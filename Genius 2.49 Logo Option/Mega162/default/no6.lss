
no6.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000000e  00800100  00003030  000030e4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00003030  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000329  0080010e  0080010e  000030f2  2**0
                  ALLOC
  3 .eeprom       0000001f  00810000  00810000  000030f2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .debug_aranges 00000060  00000000  00000000  00003111  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_pubnames 00000bf9  00000000  00000000  00003171  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00002ddd  00000000  00000000  00003d6a  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000532  00000000  00000000  00006b47  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00002421  00000000  00000000  00007079  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000510  00000000  00000000  0000949c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000199d  00000000  00000000  000099ac  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000012d3  00000000  00000000  0000b349  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 cc 00 	jmp	0x198	; 0x198 <__ctors_end>
       4:	0c 94 e9 00 	jmp	0x1d2	; 0x1d2 <__bad_interrupt>
       8:	0c 94 e9 00 	jmp	0x1d2	; 0x1d2 <__bad_interrupt>
       c:	0c 94 e9 00 	jmp	0x1d2	; 0x1d2 <__bad_interrupt>
      10:	0c 94 e9 00 	jmp	0x1d2	; 0x1d2 <__bad_interrupt>
      14:	0c 94 e9 00 	jmp	0x1d2	; 0x1d2 <__bad_interrupt>
      18:	0c 94 e9 00 	jmp	0x1d2	; 0x1d2 <__bad_interrupt>
      1c:	0c 94 e9 00 	jmp	0x1d2	; 0x1d2 <__bad_interrupt>
      20:	0c 94 e9 00 	jmp	0x1d2	; 0x1d2 <__bad_interrupt>
      24:	0c 94 e9 00 	jmp	0x1d2	; 0x1d2 <__bad_interrupt>
      28:	0c 94 e9 00 	jmp	0x1d2	; 0x1d2 <__bad_interrupt>
      2c:	0c 94 e9 00 	jmp	0x1d2	; 0x1d2 <__bad_interrupt>
      30:	0c 94 e9 00 	jmp	0x1d2	; 0x1d2 <__bad_interrupt>
      34:	0c 94 e9 00 	jmp	0x1d2	; 0x1d2 <__bad_interrupt>
      38:	0c 94 e9 00 	jmp	0x1d2	; 0x1d2 <__bad_interrupt>
      3c:	0c 94 e9 00 	jmp	0x1d2	; 0x1d2 <__bad_interrupt>
      40:	0c 94 e9 00 	jmp	0x1d2	; 0x1d2 <__bad_interrupt>
      44:	0c 94 eb 00 	jmp	0x1d6	; 0x1d6 <__vector_17>
      48:	0c 94 62 13 	jmp	0x26c4	; 0x26c4 <__vector_18>
      4c:	0c 94 27 07 	jmp	0xe4e	; 0xe4e <__vector_19>
      50:	0c 94 f7 06 	jmp	0xdee	; 0xdee <__vector_20>
      54:	0c 94 e9 00 	jmp	0x1d2	; 0x1d2 <__bad_interrupt>
      58:	0c 94 e9 00 	jmp	0x1d2	; 0x1d2 <__bad_interrupt>
      5c:	0c 94 e9 00 	jmp	0x1d2	; 0x1d2 <__bad_interrupt>
      60:	0c 94 e9 00 	jmp	0x1d2	; 0x1d2 <__bad_interrupt>
      64:	0c 94 e9 00 	jmp	0x1d2	; 0x1d2 <__bad_interrupt>
      68:	0c 94 e9 00 	jmp	0x1d2	; 0x1d2 <__bad_interrupt>
      6c:	0c 94 e9 00 	jmp	0x1d2	; 0x1d2 <__bad_interrupt>
      70:	c5 0a       	sbc	r12, r21
      72:	00 0b       	sbc	r16, r16
      74:	1f 0b       	sbc	r17, r31
      76:	26 0b       	sbc	r18, r22
      78:	2c 0b       	sbc	r18, r28
      7a:	37 0b       	sbc	r19, r23
      7c:	4c 0b       	sbc	r20, r28
      7e:	8c 0b       	sbc	r24, r28
      80:	0e 0c       	add	r0, r14
      82:	89 0c       	add	r8, r9
      84:	b2 0c       	add	r11, r2
      86:	57 0c       	add	r5, r7
      88:	15 0c       	add	r1, r5
      8a:	22 0c       	add	r2, r2
      8c:	5f 0c       	add	r5, r15
      8e:	6c 0c       	add	r6, r12
      90:	6e 0d       	add	r22, r14
      92:	b8 0c       	add	r11, r8
      94:	c5 0c       	add	r12, r5
      96:	ea 0c       	add	r14, r10
      98:	6e 0d       	add	r22, r14
      9a:	97 0c       	add	r9, r7
      9c:	ec 0c       	add	r14, r12
      9e:	b3 0b       	sbc	r27, r19
      a0:	c1 0b       	sbc	r28, r17
      a2:	a3 0c       	add	r10, r3
      a4:	0c 0d       	add	r16, r12
      a6:	1f 0d       	add	r17, r15
      a8:	25 0d       	add	r18, r5
      aa:	32 0d       	add	r19, r2
      ac:	56 0d       	add	r21, r6
      ae:	58 0d       	add	r21, r8
      b0:	64 0d       	add	r22, r4
      b2:	f9 0d       	add	r31, r9
      b4:	31 0e       	add	r3, r17
      b6:	43 0e       	add	r4, r19
      b8:	52 0e       	add	r5, r18
      ba:	89 0e       	add	r8, r25
      bc:	a0 0e       	add	r10, r16
      be:	b2 0e       	add	r11, r18
      c0:	c0 0e       	add	r12, r16
      c2:	cb 10       	cpse	r12, r11
      c4:	b3 0f       	add	r27, r19
      c6:	c5 0f       	add	r28, r21
      c8:	ed 0f       	add	r30, r29
      ca:	f9 0f       	add	r31, r25
      cc:	05 10       	cpse	r0, r5
      ce:	52 0f       	add	r21, r18
      d0:	64 0f       	add	r22, r20
      d2:	82 0f       	add	r24, r18
      d4:	8e 0f       	add	r24, r30
      d6:	16 10       	cpse	r1, r6
      d8:	2a 10       	cpse	r2, r10
      da:	69 10       	cpse	r6, r9
      dc:	76 10       	cpse	r7, r6
      de:	78 10       	cpse	r7, r8
      e0:	7f 10       	cpse	r7, r15
      e2:	89 10       	cpse	r8, r9
      e4:	96 10       	cpse	r9, r6
      e6:	9c 10       	cpse	r9, r12
      e8:	a7 10       	cpse	r10, r7
      ea:	0e 12       	cpse	r0, r30
      ec:	1d 12       	cpse	r1, r29
      ee:	4f 13       	cpse	r20, r31
      f0:	a7 12       	cpse	r10, r23
      f2:	68 12       	cpse	r6, r24
      f4:	84 12       	cpse	r8, r20
      f6:	4f 13       	cpse	r20, r31
      f8:	4f 13       	cpse	r20, r31
      fa:	c1 12       	cpse	r12, r17
      fc:	dd 12       	cpse	r13, r29
      fe:	4f 13       	cpse	r20, r31
     100:	4f 13       	cpse	r20, r31
     102:	f7 12       	cpse	r15, r23
     104:	4f 13       	cpse	r20, r31
     106:	12 13       	cpse	r17, r18
     108:	17 13       	cpse	r17, r23
     10a:	1d 13       	cpse	r17, r29
     10c:	4f 13       	cpse	r20, r31
     10e:	4f 13       	cpse	r20, r31
     110:	fd 12       	cpse	r15, r29
     112:	06 13       	cpse	r16, r22
     114:	09 13       	cpse	r16, r25
     116:	0c 13       	cpse	r16, r28
     118:	0f 13       	cpse	r16, r31
     11a:	4f 13       	cpse	r20, r31
     11c:	4f 13       	cpse	r20, r31
     11e:	22 13       	cpse	r18, r18
     120:	34 12       	cpse	r3, r20
     122:	2e 13       	cpse	r18, r30
     124:	37 13       	cpse	r19, r23
     126:	3d 13       	cpse	r19, r29
     128:	41 13       	cpse	r20, r17
     12a:	44 13       	cpse	r20, r20

0000012c <__c.3456>:
     12c:	49 6e 69 74 69 61 6c 69 7a 65 64 00                 Initialized.

00000138 <__c.3093>:
     138:	25 64 00                                            %d.

0000013b <__c.3088>:
     13b:	25 73 25 73 00                                      %s%s.

00000140 <__c.3086>:
     140:	30 32 25 2e 32 64 00                                02%.2d.

00000147 <__c.3056>:
     147:	25 64 00                                            %d.

0000014a <__c.3051>:
     14a:	30 31 25 2e 32 64 25 2e 31 64 25 2e 31 64 25 73     01%.2d%.1d%.1d%s
     15a:	25 73 25 73 00                                      %s%s.

0000015f <__c.2923>:
     15f:	41 75 74 68 6f 72 69 7a 65 64 00                    Authorized.

0000016a <__c.2898>:
     16a:	50 6f 6f 6c 52 65 73 74 61 72 74 65 64 00           PoolRestarted.

00000178 <__c.2752>:
     178:	50 6f 6f 6c 52 65 73 74 61 72 74 65 64 00           PoolRestarted.

00000186 <__c.2750>:
     186:	57 50 6f 6f 6c 3a 25 64 00                          WPool:%d.

0000018f <__c.2350>:
     18f:	50 75 6d 70 3a 25 64 00 00                          Pump:%d..

00000198 <__ctors_end>:
     198:	11 24       	eor	r1, r1
     19a:	1f be       	out	0x3f, r1	; 63
     19c:	cf ef       	ldi	r28, 0xFF	; 255
     19e:	d4 e0       	ldi	r29, 0x04	; 4
     1a0:	de bf       	out	0x3e, r29	; 62
     1a2:	cd bf       	out	0x3d, r28	; 61

000001a4 <__do_copy_data>:
     1a4:	11 e0       	ldi	r17, 0x01	; 1
     1a6:	a0 e0       	ldi	r26, 0x00	; 0
     1a8:	b1 e0       	ldi	r27, 0x01	; 1
     1aa:	e0 e3       	ldi	r30, 0x30	; 48
     1ac:	f0 e3       	ldi	r31, 0x30	; 48
     1ae:	02 c0       	rjmp	.+4      	; 0x1b4 <.do_copy_data_start>

000001b0 <.do_copy_data_loop>:
     1b0:	05 90       	lpm	r0, Z+
     1b2:	0d 92       	st	X+, r0

000001b4 <.do_copy_data_start>:
     1b4:	ae 30       	cpi	r26, 0x0E	; 14
     1b6:	b1 07       	cpc	r27, r17
     1b8:	d9 f7       	brne	.-10     	; 0x1b0 <.do_copy_data_loop>

000001ba <__do_clear_bss>:
     1ba:	14 e0       	ldi	r17, 0x04	; 4
     1bc:	ae e0       	ldi	r26, 0x0E	; 14
     1be:	b1 e0       	ldi	r27, 0x01	; 1
     1c0:	01 c0       	rjmp	.+2      	; 0x1c4 <.do_clear_bss_start>

000001c2 <.do_clear_bss_loop>:
     1c2:	1d 92       	st	X+, r1

000001c4 <.do_clear_bss_start>:
     1c4:	a7 33       	cpi	r26, 0x37	; 55
     1c6:	b1 07       	cpc	r27, r17
     1c8:	e1 f7       	brne	.-8      	; 0x1c2 <.do_clear_bss_loop>
     1ca:	0e 94 c5 11 	call	0x238a	; 0x238a <main>
     1ce:	0c 94 16 18 	jmp	0x302c	; 0x302c <_exit>

000001d2 <__bad_interrupt>:
     1d2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000001d6 <__vector_17>:

char SequencePool=0;//LivePooling Detection
char TimWatchSequence,SequenceTimeout;
char PumpTransDigit=6,PumpTotalDigit=8;

ISR(TIMER0_OVF_vect) {
     1d6:	1f 92       	push	r1
     1d8:	0f 92       	push	r0
     1da:	0f b6       	in	r0, 0x3f	; 63
     1dc:	0f 92       	push	r0
     1de:	11 24       	eor	r1, r1
     1e0:	2f 93       	push	r18
     1e2:	3f 93       	push	r19
     1e4:	5f 93       	push	r21
     1e6:	6f 93       	push	r22
     1e8:	7f 93       	push	r23
     1ea:	8f 93       	push	r24
     1ec:	9f 93       	push	r25
     1ee:	af 93       	push	r26
     1f0:	bf 93       	push	r27
    //TCNT1H=0xFD;//Ov:10ms
	//TCNT1L=0xC0;
    static char TimerExp=0;	     
    TimerExp++;
     1f2:	80 91 3a 01 	lds	r24, 0x013A
     1f6:	8f 5f       	subi	r24, 0xFF	; 255
     1f8:	80 93 3a 01 	sts	0x013A, r24
	if ((TimerExp%BlinkRate)==0){
     1fc:	60 91 11 04 	lds	r22, 0x0411
     200:	0e 94 e7 14 	call	0x29ce	; 0x29ce <__udivmodqi4>
     204:	99 23       	and	r25, r25
     206:	21 f4       	brne	.+8      	; 0x210 <__vector_17+0x3a>
		PORTE ^= 0x04;
     208:	87 b1       	in	r24, 0x07	; 7
     20a:	94 e0       	ldi	r25, 0x04	; 4
     20c:	89 27       	eor	r24, r25
     20e:	87 b9       	out	0x07, r24	; 7
	}
	TimExp++;
     210:	20 91 1f 01 	lds	r18, 0x011F
     214:	30 91 20 01 	lds	r19, 0x0120
     218:	2f 5f       	subi	r18, 0xFF	; 255
     21a:	3f 4f       	sbci	r19, 0xFF	; 255
     21c:	30 93 20 01 	sts	0x0120, r19
     220:	20 93 1f 01 	sts	0x011F, r18
	if ((TimExp%2)==0) TimSend++;
     224:	20 fd       	sbrc	r18, 0
     226:	09 c0       	rjmp	.+18     	; 0x23a <__vector_17+0x64>
     228:	80 91 23 04 	lds	r24, 0x0423
     22c:	90 91 24 04 	lds	r25, 0x0424
     230:	01 96       	adiw	r24, 0x01	; 1
     232:	90 93 24 04 	sts	0x0424, r25
     236:	80 93 23 04 	sts	0x0423, r24
	if ((TimExp%100)==0) TimWatchSequence++;
     23a:	c9 01       	movw	r24, r18
     23c:	64 e6       	ldi	r22, 0x64	; 100
     23e:	70 e0       	ldi	r23, 0x00	; 0
     240:	0e 94 f3 14 	call	0x29e6	; 0x29e6 <__udivmodhi4>
     244:	89 2b       	or	r24, r25
     246:	29 f4       	brne	.+10     	; 0x252 <__vector_17+0x7c>
     248:	80 91 de 02 	lds	r24, 0x02DE
     24c:	8f 5f       	subi	r24, 0xFF	; 255
     24e:	80 93 de 02 	sts	0x02DE, r24
	TimReceive++;
     252:	80 91 0f 04 	lds	r24, 0x040F
     256:	90 91 10 04 	lds	r25, 0x0410
     25a:	01 96       	adiw	r24, 0x01	; 1
     25c:	90 93 10 04 	sts	0x0410, r25
     260:	80 93 0f 04 	sts	0x040F, r24
	TimDelayNextPump++;
     264:	80 91 21 01 	lds	r24, 0x0121
     268:	90 91 22 01 	lds	r25, 0x0122
     26c:	01 96       	adiw	r24, 0x01	; 1
     26e:	90 93 22 01 	sts	0x0122, r25
     272:	80 93 21 01 	sts	0x0121, r24
}
     276:	bf 91       	pop	r27
     278:	af 91       	pop	r26
     27a:	9f 91       	pop	r25
     27c:	8f 91       	pop	r24
     27e:	7f 91       	pop	r23
     280:	6f 91       	pop	r22
     282:	5f 91       	pop	r21
     284:	3f 91       	pop	r19
     286:	2f 91       	pop	r18
     288:	0f 90       	pop	r0
     28a:	0f be       	out	0x3f, r0	; 63
     28c:	0f 90       	pop	r0
     28e:	1f 90       	pop	r1
     290:	18 95       	reti

00000292 <DoNothing>:
	}
}

void DoNothing(){

}
     292:	08 95       	ret

00000294 <InitMem>:

void InitMem(){
     //IFType=IT_SLAVE;
}
     294:	08 95       	ret

00000296 <GetBaudrate>:

int GetBaudrate(char brSetting){
int Result=0;
     switch(brSetting){
     296:	82 30       	cpi	r24, 0x02	; 2
     298:	59 f0       	breq	.+22     	; 0x2b0 <GetBaudrate+0x1a>
     29a:	82 30       	cpi	r24, 0x02	; 2
     29c:	18 f0       	brcs	.+6      	; 0x2a4 <GetBaudrate+0xe>
     29e:	83 30       	cpi	r24, 0x03	; 3
     2a0:	21 f4       	brne	.+8      	; 0x2aa <GetBaudrate+0x14>
     2a2:	09 c0       	rjmp	.+18     	; 0x2b6 <GetBaudrate+0x20>
     2a4:	20 e8       	ldi	r18, 0x80	; 128
     2a6:	35 e2       	ldi	r19, 0x25	; 37
     2a8:	08 c0       	rjmp	.+16     	; 0x2ba <GetBaudrate+0x24>
     2aa:	20 e0       	ldi	r18, 0x00	; 0
     2ac:	30 e0       	ldi	r19, 0x00	; 0
     2ae:	05 c0       	rjmp	.+10     	; 0x2ba <GetBaudrate+0x24>
     2b0:	20 e0       	ldi	r18, 0x00	; 0
     2b2:	3b e4       	ldi	r19, 0x4B	; 75
     2b4:	02 c0       	rjmp	.+4      	; 0x2ba <GetBaudrate+0x24>
	 case br9600: 
	      Result=9600;
	      break;
	 case br19200:
	      Result=19200;
	      break;
     2b6:	2b e9       	ldi	r18, 0x9B	; 155
     2b8:	36 e1       	ldi	r19, 0x16	; 22
	 case br5787:
	      Result=5787;
     	  break;	 
	 }
   return Result;
}
     2ba:	c9 01       	movw	r24, r18
     2bc:	08 95       	ret

000002be <GetIFType>:
char GetIFType(){
char Result=IT_NONE;
     

return Result;
}
     2be:	80 e0       	ldi	r24, 0x00	; 0
     2c0:	08 95       	ret

000002c2 <SystemComLevel>:
}



void SystemComLevel(char ComLevel){
	 sbi(PORTA,0);  // rs232 off
     2c2:	d8 9a       	sbi	0x1b, 0	; 27
	 sbi(PORTA,3);  // rs485 off
     2c4:	db 9a       	sbi	0x1b, 3	; 27
	 switch(ComLevel){
     2c6:	81 30       	cpi	r24, 0x01	; 1
     2c8:	21 f0       	breq	.+8      	; 0x2d2 <SystemComLevel+0x10>
     2ca:	82 30       	cpi	r24, 0x02	; 2
     2cc:	19 f4       	brne	.+6      	; 0x2d4 <SystemComLevel+0x12>
	 case CL_485:
		  //sbi(PORTA,0);  // rs232 off
		  cbi(PORTA,3);  // rs485 on	 
     2ce:	db 98       	cbi	0x1b, 3	; 27
     2d0:	08 95       	ret
	      break;
     case CL_232:
		  cbi(PORTA,0);  // rs232 on
     2d2:	d8 98       	cbi	0x1b, 0	; 27
     2d4:	08 95       	ret

000002d6 <StatePrintf>:
	System485(DIR_RX);//ReceiveMode
}

void StatePrintf(char *strState){
     //TerminalSendf(1,strState);
}
     2d6:	08 95       	ret

000002d8 <systemAntiFreeze>:
//15694 95.8% -> 14746 90.0%

void systemAntiFreeze(){
static char zSequence=0;

	if (IFType==IT_STANDALONE){
     2d8:	80 91 00 01 	lds	r24, 0x0100
     2dc:	82 30       	cpi	r24, 0x02	; 2
     2de:	a9 f4       	brne	.+42     	; 0x30a <systemAntiFreeze+0x32>
	    if (SequencePool>zSequence){
     2e0:	20 91 26 01 	lds	r18, 0x0126
     2e4:	80 91 35 01 	lds	r24, 0x0135
     2e8:	82 17       	cp	r24, r18
     2ea:	10 f4       	brcc	.+4      	; 0x2f0 <systemAntiFreeze+0x18>
		    TimWatchSequence=0;
     2ec:	10 92 de 02 	sts	0x02DE, r1
		}
        if (TimWatchSequence>SequenceTimeout){
     2f0:	90 91 de 02 	lds	r25, 0x02DE
     2f4:	80 91 36 04 	lds	r24, 0x0436
     2f8:	89 17       	cp	r24, r25
     2fa:	28 f4       	brcc	.+10     	; 0x306 <systemAntiFreeze+0x2e>
		    TimWatchSequence=0; 
     2fc:	10 92 de 02 	sts	0x02DE, r1
		    //SendAcknoledge(SC_FREEZE,SequenceTimeout);
		    IsRestartPooling=True;
     300:	81 e0       	ldi	r24, 0x01	; 1
     302:	80 93 03 01 	sts	0x0103, r24
		}
		zSequence=SequencePool;
     306:	20 93 35 01 	sts	0x0135, r18
     30a:	08 95       	ret

0000030c <CRC_Wayne>:

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
     30c:	70 e0       	ldi	r23, 0x00	; 0
     30e:	68 27       	eor	r22, r24
     310:	79 27       	eor	r23, r25
     312:	20 e0       	ldi	r18, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
     314:	41 e0       	ldi	r20, 0x01	; 1
     316:	50 ea       	ldi	r21, 0xA0	; 160
     318:	cb 01       	movw	r24, r22
     31a:	96 95       	lsr	r25
     31c:	87 95       	ror	r24
     31e:	60 ff       	sbrs	r22, 0
     320:	04 c0       	rjmp	.+8      	; 0x32a <CRC_Wayne+0x1e>
     322:	bc 01       	movw	r22, r24
     324:	64 27       	eor	r22, r20
     326:	75 27       	eor	r23, r21
     328:	01 c0       	rjmp	.+2      	; 0x32c <CRC_Wayne+0x20>
        else xCRC= (xCRC>> 1);
     32a:	bc 01       	movw	r22, r24
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
     32c:	2f 5f       	subi	r18, 0xFF	; 255
     32e:	28 30       	cpi	r18, 0x08	; 8
     330:	99 f7       	brne	.-26     	; 0x318 <CRC_Wayne+0xc>
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
        else xCRC= (xCRC>> 1);
    }
    return xCRC;
}
     332:	cb 01       	movw	r24, r22
     334:	08 95       	ret

00000336 <sys_delay>:

void sys_delay(unsigned int dV){
}
     336:	08 95       	ret

00000338 <System485>:

void System485(char Dir){//DIR_TX, DIR_RX	 
     switch(Dir){
     338:	81 30       	cpi	r24, 0x01	; 1
     33a:	19 f0       	breq	.+6      	; 0x342 <System485+0xa>
     33c:	82 30       	cpi	r24, 0x02	; 2
     33e:	71 f4       	brne	.+28     	; 0x35c <System485+0x24>
     340:	07 c0       	rjmp	.+14     	; 0x350 <System485+0x18>
	 case DIR_TX:
	      sbi(PORTB,1);
     342:	c1 9a       	sbi	0x18, 1	; 24
		  sbi(DDRB,1);
     344:	b9 9a       	sbi	0x17, 1	; 23
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     346:	84 ec       	ldi	r24, 0xC4	; 196
     348:	99 e0       	ldi	r25, 0x09	; 9
     34a:	01 97       	sbiw	r24, 0x01	; 1
     34c:	f1 f7       	brne	.-4      	; 0x34a <System485+0x12>
     34e:	08 95       	ret
		  _delay_ms(10);
	      break;
	 case DIR_RX:
          _delay_ms(7);
		  sbi(DDRB,1);
     350:	86 ed       	ldi	r24, 0xD6	; 214
     352:	96 e0       	ldi	r25, 0x06	; 6
     354:	01 97       	sbiw	r24, 0x01	; 1
     356:	f1 f7       	brne	.-4      	; 0x354 <System485+0x1c>
     358:	b9 9a       	sbi	0x17, 1	; 23
		  cbi(PORTB,1);		  
     35a:	c1 98       	cbi	0x18, 1	; 24
     35c:	08 95       	ret

0000035e <WayneTestSend>:
	 _uart(0,1,xData);
	 System485(DIR_RX);//ReceiveMode
}

void WayneTestSend(){
}
     35e:	08 95       	ret

00000360 <ExtractValue>:
     case CMD_REQ_GLOBAL_STATUS_2:
  	      break;
	 }	 
}

void ExtractValue(char *Source,char FirstPos,char nCount,char*Dest){//WayneRxBuffer,13,16-13,strVolume);
     360:	fc 01       	movw	r30, r24
     362:	e6 0f       	add	r30, r22
     364:	f1 1d       	adc	r31, r1
     366:	d9 01       	movw	r26, r18
     368:	90 e0       	ldi	r25, 0x00	; 0
     36a:	0d c0       	rjmp	.+26     	; 0x386 <ExtractValue+0x26>
     char i;
	 for(i=0;i<nCount;i++){
	     Dest[2*i]=(Source[FirstPos+i]>>4)+'0';
     36c:	80 81       	ld	r24, Z
     36e:	82 95       	swap	r24
     370:	8f 70       	andi	r24, 0x0F	; 15
     372:	80 5d       	subi	r24, 0xD0	; 208
     374:	8c 93       	st	X, r24
	     Dest[(2*i)+1]=(Source[FirstPos+i]&0x0F)+'0';	 
     376:	81 91       	ld	r24, Z+
     378:	8f 70       	andi	r24, 0x0F	; 15
     37a:	80 5d       	subi	r24, 0xD0	; 208
     37c:	11 96       	adiw	r26, 0x01	; 1
     37e:	8c 93       	st	X, r24
     380:	11 97       	sbiw	r26, 0x01	; 1
	 }	 
}

void ExtractValue(char *Source,char FirstPos,char nCount,char*Dest){//WayneRxBuffer,13,16-13,strVolume);
     char i;
	 for(i=0;i<nCount;i++){
     382:	9f 5f       	subi	r25, 0xFF	; 255
     384:	12 96       	adiw	r26, 0x02	; 2
     386:	94 17       	cp	r25, r20
     388:	88 f3       	brcs	.-30     	; 0x36c <ExtractValue+0xc>
	     Dest[2*i]=(Source[FirstPos+i]>>4)+'0';
	     Dest[(2*i)+1]=(Source[FirstPos+i]&0x0F)+'0';	 
	 }Dest[2*nCount]=0;
     38a:	e4 2f       	mov	r30, r20
     38c:	f0 e0       	ldi	r31, 0x00	; 0
     38e:	ee 0f       	add	r30, r30
     390:	ff 1f       	adc	r31, r31
     392:	e2 0f       	add	r30, r18
     394:	f3 1f       	adc	r31, r19
     396:	10 82       	st	Z, r1
}
     398:	08 95       	ret

0000039a <InitPumpData>:
}

void InitPumpData(){
char i;
char strSerial[20];
     if (StandaloneType==ST_GILBARCO){
     39a:	80 91 01 01 	lds	r24, 0x0101
     39e:	81 30       	cpi	r24, 0x01	; 1
     3a0:	01 f5       	brne	.+64     	; 0x3e2 <InitPumpData+0x48>
     3a2:	80 e0       	ldi	r24, 0x00	; 0
     3a4:	90 e0       	ldi	r25, 0x00	; 0
	     for(i=0;i<16;i++){
		     IsRequestTransInfo[i]=False;
			 IsRequestTotalizerInfo[i]=False;
			 zPumpStatus[i]=PUMP_NONE;
     3a6:	2e e0       	ldi	r18, 0x0E	; 14
void InitPumpData(){
char i;
char strSerial[20];
     if (StandaloneType==ST_GILBARCO){
	     for(i=0;i<16;i++){
		     IsRequestTransInfo[i]=False;
     3a8:	fc 01       	movw	r30, r24
     3aa:	e6 57       	subi	r30, 0x76	; 118
     3ac:	fd 4f       	sbci	r31, 0xFD	; 253
     3ae:	10 82       	st	Z, r1
			 IsRequestTotalizerInfo[i]=False;
     3b0:	fc 01       	movw	r30, r24
     3b2:	ed 5e       	subi	r30, 0xED	; 237
     3b4:	fb 4f       	sbci	r31, 0xFB	; 251
     3b6:	10 82       	st	Z, r1
			 zPumpStatus[i]=PUMP_NONE;
     3b8:	fc 01       	movw	r30, r24
     3ba:	e5 56       	subi	r30, 0x65	; 101
     3bc:	fd 4f       	sbci	r31, 0xFD	; 253
     3be:	20 83       	st	Z, r18
			 PumpStatus[i]=PUMP_NONE;
     3c0:	fc 01       	movw	r30, r24
     3c2:	eb 54       	subi	r30, 0x4B	; 75
     3c4:	fc 4f       	sbci	r31, 0xFC	; 252
     3c6:	20 83       	st	Z, r18
			 NoPumpCount[i]=0;
     3c8:	fc 01       	movw	r30, r24
     3ca:	eb 5d       	subi	r30, 0xDB	; 219
     3cc:	fb 4f       	sbci	r31, 0xFB	; 251
     3ce:	10 82       	st	Z, r1
			 PumpLock[i]=False;
     3d0:	fc 01       	movw	r30, r24
     3d2:	e4 53       	subi	r30, 0x34	; 52
     3d4:	fd 4f       	sbci	r31, 0xFD	; 253
     3d6:	10 82       	st	Z, r1
     3d8:	01 96       	adiw	r24, 0x01	; 1

void InitPumpData(){
char i;
char strSerial[20];
     if (StandaloneType==ST_GILBARCO){
	     for(i=0;i<16;i++){
     3da:	80 31       	cpi	r24, 0x10	; 16
     3dc:	91 05       	cpc	r25, r1
     3de:	21 f7       	brne	.-56     	; 0x3a8 <InitPumpData+0xe>
     3e0:	08 95       	ret
			 zPumpStatus[i]=PUMP_NONE;
			 PumpStatus[i]=PUMP_NONE;
			 NoPumpCount[i]=0;
			 PumpLock[i]=False;
		 }
     }else if (StandaloneType==ST_WAYNE_DART){
     3e2:	80 91 01 01 	lds	r24, 0x0101
     3e6:	82 30       	cpi	r24, 0x02	; 2
     3e8:	f1 f4       	brne	.+60     	; 0x426 <InitPumpData+0x8c>
     3ea:	80 e0       	ldi	r24, 0x00	; 0
     3ec:	90 e0       	ldi	r25, 0x00	; 0
	     for(i=0;i<16;i++){
		     IsRequestTransInfo[i]=False;
     3ee:	fc 01       	movw	r30, r24
     3f0:	e6 57       	subi	r30, 0x76	; 118
     3f2:	fd 4f       	sbci	r31, 0xFD	; 253
     3f4:	10 82       	st	Z, r1
			 IsRequestTotalizerInfo[i]=False;
     3f6:	fc 01       	movw	r30, r24
     3f8:	ed 5e       	subi	r30, 0xED	; 237
     3fa:	fb 4f       	sbci	r31, 0xFB	; 251
     3fc:	10 82       	st	Z, r1
			 zPumpStatus[i]=PW_NONE;
     3fe:	fc 01       	movw	r30, r24
     400:	e5 56       	subi	r30, 0x65	; 101
     402:	fd 4f       	sbci	r31, 0xFD	; 253
     404:	10 82       	st	Z, r1
			 PumpStatus[i]=PW_NONE;
     406:	fc 01       	movw	r30, r24
     408:	eb 54       	subi	r30, 0x4B	; 75
     40a:	fc 4f       	sbci	r31, 0xFC	; 252
     40c:	10 82       	st	Z, r1
			 NoPumpCount[i]=0;
     40e:	fc 01       	movw	r30, r24
     410:	eb 5d       	subi	r30, 0xDB	; 219
     412:	fb 4f       	sbci	r31, 0xFB	; 251
     414:	10 82       	st	Z, r1
			 PumpLock[i]=False;
     416:	fc 01       	movw	r30, r24
     418:	e4 53       	subi	r30, 0x34	; 52
     41a:	fd 4f       	sbci	r31, 0xFD	; 253
     41c:	10 82       	st	Z, r1
     41e:	01 96       	adiw	r24, 0x01	; 1
			 PumpStatus[i]=PUMP_NONE;
			 NoPumpCount[i]=0;
			 PumpLock[i]=False;
		 }
     }else if (StandaloneType==ST_WAYNE_DART){
	     for(i=0;i<16;i++){
     420:	80 31       	cpi	r24, 0x10	; 16
     422:	91 05       	cpc	r25, r1
     424:	21 f7       	brne	.-56     	; 0x3ee <InitPumpData+0x54>
     426:	08 95       	ret

00000428 <uart_init>:
     UBRR0H=0;
     UBRR0L=158;// baud 5787
     UCSR0C=(1<<URSEL0) | (1<<UPM01) | (1<<UCSZ01) | (1<<UCSZ00); // UPM01 untuk set even parity
     sei();
	 */
}
     428:	08 95       	ret

0000042a <InitSystemTimer>:

void InitSystemTimer(){
	TCCR0 |= (1 << CS02) | (1 << CS00);
     42a:	83 b7       	in	r24, 0x33	; 51
     42c:	85 60       	ori	r24, 0x05	; 5
     42e:	83 bf       	out	0x33, r24	; 51
	TIMSK |= _BV(TOIE0);
     430:	89 b7       	in	r24, 0x39	; 57
     432:	82 60       	ori	r24, 0x02	; 2
     434:	89 bf       	out	0x39, r24	; 57
}
     436:	08 95       	ret

00000438 <GetPumpID>:

char GetPumpID(char data){
     char xPumpID=0;
	 xPumpID=(data&0x0F);
	 return xPumpID;
}
     438:	8f 70       	andi	r24, 0x0F	; 15
     43a:	08 95       	ret

0000043c <GetResponse>:

char GetResponse(char data){
     char Response=0;
	 Response=((data&0xF0)>>4);
	 return Response;
}
     43c:	82 95       	swap	r24
     43e:	8f 70       	andi	r24, 0x0F	; 15
     440:	08 95       	ret

00000442 <ShiftArray>:
	 //_delay_ms(10);
}

void ShiftArray(char *strShifted, unsigned int nCount){

}
     442:	08 95       	ret

00000444 <systemServiceSPI>:

void systemServiceSPI(){
}
     444:	08 95       	ret

00000446 <SaveTransactionData>:
	    strSource[i]=strResult[i];
	    strSource[i+1]=0;
	 }
}

void SaveTransactionData(char data){
     446:	28 2f       	mov	r18, r24
     static char SavePipeline=spNone;
	 static char IdxData=0;
	 switch(SavePipeline){
     448:	80 91 2b 01 	lds	r24, 0x012B
     44c:	86 30       	cpi	r24, 0x06	; 6
     44e:	41 f1       	breq	.+80     	; 0x4a0 <SaveTransactionData+0x5a>
     450:	87 30       	cpi	r24, 0x07	; 7
     452:	30 f4       	brcc	.+12     	; 0x460 <SaveTransactionData+0x1a>
     454:	84 30       	cpi	r24, 0x04	; 4
     456:	51 f0       	breq	.+20     	; 0x46c <SaveTransactionData+0x26>
     458:	85 30       	cpi	r24, 0x05	; 5
     45a:	09 f0       	breq	.+2      	; 0x45e <SaveTransactionData+0x18>
     45c:	56 c0       	rjmp	.+172    	; 0x50a <__stack+0xb>
     45e:	17 c0       	rjmp	.+46     	; 0x48e <SaveTransactionData+0x48>
     460:	87 30       	cpi	r24, 0x07	; 7
     462:	79 f1       	breq	.+94     	; 0x4c2 <SaveTransactionData+0x7c>
     464:	8a 30       	cpi	r24, 0x0A	; 10
     466:	09 f0       	breq	.+2      	; 0x46a <SaveTransactionData+0x24>
     468:	50 c0       	rjmp	.+160    	; 0x50a <__stack+0xb>
     46a:	3b c0       	rjmp	.+118    	; 0x4e2 <SaveTransactionData+0x9c>
     case spPumpIdentifier:
	      if (IdxData==1)rxPumpId=FilterBCD(data);
     46c:	90 91 2a 01 	lds	r25, 0x012A
     470:	91 30       	cpi	r25, 0x01	; 1
     472:	29 f4       	brne	.+10     	; 0x47e <SaveTransactionData+0x38>
     474:	82 2f       	mov	r24, r18
     476:	8f 70       	andi	r24, 0x0F	; 15
     478:	80 93 3b 01 	sts	0x013B, r24
     47c:	43 c0       	rjmp	.+134    	; 0x504 <__stack+0x5>
		  else
	      if (IdxData==2)NozzleId=FilterBCD(data);
     47e:	92 30       	cpi	r25, 0x02	; 2
     480:	09 f0       	breq	.+2      	; 0x484 <SaveTransactionData+0x3e>
     482:	40 c0       	rjmp	.+128    	; 0x504 <__stack+0x5>
     484:	82 2f       	mov	r24, r18
     486:	8f 70       	andi	r24, 0x0F	; 15
     488:	80 93 e0 02 	sts	0x02E0, r24
     48c:	3b c0       	rjmp	.+118    	; 0x504 <__stack+0x5>
          IdxData++;
      	  break;
     case spProductGrade:
	      if (IdxData==0)GradeId=FilterBCD(data);
     48e:	90 91 2a 01 	lds	r25, 0x012A
     492:	99 23       	and	r25, r25
     494:	b9 f5       	brne	.+110    	; 0x504 <__stack+0x5>
     496:	82 2f       	mov	r24, r18
     498:	8f 70       	andi	r24, 0x0F	; 15
     49a:	80 93 f6 02 	sts	0x02F6, r24
     49e:	32 c0       	rjmp	.+100    	; 0x504 <__stack+0x5>
		  IdxData++;
      	  break;
     case spProductPrice:	       
          if (data!=0xF9){		      
     4a0:	29 3f       	cpi	r18, 0xF9	; 249
     4a2:	09 f4       	brne	.+2      	; 0x4a6 <SaveTransactionData+0x60>
     4a4:	40 c0       	rjmp	.+128    	; 0x526 <__stack+0x27>
		      strUnitPrice[IdxData]=BCD2Char(FilterBCD(data));
     4a6:	90 91 2a 01 	lds	r25, 0x012A
     4aa:	e9 2f       	mov	r30, r25
     4ac:	f0 e0       	ldi	r31, 0x00	; 0
	 Dest[Length]=0;
}

char FilterBCD(char data){
     char Result;
	 Result=(data&0x0F);
     4ae:	82 2f       	mov	r24, r18
     4b0:	8f 70       	andi	r24, 0x0F	; 15
}

char BCD2Char(char data){
     char Result;
	 Result=0;
	 if ((data>=0)&&(data<=9)) 
     4b2:	8a 30       	cpi	r24, 0x0A	; 10
     4b4:	10 f0       	brcs	.+4      	; 0x4ba <SaveTransactionData+0x74>
     4b6:	80 e3       	ldi	r24, 0x30	; 48
     4b8:	01 c0       	rjmp	.+2      	; 0x4bc <SaveTransactionData+0x76>
	     Result='0'+data;
     4ba:	80 5d       	subi	r24, 0xD0	; 208
	      if (IdxData==0)GradeId=FilterBCD(data);
		  IdxData++;
      	  break;
     case spProductPrice:	       
          if (data!=0xF9){		      
		      strUnitPrice[IdxData]=BCD2Char(FilterBCD(data));
     4bc:	e4 55       	subi	r30, 0x54	; 84
     4be:	fd 4f       	sbci	r31, 0xFD	; 253
     4c0:	1f c0       	rjmp	.+62     	; 0x500 <__stack+0x1>
              strUnitPrice[IdxData+1]=0;
	          IdxData++;
			  }
	  	  break;
     case spProductVolume:
          if (data!=0xFA){//Maks 7 Digit 0000123
     4c2:	2a 3f       	cpi	r18, 0xFA	; 250
     4c4:	91 f1       	breq	.+100    	; 0x52a <__stack+0x2b>
              strVolume[IdxData]=BCD2Char(FilterBCD(data));
     4c6:	90 91 2a 01 	lds	r25, 0x012A
     4ca:	e9 2f       	mov	r30, r25
     4cc:	f0 e0       	ldi	r31, 0x00	; 0
	 Dest[Length]=0;
}

char FilterBCD(char data){
     char Result;
	 Result=(data&0x0F);
     4ce:	82 2f       	mov	r24, r18
     4d0:	8f 70       	andi	r24, 0x0F	; 15
}

char BCD2Char(char data){
     char Result;
	 Result=0;
	 if ((data>=0)&&(data<=9)) 
     4d2:	8a 30       	cpi	r24, 0x0A	; 10
     4d4:	10 f0       	brcs	.+4      	; 0x4da <SaveTransactionData+0x94>
     4d6:	80 e3       	ldi	r24, 0x30	; 48
     4d8:	01 c0       	rjmp	.+2      	; 0x4dc <SaveTransactionData+0x96>
	     Result='0'+data;
     4da:	80 5d       	subi	r24, 0xD0	; 208
	          IdxData++;
			  }
	  	  break;
     case spProductVolume:
          if (data!=0xFA){//Maks 7 Digit 0000123
              strVolume[IdxData]=BCD2Char(FilterBCD(data));
     4dc:	e9 5a       	subi	r30, 0xA9	; 169
     4de:	fd 4f       	sbci	r31, 0xFD	; 253
     4e0:	0f c0       	rjmp	.+30     	; 0x500 <__stack+0x1>
              strVolume[IdxData+1]=0;
	          IdxData++;
		      }
	  	  break;
     case spProductMoney:
          if (data!=0xFB){
     4e2:	2b 3f       	cpi	r18, 0xFB	; 251
     4e4:	f1 f0       	breq	.+60     	; 0x522 <__stack+0x23>
              strAmount[IdxData]=BCD2Char(FilterBCD(data));
     4e6:	90 91 2a 01 	lds	r25, 0x012A
     4ea:	e9 2f       	mov	r30, r25
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
	 Dest[Length]=0;
}

char FilterBCD(char data){
     char Result;
	 Result=(data&0x0F);
     4ee:	82 2f       	mov	r24, r18
     4f0:	8f 70       	andi	r24, 0x0F	; 15
}

char BCD2Char(char data){
     char Result;
	 Result=0;
	 if ((data>=0)&&(data<=9)) 
     4f2:	8a 30       	cpi	r24, 0x0A	; 10
     4f4:	10 f0       	brcs	.+4      	; 0x4fa <SaveTransactionData+0xb4>
     4f6:	80 e3       	ldi	r24, 0x30	; 48
     4f8:	01 c0       	rjmp	.+2      	; 0x4fc <SaveTransactionData+0xb6>
	     Result='0'+data;
     4fa:	80 5d       	subi	r24, 0xD0	; 208
	          IdxData++;
		      }
	  	  break;
     case spProductMoney:
          if (data!=0xFB){
              strAmount[IdxData]=BCD2Char(FilterBCD(data));
     4fc:	e5 55       	subi	r30, 0x55	; 85
     4fe:	fc 4f       	sbci	r31, 0xFC	; 252
     500:	80 83       	st	Z, r24
              strAmount[IdxData+1]=0;
     502:	11 82       	std	Z+1, r1	; 0x01
              IdxData++;
     504:	9f 5f       	subi	r25, 0xFF	; 255
     506:	90 93 2a 01 	sts	0x012A, r25
     case spLRC:
	  	  break;	 
	 }

	 //Pipeline detection
	 if (data==0xF8){
     50a:	28 3f       	cpi	r18, 0xF8	; 248
     50c:	11 f4       	brne	.+4      	; 0x512 <__stack+0x13>
	     SavePipeline=spPumpIdentifier;
     50e:	84 e0       	ldi	r24, 0x04	; 4
     510:	0f c0       	rjmp	.+30     	; 0x530 <__stack+0x31>
		 IdxData=0;
	 }else if (data==0xF6){
     512:	26 3f       	cpi	r18, 0xF6	; 246
     514:	11 f4       	brne	.+4      	; 0x51a <__stack+0x1b>
	     SavePipeline=spProductGrade;
     516:	85 e0       	ldi	r24, 0x05	; 5
     518:	0b c0       	rjmp	.+22     	; 0x530 <__stack+0x31>
		 IdxData=0;
	 }else if (data==0xF7){
     51a:	27 3f       	cpi	r18, 0xF7	; 247
     51c:	11 f4       	brne	.+4      	; 0x522 <__stack+0x23>
	     SavePipeline=spProductPrice;
     51e:	86 e0       	ldi	r24, 0x06	; 6
     520:	07 c0       	rjmp	.+14     	; 0x530 <__stack+0x31>
		 IdxData=0;
	 }else if (data==0xF9){
     522:	29 3f       	cpi	r18, 0xF9	; 249
     524:	11 f4       	brne	.+4      	; 0x52a <__stack+0x2b>
	     SavePipeline=spProductVolume;
     526:	87 e0       	ldi	r24, 0x07	; 7
     528:	03 c0       	rjmp	.+6      	; 0x530 <__stack+0x31>
		 IdxData=0;
	 }else if (data==0xFA){
     52a:	2a 3f       	cpi	r18, 0xFA	; 250
     52c:	31 f4       	brne	.+12     	; 0x53a <__stack+0x3b>
	     SavePipeline=spProductMoney;
     52e:	8a e0       	ldi	r24, 0x0A	; 10
     530:	80 93 2b 01 	sts	0x012B, r24
		 IdxData=0;
     534:	10 92 2a 01 	sts	0x012A, r1
     538:	08 95       	ret
	 }else if (data==0xFB){
     53a:	2b 3f       	cpi	r18, 0xFB	; 251
     53c:	49 f4       	brne	.+18     	; 0x550 <__stack+0x51>
	     PumpTransDigit=IdxData;
     53e:	80 91 2a 01 	lds	r24, 0x012A
     542:	80 93 0b 01 	sts	0x010B, r24
	     SavePipeline=spLRC;
     546:	8b e0       	ldi	r24, 0x0B	; 11
     548:	80 93 2b 01 	sts	0x012B, r24
		 IdxData=0;
     54c:	10 92 2a 01 	sts	0x012A, r1
     550:	08 95       	ret

00000552 <SaveTotalizerData>:
	 }
}

void SaveTotalizerData(char data){
     552:	28 2f       	mov	r18, r24
     static char SavePipeline=spNone;
	 static char IdxData=0;

	 switch(SavePipeline){
     554:	80 91 29 01 	lds	r24, 0x0129
     558:	82 30       	cpi	r24, 0x02	; 2
     55a:	b9 f0       	breq	.+46     	; 0x58a <SaveTotalizerData+0x38>
     55c:	83 30       	cpi	r24, 0x03	; 3
     55e:	09 f4       	brne	.+2      	; 0x562 <SaveTotalizerData+0x10>
     560:	4a c0       	rjmp	.+148    	; 0x5f6 <SaveTotalizerData+0xa4>
     562:	81 30       	cpi	r24, 0x01	; 1
     564:	09 f0       	breq	.+2      	; 0x568 <SaveTotalizerData+0x16>
     566:	7e c0       	rjmp	.+252    	; 0x664 <SaveTotalizerData+0x112>
	 case spTotalizerGrade:
	      if (IdxData==0){
     568:	90 91 28 01 	lds	r25, 0x0128
     56c:	99 23       	and	r25, r25
     56e:	49 f4       	brne	.+18     	; 0x582 <SaveTotalizerData+0x30>
	 Dest[Length]=0;
}

char FilterBCD(char data){
     char Result;
	 Result=(data&0x0F);
     570:	82 2f       	mov	r24, r18
     572:	8f 70       	andi	r24, 0x0F	; 15
	 static char IdxData=0;

	 switch(SavePipeline){
	 case spTotalizerGrade:
	      if (IdxData==0){
		      TGradeId=FilterBCD(data);
     574:	80 93 dc 02 	sts	0x02DC, r24
			  //_uart(1,1,BCD2Char(TGradeId));
			  if (TGradeId>=5)TGradeId=5;
     578:	85 30       	cpi	r24, 0x05	; 5
     57a:	18 f0       	brcs	.+6      	; 0x582 <SaveTotalizerData+0x30>
     57c:	85 e0       	ldi	r24, 0x05	; 5
     57e:	80 93 dc 02 	sts	0x02DC, r24
			  }
          IdxData++; 
     582:	9f 5f       	subi	r25, 0xFF	; 255
     584:	90 93 28 01 	sts	0x0128, r25
     588:	6d c0       	rjmp	.+218    	; 0x664 <SaveTotalizerData+0x112>
	      break;
	 case spTotalizerVolume:
          if ((data&0xF0)==0xE0){
     58a:	82 2f       	mov	r24, r18
     58c:	80 7f       	andi	r24, 0xF0	; 240
     58e:	80 3e       	cpi	r24, 0xE0	; 224
     590:	09 f0       	breq	.+2      	; 0x594 <SaveTotalizerData+0x42>
     592:	68 c0       	rjmp	.+208    	; 0x664 <SaveTotalizerData+0x112>
		      PumpTotalizer.TotalGrade[TGradeId].strVolume[IdxData]=BCD2Char(FilterBCD(data));
     594:	50 91 dc 02 	lds	r21, 0x02DC
     598:	30 91 28 01 	lds	r19, 0x0128
     59c:	63 2f       	mov	r22, r19
     59e:	70 e0       	ldi	r23, 0x00	; 0
	 Dest[Length]=0;
}

char FilterBCD(char data){
     char Result;
	 Result=(data&0x0F);
     5a0:	82 2f       	mov	r24, r18
     5a2:	8f 70       	andi	r24, 0x0F	; 15
}

char BCD2Char(char data){
     char Result;
	 Result=0;
	 if ((data>=0)&&(data<=9)) 
     5a4:	8a 30       	cpi	r24, 0x0A	; 10
     5a6:	10 f0       	brcs	.+4      	; 0x5ac <SaveTotalizerData+0x5a>
     5a8:	40 e3       	ldi	r20, 0x30	; 48
     5aa:	02 c0       	rjmp	.+4      	; 0x5b0 <SaveTotalizerData+0x5e>
	     Result='0'+data;
     5ac:	48 2f       	mov	r20, r24
     5ae:	40 5d       	subi	r20, 0xD0	; 208
			  }
          IdxData++; 
	      break;
	 case spTotalizerVolume:
          if ((data&0xF0)==0xE0){
		      PumpTotalizer.TotalGrade[TGradeId].strVolume[IdxData]=BCD2Char(FilterBCD(data));
     5b0:	85 2f       	mov	r24, r21
     5b2:	90 e0       	ldi	r25, 0x00	; 0
     5b4:	fc 01       	movw	r30, r24
     5b6:	b5 e0       	ldi	r27, 0x05	; 5
     5b8:	ee 0f       	add	r30, r30
     5ba:	ff 1f       	adc	r31, r31
     5bc:	ba 95       	dec	r27
     5be:	e1 f7       	brne	.-8      	; 0x5b8 <SaveTotalizerData+0x66>
     5c0:	88 0f       	add	r24, r24
     5c2:	99 1f       	adc	r25, r25
     5c4:	e8 1b       	sub	r30, r24
     5c6:	f9 0b       	sbc	r31, r25
     5c8:	e6 0f       	add	r30, r22
     5ca:	f7 1f       	adc	r31, r23
     5cc:	e9 50       	subi	r30, 0x09	; 9
     5ce:	fd 4f       	sbci	r31, 0xFD	; 253
     5d0:	40 83       	st	Z, r20
			  //_uart(1,1,PumpTotalizer.TotalGrade[TGradeId].strVolume[IdxData]);

		      PumpTotalizer.TotalGrade[TGradeId].strVolume[IdxData+1]=0;
     5d2:	85 2f       	mov	r24, r21
     5d4:	90 e0       	ldi	r25, 0x00	; 0
     5d6:	fc 01       	movw	r30, r24
     5d8:	55 e0       	ldi	r21, 0x05	; 5
     5da:	ee 0f       	add	r30, r30
     5dc:	ff 1f       	adc	r31, r31
     5de:	5a 95       	dec	r21
     5e0:	e1 f7       	brne	.-8      	; 0x5da <SaveTotalizerData+0x88>
     5e2:	88 0f       	add	r24, r24
     5e4:	99 1f       	adc	r25, r25
     5e6:	e8 1b       	sub	r30, r24
     5e8:	f9 0b       	sbc	r31, r25
     5ea:	e9 50       	subi	r30, 0x09	; 9
     5ec:	fd 4f       	sbci	r31, 0xFD	; 253
     5ee:	e6 0f       	add	r30, r22
     5f0:	f7 1f       	adc	r31, r23
     5f2:	11 82       	std	Z+1, r1	; 0x01
     5f4:	34 c0       	rjmp	.+104    	; 0x65e <SaveTotalizerData+0x10c>
		      //TVolume[TGradeId][IdxData+1]=0;
		      IdxData++;
		  }
	      break;
	 case spTotalizerMoney:
          if ((data&0xF0)==0xE0){
     5f6:	82 2f       	mov	r24, r18
     5f8:	80 7f       	andi	r24, 0xF0	; 240
     5fa:	80 3e       	cpi	r24, 0xE0	; 224
     5fc:	99 f5       	brne	.+102    	; 0x664 <SaveTotalizerData+0x112>
	          //TMoney[TGradeId][IdxData]=BCD2Char(FilterBCD(data));
		      //TMoney[TGradeId][IdxData+1]=0;
		      PumpTotalizer.TotalGrade[TGradeId].strMoney[IdxData]=BCD2Char(FilterBCD(data));
     5fe:	70 91 dc 02 	lds	r23, 0x02DC
     602:	30 91 28 01 	lds	r19, 0x0128
     606:	43 2f       	mov	r20, r19
     608:	50 e0       	ldi	r21, 0x00	; 0
	 Dest[Length]=0;
}

char FilterBCD(char data){
     char Result;
	 Result=(data&0x0F);
     60a:	82 2f       	mov	r24, r18
     60c:	8f 70       	andi	r24, 0x0F	; 15
}

char BCD2Char(char data){
     char Result;
	 Result=0;
	 if ((data>=0)&&(data<=9)) 
     60e:	8a 30       	cpi	r24, 0x0A	; 10
     610:	10 f0       	brcs	.+4      	; 0x616 <SaveTotalizerData+0xc4>
     612:	60 e3       	ldi	r22, 0x30	; 48
     614:	02 c0       	rjmp	.+4      	; 0x61a <SaveTotalizerData+0xc8>
	     Result='0'+data;
     616:	68 2f       	mov	r22, r24
     618:	60 5d       	subi	r22, 0xD0	; 208
	      break;
	 case spTotalizerMoney:
          if ((data&0xF0)==0xE0){
	          //TMoney[TGradeId][IdxData]=BCD2Char(FilterBCD(data));
		      //TMoney[TGradeId][IdxData+1]=0;
		      PumpTotalizer.TotalGrade[TGradeId].strMoney[IdxData]=BCD2Char(FilterBCD(data));
     61a:	87 2f       	mov	r24, r23
     61c:	90 e0       	ldi	r25, 0x00	; 0
     61e:	fc 01       	movw	r30, r24
     620:	b5 e0       	ldi	r27, 0x05	; 5
     622:	ee 0f       	add	r30, r30
     624:	ff 1f       	adc	r31, r31
     626:	ba 95       	dec	r27
     628:	e1 f7       	brne	.-8      	; 0x622 <SaveTotalizerData+0xd0>
     62a:	88 0f       	add	r24, r24
     62c:	99 1f       	adc	r25, r25
     62e:	e8 1b       	sub	r30, r24
     630:	f9 0b       	sbc	r31, r25
     632:	e9 50       	subi	r30, 0x09	; 9
     634:	fd 4f       	sbci	r31, 0xFD	; 253
     636:	e4 0f       	add	r30, r20
     638:	f5 1f       	adc	r31, r21
     63a:	67 87       	std	Z+15, r22	; 0x0f
			  //_uart(1,1,PumpTotalizer.TotalGrade[TGradeId].strMoney[IdxData]);
		      PumpTotalizer.TotalGrade[TGradeId].strMoney[IdxData+1]=0;
     63c:	87 2f       	mov	r24, r23
     63e:	90 e0       	ldi	r25, 0x00	; 0
     640:	fc 01       	movw	r30, r24
     642:	75 e0       	ldi	r23, 0x05	; 5
     644:	ee 0f       	add	r30, r30
     646:	ff 1f       	adc	r31, r31
     648:	7a 95       	dec	r23
     64a:	e1 f7       	brne	.-8      	; 0x644 <SaveTotalizerData+0xf2>
     64c:	88 0f       	add	r24, r24
     64e:	99 1f       	adc	r25, r25
     650:	e8 1b       	sub	r30, r24
     652:	f9 0b       	sbc	r31, r25
     654:	e9 50       	subi	r30, 0x09	; 9
     656:	fd 4f       	sbci	r31, 0xFD	; 253
     658:	e4 0f       	add	r30, r20
     65a:	f5 1f       	adc	r31, r21
     65c:	10 8a       	std	Z+16, r1	; 0x10
  		      IdxData++;
     65e:	3f 5f       	subi	r19, 0xFF	; 255
     660:	30 93 28 01 	sts	0x0128, r19
          }
	      break;		  
	 }	 
	//Grade Data Next Select 
	if (data==0xF6){
     664:	26 3f       	cpi	r18, 0xF6	; 246
     666:	21 f4       	brne	.+8      	; 0x670 <SaveTotalizerData+0x11e>
	    IdxData=0;
     668:	10 92 28 01 	sts	0x0128, r1
	    SavePipeline=spTotalizerGrade;
     66c:	81 e0       	ldi	r24, 0x01	; 1
     66e:	13 c0       	rjmp	.+38     	; 0x696 <SaveTotalizerData+0x144>
		//_uart(1,1,0x0D);
		}
    else
	if (data==0xF9){
     670:	29 3f       	cpi	r18, 0xF9	; 249
     672:	11 f4       	brne	.+4      	; 0x678 <SaveTotalizerData+0x126>
	    SavePipeline=spTotalizerVolume;
     674:	82 e0       	ldi	r24, 0x02	; 2
     676:	07 c0       	rjmp	.+14     	; 0x686 <SaveTotalizerData+0x134>
		IdxData=0;
		//_uart(1,1,0x0D);
		//_uart(1,1,'V');
		}
	else
	if (data==0xFA){
     678:	2a 3f       	cpi	r18, 0xFA	; 250
     67a:	51 f4       	brne	.+20     	; 0x690 <SaveTotalizerData+0x13e>
	    PumpTotalDigit=IdxData;
     67c:	80 91 28 01 	lds	r24, 0x0128
     680:	80 93 0c 01 	sts	0x010C, r24
	    SavePipeline=spTotalizerMoney;
     684:	83 e0       	ldi	r24, 0x03	; 3
     686:	80 93 29 01 	sts	0x0129, r24
		IdxData=0;
     68a:	10 92 28 01 	sts	0x0128, r1
     68e:	08 95       	ret
		//_uart(1,1,0x0D);
		//_uart(1,1,'M');
		}
    else
	if (data==0xF4)SavePipeline=spTotalizerPPU1;
     690:	24 3f       	cpi	r18, 0xF4	; 244
     692:	21 f4       	brne	.+8      	; 0x69c <SaveTotalizerData+0x14a>
     694:	88 e0       	ldi	r24, 0x08	; 8
     696:	80 93 29 01 	sts	0x0129, r24
     69a:	08 95       	ret
	else
	if (data==0xF5)SavePipeline=spTotalizerPPU2;
     69c:	25 3f       	cpi	r18, 0xF5	; 245
     69e:	19 f4       	brne	.+6      	; 0x6a6 <SaveTotalizerData+0x154>
     6a0:	89 e0       	ldi	r24, 0x09	; 9
     6a2:	80 93 29 01 	sts	0x0129, r24
     6a6:	08 95       	ret

000006a8 <OnReceive1>:
            strRFID[8]=0;
     sprintf_P(strSerial,PSTR("RFID:%s"),strRFID);
     _uart_print(1,0,strSerial);
	 }
	 */
}
     6a8:	08 95       	ret

000006aa <UpdateMoney>:

void UpdateMoney(char *Dest, char *Src , unsigned int Length){
     6aa:	cf 93       	push	r28
     6ac:	df 93       	push	r29
     6ae:	ec 01       	movw	r28, r24
     6b0:	20 e0       	ldi	r18, 0x00	; 0
     6b2:	0b c0       	rjmp	.+22     	; 0x6ca <UpdateMoney+0x20>
     unsigned char i;
	 for(i=0;i<Length;i++){
	     Dest[i]=Src[Length-i];
     6b4:	fe 01       	movw	r30, r28
     6b6:	e8 0f       	add	r30, r24
     6b8:	f9 1f       	adc	r31, r25
     6ba:	da 01       	movw	r26, r20
     6bc:	a8 1b       	sub	r26, r24
     6be:	b9 0b       	sbc	r27, r25
     6c0:	a6 0f       	add	r26, r22
     6c2:	b7 1f       	adc	r27, r23
     6c4:	8c 91       	ld	r24, X
     6c6:	80 83       	st	Z, r24
	 */
}

void UpdateMoney(char *Dest, char *Src , unsigned int Length){
     unsigned char i;
	 for(i=0;i<Length;i++){
     6c8:	2f 5f       	subi	r18, 0xFF	; 255
     6ca:	82 2f       	mov	r24, r18
     6cc:	90 e0       	ldi	r25, 0x00	; 0
     6ce:	84 17       	cp	r24, r20
     6d0:	95 07       	cpc	r25, r21
     6d2:	80 f3       	brcs	.-32     	; 0x6b4 <UpdateMoney+0xa>
	     Dest[i]=Src[Length-i];
	 }
	 Dest[Length]=0;
     6d4:	c4 0f       	add	r28, r20
     6d6:	d5 1f       	adc	r29, r21
     6d8:	18 82       	st	Y, r1
}
     6da:	df 91       	pop	r29
     6dc:	cf 91       	pop	r28
     6de:	08 95       	ret

000006e0 <FilterBCD>:

char FilterBCD(char data){
     char Result;
	 Result=(data&0x0F);
	 return Result;
}
     6e0:	8f 70       	andi	r24, 0x0F	; 15
     6e2:	08 95       	ret

000006e4 <BCD2Char>:

char BCD2Char(char data){
     char Result;
	 Result=0;
	 if ((data>=0)&&(data<=9)) 
     6e4:	8a 30       	cpi	r24, 0x0A	; 10
     6e6:	10 f0       	brcs	.+4      	; 0x6ec <BCD2Char+0x8>
     6e8:	80 e3       	ldi	r24, 0x30	; 48
     6ea:	08 95       	ret
	     Result='0'+data;
     6ec:	80 5d       	subi	r24, 0xD0	; 208
     else Result='0';
	 return Result;
}
     6ee:	08 95       	ret

000006f0 <ShiftData>:

void ShiftData(char data){//data [0]..[10]
     6f0:	98 2f       	mov	r25, r24
     6f2:	ed e0       	ldi	r30, 0x0D	; 13
     6f4:	f4 e0       	ldi	r31, 0x04	; 4
     char i;
	 for(i=11;i>0;i--){//0..10
	    zDataBuffer[i]=zDataBuffer[i-1];
     6f6:	80 81       	ld	r24, Z
     6f8:	81 83       	std	Z+1, r24	; 0x01
     6fa:	31 97       	sbiw	r30, 0x01	; 1
	 return Result;
}

void ShiftData(char data){//data [0]..[10]
     char i;
	 for(i=11;i>0;i--){//0..10
     6fc:	84 e0       	ldi	r24, 0x04	; 4
     6fe:	e2 30       	cpi	r30, 0x02	; 2
     700:	f8 07       	cpc	r31, r24
     702:	c9 f7       	brne	.-14     	; 0x6f6 <ShiftData+0x6>
	    zDataBuffer[i]=zDataBuffer[i-1];
	 }
	 zDataBuffer[0]=data;
     704:	91 83       	std	Z+1, r25	; 0x01
}
     706:	08 95       	ret

00000708 <SetReceiveLine>:

void SetReceiveLine(char RecLine){
     stReceiveCom0=RecLine;
     708:	80 93 04 01 	sts	0x0104, r24
}
     70c:	08 95       	ret

0000070e <GetReceiveLine>:

char GetReceiveLine(){
     return stReceiveCom0;
}
     70e:	80 91 04 01 	lds	r24, 0x0104
     712:	08 95       	ret

00000714 <StrPosCopy>:



void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
     714:	cf 93       	push	r28
     716:	df 93       	push	r29
     718:	eb 01       	movw	r28, r22
     71a:	da 01       	movw	r26, r20
     71c:	a8 0f       	add	r26, r24
     71e:	b9 1f       	adc	r27, r25
     720:	40 e0       	ldi	r20, 0x00	; 0
     722:	50 e0       	ldi	r21, 0x00	; 0
     724:	07 c0       	rjmp	.+14     	; 0x734 <StrPosCopy+0x20>
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
     726:	fe 01       	movw	r30, r28
     728:	e4 0f       	add	r30, r20
     72a:	f5 1f       	adc	r31, r21
     72c:	8d 91       	ld	r24, X+
     72e:	80 83       	st	Z, r24



void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
     730:	4f 5f       	subi	r20, 0xFF	; 255
     732:	5f 4f       	sbci	r21, 0xFF	; 255
     734:	42 17       	cp	r20, r18
     736:	53 07       	cpc	r21, r19
     738:	b0 f3       	brcs	.-20     	; 0x726 <StrPosCopy+0x12>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
     73a:	c2 0f       	add	r28, r18
     73c:	d3 1f       	adc	r29, r19
     73e:	18 82       	st	Y, r1
}
     740:	df 91       	pop	r29
     742:	cf 91       	pop	r28
     744:	08 95       	ret

00000746 <CharPosCopy>:

char CharPosCopy(char *Source, unsigned int IdxSource){
     746:	fb 01       	movw	r30, r22
     748:	e8 0f       	add	r30, r24
     74a:	f9 1f       	adc	r31, r25
     char Result;
          Result=Source[IdxSource];
	 return Result;
}
     74c:	80 81       	ld	r24, Z
     74e:	08 95       	ret

00000750 <HexToChar>:
	 }
}

char HexToChar(char xHex){
char Result='0';
     if (xHex<10) Result='0'+xHex;
     750:	8a 30       	cpi	r24, 0x0A	; 10
     752:	10 f4       	brcc	.+4      	; 0x758 <HexToChar+0x8>
     754:	80 5d       	subi	r24, 0xD0	; 208
     756:	08 95       	ret
	 else 
	 if (xHex<16) Result='A'+(xHex-10); 
     758:	80 31       	cpi	r24, 0x10	; 16
     75a:	10 f0       	brcs	.+4      	; 0x760 <HexToChar+0x10>
     75c:	80 e3       	ldi	r24, 0x30	; 48
     75e:	08 95       	ret
     760:	89 5c       	subi	r24, 0xC9	; 201
	 else Result='0';
     return Result;
}
     762:	08 95       	ret

00000764 <StrPosCopyReverse>:

//Copy Reverse Filtered BCD String
void StrPosCopyReverse(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
     764:	cf 93       	push	r28
     766:	df 93       	push	r29
     768:	eb 01       	movw	r28, r22
     76a:	da 01       	movw	r26, r20
     76c:	a8 0f       	add	r26, r24
     76e:	b9 1f       	adc	r27, r25
     770:	40 e0       	ldi	r20, 0x00	; 0
     772:	50 e0       	ldi	r21, 0x00	; 0
     774:	0e c0       	rjmp	.+28     	; 0x792 <StrPosCopyReverse+0x2e>
	 Dest[Length]=0;
}

char FilterBCD(char data){
     char Result;
	 Result=(data&0x0F);
     776:	8c 91       	ld	r24, X
     778:	8f 70       	andi	r24, 0x0F	; 15
}

char BCD2Char(char data){
     char Result;
	 Result=0;
	 if ((data>=0)&&(data<=9)) 
     77a:	8a 30       	cpi	r24, 0x0A	; 10
     77c:	10 f0       	brcs	.+4      	; 0x782 <StrPosCopyReverse+0x1e>
     77e:	80 e3       	ldi	r24, 0x30	; 48
     780:	01 c0       	rjmp	.+2      	; 0x784 <StrPosCopyReverse+0x20>
	     Result='0'+data;
     782:	80 5d       	subi	r24, 0xD0	; 208

//Copy Reverse Filtered BCD String
void StrPosCopyReverse(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
     unsigned int i;
	 for (i=0;i<Length;i++){
	      Dest[i]=BCD2Char(FilterBCD(Source[IdxSource-i]));
     784:	fe 01       	movw	r30, r28
     786:	e4 0f       	add	r30, r20
     788:	f5 1f       	adc	r31, r21
     78a:	80 83       	st	Z, r24
}

//Copy Reverse Filtered BCD String
void StrPosCopyReverse(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
     unsigned int i;
	 for (i=0;i<Length;i++){
     78c:	4f 5f       	subi	r20, 0xFF	; 255
     78e:	5f 4f       	sbci	r21, 0xFF	; 255
     790:	11 97       	sbiw	r26, 0x01	; 1
     792:	42 17       	cp	r20, r18
     794:	53 07       	cpc	r21, r19
     796:	78 f3       	brcs	.-34     	; 0x776 <StrPosCopyReverse+0x12>
	      Dest[i]=BCD2Char(FilterBCD(Source[IdxSource-i]));
	 }Dest[Length]=0;
     798:	c2 0f       	add	r28, r18
     79a:	d3 1f       	adc	r29, r19
     79c:	18 82       	st	Y, r1
}
     79e:	df 91       	pop	r29
     7a0:	cf 91       	pop	r28
     7a2:	08 95       	ret

000007a4 <uartGilbarco>:
void StartupInfo(){
    _uart_printf(1,1,PSTR("Initialized"));
}

void uartGilbarco(){
}
     7a4:	08 95       	ret

000007a6 <FillChar>:

void FillChar(char *strMemory, unsigned int Length,char data){
     7a6:	20 e0       	ldi	r18, 0x00	; 0
     7a8:	30 e0       	ldi	r19, 0x00	; 0
     7aa:	06 c0       	rjmp	.+12     	; 0x7b8 <FillChar+0x12>
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
     7ac:	fc 01       	movw	r30, r24
     7ae:	e2 0f       	add	r30, r18
     7b0:	f3 1f       	adc	r31, r19
     7b2:	40 83       	st	Z, r20
void uartGilbarco(){
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
     7b4:	2f 5f       	subi	r18, 0xFF	; 255
     7b6:	3f 4f       	sbci	r19, 0xFF	; 255
     7b8:	26 17       	cp	r18, r22
     7ba:	37 07       	cpc	r19, r23
     7bc:	b8 f3       	brcs	.-18     	; 0x7ac <FillChar+0x6>
	     strMemory[i]=data;
	 }
}
     7be:	08 95       	ret

000007c0 <StartupInfo>:
	 }Dest[Length]=0;
}


void StartupInfo(){
    _uart_printf(1,1,PSTR("Initialized"));
     7c0:	81 e0       	ldi	r24, 0x01	; 1
     7c2:	61 e0       	ldi	r22, 0x01	; 1
     7c4:	4c e2       	ldi	r20, 0x2C	; 44
     7c6:	51 e0       	ldi	r21, 0x01	; 1
     7c8:	0e 94 be 14 	call	0x297c	; 0x297c <_uart_printf>
}
     7cc:	08 95       	ret

000007ce <AddZeroLead>:
	   }//Zeroed[Length-ZeroPos]=0;
	 }     
   }
}

void AddZeroLead(char *String,unsigned char Size){// 1234 ->0000001234
     7ce:	bf 92       	push	r11
     7d0:	cf 92       	push	r12
     7d2:	df 92       	push	r13
     7d4:	ef 92       	push	r14
     7d6:	ff 92       	push	r15
     7d8:	0f 93       	push	r16
     7da:	1f 93       	push	r17
     7dc:	df 93       	push	r29
     7de:	cf 93       	push	r28
     7e0:	cd b7       	in	r28, 0x3d	; 61
     7e2:	de b7       	in	r29, 0x3e	; 62
     7e4:	64 97       	sbiw	r28, 0x14	; 20
     7e6:	0f b6       	in	r0, 0x3f	; 63
     7e8:	f8 94       	cli
     7ea:	de bf       	out	0x3e, r29	; 62
     7ec:	0f be       	out	0x3f, r0	; 63
     7ee:	cd bf       	out	0x3d, r28	; 61
     7f0:	8c 01       	movw	r16, r24
     char i,Length,strAdded[20];
     Length=strlen(String);
     7f2:	fc 01       	movw	r30, r24
     7f4:	01 90       	ld	r0, Z+
     7f6:	00 20       	and	r0, r0
     7f8:	e9 f7       	brne	.-6      	; 0x7f4 <AddZeroLead+0x26>
     7fa:	31 97       	sbiw	r30, 0x01	; 1
     7fc:	2e 2f       	mov	r18, r30
     7fe:	28 1b       	sub	r18, r24

	 if (Size>Length){
     800:	26 17       	cp	r18, r22
     802:	e0 f5       	brcc	.+120    	; 0x87c <AddZeroLead+0xae>
     804:	7e 01       	movw	r14, r28
     806:	08 94       	sec
     808:	e1 1c       	adc	r14, r1
     80a:	f1 1c       	adc	r15, r1
     80c:	f7 01       	movw	r30, r14
	   }//Zeroed[Length-ZeroPos]=0;
	 }     
   }
}

void AddZeroLead(char *String,unsigned char Size){// 1234 ->0000001234
     80e:	be 2c       	mov	r11, r14
     char i,Length,strAdded[20];
     Length=strlen(String);

	 if (Size>Length){
         for(i=0;i<Size;i++){
	         strAdded[i]='0';
     810:	90 e3       	ldi	r25, 0x30	; 48
     812:	01 c0       	rjmp	.+2      	; 0x816 <AddZeroLead+0x48>
     814:	91 93       	st	Z+, r25
void AddZeroLead(char *String,unsigned char Size){// 1234 ->0000001234
     char i,Length,strAdded[20];
     Length=strlen(String);

	 if (Size>Length){
         for(i=0;i<Size;i++){
     816:	8e 2f       	mov	r24, r30
     818:	8b 19       	sub	r24, r11
     81a:	86 17       	cp	r24, r22
     81c:	d8 f3       	brcs	.-10     	; 0x814 <AddZeroLead+0x46>
	         strAdded[i]='0';
	     }strAdded[Size]=0;
     81e:	46 2f       	mov	r20, r22
     820:	50 e0       	ldi	r21, 0x00	; 0
     822:	ce 01       	movw	r24, r28
     824:	01 96       	adiw	r24, 0x01	; 1
     826:	fc 01       	movw	r30, r24
     828:	e4 0f       	add	r30, r20
     82a:	f5 1f       	adc	r31, r21
     82c:	10 82       	st	Z, r1
	     //Copy
         for(i=(Size-Length);i<Size;i++){
     82e:	76 2f       	mov	r23, r22
     830:	72 1b       	sub	r23, r18
     832:	6c 01       	movw	r12, r24
	         strAdded[i]=String[i-(Size-Length)];
     834:	30 e0       	ldi	r19, 0x00	; 0
     836:	24 1b       	sub	r18, r20
     838:	35 0b       	sbc	r19, r21
     83a:	0c c0       	rjmp	.+24     	; 0x854 <AddZeroLead+0x86>
     83c:	e7 2f       	mov	r30, r23
     83e:	f0 e0       	ldi	r31, 0x00	; 0
     840:	d6 01       	movw	r26, r12
     842:	ae 0f       	add	r26, r30
     844:	bf 1f       	adc	r27, r31
     846:	e0 0f       	add	r30, r16
     848:	f1 1f       	adc	r31, r17
     84a:	e2 0f       	add	r30, r18
     84c:	f3 1f       	adc	r31, r19
     84e:	80 81       	ld	r24, Z
     850:	8c 93       	st	X, r24
	 if (Size>Length){
         for(i=0;i<Size;i++){
	         strAdded[i]='0';
	     }strAdded[Size]=0;
	     //Copy
         for(i=(Size-Length);i<Size;i++){
     852:	7f 5f       	subi	r23, 0xFF	; 255
     854:	76 17       	cp	r23, r22
     856:	90 f3       	brcs	.-28     	; 0x83c <AddZeroLead+0x6e>
	         strAdded[i]=String[i-(Size-Length)];
	     }strAdded[Size]=0;
     858:	4c 0d       	add	r20, r12
     85a:	5d 1d       	adc	r21, r13
     85c:	da 01       	movw	r26, r20
     85e:	1c 92       	st	X, r1
     860:	f8 01       	movw	r30, r16
     862:	04 c0       	rjmp	.+8      	; 0x86c <AddZeroLead+0x9e>
	     //Zeroed
         for(i=0;i<Size;i++){
	         String[i]=strAdded[i];
     864:	d7 01       	movw	r26, r14
     866:	8d 91       	ld	r24, X+
     868:	7d 01       	movw	r14, r26
     86a:	81 93       	st	Z+, r24
	     //Copy
         for(i=(Size-Length);i<Size;i++){
	         strAdded[i]=String[i-(Size-Length)];
	     }strAdded[Size]=0;
	     //Zeroed
         for(i=0;i<Size;i++){
     86c:	8e 2d       	mov	r24, r14
     86e:	8b 19       	sub	r24, r11
     870:	86 17       	cp	r24, r22
     872:	c0 f3       	brcs	.-16     	; 0x864 <AddZeroLead+0x96>
	         String[i]=strAdded[i];
	     }String[Size]=0;
     874:	06 0f       	add	r16, r22
     876:	11 1d       	adc	r17, r1
     878:	f8 01       	movw	r30, r16
     87a:	10 82       	st	Z, r1
	 }
}
     87c:	64 96       	adiw	r28, 0x14	; 20
     87e:	0f b6       	in	r0, 0x3f	; 63
     880:	f8 94       	cli
     882:	de bf       	out	0x3e, r29	; 62
     884:	0f be       	out	0x3f, r0	; 63
     886:	cd bf       	out	0x3d, r28	; 61
     888:	cf 91       	pop	r28
     88a:	df 91       	pop	r29
     88c:	1f 91       	pop	r17
     88e:	0f 91       	pop	r16
     890:	ff 90       	pop	r15
     892:	ef 90       	pop	r14
     894:	df 90       	pop	r13
     896:	cf 90       	pop	r12
     898:	bf 90       	pop	r11
     89a:	08 95       	ret

0000089c <RemZeroLead>:
     char Result;
          Result=Source[IdxSource];
	 return Result;
}

void RemZeroLead(char *Zeroed){//Remove Zero Character 00001004 000050000 0 
     89c:	cf 93       	push	r28
     89e:	df 93       	push	r29
     8a0:	ec 01       	movw	r28, r24
unsigned char i=0,Length=0,ZeroPos=0,IsFound=False;;
     IsFound=False;
     ZeroPos=0;Length=strlen(Zeroed);
     8a2:	fc 01       	movw	r30, r24
     8a4:	01 90       	ld	r0, Z+
     8a6:	00 20       	and	r0, r0
     8a8:	e9 f7       	brne	.-6      	; 0x8a4 <RemZeroLead+0x8>
     8aa:	31 97       	sbiw	r30, 0x01	; 1
     8ac:	e8 1b       	sub	r30, r24
  if ((Length>1)&&(Zeroed[0]=='0')){
     8ae:	e2 30       	cpi	r30, 0x02	; 2
     8b0:	d0 f1       	brcs	.+116    	; 0x926 <RemZeroLead+0x8a>
     8b2:	88 81       	ld	r24, Y
     8b4:	80 33       	cpi	r24, 0x30	; 48
     8b6:	b9 f5       	brne	.+110    	; 0x926 <RemZeroLead+0x8a>
     8b8:	4c 2f       	mov	r20, r28
     8ba:	de 01       	movw	r26, r28
     8bc:	90 e0       	ldi	r25, 0x00	; 0
	 if (Zeroed[0]=='0'){
         for(i=0;i<Length;i++){//00000000->0
	         if ((Zeroed[i]=='0')&&(Zeroed[i+1]=='0')&&(IsFound==False)) ZeroPos++;
     8be:	8c 91       	ld	r24, X
     8c0:	80 33       	cpi	r24, 0x30	; 48
     8c2:	69 f4       	brne	.+26     	; 0x8de <RemZeroLead+0x42>
     8c4:	11 96       	adiw	r26, 0x01	; 1
     8c6:	8c 91       	ld	r24, X
     8c8:	11 97       	sbiw	r26, 0x01	; 1
     8ca:	80 33       	cpi	r24, 0x30	; 48
     8cc:	11 f4       	brne	.+4      	; 0x8d2 <RemZeroLead+0x36>
     8ce:	9f 5f       	subi	r25, 0xFF	; 255
     8d0:	06 c0       	rjmp	.+12     	; 0x8de <RemZeroLead+0x42>
             if ((Zeroed[i]=='0')&&(Zeroed[i+1]!='0')){
			     if ((Zeroed[i+1]=='.')||(Zeroed[i+1]==','))ZeroPos--;
     8d2:	8e 32       	cpi	r24, 0x2E	; 46
     8d4:	11 f0       	breq	.+4      	; 0x8da <RemZeroLead+0x3e>
     8d6:	8c 32       	cpi	r24, 0x2C	; 44
     8d8:	41 f4       	brne	.+16     	; 0x8ea <RemZeroLead+0x4e>
     8da:	91 50       	subi	r25, 0x01	; 1
     8dc:	06 c0       	rjmp	.+12     	; 0x8ea <RemZeroLead+0x4e>
     8de:	11 96       	adiw	r26, 0x01	; 1
unsigned char i=0,Length=0,ZeroPos=0,IsFound=False;;
     IsFound=False;
     ZeroPos=0;Length=strlen(Zeroed);
  if ((Length>1)&&(Zeroed[0]=='0')){
	 if (Zeroed[0]=='0'){
         for(i=0;i<Length;i++){//00000000->0
     8e0:	8a 2f       	mov	r24, r26
     8e2:	84 1b       	sub	r24, r20
     8e4:	8e 17       	cp	r24, r30
     8e6:	58 f3       	brcs	.-42     	; 0x8be <RemZeroLead+0x22>
     8e8:	01 c0       	rjmp	.+2      	; 0x8ec <RemZeroLead+0x50>
		         IsFound=True;
			     break;			  
			     }
	      }

		  if (IsFound==True)ZeroPos++;
     8ea:	9f 5f       	subi	r25, 0xFF	; 255
		  if (ZeroPos>=Length)ZeroPos=Length-1;
     8ec:	9e 17       	cp	r25, r30
     8ee:	10 f0       	brcs	.+4      	; 0x8f4 <RemZeroLead+0x58>
     8f0:	9e 2f       	mov	r25, r30
     8f2:	91 50       	subi	r25, 0x01	; 1
     8f4:	40 e0       	ldi	r20, 0x00	; 0
          for(i=0;i<(Length-ZeroPos);i++){
     8f6:	89 2f       	mov	r24, r25
     8f8:	90 e0       	ldi	r25, 0x00	; 0
     8fa:	2e 2f       	mov	r18, r30
     8fc:	30 e0       	ldi	r19, 0x00	; 0
     8fe:	28 1b       	sub	r18, r24
     900:	39 0b       	sbc	r19, r25
	          Zeroed[i]=Zeroed[i+ZeroPos];
     902:	be 01       	movw	r22, r28
     904:	68 0f       	add	r22, r24
     906:	79 1f       	adc	r23, r25
     908:	09 c0       	rjmp	.+18     	; 0x91c <RemZeroLead+0x80>
     90a:	fe 01       	movw	r30, r28
     90c:	ea 0f       	add	r30, r26
     90e:	fb 1f       	adc	r31, r27
     910:	a6 0f       	add	r26, r22
     912:	b7 1f       	adc	r27, r23
     914:	8c 91       	ld	r24, X
     916:	80 83       	st	Z, r24
		      Zeroed[i+1]=0;
     918:	11 82       	std	Z+1, r1	; 0x01
			     }
	      }

		  if (IsFound==True)ZeroPos++;
		  if (ZeroPos>=Length)ZeroPos=Length-1;
          for(i=0;i<(Length-ZeroPos);i++){
     91a:	4f 5f       	subi	r20, 0xFF	; 255
     91c:	a4 2f       	mov	r26, r20
     91e:	b0 e0       	ldi	r27, 0x00	; 0
     920:	a2 17       	cp	r26, r18
     922:	b3 07       	cpc	r27, r19
     924:	94 f3       	brlt	.-28     	; 0x90a <RemZeroLead+0x6e>
	          Zeroed[i]=Zeroed[i+ZeroPos];
		      Zeroed[i+1]=0;
	   }//Zeroed[Length-ZeroPos]=0;
	 }     
   }
}
     926:	df 91       	pop	r29
     928:	cf 91       	pop	r28
     92a:	08 95       	ret

0000092c <WayneOnReceive>:
	     Dest[2*i]=(Source[FirstPos+i]>>4)+'0';
	     Dest[(2*i)+1]=(Source[FirstPos+i]&0x0F)+'0';	 
	 }Dest[2*nCount]=0;
}

void WayneOnReceive(char WayneDataIn){
     92c:	0f 93       	push	r16
     92e:	1f 93       	push	r17
     static unsigned int tCRC=0xFFFF;
     char i,strSend[40],rxNozzleID=0;
     static char zReceive=wrWaitSTX;
     static rcvBuffer[11];

		WayneRxBuffer[rxBufferLength]=WayneDataIn;// 03 FA
     930:	90 91 15 01 	lds	r25, 0x0115
     934:	e9 2f       	mov	r30, r25
     936:	f0 e0       	ldi	r31, 0x00	; 0
     938:	e3 5c       	subi	r30, 0xC3	; 195
     93a:	fe 4f       	sbci	r31, 0xFE	; 254
     93c:	80 83       	st	Z, r24
		if (rxBufferLength<70)
     93e:	96 34       	cpi	r25, 0x46	; 70
     940:	18 f4       	brcc	.+6      	; 0x948 <WayneOnReceive+0x1c>
		    rxBufferLength++;
     942:	9f 5f       	subi	r25, 0xFF	; 255
     944:	90 93 15 01 	sts	0x0115, r25
        
		if ((WayneRxBuffer[rxBufferLength-2]==0x03)&&(WayneDataIn==0xFA)){
     948:	20 91 15 01 	lds	r18, 0x0115
     94c:	e2 2f       	mov	r30, r18
     94e:	f0 e0       	ldi	r31, 0x00	; 0
     950:	e3 5c       	subi	r30, 0xC3	; 195
     952:	fe 4f       	sbci	r31, 0xFE	; 254
     954:	32 97       	sbiw	r30, 0x02	; 2
     956:	90 81       	ld	r25, Z
     958:	32 96       	adiw	r30, 0x02	; 2
     95a:	93 30       	cpi	r25, 0x03	; 3
     95c:	09 f0       	breq	.+2      	; 0x960 <WayneOnReceive+0x34>
     95e:	a3 c0       	rjmp	.+326    	; 0xaa6 <WayneOnReceive+0x17a>
     960:	8a 3f       	cpi	r24, 0xFA	; 250
     962:	09 f0       	breq	.+2      	; 0x966 <WayneOnReceive+0x3a>
     964:	ab c0       	rjmp	.+342    	; 0xabc <WayneOnReceive+0x190>
			WayneRxSequence=WayneRxBuffer[1]&0x0F;
     966:	80 91 3e 01 	lds	r24, 0x013E
     96a:	8f 70       	andi	r24, 0x0F	; 15
     96c:	80 93 18 01 	sts	0x0118, r24
			//Message Identification
			MsgID[0]=WayneRxBuffer[2];
     970:	00 91 3f 01 	lds	r16, 0x013F
     974:	00 93 33 01 	sts	0x0133, r16
			MsgID[1]=WayneRxBuffer[3];
     978:	90 91 40 01 	lds	r25, 0x0140
     97c:	90 93 34 01 	sts	0x0134, r25
			  0 51 3E 01 01 00 03 04 00 46 00 
			  1 02 02 08 00 00 01 54 00 00 70 
			  2 84 03 04 00 46 00 02 09 05 00 
			  3 00 02 00 00 53 66 03 FA 
			*/
            MsgInfo=MI_UNKNOWN;
     980:	87 e0       	ldi	r24, 0x07	; 7
     982:	80 93 19 01 	sts	0x0119, r24
            if ((MsgID[0]==0x06)&&(MsgID[1]==0x1F)&&(rxBufferLength>=57)){
     986:	06 30       	cpi	r16, 0x06	; 6
     988:	71 f5       	brne	.+92     	; 0x9e6 <WayneOnReceive+0xba>
     98a:	9f 31       	cpi	r25, 0x1F	; 31
     98c:	09 f0       	breq	.+2      	; 0x990 <WayneOnReceive+0x64>
     98e:	89 c0       	rjmp	.+274    	; 0xaa2 <WayneOnReceive+0x176>
     990:	29 33       	cpi	r18, 0x39	; 57
     992:	08 f4       	brcc	.+2      	; 0x996 <WayneOnReceive+0x6a>
     994:	86 c0       	rjmp	.+268    	; 0xaa2 <WayneOnReceive+0x176>
			     MsgInfo=MI_TOTALIZER;
     996:	88 e0       	ldi	r24, 0x08	; 8
     998:	80 93 19 01 	sts	0x0119, r24
			     rxNozzleID=(WayneRxBuffer[37]&0x0F);
				 ExtractValue(WayneRxBuffer,38,5,PumpTotalizer.TotalGrade[rxNozzleID-1].strVolume);		
     99c:	00 91 62 01 	lds	r16, 0x0162
     9a0:	0f 70       	andi	r16, 0x0F	; 15
     9a2:	10 e0       	ldi	r17, 0x00	; 0
     9a4:	c8 01       	movw	r24, r16
     9a6:	01 97       	sbiw	r24, 0x01	; 1
     9a8:	9c 01       	movw	r18, r24
     9aa:	55 e0       	ldi	r21, 0x05	; 5
     9ac:	22 0f       	add	r18, r18
     9ae:	33 1f       	adc	r19, r19
     9b0:	5a 95       	dec	r21
     9b2:	e1 f7       	brne	.-8      	; 0x9ac <WayneOnReceive+0x80>
     9b4:	88 0f       	add	r24, r24
     9b6:	99 1f       	adc	r25, r25
     9b8:	28 1b       	sub	r18, r24
     9ba:	39 0b       	sbc	r19, r25
     9bc:	29 50       	subi	r18, 0x09	; 9
     9be:	3d 4f       	sbci	r19, 0xFD	; 253
     9c0:	8d e3       	ldi	r24, 0x3D	; 61
     9c2:	91 e0       	ldi	r25, 0x01	; 1
     9c4:	66 e2       	ldi	r22, 0x26	; 38
     9c6:	45 e0       	ldi	r20, 0x05	; 5
     9c8:	0e 94 b0 01 	call	0x360	; 0x360 <ExtractValue>
				 RemZeroLead(PumpTotalizer.TotalGrade[rxNozzleID].strVolume);
     9cc:	c8 01       	movw	r24, r16
     9ce:	35 e0       	ldi	r19, 0x05	; 5
     9d0:	88 0f       	add	r24, r24
     9d2:	99 1f       	adc	r25, r25
     9d4:	3a 95       	dec	r19
     9d6:	e1 f7       	brne	.-8      	; 0x9d0 <WayneOnReceive+0xa4>
     9d8:	00 0f       	add	r16, r16
     9da:	11 1f       	adc	r17, r17
     9dc:	80 1b       	sub	r24, r16
     9de:	91 0b       	sbc	r25, r17
     9e0:	89 50       	subi	r24, 0x09	; 9
     9e2:	9d 4f       	sbci	r25, 0xFD	; 253
     9e4:	38 c0       	rjmp	.+112    	; 0xa56 <WayneOnReceive+0x12a>
			     sprintf_P(strSend,PSTR("Totalizer%d:[V:%s]"),rxNozzleID,PumpTotalizer.TotalGrade[rxNozzleID].strVolume);
			     _uart_print(1,1,strSend);
				 #endif

			}
            if ((MsgID[0]==0x01)&&(MsgID[1]==0x01)&&(rxBufferLength>=38)){//Last Transaction
     9e6:	01 30       	cpi	r16, 0x01	; 1
     9e8:	a9 f4       	brne	.+42     	; 0xa14 <WayneOnReceive+0xe8>
     9ea:	91 30       	cpi	r25, 0x01	; 1
     9ec:	09 f0       	breq	.+2      	; 0x9f0 <WayneOnReceive+0xc4>
     9ee:	59 c0       	rjmp	.+178    	; 0xaa2 <WayneOnReceive+0x176>
     9f0:	26 32       	cpi	r18, 0x26	; 38
     9f2:	08 f4       	brcc	.+2      	; 0x9f6 <WayneOnReceive+0xca>
     9f4:	56 c0       	rjmp	.+172    	; 0xaa2 <WayneOnReceive+0x176>
			     //Vol:13-16 Amount:17-20
				 MsgInfo=MI_LAST_TRANSACTION;
     9f6:	86 e0       	ldi	r24, 0x06	; 6
     9f8:	80 93 19 01 	sts	0x0119, r24
				 ExtractValue(WayneRxBuffer,13,4,strVolume);
     9fc:	8d e3       	ldi	r24, 0x3D	; 61
     9fe:	91 e0       	ldi	r25, 0x01	; 1
     a00:	6d e0       	ldi	r22, 0x0D	; 13
     a02:	44 e0       	ldi	r20, 0x04	; 4
     a04:	27 e5       	ldi	r18, 0x57	; 87
     a06:	32 e0       	ldi	r19, 0x02	; 2
     a08:	0e 94 b0 01 	call	0x360	; 0x360 <ExtractValue>
				 ExtractValue(WayneRxBuffer,17,4,strAmount);
     a0c:	8d e3       	ldi	r24, 0x3D	; 61
     a0e:	91 e0       	ldi	r25, 0x01	; 1
     a10:	61 e1       	ldi	r22, 0x11	; 17
     a12:	16 c0       	rjmp	.+44     	; 0xa40 <WayneOnReceive+0x114>
			     _uart_print(1,1,strSend);
				 #endif

			}   // 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18
			    //51 34 02 08 00 00 01 88 00 00 84 60 01 01 05 38 4E 03 FA 
			if ((MsgID[0]==0x02)&&(MsgID[1]==0x08)&&(rxBufferLength>=19)){//Last Transaction
     a14:	02 30       	cpi	r16, 0x02	; 2
     a16:	11 f5       	brne	.+68     	; 0xa5c <WayneOnReceive+0x130>
     a18:	98 30       	cpi	r25, 0x08	; 8
     a1a:	09 f0       	breq	.+2      	; 0xa1e <WayneOnReceive+0xf2>
     a1c:	42 c0       	rjmp	.+132    	; 0xaa2 <WayneOnReceive+0x176>
     a1e:	23 31       	cpi	r18, 0x13	; 19
     a20:	08 f4       	brcc	.+2      	; 0xa24 <WayneOnReceive+0xf8>
     a22:	3f c0       	rjmp	.+126    	; 0xaa2 <WayneOnReceive+0x176>
			     //Vol:13-16 Amount:17-20
				 MsgInfo=MI_LAST_TRANSACTION;
     a24:	86 e0       	ldi	r24, 0x06	; 6
     a26:	80 93 19 01 	sts	0x0119, r24
				 ExtractValue(WayneRxBuffer,4,4,strVolume);
     a2a:	8d e3       	ldi	r24, 0x3D	; 61
     a2c:	91 e0       	ldi	r25, 0x01	; 1
     a2e:	64 e0       	ldi	r22, 0x04	; 4
     a30:	44 e0       	ldi	r20, 0x04	; 4
     a32:	27 e5       	ldi	r18, 0x57	; 87
     a34:	32 e0       	ldi	r19, 0x02	; 2
     a36:	0e 94 b0 01 	call	0x360	; 0x360 <ExtractValue>
				 ExtractValue(WayneRxBuffer,8,4,strAmount);
     a3a:	8d e3       	ldi	r24, 0x3D	; 61
     a3c:	91 e0       	ldi	r25, 0x01	; 1
     a3e:	68 e0       	ldi	r22, 0x08	; 8
     a40:	44 e0       	ldi	r20, 0x04	; 4
     a42:	2b ea       	ldi	r18, 0xAB	; 171
     a44:	33 e0       	ldi	r19, 0x03	; 3
     a46:	0e 94 b0 01 	call	0x360	; 0x360 <ExtractValue>
				 RemZeroLead(strVolume);
     a4a:	87 e5       	ldi	r24, 0x57	; 87
     a4c:	92 e0       	ldi	r25, 0x02	; 2
     a4e:	0e 94 4e 04 	call	0x89c	; 0x89c <RemZeroLead>
				 RemZeroLead(strAmount);
     a52:	8b ea       	ldi	r24, 0xAB	; 171
     a54:	93 e0       	ldi	r25, 0x03	; 3
     a56:	0e 94 4e 04 	call	0x89c	; 0x89c <RemZeroLead>
     a5a:	23 c0       	rjmp	.+70     	; 0xaa2 <WayneOnReceive+0x176>
			     sprintf_P(strSend,PSTR("Trans:[V:%s][A:%s]"),strVolume,strAmount);
			     _uart_print(1,1,strSend);
				 #endif
			}			

            if ((MsgID[0]==0x03)&&(MsgID[1]==0x04)){//PriceNozzleInfo
     a5c:	03 30       	cpi	r16, 0x03	; 3
     a5e:	09 f5       	brne	.+66     	; 0xaa2 <WayneOnReceive+0x176>
     a60:	94 30       	cpi	r25, 0x04	; 4
     a62:	f9 f4       	brne	.+62     	; 0xaa2 <WayneOnReceive+0x176>
			     if ((WayneRxBuffer[7]>>4)==0x01){
     a64:	80 91 44 01 	lds	r24, 0x0144
     a68:	82 95       	swap	r24
     a6a:	8f 70       	andi	r24, 0x0F	; 15
     a6c:	81 30       	cpi	r24, 0x01	; 1
     a6e:	21 f4       	brne	.+8      	; 0xa78 <WayneOnReceive+0x14c>
				      MsgInfo=MI_NOZZLE_UP;
     a70:	82 e0       	ldi	r24, 0x02	; 2
     a72:	80 93 19 01 	sts	0x0119, r24
     a76:	10 c0       	rjmp	.+32     	; 0xa98 <WayneOnReceive+0x16c>
					  #ifdef DEBUG_WAYNE_RECEIVE 
					  _uart_printf(1,1,PSTR("-WR_MESSAGE Nozzle Up-"));
					  #endif
					  }
                 else
			     if ((WayneRxBuffer[7]>>4)==0x00){
     a78:	88 23       	and	r24, r24
     a7a:	71 f4       	brne	.+28     	; 0xa98 <WayneOnReceive+0x16c>
				      //Price
					  ExtractValue(WayneRxBuffer,4,3,strUnitPrice);
     a7c:	8d e3       	ldi	r24, 0x3D	; 61
     a7e:	91 e0       	ldi	r25, 0x01	; 1
     a80:	64 e0       	ldi	r22, 0x04	; 4
     a82:	43 e0       	ldi	r20, 0x03	; 3
     a84:	2c ea       	ldi	r18, 0xAC	; 172
     a86:	32 e0       	ldi	r19, 0x02	; 2
     a88:	0e 94 b0 01 	call	0x360	; 0x360 <ExtractValue>
					  RemZeroLead(strUnitPrice);
     a8c:	8c ea       	ldi	r24, 0xAC	; 172
     a8e:	92 e0       	ldi	r25, 0x02	; 2
     a90:	0e 94 4e 04 	call	0x89c	; 0x89c <RemZeroLead>
					  #ifdef DEBUG_WAYNE_RECEIVE
			          sprintf_P(strSend,PSTR("Price%s"),strUnitPrice);
			          _uart_print(1,1,strSend);
					  #endif
				      MsgInfo=MI_NOZZLE_DOWN;
     a94:	00 93 19 01 	sts	0x0119, r16
					  #ifdef DEBUG_WAYNE_RECEIVE 
					  _uart_printf(1,1,PSTR("-WR_MESSAGE Nozzle Down-"));
					  #endif
					  }
            ActiveNozzle=WayneRxBuffer[7]&0x0F;
     a98:	80 91 44 01 	lds	r24, 0x0144
     a9c:	8f 70       	andi	r24, 0x0F	; 15
     a9e:	80 93 1c 01 	sts	0x011C, r24
            }
        WayneReply=WR_MESSAGE;
     aa2:	84 e0       	ldi	r24, 0x04	; 4
     aa4:	07 c0       	rjmp	.+14     	; 0xab4 <WayneOnReceive+0x188>
		rxBufferLength=0;	
		}else
		if ((WayneRxBuffer[rxBufferLength-2]==0x70)&&(WayneRxBuffer[rxBufferLength-1]==0xFA)){
     aa6:	90 37       	cpi	r25, 0x70	; 112
     aa8:	49 f4       	brne	.+18     	; 0xabc <WayneOnReceive+0x190>
     aaa:	31 97       	sbiw	r30, 0x01	; 1
     aac:	80 81       	ld	r24, Z
     aae:	8a 3f       	cpi	r24, 0xFA	; 250
     ab0:	29 f4       	brne	.+10     	; 0xabc <WayneOnReceive+0x190>
		
		    #ifdef DEBUG_WAYNE_RECEIVE 
			_uart_printf(1,1,PSTR("-WR_READY-"));
			#endif
		    WayneReply=WR_READY;
     ab2:	81 e0       	ldi	r24, 0x01	; 1
     ab4:	80 93 1a 01 	sts	0x011A, r24
		    rxBufferLength=0;
     ab8:	10 92 15 01 	sts	0x0115, r1
		}
		if (((WayneRxBuffer[rxBufferLength-3]&0xF0)==0x50)&&(WayneRxBuffer[rxBufferLength-1]==0xFA)){
     abc:	80 91 15 01 	lds	r24, 0x0115
     ac0:	a8 2f       	mov	r26, r24
     ac2:	b0 e0       	ldi	r27, 0x00	; 0
     ac4:	a3 5c       	subi	r26, 0xC3	; 195
     ac6:	be 4f       	sbci	r27, 0xFE	; 254
     ac8:	13 97       	sbiw	r26, 0x03	; 3
     aca:	8c 91       	ld	r24, X
     acc:	13 96       	adiw	r26, 0x03	; 3
     ace:	80 7f       	andi	r24, 0xF0	; 240
     ad0:	80 35       	cpi	r24, 0x50	; 80
     ad2:	c1 f4       	brne	.+48     	; 0xb04 <WayneOnReceive+0x1d8>
     ad4:	fd 01       	movw	r30, r26
     ad6:	31 97       	sbiw	r30, 0x01	; 1
     ad8:	80 81       	ld	r24, Z
     ada:	8a 3f       	cpi	r24, 0xFA	; 250
     adc:	99 f4       	brne	.+38     	; 0xb04 <WayneOnReceive+0x1d8>
              if ((WayneRxBuffer[rxBufferLength-2]&0xF0)==0xC0){
     ade:	fd 01       	movw	r30, r26
     ae0:	32 97       	sbiw	r30, 0x02	; 2
     ae2:	80 81       	ld	r24, Z
     ae4:	90 e0       	ldi	r25, 0x00	; 0
     ae6:	80 7f       	andi	r24, 0xF0	; 240
     ae8:	90 70       	andi	r25, 0x00	; 0
     aea:	80 3c       	cpi	r24, 0xC0	; 192
     aec:	91 05       	cpc	r25, r1
     aee:	11 f4       	brne	.+4      	; 0xaf4 <WayneOnReceive+0x1c8>
		         #ifdef DEBUG_WAYNE_RECEIVE 
				 _uart_printf(1,1,PSTR("-WR_ACK-"));
				 #endif
		         WayneReply=WR_ACK;
     af0:	82 e0       	ldi	r24, 0x02	; 2
     af2:	04 c0       	rjmp	.+8      	; 0xafc <WayneOnReceive+0x1d0>
			 }else if ((WayneRxBuffer[rxBufferLength-2]&0xF0)==0x50){
     af4:	80 35       	cpi	r24, 0x50	; 80
     af6:	91 05       	cpc	r25, r1
     af8:	19 f4       	brne	.+6      	; 0xb00 <WayneOnReceive+0x1d4>
		         #ifdef DEBUG_WAYNE_RECEIVE 
				 _uart_printf(1,1,PSTR("-WR_NACK-"));
				 #endif
		         WayneReply=WR_NACK;
     afa:	83 e0       	ldi	r24, 0x03	; 3
     afc:	80 93 1a 01 	sts	0x011A, r24
			 }
             rxBufferLength=0;
     b00:	10 92 15 01 	sts	0x0115, r1
		}
}
     b04:	1f 91       	pop	r17
     b06:	0f 91       	pop	r16
     b08:	08 95       	ret

00000b0a <StrReverse>:
}

void systemServiceSPI(){
}

void StrReverse(char *strSource){// 0054->4500
     b0a:	df 93       	push	r29
     b0c:	cf 93       	push	r28
     b0e:	cd b7       	in	r28, 0x3d	; 61
     b10:	de b7       	in	r29, 0x3e	; 62
     b12:	64 97       	sbiw	r28, 0x14	; 20
     b14:	0f b6       	in	r0, 0x3f	; 63
     b16:	f8 94       	cli
     b18:	de bf       	out	0x3e, r29	; 62
     b1a:	0f be       	out	0x3f, r0	; 63
     b1c:	cd bf       	out	0x3d, r28	; 61
     b1e:	ac 01       	movw	r20, r24
     char i,Length,strResult[20];
	 Length=strlen(strSource);
     b20:	fc 01       	movw	r30, r24
     b22:	01 90       	ld	r0, Z+
     b24:	00 20       	and	r0, r0
     b26:	e9 f7       	brne	.-6      	; 0xb22 <StrReverse+0x18>
     b28:	31 97       	sbiw	r30, 0x01	; 1
     b2a:	2e 2f       	mov	r18, r30
     b2c:	28 1b       	sub	r18, r24
     b2e:	a2 2f       	mov	r26, r18
     b30:	b0 e0       	ldi	r27, 0x00	; 0
     b32:	11 97       	sbiw	r26, 0x01	; 1
     b34:	a8 0f       	add	r26, r24
     b36:	b9 1f       	adc	r27, r25
     b38:	be 01       	movw	r22, r28
     b3a:	6f 5f       	subi	r22, 0xFF	; 255
     b3c:	7f 4f       	sbci	r23, 0xFF	; 255
     b3e:	fb 01       	movw	r30, r22
     b40:	03 c0       	rjmp	.+6      	; 0xb48 <StrReverse+0x3e>
	 for(i=0;i<Length;i++){
	    strResult[i]=strSource[Length-i-1];
     b42:	8c 91       	ld	r24, X
     b44:	81 93       	st	Z+, r24
     b46:	11 97       	sbiw	r26, 0x01	; 1
}

void StrReverse(char *strSource){// 0054->4500
     char i,Length,strResult[20];
	 Length=strlen(strSource);
	 for(i=0;i<Length;i++){
     b48:	8e 2f       	mov	r24, r30
     b4a:	86 1b       	sub	r24, r22
     b4c:	82 17       	cp	r24, r18
     b4e:	c8 f3       	brcs	.-14     	; 0xb42 <StrReverse+0x38>
	    strResult[i]=strSource[Length-i-1];
	 }strResult[Length]=0;
     b50:	ce 01       	movw	r24, r28
     b52:	01 96       	adiw	r24, 0x01	; 1
     b54:	fc 01       	movw	r30, r24
     b56:	e2 0f       	add	r30, r18
     b58:	f1 1d       	adc	r31, r1
     b5a:	10 82       	st	Z, r1
     b5c:	60 e0       	ldi	r22, 0x00	; 0
	 //CopyResult
	 for(i=0;i<strlen(strResult);i++){
     b5e:	9c 01       	movw	r18, r24
     b60:	09 c0       	rjmp	.+18     	; 0xb74 <StrReverse+0x6a>
	    strSource[i]=strResult[i];
     b62:	fa 01       	movw	r30, r20
     b64:	ea 0f       	add	r30, r26
     b66:	fb 1f       	adc	r31, r27
     b68:	a2 0f       	add	r26, r18
     b6a:	b3 1f       	adc	r27, r19
     b6c:	8c 91       	ld	r24, X
     b6e:	80 83       	st	Z, r24
	    strSource[i+1]=0;
     b70:	11 82       	std	Z+1, r1	; 0x01
	 Length=strlen(strSource);
	 for(i=0;i<Length;i++){
	    strResult[i]=strSource[Length-i-1];
	 }strResult[Length]=0;
	 //CopyResult
	 for(i=0;i<strlen(strResult);i++){
     b72:	6f 5f       	subi	r22, 0xFF	; 255
     b74:	a6 2f       	mov	r26, r22
     b76:	b0 e0       	ldi	r27, 0x00	; 0
     b78:	f9 01       	movw	r30, r18
     b7a:	01 90       	ld	r0, Z+
     b7c:	00 20       	and	r0, r0
     b7e:	e9 f7       	brne	.-6      	; 0xb7a <StrReverse+0x70>
     b80:	31 97       	sbiw	r30, 0x01	; 1
     b82:	e2 1b       	sub	r30, r18
     b84:	f3 0b       	sbc	r31, r19
     b86:	ae 17       	cp	r26, r30
     b88:	bf 07       	cpc	r27, r31
     b8a:	58 f3       	brcs	.-42     	; 0xb62 <StrReverse+0x58>
	    strSource[i]=strResult[i];
	    strSource[i+1]=0;
	 }
}
     b8c:	64 96       	adiw	r28, 0x14	; 20
     b8e:	0f b6       	in	r0, 0x3f	; 63
     b90:	f8 94       	cli
     b92:	de bf       	out	0x3e, r29	; 62
     b94:	0f be       	out	0x3f, r0	; 63
     b96:	cd bf       	out	0x3d, r28	; 61
     b98:	cf 91       	pop	r28
     b9a:	df 91       	pop	r29
     b9c:	08 95       	ret

00000b9e <GilbarcoOnReceive>:
	else
	if (data==0xF5)SavePipeline=spTotalizerPPU2;
	
}

void GilbarcoOnReceive(char data){
     b9e:	1f 93       	push	r17
     ba0:	cf 93       	push	r28
     ba2:	df 93       	push	r29
     ba4:	18 2f       	mov	r17, r24
     ba6:	ed e0       	ldi	r30, 0x0D	; 13
     ba8:	f4 e0       	ldi	r31, 0x04	; 4
}

void ShiftData(char data){//data [0]..[10]
     char i;
	 for(i=11;i>0;i--){//0..10
	    zDataBuffer[i]=zDataBuffer[i-1];
     baa:	80 81       	ld	r24, Z
     bac:	81 83       	std	Z+1, r24	; 0x01
     bae:	31 97       	sbiw	r30, 0x01	; 1
	 return Result;
}

void ShiftData(char data){//data [0]..[10]
     char i;
	 for(i=11;i>0;i--){//0..10
     bb0:	84 e0       	ldi	r24, 0x04	; 4
     bb2:	e2 30       	cpi	r30, 0x02	; 2
     bb4:	f8 07       	cpc	r31, r24
     bb6:	c9 f7       	brne	.-14     	; 0xbaa <GilbarcoOnReceive+0xc>
	    zDataBuffer[i]=zDataBuffer[i-1];
	 }
	 zDataBuffer[0]=data;
     bb8:	11 83       	std	Z+1, r17	; 0x01
void GilbarcoOnReceive(char data){
char strSend[30],chrData,i;
static char iReceive=0;
    ShiftData(data);
	 
    switch(stReceiveCom0){
     bba:	90 91 04 01 	lds	r25, 0x0104
     bbe:	93 30       	cpi	r25, 0x03	; 3
     bc0:	d1 f1       	breq	.+116    	; 0xc36 <GilbarcoOnReceive+0x98>
     bc2:	94 30       	cpi	r25, 0x04	; 4
     bc4:	30 f4       	brcc	.+12     	; 0xbd2 <GilbarcoOnReceive+0x34>
     bc6:	91 30       	cpi	r25, 0x01	; 1
     bc8:	69 f0       	breq	.+26     	; 0xbe4 <GilbarcoOnReceive+0x46>
     bca:	92 30       	cpi	r25, 0x02	; 2
     bcc:	09 f0       	breq	.+2      	; 0xbd0 <GilbarcoOnReceive+0x32>
     bce:	9f c0       	rjmp	.+318    	; 0xd0e <GilbarcoOnReceive+0x170>
     bd0:	14 c0       	rjmp	.+40     	; 0xbfa <GilbarcoOnReceive+0x5c>
     bd2:	95 30       	cpi	r25, 0x05	; 5
     bd4:	09 f4       	brne	.+2      	; 0xbd8 <GilbarcoOnReceive+0x3a>
     bd6:	47 c0       	rjmp	.+142    	; 0xc66 <GilbarcoOnReceive+0xc8>
     bd8:	95 30       	cpi	r25, 0x05	; 5
     bda:	c0 f1       	brcs	.+112    	; 0xc4c <GilbarcoOnReceive+0xae>
     bdc:	96 30       	cpi	r25, 0x06	; 6
     bde:	09 f0       	breq	.+2      	; 0xbe2 <GilbarcoOnReceive+0x44>
     be0:	96 c0       	rjmp	.+300    	; 0xd0e <GilbarcoOnReceive+0x170>
     be2:	78 c0       	rjmp	.+240    	; 0xcd4 <GilbarcoOnReceive+0x136>
	case rcIdle:
	     CMDResponse=GetResponse(data);
     be4:	81 2f       	mov	r24, r17
     be6:	82 95       	swap	r24
     be8:	8f 70       	andi	r24, 0x0F	; 15
     bea:	80 93 8d 01 	sts	0x018D, r24
		 PumpID=GetPumpID(data);
     bee:	1f 70       	andi	r17, 0x0F	; 15
     bf0:	10 93 0e 01 	sts	0x010E, r17
		 #ifdef DEBUG_GILBARCO_RESPONSE
		 sprintf_P(strSend,PSTR("Response:%.2X"),data);
		 _uart_print(1,1,strSend);
		 #endif
		 IsStatusReceived=True;
     bf4:	90 93 0f 01 	sts	0x010F, r25
     bf8:	8a c0       	rjmp	.+276    	; 0xd0e <GilbarcoOnReceive+0x170>

	     break;	
	case rcRealTimeMoney:	     
	     strCurrentMoney[Com0ReceiveCount]=BCD2Char(FilterBCD(data));
     bfa:	90 91 23 01 	lds	r25, 0x0123
     bfe:	e9 2f       	mov	r30, r25
     c00:	f0 e0       	ldi	r31, 0x00	; 0
	 Dest[Length]=0;
}

char FilterBCD(char data){
     char Result;
	 Result=(data&0x0F);
     c02:	81 2f       	mov	r24, r17
     c04:	8f 70       	andi	r24, 0x0F	; 15
}

char BCD2Char(char data){
     char Result;
	 Result=0;
	 if ((data>=0)&&(data<=9)) 
     c06:	8a 30       	cpi	r24, 0x0A	; 10
     c08:	10 f0       	brcs	.+4      	; 0xc0e <GilbarcoOnReceive+0x70>
     c0a:	80 e3       	ldi	r24, 0x30	; 48
     c0c:	01 c0       	rjmp	.+2      	; 0xc10 <GilbarcoOnReceive+0x72>
	     Result='0'+data;
     c0e:	80 5d       	subi	r24, 0xD0	; 208
		 #endif
		 IsStatusReceived=True;

	     break;	
	case rcRealTimeMoney:	     
	     strCurrentMoney[Com0ReceiveCount]=BCD2Char(FilterBCD(data));
     c10:	e8 58       	subi	r30, 0x88	; 136
     c12:	fd 4f       	sbci	r31, 0xFD	; 253
     c14:	80 83       	st	Z, r24
	     strCurrentMoney[Com0ReceiveCount+1]=0;
     c16:	11 82       	std	Z+1, r1	; 0x01
		 TimReceive=0;
     c18:	10 92 10 04 	sts	0x0410, r1
     c1c:	10 92 0f 04 	sts	0x040F, r1
		 Com0ReceiveCount++;
     c20:	89 2f       	mov	r24, r25
     c22:	8f 5f       	subi	r24, 0xFF	; 255
     c24:	80 93 23 01 	sts	0x0123, r24
	     if ((Com0ReceiveCount>6)||(TimReceive>MSG_TRANSACTION_TIMEOUT))
     c28:	87 30       	cpi	r24, 0x07	; 7
     c2a:	08 f4       	brcc	.+2      	; 0xc2e <GilbarcoOnReceive+0x90>
     c2c:	70 c0       	rjmp	.+224    	; 0xd0e <GilbarcoOnReceive+0x170>
		     IsMoneyReceived=True;
     c2e:	81 e0       	ldi	r24, 0x01	; 1
     c30:	80 93 10 01 	sts	0x0110, r24
     c34:	6c c0       	rjmp	.+216    	; 0xd0e <GilbarcoOnReceive+0x170>
	     break;	
    case rcInitTransaction://<STX>
	     if (data==0xFF){
     c36:	1f 3f       	cpi	r17, 0xFF	; 255
     c38:	09 f0       	breq	.+2      	; 0xc3c <GilbarcoOnReceive+0x9e>
     c3a:	69 c0       	rjmp	.+210    	; 0xd0e <GilbarcoOnReceive+0x170>
		    iReceive=0;
     c3c:	10 92 27 01 	sts	0x0127, r1
			TimReceive=0;
     c40:	10 92 10 04 	sts	0x0410, r1
     c44:	10 92 0f 04 	sts	0x040F, r1
		    stReceiveCom0=rcSaveTransactionMessage;
     c48:	86 e0       	ldi	r24, 0x06	; 6
     c4a:	0a c0       	rjmp	.+20     	; 0xc60 <GilbarcoOnReceive+0xc2>
		 }
	     break;
    case rcInitTotalizer://<STX>
	     if (data==0xFF){
     c4c:	1f 3f       	cpi	r17, 0xFF	; 255
     c4e:	09 f0       	breq	.+2      	; 0xc52 <GilbarcoOnReceive+0xb4>
     c50:	5e c0       	rjmp	.+188    	; 0xd0e <GilbarcoOnReceive+0x170>
		    iReceive=0;
     c52:	10 92 27 01 	sts	0x0127, r1
			TimReceive=0;
     c56:	10 92 10 04 	sts	0x0410, r1
     c5a:	10 92 0f 04 	sts	0x040F, r1
		    stReceiveCom0=rcSaveTotalizerMessage;
     c5e:	85 e0       	ldi	r24, 0x05	; 5
     c60:	80 93 04 01 	sts	0x0104, r24
     c64:	54 c0       	rjmp	.+168    	; 0xd0e <GilbarcoOnReceive+0x170>
		 }
	     break;
    case rcSaveTotalizerMessage:
	     //_uart(1,1,data);
	     SaveTotalizerData(data);
     c66:	81 2f       	mov	r24, r17
     c68:	0e 94 a9 02 	call	0x552	; 0x552 <SaveTotalizerData>
	     if ((data==0xF0)||(TimReceive>MSG_TRANSACTION_TIMEOUT)){//Proses
     c6c:	10 3f       	cpi	r17, 0xF0	; 240
     c6e:	41 f0       	breq	.+16     	; 0xc80 <GilbarcoOnReceive+0xe2>
     c70:	80 91 0f 04 	lds	r24, 0x040F
     c74:	90 91 10 04 	lds	r25, 0x0410
     c78:	89 3c       	cpi	r24, 0xC9	; 201
     c7a:	91 05       	cpc	r25, r1
     c7c:	08 f4       	brcc	.+2      	; 0xc80 <GilbarcoOnReceive+0xe2>
     c7e:	47 c0       	rjmp	.+142    	; 0xd0e <GilbarcoOnReceive+0x170>
     c80:	c0 e0       	ldi	r28, 0x00	; 0
     c82:	d0 e0       	ldi	r29, 0x00	; 0
             //ReverseData
			 //_uart_printf(1,1,PSTR("Totalizer: "));
			 for (i=0;i<6;i++){
			 	  StrReverse(PumpTotalizer.TotalGrade[i].strMoney);
     c84:	9e 01       	movw	r18, r28
     c86:	ce 01       	movw	r24, r28
     c88:	f5 e0       	ldi	r31, 0x05	; 5
     c8a:	88 0f       	add	r24, r24
     c8c:	99 1f       	adc	r25, r25
     c8e:	fa 95       	dec	r31
     c90:	e1 f7       	brne	.-8      	; 0xc8a <GilbarcoOnReceive+0xec>
     c92:	22 0f       	add	r18, r18
     c94:	33 1f       	adc	r19, r19
     c96:	82 1b       	sub	r24, r18
     c98:	93 0b       	sbc	r25, r19
     c9a:	8a 5f       	subi	r24, 0xFA	; 250
     c9c:	9c 4f       	sbci	r25, 0xFC	; 252
     c9e:	0e 94 85 05 	call	0xb0a	; 0xb0a <StrReverse>
				  StrReverse(PumpTotalizer.TotalGrade[i].strVolume);
     ca2:	9e 01       	movw	r18, r28
     ca4:	ce 01       	movw	r24, r28
     ca6:	75 e0       	ldi	r23, 0x05	; 5
     ca8:	88 0f       	add	r24, r24
     caa:	99 1f       	adc	r25, r25
     cac:	7a 95       	dec	r23
     cae:	e1 f7       	brne	.-8      	; 0xca8 <GilbarcoOnReceive+0x10a>
     cb0:	22 0f       	add	r18, r18
     cb2:	33 1f       	adc	r19, r19
     cb4:	82 1b       	sub	r24, r18
     cb6:	93 0b       	sbc	r25, r19
     cb8:	89 50       	subi	r24, 0x09	; 9
     cba:	9d 4f       	sbci	r25, 0xFD	; 253
     cbc:	0e 94 85 05 	call	0xb0a	; 0xb0a <StrReverse>
     cc0:	21 96       	adiw	r28, 0x01	; 1
	     //_uart(1,1,data);
	     SaveTotalizerData(data);
	     if ((data==0xF0)||(TimReceive>MSG_TRANSACTION_TIMEOUT)){//Proses
             //ReverseData
			 //_uart_printf(1,1,PSTR("Totalizer: "));
			 for (i=0;i<6;i++){
     cc2:	c6 30       	cpi	r28, 0x06	; 6
     cc4:	d1 05       	cpc	r29, r1
     cc6:	f1 f6       	brne	.-68     	; 0xc84 <GilbarcoOnReceive+0xe6>
			 	  StrReverse(PumpTotalizer.TotalGrade[i].strMoney);
				  StrReverse(PumpTotalizer.TotalGrade[i].strVolume);
				  //_uart_print(1,1,PumpTotalizer.TotalGrade[i].strMoney);
				  //_uart_print(1,1,PumpTotalizer.TotalGrade[i].strVolume);
             }
		     stReceiveCom0=rcIdle;
     cc8:	81 e0       	ldi	r24, 0x01	; 1
     cca:	80 93 04 01 	sts	0x0104, r24
			 IsTotalizer=True;
     cce:	80 93 12 01 	sts	0x0112, r24
     cd2:	1d c0       	rjmp	.+58     	; 0xd0e <GilbarcoOnReceive+0x170>
			 }		 
         break;	
    case rcSaveTransactionMessage:
	     //_uart(1,1,data);
	     SaveTransactionData(data);
     cd4:	81 2f       	mov	r24, r17
     cd6:	0e 94 23 02 	call	0x446	; 0x446 <SaveTransactionData>
	     if ((data==0xF0)||(TimReceive>MSG_TRANSACTION_TIMEOUT)){//Proses
     cda:	10 3f       	cpi	r17, 0xF0	; 240
     cdc:	39 f0       	breq	.+14     	; 0xcec <GilbarcoOnReceive+0x14e>
     cde:	80 91 0f 04 	lds	r24, 0x040F
     ce2:	90 91 10 04 	lds	r25, 0x0410
     ce6:	89 3c       	cpi	r24, 0xC9	; 201
     ce8:	91 05       	cpc	r25, r1
     cea:	88 f0       	brcs	.+34     	; 0xd0e <GilbarcoOnReceive+0x170>
			  StrReverse(strUnitPrice);
     cec:	8c ea       	ldi	r24, 0xAC	; 172
     cee:	92 e0       	ldi	r25, 0x02	; 2
     cf0:	0e 94 85 05 	call	0xb0a	; 0xb0a <StrReverse>
			  StrReverse(strVolume);
     cf4:	87 e5       	ldi	r24, 0x57	; 87
     cf6:	92 e0       	ldi	r25, 0x02	; 2
     cf8:	0e 94 85 05 	call	0xb0a	; 0xb0a <StrReverse>
			  StrReverse(strAmount);
     cfc:	8b ea       	ldi	r24, 0xAB	; 171
     cfe:	93 e0       	ldi	r25, 0x03	; 3
     d00:	0e 94 85 05 	call	0xb0a	; 0xb0a <StrReverse>

			  //sprintf_P(strSend,PSTR("%s"),strAmount);
			  //_uart_print(1,1,strSend);

              stReceiveCom0=rcIdle;
     d04:	81 e0       	ldi	r24, 0x01	; 1
     d06:	80 93 04 01 	sts	0x0104, r24
			  IsTransaction=True;
     d0a:	80 93 11 01 	sts	0x0111, r24
			 }
	     break;
	}
}
     d0e:	df 91       	pop	r29
     d10:	cf 91       	pop	r28
     d12:	1f 91       	pop	r17
     d14:	08 95       	ret

00000d16 <SendSPI>:
	sbi(DDRD,2);sbi(PORTD,2);//128-SS HIGH
	//_delay_ms(10);
}

void SendSPI(char xSPI){
     _spi(xSPI);
     d16:	0e 94 b5 13 	call	0x276a	; 0x276a <_spi>
	 //_delay_ms(10);
}
     d1a:	08 95       	ret

00000d1c <SendStrSPI>:
	 SendSPI(0x06);//ETX
	 SendSPI(0x60);//ETX
	 systemSlave();
}

void SendStrSPI(char *strSendSPI){
     d1c:	ff 92       	push	r15
     d1e:	0f 93       	push	r16
     d20:	1f 93       	push	r17
     d22:	cf 93       	push	r28
     d24:	df 93       	push	r29
     d26:	8c 01       	movw	r16, r24
     d28:	ff 24       	eor	r15, r15
     d2a:	06 c0       	rjmp	.+12     	; 0xd38 <SendStrSPI+0x1c>
	sbi(DDRD,2);sbi(PORTD,2);//128-SS HIGH
	//_delay_ms(10);
}

void SendSPI(char xSPI){
     _spi(xSPI);
     d2c:	c0 0f       	add	r28, r16
     d2e:	d1 1f       	adc	r29, r17
     d30:	88 81       	ld	r24, Y
     d32:	0e 94 b5 13 	call	0x276a	; 0x276a <_spi>
	 systemSlave();
}

void SendStrSPI(char *strSendSPI){
char i;
     for(i=0;i<strlen(strSendSPI);i++){
     d36:	f3 94       	inc	r15
     d38:	cf 2d       	mov	r28, r15
     d3a:	d0 e0       	ldi	r29, 0x00	; 0
     d3c:	f8 01       	movw	r30, r16
     d3e:	01 90       	ld	r0, Z+
     d40:	00 20       	and	r0, r0
     d42:	e9 f7       	brne	.-6      	; 0xd3e <SendStrSPI+0x22>
     d44:	31 97       	sbiw	r30, 0x01	; 1
     d46:	e0 1b       	sub	r30, r16
     d48:	f1 0b       	sbc	r31, r17
     d4a:	ce 17       	cp	r28, r30
     d4c:	df 07       	cpc	r29, r31
     d4e:	70 f3       	brcs	.-36     	; 0xd2c <SendStrSPI+0x10>
	    SendSPI(strSendSPI[i]);
        //_uart(1,1,strSendSPI[i]);
	 } 
}
     d50:	df 91       	pop	r29
     d52:	cf 91       	pop	r28
     d54:	1f 91       	pop	r17
     d56:	0f 91       	pop	r16
     d58:	ff 90       	pop	r15
     d5a:	08 95       	ret

00000d5c <systemSlave>:
	//_delay_ms(10);
}


void systemSlave(){
	_spi_init(0, 1);         //SPI Slave
     d5c:	80 e0       	ldi	r24, 0x00	; 0
     d5e:	61 e0       	ldi	r22, 0x01	; 1
     d60:	0e 94 93 13 	call	0x2726	; 0x2726 <_spi_init>
	sbi(DDRB,6);sbi(PORTB,6);//MISO Output
     d64:	be 9a       	sbi	0x17, 6	; 23
     d66:	c6 9a       	sbi	0x18, 6	; 24
    cbi(DDRB,5);sbi(PORTB,5);//MOSI Input
     d68:	bd 98       	cbi	0x17, 5	; 23
     d6a:	c5 9a       	sbi	0x18, 5	; 24
	cbi(DDRB,7);sbi(PORTB,7);//SCK  Input
     d6c:	bf 98       	cbi	0x17, 7	; 23
     d6e:	c7 9a       	sbi	0x18, 7	; 24
	sbi(DDRD,2);sbi(PORTD,2);//128-SS HIGH
     d70:	8a 9a       	sbi	0x11, 2	; 17
     d72:	92 9a       	sbi	0x12, 2	; 18
	//_delay_ms(10);
}
     d74:	08 95       	ret

00000d76 <systemMaster>:
     _uart(0,1,DataSend);	 
     //_uart(1,1,DataSend);
}

void systemMaster(){
    _spi_init(1, 0);         //SPI Master
     d76:	81 e0       	ldi	r24, 0x01	; 1
     d78:	60 e0       	ldi	r22, 0x00	; 0
     d7a:	0e 94 93 13 	call	0x2726	; 0x2726 <_spi_init>
	cbi(DDRB,6);sbi(PORTB,6);//MISO Input
     d7e:	be 98       	cbi	0x17, 6	; 23
     d80:	c6 9a       	sbi	0x18, 6	; 24
    sbi(DDRB,4);sbi(DDRB,5); //MOSI Output
     d82:	bc 9a       	sbi	0x17, 4	; 23
     d84:	bd 9a       	sbi	0x17, 5	; 23
	sbi(DDRB,7);sbi(PORTB,7);//SCK  Output    
     d86:	bf 9a       	sbi	0x17, 7	; 23
     d88:	c7 9a       	sbi	0x18, 7	; 24
	sbi(DDRD,2);cbi(PORTD,2);//128-SS LOW
     d8a:	8a 9a       	sbi	0x11, 2	; 17
     d8c:	92 98       	cbi	0x12, 2	; 18
	//_delay_ms(10);
}
     d8e:	08 95       	ret

00000d90 <SendPumpStatusFlow>:
			 PumpLock[i]=False;
		 }
     }    	 
}

void SendPumpStatusFlow(char xPumpID,char xPumpStatus){//
     d90:	0f 93       	push	r16
     d92:	1f 93       	push	r17
     d94:	08 2f       	mov	r16, r24
     d96:	16 2f       	mov	r17, r22
	 #ifdef DEBUG_PUMP_STATUS_FLOW 
	  sprintf_P(strSend,PSTR("P:%d,S:%d"),xPumpID,xPumpStatus);
	 _uart_print(1,1,strSend);
	 #endif

	 systemMaster();
     d98:	0e 94 bb 06 	call	0xd76	; 0xd76 <systemMaster>
	sbi(DDRD,2);sbi(PORTD,2);//128-SS HIGH
	//_delay_ms(10);
}

void SendSPI(char xSPI){
     _spi(xSPI);
     d9c:	87 e0       	ldi	r24, 0x07	; 7
     d9e:	0e 94 b5 13 	call	0x276a	; 0x276a <_spi>
	 systemMaster();
     SendSPI(0x07);//STX
     SendSPI(tmpStatus);//xIDPump
	 SendSPI(0x08);//ETX

	 systemSlave();
     da2:	1f 70       	andi	r17, 0x0F	; 15
     da4:	02 95       	swap	r16
     da6:	00 7f       	andi	r16, 0xF0	; 240
     da8:	80 2f       	mov	r24, r16
     daa:	81 2b       	or	r24, r17
     dac:	0e 94 b5 13 	call	0x276a	; 0x276a <_spi>
     db0:	88 e0       	ldi	r24, 0x08	; 8
     db2:	0e 94 b5 13 	call	0x276a	; 0x276a <_spi>
     db6:	0e 94 ae 06 	call	0xd5c	; 0xd5c <systemSlave>
}
     dba:	1f 91       	pop	r17
     dbc:	0f 91       	pop	r16
     dbe:	08 95       	ret

00000dc0 <SendCommandAcknoledge>:
       //AcknoledgeCommand
       SendCommandAcknoledge(slaveCmd,slaveMsg);
	 }//EndIf	 
}

void SendCommandAcknoledge(char AckCommand,char AckData){
     dc0:	0f 93       	push	r16
     dc2:	1f 93       	push	r17
     dc4:	18 2f       	mov	r17, r24
     dc6:	06 2f       	mov	r16, r22
	 systemMaster();
     dc8:	0e 94 bb 06 	call	0xd76	; 0xd76 <systemMaster>
	sbi(DDRD,2);sbi(PORTD,2);//128-SS HIGH
	//_delay_ms(10);
}

void SendSPI(char xSPI){
     _spi(xSPI);
     dcc:	89 e0       	ldi	r24, 0x09	; 9
     dce:	0e 94 b5 13 	call	0x276a	; 0x276a <_spi>
	 systemMaster();
	 SendSPI(0x09);
	 SendSPI(AckCommand);
	 SendSPI(AckData);
	 SendSPI(0x0A);
	 systemSlave();
     dd2:	81 2f       	mov	r24, r17
     dd4:	0e 94 b5 13 	call	0x276a	; 0x276a <_spi>
     dd8:	80 2f       	mov	r24, r16
     dda:	0e 94 b5 13 	call	0x276a	; 0x276a <_spi>
     dde:	8a e0       	ldi	r24, 0x0A	; 10
     de0:	0e 94 b5 13 	call	0x276a	; 0x276a <_spi>
     de4:	0e 94 ae 06 	call	0xd5c	; 0xd5c <systemSlave>
}
     de8:	1f 91       	pop	r17
     dea:	0f 91       	pop	r16
     dec:	08 95       	ret

00000dee <__vector_20>:
		 }
     }
	 */		 
}

ISR(USART1_RXC_vect){
     dee:	1f 92       	push	r1
     df0:	0f 92       	push	r0
     df2:	0f b6       	in	r0, 0x3f	; 63
     df4:	0f 92       	push	r0
     df6:	11 24       	eor	r1, r1
     df8:	1f 93       	push	r17
     dfa:	2f 93       	push	r18
     dfc:	3f 93       	push	r19
     dfe:	4f 93       	push	r20
     e00:	5f 93       	push	r21
     e02:	6f 93       	push	r22
     e04:	7f 93       	push	r23
     e06:	8f 93       	push	r24
     e08:	9f 93       	push	r25
     e0a:	af 93       	push	r26
     e0c:	bf 93       	push	r27
     e0e:	ef 93       	push	r30
     e10:	ff 93       	push	r31
	char dataRX1;
    dataRX1=UDR1;
     e12:	13 b1       	in	r17, 0x03	; 3


   if (IFType==IT_SLAVE){
     e14:	80 91 00 01 	lds	r24, 0x0100
     e18:	81 30       	cpi	r24, 0x01	; 1
     e1a:	39 f4       	brne	.+14     	; 0xe2a <__vector_20+0x3c>
	   systemMaster();
     e1c:	0e 94 bb 06 	call	0xd76	; 0xd76 <systemMaster>
	   _spi(dataRX1);
     e20:	81 2f       	mov	r24, r17
     e22:	0e 94 b5 13 	call	0x276a	; 0x276a <_spi>
	   systemSlave();
     e26:	0e 94 ae 06 	call	0xd5c	; 0xd5c <systemSlave>
	   }
	   
	//_uart(1,1,dataRX1);
	//OnReceive1(dataRX1);
}
     e2a:	ff 91       	pop	r31
     e2c:	ef 91       	pop	r30
     e2e:	bf 91       	pop	r27
     e30:	af 91       	pop	r26
     e32:	9f 91       	pop	r25
     e34:	8f 91       	pop	r24
     e36:	7f 91       	pop	r23
     e38:	6f 91       	pop	r22
     e3a:	5f 91       	pop	r21
     e3c:	4f 91       	pop	r20
     e3e:	3f 91       	pop	r19
     e40:	2f 91       	pop	r18
     e42:	1f 91       	pop	r17
     e44:	0f 90       	pop	r0
     e46:	0f be       	out	0x3f, r0	; 63
     e48:	0f 90       	pop	r0
     e4a:	1f 90       	pop	r1
     e4c:	18 95       	reti

00000e4e <__vector_19>:
	if ((TimExp%100)==0) TimWatchSequence++;
	TimReceive++;
	TimDelayNextPump++;
}

ISR(USART0_RXC_vect){
     e4e:	1f 92       	push	r1
     e50:	0f 92       	push	r0
     e52:	0f b6       	in	r0, 0x3f	; 63
     e54:	0f 92       	push	r0
     e56:	11 24       	eor	r1, r1
     e58:	1f 93       	push	r17
     e5a:	2f 93       	push	r18
     e5c:	3f 93       	push	r19
     e5e:	4f 93       	push	r20
     e60:	5f 93       	push	r21
     e62:	6f 93       	push	r22
     e64:	7f 93       	push	r23
     e66:	8f 93       	push	r24
     e68:	9f 93       	push	r25
     e6a:	af 93       	push	r26
     e6c:	bf 93       	push	r27
     e6e:	ef 93       	push	r30
     e70:	ff 93       	push	r31
    char dataRX0;
	char strSend[20];
	dataRX0=UDR0;
     e72:	1c b1       	in	r17, 0x0c	; 12
    //_uart(1,1,dataRX0);
    //15702 15588 15694

	//_uart(0,1,dataRX0);

	switch(IFType){
     e74:	80 91 00 01 	lds	r24, 0x0100
     e78:	81 30       	cpi	r24, 0x01	; 1
     e7a:	19 f0       	breq	.+6      	; 0xe82 <__vector_19+0x34>
     e7c:	82 30       	cpi	r24, 0x02	; 2
     e7e:	b9 f4       	brne	.+46     	; 0xeae <__vector_19+0x60>
     e80:	08 c0       	rjmp	.+16     	; 0xe92 <__vector_19+0x44>
	case IT_SLAVE:
	     systemMaster();
     e82:	0e 94 bb 06 	call	0xd76	; 0xd76 <systemMaster>
	     _spi(dataRX0);
     e86:	81 2f       	mov	r24, r17
     e88:	0e 94 b5 13 	call	0x276a	; 0x276a <_spi>

         //_uart(0,1,dataRX0);
		 //_uart(1,1,dataRX0);

	     systemSlave();
     e8c:	0e 94 ae 06 	call	0xd5c	; 0xd5c <systemSlave>
     e90:	0e c0       	rjmp	.+28     	; 0xeae <__vector_19+0x60>
	     break;
    case IT_STANDALONE:
	     switch(StandaloneType){
     e92:	80 91 01 01 	lds	r24, 0x0101
     e96:	81 30       	cpi	r24, 0x01	; 1
     e98:	19 f0       	breq	.+6      	; 0xea0 <__vector_19+0x52>
     e9a:	82 30       	cpi	r24, 0x02	; 2
     e9c:	41 f4       	brne	.+16     	; 0xeae <__vector_19+0x60>
     e9e:	04 c0       	rjmp	.+8      	; 0xea8 <__vector_19+0x5a>
		 case ST_GILBARCO:
		      GilbarcoOnReceive(dataRX0);	
     ea0:	81 2f       	mov	r24, r17
     ea2:	0e 94 cf 05 	call	0xb9e	; 0xb9e <GilbarcoOnReceive>
     ea6:	03 c0       	rjmp	.+6      	; 0xeae <__vector_19+0x60>
			  break;
		 case ST_WAYNE_DART:
		      WayneOnReceive(dataRX0);	              
     ea8:	81 2f       	mov	r24, r17
     eaa:	0e 94 96 04 	call	0x92c	; 0x92c <WayneOnReceive>
			  //_uart_print(1,1,strSend);
			  break;
		 }
     }
	 */		 
}
     eae:	ff 91       	pop	r31
     eb0:	ef 91       	pop	r30
     eb2:	bf 91       	pop	r27
     eb4:	af 91       	pop	r26
     eb6:	9f 91       	pop	r25
     eb8:	8f 91       	pop	r24
     eba:	7f 91       	pop	r23
     ebc:	6f 91       	pop	r22
     ebe:	5f 91       	pop	r21
     ec0:	4f 91       	pop	r20
     ec2:	3f 91       	pop	r19
     ec4:	2f 91       	pop	r18
     ec6:	1f 91       	pop	r17
     ec8:	0f 90       	pop	r0
     eca:	0f be       	out	0x3f, r0	; 63
     ecc:	0f 90       	pop	r0
     ece:	1f 90       	pop	r1
     ed0:	18 95       	reti

00000ed2 <PumpCommand>:
	 sprintf_P(strSend,PSTR("PumpCmd:%.2X"),DataSend);
	 _uart_print(1,1,strSend);
	 #endif


     _uart(0,1,DataSend);	 
     ed2:	62 95       	swap	r22
     ed4:	60 7f       	andi	r22, 0xF0	; 240
     ed6:	48 2f       	mov	r20, r24
     ed8:	4f 70       	andi	r20, 0x0F	; 15
     eda:	46 2b       	or	r20, r22
     edc:	80 e0       	ldi	r24, 0x00	; 0
     ede:	61 e0       	ldi	r22, 0x01	; 1
     ee0:	0e 94 7f 14 	call	0x28fe	; 0x28fe <_uart>
     //_uart(1,1,DataSend);
}
     ee4:	08 95       	ret

00000ee6 <WayneSendChar>:
	      break;	 
	 }
}

//enum eLineStatus{LS_NONE,LS_RX,LS_TX};
void WayneSendChar(char xData){
     ee6:	1f 93       	push	r17
     ee8:	18 2f       	mov	r17, r24
     System485(DIR_TX);//TransmitMode
     eea:	81 e0       	ldi	r24, 0x01	; 1
     eec:	0e 94 9c 01 	call	0x338	; 0x338 <System485>
	 _uart(0,1,xData);
     ef0:	80 e0       	ldi	r24, 0x00	; 0
     ef2:	61 e0       	ldi	r22, 0x01	; 1
     ef4:	41 2f       	mov	r20, r17
     ef6:	0e 94 7f 14 	call	0x28fe	; 0x28fe <_uart>
	 System485(DIR_RX);//ReceiveMode
     efa:	82 e0       	ldi	r24, 0x02	; 2
     efc:	0e 94 9c 01 	call	0x338	; 0x338 <System485>
}
     f00:	1f 91       	pop	r17
     f02:	08 95       	ret

00000f04 <FWayneSendBuffer>:

void WayneTestSend(){
}

void FWayneSendBuffer(char *Buffer, char nLength){
     f04:	0f 93       	push	r16
     f06:	1f 93       	push	r17
     f08:	cf 93       	push	r28
     f0a:	df 93       	push	r29
     f0c:	06 2f       	mov	r16, r22
     f0e:	ec 01       	movw	r28, r24
     f10:	10 e0       	ldi	r17, 0x00	; 0
     f12:	04 c0       	rjmp	.+8      	; 0xf1c <FWayneSendBuffer+0x18>
char i;
     for(i=0;i<nLength;i++){
	     WayneSendChar(Buffer[i]);
     f14:	89 91       	ld	r24, Y+
     f16:	0e 94 73 07 	call	0xee6	; 0xee6 <WayneSendChar>
void WayneTestSend(){
}

void FWayneSendBuffer(char *Buffer, char nLength){
char i;
     for(i=0;i<nLength;i++){
     f1a:	1f 5f       	subi	r17, 0xFF	; 255
     f1c:	10 17       	cp	r17, r16
     f1e:	d0 f3       	brcs	.-12     	; 0xf14 <FWayneSendBuffer+0x10>
	     WayneSendChar(Buffer[i]);
	 }
}
     f20:	df 91       	pop	r29
     f22:	cf 91       	pop	r28
     f24:	1f 91       	pop	r17
     f26:	0f 91       	pop	r16
     f28:	08 95       	ret

00000f2a <FWayneSendCommand>:

void FWayneSendCommand(char Command, char SequenceCmd, char xPumpID, char NozzleID){
     f2a:	0f 93       	push	r16
     f2c:	1f 93       	push	r17
     f2e:	df 93       	push	r29
     f30:	cf 93       	push	r28
     f32:	cd b7       	in	r28, 0x3d	; 61
     f34:	de b7       	in	r29, 0x3e	; 62
     f36:	6e 97       	sbiw	r28, 0x1e	; 30
     f38:	0f b6       	in	r0, 0x3f	; 63
     f3a:	f8 94       	cli
     f3c:	de bf       	out	0x3e, r29	; 62
     f3e:	0f be       	out	0x3f, r0	; 63
     f40:	cd bf       	out	0x3d, r28	; 61
     f42:	16 2f       	mov	r17, r22
     f44:	02 2f       	mov	r16, r18
char STX_ID,SEQ,MSG_ID[2],NOZZLE_ID,VALUE[6];
int tCRC16;
char strSend[30];
char CmdBuffer[30];
     
	 rxBufferLength=0;
     f46:	10 92 15 01 	sts	0x0115, r1
     switch(Command){
     f4a:	8a 30       	cpi	r24, 0x0A	; 10
     f4c:	41 f1       	breq	.+80     	; 0xf9e <FWayneSendCommand+0x74>
     f4e:	8b 30       	cpi	r24, 0x0B	; 11
     f50:	40 f4       	brcc	.+16     	; 0xf62 <FWayneSendCommand+0x38>
     f52:	85 30       	cpi	r24, 0x05	; 5
     f54:	09 f4       	brne	.+2      	; 0xf58 <FWayneSendCommand+0x2e>
     f56:	ba c0       	rjmp	.+372    	; 0x10cc <FWayneSendCommand+0x1a2>
     f58:	87 30       	cpi	r24, 0x07	; 7
     f5a:	a9 f0       	breq	.+42     	; 0xf86 <FWayneSendCommand+0x5c>
     f5c:	88 23       	and	r24, r24
     f5e:	69 f0       	breq	.+26     	; 0xf7a <FWayneSendCommand+0x50>
     f60:	23 c1       	rjmp	.+582    	; 0x11a8 <FWayneSendCommand+0x27e>
     f62:	8c 30       	cpi	r24, 0x0C	; 12
     f64:	09 f4       	brne	.+2      	; 0xf68 <FWayneSendCommand+0x3e>
     f66:	50 c0       	rjmp	.+160    	; 0x1008 <FWayneSendCommand+0xde>
     f68:	8c 30       	cpi	r24, 0x0C	; 12
     f6a:	a0 f1       	brcs	.+104    	; 0xfd4 <FWayneSendCommand+0xaa>
     f6c:	8d 30       	cpi	r24, 0x0D	; 13
     f6e:	09 f4       	brne	.+2      	; 0xf72 <FWayneSendCommand+0x48>
     f70:	75 c0       	rjmp	.+234    	; 0x105c <FWayneSendCommand+0x132>
     f72:	8e 30       	cpi	r24, 0x0E	; 14
     f74:	09 f0       	breq	.+2      	; 0xf78 <FWayneSendCommand+0x4e>
     f76:	18 c1       	rjmp	.+560    	; 0x11a8 <FWayneSendCommand+0x27e>
     f78:	d4 c0       	rjmp	.+424    	; 0x1122 <FWayneSendCommand+0x1f8>
	      STX_ID=0x50|(0x0F&(xPumpID));
		  WayneSendChar(STX_ID);
	      WayneSendChar(0x20);
	      WayneSendChar(0xFA);
		  */
		  CmdBuffer[0]=0x50|(0x0F&(xPumpID));
     f7a:	4f 70       	andi	r20, 0x0F	; 15
     f7c:	40 65       	ori	r20, 0x50	; 80
     f7e:	49 83       	std	Y+1, r20	; 0x01
		  CmdBuffer[1]=0x20;
     f80:	80 e2       	ldi	r24, 0x20	; 32
     f82:	8a 83       	std	Y+2, r24	; 0x02
     f84:	06 c0       	rjmp	.+12     	; 0xf92 <FWayneSendCommand+0x68>
	      WayneSendChar(SEQ);
	      WayneSendChar(0xFA);
		  */
		  //sprintf_P(strSend,PSTR("[%.2X %.2X %.2X ]"),STX_ID,SEQ,0xFA);
          //_uart_print(1,1,strSend);
		  CmdBuffer[0]=0x50|(0x0F&(xPumpID));
     f86:	4f 70       	andi	r20, 0x0F	; 15
     f88:	40 65       	ori	r20, 0x50	; 80
     f8a:	49 83       	std	Y+1, r20	; 0x01
		  CmdBuffer[1]=0xC0|(0x0F&SequenceCmd);
     f8c:	1f 70       	andi	r17, 0x0F	; 15
     f8e:	10 6c       	ori	r17, 0xC0	; 192
     f90:	1a 83       	std	Y+2, r17	; 0x02
		  CmdBuffer[2]=0xFA;
     f92:	8a ef       	ldi	r24, 0xFA	; 250
     f94:	8b 83       	std	Y+3, r24	; 0x03
		  FWayneSendBuffer(CmdBuffer,3);
     f96:	ce 01       	movw	r24, r28
     f98:	01 96       	adiw	r24, 0x01	; 1
     f9a:	63 e0       	ldi	r22, 0x03	; 3
     f9c:	03 c1       	rjmp	.+518    	; 0x11a4 <FWayneSendCommand+0x27a>
	      break;
     case CMD_AUTH_1://[51 31 01 01 05 63 63 03 FA]//Auth1 ->9
          tCRC16=0;
		  CmdBuffer[0]=0x50|(0x0F&xPumpID);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[0]);
     f9e:	64 2f       	mov	r22, r20
     fa0:	6f 70       	andi	r22, 0x0F	; 15
     fa2:	60 65       	ori	r22, 0x50	; 80
     fa4:	69 83       	std	Y+1, r22	; 0x01
     fa6:	80 e0       	ldi	r24, 0x00	; 0
     fa8:	90 e0       	ldi	r25, 0x00	; 0
     faa:	0e 94 86 01 	call	0x30c	; 0x30c <CRC_Wayne>
		  CmdBuffer[1]=0x30|(0x0F&SequenceCmd);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[1]);
     fae:	61 2f       	mov	r22, r17
     fb0:	6f 70       	andi	r22, 0x0F	; 15
     fb2:	60 63       	ori	r22, 0x30	; 48
     fb4:	6a 83       	std	Y+2, r22	; 0x02
     fb6:	0e 94 86 01 	call	0x30c	; 0x30c <CRC_Wayne>
		  CmdBuffer[2]=0x01;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[2]);
     fba:	11 e0       	ldi	r17, 0x01	; 1
     fbc:	1b 83       	std	Y+3, r17	; 0x03
     fbe:	61 e0       	ldi	r22, 0x01	; 1
     fc0:	0e 94 86 01 	call	0x30c	; 0x30c <CRC_Wayne>
		  CmdBuffer[3]=0x01;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[3]);
     fc4:	1c 83       	std	Y+4, r17	; 0x04
     fc6:	61 e0       	ldi	r22, 0x01	; 1
     fc8:	0e 94 86 01 	call	0x30c	; 0x30c <CRC_Wayne>
		  CmdBuffer[4]=0x05;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[4]);
     fcc:	25 e0       	ldi	r18, 0x05	; 5
     fce:	2d 83       	std	Y+5, r18	; 0x05
     fd0:	65 e0       	ldi	r22, 0x05	; 5
     fd2:	97 c0       	rjmp	.+302    	; 0x1102 <FWayneSendCommand+0x1d8>
		  CmdBuffer[8]=0xFA;
          FWayneSendBuffer(CmdBuffer,9);
	      break;
     case CMD_AUTH_2://[51 32 01 01 00 A3 24 03 FA]//Auth2 ->9
          tCRC16=0;
		  CmdBuffer[0]=0x50|(0x0F&xPumpID);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[0]);
     fd4:	64 2f       	mov	r22, r20
     fd6:	6f 70       	andi	r22, 0x0F	; 15
     fd8:	60 65       	ori	r22, 0x50	; 80
     fda:	69 83       	std	Y+1, r22	; 0x01
     fdc:	80 e0       	ldi	r24, 0x00	; 0
     fde:	90 e0       	ldi	r25, 0x00	; 0
     fe0:	0e 94 86 01 	call	0x30c	; 0x30c <CRC_Wayne>
		  CmdBuffer[1]=0x30|(0x0F&SequenceCmd);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[1]);
     fe4:	61 2f       	mov	r22, r17
     fe6:	6f 70       	andi	r22, 0x0F	; 15
     fe8:	60 63       	ori	r22, 0x30	; 48
     fea:	6a 83       	std	Y+2, r22	; 0x02
     fec:	0e 94 86 01 	call	0x30c	; 0x30c <CRC_Wayne>
		  CmdBuffer[2]=0x01;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[2]);
     ff0:	11 e0       	ldi	r17, 0x01	; 1
     ff2:	1b 83       	std	Y+3, r17	; 0x03
     ff4:	61 e0       	ldi	r22, 0x01	; 1
     ff6:	0e 94 86 01 	call	0x30c	; 0x30c <CRC_Wayne>
		  CmdBuffer[3]=0x01;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[3]);
     ffa:	1c 83       	std	Y+4, r17	; 0x04
     ffc:	61 e0       	ldi	r22, 0x01	; 1
     ffe:	0e 94 86 01 	call	0x30c	; 0x30c <CRC_Wayne>
		  CmdBuffer[4]=0x00;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[4]);
    1002:	1d 82       	std	Y+5, r1	; 0x05
    1004:	60 e0       	ldi	r22, 0x00	; 0
    1006:	7d c0       	rjmp	.+250    	; 0x1102 <FWayneSendCommand+0x1d8>
		  CmdBuffer[8]=0xFA;
          FWayneSendBuffer(CmdBuffer,9);
	      break;
     case CMD_AUTH_3://Preset Auth Max Volume
          tCRC16=0;//[51 33 04 04 99 99 99 99 63 3E 03 FA]//Auth3 ->12
		  CmdBuffer[0]=0x50|(0x0F&xPumpID);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[0]);
    1008:	64 2f       	mov	r22, r20
    100a:	6f 70       	andi	r22, 0x0F	; 15
    100c:	60 65       	ori	r22, 0x50	; 80
    100e:	69 83       	std	Y+1, r22	; 0x01
    1010:	80 e0       	ldi	r24, 0x00	; 0
    1012:	90 e0       	ldi	r25, 0x00	; 0
    1014:	0e 94 86 01 	call	0x30c	; 0x30c <CRC_Wayne>
		  CmdBuffer[1]=0x30|(0x0F&SequenceCmd);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[1]);
    1018:	61 2f       	mov	r22, r17
    101a:	6f 70       	andi	r22, 0x0F	; 15
    101c:	60 63       	ori	r22, 0x30	; 48
    101e:	6a 83       	std	Y+2, r22	; 0x02
    1020:	0e 94 86 01 	call	0x30c	; 0x30c <CRC_Wayne>
		  CmdBuffer[2]=0x04;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[2]);
    1024:	14 e0       	ldi	r17, 0x04	; 4
    1026:	1b 83       	std	Y+3, r17	; 0x03
    1028:	64 e0       	ldi	r22, 0x04	; 4
    102a:	0e 94 86 01 	call	0x30c	; 0x30c <CRC_Wayne>
		  CmdBuffer[3]=0x04;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[3]);
    102e:	1c 83       	std	Y+4, r17	; 0x04
    1030:	64 e0       	ldi	r22, 0x04	; 4
    1032:	0e 94 86 01 	call	0x30c	; 0x30c <CRC_Wayne>
		  CmdBuffer[4]=MaxAuthVolume[0];tCRC16=CRC_Wayne(tCRC16,CmdBuffer[4]);
    1036:	60 91 07 01 	lds	r22, 0x0107
    103a:	6d 83       	std	Y+5, r22	; 0x05
    103c:	0e 94 86 01 	call	0x30c	; 0x30c <CRC_Wayne>
		  CmdBuffer[5]=MaxAuthVolume[1];tCRC16=CRC_Wayne(tCRC16,CmdBuffer[5]);
    1040:	60 91 08 01 	lds	r22, 0x0108
    1044:	6e 83       	std	Y+6, r22	; 0x06
    1046:	0e 94 86 01 	call	0x30c	; 0x30c <CRC_Wayne>
		  CmdBuffer[6]=MaxAuthVolume[2];tCRC16=CRC_Wayne(tCRC16,CmdBuffer[6]);
    104a:	60 91 09 01 	lds	r22, 0x0109
    104e:	6f 83       	std	Y+7, r22	; 0x07
    1050:	0e 94 86 01 	call	0x30c	; 0x30c <CRC_Wayne>
		  CmdBuffer[7]=MaxAuthVolume[3];tCRC16=CRC_Wayne(tCRC16,CmdBuffer[7]);
    1054:	60 91 0a 01 	lds	r22, 0x010A
    1058:	68 87       	std	Y+8, r22	; 0x08
    105a:	28 c0       	rjmp	.+80     	; 0x10ac <FWayneSendCommand+0x182>
	 [51 34 02 01 01 01 01 06 5C BF 03 FA]//Auth4 Nozzle1
     [51 34 02 01 02 01 01 06 5C FB 03 FA]//Auth4 Nozzle2

	 */
          tCRC16=0;
		  CmdBuffer[0]=0x50|(0x0F&xPumpID);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[0]);
    105c:	64 2f       	mov	r22, r20
    105e:	6f 70       	andi	r22, 0x0F	; 15
    1060:	60 65       	ori	r22, 0x50	; 80
    1062:	69 83       	std	Y+1, r22	; 0x01
    1064:	80 e0       	ldi	r24, 0x00	; 0
    1066:	90 e0       	ldi	r25, 0x00	; 0
    1068:	0e 94 86 01 	call	0x30c	; 0x30c <CRC_Wayne>
		  CmdBuffer[1]=0x30|(0x0F&SequenceCmd);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[1]);
    106c:	61 2f       	mov	r22, r17
    106e:	6f 70       	andi	r22, 0x0F	; 15
    1070:	60 63       	ori	r22, 0x30	; 48
    1072:	6a 83       	std	Y+2, r22	; 0x02
    1074:	0e 94 86 01 	call	0x30c	; 0x30c <CRC_Wayne>
		  CmdBuffer[2]=0x02;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[2]);
    1078:	22 e0       	ldi	r18, 0x02	; 2
    107a:	2b 83       	std	Y+3, r18	; 0x03
    107c:	62 e0       	ldi	r22, 0x02	; 2
    107e:	0e 94 86 01 	call	0x30c	; 0x30c <CRC_Wayne>
		  CmdBuffer[3]=0x01;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[3]);
    1082:	11 e0       	ldi	r17, 0x01	; 1
    1084:	1c 83       	std	Y+4, r17	; 0x04
    1086:	61 e0       	ldi	r22, 0x01	; 1
    1088:	0e 94 86 01 	call	0x30c	; 0x30c <CRC_Wayne>
		  CmdBuffer[4]=(NozzleID&0x0F);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[4]);
    108c:	60 2f       	mov	r22, r16
    108e:	6f 70       	andi	r22, 0x0F	; 15
    1090:	6d 83       	std	Y+5, r22	; 0x05
    1092:	0e 94 86 01 	call	0x30c	; 0x30c <CRC_Wayne>
		  CmdBuffer[5]=0x01;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[5]);
    1096:	1e 83       	std	Y+6, r17	; 0x06
    1098:	61 e0       	ldi	r22, 0x01	; 1
    109a:	0e 94 86 01 	call	0x30c	; 0x30c <CRC_Wayne>
		  CmdBuffer[6]=0x01;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[6]);
    109e:	1f 83       	std	Y+7, r17	; 0x07
    10a0:	61 e0       	ldi	r22, 0x01	; 1
    10a2:	0e 94 86 01 	call	0x30c	; 0x30c <CRC_Wayne>
		  CmdBuffer[7]=0x06;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[7]);
    10a6:	26 e0       	ldi	r18, 0x06	; 6
    10a8:	28 87       	std	Y+8, r18	; 0x08
    10aa:	66 e0       	ldi	r22, 0x06	; 6
    10ac:	0e 94 86 01 	call	0x30c	; 0x30c <CRC_Wayne>
		  CmdBuffer[8]=tCRC16;
    10b0:	89 87       	std	Y+9, r24	; 0x09
		  CmdBuffer[9]=tCRC16>>8;
    10b2:	29 2f       	mov	r18, r25
    10b4:	33 27       	eor	r19, r19
    10b6:	27 fd       	sbrc	r18, 7
    10b8:	3a 95       	dec	r19
    10ba:	2a 87       	std	Y+10, r18	; 0x0a
		  CmdBuffer[10]=0x03;
    10bc:	83 e0       	ldi	r24, 0x03	; 3
    10be:	8b 87       	std	Y+11, r24	; 0x0b
		  CmdBuffer[11]=0xFA;
    10c0:	8a ef       	ldi	r24, 0xFA	; 250
    10c2:	8c 87       	std	Y+12, r24	; 0x0c
          FWayneSendBuffer(CmdBuffer,12);
    10c4:	ce 01       	movw	r24, r28
    10c6:	01 96       	adiw	r24, 0x01	; 1
    10c8:	6c e0       	ldi	r22, 0x0C	; 12
    10ca:	6c c0       	rjmp	.+216    	; 0x11a4 <FWayneSendCommand+0x27a>
	      break;     
     case CMD_TOTALIZER://[51] [37] [08 01] [02] [F2 2B] [03 FA] 
          tCRC16=0;     //[51   30   08 01   01   B3 5E   03 FA] //Total N1
		  CmdBuffer[0]=0x50|(0x0F&xPumpID);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[0]);
    10cc:	64 2f       	mov	r22, r20
    10ce:	6f 70       	andi	r22, 0x0F	; 15
    10d0:	60 65       	ori	r22, 0x50	; 80
    10d2:	69 83       	std	Y+1, r22	; 0x01
    10d4:	80 e0       	ldi	r24, 0x00	; 0
    10d6:	90 e0       	ldi	r25, 0x00	; 0
    10d8:	0e 94 86 01 	call	0x30c	; 0x30c <CRC_Wayne>
		  CmdBuffer[1]=0x30|(0x0F&SequenceCmd);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[1]);
    10dc:	61 2f       	mov	r22, r17
    10de:	6f 70       	andi	r22, 0x0F	; 15
    10e0:	60 63       	ori	r22, 0x30	; 48
    10e2:	6a 83       	std	Y+2, r22	; 0x02
    10e4:	0e 94 86 01 	call	0x30c	; 0x30c <CRC_Wayne>
		  CmdBuffer[2]=0x08;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[2]);
    10e8:	28 e0       	ldi	r18, 0x08	; 8
    10ea:	2b 83       	std	Y+3, r18	; 0x03
    10ec:	68 e0       	ldi	r22, 0x08	; 8
    10ee:	0e 94 86 01 	call	0x30c	; 0x30c <CRC_Wayne>
		  CmdBuffer[3]=0x01;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[3]);
    10f2:	21 e0       	ldi	r18, 0x01	; 1
    10f4:	2c 83       	std	Y+4, r18	; 0x04
    10f6:	61 e0       	ldi	r22, 0x01	; 1
    10f8:	0e 94 86 01 	call	0x30c	; 0x30c <CRC_Wayne>
		  CmdBuffer[4]=(NozzleID&0x0F);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[4]);
    10fc:	60 2f       	mov	r22, r16
    10fe:	6f 70       	andi	r22, 0x0F	; 15
    1100:	6d 83       	std	Y+5, r22	; 0x05
    1102:	0e 94 86 01 	call	0x30c	; 0x30c <CRC_Wayne>
		  CmdBuffer[5]=tCRC16;
    1106:	8e 83       	std	Y+6, r24	; 0x06
		  CmdBuffer[6]=tCRC16>>8;
    1108:	29 2f       	mov	r18, r25
    110a:	33 27       	eor	r19, r19
    110c:	27 fd       	sbrc	r18, 7
    110e:	3a 95       	dec	r19
    1110:	2f 83       	std	Y+7, r18	; 0x07
		  CmdBuffer[7]=0x03;
    1112:	83 e0       	ldi	r24, 0x03	; 3
    1114:	88 87       	std	Y+8, r24	; 0x08
		  CmdBuffer[8]=0xFA;
    1116:	8a ef       	ldi	r24, 0xFA	; 250
    1118:	89 87       	std	Y+9, r24	; 0x09
          FWayneSendBuffer(CmdBuffer,9);
    111a:	ce 01       	movw	r24, r28
    111c:	01 96       	adiw	r24, 0x01	; 1
    111e:	69 e0       	ldi	r22, 0x09	; 9
    1120:	41 c0       	rjmp	.+130    	; 0x11a4 <FWayneSendCommand+0x27a>
	 /*
  	   [51 30 [01 01] 00 01 01 04 01 01 03 E4 2E [03 FA] //Get Last Status

	 */
          tCRC16=0;
		  CmdBuffer[0]=0x50|(0x0F&xPumpID);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[0]);
    1122:	64 2f       	mov	r22, r20
    1124:	6f 70       	andi	r22, 0x0F	; 15
    1126:	60 65       	ori	r22, 0x50	; 80
    1128:	69 83       	std	Y+1, r22	; 0x01
    112a:	80 e0       	ldi	r24, 0x00	; 0
    112c:	90 e0       	ldi	r25, 0x00	; 0
    112e:	0e 94 86 01 	call	0x30c	; 0x30c <CRC_Wayne>
		  CmdBuffer[1]=0x30|(0x0F&SequenceCmd);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[1]);
    1132:	61 2f       	mov	r22, r17
    1134:	6f 70       	andi	r22, 0x0F	; 15
    1136:	60 63       	ori	r22, 0x30	; 48
    1138:	6a 83       	std	Y+2, r22	; 0x02
    113a:	0e 94 86 01 	call	0x30c	; 0x30c <CRC_Wayne>
		  CmdBuffer[2]=0x01;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[2]);
    113e:	11 e0       	ldi	r17, 0x01	; 1
    1140:	1b 83       	std	Y+3, r17	; 0x03
    1142:	61 e0       	ldi	r22, 0x01	; 1
    1144:	0e 94 86 01 	call	0x30c	; 0x30c <CRC_Wayne>
		  CmdBuffer[3]=0x01;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[3]);
    1148:	1c 83       	std	Y+4, r17	; 0x04
    114a:	61 e0       	ldi	r22, 0x01	; 1
    114c:	0e 94 86 01 	call	0x30c	; 0x30c <CRC_Wayne>
		  CmdBuffer[4]=0x00;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[4]);
    1150:	1d 82       	std	Y+5, r1	; 0x05
    1152:	60 e0       	ldi	r22, 0x00	; 0
    1154:	0e 94 86 01 	call	0x30c	; 0x30c <CRC_Wayne>
		  CmdBuffer[5]=0x01;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[5]);
    1158:	1e 83       	std	Y+6, r17	; 0x06
    115a:	61 e0       	ldi	r22, 0x01	; 1
    115c:	0e 94 86 01 	call	0x30c	; 0x30c <CRC_Wayne>
		  CmdBuffer[6]=0x01;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[6]);
    1160:	1f 83       	std	Y+7, r17	; 0x07
    1162:	61 e0       	ldi	r22, 0x01	; 1
    1164:	0e 94 86 01 	call	0x30c	; 0x30c <CRC_Wayne>
		  CmdBuffer[7]=0x04;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[7]);
    1168:	24 e0       	ldi	r18, 0x04	; 4
    116a:	28 87       	std	Y+8, r18	; 0x08
    116c:	64 e0       	ldi	r22, 0x04	; 4
    116e:	0e 94 86 01 	call	0x30c	; 0x30c <CRC_Wayne>
		  CmdBuffer[8]=0x01;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[8]);
    1172:	19 87       	std	Y+9, r17	; 0x09
    1174:	61 e0       	ldi	r22, 0x01	; 1
    1176:	0e 94 86 01 	call	0x30c	; 0x30c <CRC_Wayne>
		  CmdBuffer[9]=0x01;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[9]);
    117a:	1a 87       	std	Y+10, r17	; 0x0a
    117c:	61 e0       	ldi	r22, 0x01	; 1
    117e:	0e 94 86 01 	call	0x30c	; 0x30c <CRC_Wayne>
		  CmdBuffer[10]=0x03;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[10]);
    1182:	13 e0       	ldi	r17, 0x03	; 3
    1184:	1b 87       	std	Y+11, r17	; 0x0b
    1186:	63 e0       	ldi	r22, 0x03	; 3
    1188:	0e 94 86 01 	call	0x30c	; 0x30c <CRC_Wayne>
		  CmdBuffer[11]=tCRC16;
    118c:	8c 87       	std	Y+12, r24	; 0x0c
		  CmdBuffer[12]=tCRC16>>8;
    118e:	29 2f       	mov	r18, r25
    1190:	33 27       	eor	r19, r19
    1192:	27 fd       	sbrc	r18, 7
    1194:	3a 95       	dec	r19
    1196:	2d 87       	std	Y+13, r18	; 0x0d
		  CmdBuffer[13]=0x03;
    1198:	1e 87       	std	Y+14, r17	; 0x0e
		  CmdBuffer[14]=0xFA;
    119a:	8a ef       	ldi	r24, 0xFA	; 250
    119c:	8f 87       	std	Y+15, r24	; 0x0f
          FWayneSendBuffer(CmdBuffer,15);
    119e:	ce 01       	movw	r24, r28
    11a0:	01 96       	adiw	r24, 0x01	; 1
    11a2:	6f e0       	ldi	r22, 0x0F	; 15
    11a4:	0e 94 82 07 	call	0xf04	; 0xf04 <FWayneSendBuffer>
	      break;
     case CMD_REQ_GLOBAL_STATUS_2:
  	      break;
	 }	 
}
    11a8:	6e 96       	adiw	r28, 0x1e	; 30
    11aa:	0f b6       	in	r0, 0x3f	; 63
    11ac:	f8 94       	cli
    11ae:	de bf       	out	0x3e, r29	; 62
    11b0:	0f be       	out	0x3f, r0	; 63
    11b2:	cd bf       	out	0x3d, r28	; 61
    11b4:	cf 91       	pop	r28
    11b6:	df 91       	pop	r29
    11b8:	1f 91       	pop	r17
    11ba:	0f 91       	pop	r16
    11bc:	08 95       	ret

000011be <SendTotalizerFlow>:
	    SendSPI(strSendSPI[i]);
        //_uart(1,1,strSendSPI[i]);
	 } 
}

void SendTotalizerFlow(char xPumpID){
    11be:	4f 92       	push	r4
    11c0:	5f 92       	push	r5
    11c2:	6f 92       	push	r6
    11c4:	7f 92       	push	r7
    11c6:	8f 92       	push	r8
    11c8:	9f 92       	push	r9
    11ca:	af 92       	push	r10
    11cc:	bf 92       	push	r11
    11ce:	cf 92       	push	r12
    11d0:	df 92       	push	r13
    11d2:	ef 92       	push	r14
    11d4:	ff 92       	push	r15
    11d6:	0f 93       	push	r16
    11d8:	1f 93       	push	r17
    11da:	df 93       	push	r29
    11dc:	cf 93       	push	r28
    11de:	cd b7       	in	r28, 0x3d	; 61
    11e0:	de b7       	in	r29, 0x3e	; 62
    11e2:	a8 97       	sbiw	r28, 0x28	; 40
    11e4:	0f b6       	in	r0, 0x3f	; 63
    11e6:	f8 94       	cli
    11e8:	de bf       	out	0x3e, r29	; 62
    11ea:	0f be       	out	0x3f, r0	; 63
    11ec:	cd bf       	out	0x3d, r28	; 61
char i,xPump,strSend[40];
char strVol[10],strMon[10];
	 //                           [0x50,0x05]  02     01    0000000  0000000  0000000  0000000  0000200  0000000  0000200  0000000  0000000  0000000 [0x06,0x60] = 4+8*2*6=76
	 //Sending FlowSPI_Protocol     <STX>   [MsgID][PumpID][Volume1][Amount1][Volume2][Amount2][Volume3][Amount3][Volume4][Amount4][Volume5][Amount5][Volume6][Amount6]<ETX>
	 if (xPumpID>=16)xPump=16;
    11ee:	80 31       	cpi	r24, 0x10	; 16
    11f0:	10 f4       	brcc	.+4      	; 0x11f6 <SendTotalizerFlow+0x38>
    11f2:	f8 2e       	mov	r15, r24
    11f4:	02 c0       	rjmp	.+4      	; 0x11fa <SendTotalizerFlow+0x3c>
    11f6:	70 e1       	ldi	r23, 0x10	; 16
    11f8:	f7 2e       	mov	r15, r23
	 else xPump=xPumpID;
                                                
	 systemMaster();
    11fa:	0e 94 bb 06 	call	0xd76	; 0xd76 <systemMaster>
	sbi(DDRD,2);sbi(PORTD,2);//128-SS HIGH
	//_delay_ms(10);
}

void SendSPI(char xSPI){
     _spi(xSPI);
    11fe:	85 e0       	ldi	r24, 0x05	; 5
    1200:	0e 94 b5 13 	call	0x276a	; 0x276a <_spi>
void uartGilbarco(){
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    1204:	80 e5       	ldi	r24, 0x50	; 80
    1206:	0e 94 b5 13 	call	0x276a	; 0x276a <_spi>
    120a:	2e 01       	movw	r4, r28
    120c:	08 94       	sec
    120e:	41 1c       	adc	r4, r1
    1210:	51 1c       	adc	r5, r1
    1212:	52 01       	movw	r10, r4
    1214:	ce 01       	movw	r24, r28
    1216:	89 96       	adiw	r24, 0x29	; 41
	     strMemory[i]=data;
    1218:	d5 01       	movw	r26, r10
    121a:	1d 92       	st	X+, r1
    121c:	5d 01       	movw	r10, r26
void uartGilbarco(){
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    121e:	a8 17       	cp	r26, r24
    1220:	b9 07       	cpc	r27, r25
    1222:	d1 f7       	brne	.-12     	; 0x1218 <SendTotalizerFlow+0x5a>
	 systemMaster();
	 SendSPI(0x05);//STX
	 SendSPI(0x50);//STX
	 FillChar(strSend,sizeof(strSend),0);
	
	 sprintf_P(strSend,PSTR("02%.2d"),xPump);
    1224:	00 d0       	rcall	.+0      	; 0x1226 <SendTotalizerFlow+0x68>
    1226:	00 d0       	rcall	.+0      	; 0x1228 <SendTotalizerFlow+0x6a>
    1228:	00 d0       	rcall	.+0      	; 0x122a <SendTotalizerFlow+0x6c>
    122a:	ed b7       	in	r30, 0x3d	; 61
    122c:	fe b7       	in	r31, 0x3e	; 62
    122e:	31 96       	adiw	r30, 0x01	; 1
    1230:	8e 01       	movw	r16, r28
    1232:	0f 5f       	subi	r16, 0xFF	; 255
    1234:	1f 4f       	sbci	r17, 0xFF	; 255
    1236:	ad b7       	in	r26, 0x3d	; 61
    1238:	be b7       	in	r27, 0x3e	; 62
    123a:	12 96       	adiw	r26, 0x02	; 2
    123c:	1c 93       	st	X, r17
    123e:	0e 93       	st	-X, r16
    1240:	11 97       	sbiw	r26, 0x01	; 1
    1242:	80 e4       	ldi	r24, 0x40	; 64
    1244:	91 e0       	ldi	r25, 0x01	; 1
    1246:	93 83       	std	Z+3, r25	; 0x03
    1248:	82 83       	std	Z+2, r24	; 0x02
    124a:	f4 82       	std	Z+4, r15	; 0x04
    124c:	15 82       	std	Z+5, r1	; 0x05
    124e:	0e 94 29 15 	call	0x2a52	; 0x2a52 <sprintf_P>
     SendStrSPI(strSend);
    1252:	ed b7       	in	r30, 0x3d	; 61
    1254:	fe b7       	in	r31, 0x3e	; 62
    1256:	36 96       	adiw	r30, 0x06	; 6
    1258:	0f b6       	in	r0, 0x3f	; 63
    125a:	f8 94       	cli
    125c:	fe bf       	out	0x3e, r31	; 62
    125e:	0f be       	out	0x3f, r0	; 63
    1260:	ed bf       	out	0x3d, r30	; 61
    1262:	c8 01       	movw	r24, r16
    1264:	0e 94 8e 06 	call	0xd1c	; 0xd1c <SendStrSPI>
    1268:	ee 24       	eor	r14, r14
    126a:	ff 24       	eor	r15, r15
     for (i=0;i<6;i++){
	      //FixingData V:[00000000] M:[00000000]
		  AddZeroLead(PumpTotalizer.TotalGrade[i].strMoney,12);
		  AddZeroLead(PumpTotalizer.TotalGrade[i].strVolume,12);
		  FillChar(strSend,sizeof(strSend),0);
		  sprintf_P(strSend,PSTR("%s%s"),PumpTotalizer.TotalGrade[i].strVolume,PumpTotalizer.TotalGrade[i].strMoney);
    126c:	90 2e       	mov	r9, r16
    126e:	81 2e       	mov	r8, r17
    1270:	6b e3       	ldi	r22, 0x3B	; 59
    1272:	66 2e       	mov	r6, r22
    1274:	61 e0       	ldi	r22, 0x01	; 1
    1276:	76 2e       	mov	r7, r22
	 sprintf_P(strSend,PSTR("02%.2d"),xPump);
     SendStrSPI(strSend);

     for (i=0;i<6;i++){
	      //FixingData V:[00000000] M:[00000000]
		  AddZeroLead(PumpTotalizer.TotalGrade[i].strMoney,12);
    1278:	c7 01       	movw	r24, r14
    127a:	67 01       	movw	r12, r14
    127c:	55 e0       	ldi	r21, 0x05	; 5
    127e:	cc 0c       	add	r12, r12
    1280:	dd 1c       	adc	r13, r13
    1282:	5a 95       	dec	r21
    1284:	e1 f7       	brne	.-8      	; 0x127e <SendTotalizerFlow+0xc0>
    1286:	88 0f       	add	r24, r24
    1288:	99 1f       	adc	r25, r25
    128a:	c8 1a       	sub	r12, r24
    128c:	d9 0a       	sbc	r13, r25
    128e:	86 e0       	ldi	r24, 0x06	; 6
    1290:	93 e0       	ldi	r25, 0x03	; 3
    1292:	c8 0e       	add	r12, r24
    1294:	d9 1e       	adc	r13, r25
    1296:	c6 01       	movw	r24, r12
    1298:	6c e0       	ldi	r22, 0x0C	; 12
    129a:	0e 94 e7 03 	call	0x7ce	; 0x7ce <AddZeroLead>
		  AddZeroLead(PumpTotalizer.TotalGrade[i].strVolume,12);
    129e:	c7 01       	movw	r24, r14
    12a0:	87 01       	movw	r16, r14
    12a2:	35 e0       	ldi	r19, 0x05	; 5
    12a4:	00 0f       	add	r16, r16
    12a6:	11 1f       	adc	r17, r17
    12a8:	3a 95       	dec	r19
    12aa:	e1 f7       	brne	.-8      	; 0x12a4 <SendTotalizerFlow+0xe6>
    12ac:	88 0f       	add	r24, r24
    12ae:	99 1f       	adc	r25, r25
    12b0:	08 1b       	sub	r16, r24
    12b2:	19 0b       	sbc	r17, r25
    12b4:	09 50       	subi	r16, 0x09	; 9
    12b6:	1d 4f       	sbci	r17, 0xFD	; 253
    12b8:	c8 01       	movw	r24, r16
    12ba:	6c e0       	ldi	r22, 0x0C	; 12
    12bc:	0e 94 e7 03 	call	0x7ce	; 0x7ce <AddZeroLead>
    12c0:	f2 01       	movw	r30, r4
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    12c2:	11 92       	st	Z+, r1
void uartGilbarco(){
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    12c4:	ea 15       	cp	r30, r10
    12c6:	fb 05       	cpc	r31, r11
    12c8:	e1 f7       	brne	.-8      	; 0x12c2 <SendTotalizerFlow+0x104>
     for (i=0;i<6;i++){
	      //FixingData V:[00000000] M:[00000000]
		  AddZeroLead(PumpTotalizer.TotalGrade[i].strMoney,12);
		  AddZeroLead(PumpTotalizer.TotalGrade[i].strVolume,12);
		  FillChar(strSend,sizeof(strSend),0);
		  sprintf_P(strSend,PSTR("%s%s"),PumpTotalizer.TotalGrade[i].strVolume,PumpTotalizer.TotalGrade[i].strMoney);
    12ca:	ad b7       	in	r26, 0x3d	; 61
    12cc:	be b7       	in	r27, 0x3e	; 62
    12ce:	18 97       	sbiw	r26, 0x08	; 8
    12d0:	0f b6       	in	r0, 0x3f	; 63
    12d2:	f8 94       	cli
    12d4:	be bf       	out	0x3e, r27	; 62
    12d6:	0f be       	out	0x3f, r0	; 63
    12d8:	ad bf       	out	0x3d, r26	; 61
    12da:	ed b7       	in	r30, 0x3d	; 61
    12dc:	fe b7       	in	r31, 0x3e	; 62
    12de:	31 96       	adiw	r30, 0x01	; 1
    12e0:	11 96       	adiw	r26, 0x01	; 1
    12e2:	9c 92       	st	X, r9
    12e4:	11 97       	sbiw	r26, 0x01	; 1
    12e6:	12 96       	adiw	r26, 0x02	; 2
    12e8:	8c 92       	st	X, r8
    12ea:	73 82       	std	Z+3, r7	; 0x03
    12ec:	62 82       	std	Z+2, r6	; 0x02
    12ee:	15 83       	std	Z+5, r17	; 0x05
    12f0:	04 83       	std	Z+4, r16	; 0x04
    12f2:	d7 82       	std	Z+7, r13	; 0x07
    12f4:	c6 82       	std	Z+6, r12	; 0x06
    12f6:	0e 94 29 15 	call	0x2a52	; 0x2a52 <sprintf_P>
          SendStrSPI(strSend);
    12fa:	ed b7       	in	r30, 0x3d	; 61
    12fc:	fe b7       	in	r31, 0x3e	; 62
    12fe:	38 96       	adiw	r30, 0x08	; 8
    1300:	0f b6       	in	r0, 0x3f	; 63
    1302:	f8 94       	cli
    1304:	fe bf       	out	0x3e, r31	; 62
    1306:	0f be       	out	0x3f, r0	; 63
    1308:	ed bf       	out	0x3d, r30	; 61
    130a:	89 2d       	mov	r24, r9
    130c:	98 2d       	mov	r25, r8
    130e:	0e 94 8e 06 	call	0xd1c	; 0xd1c <SendStrSPI>
    1312:	08 94       	sec
    1314:	e1 1c       	adc	r14, r1
    1316:	f1 1c       	adc	r15, r1
	 FillChar(strSend,sizeof(strSend),0);
	
	 sprintf_P(strSend,PSTR("02%.2d"),xPump);
     SendStrSPI(strSend);

     for (i=0;i<6;i++){
    1318:	f6 e0       	ldi	r31, 0x06	; 6
    131a:	ef 16       	cp	r14, r31
    131c:	f1 04       	cpc	r15, r1
    131e:	09 f0       	breq	.+2      	; 0x1322 <SendTotalizerFlow+0x164>
    1320:	ab cf       	rjmp	.-170    	; 0x1278 <SendTotalizerFlow+0xba>
		  #ifdef DEBUG_TOTAL_FLOW 
		  _uart_print(1,1,strSend);
		  #endif
	 }
	 //TotalizerDigit
	 sprintf_P(strSend,PSTR("%d"),PumpTotalDigit);
    1322:	00 d0       	rcall	.+0      	; 0x1324 <SendTotalizerFlow+0x166>
    1324:	00 d0       	rcall	.+0      	; 0x1326 <SendTotalizerFlow+0x168>
    1326:	00 d0       	rcall	.+0      	; 0x1328 <SendTotalizerFlow+0x16a>
    1328:	ed b7       	in	r30, 0x3d	; 61
    132a:	fe b7       	in	r31, 0x3e	; 62
    132c:	31 96       	adiw	r30, 0x01	; 1
    132e:	ad b7       	in	r26, 0x3d	; 61
    1330:	be b7       	in	r27, 0x3e	; 62
    1332:	11 96       	adiw	r26, 0x01	; 1
    1334:	9c 92       	st	X, r9
    1336:	11 97       	sbiw	r26, 0x01	; 1
    1338:	12 96       	adiw	r26, 0x02	; 2
    133a:	8c 92       	st	X, r8
    133c:	88 e3       	ldi	r24, 0x38	; 56
    133e:	91 e0       	ldi	r25, 0x01	; 1
    1340:	93 83       	std	Z+3, r25	; 0x03
    1342:	82 83       	std	Z+2, r24	; 0x02
    1344:	80 91 0c 01 	lds	r24, 0x010C
    1348:	84 83       	std	Z+4, r24	; 0x04
    134a:	15 82       	std	Z+5, r1	; 0x05
    134c:	0e 94 29 15 	call	0x2a52	; 0x2a52 <sprintf_P>
     SendStrSPI(strSend);
    1350:	ed b7       	in	r30, 0x3d	; 61
    1352:	fe b7       	in	r31, 0x3e	; 62
    1354:	36 96       	adiw	r30, 0x06	; 6
    1356:	0f b6       	in	r0, 0x3f	; 63
    1358:	f8 94       	cli
    135a:	fe bf       	out	0x3e, r31	; 62
    135c:	0f be       	out	0x3f, r0	; 63
    135e:	ed bf       	out	0x3d, r30	; 61
    1360:	89 2d       	mov	r24, r9
    1362:	98 2d       	mov	r25, r8
    1364:	0e 94 8e 06 	call	0xd1c	; 0xd1c <SendStrSPI>
	sbi(DDRD,2);sbi(PORTD,2);//128-SS HIGH
	//_delay_ms(10);
}

void SendSPI(char xSPI){
     _spi(xSPI);
    1368:	86 e0       	ldi	r24, 0x06	; 6
    136a:	0e 94 b5 13 	call	0x276a	; 0x276a <_spi>
	 sprintf_P(strSend,PSTR("%d"),PumpTotalDigit);
     SendStrSPI(strSend);

	 SendSPI(0x06);//ETX
	 SendSPI(0x60);//ETX
	 systemSlave();
    136e:	80 e6       	ldi	r24, 0x60	; 96
    1370:	0e 94 b5 13 	call	0x276a	; 0x276a <_spi>
    1374:	0e 94 ae 06 	call	0xd5c	; 0xd5c <systemSlave>
    1378:	8a ef       	ldi	r24, 0xFA	; 250
    137a:	90 e0       	ldi	r25, 0x00	; 0
    137c:	01 97       	sbiw	r24, 0x01	; 1
    137e:	f1 f7       	brne	.-4      	; 0x137c <SendTotalizerFlow+0x1be>
	 _delay_ms(1);//DelayProses
}
    1380:	a8 96       	adiw	r28, 0x28	; 40
    1382:	0f b6       	in	r0, 0x3f	; 63
    1384:	f8 94       	cli
    1386:	de bf       	out	0x3e, r29	; 62
    1388:	0f be       	out	0x3f, r0	; 63
    138a:	cd bf       	out	0x3d, r28	; 61
    138c:	cf 91       	pop	r28
    138e:	df 91       	pop	r29
    1390:	1f 91       	pop	r17
    1392:	0f 91       	pop	r16
    1394:	ff 90       	pop	r15
    1396:	ef 90       	pop	r14
    1398:	df 90       	pop	r13
    139a:	cf 90       	pop	r12
    139c:	bf 90       	pop	r11
    139e:	af 90       	pop	r10
    13a0:	9f 90       	pop	r9
    13a2:	8f 90       	pop	r8
    13a4:	7f 90       	pop	r7
    13a6:	6f 90       	pop	r6
    13a8:	5f 90       	pop	r5
    13aa:	4f 90       	pop	r4
    13ac:	08 95       	ret

000013ae <SendTransFlow>:
	 SendSPI(0x08);//ETX

	 systemSlave();
}

void SendTransFlow(char xPumpID, char rxPumpId,char xNozzleID,char xProductID, char *sUnitPrice, char *sVolume,char * sAmount,char TransDigit){
    13ae:	6f 92       	push	r6
    13b0:	7f 92       	push	r7
    13b2:	8f 92       	push	r8
    13b4:	9f 92       	push	r9
    13b6:	af 92       	push	r10
    13b8:	bf 92       	push	r11
    13ba:	cf 92       	push	r12
    13bc:	df 92       	push	r13
    13be:	ef 92       	push	r14
    13c0:	ff 92       	push	r15
    13c2:	0f 93       	push	r16
    13c4:	1f 93       	push	r17
    13c6:	df 93       	push	r29
    13c8:	cf 93       	push	r28
    13ca:	cd b7       	in	r28, 0x3d	; 61
    13cc:	de b7       	in	r29, 0x3e	; 62
    13ce:	6e 97       	sbiw	r28, 0x1e	; 30
    13d0:	0f b6       	in	r0, 0x3f	; 63
    13d2:	f8 94       	cli
    13d4:	de bf       	out	0x3e, r29	; 62
    13d6:	0f be       	out	0x3f, r0	; 63
    13d8:	cd bf       	out	0x3d, r28	; 61
    13da:	68 2e       	mov	r6, r24
    13dc:	b4 2e       	mov	r11, r20
    13de:	72 2e       	mov	r7, r18
    13e0:	48 01       	movw	r8, r16
     char i,xNozzle,xPrd,xPump,strSend[30];

	                         //  [0x50,0x05]  01       01       1        3       004500   00000200  00000000 [0x06,0x60] = 24
	 //Sending FlowSPI_Protocol     <STX>   [MsgID][PumpID][Nozzle][ProductID][UnitPrice][Volume][Amount] <ETX>
	 AddZeroLead(sUnitPrice,6);//         Wyne    01 02 2 0 004600 00000254 00011684
    13e2:	c8 01       	movw	r24, r16
    13e4:	66 e0       	ldi	r22, 0x06	; 6
    13e6:	0e 94 e7 03 	call	0x7ce	; 0x7ce <AddZeroLead>
     AddZeroLead(sVolume,8);
    13ea:	c7 01       	movw	r24, r14
    13ec:	68 e0       	ldi	r22, 0x08	; 8
    13ee:	0e 94 e7 03 	call	0x7ce	; 0x7ce <AddZeroLead>
     AddZeroLead(sAmount,8);
    13f2:	c6 01       	movw	r24, r12
    13f4:	68 e0       	ldi	r22, 0x08	; 8
    13f6:	0e 94 e7 03 	call	0x7ce	; 0x7ce <AddZeroLead>
	 
	 if (xNozzleID>=4)xNozzle=4;
    13fa:	83 e0       	ldi	r24, 0x03	; 3
    13fc:	8b 15       	cp	r24, r11
    13fe:	10 f0       	brcs	.+4      	; 0x1404 <SendTransFlow+0x56>
    1400:	4b 2d       	mov	r20, r11
    1402:	01 c0       	rjmp	.+2      	; 0x1406 <SendTransFlow+0x58>
    1404:	44 e0       	ldi	r20, 0x04	; 4
	 else xNozzle=xNozzleID;
	 
	 if (xProductID>=4)xPrd=4;
    1406:	93 e0       	ldi	r25, 0x03	; 3
    1408:	97 15       	cp	r25, r7
    140a:	10 f0       	brcs	.+4      	; 0x1410 <SendTransFlow+0x62>
    140c:	27 2d       	mov	r18, r7
    140e:	01 c0       	rjmp	.+2      	; 0x1412 <SendTransFlow+0x64>
    1410:	24 e0       	ldi	r18, 0x04	; 4
	 else xPrd=xProductID;

	 if (xPumpID>=16)xPump=16;
    1412:	af e0       	ldi	r26, 0x0F	; 15
    1414:	a6 15       	cp	r26, r6
    1416:	10 f0       	brcs	.+4      	; 0x141c <SendTransFlow+0x6e>
    1418:	36 2d       	mov	r19, r6
    141a:	01 c0       	rjmp	.+2      	; 0x141e <SendTransFlow+0x70>
    141c:	30 e1       	ldi	r19, 0x10	; 16
	 else xPump=xPumpID;

	 sprintf_P(strSend,PSTR("01%.2d%.1d%.1d%s%s%s"),xPump,xNozzle,xPrd,sUnitPrice,sVolume,sAmount);
    141e:	8d b7       	in	r24, 0x3d	; 61
    1420:	9e b7       	in	r25, 0x3e	; 62
    1422:	40 97       	sbiw	r24, 0x10	; 16
    1424:	0f b6       	in	r0, 0x3f	; 63
    1426:	f8 94       	cli
    1428:	9e bf       	out	0x3e, r25	; 62
    142a:	0f be       	out	0x3f, r0	; 63
    142c:	8d bf       	out	0x3d, r24	; 61
    142e:	ed b7       	in	r30, 0x3d	; 61
    1430:	fe b7       	in	r31, 0x3e	; 62
    1432:	31 96       	adiw	r30, 0x01	; 1
    1434:	8e 01       	movw	r16, r28
    1436:	0f 5f       	subi	r16, 0xFF	; 255
    1438:	1f 4f       	sbci	r17, 0xFF	; 255
    143a:	ad b7       	in	r26, 0x3d	; 61
    143c:	be b7       	in	r27, 0x3e	; 62
    143e:	12 96       	adiw	r26, 0x02	; 2
    1440:	1c 93       	st	X, r17
    1442:	0e 93       	st	-X, r16
    1444:	11 97       	sbiw	r26, 0x01	; 1
    1446:	8a e4       	ldi	r24, 0x4A	; 74
    1448:	91 e0       	ldi	r25, 0x01	; 1
    144a:	93 83       	std	Z+3, r25	; 0x03
    144c:	82 83       	std	Z+2, r24	; 0x02
    144e:	34 83       	std	Z+4, r19	; 0x04
    1450:	15 82       	std	Z+5, r1	; 0x05
    1452:	46 83       	std	Z+6, r20	; 0x06
    1454:	17 82       	std	Z+7, r1	; 0x07
    1456:	20 87       	std	Z+8, r18	; 0x08
    1458:	11 86       	std	Z+9, r1	; 0x09
    145a:	93 86       	std	Z+11, r9	; 0x0b
    145c:	82 86       	std	Z+10, r8	; 0x0a
    145e:	f5 86       	std	Z+13, r15	; 0x0d
    1460:	e4 86       	std	Z+12, r14	; 0x0c
    1462:	d7 86       	std	Z+15, r13	; 0x0f
    1464:	c6 86       	std	Z+14, r12	; 0x0e
    1466:	0e 94 29 15 	call	0x2a52	; 0x2a52 <sprintf_P>
	 systemMaster();
    146a:	8d b7       	in	r24, 0x3d	; 61
    146c:	9e b7       	in	r25, 0x3e	; 62
    146e:	40 96       	adiw	r24, 0x10	; 16
    1470:	0f b6       	in	r0, 0x3f	; 63
    1472:	f8 94       	cli
    1474:	9e bf       	out	0x3e, r25	; 62
    1476:	0f be       	out	0x3f, r0	; 63
    1478:	8d bf       	out	0x3d, r24	; 61
    147a:	0e 94 bb 06 	call	0xd76	; 0xd76 <systemMaster>
	sbi(DDRD,2);sbi(PORTD,2);//128-SS HIGH
	//_delay_ms(10);
}

void SendSPI(char xSPI){
     _spi(xSPI);
    147e:	85 e0       	ldi	r24, 0x05	; 5
    1480:	0e 94 b5 13 	call	0x276a	; 0x276a <_spi>

	 sprintf_P(strSend,PSTR("01%.2d%.1d%.1d%s%s%s"),xPump,xNozzle,xPrd,sUnitPrice,sVolume,sAmount);
	 systemMaster();
	 SendSPI(0x05);//STX
	 SendSPI(0x50);//STX
	 for(i=0;i<strlen(strSend);i++){
    1484:	80 e5       	ldi	r24, 0x50	; 80
    1486:	0e 94 b5 13 	call	0x276a	; 0x276a <_spi>
    148a:	ff 24       	eor	r15, r15
    148c:	06 c0       	rjmp	.+12     	; 0x149a <SendTransFlow+0xec>
    148e:	a0 0f       	add	r26, r16
    1490:	b1 1f       	adc	r27, r17
    1492:	8c 91       	ld	r24, X
    1494:	0e 94 b5 13 	call	0x276a	; 0x276a <_spi>
    1498:	f3 94       	inc	r15
    149a:	f8 01       	movw	r30, r16
    149c:	01 90       	ld	r0, Z+
    149e:	00 20       	and	r0, r0
    14a0:	e9 f7       	brne	.-6      	; 0x149c <SendTransFlow+0xee>
    14a2:	31 97       	sbiw	r30, 0x01	; 1
    14a4:	e0 1b       	sub	r30, r16
    14a6:	f1 0b       	sbc	r31, r17
    14a8:	af 2d       	mov	r26, r15
    14aa:	b0 e0       	ldi	r27, 0x00	; 0
    14ac:	ae 17       	cp	r26, r30
    14ae:	bf 07       	cpc	r27, r31
    14b0:	70 f3       	brcs	.-36     	; 0x148e <SendTransFlow+0xe0>
		 #ifdef DEBUG_TRANS_FLOW 
		 _uart(1,1,strSend[i]);
		 #endif
	 }
	 //TransDigit
	 sprintf_P(strSend,PSTR("%d"),TransDigit);
    14b2:	00 d0       	rcall	.+0      	; 0x14b4 <SendTransFlow+0x106>
    14b4:	00 d0       	rcall	.+0      	; 0x14b6 <SendTransFlow+0x108>
    14b6:	00 d0       	rcall	.+0      	; 0x14b8 <SendTransFlow+0x10a>
    14b8:	ed b7       	in	r30, 0x3d	; 61
    14ba:	fe b7       	in	r31, 0x3e	; 62
    14bc:	31 96       	adiw	r30, 0x01	; 1
    14be:	ad b7       	in	r26, 0x3d	; 61
    14c0:	be b7       	in	r27, 0x3e	; 62
    14c2:	12 96       	adiw	r26, 0x02	; 2
    14c4:	1c 93       	st	X, r17
    14c6:	0e 93       	st	-X, r16
    14c8:	11 97       	sbiw	r26, 0x01	; 1
    14ca:	87 e4       	ldi	r24, 0x47	; 71
    14cc:	91 e0       	ldi	r25, 0x01	; 1
    14ce:	93 83       	std	Z+3, r25	; 0x03
    14d0:	82 83       	std	Z+2, r24	; 0x02
    14d2:	a4 82       	std	Z+4, r10	; 0x04
    14d4:	15 82       	std	Z+5, r1	; 0x05
    14d6:	0e 94 29 15 	call	0x2a52	; 0x2a52 <sprintf_P>
     SendStrSPI(strSend);
    14da:	8d b7       	in	r24, 0x3d	; 61
    14dc:	9e b7       	in	r25, 0x3e	; 62
    14de:	06 96       	adiw	r24, 0x06	; 6
    14e0:	0f b6       	in	r0, 0x3f	; 63
    14e2:	f8 94       	cli
    14e4:	9e bf       	out	0x3e, r25	; 62
    14e6:	0f be       	out	0x3f, r0	; 63
    14e8:	8d bf       	out	0x3d, r24	; 61
    14ea:	c8 01       	movw	r24, r16
    14ec:	0e 94 8e 06 	call	0xd1c	; 0xd1c <SendStrSPI>
	sbi(DDRD,2);sbi(PORTD,2);//128-SS HIGH
	//_delay_ms(10);
}

void SendSPI(char xSPI){
     _spi(xSPI);
    14f0:	86 e0       	ldi	r24, 0x06	; 6
    14f2:	0e 94 b5 13 	call	0x276a	; 0x276a <_spi>
	 sprintf_P(strSend,PSTR("%d"),TransDigit);
     SendStrSPI(strSend);

	 SendSPI(0x06);//ETX
	 SendSPI(0x60);//ETX
	 systemSlave();
    14f6:	80 e6       	ldi	r24, 0x60	; 96
    14f8:	0e 94 b5 13 	call	0x276a	; 0x276a <_spi>
    14fc:	0e 94 ae 06 	call	0xd5c	; 0xd5c <systemSlave>
}
    1500:	6e 96       	adiw	r28, 0x1e	; 30
    1502:	0f b6       	in	r0, 0x3f	; 63
    1504:	f8 94       	cli
    1506:	de bf       	out	0x3e, r29	; 62
    1508:	0f be       	out	0x3f, r0	; 63
    150a:	cd bf       	out	0x3d, r28	; 61
    150c:	cf 91       	pop	r28
    150e:	df 91       	pop	r29
    1510:	1f 91       	pop	r17
    1512:	0f 91       	pop	r16
    1514:	ff 90       	pop	r15
    1516:	ef 90       	pop	r14
    1518:	df 90       	pop	r13
    151a:	cf 90       	pop	r12
    151c:	bf 90       	pop	r11
    151e:	af 90       	pop	r10
    1520:	9f 90       	pop	r9
    1522:	8f 90       	pop	r8
    1524:	7f 90       	pop	r7
    1526:	6f 90       	pop	r6
    1528:	08 95       	ret

0000152a <FPoolingPump>:
	 }
}

//#define DEBUG_GILBARCO_POOLING 

void FPoolingPump(){//DefPoolTimeout,DefDelayNextPump
    152a:	af 92       	push	r10
    152c:	cf 92       	push	r12
    152e:	df 92       	push	r13
    1530:	ef 92       	push	r14
    1532:	ff 92       	push	r15
    1534:	0f 93       	push	r16
    1536:	1f 93       	push	r17
//static char txPumpID=0,StatusPump,iSend,nSend,PumpAddr=1,nNoPump,ScanPumpMax,IsNoPump=True,TPoolTimeout,TDelayNextPump;
       char CurrentAmount[15];
	   char strSend[20];

     //Monitoring
	 if (zPooling!=stPoolingPump){
    1538:	60 91 2c 01 	lds	r22, 0x012C
    153c:	80 91 2d 01 	lds	r24, 0x012D
    1540:	86 17       	cp	r24, r22
    1542:	11 f0       	breq	.+4      	; 0x1548 <FPoolingPump+0x1e>
	     zPooling=stPoolingPump;
    1544:	60 93 2d 01 	sts	0x012D, r22
         sprintf_P(strSend,PSTR("<pl:%.2d>"),stPoolingPump);
	 	 _uart_print(1,1,strSend);
		 #endif
	 }
     
	 if (IsRestartPooling==True){
    1548:	80 91 03 01 	lds	r24, 0x0103
    154c:	81 30       	cpi	r24, 0x01	; 1
    154e:	69 f4       	brne	.+26     	; 0x156a <FPoolingPump+0x40>
	     IsRestartPooling=False;
    1550:	10 92 03 01 	sts	0x0103, r1
		 SendCommandAcknoledge(SC_POOL_RESTARTED,stPoolingPump);
    1554:	8a e1       	ldi	r24, 0x1A	; 26
    1556:	0e 94 e0 06 	call	0xdc0	; 0xdc0 <SendCommandAcknoledge>
		 _uart_printf(1,1,PSTR("PoolRestarted"));
    155a:	81 e0       	ldi	r24, 0x01	; 1
    155c:	61 e0       	ldi	r22, 0x01	; 1
    155e:	4a e6       	ldi	r20, 0x6A	; 106
    1560:	51 e0       	ldi	r21, 0x01	; 1
    1562:	0e 94 be 14 	call	0x297c	; 0x297c <_uart_printf>
	     stPoolingPump=ppInit;
    1566:	10 92 2c 01 	sts	0x012C, r1
	 }
	 switch(stPoolingPump){
    156a:	80 91 2c 01 	lds	r24, 0x012C
    156e:	e8 2f       	mov	r30, r24
    1570:	f0 e0       	ldi	r31, 0x00	; 0
    1572:	e1 32       	cpi	r30, 0x21	; 33
    1574:	f1 05       	cpc	r31, r1
    1576:	08 f0       	brcs	.+2      	; 0x157a <FPoolingPump+0x50>
    1578:	b8 c2       	rjmp	.+1392   	; 0x1aea <FPoolingPump+0x5c0>
    157a:	e8 5c       	subi	r30, 0xC8	; 200
    157c:	ff 4f       	sbci	r31, 0xFF	; 255
    157e:	ee 0f       	add	r30, r30
    1580:	ff 1f       	adc	r31, r31
    1582:	05 90       	lpm	r0, Z+
    1584:	f4 91       	lpm	r31, Z+
    1586:	e0 2d       	mov	r30, r0
    1588:	09 94       	ijmp
	 case ppInit:
	      //StatePrintf(PSTR("1"));
	      //txPumpID=1;
		  iPoolingID=0;
    158a:	10 92 16 01 	sts	0x0116, r1
		  txPumpID=eeprom_read_byte(&DefPumpID[iPoolingID]);
    158e:	8d e0       	ldi	r24, 0x0D	; 13
    1590:	90 e0       	ldi	r25, 0x00	; 0
    1592:	0e 94 2a 17 	call	0x2e54	; 0x2e54 <__eerd_byte_m162>
    1596:	80 93 17 01 	sts	0x0117, r24

		  iSend=0;
    159a:	10 92 f9 03 	sts	0x03F9, r1
		  TimSend=0;          
    159e:	10 92 24 04 	sts	0x0424, r1
    15a2:	10 92 23 04 	sts	0x0423, r1
		  nNoPump=eeprom_read_byte(&DefNoPumpCountMax);
    15a6:	88 e0       	ldi	r24, 0x08	; 8
    15a8:	90 e0       	ldi	r25, 0x00	; 0
    15aa:	0e 94 2a 17 	call	0x2e54	; 0x2e54 <__eerd_byte_m162>
    15ae:	80 93 35 04 	sts	0x0435, r24
		  ScanPumpMax=eeprom_read_byte(&DefMaxPumpPooling);
    15b2:	87 e0       	ldi	r24, 0x07	; 7
    15b4:	90 e0       	ldi	r25, 0x00	; 0
    15b6:	0e 94 2a 17 	call	0x2e54	; 0x2e54 <__eerd_byte_m162>
    15ba:	80 93 61 02 	sts	0x0261, r24
		  nSend=eeprom_read_byte(&DefSendCount);
    15be:	89 e0       	ldi	r24, 0x09	; 9
    15c0:	90 e0       	ldi	r25, 0x00	; 0
    15c2:	0e 94 2a 17 	call	0x2e54	; 0x2e54 <__eerd_byte_m162>
    15c6:	80 93 77 02 	sts	0x0277, r24
		  if (IsStopPoolSequence!=True)
    15ca:	80 91 13 01 	lds	r24, 0x0113
    15ce:	81 30       	cpi	r24, 0x01	; 1
    15d0:	29 f0       	breq	.+10     	; 0x15dc <FPoolingPump+0xb2>
              SendCommandAcknoledge(SC_LIVE_SEQUENCE,SequencePool);
    15d2:	89 e1       	ldi	r24, 0x19	; 25
    15d4:	60 91 26 01 	lds	r22, 0x0126
    15d8:	0e 94 e0 06 	call	0xdc0	; 0xdc0 <SendCommandAcknoledge>
          SequencePool++;
    15dc:	80 91 26 01 	lds	r24, 0x0126
    15e0:	8f 5f       	subi	r24, 0xFF	; 255
    15e2:	80 93 26 01 	sts	0x0126, r24
		  TPoolTimeout=eeprom_read_byte(&DefPoolTimeout);
    15e6:	8a e0       	ldi	r24, 0x0A	; 10
    15e8:	90 e0       	ldi	r25, 0x00	; 0
    15ea:	0e 94 2a 17 	call	0x2e54	; 0x2e54 <__eerd_byte_m162>
    15ee:	80 93 b6 02 	sts	0x02B6, r24
		  TDelayNextPump=eeprom_read_byte(&DefDelayNextPump);		  
    15f2:	8b e0       	ldi	r24, 0x0B	; 11
    15f4:	90 e0       	ldi	r25, 0x00	; 0
    15f6:	0e 94 2a 17 	call	0x2e54	; 0x2e54 <__eerd_byte_m162>
    15fa:	80 93 3c 01 	sts	0x013C, r24
    15fe:	1a c0       	rjmp	.+52     	; 0x1634 <FPoolingPump+0x10a>
		  stPoolingPump=ppGetStatus;
	      break;
     case ppNextPump:
          iPoolingID++;
    1600:	90 91 16 01 	lds	r25, 0x0116
    1604:	9f 5f       	subi	r25, 0xFF	; 255
    1606:	90 93 16 01 	sts	0x0116, r25
	      if (iPoolingID<ScanPumpMax){
    160a:	80 91 61 02 	lds	r24, 0x0261
    160e:	98 17       	cp	r25, r24
    1610:	98 f4       	brcc	.+38     	; 0x1638 <FPoolingPump+0x10e>
			  txPumpID=eeprom_read_byte(&DefPumpID[iPoolingID]);
    1612:	89 2f       	mov	r24, r25
    1614:	90 e0       	ldi	r25, 0x00	; 0
    1616:	83 5f       	subi	r24, 0xF3	; 243
    1618:	9f 4f       	sbci	r25, 0xFF	; 255
    161a:	0e 94 2a 17 	call	0x2e54	; 0x2e54 <__eerd_byte_m162>
    161e:	80 93 17 01 	sts	0x0117, r24
			  if (txPumpID>0){			      
    1622:	88 23       	and	r24, r24
    1624:	09 f4       	brne	.+2      	; 0x1628 <FPoolingPump+0xfe>
    1626:	09 c2       	rjmp	.+1042   	; 0x1a3a <FPoolingPump+0x510>
			      iSend=0;TimSend=0;
    1628:	10 92 f9 03 	sts	0x03F9, r1
    162c:	10 92 24 04 	sts	0x0424, r1
    1630:	10 92 23 04 	sts	0x0423, r1
			      stPoolingPump=ppGetStatus;
    1634:	82 e0       	ldi	r24, 0x02	; 2
    1636:	57 c2       	rjmp	.+1198   	; 0x1ae6 <FPoolingPump+0x5bc>
			   }else stPoolingPump=ppNextPump;
		  }else stPoolingPump=ppInit;
    1638:	10 92 2c 01 	sts	0x012C, r1
    163c:	56 c2       	rjmp	.+1196   	; 0x1aea <FPoolingPump+0x5c0>
           sprintf_P(strSend,PSTR("TxPumpID:%d"),txPumpID);
	 	   _uart_print(1,1,strSend);
		  #endif

          //StatePrintf(PSTR("3"));
	      IsStatusReceived=False;
    163e:	10 92 0f 01 	sts	0x010F, r1
		  IsNoPump=False;
    1642:	10 92 06 01 	sts	0x0106, r1
	 }
	 zDataBuffer[0]=data;
}

void SetReceiveLine(char RecLine){
     stReceiveCom0=RecLine;
    1646:	81 e0       	ldi	r24, 0x01	; 1
    1648:	80 93 04 01 	sts	0x0104, r24
		  IsNoPump=False;
		  SetReceiveLine(rcIdle);
		  stPoolingPump=ppWaitIdle;
     case ppWaitIdle:
          //StatePrintf(PSTR("4"));
	      if (GetReceiveLine()==rcIdle)
    164c:	80 91 04 01 	lds	r24, 0x0104
    1650:	81 30       	cpi	r24, 0x01	; 1
    1652:	81 f7       	brne	.-32     	; 0x1634 <FPoolingPump+0x10a>
		      stPoolingPump=ppSendStatusRequest;
    1654:	84 e0       	ldi	r24, 0x04	; 4
    1656:	47 c2       	rjmp	.+1166   	; 0x1ae6 <FPoolingPump+0x5bc>
          else stPoolingPump=ppGetStatus;
	      break;
     case ppSendStatusRequest:
          //StatePrintf(PSTR("5"));
	      PumpCommand(txPumpID,CMD_STATUS);
    1658:	80 91 17 01 	lds	r24, 0x0117
    165c:	60 e0       	ldi	r22, 0x00	; 0
    165e:	0e 94 69 07 	call	0xed2	; 0xed2 <PumpCommand>
		  TimSend=0;
    1662:	10 92 24 04 	sts	0x0424, r1
    1666:	10 92 23 04 	sts	0x0423, r1
          stPoolingPump=ppWaitReplyStatus;
    166a:	86 e0       	ldi	r24, 0x06	; 6
    166c:	3c c2       	rjmp	.+1144   	; 0x1ae6 <FPoolingPump+0x5bc>
	      break;
     case ppNoPump:
          NoPumpCount[txPumpID&0x0F]++;
    166e:	80 91 17 01 	lds	r24, 0x0117
    1672:	e8 2f       	mov	r30, r24
    1674:	f0 e0       	ldi	r31, 0x00	; 0
    1676:	ef 70       	andi	r30, 0x0F	; 15
    1678:	f0 70       	andi	r31, 0x00	; 0
    167a:	eb 5d       	subi	r30, 0xDB	; 219
    167c:	fb 4f       	sbci	r31, 0xFB	; 251
    167e:	80 81       	ld	r24, Z
    1680:	8f 5f       	subi	r24, 0xFF	; 255
    1682:	80 83       	st	Z, r24
		  if (NoPumpCount[txPumpID&0x0F]>nNoPump){
    1684:	90 91 35 04 	lds	r25, 0x0435
    1688:	98 17       	cp	r25, r24
    168a:	08 f0       	brcs	.+2      	; 0x168e <FPoolingPump+0x164>
    168c:	c5 c0       	rjmp	.+394    	; 0x1818 <FPoolingPump+0x2ee>
		      NoPumpCount[txPumpID&0x0F]=0;
    168e:	10 82       	st	Z, r1
	          IsNoPump=True;
    1690:	81 e0       	ldi	r24, 0x01	; 1
    1692:	80 93 06 01 	sts	0x0106, r24
    1696:	07 c1       	rjmp	.+526    	; 0x18a6 <FPoolingPump+0x37c>
			  }
          else stPoolingPump=ppInitDelayNextPump;
	      break;
     case ppWaitReplyStatus:	      
          //StatePrintf(PSTR("7"));
          if (TimSend>TPoolTimeout){//TPoolTimeout
    1698:	80 91 b6 02 	lds	r24, 0x02B6
    169c:	90 e0       	ldi	r25, 0x00	; 0
    169e:	20 91 23 04 	lds	r18, 0x0423
    16a2:	30 91 24 04 	lds	r19, 0x0424
    16a6:	82 17       	cp	r24, r18
    16a8:	93 07       	cpc	r25, r19
    16aa:	80 f4       	brcc	.+32     	; 0x16cc <FPoolingPump+0x1a2>
		      iSend++;
    16ac:	80 91 f9 03 	lds	r24, 0x03F9
    16b0:	8f 5f       	subi	r24, 0xFF	; 255
    16b2:	80 93 f9 03 	sts	0x03F9, r24
		      if (iSend<nSend)stPoolingPump=ppGetStatus;
    16b6:	90 91 77 02 	lds	r25, 0x0277
    16ba:	89 17       	cp	r24, r25
    16bc:	10 f4       	brcc	.+4      	; 0x16c2 <FPoolingPump+0x198>
    16be:	82 e0       	ldi	r24, 0x02	; 2
    16c0:	03 c0       	rjmp	.+6      	; 0x16c8 <FPoolingPump+0x19e>
			  else
		      if (iSend>nSend)stPoolingPump=ppNoPump;//Pump Not Available
    16c2:	98 17       	cp	r25, r24
    16c4:	18 f4       	brcc	.+6      	; 0x16cc <FPoolingPump+0x1a2>
    16c6:	85 e0       	ldi	r24, 0x05	; 5
    16c8:	80 93 2c 01 	sts	0x012C, r24
		  }
          if (IsStatusReceived==True){
    16cc:	80 91 0f 01 	lds	r24, 0x010F
    16d0:	81 30       	cpi	r24, 0x01	; 1
    16d2:	09 f0       	breq	.+2      	; 0x16d6 <FPoolingPump+0x1ac>
    16d4:	0a c2       	rjmp	.+1044   	; 0x1aea <FPoolingPump+0x5c0>
		      if ((txPumpID&0x0F)==PumpID){
    16d6:	40 91 0e 01 	lds	r20, 0x010E
    16da:	80 91 17 01 	lds	r24, 0x0117
    16de:	90 e0       	ldi	r25, 0x00	; 0
    16e0:	8f 70       	andi	r24, 0x0F	; 15
    16e2:	90 70       	andi	r25, 0x00	; 0
    16e4:	24 2f       	mov	r18, r20
    16e6:	30 e0       	ldi	r19, 0x00	; 0
    16e8:	82 17       	cp	r24, r18
    16ea:	93 07       	cpc	r25, r19
    16ec:	11 f4       	brne	.+4      	; 0x16f2 <FPoolingPump+0x1c8>
			      stPoolingPump=ppUpdatePumpStatus;
    16ee:	87 e0       	ldi	r24, 0x07	; 7
    16f0:	01 c0       	rjmp	.+2      	; 0x16f4 <FPoolingPump+0x1ca>
			  }else stPoolingPump=ppDifferentPumpID;
    16f2:	89 e0       	ldi	r24, 0x09	; 9
    16f4:	80 93 2c 01 	sts	0x012C, r24

			  if ((CMDResponse==0x0F)&&(PumpID==0x0F)&&(iSend<nSend)){
    16f8:	80 91 8d 01 	lds	r24, 0x018D
    16fc:	8f 30       	cpi	r24, 0x0F	; 15
    16fe:	09 f0       	breq	.+2      	; 0x1702 <FPoolingPump+0x1d8>
    1700:	f4 c1       	rjmp	.+1000   	; 0x1aea <FPoolingPump+0x5c0>
    1702:	4f 30       	cpi	r20, 0x0F	; 15
    1704:	09 f0       	breq	.+2      	; 0x1708 <FPoolingPump+0x1de>
    1706:	f1 c1       	rjmp	.+994    	; 0x1aea <FPoolingPump+0x5c0>
    1708:	90 91 f9 03 	lds	r25, 0x03F9
    170c:	80 91 77 02 	lds	r24, 0x0277
    1710:	98 17       	cp	r25, r24
    1712:	08 f0       	brcs	.+2      	; 0x1716 <FPoolingPump+0x1ec>
    1714:	ea c1       	rjmp	.+980    	; 0x1aea <FPoolingPump+0x5c0>
    1716:	8e cf       	rjmp	.-228    	; 0x1634 <FPoolingPump+0x10a>
          stPoolingPump=ppNoPump;
	      break;
		                     //PumpStatus[1..0]= FEDCBA98 76543210
     case ppUpdatePumpStatus://                = 
          //StatePrintf(PSTR("9"));
	      PumpAddr=(txPumpID&0x0F);
    1718:	90 91 17 01 	lds	r25, 0x0117
    171c:	9f 70       	andi	r25, 0x0F	; 15
    171e:	90 93 05 01 	sts	0x0105, r25
		  if (IsNoPump==False)PumpStatus[PumpAddr]=CMDResponse;
    1722:	80 91 06 01 	lds	r24, 0x0106
    1726:	88 23       	and	r24, r24
    1728:	39 f4       	brne	.+14     	; 0x1738 <FPoolingPump+0x20e>
    172a:	e9 2f       	mov	r30, r25
    172c:	f0 e0       	ldi	r31, 0x00	; 0
    172e:	eb 54       	subi	r30, 0x4B	; 75
    1730:	fc 4f       	sbci	r31, 0xFC	; 252
    1732:	80 91 8d 01 	lds	r24, 0x018D
    1736:	07 c0       	rjmp	.+14     	; 0x1746 <FPoolingPump+0x21c>
		  else 
		  if (IsNoPump==True)PumpStatus[PumpAddr]=PUMP_NONE;
    1738:	81 30       	cpi	r24, 0x01	; 1
    173a:	31 f4       	brne	.+12     	; 0x1748 <FPoolingPump+0x21e>
    173c:	e9 2f       	mov	r30, r25
    173e:	f0 e0       	ldi	r31, 0x00	; 0
    1740:	eb 54       	subi	r30, 0x4B	; 75
    1742:	fc 4f       	sbci	r31, 0xFC	; 252
    1744:	8e e0       	ldi	r24, 0x0E	; 14
    1746:	80 83       	st	Z, r24
          
		  //SendIfUpdated
		  if (PumpStatus[PumpAddr]!=zPumpStatus[PumpAddr]){
    1748:	89 2f       	mov	r24, r25
    174a:	90 e0       	ldi	r25, 0x00	; 0
    174c:	fc 01       	movw	r30, r24
    174e:	eb 54       	subi	r30, 0x4B	; 75
    1750:	fc 4f       	sbci	r31, 0xFC	; 252
    1752:	20 81       	ld	r18, Z
    1754:	fc 01       	movw	r30, r24
    1756:	e5 56       	subi	r30, 0x65	; 101
    1758:	fd 4f       	sbci	r31, 0xFD	; 253
    175a:	80 81       	ld	r24, Z
    175c:	28 17       	cp	r18, r24
    175e:	79 f0       	breq	.+30     	; 0x177e <FPoolingPump+0x254>
		      zPumpStatus[PumpAddr]=PumpStatus[PumpAddr];
    1760:	20 83       	st	Z, r18
		      stPoolingPump=ppSendPumpStatus;
    1762:	87 e1       	ldi	r24, 0x17	; 23
    1764:	c0 c1       	rjmp	.+896    	; 0x1ae6 <FPoolingPump+0x5bc>
		  }else stPoolingPump=ppScanResponse;
          break;
     case ppSendPumpStatus://UpdatePumpStatusToMaster;
          //StatePrintf(PSTR("10"));
	      PumpAddr=(txPumpID&0x0F);
    1766:	80 91 17 01 	lds	r24, 0x0117
    176a:	e8 2f       	mov	r30, r24
    176c:	ef 70       	andi	r30, 0x0F	; 15
    176e:	e0 93 05 01 	sts	0x0105, r30
	      SendPumpStatusFlow(txPumpID,PumpStatus[PumpAddr]);
    1772:	f0 e0       	ldi	r31, 0x00	; 0
    1774:	eb 54       	subi	r30, 0x4B	; 75
    1776:	fc 4f       	sbci	r31, 0xFC	; 252
    1778:	60 81       	ld	r22, Z
    177a:	0e 94 c8 06 	call	0xd90	; 0xd90 <SendPumpStatusFlow>
	      stPoolingPump=ppScanResponse;
    177e:	88 e1       	ldi	r24, 0x18	; 24
    1780:	b2 c1       	rjmp	.+868    	; 0x1ae6 <FPoolingPump+0x5bc>
	      break;
     case ppScanResponse:
          //StatePrintf(PSTR("11"));
		  PumpAddr=(txPumpID&0x0F);
    1782:	80 91 17 01 	lds	r24, 0x0117
    1786:	8f 70       	andi	r24, 0x0F	; 15
    1788:	80 93 05 01 	sts	0x0105, r24
		  switch(CMDResponse){
    178c:	90 91 8d 01 	lds	r25, 0x018D
    1790:	98 30       	cpi	r25, 0x08	; 8
    1792:	c1 f1       	breq	.+112    	; 0x1804 <FPoolingPump+0x2da>
    1794:	99 30       	cpi	r25, 0x09	; 9
    1796:	28 f4       	brcc	.+10     	; 0x17a2 <FPoolingPump+0x278>
    1798:	96 30       	cpi	r25, 0x06	; 6
    179a:	41 f0       	breq	.+16     	; 0x17ac <FPoolingPump+0x282>
    179c:	97 30       	cpi	r25, 0x07	; 7
    179e:	91 f5       	brne	.+100    	; 0x1804 <FPoolingPump+0x2da>
    17a0:	16 c0       	rjmp	.+44     	; 0x17ce <FPoolingPump+0x2a4>
    17a2:	99 30       	cpi	r25, 0x09	; 9
    17a4:	31 f1       	breq	.+76     	; 0x17f2 <FPoolingPump+0x2c8>
    17a6:	9c 30       	cpi	r25, 0x0C	; 12
    17a8:	68 f5       	brcc	.+90     	; 0x1804 <FPoolingPump+0x2da>
    17aa:	1a c0       	rjmp	.+52     	; 0x17e0 <FPoolingPump+0x2b6>
		  case PUMP_OFF:               
		       if (IsRequestTransInfo[PumpAddr]==True)
    17ac:	a8 2f       	mov	r26, r24
    17ae:	b0 e0       	ldi	r27, 0x00	; 0
    17b0:	fd 01       	movw	r30, r26
    17b2:	e6 57       	subi	r30, 0x76	; 118
    17b4:	fd 4f       	sbci	r31, 0xFD	; 253
    17b6:	80 81       	ld	r24, Z
    17b8:	81 30       	cpi	r24, 0x01	; 1
    17ba:	c9 f0       	breq	.+50     	; 0x17ee <FPoolingPump+0x2c4>
			       stPoolingPump=ppRequestTransData;
               else 
		       if (IsRequestTotalizerInfo[PumpAddr]==True){
    17bc:	ad 5e       	subi	r26, 0xED	; 237
    17be:	bb 4f       	sbci	r27, 0xFB	; 251
    17c0:	8c 91       	ld	r24, X
    17c2:	81 30       	cpi	r24, 0x01	; 1
    17c4:	11 f4       	brne	.+4      	; 0x17ca <FPoolingPump+0x2a0>
			        stPoolingPump=ppRequestTotalizerData;
    17c6:	8b e1       	ldi	r24, 0x1B	; 27
    17c8:	1e c0       	rjmp	.+60     	; 0x1806 <FPoolingPump+0x2dc>
				}	
               else stPoolingPump=ppNextPump;
    17ca:	81 e0       	ldi	r24, 0x01	; 1
    17cc:	1c c0       	rjmp	.+56     	; 0x1806 <FPoolingPump+0x2dc>
		       break;
          case PUMP_CALL:
 			   if (PumpLock[PumpAddr]==False){
    17ce:	e8 2f       	mov	r30, r24
    17d0:	f0 e0       	ldi	r31, 0x00	; 0
    17d2:	e4 53       	subi	r30, 0x34	; 52
    17d4:	fd 4f       	sbci	r31, 0xFD	; 253
    17d6:	80 81       	ld	r24, Z
    17d8:	88 23       	and	r24, r24
    17da:	b9 f4       	brne	.+46     	; 0x180a <FPoolingPump+0x2e0>
			   	 //  if (IsRequestTransInfo[PumpAddr]==False) 
				 //      IsRequestTransInfo[PumpAddr]=True;
			       stPoolingPump=ppReplyAuth;               
    17dc:	88 e0       	ldi	r24, 0x08	; 8
    17de:	13 c0       	rjmp	.+38     	; 0x1806 <FPoolingPump+0x2dc>
			   } 
		       break;

          case PUMP_PEOT://Endeavor 776 terbaru
		  case PUMP_FEOT:
		       if (IsRequestTransInfo[PumpAddr]==True)
    17e0:	e8 2f       	mov	r30, r24
    17e2:	f0 e0       	ldi	r31, 0x00	; 0
    17e4:	e6 57       	subi	r30, 0x76	; 118
    17e6:	fd 4f       	sbci	r31, 0xFD	; 253
    17e8:	80 81       	ld	r24, Z
    17ea:	81 30       	cpi	r24, 0x01	; 1
    17ec:	59 f4       	brne	.+22     	; 0x1804 <FPoolingPump+0x2da>
			       stPoolingPump=ppRequestTransData;
    17ee:	8a e0       	ldi	r24, 0x0A	; 10
    17f0:	0a c0       	rjmp	.+20     	; 0x1806 <FPoolingPump+0x2dc>
               else stPoolingPump=ppInitDelayNextPump;
		       break;
		  case PUMP_BUSY:
               if (IsRequestTransInfo[PumpAddr]==False)
    17f2:	e8 2f       	mov	r30, r24
    17f4:	f0 e0       	ldi	r31, 0x00	; 0
    17f6:	e6 57       	subi	r30, 0x76	; 118
    17f8:	fd 4f       	sbci	r31, 0xFD	; 253
    17fa:	80 81       	ld	r24, Z
    17fc:	88 23       	and	r24, r24
    17fe:	11 f4       	brne	.+4      	; 0x1804 <FPoolingPump+0x2da>
			       IsRequestTransInfo[PumpAddr]=True;
    1800:	81 e0       	ldi	r24, 0x01	; 1
    1802:	80 83       	st	Z, r24
		       break;
		  case PUMP_AUTH:
               stPoolingPump=ppInitDelayNextPump;
		       break;		  
          default:
               stPoolingPump=ppInitDelayNextPump;
    1804:	84 e1       	ldi	r24, 0x14	; 20
    1806:	80 93 2c 01 	sts	0x012C, r24
		       break;
		  }
		  //Existing Pump
		  if (IsNoPump==True){
    180a:	80 91 06 01 	lds	r24, 0x0106
    180e:	81 30       	cpi	r24, 0x01	; 1
    1810:	09 f0       	breq	.+2      	; 0x1814 <FPoolingPump+0x2ea>
    1812:	6b c1       	rjmp	.+726    	; 0x1aea <FPoolingPump+0x5c0>
		      IsNoPump=False;
    1814:	10 92 06 01 	sts	0x0106, r1
			  stPoolingPump=ppInitDelayNextPump;
    1818:	84 e1       	ldi	r24, 0x14	; 20
    181a:	65 c1       	rjmp	.+714    	; 0x1ae6 <FPoolingPump+0x5bc>
	 }
	 zDataBuffer[0]=data;
}

void SetReceiveLine(char RecLine){
     stReceiveCom0=RecLine;
    181c:	81 e0       	ldi	r24, 0x01	; 1
    181e:	80 93 04 01 	sts	0x0104, r24
	      break;
     case ppReplyAuth:
          //StatePrintf(PSTR("11"));
	      SetReceiveLine(rcIdle);
	      if (GetReceiveLine()==rcIdle){
			  iSend=0;
    1822:	10 92 f9 03 	sts	0x03F9, r1
		      stPoolingPump=ppSendAuthorize;
    1826:	8c e0       	ldi	r24, 0x0C	; 12
    1828:	5e c1       	rjmp	.+700    	; 0x1ae6 <FPoolingPump+0x5bc>
			  }
		  else stPoolingPump=ppReplyAuth;
	      break;
     case ppSendAuthorize:
          //StatePrintf(PSTR("12"));
	      TimSend=0;
    182a:	10 92 24 04 	sts	0x0424, r1
    182e:	10 92 23 04 	sts	0x0423, r1
		  IsStatusReceived=False;
    1832:	10 92 0f 01 	sts	0x010F, r1
	      PumpCommand(txPumpID,CMD_AUTHORIZE);
    1836:	80 91 17 01 	lds	r24, 0x0117
    183a:	61 e0       	ldi	r22, 0x01	; 1
    183c:	0e 94 69 07 	call	0xed2	; 0xed2 <PumpCommand>
		  stPoolingPump=ppWaitAuthorized;
    1840:	8d e0       	ldi	r24, 0x0D	; 13
    1842:	51 c1       	rjmp	.+674    	; 0x1ae6 <FPoolingPump+0x5bc>
	      break;
     case ppWaitAuthorized:
          //StatePrintf(PSTR("13"));
	      if (TimSend>TPoolTimeout){
    1844:	80 91 b6 02 	lds	r24, 0x02B6
    1848:	90 e0       	ldi	r25, 0x00	; 0
    184a:	20 91 23 04 	lds	r18, 0x0423
    184e:	30 91 24 04 	lds	r19, 0x0424
    1852:	82 17       	cp	r24, r18
    1854:	93 07       	cpc	r25, r19
    1856:	80 f4       	brcc	.+32     	; 0x1878 <FPoolingPump+0x34e>
		  	  iSend++;
    1858:	80 91 f9 03 	lds	r24, 0x03F9
    185c:	8f 5f       	subi	r24, 0xFF	; 255
    185e:	80 93 f9 03 	sts	0x03F9, r24
		      if (iSend<nSend)stPoolingPump=ppSendAuthorize;
    1862:	90 91 77 02 	lds	r25, 0x0277
    1866:	89 17       	cp	r24, r25
    1868:	10 f4       	brcc	.+4      	; 0x186e <FPoolingPump+0x344>
    186a:	8c e0       	ldi	r24, 0x0C	; 12
    186c:	03 c0       	rjmp	.+6      	; 0x1874 <FPoolingPump+0x34a>
			  else
		      if (iSend>nSend)stPoolingPump=ppNoPump;//Pump Not Available
    186e:	98 17       	cp	r25, r24
    1870:	18 f4       	brcc	.+6      	; 0x1878 <FPoolingPump+0x34e>
    1872:	85 e0       	ldi	r24, 0x05	; 5
    1874:	80 93 2c 01 	sts	0x012C, r24
		  }
	      if (IsStatusReceived==True){
    1878:	80 91 0f 01 	lds	r24, 0x010F
    187c:	81 30       	cpi	r24, 0x01	; 1
    187e:	09 f0       	breq	.+2      	; 0x1882 <FPoolingPump+0x358>
    1880:	34 c1       	rjmp	.+616    	; 0x1aea <FPoolingPump+0x5c0>
		      IsStatusReceived=False;
    1882:	10 92 0f 01 	sts	0x010F, r1
			  //Authorized
			  _uart_printf(1,1,PSTR("Authorized"));
    1886:	61 e0       	ldi	r22, 0x01	; 1
    1888:	4f e5       	ldi	r20, 0x5F	; 95
    188a:	51 e0       	ldi	r21, 0x01	; 1
    188c:	0e 94 be 14 	call	0x297c	; 0x297c <_uart_printf>

		      if ((txPumpID&0x0F)==PumpID)stPoolingPump=ppUpdatePumpStatus;
    1890:	20 91 17 01 	lds	r18, 0x0117
    1894:	30 e0       	ldi	r19, 0x00	; 0
    1896:	2f 70       	andi	r18, 0x0F	; 15
    1898:	30 70       	andi	r19, 0x00	; 0
    189a:	80 91 0e 01 	lds	r24, 0x010E
    189e:	90 e0       	ldi	r25, 0x00	; 0
    18a0:	28 17       	cp	r18, r24
    18a2:	39 07       	cpc	r19, r25
    18a4:	11 f4       	brne	.+4      	; 0x18aa <FPoolingPump+0x380>
    18a6:	87 e0       	ldi	r24, 0x07	; 7
    18a8:	1e c1       	rjmp	.+572    	; 0x1ae6 <FPoolingPump+0x5bc>
			  else stPoolingPump=ppDifferentPumpID;
    18aa:	89 e0       	ldi	r24, 0x09	; 9
    18ac:	1c c1       	rjmp	.+568    	; 0x1ae6 <FPoolingPump+0x5bc>
		  }
	      break;
     case ppRequestRealTimeMoney:
          //StatePrintf(PSTR("14"));
		  Com0ReceiveCount=0;
    18ae:	10 92 23 01 	sts	0x0123, r1
	 }
	 zDataBuffer[0]=data;
}

void SetReceiveLine(char RecLine){
     stReceiveCom0=RecLine;
    18b2:	82 e0       	ldi	r24, 0x02	; 2
    18b4:	80 93 04 01 	sts	0x0104, r24
     case ppRequestRealTimeMoney:
          //StatePrintf(PSTR("14"));
		  Com0ReceiveCount=0;
	      SetReceiveLine(rcRealTimeMoney);
	      if (GetReceiveLine()==rcRealTimeMoney){
			  iSend=0;
    18b8:	10 92 f9 03 	sts	0x03F9, r1
    18bc:	25 c0       	rjmp	.+74     	; 0x1908 <FPoolingPump+0x3de>
			  }
		  else stPoolingPump=ppRequestRealTimeMoney;
	      break;
     case ppSendMoneyReq:
          //StatePrintf(PSTR("15"));
	 	  TimSend=0;
    18be:	10 92 24 04 	sts	0x0424, r1
    18c2:	10 92 23 04 	sts	0x0423, r1
	      IsMoneyReceived=False;
    18c6:	10 92 10 01 	sts	0x0110, r1
	      PumpCommand(txPumpID,CMD_REALTIME_MONEY);
    18ca:	80 91 17 01 	lds	r24, 0x0117
    18ce:	66 e0       	ldi	r22, 0x06	; 6
    18d0:	0e 94 69 07 	call	0xed2	; 0xed2 <PumpCommand>
		  stPoolingPump=ppWaitMoneyReq;
    18d4:	8f e0       	ldi	r24, 0x0F	; 15
    18d6:	07 c1       	rjmp	.+526    	; 0x1ae6 <FPoolingPump+0x5bc>
	      break;
     case ppWaitMoneyReq:
          //StatePrintf(PSTR("16"));
	      if (IsMoneyReceived==False){
    18d8:	80 91 10 01 	lds	r24, 0x0110
    18dc:	88 23       	and	r24, r24
    18de:	d9 f4       	brne	.+54     	; 0x1916 <FPoolingPump+0x3ec>
		  	  if (TimSend>TPoolTimeout){
    18e0:	80 91 b6 02 	lds	r24, 0x02B6
    18e4:	90 e0       	ldi	r25, 0x00	; 0
    18e6:	20 91 23 04 	lds	r18, 0x0423
    18ea:	30 91 24 04 	lds	r19, 0x0424
    18ee:	82 17       	cp	r24, r18
    18f0:	93 07       	cpc	r25, r19
    18f2:	08 f0       	brcs	.+2      	; 0x18f6 <FPoolingPump+0x3cc>
    18f4:	fa c0       	rjmp	.+500    	; 0x1aea <FPoolingPump+0x5c0>
			      iSend++;
    18f6:	80 91 f9 03 	lds	r24, 0x03F9
    18fa:	8f 5f       	subi	r24, 0xFF	; 255
    18fc:	80 93 f9 03 	sts	0x03F9, r24
		          if (iSend<nSend)stPoolingPump=ppSendMoneyReq;
    1900:	90 91 77 02 	lds	r25, 0x0277
    1904:	89 17       	cp	r24, r25
    1906:	10 f4       	brcc	.+4      	; 0x190c <FPoolingPump+0x3e2>
    1908:	8e e0       	ldi	r24, 0x0E	; 14
    190a:	ed c0       	rjmp	.+474    	; 0x1ae6 <FPoolingPump+0x5bc>
			      else
		          if (iSend>nSend)stPoolingPump=ppNoPump;//Pump Not Available
    190c:	98 17       	cp	r25, r24
    190e:	08 f0       	brcs	.+2      	; 0x1912 <FPoolingPump+0x3e8>
    1910:	ec c0       	rjmp	.+472    	; 0x1aea <FPoolingPump+0x5c0>
    1912:	85 e0       	ldi	r24, 0x05	; 5
    1914:	e8 c0       	rjmp	.+464    	; 0x1ae6 <FPoolingPump+0x5bc>
			  }
		  }else
	      if (IsMoneyReceived==True){
    1916:	81 30       	cpi	r24, 0x01	; 1
    1918:	09 f0       	breq	.+2      	; 0x191c <FPoolingPump+0x3f2>
    191a:	e7 c0       	rjmp	.+462    	; 0x1aea <FPoolingPump+0x5c0>
		      IsMoneyReceived=False;
    191c:	10 92 10 01 	sts	0x0110, r1
			  PumpAddr=(txPumpID&0x0F);
    1920:	80 91 17 01 	lds	r24, 0x0117
    1924:	8f 70       	andi	r24, 0x0F	; 15
    1926:	80 93 05 01 	sts	0x0105, r24
			  //SendCurrentMoney(txPumpID,strCurrentMoney);
			  stPoolingPump=ppMoneyRequestCompleted;
    192a:	80 e1       	ldi	r24, 0x10	; 16
    192c:	dc c0       	rjmp	.+440    	; 0x1ae6 <FPoolingPump+0x5bc>
	      TimDelayNextPump=0;
		  stPoolingPump=ppDelayNextPump;
	      break;
     case ppDelayNextPump:
          //StatePrintf(PSTR("18"));
	      if (TimDelayNextPump>=TDelayNextPump)
    192e:	80 91 3c 01 	lds	r24, 0x013C
    1932:	90 e0       	ldi	r25, 0x00	; 0
    1934:	20 91 21 01 	lds	r18, 0x0121
    1938:	30 91 22 01 	lds	r19, 0x0122
    193c:	28 17       	cp	r18, r24
    193e:	39 07       	cpc	r19, r25
    1940:	08 f4       	brcc	.+2      	; 0x1944 <FPoolingPump+0x41a>
    1942:	d3 c0       	rjmp	.+422    	; 0x1aea <FPoolingPump+0x5c0>
    1944:	7a c0       	rjmp	.+244    	; 0x1a3a <FPoolingPump+0x510>
		      stPoolingPump=ppNextPump;	      
	      break;
     case ppIsRequestTransInfo:
          PumpAddr=(txPumpID&0x0F);
    1946:	e0 91 17 01 	lds	r30, 0x0117
    194a:	ef 70       	andi	r30, 0x0F	; 15
    194c:	e0 93 05 01 	sts	0x0105, r30
	      if (IsRequestTransInfo[PumpAddr]!=False){
    1950:	f0 e0       	ldi	r31, 0x00	; 0
    1952:	e6 57       	subi	r30, 0x76	; 118
    1954:	fd 4f       	sbci	r31, 0xFD	; 253
    1956:	80 81       	ld	r24, Z
    1958:	88 23       	and	r24, r24
    195a:	11 f0       	breq	.+4      	; 0x1960 <FPoolingPump+0x436>
		      stPoolingPump=ppRequestTransData;		  
    195c:	8a e0       	ldi	r24, 0x0A	; 10
    195e:	c3 c0       	rjmp	.+390    	; 0x1ae6 <FPoolingPump+0x5bc>
		  }else{
		  stPoolingPump=ppIsRequestTotalizerInfo;
    1960:	8a e1       	ldi	r24, 0x1A	; 26
    1962:	c1 c0       	rjmp	.+386    	; 0x1ae6 <FPoolingPump+0x5bc>
	 }
	 zDataBuffer[0]=data;
}

void SetReceiveLine(char RecLine){
     stReceiveCom0=RecLine;
    1964:	83 e0       	ldi	r24, 0x03	; 3
    1966:	80 93 04 01 	sts	0x0104, r24
	      break;
     case ppRequestTransData:
          //StatePrintf(PSTR("19"));
	      SetReceiveLine(rcInitTransaction);
	      if (GetReceiveLine()==rcInitTransaction){
			  iSend=0;
    196a:	10 92 f9 03 	sts	0x03F9, r1
    196e:	30 c0       	rjmp	.+96     	; 0x19d0 <FPoolingPump+0x4a6>
			  }
		  else stPoolingPump=ppRequestTransData;
	      break;
     case ppSendTransReq:
          //StatePrintf(PSTR("20"));
	 	  TimSend=0;
    1970:	10 92 24 04 	sts	0x0424, r1
    1974:	10 92 23 04 	sts	0x0423, r1
	      IsTransaction=False;
    1978:	10 92 11 01 	sts	0x0111, r1
	      PumpCommand(txPumpID,CMD_TRANSACTION_DATA);		  
    197c:	80 91 17 01 	lds	r24, 0x0117
    1980:	64 e0       	ldi	r22, 0x04	; 4
    1982:	0e 94 69 07 	call	0xed2	; 0xed2 <PumpCommand>
		  stPoolingPump=ppWaitTransReq;
    1986:	82 e1       	ldi	r24, 0x12	; 18
    1988:	ae c0       	rjmp	.+348    	; 0x1ae6 <FPoolingPump+0x5bc>
	      break;
	 case ppWaitTransReq:
          //StatePrintf(PSTR("21"));
		  if (IsTransaction==True){
    198a:	80 91 11 01 	lds	r24, 0x0111
    198e:	81 30       	cpi	r24, 0x01	; 1
    1990:	41 f4       	brne	.+16     	; 0x19a2 <FPoolingPump+0x478>
		      PumpAddr=(txPumpID&0x0F);
    1992:	80 91 17 01 	lds	r24, 0x0117
    1996:	8f 70       	andi	r24, 0x0F	; 15
    1998:	80 93 05 01 	sts	0x0105, r24
		      stPoolingPump=ppTransRequestCompleted;
    199c:	83 e1       	ldi	r24, 0x13	; 19
    199e:	80 93 2c 01 	sts	0x012C, r24
			  }
		  if (TimSend>(TPoolTimeout*2)){
    19a2:	80 91 b6 02 	lds	r24, 0x02B6
    19a6:	90 e0       	ldi	r25, 0x00	; 0
    19a8:	88 0f       	add	r24, r24
    19aa:	99 1f       	adc	r25, r25
    19ac:	20 91 23 04 	lds	r18, 0x0423
    19b0:	30 91 24 04 	lds	r19, 0x0424
    19b4:	82 17       	cp	r24, r18
    19b6:	93 07       	cpc	r25, r19
    19b8:	08 f0       	brcs	.+2      	; 0x19bc <FPoolingPump+0x492>
    19ba:	97 c0       	rjmp	.+302    	; 0x1aea <FPoolingPump+0x5c0>
		  	  iSend++;
    19bc:	80 91 f9 03 	lds	r24, 0x03F9
    19c0:	8f 5f       	subi	r24, 0xFF	; 255
    19c2:	80 93 f9 03 	sts	0x03F9, r24
		      if (iSend<nSend)stPoolingPump=ppSendTransReq;
    19c6:	90 91 77 02 	lds	r25, 0x0277
    19ca:	89 17       	cp	r24, r25
    19cc:	08 f0       	brcs	.+2      	; 0x19d0 <FPoolingPump+0x4a6>
    19ce:	6b c0       	rjmp	.+214    	; 0x1aa6 <FPoolingPump+0x57c>
    19d0:	81 e1       	ldi	r24, 0x11	; 17
    19d2:	89 c0       	rjmp	.+274    	; 0x1ae6 <FPoolingPump+0x5bc>
		      if (iSend>nSend)stPoolingPump=ppDelayNextPump;	      
		  }
	      break;
	 case ppTransRequestCompleted:
          //StatePrintf(PSTR("21"));
		  stPoolingPump=ppSendTransInfo;
    19d4:	86 e1       	ldi	r24, 0x16	; 22
    19d6:	87 c0       	rjmp	.+270    	; 0x1ae6 <FPoolingPump+0x5bc>
	      break;
     case ppSendTransInfo:
	      PumpAddr=(txPumpID&0x0F);	      
    19d8:	80 91 17 01 	lds	r24, 0x0117
    19dc:	98 2f       	mov	r25, r24
    19de:	9f 70       	andi	r25, 0x0F	; 15
    19e0:	90 93 05 01 	sts	0x0105, r25
		  SendTransFlow(txPumpID,rxPumpId,NozzleId,GradeId,strUnitPrice,strVolume,strAmount,PumpTransDigit);
    19e4:	60 91 3b 01 	lds	r22, 0x013B
    19e8:	40 91 e0 02 	lds	r20, 0x02E0
    19ec:	20 91 f6 02 	lds	r18, 0x02F6
    19f0:	0c ea       	ldi	r16, 0xAC	; 172
    19f2:	12 e0       	ldi	r17, 0x02	; 2
    19f4:	f7 e5       	ldi	r31, 0x57	; 87
    19f6:	ef 2e       	mov	r14, r31
    19f8:	f2 e0       	ldi	r31, 0x02	; 2
    19fa:	ff 2e       	mov	r15, r31
    19fc:	eb ea       	ldi	r30, 0xAB	; 171
    19fe:	ce 2e       	mov	r12, r30
    1a00:	e3 e0       	ldi	r30, 0x03	; 3
    1a02:	de 2e       	mov	r13, r30
    1a04:	a0 90 0b 01 	lds	r10, 0x010B
    1a08:	0e 94 d7 09 	call	0x13ae	; 0x13ae <SendTransFlow>
		  IsRequestTransInfo[PumpAddr]=False;
    1a0c:	e0 91 05 01 	lds	r30, 0x0105
    1a10:	f0 e0       	ldi	r31, 0x00	; 0
    1a12:	e6 57       	subi	r30, 0x76	; 118
    1a14:	fd 4f       	sbci	r31, 0xFD	; 253
    1a16:	61 c0       	rjmp	.+194    	; 0x1ada <FPoolingPump+0x5b0>
	      TimDelayNextPump=0;		  
		  stPoolingPump=ppDelayNextPump;
	      break;     
     case ppIsRequestTotalizerInfo:
          //StatePrintf(PSTR("23"));
	      PumpAddr=(txPumpID&0x0F);
    1a18:	e0 91 17 01 	lds	r30, 0x0117
    1a1c:	ef 70       	andi	r30, 0x0F	; 15
    1a1e:	e0 93 05 01 	sts	0x0105, r30
	      if (IsRequestTotalizerInfo[PumpAddr]==True){
    1a22:	f0 e0       	ldi	r31, 0x00	; 0
    1a24:	ed 5e       	subi	r30, 0xED	; 237
    1a26:	fb 4f       	sbci	r31, 0xFB	; 251
    1a28:	80 81       	ld	r24, Z
    1a2a:	81 30       	cpi	r24, 0x01	; 1
    1a2c:	11 f4       	brne	.+4      	; 0x1a32 <FPoolingPump+0x508>
		      stPoolingPump=ppRequestTotalizerData;		  
    1a2e:	8b e1       	ldi	r24, 0x1B	; 27
    1a30:	5a c0       	rjmp	.+180    	; 0x1ae6 <FPoolingPump+0x5bc>
		  }else{
		  TimDelayNextPump=0; 
    1a32:	10 92 22 01 	sts	0x0122, r1
    1a36:	10 92 21 01 	sts	0x0121, r1
		  stPoolingPump=ppNextPump;
    1a3a:	81 e0       	ldi	r24, 0x01	; 1
    1a3c:	54 c0       	rjmp	.+168    	; 0x1ae6 <FPoolingPump+0x5bc>
	 }
	 zDataBuffer[0]=data;
}

void SetReceiveLine(char RecLine){
     stReceiveCom0=RecLine;
    1a3e:	84 e0       	ldi	r24, 0x04	; 4
    1a40:	80 93 04 01 	sts	0x0104, r24

     case ppRequestTotalizerData:
          //StatePrintf(PSTR("24"));
	      SetReceiveLine(rcInitTotalizer);
	      if (GetReceiveLine()==rcInitTotalizer){
			  iSend=0;
    1a44:	10 92 f9 03 	sts	0x03F9, r1
    1a48:	2c c0       	rjmp	.+88     	; 0x1aa2 <FPoolingPump+0x578>
			  }
		  else stPoolingPump=ppRequestTotalizerData;
	      break;
     case ppSendTotalizerReq:
          //StatePrintf(PSTR("25"));
	 	  TimSend=0;
    1a4a:	10 92 24 04 	sts	0x0424, r1
    1a4e:	10 92 23 04 	sts	0x0423, r1
	      IsTotalizer=False;
    1a52:	10 92 12 01 	sts	0x0112, r1
	      PumpCommand(txPumpID,CMD_TOTALIZER);
    1a56:	80 91 17 01 	lds	r24, 0x0117
    1a5a:	65 e0       	ldi	r22, 0x05	; 5
    1a5c:	0e 94 69 07 	call	0xed2	; 0xed2 <PumpCommand>
		  stPoolingPump=ppWaitTotalizerReq;
    1a60:	8d e1       	ldi	r24, 0x1D	; 29
    1a62:	41 c0       	rjmp	.+130    	; 0x1ae6 <FPoolingPump+0x5bc>
	      break;
	 case ppWaitTotalizerReq:
          //StatePrintf(PSTR("26"));
		  if (IsTotalizer==True){
    1a64:	80 91 12 01 	lds	r24, 0x0112
    1a68:	81 30       	cpi	r24, 0x01	; 1
    1a6a:	29 f4       	brne	.+10     	; 0x1a76 <FPoolingPump+0x54c>
		  	  IsTotalizer=False;
    1a6c:	10 92 12 01 	sts	0x0112, r1
			  stPoolingPump=ppTotalizerRequestCompleted;
    1a70:	8e e1       	ldi	r24, 0x1E	; 30
    1a72:	80 93 2c 01 	sts	0x012C, r24
		  }
          //if (TimSend>WAIT_TOTALIZER_TIMEOUT){
		  //    stPoolingPump=ppDelayNextPump;
		  //}
		  if (TimSend>(TPoolTimeout*5)){
    1a76:	80 91 b6 02 	lds	r24, 0x02B6
    1a7a:	25 e0       	ldi	r18, 0x05	; 5
    1a7c:	82 9f       	mul	r24, r18
    1a7e:	c0 01       	movw	r24, r0
    1a80:	11 24       	eor	r1, r1
    1a82:	20 91 23 04 	lds	r18, 0x0423
    1a86:	30 91 24 04 	lds	r19, 0x0424
    1a8a:	82 17       	cp	r24, r18
    1a8c:	93 07       	cpc	r25, r19
    1a8e:	68 f5       	brcc	.+90     	; 0x1aea <FPoolingPump+0x5c0>
		  	  iSend++;
    1a90:	80 91 f9 03 	lds	r24, 0x03F9
    1a94:	8f 5f       	subi	r24, 0xFF	; 255
    1a96:	80 93 f9 03 	sts	0x03F9, r24
		      if (iSend<nSend)stPoolingPump=ppSendTotalizerReq;
    1a9a:	90 91 77 02 	lds	r25, 0x0277
    1a9e:	89 17       	cp	r24, r25
    1aa0:	10 f4       	brcc	.+4      	; 0x1aa6 <FPoolingPump+0x57c>
    1aa2:	8c e1       	ldi	r24, 0x1C	; 28
    1aa4:	20 c0       	rjmp	.+64     	; 0x1ae6 <FPoolingPump+0x5bc>
			  else
		      if (iSend>nSend)stPoolingPump=ppDelayNextPump;	      
    1aa6:	98 17       	cp	r25, r24
    1aa8:	00 f5       	brcc	.+64     	; 0x1aea <FPoolingPump+0x5c0>
    1aaa:	1c c0       	rjmp	.+56     	; 0x1ae4 <FPoolingPump+0x5ba>
		  }
	      break;
	 case ppTotalizerRequestCompleted:
          //StatePrintf(PSTR("27"));																																																																																																																																		
		  stPoolingPump=ppSendTotalizerInfo;
    1aac:	8f e1       	ldi	r24, 0x1F	; 31
    1aae:	1b c0       	rjmp	.+54     	; 0x1ae6 <FPoolingPump+0x5bc>
	      break;
     case ppSendTotalizerInfo:
          //StatePrintf(PSTR("28"));
	      PumpAddr=(txPumpID&0x0F);
    1ab0:	80 91 17 01 	lds	r24, 0x0117
    1ab4:	98 2f       	mov	r25, r24
    1ab6:	9f 70       	andi	r25, 0x0F	; 15
    1ab8:	90 93 05 01 	sts	0x0105, r25
		  SendTotalizerFlow(txPumpID);
    1abc:	0e 94 df 08 	call	0x11be	; 0x11be <SendTotalizerFlow>
		  IsTotalizerACK=False;
    1ac0:	10 92 14 01 	sts	0x0114, r1
		  //IsRequestTotalizerInfo[PumpAddr]=False;
	      //TimDelayNextPump=0;
		  stPoolingPump=ppWaitTotalizerACK;
    1ac4:	80 e2       	ldi	r24, 0x20	; 32
    1ac6:	0f c0       	rjmp	.+30     	; 0x1ae6 <FPoolingPump+0x5bc>
	      break;
     case ppWaitTotalizerACK:
	      if (IsTotalizerACK==True){//SC_TOTALIZER_ACK
    1ac8:	80 91 14 01 	lds	r24, 0x0114
    1acc:	81 30       	cpi	r24, 0x01	; 1
    1ace:	69 f4       	brne	.+26     	; 0x1aea <FPoolingPump+0x5c0>
              IsRequestTotalizerInfo[PumpAddr]=False;
    1ad0:	e0 91 05 01 	lds	r30, 0x0105
    1ad4:	f0 e0       	ldi	r31, 0x00	; 0
    1ad6:	ed 5e       	subi	r30, 0xED	; 237
    1ad8:	fb 4f       	sbci	r31, 0xFB	; 251
    1ada:	10 82       	st	Z, r1
	          TimDelayNextPump=0;
    1adc:	10 92 22 01 	sts	0x0122, r1
    1ae0:	10 92 21 01 	sts	0x0121, r1
		      stPoolingPump=ppDelayNextPump;               
    1ae4:	85 e1       	ldi	r24, 0x15	; 21
    1ae6:	80 93 2c 01 	sts	0x012C, r24
		  }
	      break;
	 }
}
    1aea:	1f 91       	pop	r17
    1aec:	0f 91       	pop	r16
    1aee:	ff 90       	pop	r15
    1af0:	ef 90       	pop	r14
    1af2:	df 90       	pop	r13
    1af4:	cf 90       	pop	r12
    1af6:	af 90       	pop	r10
    1af8:	08 95       	ret

00001afa <TerminalSendf>:
	 SendSPI(AckData);
	 SendSPI(0x0A);
	 systemSlave();
}

void TerminalSendf(char Com,char *strSendf){
    1afa:	1f 93       	push	r17
    1afc:	cf 93       	push	r28
    1afe:	df 93       	push	r29
    1b00:	18 2f       	mov	r17, r24
    1b02:	eb 01       	movw	r28, r22
   if (eeprom_read_byte(&DefTerminalDebug)){
    1b04:	84 e0       	ldi	r24, 0x04	; 4
    1b06:	90 e0       	ldi	r25, 0x00	; 0
    1b08:	0e 94 2a 17 	call	0x2e54	; 0x2e54 <__eerd_byte_m162>
    1b0c:	88 23       	and	r24, r24
    1b0e:	41 f4       	brne	.+16     	; 0x1b20 <TerminalSendf+0x26>
    1b10:	0c c0       	rjmp	.+24     	; 0x1b2a <TerminalSendf+0x30>
       while(pgm_read_byte(&(*strSendf)))
	         _uart(Com, 1, pgm_read_byte(&(*strSendf++)));
    1b12:	21 96       	adiw	r28, 0x01	; 1
    1b14:	f9 01       	movw	r30, r18
    1b16:	44 91       	lpm	r20, Z+
    1b18:	81 2f       	mov	r24, r17
    1b1a:	61 e0       	ldi	r22, 0x01	; 1
    1b1c:	0e 94 7f 14 	call	0x28fe	; 0x28fe <_uart>
    1b20:	9e 01       	movw	r18, r28
	 systemSlave();
}

void TerminalSendf(char Com,char *strSendf){
   if (eeprom_read_byte(&DefTerminalDebug)){
       while(pgm_read_byte(&(*strSendf)))
    1b22:	fe 01       	movw	r30, r28
    1b24:	84 91       	lpm	r24, Z+
    1b26:	88 23       	and	r24, r24
    1b28:	a1 f7       	brne	.-24     	; 0x1b12 <TerminalSendf+0x18>
	         _uart(Com, 1, pgm_read_byte(&(*strSendf++)));
	}
}
    1b2a:	df 91       	pop	r29
    1b2c:	cf 91       	pop	r28
    1b2e:	1f 91       	pop	r17
    1b30:	08 95       	ret

00001b32 <FPoolingPump2>:
			 }
             rxBufferLength=0;
		}
}

void FPoolingPump2(){
    1b32:	af 92       	push	r10
    1b34:	cf 92       	push	r12
    1b36:	df 92       	push	r13
    1b38:	ef 92       	push	r14
    1b3a:	ff 92       	push	r15
    1b3c:	0f 93       	push	r16
    1b3e:	1f 93       	push	r17
    1b40:	df 93       	push	r29
    1b42:	cf 93       	push	r28
    1b44:	cd b7       	in	r28, 0x3d	; 61
    1b46:	de b7       	in	r29, 0x3e	; 62
    1b48:	6e 97       	sbiw	r28, 0x1e	; 30
    1b4a:	0f b6       	in	r0, 0x3f	; 63
    1b4c:	f8 94       	cli
    1b4e:	de bf       	out	0x3e, r29	; 62
    1b50:	0f be       	out	0x3f, r0	; 63
    1b52:	cd bf       	out	0x3d, r28	; 61
     static char zPooling,stPoolingPump=pwInit,nPoolTotalizer=0,IsTotalizerBusy=False,iAuthCmd=0;
	 char strSend[30];

	 //Monitoring
	 if (zPooling!=stPoolingPump){
    1b54:	20 91 31 01 	lds	r18, 0x0131
    1b58:	80 91 32 01 	lds	r24, 0x0132
    1b5c:	82 17       	cp	r24, r18
    1b5e:	31 f1       	breq	.+76     	; 0x1bac <FPoolingPump2+0x7a>
	     zPooling=stPoolingPump;
    1b60:	20 93 32 01 	sts	0x0132, r18
		 #ifdef DEBUG_WAYNE_POOLING
         sprintf_P(strSend,PSTR("WPool:%d"),stPoolingPump);
    1b64:	00 d0       	rcall	.+0      	; 0x1b66 <FPoolingPump2+0x34>
    1b66:	00 d0       	rcall	.+0      	; 0x1b68 <FPoolingPump2+0x36>
    1b68:	00 d0       	rcall	.+0      	; 0x1b6a <FPoolingPump2+0x38>
    1b6a:	ed b7       	in	r30, 0x3d	; 61
    1b6c:	fe b7       	in	r31, 0x3e	; 62
    1b6e:	31 96       	adiw	r30, 0x01	; 1
    1b70:	8e 01       	movw	r16, r28
    1b72:	0f 5f       	subi	r16, 0xFF	; 255
    1b74:	1f 4f       	sbci	r17, 0xFF	; 255
    1b76:	ad b7       	in	r26, 0x3d	; 61
    1b78:	be b7       	in	r27, 0x3e	; 62
    1b7a:	12 96       	adiw	r26, 0x02	; 2
    1b7c:	1c 93       	st	X, r17
    1b7e:	0e 93       	st	-X, r16
    1b80:	11 97       	sbiw	r26, 0x01	; 1
    1b82:	86 e8       	ldi	r24, 0x86	; 134
    1b84:	91 e0       	ldi	r25, 0x01	; 1
    1b86:	93 83       	std	Z+3, r25	; 0x03
    1b88:	82 83       	std	Z+2, r24	; 0x02
    1b8a:	24 83       	std	Z+4, r18	; 0x04
    1b8c:	15 82       	std	Z+5, r1	; 0x05
    1b8e:	0e 94 29 15 	call	0x2a52	; 0x2a52 <sprintf_P>
	 	 _uart_print(1,1,strSend);
    1b92:	8d b7       	in	r24, 0x3d	; 61
    1b94:	9e b7       	in	r25, 0x3e	; 62
    1b96:	06 96       	adiw	r24, 0x06	; 6
    1b98:	0f b6       	in	r0, 0x3f	; 63
    1b9a:	f8 94       	cli
    1b9c:	9e bf       	out	0x3e, r25	; 62
    1b9e:	0f be       	out	0x3f, r0	; 63
    1ba0:	8d bf       	out	0x3d, r24	; 61
    1ba2:	81 e0       	ldi	r24, 0x01	; 1
    1ba4:	61 e0       	ldi	r22, 0x01	; 1
    1ba6:	a8 01       	movw	r20, r16
    1ba8:	0e 94 96 14 	call	0x292c	; 0x292c <_uart_print>
		 #endif
	 }
     //Restarting
	 if (IsRestartPooling==True){
    1bac:	80 91 03 01 	lds	r24, 0x0103
    1bb0:	81 30       	cpi	r24, 0x01	; 1
    1bb2:	79 f4       	brne	.+30     	; 0x1bd2 <FPoolingPump2+0xa0>
	     IsRestartPooling=False;
    1bb4:	10 92 03 01 	sts	0x0103, r1
		 SendCommandAcknoledge(SC_POOL_RESTARTED,stPoolingPump);
    1bb8:	8a e1       	ldi	r24, 0x1A	; 26
    1bba:	60 91 31 01 	lds	r22, 0x0131
    1bbe:	0e 94 e0 06 	call	0xdc0	; 0xdc0 <SendCommandAcknoledge>
		 _uart_printf(1,1,PSTR("PoolRestarted"));
    1bc2:	81 e0       	ldi	r24, 0x01	; 1
    1bc4:	61 e0       	ldi	r22, 0x01	; 1
    1bc6:	48 e7       	ldi	r20, 0x78	; 120
    1bc8:	51 e0       	ldi	r21, 0x01	; 1
    1bca:	0e 94 be 14 	call	0x297c	; 0x297c <_uart_printf>
	     stPoolingPump=pwInit;
    1bce:	10 92 31 01 	sts	0x0131, r1
	 }
	 switch(stPoolingPump){
    1bd2:	80 91 31 01 	lds	r24, 0x0131
    1bd6:	e8 2f       	mov	r30, r24
    1bd8:	f0 e0       	ldi	r31, 0x00	; 0
    1bda:	ec 31       	cpi	r30, 0x1C	; 28
    1bdc:	f1 05       	cpc	r31, r1
    1bde:	08 f0       	brcs	.+2      	; 0x1be2 <FPoolingPump2+0xb0>
    1be0:	da c2       	rjmp	.+1460   	; 0x2196 <FPoolingPump2+0x664>
    1be2:	e7 5a       	subi	r30, 0xA7	; 167
    1be4:	ff 4f       	sbci	r31, 0xFF	; 255
    1be6:	ee 0f       	add	r30, r30
    1be8:	ff 1f       	adc	r31, r31
    1bea:	05 90       	lpm	r0, Z+
    1bec:	f4 91       	lpm	r31, Z+
    1bee:	e0 2d       	mov	r30, r0
    1bf0:	09 94       	ijmp
	 case pwInit:
		  nNoPump=eeprom_read_byte(&DefNoPumpCountMax);
    1bf2:	88 e0       	ldi	r24, 0x08	; 8
    1bf4:	90 e0       	ldi	r25, 0x00	; 0
    1bf6:	0e 94 2a 17 	call	0x2e54	; 0x2e54 <__eerd_byte_m162>
    1bfa:	80 93 35 04 	sts	0x0435, r24
		  ScanPumpMax=eeprom_read_byte(&DefMaxPumpPooling);
    1bfe:	87 e0       	ldi	r24, 0x07	; 7
    1c00:	90 e0       	ldi	r25, 0x00	; 0
    1c02:	0e 94 2a 17 	call	0x2e54	; 0x2e54 <__eerd_byte_m162>
    1c06:	80 93 61 02 	sts	0x0261, r24
		  nSend=eeprom_read_byte(&DefSendCount);
    1c0a:	89 e0       	ldi	r24, 0x09	; 9
    1c0c:	90 e0       	ldi	r25, 0x00	; 0
    1c0e:	0e 94 2a 17 	call	0x2e54	; 0x2e54 <__eerd_byte_m162>
    1c12:	80 93 77 02 	sts	0x0277, r24
		  nPoolTotalizer=eeprom_read_byte(&DefNozzleCount);
    1c16:	8d e1       	ldi	r24, 0x1D	; 29
    1c18:	90 e0       	ldi	r25, 0x00	; 0
    1c1a:	0e 94 2a 17 	call	0x2e54	; 0x2e54 <__eerd_byte_m162>
    1c1e:	80 93 30 01 	sts	0x0130, r24
		  TPoolTimeout=eeprom_read_byte(&DefPoolTimeout);
    1c22:	8a e0       	ldi	r24, 0x0A	; 10
    1c24:	90 e0       	ldi	r25, 0x00	; 0
    1c26:	0e 94 2a 17 	call	0x2e54	; 0x2e54 <__eerd_byte_m162>
    1c2a:	80 93 b6 02 	sts	0x02B6, r24
		  TDelayNextPump=eeprom_read_byte(&DefDelayNextPump);
    1c2e:	8b e0       	ldi	r24, 0x0B	; 11
    1c30:	90 e0       	ldi	r25, 0x00	; 0
    1c32:	0e 94 2a 17 	call	0x2e54	; 0x2e54 <__eerd_byte_m162>
    1c36:	80 93 3c 01 	sts	0x013C, r24
		  
		  if (IsStopPoolSequence!=True)
    1c3a:	80 91 13 01 	lds	r24, 0x0113
    1c3e:	81 30       	cpi	r24, 0x01	; 1
    1c40:	29 f0       	breq	.+10     	; 0x1c4c <FPoolingPump2+0x11a>
		      SendCommandAcknoledge(SC_LIVE_SEQUENCE,SequencePool);
    1c42:	89 e1       	ldi	r24, 0x19	; 25
    1c44:	60 91 26 01 	lds	r22, 0x0126
    1c48:	0e 94 e0 06 	call	0xdc0	; 0xdc0 <SendCommandAcknoledge>
		  SequencePool++;
    1c4c:	80 91 26 01 	lds	r24, 0x0126
    1c50:	8f 5f       	subi	r24, 0xFF	; 255
    1c52:	80 93 26 01 	sts	0x0126, r24
		  iPoolingID=0;		  
    1c56:	10 92 16 01 	sts	0x0116, r1
		  IsTotalizerBusy=False;
    1c5a:	10 92 2f 01 	sts	0x012F, r1
		  stPoolingPump=pwInitPumpAddr;
    1c5e:	81 e0       	ldi	r24, 0x01	; 1
    1c60:	95 c2       	rjmp	.+1322   	; 0x218c <FPoolingPump2+0x65a>
		  break;
     case pwInitPumpAddr:
		  txPumpID=eeprom_read_byte(&DefPumpID[iPoolingID]);
    1c62:	80 91 16 01 	lds	r24, 0x0116
    1c66:	90 e0       	ldi	r25, 0x00	; 0
    1c68:	83 5f       	subi	r24, 0xF3	; 243
    1c6a:	9f 4f       	sbci	r25, 0xFF	; 255
    1c6c:	0e 94 2a 17 	call	0x2e54	; 0x2e54 <__eerd_byte_m162>
          txPumpID=txPumpID-1; 
    1c70:	81 50       	subi	r24, 0x01	; 1
    1c72:	80 93 17 01 	sts	0x0117, r24
		   _uart_print(1,1,strSend);
		  #endif

		  //txPumpID=2-1; 
		  //SendCommandAcknoledge(SC_LIVE_SEQUENCE,SequencePool);
		  SequencePool++;
    1c76:	80 91 26 01 	lds	r24, 0x0126
    1c7a:	8f 5f       	subi	r24, 0xFF	; 255
    1c7c:	80 93 26 01 	sts	0x0126, r24
          iSend=0;		  
    1c80:	10 92 f9 03 	sts	0x03F9, r1
    1c84:	80 c2       	rjmp	.+1280   	; 0x2186 <FPoolingPump2+0x654>
	      stPoolingPump=pwScanStatus;
          break;	 
     case pwScanStatus:
	      WayneReply=WR_NONE;
    1c86:	10 92 1a 01 	sts	0x011A, r1
	      FWayneSendCommand(CMD_STATUS,0,txPumpID,0);
    1c8a:	80 e0       	ldi	r24, 0x00	; 0
    1c8c:	60 e0       	ldi	r22, 0x00	; 0
    1c8e:	40 91 17 01 	lds	r20, 0x0117
    1c92:	20 e0       	ldi	r18, 0x00	; 0
    1c94:	0e 94 95 07 	call	0xf2a	; 0xf2a <FWayneSendCommand>
		  TimSend=0;
    1c98:	10 92 24 04 	sts	0x0424, r1
    1c9c:	10 92 23 04 	sts	0x0423, r1
		  stPoolingPump=pwWaitScanReply;
    1ca0:	83 e0       	ldi	r24, 0x03	; 3
    1ca2:	74 c2       	rjmp	.+1256   	; 0x218c <FPoolingPump2+0x65a>
	      break;
     case pwWaitScanReply:
	      //Timeout->NoPump		  
          if (TimSend>TPoolTimeout){
    1ca4:	80 91 b6 02 	lds	r24, 0x02B6
    1ca8:	90 e0       	ldi	r25, 0x00	; 0
    1caa:	20 91 23 04 	lds	r18, 0x0423
    1cae:	30 91 24 04 	lds	r19, 0x0424
    1cb2:	82 17       	cp	r24, r18
    1cb4:	93 07       	cpc	r25, r19
    1cb6:	70 f4       	brcc	.+28     	; 0x1cd4 <FPoolingPump2+0x1a2>
		      iSend++;
    1cb8:	80 91 f9 03 	lds	r24, 0x03F9
    1cbc:	8f 5f       	subi	r24, 0xFF	; 255
    1cbe:	80 93 f9 03 	sts	0x03F9, r24
			  if (iSend<nSend)stPoolingPump=pwScanStatus;//Retry
    1cc2:	90 91 77 02 	lds	r25, 0x0277
    1cc6:	89 17       	cp	r24, r25
    1cc8:	10 f4       	brcc	.+4      	; 0x1cce <FPoolingPump2+0x19c>
    1cca:	82 e0       	ldi	r24, 0x02	; 2
    1ccc:	01 c0       	rjmp	.+2      	; 0x1cd0 <FPoolingPump2+0x19e>
			  else
			  if (iSend>=nSend)stPoolingPump=pwNoPump;//Pump Not Available
    1cce:	84 e0       	ldi	r24, 0x04	; 4
    1cd0:	80 93 31 01 	sts	0x0131, r24
		  }		  
	      
		  switch(WayneReply){
    1cd4:	80 91 1a 01 	lds	r24, 0x011A
    1cd8:	81 30       	cpi	r24, 0x01	; 1
    1cda:	21 f0       	breq	.+8      	; 0x1ce4 <FPoolingPump2+0x1b2>
    1cdc:	84 30       	cpi	r24, 0x04	; 4
    1cde:	09 f0       	breq	.+2      	; 0x1ce2 <FPoolingPump2+0x1b0>
    1ce0:	5a c2       	rjmp	.+1204   	; 0x2196 <FPoolingPump2+0x664>
    1ce2:	15 c0       	rjmp	.+42     	; 0x1d0e <FPoolingPump2+0x1dc>
		  case WR_READY:
			   if ((PumpStatus[txPumpID]==PW_NONE)||(PumpStatus[txPumpID]==PW_DISCONNECT)){
    1ce4:	80 91 17 01 	lds	r24, 0x0117
    1ce8:	a8 2f       	mov	r26, r24
    1cea:	b0 e0       	ldi	r27, 0x00	; 0
    1cec:	fd 01       	movw	r30, r26
    1cee:	eb 54       	subi	r30, 0x4B	; 75
    1cf0:	fc 4f       	sbci	r31, 0xFC	; 252
    1cf2:	e0 81       	ld	r30, Z
    1cf4:	ee 23       	and	r30, r30
    1cf6:	19 f0       	breq	.+6      	; 0x1cfe <FPoolingPump2+0x1cc>
    1cf8:	ee 30       	cpi	r30, 0x0E	; 14
    1cfa:	09 f0       	breq	.+2      	; 0x1cfe <FPoolingPump2+0x1cc>
    1cfc:	15 c2       	rjmp	.+1066   	; 0x2128 <FPoolingPump2+0x5f6>
			        IsRequestTransInfo[txPumpID]=False;
    1cfe:	fd 01       	movw	r30, r26
    1d00:	e6 57       	subi	r30, 0x76	; 118
    1d02:	fd 4f       	sbci	r31, 0xFD	; 253
    1d04:	10 82       	st	Z, r1
			        PumpStatus[txPumpID]=PW_ONLINE;
    1d06:	ab 54       	subi	r26, 0x4B	; 75
    1d08:	bc 4f       	sbci	r27, 0xFC	; 252
    1d0a:	86 e0       	ldi	r24, 0x06	; 6
    1d0c:	17 c0       	rjmp	.+46     	; 0x1d3c <FPoolingPump2+0x20a>
				  }
               //_uart_printf(1,1,PSTR("WR_READY"));
               stPoolingPump=pwUpdatePumpStatus;
		       break;
          case WR_MESSAGE:
		       stPoolingPump=pwReplyACK;
    1d0e:	87 e1       	ldi	r24, 0x17	; 23
    1d10:	3d c2       	rjmp	.+1146   	; 0x218c <FPoolingPump2+0x65a>
		       break;
		  }
	      break;
	 case pwNoPump:
	      NoPumpCount[txPumpID&0x0F]++;
    1d12:	80 91 17 01 	lds	r24, 0x0117
    1d16:	a8 2f       	mov	r26, r24
    1d18:	b0 e0       	ldi	r27, 0x00	; 0
    1d1a:	fd 01       	movw	r30, r26
    1d1c:	ef 70       	andi	r30, 0x0F	; 15
    1d1e:	f0 70       	andi	r31, 0x00	; 0
    1d20:	eb 5d       	subi	r30, 0xDB	; 219
    1d22:	fb 4f       	sbci	r31, 0xFB	; 251
    1d24:	80 81       	ld	r24, Z
    1d26:	8f 5f       	subi	r24, 0xFF	; 255
    1d28:	80 83       	st	Z, r24
		  if (NoPumpCount[txPumpID&0x0F]>nNoPump){
    1d2a:	90 91 35 04 	lds	r25, 0x0435
    1d2e:	98 17       	cp	r25, r24
    1d30:	08 f0       	brcs	.+2      	; 0x1d34 <FPoolingPump2+0x202>
    1d32:	7a c1       	rjmp	.+756    	; 0x2028 <FPoolingPump2+0x4f6>
		      NoPumpCount[txPumpID&0x0F]=0;
    1d34:	10 82       	st	Z, r1
	          PumpStatus[txPumpID]=PW_DISCONNECT;
    1d36:	ab 54       	subi	r26, 0x4B	; 75
    1d38:	bc 4f       	sbci	r27, 0xFC	; 252
    1d3a:	8e e0       	ldi	r24, 0x0E	; 14
    1d3c:	8c 93       	st	X, r24
    1d3e:	f4 c1       	rjmp	.+1000   	; 0x2128 <FPoolingPump2+0x5f6>
              stPoolingPump=pwUpdatePumpStatus;
			  }
          else stPoolingPump=pwInitDelayNextPump;
	      break;
     case pwUpdatePumpStatus:
	      PumpAddr=txPumpID;
    1d40:	80 91 17 01 	lds	r24, 0x0117
    1d44:	80 93 05 01 	sts	0x0105, r24
	 	  if (PumpStatus[PumpAddr]!=zPumpStatus[PumpAddr]){
    1d48:	90 e0       	ldi	r25, 0x00	; 0
    1d4a:	fc 01       	movw	r30, r24
    1d4c:	eb 54       	subi	r30, 0x4B	; 75
    1d4e:	fc 4f       	sbci	r31, 0xFC	; 252
    1d50:	e0 81       	ld	r30, Z
    1d52:	dc 01       	movw	r26, r24
    1d54:	a5 56       	subi	r26, 0x65	; 101
    1d56:	bd 4f       	sbci	r27, 0xFD	; 253
    1d58:	8c 91       	ld	r24, X
    1d5a:	e8 17       	cp	r30, r24
    1d5c:	79 f0       	breq	.+30     	; 0x1d7c <FPoolingPump2+0x24a>
		      zPumpStatus[PumpAddr]=PumpStatus[PumpAddr];
    1d5e:	ec 93       	st	X, r30
		      stPoolingPump=pwSendPumpStatus;
    1d60:	86 e0       	ldi	r24, 0x06	; 6
    1d62:	14 c2       	rjmp	.+1064   	; 0x218c <FPoolingPump2+0x65a>
		  }else stPoolingPump=pwNextAction;
	      break;
     case pwSendPumpStatus:
          PumpAddr=txPumpID;
    1d64:	80 91 17 01 	lds	r24, 0x0117
    1d68:	80 93 05 01 	sts	0x0105, r24
	      SendPumpStatusFlow(txPumpID+1,PumpStatus[PumpAddr]);
    1d6c:	e8 2f       	mov	r30, r24
    1d6e:	f0 e0       	ldi	r31, 0x00	; 0
    1d70:	eb 54       	subi	r30, 0x4B	; 75
    1d72:	fc 4f       	sbci	r31, 0xFC	; 252
    1d74:	8f 5f       	subi	r24, 0xFF	; 255
    1d76:	60 81       	ld	r22, Z
    1d78:	0e 94 c8 06 	call	0xd90	; 0xd90 <SendPumpStatusFlow>
		  //sprintf_P(strSend,PSTR("WR:%d MI:%d"),WayneReply,MsgInfo);
		  //_uart_print(1,1,strSend);
	      stPoolingPump=pwNextAction;
    1d7c:	87 e0       	ldi	r24, 0x07	; 7
    1d7e:	06 c2       	rjmp	.+1036   	; 0x218c <FPoolingPump2+0x65a>
	      break;
     case pwNextAction:
	      //Switch Action Based Pump State
		  PumpAddr=txPumpID;
    1d80:	80 91 17 01 	lds	r24, 0x0117
    1d84:	80 93 05 01 	sts	0x0105, r24
		  switch(PumpStatus[PumpAddr]){
    1d88:	a8 2f       	mov	r26, r24
    1d8a:	b0 e0       	ldi	r27, 0x00	; 0
    1d8c:	fd 01       	movw	r30, r26
    1d8e:	eb 54       	subi	r30, 0x4B	; 75
    1d90:	fc 4f       	sbci	r31, 0xFC	; 252
    1d92:	80 81       	ld	r24, Z
    1d94:	87 30       	cpi	r24, 0x07	; 7
    1d96:	09 f4       	brne	.+2      	; 0x1d9a <FPoolingPump2+0x268>
    1d98:	6e c0       	rjmp	.+220    	; 0x1e76 <FPoolingPump2+0x344>
    1d9a:	88 30       	cpi	r24, 0x08	; 8
    1d9c:	20 f4       	brcc	.+8      	; 0x1da6 <FPoolingPump2+0x274>
    1d9e:	86 30       	cpi	r24, 0x06	; 6
    1da0:	09 f0       	breq	.+2      	; 0x1da4 <FPoolingPump2+0x272>
    1da2:	f9 c1       	rjmp	.+1010   	; 0x2196 <FPoolingPump2+0x664>
    1da4:	1e c0       	rjmp	.+60     	; 0x1de2 <FPoolingPump2+0x2b0>
    1da6:	89 30       	cpi	r24, 0x09	; 9
    1da8:	09 f4       	brne	.+2      	; 0x1dac <FPoolingPump2+0x27a>
    1daa:	68 c0       	rjmp	.+208    	; 0x1e7c <FPoolingPump2+0x34a>
    1dac:	8e 30       	cpi	r24, 0x0E	; 14
    1dae:	09 f0       	breq	.+2      	; 0x1db2 <FPoolingPump2+0x280>
    1db0:	f2 c1       	rjmp	.+996    	; 0x2196 <FPoolingPump2+0x664>
		  case PW_DISCONNECT:
		       switch(WayneReply){
    1db2:	80 91 1a 01 	lds	r24, 0x011A
    1db6:	88 23       	and	r24, r24
    1db8:	09 f4       	brne	.+2      	; 0x1dbc <FPoolingPump2+0x28a>
    1dba:	36 c1       	rjmp	.+620    	; 0x2028 <FPoolingPump2+0x4f6>
    1dbc:	84 30       	cpi	r24, 0x04	; 4
    1dbe:	09 f0       	breq	.+2      	; 0x1dc2 <FPoolingPump2+0x290>
    1dc0:	ea c1       	rjmp	.+980    	; 0x2196 <FPoolingPump2+0x664>
			   case WR_MESSAGE:
			        switch(MsgInfo){
    1dc2:	80 91 19 01 	lds	r24, 0x0119
    1dc6:	83 30       	cpi	r24, 0x03	; 3
    1dc8:	39 f0       	breq	.+14     	; 0x1dd8 <FPoolingPump2+0x2a6>
    1dca:	88 30       	cpi	r24, 0x08	; 8
    1dcc:	09 f4       	brne	.+2      	; 0x1dd0 <FPoolingPump2+0x29e>
    1dce:	aa c1       	rjmp	.+852    	; 0x2124 <FPoolingPump2+0x5f2>
    1dd0:	82 30       	cpi	r24, 0x02	; 2
    1dd2:	09 f0       	breq	.+2      	; 0x1dd6 <FPoolingPump2+0x2a4>
    1dd4:	a7 c1       	rjmp	.+846    	; 0x2124 <FPoolingPump2+0x5f2>
    1dd6:	31 c0       	rjmp	.+98     	; 0x1e3a <FPoolingPump2+0x308>
					case MI_NOZZLE_DOWN:
						 IsRequestTransInfo[txPumpID]=True;
    1dd8:	a6 57       	subi	r26, 0x76	; 118
    1dda:	bd 4f       	sbci	r27, 0xFD	; 253
    1ddc:	81 e0       	ldi	r24, 0x01	; 1
    1dde:	8c 93       	st	X, r24
    1de0:	a1 c1       	rjmp	.+834    	; 0x2124 <FPoolingPump2+0x5f2>
			   }
		       break;
          case PW_ONLINE:
		       //sprintf_P(strSend,PSTR("ONLine:%d"),WayneReply);
			   //_uart_print(1,1,strSend);
		       switch(WayneReply){
    1de2:	80 91 1a 01 	lds	r24, 0x011A
    1de6:	81 30       	cpi	r24, 0x01	; 1
    1de8:	21 f0       	breq	.+8      	; 0x1df2 <FPoolingPump2+0x2c0>
    1dea:	84 30       	cpi	r24, 0x04	; 4
    1dec:	09 f0       	breq	.+2      	; 0x1df0 <FPoolingPump2+0x2be>
    1dee:	d3 c1       	rjmp	.+934    	; 0x2196 <FPoolingPump2+0x664>
    1df0:	14 c0       	rjmp	.+40     	; 0x1e1a <FPoolingPump2+0x2e8>
			   case WR_READY:
			        if (IsRequestTransInfo[txPumpID]==True){
    1df2:	fd 01       	movw	r30, r26
    1df4:	e6 57       	subi	r30, 0x76	; 118
    1df6:	fd 4f       	sbci	r31, 0xFD	; 253
    1df8:	80 81       	ld	r24, Z
    1dfa:	81 30       	cpi	r24, 0x01	; 1
    1dfc:	29 f4       	brne	.+10     	; 0x1e08 <FPoolingPump2+0x2d6>
					    iSend=0;
    1dfe:	10 92 f9 03 	sts	0x03F9, r1
					    stPoolingPump=pwSendTransactionRequest;
    1e02:	8e e0       	ldi	r24, 0x0E	; 14
    1e04:	80 93 31 01 	sts	0x0131, r24
					}if (IsRequestTotalizerInfo[txPumpID]==True){
    1e08:	ad 5e       	subi	r26, 0xED	; 237
    1e0a:	bb 4f       	sbci	r27, 0xFB	; 251
    1e0c:	8c 91       	ld	r24, X
    1e0e:	81 30       	cpi	r24, 0x01	; 1
    1e10:	09 f0       	breq	.+2      	; 0x1e14 <FPoolingPump2+0x2e2>
    1e12:	0a c1       	rjmp	.+532    	; 0x2028 <FPoolingPump2+0x4f6>
					    iSend=0;
    1e14:	10 92 f9 03 	sts	0x03F9, r1
    1e18:	29 c0       	rjmp	.+82     	; 0x1e6c <FPoolingPump2+0x33a>
						stPoolingPump=pwSendTotalizerRequest;
					}else stPoolingPump=pwInitDelayNextPump;

			        break;
			   case WR_MESSAGE:
			        switch(MsgInfo){
    1e1a:	80 91 19 01 	lds	r24, 0x0119
    1e1e:	83 30       	cpi	r24, 0x03	; 3
    1e20:	c9 f0       	breq	.+50     	; 0x1e54 <FPoolingPump2+0x322>
    1e22:	84 30       	cpi	r24, 0x04	; 4
    1e24:	20 f4       	brcc	.+8      	; 0x1e2e <FPoolingPump2+0x2fc>
    1e26:	82 30       	cpi	r24, 0x02	; 2
    1e28:	09 f0       	breq	.+2      	; 0x1e2c <FPoolingPump2+0x2fa>
    1e2a:	b5 c1       	rjmp	.+874    	; 0x2196 <FPoolingPump2+0x664>
    1e2c:	06 c0       	rjmp	.+12     	; 0x1e3a <FPoolingPump2+0x308>
    1e2e:	86 30       	cpi	r24, 0x06	; 6
    1e30:	49 f0       	breq	.+18     	; 0x1e44 <FPoolingPump2+0x312>
    1e32:	88 30       	cpi	r24, 0x08	; 8
    1e34:	09 f0       	breq	.+2      	; 0x1e38 <FPoolingPump2+0x306>
    1e36:	af c1       	rjmp	.+862    	; 0x2196 <FPoolingPump2+0x664>
    1e38:	12 c0       	rjmp	.+36     	; 0x1e5e <FPoolingPump2+0x32c>
					case MI_NOZZLE_UP:
					     PumpStatus[PumpAddr]=PW_CALL;
    1e3a:	87 e0       	ldi	r24, 0x07	; 7
    1e3c:	80 83       	st	Z, r24
						 iAuthCmd=0;
    1e3e:	10 92 2e 01 	sts	0x012E, r1
    1e42:	72 c1       	rjmp	.+740    	; 0x2128 <FPoolingPump2+0x5f6>
						 stPoolingPump=pwUpdatePumpStatus;
					     break;
					case MI_LAST_TRANSACTION:
                         if (IsRequestTransInfo[txPumpID]==True)
    1e44:	a6 57       	subi	r26, 0x76	; 118
    1e46:	bd 4f       	sbci	r27, 0xFD	; 253
    1e48:	8c 91       	ld	r24, X
    1e4a:	81 30       	cpi	r24, 0x01	; 1
    1e4c:	09 f0       	breq	.+2      	; 0x1e50 <FPoolingPump2+0x31e>
    1e4e:	ec c0       	rjmp	.+472    	; 0x2028 <FPoolingPump2+0x4f6>
						     stPoolingPump=pwSendTransMessage;
    1e50:	81 e1       	ldi	r24, 0x11	; 17
    1e52:	9c c1       	rjmp	.+824    	; 0x218c <FPoolingPump2+0x65a>
                         else stPoolingPump=pwInitDelayNextPump;
					     break;
					case MI_NOZZLE_DOWN:
                         IsRequestTransInfo[txPumpID]=True;
    1e54:	a6 57       	subi	r26, 0x76	; 118
    1e56:	bd 4f       	sbci	r27, 0xFD	; 253
    1e58:	81 e0       	ldi	r24, 0x01	; 1
    1e5a:	8c 93       	st	X, r24
    1e5c:	e5 c0       	rjmp	.+458    	; 0x2028 <FPoolingPump2+0x4f6>
						 stPoolingPump=pwInitDelayNextPump;
					     break;
                    case MI_TOTALIZER:
					     if (ActiveNozzle<4){
    1e5e:	80 91 1c 01 	lds	r24, 0x011C
    1e62:	84 30       	cpi	r24, 0x04	; 4
    1e64:	30 f4       	brcc	.+12     	; 0x1e72 <FPoolingPump2+0x340>
						     iSend=0;
    1e66:	10 92 f9 03 	sts	0x03F9, r1
						     ActiveNozzle++;
    1e6a:	8f 5f       	subi	r24, 0xFF	; 255
    1e6c:	80 93 1c 01 	sts	0x011C, r24
    1e70:	be c0       	rjmp	.+380    	; 0x1fee <FPoolingPump2+0x4bc>
						     stPoolingPump=pwSendTotalizerRequest;
						 }else stPoolingPump=pwSendTotalizerInfo;
    1e72:	8c e0       	ldi	r24, 0x0C	; 12
    1e74:	8b c1       	rjmp	.+790    	; 0x218c <FPoolingPump2+0x65a>
			   case WR_NACK:
			        break;
			   }
		       break;
          case PW_CALL:
		       iSend=0; 
    1e76:	10 92 f9 03 	sts	0x03F9, r1
    1e7a:	34 c1       	rjmp	.+616    	; 0x20e4 <FPoolingPump2+0x5b2>
			   stPoolingPump=pwSendAuthorizeCommand;               			   
		       break;
           
          case PW_AUTHORIZED:
               if (WayneReply==WR_READY){
    1e7c:	80 91 1a 01 	lds	r24, 0x011A
    1e80:	81 30       	cpi	r24, 0x01	; 1
    1e82:	09 f4       	brne	.+2      	; 0x1e86 <FPoolingPump2+0x354>
    1e84:	d1 c0       	rjmp	.+418    	; 0x2028 <FPoolingPump2+0x4f6>
			           stPoolingPump=pwInitDelayNextPump;
			   }else if (WayneReply==WR_MESSAGE){
    1e86:	80 91 1a 01 	lds	r24, 0x011A
    1e8a:	84 30       	cpi	r24, 0x04	; 4
    1e8c:	09 f0       	breq	.+2      	; 0x1e90 <FPoolingPump2+0x35e>
    1e8e:	83 c1       	rjmp	.+774    	; 0x2196 <FPoolingPump2+0x664>
			       if (MsgInfo==MI_NOZZLE_DOWN){
    1e90:	80 91 19 01 	lds	r24, 0x0119
    1e94:	83 30       	cpi	r24, 0x03	; 3
    1e96:	09 f0       	breq	.+2      	; 0x1e9a <FPoolingPump2+0x368>
    1e98:	76 c1       	rjmp	.+748    	; 0x2186 <FPoolingPump2+0x654>
				       PumpStatus[PumpAddr]=PW_ONLINE;
    1e9a:	86 e0       	ldi	r24, 0x06	; 6
    1e9c:	80 83       	st	Z, r24
					   iSend=0;
    1e9e:	10 92 f9 03 	sts	0x03F9, r1
    1ea2:	3a c0       	rjmp	.+116    	; 0x1f18 <FPoolingPump2+0x3e6>
	      break;
     //Request last Transaction
	 case pwSendTransactionRequest:	 
	      //sprintf_P(strSend,PSTR("Last Transcation"));
		  //_uart_print(1,1,strSend);
		  FWayneSendCommand(CMD_TRANSACTION,CommandSeqID[txPumpID],txPumpID,ActiveNozzle);          
    1ea4:	40 91 17 01 	lds	r20, 0x0117
    1ea8:	e4 2f       	mov	r30, r20
    1eaa:	f0 e0       	ldi	r31, 0x00	; 0
    1eac:	ee 57       	subi	r30, 0x7E	; 126
    1eae:	fd 4f       	sbci	r31, 0xFD	; 253
    1eb0:	8e e0       	ldi	r24, 0x0E	; 14
    1eb2:	60 81       	ld	r22, Z
    1eb4:	20 91 1c 01 	lds	r18, 0x011C
    1eb8:	0e 94 95 07 	call	0xf2a	; 0xf2a <FWayneSendCommand>
		  TimSend=0;
    1ebc:	10 92 24 04 	sts	0x0424, r1
    1ec0:	10 92 23 04 	sts	0x0423, r1
          stPoolingPump=pwWaitTransACK;
    1ec4:	8f e0       	ldi	r24, 0x0F	; 15
    1ec6:	62 c1       	rjmp	.+708    	; 0x218c <FPoolingPump2+0x65a>
	      break;
     case pwWaitTransACK:
	 	  //Timeout->NoPump		  
          if (TimSend>TPoolTimeout){
    1ec8:	80 91 b6 02 	lds	r24, 0x02B6
    1ecc:	90 e0       	ldi	r25, 0x00	; 0
    1ece:	20 91 23 04 	lds	r18, 0x0423
    1ed2:	30 91 24 04 	lds	r19, 0x0424
    1ed6:	82 17       	cp	r24, r18
    1ed8:	93 07       	cpc	r25, r19
    1eda:	18 f4       	brcc	.+6      	; 0x1ee2 <FPoolingPump2+0x3b0>
		      stPoolingPump=pwRetrySendTransRequest;
    1edc:	80 e1       	ldi	r24, 0x10	; 16
    1ede:	80 93 31 01 	sts	0x0131, r24
		  }
          //Acknowledge
	      if (WayneReply==WR_ACK){
    1ee2:	90 91 1a 01 	lds	r25, 0x011A
    1ee6:	92 30       	cpi	r25, 0x02	; 2
    1ee8:	09 f4       	brne	.+2      	; 0x1eec <FPoolingPump2+0x3ba>
    1eea:	60 c0       	rjmp	.+192    	; 0x1fac <FPoolingPump2+0x47a>
		      CommandSeqID[txPumpID]++;
			  //stPoolingPump=pwSendTransMessage;
			  stPoolingPump=pwScanStatus;
		  }else if (WayneReply==WR_NACK){
    1eec:	80 91 1a 01 	lds	r24, 0x011A
    1ef0:	83 30       	cpi	r24, 0x03	; 3
    1ef2:	09 f0       	breq	.+2      	; 0x1ef6 <FPoolingPump2+0x3c4>
    1ef4:	50 c1       	rjmp	.+672    	; 0x2196 <FPoolingPump2+0x664>
		      CommandSeqID[txPumpID]=0;
    1ef6:	e0 91 17 01 	lds	r30, 0x0117
    1efa:	f0 e0       	ldi	r31, 0x00	; 0
    1efc:	ee 57       	subi	r30, 0x7E	; 126
    1efe:	fd 4f       	sbci	r31, 0xFD	; 253
    1f00:	10 82       	st	Z, r1
    1f02:	0a c0       	rjmp	.+20     	; 0x1f18 <FPoolingPump2+0x3e6>
              stPoolingPump=pwSendTransactionRequest;
		  }
	      break;
     case pwRetrySendTransRequest:
	      iSend++;
    1f04:	80 91 f9 03 	lds	r24, 0x03F9
    1f08:	8f 5f       	subi	r24, 0xFF	; 255
    1f0a:	80 93 f9 03 	sts	0x03F9, r24
		  if (iSend<nSend)stPoolingPump=pwSendTransactionRequest;
    1f0e:	90 91 77 02 	lds	r25, 0x0277
    1f12:	89 17       	cp	r24, r25
    1f14:	08 f0       	brcs	.+2      	; 0x1f18 <FPoolingPump2+0x3e6>
    1f16:	e8 c0       	rjmp	.+464    	; 0x20e8 <FPoolingPump2+0x5b6>
    1f18:	8e e0       	ldi	r24, 0x0E	; 14
    1f1a:	38 c1       	rjmp	.+624    	; 0x218c <FPoolingPump2+0x65a>
		  else
		  if (iSend>=nSend)stPoolingPump=pwNoPump;
	      break;

     case pwSendTransMessage:
          rxPumpId=txPumpID;
    1f1c:	60 91 17 01 	lds	r22, 0x0117
    1f20:	60 93 3b 01 	sts	0x013B, r22
		  NozzleId=ActiveNozzle;
    1f24:	20 91 1c 01 	lds	r18, 0x011C
    1f28:	20 93 e0 02 	sts	0x02E0, r18
		  GradeId=ActiveNozzle;
    1f2c:	20 93 f6 02 	sts	0x02F6, r18
		  PumpTransDigit=6;
    1f30:	86 e0       	ldi	r24, 0x06	; 6
    1f32:	80 93 0b 01 	sts	0x010B, r24
	      SendTransFlow(txPumpID+1,rxPumpId+1,NozzleId,GradeId,strUnitPrice,strVolume,strAmount,PumpTransDigit);
    1f36:	6f 5f       	subi	r22, 0xFF	; 255
    1f38:	86 2f       	mov	r24, r22
    1f3a:	42 2f       	mov	r20, r18
    1f3c:	0c ea       	ldi	r16, 0xAC	; 172
    1f3e:	12 e0       	ldi	r17, 0x02	; 2
    1f40:	37 e5       	ldi	r19, 0x57	; 87
    1f42:	e3 2e       	mov	r14, r19
    1f44:	32 e0       	ldi	r19, 0x02	; 2
    1f46:	f3 2e       	mov	r15, r19
    1f48:	9b ea       	ldi	r25, 0xAB	; 171
    1f4a:	c9 2e       	mov	r12, r25
    1f4c:	93 e0       	ldi	r25, 0x03	; 3
    1f4e:	d9 2e       	mov	r13, r25
    1f50:	b6 e0       	ldi	r27, 0x06	; 6
    1f52:	ab 2e       	mov	r10, r27
    1f54:	0e 94 d7 09 	call	0x13ae	; 0x13ae <SendTransFlow>
		  IsRequestTransInfo[txPumpID]=False;
    1f58:	e0 91 17 01 	lds	r30, 0x0117
    1f5c:	f0 e0       	ldi	r31, 0x00	; 0
    1f5e:	e6 57       	subi	r30, 0x76	; 118
    1f60:	fd 4f       	sbci	r31, 0xFD	; 253
    1f62:	10 82       	st	Z, r1
    1f64:	61 c0       	rjmp	.+194    	; 0x2028 <FPoolingPump2+0x4f6>
		  //IsRequestTotalizerInfo[txPumpID]=True;
          stPoolingPump=pwInitDelayNextPump;
	      break; 
	 //Totalizer
	 case pwSendTotalizerRequest:
	      FWayneSendCommand(CMD_TOTALIZER,CommandSeqID[txPumpID],txPumpID,ActiveNozzle);          
    1f66:	40 91 17 01 	lds	r20, 0x0117
    1f6a:	e4 2f       	mov	r30, r20
    1f6c:	f0 e0       	ldi	r31, 0x00	; 0
    1f6e:	ee 57       	subi	r30, 0x7E	; 126
    1f70:	fd 4f       	sbci	r31, 0xFD	; 253
    1f72:	85 e0       	ldi	r24, 0x05	; 5
    1f74:	60 81       	ld	r22, Z
    1f76:	20 91 1c 01 	lds	r18, 0x011C
    1f7a:	0e 94 95 07 	call	0xf2a	; 0xf2a <FWayneSendCommand>
		  TimSend=0;
    1f7e:	10 92 24 04 	sts	0x0424, r1
    1f82:	10 92 23 04 	sts	0x0423, r1
          stPoolingPump=pwWaitTotalizerACK;
    1f86:	8a e0       	ldi	r24, 0x0A	; 10
    1f88:	01 c1       	rjmp	.+514    	; 0x218c <FPoolingPump2+0x65a>
	      break;
     case pwWaitTotalizerACK:
	       //Timeout->NoPump		  
          if (TimSend>TPoolTimeout){
    1f8a:	80 91 b6 02 	lds	r24, 0x02B6
    1f8e:	90 e0       	ldi	r25, 0x00	; 0
    1f90:	20 91 23 04 	lds	r18, 0x0423
    1f94:	30 91 24 04 	lds	r19, 0x0424
    1f98:	82 17       	cp	r24, r18
    1f9a:	93 07       	cpc	r25, r19
    1f9c:	18 f4       	brcc	.+6      	; 0x1fa4 <FPoolingPump2+0x472>
		      stPoolingPump=pwRetrySendTotalizerRequest;
    1f9e:	8b e0       	ldi	r24, 0x0B	; 11
    1fa0:	80 93 31 01 	sts	0x0131, r24
		  }
          //Acknowledge
	      if (WayneReply==WR_ACK){
    1fa4:	90 91 1a 01 	lds	r25, 0x011A
    1fa8:	92 30       	cpi	r25, 0x02	; 2
    1faa:	59 f4       	brne	.+22     	; 0x1fc2 <FPoolingPump2+0x490>
		      CommandSeqID[txPumpID]++;
    1fac:	e0 91 17 01 	lds	r30, 0x0117
    1fb0:	f0 e0       	ldi	r31, 0x00	; 0
    1fb2:	ee 57       	subi	r30, 0x7E	; 126
    1fb4:	fd 4f       	sbci	r31, 0xFD	; 253
    1fb6:	80 81       	ld	r24, Z
    1fb8:	8f 5f       	subi	r24, 0xFF	; 255
    1fba:	80 83       	st	Z, r24
			  stPoolingPump=pwScanStatus;
    1fbc:	90 93 31 01 	sts	0x0131, r25
    1fc0:	ea c0       	rjmp	.+468    	; 0x2196 <FPoolingPump2+0x664>
		  }else if (WayneReply==WR_NACK){
    1fc2:	80 91 1a 01 	lds	r24, 0x011A
    1fc6:	83 30       	cpi	r24, 0x03	; 3
    1fc8:	09 f0       	breq	.+2      	; 0x1fcc <FPoolingPump2+0x49a>
    1fca:	e5 c0       	rjmp	.+458    	; 0x2196 <FPoolingPump2+0x664>
		      CommandSeqID[txPumpID]=0;
    1fcc:	e0 91 17 01 	lds	r30, 0x0117
    1fd0:	f0 e0       	ldi	r31, 0x00	; 0
    1fd2:	ee 57       	subi	r30, 0x7E	; 126
    1fd4:	fd 4f       	sbci	r31, 0xFD	; 253
    1fd6:	10 82       	st	Z, r1
    1fd8:	0a c0       	rjmp	.+20     	; 0x1fee <FPoolingPump2+0x4bc>
              stPoolingPump=pwSendTotalizerRequest;
		  }
	      break;
     case pwRetrySendTotalizerRequest:
	      iSend++;
    1fda:	80 91 f9 03 	lds	r24, 0x03F9
    1fde:	8f 5f       	subi	r24, 0xFF	; 255
    1fe0:	80 93 f9 03 	sts	0x03F9, r24
		  if (iSend<nSend)stPoolingPump=pwSendTotalizerRequest;
    1fe4:	90 91 77 02 	lds	r25, 0x0277
    1fe8:	89 17       	cp	r24, r25
    1fea:	08 f0       	brcs	.+2      	; 0x1fee <FPoolingPump2+0x4bc>
    1fec:	7d c0       	rjmp	.+250    	; 0x20e8 <FPoolingPump2+0x5b6>
    1fee:	89 e0       	ldi	r24, 0x09	; 9
    1ff0:	cd c0       	rjmp	.+410    	; 0x218c <FPoolingPump2+0x65a>
		  else
		  if (iSend>=nSend)stPoolingPump=pwNoPump;
	      break;
     case pwSendTotalizerInfo:
	      PumpTotalDigit=10;
    1ff2:	8a e0       	ldi	r24, 0x0A	; 10
    1ff4:	80 93 0c 01 	sts	0x010C, r24
	      SendTotalizerFlow(txPumpID+1);
    1ff8:	80 91 17 01 	lds	r24, 0x0117
    1ffc:	8f 5f       	subi	r24, 0xFF	; 255
    1ffe:	0e 94 df 08 	call	0x11be	; 0x11be <SendTotalizerFlow>
		  IsTotalizerACK=False;//True;//
    2002:	10 92 14 01 	sts	0x0114, r1
		  stPoolingPump=pwWaitTotalizerInfoACK;
    2006:	8d e0       	ldi	r24, 0x0D	; 13
    2008:	c1 c0       	rjmp	.+386    	; 0x218c <FPoolingPump2+0x65a>
	      break;
     case pwWaitTotalizerInfoACK:
	      if (IsTotalizerACK==True){//SC_TOTALIZER_ACK
    200a:	80 91 14 01 	lds	r24, 0x0114
    200e:	81 30       	cpi	r24, 0x01	; 1
    2010:	09 f0       	breq	.+2      	; 0x2014 <FPoolingPump2+0x4e2>
    2012:	c1 c0       	rjmp	.+386    	; 0x2196 <FPoolingPump2+0x664>
              IsRequestTotalizerInfo[PumpAddr]=False;
    2014:	e0 91 05 01 	lds	r30, 0x0105
    2018:	f0 e0       	ldi	r31, 0x00	; 0
    201a:	ed 5e       	subi	r30, 0xED	; 237
    201c:	fb 4f       	sbci	r31, 0xFB	; 251
    201e:	10 82       	st	Z, r1
	          TimDelayNextPump=0;
    2020:	10 92 22 01 	sts	0x0122, r1
    2024:	10 92 21 01 	sts	0x0121, r1
		      stPoolingPump=pwInitDelayNextPump;
    2028:	89 e1       	ldi	r24, 0x19	; 25
    202a:	b0 c0       	rjmp	.+352    	; 0x218c <FPoolingPump2+0x65a>
     case pwSendAuthorizeCommand:
	      #ifdef DEBUG_WAYNE_STATE 
		  sprintf_P(strSend,PSTR("Authorize%d"),iAuthCmd+1);
		  _uart_print(1,1,strSend);
		  #endif
		  FWayneSendCommand((CMD_AUTH_1+iAuthCmd),CommandSeqID[txPumpID],txPumpID,ActiveNozzle);          
    202c:	40 91 17 01 	lds	r20, 0x0117
    2030:	80 91 2e 01 	lds	r24, 0x012E
    2034:	e4 2f       	mov	r30, r20
    2036:	f0 e0       	ldi	r31, 0x00	; 0
    2038:	ee 57       	subi	r30, 0x7E	; 126
    203a:	fd 4f       	sbci	r31, 0xFD	; 253
    203c:	86 5f       	subi	r24, 0xF6	; 246
    203e:	60 81       	ld	r22, Z
    2040:	20 91 1c 01 	lds	r18, 0x011C
    2044:	0e 94 95 07 	call	0xf2a	; 0xf2a <FWayneSendCommand>
		  TimSend=0;
    2048:	10 92 24 04 	sts	0x0424, r1
    204c:	10 92 23 04 	sts	0x0423, r1
          stPoolingPump=pwWaitAuthACK;
    2050:	83 e1       	ldi	r24, 0x13	; 19
    2052:	9c c0       	rjmp	.+312    	; 0x218c <FPoolingPump2+0x65a>
	      break;
     case pwWaitAuthACK:
	 	  //Timeout->NoPump		  
          if (TimSend>TPoolTimeout){
    2054:	80 91 b6 02 	lds	r24, 0x02B6
    2058:	90 e0       	ldi	r25, 0x00	; 0
    205a:	20 91 23 04 	lds	r18, 0x0423
    205e:	30 91 24 04 	lds	r19, 0x0424
    2062:	82 17       	cp	r24, r18
    2064:	93 07       	cpc	r25, r19
    2066:	18 f4       	brcc	.+6      	; 0x206e <FPoolingPump2+0x53c>
		      stPoolingPump=pwRetrySendAuthorizeCommand;
    2068:	84 e1       	ldi	r24, 0x14	; 20
    206a:	80 93 31 01 	sts	0x0131, r24
		  }		  
	      //Acknowledge
	      if (WayneReply==WR_ACK){
    206e:	20 91 1a 01 	lds	r18, 0x011A
    2072:	22 30       	cpi	r18, 0x02	; 2
    2074:	09 f5       	brne	.+66     	; 0x20b8 <FPoolingPump2+0x586>
		      iAuthCmd++;
    2076:	80 91 2e 01 	lds	r24, 0x012E
    207a:	8f 5f       	subi	r24, 0xFF	; 255
    207c:	80 93 2e 01 	sts	0x012E, r24
    2080:	90 91 17 01 	lds	r25, 0x0117
			  if (iAuthCmd>=4){//Complete ACK
    2084:	84 30       	cpi	r24, 0x04	; 4
    2086:	80 f0       	brcs	.+32     	; 0x20a8 <FPoolingPump2+0x576>
			      PumpStatus[PumpAddr]=PW_AUTHORIZED;
    2088:	e0 91 05 01 	lds	r30, 0x0105
    208c:	f0 e0       	ldi	r31, 0x00	; 0
    208e:	eb 54       	subi	r30, 0x4B	; 75
    2090:	fc 4f       	sbci	r31, 0xFC	; 252
    2092:	89 e0       	ldi	r24, 0x09	; 9
    2094:	80 83       	st	Z, r24
				  IsRequestTransInfo[txPumpID]=True;
    2096:	e9 2f       	mov	r30, r25
    2098:	f0 e0       	ldi	r31, 0x00	; 0
    209a:	e6 57       	subi	r30, 0x76	; 118
    209c:	fd 4f       	sbci	r31, 0xFD	; 253
    209e:	81 e0       	ldi	r24, 0x01	; 1
    20a0:	80 83       	st	Z, r24
			      stPoolingPump=pwScanStatus;
    20a2:	20 93 31 01 	sts	0x0131, r18
    20a6:	77 c0       	rjmp	.+238    	; 0x2196 <FPoolingPump2+0x664>
			  }else {
			   CommandSeqID[txPumpID]++;
    20a8:	e9 2f       	mov	r30, r25
    20aa:	f0 e0       	ldi	r31, 0x00	; 0
    20ac:	ee 57       	subi	r30, 0x7E	; 126
    20ae:	fd 4f       	sbci	r31, 0xFD	; 253
    20b0:	80 81       	ld	r24, Z
    20b2:	8f 5f       	subi	r24, 0xFF	; 255
    20b4:	80 83       	st	Z, r24
    20b6:	16 c0       	rjmp	.+44     	; 0x20e4 <FPoolingPump2+0x5b2>
			   stPoolingPump=pwSendAuthorizeCommand;
			   }
		  }else if (WayneReply==WR_NACK){
    20b8:	80 91 1a 01 	lds	r24, 0x011A
    20bc:	83 30       	cpi	r24, 0x03	; 3
    20be:	09 f0       	breq	.+2      	; 0x20c2 <FPoolingPump2+0x590>
    20c0:	6a c0       	rjmp	.+212    	; 0x2196 <FPoolingPump2+0x664>
		      CommandSeqID[txPumpID]=0;
    20c2:	e0 91 17 01 	lds	r30, 0x0117
    20c6:	f0 e0       	ldi	r31, 0x00	; 0
    20c8:	ee 57       	subi	r30, 0x7E	; 126
    20ca:	fd 4f       	sbci	r31, 0xFD	; 253
    20cc:	10 82       	st	Z, r1
              stPoolingPump=pwRetrySendAuthorizeCommand;
    20ce:	84 e1       	ldi	r24, 0x14	; 20
    20d0:	5d c0       	rjmp	.+186    	; 0x218c <FPoolingPump2+0x65a>
		  }
	      break;
     case pwRetrySendAuthorizeCommand:
	      iSend++;
    20d2:	80 91 f9 03 	lds	r24, 0x03F9
    20d6:	8f 5f       	subi	r24, 0xFF	; 255
    20d8:	80 93 f9 03 	sts	0x03F9, r24
		  if (iSend<nSend)stPoolingPump=pwSendAuthorizeCommand;
    20dc:	90 91 77 02 	lds	r25, 0x0277
    20e0:	89 17       	cp	r24, r25
    20e2:	10 f4       	brcc	.+4      	; 0x20e8 <FPoolingPump2+0x5b6>
    20e4:	82 e1       	ldi	r24, 0x12	; 18
    20e6:	52 c0       	rjmp	.+164    	; 0x218c <FPoolingPump2+0x65a>
		  else
		  if (iSend>=nSend)stPoolingPump=pwNoPump;
    20e8:	84 e0       	ldi	r24, 0x04	; 4
    20ea:	50 c0       	rjmp	.+160    	; 0x218c <FPoolingPump2+0x65a>
	 case pwSendGeneralStatus:
	      
	      break;
	 //Price Config	  
	 case pwSendPriceConfig:
	      stPoolingPump=pwWaitACK; 
    20ec:	86 e1       	ldi	r24, 0x16	; 22
    20ee:	4e c0       	rjmp	.+156    	; 0x218c <FPoolingPump2+0x65a>
	      break;
	 case pwWaitACK:
	      PumpStatus[PumpAddr]=PW_PRICE_UPDATED;
    20f0:	e0 91 05 01 	lds	r30, 0x0105
    20f4:	f0 e0       	ldi	r31, 0x00	; 0
    20f6:	eb 54       	subi	r30, 0x4B	; 75
    20f8:	fc 4f       	sbci	r31, 0xFC	; 252
    20fa:	8f e0       	ldi	r24, 0x0F	; 15
    20fc:	14 c0       	rjmp	.+40     	; 0x2126 <FPoolingPump2+0x5f4>
		  stPoolingPump=pwUpdatePumpStatus;
          break;	 
	 //Acknowledge--------------
	 case pwReplyACK:
	      FWayneSendCommand(CMD_ACK,WayneRxSequence,txPumpID,0);
    20fe:	87 e0       	ldi	r24, 0x07	; 7
    2100:	60 91 18 01 	lds	r22, 0x0118
    2104:	40 91 17 01 	lds	r20, 0x0117
    2108:	20 e0       	ldi	r18, 0x00	; 0
    210a:	0e 94 95 07 	call	0xf2a	; 0xf2a <FWayneSendCommand>
		  stPoolingPump=pwScanMessage;
    210e:	88 e1       	ldi	r24, 0x18	; 24
    2110:	3d c0       	rjmp	.+122    	; 0x218c <FPoolingPump2+0x65a>
	      break;	 
	 case pwScanMessage:
	      if (PumpStatus[txPumpID]==PW_NONE){
    2112:	80 91 17 01 	lds	r24, 0x0117
    2116:	e8 2f       	mov	r30, r24
    2118:	f0 e0       	ldi	r31, 0x00	; 0
    211a:	eb 54       	subi	r30, 0x4B	; 75
    211c:	fc 4f       	sbci	r31, 0xFC	; 252
    211e:	80 81       	ld	r24, Z
    2120:	88 23       	and	r24, r24
    2122:	11 f4       	brne	.+4      	; 0x2128 <FPoolingPump2+0x5f6>
			  PumpStatus[txPumpID]=PW_ONLINE;
    2124:	86 e0       	ldi	r24, 0x06	; 6
    2126:	80 83       	st	Z, r24
		  }		  
	      stPoolingPump=pwUpdatePumpStatus;
    2128:	85 e0       	ldi	r24, 0x05	; 5
    212a:	30 c0       	rjmp	.+96     	; 0x218c <FPoolingPump2+0x65a>
	      break;		  
		  		 		  
     //Next Pump----------------
     case pwInitDelayNextPump:
	      TimDelayNextPump=0;
    212c:	10 92 22 01 	sts	0x0122, r1
    2130:	10 92 21 01 	sts	0x0121, r1
          stPoolingPump=pwDelayNextPump;
    2134:	8a e1       	ldi	r24, 0x1A	; 26
    2136:	2a c0       	rjmp	.+84     	; 0x218c <FPoolingPump2+0x65a>
	      break;
     case pwDelayNextPump:
	      if (TimDelayNextPump>=TDelayNextPump)//20
    2138:	80 91 3c 01 	lds	r24, 0x013C
    213c:	90 e0       	ldi	r25, 0x00	; 0
    213e:	20 91 21 01 	lds	r18, 0x0121
    2142:	30 91 22 01 	lds	r19, 0x0122
    2146:	28 17       	cp	r18, r24
    2148:	39 07       	cpc	r19, r25
    214a:	28 f1       	brcs	.+74     	; 0x2196 <FPoolingPump2+0x664>
    214c:	1e c0       	rjmp	.+60     	; 0x218a <FPoolingPump2+0x658>
		      stPoolingPump=pwNextPump;
	      break;
     case pwNextPump:	      
          iPoolingID++;
    214e:	90 91 16 01 	lds	r25, 0x0116
    2152:	9f 5f       	subi	r25, 0xFF	; 255
    2154:	90 93 16 01 	sts	0x0116, r25
	      if (iPoolingID<ScanPumpMax){
    2158:	80 91 61 02 	lds	r24, 0x0261
    215c:	98 17       	cp	r25, r24
    215e:	c8 f4       	brcc	.+50     	; 0x2192 <FPoolingPump2+0x660>
			  txPumpID=eeprom_read_byte(&DefPumpID[iPoolingID]);
    2160:	89 2f       	mov	r24, r25
    2162:	90 e0       	ldi	r25, 0x00	; 0
    2164:	83 5f       	subi	r24, 0xF3	; 243
    2166:	9f 4f       	sbci	r25, 0xFF	; 255
    2168:	0e 94 2a 17 	call	0x2e54	; 0x2e54 <__eerd_byte_m162>
    216c:	80 93 17 01 	sts	0x0117, r24
			  if (txPumpID>0){
    2170:	88 23       	and	r24, r24
    2172:	59 f0       	breq	.+22     	; 0x218a <FPoolingPump2+0x658>
			      txPumpID=txPumpID-1;
    2174:	81 50       	subi	r24, 0x01	; 1
    2176:	80 93 17 01 	sts	0x0117, r24
			      iSend=0;TimSend=0;
    217a:	10 92 f9 03 	sts	0x03F9, r1
    217e:	10 92 24 04 	sts	0x0424, r1
    2182:	10 92 23 04 	sts	0x0423, r1
			      stPoolingPump=pwScanStatus;
    2186:	82 e0       	ldi	r24, 0x02	; 2
    2188:	01 c0       	rjmp	.+2      	; 0x218c <FPoolingPump2+0x65a>
			   }else stPoolingPump=pwNextPump;
    218a:	8b e1       	ldi	r24, 0x1B	; 27
    218c:	80 93 31 01 	sts	0x0131, r24
    2190:	02 c0       	rjmp	.+4      	; 0x2196 <FPoolingPump2+0x664>
		  } else stPoolingPump=pwInit;//pwInitPumpAddr;
    2192:	10 92 31 01 	sts	0x0131, r1
		  #endif
		  
		  //stPoolingPump=pwInitPumpAddr;
	      break;
	 }
}
    2196:	6e 96       	adiw	r28, 0x1e	; 30
    2198:	0f b6       	in	r0, 0x3f	; 63
    219a:	f8 94       	cli
    219c:	de bf       	out	0x3e, r29	; 62
    219e:	0f be       	out	0x3f, r0	; 63
    21a0:	cd bf       	out	0x3d, r28	; 61
    21a2:	cf 91       	pop	r28
    21a4:	df 91       	pop	r29
    21a6:	1f 91       	pop	r17
    21a8:	0f 91       	pop	r16
    21aa:	ff 90       	pop	r15
    21ac:	ef 90       	pop	r14
    21ae:	df 90       	pop	r13
    21b0:	cf 90       	pop	r12
    21b2:	af 90       	pop	r10
    21b4:	08 95       	ret

000021b6 <TerminalSend>:
       while(pgm_read_byte(&(*strSendf)))
	         _uart(Com, 1, pgm_read_byte(&(*strSendf++)));
	}
}

void TerminalSend(char Com,char *strSend){
    21b6:	1f 93       	push	r17
    21b8:	cf 93       	push	r28
    21ba:	df 93       	push	r29
    21bc:	18 2f       	mov	r17, r24
    21be:	eb 01       	movw	r28, r22
   if (eeprom_read_byte(&DefTerminalDebug)){
    21c0:	84 e0       	ldi	r24, 0x04	; 4
    21c2:	90 e0       	ldi	r25, 0x00	; 0
    21c4:	0e 94 2a 17 	call	0x2e54	; 0x2e54 <__eerd_byte_m162>
    21c8:	88 23       	and	r24, r24
    21ca:	29 f0       	breq	.+10     	; 0x21d6 <TerminalSend+0x20>
       _uart_print(Com,1,strSend);
    21cc:	81 2f       	mov	r24, r17
    21ce:	61 e0       	ldi	r22, 0x01	; 1
    21d0:	ae 01       	movw	r20, r28
    21d2:	0e 94 96 14 	call	0x292c	; 0x292c <_uart_print>
	}
}
    21d6:	df 91       	pop	r29
    21d8:	cf 91       	pop	r28
    21da:	1f 91       	pop	r17
    21dc:	08 95       	ret

000021de <SystemSetSlave>:

return Result;
}

void SystemSetSlave(){
     SystemComLevel(CL_232);
    21de:	81 e0       	ldi	r24, 0x01	; 1
    21e0:	0e 94 61 01 	call	0x2c2	; 0x2c2 <SystemComLevel>
     //_uart_setting(1,GetBaudrate(eeprom_read_byte(&DefBaudrate[1])),8,P_NONE,1);
	 //_uart_init(0,GetBaudrate(eeprom_read_byte(&DefBaudrate[0])));	

	 _uart_init(0,9600);	
    21e4:	80 e0       	ldi	r24, 0x00	; 0
    21e6:	40 e8       	ldi	r20, 0x80	; 128
    21e8:	55 e2       	ldi	r21, 0x25	; 37
    21ea:	60 e0       	ldi	r22, 0x00	; 0
    21ec:	70 e0       	ldi	r23, 0x00	; 0
    21ee:	0e 94 53 14 	call	0x28a6	; 0x28a6 <_uart_init>
	 _uart_init(1,9600);	
    21f2:	81 e0       	ldi	r24, 0x01	; 1
    21f4:	40 e8       	ldi	r20, 0x80	; 128
    21f6:	55 e2       	ldi	r21, 0x25	; 37
    21f8:	60 e0       	ldi	r22, 0x00	; 0
    21fa:	70 e0       	ldi	r23, 0x00	; 0
    21fc:	0e 94 53 14 	call	0x28a6	; 0x28a6 <_uart_init>
}
    2200:	08 95       	ret

00002202 <SystemSetDispenser>:

//enum eBaudRateValue{brNone,br9600,br19200,br5787};

void SystemSetDispenser(char TDispenserBrand){
    2202:	ef 92       	push	r14
    2204:	0f 93       	push	r16
     unsigned int brValue;

	 switch(TDispenserBrand){
    2206:	81 30       	cpi	r24, 0x01	; 1
    2208:	d1 f0       	breq	.+52     	; 0x223e <SystemSetDispenser+0x3c>
    220a:	81 30       	cpi	r24, 0x01	; 1
    220c:	30 f0       	brcs	.+12     	; 0x221a <SystemSetDispenser+0x18>
    220e:	82 30       	cpi	r24, 0x02	; 2
    2210:	59 f1       	breq	.+86     	; 0x2268 <SystemSetDispenser+0x66>
    2212:	83 30       	cpi	r24, 0x03	; 3
    2214:	09 f0       	breq	.+2      	; 0x2218 <SystemSetDispenser+0x16>
    2216:	55 c0       	rjmp	.+170    	; 0x22c2 <SystemSetDispenser+0xc0>
    2218:	3c c0       	rjmp	.+120    	; 0x2292 <SystemSetDispenser+0x90>
	 case ST_NONE:
	      //_uart_setting(0,GetBaudrate(eeprom_read_byte(&DefBaudrate[0])),8,P_NONE,1);
		  _uart_init(0,9600);
    221a:	80 e0       	ldi	r24, 0x00	; 0
    221c:	40 e8       	ldi	r20, 0x80	; 128
    221e:	55 e2       	ldi	r21, 0x25	; 37
    2220:	60 e0       	ldi	r22, 0x00	; 0
    2222:	70 e0       	ldi	r23, 0x00	; 0
    2224:	0e 94 53 14 	call	0x28a6	; 0x28a6 <_uart_init>
		  _uart_init(1,9600);
    2228:	81 e0       	ldi	r24, 0x01	; 1
    222a:	40 e8       	ldi	r20, 0x80	; 128
    222c:	55 e2       	ldi	r21, 0x25	; 37
    222e:	60 e0       	ldi	r22, 0x00	; 0
    2230:	70 e0       	ldi	r23, 0x00	; 0
    2232:	0e 94 53 14 	call	0x28a6	; 0x28a6 <_uart_init>
          SystemComLevel(CL_232);
    2236:	81 e0       	ldi	r24, 0x01	; 1
    2238:	0e 94 61 01 	call	0x2c2	; 0x2c2 <SystemComLevel>
    223c:	42 c0       	rjmp	.+132    	; 0x22c2 <SystemSetDispenser+0xc0>
	      break;
	 case ST_GILBARCO:
	      if (eeprom_read_byte(&DefHGMode)==HM_TTL)
    223e:	8e e1       	ldi	r24, 0x1E	; 30
    2240:	90 e0       	ldi	r25, 0x00	; 0
    2242:	0e 94 2a 17 	call	0x2e54	; 0x2e54 <__eerd_byte_m162>
    2246:	81 11       	cpse	r24, r1
		       SystemComLevel(CL_TTL);
		  else SystemComLevel(CL_232);
    2248:	81 e0       	ldi	r24, 0x01	; 1
    224a:	0e 94 61 01 	call	0x2c2	; 0x2c2 <SystemComLevel>
	      
		  eeprom_write_byte(&DefBaudrate[0],br5787);
    224e:	85 e0       	ldi	r24, 0x05	; 5
    2250:	90 e0       	ldi	r25, 0x00	; 0
    2252:	63 e0       	ldi	r22, 0x03	; 3
    2254:	0e 94 32 17 	call	0x2e64	; 0x2e64 <__eewr_byte_m162>
		  brValue=GetBaudrate(eeprom_read_byte(&DefBaudrate[0]));
	      //_uart_setting(0,brValue,8,P_NONE,1);
		  
          _uart_init(0,5787);
    2258:	80 e0       	ldi	r24, 0x00	; 0
    225a:	4b e9       	ldi	r20, 0x9B	; 155
    225c:	56 e1       	ldi	r21, 0x16	; 22
    225e:	60 e0       	ldi	r22, 0x00	; 0
    2260:	70 e0       	ldi	r23, 0x00	; 0
    2262:	0e 94 53 14 	call	0x28a6	; 0x28a6 <_uart_init>
    2266:	2d c0       	rjmp	.+90     	; 0x22c2 <SystemSetDispenser+0xc0>
	      break;
	 case ST_WAYNE_DART:		       
	 	  SystemComLevel(CL_485);
    2268:	82 e0       	ldi	r24, 0x02	; 2
    226a:	0e 94 61 01 	call	0x2c2	; 0x2c2 <SystemComLevel>
          eeprom_write_byte(&DefBaudrate[0],br9600);
    226e:	85 e0       	ldi	r24, 0x05	; 5
    2270:	90 e0       	ldi	r25, 0x00	; 0
    2272:	61 e0       	ldi	r22, 0x01	; 1
    2274:	0e 94 32 17 	call	0x2e64	; 0x2e64 <__eewr_byte_m162>
		  brValue=GetBaudrate(eeprom_read_byte(&DefBaudrate[0]));
    2278:	85 e0       	ldi	r24, 0x05	; 5
    227a:	90 e0       	ldi	r25, 0x00	; 0
    227c:	0e 94 2a 17 	call	0x2e54	; 0x2e54 <__eerd_byte_m162>
    2280:	0e 94 4b 01 	call	0x296	; 0x296 <GetBaudrate>
	      _uart_setting(0,brValue,8,P_ODD,1);
    2284:	ac 01       	movw	r20, r24
    2286:	60 e0       	ldi	r22, 0x00	; 0
    2288:	70 e0       	ldi	r23, 0x00	; 0
    228a:	80 e0       	ldi	r24, 0x00	; 0
    228c:	28 e0       	ldi	r18, 0x08	; 8
    228e:	01 e0       	ldi	r16, 0x01	; 1
    2290:	14 c0       	rjmp	.+40     	; 0x22ba <SystemSetDispenser+0xb8>
	      break;
	 case ST_TATSUNO:
	 	  SystemComLevel(CL_485);
    2292:	82 e0       	ldi	r24, 0x02	; 2
    2294:	0e 94 61 01 	call	0x2c2	; 0x2c2 <SystemComLevel>
          eeprom_write_byte(&DefBaudrate[0],br9600);
    2298:	85 e0       	ldi	r24, 0x05	; 5
    229a:	90 e0       	ldi	r25, 0x00	; 0
    229c:	61 e0       	ldi	r22, 0x01	; 1
    229e:	0e 94 32 17 	call	0x2e64	; 0x2e64 <__eewr_byte_m162>
		  brValue=GetBaudrate(eeprom_read_byte(&DefBaudrate[0]));
    22a2:	85 e0       	ldi	r24, 0x05	; 5
    22a4:	90 e0       	ldi	r25, 0x00	; 0
    22a6:	0e 94 2a 17 	call	0x2e54	; 0x2e54 <__eerd_byte_m162>
    22aa:	0e 94 4b 01 	call	0x296	; 0x296 <GetBaudrate>
	      _uart_setting(0,brValue,8,P_EVEN,1);
    22ae:	ac 01       	movw	r20, r24
    22b0:	60 e0       	ldi	r22, 0x00	; 0
    22b2:	70 e0       	ldi	r23, 0x00	; 0
    22b4:	80 e0       	ldi	r24, 0x00	; 0
    22b6:	28 e0       	ldi	r18, 0x08	; 8
    22b8:	02 e0       	ldi	r16, 0x02	; 2
    22ba:	ee 24       	eor	r14, r14
    22bc:	e3 94       	inc	r14
    22be:	0e 94 be 13 	call	0x277c	; 0x277c <_uart_setting>
	      break;
	 case ST_LG:
	      break;			  
	 }
	 InitPumpData();
    22c2:	0e 94 cd 01 	call	0x39a	; 0x39a <InitPumpData>
}
    22c6:	0f 91       	pop	r16
    22c8:	ef 90       	pop	r14
    22ca:	08 95       	ret

000022cc <SystemInit>:
	      break;	 
	 }
}

void SystemInit(){
	PORTA=0xFF;	DDRA=0xFF;
    22cc:	9f ef       	ldi	r25, 0xFF	; 255
    22ce:	9b bb       	out	0x1b, r25	; 27
    22d0:	9a bb       	out	0x1a, r25	; 26
	PORTE=0xFF;	DDRE=0xFF;
    22d2:	97 b9       	out	0x07, r25	; 7
    22d4:	96 b9       	out	0x06, r25	; 6
	DDRB= 0b01001111;//SPI Slave Input Pin-->SCK,MOSI
    22d6:	8f e4       	ldi	r24, 0x4F	; 79
    22d8:	87 bb       	out	0x17, r24	; 23
	PORTB=0b11111111;
    22da:	98 bb       	out	0x18, r25	; 24
	DDRD=0x00;PORTD=0b11111111;
    22dc:	11 ba       	out	0x11, r1	; 17
    22de:	92 bb       	out	0x12, r25	; 18
	//Slave 128_SS_High
    sbi(DDRD,2);sbi(PORTD,2);
    22e0:	8a 9a       	sbi	0x11, 2	; 17
    22e2:	92 9a       	sbi	0x12, 2	; 18
	_spi_init(0,1);
    22e4:	80 e0       	ldi	r24, 0x00	; 0
    22e6:	61 e0       	ldi	r22, 0x01	; 1
    22e8:	0e 94 93 13 	call	0x2726	; 0x2726 <_spi_init>
     sei();
	 */
}

void InitSystemTimer(){
	TCCR0 |= (1 << CS02) | (1 << CS00);
    22ec:	83 b7       	in	r24, 0x33	; 51
    22ee:	85 60       	ori	r24, 0x05	; 5
    22f0:	83 bf       	out	0x33, r24	; 51
	TIMSK |= _BV(TOIE0);
    22f2:	89 b7       	in	r24, 0x39	; 57
    22f4:	82 60       	ori	r24, 0x02	; 2
    22f6:	89 bf       	out	0x39, r24	; 57
	DDRD=0x00;PORTD=0b11111111;
	//Slave 128_SS_High
    sbi(DDRD,2);sbi(PORTD,2);
	_spi_init(0,1);
	InitSystemTimer();
	sei();
    22f8:	78 94       	sei
	_uart_init(1,GetBaudrate(eeprom_read_byte(&DefBaudrate[1])));
    22fa:	86 e0       	ldi	r24, 0x06	; 6
    22fc:	90 e0       	ldi	r25, 0x00	; 0
    22fe:	0e 94 2a 17 	call	0x2e54	; 0x2e54 <__eerd_byte_m162>
    2302:	0e 94 4b 01 	call	0x296	; 0x296 <GetBaudrate>
    2306:	ac 01       	movw	r20, r24
    2308:	66 27       	eor	r22, r22
    230a:	57 fd       	sbrc	r21, 7
    230c:	60 95       	com	r22
    230e:	76 2f       	mov	r23, r22
    2310:	81 e0       	ldi	r24, 0x01	; 1
    2312:	0e 94 53 14 	call	0x28a6	; 0x28a6 <_uart_init>
    IFType=eeprom_read_byte(&DefIFType);
    2316:	80 e0       	ldi	r24, 0x00	; 0
    2318:	90 e0       	ldi	r25, 0x00	; 0
    231a:	0e 94 2a 17 	call	0x2e54	; 0x2e54 <__eerd_byte_m162>
    231e:	80 93 00 01 	sts	0x0100, r24
    SequenceTimeout=eeprom_read_byte(&DefSequenceTimeout);
    2322:	8c e0       	ldi	r24, 0x0C	; 12
    2324:	90 e0       	ldi	r25, 0x00	; 0
    2326:	0e 94 2a 17 	call	0x2e54	; 0x2e54 <__eerd_byte_m162>
    232a:	80 93 36 04 	sts	0x0436, r24
	MaxPumpScanned=eeprom_read_byte(&DefPumpMaxCount);		
    232e:	83 e0       	ldi	r24, 0x03	; 3
    2330:	90 e0       	ldi	r25, 0x00	; 0
    2332:	0e 94 2a 17 	call	0x2e54	; 0x2e54 <__eerd_byte_m162>
    2336:	80 93 25 01 	sts	0x0125, r24

	switch(IFType){
    233a:	80 91 00 01 	lds	r24, 0x0100
    233e:	81 30       	cpi	r24, 0x01	; 1
    2340:	19 f0       	breq	.+6      	; 0x2348 <SystemInit+0x7c>
    2342:	82 30       	cpi	r24, 0x02	; 2
    2344:	a1 f4       	brne	.+40     	; 0x236e <SystemInit+0xa2>
    2346:	06 c0       	rjmp	.+12     	; 0x2354 <SystemInit+0x88>
	case IT_SLAVE:
	     BlinkRate=20;
    2348:	84 e1       	ldi	r24, 0x14	; 20
    234a:	80 93 11 04 	sts	0x0411, r24
	     SystemSetSlave();
    234e:	0e 94 ef 10 	call	0x21de	; 0x21de <SystemSetSlave>
    2352:	0d c0       	rjmp	.+26     	; 0x236e <SystemInit+0xa2>
	     break;
	case IT_STANDALONE:
	     BlinkRate=5;
    2354:	85 e0       	ldi	r24, 0x05	; 5
    2356:	80 93 11 04 	sts	0x0411, r24
		 StandaloneType=eeprom_read_byte(&DefStandaloneType);
    235a:	81 e0       	ldi	r24, 0x01	; 1
    235c:	90 e0       	ldi	r25, 0x00	; 0
    235e:	0e 94 2a 17 	call	0x2e54	; 0x2e54 <__eerd_byte_m162>
    2362:	80 93 01 01 	sts	0x0101, r24
         SystemSetDispenser(StandaloneType);
    2366:	80 91 01 01 	lds	r24, 0x0101
    236a:	0e 94 01 11 	call	0x2202	; 0x2202 <SystemSetDispenser>
	     break;	
	}
	InitPumpData();
    236e:	0e 94 cd 01 	call	0x39a	; 0x39a <InitPumpData>
	IsStopPoolSequence=False;
    2372:	10 92 13 01 	sts	0x0113, r1
	 }Dest[Length]=0;
}


void StartupInfo(){
    _uart_printf(1,1,PSTR("Initialized"));
    2376:	81 e0       	ldi	r24, 0x01	; 1
    2378:	61 e0       	ldi	r22, 0x01	; 1
    237a:	4c e2       	ldi	r20, 0x2C	; 44
    237c:	51 e0       	ldi	r21, 0x01	; 1
    237e:	0e 94 be 14 	call	0x297c	; 0x297c <_uart_printf>
	     break;	
	}
	InitPumpData();
	IsStopPoolSequence=False;
	StartupInfo();
	System485(DIR_RX);//ReceiveMode
    2382:	82 e0       	ldi	r24, 0x02	; 2
    2384:	0e 94 9c 01 	call	0x338	; 0x338 <System485>
}
    2388:	08 95       	ret

0000238a <main>:
	    _uart(0,1,dataSPI);
	 ScanStandaloneFlow(dataSPI);	 
}

void main (){
	SystemInit();
    238a:	0e 94 66 11 	call	0x22cc	; 0x22cc <SystemInit>
 //  SystemComLevel(CL_TTL);
 //  _uart_init(0,4800);

	while(1){	   
	
	   switch(IFType){
    238e:	80 91 00 01 	lds	r24, 0x0100
    2392:	82 30       	cpi	r24, 0x02	; 2
    2394:	e1 f7       	brne	.-8      	; 0x238e <main+0x4>
	   case IT_SLAVE:
	        break;
	   case IT_STANDALONE:
	        systemAntiFreeze();//15714 15724			
    2396:	0e 94 6c 01 	call	0x2d8	; 0x2d8 <systemAntiFreeze>
			switch(StandaloneType){
    239a:	80 91 01 01 	lds	r24, 0x0101
    239e:	81 30       	cpi	r24, 0x01	; 1
    23a0:	19 f0       	breq	.+6      	; 0x23a8 <main+0x1e>
    23a2:	82 30       	cpi	r24, 0x02	; 2
    23a4:	a1 f7       	brne	.-24     	; 0x238e <main+0x4>
    23a6:	03 c0       	rjmp	.+6      	; 0x23ae <main+0x24>
			case ST_GILBARCO:
			     FPoolingPump();
    23a8:	0e 94 95 0a 	call	0x152a	; 0x152a <FPoolingPump>
    23ac:	f0 cf       	rjmp	.-32     	; 0x238e <main+0x4>
			     break;
            case ST_WAYNE_DART:
                 FPoolingPump2(); 
    23ae:	0e 94 99 0d 	call	0x1b32	; 0x1b32 <FPoolingPump2>
    23b2:	ed cf       	rjmp	.-38     	; 0x238e <main+0x4>

000023b4 <ScanStandaloneFlow>:
     	  break;	 
	 }
   return Result;
}

void ScanStandaloneFlow(char xData){//<STX>[CMD][MSG]<ETX>: 0x05 0x06
    23b4:	bf 92       	push	r11
    23b6:	cf 92       	push	r12
    23b8:	df 92       	push	r13
    23ba:	ef 92       	push	r14
    23bc:	ff 92       	push	r15
    23be:	0f 93       	push	r16
    23c0:	df 93       	push	r29
    23c2:	cf 93       	push	r28
    23c4:	cd b7       	in	r28, 0x3d	; 61
    23c6:	de b7       	in	r29, 0x3e	; 62
    23c8:	68 97       	sbiw	r28, 0x18	; 24
    23ca:	0f b6       	in	r0, 0x3f	; 63
    23cc:	f8 94       	cli
    23ce:	de bf       	out	0x3e, r29	; 62
    23d0:	0f be       	out	0x3f, r0	; 63
    23d2:	cd bf       	out	0x3d, r28	; 61
     char slaveCmd,slaveMsg;        //            0x02:STANDALONE  		 0x00:NONE 0x01:GILBARCO 0x02:TATSUNO 0x03:LG 0x04:WYNE
     char ComPort,ComBaud,i;          //          0x03:DIAGNOSTIC
	 unsigned int brValue;
	 char strSend[20];
     slaveCmd=0;slaveMsg=0;         //            0x04:Totalizer
	 zFlowData[3]=zFlowData[2];     //            0x05:Baudrate
    23d4:	90 91 38 01 	lds	r25, 0x0138
    23d8:	90 93 39 01 	sts	0x0139, r25
	 zFlowData[2]=zFlowData[1];     //            0x06:DebugTerminal:-->dtOn/dtOff
    23dc:	b0 90 37 01 	lds	r11, 0x0137
    23e0:	b0 92 38 01 	sts	0x0138, r11
	 zFlowData[1]=zFlowData[0];
    23e4:	00 91 36 01 	lds	r16, 0x0136
    23e8:	00 93 37 01 	sts	0x0137, r16
	 zFlowData[0]=xData;
    23ec:	80 93 36 01 	sts	0x0136, r24
	 //Scan SatndaloneMode Switch Command
	 if((zFlowData[0]==0x06)&(zFlowData[3]==0x05)){
    23f0:	86 30       	cpi	r24, 0x06	; 6
    23f2:	09 f0       	breq	.+2      	; 0x23f6 <ScanStandaloneFlow+0x42>
    23f4:	58 c1       	rjmp	.+688    	; 0x26a6 <ScanStandaloneFlow+0x2f2>
    23f6:	95 30       	cpi	r25, 0x05	; 5
    23f8:	09 f0       	breq	.+2      	; 0x23fc <ScanStandaloneFlow+0x48>
    23fa:	55 c1       	rjmp	.+682    	; 0x26a6 <ScanStandaloneFlow+0x2f2>
         slaveCmd=zFlowData[2];
         slaveMsg=zFlowData[1];

		 switch(slaveCmd){
    23fc:	8b 2d       	mov	r24, r11
    23fe:	90 e0       	ldi	r25, 0x00	; 0
    2400:	fc 01       	movw	r30, r24
    2402:	31 97       	sbiw	r30, 0x01	; 1
    2404:	e1 32       	cpi	r30, 0x21	; 33
    2406:	f1 05       	cpc	r31, r1
    2408:	08 f0       	brcs	.+2      	; 0x240c <ScanStandaloneFlow+0x58>
    240a:	49 c1       	rjmp	.+658    	; 0x269e <ScanStandaloneFlow+0x2ea>
    240c:	eb 58       	subi	r30, 0x8B	; 139
    240e:	ff 4f       	sbci	r31, 0xFF	; 255
    2410:	ee 0f       	add	r30, r30
    2412:	ff 1f       	adc	r31, r31
    2414:	05 90       	lpm	r0, Z+
    2416:	f4 91       	lpm	r31, Z+
    2418:	e0 2d       	mov	r30, r0
    241a:	09 94       	ijmp
		 case SC_SLAVE:		      
		      IFType=IT_SLAVE;
    241c:	81 e0       	ldi	r24, 0x01	; 1
    241e:	80 93 00 01 	sts	0x0100, r24
			  BlinkRate=20;
    2422:	84 e1       	ldi	r24, 0x14	; 20
    2424:	80 93 11 04 	sts	0x0411, r24
			  eeprom_write_byte(&DefIFType,IFType);
    2428:	60 91 00 01 	lds	r22, 0x0100
    242c:	80 e0       	ldi	r24, 0x00	; 0
    242e:	90 e0       	ldi	r25, 0x00	; 0
    2430:	0e 94 32 17 	call	0x2e64	; 0x2e64 <__eewr_byte_m162>
			  #ifdef DEBUG_CMD_TERM 
			  TerminalSendf(1,PSTR("Slave"));		
			  #endif
			  SystemSetSlave();			  		 
    2434:	0e 94 ef 10 	call	0x21de	; 0x21de <SystemSetSlave>
    2438:	32 c1       	rjmp	.+612    	; 0x269e <ScanStandaloneFlow+0x2ea>
		      break;
         case SC_STANDALONE:
		      InitPumpData();		      
    243a:	0e 94 cd 01 	call	0x39a	; 0x39a <InitPumpData>
		      IFType=IT_STANDALONE;
    243e:	82 e0       	ldi	r24, 0x02	; 2
    2440:	80 93 00 01 	sts	0x0100, r24
			  BlinkRate=5;
    2444:	85 e0       	ldi	r24, 0x05	; 5
    2446:	80 93 11 04 	sts	0x0411, r24
			  eeprom_write_byte(&DefIFType,IFType);
    244a:	60 91 00 01 	lds	r22, 0x0100
    244e:	80 e0       	ldi	r24, 0x00	; 0
    2450:	90 e0       	ldi	r25, 0x00	; 0
    2452:	0e 94 32 17 	call	0x2e64	; 0x2e64 <__eewr_byte_m162>
			  #ifdef DEBUG_CMD_TERM 
			  TerminalSendf(1,PSTR("Standalone"));
			  #endif
			  StandaloneType=eeprom_read_byte(&DefStandaloneType);
    2456:	81 e0       	ldi	r24, 0x01	; 1
    2458:	90 e0       	ldi	r25, 0x00	; 0
    245a:	0e 94 2a 17 	call	0x2e54	; 0x2e54 <__eerd_byte_m162>
    245e:	80 93 01 01 	sts	0x0101, r24
              //StandaloneType=ST_WAYNE_DART;
              SystemSetDispenser(StandaloneType);
    2462:	80 91 01 01 	lds	r24, 0x0101
    2466:	31 c0       	rjmp	.+98     	; 0x24ca <ScanStandaloneFlow+0x116>
			  //_uart_init(0,GetBaudrate(eeprom_read_byte(&DefBaudrate[0])));
			  //if (slaveMsg<=0x04)StandaloneType=slaveMsg;

		      break;
         case SC_SET_PUMP_TYPE:
		      IFType=IT_STANDALONE;
    2468:	82 e0       	ldi	r24, 0x02	; 2
    246a:	80 93 00 01 	sts	0x0100, r24
			  BlinkRate=5;
    246e:	85 e0       	ldi	r24, 0x05	; 5
    2470:	80 93 11 04 	sts	0x0411, r24
              StandaloneType=slaveMsg;
    2474:	00 93 01 01 	sts	0x0101, r16
		      eeprom_write_byte(&DefStandaloneType,StandaloneType);			  		      
    2478:	60 91 01 01 	lds	r22, 0x0101
    247c:	81 e0       	ldi	r24, 0x01	; 1
    247e:	90 e0       	ldi	r25, 0x00	; 0
    2480:	0e 94 32 17 	call	0x2e64	; 0x2e64 <__eewr_byte_m162>
			  sprintf_P(strSend,PSTR("Pump:%d"),StandaloneType);
    2484:	20 91 01 01 	lds	r18, 0x0101
    2488:	00 d0       	rcall	.+0      	; 0x248a <ScanStandaloneFlow+0xd6>
    248a:	00 d0       	rcall	.+0      	; 0x248c <ScanStandaloneFlow+0xd8>
    248c:	00 d0       	rcall	.+0      	; 0x248e <ScanStandaloneFlow+0xda>
    248e:	ed b7       	in	r30, 0x3d	; 61
    2490:	fe b7       	in	r31, 0x3e	; 62
    2492:	31 96       	adiw	r30, 0x01	; 1
    2494:	ce 01       	movw	r24, r28
    2496:	01 96       	adiw	r24, 0x01	; 1
    2498:	ad b7       	in	r26, 0x3d	; 61
    249a:	be b7       	in	r27, 0x3e	; 62
    249c:	12 96       	adiw	r26, 0x02	; 2
    249e:	9c 93       	st	X, r25
    24a0:	8e 93       	st	-X, r24
    24a2:	11 97       	sbiw	r26, 0x01	; 1
    24a4:	8f e8       	ldi	r24, 0x8F	; 143
    24a6:	91 e0       	ldi	r25, 0x01	; 1
    24a8:	93 83       	std	Z+3, r25	; 0x03
    24aa:	82 83       	std	Z+2, r24	; 0x02
    24ac:	24 83       	std	Z+4, r18	; 0x04
    24ae:	15 82       	std	Z+5, r1	; 0x05
    24b0:	0e 94 29 15 	call	0x2a52	; 0x2a52 <sprintf_P>
              SystemSetDispenser(StandaloneType);
    24b4:	80 91 01 01 	lds	r24, 0x0101
    24b8:	2d b7       	in	r18, 0x3d	; 61
    24ba:	3e b7       	in	r19, 0x3e	; 62
    24bc:	2a 5f       	subi	r18, 0xFA	; 250
    24be:	3f 4f       	sbci	r19, 0xFF	; 255
    24c0:	0f b6       	in	r0, 0x3f	; 63
    24c2:	f8 94       	cli
    24c4:	3e bf       	out	0x3e, r19	; 62
    24c6:	0f be       	out	0x3f, r0	; 63
    24c8:	2d bf       	out	0x3d, r18	; 61
    24ca:	0e 94 01 11 	call	0x2202	; 0x2202 <SystemSetDispenser>
    24ce:	9a c0       	rjmp	.+308    	; 0x2604 <ScanStandaloneFlow+0x250>
		      break;
         case SC_TOTALIZER:
		      #ifdef DEBUG_CMD_TERM 
		      _uart_printf(1,1,PSTR("SC_TOTALIZER"));
			  #endif
		      if ((slaveMsg>=1)&&(slaveMsg<=16)){
    24d0:	80 2f       	mov	r24, r16
    24d2:	81 50       	subi	r24, 0x01	; 1
    24d4:	80 31       	cpi	r24, 0x10	; 16
    24d6:	38 f4       	brcc	.+14     	; 0x24e6 <ScanStandaloneFlow+0x132>
		           IsRequestTotalizerInfo[(slaveMsg&0x0F)]=True;
    24d8:	e0 2f       	mov	r30, r16
    24da:	f0 e0       	ldi	r31, 0x00	; 0
    24dc:	ef 70       	andi	r30, 0x0F	; 15
    24de:	f0 70       	andi	r31, 0x00	; 0
    24e0:	ed 5e       	subi	r30, 0xED	; 237
    24e2:	fb 4f       	sbci	r31, 0xFB	; 251
    24e4:	56 c0       	rjmp	.+172    	; 0x2592 <ScanStandaloneFlow+0x1de>
				  }
			  else if (slaveMsg==PUMP_ALL){
    24e6:	02 31       	cpi	r16, 0x12	; 18
    24e8:	09 f0       	breq	.+2      	; 0x24ec <ScanStandaloneFlow+0x138>
    24ea:	d9 c0       	rjmp	.+434    	; 0x269e <ScanStandaloneFlow+0x2ea>
    24ec:	81 e0       	ldi	r24, 0x01	; 1
    24ee:	90 e0       	ldi	r25, 0x00	; 0
		           #ifdef DEBUG_CMD_TERM 
				   _uart_printf(1,1,PSTR("PUMPALL"));
				   #endif
				   for (i=1;i<=16;i++)IsRequestTotalizerInfo[(i&0x0F)]=True;
    24f0:	21 e0       	ldi	r18, 0x01	; 1
    24f2:	fc 01       	movw	r30, r24
    24f4:	ef 70       	andi	r30, 0x0F	; 15
    24f6:	f0 70       	andi	r31, 0x00	; 0
    24f8:	ed 5e       	subi	r30, 0xED	; 237
    24fa:	fb 4f       	sbci	r31, 0xFB	; 251
    24fc:	20 83       	st	Z, r18
    24fe:	01 96       	adiw	r24, 0x01	; 1
    2500:	81 31       	cpi	r24, 0x11	; 17
    2502:	91 05       	cpc	r25, r1
    2504:	b1 f7       	brne	.-20     	; 0x24f2 <ScanStandaloneFlow+0x13e>
    2506:	cb c0       	rjmp	.+406    	; 0x269e <ScanStandaloneFlow+0x2ea>
				  }				  	     
		      break; 
         case SC_BAUDRATE:
		      ComPort=(slaveMsg>>4)-3;//3..4
    2508:	d0 2e       	mov	r13, r16
    250a:	d2 94       	swap	r13
    250c:	5f e0       	ldi	r21, 0x0F	; 15
    250e:	d5 22       	and	r13, r21
    2510:	3d ef       	ldi	r19, 0xFD	; 253
    2512:	d3 0e       	add	r13, r19
			  ComBaud=(slaveMsg&0x0F);//0,1,2,3
    2514:	4f e0       	ldi	r20, 0x0F	; 15
    2516:	c4 2e       	mov	r12, r20
    2518:	c0 22       	and	r12, r16
			  brValue=GetBaudrate(ComBaud);
    251a:	8c 2d       	mov	r24, r12
    251c:	0e 94 4b 01 	call	0x296	; 0x296 <GetBaudrate>
    2520:	7c 01       	movw	r14, r24
			  eeprom_write_byte(&DefBaudrate[ComPort],ComBaud);
    2522:	8d 2d       	mov	r24, r13
    2524:	90 e0       	ldi	r25, 0x00	; 0
    2526:	8b 5f       	subi	r24, 0xFB	; 251
    2528:	9f 4f       	sbci	r25, 0xFF	; 255
    252a:	6c 2d       	mov	r22, r12
    252c:	0e 94 32 17 	call	0x2e64	; 0x2e64 <__eewr_byte_m162>
			  #ifdef DEBUG_CMD_TERM 
 			  sprintf_P(strSend,PSTR("COM:%d,%i"),ComPort,brValue);
			  TerminalSend(1,strSend);
			  #endif
			  _uart_init(ComPort,brValue);
    2530:	c7 01       	movw	r24, r14
    2532:	a0 e0       	ldi	r26, 0x00	; 0
    2534:	b0 e0       	ldi	r27, 0x00	; 0
    2536:	8d 8b       	std	Y+21, r24	; 0x15
    2538:	9e 8b       	std	Y+22, r25	; 0x16
    253a:	af 8b       	std	Y+23, r26	; 0x17
    253c:	b8 8f       	std	Y+24, r27	; 0x18
    253e:	8d 2d       	mov	r24, r13
    2540:	4d 89       	ldd	r20, Y+21	; 0x15
    2542:	5e 89       	ldd	r21, Y+22	; 0x16
    2544:	6f 89       	ldd	r22, Y+23	; 0x17
    2546:	78 8d       	ldd	r23, Y+24	; 0x18
    2548:	0e 94 53 14 	call	0x28a6	; 0x28a6 <_uart_init>
    254c:	a8 c0       	rjmp	.+336    	; 0x269e <ScanStandaloneFlow+0x2ea>
		      break;
		 case SC_TRANSACTION:
		          if (slaveMsg<=16)IsRequestTransInfo[slaveMsg&0x0F]=True;
    254e:	01 31       	cpi	r16, 0x11	; 17
    2550:	38 f4       	brcc	.+14     	; 0x2560 <ScanStandaloneFlow+0x1ac>
    2552:	e0 2f       	mov	r30, r16
    2554:	f0 e0       	ldi	r31, 0x00	; 0
    2556:	ef 70       	andi	r30, 0x0F	; 15
    2558:	f0 70       	andi	r31, 0x00	; 0
    255a:	e6 57       	subi	r30, 0x76	; 118
    255c:	fd 4f       	sbci	r31, 0xFD	; 253
    255e:	19 c0       	rjmp	.+50     	; 0x2592 <ScanStandaloneFlow+0x1de>
				  else 
				  if (slaveMsg==PUMP_ALL){
    2560:	02 31       	cpi	r16, 0x12	; 18
    2562:	09 f0       	breq	.+2      	; 0x2566 <ScanStandaloneFlow+0x1b2>
    2564:	9c c0       	rjmp	.+312    	; 0x269e <ScanStandaloneFlow+0x2ea>
    2566:	81 e0       	ldi	r24, 0x01	; 1
    2568:	90 e0       	ldi	r25, 0x00	; 0
				      for(i=1;i<=16;i++){
					      IsRequestTransInfo[i&0x0F]=True;
    256a:	21 e0       	ldi	r18, 0x01	; 1
    256c:	fc 01       	movw	r30, r24
    256e:	ef 70       	andi	r30, 0x0F	; 15
    2570:	f0 70       	andi	r31, 0x00	; 0
    2572:	e6 57       	subi	r30, 0x76	; 118
    2574:	fd 4f       	sbci	r31, 0xFD	; 253
    2576:	20 83       	st	Z, r18
    2578:	01 96       	adiw	r24, 0x01	; 1
		      break;
		 case SC_TRANSACTION:
		          if (slaveMsg<=16)IsRequestTransInfo[slaveMsg&0x0F]=True;
				  else 
				  if (slaveMsg==PUMP_ALL){
				      for(i=1;i<=16;i++){
    257a:	81 31       	cpi	r24, 0x11	; 17
    257c:	91 05       	cpc	r25, r1
    257e:	b1 f7       	brne	.-20     	; 0x256c <ScanStandaloneFlow+0x1b8>
    2580:	8e c0       	rjmp	.+284    	; 0x269e <ScanStandaloneFlow+0x2ea>
				 sprintf_P(strSend,PSTR("ReqTrans:%d"),slaveMsg);
				 TerminalSend(1,strSend);
              #endif
		      break;     
         case SC_PUMP_LOCK:
		          if (slaveMsg<=16)PumpLock[slaveMsg&0x0F]=True;
    2582:	01 31       	cpi	r16, 0x11	; 17
    2584:	48 f4       	brcc	.+18     	; 0x2598 <ScanStandaloneFlow+0x1e4>
    2586:	e0 2f       	mov	r30, r16
    2588:	f0 e0       	ldi	r31, 0x00	; 0
    258a:	ef 70       	andi	r30, 0x0F	; 15
    258c:	f0 70       	andi	r31, 0x00	; 0
    258e:	e4 53       	subi	r30, 0x34	; 52
    2590:	fd 4f       	sbci	r31, 0xFD	; 253
    2592:	81 e0       	ldi	r24, 0x01	; 1
    2594:	80 83       	st	Z, r24
    2596:	83 c0       	rjmp	.+262    	; 0x269e <ScanStandaloneFlow+0x2ea>
				  else 
				  if (slaveMsg==PUMP_ALL){
    2598:	02 31       	cpi	r16, 0x12	; 18
    259a:	09 f0       	breq	.+2      	; 0x259e <ScanStandaloneFlow+0x1ea>
    259c:	80 c0       	rjmp	.+256    	; 0x269e <ScanStandaloneFlow+0x2ea>
    259e:	81 e0       	ldi	r24, 0x01	; 1
    25a0:	90 e0       	ldi	r25, 0x00	; 0
				      for(i=1;i<=16;i++){
					      PumpLock[i&0x0F]=True;
    25a2:	21 e0       	ldi	r18, 0x01	; 1
    25a4:	fc 01       	movw	r30, r24
    25a6:	ef 70       	andi	r30, 0x0F	; 15
    25a8:	f0 70       	andi	r31, 0x00	; 0
    25aa:	e4 53       	subi	r30, 0x34	; 52
    25ac:	fd 4f       	sbci	r31, 0xFD	; 253
    25ae:	20 83       	st	Z, r18
    25b0:	01 96       	adiw	r24, 0x01	; 1
		      break;     
         case SC_PUMP_LOCK:
		          if (slaveMsg<=16)PumpLock[slaveMsg&0x0F]=True;
				  else 
				  if (slaveMsg==PUMP_ALL){
				      for(i=1;i<=16;i++){
    25b2:	81 31       	cpi	r24, 0x11	; 17
    25b4:	91 05       	cpc	r25, r1
    25b6:	b1 f7       	brne	.-20     	; 0x25a4 <ScanStandaloneFlow+0x1f0>
    25b8:	72 c0       	rjmp	.+228    	; 0x269e <ScanStandaloneFlow+0x2ea>
				 sprintf_P(strSend,PSTR("PumpLock:%d"),slaveMsg);
				 TerminalSend(1,strSend);
              #endif
		      break;
         case SC_PUMP_UNLOCK:
		          if (slaveMsg<=16)PumpLock[slaveMsg&0x0F]=False;
    25ba:	01 31       	cpi	r16, 0x11	; 17
    25bc:	40 f4       	brcc	.+16     	; 0x25ce <ScanStandaloneFlow+0x21a>
    25be:	e0 2f       	mov	r30, r16
    25c0:	f0 e0       	ldi	r31, 0x00	; 0
    25c2:	ef 70       	andi	r30, 0x0F	; 15
    25c4:	f0 70       	andi	r31, 0x00	; 0
    25c6:	e4 53       	subi	r30, 0x34	; 52
    25c8:	fd 4f       	sbci	r31, 0xFD	; 253
    25ca:	10 82       	st	Z, r1
    25cc:	68 c0       	rjmp	.+208    	; 0x269e <ScanStandaloneFlow+0x2ea>
			   	  else 
			   	  if (slaveMsg==PUMP_ALL){
    25ce:	02 31       	cpi	r16, 0x12	; 18
    25d0:	09 f0       	breq	.+2      	; 0x25d4 <ScanStandaloneFlow+0x220>
    25d2:	65 c0       	rjmp	.+202    	; 0x269e <ScanStandaloneFlow+0x2ea>
    25d4:	81 e0       	ldi	r24, 0x01	; 1
    25d6:	90 e0       	ldi	r25, 0x00	; 0
			   	      for(i=1;i<=16;i++){
			   		      PumpLock[i&0x0F]=False;
    25d8:	fc 01       	movw	r30, r24
    25da:	ef 70       	andi	r30, 0x0F	; 15
    25dc:	f0 70       	andi	r31, 0x00	; 0
    25de:	e4 53       	subi	r30, 0x34	; 52
    25e0:	fd 4f       	sbci	r31, 0xFD	; 253
    25e2:	10 82       	st	Z, r1
    25e4:	01 96       	adiw	r24, 0x01	; 1
		      break;
         case SC_PUMP_UNLOCK:
		          if (slaveMsg<=16)PumpLock[slaveMsg&0x0F]=False;
			   	  else 
			   	  if (slaveMsg==PUMP_ALL){
			   	      for(i=1;i<=16;i++){
    25e6:	81 31       	cpi	r24, 0x11	; 17
    25e8:	91 05       	cpc	r25, r1
    25ea:	b1 f7       	brne	.-20     	; 0x25d8 <ScanStandaloneFlow+0x224>
    25ec:	58 c0       	rjmp	.+176    	; 0x269e <ScanStandaloneFlow+0x2ea>
			   	 sprintf_P(strSend,PSTR("PumpUnLock:%d"),slaveMsg);
				 TerminalSend(1,strSend);			 
               #endif
		       break;
          case SC_TOTALIZER_ACK:
		       IsTotalizerACK=True;
    25ee:	81 e0       	ldi	r24, 0x01	; 1
    25f0:	80 93 14 01 	sts	0x0114, r24
			   PumpAck=slaveMsg;
    25f4:	00 93 df 02 	sts	0x02DF, r16
    25f8:	52 c0       	rjmp	.+164    	; 0x269e <ScanStandaloneFlow+0x2ea>
		  case SC_SET_POOLING_NO_PUMP_COUNT:
		       #ifdef DEBUG_CMD_TERM 
			   sprintf_P(strSend,PSTR("NoPumpCount:%d"),slaveMsg);
			   TerminalSend(1,strSend);			 
			   #endif
		       eeprom_write_byte(&DefNoPumpCountMax,slaveMsg);
    25fa:	88 e0       	ldi	r24, 0x08	; 8
    25fc:	90 e0       	ldi	r25, 0x00	; 0
    25fe:	60 2f       	mov	r22, r16
    2600:	0e 94 32 17 	call	0x2e64	; 0x2e64 <__eewr_byte_m162>
			   IsRestartPooling=True;
    2604:	81 e0       	ldi	r24, 0x01	; 1
    2606:	80 93 03 01 	sts	0x0103, r24
    260a:	49 c0       	rjmp	.+146    	; 0x269e <ScanStandaloneFlow+0x2ea>
		  case SC_SET_POOLING_MAX_PUMP:
		       #ifdef DEBUG_CMD_TERM 
			   sprintf_P(strSend,PSTR("MaxPump:%d"),slaveMsg);
			   TerminalSend(1,strSend);			 
			   #endif
		       eeprom_write_byte(&DefMaxPumpPooling,slaveMsg);
    260c:	87 e0       	ldi	r24, 0x07	; 7
    260e:	90 e0       	ldi	r25, 0x00	; 0
    2610:	f6 cf       	rjmp	.-20     	; 0x25fe <ScanStandaloneFlow+0x24a>
		  case SC_SET_POOLING_SEND:		      
		       #ifdef DEBUG_CMD_TERM 
			   sprintf_P(strSend,PSTR("PoolTrySend:%d"),slaveMsg);
			   TerminalSend(1,strSend);			 		        
			   #endif
		       eeprom_write_byte(&DefSendCount,slaveMsg);
    2612:	89 e0       	ldi	r24, 0x09	; 9
    2614:	90 e0       	ldi	r25, 0x00	; 0
    2616:	f3 cf       	rjmp	.-26     	; 0x25fe <ScanStandaloneFlow+0x24a>
          case SC_SET_POOLING_TIMEOUT:
		       #ifdef DEBUG_CMD_TERM 
			   sprintf_P(strSend,PSTR("PoolTimeout:%d"),slaveMsg);
			   TerminalSend(1,strSend);			 
			   #endif
		       eeprom_write_byte(&DefPoolTimeout,slaveMsg);
    2618:	8a e0       	ldi	r24, 0x0A	; 10
    261a:	90 e0       	ldi	r25, 0x00	; 0
    261c:	f0 cf       	rjmp	.-32     	; 0x25fe <ScanStandaloneFlow+0x24a>
          case SC_SET_POOLING_DELAY_NEXT_PUMP:
		       #ifdef DEBUG_CMD_TERM 
			   sprintf_P(strSend,PSTR("DelayNextPump:%d"),slaveMsg);
			   TerminalSend(1,strSend);			 
			   #endif
		       eeprom_write_byte(&DefDelayNextPump,slaveMsg);
    261e:	8b e0       	ldi	r24, 0x0B	; 11
    2620:	90 e0       	ldi	r25, 0x00	; 0
    2622:	ed cf       	rjmp	.-38     	; 0x25fe <ScanStandaloneFlow+0x24a>
			   IsRestartPooling=True;
		       break;
  		  case SC_GET_POOLING_NO_PUMP_COUNT:
		       slaveMsg=eeprom_read_byte(&DefNoPumpCountMax);
    2624:	88 e0       	ldi	r24, 0x08	; 8
    2626:	90 e0       	ldi	r25, 0x00	; 0
    2628:	0e 94 2a 17 	call	0x2e54	; 0x2e54 <__eerd_byte_m162>
    262c:	04 c0       	rjmp	.+8      	; 0x2636 <ScanStandaloneFlow+0x282>
		       break;
		  case SC_GET_POOLING_MAX_PUMP:
		       slaveMsg=eeprom_read_byte(&DefMaxPumpPooling);
    262e:	87 e0       	ldi	r24, 0x07	; 7
    2630:	90 e0       	ldi	r25, 0x00	; 0
    2632:	0e 94 2a 17 	call	0x2e54	; 0x2e54 <__eerd_byte_m162>
    2636:	08 2f       	mov	r16, r24
    2638:	32 c0       	rjmp	.+100    	; 0x269e <ScanStandaloneFlow+0x2ea>
		       break;
		  case SC_GET_POOLING_SEND:		            
		       slaveMsg=eeprom_read_byte(&DefSendCount);
    263a:	89 e0       	ldi	r24, 0x09	; 9
    263c:	90 e0       	ldi	r25, 0x00	; 0
    263e:	0e 94 2a 17 	call	0x2e54	; 0x2e54 <__eerd_byte_m162>
    2642:	f9 cf       	rjmp	.-14     	; 0x2636 <ScanStandaloneFlow+0x282>
          case SC_SEQUENCE_TIMEOUT:
		       #ifdef DEBUG_CMD_TERM 
			   sprintf_P(strSend,PSTR("PoolTrySend:%d"),slaveMsg);
			   TerminalSend(1,strSend);			 		        
			   #endif 
		       eeprom_write_byte(&DefSequenceTimeout,slaveMsg);
    2644:	8c e0       	ldi	r24, 0x0C	; 12
    2646:	90 e0       	ldi	r25, 0x00	; 0
    2648:	60 2f       	mov	r22, r16
    264a:	0e 94 32 17 	call	0x2e64	; 0x2e64 <__eewr_byte_m162>
			   SequenceTimeout=eeprom_read_byte(&DefSequenceTimeout);
    264e:	8c e0       	ldi	r24, 0x0C	; 12
    2650:	90 e0       	ldi	r25, 0x00	; 0
    2652:	0e 94 2a 17 	call	0x2e54	; 0x2e54 <__eerd_byte_m162>
    2656:	80 93 36 04 	sts	0x0436, r24
    265a:	d4 cf       	rjmp	.-88     	; 0x2604 <ScanStandaloneFlow+0x250>
			   IsRestartPooling=True;		       
		       break;
          case SC_SET_PUMPID:
		       eeprom_write_byte(&DefPumpID[slaveMsg>>4],(slaveMsg&0x0F));		       
    265c:	80 2f       	mov	r24, r16
    265e:	82 95       	swap	r24
    2660:	8f 70       	andi	r24, 0x0F	; 15
    2662:	90 e0       	ldi	r25, 0x00	; 0
    2664:	60 2f       	mov	r22, r16
    2666:	6f 70       	andi	r22, 0x0F	; 15
    2668:	83 5f       	subi	r24, 0xF3	; 243
    266a:	9f 4f       	sbci	r25, 0xFF	; 255
    266c:	c9 cf       	rjmp	.-110    	; 0x2600 <ScanStandaloneFlow+0x24c>
			   TerminalSend(1,strSend);			 		        
			   #endif
               IsRestartPooling=True;
               break; 
		  case SC_CLEAR_PUMPID:
               eeprom_write_byte(&DefPumpID[slaveMsg],0);
    266e:	80 2f       	mov	r24, r16
    2670:	90 e0       	ldi	r25, 0x00	; 0
    2672:	83 5f       	subi	r24, 0xF3	; 243
    2674:	9f 4f       	sbci	r25, 0xFF	; 255
    2676:	60 e0       	ldi	r22, 0x00	; 0
    2678:	c3 cf       	rjmp	.-122    	; 0x2600 <ScanStandaloneFlow+0x24c>
			   TerminalSend(1,strSend);			 		        
			   #endif
               IsRestartPooling=True;
		       break;
          case SC_STOP_POOL_SEQUENCE:
		       IsStopPoolSequence=True;
    267a:	81 e0       	ldi	r24, 0x01	; 1
    267c:	80 93 13 01 	sts	0x0113, r24
    2680:	0e c0       	rjmp	.+28     	; 0x269e <ScanStandaloneFlow+0x2ea>
		       break; 
          case SC_START_POOL_SEQUENCE:
		       IsStopPoolSequence=False;
    2682:	10 92 13 01 	sts	0x0113, r1
    2686:	0b c0       	rjmp	.+22     	; 0x269e <ScanStandaloneFlow+0x2ea>
		       break; 
          case SC_HGM_MODE:
		       eeprom_write_byte(&DefHGMode,slaveMsg);
    2688:	8e e1       	ldi	r24, 0x1E	; 30
    268a:	90 e0       	ldi	r25, 0x00	; 0
    268c:	60 2f       	mov	r22, r16
    268e:	0e 94 32 17 	call	0x2e64	; 0x2e64 <__eewr_byte_m162>
			   SystemComLevel(eeprom_read_byte(&DefHGMode));
    2692:	8e e1       	ldi	r24, 0x1E	; 30
    2694:	90 e0       	ldi	r25, 0x00	; 0
    2696:	0e 94 2a 17 	call	0x2e54	; 0x2e54 <__eerd_byte_m162>
    269a:	0e 94 61 01 	call	0x2c2	; 0x2c2 <SystemComLevel>
			   
		       break;
		 }
       //AcknoledgeCommand
       SendCommandAcknoledge(slaveCmd,slaveMsg);
    269e:	8b 2d       	mov	r24, r11
    26a0:	60 2f       	mov	r22, r16
    26a2:	0e 94 e0 06 	call	0xdc0	; 0xdc0 <SendCommandAcknoledge>
	 }//EndIf	 
}
    26a6:	68 96       	adiw	r28, 0x18	; 24
    26a8:	0f b6       	in	r0, 0x3f	; 63
    26aa:	f8 94       	cli
    26ac:	de bf       	out	0x3e, r29	; 62
    26ae:	0f be       	out	0x3f, r0	; 63
    26b0:	cd bf       	out	0x3d, r28	; 61
    26b2:	cf 91       	pop	r28
    26b4:	df 91       	pop	r29
    26b6:	0f 91       	pop	r16
    26b8:	ff 90       	pop	r15
    26ba:	ef 90       	pop	r14
    26bc:	df 90       	pop	r13
    26be:	cf 90       	pop	r12
    26c0:	bf 90       	pop	r11
    26c2:	08 95       	ret

000026c4 <__vector_18>:
	   
	//_uart(1,1,dataRX1);
	//OnReceive1(dataRX1);
}

ISR(SPI_STC_vect){
    26c4:	1f 92       	push	r1
    26c6:	0f 92       	push	r0
    26c8:	0f b6       	in	r0, 0x3f	; 63
    26ca:	0f 92       	push	r0
    26cc:	11 24       	eor	r1, r1
    26ce:	1f 93       	push	r17
    26d0:	2f 93       	push	r18
    26d2:	3f 93       	push	r19
    26d4:	4f 93       	push	r20
    26d6:	5f 93       	push	r21
    26d8:	6f 93       	push	r22
    26da:	7f 93       	push	r23
    26dc:	8f 93       	push	r24
    26de:	9f 93       	push	r25
    26e0:	af 93       	push	r26
    26e2:	bf 93       	push	r27
    26e4:	ef 93       	push	r30
    26e6:	ff 93       	push	r31
char dataSPI;
     dataSPI=SPDR;
    26e8:	1f b1       	in	r17, 0x0f	; 15
          ScanStandaloneFlow(dataSPI);
	      break;
	 }
	 */
	 
	 if (IFType==IT_SLAVE)//EDC Line Protocol
    26ea:	80 91 00 01 	lds	r24, 0x0100
    26ee:	81 30       	cpi	r24, 0x01	; 1
    26f0:	29 f4       	brne	.+10     	; 0x26fc <__vector_18+0x38>
	    _uart(0,1,dataSPI);
    26f2:	80 e0       	ldi	r24, 0x00	; 0
    26f4:	61 e0       	ldi	r22, 0x01	; 1
    26f6:	41 2f       	mov	r20, r17
    26f8:	0e 94 7f 14 	call	0x28fe	; 0x28fe <_uart>
	 ScanStandaloneFlow(dataSPI);	 
    26fc:	81 2f       	mov	r24, r17
    26fe:	0e 94 da 11 	call	0x23b4	; 0x23b4 <ScanStandaloneFlow>
}
    2702:	ff 91       	pop	r31
    2704:	ef 91       	pop	r30
    2706:	bf 91       	pop	r27
    2708:	af 91       	pop	r26
    270a:	9f 91       	pop	r25
    270c:	8f 91       	pop	r24
    270e:	7f 91       	pop	r23
    2710:	6f 91       	pop	r22
    2712:	5f 91       	pop	r21
    2714:	4f 91       	pop	r20
    2716:	3f 91       	pop	r19
    2718:	2f 91       	pop	r18
    271a:	1f 91       	pop	r17
    271c:	0f 90       	pop	r0
    271e:	0f be       	out	0x3f, r0	; 63
    2720:	0f 90       	pop	r0
    2722:	1f 90       	pop	r1
    2724:	18 95       	reti

00002726 <_spi_init>:
enum SPI_TYPE{SLAVE,MASTER};
enum SPI_MODE{POOLING,INTERUPT};


void _spi_init(unsigned char __mode, unsigned char __interrupt){
	if(__mode){
    2726:	88 23       	and	r24, r24
    2728:	41 f0       	breq	.+16     	; 0x273a <_spi_init+0x14>
		_SPI_DDR = (1 << _SPI_MOSI) | (1 << _SPI_SCK);
    272a:	80 ea       	ldi	r24, 0xA0	; 160
    272c:	87 bb       	out	0x17, r24	; 23
		if(__interrupt)
    272e:	66 23       	and	r22, r22
    2730:	11 f0       	breq	.+4      	; 0x2736 <_spi_init+0x10>
			SPCR = (1 << SPIE) | (1 << SPE) | (1 << MSTR) | (1 << SPR1);
    2732:	82 ed       	ldi	r24, 0xD2	; 210
    2734:	0a c0       	rjmp	.+20     	; 0x274a <_spi_init+0x24>
		else
			SPCR = (1 << SPE) | (1 << MSTR) | (1 << SPR1);
    2736:	82 e5       	ldi	r24, 0x52	; 82
    2738:	08 c0       	rjmp	.+16     	; 0x274a <_spi_init+0x24>
	}
	else{

		_SPI_DDR = (1 << _SPI_MISO);
    273a:	80 e4       	ldi	r24, 0x40	; 64
    273c:	87 bb       	out	0x17, r24	; 23
		if(__interrupt)
    273e:	66 23       	and	r22, r22
    2740:	21 f0       	breq	.+8      	; 0x274a <_spi_init+0x24>
			{SPCR = (1 << SPIE) | (1 << SPE);sei();}
    2742:	80 ec       	ldi	r24, 0xC0	; 192
    2744:	8d b9       	out	0x0d, r24	; 13
    2746:	78 94       	sei
    2748:	08 95       	ret
		else
			SPCR = (1 << SPE);
    274a:	8d b9       	out	0x0d, r24	; 13
    274c:	08 95       	ret

0000274e <_spi_enable>:
			
	}
}

void _spi_enable(unsigned char __status, unsigned char __select){
	if(__status){
    274e:	88 23       	and	r24, r24
    2750:	31 f0       	breq	.+12     	; 0x275e <_spi_enable+0x10>
		if(__select)
    2752:	66 23       	and	r22, r22
    2754:	11 f0       	breq	.+4      	; 0x275a <_spi_enable+0xc>
			cbi(_MMC_PORT, _MMC_PIN);
    2756:	3b 98       	cbi	0x07, 3	; 7
    2758:	08 95       	ret
		else
			cbi(_SLAVE_PORT, _SLAVE_PIN);
    275a:	92 98       	cbi	0x12, 2	; 18
    275c:	08 95       	ret
	}
	else{
		if(__select)
    275e:	66 23       	and	r22, r22
    2760:	11 f0       	breq	.+4      	; 0x2766 <_spi_enable+0x18>
			sbi(_MMC_PORT, _MMC_PIN);
    2762:	3b 9a       	sbi	0x07, 3	; 7
    2764:	08 95       	ret
		else
			sbi(_SLAVE_PORT, _SLAVE_PIN);
    2766:	92 9a       	sbi	0x12, 2	; 18
    2768:	08 95       	ret

0000276a <_spi>:
	}
}

unsigned char _spi(unsigned char __data){   
	SPDR = __data;
    276a:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1 << SPIF)));
    276c:	77 9b       	sbis	0x0e, 7	; 14
    276e:	fe cf       	rjmp	.-4      	; 0x276c <_spi+0x2>
	return SPDR;
    2770:	8f b1       	in	r24, 0x0f	; 15
}
    2772:	08 95       	ret

00002774 <_spi_rx>:

unsigned char _spi_rx(unsigned char __select){
//	return 1;
}
    2774:	08 95       	ret

00002776 <_spi_tx>:

unsigned char _spi_tx(unsigned char __command, unsigned char __select, char *__message){
//	_spi_enable(_SPI_ENABLE, __select);
//	_spi_enable(_SPI_DISABLE, __select);
//	return 0;
}
    2776:	08 95       	ret

00002778 <_spi_interrupt>:

unsigned char _spi_interrupt(void){
	//return 0;
}
    2778:	08 95       	ret

0000277a <_spi_command>:
	}

	__command[__i++] = 0x7D;
	__command[__i++] = '\0';
	*/
}
    277a:	08 95       	ret

0000277c <_uart_setting>:

#include "UART.h"

//_uart_setting(0,GetBaudrate(eeprom_read_byte(&DefBaudrate[0])),8,P_EVEN,1);

void _uart_setting(char Port,unsigned long Baudrate,char DataSet,char ParitySet, char StopBitSet){
    277c:	af 92       	push	r10
    277e:	bf 92       	push	r11
    2780:	cf 92       	push	r12
    2782:	df 92       	push	r13
    2784:	ef 92       	push	r14
    2786:	ff 92       	push	r15
    2788:	0f 93       	push	r16
    278a:	1f 93       	push	r17
    278c:	f8 2e       	mov	r15, r24
    278e:	5a 01       	movw	r10, r20
    2790:	6b 01       	movw	r12, r22
    2792:	12 2f       	mov	r17, r18
unsigned long BaudrateValue;
     char RegB,RegC;
	 BaudrateValue= (unsigned long)((_CPU_DEFAULT + (Baudrate* 8)) / (Baudrate* 16) - 1);
    2794:	cb 01       	movw	r24, r22
    2796:	ba 01       	movw	r22, r20
    2798:	60 50       	subi	r22, 0x00	; 0
    279a:	70 4e       	sbci	r23, 0xE0	; 224
    279c:	83 4e       	sbci	r24, 0xE3	; 227
    279e:	9f 4f       	sbci	r25, 0xFF	; 255
    27a0:	33 e0       	ldi	r19, 0x03	; 3
    27a2:	66 0f       	add	r22, r22
    27a4:	77 1f       	adc	r23, r23
    27a6:	88 1f       	adc	r24, r24
    27a8:	99 1f       	adc	r25, r25
    27aa:	3a 95       	dec	r19
    27ac:	d1 f7       	brne	.-12     	; 0x27a2 <_uart_setting+0x26>
    27ae:	24 e0       	ldi	r18, 0x04	; 4
    27b0:	aa 0c       	add	r10, r10
    27b2:	bb 1c       	adc	r11, r11
    27b4:	cc 1c       	adc	r12, r12
    27b6:	dd 1c       	adc	r13, r13
    27b8:	2a 95       	dec	r18
    27ba:	d1 f7       	brne	.-12     	; 0x27b0 <_uart_setting+0x34>
    27bc:	a6 01       	movw	r20, r12
    27be:	95 01       	movw	r18, r10
    27c0:	0e 94 07 15 	call	0x2a0e	; 0x2a0e <__udivmodsi4>
    27c4:	21 50       	subi	r18, 0x01	; 1
    27c6:	30 40       	sbci	r19, 0x00	; 0
    27c8:	40 40       	sbci	r20, 0x00	; 0
    27ca:	50 40       	sbci	r21, 0x00	; 0
     RegB=0;RegC=0;
	 RegB = (1<<RXCIE0) | (1<<RXEN0) | (1<<TXEN0);
     RegC = (1<<URSEL0);
   
     //ParitySet
	 switch(ParitySet){
    27cc:	01 30       	cpi	r16, 0x01	; 1
    27ce:	31 f0       	breq	.+12     	; 0x27dc <_uart_setting+0x60>
    27d0:	02 30       	cpi	r16, 0x02	; 2
    27d2:	11 f4       	brne	.+4      	; 0x27d8 <_uart_setting+0x5c>
    27d4:	60 ea       	ldi	r22, 0xA0	; 160
    27d6:	03 c0       	rjmp	.+6      	; 0x27de <_uart_setting+0x62>
    27d8:	60 e8       	ldi	r22, 0x80	; 128
    27da:	01 c0       	rjmp	.+2      	; 0x27de <_uart_setting+0x62>
    27dc:	60 eb       	ldi	r22, 0xB0	; 176
     case P_ODD:
	      RegC=RegC|(1<<UPM00)|(1<<UPM01);
	      break;	 
	 }
     //StopBit
      if (StopBitSet==2)
    27de:	82 e0       	ldi	r24, 0x02	; 2
    27e0:	e8 16       	cp	r14, r24
    27e2:	09 f4       	brne	.+2      	; 0x27e6 <_uart_setting+0x6a>
	      RegC=RegC|(1<<USBS0);
    27e4:	68 60       	ori	r22, 0x08	; 8

		  //DataSet
		  switch (DataSet){
    27e6:	17 30       	cpi	r17, 0x07	; 7
    27e8:	61 f0       	breq	.+24     	; 0x2802 <_uart_setting+0x86>
    27ea:	18 30       	cpi	r17, 0x08	; 8
    27ec:	18 f4       	brcc	.+6      	; 0x27f4 <_uart_setting+0x78>
    27ee:	16 30       	cpi	r17, 0x06	; 6
    27f0:	59 f4       	brne	.+22     	; 0x2808 <_uart_setting+0x8c>
    27f2:	05 c0       	rjmp	.+10     	; 0x27fe <_uart_setting+0x82>
    27f4:	18 30       	cpi	r17, 0x08	; 8
    27f6:	39 f0       	breq	.+14     	; 0x2806 <_uart_setting+0x8a>
    27f8:	19 30       	cpi	r17, 0x09	; 9
    27fa:	31 f4       	brne	.+12     	; 0x2808 <_uart_setting+0x8c>
    27fc:	07 c0       	rjmp	.+14     	; 0x280c <_uart_setting+0x90>
		  case 5:
		       break;
		  case 6:
		       RegC=RegC|(1<<UCSZ00);
    27fe:	62 60       	ori	r22, 0x02	; 2
    2800:	03 c0       	rjmp	.+6      	; 0x2808 <_uart_setting+0x8c>
		       break;
		  case 7:
		       RegC=RegC|(1<<UCSZ01);
    2802:	64 60       	ori	r22, 0x04	; 4
    2804:	01 c0       	rjmp	.+2      	; 0x2808 <_uart_setting+0x8c>
		       break;
		  case 8:
		       RegC=RegC|(1<<UCSZ00)|(1<<UCSZ01);
    2806:	66 60       	ori	r22, 0x06	; 6
    2808:	78 e9       	ldi	r23, 0x98	; 152
    280a:	02 c0       	rjmp	.+4      	; 0x2810 <_uart_setting+0x94>
		       break;
		  case 9:
               RegB=RegB| (1<<UCSZ02);
		       RegC=RegC| (1<<UCSZ00)|(1<<UCSZ01);
    280c:	66 60       	ori	r22, 0x06	; 6
    280e:	7c e9       	ldi	r23, 0x9C	; 156
		       break;
		  }

	 switch (Port){
    2810:	ff 20       	and	r15, r15
    2812:	21 f0       	breq	.+8      	; 0x281c <_uart_setting+0xa0>
    2814:	81 e0       	ldi	r24, 0x01	; 1
    2816:	f8 16       	cp	r15, r24
    2818:	91 f4       	brne	.+36     	; 0x283e <_uart_setting+0xc2>
    281a:	09 c0       	rjmp	.+18     	; 0x282e <_uart_setting+0xb2>
	 case 0:		  
		  //Write
		  //Register

	      //BaudrateSetting
          UBRR0H=BaudrateValue>>8;
    281c:	bb 27       	eor	r27, r27
    281e:	a5 2f       	mov	r26, r21
    2820:	94 2f       	mov	r25, r20
    2822:	83 2f       	mov	r24, r19
    2824:	80 bd       	out	0x20, r24	; 32
		  UBRR0L=BaudrateValue;		
    2826:	29 b9       	out	0x09, r18	; 9
		  //Register
		  UCSR0B=RegB; 
    2828:	7a b9       	out	0x0a, r23	; 10
		  UCSR0C=RegC; 
    282a:	60 bd       	out	0x20, r22	; 32
    282c:	08 c0       	rjmp	.+16     	; 0x283e <_uart_setting+0xc2>
	      break;
     case 1:
		  //Write
		  //BaudrateSetting
          UBRR1H=BaudrateValue>>8;
    282e:	bb 27       	eor	r27, r27
    2830:	a5 2f       	mov	r26, r21
    2832:	94 2f       	mov	r25, r20
    2834:	83 2f       	mov	r24, r19
    2836:	8c bf       	out	0x3c, r24	; 60
		  UBRR1L=BaudrateValue;		
    2838:	20 b9       	out	0x00, r18	; 0

		  //Register
		  UCSR1B=RegB; 
    283a:	71 b9       	out	0x01, r23	; 1
		  UCSR1C=RegC;
    283c:	6c bf       	out	0x3c, r22	; 60
	      break;
	 }  
}
    283e:	1f 91       	pop	r17
    2840:	0f 91       	pop	r16
    2842:	ff 90       	pop	r15
    2844:	ef 90       	pop	r14
    2846:	df 90       	pop	r13
    2848:	cf 90       	pop	r12
    284a:	bf 90       	pop	r11
    284c:	af 90       	pop	r10
    284e:	08 95       	ret

00002850 <_uart_baudrate>:
	    UCSR0C=(1<<URSEL0) | (1<<UPM01) | (1<<UCSZ01) | (1<<UCSZ00); // UPM01 untuk set even parity
	    UBRR0H=0;UBRR0L=158;// baud 5787       
	}
}

void _uart_baudrate(unsigned char __com, unsigned long __baudrate){
    2850:	1f 93       	push	r17
    2852:	18 2f       	mov	r17, r24
    2854:	9a 01       	movw	r18, r20
    2856:	ab 01       	movw	r20, r22
	unsigned long __br;

	__br = (unsigned long)((_CPU_DEFAULT + (__baudrate * 8)) / (__baudrate * 16) - 1);
    2858:	ca 01       	movw	r24, r20
    285a:	b9 01       	movw	r22, r18
    285c:	60 50       	subi	r22, 0x00	; 0
    285e:	70 4e       	sbci	r23, 0xE0	; 224
    2860:	83 4e       	sbci	r24, 0xE3	; 227
    2862:	9f 4f       	sbci	r25, 0xFF	; 255
    2864:	f3 e0       	ldi	r31, 0x03	; 3
    2866:	66 0f       	add	r22, r22
    2868:	77 1f       	adc	r23, r23
    286a:	88 1f       	adc	r24, r24
    286c:	99 1f       	adc	r25, r25
    286e:	fa 95       	dec	r31
    2870:	d1 f7       	brne	.-12     	; 0x2866 <_uart_baudrate+0x16>
    2872:	e4 e0       	ldi	r30, 0x04	; 4
    2874:	22 0f       	add	r18, r18
    2876:	33 1f       	adc	r19, r19
    2878:	44 1f       	adc	r20, r20
    287a:	55 1f       	adc	r21, r21
    287c:	ea 95       	dec	r30
    287e:	d1 f7       	brne	.-12     	; 0x2874 <_uart_baudrate+0x24>
    2880:	0e 94 07 15 	call	0x2a0e	; 0x2a0e <__udivmodsi4>
    2884:	21 50       	subi	r18, 0x01	; 1
    2886:	30 40       	sbci	r19, 0x00	; 0
    2888:	40 40       	sbci	r20, 0x00	; 0
    288a:	50 40       	sbci	r21, 0x00	; 0
    288c:	bb 27       	eor	r27, r27
    288e:	a5 2f       	mov	r26, r21
    2890:	94 2f       	mov	r25, r20
    2892:	83 2f       	mov	r24, r19

	if(__com){
    2894:	11 23       	and	r17, r17
    2896:	19 f0       	breq	.+6      	; 0x289e <_uart_baudrate+0x4e>
		UBRR1L = __br;
    2898:	20 b9       	out	0x00, r18	; 0
		UBRR1H = __br >> 8;
    289a:	8c bf       	out	0x3c, r24	; 60
    289c:	02 c0       	rjmp	.+4      	; 0x28a2 <_uart_baudrate+0x52>
	}
	else{
		UBRR0L = __br;
    289e:	29 b9       	out	0x09, r18	; 9
		UBRR0H = __br >> 8;
    28a0:	80 bd       	out	0x20, r24	; 32
	}
}
    28a2:	1f 91       	pop	r17
    28a4:	08 95       	ret

000028a6 <_uart_init>:
		  UCSR1C=RegC;
	      break;
	 }  
}

void _uart_init(unsigned char __com, unsigned long __baudrate){
    28a6:	ef 92       	push	r14
    28a8:	ff 92       	push	r15
    28aa:	0f 93       	push	r16
    28ac:	1f 93       	push	r17
    28ae:	98 2f       	mov	r25, r24
    28b0:	7a 01       	movw	r14, r20
    28b2:	8b 01       	movw	r16, r22
	if(__com){
    28b4:	88 23       	and	r24, r24
    28b6:	29 f0       	breq	.+10     	; 0x28c2 <_uart_init+0x1c>
		UCSR1B = _BV(RXCIE1) | _BV(RXEN1) | _BV(TXEN1);
    28b8:	88 e9       	ldi	r24, 0x98	; 152
    28ba:	81 b9       	out	0x01, r24	; 1
		UCSR1C = _BV(UCSZ11) | _BV(UCSZ10);
    28bc:	86 e0       	ldi	r24, 0x06	; 6
    28be:	8c bf       	out	0x3c, r24	; 60
    28c0:	04 c0       	rjmp	.+8      	; 0x28ca <_uart_init+0x24>
	}
	else{
		UCSR0B = _BV(RXCIE0) | _BV(RXEN0) | _BV(TXEN0);
    28c2:	88 e9       	ldi	r24, 0x98	; 152
    28c4:	8a b9       	out	0x0a, r24	; 10
		UCSR0C = _BV(UCSZ01) | _BV(UCSZ00);
    28c6:	86 e0       	ldi	r24, 0x06	; 6
    28c8:	80 bd       	out	0x20, r24	; 32
	}
    

	_uart_baudrate(__com, __baudrate);
    28ca:	89 2f       	mov	r24, r25
    28cc:	b8 01       	movw	r22, r16
    28ce:	a7 01       	movw	r20, r14
    28d0:	0e 94 28 14 	call	0x2850	; 0x2850 <_uart_baudrate>

	if (__baudrate==5787){
    28d4:	8b e9       	ldi	r24, 0x9B	; 155
    28d6:	e8 16       	cp	r14, r24
    28d8:	86 e1       	ldi	r24, 0x16	; 22
    28da:	f8 06       	cpc	r15, r24
    28dc:	80 e0       	ldi	r24, 0x00	; 0
    28de:	08 07       	cpc	r16, r24
    28e0:	80 e0       	ldi	r24, 0x00	; 0
    28e2:	18 07       	cpc	r17, r24
    28e4:	39 f4       	brne	.+14     	; 0x28f4 <_uart_init+0x4e>
	    UCSR0B=_BV(RXCIE0) | _BV(RXEN0) | _BV(TXEN0);
    28e6:	88 e9       	ldi	r24, 0x98	; 152
    28e8:	8a b9       	out	0x0a, r24	; 10
	    UCSR0C=(1<<URSEL0) | (1<<UPM01) | (1<<UCSZ01) | (1<<UCSZ00); // UPM01 untuk set even parity
    28ea:	86 ea       	ldi	r24, 0xA6	; 166
    28ec:	80 bd       	out	0x20, r24	; 32
	    UBRR0H=0;UBRR0L=158;// baud 5787       
    28ee:	10 bc       	out	0x20, r1	; 32
    28f0:	8e e9       	ldi	r24, 0x9E	; 158
    28f2:	89 b9       	out	0x09, r24	; 9
	}
}
    28f4:	1f 91       	pop	r17
    28f6:	0f 91       	pop	r16
    28f8:	ff 90       	pop	r15
    28fa:	ef 90       	pop	r14
    28fc:	08 95       	ret

000028fe <_uart>:
		UBRR0H = __br >> 8;
	}
}

unsigned char _uart(unsigned char __com, unsigned char __dir, unsigned char __chr){
	if(__com){
    28fe:	88 23       	and	r24, r24
    2900:	51 f0       	breq	.+20     	; 0x2916 <_uart+0x18>
		if(__dir){
    2902:	66 23       	and	r22, r22
    2904:	21 f0       	breq	.+8      	; 0x290e <_uart+0x10>
			loop_until_bit_is_set(UCSR1A, UDRE1);
    2906:	15 9b       	sbis	0x02, 5	; 2
    2908:	fe cf       	rjmp	.-4      	; 0x2906 <_uart+0x8>
			UDR1 = __chr;
    290a:	43 b9       	out	0x03, r20	; 3
    290c:	09 c0       	rjmp	.+18     	; 0x2920 <_uart+0x22>
		}
		else{
			loop_until_bit_is_set(UCSR1A, RXC1);
    290e:	17 9b       	sbis	0x02, 7	; 2
    2910:	fe cf       	rjmp	.-4      	; 0x290e <_uart+0x10>
			return UDR1;
    2912:	83 b1       	in	r24, 0x03	; 3
    2914:	08 95       	ret
		}
	}
	else{
		if(__dir){
    2916:	66 23       	and	r22, r22
    2918:	29 f0       	breq	.+10     	; 0x2924 <_uart+0x26>
			loop_until_bit_is_set(UCSR0A, UDRE0);
    291a:	5d 9b       	sbis	0x0b, 5	; 11
    291c:	fe cf       	rjmp	.-4      	; 0x291a <_uart+0x1c>
			UDR0 = __chr;
    291e:	4c b9       	out	0x0c, r20	; 12
    2920:	81 e0       	ldi	r24, 0x01	; 1
    2922:	08 95       	ret
		}
		else{
			loop_until_bit_is_set(UCSR0A,  RXC0);
    2924:	5f 9b       	sbis	0x0b, 7	; 11
    2926:	fe cf       	rjmp	.-4      	; 0x2924 <_uart+0x26>
			return UDR0;
    2928:	8c b1       	in	r24, 0x0c	; 12
		}

	}

	return 1;
}
    292a:	08 95       	ret

0000292c <_uart_print>:

void _uart_print(unsigned char __com, unsigned char __ret, char *__str){
    292c:	0f 93       	push	r16
    292e:	1f 93       	push	r17
    2930:	cf 93       	push	r28
    2932:	df 93       	push	r29
    2934:	18 2f       	mov	r17, r24
    2936:	06 2f       	mov	r16, r22
    2938:	ea 01       	movw	r28, r20
	if(strlen(__str)>0)
    293a:	88 81       	ld	r24, Y
    293c:	88 23       	and	r24, r24
    293e:	31 f4       	brne	.+12     	; 0x294c <_uart_print+0x20>
    2940:	08 c0       	rjmp	.+16     	; 0x2952 <_uart_print+0x26>
		while(*__str) _uart(__com, 1, *__str++);
    2942:	21 96       	adiw	r28, 0x01	; 1
    2944:	81 2f       	mov	r24, r17
    2946:	61 e0       	ldi	r22, 0x01	; 1
    2948:	0e 94 7f 14 	call	0x28fe	; 0x28fe <_uart>
    294c:	48 81       	ld	r20, Y
    294e:	44 23       	and	r20, r20
    2950:	c1 f7       	brne	.-16     	; 0x2942 <_uart_print+0x16>

	if(__ret){
    2952:	00 23       	and	r16, r16
    2954:	51 f0       	breq	.+20     	; 0x296a <_uart_print+0x3e>
		_uart(__com, 1, 0x0D);
    2956:	81 2f       	mov	r24, r17
    2958:	61 e0       	ldi	r22, 0x01	; 1
    295a:	4d e0       	ldi	r20, 0x0D	; 13
    295c:	0e 94 7f 14 	call	0x28fe	; 0x28fe <_uart>
		_uart(__com, 1, 0x0A);
    2960:	81 2f       	mov	r24, r17
    2962:	61 e0       	ldi	r22, 0x01	; 1
    2964:	4a e0       	ldi	r20, 0x0A	; 10
    2966:	0e 94 7f 14 	call	0x28fe	; 0x28fe <_uart>
    296a:	82 ee       	ldi	r24, 0xE2	; 226
    296c:	94 e0       	ldi	r25, 0x04	; 4
    296e:	01 97       	sbiw	r24, 0x01	; 1
    2970:	f1 f7       	brne	.-4      	; 0x296e <_uart_print+0x42>
	}
	_delay_ms(5);
}
    2972:	df 91       	pop	r29
    2974:	cf 91       	pop	r28
    2976:	1f 91       	pop	r17
    2978:	0f 91       	pop	r16
    297a:	08 95       	ret

0000297c <_uart_printf>:

void _uart_printf(unsigned char __com, unsigned char __ret, char *__str){
    297c:	0f 93       	push	r16
    297e:	1f 93       	push	r17
    2980:	cf 93       	push	r28
    2982:	df 93       	push	r29
    2984:	18 2f       	mov	r17, r24
    2986:	06 2f       	mov	r16, r22
    2988:	ea 01       	movw	r28, r20
    298a:	07 c0       	rjmp	.+14     	; 0x299a <_uart_printf+0x1e>
	while(pgm_read_byte(&(*__str)))
		_uart(__com, 1, pgm_read_byte(&(*__str++)));
    298c:	21 96       	adiw	r28, 0x01	; 1
    298e:	f9 01       	movw	r30, r18
    2990:	44 91       	lpm	r20, Z+
    2992:	81 2f       	mov	r24, r17
    2994:	61 e0       	ldi	r22, 0x01	; 1
    2996:	0e 94 7f 14 	call	0x28fe	; 0x28fe <_uart>
    299a:	9e 01       	movw	r18, r28
	}
	_delay_ms(5);
}

void _uart_printf(unsigned char __com, unsigned char __ret, char *__str){
	while(pgm_read_byte(&(*__str)))
    299c:	fe 01       	movw	r30, r28
    299e:	84 91       	lpm	r24, Z+
    29a0:	88 23       	and	r24, r24
    29a2:	a1 f7       	brne	.-24     	; 0x298c <_uart_printf+0x10>
		_uart(__com, 1, pgm_read_byte(&(*__str++)));

	if(__ret){
    29a4:	00 23       	and	r16, r16
    29a6:	51 f0       	breq	.+20     	; 0x29bc <_uart_printf+0x40>
		_uart(__com, 1, 0x0D);
    29a8:	81 2f       	mov	r24, r17
    29aa:	61 e0       	ldi	r22, 0x01	; 1
    29ac:	4d e0       	ldi	r20, 0x0D	; 13
    29ae:	0e 94 7f 14 	call	0x28fe	; 0x28fe <_uart>
		_uart(__com, 1, 0x0A);
    29b2:	81 2f       	mov	r24, r17
    29b4:	61 e0       	ldi	r22, 0x01	; 1
    29b6:	4a e0       	ldi	r20, 0x0A	; 10
    29b8:	0e 94 7f 14 	call	0x28fe	; 0x28fe <_uart>
    29bc:	86 ea       	ldi	r24, 0xA6	; 166
    29be:	9e e0       	ldi	r25, 0x0E	; 14
    29c0:	01 97       	sbiw	r24, 0x01	; 1
    29c2:	f1 f7       	brne	.-4      	; 0x29c0 <_uart_printf+0x44>
	}
	_delay_ms(15);
}
    29c4:	df 91       	pop	r29
    29c6:	cf 91       	pop	r28
    29c8:	1f 91       	pop	r17
    29ca:	0f 91       	pop	r16
    29cc:	08 95       	ret

000029ce <__udivmodqi4>:
    29ce:	99 1b       	sub	r25, r25
    29d0:	79 e0       	ldi	r23, 0x09	; 9
    29d2:	04 c0       	rjmp	.+8      	; 0x29dc <__udivmodqi4_ep>

000029d4 <__udivmodqi4_loop>:
    29d4:	99 1f       	adc	r25, r25
    29d6:	96 17       	cp	r25, r22
    29d8:	08 f0       	brcs	.+2      	; 0x29dc <__udivmodqi4_ep>
    29da:	96 1b       	sub	r25, r22

000029dc <__udivmodqi4_ep>:
    29dc:	88 1f       	adc	r24, r24
    29de:	7a 95       	dec	r23
    29e0:	c9 f7       	brne	.-14     	; 0x29d4 <__udivmodqi4_loop>
    29e2:	80 95       	com	r24
    29e4:	08 95       	ret

000029e6 <__udivmodhi4>:
    29e6:	aa 1b       	sub	r26, r26
    29e8:	bb 1b       	sub	r27, r27
    29ea:	51 e1       	ldi	r21, 0x11	; 17
    29ec:	07 c0       	rjmp	.+14     	; 0x29fc <__udivmodhi4_ep>

000029ee <__udivmodhi4_loop>:
    29ee:	aa 1f       	adc	r26, r26
    29f0:	bb 1f       	adc	r27, r27
    29f2:	a6 17       	cp	r26, r22
    29f4:	b7 07       	cpc	r27, r23
    29f6:	10 f0       	brcs	.+4      	; 0x29fc <__udivmodhi4_ep>
    29f8:	a6 1b       	sub	r26, r22
    29fa:	b7 0b       	sbc	r27, r23

000029fc <__udivmodhi4_ep>:
    29fc:	88 1f       	adc	r24, r24
    29fe:	99 1f       	adc	r25, r25
    2a00:	5a 95       	dec	r21
    2a02:	a9 f7       	brne	.-22     	; 0x29ee <__udivmodhi4_loop>
    2a04:	80 95       	com	r24
    2a06:	90 95       	com	r25
    2a08:	bc 01       	movw	r22, r24
    2a0a:	cd 01       	movw	r24, r26
    2a0c:	08 95       	ret

00002a0e <__udivmodsi4>:
    2a0e:	a1 e2       	ldi	r26, 0x21	; 33
    2a10:	1a 2e       	mov	r1, r26
    2a12:	aa 1b       	sub	r26, r26
    2a14:	bb 1b       	sub	r27, r27
    2a16:	fd 01       	movw	r30, r26
    2a18:	0d c0       	rjmp	.+26     	; 0x2a34 <__udivmodsi4_ep>

00002a1a <__udivmodsi4_loop>:
    2a1a:	aa 1f       	adc	r26, r26
    2a1c:	bb 1f       	adc	r27, r27
    2a1e:	ee 1f       	adc	r30, r30
    2a20:	ff 1f       	adc	r31, r31
    2a22:	a2 17       	cp	r26, r18
    2a24:	b3 07       	cpc	r27, r19
    2a26:	e4 07       	cpc	r30, r20
    2a28:	f5 07       	cpc	r31, r21
    2a2a:	20 f0       	brcs	.+8      	; 0x2a34 <__udivmodsi4_ep>
    2a2c:	a2 1b       	sub	r26, r18
    2a2e:	b3 0b       	sbc	r27, r19
    2a30:	e4 0b       	sbc	r30, r20
    2a32:	f5 0b       	sbc	r31, r21

00002a34 <__udivmodsi4_ep>:
    2a34:	66 1f       	adc	r22, r22
    2a36:	77 1f       	adc	r23, r23
    2a38:	88 1f       	adc	r24, r24
    2a3a:	99 1f       	adc	r25, r25
    2a3c:	1a 94       	dec	r1
    2a3e:	69 f7       	brne	.-38     	; 0x2a1a <__udivmodsi4_loop>
    2a40:	60 95       	com	r22
    2a42:	70 95       	com	r23
    2a44:	80 95       	com	r24
    2a46:	90 95       	com	r25
    2a48:	9b 01       	movw	r18, r22
    2a4a:	ac 01       	movw	r20, r24
    2a4c:	bd 01       	movw	r22, r26
    2a4e:	cf 01       	movw	r24, r30
    2a50:	08 95       	ret

00002a52 <sprintf_P>:
    2a52:	ae e0       	ldi	r26, 0x0E	; 14
    2a54:	b0 e0       	ldi	r27, 0x00	; 0
    2a56:	ef e2       	ldi	r30, 0x2F	; 47
    2a58:	f5 e1       	ldi	r31, 0x15	; 21
    2a5a:	0c 94 ed 17 	jmp	0x2fda	; 0x2fda <__prologue_saves__+0x1c>
    2a5e:	0d 89       	ldd	r16, Y+21	; 0x15
    2a60:	1e 89       	ldd	r17, Y+22	; 0x16
    2a62:	8e e0       	ldi	r24, 0x0E	; 14
    2a64:	8c 83       	std	Y+4, r24	; 0x04
    2a66:	1a 83       	std	Y+2, r17	; 0x02
    2a68:	09 83       	std	Y+1, r16	; 0x01
    2a6a:	8f ef       	ldi	r24, 0xFF	; 255
    2a6c:	9f e7       	ldi	r25, 0x7F	; 127
    2a6e:	9e 83       	std	Y+6, r25	; 0x06
    2a70:	8d 83       	std	Y+5, r24	; 0x05
    2a72:	9e 01       	movw	r18, r28
    2a74:	27 5e       	subi	r18, 0xE7	; 231
    2a76:	3f 4f       	sbci	r19, 0xFF	; 255
    2a78:	ce 01       	movw	r24, r28
    2a7a:	01 96       	adiw	r24, 0x01	; 1
    2a7c:	6f 89       	ldd	r22, Y+23	; 0x17
    2a7e:	78 8d       	ldd	r23, Y+24	; 0x18
    2a80:	a9 01       	movw	r20, r18
    2a82:	0e 94 4d 15 	call	0x2a9a	; 0x2a9a <vfprintf>
    2a86:	2f 81       	ldd	r18, Y+7	; 0x07
    2a88:	38 85       	ldd	r19, Y+8	; 0x08
    2a8a:	02 0f       	add	r16, r18
    2a8c:	13 1f       	adc	r17, r19
    2a8e:	f8 01       	movw	r30, r16
    2a90:	10 82       	st	Z, r1
    2a92:	2e 96       	adiw	r28, 0x0e	; 14
    2a94:	e4 e0       	ldi	r30, 0x04	; 4
    2a96:	0c 94 09 18 	jmp	0x3012	; 0x3012 <__epilogue_restores__+0x1c>

00002a9a <vfprintf>:
    2a9a:	ab e0       	ldi	r26, 0x0B	; 11
    2a9c:	b0 e0       	ldi	r27, 0x00	; 0
    2a9e:	e3 e5       	ldi	r30, 0x53	; 83
    2aa0:	f5 e1       	ldi	r31, 0x15	; 21
    2aa2:	0c 94 df 17 	jmp	0x2fbe	; 0x2fbe <__prologue_saves__>
    2aa6:	3c 01       	movw	r6, r24
    2aa8:	2b 01       	movw	r4, r22
    2aaa:	5a 01       	movw	r10, r20
    2aac:	fc 01       	movw	r30, r24
    2aae:	17 82       	std	Z+7, r1	; 0x07
    2ab0:	16 82       	std	Z+6, r1	; 0x06
    2ab2:	83 81       	ldd	r24, Z+3	; 0x03
    2ab4:	81 fd       	sbrc	r24, 1
    2ab6:	03 c0       	rjmp	.+6      	; 0x2abe <vfprintf+0x24>
    2ab8:	6f ef       	ldi	r22, 0xFF	; 255
    2aba:	7f ef       	ldi	r23, 0xFF	; 255
    2abc:	c6 c1       	rjmp	.+908    	; 0x2e4a <vfprintf+0x3b0>
    2abe:	9a e0       	ldi	r25, 0x0A	; 10
    2ac0:	89 2e       	mov	r8, r25
    2ac2:	1e 01       	movw	r2, r28
    2ac4:	08 94       	sec
    2ac6:	21 1c       	adc	r2, r1
    2ac8:	31 1c       	adc	r3, r1
    2aca:	f3 01       	movw	r30, r6
    2acc:	23 81       	ldd	r18, Z+3	; 0x03
    2ace:	f2 01       	movw	r30, r4
    2ad0:	23 fd       	sbrc	r18, 3
    2ad2:	85 91       	lpm	r24, Z+
    2ad4:	23 ff       	sbrs	r18, 3
    2ad6:	81 91       	ld	r24, Z+
    2ad8:	2f 01       	movw	r4, r30
    2ada:	88 23       	and	r24, r24
    2adc:	09 f4       	brne	.+2      	; 0x2ae0 <vfprintf+0x46>
    2ade:	b2 c1       	rjmp	.+868    	; 0x2e44 <vfprintf+0x3aa>
    2ae0:	85 32       	cpi	r24, 0x25	; 37
    2ae2:	39 f4       	brne	.+14     	; 0x2af2 <vfprintf+0x58>
    2ae4:	23 fd       	sbrc	r18, 3
    2ae6:	85 91       	lpm	r24, Z+
    2ae8:	23 ff       	sbrs	r18, 3
    2aea:	81 91       	ld	r24, Z+
    2aec:	2f 01       	movw	r4, r30
    2aee:	85 32       	cpi	r24, 0x25	; 37
    2af0:	29 f4       	brne	.+10     	; 0x2afc <vfprintf+0x62>
    2af2:	90 e0       	ldi	r25, 0x00	; 0
    2af4:	b3 01       	movw	r22, r6
    2af6:	0e 94 55 17 	call	0x2eaa	; 0x2eaa <fputc>
    2afa:	e7 cf       	rjmp	.-50     	; 0x2aca <vfprintf+0x30>
    2afc:	98 2f       	mov	r25, r24
    2afe:	ff 24       	eor	r15, r15
    2b00:	ee 24       	eor	r14, r14
    2b02:	99 24       	eor	r9, r9
    2b04:	ff e1       	ldi	r31, 0x1F	; 31
    2b06:	ff 15       	cp	r31, r15
    2b08:	d0 f0       	brcs	.+52     	; 0x2b3e <vfprintf+0xa4>
    2b0a:	9b 32       	cpi	r25, 0x2B	; 43
    2b0c:	69 f0       	breq	.+26     	; 0x2b28 <vfprintf+0x8e>
    2b0e:	9c 32       	cpi	r25, 0x2C	; 44
    2b10:	28 f4       	brcc	.+10     	; 0x2b1c <vfprintf+0x82>
    2b12:	90 32       	cpi	r25, 0x20	; 32
    2b14:	59 f0       	breq	.+22     	; 0x2b2c <vfprintf+0x92>
    2b16:	93 32       	cpi	r25, 0x23	; 35
    2b18:	91 f4       	brne	.+36     	; 0x2b3e <vfprintf+0xa4>
    2b1a:	0e c0       	rjmp	.+28     	; 0x2b38 <vfprintf+0x9e>
    2b1c:	9d 32       	cpi	r25, 0x2D	; 45
    2b1e:	49 f0       	breq	.+18     	; 0x2b32 <vfprintf+0x98>
    2b20:	90 33       	cpi	r25, 0x30	; 48
    2b22:	69 f4       	brne	.+26     	; 0x2b3e <vfprintf+0xa4>
    2b24:	41 e0       	ldi	r20, 0x01	; 1
    2b26:	24 c0       	rjmp	.+72     	; 0x2b70 <vfprintf+0xd6>
    2b28:	52 e0       	ldi	r21, 0x02	; 2
    2b2a:	f5 2a       	or	r15, r21
    2b2c:	84 e0       	ldi	r24, 0x04	; 4
    2b2e:	f8 2a       	or	r15, r24
    2b30:	28 c0       	rjmp	.+80     	; 0x2b82 <vfprintf+0xe8>
    2b32:	98 e0       	ldi	r25, 0x08	; 8
    2b34:	f9 2a       	or	r15, r25
    2b36:	25 c0       	rjmp	.+74     	; 0x2b82 <vfprintf+0xe8>
    2b38:	e0 e1       	ldi	r30, 0x10	; 16
    2b3a:	fe 2a       	or	r15, r30
    2b3c:	22 c0       	rjmp	.+68     	; 0x2b82 <vfprintf+0xe8>
    2b3e:	f7 fc       	sbrc	r15, 7
    2b40:	29 c0       	rjmp	.+82     	; 0x2b94 <vfprintf+0xfa>
    2b42:	89 2f       	mov	r24, r25
    2b44:	80 53       	subi	r24, 0x30	; 48
    2b46:	8a 30       	cpi	r24, 0x0A	; 10
    2b48:	70 f4       	brcc	.+28     	; 0x2b66 <vfprintf+0xcc>
    2b4a:	f6 fe       	sbrs	r15, 6
    2b4c:	05 c0       	rjmp	.+10     	; 0x2b58 <vfprintf+0xbe>
    2b4e:	98 9c       	mul	r9, r8
    2b50:	90 2c       	mov	r9, r0
    2b52:	11 24       	eor	r1, r1
    2b54:	98 0e       	add	r9, r24
    2b56:	15 c0       	rjmp	.+42     	; 0x2b82 <vfprintf+0xe8>
    2b58:	e8 9c       	mul	r14, r8
    2b5a:	e0 2c       	mov	r14, r0
    2b5c:	11 24       	eor	r1, r1
    2b5e:	e8 0e       	add	r14, r24
    2b60:	f0 e2       	ldi	r31, 0x20	; 32
    2b62:	ff 2a       	or	r15, r31
    2b64:	0e c0       	rjmp	.+28     	; 0x2b82 <vfprintf+0xe8>
    2b66:	9e 32       	cpi	r25, 0x2E	; 46
    2b68:	29 f4       	brne	.+10     	; 0x2b74 <vfprintf+0xda>
    2b6a:	f6 fc       	sbrc	r15, 6
    2b6c:	6b c1       	rjmp	.+726    	; 0x2e44 <vfprintf+0x3aa>
    2b6e:	40 e4       	ldi	r20, 0x40	; 64
    2b70:	f4 2a       	or	r15, r20
    2b72:	07 c0       	rjmp	.+14     	; 0x2b82 <vfprintf+0xe8>
    2b74:	9c 36       	cpi	r25, 0x6C	; 108
    2b76:	19 f4       	brne	.+6      	; 0x2b7e <vfprintf+0xe4>
    2b78:	50 e8       	ldi	r21, 0x80	; 128
    2b7a:	f5 2a       	or	r15, r21
    2b7c:	02 c0       	rjmp	.+4      	; 0x2b82 <vfprintf+0xe8>
    2b7e:	98 36       	cpi	r25, 0x68	; 104
    2b80:	49 f4       	brne	.+18     	; 0x2b94 <vfprintf+0xfa>
    2b82:	f2 01       	movw	r30, r4
    2b84:	23 fd       	sbrc	r18, 3
    2b86:	95 91       	lpm	r25, Z+
    2b88:	23 ff       	sbrs	r18, 3
    2b8a:	91 91       	ld	r25, Z+
    2b8c:	2f 01       	movw	r4, r30
    2b8e:	99 23       	and	r25, r25
    2b90:	09 f0       	breq	.+2      	; 0x2b94 <vfprintf+0xfa>
    2b92:	b8 cf       	rjmp	.-144    	; 0x2b04 <vfprintf+0x6a>
    2b94:	89 2f       	mov	r24, r25
    2b96:	85 54       	subi	r24, 0x45	; 69
    2b98:	83 30       	cpi	r24, 0x03	; 3
    2b9a:	18 f0       	brcs	.+6      	; 0x2ba2 <vfprintf+0x108>
    2b9c:	80 52       	subi	r24, 0x20	; 32
    2b9e:	83 30       	cpi	r24, 0x03	; 3
    2ba0:	38 f4       	brcc	.+14     	; 0x2bb0 <vfprintf+0x116>
    2ba2:	44 e0       	ldi	r20, 0x04	; 4
    2ba4:	50 e0       	ldi	r21, 0x00	; 0
    2ba6:	a4 0e       	add	r10, r20
    2ba8:	b5 1e       	adc	r11, r21
    2baa:	5f e3       	ldi	r21, 0x3F	; 63
    2bac:	59 83       	std	Y+1, r21	; 0x01
    2bae:	0f c0       	rjmp	.+30     	; 0x2bce <vfprintf+0x134>
    2bb0:	93 36       	cpi	r25, 0x63	; 99
    2bb2:	31 f0       	breq	.+12     	; 0x2bc0 <vfprintf+0x126>
    2bb4:	93 37       	cpi	r25, 0x73	; 115
    2bb6:	79 f0       	breq	.+30     	; 0x2bd6 <vfprintf+0x13c>
    2bb8:	93 35       	cpi	r25, 0x53	; 83
    2bba:	09 f0       	breq	.+2      	; 0x2bbe <vfprintf+0x124>
    2bbc:	56 c0       	rjmp	.+172    	; 0x2c6a <vfprintf+0x1d0>
    2bbe:	20 c0       	rjmp	.+64     	; 0x2c00 <vfprintf+0x166>
    2bc0:	f5 01       	movw	r30, r10
    2bc2:	80 81       	ld	r24, Z
    2bc4:	89 83       	std	Y+1, r24	; 0x01
    2bc6:	42 e0       	ldi	r20, 0x02	; 2
    2bc8:	50 e0       	ldi	r21, 0x00	; 0
    2bca:	a4 0e       	add	r10, r20
    2bcc:	b5 1e       	adc	r11, r21
    2bce:	61 01       	movw	r12, r2
    2bd0:	01 e0       	ldi	r16, 0x01	; 1
    2bd2:	10 e0       	ldi	r17, 0x00	; 0
    2bd4:	12 c0       	rjmp	.+36     	; 0x2bfa <vfprintf+0x160>
    2bd6:	f5 01       	movw	r30, r10
    2bd8:	c0 80       	ld	r12, Z
    2bda:	d1 80       	ldd	r13, Z+1	; 0x01
    2bdc:	f6 fc       	sbrc	r15, 6
    2bde:	03 c0       	rjmp	.+6      	; 0x2be6 <vfprintf+0x14c>
    2be0:	6f ef       	ldi	r22, 0xFF	; 255
    2be2:	7f ef       	ldi	r23, 0xFF	; 255
    2be4:	02 c0       	rjmp	.+4      	; 0x2bea <vfprintf+0x150>
    2be6:	69 2d       	mov	r22, r9
    2be8:	70 e0       	ldi	r23, 0x00	; 0
    2bea:	42 e0       	ldi	r20, 0x02	; 2
    2bec:	50 e0       	ldi	r21, 0x00	; 0
    2bee:	a4 0e       	add	r10, r20
    2bf0:	b5 1e       	adc	r11, r21
    2bf2:	c6 01       	movw	r24, r12
    2bf4:	0e 94 4a 17 	call	0x2e94	; 0x2e94 <strnlen>
    2bf8:	8c 01       	movw	r16, r24
    2bfa:	5f e7       	ldi	r21, 0x7F	; 127
    2bfc:	f5 22       	and	r15, r21
    2bfe:	14 c0       	rjmp	.+40     	; 0x2c28 <vfprintf+0x18e>
    2c00:	f5 01       	movw	r30, r10
    2c02:	c0 80       	ld	r12, Z
    2c04:	d1 80       	ldd	r13, Z+1	; 0x01
    2c06:	f6 fc       	sbrc	r15, 6
    2c08:	03 c0       	rjmp	.+6      	; 0x2c10 <vfprintf+0x176>
    2c0a:	6f ef       	ldi	r22, 0xFF	; 255
    2c0c:	7f ef       	ldi	r23, 0xFF	; 255
    2c0e:	02 c0       	rjmp	.+4      	; 0x2c14 <vfprintf+0x17a>
    2c10:	69 2d       	mov	r22, r9
    2c12:	70 e0       	ldi	r23, 0x00	; 0
    2c14:	42 e0       	ldi	r20, 0x02	; 2
    2c16:	50 e0       	ldi	r21, 0x00	; 0
    2c18:	a4 0e       	add	r10, r20
    2c1a:	b5 1e       	adc	r11, r21
    2c1c:	c6 01       	movw	r24, r12
    2c1e:	0e 94 3f 17 	call	0x2e7e	; 0x2e7e <strnlen_P>
    2c22:	8c 01       	movw	r16, r24
    2c24:	50 e8       	ldi	r21, 0x80	; 128
    2c26:	f5 2a       	or	r15, r21
    2c28:	f3 fe       	sbrs	r15, 3
    2c2a:	07 c0       	rjmp	.+14     	; 0x2c3a <vfprintf+0x1a0>
    2c2c:	1a c0       	rjmp	.+52     	; 0x2c62 <vfprintf+0x1c8>
    2c2e:	80 e2       	ldi	r24, 0x20	; 32
    2c30:	90 e0       	ldi	r25, 0x00	; 0
    2c32:	b3 01       	movw	r22, r6
    2c34:	0e 94 55 17 	call	0x2eaa	; 0x2eaa <fputc>
    2c38:	ea 94       	dec	r14
    2c3a:	8e 2d       	mov	r24, r14
    2c3c:	90 e0       	ldi	r25, 0x00	; 0
    2c3e:	08 17       	cp	r16, r24
    2c40:	19 07       	cpc	r17, r25
    2c42:	a8 f3       	brcs	.-22     	; 0x2c2e <vfprintf+0x194>
    2c44:	0e c0       	rjmp	.+28     	; 0x2c62 <vfprintf+0x1c8>
    2c46:	f6 01       	movw	r30, r12
    2c48:	f7 fc       	sbrc	r15, 7
    2c4a:	85 91       	lpm	r24, Z+
    2c4c:	f7 fe       	sbrs	r15, 7
    2c4e:	81 91       	ld	r24, Z+
    2c50:	6f 01       	movw	r12, r30
    2c52:	90 e0       	ldi	r25, 0x00	; 0
    2c54:	b3 01       	movw	r22, r6
    2c56:	0e 94 55 17 	call	0x2eaa	; 0x2eaa <fputc>
    2c5a:	e1 10       	cpse	r14, r1
    2c5c:	ea 94       	dec	r14
    2c5e:	01 50       	subi	r16, 0x01	; 1
    2c60:	10 40       	sbci	r17, 0x00	; 0
    2c62:	01 15       	cp	r16, r1
    2c64:	11 05       	cpc	r17, r1
    2c66:	79 f7       	brne	.-34     	; 0x2c46 <vfprintf+0x1ac>
    2c68:	ea c0       	rjmp	.+468    	; 0x2e3e <vfprintf+0x3a4>
    2c6a:	94 36       	cpi	r25, 0x64	; 100
    2c6c:	11 f0       	breq	.+4      	; 0x2c72 <vfprintf+0x1d8>
    2c6e:	99 36       	cpi	r25, 0x69	; 105
    2c70:	69 f5       	brne	.+90     	; 0x2ccc <vfprintf+0x232>
    2c72:	f7 fe       	sbrs	r15, 7
    2c74:	08 c0       	rjmp	.+16     	; 0x2c86 <vfprintf+0x1ec>
    2c76:	f5 01       	movw	r30, r10
    2c78:	20 81       	ld	r18, Z
    2c7a:	31 81       	ldd	r19, Z+1	; 0x01
    2c7c:	42 81       	ldd	r20, Z+2	; 0x02
    2c7e:	53 81       	ldd	r21, Z+3	; 0x03
    2c80:	84 e0       	ldi	r24, 0x04	; 4
    2c82:	90 e0       	ldi	r25, 0x00	; 0
    2c84:	0a c0       	rjmp	.+20     	; 0x2c9a <vfprintf+0x200>
    2c86:	f5 01       	movw	r30, r10
    2c88:	80 81       	ld	r24, Z
    2c8a:	91 81       	ldd	r25, Z+1	; 0x01
    2c8c:	9c 01       	movw	r18, r24
    2c8e:	44 27       	eor	r20, r20
    2c90:	37 fd       	sbrc	r19, 7
    2c92:	40 95       	com	r20
    2c94:	54 2f       	mov	r21, r20
    2c96:	82 e0       	ldi	r24, 0x02	; 2
    2c98:	90 e0       	ldi	r25, 0x00	; 0
    2c9a:	a8 0e       	add	r10, r24
    2c9c:	b9 1e       	adc	r11, r25
    2c9e:	9f e6       	ldi	r25, 0x6F	; 111
    2ca0:	f9 22       	and	r15, r25
    2ca2:	57 ff       	sbrs	r21, 7
    2ca4:	09 c0       	rjmp	.+18     	; 0x2cb8 <vfprintf+0x21e>
    2ca6:	50 95       	com	r21
    2ca8:	40 95       	com	r20
    2caa:	30 95       	com	r19
    2cac:	21 95       	neg	r18
    2cae:	3f 4f       	sbci	r19, 0xFF	; 255
    2cb0:	4f 4f       	sbci	r20, 0xFF	; 255
    2cb2:	5f 4f       	sbci	r21, 0xFF	; 255
    2cb4:	e0 e8       	ldi	r30, 0x80	; 128
    2cb6:	fe 2a       	or	r15, r30
    2cb8:	ca 01       	movw	r24, r20
    2cba:	b9 01       	movw	r22, r18
    2cbc:	a1 01       	movw	r20, r2
    2cbe:	2a e0       	ldi	r18, 0x0A	; 10
    2cc0:	30 e0       	ldi	r19, 0x00	; 0
    2cc2:	0e 94 81 17 	call	0x2f02	; 0x2f02 <__ultoa_invert>
    2cc6:	d8 2e       	mov	r13, r24
    2cc8:	d2 18       	sub	r13, r2
    2cca:	40 c0       	rjmp	.+128    	; 0x2d4c <vfprintf+0x2b2>
    2ccc:	95 37       	cpi	r25, 0x75	; 117
    2cce:	29 f4       	brne	.+10     	; 0x2cda <vfprintf+0x240>
    2cd0:	1f 2d       	mov	r17, r15
    2cd2:	1f 7e       	andi	r17, 0xEF	; 239
    2cd4:	2a e0       	ldi	r18, 0x0A	; 10
    2cd6:	30 e0       	ldi	r19, 0x00	; 0
    2cd8:	1d c0       	rjmp	.+58     	; 0x2d14 <vfprintf+0x27a>
    2cda:	1f 2d       	mov	r17, r15
    2cdc:	19 7f       	andi	r17, 0xF9	; 249
    2cde:	9f 36       	cpi	r25, 0x6F	; 111
    2ce0:	61 f0       	breq	.+24     	; 0x2cfa <vfprintf+0x260>
    2ce2:	90 37       	cpi	r25, 0x70	; 112
    2ce4:	20 f4       	brcc	.+8      	; 0x2cee <vfprintf+0x254>
    2ce6:	98 35       	cpi	r25, 0x58	; 88
    2ce8:	09 f0       	breq	.+2      	; 0x2cec <vfprintf+0x252>
    2cea:	ac c0       	rjmp	.+344    	; 0x2e44 <vfprintf+0x3aa>
    2cec:	0f c0       	rjmp	.+30     	; 0x2d0c <vfprintf+0x272>
    2cee:	90 37       	cpi	r25, 0x70	; 112
    2cf0:	39 f0       	breq	.+14     	; 0x2d00 <vfprintf+0x266>
    2cf2:	98 37       	cpi	r25, 0x78	; 120
    2cf4:	09 f0       	breq	.+2      	; 0x2cf8 <vfprintf+0x25e>
    2cf6:	a6 c0       	rjmp	.+332    	; 0x2e44 <vfprintf+0x3aa>
    2cf8:	04 c0       	rjmp	.+8      	; 0x2d02 <vfprintf+0x268>
    2cfa:	28 e0       	ldi	r18, 0x08	; 8
    2cfc:	30 e0       	ldi	r19, 0x00	; 0
    2cfe:	0a c0       	rjmp	.+20     	; 0x2d14 <vfprintf+0x27a>
    2d00:	10 61       	ori	r17, 0x10	; 16
    2d02:	14 fd       	sbrc	r17, 4
    2d04:	14 60       	ori	r17, 0x04	; 4
    2d06:	20 e1       	ldi	r18, 0x10	; 16
    2d08:	30 e0       	ldi	r19, 0x00	; 0
    2d0a:	04 c0       	rjmp	.+8      	; 0x2d14 <vfprintf+0x27a>
    2d0c:	14 fd       	sbrc	r17, 4
    2d0e:	16 60       	ori	r17, 0x06	; 6
    2d10:	20 e1       	ldi	r18, 0x10	; 16
    2d12:	32 e0       	ldi	r19, 0x02	; 2
    2d14:	17 ff       	sbrs	r17, 7
    2d16:	08 c0       	rjmp	.+16     	; 0x2d28 <vfprintf+0x28e>
    2d18:	f5 01       	movw	r30, r10
    2d1a:	60 81       	ld	r22, Z
    2d1c:	71 81       	ldd	r23, Z+1	; 0x01
    2d1e:	82 81       	ldd	r24, Z+2	; 0x02
    2d20:	93 81       	ldd	r25, Z+3	; 0x03
    2d22:	44 e0       	ldi	r20, 0x04	; 4
    2d24:	50 e0       	ldi	r21, 0x00	; 0
    2d26:	08 c0       	rjmp	.+16     	; 0x2d38 <vfprintf+0x29e>
    2d28:	f5 01       	movw	r30, r10
    2d2a:	80 81       	ld	r24, Z
    2d2c:	91 81       	ldd	r25, Z+1	; 0x01
    2d2e:	bc 01       	movw	r22, r24
    2d30:	80 e0       	ldi	r24, 0x00	; 0
    2d32:	90 e0       	ldi	r25, 0x00	; 0
    2d34:	42 e0       	ldi	r20, 0x02	; 2
    2d36:	50 e0       	ldi	r21, 0x00	; 0
    2d38:	a4 0e       	add	r10, r20
    2d3a:	b5 1e       	adc	r11, r21
    2d3c:	a1 01       	movw	r20, r2
    2d3e:	0e 94 81 17 	call	0x2f02	; 0x2f02 <__ultoa_invert>
    2d42:	d8 2e       	mov	r13, r24
    2d44:	d2 18       	sub	r13, r2
    2d46:	8f e7       	ldi	r24, 0x7F	; 127
    2d48:	f8 2e       	mov	r15, r24
    2d4a:	f1 22       	and	r15, r17
    2d4c:	f6 fe       	sbrs	r15, 6
    2d4e:	0b c0       	rjmp	.+22     	; 0x2d66 <vfprintf+0x2cc>
    2d50:	5e ef       	ldi	r21, 0xFE	; 254
    2d52:	f5 22       	and	r15, r21
    2d54:	d9 14       	cp	r13, r9
    2d56:	38 f4       	brcc	.+14     	; 0x2d66 <vfprintf+0x2cc>
    2d58:	f4 fe       	sbrs	r15, 4
    2d5a:	07 c0       	rjmp	.+14     	; 0x2d6a <vfprintf+0x2d0>
    2d5c:	f2 fc       	sbrc	r15, 2
    2d5e:	05 c0       	rjmp	.+10     	; 0x2d6a <vfprintf+0x2d0>
    2d60:	8f ee       	ldi	r24, 0xEF	; 239
    2d62:	f8 22       	and	r15, r24
    2d64:	02 c0       	rjmp	.+4      	; 0x2d6a <vfprintf+0x2d0>
    2d66:	1d 2d       	mov	r17, r13
    2d68:	01 c0       	rjmp	.+2      	; 0x2d6c <vfprintf+0x2d2>
    2d6a:	19 2d       	mov	r17, r9
    2d6c:	f4 fe       	sbrs	r15, 4
    2d6e:	0d c0       	rjmp	.+26     	; 0x2d8a <vfprintf+0x2f0>
    2d70:	fe 01       	movw	r30, r28
    2d72:	ed 0d       	add	r30, r13
    2d74:	f1 1d       	adc	r31, r1
    2d76:	80 81       	ld	r24, Z
    2d78:	80 33       	cpi	r24, 0x30	; 48
    2d7a:	19 f4       	brne	.+6      	; 0x2d82 <vfprintf+0x2e8>
    2d7c:	99 ee       	ldi	r25, 0xE9	; 233
    2d7e:	f9 22       	and	r15, r25
    2d80:	08 c0       	rjmp	.+16     	; 0x2d92 <vfprintf+0x2f8>
    2d82:	1f 5f       	subi	r17, 0xFF	; 255
    2d84:	f2 fe       	sbrs	r15, 2
    2d86:	05 c0       	rjmp	.+10     	; 0x2d92 <vfprintf+0x2f8>
    2d88:	03 c0       	rjmp	.+6      	; 0x2d90 <vfprintf+0x2f6>
    2d8a:	8f 2d       	mov	r24, r15
    2d8c:	86 78       	andi	r24, 0x86	; 134
    2d8e:	09 f0       	breq	.+2      	; 0x2d92 <vfprintf+0x2f8>
    2d90:	1f 5f       	subi	r17, 0xFF	; 255
    2d92:	0f 2d       	mov	r16, r15
    2d94:	f3 fc       	sbrc	r15, 3
    2d96:	14 c0       	rjmp	.+40     	; 0x2dc0 <vfprintf+0x326>
    2d98:	f0 fe       	sbrs	r15, 0
    2d9a:	0f c0       	rjmp	.+30     	; 0x2dba <vfprintf+0x320>
    2d9c:	1e 15       	cp	r17, r14
    2d9e:	10 f0       	brcs	.+4      	; 0x2da4 <vfprintf+0x30a>
    2da0:	9d 2c       	mov	r9, r13
    2da2:	0b c0       	rjmp	.+22     	; 0x2dba <vfprintf+0x320>
    2da4:	9d 2c       	mov	r9, r13
    2da6:	9e 0c       	add	r9, r14
    2da8:	91 1a       	sub	r9, r17
    2daa:	1e 2d       	mov	r17, r14
    2dac:	06 c0       	rjmp	.+12     	; 0x2dba <vfprintf+0x320>
    2dae:	80 e2       	ldi	r24, 0x20	; 32
    2db0:	90 e0       	ldi	r25, 0x00	; 0
    2db2:	b3 01       	movw	r22, r6
    2db4:	0e 94 55 17 	call	0x2eaa	; 0x2eaa <fputc>
    2db8:	1f 5f       	subi	r17, 0xFF	; 255
    2dba:	1e 15       	cp	r17, r14
    2dbc:	c0 f3       	brcs	.-16     	; 0x2dae <vfprintf+0x314>
    2dbe:	04 c0       	rjmp	.+8      	; 0x2dc8 <vfprintf+0x32e>
    2dc0:	1e 15       	cp	r17, r14
    2dc2:	10 f4       	brcc	.+4      	; 0x2dc8 <vfprintf+0x32e>
    2dc4:	e1 1a       	sub	r14, r17
    2dc6:	01 c0       	rjmp	.+2      	; 0x2dca <vfprintf+0x330>
    2dc8:	ee 24       	eor	r14, r14
    2dca:	04 ff       	sbrs	r16, 4
    2dcc:	0f c0       	rjmp	.+30     	; 0x2dec <vfprintf+0x352>
    2dce:	80 e3       	ldi	r24, 0x30	; 48
    2dd0:	90 e0       	ldi	r25, 0x00	; 0
    2dd2:	b3 01       	movw	r22, r6
    2dd4:	0e 94 55 17 	call	0x2eaa	; 0x2eaa <fputc>
    2dd8:	02 ff       	sbrs	r16, 2
    2dda:	1d c0       	rjmp	.+58     	; 0x2e16 <vfprintf+0x37c>
    2ddc:	01 fd       	sbrc	r16, 1
    2dde:	03 c0       	rjmp	.+6      	; 0x2de6 <vfprintf+0x34c>
    2de0:	88 e7       	ldi	r24, 0x78	; 120
    2de2:	90 e0       	ldi	r25, 0x00	; 0
    2de4:	0e c0       	rjmp	.+28     	; 0x2e02 <vfprintf+0x368>
    2de6:	88 e5       	ldi	r24, 0x58	; 88
    2de8:	90 e0       	ldi	r25, 0x00	; 0
    2dea:	0b c0       	rjmp	.+22     	; 0x2e02 <vfprintf+0x368>
    2dec:	80 2f       	mov	r24, r16
    2dee:	86 78       	andi	r24, 0x86	; 134
    2df0:	91 f0       	breq	.+36     	; 0x2e16 <vfprintf+0x37c>
    2df2:	01 ff       	sbrs	r16, 1
    2df4:	02 c0       	rjmp	.+4      	; 0x2dfa <vfprintf+0x360>
    2df6:	8b e2       	ldi	r24, 0x2B	; 43
    2df8:	01 c0       	rjmp	.+2      	; 0x2dfc <vfprintf+0x362>
    2dfa:	80 e2       	ldi	r24, 0x20	; 32
    2dfc:	f7 fc       	sbrc	r15, 7
    2dfe:	8d e2       	ldi	r24, 0x2D	; 45
    2e00:	90 e0       	ldi	r25, 0x00	; 0
    2e02:	b3 01       	movw	r22, r6
    2e04:	0e 94 55 17 	call	0x2eaa	; 0x2eaa <fputc>
    2e08:	06 c0       	rjmp	.+12     	; 0x2e16 <vfprintf+0x37c>
    2e0a:	80 e3       	ldi	r24, 0x30	; 48
    2e0c:	90 e0       	ldi	r25, 0x00	; 0
    2e0e:	b3 01       	movw	r22, r6
    2e10:	0e 94 55 17 	call	0x2eaa	; 0x2eaa <fputc>
    2e14:	9a 94       	dec	r9
    2e16:	d9 14       	cp	r13, r9
    2e18:	c0 f3       	brcs	.-16     	; 0x2e0a <vfprintf+0x370>
    2e1a:	da 94       	dec	r13
    2e1c:	f1 01       	movw	r30, r2
    2e1e:	ed 0d       	add	r30, r13
    2e20:	f1 1d       	adc	r31, r1
    2e22:	80 81       	ld	r24, Z
    2e24:	90 e0       	ldi	r25, 0x00	; 0
    2e26:	b3 01       	movw	r22, r6
    2e28:	0e 94 55 17 	call	0x2eaa	; 0x2eaa <fputc>
    2e2c:	dd 20       	and	r13, r13
    2e2e:	a9 f7       	brne	.-22     	; 0x2e1a <vfprintf+0x380>
    2e30:	06 c0       	rjmp	.+12     	; 0x2e3e <vfprintf+0x3a4>
    2e32:	80 e2       	ldi	r24, 0x20	; 32
    2e34:	90 e0       	ldi	r25, 0x00	; 0
    2e36:	b3 01       	movw	r22, r6
    2e38:	0e 94 55 17 	call	0x2eaa	; 0x2eaa <fputc>
    2e3c:	ea 94       	dec	r14
    2e3e:	ee 20       	and	r14, r14
    2e40:	c1 f7       	brne	.-16     	; 0x2e32 <vfprintf+0x398>
    2e42:	43 ce       	rjmp	.-890    	; 0x2aca <vfprintf+0x30>
    2e44:	f3 01       	movw	r30, r6
    2e46:	66 81       	ldd	r22, Z+6	; 0x06
    2e48:	77 81       	ldd	r23, Z+7	; 0x07
    2e4a:	cb 01       	movw	r24, r22
    2e4c:	2b 96       	adiw	r28, 0x0b	; 11
    2e4e:	e2 e1       	ldi	r30, 0x12	; 18
    2e50:	0c 94 fb 17 	jmp	0x2ff6	; 0x2ff6 <__epilogue_restores__>

00002e54 <__eerd_byte_m162>:
    2e54:	e1 99       	sbic	0x1c, 1	; 28
    2e56:	fe cf       	rjmp	.-4      	; 0x2e54 <__eerd_byte_m162>
    2e58:	9f bb       	out	0x1f, r25	; 31
    2e5a:	8e bb       	out	0x1e, r24	; 30
    2e5c:	e0 9a       	sbi	0x1c, 0	; 28
    2e5e:	99 27       	eor	r25, r25
    2e60:	8d b3       	in	r24, 0x1d	; 29
    2e62:	08 95       	ret

00002e64 <__eewr_byte_m162>:
    2e64:	26 2f       	mov	r18, r22

00002e66 <__eewr_r18_m162>:
    2e66:	e1 99       	sbic	0x1c, 1	; 28
    2e68:	fe cf       	rjmp	.-4      	; 0x2e66 <__eewr_r18_m162>
    2e6a:	9f bb       	out	0x1f, r25	; 31
    2e6c:	8e bb       	out	0x1e, r24	; 30
    2e6e:	2d bb       	out	0x1d, r18	; 29
    2e70:	0f b6       	in	r0, 0x3f	; 63
    2e72:	f8 94       	cli
    2e74:	e2 9a       	sbi	0x1c, 2	; 28
    2e76:	e1 9a       	sbi	0x1c, 1	; 28
    2e78:	0f be       	out	0x3f, r0	; 63
    2e7a:	01 96       	adiw	r24, 0x01	; 1
    2e7c:	08 95       	ret

00002e7e <strnlen_P>:
    2e7e:	fc 01       	movw	r30, r24
    2e80:	05 90       	lpm	r0, Z+
    2e82:	61 50       	subi	r22, 0x01	; 1
    2e84:	70 40       	sbci	r23, 0x00	; 0
    2e86:	01 10       	cpse	r0, r1
    2e88:	d8 f7       	brcc	.-10     	; 0x2e80 <strnlen_P+0x2>
    2e8a:	80 95       	com	r24
    2e8c:	90 95       	com	r25
    2e8e:	8e 0f       	add	r24, r30
    2e90:	9f 1f       	adc	r25, r31
    2e92:	08 95       	ret

00002e94 <strnlen>:
    2e94:	fc 01       	movw	r30, r24
    2e96:	61 50       	subi	r22, 0x01	; 1
    2e98:	70 40       	sbci	r23, 0x00	; 0
    2e9a:	01 90       	ld	r0, Z+
    2e9c:	01 10       	cpse	r0, r1
    2e9e:	d8 f7       	brcc	.-10     	; 0x2e96 <strnlen+0x2>
    2ea0:	80 95       	com	r24
    2ea2:	90 95       	com	r25
    2ea4:	8e 0f       	add	r24, r30
    2ea6:	9f 1f       	adc	r25, r31
    2ea8:	08 95       	ret

00002eaa <fputc>:
    2eaa:	0f 93       	push	r16
    2eac:	1f 93       	push	r17
    2eae:	cf 93       	push	r28
    2eb0:	df 93       	push	r29
    2eb2:	8c 01       	movw	r16, r24
    2eb4:	eb 01       	movw	r28, r22
    2eb6:	8b 81       	ldd	r24, Y+3	; 0x03
    2eb8:	81 ff       	sbrs	r24, 1
    2eba:	1b c0       	rjmp	.+54     	; 0x2ef2 <fputc+0x48>
    2ebc:	82 ff       	sbrs	r24, 2
    2ebe:	0d c0       	rjmp	.+26     	; 0x2eda <fputc+0x30>
    2ec0:	2e 81       	ldd	r18, Y+6	; 0x06
    2ec2:	3f 81       	ldd	r19, Y+7	; 0x07
    2ec4:	8c 81       	ldd	r24, Y+4	; 0x04
    2ec6:	9d 81       	ldd	r25, Y+5	; 0x05
    2ec8:	28 17       	cp	r18, r24
    2eca:	39 07       	cpc	r19, r25
    2ecc:	64 f4       	brge	.+24     	; 0x2ee6 <fputc+0x3c>
    2ece:	e8 81       	ld	r30, Y
    2ed0:	f9 81       	ldd	r31, Y+1	; 0x01
    2ed2:	01 93       	st	Z+, r16
    2ed4:	f9 83       	std	Y+1, r31	; 0x01
    2ed6:	e8 83       	st	Y, r30
    2ed8:	06 c0       	rjmp	.+12     	; 0x2ee6 <fputc+0x3c>
    2eda:	e8 85       	ldd	r30, Y+8	; 0x08
    2edc:	f9 85       	ldd	r31, Y+9	; 0x09
    2ede:	80 2f       	mov	r24, r16
    2ee0:	09 95       	icall
    2ee2:	89 2b       	or	r24, r25
    2ee4:	31 f4       	brne	.+12     	; 0x2ef2 <fputc+0x48>
    2ee6:	8e 81       	ldd	r24, Y+6	; 0x06
    2ee8:	9f 81       	ldd	r25, Y+7	; 0x07
    2eea:	01 96       	adiw	r24, 0x01	; 1
    2eec:	9f 83       	std	Y+7, r25	; 0x07
    2eee:	8e 83       	std	Y+6, r24	; 0x06
    2ef0:	02 c0       	rjmp	.+4      	; 0x2ef6 <fputc+0x4c>
    2ef2:	0f ef       	ldi	r16, 0xFF	; 255
    2ef4:	1f ef       	ldi	r17, 0xFF	; 255
    2ef6:	c8 01       	movw	r24, r16
    2ef8:	df 91       	pop	r29
    2efa:	cf 91       	pop	r28
    2efc:	1f 91       	pop	r17
    2efe:	0f 91       	pop	r16
    2f00:	08 95       	ret

00002f02 <__ultoa_invert>:
    2f02:	fa 01       	movw	r30, r20
    2f04:	aa 27       	eor	r26, r26
    2f06:	28 30       	cpi	r18, 0x08	; 8
    2f08:	51 f1       	breq	.+84     	; 0x2f5e <__ultoa_invert+0x5c>
    2f0a:	20 31       	cpi	r18, 0x10	; 16
    2f0c:	81 f1       	breq	.+96     	; 0x2f6e <__ultoa_invert+0x6c>
    2f0e:	e8 94       	clt
    2f10:	6f 93       	push	r22
    2f12:	6e 7f       	andi	r22, 0xFE	; 254
    2f14:	6e 5f       	subi	r22, 0xFE	; 254
    2f16:	7f 4f       	sbci	r23, 0xFF	; 255
    2f18:	8f 4f       	sbci	r24, 0xFF	; 255
    2f1a:	9f 4f       	sbci	r25, 0xFF	; 255
    2f1c:	af 4f       	sbci	r26, 0xFF	; 255
    2f1e:	b1 e0       	ldi	r27, 0x01	; 1
    2f20:	3e d0       	rcall	.+124    	; 0x2f9e <__ultoa_invert+0x9c>
    2f22:	b4 e0       	ldi	r27, 0x04	; 4
    2f24:	3c d0       	rcall	.+120    	; 0x2f9e <__ultoa_invert+0x9c>
    2f26:	67 0f       	add	r22, r23
    2f28:	78 1f       	adc	r23, r24
    2f2a:	89 1f       	adc	r24, r25
    2f2c:	9a 1f       	adc	r25, r26
    2f2e:	a1 1d       	adc	r26, r1
    2f30:	68 0f       	add	r22, r24
    2f32:	79 1f       	adc	r23, r25
    2f34:	8a 1f       	adc	r24, r26
    2f36:	91 1d       	adc	r25, r1
    2f38:	a1 1d       	adc	r26, r1
    2f3a:	6a 0f       	add	r22, r26
    2f3c:	71 1d       	adc	r23, r1
    2f3e:	81 1d       	adc	r24, r1
    2f40:	91 1d       	adc	r25, r1
    2f42:	a1 1d       	adc	r26, r1
    2f44:	20 d0       	rcall	.+64     	; 0x2f86 <__ultoa_invert+0x84>
    2f46:	09 f4       	brne	.+2      	; 0x2f4a <__ultoa_invert+0x48>
    2f48:	68 94       	set
    2f4a:	3f 91       	pop	r19
    2f4c:	2a e0       	ldi	r18, 0x0A	; 10
    2f4e:	26 9f       	mul	r18, r22
    2f50:	11 24       	eor	r1, r1
    2f52:	30 19       	sub	r19, r0
    2f54:	30 5d       	subi	r19, 0xD0	; 208
    2f56:	31 93       	st	Z+, r19
    2f58:	de f6       	brtc	.-74     	; 0x2f10 <__ultoa_invert+0xe>
    2f5a:	cf 01       	movw	r24, r30
    2f5c:	08 95       	ret
    2f5e:	46 2f       	mov	r20, r22
    2f60:	47 70       	andi	r20, 0x07	; 7
    2f62:	40 5d       	subi	r20, 0xD0	; 208
    2f64:	41 93       	st	Z+, r20
    2f66:	b3 e0       	ldi	r27, 0x03	; 3
    2f68:	0f d0       	rcall	.+30     	; 0x2f88 <__ultoa_invert+0x86>
    2f6a:	c9 f7       	brne	.-14     	; 0x2f5e <__ultoa_invert+0x5c>
    2f6c:	f6 cf       	rjmp	.-20     	; 0x2f5a <__ultoa_invert+0x58>
    2f6e:	46 2f       	mov	r20, r22
    2f70:	4f 70       	andi	r20, 0x0F	; 15
    2f72:	40 5d       	subi	r20, 0xD0	; 208
    2f74:	4a 33       	cpi	r20, 0x3A	; 58
    2f76:	18 f0       	brcs	.+6      	; 0x2f7e <__ultoa_invert+0x7c>
    2f78:	49 5d       	subi	r20, 0xD9	; 217
    2f7a:	31 fd       	sbrc	r19, 1
    2f7c:	40 52       	subi	r20, 0x20	; 32
    2f7e:	41 93       	st	Z+, r20
    2f80:	02 d0       	rcall	.+4      	; 0x2f86 <__ultoa_invert+0x84>
    2f82:	a9 f7       	brne	.-22     	; 0x2f6e <__ultoa_invert+0x6c>
    2f84:	ea cf       	rjmp	.-44     	; 0x2f5a <__ultoa_invert+0x58>
    2f86:	b4 e0       	ldi	r27, 0x04	; 4
    2f88:	a6 95       	lsr	r26
    2f8a:	97 95       	ror	r25
    2f8c:	87 95       	ror	r24
    2f8e:	77 95       	ror	r23
    2f90:	67 95       	ror	r22
    2f92:	ba 95       	dec	r27
    2f94:	c9 f7       	brne	.-14     	; 0x2f88 <__ultoa_invert+0x86>
    2f96:	00 97       	sbiw	r24, 0x00	; 0
    2f98:	61 05       	cpc	r22, r1
    2f9a:	71 05       	cpc	r23, r1
    2f9c:	08 95       	ret
    2f9e:	9b 01       	movw	r18, r22
    2fa0:	ac 01       	movw	r20, r24
    2fa2:	0a 2e       	mov	r0, r26
    2fa4:	06 94       	lsr	r0
    2fa6:	57 95       	ror	r21
    2fa8:	47 95       	ror	r20
    2faa:	37 95       	ror	r19
    2fac:	27 95       	ror	r18
    2fae:	ba 95       	dec	r27
    2fb0:	c9 f7       	brne	.-14     	; 0x2fa4 <__ultoa_invert+0xa2>
    2fb2:	62 0f       	add	r22, r18
    2fb4:	73 1f       	adc	r23, r19
    2fb6:	84 1f       	adc	r24, r20
    2fb8:	95 1f       	adc	r25, r21
    2fba:	a0 1d       	adc	r26, r0
    2fbc:	08 95       	ret

00002fbe <__prologue_saves__>:
    2fbe:	2f 92       	push	r2
    2fc0:	3f 92       	push	r3
    2fc2:	4f 92       	push	r4
    2fc4:	5f 92       	push	r5
    2fc6:	6f 92       	push	r6
    2fc8:	7f 92       	push	r7
    2fca:	8f 92       	push	r8
    2fcc:	9f 92       	push	r9
    2fce:	af 92       	push	r10
    2fd0:	bf 92       	push	r11
    2fd2:	cf 92       	push	r12
    2fd4:	df 92       	push	r13
    2fd6:	ef 92       	push	r14
    2fd8:	ff 92       	push	r15
    2fda:	0f 93       	push	r16
    2fdc:	1f 93       	push	r17
    2fde:	cf 93       	push	r28
    2fe0:	df 93       	push	r29
    2fe2:	cd b7       	in	r28, 0x3d	; 61
    2fe4:	de b7       	in	r29, 0x3e	; 62
    2fe6:	ca 1b       	sub	r28, r26
    2fe8:	db 0b       	sbc	r29, r27
    2fea:	0f b6       	in	r0, 0x3f	; 63
    2fec:	f8 94       	cli
    2fee:	de bf       	out	0x3e, r29	; 62
    2ff0:	0f be       	out	0x3f, r0	; 63
    2ff2:	cd bf       	out	0x3d, r28	; 61
    2ff4:	09 94       	ijmp

00002ff6 <__epilogue_restores__>:
    2ff6:	2a 88       	ldd	r2, Y+18	; 0x12
    2ff8:	39 88       	ldd	r3, Y+17	; 0x11
    2ffa:	48 88       	ldd	r4, Y+16	; 0x10
    2ffc:	5f 84       	ldd	r5, Y+15	; 0x0f
    2ffe:	6e 84       	ldd	r6, Y+14	; 0x0e
    3000:	7d 84       	ldd	r7, Y+13	; 0x0d
    3002:	8c 84       	ldd	r8, Y+12	; 0x0c
    3004:	9b 84       	ldd	r9, Y+11	; 0x0b
    3006:	aa 84       	ldd	r10, Y+10	; 0x0a
    3008:	b9 84       	ldd	r11, Y+9	; 0x09
    300a:	c8 84       	ldd	r12, Y+8	; 0x08
    300c:	df 80       	ldd	r13, Y+7	; 0x07
    300e:	ee 80       	ldd	r14, Y+6	; 0x06
    3010:	fd 80       	ldd	r15, Y+5	; 0x05
    3012:	0c 81       	ldd	r16, Y+4	; 0x04
    3014:	1b 81       	ldd	r17, Y+3	; 0x03
    3016:	aa 81       	ldd	r26, Y+2	; 0x02
    3018:	b9 81       	ldd	r27, Y+1	; 0x01
    301a:	ce 0f       	add	r28, r30
    301c:	d1 1d       	adc	r29, r1
    301e:	0f b6       	in	r0, 0x3f	; 63
    3020:	f8 94       	cli
    3022:	de bf       	out	0x3e, r29	; 62
    3024:	0f be       	out	0x3f, r0	; 63
    3026:	cd bf       	out	0x3d, r28	; 61
    3028:	ed 01       	movw	r28, r26
    302a:	08 95       	ret

0000302c <_exit>:
    302c:	f8 94       	cli

0000302e <__stop_program>:
    302e:	ff cf       	rjmp	.-2      	; 0x302e <__stop_program>
