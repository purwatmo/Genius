
no6.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000000e  00800100  0000379c  00003850  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000379c  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000329  0080010e  0080010e  0000385e  2**0
                  ALLOC
  3 .eeprom       0000001f  00810000  00810000  0000385e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .debug_aranges 00000060  00000000  00000000  0000387d  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_pubnames 00000bf9  00000000  00000000  000038dd  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00003fa2  00000000  00000000  000044d6  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000059c  00000000  00000000  00008478  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00003058  00000000  00000000  00008a14  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000510  00000000  00000000  0000ba6c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000019a4  00000000  00000000  0000bf7c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000022dd  00000000  00000000  0000d920  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000420  00000000  00000000  0000fbfd  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 cc 00 	jmp	0x198	; 0x198 <__ctors_end>
       4:	0c 94 e9 00 	jmp	0x1d2	; 0x1d2 <__bad_interrupt>
       8:	0c 94 e9 00 	jmp	0x1d2	; 0x1d2 <__bad_interrupt>
       c:	0c 94 e9 00 	jmp	0x1d2	; 0x1d2 <__bad_interrupt>
      10:	0c 94 e9 00 	jmp	0x1d2	; 0x1d2 <__bad_interrupt>
      14:	0c 94 e9 00 	jmp	0x1d2	; 0x1d2 <__bad_interrupt>
      18:	0c 94 e9 00 	jmp	0x1d2	; 0x1d2 <__bad_interrupt>
      1c:	0c 94 e9 00 	jmp	0x1d2	; 0x1d2 <__bad_interrupt>
      20:	0c 94 e9 00 	jmp	0x1d2	; 0x1d2 <__bad_interrupt>
      24:	0c 94 e9 00 	jmp	0x1d2	; 0x1d2 <__bad_interrupt>
      28:	0c 94 e9 00 	jmp	0x1d2	; 0x1d2 <__bad_interrupt>
      2c:	0c 94 e9 00 	jmp	0x1d2	; 0x1d2 <__bad_interrupt>
      30:	0c 94 e9 00 	jmp	0x1d2	; 0x1d2 <__bad_interrupt>
      34:	0c 94 e9 00 	jmp	0x1d2	; 0x1d2 <__bad_interrupt>
      38:	0c 94 e9 00 	jmp	0x1d2	; 0x1d2 <__bad_interrupt>
      3c:	0c 94 e9 00 	jmp	0x1d2	; 0x1d2 <__bad_interrupt>
      40:	0c 94 e9 00 	jmp	0x1d2	; 0x1d2 <__bad_interrupt>
      44:	0c 94 eb 00 	jmp	0x1d6	; 0x1d6 <__vector_17>
      48:	0c 94 2d 17 	jmp	0x2e5a	; 0x2e5a <__vector_18>
      4c:	0c 94 79 0b 	jmp	0x16f2	; 0x16f2 <__vector_19>
      50:	0c 94 f7 06 	jmp	0xdee	; 0xdee <__vector_20>
      54:	0c 94 e9 00 	jmp	0x1d2	; 0x1d2 <__bad_interrupt>
      58:	0c 94 e9 00 	jmp	0x1d2	; 0x1d2 <__bad_interrupt>
      5c:	0c 94 e9 00 	jmp	0x1d2	; 0x1d2 <__bad_interrupt>
      60:	0c 94 e9 00 	jmp	0x1d2	; 0x1d2 <__bad_interrupt>
      64:	0c 94 e9 00 	jmp	0x1d2	; 0x1d2 <__bad_interrupt>
      68:	0c 94 e9 00 	jmp	0x1d2	; 0x1d2 <__bad_interrupt>
      6c:	0c 94 e9 00 	jmp	0x1d2	; 0x1d2 <__bad_interrupt>
      70:	ab 0d       	add	r26, r11
      72:	fe 0d       	add	r31, r14
      74:	21 0e       	add	r2, r17
      76:	28 0e       	add	r2, r24
      78:	2e 0e       	add	r2, r30
      7a:	39 0e       	add	r3, r25
      7c:	4e 0e       	add	r4, r30
      7e:	8e 0e       	add	r8, r30
      80:	10 0f       	add	r17, r16
      82:	8b 0f       	add	r24, r27
      84:	b4 0f       	add	r27, r20
      86:	59 0f       	add	r21, r25
      88:	17 0f       	add	r17, r23
      8a:	24 0f       	add	r18, r20
      8c:	61 0f       	add	r22, r17
      8e:	6e 0f       	add	r22, r30
      90:	70 10       	cpse	r7, r0
      92:	ba 0f       	add	r27, r26
      94:	c7 0f       	add	r28, r23
      96:	ec 0f       	add	r30, r28
      98:	70 10       	cpse	r7, r0
      9a:	99 0f       	add	r25, r25
      9c:	ee 0f       	add	r30, r30
      9e:	b5 0e       	add	r11, r21
      a0:	c3 0e       	add	r12, r19
      a2:	a5 0f       	add	r26, r21
      a4:	0e 10       	cpse	r0, r14
      a6:	21 10       	cpse	r2, r1
      a8:	27 10       	cpse	r2, r7
      aa:	34 10       	cpse	r3, r4
      ac:	58 10       	cpse	r5, r8
      ae:	5a 10       	cpse	r5, r10
      b0:	66 10       	cpse	r6, r6
      b2:	df 10       	cpse	r13, r15
      b4:	2f 11       	cpse	r18, r15
      b6:	45 11       	cpse	r20, r5
      b8:	54 11       	cpse	r21, r4
      ba:	8b 11       	cpse	r24, r11
      bc:	a2 11       	cpse	r26, r2
      be:	b4 11       	cpse	r27, r4
      c0:	c2 11       	cpse	r28, r2
      c2:	d1 13       	cpse	r29, r17
      c4:	b5 12       	cpse	r11, r21
      c6:	c7 12       	cpse	r12, r23
      c8:	ef 12       	cpse	r14, r31
      ca:	fb 12       	cpse	r15, r27
      cc:	07 13       	cpse	r16, r23
      ce:	54 12       	cpse	r5, r20
      d0:	66 12       	cpse	r6, r22
      d2:	84 12       	cpse	r8, r20
      d4:	90 12       	cpse	r9, r16
      d6:	18 13       	cpse	r17, r24
      d8:	2c 13       	cpse	r18, r28
      da:	6b 13       	cpse	r22, r27
      dc:	78 13       	cpse	r23, r24
      de:	7a 13       	cpse	r23, r26
      e0:	81 13       	cpse	r24, r17
      e2:	8b 13       	cpse	r24, r27
      e4:	98 13       	cpse	r25, r24
      e6:	9e 13       	cpse	r25, r30
      e8:	a9 13       	cpse	r26, r25
      ea:	92 15       	cp	r25, r2
      ec:	a9 15       	cp	r26, r9
      ee:	1e 17       	cp	r17, r30
      f0:	49 16       	cp	r4, r25
      f2:	08 16       	cp	r0, r24
      f4:	1e 16       	cp	r1, r30
      f6:	1e 17       	cp	r17, r30
      f8:	1e 17       	cp	r17, r30
      fa:	63 16       	cp	r6, r19
      fc:	7f 16       	cp	r7, r31
      fe:	1e 17       	cp	r17, r30
     100:	1e 17       	cp	r17, r30
     102:	99 16       	cp	r9, r25
     104:	1e 17       	cp	r17, r30
     106:	c3 16       	cp	r12, r19
     108:	c8 16       	cp	r12, r24
     10a:	d1 16       	cp	r13, r17
     10c:	1e 17       	cp	r17, r30
     10e:	1e 17       	cp	r17, r30
     110:	9f 16       	cp	r9, r31
     112:	af 16       	cp	r10, r31
     114:	b4 16       	cp	r11, r20
     116:	b9 16       	cp	r11, r25
     118:	be 16       	cp	r11, r30
     11a:	1e 17       	cp	r17, r30
     11c:	1e 17       	cp	r17, r30
     11e:	d6 16       	cp	r13, r22
     120:	cc 15       	cp	r28, r12
     122:	eb 16       	cp	r14, r27
     124:	f9 16       	cp	r15, r25
     126:	03 17       	cp	r16, r19
     128:	07 17       	cp	r16, r23
     12a:	0a 17       	cp	r16, r26

0000012c <__c.3484>:
     12c:	49 6e 69 74 69 61 6c 69 7a 65 64 00                 Initialized.

00000138 <__c.3121>:
     138:	25 64 00                                            %d.

0000013b <__c.3116>:
     13b:	25 73 25 73 00                                      %s%s.

00000140 <__c.3114>:
     140:	30 32 25 2e 32 64 00                                02%.2d.

00000147 <__c.3084>:
     147:	25 64 00                                            %d.

0000014a <__c.3079>:
     14a:	30 31 25 2e 32 64 25 2e 31 64 25 2e 31 64 25 73     01%.2d%.1d%.1d%s
     15a:	25 73 25 73 00                                      %s%s.

0000015f <__c.2951>:
     15f:	41 75 74 68 6f 72 69 7a 65 64 00                    Authorized.

0000016a <__c.2927>:
     16a:	50 6f 6f 6c 52 65 73 74 61 72 74 65 64 00           PoolRestarted.

00000178 <__c.2781>:
     178:	50 6f 6f 6c 52 65 73 74 61 72 74 65 64 00           PoolRestarted.

00000186 <__c.2779>:
     186:	57 50 6f 6f 6c 3a 25 64 00                          WPool:%d.

0000018f <__c.2379>:
     18f:	50 75 6d 70 3a 25 64 00 00                          Pump:%d..

00000198 <__ctors_end>:
     198:	11 24       	eor	r1, r1
     19a:	1f be       	out	0x3f, r1	; 63
     19c:	cf ef       	ldi	r28, 0xFF	; 255
     19e:	d4 e0       	ldi	r29, 0x04	; 4
     1a0:	de bf       	out	0x3e, r29	; 62
     1a2:	cd bf       	out	0x3d, r28	; 61

000001a4 <__do_copy_data>:
     1a4:	11 e0       	ldi	r17, 0x01	; 1
     1a6:	a0 e0       	ldi	r26, 0x00	; 0
     1a8:	b1 e0       	ldi	r27, 0x01	; 1
     1aa:	ec e9       	ldi	r30, 0x9C	; 156
     1ac:	f7 e3       	ldi	r31, 0x37	; 55
     1ae:	02 c0       	rjmp	.+4      	; 0x1b4 <.do_copy_data_start>

000001b0 <.do_copy_data_loop>:
     1b0:	05 90       	lpm	r0, Z+
     1b2:	0d 92       	st	X+, r0

000001b4 <.do_copy_data_start>:
     1b4:	ae 30       	cpi	r26, 0x0E	; 14
     1b6:	b1 07       	cpc	r27, r17
     1b8:	d9 f7       	brne	.-10     	; 0x1b0 <.do_copy_data_loop>

000001ba <__do_clear_bss>:
     1ba:	14 e0       	ldi	r17, 0x04	; 4
     1bc:	ae e0       	ldi	r26, 0x0E	; 14
     1be:	b1 e0       	ldi	r27, 0x01	; 1
     1c0:	01 c0       	rjmp	.+2      	; 0x1c4 <.do_clear_bss_start>

000001c2 <.do_clear_bss_loop>:
     1c2:	1d 92       	st	X+, r1

000001c4 <.do_clear_bss_start>:
     1c4:	a7 33       	cpi	r26, 0x37	; 55
     1c6:	b1 07       	cpc	r27, r17
     1c8:	e1 f7       	brne	.-8      	; 0x1c2 <.do_clear_bss_loop>
     1ca:	0e 94 31 15 	call	0x2a62	; 0x2a62 <main>
     1ce:	0c 94 cc 1b 	jmp	0x3798	; 0x3798 <_exit>

000001d2 <__bad_interrupt>:
     1d2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000001d6 <__vector_17>:

char SequencePool=0;//LivePooling Detection
char TimWatchSequence,SequenceTimeout;
char PumpTransDigit=6,PumpTotalDigit=8;

ISR(TIMER0_OVF_vect) {
     1d6:	1f 92       	push	r1
     1d8:	0f 92       	push	r0
     1da:	0f b6       	in	r0, 0x3f	; 63
     1dc:	0f 92       	push	r0
     1de:	11 24       	eor	r1, r1
     1e0:	2f 93       	push	r18
     1e2:	3f 93       	push	r19
     1e4:	5f 93       	push	r21
     1e6:	6f 93       	push	r22
     1e8:	7f 93       	push	r23
     1ea:	8f 93       	push	r24
     1ec:	9f 93       	push	r25
     1ee:	af 93       	push	r26
     1f0:	bf 93       	push	r27
    //TCNT1H=0xFD;//Ov:10ms
	//TCNT1L=0xC0;
    static char TimerExp=0;	     
    TimerExp++;
     1f2:	80 91 3a 01 	lds	r24, 0x013A
     1f6:	8f 5f       	subi	r24, 0xFF	; 255
     1f8:	80 93 3a 01 	sts	0x013A, r24
	if ((TimerExp%BlinkRate)==0){
     1fc:	60 91 11 04 	lds	r22, 0x0411
     200:	0e 94 53 1b 	call	0x36a6	; 0x36a6 <__udivmodqi4>
     204:	99 23       	and	r25, r25
     206:	21 f4       	brne	.+8      	; 0x210 <__vector_17+0x3a>
		PORTE ^= 0x04;
     208:	87 b1       	in	r24, 0x07	; 7
     20a:	94 e0       	ldi	r25, 0x04	; 4
     20c:	89 27       	eor	r24, r25
     20e:	87 b9       	out	0x07, r24	; 7
	}
	TimExp++;
     210:	20 91 1f 01 	lds	r18, 0x011F
     214:	30 91 20 01 	lds	r19, 0x0120
     218:	2f 5f       	subi	r18, 0xFF	; 255
     21a:	3f 4f       	sbci	r19, 0xFF	; 255
     21c:	30 93 20 01 	sts	0x0120, r19
     220:	20 93 1f 01 	sts	0x011F, r18
	if ((TimExp%2)==0) TimSend++;
     224:	20 fd       	sbrc	r18, 0
     226:	09 c0       	rjmp	.+18     	; 0x23a <__vector_17+0x64>
     228:	80 91 23 04 	lds	r24, 0x0423
     22c:	90 91 24 04 	lds	r25, 0x0424
     230:	01 96       	adiw	r24, 0x01	; 1
     232:	90 93 24 04 	sts	0x0424, r25
     236:	80 93 23 04 	sts	0x0423, r24
	if ((TimExp%100)==0) TimWatchSequence++;
     23a:	c9 01       	movw	r24, r18
     23c:	64 e6       	ldi	r22, 0x64	; 100
     23e:	70 e0       	ldi	r23, 0x00	; 0
     240:	0e 94 5f 1b 	call	0x36be	; 0x36be <__udivmodhi4>
     244:	89 2b       	or	r24, r25
     246:	29 f4       	brne	.+10     	; 0x252 <__vector_17+0x7c>
     248:	80 91 de 02 	lds	r24, 0x02DE
     24c:	8f 5f       	subi	r24, 0xFF	; 255
     24e:	80 93 de 02 	sts	0x02DE, r24
	TimReceive++;
     252:	80 91 0f 04 	lds	r24, 0x040F
     256:	90 91 10 04 	lds	r25, 0x0410
     25a:	01 96       	adiw	r24, 0x01	; 1
     25c:	90 93 10 04 	sts	0x0410, r25
     260:	80 93 0f 04 	sts	0x040F, r24
	TimDelayNextPump++;
     264:	80 91 21 01 	lds	r24, 0x0121
     268:	90 91 22 01 	lds	r25, 0x0122
     26c:	01 96       	adiw	r24, 0x01	; 1
     26e:	90 93 22 01 	sts	0x0122, r25
     272:	80 93 21 01 	sts	0x0121, r24
}
     276:	bf 91       	pop	r27
     278:	af 91       	pop	r26
     27a:	9f 91       	pop	r25
     27c:	8f 91       	pop	r24
     27e:	7f 91       	pop	r23
     280:	6f 91       	pop	r22
     282:	5f 91       	pop	r21
     284:	3f 91       	pop	r19
     286:	2f 91       	pop	r18
     288:	0f 90       	pop	r0
     28a:	0f be       	out	0x3f, r0	; 63
     28c:	0f 90       	pop	r0
     28e:	1f 90       	pop	r1
     290:	18 95       	reti

00000292 <DoNothing>:
	}
}

void DoNothing(){

}
     292:	08 95       	ret

00000294 <InitMem>:

void InitMem(){
     //IFType=IT_SLAVE;
}
     294:	08 95       	ret

00000296 <GetBaudrate>:

int GetBaudrate(char brSetting){
int Result=0;
     switch(brSetting){
     296:	82 30       	cpi	r24, 0x02	; 2
     298:	59 f0       	breq	.+22     	; 0x2b0 <GetBaudrate+0x1a>
     29a:	82 30       	cpi	r24, 0x02	; 2
     29c:	18 f0       	brcs	.+6      	; 0x2a4 <GetBaudrate+0xe>
     29e:	83 30       	cpi	r24, 0x03	; 3
     2a0:	21 f4       	brne	.+8      	; 0x2aa <GetBaudrate+0x14>
     2a2:	09 c0       	rjmp	.+18     	; 0x2b6 <GetBaudrate+0x20>
     2a4:	20 e8       	ldi	r18, 0x80	; 128
     2a6:	35 e2       	ldi	r19, 0x25	; 37
     2a8:	08 c0       	rjmp	.+16     	; 0x2ba <GetBaudrate+0x24>
     2aa:	20 e0       	ldi	r18, 0x00	; 0
     2ac:	30 e0       	ldi	r19, 0x00	; 0
     2ae:	05 c0       	rjmp	.+10     	; 0x2ba <GetBaudrate+0x24>
     2b0:	20 e0       	ldi	r18, 0x00	; 0
     2b2:	3b e4       	ldi	r19, 0x4B	; 75
     2b4:	02 c0       	rjmp	.+4      	; 0x2ba <GetBaudrate+0x24>
	 case br9600: 
	      Result=9600;
	      break;
	 case br19200:
	      Result=19200;
	      break;
     2b6:	2b e9       	ldi	r18, 0x9B	; 155
     2b8:	36 e1       	ldi	r19, 0x16	; 22
	 case br5787:
	      Result=5787;
     	  break;	 
	 }
   return Result;
}
     2ba:	c9 01       	movw	r24, r18
     2bc:	08 95       	ret

000002be <GetIFType>:
char GetIFType(){
char Result=IT_NONE;
     

return Result;
}
     2be:	80 e0       	ldi	r24, 0x00	; 0
     2c0:	08 95       	ret

000002c2 <SystemComLevel>:
}



void SystemComLevel(char ComLevel){
	 sbi(PORTA,0);  // rs232 off
     2c2:	d8 9a       	sbi	0x1b, 0	; 27
	 sbi(PORTA,3);  // rs485 off
     2c4:	db 9a       	sbi	0x1b, 3	; 27
	 switch(ComLevel){
     2c6:	81 30       	cpi	r24, 0x01	; 1
     2c8:	21 f0       	breq	.+8      	; 0x2d2 <SystemComLevel+0x10>
     2ca:	82 30       	cpi	r24, 0x02	; 2
     2cc:	19 f4       	brne	.+6      	; 0x2d4 <SystemComLevel+0x12>
	 case CL_485:
		  //sbi(PORTA,0);  // rs232 off
		  cbi(PORTA,3);  // rs485 on	 
     2ce:	db 98       	cbi	0x1b, 3	; 27
     2d0:	08 95       	ret
	      break;
     case CL_232:
		  cbi(PORTA,0);  // rs232 on
     2d2:	d8 98       	cbi	0x1b, 0	; 27
     2d4:	08 95       	ret

000002d6 <StatePrintf>:
	System485(DIR_RX);//ReceiveMode
}

void StatePrintf(char *strState){
     //TerminalSendf(1,strState);
}
     2d6:	08 95       	ret

000002d8 <systemAntiFreeze>:
//15694 95.8% -> 14746 90.0%

void systemAntiFreeze(){
static char zSequence=0;

	if (IFType==IT_STANDALONE){
     2d8:	80 91 00 01 	lds	r24, 0x0100
     2dc:	82 30       	cpi	r24, 0x02	; 2
     2de:	a9 f4       	brne	.+42     	; 0x30a <systemAntiFreeze+0x32>
	    if (SequencePool>zSequence){
     2e0:	20 91 26 01 	lds	r18, 0x0126
     2e4:	80 91 35 01 	lds	r24, 0x0135
     2e8:	82 17       	cp	r24, r18
     2ea:	10 f4       	brcc	.+4      	; 0x2f0 <systemAntiFreeze+0x18>
		    TimWatchSequence=0;
     2ec:	10 92 de 02 	sts	0x02DE, r1
		}
        if (TimWatchSequence>SequenceTimeout){
     2f0:	90 91 de 02 	lds	r25, 0x02DE
     2f4:	80 91 36 04 	lds	r24, 0x0436
     2f8:	89 17       	cp	r24, r25
     2fa:	28 f4       	brcc	.+10     	; 0x306 <systemAntiFreeze+0x2e>
		    TimWatchSequence=0; 
     2fc:	10 92 de 02 	sts	0x02DE, r1
		    //SendAcknoledge(SC_FREEZE,SequenceTimeout);
		    IsRestartPooling=True;
     300:	81 e0       	ldi	r24, 0x01	; 1
     302:	80 93 03 01 	sts	0x0103, r24
		}
		zSequence=SequencePool;
     306:	20 93 35 01 	sts	0x0135, r18
     30a:	08 95       	ret

0000030c <CRC_Wayne>:

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
     30c:	70 e0       	ldi	r23, 0x00	; 0
     30e:	68 27       	eor	r22, r24
     310:	79 27       	eor	r23, r25
     312:	20 e0       	ldi	r18, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
     314:	41 e0       	ldi	r20, 0x01	; 1
     316:	50 ea       	ldi	r21, 0xA0	; 160
     318:	cb 01       	movw	r24, r22
     31a:	96 95       	lsr	r25
     31c:	87 95       	ror	r24
     31e:	60 ff       	sbrs	r22, 0
     320:	04 c0       	rjmp	.+8      	; 0x32a <CRC_Wayne+0x1e>
     322:	bc 01       	movw	r22, r24
     324:	64 27       	eor	r22, r20
     326:	75 27       	eor	r23, r21
     328:	01 c0       	rjmp	.+2      	; 0x32c <CRC_Wayne+0x20>
        else xCRC= (xCRC>> 1);
     32a:	bc 01       	movw	r22, r24
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
     32c:	2f 5f       	subi	r18, 0xFF	; 255
     32e:	28 30       	cpi	r18, 0x08	; 8
     330:	99 f7       	brne	.-26     	; 0x318 <CRC_Wayne+0xc>
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
        else xCRC= (xCRC>> 1);
    }
    return xCRC;
}
     332:	cb 01       	movw	r24, r22
     334:	08 95       	ret

00000336 <sys_delay>:

void sys_delay(unsigned int dV){
}
     336:	08 95       	ret

00000338 <System485>:

void System485(char Dir){//DIR_TX, DIR_RX	 
     switch(Dir){
     338:	81 30       	cpi	r24, 0x01	; 1
     33a:	19 f0       	breq	.+6      	; 0x342 <System485+0xa>
     33c:	82 30       	cpi	r24, 0x02	; 2
     33e:	71 f4       	brne	.+28     	; 0x35c <System485+0x24>
     340:	07 c0       	rjmp	.+14     	; 0x350 <System485+0x18>
	 case DIR_TX:
	      sbi(PORTB,1);
     342:	c1 9a       	sbi	0x18, 1	; 24
		  sbi(DDRB,1);
     344:	b9 9a       	sbi	0x17, 1	; 23
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     346:	84 ec       	ldi	r24, 0xC4	; 196
     348:	99 e0       	ldi	r25, 0x09	; 9
     34a:	01 97       	sbiw	r24, 0x01	; 1
     34c:	f1 f7       	brne	.-4      	; 0x34a <System485+0x12>
     34e:	08 95       	ret
		  _delay_ms(10);
	      break;
	 case DIR_RX:
          _delay_ms(7);
		  sbi(DDRB,1);
     350:	86 ed       	ldi	r24, 0xD6	; 214
     352:	96 e0       	ldi	r25, 0x06	; 6
     354:	01 97       	sbiw	r24, 0x01	; 1
     356:	f1 f7       	brne	.-4      	; 0x354 <System485+0x1c>
     358:	b9 9a       	sbi	0x17, 1	; 23
		  cbi(PORTB,1);		  
     35a:	c1 98       	cbi	0x18, 1	; 24
     35c:	08 95       	ret

0000035e <WayneTestSend>:
	 _uart(0,1,xData);
	 System485(DIR_RX);//ReceiveMode
}

void WayneTestSend(){
}
     35e:	08 95       	ret

00000360 <ExtractValue>:
     case CMD_REQ_GLOBAL_STATUS_2:
  	      break;
	 }	 
}

void ExtractValue(char *Source,char FirstPos,char nCount,char*Dest){//WayneRxBuffer,13,16-13,strVolume);
     360:	fc 01       	movw	r30, r24
     362:	e6 0f       	add	r30, r22
     364:	f1 1d       	adc	r31, r1
     366:	d9 01       	movw	r26, r18
     368:	90 e0       	ldi	r25, 0x00	; 0
     36a:	0d c0       	rjmp	.+26     	; 0x386 <ExtractValue+0x26>
     char i;
	 for(i=0;i<nCount;i++){
	     Dest[2*i]=(Source[FirstPos+i]>>4)+'0';
     36c:	80 81       	ld	r24, Z
     36e:	82 95       	swap	r24
     370:	8f 70       	andi	r24, 0x0F	; 15
     372:	80 5d       	subi	r24, 0xD0	; 208
     374:	8c 93       	st	X, r24
	     Dest[(2*i)+1]=(Source[FirstPos+i]&0x0F)+'0';	 
     376:	81 91       	ld	r24, Z+
     378:	8f 70       	andi	r24, 0x0F	; 15
     37a:	80 5d       	subi	r24, 0xD0	; 208
     37c:	11 96       	adiw	r26, 0x01	; 1
     37e:	8c 93       	st	X, r24
     380:	11 97       	sbiw	r26, 0x01	; 1
	 }	 
}

void ExtractValue(char *Source,char FirstPos,char nCount,char*Dest){//WayneRxBuffer,13,16-13,strVolume);
     char i;
	 for(i=0;i<nCount;i++){
     382:	9f 5f       	subi	r25, 0xFF	; 255
     384:	12 96       	adiw	r26, 0x02	; 2
     386:	94 17       	cp	r25, r20
     388:	88 f3       	brcs	.-30     	; 0x36c <ExtractValue+0xc>
	     Dest[2*i]=(Source[FirstPos+i]>>4)+'0';
	     Dest[(2*i)+1]=(Source[FirstPos+i]&0x0F)+'0';	 
	 }Dest[2*nCount]=0;
     38a:	e4 2f       	mov	r30, r20
     38c:	f0 e0       	ldi	r31, 0x00	; 0
     38e:	ee 0f       	add	r30, r30
     390:	ff 1f       	adc	r31, r31
     392:	e2 0f       	add	r30, r18
     394:	f3 1f       	adc	r31, r19
     396:	10 82       	st	Z, r1
}
     398:	08 95       	ret

0000039a <InitPumpData>:
}

void InitPumpData(){
char i;
char strSerial[20];
     if (StandaloneType==ST_GILBARCO){
     39a:	80 91 01 01 	lds	r24, 0x0101
     39e:	81 30       	cpi	r24, 0x01	; 1
     3a0:	01 f5       	brne	.+64     	; 0x3e2 <InitPumpData+0x48>
     3a2:	80 e0       	ldi	r24, 0x00	; 0
     3a4:	90 e0       	ldi	r25, 0x00	; 0
	     for(i=0;i<16;i++){
		     IsRequestTransInfo[i]=False;
			 IsRequestTotalizerInfo[i]=False;
			 zPumpStatus[i]=PUMP_NONE;
     3a6:	2e e0       	ldi	r18, 0x0E	; 14
void InitPumpData(){
char i;
char strSerial[20];
     if (StandaloneType==ST_GILBARCO){
	     for(i=0;i<16;i++){
		     IsRequestTransInfo[i]=False;
     3a8:	fc 01       	movw	r30, r24
     3aa:	e6 57       	subi	r30, 0x76	; 118
     3ac:	fd 4f       	sbci	r31, 0xFD	; 253
     3ae:	10 82       	st	Z, r1
			 IsRequestTotalizerInfo[i]=False;
     3b0:	fc 01       	movw	r30, r24
     3b2:	ed 5e       	subi	r30, 0xED	; 237
     3b4:	fb 4f       	sbci	r31, 0xFB	; 251
     3b6:	10 82       	st	Z, r1
			 zPumpStatus[i]=PUMP_NONE;
     3b8:	fc 01       	movw	r30, r24
     3ba:	e5 56       	subi	r30, 0x65	; 101
     3bc:	fd 4f       	sbci	r31, 0xFD	; 253
     3be:	20 83       	st	Z, r18
			 PumpStatus[i]=PUMP_NONE;
     3c0:	fc 01       	movw	r30, r24
     3c2:	eb 54       	subi	r30, 0x4B	; 75
     3c4:	fc 4f       	sbci	r31, 0xFC	; 252
     3c6:	20 83       	st	Z, r18
			 NoPumpCount[i]=0;
     3c8:	fc 01       	movw	r30, r24
     3ca:	eb 5d       	subi	r30, 0xDB	; 219
     3cc:	fb 4f       	sbci	r31, 0xFB	; 251
     3ce:	10 82       	st	Z, r1
			 PumpLock[i]=False;
     3d0:	fc 01       	movw	r30, r24
     3d2:	e4 53       	subi	r30, 0x34	; 52
     3d4:	fd 4f       	sbci	r31, 0xFD	; 253
     3d6:	10 82       	st	Z, r1
     3d8:	01 96       	adiw	r24, 0x01	; 1

void InitPumpData(){
char i;
char strSerial[20];
     if (StandaloneType==ST_GILBARCO){
	     for(i=0;i<16;i++){
     3da:	80 31       	cpi	r24, 0x10	; 16
     3dc:	91 05       	cpc	r25, r1
     3de:	21 f7       	brne	.-56     	; 0x3a8 <InitPumpData+0xe>
     3e0:	08 95       	ret
			 zPumpStatus[i]=PUMP_NONE;
			 PumpStatus[i]=PUMP_NONE;
			 NoPumpCount[i]=0;
			 PumpLock[i]=False;
		 }
     }else if (StandaloneType==ST_WAYNE_DART){
     3e2:	80 91 01 01 	lds	r24, 0x0101
     3e6:	82 30       	cpi	r24, 0x02	; 2
     3e8:	f1 f4       	brne	.+60     	; 0x426 <InitPumpData+0x8c>
     3ea:	80 e0       	ldi	r24, 0x00	; 0
     3ec:	90 e0       	ldi	r25, 0x00	; 0
	     for(i=0;i<16;i++){
		     IsRequestTransInfo[i]=False;
     3ee:	fc 01       	movw	r30, r24
     3f0:	e6 57       	subi	r30, 0x76	; 118
     3f2:	fd 4f       	sbci	r31, 0xFD	; 253
     3f4:	10 82       	st	Z, r1
			 IsRequestTotalizerInfo[i]=False;
     3f6:	fc 01       	movw	r30, r24
     3f8:	ed 5e       	subi	r30, 0xED	; 237
     3fa:	fb 4f       	sbci	r31, 0xFB	; 251
     3fc:	10 82       	st	Z, r1
			 zPumpStatus[i]=PW_NONE;
     3fe:	fc 01       	movw	r30, r24
     400:	e5 56       	subi	r30, 0x65	; 101
     402:	fd 4f       	sbci	r31, 0xFD	; 253
     404:	10 82       	st	Z, r1
			 PumpStatus[i]=PW_NONE;
     406:	fc 01       	movw	r30, r24
     408:	eb 54       	subi	r30, 0x4B	; 75
     40a:	fc 4f       	sbci	r31, 0xFC	; 252
     40c:	10 82       	st	Z, r1
			 NoPumpCount[i]=0;
     40e:	fc 01       	movw	r30, r24
     410:	eb 5d       	subi	r30, 0xDB	; 219
     412:	fb 4f       	sbci	r31, 0xFB	; 251
     414:	10 82       	st	Z, r1
			 PumpLock[i]=False;
     416:	fc 01       	movw	r30, r24
     418:	e4 53       	subi	r30, 0x34	; 52
     41a:	fd 4f       	sbci	r31, 0xFD	; 253
     41c:	10 82       	st	Z, r1
     41e:	01 96       	adiw	r24, 0x01	; 1
			 PumpStatus[i]=PUMP_NONE;
			 NoPumpCount[i]=0;
			 PumpLock[i]=False;
		 }
     }else if (StandaloneType==ST_WAYNE_DART){
	     for(i=0;i<16;i++){
     420:	80 31       	cpi	r24, 0x10	; 16
     422:	91 05       	cpc	r25, r1
     424:	21 f7       	brne	.-56     	; 0x3ee <InitPumpData+0x54>
     426:	08 95       	ret

00000428 <uart_init>:
     UBRR0H=0;
     UBRR0L=158;// baud 5787
     UCSR0C=(1<<URSEL0) | (1<<UPM01) | (1<<UCSZ01) | (1<<UCSZ00); // UPM01 untuk set even parity
     sei();
	 */
}
     428:	08 95       	ret

0000042a <InitSystemTimer>:

void InitSystemTimer(){
	TCCR0 |= (1 << CS02) | (1 << CS00);
     42a:	83 b7       	in	r24, 0x33	; 51
     42c:	85 60       	ori	r24, 0x05	; 5
     42e:	83 bf       	out	0x33, r24	; 51
	TIMSK |= _BV(TOIE0);
     430:	89 b7       	in	r24, 0x39	; 57
     432:	82 60       	ori	r24, 0x02	; 2
     434:	89 bf       	out	0x39, r24	; 57
}
     436:	08 95       	ret

00000438 <GetPumpID>:

char GetPumpID(char data){
     char xPumpID=0;
	 xPumpID=(data&0x0F);
	 return xPumpID;
}
     438:	8f 70       	andi	r24, 0x0F	; 15
     43a:	08 95       	ret

0000043c <GetResponse>:

char GetResponse(char data){
     char Response=0;
	 Response=((data&0xF0)>>4);
	 return Response;
}
     43c:	82 95       	swap	r24
     43e:	8f 70       	andi	r24, 0x0F	; 15
     440:	08 95       	ret

00000442 <ShiftArray>:
	 //_delay_ms(10);
}

void ShiftArray(char *strShifted, unsigned int nCount){

}
     442:	08 95       	ret

00000444 <systemServiceSPI>:

void systemServiceSPI(){
}
     444:	08 95       	ret

00000446 <SaveTransactionData>:
	    strSource[i]=strResult[i];
	    strSource[i+1]=0;
	 }
}

void SaveTransactionData(char data){
     446:	28 2f       	mov	r18, r24
     static char SavePipeline=spNone;
	 static char IdxData=0;
	 switch(SavePipeline){
     448:	80 91 2b 01 	lds	r24, 0x012B
     44c:	86 30       	cpi	r24, 0x06	; 6
     44e:	41 f1       	breq	.+80     	; 0x4a0 <SaveTransactionData+0x5a>
     450:	87 30       	cpi	r24, 0x07	; 7
     452:	30 f4       	brcc	.+12     	; 0x460 <SaveTransactionData+0x1a>
     454:	84 30       	cpi	r24, 0x04	; 4
     456:	51 f0       	breq	.+20     	; 0x46c <SaveTransactionData+0x26>
     458:	85 30       	cpi	r24, 0x05	; 5
     45a:	09 f0       	breq	.+2      	; 0x45e <SaveTransactionData+0x18>
     45c:	56 c0       	rjmp	.+172    	; 0x50a <__stack+0xb>
     45e:	17 c0       	rjmp	.+46     	; 0x48e <SaveTransactionData+0x48>
     460:	87 30       	cpi	r24, 0x07	; 7
     462:	79 f1       	breq	.+94     	; 0x4c2 <SaveTransactionData+0x7c>
     464:	8a 30       	cpi	r24, 0x0A	; 10
     466:	09 f0       	breq	.+2      	; 0x46a <SaveTransactionData+0x24>
     468:	50 c0       	rjmp	.+160    	; 0x50a <__stack+0xb>
     46a:	3b c0       	rjmp	.+118    	; 0x4e2 <SaveTransactionData+0x9c>
     case spPumpIdentifier:
	      if (IdxData==1)rxPumpId=FilterBCD(data);
     46c:	90 91 2a 01 	lds	r25, 0x012A
     470:	91 30       	cpi	r25, 0x01	; 1
     472:	29 f4       	brne	.+10     	; 0x47e <SaveTransactionData+0x38>
     474:	82 2f       	mov	r24, r18
     476:	8f 70       	andi	r24, 0x0F	; 15
     478:	80 93 3b 01 	sts	0x013B, r24
     47c:	43 c0       	rjmp	.+134    	; 0x504 <__stack+0x5>
		  else
	      if (IdxData==2)NozzleId=FilterBCD(data);
     47e:	92 30       	cpi	r25, 0x02	; 2
     480:	09 f0       	breq	.+2      	; 0x484 <SaveTransactionData+0x3e>
     482:	40 c0       	rjmp	.+128    	; 0x504 <__stack+0x5>
     484:	82 2f       	mov	r24, r18
     486:	8f 70       	andi	r24, 0x0F	; 15
     488:	80 93 e0 02 	sts	0x02E0, r24
     48c:	3b c0       	rjmp	.+118    	; 0x504 <__stack+0x5>
          IdxData++;
      	  break;
     case spProductGrade:
	      if (IdxData==0)GradeId=FilterBCD(data);
     48e:	90 91 2a 01 	lds	r25, 0x012A
     492:	99 23       	and	r25, r25
     494:	b9 f5       	brne	.+110    	; 0x504 <__stack+0x5>
     496:	82 2f       	mov	r24, r18
     498:	8f 70       	andi	r24, 0x0F	; 15
     49a:	80 93 f6 02 	sts	0x02F6, r24
     49e:	32 c0       	rjmp	.+100    	; 0x504 <__stack+0x5>
		  IdxData++;
      	  break;
     case spProductPrice:	       
          if (data!=0xF9){		      
     4a0:	29 3f       	cpi	r18, 0xF9	; 249
     4a2:	09 f4       	brne	.+2      	; 0x4a6 <SaveTransactionData+0x60>
     4a4:	40 c0       	rjmp	.+128    	; 0x526 <__stack+0x27>
		      strUnitPrice[IdxData]=BCD2Char(FilterBCD(data));
     4a6:	90 91 2a 01 	lds	r25, 0x012A
     4aa:	e9 2f       	mov	r30, r25
     4ac:	f0 e0       	ldi	r31, 0x00	; 0
	 Dest[Length]=0;
}

char FilterBCD(char data){
     char Result;
	 Result=(data&0x0F);
     4ae:	82 2f       	mov	r24, r18
     4b0:	8f 70       	andi	r24, 0x0F	; 15
}

char BCD2Char(char data){
     char Result;
	 Result=0;
	 if ((data>=0)&&(data<=9)) 
     4b2:	8a 30       	cpi	r24, 0x0A	; 10
     4b4:	10 f0       	brcs	.+4      	; 0x4ba <SaveTransactionData+0x74>
     4b6:	80 e3       	ldi	r24, 0x30	; 48
     4b8:	01 c0       	rjmp	.+2      	; 0x4bc <SaveTransactionData+0x76>
	     Result='0'+data;
     4ba:	80 5d       	subi	r24, 0xD0	; 208
	      if (IdxData==0)GradeId=FilterBCD(data);
		  IdxData++;
      	  break;
     case spProductPrice:	       
          if (data!=0xF9){		      
		      strUnitPrice[IdxData]=BCD2Char(FilterBCD(data));
     4bc:	e4 55       	subi	r30, 0x54	; 84
     4be:	fd 4f       	sbci	r31, 0xFD	; 253
     4c0:	1f c0       	rjmp	.+62     	; 0x500 <__stack+0x1>
              strUnitPrice[IdxData+1]=0;
	          IdxData++;
			  }
	  	  break;
     case spProductVolume:
          if (data!=0xFA){//Maks 7 Digit 0000123
     4c2:	2a 3f       	cpi	r18, 0xFA	; 250
     4c4:	91 f1       	breq	.+100    	; 0x52a <__stack+0x2b>
              strVolume[IdxData]=BCD2Char(FilterBCD(data));
     4c6:	90 91 2a 01 	lds	r25, 0x012A
     4ca:	e9 2f       	mov	r30, r25
     4cc:	f0 e0       	ldi	r31, 0x00	; 0
	 Dest[Length]=0;
}

char FilterBCD(char data){
     char Result;
	 Result=(data&0x0F);
     4ce:	82 2f       	mov	r24, r18
     4d0:	8f 70       	andi	r24, 0x0F	; 15
}

char BCD2Char(char data){
     char Result;
	 Result=0;
	 if ((data>=0)&&(data<=9)) 
     4d2:	8a 30       	cpi	r24, 0x0A	; 10
     4d4:	10 f0       	brcs	.+4      	; 0x4da <SaveTransactionData+0x94>
     4d6:	80 e3       	ldi	r24, 0x30	; 48
     4d8:	01 c0       	rjmp	.+2      	; 0x4dc <SaveTransactionData+0x96>
	     Result='0'+data;
     4da:	80 5d       	subi	r24, 0xD0	; 208
	          IdxData++;
			  }
	  	  break;
     case spProductVolume:
          if (data!=0xFA){//Maks 7 Digit 0000123
              strVolume[IdxData]=BCD2Char(FilterBCD(data));
     4dc:	e9 5a       	subi	r30, 0xA9	; 169
     4de:	fd 4f       	sbci	r31, 0xFD	; 253
     4e0:	0f c0       	rjmp	.+30     	; 0x500 <__stack+0x1>
              strVolume[IdxData+1]=0;
	          IdxData++;
		      }
	  	  break;
     case spProductMoney:
          if (data!=0xFB){
     4e2:	2b 3f       	cpi	r18, 0xFB	; 251
     4e4:	f1 f0       	breq	.+60     	; 0x522 <__stack+0x23>
              strAmount[IdxData]=BCD2Char(FilterBCD(data));
     4e6:	90 91 2a 01 	lds	r25, 0x012A
     4ea:	e9 2f       	mov	r30, r25
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
	 Dest[Length]=0;
}

char FilterBCD(char data){
     char Result;
	 Result=(data&0x0F);
     4ee:	82 2f       	mov	r24, r18
     4f0:	8f 70       	andi	r24, 0x0F	; 15
}

char BCD2Char(char data){
     char Result;
	 Result=0;
	 if ((data>=0)&&(data<=9)) 
     4f2:	8a 30       	cpi	r24, 0x0A	; 10
     4f4:	10 f0       	brcs	.+4      	; 0x4fa <SaveTransactionData+0xb4>
     4f6:	80 e3       	ldi	r24, 0x30	; 48
     4f8:	01 c0       	rjmp	.+2      	; 0x4fc <SaveTransactionData+0xb6>
	     Result='0'+data;
     4fa:	80 5d       	subi	r24, 0xD0	; 208
	          IdxData++;
		      }
	  	  break;
     case spProductMoney:
          if (data!=0xFB){
              strAmount[IdxData]=BCD2Char(FilterBCD(data));
     4fc:	e5 55       	subi	r30, 0x55	; 85
     4fe:	fc 4f       	sbci	r31, 0xFC	; 252
     500:	80 83       	st	Z, r24
              strAmount[IdxData+1]=0;
     502:	11 82       	std	Z+1, r1	; 0x01
              IdxData++;
     504:	9f 5f       	subi	r25, 0xFF	; 255
     506:	90 93 2a 01 	sts	0x012A, r25
     case spLRC:
	  	  break;	 
	 }

	 //Pipeline detection
	 if (data==0xF8){
     50a:	28 3f       	cpi	r18, 0xF8	; 248
     50c:	11 f4       	brne	.+4      	; 0x512 <__stack+0x13>
	     SavePipeline=spPumpIdentifier;
     50e:	84 e0       	ldi	r24, 0x04	; 4
     510:	0f c0       	rjmp	.+30     	; 0x530 <__stack+0x31>
		 IdxData=0;
	 }else if (data==0xF6){
     512:	26 3f       	cpi	r18, 0xF6	; 246
     514:	11 f4       	brne	.+4      	; 0x51a <__stack+0x1b>
	     SavePipeline=spProductGrade;
     516:	85 e0       	ldi	r24, 0x05	; 5
     518:	0b c0       	rjmp	.+22     	; 0x530 <__stack+0x31>
		 IdxData=0;
	 }else if (data==0xF7){
     51a:	27 3f       	cpi	r18, 0xF7	; 247
     51c:	11 f4       	brne	.+4      	; 0x522 <__stack+0x23>
	     SavePipeline=spProductPrice;
     51e:	86 e0       	ldi	r24, 0x06	; 6
     520:	07 c0       	rjmp	.+14     	; 0x530 <__stack+0x31>
		 IdxData=0;
	 }else if (data==0xF9){
     522:	29 3f       	cpi	r18, 0xF9	; 249
     524:	11 f4       	brne	.+4      	; 0x52a <__stack+0x2b>
	     SavePipeline=spProductVolume;
     526:	87 e0       	ldi	r24, 0x07	; 7
     528:	03 c0       	rjmp	.+6      	; 0x530 <__stack+0x31>
		 IdxData=0;
	 }else if (data==0xFA){
     52a:	2a 3f       	cpi	r18, 0xFA	; 250
     52c:	31 f4       	brne	.+12     	; 0x53a <__stack+0x3b>
	     SavePipeline=spProductMoney;
     52e:	8a e0       	ldi	r24, 0x0A	; 10
     530:	80 93 2b 01 	sts	0x012B, r24
		 IdxData=0;
     534:	10 92 2a 01 	sts	0x012A, r1
     538:	08 95       	ret
	 }else if (data==0xFB){
     53a:	2b 3f       	cpi	r18, 0xFB	; 251
     53c:	49 f4       	brne	.+18     	; 0x550 <__stack+0x51>
	     PumpTransDigit=IdxData;
     53e:	80 91 2a 01 	lds	r24, 0x012A
     542:	80 93 0b 01 	sts	0x010B, r24
	     SavePipeline=spLRC;
     546:	8b e0       	ldi	r24, 0x0B	; 11
     548:	80 93 2b 01 	sts	0x012B, r24
		 IdxData=0;
     54c:	10 92 2a 01 	sts	0x012A, r1
     550:	08 95       	ret

00000552 <SaveTotalizerData>:
	 }
}

void SaveTotalizerData(char data){
     552:	28 2f       	mov	r18, r24
     static char SavePipeline=spNone;
	 static char IdxData=0;

	 switch(SavePipeline){
     554:	80 91 29 01 	lds	r24, 0x0129
     558:	82 30       	cpi	r24, 0x02	; 2
     55a:	b9 f0       	breq	.+46     	; 0x58a <SaveTotalizerData+0x38>
     55c:	83 30       	cpi	r24, 0x03	; 3
     55e:	09 f4       	brne	.+2      	; 0x562 <SaveTotalizerData+0x10>
     560:	4a c0       	rjmp	.+148    	; 0x5f6 <SaveTotalizerData+0xa4>
     562:	81 30       	cpi	r24, 0x01	; 1
     564:	09 f0       	breq	.+2      	; 0x568 <SaveTotalizerData+0x16>
     566:	7e c0       	rjmp	.+252    	; 0x664 <SaveTotalizerData+0x112>
	 case spTotalizerGrade:
	      if (IdxData==0){
     568:	90 91 28 01 	lds	r25, 0x0128
     56c:	99 23       	and	r25, r25
     56e:	49 f4       	brne	.+18     	; 0x582 <SaveTotalizerData+0x30>
	 Dest[Length]=0;
}

char FilterBCD(char data){
     char Result;
	 Result=(data&0x0F);
     570:	82 2f       	mov	r24, r18
     572:	8f 70       	andi	r24, 0x0F	; 15
	 static char IdxData=0;

	 switch(SavePipeline){
	 case spTotalizerGrade:
	      if (IdxData==0){
		      TGradeId=FilterBCD(data);
     574:	80 93 dc 02 	sts	0x02DC, r24
			  //_uart(1,1,BCD2Char(TGradeId));
			  if (TGradeId>=5)TGradeId=5;
     578:	85 30       	cpi	r24, 0x05	; 5
     57a:	18 f0       	brcs	.+6      	; 0x582 <SaveTotalizerData+0x30>
     57c:	85 e0       	ldi	r24, 0x05	; 5
     57e:	80 93 dc 02 	sts	0x02DC, r24
			  }
          IdxData++; 
     582:	9f 5f       	subi	r25, 0xFF	; 255
     584:	90 93 28 01 	sts	0x0128, r25
     588:	6d c0       	rjmp	.+218    	; 0x664 <SaveTotalizerData+0x112>
	      break;
	 case spTotalizerVolume:
          if ((data&0xF0)==0xE0){
     58a:	82 2f       	mov	r24, r18
     58c:	80 7f       	andi	r24, 0xF0	; 240
     58e:	80 3e       	cpi	r24, 0xE0	; 224
     590:	09 f0       	breq	.+2      	; 0x594 <SaveTotalizerData+0x42>
     592:	68 c0       	rjmp	.+208    	; 0x664 <SaveTotalizerData+0x112>
		      PumpTotalizer.TotalGrade[TGradeId].strVolume[IdxData]=BCD2Char(FilterBCD(data));
     594:	50 91 dc 02 	lds	r21, 0x02DC
     598:	30 91 28 01 	lds	r19, 0x0128
     59c:	63 2f       	mov	r22, r19
     59e:	70 e0       	ldi	r23, 0x00	; 0
	 Dest[Length]=0;
}

char FilterBCD(char data){
     char Result;
	 Result=(data&0x0F);
     5a0:	82 2f       	mov	r24, r18
     5a2:	8f 70       	andi	r24, 0x0F	; 15
}

char BCD2Char(char data){
     char Result;
	 Result=0;
	 if ((data>=0)&&(data<=9)) 
     5a4:	8a 30       	cpi	r24, 0x0A	; 10
     5a6:	10 f0       	brcs	.+4      	; 0x5ac <SaveTotalizerData+0x5a>
     5a8:	40 e3       	ldi	r20, 0x30	; 48
     5aa:	02 c0       	rjmp	.+4      	; 0x5b0 <SaveTotalizerData+0x5e>
	     Result='0'+data;
     5ac:	48 2f       	mov	r20, r24
     5ae:	40 5d       	subi	r20, 0xD0	; 208
			  }
          IdxData++; 
	      break;
	 case spTotalizerVolume:
          if ((data&0xF0)==0xE0){
		      PumpTotalizer.TotalGrade[TGradeId].strVolume[IdxData]=BCD2Char(FilterBCD(data));
     5b0:	85 2f       	mov	r24, r21
     5b2:	90 e0       	ldi	r25, 0x00	; 0
     5b4:	fc 01       	movw	r30, r24
     5b6:	b5 e0       	ldi	r27, 0x05	; 5
     5b8:	ee 0f       	add	r30, r30
     5ba:	ff 1f       	adc	r31, r31
     5bc:	ba 95       	dec	r27
     5be:	e1 f7       	brne	.-8      	; 0x5b8 <SaveTotalizerData+0x66>
     5c0:	88 0f       	add	r24, r24
     5c2:	99 1f       	adc	r25, r25
     5c4:	e8 1b       	sub	r30, r24
     5c6:	f9 0b       	sbc	r31, r25
     5c8:	e6 0f       	add	r30, r22
     5ca:	f7 1f       	adc	r31, r23
     5cc:	e9 50       	subi	r30, 0x09	; 9
     5ce:	fd 4f       	sbci	r31, 0xFD	; 253
     5d0:	40 83       	st	Z, r20
			  //_uart(1,1,PumpTotalizer.TotalGrade[TGradeId].strVolume[IdxData]);

		      PumpTotalizer.TotalGrade[TGradeId].strVolume[IdxData+1]=0;
     5d2:	85 2f       	mov	r24, r21
     5d4:	90 e0       	ldi	r25, 0x00	; 0
     5d6:	fc 01       	movw	r30, r24
     5d8:	55 e0       	ldi	r21, 0x05	; 5
     5da:	ee 0f       	add	r30, r30
     5dc:	ff 1f       	adc	r31, r31
     5de:	5a 95       	dec	r21
     5e0:	e1 f7       	brne	.-8      	; 0x5da <SaveTotalizerData+0x88>
     5e2:	88 0f       	add	r24, r24
     5e4:	99 1f       	adc	r25, r25
     5e6:	e8 1b       	sub	r30, r24
     5e8:	f9 0b       	sbc	r31, r25
     5ea:	e9 50       	subi	r30, 0x09	; 9
     5ec:	fd 4f       	sbci	r31, 0xFD	; 253
     5ee:	e6 0f       	add	r30, r22
     5f0:	f7 1f       	adc	r31, r23
     5f2:	11 82       	std	Z+1, r1	; 0x01
     5f4:	34 c0       	rjmp	.+104    	; 0x65e <SaveTotalizerData+0x10c>
		      //TVolume[TGradeId][IdxData+1]=0;
		      IdxData++;
		  }
	      break;
	 case spTotalizerMoney:
          if ((data&0xF0)==0xE0){
     5f6:	82 2f       	mov	r24, r18
     5f8:	80 7f       	andi	r24, 0xF0	; 240
     5fa:	80 3e       	cpi	r24, 0xE0	; 224
     5fc:	99 f5       	brne	.+102    	; 0x664 <SaveTotalizerData+0x112>
	          //TMoney[TGradeId][IdxData]=BCD2Char(FilterBCD(data));
		      //TMoney[TGradeId][IdxData+1]=0;
		      PumpTotalizer.TotalGrade[TGradeId].strMoney[IdxData]=BCD2Char(FilterBCD(data));
     5fe:	70 91 dc 02 	lds	r23, 0x02DC
     602:	30 91 28 01 	lds	r19, 0x0128
     606:	43 2f       	mov	r20, r19
     608:	50 e0       	ldi	r21, 0x00	; 0
	 Dest[Length]=0;
}

char FilterBCD(char data){
     char Result;
	 Result=(data&0x0F);
     60a:	82 2f       	mov	r24, r18
     60c:	8f 70       	andi	r24, 0x0F	; 15
}

char BCD2Char(char data){
     char Result;
	 Result=0;
	 if ((data>=0)&&(data<=9)) 
     60e:	8a 30       	cpi	r24, 0x0A	; 10
     610:	10 f0       	brcs	.+4      	; 0x616 <SaveTotalizerData+0xc4>
     612:	60 e3       	ldi	r22, 0x30	; 48
     614:	02 c0       	rjmp	.+4      	; 0x61a <SaveTotalizerData+0xc8>
	     Result='0'+data;
     616:	68 2f       	mov	r22, r24
     618:	60 5d       	subi	r22, 0xD0	; 208
	      break;
	 case spTotalizerMoney:
          if ((data&0xF0)==0xE0){
	          //TMoney[TGradeId][IdxData]=BCD2Char(FilterBCD(data));
		      //TMoney[TGradeId][IdxData+1]=0;
		      PumpTotalizer.TotalGrade[TGradeId].strMoney[IdxData]=BCD2Char(FilterBCD(data));
     61a:	87 2f       	mov	r24, r23
     61c:	90 e0       	ldi	r25, 0x00	; 0
     61e:	fc 01       	movw	r30, r24
     620:	b5 e0       	ldi	r27, 0x05	; 5
     622:	ee 0f       	add	r30, r30
     624:	ff 1f       	adc	r31, r31
     626:	ba 95       	dec	r27
     628:	e1 f7       	brne	.-8      	; 0x622 <SaveTotalizerData+0xd0>
     62a:	88 0f       	add	r24, r24
     62c:	99 1f       	adc	r25, r25
     62e:	e8 1b       	sub	r30, r24
     630:	f9 0b       	sbc	r31, r25
     632:	e9 50       	subi	r30, 0x09	; 9
     634:	fd 4f       	sbci	r31, 0xFD	; 253
     636:	e4 0f       	add	r30, r20
     638:	f5 1f       	adc	r31, r21
     63a:	67 87       	std	Z+15, r22	; 0x0f
			  //_uart(1,1,PumpTotalizer.TotalGrade[TGradeId].strMoney[IdxData]);
		      PumpTotalizer.TotalGrade[TGradeId].strMoney[IdxData+1]=0;
     63c:	87 2f       	mov	r24, r23
     63e:	90 e0       	ldi	r25, 0x00	; 0
     640:	fc 01       	movw	r30, r24
     642:	75 e0       	ldi	r23, 0x05	; 5
     644:	ee 0f       	add	r30, r30
     646:	ff 1f       	adc	r31, r31
     648:	7a 95       	dec	r23
     64a:	e1 f7       	brne	.-8      	; 0x644 <SaveTotalizerData+0xf2>
     64c:	88 0f       	add	r24, r24
     64e:	99 1f       	adc	r25, r25
     650:	e8 1b       	sub	r30, r24
     652:	f9 0b       	sbc	r31, r25
     654:	e9 50       	subi	r30, 0x09	; 9
     656:	fd 4f       	sbci	r31, 0xFD	; 253
     658:	e4 0f       	add	r30, r20
     65a:	f5 1f       	adc	r31, r21
     65c:	10 8a       	std	Z+16, r1	; 0x10
  		      IdxData++;
     65e:	3f 5f       	subi	r19, 0xFF	; 255
     660:	30 93 28 01 	sts	0x0128, r19
          }
	      break;		  
	 }	 
	//Grade Data Next Select 
	if (data==0xF6){
     664:	26 3f       	cpi	r18, 0xF6	; 246
     666:	21 f4       	brne	.+8      	; 0x670 <SaveTotalizerData+0x11e>
	    IdxData=0;
     668:	10 92 28 01 	sts	0x0128, r1
	    SavePipeline=spTotalizerGrade;
     66c:	81 e0       	ldi	r24, 0x01	; 1
     66e:	13 c0       	rjmp	.+38     	; 0x696 <SaveTotalizerData+0x144>
		//_uart(1,1,0x0D);
		}
    else
	if (data==0xF9){
     670:	29 3f       	cpi	r18, 0xF9	; 249
     672:	11 f4       	brne	.+4      	; 0x678 <SaveTotalizerData+0x126>
	    SavePipeline=spTotalizerVolume;
     674:	82 e0       	ldi	r24, 0x02	; 2
     676:	07 c0       	rjmp	.+14     	; 0x686 <SaveTotalizerData+0x134>
		IdxData=0;
		//_uart(1,1,0x0D);
		//_uart(1,1,'V');
		}
	else
	if (data==0xFA){
     678:	2a 3f       	cpi	r18, 0xFA	; 250
     67a:	51 f4       	brne	.+20     	; 0x690 <SaveTotalizerData+0x13e>
	    PumpTotalDigit=IdxData;
     67c:	80 91 28 01 	lds	r24, 0x0128
     680:	80 93 0c 01 	sts	0x010C, r24
	    SavePipeline=spTotalizerMoney;
     684:	83 e0       	ldi	r24, 0x03	; 3
     686:	80 93 29 01 	sts	0x0129, r24
		IdxData=0;
     68a:	10 92 28 01 	sts	0x0128, r1
     68e:	08 95       	ret
		//_uart(1,1,0x0D);
		//_uart(1,1,'M');
		}
    else
	if (data==0xF4)SavePipeline=spTotalizerPPU1;
     690:	24 3f       	cpi	r18, 0xF4	; 244
     692:	21 f4       	brne	.+8      	; 0x69c <SaveTotalizerData+0x14a>
     694:	88 e0       	ldi	r24, 0x08	; 8
     696:	80 93 29 01 	sts	0x0129, r24
     69a:	08 95       	ret
	else
	if (data==0xF5)SavePipeline=spTotalizerPPU2;
     69c:	25 3f       	cpi	r18, 0xF5	; 245
     69e:	19 f4       	brne	.+6      	; 0x6a6 <SaveTotalizerData+0x154>
     6a0:	89 e0       	ldi	r24, 0x09	; 9
     6a2:	80 93 29 01 	sts	0x0129, r24
     6a6:	08 95       	ret

000006a8 <OnReceive1>:
            strRFID[8]=0;
     sprintf_P(strSerial,PSTR("RFID:%s"),strRFID);
     _uart_print(1,0,strSerial);
	 }
	 */
}
     6a8:	08 95       	ret

000006aa <UpdateMoney>:

void UpdateMoney(char *Dest, char *Src , unsigned int Length){
     6aa:	cf 93       	push	r28
     6ac:	df 93       	push	r29
     6ae:	ec 01       	movw	r28, r24
     6b0:	20 e0       	ldi	r18, 0x00	; 0
     6b2:	0b c0       	rjmp	.+22     	; 0x6ca <UpdateMoney+0x20>
     unsigned char i;
	 for(i=0;i<Length;i++){
	     Dest[i]=Src[Length-i];
     6b4:	fe 01       	movw	r30, r28
     6b6:	e8 0f       	add	r30, r24
     6b8:	f9 1f       	adc	r31, r25
     6ba:	da 01       	movw	r26, r20
     6bc:	a8 1b       	sub	r26, r24
     6be:	b9 0b       	sbc	r27, r25
     6c0:	a6 0f       	add	r26, r22
     6c2:	b7 1f       	adc	r27, r23
     6c4:	8c 91       	ld	r24, X
     6c6:	80 83       	st	Z, r24
	 */
}

void UpdateMoney(char *Dest, char *Src , unsigned int Length){
     unsigned char i;
	 for(i=0;i<Length;i++){
     6c8:	2f 5f       	subi	r18, 0xFF	; 255
     6ca:	82 2f       	mov	r24, r18
     6cc:	90 e0       	ldi	r25, 0x00	; 0
     6ce:	84 17       	cp	r24, r20
     6d0:	95 07       	cpc	r25, r21
     6d2:	80 f3       	brcs	.-32     	; 0x6b4 <UpdateMoney+0xa>
	     Dest[i]=Src[Length-i];
	 }
	 Dest[Length]=0;
     6d4:	c4 0f       	add	r28, r20
     6d6:	d5 1f       	adc	r29, r21
     6d8:	18 82       	st	Y, r1
}
     6da:	df 91       	pop	r29
     6dc:	cf 91       	pop	r28
     6de:	08 95       	ret

000006e0 <FilterBCD>:

char FilterBCD(char data){
     char Result;
	 Result=(data&0x0F);
	 return Result;
}
     6e0:	8f 70       	andi	r24, 0x0F	; 15
     6e2:	08 95       	ret

000006e4 <BCD2Char>:

char BCD2Char(char data){
     char Result;
	 Result=0;
	 if ((data>=0)&&(data<=9)) 
     6e4:	8a 30       	cpi	r24, 0x0A	; 10
     6e6:	10 f0       	brcs	.+4      	; 0x6ec <BCD2Char+0x8>
     6e8:	80 e3       	ldi	r24, 0x30	; 48
     6ea:	08 95       	ret
	     Result='0'+data;
     6ec:	80 5d       	subi	r24, 0xD0	; 208
     else Result='0';
	 return Result;
}
     6ee:	08 95       	ret

000006f0 <ShiftData>:

void ShiftData(char data){//data [0]..[10]
     6f0:	98 2f       	mov	r25, r24
     6f2:	ed e0       	ldi	r30, 0x0D	; 13
     6f4:	f4 e0       	ldi	r31, 0x04	; 4
     char i;
	 for(i=11;i>0;i--){//0..10
	    zDataBuffer[i]=zDataBuffer[i-1];
     6f6:	80 81       	ld	r24, Z
     6f8:	81 83       	std	Z+1, r24	; 0x01
     6fa:	31 97       	sbiw	r30, 0x01	; 1
	 return Result;
}

void ShiftData(char data){//data [0]..[10]
     char i;
	 for(i=11;i>0;i--){//0..10
     6fc:	84 e0       	ldi	r24, 0x04	; 4
     6fe:	e2 30       	cpi	r30, 0x02	; 2
     700:	f8 07       	cpc	r31, r24
     702:	c9 f7       	brne	.-14     	; 0x6f6 <ShiftData+0x6>
	    zDataBuffer[i]=zDataBuffer[i-1];
	 }
	 zDataBuffer[0]=data;
     704:	91 83       	std	Z+1, r25	; 0x01
}
     706:	08 95       	ret

00000708 <SetReceiveLine>:

void SetReceiveLine(char RecLine){
     stReceiveCom0=RecLine;
     708:	80 93 04 01 	sts	0x0104, r24
}
     70c:	08 95       	ret

0000070e <GetReceiveLine>:

char GetReceiveLine(){
     return stReceiveCom0;
}
     70e:	80 91 04 01 	lds	r24, 0x0104
     712:	08 95       	ret

00000714 <StrPosCopy>:



void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
     714:	cf 93       	push	r28
     716:	df 93       	push	r29
     718:	eb 01       	movw	r28, r22
     71a:	da 01       	movw	r26, r20
     71c:	a8 0f       	add	r26, r24
     71e:	b9 1f       	adc	r27, r25
     720:	40 e0       	ldi	r20, 0x00	; 0
     722:	50 e0       	ldi	r21, 0x00	; 0
     724:	07 c0       	rjmp	.+14     	; 0x734 <StrPosCopy+0x20>
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
     726:	fe 01       	movw	r30, r28
     728:	e4 0f       	add	r30, r20
     72a:	f5 1f       	adc	r31, r21
     72c:	8d 91       	ld	r24, X+
     72e:	80 83       	st	Z, r24



void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
     730:	4f 5f       	subi	r20, 0xFF	; 255
     732:	5f 4f       	sbci	r21, 0xFF	; 255
     734:	42 17       	cp	r20, r18
     736:	53 07       	cpc	r21, r19
     738:	b0 f3       	brcs	.-20     	; 0x726 <StrPosCopy+0x12>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
     73a:	c2 0f       	add	r28, r18
     73c:	d3 1f       	adc	r29, r19
     73e:	18 82       	st	Y, r1
}
     740:	df 91       	pop	r29
     742:	cf 91       	pop	r28
     744:	08 95       	ret

00000746 <CharPosCopy>:

char CharPosCopy(char *Source, unsigned int IdxSource){
     746:	fb 01       	movw	r30, r22
     748:	e8 0f       	add	r30, r24
     74a:	f9 1f       	adc	r31, r25
     char Result;
          Result=Source[IdxSource];
	 return Result;
}
     74c:	80 81       	ld	r24, Z
     74e:	08 95       	ret

00000750 <HexToChar>:
	 }
}

char HexToChar(char xHex){
char Result='0';
     if (xHex<10) Result='0'+xHex;
     750:	8a 30       	cpi	r24, 0x0A	; 10
     752:	10 f4       	brcc	.+4      	; 0x758 <HexToChar+0x8>
     754:	80 5d       	subi	r24, 0xD0	; 208
     756:	08 95       	ret
	 else 
	 if (xHex<16) Result='A'+(xHex-10); 
     758:	80 31       	cpi	r24, 0x10	; 16
     75a:	10 f0       	brcs	.+4      	; 0x760 <HexToChar+0x10>
     75c:	80 e3       	ldi	r24, 0x30	; 48
     75e:	08 95       	ret
     760:	89 5c       	subi	r24, 0xC9	; 201
	 else Result='0';
     return Result;
}
     762:	08 95       	ret

00000764 <StrPosCopyReverse>:

//Copy Reverse Filtered BCD String
void StrPosCopyReverse(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
     764:	cf 93       	push	r28
     766:	df 93       	push	r29
     768:	eb 01       	movw	r28, r22
     76a:	da 01       	movw	r26, r20
     76c:	a8 0f       	add	r26, r24
     76e:	b9 1f       	adc	r27, r25
     770:	40 e0       	ldi	r20, 0x00	; 0
     772:	50 e0       	ldi	r21, 0x00	; 0
     774:	0e c0       	rjmp	.+28     	; 0x792 <StrPosCopyReverse+0x2e>
	 Dest[Length]=0;
}

char FilterBCD(char data){
     char Result;
	 Result=(data&0x0F);
     776:	8c 91       	ld	r24, X
     778:	8f 70       	andi	r24, 0x0F	; 15
}

char BCD2Char(char data){
     char Result;
	 Result=0;
	 if ((data>=0)&&(data<=9)) 
     77a:	8a 30       	cpi	r24, 0x0A	; 10
     77c:	10 f0       	brcs	.+4      	; 0x782 <StrPosCopyReverse+0x1e>
     77e:	80 e3       	ldi	r24, 0x30	; 48
     780:	01 c0       	rjmp	.+2      	; 0x784 <StrPosCopyReverse+0x20>
	     Result='0'+data;
     782:	80 5d       	subi	r24, 0xD0	; 208

//Copy Reverse Filtered BCD String
void StrPosCopyReverse(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
     unsigned int i;
	 for (i=0;i<Length;i++){
	      Dest[i]=BCD2Char(FilterBCD(Source[IdxSource-i]));
     784:	fe 01       	movw	r30, r28
     786:	e4 0f       	add	r30, r20
     788:	f5 1f       	adc	r31, r21
     78a:	80 83       	st	Z, r24
}

//Copy Reverse Filtered BCD String
void StrPosCopyReverse(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
     unsigned int i;
	 for (i=0;i<Length;i++){
     78c:	4f 5f       	subi	r20, 0xFF	; 255
     78e:	5f 4f       	sbci	r21, 0xFF	; 255
     790:	11 97       	sbiw	r26, 0x01	; 1
     792:	42 17       	cp	r20, r18
     794:	53 07       	cpc	r21, r19
     796:	78 f3       	brcs	.-34     	; 0x776 <StrPosCopyReverse+0x12>
	      Dest[i]=BCD2Char(FilterBCD(Source[IdxSource-i]));
	 }Dest[Length]=0;
     798:	c2 0f       	add	r28, r18
     79a:	d3 1f       	adc	r29, r19
     79c:	18 82       	st	Y, r1
}
     79e:	df 91       	pop	r29
     7a0:	cf 91       	pop	r28
     7a2:	08 95       	ret

000007a4 <uartGilbarco>:
void StartupInfo(){
    _uart_printf(1,1,PSTR("Initialized"));
}

void uartGilbarco(){
}
     7a4:	08 95       	ret

000007a6 <FillChar>:

void FillChar(char *strMemory, unsigned int Length,char data){
     7a6:	20 e0       	ldi	r18, 0x00	; 0
     7a8:	30 e0       	ldi	r19, 0x00	; 0
     7aa:	06 c0       	rjmp	.+12     	; 0x7b8 <FillChar+0x12>
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
     7ac:	fc 01       	movw	r30, r24
     7ae:	e2 0f       	add	r30, r18
     7b0:	f3 1f       	adc	r31, r19
     7b2:	40 83       	st	Z, r20
void uartGilbarco(){
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
     7b4:	2f 5f       	subi	r18, 0xFF	; 255
     7b6:	3f 4f       	sbci	r19, 0xFF	; 255
     7b8:	26 17       	cp	r18, r22
     7ba:	37 07       	cpc	r19, r23
     7bc:	b8 f3       	brcs	.-18     	; 0x7ac <FillChar+0x6>
	     strMemory[i]=data;
	 }
}
     7be:	08 95       	ret

000007c0 <StartupInfo>:
	 }Dest[Length]=0;
}


void StartupInfo(){
    _uart_printf(1,1,PSTR("Initialized"));
     7c0:	81 e0       	ldi	r24, 0x01	; 1
     7c2:	61 e0       	ldi	r22, 0x01	; 1
     7c4:	4c e2       	ldi	r20, 0x2C	; 44
     7c6:	51 e0       	ldi	r21, 0x01	; 1
     7c8:	0e 94 89 18 	call	0x3112	; 0x3112 <_uart_printf>
}
     7cc:	08 95       	ret

000007ce <AddZeroLead>:
	   }//Zeroed[Length-ZeroPos]=0;
	 }     
   }
}

void AddZeroLead(char *String,unsigned char Size){// 1234 ->0000001234
     7ce:	bf 92       	push	r11
     7d0:	cf 92       	push	r12
     7d2:	df 92       	push	r13
     7d4:	ef 92       	push	r14
     7d6:	ff 92       	push	r15
     7d8:	0f 93       	push	r16
     7da:	1f 93       	push	r17
     7dc:	df 93       	push	r29
     7de:	cf 93       	push	r28
     7e0:	cd b7       	in	r28, 0x3d	; 61
     7e2:	de b7       	in	r29, 0x3e	; 62
     7e4:	64 97       	sbiw	r28, 0x14	; 20
     7e6:	0f b6       	in	r0, 0x3f	; 63
     7e8:	f8 94       	cli
     7ea:	de bf       	out	0x3e, r29	; 62
     7ec:	0f be       	out	0x3f, r0	; 63
     7ee:	cd bf       	out	0x3d, r28	; 61
     7f0:	8c 01       	movw	r16, r24
     char i,Length,strAdded[20];
     Length=strlen(String);
     7f2:	fc 01       	movw	r30, r24
     7f4:	01 90       	ld	r0, Z+
     7f6:	00 20       	and	r0, r0
     7f8:	e9 f7       	brne	.-6      	; 0x7f4 <AddZeroLead+0x26>
     7fa:	31 97       	sbiw	r30, 0x01	; 1
     7fc:	2e 2f       	mov	r18, r30
     7fe:	28 1b       	sub	r18, r24

	 if (Size>Length){
     800:	26 17       	cp	r18, r22
     802:	e0 f5       	brcc	.+120    	; 0x87c <AddZeroLead+0xae>
     804:	7e 01       	movw	r14, r28
     806:	08 94       	sec
     808:	e1 1c       	adc	r14, r1
     80a:	f1 1c       	adc	r15, r1
     80c:	f7 01       	movw	r30, r14
	   }//Zeroed[Length-ZeroPos]=0;
	 }     
   }
}

void AddZeroLead(char *String,unsigned char Size){// 1234 ->0000001234
     80e:	be 2c       	mov	r11, r14
     char i,Length,strAdded[20];
     Length=strlen(String);

	 if (Size>Length){
         for(i=0;i<Size;i++){
	         strAdded[i]='0';
     810:	90 e3       	ldi	r25, 0x30	; 48
     812:	01 c0       	rjmp	.+2      	; 0x816 <AddZeroLead+0x48>
     814:	91 93       	st	Z+, r25
void AddZeroLead(char *String,unsigned char Size){// 1234 ->0000001234
     char i,Length,strAdded[20];
     Length=strlen(String);

	 if (Size>Length){
         for(i=0;i<Size;i++){
     816:	8e 2f       	mov	r24, r30
     818:	8b 19       	sub	r24, r11
     81a:	86 17       	cp	r24, r22
     81c:	d8 f3       	brcs	.-10     	; 0x814 <AddZeroLead+0x46>
	         strAdded[i]='0';
	     }strAdded[Size]=0;
     81e:	46 2f       	mov	r20, r22
     820:	50 e0       	ldi	r21, 0x00	; 0
     822:	ce 01       	movw	r24, r28
     824:	01 96       	adiw	r24, 0x01	; 1
     826:	fc 01       	movw	r30, r24
     828:	e4 0f       	add	r30, r20
     82a:	f5 1f       	adc	r31, r21
     82c:	10 82       	st	Z, r1
	     //Copy
         for(i=(Size-Length);i<Size;i++){
     82e:	76 2f       	mov	r23, r22
     830:	72 1b       	sub	r23, r18
     832:	6c 01       	movw	r12, r24
	         strAdded[i]=String[i-(Size-Length)];
     834:	30 e0       	ldi	r19, 0x00	; 0
     836:	24 1b       	sub	r18, r20
     838:	35 0b       	sbc	r19, r21
     83a:	0c c0       	rjmp	.+24     	; 0x854 <AddZeroLead+0x86>
     83c:	e7 2f       	mov	r30, r23
     83e:	f0 e0       	ldi	r31, 0x00	; 0
     840:	d6 01       	movw	r26, r12
     842:	ae 0f       	add	r26, r30
     844:	bf 1f       	adc	r27, r31
     846:	e0 0f       	add	r30, r16
     848:	f1 1f       	adc	r31, r17
     84a:	e2 0f       	add	r30, r18
     84c:	f3 1f       	adc	r31, r19
     84e:	80 81       	ld	r24, Z
     850:	8c 93       	st	X, r24
	 if (Size>Length){
         for(i=0;i<Size;i++){
	         strAdded[i]='0';
	     }strAdded[Size]=0;
	     //Copy
         for(i=(Size-Length);i<Size;i++){
     852:	7f 5f       	subi	r23, 0xFF	; 255
     854:	76 17       	cp	r23, r22
     856:	90 f3       	brcs	.-28     	; 0x83c <AddZeroLead+0x6e>
	         strAdded[i]=String[i-(Size-Length)];
	     }strAdded[Size]=0;
     858:	4c 0d       	add	r20, r12
     85a:	5d 1d       	adc	r21, r13
     85c:	da 01       	movw	r26, r20
     85e:	1c 92       	st	X, r1
     860:	f8 01       	movw	r30, r16
     862:	04 c0       	rjmp	.+8      	; 0x86c <AddZeroLead+0x9e>
	     //Zeroed
         for(i=0;i<Size;i++){
	         String[i]=strAdded[i];
     864:	d7 01       	movw	r26, r14
     866:	8d 91       	ld	r24, X+
     868:	7d 01       	movw	r14, r26
     86a:	81 93       	st	Z+, r24
	     //Copy
         for(i=(Size-Length);i<Size;i++){
	         strAdded[i]=String[i-(Size-Length)];
	     }strAdded[Size]=0;
	     //Zeroed
         for(i=0;i<Size;i++){
     86c:	8e 2d       	mov	r24, r14
     86e:	8b 19       	sub	r24, r11
     870:	86 17       	cp	r24, r22
     872:	c0 f3       	brcs	.-16     	; 0x864 <AddZeroLead+0x96>
	         String[i]=strAdded[i];
	     }String[Size]=0;
     874:	06 0f       	add	r16, r22
     876:	11 1d       	adc	r17, r1
     878:	f8 01       	movw	r30, r16
     87a:	10 82       	st	Z, r1
	 }
}
     87c:	64 96       	adiw	r28, 0x14	; 20
     87e:	0f b6       	in	r0, 0x3f	; 63
     880:	f8 94       	cli
     882:	de bf       	out	0x3e, r29	; 62
     884:	0f be       	out	0x3f, r0	; 63
     886:	cd bf       	out	0x3d, r28	; 61
     888:	cf 91       	pop	r28
     88a:	df 91       	pop	r29
     88c:	1f 91       	pop	r17
     88e:	0f 91       	pop	r16
     890:	ff 90       	pop	r15
     892:	ef 90       	pop	r14
     894:	df 90       	pop	r13
     896:	cf 90       	pop	r12
     898:	bf 90       	pop	r11
     89a:	08 95       	ret

0000089c <RemZeroLead>:
     char Result;
          Result=Source[IdxSource];
	 return Result;
}

void RemZeroLead(char *Zeroed){//Remove Zero Character 00001004 000050000 0 
     89c:	cf 93       	push	r28
     89e:	df 93       	push	r29
     8a0:	ec 01       	movw	r28, r24
unsigned char i=0,Length=0,ZeroPos=0,IsFound=False;;
     IsFound=False;
     ZeroPos=0;Length=strlen(Zeroed);
     8a2:	fc 01       	movw	r30, r24
     8a4:	01 90       	ld	r0, Z+
     8a6:	00 20       	and	r0, r0
     8a8:	e9 f7       	brne	.-6      	; 0x8a4 <RemZeroLead+0x8>
     8aa:	31 97       	sbiw	r30, 0x01	; 1
     8ac:	e8 1b       	sub	r30, r24
  if ((Length>1)&&(Zeroed[0]=='0')){
     8ae:	e2 30       	cpi	r30, 0x02	; 2
     8b0:	d0 f1       	brcs	.+116    	; 0x926 <RemZeroLead+0x8a>
     8b2:	88 81       	ld	r24, Y
     8b4:	80 33       	cpi	r24, 0x30	; 48
     8b6:	b9 f5       	brne	.+110    	; 0x926 <RemZeroLead+0x8a>
     8b8:	4c 2f       	mov	r20, r28
     8ba:	de 01       	movw	r26, r28
     8bc:	90 e0       	ldi	r25, 0x00	; 0
	 if (Zeroed[0]=='0'){
         for(i=0;i<Length;i++){//00000000->0
	         if ((Zeroed[i]=='0')&&(Zeroed[i+1]=='0')&&(IsFound==False)) ZeroPos++;
     8be:	8c 91       	ld	r24, X
     8c0:	80 33       	cpi	r24, 0x30	; 48
     8c2:	69 f4       	brne	.+26     	; 0x8de <RemZeroLead+0x42>
     8c4:	11 96       	adiw	r26, 0x01	; 1
     8c6:	8c 91       	ld	r24, X
     8c8:	11 97       	sbiw	r26, 0x01	; 1
     8ca:	80 33       	cpi	r24, 0x30	; 48
     8cc:	11 f4       	brne	.+4      	; 0x8d2 <RemZeroLead+0x36>
     8ce:	9f 5f       	subi	r25, 0xFF	; 255
     8d0:	06 c0       	rjmp	.+12     	; 0x8de <RemZeroLead+0x42>
             if ((Zeroed[i]=='0')&&(Zeroed[i+1]!='0')){
			     if ((Zeroed[i+1]=='.')||(Zeroed[i+1]==','))ZeroPos--;
     8d2:	8e 32       	cpi	r24, 0x2E	; 46
     8d4:	11 f0       	breq	.+4      	; 0x8da <RemZeroLead+0x3e>
     8d6:	8c 32       	cpi	r24, 0x2C	; 44
     8d8:	41 f4       	brne	.+16     	; 0x8ea <RemZeroLead+0x4e>
     8da:	91 50       	subi	r25, 0x01	; 1
     8dc:	06 c0       	rjmp	.+12     	; 0x8ea <RemZeroLead+0x4e>
     8de:	11 96       	adiw	r26, 0x01	; 1
unsigned char i=0,Length=0,ZeroPos=0,IsFound=False;;
     IsFound=False;
     ZeroPos=0;Length=strlen(Zeroed);
  if ((Length>1)&&(Zeroed[0]=='0')){
	 if (Zeroed[0]=='0'){
         for(i=0;i<Length;i++){//00000000->0
     8e0:	8a 2f       	mov	r24, r26
     8e2:	84 1b       	sub	r24, r20
     8e4:	8e 17       	cp	r24, r30
     8e6:	58 f3       	brcs	.-42     	; 0x8be <RemZeroLead+0x22>
     8e8:	01 c0       	rjmp	.+2      	; 0x8ec <RemZeroLead+0x50>
		         IsFound=True;
			     break;			  
			     }
	      }

		  if (IsFound==True)ZeroPos++;
     8ea:	9f 5f       	subi	r25, 0xFF	; 255
		  if (ZeroPos>=Length)ZeroPos=Length-1;
     8ec:	9e 17       	cp	r25, r30
     8ee:	10 f0       	brcs	.+4      	; 0x8f4 <RemZeroLead+0x58>
     8f0:	9e 2f       	mov	r25, r30
     8f2:	91 50       	subi	r25, 0x01	; 1
     8f4:	40 e0       	ldi	r20, 0x00	; 0
          for(i=0;i<(Length-ZeroPos);i++){
     8f6:	89 2f       	mov	r24, r25
     8f8:	90 e0       	ldi	r25, 0x00	; 0
     8fa:	2e 2f       	mov	r18, r30
     8fc:	30 e0       	ldi	r19, 0x00	; 0
     8fe:	28 1b       	sub	r18, r24
     900:	39 0b       	sbc	r19, r25
	          Zeroed[i]=Zeroed[i+ZeroPos];
     902:	be 01       	movw	r22, r28
     904:	68 0f       	add	r22, r24
     906:	79 1f       	adc	r23, r25
     908:	09 c0       	rjmp	.+18     	; 0x91c <RemZeroLead+0x80>
     90a:	fe 01       	movw	r30, r28
     90c:	ea 0f       	add	r30, r26
     90e:	fb 1f       	adc	r31, r27
     910:	a6 0f       	add	r26, r22
     912:	b7 1f       	adc	r27, r23
     914:	8c 91       	ld	r24, X
     916:	80 83       	st	Z, r24
		      Zeroed[i+1]=0;
     918:	11 82       	std	Z+1, r1	; 0x01
			     }
	      }

		  if (IsFound==True)ZeroPos++;
		  if (ZeroPos>=Length)ZeroPos=Length-1;
          for(i=0;i<(Length-ZeroPos);i++){
     91a:	4f 5f       	subi	r20, 0xFF	; 255
     91c:	a4 2f       	mov	r26, r20
     91e:	b0 e0       	ldi	r27, 0x00	; 0
     920:	a2 17       	cp	r26, r18
     922:	b3 07       	cpc	r27, r19
     924:	94 f3       	brlt	.-28     	; 0x90a <RemZeroLead+0x6e>
	          Zeroed[i]=Zeroed[i+ZeroPos];
		      Zeroed[i+1]=0;
	   }//Zeroed[Length-ZeroPos]=0;
	 }     
   }
}
     926:	df 91       	pop	r29
     928:	cf 91       	pop	r28
     92a:	08 95       	ret

0000092c <WayneOnReceive>:
	     Dest[2*i]=(Source[FirstPos+i]>>4)+'0';
	     Dest[(2*i)+1]=(Source[FirstPos+i]&0x0F)+'0';	 
	 }Dest[2*nCount]=0;
}

void WayneOnReceive(char WayneDataIn){
     92c:	0f 93       	push	r16
     92e:	1f 93       	push	r17
     static unsigned int tCRC=0xFFFF;
     char i,strSend[40],rxNozzleID=0;
     static char zReceive=wrWaitSTX;
     static rcvBuffer[11];

		WayneRxBuffer[rxBufferLength]=WayneDataIn;// 03 FA
     930:	90 91 15 01 	lds	r25, 0x0115
     934:	e9 2f       	mov	r30, r25
     936:	f0 e0       	ldi	r31, 0x00	; 0
     938:	e3 5c       	subi	r30, 0xC3	; 195
     93a:	fe 4f       	sbci	r31, 0xFE	; 254
     93c:	80 83       	st	Z, r24
		if (rxBufferLength<70)
     93e:	96 34       	cpi	r25, 0x46	; 70
     940:	18 f4       	brcc	.+6      	; 0x948 <WayneOnReceive+0x1c>
		    rxBufferLength++;
     942:	9f 5f       	subi	r25, 0xFF	; 255
     944:	90 93 15 01 	sts	0x0115, r25
        
		if ((WayneRxBuffer[rxBufferLength-2]==0x03)&&(WayneDataIn==0xFA)){
     948:	20 91 15 01 	lds	r18, 0x0115
     94c:	e2 2f       	mov	r30, r18
     94e:	f0 e0       	ldi	r31, 0x00	; 0
     950:	e3 5c       	subi	r30, 0xC3	; 195
     952:	fe 4f       	sbci	r31, 0xFE	; 254
     954:	32 97       	sbiw	r30, 0x02	; 2
     956:	90 81       	ld	r25, Z
     958:	32 96       	adiw	r30, 0x02	; 2
     95a:	93 30       	cpi	r25, 0x03	; 3
     95c:	09 f0       	breq	.+2      	; 0x960 <WayneOnReceive+0x34>
     95e:	a3 c0       	rjmp	.+326    	; 0xaa6 <WayneOnReceive+0x17a>
     960:	8a 3f       	cpi	r24, 0xFA	; 250
     962:	09 f0       	breq	.+2      	; 0x966 <WayneOnReceive+0x3a>
     964:	ab c0       	rjmp	.+342    	; 0xabc <WayneOnReceive+0x190>
			WayneRxSequence=WayneRxBuffer[1]&0x0F;
     966:	80 91 3e 01 	lds	r24, 0x013E
     96a:	8f 70       	andi	r24, 0x0F	; 15
     96c:	80 93 18 01 	sts	0x0118, r24
			//Message Identification
			MsgID[0]=WayneRxBuffer[2];
     970:	00 91 3f 01 	lds	r16, 0x013F
     974:	00 93 33 01 	sts	0x0133, r16
			MsgID[1]=WayneRxBuffer[3];
     978:	90 91 40 01 	lds	r25, 0x0140
     97c:	90 93 34 01 	sts	0x0134, r25
			  0 51 3E 01 01 00 03 04 00 46 00 
			  1 02 02 08 00 00 01 54 00 00 70 
			  2 84 03 04 00 46 00 02 09 05 00 
			  3 00 02 00 00 53 66 03 FA 
			*/
            MsgInfo=MI_UNKNOWN;
     980:	87 e0       	ldi	r24, 0x07	; 7
     982:	80 93 19 01 	sts	0x0119, r24
            if ((MsgID[0]==0x06)&&(MsgID[1]==0x1F)&&(rxBufferLength>=57)){
     986:	06 30       	cpi	r16, 0x06	; 6
     988:	71 f5       	brne	.+92     	; 0x9e6 <WayneOnReceive+0xba>
     98a:	9f 31       	cpi	r25, 0x1F	; 31
     98c:	09 f0       	breq	.+2      	; 0x990 <WayneOnReceive+0x64>
     98e:	89 c0       	rjmp	.+274    	; 0xaa2 <WayneOnReceive+0x176>
     990:	29 33       	cpi	r18, 0x39	; 57
     992:	08 f4       	brcc	.+2      	; 0x996 <WayneOnReceive+0x6a>
     994:	86 c0       	rjmp	.+268    	; 0xaa2 <WayneOnReceive+0x176>
			     MsgInfo=MI_TOTALIZER;
     996:	88 e0       	ldi	r24, 0x08	; 8
     998:	80 93 19 01 	sts	0x0119, r24
			     rxNozzleID=(WayneRxBuffer[37]&0x0F);
				 ExtractValue(WayneRxBuffer,38,5,PumpTotalizer.TotalGrade[rxNozzleID-1].strVolume);		
     99c:	00 91 62 01 	lds	r16, 0x0162
     9a0:	0f 70       	andi	r16, 0x0F	; 15
     9a2:	10 e0       	ldi	r17, 0x00	; 0
     9a4:	c8 01       	movw	r24, r16
     9a6:	01 97       	sbiw	r24, 0x01	; 1
     9a8:	9c 01       	movw	r18, r24
     9aa:	55 e0       	ldi	r21, 0x05	; 5
     9ac:	22 0f       	add	r18, r18
     9ae:	33 1f       	adc	r19, r19
     9b0:	5a 95       	dec	r21
     9b2:	e1 f7       	brne	.-8      	; 0x9ac <WayneOnReceive+0x80>
     9b4:	88 0f       	add	r24, r24
     9b6:	99 1f       	adc	r25, r25
     9b8:	28 1b       	sub	r18, r24
     9ba:	39 0b       	sbc	r19, r25
     9bc:	29 50       	subi	r18, 0x09	; 9
     9be:	3d 4f       	sbci	r19, 0xFD	; 253
     9c0:	8d e3       	ldi	r24, 0x3D	; 61
     9c2:	91 e0       	ldi	r25, 0x01	; 1
     9c4:	66 e2       	ldi	r22, 0x26	; 38
     9c6:	45 e0       	ldi	r20, 0x05	; 5
     9c8:	0e 94 b0 01 	call	0x360	; 0x360 <ExtractValue>
				 RemZeroLead(PumpTotalizer.TotalGrade[rxNozzleID].strVolume);
     9cc:	c8 01       	movw	r24, r16
     9ce:	35 e0       	ldi	r19, 0x05	; 5
     9d0:	88 0f       	add	r24, r24
     9d2:	99 1f       	adc	r25, r25
     9d4:	3a 95       	dec	r19
     9d6:	e1 f7       	brne	.-8      	; 0x9d0 <WayneOnReceive+0xa4>
     9d8:	00 0f       	add	r16, r16
     9da:	11 1f       	adc	r17, r17
     9dc:	80 1b       	sub	r24, r16
     9de:	91 0b       	sbc	r25, r17
     9e0:	89 50       	subi	r24, 0x09	; 9
     9e2:	9d 4f       	sbci	r25, 0xFD	; 253
     9e4:	38 c0       	rjmp	.+112    	; 0xa56 <WayneOnReceive+0x12a>
			     sprintf_P(strSend,PSTR("Totalizer%d:[V:%s]"),rxNozzleID,PumpTotalizer.TotalGrade[rxNozzleID].strVolume);
			     _uart_print(1,1,strSend);
				 #endif

			}
            if ((MsgID[0]==0x01)&&(MsgID[1]==0x01)&&(rxBufferLength>=38)){//Last Transaction
     9e6:	01 30       	cpi	r16, 0x01	; 1
     9e8:	a9 f4       	brne	.+42     	; 0xa14 <WayneOnReceive+0xe8>
     9ea:	91 30       	cpi	r25, 0x01	; 1
     9ec:	09 f0       	breq	.+2      	; 0x9f0 <WayneOnReceive+0xc4>
     9ee:	59 c0       	rjmp	.+178    	; 0xaa2 <WayneOnReceive+0x176>
     9f0:	26 32       	cpi	r18, 0x26	; 38
     9f2:	08 f4       	brcc	.+2      	; 0x9f6 <WayneOnReceive+0xca>
     9f4:	56 c0       	rjmp	.+172    	; 0xaa2 <WayneOnReceive+0x176>
			     //Vol:13-16 Amount:17-20
				 MsgInfo=MI_LAST_TRANSACTION;
     9f6:	86 e0       	ldi	r24, 0x06	; 6
     9f8:	80 93 19 01 	sts	0x0119, r24
				 ExtractValue(WayneRxBuffer,13,4,strVolume);
     9fc:	8d e3       	ldi	r24, 0x3D	; 61
     9fe:	91 e0       	ldi	r25, 0x01	; 1
     a00:	6d e0       	ldi	r22, 0x0D	; 13
     a02:	44 e0       	ldi	r20, 0x04	; 4
     a04:	27 e5       	ldi	r18, 0x57	; 87
     a06:	32 e0       	ldi	r19, 0x02	; 2
     a08:	0e 94 b0 01 	call	0x360	; 0x360 <ExtractValue>
				 ExtractValue(WayneRxBuffer,17,4,strAmount);
     a0c:	8d e3       	ldi	r24, 0x3D	; 61
     a0e:	91 e0       	ldi	r25, 0x01	; 1
     a10:	61 e1       	ldi	r22, 0x11	; 17
     a12:	16 c0       	rjmp	.+44     	; 0xa40 <WayneOnReceive+0x114>
			     _uart_print(1,1,strSend);
				 #endif

			}   // 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18
			    //51 34 02 08 00 00 01 88 00 00 84 60 01 01 05 38 4E 03 FA 
			if ((MsgID[0]==0x02)&&(MsgID[1]==0x08)&&(rxBufferLength>=19)){//Last Transaction
     a14:	02 30       	cpi	r16, 0x02	; 2
     a16:	11 f5       	brne	.+68     	; 0xa5c <WayneOnReceive+0x130>
     a18:	98 30       	cpi	r25, 0x08	; 8
     a1a:	09 f0       	breq	.+2      	; 0xa1e <WayneOnReceive+0xf2>
     a1c:	42 c0       	rjmp	.+132    	; 0xaa2 <WayneOnReceive+0x176>
     a1e:	23 31       	cpi	r18, 0x13	; 19
     a20:	08 f4       	brcc	.+2      	; 0xa24 <WayneOnReceive+0xf8>
     a22:	3f c0       	rjmp	.+126    	; 0xaa2 <WayneOnReceive+0x176>
			     //Vol:13-16 Amount:17-20
				 MsgInfo=MI_LAST_TRANSACTION;
     a24:	86 e0       	ldi	r24, 0x06	; 6
     a26:	80 93 19 01 	sts	0x0119, r24
				 ExtractValue(WayneRxBuffer,4,4,strVolume);
     a2a:	8d e3       	ldi	r24, 0x3D	; 61
     a2c:	91 e0       	ldi	r25, 0x01	; 1
     a2e:	64 e0       	ldi	r22, 0x04	; 4
     a30:	44 e0       	ldi	r20, 0x04	; 4
     a32:	27 e5       	ldi	r18, 0x57	; 87
     a34:	32 e0       	ldi	r19, 0x02	; 2
     a36:	0e 94 b0 01 	call	0x360	; 0x360 <ExtractValue>
				 ExtractValue(WayneRxBuffer,8,4,strAmount);
     a3a:	8d e3       	ldi	r24, 0x3D	; 61
     a3c:	91 e0       	ldi	r25, 0x01	; 1
     a3e:	68 e0       	ldi	r22, 0x08	; 8
     a40:	44 e0       	ldi	r20, 0x04	; 4
     a42:	2b ea       	ldi	r18, 0xAB	; 171
     a44:	33 e0       	ldi	r19, 0x03	; 3
     a46:	0e 94 b0 01 	call	0x360	; 0x360 <ExtractValue>
				 RemZeroLead(strVolume);
     a4a:	87 e5       	ldi	r24, 0x57	; 87
     a4c:	92 e0       	ldi	r25, 0x02	; 2
     a4e:	0e 94 4e 04 	call	0x89c	; 0x89c <RemZeroLead>
				 RemZeroLead(strAmount);
     a52:	8b ea       	ldi	r24, 0xAB	; 171
     a54:	93 e0       	ldi	r25, 0x03	; 3
     a56:	0e 94 4e 04 	call	0x89c	; 0x89c <RemZeroLead>
     a5a:	23 c0       	rjmp	.+70     	; 0xaa2 <WayneOnReceive+0x176>
			     sprintf_P(strSend,PSTR("Trans:[V:%s][A:%s]"),strVolume,strAmount);
			     _uart_print(1,1,strSend);
				 #endif
			}			

            if ((MsgID[0]==0x03)&&(MsgID[1]==0x04)){//PriceNozzleInfo
     a5c:	03 30       	cpi	r16, 0x03	; 3
     a5e:	09 f5       	brne	.+66     	; 0xaa2 <WayneOnReceive+0x176>
     a60:	94 30       	cpi	r25, 0x04	; 4
     a62:	f9 f4       	brne	.+62     	; 0xaa2 <WayneOnReceive+0x176>
			     if ((WayneRxBuffer[7]>>4)==0x01){
     a64:	80 91 44 01 	lds	r24, 0x0144
     a68:	82 95       	swap	r24
     a6a:	8f 70       	andi	r24, 0x0F	; 15
     a6c:	81 30       	cpi	r24, 0x01	; 1
     a6e:	21 f4       	brne	.+8      	; 0xa78 <WayneOnReceive+0x14c>
				      MsgInfo=MI_NOZZLE_UP;
     a70:	82 e0       	ldi	r24, 0x02	; 2
     a72:	80 93 19 01 	sts	0x0119, r24
     a76:	10 c0       	rjmp	.+32     	; 0xa98 <WayneOnReceive+0x16c>
					  #ifdef DEBUG_WAYNE_RECEIVE 
					  _uart_printf(1,1,PSTR("-WR_MESSAGE Nozzle Up-"));
					  #endif
					  }
                 else
			     if ((WayneRxBuffer[7]>>4)==0x00){
     a78:	88 23       	and	r24, r24
     a7a:	71 f4       	brne	.+28     	; 0xa98 <WayneOnReceive+0x16c>
				      //Price
					  ExtractValue(WayneRxBuffer,4,3,strUnitPrice);
     a7c:	8d e3       	ldi	r24, 0x3D	; 61
     a7e:	91 e0       	ldi	r25, 0x01	; 1
     a80:	64 e0       	ldi	r22, 0x04	; 4
     a82:	43 e0       	ldi	r20, 0x03	; 3
     a84:	2c ea       	ldi	r18, 0xAC	; 172
     a86:	32 e0       	ldi	r19, 0x02	; 2
     a88:	0e 94 b0 01 	call	0x360	; 0x360 <ExtractValue>
					  RemZeroLead(strUnitPrice);
     a8c:	8c ea       	ldi	r24, 0xAC	; 172
     a8e:	92 e0       	ldi	r25, 0x02	; 2
     a90:	0e 94 4e 04 	call	0x89c	; 0x89c <RemZeroLead>
					  #ifdef DEBUG_WAYNE_RECEIVE
			          sprintf_P(strSend,PSTR("Price%s"),strUnitPrice);
			          _uart_print(1,1,strSend);
					  #endif
				      MsgInfo=MI_NOZZLE_DOWN;
     a94:	00 93 19 01 	sts	0x0119, r16
					  #ifdef DEBUG_WAYNE_RECEIVE 
					  _uart_printf(1,1,PSTR("-WR_MESSAGE Nozzle Down-"));
					  #endif
					  }
            ActiveNozzle=WayneRxBuffer[7]&0x0F;
     a98:	80 91 44 01 	lds	r24, 0x0144
     a9c:	8f 70       	andi	r24, 0x0F	; 15
     a9e:	80 93 1c 01 	sts	0x011C, r24
            }
        WayneReply=WR_MESSAGE;
     aa2:	84 e0       	ldi	r24, 0x04	; 4
     aa4:	07 c0       	rjmp	.+14     	; 0xab4 <WayneOnReceive+0x188>
		rxBufferLength=0;	
		}else
		if ((WayneRxBuffer[rxBufferLength-2]==0x70)&&(WayneRxBuffer[rxBufferLength-1]==0xFA)){
     aa6:	90 37       	cpi	r25, 0x70	; 112
     aa8:	49 f4       	brne	.+18     	; 0xabc <WayneOnReceive+0x190>
     aaa:	31 97       	sbiw	r30, 0x01	; 1
     aac:	80 81       	ld	r24, Z
     aae:	8a 3f       	cpi	r24, 0xFA	; 250
     ab0:	29 f4       	brne	.+10     	; 0xabc <WayneOnReceive+0x190>
		
		    #ifdef DEBUG_WAYNE_RECEIVE 
			_uart_printf(1,1,PSTR("-WR_READY-"));
			#endif
		    WayneReply=WR_READY;
     ab2:	81 e0       	ldi	r24, 0x01	; 1
     ab4:	80 93 1a 01 	sts	0x011A, r24
		    rxBufferLength=0;
     ab8:	10 92 15 01 	sts	0x0115, r1
		}
		if (((WayneRxBuffer[rxBufferLength-3]&0xF0)==0x50)&&(WayneRxBuffer[rxBufferLength-1]==0xFA)){
     abc:	80 91 15 01 	lds	r24, 0x0115
     ac0:	a8 2f       	mov	r26, r24
     ac2:	b0 e0       	ldi	r27, 0x00	; 0
     ac4:	a3 5c       	subi	r26, 0xC3	; 195
     ac6:	be 4f       	sbci	r27, 0xFE	; 254
     ac8:	13 97       	sbiw	r26, 0x03	; 3
     aca:	8c 91       	ld	r24, X
     acc:	13 96       	adiw	r26, 0x03	; 3
     ace:	80 7f       	andi	r24, 0xF0	; 240
     ad0:	80 35       	cpi	r24, 0x50	; 80
     ad2:	c1 f4       	brne	.+48     	; 0xb04 <WayneOnReceive+0x1d8>
     ad4:	fd 01       	movw	r30, r26
     ad6:	31 97       	sbiw	r30, 0x01	; 1
     ad8:	80 81       	ld	r24, Z
     ada:	8a 3f       	cpi	r24, 0xFA	; 250
     adc:	99 f4       	brne	.+38     	; 0xb04 <WayneOnReceive+0x1d8>
              if ((WayneRxBuffer[rxBufferLength-2]&0xF0)==0xC0){
     ade:	fd 01       	movw	r30, r26
     ae0:	32 97       	sbiw	r30, 0x02	; 2
     ae2:	80 81       	ld	r24, Z
     ae4:	90 e0       	ldi	r25, 0x00	; 0
     ae6:	80 7f       	andi	r24, 0xF0	; 240
     ae8:	90 70       	andi	r25, 0x00	; 0
     aea:	80 3c       	cpi	r24, 0xC0	; 192
     aec:	91 05       	cpc	r25, r1
     aee:	11 f4       	brne	.+4      	; 0xaf4 <WayneOnReceive+0x1c8>
		         #ifdef DEBUG_WAYNE_RECEIVE 
				 _uart_printf(1,1,PSTR("-WR_ACK-"));
				 #endif
		         WayneReply=WR_ACK;
     af0:	82 e0       	ldi	r24, 0x02	; 2
     af2:	04 c0       	rjmp	.+8      	; 0xafc <WayneOnReceive+0x1d0>
			 }else if ((WayneRxBuffer[rxBufferLength-2]&0xF0)==0x50){
     af4:	80 35       	cpi	r24, 0x50	; 80
     af6:	91 05       	cpc	r25, r1
     af8:	19 f4       	brne	.+6      	; 0xb00 <WayneOnReceive+0x1d4>
		         #ifdef DEBUG_WAYNE_RECEIVE 
				 _uart_printf(1,1,PSTR("-WR_NACK-"));
				 #endif
		         WayneReply=WR_NACK;
     afa:	83 e0       	ldi	r24, 0x03	; 3
     afc:	80 93 1a 01 	sts	0x011A, r24
			 }
             rxBufferLength=0;
     b00:	10 92 15 01 	sts	0x0115, r1
		}
}
     b04:	1f 91       	pop	r17
     b06:	0f 91       	pop	r16
     b08:	08 95       	ret

00000b0a <StrReverse>:
}

void systemServiceSPI(){
}

void StrReverse(char *strSource){// 0054->4500
     b0a:	df 93       	push	r29
     b0c:	cf 93       	push	r28
     b0e:	cd b7       	in	r28, 0x3d	; 61
     b10:	de b7       	in	r29, 0x3e	; 62
     b12:	64 97       	sbiw	r28, 0x14	; 20
     b14:	0f b6       	in	r0, 0x3f	; 63
     b16:	f8 94       	cli
     b18:	de bf       	out	0x3e, r29	; 62
     b1a:	0f be       	out	0x3f, r0	; 63
     b1c:	cd bf       	out	0x3d, r28	; 61
     b1e:	ac 01       	movw	r20, r24
     char i,Length,strResult[20];
	 Length=strlen(strSource);
     b20:	fc 01       	movw	r30, r24
     b22:	01 90       	ld	r0, Z+
     b24:	00 20       	and	r0, r0
     b26:	e9 f7       	brne	.-6      	; 0xb22 <StrReverse+0x18>
     b28:	31 97       	sbiw	r30, 0x01	; 1
     b2a:	2e 2f       	mov	r18, r30
     b2c:	28 1b       	sub	r18, r24
     b2e:	a2 2f       	mov	r26, r18
     b30:	b0 e0       	ldi	r27, 0x00	; 0
     b32:	11 97       	sbiw	r26, 0x01	; 1
     b34:	a8 0f       	add	r26, r24
     b36:	b9 1f       	adc	r27, r25
     b38:	be 01       	movw	r22, r28
     b3a:	6f 5f       	subi	r22, 0xFF	; 255
     b3c:	7f 4f       	sbci	r23, 0xFF	; 255
     b3e:	fb 01       	movw	r30, r22
     b40:	03 c0       	rjmp	.+6      	; 0xb48 <StrReverse+0x3e>
	 for(i=0;i<Length;i++){
	    strResult[i]=strSource[Length-i-1];
     b42:	8c 91       	ld	r24, X
     b44:	81 93       	st	Z+, r24
     b46:	11 97       	sbiw	r26, 0x01	; 1
}

void StrReverse(char *strSource){// 0054->4500
     char i,Length,strResult[20];
	 Length=strlen(strSource);
	 for(i=0;i<Length;i++){
     b48:	8e 2f       	mov	r24, r30
     b4a:	86 1b       	sub	r24, r22
     b4c:	82 17       	cp	r24, r18
     b4e:	c8 f3       	brcs	.-14     	; 0xb42 <StrReverse+0x38>
	    strResult[i]=strSource[Length-i-1];
	 }strResult[Length]=0;
     b50:	ce 01       	movw	r24, r28
     b52:	01 96       	adiw	r24, 0x01	; 1
     b54:	fc 01       	movw	r30, r24
     b56:	e2 0f       	add	r30, r18
     b58:	f1 1d       	adc	r31, r1
     b5a:	10 82       	st	Z, r1
     b5c:	60 e0       	ldi	r22, 0x00	; 0
	 //CopyResult
	 for(i=0;i<strlen(strResult);i++){
     b5e:	9c 01       	movw	r18, r24
     b60:	09 c0       	rjmp	.+18     	; 0xb74 <StrReverse+0x6a>
	    strSource[i]=strResult[i];
     b62:	fa 01       	movw	r30, r20
     b64:	ea 0f       	add	r30, r26
     b66:	fb 1f       	adc	r31, r27
     b68:	a2 0f       	add	r26, r18
     b6a:	b3 1f       	adc	r27, r19
     b6c:	8c 91       	ld	r24, X
     b6e:	80 83       	st	Z, r24
	    strSource[i+1]=0;
     b70:	11 82       	std	Z+1, r1	; 0x01
	 Length=strlen(strSource);
	 for(i=0;i<Length;i++){
	    strResult[i]=strSource[Length-i-1];
	 }strResult[Length]=0;
	 //CopyResult
	 for(i=0;i<strlen(strResult);i++){
     b72:	6f 5f       	subi	r22, 0xFF	; 255
     b74:	a6 2f       	mov	r26, r22
     b76:	b0 e0       	ldi	r27, 0x00	; 0
     b78:	f9 01       	movw	r30, r18
     b7a:	01 90       	ld	r0, Z+
     b7c:	00 20       	and	r0, r0
     b7e:	e9 f7       	brne	.-6      	; 0xb7a <StrReverse+0x70>
     b80:	31 97       	sbiw	r30, 0x01	; 1
     b82:	e2 1b       	sub	r30, r18
     b84:	f3 0b       	sbc	r31, r19
     b86:	ae 17       	cp	r26, r30
     b88:	bf 07       	cpc	r27, r31
     b8a:	58 f3       	brcs	.-42     	; 0xb62 <StrReverse+0x58>
	    strSource[i]=strResult[i];
	    strSource[i+1]=0;
	 }
}
     b8c:	64 96       	adiw	r28, 0x14	; 20
     b8e:	0f b6       	in	r0, 0x3f	; 63
     b90:	f8 94       	cli
     b92:	de bf       	out	0x3e, r29	; 62
     b94:	0f be       	out	0x3f, r0	; 63
     b96:	cd bf       	out	0x3d, r28	; 61
     b98:	cf 91       	pop	r28
     b9a:	df 91       	pop	r29
     b9c:	08 95       	ret

00000b9e <GilbarcoOnReceive>:
	else
	if (data==0xF5)SavePipeline=spTotalizerPPU2;
	
}

void GilbarcoOnReceive(char data){
     b9e:	1f 93       	push	r17
     ba0:	cf 93       	push	r28
     ba2:	df 93       	push	r29
     ba4:	18 2f       	mov	r17, r24
     ba6:	ed e0       	ldi	r30, 0x0D	; 13
     ba8:	f4 e0       	ldi	r31, 0x04	; 4
}

void ShiftData(char data){//data [0]..[10]
     char i;
	 for(i=11;i>0;i--){//0..10
	    zDataBuffer[i]=zDataBuffer[i-1];
     baa:	80 81       	ld	r24, Z
     bac:	81 83       	std	Z+1, r24	; 0x01
     bae:	31 97       	sbiw	r30, 0x01	; 1
	 return Result;
}

void ShiftData(char data){//data [0]..[10]
     char i;
	 for(i=11;i>0;i--){//0..10
     bb0:	84 e0       	ldi	r24, 0x04	; 4
     bb2:	e2 30       	cpi	r30, 0x02	; 2
     bb4:	f8 07       	cpc	r31, r24
     bb6:	c9 f7       	brne	.-14     	; 0xbaa <GilbarcoOnReceive+0xc>
	    zDataBuffer[i]=zDataBuffer[i-1];
	 }
	 zDataBuffer[0]=data;
     bb8:	11 83       	std	Z+1, r17	; 0x01
void GilbarcoOnReceive(char data){
char strSend[30],chrData,i;
static char iReceive=0;
    ShiftData(data);
	 
    switch(stReceiveCom0){
     bba:	90 91 04 01 	lds	r25, 0x0104
     bbe:	93 30       	cpi	r25, 0x03	; 3
     bc0:	d1 f1       	breq	.+116    	; 0xc36 <GilbarcoOnReceive+0x98>
     bc2:	94 30       	cpi	r25, 0x04	; 4
     bc4:	30 f4       	brcc	.+12     	; 0xbd2 <GilbarcoOnReceive+0x34>
     bc6:	91 30       	cpi	r25, 0x01	; 1
     bc8:	69 f0       	breq	.+26     	; 0xbe4 <GilbarcoOnReceive+0x46>
     bca:	92 30       	cpi	r25, 0x02	; 2
     bcc:	09 f0       	breq	.+2      	; 0xbd0 <GilbarcoOnReceive+0x32>
     bce:	9f c0       	rjmp	.+318    	; 0xd0e <GilbarcoOnReceive+0x170>
     bd0:	14 c0       	rjmp	.+40     	; 0xbfa <GilbarcoOnReceive+0x5c>
     bd2:	95 30       	cpi	r25, 0x05	; 5
     bd4:	09 f4       	brne	.+2      	; 0xbd8 <GilbarcoOnReceive+0x3a>
     bd6:	47 c0       	rjmp	.+142    	; 0xc66 <GilbarcoOnReceive+0xc8>
     bd8:	95 30       	cpi	r25, 0x05	; 5
     bda:	c0 f1       	brcs	.+112    	; 0xc4c <GilbarcoOnReceive+0xae>
     bdc:	96 30       	cpi	r25, 0x06	; 6
     bde:	09 f0       	breq	.+2      	; 0xbe2 <GilbarcoOnReceive+0x44>
     be0:	96 c0       	rjmp	.+300    	; 0xd0e <GilbarcoOnReceive+0x170>
     be2:	78 c0       	rjmp	.+240    	; 0xcd4 <GilbarcoOnReceive+0x136>
	case rcIdle:
	     CMDResponse=GetResponse(data);
     be4:	81 2f       	mov	r24, r17
     be6:	82 95       	swap	r24
     be8:	8f 70       	andi	r24, 0x0F	; 15
     bea:	80 93 8d 01 	sts	0x018D, r24
		 PumpID=GetPumpID(data);
     bee:	1f 70       	andi	r17, 0x0F	; 15
     bf0:	10 93 0e 01 	sts	0x010E, r17
		 #ifdef DEBUG_GILBARCO_RESPONSE
		 sprintf_P(strSend,PSTR("Response:%.2X"),data);
		 _uart_print(1,1,strSend);
		 #endif
		 IsStatusReceived=True;
     bf4:	90 93 0f 01 	sts	0x010F, r25
     bf8:	8a c0       	rjmp	.+276    	; 0xd0e <GilbarcoOnReceive+0x170>

	     break;	
	case rcRealTimeMoney:	     
	     strCurrentMoney[Com0ReceiveCount]=BCD2Char(FilterBCD(data));
     bfa:	90 91 23 01 	lds	r25, 0x0123
     bfe:	e9 2f       	mov	r30, r25
     c00:	f0 e0       	ldi	r31, 0x00	; 0
	 Dest[Length]=0;
}

char FilterBCD(char data){
     char Result;
	 Result=(data&0x0F);
     c02:	81 2f       	mov	r24, r17
     c04:	8f 70       	andi	r24, 0x0F	; 15
}

char BCD2Char(char data){
     char Result;
	 Result=0;
	 if ((data>=0)&&(data<=9)) 
     c06:	8a 30       	cpi	r24, 0x0A	; 10
     c08:	10 f0       	brcs	.+4      	; 0xc0e <GilbarcoOnReceive+0x70>
     c0a:	80 e3       	ldi	r24, 0x30	; 48
     c0c:	01 c0       	rjmp	.+2      	; 0xc10 <GilbarcoOnReceive+0x72>
	     Result='0'+data;
     c0e:	80 5d       	subi	r24, 0xD0	; 208
		 #endif
		 IsStatusReceived=True;

	     break;	
	case rcRealTimeMoney:	     
	     strCurrentMoney[Com0ReceiveCount]=BCD2Char(FilterBCD(data));
     c10:	e8 58       	subi	r30, 0x88	; 136
     c12:	fd 4f       	sbci	r31, 0xFD	; 253
     c14:	80 83       	st	Z, r24
	     strCurrentMoney[Com0ReceiveCount+1]=0;
     c16:	11 82       	std	Z+1, r1	; 0x01
		 TimReceive=0;
     c18:	10 92 10 04 	sts	0x0410, r1
     c1c:	10 92 0f 04 	sts	0x040F, r1
		 Com0ReceiveCount++;
     c20:	89 2f       	mov	r24, r25
     c22:	8f 5f       	subi	r24, 0xFF	; 255
     c24:	80 93 23 01 	sts	0x0123, r24
	     if ((Com0ReceiveCount>6)||(TimReceive>MSG_TRANSACTION_TIMEOUT))
     c28:	87 30       	cpi	r24, 0x07	; 7
     c2a:	08 f4       	brcc	.+2      	; 0xc2e <GilbarcoOnReceive+0x90>
     c2c:	70 c0       	rjmp	.+224    	; 0xd0e <GilbarcoOnReceive+0x170>
		     IsMoneyReceived=True;
     c2e:	81 e0       	ldi	r24, 0x01	; 1
     c30:	80 93 10 01 	sts	0x0110, r24
     c34:	6c c0       	rjmp	.+216    	; 0xd0e <GilbarcoOnReceive+0x170>
	     break;	
    case rcInitTransaction://<STX>
	     if (data==0xFF){
     c36:	1f 3f       	cpi	r17, 0xFF	; 255
     c38:	09 f0       	breq	.+2      	; 0xc3c <GilbarcoOnReceive+0x9e>
     c3a:	69 c0       	rjmp	.+210    	; 0xd0e <GilbarcoOnReceive+0x170>
		    iReceive=0;
     c3c:	10 92 27 01 	sts	0x0127, r1
			TimReceive=0;
     c40:	10 92 10 04 	sts	0x0410, r1
     c44:	10 92 0f 04 	sts	0x040F, r1
		    stReceiveCom0=rcSaveTransactionMessage;
     c48:	86 e0       	ldi	r24, 0x06	; 6
     c4a:	0a c0       	rjmp	.+20     	; 0xc60 <GilbarcoOnReceive+0xc2>
		 }
	     break;
    case rcInitTotalizer://<STX>
	     if (data==0xFF){
     c4c:	1f 3f       	cpi	r17, 0xFF	; 255
     c4e:	09 f0       	breq	.+2      	; 0xc52 <GilbarcoOnReceive+0xb4>
     c50:	5e c0       	rjmp	.+188    	; 0xd0e <GilbarcoOnReceive+0x170>
		    iReceive=0;
     c52:	10 92 27 01 	sts	0x0127, r1
			TimReceive=0;
     c56:	10 92 10 04 	sts	0x0410, r1
     c5a:	10 92 0f 04 	sts	0x040F, r1
		    stReceiveCom0=rcSaveTotalizerMessage;
     c5e:	85 e0       	ldi	r24, 0x05	; 5
     c60:	80 93 04 01 	sts	0x0104, r24
     c64:	54 c0       	rjmp	.+168    	; 0xd0e <GilbarcoOnReceive+0x170>
		 }
	     break;
    case rcSaveTotalizerMessage:
	     //_uart(1,1,data);
	     SaveTotalizerData(data);
     c66:	81 2f       	mov	r24, r17
     c68:	0e 94 a9 02 	call	0x552	; 0x552 <SaveTotalizerData>
	     if ((data==0xF0)||(TimReceive>MSG_TRANSACTION_TIMEOUT)){//Proses
     c6c:	10 3f       	cpi	r17, 0xF0	; 240
     c6e:	41 f0       	breq	.+16     	; 0xc80 <GilbarcoOnReceive+0xe2>
     c70:	80 91 0f 04 	lds	r24, 0x040F
     c74:	90 91 10 04 	lds	r25, 0x0410
     c78:	89 3c       	cpi	r24, 0xC9	; 201
     c7a:	91 05       	cpc	r25, r1
     c7c:	08 f4       	brcc	.+2      	; 0xc80 <GilbarcoOnReceive+0xe2>
     c7e:	47 c0       	rjmp	.+142    	; 0xd0e <GilbarcoOnReceive+0x170>
     c80:	c0 e0       	ldi	r28, 0x00	; 0
     c82:	d0 e0       	ldi	r29, 0x00	; 0
             //ReverseData
			 //_uart_printf(1,1,PSTR("Totalizer: "));
			 for (i=0;i<6;i++){
			 	  StrReverse(PumpTotalizer.TotalGrade[i].strMoney);
     c84:	9e 01       	movw	r18, r28
     c86:	ce 01       	movw	r24, r28
     c88:	f5 e0       	ldi	r31, 0x05	; 5
     c8a:	88 0f       	add	r24, r24
     c8c:	99 1f       	adc	r25, r25
     c8e:	fa 95       	dec	r31
     c90:	e1 f7       	brne	.-8      	; 0xc8a <GilbarcoOnReceive+0xec>
     c92:	22 0f       	add	r18, r18
     c94:	33 1f       	adc	r19, r19
     c96:	82 1b       	sub	r24, r18
     c98:	93 0b       	sbc	r25, r19
     c9a:	8a 5f       	subi	r24, 0xFA	; 250
     c9c:	9c 4f       	sbci	r25, 0xFC	; 252
     c9e:	0e 94 85 05 	call	0xb0a	; 0xb0a <StrReverse>
				  StrReverse(PumpTotalizer.TotalGrade[i].strVolume);
     ca2:	9e 01       	movw	r18, r28
     ca4:	ce 01       	movw	r24, r28
     ca6:	75 e0       	ldi	r23, 0x05	; 5
     ca8:	88 0f       	add	r24, r24
     caa:	99 1f       	adc	r25, r25
     cac:	7a 95       	dec	r23
     cae:	e1 f7       	brne	.-8      	; 0xca8 <GilbarcoOnReceive+0x10a>
     cb0:	22 0f       	add	r18, r18
     cb2:	33 1f       	adc	r19, r19
     cb4:	82 1b       	sub	r24, r18
     cb6:	93 0b       	sbc	r25, r19
     cb8:	89 50       	subi	r24, 0x09	; 9
     cba:	9d 4f       	sbci	r25, 0xFD	; 253
     cbc:	0e 94 85 05 	call	0xb0a	; 0xb0a <StrReverse>
     cc0:	21 96       	adiw	r28, 0x01	; 1
	     //_uart(1,1,data);
	     SaveTotalizerData(data);
	     if ((data==0xF0)||(TimReceive>MSG_TRANSACTION_TIMEOUT)){//Proses
             //ReverseData
			 //_uart_printf(1,1,PSTR("Totalizer: "));
			 for (i=0;i<6;i++){
     cc2:	c6 30       	cpi	r28, 0x06	; 6
     cc4:	d1 05       	cpc	r29, r1
     cc6:	f1 f6       	brne	.-68     	; 0xc84 <GilbarcoOnReceive+0xe6>
			 	  StrReverse(PumpTotalizer.TotalGrade[i].strMoney);
				  StrReverse(PumpTotalizer.TotalGrade[i].strVolume);
				  //_uart_print(1,1,PumpTotalizer.TotalGrade[i].strMoney);
				  //_uart_print(1,1,PumpTotalizer.TotalGrade[i].strVolume);
             }
		     stReceiveCom0=rcIdle;
     cc8:	81 e0       	ldi	r24, 0x01	; 1
     cca:	80 93 04 01 	sts	0x0104, r24
			 IsTotalizer=True;
     cce:	80 93 12 01 	sts	0x0112, r24
     cd2:	1d c0       	rjmp	.+58     	; 0xd0e <GilbarcoOnReceive+0x170>
			 }		 
         break;	
    case rcSaveTransactionMessage:
	     //_uart(1,1,data);
	     SaveTransactionData(data);
     cd4:	81 2f       	mov	r24, r17
     cd6:	0e 94 23 02 	call	0x446	; 0x446 <SaveTransactionData>
	     if ((data==0xF0)||(TimReceive>MSG_TRANSACTION_TIMEOUT)){//Proses
     cda:	10 3f       	cpi	r17, 0xF0	; 240
     cdc:	39 f0       	breq	.+14     	; 0xcec <GilbarcoOnReceive+0x14e>
     cde:	80 91 0f 04 	lds	r24, 0x040F
     ce2:	90 91 10 04 	lds	r25, 0x0410
     ce6:	89 3c       	cpi	r24, 0xC9	; 201
     ce8:	91 05       	cpc	r25, r1
     cea:	88 f0       	brcs	.+34     	; 0xd0e <GilbarcoOnReceive+0x170>
			  StrReverse(strUnitPrice);
     cec:	8c ea       	ldi	r24, 0xAC	; 172
     cee:	92 e0       	ldi	r25, 0x02	; 2
     cf0:	0e 94 85 05 	call	0xb0a	; 0xb0a <StrReverse>
			  StrReverse(strVolume);
     cf4:	87 e5       	ldi	r24, 0x57	; 87
     cf6:	92 e0       	ldi	r25, 0x02	; 2
     cf8:	0e 94 85 05 	call	0xb0a	; 0xb0a <StrReverse>
			  StrReverse(strAmount);
     cfc:	8b ea       	ldi	r24, 0xAB	; 171
     cfe:	93 e0       	ldi	r25, 0x03	; 3
     d00:	0e 94 85 05 	call	0xb0a	; 0xb0a <StrReverse>

			  //sprintf_P(strSend,PSTR("%s"),strAmount);
			  //_uart_print(1,1,strSend);

              stReceiveCom0=rcIdle;
     d04:	81 e0       	ldi	r24, 0x01	; 1
     d06:	80 93 04 01 	sts	0x0104, r24
			  IsTransaction=True;
     d0a:	80 93 11 01 	sts	0x0111, r24
			 }
	     break;
	}
}
     d0e:	df 91       	pop	r29
     d10:	cf 91       	pop	r28
     d12:	1f 91       	pop	r17
     d14:	08 95       	ret

00000d16 <SendSPI>:
	sbi(DDRD,2);sbi(PORTD,2);//128-SS HIGH
	//_delay_ms(10);
}

void SendSPI(char xSPI){
     _spi(xSPI);
     d16:	0e 94 80 17 	call	0x2f00	; 0x2f00 <_spi>
	 //_delay_ms(10);
}
     d1a:	08 95       	ret

00000d1c <SendStrSPI>:
	 SendSPI(0x06);//ETX
	 SendSPI(0x60);//ETX
	 systemSlave();
}

void SendStrSPI(char *strSendSPI){
     d1c:	ff 92       	push	r15
     d1e:	0f 93       	push	r16
     d20:	1f 93       	push	r17
     d22:	cf 93       	push	r28
     d24:	df 93       	push	r29
     d26:	8c 01       	movw	r16, r24
     d28:	ff 24       	eor	r15, r15
     d2a:	06 c0       	rjmp	.+12     	; 0xd38 <SendStrSPI+0x1c>
	sbi(DDRD,2);sbi(PORTD,2);//128-SS HIGH
	//_delay_ms(10);
}

void SendSPI(char xSPI){
     _spi(xSPI);
     d2c:	c0 0f       	add	r28, r16
     d2e:	d1 1f       	adc	r29, r17
     d30:	88 81       	ld	r24, Y
     d32:	0e 94 80 17 	call	0x2f00	; 0x2f00 <_spi>
	 systemSlave();
}

void SendStrSPI(char *strSendSPI){
char i;
     for(i=0;i<strlen(strSendSPI);i++){
     d36:	f3 94       	inc	r15
     d38:	cf 2d       	mov	r28, r15
     d3a:	d0 e0       	ldi	r29, 0x00	; 0
     d3c:	f8 01       	movw	r30, r16
     d3e:	01 90       	ld	r0, Z+
     d40:	00 20       	and	r0, r0
     d42:	e9 f7       	brne	.-6      	; 0xd3e <SendStrSPI+0x22>
     d44:	31 97       	sbiw	r30, 0x01	; 1
     d46:	e0 1b       	sub	r30, r16
     d48:	f1 0b       	sbc	r31, r17
     d4a:	ce 17       	cp	r28, r30
     d4c:	df 07       	cpc	r29, r31
     d4e:	70 f3       	brcs	.-36     	; 0xd2c <SendStrSPI+0x10>
	    SendSPI(strSendSPI[i]);
        //_uart(1,1,strSendSPI[i]);
	 } 
}
     d50:	df 91       	pop	r29
     d52:	cf 91       	pop	r28
     d54:	1f 91       	pop	r17
     d56:	0f 91       	pop	r16
     d58:	ff 90       	pop	r15
     d5a:	08 95       	ret

00000d5c <systemSlave>:
	//_delay_ms(10);
}


void systemSlave(){
	_spi_init(0, 1);         //SPI Slave
     d5c:	80 e0       	ldi	r24, 0x00	; 0
     d5e:	61 e0       	ldi	r22, 0x01	; 1
     d60:	0e 94 5e 17 	call	0x2ebc	; 0x2ebc <_spi_init>
	sbi(DDRB,6);sbi(PORTB,6);//MISO Output
     d64:	be 9a       	sbi	0x17, 6	; 23
     d66:	c6 9a       	sbi	0x18, 6	; 24
    cbi(DDRB,5);sbi(PORTB,5);//MOSI Input
     d68:	bd 98       	cbi	0x17, 5	; 23
     d6a:	c5 9a       	sbi	0x18, 5	; 24
	cbi(DDRB,7);sbi(PORTB,7);//SCK  Input
     d6c:	bf 98       	cbi	0x17, 7	; 23
     d6e:	c7 9a       	sbi	0x18, 7	; 24
	sbi(DDRD,2);sbi(PORTD,2);//128-SS HIGH
     d70:	8a 9a       	sbi	0x11, 2	; 17
     d72:	92 9a       	sbi	0x12, 2	; 18
	//_delay_ms(10);
}
     d74:	08 95       	ret

00000d76 <systemMaster>:
     _uart(0,1,DataSend);	 
     //_uart(1,1,DataSend);
}

void systemMaster(){
    _spi_init(1, 0);         //SPI Master
     d76:	81 e0       	ldi	r24, 0x01	; 1
     d78:	60 e0       	ldi	r22, 0x00	; 0
     d7a:	0e 94 5e 17 	call	0x2ebc	; 0x2ebc <_spi_init>
	cbi(DDRB,6);sbi(PORTB,6);//MISO Input
     d7e:	be 98       	cbi	0x17, 6	; 23
     d80:	c6 9a       	sbi	0x18, 6	; 24
    sbi(DDRB,4);sbi(DDRB,5); //MOSI Output
     d82:	bc 9a       	sbi	0x17, 4	; 23
     d84:	bd 9a       	sbi	0x17, 5	; 23
	sbi(DDRB,7);sbi(PORTB,7);//SCK  Output    
     d86:	bf 9a       	sbi	0x17, 7	; 23
     d88:	c7 9a       	sbi	0x18, 7	; 24
	sbi(DDRD,2);cbi(PORTD,2);//128-SS LOW
     d8a:	8a 9a       	sbi	0x11, 2	; 17
     d8c:	92 98       	cbi	0x12, 2	; 18
	//_delay_ms(10);
}
     d8e:	08 95       	ret

00000d90 <SendPumpStatusFlow>:
			 PumpLock[i]=False;
		 }
     }    	 
}

void SendPumpStatusFlow(char xPumpID,char xPumpStatus){//
     d90:	0f 93       	push	r16
     d92:	1f 93       	push	r17
     d94:	08 2f       	mov	r16, r24
     d96:	16 2f       	mov	r17, r22
	 #ifdef DEBUG_PUMP_STATUS_FLOW 
	  sprintf_P(strSend,PSTR("P:%d,S:%d"),xPumpID,xPumpStatus);
	 _uart_print(1,1,strSend);
	 #endif

	 systemMaster();
     d98:	0e 94 bb 06 	call	0xd76	; 0xd76 <systemMaster>
	sbi(DDRD,2);sbi(PORTD,2);//128-SS HIGH
	//_delay_ms(10);
}

void SendSPI(char xSPI){
     _spi(xSPI);
     d9c:	87 e0       	ldi	r24, 0x07	; 7
     d9e:	0e 94 80 17 	call	0x2f00	; 0x2f00 <_spi>
	 systemMaster();
     SendSPI(0x07);//STX
     SendSPI(tmpStatus);//xIDPump
	 SendSPI(0x08);//ETX

	 systemSlave();
     da2:	1f 70       	andi	r17, 0x0F	; 15
     da4:	02 95       	swap	r16
     da6:	00 7f       	andi	r16, 0xF0	; 240
     da8:	80 2f       	mov	r24, r16
     daa:	81 2b       	or	r24, r17
     dac:	0e 94 80 17 	call	0x2f00	; 0x2f00 <_spi>
     db0:	88 e0       	ldi	r24, 0x08	; 8
     db2:	0e 94 80 17 	call	0x2f00	; 0x2f00 <_spi>
     db6:	0e 94 ae 06 	call	0xd5c	; 0xd5c <systemSlave>
}
     dba:	1f 91       	pop	r17
     dbc:	0f 91       	pop	r16
     dbe:	08 95       	ret

00000dc0 <SendCommandAcknoledge>:
       //AcknoledgeCommand
       SendCommandAcknoledge(slaveCmd,slaveMsg);
	 }//EndIf	 
}

void SendCommandAcknoledge(char AckCommand,char AckData){
     dc0:	0f 93       	push	r16
     dc2:	1f 93       	push	r17
     dc4:	18 2f       	mov	r17, r24
     dc6:	06 2f       	mov	r16, r22
	 systemMaster();
     dc8:	0e 94 bb 06 	call	0xd76	; 0xd76 <systemMaster>
	sbi(DDRD,2);sbi(PORTD,2);//128-SS HIGH
	//_delay_ms(10);
}

void SendSPI(char xSPI){
     _spi(xSPI);
     dcc:	89 e0       	ldi	r24, 0x09	; 9
     dce:	0e 94 80 17 	call	0x2f00	; 0x2f00 <_spi>
	 systemMaster();
	 SendSPI(0x09);
	 SendSPI(AckCommand);
	 SendSPI(AckData);
	 SendSPI(0x0A);
	 systemSlave();
     dd2:	81 2f       	mov	r24, r17
     dd4:	0e 94 80 17 	call	0x2f00	; 0x2f00 <_spi>
     dd8:	80 2f       	mov	r24, r16
     dda:	0e 94 80 17 	call	0x2f00	; 0x2f00 <_spi>
     dde:	8a e0       	ldi	r24, 0x0A	; 10
     de0:	0e 94 80 17 	call	0x2f00	; 0x2f00 <_spi>
     de4:	0e 94 ae 06 	call	0xd5c	; 0xd5c <systemSlave>
}
     de8:	1f 91       	pop	r17
     dea:	0f 91       	pop	r16
     dec:	08 95       	ret

00000dee <__vector_20>:
		 }
     }
	 */		 
}

ISR(USART1_RXC_vect){
     dee:	1f 92       	push	r1
     df0:	0f 92       	push	r0
     df2:	0f b6       	in	r0, 0x3f	; 63
     df4:	0f 92       	push	r0
     df6:	11 24       	eor	r1, r1
     df8:	1f 93       	push	r17
     dfa:	2f 93       	push	r18
     dfc:	3f 93       	push	r19
     dfe:	4f 93       	push	r20
     e00:	5f 93       	push	r21
     e02:	6f 93       	push	r22
     e04:	7f 93       	push	r23
     e06:	8f 93       	push	r24
     e08:	9f 93       	push	r25
     e0a:	af 93       	push	r26
     e0c:	bf 93       	push	r27
     e0e:	ef 93       	push	r30
     e10:	ff 93       	push	r31
	char dataRX1;
    dataRX1=UDR1;
     e12:	13 b1       	in	r17, 0x03	; 3


   if (IFType==IT_SLAVE){
     e14:	80 91 00 01 	lds	r24, 0x0100
     e18:	81 30       	cpi	r24, 0x01	; 1
     e1a:	39 f4       	brne	.+14     	; 0xe2a <__vector_20+0x3c>
	   systemMaster();
     e1c:	0e 94 bb 06 	call	0xd76	; 0xd76 <systemMaster>
	   _spi(dataRX1);
     e20:	81 2f       	mov	r24, r17
     e22:	0e 94 80 17 	call	0x2f00	; 0x2f00 <_spi>
	   systemSlave();
     e26:	0e 94 ae 06 	call	0xd5c	; 0xd5c <systemSlave>
	   }
	   
	//_uart(1,1,dataRX1);
	//OnReceive1(dataRX1);
}
     e2a:	ff 91       	pop	r31
     e2c:	ef 91       	pop	r30
     e2e:	bf 91       	pop	r27
     e30:	af 91       	pop	r26
     e32:	9f 91       	pop	r25
     e34:	8f 91       	pop	r24
     e36:	7f 91       	pop	r23
     e38:	6f 91       	pop	r22
     e3a:	5f 91       	pop	r21
     e3c:	4f 91       	pop	r20
     e3e:	3f 91       	pop	r19
     e40:	2f 91       	pop	r18
     e42:	1f 91       	pop	r17
     e44:	0f 90       	pop	r0
     e46:	0f be       	out	0x3f, r0	; 63
     e48:	0f 90       	pop	r0
     e4a:	1f 90       	pop	r1
     e4c:	18 95       	reti

00000e4e <PumpCommand>:
	 sprintf_P(strSend,PSTR("PumpCmd:%.2X"),DataSend);
	 _uart_print(1,1,strSend);
	 #endif


     _uart(0,1,DataSend);	 
     e4e:	62 95       	swap	r22
     e50:	60 7f       	andi	r22, 0xF0	; 240
     e52:	48 2f       	mov	r20, r24
     e54:	4f 70       	andi	r20, 0x0F	; 15
     e56:	46 2b       	or	r20, r22
     e58:	80 e0       	ldi	r24, 0x00	; 0
     e5a:	61 e0       	ldi	r22, 0x01	; 1
     e5c:	0e 94 4a 18 	call	0x3094	; 0x3094 <_uart>
     //_uart(1,1,DataSend);
}
     e60:	08 95       	ret

00000e62 <WayneSendChar>:
	      break;	 
	 }
}

//enum eLineStatus{LS_NONE,LS_RX,LS_TX};
void WayneSendChar(char xData){
     e62:	1f 93       	push	r17
     e64:	18 2f       	mov	r17, r24
     System485(DIR_TX);//TransmitMode
     e66:	81 e0       	ldi	r24, 0x01	; 1
     e68:	0e 94 9c 01 	call	0x338	; 0x338 <System485>
	 _uart(0,1,xData);
     e6c:	80 e0       	ldi	r24, 0x00	; 0
     e6e:	61 e0       	ldi	r22, 0x01	; 1
     e70:	41 2f       	mov	r20, r17
     e72:	0e 94 4a 18 	call	0x3094	; 0x3094 <_uart>
	 System485(DIR_RX);//ReceiveMode
     e76:	82 e0       	ldi	r24, 0x02	; 2
     e78:	0e 94 9c 01 	call	0x338	; 0x338 <System485>
}
     e7c:	1f 91       	pop	r17
     e7e:	08 95       	ret

00000e80 <FWayneSendBuffer>:

void WayneTestSend(){
}

void FWayneSendBuffer(char *Buffer, char nLength){
     e80:	0f 93       	push	r16
     e82:	1f 93       	push	r17
     e84:	cf 93       	push	r28
     e86:	df 93       	push	r29
     e88:	06 2f       	mov	r16, r22
     e8a:	ec 01       	movw	r28, r24
     e8c:	10 e0       	ldi	r17, 0x00	; 0
     e8e:	04 c0       	rjmp	.+8      	; 0xe98 <FWayneSendBuffer+0x18>
char i;
     for(i=0;i<nLength;i++){
	     WayneSendChar(Buffer[i]);
     e90:	89 91       	ld	r24, Y+
     e92:	0e 94 31 07 	call	0xe62	; 0xe62 <WayneSendChar>
void WayneTestSend(){
}

void FWayneSendBuffer(char *Buffer, char nLength){
char i;
     for(i=0;i<nLength;i++){
     e96:	1f 5f       	subi	r17, 0xFF	; 255
     e98:	10 17       	cp	r17, r16
     e9a:	d0 f3       	brcs	.-12     	; 0xe90 <FWayneSendBuffer+0x10>
	     WayneSendChar(Buffer[i]);
	 }
}
     e9c:	df 91       	pop	r29
     e9e:	cf 91       	pop	r28
     ea0:	1f 91       	pop	r17
     ea2:	0f 91       	pop	r16
     ea4:	08 95       	ret

00000ea6 <FWayneSendCommand>:

void FWayneSendCommand(char Command, char SequenceCmd, char xPumpID, char NozzleID){
     ea6:	0f 93       	push	r16
     ea8:	1f 93       	push	r17
     eaa:	df 93       	push	r29
     eac:	cf 93       	push	r28
     eae:	cd b7       	in	r28, 0x3d	; 61
     eb0:	de b7       	in	r29, 0x3e	; 62
     eb2:	6e 97       	sbiw	r28, 0x1e	; 30
     eb4:	0f b6       	in	r0, 0x3f	; 63
     eb6:	f8 94       	cli
     eb8:	de bf       	out	0x3e, r29	; 62
     eba:	0f be       	out	0x3f, r0	; 63
     ebc:	cd bf       	out	0x3d, r28	; 61
char STX_ID,SEQ,MSG_ID[2],NOZZLE_ID,VALUE[6];
int tCRC16;
char strSend[30];
char CmdBuffer[30];
     
	 rxBufferLength=0;
     ebe:	10 92 15 01 	sts	0x0115, r1
     switch(Command){
     ec2:	8a 30       	cpi	r24, 0x0A	; 10
     ec4:	49 f1       	breq	.+82     	; 0xf18 <FWayneSendCommand+0x72>
     ec6:	8b 30       	cpi	r24, 0x0B	; 11
     ec8:	40 f4       	brcc	.+16     	; 0xeda <FWayneSendCommand+0x34>
     eca:	85 30       	cpi	r24, 0x05	; 5
     ecc:	09 f4       	brne	.+2      	; 0xed0 <FWayneSendCommand+0x2a>
     ece:	75 c2       	rjmp	.+1258   	; 0x13ba <FWayneSendCommand+0x514>
     ed0:	87 30       	cpi	r24, 0x07	; 7
     ed2:	b1 f0       	breq	.+44     	; 0xf00 <FWayneSendCommand+0x5a>
     ed4:	88 23       	and	r24, r24
     ed6:	71 f0       	breq	.+28     	; 0xef4 <FWayneSendCommand+0x4e>
     ed8:	e1 c3       	rjmp	.+1986   	; 0x169c <FWayneSendCommand+0x7f6>
     eda:	8c 30       	cpi	r24, 0x0C	; 12
     edc:	09 f4       	brne	.+2      	; 0xee0 <FWayneSendCommand+0x3a>
     ede:	f8 c0       	rjmp	.+496    	; 0x10d0 <FWayneSendCommand+0x22a>
     ee0:	8c 30       	cpi	r24, 0x0C	; 12
     ee2:	08 f4       	brcc	.+2      	; 0xee6 <FWayneSendCommand+0x40>
     ee4:	87 c0       	rjmp	.+270    	; 0xff4 <FWayneSendCommand+0x14e>
     ee6:	8d 30       	cpi	r24, 0x0D	; 13
     ee8:	09 f4       	brne	.+2      	; 0xeec <FWayneSendCommand+0x46>
     eea:	ab c1       	rjmp	.+854    	; 0x1242 <FWayneSendCommand+0x39c>
     eec:	8e 30       	cpi	r24, 0x0E	; 14
     eee:	09 f0       	breq	.+2      	; 0xef2 <FWayneSendCommand+0x4c>
     ef0:	d5 c3       	rjmp	.+1962   	; 0x169c <FWayneSendCommand+0x7f6>
     ef2:	de c2       	rjmp	.+1468   	; 0x14b0 <FWayneSendCommand+0x60a>
	      STX_ID=0x50|(0x0F&(xPumpID));
		  WayneSendChar(STX_ID);
	      WayneSendChar(0x20);
	      WayneSendChar(0xFA);
		  */
		  CmdBuffer[0]=0x50|(0x0F&(xPumpID));
     ef4:	4f 70       	andi	r20, 0x0F	; 15
     ef6:	40 65       	ori	r20, 0x50	; 80
     ef8:	49 83       	std	Y+1, r20	; 0x01
		  CmdBuffer[1]=0x20;
     efa:	80 e2       	ldi	r24, 0x20	; 32
     efc:	8a 83       	std	Y+2, r24	; 0x02
     efe:	06 c0       	rjmp	.+12     	; 0xf0c <FWayneSendCommand+0x66>
	      WayneSendChar(SEQ);
	      WayneSendChar(0xFA);
		  */
		  //sprintf_P(strSend,PSTR("[%.2X %.2X %.2X ]"),STX_ID,SEQ,0xFA);
          //_uart_print(1,1,strSend);
		  CmdBuffer[0]=0x50|(0x0F&(xPumpID));
     f00:	4f 70       	andi	r20, 0x0F	; 15
     f02:	40 65       	ori	r20, 0x50	; 80
     f04:	49 83       	std	Y+1, r20	; 0x01
		  CmdBuffer[1]=0xC0|(0x0F&SequenceCmd);
     f06:	6f 70       	andi	r22, 0x0F	; 15
     f08:	60 6c       	ori	r22, 0xC0	; 192
     f0a:	6a 83       	std	Y+2, r22	; 0x02
		  CmdBuffer[2]=0xFA;
     f0c:	8a ef       	ldi	r24, 0xFA	; 250
     f0e:	8b 83       	std	Y+3, r24	; 0x03
		  FWayneSendBuffer(CmdBuffer,3);
     f10:	ce 01       	movw	r24, r28
     f12:	01 96       	adiw	r24, 0x01	; 1
     f14:	63 e0       	ldi	r22, 0x03	; 3
     f16:	c0 c3       	rjmp	.+1920   	; 0x1698 <FWayneSendCommand+0x7f2>
	      break;
     case CMD_AUTH_1://[51 31 01 01 05 63 63 03 FA]//Auth1 ->9
          tCRC16=0;
		  CmdBuffer[0]=0x50|(0x0F&xPumpID);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[0]);
     f18:	4f 70       	andi	r20, 0x0F	; 15
     f1a:	40 65       	ori	r20, 0x50	; 80

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
     f1c:	84 2f       	mov	r24, r20
     f1e:	90 e0       	ldi	r25, 0x00	; 0
     f20:	50 e0       	ldi	r21, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
     f22:	e1 e0       	ldi	r30, 0x01	; 1
     f24:	f0 ea       	ldi	r31, 0xA0	; 160
     f26:	9c 01       	movw	r18, r24
     f28:	36 95       	lsr	r19
     f2a:	27 95       	ror	r18
     f2c:	80 ff       	sbrs	r24, 0
     f2e:	04 c0       	rjmp	.+8      	; 0xf38 <FWayneSendCommand+0x92>
     f30:	c9 01       	movw	r24, r18
     f32:	8e 27       	eor	r24, r30
     f34:	9f 27       	eor	r25, r31
     f36:	01 c0       	rjmp	.+2      	; 0xf3a <FWayneSendCommand+0x94>
        else xCRC= (xCRC>> 1);
     f38:	c9 01       	movw	r24, r18
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
     f3a:	5f 5f       	subi	r21, 0xFF	; 255
     f3c:	58 30       	cpi	r21, 0x08	; 8
     f3e:	99 f7       	brne	.-26     	; 0xf26 <FWayneSendCommand+0x80>
		  FWayneSendBuffer(CmdBuffer,3);
	      break;
     case CMD_AUTH_1://[51 31 01 01 05 63 63 03 FA]//Auth1 ->9
          tCRC16=0;
		  CmdBuffer[0]=0x50|(0x0F&xPumpID);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[0]);
		  CmdBuffer[1]=0x30|(0x0F&SequenceCmd);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[1]);
     f40:	6f 70       	andi	r22, 0x0F	; 15
     f42:	60 63       	ori	r22, 0x30	; 48

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
     f44:	26 2f       	mov	r18, r22
     f46:	30 e0       	ldi	r19, 0x00	; 0
     f48:	28 27       	eor	r18, r24
     f4a:	39 27       	eor	r19, r25
     f4c:	50 e0       	ldi	r21, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
     f4e:	e1 e0       	ldi	r30, 0x01	; 1
     f50:	f0 ea       	ldi	r31, 0xA0	; 160
     f52:	c9 01       	movw	r24, r18
     f54:	96 95       	lsr	r25
     f56:	87 95       	ror	r24
     f58:	20 ff       	sbrs	r18, 0
     f5a:	04 c0       	rjmp	.+8      	; 0xf64 <FWayneSendCommand+0xbe>
     f5c:	9c 01       	movw	r18, r24
     f5e:	2e 27       	eor	r18, r30
     f60:	3f 27       	eor	r19, r31
     f62:	01 c0       	rjmp	.+2      	; 0xf66 <FWayneSendCommand+0xc0>
        else xCRC= (xCRC>> 1);
     f64:	9c 01       	movw	r18, r24
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
     f66:	5f 5f       	subi	r21, 0xFF	; 255
     f68:	58 30       	cpi	r21, 0x08	; 8
     f6a:	99 f7       	brne	.-26     	; 0xf52 <FWayneSendCommand+0xac>

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
     f6c:	81 e0       	ldi	r24, 0x01	; 1
     f6e:	90 e0       	ldi	r25, 0x00	; 0
     f70:	82 27       	eor	r24, r18
     f72:	93 27       	eor	r25, r19
     f74:	50 e0       	ldi	r21, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
     f76:	e1 e0       	ldi	r30, 0x01	; 1
     f78:	f0 ea       	ldi	r31, 0xA0	; 160
     f7a:	9c 01       	movw	r18, r24
     f7c:	36 95       	lsr	r19
     f7e:	27 95       	ror	r18
     f80:	80 ff       	sbrs	r24, 0
     f82:	04 c0       	rjmp	.+8      	; 0xf8c <FWayneSendCommand+0xe6>
     f84:	c9 01       	movw	r24, r18
     f86:	8e 27       	eor	r24, r30
     f88:	9f 27       	eor	r25, r31
     f8a:	01 c0       	rjmp	.+2      	; 0xf8e <FWayneSendCommand+0xe8>
        else xCRC= (xCRC>> 1);
     f8c:	c9 01       	movw	r24, r18
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
     f8e:	5f 5f       	subi	r21, 0xFF	; 255
     f90:	58 30       	cpi	r21, 0x08	; 8
     f92:	99 f7       	brne	.-26     	; 0xf7a <FWayneSendCommand+0xd4>

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
     f94:	21 e0       	ldi	r18, 0x01	; 1
     f96:	30 e0       	ldi	r19, 0x00	; 0
     f98:	28 27       	eor	r18, r24
     f9a:	39 27       	eor	r19, r25
     f9c:	50 e0       	ldi	r21, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
     f9e:	e1 e0       	ldi	r30, 0x01	; 1
     fa0:	f0 ea       	ldi	r31, 0xA0	; 160
     fa2:	c9 01       	movw	r24, r18
     fa4:	96 95       	lsr	r25
     fa6:	87 95       	ror	r24
     fa8:	20 ff       	sbrs	r18, 0
     faa:	04 c0       	rjmp	.+8      	; 0xfb4 <FWayneSendCommand+0x10e>
     fac:	9c 01       	movw	r18, r24
     fae:	2e 27       	eor	r18, r30
     fb0:	3f 27       	eor	r19, r31
     fb2:	01 c0       	rjmp	.+2      	; 0xfb6 <FWayneSendCommand+0x110>
        else xCRC= (xCRC>> 1);
     fb4:	9c 01       	movw	r18, r24
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
     fb6:	5f 5f       	subi	r21, 0xFF	; 255
     fb8:	58 30       	cpi	r21, 0x08	; 8
     fba:	99 f7       	brne	.-26     	; 0xfa2 <FWayneSendCommand+0xfc>

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
     fbc:	e5 e0       	ldi	r30, 0x05	; 5
     fbe:	f0 e0       	ldi	r31, 0x00	; 0
     fc0:	e2 27       	eor	r30, r18
     fc2:	f3 27       	eor	r31, r19
     fc4:	20 e0       	ldi	r18, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
     fc6:	a1 e0       	ldi	r26, 0x01	; 1
     fc8:	b0 ea       	ldi	r27, 0xA0	; 160
     fca:	cf 01       	movw	r24, r30
     fcc:	96 95       	lsr	r25
     fce:	87 95       	ror	r24
     fd0:	e0 ff       	sbrs	r30, 0
     fd2:	04 c0       	rjmp	.+8      	; 0xfdc <FWayneSendCommand+0x136>
     fd4:	fc 01       	movw	r30, r24
     fd6:	ea 27       	eor	r30, r26
     fd8:	fb 27       	eor	r31, r27
     fda:	01 c0       	rjmp	.+2      	; 0xfde <FWayneSendCommand+0x138>
        else xCRC= (xCRC>> 1);
     fdc:	fc 01       	movw	r30, r24
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
     fde:	2f 5f       	subi	r18, 0xFF	; 255
     fe0:	28 30       	cpi	r18, 0x08	; 8
     fe2:	99 f7       	brne	.-26     	; 0xfca <FWayneSendCommand+0x124>
		  CmdBuffer[2]=0xFA;
		  FWayneSendBuffer(CmdBuffer,3);
	      break;
     case CMD_AUTH_1://[51 31 01 01 05 63 63 03 FA]//Auth1 ->9
          tCRC16=0;
		  CmdBuffer[0]=0x50|(0x0F&xPumpID);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[0]);
     fe4:	49 83       	std	Y+1, r20	; 0x01
		  CmdBuffer[1]=0x30|(0x0F&SequenceCmd);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[1]);
     fe6:	6a 83       	std	Y+2, r22	; 0x02
		  CmdBuffer[2]=0x01;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[2]);
     fe8:	81 e0       	ldi	r24, 0x01	; 1
     fea:	8b 83       	std	Y+3, r24	; 0x03
		  CmdBuffer[3]=0x01;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[3]);
     fec:	8c 83       	std	Y+4, r24	; 0x04
		  CmdBuffer[4]=0x05;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[4]);
     fee:	85 e0       	ldi	r24, 0x05	; 5
     ff0:	8d 83       	std	Y+5, r24	; 0x05
     ff2:	68 c0       	rjmp	.+208    	; 0x10c4 <FWayneSendCommand+0x21e>
		  CmdBuffer[8]=0xFA;
          FWayneSendBuffer(CmdBuffer,9);
	      break;
     case CMD_AUTH_2://[51 32 01 01 00 A3 24 03 FA]//Auth2 ->9
          tCRC16=0;
		  CmdBuffer[0]=0x50|(0x0F&xPumpID);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[0]);
     ff4:	4f 70       	andi	r20, 0x0F	; 15
     ff6:	40 65       	ori	r20, 0x50	; 80

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
     ff8:	24 2f       	mov	r18, r20
     ffa:	30 e0       	ldi	r19, 0x00	; 0
     ffc:	50 e0       	ldi	r21, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
     ffe:	e1 e0       	ldi	r30, 0x01	; 1
    1000:	f0 ea       	ldi	r31, 0xA0	; 160
    1002:	c9 01       	movw	r24, r18
    1004:	96 95       	lsr	r25
    1006:	87 95       	ror	r24
    1008:	20 ff       	sbrs	r18, 0
    100a:	04 c0       	rjmp	.+8      	; 0x1014 <FWayneSendCommand+0x16e>
    100c:	9c 01       	movw	r18, r24
    100e:	2e 27       	eor	r18, r30
    1010:	3f 27       	eor	r19, r31
    1012:	01 c0       	rjmp	.+2      	; 0x1016 <FWayneSendCommand+0x170>
        else xCRC= (xCRC>> 1);
    1014:	9c 01       	movw	r18, r24
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    1016:	5f 5f       	subi	r21, 0xFF	; 255
    1018:	58 30       	cpi	r21, 0x08	; 8
    101a:	99 f7       	brne	.-26     	; 0x1002 <FWayneSendCommand+0x15c>
          FWayneSendBuffer(CmdBuffer,9);
	      break;
     case CMD_AUTH_2://[51 32 01 01 00 A3 24 03 FA]//Auth2 ->9
          tCRC16=0;
		  CmdBuffer[0]=0x50|(0x0F&xPumpID);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[0]);
		  CmdBuffer[1]=0x30|(0x0F&SequenceCmd);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[1]);
    101c:	6f 70       	andi	r22, 0x0F	; 15
    101e:	60 63       	ori	r22, 0x30	; 48

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    1020:	86 2f       	mov	r24, r22
    1022:	90 e0       	ldi	r25, 0x00	; 0
    1024:	82 27       	eor	r24, r18
    1026:	93 27       	eor	r25, r19
    1028:	50 e0       	ldi	r21, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    102a:	e1 e0       	ldi	r30, 0x01	; 1
    102c:	f0 ea       	ldi	r31, 0xA0	; 160
    102e:	9c 01       	movw	r18, r24
    1030:	36 95       	lsr	r19
    1032:	27 95       	ror	r18
    1034:	80 ff       	sbrs	r24, 0
    1036:	04 c0       	rjmp	.+8      	; 0x1040 <FWayneSendCommand+0x19a>
    1038:	c9 01       	movw	r24, r18
    103a:	8e 27       	eor	r24, r30
    103c:	9f 27       	eor	r25, r31
    103e:	01 c0       	rjmp	.+2      	; 0x1042 <FWayneSendCommand+0x19c>
        else xCRC= (xCRC>> 1);
    1040:	c9 01       	movw	r24, r18
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    1042:	5f 5f       	subi	r21, 0xFF	; 255
    1044:	58 30       	cpi	r21, 0x08	; 8
    1046:	99 f7       	brne	.-26     	; 0x102e <FWayneSendCommand+0x188>

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    1048:	21 e0       	ldi	r18, 0x01	; 1
    104a:	30 e0       	ldi	r19, 0x00	; 0
    104c:	28 27       	eor	r18, r24
    104e:	39 27       	eor	r19, r25
    1050:	50 e0       	ldi	r21, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    1052:	e1 e0       	ldi	r30, 0x01	; 1
    1054:	f0 ea       	ldi	r31, 0xA0	; 160
    1056:	c9 01       	movw	r24, r18
    1058:	96 95       	lsr	r25
    105a:	87 95       	ror	r24
    105c:	20 ff       	sbrs	r18, 0
    105e:	04 c0       	rjmp	.+8      	; 0x1068 <FWayneSendCommand+0x1c2>
    1060:	9c 01       	movw	r18, r24
    1062:	2e 27       	eor	r18, r30
    1064:	3f 27       	eor	r19, r31
    1066:	01 c0       	rjmp	.+2      	; 0x106a <FWayneSendCommand+0x1c4>
        else xCRC= (xCRC>> 1);
    1068:	9c 01       	movw	r18, r24
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    106a:	5f 5f       	subi	r21, 0xFF	; 255
    106c:	58 30       	cpi	r21, 0x08	; 8
    106e:	99 f7       	brne	.-26     	; 0x1056 <FWayneSendCommand+0x1b0>

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    1070:	e1 e0       	ldi	r30, 0x01	; 1
    1072:	f0 e0       	ldi	r31, 0x00	; 0
    1074:	e2 27       	eor	r30, r18
    1076:	f3 27       	eor	r31, r19
    1078:	80 e0       	ldi	r24, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    107a:	a1 e0       	ldi	r26, 0x01	; 1
    107c:	b0 ea       	ldi	r27, 0xA0	; 160
    107e:	9f 01       	movw	r18, r30
    1080:	36 95       	lsr	r19
    1082:	27 95       	ror	r18
    1084:	e0 ff       	sbrs	r30, 0
    1086:	04 c0       	rjmp	.+8      	; 0x1090 <FWayneSendCommand+0x1ea>
    1088:	f9 01       	movw	r30, r18
    108a:	ea 27       	eor	r30, r26
    108c:	fb 27       	eor	r31, r27
    108e:	01 c0       	rjmp	.+2      	; 0x1092 <FWayneSendCommand+0x1ec>
        else xCRC= (xCRC>> 1);
    1090:	f9 01       	movw	r30, r18
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    1092:	8f 5f       	subi	r24, 0xFF	; 255
    1094:	88 30       	cpi	r24, 0x08	; 8
    1096:	99 f7       	brne	.-26     	; 0x107e <FWayneSendCommand+0x1d8>
    1098:	80 e0       	ldi	r24, 0x00	; 0
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    109a:	a1 e0       	ldi	r26, 0x01	; 1
    109c:	b0 ea       	ldi	r27, 0xA0	; 160
    109e:	9f 01       	movw	r18, r30
    10a0:	36 95       	lsr	r19
    10a2:	27 95       	ror	r18
    10a4:	e0 ff       	sbrs	r30, 0
    10a6:	04 c0       	rjmp	.+8      	; 0x10b0 <FWayneSendCommand+0x20a>
    10a8:	f9 01       	movw	r30, r18
    10aa:	ea 27       	eor	r30, r26
    10ac:	fb 27       	eor	r31, r27
    10ae:	01 c0       	rjmp	.+2      	; 0x10b2 <FWayneSendCommand+0x20c>
        else xCRC= (xCRC>> 1);
    10b0:	f9 01       	movw	r30, r18
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    10b2:	8f 5f       	subi	r24, 0xFF	; 255
    10b4:	88 30       	cpi	r24, 0x08	; 8
    10b6:	99 f7       	brne	.-26     	; 0x109e <FWayneSendCommand+0x1f8>
		  CmdBuffer[8]=0xFA;
          FWayneSendBuffer(CmdBuffer,9);
	      break;
     case CMD_AUTH_2://[51 32 01 01 00 A3 24 03 FA]//Auth2 ->9
          tCRC16=0;
		  CmdBuffer[0]=0x50|(0x0F&xPumpID);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[0]);
    10b8:	49 83       	std	Y+1, r20	; 0x01
		  CmdBuffer[1]=0x30|(0x0F&SequenceCmd);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[1]);
    10ba:	6a 83       	std	Y+2, r22	; 0x02
		  CmdBuffer[2]=0x01;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[2]);
    10bc:	81 e0       	ldi	r24, 0x01	; 1
    10be:	8b 83       	std	Y+3, r24	; 0x03
		  CmdBuffer[3]=0x01;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[3]);
    10c0:	8c 83       	std	Y+4, r24	; 0x04
		  CmdBuffer[4]=0x00;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[4]);
    10c2:	1d 82       	std	Y+5, r1	; 0x05
		  CmdBuffer[5]=tCRC16;
    10c4:	ee 83       	std	Y+6, r30	; 0x06
		  CmdBuffer[6]=tCRC16>>8;
    10c6:	8f 2f       	mov	r24, r31
    10c8:	99 27       	eor	r25, r25
    10ca:	87 fd       	sbrc	r24, 7
    10cc:	9a 95       	dec	r25
    10ce:	e7 c1       	rjmp	.+974    	; 0x149e <FWayneSendCommand+0x5f8>
		  CmdBuffer[8]=0xFA;
          FWayneSendBuffer(CmdBuffer,9);
	      break;
     case CMD_AUTH_3://Preset Auth Max Volume
          tCRC16=0;//[51 33 04 04 99 99 99 99 63 3E 03 FA]//Auth3 ->12
		  CmdBuffer[0]=0x50|(0x0F&xPumpID);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[0]);
    10d0:	4f 70       	andi	r20, 0x0F	; 15
    10d2:	40 65       	ori	r20, 0x50	; 80

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    10d4:	84 2f       	mov	r24, r20
    10d6:	90 e0       	ldi	r25, 0x00	; 0
    10d8:	50 e0       	ldi	r21, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    10da:	e1 e0       	ldi	r30, 0x01	; 1
    10dc:	f0 ea       	ldi	r31, 0xA0	; 160
    10de:	9c 01       	movw	r18, r24
    10e0:	36 95       	lsr	r19
    10e2:	27 95       	ror	r18
    10e4:	80 ff       	sbrs	r24, 0
    10e6:	04 c0       	rjmp	.+8      	; 0x10f0 <FWayneSendCommand+0x24a>
    10e8:	c9 01       	movw	r24, r18
    10ea:	8e 27       	eor	r24, r30
    10ec:	9f 27       	eor	r25, r31
    10ee:	01 c0       	rjmp	.+2      	; 0x10f2 <FWayneSendCommand+0x24c>
        else xCRC= (xCRC>> 1);
    10f0:	c9 01       	movw	r24, r18
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    10f2:	5f 5f       	subi	r21, 0xFF	; 255
    10f4:	58 30       	cpi	r21, 0x08	; 8
    10f6:	99 f7       	brne	.-26     	; 0x10de <FWayneSendCommand+0x238>
          FWayneSendBuffer(CmdBuffer,9);
	      break;
     case CMD_AUTH_3://Preset Auth Max Volume
          tCRC16=0;//[51 33 04 04 99 99 99 99 63 3E 03 FA]//Auth3 ->12
		  CmdBuffer[0]=0x50|(0x0F&xPumpID);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[0]);
		  CmdBuffer[1]=0x30|(0x0F&SequenceCmd);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[1]);
    10f8:	6f 70       	andi	r22, 0x0F	; 15
    10fa:	60 63       	ori	r22, 0x30	; 48

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    10fc:	26 2f       	mov	r18, r22
    10fe:	30 e0       	ldi	r19, 0x00	; 0
    1100:	28 27       	eor	r18, r24
    1102:	39 27       	eor	r19, r25
    1104:	50 e0       	ldi	r21, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    1106:	e1 e0       	ldi	r30, 0x01	; 1
    1108:	f0 ea       	ldi	r31, 0xA0	; 160
    110a:	c9 01       	movw	r24, r18
    110c:	96 95       	lsr	r25
    110e:	87 95       	ror	r24
    1110:	20 ff       	sbrs	r18, 0
    1112:	04 c0       	rjmp	.+8      	; 0x111c <FWayneSendCommand+0x276>
    1114:	9c 01       	movw	r18, r24
    1116:	2e 27       	eor	r18, r30
    1118:	3f 27       	eor	r19, r31
    111a:	01 c0       	rjmp	.+2      	; 0x111e <FWayneSendCommand+0x278>
        else xCRC= (xCRC>> 1);
    111c:	9c 01       	movw	r18, r24
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    111e:	5f 5f       	subi	r21, 0xFF	; 255
    1120:	58 30       	cpi	r21, 0x08	; 8
    1122:	99 f7       	brne	.-26     	; 0x110a <FWayneSendCommand+0x264>

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    1124:	84 e0       	ldi	r24, 0x04	; 4
    1126:	90 e0       	ldi	r25, 0x00	; 0
    1128:	82 27       	eor	r24, r18
    112a:	93 27       	eor	r25, r19
    112c:	50 e0       	ldi	r21, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    112e:	e1 e0       	ldi	r30, 0x01	; 1
    1130:	f0 ea       	ldi	r31, 0xA0	; 160
    1132:	9c 01       	movw	r18, r24
    1134:	36 95       	lsr	r19
    1136:	27 95       	ror	r18
    1138:	80 ff       	sbrs	r24, 0
    113a:	04 c0       	rjmp	.+8      	; 0x1144 <FWayneSendCommand+0x29e>
    113c:	c9 01       	movw	r24, r18
    113e:	8e 27       	eor	r24, r30
    1140:	9f 27       	eor	r25, r31
    1142:	01 c0       	rjmp	.+2      	; 0x1146 <FWayneSendCommand+0x2a0>
        else xCRC= (xCRC>> 1);
    1144:	c9 01       	movw	r24, r18
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    1146:	5f 5f       	subi	r21, 0xFF	; 255
    1148:	58 30       	cpi	r21, 0x08	; 8
    114a:	99 f7       	brne	.-26     	; 0x1132 <FWayneSendCommand+0x28c>

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    114c:	e4 e0       	ldi	r30, 0x04	; 4
    114e:	f0 e0       	ldi	r31, 0x00	; 0
    1150:	e8 27       	eor	r30, r24
    1152:	f9 27       	eor	r31, r25
    1154:	20 e0       	ldi	r18, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    1156:	a1 e0       	ldi	r26, 0x01	; 1
    1158:	b0 ea       	ldi	r27, 0xA0	; 160
    115a:	cf 01       	movw	r24, r30
    115c:	96 95       	lsr	r25
    115e:	87 95       	ror	r24
    1160:	e0 ff       	sbrs	r30, 0
    1162:	04 c0       	rjmp	.+8      	; 0x116c <FWayneSendCommand+0x2c6>
    1164:	fc 01       	movw	r30, r24
    1166:	ea 27       	eor	r30, r26
    1168:	fb 27       	eor	r31, r27
    116a:	01 c0       	rjmp	.+2      	; 0x116e <FWayneSendCommand+0x2c8>
        else xCRC= (xCRC>> 1);
    116c:	fc 01       	movw	r30, r24
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    116e:	2f 5f       	subi	r18, 0xFF	; 255
    1170:	28 30       	cpi	r18, 0x08	; 8
    1172:	99 f7       	brne	.-26     	; 0x115a <FWayneSendCommand+0x2b4>
          tCRC16=0;//[51 33 04 04 99 99 99 99 63 3E 03 FA]//Auth3 ->12
		  CmdBuffer[0]=0x50|(0x0F&xPumpID);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[0]);
		  CmdBuffer[1]=0x30|(0x0F&SequenceCmd);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[1]);
		  CmdBuffer[2]=0x04;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[2]);
		  CmdBuffer[3]=0x04;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[3]);
		  CmdBuffer[4]=MaxAuthVolume[0];tCRC16=CRC_Wayne(tCRC16,CmdBuffer[4]);
    1174:	00 91 07 01 	lds	r16, 0x0107

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    1178:	20 2f       	mov	r18, r16
    117a:	30 e0       	ldi	r19, 0x00	; 0
    117c:	2e 27       	eor	r18, r30
    117e:	3f 27       	eor	r19, r31
    1180:	50 e0       	ldi	r21, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    1182:	e1 e0       	ldi	r30, 0x01	; 1
    1184:	f0 ea       	ldi	r31, 0xA0	; 160
    1186:	c9 01       	movw	r24, r18
    1188:	96 95       	lsr	r25
    118a:	87 95       	ror	r24
    118c:	20 ff       	sbrs	r18, 0
    118e:	04 c0       	rjmp	.+8      	; 0x1198 <FWayneSendCommand+0x2f2>
    1190:	9c 01       	movw	r18, r24
    1192:	2e 27       	eor	r18, r30
    1194:	3f 27       	eor	r19, r31
    1196:	01 c0       	rjmp	.+2      	; 0x119a <FWayneSendCommand+0x2f4>
        else xCRC= (xCRC>> 1);
    1198:	9c 01       	movw	r18, r24
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    119a:	5f 5f       	subi	r21, 0xFF	; 255
    119c:	58 30       	cpi	r21, 0x08	; 8
    119e:	99 f7       	brne	.-26     	; 0x1186 <FWayneSendCommand+0x2e0>
		  CmdBuffer[0]=0x50|(0x0F&xPumpID);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[0]);
		  CmdBuffer[1]=0x30|(0x0F&SequenceCmd);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[1]);
		  CmdBuffer[2]=0x04;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[2]);
		  CmdBuffer[3]=0x04;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[3]);
		  CmdBuffer[4]=MaxAuthVolume[0];tCRC16=CRC_Wayne(tCRC16,CmdBuffer[4]);
		  CmdBuffer[5]=MaxAuthVolume[1];tCRC16=CRC_Wayne(tCRC16,CmdBuffer[5]);
    11a0:	10 91 08 01 	lds	r17, 0x0108

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    11a4:	81 2f       	mov	r24, r17
    11a6:	90 e0       	ldi	r25, 0x00	; 0
    11a8:	82 27       	eor	r24, r18
    11aa:	93 27       	eor	r25, r19
    11ac:	50 e0       	ldi	r21, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    11ae:	e1 e0       	ldi	r30, 0x01	; 1
    11b0:	f0 ea       	ldi	r31, 0xA0	; 160
    11b2:	9c 01       	movw	r18, r24
    11b4:	36 95       	lsr	r19
    11b6:	27 95       	ror	r18
    11b8:	80 ff       	sbrs	r24, 0
    11ba:	04 c0       	rjmp	.+8      	; 0x11c4 <FWayneSendCommand+0x31e>
    11bc:	c9 01       	movw	r24, r18
    11be:	8e 27       	eor	r24, r30
    11c0:	9f 27       	eor	r25, r31
    11c2:	01 c0       	rjmp	.+2      	; 0x11c6 <FWayneSendCommand+0x320>
        else xCRC= (xCRC>> 1);
    11c4:	c9 01       	movw	r24, r18
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    11c6:	5f 5f       	subi	r21, 0xFF	; 255
    11c8:	58 30       	cpi	r21, 0x08	; 8
    11ca:	99 f7       	brne	.-26     	; 0x11b2 <FWayneSendCommand+0x30c>
		  CmdBuffer[1]=0x30|(0x0F&SequenceCmd);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[1]);
		  CmdBuffer[2]=0x04;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[2]);
		  CmdBuffer[3]=0x04;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[3]);
		  CmdBuffer[4]=MaxAuthVolume[0];tCRC16=CRC_Wayne(tCRC16,CmdBuffer[4]);
		  CmdBuffer[5]=MaxAuthVolume[1];tCRC16=CRC_Wayne(tCRC16,CmdBuffer[5]);
		  CmdBuffer[6]=MaxAuthVolume[2];tCRC16=CRC_Wayne(tCRC16,CmdBuffer[6]);
    11cc:	70 91 09 01 	lds	r23, 0x0109

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    11d0:	27 2f       	mov	r18, r23
    11d2:	30 e0       	ldi	r19, 0x00	; 0
    11d4:	28 27       	eor	r18, r24
    11d6:	39 27       	eor	r19, r25
    11d8:	50 e0       	ldi	r21, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    11da:	e1 e0       	ldi	r30, 0x01	; 1
    11dc:	f0 ea       	ldi	r31, 0xA0	; 160
    11de:	c9 01       	movw	r24, r18
    11e0:	96 95       	lsr	r25
    11e2:	87 95       	ror	r24
    11e4:	20 ff       	sbrs	r18, 0
    11e6:	04 c0       	rjmp	.+8      	; 0x11f0 <FWayneSendCommand+0x34a>
    11e8:	9c 01       	movw	r18, r24
    11ea:	2e 27       	eor	r18, r30
    11ec:	3f 27       	eor	r19, r31
    11ee:	01 c0       	rjmp	.+2      	; 0x11f2 <FWayneSendCommand+0x34c>
        else xCRC= (xCRC>> 1);
    11f0:	9c 01       	movw	r18, r24
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    11f2:	5f 5f       	subi	r21, 0xFF	; 255
    11f4:	58 30       	cpi	r21, 0x08	; 8
    11f6:	99 f7       	brne	.-26     	; 0x11de <FWayneSendCommand+0x338>
		  CmdBuffer[2]=0x04;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[2]);
		  CmdBuffer[3]=0x04;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[3]);
		  CmdBuffer[4]=MaxAuthVolume[0];tCRC16=CRC_Wayne(tCRC16,CmdBuffer[4]);
		  CmdBuffer[5]=MaxAuthVolume[1];tCRC16=CRC_Wayne(tCRC16,CmdBuffer[5]);
		  CmdBuffer[6]=MaxAuthVolume[2];tCRC16=CRC_Wayne(tCRC16,CmdBuffer[6]);
		  CmdBuffer[7]=MaxAuthVolume[3];tCRC16=CRC_Wayne(tCRC16,CmdBuffer[7]);
    11f8:	50 91 0a 01 	lds	r21, 0x010A

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    11fc:	e5 2f       	mov	r30, r21
    11fe:	f0 e0       	ldi	r31, 0x00	; 0
    1200:	e2 27       	eor	r30, r18
    1202:	f3 27       	eor	r31, r19
    1204:	20 e0       	ldi	r18, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    1206:	a1 e0       	ldi	r26, 0x01	; 1
    1208:	b0 ea       	ldi	r27, 0xA0	; 160
    120a:	cf 01       	movw	r24, r30
    120c:	96 95       	lsr	r25
    120e:	87 95       	ror	r24
    1210:	e0 ff       	sbrs	r30, 0
    1212:	04 c0       	rjmp	.+8      	; 0x121c <FWayneSendCommand+0x376>
    1214:	fc 01       	movw	r30, r24
    1216:	ea 27       	eor	r30, r26
    1218:	fb 27       	eor	r31, r27
    121a:	01 c0       	rjmp	.+2      	; 0x121e <FWayneSendCommand+0x378>
        else xCRC= (xCRC>> 1);
    121c:	fc 01       	movw	r30, r24
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    121e:	2f 5f       	subi	r18, 0xFF	; 255
    1220:	28 30       	cpi	r18, 0x08	; 8
    1222:	99 f7       	brne	.-26     	; 0x120a <FWayneSendCommand+0x364>
		  CmdBuffer[8]=0xFA;
          FWayneSendBuffer(CmdBuffer,9);
	      break;
     case CMD_AUTH_3://Preset Auth Max Volume
          tCRC16=0;//[51 33 04 04 99 99 99 99 63 3E 03 FA]//Auth3 ->12
		  CmdBuffer[0]=0x50|(0x0F&xPumpID);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[0]);
    1224:	49 83       	std	Y+1, r20	; 0x01
		  CmdBuffer[1]=0x30|(0x0F&SequenceCmd);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[1]);
    1226:	6a 83       	std	Y+2, r22	; 0x02
		  CmdBuffer[2]=0x04;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[2]);
    1228:	84 e0       	ldi	r24, 0x04	; 4
    122a:	8b 83       	std	Y+3, r24	; 0x03
		  CmdBuffer[3]=0x04;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[3]);
    122c:	8c 83       	std	Y+4, r24	; 0x04
		  CmdBuffer[4]=MaxAuthVolume[0];tCRC16=CRC_Wayne(tCRC16,CmdBuffer[4]);
    122e:	0d 83       	std	Y+5, r16	; 0x05
		  CmdBuffer[5]=MaxAuthVolume[1];tCRC16=CRC_Wayne(tCRC16,CmdBuffer[5]);
    1230:	1e 83       	std	Y+6, r17	; 0x06
		  CmdBuffer[6]=MaxAuthVolume[2];tCRC16=CRC_Wayne(tCRC16,CmdBuffer[6]);
    1232:	7f 83       	std	Y+7, r23	; 0x07
		  CmdBuffer[7]=MaxAuthVolume[3];tCRC16=CRC_Wayne(tCRC16,CmdBuffer[7]);
    1234:	58 87       	std	Y+8, r21	; 0x08
		  CmdBuffer[8]=tCRC16;
    1236:	e9 87       	std	Y+9, r30	; 0x09
		  CmdBuffer[9]=tCRC16>>8;
    1238:	8f 2f       	mov	r24, r31
    123a:	99 27       	eor	r25, r25
    123c:	87 fd       	sbrc	r24, 7
    123e:	9a 95       	dec	r25
    1240:	b3 c0       	rjmp	.+358    	; 0x13a8 <FWayneSendCommand+0x502>
	 [51 34 02 01 01 01 01 06 5C BF 03 FA]//Auth4 Nozzle1
     [51 34 02 01 02 01 01 06 5C FB 03 FA]//Auth4 Nozzle2

	 */
          tCRC16=0;
		  CmdBuffer[0]=0x50|(0x0F&xPumpID);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[0]);
    1242:	4f 70       	andi	r20, 0x0F	; 15
    1244:	40 65       	ori	r20, 0x50	; 80

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    1246:	84 2f       	mov	r24, r20
    1248:	90 e0       	ldi	r25, 0x00	; 0
    124a:	30 e0       	ldi	r19, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    124c:	a1 e0       	ldi	r26, 0x01	; 1
    124e:	b0 ea       	ldi	r27, 0xA0	; 160
    1250:	fc 01       	movw	r30, r24
    1252:	f6 95       	lsr	r31
    1254:	e7 95       	ror	r30
    1256:	80 ff       	sbrs	r24, 0
    1258:	04 c0       	rjmp	.+8      	; 0x1262 <FWayneSendCommand+0x3bc>
    125a:	cf 01       	movw	r24, r30
    125c:	8a 27       	eor	r24, r26
    125e:	9b 27       	eor	r25, r27
    1260:	01 c0       	rjmp	.+2      	; 0x1264 <FWayneSendCommand+0x3be>
        else xCRC= (xCRC>> 1);
    1262:	cf 01       	movw	r24, r30
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    1264:	3f 5f       	subi	r19, 0xFF	; 255
    1266:	38 30       	cpi	r19, 0x08	; 8
    1268:	99 f7       	brne	.-26     	; 0x1250 <FWayneSendCommand+0x3aa>
     [51 34 02 01 02 01 01 06 5C FB 03 FA]//Auth4 Nozzle2

	 */
          tCRC16=0;
		  CmdBuffer[0]=0x50|(0x0F&xPumpID);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[0]);
		  CmdBuffer[1]=0x30|(0x0F&SequenceCmd);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[1]);
    126a:	6f 70       	andi	r22, 0x0F	; 15
    126c:	60 63       	ori	r22, 0x30	; 48

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    126e:	e6 2f       	mov	r30, r22
    1270:	f0 e0       	ldi	r31, 0x00	; 0
    1272:	e8 27       	eor	r30, r24
    1274:	f9 27       	eor	r31, r25
    1276:	30 e0       	ldi	r19, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    1278:	a1 e0       	ldi	r26, 0x01	; 1
    127a:	b0 ea       	ldi	r27, 0xA0	; 160
    127c:	cf 01       	movw	r24, r30
    127e:	96 95       	lsr	r25
    1280:	87 95       	ror	r24
    1282:	e0 ff       	sbrs	r30, 0
    1284:	04 c0       	rjmp	.+8      	; 0x128e <FWayneSendCommand+0x3e8>
    1286:	fc 01       	movw	r30, r24
    1288:	ea 27       	eor	r30, r26
    128a:	fb 27       	eor	r31, r27
    128c:	01 c0       	rjmp	.+2      	; 0x1290 <FWayneSendCommand+0x3ea>
        else xCRC= (xCRC>> 1);
    128e:	fc 01       	movw	r30, r24
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    1290:	3f 5f       	subi	r19, 0xFF	; 255
    1292:	38 30       	cpi	r19, 0x08	; 8
    1294:	99 f7       	brne	.-26     	; 0x127c <FWayneSendCommand+0x3d6>

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    1296:	82 e0       	ldi	r24, 0x02	; 2
    1298:	90 e0       	ldi	r25, 0x00	; 0
    129a:	8e 27       	eor	r24, r30
    129c:	9f 27       	eor	r25, r31
    129e:	30 e0       	ldi	r19, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    12a0:	a1 e0       	ldi	r26, 0x01	; 1
    12a2:	b0 ea       	ldi	r27, 0xA0	; 160
    12a4:	fc 01       	movw	r30, r24
    12a6:	f6 95       	lsr	r31
    12a8:	e7 95       	ror	r30
    12aa:	80 ff       	sbrs	r24, 0
    12ac:	04 c0       	rjmp	.+8      	; 0x12b6 <FWayneSendCommand+0x410>
    12ae:	cf 01       	movw	r24, r30
    12b0:	8a 27       	eor	r24, r26
    12b2:	9b 27       	eor	r25, r27
    12b4:	01 c0       	rjmp	.+2      	; 0x12b8 <FWayneSendCommand+0x412>
        else xCRC= (xCRC>> 1);
    12b6:	cf 01       	movw	r24, r30
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    12b8:	3f 5f       	subi	r19, 0xFF	; 255
    12ba:	38 30       	cpi	r19, 0x08	; 8
    12bc:	99 f7       	brne	.-26     	; 0x12a4 <FWayneSendCommand+0x3fe>

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    12be:	a1 e0       	ldi	r26, 0x01	; 1
    12c0:	b0 e0       	ldi	r27, 0x00	; 0
    12c2:	a8 27       	eor	r26, r24
    12c4:	b9 27       	eor	r27, r25
    12c6:	30 e0       	ldi	r19, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    12c8:	e1 e0       	ldi	r30, 0x01	; 1
    12ca:	f0 ea       	ldi	r31, 0xA0	; 160
    12cc:	cd 01       	movw	r24, r26
    12ce:	96 95       	lsr	r25
    12d0:	87 95       	ror	r24
    12d2:	a0 ff       	sbrs	r26, 0
    12d4:	04 c0       	rjmp	.+8      	; 0x12de <FWayneSendCommand+0x438>
    12d6:	dc 01       	movw	r26, r24
    12d8:	ae 27       	eor	r26, r30
    12da:	bf 27       	eor	r27, r31
    12dc:	01 c0       	rjmp	.+2      	; 0x12e0 <FWayneSendCommand+0x43a>
        else xCRC= (xCRC>> 1);
    12de:	dc 01       	movw	r26, r24
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    12e0:	3f 5f       	subi	r19, 0xFF	; 255
    12e2:	38 30       	cpi	r19, 0x08	; 8
    12e4:	99 f7       	brne	.-26     	; 0x12cc <FWayneSendCommand+0x426>
          tCRC16=0;
		  CmdBuffer[0]=0x50|(0x0F&xPumpID);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[0]);
		  CmdBuffer[1]=0x30|(0x0F&SequenceCmd);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[1]);
		  CmdBuffer[2]=0x02;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[2]);
		  CmdBuffer[3]=0x01;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[3]);
		  CmdBuffer[4]=(NozzleID&0x0F);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[4]);
    12e6:	2f 70       	andi	r18, 0x0F	; 15

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    12e8:	e2 2f       	mov	r30, r18
    12ea:	f0 e0       	ldi	r31, 0x00	; 0
    12ec:	ea 27       	eor	r30, r26
    12ee:	fb 27       	eor	r31, r27
    12f0:	30 e0       	ldi	r19, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    12f2:	a1 e0       	ldi	r26, 0x01	; 1
    12f4:	b0 ea       	ldi	r27, 0xA0	; 160
    12f6:	cf 01       	movw	r24, r30
    12f8:	96 95       	lsr	r25
    12fa:	87 95       	ror	r24
    12fc:	e0 ff       	sbrs	r30, 0
    12fe:	04 c0       	rjmp	.+8      	; 0x1308 <FWayneSendCommand+0x462>
    1300:	fc 01       	movw	r30, r24
    1302:	ea 27       	eor	r30, r26
    1304:	fb 27       	eor	r31, r27
    1306:	01 c0       	rjmp	.+2      	; 0x130a <FWayneSendCommand+0x464>
        else xCRC= (xCRC>> 1);
    1308:	fc 01       	movw	r30, r24
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    130a:	3f 5f       	subi	r19, 0xFF	; 255
    130c:	38 30       	cpi	r19, 0x08	; 8
    130e:	99 f7       	brne	.-26     	; 0x12f6 <FWayneSendCommand+0x450>

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    1310:	81 e0       	ldi	r24, 0x01	; 1
    1312:	90 e0       	ldi	r25, 0x00	; 0
    1314:	8e 27       	eor	r24, r30
    1316:	9f 27       	eor	r25, r31
    1318:	30 e0       	ldi	r19, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    131a:	a1 e0       	ldi	r26, 0x01	; 1
    131c:	b0 ea       	ldi	r27, 0xA0	; 160
    131e:	fc 01       	movw	r30, r24
    1320:	f6 95       	lsr	r31
    1322:	e7 95       	ror	r30
    1324:	80 ff       	sbrs	r24, 0
    1326:	04 c0       	rjmp	.+8      	; 0x1330 <FWayneSendCommand+0x48a>
    1328:	cf 01       	movw	r24, r30
    132a:	8a 27       	eor	r24, r26
    132c:	9b 27       	eor	r25, r27
    132e:	01 c0       	rjmp	.+2      	; 0x1332 <FWayneSendCommand+0x48c>
        else xCRC= (xCRC>> 1);
    1330:	cf 01       	movw	r24, r30
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    1332:	3f 5f       	subi	r19, 0xFF	; 255
    1334:	38 30       	cpi	r19, 0x08	; 8
    1336:	99 f7       	brne	.-26     	; 0x131e <FWayneSendCommand+0x478>

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    1338:	e1 e0       	ldi	r30, 0x01	; 1
    133a:	f0 e0       	ldi	r31, 0x00	; 0
    133c:	e8 27       	eor	r30, r24
    133e:	f9 27       	eor	r31, r25
    1340:	30 e0       	ldi	r19, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    1342:	a1 e0       	ldi	r26, 0x01	; 1
    1344:	b0 ea       	ldi	r27, 0xA0	; 160
    1346:	cf 01       	movw	r24, r30
    1348:	96 95       	lsr	r25
    134a:	87 95       	ror	r24
    134c:	e0 ff       	sbrs	r30, 0
    134e:	04 c0       	rjmp	.+8      	; 0x1358 <FWayneSendCommand+0x4b2>
    1350:	fc 01       	movw	r30, r24
    1352:	ea 27       	eor	r30, r26
    1354:	fb 27       	eor	r31, r27
    1356:	01 c0       	rjmp	.+2      	; 0x135a <FWayneSendCommand+0x4b4>
        else xCRC= (xCRC>> 1);
    1358:	fc 01       	movw	r30, r24
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    135a:	3f 5f       	subi	r19, 0xFF	; 255
    135c:	38 30       	cpi	r19, 0x08	; 8
    135e:	99 f7       	brne	.-26     	; 0x1346 <FWayneSendCommand+0x4a0>

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    1360:	a6 e0       	ldi	r26, 0x06	; 6
    1362:	b0 e0       	ldi	r27, 0x00	; 0
    1364:	ae 27       	eor	r26, r30
    1366:	bf 27       	eor	r27, r31
    1368:	30 e0       	ldi	r19, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    136a:	e1 e0       	ldi	r30, 0x01	; 1
    136c:	f0 ea       	ldi	r31, 0xA0	; 160
    136e:	cd 01       	movw	r24, r26
    1370:	96 95       	lsr	r25
    1372:	87 95       	ror	r24
    1374:	a0 ff       	sbrs	r26, 0
    1376:	04 c0       	rjmp	.+8      	; 0x1380 <FWayneSendCommand+0x4da>
    1378:	dc 01       	movw	r26, r24
    137a:	ae 27       	eor	r26, r30
    137c:	bf 27       	eor	r27, r31
    137e:	01 c0       	rjmp	.+2      	; 0x1382 <FWayneSendCommand+0x4dc>
        else xCRC= (xCRC>> 1);
    1380:	dc 01       	movw	r26, r24
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    1382:	3f 5f       	subi	r19, 0xFF	; 255
    1384:	38 30       	cpi	r19, 0x08	; 8
    1386:	99 f7       	brne	.-26     	; 0x136e <FWayneSendCommand+0x4c8>
	 [51 34 02 01 01 01 01 06 5C BF 03 FA]//Auth4 Nozzle1
     [51 34 02 01 02 01 01 06 5C FB 03 FA]//Auth4 Nozzle2

	 */
          tCRC16=0;
		  CmdBuffer[0]=0x50|(0x0F&xPumpID);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[0]);
    1388:	49 83       	std	Y+1, r20	; 0x01
		  CmdBuffer[1]=0x30|(0x0F&SequenceCmd);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[1]);
    138a:	6a 83       	std	Y+2, r22	; 0x02
		  CmdBuffer[2]=0x02;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[2]);
    138c:	82 e0       	ldi	r24, 0x02	; 2
    138e:	8b 83       	std	Y+3, r24	; 0x03
		  CmdBuffer[3]=0x01;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[3]);
    1390:	81 e0       	ldi	r24, 0x01	; 1
    1392:	8c 83       	std	Y+4, r24	; 0x04
		  CmdBuffer[4]=(NozzleID&0x0F);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[4]);
    1394:	2d 83       	std	Y+5, r18	; 0x05
		  CmdBuffer[5]=0x01;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[5]);
    1396:	8e 83       	std	Y+6, r24	; 0x06
		  CmdBuffer[6]=0x01;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[6]);
    1398:	8f 83       	std	Y+7, r24	; 0x07
		  CmdBuffer[7]=0x06;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[7]);
    139a:	86 e0       	ldi	r24, 0x06	; 6
    139c:	88 87       	std	Y+8, r24	; 0x08
		  CmdBuffer[8]=tCRC16;
    139e:	a9 87       	std	Y+9, r26	; 0x09
		  CmdBuffer[9]=tCRC16>>8;
    13a0:	8b 2f       	mov	r24, r27
    13a2:	99 27       	eor	r25, r25
    13a4:	87 fd       	sbrc	r24, 7
    13a6:	9a 95       	dec	r25
    13a8:	8a 87       	std	Y+10, r24	; 0x0a
		  CmdBuffer[10]=0x03;
    13aa:	83 e0       	ldi	r24, 0x03	; 3
    13ac:	8b 87       	std	Y+11, r24	; 0x0b
		  CmdBuffer[11]=0xFA;
    13ae:	8a ef       	ldi	r24, 0xFA	; 250
    13b0:	8c 87       	std	Y+12, r24	; 0x0c
          FWayneSendBuffer(CmdBuffer,12);
    13b2:	ce 01       	movw	r24, r28
    13b4:	01 96       	adiw	r24, 0x01	; 1
    13b6:	6c e0       	ldi	r22, 0x0C	; 12
    13b8:	6f c1       	rjmp	.+734    	; 0x1698 <FWayneSendCommand+0x7f2>
	      break;     
     case CMD_TOTALIZER://[51] [37] [08 01] [02] [F2 2B] [03 FA] 
          tCRC16=0;     //[51   30   08 01   01   B3 5E   03 FA] //Total N1
		  CmdBuffer[0]=0x50|(0x0F&xPumpID);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[0]);
    13ba:	4f 70       	andi	r20, 0x0F	; 15
    13bc:	40 65       	ori	r20, 0x50	; 80

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    13be:	84 2f       	mov	r24, r20
    13c0:	90 e0       	ldi	r25, 0x00	; 0
    13c2:	30 e0       	ldi	r19, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    13c4:	a1 e0       	ldi	r26, 0x01	; 1
    13c6:	b0 ea       	ldi	r27, 0xA0	; 160
    13c8:	fc 01       	movw	r30, r24
    13ca:	f6 95       	lsr	r31
    13cc:	e7 95       	ror	r30
    13ce:	80 ff       	sbrs	r24, 0
    13d0:	04 c0       	rjmp	.+8      	; 0x13da <FWayneSendCommand+0x534>
    13d2:	cf 01       	movw	r24, r30
    13d4:	8a 27       	eor	r24, r26
    13d6:	9b 27       	eor	r25, r27
    13d8:	01 c0       	rjmp	.+2      	; 0x13dc <FWayneSendCommand+0x536>
        else xCRC= (xCRC>> 1);
    13da:	cf 01       	movw	r24, r30
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    13dc:	3f 5f       	subi	r19, 0xFF	; 255
    13de:	38 30       	cpi	r19, 0x08	; 8
    13e0:	99 f7       	brne	.-26     	; 0x13c8 <FWayneSendCommand+0x522>
          FWayneSendBuffer(CmdBuffer,12);
	      break;     
     case CMD_TOTALIZER://[51] [37] [08 01] [02] [F2 2B] [03 FA] 
          tCRC16=0;     //[51   30   08 01   01   B3 5E   03 FA] //Total N1
		  CmdBuffer[0]=0x50|(0x0F&xPumpID);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[0]);
		  CmdBuffer[1]=0x30|(0x0F&SequenceCmd);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[1]);
    13e2:	6f 70       	andi	r22, 0x0F	; 15
    13e4:	60 63       	ori	r22, 0x30	; 48

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    13e6:	e6 2f       	mov	r30, r22
    13e8:	f0 e0       	ldi	r31, 0x00	; 0
    13ea:	e8 27       	eor	r30, r24
    13ec:	f9 27       	eor	r31, r25
    13ee:	30 e0       	ldi	r19, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    13f0:	a1 e0       	ldi	r26, 0x01	; 1
    13f2:	b0 ea       	ldi	r27, 0xA0	; 160
    13f4:	cf 01       	movw	r24, r30
    13f6:	96 95       	lsr	r25
    13f8:	87 95       	ror	r24
    13fa:	e0 ff       	sbrs	r30, 0
    13fc:	04 c0       	rjmp	.+8      	; 0x1406 <FWayneSendCommand+0x560>
    13fe:	fc 01       	movw	r30, r24
    1400:	ea 27       	eor	r30, r26
    1402:	fb 27       	eor	r31, r27
    1404:	01 c0       	rjmp	.+2      	; 0x1408 <FWayneSendCommand+0x562>
        else xCRC= (xCRC>> 1);
    1406:	fc 01       	movw	r30, r24
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    1408:	3f 5f       	subi	r19, 0xFF	; 255
    140a:	38 30       	cpi	r19, 0x08	; 8
    140c:	99 f7       	brne	.-26     	; 0x13f4 <FWayneSendCommand+0x54e>

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    140e:	88 e0       	ldi	r24, 0x08	; 8
    1410:	90 e0       	ldi	r25, 0x00	; 0
    1412:	8e 27       	eor	r24, r30
    1414:	9f 27       	eor	r25, r31
    1416:	30 e0       	ldi	r19, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    1418:	a1 e0       	ldi	r26, 0x01	; 1
    141a:	b0 ea       	ldi	r27, 0xA0	; 160
    141c:	fc 01       	movw	r30, r24
    141e:	f6 95       	lsr	r31
    1420:	e7 95       	ror	r30
    1422:	80 ff       	sbrs	r24, 0
    1424:	04 c0       	rjmp	.+8      	; 0x142e <FWayneSendCommand+0x588>
    1426:	cf 01       	movw	r24, r30
    1428:	8a 27       	eor	r24, r26
    142a:	9b 27       	eor	r25, r27
    142c:	01 c0       	rjmp	.+2      	; 0x1430 <FWayneSendCommand+0x58a>
        else xCRC= (xCRC>> 1);
    142e:	cf 01       	movw	r24, r30
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    1430:	3f 5f       	subi	r19, 0xFF	; 255
    1432:	38 30       	cpi	r19, 0x08	; 8
    1434:	99 f7       	brne	.-26     	; 0x141c <FWayneSendCommand+0x576>

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    1436:	e1 e0       	ldi	r30, 0x01	; 1
    1438:	f0 e0       	ldi	r31, 0x00	; 0
    143a:	e8 27       	eor	r30, r24
    143c:	f9 27       	eor	r31, r25
    143e:	30 e0       	ldi	r19, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    1440:	a1 e0       	ldi	r26, 0x01	; 1
    1442:	b0 ea       	ldi	r27, 0xA0	; 160
    1444:	cf 01       	movw	r24, r30
    1446:	96 95       	lsr	r25
    1448:	87 95       	ror	r24
    144a:	e0 ff       	sbrs	r30, 0
    144c:	04 c0       	rjmp	.+8      	; 0x1456 <FWayneSendCommand+0x5b0>
    144e:	fc 01       	movw	r30, r24
    1450:	ea 27       	eor	r30, r26
    1452:	fb 27       	eor	r31, r27
    1454:	01 c0       	rjmp	.+2      	; 0x1458 <FWayneSendCommand+0x5b2>
        else xCRC= (xCRC>> 1);
    1456:	fc 01       	movw	r30, r24
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    1458:	3f 5f       	subi	r19, 0xFF	; 255
    145a:	38 30       	cpi	r19, 0x08	; 8
    145c:	99 f7       	brne	.-26     	; 0x1444 <FWayneSendCommand+0x59e>
          tCRC16=0;     //[51   30   08 01   01   B3 5E   03 FA] //Total N1
		  CmdBuffer[0]=0x50|(0x0F&xPumpID);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[0]);
		  CmdBuffer[1]=0x30|(0x0F&SequenceCmd);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[1]);
		  CmdBuffer[2]=0x08;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[2]);
		  CmdBuffer[3]=0x01;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[3]);
		  CmdBuffer[4]=(NozzleID&0x0F);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[4]);
    145e:	2f 70       	andi	r18, 0x0F	; 15

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    1460:	a2 2f       	mov	r26, r18
    1462:	b0 e0       	ldi	r27, 0x00	; 0
    1464:	ae 27       	eor	r26, r30
    1466:	bf 27       	eor	r27, r31
    1468:	30 e0       	ldi	r19, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    146a:	e1 e0       	ldi	r30, 0x01	; 1
    146c:	f0 ea       	ldi	r31, 0xA0	; 160
    146e:	cd 01       	movw	r24, r26
    1470:	96 95       	lsr	r25
    1472:	87 95       	ror	r24
    1474:	a0 ff       	sbrs	r26, 0
    1476:	04 c0       	rjmp	.+8      	; 0x1480 <FWayneSendCommand+0x5da>
    1478:	dc 01       	movw	r26, r24
    147a:	ae 27       	eor	r26, r30
    147c:	bf 27       	eor	r27, r31
    147e:	01 c0       	rjmp	.+2      	; 0x1482 <FWayneSendCommand+0x5dc>
        else xCRC= (xCRC>> 1);
    1480:	dc 01       	movw	r26, r24
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    1482:	3f 5f       	subi	r19, 0xFF	; 255
    1484:	38 30       	cpi	r19, 0x08	; 8
    1486:	99 f7       	brne	.-26     	; 0x146e <FWayneSendCommand+0x5c8>
		  CmdBuffer[11]=0xFA;
          FWayneSendBuffer(CmdBuffer,12);
	      break;     
     case CMD_TOTALIZER://[51] [37] [08 01] [02] [F2 2B] [03 FA] 
          tCRC16=0;     //[51   30   08 01   01   B3 5E   03 FA] //Total N1
		  CmdBuffer[0]=0x50|(0x0F&xPumpID);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[0]);
    1488:	49 83       	std	Y+1, r20	; 0x01
		  CmdBuffer[1]=0x30|(0x0F&SequenceCmd);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[1]);
    148a:	6a 83       	std	Y+2, r22	; 0x02
		  CmdBuffer[2]=0x08;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[2]);
    148c:	3b 83       	std	Y+3, r19	; 0x03
		  CmdBuffer[3]=0x01;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[3]);
    148e:	81 e0       	ldi	r24, 0x01	; 1
    1490:	8c 83       	std	Y+4, r24	; 0x04
		  CmdBuffer[4]=(NozzleID&0x0F);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[4]);
    1492:	2d 83       	std	Y+5, r18	; 0x05
		  CmdBuffer[5]=tCRC16;
    1494:	ae 83       	std	Y+6, r26	; 0x06
		  CmdBuffer[6]=tCRC16>>8;
    1496:	8b 2f       	mov	r24, r27
    1498:	99 27       	eor	r25, r25
    149a:	87 fd       	sbrc	r24, 7
    149c:	9a 95       	dec	r25
    149e:	8f 83       	std	Y+7, r24	; 0x07
		  CmdBuffer[7]=0x03;
    14a0:	83 e0       	ldi	r24, 0x03	; 3
    14a2:	88 87       	std	Y+8, r24	; 0x08
		  CmdBuffer[8]=0xFA;
    14a4:	8a ef       	ldi	r24, 0xFA	; 250
    14a6:	89 87       	std	Y+9, r24	; 0x09
          FWayneSendBuffer(CmdBuffer,9);
    14a8:	ce 01       	movw	r24, r28
    14aa:	01 96       	adiw	r24, 0x01	; 1
    14ac:	69 e0       	ldi	r22, 0x09	; 9
    14ae:	f4 c0       	rjmp	.+488    	; 0x1698 <FWayneSendCommand+0x7f2>
	 /*
  	   [51 30 [01 01] 00 01 01 04 01 01 03 E4 2E [03 FA] //Get Last Status

	 */
          tCRC16=0;
		  CmdBuffer[0]=0x50|(0x0F&xPumpID);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[0]);
    14b0:	4f 70       	andi	r20, 0x0F	; 15
    14b2:	40 65       	ori	r20, 0x50	; 80

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    14b4:	84 2f       	mov	r24, r20
    14b6:	90 e0       	ldi	r25, 0x00	; 0
    14b8:	50 e0       	ldi	r21, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    14ba:	e1 e0       	ldi	r30, 0x01	; 1
    14bc:	f0 ea       	ldi	r31, 0xA0	; 160
    14be:	9c 01       	movw	r18, r24
    14c0:	36 95       	lsr	r19
    14c2:	27 95       	ror	r18
    14c4:	80 ff       	sbrs	r24, 0
    14c6:	04 c0       	rjmp	.+8      	; 0x14d0 <FWayneSendCommand+0x62a>
    14c8:	c9 01       	movw	r24, r18
    14ca:	8e 27       	eor	r24, r30
    14cc:	9f 27       	eor	r25, r31
    14ce:	01 c0       	rjmp	.+2      	; 0x14d2 <FWayneSendCommand+0x62c>
        else xCRC= (xCRC>> 1);
    14d0:	c9 01       	movw	r24, r18
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    14d2:	5f 5f       	subi	r21, 0xFF	; 255
    14d4:	58 30       	cpi	r21, 0x08	; 8
    14d6:	99 f7       	brne	.-26     	; 0x14be <FWayneSendCommand+0x618>
  	   [51 30 [01 01] 00 01 01 04 01 01 03 E4 2E [03 FA] //Get Last Status

	 */
          tCRC16=0;
		  CmdBuffer[0]=0x50|(0x0F&xPumpID);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[0]);
		  CmdBuffer[1]=0x30|(0x0F&SequenceCmd);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[1]);
    14d8:	6f 70       	andi	r22, 0x0F	; 15
    14da:	60 63       	ori	r22, 0x30	; 48

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    14dc:	26 2f       	mov	r18, r22
    14de:	30 e0       	ldi	r19, 0x00	; 0
    14e0:	28 27       	eor	r18, r24
    14e2:	39 27       	eor	r19, r25
    14e4:	50 e0       	ldi	r21, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    14e6:	e1 e0       	ldi	r30, 0x01	; 1
    14e8:	f0 ea       	ldi	r31, 0xA0	; 160
    14ea:	c9 01       	movw	r24, r18
    14ec:	96 95       	lsr	r25
    14ee:	87 95       	ror	r24
    14f0:	20 ff       	sbrs	r18, 0
    14f2:	04 c0       	rjmp	.+8      	; 0x14fc <FWayneSendCommand+0x656>
    14f4:	9c 01       	movw	r18, r24
    14f6:	2e 27       	eor	r18, r30
    14f8:	3f 27       	eor	r19, r31
    14fa:	01 c0       	rjmp	.+2      	; 0x14fe <FWayneSendCommand+0x658>
        else xCRC= (xCRC>> 1);
    14fc:	9c 01       	movw	r18, r24
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    14fe:	5f 5f       	subi	r21, 0xFF	; 255
    1500:	58 30       	cpi	r21, 0x08	; 8
    1502:	99 f7       	brne	.-26     	; 0x14ea <FWayneSendCommand+0x644>

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    1504:	81 e0       	ldi	r24, 0x01	; 1
    1506:	90 e0       	ldi	r25, 0x00	; 0
    1508:	82 27       	eor	r24, r18
    150a:	93 27       	eor	r25, r19
    150c:	50 e0       	ldi	r21, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    150e:	e1 e0       	ldi	r30, 0x01	; 1
    1510:	f0 ea       	ldi	r31, 0xA0	; 160
    1512:	9c 01       	movw	r18, r24
    1514:	36 95       	lsr	r19
    1516:	27 95       	ror	r18
    1518:	80 ff       	sbrs	r24, 0
    151a:	04 c0       	rjmp	.+8      	; 0x1524 <FWayneSendCommand+0x67e>
    151c:	c9 01       	movw	r24, r18
    151e:	8e 27       	eor	r24, r30
    1520:	9f 27       	eor	r25, r31
    1522:	01 c0       	rjmp	.+2      	; 0x1526 <FWayneSendCommand+0x680>
        else xCRC= (xCRC>> 1);
    1524:	c9 01       	movw	r24, r18
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    1526:	5f 5f       	subi	r21, 0xFF	; 255
    1528:	58 30       	cpi	r21, 0x08	; 8
    152a:	99 f7       	brne	.-26     	; 0x1512 <FWayneSendCommand+0x66c>

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    152c:	21 e0       	ldi	r18, 0x01	; 1
    152e:	30 e0       	ldi	r19, 0x00	; 0
    1530:	28 27       	eor	r18, r24
    1532:	39 27       	eor	r19, r25
    1534:	50 e0       	ldi	r21, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    1536:	e1 e0       	ldi	r30, 0x01	; 1
    1538:	f0 ea       	ldi	r31, 0xA0	; 160
    153a:	c9 01       	movw	r24, r18
    153c:	96 95       	lsr	r25
    153e:	87 95       	ror	r24
    1540:	20 ff       	sbrs	r18, 0
    1542:	04 c0       	rjmp	.+8      	; 0x154c <FWayneSendCommand+0x6a6>
    1544:	9c 01       	movw	r18, r24
    1546:	2e 27       	eor	r18, r30
    1548:	3f 27       	eor	r19, r31
    154a:	01 c0       	rjmp	.+2      	; 0x154e <FWayneSendCommand+0x6a8>
        else xCRC= (xCRC>> 1);
    154c:	9c 01       	movw	r18, r24
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    154e:	5f 5f       	subi	r21, 0xFF	; 255
    1550:	58 30       	cpi	r21, 0x08	; 8
    1552:	99 f7       	brne	.-26     	; 0x153a <FWayneSendCommand+0x694>
    1554:	50 e0       	ldi	r21, 0x00	; 0
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    1556:	e1 e0       	ldi	r30, 0x01	; 1
    1558:	f0 ea       	ldi	r31, 0xA0	; 160
    155a:	c9 01       	movw	r24, r18
    155c:	96 95       	lsr	r25
    155e:	87 95       	ror	r24
    1560:	20 ff       	sbrs	r18, 0
    1562:	04 c0       	rjmp	.+8      	; 0x156c <FWayneSendCommand+0x6c6>
    1564:	9c 01       	movw	r18, r24
    1566:	2e 27       	eor	r18, r30
    1568:	3f 27       	eor	r19, r31
    156a:	01 c0       	rjmp	.+2      	; 0x156e <FWayneSendCommand+0x6c8>
        else xCRC= (xCRC>> 1);
    156c:	9c 01       	movw	r18, r24
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    156e:	5f 5f       	subi	r21, 0xFF	; 255
    1570:	58 30       	cpi	r21, 0x08	; 8
    1572:	99 f7       	brne	.-26     	; 0x155a <FWayneSendCommand+0x6b4>

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    1574:	81 e0       	ldi	r24, 0x01	; 1
    1576:	90 e0       	ldi	r25, 0x00	; 0
    1578:	82 27       	eor	r24, r18
    157a:	93 27       	eor	r25, r19
    157c:	50 e0       	ldi	r21, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    157e:	e1 e0       	ldi	r30, 0x01	; 1
    1580:	f0 ea       	ldi	r31, 0xA0	; 160
    1582:	9c 01       	movw	r18, r24
    1584:	36 95       	lsr	r19
    1586:	27 95       	ror	r18
    1588:	80 ff       	sbrs	r24, 0
    158a:	04 c0       	rjmp	.+8      	; 0x1594 <FWayneSendCommand+0x6ee>
    158c:	c9 01       	movw	r24, r18
    158e:	8e 27       	eor	r24, r30
    1590:	9f 27       	eor	r25, r31
    1592:	01 c0       	rjmp	.+2      	; 0x1596 <FWayneSendCommand+0x6f0>
        else xCRC= (xCRC>> 1);
    1594:	c9 01       	movw	r24, r18
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    1596:	5f 5f       	subi	r21, 0xFF	; 255
    1598:	58 30       	cpi	r21, 0x08	; 8
    159a:	99 f7       	brne	.-26     	; 0x1582 <FWayneSendCommand+0x6dc>

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    159c:	21 e0       	ldi	r18, 0x01	; 1
    159e:	30 e0       	ldi	r19, 0x00	; 0
    15a0:	28 27       	eor	r18, r24
    15a2:	39 27       	eor	r19, r25
    15a4:	50 e0       	ldi	r21, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    15a6:	e1 e0       	ldi	r30, 0x01	; 1
    15a8:	f0 ea       	ldi	r31, 0xA0	; 160
    15aa:	c9 01       	movw	r24, r18
    15ac:	96 95       	lsr	r25
    15ae:	87 95       	ror	r24
    15b0:	20 ff       	sbrs	r18, 0
    15b2:	04 c0       	rjmp	.+8      	; 0x15bc <FWayneSendCommand+0x716>
    15b4:	9c 01       	movw	r18, r24
    15b6:	2e 27       	eor	r18, r30
    15b8:	3f 27       	eor	r19, r31
    15ba:	01 c0       	rjmp	.+2      	; 0x15be <FWayneSendCommand+0x718>
        else xCRC= (xCRC>> 1);
    15bc:	9c 01       	movw	r18, r24
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    15be:	5f 5f       	subi	r21, 0xFF	; 255
    15c0:	58 30       	cpi	r21, 0x08	; 8
    15c2:	99 f7       	brne	.-26     	; 0x15aa <FWayneSendCommand+0x704>

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    15c4:	84 e0       	ldi	r24, 0x04	; 4
    15c6:	90 e0       	ldi	r25, 0x00	; 0
    15c8:	82 27       	eor	r24, r18
    15ca:	93 27       	eor	r25, r19
    15cc:	50 e0       	ldi	r21, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    15ce:	e1 e0       	ldi	r30, 0x01	; 1
    15d0:	f0 ea       	ldi	r31, 0xA0	; 160
    15d2:	9c 01       	movw	r18, r24
    15d4:	36 95       	lsr	r19
    15d6:	27 95       	ror	r18
    15d8:	80 ff       	sbrs	r24, 0
    15da:	04 c0       	rjmp	.+8      	; 0x15e4 <FWayneSendCommand+0x73e>
    15dc:	c9 01       	movw	r24, r18
    15de:	8e 27       	eor	r24, r30
    15e0:	9f 27       	eor	r25, r31
    15e2:	01 c0       	rjmp	.+2      	; 0x15e6 <FWayneSendCommand+0x740>
        else xCRC= (xCRC>> 1);
    15e4:	c9 01       	movw	r24, r18
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    15e6:	5f 5f       	subi	r21, 0xFF	; 255
    15e8:	58 30       	cpi	r21, 0x08	; 8
    15ea:	99 f7       	brne	.-26     	; 0x15d2 <FWayneSendCommand+0x72c>

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    15ec:	21 e0       	ldi	r18, 0x01	; 1
    15ee:	30 e0       	ldi	r19, 0x00	; 0
    15f0:	28 27       	eor	r18, r24
    15f2:	39 27       	eor	r19, r25
    15f4:	50 e0       	ldi	r21, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    15f6:	e1 e0       	ldi	r30, 0x01	; 1
    15f8:	f0 ea       	ldi	r31, 0xA0	; 160
    15fa:	c9 01       	movw	r24, r18
    15fc:	96 95       	lsr	r25
    15fe:	87 95       	ror	r24
    1600:	20 ff       	sbrs	r18, 0
    1602:	04 c0       	rjmp	.+8      	; 0x160c <FWayneSendCommand+0x766>
    1604:	9c 01       	movw	r18, r24
    1606:	2e 27       	eor	r18, r30
    1608:	3f 27       	eor	r19, r31
    160a:	01 c0       	rjmp	.+2      	; 0x160e <FWayneSendCommand+0x768>
        else xCRC= (xCRC>> 1);
    160c:	9c 01       	movw	r18, r24
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    160e:	5f 5f       	subi	r21, 0xFF	; 255
    1610:	58 30       	cpi	r21, 0x08	; 8
    1612:	99 f7       	brne	.-26     	; 0x15fa <FWayneSendCommand+0x754>

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    1614:	81 e0       	ldi	r24, 0x01	; 1
    1616:	90 e0       	ldi	r25, 0x00	; 0
    1618:	82 27       	eor	r24, r18
    161a:	93 27       	eor	r25, r19
    161c:	50 e0       	ldi	r21, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    161e:	e1 e0       	ldi	r30, 0x01	; 1
    1620:	f0 ea       	ldi	r31, 0xA0	; 160
    1622:	9c 01       	movw	r18, r24
    1624:	36 95       	lsr	r19
    1626:	27 95       	ror	r18
    1628:	80 ff       	sbrs	r24, 0
    162a:	04 c0       	rjmp	.+8      	; 0x1634 <FWayneSendCommand+0x78e>
    162c:	c9 01       	movw	r24, r18
    162e:	8e 27       	eor	r24, r30
    1630:	9f 27       	eor	r25, r31
    1632:	01 c0       	rjmp	.+2      	; 0x1636 <FWayneSendCommand+0x790>
        else xCRC= (xCRC>> 1);
    1634:	c9 01       	movw	r24, r18
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    1636:	5f 5f       	subi	r21, 0xFF	; 255
    1638:	58 30       	cpi	r21, 0x08	; 8
    163a:	99 f7       	brne	.-26     	; 0x1622 <FWayneSendCommand+0x77c>

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    163c:	e3 e0       	ldi	r30, 0x03	; 3
    163e:	f0 e0       	ldi	r31, 0x00	; 0
    1640:	e8 27       	eor	r30, r24
    1642:	f9 27       	eor	r31, r25
    1644:	20 e0       	ldi	r18, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    1646:	a1 e0       	ldi	r26, 0x01	; 1
    1648:	b0 ea       	ldi	r27, 0xA0	; 160
    164a:	cf 01       	movw	r24, r30
    164c:	96 95       	lsr	r25
    164e:	87 95       	ror	r24
    1650:	e0 ff       	sbrs	r30, 0
    1652:	04 c0       	rjmp	.+8      	; 0x165c <FWayneSendCommand+0x7b6>
    1654:	fc 01       	movw	r30, r24
    1656:	ea 27       	eor	r30, r26
    1658:	fb 27       	eor	r31, r27
    165a:	01 c0       	rjmp	.+2      	; 0x165e <FWayneSendCommand+0x7b8>
        else xCRC= (xCRC>> 1);
    165c:	fc 01       	movw	r30, r24
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    165e:	2f 5f       	subi	r18, 0xFF	; 255
    1660:	28 30       	cpi	r18, 0x08	; 8
    1662:	99 f7       	brne	.-26     	; 0x164a <FWayneSendCommand+0x7a4>
	 /*
  	   [51 30 [01 01] 00 01 01 04 01 01 03 E4 2E [03 FA] //Get Last Status

	 */
          tCRC16=0;
		  CmdBuffer[0]=0x50|(0x0F&xPumpID);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[0]);
    1664:	49 83       	std	Y+1, r20	; 0x01
		  CmdBuffer[1]=0x30|(0x0F&SequenceCmd);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[1]);
    1666:	6a 83       	std	Y+2, r22	; 0x02
		  CmdBuffer[2]=0x01;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[2]);
    1668:	91 e0       	ldi	r25, 0x01	; 1
    166a:	9b 83       	std	Y+3, r25	; 0x03
		  CmdBuffer[3]=0x01;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[3]);
    166c:	9c 83       	std	Y+4, r25	; 0x04
		  CmdBuffer[4]=0x00;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[4]);
    166e:	1d 82       	std	Y+5, r1	; 0x05
		  CmdBuffer[5]=0x01;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[5]);
    1670:	9e 83       	std	Y+6, r25	; 0x06
		  CmdBuffer[6]=0x01;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[6]);
    1672:	9f 83       	std	Y+7, r25	; 0x07
		  CmdBuffer[7]=0x04;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[7]);
    1674:	84 e0       	ldi	r24, 0x04	; 4
    1676:	88 87       	std	Y+8, r24	; 0x08
		  CmdBuffer[8]=0x01;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[8]);
    1678:	99 87       	std	Y+9, r25	; 0x09
		  CmdBuffer[9]=0x01;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[9]);
    167a:	9a 87       	std	Y+10, r25	; 0x0a
		  CmdBuffer[10]=0x03;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[10]);
    167c:	23 e0       	ldi	r18, 0x03	; 3
    167e:	2b 87       	std	Y+11, r18	; 0x0b
		  CmdBuffer[11]=tCRC16;
    1680:	ec 87       	std	Y+12, r30	; 0x0c
		  CmdBuffer[12]=tCRC16>>8;
    1682:	8f 2f       	mov	r24, r31
    1684:	99 27       	eor	r25, r25
    1686:	87 fd       	sbrc	r24, 7
    1688:	9a 95       	dec	r25
    168a:	8d 87       	std	Y+13, r24	; 0x0d
		  CmdBuffer[13]=0x03;
    168c:	2e 87       	std	Y+14, r18	; 0x0e
		  CmdBuffer[14]=0xFA;
    168e:	8a ef       	ldi	r24, 0xFA	; 250
    1690:	8f 87       	std	Y+15, r24	; 0x0f
          FWayneSendBuffer(CmdBuffer,15);
    1692:	ce 01       	movw	r24, r28
    1694:	01 96       	adiw	r24, 0x01	; 1
    1696:	6f e0       	ldi	r22, 0x0F	; 15
    1698:	0e 94 40 07 	call	0xe80	; 0xe80 <FWayneSendBuffer>
	      break;
     case CMD_REQ_GLOBAL_STATUS_2:
  	      break;
	 }	 
}
    169c:	6e 96       	adiw	r28, 0x1e	; 30
    169e:	0f b6       	in	r0, 0x3f	; 63
    16a0:	f8 94       	cli
    16a2:	de bf       	out	0x3e, r29	; 62
    16a4:	0f be       	out	0x3f, r0	; 63
    16a6:	cd bf       	out	0x3d, r28	; 61
    16a8:	cf 91       	pop	r28
    16aa:	df 91       	pop	r29
    16ac:	1f 91       	pop	r17
    16ae:	0f 91       	pop	r16
    16b0:	08 95       	ret

000016b2 <TerminalSendf>:
	 SendSPI(AckData);
	 SendSPI(0x0A);
	 systemSlave();
}

void TerminalSendf(char Com,char *strSendf){
    16b2:	1f 93       	push	r17
    16b4:	cf 93       	push	r28
    16b6:	df 93       	push	r29
    16b8:	18 2f       	mov	r17, r24
    16ba:	eb 01       	movw	r28, r22
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    16bc:	e1 99       	sbic	0x1c, 1	; 28
    16be:	fe cf       	rjmp	.-4      	; 0x16bc <TerminalSendf+0xa>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    16c0:	84 e0       	ldi	r24, 0x04	; 4
    16c2:	90 e0       	ldi	r25, 0x00	; 0
    16c4:	9f bb       	out	0x1f, r25	; 31
    16c6:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    16c8:	e0 9a       	sbi	0x1c, 0	; 28
    16ca:	8d b3       	in	r24, 0x1d	; 29
   if (eeprom_read_byte(&DefTerminalDebug)){
    16cc:	88 23       	and	r24, r24
    16ce:	41 f4       	brne	.+16     	; 0x16e0 <TerminalSendf+0x2e>
    16d0:	0c c0       	rjmp	.+24     	; 0x16ea <TerminalSendf+0x38>
       while(pgm_read_byte(&(*strSendf)))
	         _uart(Com, 1, pgm_read_byte(&(*strSendf++)));
    16d2:	21 96       	adiw	r28, 0x01	; 1
    16d4:	f9 01       	movw	r30, r18
    16d6:	44 91       	lpm	r20, Z+
    16d8:	81 2f       	mov	r24, r17
    16da:	61 e0       	ldi	r22, 0x01	; 1
    16dc:	0e 94 4a 18 	call	0x3094	; 0x3094 <_uart>
    16e0:	9e 01       	movw	r18, r28
	 systemSlave();
}

void TerminalSendf(char Com,char *strSendf){
   if (eeprom_read_byte(&DefTerminalDebug)){
       while(pgm_read_byte(&(*strSendf)))
    16e2:	fe 01       	movw	r30, r28
    16e4:	84 91       	lpm	r24, Z+
    16e6:	88 23       	and	r24, r24
    16e8:	a1 f7       	brne	.-24     	; 0x16d2 <TerminalSendf+0x20>
	         _uart(Com, 1, pgm_read_byte(&(*strSendf++)));
	}
}
    16ea:	df 91       	pop	r29
    16ec:	cf 91       	pop	r28
    16ee:	1f 91       	pop	r17
    16f0:	08 95       	ret

000016f2 <__vector_19>:
	if ((TimExp%100)==0) TimWatchSequence++;
	TimReceive++;
	TimDelayNextPump++;
}

ISR(USART0_RXC_vect){
    16f2:	1f 92       	push	r1
    16f4:	0f 92       	push	r0
    16f6:	0f b6       	in	r0, 0x3f	; 63
    16f8:	0f 92       	push	r0
    16fa:	11 24       	eor	r1, r1
    16fc:	1f 93       	push	r17
    16fe:	2f 93       	push	r18
    1700:	3f 93       	push	r19
    1702:	4f 93       	push	r20
    1704:	5f 93       	push	r21
    1706:	6f 93       	push	r22
    1708:	7f 93       	push	r23
    170a:	8f 93       	push	r24
    170c:	9f 93       	push	r25
    170e:	af 93       	push	r26
    1710:	bf 93       	push	r27
    1712:	ef 93       	push	r30
    1714:	ff 93       	push	r31
    char dataRX0;
	char strSend[20];
	dataRX0=UDR0;
    1716:	1c b1       	in	r17, 0x0c	; 12
    //_uart(1,1,dataRX0);
    //15702 15588 15694
	switch(IFType){
    1718:	80 91 00 01 	lds	r24, 0x0100
    171c:	81 30       	cpi	r24, 0x01	; 1
    171e:	19 f0       	breq	.+6      	; 0x1726 <__vector_19+0x34>
    1720:	82 30       	cpi	r24, 0x02	; 2
    1722:	09 f5       	brne	.+66     	; 0x1766 <__vector_19+0x74>
    1724:	12 c0       	rjmp	.+36     	; 0x174a <__vector_19+0x58>
	case IT_SLAVE:
	     systemMaster();
    1726:	0e 94 bb 06 	call	0xd76	; 0xd76 <systemMaster>
	     _spi(dataRX0);
    172a:	81 2f       	mov	r24, r17
    172c:	0e 94 80 17 	call	0x2f00	; 0x2f00 <_spi>

         _uart(0,1,dataRX0);
    1730:	80 e0       	ldi	r24, 0x00	; 0
    1732:	61 e0       	ldi	r22, 0x01	; 1
    1734:	41 2f       	mov	r20, r17
    1736:	0e 94 4a 18 	call	0x3094	; 0x3094 <_uart>
		 _uart(1,1,dataRX0);
    173a:	81 e0       	ldi	r24, 0x01	; 1
    173c:	61 e0       	ldi	r22, 0x01	; 1
    173e:	41 2f       	mov	r20, r17
    1740:	0e 94 4a 18 	call	0x3094	; 0x3094 <_uart>

	     systemSlave();
    1744:	0e 94 ae 06 	call	0xd5c	; 0xd5c <systemSlave>
    1748:	0e c0       	rjmp	.+28     	; 0x1766 <__vector_19+0x74>
	     break;
    case IT_STANDALONE:
	     switch(StandaloneType){
    174a:	80 91 01 01 	lds	r24, 0x0101
    174e:	81 30       	cpi	r24, 0x01	; 1
    1750:	19 f0       	breq	.+6      	; 0x1758 <__vector_19+0x66>
    1752:	82 30       	cpi	r24, 0x02	; 2
    1754:	41 f4       	brne	.+16     	; 0x1766 <__vector_19+0x74>
    1756:	04 c0       	rjmp	.+8      	; 0x1760 <__vector_19+0x6e>
		 case ST_GILBARCO:
		      GilbarcoOnReceive(dataRX0);	
    1758:	81 2f       	mov	r24, r17
    175a:	0e 94 cf 05 	call	0xb9e	; 0xb9e <GilbarcoOnReceive>
    175e:	03 c0       	rjmp	.+6      	; 0x1766 <__vector_19+0x74>
			  break;
		 case ST_WAYNE_DART:
		      WayneOnReceive(dataRX0);	              
    1760:	81 2f       	mov	r24, r17
    1762:	0e 94 96 04 	call	0x92c	; 0x92c <WayneOnReceive>
			  //_uart_print(1,1,strSend);
			  break;
		 }
     }
	 */		 
}
    1766:	ff 91       	pop	r31
    1768:	ef 91       	pop	r30
    176a:	bf 91       	pop	r27
    176c:	af 91       	pop	r26
    176e:	9f 91       	pop	r25
    1770:	8f 91       	pop	r24
    1772:	7f 91       	pop	r23
    1774:	6f 91       	pop	r22
    1776:	5f 91       	pop	r21
    1778:	4f 91       	pop	r20
    177a:	3f 91       	pop	r19
    177c:	2f 91       	pop	r18
    177e:	1f 91       	pop	r17
    1780:	0f 90       	pop	r0
    1782:	0f be       	out	0x3f, r0	; 63
    1784:	0f 90       	pop	r0
    1786:	1f 90       	pop	r1
    1788:	18 95       	reti

0000178a <SendTotalizerFlow>:
	    SendSPI(strSendSPI[i]);
        //_uart(1,1,strSendSPI[i]);
	 } 
}

void SendTotalizerFlow(char xPumpID){
    178a:	4f 92       	push	r4
    178c:	5f 92       	push	r5
    178e:	6f 92       	push	r6
    1790:	7f 92       	push	r7
    1792:	8f 92       	push	r8
    1794:	9f 92       	push	r9
    1796:	af 92       	push	r10
    1798:	bf 92       	push	r11
    179a:	cf 92       	push	r12
    179c:	df 92       	push	r13
    179e:	ef 92       	push	r14
    17a0:	ff 92       	push	r15
    17a2:	0f 93       	push	r16
    17a4:	1f 93       	push	r17
    17a6:	df 93       	push	r29
    17a8:	cf 93       	push	r28
    17aa:	cd b7       	in	r28, 0x3d	; 61
    17ac:	de b7       	in	r29, 0x3e	; 62
    17ae:	a8 97       	sbiw	r28, 0x28	; 40
    17b0:	0f b6       	in	r0, 0x3f	; 63
    17b2:	f8 94       	cli
    17b4:	de bf       	out	0x3e, r29	; 62
    17b6:	0f be       	out	0x3f, r0	; 63
    17b8:	cd bf       	out	0x3d, r28	; 61
char i,xPump,strSend[40];
char strVol[10],strMon[10];
	 //                           [0x50,0x05]  02     01    0000000  0000000  0000000  0000000  0000200  0000000  0000200  0000000  0000000  0000000 [0x06,0x60] = 4+8*2*6=76
	 //Sending FlowSPI_Protocol     <STX>   [MsgID][PumpID][Volume1][Amount1][Volume2][Amount2][Volume3][Amount3][Volume4][Amount4][Volume5][Amount5][Volume6][Amount6]<ETX>
	 if (xPumpID>=16)xPump=16;
    17ba:	80 31       	cpi	r24, 0x10	; 16
    17bc:	10 f4       	brcc	.+4      	; 0x17c2 <SendTotalizerFlow+0x38>
    17be:	f8 2e       	mov	r15, r24
    17c0:	02 c0       	rjmp	.+4      	; 0x17c6 <SendTotalizerFlow+0x3c>
    17c2:	00 e1       	ldi	r16, 0x10	; 16
    17c4:	f0 2e       	mov	r15, r16
	 else xPump=xPumpID;
                                                
	 systemMaster();
    17c6:	0e 94 bb 06 	call	0xd76	; 0xd76 <systemMaster>
	sbi(DDRD,2);sbi(PORTD,2);//128-SS HIGH
	//_delay_ms(10);
}

void SendSPI(char xSPI){
     _spi(xSPI);
    17ca:	85 e0       	ldi	r24, 0x05	; 5
    17cc:	0e 94 80 17 	call	0x2f00	; 0x2f00 <_spi>
void uartGilbarco(){
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    17d0:	80 e5       	ldi	r24, 0x50	; 80
    17d2:	0e 94 80 17 	call	0x2f00	; 0x2f00 <_spi>
    17d6:	2e 01       	movw	r4, r28
    17d8:	08 94       	sec
    17da:	41 1c       	adc	r4, r1
    17dc:	51 1c       	adc	r5, r1
    17de:	52 01       	movw	r10, r4
    17e0:	ce 01       	movw	r24, r28
    17e2:	89 96       	adiw	r24, 0x29	; 41
	     strMemory[i]=data;
    17e4:	d5 01       	movw	r26, r10
    17e6:	1d 92       	st	X+, r1
    17e8:	5d 01       	movw	r10, r26
void uartGilbarco(){
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    17ea:	a8 17       	cp	r26, r24
    17ec:	b9 07       	cpc	r27, r25
    17ee:	d1 f7       	brne	.-12     	; 0x17e4 <SendTotalizerFlow+0x5a>
	 systemMaster();
	 SendSPI(0x05);//STX
	 SendSPI(0x50);//STX
	 FillChar(strSend,sizeof(strSend),0);
	
	 sprintf_P(strSend,PSTR("02%.2d"),xPump);
    17f0:	00 d0       	rcall	.+0      	; 0x17f2 <SendTotalizerFlow+0x68>
    17f2:	00 d0       	rcall	.+0      	; 0x17f4 <SendTotalizerFlow+0x6a>
    17f4:	00 d0       	rcall	.+0      	; 0x17f6 <SendTotalizerFlow+0x6c>
    17f6:	ed b7       	in	r30, 0x3d	; 61
    17f8:	fe b7       	in	r31, 0x3e	; 62
    17fa:	31 96       	adiw	r30, 0x01	; 1
    17fc:	8e 01       	movw	r16, r28
    17fe:	0f 5f       	subi	r16, 0xFF	; 255
    1800:	1f 4f       	sbci	r17, 0xFF	; 255
    1802:	ad b7       	in	r26, 0x3d	; 61
    1804:	be b7       	in	r27, 0x3e	; 62
    1806:	12 96       	adiw	r26, 0x02	; 2
    1808:	1c 93       	st	X, r17
    180a:	0e 93       	st	-X, r16
    180c:	11 97       	sbiw	r26, 0x01	; 1
    180e:	80 e4       	ldi	r24, 0x40	; 64
    1810:	91 e0       	ldi	r25, 0x01	; 1
    1812:	93 83       	std	Z+3, r25	; 0x03
    1814:	82 83       	std	Z+2, r24	; 0x02
    1816:	f4 82       	std	Z+4, r15	; 0x04
    1818:	15 82       	std	Z+5, r1	; 0x05
    181a:	0e 94 b2 18 	call	0x3164	; 0x3164 <sprintf_P>
     SendStrSPI(strSend);
    181e:	ed b7       	in	r30, 0x3d	; 61
    1820:	fe b7       	in	r31, 0x3e	; 62
    1822:	36 96       	adiw	r30, 0x06	; 6
    1824:	0f b6       	in	r0, 0x3f	; 63
    1826:	f8 94       	cli
    1828:	fe bf       	out	0x3e, r31	; 62
    182a:	0f be       	out	0x3f, r0	; 63
    182c:	ed bf       	out	0x3d, r30	; 61
    182e:	c8 01       	movw	r24, r16
    1830:	0e 94 8e 06 	call	0xd1c	; 0xd1c <SendStrSPI>
    1834:	ee 24       	eor	r14, r14
    1836:	ff 24       	eor	r15, r15
     for (i=0;i<6;i++){
	      //FixingData V:[00000000] M:[00000000]
		  AddZeroLead(PumpTotalizer.TotalGrade[i].strMoney,12);
		  AddZeroLead(PumpTotalizer.TotalGrade[i].strVolume,12);
		  FillChar(strSend,sizeof(strSend),0);
		  sprintf_P(strSend,PSTR("%s%s"),PumpTotalizer.TotalGrade[i].strVolume,PumpTotalizer.TotalGrade[i].strMoney);
    1838:	90 2e       	mov	r9, r16
    183a:	81 2e       	mov	r8, r17
    183c:	1b e3       	ldi	r17, 0x3B	; 59
    183e:	61 2e       	mov	r6, r17
    1840:	11 e0       	ldi	r17, 0x01	; 1
    1842:	71 2e       	mov	r7, r17
	 sprintf_P(strSend,PSTR("02%.2d"),xPump);
     SendStrSPI(strSend);

     for (i=0;i<6;i++){
	      //FixingData V:[00000000] M:[00000000]
		  AddZeroLead(PumpTotalizer.TotalGrade[i].strMoney,12);
    1844:	c7 01       	movw	r24, r14
    1846:	67 01       	movw	r12, r14
    1848:	b5 e0       	ldi	r27, 0x05	; 5
    184a:	cc 0c       	add	r12, r12
    184c:	dd 1c       	adc	r13, r13
    184e:	ba 95       	dec	r27
    1850:	e1 f7       	brne	.-8      	; 0x184a <SendTotalizerFlow+0xc0>
    1852:	88 0f       	add	r24, r24
    1854:	99 1f       	adc	r25, r25
    1856:	c8 1a       	sub	r12, r24
    1858:	d9 0a       	sbc	r13, r25
    185a:	86 e0       	ldi	r24, 0x06	; 6
    185c:	93 e0       	ldi	r25, 0x03	; 3
    185e:	c8 0e       	add	r12, r24
    1860:	d9 1e       	adc	r13, r25
    1862:	c6 01       	movw	r24, r12
    1864:	6c e0       	ldi	r22, 0x0C	; 12
    1866:	0e 94 e7 03 	call	0x7ce	; 0x7ce <AddZeroLead>
		  AddZeroLead(PumpTotalizer.TotalGrade[i].strVolume,12);
    186a:	c7 01       	movw	r24, r14
    186c:	87 01       	movw	r16, r14
    186e:	f5 e0       	ldi	r31, 0x05	; 5
    1870:	00 0f       	add	r16, r16
    1872:	11 1f       	adc	r17, r17
    1874:	fa 95       	dec	r31
    1876:	e1 f7       	brne	.-8      	; 0x1870 <SendTotalizerFlow+0xe6>
    1878:	88 0f       	add	r24, r24
    187a:	99 1f       	adc	r25, r25
    187c:	08 1b       	sub	r16, r24
    187e:	19 0b       	sbc	r17, r25
    1880:	09 50       	subi	r16, 0x09	; 9
    1882:	1d 4f       	sbci	r17, 0xFD	; 253
    1884:	c8 01       	movw	r24, r16
    1886:	6c e0       	ldi	r22, 0x0C	; 12
    1888:	0e 94 e7 03 	call	0x7ce	; 0x7ce <AddZeroLead>
    188c:	f2 01       	movw	r30, r4
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    188e:	11 92       	st	Z+, r1
void uartGilbarco(){
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    1890:	ea 15       	cp	r30, r10
    1892:	fb 05       	cpc	r31, r11
    1894:	e1 f7       	brne	.-8      	; 0x188e <SendTotalizerFlow+0x104>
     for (i=0;i<6;i++){
	      //FixingData V:[00000000] M:[00000000]
		  AddZeroLead(PumpTotalizer.TotalGrade[i].strMoney,12);
		  AddZeroLead(PumpTotalizer.TotalGrade[i].strVolume,12);
		  FillChar(strSend,sizeof(strSend),0);
		  sprintf_P(strSend,PSTR("%s%s"),PumpTotalizer.TotalGrade[i].strVolume,PumpTotalizer.TotalGrade[i].strMoney);
    1896:	ad b7       	in	r26, 0x3d	; 61
    1898:	be b7       	in	r27, 0x3e	; 62
    189a:	18 97       	sbiw	r26, 0x08	; 8
    189c:	0f b6       	in	r0, 0x3f	; 63
    189e:	f8 94       	cli
    18a0:	be bf       	out	0x3e, r27	; 62
    18a2:	0f be       	out	0x3f, r0	; 63
    18a4:	ad bf       	out	0x3d, r26	; 61
    18a6:	ed b7       	in	r30, 0x3d	; 61
    18a8:	fe b7       	in	r31, 0x3e	; 62
    18aa:	31 96       	adiw	r30, 0x01	; 1
    18ac:	11 96       	adiw	r26, 0x01	; 1
    18ae:	9c 92       	st	X, r9
    18b0:	11 97       	sbiw	r26, 0x01	; 1
    18b2:	12 96       	adiw	r26, 0x02	; 2
    18b4:	8c 92       	st	X, r8
    18b6:	73 82       	std	Z+3, r7	; 0x03
    18b8:	62 82       	std	Z+2, r6	; 0x02
    18ba:	15 83       	std	Z+5, r17	; 0x05
    18bc:	04 83       	std	Z+4, r16	; 0x04
    18be:	d7 82       	std	Z+7, r13	; 0x07
    18c0:	c6 82       	std	Z+6, r12	; 0x06
    18c2:	0e 94 b2 18 	call	0x3164	; 0x3164 <sprintf_P>
          SendStrSPI(strSend);
    18c6:	ed b7       	in	r30, 0x3d	; 61
    18c8:	fe b7       	in	r31, 0x3e	; 62
    18ca:	38 96       	adiw	r30, 0x08	; 8
    18cc:	0f b6       	in	r0, 0x3f	; 63
    18ce:	f8 94       	cli
    18d0:	fe bf       	out	0x3e, r31	; 62
    18d2:	0f be       	out	0x3f, r0	; 63
    18d4:	ed bf       	out	0x3d, r30	; 61
    18d6:	89 2d       	mov	r24, r9
    18d8:	98 2d       	mov	r25, r8
    18da:	0e 94 8e 06 	call	0xd1c	; 0xd1c <SendStrSPI>
    18de:	08 94       	sec
    18e0:	e1 1c       	adc	r14, r1
    18e2:	f1 1c       	adc	r15, r1
	 FillChar(strSend,sizeof(strSend),0);
	
	 sprintf_P(strSend,PSTR("02%.2d"),xPump);
     SendStrSPI(strSend);

     for (i=0;i<6;i++){
    18e4:	f6 e0       	ldi	r31, 0x06	; 6
    18e6:	ef 16       	cp	r14, r31
    18e8:	f1 04       	cpc	r15, r1
    18ea:	09 f0       	breq	.+2      	; 0x18ee <SendTotalizerFlow+0x164>
    18ec:	ab cf       	rjmp	.-170    	; 0x1844 <SendTotalizerFlow+0xba>
		  #ifdef DEBUG_TOTAL_FLOW 
		  _uart_print(1,1,strSend);
		  #endif
	 }
	 //TotalizerDigit
	 sprintf_P(strSend,PSTR("%d"),PumpTotalDigit);
    18ee:	00 d0       	rcall	.+0      	; 0x18f0 <SendTotalizerFlow+0x166>
    18f0:	00 d0       	rcall	.+0      	; 0x18f2 <SendTotalizerFlow+0x168>
    18f2:	00 d0       	rcall	.+0      	; 0x18f4 <SendTotalizerFlow+0x16a>
    18f4:	ed b7       	in	r30, 0x3d	; 61
    18f6:	fe b7       	in	r31, 0x3e	; 62
    18f8:	31 96       	adiw	r30, 0x01	; 1
    18fa:	ad b7       	in	r26, 0x3d	; 61
    18fc:	be b7       	in	r27, 0x3e	; 62
    18fe:	11 96       	adiw	r26, 0x01	; 1
    1900:	9c 92       	st	X, r9
    1902:	11 97       	sbiw	r26, 0x01	; 1
    1904:	12 96       	adiw	r26, 0x02	; 2
    1906:	8c 92       	st	X, r8
    1908:	88 e3       	ldi	r24, 0x38	; 56
    190a:	91 e0       	ldi	r25, 0x01	; 1
    190c:	93 83       	std	Z+3, r25	; 0x03
    190e:	82 83       	std	Z+2, r24	; 0x02
    1910:	80 91 0c 01 	lds	r24, 0x010C
    1914:	84 83       	std	Z+4, r24	; 0x04
    1916:	15 82       	std	Z+5, r1	; 0x05
    1918:	0e 94 b2 18 	call	0x3164	; 0x3164 <sprintf_P>
     SendStrSPI(strSend);
    191c:	ed b7       	in	r30, 0x3d	; 61
    191e:	fe b7       	in	r31, 0x3e	; 62
    1920:	36 96       	adiw	r30, 0x06	; 6
    1922:	0f b6       	in	r0, 0x3f	; 63
    1924:	f8 94       	cli
    1926:	fe bf       	out	0x3e, r31	; 62
    1928:	0f be       	out	0x3f, r0	; 63
    192a:	ed bf       	out	0x3d, r30	; 61
    192c:	89 2d       	mov	r24, r9
    192e:	98 2d       	mov	r25, r8
    1930:	0e 94 8e 06 	call	0xd1c	; 0xd1c <SendStrSPI>
	sbi(DDRD,2);sbi(PORTD,2);//128-SS HIGH
	//_delay_ms(10);
}

void SendSPI(char xSPI){
     _spi(xSPI);
    1934:	86 e0       	ldi	r24, 0x06	; 6
    1936:	0e 94 80 17 	call	0x2f00	; 0x2f00 <_spi>
	 sprintf_P(strSend,PSTR("%d"),PumpTotalDigit);
     SendStrSPI(strSend);

	 SendSPI(0x06);//ETX
	 SendSPI(0x60);//ETX
	 systemSlave();
    193a:	80 e6       	ldi	r24, 0x60	; 96
    193c:	0e 94 80 17 	call	0x2f00	; 0x2f00 <_spi>
    1940:	0e 94 ae 06 	call	0xd5c	; 0xd5c <systemSlave>
    1944:	8a ef       	ldi	r24, 0xFA	; 250
    1946:	90 e0       	ldi	r25, 0x00	; 0
    1948:	01 97       	sbiw	r24, 0x01	; 1
    194a:	f1 f7       	brne	.-4      	; 0x1948 <SendTotalizerFlow+0x1be>
	 _delay_ms(1);//DelayProses
}
    194c:	a8 96       	adiw	r28, 0x28	; 40
    194e:	0f b6       	in	r0, 0x3f	; 63
    1950:	f8 94       	cli
    1952:	de bf       	out	0x3e, r29	; 62
    1954:	0f be       	out	0x3f, r0	; 63
    1956:	cd bf       	out	0x3d, r28	; 61
    1958:	cf 91       	pop	r28
    195a:	df 91       	pop	r29
    195c:	1f 91       	pop	r17
    195e:	0f 91       	pop	r16
    1960:	ff 90       	pop	r15
    1962:	ef 90       	pop	r14
    1964:	df 90       	pop	r13
    1966:	cf 90       	pop	r12
    1968:	bf 90       	pop	r11
    196a:	af 90       	pop	r10
    196c:	9f 90       	pop	r9
    196e:	8f 90       	pop	r8
    1970:	7f 90       	pop	r7
    1972:	6f 90       	pop	r6
    1974:	5f 90       	pop	r5
    1976:	4f 90       	pop	r4
    1978:	08 95       	ret

0000197a <SendTransFlow>:
	 SendSPI(0x08);//ETX

	 systemSlave();
}

void SendTransFlow(char xPumpID, char rxPumpId,char xNozzleID,char xProductID, char *sUnitPrice, char *sVolume,char * sAmount,char TransDigit){
    197a:	6f 92       	push	r6
    197c:	7f 92       	push	r7
    197e:	8f 92       	push	r8
    1980:	9f 92       	push	r9
    1982:	af 92       	push	r10
    1984:	bf 92       	push	r11
    1986:	cf 92       	push	r12
    1988:	df 92       	push	r13
    198a:	ef 92       	push	r14
    198c:	ff 92       	push	r15
    198e:	0f 93       	push	r16
    1990:	1f 93       	push	r17
    1992:	df 93       	push	r29
    1994:	cf 93       	push	r28
    1996:	cd b7       	in	r28, 0x3d	; 61
    1998:	de b7       	in	r29, 0x3e	; 62
    199a:	6e 97       	sbiw	r28, 0x1e	; 30
    199c:	0f b6       	in	r0, 0x3f	; 63
    199e:	f8 94       	cli
    19a0:	de bf       	out	0x3e, r29	; 62
    19a2:	0f be       	out	0x3f, r0	; 63
    19a4:	cd bf       	out	0x3d, r28	; 61
    19a6:	68 2e       	mov	r6, r24
    19a8:	b4 2e       	mov	r11, r20
    19aa:	72 2e       	mov	r7, r18
    19ac:	48 01       	movw	r8, r16
     char i,xNozzle,xPrd,xPump,strSend[30];

	                         //  [0x50,0x05]  01       01       1        3       004500   00000200  00000000 [0x06,0x60] = 24
	 //Sending FlowSPI_Protocol     <STX>   [MsgID][PumpID][Nozzle][ProductID][UnitPrice][Volume][Amount] <ETX>
	 AddZeroLead(sUnitPrice,6);//         Wyne    01 02 2 0 004600 00000254 00011684
    19ae:	c8 01       	movw	r24, r16
    19b0:	66 e0       	ldi	r22, 0x06	; 6
    19b2:	0e 94 e7 03 	call	0x7ce	; 0x7ce <AddZeroLead>
     AddZeroLead(sVolume,8);
    19b6:	c7 01       	movw	r24, r14
    19b8:	68 e0       	ldi	r22, 0x08	; 8
    19ba:	0e 94 e7 03 	call	0x7ce	; 0x7ce <AddZeroLead>
     AddZeroLead(sAmount,8);
    19be:	c6 01       	movw	r24, r12
    19c0:	68 e0       	ldi	r22, 0x08	; 8
    19c2:	0e 94 e7 03 	call	0x7ce	; 0x7ce <AddZeroLead>
	 
	 if (xNozzleID>=4)xNozzle=4;
    19c6:	83 e0       	ldi	r24, 0x03	; 3
    19c8:	8b 15       	cp	r24, r11
    19ca:	10 f0       	brcs	.+4      	; 0x19d0 <SendTransFlow+0x56>
    19cc:	4b 2d       	mov	r20, r11
    19ce:	01 c0       	rjmp	.+2      	; 0x19d2 <SendTransFlow+0x58>
    19d0:	44 e0       	ldi	r20, 0x04	; 4
	 else xNozzle=xNozzleID;
	 
	 if (xProductID>=4)xPrd=4;
    19d2:	93 e0       	ldi	r25, 0x03	; 3
    19d4:	97 15       	cp	r25, r7
    19d6:	10 f0       	brcs	.+4      	; 0x19dc <SendTransFlow+0x62>
    19d8:	27 2d       	mov	r18, r7
    19da:	01 c0       	rjmp	.+2      	; 0x19de <SendTransFlow+0x64>
    19dc:	24 e0       	ldi	r18, 0x04	; 4
	 else xPrd=xProductID;

	 if (xPumpID>=16)xPump=16;
    19de:	af e0       	ldi	r26, 0x0F	; 15
    19e0:	a6 15       	cp	r26, r6
    19e2:	10 f0       	brcs	.+4      	; 0x19e8 <SendTransFlow+0x6e>
    19e4:	36 2d       	mov	r19, r6
    19e6:	01 c0       	rjmp	.+2      	; 0x19ea <SendTransFlow+0x70>
    19e8:	30 e1       	ldi	r19, 0x10	; 16
	 else xPump=xPumpID;

	 sprintf_P(strSend,PSTR("01%.2d%.1d%.1d%s%s%s"),xPump,xNozzle,xPrd,sUnitPrice,sVolume,sAmount);
    19ea:	8d b7       	in	r24, 0x3d	; 61
    19ec:	9e b7       	in	r25, 0x3e	; 62
    19ee:	40 97       	sbiw	r24, 0x10	; 16
    19f0:	0f b6       	in	r0, 0x3f	; 63
    19f2:	f8 94       	cli
    19f4:	9e bf       	out	0x3e, r25	; 62
    19f6:	0f be       	out	0x3f, r0	; 63
    19f8:	8d bf       	out	0x3d, r24	; 61
    19fa:	ed b7       	in	r30, 0x3d	; 61
    19fc:	fe b7       	in	r31, 0x3e	; 62
    19fe:	31 96       	adiw	r30, 0x01	; 1
    1a00:	8e 01       	movw	r16, r28
    1a02:	0f 5f       	subi	r16, 0xFF	; 255
    1a04:	1f 4f       	sbci	r17, 0xFF	; 255
    1a06:	ad b7       	in	r26, 0x3d	; 61
    1a08:	be b7       	in	r27, 0x3e	; 62
    1a0a:	12 96       	adiw	r26, 0x02	; 2
    1a0c:	1c 93       	st	X, r17
    1a0e:	0e 93       	st	-X, r16
    1a10:	11 97       	sbiw	r26, 0x01	; 1
    1a12:	8a e4       	ldi	r24, 0x4A	; 74
    1a14:	91 e0       	ldi	r25, 0x01	; 1
    1a16:	93 83       	std	Z+3, r25	; 0x03
    1a18:	82 83       	std	Z+2, r24	; 0x02
    1a1a:	34 83       	std	Z+4, r19	; 0x04
    1a1c:	15 82       	std	Z+5, r1	; 0x05
    1a1e:	46 83       	std	Z+6, r20	; 0x06
    1a20:	17 82       	std	Z+7, r1	; 0x07
    1a22:	20 87       	std	Z+8, r18	; 0x08
    1a24:	11 86       	std	Z+9, r1	; 0x09
    1a26:	93 86       	std	Z+11, r9	; 0x0b
    1a28:	82 86       	std	Z+10, r8	; 0x0a
    1a2a:	f5 86       	std	Z+13, r15	; 0x0d
    1a2c:	e4 86       	std	Z+12, r14	; 0x0c
    1a2e:	d7 86       	std	Z+15, r13	; 0x0f
    1a30:	c6 86       	std	Z+14, r12	; 0x0e
    1a32:	0e 94 b2 18 	call	0x3164	; 0x3164 <sprintf_P>
	 systemMaster();
    1a36:	8d b7       	in	r24, 0x3d	; 61
    1a38:	9e b7       	in	r25, 0x3e	; 62
    1a3a:	40 96       	adiw	r24, 0x10	; 16
    1a3c:	0f b6       	in	r0, 0x3f	; 63
    1a3e:	f8 94       	cli
    1a40:	9e bf       	out	0x3e, r25	; 62
    1a42:	0f be       	out	0x3f, r0	; 63
    1a44:	8d bf       	out	0x3d, r24	; 61
    1a46:	0e 94 bb 06 	call	0xd76	; 0xd76 <systemMaster>
	sbi(DDRD,2);sbi(PORTD,2);//128-SS HIGH
	//_delay_ms(10);
}

void SendSPI(char xSPI){
     _spi(xSPI);
    1a4a:	85 e0       	ldi	r24, 0x05	; 5
    1a4c:	0e 94 80 17 	call	0x2f00	; 0x2f00 <_spi>

	 sprintf_P(strSend,PSTR("01%.2d%.1d%.1d%s%s%s"),xPump,xNozzle,xPrd,sUnitPrice,sVolume,sAmount);
	 systemMaster();
	 SendSPI(0x05);//STX
	 SendSPI(0x50);//STX
	 for(i=0;i<strlen(strSend);i++){
    1a50:	80 e5       	ldi	r24, 0x50	; 80
    1a52:	0e 94 80 17 	call	0x2f00	; 0x2f00 <_spi>
    1a56:	ff 24       	eor	r15, r15
    1a58:	06 c0       	rjmp	.+12     	; 0x1a66 <SendTransFlow+0xec>
    1a5a:	a0 0f       	add	r26, r16
    1a5c:	b1 1f       	adc	r27, r17
    1a5e:	8c 91       	ld	r24, X
    1a60:	0e 94 80 17 	call	0x2f00	; 0x2f00 <_spi>
    1a64:	f3 94       	inc	r15
    1a66:	f8 01       	movw	r30, r16
    1a68:	01 90       	ld	r0, Z+
    1a6a:	00 20       	and	r0, r0
    1a6c:	e9 f7       	brne	.-6      	; 0x1a68 <SendTransFlow+0xee>
    1a6e:	31 97       	sbiw	r30, 0x01	; 1
    1a70:	e0 1b       	sub	r30, r16
    1a72:	f1 0b       	sbc	r31, r17
    1a74:	af 2d       	mov	r26, r15
    1a76:	b0 e0       	ldi	r27, 0x00	; 0
    1a78:	ae 17       	cp	r26, r30
    1a7a:	bf 07       	cpc	r27, r31
    1a7c:	70 f3       	brcs	.-36     	; 0x1a5a <SendTransFlow+0xe0>
		 #ifdef DEBUG_TRANS_FLOW 
		 _uart(1,1,strSend[i]);
		 #endif
	 }
	 //TransDigit
	 sprintf_P(strSend,PSTR("%d"),TransDigit);
    1a7e:	00 d0       	rcall	.+0      	; 0x1a80 <SendTransFlow+0x106>
    1a80:	00 d0       	rcall	.+0      	; 0x1a82 <SendTransFlow+0x108>
    1a82:	00 d0       	rcall	.+0      	; 0x1a84 <SendTransFlow+0x10a>
    1a84:	ed b7       	in	r30, 0x3d	; 61
    1a86:	fe b7       	in	r31, 0x3e	; 62
    1a88:	31 96       	adiw	r30, 0x01	; 1
    1a8a:	ad b7       	in	r26, 0x3d	; 61
    1a8c:	be b7       	in	r27, 0x3e	; 62
    1a8e:	12 96       	adiw	r26, 0x02	; 2
    1a90:	1c 93       	st	X, r17
    1a92:	0e 93       	st	-X, r16
    1a94:	11 97       	sbiw	r26, 0x01	; 1
    1a96:	87 e4       	ldi	r24, 0x47	; 71
    1a98:	91 e0       	ldi	r25, 0x01	; 1
    1a9a:	93 83       	std	Z+3, r25	; 0x03
    1a9c:	82 83       	std	Z+2, r24	; 0x02
    1a9e:	a4 82       	std	Z+4, r10	; 0x04
    1aa0:	15 82       	std	Z+5, r1	; 0x05
    1aa2:	0e 94 b2 18 	call	0x3164	; 0x3164 <sprintf_P>
     SendStrSPI(strSend);
    1aa6:	8d b7       	in	r24, 0x3d	; 61
    1aa8:	9e b7       	in	r25, 0x3e	; 62
    1aaa:	06 96       	adiw	r24, 0x06	; 6
    1aac:	0f b6       	in	r0, 0x3f	; 63
    1aae:	f8 94       	cli
    1ab0:	9e bf       	out	0x3e, r25	; 62
    1ab2:	0f be       	out	0x3f, r0	; 63
    1ab4:	8d bf       	out	0x3d, r24	; 61
    1ab6:	c8 01       	movw	r24, r16
    1ab8:	0e 94 8e 06 	call	0xd1c	; 0xd1c <SendStrSPI>
	sbi(DDRD,2);sbi(PORTD,2);//128-SS HIGH
	//_delay_ms(10);
}

void SendSPI(char xSPI){
     _spi(xSPI);
    1abc:	86 e0       	ldi	r24, 0x06	; 6
    1abe:	0e 94 80 17 	call	0x2f00	; 0x2f00 <_spi>
	 sprintf_P(strSend,PSTR("%d"),TransDigit);
     SendStrSPI(strSend);

	 SendSPI(0x06);//ETX
	 SendSPI(0x60);//ETX
	 systemSlave();
    1ac2:	80 e6       	ldi	r24, 0x60	; 96
    1ac4:	0e 94 80 17 	call	0x2f00	; 0x2f00 <_spi>
    1ac8:	0e 94 ae 06 	call	0xd5c	; 0xd5c <systemSlave>
}
    1acc:	6e 96       	adiw	r28, 0x1e	; 30
    1ace:	0f b6       	in	r0, 0x3f	; 63
    1ad0:	f8 94       	cli
    1ad2:	de bf       	out	0x3e, r29	; 62
    1ad4:	0f be       	out	0x3f, r0	; 63
    1ad6:	cd bf       	out	0x3d, r28	; 61
    1ad8:	cf 91       	pop	r28
    1ada:	df 91       	pop	r29
    1adc:	1f 91       	pop	r17
    1ade:	0f 91       	pop	r16
    1ae0:	ff 90       	pop	r15
    1ae2:	ef 90       	pop	r14
    1ae4:	df 90       	pop	r13
    1ae6:	cf 90       	pop	r12
    1ae8:	bf 90       	pop	r11
    1aea:	af 90       	pop	r10
    1aec:	9f 90       	pop	r9
    1aee:	8f 90       	pop	r8
    1af0:	7f 90       	pop	r7
    1af2:	6f 90       	pop	r6
    1af4:	08 95       	ret

00001af6 <FPoolingPump>:
		  //stPoolingPump=pwInitPumpAddr;
	      break;
	 }
}

void FPoolingPump(){//DefPoolTimeout,DefDelayNextPump
    1af6:	af 92       	push	r10
    1af8:	cf 92       	push	r12
    1afa:	df 92       	push	r13
    1afc:	ef 92       	push	r14
    1afe:	ff 92       	push	r15
    1b00:	0f 93       	push	r16
    1b02:	1f 93       	push	r17
//static char txPumpID=0,StatusPump,iSend,nSend,PumpAddr=1,nNoPump,ScanPumpMax,IsNoPump=True,TPoolTimeout,TDelayNextPump;
       char CurrentAmount[15];
	   char strSend[20];

     //Monitoring
	 if (zPooling!=stPoolingPump){
    1b04:	60 91 2c 01 	lds	r22, 0x012C
    1b08:	80 91 2d 01 	lds	r24, 0x012D
    1b0c:	86 17       	cp	r24, r22
    1b0e:	11 f0       	breq	.+4      	; 0x1b14 <FPoolingPump+0x1e>
	     zPooling=stPoolingPump;
    1b10:	60 93 2d 01 	sts	0x012D, r22
         sprintf_P(strSend,PSTR("GPool:%d"),stPoolingPump);
	 	 _uart_print(1,1,strSend);
		 #endif
	 }
     
	 if (IsRestartPooling==True){
    1b14:	80 91 03 01 	lds	r24, 0x0103
    1b18:	81 30       	cpi	r24, 0x01	; 1
    1b1a:	69 f4       	brne	.+26     	; 0x1b36 <FPoolingPump+0x40>
	     IsRestartPooling=False;
    1b1c:	10 92 03 01 	sts	0x0103, r1
		 SendCommandAcknoledge(SC_POOL_RESTARTED,stPoolingPump);
    1b20:	8a e1       	ldi	r24, 0x1A	; 26
    1b22:	0e 94 e0 06 	call	0xdc0	; 0xdc0 <SendCommandAcknoledge>
		 _uart_printf(1,1,PSTR("PoolRestarted"));
    1b26:	81 e0       	ldi	r24, 0x01	; 1
    1b28:	61 e0       	ldi	r22, 0x01	; 1
    1b2a:	4a e6       	ldi	r20, 0x6A	; 106
    1b2c:	51 e0       	ldi	r21, 0x01	; 1
    1b2e:	0e 94 89 18 	call	0x3112	; 0x3112 <_uart_printf>
	     stPoolingPump=ppInit;
    1b32:	10 92 2c 01 	sts	0x012C, r1
	 }
	 switch(stPoolingPump){
    1b36:	80 91 2c 01 	lds	r24, 0x012C
    1b3a:	e8 2f       	mov	r30, r24
    1b3c:	f0 e0       	ldi	r31, 0x00	; 0
    1b3e:	e1 32       	cpi	r30, 0x21	; 33
    1b40:	f1 05       	cpc	r31, r1
    1b42:	08 f0       	brcs	.+2      	; 0x1b46 <FPoolingPump+0x50>
    1b44:	d4 c2       	rjmp	.+1448   	; 0x20ee <FPoolingPump+0x5f8>
    1b46:	e8 5c       	subi	r30, 0xC8	; 200
    1b48:	ff 4f       	sbci	r31, 0xFF	; 255
    1b4a:	ee 0f       	add	r30, r30
    1b4c:	ff 1f       	adc	r31, r31
    1b4e:	05 90       	lpm	r0, Z+
    1b50:	f4 91       	lpm	r31, Z+
    1b52:	e0 2d       	mov	r30, r0
    1b54:	09 94       	ijmp
	 case ppInit:
	      //StatePrintf(PSTR("1"));
	      //txPumpID=1;
		  iPoolingID=0;
    1b56:	10 92 16 01 	sts	0x0116, r1
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    1b5a:	e1 99       	sbic	0x1c, 1	; 28
    1b5c:	fe cf       	rjmp	.-4      	; 0x1b5a <FPoolingPump+0x64>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    1b5e:	8d e0       	ldi	r24, 0x0D	; 13
    1b60:	90 e0       	ldi	r25, 0x00	; 0
    1b62:	9f bb       	out	0x1f, r25	; 31
    1b64:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    1b66:	e0 9a       	sbi	0x1c, 0	; 28
    1b68:	8d b3       	in	r24, 0x1d	; 29
		  txPumpID=eeprom_read_byte(&DefPumpID[iPoolingID]);
    1b6a:	80 93 17 01 	sts	0x0117, r24

		  iSend=0;
    1b6e:	10 92 f9 03 	sts	0x03F9, r1
		  TimSend=0;          
    1b72:	10 92 24 04 	sts	0x0424, r1
    1b76:	10 92 23 04 	sts	0x0423, r1
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    1b7a:	e1 99       	sbic	0x1c, 1	; 28
    1b7c:	fe cf       	rjmp	.-4      	; 0x1b7a <FPoolingPump+0x84>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    1b7e:	88 e0       	ldi	r24, 0x08	; 8
    1b80:	90 e0       	ldi	r25, 0x00	; 0
    1b82:	9f bb       	out	0x1f, r25	; 31
    1b84:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    1b86:	e0 9a       	sbi	0x1c, 0	; 28
    1b88:	8d b3       	in	r24, 0x1d	; 29
		  nNoPump=eeprom_read_byte(&DefNoPumpCountMax);
    1b8a:	80 93 35 04 	sts	0x0435, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    1b8e:	e1 99       	sbic	0x1c, 1	; 28
    1b90:	fe cf       	rjmp	.-4      	; 0x1b8e <FPoolingPump+0x98>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    1b92:	87 e0       	ldi	r24, 0x07	; 7
    1b94:	90 e0       	ldi	r25, 0x00	; 0
    1b96:	9f bb       	out	0x1f, r25	; 31
    1b98:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    1b9a:	e0 9a       	sbi	0x1c, 0	; 28
    1b9c:	8d b3       	in	r24, 0x1d	; 29
		  ScanPumpMax=eeprom_read_byte(&DefMaxPumpPooling);
    1b9e:	80 93 61 02 	sts	0x0261, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    1ba2:	e1 99       	sbic	0x1c, 1	; 28
    1ba4:	fe cf       	rjmp	.-4      	; 0x1ba2 <FPoolingPump+0xac>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    1ba6:	89 e0       	ldi	r24, 0x09	; 9
    1ba8:	90 e0       	ldi	r25, 0x00	; 0
    1baa:	9f bb       	out	0x1f, r25	; 31
    1bac:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    1bae:	e0 9a       	sbi	0x1c, 0	; 28
    1bb0:	8d b3       	in	r24, 0x1d	; 29
		  nSend=eeprom_read_byte(&DefSendCount);
    1bb2:	80 93 77 02 	sts	0x0277, r24
		  if (IsStopPoolSequence!=True)
    1bb6:	80 91 13 01 	lds	r24, 0x0113
    1bba:	81 30       	cpi	r24, 0x01	; 1
    1bbc:	29 f0       	breq	.+10     	; 0x1bc8 <FPoolingPump+0xd2>
              SendCommandAcknoledge(SC_LIVE_SEQUENCE,SequencePool);
    1bbe:	89 e1       	ldi	r24, 0x19	; 25
    1bc0:	60 91 26 01 	lds	r22, 0x0126
    1bc4:	0e 94 e0 06 	call	0xdc0	; 0xdc0 <SendCommandAcknoledge>
          SequencePool++;
    1bc8:	80 91 26 01 	lds	r24, 0x0126
    1bcc:	8f 5f       	subi	r24, 0xFF	; 255
    1bce:	80 93 26 01 	sts	0x0126, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    1bd2:	e1 99       	sbic	0x1c, 1	; 28
    1bd4:	fe cf       	rjmp	.-4      	; 0x1bd2 <FPoolingPump+0xdc>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    1bd6:	8a e0       	ldi	r24, 0x0A	; 10
    1bd8:	90 e0       	ldi	r25, 0x00	; 0
    1bda:	9f bb       	out	0x1f, r25	; 31
    1bdc:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    1bde:	e0 9a       	sbi	0x1c, 0	; 28
    1be0:	8d b3       	in	r24, 0x1d	; 29
		  TPoolTimeout=eeprom_read_byte(&DefPoolTimeout);
    1be2:	80 93 b6 02 	sts	0x02B6, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    1be6:	e1 99       	sbic	0x1c, 1	; 28
    1be8:	fe cf       	rjmp	.-4      	; 0x1be6 <FPoolingPump+0xf0>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    1bea:	8b e0       	ldi	r24, 0x0B	; 11
    1bec:	90 e0       	ldi	r25, 0x00	; 0
    1bee:	9f bb       	out	0x1f, r25	; 31
    1bf0:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    1bf2:	e0 9a       	sbi	0x1c, 0	; 28
    1bf4:	8d b3       	in	r24, 0x1d	; 29
		  TDelayNextPump=eeprom_read_byte(&DefDelayNextPump);		  
    1bf6:	80 93 3c 01 	sts	0x013C, r24
    1bfa:	1e c0       	rjmp	.+60     	; 0x1c38 <FPoolingPump+0x142>
		  stPoolingPump=ppGetStatus;
	      break;
     case ppNextPump:
          iPoolingID++;
    1bfc:	90 91 16 01 	lds	r25, 0x0116
    1c00:	9f 5f       	subi	r25, 0xFF	; 255
    1c02:	90 93 16 01 	sts	0x0116, r25
	      if (iPoolingID<ScanPumpMax){
    1c06:	80 91 61 02 	lds	r24, 0x0261
    1c0a:	98 17       	cp	r25, r24
    1c0c:	b8 f4       	brcc	.+46     	; 0x1c3c <FPoolingPump+0x146>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    1c0e:	e1 99       	sbic	0x1c, 1	; 28
    1c10:	fe cf       	rjmp	.-4      	; 0x1c0e <FPoolingPump+0x118>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    1c12:	89 2f       	mov	r24, r25
    1c14:	90 e0       	ldi	r25, 0x00	; 0
    1c16:	83 5f       	subi	r24, 0xF3	; 243
    1c18:	9f 4f       	sbci	r25, 0xFF	; 255
    1c1a:	9f bb       	out	0x1f, r25	; 31
    1c1c:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    1c1e:	e0 9a       	sbi	0x1c, 0	; 28
    1c20:	8d b3       	in	r24, 0x1d	; 29
			  txPumpID=eeprom_read_byte(&DefPumpID[iPoolingID]);
    1c22:	80 93 17 01 	sts	0x0117, r24
			  if (txPumpID>0){			      
    1c26:	88 23       	and	r24, r24
    1c28:	09 f4       	brne	.+2      	; 0x1c2c <FPoolingPump+0x136>
    1c2a:	09 c2       	rjmp	.+1042   	; 0x203e <FPoolingPump+0x548>
			      iSend=0;TimSend=0;
    1c2c:	10 92 f9 03 	sts	0x03F9, r1
    1c30:	10 92 24 04 	sts	0x0424, r1
    1c34:	10 92 23 04 	sts	0x0423, r1
			      stPoolingPump=ppGetStatus;
    1c38:	82 e0       	ldi	r24, 0x02	; 2
    1c3a:	57 c2       	rjmp	.+1198   	; 0x20ea <FPoolingPump+0x5f4>
			   }else stPoolingPump=ppNextPump;
		  }else stPoolingPump=ppInit;
    1c3c:	10 92 2c 01 	sts	0x012C, r1
    1c40:	56 c2       	rjmp	.+1196   	; 0x20ee <FPoolingPump+0x5f8>
           sprintf_P(strSend,PSTR("TxPumpID:%d"),txPumpID);
	 	   _uart_print(1,1,strSend);
		  #endif

          //StatePrintf(PSTR("3"));
	      IsStatusReceived=False;
    1c42:	10 92 0f 01 	sts	0x010F, r1
		  IsNoPump=False;
    1c46:	10 92 06 01 	sts	0x0106, r1
	 }
	 zDataBuffer[0]=data;
}

void SetReceiveLine(char RecLine){
     stReceiveCom0=RecLine;
    1c4a:	81 e0       	ldi	r24, 0x01	; 1
    1c4c:	80 93 04 01 	sts	0x0104, r24
		  IsNoPump=False;
		  SetReceiveLine(rcIdle);
		  stPoolingPump=ppWaitIdle;
     case ppWaitIdle:
          //StatePrintf(PSTR("4"));
	      if (GetReceiveLine()==rcIdle)
    1c50:	80 91 04 01 	lds	r24, 0x0104
    1c54:	81 30       	cpi	r24, 0x01	; 1
    1c56:	81 f7       	brne	.-32     	; 0x1c38 <FPoolingPump+0x142>
		      stPoolingPump=ppSendStatusRequest;
    1c58:	84 e0       	ldi	r24, 0x04	; 4
    1c5a:	47 c2       	rjmp	.+1166   	; 0x20ea <FPoolingPump+0x5f4>
          else stPoolingPump=ppGetStatus;
	      break;
     case ppSendStatusRequest:
          //StatePrintf(PSTR("5"));
	      PumpCommand(txPumpID,CMD_STATUS);
    1c5c:	80 91 17 01 	lds	r24, 0x0117
    1c60:	60 e0       	ldi	r22, 0x00	; 0
    1c62:	0e 94 27 07 	call	0xe4e	; 0xe4e <PumpCommand>
		  TimSend=0;
    1c66:	10 92 24 04 	sts	0x0424, r1
    1c6a:	10 92 23 04 	sts	0x0423, r1
          stPoolingPump=ppWaitReplyStatus;
    1c6e:	86 e0       	ldi	r24, 0x06	; 6
    1c70:	3c c2       	rjmp	.+1144   	; 0x20ea <FPoolingPump+0x5f4>
	      break;
     case ppNoPump:
          NoPumpCount[txPumpID&0x0F]++;
    1c72:	80 91 17 01 	lds	r24, 0x0117
    1c76:	e8 2f       	mov	r30, r24
    1c78:	f0 e0       	ldi	r31, 0x00	; 0
    1c7a:	ef 70       	andi	r30, 0x0F	; 15
    1c7c:	f0 70       	andi	r31, 0x00	; 0
    1c7e:	eb 5d       	subi	r30, 0xDB	; 219
    1c80:	fb 4f       	sbci	r31, 0xFB	; 251
    1c82:	80 81       	ld	r24, Z
    1c84:	8f 5f       	subi	r24, 0xFF	; 255
    1c86:	80 83       	st	Z, r24
		  if (NoPumpCount[txPumpID&0x0F]>nNoPump){
    1c88:	90 91 35 04 	lds	r25, 0x0435
    1c8c:	98 17       	cp	r25, r24
    1c8e:	08 f0       	brcs	.+2      	; 0x1c92 <FPoolingPump+0x19c>
    1c90:	c5 c0       	rjmp	.+394    	; 0x1e1c <FPoolingPump+0x326>
		      NoPumpCount[txPumpID&0x0F]=0;
    1c92:	10 82       	st	Z, r1
	          IsNoPump=True;
    1c94:	81 e0       	ldi	r24, 0x01	; 1
    1c96:	80 93 06 01 	sts	0x0106, r24
    1c9a:	07 c1       	rjmp	.+526    	; 0x1eaa <FPoolingPump+0x3b4>
			  }
          else stPoolingPump=ppInitDelayNextPump;
	      break;
     case ppWaitReplyStatus:	      
          //StatePrintf(PSTR("7"));
          if (TimSend>TPoolTimeout){//TPoolTimeout
    1c9c:	80 91 b6 02 	lds	r24, 0x02B6
    1ca0:	90 e0       	ldi	r25, 0x00	; 0
    1ca2:	20 91 23 04 	lds	r18, 0x0423
    1ca6:	30 91 24 04 	lds	r19, 0x0424
    1caa:	82 17       	cp	r24, r18
    1cac:	93 07       	cpc	r25, r19
    1cae:	80 f4       	brcc	.+32     	; 0x1cd0 <FPoolingPump+0x1da>
		      iSend++;
    1cb0:	80 91 f9 03 	lds	r24, 0x03F9
    1cb4:	8f 5f       	subi	r24, 0xFF	; 255
    1cb6:	80 93 f9 03 	sts	0x03F9, r24
		      if (iSend<nSend)stPoolingPump=ppGetStatus;
    1cba:	90 91 77 02 	lds	r25, 0x0277
    1cbe:	89 17       	cp	r24, r25
    1cc0:	10 f4       	brcc	.+4      	; 0x1cc6 <FPoolingPump+0x1d0>
    1cc2:	82 e0       	ldi	r24, 0x02	; 2
    1cc4:	03 c0       	rjmp	.+6      	; 0x1ccc <FPoolingPump+0x1d6>
			  else
		      if (iSend>nSend)stPoolingPump=ppNoPump;//Pump Not Available
    1cc6:	98 17       	cp	r25, r24
    1cc8:	18 f4       	brcc	.+6      	; 0x1cd0 <FPoolingPump+0x1da>
    1cca:	85 e0       	ldi	r24, 0x05	; 5
    1ccc:	80 93 2c 01 	sts	0x012C, r24
		  }
          if (IsStatusReceived==True){
    1cd0:	80 91 0f 01 	lds	r24, 0x010F
    1cd4:	81 30       	cpi	r24, 0x01	; 1
    1cd6:	09 f0       	breq	.+2      	; 0x1cda <FPoolingPump+0x1e4>
    1cd8:	0a c2       	rjmp	.+1044   	; 0x20ee <FPoolingPump+0x5f8>
		      if ((txPumpID&0x0F)==PumpID){
    1cda:	40 91 0e 01 	lds	r20, 0x010E
    1cde:	80 91 17 01 	lds	r24, 0x0117
    1ce2:	90 e0       	ldi	r25, 0x00	; 0
    1ce4:	8f 70       	andi	r24, 0x0F	; 15
    1ce6:	90 70       	andi	r25, 0x00	; 0
    1ce8:	24 2f       	mov	r18, r20
    1cea:	30 e0       	ldi	r19, 0x00	; 0
    1cec:	82 17       	cp	r24, r18
    1cee:	93 07       	cpc	r25, r19
    1cf0:	11 f4       	brne	.+4      	; 0x1cf6 <FPoolingPump+0x200>
			      stPoolingPump=ppUpdatePumpStatus;
    1cf2:	87 e0       	ldi	r24, 0x07	; 7
    1cf4:	01 c0       	rjmp	.+2      	; 0x1cf8 <FPoolingPump+0x202>
			  }else stPoolingPump=ppDifferentPumpID;
    1cf6:	89 e0       	ldi	r24, 0x09	; 9
    1cf8:	80 93 2c 01 	sts	0x012C, r24

			  if ((CMDResponse==0x0F)&&(PumpID==0x0F)&&(iSend<nSend)){
    1cfc:	80 91 8d 01 	lds	r24, 0x018D
    1d00:	8f 30       	cpi	r24, 0x0F	; 15
    1d02:	09 f0       	breq	.+2      	; 0x1d06 <FPoolingPump+0x210>
    1d04:	f4 c1       	rjmp	.+1000   	; 0x20ee <FPoolingPump+0x5f8>
    1d06:	4f 30       	cpi	r20, 0x0F	; 15
    1d08:	09 f0       	breq	.+2      	; 0x1d0c <FPoolingPump+0x216>
    1d0a:	f1 c1       	rjmp	.+994    	; 0x20ee <FPoolingPump+0x5f8>
    1d0c:	90 91 f9 03 	lds	r25, 0x03F9
    1d10:	80 91 77 02 	lds	r24, 0x0277
    1d14:	98 17       	cp	r25, r24
    1d16:	08 f0       	brcs	.+2      	; 0x1d1a <FPoolingPump+0x224>
    1d18:	ea c1       	rjmp	.+980    	; 0x20ee <FPoolingPump+0x5f8>
    1d1a:	8e cf       	rjmp	.-228    	; 0x1c38 <FPoolingPump+0x142>
          stPoolingPump=ppNoPump;
	      break;
		                     //PumpStatus[1..0]= FEDCBA98 76543210
     case ppUpdatePumpStatus://                = 
          //StatePrintf(PSTR("9"));
	      PumpAddr=(txPumpID&0x0F);
    1d1c:	90 91 17 01 	lds	r25, 0x0117
    1d20:	9f 70       	andi	r25, 0x0F	; 15
    1d22:	90 93 05 01 	sts	0x0105, r25
		  if (IsNoPump==False)PumpStatus[PumpAddr]=CMDResponse;
    1d26:	80 91 06 01 	lds	r24, 0x0106
    1d2a:	88 23       	and	r24, r24
    1d2c:	39 f4       	brne	.+14     	; 0x1d3c <FPoolingPump+0x246>
    1d2e:	e9 2f       	mov	r30, r25
    1d30:	f0 e0       	ldi	r31, 0x00	; 0
    1d32:	eb 54       	subi	r30, 0x4B	; 75
    1d34:	fc 4f       	sbci	r31, 0xFC	; 252
    1d36:	80 91 8d 01 	lds	r24, 0x018D
    1d3a:	07 c0       	rjmp	.+14     	; 0x1d4a <FPoolingPump+0x254>
		  else 
		  if (IsNoPump==True)PumpStatus[PumpAddr]=PUMP_NONE;
    1d3c:	81 30       	cpi	r24, 0x01	; 1
    1d3e:	31 f4       	brne	.+12     	; 0x1d4c <FPoolingPump+0x256>
    1d40:	e9 2f       	mov	r30, r25
    1d42:	f0 e0       	ldi	r31, 0x00	; 0
    1d44:	eb 54       	subi	r30, 0x4B	; 75
    1d46:	fc 4f       	sbci	r31, 0xFC	; 252
    1d48:	8e e0       	ldi	r24, 0x0E	; 14
    1d4a:	80 83       	st	Z, r24
          
		  //SendIfUpdated
		  if (PumpStatus[PumpAddr]!=zPumpStatus[PumpAddr]){
    1d4c:	89 2f       	mov	r24, r25
    1d4e:	90 e0       	ldi	r25, 0x00	; 0
    1d50:	fc 01       	movw	r30, r24
    1d52:	eb 54       	subi	r30, 0x4B	; 75
    1d54:	fc 4f       	sbci	r31, 0xFC	; 252
    1d56:	20 81       	ld	r18, Z
    1d58:	fc 01       	movw	r30, r24
    1d5a:	e5 56       	subi	r30, 0x65	; 101
    1d5c:	fd 4f       	sbci	r31, 0xFD	; 253
    1d5e:	80 81       	ld	r24, Z
    1d60:	28 17       	cp	r18, r24
    1d62:	79 f0       	breq	.+30     	; 0x1d82 <FPoolingPump+0x28c>
		      zPumpStatus[PumpAddr]=PumpStatus[PumpAddr];
    1d64:	20 83       	st	Z, r18
		      stPoolingPump=ppSendPumpStatus;
    1d66:	87 e1       	ldi	r24, 0x17	; 23
    1d68:	c0 c1       	rjmp	.+896    	; 0x20ea <FPoolingPump+0x5f4>
		  }else stPoolingPump=ppScanResponse;
          break;
     case ppSendPumpStatus://UpdatePumpStatusToMaster;
          //StatePrintf(PSTR("10"));
	      PumpAddr=(txPumpID&0x0F);
    1d6a:	80 91 17 01 	lds	r24, 0x0117
    1d6e:	e8 2f       	mov	r30, r24
    1d70:	ef 70       	andi	r30, 0x0F	; 15
    1d72:	e0 93 05 01 	sts	0x0105, r30
	      SendPumpStatusFlow(txPumpID,PumpStatus[PumpAddr]);
    1d76:	f0 e0       	ldi	r31, 0x00	; 0
    1d78:	eb 54       	subi	r30, 0x4B	; 75
    1d7a:	fc 4f       	sbci	r31, 0xFC	; 252
    1d7c:	60 81       	ld	r22, Z
    1d7e:	0e 94 c8 06 	call	0xd90	; 0xd90 <SendPumpStatusFlow>
	      stPoolingPump=ppScanResponse;
    1d82:	88 e1       	ldi	r24, 0x18	; 24
    1d84:	b2 c1       	rjmp	.+868    	; 0x20ea <FPoolingPump+0x5f4>
	      break;
     case ppScanResponse:
          //StatePrintf(PSTR("11"));
		  PumpAddr=(txPumpID&0x0F);
    1d86:	80 91 17 01 	lds	r24, 0x0117
    1d8a:	8f 70       	andi	r24, 0x0F	; 15
    1d8c:	80 93 05 01 	sts	0x0105, r24
		  switch(CMDResponse){
    1d90:	90 91 8d 01 	lds	r25, 0x018D
    1d94:	98 30       	cpi	r25, 0x08	; 8
    1d96:	c1 f1       	breq	.+112    	; 0x1e08 <FPoolingPump+0x312>
    1d98:	99 30       	cpi	r25, 0x09	; 9
    1d9a:	28 f4       	brcc	.+10     	; 0x1da6 <FPoolingPump+0x2b0>
    1d9c:	96 30       	cpi	r25, 0x06	; 6
    1d9e:	41 f0       	breq	.+16     	; 0x1db0 <FPoolingPump+0x2ba>
    1da0:	97 30       	cpi	r25, 0x07	; 7
    1da2:	91 f5       	brne	.+100    	; 0x1e08 <FPoolingPump+0x312>
    1da4:	16 c0       	rjmp	.+44     	; 0x1dd2 <FPoolingPump+0x2dc>
    1da6:	99 30       	cpi	r25, 0x09	; 9
    1da8:	31 f1       	breq	.+76     	; 0x1df6 <FPoolingPump+0x300>
    1daa:	9b 30       	cpi	r25, 0x0B	; 11
    1dac:	69 f5       	brne	.+90     	; 0x1e08 <FPoolingPump+0x312>
    1dae:	1a c0       	rjmp	.+52     	; 0x1de4 <FPoolingPump+0x2ee>
		  case PUMP_OFF:               
		       if (IsRequestTransInfo[PumpAddr]==True)
    1db0:	a8 2f       	mov	r26, r24
    1db2:	b0 e0       	ldi	r27, 0x00	; 0
    1db4:	fd 01       	movw	r30, r26
    1db6:	e6 57       	subi	r30, 0x76	; 118
    1db8:	fd 4f       	sbci	r31, 0xFD	; 253
    1dba:	80 81       	ld	r24, Z
    1dbc:	81 30       	cpi	r24, 0x01	; 1
    1dbe:	c9 f0       	breq	.+50     	; 0x1df2 <FPoolingPump+0x2fc>
			       stPoolingPump=ppRequestTransData;
               else 
		       if (IsRequestTotalizerInfo[PumpAddr]==True){
    1dc0:	ad 5e       	subi	r26, 0xED	; 237
    1dc2:	bb 4f       	sbci	r27, 0xFB	; 251
    1dc4:	8c 91       	ld	r24, X
    1dc6:	81 30       	cpi	r24, 0x01	; 1
    1dc8:	11 f4       	brne	.+4      	; 0x1dce <FPoolingPump+0x2d8>
			        stPoolingPump=ppRequestTotalizerData;
    1dca:	8b e1       	ldi	r24, 0x1B	; 27
    1dcc:	1e c0       	rjmp	.+60     	; 0x1e0a <FPoolingPump+0x314>
				}	
               else stPoolingPump=ppNextPump;
    1dce:	81 e0       	ldi	r24, 0x01	; 1
    1dd0:	1c c0       	rjmp	.+56     	; 0x1e0a <FPoolingPump+0x314>
		       break;
          case PUMP_CALL:
 			   if (PumpLock[PumpAddr]==False){
    1dd2:	e8 2f       	mov	r30, r24
    1dd4:	f0 e0       	ldi	r31, 0x00	; 0
    1dd6:	e4 53       	subi	r30, 0x34	; 52
    1dd8:	fd 4f       	sbci	r31, 0xFD	; 253
    1dda:	80 81       	ld	r24, Z
    1ddc:	88 23       	and	r24, r24
    1dde:	b9 f4       	brne	.+46     	; 0x1e0e <FPoolingPump+0x318>
			   	 //  if (IsRequestTransInfo[PumpAddr]==False) 
				 //      IsRequestTransInfo[PumpAddr]=True;
			       stPoolingPump=ppReplyAuth;               
    1de0:	88 e0       	ldi	r24, 0x08	; 8
    1de2:	13 c0       	rjmp	.+38     	; 0x1e0a <FPoolingPump+0x314>
			   } 
		       break;
		  case PUMP_FEOT:
		       if (IsRequestTransInfo[PumpAddr]==True)
    1de4:	e8 2f       	mov	r30, r24
    1de6:	f0 e0       	ldi	r31, 0x00	; 0
    1de8:	e6 57       	subi	r30, 0x76	; 118
    1dea:	fd 4f       	sbci	r31, 0xFD	; 253
    1dec:	80 81       	ld	r24, Z
    1dee:	81 30       	cpi	r24, 0x01	; 1
    1df0:	59 f4       	brne	.+22     	; 0x1e08 <FPoolingPump+0x312>
			       stPoolingPump=ppRequestTransData;
    1df2:	8a e0       	ldi	r24, 0x0A	; 10
    1df4:	0a c0       	rjmp	.+20     	; 0x1e0a <FPoolingPump+0x314>
               else stPoolingPump=ppInitDelayNextPump;
		       break;
		  case PUMP_BUSY:
               if (IsRequestTransInfo[PumpAddr]==False)
    1df6:	e8 2f       	mov	r30, r24
    1df8:	f0 e0       	ldi	r31, 0x00	; 0
    1dfa:	e6 57       	subi	r30, 0x76	; 118
    1dfc:	fd 4f       	sbci	r31, 0xFD	; 253
    1dfe:	80 81       	ld	r24, Z
    1e00:	88 23       	and	r24, r24
    1e02:	11 f4       	brne	.+4      	; 0x1e08 <FPoolingPump+0x312>
			       IsRequestTransInfo[PumpAddr]=True;
    1e04:	81 e0       	ldi	r24, 0x01	; 1
    1e06:	80 83       	st	Z, r24
		       break;
		  case PUMP_AUTH:
               stPoolingPump=ppInitDelayNextPump;
		       break;		  
          default:
               stPoolingPump=ppInitDelayNextPump;
    1e08:	84 e1       	ldi	r24, 0x14	; 20
    1e0a:	80 93 2c 01 	sts	0x012C, r24
		       break;
		  }
		  //Existing Pump
		  if (IsNoPump==True){
    1e0e:	80 91 06 01 	lds	r24, 0x0106
    1e12:	81 30       	cpi	r24, 0x01	; 1
    1e14:	09 f0       	breq	.+2      	; 0x1e18 <FPoolingPump+0x322>
    1e16:	6b c1       	rjmp	.+726    	; 0x20ee <FPoolingPump+0x5f8>
		      IsNoPump=False;
    1e18:	10 92 06 01 	sts	0x0106, r1
			  stPoolingPump=ppInitDelayNextPump;
    1e1c:	84 e1       	ldi	r24, 0x14	; 20
    1e1e:	65 c1       	rjmp	.+714    	; 0x20ea <FPoolingPump+0x5f4>
	 }
	 zDataBuffer[0]=data;
}

void SetReceiveLine(char RecLine){
     stReceiveCom0=RecLine;
    1e20:	81 e0       	ldi	r24, 0x01	; 1
    1e22:	80 93 04 01 	sts	0x0104, r24
	      break;
     case ppReplyAuth:
          //StatePrintf(PSTR("11"));
	      SetReceiveLine(rcIdle);
	      if (GetReceiveLine()==rcIdle){
			  iSend=0;
    1e26:	10 92 f9 03 	sts	0x03F9, r1
		      stPoolingPump=ppSendAuthorize;
    1e2a:	8c e0       	ldi	r24, 0x0C	; 12
    1e2c:	5e c1       	rjmp	.+700    	; 0x20ea <FPoolingPump+0x5f4>
			  }
		  else stPoolingPump=ppReplyAuth;
	      break;
     case ppSendAuthorize:
          //StatePrintf(PSTR("12"));
	      TimSend=0;
    1e2e:	10 92 24 04 	sts	0x0424, r1
    1e32:	10 92 23 04 	sts	0x0423, r1
		  IsStatusReceived=False;
    1e36:	10 92 0f 01 	sts	0x010F, r1
	      PumpCommand(txPumpID,CMD_AUTHORIZE);
    1e3a:	80 91 17 01 	lds	r24, 0x0117
    1e3e:	61 e0       	ldi	r22, 0x01	; 1
    1e40:	0e 94 27 07 	call	0xe4e	; 0xe4e <PumpCommand>
		  stPoolingPump=ppWaitAuthorized;
    1e44:	8d e0       	ldi	r24, 0x0D	; 13
    1e46:	51 c1       	rjmp	.+674    	; 0x20ea <FPoolingPump+0x5f4>
	      break;
     case ppWaitAuthorized:
          //StatePrintf(PSTR("13"));
	      if (TimSend>TPoolTimeout){
    1e48:	80 91 b6 02 	lds	r24, 0x02B6
    1e4c:	90 e0       	ldi	r25, 0x00	; 0
    1e4e:	20 91 23 04 	lds	r18, 0x0423
    1e52:	30 91 24 04 	lds	r19, 0x0424
    1e56:	82 17       	cp	r24, r18
    1e58:	93 07       	cpc	r25, r19
    1e5a:	80 f4       	brcc	.+32     	; 0x1e7c <FPoolingPump+0x386>
		  	  iSend++;
    1e5c:	80 91 f9 03 	lds	r24, 0x03F9
    1e60:	8f 5f       	subi	r24, 0xFF	; 255
    1e62:	80 93 f9 03 	sts	0x03F9, r24
		      if (iSend<nSend)stPoolingPump=ppSendAuthorize;
    1e66:	90 91 77 02 	lds	r25, 0x0277
    1e6a:	89 17       	cp	r24, r25
    1e6c:	10 f4       	brcc	.+4      	; 0x1e72 <FPoolingPump+0x37c>
    1e6e:	8c e0       	ldi	r24, 0x0C	; 12
    1e70:	03 c0       	rjmp	.+6      	; 0x1e78 <FPoolingPump+0x382>
			  else
		      if (iSend>nSend)stPoolingPump=ppNoPump;//Pump Not Available
    1e72:	98 17       	cp	r25, r24
    1e74:	18 f4       	brcc	.+6      	; 0x1e7c <FPoolingPump+0x386>
    1e76:	85 e0       	ldi	r24, 0x05	; 5
    1e78:	80 93 2c 01 	sts	0x012C, r24
		  }
	      if (IsStatusReceived==True){
    1e7c:	80 91 0f 01 	lds	r24, 0x010F
    1e80:	81 30       	cpi	r24, 0x01	; 1
    1e82:	09 f0       	breq	.+2      	; 0x1e86 <FPoolingPump+0x390>
    1e84:	34 c1       	rjmp	.+616    	; 0x20ee <FPoolingPump+0x5f8>
		      IsStatusReceived=False;
    1e86:	10 92 0f 01 	sts	0x010F, r1
			  //Authorized
			  _uart_printf(1,1,PSTR("Authorized"));
    1e8a:	61 e0       	ldi	r22, 0x01	; 1
    1e8c:	4f e5       	ldi	r20, 0x5F	; 95
    1e8e:	51 e0       	ldi	r21, 0x01	; 1
    1e90:	0e 94 89 18 	call	0x3112	; 0x3112 <_uart_printf>

		      if ((txPumpID&0x0F)==PumpID)stPoolingPump=ppUpdatePumpStatus;
    1e94:	20 91 17 01 	lds	r18, 0x0117
    1e98:	30 e0       	ldi	r19, 0x00	; 0
    1e9a:	2f 70       	andi	r18, 0x0F	; 15
    1e9c:	30 70       	andi	r19, 0x00	; 0
    1e9e:	80 91 0e 01 	lds	r24, 0x010E
    1ea2:	90 e0       	ldi	r25, 0x00	; 0
    1ea4:	28 17       	cp	r18, r24
    1ea6:	39 07       	cpc	r19, r25
    1ea8:	11 f4       	brne	.+4      	; 0x1eae <FPoolingPump+0x3b8>
    1eaa:	87 e0       	ldi	r24, 0x07	; 7
    1eac:	1e c1       	rjmp	.+572    	; 0x20ea <FPoolingPump+0x5f4>
			  else stPoolingPump=ppDifferentPumpID;
    1eae:	89 e0       	ldi	r24, 0x09	; 9
    1eb0:	1c c1       	rjmp	.+568    	; 0x20ea <FPoolingPump+0x5f4>
		  }
	      break;
     case ppRequestRealTimeMoney:
          //StatePrintf(PSTR("14"));
		  Com0ReceiveCount=0;
    1eb2:	10 92 23 01 	sts	0x0123, r1
	 }
	 zDataBuffer[0]=data;
}

void SetReceiveLine(char RecLine){
     stReceiveCom0=RecLine;
    1eb6:	82 e0       	ldi	r24, 0x02	; 2
    1eb8:	80 93 04 01 	sts	0x0104, r24
     case ppRequestRealTimeMoney:
          //StatePrintf(PSTR("14"));
		  Com0ReceiveCount=0;
	      SetReceiveLine(rcRealTimeMoney);
	      if (GetReceiveLine()==rcRealTimeMoney){
			  iSend=0;
    1ebc:	10 92 f9 03 	sts	0x03F9, r1
    1ec0:	25 c0       	rjmp	.+74     	; 0x1f0c <FPoolingPump+0x416>
			  }
		  else stPoolingPump=ppRequestRealTimeMoney;
	      break;
     case ppSendMoneyReq:
          //StatePrintf(PSTR("15"));
	 	  TimSend=0;
    1ec2:	10 92 24 04 	sts	0x0424, r1
    1ec6:	10 92 23 04 	sts	0x0423, r1
	      IsMoneyReceived=False;
    1eca:	10 92 10 01 	sts	0x0110, r1
	      PumpCommand(txPumpID,CMD_REALTIME_MONEY);
    1ece:	80 91 17 01 	lds	r24, 0x0117
    1ed2:	66 e0       	ldi	r22, 0x06	; 6
    1ed4:	0e 94 27 07 	call	0xe4e	; 0xe4e <PumpCommand>
		  stPoolingPump=ppWaitMoneyReq;
    1ed8:	8f e0       	ldi	r24, 0x0F	; 15
    1eda:	07 c1       	rjmp	.+526    	; 0x20ea <FPoolingPump+0x5f4>
	      break;
     case ppWaitMoneyReq:
          //StatePrintf(PSTR("16"));
	      if (IsMoneyReceived==False){
    1edc:	80 91 10 01 	lds	r24, 0x0110
    1ee0:	88 23       	and	r24, r24
    1ee2:	d9 f4       	brne	.+54     	; 0x1f1a <FPoolingPump+0x424>
		  	  if (TimSend>TPoolTimeout){
    1ee4:	80 91 b6 02 	lds	r24, 0x02B6
    1ee8:	90 e0       	ldi	r25, 0x00	; 0
    1eea:	20 91 23 04 	lds	r18, 0x0423
    1eee:	30 91 24 04 	lds	r19, 0x0424
    1ef2:	82 17       	cp	r24, r18
    1ef4:	93 07       	cpc	r25, r19
    1ef6:	08 f0       	brcs	.+2      	; 0x1efa <FPoolingPump+0x404>
    1ef8:	fa c0       	rjmp	.+500    	; 0x20ee <FPoolingPump+0x5f8>
			      iSend++;
    1efa:	80 91 f9 03 	lds	r24, 0x03F9
    1efe:	8f 5f       	subi	r24, 0xFF	; 255
    1f00:	80 93 f9 03 	sts	0x03F9, r24
		          if (iSend<nSend)stPoolingPump=ppSendMoneyReq;
    1f04:	90 91 77 02 	lds	r25, 0x0277
    1f08:	89 17       	cp	r24, r25
    1f0a:	10 f4       	brcc	.+4      	; 0x1f10 <FPoolingPump+0x41a>
    1f0c:	8e e0       	ldi	r24, 0x0E	; 14
    1f0e:	ed c0       	rjmp	.+474    	; 0x20ea <FPoolingPump+0x5f4>
			      else
		          if (iSend>nSend)stPoolingPump=ppNoPump;//Pump Not Available
    1f10:	98 17       	cp	r25, r24
    1f12:	08 f0       	brcs	.+2      	; 0x1f16 <FPoolingPump+0x420>
    1f14:	ec c0       	rjmp	.+472    	; 0x20ee <FPoolingPump+0x5f8>
    1f16:	85 e0       	ldi	r24, 0x05	; 5
    1f18:	e8 c0       	rjmp	.+464    	; 0x20ea <FPoolingPump+0x5f4>
			  }
		  }else
	      if (IsMoneyReceived==True){
    1f1a:	81 30       	cpi	r24, 0x01	; 1
    1f1c:	09 f0       	breq	.+2      	; 0x1f20 <FPoolingPump+0x42a>
    1f1e:	e7 c0       	rjmp	.+462    	; 0x20ee <FPoolingPump+0x5f8>
		      IsMoneyReceived=False;
    1f20:	10 92 10 01 	sts	0x0110, r1
			  PumpAddr=(txPumpID&0x0F);
    1f24:	80 91 17 01 	lds	r24, 0x0117
    1f28:	8f 70       	andi	r24, 0x0F	; 15
    1f2a:	80 93 05 01 	sts	0x0105, r24
			  //SendCurrentMoney(txPumpID,strCurrentMoney);
			  stPoolingPump=ppMoneyRequestCompleted;
    1f2e:	80 e1       	ldi	r24, 0x10	; 16
    1f30:	dc c0       	rjmp	.+440    	; 0x20ea <FPoolingPump+0x5f4>
	      TimDelayNextPump=0;
		  stPoolingPump=ppDelayNextPump;
	      break;
     case ppDelayNextPump:
          //StatePrintf(PSTR("18"));
	      if (TimDelayNextPump>=TDelayNextPump)
    1f32:	80 91 3c 01 	lds	r24, 0x013C
    1f36:	90 e0       	ldi	r25, 0x00	; 0
    1f38:	20 91 21 01 	lds	r18, 0x0121
    1f3c:	30 91 22 01 	lds	r19, 0x0122
    1f40:	28 17       	cp	r18, r24
    1f42:	39 07       	cpc	r19, r25
    1f44:	08 f4       	brcc	.+2      	; 0x1f48 <FPoolingPump+0x452>
    1f46:	d3 c0       	rjmp	.+422    	; 0x20ee <FPoolingPump+0x5f8>
    1f48:	7a c0       	rjmp	.+244    	; 0x203e <FPoolingPump+0x548>
		      stPoolingPump=ppNextPump;	      
	      break;
     case ppIsRequestTransInfo:
          PumpAddr=(txPumpID&0x0F);
    1f4a:	e0 91 17 01 	lds	r30, 0x0117
    1f4e:	ef 70       	andi	r30, 0x0F	; 15
    1f50:	e0 93 05 01 	sts	0x0105, r30
	      if (IsRequestTransInfo[PumpAddr]!=False){
    1f54:	f0 e0       	ldi	r31, 0x00	; 0
    1f56:	e6 57       	subi	r30, 0x76	; 118
    1f58:	fd 4f       	sbci	r31, 0xFD	; 253
    1f5a:	80 81       	ld	r24, Z
    1f5c:	88 23       	and	r24, r24
    1f5e:	11 f0       	breq	.+4      	; 0x1f64 <FPoolingPump+0x46e>
		      stPoolingPump=ppRequestTransData;		  
    1f60:	8a e0       	ldi	r24, 0x0A	; 10
    1f62:	c3 c0       	rjmp	.+390    	; 0x20ea <FPoolingPump+0x5f4>
		  }else{
		  stPoolingPump=ppIsRequestTotalizerInfo;
    1f64:	8a e1       	ldi	r24, 0x1A	; 26
    1f66:	c1 c0       	rjmp	.+386    	; 0x20ea <FPoolingPump+0x5f4>
	 }
	 zDataBuffer[0]=data;
}

void SetReceiveLine(char RecLine){
     stReceiveCom0=RecLine;
    1f68:	83 e0       	ldi	r24, 0x03	; 3
    1f6a:	80 93 04 01 	sts	0x0104, r24
	      break;
     case ppRequestTransData:
          //StatePrintf(PSTR("19"));
	      SetReceiveLine(rcInitTransaction);
	      if (GetReceiveLine()==rcInitTransaction){
			  iSend=0;
    1f6e:	10 92 f9 03 	sts	0x03F9, r1
    1f72:	30 c0       	rjmp	.+96     	; 0x1fd4 <FPoolingPump+0x4de>
			  }
		  else stPoolingPump=ppRequestTransData;
	      break;
     case ppSendTransReq:
          //StatePrintf(PSTR("20"));
	 	  TimSend=0;
    1f74:	10 92 24 04 	sts	0x0424, r1
    1f78:	10 92 23 04 	sts	0x0423, r1
	      IsTransaction=False;
    1f7c:	10 92 11 01 	sts	0x0111, r1
	      PumpCommand(txPumpID,CMD_TRANSACTION_DATA);		  
    1f80:	80 91 17 01 	lds	r24, 0x0117
    1f84:	64 e0       	ldi	r22, 0x04	; 4
    1f86:	0e 94 27 07 	call	0xe4e	; 0xe4e <PumpCommand>
		  stPoolingPump=ppWaitTransReq;
    1f8a:	82 e1       	ldi	r24, 0x12	; 18
    1f8c:	ae c0       	rjmp	.+348    	; 0x20ea <FPoolingPump+0x5f4>
	      break;
	 case ppWaitTransReq:
          //StatePrintf(PSTR("21"));
		  if (IsTransaction==True){
    1f8e:	80 91 11 01 	lds	r24, 0x0111
    1f92:	81 30       	cpi	r24, 0x01	; 1
    1f94:	41 f4       	brne	.+16     	; 0x1fa6 <FPoolingPump+0x4b0>
		      PumpAddr=(txPumpID&0x0F);
    1f96:	80 91 17 01 	lds	r24, 0x0117
    1f9a:	8f 70       	andi	r24, 0x0F	; 15
    1f9c:	80 93 05 01 	sts	0x0105, r24
		      stPoolingPump=ppTransRequestCompleted;
    1fa0:	83 e1       	ldi	r24, 0x13	; 19
    1fa2:	80 93 2c 01 	sts	0x012C, r24
			  }
		  if (TimSend>(TPoolTimeout*2)){
    1fa6:	80 91 b6 02 	lds	r24, 0x02B6
    1faa:	90 e0       	ldi	r25, 0x00	; 0
    1fac:	88 0f       	add	r24, r24
    1fae:	99 1f       	adc	r25, r25
    1fb0:	20 91 23 04 	lds	r18, 0x0423
    1fb4:	30 91 24 04 	lds	r19, 0x0424
    1fb8:	82 17       	cp	r24, r18
    1fba:	93 07       	cpc	r25, r19
    1fbc:	08 f0       	brcs	.+2      	; 0x1fc0 <FPoolingPump+0x4ca>
    1fbe:	97 c0       	rjmp	.+302    	; 0x20ee <FPoolingPump+0x5f8>
		  	  iSend++;
    1fc0:	80 91 f9 03 	lds	r24, 0x03F9
    1fc4:	8f 5f       	subi	r24, 0xFF	; 255
    1fc6:	80 93 f9 03 	sts	0x03F9, r24
		      if (iSend<nSend)stPoolingPump=ppSendTransReq;
    1fca:	90 91 77 02 	lds	r25, 0x0277
    1fce:	89 17       	cp	r24, r25
    1fd0:	08 f0       	brcs	.+2      	; 0x1fd4 <FPoolingPump+0x4de>
    1fd2:	6b c0       	rjmp	.+214    	; 0x20aa <FPoolingPump+0x5b4>
    1fd4:	81 e1       	ldi	r24, 0x11	; 17
    1fd6:	89 c0       	rjmp	.+274    	; 0x20ea <FPoolingPump+0x5f4>
		      if (iSend>nSend)stPoolingPump=ppDelayNextPump;	      
		  }
	      break;
	 case ppTransRequestCompleted:
          //StatePrintf(PSTR("21"));
		  stPoolingPump=ppSendTransInfo;
    1fd8:	86 e1       	ldi	r24, 0x16	; 22
    1fda:	87 c0       	rjmp	.+270    	; 0x20ea <FPoolingPump+0x5f4>
	      break;
     case ppSendTransInfo:
	      PumpAddr=(txPumpID&0x0F);	      
    1fdc:	80 91 17 01 	lds	r24, 0x0117
    1fe0:	98 2f       	mov	r25, r24
    1fe2:	9f 70       	andi	r25, 0x0F	; 15
    1fe4:	90 93 05 01 	sts	0x0105, r25
		  SendTransFlow(txPumpID,rxPumpId,NozzleId,GradeId,strUnitPrice,strVolume,strAmount,PumpTransDigit);
    1fe8:	60 91 3b 01 	lds	r22, 0x013B
    1fec:	40 91 e0 02 	lds	r20, 0x02E0
    1ff0:	20 91 f6 02 	lds	r18, 0x02F6
    1ff4:	0c ea       	ldi	r16, 0xAC	; 172
    1ff6:	12 e0       	ldi	r17, 0x02	; 2
    1ff8:	37 e5       	ldi	r19, 0x57	; 87
    1ffa:	e3 2e       	mov	r14, r19
    1ffc:	32 e0       	ldi	r19, 0x02	; 2
    1ffe:	f3 2e       	mov	r15, r19
    2000:	9b ea       	ldi	r25, 0xAB	; 171
    2002:	c9 2e       	mov	r12, r25
    2004:	93 e0       	ldi	r25, 0x03	; 3
    2006:	d9 2e       	mov	r13, r25
    2008:	a0 90 0b 01 	lds	r10, 0x010B
    200c:	0e 94 bd 0c 	call	0x197a	; 0x197a <SendTransFlow>
		  IsRequestTransInfo[PumpAddr]=False;
    2010:	e0 91 05 01 	lds	r30, 0x0105
    2014:	f0 e0       	ldi	r31, 0x00	; 0
    2016:	e6 57       	subi	r30, 0x76	; 118
    2018:	fd 4f       	sbci	r31, 0xFD	; 253
    201a:	61 c0       	rjmp	.+194    	; 0x20de <FPoolingPump+0x5e8>
	      TimDelayNextPump=0;		  
		  stPoolingPump=ppDelayNextPump;
	      break;     
     case ppIsRequestTotalizerInfo:
          //StatePrintf(PSTR("23"));
	      PumpAddr=(txPumpID&0x0F);
    201c:	e0 91 17 01 	lds	r30, 0x0117
    2020:	ef 70       	andi	r30, 0x0F	; 15
    2022:	e0 93 05 01 	sts	0x0105, r30
	      if (IsRequestTotalizerInfo[PumpAddr]==True){
    2026:	f0 e0       	ldi	r31, 0x00	; 0
    2028:	ed 5e       	subi	r30, 0xED	; 237
    202a:	fb 4f       	sbci	r31, 0xFB	; 251
    202c:	80 81       	ld	r24, Z
    202e:	81 30       	cpi	r24, 0x01	; 1
    2030:	11 f4       	brne	.+4      	; 0x2036 <FPoolingPump+0x540>
		      stPoolingPump=ppRequestTotalizerData;		  
    2032:	8b e1       	ldi	r24, 0x1B	; 27
    2034:	5a c0       	rjmp	.+180    	; 0x20ea <FPoolingPump+0x5f4>
		  }else{
		  TimDelayNextPump=0; 
    2036:	10 92 22 01 	sts	0x0122, r1
    203a:	10 92 21 01 	sts	0x0121, r1
		  stPoolingPump=ppNextPump;
    203e:	81 e0       	ldi	r24, 0x01	; 1
    2040:	54 c0       	rjmp	.+168    	; 0x20ea <FPoolingPump+0x5f4>
	 }
	 zDataBuffer[0]=data;
}

void SetReceiveLine(char RecLine){
     stReceiveCom0=RecLine;
    2042:	84 e0       	ldi	r24, 0x04	; 4
    2044:	80 93 04 01 	sts	0x0104, r24

     case ppRequestTotalizerData:
          //StatePrintf(PSTR("24"));
	      SetReceiveLine(rcInitTotalizer);
	      if (GetReceiveLine()==rcInitTotalizer){
			  iSend=0;
    2048:	10 92 f9 03 	sts	0x03F9, r1
    204c:	2c c0       	rjmp	.+88     	; 0x20a6 <FPoolingPump+0x5b0>
			  }
		  else stPoolingPump=ppRequestTotalizerData;
	      break;
     case ppSendTotalizerReq:
          //StatePrintf(PSTR("25"));
	 	  TimSend=0;
    204e:	10 92 24 04 	sts	0x0424, r1
    2052:	10 92 23 04 	sts	0x0423, r1
	      IsTotalizer=False;
    2056:	10 92 12 01 	sts	0x0112, r1
	      PumpCommand(txPumpID,CMD_TOTALIZER);
    205a:	80 91 17 01 	lds	r24, 0x0117
    205e:	65 e0       	ldi	r22, 0x05	; 5
    2060:	0e 94 27 07 	call	0xe4e	; 0xe4e <PumpCommand>
		  stPoolingPump=ppWaitTotalizerReq;
    2064:	8d e1       	ldi	r24, 0x1D	; 29
    2066:	41 c0       	rjmp	.+130    	; 0x20ea <FPoolingPump+0x5f4>
	      break;
	 case ppWaitTotalizerReq:
          //StatePrintf(PSTR("26"));
		  if (IsTotalizer==True){
    2068:	80 91 12 01 	lds	r24, 0x0112
    206c:	81 30       	cpi	r24, 0x01	; 1
    206e:	29 f4       	brne	.+10     	; 0x207a <FPoolingPump+0x584>
		  	  IsTotalizer=False;
    2070:	10 92 12 01 	sts	0x0112, r1
			  stPoolingPump=ppTotalizerRequestCompleted;
    2074:	8e e1       	ldi	r24, 0x1E	; 30
    2076:	80 93 2c 01 	sts	0x012C, r24
		  }
          //if (TimSend>WAIT_TOTALIZER_TIMEOUT){
		  //    stPoolingPump=ppDelayNextPump;
		  //}
		  if (TimSend>(TPoolTimeout*5)){
    207a:	80 91 b6 02 	lds	r24, 0x02B6
    207e:	25 e0       	ldi	r18, 0x05	; 5
    2080:	82 9f       	mul	r24, r18
    2082:	c0 01       	movw	r24, r0
    2084:	11 24       	eor	r1, r1
    2086:	20 91 23 04 	lds	r18, 0x0423
    208a:	30 91 24 04 	lds	r19, 0x0424
    208e:	82 17       	cp	r24, r18
    2090:	93 07       	cpc	r25, r19
    2092:	68 f5       	brcc	.+90     	; 0x20ee <FPoolingPump+0x5f8>
		  	  iSend++;
    2094:	80 91 f9 03 	lds	r24, 0x03F9
    2098:	8f 5f       	subi	r24, 0xFF	; 255
    209a:	80 93 f9 03 	sts	0x03F9, r24
		      if (iSend<nSend)stPoolingPump=ppSendTotalizerReq;
    209e:	90 91 77 02 	lds	r25, 0x0277
    20a2:	89 17       	cp	r24, r25
    20a4:	10 f4       	brcc	.+4      	; 0x20aa <FPoolingPump+0x5b4>
    20a6:	8c e1       	ldi	r24, 0x1C	; 28
    20a8:	20 c0       	rjmp	.+64     	; 0x20ea <FPoolingPump+0x5f4>
			  else
		      if (iSend>nSend)stPoolingPump=ppDelayNextPump;	      
    20aa:	98 17       	cp	r25, r24
    20ac:	00 f5       	brcc	.+64     	; 0x20ee <FPoolingPump+0x5f8>
    20ae:	1c c0       	rjmp	.+56     	; 0x20e8 <FPoolingPump+0x5f2>
		  }
	      break;
	 case ppTotalizerRequestCompleted:
          //StatePrintf(PSTR("27"));																																																																																																																																		
		  stPoolingPump=ppSendTotalizerInfo;
    20b0:	8f e1       	ldi	r24, 0x1F	; 31
    20b2:	1b c0       	rjmp	.+54     	; 0x20ea <FPoolingPump+0x5f4>
	      break;
     case ppSendTotalizerInfo:
          //StatePrintf(PSTR("28"));
	      PumpAddr=(txPumpID&0x0F);
    20b4:	80 91 17 01 	lds	r24, 0x0117
    20b8:	98 2f       	mov	r25, r24
    20ba:	9f 70       	andi	r25, 0x0F	; 15
    20bc:	90 93 05 01 	sts	0x0105, r25
		  SendTotalizerFlow(txPumpID);
    20c0:	0e 94 c5 0b 	call	0x178a	; 0x178a <SendTotalizerFlow>
		  IsTotalizerACK=False;
    20c4:	10 92 14 01 	sts	0x0114, r1
		  //IsRequestTotalizerInfo[PumpAddr]=False;
	      //TimDelayNextPump=0;
		  stPoolingPump=ppWaitTotalizerACK;
    20c8:	80 e2       	ldi	r24, 0x20	; 32
    20ca:	0f c0       	rjmp	.+30     	; 0x20ea <FPoolingPump+0x5f4>
	      break;
     case ppWaitTotalizerACK:
	      if (IsTotalizerACK==True){//SC_TOTALIZER_ACK
    20cc:	80 91 14 01 	lds	r24, 0x0114
    20d0:	81 30       	cpi	r24, 0x01	; 1
    20d2:	69 f4       	brne	.+26     	; 0x20ee <FPoolingPump+0x5f8>
              IsRequestTotalizerInfo[PumpAddr]=False;
    20d4:	e0 91 05 01 	lds	r30, 0x0105
    20d8:	f0 e0       	ldi	r31, 0x00	; 0
    20da:	ed 5e       	subi	r30, 0xED	; 237
    20dc:	fb 4f       	sbci	r31, 0xFB	; 251
    20de:	10 82       	st	Z, r1
	          TimDelayNextPump=0;
    20e0:	10 92 22 01 	sts	0x0122, r1
    20e4:	10 92 21 01 	sts	0x0121, r1
		      stPoolingPump=ppDelayNextPump;               
    20e8:	85 e1       	ldi	r24, 0x15	; 21
    20ea:	80 93 2c 01 	sts	0x012C, r24
		  }
	      break;
	 }
}
    20ee:	1f 91       	pop	r17
    20f0:	0f 91       	pop	r16
    20f2:	ff 90       	pop	r15
    20f4:	ef 90       	pop	r14
    20f6:	df 90       	pop	r13
    20f8:	cf 90       	pop	r12
    20fa:	af 90       	pop	r10
    20fc:	08 95       	ret

000020fe <FPoolingPump2>:
			 }
             rxBufferLength=0;
		}
}

void FPoolingPump2(){
    20fe:	af 92       	push	r10
    2100:	cf 92       	push	r12
    2102:	df 92       	push	r13
    2104:	ef 92       	push	r14
    2106:	ff 92       	push	r15
    2108:	0f 93       	push	r16
    210a:	1f 93       	push	r17
    210c:	df 93       	push	r29
    210e:	cf 93       	push	r28
    2110:	cd b7       	in	r28, 0x3d	; 61
    2112:	de b7       	in	r29, 0x3e	; 62
    2114:	6e 97       	sbiw	r28, 0x1e	; 30
    2116:	0f b6       	in	r0, 0x3f	; 63
    2118:	f8 94       	cli
    211a:	de bf       	out	0x3e, r29	; 62
    211c:	0f be       	out	0x3f, r0	; 63
    211e:	cd bf       	out	0x3d, r28	; 61
     static char zPooling,stPoolingPump=pwInit,nPoolTotalizer=0,IsTotalizerBusy=False,iAuthCmd=0;
	 char strSend[30];

	 //Monitoring
	 if (zPooling!=stPoolingPump){
    2120:	20 91 31 01 	lds	r18, 0x0131
    2124:	80 91 32 01 	lds	r24, 0x0132
    2128:	82 17       	cp	r24, r18
    212a:	31 f1       	breq	.+76     	; 0x2178 <FPoolingPump2+0x7a>
	     zPooling=stPoolingPump;
    212c:	20 93 32 01 	sts	0x0132, r18
		 #ifdef DEBUG_WAYNE_POOLING
         sprintf_P(strSend,PSTR("WPool:%d"),stPoolingPump);
    2130:	00 d0       	rcall	.+0      	; 0x2132 <FPoolingPump2+0x34>
    2132:	00 d0       	rcall	.+0      	; 0x2134 <FPoolingPump2+0x36>
    2134:	00 d0       	rcall	.+0      	; 0x2136 <FPoolingPump2+0x38>
    2136:	ed b7       	in	r30, 0x3d	; 61
    2138:	fe b7       	in	r31, 0x3e	; 62
    213a:	31 96       	adiw	r30, 0x01	; 1
    213c:	8e 01       	movw	r16, r28
    213e:	0f 5f       	subi	r16, 0xFF	; 255
    2140:	1f 4f       	sbci	r17, 0xFF	; 255
    2142:	ad b7       	in	r26, 0x3d	; 61
    2144:	be b7       	in	r27, 0x3e	; 62
    2146:	12 96       	adiw	r26, 0x02	; 2
    2148:	1c 93       	st	X, r17
    214a:	0e 93       	st	-X, r16
    214c:	11 97       	sbiw	r26, 0x01	; 1
    214e:	86 e8       	ldi	r24, 0x86	; 134
    2150:	91 e0       	ldi	r25, 0x01	; 1
    2152:	93 83       	std	Z+3, r25	; 0x03
    2154:	82 83       	std	Z+2, r24	; 0x02
    2156:	24 83       	std	Z+4, r18	; 0x04
    2158:	15 82       	std	Z+5, r1	; 0x05
    215a:	0e 94 b2 18 	call	0x3164	; 0x3164 <sprintf_P>
	 	 _uart_print(1,1,strSend);
    215e:	8d b7       	in	r24, 0x3d	; 61
    2160:	9e b7       	in	r25, 0x3e	; 62
    2162:	06 96       	adiw	r24, 0x06	; 6
    2164:	0f b6       	in	r0, 0x3f	; 63
    2166:	f8 94       	cli
    2168:	9e bf       	out	0x3e, r25	; 62
    216a:	0f be       	out	0x3f, r0	; 63
    216c:	8d bf       	out	0x3d, r24	; 61
    216e:	81 e0       	ldi	r24, 0x01	; 1
    2170:	61 e0       	ldi	r22, 0x01	; 1
    2172:	a8 01       	movw	r20, r16
    2174:	0e 94 61 18 	call	0x30c2	; 0x30c2 <_uart_print>
		 #endif
	 }
     //Restarting
	 if (IsRestartPooling==True){
    2178:	80 91 03 01 	lds	r24, 0x0103
    217c:	81 30       	cpi	r24, 0x01	; 1
    217e:	79 f4       	brne	.+30     	; 0x219e <FPoolingPump2+0xa0>
	     IsRestartPooling=False;
    2180:	10 92 03 01 	sts	0x0103, r1
		 SendCommandAcknoledge(SC_POOL_RESTARTED,stPoolingPump);
    2184:	8a e1       	ldi	r24, 0x1A	; 26
    2186:	60 91 31 01 	lds	r22, 0x0131
    218a:	0e 94 e0 06 	call	0xdc0	; 0xdc0 <SendCommandAcknoledge>
		 _uart_printf(1,1,PSTR("PoolRestarted"));
    218e:	81 e0       	ldi	r24, 0x01	; 1
    2190:	61 e0       	ldi	r22, 0x01	; 1
    2192:	48 e7       	ldi	r20, 0x78	; 120
    2194:	51 e0       	ldi	r21, 0x01	; 1
    2196:	0e 94 89 18 	call	0x3112	; 0x3112 <_uart_printf>
	     stPoolingPump=pwInit;
    219a:	10 92 31 01 	sts	0x0131, r1
	 }
	 switch(stPoolingPump){
    219e:	80 91 31 01 	lds	r24, 0x0131
    21a2:	e8 2f       	mov	r30, r24
    21a4:	f0 e0       	ldi	r31, 0x00	; 0
    21a6:	ec 31       	cpi	r30, 0x1C	; 28
    21a8:	f1 05       	cpc	r31, r1
    21aa:	08 f0       	brcs	.+2      	; 0x21ae <FPoolingPump2+0xb0>
    21ac:	fa c2       	rjmp	.+1524   	; 0x27a2 <FPoolingPump2+0x6a4>
    21ae:	e7 5a       	subi	r30, 0xA7	; 167
    21b0:	ff 4f       	sbci	r31, 0xFF	; 255
    21b2:	ee 0f       	add	r30, r30
    21b4:	ff 1f       	adc	r31, r31
    21b6:	05 90       	lpm	r0, Z+
    21b8:	f4 91       	lpm	r31, Z+
    21ba:	e0 2d       	mov	r30, r0
    21bc:	09 94       	ijmp
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    21be:	e1 99       	sbic	0x1c, 1	; 28
    21c0:	fe cf       	rjmp	.-4      	; 0x21be <FPoolingPump2+0xc0>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    21c2:	88 e0       	ldi	r24, 0x08	; 8
    21c4:	90 e0       	ldi	r25, 0x00	; 0
    21c6:	9f bb       	out	0x1f, r25	; 31
    21c8:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    21ca:	e0 9a       	sbi	0x1c, 0	; 28
    21cc:	8d b3       	in	r24, 0x1d	; 29
	 case pwInit:
		  nNoPump=eeprom_read_byte(&DefNoPumpCountMax);
    21ce:	80 93 35 04 	sts	0x0435, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    21d2:	e1 99       	sbic	0x1c, 1	; 28
    21d4:	fe cf       	rjmp	.-4      	; 0x21d2 <FPoolingPump2+0xd4>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    21d6:	87 e0       	ldi	r24, 0x07	; 7
    21d8:	90 e0       	ldi	r25, 0x00	; 0
    21da:	9f bb       	out	0x1f, r25	; 31
    21dc:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    21de:	e0 9a       	sbi	0x1c, 0	; 28
    21e0:	8d b3       	in	r24, 0x1d	; 29
		  ScanPumpMax=eeprom_read_byte(&DefMaxPumpPooling);
    21e2:	80 93 61 02 	sts	0x0261, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    21e6:	e1 99       	sbic	0x1c, 1	; 28
    21e8:	fe cf       	rjmp	.-4      	; 0x21e6 <FPoolingPump2+0xe8>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    21ea:	89 e0       	ldi	r24, 0x09	; 9
    21ec:	90 e0       	ldi	r25, 0x00	; 0
    21ee:	9f bb       	out	0x1f, r25	; 31
    21f0:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    21f2:	e0 9a       	sbi	0x1c, 0	; 28
    21f4:	8d b3       	in	r24, 0x1d	; 29
		  nSend=eeprom_read_byte(&DefSendCount);
    21f6:	80 93 77 02 	sts	0x0277, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    21fa:	e1 99       	sbic	0x1c, 1	; 28
    21fc:	fe cf       	rjmp	.-4      	; 0x21fa <FPoolingPump2+0xfc>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    21fe:	8d e1       	ldi	r24, 0x1D	; 29
    2200:	90 e0       	ldi	r25, 0x00	; 0
    2202:	9f bb       	out	0x1f, r25	; 31
    2204:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2206:	e0 9a       	sbi	0x1c, 0	; 28
    2208:	8d b3       	in	r24, 0x1d	; 29
		  nPoolTotalizer=eeprom_read_byte(&DefNozzleCount);
    220a:	80 93 30 01 	sts	0x0130, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    220e:	e1 99       	sbic	0x1c, 1	; 28
    2210:	fe cf       	rjmp	.-4      	; 0x220e <FPoolingPump2+0x110>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2212:	8a e0       	ldi	r24, 0x0A	; 10
    2214:	90 e0       	ldi	r25, 0x00	; 0
    2216:	9f bb       	out	0x1f, r25	; 31
    2218:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    221a:	e0 9a       	sbi	0x1c, 0	; 28
    221c:	8d b3       	in	r24, 0x1d	; 29
		  TPoolTimeout=eeprom_read_byte(&DefPoolTimeout);
    221e:	80 93 b6 02 	sts	0x02B6, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2222:	e1 99       	sbic	0x1c, 1	; 28
    2224:	fe cf       	rjmp	.-4      	; 0x2222 <FPoolingPump2+0x124>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2226:	8b e0       	ldi	r24, 0x0B	; 11
    2228:	90 e0       	ldi	r25, 0x00	; 0
    222a:	9f bb       	out	0x1f, r25	; 31
    222c:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    222e:	e0 9a       	sbi	0x1c, 0	; 28
    2230:	8d b3       	in	r24, 0x1d	; 29
		  TDelayNextPump=eeprom_read_byte(&DefDelayNextPump);
    2232:	80 93 3c 01 	sts	0x013C, r24
		  
		  if (IsStopPoolSequence!=True)
    2236:	80 91 13 01 	lds	r24, 0x0113
    223a:	81 30       	cpi	r24, 0x01	; 1
    223c:	29 f0       	breq	.+10     	; 0x2248 <FPoolingPump2+0x14a>
		      SendCommandAcknoledge(SC_LIVE_SEQUENCE,SequencePool);
    223e:	89 e1       	ldi	r24, 0x19	; 25
    2240:	60 91 26 01 	lds	r22, 0x0126
    2244:	0e 94 e0 06 	call	0xdc0	; 0xdc0 <SendCommandAcknoledge>
		  SequencePool++;
    2248:	80 91 26 01 	lds	r24, 0x0126
    224c:	8f 5f       	subi	r24, 0xFF	; 255
    224e:	80 93 26 01 	sts	0x0126, r24
		  iPoolingID=0;		  
    2252:	10 92 16 01 	sts	0x0116, r1
		  IsTotalizerBusy=False;
    2256:	10 92 2f 01 	sts	0x012F, r1
		  stPoolingPump=pwInitPumpAddr;
    225a:	81 e0       	ldi	r24, 0x01	; 1
    225c:	9d c2       	rjmp	.+1338   	; 0x2798 <FPoolingPump2+0x69a>
		  break;
     case pwInitPumpAddr:
		  txPumpID=eeprom_read_byte(&DefPumpID[iPoolingID]);
    225e:	80 91 16 01 	lds	r24, 0x0116
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2262:	e1 99       	sbic	0x1c, 1	; 28
    2264:	fe cf       	rjmp	.-4      	; 0x2262 <FPoolingPump2+0x164>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2266:	90 e0       	ldi	r25, 0x00	; 0
    2268:	83 5f       	subi	r24, 0xF3	; 243
    226a:	9f 4f       	sbci	r25, 0xFF	; 255
    226c:	9f bb       	out	0x1f, r25	; 31
    226e:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2270:	e0 9a       	sbi	0x1c, 0	; 28
    2272:	8d b3       	in	r24, 0x1d	; 29
          txPumpID=txPumpID-1; 
    2274:	81 50       	subi	r24, 0x01	; 1
    2276:	80 93 17 01 	sts	0x0117, r24
		   _uart_print(1,1,strSend);
		  #endif

		  //txPumpID=2-1; 
		  //SendCommandAcknoledge(SC_LIVE_SEQUENCE,SequencePool);
		  SequencePool++;
    227a:	80 91 26 01 	lds	r24, 0x0126
    227e:	8f 5f       	subi	r24, 0xFF	; 255
    2280:	80 93 26 01 	sts	0x0126, r24
          iSend=0;		  
    2284:	10 92 f9 03 	sts	0x03F9, r1
    2288:	84 c2       	rjmp	.+1288   	; 0x2792 <FPoolingPump2+0x694>
	      stPoolingPump=pwScanStatus;
          break;	 
     case pwScanStatus:
	      WayneReply=WR_NONE;
    228a:	10 92 1a 01 	sts	0x011A, r1
	      FWayneSendCommand(CMD_STATUS,0,txPumpID,0);
    228e:	80 e0       	ldi	r24, 0x00	; 0
    2290:	60 e0       	ldi	r22, 0x00	; 0
    2292:	40 91 17 01 	lds	r20, 0x0117
    2296:	20 e0       	ldi	r18, 0x00	; 0
    2298:	0e 94 53 07 	call	0xea6	; 0xea6 <FWayneSendCommand>
		  TimSend=0;
    229c:	10 92 24 04 	sts	0x0424, r1
    22a0:	10 92 23 04 	sts	0x0423, r1
		  stPoolingPump=pwWaitScanReply;
    22a4:	83 e0       	ldi	r24, 0x03	; 3
    22a6:	78 c2       	rjmp	.+1264   	; 0x2798 <FPoolingPump2+0x69a>
	      break;
     case pwWaitScanReply:
	      //Timeout->NoPump		  
          if (TimSend>TPoolTimeout){
    22a8:	80 91 b6 02 	lds	r24, 0x02B6
    22ac:	90 e0       	ldi	r25, 0x00	; 0
    22ae:	20 91 23 04 	lds	r18, 0x0423
    22b2:	30 91 24 04 	lds	r19, 0x0424
    22b6:	82 17       	cp	r24, r18
    22b8:	93 07       	cpc	r25, r19
    22ba:	70 f4       	brcc	.+28     	; 0x22d8 <FPoolingPump2+0x1da>
		      iSend++;
    22bc:	80 91 f9 03 	lds	r24, 0x03F9
    22c0:	8f 5f       	subi	r24, 0xFF	; 255
    22c2:	80 93 f9 03 	sts	0x03F9, r24
			  if (iSend<nSend)stPoolingPump=pwScanStatus;//Retry
    22c6:	90 91 77 02 	lds	r25, 0x0277
    22ca:	89 17       	cp	r24, r25
    22cc:	10 f4       	brcc	.+4      	; 0x22d2 <FPoolingPump2+0x1d4>
    22ce:	82 e0       	ldi	r24, 0x02	; 2
    22d0:	01 c0       	rjmp	.+2      	; 0x22d4 <FPoolingPump2+0x1d6>
			  else
			  if (iSend>=nSend)stPoolingPump=pwNoPump;//Pump Not Available
    22d2:	84 e0       	ldi	r24, 0x04	; 4
    22d4:	80 93 31 01 	sts	0x0131, r24
		  }		  
	      
		  switch(WayneReply){
    22d8:	80 91 1a 01 	lds	r24, 0x011A
    22dc:	81 30       	cpi	r24, 0x01	; 1
    22de:	21 f0       	breq	.+8      	; 0x22e8 <FPoolingPump2+0x1ea>
    22e0:	84 30       	cpi	r24, 0x04	; 4
    22e2:	09 f0       	breq	.+2      	; 0x22e6 <FPoolingPump2+0x1e8>
    22e4:	5e c2       	rjmp	.+1212   	; 0x27a2 <FPoolingPump2+0x6a4>
    22e6:	15 c0       	rjmp	.+42     	; 0x2312 <FPoolingPump2+0x214>
		  case WR_READY:
			   if ((PumpStatus[txPumpID]==PW_NONE)||(PumpStatus[txPumpID]==PW_DISCONNECT)){
    22e8:	80 91 17 01 	lds	r24, 0x0117
    22ec:	a8 2f       	mov	r26, r24
    22ee:	b0 e0       	ldi	r27, 0x00	; 0
    22f0:	fd 01       	movw	r30, r26
    22f2:	eb 54       	subi	r30, 0x4B	; 75
    22f4:	fc 4f       	sbci	r31, 0xFC	; 252
    22f6:	e0 81       	ld	r30, Z
    22f8:	ee 23       	and	r30, r30
    22fa:	19 f0       	breq	.+6      	; 0x2302 <FPoolingPump2+0x204>
    22fc:	ee 30       	cpi	r30, 0x0E	; 14
    22fe:	09 f0       	breq	.+2      	; 0x2302 <FPoolingPump2+0x204>
    2300:	15 c2       	rjmp	.+1066   	; 0x272c <FPoolingPump2+0x62e>
			        IsRequestTransInfo[txPumpID]=False;
    2302:	fd 01       	movw	r30, r26
    2304:	e6 57       	subi	r30, 0x76	; 118
    2306:	fd 4f       	sbci	r31, 0xFD	; 253
    2308:	10 82       	st	Z, r1
			        PumpStatus[txPumpID]=PW_ONLINE;
    230a:	ab 54       	subi	r26, 0x4B	; 75
    230c:	bc 4f       	sbci	r27, 0xFC	; 252
    230e:	86 e0       	ldi	r24, 0x06	; 6
    2310:	17 c0       	rjmp	.+46     	; 0x2340 <FPoolingPump2+0x242>
				  }
               //_uart_printf(1,1,PSTR("WR_READY"));
               stPoolingPump=pwUpdatePumpStatus;
		       break;
          case WR_MESSAGE:
		       stPoolingPump=pwReplyACK;
    2312:	87 e1       	ldi	r24, 0x17	; 23
    2314:	41 c2       	rjmp	.+1154   	; 0x2798 <FPoolingPump2+0x69a>
		       break;
		  }
	      break;
	 case pwNoPump:
	      NoPumpCount[txPumpID&0x0F]++;
    2316:	80 91 17 01 	lds	r24, 0x0117
    231a:	a8 2f       	mov	r26, r24
    231c:	b0 e0       	ldi	r27, 0x00	; 0
    231e:	fd 01       	movw	r30, r26
    2320:	ef 70       	andi	r30, 0x0F	; 15
    2322:	f0 70       	andi	r31, 0x00	; 0
    2324:	eb 5d       	subi	r30, 0xDB	; 219
    2326:	fb 4f       	sbci	r31, 0xFB	; 251
    2328:	80 81       	ld	r24, Z
    232a:	8f 5f       	subi	r24, 0xFF	; 255
    232c:	80 83       	st	Z, r24
		  if (NoPumpCount[txPumpID&0x0F]>nNoPump){
    232e:	90 91 35 04 	lds	r25, 0x0435
    2332:	98 17       	cp	r25, r24
    2334:	08 f0       	brcs	.+2      	; 0x2338 <FPoolingPump2+0x23a>
    2336:	7a c1       	rjmp	.+756    	; 0x262c <FPoolingPump2+0x52e>
		      NoPumpCount[txPumpID&0x0F]=0;
    2338:	10 82       	st	Z, r1
	          PumpStatus[txPumpID]=PW_DISCONNECT;
    233a:	ab 54       	subi	r26, 0x4B	; 75
    233c:	bc 4f       	sbci	r27, 0xFC	; 252
    233e:	8e e0       	ldi	r24, 0x0E	; 14
    2340:	8c 93       	st	X, r24
    2342:	f4 c1       	rjmp	.+1000   	; 0x272c <FPoolingPump2+0x62e>
              stPoolingPump=pwUpdatePumpStatus;
			  }
          else stPoolingPump=pwInitDelayNextPump;
	      break;
     case pwUpdatePumpStatus:
	      PumpAddr=txPumpID;
    2344:	80 91 17 01 	lds	r24, 0x0117
    2348:	80 93 05 01 	sts	0x0105, r24
	 	  if (PumpStatus[PumpAddr]!=zPumpStatus[PumpAddr]){
    234c:	90 e0       	ldi	r25, 0x00	; 0
    234e:	fc 01       	movw	r30, r24
    2350:	eb 54       	subi	r30, 0x4B	; 75
    2352:	fc 4f       	sbci	r31, 0xFC	; 252
    2354:	e0 81       	ld	r30, Z
    2356:	dc 01       	movw	r26, r24
    2358:	a5 56       	subi	r26, 0x65	; 101
    235a:	bd 4f       	sbci	r27, 0xFD	; 253
    235c:	8c 91       	ld	r24, X
    235e:	e8 17       	cp	r30, r24
    2360:	79 f0       	breq	.+30     	; 0x2380 <FPoolingPump2+0x282>
		      zPumpStatus[PumpAddr]=PumpStatus[PumpAddr];
    2362:	ec 93       	st	X, r30
		      stPoolingPump=pwSendPumpStatus;
    2364:	86 e0       	ldi	r24, 0x06	; 6
    2366:	18 c2       	rjmp	.+1072   	; 0x2798 <FPoolingPump2+0x69a>
		  }else stPoolingPump=pwNextAction;
	      break;
     case pwSendPumpStatus:
          PumpAddr=txPumpID;
    2368:	80 91 17 01 	lds	r24, 0x0117
    236c:	80 93 05 01 	sts	0x0105, r24
	      SendPumpStatusFlow(txPumpID+1,PumpStatus[PumpAddr]);
    2370:	e8 2f       	mov	r30, r24
    2372:	f0 e0       	ldi	r31, 0x00	; 0
    2374:	eb 54       	subi	r30, 0x4B	; 75
    2376:	fc 4f       	sbci	r31, 0xFC	; 252
    2378:	8f 5f       	subi	r24, 0xFF	; 255
    237a:	60 81       	ld	r22, Z
    237c:	0e 94 c8 06 	call	0xd90	; 0xd90 <SendPumpStatusFlow>
		  //sprintf_P(strSend,PSTR("WR:%d MI:%d"),WayneReply,MsgInfo);
		  //_uart_print(1,1,strSend);
	      stPoolingPump=pwNextAction;
    2380:	87 e0       	ldi	r24, 0x07	; 7
    2382:	0a c2       	rjmp	.+1044   	; 0x2798 <FPoolingPump2+0x69a>
	      break;
     case pwNextAction:
	      //Switch Action Based Pump State
		  PumpAddr=txPumpID;
    2384:	80 91 17 01 	lds	r24, 0x0117
    2388:	80 93 05 01 	sts	0x0105, r24
		  switch(PumpStatus[PumpAddr]){
    238c:	a8 2f       	mov	r26, r24
    238e:	b0 e0       	ldi	r27, 0x00	; 0
    2390:	fd 01       	movw	r30, r26
    2392:	eb 54       	subi	r30, 0x4B	; 75
    2394:	fc 4f       	sbci	r31, 0xFC	; 252
    2396:	80 81       	ld	r24, Z
    2398:	87 30       	cpi	r24, 0x07	; 7
    239a:	09 f4       	brne	.+2      	; 0x239e <FPoolingPump2+0x2a0>
    239c:	6e c0       	rjmp	.+220    	; 0x247a <FPoolingPump2+0x37c>
    239e:	88 30       	cpi	r24, 0x08	; 8
    23a0:	20 f4       	brcc	.+8      	; 0x23aa <FPoolingPump2+0x2ac>
    23a2:	86 30       	cpi	r24, 0x06	; 6
    23a4:	09 f0       	breq	.+2      	; 0x23a8 <FPoolingPump2+0x2aa>
    23a6:	fd c1       	rjmp	.+1018   	; 0x27a2 <FPoolingPump2+0x6a4>
    23a8:	1e c0       	rjmp	.+60     	; 0x23e6 <FPoolingPump2+0x2e8>
    23aa:	89 30       	cpi	r24, 0x09	; 9
    23ac:	09 f4       	brne	.+2      	; 0x23b0 <FPoolingPump2+0x2b2>
    23ae:	68 c0       	rjmp	.+208    	; 0x2480 <FPoolingPump2+0x382>
    23b0:	8e 30       	cpi	r24, 0x0E	; 14
    23b2:	09 f0       	breq	.+2      	; 0x23b6 <FPoolingPump2+0x2b8>
    23b4:	f6 c1       	rjmp	.+1004   	; 0x27a2 <FPoolingPump2+0x6a4>
		  case PW_DISCONNECT:
		       switch(WayneReply){
    23b6:	80 91 1a 01 	lds	r24, 0x011A
    23ba:	88 23       	and	r24, r24
    23bc:	09 f4       	brne	.+2      	; 0x23c0 <FPoolingPump2+0x2c2>
    23be:	36 c1       	rjmp	.+620    	; 0x262c <FPoolingPump2+0x52e>
    23c0:	84 30       	cpi	r24, 0x04	; 4
    23c2:	09 f0       	breq	.+2      	; 0x23c6 <FPoolingPump2+0x2c8>
    23c4:	ee c1       	rjmp	.+988    	; 0x27a2 <FPoolingPump2+0x6a4>
			   case WR_MESSAGE:
			        switch(MsgInfo){
    23c6:	80 91 19 01 	lds	r24, 0x0119
    23ca:	83 30       	cpi	r24, 0x03	; 3
    23cc:	39 f0       	breq	.+14     	; 0x23dc <FPoolingPump2+0x2de>
    23ce:	88 30       	cpi	r24, 0x08	; 8
    23d0:	09 f4       	brne	.+2      	; 0x23d4 <FPoolingPump2+0x2d6>
    23d2:	aa c1       	rjmp	.+852    	; 0x2728 <FPoolingPump2+0x62a>
    23d4:	82 30       	cpi	r24, 0x02	; 2
    23d6:	09 f0       	breq	.+2      	; 0x23da <FPoolingPump2+0x2dc>
    23d8:	a7 c1       	rjmp	.+846    	; 0x2728 <FPoolingPump2+0x62a>
    23da:	31 c0       	rjmp	.+98     	; 0x243e <FPoolingPump2+0x340>
					case MI_NOZZLE_DOWN:
						 IsRequestTransInfo[txPumpID]=True;
    23dc:	a6 57       	subi	r26, 0x76	; 118
    23de:	bd 4f       	sbci	r27, 0xFD	; 253
    23e0:	81 e0       	ldi	r24, 0x01	; 1
    23e2:	8c 93       	st	X, r24
    23e4:	a1 c1       	rjmp	.+834    	; 0x2728 <FPoolingPump2+0x62a>
			   }
		       break;
          case PW_ONLINE:
		       //sprintf_P(strSend,PSTR("ONLine:%d"),WayneReply);
			   //_uart_print(1,1,strSend);
		       switch(WayneReply){
    23e6:	80 91 1a 01 	lds	r24, 0x011A
    23ea:	81 30       	cpi	r24, 0x01	; 1
    23ec:	21 f0       	breq	.+8      	; 0x23f6 <FPoolingPump2+0x2f8>
    23ee:	84 30       	cpi	r24, 0x04	; 4
    23f0:	09 f0       	breq	.+2      	; 0x23f4 <FPoolingPump2+0x2f6>
    23f2:	d7 c1       	rjmp	.+942    	; 0x27a2 <FPoolingPump2+0x6a4>
    23f4:	14 c0       	rjmp	.+40     	; 0x241e <FPoolingPump2+0x320>
			   case WR_READY:
			        if (IsRequestTransInfo[txPumpID]==True){
    23f6:	fd 01       	movw	r30, r26
    23f8:	e6 57       	subi	r30, 0x76	; 118
    23fa:	fd 4f       	sbci	r31, 0xFD	; 253
    23fc:	80 81       	ld	r24, Z
    23fe:	81 30       	cpi	r24, 0x01	; 1
    2400:	29 f4       	brne	.+10     	; 0x240c <FPoolingPump2+0x30e>
					    iSend=0;
    2402:	10 92 f9 03 	sts	0x03F9, r1
					    stPoolingPump=pwSendTransactionRequest;
    2406:	8e e0       	ldi	r24, 0x0E	; 14
    2408:	80 93 31 01 	sts	0x0131, r24
					}if (IsRequestTotalizerInfo[txPumpID]==True){
    240c:	ad 5e       	subi	r26, 0xED	; 237
    240e:	bb 4f       	sbci	r27, 0xFB	; 251
    2410:	8c 91       	ld	r24, X
    2412:	81 30       	cpi	r24, 0x01	; 1
    2414:	09 f0       	breq	.+2      	; 0x2418 <FPoolingPump2+0x31a>
    2416:	0a c1       	rjmp	.+532    	; 0x262c <FPoolingPump2+0x52e>
					    iSend=0;
    2418:	10 92 f9 03 	sts	0x03F9, r1
    241c:	29 c0       	rjmp	.+82     	; 0x2470 <FPoolingPump2+0x372>
						stPoolingPump=pwSendTotalizerRequest;
					}else stPoolingPump=pwInitDelayNextPump;

			        break;
			   case WR_MESSAGE:
			        switch(MsgInfo){
    241e:	80 91 19 01 	lds	r24, 0x0119
    2422:	83 30       	cpi	r24, 0x03	; 3
    2424:	c9 f0       	breq	.+50     	; 0x2458 <FPoolingPump2+0x35a>
    2426:	84 30       	cpi	r24, 0x04	; 4
    2428:	20 f4       	brcc	.+8      	; 0x2432 <FPoolingPump2+0x334>
    242a:	82 30       	cpi	r24, 0x02	; 2
    242c:	09 f0       	breq	.+2      	; 0x2430 <FPoolingPump2+0x332>
    242e:	b9 c1       	rjmp	.+882    	; 0x27a2 <FPoolingPump2+0x6a4>
    2430:	06 c0       	rjmp	.+12     	; 0x243e <FPoolingPump2+0x340>
    2432:	86 30       	cpi	r24, 0x06	; 6
    2434:	49 f0       	breq	.+18     	; 0x2448 <FPoolingPump2+0x34a>
    2436:	88 30       	cpi	r24, 0x08	; 8
    2438:	09 f0       	breq	.+2      	; 0x243c <FPoolingPump2+0x33e>
    243a:	b3 c1       	rjmp	.+870    	; 0x27a2 <FPoolingPump2+0x6a4>
    243c:	12 c0       	rjmp	.+36     	; 0x2462 <FPoolingPump2+0x364>
					case MI_NOZZLE_UP:
					     PumpStatus[PumpAddr]=PW_CALL;
    243e:	87 e0       	ldi	r24, 0x07	; 7
    2440:	80 83       	st	Z, r24
						 iAuthCmd=0;
    2442:	10 92 2e 01 	sts	0x012E, r1
    2446:	72 c1       	rjmp	.+740    	; 0x272c <FPoolingPump2+0x62e>
						 stPoolingPump=pwUpdatePumpStatus;
					     break;
					case MI_LAST_TRANSACTION:
                         if (IsRequestTransInfo[txPumpID]==True)
    2448:	a6 57       	subi	r26, 0x76	; 118
    244a:	bd 4f       	sbci	r27, 0xFD	; 253
    244c:	8c 91       	ld	r24, X
    244e:	81 30       	cpi	r24, 0x01	; 1
    2450:	09 f0       	breq	.+2      	; 0x2454 <FPoolingPump2+0x356>
    2452:	ec c0       	rjmp	.+472    	; 0x262c <FPoolingPump2+0x52e>
						     stPoolingPump=pwSendTransMessage;
    2454:	81 e1       	ldi	r24, 0x11	; 17
    2456:	a0 c1       	rjmp	.+832    	; 0x2798 <FPoolingPump2+0x69a>
                         else stPoolingPump=pwInitDelayNextPump;
					     break;
					case MI_NOZZLE_DOWN:
                         IsRequestTransInfo[txPumpID]=True;
    2458:	a6 57       	subi	r26, 0x76	; 118
    245a:	bd 4f       	sbci	r27, 0xFD	; 253
    245c:	81 e0       	ldi	r24, 0x01	; 1
    245e:	8c 93       	st	X, r24
    2460:	e5 c0       	rjmp	.+458    	; 0x262c <FPoolingPump2+0x52e>
						 stPoolingPump=pwInitDelayNextPump;
					     break;
                    case MI_TOTALIZER:
					     if (ActiveNozzle<4){
    2462:	80 91 1c 01 	lds	r24, 0x011C
    2466:	84 30       	cpi	r24, 0x04	; 4
    2468:	30 f4       	brcc	.+12     	; 0x2476 <FPoolingPump2+0x378>
						     iSend=0;
    246a:	10 92 f9 03 	sts	0x03F9, r1
						     ActiveNozzle++;
    246e:	8f 5f       	subi	r24, 0xFF	; 255
    2470:	80 93 1c 01 	sts	0x011C, r24
    2474:	be c0       	rjmp	.+380    	; 0x25f2 <FPoolingPump2+0x4f4>
						     stPoolingPump=pwSendTotalizerRequest;
						 }else stPoolingPump=pwSendTotalizerInfo;
    2476:	8c e0       	ldi	r24, 0x0C	; 12
    2478:	8f c1       	rjmp	.+798    	; 0x2798 <FPoolingPump2+0x69a>
			   case WR_NACK:
			        break;
			   }
		       break;
          case PW_CALL:
		       iSend=0; 
    247a:	10 92 f9 03 	sts	0x03F9, r1
    247e:	34 c1       	rjmp	.+616    	; 0x26e8 <FPoolingPump2+0x5ea>
			   stPoolingPump=pwSendAuthorizeCommand;               			   
		       break;
           
          case PW_AUTHORIZED:
               if (WayneReply==WR_READY){
    2480:	80 91 1a 01 	lds	r24, 0x011A
    2484:	81 30       	cpi	r24, 0x01	; 1
    2486:	09 f4       	brne	.+2      	; 0x248a <FPoolingPump2+0x38c>
    2488:	d1 c0       	rjmp	.+418    	; 0x262c <FPoolingPump2+0x52e>
			           stPoolingPump=pwInitDelayNextPump;
			   }else if (WayneReply==WR_MESSAGE){
    248a:	80 91 1a 01 	lds	r24, 0x011A
    248e:	84 30       	cpi	r24, 0x04	; 4
    2490:	09 f0       	breq	.+2      	; 0x2494 <FPoolingPump2+0x396>
    2492:	87 c1       	rjmp	.+782    	; 0x27a2 <FPoolingPump2+0x6a4>
			       if (MsgInfo==MI_NOZZLE_DOWN){
    2494:	80 91 19 01 	lds	r24, 0x0119
    2498:	83 30       	cpi	r24, 0x03	; 3
    249a:	09 f0       	breq	.+2      	; 0x249e <FPoolingPump2+0x3a0>
    249c:	7a c1       	rjmp	.+756    	; 0x2792 <FPoolingPump2+0x694>
				       PumpStatus[PumpAddr]=PW_ONLINE;
    249e:	86 e0       	ldi	r24, 0x06	; 6
    24a0:	80 83       	st	Z, r24
					   iSend=0;
    24a2:	10 92 f9 03 	sts	0x03F9, r1
    24a6:	3a c0       	rjmp	.+116    	; 0x251c <FPoolingPump2+0x41e>
	      break;
     //Request last Transaction
	 case pwSendTransactionRequest:	 
	      //sprintf_P(strSend,PSTR("Last Transcation"));
		  //_uart_print(1,1,strSend);
		  FWayneSendCommand(CMD_TRANSACTION,CommandSeqID[txPumpID],txPumpID,ActiveNozzle);          
    24a8:	40 91 17 01 	lds	r20, 0x0117
    24ac:	e4 2f       	mov	r30, r20
    24ae:	f0 e0       	ldi	r31, 0x00	; 0
    24b0:	ee 57       	subi	r30, 0x7E	; 126
    24b2:	fd 4f       	sbci	r31, 0xFD	; 253
    24b4:	8e e0       	ldi	r24, 0x0E	; 14
    24b6:	60 81       	ld	r22, Z
    24b8:	20 91 1c 01 	lds	r18, 0x011C
    24bc:	0e 94 53 07 	call	0xea6	; 0xea6 <FWayneSendCommand>
		  TimSend=0;
    24c0:	10 92 24 04 	sts	0x0424, r1
    24c4:	10 92 23 04 	sts	0x0423, r1
          stPoolingPump=pwWaitTransACK;
    24c8:	8f e0       	ldi	r24, 0x0F	; 15
    24ca:	66 c1       	rjmp	.+716    	; 0x2798 <FPoolingPump2+0x69a>
	      break;
     case pwWaitTransACK:
	 	  //Timeout->NoPump		  
          if (TimSend>TPoolTimeout){
    24cc:	80 91 b6 02 	lds	r24, 0x02B6
    24d0:	90 e0       	ldi	r25, 0x00	; 0
    24d2:	20 91 23 04 	lds	r18, 0x0423
    24d6:	30 91 24 04 	lds	r19, 0x0424
    24da:	82 17       	cp	r24, r18
    24dc:	93 07       	cpc	r25, r19
    24de:	18 f4       	brcc	.+6      	; 0x24e6 <FPoolingPump2+0x3e8>
		      stPoolingPump=pwRetrySendTransRequest;
    24e0:	80 e1       	ldi	r24, 0x10	; 16
    24e2:	80 93 31 01 	sts	0x0131, r24
		  }
          //Acknowledge
	      if (WayneReply==WR_ACK){
    24e6:	90 91 1a 01 	lds	r25, 0x011A
    24ea:	92 30       	cpi	r25, 0x02	; 2
    24ec:	09 f4       	brne	.+2      	; 0x24f0 <FPoolingPump2+0x3f2>
    24ee:	60 c0       	rjmp	.+192    	; 0x25b0 <FPoolingPump2+0x4b2>
		      CommandSeqID[txPumpID]++;
			  //stPoolingPump=pwSendTransMessage;
			  stPoolingPump=pwScanStatus;
		  }else if (WayneReply==WR_NACK){
    24f0:	80 91 1a 01 	lds	r24, 0x011A
    24f4:	83 30       	cpi	r24, 0x03	; 3
    24f6:	09 f0       	breq	.+2      	; 0x24fa <FPoolingPump2+0x3fc>
    24f8:	54 c1       	rjmp	.+680    	; 0x27a2 <FPoolingPump2+0x6a4>
		      CommandSeqID[txPumpID]=0;
    24fa:	e0 91 17 01 	lds	r30, 0x0117
    24fe:	f0 e0       	ldi	r31, 0x00	; 0
    2500:	ee 57       	subi	r30, 0x7E	; 126
    2502:	fd 4f       	sbci	r31, 0xFD	; 253
    2504:	10 82       	st	Z, r1
    2506:	0a c0       	rjmp	.+20     	; 0x251c <FPoolingPump2+0x41e>
              stPoolingPump=pwSendTransactionRequest;
		  }
	      break;
     case pwRetrySendTransRequest:
	      iSend++;
    2508:	80 91 f9 03 	lds	r24, 0x03F9
    250c:	8f 5f       	subi	r24, 0xFF	; 255
    250e:	80 93 f9 03 	sts	0x03F9, r24
		  if (iSend<nSend)stPoolingPump=pwSendTransactionRequest;
    2512:	90 91 77 02 	lds	r25, 0x0277
    2516:	89 17       	cp	r24, r25
    2518:	08 f0       	brcs	.+2      	; 0x251c <FPoolingPump2+0x41e>
    251a:	e8 c0       	rjmp	.+464    	; 0x26ec <FPoolingPump2+0x5ee>
    251c:	8e e0       	ldi	r24, 0x0E	; 14
    251e:	3c c1       	rjmp	.+632    	; 0x2798 <FPoolingPump2+0x69a>
		  else
		  if (iSend>=nSend)stPoolingPump=pwNoPump;
	      break;

     case pwSendTransMessage:
          rxPumpId=txPumpID;
    2520:	60 91 17 01 	lds	r22, 0x0117
    2524:	60 93 3b 01 	sts	0x013B, r22
		  NozzleId=ActiveNozzle;
    2528:	20 91 1c 01 	lds	r18, 0x011C
    252c:	20 93 e0 02 	sts	0x02E0, r18
		  GradeId=ActiveNozzle;
    2530:	20 93 f6 02 	sts	0x02F6, r18
		  PumpTransDigit=6;
    2534:	86 e0       	ldi	r24, 0x06	; 6
    2536:	80 93 0b 01 	sts	0x010B, r24
	      SendTransFlow(txPumpID+1,rxPumpId+1,NozzleId,GradeId,strUnitPrice,strVolume,strAmount,PumpTransDigit);
    253a:	6f 5f       	subi	r22, 0xFF	; 255
    253c:	86 2f       	mov	r24, r22
    253e:	42 2f       	mov	r20, r18
    2540:	0c ea       	ldi	r16, 0xAC	; 172
    2542:	12 e0       	ldi	r17, 0x02	; 2
    2544:	e7 e5       	ldi	r30, 0x57	; 87
    2546:	ee 2e       	mov	r14, r30
    2548:	e2 e0       	ldi	r30, 0x02	; 2
    254a:	fe 2e       	mov	r15, r30
    254c:	7b ea       	ldi	r23, 0xAB	; 171
    254e:	c7 2e       	mov	r12, r23
    2550:	73 e0       	ldi	r23, 0x03	; 3
    2552:	d7 2e       	mov	r13, r23
    2554:	56 e0       	ldi	r21, 0x06	; 6
    2556:	a5 2e       	mov	r10, r21
    2558:	0e 94 bd 0c 	call	0x197a	; 0x197a <SendTransFlow>
		  IsRequestTransInfo[txPumpID]=False;
    255c:	e0 91 17 01 	lds	r30, 0x0117
    2560:	f0 e0       	ldi	r31, 0x00	; 0
    2562:	e6 57       	subi	r30, 0x76	; 118
    2564:	fd 4f       	sbci	r31, 0xFD	; 253
    2566:	10 82       	st	Z, r1
    2568:	61 c0       	rjmp	.+194    	; 0x262c <FPoolingPump2+0x52e>
		  //IsRequestTotalizerInfo[txPumpID]=True;
          stPoolingPump=pwInitDelayNextPump;
	      break; 
	 //Totalizer
	 case pwSendTotalizerRequest:
	      FWayneSendCommand(CMD_TOTALIZER,CommandSeqID[txPumpID],txPumpID,ActiveNozzle);          
    256a:	40 91 17 01 	lds	r20, 0x0117
    256e:	e4 2f       	mov	r30, r20
    2570:	f0 e0       	ldi	r31, 0x00	; 0
    2572:	ee 57       	subi	r30, 0x7E	; 126
    2574:	fd 4f       	sbci	r31, 0xFD	; 253
    2576:	85 e0       	ldi	r24, 0x05	; 5
    2578:	60 81       	ld	r22, Z
    257a:	20 91 1c 01 	lds	r18, 0x011C
    257e:	0e 94 53 07 	call	0xea6	; 0xea6 <FWayneSendCommand>
		  TimSend=0;
    2582:	10 92 24 04 	sts	0x0424, r1
    2586:	10 92 23 04 	sts	0x0423, r1
          stPoolingPump=pwWaitTotalizerACK;
    258a:	8a e0       	ldi	r24, 0x0A	; 10
    258c:	05 c1       	rjmp	.+522    	; 0x2798 <FPoolingPump2+0x69a>
	      break;
     case pwWaitTotalizerACK:
	       //Timeout->NoPump		  
          if (TimSend>TPoolTimeout){
    258e:	80 91 b6 02 	lds	r24, 0x02B6
    2592:	90 e0       	ldi	r25, 0x00	; 0
    2594:	20 91 23 04 	lds	r18, 0x0423
    2598:	30 91 24 04 	lds	r19, 0x0424
    259c:	82 17       	cp	r24, r18
    259e:	93 07       	cpc	r25, r19
    25a0:	18 f4       	brcc	.+6      	; 0x25a8 <FPoolingPump2+0x4aa>
		      stPoolingPump=pwRetrySendTotalizerRequest;
    25a2:	8b e0       	ldi	r24, 0x0B	; 11
    25a4:	80 93 31 01 	sts	0x0131, r24
		  }
          //Acknowledge
	      if (WayneReply==WR_ACK){
    25a8:	90 91 1a 01 	lds	r25, 0x011A
    25ac:	92 30       	cpi	r25, 0x02	; 2
    25ae:	59 f4       	brne	.+22     	; 0x25c6 <FPoolingPump2+0x4c8>
		      CommandSeqID[txPumpID]++;
    25b0:	e0 91 17 01 	lds	r30, 0x0117
    25b4:	f0 e0       	ldi	r31, 0x00	; 0
    25b6:	ee 57       	subi	r30, 0x7E	; 126
    25b8:	fd 4f       	sbci	r31, 0xFD	; 253
    25ba:	80 81       	ld	r24, Z
    25bc:	8f 5f       	subi	r24, 0xFF	; 255
    25be:	80 83       	st	Z, r24
			  stPoolingPump=pwScanStatus;
    25c0:	90 93 31 01 	sts	0x0131, r25
    25c4:	ee c0       	rjmp	.+476    	; 0x27a2 <FPoolingPump2+0x6a4>
		  }else if (WayneReply==WR_NACK){
    25c6:	80 91 1a 01 	lds	r24, 0x011A
    25ca:	83 30       	cpi	r24, 0x03	; 3
    25cc:	09 f0       	breq	.+2      	; 0x25d0 <FPoolingPump2+0x4d2>
    25ce:	e9 c0       	rjmp	.+466    	; 0x27a2 <FPoolingPump2+0x6a4>
		      CommandSeqID[txPumpID]=0;
    25d0:	e0 91 17 01 	lds	r30, 0x0117
    25d4:	f0 e0       	ldi	r31, 0x00	; 0
    25d6:	ee 57       	subi	r30, 0x7E	; 126
    25d8:	fd 4f       	sbci	r31, 0xFD	; 253
    25da:	10 82       	st	Z, r1
    25dc:	0a c0       	rjmp	.+20     	; 0x25f2 <FPoolingPump2+0x4f4>
              stPoolingPump=pwSendTotalizerRequest;
		  }
	      break;
     case pwRetrySendTotalizerRequest:
	      iSend++;
    25de:	80 91 f9 03 	lds	r24, 0x03F9
    25e2:	8f 5f       	subi	r24, 0xFF	; 255
    25e4:	80 93 f9 03 	sts	0x03F9, r24
		  if (iSend<nSend)stPoolingPump=pwSendTotalizerRequest;
    25e8:	90 91 77 02 	lds	r25, 0x0277
    25ec:	89 17       	cp	r24, r25
    25ee:	08 f0       	brcs	.+2      	; 0x25f2 <FPoolingPump2+0x4f4>
    25f0:	7d c0       	rjmp	.+250    	; 0x26ec <FPoolingPump2+0x5ee>
    25f2:	89 e0       	ldi	r24, 0x09	; 9
    25f4:	d1 c0       	rjmp	.+418    	; 0x2798 <FPoolingPump2+0x69a>
		  else
		  if (iSend>=nSend)stPoolingPump=pwNoPump;
	      break;
     case pwSendTotalizerInfo:
	      PumpTotalDigit=10;
    25f6:	8a e0       	ldi	r24, 0x0A	; 10
    25f8:	80 93 0c 01 	sts	0x010C, r24
	      SendTotalizerFlow(txPumpID+1);
    25fc:	80 91 17 01 	lds	r24, 0x0117
    2600:	8f 5f       	subi	r24, 0xFF	; 255
    2602:	0e 94 c5 0b 	call	0x178a	; 0x178a <SendTotalizerFlow>
		  IsTotalizerACK=False;//True;//
    2606:	10 92 14 01 	sts	0x0114, r1
		  stPoolingPump=pwWaitTotalizerInfoACK;
    260a:	8d e0       	ldi	r24, 0x0D	; 13
    260c:	c5 c0       	rjmp	.+394    	; 0x2798 <FPoolingPump2+0x69a>
	      break;
     case pwWaitTotalizerInfoACK:
	      if (IsTotalizerACK==True){//SC_TOTALIZER_ACK
    260e:	80 91 14 01 	lds	r24, 0x0114
    2612:	81 30       	cpi	r24, 0x01	; 1
    2614:	09 f0       	breq	.+2      	; 0x2618 <FPoolingPump2+0x51a>
    2616:	c5 c0       	rjmp	.+394    	; 0x27a2 <FPoolingPump2+0x6a4>
              IsRequestTotalizerInfo[PumpAddr]=False;
    2618:	e0 91 05 01 	lds	r30, 0x0105
    261c:	f0 e0       	ldi	r31, 0x00	; 0
    261e:	ed 5e       	subi	r30, 0xED	; 237
    2620:	fb 4f       	sbci	r31, 0xFB	; 251
    2622:	10 82       	st	Z, r1
	          TimDelayNextPump=0;
    2624:	10 92 22 01 	sts	0x0122, r1
    2628:	10 92 21 01 	sts	0x0121, r1
		      stPoolingPump=pwInitDelayNextPump;
    262c:	89 e1       	ldi	r24, 0x19	; 25
    262e:	b4 c0       	rjmp	.+360    	; 0x2798 <FPoolingPump2+0x69a>
     case pwSendAuthorizeCommand:
	      #ifdef DEBUG_WAYNE_STATE 
		  sprintf_P(strSend,PSTR("Authorize%d"),iAuthCmd+1);
		  _uart_print(1,1,strSend);
		  #endif
		  FWayneSendCommand((CMD_AUTH_1+iAuthCmd),CommandSeqID[txPumpID],txPumpID,ActiveNozzle);          
    2630:	40 91 17 01 	lds	r20, 0x0117
    2634:	80 91 2e 01 	lds	r24, 0x012E
    2638:	e4 2f       	mov	r30, r20
    263a:	f0 e0       	ldi	r31, 0x00	; 0
    263c:	ee 57       	subi	r30, 0x7E	; 126
    263e:	fd 4f       	sbci	r31, 0xFD	; 253
    2640:	86 5f       	subi	r24, 0xF6	; 246
    2642:	60 81       	ld	r22, Z
    2644:	20 91 1c 01 	lds	r18, 0x011C
    2648:	0e 94 53 07 	call	0xea6	; 0xea6 <FWayneSendCommand>
		  TimSend=0;
    264c:	10 92 24 04 	sts	0x0424, r1
    2650:	10 92 23 04 	sts	0x0423, r1
          stPoolingPump=pwWaitAuthACK;
    2654:	83 e1       	ldi	r24, 0x13	; 19
    2656:	a0 c0       	rjmp	.+320    	; 0x2798 <FPoolingPump2+0x69a>
	      break;
     case pwWaitAuthACK:
	 	  //Timeout->NoPump		  
          if (TimSend>TPoolTimeout){
    2658:	80 91 b6 02 	lds	r24, 0x02B6
    265c:	90 e0       	ldi	r25, 0x00	; 0
    265e:	20 91 23 04 	lds	r18, 0x0423
    2662:	30 91 24 04 	lds	r19, 0x0424
    2666:	82 17       	cp	r24, r18
    2668:	93 07       	cpc	r25, r19
    266a:	18 f4       	brcc	.+6      	; 0x2672 <FPoolingPump2+0x574>
		      stPoolingPump=pwRetrySendAuthorizeCommand;
    266c:	84 e1       	ldi	r24, 0x14	; 20
    266e:	80 93 31 01 	sts	0x0131, r24
		  }		  
	      //Acknowledge
	      if (WayneReply==WR_ACK){
    2672:	20 91 1a 01 	lds	r18, 0x011A
    2676:	22 30       	cpi	r18, 0x02	; 2
    2678:	09 f5       	brne	.+66     	; 0x26bc <FPoolingPump2+0x5be>
		      iAuthCmd++;
    267a:	80 91 2e 01 	lds	r24, 0x012E
    267e:	8f 5f       	subi	r24, 0xFF	; 255
    2680:	80 93 2e 01 	sts	0x012E, r24
    2684:	90 91 17 01 	lds	r25, 0x0117
			  if (iAuthCmd>=4){//Complete ACK
    2688:	84 30       	cpi	r24, 0x04	; 4
    268a:	80 f0       	brcs	.+32     	; 0x26ac <FPoolingPump2+0x5ae>
			      PumpStatus[PumpAddr]=PW_AUTHORIZED;
    268c:	e0 91 05 01 	lds	r30, 0x0105
    2690:	f0 e0       	ldi	r31, 0x00	; 0
    2692:	eb 54       	subi	r30, 0x4B	; 75
    2694:	fc 4f       	sbci	r31, 0xFC	; 252
    2696:	89 e0       	ldi	r24, 0x09	; 9
    2698:	80 83       	st	Z, r24
				  IsRequestTransInfo[txPumpID]=True;
    269a:	e9 2f       	mov	r30, r25
    269c:	f0 e0       	ldi	r31, 0x00	; 0
    269e:	e6 57       	subi	r30, 0x76	; 118
    26a0:	fd 4f       	sbci	r31, 0xFD	; 253
    26a2:	81 e0       	ldi	r24, 0x01	; 1
    26a4:	80 83       	st	Z, r24
			      stPoolingPump=pwScanStatus;
    26a6:	20 93 31 01 	sts	0x0131, r18
    26aa:	7b c0       	rjmp	.+246    	; 0x27a2 <FPoolingPump2+0x6a4>
			  }else {
			   CommandSeqID[txPumpID]++;
    26ac:	e9 2f       	mov	r30, r25
    26ae:	f0 e0       	ldi	r31, 0x00	; 0
    26b0:	ee 57       	subi	r30, 0x7E	; 126
    26b2:	fd 4f       	sbci	r31, 0xFD	; 253
    26b4:	80 81       	ld	r24, Z
    26b6:	8f 5f       	subi	r24, 0xFF	; 255
    26b8:	80 83       	st	Z, r24
    26ba:	16 c0       	rjmp	.+44     	; 0x26e8 <FPoolingPump2+0x5ea>
			   stPoolingPump=pwSendAuthorizeCommand;
			   }
		  }else if (WayneReply==WR_NACK){
    26bc:	80 91 1a 01 	lds	r24, 0x011A
    26c0:	83 30       	cpi	r24, 0x03	; 3
    26c2:	09 f0       	breq	.+2      	; 0x26c6 <FPoolingPump2+0x5c8>
    26c4:	6e c0       	rjmp	.+220    	; 0x27a2 <FPoolingPump2+0x6a4>
		      CommandSeqID[txPumpID]=0;
    26c6:	e0 91 17 01 	lds	r30, 0x0117
    26ca:	f0 e0       	ldi	r31, 0x00	; 0
    26cc:	ee 57       	subi	r30, 0x7E	; 126
    26ce:	fd 4f       	sbci	r31, 0xFD	; 253
    26d0:	10 82       	st	Z, r1
              stPoolingPump=pwRetrySendAuthorizeCommand;
    26d2:	84 e1       	ldi	r24, 0x14	; 20
    26d4:	61 c0       	rjmp	.+194    	; 0x2798 <FPoolingPump2+0x69a>
		  }
	      break;
     case pwRetrySendAuthorizeCommand:
	      iSend++;
    26d6:	80 91 f9 03 	lds	r24, 0x03F9
    26da:	8f 5f       	subi	r24, 0xFF	; 255
    26dc:	80 93 f9 03 	sts	0x03F9, r24
		  if (iSend<nSend)stPoolingPump=pwSendAuthorizeCommand;
    26e0:	90 91 77 02 	lds	r25, 0x0277
    26e4:	89 17       	cp	r24, r25
    26e6:	10 f4       	brcc	.+4      	; 0x26ec <FPoolingPump2+0x5ee>
    26e8:	82 e1       	ldi	r24, 0x12	; 18
    26ea:	56 c0       	rjmp	.+172    	; 0x2798 <FPoolingPump2+0x69a>
		  else
		  if (iSend>=nSend)stPoolingPump=pwNoPump;
    26ec:	84 e0       	ldi	r24, 0x04	; 4
    26ee:	54 c0       	rjmp	.+168    	; 0x2798 <FPoolingPump2+0x69a>
	 case pwSendGeneralStatus:
	      
	      break;
	 //Price Config	  
	 case pwSendPriceConfig:
	      stPoolingPump=pwWaitACK; 
    26f0:	86 e1       	ldi	r24, 0x16	; 22
    26f2:	52 c0       	rjmp	.+164    	; 0x2798 <FPoolingPump2+0x69a>
	      break;
	 case pwWaitACK:
	      PumpStatus[PumpAddr]=PW_PRICE_UPDATED;
    26f4:	e0 91 05 01 	lds	r30, 0x0105
    26f8:	f0 e0       	ldi	r31, 0x00	; 0
    26fa:	eb 54       	subi	r30, 0x4B	; 75
    26fc:	fc 4f       	sbci	r31, 0xFC	; 252
    26fe:	8f e0       	ldi	r24, 0x0F	; 15
    2700:	14 c0       	rjmp	.+40     	; 0x272a <FPoolingPump2+0x62c>
		  stPoolingPump=pwUpdatePumpStatus;
          break;	 
	 //Acknowledge--------------
	 case pwReplyACK:
	      FWayneSendCommand(CMD_ACK,WayneRxSequence,txPumpID,0);
    2702:	87 e0       	ldi	r24, 0x07	; 7
    2704:	60 91 18 01 	lds	r22, 0x0118
    2708:	40 91 17 01 	lds	r20, 0x0117
    270c:	20 e0       	ldi	r18, 0x00	; 0
    270e:	0e 94 53 07 	call	0xea6	; 0xea6 <FWayneSendCommand>
		  stPoolingPump=pwScanMessage;
    2712:	88 e1       	ldi	r24, 0x18	; 24
    2714:	41 c0       	rjmp	.+130    	; 0x2798 <FPoolingPump2+0x69a>
	      break;	 
	 case pwScanMessage:
	      if (PumpStatus[txPumpID]==PW_NONE){
    2716:	80 91 17 01 	lds	r24, 0x0117
    271a:	e8 2f       	mov	r30, r24
    271c:	f0 e0       	ldi	r31, 0x00	; 0
    271e:	eb 54       	subi	r30, 0x4B	; 75
    2720:	fc 4f       	sbci	r31, 0xFC	; 252
    2722:	80 81       	ld	r24, Z
    2724:	88 23       	and	r24, r24
    2726:	11 f4       	brne	.+4      	; 0x272c <FPoolingPump2+0x62e>
			  PumpStatus[txPumpID]=PW_ONLINE;
    2728:	86 e0       	ldi	r24, 0x06	; 6
    272a:	80 83       	st	Z, r24
		  }		  
	      stPoolingPump=pwUpdatePumpStatus;
    272c:	85 e0       	ldi	r24, 0x05	; 5
    272e:	34 c0       	rjmp	.+104    	; 0x2798 <FPoolingPump2+0x69a>
	      break;		  
		  		 		  
     //Next Pump----------------
     case pwInitDelayNextPump:
	      TimDelayNextPump=0;
    2730:	10 92 22 01 	sts	0x0122, r1
    2734:	10 92 21 01 	sts	0x0121, r1
          stPoolingPump=pwDelayNextPump;
    2738:	8a e1       	ldi	r24, 0x1A	; 26
    273a:	2e c0       	rjmp	.+92     	; 0x2798 <FPoolingPump2+0x69a>
	      break;
     case pwDelayNextPump:
	      if (TimDelayNextPump>=TDelayNextPump)//20
    273c:	80 91 3c 01 	lds	r24, 0x013C
    2740:	90 e0       	ldi	r25, 0x00	; 0
    2742:	20 91 21 01 	lds	r18, 0x0121
    2746:	30 91 22 01 	lds	r19, 0x0122
    274a:	28 17       	cp	r18, r24
    274c:	39 07       	cpc	r19, r25
    274e:	48 f1       	brcs	.+82     	; 0x27a2 <FPoolingPump2+0x6a4>
    2750:	22 c0       	rjmp	.+68     	; 0x2796 <FPoolingPump2+0x698>
		      stPoolingPump=pwNextPump;
	      break;
     case pwNextPump:	      
          iPoolingID++;
    2752:	90 91 16 01 	lds	r25, 0x0116
    2756:	9f 5f       	subi	r25, 0xFF	; 255
    2758:	90 93 16 01 	sts	0x0116, r25
	      if (iPoolingID<ScanPumpMax){
    275c:	80 91 61 02 	lds	r24, 0x0261
    2760:	98 17       	cp	r25, r24
    2762:	e8 f4       	brcc	.+58     	; 0x279e <FPoolingPump2+0x6a0>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2764:	e1 99       	sbic	0x1c, 1	; 28
    2766:	fe cf       	rjmp	.-4      	; 0x2764 <FPoolingPump2+0x666>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2768:	89 2f       	mov	r24, r25
    276a:	90 e0       	ldi	r25, 0x00	; 0
    276c:	83 5f       	subi	r24, 0xF3	; 243
    276e:	9f 4f       	sbci	r25, 0xFF	; 255
    2770:	9f bb       	out	0x1f, r25	; 31
    2772:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2774:	e0 9a       	sbi	0x1c, 0	; 28
    2776:	8d b3       	in	r24, 0x1d	; 29
			  txPumpID=eeprom_read_byte(&DefPumpID[iPoolingID]);
    2778:	80 93 17 01 	sts	0x0117, r24
			  if (txPumpID>0){
    277c:	88 23       	and	r24, r24
    277e:	59 f0       	breq	.+22     	; 0x2796 <FPoolingPump2+0x698>
			      txPumpID=txPumpID-1;
    2780:	81 50       	subi	r24, 0x01	; 1
    2782:	80 93 17 01 	sts	0x0117, r24
			      iSend=0;TimSend=0;
    2786:	10 92 f9 03 	sts	0x03F9, r1
    278a:	10 92 24 04 	sts	0x0424, r1
    278e:	10 92 23 04 	sts	0x0423, r1
			      stPoolingPump=pwScanStatus;
    2792:	82 e0       	ldi	r24, 0x02	; 2
    2794:	01 c0       	rjmp	.+2      	; 0x2798 <FPoolingPump2+0x69a>
			   }else stPoolingPump=pwNextPump;
    2796:	8b e1       	ldi	r24, 0x1B	; 27
    2798:	80 93 31 01 	sts	0x0131, r24
    279c:	02 c0       	rjmp	.+4      	; 0x27a2 <FPoolingPump2+0x6a4>
		  } else stPoolingPump=pwInit;//pwInitPumpAddr;
    279e:	10 92 31 01 	sts	0x0131, r1
		  #endif
		  
		  //stPoolingPump=pwInitPumpAddr;
	      break;
	 }
}
    27a2:	6e 96       	adiw	r28, 0x1e	; 30
    27a4:	0f b6       	in	r0, 0x3f	; 63
    27a6:	f8 94       	cli
    27a8:	de bf       	out	0x3e, r29	; 62
    27aa:	0f be       	out	0x3f, r0	; 63
    27ac:	cd bf       	out	0x3d, r28	; 61
    27ae:	cf 91       	pop	r28
    27b0:	df 91       	pop	r29
    27b2:	1f 91       	pop	r17
    27b4:	0f 91       	pop	r16
    27b6:	ff 90       	pop	r15
    27b8:	ef 90       	pop	r14
    27ba:	df 90       	pop	r13
    27bc:	cf 90       	pop	r12
    27be:	af 90       	pop	r10
    27c0:	08 95       	ret

000027c2 <TerminalSend>:
       while(pgm_read_byte(&(*strSendf)))
	         _uart(Com, 1, pgm_read_byte(&(*strSendf++)));
	}
}

void TerminalSend(char Com,char *strSend){
    27c2:	28 2f       	mov	r18, r24
    27c4:	ab 01       	movw	r20, r22
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    27c6:	e1 99       	sbic	0x1c, 1	; 28
    27c8:	fe cf       	rjmp	.-4      	; 0x27c6 <TerminalSend+0x4>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    27ca:	84 e0       	ldi	r24, 0x04	; 4
    27cc:	90 e0       	ldi	r25, 0x00	; 0
    27ce:	9f bb       	out	0x1f, r25	; 31
    27d0:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    27d2:	e0 9a       	sbi	0x1c, 0	; 28
    27d4:	8d b3       	in	r24, 0x1d	; 29
   if (eeprom_read_byte(&DefTerminalDebug)){
    27d6:	88 23       	and	r24, r24
    27d8:	21 f0       	breq	.+8      	; 0x27e2 <TerminalSend+0x20>
       _uart_print(Com,1,strSend);
    27da:	82 2f       	mov	r24, r18
    27dc:	61 e0       	ldi	r22, 0x01	; 1
    27de:	0e 94 61 18 	call	0x30c2	; 0x30c2 <_uart_print>
    27e2:	08 95       	ret

000027e4 <SystemSetSlave>:

return Result;
}

void SystemSetSlave(){
     SystemComLevel(CL_232);
    27e4:	81 e0       	ldi	r24, 0x01	; 1
    27e6:	0e 94 61 01 	call	0x2c2	; 0x2c2 <SystemComLevel>
     //_uart_setting(1,GetBaudrate(eeprom_read_byte(&DefBaudrate[1])),8,P_NONE,1);
	 //_uart_init(0,GetBaudrate(eeprom_read_byte(&DefBaudrate[0])));	

	 _uart_init(0,9600);	
    27ea:	80 e0       	ldi	r24, 0x00	; 0
    27ec:	40 e8       	ldi	r20, 0x80	; 128
    27ee:	55 e2       	ldi	r21, 0x25	; 37
    27f0:	60 e0       	ldi	r22, 0x00	; 0
    27f2:	70 e0       	ldi	r23, 0x00	; 0
    27f4:	0e 94 1e 18 	call	0x303c	; 0x303c <_uart_init>
	 _uart_init(1,9600);	
    27f8:	81 e0       	ldi	r24, 0x01	; 1
    27fa:	40 e8       	ldi	r20, 0x80	; 128
    27fc:	55 e2       	ldi	r21, 0x25	; 37
    27fe:	60 e0       	ldi	r22, 0x00	; 0
    2800:	70 e0       	ldi	r23, 0x00	; 0
    2802:	0e 94 1e 18 	call	0x303c	; 0x303c <_uart_init>
}
    2806:	08 95       	ret

00002808 <SystemSetDispenser>:

//enum eBaudRateValue{brNone,br9600,br19200,br5787};

void SystemSetDispenser(char TDispenserBrand){
    2808:	ef 92       	push	r14
    280a:	0f 93       	push	r16
     unsigned int brValue;

	 switch(TDispenserBrand){
    280c:	81 30       	cpi	r24, 0x01	; 1
    280e:	d9 f0       	breq	.+54     	; 0x2846 <SystemSetDispenser+0x3e>
    2810:	81 30       	cpi	r24, 0x01	; 1
    2812:	38 f0       	brcs	.+14     	; 0x2822 <SystemSetDispenser+0x1a>
    2814:	82 30       	cpi	r24, 0x02	; 2
    2816:	09 f4       	brne	.+2      	; 0x281a <SystemSetDispenser+0x12>
    2818:	3d c0       	rjmp	.+122    	; 0x2894 <SystemSetDispenser+0x8c>
    281a:	83 30       	cpi	r24, 0x03	; 3
    281c:	09 f0       	breq	.+2      	; 0x2820 <SystemSetDispenser+0x18>
    281e:	99 c0       	rjmp	.+306    	; 0x2952 <SystemSetDispenser+0x14a>
    2820:	67 c0       	rjmp	.+206    	; 0x28f0 <SystemSetDispenser+0xe8>
	 case ST_NONE:
	      //_uart_setting(0,GetBaudrate(eeprom_read_byte(&DefBaudrate[0])),8,P_NONE,1);
		  _uart_init(0,9600);
    2822:	80 e0       	ldi	r24, 0x00	; 0
    2824:	40 e8       	ldi	r20, 0x80	; 128
    2826:	55 e2       	ldi	r21, 0x25	; 37
    2828:	60 e0       	ldi	r22, 0x00	; 0
    282a:	70 e0       	ldi	r23, 0x00	; 0
    282c:	0e 94 1e 18 	call	0x303c	; 0x303c <_uart_init>
		  _uart_init(1,9600);
    2830:	81 e0       	ldi	r24, 0x01	; 1
    2832:	40 e8       	ldi	r20, 0x80	; 128
    2834:	55 e2       	ldi	r21, 0x25	; 37
    2836:	60 e0       	ldi	r22, 0x00	; 0
    2838:	70 e0       	ldi	r23, 0x00	; 0
    283a:	0e 94 1e 18 	call	0x303c	; 0x303c <_uart_init>
          SystemComLevel(CL_232);
    283e:	81 e0       	ldi	r24, 0x01	; 1
    2840:	0e 94 61 01 	call	0x2c2	; 0x2c2 <SystemComLevel>
    2844:	86 c0       	rjmp	.+268    	; 0x2952 <SystemSetDispenser+0x14a>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2846:	e1 99       	sbic	0x1c, 1	; 28
    2848:	fe cf       	rjmp	.-4      	; 0x2846 <SystemSetDispenser+0x3e>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    284a:	8e e1       	ldi	r24, 0x1E	; 30
    284c:	90 e0       	ldi	r25, 0x00	; 0
    284e:	9f bb       	out	0x1f, r25	; 31
    2850:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2852:	e0 9a       	sbi	0x1c, 0	; 28
    2854:	8d b3       	in	r24, 0x1d	; 29
	      break;
	 case ST_GILBARCO:
	      if (eeprom_read_byte(&DefHGMode)==HM_TTL)
    2856:	81 11       	cpse	r24, r1
		       SystemComLevel(CL_TTL);
		  else SystemComLevel(CL_232);
    2858:	81 e0       	ldi	r24, 0x01	; 1
    285a:	0e 94 61 01 	call	0x2c2	; 0x2c2 <SystemComLevel>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    285e:	e1 99       	sbic	0x1c, 1	; 28
    2860:	fe cf       	rjmp	.-4      	; 0x285e <SystemSetDispenser+0x56>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2862:	25 e0       	ldi	r18, 0x05	; 5
    2864:	30 e0       	ldi	r19, 0x00	; 0
    2866:	3f bb       	out	0x1f, r19	; 31
    2868:	2e bb       	out	0x1e, r18	; 30
#endif
    EEDR = __value;
    286a:	83 e0       	ldi	r24, 0x03	; 3
    286c:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    286e:	0f b6       	in	r0, 0x3f	; 63
    2870:	f8 94       	cli
    2872:	e2 9a       	sbi	0x1c, 2	; 28
    2874:	e1 9a       	sbi	0x1c, 1	; 28
    2876:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2878:	e1 99       	sbic	0x1c, 1	; 28
    287a:	fe cf       	rjmp	.-4      	; 0x2878 <SystemSetDispenser+0x70>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    287c:	3f bb       	out	0x1f, r19	; 31
    287e:	2e bb       	out	0x1e, r18	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2880:	e0 9a       	sbi	0x1c, 0	; 28
    2882:	8d b3       	in	r24, 0x1d	; 29
	      
		  eeprom_write_byte(&DefBaudrate[0],br5787);
		  brValue=GetBaudrate(eeprom_read_byte(&DefBaudrate[0]));
	      //_uart_setting(0,brValue,8,P_NONE,1);
		  
          _uart_init(0,5787);
    2884:	80 e0       	ldi	r24, 0x00	; 0
    2886:	4b e9       	ldi	r20, 0x9B	; 155
    2888:	56 e1       	ldi	r21, 0x16	; 22
    288a:	60 e0       	ldi	r22, 0x00	; 0
    288c:	70 e0       	ldi	r23, 0x00	; 0
    288e:	0e 94 1e 18 	call	0x303c	; 0x303c <_uart_init>
    2892:	5f c0       	rjmp	.+190    	; 0x2952 <SystemSetDispenser+0x14a>
	      break;
	 case ST_WAYNE_DART:		       
	 	  SystemComLevel(CL_485);
    2894:	82 e0       	ldi	r24, 0x02	; 2
    2896:	0e 94 61 01 	call	0x2c2	; 0x2c2 <SystemComLevel>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    289a:	e1 99       	sbic	0x1c, 1	; 28
    289c:	fe cf       	rjmp	.-4      	; 0x289a <SystemSetDispenser+0x92>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    289e:	25 e0       	ldi	r18, 0x05	; 5
    28a0:	30 e0       	ldi	r19, 0x00	; 0
    28a2:	3f bb       	out	0x1f, r19	; 31
    28a4:	2e bb       	out	0x1e, r18	; 30
#endif
    EEDR = __value;
    28a6:	81 e0       	ldi	r24, 0x01	; 1
    28a8:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    28aa:	0f b6       	in	r0, 0x3f	; 63
    28ac:	f8 94       	cli
    28ae:	e2 9a       	sbi	0x1c, 2	; 28
    28b0:	e1 9a       	sbi	0x1c, 1	; 28
    28b2:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    28b4:	e1 99       	sbic	0x1c, 1	; 28
    28b6:	fe cf       	rjmp	.-4      	; 0x28b4 <SystemSetDispenser+0xac>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    28b8:	3f bb       	out	0x1f, r19	; 31
    28ba:	2e bb       	out	0x1e, r18	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    28bc:	e0 9a       	sbi	0x1c, 0	; 28
    28be:	8d b3       	in	r24, 0x1d	; 29
     //IFType=IT_SLAVE;
}

int GetBaudrate(char brSetting){
int Result=0;
     switch(brSetting){
    28c0:	82 30       	cpi	r24, 0x02	; 2
    28c2:	59 f0       	breq	.+22     	; 0x28da <SystemSetDispenser+0xd2>
    28c4:	82 30       	cpi	r24, 0x02	; 2
    28c6:	18 f0       	brcs	.+6      	; 0x28ce <SystemSetDispenser+0xc6>
    28c8:	83 30       	cpi	r24, 0x03	; 3
    28ca:	21 f4       	brne	.+8      	; 0x28d4 <SystemSetDispenser+0xcc>
    28cc:	09 c0       	rjmp	.+18     	; 0x28e0 <SystemSetDispenser+0xd8>
    28ce:	40 e8       	ldi	r20, 0x80	; 128
    28d0:	55 e2       	ldi	r21, 0x25	; 37
    28d2:	08 c0       	rjmp	.+16     	; 0x28e4 <SystemSetDispenser+0xdc>
    28d4:	40 e0       	ldi	r20, 0x00	; 0
    28d6:	50 e0       	ldi	r21, 0x00	; 0
    28d8:	05 c0       	rjmp	.+10     	; 0x28e4 <SystemSetDispenser+0xdc>
    28da:	40 e0       	ldi	r20, 0x00	; 0
    28dc:	5b e4       	ldi	r21, 0x4B	; 75
    28de:	02 c0       	rjmp	.+4      	; 0x28e4 <SystemSetDispenser+0xdc>
    28e0:	4b e9       	ldi	r20, 0x9B	; 155
    28e2:	56 e1       	ldi	r21, 0x16	; 22
	      break;
	 case ST_WAYNE_DART:		       
	 	  SystemComLevel(CL_485);
          eeprom_write_byte(&DefBaudrate[0],br9600);
		  brValue=GetBaudrate(eeprom_read_byte(&DefBaudrate[0]));
	      _uart_setting(0,brValue,8,P_ODD,1);
    28e4:	60 e0       	ldi	r22, 0x00	; 0
    28e6:	70 e0       	ldi	r23, 0x00	; 0
    28e8:	80 e0       	ldi	r24, 0x00	; 0
    28ea:	28 e0       	ldi	r18, 0x08	; 8
    28ec:	01 e0       	ldi	r16, 0x01	; 1
    28ee:	2d c0       	rjmp	.+90     	; 0x294a <SystemSetDispenser+0x142>
	      break;
	 case ST_TATSUNO:
	 	  SystemComLevel(CL_485);
    28f0:	82 e0       	ldi	r24, 0x02	; 2
    28f2:	0e 94 61 01 	call	0x2c2	; 0x2c2 <SystemComLevel>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    28f6:	e1 99       	sbic	0x1c, 1	; 28
    28f8:	fe cf       	rjmp	.-4      	; 0x28f6 <SystemSetDispenser+0xee>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    28fa:	25 e0       	ldi	r18, 0x05	; 5
    28fc:	30 e0       	ldi	r19, 0x00	; 0
    28fe:	3f bb       	out	0x1f, r19	; 31
    2900:	2e bb       	out	0x1e, r18	; 30
#endif
    EEDR = __value;
    2902:	81 e0       	ldi	r24, 0x01	; 1
    2904:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    2906:	0f b6       	in	r0, 0x3f	; 63
    2908:	f8 94       	cli
    290a:	e2 9a       	sbi	0x1c, 2	; 28
    290c:	e1 9a       	sbi	0x1c, 1	; 28
    290e:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2910:	e1 99       	sbic	0x1c, 1	; 28
    2912:	fe cf       	rjmp	.-4      	; 0x2910 <SystemSetDispenser+0x108>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2914:	3f bb       	out	0x1f, r19	; 31
    2916:	2e bb       	out	0x1e, r18	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2918:	e0 9a       	sbi	0x1c, 0	; 28
    291a:	8d b3       	in	r24, 0x1d	; 29
     //IFType=IT_SLAVE;
}

int GetBaudrate(char brSetting){
int Result=0;
     switch(brSetting){
    291c:	82 30       	cpi	r24, 0x02	; 2
    291e:	59 f0       	breq	.+22     	; 0x2936 <SystemSetDispenser+0x12e>
    2920:	82 30       	cpi	r24, 0x02	; 2
    2922:	18 f0       	brcs	.+6      	; 0x292a <SystemSetDispenser+0x122>
    2924:	83 30       	cpi	r24, 0x03	; 3
    2926:	21 f4       	brne	.+8      	; 0x2930 <SystemSetDispenser+0x128>
    2928:	09 c0       	rjmp	.+18     	; 0x293c <SystemSetDispenser+0x134>
    292a:	40 e8       	ldi	r20, 0x80	; 128
    292c:	55 e2       	ldi	r21, 0x25	; 37
    292e:	08 c0       	rjmp	.+16     	; 0x2940 <SystemSetDispenser+0x138>
    2930:	40 e0       	ldi	r20, 0x00	; 0
    2932:	50 e0       	ldi	r21, 0x00	; 0
    2934:	05 c0       	rjmp	.+10     	; 0x2940 <SystemSetDispenser+0x138>
    2936:	40 e0       	ldi	r20, 0x00	; 0
    2938:	5b e4       	ldi	r21, 0x4B	; 75
    293a:	02 c0       	rjmp	.+4      	; 0x2940 <SystemSetDispenser+0x138>
    293c:	4b e9       	ldi	r20, 0x9B	; 155
    293e:	56 e1       	ldi	r21, 0x16	; 22
	      break;
	 case ST_TATSUNO:
	 	  SystemComLevel(CL_485);
          eeprom_write_byte(&DefBaudrate[0],br9600);
		  brValue=GetBaudrate(eeprom_read_byte(&DefBaudrate[0]));
	      _uart_setting(0,brValue,8,P_EVEN,1);
    2940:	60 e0       	ldi	r22, 0x00	; 0
    2942:	70 e0       	ldi	r23, 0x00	; 0
    2944:	80 e0       	ldi	r24, 0x00	; 0
    2946:	28 e0       	ldi	r18, 0x08	; 8
    2948:	02 e0       	ldi	r16, 0x02	; 2
    294a:	ee 24       	eor	r14, r14
    294c:	e3 94       	inc	r14
    294e:	0e 94 89 17 	call	0x2f12	; 0x2f12 <_uart_setting>
	      break;
	 case ST_LG:
	      break;			  
	 }
	 InitPumpData();
    2952:	0e 94 cd 01 	call	0x39a	; 0x39a <InitPumpData>
}
    2956:	0f 91       	pop	r16
    2958:	ef 90       	pop	r14
    295a:	08 95       	ret

0000295c <SystemInit>:
	      break;	 
	 }
}

void SystemInit(){
	PORTA=0xFF;	DDRA=0xFF;
    295c:	9f ef       	ldi	r25, 0xFF	; 255
    295e:	9b bb       	out	0x1b, r25	; 27
    2960:	9a bb       	out	0x1a, r25	; 26
	PORTE=0xFF;	DDRE=0xFF;
    2962:	97 b9       	out	0x07, r25	; 7
    2964:	96 b9       	out	0x06, r25	; 6
	DDRB= 0b01001111;//SPI Slave Input Pin-->SCK,MOSI
    2966:	8f e4       	ldi	r24, 0x4F	; 79
    2968:	87 bb       	out	0x17, r24	; 23
	PORTB=0b11111111;
    296a:	98 bb       	out	0x18, r25	; 24
	DDRD=0x00;PORTD=0b11111111;
    296c:	11 ba       	out	0x11, r1	; 17
    296e:	92 bb       	out	0x12, r25	; 18
	//Slave 128_SS_High
    sbi(DDRD,2);sbi(PORTD,2);
    2970:	8a 9a       	sbi	0x11, 2	; 17
    2972:	92 9a       	sbi	0x12, 2	; 18
	_spi_init(0,1);
    2974:	80 e0       	ldi	r24, 0x00	; 0
    2976:	61 e0       	ldi	r22, 0x01	; 1
    2978:	0e 94 5e 17 	call	0x2ebc	; 0x2ebc <_spi_init>
     sei();
	 */
}

void InitSystemTimer(){
	TCCR0 |= (1 << CS02) | (1 << CS00);
    297c:	83 b7       	in	r24, 0x33	; 51
    297e:	85 60       	ori	r24, 0x05	; 5
    2980:	83 bf       	out	0x33, r24	; 51
	TIMSK |= _BV(TOIE0);
    2982:	89 b7       	in	r24, 0x39	; 57
    2984:	82 60       	ori	r24, 0x02	; 2
    2986:	89 bf       	out	0x39, r24	; 57
	DDRD=0x00;PORTD=0b11111111;
	//Slave 128_SS_High
    sbi(DDRD,2);sbi(PORTD,2);
	_spi_init(0,1);
	InitSystemTimer();
	sei();
    2988:	78 94       	sei
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    298a:	e1 99       	sbic	0x1c, 1	; 28
    298c:	fe cf       	rjmp	.-4      	; 0x298a <SystemInit+0x2e>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    298e:	86 e0       	ldi	r24, 0x06	; 6
    2990:	90 e0       	ldi	r25, 0x00	; 0
    2992:	9f bb       	out	0x1f, r25	; 31
    2994:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2996:	e0 9a       	sbi	0x1c, 0	; 28
    2998:	8d b3       	in	r24, 0x1d	; 29
     //IFType=IT_SLAVE;
}

int GetBaudrate(char brSetting){
int Result=0;
     switch(brSetting){
    299a:	82 30       	cpi	r24, 0x02	; 2
    299c:	59 f0       	breq	.+22     	; 0x29b4 <SystemInit+0x58>
    299e:	82 30       	cpi	r24, 0x02	; 2
    29a0:	18 f0       	brcs	.+6      	; 0x29a8 <SystemInit+0x4c>
    29a2:	83 30       	cpi	r24, 0x03	; 3
    29a4:	21 f4       	brne	.+8      	; 0x29ae <SystemInit+0x52>
    29a6:	09 c0       	rjmp	.+18     	; 0x29ba <SystemInit+0x5e>
    29a8:	80 e8       	ldi	r24, 0x80	; 128
    29aa:	95 e2       	ldi	r25, 0x25	; 37
    29ac:	08 c0       	rjmp	.+16     	; 0x29be <SystemInit+0x62>
    29ae:	80 e0       	ldi	r24, 0x00	; 0
    29b0:	90 e0       	ldi	r25, 0x00	; 0
    29b2:	05 c0       	rjmp	.+10     	; 0x29be <SystemInit+0x62>
    29b4:	80 e0       	ldi	r24, 0x00	; 0
    29b6:	9b e4       	ldi	r25, 0x4B	; 75
    29b8:	02 c0       	rjmp	.+4      	; 0x29be <SystemInit+0x62>
    29ba:	8b e9       	ldi	r24, 0x9B	; 155
    29bc:	96 e1       	ldi	r25, 0x16	; 22
	//Slave 128_SS_High
    sbi(DDRD,2);sbi(PORTD,2);
	_spi_init(0,1);
	InitSystemTimer();
	sei();
	_uart_init(1,GetBaudrate(eeprom_read_byte(&DefBaudrate[1])));
    29be:	ac 01       	movw	r20, r24
    29c0:	66 27       	eor	r22, r22
    29c2:	57 fd       	sbrc	r21, 7
    29c4:	60 95       	com	r22
    29c6:	76 2f       	mov	r23, r22
    29c8:	81 e0       	ldi	r24, 0x01	; 1
    29ca:	0e 94 1e 18 	call	0x303c	; 0x303c <_uart_init>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    29ce:	e1 99       	sbic	0x1c, 1	; 28
    29d0:	fe cf       	rjmp	.-4      	; 0x29ce <SystemInit+0x72>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    29d2:	80 e0       	ldi	r24, 0x00	; 0
    29d4:	90 e0       	ldi	r25, 0x00	; 0
    29d6:	9f bb       	out	0x1f, r25	; 31
    29d8:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    29da:	e0 9a       	sbi	0x1c, 0	; 28
    29dc:	8d b3       	in	r24, 0x1d	; 29
    IFType=eeprom_read_byte(&DefIFType);
    29de:	80 93 00 01 	sts	0x0100, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    29e2:	e1 99       	sbic	0x1c, 1	; 28
    29e4:	fe cf       	rjmp	.-4      	; 0x29e2 <SystemInit+0x86>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    29e6:	8c e0       	ldi	r24, 0x0C	; 12
    29e8:	90 e0       	ldi	r25, 0x00	; 0
    29ea:	9f bb       	out	0x1f, r25	; 31
    29ec:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    29ee:	e0 9a       	sbi	0x1c, 0	; 28
    29f0:	8d b3       	in	r24, 0x1d	; 29
    SequenceTimeout=eeprom_read_byte(&DefSequenceTimeout);
    29f2:	80 93 36 04 	sts	0x0436, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    29f6:	e1 99       	sbic	0x1c, 1	; 28
    29f8:	fe cf       	rjmp	.-4      	; 0x29f6 <SystemInit+0x9a>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    29fa:	83 e0       	ldi	r24, 0x03	; 3
    29fc:	90 e0       	ldi	r25, 0x00	; 0
    29fe:	9f bb       	out	0x1f, r25	; 31
    2a00:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2a02:	e0 9a       	sbi	0x1c, 0	; 28
    2a04:	8d b3       	in	r24, 0x1d	; 29
	MaxPumpScanned=eeprom_read_byte(&DefPumpMaxCount);		
    2a06:	80 93 25 01 	sts	0x0125, r24

	switch(IFType){
    2a0a:	80 91 00 01 	lds	r24, 0x0100
    2a0e:	81 30       	cpi	r24, 0x01	; 1
    2a10:	19 f0       	breq	.+6      	; 0x2a18 <SystemInit+0xbc>
    2a12:	82 30       	cpi	r24, 0x02	; 2
    2a14:	c1 f4       	brne	.+48     	; 0x2a46 <SystemInit+0xea>
    2a16:	06 c0       	rjmp	.+12     	; 0x2a24 <SystemInit+0xc8>
	case IT_SLAVE:
	     BlinkRate=20;
    2a18:	84 e1       	ldi	r24, 0x14	; 20
    2a1a:	80 93 11 04 	sts	0x0411, r24
	     SystemSetSlave();
    2a1e:	0e 94 f2 13 	call	0x27e4	; 0x27e4 <SystemSetSlave>
    2a22:	11 c0       	rjmp	.+34     	; 0x2a46 <SystemInit+0xea>
	     break;
	case IT_STANDALONE:
	     BlinkRate=5;
    2a24:	85 e0       	ldi	r24, 0x05	; 5
    2a26:	80 93 11 04 	sts	0x0411, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2a2a:	e1 99       	sbic	0x1c, 1	; 28
    2a2c:	fe cf       	rjmp	.-4      	; 0x2a2a <SystemInit+0xce>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2a2e:	81 e0       	ldi	r24, 0x01	; 1
    2a30:	90 e0       	ldi	r25, 0x00	; 0
    2a32:	9f bb       	out	0x1f, r25	; 31
    2a34:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2a36:	e0 9a       	sbi	0x1c, 0	; 28
    2a38:	8d b3       	in	r24, 0x1d	; 29
		 StandaloneType=eeprom_read_byte(&DefStandaloneType);
    2a3a:	80 93 01 01 	sts	0x0101, r24
         SystemSetDispenser(StandaloneType);
    2a3e:	80 91 01 01 	lds	r24, 0x0101
    2a42:	0e 94 04 14 	call	0x2808	; 0x2808 <SystemSetDispenser>
	     break;	
	}
	InitPumpData();
    2a46:	0e 94 cd 01 	call	0x39a	; 0x39a <InitPumpData>
	IsStopPoolSequence=False;
    2a4a:	10 92 13 01 	sts	0x0113, r1
	 }Dest[Length]=0;
}


void StartupInfo(){
    _uart_printf(1,1,PSTR("Initialized"));
    2a4e:	81 e0       	ldi	r24, 0x01	; 1
    2a50:	61 e0       	ldi	r22, 0x01	; 1
    2a52:	4c e2       	ldi	r20, 0x2C	; 44
    2a54:	51 e0       	ldi	r21, 0x01	; 1
    2a56:	0e 94 89 18 	call	0x3112	; 0x3112 <_uart_printf>
	     break;	
	}
	InitPumpData();
	IsStopPoolSequence=False;
	StartupInfo();
	System485(DIR_RX);//ReceiveMode
    2a5a:	82 e0       	ldi	r24, 0x02	; 2
    2a5c:	0e 94 9c 01 	call	0x338	; 0x338 <System485>
}
    2a60:	08 95       	ret

00002a62 <main>:
	 if (IFType==IT_SLAVE)//EDC Line Protocol
	    _uart(0,1,dataSPI);
	 ScanStandaloneFlow(dataSPI);	 
}

void main (){
    2a62:	1f 93       	push	r17
	SystemInit();
    2a64:	0e 94 ae 14 	call	0x295c	; 0x295c <SystemInit>
		    TimWatchSequence=0;
		}
        if (TimWatchSequence>SequenceTimeout){
		    TimWatchSequence=0; 
		    //SendAcknoledge(SC_FREEZE,SequenceTimeout);
		    IsRestartPooling=True;
    2a68:	11 e0       	ldi	r17, 0x01	; 1

void systemAntiFreeze(){
static char zSequence=0;

	if (IFType==IT_STANDALONE){
	    if (SequencePool>zSequence){
    2a6a:	30 91 26 01 	lds	r19, 0x0126
		    TimWatchSequence=0;
		}
        if (TimWatchSequence>SequenceTimeout){
    2a6e:	40 91 36 04 	lds	r20, 0x0436
    2a72:	20 91 de 02 	lds	r18, 0x02DE
    2a76:	90 91 35 01 	lds	r25, 0x0135
	SystemInit();

   // SystemComLevel(CL_232);
	//_uart_init(0,5787);
	while(1){	   
	   switch(IFType){
    2a7a:	80 91 00 01 	lds	r24, 0x0100
    2a7e:	82 30       	cpi	r24, 0x02	; 2
    2a80:	e1 f7       	brne	.-8      	; 0x2a7a <main+0x18>
//15694 95.8% -> 14746 90.0%

void systemAntiFreeze(){
static char zSequence=0;

	if (IFType==IT_STANDALONE){
    2a82:	80 91 00 01 	lds	r24, 0x0100
    2a86:	82 30       	cpi	r24, 0x02	; 2
    2a88:	41 f4       	brne	.+16     	; 0x2a9a <main+0x38>
	    if (SequencePool>zSequence){
    2a8a:	93 17       	cp	r25, r19
    2a8c:	20 f0       	brcs	.+8      	; 0x2a96 <main+0x34>
		    TimWatchSequence=0;
		}
        if (TimWatchSequence>SequenceTimeout){
    2a8e:	42 17       	cp	r20, r18
    2a90:	18 f4       	brcc	.+6      	; 0x2a98 <main+0x36>
		    TimWatchSequence=0; 
		    //SendAcknoledge(SC_FREEZE,SequenceTimeout);
		    IsRestartPooling=True;
    2a92:	10 93 03 01 	sts	0x0103, r17
    2a96:	20 e0       	ldi	r18, 0x00	; 0
    2a98:	93 2f       	mov	r25, r19
	   switch(IFType){
	   case IT_SLAVE:
	        break;
	   case IT_STANDALONE:
	        systemAntiFreeze();//15714 15724			
			switch(StandaloneType){
    2a9a:	80 91 01 01 	lds	r24, 0x0101
    2a9e:	81 30       	cpi	r24, 0x01	; 1
    2aa0:	19 f0       	breq	.+6      	; 0x2aa8 <main+0x46>
    2aa2:	82 30       	cpi	r24, 0x02	; 2
    2aa4:	51 f7       	brne	.-44     	; 0x2a7a <main+0x18>
    2aa6:	07 c0       	rjmp	.+14     	; 0x2ab6 <main+0x54>
    2aa8:	20 93 de 02 	sts	0x02DE, r18
    2aac:	90 93 35 01 	sts	0x0135, r25
			case ST_GILBARCO:
			     FPoolingPump();
    2ab0:	0e 94 7b 0d 	call	0x1af6	; 0x1af6 <FPoolingPump>
    2ab4:	da cf       	rjmp	.-76     	; 0x2a6a <main+0x8>
			     break;
    2ab6:	20 93 de 02 	sts	0x02DE, r18
    2aba:	90 93 35 01 	sts	0x0135, r25
            case ST_WAYNE_DART:
                 FPoolingPump2(); 
    2abe:	0e 94 7f 10 	call	0x20fe	; 0x20fe <FPoolingPump2>
    2ac2:	d3 cf       	rjmp	.-90     	; 0x2a6a <main+0x8>

00002ac4 <ScanStandaloneFlow>:
     	  break;	 
	 }
   return Result;
}

void ScanStandaloneFlow(char xData){//<STX>[CMD][MSG]<ETX>: 0x05 0x06
    2ac4:	0f 93       	push	r16
    2ac6:	1f 93       	push	r17
    2ac8:	df 93       	push	r29
    2aca:	cf 93       	push	r28
    2acc:	cd b7       	in	r28, 0x3d	; 61
    2ace:	de b7       	in	r29, 0x3e	; 62
    2ad0:	64 97       	sbiw	r28, 0x14	; 20
    2ad2:	0f b6       	in	r0, 0x3f	; 63
    2ad4:	f8 94       	cli
    2ad6:	de bf       	out	0x3e, r29	; 62
    2ad8:	0f be       	out	0x3f, r0	; 63
    2ada:	cd bf       	out	0x3d, r28	; 61
     char slaveCmd,slaveMsg;        //            0x02:STANDALONE  		 0x00:NONE 0x01:GILBARCO 0x02:TATSUNO 0x03:LG 0x04:WYNE
     char ComPort,ComBaud,i;          //          0x03:DIAGNOSTIC
	 unsigned int brValue;
	 char strSend[20];
     slaveCmd=0;slaveMsg=0;         //            0x04:Totalizer
	 zFlowData[3]=zFlowData[2];     //            0x05:Baudrate
    2adc:	90 91 38 01 	lds	r25, 0x0138
    2ae0:	90 93 39 01 	sts	0x0139, r25
	 zFlowData[2]=zFlowData[1];     //            0x06:DebugTerminal:-->dtOn/dtOff
    2ae4:	00 91 37 01 	lds	r16, 0x0137
    2ae8:	00 93 38 01 	sts	0x0138, r16
	 zFlowData[1]=zFlowData[0];
    2aec:	10 91 36 01 	lds	r17, 0x0136
    2af0:	10 93 37 01 	sts	0x0137, r17
	 zFlowData[0]=xData;
    2af4:	80 93 36 01 	sts	0x0136, r24
	 //Scan SatndaloneMode Switch Command
	 if((zFlowData[0]==0x06)&(zFlowData[3]==0x05)){
    2af8:	86 30       	cpi	r24, 0x06	; 6
    2afa:	09 f0       	breq	.+2      	; 0x2afe <ScanStandaloneFlow+0x3a>
    2afc:	a3 c1       	rjmp	.+838    	; 0x2e44 <ScanStandaloneFlow+0x380>
    2afe:	95 30       	cpi	r25, 0x05	; 5
    2b00:	09 f0       	breq	.+2      	; 0x2b04 <ScanStandaloneFlow+0x40>
    2b02:	a0 c1       	rjmp	.+832    	; 0x2e44 <ScanStandaloneFlow+0x380>
         slaveCmd=zFlowData[2];
         slaveMsg=zFlowData[1];

		 switch(slaveCmd){
    2b04:	80 2f       	mov	r24, r16
    2b06:	90 e0       	ldi	r25, 0x00	; 0
    2b08:	fc 01       	movw	r30, r24
    2b0a:	31 97       	sbiw	r30, 0x01	; 1
    2b0c:	e1 32       	cpi	r30, 0x21	; 33
    2b0e:	f1 05       	cpc	r31, r1
    2b10:	08 f0       	brcs	.+2      	; 0x2b14 <ScanStandaloneFlow+0x50>
    2b12:	94 c1       	rjmp	.+808    	; 0x2e3c <ScanStandaloneFlow+0x378>
    2b14:	eb 58       	subi	r30, 0x8B	; 139
    2b16:	ff 4f       	sbci	r31, 0xFF	; 255
    2b18:	ee 0f       	add	r30, r30
    2b1a:	ff 1f       	adc	r31, r31
    2b1c:	05 90       	lpm	r0, Z+
    2b1e:	f4 91       	lpm	r31, Z+
    2b20:	e0 2d       	mov	r30, r0
    2b22:	09 94       	ijmp
		 case SC_SLAVE:		      
		      IFType=IT_SLAVE;
    2b24:	81 e0       	ldi	r24, 0x01	; 1
    2b26:	80 93 00 01 	sts	0x0100, r24
			  BlinkRate=20;
    2b2a:	84 e1       	ldi	r24, 0x14	; 20
    2b2c:	80 93 11 04 	sts	0x0411, r24
			  eeprom_write_byte(&DefIFType,IFType);
    2b30:	20 91 00 01 	lds	r18, 0x0100
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    2b34:	e1 99       	sbic	0x1c, 1	; 28
    2b36:	fe cf       	rjmp	.-4      	; 0x2b34 <ScanStandaloneFlow+0x70>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2b38:	80 e0       	ldi	r24, 0x00	; 0
    2b3a:	90 e0       	ldi	r25, 0x00	; 0
    2b3c:	9f bb       	out	0x1f, r25	; 31
    2b3e:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    2b40:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
    2b42:	0f b6       	in	r0, 0x3f	; 63
    2b44:	f8 94       	cli
    2b46:	e2 9a       	sbi	0x1c, 2	; 28
    2b48:	e1 9a       	sbi	0x1c, 1	; 28
    2b4a:	0f be       	out	0x3f, r0	; 63
			  #ifdef DEBUG_CMD_TERM 
			  TerminalSendf(1,PSTR("Slave"));		
			  #endif
			  SystemSetSlave();			  		 
    2b4c:	0e 94 f2 13 	call	0x27e4	; 0x27e4 <SystemSetSlave>
    2b50:	75 c1       	rjmp	.+746    	; 0x2e3c <ScanStandaloneFlow+0x378>
		      break;
         case SC_STANDALONE:
		      InitPumpData();		      
    2b52:	0e 94 cd 01 	call	0x39a	; 0x39a <InitPumpData>
		      IFType=IT_STANDALONE;
    2b56:	82 e0       	ldi	r24, 0x02	; 2
    2b58:	80 93 00 01 	sts	0x0100, r24
			  BlinkRate=5;
    2b5c:	85 e0       	ldi	r24, 0x05	; 5
    2b5e:	80 93 11 04 	sts	0x0411, r24
			  eeprom_write_byte(&DefIFType,IFType);
    2b62:	20 91 00 01 	lds	r18, 0x0100
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    2b66:	e1 99       	sbic	0x1c, 1	; 28
    2b68:	fe cf       	rjmp	.-4      	; 0x2b66 <ScanStandaloneFlow+0xa2>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2b6a:	80 e0       	ldi	r24, 0x00	; 0
    2b6c:	90 e0       	ldi	r25, 0x00	; 0
    2b6e:	9f bb       	out	0x1f, r25	; 31
    2b70:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    2b72:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
    2b74:	0f b6       	in	r0, 0x3f	; 63
    2b76:	f8 94       	cli
    2b78:	e2 9a       	sbi	0x1c, 2	; 28
    2b7a:	e1 9a       	sbi	0x1c, 1	; 28
    2b7c:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2b7e:	e1 99       	sbic	0x1c, 1	; 28
    2b80:	fe cf       	rjmp	.-4      	; 0x2b7e <ScanStandaloneFlow+0xba>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2b82:	81 e0       	ldi	r24, 0x01	; 1
    2b84:	90 e0       	ldi	r25, 0x00	; 0
    2b86:	9f bb       	out	0x1f, r25	; 31
    2b88:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2b8a:	e0 9a       	sbi	0x1c, 0	; 28
    2b8c:	8d b3       	in	r24, 0x1d	; 29
			  #ifdef DEBUG_CMD_TERM 
			  TerminalSendf(1,PSTR("Standalone"));
			  #endif
			  StandaloneType=eeprom_read_byte(&DefStandaloneType);
    2b8e:	80 93 01 01 	sts	0x0101, r24
              //StandaloneType=ST_WAYNE_DART;
              SystemSetDispenser(StandaloneType);
    2b92:	80 91 01 01 	lds	r24, 0x0101
    2b96:	39 c0       	rjmp	.+114    	; 0x2c0a <ScanStandaloneFlow+0x146>
			  //_uart_init(0,GetBaudrate(eeprom_read_byte(&DefBaudrate[0])));
			  //if (slaveMsg<=0x04)StandaloneType=slaveMsg;

		      break;
         case SC_SET_PUMP_TYPE:
		      IFType=IT_STANDALONE;
    2b98:	82 e0       	ldi	r24, 0x02	; 2
    2b9a:	80 93 00 01 	sts	0x0100, r24
			  BlinkRate=5;
    2b9e:	85 e0       	ldi	r24, 0x05	; 5
    2ba0:	80 93 11 04 	sts	0x0411, r24
              StandaloneType=slaveMsg;
    2ba4:	10 93 01 01 	sts	0x0101, r17
		      eeprom_write_byte(&DefStandaloneType,StandaloneType);			  		      
    2ba8:	20 91 01 01 	lds	r18, 0x0101
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    2bac:	e1 99       	sbic	0x1c, 1	; 28
    2bae:	fe cf       	rjmp	.-4      	; 0x2bac <ScanStandaloneFlow+0xe8>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2bb0:	81 e0       	ldi	r24, 0x01	; 1
    2bb2:	90 e0       	ldi	r25, 0x00	; 0
    2bb4:	9f bb       	out	0x1f, r25	; 31
    2bb6:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    2bb8:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
    2bba:	0f b6       	in	r0, 0x3f	; 63
    2bbc:	f8 94       	cli
    2bbe:	e2 9a       	sbi	0x1c, 2	; 28
    2bc0:	e1 9a       	sbi	0x1c, 1	; 28
    2bc2:	0f be       	out	0x3f, r0	; 63
			  sprintf_P(strSend,PSTR("Pump:%d"),StandaloneType);
    2bc4:	20 91 01 01 	lds	r18, 0x0101
    2bc8:	00 d0       	rcall	.+0      	; 0x2bca <ScanStandaloneFlow+0x106>
    2bca:	00 d0       	rcall	.+0      	; 0x2bcc <ScanStandaloneFlow+0x108>
    2bcc:	00 d0       	rcall	.+0      	; 0x2bce <ScanStandaloneFlow+0x10a>
    2bce:	ed b7       	in	r30, 0x3d	; 61
    2bd0:	fe b7       	in	r31, 0x3e	; 62
    2bd2:	31 96       	adiw	r30, 0x01	; 1
    2bd4:	ce 01       	movw	r24, r28
    2bd6:	01 96       	adiw	r24, 0x01	; 1
    2bd8:	ad b7       	in	r26, 0x3d	; 61
    2bda:	be b7       	in	r27, 0x3e	; 62
    2bdc:	12 96       	adiw	r26, 0x02	; 2
    2bde:	9c 93       	st	X, r25
    2be0:	8e 93       	st	-X, r24
    2be2:	11 97       	sbiw	r26, 0x01	; 1
    2be4:	8f e8       	ldi	r24, 0x8F	; 143
    2be6:	91 e0       	ldi	r25, 0x01	; 1
    2be8:	93 83       	std	Z+3, r25	; 0x03
    2bea:	82 83       	std	Z+2, r24	; 0x02
    2bec:	24 83       	std	Z+4, r18	; 0x04
    2bee:	15 82       	std	Z+5, r1	; 0x05
    2bf0:	0e 94 b2 18 	call	0x3164	; 0x3164 <sprintf_P>
              SystemSetDispenser(StandaloneType);
    2bf4:	80 91 01 01 	lds	r24, 0x0101
    2bf8:	2d b7       	in	r18, 0x3d	; 61
    2bfa:	3e b7       	in	r19, 0x3e	; 62
    2bfc:	2a 5f       	subi	r18, 0xFA	; 250
    2bfe:	3f 4f       	sbci	r19, 0xFF	; 255
    2c00:	0f b6       	in	r0, 0x3f	; 63
    2c02:	f8 94       	cli
    2c04:	3e bf       	out	0x3e, r19	; 62
    2c06:	0f be       	out	0x3f, r0	; 63
    2c08:	2d bf       	out	0x3d, r18	; 61
    2c0a:	0e 94 04 14 	call	0x2808	; 0x2808 <SystemSetDispenser>
    2c0e:	a3 c0       	rjmp	.+326    	; 0x2d56 <ScanStandaloneFlow+0x292>
		      break;
         case SC_TOTALIZER:
		      #ifdef DEBUG_CMD_TERM 
		      _uart_printf(1,1,PSTR("SC_TOTALIZER"));
			  #endif
		      if ((slaveMsg>=1)&&(slaveMsg<=16)){
    2c10:	81 2f       	mov	r24, r17
    2c12:	81 50       	subi	r24, 0x01	; 1
    2c14:	80 31       	cpi	r24, 0x10	; 16
    2c16:	08 f4       	brcc	.+2      	; 0x2c1a <ScanStandaloneFlow+0x156>
    2c18:	3e c0       	rjmp	.+124    	; 0x2c96 <ScanStandaloneFlow+0x1d2>
		           IsRequestTotalizerInfo[(slaveMsg&0x0F)]=True;
				  }
			  else if (slaveMsg==PUMP_ALL){
    2c1a:	12 31       	cpi	r17, 0x12	; 18
    2c1c:	09 f0       	breq	.+2      	; 0x2c20 <ScanStandaloneFlow+0x15c>
    2c1e:	0e c1       	rjmp	.+540    	; 0x2e3c <ScanStandaloneFlow+0x378>
    2c20:	81 e0       	ldi	r24, 0x01	; 1
    2c22:	90 e0       	ldi	r25, 0x00	; 0
		           #ifdef DEBUG_CMD_TERM 
				   _uart_printf(1,1,PSTR("PUMPALL"));
				   #endif
				   for (i=1;i<=16;i++)IsRequestTotalizerInfo[(i&0x0F)]=True;
    2c24:	21 e0       	ldi	r18, 0x01	; 1
    2c26:	fc 01       	movw	r30, r24
    2c28:	ef 70       	andi	r30, 0x0F	; 15
    2c2a:	f0 70       	andi	r31, 0x00	; 0
    2c2c:	ed 5e       	subi	r30, 0xED	; 237
    2c2e:	fb 4f       	sbci	r31, 0xFB	; 251
    2c30:	20 83       	st	Z, r18
    2c32:	01 96       	adiw	r24, 0x01	; 1
    2c34:	81 31       	cpi	r24, 0x11	; 17
    2c36:	91 05       	cpc	r25, r1
    2c38:	b1 f7       	brne	.-20     	; 0x2c26 <ScanStandaloneFlow+0x162>
    2c3a:	00 c1       	rjmp	.+512    	; 0x2e3c <ScanStandaloneFlow+0x378>
				  }				  	     
		      break; 
         case SC_BAUDRATE:
		      ComPort=(slaveMsg>>4)-3;//3..4
    2c3c:	31 2f       	mov	r19, r17
    2c3e:	32 95       	swap	r19
    2c40:	3f 70       	andi	r19, 0x0F	; 15
    2c42:	33 50       	subi	r19, 0x03	; 3
			  ComBaud=(slaveMsg&0x0F);//0,1,2,3
    2c44:	21 2f       	mov	r18, r17
    2c46:	2f 70       	andi	r18, 0x0F	; 15
     //IFType=IT_SLAVE;
}

int GetBaudrate(char brSetting){
int Result=0;
     switch(brSetting){
    2c48:	22 30       	cpi	r18, 0x02	; 2
    2c4a:	51 f0       	breq	.+20     	; 0x2c60 <ScanStandaloneFlow+0x19c>
    2c4c:	22 30       	cpi	r18, 0x02	; 2
    2c4e:	28 f0       	brcs	.+10     	; 0x2c5a <ScanStandaloneFlow+0x196>
    2c50:	23 30       	cpi	r18, 0x03	; 3
    2c52:	49 f0       	breq	.+18     	; 0x2c66 <ScanStandaloneFlow+0x1a2>
    2c54:	40 e0       	ldi	r20, 0x00	; 0
    2c56:	50 e0       	ldi	r21, 0x00	; 0
    2c58:	08 c0       	rjmp	.+16     	; 0x2c6a <ScanStandaloneFlow+0x1a6>
    2c5a:	40 e8       	ldi	r20, 0x80	; 128
    2c5c:	55 e2       	ldi	r21, 0x25	; 37
    2c5e:	05 c0       	rjmp	.+10     	; 0x2c6a <ScanStandaloneFlow+0x1a6>
    2c60:	40 e0       	ldi	r20, 0x00	; 0
    2c62:	5b e4       	ldi	r21, 0x4B	; 75
    2c64:	02 c0       	rjmp	.+4      	; 0x2c6a <ScanStandaloneFlow+0x1a6>
    2c66:	4b e9       	ldi	r20, 0x9B	; 155
    2c68:	56 e1       	ldi	r21, 0x16	; 22
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    2c6a:	e1 99       	sbic	0x1c, 1	; 28
    2c6c:	fe cf       	rjmp	.-4      	; 0x2c6a <ScanStandaloneFlow+0x1a6>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2c6e:	83 2f       	mov	r24, r19
    2c70:	90 e0       	ldi	r25, 0x00	; 0
    2c72:	8b 5f       	subi	r24, 0xFB	; 251
    2c74:	9f 4f       	sbci	r25, 0xFF	; 255
    2c76:	9f bb       	out	0x1f, r25	; 31
    2c78:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    2c7a:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
    2c7c:	0f b6       	in	r0, 0x3f	; 63
    2c7e:	f8 94       	cli
    2c80:	e2 9a       	sbi	0x1c, 2	; 28
    2c82:	e1 9a       	sbi	0x1c, 1	; 28
    2c84:	0f be       	out	0x3f, r0	; 63
			  eeprom_write_byte(&DefBaudrate[ComPort],ComBaud);
			  #ifdef DEBUG_CMD_TERM 
 			  sprintf_P(strSend,PSTR("COM:%d,%i"),ComPort,brValue);
			  TerminalSend(1,strSend);
			  #endif
			  _uart_init(ComPort,brValue);
    2c86:	60 e0       	ldi	r22, 0x00	; 0
    2c88:	70 e0       	ldi	r23, 0x00	; 0
    2c8a:	83 2f       	mov	r24, r19
    2c8c:	0e 94 1e 18 	call	0x303c	; 0x303c <_uart_init>
    2c90:	d5 c0       	rjmp	.+426    	; 0x2e3c <ScanStandaloneFlow+0x378>
		      break;
		 case SC_TRANSACTION:
		          if (slaveMsg<=16)IsRequestTotalizerInfo[slaveMsg&0x0F]=True;
    2c92:	11 31       	cpi	r17, 0x11	; 17
    2c94:	38 f4       	brcc	.+14     	; 0x2ca4 <ScanStandaloneFlow+0x1e0>
    2c96:	e1 2f       	mov	r30, r17
    2c98:	f0 e0       	ldi	r31, 0x00	; 0
    2c9a:	ef 70       	andi	r30, 0x0F	; 15
    2c9c:	f0 70       	andi	r31, 0x00	; 0
    2c9e:	ed 5e       	subi	r30, 0xED	; 237
    2ca0:	fb 4f       	sbci	r31, 0xFB	; 251
    2ca2:	19 c0       	rjmp	.+50     	; 0x2cd6 <ScanStandaloneFlow+0x212>
				  else 
				  if (slaveMsg==PUMP_ALL){
    2ca4:	12 31       	cpi	r17, 0x12	; 18
    2ca6:	09 f0       	breq	.+2      	; 0x2caa <ScanStandaloneFlow+0x1e6>
    2ca8:	c9 c0       	rjmp	.+402    	; 0x2e3c <ScanStandaloneFlow+0x378>
    2caa:	81 e0       	ldi	r24, 0x01	; 1
    2cac:	90 e0       	ldi	r25, 0x00	; 0
				      for(i=1;i<=16;i++){
					      IsRequestTotalizerInfo[i&0x0F]=True;
    2cae:	21 e0       	ldi	r18, 0x01	; 1
    2cb0:	fc 01       	movw	r30, r24
    2cb2:	ef 70       	andi	r30, 0x0F	; 15
    2cb4:	f0 70       	andi	r31, 0x00	; 0
    2cb6:	ed 5e       	subi	r30, 0xED	; 237
    2cb8:	fb 4f       	sbci	r31, 0xFB	; 251
    2cba:	20 83       	st	Z, r18
    2cbc:	01 96       	adiw	r24, 0x01	; 1
		      break;
		 case SC_TRANSACTION:
		          if (slaveMsg<=16)IsRequestTotalizerInfo[slaveMsg&0x0F]=True;
				  else 
				  if (slaveMsg==PUMP_ALL){
				      for(i=1;i<=16;i++){
    2cbe:	81 31       	cpi	r24, 0x11	; 17
    2cc0:	91 05       	cpc	r25, r1
    2cc2:	b1 f7       	brne	.-20     	; 0x2cb0 <ScanStandaloneFlow+0x1ec>
    2cc4:	bb c0       	rjmp	.+374    	; 0x2e3c <ScanStandaloneFlow+0x378>
				 sprintf_P(strSend,PSTR("ReqTrans:%d"),slaveMsg);
				 TerminalSend(1,strSend);
              #endif
		      break;     
         case SC_PUMP_LOCK:
		          if (slaveMsg<=16)PumpLock[slaveMsg&0x0F]=True;
    2cc6:	11 31       	cpi	r17, 0x11	; 17
    2cc8:	48 f4       	brcc	.+18     	; 0x2cdc <ScanStandaloneFlow+0x218>
    2cca:	e1 2f       	mov	r30, r17
    2ccc:	f0 e0       	ldi	r31, 0x00	; 0
    2cce:	ef 70       	andi	r30, 0x0F	; 15
    2cd0:	f0 70       	andi	r31, 0x00	; 0
    2cd2:	e4 53       	subi	r30, 0x34	; 52
    2cd4:	fd 4f       	sbci	r31, 0xFD	; 253
    2cd6:	81 e0       	ldi	r24, 0x01	; 1
    2cd8:	80 83       	st	Z, r24
    2cda:	b0 c0       	rjmp	.+352    	; 0x2e3c <ScanStandaloneFlow+0x378>
				  else 
				  if (slaveMsg==PUMP_ALL){
    2cdc:	12 31       	cpi	r17, 0x12	; 18
    2cde:	09 f0       	breq	.+2      	; 0x2ce2 <ScanStandaloneFlow+0x21e>
    2ce0:	ad c0       	rjmp	.+346    	; 0x2e3c <ScanStandaloneFlow+0x378>
    2ce2:	81 e0       	ldi	r24, 0x01	; 1
    2ce4:	90 e0       	ldi	r25, 0x00	; 0
				      for(i=1;i<=16;i++){
					      PumpLock[i&0x0F]=True;
    2ce6:	21 e0       	ldi	r18, 0x01	; 1
    2ce8:	fc 01       	movw	r30, r24
    2cea:	ef 70       	andi	r30, 0x0F	; 15
    2cec:	f0 70       	andi	r31, 0x00	; 0
    2cee:	e4 53       	subi	r30, 0x34	; 52
    2cf0:	fd 4f       	sbci	r31, 0xFD	; 253
    2cf2:	20 83       	st	Z, r18
    2cf4:	01 96       	adiw	r24, 0x01	; 1
		      break;     
         case SC_PUMP_LOCK:
		          if (slaveMsg<=16)PumpLock[slaveMsg&0x0F]=True;
				  else 
				  if (slaveMsg==PUMP_ALL){
				      for(i=1;i<=16;i++){
    2cf6:	81 31       	cpi	r24, 0x11	; 17
    2cf8:	91 05       	cpc	r25, r1
    2cfa:	b1 f7       	brne	.-20     	; 0x2ce8 <ScanStandaloneFlow+0x224>
    2cfc:	9f c0       	rjmp	.+318    	; 0x2e3c <ScanStandaloneFlow+0x378>
				 sprintf_P(strSend,PSTR("PumpLock:%d"),slaveMsg);
				 TerminalSend(1,strSend);
              #endif
		      break;
         case SC_PUMP_UNLOCK:
		          if (slaveMsg<=16)PumpLock[slaveMsg&0x0F]=False;
    2cfe:	11 31       	cpi	r17, 0x11	; 17
    2d00:	40 f4       	brcc	.+16     	; 0x2d12 <ScanStandaloneFlow+0x24e>
    2d02:	e1 2f       	mov	r30, r17
    2d04:	f0 e0       	ldi	r31, 0x00	; 0
    2d06:	ef 70       	andi	r30, 0x0F	; 15
    2d08:	f0 70       	andi	r31, 0x00	; 0
    2d0a:	e4 53       	subi	r30, 0x34	; 52
    2d0c:	fd 4f       	sbci	r31, 0xFD	; 253
    2d0e:	10 82       	st	Z, r1
    2d10:	95 c0       	rjmp	.+298    	; 0x2e3c <ScanStandaloneFlow+0x378>
			   	  else 
			   	  if (slaveMsg==PUMP_ALL){
    2d12:	12 31       	cpi	r17, 0x12	; 18
    2d14:	09 f0       	breq	.+2      	; 0x2d18 <ScanStandaloneFlow+0x254>
    2d16:	92 c0       	rjmp	.+292    	; 0x2e3c <ScanStandaloneFlow+0x378>
    2d18:	81 e0       	ldi	r24, 0x01	; 1
    2d1a:	90 e0       	ldi	r25, 0x00	; 0
			   	      for(i=1;i<=16;i++){
			   		      PumpLock[i&0x0F]=False;
    2d1c:	fc 01       	movw	r30, r24
    2d1e:	ef 70       	andi	r30, 0x0F	; 15
    2d20:	f0 70       	andi	r31, 0x00	; 0
    2d22:	e4 53       	subi	r30, 0x34	; 52
    2d24:	fd 4f       	sbci	r31, 0xFD	; 253
    2d26:	10 82       	st	Z, r1
    2d28:	01 96       	adiw	r24, 0x01	; 1
		      break;
         case SC_PUMP_UNLOCK:
		          if (slaveMsg<=16)PumpLock[slaveMsg&0x0F]=False;
			   	  else 
			   	  if (slaveMsg==PUMP_ALL){
			   	      for(i=1;i<=16;i++){
    2d2a:	81 31       	cpi	r24, 0x11	; 17
    2d2c:	91 05       	cpc	r25, r1
    2d2e:	b1 f7       	brne	.-20     	; 0x2d1c <ScanStandaloneFlow+0x258>
    2d30:	85 c0       	rjmp	.+266    	; 0x2e3c <ScanStandaloneFlow+0x378>
			   	 sprintf_P(strSend,PSTR("PumpUnLock:%d"),slaveMsg);
				 TerminalSend(1,strSend);			 
               #endif
		       break;
          case SC_TOTALIZER_ACK:
		       IsTotalizerACK=True;
    2d32:	81 e0       	ldi	r24, 0x01	; 1
    2d34:	80 93 14 01 	sts	0x0114, r24
			   PumpAck=slaveMsg;
    2d38:	10 93 df 02 	sts	0x02DF, r17
    2d3c:	7f c0       	rjmp	.+254    	; 0x2e3c <ScanStandaloneFlow+0x378>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    2d3e:	e1 99       	sbic	0x1c, 1	; 28
    2d40:	fe cf       	rjmp	.-4      	; 0x2d3e <ScanStandaloneFlow+0x27a>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2d42:	88 e0       	ldi	r24, 0x08	; 8
    2d44:	90 e0       	ldi	r25, 0x00	; 0
    2d46:	9f bb       	out	0x1f, r25	; 31
    2d48:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    2d4a:	1d bb       	out	0x1d, r17	; 29

    __asm__ __volatile__ (
    2d4c:	0f b6       	in	r0, 0x3f	; 63
    2d4e:	f8 94       	cli
    2d50:	e2 9a       	sbi	0x1c, 2	; 28
    2d52:	e1 9a       	sbi	0x1c, 1	; 28
    2d54:	0f be       	out	0x3f, r0	; 63
		       #ifdef DEBUG_CMD_TERM 
			   sprintf_P(strSend,PSTR("NoPumpCount:%d"),slaveMsg);
			   TerminalSend(1,strSend);			 
			   #endif
		       eeprom_write_byte(&DefNoPumpCountMax,slaveMsg);
			   IsRestartPooling=True;
    2d56:	81 e0       	ldi	r24, 0x01	; 1
    2d58:	80 93 03 01 	sts	0x0103, r24
    2d5c:	6f c0       	rjmp	.+222    	; 0x2e3c <ScanStandaloneFlow+0x378>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    2d5e:	e1 99       	sbic	0x1c, 1	; 28
    2d60:	fe cf       	rjmp	.-4      	; 0x2d5e <ScanStandaloneFlow+0x29a>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2d62:	87 e0       	ldi	r24, 0x07	; 7
    2d64:	90 e0       	ldi	r25, 0x00	; 0
    2d66:	ef cf       	rjmp	.-34     	; 0x2d46 <ScanStandaloneFlow+0x282>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    2d68:	e1 99       	sbic	0x1c, 1	; 28
    2d6a:	fe cf       	rjmp	.-4      	; 0x2d68 <ScanStandaloneFlow+0x2a4>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2d6c:	89 e0       	ldi	r24, 0x09	; 9
    2d6e:	90 e0       	ldi	r25, 0x00	; 0
    2d70:	ea cf       	rjmp	.-44     	; 0x2d46 <ScanStandaloneFlow+0x282>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    2d72:	e1 99       	sbic	0x1c, 1	; 28
    2d74:	fe cf       	rjmp	.-4      	; 0x2d72 <ScanStandaloneFlow+0x2ae>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2d76:	8a e0       	ldi	r24, 0x0A	; 10
    2d78:	90 e0       	ldi	r25, 0x00	; 0
    2d7a:	e5 cf       	rjmp	.-54     	; 0x2d46 <ScanStandaloneFlow+0x282>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    2d7c:	e1 99       	sbic	0x1c, 1	; 28
    2d7e:	fe cf       	rjmp	.-4      	; 0x2d7c <ScanStandaloneFlow+0x2b8>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2d80:	8b e0       	ldi	r24, 0x0B	; 11
    2d82:	90 e0       	ldi	r25, 0x00	; 0
    2d84:	e0 cf       	rjmp	.-64     	; 0x2d46 <ScanStandaloneFlow+0x282>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2d86:	e1 99       	sbic	0x1c, 1	; 28
    2d88:	fe cf       	rjmp	.-4      	; 0x2d86 <ScanStandaloneFlow+0x2c2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2d8a:	88 e0       	ldi	r24, 0x08	; 8
    2d8c:	90 e0       	ldi	r25, 0x00	; 0
    2d8e:	04 c0       	rjmp	.+8      	; 0x2d98 <ScanStandaloneFlow+0x2d4>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2d90:	e1 99       	sbic	0x1c, 1	; 28
    2d92:	fe cf       	rjmp	.-4      	; 0x2d90 <ScanStandaloneFlow+0x2cc>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2d94:	87 e0       	ldi	r24, 0x07	; 7
    2d96:	90 e0       	ldi	r25, 0x00	; 0
    2d98:	9f bb       	out	0x1f, r25	; 31
    2d9a:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2d9c:	e0 9a       	sbi	0x1c, 0	; 28
    2d9e:	1d b3       	in	r17, 0x1d	; 29
    2da0:	4d c0       	rjmp	.+154    	; 0x2e3c <ScanStandaloneFlow+0x378>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2da2:	e1 99       	sbic	0x1c, 1	; 28
    2da4:	fe cf       	rjmp	.-4      	; 0x2da2 <ScanStandaloneFlow+0x2de>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2da6:	89 e0       	ldi	r24, 0x09	; 9
    2da8:	90 e0       	ldi	r25, 0x00	; 0
    2daa:	f6 cf       	rjmp	.-20     	; 0x2d98 <ScanStandaloneFlow+0x2d4>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    2dac:	e1 99       	sbic	0x1c, 1	; 28
    2dae:	fe cf       	rjmp	.-4      	; 0x2dac <ScanStandaloneFlow+0x2e8>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2db0:	8c e0       	ldi	r24, 0x0C	; 12
    2db2:	90 e0       	ldi	r25, 0x00	; 0
    2db4:	9f bb       	out	0x1f, r25	; 31
    2db6:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    2db8:	1d bb       	out	0x1d, r17	; 29

    __asm__ __volatile__ (
    2dba:	0f b6       	in	r0, 0x3f	; 63
    2dbc:	f8 94       	cli
    2dbe:	e2 9a       	sbi	0x1c, 2	; 28
    2dc0:	e1 9a       	sbi	0x1c, 1	; 28
    2dc2:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2dc4:	e1 99       	sbic	0x1c, 1	; 28
    2dc6:	fe cf       	rjmp	.-4      	; 0x2dc4 <ScanStandaloneFlow+0x300>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2dc8:	9f bb       	out	0x1f, r25	; 31
    2dca:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2dcc:	e0 9a       	sbi	0x1c, 0	; 28
    2dce:	8d b3       	in	r24, 0x1d	; 29
		       #ifdef DEBUG_CMD_TERM 
			   sprintf_P(strSend,PSTR("PoolTrySend:%d"),slaveMsg);
			   TerminalSend(1,strSend);			 		        
			   #endif 
		       eeprom_write_byte(&DefSequenceTimeout,slaveMsg);
			   SequenceTimeout=eeprom_read_byte(&DefSequenceTimeout);
    2dd0:	80 93 36 04 	sts	0x0436, r24
    2dd4:	c0 cf       	rjmp	.-128    	; 0x2d56 <ScanStandaloneFlow+0x292>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    2dd6:	e1 99       	sbic	0x1c, 1	; 28
    2dd8:	fe cf       	rjmp	.-4      	; 0x2dd6 <ScanStandaloneFlow+0x312>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2dda:	81 2f       	mov	r24, r17
    2ddc:	82 95       	swap	r24
    2dde:	8f 70       	andi	r24, 0x0F	; 15
    2de0:	90 e0       	ldi	r25, 0x00	; 0
    2de2:	83 5f       	subi	r24, 0xF3	; 243
    2de4:	9f 4f       	sbci	r25, 0xFF	; 255
    2de6:	9f bb       	out	0x1f, r25	; 31
    2de8:	8e bb       	out	0x1e, r24	; 30
			   IsRestartPooling=True;		       
		       break;
          case SC_SET_PUMPID:
		       eeprom_write_byte(&DefPumpID[slaveMsg>>4],(slaveMsg&0x0F));		       
    2dea:	81 2f       	mov	r24, r17
    2dec:	8f 70       	andi	r24, 0x0F	; 15
#endif
    EEDR = __value;
    2dee:	8d bb       	out	0x1d, r24	; 29
    2df0:	ad cf       	rjmp	.-166    	; 0x2d4c <ScanStandaloneFlow+0x288>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    2df2:	e1 99       	sbic	0x1c, 1	; 28
    2df4:	fe cf       	rjmp	.-4      	; 0x2df2 <ScanStandaloneFlow+0x32e>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2df6:	81 2f       	mov	r24, r17
    2df8:	90 e0       	ldi	r25, 0x00	; 0
    2dfa:	83 5f       	subi	r24, 0xF3	; 243
    2dfc:	9f 4f       	sbci	r25, 0xFF	; 255
    2dfe:	9f bb       	out	0x1f, r25	; 31
    2e00:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    2e02:	1d ba       	out	0x1d, r1	; 29
    2e04:	a3 cf       	rjmp	.-186    	; 0x2d4c <ScanStandaloneFlow+0x288>
			   TerminalSend(1,strSend);			 		        
			   #endif
               IsRestartPooling=True;
		       break;
          case SC_STOP_POOL_SEQUENCE:
		       IsStopPoolSequence=True;
    2e06:	81 e0       	ldi	r24, 0x01	; 1
    2e08:	80 93 13 01 	sts	0x0113, r24
    2e0c:	17 c0       	rjmp	.+46     	; 0x2e3c <ScanStandaloneFlow+0x378>
		       break; 
          case SC_START_POOL_SEQUENCE:
		       IsStopPoolSequence=False;
    2e0e:	10 92 13 01 	sts	0x0113, r1
    2e12:	14 c0       	rjmp	.+40     	; 0x2e3c <ScanStandaloneFlow+0x378>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    2e14:	e1 99       	sbic	0x1c, 1	; 28
    2e16:	fe cf       	rjmp	.-4      	; 0x2e14 <ScanStandaloneFlow+0x350>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2e18:	8e e1       	ldi	r24, 0x1E	; 30
    2e1a:	90 e0       	ldi	r25, 0x00	; 0
    2e1c:	9f bb       	out	0x1f, r25	; 31
    2e1e:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    2e20:	1d bb       	out	0x1d, r17	; 29

    __asm__ __volatile__ (
    2e22:	0f b6       	in	r0, 0x3f	; 63
    2e24:	f8 94       	cli
    2e26:	e2 9a       	sbi	0x1c, 2	; 28
    2e28:	e1 9a       	sbi	0x1c, 1	; 28
    2e2a:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2e2c:	e1 99       	sbic	0x1c, 1	; 28
    2e2e:	fe cf       	rjmp	.-4      	; 0x2e2c <ScanStandaloneFlow+0x368>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2e30:	9f bb       	out	0x1f, r25	; 31
    2e32:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2e34:	e0 9a       	sbi	0x1c, 0	; 28
    2e36:	8d b3       	in	r24, 0x1d	; 29
		       break; 
          case SC_HGM_MODE:
		       eeprom_write_byte(&DefHGMode,slaveMsg);
			   SystemComLevel(eeprom_read_byte(&DefHGMode));
    2e38:	0e 94 61 01 	call	0x2c2	; 0x2c2 <SystemComLevel>
			   
		       break;
		 }
       //AcknoledgeCommand
       SendCommandAcknoledge(slaveCmd,slaveMsg);
    2e3c:	80 2f       	mov	r24, r16
    2e3e:	61 2f       	mov	r22, r17
    2e40:	0e 94 e0 06 	call	0xdc0	; 0xdc0 <SendCommandAcknoledge>
	 }//EndIf	 
}
    2e44:	64 96       	adiw	r28, 0x14	; 20
    2e46:	0f b6       	in	r0, 0x3f	; 63
    2e48:	f8 94       	cli
    2e4a:	de bf       	out	0x3e, r29	; 62
    2e4c:	0f be       	out	0x3f, r0	; 63
    2e4e:	cd bf       	out	0x3d, r28	; 61
    2e50:	cf 91       	pop	r28
    2e52:	df 91       	pop	r29
    2e54:	1f 91       	pop	r17
    2e56:	0f 91       	pop	r16
    2e58:	08 95       	ret

00002e5a <__vector_18>:
	   
	//_uart(1,1,dataRX1);
	//OnReceive1(dataRX1);
}

ISR(SPI_STC_vect){
    2e5a:	1f 92       	push	r1
    2e5c:	0f 92       	push	r0
    2e5e:	0f b6       	in	r0, 0x3f	; 63
    2e60:	0f 92       	push	r0
    2e62:	11 24       	eor	r1, r1
    2e64:	1f 93       	push	r17
    2e66:	2f 93       	push	r18
    2e68:	3f 93       	push	r19
    2e6a:	4f 93       	push	r20
    2e6c:	5f 93       	push	r21
    2e6e:	6f 93       	push	r22
    2e70:	7f 93       	push	r23
    2e72:	8f 93       	push	r24
    2e74:	9f 93       	push	r25
    2e76:	af 93       	push	r26
    2e78:	bf 93       	push	r27
    2e7a:	ef 93       	push	r30
    2e7c:	ff 93       	push	r31
char dataSPI;
     dataSPI=SPDR;
    2e7e:	1f b1       	in	r17, 0x0f	; 15
          ScanStandaloneFlow(dataSPI);
	      break;
	 }
	 */
	 
	 if (IFType==IT_SLAVE)//EDC Line Protocol
    2e80:	80 91 00 01 	lds	r24, 0x0100
    2e84:	81 30       	cpi	r24, 0x01	; 1
    2e86:	29 f4       	brne	.+10     	; 0x2e92 <__vector_18+0x38>
	    _uart(0,1,dataSPI);
    2e88:	80 e0       	ldi	r24, 0x00	; 0
    2e8a:	61 e0       	ldi	r22, 0x01	; 1
    2e8c:	41 2f       	mov	r20, r17
    2e8e:	0e 94 4a 18 	call	0x3094	; 0x3094 <_uart>
	 ScanStandaloneFlow(dataSPI);	 
    2e92:	81 2f       	mov	r24, r17
    2e94:	0e 94 62 15 	call	0x2ac4	; 0x2ac4 <ScanStandaloneFlow>
}
    2e98:	ff 91       	pop	r31
    2e9a:	ef 91       	pop	r30
    2e9c:	bf 91       	pop	r27
    2e9e:	af 91       	pop	r26
    2ea0:	9f 91       	pop	r25
    2ea2:	8f 91       	pop	r24
    2ea4:	7f 91       	pop	r23
    2ea6:	6f 91       	pop	r22
    2ea8:	5f 91       	pop	r21
    2eaa:	4f 91       	pop	r20
    2eac:	3f 91       	pop	r19
    2eae:	2f 91       	pop	r18
    2eb0:	1f 91       	pop	r17
    2eb2:	0f 90       	pop	r0
    2eb4:	0f be       	out	0x3f, r0	; 63
    2eb6:	0f 90       	pop	r0
    2eb8:	1f 90       	pop	r1
    2eba:	18 95       	reti

00002ebc <_spi_init>:
enum SPI_TYPE{SLAVE,MASTER};
enum SPI_MODE{POOLING,INTERUPT};


void _spi_init(unsigned char __mode, unsigned char __interrupt){
	if(__mode){
    2ebc:	88 23       	and	r24, r24
    2ebe:	41 f0       	breq	.+16     	; 0x2ed0 <_spi_init+0x14>
		_SPI_DDR = (1 << _SPI_MOSI) | (1 << _SPI_SCK);
    2ec0:	80 ea       	ldi	r24, 0xA0	; 160
    2ec2:	87 bb       	out	0x17, r24	; 23
		if(__interrupt)
    2ec4:	66 23       	and	r22, r22
    2ec6:	11 f0       	breq	.+4      	; 0x2ecc <_spi_init+0x10>
			SPCR = (1 << SPIE) | (1 << SPE) | (1 << MSTR) | (1 << SPR1);
    2ec8:	82 ed       	ldi	r24, 0xD2	; 210
    2eca:	0a c0       	rjmp	.+20     	; 0x2ee0 <_spi_init+0x24>
		else
			SPCR = (1 << SPE) | (1 << MSTR) | (1 << SPR1);
    2ecc:	82 e5       	ldi	r24, 0x52	; 82
    2ece:	08 c0       	rjmp	.+16     	; 0x2ee0 <_spi_init+0x24>
	}
	else{

		_SPI_DDR = (1 << _SPI_MISO);
    2ed0:	80 e4       	ldi	r24, 0x40	; 64
    2ed2:	87 bb       	out	0x17, r24	; 23
		if(__interrupt)
    2ed4:	66 23       	and	r22, r22
    2ed6:	21 f0       	breq	.+8      	; 0x2ee0 <_spi_init+0x24>
			{SPCR = (1 << SPIE) | (1 << SPE);sei();}
    2ed8:	80 ec       	ldi	r24, 0xC0	; 192
    2eda:	8d b9       	out	0x0d, r24	; 13
    2edc:	78 94       	sei
    2ede:	08 95       	ret
		else
			SPCR = (1 << SPE);
    2ee0:	8d b9       	out	0x0d, r24	; 13
    2ee2:	08 95       	ret

00002ee4 <_spi_enable>:
			
	}
}

void _spi_enable(unsigned char __status, unsigned char __select){
	if(__status){
    2ee4:	88 23       	and	r24, r24
    2ee6:	31 f0       	breq	.+12     	; 0x2ef4 <_spi_enable+0x10>
		if(__select)
    2ee8:	66 23       	and	r22, r22
    2eea:	11 f0       	breq	.+4      	; 0x2ef0 <_spi_enable+0xc>
			cbi(_MMC_PORT, _MMC_PIN);
    2eec:	3b 98       	cbi	0x07, 3	; 7
    2eee:	08 95       	ret
		else
			cbi(_SLAVE_PORT, _SLAVE_PIN);
    2ef0:	92 98       	cbi	0x12, 2	; 18
    2ef2:	08 95       	ret
	}
	else{
		if(__select)
    2ef4:	66 23       	and	r22, r22
    2ef6:	11 f0       	breq	.+4      	; 0x2efc <_spi_enable+0x18>
			sbi(_MMC_PORT, _MMC_PIN);
    2ef8:	3b 9a       	sbi	0x07, 3	; 7
    2efa:	08 95       	ret
		else
			sbi(_SLAVE_PORT, _SLAVE_PIN);
    2efc:	92 9a       	sbi	0x12, 2	; 18
    2efe:	08 95       	ret

00002f00 <_spi>:
	}
}

unsigned char _spi(unsigned char __data){   
	SPDR = __data;
    2f00:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1 << SPIF)));
    2f02:	77 9b       	sbis	0x0e, 7	; 14
    2f04:	fe cf       	rjmp	.-4      	; 0x2f02 <_spi+0x2>
	return SPDR;
    2f06:	8f b1       	in	r24, 0x0f	; 15
}
    2f08:	08 95       	ret

00002f0a <_spi_rx>:

unsigned char _spi_rx(unsigned char __select){
//	return 1;
}
    2f0a:	08 95       	ret

00002f0c <_spi_tx>:

unsigned char _spi_tx(unsigned char __command, unsigned char __select, char *__message){
//	_spi_enable(_SPI_ENABLE, __select);
//	_spi_enable(_SPI_DISABLE, __select);
//	return 0;
}
    2f0c:	08 95       	ret

00002f0e <_spi_interrupt>:

unsigned char _spi_interrupt(void){
	//return 0;
}
    2f0e:	08 95       	ret

00002f10 <_spi_command>:
	}

	__command[__i++] = 0x7D;
	__command[__i++] = '\0';
	*/
}
    2f10:	08 95       	ret

00002f12 <_uart_setting>:

#include "UART.h"

//_uart_setting(0,GetBaudrate(eeprom_read_byte(&DefBaudrate[0])),8,P_EVEN,1);

void _uart_setting(char Port,unsigned long Baudrate,char DataSet,char ParitySet, char StopBitSet){
    2f12:	af 92       	push	r10
    2f14:	bf 92       	push	r11
    2f16:	cf 92       	push	r12
    2f18:	df 92       	push	r13
    2f1a:	ef 92       	push	r14
    2f1c:	ff 92       	push	r15
    2f1e:	0f 93       	push	r16
    2f20:	1f 93       	push	r17
    2f22:	f8 2e       	mov	r15, r24
    2f24:	5a 01       	movw	r10, r20
    2f26:	6b 01       	movw	r12, r22
    2f28:	12 2f       	mov	r17, r18
unsigned long BaudrateValue;
     char RegB,RegC;
	 BaudrateValue= (unsigned long)((_CPU_DEFAULT + (Baudrate* 8)) / (Baudrate* 16) - 1);
    2f2a:	cb 01       	movw	r24, r22
    2f2c:	ba 01       	movw	r22, r20
    2f2e:	60 50       	subi	r22, 0x00	; 0
    2f30:	70 4e       	sbci	r23, 0xE0	; 224
    2f32:	83 4e       	sbci	r24, 0xE3	; 227
    2f34:	9f 4f       	sbci	r25, 0xFF	; 255
    2f36:	33 e0       	ldi	r19, 0x03	; 3
    2f38:	66 0f       	add	r22, r22
    2f3a:	77 1f       	adc	r23, r23
    2f3c:	88 1f       	adc	r24, r24
    2f3e:	99 1f       	adc	r25, r25
    2f40:	3a 95       	dec	r19
    2f42:	d1 f7       	brne	.-12     	; 0x2f38 <_uart_setting+0x26>
    2f44:	24 e0       	ldi	r18, 0x04	; 4
    2f46:	aa 0c       	add	r10, r10
    2f48:	bb 1c       	adc	r11, r11
    2f4a:	cc 1c       	adc	r12, r12
    2f4c:	dd 1c       	adc	r13, r13
    2f4e:	2a 95       	dec	r18
    2f50:	d1 f7       	brne	.-12     	; 0x2f46 <_uart_setting+0x34>
    2f52:	a6 01       	movw	r20, r12
    2f54:	95 01       	movw	r18, r10
    2f56:	0e 94 73 1b 	call	0x36e6	; 0x36e6 <__udivmodsi4>
    2f5a:	21 50       	subi	r18, 0x01	; 1
    2f5c:	30 40       	sbci	r19, 0x00	; 0
    2f5e:	40 40       	sbci	r20, 0x00	; 0
    2f60:	50 40       	sbci	r21, 0x00	; 0
     RegB=0;RegC=0;
	 RegB = (1<<RXCIE0) | (1<<RXEN0) | (1<<TXEN0);
     RegC = (1<<URSEL0);
   
     //ParitySet
	 switch(ParitySet){
    2f62:	01 30       	cpi	r16, 0x01	; 1
    2f64:	31 f0       	breq	.+12     	; 0x2f72 <_uart_setting+0x60>
    2f66:	02 30       	cpi	r16, 0x02	; 2
    2f68:	11 f4       	brne	.+4      	; 0x2f6e <_uart_setting+0x5c>
    2f6a:	60 ea       	ldi	r22, 0xA0	; 160
    2f6c:	03 c0       	rjmp	.+6      	; 0x2f74 <_uart_setting+0x62>
    2f6e:	60 e8       	ldi	r22, 0x80	; 128
    2f70:	01 c0       	rjmp	.+2      	; 0x2f74 <_uart_setting+0x62>
    2f72:	60 eb       	ldi	r22, 0xB0	; 176
     case P_ODD:
	      RegC=RegC|(1<<UPM00)|(1<<UPM01);
	      break;	 
	 }
     //StopBit
      if (StopBitSet==2)
    2f74:	82 e0       	ldi	r24, 0x02	; 2
    2f76:	e8 16       	cp	r14, r24
    2f78:	09 f4       	brne	.+2      	; 0x2f7c <_uart_setting+0x6a>
	      RegC=RegC|(1<<USBS0);
    2f7a:	68 60       	ori	r22, 0x08	; 8

		  //DataSet
		  switch (DataSet){
    2f7c:	17 30       	cpi	r17, 0x07	; 7
    2f7e:	61 f0       	breq	.+24     	; 0x2f98 <_uart_setting+0x86>
    2f80:	18 30       	cpi	r17, 0x08	; 8
    2f82:	18 f4       	brcc	.+6      	; 0x2f8a <_uart_setting+0x78>
    2f84:	16 30       	cpi	r17, 0x06	; 6
    2f86:	59 f4       	brne	.+22     	; 0x2f9e <_uart_setting+0x8c>
    2f88:	05 c0       	rjmp	.+10     	; 0x2f94 <_uart_setting+0x82>
    2f8a:	18 30       	cpi	r17, 0x08	; 8
    2f8c:	39 f0       	breq	.+14     	; 0x2f9c <_uart_setting+0x8a>
    2f8e:	19 30       	cpi	r17, 0x09	; 9
    2f90:	31 f4       	brne	.+12     	; 0x2f9e <_uart_setting+0x8c>
    2f92:	07 c0       	rjmp	.+14     	; 0x2fa2 <_uart_setting+0x90>
		  case 5:
		       break;
		  case 6:
		       RegC=RegC|(1<<UCSZ00);
    2f94:	62 60       	ori	r22, 0x02	; 2
    2f96:	03 c0       	rjmp	.+6      	; 0x2f9e <_uart_setting+0x8c>
		       break;
		  case 7:
		       RegC=RegC|(1<<UCSZ01);
    2f98:	64 60       	ori	r22, 0x04	; 4
    2f9a:	01 c0       	rjmp	.+2      	; 0x2f9e <_uart_setting+0x8c>
		       break;
		  case 8:
		       RegC=RegC|(1<<UCSZ00)|(1<<UCSZ01);
    2f9c:	66 60       	ori	r22, 0x06	; 6
    2f9e:	78 e9       	ldi	r23, 0x98	; 152
    2fa0:	02 c0       	rjmp	.+4      	; 0x2fa6 <_uart_setting+0x94>
		       break;
		  case 9:
               RegB=RegB| (1<<UCSZ02);
		       RegC=RegC| (1<<UCSZ00)|(1<<UCSZ01);
    2fa2:	66 60       	ori	r22, 0x06	; 6
    2fa4:	7c e9       	ldi	r23, 0x9C	; 156
		       break;
		  }

	 switch (Port){
    2fa6:	ff 20       	and	r15, r15
    2fa8:	21 f0       	breq	.+8      	; 0x2fb2 <_uart_setting+0xa0>
    2faa:	81 e0       	ldi	r24, 0x01	; 1
    2fac:	f8 16       	cp	r15, r24
    2fae:	91 f4       	brne	.+36     	; 0x2fd4 <_uart_setting+0xc2>
    2fb0:	09 c0       	rjmp	.+18     	; 0x2fc4 <_uart_setting+0xb2>
	 case 0:		  
		  //Write
		  //Register

	      //BaudrateSetting
          UBRR0H=BaudrateValue>>8;
    2fb2:	bb 27       	eor	r27, r27
    2fb4:	a5 2f       	mov	r26, r21
    2fb6:	94 2f       	mov	r25, r20
    2fb8:	83 2f       	mov	r24, r19
    2fba:	80 bd       	out	0x20, r24	; 32
		  UBRR0L=BaudrateValue;		
    2fbc:	29 b9       	out	0x09, r18	; 9
		  //Register
		  UCSR0B=RegB; 
    2fbe:	7a b9       	out	0x0a, r23	; 10
		  UCSR0C=RegC; 
    2fc0:	60 bd       	out	0x20, r22	; 32
    2fc2:	08 c0       	rjmp	.+16     	; 0x2fd4 <_uart_setting+0xc2>
	      break;
     case 1:
		  //Write
		  //BaudrateSetting
          UBRR1H=BaudrateValue>>8;
    2fc4:	bb 27       	eor	r27, r27
    2fc6:	a5 2f       	mov	r26, r21
    2fc8:	94 2f       	mov	r25, r20
    2fca:	83 2f       	mov	r24, r19
    2fcc:	8c bf       	out	0x3c, r24	; 60
		  UBRR1L=BaudrateValue;		
    2fce:	20 b9       	out	0x00, r18	; 0

		  //Register
		  UCSR1B=RegB; 
    2fd0:	71 b9       	out	0x01, r23	; 1
		  UCSR1C=RegC;
    2fd2:	6c bf       	out	0x3c, r22	; 60
	      break;
	 }  
}
    2fd4:	1f 91       	pop	r17
    2fd6:	0f 91       	pop	r16
    2fd8:	ff 90       	pop	r15
    2fda:	ef 90       	pop	r14
    2fdc:	df 90       	pop	r13
    2fde:	cf 90       	pop	r12
    2fe0:	bf 90       	pop	r11
    2fe2:	af 90       	pop	r10
    2fe4:	08 95       	ret

00002fe6 <_uart_baudrate>:
	    UCSR0C=(1<<URSEL0) | (1<<UPM01) | (1<<UCSZ01) | (1<<UCSZ00); // UPM01 untuk set even parity
	    UBRR0H=0;UBRR0L=158;// baud 5787       
	}
}

void _uart_baudrate(unsigned char __com, unsigned long __baudrate){
    2fe6:	1f 93       	push	r17
    2fe8:	18 2f       	mov	r17, r24
    2fea:	9a 01       	movw	r18, r20
    2fec:	ab 01       	movw	r20, r22
	unsigned long __br;

	__br = (unsigned long)((_CPU_DEFAULT + (__baudrate * 8)) / (__baudrate * 16) - 1);
    2fee:	ca 01       	movw	r24, r20
    2ff0:	b9 01       	movw	r22, r18
    2ff2:	60 50       	subi	r22, 0x00	; 0
    2ff4:	70 4e       	sbci	r23, 0xE0	; 224
    2ff6:	83 4e       	sbci	r24, 0xE3	; 227
    2ff8:	9f 4f       	sbci	r25, 0xFF	; 255
    2ffa:	f3 e0       	ldi	r31, 0x03	; 3
    2ffc:	66 0f       	add	r22, r22
    2ffe:	77 1f       	adc	r23, r23
    3000:	88 1f       	adc	r24, r24
    3002:	99 1f       	adc	r25, r25
    3004:	fa 95       	dec	r31
    3006:	d1 f7       	brne	.-12     	; 0x2ffc <_uart_baudrate+0x16>
    3008:	e4 e0       	ldi	r30, 0x04	; 4
    300a:	22 0f       	add	r18, r18
    300c:	33 1f       	adc	r19, r19
    300e:	44 1f       	adc	r20, r20
    3010:	55 1f       	adc	r21, r21
    3012:	ea 95       	dec	r30
    3014:	d1 f7       	brne	.-12     	; 0x300a <_uart_baudrate+0x24>
    3016:	0e 94 73 1b 	call	0x36e6	; 0x36e6 <__udivmodsi4>
    301a:	21 50       	subi	r18, 0x01	; 1
    301c:	30 40       	sbci	r19, 0x00	; 0
    301e:	40 40       	sbci	r20, 0x00	; 0
    3020:	50 40       	sbci	r21, 0x00	; 0
    3022:	bb 27       	eor	r27, r27
    3024:	a5 2f       	mov	r26, r21
    3026:	94 2f       	mov	r25, r20
    3028:	83 2f       	mov	r24, r19

	if(__com){
    302a:	11 23       	and	r17, r17
    302c:	19 f0       	breq	.+6      	; 0x3034 <_uart_baudrate+0x4e>
		UBRR1L = __br;
    302e:	20 b9       	out	0x00, r18	; 0
		UBRR1H = __br >> 8;
    3030:	8c bf       	out	0x3c, r24	; 60
    3032:	02 c0       	rjmp	.+4      	; 0x3038 <_uart_baudrate+0x52>
	}
	else{
		UBRR0L = __br;
    3034:	29 b9       	out	0x09, r18	; 9
		UBRR0H = __br >> 8;
    3036:	80 bd       	out	0x20, r24	; 32
	}
}
    3038:	1f 91       	pop	r17
    303a:	08 95       	ret

0000303c <_uart_init>:
		  UCSR1C=RegC;
	      break;
	 }  
}

void _uart_init(unsigned char __com, unsigned long __baudrate){
    303c:	ef 92       	push	r14
    303e:	ff 92       	push	r15
    3040:	0f 93       	push	r16
    3042:	1f 93       	push	r17
    3044:	98 2f       	mov	r25, r24
    3046:	7a 01       	movw	r14, r20
    3048:	8b 01       	movw	r16, r22
	if(__com){
    304a:	88 23       	and	r24, r24
    304c:	29 f0       	breq	.+10     	; 0x3058 <_uart_init+0x1c>
		UCSR1B = _BV(RXCIE1) | _BV(RXEN1) | _BV(TXEN1);
    304e:	88 e9       	ldi	r24, 0x98	; 152
    3050:	81 b9       	out	0x01, r24	; 1
		UCSR1C = _BV(UCSZ11) | _BV(UCSZ10);
    3052:	86 e0       	ldi	r24, 0x06	; 6
    3054:	8c bf       	out	0x3c, r24	; 60
    3056:	04 c0       	rjmp	.+8      	; 0x3060 <_uart_init+0x24>
	}
	else{
		UCSR0B = _BV(RXCIE0) | _BV(RXEN0) | _BV(TXEN0);
    3058:	88 e9       	ldi	r24, 0x98	; 152
    305a:	8a b9       	out	0x0a, r24	; 10
		UCSR0C = _BV(UCSZ01) | _BV(UCSZ00);
    305c:	86 e0       	ldi	r24, 0x06	; 6
    305e:	80 bd       	out	0x20, r24	; 32
	}
    

	_uart_baudrate(__com, __baudrate);
    3060:	89 2f       	mov	r24, r25
    3062:	b8 01       	movw	r22, r16
    3064:	a7 01       	movw	r20, r14
    3066:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <_uart_baudrate>

	if (__baudrate==5787){
    306a:	8b e9       	ldi	r24, 0x9B	; 155
    306c:	e8 16       	cp	r14, r24
    306e:	86 e1       	ldi	r24, 0x16	; 22
    3070:	f8 06       	cpc	r15, r24
    3072:	80 e0       	ldi	r24, 0x00	; 0
    3074:	08 07       	cpc	r16, r24
    3076:	80 e0       	ldi	r24, 0x00	; 0
    3078:	18 07       	cpc	r17, r24
    307a:	39 f4       	brne	.+14     	; 0x308a <_uart_init+0x4e>
	    UCSR0B=_BV(RXCIE0) | _BV(RXEN0) | _BV(TXEN0);
    307c:	88 e9       	ldi	r24, 0x98	; 152
    307e:	8a b9       	out	0x0a, r24	; 10
	    UCSR0C=(1<<URSEL0) | (1<<UPM01) | (1<<UCSZ01) | (1<<UCSZ00); // UPM01 untuk set even parity
    3080:	86 ea       	ldi	r24, 0xA6	; 166
    3082:	80 bd       	out	0x20, r24	; 32
	    UBRR0H=0;UBRR0L=158;// baud 5787       
    3084:	10 bc       	out	0x20, r1	; 32
    3086:	8e e9       	ldi	r24, 0x9E	; 158
    3088:	89 b9       	out	0x09, r24	; 9
	}
}
    308a:	1f 91       	pop	r17
    308c:	0f 91       	pop	r16
    308e:	ff 90       	pop	r15
    3090:	ef 90       	pop	r14
    3092:	08 95       	ret

00003094 <_uart>:
		UBRR0H = __br >> 8;
	}
}

unsigned char _uart(unsigned char __com, unsigned char __dir, unsigned char __chr){
	if(__com){
    3094:	88 23       	and	r24, r24
    3096:	51 f0       	breq	.+20     	; 0x30ac <_uart+0x18>
		if(__dir){
    3098:	66 23       	and	r22, r22
    309a:	21 f0       	breq	.+8      	; 0x30a4 <_uart+0x10>
			loop_until_bit_is_set(UCSR1A, UDRE1);
    309c:	15 9b       	sbis	0x02, 5	; 2
    309e:	fe cf       	rjmp	.-4      	; 0x309c <_uart+0x8>
			UDR1 = __chr;
    30a0:	43 b9       	out	0x03, r20	; 3
    30a2:	09 c0       	rjmp	.+18     	; 0x30b6 <_uart+0x22>
		}
		else{
			loop_until_bit_is_set(UCSR1A, RXC1);
    30a4:	17 9b       	sbis	0x02, 7	; 2
    30a6:	fe cf       	rjmp	.-4      	; 0x30a4 <_uart+0x10>
			return UDR1;
    30a8:	83 b1       	in	r24, 0x03	; 3
    30aa:	08 95       	ret
		}
	}
	else{
		if(__dir){
    30ac:	66 23       	and	r22, r22
    30ae:	29 f0       	breq	.+10     	; 0x30ba <_uart+0x26>
			loop_until_bit_is_set(UCSR0A, UDRE0);
    30b0:	5d 9b       	sbis	0x0b, 5	; 11
    30b2:	fe cf       	rjmp	.-4      	; 0x30b0 <_uart+0x1c>
			UDR0 = __chr;
    30b4:	4c b9       	out	0x0c, r20	; 12
    30b6:	81 e0       	ldi	r24, 0x01	; 1
    30b8:	08 95       	ret
		}
		else{
			loop_until_bit_is_set(UCSR0A,  RXC0);
    30ba:	5f 9b       	sbis	0x0b, 7	; 11
    30bc:	fe cf       	rjmp	.-4      	; 0x30ba <_uart+0x26>
			return UDR0;
    30be:	8c b1       	in	r24, 0x0c	; 12
		}

	}

	return 1;
}
    30c0:	08 95       	ret

000030c2 <_uart_print>:

void _uart_print(unsigned char __com, unsigned char __ret, char *__str){
    30c2:	0f 93       	push	r16
    30c4:	1f 93       	push	r17
    30c6:	cf 93       	push	r28
    30c8:	df 93       	push	r29
    30ca:	18 2f       	mov	r17, r24
    30cc:	06 2f       	mov	r16, r22
    30ce:	ea 01       	movw	r28, r20
	if(strlen(__str)>0)
    30d0:	88 81       	ld	r24, Y
    30d2:	88 23       	and	r24, r24
    30d4:	31 f4       	brne	.+12     	; 0x30e2 <_uart_print+0x20>
    30d6:	08 c0       	rjmp	.+16     	; 0x30e8 <_uart_print+0x26>
		while(*__str) _uart(__com, 1, *__str++);
    30d8:	21 96       	adiw	r28, 0x01	; 1
    30da:	81 2f       	mov	r24, r17
    30dc:	61 e0       	ldi	r22, 0x01	; 1
    30de:	0e 94 4a 18 	call	0x3094	; 0x3094 <_uart>
    30e2:	48 81       	ld	r20, Y
    30e4:	44 23       	and	r20, r20
    30e6:	c1 f7       	brne	.-16     	; 0x30d8 <_uart_print+0x16>

	if(__ret){
    30e8:	00 23       	and	r16, r16
    30ea:	51 f0       	breq	.+20     	; 0x3100 <_uart_print+0x3e>
		_uart(__com, 1, 0x0D);
    30ec:	81 2f       	mov	r24, r17
    30ee:	61 e0       	ldi	r22, 0x01	; 1
    30f0:	4d e0       	ldi	r20, 0x0D	; 13
    30f2:	0e 94 4a 18 	call	0x3094	; 0x3094 <_uart>
		_uart(__com, 1, 0x0A);
    30f6:	81 2f       	mov	r24, r17
    30f8:	61 e0       	ldi	r22, 0x01	; 1
    30fa:	4a e0       	ldi	r20, 0x0A	; 10
    30fc:	0e 94 4a 18 	call	0x3094	; 0x3094 <_uart>
    3100:	82 ee       	ldi	r24, 0xE2	; 226
    3102:	94 e0       	ldi	r25, 0x04	; 4
    3104:	01 97       	sbiw	r24, 0x01	; 1
    3106:	f1 f7       	brne	.-4      	; 0x3104 <_uart_print+0x42>
	}
	_delay_ms(5);
}
    3108:	df 91       	pop	r29
    310a:	cf 91       	pop	r28
    310c:	1f 91       	pop	r17
    310e:	0f 91       	pop	r16
    3110:	08 95       	ret

00003112 <_uart_printf>:

void _uart_printf(unsigned char __com, unsigned char __ret, char *__str){
    3112:	0f 93       	push	r16
    3114:	1f 93       	push	r17
    3116:	cf 93       	push	r28
    3118:	df 93       	push	r29
    311a:	18 2f       	mov	r17, r24
    311c:	06 2f       	mov	r16, r22
    311e:	ea 01       	movw	r28, r20
    3120:	07 c0       	rjmp	.+14     	; 0x3130 <_uart_printf+0x1e>
	while(pgm_read_byte(&(*__str)))
		_uart(__com, 1, pgm_read_byte(&(*__str++)));
    3122:	21 96       	adiw	r28, 0x01	; 1
    3124:	f9 01       	movw	r30, r18
    3126:	44 91       	lpm	r20, Z+
    3128:	81 2f       	mov	r24, r17
    312a:	61 e0       	ldi	r22, 0x01	; 1
    312c:	0e 94 4a 18 	call	0x3094	; 0x3094 <_uart>
    3130:	9e 01       	movw	r18, r28
	}
	_delay_ms(5);
}

void _uart_printf(unsigned char __com, unsigned char __ret, char *__str){
	while(pgm_read_byte(&(*__str)))
    3132:	fe 01       	movw	r30, r28
    3134:	84 91       	lpm	r24, Z+
    3136:	88 23       	and	r24, r24
    3138:	a1 f7       	brne	.-24     	; 0x3122 <_uart_printf+0x10>
		_uart(__com, 1, pgm_read_byte(&(*__str++)));

	if(__ret){
    313a:	00 23       	and	r16, r16
    313c:	51 f0       	breq	.+20     	; 0x3152 <_uart_printf+0x40>
		_uart(__com, 1, 0x0D);
    313e:	81 2f       	mov	r24, r17
    3140:	61 e0       	ldi	r22, 0x01	; 1
    3142:	4d e0       	ldi	r20, 0x0D	; 13
    3144:	0e 94 4a 18 	call	0x3094	; 0x3094 <_uart>
		_uart(__com, 1, 0x0A);
    3148:	81 2f       	mov	r24, r17
    314a:	61 e0       	ldi	r22, 0x01	; 1
    314c:	4a e0       	ldi	r20, 0x0A	; 10
    314e:	0e 94 4a 18 	call	0x3094	; 0x3094 <_uart>
    3152:	86 ea       	ldi	r24, 0xA6	; 166
    3154:	9e e0       	ldi	r25, 0x0E	; 14
    3156:	01 97       	sbiw	r24, 0x01	; 1
    3158:	f1 f7       	brne	.-4      	; 0x3156 <_uart_printf+0x44>
	}
	_delay_ms(15);
}
    315a:	df 91       	pop	r29
    315c:	cf 91       	pop	r28
    315e:	1f 91       	pop	r17
    3160:	0f 91       	pop	r16
    3162:	08 95       	ret

00003164 <sprintf_P>:
    3164:	ae e0       	ldi	r26, 0x0E	; 14
    3166:	b0 e0       	ldi	r27, 0x00	; 0
    3168:	e8 eb       	ldi	r30, 0xB8	; 184
    316a:	f8 e1       	ldi	r31, 0x18	; 24
    316c:	0c 94 a3 1b 	jmp	0x3746	; 0x3746 <__prologue_saves__+0x1c>
    3170:	0d 89       	ldd	r16, Y+21	; 0x15
    3172:	1e 89       	ldd	r17, Y+22	; 0x16
    3174:	8e e0       	ldi	r24, 0x0E	; 14
    3176:	8c 83       	std	Y+4, r24	; 0x04
    3178:	1a 83       	std	Y+2, r17	; 0x02
    317a:	09 83       	std	Y+1, r16	; 0x01
    317c:	8f ef       	ldi	r24, 0xFF	; 255
    317e:	9f e7       	ldi	r25, 0x7F	; 127
    3180:	9e 83       	std	Y+6, r25	; 0x06
    3182:	8d 83       	std	Y+5, r24	; 0x05
    3184:	9e 01       	movw	r18, r28
    3186:	27 5e       	subi	r18, 0xE7	; 231
    3188:	3f 4f       	sbci	r19, 0xFF	; 255
    318a:	ce 01       	movw	r24, r28
    318c:	01 96       	adiw	r24, 0x01	; 1
    318e:	6f 89       	ldd	r22, Y+23	; 0x17
    3190:	78 8d       	ldd	r23, Y+24	; 0x18
    3192:	a9 01       	movw	r20, r18
    3194:	0e 94 d6 18 	call	0x31ac	; 0x31ac <vfprintf>
    3198:	2f 81       	ldd	r18, Y+7	; 0x07
    319a:	38 85       	ldd	r19, Y+8	; 0x08
    319c:	02 0f       	add	r16, r18
    319e:	13 1f       	adc	r17, r19
    31a0:	f8 01       	movw	r30, r16
    31a2:	10 82       	st	Z, r1
    31a4:	2e 96       	adiw	r28, 0x0e	; 14
    31a6:	e4 e0       	ldi	r30, 0x04	; 4
    31a8:	0c 94 bf 1b 	jmp	0x377e	; 0x377e <__epilogue_restores__+0x1c>

000031ac <vfprintf>:
    31ac:	ab e0       	ldi	r26, 0x0B	; 11
    31ae:	b0 e0       	ldi	r27, 0x00	; 0
    31b0:	ec ed       	ldi	r30, 0xDC	; 220
    31b2:	f8 e1       	ldi	r31, 0x18	; 24
    31b4:	0c 94 95 1b 	jmp	0x372a	; 0x372a <__prologue_saves__>
    31b8:	3c 01       	movw	r6, r24
    31ba:	2b 01       	movw	r4, r22
    31bc:	5a 01       	movw	r10, r20
    31be:	fc 01       	movw	r30, r24
    31c0:	17 82       	std	Z+7, r1	; 0x07
    31c2:	16 82       	std	Z+6, r1	; 0x06
    31c4:	83 81       	ldd	r24, Z+3	; 0x03
    31c6:	81 fd       	sbrc	r24, 1
    31c8:	03 c0       	rjmp	.+6      	; 0x31d0 <vfprintf+0x24>
    31ca:	6f ef       	ldi	r22, 0xFF	; 255
    31cc:	7f ef       	ldi	r23, 0xFF	; 255
    31ce:	c6 c1       	rjmp	.+908    	; 0x355c <vfprintf+0x3b0>
    31d0:	9a e0       	ldi	r25, 0x0A	; 10
    31d2:	89 2e       	mov	r8, r25
    31d4:	1e 01       	movw	r2, r28
    31d6:	08 94       	sec
    31d8:	21 1c       	adc	r2, r1
    31da:	31 1c       	adc	r3, r1
    31dc:	f3 01       	movw	r30, r6
    31de:	23 81       	ldd	r18, Z+3	; 0x03
    31e0:	f2 01       	movw	r30, r4
    31e2:	23 fd       	sbrc	r18, 3
    31e4:	85 91       	lpm	r24, Z+
    31e6:	23 ff       	sbrs	r18, 3
    31e8:	81 91       	ld	r24, Z+
    31ea:	2f 01       	movw	r4, r30
    31ec:	88 23       	and	r24, r24
    31ee:	09 f4       	brne	.+2      	; 0x31f2 <vfprintf+0x46>
    31f0:	b2 c1       	rjmp	.+868    	; 0x3556 <vfprintf+0x3aa>
    31f2:	85 32       	cpi	r24, 0x25	; 37
    31f4:	39 f4       	brne	.+14     	; 0x3204 <vfprintf+0x58>
    31f6:	23 fd       	sbrc	r18, 3
    31f8:	85 91       	lpm	r24, Z+
    31fa:	23 ff       	sbrs	r18, 3
    31fc:	81 91       	ld	r24, Z+
    31fe:	2f 01       	movw	r4, r30
    3200:	85 32       	cpi	r24, 0x25	; 37
    3202:	29 f4       	brne	.+10     	; 0x320e <vfprintf+0x62>
    3204:	90 e0       	ldi	r25, 0x00	; 0
    3206:	b3 01       	movw	r22, r6
    3208:	0e 94 c9 1a 	call	0x3592	; 0x3592 <fputc>
    320c:	e7 cf       	rjmp	.-50     	; 0x31dc <vfprintf+0x30>
    320e:	98 2f       	mov	r25, r24
    3210:	ff 24       	eor	r15, r15
    3212:	ee 24       	eor	r14, r14
    3214:	99 24       	eor	r9, r9
    3216:	ff e1       	ldi	r31, 0x1F	; 31
    3218:	ff 15       	cp	r31, r15
    321a:	d0 f0       	brcs	.+52     	; 0x3250 <vfprintf+0xa4>
    321c:	9b 32       	cpi	r25, 0x2B	; 43
    321e:	69 f0       	breq	.+26     	; 0x323a <vfprintf+0x8e>
    3220:	9c 32       	cpi	r25, 0x2C	; 44
    3222:	28 f4       	brcc	.+10     	; 0x322e <vfprintf+0x82>
    3224:	90 32       	cpi	r25, 0x20	; 32
    3226:	59 f0       	breq	.+22     	; 0x323e <vfprintf+0x92>
    3228:	93 32       	cpi	r25, 0x23	; 35
    322a:	91 f4       	brne	.+36     	; 0x3250 <vfprintf+0xa4>
    322c:	0e c0       	rjmp	.+28     	; 0x324a <vfprintf+0x9e>
    322e:	9d 32       	cpi	r25, 0x2D	; 45
    3230:	49 f0       	breq	.+18     	; 0x3244 <vfprintf+0x98>
    3232:	90 33       	cpi	r25, 0x30	; 48
    3234:	69 f4       	brne	.+26     	; 0x3250 <vfprintf+0xa4>
    3236:	41 e0       	ldi	r20, 0x01	; 1
    3238:	24 c0       	rjmp	.+72     	; 0x3282 <vfprintf+0xd6>
    323a:	52 e0       	ldi	r21, 0x02	; 2
    323c:	f5 2a       	or	r15, r21
    323e:	84 e0       	ldi	r24, 0x04	; 4
    3240:	f8 2a       	or	r15, r24
    3242:	28 c0       	rjmp	.+80     	; 0x3294 <vfprintf+0xe8>
    3244:	98 e0       	ldi	r25, 0x08	; 8
    3246:	f9 2a       	or	r15, r25
    3248:	25 c0       	rjmp	.+74     	; 0x3294 <vfprintf+0xe8>
    324a:	e0 e1       	ldi	r30, 0x10	; 16
    324c:	fe 2a       	or	r15, r30
    324e:	22 c0       	rjmp	.+68     	; 0x3294 <vfprintf+0xe8>
    3250:	f7 fc       	sbrc	r15, 7
    3252:	29 c0       	rjmp	.+82     	; 0x32a6 <vfprintf+0xfa>
    3254:	89 2f       	mov	r24, r25
    3256:	80 53       	subi	r24, 0x30	; 48
    3258:	8a 30       	cpi	r24, 0x0A	; 10
    325a:	70 f4       	brcc	.+28     	; 0x3278 <vfprintf+0xcc>
    325c:	f6 fe       	sbrs	r15, 6
    325e:	05 c0       	rjmp	.+10     	; 0x326a <vfprintf+0xbe>
    3260:	98 9c       	mul	r9, r8
    3262:	90 2c       	mov	r9, r0
    3264:	11 24       	eor	r1, r1
    3266:	98 0e       	add	r9, r24
    3268:	15 c0       	rjmp	.+42     	; 0x3294 <vfprintf+0xe8>
    326a:	e8 9c       	mul	r14, r8
    326c:	e0 2c       	mov	r14, r0
    326e:	11 24       	eor	r1, r1
    3270:	e8 0e       	add	r14, r24
    3272:	f0 e2       	ldi	r31, 0x20	; 32
    3274:	ff 2a       	or	r15, r31
    3276:	0e c0       	rjmp	.+28     	; 0x3294 <vfprintf+0xe8>
    3278:	9e 32       	cpi	r25, 0x2E	; 46
    327a:	29 f4       	brne	.+10     	; 0x3286 <vfprintf+0xda>
    327c:	f6 fc       	sbrc	r15, 6
    327e:	6b c1       	rjmp	.+726    	; 0x3556 <vfprintf+0x3aa>
    3280:	40 e4       	ldi	r20, 0x40	; 64
    3282:	f4 2a       	or	r15, r20
    3284:	07 c0       	rjmp	.+14     	; 0x3294 <vfprintf+0xe8>
    3286:	9c 36       	cpi	r25, 0x6C	; 108
    3288:	19 f4       	brne	.+6      	; 0x3290 <vfprintf+0xe4>
    328a:	50 e8       	ldi	r21, 0x80	; 128
    328c:	f5 2a       	or	r15, r21
    328e:	02 c0       	rjmp	.+4      	; 0x3294 <vfprintf+0xe8>
    3290:	98 36       	cpi	r25, 0x68	; 104
    3292:	49 f4       	brne	.+18     	; 0x32a6 <vfprintf+0xfa>
    3294:	f2 01       	movw	r30, r4
    3296:	23 fd       	sbrc	r18, 3
    3298:	95 91       	lpm	r25, Z+
    329a:	23 ff       	sbrs	r18, 3
    329c:	91 91       	ld	r25, Z+
    329e:	2f 01       	movw	r4, r30
    32a0:	99 23       	and	r25, r25
    32a2:	09 f0       	breq	.+2      	; 0x32a6 <vfprintf+0xfa>
    32a4:	b8 cf       	rjmp	.-144    	; 0x3216 <vfprintf+0x6a>
    32a6:	89 2f       	mov	r24, r25
    32a8:	85 54       	subi	r24, 0x45	; 69
    32aa:	83 30       	cpi	r24, 0x03	; 3
    32ac:	18 f0       	brcs	.+6      	; 0x32b4 <vfprintf+0x108>
    32ae:	80 52       	subi	r24, 0x20	; 32
    32b0:	83 30       	cpi	r24, 0x03	; 3
    32b2:	38 f4       	brcc	.+14     	; 0x32c2 <vfprintf+0x116>
    32b4:	44 e0       	ldi	r20, 0x04	; 4
    32b6:	50 e0       	ldi	r21, 0x00	; 0
    32b8:	a4 0e       	add	r10, r20
    32ba:	b5 1e       	adc	r11, r21
    32bc:	5f e3       	ldi	r21, 0x3F	; 63
    32be:	59 83       	std	Y+1, r21	; 0x01
    32c0:	0f c0       	rjmp	.+30     	; 0x32e0 <vfprintf+0x134>
    32c2:	93 36       	cpi	r25, 0x63	; 99
    32c4:	31 f0       	breq	.+12     	; 0x32d2 <vfprintf+0x126>
    32c6:	93 37       	cpi	r25, 0x73	; 115
    32c8:	79 f0       	breq	.+30     	; 0x32e8 <vfprintf+0x13c>
    32ca:	93 35       	cpi	r25, 0x53	; 83
    32cc:	09 f0       	breq	.+2      	; 0x32d0 <vfprintf+0x124>
    32ce:	56 c0       	rjmp	.+172    	; 0x337c <vfprintf+0x1d0>
    32d0:	20 c0       	rjmp	.+64     	; 0x3312 <vfprintf+0x166>
    32d2:	f5 01       	movw	r30, r10
    32d4:	80 81       	ld	r24, Z
    32d6:	89 83       	std	Y+1, r24	; 0x01
    32d8:	42 e0       	ldi	r20, 0x02	; 2
    32da:	50 e0       	ldi	r21, 0x00	; 0
    32dc:	a4 0e       	add	r10, r20
    32de:	b5 1e       	adc	r11, r21
    32e0:	61 01       	movw	r12, r2
    32e2:	01 e0       	ldi	r16, 0x01	; 1
    32e4:	10 e0       	ldi	r17, 0x00	; 0
    32e6:	12 c0       	rjmp	.+36     	; 0x330c <vfprintf+0x160>
    32e8:	f5 01       	movw	r30, r10
    32ea:	c0 80       	ld	r12, Z
    32ec:	d1 80       	ldd	r13, Z+1	; 0x01
    32ee:	f6 fc       	sbrc	r15, 6
    32f0:	03 c0       	rjmp	.+6      	; 0x32f8 <vfprintf+0x14c>
    32f2:	6f ef       	ldi	r22, 0xFF	; 255
    32f4:	7f ef       	ldi	r23, 0xFF	; 255
    32f6:	02 c0       	rjmp	.+4      	; 0x32fc <vfprintf+0x150>
    32f8:	69 2d       	mov	r22, r9
    32fa:	70 e0       	ldi	r23, 0x00	; 0
    32fc:	42 e0       	ldi	r20, 0x02	; 2
    32fe:	50 e0       	ldi	r21, 0x00	; 0
    3300:	a4 0e       	add	r10, r20
    3302:	b5 1e       	adc	r11, r21
    3304:	c6 01       	movw	r24, r12
    3306:	0e 94 be 1a 	call	0x357c	; 0x357c <strnlen>
    330a:	8c 01       	movw	r16, r24
    330c:	5f e7       	ldi	r21, 0x7F	; 127
    330e:	f5 22       	and	r15, r21
    3310:	14 c0       	rjmp	.+40     	; 0x333a <vfprintf+0x18e>
    3312:	f5 01       	movw	r30, r10
    3314:	c0 80       	ld	r12, Z
    3316:	d1 80       	ldd	r13, Z+1	; 0x01
    3318:	f6 fc       	sbrc	r15, 6
    331a:	03 c0       	rjmp	.+6      	; 0x3322 <vfprintf+0x176>
    331c:	6f ef       	ldi	r22, 0xFF	; 255
    331e:	7f ef       	ldi	r23, 0xFF	; 255
    3320:	02 c0       	rjmp	.+4      	; 0x3326 <vfprintf+0x17a>
    3322:	69 2d       	mov	r22, r9
    3324:	70 e0       	ldi	r23, 0x00	; 0
    3326:	42 e0       	ldi	r20, 0x02	; 2
    3328:	50 e0       	ldi	r21, 0x00	; 0
    332a:	a4 0e       	add	r10, r20
    332c:	b5 1e       	adc	r11, r21
    332e:	c6 01       	movw	r24, r12
    3330:	0e 94 b3 1a 	call	0x3566	; 0x3566 <strnlen_P>
    3334:	8c 01       	movw	r16, r24
    3336:	50 e8       	ldi	r21, 0x80	; 128
    3338:	f5 2a       	or	r15, r21
    333a:	f3 fe       	sbrs	r15, 3
    333c:	07 c0       	rjmp	.+14     	; 0x334c <vfprintf+0x1a0>
    333e:	1a c0       	rjmp	.+52     	; 0x3374 <vfprintf+0x1c8>
    3340:	80 e2       	ldi	r24, 0x20	; 32
    3342:	90 e0       	ldi	r25, 0x00	; 0
    3344:	b3 01       	movw	r22, r6
    3346:	0e 94 c9 1a 	call	0x3592	; 0x3592 <fputc>
    334a:	ea 94       	dec	r14
    334c:	8e 2d       	mov	r24, r14
    334e:	90 e0       	ldi	r25, 0x00	; 0
    3350:	08 17       	cp	r16, r24
    3352:	19 07       	cpc	r17, r25
    3354:	a8 f3       	brcs	.-22     	; 0x3340 <vfprintf+0x194>
    3356:	0e c0       	rjmp	.+28     	; 0x3374 <vfprintf+0x1c8>
    3358:	f6 01       	movw	r30, r12
    335a:	f7 fc       	sbrc	r15, 7
    335c:	85 91       	lpm	r24, Z+
    335e:	f7 fe       	sbrs	r15, 7
    3360:	81 91       	ld	r24, Z+
    3362:	6f 01       	movw	r12, r30
    3364:	90 e0       	ldi	r25, 0x00	; 0
    3366:	b3 01       	movw	r22, r6
    3368:	0e 94 c9 1a 	call	0x3592	; 0x3592 <fputc>
    336c:	e1 10       	cpse	r14, r1
    336e:	ea 94       	dec	r14
    3370:	01 50       	subi	r16, 0x01	; 1
    3372:	10 40       	sbci	r17, 0x00	; 0
    3374:	01 15       	cp	r16, r1
    3376:	11 05       	cpc	r17, r1
    3378:	79 f7       	brne	.-34     	; 0x3358 <vfprintf+0x1ac>
    337a:	ea c0       	rjmp	.+468    	; 0x3550 <vfprintf+0x3a4>
    337c:	94 36       	cpi	r25, 0x64	; 100
    337e:	11 f0       	breq	.+4      	; 0x3384 <vfprintf+0x1d8>
    3380:	99 36       	cpi	r25, 0x69	; 105
    3382:	69 f5       	brne	.+90     	; 0x33de <vfprintf+0x232>
    3384:	f7 fe       	sbrs	r15, 7
    3386:	08 c0       	rjmp	.+16     	; 0x3398 <vfprintf+0x1ec>
    3388:	f5 01       	movw	r30, r10
    338a:	20 81       	ld	r18, Z
    338c:	31 81       	ldd	r19, Z+1	; 0x01
    338e:	42 81       	ldd	r20, Z+2	; 0x02
    3390:	53 81       	ldd	r21, Z+3	; 0x03
    3392:	84 e0       	ldi	r24, 0x04	; 4
    3394:	90 e0       	ldi	r25, 0x00	; 0
    3396:	0a c0       	rjmp	.+20     	; 0x33ac <vfprintf+0x200>
    3398:	f5 01       	movw	r30, r10
    339a:	80 81       	ld	r24, Z
    339c:	91 81       	ldd	r25, Z+1	; 0x01
    339e:	9c 01       	movw	r18, r24
    33a0:	44 27       	eor	r20, r20
    33a2:	37 fd       	sbrc	r19, 7
    33a4:	40 95       	com	r20
    33a6:	54 2f       	mov	r21, r20
    33a8:	82 e0       	ldi	r24, 0x02	; 2
    33aa:	90 e0       	ldi	r25, 0x00	; 0
    33ac:	a8 0e       	add	r10, r24
    33ae:	b9 1e       	adc	r11, r25
    33b0:	9f e6       	ldi	r25, 0x6F	; 111
    33b2:	f9 22       	and	r15, r25
    33b4:	57 ff       	sbrs	r21, 7
    33b6:	09 c0       	rjmp	.+18     	; 0x33ca <vfprintf+0x21e>
    33b8:	50 95       	com	r21
    33ba:	40 95       	com	r20
    33bc:	30 95       	com	r19
    33be:	21 95       	neg	r18
    33c0:	3f 4f       	sbci	r19, 0xFF	; 255
    33c2:	4f 4f       	sbci	r20, 0xFF	; 255
    33c4:	5f 4f       	sbci	r21, 0xFF	; 255
    33c6:	e0 e8       	ldi	r30, 0x80	; 128
    33c8:	fe 2a       	or	r15, r30
    33ca:	ca 01       	movw	r24, r20
    33cc:	b9 01       	movw	r22, r18
    33ce:	a1 01       	movw	r20, r2
    33d0:	2a e0       	ldi	r18, 0x0A	; 10
    33d2:	30 e0       	ldi	r19, 0x00	; 0
    33d4:	0e 94 f5 1a 	call	0x35ea	; 0x35ea <__ultoa_invert>
    33d8:	d8 2e       	mov	r13, r24
    33da:	d2 18       	sub	r13, r2
    33dc:	40 c0       	rjmp	.+128    	; 0x345e <vfprintf+0x2b2>
    33de:	95 37       	cpi	r25, 0x75	; 117
    33e0:	29 f4       	brne	.+10     	; 0x33ec <vfprintf+0x240>
    33e2:	1f 2d       	mov	r17, r15
    33e4:	1f 7e       	andi	r17, 0xEF	; 239
    33e6:	2a e0       	ldi	r18, 0x0A	; 10
    33e8:	30 e0       	ldi	r19, 0x00	; 0
    33ea:	1d c0       	rjmp	.+58     	; 0x3426 <vfprintf+0x27a>
    33ec:	1f 2d       	mov	r17, r15
    33ee:	19 7f       	andi	r17, 0xF9	; 249
    33f0:	9f 36       	cpi	r25, 0x6F	; 111
    33f2:	61 f0       	breq	.+24     	; 0x340c <vfprintf+0x260>
    33f4:	90 37       	cpi	r25, 0x70	; 112
    33f6:	20 f4       	brcc	.+8      	; 0x3400 <vfprintf+0x254>
    33f8:	98 35       	cpi	r25, 0x58	; 88
    33fa:	09 f0       	breq	.+2      	; 0x33fe <vfprintf+0x252>
    33fc:	ac c0       	rjmp	.+344    	; 0x3556 <vfprintf+0x3aa>
    33fe:	0f c0       	rjmp	.+30     	; 0x341e <vfprintf+0x272>
    3400:	90 37       	cpi	r25, 0x70	; 112
    3402:	39 f0       	breq	.+14     	; 0x3412 <vfprintf+0x266>
    3404:	98 37       	cpi	r25, 0x78	; 120
    3406:	09 f0       	breq	.+2      	; 0x340a <vfprintf+0x25e>
    3408:	a6 c0       	rjmp	.+332    	; 0x3556 <vfprintf+0x3aa>
    340a:	04 c0       	rjmp	.+8      	; 0x3414 <vfprintf+0x268>
    340c:	28 e0       	ldi	r18, 0x08	; 8
    340e:	30 e0       	ldi	r19, 0x00	; 0
    3410:	0a c0       	rjmp	.+20     	; 0x3426 <vfprintf+0x27a>
    3412:	10 61       	ori	r17, 0x10	; 16
    3414:	14 fd       	sbrc	r17, 4
    3416:	14 60       	ori	r17, 0x04	; 4
    3418:	20 e1       	ldi	r18, 0x10	; 16
    341a:	30 e0       	ldi	r19, 0x00	; 0
    341c:	04 c0       	rjmp	.+8      	; 0x3426 <vfprintf+0x27a>
    341e:	14 fd       	sbrc	r17, 4
    3420:	16 60       	ori	r17, 0x06	; 6
    3422:	20 e1       	ldi	r18, 0x10	; 16
    3424:	32 e0       	ldi	r19, 0x02	; 2
    3426:	17 ff       	sbrs	r17, 7
    3428:	08 c0       	rjmp	.+16     	; 0x343a <vfprintf+0x28e>
    342a:	f5 01       	movw	r30, r10
    342c:	60 81       	ld	r22, Z
    342e:	71 81       	ldd	r23, Z+1	; 0x01
    3430:	82 81       	ldd	r24, Z+2	; 0x02
    3432:	93 81       	ldd	r25, Z+3	; 0x03
    3434:	44 e0       	ldi	r20, 0x04	; 4
    3436:	50 e0       	ldi	r21, 0x00	; 0
    3438:	08 c0       	rjmp	.+16     	; 0x344a <vfprintf+0x29e>
    343a:	f5 01       	movw	r30, r10
    343c:	80 81       	ld	r24, Z
    343e:	91 81       	ldd	r25, Z+1	; 0x01
    3440:	bc 01       	movw	r22, r24
    3442:	80 e0       	ldi	r24, 0x00	; 0
    3444:	90 e0       	ldi	r25, 0x00	; 0
    3446:	42 e0       	ldi	r20, 0x02	; 2
    3448:	50 e0       	ldi	r21, 0x00	; 0
    344a:	a4 0e       	add	r10, r20
    344c:	b5 1e       	adc	r11, r21
    344e:	a1 01       	movw	r20, r2
    3450:	0e 94 f5 1a 	call	0x35ea	; 0x35ea <__ultoa_invert>
    3454:	d8 2e       	mov	r13, r24
    3456:	d2 18       	sub	r13, r2
    3458:	8f e7       	ldi	r24, 0x7F	; 127
    345a:	f8 2e       	mov	r15, r24
    345c:	f1 22       	and	r15, r17
    345e:	f6 fe       	sbrs	r15, 6
    3460:	0b c0       	rjmp	.+22     	; 0x3478 <vfprintf+0x2cc>
    3462:	5e ef       	ldi	r21, 0xFE	; 254
    3464:	f5 22       	and	r15, r21
    3466:	d9 14       	cp	r13, r9
    3468:	38 f4       	brcc	.+14     	; 0x3478 <vfprintf+0x2cc>
    346a:	f4 fe       	sbrs	r15, 4
    346c:	07 c0       	rjmp	.+14     	; 0x347c <vfprintf+0x2d0>
    346e:	f2 fc       	sbrc	r15, 2
    3470:	05 c0       	rjmp	.+10     	; 0x347c <vfprintf+0x2d0>
    3472:	8f ee       	ldi	r24, 0xEF	; 239
    3474:	f8 22       	and	r15, r24
    3476:	02 c0       	rjmp	.+4      	; 0x347c <vfprintf+0x2d0>
    3478:	1d 2d       	mov	r17, r13
    347a:	01 c0       	rjmp	.+2      	; 0x347e <vfprintf+0x2d2>
    347c:	19 2d       	mov	r17, r9
    347e:	f4 fe       	sbrs	r15, 4
    3480:	0d c0       	rjmp	.+26     	; 0x349c <vfprintf+0x2f0>
    3482:	fe 01       	movw	r30, r28
    3484:	ed 0d       	add	r30, r13
    3486:	f1 1d       	adc	r31, r1
    3488:	80 81       	ld	r24, Z
    348a:	80 33       	cpi	r24, 0x30	; 48
    348c:	19 f4       	brne	.+6      	; 0x3494 <vfprintf+0x2e8>
    348e:	99 ee       	ldi	r25, 0xE9	; 233
    3490:	f9 22       	and	r15, r25
    3492:	08 c0       	rjmp	.+16     	; 0x34a4 <vfprintf+0x2f8>
    3494:	1f 5f       	subi	r17, 0xFF	; 255
    3496:	f2 fe       	sbrs	r15, 2
    3498:	05 c0       	rjmp	.+10     	; 0x34a4 <vfprintf+0x2f8>
    349a:	03 c0       	rjmp	.+6      	; 0x34a2 <vfprintf+0x2f6>
    349c:	8f 2d       	mov	r24, r15
    349e:	86 78       	andi	r24, 0x86	; 134
    34a0:	09 f0       	breq	.+2      	; 0x34a4 <vfprintf+0x2f8>
    34a2:	1f 5f       	subi	r17, 0xFF	; 255
    34a4:	0f 2d       	mov	r16, r15
    34a6:	f3 fc       	sbrc	r15, 3
    34a8:	14 c0       	rjmp	.+40     	; 0x34d2 <vfprintf+0x326>
    34aa:	f0 fe       	sbrs	r15, 0
    34ac:	0f c0       	rjmp	.+30     	; 0x34cc <vfprintf+0x320>
    34ae:	1e 15       	cp	r17, r14
    34b0:	10 f0       	brcs	.+4      	; 0x34b6 <vfprintf+0x30a>
    34b2:	9d 2c       	mov	r9, r13
    34b4:	0b c0       	rjmp	.+22     	; 0x34cc <vfprintf+0x320>
    34b6:	9d 2c       	mov	r9, r13
    34b8:	9e 0c       	add	r9, r14
    34ba:	91 1a       	sub	r9, r17
    34bc:	1e 2d       	mov	r17, r14
    34be:	06 c0       	rjmp	.+12     	; 0x34cc <vfprintf+0x320>
    34c0:	80 e2       	ldi	r24, 0x20	; 32
    34c2:	90 e0       	ldi	r25, 0x00	; 0
    34c4:	b3 01       	movw	r22, r6
    34c6:	0e 94 c9 1a 	call	0x3592	; 0x3592 <fputc>
    34ca:	1f 5f       	subi	r17, 0xFF	; 255
    34cc:	1e 15       	cp	r17, r14
    34ce:	c0 f3       	brcs	.-16     	; 0x34c0 <vfprintf+0x314>
    34d0:	04 c0       	rjmp	.+8      	; 0x34da <vfprintf+0x32e>
    34d2:	1e 15       	cp	r17, r14
    34d4:	10 f4       	brcc	.+4      	; 0x34da <vfprintf+0x32e>
    34d6:	e1 1a       	sub	r14, r17
    34d8:	01 c0       	rjmp	.+2      	; 0x34dc <vfprintf+0x330>
    34da:	ee 24       	eor	r14, r14
    34dc:	04 ff       	sbrs	r16, 4
    34de:	0f c0       	rjmp	.+30     	; 0x34fe <vfprintf+0x352>
    34e0:	80 e3       	ldi	r24, 0x30	; 48
    34e2:	90 e0       	ldi	r25, 0x00	; 0
    34e4:	b3 01       	movw	r22, r6
    34e6:	0e 94 c9 1a 	call	0x3592	; 0x3592 <fputc>
    34ea:	02 ff       	sbrs	r16, 2
    34ec:	1d c0       	rjmp	.+58     	; 0x3528 <vfprintf+0x37c>
    34ee:	01 fd       	sbrc	r16, 1
    34f0:	03 c0       	rjmp	.+6      	; 0x34f8 <vfprintf+0x34c>
    34f2:	88 e7       	ldi	r24, 0x78	; 120
    34f4:	90 e0       	ldi	r25, 0x00	; 0
    34f6:	0e c0       	rjmp	.+28     	; 0x3514 <vfprintf+0x368>
    34f8:	88 e5       	ldi	r24, 0x58	; 88
    34fa:	90 e0       	ldi	r25, 0x00	; 0
    34fc:	0b c0       	rjmp	.+22     	; 0x3514 <vfprintf+0x368>
    34fe:	80 2f       	mov	r24, r16
    3500:	86 78       	andi	r24, 0x86	; 134
    3502:	91 f0       	breq	.+36     	; 0x3528 <vfprintf+0x37c>
    3504:	01 ff       	sbrs	r16, 1
    3506:	02 c0       	rjmp	.+4      	; 0x350c <vfprintf+0x360>
    3508:	8b e2       	ldi	r24, 0x2B	; 43
    350a:	01 c0       	rjmp	.+2      	; 0x350e <vfprintf+0x362>
    350c:	80 e2       	ldi	r24, 0x20	; 32
    350e:	f7 fc       	sbrc	r15, 7
    3510:	8d e2       	ldi	r24, 0x2D	; 45
    3512:	90 e0       	ldi	r25, 0x00	; 0
    3514:	b3 01       	movw	r22, r6
    3516:	0e 94 c9 1a 	call	0x3592	; 0x3592 <fputc>
    351a:	06 c0       	rjmp	.+12     	; 0x3528 <vfprintf+0x37c>
    351c:	80 e3       	ldi	r24, 0x30	; 48
    351e:	90 e0       	ldi	r25, 0x00	; 0
    3520:	b3 01       	movw	r22, r6
    3522:	0e 94 c9 1a 	call	0x3592	; 0x3592 <fputc>
    3526:	9a 94       	dec	r9
    3528:	d9 14       	cp	r13, r9
    352a:	c0 f3       	brcs	.-16     	; 0x351c <vfprintf+0x370>
    352c:	da 94       	dec	r13
    352e:	f1 01       	movw	r30, r2
    3530:	ed 0d       	add	r30, r13
    3532:	f1 1d       	adc	r31, r1
    3534:	80 81       	ld	r24, Z
    3536:	90 e0       	ldi	r25, 0x00	; 0
    3538:	b3 01       	movw	r22, r6
    353a:	0e 94 c9 1a 	call	0x3592	; 0x3592 <fputc>
    353e:	dd 20       	and	r13, r13
    3540:	a9 f7       	brne	.-22     	; 0x352c <vfprintf+0x380>
    3542:	06 c0       	rjmp	.+12     	; 0x3550 <vfprintf+0x3a4>
    3544:	80 e2       	ldi	r24, 0x20	; 32
    3546:	90 e0       	ldi	r25, 0x00	; 0
    3548:	b3 01       	movw	r22, r6
    354a:	0e 94 c9 1a 	call	0x3592	; 0x3592 <fputc>
    354e:	ea 94       	dec	r14
    3550:	ee 20       	and	r14, r14
    3552:	c1 f7       	brne	.-16     	; 0x3544 <vfprintf+0x398>
    3554:	43 ce       	rjmp	.-890    	; 0x31dc <vfprintf+0x30>
    3556:	f3 01       	movw	r30, r6
    3558:	66 81       	ldd	r22, Z+6	; 0x06
    355a:	77 81       	ldd	r23, Z+7	; 0x07
    355c:	cb 01       	movw	r24, r22
    355e:	2b 96       	adiw	r28, 0x0b	; 11
    3560:	e2 e1       	ldi	r30, 0x12	; 18
    3562:	0c 94 b1 1b 	jmp	0x3762	; 0x3762 <__epilogue_restores__>

00003566 <strnlen_P>:
    3566:	fc 01       	movw	r30, r24
    3568:	05 90       	lpm	r0, Z+
    356a:	61 50       	subi	r22, 0x01	; 1
    356c:	70 40       	sbci	r23, 0x00	; 0
    356e:	01 10       	cpse	r0, r1
    3570:	d8 f7       	brcc	.-10     	; 0x3568 <strnlen_P+0x2>
    3572:	80 95       	com	r24
    3574:	90 95       	com	r25
    3576:	8e 0f       	add	r24, r30
    3578:	9f 1f       	adc	r25, r31
    357a:	08 95       	ret

0000357c <strnlen>:
    357c:	fc 01       	movw	r30, r24
    357e:	61 50       	subi	r22, 0x01	; 1
    3580:	70 40       	sbci	r23, 0x00	; 0
    3582:	01 90       	ld	r0, Z+
    3584:	01 10       	cpse	r0, r1
    3586:	d8 f7       	brcc	.-10     	; 0x357e <strnlen+0x2>
    3588:	80 95       	com	r24
    358a:	90 95       	com	r25
    358c:	8e 0f       	add	r24, r30
    358e:	9f 1f       	adc	r25, r31
    3590:	08 95       	ret

00003592 <fputc>:
    3592:	0f 93       	push	r16
    3594:	1f 93       	push	r17
    3596:	cf 93       	push	r28
    3598:	df 93       	push	r29
    359a:	8c 01       	movw	r16, r24
    359c:	eb 01       	movw	r28, r22
    359e:	8b 81       	ldd	r24, Y+3	; 0x03
    35a0:	81 ff       	sbrs	r24, 1
    35a2:	1b c0       	rjmp	.+54     	; 0x35da <fputc+0x48>
    35a4:	82 ff       	sbrs	r24, 2
    35a6:	0d c0       	rjmp	.+26     	; 0x35c2 <fputc+0x30>
    35a8:	2e 81       	ldd	r18, Y+6	; 0x06
    35aa:	3f 81       	ldd	r19, Y+7	; 0x07
    35ac:	8c 81       	ldd	r24, Y+4	; 0x04
    35ae:	9d 81       	ldd	r25, Y+5	; 0x05
    35b0:	28 17       	cp	r18, r24
    35b2:	39 07       	cpc	r19, r25
    35b4:	64 f4       	brge	.+24     	; 0x35ce <fputc+0x3c>
    35b6:	e8 81       	ld	r30, Y
    35b8:	f9 81       	ldd	r31, Y+1	; 0x01
    35ba:	01 93       	st	Z+, r16
    35bc:	f9 83       	std	Y+1, r31	; 0x01
    35be:	e8 83       	st	Y, r30
    35c0:	06 c0       	rjmp	.+12     	; 0x35ce <fputc+0x3c>
    35c2:	e8 85       	ldd	r30, Y+8	; 0x08
    35c4:	f9 85       	ldd	r31, Y+9	; 0x09
    35c6:	80 2f       	mov	r24, r16
    35c8:	09 95       	icall
    35ca:	89 2b       	or	r24, r25
    35cc:	31 f4       	brne	.+12     	; 0x35da <fputc+0x48>
    35ce:	8e 81       	ldd	r24, Y+6	; 0x06
    35d0:	9f 81       	ldd	r25, Y+7	; 0x07
    35d2:	01 96       	adiw	r24, 0x01	; 1
    35d4:	9f 83       	std	Y+7, r25	; 0x07
    35d6:	8e 83       	std	Y+6, r24	; 0x06
    35d8:	02 c0       	rjmp	.+4      	; 0x35de <fputc+0x4c>
    35da:	0f ef       	ldi	r16, 0xFF	; 255
    35dc:	1f ef       	ldi	r17, 0xFF	; 255
    35de:	c8 01       	movw	r24, r16
    35e0:	df 91       	pop	r29
    35e2:	cf 91       	pop	r28
    35e4:	1f 91       	pop	r17
    35e6:	0f 91       	pop	r16
    35e8:	08 95       	ret

000035ea <__ultoa_invert>:
    35ea:	fa 01       	movw	r30, r20
    35ec:	aa 27       	eor	r26, r26
    35ee:	28 30       	cpi	r18, 0x08	; 8
    35f0:	51 f1       	breq	.+84     	; 0x3646 <__ultoa_invert+0x5c>
    35f2:	20 31       	cpi	r18, 0x10	; 16
    35f4:	81 f1       	breq	.+96     	; 0x3656 <__ultoa_invert+0x6c>
    35f6:	e8 94       	clt
    35f8:	6f 93       	push	r22
    35fa:	6e 7f       	andi	r22, 0xFE	; 254
    35fc:	6e 5f       	subi	r22, 0xFE	; 254
    35fe:	7f 4f       	sbci	r23, 0xFF	; 255
    3600:	8f 4f       	sbci	r24, 0xFF	; 255
    3602:	9f 4f       	sbci	r25, 0xFF	; 255
    3604:	af 4f       	sbci	r26, 0xFF	; 255
    3606:	b1 e0       	ldi	r27, 0x01	; 1
    3608:	3e d0       	rcall	.+124    	; 0x3686 <__ultoa_invert+0x9c>
    360a:	b4 e0       	ldi	r27, 0x04	; 4
    360c:	3c d0       	rcall	.+120    	; 0x3686 <__ultoa_invert+0x9c>
    360e:	67 0f       	add	r22, r23
    3610:	78 1f       	adc	r23, r24
    3612:	89 1f       	adc	r24, r25
    3614:	9a 1f       	adc	r25, r26
    3616:	a1 1d       	adc	r26, r1
    3618:	68 0f       	add	r22, r24
    361a:	79 1f       	adc	r23, r25
    361c:	8a 1f       	adc	r24, r26
    361e:	91 1d       	adc	r25, r1
    3620:	a1 1d       	adc	r26, r1
    3622:	6a 0f       	add	r22, r26
    3624:	71 1d       	adc	r23, r1
    3626:	81 1d       	adc	r24, r1
    3628:	91 1d       	adc	r25, r1
    362a:	a1 1d       	adc	r26, r1
    362c:	20 d0       	rcall	.+64     	; 0x366e <__ultoa_invert+0x84>
    362e:	09 f4       	brne	.+2      	; 0x3632 <__ultoa_invert+0x48>
    3630:	68 94       	set
    3632:	3f 91       	pop	r19
    3634:	2a e0       	ldi	r18, 0x0A	; 10
    3636:	26 9f       	mul	r18, r22
    3638:	11 24       	eor	r1, r1
    363a:	30 19       	sub	r19, r0
    363c:	30 5d       	subi	r19, 0xD0	; 208
    363e:	31 93       	st	Z+, r19
    3640:	de f6       	brtc	.-74     	; 0x35f8 <__ultoa_invert+0xe>
    3642:	cf 01       	movw	r24, r30
    3644:	08 95       	ret
    3646:	46 2f       	mov	r20, r22
    3648:	47 70       	andi	r20, 0x07	; 7
    364a:	40 5d       	subi	r20, 0xD0	; 208
    364c:	41 93       	st	Z+, r20
    364e:	b3 e0       	ldi	r27, 0x03	; 3
    3650:	0f d0       	rcall	.+30     	; 0x3670 <__ultoa_invert+0x86>
    3652:	c9 f7       	brne	.-14     	; 0x3646 <__ultoa_invert+0x5c>
    3654:	f6 cf       	rjmp	.-20     	; 0x3642 <__ultoa_invert+0x58>
    3656:	46 2f       	mov	r20, r22
    3658:	4f 70       	andi	r20, 0x0F	; 15
    365a:	40 5d       	subi	r20, 0xD0	; 208
    365c:	4a 33       	cpi	r20, 0x3A	; 58
    365e:	18 f0       	brcs	.+6      	; 0x3666 <__ultoa_invert+0x7c>
    3660:	49 5d       	subi	r20, 0xD9	; 217
    3662:	31 fd       	sbrc	r19, 1
    3664:	40 52       	subi	r20, 0x20	; 32
    3666:	41 93       	st	Z+, r20
    3668:	02 d0       	rcall	.+4      	; 0x366e <__ultoa_invert+0x84>
    366a:	a9 f7       	brne	.-22     	; 0x3656 <__ultoa_invert+0x6c>
    366c:	ea cf       	rjmp	.-44     	; 0x3642 <__ultoa_invert+0x58>
    366e:	b4 e0       	ldi	r27, 0x04	; 4
    3670:	a6 95       	lsr	r26
    3672:	97 95       	ror	r25
    3674:	87 95       	ror	r24
    3676:	77 95       	ror	r23
    3678:	67 95       	ror	r22
    367a:	ba 95       	dec	r27
    367c:	c9 f7       	brne	.-14     	; 0x3670 <__ultoa_invert+0x86>
    367e:	00 97       	sbiw	r24, 0x00	; 0
    3680:	61 05       	cpc	r22, r1
    3682:	71 05       	cpc	r23, r1
    3684:	08 95       	ret
    3686:	9b 01       	movw	r18, r22
    3688:	ac 01       	movw	r20, r24
    368a:	0a 2e       	mov	r0, r26
    368c:	06 94       	lsr	r0
    368e:	57 95       	ror	r21
    3690:	47 95       	ror	r20
    3692:	37 95       	ror	r19
    3694:	27 95       	ror	r18
    3696:	ba 95       	dec	r27
    3698:	c9 f7       	brne	.-14     	; 0x368c <__ultoa_invert+0xa2>
    369a:	62 0f       	add	r22, r18
    369c:	73 1f       	adc	r23, r19
    369e:	84 1f       	adc	r24, r20
    36a0:	95 1f       	adc	r25, r21
    36a2:	a0 1d       	adc	r26, r0
    36a4:	08 95       	ret

000036a6 <__udivmodqi4>:
    36a6:	99 1b       	sub	r25, r25
    36a8:	79 e0       	ldi	r23, 0x09	; 9
    36aa:	04 c0       	rjmp	.+8      	; 0x36b4 <__udivmodqi4_ep>

000036ac <__udivmodqi4_loop>:
    36ac:	99 1f       	adc	r25, r25
    36ae:	96 17       	cp	r25, r22
    36b0:	08 f0       	brcs	.+2      	; 0x36b4 <__udivmodqi4_ep>
    36b2:	96 1b       	sub	r25, r22

000036b4 <__udivmodqi4_ep>:
    36b4:	88 1f       	adc	r24, r24
    36b6:	7a 95       	dec	r23
    36b8:	c9 f7       	brne	.-14     	; 0x36ac <__udivmodqi4_loop>
    36ba:	80 95       	com	r24
    36bc:	08 95       	ret

000036be <__udivmodhi4>:
    36be:	aa 1b       	sub	r26, r26
    36c0:	bb 1b       	sub	r27, r27
    36c2:	51 e1       	ldi	r21, 0x11	; 17
    36c4:	07 c0       	rjmp	.+14     	; 0x36d4 <__udivmodhi4_ep>

000036c6 <__udivmodhi4_loop>:
    36c6:	aa 1f       	adc	r26, r26
    36c8:	bb 1f       	adc	r27, r27
    36ca:	a6 17       	cp	r26, r22
    36cc:	b7 07       	cpc	r27, r23
    36ce:	10 f0       	brcs	.+4      	; 0x36d4 <__udivmodhi4_ep>
    36d0:	a6 1b       	sub	r26, r22
    36d2:	b7 0b       	sbc	r27, r23

000036d4 <__udivmodhi4_ep>:
    36d4:	88 1f       	adc	r24, r24
    36d6:	99 1f       	adc	r25, r25
    36d8:	5a 95       	dec	r21
    36da:	a9 f7       	brne	.-22     	; 0x36c6 <__udivmodhi4_loop>
    36dc:	80 95       	com	r24
    36de:	90 95       	com	r25
    36e0:	bc 01       	movw	r22, r24
    36e2:	cd 01       	movw	r24, r26
    36e4:	08 95       	ret

000036e6 <__udivmodsi4>:
    36e6:	a1 e2       	ldi	r26, 0x21	; 33
    36e8:	1a 2e       	mov	r1, r26
    36ea:	aa 1b       	sub	r26, r26
    36ec:	bb 1b       	sub	r27, r27
    36ee:	fd 01       	movw	r30, r26
    36f0:	0d c0       	rjmp	.+26     	; 0x370c <__udivmodsi4_ep>

000036f2 <__udivmodsi4_loop>:
    36f2:	aa 1f       	adc	r26, r26
    36f4:	bb 1f       	adc	r27, r27
    36f6:	ee 1f       	adc	r30, r30
    36f8:	ff 1f       	adc	r31, r31
    36fa:	a2 17       	cp	r26, r18
    36fc:	b3 07       	cpc	r27, r19
    36fe:	e4 07       	cpc	r30, r20
    3700:	f5 07       	cpc	r31, r21
    3702:	20 f0       	brcs	.+8      	; 0x370c <__udivmodsi4_ep>
    3704:	a2 1b       	sub	r26, r18
    3706:	b3 0b       	sbc	r27, r19
    3708:	e4 0b       	sbc	r30, r20
    370a:	f5 0b       	sbc	r31, r21

0000370c <__udivmodsi4_ep>:
    370c:	66 1f       	adc	r22, r22
    370e:	77 1f       	adc	r23, r23
    3710:	88 1f       	adc	r24, r24
    3712:	99 1f       	adc	r25, r25
    3714:	1a 94       	dec	r1
    3716:	69 f7       	brne	.-38     	; 0x36f2 <__udivmodsi4_loop>
    3718:	60 95       	com	r22
    371a:	70 95       	com	r23
    371c:	80 95       	com	r24
    371e:	90 95       	com	r25
    3720:	9b 01       	movw	r18, r22
    3722:	ac 01       	movw	r20, r24
    3724:	bd 01       	movw	r22, r26
    3726:	cf 01       	movw	r24, r30
    3728:	08 95       	ret

0000372a <__prologue_saves__>:
    372a:	2f 92       	push	r2
    372c:	3f 92       	push	r3
    372e:	4f 92       	push	r4
    3730:	5f 92       	push	r5
    3732:	6f 92       	push	r6
    3734:	7f 92       	push	r7
    3736:	8f 92       	push	r8
    3738:	9f 92       	push	r9
    373a:	af 92       	push	r10
    373c:	bf 92       	push	r11
    373e:	cf 92       	push	r12
    3740:	df 92       	push	r13
    3742:	ef 92       	push	r14
    3744:	ff 92       	push	r15
    3746:	0f 93       	push	r16
    3748:	1f 93       	push	r17
    374a:	cf 93       	push	r28
    374c:	df 93       	push	r29
    374e:	cd b7       	in	r28, 0x3d	; 61
    3750:	de b7       	in	r29, 0x3e	; 62
    3752:	ca 1b       	sub	r28, r26
    3754:	db 0b       	sbc	r29, r27
    3756:	0f b6       	in	r0, 0x3f	; 63
    3758:	f8 94       	cli
    375a:	de bf       	out	0x3e, r29	; 62
    375c:	0f be       	out	0x3f, r0	; 63
    375e:	cd bf       	out	0x3d, r28	; 61
    3760:	09 94       	ijmp

00003762 <__epilogue_restores__>:
    3762:	2a 88       	ldd	r2, Y+18	; 0x12
    3764:	39 88       	ldd	r3, Y+17	; 0x11
    3766:	48 88       	ldd	r4, Y+16	; 0x10
    3768:	5f 84       	ldd	r5, Y+15	; 0x0f
    376a:	6e 84       	ldd	r6, Y+14	; 0x0e
    376c:	7d 84       	ldd	r7, Y+13	; 0x0d
    376e:	8c 84       	ldd	r8, Y+12	; 0x0c
    3770:	9b 84       	ldd	r9, Y+11	; 0x0b
    3772:	aa 84       	ldd	r10, Y+10	; 0x0a
    3774:	b9 84       	ldd	r11, Y+9	; 0x09
    3776:	c8 84       	ldd	r12, Y+8	; 0x08
    3778:	df 80       	ldd	r13, Y+7	; 0x07
    377a:	ee 80       	ldd	r14, Y+6	; 0x06
    377c:	fd 80       	ldd	r15, Y+5	; 0x05
    377e:	0c 81       	ldd	r16, Y+4	; 0x04
    3780:	1b 81       	ldd	r17, Y+3	; 0x03
    3782:	aa 81       	ldd	r26, Y+2	; 0x02
    3784:	b9 81       	ldd	r27, Y+1	; 0x01
    3786:	ce 0f       	add	r28, r30
    3788:	d1 1d       	adc	r29, r1
    378a:	0f b6       	in	r0, 0x3f	; 63
    378c:	f8 94       	cli
    378e:	de bf       	out	0x3e, r29	; 62
    3790:	0f be       	out	0x3f, r0	; 63
    3792:	cd bf       	out	0x3d, r28	; 61
    3794:	ed 01       	movw	r28, r26
    3796:	08 95       	ret

00003798 <_exit>:
    3798:	f8 94       	cli

0000379a <__stop_program>:
    379a:	ff cf       	rjmp	.-2      	; 0x379a <__stop_program>
