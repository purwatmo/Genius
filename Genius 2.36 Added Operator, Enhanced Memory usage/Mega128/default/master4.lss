
master4.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000004e  00800100  00016f18  00016fcc  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00016f18  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000c9e  0080014e  0080014e  0001701a  2**0
                  ALLOC
  3 .eeprom       00000857  00810000  00810000  0001701a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .debug_aranges 000000e0  00000000  00000000  00017871  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_pubnames 00002701  00000000  00000000  00017951  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00013596  00000000  00000000  0001a052  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000c3b  00000000  00000000  0002d5e8  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000e0e6  00000000  00000000  0002e223  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000011f0  00000000  00000000  0003c30c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000533c  00000000  00000000  0003d4fc  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00007974  00000000  00000000  00042838  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000720  00000000  00000000  0004a1ac  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 48 12 	jmp	0x2490	; 0x2490 <__ctors_end>
       4:	0c 94 67 12 	jmp	0x24ce	; 0x24ce <__bad_interrupt>
       8:	0c 94 67 12 	jmp	0x24ce	; 0x24ce <__bad_interrupt>
       c:	0c 94 67 12 	jmp	0x24ce	; 0x24ce <__bad_interrupt>
      10:	0c 94 67 12 	jmp	0x24ce	; 0x24ce <__bad_interrupt>
      14:	0c 94 67 12 	jmp	0x24ce	; 0x24ce <__bad_interrupt>
      18:	0c 94 67 12 	jmp	0x24ce	; 0x24ce <__bad_interrupt>
      1c:	0c 94 67 12 	jmp	0x24ce	; 0x24ce <__bad_interrupt>
      20:	0c 94 67 12 	jmp	0x24ce	; 0x24ce <__bad_interrupt>
      24:	0c 94 67 12 	jmp	0x24ce	; 0x24ce <__bad_interrupt>
      28:	0c 94 67 12 	jmp	0x24ce	; 0x24ce <__bad_interrupt>
      2c:	0c 94 67 12 	jmp	0x24ce	; 0x24ce <__bad_interrupt>
      30:	0c 94 11 13 	jmp	0x2622	; 0x2622 <__vector_12>
      34:	0c 94 67 12 	jmp	0x24ce	; 0x24ce <__bad_interrupt>
      38:	0c 94 67 12 	jmp	0x24ce	; 0x24ce <__bad_interrupt>
      3c:	0c 94 67 12 	jmp	0x24ce	; 0x24ce <__bad_interrupt>
      40:	0c 94 67 12 	jmp	0x24ce	; 0x24ce <__bad_interrupt>
      44:	0c 94 9f 7d 	jmp	0xfb3e	; 0xfb3e <__vector_17>
      48:	0c 94 ad 14 	jmp	0x295a	; 0x295a <__vector_18>
      4c:	0c 94 67 12 	jmp	0x24ce	; 0x24ce <__bad_interrupt>
      50:	0c 94 67 12 	jmp	0x24ce	; 0x24ce <__bad_interrupt>
      54:	0c 94 67 12 	jmp	0x24ce	; 0x24ce <__bad_interrupt>
      58:	0c 94 67 12 	jmp	0x24ce	; 0x24ce <__bad_interrupt>
      5c:	0c 94 67 12 	jmp	0x24ce	; 0x24ce <__bad_interrupt>
      60:	0c 94 67 12 	jmp	0x24ce	; 0x24ce <__bad_interrupt>
      64:	0c 94 67 12 	jmp	0x24ce	; 0x24ce <__bad_interrupt>
      68:	0c 94 67 12 	jmp	0x24ce	; 0x24ce <__bad_interrupt>
      6c:	0c 94 67 12 	jmp	0x24ce	; 0x24ce <__bad_interrupt>
      70:	0c 94 67 12 	jmp	0x24ce	; 0x24ce <__bad_interrupt>
      74:	0c 94 67 12 	jmp	0x24ce	; 0x24ce <__bad_interrupt>
      78:	0c 94 60 41 	jmp	0x82c0	; 0x82c0 <__vector_30>
      7c:	0c 94 67 12 	jmp	0x24ce	; 0x24ce <__bad_interrupt>
      80:	0c 94 67 12 	jmp	0x24ce	; 0x24ce <__bad_interrupt>
      84:	0c 94 67 12 	jmp	0x24ce	; 0x24ce <__bad_interrupt>
      88:	0c 94 67 12 	jmp	0x24ce	; 0x24ce <__bad_interrupt>
      8c:	8c 13       	cpse	r24, r28
      8e:	8a 13       	cpse	r24, r26
      90:	8e 13       	cpse	r24, r30
      92:	90 13       	cpse	r25, r16
      94:	92 13       	cpse	r25, r18
      96:	94 13       	cpse	r25, r20
      98:	96 13       	cpse	r25, r22
      9a:	98 13       	cpse	r25, r24
      9c:	9a 13       	cpse	r25, r26
      9e:	9c 13       	cpse	r25, r28
      a0:	9e 13       	cpse	r25, r30
      a2:	a0 13       	cpse	r26, r16
      a4:	a2 13       	cpse	r26, r18
      a6:	b0 13       	cpse	r27, r16
      a8:	a4 13       	cpse	r26, r20
      aa:	b0 13       	cpse	r27, r16
      ac:	a6 13       	cpse	r26, r22
      ae:	a8 13       	cpse	r26, r24
      b0:	b0 13       	cpse	r27, r16
      b2:	aa 13       	cpse	r26, r26
      b4:	ac 13       	cpse	r26, r28
      b6:	ae 13       	cpse	r26, r30
      b8:	b0 13       	cpse	r27, r16
      ba:	b0 13       	cpse	r27, r16
      bc:	a4 13       	cpse	r26, r20
      be:	96 13       	cpse	r25, r22
      c0:	b0 13       	cpse	r27, r16
      c2:	98 13       	cpse	r25, r24
      c4:	9c 13       	cpse	r25, r28
      c6:	a0 13       	cpse	r26, r16
      c8:	ed 53       	subi	r30, 0x3D	; 61
      ca:	05 54       	subi	r16, 0x45	; 69
      cc:	17 54       	subi	r17, 0x47	; 71
      ce:	4e 54       	subi	r20, 0x4E	; 78
      d0:	7d 54       	subi	r23, 0x4D	; 77
      d2:	93 54       	subi	r25, 0x43	; 67
      d4:	ce 54       	subi	r28, 0x4E	; 78
      d6:	06 55       	subi	r16, 0x56	; 86
      d8:	48 55       	subi	r20, 0x58	; 88
      da:	50 55       	subi	r21, 0x50	; 80
      dc:	68 56       	subi	r22, 0x68	; 104
      de:	74 56       	subi	r23, 0x64	; 100
      e0:	a6 56       	subi	r26, 0x66	; 102
      e2:	e3 56       	subi	r30, 0x63	; 99
      e4:	00 57       	subi	r16, 0x70	; 112
      e6:	1a 57       	subi	r17, 0x7A	; 122
      e8:	5a 57       	subi	r21, 0x7A	; 122
      ea:	63 54       	subi	r22, 0x43	; 67
      ec:	20 55       	subi	r18, 0x50	; 80
      ee:	bf 56       	subi	r27, 0x6F	; 111
      f0:	ec 54       	subi	r30, 0x4C	; 76
      f2:	68 55       	subi	r22, 0x58	; 88
      f4:	ac 55       	subi	r26, 0x5C	; 92
      f6:	c8 55       	subi	r28, 0x58	; 88
      f8:	e2 55       	subi	r30, 0x52	; 82
      fa:	30 56       	subi	r19, 0x60	; 96
      fc:	4e 56       	subi	r20, 0x6E	; 110
      fe:	92 57       	subi	r25, 0x72	; 114
     100:	a8 57       	subi	r26, 0x78	; 120
     102:	ad 57       	subi	r26, 0x7D	; 125
     104:	e6 57       	subi	r30, 0x76	; 118
     106:	15 58       	subi	r17, 0x85	; 133
     108:	5a 58       	subi	r21, 0x8A	; 138
     10a:	78 58       	subi	r23, 0x88	; 136
     10c:	96 58       	subi	r25, 0x86	; 134
     10e:	d0 58       	subi	r29, 0x80	; 128
     110:	33 59       	subi	r19, 0x93	; 147
     112:	77 5d       	subi	r23, 0xD7	; 215
     114:	fb 57       	subi	r31, 0x7B	; 123
     116:	a0 5d       	subi	r26, 0xD0	; 208
     118:	8d 5e       	subi	r24, 0xED	; 237
     11a:	49 5e       	subi	r20, 0xE9	; 233
     11c:	74 5e       	subi	r23, 0xE4	; 228
     11e:	c7 5e       	subi	r28, 0xE7	; 231
     120:	a7 5e       	subi	r26, 0xE7	; 231
     122:	de 5e       	subi	r29, 0xEE	; 238
     124:	f7 5e       	subi	r31, 0xE7	; 231
     126:	09 5f       	subi	r16, 0xF9	; 249
     128:	ba 5d       	subi	r27, 0xDA	; 218
     12a:	12 5e       	subi	r17, 0xE2	; 226
     12c:	2f 5e       	subi	r18, 0xEF	; 239
     12e:	43 59       	subi	r20, 0x93	; 147
     130:	63 59       	subi	r22, 0x93	; 147
     132:	8a 59       	subi	r24, 0x9A	; 154
     134:	99 59       	subi	r25, 0x99	; 153
     136:	b7 59       	subi	r27, 0x97	; 151
     138:	ce 59       	subi	r28, 0x9E	; 158
     13a:	fa 59       	subi	r31, 0x9A	; 154
     13c:	11 5a       	subi	r17, 0xA1	; 161
     13e:	3d 5a       	subi	r19, 0xAD	; 173
     140:	5d 5a       	subi	r21, 0xAD	; 173
     142:	8e 5a       	subi	r24, 0xAE	; 174
     144:	9d 5a       	subi	r25, 0xAD	; 173
     146:	f6 5a       	subi	r31, 0xA6	; 166
     148:	6d 5b       	subi	r22, 0xBD	; 189
     14a:	81 5b       	subi	r24, 0xB1	; 177
     14c:	5c 5c       	subi	r21, 0xCC	; 204
     14e:	5c 5c       	subi	r21, 0xCC	; 204
     150:	95 5b       	subi	r25, 0xB5	; 181
     152:	a9 5b       	subi	r26, 0xB9	; 185
     154:	b1 5b       	subi	r27, 0xB1	; 177
     156:	cd 5b       	subi	r28, 0xBD	; 189
     158:	e1 5b       	subi	r30, 0xB1	; 177
     15a:	ee 5b       	subi	r30, 0xBE	; 190
     15c:	05 5c       	subi	r16, 0xC5	; 197
     15e:	1c 5c       	subi	r17, 0xCC	; 204
     160:	3a 5c       	subi	r19, 0xCA	; 202
     162:	5f 5c       	subi	r21, 0xCF	; 207
     164:	76 5c       	subi	r23, 0xC6	; 198
     166:	8d 5c       	subi	r24, 0xCD	; 205
     168:	a4 5c       	subi	r26, 0xC4	; 196
     16a:	bb 5c       	subi	r27, 0xCB	; 203
     16c:	d2 5c       	subi	r29, 0xC2	; 194
     16e:	e9 5c       	subi	r30, 0xC9	; 201
     170:	00 5d       	subi	r16, 0xD0	; 208
     172:	0f 5d       	subi	r16, 0xDF	; 223
     174:	26 5d       	subi	r18, 0xD6	; 214
     176:	49 5d       	subi	r20, 0xD9	; 217
     178:	6a 90       	ld	r6, -Y
     17a:	86 90       	elpm	r8, Z+
     17c:	99 90       	ld	r9, Y+
     17e:	c8 90       	.word	0x90c8	; ????
     180:	f1 90       	ld	r15, Z+
     182:	64 91       	lpm	r22, Z+
     184:	73 91       	.word	0x9173	; ????
     186:	7c 91       	ld	r23, X
     188:	b8 91       	.word	0x91b8	; ????
     18a:	df 91       	pop	r29
     18c:	26 92       	.word	0x9226	; ????
     18e:	30 92 eb 91 	sts	0x91EB, r3
     192:	36 92       	.word	0x9236	; ????
     194:	96 90       	elpm	r9, Z+
     196:	45 92       	.word	0x9245	; ????
     198:	4b 92       	.word	0x924b	; ????
     19a:	e3 94       	inc	r14
     19c:	e7 94       	ror	r14
     19e:	03 95       	inc	r16
     1a0:	e7 98       	cbi	0x1c, 7	; 28
     1a2:	e7 98       	cbi	0x1c, 7	; 28
     1a4:	e7 98       	cbi	0x1c, 7	; 28
     1a6:	e7 98       	cbi	0x1c, 7	; 28
     1a8:	4c 95 e7 98 	jmp	0x5131ce	; 0x5131ce <__data_load_end+0x4fc268>
     1ac:	6c 95 e7 98 	jmp	0x5931ce	; 0x5931ce <__data_load_end+0x57c268>
     1b0:	89 95       	.word	0x9589	; ????
     1b2:	12 96       	adiw	r26, 0x02	; 2
     1b4:	6d 96       	adiw	r28, 0x1d	; 29
     1b6:	90 96       	adiw	r26, 0x20	; 32
     1b8:	2f 95 e7 98 	call	0x4b31ce	; 0x4b31ce <__data_load_end+0x49c268>
     1bc:	25 96       	adiw	r28, 0x05	; 5
     1be:	a8 96       	adiw	r28, 0x28	; 40
     1c0:	e0 96       	adiw	r28, 0x30	; 48
     1c2:	f8 96       	adiw	r30, 0x38	; 56
     1c4:	34 97       	sbiw	r30, 0x04	; 4
     1c6:	44 97       	sbiw	r24, 0x14	; 20
     1c8:	55 98       	cbi	0x0a, 5	; 10
     1ca:	65 98       	cbi	0x0c, 5	; 12
     1cc:	aa 98       	cbi	0x15, 2	; 21
     1ce:	c9 98       	cbi	0x19, 1	; 25
     1d0:	db 98       	cbi	0x1b, 3	; 27
     1d2:	e1 98       	cbi	0x1c, 1	; 28
     1d4:	e3 98       	cbi	0x1c, 3	; 28
     1d6:	de 9a       	sbi	0x1b, 6	; 27
     1d8:	e4 9a       	sbi	0x1c, 4	; 28
     1da:	e8 9a       	sbi	0x1d, 0	; 29
     1dc:	ff 9a       	sbi	0x1f, 7	; 31
     1de:	19 9b       	sbis	0x03, 1	; 3
     1e0:	1d 9b       	sbis	0x03, 5	; 3
     1e2:	48 9b       	sbis	0x09, 0	; 9
     1e4:	62 9b       	sbis	0x0c, 2	; 12
     1e6:	68 9b       	sbis	0x0d, 0	; 13
     1e8:	70 9b       	sbis	0x0e, 0	; 14
     1ea:	73 9b       	sbis	0x0e, 3	; 14
     1ec:	76 9b       	sbis	0x0e, 6	; 14
     1ee:	79 9b       	sbis	0x0f, 1	; 15
     1f0:	7c 9b       	sbis	0x0f, 4	; 15
     1f2:	7f 9b       	sbis	0x0f, 7	; 15
     1f4:	83 9b       	sbis	0x10, 3	; 16
     1f6:	86 9b       	sbis	0x10, 6	; 16
     1f8:	89 9b       	sbis	0x11, 1	; 17
     1fa:	91 9b       	sbis	0x12, 1	; 18
     1fc:	52 9d       	mul	r21, r2
     1fe:	a7 9d       	mul	r26, r7
     200:	b6 9d       	mul	r27, r6
     202:	f8 9d       	mul	r31, r8
     204:	0a 9e       	mul	r0, r26
     206:	1f 9e       	mul	r1, r31
     208:	42 9e       	mul	r4, r18
     20a:	f8 9e       	mul	r15, r24
     20c:	02 9f       	mul	r16, r18
     20e:	d6 a5       	ldd	r29, Z+46	; 0x2e
     210:	61 9f       	mul	r22, r17
     212:	6e a0       	ldd	r6, Y+38	; 0x26
     214:	bd a0       	ldd	r11, Y+37	; 0x25
     216:	03 a1       	ldd	r16, Z+35	; 0x23
     218:	7b a1       	ldd	r23, Y+35	; 0x23
     21a:	0c a2       	std	Y+36, r0	; 0x24
     21c:	2f a2       	std	Y+39, r2	; 0x27
     21e:	f5 a2       	std	Z+37, r15	; 0x25
     220:	1f a3       	std	Y+39, r17	; 0x27
     222:	d8 a3       	std	Y+32, r29	; 0x20
     224:	f1 a3       	std	Z+33, r31	; 0x21
     226:	fb a4       	ldd	r15, Y+43	; 0x2b
     228:	69 a4       	ldd	r6, Y+41	; 0x29
     22a:	ab a4       	ldd	r10, Y+43	; 0x2b
     22c:	95 a5       	ldd	r25, Z+45	; 0x2d
     22e:	c3 a5       	ldd	r28, Z+43	; 0x2b
     230:	d6 a5       	ldd	r29, Z+46	; 0x2e
     232:	01 a5       	ldd	r16, Z+41	; 0x29
     234:	84 a5       	ldd	r24, Z+44	; 0x2c
     236:	c8 a5       	ldd	r28, Y+40	; 0x28
     238:	cf a5       	ldd	r28, Y+47	; 0x2f
     23a:	38 aa       	std	Y+48, r3	; 0x30
     23c:	3b aa       	std	Y+51, r3	; 0x33
     23e:	db aa       	std	Y+51, r13	; 0x33
     240:	ea aa       	std	Y+50, r14	; 0x32
     242:	1d ab       	std	Y+53, r17	; 0x35
     244:	2b ab       	std	Y+51, r18	; 0x33
     246:	57 ab       	std	Z+55, r21	; 0x37
     248:	fa aa       	std	Y+50, r15	; 0x32
     24a:	09 ab       	std	Y+49, r16	; 0x31
     24c:	13 ab       	std	Z+51, r17	; 0x33
     24e:	61 ab       	std	Z+49, r22	; 0x31
     250:	6e ab       	std	Y+54, r22	; 0x36
     252:	79 ab       	std	Y+49, r23	; 0x31
     254:	7c ab       	std	Y+52, r23	; 0x34
     256:	7f ab       	std	Y+55, r23	; 0x37
     258:	82 ab       	std	Z+50, r24	; 0x32
     25a:	85 ab       	std	Z+53, r24	; 0x35
     25c:	88 ab       	std	Y+48, r24	; 0x30
     25e:	8b ab       	std	Y+51, r24	; 0x33
     260:	8e ab       	std	Y+54, r24	; 0x36
     262:	b0 ab       	std	Z+48, r27	; 0x30
     264:	9e ab       	std	Y+54, r25	; 0x36
     266:	91 ab       	std	Z+49, r25	; 0x31
     268:	a9 ab       	std	Y+49, r26	; 0x31
     26a:	c5 aa       	std	Z+53, r12	; 0x35

0000026c <__c.3007>:
     26c:	49 6e 69 74 69 61 6c 69 7a 65 2e 2e 2e 20 00        Initialize... .

0000027b <__c.2991>:
     27b:	57 61 74 63 68 44 6f 67 00                          WatchDog.

00000284 <__c.2989>:
     284:	42 72 6f 77 6e 4f 75 74 00                          BrownOut.

0000028d <__c.2987>:
     28d:	45 78 74 65 72 6e 61 6c 00                          External.

00000296 <__c.2985>:
     296:	50 6f 77 65 72 4f 6e 00                             PowerOn.

0000029e <__prodloc>:
     29e:	01 06 02 06 01 0d 02 0d 01 14 02 14                 ............

000002aa <__prntloc>:
     2aa:	01 08 02 08 03 08 04 08 01 13 02 13                 ............

000002b6 <__prntlmt>:
     2b6:	02 03 04 02 0f 0f                                   ......

000002bc <__prntstr>:
     2bc:	01 01 00 00 00 00                                   ......

000002c2 <__hostloc>:
     2c2:	01 0a 02 0a 03 0a                                   ......

000002c8 <MaxKeyHit>:
     2c8:	02 04 03 03 03 03 03 04 03 04                       ..........

000002d2 <strDispenserName1>:
     2d2:	4e 2f 41 00                                         N/A.

000002d6 <strDispenserName2>:
     2d6:	47 69 6c 62 61 72 63 6f 00                          Gilbarco.

000002df <strDispenserName3>:
     2df:	57 61 79 6e 65 20 44 41 52 54 00                    Wayne DART.

000002ea <strDispenserName4>:
     2ea:	54 61 74 73 75 6e 6f 00                             Tatsuno.

000002f2 <strDispenserName5>:
     2f2:	4c 47 00                                            LG.

000002f5 <DefListDispenserName>:
     2f5:	d2 02 d6 02 df 02 ea 02 f2 02                       ..........

000002ff <__c.9961>:
     2ff:	4d 72 2e 42 69 67 00                                Mr.Big.

00000306 <__c.9866>:
     306:	25 64 00                                            %d.

00000309 <__c.9864>:
     309:	54 25 2e 32 64 25 2e 32 64 25 73 25 73 25 73 25     T%.2d%.2d%s%s%s%
     319:	73 25 73 25 73 3a 00                                s%s%s:.

00000320 <__c.9815>:
     320:	32 30 25 73 2f 25 73 2f 25 73 20 25 73 3a 25 73     20%s/%s/%s %s:%s
     330:	3a 25 73 00                                         :%s.

00000334 <__c.9787>:
     334:	25 73 00                                            %s.

00000337 <__c.9778>:
     337:	25 73 00                                            %s.

0000033a <__c.9727>:
     33a:	25 63 25 2e 32 64 3a 00                             %c%.2d:.

00000342 <__c.9706>:
     342:	43 54 53 52 50 00                                   CTSRP.

00000348 <__c.9682>:
     348:	3a 00                                               :.

0000034a <__c.9626>:
     34a:	46 6d 74 54 4d 6f 6e 65 79 3a 25 73 00              FmtTMoney:%s.

00000357 <__c.9624>:
     357:	46 6d 74 4d 6f 6e 65 79 3a 25 73 00                 FmtMoney:%s.

00000363 <__c.9622>:
     363:	54 4d 6f 6e 65 79 3a 25 73 00                       TMoney:%s.

0000036d <__c.9620>:
     36d:	54 56 6f 6c 75 6d 65 3a 25 73 00                    TVolume:%s.

00000378 <__c.9618>:
     378:	4d 6f 6e 65 79 3a 25 73 00                          Money:%s.

00000381 <__c.9616>:
     381:	56 6f 6c 75 6d 65 3a 25 73 00                       Volume:%s.

0000038b <__c.9614>:
     38b:	52 65 6d 6f 76 65 64 3a 25 73 00                    Removed:%s.

00000396 <__c.9612>:
     396:	4d 69 6e 75 73 3a 25 73 00                          Minus:%s.

0000039f <__c.9610>:
     39f:	52 61 77 3a 25 73 00                                Raw:%s.

000003a6 <__c.9608>:
     3a6:	46 6f 72 6d 61 74 65 64 3a 25 73 00                 Formated:%s.

000003b2 <__c.9606>:
     3b2:	25 73 00                                            %s.

000003b5 <__c.9604>:
     3b5:	25 73 00                                            %s.

000003b8 <__c.9602>:
     3b8:	25 73 00                                            %s.

000003bb <__c.9600>:
     3bb:	25 73 00                                            %s.

000003be <__c.9598>:
     3be:	44 61 74 61 3a 25 73 00                             Data:%s.

000003c6 <__c.9487>:
     3c6:	4e 2f 41 00                                         N/A.

000003ca <__c.9467>:
     3ca:	25 73 00                                            %s.

000003cd <__c.9462>:
	...

000003ce <__c.9335>:
     3ce:	25 64 2e 25 73 25 73 25 73 00                       %d.%s%s%s.

000003d8 <__c.9333>:
     3d8:	25 64 2e 25 73 25 73 25 73 25 73 25 73 00           %d.%s%s%s%s%s.

000003e6 <__c.9325>:
     3e6:	54 4f 54 41 4c 20 25 73 25 73 00                    TOTAL %s%s.

000003f1 <__c.9323>:
     3f1:	54 4f 54 41 4c 20 25 73 25 73 25 73 25 73 00        TOTAL %s%s%s%s.

00000400 <__c.9319>:
     400:	25 73 25 73 00                                      %s%s.

00000405 <__c.9317>:
     405:	25 73 25 73 25 73 25 73 00                          %s%s%s%s.

0000040e <__c.9315>:
     40e:	25 73 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 20 20 20     %s-----------   
     41e:	20 20 20 20 20 20 20 20 20 20 20 20 20 00                        .

0000042c <__c.9313>:
     42c:	25 73 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 20 20 20     %s-----------   
     43c:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 00           -------------.

0000044a <__c.9311>:
     44a:	41 77 61 6c 20 3a 25 73 25 73 00                    Awal :%s%s.

00000455 <__c.9309>:
     455:	41 77 61 6c 20 3a 25 73 25 73 25 73 25 73 00        Awal :%s%s%s%s.

00000464 <__c.9307>:
     464:	41 6b 68 69 72 3a 25 73 25 73 00                    Akhir:%s%s.

0000046f <__c.9305>:
     46f:	41 6b 68 69 72 3a 25 73 25 73 25 73 25 73 00        Akhir:%s%s%s%s.

0000047e <__c.9303>:
     47e:	50 25 64 2e 25 64 20 2d 20 25 73 20 00              P%d.%d - %s .

0000048b <__c.9301>:
     48b:	50 25 64 2e 25 64 20 2d 20 25 73 20 25 73 20 25     P%d.%d - %s %s %
     49b:	73 00                                               s.

0000049d <__c.9299>:
     49d:	48 61 72 67 61 3a 20 52 70 2e 25 73 00              Harga: Rp.%s.

000004aa <__c.9295>:
     4aa:	4e 2f 41 00                                         N/A.

000004ae <__c.9291>:
     4ae:	50 55 4d 50 2d 50 52 4f 44 55 43 54 20 20 20 56     PUMP-PRODUCT   V
     4be:	4f 4c 55 4d 45 28 4c 29 20 20 20 20 20 20 20 20     OLUME(L)        
     4ce:	20 20 20 20 20 20 00                                      .

000004d5 <__c.9289>:
     4d5:	50 55 4d 50 2d 50 52 4f 44 55 43 54 20 20 20 56     PUMP-PRODUCT   V
     4e5:	4f 4c 55 4d 45 28 4c 29 20 20 20 20 52 55 50 49     OLUME(L)    RUPI
     4f5:	41 48 28 52 50 29 00                                AH(RP).

000004fc <__c.9285>:
     4fc:	41 6b 68 69 72 20 53 68 69 66 74 20 3a 20 25 73     Akhir Shift : %s
     50c:	20 00                                                .

0000050e <__c.9283>:
     50e:	41 77 61 6c 20 20 53 68 69 66 74 20 3a 20 25 73     Awal  Shift : %s
     51e:	20 00                                                .

00000520 <__c.9281>:
     520:	54 65 72 6d 69 6e 61 6c 20 49 44 20 3a 20 25 2e     Terminal ID : %.
     530:	32 64 20 20 20 20 20 20 20 20 20 20 20 20 20 20     2d              
     540:	20 20 20 20 20 00                                        .

00000546 <__c.9279>:
     546:	20 20 20 20 20 20 20 20 4c 61 70 6f 72 61 6e 20             Laporan 
     556:	54 75 74 75 70 20 53 68 69 66 74 3a 20 25 73 20     Tutup Shift: %s 
     566:	20 20 20 20 20 00                                        .

0000056c <__c.9276>:
     56c:	25 64 00                                            %d.

0000056f <__c.9218>:
     56f:	25 73 00                                            %s.

00000572 <__c.9213>:
     572:	30 00                                               0.

00000574 <__c.9211>:
     574:	30 00                                               0.

00000576 <__c.9047>:
     576:	25 73 00                                            %s.

00000579 <__c.9045>:
     579:	25 73 00                                            %s.

0000057c <__c.9043>:
     57c:	25 73 00                                            %s.

0000057f <__c.9041>:
     57f:	25 73 00                                            %s.

00000582 <__c.9039>:
     582:	25 73 00                                            %s.

00000585 <__c.8953>:
     585:	41 2b 42 3a 25 73 00                                A+B:%s.

0000058c <__c.8951>:
     58c:	49 6e 42 3a 25 73 00                                InB:%s.

00000593 <__c.8947>:
     593:	49 6e 42 3a 5f 00                                   InB:_.

00000599 <__c.8945>:
     599:	49 6e 41 3a 25 73 00                                InA:%s.

000005a0 <__c.8940>:
     5a0:	49 6e 41 3a 5f 00                                   InA:_.

000005a6 <__c.8938>:
     5a6:	4f 70 65 72 61 74 69 6f 6e 20 4d 75 6c 74 69 70     Operation Multip
     5b6:	6c 79 00                                            ly.

000005b9 <__c.8809>:
     5b9:	25 73 00                                            %s.

000005bc <__c.8721>:
     5bc:	30 30 30 30 30 30 30 30 00                          00000000.

000005c5 <__c.8637>:
     5c5:	4f 70 65 72 61 74 6f 72 3a 20 25 73 00              Operator: %s.

000005d2 <__c.8632>:
     5d2:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     5e2:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     5f2:	2d 00                                               -.

000005f4 <__c.8623>:
     5f4:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
     604:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
     614:	20 20 20 00                                            .

00000618 <__c.8621>:
     618:	20 20 20 20 20 20 20 20 20 20 20 20 20 44 55 50                  DUP
     628:	4c 49 43 41 54 45 20 43 4f 50 59 20 20 20 20 20     LICATE COPY     
     638:	20 20 20 00                                            .

0000063c <__c.8466>:
     63c:	20 20 20 20 20 4f 70 65 72 61 74 6f 72 3a 20 25          Operator: %
     64c:	73 00                                               s.

0000064e <__c.8461>:
     64e:	20 20 20 20 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d         ------------
     65e:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     66e:	2d 2d 00                                            --.

00000671 <__c.8458>:
     671:	20 20 20 20 20 53 75 72 63 68 61 72 67 65 20 41          Surcharge A
     681:	6d 74 3a 20 25 73 00                                mt: %s.

00000688 <__c.8455>:
     688:	20 20 20 20 20 53 75 72 63 68 61 72 67 65 20 44          Surcharge D
     698:	73 63 3a 20 25 73 00                                sc: %s.

0000069f <__c.8452>:
     69f:	20 20 20 20 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d         ------------
     6af:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     6bf:	2d 2d 00                                            --.

000006c2 <__c.8449>:
     6c2:	20 20 20 20 20 4d 6f 6e 74 68 20 43 6f 6e 73 20          Month Cons 
     6d2:	41 20 3a 20 52 70 2e 25 73 00                       A : Rp.%s.

000006dc <__c.8446>:
     6dc:	20 20 20 20 20 4d 6f 6e 74 68 20 43 6f 6e 73 20          Month Cons 
     6ec:	56 20 3a 20 25 73 20 4c 00                          V : %s L.

000006f5 <__c.8443>:
     6f5:	20 20 20 20 20 54 6f 74 61 6c 20 52 65 64 65 65          Total Redee
     705:	6d 20 3a 20 25 73 00                                m : %s.

0000070c <__c.8440>:
     70c:	20 20 20 20 20 45 78 70 69 72 79 20 20 20 20 20          Expiry     
     71c:	20 20 3a 20 25 73 00                                  : %s.

00000723 <__c.8437>:
     723:	20 20 20 20 20 43 75 72 72 20 50 6f 69 6e 74 73          Curr Points
     733:	20 20 3a 20 25 73 00                                  : %s.

0000073a <__c.8434>:
     73a:	20 20 20 20 20 50 72 65 76 20 50 6f 69 6e 74 73          Prev Points
     74a:	20 20 3a 20 25 73 00                                  : %s.

00000751 <__c.8431>:
     751:	20 20 20 20 20 47 61 69 6e 20 50 6f 69 6e 74 73          Gain Points
     761:	20 20 3a 20 25 73 00                                  : %s.

00000768 <__c.8428>:
     768:	20 20 20 20 20 43 6f 72 70 20 4e 61 6d 65 20 20          Corp Name  
     778:	20 20 3a 20 25 73 00                                  : %s.

0000077f <__c.8425>:
     77f:	20 20 20 20 20 43 6f 72 70 20 49 44 20 20 20 20          Corp ID    
     78f:	20 20 3a 20 25 73 00                                  : %s.

00000796 <__c.8422>:
     796:	20 20 20 20 20 43 61 72 64 20 48 6f 6c 64 65 72          Card Holder
     7a6:	20 20 3a 20 25 73 20 00                               : %s .

000007ae <__c.8419>:
     7ae:	20 20 20 20 20 43 61 72 64 20 49 44 20 20 20 20          Card ID    
     7be:	20 20 3a 20 25 73 00                                  : %s.

000007c5 <__c.8416>:
     7c5:	20 20 20 20 20 20 20 20 20 4c 4f 59 41 4c 54 59              LOYALTY
     7d5:	20 49 4e 46 4f 52 4d 41 54 49 4f 4e 20 20 20 20      INFORMATION    
     7e5:	20 20 00                                              .

000007e8 <__c.8413>:
     7e8:	20 20 20 20 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d         ------------
     7f8:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     808:	2d 2d 00                                            --.

0000080b <__c.8410>:
     80b:	20 20 20 20 2e 25 73 00                                 .%s.

00000813 <__c.8406>:
     813:	20 20 20 20 54 61 6e 64 61 20 54 61 6e 67 61 6e         Tanda Tangan
     823:	20 20 28 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f       (_____________
     833:	5f 29 00                                            _).

00000836 <__c.8401>:
     836:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
     846:	20 20 20 20 20 20 00                                      .

0000084d <__c.8398>:
     84d:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
     85d:	20 20 20 20 20 20 00                                      .

00000864 <__c.8395>:
     864:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
     874:	20 00                                                .

00000876 <__c.8393>:
     876:	20 20 00                                              .

00000879 <__c.8391>:
     879:	20 20 20 20 41 70 70 72 20 43 6f 64 65 3a 20 25         Appr Code: %
     889:	73 00                                               s.

0000088b <__c.8389>:
     88b:	25 73 20 20 00                                      %s  .

00000890 <__c.8387>:
     890:	20 20 20 20 4e 61 6d 61 20 20 20 20 20 3a 20 25         Nama     : %
     8a0:	73 00                                               s.

000008a2 <__c.8384>:
     8a2:	20 20 20 20 20 20 20 20 20 20 2a 2a 2a 20 50 55               *** PU
     8b2:	4d 50 20 54 45 53 54 20 2a 2a 2a 20 20 20 20 20     MP TEST ***     
     8c2:	20 20 00                                              .

000008c5 <__c.8382>:
     8c5:	20 20 20 20 56 6f 75 63 68 65 72 20 4e 6f 3a 20         Voucher No: 
     8d5:	25 73 00                                            %s.

000008d8 <__c.8380>:
     8d8:	20 20 20 20 4b 61 72 74 75 20 49 44 20 3a 20 25         Kartu ID : %
     8e8:	73 00                                               s.

000008ea <__c.8377>:
     8ea:	20 20 20 20 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d         ------------
     8fa:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     90a:	2d 2d 00                                            --.

0000090d <__c.8374>:
     90d:	20 20 20 20 20 20 4f 64 6f 6d 65 74 65 72 20 20           Odometer  
     91d:	20 20 3a 20 25 73 00                                  : %s.

00000924 <__c.8371>:
     924:	20 20 20 20 20 20 4e 6f 2e 50 6f 6c 69 73 69 20           No.Polisi 
     934:	20 20 3a 20 25 73 00                                  : %s.

0000093b <__c.8368>:
	...

0000093c <__c.8366>:
     93c:	20 20 20 20 20 20 4a 6d 6c 20 52 75 70 69 61 68           Jml Rupiah
     94c:	20 20 3a 20 52 70 2e 25 73 00                         : Rp.%s.

00000956 <__c.8363>:
     956:	20 20 20 20 20 20 4a 6d 6c 20 4c 69 74 65 72 20           Jml Liter 
     966:	20 20 3a 20 25 73 20 4c 00                            : %s L.

0000096f <__c.8360>:
	...

00000970 <__c.8358>:
     970:	20 20 20 20 20 20 48 61 72 67 61 2f 4c 20 20 20           Harga/L   
     980:	20 20 3a 20 52 70 2e 25 73 00                         : Rp.%s.

0000098a <__c.8355>:
     98a:	20 20 20 20 20 20 50 72 6f 64 75 6b 20 20 20 20           Produk    
     99a:	20 20 3a 20 25 73 00                                  : %s.

000009a1 <__c.8352>:
     9a1:	20 20 20 20 20 20 50 75 6c 61 75 2f 50 6f 6d 70           Pulau/Pomp
     9b1:	61 20 3a 20 5b 25 73 5d 2d 25 73 00                 a : [%s]-%s.

000009bd <__c.8349>:
     9bd:	20 20 20 20 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d         ------------
     9cd:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     9dd:	2d 2d 00                                            --.

000009e0 <__c.8346>:
     9e0:	20 20 20 20 20 20 57 61 6b 74 75 3a 20 25 73 20           Waktu: %s 
     9f0:	25 73 20 00                                         %s .

000009f4 <__c.8342>:
     9f4:	20 20 20 20 20 20 53 68 69 66 74 3a 20 25 73 20           Shift: %s 
     a04:	20 4e 6f 2e 54 72 61 6e 73 3a 20 25 73 20 00         No.Trans: %s .

00000a13 <__c.8325>:
     a13:	20 00                                                .

00000a15 <__c.8323>:
     a15:	20 20 20 20 20 20 20 20 20 20 20 20 20 44 55 50                  DUP
     a25:	4c 49 43 41 54 45 20 43 4f 50 59 20 20 20 20 20     LICATE COPY     
     a35:	20 20 20 00                                            .

00000a39 <__c.7924>:
     a39:	45 72 72 6f 72 20 4e 6f 20 43 6f 6e 6e 65 63 74     Error No Connect
     a49:	69 6f 6e 00                                         ion.

00000a4d <__c.7918>:
     a4d:	50 72 6f 73 65 73 00                                Proses.

00000a54 <__c.7916>:
     a54:	53 65 6e 64 20 52 65 71 75 65 73 74 00              Send Request.

00000a61 <__c.7911>:
     a61:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
     a71:	6e 74 65 72 00                                      nter.

00000a76 <__c.7909>:
     a76:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
     a86:	6e 74 65 72 00                                      nter.

00000a8b <__c.7906>:
     a8b:	5b 2a 5d 43 61 6e 63 65 6c 20 20 5b 23 5d 45 6e     [*]Cancel  [#]En
     a9b:	74 65 72 20 00                                      ter .

00000aa0 <__c.7904>:
     aa0:	4f 64 6f 6d 65 74 65 72 3a 5f 20 00                 Odometer:_ .

00000aac <__c.7902>:
     aac:	50 6c 61 74 20 4e 6f 3a 20 25 73 20 00              Plat No: %s .

00000ab9 <__c.7899>:
     ab9:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
     ac9:	6e 74 65 72 00                                      nter.

00000ace <__c.7897>:
     ace:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
     ade:	6e 74 65 72 00                                      nter.

00000ae3 <__c.7894>:
     ae3:	5b 2a 5d 43 61 6e 63 65 6c 20 20 5b 23 5d 45 6e     [*]Cancel  [#]En
     af3:	74 65 72 20 00                                      ter .

00000af8 <__c.7892>:
     af8:	5f 00                                               _.

00000afa <__c.7890>:
     afa:	49 6e 70 75 74 20 50 6c 61 74 20 4e 6f 3a 20 00     Input Plat No: .

00000b0a <__c.7811>:
     b0a:	23 29 53 61 76 65 00                                #)Save.

00000b11 <__c.7809>:
     b11:	34 29 54 65 72 6d 49 44 3a 25 64 20 00              4)TermID:%d .

00000b1e <__c.7807>:
     b1e:	25 64 00                                            %d.

00000b21 <__c.7795>:
     b21:	25 64 00                                            %d.

00000b24 <__c.7787>:
     b24:	23 29 53 61 76 65 00                                #)Save.

00000b2b <__c.7785>:
     b2b:	34 29 54 65 72 6d 49 44 3a 25 64 20 00              4)TermID:%d .

00000b38 <__c.7783>:
     b38:	33 29 4e 6f 74 69 66 20 3a 20 20 20 20 20 2a 29     3)Notif :     *)
     b48:	45 78 69 74 00                                      Exit.

00000b4d <__c.7781>:
     b4d:	32 29 44 2f 54 20 20 20 3a 00                       2)D/T   :.

00000b57 <__c.7779>:
     b57:	31 29 4d 6f 6e 65 79 20 3a 00                       1)Money :.

00000b61 <__c.7726>:
     b61:	25 2e 32 64 00                                      %.2d.

00000b66 <__c.7724>:
     b66:	25 64 00                                            %d.

00000b69 <__c.7707>:
     b69:	25 2e 32 64 00                                      %.2d.

00000b6e <__c.7705>:
     b6e:	25 64 00                                            %d.

00000b71 <__c.7697>:
     b71:	34 29 43 75 74 20 3a 20 20 2a 29 45 78 69 74 00     4)Cut :  *)Exit.

00000b81 <__c.7695>:
     b81:	33 29 4c 6f 67 6f 3a 20 20 23 29 53 61 76 65 00     3)Logo:  #)Save.

00000b91 <__c.7693>:
     b91:	32 29 53 69 7a 65 3a 20 20 36 29 53 70 61 63 65     2)Size:  6)Space
     ba1:	20 3a 00                                             :.

00000ba4 <__c.7691>:
     ba4:	31 29 54 79 70 65 3a 20 20 35 29 53 63 72 6f 6c     1)Type:  5)Scrol
     bb4:	6c 3a 00                                            l:.

00000bb7 <__c.7627>:
     bb7:	2a 29 43 61 6e 63 65 6c 20 20 20 20 20 20 23 29     *)Cancel      #)
     bc7:	53 61 76 65 00                                      Save.

00000bcc <__c.7625>:
     bcc:	54 49 4d 45 20 3a 20 00                             TIME : .

00000bd4 <__c.7623>:
     bd4:	44 41 54 45 20 3a 20 00                             DATE : .

00000bdc <__c.7573>:
     bdc:	25 64 00                                            %d.

00000bdf <__c.7562>:
     bdf:	25 64 00                                            %d.

00000be2 <__c.7554>:
     be2:	2a 29 45 78 69 74 20 20 20 20 20 20 20 20 23 29     *)Exit        #)
     bf2:	53 61 76 65 00                                      Save.

00000bf7 <__c.7552>:
     bf7:	32 29 4e 32 3a 20 20 34 29 4e 34 3a 20 20 36 29     2)N2:  4)N4:  6)
     c07:	4e 36 3a 00                                         N6:.

00000c0b <__c.7550>:
     c0b:	31 29 4e 31 3a 20 20 33 29 4e 33 3a 20 20 35 29     1)N1:  3)N3:  5)
     c1b:	4e 35 3a 00                                         N5:.

00000c1f <__c.7548>:
     c1f:	50 72 6f 64 75 63 74 20 46 49 50 25 2e 32 64 00     Product FIP%.2d.

00000c2f <__c.7464>:
     c2f:	43 6f 6d 70 6c 65 74 65 64 00                       Completed.

00000c39 <__c.7462>:
     c39:	43 61 6e 63 65 6c 20 20 20 20 20 00                 Cancel     .

00000c45 <__c.7459>:
     c45:	49 64 5b 25 64 5d 3d 25 2e 32 64 20 20 00           Id[%d]=%.2d  .

00000c53 <__c.7456>:
     c53:	53 61 76 69 6e 67 2e 2e 00                          Saving...

00000c5c <__c.7454>:
     c5c:	2d 50 75 6d 70 49 44 2d 00                          -PumpID-.

00000c65 <__c.7450>:
     c65:	20 20 20 20 4e 6f 74 20 41 6c 6c 6f 77 65 64 20         Not Allowed 
     c75:	20 20 20 20 00                                          .

00000c7a <__c.7448>:
     c7a:	20 20 44 75 70 6c 69 63 61 74 65 20 50 75 6d 70       Duplicate Pump
     c8a:	49 44 20 20 00                                      ID  .

00000c8f <__c.7446>:
     c8f:	20 20 20 20 20 20 57 61 72 6e 69 6e 67 21 20 20           Warning!  
     c9f:	20 20 20 20 00                                          .

00000ca4 <__c.7434>:
     ca4:	25 64 2e 50 25 2e 32 64 20 7c 20 25 64 2e 50 25     %d.P%.2d | %d.P%
     cb4:	2e 32 64 00                                         .2d.

00000cb8 <__c.7428>:
     cb8:	23 29 53 61 76 65 00                                #)Save.

00000cbf <__c.7426>:
     cbf:	2a 29 42 61 63 6b 00                                *)Back.

00000cc6 <__c.7421>:
     cc6:	25 64 2e 50 25 2e 32 64 20 7c 20 25 64 2e 50 25     %d.P%.2d | %d.P%
     cd6:	2e 32 64 00                                         .2d.

00000cda <__c.7372>:
     cda:	25 2e 32 64 00                                      %.2d.

00000cdf <__c.7366>:
     cdf:	25 2e 32 64 00                                      %.2d.

00000ce4 <__c.7364>:
     ce4:	34 29 34 3a 20 20 20 38 29 38 3a 20 20 20 2a 29     4)4:   8)8:   *)
     cf4:	45 78 69 74 00                                      Exit.

00000cf9 <__c.7362>:
     cf9:	33 29 33 3a 20 20 20 37 29 37 3a 20 20 20 23 29     3)3:   7)7:   #)
     d09:	53 61 76 65 00                                      Save.

00000d0e <__c.7360>:
     d0e:	32 29 32 3a 20 20 20 36 29 36 3a 00                 2)2:   6)6:.

00000d1a <__c.7358>:
     d1a:	31 29 31 3a 20 20 20 35 29 35 3a 00                 1)1:   5)5:.

00000d26 <__c.7324>:
     d26:	5b 2a 5d 45 78 69 74 20 20 5b 23 5d 43 68 61 6e     [*]Exit  [#]Chan
     d36:	67 65 20 00                                         ge .

00000d3a <__c.7322>:
     d3a:	25 64 2e 25 73 00                                   %d.%s.

00000d40 <__c.7317>:
     d40:	2d 44 69 73 70 65 6e 73 65 72 20 42 72 61 6e 64     -Dispenser Brand
     d50:	2d 00                                               -.

00000d52 <__c.7301>:
     d52:	2a 29 45 78 69 74 00                                *)Exit.

00000d59 <__c.7299>:
     d59:	32 29 50 72 6f 64 75 63 74 00                       2)Product.

00000d63 <__c.7297>:
     d63:	31 29 49 44 00                                      1)ID.

00000d68 <__c.7282>:
     d68:	2a 29 45 78 69 74 00                                *)Exit.

00000d6f <__c.7277>:
     d6f:	25 64 2e 50 25 2e 32 64 20 7c 20 25 64 2e 50 25     %d.P%.2d | %d.P%
     d7f:	2e 32 64 20 00                                      .2d .

00000d84 <__c.7268>:
     d84:	25 2e 32 64 00                                      %.2d.

00000d89 <__c.7067>:
     d89:	5b 2a 5d 45 78 69 74 00                             [*]Exit.

00000d91 <__c.7065>:
     d91:	36 2e 41 63 74 3a 25 64 00                          6.Act:%d.

00000d9a <__c.7063>:
     d9a:	35 2e 44 6c 79 3a 25 64 00                          5.Dly:%d.

00000da3 <__c.7061>:
     da3:	34 2e 54 69 6d 50 6f 6f 6c 3a 25 64 00              4.TimPool:%d.

00000db0 <__c.7059>:
     db0:	33 2e 54 72 79 53 65 6e 64 3a 25 64 00              3.TrySend:%d.

00000dbd <__c.7057>:
     dbd:	32 2e 6e 4e 6f 50 75 6d 70 3a 25 64 00              2.nNoPump:%d.

00000dca <__c.7055>:
     dca:	31 2e 4d 61 78 50 75 6d 70 3a 25 64 00              1.MaxPump:%d.

00000dd7 <__c.6996>:
     dd7:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 00              [*]Back     .

00000de4 <__c.6991>:
     de4:	43 4f 4d 25 64 3a 25 64 00                          COM%d:%d.

00000ded <__c.6989>:
     ded:	20 20 20 20 20 2d 42 61 75 64 72 61 74 65 2d 20          -Baudrate- 
     dfd:	20 20 20 20 00                                          .

00000e02 <__c.6984>:
     e02:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 20 00           [*]Back      .

00000e10 <__c.6982>:
     e10:	33 2e 43 4f 4d 33 3a 34 38 35 00                    3.COM3:485.

00000e1b <__c.6980>:
     e1b:	33 2e 43 4f 4d 33 3a 32 33 32 00                    3.COM3:232.

00000e26 <__c.6978>:
     e26:	33 2e 43 4f 4d 33 3a 54 54 4c 00                    3.COM3:TTL.

00000e31 <__c.6976>:
     e31:	32 2e 42 61 75 64 72 61 74 65 00                    2.Baudrate.

00000e3c <__c.6974>:
     e3c:	31 2e 4d 6f 64 65 3a 53 74 61 6e 64 61 6c 6f 6e     1.Mode:Standalon
     e4c:	65 00                                               e.

00000e4e <__c.6972>:
     e4e:	31 2e 4d 6f 64 65 3a 53 6c 61 76 65 00              1.Mode:Slave.

00000e5b <__c.6970>:
     e5b:	31 2e 4d 6f 64 65 3a 4e 6f 6e 65 00                 1.Mode:None.

00000e67 <__c.6923>:
     e67:	49 6e 76 61 6c 69 64 20 4f 6c 64 20 50 61 73 73     Invalid Old Pass
     e77:	77 6f 72 64 00                                      word.

00000e7c <__c.6921>:
     e7c:	20 20 20 20 20 20 45 52 52 4f 52 20 20 20 20 20           ERROR     
     e8c:	20 20 20 20 00                                          .

00000e91 <__c.6919>:
     e91:	49 6e 76 61 6c 69 64 20 4e 65 77 20 50 61 73 73     Invalid New Pass
     ea1:	77 6f 72 64 00                                      word.

00000ea6 <__c.6917>:
     ea6:	20 20 20 20 20 20 45 52 52 4f 52 20 20 20 20 20           ERROR     
     eb6:	20 20 20 20 00                                          .

00000ebb <__c.6915>:
     ebb:	20 20 20 50 61 73 73 77 6f 72 64 20 53 61 76 65        Password Save
     ecb:	64 20 20 20 00                                      d   .

00000ed0 <__c.6913>:
     ed0:	20 20 20 20 20 43 6f 6d 70 6c 65 74 65 64 20 20          Completed  
     ee0:	20 20 20 20 00                                          .

00000ee5 <__c.6909>:
     ee5:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
     ef5:	6e 74 65 72 00                                      nter.

00000efa <__c.6906>:
     efa:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
     f0a:	6e 74 65 72 00                                      nter.

00000f0f <__c.6903>:
     f0f:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
     f1f:	6e 74 65 72 00                                      nter.

00000f24 <__c.6901>:
     f24:	4e 65 77 3a 5f 20 20 20 20 20 20 20 20 20 20 20     New:_           
     f34:	20 20 20 20 00                                          .

00000f39 <__c.6897>:
     f39:	56 61 6c 69 64 61 74 69 6e 67 2e 2e 00              Validating...

00000f46 <__c.6893>:
     f46:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
     f56:	6e 74 65 72 00                                      nter.

00000f5b <__c.6890>:
     f5b:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
     f6b:	6e 74 65 72 00                                      nter.

00000f70 <__c.6885>:
     f70:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
     f80:	6e 74 65 72 00                                      nter.

00000f85 <__c.6883>:
     f85:	4e 65 77 3a 5f 20 20 20 20 20 20 20 20 20 20 20     New:_           
     f95:	20 20 20 20 00                                          .

00000f9a <__c.6879>:
     f9a:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
     faa:	6e 74 65 72 00                                      nter.

00000faf <__c.6876>:
     faf:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
     fbf:	6e 74 65 72 00                                      nter.

00000fc4 <__c.6871>:
     fc4:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
     fd4:	6e 74 65 72 00                                      nter.

00000fd9 <__c.6869>:
     fd9:	4e 65 77 3a 5f 20 20 20 20 20 20 20 20 20 20 20     New:_           
     fe9:	20 20 20 20 00                                          .

00000fee <__c.6865>:
     fee:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
     ffe:	6e 74 65 72 00                                      nter.

00001003 <__c.6863>:
    1003:	4f 6c 64 3a 5f 00                                   Old:_.

00001009 <__c.6861>:
    1009:	2d 41 64 6d 69 6e 69 73 74 72 61 74 6f 72 2d 00     -Administrator-.

00001019 <__c.6859>:
    1019:	2d 53 75 70 65 72 76 69 73 6f 72 2d 00              -Supervisor-.

00001026 <__c.6851>:
    1026:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 00              [*]Back     .

00001033 <__c.6849>:
    1033:	32 2e 41 64 6d 69 6e 69 73 74 72 61 74 6f 72 00     2.Administrator.

00001043 <__c.6847>:
    1043:	31 2e 53 75 70 65 72 76 69 73 6f 72 00              1.Supervisor.

00001050 <__c.6845>:
    1050:	2d 43 68 61 6e 67 65 20 50 61 73 73 77 6f 72 64     -Change Password
    1060:	2d 00                                               -.

00001062 <__c.6842>:
    1062:	53 61 76 65 64 20 00                                Saved .

00001069 <__c.6836>:
    1069:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    1079:	6e 74 65 72 00                                      nter.

0000107e <__c.6833>:
    107e:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
    108e:	6e 74 65 72 00                                      nter.

00001093 <__c.6828>:
    1093:	5b 2a 5d 4e 6f 20 20 20 20 5b 23 5d 59 65 73 00     [*]No    [#]Yes.

000010a3 <__c.6826>:
    10a3:	53 61 76 65 3f 00                                   Save?.

000010a9 <__c.6824>:
    10a9:	4e 65 77 20 4f 70 65 72 61 74 6f 72 3a 00           New Operator:.

000010b7 <__c.6822>:
    10b7:	25 73 00                                            %s.

000010ba <__c.6818>:
    10ba:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    10ca:	6e 74 65 72 00                                      nter.

000010cf <__c.6816>:
    10cf:	4e 65 77 20 3a 5f 20 20 20 20 20 20 20 20 20 20     New :_          
    10df:	20 20 20 20 00                                          .

000010e4 <__c.6814>:
    10e4:	4e 61 6d 65 3a 00                                   Name:.

000010ea <__c.6812>:
    10ea:	25 73 00                                            %s.

000010ed <__c.6803>:
    10ed:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 20 20 20 20     [*]Back         
    10fd:	20 00                                                .

000010ff <__c.6801>:
    10ff:	32 2e 43 68 61 6e 67 65 20 50 61 73 73 77 6f 72     2.Change Passwor
    110f:	64 00                                               d.

00001111 <__c.6799>:
    1111:	31 2e 43 68 61 6e 67 65 20 4f 70 65 72 61 74 6f     1.Change Operato
    1121:	72 00                                               r.

00001123 <__c.6716>:
    1123:	2a 29 42 61 63 6b 00                                *)Back.

0000112a <__c.6714>:
    112a:	34 2e 53 70 61 72 61 74 6f 72 3a 25 63 20 00        4.Sparator:%c .

00001139 <__c.6712>:
    1139:	33 2e 44 65 63 69 6d 61 6c 20 3a 25 63 20 00        3.Decimal :%c .

00001148 <__c.6710>:
    1148:	32 2e 54 2e 4d 6f 6e 65 79 20 3a 25 64 20 00        2.T.Money :%d .

00001157 <__c.6708>:
    1157:	31 2e 54 2e 56 6f 6c 75 6d 65 3a 25 64 20 20 35     1.T.Volume:%d  5
    1167:	2e 54 65 73 74 00                                   .Test.

0000116d <__c.6703>:
    116d:	5b 2a 5d 42 61 63 6b 20 20 5b 23 5d 4e 65 78 74     [*]Back  [#]Next
	...

0000117e <__c.6701>:
    117e:	33 2e 4d 6f 6e 65 79 20 3a 25 64 00                 3.Money :%d.

0000118a <__c.6699>:
    118a:	32 2e 56 6f 6c 75 6d 65 3a 25 64 00                 2.Volume:%d.

00001196 <__c.6697>:
    1196:	31 2e 50 72 69 63 65 20 3a 25 64 00                 1.Price :%d.

000011a2 <__c.6680>:
    11a2:	34 29 42 72 61 6e 64 20 20 2a 29 45 78 69 74 00     4)Brand  *)Exit.

000011b2 <__c.6678>:
    11b2:	33 29 4c 61 62 65 6c 20 20 00                       3)Label  .

000011bc <__c.6676>:
    11bc:	32 29 50 72 6f 64 75 63 74 00                       2)Product.

000011c6 <__c.6674>:
    11c6:	31 29 49 44 20 20 20 20 20 00                       1)ID     .

000011d0 <__c.6634>:
    11d0:	2a 29 42 61 63 6b 20 20 20 20 23 29 4f 4b 20 20     *)Back    #)OK  
    11e0:	20 20 20 20 00                                          .

000011e5 <__c.6632>:
    11e5:	4e 65 77 3a 5f 00                                   New:_.

000011eb <__c.6630>:
    11eb:	4f 6c 64 3a 25 73 00                                Old:%s.

000011f2 <__c.6628>:
    11f2:	2a 29 42 61 63 6b 20 20 20 20 23 29 4f 4b 20 20     *)Back    #)OK  
    1202:	20 20 20 20 00                                          .

00001207 <__c.6626>:
    1207:	4e 65 77 3a 5f 00                                   New:_.

0000120d <__c.6624>:
    120d:	45 64 69 74 20 50 72 6f 64 75 63 74 20 4e 61 6d     Edit Product Nam
    121d:	65 20 20 20 00                                      e   .

00001222 <__c.6622>:
    1222:	4f 6c 64 3a 25 73 00                                Old:%s.

00001229 <__c.6619>:
    1229:	2a 29 42 61 63 6b 20 20 20 20 20 20 20 00           *)Back       .

00001237 <__c.6617>:
    1237:	32 29 25 73 00                                      2)%s.

0000123c <__c.6615>:
    123c:	31 29 25 73 00                                      1)%s.

00001241 <__c.6610>:
    1241:	2a 29 42 61 63 6b 00                                *)Back.

00001248 <__c.6605>:
    1248:	25 64 29 25 73 00                                   %d)%s.

0000124e <__c.6536>:
    124e:	2a 29 42 61 63 6b 20 20 20 20 20 20 20 20 20 20     *)Back          
    125e:	20 20 20 20 00                                          .

00001263 <__c.6534>:
    1263:	33 29 50 75 6d 70 50 6f 6f 6c 69 6e 67 20 20 20     3)PumpPooling   
    1273:	20 20 20 20 00                                          .

00001278 <__c.6532>:
    1278:	32 29 53 79 73 74 65 6d 20 20 20 20 20 20 20 20     2)System        
    1288:	20 20 20 20 00                                          .

0000128d <__c.6530>:
    128d:	31 29 4f 70 65 72 61 74 6f 72 20 20 20 20 20 20     1)Operator      
    129d:	20 20 20 20 00                                          .

000012a2 <__c.6527>:
    12a2:	34 29 44 61 74 65 74 69 6d 65 20 2a 29 45 78 69     4)Datetime *)Exi
    12b2:	74 20 20 20 00                                      t   .

000012b7 <__c.6525>:
    12b7:	33 29 44 65 63 69 6d 61 6c 20 20 37 29 4e 65 78     3)Decimal  7)Nex
    12c7:	74 20 20 20 00                                      t   .

000012cc <__c.6523>:
    12cc:	32 29 50 75 6d 70 20 20 20 20 20 36 29 48 6f 73     2)Pump     6)Hos
    12dc:	74 20 20 20 00                                      t   .

000012e1 <__c.6521>:
    12e1:	31 29 50 72 6f 64 75 63 74 20 20 35 29 50 72 69     1)Product  5)Pri
    12f1:	6e 74 65 72 00                                      nter.

000012f6 <__c.6436>:
    12f6:	2e 00                                               ..

000012f8 <__c.6434>:
    12f8:	25 64 00                                            %d.

000012fb <__c.6432>:
    12fb:	20 20 20 00                                            .

000012ff <__c.6430>:
    12ff:	2e 00                                               ..

00001301 <__c.6428>:
    1301:	25 64 00                                            %d.

00001304 <__c.6426>:
    1304:	20 20 20 00                                            .

00001308 <__c.6419>:
    1308:	5b 2a 5d 63 61 6e 63 65 6c 20 20 5b 23 5d 6e 65     [*]cancel  [#]ne
    1318:	78 74 20 20 00                                      xt  .

0000131d <__c.6417>:
    131d:	4e 65 77 3a 20 20 20 5f 2e 20 20 20 2e 20 20 20     New:   _.   .   
    132d:	2e 20 20 20 00                                      .   .

00001332 <__c.6415>:
    1332:	4f 6c 64 3a 20 25 64 2e 25 64 2e 25 64 2e 25 64     Old: %d.%d.%d.%d
	...

00001343 <__c.6413>:
    1343:	53 65 72 76 65 72 20 49 50 00                       Server IP.

0000134d <__c.6324>:
    134d:	2e 00                                               ..

0000134f <__c.6322>:
    134f:	25 64 00                                            %d.

00001352 <__c.6320>:
    1352:	20 20 20 00                                            .

00001356 <__c.6318>:
    1356:	2e 00                                               ..

00001358 <__c.6316>:
    1358:	25 64 00                                            %d.

0000135b <__c.6314>:
    135b:	20 20 20 00                                            .

0000135f <__c.6307>:
    135f:	5b 2a 5d 63 61 6e 63 65 6c 20 20 5b 23 5d 6e 65     [*]cancel  [#]ne
    136f:	78 74 20 20 00                                      xt  .

00001374 <__c.6305>:
    1374:	4e 65 77 3a 20 20 20 5f 2e 20 20 20 2e 20 20 20     New:   _.   .   
    1384:	2e 20 20 20 00                                      .   .

00001389 <__c.6303>:
    1389:	4f 6c 64 3a 20 25 64 2e 25 64 2e 25 64 2e 25 64     Old: %d.%d.%d.%d
	...

0000139a <__c.6301>:
    139a:	43 6c 69 65 6e 74 20 49 50 00                       Client IP.

000013a4 <__c.6259>:
    13a4:	25 73 25 73 00                                      %s%s.

000013a9 <__c.6255>:
    13a9:	5b 2a 5d 4e 6f 20 5b 23 5d 59 65 73 00              [*]No [#]Yes.

000013b6 <__c.6253>:
    13b6:	53 61 76 65 20 46 6f 6f 74 65 72 25 64 20 3f 00     Save Footer%d ?.

000013c6 <__c.6249>:
    13c6:	5b 2a 5d 4e 6f 20 20 5b 23 5d 59 65 73 00           [*]No  [#]Yes.

000013d4 <__c.6247>:
    13d4:	41 6c 69 67 6e 20 43 65 6e 74 65 72 3f 00           Align Center?.

000013e2 <__c.6244>:
    13e2:	5b 2a 5d 42 61 63 6b 20 20 5b 23 5d 4f 4b 00        [*]Back  [#]OK.

000013f1 <__c.6242>:
    13f1:	45 64 69 74 20 46 6f 6f 74 65 72 25 64 20 00        Edit Footer%d .

00001400 <__c.6238>:
    1400:	2a 29 45 78 69 74 20 20 20 20 20 20 20 20 20 20     *)Exit          
    1410:	20 20 20 20 00                                          .

00001415 <__c.6236>:
    1415:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    1425:	20 20 20 20 00                                          .

0000142a <__c.6234>:
    142a:	32 29 46 6f 6f 74 65 72 32 20 20 34 29 46 6f 6f     2)Footer2  4)Foo
    143a:	74 65 72 34 00                                      ter4.

0000143f <__c.6232>:
    143f:	31 29 46 6f 6f 74 65 72 31 20 20 33 29 46 6f 6f     1)Footer1  3)Foo
    144f:	74 65 72 33 00                                      ter3.

00001454 <__c.6201>:
    1454:	25 73 25 73 00                                      %s%s.

00001459 <__c.6197>:
    1459:	5b 2a 5d 4e 6f 20 5b 23 5d 59 65 73 00              [*]No [#]Yes.

00001466 <__c.6195>:
    1466:	53 61 76 65 20 48 65 61 64 65 72 25 64 20 3f 00     Save Header%d ?.

00001476 <__c.6191>:
    1476:	5b 2a 5d 4e 6f 20 20 5b 23 5d 59 65 73 00           [*]No  [#]Yes.

00001484 <__c.6189>:
    1484:	41 6c 69 67 6e 20 43 65 6e 74 65 72 3f 00           Align Center?.

00001492 <__c.6186>:
    1492:	5b 2a 5d 42 61 63 6b 20 20 5b 23 5d 4f 4b 00        [*]Back  [#]OK.

000014a1 <__c.6184>:
    14a1:	45 64 69 74 20 48 65 61 64 65 72 25 64 20 00        Edit Header%d .

000014b0 <__c.6180>:
    14b0:	2a 29 45 78 69 74 20 20 20 20 20 20 20 20 20 20     *)Exit          
    14c0:	20 20 20 20 00                                          .

000014c5 <__c.6178>:
    14c5:	33 29 48 65 61 64 65 72 33 20 20 36 29 48 65 61     3)Header3  6)Hea
    14d5:	64 65 72 36 00                                      der6.

000014da <__c.6176>:
    14da:	32 29 48 65 61 64 65 72 32 20 20 35 29 48 65 61     2)Header2  5)Hea
    14ea:	64 65 72 35 00                                      der5.

000014ef <__c.6174>:
    14ef:	31 29 48 65 61 64 65 72 31 20 20 34 29 48 65 61     1)Header1  4)Hea
    14ff:	64 65 72 34 00                                      der4.

00001504 <__c.6131>:
    1504:	2a 29 45 78 69 74 00                                *)Exit.

0000150b <__c.6129>:
    150b:	33 29 50 61 73 73 77 6f 72 64 20 20 20 20 20 20     3)Password      
    151b:	20 20 20 20 00                                          .

00001520 <__c.6127>:
    1520:	32 29 46 6f 6f 74 65 72 20 20 20 20 20 20 20 20     2)Footer        
    1530:	20 20 20 20 00                                          .

00001535 <__c.6125>:
    1535:	31 29 48 65 61 64 65 72 20 20 20 20 20 20 20 20     1)Header        
    1545:	20 20 20 20 00                                          .

0000154a <__c.6123>:
    154a:	32 29 46 6f 6f 74 65 72 20 20 20 20 35 29 53 65     2)Footer    5)Se
    155a:	72 76 65 72 00                                      rver.

0000155f <__c.6121>:
    155f:	31 29 48 65 61 64 65 72 20 20 20 20 34 29 43 6c     1)Header    4)Cl
    156f:	69 65 6e 74 00                                      ient.

00001574 <__c.6067>:
    1574:	53 61 76 69 6e 67 20 53 68 69 66 74 44 61 74 61     Saving ShiftData
    1584:	2e 2e 20 00                                         .. .

00001588 <__c.6062>:
    1588:	25 73 20 25 73 00                                   %s %s.

0000158e <__c.6060>:
    158e:	50 72 69 6e 74 69 6e 67 20 54 6f 74 61 6c 69 7a     Printing Totaliz
    159e:	65 72 00                                            er.

000015a1 <__c.6056>:
    15a1:	43 61 6e 63 65 6c 00                                Cancel.

000015a8 <__c.6051>:
    15a8:	45 72 72 6f 72 20 2d 20 4e 6f 20 50 75 6d 70 3a     Error - No Pump:
    15b8:	25 64 20 00                                         %d .

000015bc <__c.6046>:
    15bc:	57 61 69 74 20 50 75 6d 70 3a 25 64 20 00           Wait Pump:%d .

000015ca <__c.6042>:
    15ca:	57 61 69 74 20 50 75 6d 70 3a 25 64 20 00           Wait Pump:%d .

000015d8 <__c.6040>:
    15d8:	54 6f 74 61 6c 69 7a 65 72 2e 2e 00                 Totalizer...

000015e4 <__c.5968>:
    15e4:	2a 29 45 78 69 74 00                                *)Exit.

000015eb <__c.5966>:
    15eb:	33 2e 4c 6f 63 6b 20 50 75 6d 70 20 20 00           3.Lock Pump  .

000015f9 <__c.5964>:
    15f9:	32 2e 43 6c 6f 73 65 20 44 61 79 20 20 00           2.Close Day  .

00001607 <__c.5962>:
    1607:	31 2e 43 6c 6f 73 65 20 53 68 69 66 74 00           1.Close Shift.

00001615 <__c.5920>:
    1615:	34 29 53 65 74 74 69 6e 67 73 20 20 20 2a 29 45     4)Settings   *)E
    1625:	78 69 74 20 00                                      xit .

0000162a <__c.5918>:
    162a:	33 29 43 6c 6f 73 65 44 61 79 20 20 20 20 20 20     3)CloseDay      
    163a:	20 20 20 20 00                                          .

0000163f <__c.5916>:
    163f:	32 29 43 6c 6f 73 65 53 68 69 66 74 20 20 20 20     2)CloseShift    
    164f:	20 20 20 20 00                                          .

00001654 <__c.5914>:
    1654:	31 29 52 65 50 72 69 6e 74 20 20 20 20 20 20 20     1)RePrint       
    1664:	20 20 20 20 00                                          .

00001669 <__c.5884>:
    1669:	50 61 73 73 77 6f 72 64 20 52 65 73 74 6f 72 65     Password Restore
    1679:	64 00                                               d.

0000167b <__c.5880>:
    167b:	49 6e 76 61 6c 69 64 20 52 65 73 74 6f 72 65 20     Invalid Restore 
    168b:	20 00                                                .

0000168d <__c.5877>:
    168d:	30 30 30 30 30 00                                   00000.

00001693 <__c.5875>:
    1693:	31 31 31 31 31 00                                   11111.

00001699 <__c.5871>:
    1699:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    16a9:	6e 74 65 72 00                                      nter.

000016ae <__c.5868>:
    16ae:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
    16be:	6e 74 65 72 00                                      nter.

000016c3 <__c.5861>:
    16c3:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    16d3:	6e 74 65 72 00                                      nter.

000016d8 <__c.5859>:
    16d8:	5f 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20     _               
    16e8:	20 20 20 20 00                                          .

000016ed <__c.5857>:
    16ed:	45 6e 74 65 72 20 52 65 73 74 6f 72 65 20 43 6f     Enter Restore Co
    16fd:	64 65 20 20 00                                      de  .

00001702 <__c.5855>:
    1702:	4b 65 79 20 53 74 61 6d 70 3a 25 73 20 00           Key Stamp:%s .

00001710 <__c.5851>:
    1710:	49 6e 76 61 6c 69 64 20 43 6f 64 65 20 20 20 20     Invalid Code    
    1720:	20 20 20 20 00                                          .

00001725 <__c.5848>:
	...

00001726 <__c.5846>:
    1726:	25 73 00                                            %s.

00001729 <__c.5844>:
    1729:	25 73 00                                            %s.

0000172c <__c.5841>:
    172c:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    173c:	6e 74 65 72 00                                      nter.

00001741 <__c.5838>:
    1741:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
    1751:	6e 74 65 72 00                                      nter.

00001756 <__c.5831>:
	...

00001757 <__c.5829>:
    1757:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    1767:	6e 74 65 72 00                                      nter.

0000176c <__c.5827>:
    176c:	5f 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20     _               
    177c:	20 20 20 20 00                                          .

00001781 <__c.5825>:
    1781:	45 6e 74 65 72 20 47 65 4e 69 55 73 20 43 6f 64     Enter GeNiUs Cod
    1791:	65 20 20 20 00                                      e   .

00001796 <__c.5815>:
    1796:	5b 2a 5d 45 78 69 74 20 20 20 20 20 20 20 20 20     [*]Exit         
    17a6:	20 20 20 20 00                                          .

000017ab <__c.5813>:
    17ab:	32 2e 43 68 61 6e 67 65 20 50 61 73 73 77 6f 72     2.Change Passwor
    17bb:	64 20 20 20 00                                      d   .

000017c0 <__c.5811>:
    17c0:	31 2e 52 65 73 74 6f 72 65 20 50 61 73 73 77 6f     1.Restore Passwo
    17d0:	72 64 20 20 00                                      rd  .

000017d5 <__c.5809>:
    17d5:	2d 53 79 73 74 65 6d 20 41 64 6d 69 6e 20 4c 65     -System Admin Le
    17e5:	76 65 6c 2d 00                                      vel-.

000017ea <__c.5750>:
    17ea:	25 73 25 73 00                                      %s%s.

000017ef <__c.5722>:
    17ef:	25 73 00                                            %s.

000017f2 <__c.5689>:
    17f2:	25 63 00                                            %c.

000017f5 <__c.5687>:
    17f5:	32 30 25 73 00                                      20%s.

000017fa <__c.5665>:
    17fa:	25 73 00                                            %s.

000017fd <__c.5616>:
    17fd:	34 32 36 34 36 33 36 00                             4264636.

00001805 <__c.5613>:
    1805:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    1815:	6e 74 65 72 00                                      nter.

0000181a <__c.5611>:
    181a:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
    182a:	6e 74 65 72 00                                      nter.

0000182f <__c.5607>:
    182f:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    183f:	6e 74 65 72 00                                      nter.

00001844 <__c.5605>:
    1844:	5f 00                                               _.

00001846 <__c.5603>:
    1846:	50 41 53 53 57 4f 52 44 3a 00                       PASSWORD:.

00001850 <__c.5575>:
    1850:	41 63 63 65 73 73 20 44 65 6e 69 65 64 00           Access Denied.

0000185e <__c.5502>:
    185e:	54 43 50 2f 49 50 20 45 72 72 6f 72 00              TCP/IP Error.

0000186b <__c.5500>:
    186b:	4e 6f 20 52 65 70 6c 79 20 20 20 20 00              No Reply    .

00001878 <__c.5496>:
    1878:	20 20 20 20 20 20 20 00                                    .

00001880 <__c.5493>:
    1880:	50 6c 65 61 73 65 20 57 61 69 74 00                 Please Wait.

0000188c <__c.5490>:
    188c:	25 73 00                                            %s.

0000188f <__c.5488>:
    188f:	50 55 4d 50 20 54 45 53 54 00                       PUMP TEST.

00001899 <__c.5485>:
    1899:	25 73 00                                            %s.

0000189c <__c.5482>:
    189c:	25 73 00                                            %s.

0000189f <__c.5480>:
    189f:	25 73 00                                            %s.

000018a2 <__c.5478>:
    18a2:	25 73 00                                            %s.

000018a5 <__c.5474>:
    18a5:	25 73 00                                            %s.

000018a8 <__c.5470>:
    18a8:	50 72 6f 73 65 73 00                                Proses.

000018af <__c.5468>:
    18af:	2d 4d 4f 50 20 56 6f 75 63 68 65 72 2d 00           -MOP Voucher-.

000018bd <__c.5465>:
    18bd:	50 72 6f 73 65 73 00                                Proses.

000018c4 <__c.5463>:
    18c4:	49 44 3a 25 73 00                                   ID:%s.

000018ca <__c.5459>:
    18ca:	5b 2a 5d 42 61 63 6b 20 20 20 20 5b 23 5d 45 78     [*]Back    [#]Ex
    18da:	69 74 00                                            it.

000018dd <__c.5457>:
    18dd:	46 49 50 25 73 00                                   FIP%s.

000018e3 <__c.5455>:
    18e3:	54 61 70 20 4b 61 72 74 75 20 52 46 49 44 00        Tap Kartu RFID.

000018f2 <__c.5446>:
    18f2:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    1902:	6e 74 65 72 00                                      nter.

00001907 <__c.5444>:
    1907:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
    1917:	6e 74 65 72 00                                      nter.

0000191c <__c.5441>:
    191c:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    192c:	6e 74 65 72 00                                      nter.

00001931 <__c.5439>:
    1931:	53 75 72 63 68 61 72 67 65 3a 20 20 20 5f 25 00     Surcharge:   _%.

00001941 <__c.5437>:
    1941:	25 73 00                                            %s.

00001944 <__c.5433>:
    1944:	5b 2a 5d 42 61 63 6b 00                             [*]Back.

0000194c <__c.5428>:
    194c:	25 64 2e 25 73 00                                   %d.%s.

00001952 <__c.5426>:
    1952:	53 65 6c 65 63 74 20 42 61 6e 6b 00                 Select Bank.

0000195e <__c.5421>:
    195e:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    196e:	6e 74 65 72 00                                      nter.

00001973 <__c.5419>:
    1973:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
    1983:	6e 74 65 72 00                                      nter.

00001988 <__c.5416>:
    1988:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    1998:	6e 74 65 72 00                                      nter.

0000199d <__c.5414>:
    199d:	5f 00                                               _.

0000199f <__c.5412>:
    199f:	4b 6f 64 65 20 56 6f 75 63 68 65 72 00              Kode Voucher.

000019ac <__c.5403>:
    19ac:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 20 20 20 20     [*]Back         
    19bc:	20 20 20 20 00                                          .

000019c1 <__c.5401>:
    19c1:	32 2e 42 61 6e 6b 20 20 20 20 34 2e 50 75 6d 70     2.Bank    4.Pump
    19d1:	54 65 73 74 00                                      Test.

000019d6 <__c.5399>:
    19d6:	31 2e 41 63 63 6f 75 6e 74 20 33 2e 56 6f 75 63     1.Account 3.Vouc
    19e6:	68 65 72 20 00                                      her .

000019eb <__c.5397>:
    19eb:	20 20 20 53 65 6c 65 63 74 20 50 61 79 6d 65 6e        Select Paymen
    19fb:	74 20 20 20 00                                      t   .

00001a00 <__c.5348>:
    1a00:	43 52 45 44 49 54 43 41 52 44 00                    CREDITCARD.

00001a0b <__c.5342>:
    1a0b:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 20 20 20 20     [*]Back         
    1a1b:	20 20 20 20 00                                          .

00001a20 <__c.5340>:
    1a20:	32 2e 43 72 65 64 69 74 20 43 61 72 64 20 20 20     2.Credit Card   
    1a30:	20 20 20 20 00                                          .

00001a35 <__c.5338>:
    1a35:	31 2e 44 65 62 69 74 2f 46 6c 61 73 68 20 43 61     1.Debit/Flash Ca
    1a45:	72 64 20 20 00                                      rd  .

00001a4a <__c.5336>:
    1a4a:	53 65 6c 65 63 74 20 43 61 72 64 20 54 79 70 65     Select Card Type
	...

00001a5b <__c.5302>:
    1a5b:	4e 6f 20 43 6f 6e 6e 65 63 74 69 6f 6e 00           No Connection.

00001a69 <__c.5300>:
    1a69:	54 43 50 2f 49 50 20 45 52 52 4f 52 20 00           TCP/IP ERROR .

00001a77 <__c.5293>:
    1a77:	50 72 65 73 73 20 41 6e 79 20 4b 65 79 00           Press Any Key.

00001a85 <__c.5291>:
    1a85:	43 6d 20 56 6f 6c 3a 25 73 00                       Cm Vol:%s.

00001a8f <__c.5289>:
    1a8f:	43 4d 20 41 6d 74 3a 25 73 00                       CM Amt:%s.

00001a99 <__c.5287>:
    1a99:	50 6f 69 6e 74 73 3a 25 73 00                       Points:%s.

00001aa3 <__c.5285>:
    1aa3:	25 73 3a 25 73 00                                   %s:%s.

00001aa9 <__c.5278>:
    1aa9:	50 72 6f 73 65 73 00                                Proses.

00001ab0 <__c.5276>:
    1ab0:	49 44 3a 25 73 00                                   ID:%s.

00001ab6 <__c.5272>:
    1ab6:	5b 2a 5d 42 61 63 6b 20 20 20 20 5b 23 5d 45 78     [*]Back    [#]Ex
    1ac6:	69 74 00                                            it.

00001ac9 <__c.5270>:
    1ac9:	54 61 70 20 4b 61 72 74 75 20 52 46 49 44 00        Tap Kartu RFID.

00001ad8 <__c.5267>:
    1ad8:	5b 2a 5d 42 61 63 6b 20 20 20 20 5b 23 5d 45 78     [*]Back    [#]Ex
    1ae8:	69 74 00                                            it.

00001aeb <__c.5265>:
    1aeb:	54 61 70 20 4b 61 72 74 75 20 52 46 49 44 00        Tap Kartu RFID.

00001afa <__c.5263>:
    1afa:	46 49 50 3a 25 73 00                                FIP:%s.

00001b01 <__c.5257>:
    1b01:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 20 20 20 20     [*]Back         
    1b11:	20 00                                                .

00001b13 <__c.5255>:
    1b13:	32 2e 4c 6f 79 61 6c 74 79 20 55 70 64 61 74 65     2.Loyalty Update
    1b23:	20 00                                                .

00001b25 <__c.5253>:
    1b25:	31 2e 45 6e 71 75 69 72 79 20 20 20 20 20 20 20     1.Enquiry       
    1b35:	20 00                                                .

00001b37 <__c.5251>:
    1b37:	20 20 4d 65 6e 75 20 4c 6f 79 61 6c 74 79 20 20       Menu Loyalty  
    1b47:	20 00                                                .

00001b49 <__c.5216>:
    1b49:	4e 6f 20 43 6f 6e 6e 65 63 74 69 6f 6e 00           No Connection.

00001b57 <__c.5214>:
    1b57:	54 43 50 2f 49 50 20 45 52 52 4f 52 20 00           TCP/IP ERROR .

00001b65 <__c.5208>:
    1b65:	5b 2a 5d 42 61 63 6b 20 20 20 20 5b 23 5d 45 78     [*]Back    [#]Ex
    1b75:	69 74 00                                            it.

00001b78 <__c.5206>:
    1b78:	54 61 70 20 53 75 70 65 72 76 69 73 6f 72 20 43     Tap Supervisor C
    1b88:	61 72 64 00                                         ard.

00001b8c <__c.5204>:
    1b8c:	52 65 50 72 69 6e 74 20 46 49 50 3a 25 73 20 00     RePrint FIP:%s .

00001b9c <__c.5200>:
    1b9c:	54 69 64 61 6b 20 41 64 61 20 54 72 61 6e 73 61     Tidak Ada Transa
    1bac:	6b 73 69 20 00                                      ksi .

00001bb1 <__c.5194>:
    1bb1:	41 63 63 65 73 73 20 44 65 6e 69 65 64 00           Access Denied.

00001bbf <__c.5151>:
    1bbf:	25 2e 32 64 00                                      %.2d.

00001bc4 <__c.5147>:
    1bc4:	2a 29 45 78 69 74 00                                *)Exit.

00001bcb <__c.5145>:
    1bcb:	23 29 4f 4b 20 00                                   #)OK .

00001bd1 <__c.5143>:
    1bd1:	20 20 20 20 20 00                                        .

00001bd7 <__c.5141>:
    1bd7:	46 49 50 3a 5f 00                                   FIP:_.

00001bdd <__c.5136>:
    1bdd:	25 64 2e 50 25 73 20 7c 20 25 64 2e 50 25 73 00     %d.P%s | %d.P%s.

00001bed <__c.5087>:
    1bed:	30 32 25 73 25 73 25 73 25 73 25 73 25 73 25 73     02%s%s%s%s%s%s%s
	...

00001bfe <__c.4944>:
    1bfe:	30 00                                               0.

00001c00 <__c.4875>:
    1c00:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    1c10:	20 20 20 20 00                                          .

00001c15 <__c.4870>:
    1c15:	23 25 73 00                                         #%s.

00001c19 <__c.4868>:
    1c19:	25 2e 32 64 00                                      %.2d.

00001c1e <__c.4866>:
    1c1e:	40 46 49 50 3a 00                                   @FIP:.

00001c24 <__c.4864>:
    1c24:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    1c34:	20 20 20 20 00                                          .

00001c39 <__c.4860>:
    1c39:	50 72 69 6e 74 69 6e 67 20 46 49 50 25 73 20 00     Printing FIP%s .

00001c49 <__c.4836>:
    1c49:	44 3a 25 64 20 43 3a 25 63 20 20 00                 D:%d C:%c  .

00001c55 <__c.4825>:
    1c55:	25 73 20 25 73 00                                   %s %s.

00001c5b <__c.4798>:
    1c5b:	4e 6f 20 50 75 6d 70 20 46 6f 75 6e 64 00           No Pump Found.

00001c69 <__c.4796>:
    1c69:	54 43 50 2f 49 50 20 45 72 72 6f 72 00              TCP/IP Error.

00001c76 <__c.4794>:
    1c76:	50 75 6d 70 46 6f 75 6e 64 00                       PumpFound.

00001c80 <__c.4792>:
    1c80:	43 6f 6e 6e 65 63 74 65 64 00                       Connected.

00001c8a <__c.4787>:
    1c8a:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    1c9a:	20 20 20 00                                            .

00001c9e <__c.4785>:
    1c9e:	25 73 00                                            %s.

00001ca1 <__c.4780>:
    1ca1:	53 63 61 6e 20 50 75 6d 70 00                       Scan Pump.

00001cab <__c.4775>:
    1cab:	43 6f 6e 6e 65 63 74 20 20 20 20 20 20 20 20 20     Connect         
	...

00001cbc <__c.4773>:
    1cbc:	43 6f 6e 6e 65 63 74 00                             Connect.

00001cc4 <__c.4771>:
    1cc4:	43 6f 6e 6e 65 63 74 20 20 20 20 20 20 20 20 20     Connect         
	...

00001cd5 <__c.4744>:
    1cd5:	43 4f 4d 25 64 3a 25 69 20 20 20 20 20 20 20 20     COM%d:%i        
    1ce5:	20 20 20 00                                            .

00001ce9 <__c.4742>:
    1ce9:	49 6e 69 74 69 61 6c 69 7a 65 20 43 4f 4d 20 2e     Initialize COM .
    1cf9:	2e 2e 00                                            ...

00001cfc <__c.4703>:
    1cfc:	0a 47 65 4e 69 55 73 20 54 69 63 6b 65 74 20 50     .GeNiUs Ticket P
    1d0c:	72 69 6e 74 65 72 20 0a 20 56 65 72 73 69 6f 6e     rinter . Version
    1d1c:	3a 25 73 0a 20 4c 61 73 74 20 55 70 64 61 74 65     :%s. Last Update
    1d2c:	20 25 73 20 0a 20 48 61 6e 69 6e 64 6f 20 41 75      %s . Hanindo Au
    1d3c:	74 6f 6d 61 74 69 6f 6e 20 53 6f 6c 75 74 69 6f     tomation Solutio
    1d4c:	6e 73 20 0a 20 77 77 77 2e 68 61 6e 69 6e 64 6f     ns . www.hanindo
    1d5c:	67 72 6f 75 70 2e 63 6f 6d 0a 0a 0a 0a 0a 0a 0a     group.com.......
    1d6c:	0a 00                                               ..

00001d6e <__c.4701>:
    1d6e:	31 34 2f 30 32 2f 32 30 31 31 00                    14/02/2011.

00001d79 <__c.4699>:
    1d79:	32 2e 33 36 00                                      2.36.

00001d7e <__c.4690>:
    1d7e:	25 73 25 73 25 73 25 73 39 38 25 2e 32 64 46 39     %s%s%s%s98%.2dF9
    1d8e:	36 38 43 46 46 42 00                                68CFFB.

00001d95 <__c.4594>:
    1d95:	46 75 65 6c 69 6e 67 20 40 46 49 50 3a 23 25 64     Fueling @FIP:#%d
	...

00001da6 <__c.4592>:
    1da6:	54 72 61 6e 73 61 6b 73 69 20 53 65 6c 65 73 61     Transaksi Selesa
    1db6:	69 00                                               i.

00001db8 <__c.4588>:
    1db8:	49 44 3a 20 25 73 00                                ID: %s.

00001dbf <__c.4586>:
    1dbf:	25 73 00                                            %s.

00001dc2 <__c.4584>:
    1dc2:	50 25 73 20 25 73 20 00                             P%s %s .

00001dca <__c.4580>:
    1dca:	46 49 50 20 54 69 64 61 6b 20 53 69 61 70 20 20     FIP Tidak Siap  
    1dda:	20 20 00                                              .

00001ddd <__c.4577>:
    1ddd:	41 75 74 68 6f 72 69 73 61 73 69 20 42 65 72 68     Authorisasi Berh
    1ded:	61 73 69 6c 00                                      asil.

00001df2 <__c.4573>:
    1df2:	41 75 74 68 6f 72 69 73 61 73 69 20 47 61 67 61     Authorisasi Gaga
    1e02:	6c 20 20 20 00                                      l   .

00001e07 <__c.4569>:
    1e07:	20 20 20 20 20 20 20 00                                    .

00001e0f <__c.4566>:
    1e0f:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    1e1f:	20 20 20 20 00                                          .

00001e24 <__c.4564>:
    1e24:	4d 6f 68 6f 6e 20 54 75 6e 67 67 75 20 20 20 20     Mohon Tunggu    
    1e34:	20 20 20 20 00                                          .

00001e39 <__c.4562>:
    1e39:	25 73 00                                            %s.

00001e3c <__c.4560>:
    1e3c:	50 25 73 20 25 73 20 00                             P%s %s .

00001e44 <__c.4557>:
    1e44:	43 61 6e 63 65 6c 20 54 72 61 6e 73 61 63 74 69     Cancel Transacti
    1e54:	6f 6e 20 20 00                                      on  .

00001e59 <__c.4554>:
    1e59:	5b 2a 5d 42 61 63 6b 20 5b 30 5d 45 53 43 20 5b     [*]Back [0]ESC [
    1e69:	23 5d 4f 4b 00                                      #]OK.

00001e6e <__c.4552>:
    1e6e:	25 73 20 00                                         %s .

00001e72 <__c.4550>:
    1e72:	20 46 75 6c 6c 00                                    Full.

00001e78 <__c.4548>:
    1e78:	25 73 20 20 25 73 20 00                             %s  %s .

00001e80 <__c.4546>:
    1e80:	49 44 3a 20 25 73 00                                ID: %s.

00001e87 <__c.4544>:
    1e87:	25 73 20 00                                         %s .

00001e8b <__c.4540>:
    1e8b:	5b 2a 5d 42 61 63 6b 20 20 5b 23 5d 4f 4b 20 20     [*]Back  [#]OK  
    1e9b:	20 00                                                .

00001e9d <__c.4538>:
    1e9d:	4f 64 6f 6d 65 74 65 72 3a 5f 20 20 20 20 20 20     Odometer:_      
    1ead:	20 00                                                .

00001eaf <__c.4536>:
    1eaf:	25 73 20 00                                         %s .

00001eb3 <__c.4534>:
    1eb3:	20 20 25 73 20 25 73 20 00                            %s %s .

00001ebc <__c.4532>:
    1ebc:	50 75 6d 70 20 50 72 6f 64 75 63 74 20 41 6d 6f     Pump Product Amo
    1ecc:	75 6e 74 00                                         unt.

00001ed0 <__c.4530>:
    1ed0:	50 75 6d 70 20 50 72 6f 64 75 63 74 20 56 6f 6c     Pump Product Vol
    1ee0:	75 6d 65 00                                         ume.

00001ee4 <__c.4528>:
    1ee4:	20 20 54 61 6e 6b 00                                  Tank.

00001eeb <__c.4526>:
    1eeb:	20 20 25 73 20 25 73 20 00                            %s %s .

00001ef4 <__c.4524>:
    1ef4:	50 75 6d 70 20 50 72 6f 64 75 63 74 20 20 20 46     Pump Product   F
    1f04:	75 6c 6c 00                                         ull.

00001f08 <__c.4520>:
    1f08:	5b 2a 5d 42 61 63 6b 20 20 5b 23 5d 4f 4b 20 20     [*]Back  [#]OK  
    1f18:	20 20 20 20 00                                          .

00001f1d <__c.4518>:
    1f1d:	5b 32 5d 41 6d 6f 75 6e 74 3a 5f 20 20 20 20 20     [2]Amount:_     
    1f2d:	20 20 20 20 00                                          .

00001f32 <__c.4516>:
    1f32:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    1f42:	20 20 20 20 00                                          .

00001f47 <__c.4514>:
    1f47:	50 25 73 2d 25 73 20 00                             P%s-%s .

00001f4f <__c.4512>:
    1f4f:	5b 2a 5d 42 61 63 6b 20 20 5b 23 5d 4f 4b 20 20     [*]Back  [#]OK  
    1f5f:	20 20 20 20 00                                          .

00001f64 <__c.4510>:
    1f64:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    1f74:	20 20 20 20 00                                          .

00001f79 <__c.4508>:
    1f79:	5b 31 5d 56 6f 6c 75 6d 65 3a 5f 20 20 20 20 20     [1]Volume:_     
    1f89:	20 20 20 20 00                                          .

00001f8e <__c.4506>:
    1f8e:	50 25 73 2d 25 73 20 00                             P%s-%s .

00001f96 <__c.4503>:
    1f96:	41 00                                               A.

00001f98 <__c.4501>:
    1f98:	41 00                                               A.

00001f9a <__c.4499>:
    1f9a:	56 00                                               V.

00001f9c <__c.4496>:
    1f9c:	5b 2a 5d 42 61 63 6b 20 20 20 20 5b 23 5d 4e 65     [*]Back    [#]Ne
    1fac:	78 74 20 20 00                                      xt  .

00001fb1 <__c.4494>:
    1fb1:	5b 32 5d 41 6d 6f 75 6e 74 20 20 20 20 20 20 20     [2]Amount       
    1fc1:	20 20 20 20 00                                          .

00001fc6 <__c.4492>:
    1fc6:	5b 31 5d 56 6f 6c 75 6d 65 20 20 20 20 20 20 20     [1]Volume       
    1fd6:	20 20 20 20 00                                          .

00001fdb <__c.4490>:
    1fdb:	50 25 73 2d 25 73 20 00                             P%s-%s .

00001fe3 <__c.4487>:
    1fe3:	25 73 00                                            %s.

00001fe6 <__c.4484>:
    1fe6:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 20 20 20 20     [*]Back         
    1ff6:	20 20 20 20 00                                          .

00001ffb <__c.4479>:
    1ffb:	20 20 20 20 20 00                                        .

00002001 <__c.4477>:
    2001:	25 64 2e 25 73 00                                   %d.%s.

00002007 <__c.4475>:
    2007:	25 73 00                                            %s.

0000200a <__c.4473>:
    200a:	50 6f 6d 70 61 2d 25 73 00                          Pompa-%s.

00002013 <__c.4469>:
    2013:	25 2e 32 64 00                                      %.2d.

00002018 <__c.4467>:
    2018:	25 2e 32 64 00                                      %.2d.

0000201d <__c.4463>:
    201d:	5b 2a 5d 42 61 74 61 6c 20 20 20 20 20 20 20 5b     [*]Batal       [
    202d:	23 5d 4f 4b 00                                      #]OK.

00002032 <__c.4461>:
    2032:	25 73 20 25 73 00                                   %s %s.

00002038 <__c.4459>:
    2038:	25 73 00                                            %s.

0000203b <__c.4457>:
    203b:	25 73 00                                            %s.

0000203e <__c.4455>:
    203e:	25 73 00                                            %s.

00002041 <__c.4452>:
    2041:	4b 61 72 74 75 20 54 65 72 62 61 74 61 73 20 20     Kartu Terbatas  
    2051:	20 20 20 20 00                                          .

00002056 <__c.4450>:
    2056:	54 69 64 61 6b 20 54 65 72 64 61 66 74 61 72 20     Tidak Terdaftar 
    2066:	20 20 20 20 00                                          .

0000206b <__c.4447>:
    206b:	44 61 74 61 20 52 65 63 65 69 76 65 64 20 20 20     Data Received   
    207b:	20 20 20 20 00                                          .

00002080 <__c.4444>:
    2080:	54 43 50 2f 49 50 20 45 72 72 6f 72 20 20 20 20     TCP/IP Error    
    2090:	20 20 20 20 00                                          .

00002095 <__c.4442>:
    2095:	53 65 6e 64 69 6e 67 20 46 61 69 6c 65 64 20 20     Sending Failed  
    20a5:	20 20 20 20 00                                          .

000020aa <__c.4439>:
    20aa:	20 20 20 20 20 20 20 00                                    .

000020b2 <__c.4434>:
    20b2:	50 72 6f 73 65 73 00                                Proses.

000020b9 <__c.4432>:
    20b9:	49 44 3a 25 73 00                                   ID:%s.

000020bf <__c.4430>:
    20bf:	20 20 20 4c 6f 63 61 6c 20 41 63 63 6f 75 6e 74        Local Account
    20cf:	20 20 20 00                                            .

000020d3 <__c.4248>:
    20d3:	25 2e 32 64 00                                      %.2d.

000020d8 <__c.4243>:
    20d8:	45 39 34 34 35 35 31 32 00                          E9445512.

000020e1 <__c.4241>:
    20e1:	25 73 25 73 00                                      %s%s.

000020e6 <__c.4239>:
    20e6:	25 73 25 73 25 73 25 73 39 34 00                    %s%s%s%s94.

000020f1 <__c.4234>:
    20f1:	45 39 34 34 35 35 31 32 00                          E9445512.

000020fa <__c.4232>:
    20fa:	25 73 25 73 25 73 00                                %s%s%s.

00002101 <__c.4230>:
    2101:	25 73 25 73 25 73 25 73 00                          %s%s%s%s.

0000210a <__c.4228>:
    210a:	25 73 25 73 25 73 25 73 39 32 00                    %s%s%s%s92.

00002115 <__c.4223>:
    2115:	45 39 34 34 35 35 31 32 00                          E9445512.

0000211e <__c.4221>:
    211e:	25 73 25 73 00                                      %s%s.

00002123 <__c.4219>:
    2123:	25 73 25 73 25 73 25 73 39 30 00                    %s%s%s%s90.

0000212e <__c.4210>:
    212e:	25 64 46 30 30 30 30 30 30 30 45 31 32 33 34 35     %dF0000000E12345
    213e:	36 46 46 46 46 46 25 73 45 39 34 34 35 35 31 32     6FFFFF%sE9445512
	...

0000214f <__c.4208>:
    214f:	25 73 25 73 25 64 25 73 25 73 00                    %s%s%d%s%s.

0000215a <__c.4206>:
    215a:	25 73 25 73 25 73 25 73 35 38 00                    %s%s%s%s58.

00002165 <__c.4201>:
    2165:	41 46 39 36 38 43 46 46 42 00                       AF968CFFB.

0000216f <__c.4199>:
    216f:	25 73 00                                            %s.

00002172 <__c.4197>:
    2172:	25 73 35 36 00                                      %s56.

00002177 <__c.4195>:
    2177:	25 73 25 73 25 73 00                                %s%s%s.

0000217e <__c.4190>:
    217e:	46 39 36 38 43 46 46 42 00                          F968CFFB.

00002187 <__c.4188>:
    2187:	25 73 25 73 00                                      %s%s.

0000218c <__c.4186>:
    218c:	25 73 25 73 25 73 25 73 00                          %s%s%s%s.

00002195 <__c.4184>:
    2195:	25 73 25 73 25 73 25 73 33 32 00                    %s%s%s%s32.

000021a0 <__c.4179>:
    21a0:	25 73 25 73 46 39 36 38 43 46 46 42 00              %s%sF968CFFB.

000021ad <__c.4177>:
    21ad:	25 73 25 73 25 73 25 73 32 38 00                    %s%s%s%s28.

000021b8 <__c.4172>:
    21b8:	25 73 25 73 46 39 36 38 43 46 46 42 00              %s%sF968CFFB.

000021c5 <__c.4170>:
    21c5:	25 73 25 73 25 73 25 73 32 34 00                    %s%s%s%s24.

000021d0 <__c.4165>:
    21d0:	25 73 46 39 36 38 43 46 46 42 00                    %sF968CFFB.

000021db <__c.4163>:
    21db:	25 73 25 73 25 73 25 73 32 32 00                    %s%s%s%s22.

000021e6 <__c.4158>:
    21e6:	25 73 25 73 25 73 25 73 31 30 46 39 36 38 43 46     %s%s%s%s10F968CF
    21f6:	46 42 00                                            FB.

000021f9 <__c.4153>:
    21f9:	25 73 25 73 25 73 25 73 30 34 25 73 31 46 39 36     %s%s%s%s04%s1F96
    2209:	38 43 46 46 42 00                                   8CFFB.

0000220f <__c.4139>:
    220f:	25 73 2e 25 73 2e 25 73 2e 25 73 00                 %s.%s.%s.%s.

0000221b <__c.4120>:
    221b:	25 73 2e 25 73 2e 25 73 2e 25 73 00                 %s.%s.%s.%s.

00002227 <__c.4053>:
    2227:	25 73 20 25 73 00                                   %s %s.

0000222d <__c.4051>:
    222d:	32 2e 33 36 00                                      2.36.

00002232 <__c.4049>:
    2232:	47 65 4e 69 55 73 00                                GeNiUs.

00002239 <__c.4035>:
    2239:	50 72 65 73 73 20 61 6e 79 20 6b 65 79 2e 2e 20     Press any key.. 
    2249:	20 20 20 20 00                                          .

0000224e <__c.4023>:
    224e:	5b 31 5d 53 6c 61 76 65 20 5b 32 5d 53 74 61 6e     [1]Slave [2]Stan
    225e:	64 61 6c 6f 6e 65 00                                dalone.

00002265 <__c.3943>:
    2265:	3e 00                                               >.

00002267 <__c.3938>:
    2267:	25 2e 32 64 00                                      %.2d.

0000226c <__c.3936>:
    226c:	25 2e 32 64 00                                      %.2d.

00002271 <__c.3934>:
    2271:	30 00                                               0.

00002273 <__c.3932>:
    2273:	31 00                                               1.

00002275 <__c.3924>:
    2275:	25 64 00                                            %d.

00002278 <__c.3919>:
    2278:	25 2e 32 64 00                                      %.2d.

0000227d <__c.3914>:
    227d:	25 73 00                                            %s.

00002280 <__c.3909>:
    2280:	25 73 00                                            %s.

00002283 <__c.3904>:
    2283:	25 73 00                                            %s.

00002286 <__c.3902>:
    2286:	3c 00                                               <.

00002288 <__c.3834>:
    2288:	3c 4f 4b 3e 00                                      <OK>.

0000228d <__c.3829>:
    228d:	25 64 00                                            %d.

00002290 <__c.3827>:
    2290:	25 64 00                                            %d.

00002293 <__c.3816>:
    2293:	25 64 00                                            %d.

00002296 <__c.3805>:
    2296:	3c 53 61 76 69 6e 67 3e 00                          <Saving>.

0000229f <__c.3803>:
    229f:	4c 65 6e 67 74 68 3a 25 64 00                       Length:%d.

000022a9 <__c.3617>:
    22a9:	25 73 00                                            %s.

000022ac <__c.3559>:
    22ac:	25 73 00                                            %s.

000022af <__c.3557>:
    22af:	25 73 00                                            %s.

000022b2 <__c.3555>:
    22b2:	25 73 00                                            %s.

000022b5 <__c.3553>:
    22b5:	25 73 00                                            %s.

000022b8 <__c.3551>:
    22b8:	25 2e 32 64 00                                      %.2d.

000022bd <__c.3549>:
    22bd:	25 64 00                                            %d.

000022c0 <__c.3547>:
    22c0:	25 73 00                                            %s.

000022c3 <__c.3545>:
    22c3:	25 73 00                                            %s.

000022c6 <__c.3543>:
    22c6:	25 73 00                                            %s.

000022c9 <__c.3541>:
    22c9:	25 64 00                                            %d.

000022cc <__c.3539>:
    22cc:	4e 2f 41 00                                         N/A.

000022d0 <__c.3440>:
    22d0:	25 64 00                                            %d.

000022d3 <__c.3438>:
    22d3:	25 73 00                                            %s.

000022d6 <__c.3436>:
    22d6:	25 73 00                                            %s.

000022d9 <__c.3352>:
    22d9:	54 69 64 61 6b 20 41 64 61 20 54 72 61 6e 73 61     Tidak Ada Transa
    22e9:	6b 73 69 20 00                                      ksi .

000022ee <__c.3349>:
    22ee:	54 6f 74 61 6c 69 7a 65 72 41 6c 6c 20 20 20 20     TotalizerAll    
    22fe:	20 00                                                .

00002300 <__c.3346>:
    2300:	43 6c 65 61 72 20 44 61 74 61 20 54 6f 74 61 6c     Clear Data Total
    2310:	69 7a 65 72 00                                      izer.

00002315 <__c.3334>:
    2315:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
	...

00002326 <__c.3331>:
    2326:	52 65 61 64 79 2e 2e 2e 20 20 20 20 20 20 20 20     Ready...        
    2336:	20 20 20 20 00                                          .

0000233b <__c.3328>:
    233b:	52 65 61 64 79 2e 2e 2e 20 20 20 20 20 20 20 20     Ready...        
    234b:	20 20 20 20 00                                          .

00002350 <__c.3326>:
    2350:	4e 6f 20 52 65 73 70 6f 6e 73 65 2e 2e 20 20 20     No Response..   
    2360:	20 20 20 20 00                                          .

00002365 <__c.3323>:
    2365:	50 6c 65 61 73 65 20 57 61 69 74 2e 2e 20 20 20     Please Wait..   
    2375:	20 20 20 20 00                                          .

0000237a <__c.3320>:
    237a:	52 65 61 64 79 2e 2e 2e 20 20 20 20 20 20 20 20     Ready...        
    238a:	20 20 20 20 00                                          .

0000238f <__c.3317>:
    238f:	54 69 64 61 6b 20 41 64 61 20 54 72 61 6e 73 61     Tidak Ada Transa
    239f:	6b 73 69 20 00                                      ksi .

000023a4 <__c.3312>:
    23a4:	53 65 64 61 6e 67 50 72 6f 73 65 73 00              SedangProses.

000023b1 <__c.3309>:
    23b1:	34 33 35 36 41 33 31 41 00                          4356A31A.

000023ba <__c.1750>:
    23ba:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    23ca:	20 20 20 20 00                                          .

000023cf <__c.1748>:
    23cf:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    23df:	20 20 20 20 00                                          .

000023e4 <__c.1746>:
    23e4:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    23f4:	20 20 20 20 00                                          .

000023f9 <__c.1744>:
    23f9:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    2409:	20 20 20 20 00                                          .

0000240e <__alphanum>:
    240e:	30 20 2e 00 00 00 31 2e 2c 3f 21 00 32 61 62 63     0 ....1.,?!.2abc
    241e:	00 00 33 64 65 66 00 00 34 67 68 69 00 00 35 6a     ..3def..4ghi..5j
    242e:	6b 6c 00 00 36 6d 6e 6f 00 00 37 70 71 72 73 00     kl..6mno..7pqrs.
    243e:	38 74 75 76 00 00 39 77 78 79 7a 00 30 20 2e 00     8tuv..9wxyz.0 ..
    244e:	00 00 31 26 40 2b 2d 00 32 41 42 43 00 00 33 44     ..1&@+-.2ABC..3D
    245e:	45 46 00 00 34 47 48 49 00 00 35 4a 4b 4c 00 00     EF..4GHI..5JKL..
    246e:	36 4d 4e 4f 00 00 37 50 51 52 53 00 38 54 55 56     6MNO..7PQRS.8TUV
    247e:	00 00 39 57 58 59 5a 00                             ..9WXYZ.

00002486 <__maxchar>:
    2486:	02 04 03 03 03 03 03 04 03 04                       ..........

00002490 <__ctors_end>:
    2490:	11 24       	eor	r1, r1
    2492:	1f be       	out	0x3f, r1	; 63
    2494:	cf ef       	ldi	r28, 0xFF	; 255
    2496:	d0 e1       	ldi	r29, 0x10	; 16
    2498:	de bf       	out	0x3e, r29	; 62
    249a:	cd bf       	out	0x3d, r28	; 61

0000249c <__do_copy_data>:
    249c:	11 e0       	ldi	r17, 0x01	; 1
    249e:	a0 e0       	ldi	r26, 0x00	; 0
    24a0:	b1 e0       	ldi	r27, 0x01	; 1
    24a2:	e8 e1       	ldi	r30, 0x18	; 24
    24a4:	ff e6       	ldi	r31, 0x6F	; 111
    24a6:	01 e0       	ldi	r16, 0x01	; 1
    24a8:	0b bf       	out	0x3b, r16	; 59
    24aa:	02 c0       	rjmp	.+4      	; 0x24b0 <__do_copy_data+0x14>
    24ac:	07 90       	elpm	r0, Z+
    24ae:	0d 92       	st	X+, r0
    24b0:	ae 34       	cpi	r26, 0x4E	; 78
    24b2:	b1 07       	cpc	r27, r17
    24b4:	d9 f7       	brne	.-10     	; 0x24ac <__do_copy_data+0x10>

000024b6 <__do_clear_bss>:
    24b6:	1d e0       	ldi	r17, 0x0D	; 13
    24b8:	ae e4       	ldi	r26, 0x4E	; 78
    24ba:	b1 e0       	ldi	r27, 0x01	; 1
    24bc:	01 c0       	rjmp	.+2      	; 0x24c0 <.do_clear_bss_start>

000024be <.do_clear_bss_loop>:
    24be:	1d 92       	st	X+, r1

000024c0 <.do_clear_bss_start>:
    24c0:	ac 3e       	cpi	r26, 0xEC	; 236
    24c2:	b1 07       	cpc	r27, r17
    24c4:	e1 f7       	brne	.-8      	; 0x24be <.do_clear_bss_loop>
    24c6:	0e 94 f8 12 	call	0x25f0	; 0x25f0 <main>
    24ca:	0c 94 8a b7 	jmp	0x16f14	; 0x16f14 <_exit>

000024ce <__bad_interrupt>:
    24ce:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000024d2 <systemOnReset>:
	};
}


void systemOnReset(){
     IsPowerOn=False;
    24d2:	10 92 c9 03 	sts	0x03C9, r1
     if (MCUCSR & 1){   // Power-on Reset
    24d6:	04 b6       	in	r0, 0x34	; 52
    24d8:	00 fe       	sbrs	r0, 0
    24da:	0b c0       	rjmp	.+22     	; 0x24f2 <systemOnReset+0x20>
         MCUCSR=0;lcd_printf(1,1,PSTR("PowerOn"));//Wiznet Blm Ready
    24dc:	14 be       	out	0x34, r1	; 52
    24de:	81 e0       	ldi	r24, 0x01	; 1
    24e0:	61 e0       	ldi	r22, 0x01	; 1
    24e2:	46 e9       	ldi	r20, 0x96	; 150
    24e4:	52 e0       	ldi	r21, 0x02	; 2
    24e6:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		 IsPowerOn=True;
    24ea:	81 e0       	ldi	r24, 0x01	; 1
    24ec:	80 93 c9 03 	sts	0x03C9, r24
    24f0:	18 c0       	rjmp	.+48     	; 0x2522 <systemOnReset+0x50>
         }
     else 
     if (MCUCSR & 2){   // External Reset
    24f2:	04 b6       	in	r0, 0x34	; 52
    24f4:	01 fe       	sbrs	r0, 1
    24f6:	06 c0       	rjmp	.+12     	; 0x2504 <systemOnReset+0x32>
         MCUCSR=0;lcd_printf(1,1,PSTR("External"));
    24f8:	14 be       	out	0x34, r1	; 52
    24fa:	81 e0       	ldi	r24, 0x01	; 1
    24fc:	61 e0       	ldi	r22, 0x01	; 1
    24fe:	4d e8       	ldi	r20, 0x8D	; 141
    2500:	52 e0       	ldi	r21, 0x02	; 2
    2502:	0d c0       	rjmp	.+26     	; 0x251e <systemOnReset+0x4c>
        }
     else 
     if (MCUCSR & 4){   // Brown-Out Reset
    2504:	04 b6       	in	r0, 0x34	; 52
    2506:	02 fe       	sbrs	r0, 2
    2508:	06 c0       	rjmp	.+12     	; 0x2516 <systemOnReset+0x44>
         MCUCSR=0;lcd_printf(1,1,PSTR("BrownOut"));
    250a:	14 be       	out	0x34, r1	; 52
    250c:	81 e0       	ldi	r24, 0x01	; 1
    250e:	61 e0       	ldi	r22, 0x01	; 1
    2510:	44 e8       	ldi	r20, 0x84	; 132
    2512:	52 e0       	ldi	r21, 0x02	; 2
    2514:	04 c0       	rjmp	.+8      	; 0x251e <systemOnReset+0x4c>
         }
     else		  // Watchdog Reset
        {
         lcd_printf(1,1,PSTR("WatchDog"));
    2516:	81 e0       	ldi	r24, 0x01	; 1
    2518:	61 e0       	ldi	r22, 0x01	; 1
    251a:	4b e7       	ldi	r20, 0x7B	; 123
    251c:	52 e0       	ldi	r21, 0x02	; 2
    251e:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
        };
     MCUCSR=0;		  
    2522:	14 be       	out	0x34, r1	; 52
    2524:	80 ee       	ldi	r24, 0xE0	; 224
    2526:	9e e2       	ldi	r25, 0x2E	; 46
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    2528:	20 e7       	ldi	r18, 0x70	; 112
    252a:	31 e0       	ldi	r19, 0x01	; 1
    252c:	f9 01       	movw	r30, r18
    252e:	31 97       	sbiw	r30, 0x01	; 1
    2530:	f1 f7       	brne	.-4      	; 0x252e <systemOnReset+0x5c>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2532:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2534:	d9 f7       	brne	.-10     	; 0x252c <systemOnReset+0x5a>
	 _delay_ms(1200);
}
    2536:	08 95       	ret

00002538 <SystemInit>:


void SystemInit(){
	unsigned int __delay =300;
	lcd_init();
    2538:	0e 94 60 ac 	call	0x158c0	; 0x158c0 <lcd_init>
	lcd_clear();
    253c:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
	BackLightTrig();
    2540:	0e 94 f2 15 	call	0x2be4	; 0x2be4 <BackLightTrig>
	systemOnReset();
    2544:	0e 94 69 12 	call	0x24d2	; 0x24d2 <systemOnReset>

	lcd_printf(4, 1, PSTR("Initialize... "));
    2548:	84 e0       	ldi	r24, 0x04	; 4
    254a:	61 e0       	ldi	r22, 0x01	; 1
    254c:	4c e6       	ldi	r20, 0x6C	; 108
    254e:	52 e0       	ldi	r21, 0x02	; 2
    2550:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
    2554:	88 eb       	ldi	r24, 0xB8	; 184
    2556:	9b e0       	ldi	r25, 0x0B	; 11
    2558:	20 e7       	ldi	r18, 0x70	; 112
    255a:	31 e0       	ldi	r19, 0x01	; 1
    255c:	f9 01       	movw	r30, r18
    255e:	31 97       	sbiw	r30, 0x01	; 1
    2560:	f1 f7       	brne	.-4      	; 0x255e <SystemInit+0x26>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2562:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2564:	d9 f7       	brne	.-10     	; 0x255c <SystemInit+0x24>
	_delay_ms(__delay);
	PORTA = 0XFF;		// Buffer for PORTA
    2566:	9f ef       	ldi	r25, 0xFF	; 255
    2568:	9b bb       	out	0x1b, r25	; 27
	DDRA = 0xFF;		// Pin 3 out (SS _SPI_SLAVE)
    256a:	9a bb       	out	0x1a, r25	; 26
	sbi(PORTA, 3);		// Disable SS _SPI_SLAVE
    256c:	db 9a       	sbi	0x1b, 3	; 27

	//Buzzer PORTB.5
	PORTB = 0xFF;DDRB = 0xFF;
    256e:	98 bb       	out	0x18, r25	; 24
    2570:	97 bb       	out	0x17, r25	; 23
	PORTD = 0b00001101;
    2572:	8d e0       	ldi	r24, 0x0D	; 13
    2574:	82 bb       	out	0x12, r24	; 18
    DDRD =  0b00001001;
    2576:	89 e0       	ldi	r24, 0x09	; 9
    2578:	81 bb       	out	0x11, r24	; 17

	TWBR = 0xFF;
    257a:	90 93 70 00 	sts	0x0070, r25
    //MMC
	PORTE = 0x0E;		// Buffer for PORTE
    257e:	8e e0       	ldi	r24, 0x0E	; 14
    2580:	83 b9       	out	0x03, r24	; 3
	DDRE = 0x0E;		// Pin 3 out (SS _SPI_MMC), pin 2 out (HB)
    2582:	82 b9       	out	0x02, r24	; 2
	sbi(PORTE, 3);		// Disable SS _SPI_MMC
    2584:	1b 9a       	sbi	0x03, 3	; 3
	cbi(PORTE, 2);		// HB on
    2586:	1a 98       	cbi	0x03, 2	; 3

	//Keypad
	PORTF = 0xFF;		// Buffer for PORTF
    2588:	90 93 62 00 	sts	0x0062, r25
	DDRF = 0xF0;		// 4 bit row, 4 bit column
    258c:	80 ef       	ldi	r24, 0xF0	; 240
    258e:	80 93 61 00 	sts	0x0061, r24

  	_spi_init(0,1);//Slave
    2592:	80 e0       	ldi	r24, 0x00	; 0
    2594:	61 e0       	ldi	r22, 0x01	; 1
    2596:	0e 94 58 af 	call	0x15eb0	; 0x15eb0 <_spi_init>
	sbi(DDRB,3);sbi(PORTB,3);//MISO Output
    259a:	bb 9a       	sbi	0x17, 3	; 23
    259c:	c3 9a       	sbi	0x18, 3	; 24
	cbi(DDRB,2);sbi(PORTB,2);//MOSI Input
    259e:	ba 98       	cbi	0x17, 2	; 23
    25a0:	c2 9a       	sbi	0x18, 2	; 24
	cbi(DDRB,1);sbi(PORTB,1);//SCK  Input
    25a2:	b9 98       	cbi	0x17, 1	; 23
    25a4:	c1 9a       	sbi	0x18, 1	; 24

	TCCR1B |= (1 << WGM12);
    25a6:	8e b5       	in	r24, 0x2e	; 46
    25a8:	88 60       	ori	r24, 0x08	; 8
    25aa:	8e bd       	out	0x2e, r24	; 46
	TIMSK |= (1 << OCIE1A);
    25ac:	87 b7       	in	r24, 0x37	; 55
    25ae:	80 61       	ori	r24, 0x10	; 16
    25b0:	87 bf       	out	0x37, r24	; 55
	sei();          //1/14745600=0,06781684028uS *1400 = 100uS 65535-1400+1=64136
    25b2:	78 94       	sei
	OCR1A   = 15624;//49911 -->0,33847384982639 ms
    25b4:	88 e0       	ldi	r24, 0x08	; 8
    25b6:	9d e3       	ldi	r25, 0x3D	; 61
    25b8:	9b bd       	out	0x2b, r25	; 43
    25ba:	8a bd       	out	0x2a, r24	; 42
	TCCR1B |= ((1 << CS10) | (1 << CS11));
    25bc:	8e b5       	in	r24, 0x2e	; 46
    25be:	83 60       	ori	r24, 0x03	; 3
    25c0:	8e bd       	out	0x2e, r24	; 46

	SendSlaveCommand(SC_SLAVE,ST_NONE);
    25c2:	81 e0       	ldi	r24, 0x01	; 1
    25c4:	60 e0       	ldi	r22, 0x00	; 0
    25c6:	0e 94 72 74 	call	0xe8e4	; 0xe8e4 <SendSlaveCommand>
	
	InitComport();
    25ca:	0e 94 f9 9b 	call	0x137f2	; 0x137f2 <InitComport>
	_LIGHT_SET;
    25ce:	81 e0       	ldi	r24, 0x01	; 1
    25d0:	80 93 02 03 	sts	0x0302, r24
    25d4:	10 92 03 03 	sts	0x0303, r1
    25d8:	80 91 65 00 	lds	r24, 0x0065
    25dc:	8d 7f       	andi	r24, 0xFD	; 253
    25de:	80 93 65 00 	sts	0x0065, r24
	InitPrinter();
    25e2:	0e 94 48 4c 	call	0x9890	; 0x9890 <InitPrinter>
    InitializeConnection();
    25e6:	0e 94 66 78 	call	0xf0cc	; 0xf0cc <InitializeConnection>
	lcd_clear(); 
    25ea:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
}
    25ee:	08 95       	ret

000025f0 <main>:
void SystemInit();


//Program Utama
int main(){
	SystemInit();
    25f0:	0e 94 9c 12 	call	0x2538	; 0x2538 <SystemInit>
	while(1){
	//FTestChar();
	//TestUserInput();
    FMenuIdle();
    25f4:	0e 94 27 aa 	call	0x1544e	; 0x1544e <FMenuIdle>
    25f8:	fd cf       	rjmp	.-6      	; 0x25f4 <main+0x4>

000025fa <eeprom_read_byte>:

/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    25fa:	9c 01       	movw	r18, r24
    do {} while (!eeprom_is_ready ());
    25fc:	e1 99       	sbic	0x1c, 1	; 28
    25fe:	fe cf       	rjmp	.-4      	; 0x25fc <eeprom_read_byte+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2600:	3f bb       	out	0x1f, r19	; 31
    2602:	2e bb       	out	0x1e, r18	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2604:	e0 9a       	sbi	0x1c, 0	; 28
    2606:	8d b3       	in	r24, 0x1d	; 29
        : "i" (_SFR_IO_ADDR(EECR)),
          "i" (EERE),
          "i" (_SFR_IO_ADDR(EEDR))
    );
    return __result;
}
    2608:	08 95       	ret

0000260a <eeprom_write_byte>:

/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    260a:	9c 01       	movw	r18, r24
    do {} while (!eeprom_is_ready ());
    260c:	e1 99       	sbic	0x1c, 1	; 28
    260e:	fe cf       	rjmp	.-4      	; 0x260c <eeprom_write_byte+0x2>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2610:	3f bb       	out	0x1f, r19	; 31
    2612:	2e bb       	out	0x1e, r18	; 30
#endif
    EEDR = __value;
    2614:	6d bb       	out	0x1d, r22	; 29

    __asm__ __volatile__ (
    2616:	0f b6       	in	r0, 0x3f	; 63
    2618:	f8 94       	cli
    261a:	e2 9a       	sbi	0x1c, 2	; 28
    261c:	e1 9a       	sbi	0x1c, 1	; 28
    261e:	0f be       	out	0x3f, r0	; 63
          [__sreg]  "i" (_SFR_IO_ADDR(SREG)),
          [__eemwe] "i" (EEMWE),
          [__eewe]  "i" (EEWE)
        : "r0"
    );
}
    2620:	08 95       	ret

00002622 <__vector_12>:
	  strDispenserName3,
	  strDispenserName4,
	  strDispenserName5,
};

ISR(TIMER1_COMPA_vect){//Timer Overflow 1ms
    2622:	1f 92       	push	r1
    2624:	0f 92       	push	r0
    2626:	0f b6       	in	r0, 0x3f	; 63
    2628:	0f 92       	push	r0
    262a:	11 24       	eor	r1, r1
    262c:	2f 93       	push	r18
    262e:	6f 93       	push	r22
    2630:	7f 93       	push	r23
    2632:	8f 93       	push	r24
    2634:	9f 93       	push	r25
		   __sec_sign = 1;
		 }
	}
*/
	//_light_ticker();
	if(__key_light == 1){
    2636:	80 91 02 03 	lds	r24, 0x0302
    263a:	81 30       	cpi	r24, 0x01	; 1
    263c:	81 f4       	brne	.+32     	; 0x265e <__vector_12+0x3c>
		__key_lgtcnt++;
    263e:	80 91 03 03 	lds	r24, 0x0303
    2642:	8f 5f       	subi	r24, 0xFF	; 255
    2644:	80 93 03 03 	sts	0x0303, r24
		if(__key_lgtcnt == 150){
    2648:	86 39       	cpi	r24, 0x96	; 150
    264a:	49 f4       	brne	.+18     	; 0x265e <__vector_12+0x3c>
		   __key_light = 0; 
    264c:	10 92 02 03 	sts	0x0302, r1
		   __key_lgtcnt = 0; 
    2650:	10 92 03 03 	sts	0x0303, r1
		   sbi(PORTG, 1);
    2654:	80 91 65 00 	lds	r24, 0x0065
    2658:	82 60       	ori	r24, 0x02	; 2
    265a:	80 93 65 00 	sts	0x0065, r24
	if (__i_timer > 5){
		__i_timer = 0;
		PORTE = PORTE^0x04;
	}*/
	//Beep
	if (TimBeep>0){
    265e:	80 91 bf 01 	lds	r24, 0x01BF
    2662:	88 23       	and	r24, r24
    2664:	31 f0       	breq	.+12     	; 0x2672 <__vector_12+0x50>
	    TimBeep--;
    2666:	81 50       	subi	r24, 0x01	; 1
    2668:	80 93 bf 01 	sts	0x01BF, r24
		DDRB=(DDRB|0b00100000);
    266c:	bd 9a       	sbi	0x17, 5	; 23
	    PORTB=(PORTB&0b11011111);
    266e:	c5 98       	cbi	0x18, 5	; 24
    2670:	05 c0       	rjmp	.+10     	; 0x267c <__vector_12+0x5a>
	    }
	else{PORTB=(PORTB|~PORTB);
    2672:	98 b3       	in	r25, 0x18	; 24
    2674:	88 b3       	in	r24, 0x18	; 24
    2676:	80 95       	com	r24
    2678:	89 2b       	or	r24, r25
    267a:	88 bb       	out	0x18, r24	; 24
		}
    //LocalAccount
	TimLocAcc++;
    267c:	80 91 bd 01 	lds	r24, 0x01BD
    2680:	8f 5f       	subi	r24, 0xFF	; 255
    2682:	80 93 bd 01 	sts	0x01BD, r24
	//DisplaTicker
    TimTicker++;
    2686:	80 91 93 01 	lds	r24, 0x0193
    268a:	8f 5f       	subi	r24, 0xFF	; 255
    268c:	80 93 93 01 	sts	0x0193, r24
	TimPressed++;
    2690:	20 91 94 01 	lds	r18, 0x0194
    2694:	2f 5f       	subi	r18, 0xFF	; 255
    2696:	20 93 94 01 	sts	0x0194, r18
	if ((TimPressed%5)==0){
    269a:	82 2f       	mov	r24, r18
    269c:	65 e0       	ldi	r22, 0x05	; 5
    269e:	0e 94 f1 b6 	call	0x16de2	; 0x16de2 <__udivmodqi4>
    26a2:	99 23       	and	r25, r25
    26a4:	71 f4       	brne	.+28     	; 0x26c2 <__vector_12+0xa0>
	    PORTE = PORTE^0x04;
    26a6:	83 b1       	in	r24, 0x03	; 3
    26a8:	94 e0       	ldi	r25, 0x04	; 4
    26aa:	89 27       	eor	r24, r25
    26ac:	83 b9       	out	0x03, r24	; 3
	    TimDisplay++;
    26ae:	80 91 95 01 	lds	r24, 0x0195
    26b2:	8f 5f       	subi	r24, 0xFF	; 255
    26b4:	80 93 95 01 	sts	0x0195, r24
		TimPrintBusy++;
    26b8:	80 91 b8 01 	lds	r24, 0x01B8
    26bc:	8f 5f       	subi	r24, 0xFF	; 255
    26be:	80 93 b8 01 	sts	0x01B8, r24
	}
	if ((TimPressed%PRESSED_DELAY)==0){
    26c2:	82 2f       	mov	r24, r18
    26c4:	6a e0       	ldi	r22, 0x0A	; 10
    26c6:	0e 94 f1 b6 	call	0x16de2	; 0x16de2 <__udivmodqi4>
    26ca:	99 23       	and	r25, r25
    26cc:	29 f4       	brne	.+10     	; 0x26d8 <__vector_12+0xb6>
	     ProcTimeOut++;
    26ce:	80 91 be 01 	lds	r24, 0x01BE
    26d2:	8f 5f       	subi	r24, 0xFF	; 255
    26d4:	80 93 be 01 	sts	0x01BE, r24
	}
	TimSend++;
    26d8:	80 91 af 0d 	lds	r24, 0x0DAF
    26dc:	8f 5f       	subi	r24, 0xFF	; 255
    26de:	80 93 af 0d 	sts	0x0DAF, r24
}
    26e2:	9f 91       	pop	r25
    26e4:	8f 91       	pop	r24
    26e6:	7f 91       	pop	r23
    26e8:	6f 91       	pop	r22
    26ea:	2f 91       	pop	r18
    26ec:	0f 90       	pop	r0
    26ee:	0f be       	out	0x3f, r0	; 63
    26f0:	0f 90       	pop	r0
    26f2:	1f 90       	pop	r1
    26f4:	18 95       	reti

000026f6 <RePrintStandalone>:

char RePrintStandalone(char FIPAddr){
     char Result=PS_NONE;

   return Result;
}
    26f6:	86 e1       	ldi	r24, 0x16	; 22
    26f8:	08 95       	ret

000026fa <GetPumpStatusLabel>:


char GetPumpStatusLabel(char xPumpStatus){
     char Result;

	 switch(xPumpStatus){
    26fa:	e8 2f       	mov	r30, r24
    26fc:	f0 e0       	ldi	r31, 0x00	; 0
    26fe:	ee 31       	cpi	r30, 0x1E	; 30
    2700:	f1 05       	cpc	r31, r1
    2702:	70 f5       	brcc	.+92     	; 0x2760 <GetPumpStatusLabel+0x66>
    2704:	ea 5b       	subi	r30, 0xBA	; 186
    2706:	ff 4f       	sbci	r31, 0xFF	; 255
    2708:	ee 0f       	add	r30, r30
    270a:	ff 1f       	adc	r31, r31
    270c:	05 90       	lpm	r0, Z+
    270e:	f4 91       	lpm	r31, Z+
    2710:	e0 2d       	mov	r30, r0
    2712:	09 94       	ijmp
    2714:	81 e3       	ldi	r24, 0x31	; 49
    2716:	08 95       	ret
    2718:	85 e4       	ldi	r24, 0x45	; 69
    271a:	08 95       	ret
    271c:	82 e3       	ldi	r24, 0x32	; 50
    271e:	08 95       	ret
	 case PUMP_ST1: 
	      Result='1';
		  break;
	 case PUMP_ST2: 
	 	  Result='2';
		  break;
    2720:	83 e3       	ldi	r24, 0x33	; 51
    2722:	08 95       	ret
     case PUMP_ST3:
	 	  Result='3';
		  break;	
    2724:	84 e3       	ldi	r24, 0x34	; 52
    2726:	08 95       	ret
	 case PUMP_ST4: 
          Result='4';
		  break;
    2728:	85 e3       	ldi	r24, 0x35	; 53
    272a:	08 95       	ret
	 case PUMP_ST5: 
	 	  Result='5';
		  break;
    272c:	89 e6       	ldi	r24, 0x69	; 105
    272e:	08 95       	ret
	 case PUMP_OFF: 
	 case PW_ONLINE:
	 	  Result='i';
		  break;
    2730:	8e e6       	ldi	r24, 0x6E	; 110
    2732:	08 95       	ret
     case PW_CALL:
	 case PUMP_CALL: 
	 	  Result='n';
		  break;     
    2734:	81 e6       	ldi	r24, 0x61	; 97
    2736:	08 95       	ret
	 case PUMP_AUTH: 
	 	  Result='a';
		  break;
    2738:	84 e6       	ldi	r24, 0x64	; 100
    273a:	08 95       	ret
     case PW_AUTHORIZED:
	 case PUMP_BUSY: 
	 	  Result='d';
		  break;
    273c:	8f e4       	ldi	r24, 0x4F	; 79
    273e:	08 95       	ret
	 case PUMP_PEOT: 
	 	  Result='O';
		  break;
    2740:	86 e4       	ldi	r24, 0x46	; 70
    2742:	08 95       	ret
     case PW_END_DELIVERY:
	 case PUMP_FEOT: 
	 	  Result='F';
		  break;
    2744:	83 e5       	ldi	r24, 0x53	; 83
    2746:	08 95       	ret
	 case PUMP_STOP: 
	 	  Result='S';
		  break;
    2748:	8d e2       	ldi	r24, 0x2D	; 45
    274a:	08 95       	ret
	 case PUMP_NONE:
	 case PW_DISCONNECT:
	 	  Result='-';
		  break;
    274c:	80 e5       	ldi	r24, 0x50	; 80
    274e:	08 95       	ret
     case PS_PRINT_READY:
	      Result='P';
 	      break;
    2750:	89 e4       	ldi	r24, 0x49	; 73
    2752:	08 95       	ret
     case PS_PRINTED:
	      Result='I';
 	      break;
    2754:	86 e5       	ldi	r24, 0x56	; 86
    2756:	08 95       	ret
     case PS_VOID:
	      Result='V';
	      break;
    2758:	84 e5       	ldi	r24, 0x54	; 84
    275a:	08 95       	ret
     case PS_TOTALIZER:
	      Result='T';
	      break;
    275c:	84 e7       	ldi	r24, 0x74	; 116
    275e:	08 95       	ret
     case PS_FINISH_TOTALIZER:
	      Result='t';
	      break;
    2760:	88 e7       	ldi	r24, 0x78	; 120
	 default:
          Result='x';
		  break;         	 
	 }
  return Result;	 
}
    2762:	08 95       	ret

00002764 <SendPoolingCommand>:
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    2764:	80 93 b9 06 	sts	0x06B9, r24
	 PoolMsg=plMsg;
    2768:	60 93 0a 0d 	sts	0x0D0A, r22
     IsControlPooling=True;
    276c:	81 e0       	ldi	r24, 0x01	; 1
    276e:	80 93 87 01 	sts	0x0187, r24
}
    2772:	08 95       	ret

00002774 <ScanEDCFlow>:
	 RemZeroLead(strMsgID);
	 Result=atoi(strMsgID);
  return Result;
}

void ScanEDCFlow(char data){
    2774:	28 2f       	mov	r18, r24
     char i;

	 //_uart(0,1,data);

     //EDC-MSG
     if (data==0x02){
    2776:	82 30       	cpi	r24, 0x02	; 2
    2778:	39 f4       	brne	.+14     	; 0x2788 <ScanEDCFlow+0x14>
	     IsEDCFlow=True;
    277a:	81 e0       	ldi	r24, 0x01	; 1
    277c:	80 93 f7 02 	sts	0x02F7, r24
		 nFlow=0;
    2780:	10 92 f5 02 	sts	0x02F5, r1
    2784:	10 92 f4 02 	sts	0x02F4, r1
	 }//FillMessage
     if (IsEDCFlow==True){
    2788:	80 91 f7 02 	lds	r24, 0x02F7
    278c:	81 30       	cpi	r24, 0x01	; 1
    278e:	69 f4       	brne	.+26     	; 0x27aa <ScanEDCFlow+0x36>
	     rcv_trans[nFlow]=data;
    2790:	80 91 f4 02 	lds	r24, 0x02F4
    2794:	90 91 f5 02 	lds	r25, 0x02F5
    2798:	fc 01       	movw	r30, r24
    279a:	ef 5a       	subi	r30, 0xAF	; 175
    279c:	f5 4f       	sbci	r31, 0xF5	; 245
    279e:	20 83       	st	Z, r18
		 nFlow++;
    27a0:	01 96       	adiw	r24, 0x01	; 1
    27a2:	90 93 f5 02 	sts	0x02F5, r25
    27a6:	80 93 f4 02 	sts	0x02F4, r24
	 }//CloseMessage
	 if ((data==0x03)||(nFlow>=MSG03_LENGTH)){
    27aa:	23 30       	cpi	r18, 0x03	; 3
    27ac:	41 f0       	breq	.+16     	; 0x27be <ScanEDCFlow+0x4a>
    27ae:	80 91 f4 02 	lds	r24, 0x02F4
    27b2:	90 91 f5 02 	lds	r25, 0x02F5
    27b6:	8d 34       	cpi	r24, 0x4D	; 77
    27b8:	91 05       	cpc	r25, r1
    27ba:	08 f4       	brcc	.+2      	; 0x27be <ScanEDCFlow+0x4a>
    27bc:	9b c0       	rjmp	.+310    	; 0x28f4 <ScanEDCFlow+0x180>
	     //for(i=0;i<nFlow;i++){_uart(0,1,rcv_trans[i]);}
	     IsEDCFlow=False;
    27be:	10 92 f7 02 	sts	0x02F7, r1
		 EDCMsgCode=((rcv_trans[1]-'0')*10)+(rcv_trans[2]-'0');
    27c2:	30 91 53 0a 	lds	r19, 0x0A53
    27c6:	30 51       	subi	r19, 0x10	; 16
    27c8:	80 91 52 0a 	lds	r24, 0x0A52
    27cc:	2a e0       	ldi	r18, 0x0A	; 10
    27ce:	82 9f       	mul	r24, r18
    27d0:	c0 01       	movw	r24, r0
    27d2:	11 24       	eor	r1, r1
    27d4:	38 0f       	add	r19, r24
    27d6:	30 93 f6 02 	sts	0x02F6, r19

		 if (EDCMsgCode==0x03){
    27da:	33 30       	cpi	r19, 0x03	; 3
    27dc:	09 f0       	breq	.+2      	; 0x27e0 <ScanEDCFlow+0x6c>
    27de:	65 c0       	rjmp	.+202    	; 0x28aa <ScanEDCFlow+0x136>
    27e0:	e4 e5       	ldi	r30, 0x54	; 84
    27e2:	fa e0       	ldi	r31, 0x0A	; 10
    27e4:	ae eb       	ldi	r26, 0xBE	; 190
    27e6:	bd e0       	ldi	r27, 0x0D	; 13
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    27e8:	81 91       	ld	r24, Z+
    27ea:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    27ec:	8a e0       	ldi	r24, 0x0A	; 10
    27ee:	ea 35       	cpi	r30, 0x5A	; 90
    27f0:	f8 07       	cpc	r31, r24
    27f2:	d1 f7       	brne	.-12     	; 0x27e8 <ScanEDCFlow+0x74>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    27f4:	10 92 c4 0d 	sts	0x0DC4, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    27f8:	80 81       	ld	r24, Z
    27fa:	80 93 cb 08 	sts	0x08CB, r24
    27fe:	81 81       	ldd	r24, Z+1	; 0x01
    2800:	80 93 cc 08 	sts	0x08CC, r24
	 }Dest[Length]=0;
    2804:	10 92 cd 08 	sts	0x08CD, r1
    2808:	32 96       	adiw	r30, 0x02	; 2
    280a:	aa ed       	ldi	r26, 0xDA	; 218
    280c:	bd e0       	ldi	r27, 0x0D	; 13
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    280e:	81 91       	ld	r24, Z+
    2810:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2812:	8a e0       	ldi	r24, 0x0A	; 10
    2814:	eb 36       	cpi	r30, 0x6B	; 107
    2816:	f8 07       	cpc	r31, r24
    2818:	d1 f7       	brne	.-12     	; 0x280e <ScanEDCFlow+0x9a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    281a:	10 92 e9 0d 	sts	0x0DE9, r1
    281e:	ad eb       	ldi	r26, 0xBD	; 189
    2820:	bc e0       	ldi	r27, 0x0C	; 12
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2822:	81 91       	ld	r24, Z+
    2824:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2826:	8a e0       	ldi	r24, 0x0A	; 10
    2828:	ee 37       	cpi	r30, 0x7E	; 126
    282a:	f8 07       	cpc	r31, r24
    282c:	d1 f7       	brne	.-12     	; 0x2822 <ScanEDCFlow+0xae>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    282e:	10 92 d0 0c 	sts	0x0CD0, r1
    2832:	20 e0       	ldi	r18, 0x00	; 0
    2834:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2836:	f9 01       	movw	r30, r18
    2838:	ed 5e       	subi	r30, 0xED	; 237
    283a:	f6 4f       	sbci	r31, 0xF6	; 246
    283c:	d9 01       	movw	r26, r18
    283e:	af 5a       	subi	r26, 0xAF	; 175
    2840:	b5 4f       	sbci	r27, 0xF5	; 245
    2842:	9d 96       	adiw	r26, 0x2d	; 45
    2844:	8c 91       	ld	r24, X
    2846:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2848:	2f 5f       	subi	r18, 0xFF	; 255
    284a:	3f 4f       	sbci	r19, 0xFF	; 255
    284c:	26 30       	cpi	r18, 0x06	; 6
    284e:	31 05       	cpc	r19, r1
    2850:	91 f7       	brne	.-28     	; 0x2836 <ScanEDCFlow+0xc2>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2852:	10 92 19 09 	sts	0x0919, r1
    2856:	20 e0       	ldi	r18, 0x00	; 0
    2858:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    285a:	f9 01       	movw	r30, r18
    285c:	eb 59       	subi	r30, 0x9B	; 155
    285e:	f7 4f       	sbci	r31, 0xF7	; 247
    2860:	d9 01       	movw	r26, r18
    2862:	af 5a       	subi	r26, 0xAF	; 175
    2864:	b5 4f       	sbci	r27, 0xF5	; 245
    2866:	d3 96       	adiw	r26, 0x33	; 51
    2868:	8c 91       	ld	r24, X
    286a:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    286c:	2f 5f       	subi	r18, 0xFF	; 255
    286e:	3f 4f       	sbci	r19, 0xFF	; 255
    2870:	2a 30       	cpi	r18, 0x0A	; 10
    2872:	31 05       	cpc	r19, r1
    2874:	91 f7       	brne	.-28     	; 0x285a <ScanEDCFlow+0xe6>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2876:	10 92 6f 08 	sts	0x086F, r1
    287a:	20 e0       	ldi	r18, 0x00	; 0
    287c:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    287e:	f9 01       	movw	r30, r18
    2880:	ed 50       	subi	r30, 0x0D	; 13
    2882:	f3 4f       	sbci	r31, 0xF3	; 243
    2884:	d9 01       	movw	r26, r18
    2886:	af 5a       	subi	r26, 0xAF	; 175
    2888:	b5 4f       	sbci	r27, 0xF5	; 245
    288a:	dd 96       	adiw	r26, 0x3d	; 61
    288c:	8c 91       	ld	r24, X
    288e:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2890:	2f 5f       	subi	r18, 0xFF	; 255
    2892:	3f 4f       	sbci	r19, 0xFF	; 255
    2894:	2e 30       	cpi	r18, 0x0E	; 14
    2896:	31 05       	cpc	r19, r1
    2898:	91 f7       	brne	.-28     	; 0x287e <ScanEDCFlow+0x10a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    289a:	10 92 01 0d 	sts	0x0D01, r1
             StrPosCopy(rcv_trans,strCardType,11,15);
             StrPosCopy(rcv_trans,strCardID,26,19);
             StrPosCopy(rcv_trans,strApprovalCode,45,6);
             StrPosCopy(rcv_trans,strInvoiceNumber,51,10);
             StrPosCopy(rcv_trans,strDateTime,61,14);
		     IsEDCApproved=True;//Sending Message 92
    289e:	81 e0       	ldi	r24, 0x01	; 1
    28a0:	80 93 9c 01 	sts	0x019C, r24
			 IsPrintApprovalCode=True;
    28a4:	80 93 9d 01 	sts	0x019D, r24
    28a8:	08 95       	ret
	    }else
		 if (EDCMsgCode==0x04){
    28aa:	34 30       	cpi	r19, 0x04	; 4
    28ac:	19 f5       	brne	.+70     	; 0x28f4 <ScanEDCFlow+0x180>
    28ae:	e4 e5       	ldi	r30, 0x54	; 84
    28b0:	fa e0       	ldi	r31, 0x0A	; 10
    28b2:	a3 e1       	ldi	r26, 0x13	; 19
    28b4:	b9 e0       	ldi	r27, 0x09	; 9
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    28b6:	81 91       	ld	r24, Z+
    28b8:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    28ba:	8a e0       	ldi	r24, 0x0A	; 10
    28bc:	ea 35       	cpi	r30, 0x5A	; 90
    28be:	f8 07       	cpc	r31, r24
    28c0:	d1 f7       	brne	.-12     	; 0x28b6 <ScanEDCFlow+0x142>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    28c2:	10 92 19 09 	sts	0x0919, r1
    28c6:	a5 e6       	ldi	r26, 0x65	; 101
    28c8:	b8 e0       	ldi	r27, 0x08	; 8
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    28ca:	81 91       	ld	r24, Z+
    28cc:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    28ce:	8a e0       	ldi	r24, 0x0A	; 10
    28d0:	e4 36       	cpi	r30, 0x64	; 100
    28d2:	f8 07       	cpc	r31, r24
    28d4:	d1 f7       	brne	.-12     	; 0x28ca <ScanEDCFlow+0x156>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    28d6:	10 92 6f 08 	sts	0x086F, r1
    28da:	a3 ef       	ldi	r26, 0xF3	; 243
    28dc:	bc e0       	ldi	r27, 0x0C	; 12
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    28de:	81 91       	ld	r24, Z+
    28e0:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    28e2:	8a e0       	ldi	r24, 0x0A	; 10
    28e4:	e2 37       	cpi	r30, 0x72	; 114
    28e6:	f8 07       	cpc	r31, r24
    28e8:	d1 f7       	brne	.-12     	; 0x28de <ScanEDCFlow+0x16a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    28ea:	10 92 01 0d 	sts	0x0D01, r1
	    }else
		 if (EDCMsgCode==0x04){
             StrPosCopy(rcv_trans,strApprovalCode,3,6);
             StrPosCopy(rcv_trans,strInvoiceNumber,9,10);
             StrPosCopy(rcv_trans,strDateTime,19,14);
			 IsVoidTransaction=True;
    28ee:	81 e0       	ldi	r24, 0x01	; 1
    28f0:	80 93 9e 01 	sts	0x019E, r24
    28f4:	08 95       	ret

000028f6 <ScanHiddenKeyFlow>:
	    }
    }//MSGDetection
}

void ScanHiddenKeyFlow(char KeyIn){
}
    28f6:	08 95       	ret

000028f8 <ScanRFIDFlow>:


void ScanRFIDFlow(char data){//                   12 11 10 9  8  7  6  5  4  3  2  1  0
    28f8:	98 2f       	mov	r25, r24
    28fa:	e3 ea       	ldi	r30, 0xA3	; 163
    28fc:	f9 e0       	ldi	r31, 0x09	; 9
     char i=0,strSerial[20]; //Shift Data Serial; 02 32 33 44 31 30 41 36 43 0D 0A 0A 03 
	                                                //2 50 51 65 68 68 68 54 67 13 10 3

	 for(i=0;i<19;i++){
        strSerialFlow[19-i]=strSerialFlow[18-i];   
    28fe:	80 81       	ld	r24, Z
    2900:	81 83       	std	Z+1, r24	; 0x01
    2902:	31 97       	sbiw	r30, 0x01	; 1

void ScanRFIDFlow(char data){//                   12 11 10 9  8  7  6  5  4  3  2  1  0
     char i=0,strSerial[20]; //Shift Data Serial; 02 32 33 44 31 30 41 36 43 0D 0A 0A 03 
	                                                //2 50 51 65 68 68 68 54 67 13 10 3

	 for(i=0;i<19;i++){
    2904:	89 e0       	ldi	r24, 0x09	; 9
    2906:	e0 39       	cpi	r30, 0x90	; 144
    2908:	f8 07       	cpc	r31, r24
    290a:	c9 f7       	brne	.-14     	; 0x28fe <ScanRFIDFlow+0x6>
        strSerialFlow[19-i]=strSerialFlow[18-i];   
	 }  strSerialFlow[0]=data;
    290c:	9f 01       	movw	r18, r30
    290e:	2f 5f       	subi	r18, 0xFF	; 255
    2910:	3f 4f       	sbci	r19, 0xFF	; 255
    2912:	91 83       	std	Z+1, r25	; 0x01
	 //Detection
	 if ((strSerialFlow[11]==0x02)&&(strSerialFlow[1]==0x0A)&&(strSerialFlow[0]==0x03)){
    2914:	84 85       	ldd	r24, Z+12	; 0x0c
    2916:	82 30       	cpi	r24, 0x02	; 2
    2918:	f9 f4       	brne	.+62     	; 0x2958 <ScanRFIDFlow+0x60>
    291a:	80 91 92 09 	lds	r24, 0x0992
    291e:	8a 30       	cpi	r24, 0x0A	; 10
    2920:	d9 f4       	brne	.+54     	; 0x2958 <ScanRFIDFlow+0x60>
    2922:	93 30       	cpi	r25, 0x03	; 3
    2924:	c9 f4       	brne	.+50     	; 0x2958 <ScanRFIDFlow+0x60>
    2926:	f9 01       	movw	r30, r18
    2928:	3a 96       	adiw	r30, 0x0a	; 10
    292a:	a8 e8       	ldi	r26, 0x88	; 136
    292c:	bd e0       	ldi	r27, 0x0D	; 13
		for(i=0;i<8;i++) strRFID[i]=strSerialFlow[10-i];
    292e:	80 81       	ld	r24, Z
    2930:	8d 93       	st	X+, r24
    2932:	31 97       	sbiw	r30, 0x01	; 1
    2934:	89 e0       	ldi	r24, 0x09	; 9
    2936:	e3 39       	cpi	r30, 0x93	; 147
    2938:	f8 07       	cpc	r31, r24
    293a:	c9 f7       	brne	.-14     	; 0x292e <ScanRFIDFlow+0x36>
        strRFID[8]=0;
    293c:	10 92 90 0d 	sts	0x0D90, r1
	    IsRFIDDetected=True;
    2940:	81 e0       	ldi	r24, 0x01	; 1
    2942:	80 93 9b 01 	sts	0x019B, r24
	      }
     }      
}

void BackLightTrig(){    
     __key_light = 1; 
    2946:	80 93 02 03 	sts	0x0302, r24
	 __key_lgtcnt = 0; 
    294a:	10 92 03 03 	sts	0x0303, r1
	 PORTG=PORTG&0b11111101;
    294e:	80 91 65 00 	lds	r24, 0x0065
    2952:	8d 7f       	andi	r24, 0xFD	; 253
    2954:	80 93 65 00 	sts	0x0065, r24
    2958:	08 95       	ret

0000295a <__vector_18>:
	if (IFType==IT_SLAVE)ScanEDCFlow(dataSPI);
	else
	if (IFType==IT_STANDALONE)ScanStandaloneFlow(dataSPI);
}

ISR(USART0_RX_vect){
    295a:	1f 92       	push	r1
    295c:	0f 92       	push	r0
    295e:	0f b6       	in	r0, 0x3f	; 63
    2960:	0f 92       	push	r0
    2962:	11 24       	eor	r1, r1
    2964:	8f 93       	push	r24
    2966:	9f 93       	push	r25
	char dataRX0,IsSPI=False;
	dataRX0= UDR0;
    2968:	9c b1       	in	r25, 0x0c	; 12
	//PrintBusyDetection
	if ((IsBusyIdlePrinting==True)||(IsBusyFreePrinting==True)){
    296a:	80 91 b4 01 	lds	r24, 0x01B4
    296e:	81 30       	cpi	r24, 0x01	; 1
    2970:	21 f0       	breq	.+8      	; 0x297a <__vector_18+0x20>
    2972:	80 91 b6 01 	lds	r24, 0x01B6
    2976:	81 30       	cpi	r24, 0x01	; 1
    2978:	51 f4       	brne	.+20     	; 0x298e <__vector_18+0x34>
	    if (dataRX0==19)IsBusyPrint=True;
    297a:	93 31       	cpi	r25, 0x13	; 19
    297c:	21 f4       	brne	.+8      	; 0x2986 <__vector_18+0x2c>
    297e:	81 e0       	ldi	r24, 0x01	; 1
    2980:	80 93 b5 01 	sts	0x01B5, r24
    2984:	04 c0       	rjmp	.+8      	; 0x298e <__vector_18+0x34>
		else 
	    if (dataRX0==17)IsBusyPrint=False;	
    2986:	91 31       	cpi	r25, 0x11	; 17
    2988:	11 f4       	brne	.+4      	; 0x298e <__vector_18+0x34>
    298a:	10 92 b5 01 	sts	0x01B5, r1
	}
}
    298e:	9f 91       	pop	r25
    2990:	8f 91       	pop	r24
    2992:	0f 90       	pop	r0
    2994:	0f be       	out	0x3f, r0	; 63
    2996:	0f 90       	pop	r0
    2998:	1f 90       	pop	r1
    299a:	18 95       	reti

0000299c <ScanCommand>:

char ScanCommand(char *strFlow,char *fCommand){
     char Result;
	 Result=False;
   return Result;
}
    299c:	80 e0       	ldi	r24, 0x00	; 0
    299e:	08 95       	ret

000029a0 <ConfigProtocol>:
	 }
	 _uart_printf(1,1,PSTR(">"));
	 //End
}

void ConfigProtocol(char dataIn){
    29a0:	28 2f       	mov	r18, r24
     static char Conflow[7];
    //Configuration Data Request 
	if ((Conflow[6]=='i')&&(Conflow[5]=='C')&&(Conflow[4]=='o')&&(Conflow[3]=='n')&&(Conflow[2]=='f')&&(Conflow[1]=='?')&&(Conflow[0]==0x0D)&&(dataIn==0x0A)){
    29a2:	80 91 f2 02 	lds	r24, 0x02F2
    29a6:	89 36       	cpi	r24, 0x69	; 105
    29a8:	e9 f4       	brne	.+58     	; 0x29e4 <ConfigProtocol+0x44>
    29aa:	80 91 f1 02 	lds	r24, 0x02F1
    29ae:	83 34       	cpi	r24, 0x43	; 67
    29b0:	c9 f4       	brne	.+50     	; 0x29e4 <ConfigProtocol+0x44>
    29b2:	80 91 f0 02 	lds	r24, 0x02F0
    29b6:	8f 36       	cpi	r24, 0x6F	; 111
    29b8:	a9 f4       	brne	.+42     	; 0x29e4 <ConfigProtocol+0x44>
    29ba:	80 91 ef 02 	lds	r24, 0x02EF
    29be:	8e 36       	cpi	r24, 0x6E	; 110
    29c0:	89 f4       	brne	.+34     	; 0x29e4 <ConfigProtocol+0x44>
    29c2:	80 91 ee 02 	lds	r24, 0x02EE
    29c6:	86 36       	cpi	r24, 0x66	; 102
    29c8:	69 f4       	brne	.+26     	; 0x29e4 <ConfigProtocol+0x44>
    29ca:	80 91 ed 02 	lds	r24, 0x02ED
    29ce:	8f 33       	cpi	r24, 0x3F	; 63
    29d0:	49 f4       	brne	.+18     	; 0x29e4 <ConfigProtocol+0x44>
    29d2:	80 91 ec 02 	lds	r24, 0x02EC
    29d6:	8d 30       	cpi	r24, 0x0D	; 13
    29d8:	29 f4       	brne	.+10     	; 0x29e4 <ConfigProtocol+0x44>
    29da:	2a 30       	cpi	r18, 0x0A	; 10
    29dc:	19 f4       	brne	.+6      	; 0x29e4 <ConfigProtocol+0x44>
	     //SendConfigParamater();        
		 ConfigCommand=CC_SEND_CONFIG;
    29de:	82 e0       	ldi	r24, 0x02	; 2
    29e0:	80 93 b2 01 	sts	0x01B2, r24
	}

	if (IsConfigFlow==True){        
    29e4:	80 91 88 01 	lds	r24, 0x0188
    29e8:	81 30       	cpi	r24, 0x01	; 1
    29ea:	69 f4       	brne	.+26     	; 0x2a06 <ConfigProtocol+0x66>
	    rcv_trans[char_count]=dataIn;
    29ec:	80 91 8c 01 	lds	r24, 0x018C
    29f0:	90 91 8d 01 	lds	r25, 0x018D
    29f4:	fc 01       	movw	r30, r24
    29f6:	ef 5a       	subi	r30, 0xAF	; 175
    29f8:	f5 4f       	sbci	r31, 0xF5	; 245
    29fa:	20 83       	st	Z, r18
	    char_count++; 
    29fc:	01 96       	adiw	r24, 0x01	; 1
    29fe:	90 93 8d 01 	sts	0x018D, r25
    2a02:	80 93 8c 01 	sts	0x018C, r24
	}
	if ((Conflow[0]==0x04)&&(dataIn==0x40)){
    2a06:	80 91 ec 02 	lds	r24, 0x02EC
    2a0a:	84 30       	cpi	r24, 0x04	; 4
    2a0c:	51 f4       	brne	.+20     	; 0x2a22 <ConfigProtocol+0x82>
    2a0e:	20 34       	cpi	r18, 0x40	; 64
    2a10:	e9 f4       	brne	.+58     	; 0x2a4c <ConfigProtocol+0xac>
	     IsConfigFlow=True;
    2a12:	81 e0       	ldi	r24, 0x01	; 1
    2a14:	80 93 88 01 	sts	0x0188, r24
		 char_count=0;
    2a18:	10 92 8d 01 	sts	0x018D, r1
    2a1c:	10 92 8c 01 	sts	0x018C, r1
    2a20:	15 c0       	rjmp	.+42     	; 0x2a4c <ConfigProtocol+0xac>
	}
	//SavingData
	if ((Conflow[0]==0x05)&&(dataIn==0x50)){
    2a22:	85 30       	cpi	r24, 0x05	; 5
    2a24:	99 f4       	brne	.+38     	; 0x2a4c <ConfigProtocol+0xac>
    2a26:	20 35       	cpi	r18, 0x50	; 80
    2a28:	89 f4       	brne	.+34     	; 0x2a4c <ConfigProtocol+0xac>
	     transLength=char_count;
    2a2a:	80 91 8c 01 	lds	r24, 0x018C
    2a2e:	90 91 8d 01 	lds	r25, 0x018D
    2a32:	90 93 8f 01 	sts	0x018F, r25
    2a36:	80 93 8e 01 	sts	0x018E, r24
		 char_count=0;
    2a3a:	10 92 8d 01 	sts	0x018D, r1
    2a3e:	10 92 8c 01 	sts	0x018C, r1
	     IsConfigFlow=False;
    2a42:	10 92 88 01 	sts	0x0188, r1
		 ConfigCommand=CC_SAVE_CONFIG;
    2a46:	81 e0       	ldi	r24, 0x01	; 1
    2a48:	80 93 b2 01 	sts	0x01B2, r24
		 //SaveConfigParameter();
	}

	//Shifting
	Conflow[6]=Conflow[5];
    2a4c:	80 91 f1 02 	lds	r24, 0x02F1
    2a50:	80 93 f2 02 	sts	0x02F2, r24
	Conflow[5]=Conflow[4];
    2a54:	80 91 f0 02 	lds	r24, 0x02F0
    2a58:	80 93 f1 02 	sts	0x02F1, r24
	Conflow[4]=Conflow[3];
    2a5c:	80 91 ef 02 	lds	r24, 0x02EF
    2a60:	80 93 f0 02 	sts	0x02F0, r24
	Conflow[3]=Conflow[2];
    2a64:	80 91 ee 02 	lds	r24, 0x02EE
    2a68:	80 93 ef 02 	sts	0x02EF, r24
	Conflow[2]=Conflow[1];
    2a6c:	80 91 ed 02 	lds	r24, 0x02ED
    2a70:	80 93 ee 02 	sts	0x02EE, r24
	Conflow[1]=Conflow[0];
    2a74:	80 91 ec 02 	lds	r24, 0x02EC
    2a78:	80 93 ed 02 	sts	0x02ED, r24
	Conflow[0]=dataIn;
    2a7c:	20 93 ec 02 	sts	0x02EC, r18

}
    2a80:	08 95       	ret

00002a82 <system_beep>:
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    2a82:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    2a84:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    2a86:	80 93 bf 01 	sts	0x01BF, r24
}
    2a8a:	08 95       	ret

00002a8c <systemRestart>:
	 iRestart=0;
	 while(iRestart<100){
	       strRestart[iRestart]=iRestart;
	       iRestart++;	 
	 }
}
    2a8c:	08 95       	ret

00002a8e <Low>:

char Low(char X){
     char Result;
	 Result=(0x0F&X);
	 return Result;
}
    2a8e:	8f 70       	andi	r24, 0x0F	; 15
    2a90:	08 95       	ret

00002a92 <High>:
char High(char X){
     char Result;
	 Result=((X>>4)&(0x0F));
	 return Result;
}
    2a92:	82 95       	swap	r24
    2a94:	8f 70       	andi	r24, 0x0F	; 15
    2a96:	08 95       	ret

00002a98 <Str>:
char Str(char H){
    2a98:	98 2f       	mov	r25, r24
unsigned char Conv=0;
        if ((H>=0)&&(H<=9)) Conv='0'+H;
    2a9a:	8a 30       	cpi	r24, 0x0A	; 10
    2a9c:	10 f4       	brcc	.+4      	; 0x2aa2 <Str+0xa>
    2a9e:	80 5d       	subi	r24, 0xD0	; 208
    2aa0:	08 95       	ret
        else
        if ((H>=0x0A)&&(H<=0x0F)) Conv='A'+(H-10);    
    2aa2:	8a 50       	subi	r24, 0x0A	; 10
    2aa4:	86 30       	cpi	r24, 0x06	; 6
    2aa6:	10 f0       	brcs	.+4      	; 0x2aac <Str+0x14>
    2aa8:	80 e0       	ldi	r24, 0x00	; 0
    2aaa:	08 95       	ret
    2aac:	89 2f       	mov	r24, r25
    2aae:	89 5c       	subi	r24, 0xC9	; 201
        return (Conv);
}
    2ab0:	08 95       	ret

00002ab2 <charToHex>:

void charToHex(char X, char *Result){
    2ab2:	28 2f       	mov	r18, r24
    2ab4:	fb 01       	movw	r30, r22
	 Result=(0x0F&X);
	 return Result;
}
char High(char X){
     char Result;
	 Result=((X>>4)&(0x0F));
    2ab6:	98 2f       	mov	r25, r24
    2ab8:	92 95       	swap	r25
    2aba:	9f 70       	andi	r25, 0x0F	; 15
	 return Result;
}
char Str(char H){
unsigned char Conv=0;
        if ((H>=0)&&(H<=9)) Conv='0'+H;
    2abc:	9a 30       	cpi	r25, 0x0A	; 10
    2abe:	18 f4       	brcc	.+6      	; 0x2ac6 <charToHex+0x14>
    2ac0:	89 2f       	mov	r24, r25
    2ac2:	80 5d       	subi	r24, 0xD0	; 208
    2ac4:	08 c0       	rjmp	.+16     	; 0x2ad6 <charToHex+0x24>
        else
        if ((H>=0x0A)&&(H<=0x0F)) Conv='A'+(H-10);    
    2ac6:	89 2f       	mov	r24, r25
    2ac8:	8a 50       	subi	r24, 0x0A	; 10
    2aca:	86 30       	cpi	r24, 0x06	; 6
    2acc:	10 f0       	brcs	.+4      	; 0x2ad2 <charToHex+0x20>
    2ace:	80 e0       	ldi	r24, 0x00	; 0
    2ad0:	02 c0       	rjmp	.+4      	; 0x2ad6 <charToHex+0x24>
    2ad2:	89 2f       	mov	r24, r25
    2ad4:	89 5c       	subi	r24, 0xC9	; 201
        return (Conv);
}

void charToHex(char X, char *Result){
     Result[0]=Str(High(X));
    2ad6:	80 83       	st	Z, r24
	lcd_print(1,1,lcdteks);
}

char Low(char X){
     char Result;
	 Result=(0x0F&X);
    2ad8:	92 2f       	mov	r25, r18
    2ada:	9f 70       	andi	r25, 0x0F	; 15
	 Result=((X>>4)&(0x0F));
	 return Result;
}
char Str(char H){
unsigned char Conv=0;
        if ((H>=0)&&(H<=9)) Conv='0'+H;
    2adc:	9a 30       	cpi	r25, 0x0A	; 10
    2ade:	18 f4       	brcc	.+6      	; 0x2ae6 <charToHex+0x34>
    2ae0:	89 2f       	mov	r24, r25
    2ae2:	80 5d       	subi	r24, 0xD0	; 208
    2ae4:	08 c0       	rjmp	.+16     	; 0x2af6 <charToHex+0x44>
        else
        if ((H>=0x0A)&&(H<=0x0F)) Conv='A'+(H-10);    
    2ae6:	89 2f       	mov	r24, r25
    2ae8:	8a 50       	subi	r24, 0x0A	; 10
    2aea:	86 30       	cpi	r24, 0x06	; 6
    2aec:	10 f0       	brcs	.+4      	; 0x2af2 <charToHex+0x40>
    2aee:	80 e0       	ldi	r24, 0x00	; 0
    2af0:	02 c0       	rjmp	.+4      	; 0x2af6 <charToHex+0x44>
    2af2:	89 2f       	mov	r24, r25
    2af4:	89 5c       	subi	r24, 0xC9	; 201
        return (Conv);
}

void charToHex(char X, char *Result){
     Result[0]=Str(High(X));
	 Result[1]=Str(Low(X));
    2af6:	81 83       	std	Z+1, r24	; 0x01
	 Result[2]=0;
    2af8:	12 82       	std	Z+2, r1	; 0x02
	 
}
    2afa:	08 95       	ret

00002afc <strToInt>:

char strToInt(char *str){
    2afc:	fc 01       	movw	r30, r24
     char Result;
     Result=(((str[0]-'0')*10) +(str[0]-'0'));
    2afe:	80 81       	ld	r24, Z
    2b00:	2a e0       	ldi	r18, 0x0A	; 10
    2b02:	82 9f       	mul	r24, r18
    2b04:	90 01       	movw	r18, r0
    2b06:	11 24       	eor	r1, r1
    2b08:	80 51       	subi	r24, 0x10	; 16
	 return Result;
}
    2b0a:	82 0f       	add	r24, r18
    2b0c:	08 95       	ret

00002b0e <intToStr>:

void intToStr(char X, char *str){
    2b0e:	58 2f       	mov	r21, r24
    2b10:	fb 01       	movw	r30, r22
     char R,P,S;
	 R=X/100;
    2b12:	64 e6       	ldi	r22, 0x64	; 100
    2b14:	0e 94 f1 b6 	call	0x16de2	; 0x16de2 <__udivmodqi4>
    2b18:	a8 2f       	mov	r26, r24
	 P=(X%100)/10;
    2b1a:	85 2f       	mov	r24, r21
    2b1c:	0e 94 f1 b6 	call	0x16de2	; 0x16de2 <__udivmodqi4>
    2b20:	89 2f       	mov	r24, r25
    2b22:	6a e0       	ldi	r22, 0x0A	; 10
    2b24:	0e 94 f1 b6 	call	0x16de2	; 0x16de2 <__udivmodqi4>
    2b28:	48 2f       	mov	r20, r24
	 S=X-(R*100)-(P*10);
    2b2a:	8c e9       	ldi	r24, 0x9C	; 156
    2b2c:	9f ef       	ldi	r25, 0xFF	; 255
    2b2e:	a8 9f       	mul	r26, r24
    2b30:	80 2d       	mov	r24, r0
    2b32:	11 24       	eor	r1, r1
    2b34:	85 0f       	add	r24, r21
    2b36:	26 ef       	ldi	r18, 0xF6	; 246
    2b38:	3f ef       	ldi	r19, 0xFF	; 255
    2b3a:	42 9f       	mul	r20, r18
    2b3c:	90 2d       	mov	r25, r0
    2b3e:	11 24       	eor	r1, r1
    2b40:	98 0f       	add	r25, r24
	 if (X>=100){
    2b42:	54 36       	cpi	r21, 0x64	; 100
    2b44:	40 f0       	brcs	.+16     	; 0x2b56 <intToStr+0x48>
	     str[0]=('0'+R);
    2b46:	a0 5d       	subi	r26, 0xD0	; 208
    2b48:	a0 83       	st	Z, r26
	     str[1]=('0'+P);
    2b4a:	40 5d       	subi	r20, 0xD0	; 208
    2b4c:	41 83       	std	Z+1, r20	; 0x01
	     str[2]=('0'+S);
    2b4e:	90 5d       	subi	r25, 0xD0	; 208
    2b50:	92 83       	std	Z+2, r25	; 0x02
	     str[3]=0;
    2b52:	13 82       	std	Z+3, r1	; 0x03
    2b54:	08 95       	ret
	 if ((X>=10)&&(X>100)){
	     str[0]=('0'+P);
	     str[1]=('0'+S);
	     str[2]=0;
	 }else 
	 if (X<=10){
    2b56:	5b 30       	cpi	r21, 0x0B	; 11
    2b58:	18 f4       	brcc	.+6      	; 0x2b60 <intToStr+0x52>
	     str[0]=('0'+S);
    2b5a:	90 5d       	subi	r25, 0xD0	; 208
    2b5c:	90 83       	st	Z, r25
	     str[1]=0;
    2b5e:	11 82       	std	Z+1, r1	; 0x01
    2b60:	08 95       	ret

00002b62 <ViewCardID>:
		else strCardID[i]=strRFID[i-(20-LengthID)];
	 }strCardID[20]=0;

}

void ViewCardID(){//+12345678 -->12345678
    2b62:	20 e0       	ldi	r18, 0x00	; 0
    2b64:	30 e0       	ldi	r19, 0x00	; 0
     char i;
	 for(i=0;i<8;i++){         //00000000000012345678
		strCardID[i]=strRFID[i];
    2b66:	f9 01       	movw	r30, r18
    2b68:	e3 54       	subi	r30, 0x43	; 67
    2b6a:	f3 4f       	sbci	r31, 0xF3	; 243
    2b6c:	d9 01       	movw	r26, r18
    2b6e:	a8 57       	subi	r26, 0x78	; 120
    2b70:	b2 4f       	sbci	r27, 0xF2	; 242
    2b72:	8c 91       	ld	r24, X
    2b74:	80 83       	st	Z, r24
    2b76:	2f 5f       	subi	r18, 0xFF	; 255
    2b78:	3f 4f       	sbci	r19, 0xFF	; 255

}

void ViewCardID(){//+12345678 -->12345678
     char i;
	 for(i=0;i<8;i++){         //00000000000012345678
    2b7a:	28 30       	cpi	r18, 0x08	; 8
    2b7c:	31 05       	cpc	r19, r1
    2b7e:	99 f7       	brne	.-26     	; 0x2b66 <ViewCardID+0x4>
		strCardID[i]=strRFID[i];
	 }strCardID[8]=0;     
    2b80:	10 92 c5 0c 	sts	0x0CC5, r1
}
    2b84:	08 95       	ret

00002b86 <StringCopy>:
//Message 56


void StringCopy(char *Source,char *Dest,char Length){
    2b86:	cf 93       	push	r28
    2b88:	df 93       	push	r29
    2b8a:	db 01       	movw	r26, r22
    2b8c:	ec 01       	movw	r28, r24
    2b8e:	20 e0       	ldi	r18, 0x00	; 0
    2b90:	30 e0       	ldi	r19, 0x00	; 0
    2b92:	07 c0       	rjmp	.+14     	; 0x2ba2 <StringCopy+0x1c>
     char i;
	 for (i=0;i<Length;i++){
	     Dest[i]=Source[i];
    2b94:	fd 01       	movw	r30, r26
    2b96:	e2 0f       	add	r30, r18
    2b98:	f3 1f       	adc	r31, r19
    2b9a:	89 91       	ld	r24, Y+
    2b9c:	80 83       	st	Z, r24
    2b9e:	2f 5f       	subi	r18, 0xFF	; 255
    2ba0:	3f 4f       	sbci	r19, 0xFF	; 255
//Message 56


void StringCopy(char *Source,char *Dest,char Length){
     char i;
	 for (i=0;i<Length;i++){
    2ba2:	24 17       	cp	r18, r20
    2ba4:	b8 f3       	brcs	.-18     	; 0x2b94 <StringCopy+0xe>
	     Dest[i]=Source[i];
	 }Dest[Length]=0;
    2ba6:	a4 0f       	add	r26, r20
    2ba8:	b1 1d       	adc	r27, r1
    2baa:	1c 92       	st	X, r1
}
    2bac:	df 91       	pop	r29
    2bae:	cf 91       	pop	r28
    2bb0:	08 95       	ret

00002bb2 <StringCopyPos>:
void StringCopyPos(char *Source,char *Dest,char SrcPos,char Length){
    2bb2:	cf 93       	push	r28
    2bb4:	df 93       	push	r29
    2bb6:	db 01       	movw	r26, r22
    2bb8:	ec 01       	movw	r28, r24
    2bba:	c4 0f       	add	r28, r20
    2bbc:	d1 1d       	adc	r29, r1
    2bbe:	40 e0       	ldi	r20, 0x00	; 0
    2bc0:	50 e0       	ldi	r21, 0x00	; 0
    2bc2:	07 c0       	rjmp	.+14     	; 0x2bd2 <StringCopyPos+0x20>
     char i;
	 for (i=0;i<Length;i++){
	     Dest[i]=Source[SrcPos+i];
    2bc4:	fd 01       	movw	r30, r26
    2bc6:	e4 0f       	add	r30, r20
    2bc8:	f5 1f       	adc	r31, r21
    2bca:	89 91       	ld	r24, Y+
    2bcc:	80 83       	st	Z, r24
    2bce:	4f 5f       	subi	r20, 0xFF	; 255
    2bd0:	5f 4f       	sbci	r21, 0xFF	; 255
	     Dest[i]=Source[i];
	 }Dest[Length]=0;
}
void StringCopyPos(char *Source,char *Dest,char SrcPos,char Length){
     char i;
	 for (i=0;i<Length;i++){
    2bd2:	42 17       	cp	r20, r18
    2bd4:	b8 f3       	brcs	.-18     	; 0x2bc4 <StringCopyPos+0x12>
	     Dest[i]=Source[SrcPos+i];
	 }Dest[Length]=0;
    2bd6:	a2 0f       	add	r26, r18
    2bd8:	b1 1d       	adc	r27, r1
    2bda:	1c 92       	st	X, r1
}
    2bdc:	df 91       	pop	r29
    2bde:	cf 91       	pop	r28
    2be0:	08 95       	ret

00002be2 <TestLocalAccount>:

void TestLocalAccount(){

}
    2be2:	08 95       	ret

00002be4 <BackLightTrig>:
	      }
     }      
}

void BackLightTrig(){    
     __key_light = 1; 
    2be4:	81 e0       	ldi	r24, 0x01	; 1
    2be6:	80 93 02 03 	sts	0x0302, r24
	 __key_lgtcnt = 0; 
    2bea:	10 92 03 03 	sts	0x0303, r1
	 PORTG=PORTG&0b11111101;
    2bee:	e5 e6       	ldi	r30, 0x65	; 101
    2bf0:	f0 e0       	ldi	r31, 0x00	; 0
    2bf2:	80 81       	ld	r24, Z
    2bf4:	8d 7f       	andi	r24, 0xFD	; 253
    2bf6:	80 83       	st	Z, r24
}
    2bf8:	08 95       	ret

00002bfa <GetBaudrate>:
	 }
}

int GetBaudrate(char brSetting){
int Result=0;
     switch(brSetting){
    2bfa:	82 30       	cpi	r24, 0x02	; 2
    2bfc:	59 f0       	breq	.+22     	; 0x2c14 <GetBaudrate+0x1a>
    2bfe:	82 30       	cpi	r24, 0x02	; 2
    2c00:	18 f0       	brcs	.+6      	; 0x2c08 <GetBaudrate+0xe>
    2c02:	83 30       	cpi	r24, 0x03	; 3
    2c04:	21 f4       	brne	.+8      	; 0x2c0e <GetBaudrate+0x14>
    2c06:	09 c0       	rjmp	.+18     	; 0x2c1a <GetBaudrate+0x20>
    2c08:	20 e8       	ldi	r18, 0x80	; 128
    2c0a:	35 e2       	ldi	r19, 0x25	; 37
    2c0c:	08 c0       	rjmp	.+16     	; 0x2c1e <GetBaudrate+0x24>
    2c0e:	20 e0       	ldi	r18, 0x00	; 0
    2c10:	30 e0       	ldi	r19, 0x00	; 0
    2c12:	05 c0       	rjmp	.+10     	; 0x2c1e <GetBaudrate+0x24>
    2c14:	20 e0       	ldi	r18, 0x00	; 0
    2c16:	3b e4       	ldi	r19, 0x4B	; 75
    2c18:	02 c0       	rjmp	.+4      	; 0x2c1e <GetBaudrate+0x24>
	 case br9600: 
	      Result=9600;
	      break;
	 case br19200:
	      Result=19200;
	      break;
    2c1a:	2b e9       	ldi	r18, 0x9B	; 155
    2c1c:	36 e1       	ldi	r19, 0x16	; 22
	 case br5787:
	      Result=5787;
     	  break;	 
	 }
   return Result;
}
    2c1e:	c9 01       	movw	r24, r18
    2c20:	08 95       	ret

00002c22 <InitMemory>:
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2c22:	e1 99       	sbic	0x1c, 1	; 28
    2c24:	fe cf       	rjmp	.-4      	; 0x2c22 <InitMemory>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2c26:	84 e4       	ldi	r24, 0x44	; 68
    2c28:	91 e0       	ldi	r25, 0x01	; 1
    2c2a:	9f bb       	out	0x1f, r25	; 31
    2c2c:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2c2e:	e0 9a       	sbi	0x1c, 0	; 28
    2c30:	8d b3       	in	r24, 0x1d	; 29

	 }
}

void InitMemory(){
     PumpCountMax=eeprom_read_byte(&DefPoolingPumpMax);
    2c32:	80 93 4f 01 	sts	0x014F, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2c36:	e1 99       	sbic	0x1c, 1	; 28
    2c38:	fe cf       	rjmp	.-4      	; 0x2c36 <InitMemory+0x14>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2c3a:	89 e4       	ldi	r24, 0x49	; 73
    2c3c:	91 e0       	ldi	r25, 0x01	; 1
    2c3e:	9f bb       	out	0x1f, r25	; 31
    2c40:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2c42:	e0 9a       	sbi	0x1c, 0	; 28
    2c44:	8d b3       	in	r24, 0x1d	; 29
	 ActivePump=eeprom_read_byte(&DefActivePump);
    2c46:	80 93 50 01 	sts	0x0150, r24
}
    2c4a:	08 95       	ret

00002c4c <InitStandalone>:
	      RunInitStandalone=False;
	      break;
	 }
  }
  */
}
    2c4c:	08 95       	ret

00002c4e <DisplayQueueFIP>:


void DisplayQueueFIP(){// FIP:#1#2#3#4#5

}
    2c4e:	08 95       	ret

00002c50 <ShowMessage>:
	 }
}

void ShowMessage(char *Message){//Display Message on Line3
     char i;
}
    2c50:	08 95       	ret

00002c52 <CalcLRC>:

char CalcLRC(char xLRC,char DataIn){
     char Result;
	 Result=xLRC^DataIn;
     return(Result);
}
    2c52:	86 27       	eor	r24, r22
    2c54:	08 95       	ret

00002c56 <systemEDC>:
}

void systemEDC(){//EDC Handler
     

}
    2c56:	08 95       	ret

00002c58 <GeniusCalc>:


char GeniusCalc(char cOption, char valA, char valB){
     char valC_H,valC_L,xValA,xValB,Result;
	 Result=0;
     switch(cOption){
    2c58:	88 23       	and	r24, r24
    2c5a:	19 f0       	breq	.+6      	; 0x2c62 <GeniusCalc+0xa>
    2c5c:	81 30       	cpi	r24, 0x01	; 1
    2c5e:	49 f5       	brne	.+82     	; 0x2cb2 <GeniusCalc+0x5a>
    2c60:	11 c0       	rjmp	.+34     	; 0x2c84 <GeniusCalc+0x2c>
	 case G_PLUS:                  // 5 + 8 = 1 + 3 = 4
	      valC_H=(valA+valB)/10;   //  
    2c62:	26 2f       	mov	r18, r22
    2c64:	30 e0       	ldi	r19, 0x00	; 0
    2c66:	24 0f       	add	r18, r20
    2c68:	31 1d       	adc	r19, r1
		  valC_L=(valA+valB)%10;   //
	      Result=valC_H+valC_L;
    2c6a:	c9 01       	movw	r24, r18
    2c6c:	6a e0       	ldi	r22, 0x0A	; 10
    2c6e:	70 e0       	ldi	r23, 0x00	; 0
    2c70:	0e 94 1e b7 	call	0x16e3c	; 0x16e3c <__divmodhi4>
    2c74:	48 2f       	mov	r20, r24
    2c76:	c9 01       	movw	r24, r18
    2c78:	6a e0       	ldi	r22, 0x0A	; 10
    2c7a:	70 e0       	ldi	r23, 0x00	; 0
    2c7c:	0e 94 1e b7 	call	0x16e3c	; 0x16e3c <__divmodhi4>
    2c80:	46 0f       	add	r20, r22
    2c82:	18 c0       	rjmp	.+48     	; 0x2cb4 <GeniusCalc+0x5c>
	      break;
	 case G_MULTY:                 
	      if (valA>0)xValA=valA;
    2c84:	66 23       	and	r22, r22
    2c86:	09 f4       	brne	.+2      	; 0x2c8a <GeniusCalc+0x32>
    2c88:	61 e0       	ldi	r22, 0x01	; 1
		  else xValA=1;
	      if (valB>0)xValB=valB;
    2c8a:	44 23       	and	r20, r20
    2c8c:	09 f4       	brne	.+2      	; 0x2c90 <GeniusCalc+0x38>
    2c8e:	41 e0       	ldi	r20, 0x01	; 1
		  else xValB=1;
	      valC_H=(xValA*xValB)/10;   //  
    2c90:	46 9f       	mul	r20, r22
    2c92:	90 01       	movw	r18, r0
    2c94:	11 24       	eor	r1, r1
    2c96:	c9 01       	movw	r24, r18
    2c98:	6a e0       	ldi	r22, 0x0A	; 10
    2c9a:	70 e0       	ldi	r23, 0x00	; 0
    2c9c:	0e 94 1e b7 	call	0x16e3c	; 0x16e3c <__divmodhi4>
    2ca0:	46 2f       	mov	r20, r22
		  valC_L=(xValA*xValB)%10;   //
    2ca2:	c9 01       	movw	r24, r18
    2ca4:	6a e0       	ldi	r22, 0x0A	; 10
    2ca6:	70 e0       	ldi	r23, 0x00	; 0
    2ca8:	0e 94 1e b7 	call	0x16e3c	; 0x16e3c <__divmodhi4>
    2cac:	64 2f       	mov	r22, r20
    2cae:	48 2f       	mov	r20, r24
    2cb0:	d8 cf       	rjmp	.-80     	; 0x2c62 <GeniusCalc+0xa>
    2cb2:	40 e0       	ldi	r20, 0x00	; 0
	 case G_MINUS:
	      
	      break;
	 }
   return Result;
}
    2cb4:	84 2f       	mov	r24, r20
    2cb6:	08 95       	ret

00002cb8 <FSubMenuAdmin>:

char FSubMenuAdmin(){
     char Result;
	 Result=MENU_DONE;
   return Result;
}
    2cb8:	81 e0       	ldi	r24, 0x01	; 1
    2cba:	08 95       	ret

00002cbc <CountNoPumpSatus>:
	      break;	 
	 } 
   return Result;
}

char CountNoPumpSatus(char *strPumpStatusTotalizer){
    2cbc:	ff 92       	push	r15
    2cbe:	0f 93       	push	r16
    2cc0:	1f 93       	push	r17
    2cc2:	cf 93       	push	r28
    2cc4:	df 93       	push	r29
char i,Result;
     Result=0;
	 for (i=0;i<PumpCountMax;i++){
    2cc6:	f0 90 4f 01 	lds	r15, 0x014F
    2cca:	ec 01       	movw	r28, r24
    2ccc:	00 e0       	ldi	r16, 0x00	; 0
    2cce:	10 e0       	ldi	r17, 0x00	; 0
    2cd0:	09 c0       	rjmp	.+18     	; 0x2ce4 <CountNoPumpSatus+0x28>
	      if (strPumpStatusTotalizer[i]==GetPumpStatusLabel(PUMP_NONE)){
    2cd2:	8e e0       	ldi	r24, 0x0E	; 14
    2cd4:	0e 94 7d 13 	call	0x26fa	; 0x26fa <GetPumpStatusLabel>
    2cd8:	98 81       	ld	r25, Y
    2cda:	98 17       	cp	r25, r24
    2cdc:	09 f4       	brne	.+2      	; 0x2ce0 <CountNoPumpSatus+0x24>
		      Result++;		  
    2cde:	1f 5f       	subi	r17, 0xFF	; 255
}

char CountNoPumpSatus(char *strPumpStatusTotalizer){
char i,Result;
     Result=0;
	 for (i=0;i<PumpCountMax;i++){
    2ce0:	0f 5f       	subi	r16, 0xFF	; 255
    2ce2:	21 96       	adiw	r28, 0x01	; 1
    2ce4:	0f 15       	cp	r16, r15
    2ce6:	a8 f3       	brcs	.-22     	; 0x2cd2 <CountNoPumpSatus+0x16>
	      if (strPumpStatusTotalizer[i]==GetPumpStatusLabel(PUMP_NONE)){
		      Result++;		  
		  }	 
	 }
  return Result;
}
    2ce8:	81 2f       	mov	r24, r17
    2cea:	df 91       	pop	r29
    2cec:	cf 91       	pop	r28
    2cee:	1f 91       	pop	r17
    2cf0:	0f 91       	pop	r16
    2cf2:	ff 90       	pop	r15
    2cf4:	08 95       	ret

00002cf6 <FCloseDay>:
   return Result;
}

char FCloseDay(){

}
    2cf6:	08 95       	ret

00002cf8 <FLockPump>:
char FLockPump(){

}
    2cf8:	08 95       	ret

00002cfa <FMenuSettingPassword>:
char FMenuSettingPassword(){
     char Result;
   //_menu_password();
   Result=MENU_DONE;
   return Result;
}
    2cfa:	81 e0       	ldi	r24, 0x01	; 1
    2cfc:	08 95       	ret

00002cfe <menu_product>:
   return Result;
}

void menu_product(){

}
    2cfe:	08 95       	ret

00002d00 <IncValue>:
            lcd_print(xPos,yPos,strLabel);
		}
	}
}

void IncValue(char *Value,char MinValue,char MaxValue){
    2d00:	fc 01       	movw	r30, r24
     if ((*Value)<MaxValue){
    2d02:	80 81       	ld	r24, Z
    2d04:	84 17       	cp	r24, r20
    2d06:	18 f4       	brcc	.+6      	; 0x2d0e <IncValue+0xe>
	     (*Value)++;
    2d08:	8f 5f       	subi	r24, 0xFF	; 255
    2d0a:	80 83       	st	Z, r24
    2d0c:	08 95       	ret
	 }else *Value=MinValue;
    2d0e:	60 83       	st	Z, r22
    2d10:	08 95       	ret

00002d12 <DecValue>:
}

void DecValue(char *Value,char MinValue,char MaxValue){
    2d12:	fc 01       	movw	r30, r24
     if ((*Value)>MinValue){
    2d14:	80 81       	ld	r24, Z
    2d16:	68 17       	cp	r22, r24
    2d18:	18 f4       	brcc	.+6      	; 0x2d20 <DecValue+0xe>
	     (*Value)--;
    2d1a:	81 50       	subi	r24, 0x01	; 1
    2d1c:	80 83       	st	Z, r24
    2d1e:	08 95       	ret
	 }else *Value=MaxValue;
    2d20:	40 83       	st	Z, r20
    2d22:	08 95       	ret

00002d24 <zeroIP>:
		 
		}

	}
}
void zeroIP(unsigned char Val,char *StrResult){
    2d24:	58 2f       	mov	r21, r24
    2d26:	fb 01       	movw	r30, r22
     unsigned char R,P,S;
	 if (Val>=100){
    2d28:	84 36       	cpi	r24, 0x64	; 100
    2d2a:	00 f1       	brcs	.+64     	; 0x2d6c <zeroIP+0x48>
	    R=(Val/100);
    2d2c:	64 e6       	ldi	r22, 0x64	; 100
    2d2e:	0e 94 f1 b6 	call	0x16de2	; 0x16de2 <__udivmodqi4>
    2d32:	48 2f       	mov	r20, r24
        P=((Val%100)/10);
    2d34:	85 2f       	mov	r24, r21
    2d36:	0e 94 f1 b6 	call	0x16de2	; 0x16de2 <__udivmodqi4>
    2d3a:	89 2f       	mov	r24, r25
    2d3c:	6a e0       	ldi	r22, 0x0A	; 10
    2d3e:	0e 94 f1 b6 	call	0x16de2	; 0x16de2 <__udivmodqi4>
		S=Val-((R*100)+(P*10)); 
        StrResult[0]='0'+R;//+(Val/100);
    2d42:	40 5d       	subi	r20, 0xD0	; 208
    2d44:	40 83       	st	Z, r20
    2d46:	40 53       	subi	r20, 0x30	; 48
	    StrResult[1]='0'+P;//+((Val%100)/10);
    2d48:	80 5d       	subi	r24, 0xD0	; 208
    2d4a:	81 83       	std	Z+1, r24	; 0x01
    2d4c:	80 53       	subi	r24, 0x30	; 48
		StrResult[2]='0'+S;//+(Val-((Val/100)*100)-((Val%100)/10));
    2d4e:	50 5d       	subi	r21, 0xD0	; 208
    2d50:	2c e9       	ldi	r18, 0x9C	; 156
    2d52:	3f ef       	ldi	r19, 0xFF	; 255
    2d54:	42 9f       	mul	r20, r18
    2d56:	40 2d       	mov	r20, r0
    2d58:	11 24       	eor	r1, r1
    2d5a:	45 0f       	add	r20, r21
    2d5c:	26 ef       	ldi	r18, 0xF6	; 246
    2d5e:	3f ef       	ldi	r19, 0xFF	; 255
    2d60:	82 9f       	mul	r24, r18
    2d62:	80 2d       	mov	r24, r0
    2d64:	11 24       	eor	r1, r1
    2d66:	84 0f       	add	r24, r20
    2d68:	82 83       	std	Z+2, r24	; 0x02
    2d6a:	10 c0       	rjmp	.+32     	; 0x2d8c <zeroIP+0x68>
		StrResult[3]=0;
		}else     
	 if ((Val>=10)&&(Val<100)){
    2d6c:	8a 50       	subi	r24, 0x0A	; 10
    2d6e:	8a 35       	cpi	r24, 0x5A	; 90
    2d70:	78 f4       	brcc	.+30     	; 0x2d90 <zeroIP+0x6c>
        StrResult[0]='0';
    2d72:	80 e3       	ldi	r24, 0x30	; 48
    2d74:	80 83       	st	Z, r24
	    StrResult[1]=('0'+(Val/10));
    2d76:	85 2f       	mov	r24, r21
    2d78:	6a e0       	ldi	r22, 0x0A	; 10
    2d7a:	0e 94 f1 b6 	call	0x16de2	; 0x16de2 <__udivmodqi4>
    2d7e:	80 5d       	subi	r24, 0xD0	; 208
    2d80:	81 83       	std	Z+1, r24	; 0x01
		StrResult[2]=('0'+(Val%10));
    2d82:	85 2f       	mov	r24, r21
    2d84:	0e 94 f1 b6 	call	0x16de2	; 0x16de2 <__udivmodqi4>
    2d88:	90 5d       	subi	r25, 0xD0	; 208
    2d8a:	92 83       	std	Z+2, r25	; 0x02
		StrResult[3]=0;
    2d8c:	13 82       	std	Z+3, r1	; 0x03
    2d8e:	08 95       	ret
		}
     else
	 if (Val<10){
    2d90:	5a 30       	cpi	r21, 0x0A	; 10
    2d92:	30 f4       	brcc	.+12     	; 0x2da0 <zeroIP+0x7c>
	    StrResult[0]='0';
    2d94:	80 e3       	ldi	r24, 0x30	; 48
    2d96:	80 83       	st	Z, r24
		StrResult[1]='0';
    2d98:	81 83       	std	Z+1, r24	; 0x01
	    StrResult[2]='0'+Val;
    2d9a:	50 5d       	subi	r21, 0xD0	; 208
    2d9c:	52 83       	std	Z+2, r21	; 0x02
	    StrResult[3]=0;
    2d9e:	13 82       	std	Z+3, r1	; 0x03
    2da0:	08 95       	ret

00002da2 <GetLocAccStatus>:


char GetLocAccStatus(char paramMessage57){
     char Result;
	 Result=LA_NONE;
     if (paramMessage57==MSG57_INVALID)Result=LA_INVALID;
    2da2:	81 30       	cpi	r24, 0x01	; 1
    2da4:	29 f0       	breq	.+10     	; 0x2db0 <GetLocAccStatus+0xe>
	 else
     if (paramMessage57==MSG57_VALID)Result=LA_VALID;
    2da6:	82 30       	cpi	r24, 0x02	; 2
    2da8:	19 f0       	breq	.+6      	; 0x2db0 <GetLocAccStatus+0xe>
	 else
     if (paramMessage57==MSG57_LIMITED)Result=LA_LIMITED;
    2daa:	83 30       	cpi	r24, 0x03	; 3
    2dac:	09 f0       	breq	.+2      	; 0x2db0 <GetLocAccStatus+0xe>
    2dae:	80 e0       	ldi	r24, 0x00	; 0
	 return Result;
}
    2db0:	08 95       	ret

00002db2 <FTestRemZero>:
	     RemZeroLead(strTest);  
		 _uart_print(0,1,strTest);

	while (1){};
  #endif
}
    2db2:	08 95       	ret

00002db4 <StrPosCopy>:
     nAddedSpace=(Length-srcLength)/2;
     AddSpaceLead(Source,srcLength+nAddedSpace);
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
    2db4:	cf 93       	push	r28
    2db6:	df 93       	push	r29
    2db8:	eb 01       	movw	r28, r22
    2dba:	da 01       	movw	r26, r20
    2dbc:	a8 0f       	add	r26, r24
    2dbe:	b9 1f       	adc	r27, r25
    2dc0:	40 e0       	ldi	r20, 0x00	; 0
    2dc2:	50 e0       	ldi	r21, 0x00	; 0
    2dc4:	07 c0       	rjmp	.+14     	; 0x2dd4 <StrPosCopy+0x20>
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2dc6:	fe 01       	movw	r30, r28
    2dc8:	e4 0f       	add	r30, r20
    2dca:	f5 1f       	adc	r31, r21
    2dcc:	8d 91       	ld	r24, X+
    2dce:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2dd0:	4f 5f       	subi	r20, 0xFF	; 255
    2dd2:	5f 4f       	sbci	r21, 0xFF	; 255
    2dd4:	42 17       	cp	r20, r18
    2dd6:	53 07       	cpc	r21, r19
    2dd8:	b0 f3       	brcs	.-20     	; 0x2dc6 <StrPosCopy+0x12>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2dda:	c2 0f       	add	r28, r18
    2ddc:	d3 1f       	adc	r29, r19
    2dde:	18 82       	st	Y, r1
}
    2de0:	df 91       	pop	r29
    2de2:	cf 91       	pop	r28
    2de4:	08 95       	ret

00002de6 <StrPosPaste>:
void StrPosPaste(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
    2de6:	0f 93       	push	r16
    2de8:	1f 93       	push	r17
    2dea:	cf 93       	push	r28
    2dec:	df 93       	push	r29
    2dee:	8c 01       	movw	r16, r24
    2df0:	db 01       	movw	r26, r22
    2df2:	eb 01       	movw	r28, r22
    2df4:	c4 0f       	add	r28, r20
    2df6:	d5 1f       	adc	r29, r21
    2df8:	60 e0       	ldi	r22, 0x00	; 0
    2dfa:	70 e0       	ldi	r23, 0x00	; 0
    2dfc:	07 c0       	rjmp	.+14     	; 0x2e0c <StrPosPaste+0x26>
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[IdxSource+i]=Source[i];
    2dfe:	f8 01       	movw	r30, r16
    2e00:	e6 0f       	add	r30, r22
    2e02:	f7 1f       	adc	r31, r23
    2e04:	80 81       	ld	r24, Z
    2e06:	89 93       	st	Y+, r24
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
}
void StrPosPaste(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2e08:	6f 5f       	subi	r22, 0xFF	; 255
    2e0a:	7f 4f       	sbci	r23, 0xFF	; 255
    2e0c:	62 17       	cp	r22, r18
    2e0e:	73 07       	cpc	r23, r19
    2e10:	b0 f3       	brcs	.-20     	; 0x2dfe <StrPosPaste+0x18>
	    Dest[IdxSource+i]=Source[i];
	 }Dest[IdxSource+Length]=0;
    2e12:	a4 0f       	add	r26, r20
    2e14:	b5 1f       	adc	r27, r21
    2e16:	a2 0f       	add	r26, r18
    2e18:	b3 1f       	adc	r27, r19
    2e1a:	1c 92       	st	X, r1
}
    2e1c:	df 91       	pop	r29
    2e1e:	cf 91       	pop	r28
    2e20:	1f 91       	pop	r17
    2e22:	0f 91       	pop	r16
    2e24:	08 95       	ret

00002e26 <CharPosCopy>:
char CharPosCopy(char *Source, unsigned int IdxSource){
    2e26:	fb 01       	movw	r30, r22
    2e28:	e8 0f       	add	r30, r24
    2e2a:	f9 1f       	adc	r31, r25
     char Result;
     Result=Source[IdxSource];
	 return Result;
}
    2e2c:	80 81       	ld	r24, Z
    2e2e:	08 95       	ret

00002e30 <procMessage00>:
*/
char procMessage00(){
     char Result,strSend[10];
	 Result=MSG00_NACK;
	 //Message57
	 if((rcv_trans[0]==0x01)&&(transLength==MSG00_LENGTH)){
    2e30:	80 91 51 0a 	lds	r24, 0x0A51
    2e34:	81 30       	cpi	r24, 0x01	; 1
    2e36:	51 f4       	brne	.+20     	; 0x2e4c <procMessage00+0x1c>
    2e38:	80 91 8e 01 	lds	r24, 0x018E
    2e3c:	90 91 8f 01 	lds	r25, 0x018F
    2e40:	8f 97       	sbiw	r24, 0x2f	; 47
    2e42:	21 f4       	brne	.+8      	; 0x2e4c <procMessage00+0x1c>
	     //Reply
		 Result=(CharPosCopy(rcv_trans,37)-'0');
    2e44:	80 91 76 0a 	lds	r24, 0x0A76
    2e48:	80 53       	subi	r24, 0x30	; 48
    2e4a:	08 95       	ret
    2e4c:	80 e0       	ldi	r24, 0x00	; 0
		 //sprintf(strSend,"R=%d",Result);
		 //_uart_print(0,1,strSend);
		 //*/
		 }
     return Result;
}
    2e4e:	08 95       	ret

00002e50 <procMessage09>:
	    Dest[IdxSource+i]=Source[i];
	 }Dest[IdxSource+Length]=0;
}
char CharPosCopy(char *Source, unsigned int IdxSource){
     char Result;
     Result=Source[IdxSource];
    2e50:	90 91 78 0a 	lds	r25, 0x0A78
    2e54:	20 e0       	ldi	r18, 0x00	; 0
    2e56:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2e58:	f9 01       	movw	r30, r18
    2e5a:	ea 53       	subi	r30, 0x3A	; 58
    2e5c:	f6 4f       	sbci	r31, 0xF6	; 246
    2e5e:	d9 01       	movw	r26, r18
    2e60:	af 5a       	subi	r26, 0xAF	; 175
    2e62:	b5 4f       	sbci	r27, 0xF5	; 245
    2e64:	97 96       	adiw	r26, 0x27	; 39
    2e66:	8c 91       	ld	r24, X
    2e68:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2e6a:	2f 5f       	subi	r18, 0xFF	; 255
    2e6c:	3f 4f       	sbci	r19, 0xFF	; 255
    2e6e:	24 31       	cpi	r18, 0x14	; 20
    2e70:	31 05       	cpc	r19, r1
    2e72:	91 f7       	brne	.-28     	; 0x2e58 <procMessage09+0x8>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2e74:	10 92 da 09 	sts	0x09DA, r1
    2e78:	20 e0       	ldi	r18, 0x00	; 0
    2e7a:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2e7c:	f9 01       	movw	r30, r18
    2e7e:	eb 54       	subi	r30, 0x4B	; 75
    2e80:	f7 4f       	sbci	r31, 0xF7	; 247
    2e82:	d9 01       	movw	r26, r18
    2e84:	af 5a       	subi	r26, 0xAF	; 175
    2e86:	b5 4f       	sbci	r27, 0xF5	; 245
    2e88:	db 96       	adiw	r26, 0x3b	; 59
    2e8a:	8c 91       	ld	r24, X
    2e8c:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2e8e:	2f 5f       	subi	r18, 0xFF	; 255
    2e90:	3f 4f       	sbci	r19, 0xFF	; 255
    2e92:	24 31       	cpi	r18, 0x14	; 20
    2e94:	31 05       	cpc	r19, r1
    2e96:	91 f7       	brne	.-28     	; 0x2e7c <procMessage09+0x2c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2e98:	10 92 c9 08 	sts	0x08C9, r1
    2e9c:	20 e0       	ldi	r18, 0x00	; 0
    2e9e:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2ea0:	f9 01       	movw	r30, r18
    2ea2:	e0 5b       	subi	r30, 0xB0	; 176
    2ea4:	f6 4f       	sbci	r31, 0xF6	; 246
    2ea6:	d9 01       	movw	r26, r18
    2ea8:	a0 56       	subi	r26, 0x60	; 96
    2eaa:	b5 4f       	sbci	r27, 0xF5	; 245
    2eac:	8c 91       	ld	r24, X
    2eae:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2eb0:	2f 5f       	subi	r18, 0xFF	; 255
    2eb2:	3f 4f       	sbci	r19, 0xFF	; 255
    2eb4:	24 31       	cpi	r18, 0x14	; 20
    2eb6:	31 05       	cpc	r19, r1
    2eb8:	99 f7       	brne	.-26     	; 0x2ea0 <procMessage09+0x50>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2eba:	10 92 64 09 	sts	0x0964, r1
    2ebe:	20 e0       	ldi	r18, 0x00	; 0
    2ec0:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2ec2:	f9 01       	movw	r30, r18
    2ec4:	e3 5f       	subi	r30, 0xF3	; 243
    2ec6:	f2 4f       	sbci	r31, 0xF2	; 242
    2ec8:	d9 01       	movw	r26, r18
    2eca:	ac 54       	subi	r26, 0x4C	; 76
    2ecc:	b5 4f       	sbci	r27, 0xF5	; 245
    2ece:	8c 91       	ld	r24, X
    2ed0:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2ed2:	2f 5f       	subi	r18, 0xFF	; 255
    2ed4:	3f 4f       	sbci	r19, 0xFF	; 255
    2ed6:	24 31       	cpi	r18, 0x14	; 20
    2ed8:	31 05       	cpc	r19, r1
    2eda:	99 f7       	brne	.-26     	; 0x2ec2 <procMessage09+0x72>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2edc:	10 92 21 0d 	sts	0x0D21, r1
       StrPosCopy(rcv_trans,strFreeMessageLine1,39,20);
       StrPosCopy(rcv_trans,strFreeMessageLine2,59,20);
       StrPosCopy(rcv_trans,strFreeMessageLine3,79,20);
       StrPosCopy(rcv_trans,strFreeMessageLine4,99,20);
	 return Result;
}
    2ee0:	89 2f       	mov	r24, r25
    2ee2:	80 53       	subi	r24, 0x30	; 48
    2ee4:	08 95       	ret

00002ee6 <procMessage23>:
		 eeprom_write_block((const void*)&strBankName, (void*)&DefBankName[i], 11);
	 }
	 return Result;
}

char procMessage23(){
    2ee6:	20 e0       	ldi	r18, 0x00	; 0
    2ee8:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2eea:	f9 01       	movw	r30, r18
    2eec:	e3 54       	subi	r30, 0x43	; 67
    2eee:	f3 4f       	sbci	r31, 0xF3	; 243
    2ef0:	d9 01       	movw	r26, r18
    2ef2:	af 5a       	subi	r26, 0xAF	; 175
    2ef4:	b5 4f       	sbci	r27, 0xF5	; 245
    2ef6:	95 96       	adiw	r26, 0x25	; 37
    2ef8:	8c 91       	ld	r24, X
    2efa:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2efc:	2f 5f       	subi	r18, 0xFF	; 255
    2efe:	3f 4f       	sbci	r19, 0xFF	; 255
    2f00:	24 31       	cpi	r18, 0x14	; 20
    2f02:	31 05       	cpc	r19, r1
    2f04:	91 f7       	brne	.-28     	; 0x2eea <procMessage23+0x4>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2f06:	10 92 d1 0c 	sts	0x0CD1, r1
    2f0a:	20 e0       	ldi	r18, 0x00	; 0
    2f0c:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2f0e:	f9 01       	movw	r30, r18
    2f10:	ed 5c       	subi	r30, 0xCD	; 205
    2f12:	fb 4f       	sbci	r31, 0xFB	; 251
    2f14:	d9 01       	movw	r26, r18
    2f16:	af 5a       	subi	r26, 0xAF	; 175
    2f18:	b5 4f       	sbci	r27, 0xF5	; 245
    2f1a:	d9 96       	adiw	r26, 0x39	; 57
    2f1c:	8c 91       	ld	r24, X
    2f1e:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2f20:	2f 5f       	subi	r18, 0xFF	; 255
    2f22:	3f 4f       	sbci	r19, 0xFF	; 255
    2f24:	2e 31       	cpi	r18, 0x1E	; 30
    2f26:	31 05       	cpc	r19, r1
    2f28:	91 f7       	brne	.-28     	; 0x2f0e <procMessage23+0x28>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2f2a:	10 92 51 04 	sts	0x0451, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2f2e:	80 91 a8 0a 	lds	r24, 0x0AA8
    2f32:	80 93 99 04 	sts	0x0499, r24
	 }Dest[Length]=0;
    2f36:	10 92 9a 04 	sts	0x049A, r1
    2f3a:	20 e0       	ldi	r18, 0x00	; 0
    2f3c:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2f3e:	f9 01       	movw	r30, r18
    2f40:	e7 59       	subi	r30, 0x97	; 151
    2f42:	f6 4f       	sbci	r31, 0xF6	; 246
    2f44:	d9 01       	movw	r26, r18
    2f46:	a7 55       	subi	r26, 0x57	; 87
    2f48:	b5 4f       	sbci	r27, 0xF5	; 245
    2f4a:	8c 91       	ld	r24, X
    2f4c:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2f4e:	2f 5f       	subi	r18, 0xFF	; 255
    2f50:	3f 4f       	sbci	r19, 0xFF	; 255
    2f52:	28 30       	cpi	r18, 0x08	; 8
    2f54:	31 05       	cpc	r19, r1
    2f56:	99 f7       	brne	.-26     	; 0x2f3e <procMessage23+0x58>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2f58:	10 92 71 09 	sts	0x0971, r1
    2f5c:	20 e0       	ldi	r18, 0x00	; 0
    2f5e:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2f60:	f9 01       	movw	r30, r18
    2f62:	e3 57       	subi	r30, 0x73	; 115
    2f64:	fb 4f       	sbci	r31, 0xFB	; 251
    2f66:	d9 01       	movw	r26, r18
    2f68:	af 54       	subi	r26, 0x4F	; 79
    2f6a:	b5 4f       	sbci	r27, 0xF5	; 245
    2f6c:	8c 91       	ld	r24, X
    2f6e:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2f70:	2f 5f       	subi	r18, 0xFF	; 255
    2f72:	3f 4f       	sbci	r19, 0xFF	; 255
    2f74:	2a 30       	cpi	r18, 0x0A	; 10
    2f76:	31 05       	cpc	r19, r1
    2f78:	99 f7       	brne	.-26     	; 0x2f60 <procMessage23+0x7a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2f7a:	10 92 97 04 	sts	0x0497, r1
    2f7e:	20 e0       	ldi	r18, 0x00	; 0
    2f80:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2f82:	f9 01       	movw	r30, r18
    2f84:	ec 5d       	subi	r30, 0xDC	; 220
    2f86:	f2 4f       	sbci	r31, 0xF2	; 242
    2f88:	d9 01       	movw	r26, r18
    2f8a:	a5 54       	subi	r26, 0x45	; 69
    2f8c:	b5 4f       	sbci	r27, 0xF5	; 245
    2f8e:	8c 91       	ld	r24, X
    2f90:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2f92:	2f 5f       	subi	r18, 0xFF	; 255
    2f94:	3f 4f       	sbci	r19, 0xFF	; 255
    2f96:	2a 30       	cpi	r18, 0x0A	; 10
    2f98:	31 05       	cpc	r19, r1
    2f9a:	99 f7       	brne	.-26     	; 0x2f82 <procMessage23+0x9c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2f9c:	10 92 2e 0d 	sts	0x0D2E, r1
    2fa0:	20 e0       	ldi	r18, 0x00	; 0
    2fa2:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2fa4:	f9 01       	movw	r30, r18
    2fa6:	ed 50       	subi	r30, 0x0D	; 13
    2fa8:	f3 4f       	sbci	r31, 0xF3	; 243
    2faa:	d9 01       	movw	r26, r18
    2fac:	ab 53       	subi	r26, 0x3B	; 59
    2fae:	b5 4f       	sbci	r27, 0xF5	; 245
    2fb0:	8c 91       	ld	r24, X
    2fb2:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2fb4:	2f 5f       	subi	r18, 0xFF	; 255
    2fb6:	3f 4f       	sbci	r19, 0xFF	; 255
    2fb8:	23 31       	cpi	r18, 0x13	; 19
    2fba:	31 05       	cpc	r19, r1
    2fbc:	99 f7       	brne	.-26     	; 0x2fa4 <procMessage23+0xbe>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2fbe:	10 92 06 0d 	sts	0x0D06, r1
    2fc2:	20 e0       	ldi	r18, 0x00	; 0
    2fc4:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2fc6:	f9 01       	movw	r30, r18
    2fc8:	e9 51       	subi	r30, 0x19	; 25
    2fca:	f3 4f       	sbci	r31, 0xF3	; 243
    2fcc:	d9 01       	movw	r26, r18
    2fce:	a8 52       	subi	r26, 0x28	; 40
    2fd0:	b5 4f       	sbci	r27, 0xF5	; 245
    2fd2:	8c 91       	ld	r24, X
    2fd4:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2fd6:	2f 5f       	subi	r18, 0xFF	; 255
    2fd8:	3f 4f       	sbci	r19, 0xFF	; 255
    2fda:	27 30       	cpi	r18, 0x07	; 7
    2fdc:	31 05       	cpc	r19, r1
    2fde:	99 f7       	brne	.-26     	; 0x2fc6 <procMessage23+0xe0>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2fe0:	10 92 ee 0c 	sts	0x0CEE, r1
    2fe4:	20 e0       	ldi	r18, 0x00	; 0
    2fe6:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2fe8:	f9 01       	movw	r30, r18
    2fea:	e6 53       	subi	r30, 0x36	; 54
    2fec:	fc 4f       	sbci	r31, 0xFC	; 252
    2fee:	d9 01       	movw	r26, r18
    2ff0:	a1 52       	subi	r26, 0x21	; 33
    2ff2:	b5 4f       	sbci	r27, 0xF5	; 245
    2ff4:	8c 91       	ld	r24, X
    2ff6:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2ff8:	2f 5f       	subi	r18, 0xFF	; 255
    2ffa:	3f 4f       	sbci	r19, 0xFF	; 255
    2ffc:	24 30       	cpi	r18, 0x04	; 4
    2ffe:	31 05       	cpc	r19, r1
    3000:	99 f7       	brne	.-26     	; 0x2fe8 <procMessage23+0x102>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    3002:	10 92 ce 03 	sts	0x03CE, r1
     StrPosCopy(rcv_trans,strLoyCurrMonConsumeV,106,10);
     StrPosCopy(rcv_trans,strDateTime,116,19);
     StrPosCopy(rcv_trans,strAmount,135,7);
     StrPosCopy(rcv_trans,strGainPoints,142,4);
     return Result;
}
    3006:	80 e0       	ldi	r24, 0x00	; 0
    3008:	08 95       	ret

0000300a <procMessage81>:
_uart_print(0,1,strCardID);
*/	
     return Result;
}

char procMessage81(){// Result: HFCS0000
    300a:	cf 93       	push	r28
    300c:	df 93       	push	r29
     char Result=0,PrintCopy=0;//
	 char lcdteks[20];
	 //PrintHeader
     if ((CharPosCopy(rcv_trans,37))=='Y') Result=(Result|(1<<7));
    300e:	80 91 76 0a 	lds	r24, 0x0A76
    3012:	89 35       	cpi	r24, 0x59	; 89
    3014:	11 f4       	brne	.+4      	; 0x301a <procMessage81+0x10>
    3016:	90 e8       	ldi	r25, 0x80	; 128
    3018:	01 c0       	rjmp	.+2      	; 0x301c <procMessage81+0x12>
    301a:	90 e0       	ldi	r25, 0x00	; 0
     //PrintFooter
	 if ((CharPosCopy(rcv_trans,38))=='Y') Result=(Result|(1<<6));
    301c:	80 91 77 0a 	lds	r24, 0x0A77
    3020:	89 35       	cpi	r24, 0x59	; 89
    3022:	09 f4       	brne	.+2      	; 0x3026 <procMessage81+0x1c>
    3024:	90 64       	ori	r25, 0x40	; 64
	 //PaperCut
     if ((CharPosCopy(rcv_trans,39))=='Y') Result=(Result|(1<<5));
    3026:	80 91 78 0a 	lds	r24, 0x0A78
    302a:	89 35       	cpi	r24, 0x59	; 89
    302c:	09 f4       	brne	.+2      	; 0x3030 <procMessage81+0x26>
    302e:	90 62       	ori	r25, 0x20	; 32
	 //Scrool
	 Result=(Result|(1<<4));
    3030:	90 61       	ori	r25, 0x10	; 16

	 //Copies
	 PrintCopy=(CharPosCopy(rcv_trans,40)-'0');
    3032:	80 91 79 0a 	lds	r24, 0x0A79
    3036:	80 53       	subi	r24, 0x30	; 48
     if (PrintCopy<=16) Result=Result|PrintCopy;
    3038:	81 31       	cpi	r24, 0x11	; 17
    303a:	08 f4       	brcc	.+2      	; 0x303e <procMessage81+0x34>
    303c:	98 2b       	or	r25, r24
	 //Spooling
     StrPosCopy(rcv_trans,PrintBuffer,44,LengthMessage81);
    303e:	c0 91 90 01 	lds	r28, 0x0190
    3042:	d0 91 91 01 	lds	r29, 0x0191
    3046:	20 e0       	ldi	r18, 0x00	; 0
    3048:	30 e0       	ldi	r19, 0x00	; 0
    304a:	0b c0       	rjmp	.+22     	; 0x3062 <procMessage81+0x58>
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    304c:	f9 01       	movw	r30, r18
    304e:	e2 50       	subi	r30, 0x02	; 2
    3050:	fb 4f       	sbci	r31, 0xFB	; 251
    3052:	d9 01       	movw	r26, r18
    3054:	af 5a       	subi	r26, 0xAF	; 175
    3056:	b5 4f       	sbci	r27, 0xF5	; 245
    3058:	9c 96       	adiw	r26, 0x2c	; 44
    305a:	8c 91       	ld	r24, X
    305c:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    305e:	2f 5f       	subi	r18, 0xFF	; 255
    3060:	3f 4f       	sbci	r19, 0xFF	; 255
    3062:	2c 17       	cp	r18, r28
    3064:	3d 07       	cpc	r19, r29
    3066:	90 f3       	brcs	.-28     	; 0x304c <procMessage81+0x42>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    3068:	c2 50       	subi	r28, 0x02	; 2
    306a:	db 4f       	sbci	r29, 0xFB	; 251
    306c:	18 82       	st	Y, r1
	 //sprintf(lcdteks,"cmdPrint:%d ",Result);
     //_uart_print(0,1,lcdteks);

	 //while(1){};
	 return Result;
}
    306e:	89 2f       	mov	r24, r25
    3070:	df 91       	pop	r29
    3072:	cf 91       	pop	r28
    3074:	08 95       	ret

00003076 <FillChar>:
	 if(CutType== 1) { _uart(_COM_PRINTER, 1, 0x6D);}
	 if(CutType== 2) {_uart(_COM_PRINTER, 1, 0x69);}

}

void FillChar(char *strMemory, unsigned int Length,char data){
    3076:	20 e0       	ldi	r18, 0x00	; 0
    3078:	30 e0       	ldi	r19, 0x00	; 0
    307a:	06 c0       	rjmp	.+12     	; 0x3088 <FillChar+0x12>
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    307c:	fc 01       	movw	r30, r24
    307e:	e2 0f       	add	r30, r18
    3080:	f3 1f       	adc	r31, r19
    3082:	40 83       	st	Z, r20

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    3084:	2f 5f       	subi	r18, 0xFF	; 255
    3086:	3f 4f       	sbci	r19, 0xFF	; 255
    3088:	26 17       	cp	r18, r22
    308a:	37 07       	cpc	r19, r23
    308c:	b8 f3       	brcs	.-18     	; 0x307c <FillChar+0x6>
	     strMemory[i]=data;
	 }
}
    308e:	08 95       	ret

00003090 <ProcMessage91>:

void ProcMessage91(){
    3090:	20 e0       	ldi	r18, 0x00	; 0
    3092:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    3094:	f9 01       	movw	r30, r18
    3096:	e2 54       	subi	r30, 0x42	; 66
    3098:	f2 4f       	sbci	r31, 0xF2	; 242
    309a:	d9 01       	movw	r26, r18
    309c:	af 5a       	subi	r26, 0xAF	; 175
    309e:	b5 4f       	sbci	r27, 0xF5	; 245
    30a0:	95 96       	adiw	r26, 0x25	; 37
    30a2:	8c 91       	ld	r24, X
    30a4:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    30a6:	2f 5f       	subi	r18, 0xFF	; 255
    30a8:	3f 4f       	sbci	r19, 0xFF	; 255
    30aa:	26 30       	cpi	r18, 0x06	; 6
    30ac:	31 05       	cpc	r19, r1
    30ae:	91 f7       	brne	.-28     	; 0x3094 <ProcMessage91+0x4>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    30b0:	10 92 c4 0d 	sts	0x0DC4, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    30b4:	80 91 7c 0a 	lds	r24, 0x0A7C
    30b8:	80 93 cb 08 	sts	0x08CB, r24
    30bc:	80 91 7d 0a 	lds	r24, 0x0A7D
    30c0:	80 93 cc 08 	sts	0x08CC, r24
	 }Dest[Length]=0;
    30c4:	10 92 cd 08 	sts	0x08CD, r1
    30c8:	20 e0       	ldi	r18, 0x00	; 0
    30ca:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    30cc:	f9 01       	movw	r30, r18
    30ce:	e0 5c       	subi	r30, 0xC0	; 192
    30d0:	f6 4f       	sbci	r31, 0xF6	; 246
    30d2:	d9 01       	movw	r26, r18
    30d4:	af 5a       	subi	r26, 0xAF	; 175
    30d6:	b5 4f       	sbci	r27, 0xF5	; 245
    30d8:	9d 96       	adiw	r26, 0x2d	; 45
    30da:	8c 91       	ld	r24, X
    30dc:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    30de:	2f 5f       	subi	r18, 0xFF	; 255
    30e0:	3f 4f       	sbci	r19, 0xFF	; 255
    30e2:	2f 30       	cpi	r18, 0x0F	; 15
    30e4:	31 05       	cpc	r19, r1
    30e6:	91 f7       	brne	.-28     	; 0x30cc <ProcMessage91+0x3c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    30e8:	10 92 4f 09 	sts	0x094F, r1
    30ec:	20 e0       	ldi	r18, 0x00	; 0
    30ee:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    30f0:	f9 01       	movw	r30, r18
    30f2:	e0 55       	subi	r30, 0x50	; 80
    30f4:	f9 4f       	sbci	r31, 0xF9	; 249
    30f6:	d9 01       	movw	r26, r18
    30f8:	af 5a       	subi	r26, 0xAF	; 175
    30fa:	b5 4f       	sbci	r27, 0xF5	; 245
    30fc:	dc 96       	adiw	r26, 0x3c	; 60
    30fe:	8c 91       	ld	r24, X
    3100:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    3102:	2f 5f       	subi	r18, 0xFF	; 255
    3104:	3f 4f       	sbci	r19, 0xFF	; 255
    3106:	26 30       	cpi	r18, 0x06	; 6
    3108:	31 05       	cpc	r19, r1
    310a:	91 f7       	brne	.-28     	; 0x30f0 <ProcMessage91+0x60>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    310c:	10 92 b6 06 	sts	0x06B6, r1
    3110:	20 e0       	ldi	r18, 0x00	; 0
    3112:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    3114:	f9 01       	movw	r30, r18
    3116:	ec 57       	subi	r30, 0x7C	; 124
    3118:	fb 4f       	sbci	r31, 0xFB	; 251
    311a:	d9 01       	movw	r26, r18
    311c:	ad 56       	subi	r26, 0x6D	; 109
    311e:	b5 4f       	sbci	r27, 0xF5	; 245
    3120:	8c 91       	ld	r24, X
    3122:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    3124:	2f 5f       	subi	r18, 0xFF	; 255
    3126:	3f 4f       	sbci	r19, 0xFF	; 255
    3128:	28 30       	cpi	r18, 0x08	; 8
    312a:	31 05       	cpc	r19, r1
    312c:	99 f7       	brne	.-26     	; 0x3114 <ProcMessage91+0x84>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    312e:	10 92 8c 04 	sts	0x048C, r1
    3132:	20 e0       	ldi	r18, 0x00	; 0
    3134:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    3136:	f9 01       	movw	r30, r18
    3138:	e9 51       	subi	r30, 0x19	; 25
    313a:	f3 4f       	sbci	r31, 0xF3	; 243
    313c:	d9 01       	movw	r26, r18
    313e:	a5 56       	subi	r26, 0x65	; 101
    3140:	b5 4f       	sbci	r27, 0xF5	; 245
    3142:	8c 91       	ld	r24, X
    3144:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    3146:	2f 5f       	subi	r18, 0xFF	; 255
    3148:	3f 4f       	sbci	r19, 0xFF	; 255
    314a:	28 30       	cpi	r18, 0x08	; 8
    314c:	31 05       	cpc	r19, r1
    314e:	99 f7       	brne	.-26     	; 0x3136 <ProcMessage91+0xa6>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    3150:	10 92 ef 0c 	sts	0x0CEF, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    3154:	80 91 a3 0a 	lds	r24, 0x0AA3
    3158:	80 93 99 04 	sts	0x0499, r24
	 }Dest[Length]=0;
    315c:	10 92 9a 04 	sts	0x049A, r1
    3160:	20 e0       	ldi	r18, 0x00	; 0
    3162:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    3164:	f9 01       	movw	r30, r18
    3166:	e5 5f       	subi	r30, 0xF5	; 245
    3168:	fb 4f       	sbci	r31, 0xFB	; 251
    316a:	d9 01       	movw	r26, r18
    316c:	ac 55       	subi	r26, 0x5C	; 92
    316e:	b5 4f       	sbci	r27, 0xF5	; 245
    3170:	8c 91       	ld	r24, X
    3172:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    3174:	2f 5f       	subi	r18, 0xFF	; 255
    3176:	3f 4f       	sbci	r19, 0xFF	; 255
    3178:	29 30       	cpi	r18, 0x09	; 9
    317a:	31 05       	cpc	r19, r1
    317c:	99 f7       	brne	.-26     	; 0x3164 <ProcMessage91+0xd4>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    317e:	10 92 14 04 	sts	0x0414, r1
     StrPosCopy(rcv_trans,strPrice,60,6);
     StrPosCopy(rcv_trans,strVolume,66,8);
     StrPosCopy(rcv_trans,strAmount,74,8); 
	 StrPosCopy(rcv_trans,strStatus,82,1);
     StrPosCopy(rcv_trans,strSurcharge,83,9);    
}
    3182:	08 95       	ret

00003184 <IdentifyMessage>:
        //sprintf_P(strSerial,PSTR("RFID:%s"),strRFID);
        //_uart_print(0,1,strSerial);
	 }
}

void IdentifyMessage(char STX,unsigned int Length){
    3184:	1f 93       	push	r17
   if (STX==0x01){
    3186:	81 30       	cpi	r24, 0x01	; 1
    3188:	09 f0       	breq	.+2      	; 0x318c <IdentifyMessage+0x8>
    318a:	5f c0       	rjmp	.+190    	; 0x324a <IdentifyMessage+0xc6>
	    if ((Length==MSG00_LENGTH)||(MsgCode==0)) IsMessage00=True;//47
    318c:	6f 32       	cpi	r22, 0x2F	; 47
    318e:	71 05       	cpc	r23, r1
    3190:	21 f0       	breq	.+8      	; 0x319a <IdentifyMessage+0x16>
    3192:	80 91 14 01 	lds	r24, 0x0114
    3196:	88 23       	and	r24, r24
    3198:	21 f4       	brne	.+8      	; 0x31a2 <IdentifyMessage+0x1e>
    319a:	81 e0       	ldi	r24, 0x01	; 1
    319c:	80 93 a1 01 	sts	0x01A1, r24
    31a0:	4a c0       	rjmp	.+148    	; 0x3236 <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG09_LENGTH)||(MsgCode==9)) IsMessage09=True;//615
    31a2:	6c 36       	cpi	r22, 0x6C	; 108
    31a4:	71 05       	cpc	r23, r1
    31a6:	11 f0       	breq	.+4      	; 0x31ac <IdentifyMessage+0x28>
    31a8:	89 30       	cpi	r24, 0x09	; 9
    31aa:	21 f4       	brne	.+8      	; 0x31b4 <IdentifyMessage+0x30>
    31ac:	81 e0       	ldi	r24, 0x01	; 1
    31ae:	80 93 a6 01 	sts	0x01A6, r24
    31b2:	41 c0       	rjmp	.+130    	; 0x3236 <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG11_LENGTH)||(MsgCode==11)) IsMessage11=True;//615
    31b4:	92 e0       	ldi	r25, 0x02	; 2
    31b6:	67 36       	cpi	r22, 0x67	; 103
    31b8:	79 07       	cpc	r23, r25
    31ba:	11 f0       	breq	.+4      	; 0x31c0 <IdentifyMessage+0x3c>
    31bc:	8b 30       	cpi	r24, 0x0B	; 11
    31be:	21 f4       	brne	.+8      	; 0x31c8 <IdentifyMessage+0x44>
    31c0:	81 e0       	ldi	r24, 0x01	; 1
    31c2:	80 93 a3 01 	sts	0x01A3, r24
    31c6:	37 c0       	rjmp	.+110    	; 0x3236 <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG23_LENGTH)||(MsgCode==23)) IsMessage23=True;//145
    31c8:	61 39       	cpi	r22, 0x91	; 145
    31ca:	71 05       	cpc	r23, r1
    31cc:	11 f0       	breq	.+4      	; 0x31d2 <IdentifyMessage+0x4e>
    31ce:	87 31       	cpi	r24, 0x17	; 23
    31d0:	21 f4       	brne	.+8      	; 0x31da <IdentifyMessage+0x56>
    31d2:	81 e0       	ldi	r24, 0x01	; 1
    31d4:	80 93 a5 01 	sts	0x01A5, r24
    31d8:	2e c0       	rjmp	.+92     	; 0x3236 <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG57_LENGTH)||(MsgCode==57)) IsMessage57=True;//230
    31da:	66 3e       	cpi	r22, 0xE6	; 230
    31dc:	71 05       	cpc	r23, r1
    31de:	11 f0       	breq	.+4      	; 0x31e4 <IdentifyMessage+0x60>
    31e0:	89 33       	cpi	r24, 0x39	; 57
    31e2:	21 f4       	brne	.+8      	; 0x31ec <IdentifyMessage+0x68>
    31e4:	81 e0       	ldi	r24, 0x01	; 1
    31e6:	80 93 a8 01 	sts	0x01A8, r24
    31ea:	25 c0       	rjmp	.+74     	; 0x3236 <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG99_LENGTH)||(MsgCode==99)) IsMessage99=True;//378
    31ec:	91 e0       	ldi	r25, 0x01	; 1
    31ee:	68 39       	cpi	r22, 0x98	; 152
    31f0:	79 07       	cpc	r23, r25
    31f2:	11 f0       	breq	.+4      	; 0x31f8 <IdentifyMessage+0x74>
    31f4:	83 36       	cpi	r24, 0x63	; 99
    31f6:	21 f4       	brne	.+8      	; 0x3200 <IdentifyMessage+0x7c>
    31f8:	81 e0       	ldi	r24, 0x01	; 1
    31fa:	80 93 a2 01 	sts	0x01A2, r24
    31fe:	1b c0       	rjmp	.+54     	; 0x3236 <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG81_LENGTH)||(MsgCode==81)) IsMessage81=True;//426
    3200:	91 e0       	ldi	r25, 0x01	; 1
    3202:	66 3b       	cpi	r22, 0xB6	; 182
    3204:	79 07       	cpc	r23, r25
    3206:	11 f0       	breq	.+4      	; 0x320c <IdentifyMessage+0x88>
    3208:	81 35       	cpi	r24, 0x51	; 81
    320a:	21 f4       	brne	.+8      	; 0x3214 <IdentifyMessage+0x90>
    320c:	81 e0       	ldi	r24, 0x01	; 1
    320e:	80 93 a9 01 	sts	0x01A9, r24
    3212:	11 c0       	rjmp	.+34     	; 0x3236 <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG91_LENGTH)||(MsgCode==91)) IsMessage91=True;//426
    3214:	6c 35       	cpi	r22, 0x5C	; 92
    3216:	71 05       	cpc	r23, r1
    3218:	11 f0       	breq	.+4      	; 0x321e <IdentifyMessage+0x9a>
    321a:	8b 35       	cpi	r24, 0x5B	; 91
    321c:	21 f4       	brne	.+8      	; 0x3226 <IdentifyMessage+0xa2>
    321e:	81 e0       	ldi	r24, 0x01	; 1
    3220:	80 93 aa 01 	sts	0x01AA, r24
    3224:	08 c0       	rjmp	.+16     	; 0x3236 <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG21_LENGTH)||(MsgCode==21)) IsMessage21=True;//426
    3226:	66 35       	cpi	r22, 0x56	; 86
    3228:	71 05       	cpc	r23, r1
    322a:	11 f0       	breq	.+4      	; 0x3230 <IdentifyMessage+0xac>
    322c:	85 31       	cpi	r24, 0x15	; 21
    322e:	19 f4       	brne	.+6      	; 0x3236 <IdentifyMessage+0xb2>
    3230:	81 e0       	ldi	r24, 0x01	; 1
    3232:	80 93 a4 01 	sts	0x01A4, r24

        //EDC AdvanZ Respond
		if (IsMessage91==True){
    3236:	10 91 aa 01 	lds	r17, 0x01AA
    323a:	11 30       	cpi	r17, 0x01	; 1
    323c:	31 f4       	brne	.+12     	; 0x324a <IdentifyMessage+0xc6>
		    IsMessage91=False;
    323e:	10 92 aa 01 	sts	0x01AA, r1
		    ProcMessage91();
    3242:	0e 94 48 18 	call	0x3090	; 0x3090 <ProcMessage91>
			IsSendMessageEDC=True;
    3246:	10 93 9a 01 	sts	0x019A, r17
		  }

//	  sprintf(SerialSend,"Length:%i",Length);	 
//	  _uart_print(1,0,SerialSend);
	 }
}
    324a:	1f 91       	pop	r17
    324c:	08 95       	ret

0000324e <Tab>:

	  }
     return Result;     
}

void Tab(char *sTab, char nTab){
    324e:	fc 01       	movw	r30, r24
    3250:	dc 01       	movw	r26, r24
    3252:	80 e0       	ldi	r24, 0x00	; 0
     char i;
	 for(i=0;i<nTab;i++){
	     sTab[i]=' ';
    3254:	90 e2       	ldi	r25, 0x20	; 32
    3256:	02 c0       	rjmp	.+4      	; 0x325c <Tab+0xe>
    3258:	9d 93       	st	X+, r25
     return Result;     
}

void Tab(char *sTab, char nTab){
     char i;
	 for(i=0;i<nTab;i++){
    325a:	8f 5f       	subi	r24, 0xFF	; 255
    325c:	86 17       	cp	r24, r22
    325e:	e0 f3       	brcs	.-8      	; 0x3258 <Tab+0xa>
	     sTab[i]=' ';
	 }sTab[nTab]=0;
    3260:	e6 0f       	add	r30, r22
    3262:	f1 1d       	adc	r31, r1
    3264:	10 82       	st	Z, r1
}
    3266:	08 95       	ret

00003268 <StrToRaw>:
			  }
		  }
	 }
}
                                       //12byte->6Byte         0 1 2 3  
void StrToRaw(char *Source,char *Dest){//Source: "1234567890AB"
    3268:	dc 01       	movw	r26, r24
    326a:	20 e0       	ldi	r18, 0x00	; 0
    326c:	30 e0       	ldi	r19, 0x00	; 0
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    326e:	9c 91       	ld	r25, X
    3270:	90 53       	subi	r25, 0x30	; 48
    3272:	9a 30       	cpi	r25, 0x0A	; 10
    3274:	08 f0       	brcs	.+2      	; 0x3278 <StrToRaw+0x10>
    3276:	90 e0       	ldi	r25, 0x00	; 0
	 char xRaw=0;
	 for (i=0;i<6;i++){
	      xA=Ord(Source[(2*i)]);
		  xB=(0x0F&Ord(Source[(2*i)+1]));
	      xRaw=((xA<<4) | xB);
	      Dest[i]=xRaw;
    3278:	11 96       	adiw	r26, 0x01	; 1
    327a:	8c 91       	ld	r24, X
    327c:	11 97       	sbiw	r26, 0x01	; 1
    327e:	80 53       	subi	r24, 0x30	; 48
    3280:	8a 30       	cpi	r24, 0x0A	; 10
    3282:	08 f0       	brcs	.+2      	; 0x3286 <StrToRaw+0x1e>
    3284:	80 e0       	ldi	r24, 0x00	; 0
    3286:	fb 01       	movw	r30, r22
    3288:	e2 0f       	add	r30, r18
    328a:	f3 1f       	adc	r31, r19
    328c:	8f 70       	andi	r24, 0x0F	; 15
    328e:	92 95       	swap	r25
    3290:	90 7f       	andi	r25, 0xF0	; 240
    3292:	98 2b       	or	r25, r24
    3294:	90 83       	st	Z, r25
    3296:	2f 5f       	subi	r18, 0xFF	; 255
    3298:	3f 4f       	sbci	r19, 0xFF	; 255
    329a:	12 96       	adiw	r26, 0x02	; 2
}
                                       //12byte->6Byte         0 1 2 3  
void StrToRaw(char *Source,char *Dest){//Source: "1234567890AB"
     char i,xA,xB;                //Dest  :  12345678 
	 char xRaw=0;
	 for (i=0;i<6;i++){
    329c:	26 30       	cpi	r18, 0x06	; 6
    329e:	31 05       	cpc	r19, r1
    32a0:	31 f7       	brne	.-52     	; 0x326e <StrToRaw+0x6>
	      xA=Ord(Source[(2*i)]);
		  xB=(0x0F&Ord(Source[(2*i)+1]));
	      xRaw=((xA<<4) | xB);
	      Dest[i]=xRaw;
	 }	      
}
    32a2:	08 95       	ret

000032a4 <RawToStr>:
void RawToStr(char *Source,char *Dest){//Source:   1234567890AB
    32a4:	cf 93       	push	r28
    32a6:	df 93       	push	r29
    32a8:	eb 01       	movw	r28, r22
    32aa:	db 01       	movw	r26, r22
    32ac:	20 e0       	ldi	r18, 0x00	; 0
    32ae:	30 e0       	ldi	r19, 0x00	; 0
     unsigned char i,xRaw,cA,cB;               //Dest  :  "12345678" 
	 for (i=0;i<6;i++){
	      cA=Chr(Source[i]>>4);
    32b0:	fc 01       	movw	r30, r24
    32b2:	e2 0f       	add	r30, r18
    32b4:	f3 1f       	adc	r31, r19
    32b6:	e0 81       	ld	r30, Z
    32b8:	4e 2f       	mov	r20, r30
    32ba:	42 95       	swap	r20
    32bc:	4f 70       	andi	r20, 0x0F	; 15
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    32be:	4a 30       	cpi	r20, 0x0A	; 10
    32c0:	10 f0       	brcs	.+4      	; 0x32c6 <RawToStr+0x22>
    32c2:	40 e3       	ldi	r20, 0x30	; 48
    32c4:	01 c0       	rjmp	.+2      	; 0x32c8 <RawToStr+0x24>
	    Result='0'+X;
    32c6:	40 5d       	subi	r20, 0xD0	; 208
}
void RawToStr(char *Source,char *Dest){//Source:   1234567890AB
     unsigned char i,xRaw,cA,cB;               //Dest  :  "12345678" 
	 for (i=0;i<6;i++){
	      cA=Chr(Source[i]>>4);
	      cB=Chr(Source[i]&0x0F);
    32c8:	ef 70       	andi	r30, 0x0F	; 15
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    32ca:	ea 30       	cpi	r30, 0x0A	; 10
    32cc:	10 f0       	brcs	.+4      	; 0x32d2 <RawToStr+0x2e>
    32ce:	e0 e3       	ldi	r30, 0x30	; 48
    32d0:	01 c0       	rjmp	.+2      	; 0x32d4 <RawToStr+0x30>
	    Result='0'+X;
    32d2:	e0 5d       	subi	r30, 0xD0	; 208
void RawToStr(char *Source,char *Dest){//Source:   1234567890AB
     unsigned char i,xRaw,cA,cB;               //Dest  :  "12345678" 
	 for (i=0;i<6;i++){
	      cA=Chr(Source[i]>>4);
	      cB=Chr(Source[i]&0x0F);
          Dest[2*i]=cA;
    32d4:	4c 93       	st	X, r20
          Dest[(2*i)+1]=cB;
    32d6:	11 96       	adiw	r26, 0x01	; 1
    32d8:	ec 93       	st	X, r30
    32da:	11 97       	sbiw	r26, 0x01	; 1
    32dc:	2f 5f       	subi	r18, 0xFF	; 255
    32de:	3f 4f       	sbci	r19, 0xFF	; 255
    32e0:	12 96       	adiw	r26, 0x02	; 2
	      Dest[i]=xRaw;
	 }	      
}
void RawToStr(char *Source,char *Dest){//Source:   1234567890AB
     unsigned char i,xRaw,cA,cB;               //Dest  :  "12345678" 
	 for (i=0;i<6;i++){
    32e2:	26 30       	cpi	r18, 0x06	; 6
    32e4:	31 05       	cpc	r19, r1
    32e6:	21 f7       	brne	.-56     	; 0x32b0 <RawToStr+0xc>
	      cA=Chr(Source[i]>>4);
	      cB=Chr(Source[i]&0x0F);
          Dest[2*i]=cA;
          Dest[(2*i)+1]=cB;
	 }Dest[12]=0;
    32e8:	1c 86       	std	Y+12, r1	; 0x0c
}
    32ea:	df 91       	pop	r29
    32ec:	cf 91       	pop	r28
    32ee:	08 95       	ret

000032f0 <CalcMinus>:
}

char CalcMinus(char A, char B){
     signed char xC;//,xA,xB;
	 char Result;
	 if (A>=B) xC=((A-'0')-(B-'0'));
    32f0:	86 17       	cp	r24, r22
    32f2:	08 f4       	brcc	.+2      	; 0x32f6 <CalcMinus+0x6>
	 else xC=10+((A-'0')-(B-'0'));//
    32f4:	86 5f       	subi	r24, 0xF6	; 246
    32f6:	86 1b       	sub	r24, r22
	 Result='0'+xC;
  return Result;
}
    32f8:	80 5d       	subi	r24, 0xD0	; 208
    32fa:	08 95       	ret

000032fc <CalcPlus>:

char CalcPlus(char A, char B){
    32fc:	80 56       	subi	r24, 0x60	; 96
    32fe:	86 0f       	add	r24, r22
    3300:	6a e0       	ldi	r22, 0x0A	; 10
    3302:	0e 94 fd b6 	call	0x16dfa	; 0x16dfa <__divmodqi4>
     signed char xA,xB,xC;
	 char Result;
	 xC=((A-'0')+(B-'0'));
     Result='0'+(xC%10);  
   return Result;
}
    3306:	89 2f       	mov	r24, r25
    3308:	80 5d       	subi	r24, 0xD0	; 208
    330a:	08 95       	ret

0000330c <Chr>:
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    330c:	8a 30       	cpi	r24, 0x0A	; 10
    330e:	10 f0       	brcs	.+4      	; 0x3314 <Chr+0x8>
    3310:	80 e3       	ldi	r24, 0x30	; 48
    3312:	08 95       	ret
	    Result='0'+X;
    3314:	80 5d       	subi	r24, 0xD0	; 208
	 }
	return Result;
}
    3316:	08 95       	ret

00003318 <Ord>:
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    3318:	80 53       	subi	r24, 0x30	; 48
    331a:	8a 30       	cpi	r24, 0x0A	; 10
    331c:	08 f0       	brcs	.+2      	; 0x3320 <Ord+0x8>
    331e:	80 e0       	ldi	r24, 0x00	; 0
	    Result=c-'0';
	 }
	return Result;
}
    3320:	08 95       	ret

00003322 <GetTabSpace>:
	     StrCalc(TPLUS,prevSeg,currSeg,prevSeg);
	 }
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
    3322:	48 2f       	mov	r20, r24
    3324:	fb 01       	movw	r30, r22
     char i,nTab;
	 if (TabLength>0){
    3326:	18 16       	cp	r1, r24
    3328:	64 f4       	brge	.+24     	; 0x3342 <GetTabSpace+0x20>
		 nTab=TabLength;//%40;
    332a:	56 2f       	mov	r21, r22
    332c:	db 01       	movw	r26, r22
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    332e:	90 e2       	ldi	r25, 0x20	; 32
    3330:	9d 93       	st	X+, r25

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    3332:	8a 2f       	mov	r24, r26
    3334:	85 1b       	sub	r24, r21
    3336:	84 17       	cp	r24, r20
    3338:	d8 f3       	brcs	.-10     	; 0x3330 <GetTabSpace+0xe>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    333a:	e4 0f       	add	r30, r20
    333c:	f1 1d       	adc	r31, r1
    333e:	10 82       	st	Z, r1
    3340:	08 95       	ret
     }else{
	 strTab[0]=' ';
    3342:	80 e2       	ldi	r24, 0x20	; 32
    3344:	80 83       	st	Z, r24
	 strTab[1]=0;
    3346:	11 82       	std	Z+1, r1	; 0x01
    3348:	08 95       	ret

0000334a <GetBorderValue>:

}

char GetBorderValue(char BoderType){
     char Result=0;
	 switch (BoderType){
    334a:	86 30       	cpi	r24, 0x06	; 6
    334c:	51 f1       	breq	.+84     	; 0x33a2 <GetBorderValue+0x58>
    334e:	87 30       	cpi	r24, 0x07	; 7
    3350:	70 f4       	brcc	.+28     	; 0x336e <GetBorderValue+0x24>
    3352:	83 30       	cpi	r24, 0x03	; 3
    3354:	11 f1       	breq	.+68     	; 0x339a <GetBorderValue+0x50>
    3356:	84 30       	cpi	r24, 0x04	; 4
    3358:	28 f4       	brcc	.+10     	; 0x3364 <GetBorderValue+0x1a>
    335a:	81 30       	cpi	r24, 0x01	; 1
    335c:	c1 f0       	breq	.+48     	; 0x338e <GetBorderValue+0x44>
    335e:	82 30       	cpi	r24, 0x02	; 2
    3360:	c1 f4       	brne	.+48     	; 0x3392 <GetBorderValue+0x48>
    3362:	19 c0       	rjmp	.+50     	; 0x3396 <GetBorderValue+0x4c>
    3364:	84 30       	cpi	r24, 0x04	; 4
    3366:	d9 f0       	breq	.+54     	; 0x339e <GetBorderValue+0x54>
    3368:	85 30       	cpi	r24, 0x05	; 5
    336a:	99 f4       	brne	.+38     	; 0x3392 <GetBorderValue+0x48>
    336c:	22 c0       	rjmp	.+68     	; 0x33b2 <GetBorderValue+0x68>
    336e:	89 30       	cpi	r24, 0x09	; 9
    3370:	f1 f0       	breq	.+60     	; 0x33ae <GetBorderValue+0x64>
    3372:	8a 30       	cpi	r24, 0x0A	; 10
    3374:	28 f4       	brcc	.+10     	; 0x3380 <GetBorderValue+0x36>
    3376:	87 30       	cpi	r24, 0x07	; 7
    3378:	b1 f0       	breq	.+44     	; 0x33a6 <GetBorderValue+0x5c>
    337a:	88 30       	cpi	r24, 0x08	; 8
    337c:	51 f4       	brne	.+20     	; 0x3392 <GetBorderValue+0x48>
    337e:	15 c0       	rjmp	.+42     	; 0x33aa <GetBorderValue+0x60>
    3380:	8b 30       	cpi	r24, 0x0B	; 11
    3382:	d9 f0       	breq	.+54     	; 0x33ba <GetBorderValue+0x70>
    3384:	8b 30       	cpi	r24, 0x0B	; 11
    3386:	b8 f0       	brcs	.+46     	; 0x33b6 <GetBorderValue+0x6c>
    3388:	8c 30       	cpi	r24, 0x0C	; 12
    338a:	19 f4       	brne	.+6      	; 0x3392 <GetBorderValue+0x48>
    338c:	18 c0       	rjmp	.+48     	; 0x33be <GetBorderValue+0x74>
    338e:	8a ed       	ldi	r24, 0xDA	; 218
    3390:	08 95       	ret
    3392:	80 e0       	ldi	r24, 0x00	; 0
    3394:	08 95       	ret
    3396:	82 ec       	ldi	r24, 0xC2	; 194
    3398:	08 95       	ret
		case btTopLeft: 
		     Result=0xDA;
			 break;
		case btTopCenter: 
		     Result=0xC2;
			 break;
    339a:	8f eb       	ldi	r24, 0xBF	; 191
    339c:	08 95       	ret
		case btTopRight:
		     Result=0xBF;		 
			 break;
    339e:	83 ec       	ldi	r24, 0xC3	; 195
    33a0:	08 95       	ret
		case btMiddleLeft: 
			 Result=0xC3;
			 break;
    33a2:	84 eb       	ldi	r24, 0xB4	; 180
    33a4:	08 95       	ret
		case btMiddleRight: 
			 Result=0xB4;
			 break;
    33a6:	80 ec       	ldi	r24, 0xC0	; 192
    33a8:	08 95       	ret
		case btBottomLeft: 
		     Result=0xC0;
			 break;
    33aa:	81 ec       	ldi	r24, 0xC1	; 193
    33ac:	08 95       	ret
		case btBottomCenter: 
			 Result=0xC1;
			 break;
    33ae:	89 ed       	ldi	r24, 0xD9	; 217
    33b0:	08 95       	ret
		case btBottomRight: 
			 Result=0xD9;
			 break;
    33b2:	85 ec       	ldi	r24, 0xC5	; 197
    33b4:	08 95       	ret
        case btMiddleCenter:
		     Result=0xC5;
		     break;
    33b6:	83 eb       	ldi	r24, 0xB3	; 179
    33b8:	08 95       	ret
		case btVertical: 
			 Result=0xB3;
			 break;
    33ba:	84 ec       	ldi	r24, 0xC4	; 196
    33bc:	08 95       	ret
		case btHorizontal:
			 Result=0xC4;
			 break;	 
    33be:	8d e0       	ldi	r24, 0x0D	; 13
        case btNewLine:
		     Result=0x0D;
			 break;	 
	 }
   return Result;
}
    33c0:	08 95       	ret

000033c2 <InserBorder>:

void InserBorder(char BorderType, char *strPrnBuffer,char nLength,unsigned int *Pos){
    33c2:	bf 92       	push	r11
    33c4:	cf 92       	push	r12
    33c6:	df 92       	push	r13
    33c8:	ef 92       	push	r14
    33ca:	ff 92       	push	r15
    33cc:	0f 93       	push	r16
    33ce:	1f 93       	push	r17
    33d0:	cf 93       	push	r28
    33d2:	df 93       	push	r29
    33d4:	b8 2e       	mov	r11, r24
    33d6:	8b 01       	movw	r16, r22
    33d8:	e4 2e       	mov	r14, r20
    33da:	69 01       	movw	r12, r18
     char i;//,BorderValue=0;
	 unsigned int StartPos,iPos=0;
	 
	 iPos=*Pos;
    33dc:	f9 01       	movw	r30, r18
    33de:	c0 81       	ld	r28, Z
    33e0:	d1 81       	ldd	r29, Z+1	; 0x01
    33e2:	0c 0f       	add	r16, r28
    33e4:	1d 1f       	adc	r17, r29
    33e6:	ff 24       	eor	r15, r15
    33e8:	07 c0       	rjmp	.+14     	; 0x33f8 <InserBorder+0x36>
	 StartPos=iPos;
	 for (i=0;i<nLength;i++){
	      strPrnBuffer[iPos]=GetBorderValue(BorderType);
    33ea:	8b 2d       	mov	r24, r11
    33ec:	0e 94 a5 19 	call	0x334a	; 0x334a <GetBorderValue>
    33f0:	f8 01       	movw	r30, r16
    33f2:	81 93       	st	Z+, r24
    33f4:	8f 01       	movw	r16, r30
     char i;//,BorderValue=0;
	 unsigned int StartPos,iPos=0;
	 
	 iPos=*Pos;
	 StartPos=iPos;
	 for (i=0;i<nLength;i++){
    33f6:	f3 94       	inc	r15
    33f8:	fe 14       	cp	r15, r14
    33fa:	b8 f3       	brcs	.-18     	; 0x33ea <InserBorder+0x28>
	 //for (i=0;i<nLength;i++){
	 //     if (strPrnBuffer[i+StartPos]!=GetBorderValue(BorderType)){
//		      strPrnBuffer[i+StartPos]=GetBorderValue(BorderType);
//		  }
//	 }
     *Pos=iPos;
    33fc:	ce 0d       	add	r28, r14
    33fe:	d1 1d       	adc	r29, r1
    3400:	f6 01       	movw	r30, r12
    3402:	d1 83       	std	Z+1, r29	; 0x01
    3404:	c0 83       	st	Z, r28
}
    3406:	df 91       	pop	r29
    3408:	cf 91       	pop	r28
    340a:	1f 91       	pop	r17
    340c:	0f 91       	pop	r16
    340e:	ff 90       	pop	r15
    3410:	ef 90       	pop	r14
    3412:	df 90       	pop	r13
    3414:	cf 90       	pop	r12
    3416:	bf 90       	pop	r11
    3418:	08 95       	ret

0000341a <GeniusSendPumpStatus>:
   return Result;
}

void GeniusSendPumpStatus(char iPumpID){
     
}
    341a:	08 95       	ret

0000341c <GeniusSendStopPump>:
void GeniusSendStopPump(char iPumpID){
}
    341c:	08 95       	ret

0000341e <GeniusSendResumePump>:
void GeniusSendResumePump(char iPumpID){
}
    341e:	08 95       	ret

00003420 <GeniusSendPumpPreset>:
void GeniusSendPumpPreset(char iPumpID){
}
    3420:	08 95       	ret

00003422 <SetIncomingTransStatus>:
	 sprintf_P(strSend,PSTR("%d"),cSum);
	 _uart_print(1,1,strSend);	 
}


void SetIncomingTransStatus(char iPumpID,char xTransStatus){
    3422:	e8 2f       	mov	r30, r24
char iStatus,xMaskA,xMaskB,xMaskC,xPumpID;
	 xPumpID=(iPumpID&0x0F);
    3424:	28 2f       	mov	r18, r24
    3426:	2f 70       	andi	r18, 0x0F	; 15
     iStatus=IncomingTransaction[xPumpID/8];
    3428:	82 2f       	mov	r24, r18
    342a:	86 95       	lsr	r24
    342c:	86 95       	lsr	r24
    342e:	86 95       	lsr	r24
    3430:	a8 2f       	mov	r26, r24
    3432:	b0 e0       	ldi	r27, 0x00	; 0
    3434:	a5 5f       	subi	r26, 0xF5	; 245
    3436:	b2 4f       	sbci	r27, 0xF2	; 242
    3438:	4c 91       	ld	r20, X
	 if (xTransStatus==TS_NEW){
    343a:	62 30       	cpi	r22, 0x02	; 2
    343c:	59 f4       	brne	.+22     	; 0x3454 <SetIncomingTransStatus+0x32>
	     iStatus=(iStatus|(1<<(xPumpID%8)));	 
    343e:	27 70       	andi	r18, 0x07	; 7
    3440:	81 e0       	ldi	r24, 0x01	; 1
    3442:	90 e0       	ldi	r25, 0x00	; 0
    3444:	02 c0       	rjmp	.+4      	; 0x344a <SetIncomingTransStatus+0x28>
    3446:	88 0f       	add	r24, r24
    3448:	99 1f       	adc	r25, r25
    344a:	2a 95       	dec	r18
    344c:	e2 f7       	brpl	.-8      	; 0x3446 <SetIncomingTransStatus+0x24>
    344e:	48 2b       	or	r20, r24
		 IncomingTransaction[xPumpID/8]=iStatus;
    3450:	4c 93       	st	X, r20
    3452:	08 95       	ret
	 }else if (xTransStatus==TS_OLD){
    3454:	63 30       	cpi	r22, 0x03	; 3
    3456:	b1 f4       	brne	.+44     	; 0x3484 <SetIncomingTransStatus+0x62>
		 xMaskA=(0xFE<<(xPumpID%8));
    3458:	27 70       	andi	r18, 0x07	; 7
    345a:	8e ef       	ldi	r24, 0xFE	; 254
    345c:	90 e0       	ldi	r25, 0x00	; 0
    345e:	01 c0       	rjmp	.+2      	; 0x3462 <SetIncomingTransStatus+0x40>
    3460:	88 0f       	add	r24, r24
    3462:	2a 95       	dec	r18
    3464:	ea f7       	brpl	.-6      	; 0x3460 <SetIncomingTransStatus+0x3e>
		 xMaskB=(~xMaskA)>>1;
		 xMaskC=xMaskA|xMaskB;
		 iStatus=iStatus&xMaskC;
		 IncomingTransaction[iPumpID/8]=iStatus;
    3466:	e6 95       	lsr	r30
    3468:	e6 95       	lsr	r30
    346a:	e6 95       	lsr	r30
    346c:	f0 e0       	ldi	r31, 0x00	; 0
    346e:	e5 5f       	subi	r30, 0xF5	; 245
    3470:	f2 4f       	sbci	r31, 0xF2	; 242
    3472:	28 2f       	mov	r18, r24
    3474:	30 e0       	ldi	r19, 0x00	; 0
    3476:	20 95       	com	r18
    3478:	30 95       	com	r19
    347a:	35 95       	asr	r19
    347c:	27 95       	ror	r18
    347e:	82 2b       	or	r24, r18
    3480:	84 23       	and	r24, r20
    3482:	80 83       	st	Z, r24
    3484:	08 95       	ret

00003486 <GetIncomingTransStatus>:
	 }
}
char GetIncomingTransStatus(char iPumpID){
     char xPumpID,Result;
	 xPumpID=(iPumpID&0x0F);
    3486:	8f 70       	andi	r24, 0x0F	; 15
	 Result=TS_NONE;
     if((IncomingTransaction[xPumpID/8]>>(xPumpID%8))==1){
    3488:	e8 2f       	mov	r30, r24
    348a:	e6 95       	lsr	r30
    348c:	e6 95       	lsr	r30
    348e:	e6 95       	lsr	r30
    3490:	f0 e0       	ldi	r31, 0x00	; 0
    3492:	e5 5f       	subi	r30, 0xF5	; 245
    3494:	f2 4f       	sbci	r31, 0xF2	; 242
    3496:	90 81       	ld	r25, Z
    3498:	29 2f       	mov	r18, r25
    349a:	30 e0       	ldi	r19, 0x00	; 0
    349c:	87 70       	andi	r24, 0x07	; 7
    349e:	02 c0       	rjmp	.+4      	; 0x34a4 <GetIncomingTransStatus+0x1e>
    34a0:	35 95       	asr	r19
    34a2:	27 95       	ror	r18
    34a4:	8a 95       	dec	r24
    34a6:	e2 f7       	brpl	.-8      	; 0x34a0 <GetIncomingTransStatus+0x1a>
    34a8:	21 30       	cpi	r18, 0x01	; 1
    34aa:	31 05       	cpc	r19, r1
    34ac:	11 f4       	brne	.+4      	; 0x34b2 <GetIncomingTransStatus+0x2c>
    34ae:	82 e0       	ldi	r24, 0x02	; 2
    34b0:	08 95       	ret
	     Result=TS_NEW;
	 }else
     if((IncomingTransaction[xPumpID/8]>>(xPumpID%8))==0){
    34b2:	23 2b       	or	r18, r19
    34b4:	11 f4       	brne	.+4      	; 0x34ba <GetIncomingTransStatus+0x34>
    34b6:	83 e0       	ldi	r24, 0x03	; 3
    34b8:	08 95       	ret
    34ba:	80 e0       	ldi	r24, 0x00	; 0
	     Result=TS_OLD;
	 }
   return Result;
}
    34bc:	08 95       	ret

000034be <SetDispenser>:
		  }
	      break;
	 }
}

void SetDispenser(char DispType){
    34be:	df 93       	push	r29
    34c0:	cf 93       	push	r28
    34c2:	00 d0       	rcall	.+0      	; 0x34c4 <SetDispenser+0x6>
    34c4:	00 d0       	rcall	.+0      	; 0x34c6 <SetDispenser+0x8>
    34c6:	0f 92       	push	r0
    34c8:	cd b7       	in	r28, 0x3d	; 61
    34ca:	de b7       	in	r29, 0x3e	; 62
    34cc:	98 2f       	mov	r25, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    34ce:	e1 99       	sbic	0x1c, 1	; 28
    34d0:	fe cf       	rjmp	.-4      	; 0x34ce <SetDispenser+0x10>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    34d2:	27 e3       	ldi	r18, 0x37	; 55
    34d4:	31 e0       	ldi	r19, 0x01	; 1
    34d6:	3f bb       	out	0x1f, r19	; 31
    34d8:	2e bb       	out	0x1e, r18	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    34da:	e0 9a       	sbi	0x1c, 0	; 28
    34dc:	8d b3       	in	r24, 0x1d	; 29
     char CurrentDispenser;
	 char i,DecimalSetting[5];
     CurrentDispenser=eeprom_read_byte(&DefDispenserBrand);
	 if (CurrentDispenser!=DispType){
    34de:	89 17       	cp	r24, r25
    34e0:	51 f0       	breq	.+20     	; 0x34f6 <SetDispenser+0x38>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    34e2:	e1 99       	sbic	0x1c, 1	; 28
    34e4:	fe cf       	rjmp	.-4      	; 0x34e2 <SetDispenser+0x24>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    34e6:	3f bb       	out	0x1f, r19	; 31
    34e8:	2e bb       	out	0x1e, r18	; 30
#endif
    EEDR = __value;
    34ea:	9d bb       	out	0x1d, r25	; 29

    __asm__ __volatile__ (
    34ec:	0f b6       	in	r0, 0x3f	; 63
    34ee:	f8 94       	cli
    34f0:	e2 9a       	sbi	0x1c, 2	; 28
    34f2:	e1 9a       	sbi	0x1c, 1	; 28
    34f4:	0f be       	out	0x3f, r0	; 63
	     eeprom_write_byte(&DefDispenserBrand,DispType);
	 }
     //Apply Setting for Pump respectively
	 switch(DispType){
    34f6:	91 30       	cpi	r25, 0x01	; 1
    34f8:	19 f0       	breq	.+6      	; 0x3500 <SetDispenser+0x42>
    34fa:	92 30       	cpi	r25, 0x02	; 2
    34fc:	71 f4       	brne	.+28     	; 0x351a <SetDispenser+0x5c>
    34fe:	08 c0       	rjmp	.+16     	; 0x3510 <SetDispenser+0x52>
	 case ST_GILBARCO:
          DecimalSetting[0]=0;//Price
    3500:	19 82       	std	Y+1, r1	; 0x01
		  DecimalSetting[1]=3;//Volume
    3502:	83 e0       	ldi	r24, 0x03	; 3
    3504:	8a 83       	std	Y+2, r24	; 0x02
		  DecimalSetting[2]=0;//Money
    3506:	1b 82       	std	Y+3, r1	; 0x03
		  DecimalSetting[3]=2;//TotalVolume
    3508:	82 e0       	ldi	r24, 0x02	; 2
    350a:	8c 83       	std	Y+4, r24	; 0x04
		  DecimalSetting[4]=0;//TotalMoney 
    350c:	1d 82       	std	Y+5, r1	; 0x05
    350e:	05 c0       	rjmp	.+10     	; 0x351a <SetDispenser+0x5c>
	      break;
	 case ST_WAYNE_DART:
          DecimalSetting[0]=0;//Price
    3510:	19 82       	std	Y+1, r1	; 0x01
		  DecimalSetting[1]=2;//Volume
    3512:	9a 83       	std	Y+2, r25	; 0x02
		  DecimalSetting[2]=0;//Money
    3514:	1b 82       	std	Y+3, r1	; 0x03
		  DecimalSetting[3]=2;//TotalVolume
    3516:	9c 83       	std	Y+4, r25	; 0x04
		  DecimalSetting[4]=2;//TotalMoney 
    3518:	9d 83       	std	Y+5, r25	; 0x05
    351a:	29 e3       	ldi	r18, 0x39	; 57
    351c:	30 e0       	ldi	r19, 0x00	; 0
    351e:	fe 01       	movw	r30, r28
    3520:	31 96       	adiw	r30, 0x01	; 1
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    3522:	e1 99       	sbic	0x1c, 1	; 28
    3524:	fe cf       	rjmp	.-4      	; 0x3522 <SetDispenser+0x64>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3526:	3f bb       	out	0x1f, r19	; 31
    3528:	2e bb       	out	0x1e, r18	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    352a:	e0 9a       	sbi	0x1c, 0	; 28
    352c:	8d b3       	in	r24, 0x1d	; 29
	      break;	 
	 }
	 //ApplyChanges
     for (i=0;i<5;i++){
	     if (eeprom_read_byte(&DefDecimalPrice+i)!=DecimalSetting[i]){
    352e:	90 81       	ld	r25, Z
    3530:	89 17       	cp	r24, r25
    3532:	51 f0       	breq	.+20     	; 0x3548 <SetDispenser+0x8a>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    3534:	e1 99       	sbic	0x1c, 1	; 28
    3536:	fe cf       	rjmp	.-4      	; 0x3534 <SetDispenser+0x76>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3538:	3f bb       	out	0x1f, r19	; 31
    353a:	2e bb       	out	0x1e, r18	; 30
#endif
    EEDR = __value;
    353c:	9d bb       	out	0x1d, r25	; 29

    __asm__ __volatile__ (
    353e:	0f b6       	in	r0, 0x3f	; 63
    3540:	f8 94       	cli
    3542:	e2 9a       	sbi	0x1c, 2	; 28
    3544:	e1 9a       	sbi	0x1c, 1	; 28
    3546:	0f be       	out	0x3f, r0	; 63
    3548:	2f 5f       	subi	r18, 0xFF	; 255
    354a:	3f 4f       	sbci	r19, 0xFF	; 255
    354c:	31 96       	adiw	r30, 0x01	; 1
		  DecimalSetting[3]=2;//TotalVolume
		  DecimalSetting[4]=2;//TotalMoney 
	      break;	 
	 }
	 //ApplyChanges
     for (i=0;i<5;i++){
    354e:	80 e0       	ldi	r24, 0x00	; 0
    3550:	2e 33       	cpi	r18, 0x3E	; 62
    3552:	38 07       	cpc	r19, r24
    3554:	31 f7       	brne	.-52     	; 0x3522 <SetDispenser+0x64>
	     if (eeprom_read_byte(&DefDecimalPrice+i)!=DecimalSetting[i]){
		     eeprom_write_byte(&DefDecimalPrice+i,DecimalSetting[i]);
		 }
	 }
}
    3556:	0f 90       	pop	r0
    3558:	0f 90       	pop	r0
    355a:	0f 90       	pop	r0
    355c:	0f 90       	pop	r0
    355e:	0f 90       	pop	r0
    3560:	cf 91       	pop	r28
    3562:	df 91       	pop	r29
    3564:	08 95       	ret

00003566 <ComposeDatetime>:
	}
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalTotalMoney),2,Result);
}


void ComposeDatetime(char *Result){// 2010/10/01 16:27:44
    3566:	df 93       	push	r29
    3568:	cf 93       	push	r28
    356a:	cd b7       	in	r28, 0x3d	; 61
    356c:	de b7       	in	r29, 0x3e	; 62
    356e:	62 97       	sbiw	r28, 0x12	; 18
    3570:	0f b6       	in	r0, 0x3f	; 63
    3572:	f8 94       	cli
    3574:	de bf       	out	0x3e, r29	; 62
    3576:	0f be       	out	0x3f, r0	; 63
    3578:	cd bf       	out	0x3d, r28	; 61
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    357a:	20 91 c9 04 	lds	r18, 0x04C9
    357e:	2f 83       	std	Y+7, r18	; 0x07
    3580:	20 91 ca 04 	lds	r18, 0x04CA
    3584:	28 87       	std	Y+8, r18	; 0x08
	 }Dest[Length]=0;
    3586:	20 91 cc 04 	lds	r18, 0x04CC
    358a:	2c 83       	std	Y+4, r18	; 0x04
    358c:	20 91 cd 04 	lds	r18, 0x04CD
    3590:	2d 83       	std	Y+5, r18	; 0x05
    3592:	20 91 cf 04 	lds	r18, 0x04CF
    3596:	29 83       	std	Y+1, r18	; 0x01
    3598:	20 91 d0 04 	lds	r18, 0x04D0
    359c:	2a 83       	std	Y+2, r18	; 0x02
    359e:	20 91 a8 09 	lds	r18, 0x09A8
    35a2:	2a 87       	std	Y+10, r18	; 0x0a
    35a4:	20 91 a9 09 	lds	r18, 0x09A9
    35a8:	2b 87       	std	Y+11, r18	; 0x0b
    35aa:	20 91 ab 09 	lds	r18, 0x09AB
    35ae:	2d 87       	std	Y+13, r18	; 0x0d
    35b0:	20 91 ac 09 	lds	r18, 0x09AC
    35b4:	2e 87       	std	Y+14, r18	; 0x0e
    35b6:	20 91 ae 09 	lds	r18, 0x09AE
    35ba:	28 8b       	std	Y+16, r18	; 0x10
    35bc:	20 91 af 09 	lds	r18, 0x09AF
    35c0:	29 8b       	std	Y+17, r18	; 0x11
    35c2:	1a 8a       	std	Y+18, r1	; 0x12
    35c4:	1f 86       	std	Y+15, r1	; 0x0f
    35c6:	1c 86       	std	Y+12, r1	; 0x0c
    35c8:	1b 82       	std	Y+3, r1	; 0x03
    35ca:	1e 82       	std	Y+6, r1	; 0x06
    35cc:	19 86       	std	Y+9, r1	; 0x09
     StrPosCopy(strSystemDate,sYear,6,2);

     StrPosCopy(strSystemTime,sHour,0,2);
     StrPosCopy(strSystemTime,sMinute,3,2);
     StrPosCopy(strSystemTime,sSecond,6,2);
	 sprintf_P(Result,PSTR("20%s/%s/%s %s:%s:%s"),sYear,sMonth,sDay,sHour,sMinute,sSecond);
    35ce:	2d b7       	in	r18, 0x3d	; 61
    35d0:	3e b7       	in	r19, 0x3e	; 62
    35d2:	20 51       	subi	r18, 0x10	; 16
    35d4:	30 40       	sbci	r19, 0x00	; 0
    35d6:	0f b6       	in	r0, 0x3f	; 63
    35d8:	f8 94       	cli
    35da:	3e bf       	out	0x3e, r19	; 62
    35dc:	0f be       	out	0x3f, r0	; 63
    35de:	2d bf       	out	0x3d, r18	; 61
    35e0:	ed b7       	in	r30, 0x3d	; 61
    35e2:	fe b7       	in	r31, 0x3e	; 62
    35e4:	31 96       	adiw	r30, 0x01	; 1
    35e6:	ad b7       	in	r26, 0x3d	; 61
    35e8:	be b7       	in	r27, 0x3e	; 62
    35ea:	12 96       	adiw	r26, 0x02	; 2
    35ec:	9c 93       	st	X, r25
    35ee:	8e 93       	st	-X, r24
    35f0:	11 97       	sbiw	r26, 0x01	; 1
    35f2:	80 e2       	ldi	r24, 0x20	; 32
    35f4:	93 e0       	ldi	r25, 0x03	; 3
    35f6:	93 83       	std	Z+3, r25	; 0x03
    35f8:	82 83       	std	Z+2, r24	; 0x02
    35fa:	ce 01       	movw	r24, r28
    35fc:	01 96       	adiw	r24, 0x01	; 1
    35fe:	95 83       	std	Z+5, r25	; 0x05
    3600:	84 83       	std	Z+4, r24	; 0x04
    3602:	ce 01       	movw	r24, r28
    3604:	04 96       	adiw	r24, 0x04	; 4
    3606:	97 83       	std	Z+7, r25	; 0x07
    3608:	86 83       	std	Z+6, r24	; 0x06
    360a:	ce 01       	movw	r24, r28
    360c:	07 96       	adiw	r24, 0x07	; 7
    360e:	91 87       	std	Z+9, r25	; 0x09
    3610:	80 87       	std	Z+8, r24	; 0x08
    3612:	ce 01       	movw	r24, r28
    3614:	0a 96       	adiw	r24, 0x0a	; 10
    3616:	93 87       	std	Z+11, r25	; 0x0b
    3618:	82 87       	std	Z+10, r24	; 0x0a
    361a:	ce 01       	movw	r24, r28
    361c:	0d 96       	adiw	r24, 0x0d	; 13
    361e:	95 87       	std	Z+13, r25	; 0x0d
    3620:	84 87       	std	Z+12, r24	; 0x0c
    3622:	ce 01       	movw	r24, r28
    3624:	40 96       	adiw	r24, 0x10	; 16
    3626:	97 87       	std	Z+15, r25	; 0x0f
    3628:	86 87       	std	Z+14, r24	; 0x0e
    362a:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    362e:	2d b7       	in	r18, 0x3d	; 61
    3630:	3e b7       	in	r19, 0x3e	; 62
    3632:	20 5f       	subi	r18, 0xF0	; 240
    3634:	3f 4f       	sbci	r19, 0xFF	; 255
    3636:	0f b6       	in	r0, 0x3f	; 63
    3638:	f8 94       	cli
    363a:	3e bf       	out	0x3e, r19	; 62
    363c:	0f be       	out	0x3f, r0	; 63
    363e:	2d bf       	out	0x3d, r18	; 61
}
    3640:	62 96       	adiw	r28, 0x12	; 18
    3642:	0f b6       	in	r0, 0x3f	; 63
    3644:	f8 94       	cli
    3646:	de bf       	out	0x3e, r29	; 62
    3648:	0f be       	out	0x3f, r0	; 63
    364a:	cd bf       	out	0x3d, r28	; 61
    364c:	cf 91       	pop	r28
    364e:	df 91       	pop	r29
    3650:	08 95       	ret

00003652 <leadingZero>:
	     }String[Size]=0;
	 }
}

void leadingZero(char Val,char *StrResult){
     sprintf_P(StrResult,PSTR("%.2d"),Val);
    3652:	00 d0       	rcall	.+0      	; 0x3654 <leadingZero+0x2>
    3654:	00 d0       	rcall	.+0      	; 0x3656 <leadingZero+0x4>
    3656:	00 d0       	rcall	.+0      	; 0x3658 <leadingZero+0x6>
    3658:	ed b7       	in	r30, 0x3d	; 61
    365a:	fe b7       	in	r31, 0x3e	; 62
    365c:	31 96       	adiw	r30, 0x01	; 1
    365e:	ad b7       	in	r26, 0x3d	; 61
    3660:	be b7       	in	r27, 0x3e	; 62
    3662:	12 96       	adiw	r26, 0x02	; 2
    3664:	7c 93       	st	X, r23
    3666:	6e 93       	st	-X, r22
    3668:	11 97       	sbiw	r26, 0x01	; 1
    366a:	24 e8       	ldi	r18, 0x84	; 132
    366c:	3d e0       	ldi	r19, 0x0D	; 13
    366e:	33 83       	std	Z+3, r19	; 0x03
    3670:	22 83       	std	Z+2, r18	; 0x02
    3672:	84 83       	std	Z+4, r24	; 0x04
    3674:	15 82       	std	Z+5, r1	; 0x05
    3676:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    367a:	8d b7       	in	r24, 0x3d	; 61
    367c:	9e b7       	in	r25, 0x3e	; 62
    367e:	06 96       	adiw	r24, 0x06	; 6
    3680:	0f b6       	in	r0, 0x3f	; 63
    3682:	f8 94       	cli
    3684:	9e bf       	out	0x3e, r25	; 62
    3686:	0f be       	out	0x3f, r0	; 63
    3688:	8d bf       	out	0x3d, r24	; 61

}
    368a:	08 95       	ret

0000368c <UpdateSeqNum>:
	 sprintf_P(strIFT_ID,PSTR("%.2d"),IdIFT);
	 //leadingZero(IdIFT,strIFT_ID);
}

void UpdateSeqNum(){
     if (SeqNum<100)SeqNum++;
    368c:	80 91 bc 01 	lds	r24, 0x01BC
    3690:	84 36       	cpi	r24, 0x64	; 100
    3692:	20 f4       	brcc	.+8      	; 0x369c <UpdateSeqNum+0x10>
    3694:	8f 5f       	subi	r24, 0xFF	; 255
    3696:	80 93 bc 01 	sts	0x01BC, r24
    369a:	02 c0       	rjmp	.+4      	; 0x36a0 <UpdateSeqNum+0x14>
	 else SeqNum=0;
    369c:	10 92 bc 01 	sts	0x01BC, r1
	     }String[Size]=0;
	 }
}

void leadingZero(char Val,char *StrResult){
     sprintf_P(StrResult,PSTR("%.2d"),Val);
    36a0:	00 d0       	rcall	.+0      	; 0x36a2 <UpdateSeqNum+0x16>
    36a2:	00 d0       	rcall	.+0      	; 0x36a4 <UpdateSeqNum+0x18>
    36a4:	00 d0       	rcall	.+0      	; 0x36a6 <UpdateSeqNum+0x1a>
    36a6:	ed b7       	in	r30, 0x3d	; 61
    36a8:	fe b7       	in	r31, 0x3e	; 62
    36aa:	31 96       	adiw	r30, 0x01	; 1
    36ac:	87 e0       	ldi	r24, 0x07	; 7
    36ae:	9d e0       	ldi	r25, 0x0D	; 13
    36b0:	ad b7       	in	r26, 0x3d	; 61
    36b2:	be b7       	in	r27, 0x3e	; 62
    36b4:	12 96       	adiw	r26, 0x02	; 2
    36b6:	9c 93       	st	X, r25
    36b8:	8e 93       	st	-X, r24
    36ba:	11 97       	sbiw	r26, 0x01	; 1
    36bc:	84 e8       	ldi	r24, 0x84	; 132
    36be:	9d e0       	ldi	r25, 0x0D	; 13
    36c0:	93 83       	std	Z+3, r25	; 0x03
    36c2:	82 83       	std	Z+2, r24	; 0x02
    36c4:	80 91 bc 01 	lds	r24, 0x01BC
    36c8:	84 83       	std	Z+4, r24	; 0x04
    36ca:	15 82       	std	Z+5, r1	; 0x05
    36cc:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    36d0:	8d b7       	in	r24, 0x3d	; 61
    36d2:	9e b7       	in	r25, 0x3e	; 62
    36d4:	06 96       	adiw	r24, 0x06	; 6
    36d6:	0f b6       	in	r0, 0x3f	; 63
    36d8:	f8 94       	cli
    36da:	9e bf       	out	0x3e, r25	; 62
    36dc:	0f be       	out	0x3f, r0	; 63
    36de:	8d bf       	out	0x3d, r24	; 61

void UpdateSeqNum(){
     if (SeqNum<100)SeqNum++;
	 else SeqNum=0;
	 leadingZero(SeqNum,strSeqNum);
} 
    36e0:	08 95       	ret

000036e2 <UpdateIFT_ID>:
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    36e2:	e1 99       	sbic	0x1c, 1	; 28
    36e4:	fe cf       	rjmp	.-4      	; 0x36e2 <UpdateIFT_ID>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    36e6:	80 e0       	ldi	r24, 0x00	; 0
    36e8:	90 e0       	ldi	r25, 0x00	; 0
    36ea:	9f bb       	out	0x1f, r25	; 31
    36ec:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    36ee:	e0 9a       	sbi	0x1c, 0	; 28
    36f0:	8d b3       	in	r24, 0x1d	; 29

void UpdateIFT_ID(){
     char IdIFT;
     //sprintf_P(strIFT_ID,PSTR("%.2d"),eeprom_read_byte(&DefIFT_ID));
	 IdIFT=(eeprom_read_byte(&DefIFT_ID)%100);
	 sprintf_P(strIFT_ID,PSTR("%.2d"),IdIFT);
    36f2:	00 d0       	rcall	.+0      	; 0x36f4 <UpdateIFT_ID+0x12>
    36f4:	00 d0       	rcall	.+0      	; 0x36f6 <UpdateIFT_ID+0x14>
    36f6:	00 d0       	rcall	.+0      	; 0x36f8 <UpdateIFT_ID+0x16>
    36f8:	ed b7       	in	r30, 0x3d	; 61
    36fa:	fe b7       	in	r31, 0x3e	; 62
    36fc:	31 96       	adiw	r30, 0x01	; 1
    36fe:	2b ef       	ldi	r18, 0xFB	; 251
    3700:	34 e0       	ldi	r19, 0x04	; 4
    3702:	ad b7       	in	r26, 0x3d	; 61
    3704:	be b7       	in	r27, 0x3e	; 62
    3706:	12 96       	adiw	r26, 0x02	; 2
    3708:	3c 93       	st	X, r19
    370a:	2e 93       	st	-X, r18
    370c:	11 97       	sbiw	r26, 0x01	; 1
    370e:	23 ed       	ldi	r18, 0xD3	; 211
    3710:	30 e2       	ldi	r19, 0x20	; 32
    3712:	33 83       	std	Z+3, r19	; 0x03
    3714:	22 83       	std	Z+2, r18	; 0x02
    3716:	64 e6       	ldi	r22, 0x64	; 100
    3718:	0e 94 f1 b6 	call	0x16de2	; 0x16de2 <__udivmodqi4>
    371c:	94 83       	std	Z+4, r25	; 0x04
    371e:	15 82       	std	Z+5, r1	; 0x05
    3720:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    3724:	8d b7       	in	r24, 0x3d	; 61
    3726:	9e b7       	in	r25, 0x3e	; 62
    3728:	06 96       	adiw	r24, 0x06	; 6
    372a:	0f b6       	in	r0, 0x3f	; 63
    372c:	f8 94       	cli
    372e:	9e bf       	out	0x3e, r25	; 62
    3730:	0f be       	out	0x3f, r0	; 63
    3732:	8d bf       	out	0x3d, r24	; 61
	 //leadingZero(IdIFT,strIFT_ID);
}
    3734:	08 95       	ret

00003736 <MasterReset>:
	 }
}

#define DEF_OPERATOR_NAME "Mr.Big"

void MasterReset(){
    3736:	df 92       	push	r13
    3738:	ef 92       	push	r14
    373a:	ff 92       	push	r15
    373c:	0f 93       	push	r16
    373e:	1f 93       	push	r17
    3740:	df 93       	push	r29
    3742:	cf 93       	push	r28
    3744:	cd b7       	in	r28, 0x3d	; 61
    3746:	de b7       	in	r29, 0x3e	; 62
    3748:	ec 97       	sbiw	r28, 0x3c	; 60
    374a:	0f b6       	in	r0, 0x3f	; 63
    374c:	f8 94       	cli
    374e:	de bf       	out	0x3e, r29	; 62
    3750:	0f be       	out	0x3f, r0	; 63
    3752:	cd bf       	out	0x3d, r28	; 61
     char strEEP[50];
	 char xArray[10];
     //Restore All Stored EEPROM data to the Default
     sprintf_P(strEEP,PSTR(DEF_OPERATOR_NAME));
    3754:	00 d0       	rcall	.+0      	; 0x3756 <MasterReset+0x20>
    3756:	00 d0       	rcall	.+0      	; 0x3758 <MasterReset+0x22>
    3758:	8e 01       	movw	r16, r28
    375a:	05 5f       	subi	r16, 0xF5	; 245
    375c:	1f 4f       	sbci	r17, 0xFF	; 255
    375e:	ed b7       	in	r30, 0x3d	; 61
    3760:	fe b7       	in	r31, 0x3e	; 62
    3762:	12 83       	std	Z+2, r17	; 0x02
    3764:	01 83       	std	Z+1, r16	; 0x01
    3766:	8f ef       	ldi	r24, 0xFF	; 255
    3768:	92 e0       	ldi	r25, 0x02	; 2
    376a:	94 83       	std	Z+4, r25	; 0x04
    376c:	83 83       	std	Z+3, r24	; 0x03
    376e:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    3772:	0f 90       	pop	r0
    3774:	0f 90       	pop	r0
    3776:	0f 90       	pop	r0
    3778:	0f 90       	pop	r0
    377a:	85 e1       	ldi	r24, 0x15	; 21
    377c:	90 e0       	ldi	r25, 0x00	; 0
    377e:	b8 01       	movw	r22, r16
    3780:	43 e1       	ldi	r20, 0x13	; 19
    3782:	50 e0       	ldi	r21, 0x00	; 0
    3784:	25 e0       	ldi	r18, 0x05	; 5
    3786:	33 e1       	ldi	r19, 0x13	; 19
    3788:	0e 94 0d b4 	call	0x1681a	; 0x1681a <__eewr_block>
	 eeprom_write_block((const void*)&strEEP, (void*) &DefOperatorName, sizeof(DefOperatorName));

	 xArray[0]=192;	 xArray[1]=168; 	 xArray[2]=16;	 xArray[3]=70; 
    378c:	40 ec       	ldi	r20, 0xC0	; 192
    378e:	d4 2e       	mov	r13, r20
    3790:	d9 82       	std	Y+1, r13	; 0x01
    3792:	38 ea       	ldi	r19, 0xA8	; 168
    3794:	e3 2e       	mov	r14, r19
    3796:	ea 82       	std	Y+2, r14	; 0x02
    3798:	20 e1       	ldi	r18, 0x10	; 16
    379a:	f2 2e       	mov	r15, r18
    379c:	fb 82       	std	Y+3, r15	; 0x03
    379e:	86 e4       	ldi	r24, 0x46	; 70
    37a0:	8c 83       	std	Y+4, r24	; 0x04
    37a2:	88 e2       	ldi	r24, 0x28	; 40
    37a4:	90 e0       	ldi	r25, 0x00	; 0
    37a6:	8e 01       	movw	r16, r28
    37a8:	0f 5f       	subi	r16, 0xFF	; 255
    37aa:	1f 4f       	sbci	r17, 0xFF	; 255
    37ac:	b8 01       	movw	r22, r16
    37ae:	44 e0       	ldi	r20, 0x04	; 4
    37b0:	50 e0       	ldi	r21, 0x00	; 0
    37b2:	25 e0       	ldi	r18, 0x05	; 5
    37b4:	33 e1       	ldi	r19, 0x13	; 19
    37b6:	0e 94 0d b4 	call	0x1681a	; 0x1681a <__eewr_block>
	 eeprom_write_block((const void*) &xArray, (void*) &DefClientIP, 4);

	 xArray[0]=192;	 xArray[1]=168; 	 xArray[2]=16;	 xArray[3]=180; 
    37ba:	d9 82       	std	Y+1, r13	; 0x01
    37bc:	ea 82       	std	Y+2, r14	; 0x02
    37be:	fb 82       	std	Y+3, r15	; 0x03
    37c0:	84 eb       	ldi	r24, 0xB4	; 180
    37c2:	8c 83       	std	Y+4, r24	; 0x04
    37c4:	8c e2       	ldi	r24, 0x2C	; 44
    37c6:	90 e0       	ldi	r25, 0x00	; 0
    37c8:	b8 01       	movw	r22, r16
    37ca:	44 e0       	ldi	r20, 0x04	; 4
    37cc:	50 e0       	ldi	r21, 0x00	; 0
    37ce:	25 e0       	ldi	r18, 0x05	; 5
    37d0:	33 e1       	ldi	r19, 0x13	; 19
    37d2:	0e 94 0d b4 	call	0x1681a	; 0x1681a <__eewr_block>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    37d6:	e1 99       	sbic	0x1c, 1	; 28
    37d8:	fe cf       	rjmp	.-4      	; 0x37d6 <MasterReset+0xa0>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    37da:	80 e3       	ldi	r24, 0x30	; 48
    37dc:	90 e0       	ldi	r25, 0x00	; 0
    37de:	9f bb       	out	0x1f, r25	; 31
    37e0:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    37e2:	81 e0       	ldi	r24, 0x01	; 1
    37e4:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    37e6:	0f b6       	in	r0, 0x3f	; 63
    37e8:	f8 94       	cli
    37ea:	e2 9a       	sbi	0x1c, 2	; 28
    37ec:	e1 9a       	sbi	0x1c, 1	; 28
    37ee:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    37f0:	e1 99       	sbic	0x1c, 1	; 28
    37f2:	fe cf       	rjmp	.-4      	; 0x37f0 <MasterReset+0xba>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    37f4:	81 e3       	ldi	r24, 0x31	; 49
    37f6:	90 e0       	ldi	r25, 0x00	; 0
    37f8:	9f bb       	out	0x1f, r25	; 31
    37fa:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    37fc:	87 e0       	ldi	r24, 0x07	; 7
    37fe:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    3800:	0f b6       	in	r0, 0x3f	; 63
    3802:	f8 94       	cli
    3804:	e2 9a       	sbi	0x1c, 2	; 28
    3806:	e1 9a       	sbi	0x1c, 1	; 28
    3808:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    380a:	e1 99       	sbic	0x1c, 1	; 28
    380c:	fe cf       	rjmp	.-4      	; 0x380a <MasterReset+0xd4>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    380e:	82 e3       	ldi	r24, 0x32	; 50
    3810:	90 e0       	ldi	r25, 0x00	; 0
    3812:	9f bb       	out	0x1f, r25	; 31
    3814:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    3816:	85 e0       	ldi	r24, 0x05	; 5
    3818:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    381a:	0f b6       	in	r0, 0x3f	; 63
    381c:	f8 94       	cli
    381e:	e2 9a       	sbi	0x1c, 2	; 28
    3820:	e1 9a       	sbi	0x1c, 1	; 28
    3822:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    3824:	e1 99       	sbic	0x1c, 1	; 28
    3826:	fe cf       	rjmp	.-4      	; 0x3824 <MasterReset+0xee>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3828:	83 e3       	ldi	r24, 0x33	; 51
    382a:	90 e0       	ldi	r25, 0x00	; 0
    382c:	9f bb       	out	0x1f, r25	; 31
    382e:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    3830:	82 e0       	ldi	r24, 0x02	; 2
    3832:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    3834:	0f b6       	in	r0, 0x3f	; 63
    3836:	f8 94       	cli
    3838:	e2 9a       	sbi	0x1c, 2	; 28
    383a:	e1 9a       	sbi	0x1c, 1	; 28
    383c:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    383e:	e1 99       	sbic	0x1c, 1	; 28
    3840:	fe cf       	rjmp	.-4      	; 0x383e <MasterReset+0x108>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3842:	84 e3       	ldi	r24, 0x34	; 52
    3844:	90 e0       	ldi	r25, 0x00	; 0
    3846:	9f bb       	out	0x1f, r25	; 31
    3848:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    384a:	1d ba       	out	0x1d, r1	; 29

    __asm__ __volatile__ (
    384c:	0f b6       	in	r0, 0x3f	; 63
    384e:	f8 94       	cli
    3850:	e2 9a       	sbi	0x1c, 2	; 28
    3852:	e1 9a       	sbi	0x1c, 1	; 28
    3854:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    3856:	e1 99       	sbic	0x1c, 1	; 28
    3858:	fe cf       	rjmp	.-4      	; 0x3856 <MasterReset+0x120>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    385a:	85 e3       	ldi	r24, 0x35	; 53
    385c:	90 e0       	ldi	r25, 0x00	; 0
    385e:	9f bb       	out	0x1f, r25	; 31
    3860:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    3862:	83 e0       	ldi	r24, 0x03	; 3
    3864:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    3866:	0f b6       	in	r0, 0x3f	; 63
    3868:	f8 94       	cli
    386a:	e2 9a       	sbi	0x1c, 2	; 28
    386c:	e1 9a       	sbi	0x1c, 1	; 28
    386e:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    3870:	e1 99       	sbic	0x1c, 1	; 28
    3872:	fe cf       	rjmp	.-4      	; 0x3870 <MasterReset+0x13a>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3874:	86 e3       	ldi	r24, 0x36	; 54
    3876:	90 e0       	ldi	r25, 0x00	; 0
    3878:	9f bb       	out	0x1f, r25	; 31
    387a:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    387c:	1d ba       	out	0x1d, r1	; 29

    __asm__ __volatile__ (
    387e:	0f b6       	in	r0, 0x3f	; 63
    3880:	f8 94       	cli
    3882:	e2 9a       	sbi	0x1c, 2	; 28
    3884:	e1 9a       	sbi	0x1c, 1	; 28
    3886:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    3888:	e1 99       	sbic	0x1c, 1	; 28
    388a:	fe cf       	rjmp	.-4      	; 0x3888 <MasterReset+0x152>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    388c:	87 e3       	ldi	r24, 0x37	; 55
    388e:	90 e0       	ldi	r25, 0x00	; 0
    3890:	9f bb       	out	0x1f, r25	; 31
    3892:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    3894:	81 e0       	ldi	r24, 0x01	; 1
    3896:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    3898:	0f b6       	in	r0, 0x3f	; 63
    389a:	f8 94       	cli
    389c:	e2 9a       	sbi	0x1c, 2	; 28
    389e:	e1 9a       	sbi	0x1c, 1	; 28
    38a0:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    38a2:	e1 99       	sbic	0x1c, 1	; 28
    38a4:	fe cf       	rjmp	.-4      	; 0x38a2 <MasterReset+0x16c>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    38a6:	88 e3       	ldi	r24, 0x38	; 56
    38a8:	90 e0       	ldi	r25, 0x00	; 0
    38aa:	9f bb       	out	0x1f, r25	; 31
    38ac:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    38ae:	81 e0       	ldi	r24, 0x01	; 1
    38b0:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    38b2:	0f b6       	in	r0, 0x3f	; 63
    38b4:	f8 94       	cli
    38b6:	e2 9a       	sbi	0x1c, 2	; 28
    38b8:	e1 9a       	sbi	0x1c, 1	; 28
    38ba:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    38bc:	e1 99       	sbic	0x1c, 1	; 28
    38be:	fe cf       	rjmp	.-4      	; 0x38bc <MasterReset+0x186>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    38c0:	89 e3       	ldi	r24, 0x39	; 57
    38c2:	90 e0       	ldi	r25, 0x00	; 0
    38c4:	9f bb       	out	0x1f, r25	; 31
    38c6:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    38c8:	1d ba       	out	0x1d, r1	; 29

    __asm__ __volatile__ (
    38ca:	0f b6       	in	r0, 0x3f	; 63
    38cc:	f8 94       	cli
    38ce:	e2 9a       	sbi	0x1c, 2	; 28
    38d0:	e1 9a       	sbi	0x1c, 1	; 28
    38d2:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    38d4:	e1 99       	sbic	0x1c, 1	; 28
    38d6:	fe cf       	rjmp	.-4      	; 0x38d4 <MasterReset+0x19e>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    38d8:	8a e3       	ldi	r24, 0x3A	; 58
    38da:	90 e0       	ldi	r25, 0x00	; 0
    38dc:	9f bb       	out	0x1f, r25	; 31
    38de:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    38e0:	83 e0       	ldi	r24, 0x03	; 3
    38e2:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    38e4:	0f b6       	in	r0, 0x3f	; 63
    38e6:	f8 94       	cli
    38e8:	e2 9a       	sbi	0x1c, 2	; 28
    38ea:	e1 9a       	sbi	0x1c, 1	; 28
    38ec:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    38ee:	e1 99       	sbic	0x1c, 1	; 28
    38f0:	fe cf       	rjmp	.-4      	; 0x38ee <MasterReset+0x1b8>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    38f2:	8b e3       	ldi	r24, 0x3B	; 59
    38f4:	90 e0       	ldi	r25, 0x00	; 0
    38f6:	9f bb       	out	0x1f, r25	; 31
    38f8:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    38fa:	1d ba       	out	0x1d, r1	; 29

    __asm__ __volatile__ (
    38fc:	0f b6       	in	r0, 0x3f	; 63
    38fe:	f8 94       	cli
    3900:	e2 9a       	sbi	0x1c, 2	; 28
    3902:	e1 9a       	sbi	0x1c, 1	; 28
    3904:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    3906:	e1 99       	sbic	0x1c, 1	; 28
    3908:	fe cf       	rjmp	.-4      	; 0x3906 <MasterReset+0x1d0>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    390a:	8c e3       	ldi	r24, 0x3C	; 60
    390c:	90 e0       	ldi	r25, 0x00	; 0
    390e:	9f bb       	out	0x1f, r25	; 31
    3910:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    3912:	82 e0       	ldi	r24, 0x02	; 2
    3914:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    3916:	0f b6       	in	r0, 0x3f	; 63
    3918:	f8 94       	cli
    391a:	e2 9a       	sbi	0x1c, 2	; 28
    391c:	e1 9a       	sbi	0x1c, 1	; 28
    391e:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    3920:	e1 99       	sbic	0x1c, 1	; 28
    3922:	fe cf       	rjmp	.-4      	; 0x3920 <MasterReset+0x1ea>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3924:	8d e3       	ldi	r24, 0x3D	; 61
    3926:	90 e0       	ldi	r25, 0x00	; 0
    3928:	9f bb       	out	0x1f, r25	; 31
    392a:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    392c:	1d ba       	out	0x1d, r1	; 29

    __asm__ __volatile__ (
    392e:	0f b6       	in	r0, 0x3f	; 63
    3930:	f8 94       	cli
    3932:	e2 9a       	sbi	0x1c, 2	; 28
    3934:	e1 9a       	sbi	0x1c, 1	; 28
    3936:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    3938:	e1 99       	sbic	0x1c, 1	; 28
    393a:	fe cf       	rjmp	.-4      	; 0x3938 <MasterReset+0x202>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    393c:	8e e3       	ldi	r24, 0x3E	; 62
    393e:	90 e0       	ldi	r25, 0x00	; 0
    3940:	9f bb       	out	0x1f, r25	; 31
    3942:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    3944:	8c e2       	ldi	r24, 0x2C	; 44
    3946:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    3948:	0f b6       	in	r0, 0x3f	; 63
    394a:	f8 94       	cli
    394c:	e2 9a       	sbi	0x1c, 2	; 28
    394e:	e1 9a       	sbi	0x1c, 1	; 28
    3950:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    3952:	e1 99       	sbic	0x1c, 1	; 28
    3954:	fe cf       	rjmp	.-4      	; 0x3952 <MasterReset+0x21c>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3956:	8f e3       	ldi	r24, 0x3F	; 63
    3958:	90 e0       	ldi	r25, 0x00	; 0
    395a:	9f bb       	out	0x1f, r25	; 31
    395c:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    395e:	9e e2       	ldi	r25, 0x2E	; 46
    3960:	9d bb       	out	0x1d, r25	; 29

    __asm__ __volatile__ (
    3962:	0f b6       	in	r0, 0x3f	; 63
    3964:	f8 94       	cli
    3966:	e2 9a       	sbi	0x1c, 2	; 28
    3968:	e1 9a       	sbi	0x1c, 1	; 28
    396a:	0f be       	out	0x3f, r0	; 63
	 eeprom_write_byte(&DefDecimalTotalVolume,2);
	 eeprom_write_byte(&DefDecimalTotalMoney,0);
	 eeprom_write_byte(&DefDecimalMark,',');
	 eeprom_write_byte(&DefCurrencyMark,'.');

	 xArray[0]=',';	 xArray[1]='.'; 	 xArray[2]=' ';	 xArray[3]='/';  xArray[4]='-'; 
    396c:	8c e2       	ldi	r24, 0x2C	; 44
    396e:	89 83       	std	Y+1, r24	; 0x01
    3970:	9a 83       	std	Y+2, r25	; 0x02
    3972:	80 e2       	ldi	r24, 0x20	; 32
    3974:	8b 83       	std	Y+3, r24	; 0x03
    3976:	8f e2       	ldi	r24, 0x2F	; 47
    3978:	8c 83       	std	Y+4, r24	; 0x04
    397a:	8d e2       	ldi	r24, 0x2D	; 45
    397c:	8d 83       	std	Y+5, r24	; 0x05
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    397e:	80 e4       	ldi	r24, 0x40	; 64
    3980:	90 e0       	ldi	r25, 0x00	; 0
    3982:	8e 01       	movw	r16, r28
    3984:	0f 5f       	subi	r16, 0xFF	; 255
    3986:	1f 4f       	sbci	r17, 0xFF	; 255
    3988:	b8 01       	movw	r22, r16
    398a:	45 e0       	ldi	r20, 0x05	; 5
    398c:	50 e0       	ldi	r21, 0x00	; 0
    398e:	25 e0       	ldi	r18, 0x05	; 5
    3990:	33 e1       	ldi	r19, 0x13	; 19
    3992:	0e 94 0d b4 	call	0x1681a	; 0x1681a <__eewr_block>
	 eeprom_write_block((const void*) &xArray, (void*) &DefMarkMap, 5);

	 xArray[0]=1;	 xArray[1]=2; 	 xArray[2]=0;	 xArray[3]=0; xArray[4]=0;	 xArray[5]=0; xArray[6]=0;	 	 
    3996:	81 e0       	ldi	r24, 0x01	; 1
    3998:	89 83       	std	Y+1, r24	; 0x01
    399a:	82 e0       	ldi	r24, 0x02	; 2
    399c:	8a 83       	std	Y+2, r24	; 0x02
    399e:	1b 82       	std	Y+3, r1	; 0x03
    39a0:	1c 82       	std	Y+4, r1	; 0x04
    39a2:	1d 82       	std	Y+5, r1	; 0x05
    39a4:	1e 82       	std	Y+6, r1	; 0x06
    39a6:	1f 82       	std	Y+7, r1	; 0x07
    39a8:	85 e4       	ldi	r24, 0x45	; 69
    39aa:	90 e0       	ldi	r25, 0x00	; 0
    39ac:	b8 01       	movw	r22, r16
    39ae:	48 e0       	ldi	r20, 0x08	; 8
    39b0:	50 e0       	ldi	r21, 0x00	; 0
    39b2:	25 e0       	ldi	r18, 0x05	; 5
    39b4:	33 e1       	ldi	r19, 0x13	; 19
    39b6:	0e 94 0d b4 	call	0x1681a	; 0x1681a <__eewr_block>
	 eeprom_write_block((const void*) &xArray, (void*) &DefPumpMap, 8);
	 eeprom_write_block((const void*) &xArray, (void*) &DefPumpLabel, 8);

      

}
    39ba:	8d e4       	ldi	r24, 0x4D	; 77
    39bc:	90 e0       	ldi	r25, 0x00	; 0
    39be:	b8 01       	movw	r22, r16
    39c0:	48 e0       	ldi	r20, 0x08	; 8
    39c2:	50 e0       	ldi	r21, 0x00	; 0
    39c4:	25 e0       	ldi	r18, 0x05	; 5
    39c6:	33 e1       	ldi	r19, 0x13	; 19
    39c8:	0e 94 0d b4 	call	0x1681a	; 0x1681a <__eewr_block>
    39cc:	ec 96       	adiw	r28, 0x3c	; 60
    39ce:	0f b6       	in	r0, 0x3f	; 63
    39d0:	f8 94       	cli
    39d2:	de bf       	out	0x3e, r29	; 62
    39d4:	0f be       	out	0x3f, r0	; 63
    39d6:	cd bf       	out	0x3d, r28	; 61
    39d8:	cf 91       	pop	r28
    39da:	df 91       	pop	r29
    39dc:	1f 91       	pop	r17
    39de:	0f 91       	pop	r16
    39e0:	ff 90       	pop	r15
    39e2:	ef 90       	pop	r14
    39e4:	df 90       	pop	r13
    39e6:	08 95       	ret

000039e8 <procMessage21>:
       StrPosCopy(rcv_trans,strFreeMessageLine3,79,20);
       StrPosCopy(rcv_trans,strFreeMessageLine4,99,20);
	 return Result;
}

char procMessage21(){
    39e8:	af 92       	push	r10
    39ea:	bf 92       	push	r11
    39ec:	cf 92       	push	r12
    39ee:	df 92       	push	r13
    39f0:	ef 92       	push	r14
    39f2:	ff 92       	push	r15
    39f4:	0f 93       	push	r16
    39f6:	1f 93       	push	r17
    39f8:	df 93       	push	r29
    39fa:	cf 93       	push	r28
    39fc:	cd b7       	in	r28, 0x3d	; 61
    39fe:	de b7       	in	r29, 0x3e	; 62
    3a00:	2b 97       	sbiw	r28, 0x0b	; 11
    3a02:	0f b6       	in	r0, 0x3f	; 63
    3a04:	f8 94       	cli
    3a06:	de bf       	out	0x3e, r29	; 62
    3a08:	0f be       	out	0x3f, r0	; 63
    3a0a:	cd bf       	out	0x3d, r28	; 61
    3a0c:	09 e0       	ldi	r16, 0x09	; 9
    3a0e:	11 e0       	ldi	r17, 0x01	; 1
    3a10:	66 e7       	ldi	r22, 0x76	; 118
    3a12:	e6 2e       	mov	r14, r22
    3a14:	6a e0       	ldi	r22, 0x0A	; 10
    3a16:	f6 2e       	mov	r15, r22
    3a18:	6e 01       	movw	r12, r28
    3a1a:	08 94       	sec
    3a1c:	c1 1c       	adc	r12, r1
    3a1e:	d1 1c       	adc	r13, r1
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    3a20:	5b e0       	ldi	r21, 0x0B	; 11
    3a22:	a5 2e       	mov	r10, r21
    3a24:	b1 2c       	mov	r11, r1
    3a26:	ac 0e       	add	r10, r28
    3a28:	bd 1e       	adc	r11, r29
       StrPosCopy(rcv_trans,strFreeMessageLine3,79,20);
       StrPosCopy(rcv_trans,strFreeMessageLine4,99,20);
	 return Result;
}

char procMessage21(){
    3a2a:	f6 01       	movw	r30, r12
    3a2c:	d7 01       	movw	r26, r14
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    3a2e:	8d 91       	ld	r24, X+
    3a30:	81 93       	st	Z+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    3a32:	ea 15       	cp	r30, r10
    3a34:	fb 05       	cpc	r31, r11
    3a36:	d9 f7       	brne	.-10     	; 0x3a2e <procMessage21+0x46>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    3a38:	1b 86       	std	Y+11, r1	; 0x0b
    3a3a:	c8 01       	movw	r24, r16
    3a3c:	b6 01       	movw	r22, r12
    3a3e:	4b e0       	ldi	r20, 0x0B	; 11
    3a40:	50 e0       	ldi	r21, 0x00	; 0
    3a42:	25 e0       	ldi	r18, 0x05	; 5
    3a44:	33 e1       	ldi	r19, 0x13	; 19
    3a46:	0e 94 0d b4 	call	0x1681a	; 0x1681a <__eewr_block>
    3a4a:	05 5f       	subi	r16, 0xF5	; 245
    3a4c:	1f 4f       	sbci	r17, 0xFF	; 255
    3a4e:	8a e0       	ldi	r24, 0x0A	; 10
    3a50:	90 e0       	ldi	r25, 0x00	; 0
    3a52:	e8 0e       	add	r14, r24
    3a54:	f9 1e       	adc	r15, r25
}

char procMessage21(){
     char i,Result,strBankName[11];
	 Result=0;
	 for(i=0;i<4;i++){
    3a56:	91 e0       	ldi	r25, 0x01	; 1
    3a58:	05 33       	cpi	r16, 0x35	; 53
    3a5a:	19 07       	cpc	r17, r25
    3a5c:	31 f7       	brne	.-52     	; 0x3a2a <procMessage21+0x42>
         StrPosCopy(rcv_trans,strBankName,(37+(i*10)),10);
		 //Result=((Result<<1)|SaveToEEPROM(strBankName,DefBankName[i],11)); 
		 eeprom_write_block((const void*)&strBankName, (void*)&DefBankName[i], 11);
	 }
	 return Result;
}
    3a5e:	80 e0       	ldi	r24, 0x00	; 0
    3a60:	2b 96       	adiw	r28, 0x0b	; 11
    3a62:	0f b6       	in	r0, 0x3f	; 63
    3a64:	f8 94       	cli
    3a66:	de bf       	out	0x3e, r29	; 62
    3a68:	0f be       	out	0x3f, r0	; 63
    3a6a:	cd bf       	out	0x3d, r28	; 61
    3a6c:	cf 91       	pop	r28
    3a6e:	df 91       	pop	r29
    3a70:	1f 91       	pop	r17
    3a72:	0f 91       	pop	r16
    3a74:	ff 90       	pop	r15
    3a76:	ef 90       	pop	r14
    3a78:	df 90       	pop	r13
    3a7a:	cf 90       	pop	r12
    3a7c:	bf 90       	pop	r11
    3a7e:	af 90       	pop	r10
    3a80:	08 95       	ret

00003a82 <GetFIPAddr>:
	    Result=PPumpID[FIPAddr-1];
	 }
   return Result;
}

char GetFIPAddr(char iPumpID){//Find FIP Addr based on PumpID respectively: 
    3a82:	ff 92       	push	r15
    3a84:	0f 93       	push	r16
    3a86:	1f 93       	push	r17
    3a88:	df 93       	push	r29
    3a8a:	cf 93       	push	r28
    3a8c:	cd b7       	in	r28, 0x3d	; 61
    3a8e:	de b7       	in	r29, 0x3e	; 62
    3a90:	28 97       	sbiw	r28, 0x08	; 8
    3a92:	0f b6       	in	r0, 0x3f	; 63
    3a94:	f8 94       	cli
    3a96:	de bf       	out	0x3e, r29	; 62
    3a98:	0f be       	out	0x3f, r0	; 63
    3a9a:	cd bf       	out	0x3d, r28	; 61
    3a9c:	f8 2e       	mov	r15, r24
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    3a9e:	8e 01       	movw	r16, r28
    3aa0:	0f 5f       	subi	r16, 0xFF	; 255
    3aa2:	1f 4f       	sbci	r17, 0xFF	; 255
    3aa4:	c8 01       	movw	r24, r16
    3aa6:	65 e4       	ldi	r22, 0x45	; 69
    3aa8:	70 e0       	ldi	r23, 0x00	; 0
    3aaa:	48 e0       	ldi	r20, 0x08	; 8
    3aac:	50 e0       	ldi	r21, 0x00	; 0
    3aae:	2d ef       	ldi	r18, 0xFD	; 253
    3ab0:	32 e1       	ldi	r19, 0x12	; 18
    3ab2:	0e 94 f1 b3 	call	0x167e2	; 0x167e2 <__eerd_block>
    3ab6:	f8 01       	movw	r30, r16
char i,PPumpID[8],Result;     //FIP1..FIP8
	 Result=0; 
	 eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap,8);
     for(i=0;i<8;i++){
    3ab8:	9e 01       	movw	r18, r28
    3aba:	27 5f       	subi	r18, 0xF7	; 247
    3abc:	3f 4f       	sbci	r19, 0xFF	; 255
    3abe:	9e 2f       	mov	r25, r30
    3ac0:	90 1b       	sub	r25, r16
	     if (PPumpID[i]==iPumpID){
    3ac2:	80 81       	ld	r24, Z
    3ac4:	8f 15       	cp	r24, r15
    3ac6:	19 f4       	brne	.+6      	; 0x3ace <GetFIPAddr+0x4c>
		     Result=i+1;
    3ac8:	89 2f       	mov	r24, r25
    3aca:	8f 5f       	subi	r24, 0xFF	; 255
    3acc:	05 c0       	rjmp	.+10     	; 0x3ad8 <GetFIPAddr+0x56>
			 break;
    3ace:	31 96       	adiw	r30, 0x01	; 1

char GetFIPAddr(char iPumpID){//Find FIP Addr based on PumpID respectively: 
char i,PPumpID[8],Result;     //FIP1..FIP8
	 Result=0; 
	 eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap,8);
     for(i=0;i<8;i++){
    3ad0:	e2 17       	cp	r30, r18
    3ad2:	f3 07       	cpc	r31, r19
    3ad4:	a1 f7       	brne	.-24     	; 0x3abe <GetFIPAddr+0x3c>
    3ad6:	80 e0       	ldi	r24, 0x00	; 0
		     Result=i+1;
			 break;
		 }
	 }
   return Result;
}
    3ad8:	28 96       	adiw	r28, 0x08	; 8
    3ada:	0f b6       	in	r0, 0x3f	; 63
    3adc:	f8 94       	cli
    3ade:	de bf       	out	0x3e, r29	; 62
    3ae0:	0f be       	out	0x3f, r0	; 63
    3ae2:	cd bf       	out	0x3d, r28	; 61
    3ae4:	cf 91       	pop	r28
    3ae6:	df 91       	pop	r29
    3ae8:	1f 91       	pop	r17
    3aea:	0f 91       	pop	r16
    3aec:	ff 90       	pop	r15
    3aee:	08 95       	ret

00003af0 <UpdateStandaloneStatus>:
		 sprintf_P(lcdteks,PSTR("%s"),SPump);
         lcd_print(4,1,lcdteks);
     	 }
}

void UpdateStandaloneStatus(char xPumpID,char xPumpStatus){//xPumpID: (1-16)&0x0F
    3af0:	ff 92       	push	r15
    3af2:	0f 93       	push	r16
    3af4:	1f 93       	push	r17
    3af6:	cf 93       	push	r28
    3af8:	df 93       	push	r29
    3afa:	28 2f       	mov	r18, r24
    3afc:	f6 2e       	mov	r15, r22
char strSend[20],iPumpID; //[xxxxxxxxxPx]
char iAddr;

	 if (xPumpID<16){
    3afe:	80 31       	cpi	r24, 0x10	; 16
    3b00:	08 f0       	brcs	.+2      	; 0x3b04 <UpdateStandaloneStatus+0x14>
    3b02:	4e c0       	rjmp	.+156    	; 0x3ba0 <UpdateStandaloneStatus+0xb0>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    3b04:	e1 99       	sbic	0x1c, 1	; 28
    3b06:	fe cf       	rjmp	.-4      	; 0x3b04 <UpdateStandaloneStatus+0x14>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3b08:	87 e3       	ldi	r24, 0x37	; 55
    3b0a:	91 e0       	ldi	r25, 0x01	; 1
    3b0c:	9f bb       	out	0x1f, r25	; 31
    3b0e:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    3b10:	e0 9a       	sbi	0x1c, 0	; 28
    3b12:	8d b3       	in	r24, 0x1d	; 29
	     DispenserBrand=eeprom_read_byte(&DefDispenserBrand);
    3b14:	80 93 51 01 	sts	0x0151, r24
	     switch(DispenserBrand){
    3b18:	81 50       	subi	r24, 0x01	; 1
    3b1a:	82 30       	cpi	r24, 0x02	; 2
    3b1c:	08 f4       	brcc	.+2      	; 0x3b20 <UpdateStandaloneStatus+0x30>
    3b1e:	82 2f       	mov	r24, r18
	     case ST_WAYNE_DART:
              iPumpID=xPumpID;
	          break;				   
	     }

		 iAddr=GetFIPAddr(iPumpID);
    3b20:	0e 94 41 1d 	call	0x3a82	; 0x3a82 <GetFIPAddr>
		 if (iAddr>0){
    3b24:	88 23       	and	r24, r24
    3b26:	e1 f1       	breq	.+120    	; 0x3ba0 <UpdateStandaloneStatus+0xb0>
		     iAddr=iAddr-1;
			 if (strPumpStatus[iAddr]!=GetPumpStatusLabel(PS_PRINT_READY)){//iFdiiiiiiiiiiiii
    3b28:	81 50       	subi	r24, 0x01	; 1
    3b2a:	c8 2f       	mov	r28, r24
    3b2c:	d0 e0       	ldi	r29, 0x00	; 0
    3b2e:	80 e1       	ldi	r24, 0x10	; 16
    3b30:	0e 94 7d 13 	call	0x26fa	; 0x26fa <GetPumpStatusLabel>
    3b34:	8e 01       	movw	r16, r28
    3b36:	0e 5f       	subi	r16, 0xFE	; 254
    3b38:	1e 4f       	sbci	r17, 0xFE	; 254
    3b3a:	f8 01       	movw	r30, r16
    3b3c:	90 81       	ld	r25, Z
    3b3e:	98 17       	cp	r25, r24
    3b40:	b1 f0       	breq	.+44     	; 0x3b6e <UpdateStandaloneStatus+0x7e>
		         if (xPumpStatus!=PS_PRINT_READY)
    3b42:	f0 e1       	ldi	r31, 0x10	; 16
    3b44:	ff 16       	cp	r15, r31
    3b46:	21 f0       	breq	.+8      	; 0x3b50 <UpdateStandaloneStatus+0x60>
				     CurrentPumpStatus[iAddr]=xPumpStatus;
    3b48:	fe 01       	movw	r30, r28
    3b4a:	ee 5a       	subi	r30, 0xAE	; 174
    3b4c:	fe 4f       	sbci	r31, 0xFE	; 254
    3b4e:	f0 82       	st	Z, r15
			     strPumpStatus[iAddr]=GetPumpStatusLabel(xPumpStatus);
    3b50:	8f 2d       	mov	r24, r15
    3b52:	0e 94 7d 13 	call	0x26fa	; 0x26fa <GetPumpStatusLabel>
    3b56:	8e 01       	movw	r16, r28
    3b58:	0e 5f       	subi	r16, 0xFE	; 254
    3b5a:	1e 4f       	sbci	r17, 0xFE	; 254
    3b5c:	f8 01       	movw	r30, r16
    3b5e:	80 83       	st	Z, r24
                 if (xPumpStatus==PS_FINISH_TOTALIZER)
    3b60:	f5 e1       	ldi	r31, 0x15	; 21
    3b62:	ff 16       	cp	r15, r31
    3b64:	c1 f4       	brne	.+48     	; 0x3b96 <UpdateStandaloneStatus+0xa6>
				     strPumpStatus[iAddr]=GetPumpStatusLabel(CurrentPumpStatus[iAddr]);
    3b66:	ce 5a       	subi	r28, 0xAE	; 174
    3b68:	de 4f       	sbci	r29, 0xFE	; 254
    3b6a:	88 81       	ld	r24, Y
    3b6c:	10 c0       	rjmp	.+32     	; 0x3b8e <UpdateStandaloneStatus+0x9e>
    3b6e:	fe 01       	movw	r30, r28
    3b70:	ee 5a       	subi	r30, 0xAE	; 174
    3b72:	fe 4f       	sbci	r31, 0xFE	; 254
		     }else if ((strPumpStatus[iAddr]==GetPumpStatusLabel(PS_PRINT_READY))||(xPumpStatus==PUMP_FEOT)||(xPumpStatus==PS_PRINTED)||(xPumpStatus==PS_TOTALIZER)){//P
			     if (xPumpStatus==PS_PRINTED){
    3b74:	81 e1       	ldi	r24, 0x11	; 17
    3b76:	f8 16       	cp	r15, r24
    3b78:	11 f4       	brne	.+4      	; 0x3b7e <UpdateStandaloneStatus+0x8e>
				 //New

				     //if (CurrentPumpStatus[iAddr]!=GetPumpStatusLabel(PS_PRINT_READY))
			             strPumpStatus[iAddr]=GetPumpStatusLabel(CurrentPumpStatus[iAddr]);
    3b7a:	80 81       	ld	r24, Z
    3b7c:	08 c0       	rjmp	.+16     	; 0x3b8e <UpdateStandaloneStatus+0x9e>
					 //    CurrentPumpStatus[iAddr]=PUMP_OFF;
					 //    strPumpStatus[iAddr]=GetPumpStatusLabel(PUMP_OFF);
					 //}

				  }
			     else CurrentPumpStatus[iAddr]=xPumpStatus;			 
    3b7e:	f0 82       	st	Z, r15
			 if (xPumpStatus==PUMP_FEOT){
    3b80:	8b e0       	ldi	r24, 0x0B	; 11
    3b82:	f8 16       	cp	r15, r24
    3b84:	21 f0       	breq	.+8      	; 0x3b8e <UpdateStandaloneStatus+0x9e>
			     CurrentPumpStatus[iAddr]=xPumpStatus;
			     strPumpStatus[iAddr]=GetPumpStatusLabel(CurrentPumpStatus[iAddr]);
				 }
             else if (xPumpStatus==PS_TOTALIZER){
    3b86:	f4 e1       	ldi	r31, 0x14	; 20
    3b88:	ff 16       	cp	r15, r31
    3b8a:	29 f4       	brne	.+10     	; 0x3b96 <UpdateStandaloneStatus+0xa6>
			      strPumpStatus[iAddr]=GetPumpStatusLabel(xPumpStatus);
    3b8c:	84 e1       	ldi	r24, 0x14	; 20
    3b8e:	0e 94 7d 13 	call	0x26fa	; 0x26fa <GetPumpStatusLabel>
    3b92:	f8 01       	movw	r30, r16
    3b94:	80 83       	st	Z, r24
				 }
		 }		 	     
         strPumpStatus[16]=0;
    3b96:	10 92 12 01 	sts	0x0112, r1
	     IsNewPumpStatus=True;		 
    3b9a:	81 e0       	ldi	r24, 0x01	; 1
    3b9c:	80 93 01 01 	sts	0x0101, r24
		 }		 
	 }
}
    3ba0:	df 91       	pop	r29
    3ba2:	cf 91       	pop	r28
    3ba4:	1f 91       	pop	r17
    3ba6:	0f 91       	pop	r16
    3ba8:	ff 90       	pop	r15
    3baa:	08 95       	ret

00003bac <GetPumpID>:
     StrPosCopy(strSystemTime,sSecond,6,2);
	 sprintf_P(Result,PSTR("20%s/%s/%s %s:%s:%s"),sYear,sMonth,sDay,sHour,sMinute,sSecond);
}


char GetPumpID(char FIPAddr){//Find Stored PumpID in PumpMap
    3bac:	1f 93       	push	r17
    3bae:	df 93       	push	r29
    3bb0:	cf 93       	push	r28
    3bb2:	cd b7       	in	r28, 0x3d	; 61
    3bb4:	de b7       	in	r29, 0x3e	; 62
    3bb6:	28 97       	sbiw	r28, 0x08	; 8
    3bb8:	0f b6       	in	r0, 0x3f	; 63
    3bba:	f8 94       	cli
    3bbc:	de bf       	out	0x3e, r29	; 62
    3bbe:	0f be       	out	0x3f, r0	; 63
    3bc0:	cd bf       	out	0x3d, r28	; 61
    3bc2:	18 2f       	mov	r17, r24
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    3bc4:	ce 01       	movw	r24, r28
    3bc6:	01 96       	adiw	r24, 0x01	; 1
    3bc8:	65 e4       	ldi	r22, 0x45	; 69
    3bca:	70 e0       	ldi	r23, 0x00	; 0
    3bcc:	48 e0       	ldi	r20, 0x08	; 8
    3bce:	50 e0       	ldi	r21, 0x00	; 0
    3bd0:	2d ef       	ldi	r18, 0xFD	; 253
    3bd2:	32 e1       	ldi	r19, 0x12	; 18
    3bd4:	0e 94 f1 b3 	call	0x167e2	; 0x167e2 <__eerd_block>
     char PPumpID[8],Result;     
     eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap,8);
	 Result=0;
	 if ((FIPAddr>0) && (FIPAddr<8)){
    3bd8:	81 2f       	mov	r24, r17
    3bda:	81 50       	subi	r24, 0x01	; 1
    3bdc:	87 30       	cpi	r24, 0x07	; 7
    3bde:	10 f0       	brcs	.+4      	; 0x3be4 <GetPumpID+0x38>
    3be0:	80 e0       	ldi	r24, 0x00	; 0
    3be2:	04 c0       	rjmp	.+8      	; 0x3bec <GetPumpID+0x40>
	    Result=PPumpID[FIPAddr-1];
    3be4:	fe 01       	movw	r30, r28
    3be6:	e1 0f       	add	r30, r17
    3be8:	f1 1d       	adc	r31, r1
    3bea:	80 81       	ld	r24, Z
	 }
   return Result;
}
    3bec:	28 96       	adiw	r28, 0x08	; 8
    3bee:	0f b6       	in	r0, 0x3f	; 63
    3bf0:	f8 94       	cli
    3bf2:	de bf       	out	0x3e, r29	; 62
    3bf4:	0f be       	out	0x3f, r0	; 63
    3bf6:	cd bf       	out	0x3d, r28	; 61
    3bf8:	cf 91       	pop	r28
    3bfa:	df 91       	pop	r29
    3bfc:	1f 91       	pop	r17
    3bfe:	08 95       	ret

00003c00 <GetTotalizerData>:
	 if (TType==TMONEY)eeprom_write_block((const void*)&rawValue,(void*)&(TotalMoney[TAddr][iPumpAddr][iGrade]), sizeof(rawValue));
}



void GetTotalizerData(char TType, char TAddr, char xPumpAddr, char xGradeAddr, char *strValue){// 0 1 1 "0000000"
    3c00:	0f 93       	push	r16
    3c02:	1f 93       	push	r17
    3c04:	df 93       	push	r29
    3c06:	cf 93       	push	r28
    3c08:	00 d0       	rcall	.+0      	; 0x3c0a <GetTotalizerData+0xa>
    3c0a:	00 d0       	rcall	.+0      	; 0x3c0c <GetTotalizerData+0xc>
    3c0c:	00 d0       	rcall	.+0      	; 0x3c0e <GetTotalizerData+0xe>
    3c0e:	cd b7       	in	r28, 0x3d	; 61
    3c10:	de b7       	in	r29, 0x3e	; 62
    3c12:	96 2f       	mov	r25, r22
     char rawValue[6],iPumpAddr,iGrade;

	 iPumpAddr=(xPumpAddr&0x0F);
    3c14:	4f 70       	andi	r20, 0x0F	; 15
	 if ((xGradeAddr>=1)&&(xGradeAddr<=6))
    3c16:	21 50       	subi	r18, 0x01	; 1
    3c18:	26 30       	cpi	r18, 0x06	; 6
    3c1a:	08 f4       	brcc	.+2      	; 0x3c1e <GetTotalizerData+0x1e>
    3c1c:	52 2f       	mov	r21, r18
	     iGrade=xGradeAddr-1;
     
//TotalVolume[2][16][6][6];
//GetTotalizerData(TVOLUME,TOTALIZER_LAST,PumpNum,xGrade,strLastVolume);
	 if (TType==TVOLUME)eeprom_read_block((void*) &rawValue, (const void*) &(TotalVolume[TAddr][iPumpAddr][iGrade]), sizeof(rawValue));
    3c1e:	88 23       	and	r24, r24
    3c20:	d9 f4       	brne	.+54     	; 0x3c58 <GetTotalizerData+0x58>
    3c22:	64 e2       	ldi	r22, 0x24	; 36
    3c24:	46 9f       	mul	r20, r22
    3c26:	b0 01       	movw	r22, r0
    3c28:	11 24       	eor	r1, r1
    3c2a:	29 2f       	mov	r18, r25
    3c2c:	30 e0       	ldi	r19, 0x00	; 0
    3c2e:	80 e2       	ldi	r24, 0x20	; 32
    3c30:	91 e0       	ldi	r25, 0x01	; 1
    3c32:	fc 01       	movw	r30, r24
    3c34:	2e 9f       	mul	r18, r30
    3c36:	c0 01       	movw	r24, r0
    3c38:	2f 9f       	mul	r18, r31
    3c3a:	90 0d       	add	r25, r0
    3c3c:	3e 9f       	mul	r19, r30
    3c3e:	90 0d       	add	r25, r0
    3c40:	11 24       	eor	r1, r1
    3c42:	68 0f       	add	r22, r24
    3c44:	79 1f       	adc	r23, r25
    3c46:	86 e0       	ldi	r24, 0x06	; 6
    3c48:	58 9f       	mul	r21, r24
    3c4a:	c0 01       	movw	r24, r0
    3c4c:	11 24       	eor	r1, r1
    3c4e:	68 0f       	add	r22, r24
    3c50:	79 1f       	adc	r23, r25
    3c52:	6d 53       	subi	r22, 0x3D	; 61
    3c54:	7c 4f       	sbci	r23, 0xFC	; 252
    3c56:	1c c0       	rjmp	.+56     	; 0x3c90 <GetTotalizerData+0x90>
	 else 
	 if (TType==TMONEY)eeprom_read_block((void*) &rawValue, (const void*) &(TotalMoney[TAddr][iPumpAddr][iGrade]), sizeof(rawValue));
    3c58:	81 30       	cpi	r24, 0x01	; 1
    3c5a:	11 f5       	brne	.+68     	; 0x3ca0 <GetTotalizerData+0xa0>
    3c5c:	64 e2       	ldi	r22, 0x24	; 36
    3c5e:	46 9f       	mul	r20, r22
    3c60:	b0 01       	movw	r22, r0
    3c62:	11 24       	eor	r1, r1
    3c64:	29 2f       	mov	r18, r25
    3c66:	30 e0       	ldi	r19, 0x00	; 0
    3c68:	80 e2       	ldi	r24, 0x20	; 32
    3c6a:	91 e0       	ldi	r25, 0x01	; 1
    3c6c:	fc 01       	movw	r30, r24
    3c6e:	2e 9f       	mul	r18, r30
    3c70:	c0 01       	movw	r24, r0
    3c72:	2f 9f       	mul	r18, r31
    3c74:	90 0d       	add	r25, r0
    3c76:	3e 9f       	mul	r19, r30
    3c78:	90 0d       	add	r25, r0
    3c7a:	11 24       	eor	r1, r1
    3c7c:	68 0f       	add	r22, r24
    3c7e:	79 1f       	adc	r23, r25
    3c80:	86 e0       	ldi	r24, 0x06	; 6
    3c82:	58 9f       	mul	r21, r24
    3c84:	c0 01       	movw	r24, r0
    3c86:	11 24       	eor	r1, r1
    3c88:	68 0f       	add	r22, r24
    3c8a:	79 1f       	adc	r23, r25
    3c8c:	6d 5f       	subi	r22, 0xFD	; 253
    3c8e:	79 4f       	sbci	r23, 0xF9	; 249
    3c90:	ce 01       	movw	r24, r28
    3c92:	01 96       	adiw	r24, 0x01	; 1
    3c94:	46 e0       	ldi	r20, 0x06	; 6
    3c96:	50 e0       	ldi	r21, 0x00	; 0
    3c98:	2d ef       	ldi	r18, 0xFD	; 253
    3c9a:	32 e1       	ldi	r19, 0x12	; 18
    3c9c:	0e 94 f1 b3 	call	0x167e2	; 0x167e2 <__eerd_block>
	 //Convert RawData to String 
	 RawToStr(rawValue,strValue);
    3ca0:	ce 01       	movw	r24, r28
    3ca2:	01 96       	adiw	r24, 0x01	; 1
    3ca4:	b8 01       	movw	r22, r16
    3ca6:	0e 94 52 19 	call	0x32a4	; 0x32a4 <RawToStr>
}
    3caa:	26 96       	adiw	r28, 0x06	; 6
    3cac:	0f b6       	in	r0, 0x3f	; 63
    3cae:	f8 94       	cli
    3cb0:	de bf       	out	0x3e, r29	; 62
    3cb2:	0f be       	out	0x3f, r0	; 63
    3cb4:	cd bf       	out	0x3d, r28	; 61
    3cb6:	cf 91       	pop	r28
    3cb8:	df 91       	pop	r29
    3cba:	1f 91       	pop	r17
    3cbc:	0f 91       	pop	r16
    3cbe:	08 95       	ret

00003cc0 <SaveToEEPROM>:
     return Result;
}



char SaveToEEPROM(char *Src,char *Dest,unsigned int Length){
    3cc0:	ef 92       	push	r14
    3cc2:	ff 92       	push	r15
    3cc4:	0f 93       	push	r16
    3cc6:	1f 93       	push	r17
    3cc8:	df 93       	push	r29
    3cca:	cf 93       	push	r28
    3ccc:	cd b7       	in	r28, 0x3d	; 61
    3cce:	de b7       	in	r29, 0x3e	; 62
    3cd0:	ac 97       	sbiw	r28, 0x2c	; 44
    3cd2:	0f b6       	in	r0, 0x3f	; 63
    3cd4:	f8 94       	cli
    3cd6:	de bf       	out	0x3e, r29	; 62
    3cd8:	0f be       	out	0x3f, r0	; 63
    3cda:	cd bf       	out	0x3d, r28	; 61
    3cdc:	9a a7       	std	Y+42, r25	; 0x2a
    3cde:	89 a7       	std	Y+41, r24	; 0x29
    3ce0:	7c a7       	std	Y+44, r23	; 0x2c
    3ce2:	6b a7       	std	Y+43, r22	; 0x2b
    3ce4:	7a 01       	movw	r14, r20
    3ce6:	8e 01       	movw	r16, r28
    3ce8:	05 5d       	subi	r16, 0xD5	; 213
    3cea:	1f 4f       	sbci	r17, 0xFF	; 255
    3cec:	c8 01       	movw	r24, r16
    3cee:	be 01       	movw	r22, r28
    3cf0:	6f 5f       	subi	r22, 0xFF	; 255
    3cf2:	7f 4f       	sbci	r23, 0xFF	; 255
    3cf4:	2d ef       	ldi	r18, 0xFD	; 253
    3cf6:	32 e1       	ldi	r19, 0x12	; 18
    3cf8:	0e 94 f1 b3 	call	0x167e2	; 0x167e2 <__eerd_block>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    3cfc:	c8 01       	movw	r24, r16
    3cfe:	be 01       	movw	r22, r28
    3d00:	67 5d       	subi	r22, 0xD7	; 215
    3d02:	7f 4f       	sbci	r23, 0xFF	; 255
    3d04:	a7 01       	movw	r20, r14
    3d06:	25 e0       	ldi	r18, 0x05	; 5
    3d08:	33 e1       	ldi	r19, 0x13	; 19
    3d0a:	0e 94 0d b4 	call	0x1681a	; 0x1681a <__eewr_block>
     char strCompare[40];
	 //Read Previous Data
     eeprom_read_block((void*)&Dest,(const void*)&strCompare, Length);
     //if 
     eeprom_write_block((const void*)&Src,(void*)&Dest, Length);
}
    3d0e:	ac 96       	adiw	r28, 0x2c	; 44
    3d10:	0f b6       	in	r0, 0x3f	; 63
    3d12:	f8 94       	cli
    3d14:	de bf       	out	0x3e, r29	; 62
    3d16:	0f be       	out	0x3f, r0	; 63
    3d18:	cd bf       	out	0x3d, r28	; 61
    3d1a:	cf 91       	pop	r28
    3d1c:	df 91       	pop	r29
    3d1e:	1f 91       	pop	r17
    3d20:	0f 91       	pop	r16
    3d22:	ff 90       	pop	r15
    3d24:	ef 90       	pop	r14
    3d26:	08 95       	ret

00003d28 <SelectMark>:
	      break;
	 }
    return Result;
}

char SelectMark(char InMark){
    3d28:	df 92       	push	r13
    3d2a:	ef 92       	push	r14
    3d2c:	ff 92       	push	r15
    3d2e:	0f 93       	push	r16
    3d30:	1f 93       	push	r17
    3d32:	df 93       	push	r29
    3d34:	cf 93       	push	r28
    3d36:	00 d0       	rcall	.+0      	; 0x3d38 <SelectMark+0x10>
    3d38:	00 d0       	rcall	.+0      	; 0x3d3a <SelectMark+0x12>
    3d3a:	0f 92       	push	r0
    3d3c:	cd b7       	in	r28, 0x3d	; 61
    3d3e:	de b7       	in	r29, 0x3e	; 62
    3d40:	d8 2e       	mov	r13, r24
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    3d42:	8e 01       	movw	r16, r28
    3d44:	0f 5f       	subi	r16, 0xFF	; 255
    3d46:	1f 4f       	sbci	r17, 0xFF	; 255
    3d48:	c8 01       	movw	r24, r16
    3d4a:	60 e4       	ldi	r22, 0x40	; 64
    3d4c:	70 e0       	ldi	r23, 0x00	; 0
    3d4e:	45 e0       	ldi	r20, 0x05	; 5
    3d50:	50 e0       	ldi	r21, 0x00	; 0
    3d52:	2d ef       	ldi	r18, 0xFD	; 253
    3d54:	32 e1       	ldi	r19, 0x12	; 18
    3d56:	0e 94 f1 b3 	call	0x167e2	; 0x167e2 <__eerd_block>
    3d5a:	ed 2d       	mov	r30, r13
    3d5c:	21 e0       	ldi	r18, 0x01	; 1
    3d5e:	30 e0       	ldi	r19, 0x00	; 0
     eeprom_read_block((void*)&PMark,(const void*)&DefMarkMap, sizeof(DefMarkMap));
	 Length=sizeof(DefMarkMap);
	 Result=InMark;
     for(i=0;i<Length;i++){
	     if (InMark==PMark[i])
		     Result=PMark[(i+1)%Length];
    3d60:	78 01       	movw	r14, r16
char i,Result,PMark[5],Length;
     eeprom_read_block((void*)&PMark,(const void*)&DefMarkMap, sizeof(DefMarkMap));
	 Length=sizeof(DefMarkMap);
	 Result=InMark;
     for(i=0;i<Length;i++){
	     if (InMark==PMark[i])
    3d62:	d8 01       	movw	r26, r16
    3d64:	8c 91       	ld	r24, X
    3d66:	d8 16       	cp	r13, r24
    3d68:	49 f4       	brne	.+18     	; 0x3d7c <SelectMark+0x54>
		     Result=PMark[(i+1)%Length];
    3d6a:	c9 01       	movw	r24, r18
    3d6c:	65 e0       	ldi	r22, 0x05	; 5
    3d6e:	70 e0       	ldi	r23, 0x00	; 0
    3d70:	0e 94 1e b7 	call	0x16e3c	; 0x16e3c <__divmodhi4>
    3d74:	f7 01       	movw	r30, r14
    3d76:	e8 0f       	add	r30, r24
    3d78:	f9 1f       	adc	r31, r25
    3d7a:	e0 81       	ld	r30, Z
    3d7c:	0f 5f       	subi	r16, 0xFF	; 255
    3d7e:	1f 4f       	sbci	r17, 0xFF	; 255
    3d80:	2f 5f       	subi	r18, 0xFF	; 255
    3d82:	3f 4f       	sbci	r19, 0xFF	; 255
char SelectMark(char InMark){
char i,Result,PMark[5],Length;
     eeprom_read_block((void*)&PMark,(const void*)&DefMarkMap, sizeof(DefMarkMap));
	 Length=sizeof(DefMarkMap);
	 Result=InMark;
     for(i=0;i<Length;i++){
    3d84:	26 30       	cpi	r18, 0x06	; 6
    3d86:	31 05       	cpc	r19, r1
    3d88:	61 f7       	brne	.-40     	; 0x3d62 <SelectMark+0x3a>
	     if (InMark==PMark[i])
		     Result=PMark[(i+1)%Length];
	 }
     return Result;
}
    3d8a:	8e 2f       	mov	r24, r30
    3d8c:	0f 90       	pop	r0
    3d8e:	0f 90       	pop	r0
    3d90:	0f 90       	pop	r0
    3d92:	0f 90       	pop	r0
    3d94:	0f 90       	pop	r0
    3d96:	cf 91       	pop	r28
    3d98:	df 91       	pop	r29
    3d9a:	1f 91       	pop	r17
    3d9c:	0f 91       	pop	r16
    3d9e:	ff 90       	pop	r15
    3da0:	ef 90       	pop	r14
    3da2:	df 90       	pop	r13
    3da4:	08 95       	ret

00003da6 <UpdateServerIP>:
	 for(i=0;i<4;i++){
	     zeroIP(IP_blok[i],strIP[i]);
	 }
     sprintf_P(strClientIP,PSTR("%s.%s.%s.%s"),strIP[0],strIP[1],strIP[2],strIP[3]);
}
void UpdateServerIP(){     
    3da6:	cf 92       	push	r12
    3da8:	df 92       	push	r13
    3daa:	ef 92       	push	r14
    3dac:	ff 92       	push	r15
    3dae:	0f 93       	push	r16
    3db0:	1f 93       	push	r17
    3db2:	df 93       	push	r29
    3db4:	cf 93       	push	r28
    3db6:	cd b7       	in	r28, 0x3d	; 61
    3db8:	de b7       	in	r29, 0x3e	; 62
    3dba:	64 97       	sbiw	r28, 0x14	; 20
    3dbc:	0f b6       	in	r0, 0x3f	; 63
    3dbe:	f8 94       	cli
    3dc0:	de bf       	out	0x3e, r29	; 62
    3dc2:	0f be       	out	0x3f, r0	; 63
    3dc4:	cd bf       	out	0x3d, r28	; 61
    3dc6:	8e 01       	movw	r16, r28
    3dc8:	0f 5f       	subi	r16, 0xFF	; 255
    3dca:	1f 4f       	sbci	r17, 0xFF	; 255
    3dcc:	c8 01       	movw	r24, r16
    3dce:	6c e2       	ldi	r22, 0x2C	; 44
    3dd0:	70 e0       	ldi	r23, 0x00	; 0
    3dd2:	44 e0       	ldi	r20, 0x04	; 4
    3dd4:	50 e0       	ldi	r21, 0x00	; 0
    3dd6:	2d ef       	ldi	r18, 0xFD	; 253
    3dd8:	32 e1       	ldi	r19, 0x12	; 18
    3dda:	0e 94 f1 b3 	call	0x167e2	; 0x167e2 <__eerd_block>
    3dde:	78 01       	movw	r14, r16
    3de0:	8e 01       	movw	r16, r28
    3de2:	0b 5f       	subi	r16, 0xFB	; 251
    3de4:	1f 4f       	sbci	r17, 0xFF	; 255
	 char strIP[4][4];
	 //192.168.016.180
     eeprom_read_block((void*)&IP_blok,(const void*)&DefServerIP,4);

	 for(i=0;i<4;i++){
	     zeroIP(IP_blok[i],strIP[i]);
    3de6:	68 01       	movw	r12, r16
    3de8:	d7 01       	movw	r26, r14
    3dea:	8d 91       	ld	r24, X+
    3dec:	7d 01       	movw	r14, r26
    3dee:	b8 01       	movw	r22, r16
    3df0:	0e 94 92 16 	call	0x2d24	; 0x2d24 <zeroIP>
    3df4:	0c 5f       	subi	r16, 0xFC	; 252
    3df6:	1f 4f       	sbci	r17, 0xFF	; 255
     char i,IP_blok[4];
	 char strIP[4][4];
	 //192.168.016.180
     eeprom_read_block((void*)&IP_blok,(const void*)&DefServerIP,4);

	 for(i=0;i<4;i++){
    3df8:	ec 14       	cp	r14, r12
    3dfa:	fd 04       	cpc	r15, r13
    3dfc:	a9 f7       	brne	.-22     	; 0x3de8 <UpdateServerIP+0x42>
	     zeroIP(IP_blok[i],strIP[i]);
	 }
		 sprintf_P(strServerIP,PSTR("%s.%s.%s.%s"),strIP[0],strIP[1],strIP[2],strIP[3]);
    3dfe:	ed b7       	in	r30, 0x3d	; 61
    3e00:	fe b7       	in	r31, 0x3e	; 62
    3e02:	3c 97       	sbiw	r30, 0x0c	; 12
    3e04:	0f b6       	in	r0, 0x3f	; 63
    3e06:	f8 94       	cli
    3e08:	fe bf       	out	0x3e, r31	; 62
    3e0a:	0f be       	out	0x3f, r0	; 63
    3e0c:	ed bf       	out	0x3d, r30	; 61
    3e0e:	31 96       	adiw	r30, 0x01	; 1
    3e10:	8a e1       	ldi	r24, 0x1A	; 26
    3e12:	99 e0       	ldi	r25, 0x09	; 9
    3e14:	ad b7       	in	r26, 0x3d	; 61
    3e16:	be b7       	in	r27, 0x3e	; 62
    3e18:	12 96       	adiw	r26, 0x02	; 2
    3e1a:	9c 93       	st	X, r25
    3e1c:	8e 93       	st	-X, r24
    3e1e:	11 97       	sbiw	r26, 0x01	; 1
    3e20:	8f e0       	ldi	r24, 0x0F	; 15
    3e22:	92 e2       	ldi	r25, 0x22	; 34
    3e24:	93 83       	std	Z+3, r25	; 0x03
    3e26:	82 83       	std	Z+2, r24	; 0x02
    3e28:	f5 82       	std	Z+5, r15	; 0x05
    3e2a:	e4 82       	std	Z+4, r14	; 0x04
    3e2c:	ce 01       	movw	r24, r28
    3e2e:	09 96       	adiw	r24, 0x09	; 9
    3e30:	97 83       	std	Z+7, r25	; 0x07
    3e32:	86 83       	std	Z+6, r24	; 0x06
    3e34:	ce 01       	movw	r24, r28
    3e36:	0d 96       	adiw	r24, 0x0d	; 13
    3e38:	91 87       	std	Z+9, r25	; 0x09
    3e3a:	80 87       	std	Z+8, r24	; 0x08
    3e3c:	ce 01       	movw	r24, r28
    3e3e:	41 96       	adiw	r24, 0x11	; 17
    3e40:	93 87       	std	Z+11, r25	; 0x0b
    3e42:	82 87       	std	Z+10, r24	; 0x0a
    3e44:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    3e48:	ed b7       	in	r30, 0x3d	; 61
    3e4a:	fe b7       	in	r31, 0x3e	; 62
    3e4c:	3c 96       	adiw	r30, 0x0c	; 12
    3e4e:	0f b6       	in	r0, 0x3f	; 63
    3e50:	f8 94       	cli
    3e52:	fe bf       	out	0x3e, r31	; 62
    3e54:	0f be       	out	0x3f, r0	; 63
    3e56:	ed bf       	out	0x3d, r30	; 61
}
    3e58:	64 96       	adiw	r28, 0x14	; 20
    3e5a:	0f b6       	in	r0, 0x3f	; 63
    3e5c:	f8 94       	cli
    3e5e:	de bf       	out	0x3e, r29	; 62
    3e60:	0f be       	out	0x3f, r0	; 63
    3e62:	cd bf       	out	0x3d, r28	; 61
    3e64:	cf 91       	pop	r28
    3e66:	df 91       	pop	r29
    3e68:	1f 91       	pop	r17
    3e6a:	0f 91       	pop	r16
    3e6c:	ff 90       	pop	r15
    3e6e:	ef 90       	pop	r14
    3e70:	df 90       	pop	r13
    3e72:	cf 90       	pop	r12
    3e74:	08 95       	ret

00003e76 <UpdateClientIP>:
	     str[0]=('0'+S);
	     str[1]=0;
	 }
}

void UpdateClientIP(){     
    3e76:	cf 92       	push	r12
    3e78:	df 92       	push	r13
    3e7a:	ef 92       	push	r14
    3e7c:	ff 92       	push	r15
    3e7e:	0f 93       	push	r16
    3e80:	1f 93       	push	r17
    3e82:	df 93       	push	r29
    3e84:	cf 93       	push	r28
    3e86:	cd b7       	in	r28, 0x3d	; 61
    3e88:	de b7       	in	r29, 0x3e	; 62
    3e8a:	68 97       	sbiw	r28, 0x18	; 24
    3e8c:	0f b6       	in	r0, 0x3f	; 63
    3e8e:	f8 94       	cli
    3e90:	de bf       	out	0x3e, r29	; 62
    3e92:	0f be       	out	0x3f, r0	; 63
    3e94:	cd bf       	out	0x3d, r28	; 61
    3e96:	8e 01       	movw	r16, r28
    3e98:	0f 5f       	subi	r16, 0xFF	; 255
    3e9a:	1f 4f       	sbci	r17, 0xFF	; 255
    3e9c:	c8 01       	movw	r24, r16
    3e9e:	68 e2       	ldi	r22, 0x28	; 40
    3ea0:	70 e0       	ldi	r23, 0x00	; 0
    3ea2:	44 e0       	ldi	r20, 0x04	; 4
    3ea4:	50 e0       	ldi	r21, 0x00	; 0
    3ea6:	2d ef       	ldi	r18, 0xFD	; 253
    3ea8:	32 e1       	ldi	r19, 0x12	; 18
    3eaa:	0e 94 f1 b3 	call	0x167e2	; 0x167e2 <__eerd_block>
    3eae:	78 01       	movw	r14, r16
    3eb0:	8e 01       	movw	r16, r28
    3eb2:	0b 5f       	subi	r16, 0xFB	; 251
    3eb4:	1f 4f       	sbci	r17, 0xFF	; 255
	 char strIP[4][5];
	 //192.168.010.002
     eeprom_read_block((void*)&IP_blok,(const void*)&DefClientIP,4);

	 for(i=0;i<4;i++){
	     zeroIP(IP_blok[i],strIP[i]);
    3eb6:	68 01       	movw	r12, r16
    3eb8:	d7 01       	movw	r26, r14
    3eba:	8d 91       	ld	r24, X+
    3ebc:	7d 01       	movw	r14, r26
    3ebe:	b8 01       	movw	r22, r16
    3ec0:	0e 94 92 16 	call	0x2d24	; 0x2d24 <zeroIP>
    3ec4:	0b 5f       	subi	r16, 0xFB	; 251
    3ec6:	1f 4f       	sbci	r17, 0xFF	; 255
     char i,IP_blok[4];
	 char strIP[4][5];
	 //192.168.010.002
     eeprom_read_block((void*)&IP_blok,(const void*)&DefClientIP,4);

	 for(i=0;i<4;i++){
    3ec8:	ec 14       	cp	r14, r12
    3eca:	fd 04       	cpc	r15, r13
    3ecc:	a9 f7       	brne	.-22     	; 0x3eb8 <UpdateClientIP+0x42>
	     zeroIP(IP_blok[i],strIP[i]);
	 }
     sprintf_P(strClientIP,PSTR("%s.%s.%s.%s"),strIP[0],strIP[1],strIP[2],strIP[3]);
    3ece:	ed b7       	in	r30, 0x3d	; 61
    3ed0:	fe b7       	in	r31, 0x3e	; 62
    3ed2:	3c 97       	sbiw	r30, 0x0c	; 12
    3ed4:	0f b6       	in	r0, 0x3f	; 63
    3ed6:	f8 94       	cli
    3ed8:	fe bf       	out	0x3e, r31	; 62
    3eda:	0f be       	out	0x3f, r0	; 63
    3edc:	ed bf       	out	0x3d, r30	; 61
    3ede:	31 96       	adiw	r30, 0x01	; 1
    3ee0:	8d ee       	ldi	r24, 0xED	; 237
    3ee2:	98 e0       	ldi	r25, 0x08	; 8
    3ee4:	ad b7       	in	r26, 0x3d	; 61
    3ee6:	be b7       	in	r27, 0x3e	; 62
    3ee8:	12 96       	adiw	r26, 0x02	; 2
    3eea:	9c 93       	st	X, r25
    3eec:	8e 93       	st	-X, r24
    3eee:	11 97       	sbiw	r26, 0x01	; 1
    3ef0:	8b e1       	ldi	r24, 0x1B	; 27
    3ef2:	92 e2       	ldi	r25, 0x22	; 34
    3ef4:	93 83       	std	Z+3, r25	; 0x03
    3ef6:	82 83       	std	Z+2, r24	; 0x02
    3ef8:	f5 82       	std	Z+5, r15	; 0x05
    3efa:	e4 82       	std	Z+4, r14	; 0x04
    3efc:	ce 01       	movw	r24, r28
    3efe:	0a 96       	adiw	r24, 0x0a	; 10
    3f00:	97 83       	std	Z+7, r25	; 0x07
    3f02:	86 83       	std	Z+6, r24	; 0x06
    3f04:	ce 01       	movw	r24, r28
    3f06:	0f 96       	adiw	r24, 0x0f	; 15
    3f08:	91 87       	std	Z+9, r25	; 0x09
    3f0a:	80 87       	std	Z+8, r24	; 0x08
    3f0c:	ce 01       	movw	r24, r28
    3f0e:	44 96       	adiw	r24, 0x14	; 20
    3f10:	93 87       	std	Z+11, r25	; 0x0b
    3f12:	82 87       	std	Z+10, r24	; 0x0a
    3f14:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    3f18:	ed b7       	in	r30, 0x3d	; 61
    3f1a:	fe b7       	in	r31, 0x3e	; 62
    3f1c:	3c 96       	adiw	r30, 0x0c	; 12
    3f1e:	0f b6       	in	r0, 0x3f	; 63
    3f20:	f8 94       	cli
    3f22:	fe bf       	out	0x3e, r31	; 62
    3f24:	0f be       	out	0x3f, r0	; 63
    3f26:	ed bf       	out	0x3d, r30	; 61
}
    3f28:	68 96       	adiw	r28, 0x18	; 24
    3f2a:	0f b6       	in	r0, 0x3f	; 63
    3f2c:	f8 94       	cli
    3f2e:	de bf       	out	0x3e, r29	; 62
    3f30:	0f be       	out	0x3f, r0	; 63
    3f32:	cd bf       	out	0x3d, r28	; 61
    3f34:	cf 91       	pop	r28
    3f36:	df 91       	pop	r29
    3f38:	1f 91       	pop	r17
    3f3a:	0f 91       	pop	r16
    3f3c:	ff 90       	pop	r15
    3f3e:	ef 90       	pop	r14
    3f40:	df 90       	pop	r13
    3f42:	cf 90       	pop	r12
    3f44:	08 95       	ret

00003f46 <GenerateStandaloneTransData>:

     eeprom_write_block((const void*)&PTransNum,(void*)&DefTransactionNumber,sizeof(DefTransactionNumber));
}


char GenerateStandaloneTransData(char xPumpID, char *PNozzle){//[1,2,3..16]->[1,2,3..0]
    3f46:	cf 92       	push	r12
    3f48:	df 92       	push	r13
    3f4a:	ef 92       	push	r14
    3f4c:	ff 92       	push	r15
    3f4e:	0f 93       	push	r16
    3f50:	1f 93       	push	r17
    3f52:	df 93       	push	r29
    3f54:	cf 93       	push	r28
    3f56:	cd b7       	in	r28, 0x3d	; 61
    3f58:	de b7       	in	r29, 0x3e	; 62
    3f5a:	2f 97       	sbiw	r28, 0x0f	; 15
    3f5c:	0f b6       	in	r0, 0x3f	; 63
    3f5e:	f8 94       	cli
    3f60:	de bf       	out	0x3e, r29	; 62
    3f62:	0f be       	out	0x3f, r0	; 63
    3f64:	cd bf       	out	0x3d, r28	; 61
    3f66:	e8 2e       	mov	r14, r24
    3f68:	8b 01       	movw	r16, r22
     char Result=GS_NONE;
	 char strSend[30];
	 char FIPAddr;

	 iPumpID=(xPumpID&0x0F);
	 FIPAddr=GetFIPAddr(iPumpID);
    3f6a:	8f 70       	andi	r24, 0x0F	; 15
    3f6c:	0e 94 41 1d 	call	0x3a82	; 0x3a82 <GetFIPAddr>
     if (FIPAddr>0){
    3f70:	88 23       	and	r24, r24
    3f72:	09 f4       	brne	.+2      	; 0x3f76 <GenerateStandaloneTransData+0x30>
    3f74:	2d c1       	rjmp	.+602    	; 0x41d0 <GenerateStandaloneTransData+0x28a>
	     FIPAddr=FIPAddr-1;
		 iProdID=PNozzle[RecPumpData[FIPAddr].Grade];
    3f76:	81 50       	subi	r24, 0x01	; 1
    3f78:	c8 2e       	mov	r12, r24
    3f7a:	dd 24       	eor	r13, r13
    3f7c:	85 e3       	ldi	r24, 0x35	; 53
    3f7e:	90 e0       	ldi	r25, 0x00	; 0
    3f80:	c8 9e       	mul	r12, r24
    3f82:	f0 01       	movw	r30, r0
    3f84:	c9 9e       	mul	r12, r25
    3f86:	f0 0d       	add	r31, r0
    3f88:	d8 9e       	mul	r13, r24
    3f8a:	f0 0d       	add	r31, r0
    3f8c:	11 24       	eor	r1, r1
    3f8e:	e6 54       	subi	r30, 0x46	; 70
    3f90:	f9 4f       	sbci	r31, 0xF9	; 249
    3f92:	80 81       	ld	r24, Z
    3f94:	08 0f       	add	r16, r24
    3f96:	11 1d       	adc	r17, r1
    3f98:	d8 01       	movw	r26, r16
    3f9a:	2c 91       	ld	r18, X
    3f9c:	ce 01       	movw	r24, r28
    3f9e:	01 96       	adiw	r24, 0x01	; 1

		 if (iProdID>0) eeprom_read_block((void*) &ProductName, (const void*) &DefProductName[iProdID-1],sizeof(DefProductName[iProdID-1]));
    3fa0:	22 23       	and	r18, r18
    3fa2:	69 f0       	breq	.+26     	; 0x3fbe <GenerateStandaloneTransData+0x78>
    3fa4:	6d e0       	ldi	r22, 0x0D	; 13
    3fa6:	26 9f       	mul	r18, r22
    3fa8:	b0 01       	movw	r22, r0
    3faa:	11 24       	eor	r1, r1
    3fac:	62 55       	subi	r22, 0x52	; 82
    3fae:	7f 4f       	sbci	r23, 0xFF	; 255
    3fb0:	4d e0       	ldi	r20, 0x0D	; 13
    3fb2:	50 e0       	ldi	r21, 0x00	; 0
    3fb4:	2d ef       	ldi	r18, 0xFD	; 253
    3fb6:	32 e1       	ldi	r19, 0x12	; 18
    3fb8:	0e 94 f1 b3 	call	0x167e2	; 0x167e2 <__eerd_block>
    3fbc:	10 c0       	rjmp	.+32     	; 0x3fde <GenerateStandaloneTransData+0x98>
		 else sprintf_P(ProductName,PSTR("N/A"));
    3fbe:	00 d0       	rcall	.+0      	; 0x3fc0 <GenerateStandaloneTransData+0x7a>
    3fc0:	00 d0       	rcall	.+0      	; 0x3fc2 <GenerateStandaloneTransData+0x7c>
    3fc2:	ed b7       	in	r30, 0x3d	; 61
    3fc4:	fe b7       	in	r31, 0x3e	; 62
    3fc6:	92 83       	std	Z+2, r25	; 0x02
    3fc8:	81 83       	std	Z+1, r24	; 0x01
    3fca:	8c ec       	ldi	r24, 0xCC	; 204
    3fcc:	92 e2       	ldi	r25, 0x22	; 34
    3fce:	94 83       	std	Z+4, r25	; 0x04
    3fd0:	83 83       	std	Z+3, r24	; 0x03
    3fd2:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    3fd6:	0f 90       	pop	r0
    3fd8:	0f 90       	pop	r0
    3fda:	0f 90       	pop	r0
    3fdc:	0f 90       	pop	r0
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    3fde:	e1 99       	sbic	0x1c, 1	; 28
    3fe0:	fe cf       	rjmp	.-4      	; 0x3fde <GenerateStandaloneTransData+0x98>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3fe2:	80 e0       	ldi	r24, 0x00	; 0
    3fe4:	90 e0       	ldi	r25, 0x00	; 0
    3fe6:	9f bb       	out	0x1f, r25	; 31
    3fe8:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    3fea:	e0 9a       	sbi	0x1c, 0	; 28
    3fec:	fd b2       	in	r15, 0x1d	; 29

		 TermID=eeprom_read_byte(&DefIFT_ID);

		 //Shift,TransNum,Date,Time
		 sprintf_P(strShift,PSTR("%d"),RecPumpData[FIPAddr].Shift);
    3fee:	00 d0       	rcall	.+0      	; 0x3ff0 <GenerateStandaloneTransData+0xaa>
    3ff0:	00 d0       	rcall	.+0      	; 0x3ff2 <GenerateStandaloneTransData+0xac>
    3ff2:	00 d0       	rcall	.+0      	; 0x3ff4 <GenerateStandaloneTransData+0xae>
    3ff4:	ad b7       	in	r26, 0x3d	; 61
    3ff6:	be b7       	in	r27, 0x3e	; 62
    3ff8:	11 96       	adiw	r26, 0x01	; 1
    3ffa:	8f e9       	ldi	r24, 0x9F	; 159
    3ffc:	9d e0       	ldi	r25, 0x0D	; 13
    3ffe:	ed b7       	in	r30, 0x3d	; 61
    4000:	fe b7       	in	r31, 0x3e	; 62
    4002:	92 83       	std	Z+2, r25	; 0x02
    4004:	81 83       	std	Z+1, r24	; 0x01
    4006:	89 ec       	ldi	r24, 0xC9	; 201
    4008:	92 e2       	ldi	r25, 0x22	; 34
    400a:	13 96       	adiw	r26, 0x03	; 3
    400c:	9c 93       	st	X, r25
    400e:	8e 93       	st	-X, r24
    4010:	12 97       	sbiw	r26, 0x02	; 2
    4012:	85 e3       	ldi	r24, 0x35	; 53
    4014:	90 e0       	ldi	r25, 0x00	; 0
    4016:	c8 9e       	mul	r12, r24
    4018:	80 01       	movw	r16, r0
    401a:	c9 9e       	mul	r12, r25
    401c:	10 0d       	add	r17, r0
    401e:	d8 9e       	mul	r13, r24
    4020:	10 0d       	add	r17, r0
    4022:	11 24       	eor	r1, r1
    4024:	f8 01       	movw	r30, r16
    4026:	e6 54       	subi	r30, 0x46	; 70
    4028:	f9 4f       	sbci	r31, 0xF9	; 249
    402a:	82 81       	ldd	r24, Z+2	; 0x02
    402c:	14 96       	adiw	r26, 0x04	; 4
    402e:	8c 93       	st	X, r24
    4030:	14 97       	sbiw	r26, 0x04	; 4
    4032:	15 96       	adiw	r26, 0x05	; 5
    4034:	1c 92       	st	X, r1
    4036:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
		 sprintf_P(strTranNo,PSTR("%s"),RecPumpData[FIPAddr].strTransNum);
    403a:	ed b7       	in	r30, 0x3d	; 61
    403c:	fe b7       	in	r31, 0x3e	; 62
    403e:	31 96       	adiw	r30, 0x01	; 1
    4040:	8e eb       	ldi	r24, 0xBE	; 190
    4042:	9d e0       	ldi	r25, 0x0D	; 13
    4044:	ad b7       	in	r26, 0x3d	; 61
    4046:	be b7       	in	r27, 0x3e	; 62
    4048:	12 96       	adiw	r26, 0x02	; 2
    404a:	9c 93       	st	X, r25
    404c:	8e 93       	st	-X, r24
    404e:	11 97       	sbiw	r26, 0x01	; 1
    4050:	86 ec       	ldi	r24, 0xC6	; 198
    4052:	92 e2       	ldi	r25, 0x22	; 34
    4054:	93 83       	std	Z+3, r25	; 0x03
    4056:	82 83       	std	Z+2, r24	; 0x02
    4058:	c8 01       	movw	r24, r16
    405a:	83 54       	subi	r24, 0x43	; 67
    405c:	99 4f       	sbci	r25, 0xF9	; 249
    405e:	95 83       	std	Z+5, r25	; 0x05
    4060:	84 83       	std	Z+4, r24	; 0x04
    4062:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
	     sprintf_P(strDate,PSTR("%s"),RecPumpData[FIPAddr].strTransDate);
    4066:	ed b7       	in	r30, 0x3d	; 61
    4068:	fe b7       	in	r31, 0x3e	; 62
    406a:	31 96       	adiw	r30, 0x01	; 1
    406c:	80 e8       	ldi	r24, 0x80	; 128
    406e:	98 e0       	ldi	r25, 0x08	; 8
    4070:	ad b7       	in	r26, 0x3d	; 61
    4072:	be b7       	in	r27, 0x3e	; 62
    4074:	12 96       	adiw	r26, 0x02	; 2
    4076:	9c 93       	st	X, r25
    4078:	8e 93       	st	-X, r24
    407a:	11 97       	sbiw	r26, 0x01	; 1
    407c:	83 ec       	ldi	r24, 0xC3	; 195
    407e:	92 e2       	ldi	r25, 0x22	; 34
    4080:	93 83       	std	Z+3, r25	; 0x03
    4082:	82 83       	std	Z+2, r24	; 0x02
    4084:	c8 01       	movw	r24, r16
    4086:	8c 53       	subi	r24, 0x3C	; 60
    4088:	99 4f       	sbci	r25, 0xF9	; 249
    408a:	95 83       	std	Z+5, r25	; 0x05
    408c:	84 83       	std	Z+4, r24	; 0x04
    408e:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
		 sprintf_P(strTime,PSTR("%s"),RecPumpData[FIPAddr].strTransTime);	 
    4092:	ed b7       	in	r30, 0x3d	; 61
    4094:	fe b7       	in	r31, 0x3e	; 62
    4096:	31 96       	adiw	r30, 0x01	; 1
    4098:	8c e5       	ldi	r24, 0x5C	; 92
    409a:	94 e0       	ldi	r25, 0x04	; 4
    409c:	ad b7       	in	r26, 0x3d	; 61
    409e:	be b7       	in	r27, 0x3e	; 62
    40a0:	12 96       	adiw	r26, 0x02	; 2
    40a2:	9c 93       	st	X, r25
    40a4:	8e 93       	st	-X, r24
    40a6:	11 97       	sbiw	r26, 0x01	; 1
    40a8:	80 ec       	ldi	r24, 0xC0	; 192
    40aa:	92 e2       	ldi	r25, 0x22	; 34
    40ac:	93 83       	std	Z+3, r25	; 0x03
    40ae:	82 83       	std	Z+2, r24	; 0x02
    40b0:	c8 01       	movw	r24, r16
    40b2:	83 53       	subi	r24, 0x33	; 51
    40b4:	99 4f       	sbci	r25, 0xF9	; 249
    40b6:	95 83       	std	Z+5, r25	; 0x05
    40b8:	84 83       	std	Z+4, r24	; 0x04
    40ba:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>

	     //TermID,FIP_ID,Product
		 sprintf_P(strIslandID,PSTR("%d"),TermID);
    40be:	ed b7       	in	r30, 0x3d	; 61
    40c0:	fe b7       	in	r31, 0x3e	; 62
    40c2:	31 96       	adiw	r30, 0x01	; 1
    40c4:	8b e2       	ldi	r24, 0x2B	; 43
    40c6:	9a e0       	ldi	r25, 0x0A	; 10
    40c8:	ad b7       	in	r26, 0x3d	; 61
    40ca:	be b7       	in	r27, 0x3e	; 62
    40cc:	12 96       	adiw	r26, 0x02	; 2
    40ce:	9c 93       	st	X, r25
    40d0:	8e 93       	st	-X, r24
    40d2:	11 97       	sbiw	r26, 0x01	; 1
    40d4:	8d eb       	ldi	r24, 0xBD	; 189
    40d6:	92 e2       	ldi	r25, 0x22	; 34
    40d8:	93 83       	std	Z+3, r25	; 0x03
    40da:	82 83       	std	Z+2, r24	; 0x02
    40dc:	f4 82       	std	Z+4, r15	; 0x04
    40de:	15 82       	std	Z+5, r1	; 0x05
    40e0:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
		 sprintf_P(strFIP_ID,PSTR("%.2d"),xPumpID);
    40e4:	ed b7       	in	r30, 0x3d	; 61
    40e6:	fe b7       	in	r31, 0x3e	; 62
    40e8:	31 96       	adiw	r30, 0x01	; 1
    40ea:	8b ec       	ldi	r24, 0xCB	; 203
    40ec:	98 e0       	ldi	r25, 0x08	; 8
    40ee:	ad b7       	in	r26, 0x3d	; 61
    40f0:	be b7       	in	r27, 0x3e	; 62
    40f2:	12 96       	adiw	r26, 0x02	; 2
    40f4:	9c 93       	st	X, r25
    40f6:	8e 93       	st	-X, r24
    40f8:	11 97       	sbiw	r26, 0x01	; 1
    40fa:	88 eb       	ldi	r24, 0xB8	; 184
    40fc:	92 e2       	ldi	r25, 0x22	; 34
    40fe:	93 83       	std	Z+3, r25	; 0x03
    4100:	82 83       	std	Z+2, r24	; 0x02
    4102:	e4 82       	std	Z+4, r14	; 0x04
    4104:	15 82       	std	Z+5, r1	; 0x05
    4106:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
	     sprintf_P(strDescription,PSTR("%s"),ProductName);
    410a:	ed b7       	in	r30, 0x3d	; 61
    410c:	fe b7       	in	r31, 0x3e	; 62
    410e:	31 96       	adiw	r30, 0x01	; 1
    4110:	80 e4       	ldi	r24, 0x40	; 64
    4112:	99 e0       	ldi	r25, 0x09	; 9
    4114:	ad b7       	in	r26, 0x3d	; 61
    4116:	be b7       	in	r27, 0x3e	; 62
    4118:	12 96       	adiw	r26, 0x02	; 2
    411a:	9c 93       	st	X, r25
    411c:	8e 93       	st	-X, r24
    411e:	11 97       	sbiw	r26, 0x01	; 1
    4120:	85 eb       	ldi	r24, 0xB5	; 181
    4122:	92 e2       	ldi	r25, 0x22	; 34
    4124:	93 83       	std	Z+3, r25	; 0x03
    4126:	82 83       	std	Z+2, r24	; 0x02
    4128:	ce 01       	movw	r24, r28
    412a:	01 96       	adiw	r24, 0x01	; 1
    412c:	95 83       	std	Z+5, r25	; 0x05
    412e:	84 83       	std	Z+4, r24	; 0x04
    4130:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>

		 //Price Volume Money
		 sprintf_P(strPrice,PSTR("%s"),RecPumpData[FIPAddr].Price);
    4134:	ed b7       	in	r30, 0x3d	; 61
    4136:	fe b7       	in	r31, 0x3e	; 62
    4138:	31 96       	adiw	r30, 0x01	; 1
    413a:	80 eb       	ldi	r24, 0xB0	; 176
    413c:	96 e0       	ldi	r25, 0x06	; 6
    413e:	ad b7       	in	r26, 0x3d	; 61
    4140:	be b7       	in	r27, 0x3e	; 62
    4142:	12 96       	adiw	r26, 0x02	; 2
    4144:	9c 93       	st	X, r25
    4146:	8e 93       	st	-X, r24
    4148:	11 97       	sbiw	r26, 0x01	; 1
    414a:	82 eb       	ldi	r24, 0xB2	; 178
    414c:	92 e2       	ldi	r25, 0x22	; 34
    414e:	93 83       	std	Z+3, r25	; 0x03
    4150:	82 83       	std	Z+2, r24	; 0x02
    4152:	c8 01       	movw	r24, r16
    4154:	8a 52       	subi	r24, 0x2A	; 42
    4156:	99 4f       	sbci	r25, 0xF9	; 249
    4158:	95 83       	std	Z+5, r25	; 0x05
    415a:	84 83       	std	Z+4, r24	; 0x04
    415c:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
	     sprintf_P(strVolume,PSTR("%s"),RecPumpData[FIPAddr].Volume);
    4160:	ed b7       	in	r30, 0x3d	; 61
    4162:	fe b7       	in	r31, 0x3e	; 62
    4164:	31 96       	adiw	r30, 0x01	; 1
    4166:	84 e8       	ldi	r24, 0x84	; 132
    4168:	94 e0       	ldi	r25, 0x04	; 4
    416a:	ad b7       	in	r26, 0x3d	; 61
    416c:	be b7       	in	r27, 0x3e	; 62
    416e:	12 96       	adiw	r26, 0x02	; 2
    4170:	9c 93       	st	X, r25
    4172:	8e 93       	st	-X, r24
    4174:	11 97       	sbiw	r26, 0x01	; 1
    4176:	8f ea       	ldi	r24, 0xAF	; 175
    4178:	92 e2       	ldi	r25, 0x22	; 34
    417a:	93 83       	std	Z+3, r25	; 0x03
    417c:	82 83       	std	Z+2, r24	; 0x02
    417e:	c8 01       	movw	r24, r16
    4180:	83 52       	subi	r24, 0x23	; 35
    4182:	99 4f       	sbci	r25, 0xF9	; 249
    4184:	95 83       	std	Z+5, r25	; 0x05
    4186:	84 83       	std	Z+4, r24	; 0x04
    4188:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
		 sprintf_P(strAmount,PSTR("%s"),RecPumpData[FIPAddr].Money);
    418c:	ed b7       	in	r30, 0x3d	; 61
    418e:	fe b7       	in	r31, 0x3e	; 62
    4190:	31 96       	adiw	r30, 0x01	; 1
    4192:	87 ee       	ldi	r24, 0xE7	; 231
    4194:	9c e0       	ldi	r25, 0x0C	; 12
    4196:	ad b7       	in	r26, 0x3d	; 61
    4198:	be b7       	in	r27, 0x3e	; 62
    419a:	12 96       	adiw	r26, 0x02	; 2
    419c:	9c 93       	st	X, r25
    419e:	8e 93       	st	-X, r24
    41a0:	11 97       	sbiw	r26, 0x01	; 1
    41a2:	8c ea       	ldi	r24, 0xAC	; 172
    41a4:	92 e2       	ldi	r25, 0x22	; 34
    41a6:	93 83       	std	Z+3, r25	; 0x03
    41a8:	82 83       	std	Z+2, r24	; 0x02
    41aa:	0a 51       	subi	r16, 0x1A	; 26
    41ac:	19 4f       	sbci	r17, 0xF9	; 249
    41ae:	15 83       	std	Z+5, r17	; 0x05
    41b0:	04 83       	std	Z+4, r16	; 0x04
    41b2:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>

		 MOPType=MOP_CASH;
    41b6:	10 92 ba 01 	sts	0x01BA, r1
	     IsPrinting=True;	 
    41ba:	81 e0       	ldi	r24, 0x01	; 1
    41bc:	80 93 af 01 	sts	0x01AF, r24
    41c0:	ed b7       	in	r30, 0x3d	; 61
    41c2:	fe b7       	in	r31, 0x3e	; 62
    41c4:	36 96       	adiw	r30, 0x06	; 6
    41c6:	0f b6       	in	r0, 0x3f	; 63
    41c8:	f8 94       	cli
    41ca:	fe bf       	out	0x3e, r31	; 62
    41cc:	0f be       	out	0x3f, r0	; 63
    41ce:	ed bf       	out	0x3d, r30	; 61
	 }
	 //ProductName	 
	 //iProdID=PNozzle[RecPumpData[iPumpID].Nozzle];
	 //BAsedOnGrade
   return Result;
}
    41d0:	2f 96       	adiw	r28, 0x0f	; 15
    41d2:	0f b6       	in	r0, 0x3f	; 63
    41d4:	f8 94       	cli
    41d6:	de bf       	out	0x3e, r29	; 62
    41d8:	0f be       	out	0x3f, r0	; 63
    41da:	cd bf       	out	0x3d, r28	; 61
    41dc:	cf 91       	pop	r28
    41de:	df 91       	pop	r29
    41e0:	1f 91       	pop	r17
    41e2:	0f 91       	pop	r16
    41e4:	ff 90       	pop	r15
    41e6:	ef 90       	pop	r14
    41e8:	df 90       	pop	r13
    41ea:	cf 90       	pop	r12
    41ec:	08 95       	ret

000041ee <PrintStandalone>:
     char Result=PS_NONE;

   return Result;
}

char PrintStandalone(char FIPAddr,char IsReprint){
    41ee:	ef 92       	push	r14
    41f0:	ff 92       	push	r15
    41f2:	0f 93       	push	r16
    41f4:	1f 93       	push	r17
    41f6:	df 93       	push	r29
    41f8:	cf 93       	push	r28
    41fa:	00 d0       	rcall	.+0      	; 0x41fc <PrintStandalone+0xe>
    41fc:	00 d0       	rcall	.+0      	; 0x41fe <PrintStandalone+0x10>
    41fe:	00 d0       	rcall	.+0      	; 0x4200 <PrintStandalone+0x12>
    4200:	cd b7       	in	r28, 0x3d	; 61
    4202:	de b7       	in	r29, 0x3e	; 62
    4204:	f8 2e       	mov	r15, r24
    4206:	06 2f       	mov	r16, r22
	 char LFIPAddr;
	      
	 Result=PS_NO_DATA;

//	 eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap, 8);
	 iPumpID=GetPumpID(FIPAddr);//PPumpID[FIPAddr-1];
    4208:	0e 94 d6 1d 	call	0x3bac	; 0x3bac <GetPumpID>
    420c:	e8 2e       	mov	r14, r24
     LFIPAddr=GetFIPAddr(iPumpID);
    420e:	0e 94 41 1d 	call	0x3a82	; 0x3a82 <GetFIPAddr>
    4212:	18 2f       	mov	r17, r24

     if (LFIPAddr>0){
    4214:	88 23       	and	r24, r24
    4216:	99 f1       	breq	.+102    	; 0x427e <PrintStandalone+0x90>
	     LFIPAddr=LFIPAddr-1;
	     if ((IsReprint==True)||(iPumpID>0)&&(strPumpStatus[LFIPAddr]==GetPumpStatusLabel(PS_PRINT_READY))){    	 
    4218:	01 30       	cpi	r16, 0x01	; 1
    421a:	69 f0       	breq	.+26     	; 0x4236 <PrintStandalone+0x48>
    421c:	ee 20       	and	r14, r14
    421e:	79 f1       	breq	.+94     	; 0x427e <PrintStandalone+0x90>
    4220:	80 e1       	ldi	r24, 0x10	; 16
    4222:	0e 94 7d 13 	call	0x26fa	; 0x26fa <GetPumpStatusLabel>
    4226:	11 50       	subi	r17, 0x01	; 1
    4228:	e1 2f       	mov	r30, r17
    422a:	f0 e0       	ldi	r31, 0x00	; 0
    422c:	ee 5f       	subi	r30, 0xFE	; 254
    422e:	fe 4f       	sbci	r31, 0xFE	; 254
    4230:	90 81       	ld	r25, Z
    4232:	98 17       	cp	r25, r24
    4234:	21 f5       	brne	.+72     	; 0x427e <PrintStandalone+0x90>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    4236:	66 e0       	ldi	r22, 0x06	; 6
    4238:	f6 9e       	mul	r15, r22
    423a:	b0 01       	movw	r22, r0
    423c:	11 24       	eor	r1, r1
    423e:	61 5b       	subi	r22, 0xB1	; 177
    4240:	7f 4f       	sbci	r23, 0xFF	; 255
    4242:	ce 01       	movw	r24, r28
    4244:	01 96       	adiw	r24, 0x01	; 1
    4246:	46 e0       	ldi	r20, 0x06	; 6
    4248:	50 e0       	ldi	r21, 0x00	; 0
    424a:	2d ef       	ldi	r18, 0xFD	; 253
    424c:	32 e1       	ldi	r19, 0x12	; 18
    424e:	0e 94 f1 b3 	call	0x167e2	; 0x167e2 <__eerd_block>
		     eeprom_read_block((void*) &PProductID, (const void*) &DefNozzleMap[FIPAddr-1], 6);		 
		     if (((ReprintReady[FIPAddr-1]==True))||(IsReprint==False)){
    4252:	ef 2d       	mov	r30, r15
    4254:	f0 e0       	ldi	r31, 0x00	; 0
    4256:	ef 58       	subi	r30, 0x8F	; 143
    4258:	fe 4f       	sbci	r31, 0xFE	; 254
    425a:	80 81       	ld	r24, Z
    425c:	81 30       	cpi	r24, 0x01	; 1
    425e:	19 f0       	breq	.+6      	; 0x4266 <PrintStandalone+0x78>
    4260:	00 23       	and	r16, r16
    4262:	29 f0       	breq	.+10     	; 0x426e <PrintStandalone+0x80>
    4264:	0c c0       	rjmp	.+24     	; 0x427e <PrintStandalone+0x90>
			       if (IsReprint==True)IsReprintTicket=True;
    4266:	01 30       	cpi	r16, 0x01	; 1
    4268:	11 f4       	brne	.+4      	; 0x426e <PrintStandalone+0x80>
    426a:	00 93 82 01 	sts	0x0182, r16
			       GenerateStandaloneTransData(iPumpID,PProductID);		 			   
    426e:	8e 2d       	mov	r24, r14
    4270:	be 01       	movw	r22, r28
    4272:	6f 5f       	subi	r22, 0xFF	; 255
    4274:	7f 4f       	sbci	r23, 0xFF	; 255
    4276:	0e 94 a3 1f 	call	0x3f46	; 0x3f46 <GenerateStandaloneTransData>
    427a:	81 e1       	ldi	r24, 0x11	; 17
    427c:	01 c0       	rjmp	.+2      	; 0x4280 <PrintStandalone+0x92>
    427e:	82 e1       	ldi	r24, 0x12	; 18
			 }//else Result=PS_NO_DATA;
		 }
		 //else Result=PS_NO_DATA;    		    
	 }	
   return Result;
}
    4280:	26 96       	adiw	r28, 0x06	; 6
    4282:	0f b6       	in	r0, 0x3f	; 63
    4284:	f8 94       	cli
    4286:	de bf       	out	0x3e, r29	; 62
    4288:	0f be       	out	0x3f, r0	; 63
    428a:	cd bf       	out	0x3d, r28	; 61
    428c:	cf 91       	pop	r28
    428e:	df 91       	pop	r29
    4290:	1f 91       	pop	r17
    4292:	0f 91       	pop	r16
    4294:	ff 90       	pop	r15
    4296:	ef 90       	pop	r14
    4298:	08 95       	ret

0000429a <SumChecksum>:
	Geniflow[1]=Geniflow[0];
	Geniflow[0]=dataIn;
*/
}

char SumChecksum(char *strChecked){
    429a:	ac 01       	movw	r20, r24
     unsigned int SigmaSum=0;
	 char i,Result;
	 for(i=0;i<strlen(strChecked);i++){
    429c:	dc 01       	movw	r26, r24
    429e:	0d 90       	ld	r0, X+
    42a0:	00 20       	and	r0, r0
    42a2:	e9 f7       	brne	.-6      	; 0x429e <SumChecksum+0x4>
    42a4:	11 97       	sbiw	r26, 0x01	; 1
    42a6:	a8 1b       	sub	r26, r24
    42a8:	b9 0b       	sbc	r27, r25
    42aa:	20 e0       	ldi	r18, 0x00	; 0
    42ac:	30 e0       	ldi	r19, 0x00	; 0
    42ae:	90 e0       	ldi	r25, 0x00	; 0
    42b0:	06 c0       	rjmp	.+12     	; 0x42be <SumChecksum+0x24>
	     SigmaSum=SigmaSum+strChecked[i];
    42b2:	e4 0f       	add	r30, r20
    42b4:	f5 1f       	adc	r31, r21
    42b6:	80 81       	ld	r24, Z
    42b8:	28 0f       	add	r18, r24
    42ba:	31 1d       	adc	r19, r1
}

char SumChecksum(char *strChecked){
     unsigned int SigmaSum=0;
	 char i,Result;
	 for(i=0;i<strlen(strChecked);i++){
    42bc:	9f 5f       	subi	r25, 0xFF	; 255
    42be:	e9 2f       	mov	r30, r25
    42c0:	f0 e0       	ldi	r31, 0x00	; 0
    42c2:	ea 17       	cp	r30, r26
    42c4:	fb 07       	cpc	r31, r27
    42c6:	a8 f3       	brcs	.-22     	; 0x42b2 <SumChecksum+0x18>
	     SigmaSum=SigmaSum+strChecked[i];
	 }
	 Result=(SigmaSum%255);
    42c8:	c9 01       	movw	r24, r18
    42ca:	6f ef       	ldi	r22, 0xFF	; 255
    42cc:	70 e0       	ldi	r23, 0x00	; 0
    42ce:	0e 94 0a b7 	call	0x16e14	; 0x16e14 <__udivmodhi4>
	 if (Result==0)Result=255;
    42d2:	88 23       	and	r24, r24
    42d4:	09 f4       	brne	.+2      	; 0x42d8 <SumChecksum+0x3e>
    42d6:	8f ef       	ldi	r24, 0xFF	; 255
   return Result;
}
    42d8:	08 95       	ret

000042da <IsGeniusCommand>:
	 sprintf_P(strSend,PSTR("%s"),sCSum);
	 _uart_print(1,1,strSend);
*/
}

char IsGeniusCommand(char GCommand){
    42da:	ff 92       	push	r15
    42dc:	0f 93       	push	r16
    42de:	1f 93       	push	r17
    42e0:	df 93       	push	r29
    42e2:	cf 93       	push	r28
    42e4:	cd b7       	in	r28, 0x3d	; 61
    42e6:	de b7       	in	r29, 0x3e	; 62
    42e8:	2a 97       	sbiw	r28, 0x0a	; 10
    42ea:	0f b6       	in	r0, 0x3f	; 63
    42ec:	f8 94       	cli
    42ee:	de bf       	out	0x3e, r29	; 62
    42f0:	0f be       	out	0x3f, r0	; 63
    42f2:	cd bf       	out	0x3d, r28	; 61
    42f4:	f8 2e       	mov	r15, r24
     char i,Result,CommandList[10];
     Result=False;
	 sprintf_P(CommandList,PSTR("CTSRP"));
    42f6:	00 d0       	rcall	.+0      	; 0x42f8 <IsGeniusCommand+0x1e>
    42f8:	00 d0       	rcall	.+0      	; 0x42fa <IsGeniusCommand+0x20>
    42fa:	8e 01       	movw	r16, r28
    42fc:	0f 5f       	subi	r16, 0xFF	; 255
    42fe:	1f 4f       	sbci	r17, 0xFF	; 255
    4300:	ed b7       	in	r30, 0x3d	; 61
    4302:	fe b7       	in	r31, 0x3e	; 62
    4304:	12 83       	std	Z+2, r17	; 0x02
    4306:	01 83       	std	Z+1, r16	; 0x01
    4308:	82 e4       	ldi	r24, 0x42	; 66
    430a:	93 e0       	ldi	r25, 0x03	; 3
    430c:	94 83       	std	Z+4, r25	; 0x04
    430e:	83 83       	std	Z+3, r24	; 0x03
    4310:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
	 for(i=0;i<strlen(CommandList);i++){
    4314:	d8 01       	movw	r26, r16
    4316:	0d 90       	ld	r0, X+
    4318:	00 20       	and	r0, r0
    431a:	e9 f7       	brne	.-6      	; 0x4316 <IsGeniusCommand+0x3c>
    431c:	11 97       	sbiw	r26, 0x01	; 1
    431e:	a0 1b       	sub	r26, r16
    4320:	b1 0b       	sbc	r27, r17
    4322:	90 e0       	ldi	r25, 0x00	; 0
    4324:	0f 90       	pop	r0
    4326:	0f 90       	pop	r0
    4328:	0f 90       	pop	r0
    432a:	0f 90       	pop	r0
	    if (CommandList[i]==GCommand){
    432c:	98 01       	movw	r18, r16
    432e:	08 c0       	rjmp	.+16     	; 0x4340 <IsGeniusCommand+0x66>
    4330:	e2 0f       	add	r30, r18
    4332:	f3 1f       	adc	r31, r19
    4334:	80 81       	ld	r24, Z
    4336:	8f 15       	cp	r24, r15
    4338:	11 f4       	brne	.+4      	; 0x433e <IsGeniusCommand+0x64>
    433a:	81 e0       	ldi	r24, 0x01	; 1
    433c:	07 c0       	rjmp	.+14     	; 0x434c <IsGeniusCommand+0x72>

char IsGeniusCommand(char GCommand){
     char i,Result,CommandList[10];
     Result=False;
	 sprintf_P(CommandList,PSTR("CTSRP"));
	 for(i=0;i<strlen(CommandList);i++){
    433e:	9f 5f       	subi	r25, 0xFF	; 255
    4340:	e9 2f       	mov	r30, r25
    4342:	f0 e0       	ldi	r31, 0x00	; 0
    4344:	ea 17       	cp	r30, r26
    4346:	fb 07       	cpc	r31, r27
    4348:	98 f3       	brcs	.-26     	; 0x4330 <IsGeniusCommand+0x56>
    434a:	80 e0       	ldi	r24, 0x00	; 0
		    Result=True;
			break;
			}
	 }
   return Result;	 
}
    434c:	2a 96       	adiw	r28, 0x0a	; 10
    434e:	0f b6       	in	r0, 0x3f	; 63
    4350:	f8 94       	cli
    4352:	de bf       	out	0x3e, r29	; 62
    4354:	0f be       	out	0x3f, r0	; 63
    4356:	cd bf       	out	0x3d, r28	; 61
    4358:	cf 91       	pop	r28
    435a:	df 91       	pop	r29
    435c:	1f 91       	pop	r17
    435e:	0f 91       	pop	r16
    4360:	ff 90       	pop	r15
    4362:	08 95       	ret

00004364 <Pos>:
  return Result;
}
		

//Genius Protocol Version:1.0 AKR
int Pos(char *Substr, char *String){//1245:4645
    4364:	0f 93       	push	r16
    4366:	1f 93       	push	r17
    4368:	cf 93       	push	r28
    436a:	df 93       	push	r29
    436c:	ac 01       	movw	r20, r24
    char i,j,CountMatch;
	char Length,subLen,PosFound;

	Length=strlen(String);
    436e:	fb 01       	movw	r30, r22
    4370:	01 90       	ld	r0, Z+
    4372:	00 20       	and	r0, r0
    4374:	e9 f7       	brne	.-6      	; 0x4370 <Pos+0xc>
    4376:	31 97       	sbiw	r30, 0x01	; 1
    4378:	1e 2f       	mov	r17, r30
    437a:	16 1b       	sub	r17, r22
	subLen=strlen(Substr);
    437c:	fc 01       	movw	r30, r24
    437e:	01 90       	ld	r0, Z+
    4380:	00 20       	and	r0, r0
    4382:	e9 f7       	brne	.-6      	; 0x437e <Pos+0x1a>
    4384:	31 97       	sbiw	r30, 0x01	; 1
    4386:	0e 2f       	mov	r16, r30
    4388:	08 1b       	sub	r16, r24
    438a:	db 01       	movw	r26, r22
    438c:	60 e0       	ldi	r22, 0x00	; 0
    438e:	18 c0       	rjmp	.+48     	; 0x43c0 <Pos+0x5c>
	PosFound=Length;
	for(i=0;i<Length;i++){
	    if (String[i]==Substr[0]){
    4390:	9c 91       	ld	r25, X
    4392:	fa 01       	movw	r30, r20
    4394:	80 81       	ld	r24, Z
    4396:	98 17       	cp	r25, r24
    4398:	89 f4       	brne	.+34     	; 0x43bc <Pos+0x58>
    439a:	ed 01       	movw	r28, r26
    439c:	20 e0       	ldi	r18, 0x00	; 0
    439e:	30 e0       	ldi	r19, 0x00	; 0
    43a0:	09 c0       	rjmp	.+18     	; 0x43b4 <Pos+0x50>
		    CountMatch=0;
			for(j=0;j<subLen;j++){
			    //notFound
			    if (Substr[j]==String[i+j]){
    43a2:	fa 01       	movw	r30, r20
    43a4:	e2 0f       	add	r30, r18
    43a6:	f3 1f       	adc	r31, r19
    43a8:	90 81       	ld	r25, Z
    43aa:	89 91       	ld	r24, Y+
    43ac:	2f 5f       	subi	r18, 0xFF	; 255
    43ae:	3f 4f       	sbci	r19, 0xFF	; 255
    43b0:	98 17       	cp	r25, r24
    43b2:	21 f4       	brne	.+8      	; 0x43bc <Pos+0x58>
	subLen=strlen(Substr);
	PosFound=Length;
	for(i=0;i<Length;i++){
	    if (String[i]==Substr[0]){
		    CountMatch=0;
			for(j=0;j<subLen;j++){
    43b4:	20 17       	cp	r18, r16
    43b6:	a8 f3       	brcs	.-22     	; 0x43a2 <Pos+0x3e>
    43b8:	86 2f       	mov	r24, r22
    43ba:	05 c0       	rjmp	.+10     	; 0x43c6 <Pos+0x62>
	char Length,subLen,PosFound;

	Length=strlen(String);
	subLen=strlen(Substr);
	PosFound=Length;
	for(i=0;i<Length;i++){
    43bc:	6f 5f       	subi	r22, 0xFF	; 255
    43be:	11 96       	adiw	r26, 0x01	; 1
    43c0:	61 17       	cp	r22, r17
    43c2:	30 f3       	brcs	.-52     	; 0x4390 <Pos+0x2c>
    43c4:	81 2f       	mov	r24, r17
			    break;  
			}
		}
	}
  return  PosFound;
}
    43c6:	90 e0       	ldi	r25, 0x00	; 0
    43c8:	df 91       	pop	r29
    43ca:	cf 91       	pop	r28
    43cc:	1f 91       	pop	r17
    43ce:	0f 91       	pop	r16
    43d0:	08 95       	ret

000043d2 <CreateReport>:
//		  }
//	 }
     *Pos=iPos;
}

void CreateReport(char *strData, char *strPrnBuffer, unsigned int *Pos){
    43d2:	7f 92       	push	r7
    43d4:	8f 92       	push	r8
    43d6:	9f 92       	push	r9
    43d8:	af 92       	push	r10
    43da:	bf 92       	push	r11
    43dc:	cf 92       	push	r12
    43de:	df 92       	push	r13
    43e0:	ef 92       	push	r14
    43e2:	ff 92       	push	r15
    43e4:	0f 93       	push	r16
    43e6:	1f 93       	push	r17
    43e8:	cf 93       	push	r28
    43ea:	df 93       	push	r29
    43ec:	5c 01       	movw	r10, r24
    43ee:	6b 01       	movw	r12, r22
    43f0:	4a 01       	movw	r8, r20
     unsigned int iPos,PosResult,Length;
	 char i,strSend[20];
	 Length=strlen(strData);
    43f2:	ec 01       	movw	r28, r24
    43f4:	09 90       	ld	r0, Y+
    43f6:	00 20       	and	r0, r0
    43f8:	e9 f7       	brne	.-6      	; 0x43f4 <CreateReport+0x22>
    43fa:	21 97       	sbiw	r28, 0x01	; 1
    43fc:	c8 1b       	sub	r28, r24
    43fe:	d9 0b       	sbc	r29, r25
    4400:	cb 32       	cpi	r28, 0x2B	; 43
    4402:	d1 05       	cpc	r29, r1
    4404:	10 f0       	brcs	.+4      	; 0x440a <CreateReport+0x38>
    4406:	ca e2       	ldi	r28, 0x2A	; 42
    4408:	d0 e0       	ldi	r29, 0x00	; 0
	 if (Length>BORDER_LENGTH)Length=BORDER_LENGTH;
     
	 iPos=*Pos;
    440a:	f4 01       	movw	r30, r8
    440c:	00 81       	ld	r16, Z
    440e:	11 81       	ldd	r17, Z+1	; 0x01
	 strPrnBuffer[iPos]=GetBorderValue(btVertical);
    4410:	76 01       	movw	r14, r12
    4412:	e0 0e       	add	r14, r16
    4414:	f1 1e       	adc	r15, r17
    4416:	8a e0       	ldi	r24, 0x0A	; 10
    4418:	0e 94 a5 19 	call	0x334a	; 0x334a <GetBorderValue>
    441c:	78 2e       	mov	r7, r24
    441e:	f7 01       	movw	r30, r14
    4420:	80 83       	st	Z, r24
     iPos++;
    4422:	98 01       	movw	r18, r16
    4424:	2f 5f       	subi	r18, 0xFF	; 255
    4426:	3f 4f       	sbci	r19, 0xFF	; 255
    4428:	d7 01       	movw	r26, r14
    442a:	90 e0       	ldi	r25, 0x00	; 0
    442c:	07 c0       	rjmp	.+14     	; 0x443c <CreateReport+0x6a>

	 for (i=0;i<Length;i++){	      
	      strPrnBuffer[iPos]=strData[i];	      	 
    442e:	ea 0d       	add	r30, r10
    4430:	fb 1d       	adc	r31, r11
    4432:	80 81       	ld	r24, Z
    4434:	8c 93       	st	X, r24
		  iPos++;
    4436:	2f 5f       	subi	r18, 0xFF	; 255
    4438:	3f 4f       	sbci	r19, 0xFF	; 255
     
	 iPos=*Pos;
	 strPrnBuffer[iPos]=GetBorderValue(btVertical);
     iPos++;

	 for (i=0;i<Length;i++){	      
    443a:	9f 5f       	subi	r25, 0xFF	; 255
    443c:	e9 2f       	mov	r30, r25
    443e:	f0 e0       	ldi	r31, 0x00	; 0
    4440:	11 96       	adiw	r26, 0x01	; 1
    4442:	ec 17       	cp	r30, r28
    4444:	fd 07       	cpc	r31, r29
    4446:	98 f3       	brcs	.-26     	; 0x442e <CreateReport+0x5c>
    4448:	62 2f       	mov	r22, r18
	      strPrnBuffer[iPos]=strData[i];	      	 
		  iPos++;
	 }
	 if (Length<BORDER_LENGTH){
    444a:	ca 32       	cpi	r28, 0x2A	; 42
    444c:	d1 05       	cpc	r29, r1
    444e:	91 f0       	breq	.+36     	; 0x4474 <CreateReport+0xa2>
    4450:	f6 01       	movw	r30, r12
    4452:	e2 0f       	add	r30, r18
    4454:	f3 1f       	adc	r31, r19
	     for (i=0;i<(BORDER_LENGTH-Length);i++){	      
    4456:	4a e2       	ldi	r20, 0x2A	; 42
    4458:	50 e0       	ldi	r21, 0x00	; 0
    445a:	4c 1b       	sub	r20, r28
    445c:	5d 0b       	sbc	r21, r29
	          strPrnBuffer[iPos]=' ';
    445e:	70 e2       	ldi	r23, 0x20	; 32
    4460:	03 c0       	rjmp	.+6      	; 0x4468 <CreateReport+0x96>
    4462:	71 93       	st	Z+, r23
		      iPos++;
    4464:	2f 5f       	subi	r18, 0xFF	; 255
    4466:	3f 4f       	sbci	r19, 0xFF	; 255
	 for (i=0;i<Length;i++){	      
	      strPrnBuffer[iPos]=strData[i];	      	 
		  iPos++;
	 }
	 if (Length<BORDER_LENGTH){
	     for (i=0;i<(BORDER_LENGTH-Length);i++){	      
    4468:	82 2f       	mov	r24, r18
    446a:	86 1b       	sub	r24, r22
    446c:	90 e0       	ldi	r25, 0x00	; 0
    446e:	84 17       	cp	r24, r20
    4470:	95 07       	cpc	r25, r21
    4472:	b8 f3       	brcs	.-18     	; 0x4462 <CreateReport+0x90>
	          strPrnBuffer[iPos]=' ';
		      iPos++;
	     }	    
	 }
	 strPrnBuffer[iPos]=GetBorderValue(btVertical);
    4474:	f6 01       	movw	r30, r12
    4476:	e2 0f       	add	r30, r18
    4478:	f3 1f       	adc	r31, r19
    447a:	70 82       	st	Z, r7
     iPos++;
    447c:	c9 01       	movw	r24, r18
    447e:	01 96       	adiw	r24, 0x01	; 1
     //PosResult=*Pos+Length;
	 strPrnBuffer[iPos]=0x0D; 
    4480:	c8 0e       	add	r12, r24
    4482:	d9 1e       	adc	r13, r25
    4484:	2d e0       	ldi	r18, 0x0D	; 13
    4486:	f6 01       	movw	r30, r12
    4488:	20 83       	st	Z, r18
	 iPos++;

   //*Pos=PosResult+1;
   *Pos=iPos;
    448a:	01 96       	adiw	r24, 0x01	; 1
    448c:	f4 01       	movw	r30, r8
    448e:	91 83       	std	Z+1, r25	; 0x01
    4490:	80 83       	st	Z, r24
    //sprintf_P(strSend,PSTR("Pos:%d"),*Pos);
	//_uart_print(0,1,strSend);
}
    4492:	df 91       	pop	r29
    4494:	cf 91       	pop	r28
    4496:	1f 91       	pop	r17
    4498:	0f 91       	pop	r16
    449a:	ff 90       	pop	r15
    449c:	ef 90       	pop	r14
    449e:	df 90       	pop	r13
    44a0:	cf 90       	pop	r12
    44a2:	bf 90       	pop	r11
    44a4:	af 90       	pop	r10
    44a6:	9f 90       	pop	r9
    44a8:	8f 90       	pop	r8
    44aa:	7f 90       	pop	r7
    44ac:	08 95       	ret

000044ae <AddList>:

//AddListTotal(xGrade,strRef1);
void ClearList(char *strList){
     FillChar(strList,strlen(strList),0);
}
void AddList(char GradeId, char *strList){
    44ae:	38 2f       	mov	r19, r24
    44b0:	ab 01       	movw	r20, r22
     char i,iPos,Length,IsFound=False;	 
	 if ((GradeId>=1)&&((GradeId<=6))){
    44b2:	81 50       	subi	r24, 0x01	; 1
    44b4:	86 30       	cpi	r24, 0x06	; 6
    44b6:	68 f5       	brcc	.+90     	; 0x4512 <AddList+0x64>
		 iPos=0;
		 IsFound=False;	
		 Length=strlen(strList);
    44b8:	fb 01       	movw	r30, r22
    44ba:	01 90       	ld	r0, Z+
    44bc:	00 20       	and	r0, r0
    44be:	e9 f7       	brne	.-6      	; 0x44ba <AddList+0xc>
    44c0:	31 97       	sbiw	r30, 0x01	; 1
    44c2:	e6 1b       	sub	r30, r22
    44c4:	f7 0b       	sbc	r31, r23
    44c6:	7e 2f       	mov	r23, r30
	     if (Length>0){
    44c8:	ee 23       	and	r30, r30
    44ca:	11 f4       	brne	.+4      	; 0x44d0 <AddList+0x22>
    44cc:	20 e0       	ldi	r18, 0x00	; 0
    44ce:	14 c0       	rjmp	.+40     	; 0x44f8 <AddList+0x4a>
    44d0:	80 e0       	ldi	r24, 0x00	; 0
    44d2:	90 e0       	ldi	r25, 0x00	; 0
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
	    Result='0'+X;
    44d4:	63 2f       	mov	r22, r19
    44d6:	60 5d       	subi	r22, 0xD0	; 208
		 Length=strlen(strList);
	     if (Length>0){
			 for (i=0;i<Length;i++){//"123"
			      //_uart(1,1,strList[i]);
			      iPos++;
			      if (strList[i]==Chr(GradeId)){
    44d8:	fa 01       	movw	r30, r20
    44da:	e8 0f       	add	r30, r24
    44dc:	f9 1f       	adc	r31, r25
    44de:	e0 81       	ld	r30, Z
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    44e0:	3a 30       	cpi	r19, 0x0A	; 10
    44e2:	10 f0       	brcs	.+4      	; 0x44e8 <AddList+0x3a>
    44e4:	20 e3       	ldi	r18, 0x30	; 48
    44e6:	01 c0       	rjmp	.+2      	; 0x44ea <AddList+0x3c>
	    Result='0'+X;
    44e8:	26 2f       	mov	r18, r22
		 Length=strlen(strList);
	     if (Length>0){
			 for (i=0;i<Length;i++){//"123"
			      //_uart(1,1,strList[i]);
			      iPos++;
			      if (strList[i]==Chr(GradeId)){
    44ea:	e2 17       	cp	r30, r18
    44ec:	91 f0       	breq	.+36     	; 0x4512 <AddList+0x64>
    44ee:	28 2f       	mov	r18, r24
    44f0:	2f 5f       	subi	r18, 0xFF	; 255
    44f2:	01 96       	adiw	r24, 0x01	; 1
	 if ((GradeId>=1)&&((GradeId<=6))){
		 iPos=0;
		 IsFound=False;	
		 Length=strlen(strList);
	     if (Length>0){
			 for (i=0;i<Length;i++){//"123"
    44f4:	87 17       	cp	r24, r23
    44f6:	80 f3       	brcs	.-32     	; 0x44d8 <AddList+0x2a>
					  break;
				  }
			 }
	     }
		 if (IsFound==False){
		     strList[iPos]=Chr(GradeId);
    44f8:	62 2f       	mov	r22, r18
    44fa:	70 e0       	ldi	r23, 0x00	; 0
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    44fc:	3a 30       	cpi	r19, 0x0A	; 10
    44fe:	10 f0       	brcs	.+4      	; 0x4504 <AddList+0x56>
    4500:	80 e3       	ldi	r24, 0x30	; 48
    4502:	02 c0       	rjmp	.+4      	; 0x4508 <AddList+0x5a>
	    Result='0'+X;
    4504:	83 2f       	mov	r24, r19
    4506:	80 5d       	subi	r24, 0xD0	; 208
					  break;
				  }
			 }
	     }
		 if (IsFound==False){
		     strList[iPos]=Chr(GradeId);
    4508:	fa 01       	movw	r30, r20
    450a:	e6 0f       	add	r30, r22
    450c:	f7 1f       	adc	r31, r23
    450e:	80 83       	st	Z, r24
		     strList[iPos+1]=0;
    4510:	11 82       	std	Z+1, r1	; 0x01
    4512:	08 95       	ret

00004514 <ClearList>:
	 AddSpaceLag(strProductName,10);
}

//AddListTotal(xGrade,strRef1);
void ClearList(char *strList){
     FillChar(strList,strlen(strList),0);
    4514:	dc 01       	movw	r26, r24
    4516:	0d 90       	ld	r0, X+
    4518:	00 20       	and	r0, r0
    451a:	e9 f7       	brne	.-6      	; 0x4516 <ClearList+0x2>
    451c:	11 97       	sbiw	r26, 0x01	; 1
    451e:	a8 1b       	sub	r26, r24
    4520:	b9 0b       	sbc	r27, r25
    4522:	20 e0       	ldi	r18, 0x00	; 0
    4524:	30 e0       	ldi	r19, 0x00	; 0
    4526:	06 c0       	rjmp	.+12     	; 0x4534 <ClearList+0x20>
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    4528:	fc 01       	movw	r30, r24
    452a:	e2 0f       	add	r30, r18
    452c:	f3 1f       	adc	r31, r19
    452e:	10 82       	st	Z, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    4530:	2f 5f       	subi	r18, 0xFF	; 255
    4532:	3f 4f       	sbci	r19, 0xFF	; 255
    4534:	2a 17       	cp	r18, r26
    4536:	3b 07       	cpc	r19, r27
    4538:	b8 f3       	brcs	.-18     	; 0x4528 <ClearList+0x14>
}

//AddListTotal(xGrade,strRef1);
void ClearList(char *strList){
     FillChar(strList,strlen(strList),0);
}
    453a:	08 95       	ret

0000453c <CalcSegmen>:
		 */
		 CalcMultiply(strA,strB,strC);
	 }
}

void CalcSegmen(char *strMain, char cNum, char *strResult){
    453c:	6f 92       	push	r6
    453e:	7f 92       	push	r7
    4540:	8f 92       	push	r8
    4542:	9f 92       	push	r9
    4544:	bf 92       	push	r11
    4546:	cf 92       	push	r12
    4548:	df 92       	push	r13
    454a:	ef 92       	push	r14
    454c:	ff 92       	push	r15
    454e:	0f 93       	push	r16
    4550:	1f 93       	push	r17
    4552:	df 93       	push	r29
    4554:	cf 93       	push	r28
    4556:	cd b7       	in	r28, 0x3d	; 61
    4558:	de b7       	in	r29, 0x3e	; 62
    455a:	64 97       	sbiw	r28, 0x14	; 20
    455c:	0f b6       	in	r0, 0x3f	; 63
    455e:	f8 94       	cli
    4560:	de bf       	out	0x3e, r29	; 62
    4562:	0f be       	out	0x3f, r0	; 63
    4564:	cd bf       	out	0x3d, r28	; 61
    4566:	7c 01       	movw	r14, r24
    4568:	6a 01       	movw	r12, r20
    456a:	bb 24       	eor	r11, r11
    456c:	30 e0       	ldi	r19, 0x00	; 0

	 xResNext=0;
     xRes=0;

	 for(i=0;i<strlen(strMain);i++){           
         xCalc=(strMain[strlen(strMain)-1-i]-'0')*(cNum-'0')+xResNext;//Hasil
    456e:	06 2f       	mov	r16, r22
    4570:	10 e0       	ldi	r17, 0x00	; 0
    4572:	00 53       	subi	r16, 0x30	; 48
    4574:	10 40       	sbci	r17, 0x00	; 0
		 xRes=xCalc%10;
		 xResNext=xCalc/10;
	     tmpResult[i]='0'+xRes;	 
    4576:	3e 01       	movw	r6, r28
    4578:	08 94       	sec
    457a:	61 1c       	adc	r6, r1
    457c:	71 1c       	adc	r7, r1
		 tmpResult[i+1]=0;
    457e:	72 e0       	ldi	r23, 0x02	; 2
    4580:	87 2e       	mov	r8, r23
    4582:	91 2c       	mov	r9, r1
    4584:	8c 0e       	add	r8, r28
    4586:	9d 1e       	adc	r9, r29
    4588:	24 c0       	rjmp	.+72     	; 0x45d2 <CalcSegmen+0x96>

	 xResNext=0;
     xRes=0;

	 for(i=0;i<strlen(strMain);i++){           
         xCalc=(strMain[strlen(strMain)-1-i]-'0')*(cNum-'0')+xResNext;//Hasil
    458a:	11 97       	sbiw	r26, 0x01	; 1
    458c:	a4 1b       	sub	r26, r20
    458e:	b5 0b       	sbc	r27, r21
    4590:	ae 0d       	add	r26, r14
    4592:	bf 1d       	adc	r27, r15
    4594:	8c 91       	ld	r24, X
    4596:	90 e0       	ldi	r25, 0x00	; 0
    4598:	c0 97       	sbiw	r24, 0x30	; 48
    459a:	bc 01       	movw	r22, r24
    459c:	60 9f       	mul	r22, r16
    459e:	c0 01       	movw	r24, r0
    45a0:	61 9f       	mul	r22, r17
    45a2:	90 0d       	add	r25, r0
    45a4:	70 9f       	mul	r23, r16
    45a6:	90 0d       	add	r25, r0
    45a8:	11 24       	eor	r1, r1
    45aa:	23 2f       	mov	r18, r19
    45ac:	28 0f       	add	r18, r24
		 xRes=xCalc%10;
		 xResNext=xCalc/10;
    45ae:	82 2f       	mov	r24, r18
    45b0:	6a e0       	ldi	r22, 0x0A	; 10
    45b2:	0e 94 f1 b6 	call	0x16de2	; 0x16de2 <__udivmodqi4>
    45b6:	38 2f       	mov	r19, r24
	     tmpResult[i]='0'+xRes;	 
    45b8:	f3 01       	movw	r30, r6
    45ba:	e4 0f       	add	r30, r20
    45bc:	f5 1f       	adc	r31, r21
    45be:	82 2f       	mov	r24, r18
    45c0:	0e 94 f1 b6 	call	0x16de2	; 0x16de2 <__udivmodqi4>
    45c4:	90 5d       	subi	r25, 0xD0	; 208
    45c6:	90 83       	st	Z, r25
		 tmpResult[i+1]=0;
    45c8:	48 0d       	add	r20, r8
    45ca:	59 1d       	adc	r21, r9
    45cc:	fa 01       	movw	r30, r20
    45ce:	10 82       	st	Z, r1
	 char i,lenR,xCalc,xRes,xResNext,tmpResult[20];

	 xResNext=0;
     xRes=0;

	 for(i=0;i<strlen(strMain);i++){           
    45d0:	b3 94       	inc	r11
    45d2:	4b 2d       	mov	r20, r11
    45d4:	50 e0       	ldi	r21, 0x00	; 0
    45d6:	d7 01       	movw	r26, r14
    45d8:	0d 90       	ld	r0, X+
    45da:	00 20       	and	r0, r0
    45dc:	e9 f7       	brne	.-6      	; 0x45d8 <CalcSegmen+0x9c>
    45de:	11 97       	sbiw	r26, 0x01	; 1
    45e0:	ae 19       	sub	r26, r14
    45e2:	bf 09       	sbc	r27, r15
    45e4:	4a 17       	cp	r20, r26
    45e6:	5b 07       	cpc	r21, r27
    45e8:	80 f2       	brcs	.-96     	; 0x458a <CalcSegmen+0x4e>
		 xRes=xCalc%10;
		 xResNext=xCalc/10;
	     tmpResult[i]='0'+xRes;	 
		 tmpResult[i+1]=0;
	 }
	 if (xResNext>0){
    45ea:	33 23       	and	r19, r19
    45ec:	89 f0       	breq	.+34     	; 0x4610 <CalcSegmen+0xd4>
	     lenR=strlen(tmpResult);
    45ee:	fe 01       	movw	r30, r28
    45f0:	31 96       	adiw	r30, 0x01	; 1
    45f2:	df 01       	movw	r26, r30
    45f4:	0d 90       	ld	r0, X+
    45f6:	00 20       	and	r0, r0
    45f8:	e9 f7       	brne	.-6      	; 0x45f4 <CalcSegmen+0xb8>
    45fa:	11 97       	sbiw	r26, 0x01	; 1
	     tmpResult[lenR]='0'+xResNext;
    45fc:	ae 1b       	sub	r26, r30
    45fe:	b0 e0       	ldi	r27, 0x00	; 0
    4600:	ea 0f       	add	r30, r26
    4602:	fb 1f       	adc	r31, r27
    4604:	30 5d       	subi	r19, 0xD0	; 208
    4606:	30 83       	st	Z, r19
		 tmpResult[lenR+1]=0;	 
    4608:	ac 0f       	add	r26, r28
    460a:	bd 1f       	adc	r27, r29
    460c:	12 96       	adiw	r26, 0x02	; 2
    460e:	1c 92       	st	X, r1
	 }
	 lenR=strlen(tmpResult);
    4610:	de 01       	movw	r26, r28
    4612:	11 96       	adiw	r26, 0x01	; 1
    4614:	fd 01       	movw	r30, r26
    4616:	01 90       	ld	r0, Z+
    4618:	00 20       	and	r0, r0
    461a:	e9 f7       	brne	.-6      	; 0x4616 <CalcSegmen+0xda>
    461c:	31 97       	sbiw	r30, 0x01	; 1
    461e:	9e 2f       	mov	r25, r30
    4620:	9a 1b       	sub	r25, r26
    4622:	a9 0f       	add	r26, r25
    4624:	b1 1d       	adc	r27, r1
    4626:	f6 01       	movw	r30, r12
    4628:	02 c0       	rjmp	.+4      	; 0x462e <CalcSegmen+0xf2>
	 for (i=0;i<lenR;i++){
	     strResult[i]=tmpResult[lenR-1-i];
    462a:	8c 91       	ld	r24, X
    462c:	81 93       	st	Z+, r24
    462e:	11 97       	sbiw	r26, 0x01	; 1
	     lenR=strlen(tmpResult);
	     tmpResult[lenR]='0'+xResNext;
		 tmpResult[lenR+1]=0;	 
	 }
	 lenR=strlen(tmpResult);
	 for (i=0;i<lenR;i++){
    4630:	ac 17       	cp	r26, r28
    4632:	bd 07       	cpc	r27, r29
    4634:	d1 f7       	brne	.-12     	; 0x462a <CalcSegmen+0xee>
	     strResult[i]=tmpResult[lenR-1-i];
	 }
	 strResult[lenR]=0;
    4636:	c9 0e       	add	r12, r25
    4638:	d1 1c       	adc	r13, r1
    463a:	f6 01       	movw	r30, r12
    463c:	10 82       	st	Z, r1
}
    463e:	64 96       	adiw	r28, 0x14	; 20
    4640:	0f b6       	in	r0, 0x3f	; 63
    4642:	f8 94       	cli
    4644:	de bf       	out	0x3e, r29	; 62
    4646:	0f be       	out	0x3f, r0	; 63
    4648:	cd bf       	out	0x3d, r28	; 61
    464a:	cf 91       	pop	r28
    464c:	df 91       	pop	r29
    464e:	1f 91       	pop	r17
    4650:	0f 91       	pop	r16
    4652:	ff 90       	pop	r15
    4654:	ef 90       	pop	r14
    4656:	df 90       	pop	r13
    4658:	cf 90       	pop	r12
    465a:	bf 90       	pop	r11
    465c:	9f 90       	pop	r9
    465e:	8f 90       	pop	r8
    4660:	7f 90       	pop	r7
    4662:	6f 90       	pop	r6
    4664:	08 95       	ret

00004666 <GetMinusPos>:
		  if (KeyChar=='*')stTestCalc=tcInitData;
	      break;	 
	 }
}

char GetMinusPos(char *strNumber){
    4666:	ac 01       	movw	r20, r24
char i,Result;
     Result=0;
     for(i=0;i<strlen(strNumber);i++){
    4668:	dc 01       	movw	r26, r24
    466a:	0d 90       	ld	r0, X+
    466c:	00 20       	and	r0, r0
    466e:	e9 f7       	brne	.-6      	; 0x466a <GetMinusPos+0x4>
    4670:	11 97       	sbiw	r26, 0x01	; 1
    4672:	a8 1b       	sub	r26, r24
    4674:	b9 0b       	sbc	r27, r25
    4676:	20 e0       	ldi	r18, 0x00	; 0
    4678:	0a c0       	rjmp	.+20     	; 0x468e <GetMinusPos+0x28>
	     if (strNumber[i]=='-'){
    467a:	e4 0f       	add	r30, r20
    467c:	f5 1f       	adc	r31, r21
    467e:	80 81       	ld	r24, Z
    4680:	92 2f       	mov	r25, r18
    4682:	9f 5f       	subi	r25, 0xFF	; 255
    4684:	8d 32       	cpi	r24, 0x2D	; 45
    4686:	11 f4       	brne	.+4      	; 0x468c <GetMinusPos+0x26>
		     Result=i+1;
    4688:	89 2f       	mov	r24, r25
    468a:	08 95       	ret
}

char GetMinusPos(char *strNumber){
char i,Result;
     Result=0;
     for(i=0;i<strlen(strNumber);i++){
    468c:	29 2f       	mov	r18, r25
    468e:	e2 2f       	mov	r30, r18
    4690:	f0 e0       	ldi	r31, 0x00	; 0
    4692:	ea 17       	cp	r30, r26
    4694:	fb 07       	cpc	r31, r27
    4696:	88 f3       	brcs	.-30     	; 0x467a <GetMinusPos+0x14>
    4698:	80 e0       	ldi	r24, 0x00	; 0
		     Result=i+1;
			 break;
		 }
	 }
  return Result;     
}
    469a:	08 95       	ret

0000469c <IsMinus>:

char IsMinus(char *strNumber){
char i,Result=False;
     Result=False;
	 if (GetMinusPos(strNumber)>0){
    469c:	0e 94 33 23 	call	0x4666	; 0x4666 <GetMinusPos>
    46a0:	81 11       	cpse	r24, r1
    46a2:	81 e0       	ldi	r24, 0x01	; 1
	     Result=True;
	 }     
  return Result;
}
    46a4:	08 95       	ret

000046a6 <RemoveMinus>:

void RemoveMinus(char *strNumber){
    46a6:	cf 93       	push	r28
    46a8:	df 93       	push	r29
    46aa:	ec 01       	movw	r28, r24
     char MinPos,Length;

     if (IsMinus(strNumber)==True){
    46ac:	0e 94 4e 23 	call	0x469c	; 0x469c <IsMinus>
    46b0:	81 30       	cpi	r24, 0x01	; 1
    46b2:	19 f5       	brne	.+70     	; 0x46fa <RemoveMinus+0x54>
	     MinPos=GetMinusPos(strNumber);
    46b4:	ce 01       	movw	r24, r28
    46b6:	0e 94 33 23 	call	0x4666	; 0x4666 <GetMinusPos>
		 Length=strlen(strNumber);
    46ba:	de 01       	movw	r26, r28
    46bc:	0d 90       	ld	r0, X+
    46be:	00 20       	and	r0, r0
    46c0:	e9 f7       	brne	.-6      	; 0x46bc <RemoveMinus+0x16>
    46c2:	11 97       	sbiw	r26, 0x01	; 1
		 StrPosCopy(strNumber,strNumber,MinPos,(Length-MinPos));	      
    46c4:	ac 1b       	sub	r26, r28
    46c6:	b0 e0       	ldi	r27, 0x00	; 0
    46c8:	90 e0       	ldi	r25, 0x00	; 0
    46ca:	a8 1b       	sub	r26, r24
    46cc:	b9 0b       	sbc	r27, r25
    46ce:	ae 01       	movw	r20, r28
    46d0:	48 0f       	add	r20, r24
    46d2:	59 1f       	adc	r21, r25
    46d4:	20 e0       	ldi	r18, 0x00	; 0
    46d6:	30 e0       	ldi	r19, 0x00	; 0
    46d8:	0a c0       	rjmp	.+20     	; 0x46ee <RemoveMinus+0x48>
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    46da:	be 01       	movw	r22, r28
    46dc:	62 0f       	add	r22, r18
    46de:	73 1f       	adc	r23, r19
    46e0:	fa 01       	movw	r30, r20
    46e2:	81 91       	ld	r24, Z+
    46e4:	af 01       	movw	r20, r30
    46e6:	fb 01       	movw	r30, r22
    46e8:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    46ea:	2f 5f       	subi	r18, 0xFF	; 255
    46ec:	3f 4f       	sbci	r19, 0xFF	; 255
    46ee:	2a 17       	cp	r18, r26
    46f0:	3b 07       	cpc	r19, r27
    46f2:	98 f3       	brcs	.-26     	; 0x46da <RemoveMinus+0x34>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    46f4:	ac 0f       	add	r26, r28
    46f6:	bd 1f       	adc	r27, r29
    46f8:	1c 92       	st	X, r1
     if (IsMinus(strNumber)==True){
	     MinPos=GetMinusPos(strNumber);
		 Length=strlen(strNumber);
		 StrPosCopy(strNumber,strNumber,MinPos,(Length-MinPos));	      
	 }
}
    46fa:	df 91       	pop	r29
    46fc:	cf 91       	pop	r28
    46fe:	08 95       	ret

00004700 <IsMoreThan>:
	    Result=c-'0';
	 }
	return Result;
}

char IsMoreThan(char *strA, char *strB){
    4700:	ac 01       	movw	r20, r24
    4702:	27 2f       	mov	r18, r23
     char i,LengthA,LengthB,Result=False;
	 char strSend[20];	 
     //Check Length
	 LengthA=strlen(strA);
    4704:	fc 01       	movw	r30, r24
    4706:	01 90       	ld	r0, Z+
    4708:	00 20       	and	r0, r0
    470a:	e9 f7       	brne	.-6      	; 0x4706 <IsMoreThan+0x6>
    470c:	31 97       	sbiw	r30, 0x01	; 1
    470e:	7e 2f       	mov	r23, r30
    4710:	78 1b       	sub	r23, r24
	 LengthB=strlen(strB);
    4712:	a6 2f       	mov	r26, r22
    4714:	b2 2f       	mov	r27, r18
    4716:	fd 01       	movw	r30, r26
    4718:	01 90       	ld	r0, Z+
    471a:	00 20       	and	r0, r0
    471c:	e9 f7       	brne	.-6      	; 0x4718 <IsMoreThan+0x18>
    471e:	31 97       	sbiw	r30, 0x01	; 1
    4720:	e6 1b       	sub	r30, r22
	 Result=False;
	 if (LengthA>LengthB)Result=True;
    4722:	e7 17       	cp	r30, r23
    4724:	48 f1       	brcs	.+82     	; 0x4778 <IsMoreThan+0x78>
	 else 
	 if (LengthA==LengthB){          //456755 
    4726:	7e 17       	cp	r23, r30
    4728:	49 f5       	brne	.+82     	; 0x477c <IsMoreThan+0x7c>
    472a:	86 2f       	mov	r24, r22
    472c:	92 2f       	mov	r25, r18
    472e:	9c 01       	movw	r18, r24
    4730:	d9 01       	movw	r26, r18
    4732:	20 e0       	ldi	r18, 0x00	; 0
    4734:	30 e0       	ldi	r19, 0x00	; 0
    4736:	1d c0       	rjmp	.+58     	; 0x4772 <IsMoreThan+0x72>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    4738:	fa 01       	movw	r30, r20
    473a:	e2 0f       	add	r30, r18
    473c:	f3 1f       	adc	r31, r19
    473e:	e0 81       	ld	r30, Z
    4740:	e0 53       	subi	r30, 0x30	; 48
    4742:	ea 30       	cpi	r30, 0x0A	; 10
    4744:	10 f0       	brcs	.+4      	; 0x474a <IsMoreThan+0x4a>
    4746:	60 e0       	ldi	r22, 0x00	; 0
    4748:	01 c0       	rjmp	.+2      	; 0x474c <IsMoreThan+0x4c>
    474a:	6e 2f       	mov	r22, r30
	 Result=False;
	 if (LengthA>LengthB)Result=True;
	 else 
	 if (LengthA==LengthB){          //456755 
	     for(i=0;i<LengthA;i++){    //456410   
		     if (Ord(strA[i])>Ord(strB[i])){
    474c:	8c 91       	ld	r24, X
    474e:	80 53       	subi	r24, 0x30	; 48
    4750:	8a 30       	cpi	r24, 0x0A	; 10
    4752:	10 f0       	brcs	.+4      	; 0x4758 <IsMoreThan+0x58>
    4754:	90 e0       	ldi	r25, 0x00	; 0
    4756:	01 c0       	rjmp	.+2      	; 0x475a <IsMoreThan+0x5a>
    4758:	98 2f       	mov	r25, r24
    475a:	96 17       	cp	r25, r22
    475c:	68 f0       	brcs	.+26     	; 0x4778 <IsMoreThan+0x78>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    475e:	ea 30       	cpi	r30, 0x0A	; 10
    4760:	08 f0       	brcs	.+2      	; 0x4764 <IsMoreThan+0x64>
    4762:	e0 e0       	ldi	r30, 0x00	; 0
	 if (LengthA==LengthB){          //456755 
	     for(i=0;i<LengthA;i++){    //456410   
		     if (Ord(strA[i])>Ord(strB[i])){
			     Result=True;
				 break;
			 }else if (Ord(strA[i])<Ord(strB[i])){
    4764:	8a 30       	cpi	r24, 0x0A	; 10
    4766:	10 f4       	brcc	.+4      	; 0x476c <IsMoreThan+0x6c>
    4768:	e8 17       	cp	r30, r24
    476a:	40 f0       	brcs	.+16     	; 0x477c <IsMoreThan+0x7c>
    476c:	2f 5f       	subi	r18, 0xFF	; 255
    476e:	3f 4f       	sbci	r19, 0xFF	; 255
    4770:	11 96       	adiw	r26, 0x01	; 1
	 LengthB=strlen(strB);
	 Result=False;
	 if (LengthA>LengthB)Result=True;
	 else 
	 if (LengthA==LengthB){          //456755 
	     for(i=0;i<LengthA;i++){    //456410   
    4772:	27 17       	cp	r18, r23
    4774:	08 f3       	brcs	.-62     	; 0x4738 <IsMoreThan+0x38>
    4776:	02 c0       	rjmp	.+4      	; 0x477c <IsMoreThan+0x7c>
    4778:	81 e0       	ldi	r24, 0x01	; 1
    477a:	08 95       	ret
    477c:	80 e0       	ldi	r24, 0x00	; 0
				 break;
			 }			 		 
		 }
	 }
  return Result;
}
    477e:	08 95       	ret

00004780 <IsZerroAll>:
   return Result;
}

char IsZerroAll(char *strZerro){
     char i,Length,nZerro=0,Result;
	 Length=strlen(strZerro);
    4780:	fc 01       	movw	r30, r24
    4782:	01 90       	ld	r0, Z+
    4784:	00 20       	and	r0, r0
    4786:	e9 f7       	brne	.-6      	; 0x4782 <IsZerroAll+0x2>
    4788:	31 97       	sbiw	r30, 0x01	; 1
    478a:	e8 1b       	sub	r30, r24
    478c:	dc 01       	movw	r26, r24
    478e:	ae 0f       	add	r26, r30
    4790:	b1 1d       	adc	r27, r1
    4792:	90 e0       	ldi	r25, 0x00	; 0
    4794:	20 e0       	ldi	r18, 0x00	; 0
    4796:	06 c0       	rjmp	.+12     	; 0x47a4 <IsZerroAll+0x24>
	 nZerro=0;
	 Result=False;
	 for(i=0;i<Length;i++){
	     if (strZerro[Length-i]=='0')nZerro++;
    4798:	8c 91       	ld	r24, X
    479a:	80 33       	cpi	r24, 0x30	; 48
    479c:	09 f4       	brne	.+2      	; 0x47a0 <IsZerroAll+0x20>
    479e:	2f 5f       	subi	r18, 0xFF	; 255
char IsZerroAll(char *strZerro){
     char i,Length,nZerro=0,Result;
	 Length=strlen(strZerro);
	 nZerro=0;
	 Result=False;
	 for(i=0;i<Length;i++){
    47a0:	9f 5f       	subi	r25, 0xFF	; 255
    47a2:	11 97       	sbiw	r26, 0x01	; 1
    47a4:	9e 17       	cp	r25, r30
    47a6:	c0 f3       	brcs	.-16     	; 0x4798 <IsZerroAll+0x18>
    47a8:	80 e0       	ldi	r24, 0x00	; 0
    47aa:	2e 17       	cp	r18, r30
    47ac:	09 f4       	brne	.+2      	; 0x47b0 <IsZerroAll+0x30>
    47ae:	81 e0       	ldi	r24, 0x01	; 1
	     if (strZerro[Length-i]=='0')nZerro++;
	 }if (nZerro==Length) Result=True;
  return Result;
}
    47b0:	08 95       	ret

000047b2 <PstrCopy>:
     _uart(_COM_PRINTER, 1, 0x0D);     
     _uart(_COM_PRINTER, 1, 0x0A);

}

void PstrCopy(char *Dest,char *Source){
    47b2:	cf 93       	push	r28
    47b4:	df 93       	push	r29
    47b6:	20 e0       	ldi	r18, 0x00	; 0
    47b8:	08 c0       	rjmp	.+16     	; 0x47ca <PstrCopy+0x18>
     char i=0;
	 for(i=0;i<strlen(Source);i++){
	    Dest[i]=pgm_read_byte(&Source[i]);
    47ba:	fb 01       	movw	r30, r22
    47bc:	ec 0f       	add	r30, r28
    47be:	fd 1f       	adc	r31, r29
    47c0:	e4 91       	lpm	r30, Z+
    47c2:	c8 0f       	add	r28, r24
    47c4:	d9 1f       	adc	r29, r25
    47c6:	e8 83       	st	Y, r30

}

void PstrCopy(char *Dest,char *Source){
     char i=0;
	 for(i=0;i<strlen(Source);i++){
    47c8:	2f 5f       	subi	r18, 0xFF	; 255
    47ca:	c2 2f       	mov	r28, r18
    47cc:	d0 e0       	ldi	r29, 0x00	; 0
    47ce:	fb 01       	movw	r30, r22
    47d0:	01 90       	ld	r0, Z+
    47d2:	00 20       	and	r0, r0
    47d4:	e9 f7       	brne	.-6      	; 0x47d0 <PstrCopy+0x1e>
    47d6:	31 97       	sbiw	r30, 0x01	; 1
    47d8:	e6 1b       	sub	r30, r22
    47da:	f7 0b       	sbc	r31, r23
    47dc:	ce 17       	cp	r28, r30
    47de:	df 07       	cpc	r29, r31
    47e0:	60 f3       	brcs	.-40     	; 0x47ba <PstrCopy+0x8>
	    Dest[i]=pgm_read_byte(&Source[i]);
	 }
}
    47e2:	df 91       	pop	r29
    47e4:	cf 91       	pop	r28
    47e6:	08 95       	ret

000047e8 <SpaceOnly>:
	     if (strDecimal[i]==DecPointMark)
		     strDecimal[i]=0;
	 }
}

char SpaceOnly(char *string){
    47e8:	ac 01       	movw	r20, r24
     char Result,nChar=0;
	 unsigned int i=0;
	 nChar=0;
	 Result=False;
	 for(i=0;i<strlen(string);i++){
    47ea:	dc 01       	movw	r26, r24
    47ec:	0d 90       	ld	r0, X+
    47ee:	00 20       	and	r0, r0
    47f0:	e9 f7       	brne	.-6      	; 0x47ec <SpaceOnly+0x4>
    47f2:	11 97       	sbiw	r26, 0x01	; 1
    47f4:	a8 1b       	sub	r26, r24
    47f6:	b9 0b       	sbc	r27, r25
    47f8:	90 e0       	ldi	r25, 0x00	; 0
    47fa:	20 e0       	ldi	r18, 0x00	; 0
    47fc:	30 e0       	ldi	r19, 0x00	; 0
    47fe:	09 c0       	rjmp	.+18     	; 0x4812 <SpaceOnly+0x2a>
	    if(string[i]!=' ') nChar++;
    4800:	fa 01       	movw	r30, r20
    4802:	e2 0f       	add	r30, r18
    4804:	f3 1f       	adc	r31, r19
    4806:	80 81       	ld	r24, Z
    4808:	80 32       	cpi	r24, 0x20	; 32
    480a:	09 f0       	breq	.+2      	; 0x480e <SpaceOnly+0x26>
    480c:	9f 5f       	subi	r25, 0xFF	; 255
char SpaceOnly(char *string){
     char Result,nChar=0;
	 unsigned int i=0;
	 nChar=0;
	 Result=False;
	 for(i=0;i<strlen(string);i++){
    480e:	2f 5f       	subi	r18, 0xFF	; 255
    4810:	3f 4f       	sbci	r19, 0xFF	; 255
    4812:	2a 17       	cp	r18, r26
    4814:	3b 07       	cpc	r19, r27
    4816:	a0 f3       	brcs	.-24     	; 0x4800 <SpaceOnly+0x18>
    4818:	80 e0       	ldi	r24, 0x00	; 0
    481a:	99 23       	and	r25, r25
    481c:	09 f4       	brne	.+2      	; 0x4820 <SpaceOnly+0x38>
    481e:	81 e0       	ldi	r24, 0x01	; 1
	 }
	 if (nChar>0) Result=False;
	 else Result=True;

	 return Result;
}
    4820:	08 95       	ret

00004822 <RemDecimal>:
	 }
}



void RemDecimal(char *strDecimal){//4500.00-->4500
    4822:	9c 01       	movw	r18, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    4824:	e1 99       	sbic	0x1c, 1	; 28
    4826:	fe cf       	rjmp	.-4      	; 0x4824 <RemDecimal+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    4828:	8e e3       	ldi	r24, 0x3E	; 62
    482a:	90 e0       	ldi	r25, 0x00	; 0
    482c:	9f bb       	out	0x1f, r25	; 31
    482e:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    4830:	e0 9a       	sbi	0x1c, 0	; 28
    4832:	5d b3       	in	r21, 0x1d	; 29
    4834:	40 e0       	ldi	r20, 0x00	; 0
    4836:	08 c0       	rjmp	.+16     	; 0x4848 <RemDecimal+0x26>
char i,DecPointMark;
     DecPointMark=eeprom_read_byte(&DefDecimalMark);	 

     for(i=0;i<strlen(strDecimal);i++){
	     if (strDecimal[i]==DecPointMark)
    4838:	f9 01       	movw	r30, r18
    483a:	e8 0f       	add	r30, r24
    483c:	f9 1f       	adc	r31, r25
    483e:	80 81       	ld	r24, Z
    4840:	85 17       	cp	r24, r21
    4842:	09 f4       	brne	.+2      	; 0x4846 <RemDecimal+0x24>
		     strDecimal[i]=0;
    4844:	10 82       	st	Z, r1

void RemDecimal(char *strDecimal){//4500.00-->4500
char i,DecPointMark;
     DecPointMark=eeprom_read_byte(&DefDecimalMark);	 

     for(i=0;i<strlen(strDecimal);i++){
    4846:	4f 5f       	subi	r20, 0xFF	; 255
    4848:	84 2f       	mov	r24, r20
    484a:	90 e0       	ldi	r25, 0x00	; 0
    484c:	f9 01       	movw	r30, r18
    484e:	01 90       	ld	r0, Z+
    4850:	00 20       	and	r0, r0
    4852:	e9 f7       	brne	.-6      	; 0x484e <RemDecimal+0x2c>
    4854:	31 97       	sbiw	r30, 0x01	; 1
    4856:	e2 1b       	sub	r30, r18
    4858:	f3 0b       	sbc	r31, r19
    485a:	8e 17       	cp	r24, r30
    485c:	9f 07       	cpc	r25, r31
    485e:	60 f3       	brcs	.-40     	; 0x4838 <RemDecimal+0x16>
	     if (strDecimal[i]==DecPointMark)
		     strDecimal[i]=0;
	 }
}
    4860:	08 95       	ret

00004862 <GetProductPrice>:
          stGenerateReport=grScanAction;
	      break;
	 }
}
//SaveTotalProduct(xGrade,strDeltaVolume,strDeltaMoney);
void GetProductPrice(char *sPrice,char xPumpID,char xNozzle){
    4862:	cf 92       	push	r12
    4864:	df 92       	push	r13
    4866:	ef 92       	push	r14
    4868:	ff 92       	push	r15
    486a:	0f 93       	push	r16
    486c:	1f 93       	push	r17
    486e:	df 93       	push	r29
    4870:	cf 93       	push	r28
    4872:	cd b7       	in	r28, 0x3d	; 61
    4874:	de b7       	in	r29, 0x3e	; 62
    4876:	67 97       	sbiw	r28, 0x17	; 23
    4878:	0f b6       	in	r0, 0x3f	; 63
    487a:	f8 94       	cli
    487c:	de bf       	out	0x3e, r29	; 62
    487e:	0f be       	out	0x3f, r0	; 63
    4880:	cd bf       	out	0x3d, r28	; 61
    4882:	7c 01       	movw	r14, r24
    4884:	d6 2e       	mov	r13, r22
    4886:	c4 2e       	mov	r12, r20
char i,PPumpID[8],PProdID[6],strPrice[9],iPumpID,xProductID;
     sprintf_P(sPrice,PSTR(""));
    4888:	00 d0       	rcall	.+0      	; 0x488a <GetProductPrice+0x28>
    488a:	00 d0       	rcall	.+0      	; 0x488c <GetProductPrice+0x2a>
    488c:	ad b7       	in	r26, 0x3d	; 61
    488e:	be b7       	in	r27, 0x3e	; 62
    4890:	12 96       	adiw	r26, 0x02	; 2
    4892:	9c 93       	st	X, r25
    4894:	8e 93       	st	-X, r24
    4896:	11 97       	sbiw	r26, 0x01	; 1
    4898:	8d ec       	ldi	r24, 0xCD	; 205
    489a:	93 e0       	ldi	r25, 0x03	; 3
    489c:	14 96       	adiw	r26, 0x04	; 4
    489e:	9c 93       	st	X, r25
    48a0:	8e 93       	st	-X, r24
    48a2:	13 97       	sbiw	r26, 0x03	; 3
    48a4:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    48a8:	0f 90       	pop	r0
    48aa:	0f 90       	pop	r0
    48ac:	0f 90       	pop	r0
    48ae:	0f 90       	pop	r0
    48b0:	8e 01       	movw	r16, r28
    48b2:	09 5f       	subi	r16, 0xF9	; 249
    48b4:	1f 4f       	sbci	r17, 0xFF	; 255
    48b6:	c8 01       	movw	r24, r16
    48b8:	65 e4       	ldi	r22, 0x45	; 69
    48ba:	70 e0       	ldi	r23, 0x00	; 0
    48bc:	48 e0       	ldi	r20, 0x08	; 8
    48be:	50 e0       	ldi	r21, 0x00	; 0
    48c0:	2d ef       	ldi	r18, 0xFD	; 253
    48c2:	32 e1       	ldi	r19, 0x12	; 18
    48c4:	0e 94 f1 b3 	call	0x167e2	; 0x167e2 <__eerd_block>
    48c8:	f8 01       	movw	r30, r16
     //FindPumpID
	 eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap,8);
	 iPumpID=0;
	 for(i=0;i<8;i++){
    48ca:	9e 01       	movw	r18, r28
    48cc:	21 5f       	subi	r18, 0xF1	; 241
    48ce:	3f 4f       	sbci	r19, 0xFF	; 255
    48d0:	9e 2f       	mov	r25, r30
    48d2:	90 1b       	sub	r25, r16
	     if (PPumpID[i]==xPumpID){
    48d4:	80 81       	ld	r24, Z
    48d6:	8d 15       	cp	r24, r13
    48d8:	11 f4       	brne	.+4      	; 0x48de <GetProductPrice+0x7c>
    48da:	89 2f       	mov	r24, r25
    48dc:	05 c0       	rjmp	.+10     	; 0x48e8 <GetProductPrice+0x86>
    48de:	31 96       	adiw	r30, 0x01	; 1
char i,PPumpID[8],PProdID[6],strPrice[9],iPumpID,xProductID;
     sprintf_P(sPrice,PSTR(""));
     //FindPumpID
	 eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap,8);
	 iPumpID=0;
	 for(i=0;i<8;i++){
    48e0:	e2 17       	cp	r30, r18
    48e2:	f3 07       	cpc	r31, r19
    48e4:	a9 f7       	brne	.-22     	; 0x48d0 <GetProductPrice+0x6e>
    48e6:	80 e0       	ldi	r24, 0x00	; 0
	     if (PPumpID[i]==xPumpID){
		     iPumpID=i;
			 break;
		 }	 
	 }
	 if ((iPumpID>=0)&&(xNozzle<6)){
    48e8:	b5 e0       	ldi	r27, 0x05	; 5
    48ea:	bc 15       	cp	r27, r12
    48ec:	08 f4       	brcc	.+2      	; 0x48f0 <GetProductPrice+0x8e>
    48ee:	41 c0       	rjmp	.+130    	; 0x4972 <GetProductPrice+0x110>
    48f0:	66 e0       	ldi	r22, 0x06	; 6
    48f2:	86 9f       	mul	r24, r22
    48f4:	b0 01       	movw	r22, r0
    48f6:	11 24       	eor	r1, r1
    48f8:	6b 5a       	subi	r22, 0xAB	; 171
    48fa:	7f 4f       	sbci	r23, 0xFF	; 255
    48fc:	ce 01       	movw	r24, r28
    48fe:	01 96       	adiw	r24, 0x01	; 1
    4900:	46 e0       	ldi	r20, 0x06	; 6
    4902:	50 e0       	ldi	r21, 0x00	; 0
    4904:	2d ef       	ldi	r18, 0xFD	; 253
    4906:	32 e1       	ldi	r19, 0x12	; 18
    4908:	0e 94 f1 b3 	call	0x167e2	; 0x167e2 <__eerd_block>
         eeprom_read_block((void*) &PProdID,(const void*) &DefNozzleMap[iPumpID],6);
         xProductID=PProdID[xNozzle-1];
		 //Price
		 eeprom_read_block((void*) &strPrice, (const void*) &DefProductPrice[xProductID-1], 9);
		 RemDecimal(strPrice);
    490c:	8e 01       	movw	r16, r28
    490e:	01 5f       	subi	r16, 0xF1	; 241
    4910:	1f 4f       	sbci	r17, 0xFF	; 255
    4912:	fe 01       	movw	r30, r28
    4914:	ec 0d       	add	r30, r12
    4916:	f1 1d       	adc	r31, r1
    4918:	60 81       	ld	r22, Z
    491a:	89 e0       	ldi	r24, 0x09	; 9
    491c:	68 9f       	mul	r22, r24
    491e:	b0 01       	movw	r22, r0
    4920:	11 24       	eor	r1, r1
    4922:	64 58       	subi	r22, 0x84	; 132
    4924:	7f 4f       	sbci	r23, 0xFF	; 255
    4926:	c8 01       	movw	r24, r16
    4928:	49 e0       	ldi	r20, 0x09	; 9
    492a:	50 e0       	ldi	r21, 0x00	; 0
    492c:	2d ef       	ldi	r18, 0xFD	; 253
    492e:	32 e1       	ldi	r19, 0x12	; 18
    4930:	0e 94 f1 b3 	call	0x167e2	; 0x167e2 <__eerd_block>
    4934:	c8 01       	movw	r24, r16
    4936:	0e 94 11 24 	call	0x4822	; 0x4822 <RemDecimal>
		 sprintf_P(sPrice,PSTR("%s"),strPrice);
    493a:	00 d0       	rcall	.+0      	; 0x493c <GetProductPrice+0xda>
    493c:	00 d0       	rcall	.+0      	; 0x493e <GetProductPrice+0xdc>
    493e:	00 d0       	rcall	.+0      	; 0x4940 <GetProductPrice+0xde>
    4940:	ed b7       	in	r30, 0x3d	; 61
    4942:	fe b7       	in	r31, 0x3e	; 62
    4944:	31 96       	adiw	r30, 0x01	; 1
    4946:	ad b7       	in	r26, 0x3d	; 61
    4948:	be b7       	in	r27, 0x3e	; 62
    494a:	12 96       	adiw	r26, 0x02	; 2
    494c:	fc 92       	st	X, r15
    494e:	ee 92       	st	-X, r14
    4950:	11 97       	sbiw	r26, 0x01	; 1
    4952:	8a ec       	ldi	r24, 0xCA	; 202
    4954:	93 e0       	ldi	r25, 0x03	; 3
    4956:	93 83       	std	Z+3, r25	; 0x03
    4958:	82 83       	std	Z+2, r24	; 0x02
    495a:	15 83       	std	Z+5, r17	; 0x05
    495c:	04 83       	std	Z+4, r16	; 0x04
    495e:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    4962:	ed b7       	in	r30, 0x3d	; 61
    4964:	fe b7       	in	r31, 0x3e	; 62
    4966:	36 96       	adiw	r30, 0x06	; 6
    4968:	0f b6       	in	r0, 0x3f	; 63
    496a:	f8 94       	cli
    496c:	fe bf       	out	0x3e, r31	; 62
    496e:	0f be       	out	0x3f, r0	; 63
    4970:	ed bf       	out	0x3d, r30	; 61
	 }    
	 //Clear Decimal

}
    4972:	67 96       	adiw	r28, 0x17	; 23
    4974:	0f b6       	in	r0, 0x3f	; 63
    4976:	f8 94       	cli
    4978:	de bf       	out	0x3e, r29	; 62
    497a:	0f be       	out	0x3f, r0	; 63
    497c:	cd bf       	out	0x3d, r28	; 61
    497e:	cf 91       	pop	r28
    4980:	df 91       	pop	r29
    4982:	1f 91       	pop	r17
    4984:	0f 91       	pop	r16
    4986:	ff 90       	pop	r15
    4988:	ef 90       	pop	r14
    498a:	df 90       	pop	r13
    498c:	cf 90       	pop	r12
    498e:	08 95       	ret

00004990 <FormatDate>:
	 }     
   }
}

              //Fmt:DATE_LONG_YEAR,DATE_SHORT_YEAR //0123456789    0123456789 
void FormatDate(char FmtYear, char *Date){         //2010/06/16 -> 16/06/2010
    4990:	df 93       	push	r29
    4992:	cf 93       	push	r28
    4994:	cd b7       	in	r28, 0x3d	; 61
    4996:	de b7       	in	r29, 0x3e	; 62
    4998:	2b 97       	sbiw	r28, 0x0b	; 11
    499a:	0f b6       	in	r0, 0x3f	; 63
    499c:	f8 94       	cli
    499e:	de bf       	out	0x3e, r29	; 62
    49a0:	0f be       	out	0x3f, r0	; 63
    49a2:	cd bf       	out	0x3d, r28	; 61
    49a4:	98 2f       	mov	r25, r24
    49a6:	9b 01       	movw	r18, r22
     char i,sDate[11];

     sDate[0]=Date[8];
    49a8:	fb 01       	movw	r30, r22
    49aa:	80 85       	ldd	r24, Z+8	; 0x08
    49ac:	89 83       	std	Y+1, r24	; 0x01
	 sDate[1]=Date[9];
    49ae:	81 85       	ldd	r24, Z+9	; 0x09
    49b0:	8a 83       	std	Y+2, r24	; 0x02
     sDate[2]=Date[7];
    49b2:	87 81       	ldd	r24, Z+7	; 0x07
    49b4:	8b 83       	std	Y+3, r24	; 0x03
	 sDate[3]=Date[5];
    49b6:	85 81       	ldd	r24, Z+5	; 0x05
    49b8:	8c 83       	std	Y+4, r24	; 0x04
     sDate[4]=Date[6];
    49ba:	86 81       	ldd	r24, Z+6	; 0x06
    49bc:	8d 83       	std	Y+5, r24	; 0x05
	 sDate[5]=Date[4];
    49be:	84 81       	ldd	r24, Z+4	; 0x04
    49c0:	8e 83       	std	Y+6, r24	; 0x06
	 switch(FmtYear){
    49c2:	99 23       	and	r25, r25
    49c4:	19 f0       	breq	.+6      	; 0x49cc <FormatDate+0x3c>
    49c6:	91 30       	cpi	r25, 0x01	; 1
    49c8:	59 f4       	brne	.+22     	; 0x49e0 <FormatDate+0x50>
    49ca:	0f c0       	rjmp	.+30     	; 0x49ea <FormatDate+0x5a>
	 case DATE_LONG_YEAR:
	 	  for(i=0;i<4;i++)sDate[i+6]=Date[i];
    49cc:	fb 01       	movw	r30, r22
    49ce:	80 81       	ld	r24, Z
    49d0:	8f 83       	std	Y+7, r24	; 0x07
    49d2:	81 81       	ldd	r24, Z+1	; 0x01
    49d4:	88 87       	std	Y+8, r24	; 0x08
    49d6:	82 81       	ldd	r24, Z+2	; 0x02
    49d8:	89 87       	std	Y+9, r24	; 0x09
    49da:	83 81       	ldd	r24, Z+3	; 0x03
    49dc:	8a 87       	std	Y+10, r24	; 0x0a
          sDate[10]=0;
    49de:	1b 86       	std	Y+11, r1	; 0x0b
    49e0:	90 e0       	ldi	r25, 0x00	; 0
	      for(i=0;i<2;i++)sDate[i+6]=Date[i+2];
          sDate[8]=0;
	      break;
	 }
	 //replace
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
    49e2:	ae 01       	movw	r20, r28
    49e4:	4f 5f       	subi	r20, 0xFF	; 255
    49e6:	5f 4f       	sbci	r21, 0xFF	; 255
    49e8:	0f c0       	rjmp	.+30     	; 0x4a08 <FormatDate+0x78>
	 case DATE_LONG_YEAR:
	 	  for(i=0;i<4;i++)sDate[i+6]=Date[i];
          sDate[10]=0;
	      break;
	 case DATE_SHORT_YEAR:
	      for(i=0;i<2;i++)sDate[i+6]=Date[i+2];
    49ea:	fb 01       	movw	r30, r22
    49ec:	82 81       	ldd	r24, Z+2	; 0x02
    49ee:	8f 83       	std	Y+7, r24	; 0x07
    49f0:	83 81       	ldd	r24, Z+3	; 0x03
    49f2:	88 87       	std	Y+8, r24	; 0x08
          sDate[8]=0;
    49f4:	19 86       	std	Y+9, r1	; 0x09
    49f6:	f4 cf       	rjmp	.-24     	; 0x49e0 <FormatDate+0x50>
	      break;
	 }
	 //replace
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
    49f8:	f9 01       	movw	r30, r18
    49fa:	ea 0f       	add	r30, r26
    49fc:	fb 1f       	adc	r31, r27
    49fe:	a4 0f       	add	r26, r20
    4a00:	b5 1f       	adc	r27, r21
    4a02:	8c 91       	ld	r24, X
    4a04:	80 83       	st	Z, r24
    4a06:	9f 5f       	subi	r25, 0xFF	; 255
    4a08:	a9 2f       	mov	r26, r25
    4a0a:	b0 e0       	ldi	r27, 0x00	; 0
    4a0c:	fa 01       	movw	r30, r20
    4a0e:	01 90       	ld	r0, Z+
    4a10:	00 20       	and	r0, r0
    4a12:	e9 f7       	brne	.-6      	; 0x4a0e <FormatDate+0x7e>
    4a14:	31 97       	sbiw	r30, 0x01	; 1
    4a16:	e4 1b       	sub	r30, r20
    4a18:	f5 0b       	sbc	r31, r21
    4a1a:	ae 17       	cp	r26, r30
    4a1c:	bf 07       	cpc	r27, r31
    4a1e:	60 f3       	brcs	.-40     	; 0x49f8 <FormatDate+0x68>
}
    4a20:	2b 96       	adiw	r28, 0x0b	; 11
    4a22:	0f b6       	in	r0, 0x3f	; 63
    4a24:	f8 94       	cli
    4a26:	de bf       	out	0x3e, r29	; 62
    4a28:	0f be       	out	0x3f, r0	; 63
    4a2a:	cd bf       	out	0x3d, r28	; 61
    4a2c:	cf 91       	pop	r28
    4a2e:	df 91       	pop	r29
    4a30:	08 95       	ret

00004a32 <RemZeroLead>:

	while (1){};
  #endif
}

void RemZeroLead(char *Zeroed){//Remove Zero Character 00001004 000050000 0 
    4a32:	cf 93       	push	r28
    4a34:	df 93       	push	r29
    4a36:	ec 01       	movw	r28, r24
unsigned char i=0,Length=0,ZeroPos=0,IsFound=False;;
     IsFound=False;
     ZeroPos=0;Length=strlen(Zeroed);
    4a38:	fc 01       	movw	r30, r24
    4a3a:	01 90       	ld	r0, Z+
    4a3c:	00 20       	and	r0, r0
    4a3e:	e9 f7       	brne	.-6      	; 0x4a3a <RemZeroLead+0x8>
    4a40:	31 97       	sbiw	r30, 0x01	; 1
    4a42:	e8 1b       	sub	r30, r24
  if ((Length>1)&&(Zeroed[0]=='0')){
    4a44:	e2 30       	cpi	r30, 0x02	; 2
    4a46:	d0 f1       	brcs	.+116    	; 0x4abc <RemZeroLead+0x8a>
    4a48:	88 81       	ld	r24, Y
    4a4a:	80 33       	cpi	r24, 0x30	; 48
    4a4c:	b9 f5       	brne	.+110    	; 0x4abc <RemZeroLead+0x8a>
    4a4e:	4c 2f       	mov	r20, r28
    4a50:	de 01       	movw	r26, r28
    4a52:	90 e0       	ldi	r25, 0x00	; 0
	 if (Zeroed[0]=='0'){
         for(i=0;i<Length;i++){//00000000->0
	         if ((Zeroed[i]=='0')&&(Zeroed[i+1]=='0')&&(IsFound==False)) ZeroPos++;
    4a54:	8c 91       	ld	r24, X
    4a56:	80 33       	cpi	r24, 0x30	; 48
    4a58:	69 f4       	brne	.+26     	; 0x4a74 <RemZeroLead+0x42>
    4a5a:	11 96       	adiw	r26, 0x01	; 1
    4a5c:	8c 91       	ld	r24, X
    4a5e:	11 97       	sbiw	r26, 0x01	; 1
    4a60:	80 33       	cpi	r24, 0x30	; 48
    4a62:	11 f4       	brne	.+4      	; 0x4a68 <RemZeroLead+0x36>
    4a64:	9f 5f       	subi	r25, 0xFF	; 255
    4a66:	06 c0       	rjmp	.+12     	; 0x4a74 <RemZeroLead+0x42>
             if ((Zeroed[i]=='0')&&(Zeroed[i+1]!='0')){
			     if ((Zeroed[i+1]=='.')||(Zeroed[i+1]==','))ZeroPos--;
    4a68:	8e 32       	cpi	r24, 0x2E	; 46
    4a6a:	11 f0       	breq	.+4      	; 0x4a70 <RemZeroLead+0x3e>
    4a6c:	8c 32       	cpi	r24, 0x2C	; 44
    4a6e:	41 f4       	brne	.+16     	; 0x4a80 <RemZeroLead+0x4e>
    4a70:	91 50       	subi	r25, 0x01	; 1
    4a72:	06 c0       	rjmp	.+12     	; 0x4a80 <RemZeroLead+0x4e>
    4a74:	11 96       	adiw	r26, 0x01	; 1
unsigned char i=0,Length=0,ZeroPos=0,IsFound=False;;
     IsFound=False;
     ZeroPos=0;Length=strlen(Zeroed);
  if ((Length>1)&&(Zeroed[0]=='0')){
	 if (Zeroed[0]=='0'){
         for(i=0;i<Length;i++){//00000000->0
    4a76:	8a 2f       	mov	r24, r26
    4a78:	84 1b       	sub	r24, r20
    4a7a:	8e 17       	cp	r24, r30
    4a7c:	58 f3       	brcs	.-42     	; 0x4a54 <RemZeroLead+0x22>
    4a7e:	01 c0       	rjmp	.+2      	; 0x4a82 <RemZeroLead+0x50>
		         IsFound=True;
			     break;			  
			     }
	      }

		  if (IsFound==True)ZeroPos++;
    4a80:	9f 5f       	subi	r25, 0xFF	; 255
		  if (ZeroPos>=Length)ZeroPos=Length-1;
    4a82:	9e 17       	cp	r25, r30
    4a84:	10 f0       	brcs	.+4      	; 0x4a8a <RemZeroLead+0x58>
    4a86:	9e 2f       	mov	r25, r30
    4a88:	91 50       	subi	r25, 0x01	; 1
    4a8a:	40 e0       	ldi	r20, 0x00	; 0
          for(i=0;i<(Length-ZeroPos);i++){
    4a8c:	89 2f       	mov	r24, r25
    4a8e:	90 e0       	ldi	r25, 0x00	; 0
    4a90:	2e 2f       	mov	r18, r30
    4a92:	30 e0       	ldi	r19, 0x00	; 0
    4a94:	28 1b       	sub	r18, r24
    4a96:	39 0b       	sbc	r19, r25
	          Zeroed[i]=Zeroed[i+ZeroPos];
    4a98:	be 01       	movw	r22, r28
    4a9a:	68 0f       	add	r22, r24
    4a9c:	79 1f       	adc	r23, r25
    4a9e:	09 c0       	rjmp	.+18     	; 0x4ab2 <RemZeroLead+0x80>
    4aa0:	fe 01       	movw	r30, r28
    4aa2:	ea 0f       	add	r30, r26
    4aa4:	fb 1f       	adc	r31, r27
    4aa6:	a6 0f       	add	r26, r22
    4aa8:	b7 1f       	adc	r27, r23
    4aaa:	8c 91       	ld	r24, X
    4aac:	80 83       	st	Z, r24
		      Zeroed[i+1]=0;
    4aae:	11 82       	std	Z+1, r1	; 0x01
			     }
	      }

		  if (IsFound==True)ZeroPos++;
		  if (ZeroPos>=Length)ZeroPos=Length-1;
          for(i=0;i<(Length-ZeroPos);i++){
    4ab0:	4f 5f       	subi	r20, 0xFF	; 255
    4ab2:	a4 2f       	mov	r26, r20
    4ab4:	b0 e0       	ldi	r27, 0x00	; 0
    4ab6:	a2 17       	cp	r26, r18
    4ab8:	b3 07       	cpc	r27, r19
    4aba:	94 f3       	brlt	.-28     	; 0x4aa0 <RemZeroLead+0x6e>
	          Zeroed[i]=Zeroed[i+ZeroPos];
		      Zeroed[i+1]=0;
	   }//Zeroed[Length-ZeroPos]=0;
	 }     
   }
}
    4abc:	df 91       	pop	r29
    4abe:	cf 91       	pop	r28
    4ac0:	08 95       	ret

00004ac2 <RemSpaceLead>:
	 if (Spaced[PosSpaced]==' ')Spaced[PosSpaced]=0;
	 if (Spaced[0]==' ')Spaced[0]=0;
	 Spaced[strlen(Spaced)]=0;
}

void RemSpaceLead(char *Zeroed){//Remove Space Character SSSSSS1234 12340234
    4ac2:	cf 93       	push	r28
    4ac4:	df 93       	push	r29
    4ac6:	ec 01       	movw	r28, r24
unsigned char i=0,Length=0,ZeroPos=0,IsFound=False;;
     ZeroPos=0;Length=strlen(Zeroed);
    4ac8:	fc 01       	movw	r30, r24
    4aca:	01 90       	ld	r0, Z+
    4acc:	00 20       	and	r0, r0
    4ace:	e9 f7       	brne	.-6      	; 0x4aca <RemSpaceLead+0x8>
    4ad0:	31 97       	sbiw	r30, 0x01	; 1
    4ad2:	6e 2f       	mov	r22, r30
    4ad4:	68 1b       	sub	r22, r24
	 if ((Length>1)&&(Zeroed[0]==' ')){
    4ad6:	62 30       	cpi	r22, 0x02	; 2
    4ad8:	e0 f1       	brcs	.+120    	; 0x4b52 <RemSpaceLead+0x90>
    4ada:	88 81       	ld	r24, Y
    4adc:	80 32       	cpi	r24, 0x20	; 32
    4ade:	c9 f5       	brne	.+114    	; 0x4b52 <RemSpaceLead+0x90>
    4ae0:	4c 2f       	mov	r20, r28
    4ae2:	fe 01       	movw	r30, r28
    4ae4:	90 e0       	ldi	r25, 0x00	; 0
    4ae6:	20 e0       	ldi	r18, 0x00	; 0
	     for(i=0;i<Length;i++){
		     if ((Zeroed[i]==' ')&&(Zeroed[i+1]==' ')&&(IsFound==False)) ZeroPos++;
    4ae8:	80 81       	ld	r24, Z
    4aea:	80 32       	cpi	r24, 0x20	; 32
    4aec:	41 f4       	brne	.+16     	; 0x4afe <RemSpaceLead+0x3c>
    4aee:	81 81       	ldd	r24, Z+1	; 0x01
    4af0:	80 32       	cpi	r24, 0x20	; 32
    4af2:	21 f4       	brne	.+8      	; 0x4afc <RemSpaceLead+0x3a>
    4af4:	22 23       	and	r18, r18
    4af6:	19 f4       	brne	.+6      	; 0x4afe <RemSpaceLead+0x3c>
    4af8:	9f 5f       	subi	r25, 0xFF	; 255
    4afa:	01 c0       	rjmp	.+2      	; 0x4afe <RemSpaceLead+0x3c>
    4afc:	21 e0       	ldi	r18, 0x01	; 1
    4afe:	31 96       	adiw	r30, 0x01	; 1

void RemSpaceLead(char *Zeroed){//Remove Space Character SSSSSS1234 12340234
unsigned char i=0,Length=0,ZeroPos=0,IsFound=False;;
     ZeroPos=0;Length=strlen(Zeroed);
	 if ((Length>1)&&(Zeroed[0]==' ')){
	     for(i=0;i<Length;i++){
    4b00:	8e 2f       	mov	r24, r30
    4b02:	84 1b       	sub	r24, r20
    4b04:	86 17       	cp	r24, r22
    4b06:	80 f3       	brcs	.-32     	; 0x4ae8 <RemSpaceLead+0x26>
		     if ((Zeroed[i]==' ')&&(Zeroed[i+1]==' ')&&(IsFound==False)) ZeroPos++;
	         if((Zeroed[i]==' ')&&(Zeroed[i+1]!=' '))IsFound=True;
		 }ZeroPos++;
    4b08:	39 2f       	mov	r19, r25
    4b0a:	3f 5f       	subi	r19, 0xFF	; 255
    4b0c:	20 e0       	ldi	r18, 0x00	; 0
	     for(i=0;i<strlen(Zeroed);i++){
		     Zeroed[i]=Zeroed[i+ZeroPos];
    4b0e:	43 2f       	mov	r20, r19
    4b10:	50 e0       	ldi	r21, 0x00	; 0
    4b12:	09 c0       	rjmp	.+18     	; 0x4b26 <RemSpaceLead+0x64>
    4b14:	fe 01       	movw	r30, r28
    4b16:	e8 0f       	add	r30, r24
    4b18:	f9 1f       	adc	r31, r25
    4b1a:	df 01       	movw	r26, r30
    4b1c:	a4 0f       	add	r26, r20
    4b1e:	b5 1f       	adc	r27, r21
    4b20:	8c 91       	ld	r24, X
    4b22:	80 83       	st	Z, r24
	 if ((Length>1)&&(Zeroed[0]==' ')){
	     for(i=0;i<Length;i++){
		     if ((Zeroed[i]==' ')&&(Zeroed[i+1]==' ')&&(IsFound==False)) ZeroPos++;
	         if((Zeroed[i]==' ')&&(Zeroed[i+1]!=' '))IsFound=True;
		 }ZeroPos++;
	     for(i=0;i<strlen(Zeroed);i++){
    4b24:	2f 5f       	subi	r18, 0xFF	; 255
    4b26:	82 2f       	mov	r24, r18
    4b28:	90 e0       	ldi	r25, 0x00	; 0
    4b2a:	fe 01       	movw	r30, r28
    4b2c:	01 90       	ld	r0, Z+
    4b2e:	00 20       	and	r0, r0
    4b30:	e9 f7       	brne	.-6      	; 0x4b2c <RemSpaceLead+0x6a>
    4b32:	31 97       	sbiw	r30, 0x01	; 1
    4b34:	ec 1b       	sub	r30, r28
    4b36:	fd 0b       	sbc	r31, r29
    4b38:	8e 17       	cp	r24, r30
    4b3a:	9f 07       	cpc	r25, r31
    4b3c:	58 f3       	brcs	.-42     	; 0x4b14 <RemSpaceLead+0x52>
		     Zeroed[i]=Zeroed[i+ZeroPos];
		 }
		 //Clearence
		 for(i=(Length-ZeroPos);i<Length;i++){
    4b3e:	86 2f       	mov	r24, r22
    4b40:	83 1b       	sub	r24, r19
    4b42:	05 c0       	rjmp	.+10     	; 0x4b4e <RemSpaceLead+0x8c>
		     Zeroed[i]=0;
    4b44:	fe 01       	movw	r30, r28
    4b46:	e8 0f       	add	r30, r24
    4b48:	f1 1d       	adc	r31, r1
    4b4a:	10 82       	st	Z, r1
		 }ZeroPos++;
	     for(i=0;i<strlen(Zeroed);i++){
		     Zeroed[i]=Zeroed[i+ZeroPos];
		 }
		 //Clearence
		 for(i=(Length-ZeroPos);i<Length;i++){
    4b4c:	8f 5f       	subi	r24, 0xFF	; 255
    4b4e:	86 17       	cp	r24, r22
    4b50:	c8 f3       	brcs	.-14     	; 0x4b44 <RemSpaceLead+0x82>
		     Zeroed[i]=0;
		 }
     }
}
    4b52:	df 91       	pop	r29
    4b54:	cf 91       	pop	r28
    4b56:	08 95       	ret

00004b58 <RemSpaceLag>:
	 if (Spaced[0]==' ')Spaced[0]=0;
	 Spaced[strlen(Spaced)]=0;
}
*/
                                                      //012345678
void RemSpaceLag(char *Spaced){//Remove Space Character 1234SSSSS L=9 i=0 i=7
    4b58:	0f 93       	push	r16
    4b5a:	1f 93       	push	r17
    4b5c:	cf 93       	push	r28
    4b5e:	df 93       	push	r29
    4b60:	ec 01       	movw	r28, r24
unsigned char i=0,Length=0,PosSpaced=0;
     Length=strlen(Spaced);
    4b62:	dc 01       	movw	r26, r24
    4b64:	0d 90       	ld	r0, X+
    4b66:	00 20       	and	r0, r0
    4b68:	e9 f7       	brne	.-6      	; 0x4b64 <RemSpaceLag+0xc>
    4b6a:	11 97       	sbiw	r26, 0x01	; 1
    4b6c:	a8 1b       	sub	r26, r24
    4b6e:	b0 e0       	ldi	r27, 0x00	; 0
    4b70:	20 e0       	ldi	r18, 0x00	; 0
    4b72:	30 e0       	ldi	r19, 0x00	; 0
     for(i=0;i<(Length-1);i++){
    4b74:	6a 2f       	mov	r22, r26
    4b76:	70 e0       	ldi	r23, 0x00	; 0
    4b78:	8b 01       	movw	r16, r22
    4b7a:	01 50       	subi	r16, 0x01	; 1
    4b7c:	10 40       	sbci	r17, 0x00	; 0
	     if ((Spaced[Length-i-2]==' ')&&(Spaced[Length-i-1]==' ')){
		      Spaced[Length-i-1]=0;
    4b7e:	a1 50       	subi	r26, 0x01	; 1
    4b80:	16 c0       	rjmp	.+44     	; 0x4bae <RemSpaceLag+0x56>
                                                      //012345678
void RemSpaceLag(char *Spaced){//Remove Space Character 1234SSSSS L=9 i=0 i=7
unsigned char i=0,Length=0,PosSpaced=0;
     Length=strlen(Spaced);
     for(i=0;i<(Length-1);i++){
	     if ((Spaced[Length-i-2]==' ')&&(Spaced[Length-i-1]==' ')){
    4b82:	ab 01       	movw	r20, r22
    4b84:	48 1b       	sub	r20, r24
    4b86:	59 0b       	sbc	r21, r25
    4b88:	fe 01       	movw	r30, r28
    4b8a:	e4 0f       	add	r30, r20
    4b8c:	f5 1f       	adc	r31, r21
    4b8e:	32 97       	sbiw	r30, 0x02	; 2
    4b90:	80 81       	ld	r24, Z
    4b92:	80 32       	cpi	r24, 0x20	; 32
    4b94:	89 f4       	brne	.+34     	; 0x4bb8 <RemSpaceLag+0x60>
    4b96:	fa 01       	movw	r30, r20
    4b98:	31 97       	sbiw	r30, 0x01	; 1
    4b9a:	ec 0f       	add	r30, r28
    4b9c:	fd 1f       	adc	r31, r29
    4b9e:	2f 5f       	subi	r18, 0xFF	; 255
    4ba0:	3f 4f       	sbci	r19, 0xFF	; 255
    4ba2:	80 81       	ld	r24, Z
    4ba4:	80 32       	cpi	r24, 0x20	; 32
    4ba6:	41 f4       	brne	.+16     	; 0x4bb8 <RemSpaceLag+0x60>
		      Spaced[Length-i-1]=0;
    4ba8:	10 82       	st	Z, r1
    4baa:	ba 2f       	mov	r27, r26
    4bac:	b2 1b       	sub	r27, r18
*/
                                                      //012345678
void RemSpaceLag(char *Spaced){//Remove Space Character 1234SSSSS L=9 i=0 i=7
unsigned char i=0,Length=0,PosSpaced=0;
     Length=strlen(Spaced);
     for(i=0;i<(Length-1);i++){
    4bae:	82 2f       	mov	r24, r18
    4bb0:	90 e0       	ldi	r25, 0x00	; 0
    4bb2:	80 17       	cp	r24, r16
    4bb4:	91 07       	cpc	r25, r17
    4bb6:	2c f3       	brlt	.-54     	; 0x4b82 <RemSpaceLag+0x2a>
		      Spaced[Length-i-1]=0;
			  PosSpaced=Length-i-2;
			  }
         else break;
	 }
	 if (Spaced[PosSpaced]==' ')Spaced[PosSpaced]=0;
    4bb8:	fe 01       	movw	r30, r28
    4bba:	eb 0f       	add	r30, r27
    4bbc:	f1 1d       	adc	r31, r1
    4bbe:	80 81       	ld	r24, Z
    4bc0:	80 32       	cpi	r24, 0x20	; 32
    4bc2:	09 f4       	brne	.+2      	; 0x4bc6 <RemSpaceLag+0x6e>
    4bc4:	10 82       	st	Z, r1
	 if (Spaced[0]==' ')Spaced[0]=0;
    4bc6:	88 81       	ld	r24, Y
    4bc8:	80 32       	cpi	r24, 0x20	; 32
    4bca:	09 f4       	brne	.+2      	; 0x4bce <RemSpaceLag+0x76>
    4bcc:	18 82       	st	Y, r1
	 Spaced[strlen(Spaced)]=0;
    4bce:	fe 01       	movw	r30, r28
    4bd0:	01 90       	ld	r0, Z+
    4bd2:	00 20       	and	r0, r0
    4bd4:	e9 f7       	brne	.-6      	; 0x4bd0 <RemSpaceLag+0x78>
    4bd6:	31 97       	sbiw	r30, 0x01	; 1
    4bd8:	ec 1b       	sub	r30, r28
    4bda:	fd 0b       	sbc	r31, r29
    4bdc:	ec 0f       	add	r30, r28
    4bde:	fd 1f       	adc	r31, r29
    4be0:	10 82       	st	Z, r1
}
    4be2:	df 91       	pop	r29
    4be4:	cf 91       	pop	r28
    4be6:	1f 91       	pop	r17
    4be8:	0f 91       	pop	r16
    4bea:	08 95       	ret

00004bec <procMessage57>:
     StrPosCopy(rcv_trans,strAmount,135,7);
     StrPosCopy(rcv_trans,strGainPoints,142,4);
     return Result;
}

char procMessage57(){
    4bec:	1f 93       	push	r17
	    Dest[IdxSource+i]=Source[i];
	 }Dest[IdxSource+Length]=0;
}
char CharPosCopy(char *Source, unsigned int IdxSource){
     char Result;
     Result=Source[IdxSource];
    4bee:	10 91 8a 0a 	lds	r17, 0x0A8A
    4bf2:	20 e0       	ldi	r18, 0x00	; 0
    4bf4:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    4bf6:	f9 01       	movw	r30, r18
    4bf8:	ef 5a       	subi	r30, 0xAF	; 175
    4bfa:	f5 4f       	sbci	r31, 0xF5	; 245
    4bfc:	d9 01       	movw	r26, r18
    4bfe:	a3 54       	subi	r26, 0x43	; 67
    4c00:	b3 4f       	sbci	r27, 0xF3	; 243
    4c02:	95 96       	adiw	r26, 0x25	; 37
    4c04:	8c 91       	ld	r24, X
    4c06:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    4c08:	2f 5f       	subi	r18, 0xFF	; 255
    4c0a:	3f 4f       	sbci	r19, 0xFF	; 255
    4c0c:	24 31       	cpi	r18, 0x14	; 20
    4c0e:	31 05       	cpc	r19, r1
    4c10:	91 f7       	brne	.-28     	; 0x4bf6 <procMessage57+0xa>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    4c12:	10 92 65 0a 	sts	0x0A65, r1
	 
	     //Card Status
		 Result=(CharPosCopy(rcv_trans,57)-'0')+1;
		 //CardID
		 StrPosCopy(strCardID,rcv_trans,37,20);
		 RemSpaceLead(strCardID);
    4c16:	8d eb       	ldi	r24, 0xBD	; 189
    4c18:	9c e0       	ldi	r25, 0x0C	; 12
    4c1a:	0e 94 61 25 	call	0x4ac2	; 0x4ac2 <RemSpaceLead>
    4c1e:	20 e0       	ldi	r18, 0x00	; 0
    4c20:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    4c22:	f9 01       	movw	r30, r18
    4c24:	ed 5c       	subi	r30, 0xCD	; 205
    4c26:	fb 4f       	sbci	r31, 0xFB	; 251
    4c28:	d9 01       	movw	r26, r18
    4c2a:	af 5a       	subi	r26, 0xAF	; 175
    4c2c:	b5 4f       	sbci	r27, 0xF5	; 245
    4c2e:	dc 96       	adiw	r26, 0x3c	; 60
    4c30:	8c 91       	ld	r24, X
    4c32:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    4c34:	2f 5f       	subi	r18, 0xFF	; 255
    4c36:	3f 4f       	sbci	r19, 0xFF	; 255
    4c38:	28 32       	cpi	r18, 0x28	; 40
    4c3a:	31 05       	cpc	r19, r1
    4c3c:	91 f7       	brne	.-28     	; 0x4c22 <procMessage57+0x36>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    4c3e:	10 92 5b 04 	sts	0x045B, r1
		 //CardID
		 StrPosCopy(strCardID,rcv_trans,37,20);
		 RemSpaceLead(strCardID);
	     //Card Holder
		 StrPosCopy(rcv_trans,strCardHolder,60,40);
		 RemSpaceLag(strCardHolder);
    4c42:	83 e3       	ldi	r24, 0x33	; 51
    4c44:	94 e0       	ldi	r25, 0x04	; 4
    4c46:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <RemSpaceLag>
    4c4a:	20 e0       	ldi	r18, 0x00	; 0
    4c4c:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    4c4e:	f9 01       	movw	r30, r18
    4c50:	e6 59       	subi	r30, 0x96	; 150
    4c52:	fb 4f       	sbci	r31, 0xFB	; 251
    4c54:	d9 01       	movw	r26, r18
    4c56:	a7 51       	subi	r26, 0x17	; 23
    4c58:	b5 4f       	sbci	r27, 0xF5	; 245
    4c5a:	8c 91       	ld	r24, X
    4c5c:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    4c5e:	2f 5f       	subi	r18, 0xFF	; 255
    4c60:	3f 4f       	sbci	r19, 0xFF	; 255
    4c62:	29 31       	cpi	r18, 0x19	; 25
    4c64:	31 05       	cpc	r19, r1
    4c66:	99 f7       	brne	.-26     	; 0x4c4e <procMessage57+0x62>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    4c68:	10 92 83 04 	sts	0x0483, r1
	     //Card Holder
		 StrPosCopy(rcv_trans,strCardHolder,60,40);
		 RemSpaceLag(strCardHolder);
		 //BalanceTypePrint
		 StrPosCopy(rcv_trans,strBalanceTypePrint,154-2,25);
		 RemSpaceLag(strBalanceTypePrint);
    4c6c:	8a e6       	ldi	r24, 0x6A	; 106
    4c6e:	94 e0       	ldi	r25, 0x04	; 4
    4c70:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <RemSpaceLag>
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    4c74:	80 91 02 0b 	lds	r24, 0x0B02
    4c78:	80 93 f4 03 	sts	0x03F4, r24
	 }Dest[Length]=0;
    4c7c:	10 92 f5 03 	sts	0x03F5, r1
    4c80:	20 e0       	ldi	r18, 0x00	; 0
    4c82:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    4c84:	f9 01       	movw	r30, r18
    4c86:	e1 5d       	subi	r30, 0xD1	; 209
    4c88:	f2 4f       	sbci	r31, 0xF2	; 242
    4c8a:	d9 01       	movw	r26, r18
    4c8c:	ad 5f       	subi	r26, 0xFD	; 253
    4c8e:	b4 4f       	sbci	r27, 0xF4	; 244
    4c90:	8c 91       	ld	r24, X
    4c92:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    4c94:	2f 5f       	subi	r18, 0xFF	; 255
    4c96:	3f 4f       	sbci	r19, 0xFF	; 255
    4c98:	2d 30       	cpi	r18, 0x0D	; 13
    4c9a:	31 05       	cpc	r19, r1
    4c9c:	99 f7       	brne	.-26     	; 0x4c84 <procMessage57+0x98>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    4c9e:	10 92 3c 0d 	sts	0x0D3C, r1
		 RemSpaceLag(strBalanceTypePrint);
         //BalanceTypeCode
		 StrPosCopy(rcv_trans,strBalanceCode,177,1);
		 //Balance
		 StrPosCopy(rcv_trans,strBalance,178,13);
		 RemSpaceLead(strBalance);
    4ca2:	8f e2       	ldi	r24, 0x2F	; 47
    4ca4:	9d e0       	ldi	r25, 0x0D	; 13
    4ca6:	0e 94 61 25 	call	0x4ac2	; 0x4ac2 <RemSpaceLead>
    4caa:	20 e0       	ldi	r18, 0x00	; 0
    4cac:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    4cae:	f9 01       	movw	r30, r18
    4cb0:	e2 5d       	subi	r30, 0xD2	; 210
    4cb2:	f5 4f       	sbci	r31, 0xF5	; 245
    4cb4:	d9 01       	movw	r26, r18
    4cb6:	a0 5f       	subi	r26, 0xF0	; 240
    4cb8:	b4 4f       	sbci	r27, 0xF4	; 244
    4cba:	8c 91       	ld	r24, X
    4cbc:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    4cbe:	2f 5f       	subi	r18, 0xFF	; 255
    4cc0:	3f 4f       	sbci	r19, 0xFF	; 255
    4cc2:	2a 30       	cpi	r18, 0x0A	; 10
    4cc4:	31 05       	cpc	r19, r1
    4cc6:	99 f7       	brne	.-26     	; 0x4cae <procMessage57+0xc2>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    4cc8:	10 92 38 0a 	sts	0x0A38, r1
		 //Balance
		 StrPosCopy(rcv_trans,strBalance,178,13);
		 RemSpaceLead(strBalance);
		 //LicPlate
		 StrPosCopy(rcv_trans,strLicPlate,193-2,10);
		 RemSpaceLag(strLicPlate);
    4ccc:	8e e2       	ldi	r24, 0x2E	; 46
    4cce:	9a e0       	ldi	r25, 0x0A	; 10
    4cd0:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <RemSpaceLag>
    4cd4:	20 e0       	ldi	r18, 0x00	; 0
    4cd6:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    4cd8:	f9 01       	movw	r30, r18
    4cda:	e5 57       	subi	r30, 0x75	; 117
    4cdc:	f7 4f       	sbci	r31, 0xF7	; 247
    4cde:	d9 01       	movw	r26, r18
    4ce0:	a6 5e       	subi	r26, 0xE6	; 230
    4ce2:	b4 4f       	sbci	r27, 0xF4	; 244
    4ce4:	8c 91       	ld	r24, X
    4ce6:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    4ce8:	2f 5f       	subi	r18, 0xFF	; 255
    4cea:	3f 4f       	sbci	r19, 0xFF	; 255
    4cec:	24 31       	cpi	r18, 0x14	; 20
    4cee:	31 05       	cpc	r19, r1
    4cf0:	99 f7       	brne	.-26     	; 0x4cd8 <procMessage57+0xec>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    4cf2:	10 92 9f 08 	sts	0x089F, r1
		 //LicPlate
		 StrPosCopy(rcv_trans,strLicPlate,193-2,10);
		 RemSpaceLag(strLicPlate);
		 //CompName
		 StrPosCopy(rcv_trans,strCompName,203-2,20);
		 RemSpaceLag(strCompName);
    4cf6:	8b e8       	ldi	r24, 0x8B	; 139
    4cf8:	98 e0       	ldi	r25, 0x08	; 8
    4cfa:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <RemSpaceLag>
		 _uart_print(0,1,strCompName);
		 
_uart_print(0,1,strCardID);
*/	
     return Result;
}
    4cfe:	81 2f       	mov	r24, r17
    4d00:	8f 52       	subi	r24, 0x2F	; 47
    4d02:	1f 91       	pop	r17
    4d04:	08 95       	ret

00004d06 <clearString>:
	     break;
	}
  return Result;
}

void clearString(char *str){
    4d06:	20 e0       	ldi	r18, 0x00	; 0
    4d08:	30 e0       	ldi	r19, 0x00	; 0
    4d0a:	06 c0       	rjmp	.+12     	; 0x4d18 <clearString+0x12>
     int i;
	 for(i=0;i<strlen(str);i++){
	    str[i]=0;
    4d0c:	fc 01       	movw	r30, r24
    4d0e:	e2 0f       	add	r30, r18
    4d10:	f3 1f       	adc	r31, r19
    4d12:	10 82       	st	Z, r1
  return Result;
}

void clearString(char *str){
     int i;
	 for(i=0;i<strlen(str);i++){
    4d14:	2f 5f       	subi	r18, 0xFF	; 255
    4d16:	3f 4f       	sbci	r19, 0xFF	; 255
    4d18:	fc 01       	movw	r30, r24
    4d1a:	01 90       	ld	r0, Z+
    4d1c:	00 20       	and	r0, r0
    4d1e:	e9 f7       	brne	.-6      	; 0x4d1a <clearString+0x14>
    4d20:	31 97       	sbiw	r30, 0x01	; 1
    4d22:	e8 1b       	sub	r30, r24
    4d24:	f9 0b       	sbc	r31, r25
    4d26:	2e 17       	cp	r18, r30
    4d28:	3f 07       	cpc	r19, r31
    4d2a:	80 f3       	brcs	.-32     	; 0x4d0c <clearString+0x6>
	    str[i]=0;
	 }
}
    4d2c:	08 95       	ret

00004d2e <AddZeroLead>:
	 }String[Size]=0;
  }
}


void AddZeroLead(char *String,unsigned char Size){// 1234 ->0000001234
    4d2e:	bf 92       	push	r11
    4d30:	cf 92       	push	r12
    4d32:	df 92       	push	r13
    4d34:	ef 92       	push	r14
    4d36:	ff 92       	push	r15
    4d38:	0f 93       	push	r16
    4d3a:	1f 93       	push	r17
    4d3c:	df 93       	push	r29
    4d3e:	cf 93       	push	r28
    4d40:	cd b7       	in	r28, 0x3d	; 61
    4d42:	de b7       	in	r29, 0x3e	; 62
    4d44:	6e 97       	sbiw	r28, 0x1e	; 30
    4d46:	0f b6       	in	r0, 0x3f	; 63
    4d48:	f8 94       	cli
    4d4a:	de bf       	out	0x3e, r29	; 62
    4d4c:	0f be       	out	0x3f, r0	; 63
    4d4e:	cd bf       	out	0x3d, r28	; 61
    4d50:	8c 01       	movw	r16, r24
     char i,Length,strAdded[30];
     Length=strlen(String);
    4d52:	fc 01       	movw	r30, r24
    4d54:	01 90       	ld	r0, Z+
    4d56:	00 20       	and	r0, r0
    4d58:	e9 f7       	brne	.-6      	; 0x4d54 <AddZeroLead+0x26>
    4d5a:	31 97       	sbiw	r30, 0x01	; 1
    4d5c:	2e 2f       	mov	r18, r30
    4d5e:	28 1b       	sub	r18, r24

	 if (Size>Length){
    4d60:	26 17       	cp	r18, r22
    4d62:	e0 f5       	brcc	.+120    	; 0x4ddc <AddZeroLead+0xae>
    4d64:	7e 01       	movw	r14, r28
    4d66:	08 94       	sec
    4d68:	e1 1c       	adc	r14, r1
    4d6a:	f1 1c       	adc	r15, r1
    4d6c:	f7 01       	movw	r30, r14
	 }String[Size]=0;
  }
}


void AddZeroLead(char *String,unsigned char Size){// 1234 ->0000001234
    4d6e:	be 2c       	mov	r11, r14
     char i,Length,strAdded[30];
     Length=strlen(String);

	 if (Size>Length){
         for(i=0;i<Size;i++){
	         strAdded[i]='0';
    4d70:	90 e3       	ldi	r25, 0x30	; 48
    4d72:	01 c0       	rjmp	.+2      	; 0x4d76 <AddZeroLead+0x48>
    4d74:	91 93       	st	Z+, r25
void AddZeroLead(char *String,unsigned char Size){// 1234 ->0000001234
     char i,Length,strAdded[30];
     Length=strlen(String);

	 if (Size>Length){
         for(i=0;i<Size;i++){
    4d76:	8e 2f       	mov	r24, r30
    4d78:	8b 19       	sub	r24, r11
    4d7a:	86 17       	cp	r24, r22
    4d7c:	d8 f3       	brcs	.-10     	; 0x4d74 <AddZeroLead+0x46>
	         strAdded[i]='0';
	     }strAdded[Size]=0;
    4d7e:	46 2f       	mov	r20, r22
    4d80:	50 e0       	ldi	r21, 0x00	; 0
    4d82:	ce 01       	movw	r24, r28
    4d84:	01 96       	adiw	r24, 0x01	; 1
    4d86:	fc 01       	movw	r30, r24
    4d88:	e4 0f       	add	r30, r20
    4d8a:	f5 1f       	adc	r31, r21
    4d8c:	10 82       	st	Z, r1
	     //Copy
         for(i=(Size-Length);i<Size;i++){
    4d8e:	76 2f       	mov	r23, r22
    4d90:	72 1b       	sub	r23, r18
    4d92:	6c 01       	movw	r12, r24
	         strAdded[i]=String[i-(Size-Length)];
    4d94:	30 e0       	ldi	r19, 0x00	; 0
    4d96:	24 1b       	sub	r18, r20
    4d98:	35 0b       	sbc	r19, r21
    4d9a:	0c c0       	rjmp	.+24     	; 0x4db4 <AddZeroLead+0x86>
    4d9c:	e7 2f       	mov	r30, r23
    4d9e:	f0 e0       	ldi	r31, 0x00	; 0
    4da0:	d6 01       	movw	r26, r12
    4da2:	ae 0f       	add	r26, r30
    4da4:	bf 1f       	adc	r27, r31
    4da6:	e0 0f       	add	r30, r16
    4da8:	f1 1f       	adc	r31, r17
    4daa:	e2 0f       	add	r30, r18
    4dac:	f3 1f       	adc	r31, r19
    4dae:	80 81       	ld	r24, Z
    4db0:	8c 93       	st	X, r24
	 if (Size>Length){
         for(i=0;i<Size;i++){
	         strAdded[i]='0';
	     }strAdded[Size]=0;
	     //Copy
         for(i=(Size-Length);i<Size;i++){
    4db2:	7f 5f       	subi	r23, 0xFF	; 255
    4db4:	76 17       	cp	r23, r22
    4db6:	90 f3       	brcs	.-28     	; 0x4d9c <AddZeroLead+0x6e>
	         strAdded[i]=String[i-(Size-Length)];
	     }strAdded[Size]=0;
    4db8:	4c 0d       	add	r20, r12
    4dba:	5d 1d       	adc	r21, r13
    4dbc:	da 01       	movw	r26, r20
    4dbe:	1c 92       	st	X, r1
    4dc0:	f8 01       	movw	r30, r16
    4dc2:	04 c0       	rjmp	.+8      	; 0x4dcc <AddZeroLead+0x9e>
	     //Zeroed
         for(i=0;i<Size;i++){
	         String[i]=strAdded[i];
    4dc4:	d7 01       	movw	r26, r14
    4dc6:	8d 91       	ld	r24, X+
    4dc8:	7d 01       	movw	r14, r26
    4dca:	81 93       	st	Z+, r24
	     //Copy
         for(i=(Size-Length);i<Size;i++){
	         strAdded[i]=String[i-(Size-Length)];
	     }strAdded[Size]=0;
	     //Zeroed
         for(i=0;i<Size;i++){
    4dcc:	8e 2d       	mov	r24, r14
    4dce:	8b 19       	sub	r24, r11
    4dd0:	86 17       	cp	r24, r22
    4dd2:	c0 f3       	brcs	.-16     	; 0x4dc4 <AddZeroLead+0x96>
	         String[i]=strAdded[i];
	     }String[Size]=0;
    4dd4:	06 0f       	add	r16, r22
    4dd6:	11 1d       	adc	r17, r1
    4dd8:	f8 01       	movw	r30, r16
    4dda:	10 82       	st	Z, r1
	 }
}
    4ddc:	6e 96       	adiw	r28, 0x1e	; 30
    4dde:	0f b6       	in	r0, 0x3f	; 63
    4de0:	f8 94       	cli
    4de2:	de bf       	out	0x3e, r29	; 62
    4de4:	0f be       	out	0x3f, r0	; 63
    4de6:	cd bf       	out	0x3d, r28	; 61
    4de8:	cf 91       	pop	r28
    4dea:	df 91       	pop	r29
    4dec:	1f 91       	pop	r17
    4dee:	0f 91       	pop	r16
    4df0:	ff 90       	pop	r15
    4df2:	ef 90       	pop	r14
    4df4:	df 90       	pop	r13
    4df6:	cf 90       	pop	r12
    4df8:	bf 90       	pop	r11
    4dfa:	08 95       	ret

00004dfc <GetTotalizerMoney>:
	     FIPAddr=FIPAddr-1;	     
	     GetTotalizerData(TVOLUME,TOTALIZER_NOW,FIPAddr,iGrade,Result);
	 }
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalTotalVolume),2,Result);
}
void GetTotalizerMoney(char iPumpID,char iGrade, char *Result){
    4dfc:	0f 93       	push	r16
    4dfe:	1f 93       	push	r17
    4e00:	cf 93       	push	r28
    4e02:	df 93       	push	r29
    4e04:	18 2f       	mov	r17, r24
    4e06:	06 2f       	mov	r16, r22
    4e08:	ea 01       	movw	r28, r20
     char FIPAddr;
     AddZeroLead(Result,13); 
    4e0a:	ca 01       	movw	r24, r20
    4e0c:	6d e0       	ldi	r22, 0x0D	; 13
    4e0e:	0e 94 97 26 	call	0x4d2e	; 0x4d2e <AddZeroLead>
	 FIPAddr=GetFIPAddr(iPumpID);
    4e12:	81 2f       	mov	r24, r17
    4e14:	0e 94 41 1d 	call	0x3a82	; 0x3a82 <GetFIPAddr>
    4e18:	48 2f       	mov	r20, r24
	 if (FIPAddr>0){
    4e1a:	88 23       	and	r24, r24
    4e1c:	39 f0       	breq	.+14     	; 0x4e2c <GetTotalizerMoney+0x30>
	    FIPAddr=FIPAddr-1;
	    GetTotalizerData(TMONEY,TOTALIZER_NOW,FIPAddr,iGrade,Result);
    4e1e:	41 50       	subi	r20, 0x01	; 1
    4e20:	81 e0       	ldi	r24, 0x01	; 1
    4e22:	61 e0       	ldi	r22, 0x01	; 1
    4e24:	20 2f       	mov	r18, r16
    4e26:	8e 01       	movw	r16, r28
    4e28:	0e 94 00 1e 	call	0x3c00	; 0x3c00 <GetTotalizerData>
	}
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalTotalMoney),2,Result);
}
    4e2c:	df 91       	pop	r29
    4e2e:	cf 91       	pop	r28
    4e30:	1f 91       	pop	r17
    4e32:	0f 91       	pop	r16
    4e34:	08 95       	ret

00004e36 <GetTotalizerVolume>:
     AddZeroLead(Result,10);
	 sprintf_P(Result,PSTR("%s"),RecPumpData[iPumpID&0x0F].Money);
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalMoney),3,Result);
}

void GetTotalizerVolume(char iPumpID,char iGrade,char *Result){
    4e36:	0f 93       	push	r16
    4e38:	1f 93       	push	r17
    4e3a:	cf 93       	push	r28
    4e3c:	df 93       	push	r29
    4e3e:	18 2f       	mov	r17, r24
    4e40:	06 2f       	mov	r16, r22
    4e42:	ea 01       	movw	r28, r20
     char FIPAddr;
     AddZeroLead(Result,11);
    4e44:	ca 01       	movw	r24, r20
    4e46:	6b e0       	ldi	r22, 0x0B	; 11
    4e48:	0e 94 97 26 	call	0x4d2e	; 0x4d2e <AddZeroLead>
	 FIPAddr=GetFIPAddr(iPumpID);
    4e4c:	81 2f       	mov	r24, r17
    4e4e:	0e 94 41 1d 	call	0x3a82	; 0x3a82 <GetFIPAddr>
    4e52:	48 2f       	mov	r20, r24
	 if (FIPAddr>0){
    4e54:	88 23       	and	r24, r24
    4e56:	39 f0       	breq	.+14     	; 0x4e66 <GetTotalizerVolume+0x30>
	     FIPAddr=FIPAddr-1;	     
	     GetTotalizerData(TVOLUME,TOTALIZER_NOW,FIPAddr,iGrade,Result);
    4e58:	41 50       	subi	r20, 0x01	; 1
    4e5a:	80 e0       	ldi	r24, 0x00	; 0
    4e5c:	61 e0       	ldi	r22, 0x01	; 1
    4e5e:	20 2f       	mov	r18, r16
    4e60:	8e 01       	movw	r16, r28
    4e62:	0e 94 00 1e 	call	0x3c00	; 0x3c00 <GetTotalizerData>
	 }
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalTotalVolume),2,Result);
}
    4e66:	df 91       	pop	r29
    4e68:	cf 91       	pop	r28
    4e6a:	1f 91       	pop	r17
    4e6c:	0f 91       	pop	r16
    4e6e:	08 95       	ret

00004e70 <GetTransactionMoney>:
void GetTransactionVolume(char iPumpID,char *Result){
     AddZeroLead(Result,10);
     sprintf_P(Result,PSTR("%s"),RecPumpData[iPumpID&0x0F].Volume); 
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalVolume),3,Result);
}
void GetTransactionMoney(char iPumpID,char *Result){
    4e70:	ef 92       	push	r14
    4e72:	ff 92       	push	r15
    4e74:	0f 93       	push	r16
    4e76:	1f 93       	push	r17
    4e78:	08 2f       	mov	r16, r24
    4e7a:	7b 01       	movw	r14, r22
     AddZeroLead(Result,10);
    4e7c:	cb 01       	movw	r24, r22
    4e7e:	6a e0       	ldi	r22, 0x0A	; 10
    4e80:	0e 94 97 26 	call	0x4d2e	; 0x4d2e <AddZeroLead>
	 sprintf_P(Result,PSTR("%s"),RecPumpData[iPumpID&0x0F].Money);
    4e84:	00 d0       	rcall	.+0      	; 0x4e86 <GetTransactionMoney+0x16>
    4e86:	00 d0       	rcall	.+0      	; 0x4e88 <GetTransactionMoney+0x18>
    4e88:	00 d0       	rcall	.+0      	; 0x4e8a <GetTransactionMoney+0x1a>
    4e8a:	ed b7       	in	r30, 0x3d	; 61
    4e8c:	fe b7       	in	r31, 0x3e	; 62
    4e8e:	31 96       	adiw	r30, 0x01	; 1
    4e90:	ad b7       	in	r26, 0x3d	; 61
    4e92:	be b7       	in	r27, 0x3e	; 62
    4e94:	12 96       	adiw	r26, 0x02	; 2
    4e96:	fc 92       	st	X, r15
    4e98:	ee 92       	st	-X, r14
    4e9a:	11 97       	sbiw	r26, 0x01	; 1
    4e9c:	84 e3       	ldi	r24, 0x34	; 52
    4e9e:	93 e0       	ldi	r25, 0x03	; 3
    4ea0:	93 83       	std	Z+3, r25	; 0x03
    4ea2:	82 83       	std	Z+2, r24	; 0x02
    4ea4:	10 e0       	ldi	r17, 0x00	; 0
    4ea6:	0f 70       	andi	r16, 0x0F	; 15
    4ea8:	10 70       	andi	r17, 0x00	; 0
    4eaa:	85 e3       	ldi	r24, 0x35	; 53
    4eac:	90 e0       	ldi	r25, 0x00	; 0
    4eae:	9c 01       	movw	r18, r24
    4eb0:	02 9f       	mul	r16, r18
    4eb2:	c0 01       	movw	r24, r0
    4eb4:	03 9f       	mul	r16, r19
    4eb6:	90 0d       	add	r25, r0
    4eb8:	12 9f       	mul	r17, r18
    4eba:	90 0d       	add	r25, r0
    4ebc:	11 24       	eor	r1, r1
    4ebe:	8a 51       	subi	r24, 0x1A	; 26
    4ec0:	99 4f       	sbci	r25, 0xF9	; 249
    4ec2:	95 83       	std	Z+5, r25	; 0x05
    4ec4:	84 83       	std	Z+4, r24	; 0x04
    4ec6:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    4eca:	8d b7       	in	r24, 0x3d	; 61
    4ecc:	9e b7       	in	r25, 0x3e	; 62
    4ece:	06 96       	adiw	r24, 0x06	; 6
    4ed0:	0f b6       	in	r0, 0x3f	; 63
    4ed2:	f8 94       	cli
    4ed4:	9e bf       	out	0x3e, r25	; 62
    4ed6:	0f be       	out	0x3f, r0	; 63
    4ed8:	8d bf       	out	0x3d, r24	; 61
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalMoney),3,Result);
}
    4eda:	1f 91       	pop	r17
    4edc:	0f 91       	pop	r16
    4ede:	ff 90       	pop	r15
    4ee0:	ef 90       	pop	r14
    4ee2:	08 95       	ret

00004ee4 <GetTransactionVolume>:
     }
*/
     FormatDecimal(Result,CurrentDecimal);
}

void GetTransactionVolume(char iPumpID,char *Result){
    4ee4:	ef 92       	push	r14
    4ee6:	ff 92       	push	r15
    4ee8:	0f 93       	push	r16
    4eea:	1f 93       	push	r17
    4eec:	08 2f       	mov	r16, r24
    4eee:	7b 01       	movw	r14, r22
     AddZeroLead(Result,10);
    4ef0:	cb 01       	movw	r24, r22
    4ef2:	6a e0       	ldi	r22, 0x0A	; 10
    4ef4:	0e 94 97 26 	call	0x4d2e	; 0x4d2e <AddZeroLead>
     sprintf_P(Result,PSTR("%s"),RecPumpData[iPumpID&0x0F].Volume); 
    4ef8:	00 d0       	rcall	.+0      	; 0x4efa <GetTransactionVolume+0x16>
    4efa:	00 d0       	rcall	.+0      	; 0x4efc <GetTransactionVolume+0x18>
    4efc:	00 d0       	rcall	.+0      	; 0x4efe <GetTransactionVolume+0x1a>
    4efe:	ed b7       	in	r30, 0x3d	; 61
    4f00:	fe b7       	in	r31, 0x3e	; 62
    4f02:	31 96       	adiw	r30, 0x01	; 1
    4f04:	ad b7       	in	r26, 0x3d	; 61
    4f06:	be b7       	in	r27, 0x3e	; 62
    4f08:	12 96       	adiw	r26, 0x02	; 2
    4f0a:	fc 92       	st	X, r15
    4f0c:	ee 92       	st	-X, r14
    4f0e:	11 97       	sbiw	r26, 0x01	; 1
    4f10:	87 e3       	ldi	r24, 0x37	; 55
    4f12:	93 e0       	ldi	r25, 0x03	; 3
    4f14:	93 83       	std	Z+3, r25	; 0x03
    4f16:	82 83       	std	Z+2, r24	; 0x02
    4f18:	10 e0       	ldi	r17, 0x00	; 0
    4f1a:	0f 70       	andi	r16, 0x0F	; 15
    4f1c:	10 70       	andi	r17, 0x00	; 0
    4f1e:	85 e3       	ldi	r24, 0x35	; 53
    4f20:	90 e0       	ldi	r25, 0x00	; 0
    4f22:	9c 01       	movw	r18, r24
    4f24:	02 9f       	mul	r16, r18
    4f26:	c0 01       	movw	r24, r0
    4f28:	03 9f       	mul	r16, r19
    4f2a:	90 0d       	add	r25, r0
    4f2c:	12 9f       	mul	r17, r18
    4f2e:	90 0d       	add	r25, r0
    4f30:	11 24       	eor	r1, r1
    4f32:	83 52       	subi	r24, 0x23	; 35
    4f34:	99 4f       	sbci	r25, 0xF9	; 249
    4f36:	95 83       	std	Z+5, r25	; 0x05
    4f38:	84 83       	std	Z+4, r24	; 0x04
    4f3a:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    4f3e:	8d b7       	in	r24, 0x3d	; 61
    4f40:	9e b7       	in	r25, 0x3e	; 62
    4f42:	06 96       	adiw	r24, 0x06	; 6
    4f44:	0f b6       	in	r0, 0x3f	; 63
    4f46:	f8 94       	cli
    4f48:	9e bf       	out	0x3e, r25	; 62
    4f4a:	0f be       	out	0x3f, r0	; 63
    4f4c:	8d bf       	out	0x3d, r24	; 61
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalVolume),3,Result);
}
    4f4e:	1f 91       	pop	r17
    4f50:	0f 91       	pop	r16
    4f52:	ff 90       	pop	r15
    4f54:	ef 90       	pop	r14
    4f56:	08 95       	ret

00004f58 <SetTotalizerData>:
			  }
		  }
	 }
}

void SetTotalizerData(char TType, char TAddr, char xPumpAddr, char xGradeAddr, char *strValue){// 0 1 1 "00000000"
    4f58:	af 92       	push	r10
    4f5a:	bf 92       	push	r11
    4f5c:	cf 92       	push	r12
    4f5e:	df 92       	push	r13
    4f60:	ef 92       	push	r14
    4f62:	ff 92       	push	r15
    4f64:	0f 93       	push	r16
    4f66:	1f 93       	push	r17
    4f68:	df 93       	push	r29
    4f6a:	cf 93       	push	r28
    4f6c:	cd b7       	in	r28, 0x3d	; 61
    4f6e:	de b7       	in	r29, 0x3e	; 62
    4f70:	65 97       	sbiw	r28, 0x15	; 21
    4f72:	0f b6       	in	r0, 0x3f	; 63
    4f74:	f8 94       	cli
    4f76:	de bf       	out	0x3e, r29	; 62
    4f78:	0f be       	out	0x3f, r0	; 63
    4f7a:	cd bf       	out	0x3d, r28	; 61
    4f7c:	d8 2e       	mov	r13, r24
    4f7e:	c6 2e       	mov	r12, r22
    4f80:	b4 2e       	mov	r11, r20
    4f82:	a2 2e       	mov	r10, r18
     char rawValue[6],iPumpAddr,iGrade;
	 char strPValue[15];
	 char Idx;
	 char strSend[30];
	 //Convert String to RawData
	 if (strlen(strValue)<=12){
    4f84:	d8 01       	movw	r26, r16
    4f86:	0d 90       	ld	r0, X+
    4f88:	00 20       	and	r0, r0
    4f8a:	e9 f7       	brne	.-6      	; 0x4f86 <SetTotalizerData+0x2e>
    4f8c:	11 97       	sbiw	r26, 0x01	; 1
    4f8e:	a0 1b       	sub	r26, r16
    4f90:	b1 0b       	sbc	r27, r17
    4f92:	e7 e0       	ldi	r30, 0x07	; 7
    4f94:	ee 2e       	mov	r14, r30
    4f96:	f1 2c       	mov	r15, r1
    4f98:	ec 0e       	add	r14, r28
    4f9a:	fd 1e       	adc	r15, r29
    4f9c:	ad 30       	cpi	r26, 0x0D	; 13
    4f9e:	b1 05       	cpc	r27, r1
    4fa0:	58 f5       	brcc	.+86     	; 0x4ff8 <SetTotalizerData+0xa0>
	     sprintf_P(strPValue,PSTR("%s"),strValue);
    4fa2:	00 d0       	rcall	.+0      	; 0x4fa4 <SetTotalizerData+0x4c>
    4fa4:	00 d0       	rcall	.+0      	; 0x4fa6 <SetTotalizerData+0x4e>
    4fa6:	00 d0       	rcall	.+0      	; 0x4fa8 <SetTotalizerData+0x50>
    4fa8:	ed b7       	in	r30, 0x3d	; 61
    4faa:	fe b7       	in	r31, 0x3e	; 62
    4fac:	31 96       	adiw	r30, 0x01	; 1
    4fae:	ad b7       	in	r26, 0x3d	; 61
    4fb0:	be b7       	in	r27, 0x3e	; 62
    4fb2:	12 96       	adiw	r26, 0x02	; 2
    4fb4:	fc 92       	st	X, r15
    4fb6:	ee 92       	st	-X, r14
    4fb8:	11 97       	sbiw	r26, 0x01	; 1
    4fba:	89 eb       	ldi	r24, 0xB9	; 185
    4fbc:	95 e0       	ldi	r25, 0x05	; 5
    4fbe:	93 83       	std	Z+3, r25	; 0x03
    4fc0:	82 83       	std	Z+2, r24	; 0x02
    4fc2:	15 83       	std	Z+5, r17	; 0x05
    4fc4:	04 83       	std	Z+4, r16	; 0x04
    4fc6:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
		 if (strlen(strPValue)<12)AddZeroLead(strPValue,12);
    4fca:	f7 01       	movw	r30, r14
    4fcc:	01 90       	ld	r0, Z+
    4fce:	00 20       	and	r0, r0
    4fd0:	e9 f7       	brne	.-6      	; 0x4fcc <SetTotalizerData+0x74>
    4fd2:	31 97       	sbiw	r30, 0x01	; 1
    4fd4:	ee 19       	sub	r30, r14
    4fd6:	ff 09       	sbc	r31, r15
    4fd8:	6d b7       	in	r22, 0x3d	; 61
    4fda:	7e b7       	in	r23, 0x3e	; 62
    4fdc:	6a 5f       	subi	r22, 0xFA	; 250
    4fde:	7f 4f       	sbci	r23, 0xFF	; 255
    4fe0:	0f b6       	in	r0, 0x3f	; 63
    4fe2:	f8 94       	cli
    4fe4:	7e bf       	out	0x3e, r23	; 62
    4fe6:	0f be       	out	0x3f, r0	; 63
    4fe8:	6d bf       	out	0x3d, r22	; 61
    4fea:	3c 97       	sbiw	r30, 0x0c	; 12
    4fec:	a0 f4       	brcc	.+40     	; 0x5016 <SetTotalizerData+0xbe>
    4fee:	c7 01       	movw	r24, r14
    4ff0:	6c e0       	ldi	r22, 0x0C	; 12
    4ff2:	0e 94 97 26 	call	0x4d2e	; 0x4d2e <AddZeroLead>
    4ff6:	0f c0       	rjmp	.+30     	; 0x5016 <SetTotalizerData+0xbe>
    4ff8:	8a 2f       	mov	r24, r26
    4ffa:	8c 50       	subi	r24, 0x0C	; 12
    4ffc:	f8 01       	movw	r30, r16
    4ffe:	e8 0f       	add	r30, r24
    5000:	f1 1d       	adc	r31, r1
    5002:	d7 01       	movw	r26, r14
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    5004:	9e 01       	movw	r18, r28
    5006:	2d 5e       	subi	r18, 0xED	; 237
    5008:	3f 4f       	sbci	r19, 0xFF	; 255
	    Dest[i]=Source[IdxSource+i];
    500a:	81 91       	ld	r24, Z+
    500c:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    500e:	a2 17       	cp	r26, r18
    5010:	b3 07       	cpc	r27, r19
    5012:	d9 f7       	brne	.-10     	; 0x500a <SetTotalizerData+0xb2>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    5014:	1b 8a       	std	Y+19, r1	; 0x13
	 else {//Lebih dari 8: 0123456789
	     Idx=strlen(strValue)-12;
	     StrPosCopy(strValue,strPValue,Idx,12);
	 }

	 iPumpAddr=(xPumpAddr&0x0F);
    5016:	0b 2d       	mov	r16, r11
    5018:	0f 70       	andi	r16, 0x0F	; 15
	 if ((xGradeAddr>=1)&&(xGradeAddr<=6))
    501a:	1a 2d       	mov	r17, r10
    501c:	11 50       	subi	r17, 0x01	; 1
    501e:	16 30       	cpi	r17, 0x06	; 6
    5020:	08 f0       	brcs	.+2      	; 0x5024 <SetTotalizerData+0xcc>
    5022:	10 e0       	ldi	r17, 0x00	; 0
	     iGrade=xGradeAddr-1;
	 StrToRaw(strPValue,rawValue);
    5024:	ce 01       	movw	r24, r28
    5026:	07 96       	adiw	r24, 0x07	; 7
    5028:	7e 01       	movw	r14, r28
    502a:	08 94       	sec
    502c:	e1 1c       	adc	r14, r1
    502e:	f1 1c       	adc	r15, r1
    5030:	b7 01       	movw	r22, r14
    5032:	0e 94 34 19 	call	0x3268	; 0x3268 <StrToRaw>

	 if (TType==TVOLUME)eeprom_write_block((const void*)&rawValue,(void*)&(TotalVolume[TAddr][iPumpAddr][iGrade]), sizeof(rawValue));
    5036:	dd 20       	and	r13, r13
    5038:	d9 f4       	brne	.+54     	; 0x5070 <SetTotalizerData+0x118>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    503a:	84 e2       	ldi	r24, 0x24	; 36
    503c:	08 9f       	mul	r16, r24
    503e:	c0 01       	movw	r24, r0
    5040:	11 24       	eor	r1, r1
    5042:	4c 2d       	mov	r20, r12
    5044:	50 e0       	ldi	r21, 0x00	; 0
    5046:	20 e2       	ldi	r18, 0x20	; 32
    5048:	31 e0       	ldi	r19, 0x01	; 1
    504a:	d9 01       	movw	r26, r18
    504c:	4a 9f       	mul	r20, r26
    504e:	90 01       	movw	r18, r0
    5050:	4b 9f       	mul	r20, r27
    5052:	30 0d       	add	r19, r0
    5054:	5a 9f       	mul	r21, r26
    5056:	30 0d       	add	r19, r0
    5058:	11 24       	eor	r1, r1
    505a:	82 0f       	add	r24, r18
    505c:	93 1f       	adc	r25, r19
    505e:	26 e0       	ldi	r18, 0x06	; 6
    5060:	12 9f       	mul	r17, r18
    5062:	90 01       	movw	r18, r0
    5064:	11 24       	eor	r1, r1
    5066:	82 0f       	add	r24, r18
    5068:	93 1f       	adc	r25, r19
    506a:	8d 53       	subi	r24, 0x3D	; 61
    506c:	9c 4f       	sbci	r25, 0xFC	; 252
    506e:	1d c0       	rjmp	.+58     	; 0x50aa <SetTotalizerData+0x152>
	 else 
	 if (TType==TMONEY)eeprom_write_block((const void*)&rawValue,(void*)&(TotalMoney[TAddr][iPumpAddr][iGrade]), sizeof(rawValue));
    5070:	b1 e0       	ldi	r27, 0x01	; 1
    5072:	db 16       	cp	r13, r27
    5074:	09 f5       	brne	.+66     	; 0x50b8 <SetTotalizerData+0x160>
    5076:	84 e2       	ldi	r24, 0x24	; 36
    5078:	08 9f       	mul	r16, r24
    507a:	c0 01       	movw	r24, r0
    507c:	11 24       	eor	r1, r1
    507e:	4c 2d       	mov	r20, r12
    5080:	50 e0       	ldi	r21, 0x00	; 0
    5082:	20 e2       	ldi	r18, 0x20	; 32
    5084:	31 e0       	ldi	r19, 0x01	; 1
    5086:	b9 01       	movw	r22, r18
    5088:	46 9f       	mul	r20, r22
    508a:	90 01       	movw	r18, r0
    508c:	47 9f       	mul	r20, r23
    508e:	30 0d       	add	r19, r0
    5090:	56 9f       	mul	r21, r22
    5092:	30 0d       	add	r19, r0
    5094:	11 24       	eor	r1, r1
    5096:	82 0f       	add	r24, r18
    5098:	93 1f       	adc	r25, r19
    509a:	26 e0       	ldi	r18, 0x06	; 6
    509c:	12 9f       	mul	r17, r18
    509e:	90 01       	movw	r18, r0
    50a0:	11 24       	eor	r1, r1
    50a2:	82 0f       	add	r24, r18
    50a4:	93 1f       	adc	r25, r19
    50a6:	8d 5f       	subi	r24, 0xFD	; 253
    50a8:	99 4f       	sbci	r25, 0xF9	; 249
    50aa:	b7 01       	movw	r22, r14
    50ac:	46 e0       	ldi	r20, 0x06	; 6
    50ae:	50 e0       	ldi	r21, 0x00	; 0
    50b0:	25 e0       	ldi	r18, 0x05	; 5
    50b2:	33 e1       	ldi	r19, 0x13	; 19
    50b4:	0e 94 0d b4 	call	0x1681a	; 0x1681a <__eewr_block>
}
    50b8:	65 96       	adiw	r28, 0x15	; 21
    50ba:	0f b6       	in	r0, 0x3f	; 63
    50bc:	f8 94       	cli
    50be:	de bf       	out	0x3e, r29	; 62
    50c0:	0f be       	out	0x3f, r0	; 63
    50c2:	cd bf       	out	0x3d, r28	; 61
    50c4:	cf 91       	pop	r28
    50c6:	df 91       	pop	r29
    50c8:	1f 91       	pop	r17
    50ca:	0f 91       	pop	r16
    50cc:	ff 90       	pop	r15
    50ce:	ef 90       	pop	r14
    50d0:	df 90       	pop	r13
    50d2:	cf 90       	pop	r12
    50d4:	bf 90       	pop	r11
    50d6:	af 90       	pop	r10
    50d8:	08 95       	ret

000050da <SaveTotalizerCurrentToLast>:
	 }Dest[12]=0;
}

//SetTotalizerData(TVOLUME,TOTALIZER_NOW,1,1,strVolume)

void SaveTotalizerCurrentToLast(){
    50da:	4f 92       	push	r4
    50dc:	5f 92       	push	r5
    50de:	7f 92       	push	r7
    50e0:	8f 92       	push	r8
    50e2:	9f 92       	push	r9
    50e4:	af 92       	push	r10
    50e6:	bf 92       	push	r11
    50e8:	cf 92       	push	r12
    50ea:	df 92       	push	r13
    50ec:	ef 92       	push	r14
    50ee:	ff 92       	push	r15
    50f0:	0f 93       	push	r16
    50f2:	1f 93       	push	r17
    50f4:	df 93       	push	r29
    50f6:	cf 93       	push	r28
    50f8:	cd b7       	in	r28, 0x3d	; 61
    50fa:	de b7       	in	r29, 0x3e	; 62
    50fc:	2f 97       	sbiw	r28, 0x0f	; 15
    50fe:	0f b6       	in	r0, 0x3f	; 63
    5100:	f8 94       	cli
    5102:	de bf       	out	0x3e, r29	; 62
    5104:	0f be       	out	0x3f, r0	; 63
    5106:	cd bf       	out	0x3d, r28	; 61
    5108:	77 24       	eor	r7, r7
    510a:	73 94       	inc	r7
	 
	 for (iPump=1;iPump<=16;iPump++){//Pump
	      FIPAddr=GetFIPAddr(iPump);
		  if (FIPAddr>0){
		      FIPAddr=FIPAddr-1;
			  for(iGrade=1;iGrade<=6;iGrade++){
    510c:	4e 01       	movw	r8, r28
    510e:	08 94       	sec
    5110:	81 1c       	adc	r8, r1
    5112:	91 1c       	adc	r9, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    5114:	f0 e1       	ldi	r31, 0x10	; 16
    5116:	4f 2e       	mov	r4, r31
    5118:	51 2c       	mov	r5, r1
    511a:	4c 0e       	add	r4, r28
    511c:	5d 1e       	adc	r5, r29
     char iPump,iGrade;
     char strValue[15];
     char FIPAddr;
	 
	 for (iPump=1;iPump<=16;iPump++){//Pump
	      FIPAddr=GetFIPAddr(iPump);
    511e:	87 2d       	mov	r24, r7
    5120:	0e 94 41 1d 	call	0x3a82	; 0x3a82 <GetFIPAddr>
		  if (FIPAddr>0){
    5124:	88 23       	and	r24, r24
    5126:	91 f1       	breq	.+100    	; 0x518c <SaveTotalizerCurrentToLast+0xb2>
		      FIPAddr=FIPAddr-1;
    5128:	a8 2e       	mov	r10, r24
    512a:	aa 94       	dec	r10
    512c:	bb 24       	eor	r11, r11
    512e:	b3 94       	inc	r11
    5130:	2a c0       	rjmp	.+84     	; 0x5186 <SaveTotalizerCurrentToLast+0xac>
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    5132:	f7 01       	movw	r30, r14
    5134:	11 92       	st	Z+, r1
    5136:	7f 01       	movw	r14, r30

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    5138:	e4 15       	cp	r30, r4
    513a:	f5 05       	cpc	r31, r5
    513c:	d1 f7       	brne	.-12     	; 0x5132 <SaveTotalizerCurrentToLast+0x58>
	      FIPAddr=GetFIPAddr(iPump);
		  if (FIPAddr>0){
		      FIPAddr=FIPAddr-1;
			  for(iGrade=1;iGrade<=6;iGrade++){
				  FillChar(strValue,sizeof(strValue),0);
				  GetTotalizerData(TVOLUME,TOTALIZER_NOW,FIPAddr,iGrade,strValue);
    513e:	80 e0       	ldi	r24, 0x00	; 0
    5140:	61 e0       	ldi	r22, 0x01	; 1
    5142:	4a 2d       	mov	r20, r10
    5144:	2b 2d       	mov	r18, r11
    5146:	84 01       	movw	r16, r8
    5148:	0e 94 00 1e 	call	0x3c00	; 0x3c00 <GetTotalizerData>
				  SetTotalizerData(TVOLUME,TOTALIZER_LAST,FIPAddr,iGrade,strValue);
    514c:	80 e0       	ldi	r24, 0x00	; 0
    514e:	60 e0       	ldi	r22, 0x00	; 0
    5150:	4a 2d       	mov	r20, r10
    5152:	2b 2d       	mov	r18, r11
    5154:	0e 94 ac 27 	call	0x4f58	; 0x4f58 <SetTotalizerData>
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    5158:	f6 01       	movw	r30, r12
    515a:	11 92       	st	Z+, r1
    515c:	6f 01       	movw	r12, r30

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    515e:	ee 15       	cp	r30, r14
    5160:	ff 05       	cpc	r31, r15
    5162:	d1 f7       	brne	.-12     	; 0x5158 <SaveTotalizerCurrentToLast+0x7e>
			  for(iGrade=1;iGrade<=6;iGrade++){
				  FillChar(strValue,sizeof(strValue),0);
				  GetTotalizerData(TVOLUME,TOTALIZER_NOW,FIPAddr,iGrade,strValue);
				  SetTotalizerData(TVOLUME,TOTALIZER_LAST,FIPAddr,iGrade,strValue);
				  FillChar(strValue,sizeof(strValue),0);
				  GetTotalizerData(TMONEY,TOTALIZER_NOW,FIPAddr,iGrade,strValue);
    5164:	81 e0       	ldi	r24, 0x01	; 1
    5166:	61 e0       	ldi	r22, 0x01	; 1
    5168:	4a 2d       	mov	r20, r10
    516a:	2b 2d       	mov	r18, r11
    516c:	84 01       	movw	r16, r8
    516e:	0e 94 00 1e 	call	0x3c00	; 0x3c00 <GetTotalizerData>
				  SetTotalizerData(TMONEY,TOTALIZER_LAST,FIPAddr,iGrade,strValue);
    5172:	81 e0       	ldi	r24, 0x01	; 1
    5174:	60 e0       	ldi	r22, 0x00	; 0
    5176:	4a 2d       	mov	r20, r10
    5178:	2b 2d       	mov	r18, r11
    517a:	0e 94 ac 27 	call	0x4f58	; 0x4f58 <SetTotalizerData>
	 
	 for (iPump=1;iPump<=16;iPump++){//Pump
	      FIPAddr=GetFIPAddr(iPump);
		  if (FIPAddr>0){
		      FIPAddr=FIPAddr-1;
			  for(iGrade=1;iGrade<=6;iGrade++){
    517e:	b3 94       	inc	r11
    5180:	f7 e0       	ldi	r31, 0x07	; 7
    5182:	bf 16       	cp	r11, r31
    5184:	19 f0       	breq	.+6      	; 0x518c <SaveTotalizerCurrentToLast+0xb2>
    5186:	64 01       	movw	r12, r8
    5188:	74 01       	movw	r14, r8
    518a:	d3 cf       	rjmp	.-90     	; 0x5132 <SaveTotalizerCurrentToLast+0x58>
void SaveTotalizerCurrentToLast(){
     char iPump,iGrade;
     char strValue[15];
     char FIPAddr;
	 
	 for (iPump=1;iPump<=16;iPump++){//Pump
    518c:	73 94       	inc	r7
    518e:	81 e1       	ldi	r24, 0x11	; 17
    5190:	78 16       	cp	r7, r24
    5192:	29 f6       	brne	.-118    	; 0x511e <SaveTotalizerCurrentToLast+0x44>
				  GetTotalizerData(TMONEY,TOTALIZER_NOW,FIPAddr,iGrade,strValue);
				  SetTotalizerData(TMONEY,TOTALIZER_LAST,FIPAddr,iGrade,strValue);
			  }
		  }
	 }
}
    5194:	2f 96       	adiw	r28, 0x0f	; 15
    5196:	0f b6       	in	r0, 0x3f	; 63
    5198:	f8 94       	cli
    519a:	de bf       	out	0x3e, r29	; 62
    519c:	0f be       	out	0x3f, r0	; 63
    519e:	cd bf       	out	0x3d, r28	; 61
    51a0:	cf 91       	pop	r28
    51a2:	df 91       	pop	r29
    51a4:	1f 91       	pop	r17
    51a6:	0f 91       	pop	r16
    51a8:	ff 90       	pop	r15
    51aa:	ef 90       	pop	r14
    51ac:	df 90       	pop	r13
    51ae:	cf 90       	pop	r12
    51b0:	bf 90       	pop	r11
    51b2:	af 90       	pop	r10
    51b4:	9f 90       	pop	r9
    51b6:	8f 90       	pop	r8
    51b8:	7f 90       	pop	r7
    51ba:	5f 90       	pop	r5
    51bc:	4f 90       	pop	r4
    51be:	08 95       	ret

000051c0 <ResetTotalizer>:
}

//-------------------Totalizer-----------------------------------------
//TAddr{TOTALIZER_LAST,TOTALIZER_NOW}
//TType:{TNONE,TVOLUME,TMONEY};
void ResetTotalizer(char TAddr){//Clear All TotalizerData;
    51c0:	af 92       	push	r10
    51c2:	bf 92       	push	r11
    51c4:	cf 92       	push	r12
    51c6:	df 92       	push	r13
    51c8:	ef 92       	push	r14
    51ca:	ff 92       	push	r15
    51cc:	0f 93       	push	r16
    51ce:	1f 93       	push	r17
    51d0:	df 93       	push	r29
    51d2:	cf 93       	push	r28
    51d4:	cd b7       	in	r28, 0x3d	; 61
    51d6:	de b7       	in	r29, 0x3e	; 62
    51d8:	29 97       	sbiw	r28, 0x09	; 9
    51da:	0f b6       	in	r0, 0x3f	; 63
    51dc:	f8 94       	cli
    51de:	de bf       	out	0x3e, r29	; 62
    51e0:	0f be       	out	0x3f, r0	; 63
    51e2:	cd bf       	out	0x3d, r28	; 61
    51e4:	a8 2e       	mov	r10, r24
     char iPump,iGrade;
     char strValue[9];
	 char FIPAddr;
	 
	 sprintf_P(strValue,PSTR("00000000"));
    51e6:	00 d0       	rcall	.+0      	; 0x51e8 <ResetTotalizer+0x28>
    51e8:	00 d0       	rcall	.+0      	; 0x51ea <ResetTotalizer+0x2a>
    51ea:	6e 01       	movw	r12, r28
    51ec:	08 94       	sec
    51ee:	c1 1c       	adc	r12, r1
    51f0:	d1 1c       	adc	r13, r1
    51f2:	ed b7       	in	r30, 0x3d	; 61
    51f4:	fe b7       	in	r31, 0x3e	; 62
    51f6:	d2 82       	std	Z+2, r13	; 0x02
    51f8:	c1 82       	std	Z+1, r12	; 0x01
    51fa:	8c eb       	ldi	r24, 0xBC	; 188
    51fc:	95 e0       	ldi	r25, 0x05	; 5
    51fe:	94 83       	std	Z+4, r25	; 0x04
    5200:	83 83       	std	Z+3, r24	; 0x03
    5202:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    5206:	ee 24       	eor	r14, r14
    5208:	e3 94       	inc	r14
    520a:	0f 90       	pop	r0
    520c:	0f 90       	pop	r0
    520e:	0f 90       	pop	r0
    5210:	0f 90       	pop	r0
	 for (iPump=1;iPump<=16;iPump++){//Pump
	      FIPAddr=GetFIPAddr(iPump);
    5212:	8e 2d       	mov	r24, r14
    5214:	0e 94 41 1d 	call	0x3a82	; 0x3a82 <GetFIPAddr>
		  if (FIPAddr>0){
    5218:	88 23       	and	r24, r24
    521a:	a9 f0       	breq	.+42     	; 0x5246 <ResetTotalizer+0x86>
		      FIPAddr=FIPAddr-1;
    521c:	b8 2e       	mov	r11, r24
    521e:	ba 94       	dec	r11
    5220:	ff 24       	eor	r15, r15
    5222:	f3 94       	inc	r15
			  for(iGrade=1;iGrade<=6;iGrade++){
				  SetTotalizerData(TVOLUME,TAddr,FIPAddr,iGrade,strValue);
    5224:	80 e0       	ldi	r24, 0x00	; 0
    5226:	6a 2d       	mov	r22, r10
    5228:	4b 2d       	mov	r20, r11
    522a:	2f 2d       	mov	r18, r15
    522c:	86 01       	movw	r16, r12
    522e:	0e 94 ac 27 	call	0x4f58	; 0x4f58 <SetTotalizerData>
				  SetTotalizerData(TMONEY,TAddr,FIPAddr,iGrade,strValue);
    5232:	81 e0       	ldi	r24, 0x01	; 1
    5234:	6a 2d       	mov	r22, r10
    5236:	4b 2d       	mov	r20, r11
    5238:	2f 2d       	mov	r18, r15
    523a:	0e 94 ac 27 	call	0x4f58	; 0x4f58 <SetTotalizerData>
	 sprintf_P(strValue,PSTR("00000000"));
	 for (iPump=1;iPump<=16;iPump++){//Pump
	      FIPAddr=GetFIPAddr(iPump);
		  if (FIPAddr>0){
		      FIPAddr=FIPAddr-1;
			  for(iGrade=1;iGrade<=6;iGrade++){
    523e:	f3 94       	inc	r15
    5240:	f7 e0       	ldi	r31, 0x07	; 7
    5242:	ff 16       	cp	r15, r31
    5244:	79 f7       	brne	.-34     	; 0x5224 <ResetTotalizer+0x64>
     char iPump,iGrade;
     char strValue[9];
	 char FIPAddr;
	 
	 sprintf_P(strValue,PSTR("00000000"));
	 for (iPump=1;iPump<=16;iPump++){//Pump
    5246:	e3 94       	inc	r14
    5248:	81 e1       	ldi	r24, 0x11	; 17
    524a:	e8 16       	cp	r14, r24
    524c:	11 f7       	brne	.-60     	; 0x5212 <ResetTotalizer+0x52>
				  SetTotalizerData(TVOLUME,TAddr,FIPAddr,iGrade,strValue);
				  SetTotalizerData(TMONEY,TAddr,FIPAddr,iGrade,strValue);
			  }
		  }
	 }
}
    524e:	29 96       	adiw	r28, 0x09	; 9
    5250:	0f b6       	in	r0, 0x3f	; 63
    5252:	f8 94       	cli
    5254:	de bf       	out	0x3e, r29	; 62
    5256:	0f be       	out	0x3f, r0	; 63
    5258:	cd bf       	out	0x3d, r28	; 61
    525a:	cf 91       	pop	r28
    525c:	df 91       	pop	r29
    525e:	1f 91       	pop	r17
    5260:	0f 91       	pop	r16
    5262:	ff 90       	pop	r15
    5264:	ef 90       	pop	r14
    5266:	df 90       	pop	r13
    5268:	cf 90       	pop	r12
    526a:	bf 90       	pop	r11
    526c:	af 90       	pop	r10
    526e:	08 95       	ret

00005270 <AddZeroLag>:
	         String[i]=strAdded[i];
	     }String[Size]=0;
	 }
}

void AddZeroLag(char *String,unsigned char Size){// [123]->12300
    5270:	cf 93       	push	r28
    5272:	df 93       	push	r29
    5274:	ec 01       	movw	r28, r24
char i,Length;
     Length=strlen(String);
    5276:	dc 01       	movw	r26, r24
    5278:	0d 90       	ld	r0, X+
    527a:	00 20       	and	r0, r0
    527c:	e9 f7       	brne	.-6      	; 0x5278 <AddZeroLag+0x8>
    527e:	11 97       	sbiw	r26, 0x01	; 1
    5280:	a8 1b       	sub	r26, r24
    5282:	b9 0b       	sbc	r27, r25
  if (Length<Size){   
    5284:	a6 17       	cp	r26, r22
    5286:	60 f4       	brcc	.+24     	; 0x52a0 <AddZeroLag+0x30>
    5288:	8a 2f       	mov	r24, r26
     for(i=Length;i<Size;i++){
	    String[i]='0';
    528a:	90 e3       	ldi	r25, 0x30	; 48
    528c:	fe 01       	movw	r30, r28
    528e:	e8 0f       	add	r30, r24
    5290:	f1 1d       	adc	r31, r1
    5292:	90 83       	st	Z, r25

void AddZeroLag(char *String,unsigned char Size){// [123]->12300
char i,Length;
     Length=strlen(String);
  if (Length<Size){   
     for(i=Length;i<Size;i++){
    5294:	8f 5f       	subi	r24, 0xFF	; 255
    5296:	86 17       	cp	r24, r22
    5298:	c8 f3       	brcs	.-14     	; 0x528c <AddZeroLag+0x1c>
	    String[i]='0';
	 }String[Size]=0;
    529a:	c6 0f       	add	r28, r22
    529c:	d1 1d       	adc	r29, r1
    529e:	18 82       	st	Y, r1
  }
}
    52a0:	df 91       	pop	r29
    52a2:	cf 91       	pop	r28
    52a4:	08 95       	ret

000052a6 <StrCalc>:
     
	 //if (NinePos<Length-4)
	 StrCalc(TPLUS,strMaxValue,strOverflowed,strOverflowed);
}
                                                                   //     1111111 
void StrCalc(char TOperation, char *strA , char *strB, char *strC){//  A: 00000000
    52a6:	3f 92       	push	r3
    52a8:	4f 92       	push	r4
    52aa:	5f 92       	push	r5
    52ac:	6f 92       	push	r6
    52ae:	7f 92       	push	r7
    52b0:	8f 92       	push	r8
    52b2:	9f 92       	push	r9
    52b4:	af 92       	push	r10
    52b6:	bf 92       	push	r11
    52b8:	cf 92       	push	r12
    52ba:	df 92       	push	r13
    52bc:	ef 92       	push	r14
    52be:	ff 92       	push	r15
    52c0:	0f 93       	push	r16
    52c2:	1f 93       	push	r17
    52c4:	df 93       	push	r29
    52c6:	cf 93       	push	r28
    52c8:	cd b7       	in	r28, 0x3d	; 61
    52ca:	de b7       	in	r29, 0x3e	; 62
    52cc:	c8 55       	subi	r28, 0x58	; 88
    52ce:	d0 40       	sbci	r29, 0x00	; 0
    52d0:	0f b6       	in	r0, 0x3f	; 63
    52d2:	f8 94       	cli
    52d4:	de bf       	out	0x3e, r29	; 62
    52d6:	0f be       	out	0x3f, r0	; 63
    52d8:	cd bf       	out	0x3d, r28	; 61
    52da:	68 2e       	mov	r6, r24
    52dc:	67 96       	adiw	r28, 0x17	; 23
    52de:	7f af       	std	Y+63, r23	; 0x3f
    52e0:	6e af       	std	Y+62, r22	; 0x3e
    52e2:	67 97       	sbiw	r28, 0x17	; 23
    52e4:	69 96       	adiw	r28, 0x19	; 25
    52e6:	5f af       	std	Y+63, r21	; 0x3f
    52e8:	4e af       	std	Y+62, r20	; 0x3e
    52ea:	69 97       	sbiw	r28, 0x19	; 25
    52ec:	59 01       	movw	r10, r18
    52ee:	fe 01       	movw	r30, r28
    52f0:	31 96       	adiw	r30, 0x01	; 1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    52f2:	ce 01       	movw	r24, r28
    52f4:	45 96       	adiw	r24, 0x15	; 21
	     strMemory[i]=data;
    52f6:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    52f8:	e8 17       	cp	r30, r24
    52fa:	f9 07       	cpc	r31, r25
    52fc:	e1 f7       	brne	.-8      	; 0x52f6 <StrCalc+0x50>
	     strMemory[i]=data;
    52fe:	ce 01       	movw	r24, r28
    5300:	89 96       	adiw	r24, 0x29	; 41
    5302:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    5304:	e8 17       	cp	r30, r24
    5306:	f9 07       	cpc	r31, r25
    5308:	e1 f7       	brne	.-8      	; 0x5302 <StrCalc+0x5c>
    530a:	fe 01       	movw	r30, r28
    530c:	fd 96       	adiw	r30, 0x3d	; 61
	     strMemory[i]=data;
    530e:	cf 01       	movw	r24, r30
    5310:	44 96       	adiw	r24, 0x14	; 20
    5312:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    5314:	e8 17       	cp	r30, r24
    5316:	f9 07       	cpc	r31, r25
    5318:	e1 f7       	brne	.-8      	; 0x5312 <StrCalc+0x6c>
	 FillChar(tmpB,sizeof(tmpB),0);
	 FillChar(Result,sizeof(Result),0);
                                            // -5    -5     5    5
	                                        // -6 -   6 -  -6 -  6 -
                                            // -5+6   
	 sprintf_P(tmpA,PSTR("%s"),strA);       // 
    531a:	00 d0       	rcall	.+0      	; 0x531c <StrCalc+0x76>
    531c:	00 d0       	rcall	.+0      	; 0x531e <StrCalc+0x78>
    531e:	00 d0       	rcall	.+0      	; 0x5320 <StrCalc+0x7a>
    5320:	ed b7       	in	r30, 0x3d	; 61
    5322:	fe b7       	in	r31, 0x3e	; 62
    5324:	31 96       	adiw	r30, 0x01	; 1
    5326:	8e 01       	movw	r16, r28
    5328:	0f 5f       	subi	r16, 0xFF	; 255
    532a:	1f 4f       	sbci	r17, 0xFF	; 255
    532c:	ad b7       	in	r26, 0x3d	; 61
    532e:	be b7       	in	r27, 0x3e	; 62
    5330:	12 96       	adiw	r26, 0x02	; 2
    5332:	1c 93       	st	X, r17
    5334:	0e 93       	st	-X, r16
    5336:	11 97       	sbiw	r26, 0x01	; 1
    5338:	82 e8       	ldi	r24, 0x82	; 130
    533a:	95 e0       	ldi	r25, 0x05	; 5
    533c:	93 83       	std	Z+3, r25	; 0x03
    533e:	82 83       	std	Z+2, r24	; 0x02
    5340:	67 96       	adiw	r28, 0x17	; 23
    5342:	2e ad       	ldd	r18, Y+62	; 0x3e
    5344:	3f ad       	ldd	r19, Y+63	; 0x3f
    5346:	67 97       	sbiw	r28, 0x17	; 23
    5348:	35 83       	std	Z+5, r19	; 0x05
    534a:	24 83       	std	Z+4, r18	; 0x04
    534c:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
	 sprintf_P(tmpB,PSTR("%s"),strB);  
    5350:	ed b7       	in	r30, 0x3d	; 61
    5352:	fe b7       	in	r31, 0x3e	; 62
    5354:	31 96       	adiw	r30, 0x01	; 1
    5356:	ce 01       	movw	r24, r28
    5358:	45 96       	adiw	r24, 0x15	; 21
    535a:	ad b7       	in	r26, 0x3d	; 61
    535c:	be b7       	in	r27, 0x3e	; 62
    535e:	12 96       	adiw	r26, 0x02	; 2
    5360:	9c 93       	st	X, r25
    5362:	8e 93       	st	-X, r24
    5364:	11 97       	sbiw	r26, 0x01	; 1
    5366:	8f e7       	ldi	r24, 0x7F	; 127
    5368:	95 e0       	ldi	r25, 0x05	; 5
    536a:	93 83       	std	Z+3, r25	; 0x03
    536c:	82 83       	std	Z+2, r24	; 0x02
    536e:	69 96       	adiw	r28, 0x19	; 25
    5370:	2e ad       	ldd	r18, Y+62	; 0x3e
    5372:	3f ad       	ldd	r19, Y+63	; 0x3f
    5374:	69 97       	sbiw	r28, 0x19	; 25
    5376:	35 83       	std	Z+5, r19	; 0x05
    5378:	24 83       	std	Z+4, r18	; 0x04
    537a:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>

     if (IsMinus(tmpA)==True){
    537e:	8d b7       	in	r24, 0x3d	; 61
    5380:	9e b7       	in	r25, 0x3e	; 62
    5382:	06 96       	adiw	r24, 0x06	; 6
    5384:	0f b6       	in	r0, 0x3f	; 63
    5386:	f8 94       	cli
    5388:	9e bf       	out	0x3e, r25	; 62
    538a:	0f be       	out	0x3f, r0	; 63
    538c:	8d bf       	out	0x3d, r24	; 61
    538e:	c8 01       	movw	r24, r16
    5390:	0e 94 4e 23 	call	0x469c	; 0x469c <IsMinus>
    5394:	81 30       	cpi	r24, 0x01	; 1
    5396:	21 f0       	breq	.+8      	; 0x53a0 <StrCalc+0xfa>
    5398:	65 96       	adiw	r28, 0x15	; 21
    539a:	1f ae       	std	Y+63, r1	; 0x3f
    539c:	65 97       	sbiw	r28, 0x15	; 21
    539e:	07 c0       	rjmp	.+14     	; 0x53ae <StrCalc+0x108>
	     RemoveMinus(tmpA);
    53a0:	c8 01       	movw	r24, r16
    53a2:	0e 94 53 23 	call	0x46a6	; 0x46a6 <RemoveMinus>
    53a6:	91 e0       	ldi	r25, 0x01	; 1
    53a8:	65 96       	adiw	r28, 0x15	; 21
    53aa:	9f af       	std	Y+63, r25	; 0x3f
    53ac:	65 97       	sbiw	r28, 0x15	; 21
		 IsMinA=True;
	 }
     if (IsMinus(tmpB)==True){
    53ae:	8e 01       	movw	r16, r28
    53b0:	0b 5e       	subi	r16, 0xEB	; 235
    53b2:	1f 4f       	sbci	r17, 0xFF	; 255
    53b4:	c8 01       	movw	r24, r16
    53b6:	0e 94 4e 23 	call	0x469c	; 0x469c <IsMinus>
    53ba:	81 30       	cpi	r24, 0x01	; 1
    53bc:	21 f0       	breq	.+8      	; 0x53c6 <StrCalc+0x120>
    53be:	64 96       	adiw	r28, 0x14	; 20
    53c0:	1f ae       	std	Y+63, r1	; 0x3f
    53c2:	64 97       	sbiw	r28, 0x14	; 20
    53c4:	07 c0       	rjmp	.+14     	; 0x53d4 <StrCalc+0x12e>
	     RemoveMinus(tmpB);
    53c6:	c8 01       	movw	r24, r16
    53c8:	0e 94 53 23 	call	0x46a6	; 0x46a6 <RemoveMinus>
    53cc:	a1 e0       	ldi	r26, 0x01	; 1
    53ce:	64 96       	adiw	r28, 0x14	; 20
    53d0:	af af       	std	Y+63, r26	; 0x3f
    53d2:	64 97       	sbiw	r28, 0x14	; 20
		 IsMinB=True;
	 }    	

     lenA=strlen(tmpA);
    53d4:	fe 01       	movw	r30, r28
    53d6:	31 96       	adiw	r30, 0x01	; 1
    53d8:	df 01       	movw	r26, r30
    53da:	0d 90       	ld	r0, X+
    53dc:	00 20       	and	r0, r0
    53de:	e9 f7       	brne	.-6      	; 0x53da <StrCalc+0x134>
    53e0:	cd 01       	movw	r24, r26
    53e2:	01 97       	sbiw	r24, 0x01	; 1
    53e4:	8e 1b       	sub	r24, r30
    53e6:	9f 0b       	sbc	r25, r31
     lenB=strlen(tmpB);
    53e8:	de 01       	movw	r26, r28
    53ea:	55 96       	adiw	r26, 0x15	; 21
    53ec:	fd 01       	movw	r30, r26
    53ee:	01 90       	ld	r0, Z+
    53f0:	00 20       	and	r0, r0
    53f2:	e9 f7       	brne	.-6      	; 0x53ee <StrCalc+0x148>
    53f4:	31 97       	sbiw	r30, 0x01	; 1
     /*
	 sprintf_P(strSend,PSTR("A:%s"),strA);	 _uart_print(0,1,strSend);
	 sprintf_P(strSend,PSTR("B:%s"),strB);	 _uart_print(0,1,strSend);
     */

     AddZeroLead(tmpA,FixLen+1);
    53f6:	1e 2f       	mov	r17, r30
    53f8:	1a 1b       	sub	r17, r26
    53fa:	18 17       	cp	r17, r24
    53fc:	08 f4       	brcc	.+2      	; 0x5400 <StrCalc+0x15a>
    53fe:	18 2f       	mov	r17, r24
    5400:	1f 5f       	subi	r17, 0xFF	; 255
    5402:	7e 01       	movw	r14, r28
    5404:	08 94       	sec
    5406:	e1 1c       	adc	r14, r1
    5408:	f1 1c       	adc	r15, r1
    540a:	c7 01       	movw	r24, r14
    540c:	61 2f       	mov	r22, r17
    540e:	0e 94 97 26 	call	0x4d2e	; 0x4d2e <AddZeroLead>
     AddZeroLead(tmpB,FixLen+1);
    5412:	95 e1       	ldi	r25, 0x15	; 21
    5414:	c9 2e       	mov	r12, r25
    5416:	d1 2c       	mov	r13, r1
    5418:	cc 0e       	add	r12, r28
    541a:	dd 1e       	adc	r13, r29
    541c:	c6 01       	movw	r24, r12
    541e:	61 2f       	mov	r22, r17
    5420:	0e 94 97 26 	call	0x4d2e	; 0x4d2e <AddZeroLead>
	 _uart_print(0,1,strSend);
	 sprintf_P(strSend,PSTR("B:%s"),strB);
	 _uart_print(0,1,strSend);
	 */

     lenA=strlen(tmpA);
    5424:	f7 01       	movw	r30, r14
    5426:	01 90       	ld	r0, Z+
    5428:	00 20       	and	r0, r0
    542a:	e9 f7       	brne	.-6      	; 0x5426 <StrCalc+0x180>
    542c:	31 97       	sbiw	r30, 0x01	; 1
    542e:	7e 2e       	mov	r7, r30
    5430:	7e 18       	sub	r7, r14
     lenB=strlen(tmpB);
    5432:	f6 01       	movw	r30, r12
    5434:	01 90       	ld	r0, Z+
    5436:	00 20       	and	r0, r0
    5438:	e9 f7       	brne	.-6      	; 0x5434 <StrCalc+0x18e>
    543a:	31 97       	sbiw	r30, 0x01	; 1
    543c:	9e 2e       	mov	r9, r30
    543e:	9c 18       	sub	r9, r12
     IsNegative=False;
	 
	 IsNegative=False;
	 IsSwap=False;

	 if (IsMoreThan(tmpB,tmpA)==True){
    5440:	c6 01       	movw	r24, r12
    5442:	b7 01       	movw	r22, r14
    5444:	0e 94 80 23 	call	0x4700	; 0x4700 <IsMoreThan>
    5448:	81 30       	cpi	r24, 0x01	; 1
    544a:	11 f0       	breq	.+4      	; 0x5450 <StrCalc+0x1aa>
    544c:	80 e0       	ldi	r24, 0x00	; 0
    544e:	42 c0       	rjmp	.+132    	; 0x54d4 <StrCalc+0x22e>
	     IsSwap=True;
         sprintf_P(tmpC,PSTR("%s"),tmpA);
    5450:	00 d0       	rcall	.+0      	; 0x5452 <StrCalc+0x1ac>
    5452:	00 d0       	rcall	.+0      	; 0x5454 <StrCalc+0x1ae>
    5454:	00 d0       	rcall	.+0      	; 0x5456 <StrCalc+0x1b0>
    5456:	ed b7       	in	r30, 0x3d	; 61
    5458:	fe b7       	in	r31, 0x3e	; 62
    545a:	31 96       	adiw	r30, 0x01	; 1
    545c:	8e 01       	movw	r16, r28
    545e:	07 5d       	subi	r16, 0xD7	; 215
    5460:	1f 4f       	sbci	r17, 0xFF	; 255
    5462:	ad b7       	in	r26, 0x3d	; 61
    5464:	be b7       	in	r27, 0x3e	; 62
    5466:	12 96       	adiw	r26, 0x02	; 2
    5468:	1c 93       	st	X, r17
    546a:	0e 93       	st	-X, r16
    546c:	11 97       	sbiw	r26, 0x01	; 1
    546e:	8c e7       	ldi	r24, 0x7C	; 124
    5470:	95 e0       	ldi	r25, 0x05	; 5
    5472:	93 83       	std	Z+3, r25	; 0x03
    5474:	82 83       	std	Z+2, r24	; 0x02
    5476:	f5 82       	std	Z+5, r15	; 0x05
    5478:	e4 82       	std	Z+4, r14	; 0x04
    547a:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
		 sprintf_P(tmpA,PSTR("%s"),tmpB);
    547e:	ed b7       	in	r30, 0x3d	; 61
    5480:	fe b7       	in	r31, 0x3e	; 62
    5482:	31 96       	adiw	r30, 0x01	; 1
    5484:	ad b7       	in	r26, 0x3d	; 61
    5486:	be b7       	in	r27, 0x3e	; 62
    5488:	12 96       	adiw	r26, 0x02	; 2
    548a:	fc 92       	st	X, r15
    548c:	ee 92       	st	-X, r14
    548e:	11 97       	sbiw	r26, 0x01	; 1
    5490:	89 e7       	ldi	r24, 0x79	; 121
    5492:	95 e0       	ldi	r25, 0x05	; 5
    5494:	93 83       	std	Z+3, r25	; 0x03
    5496:	82 83       	std	Z+2, r24	; 0x02
    5498:	d5 82       	std	Z+5, r13	; 0x05
    549a:	c4 82       	std	Z+4, r12	; 0x04
    549c:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
		 sprintf_P(tmpB,PSTR("%s"),tmpC);
    54a0:	ed b7       	in	r30, 0x3d	; 61
    54a2:	fe b7       	in	r31, 0x3e	; 62
    54a4:	31 96       	adiw	r30, 0x01	; 1
    54a6:	ad b7       	in	r26, 0x3d	; 61
    54a8:	be b7       	in	r27, 0x3e	; 62
    54aa:	12 96       	adiw	r26, 0x02	; 2
    54ac:	dc 92       	st	X, r13
    54ae:	ce 92       	st	-X, r12
    54b0:	11 97       	sbiw	r26, 0x01	; 1
    54b2:	86 e7       	ldi	r24, 0x76	; 118
    54b4:	95 e0       	ldi	r25, 0x05	; 5
    54b6:	93 83       	std	Z+3, r25	; 0x03
    54b8:	82 83       	std	Z+2, r24	; 0x02
    54ba:	15 83       	std	Z+5, r17	; 0x05
    54bc:	04 83       	std	Z+4, r16	; 0x04
    54be:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    54c2:	81 e0       	ldi	r24, 0x01	; 1
    54c4:	ed b7       	in	r30, 0x3d	; 61
    54c6:	fe b7       	in	r31, 0x3e	; 62
    54c8:	36 96       	adiw	r30, 0x06	; 6
    54ca:	0f b6       	in	r0, 0x3f	; 63
    54cc:	f8 94       	cli
    54ce:	fe bf       	out	0x3e, r31	; 62
    54d0:	0f be       	out	0x3f, r0	; 63
    54d2:	ed bf       	out	0x3d, r30	; 61
	 }
    
	if (TOperation==TMINUS){
    54d4:	66 20       	and	r6, r6
    54d6:	39 f5       	brne	.+78     	; 0x5526 <StrCalc+0x280>
	    TCalc=TOperation;
		IsNegative=False;
		if (IsSwap==True){
    54d8:	81 30       	cpi	r24, 0x01	; 1
    54da:	99 f4       	brne	.+38     	; 0x5502 <StrCalc+0x25c>
		    if ((IsMinA==True)&&(IsMinB==True)){IsNegative=False;TCalc=TMINUS;}
    54dc:	65 96       	adiw	r28, 0x15	; 21
    54de:	ff ad       	ldd	r31, Y+63	; 0x3f
    54e0:	65 97       	sbiw	r28, 0x15	; 21
    54e2:	f1 30       	cpi	r31, 0x01	; 1
    54e4:	39 f4       	brne	.+14     	; 0x54f4 <StrCalc+0x24e>
    54e6:	64 96       	adiw	r28, 0x14	; 20
    54e8:	2f ad       	ldd	r18, Y+63	; 0x3f
    54ea:	64 97       	sbiw	r28, 0x14	; 20
    54ec:	21 30       	cpi	r18, 0x01	; 1
    54ee:	09 f0       	breq	.+2      	; 0x54f2 <StrCalc+0x24c>
    54f0:	9e c1       	rjmp	.+828    	; 0x582e <StrCalc+0x588>
    54f2:	42 c0       	rjmp	.+132    	; 0x5578 <StrCalc+0x2d2>
            else if ((IsMinA==True)&&(IsMinB==False)){IsNegative=True;TCalc=TPLUS;}
            else if ((IsMinA==False)&&(IsMinB==True)){IsNegative=False;TCalc=TPLUS;}
    54f4:	64 96       	adiw	r28, 0x14	; 20
    54f6:	3f ad       	ldd	r19, Y+63	; 0x3f
    54f8:	64 97       	sbiw	r28, 0x14	; 20
    54fa:	31 30       	cpi	r19, 0x01	; 1
    54fc:	09 f0       	breq	.+2      	; 0x5500 <StrCalc+0x25a>
    54fe:	8e c1       	rjmp	.+796    	; 0x581c <StrCalc+0x576>
    5500:	92 c1       	rjmp	.+804    	; 0x5826 <StrCalc+0x580>
            else if ((IsMinA==False)&&(IsMinB==False)){IsNegative=True;TCalc=TMINUS;}
		}else
		if (IsSwap==False){
		    if ((IsMinA==True)&&(IsMinB==True)){IsNegative=True;TCalc=TMINUS;}
    5502:	65 96       	adiw	r28, 0x15	; 21
    5504:	8f ad       	ldd	r24, Y+63	; 0x3f
    5506:	65 97       	sbiw	r28, 0x15	; 21
    5508:	81 30       	cpi	r24, 0x01	; 1
    550a:	39 f4       	brne	.+14     	; 0x551a <StrCalc+0x274>
    550c:	64 96       	adiw	r28, 0x14	; 20
    550e:	9f ad       	ldd	r25, Y+63	; 0x3f
    5510:	64 97       	sbiw	r28, 0x14	; 20
    5512:	91 30       	cpi	r25, 0x01	; 1
    5514:	09 f0       	breq	.+2      	; 0x5518 <StrCalc+0x272>
    5516:	8b c1       	rjmp	.+790    	; 0x582e <StrCalc+0x588>
    5518:	81 c1       	rjmp	.+770    	; 0x581c <StrCalc+0x576>
            else if ((IsMinA==True)&&(IsMinB==False)){IsNegative=True;TCalc=TPLUS;}
            else if ((IsMinA==False)&&(IsMinB==True)){IsNegative=False;TCalc=TPLUS;}
    551a:	64 96       	adiw	r28, 0x14	; 20
    551c:	af ad       	ldd	r26, Y+63	; 0x3f
    551e:	64 97       	sbiw	r28, 0x14	; 20
    5520:	a1 30       	cpi	r26, 0x01	; 1
    5522:	51 f5       	brne	.+84     	; 0x5578 <StrCalc+0x2d2>
    5524:	80 c1       	rjmp	.+768    	; 0x5826 <StrCalc+0x580>
            else if ((IsMinA==False)&&(IsMinB==False)){IsNegative=False;TCalc=TMINUS;}
		}
	 }else
	if (TOperation==TPLUS){
    5526:	b1 e0       	ldi	r27, 0x01	; 1
    5528:	6b 16       	cp	r6, r27
    552a:	31 f5       	brne	.+76     	; 0x5578 <StrCalc+0x2d2>
	    TCalc=TOperation;
		IsNegative=False;
		if (IsSwap==True){
    552c:	81 30       	cpi	r24, 0x01	; 1
    552e:	91 f4       	brne	.+36     	; 0x5554 <StrCalc+0x2ae>
		    if ((IsMinA==True)&&(IsMinB==True)){IsNegative=True;TCalc=TPLUS;}
    5530:	65 96       	adiw	r28, 0x15	; 21
    5532:	ef ad       	ldd	r30, Y+63	; 0x3f
    5534:	65 97       	sbiw	r28, 0x15	; 21
    5536:	e1 30       	cpi	r30, 0x01	; 1
    5538:	31 f4       	brne	.+12     	; 0x5546 <StrCalc+0x2a0>
    553a:	64 96       	adiw	r28, 0x14	; 20
    553c:	ff ad       	ldd	r31, Y+63	; 0x3f
    553e:	64 97       	sbiw	r28, 0x14	; 20
    5540:	f1 30       	cpi	r31, 0x01	; 1
    5542:	d1 f4       	brne	.+52     	; 0x5578 <StrCalc+0x2d2>
    5544:	74 c1       	rjmp	.+744    	; 0x582e <StrCalc+0x588>
            else if ((IsMinA==True)&&(IsMinB==False)){IsNegative=False;TCalc=TMINUS;}
            else if ((IsMinA==False)&&(IsMinB==True)){IsNegative=True;TCalc=TMINUS;}
    5546:	64 96       	adiw	r28, 0x14	; 20
    5548:	2f ad       	ldd	r18, Y+63	; 0x3f
    554a:	64 97       	sbiw	r28, 0x14	; 20
    554c:	21 30       	cpi	r18, 0x01	; 1
    554e:	09 f0       	breq	.+2      	; 0x5552 <StrCalc+0x2ac>
    5550:	6a c1       	rjmp	.+724    	; 0x5826 <StrCalc+0x580>
    5552:	64 c1       	rjmp	.+712    	; 0x581c <StrCalc+0x576>
            else if ((IsMinA==False)&&(IsMinB==False)){IsNegative=False;TCalc=TPLUS;}
		}else
		if (IsSwap==False){
		    if ((IsMinA==True)&&(IsMinB==True)){IsNegative=True;TCalc=TPLUS;}
    5554:	65 96       	adiw	r28, 0x15	; 21
    5556:	3f ad       	ldd	r19, Y+63	; 0x3f
    5558:	65 97       	sbiw	r28, 0x15	; 21
    555a:	31 30       	cpi	r19, 0x01	; 1
    555c:	39 f4       	brne	.+14     	; 0x556c <StrCalc+0x2c6>
    555e:	64 96       	adiw	r28, 0x14	; 20
    5560:	8f ad       	ldd	r24, Y+63	; 0x3f
    5562:	64 97       	sbiw	r28, 0x14	; 20
    5564:	81 30       	cpi	r24, 0x01	; 1
    5566:	09 f0       	breq	.+2      	; 0x556a <StrCalc+0x2c4>
    5568:	59 c1       	rjmp	.+690    	; 0x581c <StrCalc+0x576>
    556a:	61 c1       	rjmp	.+706    	; 0x582e <StrCalc+0x588>
            else if ((IsMinA==True)&&(IsMinB==False)){IsNegative=True;TCalc=TMINUS;}
            else if ((IsMinA==False)&&(IsMinB==True)){IsNegative=False;TCalc=TMINUS;}
    556c:	64 96       	adiw	r28, 0x14	; 20
    556e:	9f ad       	ldd	r25, Y+63	; 0x3f
    5570:	64 97       	sbiw	r28, 0x14	; 20
    5572:	91 30       	cpi	r25, 0x01	; 1
    5574:	09 f0       	breq	.+2      	; 0x5578 <StrCalc+0x2d2>
    5576:	57 c1       	rjmp	.+686    	; 0x5826 <StrCalc+0x580>
   // A: 100000
   // B: 000001 -
   // -----------
   // C: 099999

	 if (TCalc==TMINUS){
    5578:	62 96       	adiw	r28, 0x12	; 18
    557a:	1f ae       	std	Y+63, r1	; 0x3f
    557c:	62 97       	sbiw	r28, 0x12	; 18
     
	 //if (NinePos<Length-4)
	 StrCalc(TPLUS,strMaxValue,strOverflowed,strOverflowed);
}
                                                                   //     1111111 
void StrCalc(char TOperation, char *strA , char *strB, char *strC){//  A: 00000000
    557e:	e7 2c       	mov	r14, r7
    5580:	ff 24       	eor	r15, r15
    5582:	67 01       	movw	r12, r14
    5584:	08 94       	sec
    5586:	c1 08       	sbc	r12, r1
    5588:	d1 08       	sbc	r13, r1
    558a:	ae 01       	movw	r20, r28
    558c:	43 5c       	subi	r20, 0xC3	; 195
    558e:	5f 4f       	sbci	r21, 0xFF	; 255
    5590:	4c 0d       	add	r20, r12
    5592:	5d 1d       	adc	r21, r13
    5594:	ce 01       	movw	r24, r28
    5596:	01 96       	adiw	r24, 0x01	; 1
    5598:	8c 01       	movw	r16, r24
    559a:	0c 0d       	add	r16, r12
    559c:	1d 1d       	adc	r17, r13
    559e:	be 01       	movw	r22, r28
    55a0:	69 0d       	add	r22, r9
    55a2:	71 1d       	adc	r23, r1
    55a4:	6c 5e       	subi	r22, 0xEC	; 236
    55a6:	7f 4f       	sbci	r23, 0xFF	; 255
    55a8:	99 24       	eor	r9, r9
			     Result[lenA-i-1]=Chr(Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
			 }else
			 if (Ord(tmpA[lenA-i-1])<Ord(tmpB[lenB-i-1])){
			 //Pinjaman
			     for(j=i+1;j<lenA;j++){
				     if (tmpA[lenA-j-1]=='0')tmpA[lenA-j-1]='9';
    55aa:	2c 01       	movw	r4, r24
    55ac:	89 e3       	ldi	r24, 0x39	; 57
    55ae:	88 2e       	mov	r8, r24
					 if (tmpA[lenA-j-1]!='0'){
					     tmpA[lenA-j-1]=Chr(Ord(tmpA[lenA-j-1])-1);
						 break;
					 }				 
				 }
				 Result[lenA-i-1]=Chr(10+Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
    55b0:	9a e0       	ldi	r25, 0x0A	; 10
    55b2:	52 c0       	rjmp	.+164    	; 0x5658 <StrCalc+0x3b2>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    55b4:	d8 01       	movw	r26, r16
    55b6:	8c 91       	ld	r24, X
    55b8:	80 53       	subi	r24, 0x30	; 48
    55ba:	8a 30       	cpi	r24, 0x0A	; 10
    55bc:	10 f0       	brcs	.+4      	; 0x55c2 <StrCalc+0x31c>
    55be:	20 e0       	ldi	r18, 0x00	; 0
    55c0:	01 c0       	rjmp	.+2      	; 0x55c4 <StrCalc+0x31e>
    55c2:	28 2f       	mov	r18, r24
   // -----------
   // C: 099999

	 if (TCalc==TMINUS){
	     for(i=0;i<lenA;i++){		 
		     if (Ord(tmpA[lenA-i-1])>=Ord(tmpB[lenB-i-1])){
    55c4:	fb 01       	movw	r30, r22
    55c6:	30 81       	ld	r19, Z
    55c8:	30 53       	subi	r19, 0x30	; 48
    55ca:	3a 30       	cpi	r19, 0x0A	; 10
    55cc:	10 f4       	brcc	.+4      	; 0x55d2 <StrCalc+0x32c>
    55ce:	23 17       	cp	r18, r19
    55d0:	40 f0       	brcs	.+16     	; 0x55e2 <StrCalc+0x33c>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    55d2:	8a 30       	cpi	r24, 0x0A	; 10
    55d4:	08 f0       	brcs	.+2      	; 0x55d8 <StrCalc+0x332>
    55d6:	80 e0       	ldi	r24, 0x00	; 0

	 if (TCalc==TMINUS){
	     for(i=0;i<lenA;i++){		 
		     if (Ord(tmpA[lenA-i-1])>=Ord(tmpB[lenB-i-1])){
			 //Cukup
			     Result[lenA-i-1]=Chr(Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
    55d8:	3a 30       	cpi	r19, 0x0A	; 10
    55da:	08 f0       	brcs	.+2      	; 0x55de <StrCalc+0x338>
    55dc:	30 e0       	ldi	r19, 0x00	; 0
    55de:	83 1b       	sub	r24, r19
    55e0:	2d c0       	rjmp	.+90     	; 0x563c <StrCalc+0x396>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    55e2:	8a 30       	cpi	r24, 0x0A	; 10
    55e4:	10 f4       	brcc	.+4      	; 0x55ea <StrCalc+0x344>
	     for(i=0;i<lenA;i++){		 
		     if (Ord(tmpA[lenA-i-1])>=Ord(tmpB[lenB-i-1])){
			 //Cukup
			     Result[lenA-i-1]=Chr(Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
			 }else
			 if (Ord(tmpA[lenA-i-1])<Ord(tmpB[lenB-i-1])){
    55e6:	83 17       	cp	r24, r19
    55e8:	80 f5       	brcc	.+96     	; 0x564a <StrCalc+0x3a4>
    55ea:	29 2d       	mov	r18, r9
    55ec:	0a c0       	rjmp	.+20     	; 0x5602 <StrCalc+0x35c>
			 //Pinjaman
			     for(j=i+1;j<lenA;j++){
				     if (tmpA[lenA-j-1]=='0')tmpA[lenA-j-1]='9';
    55ee:	f6 01       	movw	r30, r12
    55f0:	e2 1b       	sub	r30, r18
    55f2:	f1 09       	sbc	r31, r1
    55f4:	d2 01       	movw	r26, r4
    55f6:	ae 0f       	add	r26, r30
    55f8:	bf 1f       	adc	r27, r31
    55fa:	8c 91       	ld	r24, X
    55fc:	80 33       	cpi	r24, 0x30	; 48
    55fe:	29 f4       	brne	.+10     	; 0x560a <StrCalc+0x364>
    5600:	8c 92       	st	X, r8
			 //Cukup
			     Result[lenA-i-1]=Chr(Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
			 }else
			 if (Ord(tmpA[lenA-i-1])<Ord(tmpB[lenB-i-1])){
			 //Pinjaman
			     for(j=i+1;j<lenA;j++){
    5602:	2f 5f       	subi	r18, 0xFF	; 255
    5604:	27 15       	cp	r18, r7
    5606:	98 f3       	brcs	.-26     	; 0x55ee <StrCalc+0x348>
    5608:	10 c0       	rjmp	.+32     	; 0x562a <StrCalc+0x384>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    560a:	28 2f       	mov	r18, r24
    560c:	20 53       	subi	r18, 0x30	; 48
    560e:	2a 30       	cpi	r18, 0x0A	; 10
    5610:	08 f0       	brcs	.+2      	; 0x5614 <StrCalc+0x36e>
    5612:	20 e0       	ldi	r18, 0x00	; 0
			 //Pinjaman
			     for(j=i+1;j<lenA;j++){
				     if (tmpA[lenA-j-1]=='0')tmpA[lenA-j-1]='9';
					 else
					 if (tmpA[lenA-j-1]!='0'){
					     tmpA[lenA-j-1]=Chr(Ord(tmpA[lenA-j-1])-1);
    5614:	82 2f       	mov	r24, r18
    5616:	81 50       	subi	r24, 0x01	; 1
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    5618:	8a 30       	cpi	r24, 0x0A	; 10
    561a:	10 f0       	brcs	.+4      	; 0x5620 <StrCalc+0x37a>
    561c:	80 e3       	ldi	r24, 0x30	; 48
    561e:	02 c0       	rjmp	.+4      	; 0x5624 <StrCalc+0x37e>
	    Result='0'+X;
    5620:	82 2f       	mov	r24, r18
    5622:	81 5d       	subi	r24, 0xD1	; 209
			 //Pinjaman
			     for(j=i+1;j<lenA;j++){
				     if (tmpA[lenA-j-1]=='0')tmpA[lenA-j-1]='9';
					 else
					 if (tmpA[lenA-j-1]!='0'){
					     tmpA[lenA-j-1]=Chr(Ord(tmpA[lenA-j-1])-1);
    5624:	e4 0d       	add	r30, r4
    5626:	f5 1d       	adc	r31, r5
    5628:	80 83       	st	Z, r24
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    562a:	f8 01       	movw	r30, r16
    562c:	20 81       	ld	r18, Z
    562e:	20 53       	subi	r18, 0x30	; 48
    5630:	2a 30       	cpi	r18, 0x0A	; 10
    5632:	08 f0       	brcs	.+2      	; 0x5636 <StrCalc+0x390>
    5634:	20 e0       	ldi	r18, 0x00	; 0
					 if (tmpA[lenA-j-1]!='0'){
					     tmpA[lenA-j-1]=Chr(Ord(tmpA[lenA-j-1])-1);
						 break;
					 }				 
				 }
				 Result[lenA-i-1]=Chr(10+Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
    5636:	89 2f       	mov	r24, r25
    5638:	83 1b       	sub	r24, r19
    563a:	82 0f       	add	r24, r18
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    563c:	8a 30       	cpi	r24, 0x0A	; 10
    563e:	10 f0       	brcs	.+4      	; 0x5644 <StrCalc+0x39e>
    5640:	80 e3       	ldi	r24, 0x30	; 48
    5642:	01 c0       	rjmp	.+2      	; 0x5646 <StrCalc+0x3a0>
	    Result='0'+X;
    5644:	80 5d       	subi	r24, 0xD0	; 208
					 if (tmpA[lenA-j-1]!='0'){
					     tmpA[lenA-j-1]=Chr(Ord(tmpA[lenA-j-1])-1);
						 break;
					 }				 
				 }
				 Result[lenA-i-1]=Chr(10+Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
    5646:	da 01       	movw	r26, r20
    5648:	8c 93       	st	X, r24
   // B: 000001 -
   // -----------
   // C: 099999

	 if (TCalc==TMINUS){
	     for(i=0;i<lenA;i++){		 
    564a:	93 94       	inc	r9
    564c:	41 50       	subi	r20, 0x01	; 1
    564e:	50 40       	sbci	r21, 0x00	; 0
    5650:	01 50       	subi	r16, 0x01	; 1
    5652:	10 40       	sbci	r17, 0x00	; 0
    5654:	61 50       	subi	r22, 0x01	; 1
    5656:	70 40       	sbci	r23, 0x00	; 0
    5658:	97 14       	cp	r9, r7
    565a:	08 f4       	brcc	.+2      	; 0x565e <StrCalc+0x3b8>
    565c:	ab cf       	rjmp	.-170    	; 0x55b4 <StrCalc+0x30e>
						 break;
					 }				 
				 }
				 Result[lenA-i-1]=Chr(10+Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
			 }
		 }Result[lenA]=0;		    
    565e:	8e 01       	movw	r16, r28
    5660:	03 5c       	subi	r16, 0xC3	; 195
    5662:	1f 4f       	sbci	r17, 0xFF	; 255
    5664:	e0 0e       	add	r14, r16
    5666:	f1 1e       	adc	r15, r17
    5668:	f7 01       	movw	r30, r14
    566a:	10 82       	st	Z, r1
       RemZeroLead(Result);
    566c:	c8 01       	movw	r24, r16
    566e:	0e 94 19 25 	call	0x4a32	; 0x4a32 <RemZeroLead>
//	 sprintf_P(strSend,PSTR("C':%s"),Result);
//	 _uart_print(0,1,strSend);
		 
		 FixLen=strlen(Result);
    5672:	f8 01       	movw	r30, r16
    5674:	01 90       	ld	r0, Z+
    5676:	00 20       	and	r0, r0
    5678:	e9 f7       	brne	.-6      	; 0x5674 <StrCalc+0x3ce>
    567a:	31 97       	sbiw	r30, 0x01	; 1
    567c:	3e 2f       	mov	r19, r30
    567e:	30 1b       	sub	r19, r16
    5680:	d8 01       	movw	r26, r16
    5682:	20 e0       	ldi	r18, 0x00	; 0
    5684:	90 e0       	ldi	r25, 0x00	; 0
		 iPos=0;
		 for(i=0;i<FixLen;i++){
		     if ((i==0)&&(IsNegative==True)){
			     strC[iPos]='-';
    5686:	4d e2       	ldi	r20, 0x2D	; 45
    5688:	13 c0       	rjmp	.+38     	; 0x56b0 <StrCalc+0x40a>
//	 _uart_print(0,1,strSend);
		 
		 FixLen=strlen(Result);
		 iPos=0;
		 for(i=0;i<FixLen;i++){
		     if ((i==0)&&(IsNegative==True)){
    568a:	22 23       	and	r18, r18
    568c:	51 f4       	brne	.+20     	; 0x56a2 <StrCalc+0x3fc>
    568e:	62 96       	adiw	r28, 0x12	; 18
    5690:	ff ad       	ldd	r31, Y+63	; 0x3f
    5692:	62 97       	sbiw	r28, 0x12	; 18
    5694:	f1 30       	cpi	r31, 0x01	; 1
    5696:	29 f4       	brne	.+10     	; 0x56a2 <StrCalc+0x3fc>
			     strC[iPos]='-';
    5698:	f5 01       	movw	r30, r10
    569a:	e9 0f       	add	r30, r25
    569c:	f1 1d       	adc	r31, r1
    569e:	40 83       	st	Z, r20
				 iPos++;
    56a0:	9f 5f       	subi	r25, 0xFF	; 255
			 }
		     strC[iPos]=Result[i];
    56a2:	f5 01       	movw	r30, r10
    56a4:	e9 0f       	add	r30, r25
    56a6:	f1 1d       	adc	r31, r1
    56a8:	8d 91       	ld	r24, X+
    56aa:	80 83       	st	Z, r24
			 iPos++;
    56ac:	9f 5f       	subi	r25, 0xFF	; 255
//	 sprintf_P(strSend,PSTR("C':%s"),Result);
//	 _uart_print(0,1,strSend);
		 
		 FixLen=strlen(Result);
		 iPos=0;
		 for(i=0;i<FixLen;i++){
    56ae:	2f 5f       	subi	r18, 0xFF	; 255
    56b0:	23 17       	cp	r18, r19
    56b2:	58 f3       	brcs	.-42     	; 0x568a <StrCalc+0x3e4>
			     strC[iPos]='-';
				 iPos++;
			 }
		     strC[iPos]=Result[i];
			 iPos++;
		 }strC[iPos]=0;
    56b4:	f5 01       	movw	r30, r10
    56b6:	e9 0f       	add	r30, r25
    56b8:	f1 1d       	adc	r31, r1
    56ba:	10 82       	st	Z, r1
    56bc:	a0 c0       	rjmp	.+320    	; 0x57fe <StrCalc+0x558>
	 }
	 else                     //         1
	 if (TCalc==TPLUS){  //A:099999999
    56be:	bd e3       	ldi	r27, 0x3D	; 61
    56c0:	eb 2e       	mov	r14, r27
    56c2:	f1 2c       	mov	r15, r1
    56c4:	ec 0e       	add	r14, r28
    56c6:	fd 1e       	adc	r15, r29
    56c8:	ae 01       	movw	r20, r28
    56ca:	49 0d       	add	r20, r9
    56cc:	51 1d       	adc	r21, r1
    56ce:	4c 5e       	subi	r20, 0xEC	; 236
    56d0:	5f 4f       	sbci	r21, 0xFF	; 255
     
	 //if (NinePos<Length-4)
	 StrCalc(TPLUS,strMaxValue,strOverflowed,strOverflowed);
}
                                                                   //     1111111 
void StrCalc(char TOperation, char *strA , char *strB, char *strC){//  A: 00000000
    56d2:	07 2d       	mov	r16, r7
    56d4:	10 e0       	ldi	r17, 0x00	; 0
    56d6:	48 01       	movw	r8, r16
    56d8:	08 94       	sec
    56da:	81 08       	sbc	r8, r1
    56dc:	91 08       	sbc	r9, r1
    56de:	ce 01       	movw	r24, r28
    56e0:	01 96       	adiw	r24, 0x01	; 1
    56e2:	6c 01       	movw	r12, r24
    56e4:	c8 0c       	add	r12, r8
    56e6:	d9 1c       	adc	r13, r9
    56e8:	30 e0       	ldi	r19, 0x00	; 0
    56ea:	20 e0       	ldi	r18, 0x00	; 0
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    56ec:	2c 01       	movw	r4, r24
                 //Lebih
				 Result[i]=Chr(newC%10);
				 zMin=newC/10;
			     for(j=i+1;j<lenA;j++){
				     if ((Ord(tmpA[lenA-j-1])+zMin)>=10){
					     tmpA[lenA-j-1]=Chr((Ord(tmpA[lenA-j-1])+zMin)%10);
    56ee:	a0 e3       	ldi	r26, 0x30	; 48
    56f0:	3a 2e       	mov	r3, r26
    56f2:	47 c0       	rjmp	.+142    	; 0x5782 <StrCalc+0x4dc>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    56f4:	d6 01       	movw	r26, r12
    56f6:	9c 91       	ld	r25, X
    56f8:	90 53       	subi	r25, 0x30	; 48
    56fa:	9a 30       	cpi	r25, 0x0A	; 10
    56fc:	08 f0       	brcs	.+2      	; 0x5700 <StrCalc+0x45a>
    56fe:	90 e0       	ldi	r25, 0x00	; 0
	 }
	 else                     //         1
	 if (TCalc==TPLUS){  //A:099999999
	     zMin=0;              //B:000000001
	     for(i=0;i<lenA;i++){ //C:       00
		     newC=(Ord(tmpA[lenA-i-1])+Ord(tmpB[lenB-i-1]));			 
    5700:	fa 01       	movw	r30, r20
    5702:	80 81       	ld	r24, Z
    5704:	80 53       	subi	r24, 0x30	; 48
    5706:	8a 30       	cpi	r24, 0x0A	; 10
    5708:	08 f0       	brcs	.+2      	; 0x570c <StrCalc+0x466>
    570a:	80 e0       	ldi	r24, 0x00	; 0
    570c:	89 0f       	add	r24, r25
			 if (newC<10){
    570e:	8a 30       	cpi	r24, 0x0A	; 10
    5710:	18 f4       	brcc	.+6      	; 0x5718 <StrCalc+0x472>
			     Result[i]=Chr(newC);
    5712:	80 5d       	subi	r24, 0xD0	; 208
    5714:	d7 01       	movw	r26, r14
    5716:	28 c0       	rjmp	.+80     	; 0x5768 <StrCalc+0x4c2>
				 zMin=newC/10;
			 }else if (newC>=10){
                 //Lebih
				 Result[i]=Chr(newC%10);
    5718:	6a e0       	ldi	r22, 0x0A	; 10
    571a:	0e 94 f1 b6 	call	0x16de2	; 0x16de2 <__udivmodqi4>
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    571e:	9a 30       	cpi	r25, 0x0A	; 10
    5720:	10 f0       	brcs	.+4      	; 0x5726 <StrCalc+0x480>
    5722:	90 e3       	ldi	r25, 0x30	; 48
    5724:	01 c0       	rjmp	.+2      	; 0x5728 <StrCalc+0x482>
	    Result='0'+X;
    5726:	90 5d       	subi	r25, 0xD0	; 208
			 if (newC<10){
			     Result[i]=Chr(newC);
				 zMin=newC/10;
			 }else if (newC>=10){
                 //Lebih
				 Result[i]=Chr(newC%10);
    5728:	f7 01       	movw	r30, r14
    572a:	90 83       	st	Z, r25
    572c:	83 2f       	mov	r24, r19
    572e:	0e c0       	rjmp	.+28     	; 0x574c <StrCalc+0x4a6>
				 zMin=newC/10;
			     for(j=i+1;j<lenA;j++){
				     if ((Ord(tmpA[lenA-j-1])+zMin)>=10){
    5730:	d4 01       	movw	r26, r8
    5732:	a8 1b       	sub	r26, r24
    5734:	b1 09       	sbc	r27, r1
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    5736:	f2 01       	movw	r30, r4
    5738:	ea 0f       	add	r30, r26
    573a:	fb 1f       	adc	r31, r27
    573c:	90 81       	ld	r25, Z
    573e:	90 53       	subi	r25, 0x30	; 48
    5740:	9a 30       	cpi	r25, 0x0A	; 10
    5742:	08 f0       	brcs	.+2      	; 0x5746 <StrCalc+0x4a0>
    5744:	79 c0       	rjmp	.+242    	; 0x5838 <StrCalc+0x592>
			 }else if (newC>=10){
                 //Lebih
				 Result[i]=Chr(newC%10);
				 zMin=newC/10;
			     for(j=i+1;j<lenA;j++){
				     if ((Ord(tmpA[lenA-j-1])+zMin)>=10){
    5746:	99 30       	cpi	r25, 0x09	; 9
    5748:	29 f4       	brne	.+10     	; 0x5754 <StrCalc+0x4ae>
					     tmpA[lenA-j-1]=Chr((Ord(tmpA[lenA-j-1])+zMin)%10);
    574a:	30 82       	st	Z, r3
				 zMin=newC/10;
			 }else if (newC>=10){
                 //Lebih
				 Result[i]=Chr(newC%10);
				 zMin=newC/10;
			     for(j=i+1;j<lenA;j++){
    574c:	8f 5f       	subi	r24, 0xFF	; 255
    574e:	87 15       	cp	r24, r7
    5750:	78 f3       	brcs	.-34     	; 0x5730 <StrCalc+0x48a>
    5752:	0d c0       	rjmp	.+26     	; 0x576e <StrCalc+0x4c8>
				     if ((Ord(tmpA[lenA-j-1])+zMin)>=10){
					     tmpA[lenA-j-1]=Chr((Ord(tmpA[lenA-j-1])+zMin)%10);
						 zMin=1;
					 }else{
					     tmpA[lenA-j-1]=Chr((Ord(tmpA[lenA-j-1])+zMin));
    5754:	89 2f       	mov	r24, r25
    5756:	8f 5f       	subi	r24, 0xFF	; 255
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    5758:	8a 30       	cpi	r24, 0x0A	; 10
    575a:	10 f0       	brcs	.+4      	; 0x5760 <StrCalc+0x4ba>
    575c:	80 e3       	ldi	r24, 0x30	; 48
    575e:	02 c0       	rjmp	.+4      	; 0x5764 <StrCalc+0x4be>
	    Result='0'+X;
    5760:	89 2f       	mov	r24, r25
    5762:	8f 5c       	subi	r24, 0xCF	; 207
			     for(j=i+1;j<lenA;j++){
				     if ((Ord(tmpA[lenA-j-1])+zMin)>=10){
					     tmpA[lenA-j-1]=Chr((Ord(tmpA[lenA-j-1])+zMin)%10);
						 zMin=1;
					 }else{
					     tmpA[lenA-j-1]=Chr((Ord(tmpA[lenA-j-1])+zMin));
    5764:	a4 0d       	add	r26, r4
    5766:	b5 1d       	adc	r27, r5
    5768:	8c 93       	st	X, r24
    576a:	20 e0       	ldi	r18, 0x00	; 0
    576c:	01 c0       	rjmp	.+2      	; 0x5770 <StrCalc+0x4ca>
				 zMin=newC/10;
			 }else if (newC>=10){
                 //Lebih
				 Result[i]=Chr(newC%10);
				 zMin=newC/10;
			     for(j=i+1;j<lenA;j++){
    576e:	21 e0       	ldi	r18, 0x01	; 1
		 }strC[iPos]=0;
	 }
	 else                     //         1
	 if (TCalc==TPLUS){  //A:099999999
	     zMin=0;              //B:000000001
	     for(i=0;i<lenA;i++){ //C:       00
    5770:	3f 5f       	subi	r19, 0xFF	; 255
    5772:	08 94       	sec
    5774:	e1 1c       	adc	r14, r1
    5776:	f1 1c       	adc	r15, r1
    5778:	41 50       	subi	r20, 0x01	; 1
    577a:	50 40       	sbci	r21, 0x00	; 0
    577c:	08 94       	sec
    577e:	c1 08       	sbc	r12, r1
    5780:	d1 08       	sbc	r13, r1
    5782:	37 15       	cp	r19, r7
    5784:	08 f4       	brcc	.+2      	; 0x5788 <StrCalc+0x4e2>
    5786:	b6 cf       	rjmp	.-148    	; 0x56f4 <StrCalc+0x44e>
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
	    Result='0'+X;
    5788:	20 5d       	subi	r18, 0xD0	; 208
				 }//EndFor j                
			   }//End else
			 }//EndFor

		  //Result[lenA]==Chr(zMin); ???
		  Result[lenA]=Chr(zMin);
    578a:	de 01       	movw	r26, r28
    578c:	dd 96       	adiw	r26, 0x3d	; 61
    578e:	fd 01       	movw	r30, r26
    5790:	e0 0f       	add	r30, r16
    5792:	f1 1f       	adc	r31, r17
    5794:	20 83       	st	Z, r18
		  Result[lenA+1]=0;
    5796:	0c 0f       	add	r16, r28
    5798:	1d 1f       	adc	r17, r29
    579a:	f8 01       	movw	r30, r16
    579c:	16 ae       	std	Z+62, r1	; 0x3e
		 FixLen=strlen(Result);
		 for(i=0;i<FixLen;i++){
		     strC[i]=Result[FixLen-i-1];
		 }strC[FixLen]=0;
*/
         FixLen=strlen(Result);
    579e:	fd 01       	movw	r30, r26
    57a0:	01 90       	ld	r0, Z+
    57a2:	00 20       	and	r0, r0
    57a4:	e9 f7       	brne	.-6      	; 0x57a0 <StrCalc+0x4fa>
    57a6:	31 97       	sbiw	r30, 0x01	; 1
    57a8:	5e 2f       	mov	r21, r30
    57aa:	5a 1b       	sub	r21, r26
    57ac:	25 2f       	mov	r18, r21
    57ae:	30 e0       	ldi	r19, 0x00	; 0
    57b0:	21 50       	subi	r18, 0x01	; 1
    57b2:	30 40       	sbci	r19, 0x00	; 0
    57b4:	2a 0f       	add	r18, r26
    57b6:	3b 1f       	adc	r19, r27
    57b8:	40 e0       	ldi	r20, 0x00	; 0
    57ba:	90 e0       	ldi	r25, 0x00	; 0
		 iPos=0;
		 for(i=0;i<FixLen;i++){
		     if ((i==0)&&(IsNegative==True)){
			     strC[iPos]='-';
    57bc:	6d e2       	ldi	r22, 0x2D	; 45
    57be:	16 c0       	rjmp	.+44     	; 0x57ec <StrCalc+0x546>
		 }strC[FixLen]=0;
*/
         FixLen=strlen(Result);
		 iPos=0;
		 for(i=0;i<FixLen;i++){
		     if ((i==0)&&(IsNegative==True)){
    57c0:	44 23       	and	r20, r20
    57c2:	51 f4       	brne	.+20     	; 0x57d8 <StrCalc+0x532>
    57c4:	63 96       	adiw	r28, 0x13	; 19
    57c6:	ff ad       	ldd	r31, Y+63	; 0x3f
    57c8:	63 97       	sbiw	r28, 0x13	; 19
    57ca:	f1 30       	cpi	r31, 0x01	; 1
    57cc:	29 f4       	brne	.+10     	; 0x57d8 <StrCalc+0x532>
			     strC[iPos]='-';
    57ce:	f5 01       	movw	r30, r10
    57d0:	e9 0f       	add	r30, r25
    57d2:	f1 1d       	adc	r31, r1
    57d4:	60 83       	st	Z, r22
				 iPos++;
    57d6:	9f 5f       	subi	r25, 0xFF	; 255
			 }
		     strC[iPos]=Result[FixLen-i-1];
    57d8:	f5 01       	movw	r30, r10
    57da:	e9 0f       	add	r30, r25
    57dc:	f1 1d       	adc	r31, r1
    57de:	d9 01       	movw	r26, r18
    57e0:	8c 91       	ld	r24, X
    57e2:	80 83       	st	Z, r24
			 iPos++;
    57e4:	9f 5f       	subi	r25, 0xFF	; 255
		     strC[i]=Result[FixLen-i-1];
		 }strC[FixLen]=0;
*/
         FixLen=strlen(Result);
		 iPos=0;
		 for(i=0;i<FixLen;i++){
    57e6:	4f 5f       	subi	r20, 0xFF	; 255
    57e8:	21 50       	subi	r18, 0x01	; 1
    57ea:	30 40       	sbci	r19, 0x00	; 0
    57ec:	45 17       	cp	r20, r21
    57ee:	40 f3       	brcs	.-48     	; 0x57c0 <StrCalc+0x51a>
			     strC[iPos]='-';
				 iPos++;
			 }
		     strC[iPos]=Result[FixLen-i-1];
			 iPos++;
		 }strC[iPos]=0;
    57f0:	f5 01       	movw	r30, r10
    57f2:	e9 0f       	add	r30, r25
    57f4:	f1 1d       	adc	r31, r1
    57f6:	10 82       	st	Z, r1

       RemZeroLead(strC);
    57f8:	c5 01       	movw	r24, r10
    57fa:	0e 94 19 25 	call	0x4a32	; 0x4a32 <RemZeroLead>
  //    sprintf_P(strSend,PSTR("C':%s"),strC);
//	 _uart_print(0,1,strSend);

	 }//EndIf 

	 if (TOperation==TMULTIPLY){
    57fe:	b2 e0       	ldi	r27, 0x02	; 2
    5800:	6b 16       	cp	r6, r27
    5802:	e1 f4       	brne	.+56     	; 0x583c <StrCalc+0x596>
		 valA=atol(strA);
		 valB=atol(strB);
		 valC=valA*valB;		 
         ltoa(valC,strC,10);
		 */
		 CalcMultiply(strA,strB,strC);
    5804:	67 96       	adiw	r28, 0x17	; 23
    5806:	8e ad       	ldd	r24, Y+62	; 0x3e
    5808:	9f ad       	ldd	r25, Y+63	; 0x3f
    580a:	67 97       	sbiw	r28, 0x17	; 23
    580c:	69 96       	adiw	r28, 0x19	; 25
    580e:	6e ad       	ldd	r22, Y+62	; 0x3e
    5810:	7f ad       	ldd	r23, Y+63	; 0x3f
    5812:	69 97       	sbiw	r28, 0x19	; 25
    5814:	a5 01       	movw	r20, r10
    5816:	0e 94 37 2c 	call	0x586e	; 0x586e <CalcMultiply>
    581a:	10 c0       	rjmp	.+32     	; 0x583c <StrCalc+0x596>
	 }
}
    581c:	e1 e0       	ldi	r30, 0x01	; 1
    581e:	62 96       	adiw	r28, 0x12	; 18
    5820:	ef af       	std	Y+63, r30	; 0x3f
    5822:	62 97       	sbiw	r28, 0x12	; 18
    5824:	ac ce       	rjmp	.-680    	; 0x557e <StrCalc+0x2d8>
    5826:	63 96       	adiw	r28, 0x13	; 19
    5828:	1f ae       	std	Y+63, r1	; 0x3f
    582a:	63 97       	sbiw	r28, 0x13	; 19
    582c:	48 cf       	rjmp	.-368    	; 0x56be <StrCalc+0x418>
    582e:	f1 e0       	ldi	r31, 0x01	; 1
    5830:	63 96       	adiw	r28, 0x13	; 19
    5832:	ff af       	std	Y+63, r31	; 0x3f
    5834:	63 97       	sbiw	r28, 0x13	; 19
    5836:	43 cf       	rjmp	.-378    	; 0x56be <StrCalc+0x418>
    5838:	90 e0       	ldi	r25, 0x00	; 0
    583a:	8c cf       	rjmp	.-232    	; 0x5754 <StrCalc+0x4ae>
    583c:	c8 5a       	subi	r28, 0xA8	; 168
    583e:	df 4f       	sbci	r29, 0xFF	; 255
    5840:	0f b6       	in	r0, 0x3f	; 63
    5842:	f8 94       	cli
    5844:	de bf       	out	0x3e, r29	; 62
    5846:	0f be       	out	0x3f, r0	; 63
    5848:	cd bf       	out	0x3d, r28	; 61
    584a:	cf 91       	pop	r28
    584c:	df 91       	pop	r29
    584e:	1f 91       	pop	r17
    5850:	0f 91       	pop	r16
    5852:	ff 90       	pop	r15
    5854:	ef 90       	pop	r14
    5856:	df 90       	pop	r13
    5858:	cf 90       	pop	r12
    585a:	bf 90       	pop	r11
    585c:	af 90       	pop	r10
    585e:	9f 90       	pop	r9
    5860:	8f 90       	pop	r8
    5862:	7f 90       	pop	r7
    5864:	6f 90       	pop	r6
    5866:	5f 90       	pop	r5
    5868:	4f 90       	pop	r4
    586a:	3f 90       	pop	r3
    586c:	08 95       	ret

0000586e <CalcMultiply>:
	 }
	 strResult[lenR]=0;
}


void CalcMultiply(char *strA,char *strB,char *strC){
    586e:	4f 92       	push	r4
    5870:	5f 92       	push	r5
    5872:	6f 92       	push	r6
    5874:	7f 92       	push	r7
    5876:	8f 92       	push	r8
    5878:	9f 92       	push	r9
    587a:	af 92       	push	r10
    587c:	bf 92       	push	r11
    587e:	cf 92       	push	r12
    5880:	df 92       	push	r13
    5882:	ef 92       	push	r14
    5884:	ff 92       	push	r15
    5886:	0f 93       	push	r16
    5888:	1f 93       	push	r17
    588a:	df 93       	push	r29
    588c:	cf 93       	push	r28
    588e:	cd b7       	in	r28, 0x3d	; 61
    5890:	de b7       	in	r29, 0x3e	; 62
    5892:	a8 97       	sbiw	r28, 0x28	; 40
    5894:	0f b6       	in	r0, 0x3f	; 63
    5896:	f8 94       	cli
    5898:	de bf       	out	0x3e, r29	; 62
    589a:	0f be       	out	0x3f, r0	; 63
    589c:	cd bf       	out	0x3d, r28	; 61
    589e:	3c 01       	movw	r6, r24
    58a0:	6b 01       	movw	r12, r22
    58a2:	2a 01       	movw	r4, r20
	 
	 */
	 char i,lenB;
	 char prevSeg[20],currSeg[20];

     RemZeroLead(strA);
    58a4:	0e 94 19 25 	call	0x4a32	; 0x4a32 <RemZeroLead>
     RemZeroLead(strB);
    58a8:	c6 01       	movw	r24, r12
    58aa:	0e 94 19 25 	call	0x4a32	; 0x4a32 <RemZeroLead>
	 lenB=strlen(strB);
    58ae:	d6 01       	movw	r26, r12
    58b0:	0d 90       	ld	r0, X+
    58b2:	00 20       	and	r0, r0
    58b4:	e9 f7       	brne	.-6      	; 0x58b0 <CalcMultiply+0x42>
    58b6:	11 97       	sbiw	r26, 0x01	; 1
    58b8:	8a 2e       	mov	r8, r26
    58ba:	8c 18       	sub	r8, r12
	 sprintf_P(prevSeg,PSTR("0"));
    58bc:	00 d0       	rcall	.+0      	; 0x58be <CalcMultiply+0x50>
    58be:	00 d0       	rcall	.+0      	; 0x58c0 <CalcMultiply+0x52>
    58c0:	8e 01       	movw	r16, r28
    58c2:	0f 5f       	subi	r16, 0xFF	; 255
    58c4:	1f 4f       	sbci	r17, 0xFF	; 255
    58c6:	ad b7       	in	r26, 0x3d	; 61
    58c8:	be b7       	in	r27, 0x3e	; 62
    58ca:	12 96       	adiw	r26, 0x02	; 2
    58cc:	1c 93       	st	X, r17
    58ce:	0e 93       	st	-X, r16
    58d0:	11 97       	sbiw	r26, 0x01	; 1
    58d2:	84 e7       	ldi	r24, 0x74	; 116
    58d4:	95 e0       	ldi	r25, 0x05	; 5
    58d6:	14 96       	adiw	r26, 0x04	; 4
    58d8:	9c 93       	st	X, r25
    58da:	8e 93       	st	-X, r24
    58dc:	13 97       	sbiw	r26, 0x03	; 3
    58de:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
	 sprintf_P(currSeg,PSTR("0"));
    58e2:	25 e1       	ldi	r18, 0x15	; 21
    58e4:	e2 2e       	mov	r14, r18
    58e6:	f1 2c       	mov	r15, r1
    58e8:	ec 0e       	add	r14, r28
    58ea:	fd 1e       	adc	r15, r29
    58ec:	ed b7       	in	r30, 0x3d	; 61
    58ee:	fe b7       	in	r31, 0x3e	; 62
    58f0:	f2 82       	std	Z+2, r15	; 0x02
    58f2:	e1 82       	std	Z+1, r14	; 0x01
    58f4:	82 e7       	ldi	r24, 0x72	; 114
    58f6:	95 e0       	ldi	r25, 0x05	; 5
    58f8:	94 83       	std	Z+4, r25	; 0x04
    58fa:	83 83       	std	Z+3, r24	; 0x03
    58fc:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    5900:	bb 24       	eor	r11, r11
    5902:	0f 90       	pop	r0
    5904:	0f 90       	pop	r0
    5906:	0f 90       	pop	r0
    5908:	0f 90       	pop	r0
    590a:	a0 2e       	mov	r10, r16
    590c:	91 2e       	mov	r9, r17

	 for(i=0;i<strlen(strB);i++){
	     //
         CalcSegmen(strA,strB[lenB-1-i],currSeg);
    590e:	08 2d       	mov	r16, r8
    5910:	10 e0       	ldi	r17, 0x00	; 0
    5912:	01 50       	subi	r16, 0x01	; 1
    5914:	10 40       	sbci	r17, 0x00	; 0
    5916:	1f c0       	rjmp	.+62     	; 0x5956 <CalcMultiply+0xe8>
    5918:	f8 01       	movw	r30, r16
    591a:	e8 1b       	sub	r30, r24
    591c:	f9 0b       	sbc	r31, r25
    591e:	ec 0d       	add	r30, r12
    5920:	fd 1d       	adc	r31, r13
    5922:	c3 01       	movw	r24, r6
    5924:	60 81       	ld	r22, Z
    5926:	a7 01       	movw	r20, r14
    5928:	0e 94 9e 22 	call	0x453c	; 0x453c <CalcSegmen>
         AddZeroLag(currSeg,strlen(currSeg)+i);
    592c:	f7 01       	movw	r30, r14
    592e:	01 90       	ld	r0, Z+
    5930:	00 20       	and	r0, r0
    5932:	e9 f7       	brne	.-6      	; 0x592e <CalcMultiply+0xc0>
    5934:	31 97       	sbiw	r30, 0x01	; 1
    5936:	ee 19       	sub	r30, r14
    5938:	ff 09       	sbc	r31, r15
    593a:	6b 2d       	mov	r22, r11
    593c:	6e 0f       	add	r22, r30
    593e:	c7 01       	movw	r24, r14
    5940:	0e 94 38 29 	call	0x5270	; 0x5270 <AddZeroLag>
	     StrCalc(TPLUS,prevSeg,currSeg,prevSeg);
    5944:	81 e0       	ldi	r24, 0x01	; 1
    5946:	6a 2d       	mov	r22, r10
    5948:	79 2d       	mov	r23, r9
    594a:	a7 01       	movw	r20, r14
    594c:	2a 2d       	mov	r18, r10
    594e:	39 2d       	mov	r19, r9
    5950:	0e 94 53 29 	call	0x52a6	; 0x52a6 <StrCalc>
     RemZeroLead(strB);
	 lenB=strlen(strB);
	 sprintf_P(prevSeg,PSTR("0"));
	 sprintf_P(currSeg,PSTR("0"));

	 for(i=0;i<strlen(strB);i++){
    5954:	b3 94       	inc	r11
    5956:	f6 01       	movw	r30, r12
    5958:	01 90       	ld	r0, Z+
    595a:	00 20       	and	r0, r0
    595c:	e9 f7       	brne	.-6      	; 0x5958 <CalcMultiply+0xea>
    595e:	31 97       	sbiw	r30, 0x01	; 1
    5960:	ec 19       	sub	r30, r12
    5962:	fd 09       	sbc	r31, r13
    5964:	8b 2d       	mov	r24, r11
    5966:	90 e0       	ldi	r25, 0x00	; 0
    5968:	8e 17       	cp	r24, r30
    596a:	9f 07       	cpc	r25, r31
    596c:	a8 f2       	brcs	.-86     	; 0x5918 <CalcMultiply+0xaa>
	     //
         CalcSegmen(strA,strB[lenB-1-i],currSeg);
         AddZeroLag(currSeg,strlen(currSeg)+i);
	     StrCalc(TPLUS,prevSeg,currSeg,prevSeg);
	 }
	 sprintf_P(strC,PSTR("%s"),prevSeg);
    596e:	00 d0       	rcall	.+0      	; 0x5970 <CalcMultiply+0x102>
    5970:	00 d0       	rcall	.+0      	; 0x5972 <CalcMultiply+0x104>
    5972:	00 d0       	rcall	.+0      	; 0x5974 <CalcMultiply+0x106>
    5974:	ed b7       	in	r30, 0x3d	; 61
    5976:	fe b7       	in	r31, 0x3e	; 62
    5978:	31 96       	adiw	r30, 0x01	; 1
    597a:	ad b7       	in	r26, 0x3d	; 61
    597c:	be b7       	in	r27, 0x3e	; 62
    597e:	12 96       	adiw	r26, 0x02	; 2
    5980:	5c 92       	st	X, r5
    5982:	4e 92       	st	-X, r4
    5984:	11 97       	sbiw	r26, 0x01	; 1
    5986:	8f e6       	ldi	r24, 0x6F	; 111
    5988:	95 e0       	ldi	r25, 0x05	; 5
    598a:	93 83       	std	Z+3, r25	; 0x03
    598c:	82 83       	std	Z+2, r24	; 0x02
    598e:	a4 82       	std	Z+4, r10	; 0x04
    5990:	95 82       	std	Z+5, r9	; 0x05
    5992:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    5996:	ed b7       	in	r30, 0x3d	; 61
    5998:	fe b7       	in	r31, 0x3e	; 62
    599a:	36 96       	adiw	r30, 0x06	; 6
    599c:	0f b6       	in	r0, 0x3f	; 63
    599e:	f8 94       	cli
    59a0:	fe bf       	out	0x3e, r31	; 62
    59a2:	0f be       	out	0x3f, r0	; 63
    59a4:	ed bf       	out	0x3d, r30	; 61
}
    59a6:	a8 96       	adiw	r28, 0x28	; 40
    59a8:	0f b6       	in	r0, 0x3f	; 63
    59aa:	f8 94       	cli
    59ac:	de bf       	out	0x3e, r29	; 62
    59ae:	0f be       	out	0x3f, r0	; 63
    59b0:	cd bf       	out	0x3d, r28	; 61
    59b2:	cf 91       	pop	r28
    59b4:	df 91       	pop	r29
    59b6:	1f 91       	pop	r17
    59b8:	0f 91       	pop	r16
    59ba:	ff 90       	pop	r15
    59bc:	ef 90       	pop	r14
    59be:	df 90       	pop	r13
    59c0:	cf 90       	pop	r12
    59c2:	bf 90       	pop	r11
    59c4:	af 90       	pop	r10
    59c6:	9f 90       	pop	r9
    59c8:	8f 90       	pop	r8
    59ca:	7f 90       	pop	r7
    59cc:	6f 90       	pop	r6
    59ce:	5f 90       	pop	r5
    59d0:	4f 90       	pop	r4
    59d2:	08 95       	ret

000059d4 <NormalizeOverflow>:
		 Length=strlen(strNumber);
		 StrPosCopy(strNumber,strNumber,MinPos,(Length-MinPos));	      
	 }
}

void NormalizeOverflow(char *strOverflowed){
    59d4:	cf 92       	push	r12
    59d6:	df 92       	push	r13
    59d8:	ef 92       	push	r14
    59da:	ff 92       	push	r15
    59dc:	0f 93       	push	r16
    59de:	1f 93       	push	r17
    59e0:	df 93       	push	r29
    59e2:	cf 93       	push	r28
    59e4:	cd b7       	in	r28, 0x3d	; 61
    59e6:	de b7       	in	r29, 0x3e	; 62
    59e8:	64 97       	sbiw	r28, 0x14	; 20
    59ea:	0f b6       	in	r0, 0x3f	; 63
    59ec:	f8 94       	cli
    59ee:	de bf       	out	0x3e, r29	; 62
    59f0:	0f be       	out	0x3f, r0	; 63
    59f2:	cd bf       	out	0x3d, r28	; 61
    59f4:	d8 2e       	mov	r13, r24
    59f6:	c9 2e       	mov	r12, r25
char i,Length,strMaxValue[20];//-99999999

     Length=strlen(strOverflowed);//-999453
    59f8:	a8 2f       	mov	r26, r24
    59fa:	b9 2f       	mov	r27, r25
    59fc:	fd 01       	movw	r30, r26
    59fe:	01 90       	ld	r0, Z+
    5a00:	00 20       	and	r0, r0
    5a02:	e9 f7       	brne	.-6      	; 0x59fe <NormalizeOverflow+0x2a>
    5a04:	31 97       	sbiw	r30, 0x01	; 1
    5a06:	4e 2f       	mov	r20, r30
    5a08:	48 1b       	sub	r20, r24
    5a0a:	20 e0       	ldi	r18, 0x00	; 0
    5a0c:	30 e0       	ldi	r19, 0x00	; 0
    5a0e:	7e 01       	movw	r14, r28
    5a10:	08 94       	sec
    5a12:	e1 1c       	adc	r14, r1
    5a14:	f1 1c       	adc	r15, r1
    5a16:	04 2f       	mov	r16, r20
    5a18:	10 e0       	ldi	r17, 0x00	; 0
    5a1a:	0e c0       	rjmp	.+28     	; 0x5a38 <NormalizeOverflow+0x64>
     for(i=0;i<Length;i++){//123456
	     strMaxValue[i]='0'+((Length-i)/Length);
    5a1c:	f7 01       	movw	r30, r14
    5a1e:	e2 0f       	add	r30, r18
    5a20:	f3 1f       	adc	r31, r19
    5a22:	c8 01       	movw	r24, r16
    5a24:	82 1b       	sub	r24, r18
    5a26:	93 0b       	sbc	r25, r19
    5a28:	64 2f       	mov	r22, r20
    5a2a:	70 e0       	ldi	r23, 0x00	; 0
    5a2c:	0e 94 1e b7 	call	0x16e3c	; 0x16e3c <__divmodhi4>
    5a30:	60 5d       	subi	r22, 0xD0	; 208
    5a32:	60 83       	st	Z, r22
    5a34:	2f 5f       	subi	r18, 0xFF	; 255
    5a36:	3f 4f       	sbci	r19, 0xFF	; 255

void NormalizeOverflow(char *strOverflowed){
char i,Length,strMaxValue[20];//-99999999

     Length=strlen(strOverflowed);//-999453
     for(i=0;i<Length;i++){//123456
    5a38:	24 17       	cp	r18, r20
    5a3a:	80 f3       	brcs	.-32     	; 0x5a1c <NormalizeOverflow+0x48>
	     strMaxValue[i]='0'+((Length-i)/Length);
	 }strMaxValue[Length]=0;
    5a3c:	0e 0d       	add	r16, r14
    5a3e:	1f 1d       	adc	r17, r15
    5a40:	f8 01       	movw	r30, r16
    5a42:	10 82       	st	Z, r1
     
	 //if (NinePos<Length-4)
	 StrCalc(TPLUS,strMaxValue,strOverflowed,strOverflowed);
    5a44:	81 e0       	ldi	r24, 0x01	; 1
    5a46:	b7 01       	movw	r22, r14
    5a48:	4d 2d       	mov	r20, r13
    5a4a:	5c 2d       	mov	r21, r12
    5a4c:	2d 2d       	mov	r18, r13
    5a4e:	3c 2d       	mov	r19, r12
    5a50:	0e 94 53 29 	call	0x52a6	; 0x52a6 <StrCalc>
}
    5a54:	64 96       	adiw	r28, 0x14	; 20
    5a56:	0f b6       	in	r0, 0x3f	; 63
    5a58:	f8 94       	cli
    5a5a:	de bf       	out	0x3e, r29	; 62
    5a5c:	0f be       	out	0x3f, r0	; 63
    5a5e:	cd bf       	out	0x3d, r28	; 61
    5a60:	cf 91       	pop	r28
    5a62:	df 91       	pop	r29
    5a64:	1f 91       	pop	r17
    5a66:	0f 91       	pop	r16
    5a68:	ff 90       	pop	r15
    5a6a:	ef 90       	pop	r14
    5a6c:	df 90       	pop	r13
    5a6e:	cf 90       	pop	r12
    5a70:	08 95       	ret

00005a72 <AddSpaceLead>:
	    String[i]=' ';
	 }String[Size]=0;
  }
}

void AddSpaceLead(char *String,unsigned char Size){//
    5a72:	bf 92       	push	r11
    5a74:	cf 92       	push	r12
    5a76:	df 92       	push	r13
    5a78:	ef 92       	push	r14
    5a7a:	ff 92       	push	r15
    5a7c:	0f 93       	push	r16
    5a7e:	1f 93       	push	r17
    5a80:	df 93       	push	r29
    5a82:	cf 93       	push	r28
    5a84:	cd b7       	in	r28, 0x3d	; 61
    5a86:	de b7       	in	r29, 0x3e	; 62
    5a88:	e2 97       	sbiw	r28, 0x32	; 50
    5a8a:	0f b6       	in	r0, 0x3f	; 63
    5a8c:	f8 94       	cli
    5a8e:	de bf       	out	0x3e, r29	; 62
    5a90:	0f be       	out	0x3f, r0	; 63
    5a92:	cd bf       	out	0x3d, r28	; 61
    5a94:	8c 01       	movw	r16, r24
     char i,Length,strAdded[50];
     Length=strlen(String);
    5a96:	fc 01       	movw	r30, r24
    5a98:	01 90       	ld	r0, Z+
    5a9a:	00 20       	and	r0, r0
    5a9c:	e9 f7       	brne	.-6      	; 0x5a98 <AddSpaceLead+0x26>
    5a9e:	31 97       	sbiw	r30, 0x01	; 1
    5aa0:	2e 2f       	mov	r18, r30
    5aa2:	28 1b       	sub	r18, r24

	 if (Size>Length){
    5aa4:	26 17       	cp	r18, r22
    5aa6:	e0 f5       	brcc	.+120    	; 0x5b20 <AddSpaceLead+0xae>
    5aa8:	7e 01       	movw	r14, r28
    5aaa:	08 94       	sec
    5aac:	e1 1c       	adc	r14, r1
    5aae:	f1 1c       	adc	r15, r1
    5ab0:	f7 01       	movw	r30, r14
	    String[i]=' ';
	 }String[Size]=0;
  }
}

void AddSpaceLead(char *String,unsigned char Size){//
    5ab2:	be 2c       	mov	r11, r14
     char i,Length,strAdded[50];
     Length=strlen(String);

	 if (Size>Length){
         for(i=0;i<Size;i++){
	         strAdded[i]=' ';
    5ab4:	90 e2       	ldi	r25, 0x20	; 32
    5ab6:	01 c0       	rjmp	.+2      	; 0x5aba <AddSpaceLead+0x48>
    5ab8:	91 93       	st	Z+, r25
void AddSpaceLead(char *String,unsigned char Size){//
     char i,Length,strAdded[50];
     Length=strlen(String);

	 if (Size>Length){
         for(i=0;i<Size;i++){
    5aba:	8e 2f       	mov	r24, r30
    5abc:	8b 19       	sub	r24, r11
    5abe:	86 17       	cp	r24, r22
    5ac0:	d8 f3       	brcs	.-10     	; 0x5ab8 <AddSpaceLead+0x46>
	         strAdded[i]=' ';
	     }strAdded[Size]=0;
    5ac2:	46 2f       	mov	r20, r22
    5ac4:	50 e0       	ldi	r21, 0x00	; 0
    5ac6:	ce 01       	movw	r24, r28
    5ac8:	01 96       	adiw	r24, 0x01	; 1
    5aca:	fc 01       	movw	r30, r24
    5acc:	e4 0f       	add	r30, r20
    5ace:	f5 1f       	adc	r31, r21
    5ad0:	10 82       	st	Z, r1
	     //Copy
         for(i=(Size-Length);i<Size;i++){
    5ad2:	76 2f       	mov	r23, r22
    5ad4:	72 1b       	sub	r23, r18
    5ad6:	6c 01       	movw	r12, r24
	         strAdded[i]=String[i-(Size-Length)];
    5ad8:	30 e0       	ldi	r19, 0x00	; 0
    5ada:	24 1b       	sub	r18, r20
    5adc:	35 0b       	sbc	r19, r21
    5ade:	0c c0       	rjmp	.+24     	; 0x5af8 <AddSpaceLead+0x86>
    5ae0:	e7 2f       	mov	r30, r23
    5ae2:	f0 e0       	ldi	r31, 0x00	; 0
    5ae4:	d6 01       	movw	r26, r12
    5ae6:	ae 0f       	add	r26, r30
    5ae8:	bf 1f       	adc	r27, r31
    5aea:	e0 0f       	add	r30, r16
    5aec:	f1 1f       	adc	r31, r17
    5aee:	e2 0f       	add	r30, r18
    5af0:	f3 1f       	adc	r31, r19
    5af2:	80 81       	ld	r24, Z
    5af4:	8c 93       	st	X, r24
	 if (Size>Length){
         for(i=0;i<Size;i++){
	         strAdded[i]=' ';
	     }strAdded[Size]=0;
	     //Copy
         for(i=(Size-Length);i<Size;i++){
    5af6:	7f 5f       	subi	r23, 0xFF	; 255
    5af8:	76 17       	cp	r23, r22
    5afa:	90 f3       	brcs	.-28     	; 0x5ae0 <AddSpaceLead+0x6e>
	         strAdded[i]=String[i-(Size-Length)];
	     }strAdded[Size]=0;
    5afc:	4c 0d       	add	r20, r12
    5afe:	5d 1d       	adc	r21, r13
    5b00:	da 01       	movw	r26, r20
    5b02:	1c 92       	st	X, r1
    5b04:	f8 01       	movw	r30, r16
    5b06:	04 c0       	rjmp	.+8      	; 0x5b10 <AddSpaceLead+0x9e>
	     //Spaced
         for(i=0;i<Size;i++){
	         String[i]=strAdded[i];
    5b08:	d7 01       	movw	r26, r14
    5b0a:	8d 91       	ld	r24, X+
    5b0c:	7d 01       	movw	r14, r26
    5b0e:	81 93       	st	Z+, r24
	     //Copy
         for(i=(Size-Length);i<Size;i++){
	         strAdded[i]=String[i-(Size-Length)];
	     }strAdded[Size]=0;
	     //Spaced
         for(i=0;i<Size;i++){
    5b10:	8e 2d       	mov	r24, r14
    5b12:	8b 19       	sub	r24, r11
    5b14:	86 17       	cp	r24, r22
    5b16:	c0 f3       	brcs	.-16     	; 0x5b08 <AddSpaceLead+0x96>
	         String[i]=strAdded[i];
	     }String[Size]=0;
    5b18:	06 0f       	add	r16, r22
    5b1a:	11 1d       	adc	r17, r1
    5b1c:	f8 01       	movw	r30, r16
    5b1e:	10 82       	st	Z, r1
	 }
}
    5b20:	e2 96       	adiw	r28, 0x32	; 50
    5b22:	0f b6       	in	r0, 0x3f	; 63
    5b24:	f8 94       	cli
    5b26:	de bf       	out	0x3e, r29	; 62
    5b28:	0f be       	out	0x3f, r0	; 63
    5b2a:	cd bf       	out	0x3d, r28	; 61
    5b2c:	cf 91       	pop	r28
    5b2e:	df 91       	pop	r29
    5b30:	1f 91       	pop	r17
    5b32:	0f 91       	pop	r16
    5b34:	ff 90       	pop	r15
    5b36:	ef 90       	pop	r14
    5b38:	df 90       	pop	r13
    5b3a:	cf 90       	pop	r12
    5b3c:	bf 90       	pop	r11
    5b3e:	08 95       	ret

00005b40 <AddSpaceLag>:
	 }
}



void AddSpaceLag(char *String,unsigned char Size){// [CREDITCARD             ]
    5b40:	cf 93       	push	r28
    5b42:	df 93       	push	r29
    5b44:	ec 01       	movw	r28, r24
char i,Length;
     Length=strlen(String);
    5b46:	dc 01       	movw	r26, r24
    5b48:	0d 90       	ld	r0, X+
    5b4a:	00 20       	and	r0, r0
    5b4c:	e9 f7       	brne	.-6      	; 0x5b48 <AddSpaceLag+0x8>
    5b4e:	11 97       	sbiw	r26, 0x01	; 1
    5b50:	a8 1b       	sub	r26, r24
    5b52:	b9 0b       	sbc	r27, r25
  if (Length<Size){   
    5b54:	a6 17       	cp	r26, r22
    5b56:	60 f4       	brcc	.+24     	; 0x5b70 <AddSpaceLag+0x30>
    5b58:	8a 2f       	mov	r24, r26
     for(i=Length;i<Size;i++){
	    String[i]=' ';
    5b5a:	90 e2       	ldi	r25, 0x20	; 32
    5b5c:	fe 01       	movw	r30, r28
    5b5e:	e8 0f       	add	r30, r24
    5b60:	f1 1d       	adc	r31, r1
    5b62:	90 83       	st	Z, r25

void AddSpaceLag(char *String,unsigned char Size){// [CREDITCARD             ]
char i,Length;
     Length=strlen(String);
  if (Length<Size){   
     for(i=Length;i<Size;i++){
    5b64:	8f 5f       	subi	r24, 0xFF	; 255
    5b66:	86 17       	cp	r24, r22
    5b68:	c8 f3       	brcs	.-14     	; 0x5b5c <AddSpaceLag+0x1c>
	    String[i]=' ';
	 }String[Size]=0;
    5b6a:	c6 0f       	add	r28, r22
    5b6c:	d1 1d       	adc	r29, r1
    5b6e:	18 82       	st	Y, r1
  }
}
    5b70:	df 91       	pop	r29
    5b72:	cf 91       	pop	r28
    5b74:	08 95       	ret

00005b76 <GetProductName>:
	 }    
	 //Clear Decimal

}

void GetProductName(char GradeId,char *strProductName){
    5b76:	0f 93       	push	r16
    5b78:	1f 93       	push	r17
    5b7a:	df 93       	push	r29
    5b7c:	cf 93       	push	r28
    5b7e:	cd b7       	in	r28, 0x3d	; 61
    5b80:	de b7       	in	r29, 0x3e	; 62
    5b82:	2c 97       	sbiw	r28, 0x0c	; 12
    5b84:	0f b6       	in	r0, 0x3f	; 63
    5b86:	f8 94       	cli
    5b88:	de bf       	out	0x3e, r29	; 62
    5b8a:	0f be       	out	0x3f, r0	; 63
    5b8c:	cd bf       	out	0x3d, r28	; 61
    5b8e:	48 2f       	mov	r20, r24
    5b90:	8b 01       	movw	r16, r22
    5b92:	fe 01       	movw	r30, r28
    5b94:	31 96       	adiw	r30, 0x01	; 1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    5b96:	9e 01       	movw	r18, r28
    5b98:	23 5f       	subi	r18, 0xF3	; 243
    5b9a:	3f 4f       	sbci	r19, 0xFF	; 255
	     strMemory[i]=data;
    5b9c:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    5b9e:	e2 17       	cp	r30, r18
    5ba0:	f3 07       	cpc	r31, r19
    5ba2:	e1 f7       	brne	.-8      	; 0x5b9c <GetProductName+0x26>
    5ba4:	ce 01       	movw	r24, r28
    5ba6:	01 96       	adiw	r24, 0x01	; 1

void GetProductName(char GradeId,char *strProductName){
char SProductName[12],i,Length;
     FillChar(SProductName,sizeof(SProductName),0); 
	 //eeprom_read_block((void*) &SProductName, (const void*) &DefProductName[GradeId-1],10);
	 if (GradeId>0) eeprom_read_block((void*) &SProductName, (const void*) &DefProductName[GradeId-1],10);
    5ba8:	44 23       	and	r20, r20
    5baa:	69 f0       	breq	.+26     	; 0x5bc6 <GetProductName+0x50>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    5bac:	6d e0       	ldi	r22, 0x0D	; 13
    5bae:	46 9f       	mul	r20, r22
    5bb0:	b0 01       	movw	r22, r0
    5bb2:	11 24       	eor	r1, r1
    5bb4:	62 55       	subi	r22, 0x52	; 82
    5bb6:	7f 4f       	sbci	r23, 0xFF	; 255
    5bb8:	4a e0       	ldi	r20, 0x0A	; 10
    5bba:	50 e0       	ldi	r21, 0x00	; 0
    5bbc:	2d ef       	ldi	r18, 0xFD	; 253
    5bbe:	32 e1       	ldi	r19, 0x12	; 18
    5bc0:	0e 94 f1 b3 	call	0x167e2	; 0x167e2 <__eerd_block>
    5bc4:	14 c0       	rjmp	.+40     	; 0x5bee <GetProductName+0x78>
	 else sprintf_P(SProductName,PSTR("N/A"));
    5bc6:	00 d0       	rcall	.+0      	; 0x5bc8 <GetProductName+0x52>
    5bc8:	00 d0       	rcall	.+0      	; 0x5bca <GetProductName+0x54>
    5bca:	ad b7       	in	r26, 0x3d	; 61
    5bcc:	be b7       	in	r27, 0x3e	; 62
    5bce:	12 96       	adiw	r26, 0x02	; 2
    5bd0:	9c 93       	st	X, r25
    5bd2:	8e 93       	st	-X, r24
    5bd4:	11 97       	sbiw	r26, 0x01	; 1
    5bd6:	86 ec       	ldi	r24, 0xC6	; 198
    5bd8:	93 e0       	ldi	r25, 0x03	; 3
    5bda:	14 96       	adiw	r26, 0x04	; 4
    5bdc:	9c 93       	st	X, r25
    5bde:	8e 93       	st	-X, r24
    5be0:	13 97       	sbiw	r26, 0x03	; 3
    5be2:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    5be6:	0f 90       	pop	r0
    5be8:	0f 90       	pop	r0
    5bea:	0f 90       	pop	r0
    5bec:	0f 90       	pop	r0

     Length=strlen(SProductName);
    5bee:	de 01       	movw	r26, r28
    5bf0:	11 96       	adiw	r26, 0x01	; 1
    5bf2:	fd 01       	movw	r30, r26
    5bf4:	01 90       	ld	r0, Z+
    5bf6:	00 20       	and	r0, r0
    5bf8:	e9 f7       	brne	.-6      	; 0x5bf4 <GetProductName+0x7e>
    5bfa:	31 97       	sbiw	r30, 0x01	; 1
    5bfc:	ea 1b       	sub	r30, r26
    5bfe:	eb 30       	cpi	r30, 0x0B	; 11
    5c00:	08 f0       	brcs	.+2      	; 0x5c04 <GetProductName+0x8e>
    5c02:	ea e0       	ldi	r30, 0x0A	; 10
    5c04:	ae 01       	movw	r20, r28
    5c06:	4f 5f       	subi	r20, 0xFF	; 255
    5c08:	5f 4f       	sbci	r21, 0xFF	; 255
    5c0a:	98 01       	movw	r18, r16
    5c0c:	ba 01       	movw	r22, r20
    5c0e:	06 c0       	rjmp	.+12     	; 0x5c1c <GetProductName+0xa6>
	 if (Length>10)Length=10;

	 for(i=0;i<Length;i++){
	     strProductName[i]=SProductName[i];
    5c10:	db 01       	movw	r26, r22
    5c12:	8d 91       	ld	r24, X+
    5c14:	bd 01       	movw	r22, r26
    5c16:	d9 01       	movw	r26, r18
    5c18:	8d 93       	st	X+, r24
    5c1a:	9d 01       	movw	r18, r26
	 else sprintf_P(SProductName,PSTR("N/A"));

     Length=strlen(SProductName);
	 if (Length>10)Length=10;

	 for(i=0;i<Length;i++){
    5c1c:	86 2f       	mov	r24, r22
    5c1e:	84 1b       	sub	r24, r20
    5c20:	8e 17       	cp	r24, r30
    5c22:	b0 f3       	brcs	.-20     	; 0x5c10 <GetProductName+0x9a>
	     strProductName[i]=SProductName[i];
	 }strProductName[Length]=0;
    5c24:	c8 01       	movw	r24, r16
    5c26:	8e 0f       	add	r24, r30
    5c28:	91 1d       	adc	r25, r1
    5c2a:	fc 01       	movw	r30, r24
    5c2c:	10 82       	st	Z, r1

	 AddSpaceLag(strProductName,10);
    5c2e:	c8 01       	movw	r24, r16
    5c30:	6a e0       	ldi	r22, 0x0A	; 10
    5c32:	0e 94 a0 2d 	call	0x5b40	; 0x5b40 <AddSpaceLag>
}
    5c36:	2c 96       	adiw	r28, 0x0c	; 12
    5c38:	0f b6       	in	r0, 0x3f	; 63
    5c3a:	f8 94       	cli
    5c3c:	de bf       	out	0x3e, r29	; 62
    5c3e:	0f be       	out	0x3f, r0	; 63
    5c40:	cd bf       	out	0x3d, r28	; 61
    5c42:	cf 91       	pop	r28
    5c44:	df 91       	pop	r29
    5c46:	1f 91       	pop	r17
    5c48:	0f 91       	pop	r16
    5c4a:	08 95       	ret

00005c4c <GeniusSendLastTransaction>:
}
void GeniusSendPumpPreset(char iPumpID){
}


void GeniusSendLastTransaction(char iPumpID){
    5c4c:	2f 92       	push	r2
    5c4e:	3f 92       	push	r3
    5c50:	4f 92       	push	r4
    5c52:	5f 92       	push	r5
    5c54:	6f 92       	push	r6
    5c56:	7f 92       	push	r7
    5c58:	8f 92       	push	r8
    5c5a:	9f 92       	push	r9
    5c5c:	af 92       	push	r10
    5c5e:	bf 92       	push	r11
    5c60:	cf 92       	push	r12
    5c62:	df 92       	push	r13
    5c64:	ef 92       	push	r14
    5c66:	ff 92       	push	r15
    5c68:	0f 93       	push	r16
    5c6a:	1f 93       	push	r17
    5c6c:	df 93       	push	r29
    5c6e:	cf 93       	push	r28
    5c70:	cd b7       	in	r28, 0x3d	; 61
    5c72:	de b7       	in	r29, 0x3e	; 62
    5c74:	c0 5b       	subi	r28, 0xB0	; 176
    5c76:	d0 40       	sbci	r29, 0x00	; 0
    5c78:	0f b6       	in	r0, 0x3f	; 63
    5c7a:	f8 94       	cli
    5c7c:	de bf       	out	0x3e, r29	; 62
    5c7e:	0f be       	out	0x3f, r0	; 63
    5c80:	cd bf       	out	0x3d, r28	; 61
    5c82:	e8 2e       	mov	r14, r24
    5c84:	fe 01       	movw	r30, r28
    5c86:	37 96       	adiw	r30, 0x07	; 7

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    5c88:	ce 01       	movw	r24, r28
    5c8a:	46 96       	adiw	r24, 0x16	; 22
	     strMemory[i]=data;
    5c8c:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    5c8e:	e8 17       	cp	r30, r24
    5c90:	f9 07       	cpc	r31, r25
    5c92:	e1 f7       	brne	.-8      	; 0x5c8c <GeniusSendLastTransaction+0x40>
	     strMemory[i]=data;
    5c94:	ce 01       	movw	r24, r28
    5c96:	85 96       	adiw	r24, 0x25	; 37
    5c98:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    5c9a:	e8 17       	cp	r30, r24
    5c9c:	f9 07       	cpc	r31, r25
    5c9e:	e1 f7       	brne	.-8      	; 0x5c98 <GeniusSendLastTransaction+0x4c>
	     strMemory[i]=data;
    5ca0:	ce 01       	movw	r24, r28
    5ca2:	c4 96       	adiw	r24, 0x34	; 52
    5ca4:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    5ca6:	e8 17       	cp	r30, r24
    5ca8:	f9 07       	cpc	r31, r25
    5caa:	e1 f7       	brne	.-8      	; 0x5ca4 <GeniusSendLastTransaction+0x58>
	     strMemory[i]=data;
    5cac:	cf 01       	movw	r24, r30
    5cae:	3f 01       	movw	r6, r30
    5cb0:	0f 96       	adiw	r24, 0x0f	; 15
    5cb2:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    5cb4:	e8 17       	cp	r30, r24
    5cb6:	f9 07       	cpc	r31, r25
    5cb8:	e1 f7       	brne	.-8      	; 0x5cb2 <GeniusSendLastTransaction+0x66>
	 FillChar(STotalVolume,sizeof(STotalVolume),0);
	 FillChar(STotalMoney,sizeof(STotalMoney),0);
	      

	 //Generate
	 FIPAddr=GetFIPAddr(iPumpID);
    5cba:	8e 2d       	mov	r24, r14
    5cbc:	0e 94 41 1d 	call	0x3a82	; 0x3a82 <GetFIPAddr>
    5cc0:	96 e0       	ldi	r25, 0x06	; 6
    5cc2:	89 9f       	mul	r24, r25
    5cc4:	b0 01       	movw	r22, r0
    5cc6:	11 24       	eor	r1, r1
    5cc8:	61 5b       	subi	r22, 0xB1	; 177
    5cca:	7f 4f       	sbci	r23, 0xFF	; 255
    5ccc:	8e 01       	movw	r16, r28
    5cce:	0f 5f       	subi	r16, 0xFF	; 255
    5cd0:	1f 4f       	sbci	r17, 0xFF	; 255
    5cd2:	c8 01       	movw	r24, r16
    5cd4:	46 e0       	ldi	r20, 0x06	; 6
    5cd6:	50 e0       	ldi	r21, 0x00	; 0
    5cd8:	2d ef       	ldi	r18, 0xFD	; 253
    5cda:	32 e1       	ldi	r19, 0x12	; 18
    5cdc:	0e 94 f1 b3 	call	0x167e2	; 0x167e2 <__eerd_block>
     eeprom_read_block((void*) &PProductID, (const void*) &DefNozzleMap[FIPAddr-1], 6);
	 iNozzle=RecPumpData[iPumpID&0x0F].Grade;
    5ce0:	2e 2c       	mov	r2, r14
    5ce2:	33 24       	eor	r3, r3
    5ce4:	91 01       	movw	r18, r2
    5ce6:	2f 70       	andi	r18, 0x0F	; 15
    5ce8:	30 70       	andi	r19, 0x00	; 0
    5cea:	85 e3       	ldi	r24, 0x35	; 53
    5cec:	90 e0       	ldi	r25, 0x00	; 0
    5cee:	28 9f       	mul	r18, r24
    5cf0:	f0 01       	movw	r30, r0
    5cf2:	29 9f       	mul	r18, r25
    5cf4:	f0 0d       	add	r31, r0
    5cf6:	38 9f       	mul	r19, r24
    5cf8:	f0 0d       	add	r31, r0
    5cfa:	11 24       	eor	r1, r1
    5cfc:	e6 54       	subi	r30, 0x46	; 70
    5cfe:	f9 4f       	sbci	r31, 0xF9	; 249
    5d00:	f0 80       	ld	r15, Z
	 iProdID=PProductID[iNozzle];
    5d02:	4f 2c       	mov	r4, r15
    5d04:	55 24       	eor	r5, r5

	 GetProductName(iProdID,strProduct);
    5d06:	04 0d       	add	r16, r4
    5d08:	15 1d       	adc	r17, r5
    5d0a:	d8 01       	movw	r26, r16
    5d0c:	8c 91       	ld	r24, X
    5d0e:	60 e7       	ldi	r22, 0x70	; 112
    5d10:	78 e0       	ldi	r23, 0x08	; 8
    5d12:	0e 94 bb 2d 	call	0x5b76	; 0x5b76 <GetProductName>
	 GetTransactionVolume(iPumpID,SVolume);
    5d16:	67 e0       	ldi	r22, 0x07	; 7
    5d18:	86 2e       	mov	r8, r22
    5d1a:	91 2c       	mov	r9, r1
    5d1c:	8c 0e       	add	r8, r28
    5d1e:	9d 1e       	adc	r9, r29
    5d20:	8e 2d       	mov	r24, r14
    5d22:	b4 01       	movw	r22, r8
    5d24:	0e 94 72 27 	call	0x4ee4	; 0x4ee4 <GetTransactionVolume>
	 GetTransactionMoney(iPumpID,SMoney);
    5d28:	56 e1       	ldi	r21, 0x16	; 22
    5d2a:	a5 2e       	mov	r10, r21
    5d2c:	b1 2c       	mov	r11, r1
    5d2e:	ac 0e       	add	r10, r28
    5d30:	bd 1e       	adc	r11, r29
    5d32:	8e 2d       	mov	r24, r14
    5d34:	b5 01       	movw	r22, r10
    5d36:	0e 94 38 27 	call	0x4e70	; 0x4e70 <GetTransactionMoney>
	 GetTotalizerVolume(iPumpID,iNozzle,STotalVolume);
    5d3a:	45 e2       	ldi	r20, 0x25	; 37
    5d3c:	c4 2e       	mov	r12, r20
    5d3e:	d1 2c       	mov	r13, r1
    5d40:	cc 0e       	add	r12, r28
    5d42:	dd 1e       	adc	r13, r29
    5d44:	8e 2d       	mov	r24, r14
    5d46:	6f 2d       	mov	r22, r15
    5d48:	a6 01       	movw	r20, r12
    5d4a:	0e 94 1b 27 	call	0x4e36	; 0x4e36 <GetTotalizerVolume>
	 GetTotalizerMoney(iPumpID,iNozzle,STotalMoney);
    5d4e:	8e 2d       	mov	r24, r14
    5d50:	6f 2d       	mov	r22, r15
    5d52:	a3 01       	movw	r20, r6
    5d54:	0e 94 fe 26 	call	0x4dfc	; 0x4dfc <GetTotalizerMoney>
	 
     ComposeDatetime(SDatetime);
    5d58:	33 e4       	ldi	r19, 0x43	; 67
    5d5a:	e3 2e       	mov	r14, r19
    5d5c:	f1 2c       	mov	r15, r1
    5d5e:	ec 0e       	add	r14, r28
    5d60:	fd 1e       	adc	r15, r29
    5d62:	c7 01       	movw	r24, r14
    5d64:	0e 94 b3 1a 	call	0x3566	; 0x3566 <ComposeDatetime>

	 //Compose
	 sprintf_P(strSend,PSTR("T%.2d%.2d%s%s%s%s%s%s:"),iPumpID,iNozzle,strProduct,SDatetime,SVolume,SMoney,STotalVolume,STotalMoney);
    5d68:	ed b7       	in	r30, 0x3d	; 61
    5d6a:	fe b7       	in	r31, 0x3e	; 62
    5d6c:	74 97       	sbiw	r30, 0x14	; 20
    5d6e:	0f b6       	in	r0, 0x3f	; 63
    5d70:	f8 94       	cli
    5d72:	fe bf       	out	0x3e, r31	; 62
    5d74:	0f be       	out	0x3f, r0	; 63
    5d76:	ed bf       	out	0x3d, r30	; 61
    5d78:	31 96       	adiw	r30, 0x01	; 1
    5d7a:	8e 01       	movw	r16, r28
    5d7c:	09 5a       	subi	r16, 0xA9	; 169
    5d7e:	1f 4f       	sbci	r17, 0xFF	; 255
    5d80:	ad b7       	in	r26, 0x3d	; 61
    5d82:	be b7       	in	r27, 0x3e	; 62
    5d84:	12 96       	adiw	r26, 0x02	; 2
    5d86:	1c 93       	st	X, r17
    5d88:	0e 93       	st	-X, r16
    5d8a:	11 97       	sbiw	r26, 0x01	; 1
    5d8c:	89 e0       	ldi	r24, 0x09	; 9
    5d8e:	93 e0       	ldi	r25, 0x03	; 3
    5d90:	93 83       	std	Z+3, r25	; 0x03
    5d92:	82 83       	std	Z+2, r24	; 0x02
    5d94:	35 82       	std	Z+5, r3	; 0x05
    5d96:	24 82       	std	Z+4, r2	; 0x04
    5d98:	57 82       	std	Z+7, r5	; 0x07
    5d9a:	46 82       	std	Z+6, r4	; 0x06
    5d9c:	80 e7       	ldi	r24, 0x70	; 112
    5d9e:	98 e0       	ldi	r25, 0x08	; 8
    5da0:	91 87       	std	Z+9, r25	; 0x09
    5da2:	80 87       	std	Z+8, r24	; 0x08
    5da4:	f3 86       	std	Z+11, r15	; 0x0b
    5da6:	e2 86       	std	Z+10, r14	; 0x0a
    5da8:	95 86       	std	Z+13, r9	; 0x0d
    5daa:	84 86       	std	Z+12, r8	; 0x0c
    5dac:	b7 86       	std	Z+15, r11	; 0x0f
    5dae:	a6 86       	std	Z+14, r10	; 0x0e
    5db0:	d1 8a       	std	Z+17, r13	; 0x11
    5db2:	c0 8a       	std	Z+16, r12	; 0x10
    5db4:	62 8a       	std	Z+18, r6	; 0x12
    5db6:	73 8a       	std	Z+19, r7	; 0x13
    5db8:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
	 cSum=SumChecksum(strSend);
    5dbc:	ad b7       	in	r26, 0x3d	; 61
    5dbe:	be b7       	in	r27, 0x3e	; 62
    5dc0:	54 96       	adiw	r26, 0x14	; 20
    5dc2:	0f b6       	in	r0, 0x3f	; 63
    5dc4:	f8 94       	cli
    5dc6:	be bf       	out	0x3e, r27	; 62
    5dc8:	0f be       	out	0x3f, r0	; 63
    5dca:	ad bf       	out	0x3d, r26	; 61
    5dcc:	c8 01       	movw	r24, r16
    5dce:	0e 94 4d 21 	call	0x429a	; 0x429a <SumChecksum>
    5dd2:	e8 2e       	mov	r14, r24
	 _uart_print(1,0,strSend);
    5dd4:	81 e0       	ldi	r24, 0x01	; 1
    5dd6:	60 e0       	ldi	r22, 0x00	; 0
    5dd8:	a8 01       	movw	r20, r16
    5dda:	0e 94 70 b2 	call	0x164e0	; 0x164e0 <_uart_print>
    5dde:	f8 01       	movw	r30, r16

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    5de0:	c8 01       	movw	r24, r16
    5de2:	f9 2e       	mov	r15, r25
    5de4:	ce 01       	movw	r24, r28
    5de6:	8f 54       	subi	r24, 0x4F	; 79
    5de8:	9f 4f       	sbci	r25, 0xFF	; 255
	     strMemory[i]=data;
    5dea:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    5dec:	e8 17       	cp	r30, r24
    5dee:	f9 07       	cpc	r31, r25
    5df0:	e1 f7       	brne	.-8      	; 0x5dea <GeniusSendLastTransaction+0x19e>
	 //Compose
	 sprintf_P(strSend,PSTR("T%.2d%.2d%s%s%s%s%s%s:"),iPumpID,iNozzle,strProduct,SDatetime,SVolume,SMoney,STotalVolume,STotalMoney);
	 cSum=SumChecksum(strSend);
	 _uart_print(1,0,strSend);
	 FillChar(strSend,sizeof(strSend),0);      
	 sprintf_P(strSend,PSTR("%d"),cSum);
    5df2:	00 d0       	rcall	.+0      	; 0x5df4 <GeniusSendLastTransaction+0x1a8>
    5df4:	00 d0       	rcall	.+0      	; 0x5df6 <GeniusSendLastTransaction+0x1aa>
    5df6:	00 d0       	rcall	.+0      	; 0x5df8 <GeniusSendLastTransaction+0x1ac>
    5df8:	ed b7       	in	r30, 0x3d	; 61
    5dfa:	fe b7       	in	r31, 0x3e	; 62
    5dfc:	31 96       	adiw	r30, 0x01	; 1
    5dfe:	ad b7       	in	r26, 0x3d	; 61
    5e00:	be b7       	in	r27, 0x3e	; 62
    5e02:	11 96       	adiw	r26, 0x01	; 1
    5e04:	0c 93       	st	X, r16
    5e06:	11 97       	sbiw	r26, 0x01	; 1
    5e08:	12 96       	adiw	r26, 0x02	; 2
    5e0a:	fc 92       	st	X, r15
    5e0c:	86 e0       	ldi	r24, 0x06	; 6
    5e0e:	93 e0       	ldi	r25, 0x03	; 3
    5e10:	93 83       	std	Z+3, r25	; 0x03
    5e12:	82 83       	std	Z+2, r24	; 0x02
    5e14:	e4 82       	std	Z+4, r14	; 0x04
    5e16:	15 82       	std	Z+5, r1	; 0x05
    5e18:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
	 _uart_print(1,1,strSend);	 
    5e1c:	ed b7       	in	r30, 0x3d	; 61
    5e1e:	fe b7       	in	r31, 0x3e	; 62
    5e20:	36 96       	adiw	r30, 0x06	; 6
    5e22:	0f b6       	in	r0, 0x3f	; 63
    5e24:	f8 94       	cli
    5e26:	fe bf       	out	0x3e, r31	; 62
    5e28:	0f be       	out	0x3f, r0	; 63
    5e2a:	ed bf       	out	0x3d, r30	; 61
    5e2c:	81 e0       	ldi	r24, 0x01	; 1
    5e2e:	61 e0       	ldi	r22, 0x01	; 1
    5e30:	40 2f       	mov	r20, r16
    5e32:	5f 2d       	mov	r21, r15
    5e34:	0e 94 70 b2 	call	0x164e0	; 0x164e0 <_uart_print>
}
    5e38:	c0 55       	subi	r28, 0x50	; 80
    5e3a:	df 4f       	sbci	r29, 0xFF	; 255
    5e3c:	0f b6       	in	r0, 0x3f	; 63
    5e3e:	f8 94       	cli
    5e40:	de bf       	out	0x3e, r29	; 62
    5e42:	0f be       	out	0x3f, r0	; 63
    5e44:	cd bf       	out	0x3d, r28	; 61
    5e46:	cf 91       	pop	r28
    5e48:	df 91       	pop	r29
    5e4a:	1f 91       	pop	r17
    5e4c:	0f 91       	pop	r16
    5e4e:	ff 90       	pop	r15
    5e50:	ef 90       	pop	r14
    5e52:	df 90       	pop	r13
    5e54:	cf 90       	pop	r12
    5e56:	bf 90       	pop	r11
    5e58:	af 90       	pop	r10
    5e5a:	9f 90       	pop	r9
    5e5c:	8f 90       	pop	r8
    5e5e:	7f 90       	pop	r7
    5e60:	6f 90       	pop	r6
    5e62:	5f 90       	pop	r5
    5e64:	4f 90       	pop	r4
    5e66:	3f 90       	pop	r3
    5e68:	2f 90       	pop	r2
    5e6a:	08 95       	ret

00005e6c <systemGeniusProtocol>:

void systemGeniusProtocol(){
static char stGeniusProtocol=gpInitScan;
static char iPumpID;
	 
	 switch(stGeniusProtocol){
    5e6c:	80 91 c2 01 	lds	r24, 0x01C2
    5e70:	83 30       	cpi	r24, 0x03	; 3
    5e72:	61 f1       	breq	.+88     	; 0x5ecc <systemGeniusProtocol+0x60>
    5e74:	84 30       	cpi	r24, 0x04	; 4
    5e76:	28 f4       	brcc	.+10     	; 0x5e82 <systemGeniusProtocol+0x16>
    5e78:	81 30       	cpi	r24, 0x01	; 1
    5e7a:	81 f0       	breq	.+32     	; 0x5e9c <systemGeniusProtocol+0x30>
    5e7c:	82 30       	cpi	r24, 0x02	; 2
    5e7e:	c0 f4       	brcc	.+48     	; 0x5eb0 <systemGeniusProtocol+0x44>
    5e80:	09 c0       	rjmp	.+18     	; 0x5e94 <systemGeniusProtocol+0x28>
    5e82:	85 30       	cpi	r24, 0x05	; 5
    5e84:	09 f4       	brne	.+2      	; 0x5e88 <systemGeniusProtocol+0x1c>
    5e86:	43 c0       	rjmp	.+134    	; 0x5f0e <systemGeniusProtocol+0xa2>
    5e88:	85 30       	cpi	r24, 0x05	; 5
    5e8a:	a0 f1       	brcs	.+104    	; 0x5ef4 <systemGeniusProtocol+0x88>
    5e8c:	86 30       	cpi	r24, 0x06	; 6
    5e8e:	09 f0       	breq	.+2      	; 0x5e92 <systemGeniusProtocol+0x26>
    5e90:	58 c0       	rjmp	.+176    	; 0x5f42 <systemGeniusProtocol+0xd6>
    5e92:	45 c0       	rjmp	.+138    	; 0x5f1e <systemGeniusProtocol+0xb2>
	 case gpInitScan:
	      iPumpID=1;
    5e94:	81 e0       	ldi	r24, 0x01	; 1
    5e96:	80 93 c1 01 	sts	0x01C1, r24
    5e9a:	3e c0       	rjmp	.+124    	; 0x5f18 <systemGeniusProtocol+0xac>
          stGeniusProtocol=gpScanNewTransaction;
	      break;
	 case gpScanNewTransaction:
	      if (GetIncomingTransStatus(PumpID)==TS_NEW){
    5e9c:	80 91 c0 01 	lds	r24, 0x01C0
    5ea0:	0e 94 43 1a 	call	0x3486	; 0x3486 <GetIncomingTransStatus>
    5ea4:	82 30       	cpi	r24, 0x02	; 2
    5ea6:	09 f0       	breq	.+2      	; 0x5eaa <systemGeniusProtocol+0x3e>
    5ea8:	4c c0       	rjmp	.+152    	; 0x5f42 <systemGeniusProtocol+0xd6>
		      IsTotalizerReceived=False;
    5eaa:	10 92 b1 01 	sts	0x01B1, r1
    5eae:	34 c0       	rjmp	.+104    	; 0x5f18 <systemGeniusProtocol+0xac>
		      stGeniusProtocol=gpRequestTotalizer;
		  }
	      break;
     case gpRequestTotalizer:
	      SendPoolingCommand(SC_TOTALIZER,iPumpID);
    5eb0:	90 91 c1 01 	lds	r25, 0x01C1
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    5eb4:	85 e0       	ldi	r24, 0x05	; 5
    5eb6:	80 93 b9 06 	sts	0x06B9, r24
	 PoolMsg=plMsg;
    5eba:	90 93 0a 0d 	sts	0x0D0A, r25
     IsControlPooling=True;
    5ebe:	81 e0       	ldi	r24, 0x01	; 1
    5ec0:	80 93 87 01 	sts	0x0187, r24
		      stGeniusProtocol=gpRequestTotalizer;
		  }
	      break;
     case gpRequestTotalizer:
	      SendPoolingCommand(SC_TOTALIZER,iPumpID);
		  TimSend=0;
    5ec4:	10 92 af 0d 	sts	0x0DAF, r1
		  stGeniusProtocol=gpWaitRequestedTotalizer;
    5ec8:	83 e0       	ldi	r24, 0x03	; 3
    5eca:	26 c0       	rjmp	.+76     	; 0x5f18 <systemGeniusProtocol+0xac>
	      break;
     case gpWaitRequestedTotalizer:
	      if ((IsTotalizerReceived==True)&&(AcknoledgePump==iPumpID)){
    5ecc:	80 91 b1 01 	lds	r24, 0x01B1
    5ed0:	81 30       	cpi	r24, 0x01	; 1
    5ed2:	59 f4       	brne	.+22     	; 0x5eea <systemGeniusProtocol+0x7e>
    5ed4:	90 91 23 0d 	lds	r25, 0x0D23
    5ed8:	80 91 c1 01 	lds	r24, 0x01C1
    5edc:	98 17       	cp	r25, r24
    5ede:	29 f4       	brne	.+10     	; 0x5eea <systemGeniusProtocol+0x7e>
		      IsTotalizerReceived=False;
    5ee0:	10 92 b1 01 	sts	0x01B1, r1
			  stGeniusProtocol=gpSendTransactionData;
    5ee4:	84 e0       	ldi	r24, 0x04	; 4
    5ee6:	80 93 c2 01 	sts	0x01C2, r24
		  }
	      if (TimSend>TIM_SEND*2)stGeniusProtocol=gpNextPumpScan;
    5eea:	80 91 af 0d 	lds	r24, 0x0DAF
    5eee:	85 31       	cpi	r24, 0x15	; 21
    5ef0:	40 f1       	brcs	.+80     	; 0x5f42 <systemGeniusProtocol+0xd6>
    5ef2:	11 c0       	rjmp	.+34     	; 0x5f16 <systemGeniusProtocol+0xaa>
	      break;
     case gpSendTransactionData:
          GeniusSendLastTransaction(iPumpID);
    5ef4:	80 91 c1 01 	lds	r24, 0x01C1
    5ef8:	0e 94 26 2e 	call	0x5c4c	; 0x5c4c <GeniusSendLastTransaction>
		  SetIncomingTransStatus(iPumpID,TS_OLD);
    5efc:	80 91 c1 01 	lds	r24, 0x01C1
    5f00:	63 e0       	ldi	r22, 0x03	; 3
    5f02:	0e 94 11 1a 	call	0x3422	; 0x3422 <SetIncomingTransStatus>
		  
		  TimSend=0;
    5f06:	10 92 af 0d 	sts	0x0DAF, r1
          stGeniusProtocol=gpDelayNextPumpScan;
    5f0a:	85 e0       	ldi	r24, 0x05	; 5
    5f0c:	05 c0       	rjmp	.+10     	; 0x5f18 <systemGeniusProtocol+0xac>
	      break;
     case gpDelayNextPumpScan:
          if (TimSend>1)stGeniusProtocol=gpNextPumpScan;
    5f0e:	80 91 af 0d 	lds	r24, 0x0DAF
    5f12:	82 30       	cpi	r24, 0x02	; 2
    5f14:	b0 f0       	brcs	.+44     	; 0x5f42 <systemGeniusProtocol+0xd6>
    5f16:	86 e0       	ldi	r24, 0x06	; 6
    5f18:	80 93 c2 01 	sts	0x01C2, r24
    5f1c:	08 95       	ret
	      break;
     case gpNextPumpScan:
          if (iPumpID<=eeprom_read_byte(&DefPoolingPumpMax)){
    5f1e:	20 91 c1 01 	lds	r18, 0x01C1
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    5f22:	e1 99       	sbic	0x1c, 1	; 28
    5f24:	fe cf       	rjmp	.-4      	; 0x5f22 <systemGeniusProtocol+0xb6>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    5f26:	84 e4       	ldi	r24, 0x44	; 68
    5f28:	91 e0       	ldi	r25, 0x01	; 1
    5f2a:	9f bb       	out	0x1f, r25	; 31
    5f2c:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    5f2e:	e0 9a       	sbi	0x1c, 0	; 28
    5f30:	8d b3       	in	r24, 0x1d	; 29
    5f32:	82 17       	cp	r24, r18
    5f34:	30 f0       	brcs	.+12     	; 0x5f42 <systemGeniusProtocol+0xd6>
		      iPumpID++;
    5f36:	2f 5f       	subi	r18, 0xFF	; 255
    5f38:	20 93 c1 01 	sts	0x01C1, r18
              stGeniusProtocol=gpScanNewTransaction;
    5f3c:	81 e0       	ldi	r24, 0x01	; 1
    5f3e:	80 93 c2 01 	sts	0x01C2, r24
    5f42:	08 95       	ret

00005f44 <StrAlignCenter>:
	 }
	 //replace
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrAlignCenter(char *Source, unsigned int Length){
    5f44:	ef 92       	push	r14
    5f46:	ff 92       	push	r15
    5f48:	0f 93       	push	r16
    5f4a:	1f 93       	push	r17
    5f4c:	18 2f       	mov	r17, r24
    5f4e:	09 2f       	mov	r16, r25
    5f50:	7b 01       	movw	r14, r22
char nAddedSpace,srcLength;
     RemSpaceLag(Source);
    5f52:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <RemSpaceLag>
	 RemSpaceLead(Source);
    5f56:	81 2f       	mov	r24, r17
    5f58:	90 2f       	mov	r25, r16
    5f5a:	0e 94 61 25 	call	0x4ac2	; 0x4ac2 <RemSpaceLead>
	 srcLength=strlen(Source);
    5f5e:	a1 2f       	mov	r26, r17
    5f60:	b0 2f       	mov	r27, r16
    5f62:	fd 01       	movw	r30, r26
    5f64:	01 90       	ld	r0, Z+
    5f66:	00 20       	and	r0, r0
    5f68:	e9 f7       	brne	.-6      	; 0x5f64 <StrAlignCenter+0x20>
    5f6a:	31 97       	sbiw	r30, 0x01	; 1
    5f6c:	e1 1b       	sub	r30, r17
     nAddedSpace=(Length-srcLength)/2;
     AddSpaceLead(Source,srcLength+nAddedSpace);
    5f6e:	c7 01       	movw	r24, r14
    5f70:	8e 1b       	sub	r24, r30
    5f72:	91 09       	sbc	r25, r1
    5f74:	96 95       	lsr	r25
    5f76:	87 95       	ror	r24
    5f78:	e8 0f       	add	r30, r24
    5f7a:	81 2f       	mov	r24, r17
    5f7c:	90 2f       	mov	r25, r16
    5f7e:	6e 2f       	mov	r22, r30
    5f80:	0e 94 39 2d 	call	0x5a72	; 0x5a72 <AddSpaceLead>
	 AddSpaceLag(Source,Length);
    5f84:	81 2f       	mov	r24, r17
    5f86:	90 2f       	mov	r25, r16
    5f88:	6e 2d       	mov	r22, r14
    5f8a:	0e 94 a0 2d 	call	0x5b40	; 0x5b40 <AddSpaceLag>
}
    5f8e:	1f 91       	pop	r17
    5f90:	0f 91       	pop	r16
    5f92:	ff 90       	pop	r15
    5f94:	ef 90       	pop	r14
    5f96:	08 95       	ret

00005f98 <AddCharLead>:
	 }String[Size]=0;
  }

}

void AddCharLead(char *String,char CharAdded,unsigned char Size){//
    5f98:	bf 92       	push	r11
    5f9a:	cf 92       	push	r12
    5f9c:	df 92       	push	r13
    5f9e:	ef 92       	push	r14
    5fa0:	ff 92       	push	r15
    5fa2:	0f 93       	push	r16
    5fa4:	1f 93       	push	r17
    5fa6:	df 93       	push	r29
    5fa8:	cf 93       	push	r28
    5faa:	cd b7       	in	r28, 0x3d	; 61
    5fac:	de b7       	in	r29, 0x3e	; 62
    5fae:	6e 97       	sbiw	r28, 0x1e	; 30
    5fb0:	0f b6       	in	r0, 0x3f	; 63
    5fb2:	f8 94       	cli
    5fb4:	de bf       	out	0x3e, r29	; 62
    5fb6:	0f be       	out	0x3f, r0	; 63
    5fb8:	cd bf       	out	0x3d, r28	; 61
    5fba:	8c 01       	movw	r16, r24
    5fbc:	e4 2e       	mov	r14, r20
     char i,Length,strAdded[30];
     Length=strlen(String);
    5fbe:	fc 01       	movw	r30, r24
    5fc0:	01 90       	ld	r0, Z+
    5fc2:	00 20       	and	r0, r0
    5fc4:	e9 f7       	brne	.-6      	; 0x5fc0 <AddCharLead+0x28>
    5fc6:	31 97       	sbiw	r30, 0x01	; 1
    5fc8:	2e 2f       	mov	r18, r30
    5fca:	28 1b       	sub	r18, r24

	 if (Size>Length){
    5fcc:	24 17       	cp	r18, r20
    5fce:	d0 f5       	brcc	.+116    	; 0x6044 <AddCharLead+0xac>
    5fd0:	ae 01       	movw	r20, r28
    5fd2:	4f 5f       	subi	r20, 0xFF	; 255
    5fd4:	5f 4f       	sbci	r21, 0xFF	; 255
    5fd6:	fa 01       	movw	r30, r20
	 }String[Size]=0;
  }

}

void AddCharLead(char *String,char CharAdded,unsigned char Size){//
    5fd8:	b4 2e       	mov	r11, r20
    5fda:	01 c0       	rjmp	.+2      	; 0x5fde <AddCharLead+0x46>
     char i,Length,strAdded[30];
     Length=strlen(String);

	 if (Size>Length){
         for(i=0;i<Size;i++){
	         strAdded[i]=CharAdded;
    5fdc:	61 93       	st	Z+, r22
void AddCharLead(char *String,char CharAdded,unsigned char Size){//
     char i,Length,strAdded[30];
     Length=strlen(String);

	 if (Size>Length){
         for(i=0;i<Size;i++){
    5fde:	8e 2f       	mov	r24, r30
    5fe0:	8b 19       	sub	r24, r11
    5fe2:	8e 15       	cp	r24, r14
    5fe4:	d8 f3       	brcs	.-10     	; 0x5fdc <AddCharLead+0x44>
	         strAdded[i]=CharAdded;
	     }strAdded[Size]=0;
    5fe6:	6e 2d       	mov	r22, r14
    5fe8:	70 e0       	ldi	r23, 0x00	; 0
    5fea:	ce 01       	movw	r24, r28
    5fec:	01 96       	adiw	r24, 0x01	; 1
    5fee:	fc 01       	movw	r30, r24
    5ff0:	e6 0f       	add	r30, r22
    5ff2:	f7 1f       	adc	r31, r23
    5ff4:	10 82       	st	Z, r1
	     //Copy
         for(i=(Size-Length);i<Size;i++){
    5ff6:	fe 2c       	mov	r15, r14
    5ff8:	f2 1a       	sub	r15, r18
    5ffa:	6c 01       	movw	r12, r24
	         strAdded[i]=String[i-(Size-Length)];
    5ffc:	30 e0       	ldi	r19, 0x00	; 0
    5ffe:	26 1b       	sub	r18, r22
    6000:	37 0b       	sbc	r19, r23
    6002:	0c c0       	rjmp	.+24     	; 0x601c <AddCharLead+0x84>
    6004:	ef 2d       	mov	r30, r15
    6006:	f0 e0       	ldi	r31, 0x00	; 0
    6008:	d6 01       	movw	r26, r12
    600a:	ae 0f       	add	r26, r30
    600c:	bf 1f       	adc	r27, r31
    600e:	e0 0f       	add	r30, r16
    6010:	f1 1f       	adc	r31, r17
    6012:	e2 0f       	add	r30, r18
    6014:	f3 1f       	adc	r31, r19
    6016:	80 81       	ld	r24, Z
    6018:	8c 93       	st	X, r24
	 if (Size>Length){
         for(i=0;i<Size;i++){
	         strAdded[i]=CharAdded;
	     }strAdded[Size]=0;
	     //Copy
         for(i=(Size-Length);i<Size;i++){
    601a:	f3 94       	inc	r15
    601c:	fe 14       	cp	r15, r14
    601e:	90 f3       	brcs	.-28     	; 0x6004 <AddCharLead+0x6c>
	         strAdded[i]=String[i-(Size-Length)];
	     }strAdded[Size]=0;
    6020:	6c 0d       	add	r22, r12
    6022:	7d 1d       	adc	r23, r13
    6024:	db 01       	movw	r26, r22
    6026:	1c 92       	st	X, r1
    6028:	f8 01       	movw	r30, r16
    602a:	04 c0       	rjmp	.+8      	; 0x6034 <AddCharLead+0x9c>
	     //Spaced
         for(i=0;i<Size;i++){
	         String[i]=strAdded[i];
    602c:	da 01       	movw	r26, r20
    602e:	8d 91       	ld	r24, X+
    6030:	ad 01       	movw	r20, r26
    6032:	81 93       	st	Z+, r24
	     //Copy
         for(i=(Size-Length);i<Size;i++){
	         strAdded[i]=String[i-(Size-Length)];
	     }strAdded[Size]=0;
	     //Spaced
         for(i=0;i<Size;i++){
    6034:	84 2f       	mov	r24, r20
    6036:	8b 19       	sub	r24, r11
    6038:	8e 15       	cp	r24, r14
    603a:	c0 f3       	brcs	.-16     	; 0x602c <AddCharLead+0x94>
	         String[i]=strAdded[i];
	     }String[Size]=0;
    603c:	0e 0d       	add	r16, r14
    603e:	11 1d       	adc	r17, r1
    6040:	f8 01       	movw	r30, r16
    6042:	10 82       	st	Z, r1
	 }
}
    6044:	6e 96       	adiw	r28, 0x1e	; 30
    6046:	0f b6       	in	r0, 0x3f	; 63
    6048:	f8 94       	cli
    604a:	de bf       	out	0x3e, r29	; 62
    604c:	0f be       	out	0x3f, r0	; 63
    604e:	cd bf       	out	0x3d, r28	; 61
    6050:	cf 91       	pop	r28
    6052:	df 91       	pop	r29
    6054:	1f 91       	pop	r17
    6056:	0f 91       	pop	r16
    6058:	ff 90       	pop	r15
    605a:	ef 90       	pop	r14
    605c:	df 90       	pop	r13
    605e:	cf 90       	pop	r12
    6060:	bf 90       	pop	r11
    6062:	08 95       	ret

00006064 <AddCharLag>:
    }
return Result;
}

//String Processing
void AddCharLag(char *String,char CharAdded,unsigned char Size){
    6064:	cf 93       	push	r28
    6066:	df 93       	push	r29
    6068:	ec 01       	movw	r28, r24
char i,Length;
     Length=strlen(String);
    606a:	dc 01       	movw	r26, r24
    606c:	0d 90       	ld	r0, X+
    606e:	00 20       	and	r0, r0
    6070:	e9 f7       	brne	.-6      	; 0x606c <AddCharLag+0x8>
    6072:	11 97       	sbiw	r26, 0x01	; 1
    6074:	a8 1b       	sub	r26, r24
    6076:	b9 0b       	sbc	r27, r25
  if (Length<Size){   
    6078:	a4 17       	cp	r26, r20
    607a:	58 f4       	brcc	.+22     	; 0x6092 <AddCharLag+0x2e>
    607c:	8a 2f       	mov	r24, r26
     for(i=Length;i<Size;i++){
	    String[i]=CharAdded;
    607e:	fe 01       	movw	r30, r28
    6080:	e8 0f       	add	r30, r24
    6082:	f1 1d       	adc	r31, r1
    6084:	60 83       	st	Z, r22
//String Processing
void AddCharLag(char *String,char CharAdded,unsigned char Size){
char i,Length;
     Length=strlen(String);
  if (Length<Size){   
     for(i=Length;i<Size;i++){
    6086:	8f 5f       	subi	r24, 0xFF	; 255
    6088:	84 17       	cp	r24, r20
    608a:	c8 f3       	brcs	.-14     	; 0x607e <AddCharLag+0x1a>
	    String[i]=CharAdded;
	 }String[Size]=0;
    608c:	c4 0f       	add	r28, r20
    608e:	d1 1d       	adc	r29, r1
    6090:	18 82       	st	Y, r1
  }

}
    6092:	df 91       	pop	r29
    6094:	cf 91       	pop	r28
    6096:	08 95       	ret

00006098 <CountTotalizerSatus>:
		      Result++;		  
		  }	 
	 }
  return Result;
}
char CountTotalizerSatus(char *strPumpStatusTotalizer){
    6098:	cf 92       	push	r12
    609a:	df 92       	push	r13
    609c:	ef 92       	push	r14
    609e:	ff 92       	push	r15
    60a0:	0f 93       	push	r16
    60a2:	1f 93       	push	r17
    60a4:	cf 93       	push	r28
    60a6:	df 93       	push	r29
    60a8:	7c 01       	movw	r14, r24
char i,Result;
     Result=0;
	 for (i=0;i<strlen(strPumpStatusTotalizer);i++){
    60aa:	dc 01       	movw	r26, r24
    60ac:	0d 90       	ld	r0, X+
    60ae:	00 20       	and	r0, r0
    60b0:	e9 f7       	brne	.-6      	; 0x60ac <CountTotalizerSatus+0x14>
    60b2:	8d 01       	movw	r16, r26
    60b4:	01 50       	subi	r16, 0x01	; 1
    60b6:	10 40       	sbci	r17, 0x00	; 0
    60b8:	08 1b       	sub	r16, r24
    60ba:	19 0b       	sbc	r17, r25
    60bc:	cc 24       	eor	r12, r12
    60be:	dd 24       	eor	r13, r13
    60c0:	0a c0       	rjmp	.+20     	; 0x60d6 <CountTotalizerSatus+0x3e>
	      if (strPumpStatusTotalizer[i]==GetPumpStatusLabel(PS_TOTALIZER)){
    60c2:	84 e1       	ldi	r24, 0x14	; 20
    60c4:	0e 94 7d 13 	call	0x26fa	; 0x26fa <GetPumpStatusLabel>
    60c8:	ce 0d       	add	r28, r14
    60ca:	df 1d       	adc	r29, r15
    60cc:	98 81       	ld	r25, Y
    60ce:	98 17       	cp	r25, r24
    60d0:	09 f4       	brne	.+2      	; 0x60d4 <CountTotalizerSatus+0x3c>
		      Result++;		  
    60d2:	d3 94       	inc	r13
  return Result;
}
char CountTotalizerSatus(char *strPumpStatusTotalizer){
char i,Result;
     Result=0;
	 for (i=0;i<strlen(strPumpStatusTotalizer);i++){
    60d4:	c3 94       	inc	r12
    60d6:	cc 2d       	mov	r28, r12
    60d8:	d0 e0       	ldi	r29, 0x00	; 0
    60da:	c0 17       	cp	r28, r16
    60dc:	d1 07       	cpc	r29, r17
    60de:	88 f3       	brcs	.-30     	; 0x60c2 <CountTotalizerSatus+0x2a>
	      if (strPumpStatusTotalizer[i]==GetPumpStatusLabel(PS_TOTALIZER)){
		      Result++;		  
		  }	 
	 }
  return Result;
}
    60e0:	8d 2d       	mov	r24, r13
    60e2:	df 91       	pop	r29
    60e4:	cf 91       	pop	r28
    60e6:	1f 91       	pop	r17
    60e8:	0f 91       	pop	r16
    60ea:	ff 90       	pop	r15
    60ec:	ef 90       	pop	r14
    60ee:	df 90       	pop	r13
    60f0:	cf 90       	pop	r12
    60f2:	08 95       	ret

000060f4 <RemoveChar>:
	   sprintf_P(strSend,PSTR("Wrap:%s"),strDestCode);
	   _uart_print(1,1,strSend);     
	 #endif
}

void RemoveChar(char *strSource, char cRem){
    60f4:	1f 93       	push	r17
    60f6:	df 93       	push	r29
    60f8:	cf 93       	push	r28
    60fa:	cd b7       	in	r28, 0x3d	; 61
    60fc:	de b7       	in	r29, 0x3e	; 62
    60fe:	64 97       	sbiw	r28, 0x14	; 20
    6100:	0f b6       	in	r0, 0x3f	; 63
    6102:	f8 94       	cli
    6104:	de bf       	out	0x3e, r29	; 62
    6106:	0f be       	out	0x3f, r0	; 63
    6108:	cd bf       	out	0x3d, r28	; 61
    610a:	16 2f       	mov	r17, r22
    610c:	50 e0       	ldi	r21, 0x00	; 0
    610e:	40 e0       	ldi	r20, 0x00	; 0
     char i,iAdd,sTemp[20];
     iAdd=0;
	 for(i=0;i<strlen(strSource);i++){
	     if (strSource[i]!=cRem){
		     sTemp[iAdd]=strSource[i];
    6110:	be 01       	movw	r22, r28
    6112:	6f 5f       	subi	r22, 0xFF	; 255
    6114:	7f 4f       	sbci	r23, 0xFF	; 255
    6116:	0c c0       	rjmp	.+24     	; 0x6130 <RemoveChar+0x3c>

void RemoveChar(char *strSource, char cRem){
     char i,iAdd,sTemp[20];
     iAdd=0;
	 for(i=0;i<strlen(strSource);i++){
	     if (strSource[i]!=cRem){
    6118:	28 0f       	add	r18, r24
    611a:	39 1f       	adc	r19, r25
    611c:	d9 01       	movw	r26, r18
    611e:	2c 91       	ld	r18, X
    6120:	21 17       	cp	r18, r17
    6122:	29 f0       	breq	.+10     	; 0x612e <RemoveChar+0x3a>
		     sTemp[iAdd]=strSource[i];
    6124:	fb 01       	movw	r30, r22
    6126:	e4 0f       	add	r30, r20
    6128:	f1 1d       	adc	r31, r1
    612a:	20 83       	st	Z, r18
			 iAdd++;
    612c:	4f 5f       	subi	r20, 0xFF	; 255
}

void RemoveChar(char *strSource, char cRem){
     char i,iAdd,sTemp[20];
     iAdd=0;
	 for(i=0;i<strlen(strSource);i++){
    612e:	5f 5f       	subi	r21, 0xFF	; 255
    6130:	25 2f       	mov	r18, r21
    6132:	30 e0       	ldi	r19, 0x00	; 0
    6134:	fc 01       	movw	r30, r24
    6136:	01 90       	ld	r0, Z+
    6138:	00 20       	and	r0, r0
    613a:	e9 f7       	brne	.-6      	; 0x6136 <RemoveChar+0x42>
    613c:	31 97       	sbiw	r30, 0x01	; 1
    613e:	e8 1b       	sub	r30, r24
    6140:	f9 0b       	sbc	r31, r25
    6142:	2e 17       	cp	r18, r30
    6144:	3f 07       	cpc	r19, r31
    6146:	40 f3       	brcs	.-48     	; 0x6118 <RemoveChar+0x24>
	     if (strSource[i]!=cRem){
		     sTemp[iAdd]=strSource[i];
			 iAdd++;
          }
	 }sTemp[iAdd]=0;
    6148:	9e 01       	movw	r18, r28
    614a:	2f 5f       	subi	r18, 0xFF	; 255
    614c:	3f 4f       	sbci	r19, 0xFF	; 255
    614e:	f9 01       	movw	r30, r18
    6150:	e4 0f       	add	r30, r20
    6152:	f1 1d       	adc	r31, r1
    6154:	10 82       	st	Z, r1
	 sprintf_P(strSource,PSTR("%s"),sTemp);
    6156:	00 d0       	rcall	.+0      	; 0x6158 <RemoveChar+0x64>
    6158:	00 d0       	rcall	.+0      	; 0x615a <RemoveChar+0x66>
    615a:	00 d0       	rcall	.+0      	; 0x615c <RemoveChar+0x68>
    615c:	ed b7       	in	r30, 0x3d	; 61
    615e:	fe b7       	in	r31, 0x3e	; 62
    6160:	31 96       	adiw	r30, 0x01	; 1
    6162:	ad b7       	in	r26, 0x3d	; 61
    6164:	be b7       	in	r27, 0x3e	; 62
    6166:	12 96       	adiw	r26, 0x02	; 2
    6168:	9c 93       	st	X, r25
    616a:	8e 93       	st	-X, r24
    616c:	11 97       	sbiw	r26, 0x01	; 1
    616e:	8f ee       	ldi	r24, 0xEF	; 239
    6170:	97 e1       	ldi	r25, 0x17	; 23
    6172:	93 83       	std	Z+3, r25	; 0x03
    6174:	82 83       	std	Z+2, r24	; 0x02
    6176:	35 83       	std	Z+5, r19	; 0x05
    6178:	24 83       	std	Z+4, r18	; 0x04
    617a:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    617e:	ed b7       	in	r30, 0x3d	; 61
    6180:	fe b7       	in	r31, 0x3e	; 62
    6182:	36 96       	adiw	r30, 0x06	; 6
    6184:	0f b6       	in	r0, 0x3f	; 63
    6186:	f8 94       	cli
    6188:	fe bf       	out	0x3e, r31	; 62
    618a:	0f be       	out	0x3f, r0	; 63
    618c:	ed bf       	out	0x3d, r30	; 61
}
    618e:	64 96       	adiw	r28, 0x14	; 20
    6190:	0f b6       	in	r0, 0x3f	; 63
    6192:	f8 94       	cli
    6194:	de bf       	out	0x3e, r29	; 62
    6196:	0f be       	out	0x3f, r0	; 63
    6198:	cd bf       	out	0x3d, r28	; 61
    619a:	cf 91       	pop	r28
    619c:	df 91       	pop	r29
    619e:	1f 91       	pop	r17
    61a0:	08 95       	ret

000061a2 <WrapCode>:
	      break;
	 }
   return Result;
}

void WrapCode(char *strRawCode){
    61a2:	8f 92       	push	r8
    61a4:	9f 92       	push	r9
    61a6:	bf 92       	push	r11
    61a8:	cf 92       	push	r12
    61aa:	df 92       	push	r13
    61ac:	ef 92       	push	r14
    61ae:	ff 92       	push	r15
    61b0:	0f 93       	push	r16
    61b2:	1f 93       	push	r17
    61b4:	df 93       	push	r29
    61b6:	cf 93       	push	r28
    61b8:	cd b7       	in	r28, 0x3d	; 61
    61ba:	de b7       	in	r29, 0x3e	; 62
    61bc:	2f 97       	sbiw	r28, 0x0f	; 15
    61be:	0f b6       	in	r0, 0x3f	; 63
    61c0:	f8 94       	cli
    61c2:	de bf       	out	0x3e, r29	; 62
    61c4:	0f be       	out	0x3f, r0	; 63
    61c6:	cd bf       	out	0x3d, r28	; 61
    61c8:	6c 01       	movw	r12, r24
    61ca:	bb 24       	eor	r11, r11
    61cc:	40 e0       	ldi	r20, 0x00	; 0
    61ce:	4e 01       	movw	r8, r28
    61d0:	08 94       	sec
    61d2:	81 1c       	adc	r8, r1
    61d4:	91 1c       	adc	r9, r1
    61d6:	12 c0       	rjmp	.+36     	; 0x61fc <WrapCode+0x5a>
     char i,seedKey;
	 char strTemp[15];
	 //62678677 ->68846445
	 seedKey=0;
	 for (i=0;i<strlen(strRawCode);i++){
	      strTemp[i]='0'+GeniusCalc(G_PLUS,(strRawCode[i]-'0'),seedKey);
    61d8:	86 01       	movw	r16, r12
    61da:	0e 0d       	add	r16, r14
    61dc:	1f 1d       	adc	r17, r15
    61de:	d8 01       	movw	r26, r16
    61e0:	6c 91       	ld	r22, X
    61e2:	60 53       	subi	r22, 0x30	; 48
    61e4:	80 e0       	ldi	r24, 0x00	; 0
    61e6:	0e 94 2c 16 	call	0x2c58	; 0x2c58 <GeniusCalc>
    61ea:	e8 0c       	add	r14, r8
    61ec:	f9 1c       	adc	r15, r9
    61ee:	80 5d       	subi	r24, 0xD0	; 208
    61f0:	f7 01       	movw	r30, r14
    61f2:	80 83       	st	Z, r24
		  seedKey=strRawCode[i]-'0';
    61f4:	d8 01       	movw	r26, r16
    61f6:	4c 91       	ld	r20, X
    61f8:	40 53       	subi	r20, 0x30	; 48
void WrapCode(char *strRawCode){
     char i,seedKey;
	 char strTemp[15];
	 //62678677 ->68846445
	 seedKey=0;
	 for (i=0;i<strlen(strRawCode);i++){
    61fa:	b3 94       	inc	r11
    61fc:	eb 2c       	mov	r14, r11
    61fe:	ff 24       	eor	r15, r15
    6200:	d6 01       	movw	r26, r12
    6202:	0d 90       	ld	r0, X+
    6204:	00 20       	and	r0, r0
    6206:	e9 f7       	brne	.-6      	; 0x6202 <WrapCode+0x60>
    6208:	11 97       	sbiw	r26, 0x01	; 1
    620a:	ac 19       	sub	r26, r12
    620c:	bd 09       	sbc	r27, r13
    620e:	ea 16       	cp	r14, r26
    6210:	fb 06       	cpc	r15, r27
    6212:	10 f3       	brcs	.-60     	; 0x61d8 <WrapCode+0x36>
	      strTemp[i]='0'+GeniusCalc(G_PLUS,(strRawCode[i]-'0'),seedKey);
		  seedKey=strRawCode[i]-'0';
	 }strTemp[strlen(strRawCode)]=0;
    6214:	a8 0d       	add	r26, r8
    6216:	b9 1d       	adc	r27, r9
    6218:	1c 92       	st	X, r1
     sprintf_P(strRawCode,PSTR("%s"),strTemp);
    621a:	00 d0       	rcall	.+0      	; 0x621c <WrapCode+0x7a>
    621c:	00 d0       	rcall	.+0      	; 0x621e <WrapCode+0x7c>
    621e:	00 d0       	rcall	.+0      	; 0x6220 <WrapCode+0x7e>
    6220:	ed b7       	in	r30, 0x3d	; 61
    6222:	fe b7       	in	r31, 0x3e	; 62
    6224:	31 96       	adiw	r30, 0x01	; 1
    6226:	ad b7       	in	r26, 0x3d	; 61
    6228:	be b7       	in	r27, 0x3e	; 62
    622a:	12 96       	adiw	r26, 0x02	; 2
    622c:	dc 92       	st	X, r13
    622e:	ce 92       	st	-X, r12
    6230:	11 97       	sbiw	r26, 0x01	; 1
    6232:	8a ef       	ldi	r24, 0xFA	; 250
    6234:	97 e1       	ldi	r25, 0x17	; 23
    6236:	93 83       	std	Z+3, r25	; 0x03
    6238:	82 83       	std	Z+2, r24	; 0x02
    623a:	95 82       	std	Z+5, r9	; 0x05
    623c:	84 82       	std	Z+4, r8	; 0x04
    623e:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    6242:	ed b7       	in	r30, 0x3d	; 61
    6244:	fe b7       	in	r31, 0x3e	; 62
    6246:	36 96       	adiw	r30, 0x06	; 6
    6248:	0f b6       	in	r0, 0x3f	; 63
    624a:	f8 94       	cli
    624c:	fe bf       	out	0x3e, r31	; 62
    624e:	0f be       	out	0x3f, r0	; 63
    6250:	ed bf       	out	0x3d, r30	; 61
}
    6252:	2f 96       	adiw	r28, 0x0f	; 15
    6254:	0f b6       	in	r0, 0x3f	; 63
    6256:	f8 94       	cli
    6258:	de bf       	out	0x3e, r29	; 62
    625a:	0f be       	out	0x3f, r0	; 63
    625c:	cd bf       	out	0x3d, r28	; 61
    625e:	cf 91       	pop	r28
    6260:	df 91       	pop	r29
    6262:	1f 91       	pop	r17
    6264:	0f 91       	pop	r16
    6266:	ff 90       	pop	r15
    6268:	ef 90       	pop	r14
    626a:	df 90       	pop	r13
    626c:	cf 90       	pop	r12
    626e:	bf 90       	pop	r11
    6270:	9f 90       	pop	r9
    6272:	8f 90       	pop	r8
    6274:	08 95       	ret

00006276 <GenerateKeyStamp>:


   return Result;
}

void GenerateKeyStamp(char *sTime, char *sGCode, char *strKeyStamp){//
    6276:	8f 92       	push	r8
    6278:	9f 92       	push	r9
    627a:	af 92       	push	r10
    627c:	bf 92       	push	r11
    627e:	df 92       	push	r13
    6280:	ef 92       	push	r14
    6282:	ff 92       	push	r15
    6284:	0f 93       	push	r16
    6286:	1f 93       	push	r17
    6288:	df 93       	push	r29
    628a:	cf 93       	push	r28
    628c:	cd b7       	in	r28, 0x3d	; 61
    628e:	de b7       	in	r29, 0x3e	; 62
    6290:	2d 97       	sbiw	r28, 0x0d	; 13
    6292:	0f b6       	in	r0, 0x3f	; 63
    6294:	f8 94       	cli
    6296:	de bf       	out	0x3e, r29	; 62
    6298:	0f be       	out	0x3f, r0	; 63
    629a:	cd bf       	out	0x3d, r28	; 61
    629c:	9c 01       	movw	r18, r24
    629e:	7b 01       	movw	r14, r22
    62a0:	5a 01       	movw	r10, r20
	             65585577
	 */
     char seedIdx,sSeed[10],sAdd[3],i;
     
	 seedIdx=(sTime[5]-'0')%8; 
	 sAdd[0]=sGCode[seedIdx];
    62a2:	dc 01       	movw	r26, r24
    62a4:	15 96       	adiw	r26, 0x05	; 5
    62a6:	8c 91       	ld	r24, X
    62a8:	90 e0       	ldi	r25, 0x00	; 0
    62aa:	c0 97       	sbiw	r24, 0x30	; 48
    62ac:	68 e0       	ldi	r22, 0x08	; 8
    62ae:	70 e0       	ldi	r23, 0x00	; 0
    62b0:	0e 94 1e b7 	call	0x16e3c	; 0x16e3c <__divmodhi4>
    62b4:	f7 01       	movw	r30, r14
    62b6:	e8 0f       	add	r30, r24
    62b8:	f1 1d       	adc	r31, r1
    62ba:	80 81       	ld	r24, Z
    62bc:	89 83       	std	Y+1, r24	; 0x01
     seedIdx=(sTime[6]-'0')%8;
	 sAdd[1]=sGCode[seedIdx];
    62be:	f9 01       	movw	r30, r18
    62c0:	86 81       	ldd	r24, Z+6	; 0x06
    62c2:	90 e0       	ldi	r25, 0x00	; 0
    62c4:	c0 97       	sbiw	r24, 0x30	; 48
    62c6:	68 e0       	ldi	r22, 0x08	; 8
    62c8:	70 e0       	ldi	r23, 0x00	; 0
    62ca:	0e 94 1e b7 	call	0x16e3c	; 0x16e3c <__divmodhi4>
    62ce:	f7 01       	movw	r30, r14
    62d0:	e8 0f       	add	r30, r24
    62d2:	f1 1d       	adc	r31, r1
    62d4:	80 81       	ld	r24, Z
    62d6:	8a 83       	std	Y+2, r24	; 0x02
	 sAdd[2]=0;
    62d8:	1b 82       	std	Y+3, r1	; 0x03

	 sprintf_P(sSeed,PSTR("%s%s"),sTime,sAdd);
    62da:	8d b7       	in	r24, 0x3d	; 61
    62dc:	9e b7       	in	r25, 0x3e	; 62
    62de:	08 97       	sbiw	r24, 0x08	; 8
    62e0:	0f b6       	in	r0, 0x3f	; 63
    62e2:	f8 94       	cli
    62e4:	9e bf       	out	0x3e, r25	; 62
    62e6:	0f be       	out	0x3f, r0	; 63
    62e8:	8d bf       	out	0x3d, r24	; 61
    62ea:	ed b7       	in	r30, 0x3d	; 61
    62ec:	fe b7       	in	r31, 0x3e	; 62
    62ee:	31 96       	adiw	r30, 0x01	; 1
    62f0:	8e 01       	movw	r16, r28
    62f2:	0c 5f       	subi	r16, 0xFC	; 252
    62f4:	1f 4f       	sbci	r17, 0xFF	; 255
    62f6:	ad b7       	in	r26, 0x3d	; 61
    62f8:	be b7       	in	r27, 0x3e	; 62
    62fa:	12 96       	adiw	r26, 0x02	; 2
    62fc:	1c 93       	st	X, r17
    62fe:	0e 93       	st	-X, r16
    6300:	11 97       	sbiw	r26, 0x01	; 1
    6302:	8a ee       	ldi	r24, 0xEA	; 234
    6304:	97 e1       	ldi	r25, 0x17	; 23
    6306:	93 83       	std	Z+3, r25	; 0x03
    6308:	82 83       	std	Z+2, r24	; 0x02
    630a:	35 83       	std	Z+5, r19	; 0x05
    630c:	24 83       	std	Z+4, r18	; 0x04
    630e:	ce 01       	movw	r24, r28
    6310:	01 96       	adiw	r24, 0x01	; 1
    6312:	97 83       	std	Z+7, r25	; 0x07
    6314:	86 83       	std	Z+6, r24	; 0x06
    6316:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    631a:	dd 24       	eor	r13, r13
    631c:	ed b7       	in	r30, 0x3d	; 61
    631e:	fe b7       	in	r31, 0x3e	; 62
    6320:	38 96       	adiw	r30, 0x08	; 8
    6322:	0f b6       	in	r0, 0x3f	; 63
    6324:	f8 94       	cli
    6326:	fe bf       	out	0x3e, r31	; 62
    6328:	0f be       	out	0x3f, r0	; 63
    632a:	ed bf       	out	0x3d, r30	; 61
     for(i=0;i<strlen(sGCode);i++){
	     strKeyStamp[i]='0'+GeniusCalc(G_MULTY,(sSeed[i]-'0'),(sGCode[i]-'0'));		 
    632c:	48 01       	movw	r8, r16
    632e:	13 c0       	rjmp	.+38     	; 0x6356 <GenerateKeyStamp+0xe0>
    6330:	f4 01       	movw	r30, r8
    6332:	e0 0f       	add	r30, r16
    6334:	f1 1f       	adc	r31, r17
    6336:	60 81       	ld	r22, Z
    6338:	60 53       	subi	r22, 0x30	; 48
    633a:	f7 01       	movw	r30, r14
    633c:	e0 0f       	add	r30, r16
    633e:	f1 1f       	adc	r31, r17
    6340:	40 81       	ld	r20, Z
    6342:	40 53       	subi	r20, 0x30	; 48
    6344:	81 e0       	ldi	r24, 0x01	; 1
    6346:	0e 94 2c 16 	call	0x2c58	; 0x2c58 <GeniusCalc>
    634a:	0a 0d       	add	r16, r10
    634c:	1b 1d       	adc	r17, r11
    634e:	80 5d       	subi	r24, 0xD0	; 208
    6350:	d8 01       	movw	r26, r16
    6352:	8c 93       	st	X, r24
     seedIdx=(sTime[6]-'0')%8;
	 sAdd[1]=sGCode[seedIdx];
	 sAdd[2]=0;

	 sprintf_P(sSeed,PSTR("%s%s"),sTime,sAdd);
     for(i=0;i<strlen(sGCode);i++){
    6354:	d3 94       	inc	r13
    6356:	0d 2d       	mov	r16, r13
    6358:	10 e0       	ldi	r17, 0x00	; 0
    635a:	d7 01       	movw	r26, r14
    635c:	0d 90       	ld	r0, X+
    635e:	00 20       	and	r0, r0
    6360:	e9 f7       	brne	.-6      	; 0x635c <GenerateKeyStamp+0xe6>
    6362:	11 97       	sbiw	r26, 0x01	; 1
    6364:	ae 19       	sub	r26, r14
    6366:	bf 09       	sbc	r27, r15
    6368:	0a 17       	cp	r16, r26
    636a:	1b 07       	cpc	r17, r27
    636c:	08 f3       	brcs	.-62     	; 0x6330 <GenerateKeyStamp+0xba>
	     strKeyStamp[i]='0'+GeniusCalc(G_MULTY,(sSeed[i]-'0'),(sGCode[i]-'0'));		 
	 }strKeyStamp[strlen(sGCode)]=0;
    636e:	aa 0d       	add	r26, r10
    6370:	bb 1d       	adc	r27, r11
    6372:	1c 92       	st	X, r1
     WrapCode(strKeyStamp);
    6374:	c5 01       	movw	r24, r10
    6376:	0e 94 d1 30 	call	0x61a2	; 0x61a2 <WrapCode>
}
    637a:	2d 96       	adiw	r28, 0x0d	; 13
    637c:	0f b6       	in	r0, 0x3f	; 63
    637e:	f8 94       	cli
    6380:	de bf       	out	0x3e, r29	; 62
    6382:	0f be       	out	0x3f, r0	; 63
    6384:	cd bf       	out	0x3d, r28	; 61
    6386:	cf 91       	pop	r28
    6388:	df 91       	pop	r29
    638a:	1f 91       	pop	r17
    638c:	0f 91       	pop	r16
    638e:	ff 90       	pop	r15
    6390:	ef 90       	pop	r14
    6392:	df 90       	pop	r13
    6394:	bf 90       	pop	r11
    6396:	af 90       	pop	r10
    6398:	9f 90       	pop	r9
    639a:	8f 90       	pop	r8
    639c:	08 95       	ret

0000639e <GenerateGeniusCode>:
		  seedKey=strRawCode[i]-'0';
	 }strTemp[strlen(strRawCode)]=0;
     sprintf_P(strRawCode,PSTR("%s"),strTemp);
}

void GenerateGeniusCode(char *srcDate, char cSeed, char *strDestCode){
    639e:	af 92       	push	r10
    63a0:	bf 92       	push	r11
    63a2:	cf 92       	push	r12
    63a4:	df 92       	push	r13
    63a6:	ef 92       	push	r14
    63a8:	ff 92       	push	r15
    63aa:	0f 93       	push	r16
    63ac:	1f 93       	push	r17
    63ae:	df 93       	push	r29
    63b0:	cf 93       	push	r28
    63b2:	cd b7       	in	r28, 0x3d	; 61
    63b4:	de b7       	in	r29, 0x3e	; 62
    63b6:	28 97       	sbiw	r28, 0x08	; 8
    63b8:	0f b6       	in	r0, 0x3f	; 63
    63ba:	f8 94       	cli
    63bc:	de bf       	out	0x3e, r29	; 62
    63be:	0f be       	out	0x3f, r0	; 63
    63c0:	cd bf       	out	0x3d, r28	; 61
    63c2:	7c 01       	movw	r14, r24
    63c4:	c6 2e       	mov	r12, r22
    63c6:	5a 01       	movw	r10, r20
	    sprintf_P(strSend,PSTR("Date[%s]"),srcDate);
		_uart_print(1,1,strSend);
     #endif
    

	 StrPosCopy(srcDate,AddYear,strlen(srcDate)-2,2);
    63c8:	fc 01       	movw	r30, r24
    63ca:	01 90       	ld	r0, Z+
    63cc:	00 20       	and	r0, r0
    63ce:	e9 f7       	brne	.-6      	; 0x63ca <GenerateGeniusCode+0x2c>
    63d0:	e8 1b       	sub	r30, r24
    63d2:	f9 0b       	sbc	r31, r25
    63d4:	33 97       	sbiw	r30, 0x03	; 3
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    63d6:	e8 0f       	add	r30, r24
    63d8:	f9 1f       	adc	r31, r25
    63da:	80 81       	ld	r24, Z
    63dc:	89 83       	std	Y+1, r24	; 0x01
    63de:	81 81       	ldd	r24, Z+1	; 0x01
    63e0:	8a 83       	std	Y+2, r24	; 0x02
	 }Dest[Length]=0;
    63e2:	1b 82       	std	Y+3, r1	; 0x03
    #ifdef DEBUG_GENIUS_CODE
	    sprintf_P(strSend,PSTR("Year:[%s]"),AddYear);
		_uart_print(1,1,strSend);
     #endif

	 sprintf_P(SYear,PSTR("20%s"),AddYear);
    63e4:	00 d0       	rcall	.+0      	; 0x63e6 <GenerateGeniusCode+0x48>
    63e6:	00 d0       	rcall	.+0      	; 0x63e8 <GenerateGeniusCode+0x4a>
    63e8:	00 d0       	rcall	.+0      	; 0x63ea <GenerateGeniusCode+0x4c>
    63ea:	ed b7       	in	r30, 0x3d	; 61
    63ec:	fe b7       	in	r31, 0x3e	; 62
    63ee:	31 96       	adiw	r30, 0x01	; 1
    63f0:	8e 01       	movw	r16, r28
    63f2:	0c 5f       	subi	r16, 0xFC	; 252
    63f4:	1f 4f       	sbci	r17, 0xFF	; 255
    63f6:	ad b7       	in	r26, 0x3d	; 61
    63f8:	be b7       	in	r27, 0x3e	; 62
    63fa:	12 96       	adiw	r26, 0x02	; 2
    63fc:	1c 93       	st	X, r17
    63fe:	0e 93       	st	-X, r16
    6400:	11 97       	sbiw	r26, 0x01	; 1
    6402:	85 ef       	ldi	r24, 0xF5	; 245
    6404:	97 e1       	ldi	r25, 0x17	; 23
    6406:	93 83       	std	Z+3, r25	; 0x03
    6408:	82 83       	std	Z+2, r24	; 0x02
    640a:	ce 01       	movw	r24, r28
    640c:	01 96       	adiw	r24, 0x01	; 1
    640e:	95 83       	std	Z+5, r25	; 0x05
    6410:	84 83       	std	Z+4, r24	; 0x04
    6412:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
	 StrPosPaste(SYear,srcDate,strlen(srcDate)-2,strlen(SYear));
    6416:	d7 01       	movw	r26, r14
    6418:	0d 90       	ld	r0, X+
    641a:	00 20       	and	r0, r0
    641c:	e9 f7       	brne	.-6      	; 0x6418 <GenerateGeniusCode+0x7a>
    641e:	9d 01       	movw	r18, r26
    6420:	21 50       	subi	r18, 0x01	; 1
    6422:	30 40       	sbci	r19, 0x00	; 0
    6424:	2e 19       	sub	r18, r14
    6426:	3f 09       	sbc	r19, r15
    6428:	d8 01       	movw	r26, r16
    642a:	0d 90       	ld	r0, X+
    642c:	00 20       	and	r0, r0
    642e:	e9 f7       	brne	.-6      	; 0x642a <GenerateGeniusCode+0x8c>
    6430:	11 97       	sbiw	r26, 0x01	; 1
    6432:	a0 1b       	sub	r26, r16
    6434:	b1 0b       	sbc	r27, r17
    6436:	22 50       	subi	r18, 0x02	; 2
    6438:	30 40       	sbci	r19, 0x00	; 0
    643a:	b7 01       	movw	r22, r14
    643c:	62 0f       	add	r22, r18
    643e:	73 1f       	adc	r23, r19
    6440:	2e 5f       	subi	r18, 0xFE	; 254
    6442:	3f 4f       	sbci	r19, 0xFF	; 255
    6444:	40 e0       	ldi	r20, 0x00	; 0
    6446:	50 e0       	ldi	r21, 0x00	; 0
    6448:	ed b7       	in	r30, 0x3d	; 61
    644a:	fe b7       	in	r31, 0x3e	; 62
    644c:	36 96       	adiw	r30, 0x06	; 6
    644e:	0f b6       	in	r0, 0x3f	; 63
    6450:	f8 94       	cli
    6452:	fe bf       	out	0x3e, r31	; 62
    6454:	0f be       	out	0x3f, r0	; 63
    6456:	ed bf       	out	0x3d, r30	; 61
    6458:	09 c0       	rjmp	.+18     	; 0x646c <GenerateGeniusCode+0xce>
	 }Dest[Length]=0;
}
void StrPosPaste(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[IdxSource+i]=Source[i];
    645a:	f8 01       	movw	r30, r16
    645c:	e4 0f       	add	r30, r20
    645e:	f5 1f       	adc	r31, r21
    6460:	80 81       	ld	r24, Z
    6462:	fb 01       	movw	r30, r22
    6464:	81 93       	st	Z+, r24
    6466:	bf 01       	movw	r22, r30
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
}
void StrPosPaste(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    6468:	4f 5f       	subi	r20, 0xFF	; 255
    646a:	5f 4f       	sbci	r21, 0xFF	; 255
    646c:	4a 17       	cp	r20, r26
    646e:	5b 07       	cpc	r21, r27
    6470:	a0 f3       	brcs	.-24     	; 0x645a <GenerateGeniusCode+0xbc>
	    Dest[IdxSource+i]=Source[i];
	 }Dest[IdxSource+Length]=0;
    6472:	ae 0d       	add	r26, r14
    6474:	bf 1d       	adc	r27, r15
    6476:	a2 0f       	add	r26, r18
    6478:	b3 1f       	adc	r27, r19
    647a:	12 97       	sbiw	r26, 0x02	; 2
    647c:	1c 92       	st	X, r1
	 #ifdef DEBUG_GENIUS_CODE
	    sprintf_P(strSend,PSTR("NewDate[%s]"),srcDate);
		_uart_print(1,1,strSend);
     #endif

	 sprintf_P(strDestCode,PSTR("%c"),cSeed);     
    647e:	00 d0       	rcall	.+0      	; 0x6480 <GenerateGeniusCode+0xe2>
    6480:	00 d0       	rcall	.+0      	; 0x6482 <GenerateGeniusCode+0xe4>
    6482:	00 d0       	rcall	.+0      	; 0x6484 <GenerateGeniusCode+0xe6>
    6484:	ed b7       	in	r30, 0x3d	; 61
    6486:	fe b7       	in	r31, 0x3e	; 62
    6488:	31 96       	adiw	r30, 0x01	; 1
    648a:	ad b7       	in	r26, 0x3d	; 61
    648c:	be b7       	in	r27, 0x3e	; 62
    648e:	12 96       	adiw	r26, 0x02	; 2
    6490:	bc 92       	st	X, r11
    6492:	ae 92       	st	-X, r10
    6494:	11 97       	sbiw	r26, 0x01	; 1
    6496:	82 ef       	ldi	r24, 0xF2	; 242
    6498:	97 e1       	ldi	r25, 0x17	; 23
    649a:	93 83       	std	Z+3, r25	; 0x03
    649c:	82 83       	std	Z+2, r24	; 0x02
    649e:	c4 82       	std	Z+4, r12	; 0x04
    64a0:	15 82       	std	Z+5, r1	; 0x05
    64a2:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    64a6:	dd 24       	eor	r13, r13
    64a8:	d3 94       	inc	r13
    64aa:	ed b7       	in	r30, 0x3d	; 61
    64ac:	fe b7       	in	r31, 0x3e	; 62
    64ae:	36 96       	adiw	r30, 0x06	; 6
    64b0:	0f b6       	in	r0, 0x3f	; 63
    64b2:	f8 94       	cli
    64b4:	fe bf       	out	0x3e, r31	; 62
    64b6:	0f be       	out	0x3f, r0	; 63
    64b8:	ed bf       	out	0x3d, r30	; 61
	 GCalcOpt=G_PLUS;
	 for (i=1;i<strlen(srcDate);i++){
	      strDestCode[i]='0'+GeniusCalc(GCalcOpt,(cSeed-'0'),(srcDate[i]-'0'));	 
    64ba:	f0 ed       	ldi	r31, 0xD0	; 208
    64bc:	cf 0e       	add	r12, r31
    64be:	0f c0       	rjmp	.+30     	; 0x64de <GenerateGeniusCode+0x140>
    64c0:	f7 01       	movw	r30, r14
    64c2:	e0 0f       	add	r30, r16
    64c4:	f1 1f       	adc	r31, r17
    64c6:	40 81       	ld	r20, Z
    64c8:	40 53       	subi	r20, 0x30	; 48
    64ca:	80 e0       	ldi	r24, 0x00	; 0
    64cc:	6c 2d       	mov	r22, r12
    64ce:	0e 94 2c 16 	call	0x2c58	; 0x2c58 <GeniusCalc>
    64d2:	0a 0d       	add	r16, r10
    64d4:	1b 1d       	adc	r17, r11
    64d6:	80 5d       	subi	r24, 0xD0	; 208
    64d8:	d8 01       	movw	r26, r16
    64da:	8c 93       	st	X, r24
		_uart_print(1,1,strSend);
     #endif

	 sprintf_P(strDestCode,PSTR("%c"),cSeed);     
	 GCalcOpt=G_PLUS;
	 for (i=1;i<strlen(srcDate);i++){
    64dc:	d3 94       	inc	r13
    64de:	0d 2d       	mov	r16, r13
    64e0:	10 e0       	ldi	r17, 0x00	; 0
    64e2:	d7 01       	movw	r26, r14
    64e4:	0d 90       	ld	r0, X+
    64e6:	00 20       	and	r0, r0
    64e8:	e9 f7       	brne	.-6      	; 0x64e4 <GenerateGeniusCode+0x146>
    64ea:	11 97       	sbiw	r26, 0x01	; 1
    64ec:	ae 19       	sub	r26, r14
    64ee:	bf 09       	sbc	r27, r15
    64f0:	0a 17       	cp	r16, r26
    64f2:	1b 07       	cpc	r17, r27
    64f4:	28 f3       	brcs	.-54     	; 0x64c0 <GenerateGeniusCode+0x122>
	      strDestCode[i]='0'+GeniusCalc(GCalcOpt,(cSeed-'0'),(srcDate[i]-'0'));	 
	 }strDestCode[strlen(srcDate)]=0;
    64f6:	aa 0d       	add	r26, r10
    64f8:	bb 1d       	adc	r27, r11
    64fa:	1c 92       	st	X, r1
	 #ifdef DEBUG_GENIUS_CODE
       sprintf_P(strSend,PSTR("1st:%s"),strDestCode);
	   _uart_print(1,1,strSend);     
	 #endif

	 WrapCode(strDestCode);
    64fc:	c5 01       	movw	r24, r10
    64fe:	0e 94 d1 30 	call	0x61a2	; 0x61a2 <WrapCode>
	 #ifdef DEBUG_GENIUS_CODE
	   sprintf_P(strSend,PSTR("Wrap:%s"),strDestCode);
	   _uart_print(1,1,strSend);     
	 #endif
}
    6502:	28 96       	adiw	r28, 0x08	; 8
    6504:	0f b6       	in	r0, 0x3f	; 63
    6506:	f8 94       	cli
    6508:	de bf       	out	0x3e, r29	; 62
    650a:	0f be       	out	0x3f, r0	; 63
    650c:	cd bf       	out	0x3d, r28	; 61
    650e:	cf 91       	pop	r28
    6510:	df 91       	pop	r29
    6512:	1f 91       	pop	r17
    6514:	0f 91       	pop	r16
    6516:	ff 90       	pop	r15
    6518:	ef 90       	pop	r14
    651a:	df 90       	pop	r13
    651c:	cf 90       	pop	r12
    651e:	bf 90       	pop	r11
    6520:	af 90       	pop	r10
    6522:	08 95       	ret

00006524 <GeneratePrintInit>:
	IsBusyMsg11=True;
}



void GeneratePrintInit(){//Create Initialize Print 
    6524:	cf 92       	push	r12
    6526:	df 92       	push	r13
    6528:	ef 92       	push	r14
    652a:	ff 92       	push	r15
    652c:	0f 93       	push	r16
    652e:	1f 93       	push	r17
    6530:	df 93       	push	r29
    6532:	cf 93       	push	r28
    6534:	cd b7       	in	r28, 0x3d	; 61
    6536:	de b7       	in	r29, 0x3e	; 62
    6538:	62 97       	sbiw	r28, 0x12	; 18
    653a:	0f b6       	in	r0, 0x3f	; 63
    653c:	f8 94       	cli
    653e:	de bf       	out	0x3e, r29	; 62
    6540:	0f be       	out	0x3f, r0	; 63
    6542:	cd bf       	out	0x3d, r28	; 61
     char strVernum[6],strVerdate[12];
	 sprintf_P(strVernum,PSTR(VERSION_NUM));
    6544:	00 d0       	rcall	.+0      	; 0x6546 <GeneratePrintInit+0x22>
    6546:	00 d0       	rcall	.+0      	; 0x6548 <GeneratePrintInit+0x24>
    6548:	6e 01       	movw	r12, r28
    654a:	08 94       	sec
    654c:	c1 1c       	adc	r12, r1
    654e:	d1 1c       	adc	r13, r1
    6550:	ad b7       	in	r26, 0x3d	; 61
    6552:	be b7       	in	r27, 0x3e	; 62
    6554:	12 96       	adiw	r26, 0x02	; 2
    6556:	dc 92       	st	X, r13
    6558:	ce 92       	st	-X, r12
    655a:	11 97       	sbiw	r26, 0x01	; 1
    655c:	89 e7       	ldi	r24, 0x79	; 121
    655e:	9d e1       	ldi	r25, 0x1D	; 29
    6560:	14 96       	adiw	r26, 0x04	; 4
    6562:	9c 93       	st	X, r25
    6564:	8e 93       	st	-X, r24
    6566:	13 97       	sbiw	r26, 0x03	; 3
    6568:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
	 sprintf_P(strVerdate,PSTR(VERSION_DATE));
    656c:	e7 e0       	ldi	r30, 0x07	; 7
    656e:	ee 2e       	mov	r14, r30
    6570:	f1 2c       	mov	r15, r1
    6572:	ec 0e       	add	r14, r28
    6574:	fd 1e       	adc	r15, r29
    6576:	ed b7       	in	r30, 0x3d	; 61
    6578:	fe b7       	in	r31, 0x3e	; 62
    657a:	f2 82       	std	Z+2, r15	; 0x02
    657c:	e1 82       	std	Z+1, r14	; 0x01
    657e:	8e e6       	ldi	r24, 0x6E	; 110
    6580:	9d e1       	ldi	r25, 0x1D	; 29
    6582:	94 83       	std	Z+4, r25	; 0x04
    6584:	83 83       	std	Z+3, r24	; 0x03
    6586:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
     sprintf_P(PrintBuffer,PSTR("\nGeNiUs Ticket Printer \n Version:%s\n Last Update %s \n Hanindo Automation Solutions \n www.hanindogroup.com\n\n\n\n\n\n\n\n"),strVernum,strVerdate);
    658a:	00 d0       	rcall	.+0      	; 0x658c <GeneratePrintInit+0x68>
    658c:	00 d0       	rcall	.+0      	; 0x658e <GeneratePrintInit+0x6a>
    658e:	ed b7       	in	r30, 0x3d	; 61
    6590:	fe b7       	in	r31, 0x3e	; 62
    6592:	31 96       	adiw	r30, 0x01	; 1
    6594:	0e ef       	ldi	r16, 0xFE	; 254
    6596:	14 e0       	ldi	r17, 0x04	; 4
    6598:	ad b7       	in	r26, 0x3d	; 61
    659a:	be b7       	in	r27, 0x3e	; 62
    659c:	12 96       	adiw	r26, 0x02	; 2
    659e:	1c 93       	st	X, r17
    65a0:	0e 93       	st	-X, r16
    65a2:	11 97       	sbiw	r26, 0x01	; 1
    65a4:	8c ef       	ldi	r24, 0xFC	; 252
    65a6:	9c e1       	ldi	r25, 0x1C	; 28
    65a8:	93 83       	std	Z+3, r25	; 0x03
    65aa:	82 83       	std	Z+2, r24	; 0x02
    65ac:	d5 82       	std	Z+5, r13	; 0x05
    65ae:	c4 82       	std	Z+4, r12	; 0x04
    65b0:	f7 82       	std	Z+7, r15	; 0x07
    65b2:	e6 82       	std	Z+6, r14	; 0x06
    65b4:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
	 _uart_print(0,1,PrintBuffer);
    65b8:	ed b7       	in	r30, 0x3d	; 61
    65ba:	fe b7       	in	r31, 0x3e	; 62
    65bc:	38 96       	adiw	r30, 0x08	; 8
    65be:	0f b6       	in	r0, 0x3f	; 63
    65c0:	f8 94       	cli
    65c2:	fe bf       	out	0x3e, r31	; 62
    65c4:	0f be       	out	0x3f, r0	; 63
    65c6:	ed bf       	out	0x3d, r30	; 61
    65c8:	80 e0       	ldi	r24, 0x00	; 0
    65ca:	61 e0       	ldi	r22, 0x01	; 1
    65cc:	a8 01       	movw	r20, r16
    65ce:	0e 94 70 b2 	call	0x164e0	; 0x164e0 <_uart_print>
	 LengthMessage81=strlen(PrintBuffer);
    65d2:	f8 01       	movw	r30, r16
    65d4:	01 90       	ld	r0, Z+
    65d6:	00 20       	and	r0, r0
    65d8:	e9 f7       	brne	.-6      	; 0x65d4 <GeneratePrintInit+0xb0>
    65da:	31 97       	sbiw	r30, 0x01	; 1
    65dc:	e0 1b       	sub	r30, r16
    65de:	f1 0b       	sbc	r31, r17
    65e0:	f0 93 91 01 	sts	0x0191, r31
    65e4:	e0 93 90 01 	sts	0x0190, r30
	 //Spooling HFCx 0000
	 cmdPrint=0b00010000|(1<<PRN_PAPER_CUT);
    65e8:	80 e3       	ldi	r24, 0x30	; 48
    65ea:	80 93 b7 01 	sts	0x01B7, r24
	 IsFreePrinting=True;
    65ee:	81 e0       	ldi	r24, 0x01	; 1
    65f0:	80 93 ab 01 	sts	0x01AB, r24
}
    65f4:	62 96       	adiw	r28, 0x12	; 18
    65f6:	0f b6       	in	r0, 0x3f	; 63
    65f8:	f8 94       	cli
    65fa:	de bf       	out	0x3e, r29	; 62
    65fc:	0f be       	out	0x3f, r0	; 63
    65fe:	cd bf       	out	0x3d, r28	; 61
    6600:	cf 91       	pop	r28
    6602:	df 91       	pop	r29
    6604:	1f 91       	pop	r17
    6606:	0f 91       	pop	r16
    6608:	ff 90       	pop	r15
    660a:	ef 90       	pop	r14
    660c:	df 90       	pop	r13
    660e:	cf 90       	pop	r12
    6610:	08 95       	ret

00006612 <FormatCurrency>:
     DecCfg=eeprom_read_byte(&DefDecimalTotalVolume);
	 FormatDecimal(strRawVolume,DecCfg);
}


void FormatCurrency(char *strCurrency){// 5000000.00 5,000,000.00
    6612:	9f 92       	push	r9
    6614:	af 92       	push	r10
    6616:	bf 92       	push	r11
    6618:	cf 92       	push	r12
    661a:	df 92       	push	r13
    661c:	ef 92       	push	r14
    661e:	ff 92       	push	r15
    6620:	0f 93       	push	r16
    6622:	1f 93       	push	r17
    6624:	df 93       	push	r29
    6626:	cf 93       	push	r28
    6628:	cd b7       	in	r28, 0x3d	; 61
    662a:	de b7       	in	r29, 0x3e	; 62
    662c:	64 97       	sbiw	r28, 0x14	; 20
    662e:	0f b6       	in	r0, 0x3f	; 63
    6630:	f8 94       	cli
    6632:	de bf       	out	0x3e, r29	; 62
    6634:	0f be       	out	0x3f, r0	; 63
    6636:	cd bf       	out	0x3d, r28	; 61
    6638:	6c 01       	movw	r12, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    663a:	e1 99       	sbic	0x1c, 1	; 28
    663c:	fe cf       	rjmp	.-4      	; 0x663a <FormatCurrency+0x28>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    663e:	8f e3       	ldi	r24, 0x3F	; 63
    6640:	90 e0       	ldi	r25, 0x00	; 0
    6642:	9f bb       	out	0x1f, r25	; 31
    6644:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    6646:	e0 9a       	sbi	0x1c, 0	; 28
    6648:	9d b2       	in	r9, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    664a:	e1 99       	sbic	0x1c, 1	; 28
    664c:	fe cf       	rjmp	.-4      	; 0x664a <FormatCurrency+0x38>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    664e:	8e e3       	ldi	r24, 0x3E	; 62
    6650:	90 e0       	ldi	r25, 0x00	; 0
    6652:	9f bb       	out	0x1f, r25	; 31
    6654:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    6656:	e0 9a       	sbi	0x1c, 0	; 28
    6658:	3d b3       	in	r19, 0x1d	; 29
	 char CurrencyMark,DecimalMark;

	 CurrencyMark=eeprom_read_byte(&DefCurrencyMark);
	 DecimalMark=eeprom_read_byte(&DefDecimalMark);

	 Length=strlen(strCurrency);//123,456
    665a:	f6 01       	movw	r30, r12
    665c:	01 90       	ld	r0, Z+
    665e:	00 20       	and	r0, r0
    6660:	e9 f7       	brne	.-6      	; 0x665c <FormatCurrency+0x4a>
    6662:	31 97       	sbiw	r30, 0x01	; 1
    6664:	ee 2e       	mov	r14, r30
    6666:	ec 18       	sub	r14, r12
    6668:	fe 01       	movw	r30, r28
    666a:	31 96       	adiw	r30, 0x01	; 1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    666c:	ce 01       	movw	r24, r28
    666e:	45 96       	adiw	r24, 0x15	; 21
	     strMemory[i]=data;
    6670:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    6672:	e8 17       	cp	r30, r24
    6674:	f9 07       	cpc	r31, r25
    6676:	e1 f7       	brne	.-8      	; 0x6670 <FormatCurrency+0x5e>
    6678:	f6 01       	movw	r30, r12
    667a:	fe 2c       	mov	r15, r14
    667c:	80 e0       	ldi	r24, 0x00	; 0
    667e:	20 e0       	ldi	r18, 0x00	; 0
    6680:	09 c0       	rjmp	.+18     	; 0x6694 <FormatCurrency+0x82>
	 dotPos=Length;
	 nComa=0;
	 FillChar(fmtCurrency,sizeof(fmtCurrency),0);
	 //Detection
	 for(i=0;i<Length;i++){// 123,456 
	     if (strCurrency[i]==DecimalMark) dotPos=i;//3
    6682:	90 81       	ld	r25, Z
    6684:	93 17       	cp	r25, r19
    6686:	09 f4       	brne	.+2      	; 0x668a <FormatCurrency+0x78>
    6688:	f8 2e       	mov	r15, r24
		 if (strCurrency[i]==CurrencyMark) nComa++;//0
    668a:	99 15       	cp	r25, r9
    668c:	09 f4       	brne	.+2      	; 0x6690 <FormatCurrency+0x7e>
    668e:	2f 5f       	subi	r18, 0xFF	; 255
	 Length=strlen(strCurrency);//123,456
	 dotPos=Length;
	 nComa=0;
	 FillChar(fmtCurrency,sizeof(fmtCurrency),0);
	 //Detection
	 for(i=0;i<Length;i++){// 123,456 
    6690:	8f 5f       	subi	r24, 0xFF	; 255
    6692:	31 96       	adiw	r30, 0x01	; 1
    6694:	8e 15       	cp	r24, r14
    6696:	a8 f3       	brcs	.-22     	; 0x6682 <FormatCurrency+0x70>
	     if (strCurrency[i]==DecimalMark) dotPos=i;//3
		 if (strCurrency[i]==CurrencyMark) nComa++;//0
	 }

	 if((nComa==0)&&(dotPos>3)){		 
    6698:	22 23       	and	r18, r18
    669a:	09 f0       	breq	.+2      	; 0x669e <FormatCurrency+0x8c>
    669c:	5e c0       	rjmp	.+188    	; 0x675a <FormatCurrency+0x148>
    669e:	83 e0       	ldi	r24, 0x03	; 3
    66a0:	8f 15       	cp	r24, r15
    66a2:	08 f0       	brcs	.+2      	; 0x66a6 <FormatCurrency+0x94>
    66a4:	5a c0       	rjmp	.+180    	; 0x675a <FormatCurrency+0x148>
    66a6:	40 e0       	ldi	r20, 0x00	; 0
    66a8:	20 e0       	ldi	r18, 0x00	; 0
    66aa:	30 e0       	ldi	r19, 0x00	; 0
         iPos=0;
	     for(i=0;i<dotPos;i++){
	         if ((((dotPos-i)%3)==0)&&(i<(dotPos))&&(i>0)){ 
    66ac:	af 2c       	mov	r10, r15
    66ae:	bb 24       	eor	r11, r11
		        fmtCurrency[iPos]=CurrencyMark;
    66b0:	8e 01       	movw	r16, r28
    66b2:	0f 5f       	subi	r16, 0xFF	; 255
    66b4:	1f 4f       	sbci	r17, 0xFF	; 255
	 }

	 if((nComa==0)&&(dotPos>3)){		 
         iPos=0;
	     for(i=0;i<dotPos;i++){
	         if ((((dotPos-i)%3)==0)&&(i<(dotPos))&&(i>0)){ 
    66b6:	c5 01       	movw	r24, r10
    66b8:	82 1b       	sub	r24, r18
    66ba:	93 0b       	sbc	r25, r19
    66bc:	63 e0       	ldi	r22, 0x03	; 3
    66be:	70 e0       	ldi	r23, 0x00	; 0
    66c0:	0e 94 1e b7 	call	0x16e3c	; 0x16e3c <__divmodhi4>
    66c4:	89 2b       	or	r24, r25
    66c6:	49 f4       	brne	.+18     	; 0x66da <FormatCurrency+0xc8>
    66c8:	2f 15       	cp	r18, r15
    66ca:	38 f4       	brcc	.+14     	; 0x66da <FormatCurrency+0xc8>
    66cc:	22 23       	and	r18, r18
    66ce:	29 f0       	breq	.+10     	; 0x66da <FormatCurrency+0xc8>
		        fmtCurrency[iPos]=CurrencyMark;
    66d0:	f8 01       	movw	r30, r16
    66d2:	e4 0f       	add	r30, r20
    66d4:	f1 1d       	adc	r31, r1
    66d6:	90 82       	st	Z, r9
		        iPos++;
    66d8:	4f 5f       	subi	r20, 0xFF	; 255
		        }
		        fmtCurrency[iPos]=strCurrency[i];
    66da:	d8 01       	movw	r26, r16
    66dc:	a4 0f       	add	r26, r20
    66de:	b1 1d       	adc	r27, r1
    66e0:	f6 01       	movw	r30, r12
    66e2:	e2 0f       	add	r30, r18
    66e4:	f3 1f       	adc	r31, r19
    66e6:	80 81       	ld	r24, Z
    66e8:	8c 93       	st	X, r24
			    iPos++;
    66ea:	4f 5f       	subi	r20, 0xFF	; 255
			    fmtCurrency[iPos]=0;
    66ec:	f8 01       	movw	r30, r16
    66ee:	e4 0f       	add	r30, r20
    66f0:	f1 1d       	adc	r31, r1
    66f2:	10 82       	st	Z, r1
    66f4:	2f 5f       	subi	r18, 0xFF	; 255
    66f6:	3f 4f       	sbci	r19, 0xFF	; 255
		 if (strCurrency[i]==CurrencyMark) nComa++;//0
	 }

	 if((nComa==0)&&(dotPos>3)){		 
         iPos=0;
	     for(i=0;i<dotPos;i++){
    66f8:	2f 15       	cp	r18, r15
    66fa:	e8 f2       	brcs	.-70     	; 0x66b6 <FormatCurrency+0xa4>
    66fc:	9f 2d       	mov	r25, r15
			    iPos++;
			    fmtCurrency[iPos]=0;
	         }
         
	     for(i=dotPos;i<Length;i++){
		        fmtCurrency[iPos]=strCurrency[i];
    66fe:	9e 01       	movw	r18, r28
    6700:	2f 5f       	subi	r18, 0xFF	; 255
    6702:	3f 4f       	sbci	r19, 0xFF	; 255
    6704:	0e c0       	rjmp	.+28     	; 0x6722 <FormatCurrency+0x110>
    6706:	d9 01       	movw	r26, r18
    6708:	a4 0f       	add	r26, r20
    670a:	b1 1d       	adc	r27, r1
    670c:	f6 01       	movw	r30, r12
    670e:	e9 0f       	add	r30, r25
    6710:	f1 1d       	adc	r31, r1
    6712:	80 81       	ld	r24, Z
    6714:	8c 93       	st	X, r24
			    iPos++;
    6716:	4f 5f       	subi	r20, 0xFF	; 255
			    fmtCurrency[iPos]=0;
    6718:	f9 01       	movw	r30, r18
    671a:	e4 0f       	add	r30, r20
    671c:	f1 1d       	adc	r31, r1
    671e:	10 82       	st	Z, r1
		        fmtCurrency[iPos]=strCurrency[i];
			    iPos++;
			    fmtCurrency[iPos]=0;
	         }
         
	     for(i=dotPos;i<Length;i++){
    6720:	9f 5f       	subi	r25, 0xFF	; 255
    6722:	9e 15       	cp	r25, r14
    6724:	80 f3       	brcs	.-32     	; 0x6706 <FormatCurrency+0xf4>
    6726:	90 e0       	ldi	r25, 0x00	; 0
		        fmtCurrency[iPos]=strCurrency[i];
			    iPos++;
			    fmtCurrency[iPos]=0;
	         }
	      for(i=0;i<strlen(fmtCurrency);i++){
    6728:	9e 01       	movw	r18, r28
    672a:	2f 5f       	subi	r18, 0xFF	; 255
    672c:	3f 4f       	sbci	r19, 0xFF	; 255
    672e:	09 c0       	rjmp	.+18     	; 0x6742 <FormatCurrency+0x130>
	          strCurrency[i]=fmtCurrency[i];
    6730:	f6 01       	movw	r30, r12
    6732:	ea 0f       	add	r30, r26
    6734:	fb 1f       	adc	r31, r27
    6736:	a2 0f       	add	r26, r18
    6738:	b3 1f       	adc	r27, r19
    673a:	8c 91       	ld	r24, X
    673c:	80 83       	st	Z, r24
			  strCurrency[i+1]=0;
    673e:	11 82       	std	Z+1, r1	; 0x01
	     for(i=dotPos;i<Length;i++){
		        fmtCurrency[iPos]=strCurrency[i];
			    iPos++;
			    fmtCurrency[iPos]=0;
	         }
	      for(i=0;i<strlen(fmtCurrency);i++){
    6740:	9f 5f       	subi	r25, 0xFF	; 255
    6742:	a9 2f       	mov	r26, r25
    6744:	b0 e0       	ldi	r27, 0x00	; 0
    6746:	f9 01       	movw	r30, r18
    6748:	01 90       	ld	r0, Z+
    674a:	00 20       	and	r0, r0
    674c:	e9 f7       	brne	.-6      	; 0x6748 <FormatCurrency+0x136>
    674e:	31 97       	sbiw	r30, 0x01	; 1
    6750:	e2 1b       	sub	r30, r18
    6752:	f3 0b       	sbc	r31, r19
    6754:	ae 17       	cp	r26, r30
    6756:	bf 07       	cpc	r27, r31
    6758:	58 f3       	brcs	.-42     	; 0x6730 <FormatCurrency+0x11e>
	          strCurrency[i]=fmtCurrency[i];
			  strCurrency[i+1]=0;
	      }
     }      
}
    675a:	64 96       	adiw	r28, 0x14	; 20
    675c:	0f b6       	in	r0, 0x3f	; 63
    675e:	f8 94       	cli
    6760:	de bf       	out	0x3e, r29	; 62
    6762:	0f be       	out	0x3f, r0	; 63
    6764:	cd bf       	out	0x3d, r28	; 61
    6766:	cf 91       	pop	r28
    6768:	df 91       	pop	r29
    676a:	1f 91       	pop	r17
    676c:	0f 91       	pop	r16
    676e:	ff 90       	pop	r15
    6770:	ef 90       	pop	r14
    6772:	df 90       	pop	r13
    6774:	cf 90       	pop	r12
    6776:	bf 90       	pop	r11
    6778:	af 90       	pop	r10
    677a:	9f 90       	pop	r9
    677c:	08 95       	ret

0000677e <FormatDecimal>:

void TestLocalAccount(){

}

void FormatDecimal(char *strRawData, char DecimalCfg){// 9-> 0,009 0,234 123 
    677e:	ef 92       	push	r14
    6780:	ff 92       	push	r15
    6782:	0f 93       	push	r16
    6784:	1f 93       	push	r17
    6786:	df 93       	push	r29
    6788:	cf 93       	push	r28
    678a:	cd b7       	in	r28, 0x3d	; 61
    678c:	de b7       	in	r29, 0x3e	; 62
    678e:	64 97       	sbiw	r28, 0x14	; 20
    6790:	0f b6       	in	r0, 0x3f	; 63
    6792:	f8 94       	cli
    6794:	de bf       	out	0x3e, r29	; 62
    6796:	0f be       	out	0x3f, r0	; 63
    6798:	cd bf       	out	0x3d, r28	; 61
    679a:	8c 01       	movw	r16, r24
     char i,iPos,CommaPos,Length=0;                 //1->0,01 
	 char strDecimalFormated[20];
	 char DecPointMark;
     if (DecimalCfg>0){    
    679c:	66 23       	and	r22, r22
    679e:	09 f4       	brne	.+2      	; 0x67a2 <FormatDecimal+0x24>
    67a0:	56 c0       	rjmp	.+172    	; 0x684e <FormatDecimal+0xd0>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    67a2:	e1 99       	sbic	0x1c, 1	; 28
    67a4:	fe cf       	rjmp	.-4      	; 0x67a2 <FormatDecimal+0x24>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    67a6:	8e e3       	ldi	r24, 0x3E	; 62
    67a8:	90 e0       	ldi	r25, 0x00	; 0
    67aa:	9f bb       	out	0x1f, r25	; 31
    67ac:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    67ae:	e0 9a       	sbi	0x1c, 0	; 28
    67b0:	ed b2       	in	r14, 0x1d	; 29
		 DecPointMark=eeprom_read_byte(&DefDecimalMark);	 
		 Length=strlen(strRawData);
    67b2:	f8 01       	movw	r30, r16
    67b4:	01 90       	ld	r0, Z+
    67b6:	00 20       	and	r0, r0
    67b8:	e9 f7       	brne	.-6      	; 0x67b4 <FormatDecimal+0x36>
    67ba:	31 97       	sbiw	r30, 0x01	; 1
    67bc:	3e 2f       	mov	r19, r30
    67be:	30 1b       	sub	r19, r16

		 if (Length>DecimalCfg)CommaPos=Length-DecimalCfg;
    67c0:	63 17       	cp	r22, r19
    67c2:	b8 f5       	brcc	.+110    	; 0x6832 <FormatDecimal+0xb4>
    67c4:	f3 2e       	mov	r15, r19
    67c6:	f6 1a       	sub	r15, r22
    67c8:	b8 01       	movw	r22, r16
    67ca:	d8 01       	movw	r26, r16
    67cc:	20 e0       	ldi	r18, 0x00	; 0
    67ce:	90 e0       	ldi	r25, 0x00	; 0

		 
		 iPos=0;
		 for(i=0;i<Length;i++){
			 if (i==CommaPos){
				 strDecimalFormated[iPos]=DecPointMark;
    67d0:	ae 01       	movw	r20, r28
    67d2:	4f 5f       	subi	r20, 0xFF	; 255
    67d4:	5f 4f       	sbci	r21, 0xFF	; 255
    67d6:	0e c0       	rjmp	.+28     	; 0x67f4 <FormatDecimal+0x76>
			 }

		 
		 iPos=0;
		 for(i=0;i<Length;i++){
			 if (i==CommaPos){
    67d8:	2f 15       	cp	r18, r15
    67da:	29 f4       	brne	.+10     	; 0x67e6 <FormatDecimal+0x68>
				 strDecimalFormated[iPos]=DecPointMark;
    67dc:	fa 01       	movw	r30, r20
    67de:	e9 0f       	add	r30, r25
    67e0:	f1 1d       	adc	r31, r1
    67e2:	e0 82       	st	Z, r14
				 iPos++;
    67e4:	9f 5f       	subi	r25, 0xFF	; 255
			}
			strDecimalFormated[iPos]=strRawData[i];
    67e6:	fa 01       	movw	r30, r20
    67e8:	e9 0f       	add	r30, r25
    67ea:	f1 1d       	adc	r31, r1
    67ec:	8d 91       	ld	r24, X+
    67ee:	80 83       	st	Z, r24
			//strDecimalFormated[iPos+1]=0;
			iPos++;
    67f0:	9f 5f       	subi	r25, 0xFF	; 255
			 CommaPos=1;
			 }

		 
		 iPos=0;
		 for(i=0;i<Length;i++){
    67f2:	2f 5f       	subi	r18, 0xFF	; 255
    67f4:	23 17       	cp	r18, r19
    67f6:	80 f3       	brcs	.-32     	; 0x67d8 <FormatDecimal+0x5a>
				 iPos++;
			}
			strDecimalFormated[iPos]=strRawData[i];
			//strDecimalFormated[iPos+1]=0;
			iPos++;
		 }strDecimalFormated[iPos]=0;
    67f8:	9e 01       	movw	r18, r28
    67fa:	2f 5f       	subi	r18, 0xFF	; 255
    67fc:	3f 4f       	sbci	r19, 0xFF	; 255
    67fe:	f9 01       	movw	r30, r18
    6800:	e9 0f       	add	r30, r25
    6802:	f1 1d       	adc	r31, r1
    6804:	10 82       	st	Z, r1
		 
         //_uart_print(1,1,strDecimalFormated); 

		 Length=strlen(strDecimalFormated);
    6806:	f9 01       	movw	r30, r18
    6808:	01 90       	ld	r0, Z+
    680a:	00 20       	and	r0, r0
    680c:	e9 f7       	brne	.-6      	; 0x6808 <FormatDecimal+0x8a>
    680e:	31 97       	sbiw	r30, 0x01	; 1
    6810:	9e 2f       	mov	r25, r30
    6812:	92 1b       	sub	r25, r18
    6814:	d9 01       	movw	r26, r18
    6816:	04 c0       	rjmp	.+8      	; 0x6820 <FormatDecimal+0xa2>
		 for(i=0;i<Length;i++){
			 strRawData[i]=strDecimalFormated[i];
    6818:	8d 91       	ld	r24, X+
    681a:	fb 01       	movw	r30, r22
    681c:	81 93       	st	Z+, r24
    681e:	bf 01       	movw	r22, r30
		 }strDecimalFormated[iPos]=0;
		 
         //_uart_print(1,1,strDecimalFormated); 

		 Length=strlen(strDecimalFormated);
		 for(i=0;i<Length;i++){
    6820:	8a 2f       	mov	r24, r26
    6822:	82 1b       	sub	r24, r18
    6824:	89 17       	cp	r24, r25
    6826:	c0 f3       	brcs	.-16     	; 0x6818 <FormatDecimal+0x9a>
			 strRawData[i]=strDecimalFormated[i];
		 }strRawData[Length]=0;
    6828:	09 0f       	add	r16, r25
    682a:	11 1d       	adc	r17, r1
    682c:	f8 01       	movw	r30, r16
    682e:	10 82       	st	Z, r1
    6830:	0e c0       	rjmp	.+28     	; 0x684e <FormatDecimal+0xd0>
		 if (Length>DecimalCfg)CommaPos=Length-DecimalCfg;
		 else CommaPos=1;


		 if (Length<=DecimalCfg){// 123 -> 0123
			 AddZeroLead(strRawData,(DecimalCfg+1));
    6832:	6f 5f       	subi	r22, 0xFF	; 255
    6834:	c8 01       	movw	r24, r16
    6836:	0e 94 97 26 	call	0x4d2e	; 0x4d2e <AddZeroLead>
			 //AddZeroLead(strRawData,(DecimalCfg+2));
			 Length=strlen(strRawData);
    683a:	f8 01       	movw	r30, r16
    683c:	01 90       	ld	r0, Z+
    683e:	00 20       	and	r0, r0
    6840:	e9 f7       	brne	.-6      	; 0x683c <FormatDecimal+0xbe>
    6842:	31 97       	sbiw	r30, 0x01	; 1
    6844:	3e 2f       	mov	r19, r30
    6846:	30 1b       	sub	r19, r16
    6848:	ff 24       	eor	r15, r15
    684a:	f3 94       	inc	r15
    684c:	bd cf       	rjmp	.-134    	; 0x67c8 <FormatDecimal+0x4a>
		 for(i=0;i<Length;i++){
			 strRawData[i]=strDecimalFormated[i];
		 }strRawData[Length]=0;
	 }
          //_uart_print(1,1,strRawData); 
}
    684e:	64 96       	adiw	r28, 0x14	; 20
    6850:	0f b6       	in	r0, 0x3f	; 63
    6852:	f8 94       	cli
    6854:	de bf       	out	0x3e, r29	; 62
    6856:	0f be       	out	0x3f, r0	; 63
    6858:	cd bf       	out	0x3d, r28	; 61
    685a:	cf 91       	pop	r28
    685c:	df 91       	pop	r29
    685e:	1f 91       	pop	r17
    6860:	0f 91       	pop	r16
    6862:	ff 90       	pop	r15
    6864:	ef 90       	pop	r14
    6866:	08 95       	ret

00006868 <NormalizeDecimal>:
	 Result=(SigmaSum%255);
	 if (Result==0)Result=255;
   return Result;
}

void NormalizeDecimal(char CurrentDecimal, char NewDecimal, char *Result){// 01234567,89
    6868:	68 2f       	mov	r22, r24
    686a:	ca 01       	movw	r24, r20
		 StrPosCopy(Result,SResult,DeltaDec,Length-DeltaDec);
		 	           
	 
     }
*/
     FormatDecimal(Result,CurrentDecimal);
    686c:	0e 94 bf 33 	call	0x677e	; 0x677e <FormatDecimal>
}
    6870:	08 95       	ret

00006872 <FormatTotalizerVolume>:
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalTotalMoney);
	 FormatDecimal(strRawMoney,DecCfg);
}

void FormatTotalizerVolume(char *strRawVolume){//96->0,96 
    6872:	9c 01       	movw	r18, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    6874:	e1 99       	sbic	0x1c, 1	; 28
    6876:	fe cf       	rjmp	.-4      	; 0x6874 <FormatTotalizerVolume+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    6878:	8c e3       	ldi	r24, 0x3C	; 60
    687a:	90 e0       	ldi	r25, 0x00	; 0
    687c:	9f bb       	out	0x1f, r25	; 31
    687e:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    6880:	e0 9a       	sbi	0x1c, 0	; 28
    6882:	6d b3       	in	r22, 0x1d	; 29
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalTotalVolume);
	 FormatDecimal(strRawVolume,DecCfg);
    6884:	c9 01       	movw	r24, r18
    6886:	0e 94 bf 33 	call	0x677e	; 0x677e <FormatDecimal>
}
    688a:	08 95       	ret

0000688c <FormatTotalizerMoney>:
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalVolume);
	 FormatDecimal(strRawVolume,DecCfg);
}

void FormatTotalizerMoney(char *strRawMoney){
    688c:	9c 01       	movw	r18, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    688e:	e1 99       	sbic	0x1c, 1	; 28
    6890:	fe cf       	rjmp	.-4      	; 0x688e <FormatTotalizerMoney+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    6892:	8d e3       	ldi	r24, 0x3D	; 61
    6894:	90 e0       	ldi	r25, 0x00	; 0
    6896:	9f bb       	out	0x1f, r25	; 31
    6898:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    689a:	e0 9a       	sbi	0x1c, 0	; 28
    689c:	6d b3       	in	r22, 0x1d	; 29
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalTotalMoney);
	 FormatDecimal(strRawMoney,DecCfg);
    689e:	c9 01       	movw	r24, r18
    68a0:	0e 94 bf 33 	call	0x677e	; 0x677e <FormatDecimal>
}
    68a4:	08 95       	ret

000068a6 <FormatVolume>:
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalMoney);
	 FormatDecimal(strRawMoney,DecCfg);
}

void FormatVolume(char *strRawVolume){//96->0,96 
    68a6:	9c 01       	movw	r18, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    68a8:	e1 99       	sbic	0x1c, 1	; 28
    68aa:	fe cf       	rjmp	.-4      	; 0x68a8 <FormatVolume+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    68ac:	8a e3       	ldi	r24, 0x3A	; 58
    68ae:	90 e0       	ldi	r25, 0x00	; 0
    68b0:	9f bb       	out	0x1f, r25	; 31
    68b2:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    68b4:	e0 9a       	sbi	0x1c, 0	; 28
    68b6:	6d b3       	in	r22, 0x1d	; 29
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalVolume);
	 FormatDecimal(strRawVolume,DecCfg);
    68b8:	c9 01       	movw	r24, r18
    68ba:	0e 94 bf 33 	call	0x677e	; 0x677e <FormatDecimal>
}
    68be:	08 95       	ret

000068c0 <FormatMoney>:
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalPrice);
	 FormatDecimal(strRawPrice,DecCfg);
}

void FormatMoney(char *strRawMoney){
    68c0:	9c 01       	movw	r18, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    68c2:	e1 99       	sbic	0x1c, 1	; 28
    68c4:	fe cf       	rjmp	.-4      	; 0x68c2 <FormatMoney+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    68c6:	8b e3       	ldi	r24, 0x3B	; 59
    68c8:	90 e0       	ldi	r25, 0x00	; 0
    68ca:	9f bb       	out	0x1f, r25	; 31
    68cc:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    68ce:	e0 9a       	sbi	0x1c, 0	; 28
    68d0:	6d b3       	in	r22, 0x1d	; 29
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalMoney);
	 FormatDecimal(strRawMoney,DecCfg);
    68d2:	c9 01       	movw	r24, r18
    68d4:	0e 94 bf 33 	call	0x677e	; 0x677e <FormatDecimal>
}
    68d8:	08 95       	ret

000068da <FormatPrice>:
		 }strRawData[Length]=0;
	 }
          //_uart_print(1,1,strRawData); 
}

void FormatPrice(char *strRawPrice){
    68da:	9c 01       	movw	r18, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    68dc:	e1 99       	sbic	0x1c, 1	; 28
    68de:	fe cf       	rjmp	.-4      	; 0x68dc <FormatPrice+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    68e0:	89 e3       	ldi	r24, 0x39	; 57
    68e2:	90 e0       	ldi	r25, 0x00	; 0
    68e4:	9f bb       	out	0x1f, r25	; 31
    68e6:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    68e8:	e0 9a       	sbi	0x1c, 0	; 28
    68ea:	6d b3       	in	r22, 0x1d	; 29
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalPrice);
	 FormatDecimal(strRawPrice,DecCfg);
    68ec:	c9 01       	movw	r24, r18
    68ee:	0e 94 bf 33 	call	0x677e	; 0x677e <FormatDecimal>
}
    68f2:	08 95       	ret

000068f4 <systemGenerateReport>:
	 }
}

//Spooling HFCS 0000 : Header, Footer, Copy , Scrool [Copy:16x max]
//			cmdPrint=procMessage81();
void systemGenerateReport(){
    68f4:	2f 92       	push	r2
    68f6:	3f 92       	push	r3
    68f8:	4f 92       	push	r4
    68fa:	5f 92       	push	r5
    68fc:	6f 92       	push	r6
    68fe:	7f 92       	push	r7
    6900:	8f 92       	push	r8
    6902:	9f 92       	push	r9
    6904:	af 92       	push	r10
    6906:	bf 92       	push	r11
    6908:	cf 92       	push	r12
    690a:	df 92       	push	r13
    690c:	ef 92       	push	r14
    690e:	ff 92       	push	r15
    6910:	0f 93       	push	r16
    6912:	1f 93       	push	r17
    6914:	df 93       	push	r29
    6916:	cf 93       	push	r28
    6918:	cd b7       	in	r28, 0x3d	; 61
    691a:	de b7       	in	r29, 0x3e	; 62
    691c:	c8 5f       	subi	r28, 0xF8	; 248
    691e:	d0 40       	sbci	r29, 0x00	; 0
    6920:	0f b6       	in	r0, 0x3f	; 63
    6922:	f8 94       	cli
    6924:	de bf       	out	0x3e, r29	; 62
    6926:	0f be       	out	0x3f, r0	; 63
    6928:	cd bf       	out	0x3d, r28	; 61
	   char strTabSpace[20],strTabSpace2[20];
	   char iTotal;//,PadLength;
	   char sPrice[10],strProductPrice[20];
	   char FIPAddr;

     switch(stGenerateReport){
    692a:	10 91 fa 01 	lds	r17, 0x01FA
    692e:	16 30       	cpi	r17, 0x06	; 6
    6930:	09 f4       	brne	.+2      	; 0x6934 <systemGenerateReport+0x40>
    6932:	5d c2       	rjmp	.+1210   	; 0x6dee <systemGenerateReport+0x4fa>
    6934:	17 30       	cpi	r17, 0x07	; 7
    6936:	98 f4       	brcc	.+38     	; 0x695e <systemGenerateReport+0x6a>
    6938:	12 30       	cpi	r17, 0x02	; 2
    693a:	09 f4       	brne	.+2      	; 0x693e <systemGenerateReport+0x4a>
    693c:	a7 c0       	rjmp	.+334    	; 0x6a8c <systemGenerateReport+0x198>
    693e:	13 30       	cpi	r17, 0x03	; 3
    6940:	38 f4       	brcc	.+14     	; 0x6950 <systemGenerateReport+0x5c>
    6942:	11 23       	and	r17, r17
    6944:	31 f1       	breq	.+76     	; 0x6992 <systemGenerateReport+0x9e>
    6946:	11 30       	cpi	r17, 0x01	; 1
    6948:	11 f0       	breq	.+4      	; 0x694e <systemGenerateReport+0x5a>
    694a:	0c 94 93 3f 	jmp	0x7f26	; 0x7f26 <systemGenerateReport+0x1632>
    694e:	2d c0       	rjmp	.+90     	; 0x69aa <systemGenerateReport+0xb6>
    6950:	14 30       	cpi	r17, 0x04	; 4
    6952:	09 f4       	brne	.+2      	; 0x6956 <systemGenerateReport+0x62>
    6954:	c8 c1       	rjmp	.+912    	; 0x6ce6 <systemGenerateReport+0x3f2>
    6956:	15 30       	cpi	r17, 0x05	; 5
    6958:	08 f0       	brcs	.+2      	; 0x695c <systemGenerateReport+0x68>
    695a:	4c c7       	rjmp	.+3736   	; 0x77f4 <systemGenerateReport+0xf00>
    695c:	bb c1       	rjmp	.+886    	; 0x6cd4 <systemGenerateReport+0x3e0>
    695e:	19 30       	cpi	r17, 0x09	; 9
    6960:	09 f4       	brne	.+2      	; 0x6964 <systemGenerateReport+0x70>
    6962:	48 c7       	rjmp	.+3728   	; 0x77f4 <systemGenerateReport+0xf00>
    6964:	1a 30       	cpi	r17, 0x0A	; 10
    6966:	40 f4       	brcc	.+16     	; 0x6978 <systemGenerateReport+0x84>
    6968:	17 30       	cpi	r17, 0x07	; 7
    696a:	09 f4       	brne	.+2      	; 0x696e <systemGenerateReport+0x7a>
    696c:	aa c2       	rjmp	.+1364   	; 0x6ec2 <systemGenerateReport+0x5ce>
    696e:	18 30       	cpi	r17, 0x08	; 8
    6970:	11 f0       	breq	.+4      	; 0x6976 <systemGenerateReport+0x82>
    6972:	0c 94 93 3f 	jmp	0x7f26	; 0x7f26 <systemGenerateReport+0x1632>
    6976:	b3 c2       	rjmp	.+1382   	; 0x6ede <systemGenerateReport+0x5ea>
    6978:	1b 30       	cpi	r17, 0x0B	; 11
    697a:	11 f4       	brne	.+4      	; 0x6980 <systemGenerateReport+0x8c>
    697c:	0c 94 86 3f 	jmp	0x7f0c	; 0x7f0c <systemGenerateReport+0x1618>
    6980:	1b 30       	cpi	r17, 0x0B	; 11
    6982:	08 f4       	brcc	.+2      	; 0x6986 <systemGenerateReport+0x92>
    6984:	3e c7       	rjmp	.+3708   	; 0x7802 <systemGenerateReport+0xf0e>
    6986:	1c 30       	cpi	r17, 0x0C	; 12
    6988:	11 f0       	breq	.+4      	; 0x698e <systemGenerateReport+0x9a>
    698a:	0c 94 93 3f 	jmp	0x7f26	; 0x7f26 <systemGenerateReport+0x1632>
    698e:	0c 94 8e 3f 	jmp	0x7f1c	; 0x7f1c <systemGenerateReport+0x1628>
	 case grScanAction://Wait for Complete incoming Totalizer data	      
		  if (IsGenerateReport==True){
    6992:	80 91 89 01 	lds	r24, 0x0189
    6996:	81 30       	cpi	r24, 0x01	; 1
    6998:	11 f0       	breq	.+4      	; 0x699e <systemGenerateReport+0xaa>
    699a:	0c 94 93 3f 	jmp	0x7f26	; 0x7f26 <systemGenerateReport+0x1632>
		      IsGenerateReport=False;
    699e:	10 92 89 01 	sts	0x0189, r1
			  IsFinishPrintingTotalizer=False;
    69a2:	10 92 8a 01 	sts	0x018A, r1
    69a6:	0c 94 8b 3f 	jmp	0x7f16	; 0x7f16 <systemGenerateReport+0x1622>
			  stGenerateReport=grInitData;
		  }
	      break;
	 case grInitData:
	      xPump=1;
    69aa:	10 93 f9 01 	sts	0x01F9, r17
		  xNozzle=1;
    69ae:	10 93 f8 01 	sts	0x01F8, r17
		  RepPos=0;
    69b2:	10 92 e9 01 	sts	0x01E9, r1
    69b6:	10 92 e8 01 	sts	0x01E8, r1
    69ba:	ee ef       	ldi	r30, 0xFE	; 254
    69bc:	f4 e0       	ldi	r31, 0x04	; 4
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    69be:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    69c0:	86 e0       	ldi	r24, 0x06	; 6
    69c2:	ef 38       	cpi	r30, 0x8F	; 143
    69c4:	f8 07       	cpc	r31, r24
    69c6:	d9 f7       	brne	.-10     	; 0x69be <systemGenerateReport+0xca>
    69c8:	fe 01       	movw	r30, r28
    69ca:	eb 55       	subi	r30, 0x5B	; 91
    69cc:	ff 4f       	sbci	r31, 0xFF	; 255
	     strMemory[i]=data;
    69ce:	ce 01       	movw	r24, r28
    69d0:	8b 50       	subi	r24, 0x0B	; 11
    69d2:	9f 4f       	sbci	r25, 0xFF	; 255
    69d4:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    69d6:	e8 17       	cp	r30, r24
    69d8:	f9 07       	cpc	r31, r25
    69da:	e1 f7       	brne	.-8      	; 0x69d4 <systemGenerateReport+0xe0>
    69dc:	fe 01       	movw	r30, r28
    69de:	f7 96       	adiw	r30, 0x37	; 55
	     strMemory[i]=data;
    69e0:	cf 01       	movw	r24, r30
    69e2:	0f 96       	adiw	r24, 0x0f	; 15
    69e4:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    69e6:	e8 17       	cp	r30, r24
    69e8:	f9 07       	cpc	r31, r25
    69ea:	e1 f7       	brne	.-8      	; 0x69e4 <systemGenerateReport+0xf0>
    69ec:	fe 01       	movw	r30, r28
    69ee:	ea 5b       	subi	r30, 0xBA	; 186
    69f0:	ff 4f       	sbci	r31, 0xFF	; 255
	     strMemory[i]=data;
    69f2:	cf 01       	movw	r24, r30
    69f4:	0f 96       	adiw	r24, 0x0f	; 15
    69f6:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    69f8:	e8 17       	cp	r30, r24
    69fa:	f9 07       	cpc	r31, r25
    69fc:	e1 f7       	brne	.-8      	; 0x69f6 <systemGenerateReport+0x102>
    69fe:	eb e2       	ldi	r30, 0x2B	; 43
    6a00:	f9 e0       	ldi	r31, 0x09	; 9
	     strMemory[i]=data;
    6a02:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    6a04:	99 e0       	ldi	r25, 0x09	; 9
    6a06:	ef 33       	cpi	r30, 0x3F	; 63
    6a08:	f9 07       	cpc	r31, r25
    6a0a:	d9 f7       	brne	.-10     	; 0x6a02 <systemGenerateReport+0x10e>
    6a0c:	ec ed       	ldi	r30, 0xDC	; 220
    6a0e:	f9 e0       	ldi	r31, 0x09	; 9
	     strMemory[i]=data;
    6a10:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    6a12:	a9 e0       	ldi	r26, 0x09	; 9
    6a14:	e0 3f       	cpi	r30, 0xF0	; 240
    6a16:	fa 07       	cpc	r31, r26
    6a18:	d9 f7       	brne	.-10     	; 0x6a10 <systemGenerateReport+0x11c>
    6a1a:	e4 e6       	ldi	r30, 0x64	; 100
    6a1c:	fd e0       	ldi	r31, 0x0D	; 13
	     strMemory[i]=data;
    6a1e:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    6a20:	bd e0       	ldi	r27, 0x0D	; 13
    6a22:	e3 37       	cpi	r30, 0x73	; 115
    6a24:	fb 07       	cpc	r31, r27
    6a26:	d9 f7       	brne	.-10     	; 0x6a1e <systemGenerateReport+0x12a>
    6a28:	e9 e3       	ldi	r30, 0x39	; 57
    6a2a:	fa e0       	ldi	r31, 0x0A	; 10
	     strMemory[i]=data;
    6a2c:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    6a2e:	8a e0       	ldi	r24, 0x0A	; 10
    6a30:	e8 34       	cpi	r30, 0x48	; 72
    6a32:	f8 07       	cpc	r31, r24
    6a34:	d9 f7       	brne	.-10     	; 0x6a2c <systemGenerateReport+0x138>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    6a36:	e1 99       	sbic	0x1c, 1	; 28
    6a38:	fe cf       	rjmp	.-4      	; 0x6a36 <systemGenerateReport+0x142>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    6a3a:	8f e3       	ldi	r24, 0x3F	; 63
    6a3c:	91 e0       	ldi	r25, 0x01	; 1
    6a3e:	9f bb       	out	0x1f, r25	; 31
    6a40:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    6a42:	e0 9a       	sbi	0x1c, 0	; 28
    6a44:	2d b3       	in	r18, 0x1d	; 29
		  FillChar(strTotalMoney,sizeof(strTotalMoney),0);


		  FillChar(strDeltaMoney,sizeof(strDeltaMoney),0);
		  FillChar(strDeltaVolume,sizeof(strDeltaVolume),0);
		  sprintf_P(strShift,PSTR("%d"),eeprom_read_byte(&DefShift));
    6a46:	00 d0       	rcall	.+0      	; 0x6a48 <systemGenerateReport+0x154>
    6a48:	00 d0       	rcall	.+0      	; 0x6a4a <systemGenerateReport+0x156>
    6a4a:	00 d0       	rcall	.+0      	; 0x6a4c <systemGenerateReport+0x158>
    6a4c:	ed b7       	in	r30, 0x3d	; 61
    6a4e:	fe b7       	in	r31, 0x3e	; 62
    6a50:	31 96       	adiw	r30, 0x01	; 1
    6a52:	8f e9       	ldi	r24, 0x9F	; 159
    6a54:	9d e0       	ldi	r25, 0x0D	; 13
    6a56:	ad b7       	in	r26, 0x3d	; 61
    6a58:	be b7       	in	r27, 0x3e	; 62
    6a5a:	12 96       	adiw	r26, 0x02	; 2
    6a5c:	9c 93       	st	X, r25
    6a5e:	8e 93       	st	-X, r24
    6a60:	11 97       	sbiw	r26, 0x01	; 1
    6a62:	8c e6       	ldi	r24, 0x6C	; 108
    6a64:	95 e0       	ldi	r25, 0x05	; 5
    6a66:	93 83       	std	Z+3, r25	; 0x03
    6a68:	82 83       	std	Z+2, r24	; 0x02
    6a6a:	24 83       	std	Z+4, r18	; 0x04
    6a6c:	15 82       	std	Z+5, r1	; 0x05
    6a6e:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>

          stGenerateReport=grCreateReportHeader;
    6a72:	82 e0       	ldi	r24, 0x02	; 2
    6a74:	80 93 fa 01 	sts	0x01FA, r24
    6a78:	ed b7       	in	r30, 0x3d	; 61
    6a7a:	fe b7       	in	r31, 0x3e	; 62
    6a7c:	36 96       	adiw	r30, 0x06	; 6
    6a7e:	0f b6       	in	r0, 0x3f	; 63
    6a80:	f8 94       	cli
    6a82:	fe bf       	out	0x3e, r31	; 62
    6a84:	0f be       	out	0x3f, r0	; 63
    6a86:	ed bf       	out	0x3d, r30	; 61
    6a88:	0c 94 93 3f 	jmp	0x7f26	; 0x7f26 <systemGenerateReport+0x1632>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    6a8c:	ce 01       	movw	r24, r28
    6a8e:	8b 5a       	subi	r24, 0xAB	; 171
    6a90:	9f 4f       	sbci	r25, 0xFF	; 255
    6a92:	63 e4       	ldi	r22, 0x43	; 67
    6a94:	78 e0       	ldi	r23, 0x08	; 8
    6a96:	44 e1       	ldi	r20, 0x14	; 20
    6a98:	50 e0       	ldi	r21, 0x00	; 0
    6a9a:	2d ef       	ldi	r18, 0xFD	; 253
    6a9c:	32 e1       	ldi	r19, 0x12	; 18
    6a9e:	0e 94 f1 b3 	call	0x167e2	; 0x167e2 <__eerd_block>
	      break;
	 case grCreateReportHeader://Border: btTopLeft,btTopCenter,btTopRight,btMiddleLeft,btMiddleCenter,btMiddleRight,btBottomLeft,btBottomCenter,btBottomRight,btVertical,btHorizontal
		  eeprom_read_block((void*) &LastShiftDateTime, (const void*) &DefLastShiftDateTime, sizeof(DefLastShiftDateTime));
          
		  InserBorder(btTopLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btTopRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);
    6aa2:	81 e0       	ldi	r24, 0x01	; 1
    6aa4:	6e ef       	ldi	r22, 0xFE	; 254
    6aa6:	74 e0       	ldi	r23, 0x04	; 4
    6aa8:	41 e0       	ldi	r20, 0x01	; 1
    6aaa:	28 ee       	ldi	r18, 0xE8	; 232
    6aac:	31 e0       	ldi	r19, 0x01	; 1
    6aae:	0e 94 e1 19 	call	0x33c2	; 0x33c2 <InserBorder>
    6ab2:	8b e0       	ldi	r24, 0x0B	; 11
    6ab4:	6e ef       	ldi	r22, 0xFE	; 254
    6ab6:	74 e0       	ldi	r23, 0x04	; 4
    6ab8:	4a e2       	ldi	r20, 0x2A	; 42
    6aba:	28 ee       	ldi	r18, 0xE8	; 232
    6abc:	31 e0       	ldi	r19, 0x01	; 1
    6abe:	0e 94 e1 19 	call	0x33c2	; 0x33c2 <InserBorder>
    6ac2:	83 e0       	ldi	r24, 0x03	; 3
    6ac4:	6e ef       	ldi	r22, 0xFE	; 254
    6ac6:	74 e0       	ldi	r23, 0x04	; 4
    6ac8:	41 e0       	ldi	r20, 0x01	; 1
    6aca:	28 ee       	ldi	r18, 0xE8	; 232
    6acc:	31 e0       	ldi	r19, 0x01	; 1
    6ace:	0e 94 e1 19 	call	0x33c2	; 0x33c2 <InserBorder>
    6ad2:	8c e0       	ldi	r24, 0x0C	; 12
    6ad4:	6e ef       	ldi	r22, 0xFE	; 254
    6ad6:	74 e0       	ldi	r23, 0x04	; 4
    6ad8:	41 e0       	ldi	r20, 0x01	; 1
    6ada:	28 ee       	ldi	r18, 0xE8	; 232
    6adc:	31 e0       	ldi	r19, 0x01	; 1
    6ade:	0e 94 e1 19 	call	0x33c2	; 0x33c2 <InserBorder>
	      sprintf_P(strReport,PSTR("        Laporan Tutup Shift: %s      "),strShift);CreateReport(strReport,PrintBuffer,&RepPos);
    6ae2:	00 d0       	rcall	.+0      	; 0x6ae4 <systemGenerateReport+0x1f0>
    6ae4:	00 d0       	rcall	.+0      	; 0x6ae6 <systemGenerateReport+0x1f2>
    6ae6:	00 d0       	rcall	.+0      	; 0x6ae8 <systemGenerateReport+0x1f4>
    6ae8:	ed b7       	in	r30, 0x3d	; 61
    6aea:	fe b7       	in	r31, 0x3e	; 62
    6aec:	31 96       	adiw	r30, 0x01	; 1
    6aee:	8e 01       	movw	r16, r28
    6af0:	0b 55       	subi	r16, 0x5B	; 91
    6af2:	1f 4f       	sbci	r17, 0xFF	; 255
    6af4:	ad b7       	in	r26, 0x3d	; 61
    6af6:	be b7       	in	r27, 0x3e	; 62
    6af8:	12 96       	adiw	r26, 0x02	; 2
    6afa:	1c 93       	st	X, r17
    6afc:	0e 93       	st	-X, r16
    6afe:	11 97       	sbiw	r26, 0x01	; 1
    6b00:	86 e4       	ldi	r24, 0x46	; 70
    6b02:	95 e0       	ldi	r25, 0x05	; 5
    6b04:	93 83       	std	Z+3, r25	; 0x03
    6b06:	82 83       	std	Z+2, r24	; 0x02
    6b08:	8f e9       	ldi	r24, 0x9F	; 159
    6b0a:	9d e0       	ldi	r25, 0x0D	; 13
    6b0c:	95 83       	std	Z+5, r25	; 0x05
    6b0e:	84 83       	std	Z+4, r24	; 0x04
    6b10:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    6b14:	ed b7       	in	r30, 0x3d	; 61
    6b16:	fe b7       	in	r31, 0x3e	; 62
    6b18:	36 96       	adiw	r30, 0x06	; 6
    6b1a:	0f b6       	in	r0, 0x3f	; 63
    6b1c:	f8 94       	cli
    6b1e:	fe bf       	out	0x3e, r31	; 62
    6b20:	0f be       	out	0x3f, r0	; 63
    6b22:	ed bf       	out	0x3d, r30	; 61
    6b24:	c8 01       	movw	r24, r16
    6b26:	6e ef       	ldi	r22, 0xFE	; 254
    6b28:	74 e0       	ldi	r23, 0x04	; 4
    6b2a:	48 ee       	ldi	r20, 0xE8	; 232
    6b2c:	51 e0       	ldi	r21, 0x01	; 1
    6b2e:	0e 94 e9 21 	call	0x43d2	; 0x43d2 <CreateReport>
		  InserBorder(btMiddleLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btMiddleRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);     
    6b32:	84 e0       	ldi	r24, 0x04	; 4
    6b34:	6e ef       	ldi	r22, 0xFE	; 254
    6b36:	74 e0       	ldi	r23, 0x04	; 4
    6b38:	41 e0       	ldi	r20, 0x01	; 1
    6b3a:	28 ee       	ldi	r18, 0xE8	; 232
    6b3c:	31 e0       	ldi	r19, 0x01	; 1
    6b3e:	0e 94 e1 19 	call	0x33c2	; 0x33c2 <InserBorder>
    6b42:	8b e0       	ldi	r24, 0x0B	; 11
    6b44:	6e ef       	ldi	r22, 0xFE	; 254
    6b46:	74 e0       	ldi	r23, 0x04	; 4
    6b48:	4a e2       	ldi	r20, 0x2A	; 42
    6b4a:	28 ee       	ldi	r18, 0xE8	; 232
    6b4c:	31 e0       	ldi	r19, 0x01	; 1
    6b4e:	0e 94 e1 19 	call	0x33c2	; 0x33c2 <InserBorder>
    6b52:	86 e0       	ldi	r24, 0x06	; 6
    6b54:	6e ef       	ldi	r22, 0xFE	; 254
    6b56:	74 e0       	ldi	r23, 0x04	; 4
    6b58:	41 e0       	ldi	r20, 0x01	; 1
    6b5a:	28 ee       	ldi	r18, 0xE8	; 232
    6b5c:	31 e0       	ldi	r19, 0x01	; 1
    6b5e:	0e 94 e1 19 	call	0x33c2	; 0x33c2 <InserBorder>
    6b62:	8c e0       	ldi	r24, 0x0C	; 12
    6b64:	6e ef       	ldi	r22, 0xFE	; 254
    6b66:	74 e0       	ldi	r23, 0x04	; 4
    6b68:	41 e0       	ldi	r20, 0x01	; 1
    6b6a:	28 ee       	ldi	r18, 0xE8	; 232
    6b6c:	31 e0       	ldi	r19, 0x01	; 1
    6b6e:	0e 94 e1 19 	call	0x33c2	; 0x33c2 <InserBorder>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    6b72:	e1 99       	sbic	0x1c, 1	; 28
    6b74:	fe cf       	rjmp	.-4      	; 0x6b72 <systemGenerateReport+0x27e>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    6b76:	80 e0       	ldi	r24, 0x00	; 0
    6b78:	90 e0       	ldi	r25, 0x00	; 0
    6b7a:	9f bb       	out	0x1f, r25	; 31
    6b7c:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    6b7e:	e0 9a       	sbi	0x1c, 0	; 28
    6b80:	2d b3       	in	r18, 0x1d	; 29
	      sprintf_P(strReport,PSTR("Terminal ID : %.2d                   "),eeprom_read_byte(&DefIFT_ID));CreateReport(strReport,PrintBuffer,&RepPos);
    6b82:	00 d0       	rcall	.+0      	; 0x6b84 <systemGenerateReport+0x290>
    6b84:	00 d0       	rcall	.+0      	; 0x6b86 <systemGenerateReport+0x292>
    6b86:	00 d0       	rcall	.+0      	; 0x6b88 <systemGenerateReport+0x294>
    6b88:	ed b7       	in	r30, 0x3d	; 61
    6b8a:	fe b7       	in	r31, 0x3e	; 62
    6b8c:	31 96       	adiw	r30, 0x01	; 1
    6b8e:	8e 01       	movw	r16, r28
    6b90:	0b 55       	subi	r16, 0x5B	; 91
    6b92:	1f 4f       	sbci	r17, 0xFF	; 255
    6b94:	ad b7       	in	r26, 0x3d	; 61
    6b96:	be b7       	in	r27, 0x3e	; 62
    6b98:	12 96       	adiw	r26, 0x02	; 2
    6b9a:	1c 93       	st	X, r17
    6b9c:	0e 93       	st	-X, r16
    6b9e:	11 97       	sbiw	r26, 0x01	; 1
    6ba0:	80 e2       	ldi	r24, 0x20	; 32
    6ba2:	95 e0       	ldi	r25, 0x05	; 5
    6ba4:	93 83       	std	Z+3, r25	; 0x03
    6ba6:	82 83       	std	Z+2, r24	; 0x02
    6ba8:	24 83       	std	Z+4, r18	; 0x04
    6baa:	15 82       	std	Z+5, r1	; 0x05
    6bac:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    6bb0:	ed b7       	in	r30, 0x3d	; 61
    6bb2:	fe b7       	in	r31, 0x3e	; 62
    6bb4:	36 96       	adiw	r30, 0x06	; 6
    6bb6:	0f b6       	in	r0, 0x3f	; 63
    6bb8:	f8 94       	cli
    6bba:	fe bf       	out	0x3e, r31	; 62
    6bbc:	0f be       	out	0x3f, r0	; 63
    6bbe:	ed bf       	out	0x3d, r30	; 61
    6bc0:	c8 01       	movw	r24, r16
    6bc2:	6e ef       	ldi	r22, 0xFE	; 254
    6bc4:	74 e0       	ldi	r23, 0x04	; 4
    6bc6:	48 ee       	ldi	r20, 0xE8	; 232
    6bc8:	51 e0       	ldi	r21, 0x01	; 1
    6bca:	0e 94 e9 21 	call	0x43d2	; 0x43d2 <CreateReport>
	      sprintf_P(strReport,PSTR("Awal  Shift : %s "),LastShiftDateTime);             CreateReport(strReport,PrintBuffer,&RepPos);
    6bce:	00 d0       	rcall	.+0      	; 0x6bd0 <systemGenerateReport+0x2dc>
    6bd0:	00 d0       	rcall	.+0      	; 0x6bd2 <systemGenerateReport+0x2de>
    6bd2:	00 d0       	rcall	.+0      	; 0x6bd4 <systemGenerateReport+0x2e0>
    6bd4:	ed b7       	in	r30, 0x3d	; 61
    6bd6:	fe b7       	in	r31, 0x3e	; 62
    6bd8:	31 96       	adiw	r30, 0x01	; 1
    6bda:	ad b7       	in	r26, 0x3d	; 61
    6bdc:	be b7       	in	r27, 0x3e	; 62
    6bde:	12 96       	adiw	r26, 0x02	; 2
    6be0:	1c 93       	st	X, r17
    6be2:	0e 93       	st	-X, r16
    6be4:	11 97       	sbiw	r26, 0x01	; 1
    6be6:	8e e0       	ldi	r24, 0x0E	; 14
    6be8:	95 e0       	ldi	r25, 0x05	; 5
    6bea:	93 83       	std	Z+3, r25	; 0x03
    6bec:	82 83       	std	Z+2, r24	; 0x02
    6bee:	ce 01       	movw	r24, r28
    6bf0:	8b 5a       	subi	r24, 0xAB	; 171
    6bf2:	9f 4f       	sbci	r25, 0xFF	; 255
    6bf4:	95 83       	std	Z+5, r25	; 0x05
    6bf6:	84 83       	std	Z+4, r24	; 0x04
    6bf8:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    6bfc:	ed b7       	in	r30, 0x3d	; 61
    6bfe:	fe b7       	in	r31, 0x3e	; 62
    6c00:	36 96       	adiw	r30, 0x06	; 6
    6c02:	0f b6       	in	r0, 0x3f	; 63
    6c04:	f8 94       	cli
    6c06:	fe bf       	out	0x3e, r31	; 62
    6c08:	0f be       	out	0x3f, r0	; 63
    6c0a:	ed bf       	out	0x3d, r30	; 61
    6c0c:	c8 01       	movw	r24, r16
    6c0e:	6e ef       	ldi	r22, 0xFE	; 254
    6c10:	74 e0       	ldi	r23, 0x04	; 4
    6c12:	48 ee       	ldi	r20, 0xE8	; 232
    6c14:	51 e0       	ldi	r21, 0x01	; 1
    6c16:	0e 94 e9 21 	call	0x43d2	; 0x43d2 <CreateReport>
	      sprintf_P(strReport,PSTR("Akhir Shift : %s "),CurrentShiftDateTime);      CreateReport(strReport,PrintBuffer,&RepPos);
    6c1a:	00 d0       	rcall	.+0      	; 0x6c1c <systemGenerateReport+0x328>
    6c1c:	00 d0       	rcall	.+0      	; 0x6c1e <systemGenerateReport+0x32a>
    6c1e:	00 d0       	rcall	.+0      	; 0x6c20 <systemGenerateReport+0x32c>
    6c20:	ed b7       	in	r30, 0x3d	; 61
    6c22:	fe b7       	in	r31, 0x3e	; 62
    6c24:	31 96       	adiw	r30, 0x01	; 1
    6c26:	ad b7       	in	r26, 0x3d	; 61
    6c28:	be b7       	in	r27, 0x3e	; 62
    6c2a:	12 96       	adiw	r26, 0x02	; 2
    6c2c:	1c 93       	st	X, r17
    6c2e:	0e 93       	st	-X, r16
    6c30:	11 97       	sbiw	r26, 0x01	; 1
    6c32:	8c ef       	ldi	r24, 0xFC	; 252
    6c34:	94 e0       	ldi	r25, 0x04	; 4
    6c36:	93 83       	std	Z+3, r25	; 0x03
    6c38:	82 83       	std	Z+2, r24	; 0x02
    6c3a:	80 ea       	ldi	r24, 0xA0	; 160
    6c3c:	98 e0       	ldi	r25, 0x08	; 8
    6c3e:	95 83       	std	Z+5, r25	; 0x05
    6c40:	84 83       	std	Z+4, r24	; 0x04
    6c42:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    6c46:	ed b7       	in	r30, 0x3d	; 61
    6c48:	fe b7       	in	r31, 0x3e	; 62
    6c4a:	36 96       	adiw	r30, 0x06	; 6
    6c4c:	0f b6       	in	r0, 0x3f	; 63
    6c4e:	f8 94       	cli
    6c50:	fe bf       	out	0x3e, r31	; 62
    6c52:	0f be       	out	0x3f, r0	; 63
    6c54:	ed bf       	out	0x3d, r30	; 61
    6c56:	c8 01       	movw	r24, r16
    6c58:	6e ef       	ldi	r22, 0xFE	; 254
    6c5a:	74 e0       	ldi	r23, 0x04	; 4
    6c5c:	48 ee       	ldi	r20, 0xE8	; 232
    6c5e:	51 e0       	ldi	r21, 0x01	; 1
    6c60:	0e 94 e9 21 	call	0x43d2	; 0x43d2 <CreateReport>
	      //sprintf_P(strReport,PSTR("Transaksi   : %s "),DeltaTransaction);      CreateReport(strReport,PrintBuffer,&RepPos);
          InserBorder(btBottomLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btBottomRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);
    6c64:	87 e0       	ldi	r24, 0x07	; 7
    6c66:	6e ef       	ldi	r22, 0xFE	; 254
    6c68:	74 e0       	ldi	r23, 0x04	; 4
    6c6a:	41 e0       	ldi	r20, 0x01	; 1
    6c6c:	28 ee       	ldi	r18, 0xE8	; 232
    6c6e:	31 e0       	ldi	r19, 0x01	; 1
    6c70:	0e 94 e1 19 	call	0x33c2	; 0x33c2 <InserBorder>
    6c74:	8b e0       	ldi	r24, 0x0B	; 11
    6c76:	6e ef       	ldi	r22, 0xFE	; 254
    6c78:	74 e0       	ldi	r23, 0x04	; 4
    6c7a:	4a e2       	ldi	r20, 0x2A	; 42
    6c7c:	28 ee       	ldi	r18, 0xE8	; 232
    6c7e:	31 e0       	ldi	r19, 0x01	; 1
    6c80:	0e 94 e1 19 	call	0x33c2	; 0x33c2 <InserBorder>
    6c84:	89 e0       	ldi	r24, 0x09	; 9
    6c86:	6e ef       	ldi	r22, 0xFE	; 254
    6c88:	74 e0       	ldi	r23, 0x04	; 4
    6c8a:	41 e0       	ldi	r20, 0x01	; 1
    6c8c:	28 ee       	ldi	r18, 0xE8	; 232
    6c8e:	31 e0       	ldi	r19, 0x01	; 1
    6c90:	0e 94 e1 19 	call	0x33c2	; 0x33c2 <InserBorder>
    6c94:	8c e0       	ldi	r24, 0x0C	; 12
    6c96:	6e ef       	ldi	r22, 0xFE	; 254
    6c98:	74 e0       	ldi	r23, 0x04	; 4
    6c9a:	41 e0       	ldi	r20, 0x01	; 1
    6c9c:	28 ee       	ldi	r18, 0xE8	; 232
    6c9e:	31 e0       	ldi	r19, 0x01	; 1
    6ca0:	0e 94 e1 19 	call	0x33c2	; 0x33c2 <InserBorder>
		  /*
	      if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("PUMP-PRODUCT   VOLUME(L)    RUPIAH(RP)"));         
	      else sprintf_P(strReport,PSTR("PUMP-PRODUCT   VOLUME(L)              "));CreateReport(strReport,PrintBuffer,&RepPos);
          InserBorder(btBottomLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btBottomRight,PrintBuffer,1,&RepPos);//InserBorder(btNewLine,PrintBuffer,1,&RepPos);         		 
          */
		  ClearList(GradeList);
    6ca4:	8a ee       	ldi	r24, 0xEA	; 234
    6ca6:	91 e0       	ldi	r25, 0x01	; 1
    6ca8:	0e 94 8a 22 	call	0x4514	; 0x4514 <ClearList>
		  cmdPrint=0b10000000;//PrintHeader
    6cac:	80 e8       	ldi	r24, 0x80	; 128
    6cae:	80 93 b7 01 	sts	0x01B7, r24
		  LengthMessage81=RepPos+1;
    6cb2:	80 91 e8 01 	lds	r24, 0x01E8
    6cb6:	90 91 e9 01 	lds	r25, 0x01E9
    6cba:	01 96       	adiw	r24, 0x01	; 1
    6cbc:	90 93 91 01 	sts	0x0191, r25
    6cc0:	80 93 90 01 	sts	0x0190, r24
		  IsFreePrinting=True;
    6cc4:	81 e0       	ldi	r24, 0x01	; 1
    6cc6:	80 93 ab 01 	sts	0x01AB, r24
          IsBusyFreePrinting=True;
    6cca:	80 93 b6 01 	sts	0x01B6, r24
		  		  
          stGenerateReport=grWaitPrinted1;
    6cce:	83 e0       	ldi	r24, 0x03	; 3
    6cd0:	0c 94 8b 3f 	jmp	0x7f16	; 0x7f16 <systemGenerateReport+0x1622>
	      break;
     case grWaitPrinted1:
          if (IsBusyFreePrinting==False)
    6cd4:	80 91 b6 01 	lds	r24, 0x01B6
    6cd8:	88 23       	and	r24, r24
    6cda:	11 f0       	breq	.+4      	; 0x6ce0 <systemGenerateReport+0x3ec>
    6cdc:	0c 94 93 3f 	jmp	0x7f26	; 0x7f26 <systemGenerateReport+0x1632>
		      stGenerateReport=grGenerateLabel;//grGenerateReportData;//grFinishGenerateReport;
    6ce0:	84 e0       	ldi	r24, 0x04	; 4
    6ce2:	0c 94 8b 3f 	jmp	0x7f16	; 0x7f16 <systemGenerateReport+0x1622>
	      break;
     case grGenerateLabel:
          RepPos=0;
    6ce6:	10 92 e9 01 	sts	0x01E9, r1
    6cea:	10 92 e8 01 	sts	0x01E8, r1
          InserBorder(btTopLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btTopRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          
    6cee:	81 e0       	ldi	r24, 0x01	; 1
    6cf0:	6e ef       	ldi	r22, 0xFE	; 254
    6cf2:	74 e0       	ldi	r23, 0x04	; 4
    6cf4:	41 e0       	ldi	r20, 0x01	; 1
    6cf6:	28 ee       	ldi	r18, 0xE8	; 232
    6cf8:	31 e0       	ldi	r19, 0x01	; 1
    6cfa:	0e 94 e1 19 	call	0x33c2	; 0x33c2 <InserBorder>
    6cfe:	8b e0       	ldi	r24, 0x0B	; 11
    6d00:	6e ef       	ldi	r22, 0xFE	; 254
    6d02:	74 e0       	ldi	r23, 0x04	; 4
    6d04:	4a e2       	ldi	r20, 0x2A	; 42
    6d06:	28 ee       	ldi	r18, 0xE8	; 232
    6d08:	31 e0       	ldi	r19, 0x01	; 1
    6d0a:	0e 94 e1 19 	call	0x33c2	; 0x33c2 <InserBorder>
    6d0e:	83 e0       	ldi	r24, 0x03	; 3
    6d10:	6e ef       	ldi	r22, 0xFE	; 254
    6d12:	74 e0       	ldi	r23, 0x04	; 4
    6d14:	41 e0       	ldi	r20, 0x01	; 1
    6d16:	28 ee       	ldi	r18, 0xE8	; 232
    6d18:	31 e0       	ldi	r19, 0x01	; 1
    6d1a:	0e 94 e1 19 	call	0x33c2	; 0x33c2 <InserBorder>
    6d1e:	8c e0       	ldi	r24, 0x0C	; 12
    6d20:	6e ef       	ldi	r22, 0xFE	; 254
    6d22:	74 e0       	ldi	r23, 0x04	; 4
    6d24:	41 e0       	ldi	r20, 0x01	; 1
    6d26:	28 ee       	ldi	r18, 0xE8	; 232
    6d28:	31 e0       	ldi	r19, 0x01	; 1
    6d2a:	0e 94 e1 19 	call	0x33c2	; 0x33c2 <InserBorder>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    6d2e:	e1 99       	sbic	0x1c, 1	; 28
    6d30:	fe cf       	rjmp	.-4      	; 0x6d2e <systemGenerateReport+0x43a>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    6d32:	81 ec       	ldi	r24, 0xC1	; 193
    6d34:	93 e0       	ldi	r25, 0x03	; 3
    6d36:	9f bb       	out	0x1f, r25	; 31
    6d38:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    6d3a:	e0 9a       	sbi	0x1c, 0	; 28
    6d3c:	8d b3       	in	r24, 0x1d	; 29
    6d3e:	9e 01       	movw	r18, r28
    6d40:	2b 55       	subi	r18, 0x5B	; 91
    6d42:	3f 4f       	sbci	r19, 0xFF	; 255
	      if (eeprom_read_byte(&DefPrintMoney)==True)
    6d44:	81 30       	cpi	r24, 0x01	; 1
    6d46:	79 f4       	brne	.+30     	; 0x6d66 <systemGenerateReport+0x472>
		       sprintf_P(strReport,PSTR("PUMP-PRODUCT   VOLUME(L)    RUPIAH(RP)"));         
    6d48:	00 d0       	rcall	.+0      	; 0x6d4a <systemGenerateReport+0x456>
    6d4a:	00 d0       	rcall	.+0      	; 0x6d4c <systemGenerateReport+0x458>
    6d4c:	ad b7       	in	r26, 0x3d	; 61
    6d4e:	be b7       	in	r27, 0x3e	; 62
    6d50:	12 96       	adiw	r26, 0x02	; 2
    6d52:	3c 93       	st	X, r19
    6d54:	2e 93       	st	-X, r18
    6d56:	11 97       	sbiw	r26, 0x01	; 1
    6d58:	85 ed       	ldi	r24, 0xD5	; 213
    6d5a:	94 e0       	ldi	r25, 0x04	; 4
    6d5c:	14 96       	adiw	r26, 0x04	; 4
    6d5e:	9c 93       	st	X, r25
    6d60:	8e 93       	st	-X, r24
    6d62:	13 97       	sbiw	r26, 0x03	; 3
    6d64:	0a c0       	rjmp	.+20     	; 0x6d7a <systemGenerateReport+0x486>
	      else sprintf_P(strReport,PSTR("PUMP-PRODUCT   VOLUME(L)              "));CreateReport(strReport,PrintBuffer,&RepPos);
    6d66:	00 d0       	rcall	.+0      	; 0x6d68 <systemGenerateReport+0x474>
    6d68:	00 d0       	rcall	.+0      	; 0x6d6a <systemGenerateReport+0x476>
    6d6a:	ed b7       	in	r30, 0x3d	; 61
    6d6c:	fe b7       	in	r31, 0x3e	; 62
    6d6e:	32 83       	std	Z+2, r19	; 0x02
    6d70:	21 83       	std	Z+1, r18	; 0x01
    6d72:	8e ea       	ldi	r24, 0xAE	; 174
    6d74:	94 e0       	ldi	r25, 0x04	; 4
    6d76:	94 83       	std	Z+4, r25	; 0x04
    6d78:	83 83       	std	Z+3, r24	; 0x03
    6d7a:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    6d7e:	0f 90       	pop	r0
    6d80:	0f 90       	pop	r0
    6d82:	0f 90       	pop	r0
    6d84:	0f 90       	pop	r0
    6d86:	ce 01       	movw	r24, r28
    6d88:	8b 55       	subi	r24, 0x5B	; 91
    6d8a:	9f 4f       	sbci	r25, 0xFF	; 255
    6d8c:	6e ef       	ldi	r22, 0xFE	; 254
    6d8e:	74 e0       	ldi	r23, 0x04	; 4
    6d90:	48 ee       	ldi	r20, 0xE8	; 232
    6d92:	51 e0       	ldi	r21, 0x01	; 1
    6d94:	0e 94 e9 21 	call	0x43d2	; 0x43d2 <CreateReport>
          InserBorder(btBottomLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btBottomRight,PrintBuffer,1,&RepPos);//InserBorder(btNewLine,PrintBuffer,1,&RepPos);         		 
    6d98:	87 e0       	ldi	r24, 0x07	; 7
    6d9a:	6e ef       	ldi	r22, 0xFE	; 254
    6d9c:	74 e0       	ldi	r23, 0x04	; 4
    6d9e:	41 e0       	ldi	r20, 0x01	; 1
    6da0:	28 ee       	ldi	r18, 0xE8	; 232
    6da2:	31 e0       	ldi	r19, 0x01	; 1
    6da4:	0e 94 e1 19 	call	0x33c2	; 0x33c2 <InserBorder>
    6da8:	8b e0       	ldi	r24, 0x0B	; 11
    6daa:	6e ef       	ldi	r22, 0xFE	; 254
    6dac:	74 e0       	ldi	r23, 0x04	; 4
    6dae:	4a e2       	ldi	r20, 0x2A	; 42
    6db0:	28 ee       	ldi	r18, 0xE8	; 232
    6db2:	31 e0       	ldi	r19, 0x01	; 1
    6db4:	0e 94 e1 19 	call	0x33c2	; 0x33c2 <InserBorder>
    6db8:	89 e0       	ldi	r24, 0x09	; 9
    6dba:	6e ef       	ldi	r22, 0xFE	; 254
    6dbc:	74 e0       	ldi	r23, 0x04	; 4
    6dbe:	41 e0       	ldi	r20, 0x01	; 1
    6dc0:	28 ee       	ldi	r18, 0xE8	; 232
    6dc2:	31 e0       	ldi	r19, 0x01	; 1
    6dc4:	0e 94 e1 19 	call	0x33c2	; 0x33c2 <InserBorder>
          
		  cmdPrint=0b00000000;
    6dc8:	10 92 b7 01 	sts	0x01B7, r1
		  LengthMessage81=RepPos+1;
    6dcc:	80 91 e8 01 	lds	r24, 0x01E8
    6dd0:	90 91 e9 01 	lds	r25, 0x01E9
    6dd4:	01 96       	adiw	r24, 0x01	; 1
    6dd6:	90 93 91 01 	sts	0x0191, r25
    6dda:	80 93 90 01 	sts	0x0190, r24

		  IsFreePrinting=True;
    6dde:	81 e0       	ldi	r24, 0x01	; 1
    6de0:	80 93 ab 01 	sts	0x01AB, r24
	      IsBusyFreePrinting=True;
    6de4:	80 93 b6 01 	sts	0x01B6, r24

		  stGenerateReport=grWaitLabelPrinted;
    6de8:	85 e0       	ldi	r24, 0x05	; 5
    6dea:	0c 94 8b 3f 	jmp	0x7f16	; 0x7f16 <systemGenerateReport+0x1622>
          if (IsBusyFreePrinting==False)
		      stGenerateReport=grGenerateReportData;//grFinishGenerateReport;
	      break;
     case grGenerateReportData:
	      //Generate: PumpNum, Nozzle, Product
	      if ((xPump>=1)&&(xPump<=8)){
    6dee:	80 91 f9 01 	lds	r24, 0x01F9
    6df2:	81 50       	subi	r24, 0x01	; 1
    6df4:	88 30       	cpi	r24, 0x08	; 8
    6df6:	10 f0       	brcs	.+4      	; 0x6dfc <systemGenerateReport+0x508>
    6df8:	0c 94 93 3f 	jmp	0x7f26	; 0x7f26 <systemGenerateReport+0x1632>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    6dfc:	ce 01       	movw	r24, r28
    6dfe:	07 96       	adiw	r24, 0x07	; 7
    6e00:	65 e4       	ldi	r22, 0x45	; 69
    6e02:	70 e0       	ldi	r23, 0x00	; 0
    6e04:	48 e0       	ldi	r20, 0x08	; 8
    6e06:	50 e0       	ldi	r21, 0x00	; 0
    6e08:	2d ef       	ldi	r18, 0xFD	; 253
    6e0a:	32 e1       	ldi	r19, 0x12	; 18
    6e0c:	0e 94 f1 b3 	call	0x167e2	; 0x167e2 <__eerd_block>
		      eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap, 8);
			  PumpNum=PPumpID[xPump-1];
    6e10:	90 91 f9 01 	lds	r25, 0x01F9
    6e14:	fe 01       	movw	r30, r28
    6e16:	e9 0f       	add	r30, r25
    6e18:	f1 1d       	adc	r31, r1
    6e1a:	86 81       	ldd	r24, Z+6	; 0x06
    6e1c:	80 93 f6 01 	sts	0x01F6, r24
			  if (PumpNum>0){
    6e20:	88 23       	and	r24, r24
    6e22:	09 f4       	brne	.+2      	; 0x6e26 <systemGenerateReport+0x532>
    6e24:	4b c0       	rjmp	.+150    	; 0x6ebc <systemGenerateReport+0x5c8>
    6e26:	91 9f       	mul	r25, r17
    6e28:	b0 01       	movw	r22, r0
    6e2a:	11 24       	eor	r1, r1
    6e2c:	61 5b       	subi	r22, 0xB1	; 177
    6e2e:	7f 4f       	sbci	r23, 0xFF	; 255
    6e30:	ce 01       	movw	r24, r28
    6e32:	01 96       	adiw	r24, 0x01	; 1
    6e34:	46 e0       	ldi	r20, 0x06	; 6
    6e36:	50 e0       	ldi	r21, 0x00	; 0
    6e38:	2d ef       	ldi	r18, 0xFD	; 253
    6e3a:	32 e1       	ldi	r19, 0x12	; 18
    6e3c:	0e 94 f1 b3 	call	0x167e2	; 0x167e2 <__eerd_block>
				  eeprom_read_block((void*) &PProductID, (const void*) &DefNozzleMap[xPump-1], 6);
				  xGrade=PProductID[xNozzle-1];
    6e40:	80 91 f8 01 	lds	r24, 0x01F8
    6e44:	fe 01       	movw	r30, r28
    6e46:	e8 0f       	add	r30, r24
    6e48:	f1 1d       	adc	r31, r1
    6e4a:	80 81       	ld	r24, Z
    6e4c:	80 93 f7 01 	sts	0x01F7, r24
    6e50:	e0 e7       	ldi	r30, 0x70	; 112
    6e52:	ce 2e       	mov	r12, r30
    6e54:	e8 e0       	ldi	r30, 0x08	; 8
    6e56:	de 2e       	mov	r13, r30

				  if (xGrade>0){
    6e58:	88 23       	and	r24, r24
    6e5a:	99 f0       	breq	.+38     	; 0x6e82 <systemGenerateReport+0x58e>
				      GetProductName(xGrade,strProduct);
    6e5c:	b6 01       	movw	r22, r12
    6e5e:	0e 94 bb 2d 	call	0x5b76	; 0x5b76 <GetProductName>
                      GradeUsed=xGrade;
    6e62:	80 91 f7 01 	lds	r24, 0x01F7
    6e66:	80 93 f4 01 	sts	0x01F4, r24
					  xGrade=xNozzle;//
    6e6a:	80 91 f8 01 	lds	r24, 0x01F8
    6e6e:	80 93 f7 01 	sts	0x01F7, r24
					  PumpNozzle=xNozzle;
    6e72:	80 93 f5 01 	sts	0x01F5, r24
					  xNozzle++;
    6e76:	8f 5f       	subi	r24, 0xFF	; 255
    6e78:	80 93 f8 01 	sts	0x01F8, r24
					  stGenerateReport=grCreateReportTotalizer;
    6e7c:	88 e0       	ldi	r24, 0x08	; 8
    6e7e:	0c 94 8b 3f 	jmp	0x7f16	; 0x7f16 <systemGenerateReport+0x1622>
				  }
				  else{sprintf_P(strProduct,PSTR("N/A"));			  
    6e82:	00 d0       	rcall	.+0      	; 0x6e84 <systemGenerateReport+0x590>
    6e84:	00 d0       	rcall	.+0      	; 0x6e86 <systemGenerateReport+0x592>
    6e86:	ad b7       	in	r26, 0x3d	; 61
    6e88:	be b7       	in	r27, 0x3e	; 62
    6e8a:	12 96       	adiw	r26, 0x02	; 2
    6e8c:	dc 92       	st	X, r13
    6e8e:	ce 92       	st	-X, r12
    6e90:	11 97       	sbiw	r26, 0x01	; 1
    6e92:	8a ea       	ldi	r24, 0xAA	; 170
    6e94:	94 e0       	ldi	r25, 0x04	; 4
    6e96:	14 96       	adiw	r26, 0x04	; 4
    6e98:	9c 93       	st	X, r25
    6e9a:	8e 93       	st	-X, r24
    6e9c:	13 97       	sbiw	r26, 0x03	; 3
    6e9e:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
					   xNozzle++;
    6ea2:	80 91 f8 01 	lds	r24, 0x01F8
    6ea6:	8f 5f       	subi	r24, 0xFF	; 255
    6ea8:	80 93 f8 01 	sts	0x01F8, r24
					   if (xNozzle>6)stGenerateReport=grNextPump;
    6eac:	0f 90       	pop	r0
    6eae:	0f 90       	pop	r0
    6eb0:	0f 90       	pop	r0
    6eb2:	0f 90       	pop	r0
    6eb4:	87 30       	cpi	r24, 0x07	; 7
    6eb6:	10 f4       	brcc	.+4      	; 0x6ebc <systemGenerateReport+0x5c8>
    6eb8:	0c 94 93 3f 	jmp	0x7f26	; 0x7f26 <systemGenerateReport+0x1632>
					  }
				}else stGenerateReport=grNextPump;
    6ebc:	87 e0       	ldi	r24, 0x07	; 7
    6ebe:	0c 94 8b 3f 	jmp	0x7f16	; 0x7f16 <systemGenerateReport+0x1622>
			  }
	      break;
     case grNextPump:
	      xNozzle=1;
    6ec2:	81 e0       	ldi	r24, 0x01	; 1
    6ec4:	80 93 f8 01 	sts	0x01F8, r24
	      xPump++;
    6ec8:	80 91 f9 01 	lds	r24, 0x01F9
    6ecc:	8f 5f       	subi	r24, 0xFF	; 255
    6ece:	80 93 f9 01 	sts	0x01F9, r24
	      if (xPump>8)stGenerateReport=grCreateReportFooter;
    6ed2:	89 30       	cpi	r24, 0x09	; 9
    6ed4:	08 f4       	brcc	.+2      	; 0x6ed8 <systemGenerateReport+0x5e4>
    6ed6:	93 c4       	rjmp	.+2342   	; 0x77fe <systemGenerateReport+0xf0a>
    6ed8:	8a e0       	ldi	r24, 0x0A	; 10
    6eda:	0c 94 8b 3f 	jmp	0x7f16	; 0x7f16 <systemGenerateReport+0x1622>
		  else stGenerateReport=grGenerateReportData;
	      break;
     case grCreateReportTotalizer:

          RepPos=0;
    6ede:	10 92 e9 01 	sts	0x01E9, r1
    6ee2:	10 92 e8 01 	sts	0x01E8, r1
    6ee6:	ee ef       	ldi	r30, 0xFE	; 254
    6ee8:	f4 e0       	ldi	r31, 0x04	; 4
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    6eea:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    6eec:	b6 e0       	ldi	r27, 0x06	; 6
    6eee:	ef 38       	cpi	r30, 0x8F	; 143
    6ef0:	fb 07       	cpc	r31, r27
    6ef2:	d9 f7       	brne	.-10     	; 0x6eea <systemGenerateReport+0x5f6>
    6ef4:	fe 01       	movw	r30, r28
    6ef6:	eb 55       	subi	r30, 0x5B	; 91
    6ef8:	ff 4f       	sbci	r31, 0xFF	; 255
	     strMemory[i]=data;
    6efa:	ce 01       	movw	r24, r28
    6efc:	8b 50       	subi	r24, 0x0B	; 11
    6efe:	9f 4f       	sbci	r25, 0xFF	; 255
    6f00:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    6f02:	e8 17       	cp	r30, r24
    6f04:	f9 07       	cpc	r31, r25
    6f06:	e1 f7       	brne	.-8      	; 0x6f00 <systemGenerateReport+0x60c>
    6f08:	e4 e6       	ldi	r30, 0x64	; 100
    6f0a:	fd e0       	ldi	r31, 0x0D	; 13
	     strMemory[i]=data;
    6f0c:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    6f0e:	8d e0       	ldi	r24, 0x0D	; 13
    6f10:	e3 37       	cpi	r30, 0x73	; 115
    6f12:	f8 07       	cpc	r31, r24
    6f14:	d9 f7       	brne	.-10     	; 0x6f0c <systemGenerateReport+0x618>
    6f16:	e9 e3       	ldi	r30, 0x39	; 57
    6f18:	fa e0       	ldi	r31, 0x0A	; 10
	     strMemory[i]=data;
    6f1a:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    6f1c:	9a e0       	ldi	r25, 0x0A	; 10
    6f1e:	e8 34       	cpi	r30, 0x48	; 72
    6f20:	f9 07       	cpc	r31, r25
    6f22:	d9 f7       	brne	.-10     	; 0x6f1a <systemGenerateReport+0x626>
    6f24:	fe 01       	movw	r30, r28
    6f26:	79 96       	adiw	r30, 0x19	; 25
	     strMemory[i]=data;
    6f28:	ce 01       	movw	r24, r28
    6f2a:	88 96       	adiw	r24, 0x28	; 40
    6f2c:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    6f2e:	e8 17       	cp	r30, r24
    6f30:	f9 07       	cpc	r31, r25
    6f32:	e1 f7       	brne	.-8      	; 0x6f2c <systemGenerateReport+0x638>
	     strMemory[i]=data;
    6f34:	ce 01       	movw	r24, r28
    6f36:	c7 96       	adiw	r24, 0x37	; 55
    6f38:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    6f3a:	e8 17       	cp	r30, r24
    6f3c:	f9 07       	cpc	r31, r25
    6f3e:	e1 f7       	brne	.-8      	; 0x6f38 <systemGenerateReport+0x644>
	     strMemory[i]=data;
    6f40:	cf 01       	movw	r24, r30
    6f42:	0f 96       	adiw	r24, 0x0f	; 15
    6f44:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    6f46:	e8 17       	cp	r30, r24
    6f48:	f9 07       	cpc	r31, r25
    6f4a:	e1 f7       	brne	.-8      	; 0x6f44 <systemGenerateReport+0x650>
    6f4c:	fe 01       	movw	r30, r28
    6f4e:	ea 5b       	subi	r30, 0xBA	; 186
    6f50:	ff 4f       	sbci	r31, 0xFF	; 255
	     strMemory[i]=data;
    6f52:	cf 01       	movw	r24, r30
    6f54:	ee 2e       	mov	r14, r30
    6f56:	d9 2e       	mov	r13, r25
    6f58:	0f 96       	adiw	r24, 0x0f	; 15
    6f5a:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    6f5c:	e8 17       	cp	r30, r24
    6f5e:	f9 07       	cpc	r31, r25
    6f60:	e1 f7       	brne	.-8      	; 0x6f5a <systemGenerateReport+0x666>
		  FillChar(strLastMoney,sizeof(strLastMoney),0);

		  FillChar(strCurrentVolume,sizeof(strCurrentVolume),0);
		  FillChar(strCurrentMoney,sizeof(strCurrentMoney),0);

          FIPAddr=GetFIPAddr(PumpNum); 
    6f62:	80 91 f6 01 	lds	r24, 0x01F6
    6f66:	0e 94 41 1d 	call	0x3a82	; 0x3a82 <GetFIPAddr>
		  if (FIPAddr>0){
    6f6a:	88 23       	and	r24, r24
    6f6c:	49 f1       	breq	.+82     	; 0x6fc0 <systemGenerateReport+0x6cc>
		      FIPAddr=FIPAddr-1;		  
    6f6e:	f8 2e       	mov	r15, r24
    6f70:	fa 94       	dec	r15
			  GetTotalizerData(TVOLUME,TOTALIZER_LAST,FIPAddr,PumpNozzle,strLastVolume);
    6f72:	80 e0       	ldi	r24, 0x00	; 0
    6f74:	60 e0       	ldi	r22, 0x00	; 0
    6f76:	4f 2d       	mov	r20, r15
    6f78:	20 91 f5 01 	lds	r18, 0x01F5
    6f7c:	8e 01       	movw	r16, r28
    6f7e:	07 5e       	subi	r16, 0xE7	; 231
    6f80:	1f 4f       	sbci	r17, 0xFF	; 255
    6f82:	0e 94 00 1e 	call	0x3c00	; 0x3c00 <GetTotalizerData>
			  GetTotalizerData(TMONEY,TOTALIZER_LAST,FIPAddr,PumpNozzle,strLastMoney);
    6f86:	81 e0       	ldi	r24, 0x01	; 1
    6f88:	60 e0       	ldi	r22, 0x00	; 0
    6f8a:	4f 2d       	mov	r20, r15
    6f8c:	20 91 f5 01 	lds	r18, 0x01F5
    6f90:	8e 01       	movw	r16, r28
    6f92:	08 5d       	subi	r16, 0xD8	; 216
    6f94:	1f 4f       	sbci	r17, 0xFF	; 255
    6f96:	0e 94 00 1e 	call	0x3c00	; 0x3c00 <GetTotalizerData>

			  GetTotalizerData(TVOLUME,TOTALIZER_NOW,FIPAddr,PumpNozzle,strCurrentVolume);
    6f9a:	80 e0       	ldi	r24, 0x00	; 0
    6f9c:	61 e0       	ldi	r22, 0x01	; 1
    6f9e:	4f 2d       	mov	r20, r15
    6fa0:	20 91 f5 01 	lds	r18, 0x01F5
    6fa4:	8e 01       	movw	r16, r28
    6fa6:	09 5c       	subi	r16, 0xC9	; 201
    6fa8:	1f 4f       	sbci	r17, 0xFF	; 255
    6faa:	0e 94 00 1e 	call	0x3c00	; 0x3c00 <GetTotalizerData>
			  GetTotalizerData(TMONEY,TOTALIZER_NOW,FIPAddr,PumpNozzle,strCurrentMoney);
    6fae:	81 e0       	ldi	r24, 0x01	; 1
    6fb0:	61 e0       	ldi	r22, 0x01	; 1
    6fb2:	4f 2d       	mov	r20, r15
    6fb4:	20 91 f5 01 	lds	r18, 0x01F5
    6fb8:	0e 2d       	mov	r16, r14
    6fba:	1d 2d       	mov	r17, r13
    6fbc:	0e 94 00 1e 	call	0x3c00	; 0x3c00 <GetTotalizerData>
		  }

		  StrCalc(TMINUS,strCurrentVolume,strLastVolume,strDeltaVolume);
    6fc0:	80 e0       	ldi	r24, 0x00	; 0
    6fc2:	be 01       	movw	r22, r28
    6fc4:	69 5c       	subi	r22, 0xC9	; 201
    6fc6:	7f 4f       	sbci	r23, 0xFF	; 255
    6fc8:	ae 01       	movw	r20, r28
    6fca:	47 5e       	subi	r20, 0xE7	; 231
    6fcc:	5f 4f       	sbci	r21, 0xFF	; 255
    6fce:	29 e3       	ldi	r18, 0x39	; 57
    6fd0:	3a e0       	ldi	r19, 0x0A	; 10
    6fd2:	0e 94 53 29 	call	0x52a6	; 0x52a6 <StrCalc>

		  if (IsMinus(strDeltaVolume)==True)
    6fd6:	89 e3       	ldi	r24, 0x39	; 57
    6fd8:	9a e0       	ldi	r25, 0x0A	; 10
    6fda:	0e 94 4e 23 	call	0x469c	; 0x469c <IsMinus>
    6fde:	81 30       	cpi	r24, 0x01	; 1
    6fe0:	21 f4       	brne	.+8      	; 0x6fea <systemGenerateReport+0x6f6>
		      NormalizeOverflow(strDeltaVolume);
    6fe2:	89 e3       	ldi	r24, 0x39	; 57
    6fe4:	9a e0       	ldi	r25, 0x0A	; 10
    6fe6:	0e 94 ea 2c 	call	0x59d4	; 0x59d4 <NormalizeOverflow>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    6fea:	e1 99       	sbic	0x1c, 1	; 28
    6fec:	fe cf       	rjmp	.-4      	; 0x6fea <systemGenerateReport+0x6f6>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    6fee:	77 e3       	ldi	r23, 0x37	; 55
    6ff0:	87 2e       	mov	r8, r23
    6ff2:	71 e0       	ldi	r23, 0x01	; 1
    6ff4:	97 2e       	mov	r9, r23
    6ff6:	9f ba       	out	0x1f, r9	; 31
    6ff8:	8e ba       	out	0x1e, r8	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    6ffa:	e0 9a       	sbi	0x1c, 0	; 28
    6ffc:	8d b3       	in	r24, 0x1d	; 29

		  //Calculate Wayne Estimated Total Money
		  if (eeprom_read_byte(&DefDispenserBrand)==ST_WAYNE_DART){
    6ffe:	82 30       	cpi	r24, 0x02	; 2
    7000:	79 f4       	brne	.+30     	; 0x7020 <systemGenerateReport+0x72c>
              GetProductPrice(sPrice,PumpNum,PumpNozzle);//Money = Price x Volume
    7002:	8e 01       	movw	r16, r28
    7004:	01 5f       	subi	r16, 0xF1	; 241
    7006:	1f 4f       	sbci	r17, 0xFF	; 255
    7008:	c8 01       	movw	r24, r16
    700a:	60 91 f6 01 	lds	r22, 0x01F6
    700e:	40 91 f5 01 	lds	r20, 0x01F5
    7012:	0e 94 31 24 	call	0x4862	; 0x4862 <GetProductPrice>
			  StrCalc(TMULTIPLY,sPrice,strDeltaVolume,strDeltaMoney);
    7016:	82 e0       	ldi	r24, 0x02	; 2
    7018:	b8 01       	movw	r22, r16
    701a:	49 e3       	ldi	r20, 0x39	; 57
    701c:	5a e0       	ldi	r21, 0x0A	; 10
    701e:	07 c0       	rjmp	.+14     	; 0x702e <systemGenerateReport+0x73a>
			  
		  }else StrCalc(TMINUS,strCurrentMoney,strLastMoney,strDeltaMoney);
    7020:	80 e0       	ldi	r24, 0x00	; 0
    7022:	be 01       	movw	r22, r28
    7024:	6a 5b       	subi	r22, 0xBA	; 186
    7026:	7f 4f       	sbci	r23, 0xFF	; 255
    7028:	ae 01       	movw	r20, r28
    702a:	48 5d       	subi	r20, 0xD8	; 216
    702c:	5f 4f       	sbci	r21, 0xFF	; 255
    702e:	24 e6       	ldi	r18, 0x64	; 100
    7030:	3d e0       	ldi	r19, 0x0D	; 13
    7032:	0e 94 53 29 	call	0x52a6	; 0x52a6 <StrCalc>

		  if (IsMinus(strDeltaMoney)==True)
    7036:	84 e6       	ldi	r24, 0x64	; 100
    7038:	9d e0       	ldi	r25, 0x0D	; 13
    703a:	0e 94 4e 23 	call	0x469c	; 0x469c <IsMinus>
    703e:	81 30       	cpi	r24, 0x01	; 1
    7040:	21 f4       	brne	.+8      	; 0x704a <systemGenerateReport+0x756>
		      NormalizeOverflow(strDeltaMoney);
    7042:	84 e6       	ldi	r24, 0x64	; 100
    7044:	9d e0       	ldi	r25, 0x0D	; 13
    7046:	0e 94 ea 2c 	call	0x59d4	; 0x59d4 <NormalizeOverflow>

		  AddList(GradeUsed,GradeList);
    704a:	80 91 f4 01 	lds	r24, 0x01F4
    704e:	6a ee       	ldi	r22, 0xEA	; 234
    7050:	71 e0       	ldi	r23, 0x01	; 1
    7052:	0e 94 57 22 	call	0x44ae	; 0x44ae <AddList>
		  
		  StrCalc(TPLUS,strTotalVolume,strDeltaVolume,strTotalVolume);
    7056:	81 e0       	ldi	r24, 0x01	; 1
    7058:	6b e2       	ldi	r22, 0x2B	; 43
    705a:	79 e0       	ldi	r23, 0x09	; 9
    705c:	49 e3       	ldi	r20, 0x39	; 57
    705e:	5a e0       	ldi	r21, 0x0A	; 10
    7060:	9b 01       	movw	r18, r22
    7062:	0e 94 53 29 	call	0x52a6	; 0x52a6 <StrCalc>
		  StrCalc(TPLUS,strTotalMoney,strDeltaMoney,strTotalMoney);
    7066:	81 e0       	ldi	r24, 0x01	; 1
    7068:	6c ed       	ldi	r22, 0xDC	; 220
    706a:	79 e0       	ldi	r23, 0x09	; 9
    706c:	44 e6       	ldi	r20, 0x64	; 100
    706e:	5d e0       	ldi	r21, 0x0D	; 13
    7070:	9b 01       	movw	r18, r22
    7072:	0e 94 53 29 	call	0x52a6	; 0x52a6 <StrCalc>


		  RemZeroLead(strDeltaMoney);
    7076:	84 e6       	ldi	r24, 0x64	; 100
    7078:	9d e0       	ldi	r25, 0x0D	; 13
    707a:	0e 94 19 25 	call	0x4a32	; 0x4a32 <RemZeroLead>
		  RemZeroLead(strCurrentMoney);
    707e:	66 e4       	ldi	r22, 0x46	; 70
    7080:	c6 2e       	mov	r12, r22
    7082:	d1 2c       	mov	r13, r1
    7084:	cc 0e       	add	r12, r28
    7086:	dd 1e       	adc	r13, r29
    7088:	c6 01       	movw	r24, r12
    708a:	0e 94 19 25 	call	0x4a32	; 0x4a32 <RemZeroLead>
		  RemZeroLead(strLastMoney);
    708e:	58 e2       	ldi	r21, 0x28	; 40
    7090:	e5 2e       	mov	r14, r21
    7092:	f1 2c       	mov	r15, r1
    7094:	ec 0e       	add	r14, r28
    7096:	fd 1e       	adc	r15, r29
    7098:	c7 01       	movw	r24, r14
    709a:	0e 94 19 25 	call	0x4a32	; 0x4a32 <RemZeroLead>

          RemZeroLead(strDeltaVolume);
    709e:	89 e3       	ldi	r24, 0x39	; 57
    70a0:	9a e0       	ldi	r25, 0x0A	; 10
    70a2:	0e 94 19 25 	call	0x4a32	; 0x4a32 <RemZeroLead>
          RemZeroLead(strCurrentVolume);
    70a6:	47 e3       	ldi	r20, 0x37	; 55
    70a8:	a4 2e       	mov	r10, r20
    70aa:	b1 2c       	mov	r11, r1
    70ac:	ac 0e       	add	r10, r28
    70ae:	bd 1e       	adc	r11, r29
    70b0:	c5 01       	movw	r24, r10
    70b2:	0e 94 19 25 	call	0x4a32	; 0x4a32 <RemZeroLead>
          RemZeroLead(strLastVolume);
    70b6:	8e 01       	movw	r16, r28
    70b8:	07 5e       	subi	r16, 0xE7	; 231
    70ba:	1f 4f       	sbci	r17, 0xFF	; 255
    70bc:	c8 01       	movw	r24, r16
    70be:	0e 94 19 25 	call	0x4a32	; 0x4a32 <RemZeroLead>

		  FormatTotalizerMoney(strDeltaMoney);
    70c2:	84 e6       	ldi	r24, 0x64	; 100
    70c4:	9d e0       	ldi	r25, 0x0D	; 13
    70c6:	0e 94 46 34 	call	0x688c	; 0x688c <FormatTotalizerMoney>
		  FormatTotalizerMoney(strCurrentMoney);
    70ca:	c6 01       	movw	r24, r12
    70cc:	0e 94 46 34 	call	0x688c	; 0x688c <FormatTotalizerMoney>
		  FormatTotalizerMoney(strLastMoney);
    70d0:	c7 01       	movw	r24, r14
    70d2:	0e 94 46 34 	call	0x688c	; 0x688c <FormatTotalizerMoney>

		  FormatTotalizerVolume(strDeltaVolume);
    70d6:	89 e3       	ldi	r24, 0x39	; 57
    70d8:	9a e0       	ldi	r25, 0x0A	; 10
    70da:	0e 94 39 34 	call	0x6872	; 0x6872 <FormatTotalizerVolume>
		  FormatTotalizerVolume(strLastVolume);
    70de:	c8 01       	movw	r24, r16
    70e0:	0e 94 39 34 	call	0x6872	; 0x6872 <FormatTotalizerVolume>
		  FormatTotalizerVolume(strCurrentVolume); 
    70e4:	c5 01       	movw	r24, r10
    70e6:	0e 94 39 34 	call	0x6872	; 0x6872 <FormatTotalizerVolume>

          FormatCurrency(strDeltaMoney);
    70ea:	84 e6       	ldi	r24, 0x64	; 100
    70ec:	9d e0       	ldi	r25, 0x0D	; 13
    70ee:	0e 94 09 33 	call	0x6612	; 0x6612 <FormatCurrency>
		  FormatCurrency(strCurrentMoney);
    70f2:	c6 01       	movw	r24, r12
    70f4:	0e 94 09 33 	call	0x6612	; 0x6612 <FormatCurrency>
		  FormatCurrency(strLastMoney);
    70f8:	c7 01       	movw	r24, r14
    70fa:	0e 94 09 33 	call	0x6612	; 0x6612 <FormatCurrency>

		  FormatCurrency(strDeltaVolume);		  
    70fe:	89 e3       	ldi	r24, 0x39	; 57
    7100:	9a e0       	ldi	r25, 0x0A	; 10
    7102:	0e 94 09 33 	call	0x6612	; 0x6612 <FormatCurrency>
		  FormatCurrency(strLastVolume);
    7106:	c8 01       	movw	r24, r16
    7108:	0e 94 09 33 	call	0x6612	; 0x6612 <FormatCurrency>
          FormatCurrency(strCurrentVolume);
    710c:	c5 01       	movw	r24, r10
    710e:	0e 94 09 33 	call	0x6612	; 0x6612 <FormatCurrency>


          InserBorder(btTopLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btTopRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          
    7112:	81 e0       	ldi	r24, 0x01	; 1
    7114:	6e ef       	ldi	r22, 0xFE	; 254
    7116:	74 e0       	ldi	r23, 0x04	; 4
    7118:	41 e0       	ldi	r20, 0x01	; 1
    711a:	28 ee       	ldi	r18, 0xE8	; 232
    711c:	31 e0       	ldi	r19, 0x01	; 1
    711e:	0e 94 e1 19 	call	0x33c2	; 0x33c2 <InserBorder>
    7122:	8b e0       	ldi	r24, 0x0B	; 11
    7124:	6e ef       	ldi	r22, 0xFE	; 254
    7126:	74 e0       	ldi	r23, 0x04	; 4
    7128:	4a e2       	ldi	r20, 0x2A	; 42
    712a:	28 ee       	ldi	r18, 0xE8	; 232
    712c:	31 e0       	ldi	r19, 0x01	; 1
    712e:	0e 94 e1 19 	call	0x33c2	; 0x33c2 <InserBorder>
    7132:	83 e0       	ldi	r24, 0x03	; 3
    7134:	6e ef       	ldi	r22, 0xFE	; 254
    7136:	74 e0       	ldi	r23, 0x04	; 4
    7138:	41 e0       	ldi	r20, 0x01	; 1
    713a:	28 ee       	ldi	r18, 0xE8	; 232
    713c:	31 e0       	ldi	r19, 0x01	; 1
    713e:	0e 94 e1 19 	call	0x33c2	; 0x33c2 <InserBorder>
    7142:	8c e0       	ldi	r24, 0x0C	; 12
    7144:	6e ef       	ldi	r22, 0xFE	; 254
    7146:	74 e0       	ldi	r23, 0x04	; 4
    7148:	41 e0       	ldi	r20, 0x01	; 1
    714a:	28 ee       	ldi	r18, 0xE8	; 232
    714c:	31 e0       	ldi	r19, 0x01	; 1
    714e:	0e 94 e1 19 	call	0x33c2	; 0x33c2 <InserBorder>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    7152:	e1 99       	sbic	0x1c, 1	; 28
    7154:	fe cf       	rjmp	.-4      	; 0x7152 <systemGenerateReport+0x85e>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    7156:	9f ba       	out	0x1f, r9	; 31
    7158:	8e ba       	out	0x1e, r8	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    715a:	e0 9a       	sbi	0x1c, 0	; 28
    715c:	8d b3       	in	r24, 0x1d	; 29
    715e:	30 e7       	ldi	r19, 0x70	; 112
    7160:	c3 2e       	mov	r12, r19
    7162:	38 e0       	ldi	r19, 0x08	; 8
    7164:	d3 2e       	mov	r13, r19
          if (eeprom_read_byte(&DefDispenserBrand)==ST_WAYNE_DART){
    7166:	82 30       	cpi	r24, 0x02	; 2
    7168:	09 f0       	breq	.+2      	; 0x716c <systemGenerateReport+0x878>
    716a:	84 c0       	rjmp	.+264    	; 0x7274 <systemGenerateReport+0x980>
		      GetProductPrice(sPrice,PumpNum,PumpNozzle);
    716c:	2f e0       	ldi	r18, 0x0F	; 15
    716e:	e2 2e       	mov	r14, r18
    7170:	f1 2c       	mov	r15, r1
    7172:	ec 0e       	add	r14, r28
    7174:	fd 1e       	adc	r15, r29
    7176:	c7 01       	movw	r24, r14
    7178:	60 91 f6 01 	lds	r22, 0x01F6
    717c:	40 91 f5 01 	lds	r20, 0x01F5
    7180:	0e 94 31 24 	call	0x4862	; 0x4862 <GetProductPrice>
			  sprintf_P(strProductPrice,PSTR("Harga: Rp.%s"),sPrice);
    7184:	00 d0       	rcall	.+0      	; 0x7186 <systemGenerateReport+0x892>
    7186:	00 d0       	rcall	.+0      	; 0x7188 <systemGenerateReport+0x894>
    7188:	00 d0       	rcall	.+0      	; 0x718a <systemGenerateReport+0x896>
    718a:	ed b7       	in	r30, 0x3d	; 61
    718c:	fe b7       	in	r31, 0x3e	; 62
    718e:	31 96       	adiw	r30, 0x01	; 1
    7190:	8e 01       	movw	r16, r28
    7192:	0f 56       	subi	r16, 0x6F	; 111
    7194:	1f 4f       	sbci	r17, 0xFF	; 255
    7196:	ad b7       	in	r26, 0x3d	; 61
    7198:	be b7       	in	r27, 0x3e	; 62
    719a:	12 96       	adiw	r26, 0x02	; 2
    719c:	1c 93       	st	X, r17
    719e:	0e 93       	st	-X, r16
    71a0:	11 97       	sbiw	r26, 0x01	; 1
    71a2:	8d e9       	ldi	r24, 0x9D	; 157
    71a4:	94 e0       	ldi	r25, 0x04	; 4
    71a6:	93 83       	std	Z+3, r25	; 0x03
    71a8:	82 83       	std	Z+2, r24	; 0x02
    71aa:	f5 82       	std	Z+5, r15	; 0x05
    71ac:	e4 82       	std	Z+4, r14	; 0x04
    71ae:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>

		      GetTabSpace(((17+10-strlen(strProduct))-strlen(strProductPrice)),strTabSpace2);
    71b2:	d6 01       	movw	r26, r12
    71b4:	0d 90       	ld	r0, X+
    71b6:	00 20       	and	r0, r0
    71b8:	e9 f7       	brne	.-6      	; 0x71b4 <systemGenerateReport+0x8c0>
    71ba:	11 97       	sbiw	r26, 0x01	; 1
    71bc:	ac 19       	sub	r26, r12
    71be:	bd 09       	sbc	r27, r13
    71c0:	f8 01       	movw	r30, r16
    71c2:	01 90       	ld	r0, Z+
    71c4:	00 20       	and	r0, r0
    71c6:	e9 f7       	brne	.-6      	; 0x71c2 <systemGenerateReport+0x8ce>
    71c8:	31 97       	sbiw	r30, 0x01	; 1
    71ca:	0e 1b       	sub	r16, r30
    71cc:	0a 1b       	sub	r16, r26
    71ce:	05 5e       	subi	r16, 0xE5	; 229
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    71d0:	ed b7       	in	r30, 0x3d	; 61
    71d2:	fe b7       	in	r31, 0x3e	; 62
    71d4:	36 96       	adiw	r30, 0x06	; 6
    71d6:	0f b6       	in	r0, 0x3f	; 63
    71d8:	f8 94       	cli
    71da:	fe bf       	out	0x3e, r31	; 62
    71dc:	0f be       	out	0x3f, r0	; 63
    71de:	ed bf       	out	0x3d, r30	; 61
    71e0:	fe 01       	movw	r30, r28
    71e2:	e3 58       	subi	r30, 0x83	; 131
    71e4:	ff 4f       	sbci	r31, 0xFF	; 255
    71e6:	10 16       	cp	r1, r16
    71e8:	74 f4       	brge	.+28     	; 0x7206 <systemGenerateReport+0x912>
    71ea:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    71ec:	90 e2       	ldi	r25, 0x20	; 32
    71ee:	02 c0       	rjmp	.+4      	; 0x71f4 <systemGenerateReport+0x900>
    71f0:	91 93       	st	Z+, r25

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    71f2:	8f 5f       	subi	r24, 0xFF	; 255
    71f4:	80 17       	cp	r24, r16
    71f6:	e0 f3       	brcs	.-8      	; 0x71f0 <systemGenerateReport+0x8fc>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    71f8:	fe 01       	movw	r30, r28
    71fa:	e3 58       	subi	r30, 0x83	; 131
    71fc:	ff 4f       	sbci	r31, 0xFF	; 255
    71fe:	e0 0f       	add	r30, r16
    7200:	f1 1d       	adc	r31, r1
    7202:	10 82       	st	Z, r1
    7204:	03 c0       	rjmp	.+6      	; 0x720c <systemGenerateReport+0x918>
     }else{
	 strTab[0]=' ';
    7206:	80 e2       	ldi	r24, 0x20	; 32
    7208:	80 83       	st	Z, r24
	 strTab[1]=0;
    720a:	11 82       	std	Z+1, r1	; 0x01
          if (eeprom_read_byte(&DefDispenserBrand)==ST_WAYNE_DART){
		      GetProductPrice(sPrice,PumpNum,PumpNozzle);
			  sprintf_P(strProductPrice,PSTR("Harga: Rp.%s"),sPrice);

		      GetTabSpace(((17+10-strlen(strProduct))-strlen(strProductPrice)),strTabSpace2);
		      sprintf_P(strReport,PSTR("P%d.%d - %s %s %s"),PumpNum,PumpNozzle,strProduct,strTabSpace2,strProductPrice);
    720c:	8d b7       	in	r24, 0x3d	; 61
    720e:	9e b7       	in	r25, 0x3e	; 62
    7210:	0e 97       	sbiw	r24, 0x0e	; 14
    7212:	0f b6       	in	r0, 0x3f	; 63
    7214:	f8 94       	cli
    7216:	9e bf       	out	0x3e, r25	; 62
    7218:	0f be       	out	0x3f, r0	; 63
    721a:	8d bf       	out	0x3d, r24	; 61
    721c:	ed b7       	in	r30, 0x3d	; 61
    721e:	fe b7       	in	r31, 0x3e	; 62
    7220:	31 96       	adiw	r30, 0x01	; 1
    7222:	ce 01       	movw	r24, r28
    7224:	8b 55       	subi	r24, 0x5B	; 91
    7226:	9f 4f       	sbci	r25, 0xFF	; 255
    7228:	ad b7       	in	r26, 0x3d	; 61
    722a:	be b7       	in	r27, 0x3e	; 62
    722c:	12 96       	adiw	r26, 0x02	; 2
    722e:	9c 93       	st	X, r25
    7230:	8e 93       	st	-X, r24
    7232:	11 97       	sbiw	r26, 0x01	; 1
    7234:	8b e8       	ldi	r24, 0x8B	; 139
    7236:	94 e0       	ldi	r25, 0x04	; 4
    7238:	93 83       	std	Z+3, r25	; 0x03
    723a:	82 83       	std	Z+2, r24	; 0x02
    723c:	80 91 f6 01 	lds	r24, 0x01F6
    7240:	84 83       	std	Z+4, r24	; 0x04
    7242:	15 82       	std	Z+5, r1	; 0x05
    7244:	80 91 f5 01 	lds	r24, 0x01F5
    7248:	86 83       	std	Z+6, r24	; 0x06
    724a:	17 82       	std	Z+7, r1	; 0x07
    724c:	80 e7       	ldi	r24, 0x70	; 112
    724e:	98 e0       	ldi	r25, 0x08	; 8
    7250:	91 87       	std	Z+9, r25	; 0x09
    7252:	80 87       	std	Z+8, r24	; 0x08
    7254:	ce 01       	movw	r24, r28
    7256:	83 58       	subi	r24, 0x83	; 131
    7258:	9f 4f       	sbci	r25, 0xFF	; 255
    725a:	93 87       	std	Z+11, r25	; 0x0b
    725c:	82 87       	std	Z+10, r24	; 0x0a
    725e:	ce 01       	movw	r24, r28
    7260:	8f 56       	subi	r24, 0x6F	; 111
    7262:	9f 4f       	sbci	r25, 0xFF	; 255
    7264:	95 87       	std	Z+13, r25	; 0x0d
    7266:	84 87       	std	Z+12, r24	; 0x0c
    7268:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    726c:	ed b7       	in	r30, 0x3d	; 61
    726e:	fe b7       	in	r31, 0x3e	; 62
    7270:	3e 96       	adiw	r30, 0x0e	; 14
    7272:	27 c0       	rjmp	.+78     	; 0x72c2 <systemGenerateReport+0x9ce>
		  }
		  else sprintf_P(strReport,PSTR("P%d.%d - %s "),PumpNum,PumpNozzle,strProduct);
    7274:	8d b7       	in	r24, 0x3d	; 61
    7276:	9e b7       	in	r25, 0x3e	; 62
    7278:	0a 97       	sbiw	r24, 0x0a	; 10
    727a:	0f b6       	in	r0, 0x3f	; 63
    727c:	f8 94       	cli
    727e:	9e bf       	out	0x3e, r25	; 62
    7280:	0f be       	out	0x3f, r0	; 63
    7282:	8d bf       	out	0x3d, r24	; 61
    7284:	ed b7       	in	r30, 0x3d	; 61
    7286:	fe b7       	in	r31, 0x3e	; 62
    7288:	31 96       	adiw	r30, 0x01	; 1
    728a:	ce 01       	movw	r24, r28
    728c:	8b 55       	subi	r24, 0x5B	; 91
    728e:	9f 4f       	sbci	r25, 0xFF	; 255
    7290:	ad b7       	in	r26, 0x3d	; 61
    7292:	be b7       	in	r27, 0x3e	; 62
    7294:	12 96       	adiw	r26, 0x02	; 2
    7296:	9c 93       	st	X, r25
    7298:	8e 93       	st	-X, r24
    729a:	11 97       	sbiw	r26, 0x01	; 1
    729c:	8e e7       	ldi	r24, 0x7E	; 126
    729e:	94 e0       	ldi	r25, 0x04	; 4
    72a0:	93 83       	std	Z+3, r25	; 0x03
    72a2:	82 83       	std	Z+2, r24	; 0x02
    72a4:	80 91 f6 01 	lds	r24, 0x01F6
    72a8:	84 83       	std	Z+4, r24	; 0x04
    72aa:	15 82       	std	Z+5, r1	; 0x05
    72ac:	80 91 f5 01 	lds	r24, 0x01F5
    72b0:	86 83       	std	Z+6, r24	; 0x06
    72b2:	17 82       	std	Z+7, r1	; 0x07
    72b4:	d1 86       	std	Z+9, r13	; 0x09
    72b6:	c0 86       	std	Z+8, r12	; 0x08
    72b8:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    72bc:	ed b7       	in	r30, 0x3d	; 61
    72be:	fe b7       	in	r31, 0x3e	; 62
    72c0:	3a 96       	adiw	r30, 0x0a	; 10
    72c2:	0f b6       	in	r0, 0x3f	; 63
    72c4:	f8 94       	cli
    72c6:	fe bf       	out	0x3e, r31	; 62
    72c8:	0f be       	out	0x3f, r0	; 63
    72ca:	ed bf       	out	0x3d, r30	; 61
		  CreateReport(strReport,PrintBuffer,&RepPos);
    72cc:	ce 01       	movw	r24, r28
    72ce:	8b 55       	subi	r24, 0x5B	; 91
    72d0:	9f 4f       	sbci	r25, 0xFF	; 255
    72d2:	6e ef       	ldi	r22, 0xFE	; 254
    72d4:	74 e0       	ldi	r23, 0x04	; 4
    72d6:	48 ee       	ldi	r20, 0xE8	; 232
    72d8:	51 e0       	ldi	r21, 0x01	; 1
    72da:	0e 94 e9 21 	call	0x43d2	; 0x43d2 <CreateReport>
          InserBorder(btMiddleLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btMiddleRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          
    72de:	84 e0       	ldi	r24, 0x04	; 4
    72e0:	6e ef       	ldi	r22, 0xFE	; 254
    72e2:	74 e0       	ldi	r23, 0x04	; 4
    72e4:	41 e0       	ldi	r20, 0x01	; 1
    72e6:	28 ee       	ldi	r18, 0xE8	; 232
    72e8:	31 e0       	ldi	r19, 0x01	; 1
    72ea:	0e 94 e1 19 	call	0x33c2	; 0x33c2 <InserBorder>
    72ee:	8b e0       	ldi	r24, 0x0B	; 11
    72f0:	6e ef       	ldi	r22, 0xFE	; 254
    72f2:	74 e0       	ldi	r23, 0x04	; 4
    72f4:	4a e2       	ldi	r20, 0x2A	; 42
    72f6:	28 ee       	ldi	r18, 0xE8	; 232
    72f8:	31 e0       	ldi	r19, 0x01	; 1
    72fa:	0e 94 e1 19 	call	0x33c2	; 0x33c2 <InserBorder>
    72fe:	86 e0       	ldi	r24, 0x06	; 6
    7300:	6e ef       	ldi	r22, 0xFE	; 254
    7302:	74 e0       	ldi	r23, 0x04	; 4
    7304:	41 e0       	ldi	r20, 0x01	; 1
    7306:	28 ee       	ldi	r18, 0xE8	; 232
    7308:	31 e0       	ldi	r19, 0x01	; 1
    730a:	0e 94 e1 19 	call	0x33c2	; 0x33c2 <InserBorder>
    730e:	8c e0       	ldi	r24, 0x0C	; 12
    7310:	6e ef       	ldi	r22, 0xFE	; 254
    7312:	74 e0       	ldi	r23, 0x04	; 4
    7314:	41 e0       	ldi	r20, 0x01	; 1
    7316:	28 ee       	ldi	r18, 0xE8	; 232
    7318:	31 e0       	ldi	r19, 0x01	; 1
    731a:	0e 94 e1 19 	call	0x33c2	; 0x33c2 <InserBorder>

		  GetTabSpace((17-strlen(strCurrentVolume)),strTabSpace);
    731e:	de 01       	movw	r26, r28
    7320:	d7 96       	adiw	r26, 0x37	; 55
    7322:	fd 01       	movw	r30, r26
    7324:	01 90       	ld	r0, Z+
    7326:	00 20       	and	r0, r0
    7328:	e9 f7       	brne	.-6      	; 0x7324 <systemGenerateReport+0xa30>
    732a:	9a 2f       	mov	r25, r26
    732c:	9e 1b       	sub	r25, r30
    732e:	9e 5e       	subi	r25, 0xEE	; 238
    7330:	de 01       	movw	r26, r28
    7332:	a7 59       	subi	r26, 0x97	; 151
    7334:	bf 4f       	sbci	r27, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    7336:	19 16       	cp	r1, r25
    7338:	7c f4       	brge	.+30     	; 0x7358 <systemGenerateReport+0xa64>
    733a:	fd 01       	movw	r30, r26
    733c:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    733e:	20 e2       	ldi	r18, 0x20	; 32
    7340:	02 c0       	rjmp	.+4      	; 0x7346 <systemGenerateReport+0xa52>
    7342:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    7344:	8f 5f       	subi	r24, 0xFF	; 255
    7346:	89 17       	cp	r24, r25
    7348:	e0 f3       	brcs	.-8      	; 0x7342 <systemGenerateReport+0xa4e>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    734a:	fe 01       	movw	r30, r28
    734c:	e7 59       	subi	r30, 0x97	; 151
    734e:	ff 4f       	sbci	r31, 0xFF	; 255
    7350:	e9 0f       	add	r30, r25
    7352:	f1 1d       	adc	r31, r1
    7354:	10 82       	st	Z, r1
    7356:	04 c0       	rjmp	.+8      	; 0x7360 <systemGenerateReport+0xa6c>
     }else{
	 strTab[0]=' ';
    7358:	80 e2       	ldi	r24, 0x20	; 32
    735a:	8c 93       	st	X, r24
	 strTab[1]=0;
    735c:	11 96       	adiw	r26, 0x01	; 1
    735e:	1c 92       	st	X, r1
		  else sprintf_P(strReport,PSTR("P%d.%d - %s "),PumpNum,PumpNozzle,strProduct);
		  CreateReport(strReport,PrintBuffer,&RepPos);
          InserBorder(btMiddleLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btMiddleRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          

		  GetTabSpace((17-strlen(strCurrentVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strCurrentMoney)),strTabSpace2);
    7360:	de 01       	movw	r26, r28
    7362:	aa 5b       	subi	r26, 0xBA	; 186
    7364:	bf 4f       	sbci	r27, 0xFF	; 255
    7366:	fd 01       	movw	r30, r26
    7368:	01 90       	ld	r0, Z+
    736a:	00 20       	and	r0, r0
    736c:	e9 f7       	brne	.-6      	; 0x7368 <systemGenerateReport+0xa74>
    736e:	ae 1b       	sub	r26, r30
    7370:	a0 5f       	subi	r26, 0xF0	; 240
    7372:	fe 01       	movw	r30, r28
    7374:	e3 58       	subi	r30, 0x83	; 131
    7376:	ff 4f       	sbci	r31, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    7378:	1a 16       	cp	r1, r26
    737a:	74 f4       	brge	.+28     	; 0x7398 <systemGenerateReport+0xaa4>
    737c:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    737e:	90 e2       	ldi	r25, 0x20	; 32
    7380:	02 c0       	rjmp	.+4      	; 0x7386 <systemGenerateReport+0xa92>
    7382:	91 93       	st	Z+, r25

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    7384:	8f 5f       	subi	r24, 0xFF	; 255
    7386:	8a 17       	cp	r24, r26
    7388:	e0 f3       	brcs	.-8      	; 0x7382 <systemGenerateReport+0xa8e>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    738a:	fe 01       	movw	r30, r28
    738c:	e3 58       	subi	r30, 0x83	; 131
    738e:	ff 4f       	sbci	r31, 0xFF	; 255
    7390:	ea 0f       	add	r30, r26
    7392:	f1 1d       	adc	r31, r1
    7394:	10 82       	st	Z, r1
    7396:	03 c0       	rjmp	.+6      	; 0x739e <systemGenerateReport+0xaaa>
     }else{
	 strTab[0]=' ';
    7398:	80 e2       	ldi	r24, 0x20	; 32
    739a:	80 83       	st	Z, r24
	 strTab[1]=0;
    739c:	11 82       	std	Z+1, r1	; 0x01
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    739e:	e1 99       	sbic	0x1c, 1	; 28
    73a0:	fe cf       	rjmp	.-4      	; 0x739e <systemGenerateReport+0xaaa>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    73a2:	91 ec       	ldi	r25, 0xC1	; 193
    73a4:	e9 2e       	mov	r14, r25
    73a6:	93 e0       	ldi	r25, 0x03	; 3
    73a8:	f9 2e       	mov	r15, r25
    73aa:	ff ba       	out	0x1f, r15	; 31
    73ac:	ee ba       	out	0x1e, r14	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    73ae:	e0 9a       	sbi	0x1c, 0	; 28
    73b0:	8d b3       	in	r24, 0x1d	; 29
    73b2:	9e 01       	movw	r18, r28
    73b4:	2b 55       	subi	r18, 0x5B	; 91
    73b6:	3f 4f       	sbci	r19, 0xFF	; 255
    73b8:	ae 01       	movw	r20, r28
    73ba:	49 5c       	subi	r20, 0xC9	; 201
    73bc:	5f 4f       	sbci	r21, 0xFF	; 255
    73be:	de 01       	movw	r26, r28
    73c0:	a7 59       	subi	r26, 0x97	; 151
    73c2:	bf 4f       	sbci	r27, 0xFF	; 255
          InserBorder(btMiddleLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btMiddleRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          

		  GetTabSpace((17-strlen(strCurrentVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strCurrentMoney)),strTabSpace2);
		  //PrintMoney
		  if (eeprom_read_byte(&DefPrintMoney)==True) sprintf_P(strReport,PSTR("Akhir:%s%s%s%s"),strTabSpace,strCurrentVolume,strTabSpace2,strCurrentMoney);//CreateReport(strReport,PrintBuffer,&RepPos);
    73c4:	81 30       	cpi	r24, 0x01	; 1
    73c6:	49 f5       	brne	.+82     	; 0x741a <systemGenerateReport+0xb26>
    73c8:	8d b7       	in	r24, 0x3d	; 61
    73ca:	9e b7       	in	r25, 0x3e	; 62
    73cc:	0c 97       	sbiw	r24, 0x0c	; 12
    73ce:	0f b6       	in	r0, 0x3f	; 63
    73d0:	f8 94       	cli
    73d2:	9e bf       	out	0x3e, r25	; 62
    73d4:	0f be       	out	0x3f, r0	; 63
    73d6:	8d bf       	out	0x3d, r24	; 61
    73d8:	6d b7       	in	r22, 0x3d	; 61
    73da:	7e b7       	in	r23, 0x3e	; 62
    73dc:	6f 5f       	subi	r22, 0xFF	; 255
    73de:	7f 4f       	sbci	r23, 0xFF	; 255
    73e0:	ed b7       	in	r30, 0x3d	; 61
    73e2:	fe b7       	in	r31, 0x3e	; 62
    73e4:	32 83       	std	Z+2, r19	; 0x02
    73e6:	21 83       	std	Z+1, r18	; 0x01
    73e8:	8f e6       	ldi	r24, 0x6F	; 111
    73ea:	94 e0       	ldi	r25, 0x04	; 4
    73ec:	fb 01       	movw	r30, r22
    73ee:	93 83       	std	Z+3, r25	; 0x03
    73f0:	82 83       	std	Z+2, r24	; 0x02
    73f2:	b5 83       	std	Z+5, r27	; 0x05
    73f4:	a4 83       	std	Z+4, r26	; 0x04
    73f6:	57 83       	std	Z+7, r21	; 0x07
    73f8:	46 83       	std	Z+6, r20	; 0x06
    73fa:	ce 01       	movw	r24, r28
    73fc:	83 58       	subi	r24, 0x83	; 131
    73fe:	9f 4f       	sbci	r25, 0xFF	; 255
    7400:	91 87       	std	Z+9, r25	; 0x09
    7402:	80 87       	std	Z+8, r24	; 0x08
    7404:	ce 01       	movw	r24, r28
    7406:	8a 5b       	subi	r24, 0xBA	; 186
    7408:	9f 4f       	sbci	r25, 0xFF	; 255
    740a:	93 87       	std	Z+11, r25	; 0x0b
    740c:	82 87       	std	Z+10, r24	; 0x0a
    740e:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    7412:	8d b7       	in	r24, 0x3d	; 61
    7414:	9e b7       	in	r25, 0x3e	; 62
    7416:	0c 96       	adiw	r24, 0x0c	; 12
    7418:	1c c0       	rjmp	.+56     	; 0x7452 <systemGenerateReport+0xb5e>
		  else sprintf_P(strReport,PSTR("Akhir:%s%s"),strTabSpace,strCurrentVolume);
    741a:	ed b7       	in	r30, 0x3d	; 61
    741c:	fe b7       	in	r31, 0x3e	; 62
    741e:	38 97       	sbiw	r30, 0x08	; 8
    7420:	0f b6       	in	r0, 0x3f	; 63
    7422:	f8 94       	cli
    7424:	fe bf       	out	0x3e, r31	; 62
    7426:	0f be       	out	0x3f, r0	; 63
    7428:	ed bf       	out	0x3d, r30	; 61
    742a:	6d b7       	in	r22, 0x3d	; 61
    742c:	7e b7       	in	r23, 0x3e	; 62
    742e:	6f 5f       	subi	r22, 0xFF	; 255
    7430:	7f 4f       	sbci	r23, 0xFF	; 255
    7432:	32 83       	std	Z+2, r19	; 0x02
    7434:	21 83       	std	Z+1, r18	; 0x01
    7436:	84 e6       	ldi	r24, 0x64	; 100
    7438:	94 e0       	ldi	r25, 0x04	; 4
    743a:	fb 01       	movw	r30, r22
    743c:	93 83       	std	Z+3, r25	; 0x03
    743e:	82 83       	std	Z+2, r24	; 0x02
    7440:	b5 83       	std	Z+5, r27	; 0x05
    7442:	a4 83       	std	Z+4, r26	; 0x04
    7444:	57 83       	std	Z+7, r21	; 0x07
    7446:	46 83       	std	Z+6, r20	; 0x06
    7448:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    744c:	8d b7       	in	r24, 0x3d	; 61
    744e:	9e b7       	in	r25, 0x3e	; 62
    7450:	08 96       	adiw	r24, 0x08	; 8
    7452:	0f b6       	in	r0, 0x3f	; 63
    7454:	f8 94       	cli
    7456:	9e bf       	out	0x3e, r25	; 62
    7458:	0f be       	out	0x3f, r0	; 63
    745a:	8d bf       	out	0x3d, r24	; 61
		  CreateReport(strReport,PrintBuffer,&RepPos);
    745c:	ce 01       	movw	r24, r28
    745e:	8b 55       	subi	r24, 0x5B	; 91
    7460:	9f 4f       	sbci	r25, 0xFF	; 255
    7462:	6e ef       	ldi	r22, 0xFE	; 254
    7464:	74 e0       	ldi	r23, 0x04	; 4
    7466:	48 ee       	ldi	r20, 0xE8	; 232
    7468:	51 e0       	ldi	r21, 0x01	; 1
    746a:	0e 94 e9 21 	call	0x43d2	; 0x43d2 <CreateReport>

		  GetTabSpace((17-strlen(strLastVolume)),strTabSpace);
    746e:	de 01       	movw	r26, r28
    7470:	59 96       	adiw	r26, 0x19	; 25
    7472:	fd 01       	movw	r30, r26
    7474:	01 90       	ld	r0, Z+
    7476:	00 20       	and	r0, r0
    7478:	e9 f7       	brne	.-6      	; 0x7474 <systemGenerateReport+0xb80>
    747a:	9a 2f       	mov	r25, r26
    747c:	9e 1b       	sub	r25, r30
    747e:	9e 5e       	subi	r25, 0xEE	; 238
    7480:	de 01       	movw	r26, r28
    7482:	a7 59       	subi	r26, 0x97	; 151
    7484:	bf 4f       	sbci	r27, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    7486:	19 16       	cp	r1, r25
    7488:	7c f4       	brge	.+30     	; 0x74a8 <systemGenerateReport+0xbb4>
    748a:	fd 01       	movw	r30, r26
    748c:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    748e:	20 e2       	ldi	r18, 0x20	; 32
    7490:	02 c0       	rjmp	.+4      	; 0x7496 <systemGenerateReport+0xba2>
    7492:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    7494:	8f 5f       	subi	r24, 0xFF	; 255
    7496:	89 17       	cp	r24, r25
    7498:	e0 f3       	brcs	.-8      	; 0x7492 <systemGenerateReport+0xb9e>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    749a:	fe 01       	movw	r30, r28
    749c:	e7 59       	subi	r30, 0x97	; 151
    749e:	ff 4f       	sbci	r31, 0xFF	; 255
    74a0:	e9 0f       	add	r30, r25
    74a2:	f1 1d       	adc	r31, r1
    74a4:	10 82       	st	Z, r1
    74a6:	04 c0       	rjmp	.+8      	; 0x74b0 <systemGenerateReport+0xbbc>
     }else{
	 strTab[0]=' ';
    74a8:	80 e2       	ldi	r24, 0x20	; 32
    74aa:	8c 93       	st	X, r24
	 strTab[1]=0;
    74ac:	11 96       	adiw	r26, 0x01	; 1
    74ae:	1c 92       	st	X, r1
		  if (eeprom_read_byte(&DefPrintMoney)==True) sprintf_P(strReport,PSTR("Akhir:%s%s%s%s"),strTabSpace,strCurrentVolume,strTabSpace2,strCurrentMoney);//CreateReport(strReport,PrintBuffer,&RepPos);
		  else sprintf_P(strReport,PSTR("Akhir:%s%s"),strTabSpace,strCurrentVolume);
		  CreateReport(strReport,PrintBuffer,&RepPos);

		  GetTabSpace((17-strlen(strLastVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strLastMoney)),strTabSpace2);
    74b0:	de 01       	movw	r26, r28
    74b2:	98 96       	adiw	r26, 0x28	; 40
    74b4:	fd 01       	movw	r30, r26
    74b6:	01 90       	ld	r0, Z+
    74b8:	00 20       	and	r0, r0
    74ba:	e9 f7       	brne	.-6      	; 0x74b6 <systemGenerateReport+0xbc2>
    74bc:	ae 1b       	sub	r26, r30
    74be:	a0 5f       	subi	r26, 0xF0	; 240
    74c0:	fe 01       	movw	r30, r28
    74c2:	e3 58       	subi	r30, 0x83	; 131
    74c4:	ff 4f       	sbci	r31, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    74c6:	1a 16       	cp	r1, r26
    74c8:	74 f4       	brge	.+28     	; 0x74e6 <systemGenerateReport+0xbf2>
    74ca:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    74cc:	90 e2       	ldi	r25, 0x20	; 32
    74ce:	02 c0       	rjmp	.+4      	; 0x74d4 <systemGenerateReport+0xbe0>
    74d0:	91 93       	st	Z+, r25

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    74d2:	8f 5f       	subi	r24, 0xFF	; 255
    74d4:	8a 17       	cp	r24, r26
    74d6:	e0 f3       	brcs	.-8      	; 0x74d0 <systemGenerateReport+0xbdc>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    74d8:	fe 01       	movw	r30, r28
    74da:	e3 58       	subi	r30, 0x83	; 131
    74dc:	ff 4f       	sbci	r31, 0xFF	; 255
    74de:	ea 0f       	add	r30, r26
    74e0:	f1 1d       	adc	r31, r1
    74e2:	10 82       	st	Z, r1
    74e4:	03 c0       	rjmp	.+6      	; 0x74ec <systemGenerateReport+0xbf8>
     }else{
	 strTab[0]=' ';
    74e6:	80 e2       	ldi	r24, 0x20	; 32
    74e8:	80 83       	st	Z, r24
	 strTab[1]=0;
    74ea:	11 82       	std	Z+1, r1	; 0x01
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    74ec:	e1 99       	sbic	0x1c, 1	; 28
    74ee:	fe cf       	rjmp	.-4      	; 0x74ec <systemGenerateReport+0xbf8>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    74f0:	ff ba       	out	0x1f, r15	; 31
    74f2:	ee ba       	out	0x1e, r14	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    74f4:	e0 9a       	sbi	0x1c, 0	; 28
    74f6:	8d b3       	in	r24, 0x1d	; 29
    74f8:	9e 01       	movw	r18, r28
    74fa:	2b 55       	subi	r18, 0x5B	; 91
    74fc:	3f 4f       	sbci	r19, 0xFF	; 255
    74fe:	ae 01       	movw	r20, r28
    7500:	47 5e       	subi	r20, 0xE7	; 231
    7502:	5f 4f       	sbci	r21, 0xFF	; 255
    7504:	de 01       	movw	r26, r28
    7506:	a7 59       	subi	r26, 0x97	; 151
    7508:	bf 4f       	sbci	r27, 0xFF	; 255
		  CreateReport(strReport,PrintBuffer,&RepPos);

		  GetTabSpace((17-strlen(strLastVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strLastMoney)),strTabSpace2);
		  //PrintMoney
		  if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("Awal :%s%s%s%s"),strTabSpace,strLastVolume,strTabSpace2,strLastMoney);//CreateReport(strReport,PrintBuffer,&RepPos);
    750a:	81 30       	cpi	r24, 0x01	; 1
    750c:	31 f5       	brne	.+76     	; 0x755a <systemGenerateReport+0xc66>
    750e:	ed b7       	in	r30, 0x3d	; 61
    7510:	fe b7       	in	r31, 0x3e	; 62
    7512:	3c 97       	sbiw	r30, 0x0c	; 12
    7514:	0f b6       	in	r0, 0x3f	; 63
    7516:	f8 94       	cli
    7518:	fe bf       	out	0x3e, r31	; 62
    751a:	0f be       	out	0x3f, r0	; 63
    751c:	ed bf       	out	0x3d, r30	; 61
    751e:	6d b7       	in	r22, 0x3d	; 61
    7520:	7e b7       	in	r23, 0x3e	; 62
    7522:	6f 5f       	subi	r22, 0xFF	; 255
    7524:	7f 4f       	sbci	r23, 0xFF	; 255
    7526:	32 83       	std	Z+2, r19	; 0x02
    7528:	21 83       	std	Z+1, r18	; 0x01
    752a:	85 e5       	ldi	r24, 0x55	; 85
    752c:	94 e0       	ldi	r25, 0x04	; 4
    752e:	fb 01       	movw	r30, r22
    7530:	93 83       	std	Z+3, r25	; 0x03
    7532:	82 83       	std	Z+2, r24	; 0x02
    7534:	b5 83       	std	Z+5, r27	; 0x05
    7536:	a4 83       	std	Z+4, r26	; 0x04
    7538:	57 83       	std	Z+7, r21	; 0x07
    753a:	46 83       	std	Z+6, r20	; 0x06
    753c:	ce 01       	movw	r24, r28
    753e:	83 58       	subi	r24, 0x83	; 131
    7540:	9f 4f       	sbci	r25, 0xFF	; 255
    7542:	91 87       	std	Z+9, r25	; 0x09
    7544:	80 87       	std	Z+8, r24	; 0x08
    7546:	ce 01       	movw	r24, r28
    7548:	88 96       	adiw	r24, 0x28	; 40
    754a:	93 87       	std	Z+11, r25	; 0x0b
    754c:	82 87       	std	Z+10, r24	; 0x0a
    754e:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    7552:	8d b7       	in	r24, 0x3d	; 61
    7554:	9e b7       	in	r25, 0x3e	; 62
    7556:	0c 96       	adiw	r24, 0x0c	; 12
    7558:	1c c0       	rjmp	.+56     	; 0x7592 <systemGenerateReport+0xc9e>
		  else sprintf_P(strReport,PSTR("Awal :%s%s"),strTabSpace,strLastVolume);
    755a:	ed b7       	in	r30, 0x3d	; 61
    755c:	fe b7       	in	r31, 0x3e	; 62
    755e:	38 97       	sbiw	r30, 0x08	; 8
    7560:	0f b6       	in	r0, 0x3f	; 63
    7562:	f8 94       	cli
    7564:	fe bf       	out	0x3e, r31	; 62
    7566:	0f be       	out	0x3f, r0	; 63
    7568:	ed bf       	out	0x3d, r30	; 61
    756a:	6d b7       	in	r22, 0x3d	; 61
    756c:	7e b7       	in	r23, 0x3e	; 62
    756e:	6f 5f       	subi	r22, 0xFF	; 255
    7570:	7f 4f       	sbci	r23, 0xFF	; 255
    7572:	32 83       	std	Z+2, r19	; 0x02
    7574:	21 83       	std	Z+1, r18	; 0x01
    7576:	8a e4       	ldi	r24, 0x4A	; 74
    7578:	94 e0       	ldi	r25, 0x04	; 4
    757a:	fb 01       	movw	r30, r22
    757c:	93 83       	std	Z+3, r25	; 0x03
    757e:	82 83       	std	Z+2, r24	; 0x02
    7580:	b5 83       	std	Z+5, r27	; 0x05
    7582:	a4 83       	std	Z+4, r26	; 0x04
    7584:	57 83       	std	Z+7, r21	; 0x07
    7586:	46 83       	std	Z+6, r20	; 0x06
    7588:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    758c:	8d b7       	in	r24, 0x3d	; 61
    758e:	9e b7       	in	r25, 0x3e	; 62
    7590:	08 96       	adiw	r24, 0x08	; 8
    7592:	0f b6       	in	r0, 0x3f	; 63
    7594:	f8 94       	cli
    7596:	9e bf       	out	0x3e, r25	; 62
    7598:	0f be       	out	0x3f, r0	; 63
    759a:	8d bf       	out	0x3d, r24	; 61
		  CreateReport(strReport,PrintBuffer,&RepPos);
    759c:	ce 01       	movw	r24, r28
    759e:	8b 55       	subi	r24, 0x5B	; 91
    75a0:	9f 4f       	sbci	r25, 0xFF	; 255
    75a2:	6e ef       	ldi	r22, 0xFE	; 254
    75a4:	74 e0       	ldi	r23, 0x04	; 4
    75a6:	48 ee       	ldi	r20, 0xE8	; 232
    75a8:	51 e0       	ldi	r21, 0x01	; 1
    75aa:	0e 94 e9 21 	call	0x43d2	; 0x43d2 <CreateReport>
    75ae:	8e 01       	movw	r16, r28
    75b0:	07 59       	subi	r16, 0x97	; 151
    75b2:	1f 4f       	sbci	r17, 0xFF	; 255
    75b4:	f8 01       	movw	r30, r16
void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    75b6:	20 e2       	ldi	r18, 0x20	; 32

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    75b8:	d8 01       	movw	r26, r16
    75ba:	c8 01       	movw	r24, r16
    75bc:	0c 96       	adiw	r24, 0x0c	; 12
		     strTab[i]=' ';
    75be:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    75c0:	e8 17       	cp	r30, r24
    75c2:	f9 07       	cpc	r31, r25
    75c4:	e1 f7       	brne	.-8      	; 0x75be <systemGenerateReport+0xcca>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    75c6:	1c 96       	adiw	r26, 0x0c	; 12
    75c8:	1c 92       	st	X, r1
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    75ca:	e1 99       	sbic	0x1c, 1	; 28
    75cc:	fe cf       	rjmp	.-4      	; 0x75ca <systemGenerateReport+0xcd6>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    75ce:	ff ba       	out	0x1f, r15	; 31
    75d0:	ee ba       	out	0x1e, r14	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    75d2:	e0 9a       	sbi	0x1c, 0	; 28
    75d4:	8d b3       	in	r24, 0x1d	; 29
    75d6:	9e 01       	movw	r18, r28
    75d8:	2b 55       	subi	r18, 0x5B	; 91
    75da:	3f 4f       	sbci	r19, 0xFF	; 255
    75dc:	de 01       	movw	r26, r28
    75de:	a7 59       	subi	r26, 0x97	; 151
    75e0:	bf 4f       	sbci	r27, 0xFF	; 255
		  else sprintf_P(strReport,PSTR("Awal :%s%s"),strTabSpace,strLastVolume);
		  CreateReport(strReport,PrintBuffer,&RepPos);

		  GetTabSpace(12,strTabSpace);
          //PrintMoney
          if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("%s-----------   -------------"),strTabSpace);//CreateReport(strReport,PrintBuffer,&RepPos);
    75e2:	81 30       	cpi	r24, 0x01	; 1
    75e4:	71 f4       	brne	.+28     	; 0x7602 <systemGenerateReport+0xd0e>
    75e6:	00 d0       	rcall	.+0      	; 0x75e8 <systemGenerateReport+0xcf4>
    75e8:	00 d0       	rcall	.+0      	; 0x75ea <systemGenerateReport+0xcf6>
    75ea:	00 d0       	rcall	.+0      	; 0x75ec <systemGenerateReport+0xcf8>
    75ec:	4d b7       	in	r20, 0x3d	; 61
    75ee:	5e b7       	in	r21, 0x3e	; 62
    75f0:	4f 5f       	subi	r20, 0xFF	; 255
    75f2:	5f 4f       	sbci	r21, 0xFF	; 255
    75f4:	ed b7       	in	r30, 0x3d	; 61
    75f6:	fe b7       	in	r31, 0x3e	; 62
    75f8:	32 83       	std	Z+2, r19	; 0x02
    75fa:	21 83       	std	Z+1, r18	; 0x01
    75fc:	8c e2       	ldi	r24, 0x2C	; 44
    75fe:	94 e0       	ldi	r25, 0x04	; 4
    7600:	0d c0       	rjmp	.+26     	; 0x761c <systemGenerateReport+0xd28>
		  else sprintf_P(strReport,PSTR("%s-----------                "),strTabSpace);CreateReport(strReport,PrintBuffer,&RepPos);
    7602:	00 d0       	rcall	.+0      	; 0x7604 <systemGenerateReport+0xd10>
    7604:	00 d0       	rcall	.+0      	; 0x7606 <systemGenerateReport+0xd12>
    7606:	00 d0       	rcall	.+0      	; 0x7608 <systemGenerateReport+0xd14>
    7608:	4d b7       	in	r20, 0x3d	; 61
    760a:	5e b7       	in	r21, 0x3e	; 62
    760c:	4f 5f       	subi	r20, 0xFF	; 255
    760e:	5f 4f       	sbci	r21, 0xFF	; 255
    7610:	ed b7       	in	r30, 0x3d	; 61
    7612:	fe b7       	in	r31, 0x3e	; 62
    7614:	32 83       	std	Z+2, r19	; 0x02
    7616:	21 83       	std	Z+1, r18	; 0x01
    7618:	8e e0       	ldi	r24, 0x0E	; 14
    761a:	94 e0       	ldi	r25, 0x04	; 4
    761c:	fa 01       	movw	r30, r20
    761e:	93 83       	std	Z+3, r25	; 0x03
    7620:	82 83       	std	Z+2, r24	; 0x02
    7622:	b5 83       	std	Z+5, r27	; 0x05
    7624:	a4 83       	std	Z+4, r26	; 0x04
    7626:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    762a:	8d b7       	in	r24, 0x3d	; 61
    762c:	9e b7       	in	r25, 0x3e	; 62
    762e:	06 96       	adiw	r24, 0x06	; 6
    7630:	0f b6       	in	r0, 0x3f	; 63
    7632:	f8 94       	cli
    7634:	9e bf       	out	0x3e, r25	; 62
    7636:	0f be       	out	0x3f, r0	; 63
    7638:	8d bf       	out	0x3d, r24	; 61
    763a:	ce 01       	movw	r24, r28
    763c:	8b 55       	subi	r24, 0x5B	; 91
    763e:	9f 4f       	sbci	r25, 0xFF	; 255
    7640:	6e ef       	ldi	r22, 0xFE	; 254
    7642:	74 e0       	ldi	r23, 0x04	; 4
    7644:	48 ee       	ldi	r20, 0xE8	; 232
    7646:	51 e0       	ldi	r21, 0x01	; 1
    7648:	0e 94 e9 21 	call	0x43d2	; 0x43d2 <CreateReport>

		  GetTabSpace((23-strlen(strDeltaVolume)),strTabSpace);
    764c:	e9 e3       	ldi	r30, 0x39	; 57
    764e:	fa e0       	ldi	r31, 0x0A	; 10
    7650:	01 90       	ld	r0, Z+
    7652:	00 20       	and	r0, r0
    7654:	e9 f7       	brne	.-6      	; 0x7650 <systemGenerateReport+0xd5c>
    7656:	31 97       	sbiw	r30, 0x01	; 1
    7658:	e9 53       	subi	r30, 0x39	; 57
    765a:	fa 40       	sbci	r31, 0x0A	; 10
    765c:	97 e1       	ldi	r25, 0x17	; 23
    765e:	9e 1b       	sub	r25, r30
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    7660:	19 16       	cp	r1, r25
    7662:	84 f4       	brge	.+32     	; 0x7684 <systemGenerateReport+0xd90>
    7664:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    7666:	20 e2       	ldi	r18, 0x20	; 32
    7668:	04 c0       	rjmp	.+8      	; 0x7672 <systemGenerateReport+0xd7e>
    766a:	d8 01       	movw	r26, r16
    766c:	2d 93       	st	X+, r18
    766e:	8d 01       	movw	r16, r26

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    7670:	8f 5f       	subi	r24, 0xFF	; 255
    7672:	89 17       	cp	r24, r25
    7674:	d0 f3       	brcs	.-12     	; 0x766a <systemGenerateReport+0xd76>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    7676:	fe 01       	movw	r30, r28
    7678:	e7 59       	subi	r30, 0x97	; 151
    767a:	ff 4f       	sbci	r31, 0xFF	; 255
    767c:	e9 0f       	add	r30, r25
    767e:	f1 1d       	adc	r31, r1
    7680:	10 82       	st	Z, r1
    7682:	06 c0       	rjmp	.+12     	; 0x7690 <systemGenerateReport+0xd9c>
     }else{
	 strTab[0]=' ';
    7684:	fe 01       	movw	r30, r28
    7686:	e7 59       	subi	r30, 0x97	; 151
    7688:	ff 4f       	sbci	r31, 0xFF	; 255
    768a:	80 e2       	ldi	r24, 0x20	; 32
    768c:	80 83       	st	Z, r24
	 strTab[1]=0;
    768e:	11 82       	std	Z+1, r1	; 0x01
          //PrintMoney
          if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("%s-----------   -------------"),strTabSpace);//CreateReport(strReport,PrintBuffer,&RepPos);
		  else sprintf_P(strReport,PSTR("%s-----------                "),strTabSpace);CreateReport(strReport,PrintBuffer,&RepPos);

		  GetTabSpace((23-strlen(strDeltaVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strDeltaMoney)),strTabSpace2);
    7690:	e4 e6       	ldi	r30, 0x64	; 100
    7692:	fd e0       	ldi	r31, 0x0D	; 13
    7694:	01 90       	ld	r0, Z+
    7696:	00 20       	and	r0, r0
    7698:	e9 f7       	brne	.-6      	; 0x7694 <systemGenerateReport+0xda0>
    769a:	31 97       	sbiw	r30, 0x01	; 1
    769c:	e4 56       	subi	r30, 0x64	; 100
    769e:	fd 40       	sbci	r31, 0x0D	; 13
    76a0:	9f e0       	ldi	r25, 0x0F	; 15
    76a2:	9e 1b       	sub	r25, r30
    76a4:	fe 01       	movw	r30, r28
    76a6:	e3 58       	subi	r30, 0x83	; 131
    76a8:	ff 4f       	sbci	r31, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    76aa:	19 16       	cp	r1, r25
    76ac:	74 f4       	brge	.+28     	; 0x76ca <systemGenerateReport+0xdd6>
    76ae:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    76b0:	20 e2       	ldi	r18, 0x20	; 32
    76b2:	02 c0       	rjmp	.+4      	; 0x76b8 <systemGenerateReport+0xdc4>
    76b4:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    76b6:	8f 5f       	subi	r24, 0xFF	; 255
    76b8:	89 17       	cp	r24, r25
    76ba:	e0 f3       	brcs	.-8      	; 0x76b4 <systemGenerateReport+0xdc0>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    76bc:	fe 01       	movw	r30, r28
    76be:	e3 58       	subi	r30, 0x83	; 131
    76c0:	ff 4f       	sbci	r31, 0xFF	; 255
    76c2:	e9 0f       	add	r30, r25
    76c4:	f1 1d       	adc	r31, r1
    76c6:	10 82       	st	Z, r1
    76c8:	03 c0       	rjmp	.+6      	; 0x76d0 <systemGenerateReport+0xddc>
     }else{
	 strTab[0]=' ';
    76ca:	80 e2       	ldi	r24, 0x20	; 32
    76cc:	80 83       	st	Z, r24
	 strTab[1]=0;
    76ce:	11 82       	std	Z+1, r1	; 0x01
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    76d0:	e1 99       	sbic	0x1c, 1	; 28
    76d2:	fe cf       	rjmp	.-4      	; 0x76d0 <systemGenerateReport+0xddc>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    76d4:	ff ba       	out	0x1f, r15	; 31
    76d6:	ee ba       	out	0x1e, r14	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    76d8:	e0 9a       	sbi	0x1c, 0	; 28
    76da:	8d b3       	in	r24, 0x1d	; 29
    76dc:	9e 01       	movw	r18, r28
    76de:	2b 55       	subi	r18, 0x5B	; 91
    76e0:	3f 4f       	sbci	r19, 0xFF	; 255
    76e2:	49 e3       	ldi	r20, 0x39	; 57
    76e4:	5a e0       	ldi	r21, 0x0A	; 10
    76e6:	de 01       	movw	r26, r28
    76e8:	a7 59       	subi	r26, 0x97	; 151
    76ea:	bf 4f       	sbci	r27, 0xFF	; 255
		  else sprintf_P(strReport,PSTR("%s-----------                "),strTabSpace);CreateReport(strReport,PrintBuffer,&RepPos);

		  GetTabSpace((23-strlen(strDeltaVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strDeltaMoney)),strTabSpace2);
          //PrintMoney
		  if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("%s%s%s%s"),strTabSpace,strDeltaVolume,strTabSpace2,strDeltaMoney);//CreateReport(strReport,PrintBuffer,&RepPos);
    76ec:	81 30       	cpi	r24, 0x01	; 1
    76ee:	31 f5       	brne	.+76     	; 0x773c <systemGenerateReport+0xe48>
    76f0:	ed b7       	in	r30, 0x3d	; 61
    76f2:	fe b7       	in	r31, 0x3e	; 62
    76f4:	3c 97       	sbiw	r30, 0x0c	; 12
    76f6:	0f b6       	in	r0, 0x3f	; 63
    76f8:	f8 94       	cli
    76fa:	fe bf       	out	0x3e, r31	; 62
    76fc:	0f be       	out	0x3f, r0	; 63
    76fe:	ed bf       	out	0x3d, r30	; 61
    7700:	6d b7       	in	r22, 0x3d	; 61
    7702:	7e b7       	in	r23, 0x3e	; 62
    7704:	6f 5f       	subi	r22, 0xFF	; 255
    7706:	7f 4f       	sbci	r23, 0xFF	; 255
    7708:	32 83       	std	Z+2, r19	; 0x02
    770a:	21 83       	std	Z+1, r18	; 0x01
    770c:	85 e0       	ldi	r24, 0x05	; 5
    770e:	94 e0       	ldi	r25, 0x04	; 4
    7710:	fb 01       	movw	r30, r22
    7712:	93 83       	std	Z+3, r25	; 0x03
    7714:	82 83       	std	Z+2, r24	; 0x02
    7716:	b5 83       	std	Z+5, r27	; 0x05
    7718:	a4 83       	std	Z+4, r26	; 0x04
    771a:	57 83       	std	Z+7, r21	; 0x07
    771c:	46 83       	std	Z+6, r20	; 0x06
    771e:	ce 01       	movw	r24, r28
    7720:	83 58       	subi	r24, 0x83	; 131
    7722:	9f 4f       	sbci	r25, 0xFF	; 255
    7724:	91 87       	std	Z+9, r25	; 0x09
    7726:	80 87       	std	Z+8, r24	; 0x08
    7728:	84 e6       	ldi	r24, 0x64	; 100
    772a:	9d e0       	ldi	r25, 0x0D	; 13
    772c:	93 87       	std	Z+11, r25	; 0x0b
    772e:	82 87       	std	Z+10, r24	; 0x0a
    7730:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    7734:	8d b7       	in	r24, 0x3d	; 61
    7736:	9e b7       	in	r25, 0x3e	; 62
    7738:	0c 96       	adiw	r24, 0x0c	; 12
    773a:	1c c0       	rjmp	.+56     	; 0x7774 <systemGenerateReport+0xe80>
          else sprintf_P(strReport,PSTR("%s%s"),strTabSpace,strDeltaVolume);CreateReport(strReport,PrintBuffer,&RepPos);
    773c:	ed b7       	in	r30, 0x3d	; 61
    773e:	fe b7       	in	r31, 0x3e	; 62
    7740:	38 97       	sbiw	r30, 0x08	; 8
    7742:	0f b6       	in	r0, 0x3f	; 63
    7744:	f8 94       	cli
    7746:	fe bf       	out	0x3e, r31	; 62
    7748:	0f be       	out	0x3f, r0	; 63
    774a:	ed bf       	out	0x3d, r30	; 61
    774c:	6d b7       	in	r22, 0x3d	; 61
    774e:	7e b7       	in	r23, 0x3e	; 62
    7750:	6f 5f       	subi	r22, 0xFF	; 255
    7752:	7f 4f       	sbci	r23, 0xFF	; 255
    7754:	32 83       	std	Z+2, r19	; 0x02
    7756:	21 83       	std	Z+1, r18	; 0x01
    7758:	80 e0       	ldi	r24, 0x00	; 0
    775a:	94 e0       	ldi	r25, 0x04	; 4
    775c:	fb 01       	movw	r30, r22
    775e:	93 83       	std	Z+3, r25	; 0x03
    7760:	82 83       	std	Z+2, r24	; 0x02
    7762:	b5 83       	std	Z+5, r27	; 0x05
    7764:	a4 83       	std	Z+4, r26	; 0x04
    7766:	57 83       	std	Z+7, r21	; 0x07
    7768:	46 83       	std	Z+6, r20	; 0x06
    776a:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    776e:	8d b7       	in	r24, 0x3d	; 61
    7770:	9e b7       	in	r25, 0x3e	; 62
    7772:	08 96       	adiw	r24, 0x08	; 8
    7774:	0f b6       	in	r0, 0x3f	; 63
    7776:	f8 94       	cli
    7778:	9e bf       	out	0x3e, r25	; 62
    777a:	0f be       	out	0x3f, r0	; 63
    777c:	8d bf       	out	0x3d, r24	; 61
    777e:	ce 01       	movw	r24, r28
    7780:	8b 55       	subi	r24, 0x5B	; 91
    7782:	9f 4f       	sbci	r25, 0xFF	; 255
    7784:	6e ef       	ldi	r22, 0xFE	; 254
    7786:	74 e0       	ldi	r23, 0x04	; 4
    7788:	48 ee       	ldi	r20, 0xE8	; 232
    778a:	51 e0       	ldi	r21, 0x01	; 1
    778c:	0e 94 e9 21 	call	0x43d2	; 0x43d2 <CreateReport>

          InserBorder(btBottomLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btBottomRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);
    7790:	87 e0       	ldi	r24, 0x07	; 7
    7792:	6e ef       	ldi	r22, 0xFE	; 254
    7794:	74 e0       	ldi	r23, 0x04	; 4
    7796:	41 e0       	ldi	r20, 0x01	; 1
    7798:	28 ee       	ldi	r18, 0xE8	; 232
    779a:	31 e0       	ldi	r19, 0x01	; 1
    779c:	0e 94 e1 19 	call	0x33c2	; 0x33c2 <InserBorder>
    77a0:	8b e0       	ldi	r24, 0x0B	; 11
    77a2:	6e ef       	ldi	r22, 0xFE	; 254
    77a4:	74 e0       	ldi	r23, 0x04	; 4
    77a6:	4a e2       	ldi	r20, 0x2A	; 42
    77a8:	28 ee       	ldi	r18, 0xE8	; 232
    77aa:	31 e0       	ldi	r19, 0x01	; 1
    77ac:	0e 94 e1 19 	call	0x33c2	; 0x33c2 <InserBorder>
    77b0:	89 e0       	ldi	r24, 0x09	; 9
    77b2:	6e ef       	ldi	r22, 0xFE	; 254
    77b4:	74 e0       	ldi	r23, 0x04	; 4
    77b6:	41 e0       	ldi	r20, 0x01	; 1
    77b8:	28 ee       	ldi	r18, 0xE8	; 232
    77ba:	31 e0       	ldi	r19, 0x01	; 1
    77bc:	0e 94 e1 19 	call	0x33c2	; 0x33c2 <InserBorder>
    77c0:	8c e0       	ldi	r24, 0x0C	; 12
    77c2:	6e ef       	ldi	r22, 0xFE	; 254
    77c4:	74 e0       	ldi	r23, 0x04	; 4
    77c6:	41 e0       	ldi	r20, 0x01	; 1
    77c8:	28 ee       	ldi	r18, 0xE8	; 232
    77ca:	31 e0       	ldi	r19, 0x01	; 1
    77cc:	0e 94 e1 19 	call	0x33c2	; 0x33c2 <InserBorder>


          cmdPrint=0b00000000;
    77d0:	10 92 b7 01 	sts	0x01B7, r1
		  LengthMessage81=RepPos+1;
    77d4:	80 91 e8 01 	lds	r24, 0x01E8
    77d8:	90 91 e9 01 	lds	r25, 0x01E9
    77dc:	01 96       	adiw	r24, 0x01	; 1
    77de:	90 93 91 01 	sts	0x0191, r25
    77e2:	80 93 90 01 	sts	0x0190, r24

		  IsFreePrinting=True;
    77e6:	81 e0       	ldi	r24, 0x01	; 1
    77e8:	80 93 ab 01 	sts	0x01AB, r24
	      IsBusyFreePrinting=True;
    77ec:	80 93 b6 01 	sts	0x01B6, r24

	      stGenerateReport=grWaitPrinted2;
    77f0:	89 e0       	ldi	r24, 0x09	; 9
    77f2:	91 c3       	rjmp	.+1826   	; 0x7f16 <systemGenerateReport+0x1622>
	      break;
     case grWaitPrinted2:
	 
          if (IsBusyFreePrinting==False)stGenerateReport=grGenerateReportData;
    77f4:	80 91 b6 01 	lds	r24, 0x01B6
    77f8:	88 23       	and	r24, r24
    77fa:	09 f0       	breq	.+2      	; 0x77fe <systemGenerateReport+0xf0a>
    77fc:	94 c3       	rjmp	.+1832   	; 0x7f26 <systemGenerateReport+0x1632>
    77fe:	86 e0       	ldi	r24, 0x06	; 6
    7800:	8a c3       	rjmp	.+1812   	; 0x7f16 <systemGenerateReport+0x1622>
	      break;
     case grCreateReportFooter:
          RepPos=0;
    7802:	10 92 e9 01 	sts	0x01E9, r1
    7806:	10 92 e8 01 	sts	0x01E8, r1
    780a:	ee ef       	ldi	r30, 0xFE	; 254
    780c:	f4 e0       	ldi	r31, 0x04	; 4
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    780e:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7810:	96 e0       	ldi	r25, 0x06	; 6
    7812:	ef 38       	cpi	r30, 0x8F	; 143
    7814:	f9 07       	cpc	r31, r25
    7816:	d9 f7       	brne	.-10     	; 0x780e <systemGenerateReport+0xf1a>
    7818:	fe 01       	movw	r30, r28
    781a:	eb 55       	subi	r30, 0x5B	; 91
    781c:	ff 4f       	sbci	r31, 0xFF	; 255
	     strMemory[i]=data;
    781e:	ce 01       	movw	r24, r28
    7820:	8b 50       	subi	r24, 0x0B	; 11
    7822:	9f 4f       	sbci	r25, 0xFF	; 255
    7824:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7826:	e8 17       	cp	r30, r24
    7828:	f9 07       	cpc	r31, r25
    782a:	e1 f7       	brne	.-8      	; 0x7824 <systemGenerateReport+0xf30>
     case grCreateReportFooter:
          RepPos=0;
		  FillChar(PrintBuffer,sizeof(PrintBuffer),0);
		  FillChar(strReport,sizeof(strReport),0);

		  RemZeroLead(strTotalMoney);
    782c:	8c ed       	ldi	r24, 0xDC	; 220
    782e:	99 e0       	ldi	r25, 0x09	; 9
    7830:	0e 94 19 25 	call	0x4a32	; 0x4a32 <RemZeroLead>
		  RemZeroLead(strTotalVolume);
    7834:	0b e2       	ldi	r16, 0x2B	; 43
    7836:	19 e0       	ldi	r17, 0x09	; 9
    7838:	c8 01       	movw	r24, r16
    783a:	0e 94 19 25 	call	0x4a32	; 0x4a32 <RemZeroLead>

		  FormatTotalizerMoney(strTotalMoney);
    783e:	8c ed       	ldi	r24, 0xDC	; 220
    7840:	99 e0       	ldi	r25, 0x09	; 9
    7842:	0e 94 46 34 	call	0x688c	; 0x688c <FormatTotalizerMoney>
		  FormatCurrency(strTotalMoney);
    7846:	8c ed       	ldi	r24, 0xDC	; 220
    7848:	99 e0       	ldi	r25, 0x09	; 9
    784a:	0e 94 09 33 	call	0x6612	; 0x6612 <FormatCurrency>
		  FormatTotalizerVolume(strTotalVolume);
    784e:	c8 01       	movw	r24, r16
    7850:	0e 94 39 34 	call	0x6872	; 0x6872 <FormatTotalizerVolume>
		  FormatCurrency(strTotalVolume);
    7854:	c8 01       	movw	r24, r16
    7856:	0e 94 09 33 	call	0x6612	; 0x6612 <FormatCurrency>

          //Test
		  //RemZeroLead(strTotalMoney);
		  //RemZeroLead(strTotalVolume);

		  InserBorder(btTopLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btTopRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          
    785a:	81 e0       	ldi	r24, 0x01	; 1
    785c:	6e ef       	ldi	r22, 0xFE	; 254
    785e:	74 e0       	ldi	r23, 0x04	; 4
    7860:	41 e0       	ldi	r20, 0x01	; 1
    7862:	28 ee       	ldi	r18, 0xE8	; 232
    7864:	31 e0       	ldi	r19, 0x01	; 1
    7866:	0e 94 e1 19 	call	0x33c2	; 0x33c2 <InserBorder>
    786a:	8b e0       	ldi	r24, 0x0B	; 11
    786c:	6e ef       	ldi	r22, 0xFE	; 254
    786e:	74 e0       	ldi	r23, 0x04	; 4
    7870:	4a e2       	ldi	r20, 0x2A	; 42
    7872:	28 ee       	ldi	r18, 0xE8	; 232
    7874:	31 e0       	ldi	r19, 0x01	; 1
    7876:	0e 94 e1 19 	call	0x33c2	; 0x33c2 <InserBorder>
    787a:	83 e0       	ldi	r24, 0x03	; 3
    787c:	6e ef       	ldi	r22, 0xFE	; 254
    787e:	74 e0       	ldi	r23, 0x04	; 4
    7880:	41 e0       	ldi	r20, 0x01	; 1
    7882:	28 ee       	ldi	r18, 0xE8	; 232
    7884:	31 e0       	ldi	r19, 0x01	; 1
    7886:	0e 94 e1 19 	call	0x33c2	; 0x33c2 <InserBorder>
    788a:	8c e0       	ldi	r24, 0x0C	; 12
    788c:	6e ef       	ldi	r22, 0xFE	; 254
    788e:	74 e0       	ldi	r23, 0x04	; 4
    7890:	41 e0       	ldi	r20, 0x01	; 1
    7892:	28 ee       	ldi	r18, 0xE8	; 232
    7894:	31 e0       	ldi	r19, 0x01	; 1
    7896:	0e 94 e1 19 	call	0x33c2	; 0x33c2 <InserBorder>
		  GetTabSpace((17-strlen(strTotalVolume)),strTabSpace);
    789a:	d8 01       	movw	r26, r16
    789c:	0d 90       	ld	r0, X+
    789e:	00 20       	and	r0, r0
    78a0:	e9 f7       	brne	.-6      	; 0x789c <systemGenerateReport+0xfa8>
    78a2:	8d 01       	movw	r16, r26
    78a4:	01 50       	subi	r16, 0x01	; 1
    78a6:	10 40       	sbci	r17, 0x00	; 0
    78a8:	0b 52       	subi	r16, 0x2B	; 43
    78aa:	19 40       	sbci	r17, 0x09	; 9
    78ac:	91 e1       	ldi	r25, 0x11	; 17
    78ae:	90 1b       	sub	r25, r16
    78b0:	de 01       	movw	r26, r28
    78b2:	a7 59       	subi	r26, 0x97	; 151
    78b4:	bf 4f       	sbci	r27, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    78b6:	19 16       	cp	r1, r25
    78b8:	7c f4       	brge	.+30     	; 0x78d8 <systemGenerateReport+0xfe4>
    78ba:	fd 01       	movw	r30, r26
    78bc:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    78be:	20 e2       	ldi	r18, 0x20	; 32
    78c0:	02 c0       	rjmp	.+4      	; 0x78c6 <systemGenerateReport+0xfd2>
    78c2:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    78c4:	8f 5f       	subi	r24, 0xFF	; 255
    78c6:	89 17       	cp	r24, r25
    78c8:	e0 f3       	brcs	.-8      	; 0x78c2 <systemGenerateReport+0xfce>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    78ca:	fe 01       	movw	r30, r28
    78cc:	e7 59       	subi	r30, 0x97	; 151
    78ce:	ff 4f       	sbci	r31, 0xFF	; 255
    78d0:	e9 0f       	add	r30, r25
    78d2:	f1 1d       	adc	r31, r1
    78d4:	10 82       	st	Z, r1
    78d6:	04 c0       	rjmp	.+8      	; 0x78e0 <systemGenerateReport+0xfec>
     }else{
	 strTab[0]=' ';
    78d8:	80 e2       	ldi	r24, 0x20	; 32
    78da:	8c 93       	st	X, r24
	 strTab[1]=0;
    78dc:	11 96       	adiw	r26, 0x01	; 1
    78de:	1c 92       	st	X, r1
		  //RemZeroLead(strTotalMoney);
		  //RemZeroLead(strTotalVolume);

		  InserBorder(btTopLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btTopRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          
		  GetTabSpace((17-strlen(strTotalVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strTotalMoney)),strTabSpace2);
    78e0:	ec ed       	ldi	r30, 0xDC	; 220
    78e2:	f9 e0       	ldi	r31, 0x09	; 9
    78e4:	01 90       	ld	r0, Z+
    78e6:	00 20       	and	r0, r0
    78e8:	e9 f7       	brne	.-6      	; 0x78e4 <systemGenerateReport+0xff0>
    78ea:	31 97       	sbiw	r30, 0x01	; 1
    78ec:	ec 5d       	subi	r30, 0xDC	; 220
    78ee:	f9 40       	sbci	r31, 0x09	; 9
    78f0:	9f e0       	ldi	r25, 0x0F	; 15
    78f2:	9e 1b       	sub	r25, r30
    78f4:	fe 01       	movw	r30, r28
    78f6:	e3 58       	subi	r30, 0x83	; 131
    78f8:	ff 4f       	sbci	r31, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    78fa:	19 16       	cp	r1, r25
    78fc:	74 f4       	brge	.+28     	; 0x791a <systemGenerateReport+0x1026>
    78fe:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    7900:	20 e2       	ldi	r18, 0x20	; 32
    7902:	02 c0       	rjmp	.+4      	; 0x7908 <systemGenerateReport+0x1014>
    7904:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    7906:	8f 5f       	subi	r24, 0xFF	; 255
    7908:	89 17       	cp	r24, r25
    790a:	e0 f3       	brcs	.-8      	; 0x7904 <systemGenerateReport+0x1010>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    790c:	fe 01       	movw	r30, r28
    790e:	e3 58       	subi	r30, 0x83	; 131
    7910:	ff 4f       	sbci	r31, 0xFF	; 255
    7912:	e9 0f       	add	r30, r25
    7914:	f1 1d       	adc	r31, r1
    7916:	10 82       	st	Z, r1
    7918:	03 c0       	rjmp	.+6      	; 0x7920 <systemGenerateReport+0x102c>
     }else{
	 strTab[0]=' ';
    791a:	80 e2       	ldi	r24, 0x20	; 32
    791c:	80 83       	st	Z, r24
	 strTab[1]=0;
    791e:	11 82       	std	Z+1, r1	; 0x01
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    7920:	e1 99       	sbic	0x1c, 1	; 28
    7922:	fe cf       	rjmp	.-4      	; 0x7920 <systemGenerateReport+0x102c>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    7924:	e1 ec       	ldi	r30, 0xC1	; 193
    7926:	f3 e0       	ldi	r31, 0x03	; 3
    7928:	ff bb       	out	0x1f, r31	; 31
    792a:	ee bb       	out	0x1e, r30	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    792c:	e0 9a       	sbi	0x1c, 0	; 28
    792e:	8d b3       	in	r24, 0x1d	; 29
    7930:	9e 01       	movw	r18, r28
    7932:	2b 55       	subi	r18, 0x5B	; 91
    7934:	3f 4f       	sbci	r19, 0xFF	; 255
    7936:	4b e2       	ldi	r20, 0x2B	; 43
    7938:	59 e0       	ldi	r21, 0x09	; 9
    793a:	de 01       	movw	r26, r28
    793c:	a7 59       	subi	r26, 0x97	; 151
    793e:	bf 4f       	sbci	r27, 0xFF	; 255

		  InserBorder(btTopLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btTopRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          
		  GetTabSpace((17-strlen(strTotalVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strTotalMoney)),strTabSpace2);
          //PrintMoney
		  if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("TOTAL %s%s%s%s"),strTabSpace,strTotalVolume,strTabSpace2,strTotalMoney);//CreateReport(strReport,PrintBuffer,&RepPos);
    7940:	81 30       	cpi	r24, 0x01	; 1
    7942:	41 f5       	brne	.+80     	; 0x7994 <systemGenerateReport+0x10a0>
    7944:	8d b7       	in	r24, 0x3d	; 61
    7946:	9e b7       	in	r25, 0x3e	; 62
    7948:	0c 97       	sbiw	r24, 0x0c	; 12
    794a:	0f b6       	in	r0, 0x3f	; 63
    794c:	f8 94       	cli
    794e:	9e bf       	out	0x3e, r25	; 62
    7950:	0f be       	out	0x3f, r0	; 63
    7952:	8d bf       	out	0x3d, r24	; 61
    7954:	6d b7       	in	r22, 0x3d	; 61
    7956:	7e b7       	in	r23, 0x3e	; 62
    7958:	6f 5f       	subi	r22, 0xFF	; 255
    795a:	7f 4f       	sbci	r23, 0xFF	; 255
    795c:	ed b7       	in	r30, 0x3d	; 61
    795e:	fe b7       	in	r31, 0x3e	; 62
    7960:	32 83       	std	Z+2, r19	; 0x02
    7962:	21 83       	std	Z+1, r18	; 0x01
    7964:	81 ef       	ldi	r24, 0xF1	; 241
    7966:	93 e0       	ldi	r25, 0x03	; 3
    7968:	fb 01       	movw	r30, r22
    796a:	93 83       	std	Z+3, r25	; 0x03
    796c:	82 83       	std	Z+2, r24	; 0x02
    796e:	b5 83       	std	Z+5, r27	; 0x05
    7970:	a4 83       	std	Z+4, r26	; 0x04
    7972:	57 83       	std	Z+7, r21	; 0x07
    7974:	46 83       	std	Z+6, r20	; 0x06
    7976:	ce 01       	movw	r24, r28
    7978:	83 58       	subi	r24, 0x83	; 131
    797a:	9f 4f       	sbci	r25, 0xFF	; 255
    797c:	91 87       	std	Z+9, r25	; 0x09
    797e:	80 87       	std	Z+8, r24	; 0x08
    7980:	8c ed       	ldi	r24, 0xDC	; 220
    7982:	99 e0       	ldi	r25, 0x09	; 9
    7984:	93 87       	std	Z+11, r25	; 0x0b
    7986:	82 87       	std	Z+10, r24	; 0x0a
    7988:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    798c:	8d b7       	in	r24, 0x3d	; 61
    798e:	9e b7       	in	r25, 0x3e	; 62
    7990:	0c 96       	adiw	r24, 0x0c	; 12
    7992:	1c c0       	rjmp	.+56     	; 0x79cc <systemGenerateReport+0x10d8>
		  else sprintf_P(strReport,PSTR("TOTAL %s%s"),strTabSpace,strTotalVolume);CreateReport(strReport,PrintBuffer,&RepPos);
    7994:	ed b7       	in	r30, 0x3d	; 61
    7996:	fe b7       	in	r31, 0x3e	; 62
    7998:	38 97       	sbiw	r30, 0x08	; 8
    799a:	0f b6       	in	r0, 0x3f	; 63
    799c:	f8 94       	cli
    799e:	fe bf       	out	0x3e, r31	; 62
    79a0:	0f be       	out	0x3f, r0	; 63
    79a2:	ed bf       	out	0x3d, r30	; 61
    79a4:	6d b7       	in	r22, 0x3d	; 61
    79a6:	7e b7       	in	r23, 0x3e	; 62
    79a8:	6f 5f       	subi	r22, 0xFF	; 255
    79aa:	7f 4f       	sbci	r23, 0xFF	; 255
    79ac:	32 83       	std	Z+2, r19	; 0x02
    79ae:	21 83       	std	Z+1, r18	; 0x01
    79b0:	86 ee       	ldi	r24, 0xE6	; 230
    79b2:	93 e0       	ldi	r25, 0x03	; 3
    79b4:	fb 01       	movw	r30, r22
    79b6:	93 83       	std	Z+3, r25	; 0x03
    79b8:	82 83       	std	Z+2, r24	; 0x02
    79ba:	b5 83       	std	Z+5, r27	; 0x05
    79bc:	a4 83       	std	Z+4, r26	; 0x04
    79be:	57 83       	std	Z+7, r21	; 0x07
    79c0:	46 83       	std	Z+6, r20	; 0x06
    79c2:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    79c6:	8d b7       	in	r24, 0x3d	; 61
    79c8:	9e b7       	in	r25, 0x3e	; 62
    79ca:	08 96       	adiw	r24, 0x08	; 8
    79cc:	0f b6       	in	r0, 0x3f	; 63
    79ce:	f8 94       	cli
    79d0:	9e bf       	out	0x3e, r25	; 62
    79d2:	0f be       	out	0x3f, r0	; 63
    79d4:	8d bf       	out	0x3d, r24	; 61
    79d6:	ce 01       	movw	r24, r28
    79d8:	8b 55       	subi	r24, 0x5B	; 91
    79da:	9f 4f       	sbci	r25, 0xFF	; 255
    79dc:	6e ef       	ldi	r22, 0xFE	; 254
    79de:	74 e0       	ldi	r23, 0x04	; 4
    79e0:	48 ee       	ldi	r20, 0xE8	; 232
    79e2:	51 e0       	ldi	r21, 0x01	; 1
    79e4:	0e 94 e9 21 	call	0x43d2	; 0x43d2 <CreateReport>

		  InserBorder(btMiddleLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btMiddleRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);     	      
    79e8:	84 e0       	ldi	r24, 0x04	; 4
    79ea:	6e ef       	ldi	r22, 0xFE	; 254
    79ec:	74 e0       	ldi	r23, 0x04	; 4
    79ee:	41 e0       	ldi	r20, 0x01	; 1
    79f0:	28 ee       	ldi	r18, 0xE8	; 232
    79f2:	31 e0       	ldi	r19, 0x01	; 1
    79f4:	0e 94 e1 19 	call	0x33c2	; 0x33c2 <InserBorder>
    79f8:	8b e0       	ldi	r24, 0x0B	; 11
    79fa:	6e ef       	ldi	r22, 0xFE	; 254
    79fc:	74 e0       	ldi	r23, 0x04	; 4
    79fe:	4a e2       	ldi	r20, 0x2A	; 42
    7a00:	28 ee       	ldi	r18, 0xE8	; 232
    7a02:	31 e0       	ldi	r19, 0x01	; 1
    7a04:	0e 94 e1 19 	call	0x33c2	; 0x33c2 <InserBorder>
    7a08:	86 e0       	ldi	r24, 0x06	; 6
    7a0a:	6e ef       	ldi	r22, 0xFE	; 254
    7a0c:	74 e0       	ldi	r23, 0x04	; 4
    7a0e:	41 e0       	ldi	r20, 0x01	; 1
    7a10:	28 ee       	ldi	r18, 0xE8	; 232
    7a12:	31 e0       	ldi	r19, 0x01	; 1
    7a14:	0e 94 e1 19 	call	0x33c2	; 0x33c2 <InserBorder>
    7a18:	8c e0       	ldi	r24, 0x0C	; 12
    7a1a:	6e ef       	ldi	r22, 0xFE	; 254
    7a1c:	74 e0       	ldi	r23, 0x04	; 4
    7a1e:	41 e0       	ldi	r20, 0x01	; 1
    7a20:	28 ee       	ldi	r18, 0xE8	; 232
    7a22:	31 e0       	ldi	r19, 0x01	; 1
    7a24:	0e 94 e1 19 	call	0x33c2	; 0x33c2 <InserBorder>
    7a28:	ee 24       	eor	r14, r14

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7a2a:	88 e2       	ldi	r24, 0x28	; 40
    7a2c:	28 2e       	mov	r2, r24
    7a2e:	31 2c       	mov	r3, r1
    7a30:	2c 0e       	add	r2, r28
    7a32:	3d 1e       	adc	r3, r29
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    7a34:	07 e3       	ldi	r16, 0x37	; 55
    7a36:	60 2e       	mov	r6, r16
    7a38:	71 2c       	mov	r7, r1
    7a3a:	6c 0e       	add	r6, r28
    7a3c:	7d 1e       	adc	r7, r29
    7a3e:	d3 01       	movw	r26, r6
    7a40:	1f 96       	adiw	r26, 0x0f	; 15
    7a42:	cb 50       	subi	r28, 0x0B	; 11
    7a44:	df 4f       	sbci	r29, 0xFF	; 255
    7a46:	b9 83       	std	Y+1, r27	; 0x01
    7a48:	a8 83       	st	Y, r26
    7a4a:	c5 5f       	subi	r28, 0xF5	; 245
    7a4c:	d0 40       	sbci	r29, 0x00	; 0
    7a4e:	16 e4       	ldi	r17, 0x46	; 70
    7a50:	41 2e       	mov	r4, r17
    7a52:	51 2c       	mov	r5, r1
    7a54:	4c 0e       	add	r4, r28
    7a56:	5d 1e       	adc	r5, r29
    7a58:	f2 01       	movw	r30, r4
    7a5a:	3f 96       	adiw	r30, 0x0f	; 15
    7a5c:	c9 50       	subi	r28, 0x09	; 9
    7a5e:	df 4f       	sbci	r29, 0xFF	; 255
    7a60:	f9 83       	std	Y+1, r31	; 0x01
    7a62:	e8 83       	st	Y, r30
    7a64:	c7 5f       	subi	r28, 0xF7	; 247
    7a66:	d0 40       	sbci	r29, 0x00	; 0
    7a68:	bd e7       	ldi	r27, 0x7D	; 125
    7a6a:	8b 2e       	mov	r8, r27
    7a6c:	91 2c       	mov	r9, r1
    7a6e:	8c 0e       	add	r8, r28
    7a70:	9d 1e       	adc	r9, r29
    7a72:	e3 c1       	rjmp	.+966    	; 0x7e3a <systemGenerateReport+0x1546>
    7a74:	f5 01       	movw	r30, r10
    7a76:	e6 51       	subi	r30, 0x16	; 22
    7a78:	fe 4f       	sbci	r31, 0xFE	; 254
    7a7a:	80 81       	ld	r24, Z
    7a7c:	80 53       	subi	r24, 0x30	; 48
    7a7e:	8a 30       	cpi	r24, 0x0A	; 10
    7a80:	08 f0       	brcs	.+2      	; 0x7a84 <systemGenerateReport+0x1190>
    7a82:	80 e0       	ldi	r24, 0x00	; 0
		  else sprintf_P(strReport,PSTR("TOTAL %s%s"),strTabSpace,strTotalVolume);CreateReport(strReport,PrintBuffer,&RepPos);

		  InserBorder(btMiddleLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btMiddleRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);     	      

		  for(iTotal=0;iTotal<strlen(GradeList);iTotal++){
		      xGrade=Ord(GradeList[iTotal]);
    7a84:	80 93 f7 01 	sts	0x01F7, r24
			  if (xGrade>0){
    7a88:	88 23       	and	r24, r24
    7a8a:	09 f4       	brne	.+2      	; 0x7a8e <systemGenerateReport+0x119a>
    7a8c:	d5 c1       	rjmp	.+938    	; 0x7e38 <systemGenerateReport+0x1544>
			      GetProductName(xGrade,strProduct);
    7a8e:	60 e7       	ldi	r22, 0x70	; 112
    7a90:	78 e0       	ldi	r23, 0x08	; 8
    7a92:	0e 94 bb 2d 	call	0x5b76	; 0x5b76 <GetProductName>
    7a96:	eb e2       	ldi	r30, 0x2B	; 43
    7a98:	f9 e0       	ldi	r31, 0x09	; 9
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    7a9a:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7a9c:	89 e0       	ldi	r24, 0x09	; 9
    7a9e:	ef 33       	cpi	r30, 0x3F	; 63
    7aa0:	f8 07       	cpc	r31, r24
    7aa2:	d9 f7       	brne	.-10     	; 0x7a9a <systemGenerateReport+0x11a6>
    7aa4:	ec ed       	ldi	r30, 0xDC	; 220
    7aa6:	f9 e0       	ldi	r31, 0x09	; 9
	     strMemory[i]=data;
    7aa8:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7aaa:	99 e0       	ldi	r25, 0x09	; 9
    7aac:	e0 3f       	cpi	r30, 0xF0	; 240
    7aae:	f9 07       	cpc	r31, r25
    7ab0:	d9 f7       	brne	.-10     	; 0x7aa8 <systemGenerateReport+0x11b4>
			      GetProductName(xGrade,strProduct);
				  
				  FillChar(strTotalVolume,sizeof(strTotalVolume),0);
				  FillChar(strTotalMoney,sizeof(strTotalMoney),0);

				  for(xPump=1;xPump<=8;xPump++){
    7ab2:	81 e0       	ldi	r24, 0x01	; 1
    7ab4:	80 93 f9 01 	sts	0x01F9, r24

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7ab8:	a9 e1       	ldi	r26, 0x19	; 25
    7aba:	ca 2e       	mov	r12, r26
    7abc:	d1 2c       	mov	r13, r1
    7abe:	cc 0e       	add	r12, r28
    7ac0:	dd 1e       	adc	r13, r29
    7ac2:	e6 c0       	rjmp	.+460    	; 0x7c90 <systemGenerateReport+0x139c>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    7ac4:	ce 01       	movw	r24, r28
    7ac6:	07 96       	adiw	r24, 0x07	; 7
    7ac8:	65 e4       	ldi	r22, 0x45	; 69
    7aca:	70 e0       	ldi	r23, 0x00	; 0
    7acc:	48 e0       	ldi	r20, 0x08	; 8
    7ace:	50 e0       	ldi	r21, 0x00	; 0
    7ad0:	2d ef       	ldi	r18, 0xFD	; 253
    7ad2:	32 e1       	ldi	r19, 0x12	; 18
    7ad4:	0e 94 f1 b3 	call	0x167e2	; 0x167e2 <__eerd_block>
				  FillChar(strTotalVolume,sizeof(strTotalVolume),0);
				  FillChar(strTotalMoney,sizeof(strTotalMoney),0);

				  for(xPump=1;xPump<=8;xPump++){
				      eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap, 8);
			          PumpNum=PPumpID[xPump-1];
    7ad8:	80 91 f9 01 	lds	r24, 0x01F9
    7adc:	fe 01       	movw	r30, r28
    7ade:	e8 0f       	add	r30, r24
    7ae0:	f1 1d       	adc	r31, r1
    7ae2:	86 81       	ldd	r24, Z+6	; 0x06
    7ae4:	80 93 f6 01 	sts	0x01F6, r24
					  if (PumpNum>0){
    7ae8:	88 23       	and	r24, r24
    7aea:	09 f4       	brne	.+2      	; 0x7aee <systemGenerateReport+0x11fa>
    7aec:	cc c0       	rjmp	.+408    	; 0x7c86 <systemGenerateReport+0x1392>
						  for (xNozzle=1;xNozzle<=6;xNozzle++){
    7aee:	81 e0       	ldi	r24, 0x01	; 1
    7af0:	c3 c0       	rjmp	.+390    	; 0x7c78 <systemGenerateReport+0x1384>
    7af2:	60 91 f9 01 	lds	r22, 0x01F9
    7af6:	a6 e0       	ldi	r26, 0x06	; 6
    7af8:	6a 9f       	mul	r22, r26
    7afa:	b0 01       	movw	r22, r0
    7afc:	11 24       	eor	r1, r1
    7afe:	61 5b       	subi	r22, 0xB1	; 177
    7b00:	7f 4f       	sbci	r23, 0xFF	; 255
    7b02:	ce 01       	movw	r24, r28
    7b04:	01 96       	adiw	r24, 0x01	; 1
    7b06:	46 e0       	ldi	r20, 0x06	; 6
    7b08:	50 e0       	ldi	r21, 0x00	; 0
    7b0a:	2d ef       	ldi	r18, 0xFD	; 253
    7b0c:	32 e1       	ldi	r19, 0x12	; 18
    7b0e:	0e 94 f1 b3 	call	0x167e2	; 0x167e2 <__eerd_block>
							  eeprom_read_block((void*) &PProductID, (const void*) &DefNozzleMap[xPump-1], 6);
							  //Found Grade
						      if (PProductID[xNozzle-1]==xGrade){
    7b12:	80 91 f8 01 	lds	r24, 0x01F8
    7b16:	fe 01       	movw	r30, r28
    7b18:	e8 0f       	add	r30, r24
    7b1a:	f1 1d       	adc	r31, r1
    7b1c:	90 81       	ld	r25, Z
    7b1e:	80 91 f7 01 	lds	r24, 0x01F7
    7b22:	98 17       	cp	r25, r24
    7b24:	09 f0       	breq	.+2      	; 0x7b28 <systemGenerateReport+0x1234>
    7b26:	a5 c0       	rjmp	.+330    	; 0x7c72 <systemGenerateReport+0x137e>
    7b28:	e4 e6       	ldi	r30, 0x64	; 100
    7b2a:	fd e0       	ldi	r31, 0x0D	; 13
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    7b2c:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7b2e:	bd e0       	ldi	r27, 0x0D	; 13
    7b30:	e3 37       	cpi	r30, 0x73	; 115
    7b32:	fb 07       	cpc	r31, r27
    7b34:	d9 f7       	brne	.-10     	; 0x7b2c <systemGenerateReport+0x1238>
    7b36:	e9 e3       	ldi	r30, 0x39	; 57
    7b38:	fa e0       	ldi	r31, 0x0A	; 10
	     strMemory[i]=data;
    7b3a:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7b3c:	8a e0       	ldi	r24, 0x0A	; 10
    7b3e:	e8 34       	cpi	r30, 0x48	; 72
    7b40:	f8 07       	cpc	r31, r24
    7b42:	d9 f7       	brne	.-10     	; 0x7b3a <systemGenerateReport+0x1246>
    7b44:	f6 01       	movw	r30, r12
	     strMemory[i]=data;
    7b46:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7b48:	e2 15       	cp	r30, r2
    7b4a:	f3 05       	cpc	r31, r3
    7b4c:	e1 f7       	brne	.-8      	; 0x7b46 <systemGenerateReport+0x1252>
    7b4e:	f1 01       	movw	r30, r2
	     strMemory[i]=data;
    7b50:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7b52:	e6 15       	cp	r30, r6
    7b54:	f7 05       	cpc	r31, r7
    7b56:	e1 f7       	brne	.-8      	; 0x7b50 <systemGenerateReport+0x125c>
    7b58:	f3 01       	movw	r30, r6
	     strMemory[i]=data;
    7b5a:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7b5c:	cb 50       	subi	r28, 0x0B	; 11
    7b5e:	df 4f       	sbci	r29, 0xFF	; 255
    7b60:	a8 81       	ld	r26, Y
    7b62:	b9 81       	ldd	r27, Y+1	; 0x01
    7b64:	c5 5f       	subi	r28, 0xF5	; 245
    7b66:	d0 40       	sbci	r29, 0x00	; 0
    7b68:	ea 17       	cp	r30, r26
    7b6a:	fb 07       	cpc	r31, r27
    7b6c:	b1 f7       	brne	.-20     	; 0x7b5a <systemGenerateReport+0x1266>
    7b6e:	f2 01       	movw	r30, r4
	     strMemory[i]=data;
    7b70:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7b72:	c9 50       	subi	r28, 0x09	; 9
    7b74:	df 4f       	sbci	r29, 0xFF	; 255
    7b76:	88 81       	ld	r24, Y
    7b78:	99 81       	ldd	r25, Y+1	; 0x01
    7b7a:	c7 5f       	subi	r28, 0xF7	; 247
    7b7c:	d0 40       	sbci	r29, 0x00	; 0
    7b7e:	e8 17       	cp	r30, r24
    7b80:	f9 07       	cpc	r31, r25
    7b82:	b1 f7       	brne	.-20     	; 0x7b70 <systemGenerateReport+0x127c>
								  FillChar(strLastVolume,sizeof(strLastVolume),0);
								  FillChar(strLastMoney,sizeof(strLastMoney),0);
								  FillChar(strCurrentVolume,sizeof(strCurrentVolume),0);
								  FillChar(strCurrentMoney,sizeof(strCurrentMoney),0);

								  PumpNozzle=xNozzle;
    7b84:	80 91 f8 01 	lds	r24, 0x01F8
    7b88:	80 93 f5 01 	sts	0x01F5, r24
								  
								  FIPAddr=GetFIPAddr(PumpNum); 
    7b8c:	80 91 f6 01 	lds	r24, 0x01F6
    7b90:	0e 94 41 1d 	call	0x3a82	; 0x3a82 <GetFIPAddr>
								  if (FIPAddr>0){
    7b94:	88 23       	and	r24, r24
    7b96:	11 f1       	breq	.+68     	; 0x7bdc <systemGenerateReport+0x12e8>
									  FIPAddr=FIPAddr-1;							  							  							      
    7b98:	f8 2e       	mov	r15, r24
    7b9a:	fa 94       	dec	r15
									  GetTotalizerData(TVOLUME,TOTALIZER_LAST,FIPAddr,PumpNozzle,strLastVolume);
    7b9c:	80 e0       	ldi	r24, 0x00	; 0
    7b9e:	60 e0       	ldi	r22, 0x00	; 0
    7ba0:	4f 2d       	mov	r20, r15
    7ba2:	20 91 f5 01 	lds	r18, 0x01F5
    7ba6:	86 01       	movw	r16, r12
    7ba8:	0e 94 00 1e 	call	0x3c00	; 0x3c00 <GetTotalizerData>
									  GetTotalizerData(TMONEY,TOTALIZER_LAST,FIPAddr,PumpNozzle,strLastMoney);
    7bac:	81 e0       	ldi	r24, 0x01	; 1
    7bae:	60 e0       	ldi	r22, 0x00	; 0
    7bb0:	4f 2d       	mov	r20, r15
    7bb2:	20 91 f5 01 	lds	r18, 0x01F5
    7bb6:	81 01       	movw	r16, r2
    7bb8:	0e 94 00 1e 	call	0x3c00	; 0x3c00 <GetTotalizerData>

									  GetTotalizerData(TVOLUME,TOTALIZER_NOW,FIPAddr,PumpNozzle,strCurrentVolume);
    7bbc:	80 e0       	ldi	r24, 0x00	; 0
    7bbe:	61 e0       	ldi	r22, 0x01	; 1
    7bc0:	4f 2d       	mov	r20, r15
    7bc2:	20 91 f5 01 	lds	r18, 0x01F5
    7bc6:	83 01       	movw	r16, r6
    7bc8:	0e 94 00 1e 	call	0x3c00	; 0x3c00 <GetTotalizerData>
									  GetTotalizerData(TMONEY,TOTALIZER_NOW,FIPAddr,PumpNozzle,strCurrentMoney);
    7bcc:	81 e0       	ldi	r24, 0x01	; 1
    7bce:	61 e0       	ldi	r22, 0x01	; 1
    7bd0:	4f 2d       	mov	r20, r15
    7bd2:	20 91 f5 01 	lds	r18, 0x01F5
    7bd6:	82 01       	movw	r16, r4
    7bd8:	0e 94 00 1e 	call	0x3c00	; 0x3c00 <GetTotalizerData>
								  }

								  StrCalc(TMINUS,strCurrentVolume,strLastVolume,strDeltaVolume);
    7bdc:	80 e0       	ldi	r24, 0x00	; 0
    7bde:	b3 01       	movw	r22, r6
    7be0:	a6 01       	movw	r20, r12
    7be2:	29 e3       	ldi	r18, 0x39	; 57
    7be4:	3a e0       	ldi	r19, 0x0A	; 10
    7be6:	0e 94 53 29 	call	0x52a6	; 0x52a6 <StrCalc>
								  if (IsMinus(strDeltaVolume)==True)
    7bea:	89 e3       	ldi	r24, 0x39	; 57
    7bec:	9a e0       	ldi	r25, 0x0A	; 10
    7bee:	0e 94 4e 23 	call	0x469c	; 0x469c <IsMinus>
    7bf2:	81 30       	cpi	r24, 0x01	; 1
    7bf4:	21 f4       	brne	.+8      	; 0x7bfe <systemGenerateReport+0x130a>
								      NormalizeOverflow(strDeltaVolume);
    7bf6:	89 e3       	ldi	r24, 0x39	; 57
    7bf8:	9a e0       	ldi	r25, 0x0A	; 10
    7bfa:	0e 94 ea 2c 	call	0x59d4	; 0x59d4 <NormalizeOverflow>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    7bfe:	e1 99       	sbic	0x1c, 1	; 28
    7c00:	fe cf       	rjmp	.-4      	; 0x7bfe <systemGenerateReport+0x130a>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    7c02:	a7 e3       	ldi	r26, 0x37	; 55
    7c04:	b1 e0       	ldi	r27, 0x01	; 1
    7c06:	bf bb       	out	0x1f, r27	; 31
    7c08:	ae bb       	out	0x1e, r26	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    7c0a:	e0 9a       	sbi	0x1c, 0	; 28
    7c0c:	8d b3       	in	r24, 0x1d	; 29


								  //Calculate Wayne Estimated Total Money
								  if (eeprom_read_byte(&DefDispenserBrand)==ST_WAYNE_DART){
    7c0e:	82 30       	cpi	r24, 0x02	; 2
    7c10:	79 f4       	brne	.+30     	; 0x7c30 <systemGenerateReport+0x133c>
						              GetProductPrice(sPrice,PumpNum,PumpNozzle);//Money = Price x Volume
    7c12:	ce 01       	movw	r24, r28
    7c14:	0f 96       	adiw	r24, 0x0f	; 15
    7c16:	60 91 f6 01 	lds	r22, 0x01F6
    7c1a:	40 91 f5 01 	lds	r20, 0x01F5
    7c1e:	0e 94 31 24 	call	0x4862	; 0x4862 <GetProductPrice>
									  StrCalc(TMULTIPLY,sPrice,strDeltaVolume,strDeltaMoney);
    7c22:	82 e0       	ldi	r24, 0x02	; 2
    7c24:	be 01       	movw	r22, r28
    7c26:	61 5f       	subi	r22, 0xF1	; 241
    7c28:	7f 4f       	sbci	r23, 0xFF	; 255
    7c2a:	49 e3       	ldi	r20, 0x39	; 57
    7c2c:	5a e0       	ldi	r21, 0x0A	; 10
    7c2e:	03 c0       	rjmp	.+6      	; 0x7c36 <systemGenerateReport+0x1342>
								  }else StrCalc(TMINUS,strCurrentMoney,strLastMoney,strDeltaMoney);
    7c30:	80 e0       	ldi	r24, 0x00	; 0
    7c32:	b2 01       	movw	r22, r4
    7c34:	a1 01       	movw	r20, r2
    7c36:	24 e6       	ldi	r18, 0x64	; 100
    7c38:	3d e0       	ldi	r19, 0x0D	; 13
    7c3a:	0e 94 53 29 	call	0x52a6	; 0x52a6 <StrCalc>
								  //StrCalc(TMINUS,strCurrentMoney,strLastMoney,strDeltaMoney);
								  if (IsMinus(strDeltaMoney)==True)
    7c3e:	84 e6       	ldi	r24, 0x64	; 100
    7c40:	9d e0       	ldi	r25, 0x0D	; 13
    7c42:	0e 94 4e 23 	call	0x469c	; 0x469c <IsMinus>
    7c46:	81 30       	cpi	r24, 0x01	; 1
    7c48:	21 f4       	brne	.+8      	; 0x7c52 <systemGenerateReport+0x135e>
								      NormalizeOverflow(strDeltaMoney);
    7c4a:	84 e6       	ldi	r24, 0x64	; 100
    7c4c:	9d e0       	ldi	r25, 0x0D	; 13
    7c4e:	0e 94 ea 2c 	call	0x59d4	; 0x59d4 <NormalizeOverflow>
		  
								  StrCalc(TPLUS,strTotalVolume,strDeltaVolume,strTotalVolume);
    7c52:	81 e0       	ldi	r24, 0x01	; 1
    7c54:	6b e2       	ldi	r22, 0x2B	; 43
    7c56:	79 e0       	ldi	r23, 0x09	; 9
    7c58:	49 e3       	ldi	r20, 0x39	; 57
    7c5a:	5a e0       	ldi	r21, 0x0A	; 10
    7c5c:	9b 01       	movw	r18, r22
    7c5e:	0e 94 53 29 	call	0x52a6	; 0x52a6 <StrCalc>
								  StrCalc(TPLUS,strTotalMoney,strDeltaMoney,strTotalMoney);
    7c62:	81 e0       	ldi	r24, 0x01	; 1
    7c64:	6c ed       	ldi	r22, 0xDC	; 220
    7c66:	79 e0       	ldi	r23, 0x09	; 9
    7c68:	44 e6       	ldi	r20, 0x64	; 100
    7c6a:	5d e0       	ldi	r21, 0x0D	; 13
    7c6c:	9b 01       	movw	r18, r22
    7c6e:	0e 94 53 29 	call	0x52a6	; 0x52a6 <StrCalc>

				  for(xPump=1;xPump<=8;xPump++){
				      eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap, 8);
			          PumpNum=PPumpID[xPump-1];
					  if (PumpNum>0){
						  for (xNozzle=1;xNozzle<=6;xNozzle++){
    7c72:	80 91 f8 01 	lds	r24, 0x01F8
    7c76:	8f 5f       	subi	r24, 0xFF	; 255
    7c78:	80 93 f8 01 	sts	0x01F8, r24
    7c7c:	80 91 f8 01 	lds	r24, 0x01F8
    7c80:	87 30       	cpi	r24, 0x07	; 7
    7c82:	08 f4       	brcc	.+2      	; 0x7c86 <systemGenerateReport+0x1392>
    7c84:	36 cf       	rjmp	.-404    	; 0x7af2 <systemGenerateReport+0x11fe>
			      GetProductName(xGrade,strProduct);
				  
				  FillChar(strTotalVolume,sizeof(strTotalVolume),0);
				  FillChar(strTotalMoney,sizeof(strTotalMoney),0);

				  for(xPump=1;xPump<=8;xPump++){
    7c86:	80 91 f9 01 	lds	r24, 0x01F9
    7c8a:	8f 5f       	subi	r24, 0xFF	; 255
    7c8c:	80 93 f9 01 	sts	0x01F9, r24
    7c90:	80 91 f9 01 	lds	r24, 0x01F9
    7c94:	89 30       	cpi	r24, 0x09	; 9
    7c96:	08 f4       	brcc	.+2      	; 0x7c9a <systemGenerateReport+0x13a6>
    7c98:	15 cf       	rjmp	.-470    	; 0x7ac4 <systemGenerateReport+0x11d0>
							  }
						  }
					  }				  
				  }

				  RemZeroLead(strTotalMoney);
    7c9a:	8c ed       	ldi	r24, 0xDC	; 220
    7c9c:	99 e0       	ldi	r25, 0x09	; 9
    7c9e:	0e 94 19 25 	call	0x4a32	; 0x4a32 <RemZeroLead>
				  RemZeroLead(strTotalVolume);
    7ca2:	0b e2       	ldi	r16, 0x2B	; 43
    7ca4:	19 e0       	ldi	r17, 0x09	; 9
    7ca6:	c8 01       	movw	r24, r16
    7ca8:	0e 94 19 25 	call	0x4a32	; 0x4a32 <RemZeroLead>

				  FormatTotalizerMoney(strTotalMoney);
    7cac:	8c ed       	ldi	r24, 0xDC	; 220
    7cae:	99 e0       	ldi	r25, 0x09	; 9
    7cb0:	0e 94 46 34 	call	0x688c	; 0x688c <FormatTotalizerMoney>
				  FormatCurrency(strTotalMoney);
    7cb4:	8c ed       	ldi	r24, 0xDC	; 220
    7cb6:	99 e0       	ldi	r25, 0x09	; 9
    7cb8:	0e 94 09 33 	call	0x6612	; 0x6612 <FormatCurrency>

				  FormatTotalizerVolume(strTotalVolume);
    7cbc:	c8 01       	movw	r24, r16
    7cbe:	0e 94 39 34 	call	0x6872	; 0x6872 <FormatTotalizerVolume>
				  FormatCurrency(strTotalVolume);
    7cc2:	c8 01       	movw	r24, r16
    7cc4:	0e 94 09 33 	call	0x6612	; 0x6612 <FormatCurrency>
		          //Test
				 // RemZeroLead(strTotalMoney);
				 // RemZeroLead(strTotalVolume);


			      GetTabSpace((21-strlen(strProduct)-strlen(strTotalVolume)),strTabSpace);
    7cc8:	e0 e7       	ldi	r30, 0x70	; 112
    7cca:	f8 e0       	ldi	r31, 0x08	; 8
    7ccc:	01 90       	ld	r0, Z+
    7cce:	00 20       	and	r0, r0
    7cd0:	e9 f7       	brne	.-6      	; 0x7ccc <systemGenerateReport+0x13d8>
    7cd2:	31 97       	sbiw	r30, 0x01	; 1
    7cd4:	e0 57       	subi	r30, 0x70	; 112
    7cd6:	f8 40       	sbci	r31, 0x08	; 8
    7cd8:	d8 01       	movw	r26, r16
    7cda:	0d 90       	ld	r0, X+
    7cdc:	00 20       	and	r0, r0
    7cde:	e9 f7       	brne	.-6      	; 0x7cda <systemGenerateReport+0x13e6>
    7ce0:	8d 01       	movw	r16, r26
    7ce2:	01 50       	subi	r16, 0x01	; 1
    7ce4:	10 40       	sbci	r17, 0x00	; 0
    7ce6:	0b 52       	subi	r16, 0x2B	; 43
    7ce8:	19 40       	sbci	r17, 0x09	; 9
    7cea:	8e 2f       	mov	r24, r30
    7cec:	81 95       	neg	r24
    7cee:	80 1b       	sub	r24, r16
    7cf0:	8b 5e       	subi	r24, 0xEB	; 235
    7cf2:	de 01       	movw	r26, r28
    7cf4:	a7 59       	subi	r26, 0x97	; 151
    7cf6:	bf 4f       	sbci	r27, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    7cf8:	18 16       	cp	r1, r24
    7cfa:	7c f4       	brge	.+30     	; 0x7d1a <systemGenerateReport+0x1426>
    7cfc:	fd 01       	movw	r30, r26
    7cfe:	90 e0       	ldi	r25, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    7d00:	20 e2       	ldi	r18, 0x20	; 32
    7d02:	02 c0       	rjmp	.+4      	; 0x7d08 <systemGenerateReport+0x1414>
    7d04:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    7d06:	9f 5f       	subi	r25, 0xFF	; 255
    7d08:	98 17       	cp	r25, r24
    7d0a:	e0 f3       	brcs	.-8      	; 0x7d04 <systemGenerateReport+0x1410>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    7d0c:	fe 01       	movw	r30, r28
    7d0e:	e7 59       	subi	r30, 0x97	; 151
    7d10:	ff 4f       	sbci	r31, 0xFF	; 255
    7d12:	e8 0f       	add	r30, r24
    7d14:	f1 1d       	adc	r31, r1
    7d16:	10 82       	st	Z, r1
    7d18:	04 c0       	rjmp	.+8      	; 0x7d22 <systemGenerateReport+0x142e>
     }else{
	 strTab[0]=' ';
    7d1a:	80 e2       	ldi	r24, 0x20	; 32
    7d1c:	8c 93       	st	X, r24
	 strTab[1]=0;
    7d1e:	11 96       	adiw	r26, 0x01	; 1
    7d20:	1c 92       	st	X, r1
				 // RemZeroLead(strTotalMoney);
				 // RemZeroLead(strTotalVolume);


			      GetTabSpace((21-strlen(strProduct)-strlen(strTotalVolume)),strTabSpace);
			      GetTabSpace((15-strlen(strTotalMoney)),strTabSpace2);
    7d22:	ec ed       	ldi	r30, 0xDC	; 220
    7d24:	f9 e0       	ldi	r31, 0x09	; 9
    7d26:	01 90       	ld	r0, Z+
    7d28:	00 20       	and	r0, r0
    7d2a:	e9 f7       	brne	.-6      	; 0x7d26 <systemGenerateReport+0x1432>
    7d2c:	31 97       	sbiw	r30, 0x01	; 1
    7d2e:	ec 5d       	subi	r30, 0xDC	; 220
    7d30:	f9 40       	sbci	r31, 0x09	; 9
    7d32:	9f e0       	ldi	r25, 0x0F	; 15
    7d34:	9e 1b       	sub	r25, r30
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    7d36:	19 16       	cp	r1, r25
    7d38:	6c f4       	brge	.+26     	; 0x7d54 <systemGenerateReport+0x1460>
    7d3a:	f4 01       	movw	r30, r8
    7d3c:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    7d3e:	20 e2       	ldi	r18, 0x20	; 32
    7d40:	02 c0       	rjmp	.+4      	; 0x7d46 <systemGenerateReport+0x1452>
    7d42:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    7d44:	8f 5f       	subi	r24, 0xFF	; 255
    7d46:	89 17       	cp	r24, r25
    7d48:	e0 f3       	brcs	.-8      	; 0x7d42 <systemGenerateReport+0x144e>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    7d4a:	f4 01       	movw	r30, r8
    7d4c:	e9 0f       	add	r30, r25
    7d4e:	f1 1d       	adc	r31, r1
    7d50:	10 82       	st	Z, r1
    7d52:	04 c0       	rjmp	.+8      	; 0x7d5c <systemGenerateReport+0x1468>
     }else{
	 strTab[0]=' ';
    7d54:	80 e2       	ldi	r24, 0x20	; 32
    7d56:	f4 01       	movw	r30, r8
    7d58:	80 83       	st	Z, r24
	 strTab[1]=0;
    7d5a:	11 82       	std	Z+1, r1	; 0x01
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    7d5c:	e1 99       	sbic	0x1c, 1	; 28
    7d5e:	fe cf       	rjmp	.-4      	; 0x7d5c <systemGenerateReport+0x1468>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    7d60:	81 ec       	ldi	r24, 0xC1	; 193
    7d62:	93 e0       	ldi	r25, 0x03	; 3
    7d64:	9f bb       	out	0x1f, r25	; 31
    7d66:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    7d68:	e0 9a       	sbi	0x1c, 0	; 28
    7d6a:	8d b3       	in	r24, 0x1d	; 29
    7d6c:	9e 01       	movw	r18, r28
    7d6e:	2b 55       	subi	r18, 0x5B	; 91
    7d70:	3f 4f       	sbci	r19, 0xFF	; 255
    7d72:	4b e2       	ldi	r20, 0x2B	; 43
    7d74:	59 e0       	ldi	r21, 0x09	; 9
    7d76:	f0 e7       	ldi	r31, 0x70	; 112
    7d78:	cf 2e       	mov	r12, r31
    7d7a:	f8 e0       	ldi	r31, 0x08	; 8
    7d7c:	df 2e       	mov	r13, r31
    7d7e:	de 01       	movw	r26, r28
    7d80:	a7 59       	subi	r26, 0x97	; 151
    7d82:	bf 4f       	sbci	r27, 0xFF	; 255
    7d84:	b5 01       	movw	r22, r10
    7d86:	6f 5f       	subi	r22, 0xFF	; 255
    7d88:	7f 4f       	sbci	r23, 0xFF	; 255

			      GetTabSpace((21-strlen(strProduct)-strlen(strTotalVolume)),strTabSpace);
			      GetTabSpace((15-strlen(strTotalMoney)),strTabSpace2);

				  //PrintMoney
		          if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("%d.%s%s%s%s%s"),iTotal+1,strProduct,strTabSpace,strTotalVolume,strTabSpace2,strTotalMoney);
    7d8a:	81 30       	cpi	r24, 0x01	; 1
    7d8c:	39 f5       	brne	.+78     	; 0x7ddc <systemGenerateReport+0x14e8>
    7d8e:	ed b7       	in	r30, 0x3d	; 61
    7d90:	fe b7       	in	r31, 0x3e	; 62
    7d92:	70 97       	sbiw	r30, 0x10	; 16
    7d94:	0f b6       	in	r0, 0x3f	; 63
    7d96:	f8 94       	cli
    7d98:	fe bf       	out	0x3e, r31	; 62
    7d9a:	0f be       	out	0x3f, r0	; 63
    7d9c:	ed bf       	out	0x3d, r30	; 61
    7d9e:	0d b7       	in	r16, 0x3d	; 61
    7da0:	1e b7       	in	r17, 0x3e	; 62
    7da2:	0f 5f       	subi	r16, 0xFF	; 255
    7da4:	1f 4f       	sbci	r17, 0xFF	; 255
    7da6:	32 83       	std	Z+2, r19	; 0x02
    7da8:	21 83       	std	Z+1, r18	; 0x01
    7daa:	88 ed       	ldi	r24, 0xD8	; 216
    7dac:	93 e0       	ldi	r25, 0x03	; 3
    7dae:	f8 01       	movw	r30, r16
    7db0:	93 83       	std	Z+3, r25	; 0x03
    7db2:	82 83       	std	Z+2, r24	; 0x02
    7db4:	75 83       	std	Z+5, r23	; 0x05
    7db6:	64 83       	std	Z+4, r22	; 0x04
    7db8:	d7 82       	std	Z+7, r13	; 0x07
    7dba:	c6 82       	std	Z+6, r12	; 0x06
    7dbc:	b1 87       	std	Z+9, r27	; 0x09
    7dbe:	a0 87       	std	Z+8, r26	; 0x08
    7dc0:	53 87       	std	Z+11, r21	; 0x0b
    7dc2:	42 87       	std	Z+10, r20	; 0x0a
    7dc4:	95 86       	std	Z+13, r9	; 0x0d
    7dc6:	84 86       	std	Z+12, r8	; 0x0c
    7dc8:	8c ed       	ldi	r24, 0xDC	; 220
    7dca:	99 e0       	ldi	r25, 0x09	; 9
    7dcc:	97 87       	std	Z+15, r25	; 0x0f
    7dce:	86 87       	std	Z+14, r24	; 0x0e
    7dd0:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    7dd4:	8d b7       	in	r24, 0x3d	; 61
    7dd6:	9e b7       	in	r25, 0x3e	; 62
    7dd8:	40 96       	adiw	r24, 0x10	; 16
    7dda:	20 c0       	rjmp	.+64     	; 0x7e1c <systemGenerateReport+0x1528>
				  else sprintf_P(strReport,PSTR("%d.%s%s%s"),iTotal+1,strProduct,strTabSpace,strTotalVolume);
    7ddc:	ed b7       	in	r30, 0x3d	; 61
    7dde:	fe b7       	in	r31, 0x3e	; 62
    7de0:	3c 97       	sbiw	r30, 0x0c	; 12
    7de2:	0f b6       	in	r0, 0x3f	; 63
    7de4:	f8 94       	cli
    7de6:	fe bf       	out	0x3e, r31	; 62
    7de8:	0f be       	out	0x3f, r0	; 63
    7dea:	ed bf       	out	0x3d, r30	; 61
    7dec:	0d b7       	in	r16, 0x3d	; 61
    7dee:	1e b7       	in	r17, 0x3e	; 62
    7df0:	0f 5f       	subi	r16, 0xFF	; 255
    7df2:	1f 4f       	sbci	r17, 0xFF	; 255
    7df4:	32 83       	std	Z+2, r19	; 0x02
    7df6:	21 83       	std	Z+1, r18	; 0x01
    7df8:	8e ec       	ldi	r24, 0xCE	; 206
    7dfa:	93 e0       	ldi	r25, 0x03	; 3
    7dfc:	f8 01       	movw	r30, r16
    7dfe:	93 83       	std	Z+3, r25	; 0x03
    7e00:	82 83       	std	Z+2, r24	; 0x02
    7e02:	75 83       	std	Z+5, r23	; 0x05
    7e04:	64 83       	std	Z+4, r22	; 0x04
    7e06:	d7 82       	std	Z+7, r13	; 0x07
    7e08:	c6 82       	std	Z+6, r12	; 0x06
    7e0a:	b1 87       	std	Z+9, r27	; 0x09
    7e0c:	a0 87       	std	Z+8, r26	; 0x08
    7e0e:	53 87       	std	Z+11, r21	; 0x0b
    7e10:	42 87       	std	Z+10, r20	; 0x0a
    7e12:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    7e16:	8d b7       	in	r24, 0x3d	; 61
    7e18:	9e b7       	in	r25, 0x3e	; 62
    7e1a:	0c 96       	adiw	r24, 0x0c	; 12
    7e1c:	0f b6       	in	r0, 0x3f	; 63
    7e1e:	f8 94       	cli
    7e20:	9e bf       	out	0x3e, r25	; 62
    7e22:	0f be       	out	0x3f, r0	; 63
    7e24:	8d bf       	out	0x3d, r24	; 61

				  CreateReport(strReport,PrintBuffer,&RepPos);
    7e26:	ce 01       	movw	r24, r28
    7e28:	8b 55       	subi	r24, 0x5B	; 91
    7e2a:	9f 4f       	sbci	r25, 0xFF	; 255
    7e2c:	6e ef       	ldi	r22, 0xFE	; 254
    7e2e:	74 e0       	ldi	r23, 0x04	; 4
    7e30:	48 ee       	ldi	r20, 0xE8	; 232
    7e32:	51 e0       	ldi	r21, 0x01	; 1
    7e34:	0e 94 e9 21 	call	0x43d2	; 0x43d2 <CreateReport>
		  if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("TOTAL %s%s%s%s"),strTabSpace,strTotalVolume,strTabSpace2,strTotalMoney);//CreateReport(strReport,PrintBuffer,&RepPos);
		  else sprintf_P(strReport,PSTR("TOTAL %s%s"),strTabSpace,strTotalVolume);CreateReport(strReport,PrintBuffer,&RepPos);

		  InserBorder(btMiddleLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btMiddleRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);     	      

		  for(iTotal=0;iTotal<strlen(GradeList);iTotal++){
    7e38:	e3 94       	inc	r14
    7e3a:	ea ee       	ldi	r30, 0xEA	; 234
    7e3c:	f1 e0       	ldi	r31, 0x01	; 1
    7e3e:	01 90       	ld	r0, Z+
    7e40:	00 20       	and	r0, r0
    7e42:	e9 f7       	brne	.-6      	; 0x7e3e <systemGenerateReport+0x154a>
    7e44:	31 97       	sbiw	r30, 0x01	; 1
    7e46:	ea 5e       	subi	r30, 0xEA	; 234
    7e48:	f1 40       	sbci	r31, 0x01	; 1
    7e4a:	ae 2c       	mov	r10, r14
    7e4c:	bb 24       	eor	r11, r11
    7e4e:	ae 16       	cp	r10, r30
    7e50:	bf 06       	cpc	r11, r31
    7e52:	08 f4       	brcc	.+2      	; 0x7e56 <systemGenerateReport+0x1562>
    7e54:	0f ce       	rjmp	.-994    	; 0x7a74 <systemGenerateReport+0x1180>
				  else sprintf_P(strReport,PSTR("%d.%s%s%s"),iTotal+1,strProduct,strTabSpace,strTotalVolume);

				  CreateReport(strReport,PrintBuffer,&RepPos);
               }
		  }
          InserBorder(btBottomLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btBottomRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);
    7e56:	87 e0       	ldi	r24, 0x07	; 7
    7e58:	6e ef       	ldi	r22, 0xFE	; 254
    7e5a:	74 e0       	ldi	r23, 0x04	; 4
    7e5c:	41 e0       	ldi	r20, 0x01	; 1
    7e5e:	28 ee       	ldi	r18, 0xE8	; 232
    7e60:	31 e0       	ldi	r19, 0x01	; 1
    7e62:	0e 94 e1 19 	call	0x33c2	; 0x33c2 <InserBorder>
    7e66:	8b e0       	ldi	r24, 0x0B	; 11
    7e68:	6e ef       	ldi	r22, 0xFE	; 254
    7e6a:	74 e0       	ldi	r23, 0x04	; 4
    7e6c:	4a e2       	ldi	r20, 0x2A	; 42
    7e6e:	28 ee       	ldi	r18, 0xE8	; 232
    7e70:	31 e0       	ldi	r19, 0x01	; 1
    7e72:	0e 94 e1 19 	call	0x33c2	; 0x33c2 <InserBorder>
    7e76:	89 e0       	ldi	r24, 0x09	; 9
    7e78:	6e ef       	ldi	r22, 0xFE	; 254
    7e7a:	74 e0       	ldi	r23, 0x04	; 4
    7e7c:	41 e0       	ldi	r20, 0x01	; 1
    7e7e:	28 ee       	ldi	r18, 0xE8	; 232
    7e80:	31 e0       	ldi	r19, 0x01	; 1
    7e82:	0e 94 e1 19 	call	0x33c2	; 0x33c2 <InserBorder>
    7e86:	8c e0       	ldi	r24, 0x0C	; 12
    7e88:	6e ef       	ldi	r22, 0xFE	; 254
    7e8a:	74 e0       	ldi	r23, 0x04	; 4
    7e8c:	41 e0       	ldi	r20, 0x01	; 1
    7e8e:	28 ee       	ldi	r18, 0xE8	; 232
    7e90:	31 e0       	ldi	r19, 0x01	; 1
    7e92:	0e 94 e1 19 	call	0x33c2	; 0x33c2 <InserBorder>
		  InserBorder(btNewLine,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);
    7e96:	8c e0       	ldi	r24, 0x0C	; 12
    7e98:	6e ef       	ldi	r22, 0xFE	; 254
    7e9a:	74 e0       	ldi	r23, 0x04	; 4
    7e9c:	41 e0       	ldi	r20, 0x01	; 1
    7e9e:	28 ee       	ldi	r18, 0xE8	; 232
    7ea0:	31 e0       	ldi	r19, 0x01	; 1
    7ea2:	0e 94 e1 19 	call	0x33c2	; 0x33c2 <InserBorder>
    7ea6:	8c e0       	ldi	r24, 0x0C	; 12
    7ea8:	6e ef       	ldi	r22, 0xFE	; 254
    7eaa:	74 e0       	ldi	r23, 0x04	; 4
    7eac:	41 e0       	ldi	r20, 0x01	; 1
    7eae:	28 ee       	ldi	r18, 0xE8	; 232
    7eb0:	31 e0       	ldi	r19, 0x01	; 1
    7eb2:	0e 94 e1 19 	call	0x33c2	; 0x33c2 <InserBorder>
    7eb6:	8c e0       	ldi	r24, 0x0C	; 12
    7eb8:	6e ef       	ldi	r22, 0xFE	; 254
    7eba:	74 e0       	ldi	r23, 0x04	; 4
    7ebc:	41 e0       	ldi	r20, 0x01	; 1
    7ebe:	28 ee       	ldi	r18, 0xE8	; 232
    7ec0:	31 e0       	ldi	r19, 0x01	; 1
    7ec2:	0e 94 e1 19 	call	0x33c2	; 0x33c2 <InserBorder>
    7ec6:	8c e0       	ldi	r24, 0x0C	; 12
    7ec8:	6e ef       	ldi	r22, 0xFE	; 254
    7eca:	74 e0       	ldi	r23, 0x04	; 4
    7ecc:	41 e0       	ldi	r20, 0x01	; 1
    7ece:	28 ee       	ldi	r18, 0xE8	; 232
    7ed0:	31 e0       	ldi	r19, 0x01	; 1
    7ed2:	0e 94 e1 19 	call	0x33c2	; 0x33c2 <InserBorder>
    7ed6:	8c e0       	ldi	r24, 0x0C	; 12
    7ed8:	6e ef       	ldi	r22, 0xFE	; 254
    7eda:	74 e0       	ldi	r23, 0x04	; 4
    7edc:	41 e0       	ldi	r20, 0x01	; 1
    7ede:	28 ee       	ldi	r18, 0xE8	; 232
    7ee0:	31 e0       	ldi	r19, 0x01	; 1
    7ee2:	0e 94 e1 19 	call	0x33c2	; 0x33c2 <InserBorder>


          cmdPrint=0b00010000|(1<<PRN_PAPER_CUT);
    7ee6:	80 e3       	ldi	r24, 0x30	; 48
    7ee8:	80 93 b7 01 	sts	0x01B7, r24
		  LengthMessage81=RepPos+1;
    7eec:	80 91 e8 01 	lds	r24, 0x01E8
    7ef0:	90 91 e9 01 	lds	r25, 0x01E9
    7ef4:	01 96       	adiw	r24, 0x01	; 1
    7ef6:	90 93 91 01 	sts	0x0191, r25
    7efa:	80 93 90 01 	sts	0x0190, r24
		  IsFreePrinting=True;
    7efe:	81 e0       	ldi	r24, 0x01	; 1
    7f00:	80 93 ab 01 	sts	0x01AB, r24
	      IsBusyFreePrinting=True; 
    7f04:	80 93 b6 01 	sts	0x01B6, r24
         	       
	      stGenerateReport=grWaitPrinted3;
    7f08:	8b e0       	ldi	r24, 0x0B	; 11
    7f0a:	05 c0       	rjmp	.+10     	; 0x7f16 <systemGenerateReport+0x1622>
	      break;
     case grWaitPrinted3:
          if (IsBusyFreePrinting==False)stGenerateReport=grFinishGenerateReport;
    7f0c:	80 91 b6 01 	lds	r24, 0x01B6
    7f10:	88 23       	and	r24, r24
    7f12:	49 f4       	brne	.+18     	; 0x7f26 <systemGenerateReport+0x1632>
    7f14:	8c e0       	ldi	r24, 0x0C	; 12
    7f16:	80 93 fa 01 	sts	0x01FA, r24
    7f1a:	05 c0       	rjmp	.+10     	; 0x7f26 <systemGenerateReport+0x1632>
	      break;
     case grFinishGenerateReport:
	      IsFinishPrintingTotalizer=True;
    7f1c:	81 e0       	ldi	r24, 0x01	; 1
    7f1e:	80 93 8a 01 	sts	0x018A, r24
          stGenerateReport=grScanAction;
    7f22:	10 92 fa 01 	sts	0x01FA, r1
	      break;
	 }
}
    7f26:	c8 50       	subi	r28, 0x08	; 8
    7f28:	df 4f       	sbci	r29, 0xFF	; 255
    7f2a:	0f b6       	in	r0, 0x3f	; 63
    7f2c:	f8 94       	cli
    7f2e:	de bf       	out	0x3e, r29	; 62
    7f30:	0f be       	out	0x3f, r0	; 63
    7f32:	cd bf       	out	0x3d, r28	; 61
    7f34:	cf 91       	pop	r28
    7f36:	df 91       	pop	r29
    7f38:	1f 91       	pop	r17
    7f3a:	0f 91       	pop	r16
    7f3c:	ff 90       	pop	r15
    7f3e:	ef 90       	pop	r14
    7f40:	df 90       	pop	r13
    7f42:	cf 90       	pop	r12
    7f44:	bf 90       	pop	r11
    7f46:	af 90       	pop	r10
    7f48:	9f 90       	pop	r9
    7f4a:	8f 90       	pop	r8
    7f4c:	7f 90       	pop	r7
    7f4e:	6f 90       	pop	r6
    7f50:	5f 90       	pop	r5
    7f52:	4f 90       	pop	r4
    7f54:	3f 90       	pop	r3
    7f56:	2f 90       	pop	r2
    7f58:	08 95       	ret

00007f5a <UpdateCardID>:
	 else SeqNum=0;
	 leadingZero(SeqNum,strSeqNum);
} 


void UpdateCardID(){
    7f5a:	cf 93       	push	r28
    7f5c:	df 93       	push	r29
     char i,LengthID;
	 LengthID=strlen(strRFID);  //           +12345678  
    7f5e:	e8 e8       	ldi	r30, 0x88	; 136
    7f60:	fd e0       	ldi	r31, 0x0D	; 13
    7f62:	01 90       	ld	r0, Z+
    7f64:	00 20       	and	r0, r0
    7f66:	e9 f7       	brne	.-6      	; 0x7f62 <UpdateCardID+0x8>
    7f68:	31 97       	sbiw	r30, 0x01	; 1
    7f6a:	e8 58       	subi	r30, 0x88	; 136
    7f6c:	fd 40       	sbci	r31, 0x0D	; 13
    7f6e:	ad eb       	ldi	r26, 0xBD	; 189
    7f70:	bc e0       	ldi	r27, 0x0C	; 12
	 else SeqNum=0;
	 leadingZero(SeqNum,strSeqNum);
} 


void UpdateCardID(){
    7f72:	f0 e0       	ldi	r31, 0x00	; 0
    7f74:	ef 01       	movw	r28, r30
    7f76:	cc 58       	subi	r28, 0x8C	; 140
    7f78:	d2 4f       	sbci	r29, 0xF2	; 242
    7f7a:	20 e0       	ldi	r18, 0x00	; 0
    7f7c:	30 e0       	ldi	r19, 0x00	; 0
     char i,LengthID;
	 LengthID=strlen(strRFID);  //           +12345678  
	 for(i=0;i<20;i++){         //SSSSSSSSSSSS12345678
	    if (i<(20-LengthID))strCardID[i]=' ';
    7f7e:	44 e1       	ldi	r20, 0x14	; 20
    7f80:	50 e0       	ldi	r21, 0x00	; 0
    7f82:	4e 1b       	sub	r20, r30
    7f84:	5f 0b       	sbc	r21, r31
    7f86:	90 e2       	ldi	r25, 0x20	; 32
    7f88:	24 17       	cp	r18, r20
    7f8a:	35 07       	cpc	r19, r21
    7f8c:	14 f4       	brge	.+4      	; 0x7f92 <UpdateCardID+0x38>
    7f8e:	9c 93       	st	X, r25
    7f90:	02 c0       	rjmp	.+4      	; 0x7f96 <UpdateCardID+0x3c>
		else strCardID[i]=strRFID[i-(20-LengthID)];
    7f92:	88 81       	ld	r24, Y
    7f94:	8c 93       	st	X, r24
    7f96:	2f 5f       	subi	r18, 0xFF	; 255
    7f98:	3f 4f       	sbci	r19, 0xFF	; 255
    7f9a:	11 96       	adiw	r26, 0x01	; 1
    7f9c:	21 96       	adiw	r28, 0x01	; 1


void UpdateCardID(){
     char i,LengthID;
	 LengthID=strlen(strRFID);  //           +12345678  
	 for(i=0;i<20;i++){         //SSSSSSSSSSSS12345678
    7f9e:	24 31       	cpi	r18, 0x14	; 20
    7fa0:	31 05       	cpc	r19, r1
    7fa2:	91 f7       	brne	.-28     	; 0x7f88 <UpdateCardID+0x2e>
	    if (i<(20-LengthID))strCardID[i]=' ';
		else strCardID[i]=strRFID[i-(20-LengthID)];
	 }strCardID[20]=0;
    7fa4:	10 92 d1 0c 	sts	0x0CD1, r1

}
    7fa8:	df 91       	pop	r29
    7faa:	cf 91       	pop	r28
    7fac:	08 95       	ret

00007fae <GenerateTransactionNum>:
		 //else Result=PS_NO_DATA;    		    
	 }	
   return Result;
}

void GenerateTransactionNum(char *sTransNumber){//Create and Save TransactionNumber to EEPROM
    7fae:	cf 92       	push	r12
    7fb0:	df 92       	push	r13
    7fb2:	ef 92       	push	r14
    7fb4:	ff 92       	push	r15
    7fb6:	0f 93       	push	r16
    7fb8:	1f 93       	push	r17
    7fba:	df 93       	push	r29
    7fbc:	cf 93       	push	r28
    7fbe:	cd b7       	in	r28, 0x3d	; 61
    7fc0:	de b7       	in	r29, 0x3e	; 62
    7fc2:	27 97       	sbiw	r28, 0x07	; 7
    7fc4:	0f b6       	in	r0, 0x3f	; 63
    7fc6:	f8 94       	cli
    7fc8:	de bf       	out	0x3e, r29	; 62
    7fca:	0f be       	out	0x3f, r0	; 63
    7fcc:	cd bf       	out	0x3d, r28	; 61
    7fce:	6c 01       	movw	r12, r24
    7fd0:	fe 01       	movw	r30, r28
    7fd2:	31 96       	adiw	r30, 0x01	; 1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7fd4:	ce 01       	movw	r24, r28
    7fd6:	08 96       	adiw	r24, 0x08	; 8
	     strMemory[i]=data;
    7fd8:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7fda:	e8 17       	cp	r30, r24
    7fdc:	f9 07       	cpc	r31, r25
    7fde:	e1 f7       	brne	.-8      	; 0x7fd8 <GenerateTransactionNum+0x2a>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    7fe0:	8e 01       	movw	r16, r28
    7fe2:	0f 5f       	subi	r16, 0xFF	; 255
    7fe4:	1f 4f       	sbci	r17, 0xFF	; 255
    7fe6:	c8 01       	movw	r24, r16
    7fe8:	68 e3       	ldi	r22, 0x38	; 56
    7fea:	71 e0       	ldi	r23, 0x01	; 1
    7fec:	47 e0       	ldi	r20, 0x07	; 7
    7fee:	50 e0       	ldi	r21, 0x00	; 0
    7ff0:	2d ef       	ldi	r18, 0xFD	; 253
    7ff2:	32 e1       	ldi	r19, 0x12	; 18
    7ff4:	0e 94 f1 b3 	call	0x167e2	; 0x167e2 <__eerd_block>
     char i,PTransNum[7],cNum,xNum=0,xAdd=0,Length=0;
	 FillChar(PTransNum,sizeof(PTransNum),0);//"999999"->"000000"
     eeprom_read_block((void*) &PTransNum, (const void*) &DefTransactionNumber,sizeof(DefTransactionNumber));
     xAdd=1;
	 xNum=0;
	 Length=strlen(PTransNum);
    7ff8:	f8 01       	movw	r30, r16
    7ffa:	01 90       	ld	r0, Z+
    7ffc:	00 20       	and	r0, r0
    7ffe:	e9 f7       	brne	.-6      	; 0x7ffa <GenerateTransactionNum+0x4c>
    8000:	31 97       	sbiw	r30, 0x01	; 1
    8002:	e0 1b       	sub	r30, r16
		 //else Result=PS_NO_DATA;    		    
	 }	
   return Result;
}

void GenerateTransactionNum(char *sTransNumber){//Create and Save TransactionNumber to EEPROM
    8004:	f0 e0       	ldi	r31, 0x00	; 0
    8006:	0e 0f       	add	r16, r30
    8008:	1f 1f       	adc	r17, r31
    800a:	31 97       	sbiw	r30, 0x01	; 1
    800c:	76 01       	movw	r14, r12
    800e:	ee 0e       	add	r14, r30
    8010:	ff 1e       	adc	r15, r31
    8012:	31 96       	adiw	r30, 0x01	; 1
    8014:	61 e0       	ldi	r22, 0x01	; 1
    8016:	19 c0       	rjmp	.+50     	; 0x804a <GenerateTransactionNum+0x9c>
	 xNum=0;
	 Length=strlen(PTransNum);

	 for(i=0;i<Length;i++){//[000009] 999999 123456
	     xNum=PTransNum[Length-i-1]-'0';		 
		 cNum='0'+((xNum+xAdd)%10);
    8018:	d8 01       	movw	r26, r16
    801a:	2c 91       	ld	r18, X
    801c:	20 53       	subi	r18, 0x30	; 48
    801e:	30 e0       	ldi	r19, 0x00	; 0
    8020:	26 0f       	add	r18, r22
    8022:	31 1d       	adc	r19, r1
    8024:	c9 01       	movw	r24, r18
    8026:	6a e0       	ldi	r22, 0x0A	; 10
    8028:	70 e0       	ldi	r23, 0x00	; 0
    802a:	0e 94 1e b7 	call	0x16e3c	; 0x16e3c <__divmodhi4>
    802e:	48 2f       	mov	r20, r24
    8030:	40 5d       	subi	r20, 0xD0	; 208
		 xAdd=((xNum+xAdd)/10);
    8032:	c9 01       	movw	r24, r18
    8034:	6a e0       	ldi	r22, 0x0A	; 10
    8036:	70 e0       	ldi	r23, 0x00	; 0
    8038:	0e 94 1e b7 	call	0x16e3c	; 0x16e3c <__divmodhi4>
		 PTransNum[Length-i-1]=cNum;
    803c:	d8 01       	movw	r26, r16
    803e:	4c 93       	st	X, r20
		 sTransNumber[Length-i-1]=cNum;
    8040:	d7 01       	movw	r26, r14
    8042:	4c 93       	st	X, r20
    8044:	08 94       	sec
    8046:	e1 08       	sbc	r14, r1
    8048:	f1 08       	sbc	r15, r1
    804a:	01 50       	subi	r16, 0x01	; 1
    804c:	10 40       	sbci	r17, 0x00	; 0
     eeprom_read_block((void*) &PTransNum, (const void*) &DefTransactionNumber,sizeof(DefTransactionNumber));
     xAdd=1;
	 xNum=0;
	 Length=strlen(PTransNum);

	 for(i=0;i<Length;i++){//[000009] 999999 123456
    804e:	0c 17       	cp	r16, r28
    8050:	1d 07       	cpc	r17, r29
    8052:	11 f7       	brne	.-60     	; 0x8018 <GenerateTransactionNum+0x6a>
		 cNum='0'+((xNum+xAdd)%10);
		 xAdd=((xNum+xAdd)/10);
		 PTransNum[Length-i-1]=cNum;
		 sTransNumber[Length-i-1]=cNum;
	 }
	 sTransNumber[Length]=0;
    8054:	ce 0e       	add	r12, r30
    8056:	df 1e       	adc	r13, r31
    8058:	d6 01       	movw	r26, r12
    805a:	1c 92       	st	X, r1
	 PTransNum[Length]=0;
    805c:	be 01       	movw	r22, r28
    805e:	6f 5f       	subi	r22, 0xFF	; 255
    8060:	7f 4f       	sbci	r23, 0xFF	; 255
    8062:	e6 0f       	add	r30, r22
    8064:	f7 1f       	adc	r31, r23
    8066:	10 82       	st	Z, r1
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    8068:	88 e3       	ldi	r24, 0x38	; 56
    806a:	91 e0       	ldi	r25, 0x01	; 1
    806c:	47 e0       	ldi	r20, 0x07	; 7
    806e:	50 e0       	ldi	r21, 0x00	; 0
    8070:	25 e0       	ldi	r18, 0x05	; 5
    8072:	33 e1       	ldi	r19, 0x13	; 19
    8074:	0e 94 0d b4 	call	0x1681a	; 0x1681a <__eewr_block>

     eeprom_write_block((const void*)&PTransNum,(void*)&DefTransactionNumber,sizeof(DefTransactionNumber));
}
    8078:	27 96       	adiw	r28, 0x07	; 7
    807a:	0f b6       	in	r0, 0x3f	; 63
    807c:	f8 94       	cli
    807e:	de bf       	out	0x3e, r29	; 62
    8080:	0f be       	out	0x3f, r0	; 63
    8082:	cd bf       	out	0x3d, r28	; 61
    8084:	cf 91       	pop	r28
    8086:	df 91       	pop	r29
    8088:	1f 91       	pop	r17
    808a:	0f 91       	pop	r16
    808c:	ff 90       	pop	r15
    808e:	ef 90       	pop	r14
    8090:	df 90       	pop	r13
    8092:	cf 90       	pop	r12
    8094:	08 95       	ret

00008096 <GetParameter>:
	}
  return  PosFound;
}


void GetParameter(char *GFlow,char FLength,char *GCmd,char *GPumpID, char *GeniCSum){
    8096:	8f 92       	push	r8
    8098:	9f 92       	push	r9
    809a:	af 92       	push	r10
    809c:	bf 92       	push	r11
    809e:	cf 92       	push	r12
    80a0:	df 92       	push	r13
    80a2:	ef 92       	push	r14
    80a4:	ff 92       	push	r15
    80a6:	0f 93       	push	r16
    80a8:	1f 93       	push	r17
    80aa:	df 93       	push	r29
    80ac:	cf 93       	push	r28
    80ae:	cd b7       	in	r28, 0x3d	; 61
    80b0:	de b7       	in	r29, 0x3e	; 62
    80b2:	a7 97       	sbiw	r28, 0x27	; 39
    80b4:	0f b6       	in	r0, 0x3f	; 63
    80b6:	f8 94       	cli
    80b8:	de bf       	out	0x3e, r29	; 62
    80ba:	0f be       	out	0x3f, r0	; 63
    80bc:	cd bf       	out	0x3d, r28	; 61
    80be:	79 01       	movw	r14, r18
    80c0:	48 01       	movw	r8, r16
    80c2:	e6 2f       	mov	r30, r22
    80c4:	f0 e0       	ldi	r31, 0x00	; 0
    80c6:	31 97       	sbiw	r30, 0x01	; 1
    80c8:	e8 0f       	add	r30, r24
    80ca:	f9 1f       	adc	r31, r25
    80cc:	9e 01       	movw	r18, r28
    80ce:	26 5f       	subi	r18, 0xF6	; 246
    80d0:	3f 4f       	sbci	r19, 0xFF	; 255
    80d2:	d9 01       	movw	r26, r18
    80d4:	03 c0       	rjmp	.+6      	; 0x80dc <GetParameter+0x46>
char strSend[20],strSub[3];
int SumLength;

     //TransposeFlow
     for (i=0;i<FLength;i++){	 
	     SGeniusFlow[i]=GFlow[FLength-i-1];
    80d6:	80 81       	ld	r24, Z
    80d8:	8d 93       	st	X+, r24
    80da:	31 97       	sbiw	r30, 0x01	; 1
char SGeniusFlow[30];
char strSend[20],strSub[3];
int SumLength;

     //TransposeFlow
     for (i=0;i<FLength;i++){	 
    80dc:	8a 2f       	mov	r24, r26
    80de:	82 1b       	sub	r24, r18
    80e0:	86 17       	cp	r24, r22
    80e2:	c8 f3       	brcs	.-14     	; 0x80d6 <GetParameter+0x40>
	     SGeniusFlow[i]=GFlow[FLength-i-1];
	 }SGeniusFlow[FLength]=0;
    80e4:	c6 2e       	mov	r12, r22
    80e6:	dd 24       	eor	r13, r13
    80e8:	aa e0       	ldi	r26, 0x0A	; 10
    80ea:	aa 2e       	mov	r10, r26
    80ec:	b1 2c       	mov	r11, r1
    80ee:	ac 0e       	add	r10, r28
    80f0:	bd 1e       	adc	r11, r29
    80f2:	f5 01       	movw	r30, r10
    80f4:	ec 0d       	add	r30, r12
    80f6:	fd 1d       	adc	r31, r13
    80f8:	10 82       	st	Z, r1

	 xCmd=CharPosCopy(SGeniusFlow,0);
	 *GCmd=xCmd;
    80fa:	8a 85       	ldd	r24, Y+10	; 0x0a
    80fc:	fa 01       	movw	r30, r20
    80fe:	80 83       	st	Z, r24
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8100:	8b 85       	ldd	r24, Y+11	; 0x0b
    8102:	89 83       	std	Y+1, r24	; 0x01
    8104:	8c 85       	ldd	r24, Y+12	; 0x0c
    8106:	8a 83       	std	Y+2, r24	; 0x02
	 }Dest[Length]=0;
    8108:	1b 82       	std	Y+3, r1	; 0x03
	 }SGeniusFlow[FLength]=0;

	 xCmd=CharPosCopy(SGeniusFlow,0);
	 *GCmd=xCmd;
	 StrPosCopy(SGeniusFlow,sPumpID,1,2);
	 xPumpID=atoi(sPumpID);
    810a:	ce 01       	movw	r24, r28
    810c:	01 96       	adiw	r24, 0x01	; 1
    810e:	0e 94 c3 b3 	call	0x16786	; 0x16786 <atoi>
	 *GPumpID=xPumpID;
    8112:	f7 01       	movw	r30, r14
    8114:	80 83       	st	Z, r24
	 sprintf_P(strSub,PSTR(":"));
    8116:	00 d0       	rcall	.+0      	; 0x8118 <GetParameter+0x82>
    8118:	00 d0       	rcall	.+0      	; 0x811a <GetParameter+0x84>
    811a:	f7 e0       	ldi	r31, 0x07	; 7
    811c:	ef 2e       	mov	r14, r31
    811e:	f1 2c       	mov	r15, r1
    8120:	ec 0e       	add	r14, r28
    8122:	fd 1e       	adc	r15, r29
    8124:	ed b7       	in	r30, 0x3d	; 61
    8126:	fe b7       	in	r31, 0x3e	; 62
    8128:	f2 82       	std	Z+2, r15	; 0x02
    812a:	e1 82       	std	Z+1, r14	; 0x01
    812c:	88 e4       	ldi	r24, 0x48	; 72
    812e:	93 e0       	ldi	r25, 0x03	; 3
    8130:	94 83       	std	Z+4, r25	; 0x04
    8132:	83 83       	std	Z+3, r24	; 0x03
    8134:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
	 if (Pos(strSub,SGeniusFlow)<FLength){
    8138:	0f 90       	pop	r0
    813a:	0f 90       	pop	r0
    813c:	0f 90       	pop	r0
    813e:	0f 90       	pop	r0
    8140:	c7 01       	movw	r24, r14
    8142:	b5 01       	movw	r22, r10
    8144:	0e 94 b2 21 	call	0x4364	; 0x4364 <Pos>
    8148:	8c 15       	cp	r24, r12
    814a:	9d 05       	cpc	r25, r13
    814c:	4c f5       	brge	.+82     	; 0x81a0 <GetParameter+0x10a>
	     SumLength=FLength-Pos(strSub,SGeniusFlow);
    814e:	c7 01       	movw	r24, r14
    8150:	b5 01       	movw	r22, r10
    8152:	0e 94 b2 21 	call	0x4364	; 0x4364 <Pos>
    8156:	8c 01       	movw	r16, r24
	 	 StrPosCopy(SGeniusFlow,sCSum,Pos(strSub,SGeniusFlow)+1,SumLength);
    8158:	c7 01       	movw	r24, r14
    815a:	b5 01       	movw	r22, r10
    815c:	0e 94 b2 21 	call	0x4364	; 0x4364 <Pos>
    8160:	a6 01       	movw	r20, r12
    8162:	40 1b       	sub	r20, r16
    8164:	51 0b       	sbc	r21, r17
    8166:	d5 01       	movw	r26, r10
    8168:	a8 0f       	add	r26, r24
    816a:	b9 1f       	adc	r27, r25
    816c:	20 e0       	ldi	r18, 0x00	; 0
    816e:	30 e0       	ldi	r19, 0x00	; 0
    8170:	be 01       	movw	r22, r28
    8172:	6c 5f       	subi	r22, 0xFC	; 252
    8174:	7f 4f       	sbci	r23, 0xFF	; 255
    8176:	07 c0       	rjmp	.+14     	; 0x8186 <GetParameter+0xf0>
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8178:	fb 01       	movw	r30, r22
    817a:	e2 0f       	add	r30, r18
    817c:	f3 1f       	adc	r31, r19
    817e:	8c 91       	ld	r24, X
    8180:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8182:	2f 5f       	subi	r18, 0xFF	; 255
    8184:	3f 4f       	sbci	r19, 0xFF	; 255
    8186:	11 96       	adiw	r26, 0x01	; 1
    8188:	24 17       	cp	r18, r20
    818a:	35 07       	cpc	r19, r21
    818c:	a8 f3       	brcs	.-22     	; 0x8178 <GetParameter+0xe2>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    818e:	46 0f       	add	r20, r22
    8190:	57 1f       	adc	r21, r23
    8192:	fa 01       	movw	r30, r20
    8194:	10 82       	st	Z, r1
	 *GPumpID=xPumpID;
	 sprintf_P(strSub,PSTR(":"));
	 if (Pos(strSub,SGeniusFlow)<FLength){
	     SumLength=FLength-Pos(strSub,SGeniusFlow);
	 	 StrPosCopy(SGeniusFlow,sCSum,Pos(strSub,SGeniusFlow)+1,SumLength);
		 xCsum=atoi(sCSum);
    8196:	cb 01       	movw	r24, r22
    8198:	0e 94 c3 b3 	call	0x16786	; 0x16786 <atoi>
	     *GeniCSum=xCsum;
    819c:	f4 01       	movw	r30, r8
    819e:	80 83       	st	Z, r24
	 sprintf_P(strSend,PSTR("%d"),xPumpID);
	 _uart_print(1,1,strSend);
	 sprintf_P(strSend,PSTR("%s"),sCSum);
	 _uart_print(1,1,strSend);
*/
}
    81a0:	a7 96       	adiw	r28, 0x27	; 39
    81a2:	0f b6       	in	r0, 0x3f	; 63
    81a4:	f8 94       	cli
    81a6:	de bf       	out	0x3e, r29	; 62
    81a8:	0f be       	out	0x3f, r0	; 63
    81aa:	cd bf       	out	0x3d, r28	; 61
    81ac:	cf 91       	pop	r28
    81ae:	df 91       	pop	r29
    81b0:	1f 91       	pop	r17
    81b2:	0f 91       	pop	r16
    81b4:	ff 90       	pop	r15
    81b6:	ef 90       	pop	r14
    81b8:	df 90       	pop	r13
    81ba:	cf 90       	pop	r12
    81bc:	bf 90       	pop	r11
    81be:	af 90       	pop	r10
    81c0:	9f 90       	pop	r9
    81c2:	8f 90       	pop	r8
    81c4:	08 95       	ret

000081c6 <GeniusProtocol>:
   return Result;	 
}

//enum eGeniusProtocolCommand{GP_PUMP_STATUS,GP_PUMP_LAST_TRANSACTION,GP_PUMP_STOP,GP_PUMP_RESUME,GP_PUMP_PRESET};

void GeniusProtocol(char dataIn){
    81c6:	ff 92       	push	r15
    81c8:	0f 93       	push	r16
    81ca:	1f 93       	push	r17
    81cc:	df 93       	push	r29
    81ce:	cf 93       	push	r28
    81d0:	cd b7       	in	r28, 0x3d	; 61
    81d2:	de b7       	in	r29, 0x3e	; 62
    81d4:	67 97       	sbiw	r28, 0x17	; 23
    81d6:	0f b6       	in	r0, 0x3f	; 63
    81d8:	f8 94       	cli
    81da:	de bf       	out	0x3e, r29	; 62
    81dc:	0f be       	out	0x3f, r0	; 63
    81de:	cd bf       	out	0x3d, r28	; 61
    81e0:	f8 2e       	mov	r15, r24
	 char i,GeniCmd,GeniPumpID,GeniCSum;//,sCmd[7];
	 char strSend[20];

    //_uart(1,1,dataIn);

	if (dataIn==0x0D){	
    81e2:	8d e0       	ldi	r24, 0x0D	; 13
    81e4:	f8 16       	cp	r15, r24
    81e6:	09 f0       	breq	.+2      	; 0x81ea <GeniusProtocol+0x24>
    81e8:	45 c0       	rjmp	.+138    	; 0x8274 <GeniusProtocol+0xae>
	    GetParameter(Geniflow,FlowLength,&GeniCmd,&GeniPumpID,&GeniCSum);
    81ea:	85 ec       	ldi	r24, 0xC5	; 197
    81ec:	91 e0       	ldi	r25, 0x01	; 1
    81ee:	60 91 c4 01 	lds	r22, 0x01C4
    81f2:	ae 01       	movw	r20, r28
    81f4:	4f 5f       	subi	r20, 0xFF	; 255
    81f6:	5f 4f       	sbci	r21, 0xFF	; 255
    81f8:	9e 01       	movw	r18, r28
    81fa:	2e 5f       	subi	r18, 0xFE	; 254
    81fc:	3f 4f       	sbci	r19, 0xFF	; 255
    81fe:	8e 01       	movw	r16, r28
    8200:	0d 5f       	subi	r16, 0xFD	; 253
    8202:	1f 4f       	sbci	r17, 0xFF	; 255
    8204:	0e 94 4b 40 	call	0x8096	; 0x8096 <GetParameter>
		FlowLength=0;
    8208:	10 92 c4 01 	sts	0x01C4, r1
		IsGeniusFlow=False;
    820c:	10 92 c3 01 	sts	0x01C3, r1
		FillChar(strSend,0,sizeof(strSend));
		sprintf_P(strSend,PSTR("%c%.2d:"),GeniCmd,GeniPumpID);
    8210:	ad b7       	in	r26, 0x3d	; 61
    8212:	be b7       	in	r27, 0x3e	; 62
    8214:	18 97       	sbiw	r26, 0x08	; 8
    8216:	0f b6       	in	r0, 0x3f	; 63
    8218:	f8 94       	cli
    821a:	be bf       	out	0x3e, r27	; 62
    821c:	0f be       	out	0x3f, r0	; 63
    821e:	ad bf       	out	0x3d, r26	; 61
    8220:	ed b7       	in	r30, 0x3d	; 61
    8222:	fe b7       	in	r31, 0x3e	; 62
    8224:	31 96       	adiw	r30, 0x01	; 1
    8226:	8e 01       	movw	r16, r28
    8228:	0c 5f       	subi	r16, 0xFC	; 252
    822a:	1f 4f       	sbci	r17, 0xFF	; 255
    822c:	12 96       	adiw	r26, 0x02	; 2
    822e:	1c 93       	st	X, r17
    8230:	0e 93       	st	-X, r16
    8232:	11 97       	sbiw	r26, 0x01	; 1
    8234:	8a e3       	ldi	r24, 0x3A	; 58
    8236:	93 e0       	ldi	r25, 0x03	; 3
    8238:	93 83       	std	Z+3, r25	; 0x03
    823a:	82 83       	std	Z+2, r24	; 0x02
    823c:	89 81       	ldd	r24, Y+1	; 0x01
    823e:	84 83       	std	Z+4, r24	; 0x04
    8240:	15 82       	std	Z+5, r1	; 0x05
    8242:	8a 81       	ldd	r24, Y+2	; 0x02
    8244:	86 83       	std	Z+6, r24	; 0x06
    8246:	17 82       	std	Z+7, r1	; 0x07
    8248:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
		//_uart_print(1,1,strSend);


		if ((SumChecksum(strSend))==GeniCSum){
    824c:	8d b7       	in	r24, 0x3d	; 61
    824e:	9e b7       	in	r25, 0x3e	; 62
    8250:	08 96       	adiw	r24, 0x08	; 8
    8252:	0f b6       	in	r0, 0x3f	; 63
    8254:	f8 94       	cli
    8256:	9e bf       	out	0x3e, r25	; 62
    8258:	0f be       	out	0x3f, r0	; 63
    825a:	8d bf       	out	0x3d, r24	; 61
    825c:	c8 01       	movw	r24, r16
    825e:	0e 94 4d 21 	call	0x429a	; 0x429a <SumChecksum>
    8262:	9b 81       	ldd	r25, Y+3	; 0x03
    8264:	89 17       	cp	r24, r25
    8266:	31 f4       	brne	.+12     	; 0x8274 <GeniusProtocol+0xae>
		     switch(GeniCmd){
    8268:	89 81       	ldd	r24, Y+1	; 0x01
    826a:	84 35       	cpi	r24, 0x54	; 84
    826c:	19 f4       	brne	.+6      	; 0x8274 <GeniusProtocol+0xae>
			 case 'C'://PumpStatus
			      GeniusSendPumpStatus(GeniPumpID);
			      break;
             case 'T'://Transaction Request: T01:239<0D>
			      GeniusSendLastTransaction(GeniPumpID);
    826e:	8a 81       	ldd	r24, Y+2	; 0x02
    8270:	0e 94 26 2e 	call	0x5c4c	; 0x5c4c <GeniusSendLastTransaction>
    8274:	e7 ed       	ldi	r30, 0xD7	; 215
    8276:	f1 e0       	ldi	r31, 0x01	; 1
			 }
		}
	}
	//Shifting
	for(i=19;i>0;i--){
	    Geniflow[i]=Geniflow[i-1];	
    8278:	80 81       	ld	r24, Z
    827a:	81 83       	std	Z+1, r24	; 0x01
    827c:	31 97       	sbiw	r30, 0x01	; 1
			      break;
			 }
		}
	}
	//Shifting
	for(i=19;i>0;i--){
    827e:	91 e0       	ldi	r25, 0x01	; 1
    8280:	e4 3c       	cpi	r30, 0xC4	; 196
    8282:	f9 07       	cpc	r31, r25
    8284:	c9 f7       	brne	.-14     	; 0x8278 <GeniusProtocol+0xb2>
	    Geniflow[i]=Geniflow[i-1];	
	}Geniflow[0]=dataIn;
    8286:	f1 82       	std	Z+1, r15	; 0x01

	if (IsGeniusCommand(dataIn)==True)IsGeniusFlow=True;
    8288:	8f 2d       	mov	r24, r15
    828a:	0e 94 6d 21 	call	0x42da	; 0x42da <IsGeniusCommand>
    828e:	81 30       	cpi	r24, 0x01	; 1
    8290:	11 f4       	brne	.+4      	; 0x8296 <GeniusProtocol+0xd0>
    8292:	80 93 c3 01 	sts	0x01C3, r24
	if (IsGeniusFlow==True)FlowLength++;
    8296:	80 91 c3 01 	lds	r24, 0x01C3
    829a:	81 30       	cpi	r24, 0x01	; 1
    829c:	29 f4       	brne	.+10     	; 0x82a8 <GeniusProtocol+0xe2>
    829e:	80 91 c4 01 	lds	r24, 0x01C4
    82a2:	8f 5f       	subi	r24, 0xFF	; 255
    82a4:	80 93 c4 01 	sts	0x01C4, r24
	Geniflow[3]=Geniflow[2];
	Geniflow[2]=Geniflow[1];
	Geniflow[1]=Geniflow[0];
	Geniflow[0]=dataIn;
*/
}
    82a8:	67 96       	adiw	r28, 0x17	; 23
    82aa:	0f b6       	in	r0, 0x3f	; 63
    82ac:	f8 94       	cli
    82ae:	de bf       	out	0x3e, r29	; 62
    82b0:	0f be       	out	0x3f, r0	; 63
    82b2:	cd bf       	out	0x3d, r28	; 61
    82b4:	cf 91       	pop	r28
    82b6:	df 91       	pop	r29
    82b8:	1f 91       	pop	r17
    82ba:	0f 91       	pop	r16
    82bc:	ff 90       	pop	r15
    82be:	08 95       	ret

000082c0 <__vector_30>:
}

// NotSuccessful! 


ISR(USART1_RX_vect){
    82c0:	1f 92       	push	r1
    82c2:	0f 92       	push	r0
    82c4:	0f b6       	in	r0, 0x3f	; 63
    82c6:	0f 92       	push	r0
    82c8:	0b b6       	in	r0, 0x3b	; 59
    82ca:	0f 92       	push	r0
    82cc:	11 24       	eor	r1, r1
    82ce:	1f 93       	push	r17
    82d0:	2f 93       	push	r18
    82d2:	3f 93       	push	r19
    82d4:	4f 93       	push	r20
    82d6:	5f 93       	push	r21
    82d8:	6f 93       	push	r22
    82da:	7f 93       	push	r23
    82dc:	8f 93       	push	r24
    82de:	9f 93       	push	r25
    82e0:	af 93       	push	r26
    82e2:	bf 93       	push	r27
    82e4:	ef 93       	push	r30
    82e6:	ff 93       	push	r31
	char dataTX1,serialSend[12];
	static char IsAdvanZProtocol=False;
	unsigned int i;
	dataTX1 = UDR1;
    82e8:	10 91 9c 00 	lds	r17, 0x009C

	//NewPacket
	if (IsNewPacket==True){
    82ec:	80 91 8b 01 	lds	r24, 0x018B
    82f0:	81 30       	cpi	r24, 0x01	; 1
    82f2:	51 f4       	brne	.+20     	; 0x8308 <__vector_30+0x48>
	    if (dataTX1==0x01){
    82f4:	11 30       	cpi	r17, 0x01	; 1
    82f6:	41 f4       	brne	.+16     	; 0x8308 <__vector_30+0x48>
		    char_count=0;
    82f8:	10 92 8d 01 	sts	0x018D, r1
    82fc:	10 92 8c 01 	sts	0x018C, r1
            IsNewPacket=False;
    8300:	10 92 8b 01 	sts	0x018B, r1
			IsAdvanZProtocol=True;
    8304:	10 93 eb 02 	sts	0x02EB, r17
			}
	}
    //Save data to buffer if AdvanZ MSG
	if (IsAdvanZProtocol==True){
    8308:	80 91 eb 02 	lds	r24, 0x02EB
    830c:	81 30       	cpi	r24, 0x01	; 1
    830e:	69 f4       	brne	.+26     	; 0x832a <__vector_30+0x6a>
	    rcv_trans[char_count]=dataTX1;
    8310:	80 91 8c 01 	lds	r24, 0x018C
    8314:	90 91 8d 01 	lds	r25, 0x018D
    8318:	fc 01       	movw	r30, r24
    831a:	ef 5a       	subi	r30, 0xAF	; 175
    831c:	f5 4f       	sbci	r31, 0xF5	; 245
    831e:	10 83       	st	Z, r17
	    char_count++; 
    8320:	01 96       	adiw	r24, 0x01	; 1
    8322:	90 93 8d 01 	sts	0x018D, r25
    8326:	80 93 8c 01 	sts	0x018C, r24
	}

	if (dataTX1==0x02){
    832a:	12 30       	cpi	r17, 0x02	; 2
    832c:	b1 f5       	brne	.+108    	; 0x839a <__vector_30+0xda>
		transLength=char_count;
    832e:	60 91 8c 01 	lds	r22, 0x018C
    8332:	70 91 8d 01 	lds	r23, 0x018D
    8336:	70 93 8f 01 	sts	0x018F, r23
    833a:	60 93 8e 01 	sts	0x018E, r22
		char_count=0;
    833e:	10 92 8d 01 	sts	0x018D, r1
    8342:	10 92 8c 01 	sts	0x018C, r1
		IsAdvanZProtocol=False;
    8346:	10 92 eb 02 	sts	0x02EB, r1

		//MessageIdentification
        if (MsgCode!=MSG_NONE)MsgCode=MSG_NONE;
	    MsgCode=((rcv_trans[35]-'0')*10)+(rcv_trans[36]-'0');
    834a:	20 91 75 0a 	lds	r18, 0x0A75
    834e:	20 51       	subi	r18, 0x10	; 16
    8350:	80 91 74 0a 	lds	r24, 0x0A74
    8354:	3a e0       	ldi	r19, 0x0A	; 10
    8356:	83 9f       	mul	r24, r19
    8358:	c0 01       	movw	r24, r0
    835a:	11 24       	eor	r1, r1
    835c:	28 0f       	add	r18, r24
    835e:	20 93 14 01 	sts	0x0114, r18
     
	    IdentifyMessage(rcv_trans[0],transLength);
    8362:	80 91 51 0a 	lds	r24, 0x0A51
    8366:	0e 94 c2 18 	call	0x3184	; 0x3184 <IdentifyMessage>
		IsNewPacket=True;
    836a:	21 e0       	ldi	r18, 0x01	; 1
    836c:	20 93 8b 01 	sts	0x018B, r18

		if ((rcv_trans[35]=='8')&&(rcv_trans[36]=='1')){
    8370:	80 91 74 0a 	lds	r24, 0x0A74
    8374:	88 33       	cpi	r24, 0x38	; 56
    8376:	89 f4       	brne	.+34     	; 0x839a <__vector_30+0xda>
    8378:	80 91 75 0a 	lds	r24, 0x0A75
    837c:	81 33       	cpi	r24, 0x31	; 49
    837e:	69 f4       	brne	.+26     	; 0x839a <__vector_30+0xda>
		   LengthMessage81=transLength-12-44;
    8380:	80 91 8e 01 	lds	r24, 0x018E
    8384:	90 91 8f 01 	lds	r25, 0x018F
    8388:	c8 97       	sbiw	r24, 0x38	; 56
    838a:	90 93 91 01 	sts	0x0191, r25
    838e:	80 93 90 01 	sts	0x0190, r24
		   IsMessage81=True;
    8392:	20 93 a9 01 	sts	0x01A9, r18
		   IsCompleteFilling=True;
    8396:	20 93 ac 01 	sts	0x01AC, r18
		

	}//Endif(dataTX1==0x02)

	//ConfigDetection: iConf?<0D><0A>
	if (IsNewPacket!=True)ConfigProtocol(dataTX1);
    839a:	80 91 8b 01 	lds	r24, 0x018B
    839e:	81 30       	cpi	r24, 0x01	; 1
    83a0:	19 f0       	breq	.+6      	; 0x83a8 <__vector_30+0xe8>
    83a2:	81 2f       	mov	r24, r17
    83a4:	0e 94 d0 14 	call	0x29a0	; 0x29a0 <ConfigProtocol>
	//GeniusDetection: [CMD][MSG][CSUM][0x0D]
	if ((IFType==IT_STANDALONE)&&(IsNewPacket!=True))GeniusProtocol(dataTX1);		
    83a8:	80 91 00 01 	lds	r24, 0x0100
    83ac:	82 30       	cpi	r24, 0x02	; 2
    83ae:	39 f4       	brne	.+14     	; 0x83be <__vector_30+0xfe>
    83b0:	80 91 8b 01 	lds	r24, 0x018B
    83b4:	81 30       	cpi	r24, 0x01	; 1
    83b6:	19 f0       	breq	.+6      	; 0x83be <__vector_30+0xfe>
    83b8:	81 2f       	mov	r24, r17
    83ba:	0e 94 e3 40 	call	0x81c6	; 0x81c6 <GeniusProtocol>
    //_uart(0,1,dataTX1);
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}
    83be:	ff 91       	pop	r31
    83c0:	ef 91       	pop	r30
    83c2:	bf 91       	pop	r27
    83c4:	af 91       	pop	r26
    83c6:	9f 91       	pop	r25
    83c8:	8f 91       	pop	r24
    83ca:	7f 91       	pop	r23
    83cc:	6f 91       	pop	r22
    83ce:	5f 91       	pop	r21
    83d0:	4f 91       	pop	r20
    83d2:	3f 91       	pop	r19
    83d4:	2f 91       	pop	r18
    83d6:	1f 91       	pop	r17
    83d8:	0f 90       	pop	r0
    83da:	0b be       	out	0x3b, r0	; 59
    83dc:	0f 90       	pop	r0
    83de:	0f be       	out	0x3f, r0	; 63
    83e0:	0f 90       	pop	r0
    83e2:	1f 90       	pop	r1
    83e4:	18 95       	reti

000083e6 <procMessage99>:
     StrPosCopy(rcv_trans,strAmount,74,8); 
	 StrPosCopy(rcv_trans,strStatus,82,1);
     StrPosCopy(rcv_trans,strSurcharge,83,9);    
}

char procMessage99(){//<STX>[IFT IDSeq N Srce IPDest IPMsg CodeTran NoShiftDateTimeIsland IDFIP IDProduct IDDescriptionPriceVolumeAmountMOP TypeMOP NameCard IDCard HolderBalance Type Balance MeterVolume MeterAmount Current TimePrint Count Checksum ETX
    83e6:	0f 93       	push	r16
    83e8:	1f 93       	push	r17
     char Result;
	 Result=MSG99_NONE;
	 //Message99
	 if((rcv_trans[0]==0x01)&&(transLength>=378)){
    83ea:	80 91 51 0a 	lds	r24, 0x0A51
    83ee:	81 30       	cpi	r24, 0x01	; 1
    83f0:	09 f0       	breq	.+2      	; 0x83f4 <procMessage99+0xe>
    83f2:	2e c2       	rjmp	.+1116   	; 0x8850 <procMessage99+0x46a>
    83f4:	80 91 8e 01 	lds	r24, 0x018E
    83f8:	90 91 8f 01 	lds	r25, 0x018F
    83fc:	8a 57       	subi	r24, 0x7A	; 122
    83fe:	91 40       	sbci	r25, 0x01	; 1
    8400:	08 f4       	brcc	.+2      	; 0x8404 <procMessage99+0x1e>
    8402:	26 c2       	rjmp	.+1100   	; 0x8850 <procMessage99+0x46a>
    8404:	20 e0       	ldi	r18, 0x00	; 0
    8406:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8408:	f9 01       	movw	r30, r18
    840a:	e2 54       	subi	r30, 0x42	; 66
    840c:	f2 4f       	sbci	r31, 0xF2	; 242
    840e:	d9 01       	movw	r26, r18
    8410:	af 5a       	subi	r26, 0xAF	; 175
    8412:	b5 4f       	sbci	r27, 0xF5	; 245
    8414:	95 96       	adiw	r26, 0x25	; 37
    8416:	8c 91       	ld	r24, X
    8418:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    841a:	2f 5f       	subi	r18, 0xFF	; 255
    841c:	3f 4f       	sbci	r19, 0xFF	; 255
    841e:	26 30       	cpi	r18, 0x06	; 6
    8420:	31 05       	cpc	r19, r1
    8422:	91 f7       	brne	.-28     	; 0x8408 <procMessage99+0x22>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8424:	10 92 c4 0d 	sts	0x0DC4, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8428:	80 91 7c 0a 	lds	r24, 0x0A7C
    842c:	80 93 9f 0d 	sts	0x0D9F, r24
	 }Dest[Length]=0;
    8430:	10 92 a0 0d 	sts	0x0DA0, r1
	 Result=MSG99_NONE;
	 //Message99
	 if((rcv_trans[0]==0x01)&&(transLength>=378)){
       StrPosCopy(rcv_trans,strTranNo,37,6);//Transaction Number
       StrPosCopy(rcv_trans,strShift,43,1);
       Shift=(CharPosCopy(rcv_trans,43)-'0');
    8434:	80 53       	subi	r24, 0x30	; 48
    8436:	80 93 bb 01 	sts	0x01BB, r24
    843a:	20 e0       	ldi	r18, 0x00	; 0
    843c:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    843e:	f9 01       	movw	r30, r18
    8440:	e0 58       	subi	r30, 0x80	; 128
    8442:	f7 4f       	sbci	r31, 0xF7	; 247
    8444:	d9 01       	movw	r26, r18
    8446:	af 5a       	subi	r26, 0xAF	; 175
    8448:	b5 4f       	sbci	r27, 0xF5	; 245
    844a:	9c 96       	adiw	r26, 0x2c	; 44
    844c:	8c 91       	ld	r24, X
    844e:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8450:	2f 5f       	subi	r18, 0xFF	; 255
    8452:	3f 4f       	sbci	r19, 0xFF	; 255
    8454:	2a 30       	cpi	r18, 0x0A	; 10
    8456:	31 05       	cpc	r19, r1
    8458:	91 f7       	brne	.-28     	; 0x843e <procMessage99+0x58>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    845a:	10 92 8a 08 	sts	0x088A, r1
    845e:	20 e0       	ldi	r18, 0x00	; 0
    8460:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8462:	f9 01       	movw	r30, r18
    8464:	e4 5a       	subi	r30, 0xA4	; 164
    8466:	fb 4f       	sbci	r31, 0xFB	; 251
    8468:	d9 01       	movw	r26, r18
    846a:	af 5a       	subi	r26, 0xAF	; 175
    846c:	b5 4f       	sbci	r27, 0xF5	; 245
    846e:	d6 96       	adiw	r26, 0x36	; 54
    8470:	8c 91       	ld	r24, X
    8472:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8474:	2f 5f       	subi	r18, 0xFF	; 255
    8476:	3f 4f       	sbci	r19, 0xFF	; 255
    8478:	28 30       	cpi	r18, 0x08	; 8
    847a:	31 05       	cpc	r19, r1
    847c:	91 f7       	brne	.-28     	; 0x8462 <procMessage99+0x7c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    847e:	10 92 64 04 	sts	0x0464, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8482:	80 91 8f 0a 	lds	r24, 0x0A8F
    8486:	80 93 2b 0a 	sts	0x0A2B, r24
    848a:	80 91 90 0a 	lds	r24, 0x0A90
    848e:	80 93 2c 0a 	sts	0x0A2C, r24
	 }Dest[Length]=0;
    8492:	10 92 2d 0a 	sts	0x0A2D, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8496:	80 91 91 0a 	lds	r24, 0x0A91
    849a:	80 93 cb 08 	sts	0x08CB, r24
    849e:	80 91 92 0a 	lds	r24, 0x0A92
    84a2:	80 93 cc 08 	sts	0x08CC, r24
	 }Dest[Length]=0;
    84a6:	10 92 cd 08 	sts	0x08CD, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    84aa:	80 91 93 0a 	lds	r24, 0x0A93
    84ae:	80 93 a5 09 	sts	0x09A5, r24
    84b2:	80 91 94 0a 	lds	r24, 0x0A94
    84b6:	80 93 a6 09 	sts	0x09A6, r24
	 }Dest[Length]=0;
    84ba:	10 92 a7 09 	sts	0x09A7, r1
    84be:	20 e0       	ldi	r18, 0x00	; 0
    84c0:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    84c2:	f9 01       	movw	r30, r18
    84c4:	e0 5c       	subi	r30, 0xC0	; 192
    84c6:	f6 4f       	sbci	r31, 0xF6	; 246
    84c8:	d9 01       	movw	r26, r18
    84ca:	ab 56       	subi	r26, 0x6B	; 107
    84cc:	b5 4f       	sbci	r27, 0xF5	; 245
    84ce:	8c 91       	ld	r24, X
    84d0:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    84d2:	2f 5f       	subi	r18, 0xFF	; 255
    84d4:	3f 4f       	sbci	r19, 0xFF	; 255
    84d6:	2f 30       	cpi	r18, 0x0F	; 15
    84d8:	31 05       	cpc	r19, r1
    84da:	99 f7       	brne	.-26     	; 0x84c2 <procMessage99+0xdc>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    84dc:	10 92 4f 09 	sts	0x094F, r1
    84e0:	20 e0       	ldi	r18, 0x00	; 0
    84e2:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    84e4:	f9 01       	movw	r30, r18
    84e6:	e0 55       	subi	r30, 0x50	; 80
    84e8:	f9 4f       	sbci	r31, 0xF9	; 249
    84ea:	d9 01       	movw	r26, r18
    84ec:	ac 55       	subi	r26, 0x5C	; 92
    84ee:	b5 4f       	sbci	r27, 0xF5	; 245
    84f0:	8c 91       	ld	r24, X
    84f2:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    84f4:	2f 5f       	subi	r18, 0xFF	; 255
    84f6:	3f 4f       	sbci	r19, 0xFF	; 255
    84f8:	28 30       	cpi	r18, 0x08	; 8
    84fa:	31 05       	cpc	r19, r1
    84fc:	99 f7       	brne	.-26     	; 0x84e4 <procMessage99+0xfe>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    84fe:	10 92 b8 06 	sts	0x06B8, r1
    8502:	20 e0       	ldi	r18, 0x00	; 0
    8504:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8506:	f9 01       	movw	r30, r18
    8508:	ec 57       	subi	r30, 0x7C	; 124
    850a:	fb 4f       	sbci	r31, 0xFB	; 251
    850c:	d9 01       	movw	r26, r18
    850e:	a4 55       	subi	r26, 0x54	; 84
    8510:	b5 4f       	sbci	r27, 0xF5	; 245
    8512:	8c 91       	ld	r24, X
    8514:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8516:	2f 5f       	subi	r18, 0xFF	; 255
    8518:	3f 4f       	sbci	r19, 0xFF	; 255
    851a:	28 30       	cpi	r18, 0x08	; 8
    851c:	31 05       	cpc	r19, r1
    851e:	99 f7       	brne	.-26     	; 0x8506 <procMessage99+0x120>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8520:	10 92 8c 04 	sts	0x048C, r1
    8524:	20 e0       	ldi	r18, 0x00	; 0
    8526:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8528:	f9 01       	movw	r30, r18
    852a:	e9 51       	subi	r30, 0x19	; 25
    852c:	f3 4f       	sbci	r31, 0xF3	; 243
    852e:	d9 01       	movw	r26, r18
    8530:	ac 54       	subi	r26, 0x4C	; 76
    8532:	b5 4f       	sbci	r27, 0xF5	; 245
    8534:	8c 91       	ld	r24, X
    8536:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8538:	2f 5f       	subi	r18, 0xFF	; 255
    853a:	3f 4f       	sbci	r19, 0xFF	; 255
    853c:	2a 30       	cpi	r18, 0x0A	; 10
    853e:	31 05       	cpc	r19, r1
    8540:	99 f7       	brne	.-26     	; 0x8528 <procMessage99+0x142>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8542:	10 92 f1 0c 	sts	0x0CF1, r1

	   //FillChar(strAmount,sizeof(strAmount),0);
       StrPosCopy(rcv_trans,strAmount,99,10);

       //StrPosCopy(rcv_trans,strMOPType,109,1);
       MOPType=(CharPosCopy(rcv_trans,109)-'0');
    8546:	80 91 be 0a 	lds	r24, 0x0ABE
    854a:	80 53       	subi	r24, 0x30	; 48
    854c:	80 93 ba 01 	sts	0x01BA, r24
    8550:	20 e0       	ldi	r18, 0x00	; 0
    8552:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8554:	f9 01       	movw	r30, r18
    8556:	e1 57       	subi	r30, 0x71	; 113
    8558:	f9 4f       	sbci	r31, 0xF9	; 249
    855a:	d9 01       	movw	r26, r18
    855c:	a1 54       	subi	r26, 0x41	; 65
    855e:	b5 4f       	sbci	r27, 0xF5	; 245
    8560:	8c 91       	ld	r24, X
    8562:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8564:	2f 5f       	subi	r18, 0xFF	; 255
    8566:	3f 4f       	sbci	r19, 0xFF	; 255
    8568:	24 31       	cpi	r18, 0x14	; 20
    856a:	31 05       	cpc	r19, r1
    856c:	99 f7       	brne	.-26     	; 0x8554 <procMessage99+0x16e>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    856e:	10 92 a3 06 	sts	0x06A3, r1
    8572:	20 e0       	ldi	r18, 0x00	; 0
    8574:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8576:	f9 01       	movw	r30, r18
    8578:	e3 54       	subi	r30, 0x43	; 67
    857a:	f3 4f       	sbci	r31, 0xF3	; 243
    857c:	d9 01       	movw	r26, r18
    857e:	ad 52       	subi	r26, 0x2D	; 45
    8580:	b5 4f       	sbci	r27, 0xF5	; 245
    8582:	8c 91       	ld	r24, X
    8584:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8586:	2f 5f       	subi	r18, 0xFF	; 255
    8588:	3f 4f       	sbci	r19, 0xFF	; 255
    858a:	24 31       	cpi	r18, 0x14	; 20
    858c:	31 05       	cpc	r19, r1
    858e:	99 f7       	brne	.-26     	; 0x8576 <procMessage99+0x190>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8590:	10 92 d1 0c 	sts	0x0CD1, r1
    8594:	20 e0       	ldi	r18, 0x00	; 0
    8596:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8598:	f9 01       	movw	r30, r18
    859a:	ed 5c       	subi	r30, 0xCD	; 205
    859c:	fb 4f       	sbci	r31, 0xFB	; 251
    859e:	d9 01       	movw	r26, r18
    85a0:	a9 51       	subi	r26, 0x19	; 25
    85a2:	b5 4f       	sbci	r27, 0xF5	; 245
    85a4:	8c 91       	ld	r24, X
    85a6:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    85a8:	2f 5f       	subi	r18, 0xFF	; 255
    85aa:	3f 4f       	sbci	r19, 0xFF	; 255
    85ac:	28 32       	cpi	r18, 0x28	; 40
    85ae:	31 05       	cpc	r19, r1
    85b0:	99 f7       	brne	.-26     	; 0x8598 <procMessage99+0x1b2>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    85b2:	10 92 5b 04 	sts	0x045B, r1
    85b6:	20 e0       	ldi	r18, 0x00	; 0
    85b8:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    85ba:	f9 01       	movw	r30, r18
    85bc:	e6 59       	subi	r30, 0x96	; 150
    85be:	fb 4f       	sbci	r31, 0xFB	; 251
    85c0:	d9 01       	movw	r26, r18
    85c2:	a1 5f       	subi	r26, 0xF1	; 241
    85c4:	b4 4f       	sbci	r27, 0xF4	; 244
    85c6:	8c 91       	ld	r24, X
    85c8:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    85ca:	2f 5f       	subi	r18, 0xFF	; 255
    85cc:	3f 4f       	sbci	r19, 0xFF	; 255
    85ce:	29 31       	cpi	r18, 0x19	; 25
    85d0:	31 05       	cpc	r19, r1
    85d2:	99 f7       	brne	.-26     	; 0x85ba <procMessage99+0x1d4>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    85d4:	10 92 83 04 	sts	0x0483, r1
    85d8:	20 e0       	ldi	r18, 0x00	; 0
    85da:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    85dc:	f9 01       	movw	r30, r18
    85de:	e1 5d       	subi	r30, 0xD1	; 209
    85e0:	f2 4f       	sbci	r31, 0xF2	; 242
    85e2:	d9 01       	movw	r26, r18
    85e4:	a8 5d       	subi	r26, 0xD8	; 216
    85e6:	b4 4f       	sbci	r27, 0xF4	; 244
    85e8:	8c 91       	ld	r24, X
    85ea:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    85ec:	2f 5f       	subi	r18, 0xFF	; 255
    85ee:	3f 4f       	sbci	r19, 0xFF	; 255
    85f0:	2d 30       	cpi	r18, 0x0D	; 13
    85f2:	31 05       	cpc	r19, r1
    85f4:	99 f7       	brne	.-26     	; 0x85dc <procMessage99+0x1f6>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    85f6:	10 92 3c 0d 	sts	0x0D3C, r1
    85fa:	20 e0       	ldi	r18, 0x00	; 0
    85fc:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    85fe:	f9 01       	movw	r30, r18
    8600:	e5 56       	subi	r30, 0x65	; 101
    8602:	fb 4f       	sbci	r31, 0xFB	; 251
    8604:	d9 01       	movw	r26, r18
    8606:	ab 5c       	subi	r26, 0xCB	; 203
    8608:	b4 4f       	sbci	r27, 0xF4	; 244
    860a:	8c 91       	ld	r24, X
    860c:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    860e:	2f 5f       	subi	r18, 0xFF	; 255
    8610:	3f 4f       	sbci	r19, 0xFF	; 255
    8612:	2d 30       	cpi	r18, 0x0D	; 13
    8614:	31 05       	cpc	r19, r1
    8616:	99 f7       	brne	.-26     	; 0x85fe <procMessage99+0x218>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8618:	10 92 a8 04 	sts	0x04A8, r1
    861c:	20 e0       	ldi	r18, 0x00	; 0
    861e:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8620:	f9 01       	movw	r30, r18
    8622:	e3 5e       	subi	r30, 0xE3	; 227
    8624:	f5 4f       	sbci	r31, 0xF5	; 245
    8626:	d9 01       	movw	r26, r18
    8628:	ae 5b       	subi	r26, 0xBE	; 190
    862a:	b4 4f       	sbci	r27, 0xF4	; 244
    862c:	8c 91       	ld	r24, X
    862e:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8630:	2f 5f       	subi	r18, 0xFF	; 255
    8632:	3f 4f       	sbci	r19, 0xFF	; 255
    8634:	2d 30       	cpi	r18, 0x0D	; 13
    8636:	31 05       	cpc	r19, r1
    8638:	99 f7       	brne	.-26     	; 0x8620 <procMessage99+0x23a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    863a:	10 92 2a 0a 	sts	0x0A2A, r1
    863e:	20 e0       	ldi	r18, 0x00	; 0
    8640:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8642:	f9 01       	movw	r30, r18
    8644:	e2 53       	subi	r30, 0x32	; 50
    8646:	f7 4f       	sbci	r31, 0xF7	; 247
    8648:	d9 01       	movw	r26, r18
    864a:	a1 5b       	subi	r26, 0xB1	; 177
    864c:	b4 4f       	sbci	r27, 0xF4	; 244
    864e:	8c 91       	ld	r24, X
    8650:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8652:	2f 5f       	subi	r18, 0xFF	; 255
    8654:	3f 4f       	sbci	r19, 0xFF	; 255
    8656:	23 31       	cpi	r18, 0x13	; 19
    8658:	31 05       	cpc	r19, r1
    865a:	99 f7       	brne	.-26     	; 0x8642 <procMessage99+0x25c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    865c:	10 92 e1 08 	sts	0x08E1, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8660:	80 91 62 0b 	lds	r24, 0x0B62
    8664:	80 93 bb 0d 	sts	0x0DBB, r24
    8668:	80 91 63 0b 	lds	r24, 0x0B63
    866c:	80 93 bc 0d 	sts	0x0DBC, r24
	 }Dest[Length]=0;
    8670:	10 92 bd 0d 	sts	0x0DBD, r1
    8674:	20 e0       	ldi	r18, 0x00	; 0
    8676:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8678:	f9 01       	movw	r30, r18
    867a:	e8 5b       	subi	r30, 0xB8	; 184
    867c:	f5 4f       	sbci	r31, 0xF5	; 245
    867e:	d9 01       	movw	r26, r18
    8680:	ac 59       	subi	r26, 0x9C	; 156
    8682:	b4 4f       	sbci	r27, 0xF4	; 244
    8684:	8c 91       	ld	r24, X
    8686:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8688:	2f 5f       	subi	r18, 0xFF	; 255
    868a:	3f 4f       	sbci	r19, 0xFF	; 255
    868c:	28 30       	cpi	r18, 0x08	; 8
    868e:	31 05       	cpc	r19, r1
    8690:	99 f7       	brne	.-26     	; 0x8678 <procMessage99+0x292>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8692:	10 92 50 0a 	sts	0x0A50, r1
    8696:	20 e0       	ldi	r18, 0x00	; 0
    8698:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    869a:	f9 01       	movw	r30, r18
    869c:	e6 53       	subi	r30, 0x36	; 54
    869e:	fc 4f       	sbci	r31, 0xFC	; 252
    86a0:	d9 01       	movw	r26, r18
    86a2:	a4 59       	subi	r26, 0x94	; 148
    86a4:	b4 4f       	sbci	r27, 0xF4	; 244
    86a6:	8c 91       	ld	r24, X
    86a8:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    86aa:	2f 5f       	subi	r18, 0xFF	; 255
    86ac:	3f 4f       	sbci	r19, 0xFF	; 255
    86ae:	28 30       	cpi	r18, 0x08	; 8
    86b0:	31 05       	cpc	r19, r1
    86b2:	99 f7       	brne	.-26     	; 0x869a <procMessage99+0x2b4>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    86b4:	10 92 d2 03 	sts	0x03D2, r1
    86b8:	20 e0       	ldi	r18, 0x00	; 0
    86ba:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    86bc:	f9 01       	movw	r30, r18
    86be:	ea 50       	subi	r30, 0x0A	; 10
    86c0:	fc 4f       	sbci	r31, 0xFC	; 252
    86c2:	d9 01       	movw	r26, r18
    86c4:	ac 58       	subi	r26, 0x8C	; 140
    86c6:	b4 4f       	sbci	r27, 0xF4	; 244
    86c8:	8c 91       	ld	r24, X
    86ca:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    86cc:	2f 5f       	subi	r18, 0xFF	; 255
    86ce:	3f 4f       	sbci	r19, 0xFF	; 255
    86d0:	24 31       	cpi	r18, 0x14	; 20
    86d2:	31 05       	cpc	r19, r1
    86d4:	99 f7       	brne	.-26     	; 0x86bc <procMessage99+0x2d6>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    86d6:	10 92 0a 04 	sts	0x040A, r1
    86da:	20 e0       	ldi	r18, 0x00	; 0
    86dc:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    86de:	f9 01       	movw	r30, r18
    86e0:	ed 52       	subi	r30, 0x2D	; 45
    86e2:	fc 4f       	sbci	r31, 0xFC	; 252
    86e4:	d9 01       	movw	r26, r18
    86e6:	a8 57       	subi	r26, 0x78	; 120
    86e8:	b4 4f       	sbci	r27, 0xF4	; 244
    86ea:	8c 91       	ld	r24, X
    86ec:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    86ee:	2f 5f       	subi	r18, 0xFF	; 255
    86f0:	3f 4f       	sbci	r19, 0xFF	; 255
    86f2:	2e 31       	cpi	r18, 0x1E	; 30
    86f4:	31 05       	cpc	r19, r1
    86f6:	99 f7       	brne	.-26     	; 0x86de <procMessage99+0x2f8>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    86f8:	10 92 f1 03 	sts	0x03F1, r1
    86fc:	20 e0       	ldi	r18, 0x00	; 0
    86fe:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8700:	f9 01       	movw	r30, r18
    8702:	e7 59       	subi	r30, 0x97	; 151
    8704:	f6 4f       	sbci	r31, 0xF6	; 246
    8706:	d9 01       	movw	r26, r18
    8708:	aa 55       	subi	r26, 0x5A	; 90
    870a:	b4 4f       	sbci	r27, 0xF4	; 244
    870c:	8c 91       	ld	r24, X
    870e:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8710:	2f 5f       	subi	r18, 0xFF	; 255
    8712:	3f 4f       	sbci	r19, 0xFF	; 255
    8714:	28 30       	cpi	r18, 0x08	; 8
    8716:	31 05       	cpc	r19, r1
    8718:	99 f7       	brne	.-26     	; 0x8700 <procMessage99+0x31a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    871a:	10 92 71 09 	sts	0x0971, r1
    871e:	20 e0       	ldi	r18, 0x00	; 0
    8720:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8722:	f9 01       	movw	r30, r18
    8724:	e3 57       	subi	r30, 0x73	; 115
    8726:	fb 4f       	sbci	r31, 0xFB	; 251
    8728:	d9 01       	movw	r26, r18
    872a:	a2 55       	subi	r26, 0x52	; 82
    872c:	b4 4f       	sbci	r27, 0xF4	; 244
    872e:	8c 91       	ld	r24, X
    8730:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8732:	2f 5f       	subi	r18, 0xFF	; 255
    8734:	3f 4f       	sbci	r19, 0xFF	; 255
    8736:	2a 30       	cpi	r18, 0x0A	; 10
    8738:	31 05       	cpc	r19, r1
    873a:	99 f7       	brne	.-26     	; 0x8722 <procMessage99+0x33c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    873c:	10 92 97 04 	sts	0x0497, r1
    8740:	20 e0       	ldi	r18, 0x00	; 0
    8742:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8744:	f9 01       	movw	r30, r18
    8746:	ec 5d       	subi	r30, 0xDC	; 220
    8748:	f2 4f       	sbci	r31, 0xF2	; 242
    874a:	d9 01       	movw	r26, r18
    874c:	a8 54       	subi	r26, 0x48	; 72
    874e:	b4 4f       	sbci	r27, 0xF4	; 244
    8750:	8c 91       	ld	r24, X
    8752:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8754:	2f 5f       	subi	r18, 0xFF	; 255
    8756:	3f 4f       	sbci	r19, 0xFF	; 255
    8758:	2a 30       	cpi	r18, 0x0A	; 10
    875a:	31 05       	cpc	r19, r1
    875c:	99 f7       	brne	.-26     	; 0x8744 <procMessage99+0x35e>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    875e:	10 92 2e 0d 	sts	0x0D2E, r1
    8762:	20 e0       	ldi	r18, 0x00	; 0
    8764:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8766:	f9 01       	movw	r30, r18
    8768:	e2 50       	subi	r30, 0x02	; 2
    876a:	f7 4f       	sbci	r31, 0xF7	; 247
    876c:	d9 01       	movw	r26, r18
    876e:	ae 53       	subi	r26, 0x3E	; 62
    8770:	b4 4f       	sbci	r27, 0xF4	; 244
    8772:	8c 91       	ld	r24, X
    8774:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8776:	2f 5f       	subi	r18, 0xFF	; 255
    8778:	3f 4f       	sbci	r19, 0xFF	; 255
    877a:	24 31       	cpi	r18, 0x14	; 20
    877c:	31 05       	cpc	r19, r1
    877e:	99 f7       	brne	.-26     	; 0x8766 <procMessage99+0x380>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8780:	10 92 12 09 	sts	0x0912, r1
    8784:	20 e0       	ldi	r18, 0x00	; 0
    8786:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8788:	f9 01       	movw	r30, r18
    878a:	ea 57       	subi	r30, 0x7A	; 122
    878c:	f6 4f       	sbci	r31, 0xF6	; 246
    878e:	d9 01       	movw	r26, r18
    8790:	aa 52       	subi	r26, 0x2A	; 42
    8792:	b4 4f       	sbci	r27, 0xF4	; 244
    8794:	8c 91       	ld	r24, X
    8796:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8798:	2f 5f       	subi	r18, 0xFF	; 255
    879a:	3f 4f       	sbci	r19, 0xFF	; 255
    879c:	2a 30       	cpi	r18, 0x0A	; 10
    879e:	31 05       	cpc	r19, r1
    87a0:	99 f7       	brne	.-26     	; 0x8788 <procMessage99+0x3a2>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    87a2:	10 92 90 09 	sts	0x0990, r1
    87a6:	20 e0       	ldi	r18, 0x00	; 0
    87a8:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    87aa:	f9 01       	movw	r30, r18
    87ac:	e7 55       	subi	r30, 0x57	; 87
    87ae:	fb 4f       	sbci	r31, 0xFB	; 251
    87b0:	d9 01       	movw	r26, r18
    87b2:	a0 52       	subi	r26, 0x20	; 32
    87b4:	b4 4f       	sbci	r27, 0xF4	; 244
    87b6:	8c 91       	ld	r24, X
    87b8:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    87ba:	2f 5f       	subi	r18, 0xFF	; 255
    87bc:	3f 4f       	sbci	r19, 0xFF	; 255
    87be:	28 30       	cpi	r18, 0x08	; 8
    87c0:	31 05       	cpc	r19, r1
    87c2:	99 f7       	brne	.-26     	; 0x87aa <procMessage99+0x3c4>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    87c4:	10 92 b1 04 	sts	0x04B1, r1
    87c8:	20 e0       	ldi	r18, 0x00	; 0
    87ca:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    87cc:	f9 01       	movw	r30, r18
    87ce:	e0 55       	subi	r30, 0x50	; 80
    87d0:	f2 4f       	sbci	r31, 0xF2	; 242
    87d2:	d9 01       	movw	r26, r18
    87d4:	a8 51       	subi	r26, 0x18	; 24
    87d6:	b4 4f       	sbci	r27, 0xF4	; 244
    87d8:	8c 91       	ld	r24, X
    87da:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    87dc:	2f 5f       	subi	r18, 0xFF	; 255
    87de:	3f 4f       	sbci	r19, 0xFF	; 255
    87e0:	2a 30       	cpi	r18, 0x0A	; 10
    87e2:	31 05       	cpc	r19, r1
    87e4:	99 f7       	brne	.-26     	; 0x87cc <procMessage99+0x3e6>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    87e6:	10 92 ba 0d 	sts	0x0DBA, r1
    87ea:	20 e0       	ldi	r18, 0x00	; 0
    87ec:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    87ee:	f9 01       	movw	r30, r18
    87f0:	ef 5b       	subi	r30, 0xBF	; 191
    87f2:	f2 4f       	sbci	r31, 0xF2	; 242
    87f4:	d9 01       	movw	r26, r18
    87f6:	ae 50       	subi	r26, 0x0E	; 14
    87f8:	b4 4f       	sbci	r27, 0xF4	; 244
    87fa:	8c 91       	ld	r24, X
    87fc:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    87fe:	2f 5f       	subi	r18, 0xFF	; 255
    8800:	3f 4f       	sbci	r19, 0xFF	; 255
    8802:	24 31       	cpi	r18, 0x14	; 20
    8804:	31 05       	cpc	r19, r1
    8806:	99 f7       	brne	.-26     	; 0x87ee <procMessage99+0x408>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8808:	10 92 55 0d 	sts	0x0D55, r1
    880c:	20 e0       	ldi	r18, 0x00	; 0
    880e:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8810:	f9 01       	movw	r30, r18
    8812:	e4 52       	subi	r30, 0x24	; 36
    8814:	fb 4f       	sbci	r31, 0xFB	; 251
    8816:	d9 01       	movw	r26, r18
    8818:	aa 5f       	subi	r26, 0xFA	; 250
    881a:	b3 4f       	sbci	r27, 0xF3	; 243
    881c:	8c 91       	ld	r24, X
    881e:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8820:	2f 5f       	subi	r18, 0xFF	; 255
    8822:	3f 4f       	sbci	r19, 0xFF	; 255
    8824:	2e 31       	cpi	r18, 0x1E	; 30
    8826:	31 05       	cpc	r19, r1
    8828:	99 f7       	brne	.-26     	; 0x8810 <procMessage99+0x42a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    882a:	10 92 fa 04 	sts	0x04FA, r1
       StrPosCopy(rcv_trans,strCorporateName,437,30);
	   //


	   //FIP Detection LocalAccount Null Filling
	   if ((nLocalAccount>0)&&(LocalAccountFIP[0]==atoi(strFIP_ID))){
    882e:	80 91 92 01 	lds	r24, 0x0192
    8832:	88 23       	and	r24, r24
    8834:	69 f0       	breq	.+26     	; 0x8850 <procMessage99+0x46a>
    8836:	00 91 65 04 	lds	r16, 0x0465
    883a:	10 e0       	ldi	r17, 0x00	; 0
    883c:	8b ec       	ldi	r24, 0xCB	; 203
    883e:	98 e0       	ldi	r25, 0x08	; 8
    8840:	0e 94 c3 b3 	call	0x16786	; 0x16786 <atoi>
    8844:	08 17       	cp	r16, r24
    8846:	19 07       	cpc	r17, r25
    8848:	19 f4       	brne	.+6      	; 0x8850 <procMessage99+0x46a>
	        IsCompleteFilling=True;
    884a:	81 e0       	ldi	r24, 0x01	; 1
    884c:	80 93 ac 01 	sts	0x01AC, r24
	   }

	  }
     return Result;     
}
    8850:	80 e0       	ldi	r24, 0x00	; 0
    8852:	1f 91       	pop	r17
    8854:	0f 91       	pop	r16
    8856:	08 95       	ret

00008858 <GetMessageID>:
		  }
       IsStandaloneAcknoledge=True;
	  }
}

char GetMessageID(char *strMessageFlow){
    8858:	0f 93       	push	r16
    885a:	1f 93       	push	r17
    885c:	df 93       	push	r29
    885e:	cf 93       	push	r28
    8860:	00 d0       	rcall	.+0      	; 0x8862 <GetMessageID+0xa>
    8862:	0f 92       	push	r0
    8864:	cd b7       	in	r28, 0x3d	; 61
    8866:	de b7       	in	r29, 0x3e	; 62
    8868:	fc 01       	movw	r30, r24
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    886a:	80 81       	ld	r24, Z
    886c:	89 83       	std	Y+1, r24	; 0x01
    886e:	81 81       	ldd	r24, Z+1	; 0x01
    8870:	8a 83       	std	Y+2, r24	; 0x02
	 }Dest[Length]=0;
    8872:	1b 82       	std	Y+3, r1	; 0x03
}

char GetMessageID(char *strMessageFlow){
     char Result,strMsgID[3];
	 StrPosCopy(strMessageFlow,strMsgID,0,2);
	 RemZeroLead(strMsgID);
    8874:	8e 01       	movw	r16, r28
    8876:	0f 5f       	subi	r16, 0xFF	; 255
    8878:	1f 4f       	sbci	r17, 0xFF	; 255
    887a:	c8 01       	movw	r24, r16
    887c:	0e 94 19 25 	call	0x4a32	; 0x4a32 <RemZeroLead>
	 Result=atoi(strMsgID);
    8880:	c8 01       	movw	r24, r16
    8882:	0e 94 c3 b3 	call	0x16786	; 0x16786 <atoi>
  return Result;
}
    8886:	0f 90       	pop	r0
    8888:	0f 90       	pop	r0
    888a:	0f 90       	pop	r0
    888c:	cf 91       	pop	r28
    888e:	df 91       	pop	r29
    8890:	1f 91       	pop	r17
    8892:	0f 91       	pop	r16
    8894:	08 95       	ret

00008896 <FTestChar>:
		TimTicker++;
	}

}

char FTestChar(){
    8896:	0f 93       	push	r16
    8898:	1f 93       	push	r17
    889a:	df 93       	push	r29
    889c:	cf 93       	push	r28
    889e:	cd b7       	in	r28, 0x3d	; 61
    88a0:	de b7       	in	r29, 0x3e	; 62
    88a2:	64 97       	sbiw	r28, 0x14	; 20
    88a4:	0f b6       	in	r0, 0x3f	; 63
    88a6:	f8 94       	cli
    88a8:	de bf       	out	0x3e, r29	; 62
    88aa:	0f be       	out	0x3f, r0	; 63
    88ac:	cd bf       	out	0x3d, r28	; 61
char lcdteks[20],Result;
char i=0;
     Result=MENU_NONE;
     sprintf_P(lcdteks,PSTR("D:%d C:%c  "),i,i);
    88ae:	8d b7       	in	r24, 0x3d	; 61
    88b0:	9e b7       	in	r25, 0x3e	; 62
    88b2:	08 97       	sbiw	r24, 0x08	; 8
    88b4:	0f b6       	in	r0, 0x3f	; 63
    88b6:	f8 94       	cli
    88b8:	9e bf       	out	0x3e, r25	; 62
    88ba:	0f be       	out	0x3f, r0	; 63
    88bc:	8d bf       	out	0x3d, r24	; 61
    88be:	ed b7       	in	r30, 0x3d	; 61
    88c0:	fe b7       	in	r31, 0x3e	; 62
    88c2:	31 96       	adiw	r30, 0x01	; 1
    88c4:	8e 01       	movw	r16, r28
    88c6:	0f 5f       	subi	r16, 0xFF	; 255
    88c8:	1f 4f       	sbci	r17, 0xFF	; 255
    88ca:	ad b7       	in	r26, 0x3d	; 61
    88cc:	be b7       	in	r27, 0x3e	; 62
    88ce:	12 96       	adiw	r26, 0x02	; 2
    88d0:	1c 93       	st	X, r17
    88d2:	0e 93       	st	-X, r16
    88d4:	11 97       	sbiw	r26, 0x01	; 1
    88d6:	89 e4       	ldi	r24, 0x49	; 73
    88d8:	9c e1       	ldi	r25, 0x1C	; 28
    88da:	93 83       	std	Z+3, r25	; 0x03
    88dc:	82 83       	std	Z+2, r24	; 0x02
    88de:	15 82       	std	Z+5, r1	; 0x05
    88e0:	14 82       	std	Z+4, r1	; 0x04
    88e2:	17 82       	std	Z+7, r1	; 0x07
    88e4:	16 82       	std	Z+6, r1	; 0x06
    88e6:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
     lcd_print(1,1,lcdteks);
    88ea:	8d b7       	in	r24, 0x3d	; 61
    88ec:	9e b7       	in	r25, 0x3e	; 62
    88ee:	08 96       	adiw	r24, 0x08	; 8
    88f0:	0f b6       	in	r0, 0x3f	; 63
    88f2:	f8 94       	cli
    88f4:	9e bf       	out	0x3e, r25	; 62
    88f6:	0f be       	out	0x3f, r0	; 63
    88f8:	8d bf       	out	0x3d, r24	; 61
    88fa:	81 e0       	ldi	r24, 0x01	; 1
    88fc:	61 e0       	ldi	r22, 0x01	; 1
    88fe:	a8 01       	movw	r20, r16
    8900:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
    8904:	88 ee       	ldi	r24, 0xE8	; 232
    8906:	9d ef       	ldi	r25, 0xFD	; 253
    8908:	29 e1       	ldi	r18, 0x19	; 25
    890a:	30 e0       	ldi	r19, 0x00	; 0
    890c:	f9 01       	movw	r30, r18
    890e:	31 97       	sbiw	r30, 0x01	; 1
    8910:	f1 f7       	brne	.-4      	; 0x890e <FTestChar+0x78>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    8912:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    8914:	d9 f7       	brne	.-10     	; 0x890c <FTestChar+0x76>
	 if (i==0xFF)Result=MENU_DONE;
	 i++;
     _delay_ms(6500);
  return Result;
}
    8916:	80 e0       	ldi	r24, 0x00	; 0
    8918:	64 96       	adiw	r28, 0x14	; 20
    891a:	0f b6       	in	r0, 0x3f	; 63
    891c:	f8 94       	cli
    891e:	de bf       	out	0x3e, r29	; 62
    8920:	0f be       	out	0x3f, r0	; 63
    8922:	cd bf       	out	0x3d, r28	; 61
    8924:	cf 91       	pop	r28
    8926:	df 91       	pop	r29
    8928:	1f 91       	pop	r17
    892a:	0f 91       	pop	r16
    892c:	08 95       	ret

0000892e <DisplayPumpStatus>:
		  break;         	 
	 }
  return Result;	 
}

void DisplayPumpStatus(){
    892e:	0f 93       	push	r16
    8930:	1f 93       	push	r17
    8932:	df 93       	push	r29
    8934:	cf 93       	push	r28
    8936:	cd b7       	in	r28, 0x3d	; 61
    8938:	de b7       	in	r29, 0x3e	; 62
    893a:	a8 97       	sbiw	r28, 0x28	; 40
    893c:	0f b6       	in	r0, 0x3f	; 63
    893e:	f8 94       	cli
    8940:	de bf       	out	0x3e, r29	; 62
    8942:	0f be       	out	0x3f, r0	; 63
    8944:	cd bf       	out	0x3d, r28	; 61
     char SPump[20],lcdteks[20];

	 if (IsNewPumpStatus==True){
    8946:	80 91 01 01 	lds	r24, 0x0101
    894a:	81 30       	cpi	r24, 0x01	; 1
    894c:	09 f0       	breq	.+2      	; 0x8950 <DisplayPumpStatus+0x22>
    894e:	4a c0       	rjmp	.+148    	; 0x89e4 <DisplayPumpStatus+0xb6>
	     IsNewPumpStatus=False;
    8950:	10 92 01 01 	sts	0x0101, r1
	      }
     }      
}

void BackLightTrig(){    
     __key_light = 1; 
    8954:	80 93 02 03 	sts	0x0302, r24
	 __key_lgtcnt = 0; 
    8958:	10 92 03 03 	sts	0x0303, r1
	 PORTG=PORTG&0b11111101;
    895c:	80 91 65 00 	lds	r24, 0x0065
    8960:	8d 7f       	andi	r24, 0xFD	; 253
    8962:	80 93 65 00 	sts	0x0065, r24
     char SPump[20],lcdteks[20];

	 if (IsNewPumpStatus==True){
	     IsNewPumpStatus=False;
		 BackLightTrig();
		 StrPosCopy(strPumpStatus,SPump,0,PumpCountMax);
    8966:	80 91 4f 01 	lds	r24, 0x014F
    896a:	48 2f       	mov	r20, r24
    896c:	50 e0       	ldi	r21, 0x00	; 0
    896e:	20 e0       	ldi	r18, 0x00	; 0
    8970:	30 e0       	ldi	r19, 0x00	; 0
    8972:	be 01       	movw	r22, r28
    8974:	6f 5f       	subi	r22, 0xFF	; 255
    8976:	7f 4f       	sbci	r23, 0xFF	; 255
    8978:	0a c0       	rjmp	.+20     	; 0x898e <DisplayPumpStatus+0x60>
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    897a:	fb 01       	movw	r30, r22
    897c:	e2 0f       	add	r30, r18
    897e:	f3 1f       	adc	r31, r19
    8980:	d9 01       	movw	r26, r18
    8982:	ae 5f       	subi	r26, 0xFE	; 254
    8984:	be 4f       	sbci	r27, 0xFE	; 254
    8986:	8c 91       	ld	r24, X
    8988:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    898a:	2f 5f       	subi	r18, 0xFF	; 255
    898c:	3f 4f       	sbci	r19, 0xFF	; 255
    898e:	24 17       	cp	r18, r20
    8990:	35 07       	cpc	r19, r21
    8992:	98 f3       	brcs	.-26     	; 0x897a <DisplayPumpStatus+0x4c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8994:	46 0f       	add	r20, r22
    8996:	57 1f       	adc	r21, r23
    8998:	da 01       	movw	r26, r20
    899a:	1c 92       	st	X, r1

	 if (IsNewPumpStatus==True){
	     IsNewPumpStatus=False;
		 BackLightTrig();
		 StrPosCopy(strPumpStatus,SPump,0,PumpCountMax);
		 sprintf_P(lcdteks,PSTR("%s"),SPump);
    899c:	00 d0       	rcall	.+0      	; 0x899e <DisplayPumpStatus+0x70>
    899e:	00 d0       	rcall	.+0      	; 0x89a0 <DisplayPumpStatus+0x72>
    89a0:	00 d0       	rcall	.+0      	; 0x89a2 <DisplayPumpStatus+0x74>
    89a2:	ed b7       	in	r30, 0x3d	; 61
    89a4:	fe b7       	in	r31, 0x3e	; 62
    89a6:	31 96       	adiw	r30, 0x01	; 1
    89a8:	8e 01       	movw	r16, r28
    89aa:	0b 5e       	subi	r16, 0xEB	; 235
    89ac:	1f 4f       	sbci	r17, 0xFF	; 255
    89ae:	ad b7       	in	r26, 0x3d	; 61
    89b0:	be b7       	in	r27, 0x3e	; 62
    89b2:	12 96       	adiw	r26, 0x02	; 2
    89b4:	1c 93       	st	X, r17
    89b6:	0e 93       	st	-X, r16
    89b8:	11 97       	sbiw	r26, 0x01	; 1
    89ba:	89 ea       	ldi	r24, 0xA9	; 169
    89bc:	92 e2       	ldi	r25, 0x22	; 34
    89be:	93 83       	std	Z+3, r25	; 0x03
    89c0:	82 83       	std	Z+2, r24	; 0x02
    89c2:	75 83       	std	Z+5, r23	; 0x05
    89c4:	64 83       	std	Z+4, r22	; 0x04
    89c6:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
         lcd_print(4,1,lcdteks);
    89ca:	ed b7       	in	r30, 0x3d	; 61
    89cc:	fe b7       	in	r31, 0x3e	; 62
    89ce:	36 96       	adiw	r30, 0x06	; 6
    89d0:	0f b6       	in	r0, 0x3f	; 63
    89d2:	f8 94       	cli
    89d4:	fe bf       	out	0x3e, r31	; 62
    89d6:	0f be       	out	0x3f, r0	; 63
    89d8:	ed bf       	out	0x3d, r30	; 61
    89da:	84 e0       	ldi	r24, 0x04	; 4
    89dc:	61 e0       	ldi	r22, 0x01	; 1
    89de:	a8 01       	movw	r20, r16
    89e0:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
     	 }
}
    89e4:	a8 96       	adiw	r28, 0x28	; 40
    89e6:	0f b6       	in	r0, 0x3f	; 63
    89e8:	f8 94       	cli
    89ea:	de bf       	out	0x3e, r29	; 62
    89ec:	0f be       	out	0x3f, r0	; 63
    89ee:	cd bf       	out	0x3d, r28	; 61
    89f0:	cf 91       	pop	r28
    89f2:	df 91       	pop	r29
    89f4:	1f 91       	pop	r17
    89f6:	0f 91       	pop	r16
    89f8:	08 95       	ret

000089fa <FViewFreeMessage>:
char FViewFreeMessage(){
static char stFreeMessage=fmInit;
       char Result=MENU_NONE;
     
	 Result=MENU_NONE;
	 switch(stFreeMessage){
    89fa:	80 91 c0 02 	lds	r24, 0x02C0
    89fe:	81 30       	cpi	r24, 0x01	; 1
    8a00:	49 f0       	breq	.+18     	; 0x8a14 <FViewFreeMessage+0x1a>
    8a02:	81 30       	cpi	r24, 0x01	; 1
    8a04:	28 f0       	brcs	.+10     	; 0x8a10 <FViewFreeMessage+0x16>
    8a06:	82 30       	cpi	r24, 0x02	; 2
    8a08:	19 f1       	breq	.+70     	; 0x8a50 <FViewFreeMessage+0x56>
    8a0a:	83 30       	cpi	r24, 0x03	; 3
    8a0c:	71 f5       	brne	.+92     	; 0x8a6a <FViewFreeMessage+0x70>
    8a0e:	29 c0       	rjmp	.+82     	; 0x8a62 <FViewFreeMessage+0x68>
	 case fmInit:
	      stFreeMessage=fmDisplayFreeMessage;
    8a10:	81 e0       	ldi	r24, 0x01	; 1
    8a12:	23 c0       	rjmp	.+70     	; 0x8a5a <FViewFreeMessage+0x60>
	      break;
     case fmDisplayFreeMessage:
		  lcd_clear();
    8a14:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
		  lcd_print(1,1,strFreeMessageLine1);
    8a18:	81 e0       	ldi	r24, 0x01	; 1
    8a1a:	61 e0       	ldi	r22, 0x01	; 1
    8a1c:	46 ec       	ldi	r20, 0xC6	; 198
    8a1e:	59 e0       	ldi	r21, 0x09	; 9
    8a20:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
		  lcd_print(2,1,strFreeMessageLine2);
    8a24:	82 e0       	ldi	r24, 0x02	; 2
    8a26:	61 e0       	ldi	r22, 0x01	; 1
    8a28:	45 eb       	ldi	r20, 0xB5	; 181
    8a2a:	58 e0       	ldi	r21, 0x08	; 8
    8a2c:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
		  lcd_print(3,1,strFreeMessageLine3);
    8a30:	83 e0       	ldi	r24, 0x03	; 3
    8a32:	61 e0       	ldi	r22, 0x01	; 1
    8a34:	40 e5       	ldi	r20, 0x50	; 80
    8a36:	59 e0       	ldi	r21, 0x09	; 9
    8a38:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
		  lcd_print(4,1,strFreeMessageLine4);
    8a3c:	84 e0       	ldi	r24, 0x04	; 4
    8a3e:	61 e0       	ldi	r22, 0x01	; 1
    8a40:	4d e0       	ldi	r20, 0x0D	; 13
    8a42:	5d e0       	ldi	r21, 0x0D	; 13
    8a44:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
	      TimDisplay=0;
    8a48:	10 92 95 01 	sts	0x0195, r1
	      stFreeMessage=fmDelayViewMesage;
    8a4c:	82 e0       	ldi	r24, 0x02	; 2
    8a4e:	05 c0       	rjmp	.+10     	; 0x8a5a <FViewFreeMessage+0x60>
	      break;
	 case fmDelayViewMesage:  
	      if (TimDisplay>TIM_FREE_MESSAGE)stFreeMessage=fmFinishFreeMessage;
    8a50:	80 91 95 01 	lds	r24, 0x0195
    8a54:	8b 30       	cpi	r24, 0x0B	; 11
    8a56:	48 f0       	brcs	.+18     	; 0x8a6a <FViewFreeMessage+0x70>
    8a58:	83 e0       	ldi	r24, 0x03	; 3
    8a5a:	80 93 c0 02 	sts	0x02C0, r24
    8a5e:	80 e0       	ldi	r24, 0x00	; 0
    8a60:	08 95       	ret
	      break;
     case fmFinishFreeMessage:
          stFreeMessage=fmInit;
    8a62:	10 92 c0 02 	sts	0x02C0, r1
    8a66:	81 e0       	ldi	r24, 0x01	; 1
    8a68:	08 95       	ret
    8a6a:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
  return Result;
}
    8a6c:	08 95       	ret

00008a6e <DisplayScreenIdle>:
		if ((__num>='0')&&(__num<='9')||(IsStandAloneDetected==True)) 
		break;
	 }
}

void DisplayScreenIdle(void){
    8a6e:	cf 92       	push	r12
    8a70:	df 92       	push	r13
    8a72:	ef 92       	push	r14
    8a74:	ff 92       	push	r15
    8a76:	0f 93       	push	r16
    8a78:	1f 93       	push	r17
    8a7a:	df 93       	push	r29
    8a7c:	cf 93       	push	r28
    8a7e:	cd b7       	in	r28, 0x3d	; 61
    8a80:	de b7       	in	r29, 0x3e	; 62
    8a82:	a8 97       	sbiw	r28, 0x28	; 40
    8a84:	0f b6       	in	r0, 0x3f	; 63
    8a86:	f8 94       	cli
    8a88:	de bf       	out	0x3e, r29	; 62
    8a8a:	0f be       	out	0x3f, r0	; 63
    8a8c:	cd bf       	out	0x3d, r28	; 61
char strCodeName[10],strVersion[10],lcdteks[20];
    sprintf_P(strCodeName,PSTR(CODE_NAME)); 
    8a8e:	00 d0       	rcall	.+0      	; 0x8a90 <DisplayScreenIdle+0x22>
    8a90:	00 d0       	rcall	.+0      	; 0x8a92 <DisplayScreenIdle+0x24>
    8a92:	6e 01       	movw	r12, r28
    8a94:	08 94       	sec
    8a96:	c1 1c       	adc	r12, r1
    8a98:	d1 1c       	adc	r13, r1
    8a9a:	ad b7       	in	r26, 0x3d	; 61
    8a9c:	be b7       	in	r27, 0x3e	; 62
    8a9e:	12 96       	adiw	r26, 0x02	; 2
    8aa0:	dc 92       	st	X, r13
    8aa2:	ce 92       	st	-X, r12
    8aa4:	11 97       	sbiw	r26, 0x01	; 1
    8aa6:	82 e3       	ldi	r24, 0x32	; 50
    8aa8:	92 e2       	ldi	r25, 0x22	; 34
    8aaa:	14 96       	adiw	r26, 0x04	; 4
    8aac:	9c 93       	st	X, r25
    8aae:	8e 93       	st	-X, r24
    8ab0:	13 97       	sbiw	r26, 0x03	; 3
    8ab2:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    sprintf_P(strVersion,PSTR(VERSION_NUM)); 
    8ab6:	bb e0       	ldi	r27, 0x0B	; 11
    8ab8:	eb 2e       	mov	r14, r27
    8aba:	f1 2c       	mov	r15, r1
    8abc:	ec 0e       	add	r14, r28
    8abe:	fd 1e       	adc	r15, r29
    8ac0:	ed b7       	in	r30, 0x3d	; 61
    8ac2:	fe b7       	in	r31, 0x3e	; 62
    8ac4:	f2 82       	std	Z+2, r15	; 0x02
    8ac6:	e1 82       	std	Z+1, r14	; 0x01
    8ac8:	8d e2       	ldi	r24, 0x2D	; 45
    8aca:	92 e2       	ldi	r25, 0x22	; 34
    8acc:	94 83       	std	Z+4, r25	; 0x04
    8ace:	83 83       	std	Z+3, r24	; 0x03
    8ad0:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    sprintf_P(lcdteks,PSTR("%s %s"),strCodeName,strVersion); 
    8ad4:	00 d0       	rcall	.+0      	; 0x8ad6 <DisplayScreenIdle+0x68>
    8ad6:	00 d0       	rcall	.+0      	; 0x8ad8 <DisplayScreenIdle+0x6a>
    8ad8:	ed b7       	in	r30, 0x3d	; 61
    8ada:	fe b7       	in	r31, 0x3e	; 62
    8adc:	31 96       	adiw	r30, 0x01	; 1
    8ade:	8e 01       	movw	r16, r28
    8ae0:	0b 5e       	subi	r16, 0xEB	; 235
    8ae2:	1f 4f       	sbci	r17, 0xFF	; 255
    8ae4:	ad b7       	in	r26, 0x3d	; 61
    8ae6:	be b7       	in	r27, 0x3e	; 62
    8ae8:	12 96       	adiw	r26, 0x02	; 2
    8aea:	1c 93       	st	X, r17
    8aec:	0e 93       	st	-X, r16
    8aee:	11 97       	sbiw	r26, 0x01	; 1
    8af0:	87 e2       	ldi	r24, 0x27	; 39
    8af2:	92 e2       	ldi	r25, 0x22	; 34
    8af4:	93 83       	std	Z+3, r25	; 0x03
    8af6:	82 83       	std	Z+2, r24	; 0x02
    8af8:	d5 82       	std	Z+5, r13	; 0x05
    8afa:	c4 82       	std	Z+4, r12	; 0x04
    8afc:	f7 82       	std	Z+7, r15	; 0x07
    8afe:	e6 82       	std	Z+6, r14	; 0x06
    8b00:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
	lcd_clear();
    8b04:	ed b7       	in	r30, 0x3d	; 61
    8b06:	fe b7       	in	r31, 0x3e	; 62
    8b08:	38 96       	adiw	r30, 0x08	; 8
    8b0a:	0f b6       	in	r0, 0x3f	; 63
    8b0c:	f8 94       	cli
    8b0e:	fe bf       	out	0x3e, r31	; 62
    8b10:	0f be       	out	0x3f, r0	; 63
    8b12:	ed bf       	out	0x3d, r30	; 61
    8b14:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
	lcd_print(1,1,lcdteks);
    8b18:	81 e0       	ldi	r24, 0x01	; 1
    8b1a:	61 e0       	ldi	r22, 0x01	; 1
    8b1c:	a8 01       	movw	r20, r16
    8b1e:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
}
    8b22:	a8 96       	adiw	r28, 0x28	; 40
    8b24:	0f b6       	in	r0, 0x3f	; 63
    8b26:	f8 94       	cli
    8b28:	de bf       	out	0x3e, r29	; 62
    8b2a:	0f be       	out	0x3f, r0	; 63
    8b2c:	cd bf       	out	0x3d, r28	; 61
    8b2e:	cf 91       	pop	r28
    8b30:	df 91       	pop	r29
    8b32:	1f 91       	pop	r17
    8b34:	0f 91       	pop	r16
    8b36:	ff 90       	pop	r15
    8b38:	ef 90       	pop	r14
    8b3a:	df 90       	pop	r13
    8b3c:	cf 90       	pop	r12
    8b3e:	08 95       	ret

00008b40 <_scr_pump>:

void leadingZero(char Val,char *StrResult){
     sprintf_P(StrResult,PSTR("%.2d"),Val);

}
void _scr_pump(void){
    8b40:	8f 92       	push	r8
    8b42:	9f 92       	push	r9
    8b44:	af 92       	push	r10
    8b46:	bf 92       	push	r11
    8b48:	cf 92       	push	r12
    8b4a:	df 92       	push	r13
    8b4c:	ef 92       	push	r14
    8b4e:	ff 92       	push	r15
    8b50:	0f 93       	push	r16
    8b52:	1f 93       	push	r17
    8b54:	df 93       	push	r29
    8b56:	cf 93       	push	r28
    8b58:	cd b7       	in	r28, 0x3d	; 61
    8b5a:	de b7       	in	r29, 0x3e	; 62
    8b5c:	6c 97       	sbiw	r28, 0x1c	; 28
    8b5e:	0f b6       	in	r0, 0x3f	; 63
    8b60:	f8 94       	cli
    8b62:	de bf       	out	0x3e, r29	; 62
    8b64:	0f be       	out	0x3f, r0	; 63
    8b66:	cd bf       	out	0x3d, r28	; 61
	 //char strPumpL[3],strPumpR[3];
	 char __pump_id[8];
	 char i;
     char lcdteks[20];
	 lcd_clear();_delay_ms(10);
    8b68:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
    8b6c:	84 ec       	ldi	r24, 0xC4	; 196
    8b6e:	99 e0       	ldi	r25, 0x09	; 9
    8b70:	01 97       	sbiw	r24, 0x01	; 1
    8b72:	f1 f7       	brne	.-4      	; 0x8b70 <_scr_pump+0x30>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    8b74:	8e 01       	movw	r16, r28
    8b76:	0f 5f       	subi	r16, 0xFF	; 255
    8b78:	1f 4f       	sbci	r17, 0xFF	; 255
    8b7a:	c8 01       	movw	r24, r16
    8b7c:	65 e4       	ldi	r22, 0x45	; 69
    8b7e:	70 e0       	ldi	r23, 0x00	; 0
    8b80:	48 e0       	ldi	r20, 0x08	; 8
    8b82:	50 e0       	ldi	r21, 0x00	; 0
    8b84:	2d ef       	ldi	r18, 0xFD	; 253
    8b86:	32 e1       	ldi	r19, 0x12	; 18
    8b88:	0e 94 f1 b3 	call	0x167e2	; 0x167e2 <__eerd_block>
    8b8c:	78 01       	movw	r14, r16
    8b8e:	01 e0       	ldi	r16, 0x01	; 1
    8b90:	10 e0       	ldi	r17, 0x00	; 0
		eeprom_read_block((void*) &__pump_id, (const void*) &DefPumpMap, 8);
        for (i=0;i<4;i++){
             //leadingZero(__pump_id[i],strPumpL);
			 //leadingZero(__pump_id[i+4],strPumpR);
             //sprintf_P(lcdteks,PSTR("%d.P%s | %.P%s  "),(i+1),strPumpL,(i+5),strPumpR);
			 sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d "),(i+1),__pump_id[i],(i+5),__pump_id[i+4]);
    8b92:	29 e0       	ldi	r18, 0x09	; 9
    8b94:	c2 2e       	mov	r12, r18
    8b96:	d1 2c       	mov	r13, r1
    8b98:	cc 0e       	add	r12, r28
    8b9a:	dd 1e       	adc	r13, r29
    8b9c:	9f e6       	ldi	r25, 0x6F	; 111
    8b9e:	89 2e       	mov	r8, r25
    8ba0:	9d e0       	ldi	r25, 0x0D	; 13
    8ba2:	99 2e       	mov	r9, r25
	 char i;
     char lcdteks[20];
	 lcd_clear();_delay_ms(10);
	 //Display
		eeprom_read_block((void*) &__pump_id, (const void*) &DefPumpMap, 8);
        for (i=0;i<4;i++){
    8ba4:	85 e0       	ldi	r24, 0x05	; 5
    8ba6:	a8 2e       	mov	r10, r24
    8ba8:	b1 2c       	mov	r11, r1
    8baa:	ac 0e       	add	r10, r28
    8bac:	bd 1e       	adc	r11, r29
             //leadingZero(__pump_id[i],strPumpL);
			 //leadingZero(__pump_id[i+4],strPumpR);
             //sprintf_P(lcdteks,PSTR("%d.P%s | %.P%s  "),(i+1),strPumpL,(i+5),strPumpR);
			 sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d "),(i+1),__pump_id[i],(i+5),__pump_id[i+4]);
    8bae:	8d b7       	in	r24, 0x3d	; 61
    8bb0:	9e b7       	in	r25, 0x3e	; 62
    8bb2:	0c 97       	sbiw	r24, 0x0c	; 12
    8bb4:	0f b6       	in	r0, 0x3f	; 63
    8bb6:	f8 94       	cli
    8bb8:	9e bf       	out	0x3e, r25	; 62
    8bba:	0f be       	out	0x3f, r0	; 63
    8bbc:	8d bf       	out	0x3d, r24	; 61
    8bbe:	ed b7       	in	r30, 0x3d	; 61
    8bc0:	fe b7       	in	r31, 0x3e	; 62
    8bc2:	31 96       	adiw	r30, 0x01	; 1
    8bc4:	ad b7       	in	r26, 0x3d	; 61
    8bc6:	be b7       	in	r27, 0x3e	; 62
    8bc8:	12 96       	adiw	r26, 0x02	; 2
    8bca:	dc 92       	st	X, r13
    8bcc:	ce 92       	st	-X, r12
    8bce:	11 97       	sbiw	r26, 0x01	; 1
    8bd0:	93 82       	std	Z+3, r9	; 0x03
    8bd2:	82 82       	std	Z+2, r8	; 0x02
    8bd4:	15 83       	std	Z+5, r17	; 0x05
    8bd6:	04 83       	std	Z+4, r16	; 0x04
    8bd8:	d7 01       	movw	r26, r14
    8bda:	8c 91       	ld	r24, X
    8bdc:	86 83       	std	Z+6, r24	; 0x06
    8bde:	17 82       	std	Z+7, r1	; 0x07
    8be0:	0c 5f       	subi	r16, 0xFC	; 252
    8be2:	1f 4f       	sbci	r17, 0xFF	; 255
    8be4:	11 87       	std	Z+9, r17	; 0x09
    8be6:	00 87       	std	Z+8, r16	; 0x08
    8be8:	04 50       	subi	r16, 0x04	; 4
    8bea:	10 40       	sbci	r17, 0x00	; 0
    8bec:	14 96       	adiw	r26, 0x04	; 4
    8bee:	8c 91       	ld	r24, X
    8bf0:	82 87       	std	Z+10, r24	; 0x0a
    8bf2:	13 86       	std	Z+11, r1	; 0x0b
    8bf4:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
			 lcd_print((i+1),1,lcdteks);
    8bf8:	8d b7       	in	r24, 0x3d	; 61
    8bfa:	9e b7       	in	r25, 0x3e	; 62
    8bfc:	0c 96       	adiw	r24, 0x0c	; 12
    8bfe:	0f b6       	in	r0, 0x3f	; 63
    8c00:	f8 94       	cli
    8c02:	9e bf       	out	0x3e, r25	; 62
    8c04:	0f be       	out	0x3f, r0	; 63
    8c06:	8d bf       	out	0x3d, r24	; 61
    8c08:	80 2f       	mov	r24, r16
    8c0a:	61 e0       	ldi	r22, 0x01	; 1
    8c0c:	a6 01       	movw	r20, r12
    8c0e:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
    8c12:	08 94       	sec
    8c14:	e1 1c       	adc	r14, r1
    8c16:	f1 1c       	adc	r15, r1
    8c18:	0f 5f       	subi	r16, 0xFF	; 255
    8c1a:	1f 4f       	sbci	r17, 0xFF	; 255
	 char i;
     char lcdteks[20];
	 lcd_clear();_delay_ms(10);
	 //Display
		eeprom_read_block((void*) &__pump_id, (const void*) &DefPumpMap, 8);
        for (i=0;i<4;i++){
    8c1c:	ea 14       	cp	r14, r10
    8c1e:	fb 04       	cpc	r15, r11
    8c20:	31 f6       	brne	.-116    	; 0x8bae <_scr_pump+0x6e>
			 //leadingZero(__pump_id[i+4],strPumpR);
             //sprintf_P(lcdteks,PSTR("%d.P%s | %.P%s  "),(i+1),strPumpL,(i+5),strPumpR);
			 sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d "),(i+1),__pump_id[i],(i+5),__pump_id[i+4]);
			 lcd_print((i+1),1,lcdteks);
		}
        lcd_printf(4,15,PSTR("*)Exit"));
    8c22:	84 e0       	ldi	r24, 0x04	; 4
    8c24:	6f e0       	ldi	r22, 0x0F	; 15
    8c26:	48 e6       	ldi	r20, 0x68	; 104
    8c28:	5d e0       	ldi	r21, 0x0D	; 13
    8c2a:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
}
    8c2e:	6c 96       	adiw	r28, 0x1c	; 28
    8c30:	0f b6       	in	r0, 0x3f	; 63
    8c32:	f8 94       	cli
    8c34:	de bf       	out	0x3e, r29	; 62
    8c36:	0f be       	out	0x3f, r0	; 63
    8c38:	cd bf       	out	0x3d, r28	; 61
    8c3a:	cf 91       	pop	r28
    8c3c:	df 91       	pop	r29
    8c3e:	1f 91       	pop	r17
    8c40:	0f 91       	pop	r16
    8c42:	ff 90       	pop	r15
    8c44:	ef 90       	pop	r14
    8c46:	df 90       	pop	r13
    8c48:	cf 90       	pop	r12
    8c4a:	bf 90       	pop	r11
    8c4c:	af 90       	pop	r10
    8c4e:	9f 90       	pop	r9
    8c50:	8f 90       	pop	r8
    8c52:	08 95       	ret

00008c54 <_menu_host>:
			lcd_print(__x, __y, __buff);
		}
	}
}

void _menu_host(void){
    8c54:	2f 92       	push	r2
    8c56:	3f 92       	push	r3
    8c58:	4f 92       	push	r4
    8c5a:	5f 92       	push	r5
    8c5c:	6f 92       	push	r6
    8c5e:	7f 92       	push	r7
    8c60:	8f 92       	push	r8
    8c62:	9f 92       	push	r9
    8c64:	af 92       	push	r10
    8c66:	bf 92       	push	r11
    8c68:	cf 92       	push	r12
    8c6a:	df 92       	push	r13
    8c6c:	ef 92       	push	r14
    8c6e:	ff 92       	push	r15
    8c70:	0f 93       	push	r16
    8c72:	1f 93       	push	r17
    8c74:	df 93       	push	r29
    8c76:	cf 93       	push	r28
    8c78:	cd b7       	in	r28, 0x3d	; 61
    8c7a:	de b7       	in	r29, 0x3e	; 62
    8c7c:	6d 97       	sbiw	r28, 0x1d	; 29
    8c7e:	0f b6       	in	r0, 0x3f	; 63
    8c80:	f8 94       	cli
    8c82:	de bf       	out	0x3e, r29	; 62
    8c84:	0f be       	out	0x3f, r0	; 63
    8c86:	cd bf       	out	0x3d, r28	; 61
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    8c88:	e1 99       	sbic	0x1c, 1	; 28
    8c8a:	fe cf       	rjmp	.-4      	; 0x8c88 <_menu_host+0x34>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    8c8c:	21 ec       	ldi	r18, 0xC1	; 193
    8c8e:	33 e0       	ldi	r19, 0x03	; 3
    8c90:	3f bb       	out	0x1f, r19	; 31
    8c92:	2e bb       	out	0x1e, r18	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    8c94:	e0 9a       	sbi	0x1c, 0	; 28
    8c96:	8d b3       	in	r24, 0x1d	; 29
	char 			__value[4];
	unsigned char	__i, __x, __y, __key, __num, __buff[5];
	char lcdteks[20];
	static char TermID;

	__value[0] = eeprom_read_byte(&DefPrintMoney);
    8c98:	89 83       	std	Y+1, r24	; 0x01
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    8c9a:	e1 99       	sbic	0x1c, 1	; 28
    8c9c:	fe cf       	rjmp	.-4      	; 0x8c9a <_menu_host+0x46>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    8c9e:	87 e3       	ldi	r24, 0x37	; 55
    8ca0:	90 e0       	ldi	r25, 0x00	; 0
    8ca2:	9f bb       	out	0x1f, r25	; 31
    8ca4:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    8ca6:	e0 9a       	sbi	0x1c, 0	; 28
    8ca8:	8d b3       	in	r24, 0x1d	; 29
	__value[1] = eeprom_read_byte(&DefShowDateTime);
    8caa:	8a 83       	std	Y+2, r24	; 0x02
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    8cac:	e1 99       	sbic	0x1c, 1	; 28
    8cae:	fe cf       	rjmp	.-4      	; 0x8cac <_menu_host+0x58>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    8cb0:	08 e3       	ldi	r16, 0x38	; 56
    8cb2:	20 2e       	mov	r2, r16
    8cb4:	00 e0       	ldi	r16, 0x00	; 0
    8cb6:	30 2e       	mov	r3, r16
    8cb8:	3f ba       	out	0x1f, r3	; 31
    8cba:	2e ba       	out	0x1e, r2	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    8cbc:	e0 9a       	sbi	0x1c, 0	; 28
    8cbe:	8d b3       	in	r24, 0x1d	; 29
	__value[2] = eeprom_read_byte(&DefNotifScreen);
    8cc0:	8b 83       	std	Y+3, r24	; 0x03
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    8cc2:	e1 99       	sbic	0x1c, 1	; 28
    8cc4:	fe cf       	rjmp	.-4      	; 0x8cc2 <_menu_host+0x6e>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    8cc6:	10 e0       	ldi	r17, 0x00	; 0
    8cc8:	41 2e       	mov	r4, r17
    8cca:	10 e0       	ldi	r17, 0x00	; 0
    8ccc:	51 2e       	mov	r5, r17
    8cce:	5f ba       	out	0x1f, r5	; 31
    8cd0:	4e ba       	out	0x1e, r4	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    8cd2:	e0 9a       	sbi	0x1c, 0	; 28
    8cd4:	8d b3       	in	r24, 0x1d	; 29
	TermID= eeprom_read_byte(&DefIFT_ID);
    8cd6:	80 93 5e 02 	sts	0x025E, r24


	lcd_clear();_delay_ms(10);
    8cda:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
    8cde:	84 ec       	ldi	r24, 0xC4	; 196
    8ce0:	99 e0       	ldi	r25, 0x09	; 9
    8ce2:	01 97       	sbiw	r24, 0x01	; 1
    8ce4:	f1 f7       	brne	.-4      	; 0x8ce2 <_menu_host+0x8e>
	lcd_printf(1, 1, PSTR("1)Money :"));
    8ce6:	81 e0       	ldi	r24, 0x01	; 1
    8ce8:	61 e0       	ldi	r22, 0x01	; 1
    8cea:	47 e5       	ldi	r20, 0x57	; 87
    8cec:	5b e0       	ldi	r21, 0x0B	; 11
    8cee:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
	lcd_printf(2, 1, PSTR("2)D/T   :"));
    8cf2:	82 e0       	ldi	r24, 0x02	; 2
    8cf4:	61 e0       	ldi	r22, 0x01	; 1
    8cf6:	4d e4       	ldi	r20, 0x4D	; 77
    8cf8:	5b e0       	ldi	r21, 0x0B	; 11
    8cfa:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
	lcd_printf(3, 1, PSTR("3)Notif :     *)Exit"));
    8cfe:	83 e0       	ldi	r24, 0x03	; 3
    8d00:	61 e0       	ldi	r22, 0x01	; 1
    8d02:	48 e3       	ldi	r20, 0x38	; 56
    8d04:	5b e0       	ldi	r21, 0x0B	; 11
    8d06:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
   sprintf_P(lcdteks,PSTR("4)TermID:%d "),TermID);
    8d0a:	00 d0       	rcall	.+0      	; 0x8d0c <_menu_host+0xb8>
    8d0c:	00 d0       	rcall	.+0      	; 0x8d0e <_menu_host+0xba>
    8d0e:	00 d0       	rcall	.+0      	; 0x8d10 <_menu_host+0xbc>
    8d10:	ed b7       	in	r30, 0x3d	; 61
    8d12:	fe b7       	in	r31, 0x3e	; 62
    8d14:	31 96       	adiw	r30, 0x01	; 1
    8d16:	8e 01       	movw	r16, r28
    8d18:	06 5f       	subi	r16, 0xF6	; 246
    8d1a:	1f 4f       	sbci	r17, 0xFF	; 255
    8d1c:	ad b7       	in	r26, 0x3d	; 61
    8d1e:	be b7       	in	r27, 0x3e	; 62
    8d20:	12 96       	adiw	r26, 0x02	; 2
    8d22:	1c 93       	st	X, r17
    8d24:	0e 93       	st	-X, r16
    8d26:	11 97       	sbiw	r26, 0x01	; 1
    8d28:	8b e2       	ldi	r24, 0x2B	; 43
    8d2a:	9b e0       	ldi	r25, 0x0B	; 11
    8d2c:	93 83       	std	Z+3, r25	; 0x03
    8d2e:	82 83       	std	Z+2, r24	; 0x02
    8d30:	80 91 5e 02 	lds	r24, 0x025E
    8d34:	84 83       	std	Z+4, r24	; 0x04
    8d36:	15 82       	std	Z+5, r1	; 0x05
    8d38:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
		 lcd_print(4, 1,lcdteks);
    8d3c:	ed b7       	in	r30, 0x3d	; 61
    8d3e:	fe b7       	in	r31, 0x3e	; 62
    8d40:	36 96       	adiw	r30, 0x06	; 6
    8d42:	0f b6       	in	r0, 0x3f	; 63
    8d44:	f8 94       	cli
    8d46:	fe bf       	out	0x3e, r31	; 62
    8d48:	0f be       	out	0x3f, r0	; 63
    8d4a:	ed bf       	out	0x3d, r30	; 61
    8d4c:	84 e0       	ldi	r24, 0x04	; 4
    8d4e:	61 e0       	ldi	r22, 0x01	; 1
    8d50:	a8 01       	movw	r20, r16
    8d52:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
	lcd_printf(4, 15, PSTR("#)Save"));
    8d56:	84 e0       	ldi	r24, 0x04	; 4
    8d58:	6f e0       	ldi	r22, 0x0F	; 15
    8d5a:	44 e2       	ldi	r20, 0x24	; 36
    8d5c:	5b e0       	ldi	r21, 0x0B	; 11
    8d5e:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
    8d62:	b2 ec       	ldi	r27, 0xC2	; 194
    8d64:	eb 2e       	mov	r14, r27
    8d66:	b2 e0       	ldi	r27, 0x02	; 2
    8d68:	fb 2e       	mov	r15, r27
    8d6a:	6e 01       	movw	r12, r28
    8d6c:	08 94       	sec
    8d6e:	c1 1c       	adc	r12, r1
    8d70:	d1 1c       	adc	r13, r1

	for(__i = 0; __i < 3; __i++){
		__x = pgm_read_byte(&__hostloc[__i][0]);
		__y = pgm_read_byte(&__hostloc[__i][1]);
		sprintf_P(__buff,PSTR("%d"),__value[__i]);
    8d72:	a5 e0       	ldi	r26, 0x05	; 5
    8d74:	aa 2e       	mov	r10, r26
    8d76:	b1 2c       	mov	r11, r1
    8d78:	ac 0e       	add	r10, r28
    8d7a:	bd 1e       	adc	r11, r29
    8d7c:	f1 e2       	ldi	r31, 0x21	; 33
    8d7e:	8f 2e       	mov	r8, r31
    8d80:	fb e0       	ldi	r31, 0x0B	; 11
    8d82:	9f 2e       	mov	r9, r31
   sprintf_P(lcdteks,PSTR("4)TermID:%d "),TermID);
		 lcd_print(4, 1,lcdteks);
	lcd_printf(4, 15, PSTR("#)Save"));

	for(__i = 0; __i < 3; __i++){
		__x = pgm_read_byte(&__hostloc[__i][0]);
    8d84:	f7 01       	movw	r30, r14
    8d86:	04 91       	lpm	r16, Z+
		__y = pgm_read_byte(&__hostloc[__i][1]);
    8d88:	08 94       	sec
    8d8a:	e1 1c       	adc	r14, r1
    8d8c:	f1 1c       	adc	r15, r1
    8d8e:	f7 01       	movw	r30, r14
    8d90:	14 91       	lpm	r17, Z+
		sprintf_P(__buff,PSTR("%d"),__value[__i]);
    8d92:	00 d0       	rcall	.+0      	; 0x8d94 <_menu_host+0x140>
    8d94:	00 d0       	rcall	.+0      	; 0x8d96 <_menu_host+0x142>
    8d96:	00 d0       	rcall	.+0      	; 0x8d98 <_menu_host+0x144>
    8d98:	ed b7       	in	r30, 0x3d	; 61
    8d9a:	fe b7       	in	r31, 0x3e	; 62
    8d9c:	31 96       	adiw	r30, 0x01	; 1
    8d9e:	ad b7       	in	r26, 0x3d	; 61
    8da0:	be b7       	in	r27, 0x3e	; 62
    8da2:	12 96       	adiw	r26, 0x02	; 2
    8da4:	bc 92       	st	X, r11
    8da6:	ae 92       	st	-X, r10
    8da8:	11 97       	sbiw	r26, 0x01	; 1
    8daa:	93 82       	std	Z+3, r9	; 0x03
    8dac:	82 82       	std	Z+2, r8	; 0x02
    8dae:	d6 01       	movw	r26, r12
    8db0:	8d 91       	ld	r24, X+
    8db2:	6d 01       	movw	r12, r26
    8db4:	84 83       	std	Z+4, r24	; 0x04
    8db6:	15 82       	std	Z+5, r1	; 0x05
    8db8:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
		//_f_inttostr(__buff, __value[__i]);
		lcd_print(__x, __y, __buff);
    8dbc:	ed b7       	in	r30, 0x3d	; 61
    8dbe:	fe b7       	in	r31, 0x3e	; 62
    8dc0:	36 96       	adiw	r30, 0x06	; 6
    8dc2:	0f b6       	in	r0, 0x3f	; 63
    8dc4:	f8 94       	cli
    8dc6:	fe bf       	out	0x3e, r31	; 62
    8dc8:	0f be       	out	0x3f, r0	; 63
    8dca:	ed bf       	out	0x3d, r30	; 61
    8dcc:	80 2f       	mov	r24, r16
    8dce:	61 2f       	mov	r22, r17
    8dd0:	a5 01       	movw	r20, r10
    8dd2:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
    8dd6:	08 94       	sec
    8dd8:	e1 1c       	adc	r14, r1
    8dda:	f1 1c       	adc	r15, r1
	lcd_printf(3, 1, PSTR("3)Notif :     *)Exit"));
   sprintf_P(lcdteks,PSTR("4)TermID:%d "),TermID);
		 lcd_print(4, 1,lcdteks);
	lcd_printf(4, 15, PSTR("#)Save"));

	for(__i = 0; __i < 3; __i++){
    8ddc:	f8 ec       	ldi	r31, 0xC8	; 200
    8dde:	ef 16       	cp	r14, r31
    8de0:	f2 e0       	ldi	r31, 0x02	; 2
    8de2:	ff 06       	cpc	r15, r31
    8de4:	79 f6       	brne	.-98     	; 0x8d84 <_menu_host+0x130>
			lcd_print(__x, __y, __buff);
		}else
		if (__num=='4'){
		    if (TermID<=99)TermID++;
			else TermID=1;
	     sprintf_P(lcdteks,PSTR("4)TermID:%d "),TermID);
    8de6:	ea e0       	ldi	r30, 0x0A	; 10
    8de8:	ae 2e       	mov	r10, r30
    8dea:	b1 2c       	mov	r11, r1
    8dec:	ac 0e       	add	r10, r28
    8dee:	bd 1e       	adc	r11, r29
    8df0:	71 e1       	ldi	r23, 0x11	; 17
    8df2:	67 2e       	mov	r6, r23
    8df4:	7b e0       	ldi	r23, 0x0B	; 11
    8df6:	77 2e       	mov	r7, r23
			eeprom_write_byte(&DefNotifScreen, __value[2]);
			eeprom_write_byte(&DefIFT_ID,TermID);
			break;
		}
		if(__num >= 0x31 && __num <= 0x33){
			if(__value[__num - 0x31] == 1)
    8df8:	6e 01       	movw	r12, r28
    8dfa:	08 94       	sec
    8dfc:	c1 1c       	adc	r12, r1
    8dfe:	d1 1c       	adc	r13, r1
				__value[__num - 0x31] = 0;
			else
				__value[__num - 0x31]++;
			__x = pgm_read_byte(&__hostloc[__num - 0x31][0]);
			__y = pgm_read_byte(&__hostloc[__num - 0x31][1]);
			sprintf_P(__buff,PSTR("%d"),__value[__num - 0x31]);
    8e00:	65 e0       	ldi	r22, 0x05	; 5
    8e02:	e6 2e       	mov	r14, r22
    8e04:	f1 2c       	mov	r15, r1
    8e06:	ec 0e       	add	r14, r28
    8e08:	fd 1e       	adc	r15, r29
    8e0a:	5e e1       	ldi	r21, 0x1E	; 30
    8e0c:	85 2e       	mov	r8, r21
    8e0e:	5b e0       	ldi	r21, 0x0B	; 11
    8e10:	95 2e       	mov	r9, r21
		//_f_inttostr(__buff, __value[__i]);
		lcd_print(__x, __y, __buff);
	}

	while(1){
		__key = _key_scan(1);
    8e12:	81 e0       	ldi	r24, 0x01	; 1
    8e14:	0e 94 84 ae 	call	0x15d08	; 0x15d08 <_key_scan>
    8e18:	18 2f       	mov	r17, r24
		__num = _key_btn(__key);
    8e1a:	0e 94 e5 ad 	call	0x15bca	; 0x15bca <_key_btn>
    8e1e:	98 2f       	mov	r25, r24

		if(__key == _KEY_CANCEL)
    8e20:	17 3e       	cpi	r17, 0xE7	; 231
    8e22:	09 f4       	brne	.+2      	; 0x8e26 <_menu_host+0x1d2>
    8e24:	ad c0       	rjmp	.+346    	; 0x8f80 <_menu_host+0x32c>
			return;
		if(__key==_KEY_ENTER){
    8e26:	17 3b       	cpi	r17, 0xB7	; 183
    8e28:	09 f0       	breq	.+2      	; 0x8e2c <_menu_host+0x1d8>
    8e2a:	32 c0       	rjmp	.+100    	; 0x8e90 <_menu_host+0x23c>
			eeprom_write_byte(&DefPrintMoney, __value[0]);
    8e2c:	89 81       	ldd	r24, Y+1	; 0x01
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    8e2e:	e1 99       	sbic	0x1c, 1	; 28
    8e30:	fe cf       	rjmp	.-4      	; 0x8e2e <_menu_host+0x1da>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    8e32:	21 ec       	ldi	r18, 0xC1	; 193
    8e34:	33 e0       	ldi	r19, 0x03	; 3
    8e36:	3f bb       	out	0x1f, r19	; 31
    8e38:	2e bb       	out	0x1e, r18	; 30
#endif
    EEDR = __value;
    8e3a:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    8e3c:	0f b6       	in	r0, 0x3f	; 63
    8e3e:	f8 94       	cli
    8e40:	e2 9a       	sbi	0x1c, 2	; 28
    8e42:	e1 9a       	sbi	0x1c, 1	; 28
    8e44:	0f be       	out	0x3f, r0	; 63
			eeprom_write_byte(&DefShowDateTime, __value[1]);
    8e46:	8a 81       	ldd	r24, Y+2	; 0x02
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    8e48:	e1 99       	sbic	0x1c, 1	; 28
    8e4a:	fe cf       	rjmp	.-4      	; 0x8e48 <_menu_host+0x1f4>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    8e4c:	a7 e3       	ldi	r26, 0x37	; 55
    8e4e:	b0 e0       	ldi	r27, 0x00	; 0
    8e50:	bf bb       	out	0x1f, r27	; 31
    8e52:	ae bb       	out	0x1e, r26	; 30
#endif
    EEDR = __value;
    8e54:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    8e56:	0f b6       	in	r0, 0x3f	; 63
    8e58:	f8 94       	cli
    8e5a:	e2 9a       	sbi	0x1c, 2	; 28
    8e5c:	e1 9a       	sbi	0x1c, 1	; 28
    8e5e:	0f be       	out	0x3f, r0	; 63
			eeprom_write_byte(&DefNotifScreen, __value[2]);
    8e60:	8b 81       	ldd	r24, Y+3	; 0x03
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    8e62:	e1 99       	sbic	0x1c, 1	; 28
    8e64:	fe cf       	rjmp	.-4      	; 0x8e62 <_menu_host+0x20e>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    8e66:	3f ba       	out	0x1f, r3	; 31
    8e68:	2e ba       	out	0x1e, r2	; 30
#endif
    EEDR = __value;
    8e6a:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    8e6c:	0f b6       	in	r0, 0x3f	; 63
    8e6e:	f8 94       	cli
    8e70:	e2 9a       	sbi	0x1c, 2	; 28
    8e72:	e1 9a       	sbi	0x1c, 1	; 28
    8e74:	0f be       	out	0x3f, r0	; 63
			eeprom_write_byte(&DefIFT_ID,TermID);
    8e76:	80 91 5e 02 	lds	r24, 0x025E
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    8e7a:	e1 99       	sbic	0x1c, 1	; 28
    8e7c:	fe cf       	rjmp	.-4      	; 0x8e7a <_menu_host+0x226>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    8e7e:	5f ba       	out	0x1f, r5	; 31
    8e80:	4e ba       	out	0x1e, r4	; 30
#endif
    EEDR = __value;
    8e82:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    8e84:	0f b6       	in	r0, 0x3f	; 63
    8e86:	f8 94       	cli
    8e88:	e2 9a       	sbi	0x1c, 2	; 28
    8e8a:	e1 9a       	sbi	0x1c, 1	; 28
    8e8c:	0f be       	out	0x3f, r0	; 63
    8e8e:	78 c0       	rjmp	.+240    	; 0x8f80 <_menu_host+0x32c>
			break;
		}
		if(__num >= 0x31 && __num <= 0x33){
    8e90:	81 53       	subi	r24, 0x31	; 49
    8e92:	83 30       	cpi	r24, 0x03	; 3
    8e94:	08 f0       	brcs	.+2      	; 0x8e98 <_menu_host+0x244>
    8e96:	40 c0       	rjmp	.+128    	; 0x8f18 <_menu_host+0x2c4>
			if(__value[__num - 0x31] == 1)
    8e98:	a9 2f       	mov	r26, r25
    8e9a:	b0 e0       	ldi	r27, 0x00	; 0
    8e9c:	d1 97       	sbiw	r26, 0x31	; 49
    8e9e:	f6 01       	movw	r30, r12
    8ea0:	ea 0f       	add	r30, r26
    8ea2:	fb 1f       	adc	r31, r27
    8ea4:	80 81       	ld	r24, Z
    8ea6:	81 30       	cpi	r24, 0x01	; 1
    8ea8:	11 f4       	brne	.+4      	; 0x8eae <_menu_host+0x25a>
				__value[__num - 0x31] = 0;
    8eaa:	10 82       	st	Z, r1
    8eac:	02 c0       	rjmp	.+4      	; 0x8eb2 <_menu_host+0x25e>
			else
				__value[__num - 0x31]++;
    8eae:	8f 5f       	subi	r24, 0xFF	; 255
    8eb0:	80 83       	st	Z, r24
			__x = pgm_read_byte(&__hostloc[__num - 0x31][0]);
    8eb2:	29 2f       	mov	r18, r25
    8eb4:	30 e0       	ldi	r19, 0x00	; 0
    8eb6:	21 53       	subi	r18, 0x31	; 49
    8eb8:	30 40       	sbci	r19, 0x00	; 0
    8eba:	22 0f       	add	r18, r18
    8ebc:	33 1f       	adc	r19, r19
    8ebe:	c9 01       	movw	r24, r18
    8ec0:	8e 53       	subi	r24, 0x3E	; 62
    8ec2:	9d 4f       	sbci	r25, 0xFD	; 253
    8ec4:	fc 01       	movw	r30, r24
    8ec6:	04 91       	lpm	r16, Z+
			__y = pgm_read_byte(&__hostloc[__num - 0x31][1]);
    8ec8:	2d 53       	subi	r18, 0x3D	; 61
    8eca:	3d 4f       	sbci	r19, 0xFD	; 253
    8ecc:	f9 01       	movw	r30, r18
    8ece:	14 91       	lpm	r17, Z+
			sprintf_P(__buff,PSTR("%d"),__value[__num - 0x31]);
    8ed0:	00 d0       	rcall	.+0      	; 0x8ed2 <_menu_host+0x27e>
    8ed2:	00 d0       	rcall	.+0      	; 0x8ed4 <_menu_host+0x280>
    8ed4:	00 d0       	rcall	.+0      	; 0x8ed6 <_menu_host+0x282>
    8ed6:	2d b7       	in	r18, 0x3d	; 61
    8ed8:	3e b7       	in	r19, 0x3e	; 62
    8eda:	2f 5f       	subi	r18, 0xFF	; 255
    8edc:	3f 4f       	sbci	r19, 0xFF	; 255
    8ede:	ed b7       	in	r30, 0x3d	; 61
    8ee0:	fe b7       	in	r31, 0x3e	; 62
    8ee2:	f2 82       	std	Z+2, r15	; 0x02
    8ee4:	e1 82       	std	Z+1, r14	; 0x01
    8ee6:	f9 01       	movw	r30, r18
    8ee8:	93 82       	std	Z+3, r9	; 0x03
    8eea:	82 82       	std	Z+2, r8	; 0x02
    8eec:	ac 0d       	add	r26, r12
    8eee:	bd 1d       	adc	r27, r13
    8ef0:	8c 91       	ld	r24, X
    8ef2:	84 83       	std	Z+4, r24	; 0x04
    8ef4:	15 82       	std	Z+5, r1	; 0x05
    8ef6:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
			//_f_inttostr(__buff, __value[__num - 0x31]);
			lcd_print(__x, __y, __buff);
    8efa:	2d b7       	in	r18, 0x3d	; 61
    8efc:	3e b7       	in	r19, 0x3e	; 62
    8efe:	2a 5f       	subi	r18, 0xFA	; 250
    8f00:	3f 4f       	sbci	r19, 0xFF	; 255
    8f02:	0f b6       	in	r0, 0x3f	; 63
    8f04:	f8 94       	cli
    8f06:	3e bf       	out	0x3e, r19	; 62
    8f08:	0f be       	out	0x3f, r0	; 63
    8f0a:	2d bf       	out	0x3d, r18	; 61
    8f0c:	80 2f       	mov	r24, r16
    8f0e:	61 2f       	mov	r22, r17
    8f10:	a7 01       	movw	r20, r14
    8f12:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
    8f16:	7d cf       	rjmp	.-262    	; 0x8e12 <_menu_host+0x1be>
		}else
		if (__num=='4'){
    8f18:	94 33       	cpi	r25, 0x34	; 52
    8f1a:	09 f0       	breq	.+2      	; 0x8f1e <_menu_host+0x2ca>
    8f1c:	7a cf       	rjmp	.-268    	; 0x8e12 <_menu_host+0x1be>
		    if (TermID<=99)TermID++;
    8f1e:	80 91 5e 02 	lds	r24, 0x025E
    8f22:	84 36       	cpi	r24, 0x64	; 100
    8f24:	10 f4       	brcc	.+4      	; 0x8f2a <_menu_host+0x2d6>
    8f26:	8f 5f       	subi	r24, 0xFF	; 255
    8f28:	01 c0       	rjmp	.+2      	; 0x8f2c <_menu_host+0x2d8>
			else TermID=1;
    8f2a:	81 e0       	ldi	r24, 0x01	; 1
    8f2c:	80 93 5e 02 	sts	0x025E, r24
	     sprintf_P(lcdteks,PSTR("4)TermID:%d "),TermID);
    8f30:	00 d0       	rcall	.+0      	; 0x8f32 <_menu_host+0x2de>
    8f32:	00 d0       	rcall	.+0      	; 0x8f34 <_menu_host+0x2e0>
    8f34:	00 d0       	rcall	.+0      	; 0x8f36 <_menu_host+0x2e2>
    8f36:	ed b7       	in	r30, 0x3d	; 61
    8f38:	fe b7       	in	r31, 0x3e	; 62
    8f3a:	31 96       	adiw	r30, 0x01	; 1
    8f3c:	ad b7       	in	r26, 0x3d	; 61
    8f3e:	be b7       	in	r27, 0x3e	; 62
    8f40:	12 96       	adiw	r26, 0x02	; 2
    8f42:	bc 92       	st	X, r11
    8f44:	ae 92       	st	-X, r10
    8f46:	11 97       	sbiw	r26, 0x01	; 1
    8f48:	73 82       	std	Z+3, r7	; 0x03
    8f4a:	62 82       	std	Z+2, r6	; 0x02
    8f4c:	80 91 5e 02 	lds	r24, 0x025E
    8f50:	84 83       	std	Z+4, r24	; 0x04
    8f52:	15 82       	std	Z+5, r1	; 0x05
    8f54:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
		 lcd_print(4, 1,lcdteks);lcd_printf(4, 15, PSTR("#)Save"));
    8f58:	ed b7       	in	r30, 0x3d	; 61
    8f5a:	fe b7       	in	r31, 0x3e	; 62
    8f5c:	36 96       	adiw	r30, 0x06	; 6
    8f5e:	0f b6       	in	r0, 0x3f	; 63
    8f60:	f8 94       	cli
    8f62:	fe bf       	out	0x3e, r31	; 62
    8f64:	0f be       	out	0x3f, r0	; 63
    8f66:	ed bf       	out	0x3d, r30	; 61
    8f68:	84 e0       	ldi	r24, 0x04	; 4
    8f6a:	61 e0       	ldi	r22, 0x01	; 1
    8f6c:	a5 01       	movw	r20, r10
    8f6e:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
    8f72:	84 e0       	ldi	r24, 0x04	; 4
    8f74:	6f e0       	ldi	r22, 0x0F	; 15
    8f76:	4a e0       	ldi	r20, 0x0A	; 10
    8f78:	5b e0       	ldi	r21, 0x0B	; 11
    8f7a:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
    8f7e:	49 cf       	rjmp	.-366    	; 0x8e12 <_menu_host+0x1be>
		 
		}

	}
}
    8f80:	6d 96       	adiw	r28, 0x1d	; 29
    8f82:	0f b6       	in	r0, 0x3f	; 63
    8f84:	f8 94       	cli
    8f86:	de bf       	out	0x3e, r29	; 62
    8f88:	0f be       	out	0x3f, r0	; 63
    8f8a:	cd bf       	out	0x3d, r28	; 61
    8f8c:	cf 91       	pop	r28
    8f8e:	df 91       	pop	r29
    8f90:	1f 91       	pop	r17
    8f92:	0f 91       	pop	r16
    8f94:	ff 90       	pop	r15
    8f96:	ef 90       	pop	r14
    8f98:	df 90       	pop	r13
    8f9a:	cf 90       	pop	r12
    8f9c:	bf 90       	pop	r11
    8f9e:	af 90       	pop	r10
    8fa0:	9f 90       	pop	r9
    8fa2:	8f 90       	pop	r8
    8fa4:	7f 90       	pop	r7
    8fa6:	6f 90       	pop	r6
    8fa8:	5f 90       	pop	r5
    8faa:	4f 90       	pop	r4
    8fac:	3f 90       	pop	r3
    8fae:	2f 90       	pop	r2
    8fb0:	08 95       	ret

00008fb2 <FSettingHost>:
char FSettingPrinter(){
     _menu_printer();
	 return MENU_DONE;
}
char FSettingHost(){
     _menu_host();
    8fb2:	0e 94 2a 46 	call	0x8c54	; 0x8c54 <_menu_host>
	 return MENU_DONE;
}
    8fb6:	81 e0       	ldi	r24, 0x01	; 1
    8fb8:	08 95       	ret

00008fba <_menu_printer>:
}

//*************************************************************************
//  ngeset printer

void _menu_printer(void){
    8fba:	2f 92       	push	r2
    8fbc:	3f 92       	push	r3
    8fbe:	4f 92       	push	r4
    8fc0:	5f 92       	push	r5
    8fc2:	6f 92       	push	r6
    8fc4:	7f 92       	push	r7
    8fc6:	8f 92       	push	r8
    8fc8:	9f 92       	push	r9
    8fca:	af 92       	push	r10
    8fcc:	bf 92       	push	r11
    8fce:	cf 92       	push	r12
    8fd0:	df 92       	push	r13
    8fd2:	ef 92       	push	r14
    8fd4:	ff 92       	push	r15
    8fd6:	0f 93       	push	r16
    8fd8:	1f 93       	push	r17
    8fda:	df 93       	push	r29
    8fdc:	cf 93       	push	r28
    8fde:	cd b7       	in	r28, 0x3d	; 61
    8fe0:	de b7       	in	r29, 0x3e	; 62
    8fe2:	2c 97       	sbiw	r28, 0x0c	; 12
    8fe4:	0f b6       	in	r0, 0x3f	; 63
    8fe6:	f8 94       	cli
    8fe8:	de bf       	out	0x3e, r29	; 62
    8fea:	0f be       	out	0x3f, r0	; 63
    8fec:	cd bf       	out	0x3d, r28	; 61
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    8fee:	e1 99       	sbic	0x1c, 1	; 28
    8ff0:	fe cf       	rjmp	.-4      	; 0x8fee <_menu_printer+0x34>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    8ff2:	20 e3       	ldi	r18, 0x30	; 48
    8ff4:	30 e0       	ldi	r19, 0x00	; 0
    8ff6:	3f bb       	out	0x1f, r19	; 31
    8ff8:	2e bb       	out	0x1e, r18	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    8ffa:	e0 9a       	sbi	0x1c, 0	; 28
    8ffc:	5d b3       	in	r21, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    8ffe:	e1 99       	sbic	0x1c, 1	; 28
    9000:	fe cf       	rjmp	.-4      	; 0x8ffe <_menu_printer+0x44>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    9002:	65 e3       	ldi	r22, 0x35	; 53
    9004:	70 e0       	ldi	r23, 0x00	; 0
    9006:	7f bb       	out	0x1f, r23	; 31
    9008:	6e bb       	out	0x1e, r22	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    900a:	e0 9a       	sbi	0x1c, 0	; 28
    900c:	4d b3       	in	r20, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    900e:	e1 99       	sbic	0x1c, 1	; 28
    9010:	fe cf       	rjmp	.-4      	; 0x900e <_menu_printer+0x54>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    9012:	84 e3       	ldi	r24, 0x34	; 52
    9014:	90 e0       	ldi	r25, 0x00	; 0
    9016:	9f bb       	out	0x1f, r25	; 31
    9018:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    901a:	e0 9a       	sbi	0x1c, 0	; 28
    901c:	3d b3       	in	r19, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    901e:	e1 99       	sbic	0x1c, 1	; 28
    9020:	fe cf       	rjmp	.-4      	; 0x901e <_menu_printer+0x64>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    9022:	a3 e3       	ldi	r26, 0x33	; 51
    9024:	b0 e0       	ldi	r27, 0x00	; 0
    9026:	bf bb       	out	0x1f, r27	; 31
    9028:	ae bb       	out	0x1e, r26	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    902a:	e0 9a       	sbi	0x1c, 0	; 28
    902c:	2d b3       	in	r18, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    902e:	e1 99       	sbic	0x1c, 1	; 28
    9030:	fe cf       	rjmp	.-4      	; 0x902e <_menu_printer+0x74>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    9032:	e1 e3       	ldi	r30, 0x31	; 49
    9034:	f0 e0       	ldi	r31, 0x00	; 0
    9036:	ff bb       	out	0x1f, r31	; 31
    9038:	ee bb       	out	0x1e, r30	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    903a:	e0 9a       	sbi	0x1c, 0	; 28
    903c:	9d b3       	in	r25, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    903e:	e1 99       	sbic	0x1c, 1	; 28
    9040:	fe cf       	rjmp	.-4      	; 0x903e <_menu_printer+0x84>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    9042:	62 e3       	ldi	r22, 0x32	; 50
    9044:	70 e0       	ldi	r23, 0x00	; 0
    9046:	7f bb       	out	0x1f, r23	; 31
    9048:	6e bb       	out	0x1e, r22	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    904a:	e0 9a       	sbi	0x1c, 0	; 28
    904c:	8d b3       	in	r24, 0x1d	; 29
	char 			__value[6];
	char	__i, __x, __y, __lmt, __start, __key, __num, __buff[6];
//	char lcdteks[20];

	__value[0] = eeprom_read_byte(&DefPrinterType);
    904e:	59 83       	std	Y+1, r21	; 0x01
	__value[1] = eeprom_read_byte(&DefPrintSize);
    9050:	4a 83       	std	Y+2, r20	; 0x02
	__value[2] = eeprom_read_byte(&DefPrintLogo);
    9052:	3b 83       	std	Y+3, r19	; 0x03
	__value[3] = eeprom_read_byte(&DefPrintAutoCut);
    9054:	2c 83       	std	Y+4, r18	; 0x04
	__value[4] = eeprom_read_byte(&DefPrintScrollEnd);
    9056:	9d 83       	std	Y+5, r25	; 0x05
	__value[5] = eeprom_read_byte(&DefPrintScrollSpace);
    9058:	8e 83       	std	Y+6, r24	; 0x06

	lcd_clear();
    905a:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
	lcd_printf(1, 1, PSTR("1)Type:  5)Scroll:"));
    905e:	81 e0       	ldi	r24, 0x01	; 1
    9060:	61 e0       	ldi	r22, 0x01	; 1
    9062:	44 ea       	ldi	r20, 0xA4	; 164
    9064:	5b e0       	ldi	r21, 0x0B	; 11
    9066:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
	lcd_printf(2, 1, PSTR("2)Size:  6)Space :"));
    906a:	82 e0       	ldi	r24, 0x02	; 2
    906c:	61 e0       	ldi	r22, 0x01	; 1
    906e:	41 e9       	ldi	r20, 0x91	; 145
    9070:	5b e0       	ldi	r21, 0x0B	; 11
    9072:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
	lcd_printf(3, 1, PSTR("3)Logo:  #)Save"));
    9076:	83 e0       	ldi	r24, 0x03	; 3
    9078:	61 e0       	ldi	r22, 0x01	; 1
    907a:	41 e8       	ldi	r20, 0x81	; 129
    907c:	5b e0       	ldi	r21, 0x0B	; 11
    907e:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
	lcd_printf(4, 1, PSTR("4)Cut :  *)Exit"));
    9082:	84 e0       	ldi	r24, 0x04	; 4
    9084:	61 e0       	ldi	r22, 0x01	; 1
    9086:	41 e7       	ldi	r20, 0x71	; 113
    9088:	5b e0       	ldi	r21, 0x0B	; 11
    908a:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
    908e:	0a ea       	ldi	r16, 0xAA	; 170
    9090:	12 e0       	ldi	r17, 0x02	; 2
    9092:	4e 01       	movw	r8, r28
    9094:	08 94       	sec
    9096:	81 1c       	adc	r8, r1
    9098:	91 1c       	adc	r9, r1
    909a:	74 01       	movw	r14, r8

	for(__i = 0; __i < 6; __i++){
		__x = pgm_read_byte(&__prntloc[__i][0]);
		__y = pgm_read_byte(&__prntloc[__i][1]);
        sprintf_P(__buff,PSTR("%d"),__value[__i]);
    909c:	67 e0       	ldi	r22, 0x07	; 7
    909e:	c6 2e       	mov	r12, r22
    90a0:	d1 2c       	mov	r13, r1
    90a2:	cc 0e       	add	r12, r28
    90a4:	dd 1e       	adc	r13, r29
    90a6:	5e e6       	ldi	r21, 0x6E	; 110
    90a8:	25 2e       	mov	r2, r21
    90aa:	5b e0       	ldi	r21, 0x0B	; 11
    90ac:	35 2e       	mov	r3, r21
		//_f_inttostr(__buff, __value[__i]);
		if(__i == 4) sprintf_P(__buff,PSTR("%.2d"),__value[__i]);
    90ae:	49 e6       	ldi	r20, 0x69	; 105
    90b0:	44 2e       	mov	r4, r20
    90b2:	4b e0       	ldi	r20, 0x0B	; 11
    90b4:	54 2e       	mov	r5, r20
	lcd_printf(2, 1, PSTR("2)Size:  6)Space :"));
	lcd_printf(3, 1, PSTR("3)Logo:  #)Save"));
	lcd_printf(4, 1, PSTR("4)Cut :  *)Exit"));

	for(__i = 0; __i < 6; __i++){
		__x = pgm_read_byte(&__prntloc[__i][0]);
    90b6:	f8 01       	movw	r30, r16
    90b8:	74 90       	lpm	r7, Z+
		__y = pgm_read_byte(&__prntloc[__i][1]);
    90ba:	0f 5f       	subi	r16, 0xFF	; 255
    90bc:	1f 4f       	sbci	r17, 0xFF	; 255
    90be:	f8 01       	movw	r30, r16
    90c0:	a4 90       	lpm	r10, Z+
    90c2:	01 50       	subi	r16, 0x01	; 1
    90c4:	10 40       	sbci	r17, 0x00	; 0
        sprintf_P(__buff,PSTR("%d"),__value[__i]);
    90c6:	d7 01       	movw	r26, r14
    90c8:	bc 90       	ld	r11, X
    90ca:	00 d0       	rcall	.+0      	; 0x90cc <_menu_printer+0x112>
    90cc:	00 d0       	rcall	.+0      	; 0x90ce <_menu_printer+0x114>
    90ce:	00 d0       	rcall	.+0      	; 0x90d0 <_menu_printer+0x116>
    90d0:	ed b7       	in	r30, 0x3d	; 61
    90d2:	fe b7       	in	r31, 0x3e	; 62
    90d4:	31 96       	adiw	r30, 0x01	; 1
    90d6:	ad b7       	in	r26, 0x3d	; 61
    90d8:	be b7       	in	r27, 0x3e	; 62
    90da:	12 96       	adiw	r26, 0x02	; 2
    90dc:	dc 92       	st	X, r13
    90de:	ce 92       	st	-X, r12
    90e0:	11 97       	sbiw	r26, 0x01	; 1
    90e2:	33 82       	std	Z+3, r3	; 0x03
    90e4:	22 82       	std	Z+2, r2	; 0x02
    90e6:	b4 82       	std	Z+4, r11	; 0x04
    90e8:	15 82       	std	Z+5, r1	; 0x05
    90ea:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
		//_f_inttostr(__buff, __value[__i]);
		if(__i == 4) sprintf_P(__buff,PSTR("%.2d"),__value[__i]);
    90ee:	8e 2d       	mov	r24, r14
    90f0:	88 19       	sub	r24, r8
    90f2:	ed b7       	in	r30, 0x3d	; 61
    90f4:	fe b7       	in	r31, 0x3e	; 62
    90f6:	36 96       	adiw	r30, 0x06	; 6
    90f8:	0f b6       	in	r0, 0x3f	; 63
    90fa:	f8 94       	cli
    90fc:	fe bf       	out	0x3e, r31	; 62
    90fe:	0f be       	out	0x3f, r0	; 63
    9100:	ed bf       	out	0x3d, r30	; 61
    9102:	84 30       	cpi	r24, 0x04	; 4
    9104:	d1 f4       	brne	.+52     	; 0x913a <_menu_printer+0x180>
    9106:	00 d0       	rcall	.+0      	; 0x9108 <_menu_printer+0x14e>
    9108:	00 d0       	rcall	.+0      	; 0x910a <_menu_printer+0x150>
    910a:	00 d0       	rcall	.+0      	; 0x910c <_menu_printer+0x152>
    910c:	ed b7       	in	r30, 0x3d	; 61
    910e:	fe b7       	in	r31, 0x3e	; 62
    9110:	31 96       	adiw	r30, 0x01	; 1
    9112:	ad b7       	in	r26, 0x3d	; 61
    9114:	be b7       	in	r27, 0x3e	; 62
    9116:	12 96       	adiw	r26, 0x02	; 2
    9118:	dc 92       	st	X, r13
    911a:	ce 92       	st	-X, r12
    911c:	11 97       	sbiw	r26, 0x01	; 1
    911e:	53 82       	std	Z+3, r5	; 0x03
    9120:	42 82       	std	Z+2, r4	; 0x02
    9122:	b4 82       	std	Z+4, r11	; 0x04
    9124:	15 82       	std	Z+5, r1	; 0x05
    9126:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    912a:	ed b7       	in	r30, 0x3d	; 61
    912c:	fe b7       	in	r31, 0x3e	; 62
    912e:	36 96       	adiw	r30, 0x06	; 6
    9130:	0f b6       	in	r0, 0x3f	; 63
    9132:	f8 94       	cli
    9134:	fe bf       	out	0x3e, r31	; 62
    9136:	0f be       	out	0x3f, r0	; 63
    9138:	ed bf       	out	0x3d, r30	; 61
		//_f_punctuation(__buff, 0, 2, 0);
		lcd_print(__x, __y, __buff);
    913a:	87 2d       	mov	r24, r7
    913c:	6a 2d       	mov	r22, r10
    913e:	a6 01       	movw	r20, r12
    9140:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
    9144:	0e 5f       	subi	r16, 0xFE	; 254
    9146:	1f 4f       	sbci	r17, 0xFF	; 255
    9148:	08 94       	sec
    914a:	e1 1c       	adc	r14, r1
    914c:	f1 1c       	adc	r15, r1
	lcd_printf(1, 1, PSTR("1)Type:  5)Scroll:"));
	lcd_printf(2, 1, PSTR("2)Size:  6)Space :"));
	lcd_printf(3, 1, PSTR("3)Logo:  #)Save"));
	lcd_printf(4, 1, PSTR("4)Cut :  *)Exit"));

	for(__i = 0; __i < 6; __i++){
    914e:	f2 e0       	ldi	r31, 0x02	; 2
    9150:	06 3b       	cpi	r16, 0xB6	; 182
    9152:	1f 07       	cpc	r17, r31
    9154:	09 f0       	breq	.+2      	; 0x9158 <_menu_printer+0x19e>
    9156:	af cf       	rjmp	.-162    	; 0x90b6 <_menu_printer+0xfc>

		}
		if(__num >= 0x31 && __num <= 0x36){
			__lmt = pgm_read_byte(&__prntlmt[__num - 0x31]);
			__start = pgm_read_byte(&__prntstr[__num - 0x31]);
			if(__value[__num - 0x31] == __lmt)
    9158:	2e 01       	movw	r4, r28
    915a:	08 94       	sec
    915c:	41 1c       	adc	r4, r1
    915e:	51 1c       	adc	r5, r1
				__value[__num - 0x31] = __start;
			else
				__value[__num - 0x31]++;
			__x = pgm_read_byte(&__prntloc[__num - 0x31][0]);
			__y = pgm_read_byte(&__prntloc[__num - 0x31][1]);
			sprintf_P(__buff,PSTR("%d"),__value[__num - 0x31]);
    9160:	37 e0       	ldi	r19, 0x07	; 7
    9162:	e3 2e       	mov	r14, r19
    9164:	f1 2c       	mov	r15, r1
    9166:	ec 0e       	add	r14, r28
    9168:	fd 1e       	adc	r15, r29
    916a:	26 e6       	ldi	r18, 0x66	; 102
    916c:	62 2e       	mov	r6, r18
    916e:	2b e0       	ldi	r18, 0x0B	; 11
    9170:	72 2e       	mov	r7, r18
			//_f_inttostr(__buff, __value[__num - 0x31]);
			if((__num == 0x35)||(__num == 0x36))
			   sprintf_P(__buff,PSTR("%.2d"),__value[__num - 0x31]);
    9172:	91 e6       	ldi	r25, 0x61	; 97
    9174:	29 2e       	mov	r2, r25
    9176:	9b e0       	ldi	r25, 0x0B	; 11
    9178:	39 2e       	mov	r3, r25
		__key = _key_scan(1);
		__num = _key_btn(__key);
		if(__key == _KEY_CANCEL)
			return;
		if(__key==_KEY_ENTER){
			eeprom_write_byte(&DefPrinterType, __value[0]);
    917a:	89 80       	ldd	r8, Y+1	; 0x01
			eeprom_write_byte(&DefPrintSize, __value[1]);
    917c:	9a 80       	ldd	r9, Y+2	; 0x02
			eeprom_write_byte(&DefPrintLogo, __value[2]);
    917e:	ab 80       	ldd	r10, Y+3	; 0x03
			eeprom_write_byte(&DefPrintAutoCut, __value[3]);
    9180:	bc 80       	ldd	r11, Y+4	; 0x04
			eeprom_write_byte(&DefPrintScrollEnd, __value[4]);
    9182:	cd 80       	ldd	r12, Y+5	; 0x05
			eeprom_write_byte(&DefPrintScrollSpace, __value[5]);
    9184:	de 80       	ldd	r13, Y+6	; 0x06
	}
    //sprintf_P(lcdteks,PSTR("6)Space :%.2d"),__value[5]);
	//lcd_print(2,10,lcdteks);

	while(1){	
		__key = _key_scan(1);
    9186:	81 e0       	ldi	r24, 0x01	; 1
    9188:	0e 94 84 ae 	call	0x15d08	; 0x15d08 <_key_scan>
    918c:	18 2f       	mov	r17, r24
		__num = _key_btn(__key);
    918e:	0e 94 e5 ad 	call	0x15bca	; 0x15bca <_key_btn>
    9192:	08 2f       	mov	r16, r24
		if(__key == _KEY_CANCEL)
    9194:	17 3e       	cpi	r17, 0xE7	; 231
    9196:	09 f4       	brne	.+2      	; 0x919a <_menu_printer+0x1e0>
    9198:	b1 c0       	rjmp	.+354    	; 0x92fc <_menu_printer+0x342>
			return;
		if(__key==_KEY_ENTER){
    919a:	17 3b       	cpi	r17, 0xB7	; 183
    919c:	09 f0       	breq	.+2      	; 0x91a0 <_menu_printer+0x1e6>
    919e:	48 c0       	rjmp	.+144    	; 0x9230 <_menu_printer+0x276>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    91a0:	e1 99       	sbic	0x1c, 1	; 28
    91a2:	fe cf       	rjmp	.-4      	; 0x91a0 <_menu_printer+0x1e6>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    91a4:	20 e3       	ldi	r18, 0x30	; 48
    91a6:	30 e0       	ldi	r19, 0x00	; 0
    91a8:	3f bb       	out	0x1f, r19	; 31
    91aa:	2e bb       	out	0x1e, r18	; 30
#endif
    EEDR = __value;
    91ac:	8d ba       	out	0x1d, r8	; 29

    __asm__ __volatile__ (
    91ae:	0f b6       	in	r0, 0x3f	; 63
    91b0:	f8 94       	cli
    91b2:	e2 9a       	sbi	0x1c, 2	; 28
    91b4:	e1 9a       	sbi	0x1c, 1	; 28
    91b6:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    91b8:	e1 99       	sbic	0x1c, 1	; 28
    91ba:	fe cf       	rjmp	.-4      	; 0x91b8 <_menu_printer+0x1fe>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    91bc:	65 e3       	ldi	r22, 0x35	; 53
    91be:	70 e0       	ldi	r23, 0x00	; 0
    91c0:	7f bb       	out	0x1f, r23	; 31
    91c2:	6e bb       	out	0x1e, r22	; 30
#endif
    EEDR = __value;
    91c4:	9d ba       	out	0x1d, r9	; 29

    __asm__ __volatile__ (
    91c6:	0f b6       	in	r0, 0x3f	; 63
    91c8:	f8 94       	cli
    91ca:	e2 9a       	sbi	0x1c, 2	; 28
    91cc:	e1 9a       	sbi	0x1c, 1	; 28
    91ce:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    91d0:	e1 99       	sbic	0x1c, 1	; 28
    91d2:	fe cf       	rjmp	.-4      	; 0x91d0 <_menu_printer+0x216>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    91d4:	84 e3       	ldi	r24, 0x34	; 52
    91d6:	90 e0       	ldi	r25, 0x00	; 0
    91d8:	9f bb       	out	0x1f, r25	; 31
    91da:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    91dc:	ad ba       	out	0x1d, r10	; 29

    __asm__ __volatile__ (
    91de:	0f b6       	in	r0, 0x3f	; 63
    91e0:	f8 94       	cli
    91e2:	e2 9a       	sbi	0x1c, 2	; 28
    91e4:	e1 9a       	sbi	0x1c, 1	; 28
    91e6:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    91e8:	e1 99       	sbic	0x1c, 1	; 28
    91ea:	fe cf       	rjmp	.-4      	; 0x91e8 <_menu_printer+0x22e>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    91ec:	a3 e3       	ldi	r26, 0x33	; 51
    91ee:	b0 e0       	ldi	r27, 0x00	; 0
    91f0:	bf bb       	out	0x1f, r27	; 31
    91f2:	ae bb       	out	0x1e, r26	; 30
#endif
    EEDR = __value;
    91f4:	bd ba       	out	0x1d, r11	; 29

    __asm__ __volatile__ (
    91f6:	0f b6       	in	r0, 0x3f	; 63
    91f8:	f8 94       	cli
    91fa:	e2 9a       	sbi	0x1c, 2	; 28
    91fc:	e1 9a       	sbi	0x1c, 1	; 28
    91fe:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    9200:	e1 99       	sbic	0x1c, 1	; 28
    9202:	fe cf       	rjmp	.-4      	; 0x9200 <_menu_printer+0x246>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    9204:	e1 e3       	ldi	r30, 0x31	; 49
    9206:	f0 e0       	ldi	r31, 0x00	; 0
    9208:	ff bb       	out	0x1f, r31	; 31
    920a:	ee bb       	out	0x1e, r30	; 30
#endif
    EEDR = __value;
    920c:	cd ba       	out	0x1d, r12	; 29

    __asm__ __volatile__ (
    920e:	0f b6       	in	r0, 0x3f	; 63
    9210:	f8 94       	cli
    9212:	e2 9a       	sbi	0x1c, 2	; 28
    9214:	e1 9a       	sbi	0x1c, 1	; 28
    9216:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    9218:	e1 99       	sbic	0x1c, 1	; 28
    921a:	fe cf       	rjmp	.-4      	; 0x9218 <_menu_printer+0x25e>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    921c:	22 e3       	ldi	r18, 0x32	; 50
    921e:	30 e0       	ldi	r19, 0x00	; 0
    9220:	3f bb       	out	0x1f, r19	; 31
    9222:	2e bb       	out	0x1e, r18	; 30
#endif
    EEDR = __value;
    9224:	dd ba       	out	0x1d, r13	; 29

    __asm__ __volatile__ (
    9226:	0f b6       	in	r0, 0x3f	; 63
    9228:	f8 94       	cli
    922a:	e2 9a       	sbi	0x1c, 2	; 28
    922c:	e1 9a       	sbi	0x1c, 1	; 28
    922e:	0f be       	out	0x3f, r0	; 63
			eeprom_write_byte(&DefPrintAutoCut, __value[3]);
			eeprom_write_byte(&DefPrintScrollEnd, __value[4]);
			eeprom_write_byte(&DefPrintScrollSpace, __value[5]);

		}
		if(__num >= 0x31 && __num <= 0x36){
    9230:	80 2f       	mov	r24, r16
    9232:	81 53       	subi	r24, 0x31	; 49
    9234:	86 30       	cpi	r24, 0x06	; 6
    9236:	08 f0       	brcs	.+2      	; 0x923a <_menu_printer+0x280>
    9238:	a6 cf       	rjmp	.-180    	; 0x9186 <_menu_printer+0x1cc>
			__lmt = pgm_read_byte(&__prntlmt[__num - 0x31]);
    923a:	a0 2f       	mov	r26, r16
    923c:	b0 e0       	ldi	r27, 0x00	; 0
    923e:	d1 97       	sbiw	r26, 0x31	; 49
    9240:	fd 01       	movw	r30, r26
    9242:	ea 54       	subi	r30, 0x4A	; 74
    9244:	fd 4f       	sbci	r31, 0xFD	; 253
    9246:	24 91       	lpm	r18, Z+
			__start = pgm_read_byte(&__prntstr[__num - 0x31]);
    9248:	fd 01       	movw	r30, r26
    924a:	e4 54       	subi	r30, 0x44	; 68
    924c:	fd 4f       	sbci	r31, 0xFD	; 253
    924e:	94 91       	lpm	r25, Z+
			if(__value[__num - 0x31] == __lmt)
    9250:	f2 01       	movw	r30, r4
    9252:	ea 0f       	add	r30, r26
    9254:	fb 1f       	adc	r31, r27
    9256:	80 81       	ld	r24, Z
    9258:	82 17       	cp	r24, r18
    925a:	11 f4       	brne	.+4      	; 0x9260 <_menu_printer+0x2a6>
				__value[__num - 0x31] = __start;
    925c:	90 83       	st	Z, r25
    925e:	02 c0       	rjmp	.+4      	; 0x9264 <_menu_printer+0x2aa>
			else
				__value[__num - 0x31]++;
    9260:	8f 5f       	subi	r24, 0xFF	; 255
    9262:	80 83       	st	Z, r24
			__x = pgm_read_byte(&__prntloc[__num - 0x31][0]);
    9264:	9d 01       	movw	r18, r26
    9266:	22 0f       	add	r18, r18
    9268:	33 1f       	adc	r19, r19
    926a:	c9 01       	movw	r24, r18
    926c:	86 55       	subi	r24, 0x56	; 86
    926e:	9d 4f       	sbci	r25, 0xFD	; 253
    9270:	fc 01       	movw	r30, r24
    9272:	c4 90       	lpm	r12, Z+
			__y = pgm_read_byte(&__prntloc[__num - 0x31][1]);
    9274:	25 55       	subi	r18, 0x55	; 85
    9276:	3d 4f       	sbci	r19, 0xFD	; 253
    9278:	f9 01       	movw	r30, r18
    927a:	d4 90       	lpm	r13, Z+
			sprintf_P(__buff,PSTR("%d"),__value[__num - 0x31]);
    927c:	a4 0d       	add	r26, r4
    927e:	b5 1d       	adc	r27, r5
    9280:	1c 91       	ld	r17, X
    9282:	00 d0       	rcall	.+0      	; 0x9284 <_menu_printer+0x2ca>
    9284:	00 d0       	rcall	.+0      	; 0x9286 <_menu_printer+0x2cc>
    9286:	00 d0       	rcall	.+0      	; 0x9288 <_menu_printer+0x2ce>
    9288:	ed b7       	in	r30, 0x3d	; 61
    928a:	fe b7       	in	r31, 0x3e	; 62
    928c:	31 96       	adiw	r30, 0x01	; 1
    928e:	ad b7       	in	r26, 0x3d	; 61
    9290:	be b7       	in	r27, 0x3e	; 62
    9292:	12 96       	adiw	r26, 0x02	; 2
    9294:	fc 92       	st	X, r15
    9296:	ee 92       	st	-X, r14
    9298:	11 97       	sbiw	r26, 0x01	; 1
    929a:	73 82       	std	Z+3, r7	; 0x03
    929c:	62 82       	std	Z+2, r6	; 0x02
    929e:	14 83       	std	Z+4, r17	; 0x04
    92a0:	15 82       	std	Z+5, r1	; 0x05
    92a2:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
			//_f_inttostr(__buff, __value[__num - 0x31]);
			if((__num == 0x35)||(__num == 0x36))
    92a6:	05 53       	subi	r16, 0x35	; 53
    92a8:	ed b7       	in	r30, 0x3d	; 61
    92aa:	fe b7       	in	r31, 0x3e	; 62
    92ac:	36 96       	adiw	r30, 0x06	; 6
    92ae:	0f b6       	in	r0, 0x3f	; 63
    92b0:	f8 94       	cli
    92b2:	fe bf       	out	0x3e, r31	; 62
    92b4:	0f be       	out	0x3f, r0	; 63
    92b6:	ed bf       	out	0x3d, r30	; 61
    92b8:	02 30       	cpi	r16, 0x02	; 2
    92ba:	d0 f4       	brcc	.+52     	; 0x92f0 <_menu_printer+0x336>
			   sprintf_P(__buff,PSTR("%.2d"),__value[__num - 0x31]);
    92bc:	00 d0       	rcall	.+0      	; 0x92be <_menu_printer+0x304>
    92be:	00 d0       	rcall	.+0      	; 0x92c0 <_menu_printer+0x306>
    92c0:	00 d0       	rcall	.+0      	; 0x92c2 <_menu_printer+0x308>
    92c2:	ed b7       	in	r30, 0x3d	; 61
    92c4:	fe b7       	in	r31, 0x3e	; 62
    92c6:	31 96       	adiw	r30, 0x01	; 1
    92c8:	ad b7       	in	r26, 0x3d	; 61
    92ca:	be b7       	in	r27, 0x3e	; 62
    92cc:	12 96       	adiw	r26, 0x02	; 2
    92ce:	fc 92       	st	X, r15
    92d0:	ee 92       	st	-X, r14
    92d2:	11 97       	sbiw	r26, 0x01	; 1
    92d4:	33 82       	std	Z+3, r3	; 0x03
    92d6:	22 82       	std	Z+2, r2	; 0x02
    92d8:	14 83       	std	Z+4, r17	; 0x04
    92da:	15 82       	std	Z+5, r1	; 0x05
    92dc:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    92e0:	ed b7       	in	r30, 0x3d	; 61
    92e2:	fe b7       	in	r31, 0x3e	; 62
    92e4:	36 96       	adiw	r30, 0x06	; 6
    92e6:	0f b6       	in	r0, 0x3f	; 63
    92e8:	f8 94       	cli
    92ea:	fe bf       	out	0x3e, r31	; 62
    92ec:	0f be       	out	0x3f, r0	; 63
    92ee:	ed bf       	out	0x3d, r30	; 61
				//_f_punctuation(__buff, 0, 2, 0);

			lcd_print(__x, __y, __buff);
    92f0:	8c 2d       	mov	r24, r12
    92f2:	6d 2d       	mov	r22, r13
    92f4:	a7 01       	movw	r20, r14
    92f6:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
    92fa:	3f cf       	rjmp	.-386    	; 0x917a <_menu_printer+0x1c0>
		}
	}
}
    92fc:	2c 96       	adiw	r28, 0x0c	; 12
    92fe:	0f b6       	in	r0, 0x3f	; 63
    9300:	f8 94       	cli
    9302:	de bf       	out	0x3e, r29	; 62
    9304:	0f be       	out	0x3f, r0	; 63
    9306:	cd bf       	out	0x3d, r28	; 61
    9308:	cf 91       	pop	r28
    930a:	df 91       	pop	r29
    930c:	1f 91       	pop	r17
    930e:	0f 91       	pop	r16
    9310:	ff 90       	pop	r15
    9312:	ef 90       	pop	r14
    9314:	df 90       	pop	r13
    9316:	cf 90       	pop	r12
    9318:	bf 90       	pop	r11
    931a:	af 90       	pop	r10
    931c:	9f 90       	pop	r9
    931e:	8f 90       	pop	r8
    9320:	7f 90       	pop	r7
    9322:	6f 90       	pop	r6
    9324:	5f 90       	pop	r5
    9326:	4f 90       	pop	r4
    9328:	3f 90       	pop	r3
    932a:	2f 90       	pop	r2
    932c:	08 95       	ret

0000932e <FSettingPrinter>:
char FSettingDatetime(){
     _menu_datetime();
     return MENU_DONE;
}
char FSettingPrinter(){
     _menu_printer();
    932e:	0e 94 dd 47 	call	0x8fba	; 0x8fba <_menu_printer>
	 return MENU_DONE;
}
    9332:	81 e0       	ldi	r24, 0x01	; 1
    9334:	08 95       	ret

00009336 <_menu_pumpprodinput>:
//**********************************************************************
// subrutin merubah produk
// parameter di simpan di __pump_prod
//**********************************************************************

void _menu_pumpprodinput(unsigned char __select){
    9336:	6f 92       	push	r6
    9338:	7f 92       	push	r7
    933a:	8f 92       	push	r8
    933c:	9f 92       	push	r9
    933e:	af 92       	push	r10
    9340:	bf 92       	push	r11
    9342:	cf 92       	push	r12
    9344:	df 92       	push	r13
    9346:	ef 92       	push	r14
    9348:	ff 92       	push	r15
    934a:	0f 93       	push	r16
    934c:	1f 93       	push	r17
    934e:	df 93       	push	r29
    9350:	cf 93       	push	r28
    9352:	cd b7       	in	r28, 0x3d	; 61
    9354:	de b7       	in	r29, 0x3e	; 62
    9356:	a7 97       	sbiw	r28, 0x27	; 39
    9358:	0f b6       	in	r0, 0x3f	; 63
    935a:	f8 94       	cli
    935c:	de bf       	out	0x3e, r29	; 62
    935e:	0f be       	out	0x3f, r0	; 63
    9360:	cd bf       	out	0x3d, r28	; 61
    9362:	b8 2e       	mov	r11, r24
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    9364:	8e 01       	movw	r16, r28
    9366:	04 5f       	subi	r16, 0xF4	; 244
    9368:	1f 4f       	sbci	r17, 0xFF	; 255
    936a:	c8 01       	movw	r24, r16
    936c:	65 e4       	ldi	r22, 0x45	; 69
    936e:	70 e0       	ldi	r23, 0x00	; 0
    9370:	48 e0       	ldi	r20, 0x08	; 8
    9372:	50 e0       	ldi	r21, 0x00	; 0
    9374:	2d ef       	ldi	r18, 0xFD	; 253
    9376:	32 e1       	ldi	r19, 0x12	; 18
    9378:	0e 94 f1 b3 	call	0x167e2	; 0x167e2 <__eerd_block>
	char 			__pump_prod[6],__pump_id[8];
	unsigned char	__i, __x, __y, __key, __num, __buff[5];
	char lcdteks[20];

	eeprom_read_block((void*) &__pump_id, (const void*) &DefPumpMap, 8);
	eeprom_read_block((void*) &__pump_prod, (const void*) &DefNozzleMap[__select], 6);
    937c:	86 e0       	ldi	r24, 0x06	; 6
    937e:	b8 9e       	mul	r11, r24
    9380:	40 01       	movw	r8, r0
    9382:	11 24       	eor	r1, r1
    9384:	85 e5       	ldi	r24, 0x55	; 85
    9386:	90 e0       	ldi	r25, 0x00	; 0
    9388:	88 0e       	add	r8, r24
    938a:	99 1e       	adc	r9, r25
    938c:	96 e0       	ldi	r25, 0x06	; 6
    938e:	c9 2e       	mov	r12, r25
    9390:	d1 2c       	mov	r13, r1
    9392:	cc 0e       	add	r12, r28
    9394:	dd 1e       	adc	r13, r29
    9396:	c6 01       	movw	r24, r12
    9398:	b4 01       	movw	r22, r8
    939a:	46 e0       	ldi	r20, 0x06	; 6
    939c:	50 e0       	ldi	r21, 0x00	; 0
    939e:	2d ef       	ldi	r18, 0xFD	; 253
    93a0:	32 e1       	ldi	r19, 0x12	; 18
    93a2:	0e 94 f1 b3 	call	0x167e2	; 0x167e2 <__eerd_block>

	lcd_clear();_delay_ms(10);
    93a6:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
    93aa:	84 ec       	ldi	r24, 0xC4	; 196
    93ac:	99 e0       	ldi	r25, 0x09	; 9
    93ae:	01 97       	sbiw	r24, 0x01	; 1
    93b0:	f1 f7       	brne	.-4      	; 0x93ae <_menu_pumpprodinput+0x78>
    sprintf_P(lcdteks, PSTR("Product FIP%.2d"),__pump_id[__select]);
    93b2:	00 d0       	rcall	.+0      	; 0x93b4 <_menu_pumpprodinput+0x7e>
    93b4:	00 d0       	rcall	.+0      	; 0x93b6 <_menu_pumpprodinput+0x80>
    93b6:	00 d0       	rcall	.+0      	; 0x93b8 <_menu_pumpprodinput+0x82>
    93b8:	ed b7       	in	r30, 0x3d	; 61
    93ba:	fe b7       	in	r31, 0x3e	; 62
    93bc:	31 96       	adiw	r30, 0x01	; 1
    93be:	84 e1       	ldi	r24, 0x14	; 20
    93c0:	e8 2e       	mov	r14, r24
    93c2:	f1 2c       	mov	r15, r1
    93c4:	ec 0e       	add	r14, r28
    93c6:	fd 1e       	adc	r15, r29
    93c8:	ad b7       	in	r26, 0x3d	; 61
    93ca:	be b7       	in	r27, 0x3e	; 62
    93cc:	12 96       	adiw	r26, 0x02	; 2
    93ce:	fc 92       	st	X, r15
    93d0:	ee 92       	st	-X, r14
    93d2:	11 97       	sbiw	r26, 0x01	; 1
    93d4:	8f e1       	ldi	r24, 0x1F	; 31
    93d6:	9c e0       	ldi	r25, 0x0C	; 12
    93d8:	93 83       	std	Z+3, r25	; 0x03
    93da:	82 83       	std	Z+2, r24	; 0x02
    93dc:	0b 0d       	add	r16, r11
    93de:	11 1d       	adc	r17, r1
    93e0:	d8 01       	movw	r26, r16
    93e2:	8c 91       	ld	r24, X
    93e4:	84 83       	std	Z+4, r24	; 0x04
    93e6:	15 82       	std	Z+5, r1	; 0x05
    93e8:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    lcd_print(1, 1,lcdteks);
    93ec:	ed b7       	in	r30, 0x3d	; 61
    93ee:	fe b7       	in	r31, 0x3e	; 62
    93f0:	36 96       	adiw	r30, 0x06	; 6
    93f2:	0f b6       	in	r0, 0x3f	; 63
    93f4:	f8 94       	cli
    93f6:	fe bf       	out	0x3e, r31	; 62
    93f8:	0f be       	out	0x3f, r0	; 63
    93fa:	ed bf       	out	0x3d, r30	; 61
    93fc:	81 e0       	ldi	r24, 0x01	; 1
    93fe:	61 e0       	ldi	r22, 0x01	; 1
    9400:	a7 01       	movw	r20, r14
    9402:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>

	lcd_printf(2, 1, PSTR("1)N1:  3)N3:  5)N5:"));
    9406:	82 e0       	ldi	r24, 0x02	; 2
    9408:	61 e0       	ldi	r22, 0x01	; 1
    940a:	4b e0       	ldi	r20, 0x0B	; 11
    940c:	5c e0       	ldi	r21, 0x0C	; 12
    940e:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
	lcd_printf(3, 1, PSTR("2)N2:  4)N4:  6)N6:"));
    9412:	83 e0       	ldi	r24, 0x03	; 3
    9414:	61 e0       	ldi	r22, 0x01	; 1
    9416:	47 ef       	ldi	r20, 0xF7	; 247
    9418:	5b e0       	ldi	r21, 0x0B	; 11
    941a:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
	lcd_printf(4, 1, PSTR("*)Exit        #)Save"));
    941e:	84 e0       	ldi	r24, 0x04	; 4
    9420:	61 e0       	ldi	r22, 0x01	; 1
    9422:	42 ee       	ldi	r20, 0xE2	; 226
    9424:	5b e0       	ldi	r21, 0x0B	; 11
    9426:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
    942a:	be e9       	ldi	r27, 0x9E	; 158
    942c:	eb 2e       	mov	r14, r27
    942e:	b2 e0       	ldi	r27, 0x02	; 2
    9430:	fb 2e       	mov	r15, r27

	for(__i = 0; __i < 6; __i++){
		__x = pgm_read_byte(&__prodloc[__i][0]);
		__y = pgm_read_byte(&__prodloc[__i][1]);
        sprintf_P(__buff,PSTR("%d"),__pump_prod[__i]);
    9432:	5e 01       	movw	r10, r28
    9434:	08 94       	sec
    9436:	a1 1c       	adc	r10, r1
    9438:	b1 1c       	adc	r11, r1
    943a:	af ed       	ldi	r26, 0xDF	; 223
    943c:	6a 2e       	mov	r6, r26
    943e:	ab e0       	ldi	r26, 0x0B	; 11
    9440:	7a 2e       	mov	r7, r26
	lcd_printf(2, 1, PSTR("1)N1:  3)N3:  5)N5:"));
	lcd_printf(3, 1, PSTR("2)N2:  4)N4:  6)N6:"));
	lcd_printf(4, 1, PSTR("*)Exit        #)Save"));

	for(__i = 0; __i < 6; __i++){
		__x = pgm_read_byte(&__prodloc[__i][0]);
    9442:	f7 01       	movw	r30, r14
    9444:	04 91       	lpm	r16, Z+
		__y = pgm_read_byte(&__prodloc[__i][1]);
    9446:	08 94       	sec
    9448:	e1 1c       	adc	r14, r1
    944a:	f1 1c       	adc	r15, r1
    944c:	f7 01       	movw	r30, r14
    944e:	14 91       	lpm	r17, Z+
        sprintf_P(__buff,PSTR("%d"),__pump_prod[__i]);
    9450:	00 d0       	rcall	.+0      	; 0x9452 <_menu_pumpprodinput+0x11c>
    9452:	00 d0       	rcall	.+0      	; 0x9454 <_menu_pumpprodinput+0x11e>
    9454:	00 d0       	rcall	.+0      	; 0x9456 <_menu_pumpprodinput+0x120>
    9456:	ed b7       	in	r30, 0x3d	; 61
    9458:	fe b7       	in	r31, 0x3e	; 62
    945a:	31 96       	adiw	r30, 0x01	; 1
    945c:	ad b7       	in	r26, 0x3d	; 61
    945e:	be b7       	in	r27, 0x3e	; 62
    9460:	12 96       	adiw	r26, 0x02	; 2
    9462:	bc 92       	st	X, r11
    9464:	ae 92       	st	-X, r10
    9466:	11 97       	sbiw	r26, 0x01	; 1
    9468:	73 82       	std	Z+3, r7	; 0x03
    946a:	62 82       	std	Z+2, r6	; 0x02
    946c:	d6 01       	movw	r26, r12
    946e:	8d 91       	ld	r24, X+
    9470:	6d 01       	movw	r12, r26
    9472:	84 83       	std	Z+4, r24	; 0x04
    9474:	15 82       	std	Z+5, r1	; 0x05
    9476:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
		//_f_inttostr(__buff, __pump_prod[__i]);
		lcd_print(__x+1, __y, __buff);
    947a:	ed b7       	in	r30, 0x3d	; 61
    947c:	fe b7       	in	r31, 0x3e	; 62
    947e:	36 96       	adiw	r30, 0x06	; 6
    9480:	0f b6       	in	r0, 0x3f	; 63
    9482:	f8 94       	cli
    9484:	fe bf       	out	0x3e, r31	; 62
    9486:	0f be       	out	0x3f, r0	; 63
    9488:	ed bf       	out	0x3d, r30	; 61
    948a:	80 2f       	mov	r24, r16
    948c:	8f 5f       	subi	r24, 0xFF	; 255
    948e:	61 2f       	mov	r22, r17
    9490:	a5 01       	movw	r20, r10
    9492:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
    9496:	08 94       	sec
    9498:	e1 1c       	adc	r14, r1
    949a:	f1 1c       	adc	r15, r1

	lcd_printf(2, 1, PSTR("1)N1:  3)N3:  5)N5:"));
	lcd_printf(3, 1, PSTR("2)N2:  4)N4:  6)N6:"));
	lcd_printf(4, 1, PSTR("*)Exit        #)Save"));

	for(__i = 0; __i < 6; __i++){
    949c:	fa ea       	ldi	r31, 0xAA	; 170
    949e:	ef 16       	cp	r14, r31
    94a0:	f2 e0       	ldi	r31, 0x02	; 2
    94a2:	ff 06       	cpc	r15, r31
    94a4:	71 f6       	brne	.-100    	; 0x9442 <_menu_pumpprodinput+0x10c>
		if(__key == _KEY_ENTER){
			eeprom_write_block((const void*) &__pump_prod, (void*) &DefNozzleMap[__select], 6);
			return;
		}
		if(__num >= '1' && __num <= '6'){
			if(__pump_prod[__num - '1'] == 6)
    94a6:	f6 e0       	ldi	r31, 0x06	; 6
    94a8:	cf 2e       	mov	r12, r31
    94aa:	d1 2c       	mov	r13, r1
    94ac:	cc 0e       	add	r12, r28
    94ae:	dd 1e       	adc	r13, r29
			else
				__pump_prod[__num - '1']++;

			__x = pgm_read_byte(&__prodloc[__num - 0x31][0]);
			__y = pgm_read_byte(&__prodloc[__num - 0x31][1]);
			sprintf_P(__buff,PSTR("%d"),__pump_prod[__num - 0x31]);
    94b0:	7e 01       	movw	r14, r28
    94b2:	08 94       	sec
    94b4:	e1 1c       	adc	r14, r1
    94b6:	f1 1c       	adc	r15, r1
    94b8:	ec ed       	ldi	r30, 0xDC	; 220
    94ba:	ae 2e       	mov	r10, r30
    94bc:	eb e0       	ldi	r30, 0x0B	; 11
    94be:	be 2e       	mov	r11, r30
		lcd_print(__x+1, __y, __buff);
	}

	while(1){
		
		__key = _key_scan(1);
    94c0:	81 e0       	ldi	r24, 0x01	; 1
    94c2:	0e 94 84 ae 	call	0x15d08	; 0x15d08 <_key_scan>
    94c6:	18 2f       	mov	r17, r24
		__num = _key_btn(__key);
    94c8:	0e 94 e5 ad 	call	0x15bca	; 0x15bca <_key_btn>
    94cc:	98 2f       	mov	r25, r24
		if(__key == _KEY_CANCEL)
    94ce:	17 3e       	cpi	r17, 0xE7	; 231
    94d0:	09 f4       	brne	.+2      	; 0x94d4 <_menu_pumpprodinput+0x19e>
    94d2:	50 c0       	rjmp	.+160    	; 0x9574 <_menu_pumpprodinput+0x23e>
			return;
		if(__key == _KEY_ENTER){
    94d4:	17 3b       	cpi	r17, 0xB7	; 183
    94d6:	59 f4       	brne	.+22     	; 0x94ee <_menu_pumpprodinput+0x1b8>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    94d8:	c4 01       	movw	r24, r8
    94da:	be 01       	movw	r22, r28
    94dc:	6a 5f       	subi	r22, 0xFA	; 250
    94de:	7f 4f       	sbci	r23, 0xFF	; 255
    94e0:	46 e0       	ldi	r20, 0x06	; 6
    94e2:	50 e0       	ldi	r21, 0x00	; 0
    94e4:	25 e0       	ldi	r18, 0x05	; 5
    94e6:	33 e1       	ldi	r19, 0x13	; 19
    94e8:	0e 94 0d b4 	call	0x1681a	; 0x1681a <__eewr_block>
    94ec:	43 c0       	rjmp	.+134    	; 0x9574 <_menu_pumpprodinput+0x23e>
			eeprom_write_block((const void*) &__pump_prod, (void*) &DefNozzleMap[__select], 6);
			return;
		}
		if(__num >= '1' && __num <= '6'){
    94ee:	81 53       	subi	r24, 0x31	; 49
    94f0:	86 30       	cpi	r24, 0x06	; 6
    94f2:	30 f7       	brcc	.-52     	; 0x94c0 <_menu_pumpprodinput+0x18a>
			if(__pump_prod[__num - '1'] == 6)
    94f4:	a9 2f       	mov	r26, r25
    94f6:	b0 e0       	ldi	r27, 0x00	; 0
    94f8:	d1 97       	sbiw	r26, 0x31	; 49
    94fa:	f6 01       	movw	r30, r12
    94fc:	ea 0f       	add	r30, r26
    94fe:	fb 1f       	adc	r31, r27
    9500:	80 81       	ld	r24, Z
    9502:	86 30       	cpi	r24, 0x06	; 6
    9504:	11 f4       	brne	.+4      	; 0x950a <_menu_pumpprodinput+0x1d4>
				__pump_prod[__num - '1'] = 0;
    9506:	10 82       	st	Z, r1
    9508:	02 c0       	rjmp	.+4      	; 0x950e <_menu_pumpprodinput+0x1d8>
			else
				__pump_prod[__num - '1']++;
    950a:	8f 5f       	subi	r24, 0xFF	; 255
    950c:	80 83       	st	Z, r24

			__x = pgm_read_byte(&__prodloc[__num - 0x31][0]);
    950e:	29 2f       	mov	r18, r25
    9510:	30 e0       	ldi	r19, 0x00	; 0
    9512:	21 53       	subi	r18, 0x31	; 49
    9514:	30 40       	sbci	r19, 0x00	; 0
    9516:	22 0f       	add	r18, r18
    9518:	33 1f       	adc	r19, r19
    951a:	c9 01       	movw	r24, r18
    951c:	82 56       	subi	r24, 0x62	; 98
    951e:	9d 4f       	sbci	r25, 0xFD	; 253
    9520:	fc 01       	movw	r30, r24
    9522:	04 91       	lpm	r16, Z+
			__y = pgm_read_byte(&__prodloc[__num - 0x31][1]);
    9524:	21 56       	subi	r18, 0x61	; 97
    9526:	3d 4f       	sbci	r19, 0xFD	; 253
    9528:	f9 01       	movw	r30, r18
    952a:	14 91       	lpm	r17, Z+
			sprintf_P(__buff,PSTR("%d"),__pump_prod[__num - 0x31]);
    952c:	00 d0       	rcall	.+0      	; 0x952e <_menu_pumpprodinput+0x1f8>
    952e:	00 d0       	rcall	.+0      	; 0x9530 <_menu_pumpprodinput+0x1fa>
    9530:	00 d0       	rcall	.+0      	; 0x9532 <_menu_pumpprodinput+0x1fc>
    9532:	2d b7       	in	r18, 0x3d	; 61
    9534:	3e b7       	in	r19, 0x3e	; 62
    9536:	2f 5f       	subi	r18, 0xFF	; 255
    9538:	3f 4f       	sbci	r19, 0xFF	; 255
    953a:	ed b7       	in	r30, 0x3d	; 61
    953c:	fe b7       	in	r31, 0x3e	; 62
    953e:	f2 82       	std	Z+2, r15	; 0x02
    9540:	e1 82       	std	Z+1, r14	; 0x01
    9542:	f9 01       	movw	r30, r18
    9544:	b3 82       	std	Z+3, r11	; 0x03
    9546:	a2 82       	std	Z+2, r10	; 0x02
    9548:	ac 0d       	add	r26, r12
    954a:	bd 1d       	adc	r27, r13
    954c:	8c 91       	ld	r24, X
    954e:	84 83       	std	Z+4, r24	; 0x04
    9550:	15 82       	std	Z+5, r1	; 0x05
    9552:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
			//_f_inttostr(__buff, __pump_prod[__num - 0x31]);
			lcd_print(__x+1, __y, __buff);
    9556:	8d b7       	in	r24, 0x3d	; 61
    9558:	9e b7       	in	r25, 0x3e	; 62
    955a:	06 96       	adiw	r24, 0x06	; 6
    955c:	0f b6       	in	r0, 0x3f	; 63
    955e:	f8 94       	cli
    9560:	9e bf       	out	0x3e, r25	; 62
    9562:	0f be       	out	0x3f, r0	; 63
    9564:	8d bf       	out	0x3d, r24	; 61
    9566:	80 2f       	mov	r24, r16
    9568:	8f 5f       	subi	r24, 0xFF	; 255
    956a:	61 2f       	mov	r22, r17
    956c:	a7 01       	movw	r20, r14
    956e:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
    9572:	a6 cf       	rjmp	.-180    	; 0x94c0 <_menu_pumpprodinput+0x18a>
		}
	}
}
    9574:	a7 96       	adiw	r28, 0x27	; 39
    9576:	0f b6       	in	r0, 0x3f	; 63
    9578:	f8 94       	cli
    957a:	de bf       	out	0x3e, r29	; 62
    957c:	0f be       	out	0x3f, r0	; 63
    957e:	cd bf       	out	0x3d, r28	; 61
    9580:	cf 91       	pop	r28
    9582:	df 91       	pop	r29
    9584:	1f 91       	pop	r17
    9586:	0f 91       	pop	r16
    9588:	ff 90       	pop	r15
    958a:	ef 90       	pop	r14
    958c:	df 90       	pop	r13
    958e:	cf 90       	pop	r12
    9590:	bf 90       	pop	r11
    9592:	af 90       	pop	r10
    9594:	9f 90       	pop	r9
    9596:	8f 90       	pop	r8
    9598:	7f 90       	pop	r7
    959a:	6f 90       	pop	r6
    959c:	08 95       	ret

0000959e <_menu_pumpprod>:
	       break;
	   }	   
	}
}

void _menu_pumpprod(void){
    959e:	cf 93       	push	r28
    95a0:	df 93       	push	r29
    95a2:	c4 ec       	ldi	r28, 0xC4	; 196
    95a4:	d9 e0       	ldi	r29, 0x09	; 9
	char __key;
	//char __pump_id[8];
	while(1){
		lcd_clear();_delay_ms(10);
    95a6:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
    95aa:	ce 01       	movw	r24, r28
    95ac:	01 97       	sbiw	r24, 0x01	; 1
    95ae:	f1 f7       	brne	.-4      	; 0x95ac <_menu_pumpprod+0xe>
		_scr_pump();
    95b0:	0e 94 a0 45 	call	0x8b40	; 0x8b40 <_scr_pump>
		while(1){
			__key = _key_scan(1);
    95b4:	81 e0       	ldi	r24, 0x01	; 1
    95b6:	0e 94 84 ae 	call	0x15d08	; 0x15d08 <_key_scan>
			if( __key == _KEY_1 || __key == _KEY_2 || __key == _KEY_3 ||
    95ba:	8e 3e       	cpi	r24, 0xEE	; 238
    95bc:	71 f0       	breq	.+28     	; 0x95da <_menu_pumpprod+0x3c>
    95be:	8e 3d       	cpi	r24, 0xDE	; 222
    95c0:	61 f0       	breq	.+24     	; 0x95da <_menu_pumpprod+0x3c>
    95c2:	8e 3b       	cpi	r24, 0xBE	; 190
    95c4:	51 f0       	breq	.+20     	; 0x95da <_menu_pumpprod+0x3c>
    95c6:	8d 3e       	cpi	r24, 0xED	; 237
    95c8:	41 f0       	breq	.+16     	; 0x95da <_menu_pumpprod+0x3c>
    95ca:	8d 3d       	cpi	r24, 0xDD	; 221
    95cc:	31 f0       	breq	.+12     	; 0x95da <_menu_pumpprod+0x3c>
    95ce:	8d 3b       	cpi	r24, 0xBD	; 189
    95d0:	21 f0       	breq	.+8      	; 0x95da <_menu_pumpprod+0x3c>
    95d2:	8b 3e       	cpi	r24, 0xEB	; 235
    95d4:	11 f0       	breq	.+4      	; 0x95da <_menu_pumpprod+0x3c>
    95d6:	8b 3d       	cpi	r24, 0xDB	; 219
    95d8:	31 f4       	brne	.+12     	; 0x95e6 <_menu_pumpprod+0x48>
				__key == _KEY_4 || __key == _KEY_5 || __key == _KEY_6 ||
				__key == _KEY_7 || __key == _KEY_8){
				_menu_pumpprodinput(_key_btn(__key) - 0x31);
    95da:	0e 94 e5 ad 	call	0x15bca	; 0x15bca <_key_btn>
    95de:	81 53       	subi	r24, 0x31	; 49
    95e0:	0e 94 9b 49 	call	0x9336	; 0x9336 <_menu_pumpprodinput>
    95e4:	e0 cf       	rjmp	.-64     	; 0x95a6 <_menu_pumpprod+0x8>
				break;
			}
			if(__key == _KEY_CANCEL)
    95e6:	87 3e       	cpi	r24, 0xE7	; 231
    95e8:	29 f7       	brne	.-54     	; 0x95b4 <_menu_pumpprod+0x16>
				return;
		}
	}
}
    95ea:	df 91       	pop	r29
    95ec:	cf 91       	pop	r28
    95ee:	08 95       	ret

000095f0 <FMenuPumpLabel>:
		       break;		         
	      }
	 }     
}

void FMenuPumpLabel(){
    95f0:	6f 92       	push	r6
    95f2:	7f 92       	push	r7
    95f4:	8f 92       	push	r8
    95f6:	9f 92       	push	r9
    95f8:	af 92       	push	r10
    95fa:	bf 92       	push	r11
    95fc:	cf 92       	push	r12
    95fe:	df 92       	push	r13
    9600:	ef 92       	push	r14
    9602:	ff 92       	push	r15
    9604:	1f 93       	push	r17
    9606:	df 93       	push	r29
    9608:	cf 93       	push	r28
    960a:	cd b7       	in	r28, 0x3d	; 61
    960c:	de b7       	in	r29, 0x3e	; 62
    960e:	2d 97       	sbiw	r28, 0x0d	; 13
    9610:	0f b6       	in	r0, 0x3f	; 63
    9612:	f8 94       	cli
    9614:	de bf       	out	0x3e, r29	; 62
    9616:	0f be       	out	0x3f, r0	; 63
    9618:	cd bf       	out	0x3d, r28	; 61
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    961a:	66 e0       	ldi	r22, 0x06	; 6
    961c:	c6 2e       	mov	r12, r22
    961e:	d1 2c       	mov	r13, r1
    9620:	cc 0e       	add	r12, r28
    9622:	dd 1e       	adc	r13, r29
    9624:	c6 01       	movw	r24, r12
    9626:	6d e4       	ldi	r22, 0x4D	; 77
    9628:	70 e0       	ldi	r23, 0x00	; 0
    962a:	48 e0       	ldi	r20, 0x08	; 8
    962c:	50 e0       	ldi	r21, 0x00	; 0
    962e:	2d ef       	ldi	r18, 0xFD	; 253
    9630:	32 e1       	ldi	r19, 0x12	; 18
    9632:	0e 94 f1 b3 	call	0x167e2	; 0x167e2 <__eerd_block>
	char PPumpLabel[8];
	unsigned char i, xPos,yPos,KeyPressed,KeyChar,strLabel[5];
	static char MaxCountId=16;

	eeprom_read_block((void*) &PPumpLabel, (const void*) &DefPumpLabel, 8);
	MaxCountId=99;
    9636:	83 e6       	ldi	r24, 0x63	; 99
    9638:	80 93 46 01 	sts	0x0146, r24
	lcd_clear();_delay_ms(10);
    963c:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
    9640:	84 ec       	ldi	r24, 0xC4	; 196
    9642:	99 e0       	ldi	r25, 0x09	; 9
    9644:	01 97       	sbiw	r24, 0x01	; 1
    9646:	f1 f7       	brne	.-4      	; 0x9644 <FMenuPumpLabel+0x54>
	lcd_printf(1, 1, PSTR("1)1:   5)5:"));
    9648:	81 e0       	ldi	r24, 0x01	; 1
    964a:	61 e0       	ldi	r22, 0x01	; 1
    964c:	4a e1       	ldi	r20, 0x1A	; 26
    964e:	5d e0       	ldi	r21, 0x0D	; 13
    9650:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
	lcd_printf(2, 1, PSTR("2)2:   6)6:"));
    9654:	82 e0       	ldi	r24, 0x02	; 2
    9656:	61 e0       	ldi	r22, 0x01	; 1
    9658:	4e e0       	ldi	r20, 0x0E	; 14
    965a:	5d e0       	ldi	r21, 0x0D	; 13
    965c:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
	lcd_printf(3, 1, PSTR("3)3:   7)7:   #)Save"));
    9660:	83 e0       	ldi	r24, 0x03	; 3
    9662:	61 e0       	ldi	r22, 0x01	; 1
    9664:	49 ef       	ldi	r20, 0xF9	; 249
    9666:	5c e0       	ldi	r21, 0x0C	; 12
    9668:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
	lcd_printf(4, 1, PSTR("4)4:   8)8:   *)Exit"));
    966c:	84 e0       	ldi	r24, 0x04	; 4
    966e:	61 e0       	ldi	r22, 0x01	; 1
    9670:	44 ee       	ldi	r20, 0xE4	; 228
    9672:	5c e0       	ldi	r21, 0x0C	; 12
    9674:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
    9678:	76 01       	movw	r14, r12

	for(i=0;i< 8;i++){
	    sprintf_P(strLabel,PSTR("%.2d"),PPumpLabel[i]);
    967a:	5e 01       	movw	r10, r28
    967c:	08 94       	sec
    967e:	a1 1c       	adc	r10, r1
    9680:	b1 1c       	adc	r11, r1
    9682:	5f ed       	ldi	r21, 0xDF	; 223
    9684:	65 2e       	mov	r6, r21
    9686:	5c e0       	ldi	r21, 0x0C	; 12
    9688:	75 2e       	mov	r7, r21
	lcd_printf(1, 1, PSTR("1)1:   5)5:"));
	lcd_printf(2, 1, PSTR("2)2:   6)6:"));
	lcd_printf(3, 1, PSTR("3)3:   7)7:   #)Save"));
	lcd_printf(4, 1, PSTR("4)4:   8)8:   *)Exit"));

	for(i=0;i< 8;i++){
    968a:	4e e0       	ldi	r20, 0x0E	; 14
    968c:	84 2e       	mov	r8, r20
    968e:	91 2c       	mov	r9, r1
    9690:	8c 0e       	add	r8, r28
    9692:	9d 1e       	adc	r9, r29
	MaxCountId=99;
	lcd_clear();_delay_ms(10);
	lcd_printf(1, 1, PSTR("1)1:   5)5:"));
	lcd_printf(2, 1, PSTR("2)2:   6)6:"));
	lcd_printf(3, 1, PSTR("3)3:   7)7:   #)Save"));
	lcd_printf(4, 1, PSTR("4)4:   8)8:   *)Exit"));
    9694:	1e 2d       	mov	r17, r14
    9696:	1c 19       	sub	r17, r12

	for(i=0;i< 8;i++){
	    sprintf_P(strLabel,PSTR("%.2d"),PPumpLabel[i]);
    9698:	00 d0       	rcall	.+0      	; 0x969a <FMenuPumpLabel+0xaa>
    969a:	00 d0       	rcall	.+0      	; 0x969c <FMenuPumpLabel+0xac>
    969c:	00 d0       	rcall	.+0      	; 0x969e <FMenuPumpLabel+0xae>
    969e:	ed b7       	in	r30, 0x3d	; 61
    96a0:	fe b7       	in	r31, 0x3e	; 62
    96a2:	31 96       	adiw	r30, 0x01	; 1
    96a4:	ad b7       	in	r26, 0x3d	; 61
    96a6:	be b7       	in	r27, 0x3e	; 62
    96a8:	12 96       	adiw	r26, 0x02	; 2
    96aa:	bc 92       	st	X, r11
    96ac:	ae 92       	st	-X, r10
    96ae:	11 97       	sbiw	r26, 0x01	; 1
    96b0:	73 82       	std	Z+3, r7	; 0x03
    96b2:	62 82       	std	Z+2, r6	; 0x02
    96b4:	d7 01       	movw	r26, r14
    96b6:	8d 91       	ld	r24, X+
    96b8:	7d 01       	movw	r14, r26
    96ba:	84 83       	std	Z+4, r24	; 0x04
    96bc:	15 82       	std	Z+5, r1	; 0x05
    96be:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
		xPos=1+(i%4);
		yPos=5+(i/4)*8;
        lcd_print(xPos,yPos,strLabel);
    96c2:	ed b7       	in	r30, 0x3d	; 61
    96c4:	fe b7       	in	r31, 0x3e	; 62
    96c6:	36 96       	adiw	r30, 0x06	; 6
    96c8:	0f b6       	in	r0, 0x3f	; 63
    96ca:	f8 94       	cli
    96cc:	fe bf       	out	0x3e, r31	; 62
    96ce:	0f be       	out	0x3f, r0	; 63
    96d0:	ed bf       	out	0x3d, r30	; 61
    96d2:	61 2f       	mov	r22, r17
    96d4:	66 95       	lsr	r22
    96d6:	66 95       	lsr	r22
    96d8:	66 0f       	add	r22, r22
    96da:	66 0f       	add	r22, r22
    96dc:	66 0f       	add	r22, r22
    96de:	6b 5f       	subi	r22, 0xFB	; 251
    96e0:	13 70       	andi	r17, 0x03	; 3
    96e2:	81 2f       	mov	r24, r17
    96e4:	8f 5f       	subi	r24, 0xFF	; 255
    96e6:	a5 01       	movw	r20, r10
    96e8:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
	lcd_printf(1, 1, PSTR("1)1:   5)5:"));
	lcd_printf(2, 1, PSTR("2)2:   6)6:"));
	lcd_printf(3, 1, PSTR("3)3:   7)7:   #)Save"));
	lcd_printf(4, 1, PSTR("4)4:   8)8:   *)Exit"));

	for(i=0;i< 8;i++){
    96ec:	e8 14       	cp	r14, r8
    96ee:	f9 04       	cpc	r15, r9
    96f0:	89 f6       	brne	.-94     	; 0x9694 <FMenuPumpLabel+0xa4>
			eeprom_write_block((const void*) &PPumpLabel, (void*) &DefPumpLabel, 8);
			break;
		}
		if ((KeyChar>='1') && (KeyChar<= '8')){
		     i=(KeyChar-'1');
			if(PPumpLabel[i] == MaxCountId)
    96f2:	36 e0       	ldi	r19, 0x06	; 6
    96f4:	c3 2e       	mov	r12, r19
    96f6:	d1 2c       	mov	r13, r1
    96f8:	cc 0e       	add	r12, r28
    96fa:	dd 1e       	adc	r13, r29
			   PPumpLabel[i] = 0;
			else
			   PPumpLabel[i]++;
            xPos=1+(i%4);
		    yPos=5+(i/4)*8;
			sprintf_P(strLabel,PSTR("%.2d"),PPumpLabel[i]);
    96fc:	7e 01       	movw	r14, r28
    96fe:	08 94       	sec
    9700:	e1 1c       	adc	r14, r1
    9702:	f1 1c       	adc	r15, r1
    9704:	2a ed       	ldi	r18, 0xDA	; 218
    9706:	a2 2e       	mov	r10, r18
    9708:	2c e0       	ldi	r18, 0x0C	; 12
    970a:	b2 2e       	mov	r11, r18
		yPos=5+(i/4)*8;
        lcd_print(xPos,yPos,strLabel);
	}

	while(1){
		KeyPressed = _key_scan(1);
    970c:	81 e0       	ldi	r24, 0x01	; 1
    970e:	0e 94 84 ae 	call	0x15d08	; 0x15d08 <_key_scan>
    9712:	18 2f       	mov	r17, r24
		KeyChar    = _key_btn(KeyPressed);
    9714:	0e 94 e5 ad 	call	0x15bca	; 0x15bca <_key_btn>
		if(KeyPressed == _KEY_CANCEL)break;
    9718:	17 3e       	cpi	r17, 0xE7	; 231
    971a:	09 f4       	brne	.+2      	; 0x971e <FMenuPumpLabel+0x12e>
    971c:	4b c0       	rjmp	.+150    	; 0x97b4 <FMenuPumpLabel+0x1c4>
		else
		if(KeyPressed == _KEY_ENTER){
    971e:	17 3b       	cpi	r17, 0xB7	; 183
    9720:	61 f4       	brne	.+24     	; 0x973a <FMenuPumpLabel+0x14a>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    9722:	8d e4       	ldi	r24, 0x4D	; 77
    9724:	90 e0       	ldi	r25, 0x00	; 0
    9726:	be 01       	movw	r22, r28
    9728:	6a 5f       	subi	r22, 0xFA	; 250
    972a:	7f 4f       	sbci	r23, 0xFF	; 255
    972c:	48 e0       	ldi	r20, 0x08	; 8
    972e:	50 e0       	ldi	r21, 0x00	; 0
    9730:	25 e0       	ldi	r18, 0x05	; 5
    9732:	33 e1       	ldi	r19, 0x13	; 19
    9734:	0e 94 0d b4 	call	0x1681a	; 0x1681a <__eewr_block>
    9738:	3d c0       	rjmp	.+122    	; 0x97b4 <FMenuPumpLabel+0x1c4>
			eeprom_write_block((const void*) &PPumpLabel, (void*) &DefPumpLabel, 8);
			break;
		}
		if ((KeyChar>='1') && (KeyChar<= '8')){
    973a:	18 2f       	mov	r17, r24
    973c:	11 53       	subi	r17, 0x31	; 49
    973e:	18 30       	cpi	r17, 0x08	; 8
    9740:	28 f7       	brcc	.-54     	; 0x970c <FMenuPumpLabel+0x11c>
		     i=(KeyChar-'1');
			if(PPumpLabel[i] == MaxCountId)
    9742:	a1 2f       	mov	r26, r17
    9744:	b0 e0       	ldi	r27, 0x00	; 0
    9746:	f6 01       	movw	r30, r12
    9748:	ea 0f       	add	r30, r26
    974a:	fb 1f       	adc	r31, r27
    974c:	90 81       	ld	r25, Z
    974e:	80 91 46 01 	lds	r24, 0x0146
    9752:	98 17       	cp	r25, r24
    9754:	11 f4       	brne	.+4      	; 0x975a <FMenuPumpLabel+0x16a>
			   PPumpLabel[i] = 0;
    9756:	10 82       	st	Z, r1
    9758:	02 c0       	rjmp	.+4      	; 0x975e <FMenuPumpLabel+0x16e>
			else
			   PPumpLabel[i]++;
    975a:	9f 5f       	subi	r25, 0xFF	; 255
    975c:	90 83       	st	Z, r25
            xPos=1+(i%4);
		    yPos=5+(i/4)*8;
			sprintf_P(strLabel,PSTR("%.2d"),PPumpLabel[i]);
    975e:	00 d0       	rcall	.+0      	; 0x9760 <FMenuPumpLabel+0x170>
    9760:	00 d0       	rcall	.+0      	; 0x9762 <FMenuPumpLabel+0x172>
    9762:	00 d0       	rcall	.+0      	; 0x9764 <FMenuPumpLabel+0x174>
    9764:	2d b7       	in	r18, 0x3d	; 61
    9766:	3e b7       	in	r19, 0x3e	; 62
    9768:	2f 5f       	subi	r18, 0xFF	; 255
    976a:	3f 4f       	sbci	r19, 0xFF	; 255
    976c:	ed b7       	in	r30, 0x3d	; 61
    976e:	fe b7       	in	r31, 0x3e	; 62
    9770:	f2 82       	std	Z+2, r15	; 0x02
    9772:	e1 82       	std	Z+1, r14	; 0x01
    9774:	f9 01       	movw	r30, r18
    9776:	b3 82       	std	Z+3, r11	; 0x03
    9778:	a2 82       	std	Z+2, r10	; 0x02
    977a:	ac 0d       	add	r26, r12
    977c:	bd 1d       	adc	r27, r13
    977e:	8c 91       	ld	r24, X
    9780:	84 83       	std	Z+4, r24	; 0x04
    9782:	15 82       	std	Z+5, r1	; 0x05
    9784:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
            lcd_print(xPos,yPos,strLabel);
    9788:	8d b7       	in	r24, 0x3d	; 61
    978a:	9e b7       	in	r25, 0x3e	; 62
    978c:	06 96       	adiw	r24, 0x06	; 6
    978e:	0f b6       	in	r0, 0x3f	; 63
    9790:	f8 94       	cli
    9792:	9e bf       	out	0x3e, r25	; 62
    9794:	0f be       	out	0x3f, r0	; 63
    9796:	8d bf       	out	0x3d, r24	; 61
    9798:	61 2f       	mov	r22, r17
    979a:	66 95       	lsr	r22
    979c:	66 95       	lsr	r22
    979e:	66 0f       	add	r22, r22
    97a0:	66 0f       	add	r22, r22
    97a2:	66 0f       	add	r22, r22
    97a4:	6b 5f       	subi	r22, 0xFB	; 251
    97a6:	13 70       	andi	r17, 0x03	; 3
    97a8:	81 2f       	mov	r24, r17
    97aa:	8f 5f       	subi	r24, 0xFF	; 255
    97ac:	a7 01       	movw	r20, r14
    97ae:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
    97b2:	ac cf       	rjmp	.-168    	; 0x970c <FMenuPumpLabel+0x11c>
		}
	}
}
    97b4:	2d 96       	adiw	r28, 0x0d	; 13
    97b6:	0f b6       	in	r0, 0x3f	; 63
    97b8:	f8 94       	cli
    97ba:	de bf       	out	0x3e, r29	; 62
    97bc:	0f be       	out	0x3f, r0	; 63
    97be:	cd bf       	out	0x3d, r28	; 61
    97c0:	cf 91       	pop	r28
    97c2:	df 91       	pop	r29
    97c4:	1f 91       	pop	r17
    97c6:	ff 90       	pop	r15
    97c8:	ef 90       	pop	r14
    97ca:	df 90       	pop	r13
    97cc:	cf 90       	pop	r12
    97ce:	bf 90       	pop	r11
    97d0:	af 90       	pop	r10
    97d2:	9f 90       	pop	r9
    97d4:	8f 90       	pop	r8
    97d6:	7f 90       	pop	r7
    97d8:	6f 90       	pop	r6
    97da:	08 95       	ret

000097dc <system_stop>:
	return Result;
}

void system_stop(){
	 char __key,__num;
	 lcd_printf(4,1,PSTR("Press any key..     "));
    97dc:	84 e0       	ldi	r24, 0x04	; 4
    97de:	61 e0       	ldi	r22, 0x01	; 1
    97e0:	49 e3       	ldi	r20, 0x39	; 57
    97e2:	52 e2       	ldi	r21, 0x22	; 34
    97e4:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    97e8:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    97ea:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    97ec:	85 e0       	ldi	r24, 0x05	; 5
    97ee:	80 93 bf 01 	sts	0x01BF, r24
void system_stop(){
	 char __key,__num;
	 lcd_printf(4,1,PSTR("Press any key..     "));
	 system_beep(5);
	 while(1){
		__key = _key_scan(1);
    97f2:	81 e0       	ldi	r24, 0x01	; 1
    97f4:	0e 94 84 ae 	call	0x15d08	; 0x15d08 <_key_scan>
		__num = _key_btn(__key);
    97f8:	0e 94 e5 ad 	call	0x15bca	; 0x15bca <_key_btn>
		if ((__num>='0')&&(__num<='9')||(IsStandAloneDetected==True)) 
    97fc:	80 53       	subi	r24, 0x30	; 48
    97fe:	8a 30       	cpi	r24, 0x0A	; 10
    9800:	20 f0       	brcs	.+8      	; 0x980a <system_stop+0x2e>
    9802:	80 91 9f 01 	lds	r24, 0x019F
    9806:	81 30       	cpi	r24, 0x01	; 1
    9808:	a1 f7       	brne	.-24     	; 0x97f2 <system_stop+0x16>
    980a:	08 95       	ret

0000980c <systemForceType>:
	 }
}

char systemForceType(){
     char Result,KeyChar;
	 lcd_printf(4,1,PSTR("[1]Slave [2]Standalone"));
    980c:	84 e0       	ldi	r24, 0x04	; 4
    980e:	61 e0       	ldi	r22, 0x01	; 1
    9810:	4e e4       	ldi	r20, 0x4E	; 78
    9812:	52 e2       	ldi	r21, 0x22	; 34
    9814:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    9818:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    981a:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    981c:	81 e0       	ldi	r24, 0x01	; 1
    981e:	80 93 bf 01 	sts	0x01BF, r24
    9822:	80 e5       	ldi	r24, 0x50	; 80
    9824:	93 ec       	ldi	r25, 0xC3	; 195
    9826:	01 97       	sbiw	r24, 0x01	; 1
    9828:	f1 f7       	brne	.-4      	; 0x9826 <systemForceType+0x1a>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    982a:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    982c:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    982e:	82 e0       	ldi	r24, 0x02	; 2
    9830:	80 93 bf 01 	sts	0x01BF, r24
	 lcd_printf(4,1,PSTR("[1]Slave [2]Standalone"));
	 system_beep(1);
	 _delay_ms(200);
	 system_beep(2);
	 while(1){
	    KeyChar=_key_btn(_key_scan(1));
    9834:	81 e0       	ldi	r24, 0x01	; 1
    9836:	0e 94 84 ae 	call	0x15d08	; 0x15d08 <_key_scan>
    983a:	0e 94 e5 ad 	call	0x15bca	; 0x15bca <_key_btn>
    983e:	98 2f       	mov	r25, r24
		if ((KeyChar=='1')||(KeyChar=='2')){
    9840:	81 53       	subi	r24, 0x31	; 49
    9842:	82 30       	cpi	r24, 0x02	; 2
    9844:	b8 f7       	brcc	.-18     	; 0x9834 <systemForceType+0x28>
		    Result=KeyChar;
			break;
		}
	 }
	return Result;
}
    9846:	89 2f       	mov	r24, r25
    9848:	08 95       	ret

0000984a <SendPrint>:
	 for(i=0;i<strlen(Source);i++){
	    Dest[i]=pgm_read_byte(&Source[i]);
	 }
}

void SendPrint(char xSend,char xSendLead){
    984a:	1f 93       	push	r17
    984c:	18 2f       	mov	r17, r24
static char zSend;     
	 if (xSend==0x19){
    984e:	89 31       	cpi	r24, 0x19	; 25
    9850:	59 f4       	brne	.+22     	; 0x9868 <SendPrint+0x1e>
	     if (zSend==xSendLead)_uart(_COM_PRINTER,1,xSendLead);
    9852:	40 91 46 02 	lds	r20, 0x0246
    9856:	46 17       	cp	r20, r22
    9858:	19 f4       	brne	.+6      	; 0x9860 <SendPrint+0x16>
    985a:	80 e0       	ldi	r24, 0x00	; 0
    985c:	61 e0       	ldi	r22, 0x01	; 1
    985e:	07 c0       	rjmp	.+14     	; 0x986e <SendPrint+0x24>
		 else _uart(_COM_PRINTER,1,' ');	 
    9860:	80 e0       	ldi	r24, 0x00	; 0
    9862:	61 e0       	ldi	r22, 0x01	; 1
    9864:	40 e2       	ldi	r20, 0x20	; 32
    9866:	03 c0       	rjmp	.+6      	; 0x986e <SendPrint+0x24>
	 } 
	 else _uart(_COM_PRINTER,1,xSend);
    9868:	80 e0       	ldi	r24, 0x00	; 0
    986a:	61 e0       	ldi	r22, 0x01	; 1
    986c:	41 2f       	mov	r20, r17
    986e:	0e 94 53 b2 	call	0x164a6	; 0x164a6 <_uart>
	 zSend=xSend;
    9872:	10 93 46 02 	sts	0x0246, r17
}
    9876:	1f 91       	pop	r17
    9878:	08 95       	ret

0000987a <CarriegeReturn>:
	      break;	 
	 }
}

void CarriegeReturn(){
     _uart(_COM_PRINTER, 1, 0x0D);     
    987a:	80 e0       	ldi	r24, 0x00	; 0
    987c:	61 e0       	ldi	r22, 0x01	; 1
    987e:	4d e0       	ldi	r20, 0x0D	; 13
    9880:	0e 94 53 b2 	call	0x164a6	; 0x164a6 <_uart>
     _uart(_COM_PRINTER, 1, 0x0A);
    9884:	80 e0       	ldi	r24, 0x00	; 0
    9886:	61 e0       	ldi	r22, 0x01	; 1
    9888:	4a e0       	ldi	r20, 0x0A	; 10
    988a:	0e 94 53 b2 	call	0x164a6	; 0x164a6 <_uart>

}
    988e:	08 95       	ret

00009890 <InitPrinter>:
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    9890:	e1 99       	sbic	0x1c, 1	; 28
    9892:	fe cf       	rjmp	.-4      	; 0x9890 <InitPrinter>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    9894:	80 e3       	ldi	r24, 0x30	; 48
    9896:	90 e0       	ldi	r25, 0x00	; 0
    9898:	9f bb       	out	0x1f, r25	; 31
    989a:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    989c:	e0 9a       	sbi	0x1c, 0	; 28
    989e:	8d b3       	in	r24, 0x1d	; 29
void InitPrinter(){
char PrinterType;
     PrinterType=eeprom_read_byte(&DefPrinterType);
    //Custom Printer TG02
	//Density Lowest: 1D 7C 00
	if (PrinterType==PT_CUSTOM_TG02){
    98a0:	81 30       	cpi	r24, 0x01	; 1
    98a2:	71 f5       	brne	.+92     	; 0x9900 <InitPrinter+0x70>
		_uart(_COM_PRINTER, 1, 0x1D);_uart(_COM_PRINTER, 1, 0x7C);_uart(_COM_PRINTER, 1, 0x00);
    98a4:	80 e0       	ldi	r24, 0x00	; 0
    98a6:	61 e0       	ldi	r22, 0x01	; 1
    98a8:	4d e1       	ldi	r20, 0x1D	; 29
    98aa:	0e 94 53 b2 	call	0x164a6	; 0x164a6 <_uart>
    98ae:	80 e0       	ldi	r24, 0x00	; 0
    98b0:	61 e0       	ldi	r22, 0x01	; 1
    98b2:	4c e7       	ldi	r20, 0x7C	; 124
    98b4:	0e 94 53 b2 	call	0x164a6	; 0x164a6 <_uart>
    98b8:	80 e0       	ldi	r24, 0x00	; 0
    98ba:	61 e0       	ldi	r22, 0x01	; 1
    98bc:	40 e0       	ldi	r20, 0x00	; 0
    98be:	0e 94 53 b2 	call	0x164a6	; 0x164a6 <_uart>
		//Double Strike ON : 1B 47 01
		_uart(_COM_PRINTER, 1, 0x1B);_uart(_COM_PRINTER, 1, 0x47);_uart(_COM_PRINTER, 1, 0x01);
    98c2:	80 e0       	ldi	r24, 0x00	; 0
    98c4:	61 e0       	ldi	r22, 0x01	; 1
    98c6:	4b e1       	ldi	r20, 0x1B	; 27
    98c8:	0e 94 53 b2 	call	0x164a6	; 0x164a6 <_uart>
    98cc:	80 e0       	ldi	r24, 0x00	; 0
    98ce:	61 e0       	ldi	r22, 0x01	; 1
    98d0:	47 e4       	ldi	r20, 0x47	; 71
    98d2:	0e 94 53 b2 	call	0x164a6	; 0x164a6 <_uart>
    98d6:	80 e0       	ldi	r24, 0x00	; 0
    98d8:	61 e0       	ldi	r22, 0x01	; 1
    98da:	41 e0       	ldi	r20, 0x01	; 1
    98dc:	0e 94 53 b2 	call	0x164a6	; 0x164a6 <_uart>
		//Font Setting: 1D 21 01
		_uart(_COM_PRINTER, 1, 0x1D);_uart(_COM_PRINTER, 1, 0x21);_uart(_COM_PRINTER, 1, 0x01);   
    98e0:	80 e0       	ldi	r24, 0x00	; 0
    98e2:	61 e0       	ldi	r22, 0x01	; 1
    98e4:	4d e1       	ldi	r20, 0x1D	; 29
    98e6:	0e 94 53 b2 	call	0x164a6	; 0x164a6 <_uart>
    98ea:	80 e0       	ldi	r24, 0x00	; 0
    98ec:	61 e0       	ldi	r22, 0x01	; 1
    98ee:	41 e2       	ldi	r20, 0x21	; 33
    98f0:	0e 94 53 b2 	call	0x164a6	; 0x164a6 <_uart>
    98f4:	80 e0       	ldi	r24, 0x00	; 0
    98f6:	61 e0       	ldi	r22, 0x01	; 1
    98f8:	41 e0       	ldi	r20, 0x01	; 1
    98fa:	0e 94 53 b2 	call	0x164a6	; 0x164a6 <_uart>
    98fe:	08 95       	ret
		}
    else
	if (PrinterType==PT_CUSTOM_CUBE){
    9900:	82 30       	cpi	r24, 0x02	; 2
    9902:	69 f5       	brne	.+90     	; 0x995e <InitPrinter+0xce>
        //Print Density 0%
		_uart(_COM_PRINTER, 1, 0x1D);_uart(_COM_PRINTER, 1, 0x7C);_uart(_COM_PRINTER, 1, 0x04);
    9904:	80 e0       	ldi	r24, 0x00	; 0
    9906:	61 e0       	ldi	r22, 0x01	; 1
    9908:	4d e1       	ldi	r20, 0x1D	; 29
    990a:	0e 94 53 b2 	call	0x164a6	; 0x164a6 <_uart>
    990e:	80 e0       	ldi	r24, 0x00	; 0
    9910:	61 e0       	ldi	r22, 0x01	; 1
    9912:	4c e7       	ldi	r20, 0x7C	; 124
    9914:	0e 94 53 b2 	call	0x164a6	; 0x164a6 <_uart>
    9918:	80 e0       	ldi	r24, 0x00	; 0
    991a:	61 e0       	ldi	r22, 0x01	; 1
    991c:	44 e0       	ldi	r20, 0x04	; 4
    991e:	0e 94 53 b2 	call	0x164a6	; 0x164a6 <_uart>
		//Double Strike OFF : 1B 47 00
		_uart(_COM_PRINTER, 1, 0x1B);_uart(_COM_PRINTER, 1, 0x47);_uart(_COM_PRINTER, 1, 0x00);
    9922:	80 e0       	ldi	r24, 0x00	; 0
    9924:	61 e0       	ldi	r22, 0x01	; 1
    9926:	4b e1       	ldi	r20, 0x1B	; 27
    9928:	0e 94 53 b2 	call	0x164a6	; 0x164a6 <_uart>
    992c:	80 e0       	ldi	r24, 0x00	; 0
    992e:	61 e0       	ldi	r22, 0x01	; 1
    9930:	47 e4       	ldi	r20, 0x47	; 71
    9932:	0e 94 53 b2 	call	0x164a6	; 0x164a6 <_uart>
    9936:	80 e0       	ldi	r24, 0x00	; 0
    9938:	61 e0       	ldi	r22, 0x01	; 1
    993a:	40 e0       	ldi	r20, 0x00	; 0
    993c:	0e 94 53 b2 	call	0x164a6	; 0x164a6 <_uart>
		//Font Setting: 1D 21 01
		_uart(_COM_PRINTER, 1, 0x1D);_uart(_COM_PRINTER, 1, 0x21);_uart(_COM_PRINTER, 1, 0x00);   
    9940:	80 e0       	ldi	r24, 0x00	; 0
    9942:	61 e0       	ldi	r22, 0x01	; 1
    9944:	4d e1       	ldi	r20, 0x1D	; 29
    9946:	0e 94 53 b2 	call	0x164a6	; 0x164a6 <_uart>
    994a:	80 e0       	ldi	r24, 0x00	; 0
    994c:	61 e0       	ldi	r22, 0x01	; 1
    994e:	41 e2       	ldi	r20, 0x21	; 33
    9950:	0e 94 53 b2 	call	0x164a6	; 0x164a6 <_uart>
    9954:	80 e0       	ldi	r24, 0x00	; 0
    9956:	61 e0       	ldi	r22, 0x01	; 1
    9958:	40 e0       	ldi	r20, 0x00	; 0
    995a:	0e 94 53 b2 	call	0x164a6	; 0x164a6 <_uart>
    995e:	08 95       	ret

00009960 <PrintNormalHeight>:
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    9960:	e1 99       	sbic	0x1c, 1	; 28
    9962:	fe cf       	rjmp	.-4      	; 0x9960 <PrintNormalHeight>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    9964:	80 e3       	ldi	r24, 0x30	; 48
    9966:	90 e0       	ldi	r25, 0x00	; 0
    9968:	9f bb       	out	0x1f, r25	; 31
    996a:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    996c:	e0 9a       	sbi	0x1c, 0	; 28
    996e:	8d b3       	in	r24, 0x1d	; 29
}

void PrintNormalHeight(){
char PrinterType;
     PrinterType=eeprom_read_byte(&DefPrinterType);
	 if (PrinterType==PT_CUSTOM_CUBE){
    9970:	82 30       	cpi	r24, 0x02	; 2
    9972:	79 f4       	brne	.+30     	; 0x9992 <PrintNormalHeight+0x32>
	     _uart(_COM_PRINTER, 1, 0x1D);_uart(_COM_PRINTER, 1, 0x21);_uart(_COM_PRINTER, 1, 0x00);
    9974:	80 e0       	ldi	r24, 0x00	; 0
    9976:	61 e0       	ldi	r22, 0x01	; 1
    9978:	4d e1       	ldi	r20, 0x1D	; 29
    997a:	0e 94 53 b2 	call	0x164a6	; 0x164a6 <_uart>
    997e:	80 e0       	ldi	r24, 0x00	; 0
    9980:	61 e0       	ldi	r22, 0x01	; 1
    9982:	41 e2       	ldi	r20, 0x21	; 33
    9984:	0e 94 53 b2 	call	0x164a6	; 0x164a6 <_uart>
    9988:	80 e0       	ldi	r24, 0x00	; 0
    998a:	61 e0       	ldi	r22, 0x01	; 1
    998c:	40 e0       	ldi	r20, 0x00	; 0
    998e:	0e 94 53 b2 	call	0x164a6	; 0x164a6 <_uart>
    9992:	08 95       	ret

00009994 <PrintDoubleHeight>:
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    9994:	e1 99       	sbic	0x1c, 1	; 28
    9996:	fe cf       	rjmp	.-4      	; 0x9994 <PrintDoubleHeight>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    9998:	80 e3       	ldi	r24, 0x30	; 48
    999a:	90 e0       	ldi	r25, 0x00	; 0
    999c:	9f bb       	out	0x1f, r25	; 31
    999e:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    99a0:	e0 9a       	sbi	0x1c, 0	; 28
    99a2:	8d b3       	in	r24, 0x1d	; 29
//void SetPrinterCharacterWidth

void PrintDoubleHeight(){
char PrinterType;
     PrinterType=eeprom_read_byte(&DefPrinterType);
	 if (PrinterType==PT_CUSTOM_CUBE){
    99a4:	82 30       	cpi	r24, 0x02	; 2
    99a6:	79 f4       	brne	.+30     	; 0x99c6 <PrintDoubleHeight+0x32>
	     _uart(_COM_PRINTER, 1, 0x1D);_uart(_COM_PRINTER, 1, 0x21);_uart(_COM_PRINTER, 1, 0x01);
    99a8:	80 e0       	ldi	r24, 0x00	; 0
    99aa:	61 e0       	ldi	r22, 0x01	; 1
    99ac:	4d e1       	ldi	r20, 0x1D	; 29
    99ae:	0e 94 53 b2 	call	0x164a6	; 0x164a6 <_uart>
    99b2:	80 e0       	ldi	r24, 0x00	; 0
    99b4:	61 e0       	ldi	r22, 0x01	; 1
    99b6:	41 e2       	ldi	r20, 0x21	; 33
    99b8:	0e 94 53 b2 	call	0x164a6	; 0x164a6 <_uart>
    99bc:	80 e0       	ldi	r24, 0x00	; 0
    99be:	61 e0       	ldi	r22, 0x01	; 1
    99c0:	41 e0       	ldi	r20, 0x01	; 1
    99c2:	0e 94 53 b2 	call	0x164a6	; 0x164a6 <_uart>
    99c6:	08 95       	ret

000099c8 <PaperCut>:

	 return Result;
}


void PaperCut(){
    99c8:	1f 93       	push	r17
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    99ca:	e1 99       	sbic	0x1c, 1	; 28
    99cc:	fe cf       	rjmp	.-4      	; 0x99ca <PaperCut+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    99ce:	83 e3       	ldi	r24, 0x33	; 51
    99d0:	90 e0       	ldi	r25, 0x00	; 0
    99d2:	9f bb       	out	0x1f, r25	; 31
    99d4:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    99d6:	e0 9a       	sbi	0x1c, 0	; 28
    99d8:	1d b3       	in	r17, 0x1d	; 29
     char CutType;
     CutType= eeprom_read_byte(&DefPrintAutoCut);
     _uart(_COM_PRINTER, 1, 0x1B);
    99da:	80 e0       	ldi	r24, 0x00	; 0
    99dc:	61 e0       	ldi	r22, 0x01	; 1
    99de:	4b e1       	ldi	r20, 0x1B	; 27
    99e0:	0e 94 53 b2 	call	0x164a6	; 0x164a6 <_uart>
	 if(CutType== 1) { _uart(_COM_PRINTER, 1, 0x6D);}
    99e4:	11 30       	cpi	r17, 0x01	; 1
    99e6:	21 f4       	brne	.+8      	; 0x99f0 <PaperCut+0x28>
    99e8:	80 e0       	ldi	r24, 0x00	; 0
    99ea:	61 e0       	ldi	r22, 0x01	; 1
    99ec:	4d e6       	ldi	r20, 0x6D	; 109
    99ee:	05 c0       	rjmp	.+10     	; 0x99fa <PaperCut+0x32>
	 if(CutType== 2) {_uart(_COM_PRINTER, 1, 0x69);}
    99f0:	12 30       	cpi	r17, 0x02	; 2
    99f2:	29 f4       	brne	.+10     	; 0x99fe <PaperCut+0x36>
    99f4:	80 e0       	ldi	r24, 0x00	; 0
    99f6:	61 e0       	ldi	r22, 0x01	; 1
    99f8:	49 e6       	ldi	r20, 0x69	; 105
    99fa:	0e 94 53 b2 	call	0x164a6	; 0x164a6 <_uart>

}
    99fe:	1f 91       	pop	r17
    9a00:	08 95       	ret

00009a02 <sendMessage98>:
		        break;
	       }//EndSwitch
return Result;
}

void sendMessage98(char PumpID){
    9a02:	ff 92       	push	r15
    9a04:	0f 93       	push	r16
    9a06:	1f 93       	push	r17
    9a08:	df 93       	push	r29
    9a0a:	cf 93       	push	r28
    9a0c:	cd b7       	in	r28, 0x3d	; 61
    9a0e:	de b7       	in	r29, 0x3e	; 62
    9a10:	ea 97       	sbiw	r28, 0x3a	; 58
    9a12:	0f b6       	in	r0, 0x3f	; 63
    9a14:	f8 94       	cli
    9a16:	de bf       	out	0x3e, r29	; 62
    9a18:	0f be       	out	0x3f, r0	; 63
    9a1a:	cd bf       	out	0x3d, r28	; 61
    9a1c:	f8 2e       	mov	r15, r24
	char __pump_id[8];
	char strSend[50];
	char xFIP_ID;
	
	_uart(1, 1,0x01);
    9a1e:	81 e0       	ldi	r24, 0x01	; 1
    9a20:	61 e0       	ldi	r22, 0x01	; 1
    9a22:	41 e0       	ldi	r20, 0x01	; 1
    9a24:	0e 94 53 b2 	call	0x164a6	; 0x164a6 <_uart>
    UpdateIFT_ID(); //ReadIFT_ID
    9a28:	0e 94 71 1b 	call	0x36e2	; 0x36e2 <UpdateIFT_ID>
	UpdateSeqNum(); //UpdateSeqNum SeqNum++
    9a2c:	0e 94 46 1b 	call	0x368c	; 0x368c <UpdateSeqNum>
	UpdateClientIP();//ReadSourceIP
    9a30:	0e 94 3b 1f 	call	0x3e76	; 0x3e76 <UpdateClientIP>
	UpdateServerIP();//ReadDestIP
    9a34:	0e 94 d3 1e 	call	0x3da6	; 0x3da6 <UpdateServerIP>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    9a38:	ce 01       	movw	r24, r28
    9a3a:	01 96       	adiw	r24, 0x01	; 1
    9a3c:	65 e4       	ldi	r22, 0x45	; 69
    9a3e:	70 e0       	ldi	r23, 0x00	; 0
    9a40:	48 e0       	ldi	r20, 0x08	; 8
    9a42:	50 e0       	ldi	r21, 0x00	; 0
    9a44:	2d ef       	ldi	r18, 0xFD	; 253
    9a46:	32 e1       	ldi	r19, 0x12	; 18
    9a48:	0e 94 f1 b3 	call	0x167e2	; 0x167e2 <__eerd_block>
	eeprom_read_block((void*) &__pump_id, (const void*) &DefPumpMap, 8);
	xFIP_ID=__pump_id[PumpID-1];
	//if (xFIP_ID>16)xFIP_ID=16;
	sprintf_P(strSend,PSTR("%s%s%s%s98%.2dF968CFFB"),strIFT_ID,strSeqNum,strClientIP,strServerIP,xFIP_ID);
    9a4c:	8d b7       	in	r24, 0x3d	; 61
    9a4e:	9e b7       	in	r25, 0x3e	; 62
    9a50:	0e 97       	sbiw	r24, 0x0e	; 14
    9a52:	0f b6       	in	r0, 0x3f	; 63
    9a54:	f8 94       	cli
    9a56:	9e bf       	out	0x3e, r25	; 62
    9a58:	0f be       	out	0x3f, r0	; 63
    9a5a:	8d bf       	out	0x3d, r24	; 61
    9a5c:	ad b7       	in	r26, 0x3d	; 61
    9a5e:	be b7       	in	r27, 0x3e	; 62
    9a60:	11 96       	adiw	r26, 0x01	; 1
    9a62:	8e 01       	movw	r16, r28
    9a64:	07 5f       	subi	r16, 0xF7	; 247
    9a66:	1f 4f       	sbci	r17, 0xFF	; 255
    9a68:	ed b7       	in	r30, 0x3d	; 61
    9a6a:	fe b7       	in	r31, 0x3e	; 62
    9a6c:	12 83       	std	Z+2, r17	; 0x02
    9a6e:	01 83       	std	Z+1, r16	; 0x01
    9a70:	8e e7       	ldi	r24, 0x7E	; 126
    9a72:	9d e1       	ldi	r25, 0x1D	; 29
    9a74:	13 96       	adiw	r26, 0x03	; 3
    9a76:	9c 93       	st	X, r25
    9a78:	8e 93       	st	-X, r24
    9a7a:	12 97       	sbiw	r26, 0x02	; 2
    9a7c:	8b ef       	ldi	r24, 0xFB	; 251
    9a7e:	94 e0       	ldi	r25, 0x04	; 4
    9a80:	15 96       	adiw	r26, 0x05	; 5
    9a82:	9c 93       	st	X, r25
    9a84:	8e 93       	st	-X, r24
    9a86:	14 97       	sbiw	r26, 0x04	; 4
    9a88:	87 e0       	ldi	r24, 0x07	; 7
    9a8a:	9d e0       	ldi	r25, 0x0D	; 13
    9a8c:	17 96       	adiw	r26, 0x07	; 7
    9a8e:	9c 93       	st	X, r25
    9a90:	8e 93       	st	-X, r24
    9a92:	16 97       	sbiw	r26, 0x06	; 6
    9a94:	8d ee       	ldi	r24, 0xED	; 237
    9a96:	98 e0       	ldi	r25, 0x08	; 8
    9a98:	19 96       	adiw	r26, 0x09	; 9
    9a9a:	9c 93       	st	X, r25
    9a9c:	8e 93       	st	-X, r24
    9a9e:	18 97       	sbiw	r26, 0x08	; 8
    9aa0:	8a e1       	ldi	r24, 0x1A	; 26
    9aa2:	99 e0       	ldi	r25, 0x09	; 9
    9aa4:	1b 96       	adiw	r26, 0x0b	; 11
    9aa6:	9c 93       	st	X, r25
    9aa8:	8e 93       	st	-X, r24
    9aaa:	1a 97       	sbiw	r26, 0x0a	; 10
    9aac:	fe 01       	movw	r30, r28
    9aae:	ef 0d       	add	r30, r15
    9ab0:	f1 1d       	adc	r31, r1
    9ab2:	80 81       	ld	r24, Z
    9ab4:	1c 96       	adiw	r26, 0x0c	; 12
    9ab6:	8c 93       	st	X, r24
    9ab8:	1c 97       	sbiw	r26, 0x0c	; 12
    9aba:	1d 96       	adiw	r26, 0x0d	; 13
    9abc:	1c 92       	st	X, r1
    9abe:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
	_uart_print(1, 0,strSend);
    9ac2:	8d b7       	in	r24, 0x3d	; 61
    9ac4:	9e b7       	in	r25, 0x3e	; 62
    9ac6:	0e 96       	adiw	r24, 0x0e	; 14
    9ac8:	0f b6       	in	r0, 0x3f	; 63
    9aca:	f8 94       	cli
    9acc:	9e bf       	out	0x3e, r25	; 62
    9ace:	0f be       	out	0x3f, r0	; 63
    9ad0:	8d bf       	out	0x3d, r24	; 61
    9ad2:	81 e0       	ldi	r24, 0x01	; 1
    9ad4:	60 e0       	ldi	r22, 0x00	; 0
    9ad6:	a8 01       	movw	r20, r16
    9ad8:	0e 94 70 b2 	call	0x164e0	; 0x164e0 <_uart_print>
	_uart(1, 1,0x02);
    9adc:	81 e0       	ldi	r24, 0x01	; 1
    9ade:	61 e0       	ldi	r22, 0x01	; 1
    9ae0:	42 e0       	ldi	r20, 0x02	; 2
    9ae2:	0e 94 53 b2 	call	0x164a6	; 0x164a6 <_uart>
	IsBusyMsg11=True;
    9ae6:	81 e0       	ldi	r24, 0x01	; 1
    9ae8:	80 93 b0 01 	sts	0x01B0, r24
}
    9aec:	ea 96       	adiw	r28, 0x3a	; 58
    9aee:	0f b6       	in	r0, 0x3f	; 63
    9af0:	f8 94       	cli
    9af2:	de bf       	out	0x3e, r29	; 62
    9af4:	0f be       	out	0x3f, r0	; 63
    9af6:	cd bf       	out	0x3d, r28	; 61
    9af8:	cf 91       	pop	r28
    9afa:	df 91       	pop	r29
    9afc:	1f 91       	pop	r17
    9afe:	0f 91       	pop	r16
    9b00:	ff 90       	pop	r15
    9b02:	08 95       	ret

00009b04 <sendMessage94>:
    //_uart_print(0, 0,strSend);
    _uart_print(1, 0,strSend);
	_uart(1, 1,0x02);
}

void sendMessage94(){//Void Transaction Message
    9b04:	0f 93       	push	r16
    9b06:	1f 93       	push	r17
    9b08:	df 93       	push	r29
    9b0a:	cf 93       	push	r28
    9b0c:	cd b7       	in	r28, 0x3d	; 61
    9b0e:	de b7       	in	r29, 0x3e	; 62
    9b10:	c0 55       	subi	r28, 0x50	; 80
    9b12:	d0 40       	sbci	r29, 0x00	; 0
    9b14:	0f b6       	in	r0, 0x3f	; 63
    9b16:	f8 94       	cli
    9b18:	de bf       	out	0x3e, r29	; 62
    9b1a:	0f be       	out	0x3f, r0	; 63
    9b1c:	cd bf       	out	0x3d, r28	; 61
	char strSend[80];
	_uart(1, 1,0x01);
    9b1e:	81 e0       	ldi	r24, 0x01	; 1
    9b20:	61 e0       	ldi	r22, 0x01	; 1
    9b22:	41 e0       	ldi	r20, 0x01	; 1
    9b24:	0e 94 53 b2 	call	0x164a6	; 0x164a6 <_uart>
	UpdateIFT_ID(); //ReadIFT_ID
    9b28:	0e 94 71 1b 	call	0x36e2	; 0x36e2 <UpdateIFT_ID>
	UpdateSeqNum(); //UpdateSeqNum SeqNum++
    9b2c:	0e 94 46 1b 	call	0x368c	; 0x368c <UpdateSeqNum>
	UpdateClientIP();//ReadSourceIP
    9b30:	0e 94 3b 1f 	call	0x3e76	; 0x3e76 <UpdateClientIP>
	UpdateServerIP();//ReadDestIP
    9b34:	0e 94 d3 1e 	call	0x3da6	; 0x3da6 <UpdateServerIP>
	sprintf_P(strSend,PSTR("%s%s%s%s94"),strIFT_ID,strSeqNum,strClientIP,strServerIP);
    9b38:	8d b7       	in	r24, 0x3d	; 61
    9b3a:	9e b7       	in	r25, 0x3e	; 62
    9b3c:	0c 97       	sbiw	r24, 0x0c	; 12
    9b3e:	0f b6       	in	r0, 0x3f	; 63
    9b40:	f8 94       	cli
    9b42:	9e bf       	out	0x3e, r25	; 62
    9b44:	0f be       	out	0x3f, r0	; 63
    9b46:	8d bf       	out	0x3d, r24	; 61
    9b48:	ed b7       	in	r30, 0x3d	; 61
    9b4a:	fe b7       	in	r31, 0x3e	; 62
    9b4c:	31 96       	adiw	r30, 0x01	; 1
    9b4e:	8e 01       	movw	r16, r28
    9b50:	0f 5f       	subi	r16, 0xFF	; 255
    9b52:	1f 4f       	sbci	r17, 0xFF	; 255
    9b54:	ad b7       	in	r26, 0x3d	; 61
    9b56:	be b7       	in	r27, 0x3e	; 62
    9b58:	12 96       	adiw	r26, 0x02	; 2
    9b5a:	1c 93       	st	X, r17
    9b5c:	0e 93       	st	-X, r16
    9b5e:	11 97       	sbiw	r26, 0x01	; 1
    9b60:	86 ee       	ldi	r24, 0xE6	; 230
    9b62:	90 e2       	ldi	r25, 0x20	; 32
    9b64:	93 83       	std	Z+3, r25	; 0x03
    9b66:	82 83       	std	Z+2, r24	; 0x02
    9b68:	8b ef       	ldi	r24, 0xFB	; 251
    9b6a:	94 e0       	ldi	r25, 0x04	; 4
    9b6c:	95 83       	std	Z+5, r25	; 0x05
    9b6e:	84 83       	std	Z+4, r24	; 0x04
    9b70:	87 e0       	ldi	r24, 0x07	; 7
    9b72:	9d e0       	ldi	r25, 0x0D	; 13
    9b74:	97 83       	std	Z+7, r25	; 0x07
    9b76:	86 83       	std	Z+6, r24	; 0x06
    9b78:	8d ee       	ldi	r24, 0xED	; 237
    9b7a:	98 e0       	ldi	r25, 0x08	; 8
    9b7c:	91 87       	std	Z+9, r25	; 0x09
    9b7e:	80 87       	std	Z+8, r24	; 0x08
    9b80:	8a e1       	ldi	r24, 0x1A	; 26
    9b82:	99 e0       	ldi	r25, 0x09	; 9
    9b84:	93 87       	std	Z+11, r25	; 0x0b
    9b86:	82 87       	std	Z+10, r24	; 0x0a
    9b88:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    _uart_print(1, 0,strSend);
    9b8c:	ed b7       	in	r30, 0x3d	; 61
    9b8e:	fe b7       	in	r31, 0x3e	; 62
    9b90:	3c 96       	adiw	r30, 0x0c	; 12
    9b92:	0f b6       	in	r0, 0x3f	; 63
    9b94:	f8 94       	cli
    9b96:	fe bf       	out	0x3e, r31	; 62
    9b98:	0f be       	out	0x3f, r0	; 63
    9b9a:	ed bf       	out	0x3d, r30	; 61
    9b9c:	81 e0       	ldi	r24, 0x01	; 1
    9b9e:	60 e0       	ldi	r22, 0x00	; 0
    9ba0:	a8 01       	movw	r20, r16
    9ba2:	0e 94 70 b2 	call	0x164e0	; 0x164e0 <_uart_print>
    //_uart_print(0, 0,strSend);
	sprintf_P(strSend,PSTR("%s%s"),strInvoiceNumber,strDateTime);
    9ba6:	8d b7       	in	r24, 0x3d	; 61
    9ba8:	9e b7       	in	r25, 0x3e	; 62
    9baa:	08 97       	sbiw	r24, 0x08	; 8
    9bac:	0f b6       	in	r0, 0x3f	; 63
    9bae:	f8 94       	cli
    9bb0:	9e bf       	out	0x3e, r25	; 62
    9bb2:	0f be       	out	0x3f, r0	; 63
    9bb4:	8d bf       	out	0x3d, r24	; 61
    9bb6:	ed b7       	in	r30, 0x3d	; 61
    9bb8:	fe b7       	in	r31, 0x3e	; 62
    9bba:	31 96       	adiw	r30, 0x01	; 1
    9bbc:	ad b7       	in	r26, 0x3d	; 61
    9bbe:	be b7       	in	r27, 0x3e	; 62
    9bc0:	12 96       	adiw	r26, 0x02	; 2
    9bc2:	1c 93       	st	X, r17
    9bc4:	0e 93       	st	-X, r16
    9bc6:	11 97       	sbiw	r26, 0x01	; 1
    9bc8:	81 ee       	ldi	r24, 0xE1	; 225
    9bca:	90 e2       	ldi	r25, 0x20	; 32
    9bcc:	93 83       	std	Z+3, r25	; 0x03
    9bce:	82 83       	std	Z+2, r24	; 0x02
    9bd0:	85 e6       	ldi	r24, 0x65	; 101
    9bd2:	98 e0       	ldi	r25, 0x08	; 8
    9bd4:	95 83       	std	Z+5, r25	; 0x05
    9bd6:	84 83       	std	Z+4, r24	; 0x04
    9bd8:	83 ef       	ldi	r24, 0xF3	; 243
    9bda:	9c e0       	ldi	r25, 0x0C	; 12
    9bdc:	97 83       	std	Z+7, r25	; 0x07
    9bde:	86 83       	std	Z+6, r24	; 0x06
    9be0:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    _uart_print(1, 0,strSend);
    9be4:	ed b7       	in	r30, 0x3d	; 61
    9be6:	fe b7       	in	r31, 0x3e	; 62
    9be8:	38 96       	adiw	r30, 0x08	; 8
    9bea:	0f b6       	in	r0, 0x3f	; 63
    9bec:	f8 94       	cli
    9bee:	fe bf       	out	0x3e, r31	; 62
    9bf0:	0f be       	out	0x3f, r0	; 63
    9bf2:	ed bf       	out	0x3d, r30	; 61
    9bf4:	81 e0       	ldi	r24, 0x01	; 1
    9bf6:	60 e0       	ldi	r22, 0x00	; 0
    9bf8:	a8 01       	movw	r20, r16
    9bfa:	0e 94 70 b2 	call	0x164e0	; 0x164e0 <_uart_print>
	sprintf_P(strSend,PSTR("E9445512"));
    9bfe:	00 d0       	rcall	.+0      	; 0x9c00 <sendMessage94+0xfc>
    9c00:	00 d0       	rcall	.+0      	; 0x9c02 <sendMessage94+0xfe>
    9c02:	ad b7       	in	r26, 0x3d	; 61
    9c04:	be b7       	in	r27, 0x3e	; 62
    9c06:	12 96       	adiw	r26, 0x02	; 2
    9c08:	1c 93       	st	X, r17
    9c0a:	0e 93       	st	-X, r16
    9c0c:	11 97       	sbiw	r26, 0x01	; 1
    9c0e:	88 ed       	ldi	r24, 0xD8	; 216
    9c10:	90 e2       	ldi	r25, 0x20	; 32
    9c12:	14 96       	adiw	r26, 0x04	; 4
    9c14:	9c 93       	st	X, r25
    9c16:	8e 93       	st	-X, r24
    9c18:	13 97       	sbiw	r26, 0x03	; 3
    9c1a:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    //_uart_print(0, 0,strSend);
    _uart_print(1, 0,strSend);
    9c1e:	0f 90       	pop	r0
    9c20:	0f 90       	pop	r0
    9c22:	0f 90       	pop	r0
    9c24:	0f 90       	pop	r0
    9c26:	81 e0       	ldi	r24, 0x01	; 1
    9c28:	60 e0       	ldi	r22, 0x00	; 0
    9c2a:	a8 01       	movw	r20, r16
    9c2c:	0e 94 70 b2 	call	0x164e0	; 0x164e0 <_uart_print>
	_uart(1, 1,0x02);
    9c30:	81 e0       	ldi	r24, 0x01	; 1
    9c32:	61 e0       	ldi	r22, 0x01	; 1
    9c34:	42 e0       	ldi	r20, 0x02	; 2
    9c36:	0e 94 53 b2 	call	0x164a6	; 0x164a6 <_uart>
}
    9c3a:	c0 5b       	subi	r28, 0xB0	; 176
    9c3c:	df 4f       	sbci	r29, 0xFF	; 255
    9c3e:	0f b6       	in	r0, 0x3f	; 63
    9c40:	f8 94       	cli
    9c42:	de bf       	out	0x3e, r29	; 62
    9c44:	0f be       	out	0x3f, r0	; 63
    9c46:	cd bf       	out	0x3d, r28	; 61
    9c48:	cf 91       	pop	r28
    9c4a:	df 91       	pop	r29
    9c4c:	1f 91       	pop	r17
    9c4e:	0f 91       	pop	r16
    9c50:	08 95       	ret

00009c52 <sendMessage92>:
	sprintf_P(strSend,PSTR("E9445512"));
    _uart_print(1, 0,strSend);
	_uart(1, 1,0x02);
}

void sendMessage92(){
    9c52:	0f 93       	push	r16
    9c54:	1f 93       	push	r17
    9c56:	df 93       	push	r29
    9c58:	cf 93       	push	r28
    9c5a:	cd b7       	in	r28, 0x3d	; 61
    9c5c:	de b7       	in	r29, 0x3e	; 62
    9c5e:	c0 55       	subi	r28, 0x50	; 80
    9c60:	d0 40       	sbci	r29, 0x00	; 0
    9c62:	0f b6       	in	r0, 0x3f	; 63
    9c64:	f8 94       	cli
    9c66:	de bf       	out	0x3e, r29	; 62
    9c68:	0f be       	out	0x3f, r0	; 63
    9c6a:	cd bf       	out	0x3d, r28	; 61
	char strSend[80];
	_uart(1, 1,0x01);
    9c6c:	81 e0       	ldi	r24, 0x01	; 1
    9c6e:	61 e0       	ldi	r22, 0x01	; 1
    9c70:	41 e0       	ldi	r20, 0x01	; 1
    9c72:	0e 94 53 b2 	call	0x164a6	; 0x164a6 <_uart>
	UpdateIFT_ID(); //ReadIFT_ID
    9c76:	0e 94 71 1b 	call	0x36e2	; 0x36e2 <UpdateIFT_ID>
	UpdateSeqNum(); //UpdateSeqNum SeqNum++
    9c7a:	0e 94 46 1b 	call	0x368c	; 0x368c <UpdateSeqNum>
	UpdateClientIP();//ReadSourceIP
    9c7e:	0e 94 3b 1f 	call	0x3e76	; 0x3e76 <UpdateClientIP>
	UpdateServerIP();//ReadDestIP
    9c82:	0e 94 d3 1e 	call	0x3da6	; 0x3da6 <UpdateServerIP>
	sprintf_P(strSend,PSTR("%s%s%s%s92"),strIFT_ID,strSeqNum,strClientIP,strServerIP);
    9c86:	8d b7       	in	r24, 0x3d	; 61
    9c88:	9e b7       	in	r25, 0x3e	; 62
    9c8a:	0c 97       	sbiw	r24, 0x0c	; 12
    9c8c:	0f b6       	in	r0, 0x3f	; 63
    9c8e:	f8 94       	cli
    9c90:	9e bf       	out	0x3e, r25	; 62
    9c92:	0f be       	out	0x3f, r0	; 63
    9c94:	8d bf       	out	0x3d, r24	; 61
    9c96:	ed b7       	in	r30, 0x3d	; 61
    9c98:	fe b7       	in	r31, 0x3e	; 62
    9c9a:	31 96       	adiw	r30, 0x01	; 1
    9c9c:	8e 01       	movw	r16, r28
    9c9e:	0f 5f       	subi	r16, 0xFF	; 255
    9ca0:	1f 4f       	sbci	r17, 0xFF	; 255
    9ca2:	ad b7       	in	r26, 0x3d	; 61
    9ca4:	be b7       	in	r27, 0x3e	; 62
    9ca6:	12 96       	adiw	r26, 0x02	; 2
    9ca8:	1c 93       	st	X, r17
    9caa:	0e 93       	st	-X, r16
    9cac:	11 97       	sbiw	r26, 0x01	; 1
    9cae:	8a e0       	ldi	r24, 0x0A	; 10
    9cb0:	91 e2       	ldi	r25, 0x21	; 33
    9cb2:	93 83       	std	Z+3, r25	; 0x03
    9cb4:	82 83       	std	Z+2, r24	; 0x02
    9cb6:	8b ef       	ldi	r24, 0xFB	; 251
    9cb8:	94 e0       	ldi	r25, 0x04	; 4
    9cba:	95 83       	std	Z+5, r25	; 0x05
    9cbc:	84 83       	std	Z+4, r24	; 0x04
    9cbe:	87 e0       	ldi	r24, 0x07	; 7
    9cc0:	9d e0       	ldi	r25, 0x0D	; 13
    9cc2:	97 83       	std	Z+7, r25	; 0x07
    9cc4:	86 83       	std	Z+6, r24	; 0x06
    9cc6:	8d ee       	ldi	r24, 0xED	; 237
    9cc8:	98 e0       	ldi	r25, 0x08	; 8
    9cca:	91 87       	std	Z+9, r25	; 0x09
    9ccc:	80 87       	std	Z+8, r24	; 0x08
    9cce:	8a e1       	ldi	r24, 0x1A	; 26
    9cd0:	99 e0       	ldi	r25, 0x09	; 9
    9cd2:	93 87       	std	Z+11, r25	; 0x0b
    9cd4:	82 87       	std	Z+10, r24	; 0x0a
    9cd6:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    _uart_print(1, 0,strSend);
    9cda:	ed b7       	in	r30, 0x3d	; 61
    9cdc:	fe b7       	in	r31, 0x3e	; 62
    9cde:	3c 96       	adiw	r30, 0x0c	; 12
    9ce0:	0f b6       	in	r0, 0x3f	; 63
    9ce2:	f8 94       	cli
    9ce4:	fe bf       	out	0x3e, r31	; 62
    9ce6:	0f be       	out	0x3f, r0	; 63
    9ce8:	ed bf       	out	0x3d, r30	; 61
    9cea:	81 e0       	ldi	r24, 0x01	; 1
    9cec:	60 e0       	ldi	r22, 0x00	; 0
    9cee:	a8 01       	movw	r20, r16
    9cf0:	0e 94 70 b2 	call	0x164e0	; 0x164e0 <_uart_print>
    //_uart_print(0, 0,strSend);
	sprintf_P(strSend,PSTR("%s%s%s%s"),strTranNo,strFIP_ID,strCardType,strCardID);
    9cf4:	8d b7       	in	r24, 0x3d	; 61
    9cf6:	9e b7       	in	r25, 0x3e	; 62
    9cf8:	0c 97       	sbiw	r24, 0x0c	; 12
    9cfa:	0f b6       	in	r0, 0x3f	; 63
    9cfc:	f8 94       	cli
    9cfe:	9e bf       	out	0x3e, r25	; 62
    9d00:	0f be       	out	0x3f, r0	; 63
    9d02:	8d bf       	out	0x3d, r24	; 61
    9d04:	ed b7       	in	r30, 0x3d	; 61
    9d06:	fe b7       	in	r31, 0x3e	; 62
    9d08:	31 96       	adiw	r30, 0x01	; 1
    9d0a:	ad b7       	in	r26, 0x3d	; 61
    9d0c:	be b7       	in	r27, 0x3e	; 62
    9d0e:	12 96       	adiw	r26, 0x02	; 2
    9d10:	1c 93       	st	X, r17
    9d12:	0e 93       	st	-X, r16
    9d14:	11 97       	sbiw	r26, 0x01	; 1
    9d16:	81 e0       	ldi	r24, 0x01	; 1
    9d18:	91 e2       	ldi	r25, 0x21	; 33
    9d1a:	93 83       	std	Z+3, r25	; 0x03
    9d1c:	82 83       	std	Z+2, r24	; 0x02
    9d1e:	8e eb       	ldi	r24, 0xBE	; 190
    9d20:	9d e0       	ldi	r25, 0x0D	; 13
    9d22:	95 83       	std	Z+5, r25	; 0x05
    9d24:	84 83       	std	Z+4, r24	; 0x04
    9d26:	8b ec       	ldi	r24, 0xCB	; 203
    9d28:	98 e0       	ldi	r25, 0x08	; 8
    9d2a:	97 83       	std	Z+7, r25	; 0x07
    9d2c:	86 83       	std	Z+6, r24	; 0x06
    9d2e:	8a ed       	ldi	r24, 0xDA	; 218
    9d30:	9d e0       	ldi	r25, 0x0D	; 13
    9d32:	91 87       	std	Z+9, r25	; 0x09
    9d34:	80 87       	std	Z+8, r24	; 0x08
    9d36:	8d eb       	ldi	r24, 0xBD	; 189
    9d38:	9c e0       	ldi	r25, 0x0C	; 12
    9d3a:	93 87       	std	Z+11, r25	; 0x0b
    9d3c:	82 87       	std	Z+10, r24	; 0x0a
    9d3e:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    _uart_print(1, 0,strSend);
    9d42:	ed b7       	in	r30, 0x3d	; 61
    9d44:	fe b7       	in	r31, 0x3e	; 62
    9d46:	3c 96       	adiw	r30, 0x0c	; 12
    9d48:	0f b6       	in	r0, 0x3f	; 63
    9d4a:	f8 94       	cli
    9d4c:	fe bf       	out	0x3e, r31	; 62
    9d4e:	0f be       	out	0x3f, r0	; 63
    9d50:	ed bf       	out	0x3d, r30	; 61
    9d52:	81 e0       	ldi	r24, 0x01	; 1
    9d54:	60 e0       	ldi	r22, 0x00	; 0
    9d56:	a8 01       	movw	r20, r16
    9d58:	0e 94 70 b2 	call	0x164e0	; 0x164e0 <_uart_print>
    //_uart_print(0, 0,strSend);
	sprintf_P(strSend,PSTR("%s%s%s"),strApprovalCode,strInvoiceNumber,strDateTime);
    9d5c:	8d b7       	in	r24, 0x3d	; 61
    9d5e:	9e b7       	in	r25, 0x3e	; 62
    9d60:	0a 97       	sbiw	r24, 0x0a	; 10
    9d62:	0f b6       	in	r0, 0x3f	; 63
    9d64:	f8 94       	cli
    9d66:	9e bf       	out	0x3e, r25	; 62
    9d68:	0f be       	out	0x3f, r0	; 63
    9d6a:	8d bf       	out	0x3d, r24	; 61
    9d6c:	ed b7       	in	r30, 0x3d	; 61
    9d6e:	fe b7       	in	r31, 0x3e	; 62
    9d70:	31 96       	adiw	r30, 0x01	; 1
    9d72:	ad b7       	in	r26, 0x3d	; 61
    9d74:	be b7       	in	r27, 0x3e	; 62
    9d76:	12 96       	adiw	r26, 0x02	; 2
    9d78:	1c 93       	st	X, r17
    9d7a:	0e 93       	st	-X, r16
    9d7c:	11 97       	sbiw	r26, 0x01	; 1
    9d7e:	8a ef       	ldi	r24, 0xFA	; 250
    9d80:	90 e2       	ldi	r25, 0x20	; 32
    9d82:	93 83       	std	Z+3, r25	; 0x03
    9d84:	82 83       	std	Z+2, r24	; 0x02
    9d86:	83 e1       	ldi	r24, 0x13	; 19
    9d88:	99 e0       	ldi	r25, 0x09	; 9
    9d8a:	95 83       	std	Z+5, r25	; 0x05
    9d8c:	84 83       	std	Z+4, r24	; 0x04
    9d8e:	85 e6       	ldi	r24, 0x65	; 101
    9d90:	98 e0       	ldi	r25, 0x08	; 8
    9d92:	97 83       	std	Z+7, r25	; 0x07
    9d94:	86 83       	std	Z+6, r24	; 0x06
    9d96:	83 ef       	ldi	r24, 0xF3	; 243
    9d98:	9c e0       	ldi	r25, 0x0C	; 12
    9d9a:	91 87       	std	Z+9, r25	; 0x09
    9d9c:	80 87       	std	Z+8, r24	; 0x08
    9d9e:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    _uart_print(1, 0,strSend);
    9da2:	ed b7       	in	r30, 0x3d	; 61
    9da4:	fe b7       	in	r31, 0x3e	; 62
    9da6:	3a 96       	adiw	r30, 0x0a	; 10
    9da8:	0f b6       	in	r0, 0x3f	; 63
    9daa:	f8 94       	cli
    9dac:	fe bf       	out	0x3e, r31	; 62
    9dae:	0f be       	out	0x3f, r0	; 63
    9db0:	ed bf       	out	0x3d, r30	; 61
    9db2:	81 e0       	ldi	r24, 0x01	; 1
    9db4:	60 e0       	ldi	r22, 0x00	; 0
    9db6:	a8 01       	movw	r20, r16
    9db8:	0e 94 70 b2 	call	0x164e0	; 0x164e0 <_uart_print>
    //_uart_print(0, 0,strSend);
	sprintf_P(strSend,PSTR("E9445512"));
    9dbc:	00 d0       	rcall	.+0      	; 0x9dbe <sendMessage92+0x16c>
    9dbe:	00 d0       	rcall	.+0      	; 0x9dc0 <sendMessage92+0x16e>
    9dc0:	ad b7       	in	r26, 0x3d	; 61
    9dc2:	be b7       	in	r27, 0x3e	; 62
    9dc4:	12 96       	adiw	r26, 0x02	; 2
    9dc6:	1c 93       	st	X, r17
    9dc8:	0e 93       	st	-X, r16
    9dca:	11 97       	sbiw	r26, 0x01	; 1
    9dcc:	81 ef       	ldi	r24, 0xF1	; 241
    9dce:	90 e2       	ldi	r25, 0x20	; 32
    9dd0:	14 96       	adiw	r26, 0x04	; 4
    9dd2:	9c 93       	st	X, r25
    9dd4:	8e 93       	st	-X, r24
    9dd6:	13 97       	sbiw	r26, 0x03	; 3
    9dd8:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    //_uart_print(0, 0,strSend);
    _uart_print(1, 0,strSend);
    9ddc:	0f 90       	pop	r0
    9dde:	0f 90       	pop	r0
    9de0:	0f 90       	pop	r0
    9de2:	0f 90       	pop	r0
    9de4:	81 e0       	ldi	r24, 0x01	; 1
    9de6:	60 e0       	ldi	r22, 0x00	; 0
    9de8:	a8 01       	movw	r20, r16
    9dea:	0e 94 70 b2 	call	0x164e0	; 0x164e0 <_uart_print>
	_uart(1, 1,0x02);
    9dee:	81 e0       	ldi	r24, 0x01	; 1
    9df0:	61 e0       	ldi	r22, 0x01	; 1
    9df2:	42 e0       	ldi	r20, 0x02	; 2
    9df4:	0e 94 53 b2 	call	0x164a6	; 0x164a6 <_uart>
}
    9df8:	c0 5b       	subi	r28, 0xB0	; 176
    9dfa:	df 4f       	sbci	r29, 0xFF	; 255
    9dfc:	0f b6       	in	r0, 0x3f	; 63
    9dfe:	f8 94       	cli
    9e00:	de bf       	out	0x3e, r29	; 62
    9e02:	0f be       	out	0x3f, r0	; 63
    9e04:	cd bf       	out	0x3d, r28	; 61
    9e06:	cf 91       	pop	r28
    9e08:	df 91       	pop	r29
    9e0a:	1f 91       	pop	r17
    9e0c:	0f 91       	pop	r16
    9e0e:	08 95       	ret

00009e10 <sendMessage90>:
	sprintf_P(strSend,PSTR("%dF0000000E123456FFFFF%sE9445512"),CardType,strOdometer);
    _uart_print(1, 0,strSend);
	_uart(1, 1,0x02);
}

void sendMessage90(){
    9e10:	0f 93       	push	r16
    9e12:	1f 93       	push	r17
    9e14:	df 93       	push	r29
    9e16:	cf 93       	push	r28
    9e18:	cd b7       	in	r28, 0x3d	; 61
    9e1a:	de b7       	in	r29, 0x3e	; 62
    9e1c:	c0 55       	subi	r28, 0x50	; 80
    9e1e:	d0 40       	sbci	r29, 0x00	; 0
    9e20:	0f b6       	in	r0, 0x3f	; 63
    9e22:	f8 94       	cli
    9e24:	de bf       	out	0x3e, r29	; 62
    9e26:	0f be       	out	0x3f, r0	; 63
    9e28:	cd bf       	out	0x3d, r28	; 61
	char strSend[80];
	_uart(1, 1,0x01);
    9e2a:	81 e0       	ldi	r24, 0x01	; 1
    9e2c:	61 e0       	ldi	r22, 0x01	; 1
    9e2e:	41 e0       	ldi	r20, 0x01	; 1
    9e30:	0e 94 53 b2 	call	0x164a6	; 0x164a6 <_uart>
	UpdateIFT_ID(); //ReadIFT_ID
    9e34:	0e 94 71 1b 	call	0x36e2	; 0x36e2 <UpdateIFT_ID>
	UpdateSeqNum(); //UpdateSeqNum SeqNum++
    9e38:	0e 94 46 1b 	call	0x368c	; 0x368c <UpdateSeqNum>
	UpdateClientIP();//ReadSourceIP
    9e3c:	0e 94 3b 1f 	call	0x3e76	; 0x3e76 <UpdateClientIP>
	UpdateServerIP();//ReadDestIP
    9e40:	0e 94 d3 1e 	call	0x3da6	; 0x3da6 <UpdateServerIP>
	sprintf_P(strSend,PSTR("%s%s%s%s90"),strIFT_ID,strSeqNum,strClientIP,strServerIP);
    9e44:	8d b7       	in	r24, 0x3d	; 61
    9e46:	9e b7       	in	r25, 0x3e	; 62
    9e48:	0c 97       	sbiw	r24, 0x0c	; 12
    9e4a:	0f b6       	in	r0, 0x3f	; 63
    9e4c:	f8 94       	cli
    9e4e:	9e bf       	out	0x3e, r25	; 62
    9e50:	0f be       	out	0x3f, r0	; 63
    9e52:	8d bf       	out	0x3d, r24	; 61
    9e54:	ed b7       	in	r30, 0x3d	; 61
    9e56:	fe b7       	in	r31, 0x3e	; 62
    9e58:	31 96       	adiw	r30, 0x01	; 1
    9e5a:	8e 01       	movw	r16, r28
    9e5c:	0f 5f       	subi	r16, 0xFF	; 255
    9e5e:	1f 4f       	sbci	r17, 0xFF	; 255
    9e60:	ad b7       	in	r26, 0x3d	; 61
    9e62:	be b7       	in	r27, 0x3e	; 62
    9e64:	12 96       	adiw	r26, 0x02	; 2
    9e66:	1c 93       	st	X, r17
    9e68:	0e 93       	st	-X, r16
    9e6a:	11 97       	sbiw	r26, 0x01	; 1
    9e6c:	83 e2       	ldi	r24, 0x23	; 35
    9e6e:	91 e2       	ldi	r25, 0x21	; 33
    9e70:	93 83       	std	Z+3, r25	; 0x03
    9e72:	82 83       	std	Z+2, r24	; 0x02
    9e74:	8b ef       	ldi	r24, 0xFB	; 251
    9e76:	94 e0       	ldi	r25, 0x04	; 4
    9e78:	95 83       	std	Z+5, r25	; 0x05
    9e7a:	84 83       	std	Z+4, r24	; 0x04
    9e7c:	87 e0       	ldi	r24, 0x07	; 7
    9e7e:	9d e0       	ldi	r25, 0x0D	; 13
    9e80:	97 83       	std	Z+7, r25	; 0x07
    9e82:	86 83       	std	Z+6, r24	; 0x06
    9e84:	8d ee       	ldi	r24, 0xED	; 237
    9e86:	98 e0       	ldi	r25, 0x08	; 8
    9e88:	91 87       	std	Z+9, r25	; 0x09
    9e8a:	80 87       	std	Z+8, r24	; 0x08
    9e8c:	8a e1       	ldi	r24, 0x1A	; 26
    9e8e:	99 e0       	ldi	r25, 0x09	; 9
    9e90:	93 87       	std	Z+11, r25	; 0x0b
    9e92:	82 87       	std	Z+10, r24	; 0x0a
    9e94:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    _uart_print(1, 0,strSend);
    9e98:	ed b7       	in	r30, 0x3d	; 61
    9e9a:	fe b7       	in	r31, 0x3e	; 62
    9e9c:	3c 96       	adiw	r30, 0x0c	; 12
    9e9e:	0f b6       	in	r0, 0x3f	; 63
    9ea0:	f8 94       	cli
    9ea2:	fe bf       	out	0x3e, r31	; 62
    9ea4:	0f be       	out	0x3f, r0	; 63
    9ea6:	ed bf       	out	0x3d, r30	; 61
    9ea8:	81 e0       	ldi	r24, 0x01	; 1
    9eaa:	60 e0       	ldi	r22, 0x00	; 0
    9eac:	a8 01       	movw	r20, r16
    9eae:	0e 94 70 b2 	call	0x164e0	; 0x164e0 <_uart_print>
	sprintf_P(strSend,PSTR("%s%s"),strFIP_ID,strRef1);
    9eb2:	8d b7       	in	r24, 0x3d	; 61
    9eb4:	9e b7       	in	r25, 0x3e	; 62
    9eb6:	08 97       	sbiw	r24, 0x08	; 8
    9eb8:	0f b6       	in	r0, 0x3f	; 63
    9eba:	f8 94       	cli
    9ebc:	9e bf       	out	0x3e, r25	; 62
    9ebe:	0f be       	out	0x3f, r0	; 63
    9ec0:	8d bf       	out	0x3d, r24	; 61
    9ec2:	ed b7       	in	r30, 0x3d	; 61
    9ec4:	fe b7       	in	r31, 0x3e	; 62
    9ec6:	31 96       	adiw	r30, 0x01	; 1
    9ec8:	ad b7       	in	r26, 0x3d	; 61
    9eca:	be b7       	in	r27, 0x3e	; 62
    9ecc:	12 96       	adiw	r26, 0x02	; 2
    9ece:	1c 93       	st	X, r17
    9ed0:	0e 93       	st	-X, r16
    9ed2:	11 97       	sbiw	r26, 0x01	; 1
    9ed4:	8e e1       	ldi	r24, 0x1E	; 30
    9ed6:	91 e2       	ldi	r25, 0x21	; 33
    9ed8:	93 83       	std	Z+3, r25	; 0x03
    9eda:	82 83       	std	Z+2, r24	; 0x02
    9edc:	8b ec       	ldi	r24, 0xCB	; 203
    9ede:	98 e0       	ldi	r25, 0x08	; 8
    9ee0:	95 83       	std	Z+5, r25	; 0x05
    9ee2:	84 83       	std	Z+4, r24	; 0x04
    9ee4:	85 ec       	ldi	r24, 0xC5	; 197
    9ee6:	9d e0       	ldi	r25, 0x0D	; 13
    9ee8:	97 83       	std	Z+7, r25	; 0x07
    9eea:	86 83       	std	Z+6, r24	; 0x06
    9eec:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    _uart_print(1, 0,strSend);
    9ef0:	ed b7       	in	r30, 0x3d	; 61
    9ef2:	fe b7       	in	r31, 0x3e	; 62
    9ef4:	38 96       	adiw	r30, 0x08	; 8
    9ef6:	0f b6       	in	r0, 0x3f	; 63
    9ef8:	f8 94       	cli
    9efa:	fe bf       	out	0x3e, r31	; 62
    9efc:	0f be       	out	0x3f, r0	; 63
    9efe:	ed bf       	out	0x3d, r30	; 61
    9f00:	81 e0       	ldi	r24, 0x01	; 1
    9f02:	60 e0       	ldi	r22, 0x00	; 0
    9f04:	a8 01       	movw	r20, r16
    9f06:	0e 94 70 b2 	call	0x164e0	; 0x164e0 <_uart_print>
	sprintf_P(strSend,PSTR("E9445512"));
    9f0a:	00 d0       	rcall	.+0      	; 0x9f0c <sendMessage90+0xfc>
    9f0c:	00 d0       	rcall	.+0      	; 0x9f0e <sendMessage90+0xfe>
    9f0e:	ad b7       	in	r26, 0x3d	; 61
    9f10:	be b7       	in	r27, 0x3e	; 62
    9f12:	12 96       	adiw	r26, 0x02	; 2
    9f14:	1c 93       	st	X, r17
    9f16:	0e 93       	st	-X, r16
    9f18:	11 97       	sbiw	r26, 0x01	; 1
    9f1a:	85 e1       	ldi	r24, 0x15	; 21
    9f1c:	91 e2       	ldi	r25, 0x21	; 33
    9f1e:	14 96       	adiw	r26, 0x04	; 4
    9f20:	9c 93       	st	X, r25
    9f22:	8e 93       	st	-X, r24
    9f24:	13 97       	sbiw	r26, 0x03	; 3
    9f26:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    _uart_print(1, 0,strSend);
    9f2a:	0f 90       	pop	r0
    9f2c:	0f 90       	pop	r0
    9f2e:	0f 90       	pop	r0
    9f30:	0f 90       	pop	r0
    9f32:	81 e0       	ldi	r24, 0x01	; 1
    9f34:	60 e0       	ldi	r22, 0x00	; 0
    9f36:	a8 01       	movw	r20, r16
    9f38:	0e 94 70 b2 	call	0x164e0	; 0x164e0 <_uart_print>
	_uart(1, 1,0x02);
    9f3c:	81 e0       	ldi	r24, 0x01	; 1
    9f3e:	61 e0       	ldi	r22, 0x01	; 1
    9f40:	42 e0       	ldi	r20, 0x02	; 2
    9f42:	0e 94 53 b2 	call	0x164a6	; 0x164a6 <_uart>
}
    9f46:	c0 5b       	subi	r28, 0xB0	; 176
    9f48:	df 4f       	sbci	r29, 0xFF	; 255
    9f4a:	0f b6       	in	r0, 0x3f	; 63
    9f4c:	f8 94       	cli
    9f4e:	de bf       	out	0x3e, r29	; 62
    9f50:	0f be       	out	0x3f, r0	; 63
    9f52:	cd bf       	out	0x3d, r28	; 61
    9f54:	cf 91       	pop	r28
    9f56:	df 91       	pop	r29
    9f58:	1f 91       	pop	r17
    9f5a:	0f 91       	pop	r16
    9f5c:	08 95       	ret

00009f5e <sendMessage58>:

	_uart_printf(1,0,PSTR("AF968CFFB"));
	_uart(1, 1,0x02);
}

void sendMessage58(){
    9f5e:	cf 92       	push	r12
    9f60:	df 92       	push	r13
    9f62:	ef 92       	push	r14
    9f64:	ff 92       	push	r15
    9f66:	0f 93       	push	r16
    9f68:	1f 93       	push	r17
    9f6a:	df 93       	push	r29
    9f6c:	cf 93       	push	r28
    9f6e:	cd b7       	in	r28, 0x3d	; 61
    9f70:	de b7       	in	r29, 0x3e	; 62
    9f72:	c0 55       	subi	r28, 0x50	; 80
    9f74:	d0 40       	sbci	r29, 0x00	; 0
    9f76:	0f b6       	in	r0, 0x3f	; 63
    9f78:	f8 94       	cli
    9f7a:	de bf       	out	0x3e, r29	; 62
    9f7c:	0f be       	out	0x3f, r0	; 63
    9f7e:	cd bf       	out	0x3d, r28	; 61
	char strSend[80];
	_uart(1, 1,0x01);
    9f80:	81 e0       	ldi	r24, 0x01	; 1
    9f82:	61 e0       	ldi	r22, 0x01	; 1
    9f84:	41 e0       	ldi	r20, 0x01	; 1
    9f86:	0e 94 53 b2 	call	0x164a6	; 0x164a6 <_uart>
	UpdateIFT_ID(); //ReadIFT_ID
    9f8a:	0e 94 71 1b 	call	0x36e2	; 0x36e2 <UpdateIFT_ID>
	UpdateSeqNum(); //UpdateSeqNum SeqNum++
    9f8e:	0e 94 46 1b 	call	0x368c	; 0x368c <UpdateSeqNum>
	UpdateClientIP();//ReadSourceIP
    9f92:	0e 94 3b 1f 	call	0x3e76	; 0x3e76 <UpdateClientIP>
	UpdateServerIP();//ReadDestIP
    9f96:	0e 94 d3 1e 	call	0x3da6	; 0x3da6 <UpdateServerIP>
	UpdateCardID();  //ReadCardID
    9f9a:	0e 94 ad 3f 	call	0x7f5a	; 0x7f5a <UpdateCardID>
	sprintf_P(strSend,PSTR("%s%s%s%s58"),strIFT_ID,strSeqNum,strClientIP,strServerIP);
    9f9e:	8d b7       	in	r24, 0x3d	; 61
    9fa0:	9e b7       	in	r25, 0x3e	; 62
    9fa2:	0c 97       	sbiw	r24, 0x0c	; 12
    9fa4:	0f b6       	in	r0, 0x3f	; 63
    9fa6:	f8 94       	cli
    9fa8:	9e bf       	out	0x3e, r25	; 62
    9faa:	0f be       	out	0x3f, r0	; 63
    9fac:	8d bf       	out	0x3d, r24	; 61
    9fae:	ed b7       	in	r30, 0x3d	; 61
    9fb0:	fe b7       	in	r31, 0x3e	; 62
    9fb2:	31 96       	adiw	r30, 0x01	; 1
    9fb4:	8e 01       	movw	r16, r28
    9fb6:	0f 5f       	subi	r16, 0xFF	; 255
    9fb8:	1f 4f       	sbci	r17, 0xFF	; 255
    9fba:	ad b7       	in	r26, 0x3d	; 61
    9fbc:	be b7       	in	r27, 0x3e	; 62
    9fbe:	12 96       	adiw	r26, 0x02	; 2
    9fc0:	1c 93       	st	X, r17
    9fc2:	0e 93       	st	-X, r16
    9fc4:	11 97       	sbiw	r26, 0x01	; 1
    9fc6:	8a e5       	ldi	r24, 0x5A	; 90
    9fc8:	91 e2       	ldi	r25, 0x21	; 33
    9fca:	93 83       	std	Z+3, r25	; 0x03
    9fcc:	82 83       	std	Z+2, r24	; 0x02
    9fce:	8b ef       	ldi	r24, 0xFB	; 251
    9fd0:	94 e0       	ldi	r25, 0x04	; 4
    9fd2:	95 83       	std	Z+5, r25	; 0x05
    9fd4:	84 83       	std	Z+4, r24	; 0x04
    9fd6:	87 e0       	ldi	r24, 0x07	; 7
    9fd8:	9d e0       	ldi	r25, 0x0D	; 13
    9fda:	97 83       	std	Z+7, r25	; 0x07
    9fdc:	86 83       	std	Z+6, r24	; 0x06
    9fde:	8d ee       	ldi	r24, 0xED	; 237
    9fe0:	98 e0       	ldi	r25, 0x08	; 8
    9fe2:	91 87       	std	Z+9, r25	; 0x09
    9fe4:	80 87       	std	Z+8, r24	; 0x08
    9fe6:	8a e1       	ldi	r24, 0x1A	; 26
    9fe8:	99 e0       	ldi	r25, 0x09	; 9
    9fea:	93 87       	std	Z+11, r25	; 0x0b
    9fec:	82 87       	std	Z+10, r24	; 0x0a
    9fee:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    _uart_print(1, 0,strSend);
    9ff2:	8d b7       	in	r24, 0x3d	; 61
    9ff4:	9e b7       	in	r25, 0x3e	; 62
    9ff6:	0c 96       	adiw	r24, 0x0c	; 12
    9ff8:	0f b6       	in	r0, 0x3f	; 63
    9ffa:	f8 94       	cli
    9ffc:	9e bf       	out	0x3e, r25	; 62
    9ffe:	0f be       	out	0x3f, r0	; 63
    a000:	8d bf       	out	0x3d, r24	; 61
    a002:	81 e0       	ldi	r24, 0x01	; 1
    a004:	60 e0       	ldi	r22, 0x00	; 0
    a006:	a8 01       	movw	r20, r16
    a008:	0e 94 70 b2 	call	0x164e0	; 0x164e0 <_uart_print>
	AddSpaceLead(strBalanceValue,13);
    a00c:	e6 e5       	ldi	r30, 0x56	; 86
    a00e:	ee 2e       	mov	r14, r30
    a010:	ed e0       	ldi	r30, 0x0D	; 13
    a012:	fe 2e       	mov	r15, r30
    a014:	c7 01       	movw	r24, r14
    a016:	6d e0       	ldi	r22, 0x0D	; 13
    a018:	0e 94 39 2d 	call	0x5a72	; 0x5a72 <AddSpaceLead>
	AddSpaceLead(strOdometer,10);
    a01c:	72 ed       	ldi	r23, 0xD2	; 210
    a01e:	c7 2e       	mov	r12, r23
    a020:	74 e0       	ldi	r23, 0x04	; 4
    a022:	d7 2e       	mov	r13, r23
    a024:	c6 01       	movw	r24, r12
    a026:	6a e0       	ldi	r22, 0x0A	; 10
    a028:	0e 94 39 2d 	call	0x5a72	; 0x5a72 <AddSpaceLead>
	sprintf_P(strSend,PSTR("%s%s%d%s%s"),strCardID,strFIP_ID,NozzleID,strBalanceType,strBalanceValue);
    a02c:	ad b7       	in	r26, 0x3d	; 61
    a02e:	be b7       	in	r27, 0x3e	; 62
    a030:	1e 97       	sbiw	r26, 0x0e	; 14
    a032:	0f b6       	in	r0, 0x3f	; 63
    a034:	f8 94       	cli
    a036:	be bf       	out	0x3e, r27	; 62
    a038:	0f be       	out	0x3f, r0	; 63
    a03a:	ad bf       	out	0x3d, r26	; 61
    a03c:	ed b7       	in	r30, 0x3d	; 61
    a03e:	fe b7       	in	r31, 0x3e	; 62
    a040:	31 96       	adiw	r30, 0x01	; 1
    a042:	12 96       	adiw	r26, 0x02	; 2
    a044:	1c 93       	st	X, r17
    a046:	0e 93       	st	-X, r16
    a048:	11 97       	sbiw	r26, 0x01	; 1
    a04a:	8f e4       	ldi	r24, 0x4F	; 79
    a04c:	91 e2       	ldi	r25, 0x21	; 33
    a04e:	93 83       	std	Z+3, r25	; 0x03
    a050:	82 83       	std	Z+2, r24	; 0x02
    a052:	8d eb       	ldi	r24, 0xBD	; 189
    a054:	9c e0       	ldi	r25, 0x0C	; 12
    a056:	95 83       	std	Z+5, r25	; 0x05
    a058:	84 83       	std	Z+4, r24	; 0x04
    a05a:	8b ec       	ldi	r24, 0xCB	; 203
    a05c:	98 e0       	ldi	r25, 0x08	; 8
    a05e:	97 83       	std	Z+7, r25	; 0x07
    a060:	86 83       	std	Z+6, r24	; 0x06
    a062:	80 91 7f 08 	lds	r24, 0x087F
    a066:	80 87       	std	Z+8, r24	; 0x08
    a068:	11 86       	std	Z+9, r1	; 0x09
    a06a:	82 eb       	ldi	r24, 0xB2	; 178
    a06c:	94 e0       	ldi	r25, 0x04	; 4
    a06e:	93 87       	std	Z+11, r25	; 0x0b
    a070:	82 87       	std	Z+10, r24	; 0x0a
    a072:	f5 86       	std	Z+13, r15	; 0x0d
    a074:	e4 86       	std	Z+12, r14	; 0x0c
    a076:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    _uart_print(1, 0,strSend);
    a07a:	8d b7       	in	r24, 0x3d	; 61
    a07c:	9e b7       	in	r25, 0x3e	; 62
    a07e:	0e 96       	adiw	r24, 0x0e	; 14
    a080:	0f b6       	in	r0, 0x3f	; 63
    a082:	f8 94       	cli
    a084:	9e bf       	out	0x3e, r25	; 62
    a086:	0f be       	out	0x3f, r0	; 63
    a088:	8d bf       	out	0x3d, r24	; 61
    a08a:	81 e0       	ldi	r24, 0x01	; 1
    a08c:	60 e0       	ldi	r22, 0x00	; 0
    a08e:	a8 01       	movw	r20, r16
    a090:	0e 94 70 b2 	call	0x164e0	; 0x164e0 <_uart_print>

	CardType=0;
    a094:	10 92 98 04 	sts	0x0498, r1
	sprintf_P(strSend,PSTR("%dF0000000E123456FFFFF%sE9445512"),CardType,strOdometer);
    a098:	ad b7       	in	r26, 0x3d	; 61
    a09a:	be b7       	in	r27, 0x3e	; 62
    a09c:	18 97       	sbiw	r26, 0x08	; 8
    a09e:	0f b6       	in	r0, 0x3f	; 63
    a0a0:	f8 94       	cli
    a0a2:	be bf       	out	0x3e, r27	; 62
    a0a4:	0f be       	out	0x3f, r0	; 63
    a0a6:	ad bf       	out	0x3d, r26	; 61
    a0a8:	ed b7       	in	r30, 0x3d	; 61
    a0aa:	fe b7       	in	r31, 0x3e	; 62
    a0ac:	31 96       	adiw	r30, 0x01	; 1
    a0ae:	12 96       	adiw	r26, 0x02	; 2
    a0b0:	1c 93       	st	X, r17
    a0b2:	0e 93       	st	-X, r16
    a0b4:	11 97       	sbiw	r26, 0x01	; 1
    a0b6:	8e e2       	ldi	r24, 0x2E	; 46
    a0b8:	91 e2       	ldi	r25, 0x21	; 33
    a0ba:	93 83       	std	Z+3, r25	; 0x03
    a0bc:	82 83       	std	Z+2, r24	; 0x02
    a0be:	15 82       	std	Z+5, r1	; 0x05
    a0c0:	14 82       	std	Z+4, r1	; 0x04
    a0c2:	d7 82       	std	Z+7, r13	; 0x07
    a0c4:	c6 82       	std	Z+6, r12	; 0x06
    a0c6:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    _uart_print(1, 0,strSend);
    a0ca:	8d b7       	in	r24, 0x3d	; 61
    a0cc:	9e b7       	in	r25, 0x3e	; 62
    a0ce:	08 96       	adiw	r24, 0x08	; 8
    a0d0:	0f b6       	in	r0, 0x3f	; 63
    a0d2:	f8 94       	cli
    a0d4:	9e bf       	out	0x3e, r25	; 62
    a0d6:	0f be       	out	0x3f, r0	; 63
    a0d8:	8d bf       	out	0x3d, r24	; 61
    a0da:	81 e0       	ldi	r24, 0x01	; 1
    a0dc:	60 e0       	ldi	r22, 0x00	; 0
    a0de:	a8 01       	movw	r20, r16
    a0e0:	0e 94 70 b2 	call	0x164e0	; 0x164e0 <_uart_print>
	_uart(1, 1,0x02);
    a0e4:	81 e0       	ldi	r24, 0x01	; 1
    a0e6:	61 e0       	ldi	r22, 0x01	; 1
    a0e8:	42 e0       	ldi	r20, 0x02	; 2
    a0ea:	0e 94 53 b2 	call	0x164a6	; 0x164a6 <_uart>
}
    a0ee:	c0 5b       	subi	r28, 0xB0	; 176
    a0f0:	df 4f       	sbci	r29, 0xFF	; 255
    a0f2:	0f b6       	in	r0, 0x3f	; 63
    a0f4:	f8 94       	cli
    a0f6:	de bf       	out	0x3e, r29	; 62
    a0f8:	0f be       	out	0x3f, r0	; 63
    a0fa:	cd bf       	out	0x3d, r28	; 61
    a0fc:	cf 91       	pop	r28
    a0fe:	df 91       	pop	r29
    a100:	1f 91       	pop	r17
    a102:	0f 91       	pop	r16
    a104:	ff 90       	pop	r15
    a106:	ef 90       	pop	r14
    a108:	df 90       	pop	r13
    a10a:	cf 90       	pop	r12
    a10c:	08 95       	ret

0000a10e <sendMessage32>:
	_uart(1, 1,0x02);
}



void sendMessage32(){//Msg32: <01>[ID][Seq][SrcIP][DestIP][MsgCode][FIP][PaymentType][Ref1][Ref2][Ref3][Ref4]<02>
    a10e:	0f 93       	push	r16
    a110:	1f 93       	push	r17
    a112:	df 93       	push	r29
    a114:	cf 93       	push	r28
    a116:	cd b7       	in	r28, 0x3d	; 61
    a118:	de b7       	in	r29, 0x3e	; 62
    a11a:	c0 55       	subi	r28, 0x50	; 80
    a11c:	d0 40       	sbci	r29, 0x00	; 0
    a11e:	0f b6       	in	r0, 0x3f	; 63
    a120:	f8 94       	cli
    a122:	de bf       	out	0x3e, r29	; 62
    a124:	0f be       	out	0x3f, r0	; 63
    a126:	cd bf       	out	0x3d, r28	; 61
	char strSend[80];
	UpdateIFT_ID(); //ReadIFT_ID
    a128:	0e 94 71 1b 	call	0x36e2	; 0x36e2 <UpdateIFT_ID>
	UpdateSeqNum(); //UpdateSeqNum SeqNum++
    a12c:	0e 94 46 1b 	call	0x368c	; 0x368c <UpdateSeqNum>
	UpdateClientIP();//ReadSourceIP
    a130:	0e 94 3b 1f 	call	0x3e76	; 0x3e76 <UpdateClientIP>
	UpdateServerIP();//ReadDestIP
    a134:	0e 94 d3 1e 	call	0x3da6	; 0x3da6 <UpdateServerIP>
	_uart(1, 1,0x01);
    a138:	81 e0       	ldi	r24, 0x01	; 1
    a13a:	61 e0       	ldi	r22, 0x01	; 1
    a13c:	41 e0       	ldi	r20, 0x01	; 1
    a13e:	0e 94 53 b2 	call	0x164a6	; 0x164a6 <_uart>
	sprintf_P(strSend,PSTR("%s%s%s%s32"),strIFT_ID,strSeqNum,strClientIP,strServerIP);
    a142:	8d b7       	in	r24, 0x3d	; 61
    a144:	9e b7       	in	r25, 0x3e	; 62
    a146:	0c 97       	sbiw	r24, 0x0c	; 12
    a148:	0f b6       	in	r0, 0x3f	; 63
    a14a:	f8 94       	cli
    a14c:	9e bf       	out	0x3e, r25	; 62
    a14e:	0f be       	out	0x3f, r0	; 63
    a150:	8d bf       	out	0x3d, r24	; 61
    a152:	ed b7       	in	r30, 0x3d	; 61
    a154:	fe b7       	in	r31, 0x3e	; 62
    a156:	31 96       	adiw	r30, 0x01	; 1
    a158:	8e 01       	movw	r16, r28
    a15a:	0f 5f       	subi	r16, 0xFF	; 255
    a15c:	1f 4f       	sbci	r17, 0xFF	; 255
    a15e:	ad b7       	in	r26, 0x3d	; 61
    a160:	be b7       	in	r27, 0x3e	; 62
    a162:	12 96       	adiw	r26, 0x02	; 2
    a164:	1c 93       	st	X, r17
    a166:	0e 93       	st	-X, r16
    a168:	11 97       	sbiw	r26, 0x01	; 1
    a16a:	85 e9       	ldi	r24, 0x95	; 149
    a16c:	91 e2       	ldi	r25, 0x21	; 33
    a16e:	93 83       	std	Z+3, r25	; 0x03
    a170:	82 83       	std	Z+2, r24	; 0x02
    a172:	8b ef       	ldi	r24, 0xFB	; 251
    a174:	94 e0       	ldi	r25, 0x04	; 4
    a176:	95 83       	std	Z+5, r25	; 0x05
    a178:	84 83       	std	Z+4, r24	; 0x04
    a17a:	87 e0       	ldi	r24, 0x07	; 7
    a17c:	9d e0       	ldi	r25, 0x0D	; 13
    a17e:	97 83       	std	Z+7, r25	; 0x07
    a180:	86 83       	std	Z+6, r24	; 0x06
    a182:	8d ee       	ldi	r24, 0xED	; 237
    a184:	98 e0       	ldi	r25, 0x08	; 8
    a186:	91 87       	std	Z+9, r25	; 0x09
    a188:	80 87       	std	Z+8, r24	; 0x08
    a18a:	8a e1       	ldi	r24, 0x1A	; 26
    a18c:	99 e0       	ldi	r25, 0x09	; 9
    a18e:	93 87       	std	Z+11, r25	; 0x0b
    a190:	82 87       	std	Z+10, r24	; 0x0a
    a192:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    _uart_print(1, 0,strSend);
    a196:	ed b7       	in	r30, 0x3d	; 61
    a198:	fe b7       	in	r31, 0x3e	; 62
    a19a:	3c 96       	adiw	r30, 0x0c	; 12
    a19c:	0f b6       	in	r0, 0x3f	; 63
    a19e:	f8 94       	cli
    a1a0:	fe bf       	out	0x3e, r31	; 62
    a1a2:	0f be       	out	0x3f, r0	; 63
    a1a4:	ed bf       	out	0x3d, r30	; 61
    a1a6:	81 e0       	ldi	r24, 0x01	; 1
    a1a8:	60 e0       	ldi	r22, 0x00	; 0
    a1aa:	a8 01       	movw	r20, r16
    a1ac:	0e 94 70 b2 	call	0x164e0	; 0x164e0 <_uart_print>
	sprintf_P(strSend,PSTR("%s%s%s%s"),strFIP_ID,strPaymentType,strRef1,strRef2);
    a1b0:	8d b7       	in	r24, 0x3d	; 61
    a1b2:	9e b7       	in	r25, 0x3e	; 62
    a1b4:	0c 97       	sbiw	r24, 0x0c	; 12
    a1b6:	0f b6       	in	r0, 0x3f	; 63
    a1b8:	f8 94       	cli
    a1ba:	9e bf       	out	0x3e, r25	; 62
    a1bc:	0f be       	out	0x3f, r0	; 63
    a1be:	8d bf       	out	0x3d, r24	; 61
    a1c0:	ed b7       	in	r30, 0x3d	; 61
    a1c2:	fe b7       	in	r31, 0x3e	; 62
    a1c4:	31 96       	adiw	r30, 0x01	; 1
    a1c6:	ad b7       	in	r26, 0x3d	; 61
    a1c8:	be b7       	in	r27, 0x3e	; 62
    a1ca:	12 96       	adiw	r26, 0x02	; 2
    a1cc:	1c 93       	st	X, r17
    a1ce:	0e 93       	st	-X, r16
    a1d0:	11 97       	sbiw	r26, 0x01	; 1
    a1d2:	8c e8       	ldi	r24, 0x8C	; 140
    a1d4:	91 e2       	ldi	r25, 0x21	; 33
    a1d6:	93 83       	std	Z+3, r25	; 0x03
    a1d8:	82 83       	std	Z+2, r24	; 0x02
    a1da:	8b ec       	ldi	r24, 0xCB	; 203
    a1dc:	98 e0       	ldi	r25, 0x08	; 8
    a1de:	95 83       	std	Z+5, r25	; 0x05
    a1e0:	84 83       	std	Z+4, r24	; 0x04
    a1e2:	82 e6       	ldi	r24, 0x62	; 98
    a1e4:	98 e0       	ldi	r25, 0x08	; 8
    a1e6:	97 83       	std	Z+7, r25	; 0x07
    a1e8:	86 83       	std	Z+6, r24	; 0x06
    a1ea:	85 ec       	ldi	r24, 0xC5	; 197
    a1ec:	9d e0       	ldi	r25, 0x0D	; 13
    a1ee:	91 87       	std	Z+9, r25	; 0x09
    a1f0:	80 87       	std	Z+8, r24	; 0x08
    a1f2:	82 ed       	ldi	r24, 0xD2	; 210
    a1f4:	9c e0       	ldi	r25, 0x0C	; 12
    a1f6:	93 87       	std	Z+11, r25	; 0x0b
    a1f8:	82 87       	std	Z+10, r24	; 0x0a
    a1fa:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    _uart_print(1, 0,strSend);
    a1fe:	ed b7       	in	r30, 0x3d	; 61
    a200:	fe b7       	in	r31, 0x3e	; 62
    a202:	3c 96       	adiw	r30, 0x0c	; 12
    a204:	0f b6       	in	r0, 0x3f	; 63
    a206:	f8 94       	cli
    a208:	fe bf       	out	0x3e, r31	; 62
    a20a:	0f be       	out	0x3f, r0	; 63
    a20c:	ed bf       	out	0x3d, r30	; 61
    a20e:	81 e0       	ldi	r24, 0x01	; 1
    a210:	60 e0       	ldi	r22, 0x00	; 0
    a212:	a8 01       	movw	r20, r16
    a214:	0e 94 70 b2 	call	0x164e0	; 0x164e0 <_uart_print>
	sprintf_P(strSend,PSTR("%s%s"),strRef3,strRef4);
    a218:	8d b7       	in	r24, 0x3d	; 61
    a21a:	9e b7       	in	r25, 0x3e	; 62
    a21c:	08 97       	sbiw	r24, 0x08	; 8
    a21e:	0f b6       	in	r0, 0x3f	; 63
    a220:	f8 94       	cli
    a222:	9e bf       	out	0x3e, r25	; 62
    a224:	0f be       	out	0x3f, r0	; 63
    a226:	8d bf       	out	0x3d, r24	; 61
    a228:	ed b7       	in	r30, 0x3d	; 61
    a22a:	fe b7       	in	r31, 0x3e	; 62
    a22c:	31 96       	adiw	r30, 0x01	; 1
    a22e:	ad b7       	in	r26, 0x3d	; 61
    a230:	be b7       	in	r27, 0x3e	; 62
    a232:	12 96       	adiw	r26, 0x02	; 2
    a234:	1c 93       	st	X, r17
    a236:	0e 93       	st	-X, r16
    a238:	11 97       	sbiw	r26, 0x01	; 1
    a23a:	87 e8       	ldi	r24, 0x87	; 135
    a23c:	91 e2       	ldi	r25, 0x21	; 33
    a23e:	93 83       	std	Z+3, r25	; 0x03
    a240:	82 83       	std	Z+2, r24	; 0x02
    a242:	81 eb       	ldi	r24, 0xB1	; 177
    a244:	99 e0       	ldi	r25, 0x09	; 9
    a246:	95 83       	std	Z+5, r25	; 0x05
    a248:	84 83       	std	Z+4, r24	; 0x04
    a24a:	84 eb       	ldi	r24, 0xB4	; 180
    a24c:	94 e0       	ldi	r25, 0x04	; 4
    a24e:	97 83       	std	Z+7, r25	; 0x07
    a250:	86 83       	std	Z+6, r24	; 0x06
    a252:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    _uart_print(1, 0,strSend);
    a256:	ed b7       	in	r30, 0x3d	; 61
    a258:	fe b7       	in	r31, 0x3e	; 62
    a25a:	38 96       	adiw	r30, 0x08	; 8
    a25c:	0f b6       	in	r0, 0x3f	; 63
    a25e:	f8 94       	cli
    a260:	fe bf       	out	0x3e, r31	; 62
    a262:	0f be       	out	0x3f, r0	; 63
    a264:	ed bf       	out	0x3d, r30	; 61
    a266:	81 e0       	ldi	r24, 0x01	; 1
    a268:	60 e0       	ldi	r22, 0x00	; 0
    a26a:	a8 01       	movw	r20, r16
    a26c:	0e 94 70 b2 	call	0x164e0	; 0x164e0 <_uart_print>
	sprintf_P(strSend,PSTR("F968CFFB"));
    a270:	00 d0       	rcall	.+0      	; 0xa272 <sendMessage32+0x164>
    a272:	00 d0       	rcall	.+0      	; 0xa274 <sendMessage32+0x166>
    a274:	ad b7       	in	r26, 0x3d	; 61
    a276:	be b7       	in	r27, 0x3e	; 62
    a278:	12 96       	adiw	r26, 0x02	; 2
    a27a:	1c 93       	st	X, r17
    a27c:	0e 93       	st	-X, r16
    a27e:	11 97       	sbiw	r26, 0x01	; 1
    a280:	8e e7       	ldi	r24, 0x7E	; 126
    a282:	91 e2       	ldi	r25, 0x21	; 33
    a284:	14 96       	adiw	r26, 0x04	; 4
    a286:	9c 93       	st	X, r25
    a288:	8e 93       	st	-X, r24
    a28a:	13 97       	sbiw	r26, 0x03	; 3
    a28c:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    _uart_print(1, 0,strSend);
    a290:	0f 90       	pop	r0
    a292:	0f 90       	pop	r0
    a294:	0f 90       	pop	r0
    a296:	0f 90       	pop	r0
    a298:	81 e0       	ldi	r24, 0x01	; 1
    a29a:	60 e0       	ldi	r22, 0x00	; 0
    a29c:	a8 01       	movw	r20, r16
    a29e:	0e 94 70 b2 	call	0x164e0	; 0x164e0 <_uart_print>
	_uart(1, 1,0x02);
    a2a2:	81 e0       	ldi	r24, 0x01	; 1
    a2a4:	61 e0       	ldi	r22, 0x01	; 1
    a2a6:	42 e0       	ldi	r20, 0x02	; 2
    a2a8:	0e 94 53 b2 	call	0x164a6	; 0x164a6 <_uart>

}
    a2ac:	c0 5b       	subi	r28, 0xB0	; 176
    a2ae:	df 4f       	sbci	r29, 0xFF	; 255
    a2b0:	0f b6       	in	r0, 0x3f	; 63
    a2b2:	f8 94       	cli
    a2b4:	de bf       	out	0x3e, r29	; 62
    a2b6:	0f be       	out	0x3f, r0	; 63
    a2b8:	cd bf       	out	0x3d, r28	; 61
    a2ba:	cf 91       	pop	r28
    a2bc:	df 91       	pop	r29
    a2be:	1f 91       	pop	r17
    a2c0:	0f 91       	pop	r16
    a2c2:	08 95       	ret

0000a2c4 <sendMessage28>:
	sprintf_P(strSend,PSTR("%s%sF968CFFB"),strCardID,strFIP_ID);
    _uart_print(1, 0,strSend);
	_uart(1, 1,0x02);
}

void sendMessage28(){//Msg28: <01>[0103192.168.016.070192.168.016.18024[FIP][CardID]F968CFFB]<02>
    a2c4:	0f 93       	push	r16
    a2c6:	1f 93       	push	r17
    a2c8:	df 93       	push	r29
    a2ca:	cf 93       	push	r28
    a2cc:	cd b7       	in	r28, 0x3d	; 61
    a2ce:	de b7       	in	r29, 0x3e	; 62
    a2d0:	ec 97       	sbiw	r28, 0x3c	; 60
    a2d2:	0f b6       	in	r0, 0x3f	; 63
    a2d4:	f8 94       	cli
    a2d6:	de bf       	out	0x3e, r29	; 62
    a2d8:	0f be       	out	0x3f, r0	; 63
    a2da:	cd bf       	out	0x3d, r28	; 61
	char strSend[60];
	_uart(1, 1,0x01);
    a2dc:	81 e0       	ldi	r24, 0x01	; 1
    a2de:	61 e0       	ldi	r22, 0x01	; 1
    a2e0:	41 e0       	ldi	r20, 0x01	; 1
    a2e2:	0e 94 53 b2 	call	0x164a6	; 0x164a6 <_uart>
	UpdateIFT_ID(); //ReadIFT_ID
    a2e6:	0e 94 71 1b 	call	0x36e2	; 0x36e2 <UpdateIFT_ID>
	UpdateSeqNum(); //UpdateSeqNum SeqNum++
    a2ea:	0e 94 46 1b 	call	0x368c	; 0x368c <UpdateSeqNum>
	UpdateClientIP();//ReadSourceIP
    a2ee:	0e 94 3b 1f 	call	0x3e76	; 0x3e76 <UpdateClientIP>
	UpdateServerIP();//ReadDestIP
    a2f2:	0e 94 d3 1e 	call	0x3da6	; 0x3da6 <UpdateServerIP>
	sprintf_P(strSend,PSTR("%s%s%s%s28"),strIFT_ID,strSeqNum,strClientIP,strServerIP);
    a2f6:	8d b7       	in	r24, 0x3d	; 61
    a2f8:	9e b7       	in	r25, 0x3e	; 62
    a2fa:	0c 97       	sbiw	r24, 0x0c	; 12
    a2fc:	0f b6       	in	r0, 0x3f	; 63
    a2fe:	f8 94       	cli
    a300:	9e bf       	out	0x3e, r25	; 62
    a302:	0f be       	out	0x3f, r0	; 63
    a304:	8d bf       	out	0x3d, r24	; 61
    a306:	ed b7       	in	r30, 0x3d	; 61
    a308:	fe b7       	in	r31, 0x3e	; 62
    a30a:	31 96       	adiw	r30, 0x01	; 1
    a30c:	8e 01       	movw	r16, r28
    a30e:	0f 5f       	subi	r16, 0xFF	; 255
    a310:	1f 4f       	sbci	r17, 0xFF	; 255
    a312:	ad b7       	in	r26, 0x3d	; 61
    a314:	be b7       	in	r27, 0x3e	; 62
    a316:	12 96       	adiw	r26, 0x02	; 2
    a318:	1c 93       	st	X, r17
    a31a:	0e 93       	st	-X, r16
    a31c:	11 97       	sbiw	r26, 0x01	; 1
    a31e:	8d ea       	ldi	r24, 0xAD	; 173
    a320:	91 e2       	ldi	r25, 0x21	; 33
    a322:	93 83       	std	Z+3, r25	; 0x03
    a324:	82 83       	std	Z+2, r24	; 0x02
    a326:	8b ef       	ldi	r24, 0xFB	; 251
    a328:	94 e0       	ldi	r25, 0x04	; 4
    a32a:	95 83       	std	Z+5, r25	; 0x05
    a32c:	84 83       	std	Z+4, r24	; 0x04
    a32e:	87 e0       	ldi	r24, 0x07	; 7
    a330:	9d e0       	ldi	r25, 0x0D	; 13
    a332:	97 83       	std	Z+7, r25	; 0x07
    a334:	86 83       	std	Z+6, r24	; 0x06
    a336:	8d ee       	ldi	r24, 0xED	; 237
    a338:	98 e0       	ldi	r25, 0x08	; 8
    a33a:	91 87       	std	Z+9, r25	; 0x09
    a33c:	80 87       	std	Z+8, r24	; 0x08
    a33e:	8a e1       	ldi	r24, 0x1A	; 26
    a340:	99 e0       	ldi	r25, 0x09	; 9
    a342:	93 87       	std	Z+11, r25	; 0x0b
    a344:	82 87       	std	Z+10, r24	; 0x0a
    a346:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    _uart_print(1, 0,strSend);
    a34a:	8d b7       	in	r24, 0x3d	; 61
    a34c:	9e b7       	in	r25, 0x3e	; 62
    a34e:	0c 96       	adiw	r24, 0x0c	; 12
    a350:	0f b6       	in	r0, 0x3f	; 63
    a352:	f8 94       	cli
    a354:	9e bf       	out	0x3e, r25	; 62
    a356:	0f be       	out	0x3f, r0	; 63
    a358:	8d bf       	out	0x3d, r24	; 61
    a35a:	81 e0       	ldi	r24, 0x01	; 1
    a35c:	60 e0       	ldi	r22, 0x00	; 0
    a35e:	a8 01       	movw	r20, r16
    a360:	0e 94 70 b2 	call	0x164e0	; 0x164e0 <_uart_print>
	UpdateCardID();
    a364:	0e 94 ad 3f 	call	0x7f5a	; 0x7f5a <UpdateCardID>
	sprintf_P(strSend,PSTR("%s%sF968CFFB"),strFIP_ID,strCardID);
    a368:	ad b7       	in	r26, 0x3d	; 61
    a36a:	be b7       	in	r27, 0x3e	; 62
    a36c:	18 97       	sbiw	r26, 0x08	; 8
    a36e:	0f b6       	in	r0, 0x3f	; 63
    a370:	f8 94       	cli
    a372:	be bf       	out	0x3e, r27	; 62
    a374:	0f be       	out	0x3f, r0	; 63
    a376:	ad bf       	out	0x3d, r26	; 61
    a378:	ed b7       	in	r30, 0x3d	; 61
    a37a:	fe b7       	in	r31, 0x3e	; 62
    a37c:	31 96       	adiw	r30, 0x01	; 1
    a37e:	12 96       	adiw	r26, 0x02	; 2
    a380:	1c 93       	st	X, r17
    a382:	0e 93       	st	-X, r16
    a384:	11 97       	sbiw	r26, 0x01	; 1
    a386:	80 ea       	ldi	r24, 0xA0	; 160
    a388:	91 e2       	ldi	r25, 0x21	; 33
    a38a:	93 83       	std	Z+3, r25	; 0x03
    a38c:	82 83       	std	Z+2, r24	; 0x02
    a38e:	8b ec       	ldi	r24, 0xCB	; 203
    a390:	98 e0       	ldi	r25, 0x08	; 8
    a392:	95 83       	std	Z+5, r25	; 0x05
    a394:	84 83       	std	Z+4, r24	; 0x04
    a396:	8d eb       	ldi	r24, 0xBD	; 189
    a398:	9c e0       	ldi	r25, 0x0C	; 12
    a39a:	97 83       	std	Z+7, r25	; 0x07
    a39c:	86 83       	std	Z+6, r24	; 0x06
    a39e:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    _uart_print(1, 0,strSend);
    a3a2:	8d b7       	in	r24, 0x3d	; 61
    a3a4:	9e b7       	in	r25, 0x3e	; 62
    a3a6:	08 96       	adiw	r24, 0x08	; 8
    a3a8:	0f b6       	in	r0, 0x3f	; 63
    a3aa:	f8 94       	cli
    a3ac:	9e bf       	out	0x3e, r25	; 62
    a3ae:	0f be       	out	0x3f, r0	; 63
    a3b0:	8d bf       	out	0x3d, r24	; 61
    a3b2:	81 e0       	ldi	r24, 0x01	; 1
    a3b4:	60 e0       	ldi	r22, 0x00	; 0
    a3b6:	a8 01       	movw	r20, r16
    a3b8:	0e 94 70 b2 	call	0x164e0	; 0x164e0 <_uart_print>
	_uart(1, 1,0x02);
    a3bc:	81 e0       	ldi	r24, 0x01	; 1
    a3be:	61 e0       	ldi	r22, 0x01	; 1
    a3c0:	42 e0       	ldi	r20, 0x02	; 2
    a3c2:	0e 94 53 b2 	call	0x164a6	; 0x164a6 <_uart>
}
    a3c6:	ec 96       	adiw	r28, 0x3c	; 60
    a3c8:	0f b6       	in	r0, 0x3f	; 63
    a3ca:	f8 94       	cli
    a3cc:	de bf       	out	0x3e, r29	; 62
    a3ce:	0f be       	out	0x3f, r0	; 63
    a3d0:	cd bf       	out	0x3d, r28	; 61
    a3d2:	cf 91       	pop	r28
    a3d4:	df 91       	pop	r29
    a3d6:	1f 91       	pop	r17
    a3d8:	0f 91       	pop	r16
    a3da:	08 95       	ret

0000a3dc <sendMessage24>:
	sprintf_P(strSend,PSTR("%sF968CFFB"),strCardID);
    _uart_print(1, 0,strSend);
	_uart(1, 1,0x02);
}

void sendMessage24(){//Msg24: <01>[0103192.168.016.070192.168.016.18022[CardID]F968CFFB]<02>
    a3dc:	0f 93       	push	r16
    a3de:	1f 93       	push	r17
    a3e0:	df 93       	push	r29
    a3e2:	cf 93       	push	r28
    a3e4:	cd b7       	in	r28, 0x3d	; 61
    a3e6:	de b7       	in	r29, 0x3e	; 62
    a3e8:	ec 97       	sbiw	r28, 0x3c	; 60
    a3ea:	0f b6       	in	r0, 0x3f	; 63
    a3ec:	f8 94       	cli
    a3ee:	de bf       	out	0x3e, r29	; 62
    a3f0:	0f be       	out	0x3f, r0	; 63
    a3f2:	cd bf       	out	0x3d, r28	; 61
	char strSend[60];
	_uart(1, 1,0x01);
    a3f4:	81 e0       	ldi	r24, 0x01	; 1
    a3f6:	61 e0       	ldi	r22, 0x01	; 1
    a3f8:	41 e0       	ldi	r20, 0x01	; 1
    a3fa:	0e 94 53 b2 	call	0x164a6	; 0x164a6 <_uart>
	UpdateIFT_ID(); //ReadIFT_ID
    a3fe:	0e 94 71 1b 	call	0x36e2	; 0x36e2 <UpdateIFT_ID>
	UpdateSeqNum(); //UpdateSeqNum SeqNum++
    a402:	0e 94 46 1b 	call	0x368c	; 0x368c <UpdateSeqNum>
	UpdateClientIP();//ReadSourceIP
    a406:	0e 94 3b 1f 	call	0x3e76	; 0x3e76 <UpdateClientIP>
	UpdateServerIP();//ReadDestIP
    a40a:	0e 94 d3 1e 	call	0x3da6	; 0x3da6 <UpdateServerIP>
	sprintf_P(strSend,PSTR("%s%s%s%s24"),strIFT_ID,strSeqNum,strClientIP,strServerIP);
    a40e:	8d b7       	in	r24, 0x3d	; 61
    a410:	9e b7       	in	r25, 0x3e	; 62
    a412:	0c 97       	sbiw	r24, 0x0c	; 12
    a414:	0f b6       	in	r0, 0x3f	; 63
    a416:	f8 94       	cli
    a418:	9e bf       	out	0x3e, r25	; 62
    a41a:	0f be       	out	0x3f, r0	; 63
    a41c:	8d bf       	out	0x3d, r24	; 61
    a41e:	ed b7       	in	r30, 0x3d	; 61
    a420:	fe b7       	in	r31, 0x3e	; 62
    a422:	31 96       	adiw	r30, 0x01	; 1
    a424:	8e 01       	movw	r16, r28
    a426:	0f 5f       	subi	r16, 0xFF	; 255
    a428:	1f 4f       	sbci	r17, 0xFF	; 255
    a42a:	ad b7       	in	r26, 0x3d	; 61
    a42c:	be b7       	in	r27, 0x3e	; 62
    a42e:	12 96       	adiw	r26, 0x02	; 2
    a430:	1c 93       	st	X, r17
    a432:	0e 93       	st	-X, r16
    a434:	11 97       	sbiw	r26, 0x01	; 1
    a436:	85 ec       	ldi	r24, 0xC5	; 197
    a438:	91 e2       	ldi	r25, 0x21	; 33
    a43a:	93 83       	std	Z+3, r25	; 0x03
    a43c:	82 83       	std	Z+2, r24	; 0x02
    a43e:	8b ef       	ldi	r24, 0xFB	; 251
    a440:	94 e0       	ldi	r25, 0x04	; 4
    a442:	95 83       	std	Z+5, r25	; 0x05
    a444:	84 83       	std	Z+4, r24	; 0x04
    a446:	87 e0       	ldi	r24, 0x07	; 7
    a448:	9d e0       	ldi	r25, 0x0D	; 13
    a44a:	97 83       	std	Z+7, r25	; 0x07
    a44c:	86 83       	std	Z+6, r24	; 0x06
    a44e:	8d ee       	ldi	r24, 0xED	; 237
    a450:	98 e0       	ldi	r25, 0x08	; 8
    a452:	91 87       	std	Z+9, r25	; 0x09
    a454:	80 87       	std	Z+8, r24	; 0x08
    a456:	8a e1       	ldi	r24, 0x1A	; 26
    a458:	99 e0       	ldi	r25, 0x09	; 9
    a45a:	93 87       	std	Z+11, r25	; 0x0b
    a45c:	82 87       	std	Z+10, r24	; 0x0a
    a45e:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    _uart_print(1, 0,strSend);
    a462:	8d b7       	in	r24, 0x3d	; 61
    a464:	9e b7       	in	r25, 0x3e	; 62
    a466:	0c 96       	adiw	r24, 0x0c	; 12
    a468:	0f b6       	in	r0, 0x3f	; 63
    a46a:	f8 94       	cli
    a46c:	9e bf       	out	0x3e, r25	; 62
    a46e:	0f be       	out	0x3f, r0	; 63
    a470:	8d bf       	out	0x3d, r24	; 61
    a472:	81 e0       	ldi	r24, 0x01	; 1
    a474:	60 e0       	ldi	r22, 0x00	; 0
    a476:	a8 01       	movw	r20, r16
    a478:	0e 94 70 b2 	call	0x164e0	; 0x164e0 <_uart_print>
	UpdateCardID();
    a47c:	0e 94 ad 3f 	call	0x7f5a	; 0x7f5a <UpdateCardID>
	sprintf_P(strSend,PSTR("%s%sF968CFFB"),strCardID,strFIP_ID);
    a480:	ad b7       	in	r26, 0x3d	; 61
    a482:	be b7       	in	r27, 0x3e	; 62
    a484:	18 97       	sbiw	r26, 0x08	; 8
    a486:	0f b6       	in	r0, 0x3f	; 63
    a488:	f8 94       	cli
    a48a:	be bf       	out	0x3e, r27	; 62
    a48c:	0f be       	out	0x3f, r0	; 63
    a48e:	ad bf       	out	0x3d, r26	; 61
    a490:	ed b7       	in	r30, 0x3d	; 61
    a492:	fe b7       	in	r31, 0x3e	; 62
    a494:	31 96       	adiw	r30, 0x01	; 1
    a496:	12 96       	adiw	r26, 0x02	; 2
    a498:	1c 93       	st	X, r17
    a49a:	0e 93       	st	-X, r16
    a49c:	11 97       	sbiw	r26, 0x01	; 1
    a49e:	88 eb       	ldi	r24, 0xB8	; 184
    a4a0:	91 e2       	ldi	r25, 0x21	; 33
    a4a2:	93 83       	std	Z+3, r25	; 0x03
    a4a4:	82 83       	std	Z+2, r24	; 0x02
    a4a6:	8d eb       	ldi	r24, 0xBD	; 189
    a4a8:	9c e0       	ldi	r25, 0x0C	; 12
    a4aa:	95 83       	std	Z+5, r25	; 0x05
    a4ac:	84 83       	std	Z+4, r24	; 0x04
    a4ae:	8b ec       	ldi	r24, 0xCB	; 203
    a4b0:	98 e0       	ldi	r25, 0x08	; 8
    a4b2:	97 83       	std	Z+7, r25	; 0x07
    a4b4:	86 83       	std	Z+6, r24	; 0x06
    a4b6:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    _uart_print(1, 0,strSend);
    a4ba:	8d b7       	in	r24, 0x3d	; 61
    a4bc:	9e b7       	in	r25, 0x3e	; 62
    a4be:	08 96       	adiw	r24, 0x08	; 8
    a4c0:	0f b6       	in	r0, 0x3f	; 63
    a4c2:	f8 94       	cli
    a4c4:	9e bf       	out	0x3e, r25	; 62
    a4c6:	0f be       	out	0x3f, r0	; 63
    a4c8:	8d bf       	out	0x3d, r24	; 61
    a4ca:	81 e0       	ldi	r24, 0x01	; 1
    a4cc:	60 e0       	ldi	r22, 0x00	; 0
    a4ce:	a8 01       	movw	r20, r16
    a4d0:	0e 94 70 b2 	call	0x164e0	; 0x164e0 <_uart_print>
	_uart(1, 1,0x02);
    a4d4:	81 e0       	ldi	r24, 0x01	; 1
    a4d6:	61 e0       	ldi	r22, 0x01	; 1
    a4d8:	42 e0       	ldi	r20, 0x02	; 2
    a4da:	0e 94 53 b2 	call	0x164a6	; 0x164a6 <_uart>
}
    a4de:	ec 96       	adiw	r28, 0x3c	; 60
    a4e0:	0f b6       	in	r0, 0x3f	; 63
    a4e2:	f8 94       	cli
    a4e4:	de bf       	out	0x3e, r29	; 62
    a4e6:	0f be       	out	0x3f, r0	; 63
    a4e8:	cd bf       	out	0x3d, r28	; 61
    a4ea:	cf 91       	pop	r28
    a4ec:	df 91       	pop	r29
    a4ee:	1f 91       	pop	r17
    a4f0:	0f 91       	pop	r16
    a4f2:	08 95       	ret

0000a4f4 <sendMessage22>:
    _uart_print(1, 0,strSend);
	_uart(1, 1,0x02);
	IsNewPacket=True;
}

void sendMessage22(){//Msg22: <01>[0103192.168.016.070192.168.016.18022[CardID]F968CFFB]<02>
    a4f4:	0f 93       	push	r16
    a4f6:	1f 93       	push	r17
    a4f8:	df 93       	push	r29
    a4fa:	cf 93       	push	r28
    a4fc:	cd b7       	in	r28, 0x3d	; 61
    a4fe:	de b7       	in	r29, 0x3e	; 62
    a500:	ec 97       	sbiw	r28, 0x3c	; 60
    a502:	0f b6       	in	r0, 0x3f	; 63
    a504:	f8 94       	cli
    a506:	de bf       	out	0x3e, r29	; 62
    a508:	0f be       	out	0x3f, r0	; 63
    a50a:	cd bf       	out	0x3d, r28	; 61
	char strSend[60];
	_uart(1, 1,0x01);
    a50c:	81 e0       	ldi	r24, 0x01	; 1
    a50e:	61 e0       	ldi	r22, 0x01	; 1
    a510:	41 e0       	ldi	r20, 0x01	; 1
    a512:	0e 94 53 b2 	call	0x164a6	; 0x164a6 <_uart>
	UpdateIFT_ID(); //ReadIFT_ID
    a516:	0e 94 71 1b 	call	0x36e2	; 0x36e2 <UpdateIFT_ID>
	UpdateSeqNum(); //UpdateSeqNum SeqNum++
    a51a:	0e 94 46 1b 	call	0x368c	; 0x368c <UpdateSeqNum>
	UpdateClientIP();//ReadSourceIP
    a51e:	0e 94 3b 1f 	call	0x3e76	; 0x3e76 <UpdateClientIP>
	UpdateServerIP();//ReadDestIP
    a522:	0e 94 d3 1e 	call	0x3da6	; 0x3da6 <UpdateServerIP>
	sprintf_P(strSend,PSTR("%s%s%s%s22"),strIFT_ID,strSeqNum,strClientIP,strServerIP);
    a526:	8d b7       	in	r24, 0x3d	; 61
    a528:	9e b7       	in	r25, 0x3e	; 62
    a52a:	0c 97       	sbiw	r24, 0x0c	; 12
    a52c:	0f b6       	in	r0, 0x3f	; 63
    a52e:	f8 94       	cli
    a530:	9e bf       	out	0x3e, r25	; 62
    a532:	0f be       	out	0x3f, r0	; 63
    a534:	8d bf       	out	0x3d, r24	; 61
    a536:	ed b7       	in	r30, 0x3d	; 61
    a538:	fe b7       	in	r31, 0x3e	; 62
    a53a:	31 96       	adiw	r30, 0x01	; 1
    a53c:	8e 01       	movw	r16, r28
    a53e:	0f 5f       	subi	r16, 0xFF	; 255
    a540:	1f 4f       	sbci	r17, 0xFF	; 255
    a542:	ad b7       	in	r26, 0x3d	; 61
    a544:	be b7       	in	r27, 0x3e	; 62
    a546:	12 96       	adiw	r26, 0x02	; 2
    a548:	1c 93       	st	X, r17
    a54a:	0e 93       	st	-X, r16
    a54c:	11 97       	sbiw	r26, 0x01	; 1
    a54e:	8b ed       	ldi	r24, 0xDB	; 219
    a550:	91 e2       	ldi	r25, 0x21	; 33
    a552:	93 83       	std	Z+3, r25	; 0x03
    a554:	82 83       	std	Z+2, r24	; 0x02
    a556:	8b ef       	ldi	r24, 0xFB	; 251
    a558:	94 e0       	ldi	r25, 0x04	; 4
    a55a:	95 83       	std	Z+5, r25	; 0x05
    a55c:	84 83       	std	Z+4, r24	; 0x04
    a55e:	87 e0       	ldi	r24, 0x07	; 7
    a560:	9d e0       	ldi	r25, 0x0D	; 13
    a562:	97 83       	std	Z+7, r25	; 0x07
    a564:	86 83       	std	Z+6, r24	; 0x06
    a566:	8d ee       	ldi	r24, 0xED	; 237
    a568:	98 e0       	ldi	r25, 0x08	; 8
    a56a:	91 87       	std	Z+9, r25	; 0x09
    a56c:	80 87       	std	Z+8, r24	; 0x08
    a56e:	8a e1       	ldi	r24, 0x1A	; 26
    a570:	99 e0       	ldi	r25, 0x09	; 9
    a572:	93 87       	std	Z+11, r25	; 0x0b
    a574:	82 87       	std	Z+10, r24	; 0x0a
    a576:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    _uart_print(1, 0,strSend);
    a57a:	8d b7       	in	r24, 0x3d	; 61
    a57c:	9e b7       	in	r25, 0x3e	; 62
    a57e:	0c 96       	adiw	r24, 0x0c	; 12
    a580:	0f b6       	in	r0, 0x3f	; 63
    a582:	f8 94       	cli
    a584:	9e bf       	out	0x3e, r25	; 62
    a586:	0f be       	out	0x3f, r0	; 63
    a588:	8d bf       	out	0x3d, r24	; 61
    a58a:	81 e0       	ldi	r24, 0x01	; 1
    a58c:	60 e0       	ldi	r22, 0x00	; 0
    a58e:	a8 01       	movw	r20, r16
    a590:	0e 94 70 b2 	call	0x164e0	; 0x164e0 <_uart_print>
	UpdateCardID();
    a594:	0e 94 ad 3f 	call	0x7f5a	; 0x7f5a <UpdateCardID>
	sprintf_P(strSend,PSTR("%sF968CFFB"),strCardID);
    a598:	00 d0       	rcall	.+0      	; 0xa59a <sendMessage22+0xa6>
    a59a:	00 d0       	rcall	.+0      	; 0xa59c <sendMessage22+0xa8>
    a59c:	00 d0       	rcall	.+0      	; 0xa59e <sendMessage22+0xaa>
    a59e:	ed b7       	in	r30, 0x3d	; 61
    a5a0:	fe b7       	in	r31, 0x3e	; 62
    a5a2:	31 96       	adiw	r30, 0x01	; 1
    a5a4:	ad b7       	in	r26, 0x3d	; 61
    a5a6:	be b7       	in	r27, 0x3e	; 62
    a5a8:	12 96       	adiw	r26, 0x02	; 2
    a5aa:	1c 93       	st	X, r17
    a5ac:	0e 93       	st	-X, r16
    a5ae:	11 97       	sbiw	r26, 0x01	; 1
    a5b0:	80 ed       	ldi	r24, 0xD0	; 208
    a5b2:	91 e2       	ldi	r25, 0x21	; 33
    a5b4:	93 83       	std	Z+3, r25	; 0x03
    a5b6:	82 83       	std	Z+2, r24	; 0x02
    a5b8:	8d eb       	ldi	r24, 0xBD	; 189
    a5ba:	9c e0       	ldi	r25, 0x0C	; 12
    a5bc:	95 83       	std	Z+5, r25	; 0x05
    a5be:	84 83       	std	Z+4, r24	; 0x04
    a5c0:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    _uart_print(1, 0,strSend);
    a5c4:	8d b7       	in	r24, 0x3d	; 61
    a5c6:	9e b7       	in	r25, 0x3e	; 62
    a5c8:	06 96       	adiw	r24, 0x06	; 6
    a5ca:	0f b6       	in	r0, 0x3f	; 63
    a5cc:	f8 94       	cli
    a5ce:	9e bf       	out	0x3e, r25	; 62
    a5d0:	0f be       	out	0x3f, r0	; 63
    a5d2:	8d bf       	out	0x3d, r24	; 61
    a5d4:	81 e0       	ldi	r24, 0x01	; 1
    a5d6:	60 e0       	ldi	r22, 0x00	; 0
    a5d8:	a8 01       	movw	r20, r16
    a5da:	0e 94 70 b2 	call	0x164e0	; 0x164e0 <_uart_print>
	_uart(1, 1,0x02);
    a5de:	81 e0       	ldi	r24, 0x01	; 1
    a5e0:	61 e0       	ldi	r22, 0x01	; 1
    a5e2:	42 e0       	ldi	r20, 0x02	; 2
    a5e4:	0e 94 53 b2 	call	0x164a6	; 0x164a6 <_uart>
}
    a5e8:	ec 96       	adiw	r28, 0x3c	; 60
    a5ea:	0f b6       	in	r0, 0x3f	; 63
    a5ec:	f8 94       	cli
    a5ee:	de bf       	out	0x3e, r29	; 62
    a5f0:	0f be       	out	0x3f, r0	; 63
    a5f2:	cd bf       	out	0x3d, r28	; 61
    a5f4:	cf 91       	pop	r28
    a5f6:	df 91       	pop	r29
    a5f8:	1f 91       	pop	r17
    a5fa:	0f 91       	pop	r16
    a5fc:	08 95       	ret

0000a5fe <sendMessage10>:
     _uart_print(1, 0,strSend);
	 _uart(1, 1,0x02);
}

/*Subrutine Msg10*/
void sendMessage10(){//Msg10: <01>[0103192.168.016.070192.168.016.18010F968CFFB]<02>
    a5fe:	0f 93       	push	r16
    a600:	1f 93       	push	r17
    a602:	df 93       	push	r29
    a604:	cf 93       	push	r28
    a606:	cd b7       	in	r28, 0x3d	; 61
    a608:	de b7       	in	r29, 0x3e	; 62
    a60a:	ec 97       	sbiw	r28, 0x3c	; 60
    a60c:	0f b6       	in	r0, 0x3f	; 63
    a60e:	f8 94       	cli
    a610:	de bf       	out	0x3e, r29	; 62
    a612:	0f be       	out	0x3f, r0	; 63
    a614:	cd bf       	out	0x3d, r28	; 61
	char strSend[60];
	_uart(1, 1,0x01);
    a616:	81 e0       	ldi	r24, 0x01	; 1
    a618:	61 e0       	ldi	r22, 0x01	; 1
    a61a:	41 e0       	ldi	r20, 0x01	; 1
    a61c:	0e 94 53 b2 	call	0x164a6	; 0x164a6 <_uart>
	UpdateIFT_ID(); //ReadIFT_ID
    a620:	0e 94 71 1b 	call	0x36e2	; 0x36e2 <UpdateIFT_ID>
	UpdateSeqNum(); //UpdateSeqNum SeqNum++
    a624:	0e 94 46 1b 	call	0x368c	; 0x368c <UpdateSeqNum>
	UpdateClientIP();//ReadSourceIP
    a628:	0e 94 3b 1f 	call	0x3e76	; 0x3e76 <UpdateClientIP>
	UpdateServerIP();//ReadDestIP
    a62c:	0e 94 d3 1e 	call	0x3da6	; 0x3da6 <UpdateServerIP>
	sprintf_P(strSend,PSTR("%s%s%s%s10F968CFFB"),strIFT_ID,strSeqNum,strClientIP,strServerIP);
    a630:	8d b7       	in	r24, 0x3d	; 61
    a632:	9e b7       	in	r25, 0x3e	; 62
    a634:	0c 97       	sbiw	r24, 0x0c	; 12
    a636:	0f b6       	in	r0, 0x3f	; 63
    a638:	f8 94       	cli
    a63a:	9e bf       	out	0x3e, r25	; 62
    a63c:	0f be       	out	0x3f, r0	; 63
    a63e:	8d bf       	out	0x3d, r24	; 61
    a640:	ed b7       	in	r30, 0x3d	; 61
    a642:	fe b7       	in	r31, 0x3e	; 62
    a644:	31 96       	adiw	r30, 0x01	; 1
    a646:	8e 01       	movw	r16, r28
    a648:	0f 5f       	subi	r16, 0xFF	; 255
    a64a:	1f 4f       	sbci	r17, 0xFF	; 255
    a64c:	ad b7       	in	r26, 0x3d	; 61
    a64e:	be b7       	in	r27, 0x3e	; 62
    a650:	12 96       	adiw	r26, 0x02	; 2
    a652:	1c 93       	st	X, r17
    a654:	0e 93       	st	-X, r16
    a656:	11 97       	sbiw	r26, 0x01	; 1
    a658:	86 ee       	ldi	r24, 0xE6	; 230
    a65a:	91 e2       	ldi	r25, 0x21	; 33
    a65c:	93 83       	std	Z+3, r25	; 0x03
    a65e:	82 83       	std	Z+2, r24	; 0x02
    a660:	8b ef       	ldi	r24, 0xFB	; 251
    a662:	94 e0       	ldi	r25, 0x04	; 4
    a664:	95 83       	std	Z+5, r25	; 0x05
    a666:	84 83       	std	Z+4, r24	; 0x04
    a668:	87 e0       	ldi	r24, 0x07	; 7
    a66a:	9d e0       	ldi	r25, 0x0D	; 13
    a66c:	97 83       	std	Z+7, r25	; 0x07
    a66e:	86 83       	std	Z+6, r24	; 0x06
    a670:	8d ee       	ldi	r24, 0xED	; 237
    a672:	98 e0       	ldi	r25, 0x08	; 8
    a674:	91 87       	std	Z+9, r25	; 0x09
    a676:	80 87       	std	Z+8, r24	; 0x08
    a678:	8a e1       	ldi	r24, 0x1A	; 26
    a67a:	99 e0       	ldi	r25, 0x09	; 9
    a67c:	93 87       	std	Z+11, r25	; 0x0b
    a67e:	82 87       	std	Z+10, r24	; 0x0a
    a680:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    _uart_print(1, 0,strSend);
    a684:	8d b7       	in	r24, 0x3d	; 61
    a686:	9e b7       	in	r25, 0x3e	; 62
    a688:	0c 96       	adiw	r24, 0x0c	; 12
    a68a:	0f b6       	in	r0, 0x3f	; 63
    a68c:	f8 94       	cli
    a68e:	9e bf       	out	0x3e, r25	; 62
    a690:	0f be       	out	0x3f, r0	; 63
    a692:	8d bf       	out	0x3d, r24	; 61
    a694:	81 e0       	ldi	r24, 0x01	; 1
    a696:	60 e0       	ldi	r22, 0x00	; 0
    a698:	a8 01       	movw	r20, r16
    a69a:	0e 94 70 b2 	call	0x164e0	; 0x164e0 <_uart_print>
	_uart(1, 1,0x02);
    a69e:	81 e0       	ldi	r24, 0x01	; 1
    a6a0:	61 e0       	ldi	r22, 0x01	; 1
    a6a2:	42 e0       	ldi	r20, 0x02	; 2
    a6a4:	0e 94 53 b2 	call	0x164a6	; 0x164a6 <_uart>
	IsNewPacket=True;
    a6a8:	81 e0       	ldi	r24, 0x01	; 1
    a6aa:	80 93 8b 01 	sts	0x018B, r24
}
    a6ae:	ec 96       	adiw	r28, 0x3c	; 60
    a6b0:	0f b6       	in	r0, 0x3f	; 63
    a6b2:	f8 94       	cli
    a6b4:	de bf       	out	0x3e, r29	; 62
    a6b6:	0f be       	out	0x3f, r0	; 63
    a6b8:	cd bf       	out	0x3d, r28	; 61
    a6ba:	cf 91       	pop	r28
    a6bc:	df 91       	pop	r29
    a6be:	1f 91       	pop	r17
    a6c0:	0f 91       	pop	r16
    a6c2:	08 95       	ret

0000a6c4 <sendMessage04>:
     

//}

/*Subrutine Msg04*/
void sendMessage04(){   //      <STX>[IFTID][Seq][No][SrceIP][DestIP][MsgCode][ReceiptNo][Value][Checksum][ETX]
    a6c4:	0f 93       	push	r16
    a6c6:	1f 93       	push	r17
    a6c8:	df 93       	push	r29
    a6ca:	cf 93       	push	r28
    a6cc:	cd b7       	in	r28, 0x3d	; 61
    a6ce:	de b7       	in	r29, 0x3e	; 62
    a6d0:	ec 97       	sbiw	r28, 0x3c	; 60
    a6d2:	0f b6       	in	r0, 0x3f	; 63
    a6d4:	f8 94       	cli
    a6d6:	de bf       	out	0x3e, r29	; 62
    a6d8:	0f be       	out	0x3f, r0	; 63
    a6da:	cd bf       	out	0x3d, r28	; 61
                        //Msg04: <01>[01][03][192.168.000.101][192.168.000.001][04][000001]0F968CFFB]<02>
	 char strSend[60];
	 _uart(1, 1,0x01);
    a6dc:	81 e0       	ldi	r24, 0x01	; 1
    a6de:	61 e0       	ldi	r22, 0x01	; 1
    a6e0:	41 e0       	ldi	r20, 0x01	; 1
    a6e2:	0e 94 53 b2 	call	0x164a6	; 0x164a6 <_uart>
	 UpdateIFT_ID(); //ReadIFT_ID
    a6e6:	0e 94 71 1b 	call	0x36e2	; 0x36e2 <UpdateIFT_ID>
	 UpdateSeqNum(); //UpdateSeqNum SeqNum++
    a6ea:	0e 94 46 1b 	call	0x368c	; 0x368c <UpdateSeqNum>
	 UpdateClientIP();//ReadSourceIP
    a6ee:	0e 94 3b 1f 	call	0x3e76	; 0x3e76 <UpdateClientIP>
	 UpdateServerIP();//ReadDestIP
    a6f2:	0e 94 d3 1e 	call	0x3da6	; 0x3da6 <UpdateServerIP>
	 //strTranNo = strReceiptNum
	 sprintf_P(strSend,PSTR("%s%s%s%s04%s1F968CFFB"),strIFT_ID,strSeqNum,strClientIP,strServerIP,strTranNo);
    a6f6:	8d b7       	in	r24, 0x3d	; 61
    a6f8:	9e b7       	in	r25, 0x3e	; 62
    a6fa:	0e 97       	sbiw	r24, 0x0e	; 14
    a6fc:	0f b6       	in	r0, 0x3f	; 63
    a6fe:	f8 94       	cli
    a700:	9e bf       	out	0x3e, r25	; 62
    a702:	0f be       	out	0x3f, r0	; 63
    a704:	8d bf       	out	0x3d, r24	; 61
    a706:	ed b7       	in	r30, 0x3d	; 61
    a708:	fe b7       	in	r31, 0x3e	; 62
    a70a:	31 96       	adiw	r30, 0x01	; 1
    a70c:	8e 01       	movw	r16, r28
    a70e:	0f 5f       	subi	r16, 0xFF	; 255
    a710:	1f 4f       	sbci	r17, 0xFF	; 255
    a712:	ad b7       	in	r26, 0x3d	; 61
    a714:	be b7       	in	r27, 0x3e	; 62
    a716:	12 96       	adiw	r26, 0x02	; 2
    a718:	1c 93       	st	X, r17
    a71a:	0e 93       	st	-X, r16
    a71c:	11 97       	sbiw	r26, 0x01	; 1
    a71e:	89 ef       	ldi	r24, 0xF9	; 249
    a720:	91 e2       	ldi	r25, 0x21	; 33
    a722:	93 83       	std	Z+3, r25	; 0x03
    a724:	82 83       	std	Z+2, r24	; 0x02
    a726:	8b ef       	ldi	r24, 0xFB	; 251
    a728:	94 e0       	ldi	r25, 0x04	; 4
    a72a:	95 83       	std	Z+5, r25	; 0x05
    a72c:	84 83       	std	Z+4, r24	; 0x04
    a72e:	87 e0       	ldi	r24, 0x07	; 7
    a730:	9d e0       	ldi	r25, 0x0D	; 13
    a732:	97 83       	std	Z+7, r25	; 0x07
    a734:	86 83       	std	Z+6, r24	; 0x06
    a736:	8d ee       	ldi	r24, 0xED	; 237
    a738:	98 e0       	ldi	r25, 0x08	; 8
    a73a:	91 87       	std	Z+9, r25	; 0x09
    a73c:	80 87       	std	Z+8, r24	; 0x08
    a73e:	8a e1       	ldi	r24, 0x1A	; 26
    a740:	99 e0       	ldi	r25, 0x09	; 9
    a742:	93 87       	std	Z+11, r25	; 0x0b
    a744:	82 87       	std	Z+10, r24	; 0x0a
    a746:	8e eb       	ldi	r24, 0xBE	; 190
    a748:	9d e0       	ldi	r25, 0x0D	; 13
    a74a:	95 87       	std	Z+13, r25	; 0x0d
    a74c:	84 87       	std	Z+12, r24	; 0x0c
    a74e:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
     _uart_print(1, 0,strSend);
    a752:	8d b7       	in	r24, 0x3d	; 61
    a754:	9e b7       	in	r25, 0x3e	; 62
    a756:	0e 96       	adiw	r24, 0x0e	; 14
    a758:	0f b6       	in	r0, 0x3f	; 63
    a75a:	f8 94       	cli
    a75c:	9e bf       	out	0x3e, r25	; 62
    a75e:	0f be       	out	0x3f, r0	; 63
    a760:	8d bf       	out	0x3d, r24	; 61
    a762:	81 e0       	ldi	r24, 0x01	; 1
    a764:	60 e0       	ldi	r22, 0x00	; 0
    a766:	a8 01       	movw	r20, r16
    a768:	0e 94 70 b2 	call	0x164e0	; 0x164e0 <_uart_print>
	 _uart(1, 1,0x02);
    a76c:	81 e0       	ldi	r24, 0x01	; 1
    a76e:	61 e0       	ldi	r22, 0x01	; 1
    a770:	42 e0       	ldi	r20, 0x02	; 2
    a772:	0e 94 53 b2 	call	0x164a6	; 0x164a6 <_uart>
}
    a776:	ec 96       	adiw	r28, 0x3c	; 60
    a778:	0f b6       	in	r0, 0x3f	; 63
    a77a:	f8 94       	cli
    a77c:	de bf       	out	0x3e, r29	; 62
    a77e:	0f be       	out	0x3f, r0	; 63
    a780:	cd bf       	out	0x3d, r28	; 61
    a782:	cf 91       	pop	r28
    a784:	df 91       	pop	r29
    a786:	1f 91       	pop	r17
    a788:	0f 91       	pop	r16
    a78a:	08 95       	ret

0000a78c <FreePrinting>:
	 } 
	 else _uart(_COM_PRINTER,1,xSend);
	 zSend=xSend;
}

void FreePrinting(){
    a78c:	0f 93       	push	r16
    a78e:	1f 93       	push	r17
    a790:	df 93       	push	r29
    a792:	cf 93       	push	r28
    a794:	cd b7       	in	r28, 0x3d	; 61
    a796:	de b7       	in	r29, 0x3e	; 62
    a798:	64 97       	sbiw	r28, 0x14	; 20
    a79a:	0f b6       	in	r0, 0x3f	; 63
    a79c:	f8 94       	cli
    a79e:	de bf       	out	0x3e, r29	; 62
    a7a0:	0f be       	out	0x3f, r0	; 63
    a7a2:	cd bf       	out	0x3d, r28	; 61
static char iPrinted=0,iHeader=0,iFooter=0,PrintCopy=0,iMargin=0,iScroll=0,nScroll=0;
static unsigned int iSend=0,LSend=0,iLoop=0;
       char strOperatorName[20];

     //Normalize FreePrintIdleState
     if ((IsFreePrinting==True)&&(stFreePrinting!=fpInit)){
    a7a4:	20 91 ab 01 	lds	r18, 0x01AB
    a7a8:	21 30       	cpi	r18, 0x01	; 1
    a7aa:	31 f4       	brne	.+12     	; 0xa7b8 <FreePrinting+0x2c>
    a7ac:	80 91 15 01 	lds	r24, 0x0115
    a7b0:	81 30       	cpi	r24, 0x01	; 1
    a7b2:	11 f0       	breq	.+4      	; 0xa7b8 <FreePrinting+0x2c>
	     stFreePrinting=fpInit;
    a7b4:	20 93 15 01 	sts	0x0115, r18
	 }

	 switch (stFreePrinting){
    a7b8:	80 91 15 01 	lds	r24, 0x0115
    a7bc:	90 e0       	ldi	r25, 0x00	; 0
    a7be:	fc 01       	movw	r30, r24
    a7c0:	31 97       	sbiw	r30, 0x01	; 1
    a7c2:	eb 31       	cpi	r30, 0x1B	; 27
    a7c4:	f1 05       	cpc	r31, r1
    a7c6:	08 f0       	brcs	.+2      	; 0xa7ca <FreePrinting+0x3e>
    a7c8:	7c c3       	rjmp	.+1784   	; 0xaec2 <FreePrinting+0x736>
    a7ca:	ec 59       	subi	r30, 0x9C	; 156
    a7cc:	ff 4f       	sbci	r31, 0xFF	; 255
    a7ce:	ee 0f       	add	r30, r30
    a7d0:	ff 1f       	adc	r31, r31
    a7d2:	05 90       	lpm	r0, Z+
    a7d4:	f4 91       	lpm	r31, Z+
    a7d6:	e0 2d       	mov	r30, r0
    a7d8:	09 94       	ijmp
     case fpInit:
	      //_uart_printf(0,1,PSTR("fpInit"));
	      if (IsFreePrinting==True){
    a7da:	21 30       	cpi	r18, 0x01	; 1
    a7dc:	09 f0       	breq	.+2      	; 0xa7e0 <FreePrinting+0x54>
    a7de:	71 c3       	rjmp	.+1762   	; 0xaec2 <FreePrinting+0x736>
		      IsFreePrinting=False;
    a7e0:	10 92 ab 01 	sts	0x01AB, r1
			  IsBusyFreePrinting=True;
    a7e4:	20 93 b6 01 	sts	0x01B6, r18
			  IsBusyPrint=False;
    a7e8:	10 92 b5 01 	sts	0x01B5, r1
			  iPrinted=0,iFooter=0;
    a7ec:	10 92 45 02 	sts	0x0245, r1
    a7f0:	10 92 43 02 	sts	0x0243, r1

			  PrintCopy=(cmdPrint&0x0F);
    a7f4:	80 91 b7 01 	lds	r24, 0x01B7
    a7f8:	8f 70       	andi	r24, 0x0F	; 15
    a7fa:	80 93 42 02 	sts	0x0242, r24

			  //cmdPrint=cmdPrint|0b00100000;
			  //PrintCopy=2;

			  stFreePrinting=fpInitHeader;
    a7fe:	82 e0       	ldi	r24, 0x02	; 2
    a800:	80 93 15 01 	sts	0x0115, r24
			  InitPrinter();
    a804:	0e 94 48 4c 	call	0x9890	; 0x9890 <InitPrinter>
    a808:	5c c3       	rjmp	.+1720   	; 0xaec2 <FreePrinting+0x736>
			  }
	      break;
     case fpInitHeader:
	      //_uart_printf(0,1,PSTR("fpInitHeader"));
		  iHeader=0;
    a80a:	10 92 44 02 	sts	0x0244, r1
	      if (((cmdPrint&0b10000000)>>7)==1){
    a80e:	80 91 b7 01 	lds	r24, 0x01B7
    a812:	88 1f       	adc	r24, r24
    a814:	88 27       	eor	r24, r24
    a816:	88 1f       	adc	r24, r24
    a818:	90 e0       	ldi	r25, 0x00	; 0
    a81a:	81 30       	cpi	r24, 0x01	; 1
    a81c:	91 05       	cpc	r25, r1
    a81e:	21 f1       	breq	.+72     	; 0xa868 <FreePrinting+0xdc>
		      stFreePrinting=fpLoadHeader;
			  }
		  else
	      if (((cmdPrint&0b10000000)>>7)==0) stFreePrinting=fpInitMessage;	      
    a820:	89 2b       	or	r24, r25
    a822:	09 f0       	breq	.+2      	; 0xa826 <FreePrinting+0x9a>
    a824:	4e c3       	rjmp	.+1692   	; 0xaec2 <FreePrinting+0x736>
    a826:	85 e0       	ldi	r24, 0x05	; 5
    a828:	80 93 15 01 	sts	0x0115, r24
    a82c:	4a c3       	rjmp	.+1684   	; 0xaec2 <FreePrinting+0x736>
    a82e:	60 91 44 02 	lds	r22, 0x0244
    a832:	89 e2       	ldi	r24, 0x29	; 41
    a834:	68 9f       	mul	r22, r24
    a836:	b0 01       	movw	r22, r0
    a838:	11 24       	eor	r1, r1
    a83a:	69 5d       	subi	r22, 0xD9	; 217
    a83c:	7d 4f       	sbci	r23, 0xFD	; 253
    a83e:	80 ef       	ldi	r24, 0xF0	; 240
    a840:	99 e0       	ldi	r25, 0x09	; 9
    a842:	48 e2       	ldi	r20, 0x28	; 40
    a844:	50 e0       	ldi	r21, 0x00	; 0
    a846:	2d ef       	ldi	r18, 0xFD	; 253
    a848:	32 e1       	ldi	r19, 0x12	; 18
    a84a:	0e 94 f1 b3 	call	0x167e2	; 0x167e2 <__eerd_block>
	      break;
     case fpLoadHeader:
	      //_uart_printf(0,1,PSTR("fpLoadHeader"));
          //Header 1
	      eeprom_read_block((void*) &strPrint, (const void*) &DefHeaderFooter[iHeader], 40);
		  iHeader++;
    a84e:	80 91 44 02 	lds	r24, 0x0244
    a852:	8f 5f       	subi	r24, 0xFF	; 255
    a854:	80 93 44 02 	sts	0x0244, r24
		  if (iHeader<6){
    a858:	86 30       	cpi	r24, 0x06	; 6
    a85a:	28 f7       	brcc	.-54     	; 0xa826 <FreePrinting+0x9a>
		      if (SpaceOnly(strPrint)==True){
    a85c:	80 ef       	ldi	r24, 0xF0	; 240
    a85e:	99 e0       	ldi	r25, 0x09	; 9
    a860:	0e 94 f4 23 	call	0x47e8	; 0x47e8 <SpaceOnly>
    a864:	81 30       	cpi	r24, 0x01	; 1
    a866:	11 f4       	brne	.+4      	; 0xa86c <FreePrinting+0xe0>
			      stFreePrinting=fpLoadHeader;
    a868:	83 e0       	ldi	r24, 0x03	; 3
    a86a:	de cf       	rjmp	.-68     	; 0xa828 <FreePrinting+0x9c>
				  }	      
			  else{
			      stFreePrinting=fpPrintHeader;
    a86c:	84 e0       	ldi	r24, 0x04	; 4
    a86e:	80 93 15 01 	sts	0x0115, r24
			      iSend=0;
    a872:	10 92 3e 02 	sts	0x023E, r1
    a876:	10 92 3d 02 	sts	0x023D, r1
				  iLoop=0;
    a87a:	10 92 3a 02 	sts	0x023A, r1
    a87e:	10 92 39 02 	sts	0x0239, r1
				  //PrintDoubleHeight on 1st Header
				  if (iHeader==1) PrintDoubleHeight();
    a882:	80 91 44 02 	lds	r24, 0x0244
    a886:	81 30       	cpi	r24, 0x01	; 1
    a888:	19 f4       	brne	.+6      	; 0xa890 <FreePrinting+0x104>
    a88a:	0e 94 ca 4c 	call	0x9994	; 0x9994 <PrintDoubleHeight>
    a88e:	19 c3       	rjmp	.+1586   	; 0xaec2 <FreePrinting+0x736>
				  else 
				  if (iHeader==2) PrintNormalHeight();
    a890:	82 30       	cpi	r24, 0x02	; 2
    a892:	09 f0       	breq	.+2      	; 0xa896 <FreePrinting+0x10a>
    a894:	16 c3       	rjmp	.+1580   	; 0xaec2 <FreePrinting+0x736>
    a896:	0e 94 b0 4c 	call	0x9960	; 0x9960 <PrintNormalHeight>
    a89a:	13 c3       	rjmp	.+1574   	; 0xaec2 <FreePrinting+0x736>
		  {stFreePrinting=fpInitMessage;
		  }
	      break;
     case fpPrintHeader:
	      //_uart_printf(0,1,PSTR("fpPrintHeader"));
		  if (iSend<40){
    a89c:	80 91 3d 02 	lds	r24, 0x023D
    a8a0:	90 91 3e 02 	lds	r25, 0x023E
    a8a4:	88 97       	sbiw	r24, 0x28	; 40
    a8a6:	68 f4       	brcc	.+26     	; 0xa8c2 <FreePrinting+0x136>
		      iLoop++;
    a8a8:	80 91 39 02 	lds	r24, 0x0239
    a8ac:	90 91 3a 02 	lds	r25, 0x023A
    a8b0:	01 96       	adiw	r24, 0x01	; 1
    a8b2:	90 93 3a 02 	sts	0x023A, r25
    a8b6:	80 93 39 02 	sts	0x0239, r24
			  if ((iLoop%PRINT_DELAY)==0){
			     //_uart(_COM_PRINTER,1,strPrint[iSend]);
		         //iSend++;
				 TimPrintBusy=0;
    a8ba:	10 92 b8 01 	sts	0x01B8, r1
				 stFreePrinting=fpCheckPrintStatusHeader;
    a8be:	82 e1       	ldi	r24, 0x12	; 18
    a8c0:	b3 cf       	rjmp	.-154    	; 0xa828 <FreePrinting+0x9c>
				 }
			  }
          else{ 
		     stFreePrinting=fpLoadHeader;
    a8c2:	83 e0       	ldi	r24, 0x03	; 3
    a8c4:	57 c2       	rjmp	.+1198   	; 0xad74 <FreePrinting+0x5e8>
			 CarriegeReturn();
		  }
	      break;

     case fpCheckPrintStatusHeader:
	      if (IsBusyPrint==False){
    a8c6:	80 91 b5 01 	lds	r24, 0x01B5
    a8ca:	88 23       	and	r24, r24
    a8cc:	09 f0       	breq	.+2      	; 0xa8d0 <FreePrinting+0x144>
    a8ce:	71 c2       	rjmp	.+1250   	; 0xadb2 <FreePrinting+0x626>
		      _uart(_COM_PRINTER,1,strPrint[iSend]);
    a8d0:	e0 91 3d 02 	lds	r30, 0x023D
    a8d4:	f0 91 3e 02 	lds	r31, 0x023E
    a8d8:	e0 51       	subi	r30, 0x10	; 16
    a8da:	f6 4f       	sbci	r31, 0xF6	; 246
    a8dc:	61 e0       	ldi	r22, 0x01	; 1
    a8de:	40 81       	ld	r20, Z
    a8e0:	0e 94 53 b2 	call	0x164a6	; 0x164a6 <_uart>
		      iSend++;
    a8e4:	80 91 3d 02 	lds	r24, 0x023D
    a8e8:	90 91 3e 02 	lds	r25, 0x023E
    a8ec:	01 96       	adiw	r24, 0x01	; 1
    a8ee:	90 93 3e 02 	sts	0x023E, r25
    a8f2:	80 93 3d 02 	sts	0x023D, r24
		      stFreePrinting=fpPrintHeader;
    a8f6:	84 e0       	ldi	r24, 0x04	; 4
    a8f8:	5a c2       	rjmp	.+1204   	; 0xadae <FreePrinting+0x622>
			  }
	      break;

     case fpInitMessage:
	      //_uart_printf(0,1,PSTR("fpInitMessage"));
	      iSend=0;iLoop=0;
    a8fa:	10 92 3e 02 	sts	0x023E, r1
    a8fe:	10 92 3d 02 	sts	0x023D, r1
    a902:	10 92 3a 02 	sts	0x023A, r1
    a906:	10 92 39 02 	sts	0x0239, r1
          stFreePrinting=fpPrintMessage; 
    a90a:	08 e0       	ldi	r16, 0x08	; 8
    a90c:	00 93 15 01 	sts	0x0115, r16
		  CarriegeReturn();
    a910:	0e 94 3d 4c 	call	0x987a	; 0x987a <CarriegeReturn>
		  if (iPrinted>0) stFreePrinting=fpInitDuplicate;
    a914:	80 91 45 02 	lds	r24, 0x0245
    a918:	88 23       	and	r24, r24
    a91a:	11 f0       	breq	.+4      	; 0xa920 <FreePrinting+0x194>
    a91c:	86 e0       	ldi	r24, 0x06	; 6
    a91e:	84 cf       	rjmp	.-248    	; 0xa828 <FreePrinting+0x9c>
		  else stFreePrinting=fpPrintMessage; 
    a920:	00 93 15 01 	sts	0x0115, r16
    a924:	ce c2       	rjmp	.+1436   	; 0xaec2 <FreePrinting+0x736>
	      break;
     case fpInitDuplicate:
	      //_uart_printf(0,1,PSTR("fpInitDuplicate"));
          if (iPrinted>0)sprintf_P(strPrint,PSTR("             DUPLICATE COPY        "));
    a926:	80 91 45 02 	lds	r24, 0x0245
    a92a:	20 ef       	ldi	r18, 0xF0	; 240
    a92c:	39 e0       	ldi	r19, 0x09	; 9
    a92e:	88 23       	and	r24, r24
    a930:	79 f0       	breq	.+30     	; 0xa950 <FreePrinting+0x1c4>
    a932:	00 d0       	rcall	.+0      	; 0xa934 <FreePrinting+0x1a8>
    a934:	00 d0       	rcall	.+0      	; 0xa936 <FreePrinting+0x1aa>
    a936:	ad b7       	in	r26, 0x3d	; 61
    a938:	be b7       	in	r27, 0x3e	; 62
    a93a:	12 96       	adiw	r26, 0x02	; 2
    a93c:	3c 93       	st	X, r19
    a93e:	2e 93       	st	-X, r18
    a940:	11 97       	sbiw	r26, 0x01	; 1
    a942:	88 e1       	ldi	r24, 0x18	; 24
    a944:	96 e0       	ldi	r25, 0x06	; 6
    a946:	14 96       	adiw	r26, 0x04	; 4
    a948:	9c 93       	st	X, r25
    a94a:	8e 93       	st	-X, r24
    a94c:	13 97       	sbiw	r26, 0x03	; 3
    a94e:	0a c0       	rjmp	.+20     	; 0xa964 <FreePrinting+0x1d8>
          else           sprintf_P(strPrint,PSTR("                                   "));
    a950:	00 d0       	rcall	.+0      	; 0xa952 <FreePrinting+0x1c6>
    a952:	00 d0       	rcall	.+0      	; 0xa954 <FreePrinting+0x1c8>
    a954:	ed b7       	in	r30, 0x3d	; 61
    a956:	fe b7       	in	r31, 0x3e	; 62
    a958:	32 83       	std	Z+2, r19	; 0x02
    a95a:	21 83       	std	Z+1, r18	; 0x01
    a95c:	84 ef       	ldi	r24, 0xF4	; 244
    a95e:	95 e0       	ldi	r25, 0x05	; 5
    a960:	94 83       	std	Z+4, r25	; 0x04
    a962:	83 83       	std	Z+3, r24	; 0x03
    a964:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    a968:	0f 90       	pop	r0
    a96a:	0f 90       	pop	r0
    a96c:	0f 90       	pop	r0
    a96e:	0f 90       	pop	r0
		  iSend=0;
    a970:	10 92 3e 02 	sts	0x023E, r1
    a974:	10 92 3d 02 	sts	0x023D, r1
		  iLoop=0;
    a978:	10 92 3a 02 	sts	0x023A, r1
    a97c:	10 92 39 02 	sts	0x0239, r1
		  LSend=strlen(strPrint);
    a980:	e0 ef       	ldi	r30, 0xF0	; 240
    a982:	f9 e0       	ldi	r31, 0x09	; 9
    a984:	01 90       	ld	r0, Z+
    a986:	00 20       	and	r0, r0
    a988:	e9 f7       	brne	.-6      	; 0xa984 <FreePrinting+0x1f8>
    a98a:	31 97       	sbiw	r30, 0x01	; 1
    a98c:	e0 5f       	subi	r30, 0xF0	; 240
    a98e:	f9 40       	sbci	r31, 0x09	; 9
    a990:	f0 93 3c 02 	sts	0x023C, r31
    a994:	e0 93 3b 02 	sts	0x023B, r30
          stFreePrinting=fpPrintDuplicate; 
    a998:	87 e0       	ldi	r24, 0x07	; 7
    a99a:	46 cf       	rjmp	.-372    	; 0xa828 <FreePrinting+0x9c>
	      break;
     case fpPrintDuplicate:
	      //_uart_printf(0,1,PSTR("fpPrintDuplicate"));
		  if (iSend<LSend){
    a99c:	20 91 3d 02 	lds	r18, 0x023D
    a9a0:	30 91 3e 02 	lds	r19, 0x023E
    a9a4:	80 91 3b 02 	lds	r24, 0x023B
    a9a8:	90 91 3c 02 	lds	r25, 0x023C
    a9ac:	28 17       	cp	r18, r24
    a9ae:	39 07       	cpc	r19, r25
    a9b0:	68 f4       	brcc	.+26     	; 0xa9cc <FreePrinting+0x240>
		      iLoop++;
    a9b2:	80 91 39 02 	lds	r24, 0x0239
    a9b6:	90 91 3a 02 	lds	r25, 0x023A
    a9ba:	01 96       	adiw	r24, 0x01	; 1
    a9bc:	90 93 3a 02 	sts	0x023A, r25
    a9c0:	80 93 39 02 	sts	0x0239, r24
			  if((iLoop%PRINT_DELAY)==0){
			     //_uart(_COM_PRINTER,1,strPrint[iSend]);
				 //iSend++;
				 TimPrintBusy=0;
    a9c4:	10 92 b8 01 	sts	0x01B8, r1
                 stFreePrinting=fpCheckPrintStatusDuplicate;
    a9c8:	85 e1       	ldi	r24, 0x15	; 21
    a9ca:	2e cf       	rjmp	.-420    	; 0xa828 <FreePrinting+0x9c>
				 }
			  }
          else {
		     iSend=0;
    a9cc:	10 92 3e 02 	sts	0x023E, r1
    a9d0:	10 92 3d 02 	sts	0x023D, r1
		     stFreePrinting=fpPrintMessage;
    a9d4:	88 e0       	ldi	r24, 0x08	; 8
    a9d6:	ce c1       	rjmp	.+924    	; 0xad74 <FreePrinting+0x5e8>
			 CarriegeReturn();	      
			 }
	      break;
     case fpCheckPrintStatusDuplicate:
	      if (IsBusyPrint==False){
    a9d8:	80 91 b5 01 	lds	r24, 0x01B5
    a9dc:	88 23       	and	r24, r24
    a9de:	09 f0       	breq	.+2      	; 0xa9e2 <FreePrinting+0x256>
    a9e0:	e8 c1       	rjmp	.+976    	; 0xadb2 <FreePrinting+0x626>
		      _uart(_COM_PRINTER,1,strPrint[iSend]);
    a9e2:	e0 91 3d 02 	lds	r30, 0x023D
    a9e6:	f0 91 3e 02 	lds	r31, 0x023E
    a9ea:	e0 51       	subi	r30, 0x10	; 16
    a9ec:	f6 4f       	sbci	r31, 0xF6	; 246
    a9ee:	61 e0       	ldi	r22, 0x01	; 1
    a9f0:	40 81       	ld	r20, Z
    a9f2:	0e 94 53 b2 	call	0x164a6	; 0x164a6 <_uart>
		      iSend++;
    a9f6:	80 91 3d 02 	lds	r24, 0x023D
    a9fa:	90 91 3e 02 	lds	r25, 0x023E
    a9fe:	01 96       	adiw	r24, 0x01	; 1
    aa00:	90 93 3e 02 	sts	0x023E, r25
    aa04:	80 93 3d 02 	sts	0x023D, r24
		      stFreePrinting=fpPrintDuplicate;
    aa08:	87 e0       	ldi	r24, 0x07	; 7
    aa0a:	d1 c1       	rjmp	.+930    	; 0xadae <FreePrinting+0x622>
		      stFreePrinting=fpFinishFreePrinting;
			  }
	      break;

     case fpPrintMessage:
		  if (iSend<LengthMessage81){
    aa0c:	20 91 3d 02 	lds	r18, 0x023D
    aa10:	30 91 3e 02 	lds	r19, 0x023E
    aa14:	80 91 90 01 	lds	r24, 0x0190
    aa18:	90 91 91 01 	lds	r25, 0x0191
    aa1c:	28 17       	cp	r18, r24
    aa1e:	39 07       	cpc	r19, r25
    aa20:	68 f4       	brcc	.+26     	; 0xaa3c <FreePrinting+0x2b0>
		      iLoop++;
    aa22:	80 91 39 02 	lds	r24, 0x0239
    aa26:	90 91 3a 02 	lds	r25, 0x023A
    aa2a:	01 96       	adiw	r24, 0x01	; 1
    aa2c:	90 93 3a 02 	sts	0x023A, r25
    aa30:	80 93 39 02 	sts	0x0239, r24
			  if((iLoop%PRINT_DELAY)==0){
			     TimPrintBusy=0;
    aa34:	10 92 b8 01 	sts	0x01B8, r1
				 stFreePrinting=fpCheckPrintStatusMessage;
    aa38:	83 e1       	ldi	r24, 0x13	; 19
    aa3a:	f6 ce       	rjmp	.-532    	; 0xa828 <FreePrinting+0x9c>
				 }
			  }
          else stFreePrinting=fpLoadEndLine;//fpInitFooter;
    aa3c:	86 e1       	ldi	r24, 0x16	; 22
    aa3e:	f4 ce       	rjmp	.-536    	; 0xa828 <FreePrinting+0x9c>
	      break;
     
     case fpCheckPrintStatusMessage:
	      if (IsBusyPrint==False){
    aa40:	80 91 b5 01 	lds	r24, 0x01B5
    aa44:	88 23       	and	r24, r24
    aa46:	09 f0       	breq	.+2      	; 0xaa4a <FreePrinting+0x2be>
    aa48:	b4 c1       	rjmp	.+872    	; 0xadb2 <FreePrinting+0x626>
              if ((PrintBuffer[iSend]!=0x0D)||(PrintBuffer[iSend]!=0x0A))
			      SendPrint(PrintBuffer[iSend],PrintBuffer[iSend+1]);
    aa4a:	e0 91 3d 02 	lds	r30, 0x023D
    aa4e:	f0 91 3e 02 	lds	r31, 0x023E
    aa52:	e2 50       	subi	r30, 0x02	; 2
    aa54:	fb 4f       	sbci	r31, 0xFB	; 251
    aa56:	80 81       	ld	r24, Z
    aa58:	61 81       	ldd	r22, Z+1	; 0x01
    aa5a:	0e 94 25 4c 	call	0x984a	; 0x984a <SendPrint>
			     // _uart(_COM_PRINTER,1,PrintBuffer[iSend]);
              if ((PrintBuffer[iSend]==0x0D)||(PrintBuffer[iSend+1]==0x0A))
    aa5e:	e0 91 3d 02 	lds	r30, 0x023D
    aa62:	f0 91 3e 02 	lds	r31, 0x023E
    aa66:	e2 50       	subi	r30, 0x02	; 2
    aa68:	fb 4f       	sbci	r31, 0xFB	; 251
    aa6a:	80 81       	ld	r24, Z
    aa6c:	8d 30       	cpi	r24, 0x0D	; 13
    aa6e:	19 f0       	breq	.+6      	; 0xaa76 <FreePrinting+0x2ea>
    aa70:	81 81       	ldd	r24, Z+1	; 0x01
    aa72:	8a 30       	cpi	r24, 0x0A	; 10
    aa74:	11 f4       	brne	.+4      	; 0xaa7a <FreePrinting+0x2ee>
			     CarriegeReturn();
    aa76:	0e 94 3d 4c 	call	0x987a	; 0x987a <CarriegeReturn>
             iSend++;
    aa7a:	80 91 3d 02 	lds	r24, 0x023D
    aa7e:	90 91 3e 02 	lds	r25, 0x023E
    aa82:	01 96       	adiw	r24, 0x01	; 1
    aa84:	90 93 3e 02 	sts	0x023E, r25
    aa88:	80 93 3d 02 	sts	0x023D, r24
		     stFreePrinting=fpPrintMessage;
    aa8c:	88 e0       	ldi	r24, 0x08	; 8
    aa8e:	8f c1       	rjmp	.+798    	; 0xadae <FreePrinting+0x622>
		      stFreePrinting=fpFinishFreePrinting;
			  }
	      break;
     //SpaceAdded
	 case fpInitSpace:
	      iLoop=0;
    aa90:	10 92 3a 02 	sts	0x023A, r1
    aa94:	10 92 39 02 	sts	0x0239, r1
		  iMargin=0;
    aa98:	10 92 41 02 	sts	0x0241, r1
		  stFreePrinting=fpPrintMargin;
    aa9c:	8a e0       	ldi	r24, 0x0A	; 10
    aa9e:	c4 ce       	rjmp	.-632    	; 0xa828 <FreePrinting+0x9c>
	      break;
	 case fpPrintMargin:
		  if (iMargin<PRINT_MARGIN){
    aaa0:	80 91 41 02 	lds	r24, 0x0241
    aaa4:	85 30       	cpi	r24, 0x05	; 5
    aaa6:	90 f4       	brcc	.+36     	; 0xaacc <FreePrinting+0x340>
		      iMargin++;
    aaa8:	8f 5f       	subi	r24, 0xFF	; 255
    aaaa:	80 93 41 02 	sts	0x0241, r24
		      iLoop++;
    aaae:	80 91 39 02 	lds	r24, 0x0239
    aab2:	90 91 3a 02 	lds	r25, 0x023A
    aab6:	01 96       	adiw	r24, 0x01	; 1
    aab8:	90 93 3a 02 	sts	0x023A, r25
    aabc:	80 93 39 02 	sts	0x0239, r24
	          if ((iLoop%PRINT_DELAY)==0)_uart(_COM_PRINTER,1,' ');
    aac0:	80 e0       	ldi	r24, 0x00	; 0
    aac2:	61 e0       	ldi	r22, 0x01	; 1
    aac4:	40 e2       	ldi	r20, 0x20	; 32
    aac6:	0e 94 53 b2 	call	0x164a6	; 0x164a6 <_uart>
    aaca:	fb c1       	rjmp	.+1014   	; 0xaec2 <FreePrinting+0x736>
			 }
          else stFreePrinting=fpPrintMessage;
    aacc:	88 e0       	ldi	r24, 0x08	; 8
    aace:	ac ce       	rjmp	.-680    	; 0xa828 <FreePrinting+0x9c>
    aad0:	8e 01       	movw	r16, r28
    aad2:	0f 5f       	subi	r16, 0xFF	; 255
    aad4:	1f 4f       	sbci	r17, 0xFF	; 255
    aad6:	c8 01       	movw	r24, r16
    aad8:	65 e1       	ldi	r22, 0x15	; 21
    aada:	70 e0       	ldi	r23, 0x00	; 0
    aadc:	42 e1       	ldi	r20, 0x12	; 18
    aade:	50 e0       	ldi	r21, 0x00	; 0
    aae0:	2d ef       	ldi	r18, 0xFD	; 253
    aae2:	32 e1       	ldi	r19, 0x12	; 18
    aae4:	0e 94 f1 b3 	call	0x167e2	; 0x167e2 <__eerd_block>
	      break;
     
     //Added Operator Name:
	 case fpLoadEndLine:
		  eeprom_read_block((void*) &strOperatorName, (const void*) &DefOperatorName,18);
		  if ((SpaceOnly(strOperatorName)!=True)||(strlen(strOperatorName)>0)){
    aae8:	c8 01       	movw	r24, r16
    aaea:	0e 94 f4 23 	call	0x47e8	; 0x47e8 <SpaceOnly>
    aaee:	81 30       	cpi	r24, 0x01	; 1
    aaf0:	21 f4       	brne	.+8      	; 0xaafa <FreePrinting+0x36e>
    aaf2:	89 81       	ldd	r24, Y+1	; 0x01
    aaf4:	88 23       	and	r24, r24
    aaf6:	09 f4       	brne	.+2      	; 0xaafa <FreePrinting+0x36e>
    aaf8:	27 c1       	rjmp	.+590    	; 0xad48 <FreePrinting+0x5bc>
			   sprintf_P(strPrint,PSTR("---------------------------------"));
    aafa:	00 d0       	rcall	.+0      	; 0xaafc <FreePrinting+0x370>
    aafc:	00 d0       	rcall	.+0      	; 0xaafe <FreePrinting+0x372>
    aafe:	00 ef       	ldi	r16, 0xF0	; 240
    ab00:	19 e0       	ldi	r17, 0x09	; 9
    ab02:	ad b7       	in	r26, 0x3d	; 61
    ab04:	be b7       	in	r27, 0x3e	; 62
    ab06:	12 96       	adiw	r26, 0x02	; 2
    ab08:	1c 93       	st	X, r17
    ab0a:	0e 93       	st	-X, r16
    ab0c:	11 97       	sbiw	r26, 0x01	; 1
    ab0e:	82 ed       	ldi	r24, 0xD2	; 210
    ab10:	95 e0       	ldi	r25, 0x05	; 5
    ab12:	14 96       	adiw	r26, 0x04	; 4
    ab14:	9c 93       	st	X, r25
    ab16:	8e 93       	st	-X, r24
    ab18:	13 97       	sbiw	r26, 0x03	; 3
    ab1a:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
			   //AddSpaceLead(strPrint,(strlen(strPrint)+PRINT_MARGIN));
		       iSend=0;
    ab1e:	10 92 3e 02 	sts	0x023E, r1
    ab22:	10 92 3d 02 	sts	0x023D, r1
			   iLoop=0;
    ab26:	10 92 3a 02 	sts	0x023A, r1
    ab2a:	10 92 39 02 	sts	0x0239, r1
			   LSend=strlen(strPrint);
    ab2e:	f8 01       	movw	r30, r16
    ab30:	01 90       	ld	r0, Z+
    ab32:	00 20       	and	r0, r0
    ab34:	e9 f7       	brne	.-6      	; 0xab30 <FreePrinting+0x3a4>
    ab36:	8f 01       	movw	r16, r30
    ab38:	01 50       	subi	r16, 0x01	; 1
    ab3a:	10 40       	sbci	r17, 0x00	; 0
    ab3c:	00 5f       	subi	r16, 0xF0	; 240
    ab3e:	19 40       	sbci	r17, 0x09	; 9
    ab40:	10 93 3c 02 	sts	0x023C, r17
    ab44:	00 93 3b 02 	sts	0x023B, r16
			   stFreePrinting=fpPrintEndLine;	
    ab48:	87 e1       	ldi	r24, 0x17	; 23
    ab4a:	80 93 15 01 	sts	0x0115, r24
    ab4e:	0f 90       	pop	r0
    ab50:	0f 90       	pop	r0
    ab52:	0f 90       	pop	r0
    ab54:	0f 90       	pop	r0
    ab56:	b5 c1       	rjmp	.+874    	; 0xaec2 <FreePrinting+0x736>
		  }	       
          else stFreePrinting=piLoadFooter;
	      break;

	 case fpPrintEndLine:
		  if (iSend<LSend){
    ab58:	20 91 3d 02 	lds	r18, 0x023D
    ab5c:	30 91 3e 02 	lds	r19, 0x023E
    ab60:	80 91 3b 02 	lds	r24, 0x023B
    ab64:	90 91 3c 02 	lds	r25, 0x023C
    ab68:	28 17       	cp	r18, r24
    ab6a:	39 07       	cpc	r19, r25
    ab6c:	68 f4       	brcc	.+26     	; 0xab88 <FreePrinting+0x3fc>
		      iLoop++;
    ab6e:	80 91 39 02 	lds	r24, 0x0239
    ab72:	90 91 3a 02 	lds	r25, 0x023A
    ab76:	01 96       	adiw	r24, 0x01	; 1
    ab78:	90 93 3a 02 	sts	0x023A, r25
    ab7c:	80 93 39 02 	sts	0x0239, r24
			  if((iLoop%PRINT_DELAY)==0){
				  TimPrintBusy=0;
    ab80:	10 92 b8 01 	sts	0x01B8, r1
				  stFreePrinting=fpCheckPrintEndLine;
    ab84:	88 e1       	ldi	r24, 0x18	; 24
    ab86:	50 ce       	rjmp	.-864    	; 0xa828 <FreePrinting+0x9c>
				}
			  }
          else {
			  CarriegeReturn();
    ab88:	0e 94 3d 4c 	call	0x987a	; 0x987a <CarriegeReturn>
			  stFreePrinting=fpLoadOperatorName;
    ab8c:	89 e1       	ldi	r24, 0x19	; 25
    ab8e:	4c ce       	rjmp	.-872    	; 0xa828 <FreePrinting+0x9c>
			  }
	      break;
	 case fpCheckPrintEndLine:
	      if (IsBusyPrint==False){
    ab90:	80 91 b5 01 	lds	r24, 0x01B5
    ab94:	88 23       	and	r24, r24
    ab96:	09 f0       	breq	.+2      	; 0xab9a <FreePrinting+0x40e>
    ab98:	0c c1       	rjmp	.+536    	; 0xadb2 <FreePrinting+0x626>
		      _uart(_COM_PRINTER,1,strPrint[iSend]);
    ab9a:	e0 91 3d 02 	lds	r30, 0x023D
    ab9e:	f0 91 3e 02 	lds	r31, 0x023E
    aba2:	e0 51       	subi	r30, 0x10	; 16
    aba4:	f6 4f       	sbci	r31, 0xF6	; 246
    aba6:	61 e0       	ldi	r22, 0x01	; 1
    aba8:	40 81       	ld	r20, Z
    abaa:	0e 94 53 b2 	call	0x164a6	; 0x164a6 <_uart>
		      iSend++;
    abae:	80 91 3d 02 	lds	r24, 0x023D
    abb2:	90 91 3e 02 	lds	r25, 0x023E
    abb6:	01 96       	adiw	r24, 0x01	; 1
    abb8:	90 93 3e 02 	sts	0x023E, r25
    abbc:	80 93 3d 02 	sts	0x023D, r24
		      stFreePrinting=fpPrintEndLine;
    abc0:	87 e1       	ldi	r24, 0x17	; 23
    abc2:	f5 c0       	rjmp	.+490    	; 0xadae <FreePrinting+0x622>
    abc4:	8e 01       	movw	r16, r28
    abc6:	0f 5f       	subi	r16, 0xFF	; 255
    abc8:	1f 4f       	sbci	r17, 0xFF	; 255
    abca:	c8 01       	movw	r24, r16
    abcc:	65 e1       	ldi	r22, 0x15	; 21
    abce:	70 e0       	ldi	r23, 0x00	; 0
    abd0:	42 e1       	ldi	r20, 0x12	; 18
    abd2:	50 e0       	ldi	r21, 0x00	; 0
    abd4:	2d ef       	ldi	r18, 0xFD	; 253
    abd6:	32 e1       	ldi	r19, 0x12	; 18
    abd8:	0e 94 f1 b3 	call	0x167e2	; 0x167e2 <__eerd_block>
    abdc:	c8 01       	movw	r24, r16
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    abde:	9e 01       	movw	r18, r28
    abe0:	20 5f       	subi	r18, 0xF0	; 240
    abe2:	3f 4f       	sbci	r19, 0xFF	; 255
	    Dest[i]=Source[IdxSource+i];
    abe4:	01 96       	adiw	r24, 0x01	; 1
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    abe6:	82 17       	cp	r24, r18
    abe8:	93 07       	cpc	r25, r19
    abea:	e1 f7       	brne	.-8      	; 0xabe4 <FreePrinting+0x458>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    abec:	18 8a       	std	Y+16, r1	; 0x10
	      break;

	 case fpLoadOperatorName:
		  eeprom_read_block((void*) &strOperatorName, (const void*) &DefOperatorName,18);
		  StrPosCopy(strOperatorName,strOperatorName,0,15);
		  sprintf_P(strPrint,PSTR("Operator: %s"),strOperatorName);
    abee:	00 d0       	rcall	.+0      	; 0xabf0 <FreePrinting+0x464>
    abf0:	00 d0       	rcall	.+0      	; 0xabf2 <FreePrinting+0x466>
    abf2:	00 d0       	rcall	.+0      	; 0xabf4 <FreePrinting+0x468>
    abf4:	ed b7       	in	r30, 0x3d	; 61
    abf6:	fe b7       	in	r31, 0x3e	; 62
    abf8:	31 96       	adiw	r30, 0x01	; 1
    abfa:	00 ef       	ldi	r16, 0xF0	; 240
    abfc:	19 e0       	ldi	r17, 0x09	; 9
    abfe:	ad b7       	in	r26, 0x3d	; 61
    ac00:	be b7       	in	r27, 0x3e	; 62
    ac02:	12 96       	adiw	r26, 0x02	; 2
    ac04:	1c 93       	st	X, r17
    ac06:	0e 93       	st	-X, r16
    ac08:	11 97       	sbiw	r26, 0x01	; 1
    ac0a:	85 ec       	ldi	r24, 0xC5	; 197
    ac0c:	95 e0       	ldi	r25, 0x05	; 5
    ac0e:	93 83       	std	Z+3, r25	; 0x03
    ac10:	82 83       	std	Z+2, r24	; 0x02
    ac12:	ce 01       	movw	r24, r28
    ac14:	01 96       	adiw	r24, 0x01	; 1
    ac16:	95 83       	std	Z+5, r25	; 0x05
    ac18:	84 83       	std	Z+4, r24	; 0x04
    ac1a:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
	      iSend=0;
    ac1e:	10 92 3e 02 	sts	0x023E, r1
    ac22:	10 92 3d 02 	sts	0x023D, r1
		  iLoop=0;
    ac26:	10 92 3a 02 	sts	0x023A, r1
    ac2a:	10 92 39 02 	sts	0x0239, r1
		  LSend=strlen(strPrint);
    ac2e:	f8 01       	movw	r30, r16
    ac30:	01 90       	ld	r0, Z+
    ac32:	00 20       	and	r0, r0
    ac34:	e9 f7       	brne	.-6      	; 0xac30 <FreePrinting+0x4a4>
    ac36:	8f 01       	movw	r16, r30
    ac38:	01 50       	subi	r16, 0x01	; 1
    ac3a:	10 40       	sbci	r17, 0x00	; 0
    ac3c:	00 5f       	subi	r16, 0xF0	; 240
    ac3e:	19 40       	sbci	r17, 0x09	; 9
    ac40:	10 93 3c 02 	sts	0x023C, r17
    ac44:	00 93 3b 02 	sts	0x023B, r16
		  stFreePrinting=fpPrintOperatorName;	
    ac48:	8a e1       	ldi	r24, 0x1A	; 26
    ac4a:	80 93 15 01 	sts	0x0115, r24
    ac4e:	8d b7       	in	r24, 0x3d	; 61
    ac50:	9e b7       	in	r25, 0x3e	; 62
    ac52:	06 96       	adiw	r24, 0x06	; 6
    ac54:	0f b6       	in	r0, 0x3f	; 63
    ac56:	f8 94       	cli
    ac58:	9e bf       	out	0x3e, r25	; 62
    ac5a:	0f be       	out	0x3f, r0	; 63
    ac5c:	8d bf       	out	0x3d, r24	; 61
    ac5e:	31 c1       	rjmp	.+610    	; 0xaec2 <FreePrinting+0x736>
	      break;
	 case fpPrintOperatorName:
		  if (iSend<LSend){
    ac60:	20 91 3d 02 	lds	r18, 0x023D
    ac64:	30 91 3e 02 	lds	r19, 0x023E
    ac68:	80 91 3b 02 	lds	r24, 0x023B
    ac6c:	90 91 3c 02 	lds	r25, 0x023C
    ac70:	28 17       	cp	r18, r24
    ac72:	39 07       	cpc	r19, r25
    ac74:	68 f4       	brcc	.+26     	; 0xac90 <FreePrinting+0x504>
		      iLoop++;
    ac76:	80 91 39 02 	lds	r24, 0x0239
    ac7a:	90 91 3a 02 	lds	r25, 0x023A
    ac7e:	01 96       	adiw	r24, 0x01	; 1
    ac80:	90 93 3a 02 	sts	0x023A, r25
    ac84:	80 93 39 02 	sts	0x0239, r24
			  if((iLoop%PRINT_DELAY)==0){
				  TimPrintBusy=0;
    ac88:	10 92 b8 01 	sts	0x01B8, r1
				  stFreePrinting=fpCheckPrintOperatorName;
    ac8c:	8b e1       	ldi	r24, 0x1B	; 27
    ac8e:	cc cd       	rjmp	.-1128   	; 0xa828 <FreePrinting+0x9c>
				}
			  }
          else {
			  CarriegeReturn();
    ac90:	0e 94 3d 4c 	call	0x987a	; 0x987a <CarriegeReturn>
			  CarriegeReturn();
    ac94:	0e 94 3d 4c 	call	0x987a	; 0x987a <CarriegeReturn>
			  stFreePrinting=fpInitFooter;
    ac98:	8b e0       	ldi	r24, 0x0B	; 11
    ac9a:	c6 cd       	rjmp	.-1140   	; 0xa828 <FreePrinting+0x9c>
			  }
	      break;
	 case fpCheckPrintOperatorName:
	      if (IsBusyPrint==False){
    ac9c:	80 91 b5 01 	lds	r24, 0x01B5
    aca0:	88 23       	and	r24, r24
    aca2:	09 f0       	breq	.+2      	; 0xaca6 <FreePrinting+0x51a>
    aca4:	86 c0       	rjmp	.+268    	; 0xadb2 <FreePrinting+0x626>
		      _uart(_COM_PRINTER,1,strPrint[iSend]);
    aca6:	e0 91 3d 02 	lds	r30, 0x023D
    acaa:	f0 91 3e 02 	lds	r31, 0x023E
    acae:	e0 51       	subi	r30, 0x10	; 16
    acb0:	f6 4f       	sbci	r31, 0xF6	; 246
    acb2:	61 e0       	ldi	r22, 0x01	; 1
    acb4:	40 81       	ld	r20, Z
    acb6:	0e 94 53 b2 	call	0x164a6	; 0x164a6 <_uart>
		      iSend++;
    acba:	80 91 3d 02 	lds	r24, 0x023D
    acbe:	90 91 3e 02 	lds	r25, 0x023E
    acc2:	01 96       	adiw	r24, 0x01	; 1
    acc4:	90 93 3e 02 	sts	0x023E, r25
    acc8:	80 93 3d 02 	sts	0x023D, r24
		      stFreePrinting=fpPrintOperatorName;
    accc:	8a e1       	ldi	r24, 0x1A	; 26
    acce:	6f c0       	rjmp	.+222    	; 0xadae <FreePrinting+0x622>
			  }
	      break;

     case fpInitFooter:
	      //_uart_printf(0,1,PSTR("fpInitFooter"));
          if (((cmdPrint&0b01000000)>>6)==1){
    acd0:	80 91 b7 01 	lds	r24, 0x01B7
    acd4:	86 ff       	sbrs	r24, 6
    acd6:	06 c0       	rjmp	.+12     	; 0xace4 <FreePrinting+0x558>
		      stFreePrinting=fpLoadFooter;
    acd8:	8c e0       	ldi	r24, 0x0C	; 12
    acda:	80 93 15 01 	sts	0x0115, r24
			  iFooter=0;
    acde:	10 92 43 02 	sts	0x0243, r1
    ace2:	ef c0       	rjmp	.+478    	; 0xaec2 <FreePrinting+0x736>
			  }
		  else
	      if (((cmdPrint&0b01000000)>>6)==0) stFreePrinting=fpPaperCut;//fpInitScroll;	                
    ace4:	80 e1       	ldi	r24, 0x10	; 16
    ace6:	a0 cd       	rjmp	.-1216   	; 0xa828 <FreePrinting+0x9c>
    ace8:	60 91 43 02 	lds	r22, 0x0243
    acec:	89 e2       	ldi	r24, 0x29	; 41
    acee:	68 9f       	mul	r22, r24
    acf0:	b0 01       	movw	r22, r0
    acf2:	11 24       	eor	r1, r1
    acf4:	63 5e       	subi	r22, 0xE3	; 227
    acf6:	7c 4f       	sbci	r23, 0xFC	; 252
    acf8:	80 ef       	ldi	r24, 0xF0	; 240
    acfa:	99 e0       	ldi	r25, 0x09	; 9
    acfc:	48 e2       	ldi	r20, 0x28	; 40
    acfe:	50 e0       	ldi	r21, 0x00	; 0
    ad00:	2d ef       	ldi	r18, 0xFD	; 253
    ad02:	32 e1       	ldi	r19, 0x12	; 18
    ad04:	0e 94 f1 b3 	call	0x167e2	; 0x167e2 <__eerd_block>
	      break;
     case fpLoadFooter:
	 	  //_uart_printf(0,1,PSTR("fpLoadFooter"));
          //Footer 1
	      eeprom_read_block((void*) &strPrint, (const void*) &DefHeaderFooter[6+iFooter], 40);
		  iFooter++;
    ad08:	80 91 43 02 	lds	r24, 0x0243
    ad0c:	8f 5f       	subi	r24, 0xFF	; 255
    ad0e:	80 93 43 02 	sts	0x0243, r24
		  if (iFooter<4){
    ad12:	84 30       	cpi	r24, 0x04	; 4
    ad14:	90 f4       	brcc	.+36     	; 0xad3a <FreePrinting+0x5ae>
		      if (SpaceOnly(strPrint)==True){
    ad16:	80 ef       	ldi	r24, 0xF0	; 240
    ad18:	99 e0       	ldi	r25, 0x09	; 9
    ad1a:	0e 94 f4 23 	call	0x47e8	; 0x47e8 <SpaceOnly>
    ad1e:	81 30       	cpi	r24, 0x01	; 1
    ad20:	11 f4       	brne	.+4      	; 0xad26 <FreePrinting+0x59a>
			      stFreePrinting=fpLoadFooter;
    ad22:	8c e0       	ldi	r24, 0x0C	; 12
    ad24:	81 cd       	rjmp	.-1278   	; 0xa828 <FreePrinting+0x9c>
				  }
			  else{
			      iSend=0;
    ad26:	10 92 3e 02 	sts	0x023E, r1
    ad2a:	10 92 3d 02 	sts	0x023D, r1
				  iLoop=0;
    ad2e:	10 92 3a 02 	sts	0x023A, r1
    ad32:	10 92 39 02 	sts	0x0239, r1
				  stFreePrinting=fpPrintFooter;
    ad36:	8d e0       	ldi	r24, 0x0D	; 13
    ad38:	77 cd       	rjmp	.-1298   	; 0xa828 <FreePrinting+0x9c>
			      }
		  }else{
		    CarriegeReturn();
    ad3a:	0e 94 3d 4c 	call	0x987a	; 0x987a <CarriegeReturn>
			iPrinted++;
    ad3e:	80 91 45 02 	lds	r24, 0x0245
    ad42:	8f 5f       	subi	r24, 0xFF	; 255
    ad44:	80 93 45 02 	sts	0x0245, r24

			//if (eeprom_read_byte(&DefPrinterType)==PT_CUSTOM_CUBE){
			    stFreePrinting=fpInitScroll;
    ad48:	8e e0       	ldi	r24, 0x0E	; 14
    ad4a:	6e cd       	rjmp	.-1316   	; 0xa828 <FreePrinting+0x9c>
			//}else stFreePrinting=fpPaperCut;

			}
	      break;
     case fpPrintFooter:
		  if (iSend<40){
    ad4c:	80 91 3d 02 	lds	r24, 0x023D
    ad50:	90 91 3e 02 	lds	r25, 0x023E
    ad54:	88 97       	sbiw	r24, 0x28	; 40
    ad56:	68 f4       	brcc	.+26     	; 0xad72 <FreePrinting+0x5e6>
		      iLoop++;
    ad58:	80 91 39 02 	lds	r24, 0x0239
    ad5c:	90 91 3a 02 	lds	r25, 0x023A
    ad60:	01 96       	adiw	r24, 0x01	; 1
    ad62:	90 93 3a 02 	sts	0x023A, r25
    ad66:	80 93 39 02 	sts	0x0239, r24
			  if((iLoop%PRINT_DELAY)==0){
		        //_uart(_COM_PRINTER,1,strPrint[iSend]);
		        //iSend++;
				TimPrintBusy=0;
    ad6a:	10 92 b8 01 	sts	0x01B8, r1
				stFreePrinting=fpCheckPrintStatusFooter;
    ad6e:	84 e1       	ldi	r24, 0x14	; 20
    ad70:	5b cd       	rjmp	.-1354   	; 0xa828 <FreePrinting+0x9c>
				}
			  }
          else {
		      stFreePrinting=fpLoadFooter;
    ad72:	8c e0       	ldi	r24, 0x0C	; 12
    ad74:	80 93 15 01 	sts	0x0115, r24
			  CarriegeReturn();
    ad78:	0e 94 3d 4c 	call	0x987a	; 0x987a <CarriegeReturn>
    ad7c:	a2 c0       	rjmp	.+324    	; 0xaec2 <FreePrinting+0x736>
			  }
	      break;
     
	 case fpCheckPrintStatusFooter:
	      if (IsBusyPrint==False){
    ad7e:	80 91 b5 01 	lds	r24, 0x01B5
    ad82:	88 23       	and	r24, r24
    ad84:	b1 f4       	brne	.+44     	; 0xadb2 <FreePrinting+0x626>
		      _uart(_COM_PRINTER,1,strPrint[iSend]);
    ad86:	e0 91 3d 02 	lds	r30, 0x023D
    ad8a:	f0 91 3e 02 	lds	r31, 0x023E
    ad8e:	e0 51       	subi	r30, 0x10	; 16
    ad90:	f6 4f       	sbci	r31, 0xF6	; 246
    ad92:	61 e0       	ldi	r22, 0x01	; 1
    ad94:	40 81       	ld	r20, Z
    ad96:	0e 94 53 b2 	call	0x164a6	; 0x164a6 <_uart>
		      iSend++;
    ad9a:	80 91 3d 02 	lds	r24, 0x023D
    ad9e:	90 91 3e 02 	lds	r25, 0x023E
    ada2:	01 96       	adiw	r24, 0x01	; 1
    ada4:	90 93 3e 02 	sts	0x023E, r25
    ada8:	80 93 3d 02 	sts	0x023D, r24
		      stFreePrinting=fpPrintFooter;
    adac:	8d e0       	ldi	r24, 0x0D	; 13
    adae:	80 93 15 01 	sts	0x0115, r24
		  }
		  if (TimPrintBusy>TIM_BUSY_PRINT){
    adb2:	80 91 b8 01 	lds	r24, 0x01B8
    adb6:	8b 30       	cpi	r24, 0x0B	; 11
    adb8:	08 f4       	brcc	.+2      	; 0xadbc <FreePrinting+0x630>
    adba:	83 c0       	rjmp	.+262    	; 0xaec2 <FreePrinting+0x736>
		      IsPrintERROR=True;
    adbc:	81 e0       	ldi	r24, 0x01	; 1
    adbe:	80 93 b3 01 	sts	0x01B3, r24
		      stFreePrinting=fpFinishFreePrinting;
    adc2:	81 e1       	ldi	r24, 0x11	; 17
    adc4:	31 cd       	rjmp	.-1438   	; 0xa828 <FreePrinting+0x9c>
			  }
	      break;

     case fpInitScroll:
	      iScroll=0;
    adc6:	10 92 40 02 	sts	0x0240, r1
		  iSend=0;
    adca:	10 92 3e 02 	sts	0x023E, r1
    adce:	10 92 3d 02 	sts	0x023D, r1
		  if (iPrinted<PrintCopy)
    add2:	90 91 45 02 	lds	r25, 0x0245
    add6:	80 91 42 02 	lds	r24, 0x0242
    adda:	98 17       	cp	r25, r24
    addc:	28 f4       	brcc	.+10     	; 0xade8 <FreePrinting+0x65c>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    adde:	e1 99       	sbic	0x1c, 1	; 28
    ade0:	fe cf       	rjmp	.-4      	; 0xadde <FreePrinting+0x652>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    ade2:	82 e3       	ldi	r24, 0x32	; 50
    ade4:	90 e0       	ldi	r25, 0x00	; 0
    ade6:	04 c0       	rjmp	.+8      	; 0xadf0 <FreePrinting+0x664>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    ade8:	e1 99       	sbic	0x1c, 1	; 28
    adea:	fe cf       	rjmp	.-4      	; 0xade8 <FreePrinting+0x65c>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    adec:	81 e3       	ldi	r24, 0x31	; 49
    adee:	90 e0       	ldi	r25, 0x00	; 0
    adf0:	9f bb       	out	0x1f, r25	; 31
    adf2:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    adf4:	e0 9a       	sbi	0x1c, 0	; 28
    adf6:	8d b3       	in	r24, 0x1d	; 29
		      nScroll=eeprom_read_byte(&DefPrintScrollSpace);
		  else if (iPrinted>=PrintCopy)
		  	  nScroll=eeprom_read_byte(&DefPrintScrollEnd);
    adf8:	80 93 3f 02 	sts	0x023F, r24

          stFreePrinting=fpScrollPaper;
    adfc:	8f e0       	ldi	r24, 0x0F	; 15
    adfe:	14 cd       	rjmp	.-1496   	; 0xa828 <FreePrinting+0x9c>
	      break;
     case fpScrollPaper:
	      if (iScroll>nScroll)stFreePrinting=fpPaperCut;
    ae00:	90 91 40 02 	lds	r25, 0x0240
    ae04:	80 91 3f 02 	lds	r24, 0x023F
    ae08:	89 17       	cp	r24, r25
    ae0a:	18 f4       	brcc	.+6      	; 0xae12 <FreePrinting+0x686>
    ae0c:	80 e1       	ldi	r24, 0x10	; 16
    ae0e:	80 93 15 01 	sts	0x0115, r24
		  iSend++;
    ae12:	80 91 3d 02 	lds	r24, 0x023D
    ae16:	90 91 3e 02 	lds	r25, 0x023E
    ae1a:	01 96       	adiw	r24, 0x01	; 1
    ae1c:	90 93 3e 02 	sts	0x023E, r25
    ae20:	80 93 3d 02 	sts	0x023D, r24
		  if (iSend%PRINT_DELAY==0){
		      CarriegeReturn();
    ae24:	0e 94 3d 4c 	call	0x987a	; 0x987a <CarriegeReturn>
			  iScroll++;
    ae28:	80 91 40 02 	lds	r24, 0x0240
    ae2c:	8f 5f       	subi	r24, 0xFF	; 255
    ae2e:	80 93 40 02 	sts	0x0240, r24
    ae32:	47 c0       	rjmp	.+142    	; 0xaec2 <FreePrinting+0x736>
			  }
	      break;
     case fpPaperCut:
		  //_uart_printf(0,1,PSTR("fpPaperCut"));
		  //iPrinted++;
          if (iPrinted<PrintCopy){
    ae34:	90 91 45 02 	lds	r25, 0x0245
    ae38:	80 91 42 02 	lds	r24, 0x0242
    ae3c:	98 17       	cp	r25, r24
    ae3e:	20 f4       	brcc	.+8      	; 0xae48 <FreePrinting+0x6bc>
		      CarriegeReturn();
    ae40:	0e 94 3d 4c 	call	0x987a	; 0x987a <CarriegeReturn>
              stFreePrinting=fpInitHeader;
    ae44:	82 e0       	ldi	r24, 0x02	; 2
    ae46:	07 c0       	rjmp	.+14     	; 0xae56 <FreePrinting+0x6ca>
			  }
          else{
		      if (IFType==IT_SLAVE)sendMessage04();
    ae48:	80 91 00 01 	lds	r24, 0x0100
    ae4c:	81 30       	cpi	r24, 0x01	; 1
    ae4e:	11 f4       	brne	.+4      	; 0xae54 <FreePrinting+0x6c8>
    ae50:	0e 94 62 53 	call	0xa6c4	; 0xa6c4 <sendMessage04>
		      stFreePrinting=fpFinishFreePrinting;
    ae54:	81 e1       	ldi	r24, 0x11	; 17
    ae56:	80 93 15 01 	sts	0x0115, r24
			  }
          
		  if (((cmdPrint&0b00100000)>>5)==1){
    ae5a:	80 91 b7 01 	lds	r24, 0x01B7
    ae5e:	85 ff       	sbrs	r24, 5
    ae60:	30 c0       	rjmp	.+96     	; 0xaec2 <FreePrinting+0x736>
		      if (iPrinted==0){
    ae62:	80 91 45 02 	lds	r24, 0x0245
    ae66:	88 23       	and	r24, r24
    ae68:	31 f4       	brne	.+12     	; 0xae76 <FreePrinting+0x6ea>
			      CarriegeReturn();_delay_ms(50);
    ae6a:	0e 94 3d 4c 	call	0x987a	; 0x987a <CarriegeReturn>
    ae6e:	84 ed       	ldi	r24, 0xD4	; 212
    ae70:	90 e3       	ldi	r25, 0x30	; 48
    ae72:	01 97       	sbiw	r24, 0x01	; 1
    ae74:	f1 f7       	brne	.-4      	; 0xae72 <FreePrinting+0x6e6>
				 }
              //HFCS 0000 : Header, Footer, Copy , Scrool [Copy:16x max]
		      if ((iPrinted==PrintCopy)){
    ae76:	90 91 45 02 	lds	r25, 0x0245
    ae7a:	80 91 42 02 	lds	r24, 0x0242
    ae7e:	98 17       	cp	r25, r24
    ae80:	b1 f4       	brne	.+44     	; 0xaeae <FreePrinting+0x722>
			      // if (((cmdPrint&0b00010000)>>4)==1){
				  CarriegeReturn();_delay_ms(50);
    ae82:	0e 94 3d 4c 	call	0x987a	; 0x987a <CarriegeReturn>
    ae86:	04 ed       	ldi	r16, 0xD4	; 212
    ae88:	10 e3       	ldi	r17, 0x30	; 48
    ae8a:	c8 01       	movw	r24, r16
    ae8c:	01 97       	sbiw	r24, 0x01	; 1
    ae8e:	f1 f7       	brne	.-4      	; 0xae8c <FreePrinting+0x700>
				  CarriegeReturn();_delay_ms(50);
    ae90:	0e 94 3d 4c 	call	0x987a	; 0x987a <CarriegeReturn>
    ae94:	c8 01       	movw	r24, r16
    ae96:	01 97       	sbiw	r24, 0x01	; 1
    ae98:	f1 f7       	brne	.-4      	; 0xae96 <FreePrinting+0x70a>
				  CarriegeReturn();_delay_ms(50);
    ae9a:	0e 94 3d 4c 	call	0x987a	; 0x987a <CarriegeReturn>
    ae9e:	c8 01       	movw	r24, r16
    aea0:	01 97       	sbiw	r24, 0x01	; 1
    aea2:	f1 f7       	brne	.-4      	; 0xaea0 <FreePrinting+0x714>
				  CarriegeReturn();_delay_ms(50);
    aea4:	0e 94 3d 4c 	call	0x987a	; 0x987a <CarriegeReturn>
    aea8:	c8 01       	movw	r24, r16
    aeaa:	01 97       	sbiw	r24, 0x01	; 1
    aeac:	f1 f7       	brne	.-4      	; 0xaeaa <FreePrinting+0x71e>
				   //}
				 }
		      PaperCut();
    aeae:	0e 94 e4 4c 	call	0x99c8	; 0x99c8 <PaperCut>
    aeb2:	07 c0       	rjmp	.+14     	; 0xaec2 <FreePrinting+0x736>
		   }
	      break;
     case fpFinishFreePrinting:
	 	  //_uart_printf(0,1,PSTR("fpFinished"));
		  IsBusyFreePrinting=False;
    aeb4:	10 92 b6 01 	sts	0x01B6, r1
	      stFreePrinting=fpInit;
    aeb8:	81 e0       	ldi	r24, 0x01	; 1
    aeba:	80 93 15 01 	sts	0x0115, r24
		  iPrinted=0;
    aebe:	10 92 45 02 	sts	0x0245, r1
	      break;
	 }//EndCase
}
    aec2:	64 96       	adiw	r28, 0x14	; 20
    aec4:	0f b6       	in	r0, 0x3f	; 63
    aec6:	f8 94       	cli
    aec8:	de bf       	out	0x3e, r29	; 62
    aeca:	0f be       	out	0x3f, r0	; 63
    aecc:	cd bf       	out	0x3d, r28	; 61
    aece:	cf 91       	pop	r28
    aed0:	df 91       	pop	r29
    aed2:	1f 91       	pop	r17
    aed4:	0f 91       	pop	r16
    aed6:	08 95       	ret

0000aed8 <PrintIdle>:
		//Font Setting: 1D 21 01
		_uart(_COM_PRINTER, 1, 0x1D);_uart(_COM_PRINTER, 1, 0x21);_uart(_COM_PRINTER, 1, 0x00);   
		}
}

void PrintIdle(){
    aed8:	0f 93       	push	r16
    aeda:	1f 93       	push	r17
    aedc:	df 93       	push	r29
    aede:	cf 93       	push	r28
    aee0:	cd b7       	in	r28, 0x3d	; 61
    aee2:	de b7       	in	r29, 0x3e	; 62
    aee4:	64 97       	sbiw	r28, 0x14	; 20
    aee6:	0f b6       	in	r0, 0x3f	; 63
    aee8:	f8 94       	cli
    aeea:	de bf       	out	0x3e, r29	; 62
    aeec:	0f be       	out	0x3f, r0	; 63
    aeee:	cd bf       	out	0x3d, r28	; 61
		_uart_print(1,1,strSend);
	 }
	 #endif

     //Normalize PrintIdleState
     if ((IsPrinting==True)&&(stPrintIdle!=piIdle)){
    aef0:	80 91 af 01 	lds	r24, 0x01AF
    aef4:	81 30       	cpi	r24, 0x01	; 1
    aef6:	31 f4       	brne	.+12     	; 0xaf04 <PrintIdle+0x2c>
    aef8:	80 91 56 02 	lds	r24, 0x0256
    aefc:	88 23       	and	r24, r24
    aefe:	11 f0       	breq	.+4      	; 0xaf04 <PrintIdle+0x2c>
	     stPrintIdle=piIdle;
    af00:	10 92 56 02 	sts	0x0256, r1
	 }

     switch(stPrintIdle){
    af04:	80 91 56 02 	lds	r24, 0x0256
    af08:	e8 2f       	mov	r30, r24
    af0a:	f0 e0       	ldi	r31, 0x00	; 0
    af0c:	e8 31       	cpi	r30, 0x18	; 24
    af0e:	f1 05       	cpc	r31, r1
    af10:	08 f0       	brcs	.+2      	; 0xaf14 <PrintIdle+0x3c>
    af12:	95 c7       	rjmp	.+3882   	; 0xbe3e <PrintIdle+0xf66>
    af14:	e1 58       	subi	r30, 0x81	; 129
    af16:	ff 4f       	sbci	r31, 0xFF	; 255
    af18:	ee 0f       	add	r30, r30
    af1a:	ff 1f       	adc	r31, r31
    af1c:	05 90       	lpm	r0, Z+
    af1e:	f4 91       	lpm	r31, Z+
    af20:	e0 2d       	mov	r30, r0
    af22:	09 94       	ijmp
	 case piIdle:
	      if (IsPrinting==True){
    af24:	80 91 af 01 	lds	r24, 0x01AF
    af28:	81 30       	cpi	r24, 0x01	; 1
    af2a:	09 f0       	breq	.+2      	; 0xaf2e <PrintIdle+0x56>
    af2c:	88 c7       	rjmp	.+3856   	; 0xbe3e <PrintIdle+0xf66>
		      IsPrinting=False;
    af2e:	10 92 af 01 	sts	0x01AF, r1
			  IsBusyIdlePrinting=True;
    af32:	80 93 b4 01 	sts	0x01B4, r24
			  IsBusyPrint=False;
    af36:	10 92 b5 01 	sts	0x01B5, r1
			  iPrinted=0;
    af3a:	10 92 48 02 	sts	0x0248, r1
			  PrintCopy=0;
    af3e:	10 92 47 02 	sts	0x0247, r1
		      stPrintIdle=piInit;
    af42:	80 93 56 02 	sts	0x0256, r24
			  InitPrinter();
    af46:	0e 94 48 4c 	call	0x9890	; 0x9890 <InitPrinter>
			  IsSignedField=False;
    af4a:	10 92 4f 02 	sts	0x024F, r1
    af4e:	77 c7       	rjmp	.+3822   	; 0xbe3e <PrintIdle+0xf66>
			  }
	      break;
	 case piInit:
	      iHeader=0;
    af50:	10 92 55 02 	sts	0x0255, r1
		  CarriegeReturn();
    af54:	0e 94 3d 4c 	call	0x987a	; 0x987a <CarriegeReturn>
    af58:	1d c0       	rjmp	.+58     	; 0xaf94 <PrintIdle+0xbc>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    af5a:	60 91 55 02 	lds	r22, 0x0255
    af5e:	89 e2       	ldi	r24, 0x29	; 41
    af60:	68 9f       	mul	r22, r24
    af62:	b0 01       	movw	r22, r0
    af64:	11 24       	eor	r1, r1
    af66:	69 5d       	subi	r22, 0xD9	; 217
    af68:	7d 4f       	sbci	r23, 0xFD	; 253
    af6a:	80 ef       	ldi	r24, 0xF0	; 240
    af6c:	99 e0       	ldi	r25, 0x09	; 9
    af6e:	49 e2       	ldi	r20, 0x29	; 41
    af70:	50 e0       	ldi	r21, 0x00	; 0
    af72:	2d ef       	ldi	r18, 0xFD	; 253
    af74:	32 e1       	ldi	r19, 0x12	; 18
    af76:	0e 94 f1 b3 	call	0x167e2	; 0x167e2 <__eerd_block>
		  stPrintIdle=piLoadHeader;
	      break;
     case piLoadHeader:
	      eeprom_read_block((void*) &strPrint, (const void*) &DefHeaderFooter[iHeader], sizeof(DefHeaderFooter[iHeader]));
		  iHeader++;
    af7a:	80 91 55 02 	lds	r24, 0x0255
    af7e:	8f 5f       	subi	r24, 0xFF	; 255
    af80:	80 93 55 02 	sts	0x0255, r24
		  if (iHeader<6){
    af84:	86 30       	cpi	r24, 0x06	; 6
    af86:	00 f5       	brcc	.+64     	; 0xafc8 <PrintIdle+0xf0>
		      if (SpaceOnly(strPrint)==True){
    af88:	80 ef       	ldi	r24, 0xF0	; 240
    af8a:	99 e0       	ldi	r25, 0x09	; 9
    af8c:	0e 94 f4 23 	call	0x47e8	; 0x47e8 <SpaceOnly>
    af90:	81 30       	cpi	r24, 0x01	; 1
    af92:	11 f4       	brne	.+4      	; 0xaf98 <PrintIdle+0xc0>
			      stPrintIdle=piLoadHeader;
    af94:	82 e0       	ldi	r24, 0x02	; 2
    af96:	28 c7       	rjmp	.+3664   	; 0xbde8 <PrintIdle+0xf10>
				  }	      
			  else{
			      stPrintIdle=piPrintHeader;
    af98:	83 e0       	ldi	r24, 0x03	; 3
    af9a:	80 93 56 02 	sts	0x0256, r24
			      iSend=0;
    af9e:	10 92 4e 02 	sts	0x024E, r1
    afa2:	10 92 4d 02 	sts	0x024D, r1
				  iLoop=0;
    afa6:	10 92 4a 02 	sts	0x024A, r1
    afaa:	10 92 49 02 	sts	0x0249, r1
				  //PrintDoubleHeight on 1st Header
				  if (iHeader==1) PrintDoubleHeight();
    afae:	80 91 55 02 	lds	r24, 0x0255
    afb2:	81 30       	cpi	r24, 0x01	; 1
    afb4:	19 f4       	brne	.+6      	; 0xafbc <PrintIdle+0xe4>
    afb6:	0e 94 ca 4c 	call	0x9994	; 0x9994 <PrintDoubleHeight>
    afba:	41 c7       	rjmp	.+3714   	; 0xbe3e <PrintIdle+0xf66>
				  else 
				  if (iHeader==2) PrintNormalHeight();
    afbc:	82 30       	cpi	r24, 0x02	; 2
    afbe:	09 f0       	breq	.+2      	; 0xafc2 <PrintIdle+0xea>
    afc0:	3e c7       	rjmp	.+3708   	; 0xbe3e <PrintIdle+0xf66>
    afc2:	0e 94 b0 4c 	call	0x9960	; 0x9960 <PrintNormalHeight>
    afc6:	3b c7       	rjmp	.+3702   	; 0xbe3e <PrintIdle+0xf66>
			   }
		  }else{stPrintIdle=piInitDuplicate; //stPrintIdle=piInitMessage;//
    afc8:	84 e0       	ldi	r24, 0x04	; 4
    afca:	0e c7       	rjmp	.+3612   	; 0xbde8 <PrintIdle+0xf10>
		        //else stPrintIdle=piInitMessage;
		  }
	      break;
	 case piPrintHeader:
		  if (iSend<40){
    afcc:	80 91 4d 02 	lds	r24, 0x024D
    afd0:	90 91 4e 02 	lds	r25, 0x024E
    afd4:	88 97       	sbiw	r24, 0x28	; 40
    afd6:	68 f4       	brcc	.+26     	; 0xaff2 <PrintIdle+0x11a>
		      iLoop++;
    afd8:	80 91 49 02 	lds	r24, 0x0249
    afdc:	90 91 4a 02 	lds	r25, 0x024A
    afe0:	01 96       	adiw	r24, 0x01	; 1
    afe2:	90 93 4a 02 	sts	0x024A, r25
    afe6:	80 93 49 02 	sts	0x0249, r24
			  if ((iLoop%PRINT_DELAY)==0){
				 TimPrintBusy=0;
    afea:	10 92 b8 01 	sts	0x01B8, r1
				 stPrintIdle=piCheckPrintStatusHeader;
    afee:	8b e0       	ldi	r24, 0x0B	; 11
    aff0:	fb c6       	rjmp	.+3574   	; 0xbde8 <PrintIdle+0xf10>
				 }
			  }
          else{ 
		     stPrintIdle=piLoadHeader;
    aff2:	82 e0       	ldi	r24, 0x02	; 2
    aff4:	8d c6       	rjmp	.+3354   	; 0xbd10 <PrintIdle+0xe38>
			 CarriegeReturn();
		  }
	      break;
     case piCheckPrintStatusHeader:
	      if (IsBusyPrint==False){
    aff6:	80 91 b5 01 	lds	r24, 0x01B5
    affa:	88 23       	and	r24, r24
    affc:	09 f0       	breq	.+2      	; 0xb000 <PrintIdle+0x128>
    affe:	ec c6       	rjmp	.+3544   	; 0xbdd8 <PrintIdle+0xf00>
		      _uart(_COM_PRINTER,1,strPrint[iSend]);
    b000:	e0 91 4d 02 	lds	r30, 0x024D
    b004:	f0 91 4e 02 	lds	r31, 0x024E
    b008:	e0 51       	subi	r30, 0x10	; 16
    b00a:	f6 4f       	sbci	r31, 0xF6	; 246
    b00c:	61 e0       	ldi	r22, 0x01	; 1
    b00e:	40 81       	ld	r20, Z
    b010:	0e 94 53 b2 	call	0x164a6	; 0x164a6 <_uart>
		      iSend++;
    b014:	80 91 4d 02 	lds	r24, 0x024D
    b018:	90 91 4e 02 	lds	r25, 0x024E
    b01c:	01 96       	adiw	r24, 0x01	; 1
    b01e:	90 93 4e 02 	sts	0x024E, r25
    b022:	80 93 4d 02 	sts	0x024D, r24
		      stPrintIdle=piPrintHeader;
    b026:	83 e0       	ldi	r24, 0x03	; 3
    b028:	d5 c6       	rjmp	.+3498   	; 0xbdd4 <PrintIdle+0xefc>
		      stPrintIdle=piFinishPrintIdle;
			  }
	      break;

     case piInitDuplicate:
          if ((iPrinted>0)||(IsReprintTicket==True)){
    b02a:	80 91 48 02 	lds	r24, 0x0248
    b02e:	88 23       	and	r24, r24
    b030:	21 f4       	brne	.+8      	; 0xb03a <PrintIdle+0x162>
    b032:	80 91 82 01 	lds	r24, 0x0182
    b036:	81 30       	cpi	r24, 0x01	; 1
    b038:	a9 f4       	brne	.+42     	; 0xb064 <PrintIdle+0x18c>
		      IsReprintTicket=False;
    b03a:	10 92 82 01 	sts	0x0182, r1
		      CarriegeReturn(); 
    b03e:	0e 94 3d 4c 	call	0x987a	; 0x987a <CarriegeReturn>
		      sprintf_P(strPrint,PSTR("             DUPLICATE COPY        "));
    b042:	00 d0       	rcall	.+0      	; 0xb044 <PrintIdle+0x16c>
    b044:	00 d0       	rcall	.+0      	; 0xb046 <PrintIdle+0x16e>
    b046:	80 ef       	ldi	r24, 0xF0	; 240
    b048:	99 e0       	ldi	r25, 0x09	; 9
    b04a:	ad b7       	in	r26, 0x3d	; 61
    b04c:	be b7       	in	r27, 0x3e	; 62
    b04e:	12 96       	adiw	r26, 0x02	; 2
    b050:	9c 93       	st	X, r25
    b052:	8e 93       	st	-X, r24
    b054:	11 97       	sbiw	r26, 0x01	; 1
    b056:	85 e1       	ldi	r24, 0x15	; 21
    b058:	9a e0       	ldi	r25, 0x0A	; 10
    b05a:	14 96       	adiw	r26, 0x04	; 4
    b05c:	9c 93       	st	X, r25
    b05e:	8e 93       	st	-X, r24
    b060:	13 97       	sbiw	r26, 0x03	; 3
    b062:	0c c0       	rjmp	.+24     	; 0xb07c <PrintIdle+0x1a4>
		      }
          else{           sprintf_P(strPrint,PSTR(" "));
    b064:	00 d0       	rcall	.+0      	; 0xb066 <PrintIdle+0x18e>
    b066:	00 d0       	rcall	.+0      	; 0xb068 <PrintIdle+0x190>
    b068:	80 ef       	ldi	r24, 0xF0	; 240
    b06a:	99 e0       	ldi	r25, 0x09	; 9
    b06c:	ed b7       	in	r30, 0x3d	; 61
    b06e:	fe b7       	in	r31, 0x3e	; 62
    b070:	92 83       	std	Z+2, r25	; 0x02
    b072:	81 83       	std	Z+1, r24	; 0x01
    b074:	83 e1       	ldi	r24, 0x13	; 19
    b076:	9a e0       	ldi	r25, 0x0A	; 10
    b078:	94 83       	std	Z+4, r25	; 0x04
    b07a:	83 83       	std	Z+3, r24	; 0x03
    b07c:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    b080:	0f 90       	pop	r0
    b082:	0f 90       	pop	r0
    b084:	0f 90       	pop	r0
    b086:	0f 90       	pop	r0
		      }
		  iSend=0;
    b088:	10 92 4e 02 	sts	0x024E, r1
    b08c:	10 92 4d 02 	sts	0x024D, r1
		  iLoop=0;
    b090:	10 92 4a 02 	sts	0x024A, r1
    b094:	10 92 49 02 	sts	0x0249, r1
		  LSend=strlen(strPrint);
    b098:	e0 ef       	ldi	r30, 0xF0	; 240
    b09a:	f9 e0       	ldi	r31, 0x09	; 9
    b09c:	01 90       	ld	r0, Z+
    b09e:	00 20       	and	r0, r0
    b0a0:	e9 f7       	brne	.-6      	; 0xb09c <PrintIdle+0x1c4>
    b0a2:	31 97       	sbiw	r30, 0x01	; 1
    b0a4:	e0 5f       	subi	r30, 0xF0	; 240
    b0a6:	f9 40       	sbci	r31, 0x09	; 9
    b0a8:	f0 93 4c 02 	sts	0x024C, r31
    b0ac:	e0 93 4b 02 	sts	0x024B, r30
          stPrintIdle=piPrintDuplicate; 
    b0b0:	85 e0       	ldi	r24, 0x05	; 5
    b0b2:	9a c6       	rjmp	.+3380   	; 0xbde8 <PrintIdle+0xf10>
	      break;
     case piPrintDuplicate:
		  if (iSend<LSend){
    b0b4:	20 91 4d 02 	lds	r18, 0x024D
    b0b8:	30 91 4e 02 	lds	r19, 0x024E
    b0bc:	80 91 4b 02 	lds	r24, 0x024B
    b0c0:	90 91 4c 02 	lds	r25, 0x024C
    b0c4:	28 17       	cp	r18, r24
    b0c6:	39 07       	cpc	r19, r25
    b0c8:	68 f4       	brcc	.+26     	; 0xb0e4 <PrintIdle+0x20c>
		      iLoop++;
    b0ca:	80 91 49 02 	lds	r24, 0x0249
    b0ce:	90 91 4a 02 	lds	r25, 0x024A
    b0d2:	01 96       	adiw	r24, 0x01	; 1
    b0d4:	90 93 4a 02 	sts	0x024A, r25
    b0d8:	80 93 49 02 	sts	0x0249, r24
			  if((iLoop%PRINT_DELAY)==0){
				 TimPrintBusy=0;
    b0dc:	10 92 b8 01 	sts	0x01B8, r1
                 stPrintIdle=piCheckPrintStatusDuplicate;
    b0e0:	86 e0       	ldi	r24, 0x06	; 6
    b0e2:	82 c6       	rjmp	.+3332   	; 0xbde8 <PrintIdle+0xf10>
				 }
			  }
          else {
		     iSend=0;
    b0e4:	10 92 4e 02 	sts	0x024E, r1
    b0e8:	10 92 4d 02 	sts	0x024D, r1
		     stPrintIdle=piInitMessage;
    b0ec:	87 e0       	ldi	r24, 0x07	; 7
    b0ee:	7c c6       	rjmp	.+3320   	; 0xbde8 <PrintIdle+0xf10>
			 }
	      break;
     case piCheckPrintStatusDuplicate:
	      if (IsBusyPrint==False){
    b0f0:	80 91 b5 01 	lds	r24, 0x01B5
    b0f4:	88 23       	and	r24, r24
    b0f6:	09 f0       	breq	.+2      	; 0xb0fa <PrintIdle+0x222>
    b0f8:	6f c6       	rjmp	.+3294   	; 0xbdd8 <PrintIdle+0xf00>
		      _uart(_COM_PRINTER,1,strPrint[iSend]);
    b0fa:	e0 91 4d 02 	lds	r30, 0x024D
    b0fe:	f0 91 4e 02 	lds	r31, 0x024E
    b102:	e0 51       	subi	r30, 0x10	; 16
    b104:	f6 4f       	sbci	r31, 0xF6	; 246
    b106:	61 e0       	ldi	r22, 0x01	; 1
    b108:	40 81       	ld	r20, Z
    b10a:	0e 94 53 b2 	call	0x164a6	; 0x164a6 <_uart>
    b10e:	84 ec       	ldi	r24, 0xC4	; 196
    b110:	99 e0       	ldi	r25, 0x09	; 9
    b112:	01 97       	sbiw	r24, 0x01	; 1
    b114:	f1 f7       	brne	.-4      	; 0xb112 <PrintIdle+0x23a>
			  _delay_ms(10);
		      iSend++;
    b116:	80 91 4d 02 	lds	r24, 0x024D
    b11a:	90 91 4e 02 	lds	r25, 0x024E
    b11e:	01 96       	adiw	r24, 0x01	; 1
    b120:	90 93 4e 02 	sts	0x024E, r25
    b124:	80 93 4d 02 	sts	0x024D, r24
		      stPrintIdle=piPrintDuplicate;
    b128:	85 e0       	ldi	r24, 0x05	; 5
    b12a:	54 c6       	rjmp	.+3240   	; 0xbdd4 <PrintIdle+0xefc>
		      stPrintIdle=piFinishPrintIdle;
			  }
	      break;

     case piInitMessage:
	      iSend=0;iLoop=0;
    b12c:	10 92 4e 02 	sts	0x024E, r1
    b130:	10 92 4d 02 	sts	0x024D, r1
    b134:	10 92 4a 02 	sts	0x024A, r1
    b138:	10 92 49 02 	sts	0x0249, r1
		  iMessage=0;
    b13c:	10 92 51 02 	sts	0x0251, r1
		  switch(MOPType){
    b140:	80 91 ba 01 	lds	r24, 0x01BA
    b144:	83 30       	cpi	r24, 0x03	; 3
    b146:	81 f0       	breq	.+32     	; 0xb168 <PrintIdle+0x290>
    b148:	84 30       	cpi	r24, 0x04	; 4
    b14a:	28 f4       	brcc	.+10     	; 0xb156 <PrintIdle+0x27e>
    b14c:	81 30       	cpi	r24, 0x01	; 1
    b14e:	61 f0       	breq	.+24     	; 0xb168 <PrintIdle+0x290>
    b150:	82 30       	cpi	r24, 0x02	; 2
    b152:	40 f4       	brcc	.+16     	; 0xb164 <PrintIdle+0x28c>
    b154:	10 c0       	rjmp	.+32     	; 0xb176 <PrintIdle+0x29e>
    b156:	88 30       	cpi	r24, 0x08	; 8
    b158:	49 f0       	breq	.+18     	; 0xb16c <PrintIdle+0x294>
    b15a:	89 30       	cpi	r24, 0x09	; 9
    b15c:	61 f0       	breq	.+24     	; 0xb176 <PrintIdle+0x29e>
    b15e:	87 30       	cpi	r24, 0x07	; 7
    b160:	51 f4       	brne	.+20     	; 0xb176 <PrintIdle+0x29e>
    b162:	02 c0       	rjmp	.+4      	; 0xb168 <PrintIdle+0x290>
		  case MOP_CASH:
		       MessageLine=10;
			   PrintCopy=1;
		       break;
          case MOP_CREDIT_CARD:
		       MessageLine=10;
    b164:	8a e0       	ldi	r24, 0x0A	; 10
    b166:	03 c0       	rjmp	.+6      	; 0xb16e <PrintIdle+0x296>
          case MOP_LOCAL_ACCOUNT:
		       MessageLine=20;
			   PrintCopy=2;
		       break;
          case MOP_VOUCHER:
		       MessageLine=20;
    b168:	84 e1       	ldi	r24, 0x14	; 20
    b16a:	01 c0       	rjmp	.+2      	; 0xb16e <PrintIdle+0x296>
			   PrintCopy=2;
		       break;
          case MOP_PUMP_TEST:
		       MessageLine=12;
    b16c:	8c e0       	ldi	r24, 0x0C	; 12
    b16e:	80 93 50 02 	sts	0x0250, r24
			   PrintCopy=2;
    b172:	82 e0       	ldi	r24, 0x02	; 2
    b174:	04 c0       	rjmp	.+8      	; 0xb17e <PrintIdle+0x2a6>
          case MOP_VOID_CARD:
		       MessageLine=10;
			   PrintCopy=1;
		       break;          
          default:
		       MessageLine=10;
    b176:	8a e0       	ldi	r24, 0x0A	; 10
    b178:	80 93 50 02 	sts	0x0250, r24
			   PrintCopy=1;
    b17c:	81 e0       	ldi	r24, 0x01	; 1
    b17e:	80 93 47 02 	sts	0x0247, r24
		       break; 
		  }
		  //LoyaltyDetection
          if ((strlen(strLoyCardID)>0)&&(SpaceOnly(strLoyCardID)==False)){
    b182:	80 91 f6 03 	lds	r24, 0x03F6
    b186:	88 23       	and	r24, r24
    b188:	49 f0       	breq	.+18     	; 0xb19c <PrintIdle+0x2c4>
    b18a:	86 ef       	ldi	r24, 0xF6	; 246
    b18c:	93 e0       	ldi	r25, 0x03	; 3
    b18e:	0e 94 f4 23 	call	0x47e8	; 0x47e8 <SpaceOnly>
    b192:	88 23       	and	r24, r24
    b194:	19 f4       	brne	.+6      	; 0xb19c <PrintIdle+0x2c4>
		       MessageLine=33;
    b196:	81 e2       	ldi	r24, 0x21	; 33
    b198:	80 93 50 02 	sts	0x0250, r24
		  }
          //stPrintIdle=piLoadMessage;
		  stPrintIdle=piFormatingMessage;
    b19c:	88 e0       	ldi	r24, 0x08	; 8
    b19e:	24 c6       	rjmp	.+3144   	; 0xbde8 <PrintIdle+0xf10>
	      break;
     case piFormatingMessage:
	      if (iPrinted==0){
    b1a0:	80 91 48 02 	lds	r24, 0x0248
    b1a4:	88 23       	and	r24, r24
    b1a6:	09 f0       	breq	.+2      	; 0xb1aa <PrintIdle+0x2d2>
    b1a8:	c9 c4       	rjmp	.+2450   	; 0xbb3c <PrintIdle+0xc64>

		      FormatDate(DATE_LONG_YEAR,strDate);
    b1aa:	60 e8       	ldi	r22, 0x80	; 128
    b1ac:	78 e0       	ldi	r23, 0x08	; 8
    b1ae:	0e 94 c8 24 	call	0x4990	; 0x4990 <FormatDate>
              RemZeroLead(strIslandID);
    b1b2:	8b e2       	ldi	r24, 0x2B	; 43
    b1b4:	9a e0       	ldi	r25, 0x0A	; 10
    b1b6:	0e 94 19 25 	call	0x4a32	; 0x4a32 <RemZeroLead>
			  RemZeroLead(strFIP_ID);
    b1ba:	8b ec       	ldi	r24, 0xCB	; 203
    b1bc:	98 e0       	ldi	r25, 0x08	; 8
    b1be:	0e 94 19 25 	call	0x4a32	; 0x4a32 <RemZeroLead>
		      RemZeroLead(strPrice);              
    b1c2:	80 eb       	ldi	r24, 0xB0	; 176
    b1c4:	96 e0       	ldi	r25, 0x06	; 6
    b1c6:	0e 94 19 25 	call	0x4a32	; 0x4a32 <RemZeroLead>
              if (IFType==IT_SLAVE)
    b1ca:	80 91 00 01 	lds	r24, 0x0100
    b1ce:	81 30       	cpi	r24, 0x01	; 1
    b1d0:	21 f4       	brne	.+8      	; 0xb1da <PrintIdle+0x302>
			      RemZeroLead(strVolume);
    b1d2:	84 e8       	ldi	r24, 0x84	; 132
    b1d4:	94 e0       	ldi	r25, 0x04	; 4
    b1d6:	0e 94 19 25 	call	0x4a32	; 0x4a32 <RemZeroLead>
              RemZeroLead(strAmount);
    b1da:	87 ee       	ldi	r24, 0xE7	; 231
    b1dc:	9c e0       	ldi	r25, 0x0C	; 12
    b1de:	0e 94 19 25 	call	0x4a32	; 0x4a32 <RemZeroLead>

			  RemDecimal(strPrice);
    b1e2:	80 eb       	ldi	r24, 0xB0	; 176
    b1e4:	96 e0       	ldi	r25, 0x06	; 6
    b1e6:	0e 94 11 24 	call	0x4822	; 0x4822 <RemDecimal>
			  RemDecimal(strAmount);
    b1ea:	87 ee       	ldi	r24, 0xE7	; 231
    b1ec:	9c e0       	ldi	r25, 0x0C	; 12
    b1ee:	0e 94 11 24 	call	0x4822	; 0x4822 <RemDecimal>
	  
			  FormatCurrency(strPrice);
    b1f2:	80 eb       	ldi	r24, 0xB0	; 176
    b1f4:	96 e0       	ldi	r25, 0x06	; 6
    b1f6:	0e 94 09 33 	call	0x6612	; 0x6612 <FormatCurrency>
			  FormatCurrency(strAmount);
    b1fa:	87 ee       	ldi	r24, 0xE7	; 231
    b1fc:	9c e0       	ldi	r25, 0x0C	; 12
    b1fe:	0e 94 09 33 	call	0x6612	; 0x6612 <FormatCurrency>
              if (IFType==IT_SLAVE){
    b202:	80 91 00 01 	lds	r24, 0x0100
    b206:	81 30       	cpi	r24, 0x01	; 1
    b208:	09 f0       	breq	.+2      	; 0xb20c <PrintIdle+0x334>
    b20a:	98 c4       	rjmp	.+2352   	; 0xbb3c <PrintIdle+0xc64>
		          RemSpaceLag(strCardID);
    b20c:	8d eb       	ldi	r24, 0xBD	; 189
    b20e:	9c e0       	ldi	r25, 0x0C	; 12
    b210:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <RemSpaceLag>
		          RemSpaceLag(strCardHolder);
    b214:	83 e3       	ldi	r24, 0x33	; 51
    b216:	94 e0       	ldi	r25, 0x04	; 4
    b218:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <RemSpaceLag>
		          RemSpaceLag(strMOPName);
    b21c:	8f e8       	ldi	r24, 0x8F	; 143
    b21e:	96 e0       	ldi	r25, 0x06	; 6
    b220:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <RemSpaceLag>
		          RemSpaceLag(strLoyCardHolder);
    b224:	83 ed       	ldi	r24, 0xD3	; 211
    b226:	93 e0       	ldi	r25, 0x03	; 3
    b228:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <RemSpaceLag>
		          RemSpaceLag(strCorporateID);
    b22c:	81 e4       	ldi	r24, 0x41	; 65
    b22e:	9d e0       	ldi	r25, 0x0D	; 13
    b230:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <RemSpaceLag>
		          RemSpaceLag(strCorporateName);
    b234:	8c ed       	ldi	r24, 0xDC	; 220
    b236:	94 e0       	ldi	r25, 0x04	; 4
    b238:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <RemSpaceLag>
		          RemSpaceLag(strLoyRedeemPoints);
    b23c:	89 ea       	ldi	r24, 0xA9	; 169
    b23e:	94 e0       	ldi	r25, 0x04	; 4
    b240:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <RemSpaceLag>
		          RemSpaceLag(strLoyCurrMonConsumeV);
    b244:	84 e2       	ldi	r24, 0x24	; 36
    b246:	9d e0       	ldi	r25, 0x0D	; 13
    b248:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <RemSpaceLag>
				  RemSpaceLag(strLoyCurrMonConsumeA);
    b24c:	8d e8       	ldi	r24, 0x8D	; 141
    b24e:	94 e0       	ldi	r25, 0x04	; 4
    b250:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <RemSpaceLag>
		          FormatCurrency(strLoyCurrMonConsumeV);              
    b254:	84 e2       	ldi	r24, 0x24	; 36
    b256:	9d e0       	ldi	r25, 0x0D	; 13
    b258:	0e 94 09 33 	call	0x6612	; 0x6612 <FormatCurrency>
		          FormatCurrency(strLoyCurrMonConsumeA);
    b25c:	8d e8       	ldi	r24, 0x8D	; 141
    b25e:	94 e0       	ldi	r25, 0x04	; 4
    b260:	0e 94 09 33 	call	0x6612	; 0x6612 <FormatCurrency>
    b264:	6b c4       	rjmp	.+2262   	; 0xbb3c <PrintIdle+0xc64>
			   }
		  }
          stPrintIdle=piLoadMessage;
	      break;
     case piLoadMessage:
	      switch(iMessage){
    b266:	80 91 51 02 	lds	r24, 0x0251
    b26a:	e8 2f       	mov	r30, r24
    b26c:	f0 e0       	ldi	r31, 0x00	; 0
    b26e:	e5 32       	cpi	r30, 0x25	; 37
    b270:	f1 05       	cpc	r31, r1
    b272:	08 f0       	brcs	.+2      	; 0xb276 <PrintIdle+0x39e>
    b274:	26 c4       	rjmp	.+2124   	; 0xbac2 <PrintIdle+0xbea>
    b276:	e9 56       	subi	r30, 0x69	; 105
    b278:	ff 4f       	sbci	r31, 0xFF	; 255
    b27a:	ee 0f       	add	r30, r30
    b27c:	ff 1f       	adc	r31, r31
    b27e:	05 90       	lpm	r0, Z+
    b280:	f4 91       	lpm	r31, Z+
    b282:	e0 2d       	mov	r30, r0
    b284:	09 94       	ijmp
		  case 0:
		       CarriegeReturn();
    b286:	0e 94 3d 4c 	call	0x987a	; 0x987a <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("      Shift: %s  No.Trans: %s "),strShift,strTranNo);
    b28a:	8d b7       	in	r24, 0x3d	; 61
    b28c:	9e b7       	in	r25, 0x3e	; 62
    b28e:	08 97       	sbiw	r24, 0x08	; 8
    b290:	0f b6       	in	r0, 0x3f	; 63
    b292:	f8 94       	cli
    b294:	9e bf       	out	0x3e, r25	; 62
    b296:	0f be       	out	0x3f, r0	; 63
    b298:	8d bf       	out	0x3d, r24	; 61
    b29a:	ed b7       	in	r30, 0x3d	; 61
    b29c:	fe b7       	in	r31, 0x3e	; 62
    b29e:	31 96       	adiw	r30, 0x01	; 1
    b2a0:	80 ef       	ldi	r24, 0xF0	; 240
    b2a2:	99 e0       	ldi	r25, 0x09	; 9
    b2a4:	ad b7       	in	r26, 0x3d	; 61
    b2a6:	be b7       	in	r27, 0x3e	; 62
    b2a8:	12 96       	adiw	r26, 0x02	; 2
    b2aa:	9c 93       	st	X, r25
    b2ac:	8e 93       	st	-X, r24
    b2ae:	11 97       	sbiw	r26, 0x01	; 1
    b2b0:	84 ef       	ldi	r24, 0xF4	; 244
    b2b2:	99 e0       	ldi	r25, 0x09	; 9
    b2b4:	93 83       	std	Z+3, r25	; 0x03
    b2b6:	82 83       	std	Z+2, r24	; 0x02
    b2b8:	8f e9       	ldi	r24, 0x9F	; 159
    b2ba:	9d e0       	ldi	r25, 0x0D	; 13
    b2bc:	95 83       	std	Z+5, r25	; 0x05
    b2be:	84 83       	std	Z+4, r24	; 0x04
    b2c0:	8e eb       	ldi	r24, 0xBE	; 190
    b2c2:	9d e0       	ldi	r25, 0x0D	; 13
    b2c4:	1f c0       	rjmp	.+62     	; 0xb304 <PrintIdle+0x42c>
		       break;
		  case 1:
		       //FormatDate(strDate);
			   CarriegeReturn();
    b2c6:	0e 94 3d 4c 	call	0x987a	; 0x987a <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("      Waktu: %s %s "),strDate,strTime);
    b2ca:	8d b7       	in	r24, 0x3d	; 61
    b2cc:	9e b7       	in	r25, 0x3e	; 62
    b2ce:	08 97       	sbiw	r24, 0x08	; 8
    b2d0:	0f b6       	in	r0, 0x3f	; 63
    b2d2:	f8 94       	cli
    b2d4:	9e bf       	out	0x3e, r25	; 62
    b2d6:	0f be       	out	0x3f, r0	; 63
    b2d8:	8d bf       	out	0x3d, r24	; 61
    b2da:	ed b7       	in	r30, 0x3d	; 61
    b2dc:	fe b7       	in	r31, 0x3e	; 62
    b2de:	31 96       	adiw	r30, 0x01	; 1
    b2e0:	80 ef       	ldi	r24, 0xF0	; 240
    b2e2:	99 e0       	ldi	r25, 0x09	; 9
    b2e4:	ad b7       	in	r26, 0x3d	; 61
    b2e6:	be b7       	in	r27, 0x3e	; 62
    b2e8:	12 96       	adiw	r26, 0x02	; 2
    b2ea:	9c 93       	st	X, r25
    b2ec:	8e 93       	st	-X, r24
    b2ee:	11 97       	sbiw	r26, 0x01	; 1
    b2f0:	80 ee       	ldi	r24, 0xE0	; 224
    b2f2:	99 e0       	ldi	r25, 0x09	; 9
    b2f4:	93 83       	std	Z+3, r25	; 0x03
    b2f6:	82 83       	std	Z+2, r24	; 0x02
    b2f8:	80 e8       	ldi	r24, 0x80	; 128
    b2fa:	98 e0       	ldi	r25, 0x08	; 8
    b2fc:	95 83       	std	Z+5, r25	; 0x05
    b2fe:	84 83       	std	Z+4, r24	; 0x04
    b300:	8c e5       	ldi	r24, 0x5C	; 92
    b302:	94 e0       	ldi	r25, 0x04	; 4
    b304:	97 83       	std	Z+7, r25	; 0x07
    b306:	86 83       	std	Z+6, r24	; 0x06
    b308:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    b30c:	ed b7       	in	r30, 0x3d	; 61
    b30e:	fe b7       	in	r31, 0x3e	; 62
    b310:	38 96       	adiw	r30, 0x08	; 8
    b312:	b9 c3       	rjmp	.+1906   	; 0xba86 <PrintIdle+0xbae>
		       break;
		  case 2:
		       CarriegeReturn();
    b314:	0e 94 3d 4c 	call	0x987a	; 0x987a <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("    ------------------------------"));
    b318:	00 d0       	rcall	.+0      	; 0xb31a <PrintIdle+0x442>
    b31a:	00 d0       	rcall	.+0      	; 0xb31c <PrintIdle+0x444>
    b31c:	80 ef       	ldi	r24, 0xF0	; 240
    b31e:	99 e0       	ldi	r25, 0x09	; 9
    b320:	ad b7       	in	r26, 0x3d	; 61
    b322:	be b7       	in	r27, 0x3e	; 62
    b324:	12 96       	adiw	r26, 0x02	; 2
    b326:	9c 93       	st	X, r25
    b328:	8e 93       	st	-X, r24
    b32a:	11 97       	sbiw	r26, 0x01	; 1
    b32c:	8d eb       	ldi	r24, 0xBD	; 189
    b32e:	99 e0       	ldi	r25, 0x09	; 9
    b330:	be c3       	rjmp	.+1916   	; 0xbaae <PrintIdle+0xbd6>
		       break;
		  case 3:
		       CarriegeReturn();
    b332:	0e 94 3d 4c 	call	0x987a	; 0x987a <CarriegeReturn>
			   //RemZeroLead(strIslandID);
			   //RemZeroLead(strFIP_ID);
		       sprintf_P(strPrint,PSTR("      Pulau/Pompa : [%s]-%s"),strIslandID,strFIP_ID);
    b336:	ed b7       	in	r30, 0x3d	; 61
    b338:	fe b7       	in	r31, 0x3e	; 62
    b33a:	38 97       	sbiw	r30, 0x08	; 8
    b33c:	0f b6       	in	r0, 0x3f	; 63
    b33e:	f8 94       	cli
    b340:	fe bf       	out	0x3e, r31	; 62
    b342:	0f be       	out	0x3f, r0	; 63
    b344:	ed bf       	out	0x3d, r30	; 61
    b346:	31 96       	adiw	r30, 0x01	; 1
    b348:	80 ef       	ldi	r24, 0xF0	; 240
    b34a:	99 e0       	ldi	r25, 0x09	; 9
    b34c:	ad b7       	in	r26, 0x3d	; 61
    b34e:	be b7       	in	r27, 0x3e	; 62
    b350:	12 96       	adiw	r26, 0x02	; 2
    b352:	9c 93       	st	X, r25
    b354:	8e 93       	st	-X, r24
    b356:	11 97       	sbiw	r26, 0x01	; 1
    b358:	81 ea       	ldi	r24, 0xA1	; 161
    b35a:	99 e0       	ldi	r25, 0x09	; 9
    b35c:	93 83       	std	Z+3, r25	; 0x03
    b35e:	82 83       	std	Z+2, r24	; 0x02
    b360:	8b e2       	ldi	r24, 0x2B	; 43
    b362:	9a e0       	ldi	r25, 0x0A	; 10
    b364:	95 83       	std	Z+5, r25	; 0x05
    b366:	84 83       	std	Z+4, r24	; 0x04
    b368:	8b ec       	ldi	r24, 0xCB	; 203
    b36a:	98 e0       	ldi	r25, 0x08	; 8
    b36c:	cb cf       	rjmp	.-106    	; 0xb304 <PrintIdle+0x42c>
		       break;
		  case 4:
		       CarriegeReturn();
    b36e:	0e 94 3d 4c 	call	0x987a	; 0x987a <CarriegeReturn>
			   sprintf_P(strPrint,PSTR("      Produk      : %s"),strDescription);
    b372:	00 d0       	rcall	.+0      	; 0xb374 <PrintIdle+0x49c>
    b374:	00 d0       	rcall	.+0      	; 0xb376 <PrintIdle+0x49e>
    b376:	00 d0       	rcall	.+0      	; 0xb378 <PrintIdle+0x4a0>
    b378:	ed b7       	in	r30, 0x3d	; 61
    b37a:	fe b7       	in	r31, 0x3e	; 62
    b37c:	31 96       	adiw	r30, 0x01	; 1
    b37e:	80 ef       	ldi	r24, 0xF0	; 240
    b380:	99 e0       	ldi	r25, 0x09	; 9
    b382:	ad b7       	in	r26, 0x3d	; 61
    b384:	be b7       	in	r27, 0x3e	; 62
    b386:	12 96       	adiw	r26, 0x02	; 2
    b388:	9c 93       	st	X, r25
    b38a:	8e 93       	st	-X, r24
    b38c:	11 97       	sbiw	r26, 0x01	; 1
    b38e:	8a e8       	ldi	r24, 0x8A	; 138
    b390:	99 e0       	ldi	r25, 0x09	; 9
    b392:	93 83       	std	Z+3, r25	; 0x03
    b394:	82 83       	std	Z+2, r24	; 0x02
    b396:	80 e4       	ldi	r24, 0x40	; 64
    b398:	99 e0       	ldi	r25, 0x09	; 9
    b39a:	6e c3       	rjmp	.+1756   	; 0xba78 <PrintIdle+0xba0>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    b39c:	e1 99       	sbic	0x1c, 1	; 28
    b39e:	fe cf       	rjmp	.-4      	; 0xb39c <PrintIdle+0x4c4>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    b3a0:	81 ec       	ldi	r24, 0xC1	; 193
    b3a2:	93 e0       	ldi	r25, 0x03	; 3
    b3a4:	9f bb       	out	0x1f, r25	; 31
    b3a6:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    b3a8:	e0 9a       	sbi	0x1c, 0	; 28
    b3aa:	8d b3       	in	r24, 0x1d	; 29
    b3ac:	00 ef       	ldi	r16, 0xF0	; 240
    b3ae:	19 e0       	ldi	r17, 0x09	; 9
		       break;
		  case 5:
		       //RemZeroLead(strPrice);
               //FormatCurrency(strPrice);
               if (eeprom_read_byte(&DefPrintMoney)==True){
    b3b0:	81 30       	cpi	r24, 0x01	; 1
    b3b2:	a9 f4       	brne	.+42     	; 0xb3de <PrintIdle+0x506>
			   	   CarriegeReturn();
    b3b4:	0e 94 3d 4c 	call	0x987a	; 0x987a <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("      Harga/L     : Rp.%s"),strPrice);
    b3b8:	00 d0       	rcall	.+0      	; 0xb3ba <PrintIdle+0x4e2>
    b3ba:	00 d0       	rcall	.+0      	; 0xb3bc <PrintIdle+0x4e4>
    b3bc:	00 d0       	rcall	.+0      	; 0xb3be <PrintIdle+0x4e6>
    b3be:	ed b7       	in	r30, 0x3d	; 61
    b3c0:	fe b7       	in	r31, 0x3e	; 62
    b3c2:	31 96       	adiw	r30, 0x01	; 1
    b3c4:	ad b7       	in	r26, 0x3d	; 61
    b3c6:	be b7       	in	r27, 0x3e	; 62
    b3c8:	12 96       	adiw	r26, 0x02	; 2
    b3ca:	1c 93       	st	X, r17
    b3cc:	0e 93       	st	-X, r16
    b3ce:	11 97       	sbiw	r26, 0x01	; 1
    b3d0:	80 e7       	ldi	r24, 0x70	; 112
    b3d2:	99 e0       	ldi	r25, 0x09	; 9
    b3d4:	93 83       	std	Z+3, r25	; 0x03
    b3d6:	82 83       	std	Z+2, r24	; 0x02
    b3d8:	80 eb       	ldi	r24, 0xB0	; 176
    b3da:	96 e0       	ldi	r25, 0x06	; 6
    b3dc:	4d c3       	rjmp	.+1690   	; 0xba78 <PrintIdle+0xba0>
			   }else sprintf_P(strPrint,PSTR(""));
    b3de:	00 d0       	rcall	.+0      	; 0xb3e0 <PrintIdle+0x508>
    b3e0:	00 d0       	rcall	.+0      	; 0xb3e2 <PrintIdle+0x50a>
    b3e2:	ad b7       	in	r26, 0x3d	; 61
    b3e4:	be b7       	in	r27, 0x3e	; 62
    b3e6:	12 96       	adiw	r26, 0x02	; 2
    b3e8:	1c 93       	st	X, r17
    b3ea:	0e 93       	st	-X, r16
    b3ec:	11 97       	sbiw	r26, 0x01	; 1
    b3ee:	8f e6       	ldi	r24, 0x6F	; 111
    b3f0:	99 e0       	ldi	r25, 0x09	; 9
    b3f2:	5d c3       	rjmp	.+1722   	; 0xbaae <PrintIdle+0xbd6>

		       break;
		  case 6:
		       //RemZeroLead(strVolume);
		       CarriegeReturn();
    b3f4:	0e 94 3d 4c 	call	0x987a	; 0x987a <CarriegeReturn>
			   sprintf_P(strPrint,PSTR("      Jml Liter   : %s L"),strVolume);
    b3f8:	00 d0       	rcall	.+0      	; 0xb3fa <PrintIdle+0x522>
    b3fa:	00 d0       	rcall	.+0      	; 0xb3fc <PrintIdle+0x524>
    b3fc:	00 d0       	rcall	.+0      	; 0xb3fe <PrintIdle+0x526>
    b3fe:	ed b7       	in	r30, 0x3d	; 61
    b400:	fe b7       	in	r31, 0x3e	; 62
    b402:	31 96       	adiw	r30, 0x01	; 1
    b404:	80 ef       	ldi	r24, 0xF0	; 240
    b406:	99 e0       	ldi	r25, 0x09	; 9
    b408:	ad b7       	in	r26, 0x3d	; 61
    b40a:	be b7       	in	r27, 0x3e	; 62
    b40c:	12 96       	adiw	r26, 0x02	; 2
    b40e:	9c 93       	st	X, r25
    b410:	8e 93       	st	-X, r24
    b412:	11 97       	sbiw	r26, 0x01	; 1
    b414:	86 e5       	ldi	r24, 0x56	; 86
    b416:	99 e0       	ldi	r25, 0x09	; 9
    b418:	93 83       	std	Z+3, r25	; 0x03
    b41a:	82 83       	std	Z+2, r24	; 0x02
    b41c:	84 e8       	ldi	r24, 0x84	; 132
    b41e:	94 e0       	ldi	r25, 0x04	; 4
    b420:	2b c3       	rjmp	.+1622   	; 0xba78 <PrintIdle+0xba0>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    b422:	e1 99       	sbic	0x1c, 1	; 28
    b424:	fe cf       	rjmp	.-4      	; 0xb422 <PrintIdle+0x54a>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    b426:	81 ec       	ldi	r24, 0xC1	; 193
    b428:	93 e0       	ldi	r25, 0x03	; 3
    b42a:	9f bb       	out	0x1f, r25	; 31
    b42c:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    b42e:	e0 9a       	sbi	0x1c, 0	; 28
    b430:	8d b3       	in	r24, 0x1d	; 29
    b432:	00 ef       	ldi	r16, 0xF0	; 240
    b434:	19 e0       	ldi	r17, 0x09	; 9
		       break;
		  case 7:
		       //RemZeroLead(strAmount);		       
			   //FormatCurrency(strAmount);
               if (eeprom_read_byte(&DefPrintMoney)==True){
    b436:	81 30       	cpi	r24, 0x01	; 1
    b438:	a9 f4       	brne	.+42     	; 0xb464 <PrintIdle+0x58c>
			   	   CarriegeReturn();
    b43a:	0e 94 3d 4c 	call	0x987a	; 0x987a <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("      Jml Rupiah  : Rp.%s"),strAmount);
    b43e:	00 d0       	rcall	.+0      	; 0xb440 <PrintIdle+0x568>
    b440:	00 d0       	rcall	.+0      	; 0xb442 <PrintIdle+0x56a>
    b442:	00 d0       	rcall	.+0      	; 0xb444 <PrintIdle+0x56c>
    b444:	ed b7       	in	r30, 0x3d	; 61
    b446:	fe b7       	in	r31, 0x3e	; 62
    b448:	31 96       	adiw	r30, 0x01	; 1
    b44a:	ad b7       	in	r26, 0x3d	; 61
    b44c:	be b7       	in	r27, 0x3e	; 62
    b44e:	12 96       	adiw	r26, 0x02	; 2
    b450:	1c 93       	st	X, r17
    b452:	0e 93       	st	-X, r16
    b454:	11 97       	sbiw	r26, 0x01	; 1
    b456:	8c e3       	ldi	r24, 0x3C	; 60
    b458:	99 e0       	ldi	r25, 0x09	; 9
    b45a:	93 83       	std	Z+3, r25	; 0x03
    b45c:	82 83       	std	Z+2, r24	; 0x02
    b45e:	87 ee       	ldi	r24, 0xE7	; 231
    b460:	9c e0       	ldi	r25, 0x0C	; 12
    b462:	0a c3       	rjmp	.+1556   	; 0xba78 <PrintIdle+0xba0>
			   }else sprintf_P(strPrint,PSTR(""));
    b464:	00 d0       	rcall	.+0      	; 0xb466 <PrintIdle+0x58e>
    b466:	00 d0       	rcall	.+0      	; 0xb468 <PrintIdle+0x590>
    b468:	ad b7       	in	r26, 0x3d	; 61
    b46a:	be b7       	in	r27, 0x3e	; 62
    b46c:	12 96       	adiw	r26, 0x02	; 2
    b46e:	1c 93       	st	X, r17
    b470:	0e 93       	st	-X, r16
    b472:	11 97       	sbiw	r26, 0x01	; 1
    b474:	8b e3       	ldi	r24, 0x3B	; 59
    b476:	99 e0       	ldi	r25, 0x09	; 9
    b478:	1a c3       	rjmp	.+1588   	; 0xbaae <PrintIdle+0xbd6>

		       break;
		  case 8:
		       if ((strlen(strLicPlate)>0)&&(SpaceOnly(strLicPlate)==False)){
    b47a:	0e e2       	ldi	r16, 0x2E	; 46
    b47c:	1a e0       	ldi	r17, 0x0A	; 10
    b47e:	80 91 2e 0a 	lds	r24, 0x0A2E
    b482:	88 23       	and	r24, r24
    b484:	09 f4       	brne	.+2      	; 0xb488 <PrintIdle+0x5b0>
    b486:	18 c2       	rjmp	.+1072   	; 0xb8b8 <PrintIdle+0x9e0>
    b488:	c8 01       	movw	r24, r16
    b48a:	0e 94 f4 23 	call	0x47e8	; 0x47e8 <SpaceOnly>
    b48e:	88 23       	and	r24, r24
    b490:	09 f0       	breq	.+2      	; 0xb494 <PrintIdle+0x5bc>
    b492:	12 c2       	rjmp	.+1060   	; 0xb8b8 <PrintIdle+0x9e0>
			       CarriegeReturn();
    b494:	0e 94 3d 4c 	call	0x987a	; 0x987a <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("      No.Polisi   : %s"),strLicPlate);
    b498:	00 d0       	rcall	.+0      	; 0xb49a <PrintIdle+0x5c2>
    b49a:	00 d0       	rcall	.+0      	; 0xb49c <PrintIdle+0x5c4>
    b49c:	00 d0       	rcall	.+0      	; 0xb49e <PrintIdle+0x5c6>
    b49e:	ed b7       	in	r30, 0x3d	; 61
    b4a0:	fe b7       	in	r31, 0x3e	; 62
    b4a2:	31 96       	adiw	r30, 0x01	; 1
    b4a4:	80 ef       	ldi	r24, 0xF0	; 240
    b4a6:	99 e0       	ldi	r25, 0x09	; 9
    b4a8:	ad b7       	in	r26, 0x3d	; 61
    b4aa:	be b7       	in	r27, 0x3e	; 62
    b4ac:	12 96       	adiw	r26, 0x02	; 2
    b4ae:	9c 93       	st	X, r25
    b4b0:	8e 93       	st	-X, r24
    b4b2:	11 97       	sbiw	r26, 0x01	; 1
    b4b4:	84 e2       	ldi	r24, 0x24	; 36
    b4b6:	99 e0       	ldi	r25, 0x09	; 9
    b4b8:	1f c0       	rjmp	.+62     	; 0xb4f8 <PrintIdle+0x620>
                   ClearMem(strLicPlate);
				   }
               else ClearMem(strPrint);
		       break;
		  case 9:
		       if ((strlen(strOdometer)>0)&&(SpaceOnly(strOdometer)==False)){
    b4ba:	02 ed       	ldi	r16, 0xD2	; 210
    b4bc:	14 e0       	ldi	r17, 0x04	; 4
    b4be:	80 91 d2 04 	lds	r24, 0x04D2
    b4c2:	88 23       	and	r24, r24
    b4c4:	09 f4       	brne	.+2      	; 0xb4c8 <PrintIdle+0x5f0>
    b4c6:	f8 c1       	rjmp	.+1008   	; 0xb8b8 <PrintIdle+0x9e0>
    b4c8:	c8 01       	movw	r24, r16
    b4ca:	0e 94 f4 23 	call	0x47e8	; 0x47e8 <SpaceOnly>
    b4ce:	88 23       	and	r24, r24
    b4d0:	09 f0       	breq	.+2      	; 0xb4d4 <PrintIdle+0x5fc>
    b4d2:	f2 c1       	rjmp	.+996    	; 0xb8b8 <PrintIdle+0x9e0>
			       CarriegeReturn();
    b4d4:	0e 94 3d 4c 	call	0x987a	; 0x987a <CarriegeReturn>
		           sprintf_P(strPrint,PSTR("      Odometer    : %s"),strOdometer);
    b4d8:	00 d0       	rcall	.+0      	; 0xb4da <PrintIdle+0x602>
    b4da:	00 d0       	rcall	.+0      	; 0xb4dc <PrintIdle+0x604>
    b4dc:	00 d0       	rcall	.+0      	; 0xb4de <PrintIdle+0x606>
    b4de:	ed b7       	in	r30, 0x3d	; 61
    b4e0:	fe b7       	in	r31, 0x3e	; 62
    b4e2:	31 96       	adiw	r30, 0x01	; 1
    b4e4:	80 ef       	ldi	r24, 0xF0	; 240
    b4e6:	99 e0       	ldi	r25, 0x09	; 9
    b4e8:	ad b7       	in	r26, 0x3d	; 61
    b4ea:	be b7       	in	r27, 0x3e	; 62
    b4ec:	12 96       	adiw	r26, 0x02	; 2
    b4ee:	9c 93       	st	X, r25
    b4f0:	8e 93       	st	-X, r24
    b4f2:	11 97       	sbiw	r26, 0x01	; 1
    b4f4:	8d e0       	ldi	r24, 0x0D	; 13
    b4f6:	99 e0       	ldi	r25, 0x09	; 9
    b4f8:	93 83       	std	Z+3, r25	; 0x03
    b4fa:	82 83       	std	Z+2, r24	; 0x02
    b4fc:	15 83       	std	Z+5, r17	; 0x05
    b4fe:	04 83       	std	Z+4, r16	; 0x04
    b500:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
				   ClearMem(strOdometer);
    b504:	ed b7       	in	r30, 0x3d	; 61
    b506:	fe b7       	in	r31, 0x3e	; 62
    b508:	36 96       	adiw	r30, 0x06	; 6
    b50a:	0f b6       	in	r0, 0x3f	; 63
    b50c:	f8 94       	cli
    b50e:	fe bf       	out	0x3e, r31	; 62
    b510:	0f be       	out	0x3f, r0	; 63
    b512:	ed bf       	out	0x3d, r30	; 61
    b514:	c8 01       	movw	r24, r16
    b516:	0e 94 7f ad 	call	0x15afe	; 0x15afe <ClearMem>
    b51a:	d3 c2       	rjmp	.+1446   	; 0xbac2 <PrintIdle+0xbea>
			   }else ClearMem(strPrint);
		       break;
		  case 10:
		       CarriegeReturn();
    b51c:	0e 94 3d 4c 	call	0x987a	; 0x987a <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("    ------------------------------"));
    b520:	00 d0       	rcall	.+0      	; 0xb522 <PrintIdle+0x64a>
    b522:	00 d0       	rcall	.+0      	; 0xb524 <PrintIdle+0x64c>
    b524:	80 ef       	ldi	r24, 0xF0	; 240
    b526:	99 e0       	ldi	r25, 0x09	; 9
    b528:	ad b7       	in	r26, 0x3d	; 61
    b52a:	be b7       	in	r27, 0x3e	; 62
    b52c:	12 96       	adiw	r26, 0x02	; 2
    b52e:	9c 93       	st	X, r25
    b530:	8e 93       	st	-X, r24
    b532:	11 97       	sbiw	r26, 0x01	; 1
    b534:	8a ee       	ldi	r24, 0xEA	; 234
    b536:	98 e0       	ldi	r25, 0x08	; 8
    b538:	ba c2       	rjmp	.+1396   	; 0xbaae <PrintIdle+0xbd6>
		       break;
          //ChangeMOPPrint
		  case 11:
			   if ((MOPType==MOP_LOCAL_ACCOUNT)||(MOPType==MOP_DEBIT_CARD)||(MOPType==MOP_LOYALTY_LOCAL_ACCOUNT)){
    b53a:	80 91 ba 01 	lds	r24, 0x01BA
    b53e:	81 30       	cpi	r24, 0x01	; 1
    b540:	21 f0       	breq	.+8      	; 0xb54a <PrintIdle+0x672>
    b542:	83 30       	cpi	r24, 0x03	; 3
    b544:	11 f0       	breq	.+4      	; 0xb54a <PrintIdle+0x672>
    b546:	86 30       	cpi	r24, 0x06	; 6
    b548:	b9 f4       	brne	.+46     	; 0xb578 <PrintIdle+0x6a0>
			       //RemSpaceLag(strCardID);
				   CarriegeReturn();
    b54a:	0e 94 3d 4c 	call	0x987a	; 0x987a <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("    Kartu ID : %s"),strCardID);
    b54e:	00 d0       	rcall	.+0      	; 0xb550 <PrintIdle+0x678>
    b550:	00 d0       	rcall	.+0      	; 0xb552 <PrintIdle+0x67a>
    b552:	00 d0       	rcall	.+0      	; 0xb554 <PrintIdle+0x67c>
    b554:	ed b7       	in	r30, 0x3d	; 61
    b556:	fe b7       	in	r31, 0x3e	; 62
    b558:	31 96       	adiw	r30, 0x01	; 1
    b55a:	80 ef       	ldi	r24, 0xF0	; 240
    b55c:	99 e0       	ldi	r25, 0x09	; 9
    b55e:	ad b7       	in	r26, 0x3d	; 61
    b560:	be b7       	in	r27, 0x3e	; 62
    b562:	12 96       	adiw	r26, 0x02	; 2
    b564:	9c 93       	st	X, r25
    b566:	8e 93       	st	-X, r24
    b568:	11 97       	sbiw	r26, 0x01	; 1
    b56a:	88 ed       	ldi	r24, 0xD8	; 216
    b56c:	98 e0       	ldi	r25, 0x08	; 8
    b56e:	93 83       	std	Z+3, r25	; 0x03
    b570:	82 83       	std	Z+2, r24	; 0x02
    b572:	8d eb       	ldi	r24, 0xBD	; 189
    b574:	9c e0       	ldi	r25, 0x0C	; 12
    b576:	18 c0       	rjmp	.+48     	; 0xb5a8 <PrintIdle+0x6d0>
				   IsSignedField=True;
				   }
	           else
			   if (MOPType==MOP_VOUCHER){
    b578:	87 30       	cpi	r24, 0x07	; 7
    b57a:	f1 f4       	brne	.+60     	; 0xb5b8 <PrintIdle+0x6e0>
			       //RemSpaceLag(strCardID);
				   CarriegeReturn();
    b57c:	0e 94 3d 4c 	call	0x987a	; 0x987a <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("    Voucher No: %s"),strVoucherNum);
    b580:	00 d0       	rcall	.+0      	; 0xb582 <PrintIdle+0x6aa>
    b582:	00 d0       	rcall	.+0      	; 0xb584 <PrintIdle+0x6ac>
    b584:	00 d0       	rcall	.+0      	; 0xb586 <PrintIdle+0x6ae>
    b586:	ed b7       	in	r30, 0x3d	; 61
    b588:	fe b7       	in	r31, 0x3e	; 62
    b58a:	31 96       	adiw	r30, 0x01	; 1
    b58c:	80 ef       	ldi	r24, 0xF0	; 240
    b58e:	99 e0       	ldi	r25, 0x09	; 9
    b590:	ad b7       	in	r26, 0x3d	; 61
    b592:	be b7       	in	r27, 0x3e	; 62
    b594:	12 96       	adiw	r26, 0x02	; 2
    b596:	9c 93       	st	X, r25
    b598:	8e 93       	st	-X, r24
    b59a:	11 97       	sbiw	r26, 0x01	; 1
    b59c:	85 ec       	ldi	r24, 0xC5	; 197
    b59e:	98 e0       	ldi	r25, 0x08	; 8
    b5a0:	93 83       	std	Z+3, r25	; 0x03
    b5a2:	82 83       	std	Z+2, r24	; 0x02
    b5a4:	83 e7       	ldi	r24, 0x73	; 115
    b5a6:	9d e0       	ldi	r25, 0x0D	; 13
    b5a8:	95 83       	std	Z+5, r25	; 0x05
    b5aa:	84 83       	std	Z+4, r24	; 0x04
    b5ac:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
				   IsSignedField=True;
    b5b0:	81 e0       	ldi	r24, 0x01	; 1
    b5b2:	80 93 4f 02 	sts	0x024F, r24
    b5b6:	64 c2       	rjmp	.+1224   	; 0xba80 <PrintIdle+0xba8>
    b5b8:	00 ef       	ldi	r16, 0xF0	; 240
    b5ba:	19 e0       	ldi	r17, 0x09	; 9
				   }
			   else
			   if (MOPType==MOP_PUMP_TEST) {
    b5bc:	88 30       	cpi	r24, 0x08	; 8
    b5be:	09 f0       	breq	.+2      	; 0xb5c2 <PrintIdle+0x6ea>
    b5c0:	a9 cf       	rjmp	.-174    	; 0xb514 <PrintIdle+0x63c>
			       CarriegeReturn();
    b5c2:	0e 94 3d 4c 	call	0x987a	; 0x987a <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("          *** PUMP TEST ***       "));
    b5c6:	00 d0       	rcall	.+0      	; 0xb5c8 <PrintIdle+0x6f0>
    b5c8:	00 d0       	rcall	.+0      	; 0xb5ca <PrintIdle+0x6f2>
    b5ca:	ad b7       	in	r26, 0x3d	; 61
    b5cc:	be b7       	in	r27, 0x3e	; 62
    b5ce:	12 96       	adiw	r26, 0x02	; 2
    b5d0:	1c 93       	st	X, r17
    b5d2:	0e 93       	st	-X, r16
    b5d4:	11 97       	sbiw	r26, 0x01	; 1
    b5d6:	82 ea       	ldi	r24, 0xA2	; 162
    b5d8:	98 e0       	ldi	r25, 0x08	; 8
    b5da:	14 96       	adiw	r26, 0x04	; 4
    b5dc:	9c 93       	st	X, r25
    b5de:	8e 93       	st	-X, r24
    b5e0:	13 97       	sbiw	r26, 0x03	; 3
    b5e2:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
				   IsSignedField=False;
    b5e6:	10 92 4f 02 	sts	0x024F, r1
    b5ea:	67 c2       	rjmp	.+1230   	; 0xbaba <PrintIdle+0xbe2>
				   }
               else ClearMem(strPrint);
		       break;
          case 12:
			   if (MOPType==MOP_LOCAL_ACCOUNT) {
    b5ec:	80 91 ba 01 	lds	r24, 0x01BA
    b5f0:	81 30       	cpi	r24, 0x01	; 1
    b5f2:	99 f4       	brne	.+38     	; 0xb61a <PrintIdle+0x742>
			       //RemSpaceLag(strCardHolder);
				   CarriegeReturn();
    b5f4:	0e 94 3d 4c 	call	0x987a	; 0x987a <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("    Nama     : %s"),strCardHolder);
    b5f8:	00 d0       	rcall	.+0      	; 0xb5fa <PrintIdle+0x722>
    b5fa:	00 d0       	rcall	.+0      	; 0xb5fc <PrintIdle+0x724>
    b5fc:	00 d0       	rcall	.+0      	; 0xb5fe <PrintIdle+0x726>
    b5fe:	ed b7       	in	r30, 0x3d	; 61
    b600:	fe b7       	in	r31, 0x3e	; 62
    b602:	31 96       	adiw	r30, 0x01	; 1
    b604:	80 ef       	ldi	r24, 0xF0	; 240
    b606:	99 e0       	ldi	r25, 0x09	; 9
    b608:	ad b7       	in	r26, 0x3d	; 61
    b60a:	be b7       	in	r27, 0x3e	; 62
    b60c:	12 96       	adiw	r26, 0x02	; 2
    b60e:	9c 93       	st	X, r25
    b610:	8e 93       	st	-X, r24
    b612:	11 97       	sbiw	r26, 0x01	; 1
    b614:	80 e9       	ldi	r24, 0x90	; 144
    b616:	98 e0       	ldi	r25, 0x08	; 8
    b618:	3a c0       	rjmp	.+116    	; 0xb68e <PrintIdle+0x7b6>
				   }
               else 
               if (MOPType==MOP_DEBIT_CARD) {//EDCApprovalCode
    b61a:	83 30       	cpi	r24, 0x03	; 3
    b61c:	e9 f5       	brne	.+122    	; 0xb698 <PrintIdle+0x7c0>
			       if (IsPrintApprovalCode==True){
    b61e:	80 91 9d 01 	lds	r24, 0x019D
    b622:	81 30       	cpi	r24, 0x01	; 1
    b624:	11 f5       	brne	.+68     	; 0xb66a <PrintIdle+0x792>
				       IsPrintApprovalCode=False;
    b626:	10 92 9d 01 	sts	0x019D, r1
					   FillChar(strCardHolder,0,sizeof(strCardHolder));
					   sprintf_P(strCardHolder,PSTR("%s  "),strApprovalCode);
    b62a:	00 d0       	rcall	.+0      	; 0xb62c <PrintIdle+0x754>
    b62c:	00 d0       	rcall	.+0      	; 0xb62e <PrintIdle+0x756>
    b62e:	00 d0       	rcall	.+0      	; 0xb630 <PrintIdle+0x758>
    b630:	ed b7       	in	r30, 0x3d	; 61
    b632:	fe b7       	in	r31, 0x3e	; 62
    b634:	31 96       	adiw	r30, 0x01	; 1
    b636:	83 e3       	ldi	r24, 0x33	; 51
    b638:	94 e0       	ldi	r25, 0x04	; 4
    b63a:	ad b7       	in	r26, 0x3d	; 61
    b63c:	be b7       	in	r27, 0x3e	; 62
    b63e:	12 96       	adiw	r26, 0x02	; 2
    b640:	9c 93       	st	X, r25
    b642:	8e 93       	st	-X, r24
    b644:	11 97       	sbiw	r26, 0x01	; 1
    b646:	8b e8       	ldi	r24, 0x8B	; 139
    b648:	98 e0       	ldi	r25, 0x08	; 8
    b64a:	93 83       	std	Z+3, r25	; 0x03
    b64c:	82 83       	std	Z+2, r24	; 0x02
    b64e:	83 e1       	ldi	r24, 0x13	; 19
    b650:	99 e0       	ldi	r25, 0x09	; 9
    b652:	95 83       	std	Z+5, r25	; 0x05
    b654:	84 83       	std	Z+4, r24	; 0x04
    b656:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    b65a:	ed b7       	in	r30, 0x3d	; 61
    b65c:	fe b7       	in	r31, 0x3e	; 62
    b65e:	36 96       	adiw	r30, 0x06	; 6
    b660:	0f b6       	in	r0, 0x3f	; 63
    b662:	f8 94       	cli
    b664:	fe bf       	out	0x3e, r31	; 62
    b666:	0f be       	out	0x3f, r0	; 63
    b668:	ed bf       	out	0x3d, r30	; 61
				   }
			       //RemSpaceLag(strCardHolder);
				   CarriegeReturn();
    b66a:	0e 94 3d 4c 	call	0x987a	; 0x987a <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("    Appr Code: %s"),strCardHolder);
    b66e:	00 d0       	rcall	.+0      	; 0xb670 <PrintIdle+0x798>
    b670:	00 d0       	rcall	.+0      	; 0xb672 <PrintIdle+0x79a>
    b672:	00 d0       	rcall	.+0      	; 0xb674 <PrintIdle+0x79c>
    b674:	ed b7       	in	r30, 0x3d	; 61
    b676:	fe b7       	in	r31, 0x3e	; 62
    b678:	31 96       	adiw	r30, 0x01	; 1
    b67a:	80 ef       	ldi	r24, 0xF0	; 240
    b67c:	99 e0       	ldi	r25, 0x09	; 9
    b67e:	ad b7       	in	r26, 0x3d	; 61
    b680:	be b7       	in	r27, 0x3e	; 62
    b682:	12 96       	adiw	r26, 0x02	; 2
    b684:	9c 93       	st	X, r25
    b686:	8e 93       	st	-X, r24
    b688:	11 97       	sbiw	r26, 0x01	; 1
    b68a:	89 e7       	ldi	r24, 0x79	; 121
    b68c:	98 e0       	ldi	r25, 0x08	; 8
    b68e:	93 83       	std	Z+3, r25	; 0x03
    b690:	82 83       	std	Z+2, r24	; 0x02
    b692:	83 e3       	ldi	r24, 0x33	; 51
    b694:	94 e0       	ldi	r25, 0x04	; 4
    b696:	f0 c1       	rjmp	.+992    	; 0xba78 <PrintIdle+0xba0>
				   }
               else
			   if (MOPType==MOP_VOUCHER){
    b698:	87 30       	cpi	r24, 0x07	; 7
    b69a:	79 f4       	brne	.+30     	; 0xb6ba <PrintIdle+0x7e2>
			       CarriegeReturn();
    b69c:	0e 94 3d 4c 	call	0x987a	; 0x987a <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("  "));
    b6a0:	00 d0       	rcall	.+0      	; 0xb6a2 <PrintIdle+0x7ca>
    b6a2:	00 d0       	rcall	.+0      	; 0xb6a4 <PrintIdle+0x7cc>
    b6a4:	80 ef       	ldi	r24, 0xF0	; 240
    b6a6:	99 e0       	ldi	r25, 0x09	; 9
    b6a8:	ad b7       	in	r26, 0x3d	; 61
    b6aa:	be b7       	in	r27, 0x3e	; 62
    b6ac:	12 96       	adiw	r26, 0x02	; 2
    b6ae:	9c 93       	st	X, r25
    b6b0:	8e 93       	st	-X, r24
    b6b2:	11 97       	sbiw	r26, 0x01	; 1
    b6b4:	86 e7       	ldi	r24, 0x76	; 118
    b6b6:	98 e0       	ldi	r25, 0x08	; 8
    b6b8:	fa c1       	rjmp	.+1012   	; 0xbaae <PrintIdle+0xbd6>
    b6ba:	00 ef       	ldi	r16, 0xF0	; 240
    b6bc:	19 e0       	ldi	r17, 0x09	; 9
				   }
			   else
			   if (MOPType==MOP_PUMP_TEST) {
    b6be:	88 30       	cpi	r24, 0x08	; 8
    b6c0:	09 f0       	breq	.+2      	; 0xb6c4 <PrintIdle+0x7ec>
    b6c2:	28 cf       	rjmp	.-432    	; 0xb514 <PrintIdle+0x63c>
			       CarriegeReturn();
    b6c4:	0e 94 3d 4c 	call	0x987a	; 0x987a <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("                 "));
    b6c8:	00 d0       	rcall	.+0      	; 0xb6ca <PrintIdle+0x7f2>
    b6ca:	00 d0       	rcall	.+0      	; 0xb6cc <PrintIdle+0x7f4>
    b6cc:	ed b7       	in	r30, 0x3d	; 61
    b6ce:	fe b7       	in	r31, 0x3e	; 62
    b6d0:	12 83       	std	Z+2, r17	; 0x02
    b6d2:	01 83       	std	Z+1, r16	; 0x01
    b6d4:	84 e6       	ldi	r24, 0x64	; 100
    b6d6:	98 e0       	ldi	r25, 0x08	; 8
    b6d8:	25 c0       	rjmp	.+74     	; 0xb724 <PrintIdle+0x84c>
				   }
               else ClearMem(strPrint);
		       break;
          case 13:
		       if (IsSignedField==True){
    b6da:	80 91 4f 02 	lds	r24, 0x024F
    b6de:	00 ef       	ldi	r16, 0xF0	; 240
    b6e0:	19 e0       	ldi	r17, 0x09	; 9
    b6e2:	81 30       	cpi	r24, 0x01	; 1
    b6e4:	09 f0       	breq	.+2      	; 0xb6e8 <PrintIdle+0x810>
    b6e6:	16 cf       	rjmp	.-468    	; 0xb514 <PrintIdle+0x63c>
			       CarriegeReturn();
    b6e8:	0e 94 3d 4c 	call	0x987a	; 0x987a <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("                      "));
    b6ec:	00 d0       	rcall	.+0      	; 0xb6ee <PrintIdle+0x816>
    b6ee:	00 d0       	rcall	.+0      	; 0xb6f0 <PrintIdle+0x818>
    b6f0:	ad b7       	in	r26, 0x3d	; 61
    b6f2:	be b7       	in	r27, 0x3e	; 62
    b6f4:	12 96       	adiw	r26, 0x02	; 2
    b6f6:	1c 93       	st	X, r17
    b6f8:	0e 93       	st	-X, r16
    b6fa:	11 97       	sbiw	r26, 0x01	; 1
    b6fc:	8d e4       	ldi	r24, 0x4D	; 77
    b6fe:	98 e0       	ldi	r25, 0x08	; 8
    b700:	d6 c1       	rjmp	.+940    	; 0xbaae <PrintIdle+0xbd6>
               }else ClearMem(strPrint);
		       break;
          case 14:
		       if (IsSignedField==True){
    b702:	80 91 4f 02 	lds	r24, 0x024F
    b706:	00 ef       	ldi	r16, 0xF0	; 240
    b708:	19 e0       	ldi	r17, 0x09	; 9
    b70a:	81 30       	cpi	r24, 0x01	; 1
    b70c:	09 f0       	breq	.+2      	; 0xb710 <PrintIdle+0x838>
    b70e:	02 cf       	rjmp	.-508    	; 0xb514 <PrintIdle+0x63c>
			       CarriegeReturn();
    b710:	0e 94 3d 4c 	call	0x987a	; 0x987a <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("                      "));
    b714:	00 d0       	rcall	.+0      	; 0xb716 <PrintIdle+0x83e>
    b716:	00 d0       	rcall	.+0      	; 0xb718 <PrintIdle+0x840>
    b718:	ed b7       	in	r30, 0x3d	; 61
    b71a:	fe b7       	in	r31, 0x3e	; 62
    b71c:	12 83       	std	Z+2, r17	; 0x02
    b71e:	01 83       	std	Z+1, r16	; 0x01
    b720:	86 e3       	ldi	r24, 0x36	; 54
    b722:	98 e0       	ldi	r25, 0x08	; 8
    b724:	94 83       	std	Z+4, r25	; 0x04
    b726:	83 83       	std	Z+3, r24	; 0x03
    b728:	c6 c1       	rjmp	.+908    	; 0xbab6 <PrintIdle+0xbde>
			       //sprintf_P(strPrint,PSTR("                      "));
				   ClearMem(strPrint);
               }else ClearMem(strPrint);
		       break;
          case 17:
		       if (IsSignedField==True){
    b72a:	80 91 4f 02 	lds	r24, 0x024F
    b72e:	00 ef       	ldi	r16, 0xF0	; 240
    b730:	19 e0       	ldi	r17, 0x09	; 9
    b732:	81 30       	cpi	r24, 0x01	; 1
    b734:	09 f0       	breq	.+2      	; 0xb738 <PrintIdle+0x860>
    b736:	ee ce       	rjmp	.-548    	; 0xb514 <PrintIdle+0x63c>
			       CarriegeReturn();
    b738:	0e 94 3d 4c 	call	0x987a	; 0x987a <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("    Tanda Tangan  (______________)"));
    b73c:	00 d0       	rcall	.+0      	; 0xb73e <PrintIdle+0x866>
    b73e:	00 d0       	rcall	.+0      	; 0xb740 <PrintIdle+0x868>
    b740:	ad b7       	in	r26, 0x3d	; 61
    b742:	be b7       	in	r27, 0x3e	; 62
    b744:	12 96       	adiw	r26, 0x02	; 2
    b746:	1c 93       	st	X, r17
    b748:	0e 93       	st	-X, r16
    b74a:	11 97       	sbiw	r26, 0x01	; 1
    b74c:	83 e1       	ldi	r24, 0x13	; 19
    b74e:	98 e0       	ldi	r25, 0x08	; 8
    b750:	ae c1       	rjmp	.+860    	; 0xbaae <PrintIdle+0xbd6>
               }else ClearMem(strPrint);
		       break;
          case 18:
		       if (IsSignedField==True){
    b752:	80 91 4f 02 	lds	r24, 0x024F
    b756:	81 30       	cpi	r24, 0x01	; 1
    b758:	09 f0       	breq	.+2      	; 0xb75c <PrintIdle+0x884>
    b75a:	ae c0       	rjmp	.+348    	; 0xb8b8 <PrintIdle+0x9e0>
			       IsSignedField=False;
    b75c:	10 92 4f 02 	sts	0x024F, r1
    b760:	ab c0       	rjmp	.+342    	; 0xb8b8 <PrintIdle+0x9e0>
			       //sprintf_P(strPrint,PSTR("                      "));
				   ClearMem(strPrint);
               }else ClearMem(strPrint);
		       break;
          case 19://PrintMOP Name
		       if (MOPType!=MOP_CASH){
    b762:	80 91 ba 01 	lds	r24, 0x01BA
    b766:	00 ef       	ldi	r16, 0xF0	; 240
    b768:	19 e0       	ldi	r17, 0x09	; 9
    b76a:	88 23       	and	r24, r24
    b76c:	09 f4       	brne	.+2      	; 0xb770 <PrintIdle+0x898>
    b76e:	d2 ce       	rjmp	.-604    	; 0xb514 <PrintIdle+0x63c>
			       CarriegeReturn();
    b770:	0e 94 3d 4c 	call	0x987a	; 0x987a <CarriegeReturn>
			       //RemSpaceLag(strMOPName);
			       sprintf_P(strPrint,PSTR("    .%s"),strMOPName);
    b774:	00 d0       	rcall	.+0      	; 0xb776 <PrintIdle+0x89e>
    b776:	00 d0       	rcall	.+0      	; 0xb778 <PrintIdle+0x8a0>
    b778:	00 d0       	rcall	.+0      	; 0xb77a <PrintIdle+0x8a2>
    b77a:	ed b7       	in	r30, 0x3d	; 61
    b77c:	fe b7       	in	r31, 0x3e	; 62
    b77e:	31 96       	adiw	r30, 0x01	; 1
    b780:	ad b7       	in	r26, 0x3d	; 61
    b782:	be b7       	in	r27, 0x3e	; 62
    b784:	12 96       	adiw	r26, 0x02	; 2
    b786:	1c 93       	st	X, r17
    b788:	0e 93       	st	-X, r16
    b78a:	11 97       	sbiw	r26, 0x01	; 1
    b78c:	8b e0       	ldi	r24, 0x0B	; 11
    b78e:	98 e0       	ldi	r25, 0x08	; 8
    b790:	93 83       	std	Z+3, r25	; 0x03
    b792:	82 83       	std	Z+2, r24	; 0x02
    b794:	8f e8       	ldi	r24, 0x8F	; 143
    b796:	96 e0       	ldi	r25, 0x06	; 6
    b798:	6f c1       	rjmp	.+734    	; 0xba78 <PrintIdle+0xba0>
			   }else ClearMem(strPrint);
		       break;
		  case 20:
		       if (MOPType!=MOP_CASH){
    b79a:	80 91 ba 01 	lds	r24, 0x01BA
    b79e:	00 ef       	ldi	r16, 0xF0	; 240
    b7a0:	19 e0       	ldi	r17, 0x09	; 9
    b7a2:	88 23       	and	r24, r24
    b7a4:	09 f4       	brne	.+2      	; 0xb7a8 <PrintIdle+0x8d0>
    b7a6:	b6 ce       	rjmp	.-660    	; 0xb514 <PrintIdle+0x63c>
			       CarriegeReturn();
    b7a8:	0e 94 3d 4c 	call	0x987a	; 0x987a <CarriegeReturn>
		           sprintf_P(strPrint,PSTR("    ------------------------------"));
    b7ac:	00 d0       	rcall	.+0      	; 0xb7ae <PrintIdle+0x8d6>
    b7ae:	00 d0       	rcall	.+0      	; 0xb7b0 <PrintIdle+0x8d8>
    b7b0:	ad b7       	in	r26, 0x3d	; 61
    b7b2:	be b7       	in	r27, 0x3e	; 62
    b7b4:	12 96       	adiw	r26, 0x02	; 2
    b7b6:	1c 93       	st	X, r17
    b7b8:	0e 93       	st	-X, r16
    b7ba:	11 97       	sbiw	r26, 0x01	; 1
    b7bc:	88 ee       	ldi	r24, 0xE8	; 232
    b7be:	97 e0       	ldi	r25, 0x07	; 7
    b7c0:	76 c1       	rjmp	.+748    	; 0xbaae <PrintIdle+0xbd6>
			   }else ClearMem(strPrint);
		       break;          
          //Loyalty
		  case 21:
		       CarriegeReturn();
    b7c2:	0e 94 3d 4c 	call	0x987a	; 0x987a <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("         LOYALTY INFORMATION      "));
    b7c6:	00 d0       	rcall	.+0      	; 0xb7c8 <PrintIdle+0x8f0>
    b7c8:	00 d0       	rcall	.+0      	; 0xb7ca <PrintIdle+0x8f2>
    b7ca:	80 ef       	ldi	r24, 0xF0	; 240
    b7cc:	99 e0       	ldi	r25, 0x09	; 9
    b7ce:	ed b7       	in	r30, 0x3d	; 61
    b7d0:	fe b7       	in	r31, 0x3e	; 62
    b7d2:	92 83       	std	Z+2, r25	; 0x02
    b7d4:	81 83       	std	Z+1, r24	; 0x01
    b7d6:	85 ec       	ldi	r24, 0xC5	; 197
    b7d8:	97 e0       	ldi	r25, 0x07	; 7
    b7da:	a4 cf       	rjmp	.-184    	; 0xb724 <PrintIdle+0x84c>
		       break; 			            
		  case 22:
		       CarriegeReturn();
    b7dc:	0e 94 3d 4c 	call	0x987a	; 0x987a <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("     Card ID      : %s"),strLoyCardID);
    b7e0:	00 d0       	rcall	.+0      	; 0xb7e2 <PrintIdle+0x90a>
    b7e2:	00 d0       	rcall	.+0      	; 0xb7e4 <PrintIdle+0x90c>
    b7e4:	00 d0       	rcall	.+0      	; 0xb7e6 <PrintIdle+0x90e>
    b7e6:	ed b7       	in	r30, 0x3d	; 61
    b7e8:	fe b7       	in	r31, 0x3e	; 62
    b7ea:	31 96       	adiw	r30, 0x01	; 1
    b7ec:	80 ef       	ldi	r24, 0xF0	; 240
    b7ee:	99 e0       	ldi	r25, 0x09	; 9
    b7f0:	ad b7       	in	r26, 0x3d	; 61
    b7f2:	be b7       	in	r27, 0x3e	; 62
    b7f4:	12 96       	adiw	r26, 0x02	; 2
    b7f6:	9c 93       	st	X, r25
    b7f8:	8e 93       	st	-X, r24
    b7fa:	11 97       	sbiw	r26, 0x01	; 1
    b7fc:	8e ea       	ldi	r24, 0xAE	; 174
    b7fe:	97 e0       	ldi	r25, 0x07	; 7
    b800:	93 83       	std	Z+3, r25	; 0x03
    b802:	82 83       	std	Z+2, r24	; 0x02
    b804:	86 ef       	ldi	r24, 0xF6	; 246
    b806:	93 e0       	ldi	r25, 0x03	; 3
    b808:	37 c1       	rjmp	.+622    	; 0xba78 <PrintIdle+0xba0>
		       break;
		  case 23:
		       CarriegeReturn();
    b80a:	0e 94 3d 4c 	call	0x987a	; 0x987a <CarriegeReturn>
			   //RemSpaceLag(strLoyCardHolder);
		       sprintf_P(strPrint,PSTR("     Card Holder  : %s "),strLoyCardHolder);
    b80e:	00 d0       	rcall	.+0      	; 0xb810 <PrintIdle+0x938>
    b810:	00 d0       	rcall	.+0      	; 0xb812 <PrintIdle+0x93a>
    b812:	00 d0       	rcall	.+0      	; 0xb814 <PrintIdle+0x93c>
    b814:	ed b7       	in	r30, 0x3d	; 61
    b816:	fe b7       	in	r31, 0x3e	; 62
    b818:	31 96       	adiw	r30, 0x01	; 1
    b81a:	80 ef       	ldi	r24, 0xF0	; 240
    b81c:	99 e0       	ldi	r25, 0x09	; 9
    b81e:	ad b7       	in	r26, 0x3d	; 61
    b820:	be b7       	in	r27, 0x3e	; 62
    b822:	12 96       	adiw	r26, 0x02	; 2
    b824:	9c 93       	st	X, r25
    b826:	8e 93       	st	-X, r24
    b828:	11 97       	sbiw	r26, 0x01	; 1
    b82a:	86 e9       	ldi	r24, 0x96	; 150
    b82c:	97 e0       	ldi	r25, 0x07	; 7
    b82e:	93 83       	std	Z+3, r25	; 0x03
    b830:	82 83       	std	Z+2, r24	; 0x02
    b832:	83 ed       	ldi	r24, 0xD3	; 211
    b834:	93 e0       	ldi	r25, 0x03	; 3
    b836:	20 c1       	rjmp	.+576    	; 0xba78 <PrintIdle+0xba0>
		       break;
		  case 24:
		       if ((strlen(strCorporateID)>0)&&(SpaceOnly(strCorporateID)==False)){
    b838:	01 e4       	ldi	r16, 0x41	; 65
    b83a:	1d e0       	ldi	r17, 0x0D	; 13
    b83c:	80 91 41 0d 	lds	r24, 0x0D41
    b840:	88 23       	and	r24, r24
    b842:	d1 f1       	breq	.+116    	; 0xb8b8 <PrintIdle+0x9e0>
    b844:	c8 01       	movw	r24, r16
    b846:	0e 94 f4 23 	call	0x47e8	; 0x47e8 <SpaceOnly>
    b84a:	88 23       	and	r24, r24
    b84c:	a9 f5       	brne	.+106    	; 0xb8b8 <PrintIdle+0x9e0>
		           CarriegeReturn();
    b84e:	0e 94 3d 4c 	call	0x987a	; 0x987a <CarriegeReturn>
				   //RemSpaceLag(strCorporateID);
		           sprintf_P(strPrint,PSTR("     Corp ID      : %s"),strCorporateID);
    b852:	00 d0       	rcall	.+0      	; 0xb854 <PrintIdle+0x97c>
    b854:	00 d0       	rcall	.+0      	; 0xb856 <PrintIdle+0x97e>
    b856:	00 d0       	rcall	.+0      	; 0xb858 <PrintIdle+0x980>
    b858:	ed b7       	in	r30, 0x3d	; 61
    b85a:	fe b7       	in	r31, 0x3e	; 62
    b85c:	31 96       	adiw	r30, 0x01	; 1
    b85e:	80 ef       	ldi	r24, 0xF0	; 240
    b860:	99 e0       	ldi	r25, 0x09	; 9
    b862:	ad b7       	in	r26, 0x3d	; 61
    b864:	be b7       	in	r27, 0x3e	; 62
    b866:	12 96       	adiw	r26, 0x02	; 2
    b868:	9c 93       	st	X, r25
    b86a:	8e 93       	st	-X, r24
    b86c:	11 97       	sbiw	r26, 0x01	; 1
    b86e:	8f e7       	ldi	r24, 0x7F	; 127
    b870:	97 e0       	ldi	r25, 0x07	; 7
    b872:	1d c0       	rjmp	.+58     	; 0xb8ae <PrintIdle+0x9d6>
			   }else ClearMem(strPrint);
		       break;
		  case 25:
		       if ((strlen(strCorporateName)>0)&&(SpaceOnly(strCorporateName)==False)){
    b874:	0c ed       	ldi	r16, 0xDC	; 220
    b876:	14 e0       	ldi	r17, 0x04	; 4
    b878:	80 91 dc 04 	lds	r24, 0x04DC
    b87c:	88 23       	and	r24, r24
    b87e:	e1 f0       	breq	.+56     	; 0xb8b8 <PrintIdle+0x9e0>
    b880:	c8 01       	movw	r24, r16
    b882:	0e 94 f4 23 	call	0x47e8	; 0x47e8 <SpaceOnly>
    b886:	88 23       	and	r24, r24
    b888:	b9 f4       	brne	.+46     	; 0xb8b8 <PrintIdle+0x9e0>
		           CarriegeReturn();
    b88a:	0e 94 3d 4c 	call	0x987a	; 0x987a <CarriegeReturn>
				   //RemSpaceLag(strCorporateName);
		           sprintf_P(strPrint,PSTR("     Corp Name    : %s"),strCorporateName);
    b88e:	00 d0       	rcall	.+0      	; 0xb890 <PrintIdle+0x9b8>
    b890:	00 d0       	rcall	.+0      	; 0xb892 <PrintIdle+0x9ba>
    b892:	00 d0       	rcall	.+0      	; 0xb894 <PrintIdle+0x9bc>
    b894:	ed b7       	in	r30, 0x3d	; 61
    b896:	fe b7       	in	r31, 0x3e	; 62
    b898:	31 96       	adiw	r30, 0x01	; 1
    b89a:	80 ef       	ldi	r24, 0xF0	; 240
    b89c:	99 e0       	ldi	r25, 0x09	; 9
    b89e:	ad b7       	in	r26, 0x3d	; 61
    b8a0:	be b7       	in	r27, 0x3e	; 62
    b8a2:	12 96       	adiw	r26, 0x02	; 2
    b8a4:	9c 93       	st	X, r25
    b8a6:	8e 93       	st	-X, r24
    b8a8:	11 97       	sbiw	r26, 0x01	; 1
    b8aa:	88 e6       	ldi	r24, 0x68	; 104
    b8ac:	97 e0       	ldi	r25, 0x07	; 7
    b8ae:	93 83       	std	Z+3, r25	; 0x03
    b8b0:	82 83       	std	Z+2, r24	; 0x02
    b8b2:	15 83       	std	Z+5, r17	; 0x05
    b8b4:	04 83       	std	Z+4, r16	; 0x04
    b8b6:	e2 c0       	rjmp	.+452    	; 0xba7c <PrintIdle+0xba4>
			   }else ClearMem(strPrint);
    b8b8:	80 ef       	ldi	r24, 0xF0	; 240
    b8ba:	99 e0       	ldi	r25, 0x09	; 9
    b8bc:	2c ce       	rjmp	.-936    	; 0xb516 <PrintIdle+0x63e>
		       break;
		  case 26:
		       CarriegeReturn();
    b8be:	0e 94 3d 4c 	call	0x987a	; 0x987a <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("     Gain Points  : %s"),strGainPoints);
    b8c2:	00 d0       	rcall	.+0      	; 0xb8c4 <PrintIdle+0x9ec>
    b8c4:	00 d0       	rcall	.+0      	; 0xb8c6 <PrintIdle+0x9ee>
    b8c6:	00 d0       	rcall	.+0      	; 0xb8c8 <PrintIdle+0x9f0>
    b8c8:	ed b7       	in	r30, 0x3d	; 61
    b8ca:	fe b7       	in	r31, 0x3e	; 62
    b8cc:	31 96       	adiw	r30, 0x01	; 1
    b8ce:	80 ef       	ldi	r24, 0xF0	; 240
    b8d0:	99 e0       	ldi	r25, 0x09	; 9
    b8d2:	ad b7       	in	r26, 0x3d	; 61
    b8d4:	be b7       	in	r27, 0x3e	; 62
    b8d6:	12 96       	adiw	r26, 0x02	; 2
    b8d8:	9c 93       	st	X, r25
    b8da:	8e 93       	st	-X, r24
    b8dc:	11 97       	sbiw	r26, 0x01	; 1
    b8de:	81 e5       	ldi	r24, 0x51	; 81
    b8e0:	97 e0       	ldi	r25, 0x07	; 7
    b8e2:	93 83       	std	Z+3, r25	; 0x03
    b8e4:	82 83       	std	Z+2, r24	; 0x02
    b8e6:	8a ec       	ldi	r24, 0xCA	; 202
    b8e8:	93 e0       	ldi	r25, 0x03	; 3
    b8ea:	c6 c0       	rjmp	.+396    	; 0xba78 <PrintIdle+0xba0>
		       break;
		  case 27:
		       CarriegeReturn();
    b8ec:	0e 94 3d 4c 	call	0x987a	; 0x987a <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("     Prev Points  : %s"),strPrevPoints);
    b8f0:	00 d0       	rcall	.+0      	; 0xb8f2 <PrintIdle+0xa1a>
    b8f2:	00 d0       	rcall	.+0      	; 0xb8f4 <PrintIdle+0xa1c>
    b8f4:	00 d0       	rcall	.+0      	; 0xb8f6 <PrintIdle+0xa1e>
    b8f6:	ed b7       	in	r30, 0x3d	; 61
    b8f8:	fe b7       	in	r31, 0x3e	; 62
    b8fa:	31 96       	adiw	r30, 0x01	; 1
    b8fc:	80 ef       	ldi	r24, 0xF0	; 240
    b8fe:	99 e0       	ldi	r25, 0x09	; 9
    b900:	ad b7       	in	r26, 0x3d	; 61
    b902:	be b7       	in	r27, 0x3e	; 62
    b904:	12 96       	adiw	r26, 0x02	; 2
    b906:	9c 93       	st	X, r25
    b908:	8e 93       	st	-X, r24
    b90a:	11 97       	sbiw	r26, 0x01	; 1
    b90c:	8a e3       	ldi	r24, 0x3A	; 58
    b90e:	97 e0       	ldi	r25, 0x07	; 7
    b910:	93 83       	std	Z+3, r25	; 0x03
    b912:	82 83       	std	Z+2, r24	; 0x02
    b914:	88 e4       	ldi	r24, 0x48	; 72
    b916:	9a e0       	ldi	r25, 0x0A	; 10
    b918:	af c0       	rjmp	.+350    	; 0xba78 <PrintIdle+0xba0>
		       break;
		  case 28:
		       CarriegeReturn();
    b91a:	0e 94 3d 4c 	call	0x987a	; 0x987a <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("     Curr Points  : %s"),strLoyCurrentPoints);
    b91e:	00 d0       	rcall	.+0      	; 0xb920 <PrintIdle+0xa48>
    b920:	00 d0       	rcall	.+0      	; 0xb922 <PrintIdle+0xa4a>
    b922:	00 d0       	rcall	.+0      	; 0xb924 <PrintIdle+0xa4c>
    b924:	ed b7       	in	r30, 0x3d	; 61
    b926:	fe b7       	in	r31, 0x3e	; 62
    b928:	31 96       	adiw	r30, 0x01	; 1
    b92a:	80 ef       	ldi	r24, 0xF0	; 240
    b92c:	99 e0       	ldi	r25, 0x09	; 9
    b92e:	ad b7       	in	r26, 0x3d	; 61
    b930:	be b7       	in	r27, 0x3e	; 62
    b932:	12 96       	adiw	r26, 0x02	; 2
    b934:	9c 93       	st	X, r25
    b936:	8e 93       	st	-X, r24
    b938:	11 97       	sbiw	r26, 0x01	; 1
    b93a:	83 e2       	ldi	r24, 0x23	; 35
    b93c:	97 e0       	ldi	r25, 0x07	; 7
    b93e:	93 83       	std	Z+3, r25	; 0x03
    b940:	82 83       	std	Z+2, r24	; 0x02
    b942:	89 e6       	ldi	r24, 0x69	; 105
    b944:	99 e0       	ldi	r25, 0x09	; 9
    b946:	98 c0       	rjmp	.+304    	; 0xba78 <PrintIdle+0xba0>
		       break;
		  case 29:
		       CarriegeReturn();
    b948:	0e 94 3d 4c 	call	0x987a	; 0x987a <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("     Expiry       : %s"),strLoyExpiry);
    b94c:	00 d0       	rcall	.+0      	; 0xb94e <PrintIdle+0xa76>
    b94e:	00 d0       	rcall	.+0      	; 0xb950 <PrintIdle+0xa78>
    b950:	00 d0       	rcall	.+0      	; 0xb952 <PrintIdle+0xa7a>
    b952:	ed b7       	in	r30, 0x3d	; 61
    b954:	fe b7       	in	r31, 0x3e	; 62
    b956:	31 96       	adiw	r30, 0x01	; 1
    b958:	80 ef       	ldi	r24, 0xF0	; 240
    b95a:	99 e0       	ldi	r25, 0x09	; 9
    b95c:	ad b7       	in	r26, 0x3d	; 61
    b95e:	be b7       	in	r27, 0x3e	; 62
    b960:	12 96       	adiw	r26, 0x02	; 2
    b962:	9c 93       	st	X, r25
    b964:	8e 93       	st	-X, r24
    b966:	11 97       	sbiw	r26, 0x01	; 1
    b968:	8c e0       	ldi	r24, 0x0C	; 12
    b96a:	97 e0       	ldi	r25, 0x07	; 7
    b96c:	93 83       	std	Z+3, r25	; 0x03
    b96e:	82 83       	std	Z+2, r24	; 0x02
    b970:	80 eb       	ldi	r24, 0xB0	; 176
    b972:	9d e0       	ldi	r25, 0x0D	; 13
    b974:	81 c0       	rjmp	.+258    	; 0xba78 <PrintIdle+0xba0>
		       break;
		  case 30:
		       CarriegeReturn();
    b976:	0e 94 3d 4c 	call	0x987a	; 0x987a <CarriegeReturn>
			   //RemSpaceLag(strLoyRedeemPoints);
		       sprintf_P(strPrint,PSTR("     Total Redeem : %s"),strLoyRedeemPoints);
    b97a:	00 d0       	rcall	.+0      	; 0xb97c <PrintIdle+0xaa4>
    b97c:	00 d0       	rcall	.+0      	; 0xb97e <PrintIdle+0xaa6>
    b97e:	00 d0       	rcall	.+0      	; 0xb980 <PrintIdle+0xaa8>
    b980:	ed b7       	in	r30, 0x3d	; 61
    b982:	fe b7       	in	r31, 0x3e	; 62
    b984:	31 96       	adiw	r30, 0x01	; 1
    b986:	80 ef       	ldi	r24, 0xF0	; 240
    b988:	99 e0       	ldi	r25, 0x09	; 9
    b98a:	ad b7       	in	r26, 0x3d	; 61
    b98c:	be b7       	in	r27, 0x3e	; 62
    b98e:	12 96       	adiw	r26, 0x02	; 2
    b990:	9c 93       	st	X, r25
    b992:	8e 93       	st	-X, r24
    b994:	11 97       	sbiw	r26, 0x01	; 1
    b996:	85 ef       	ldi	r24, 0xF5	; 245
    b998:	96 e0       	ldi	r25, 0x06	; 6
    b99a:	93 83       	std	Z+3, r25	; 0x03
    b99c:	82 83       	std	Z+2, r24	; 0x02
    b99e:	89 ea       	ldi	r24, 0xA9	; 169
    b9a0:	94 e0       	ldi	r25, 0x04	; 4
    b9a2:	6a c0       	rjmp	.+212    	; 0xba78 <PrintIdle+0xba0>
		       break;
		  case 31:
		       CarriegeReturn();
    b9a4:	0e 94 3d 4c 	call	0x987a	; 0x987a <CarriegeReturn>
			   //RemSpaceLag(strLoyCurrMonConsumeV);
			   //FormatCurrency(strLoyCurrMonConsumeV);
		       sprintf_P(strPrint,PSTR("     Month Cons V : %s L"),strLoyCurrMonConsumeV);
    b9a8:	00 d0       	rcall	.+0      	; 0xb9aa <PrintIdle+0xad2>
    b9aa:	00 d0       	rcall	.+0      	; 0xb9ac <PrintIdle+0xad4>
    b9ac:	00 d0       	rcall	.+0      	; 0xb9ae <PrintIdle+0xad6>
    b9ae:	ed b7       	in	r30, 0x3d	; 61
    b9b0:	fe b7       	in	r31, 0x3e	; 62
    b9b2:	31 96       	adiw	r30, 0x01	; 1
    b9b4:	80 ef       	ldi	r24, 0xF0	; 240
    b9b6:	99 e0       	ldi	r25, 0x09	; 9
    b9b8:	ad b7       	in	r26, 0x3d	; 61
    b9ba:	be b7       	in	r27, 0x3e	; 62
    b9bc:	12 96       	adiw	r26, 0x02	; 2
    b9be:	9c 93       	st	X, r25
    b9c0:	8e 93       	st	-X, r24
    b9c2:	11 97       	sbiw	r26, 0x01	; 1
    b9c4:	8c ed       	ldi	r24, 0xDC	; 220
    b9c6:	96 e0       	ldi	r25, 0x06	; 6
    b9c8:	93 83       	std	Z+3, r25	; 0x03
    b9ca:	82 83       	std	Z+2, r24	; 0x02
    b9cc:	84 e2       	ldi	r24, 0x24	; 36
    b9ce:	9d e0       	ldi	r25, 0x0D	; 13
    b9d0:	53 c0       	rjmp	.+166    	; 0xba78 <PrintIdle+0xba0>
		       break;
		  case 32:
		       CarriegeReturn();
    b9d2:	0e 94 3d 4c 	call	0x987a	; 0x987a <CarriegeReturn>
			   //RemSpaceLag(strLoyCurrMonConsumeA);
			   //FormatCurrency(strLoyCurrMonConsumeA);
		       sprintf_P(strPrint,PSTR("     Month Cons A : Rp.%s"),strLoyCurrMonConsumeA);
    b9d6:	00 d0       	rcall	.+0      	; 0xb9d8 <PrintIdle+0xb00>
    b9d8:	00 d0       	rcall	.+0      	; 0xb9da <PrintIdle+0xb02>
    b9da:	00 d0       	rcall	.+0      	; 0xb9dc <PrintIdle+0xb04>
    b9dc:	ed b7       	in	r30, 0x3d	; 61
    b9de:	fe b7       	in	r31, 0x3e	; 62
    b9e0:	31 96       	adiw	r30, 0x01	; 1
    b9e2:	80 ef       	ldi	r24, 0xF0	; 240
    b9e4:	99 e0       	ldi	r25, 0x09	; 9
    b9e6:	ad b7       	in	r26, 0x3d	; 61
    b9e8:	be b7       	in	r27, 0x3e	; 62
    b9ea:	12 96       	adiw	r26, 0x02	; 2
    b9ec:	9c 93       	st	X, r25
    b9ee:	8e 93       	st	-X, r24
    b9f0:	11 97       	sbiw	r26, 0x01	; 1
    b9f2:	82 ec       	ldi	r24, 0xC2	; 194
    b9f4:	96 e0       	ldi	r25, 0x06	; 6
    b9f6:	93 83       	std	Z+3, r25	; 0x03
    b9f8:	82 83       	std	Z+2, r24	; 0x02
    b9fa:	8d e8       	ldi	r24, 0x8D	; 141
    b9fc:	94 e0       	ldi	r25, 0x04	; 4
    b9fe:	3c c0       	rjmp	.+120    	; 0xba78 <PrintIdle+0xba0>
		       break;
		  case 33://EndOfLoyalty
		       CarriegeReturn();
    ba00:	0e 94 3d 4c 	call	0x987a	; 0x987a <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("    ------------------------------"));
    ba04:	00 d0       	rcall	.+0      	; 0xba06 <PrintIdle+0xb2e>
    ba06:	00 d0       	rcall	.+0      	; 0xba08 <PrintIdle+0xb30>
    ba08:	80 ef       	ldi	r24, 0xF0	; 240
    ba0a:	99 e0       	ldi	r25, 0x09	; 9
    ba0c:	ad b7       	in	r26, 0x3d	; 61
    ba0e:	be b7       	in	r27, 0x3e	; 62
    ba10:	12 96       	adiw	r26, 0x02	; 2
    ba12:	9c 93       	st	X, r25
    ba14:	8e 93       	st	-X, r24
    ba16:	11 97       	sbiw	r26, 0x01	; 1
    ba18:	8f e9       	ldi	r24, 0x9F	; 159
    ba1a:	96 e0       	ldi	r25, 0x06	; 6
    ba1c:	48 c0       	rjmp	.+144    	; 0xbaae <PrintIdle+0xbd6>
		       break;
		  case 34:
		       CarriegeReturn();
    ba1e:	0e 94 3d 4c 	call	0x987a	; 0x987a <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("     Surcharge Dsc: %s"),strSurchargeDesc);
    ba22:	00 d0       	rcall	.+0      	; 0xba24 <PrintIdle+0xb4c>
    ba24:	00 d0       	rcall	.+0      	; 0xba26 <PrintIdle+0xb4e>
    ba26:	00 d0       	rcall	.+0      	; 0xba28 <PrintIdle+0xb50>
    ba28:	ed b7       	in	r30, 0x3d	; 61
    ba2a:	fe b7       	in	r31, 0x3e	; 62
    ba2c:	31 96       	adiw	r30, 0x01	; 1
    ba2e:	80 ef       	ldi	r24, 0xF0	; 240
    ba30:	99 e0       	ldi	r25, 0x09	; 9
    ba32:	ad b7       	in	r26, 0x3d	; 61
    ba34:	be b7       	in	r27, 0x3e	; 62
    ba36:	12 96       	adiw	r26, 0x02	; 2
    ba38:	9c 93       	st	X, r25
    ba3a:	8e 93       	st	-X, r24
    ba3c:	11 97       	sbiw	r26, 0x01	; 1
    ba3e:	88 e8       	ldi	r24, 0x88	; 136
    ba40:	96 e0       	ldi	r25, 0x06	; 6
    ba42:	93 83       	std	Z+3, r25	; 0x03
    ba44:	82 83       	std	Z+2, r24	; 0x02
    ba46:	8e ef       	ldi	r24, 0xFE	; 254
    ba48:	98 e0       	ldi	r25, 0x08	; 8
    ba4a:	16 c0       	rjmp	.+44     	; 0xba78 <PrintIdle+0xba0>
		       break;
		  case 35:
		       CarriegeReturn();
    ba4c:	0e 94 3d 4c 	call	0x987a	; 0x987a <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("     Surcharge Amt: %s"),strSurchargeAmount);
    ba50:	00 d0       	rcall	.+0      	; 0xba52 <PrintIdle+0xb7a>
    ba52:	00 d0       	rcall	.+0      	; 0xba54 <PrintIdle+0xb7c>
    ba54:	00 d0       	rcall	.+0      	; 0xba56 <PrintIdle+0xb7e>
    ba56:	ed b7       	in	r30, 0x3d	; 61
    ba58:	fe b7       	in	r31, 0x3e	; 62
    ba5a:	31 96       	adiw	r30, 0x01	; 1
    ba5c:	80 ef       	ldi	r24, 0xF0	; 240
    ba5e:	99 e0       	ldi	r25, 0x09	; 9
    ba60:	ad b7       	in	r26, 0x3d	; 61
    ba62:	be b7       	in	r27, 0x3e	; 62
    ba64:	12 96       	adiw	r26, 0x02	; 2
    ba66:	9c 93       	st	X, r25
    ba68:	8e 93       	st	-X, r24
    ba6a:	11 97       	sbiw	r26, 0x01	; 1
    ba6c:	81 e7       	ldi	r24, 0x71	; 113
    ba6e:	96 e0       	ldi	r25, 0x06	; 6
    ba70:	93 83       	std	Z+3, r25	; 0x03
    ba72:	82 83       	std	Z+2, r24	; 0x02
    ba74:	86 e8       	ldi	r24, 0x86	; 134
    ba76:	99 e0       	ldi	r25, 0x09	; 9
    ba78:	95 83       	std	Z+5, r25	; 0x05
    ba7a:	84 83       	std	Z+4, r24	; 0x04
    ba7c:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    ba80:	ed b7       	in	r30, 0x3d	; 61
    ba82:	fe b7       	in	r31, 0x3e	; 62
    ba84:	36 96       	adiw	r30, 0x06	; 6
    ba86:	0f b6       	in	r0, 0x3f	; 63
    ba88:	f8 94       	cli
    ba8a:	fe bf       	out	0x3e, r31	; 62
    ba8c:	0f be       	out	0x3f, r0	; 63
    ba8e:	ed bf       	out	0x3d, r30	; 61
    ba90:	18 c0       	rjmp	.+48     	; 0xbac2 <PrintIdle+0xbea>
		       break;
		  case 36:
		       CarriegeReturn();
    ba92:	0e 94 3d 4c 	call	0x987a	; 0x987a <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("    ------------------------------"));
    ba96:	00 d0       	rcall	.+0      	; 0xba98 <PrintIdle+0xbc0>
    ba98:	00 d0       	rcall	.+0      	; 0xba9a <PrintIdle+0xbc2>
    ba9a:	80 ef       	ldi	r24, 0xF0	; 240
    ba9c:	99 e0       	ldi	r25, 0x09	; 9
    ba9e:	ad b7       	in	r26, 0x3d	; 61
    baa0:	be b7       	in	r27, 0x3e	; 62
    baa2:	12 96       	adiw	r26, 0x02	; 2
    baa4:	9c 93       	st	X, r25
    baa6:	8e 93       	st	-X, r24
    baa8:	11 97       	sbiw	r26, 0x01	; 1
    baaa:	8e e4       	ldi	r24, 0x4E	; 78
    baac:	96 e0       	ldi	r25, 0x06	; 6
    baae:	14 96       	adiw	r26, 0x04	; 4
    bab0:	9c 93       	st	X, r25
    bab2:	8e 93       	st	-X, r24
    bab4:	13 97       	sbiw	r26, 0x03	; 3
    bab6:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    baba:	0f 90       	pop	r0
    babc:	0f 90       	pop	r0
    babe:	0f 90       	pop	r0
    bac0:	0f 90       	pop	r0
		       break;
		  }
		  iLoop=0;iSend=0;LSend=strlen(strPrint);
    bac2:	10 92 4a 02 	sts	0x024A, r1
    bac6:	10 92 49 02 	sts	0x0249, r1
    baca:	10 92 4e 02 	sts	0x024E, r1
    bace:	10 92 4d 02 	sts	0x024D, r1
    bad2:	e0 ef       	ldi	r30, 0xF0	; 240
    bad4:	f9 e0       	ldi	r31, 0x09	; 9
    bad6:	01 90       	ld	r0, Z+
    bad8:	00 20       	and	r0, r0
    bada:	e9 f7       	brne	.-6      	; 0xbad6 <PrintIdle+0xbfe>
    badc:	31 97       	sbiw	r30, 0x01	; 1
    bade:	e0 5f       	subi	r30, 0xF0	; 240
    bae0:	f9 40       	sbci	r31, 0x09	; 9
    bae2:	f0 93 4c 02 	sts	0x024C, r31
    bae6:	e0 93 4b 02 	sts	0x024B, r30
          stPrintIdle=piPrintMessage;
    baea:	8a e0       	ldi	r24, 0x0A	; 10
    baec:	7d c1       	rjmp	.+762    	; 0xbde8 <PrintIdle+0xf10>
	      break;
     case piPrintMessage:
	      if (iSend<LSend){
    baee:	20 91 4d 02 	lds	r18, 0x024D
    baf2:	30 91 4e 02 	lds	r19, 0x024E
    baf6:	80 91 4b 02 	lds	r24, 0x024B
    bafa:	90 91 4c 02 	lds	r25, 0x024C
    bafe:	28 17       	cp	r18, r24
    bb00:	39 07       	cpc	r19, r25
    bb02:	68 f4       	brcc	.+26     	; 0xbb1e <PrintIdle+0xc46>
		      iLoop++;
    bb04:	80 91 49 02 	lds	r24, 0x0249
    bb08:	90 91 4a 02 	lds	r25, 0x024A
    bb0c:	01 96       	adiw	r24, 0x01	; 1
    bb0e:	90 93 4a 02 	sts	0x024A, r25
    bb12:	80 93 49 02 	sts	0x0249, r24
			  if((iLoop%PRINT_DELAY)==0){
				 TimPrintBusy=0;
    bb16:	10 92 b8 01 	sts	0x01B8, r1
				 stPrintIdle=piCheckPrintStatusMessage;
    bb1a:	8c e0       	ldi	r24, 0x0C	; 12
    bb1c:	65 c1       	rjmp	.+714    	; 0xbde8 <PrintIdle+0xf10>
				 }
			  }
          else{iMessage++;
    bb1e:	80 91 51 02 	lds	r24, 0x0251
    bb22:	8f 5f       	subi	r24, 0xFF	; 255
    bb24:	80 93 51 02 	sts	0x0251, r24
		      if (iMessage>MessageLine){
    bb28:	90 91 50 02 	lds	r25, 0x0250
    bb2c:	98 17       	cp	r25, r24
    bb2e:	30 f4       	brcc	.+12     	; 0xbb3c <PrintIdle+0xc64>
			      iFooter=0;				  
    bb30:	10 92 54 02 	sts	0x0254, r1
				  CarriegeReturn();
    bb34:	0e 94 3d 4c 	call	0x987a	; 0x987a <CarriegeReturn>
				  stPrintIdle=piLoadOperatorName;//piLoadFooter;
    bb38:	85 e1       	ldi	r24, 0x15	; 21
    bb3a:	56 c1       	rjmp	.+684    	; 0xbde8 <PrintIdle+0xf10>
			  }
			  else stPrintIdle=piLoadMessage;
    bb3c:	89 e0       	ldi	r24, 0x09	; 9
    bb3e:	54 c1       	rjmp	.+680    	; 0xbde8 <PrintIdle+0xf10>
			  }
	      break;
     case piCheckPrintStatusMessage:
	      if (IsBusyPrint==False){
    bb40:	80 91 b5 01 	lds	r24, 0x01B5
    bb44:	88 23       	and	r24, r24
    bb46:	09 f0       	breq	.+2      	; 0xbb4a <PrintIdle+0xc72>
    bb48:	47 c1       	rjmp	.+654    	; 0xbdd8 <PrintIdle+0xf00>
		      _uart(_COM_PRINTER,1,strPrint[iSend]);
    bb4a:	e0 91 4d 02 	lds	r30, 0x024D
    bb4e:	f0 91 4e 02 	lds	r31, 0x024E
    bb52:	e0 51       	subi	r30, 0x10	; 16
    bb54:	f6 4f       	sbci	r31, 0xF6	; 246
    bb56:	61 e0       	ldi	r22, 0x01	; 1
    bb58:	40 81       	ld	r20, Z
    bb5a:	0e 94 53 b2 	call	0x164a6	; 0x164a6 <_uart>
		      iSend++;
    bb5e:	80 91 4d 02 	lds	r24, 0x024D
    bb62:	90 91 4e 02 	lds	r25, 0x024E
    bb66:	01 96       	adiw	r24, 0x01	; 1
    bb68:	90 93 4e 02 	sts	0x024E, r25
    bb6c:	80 93 4d 02 	sts	0x024D, r24
		      stPrintIdle=piPrintMessage;
    bb70:	8a e0       	ldi	r24, 0x0A	; 10
    bb72:	30 c1       	rjmp	.+608    	; 0xbdd4 <PrintIdle+0xefc>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    bb74:	8e 01       	movw	r16, r28
    bb76:	0f 5f       	subi	r16, 0xFF	; 255
    bb78:	1f 4f       	sbci	r17, 0xFF	; 255
    bb7a:	c8 01       	movw	r24, r16
    bb7c:	65 e1       	ldi	r22, 0x15	; 21
    bb7e:	70 e0       	ldi	r23, 0x00	; 0
    bb80:	42 e1       	ldi	r20, 0x12	; 18
    bb82:	50 e0       	ldi	r21, 0x00	; 0
    bb84:	2d ef       	ldi	r18, 0xFD	; 253
    bb86:	32 e1       	ldi	r19, 0x12	; 18
    bb88:	0e 94 f1 b3 	call	0x167e2	; 0x167e2 <__eerd_block>

	//Added Operator Name:
	 case piLoadOperatorName:
	      //CheckEmpty
		  eeprom_read_block((void*) &strOperatorName, (const void*) &DefOperatorName,18);
		  if ((SpaceOnly(strOperatorName)!=True)||(strlen(strOperatorName)>0)){
    bb8c:	c8 01       	movw	r24, r16
    bb8e:	0e 94 f4 23 	call	0x47e8	; 0x47e8 <SpaceOnly>
    bb92:	81 30       	cpi	r24, 0x01	; 1
    bb94:	21 f4       	brne	.+8      	; 0xbb9e <PrintIdle+0xcc6>
    bb96:	89 81       	ldd	r24, Y+1	; 0x01
    bb98:	88 23       	and	r24, r24
    bb9a:	09 f4       	brne	.+2      	; 0xbb9e <PrintIdle+0xcc6>
    bb9c:	97 c0       	rjmp	.+302    	; 0xbccc <PrintIdle+0xdf4>
    bb9e:	ce 01       	movw	r24, r28
    bba0:	01 96       	adiw	r24, 0x01	; 1
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bba2:	9e 01       	movw	r18, r28
    bba4:	20 5f       	subi	r18, 0xF0	; 240
    bba6:	3f 4f       	sbci	r19, 0xFF	; 255
	    Dest[i]=Source[IdxSource+i];
    bba8:	01 96       	adiw	r24, 0x01	; 1
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bbaa:	82 17       	cp	r24, r18
    bbac:	93 07       	cpc	r25, r19
    bbae:	e1 f7       	brne	.-8      	; 0xbba8 <PrintIdle+0xcd0>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    bbb0:	18 8a       	std	Y+16, r1	; 0x10
	 case piLoadOperatorName:
	      //CheckEmpty
		  eeprom_read_block((void*) &strOperatorName, (const void*) &DefOperatorName,18);
		  if ((SpaceOnly(strOperatorName)!=True)||(strlen(strOperatorName)>0)){
			   StrPosCopy(strOperatorName,strOperatorName,0,15);
			   sprintf_P(strPrint,PSTR("     Operator: %s"),strOperatorName);			   
    bbb2:	00 d0       	rcall	.+0      	; 0xbbb4 <PrintIdle+0xcdc>
    bbb4:	00 d0       	rcall	.+0      	; 0xbbb6 <PrintIdle+0xcde>
    bbb6:	00 d0       	rcall	.+0      	; 0xbbb8 <PrintIdle+0xce0>
    bbb8:	ed b7       	in	r30, 0x3d	; 61
    bbba:	fe b7       	in	r31, 0x3e	; 62
    bbbc:	31 96       	adiw	r30, 0x01	; 1
    bbbe:	00 ef       	ldi	r16, 0xF0	; 240
    bbc0:	19 e0       	ldi	r17, 0x09	; 9
    bbc2:	ad b7       	in	r26, 0x3d	; 61
    bbc4:	be b7       	in	r27, 0x3e	; 62
    bbc6:	12 96       	adiw	r26, 0x02	; 2
    bbc8:	1c 93       	st	X, r17
    bbca:	0e 93       	st	-X, r16
    bbcc:	11 97       	sbiw	r26, 0x01	; 1
    bbce:	8c e3       	ldi	r24, 0x3C	; 60
    bbd0:	96 e0       	ldi	r25, 0x06	; 6
    bbd2:	93 83       	std	Z+3, r25	; 0x03
    bbd4:	82 83       	std	Z+2, r24	; 0x02
    bbd6:	ce 01       	movw	r24, r28
    bbd8:	01 96       	adiw	r24, 0x01	; 1
    bbda:	95 83       	std	Z+5, r25	; 0x05
    bbdc:	84 83       	std	Z+4, r24	; 0x04
    bbde:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
		       iSend=0;
    bbe2:	10 92 4e 02 	sts	0x024E, r1
    bbe6:	10 92 4d 02 	sts	0x024D, r1
			   iLoop=0;
    bbea:	10 92 4a 02 	sts	0x024A, r1
    bbee:	10 92 49 02 	sts	0x0249, r1
			   LSend=strlen(strPrint);
    bbf2:	f8 01       	movw	r30, r16
    bbf4:	01 90       	ld	r0, Z+
    bbf6:	00 20       	and	r0, r0
    bbf8:	e9 f7       	brne	.-6      	; 0xbbf4 <PrintIdle+0xd1c>
    bbfa:	8f 01       	movw	r16, r30
    bbfc:	01 50       	subi	r16, 0x01	; 1
    bbfe:	10 40       	sbci	r17, 0x00	; 0
    bc00:	00 5f       	subi	r16, 0xF0	; 240
    bc02:	19 40       	sbci	r17, 0x09	; 9
    bc04:	10 93 4c 02 	sts	0x024C, r17
    bc08:	00 93 4b 02 	sts	0x024B, r16
			   stPrintIdle=piPrintOperatorName;	
    bc0c:	86 e1       	ldi	r24, 0x16	; 22
    bc0e:	80 93 56 02 	sts	0x0256, r24
    bc12:	8d b7       	in	r24, 0x3d	; 61
    bc14:	9e b7       	in	r25, 0x3e	; 62
    bc16:	06 96       	adiw	r24, 0x06	; 6
    bc18:	0f b6       	in	r0, 0x3f	; 63
    bc1a:	f8 94       	cli
    bc1c:	9e bf       	out	0x3e, r25	; 62
    bc1e:	0f be       	out	0x3f, r0	; 63
    bc20:	8d bf       	out	0x3d, r24	; 61
    bc22:	0d c1       	rjmp	.+538    	; 0xbe3e <PrintIdle+0xf66>
		  }	       
          else stPrintIdle=piLoadFooter;
	      break;
	 case piPrintOperatorName:
		  if (iSend<LSend){
    bc24:	20 91 4d 02 	lds	r18, 0x024D
    bc28:	30 91 4e 02 	lds	r19, 0x024E
    bc2c:	80 91 4b 02 	lds	r24, 0x024B
    bc30:	90 91 4c 02 	lds	r25, 0x024C
    bc34:	28 17       	cp	r18, r24
    bc36:	39 07       	cpc	r19, r25
    bc38:	68 f4       	brcc	.+26     	; 0xbc54 <PrintIdle+0xd7c>
		      iLoop++;
    bc3a:	80 91 49 02 	lds	r24, 0x0249
    bc3e:	90 91 4a 02 	lds	r25, 0x024A
    bc42:	01 96       	adiw	r24, 0x01	; 1
    bc44:	90 93 4a 02 	sts	0x024A, r25
    bc48:	80 93 49 02 	sts	0x0249, r24
			  if((iLoop%PRINT_DELAY)==0){
				  TimPrintBusy=0;
    bc4c:	10 92 b8 01 	sts	0x01B8, r1
				  stPrintIdle=piCheckPrintOperatorName;
    bc50:	87 e1       	ldi	r24, 0x17	; 23
    bc52:	ca c0       	rjmp	.+404    	; 0xbde8 <PrintIdle+0xf10>
				}
			  }
          else {
			  CarriegeReturn();
    bc54:	0e 94 3d 4c 	call	0x987a	; 0x987a <CarriegeReturn>
			  CarriegeReturn();
    bc58:	0e 94 3d 4c 	call	0x987a	; 0x987a <CarriegeReturn>
    bc5c:	37 c0       	rjmp	.+110    	; 0xbccc <PrintIdle+0xdf4>
			  stPrintIdle=piLoadFooter;
			  }
	      break;
	 case piCheckPrintOperatorName:
	      if (IsBusyPrint==False){
    bc5e:	80 91 b5 01 	lds	r24, 0x01B5
    bc62:	88 23       	and	r24, r24
    bc64:	09 f0       	breq	.+2      	; 0xbc68 <PrintIdle+0xd90>
    bc66:	b8 c0       	rjmp	.+368    	; 0xbdd8 <PrintIdle+0xf00>
		      _uart(_COM_PRINTER,1,strPrint[iSend]);
    bc68:	e0 91 4d 02 	lds	r30, 0x024D
    bc6c:	f0 91 4e 02 	lds	r31, 0x024E
    bc70:	e0 51       	subi	r30, 0x10	; 16
    bc72:	f6 4f       	sbci	r31, 0xF6	; 246
    bc74:	61 e0       	ldi	r22, 0x01	; 1
    bc76:	40 81       	ld	r20, Z
    bc78:	0e 94 53 b2 	call	0x164a6	; 0x164a6 <_uart>
		      iSend++;
    bc7c:	80 91 4d 02 	lds	r24, 0x024D
    bc80:	90 91 4e 02 	lds	r25, 0x024E
    bc84:	01 96       	adiw	r24, 0x01	; 1
    bc86:	90 93 4e 02 	sts	0x024E, r25
    bc8a:	80 93 4d 02 	sts	0x024D, r24
		      stPrintIdle=piPrintOperatorName;
    bc8e:	86 e1       	ldi	r24, 0x16	; 22
    bc90:	a1 c0       	rjmp	.+322    	; 0xbdd4 <PrintIdle+0xefc>
    bc92:	60 91 54 02 	lds	r22, 0x0254
    bc96:	89 e2       	ldi	r24, 0x29	; 41
    bc98:	68 9f       	mul	r22, r24
    bc9a:	b0 01       	movw	r22, r0
    bc9c:	11 24       	eor	r1, r1
    bc9e:	63 5e       	subi	r22, 0xE3	; 227
    bca0:	7c 4f       	sbci	r23, 0xFC	; 252
    bca2:	80 ef       	ldi	r24, 0xF0	; 240
    bca4:	99 e0       	ldi	r25, 0x09	; 9
    bca6:	48 e2       	ldi	r20, 0x28	; 40
    bca8:	50 e0       	ldi	r21, 0x00	; 0
    bcaa:	2d ef       	ldi	r18, 0xFD	; 253
    bcac:	32 e1       	ldi	r19, 0x12	; 18
    bcae:	0e 94 f1 b3 	call	0x167e2	; 0x167e2 <__eerd_block>

	 	       
     case piLoadFooter:
	      FillChar(strPrint,0,sizeof(strPrint));
	      eeprom_read_block((void*) &strPrint, (const void*) &DefHeaderFooter[6+iFooter], 40);
		  iFooter++;
    bcb2:	80 91 54 02 	lds	r24, 0x0254
    bcb6:	8f 5f       	subi	r24, 0xFF	; 255
    bcb8:	80 93 54 02 	sts	0x0254, r24
		  if (iFooter<=4){
    bcbc:	85 30       	cpi	r24, 0x05	; 5
    bcbe:	90 f4       	brcc	.+36     	; 0xbce4 <PrintIdle+0xe0c>
		      if (SpaceOnly(strPrint)==True){
    bcc0:	80 ef       	ldi	r24, 0xF0	; 240
    bcc2:	99 e0       	ldi	r25, 0x09	; 9
    bcc4:	0e 94 f4 23 	call	0x47e8	; 0x47e8 <SpaceOnly>
    bcc8:	81 30       	cpi	r24, 0x01	; 1
    bcca:	11 f4       	brne	.+4      	; 0xbcd0 <PrintIdle+0xdf8>
			      stPrintIdle=piLoadFooter;
    bccc:	8e e0       	ldi	r24, 0x0E	; 14
    bcce:	8c c0       	rjmp	.+280    	; 0xbde8 <PrintIdle+0xf10>
				  }
			  else{
			      iSend=0;
    bcd0:	10 92 4e 02 	sts	0x024E, r1
    bcd4:	10 92 4d 02 	sts	0x024D, r1
				  iLoop=0;
    bcd8:	10 92 4a 02 	sts	0x024A, r1
    bcdc:	10 92 49 02 	sts	0x0249, r1
				  stPrintIdle=piPrintFooter;
    bce0:	8f e0       	ldi	r24, 0x0F	; 15
    bce2:	82 c0       	rjmp	.+260    	; 0xbde8 <PrintIdle+0xf10>
				  //RemSpaceLag(strPrint);
				  //CarriegeReturn();
			      }
		  }else{stPrintIdle=piInitScroll;
    bce4:	81 e1       	ldi	r24, 0x11	; 17
    bce6:	80 c0       	rjmp	.+256    	; 0xbde8 <PrintIdle+0xf10>
		        //iPrinted++;
			}
	      break;
     case piPrintFooter:
		  if (iSend<40){
    bce8:	80 91 4d 02 	lds	r24, 0x024D
    bcec:	90 91 4e 02 	lds	r25, 0x024E
    bcf0:	88 97       	sbiw	r24, 0x28	; 40
    bcf2:	68 f4       	brcc	.+26     	; 0xbd0e <PrintIdle+0xe36>
		      iLoop++;
    bcf4:	80 91 49 02 	lds	r24, 0x0249
    bcf8:	90 91 4a 02 	lds	r25, 0x024A
    bcfc:	01 96       	adiw	r24, 0x01	; 1
    bcfe:	90 93 4a 02 	sts	0x024A, r25
    bd02:	80 93 49 02 	sts	0x0249, r24
			  if((iLoop%PRINT_DELAY)==0){
				TimPrintBusy=0;
    bd06:	10 92 b8 01 	sts	0x01B8, r1
				stPrintIdle=piCheckPrintStatusFooter;
    bd0a:	8d e0       	ldi	r24, 0x0D	; 13
    bd0c:	6d c0       	rjmp	.+218    	; 0xbde8 <PrintIdle+0xf10>
				}
			  }
          else {
		      stPrintIdle=piLoadFooter;
    bd0e:	8e e0       	ldi	r24, 0x0E	; 14
    bd10:	80 93 56 02 	sts	0x0256, r24
			  CarriegeReturn();
    bd14:	0e 94 3d 4c 	call	0x987a	; 0x987a <CarriegeReturn>
    bd18:	92 c0       	rjmp	.+292    	; 0xbe3e <PrintIdle+0xf66>
			  }
	      break;
     case piCheckPrintStatusFooter:
	      if (IsBusyPrint==False){
    bd1a:	80 91 b5 01 	lds	r24, 0x01B5
    bd1e:	88 23       	and	r24, r24
    bd20:	09 f0       	breq	.+2      	; 0xbd24 <PrintIdle+0xe4c>
    bd22:	5a c0       	rjmp	.+180    	; 0xbdd8 <PrintIdle+0xf00>
		      _uart(_COM_PRINTER,1,strPrint[iSend]);
    bd24:	e0 91 4d 02 	lds	r30, 0x024D
    bd28:	f0 91 4e 02 	lds	r31, 0x024E
    bd2c:	e0 51       	subi	r30, 0x10	; 16
    bd2e:	f6 4f       	sbci	r31, 0xF6	; 246
    bd30:	61 e0       	ldi	r22, 0x01	; 1
    bd32:	40 81       	ld	r20, Z
    bd34:	0e 94 53 b2 	call	0x164a6	; 0x164a6 <_uart>
		      iSend++;
    bd38:	80 91 4d 02 	lds	r24, 0x024D
    bd3c:	90 91 4e 02 	lds	r25, 0x024E
    bd40:	01 96       	adiw	r24, 0x01	; 1
    bd42:	90 93 4e 02 	sts	0x024E, r25
    bd46:	80 93 4d 02 	sts	0x024D, r24
		      stPrintIdle=piPrintFooter;
    bd4a:	8f e0       	ldi	r24, 0x0F	; 15
    bd4c:	43 c0       	rjmp	.+134    	; 0xbdd4 <PrintIdle+0xefc>
		      stPrintIdle=piFinishPrintIdle;
			  }
	      break;

     case piInitScroll:
	      iPrinted++;
    bd4e:	90 91 48 02 	lds	r25, 0x0248
    bd52:	9f 5f       	subi	r25, 0xFF	; 255
    bd54:	90 93 48 02 	sts	0x0248, r25
		  iScroll=0;
    bd58:	10 92 53 02 	sts	0x0253, r1
		  iLoop=0;
    bd5c:	10 92 4a 02 	sts	0x024A, r1
    bd60:	10 92 49 02 	sts	0x0249, r1
		  if (iPrinted<PrintCopy){
    bd64:	80 91 47 02 	lds	r24, 0x0247
    bd68:	98 17       	cp	r25, r24
    bd6a:	28 f4       	brcc	.+10     	; 0xbd76 <PrintIdle+0xe9e>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    bd6c:	e1 99       	sbic	0x1c, 1	; 28
    bd6e:	fe cf       	rjmp	.-4      	; 0xbd6c <PrintIdle+0xe94>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    bd70:	82 e3       	ldi	r24, 0x32	; 50
    bd72:	90 e0       	ldi	r25, 0x00	; 0
    bd74:	04 c0       	rjmp	.+8      	; 0xbd7e <PrintIdle+0xea6>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    bd76:	e1 99       	sbic	0x1c, 1	; 28
    bd78:	fe cf       	rjmp	.-4      	; 0xbd76 <PrintIdle+0xe9e>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    bd7a:	81 e3       	ldi	r24, 0x31	; 49
    bd7c:	90 e0       	ldi	r25, 0x00	; 0
    bd7e:	9f bb       	out	0x1f, r25	; 31
    bd80:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    bd82:	e0 9a       	sbi	0x1c, 0	; 28
    bd84:	8d b3       	in	r24, 0x1d	; 29
		      nScroll=eeprom_read_byte(&DefPrintScrollSpace);
		  }else if (iPrinted>=PrintCopy){		  	  
		      nScroll=eeprom_read_byte(&DefPrintScrollEnd);
    bd86:	80 93 52 02 	sts	0x0252, r24
		  if (eeprom_read_byte(&DefPrinterType)==PT_CUSTOM_TG02){
		      _uart_printf(0,1,PSTR("----Scrolled2-----"));

		      stPrintIdle=piPaperCut;
		  }*/
          stPrintIdle=piScrollPaper;              
    bd8a:	80 e1       	ldi	r24, 0x10	; 16
    bd8c:	2d c0       	rjmp	.+90     	; 0xbde8 <PrintIdle+0xf10>
	      break;
     case piScrollPaper:
	      iLoop++;
    bd8e:	80 91 49 02 	lds	r24, 0x0249
    bd92:	90 91 4a 02 	lds	r25, 0x024A
    bd96:	01 96       	adiw	r24, 0x01	; 1
    bd98:	90 93 4a 02 	sts	0x024A, r25
    bd9c:	80 93 49 02 	sts	0x0249, r24
		  if (iLoop%PRINT_DELAY==0){
			  TimPrintBusy=0;
    bda0:	10 92 b8 01 	sts	0x01B8, r1
			  stPrintIdle=piCheckPrintStatusScroll;
    bda4:	82 e1       	ldi	r24, 0x12	; 18
    bda6:	80 93 56 02 	sts	0x0256, r24
			  }
	      if (iScroll>nScroll)stPrintIdle=piPaperCut;
    bdaa:	90 91 53 02 	lds	r25, 0x0253
    bdae:	80 91 52 02 	lds	r24, 0x0252
    bdb2:	89 17       	cp	r24, r25
    bdb4:	08 f0       	brcs	.+2      	; 0xbdb8 <PrintIdle+0xee0>
    bdb6:	43 c0       	rjmp	.+134    	; 0xbe3e <PrintIdle+0xf66>
    bdb8:	83 e1       	ldi	r24, 0x13	; 19
    bdba:	16 c0       	rjmp	.+44     	; 0xbde8 <PrintIdle+0xf10>
	      break;
     case piCheckPrintStatusScroll:
	      if (IsBusyPrint==False){
    bdbc:	80 91 b5 01 	lds	r24, 0x01B5
    bdc0:	88 23       	and	r24, r24
    bdc2:	51 f4       	brne	.+20     	; 0xbdd8 <PrintIdle+0xf00>
		      iScroll++;
    bdc4:	80 91 53 02 	lds	r24, 0x0253
    bdc8:	8f 5f       	subi	r24, 0xFF	; 255
    bdca:	80 93 53 02 	sts	0x0253, r24
		      CarriegeReturn();
    bdce:	0e 94 3d 4c 	call	0x987a	; 0x987a <CarriegeReturn>
		      stPrintIdle=piScrollPaper;
    bdd2:	80 e1       	ldi	r24, 0x10	; 16
    bdd4:	80 93 56 02 	sts	0x0256, r24
		  }
		  if (TimPrintBusy>TIM_BUSY_PRINT){
    bdd8:	80 91 b8 01 	lds	r24, 0x01B8
    bddc:	8b 30       	cpi	r24, 0x0B	; 11
    bdde:	78 f1       	brcs	.+94     	; 0xbe3e <PrintIdle+0xf66>
		      IsPrintERROR=True;
    bde0:	81 e0       	ldi	r24, 0x01	; 1
    bde2:	80 93 b3 01 	sts	0x01B3, r24
		      stPrintIdle=piFinishPrintIdle;
    bde6:	84 e1       	ldi	r24, 0x14	; 20
    bde8:	80 93 56 02 	sts	0x0256, r24
    bdec:	28 c0       	rjmp	.+80     	; 0xbe3e <PrintIdle+0xf66>
	      break;
     case piPaperCut:
	      //sprintf_P(strSend,PSTR("i:%d Copy:%d"),iPrinted,PrintCopy);
		  //_uart_print(0,1,strSend);

          if (iPrinted>=PrintCopy){
    bdee:	90 91 48 02 	lds	r25, 0x0248
    bdf2:	80 91 47 02 	lds	r24, 0x0247
    bdf6:	98 17       	cp	r25, r24
    bdf8:	10 f0       	brcs	.+4      	; 0xbdfe <PrintIdle+0xf26>
		      stPrintIdle=piFinishPrintIdle;
    bdfa:	84 e1       	ldi	r24, 0x14	; 20
    bdfc:	05 c0       	rjmp	.+10     	; 0xbe08 <PrintIdle+0xf30>
			  }
		  else {CarriegeReturn();
    bdfe:	0e 94 3d 4c 	call	0x987a	; 0x987a <CarriegeReturn>
		        CarriegeReturn();
    be02:	0e 94 3d 4c 	call	0x987a	; 0x987a <CarriegeReturn>
		        stPrintIdle=piInit;
    be06:	81 e0       	ldi	r24, 0x01	; 1
    be08:	80 93 56 02 	sts	0x0256, r24
		       }
		  PaperCut();
    be0c:	0e 94 e4 4c 	call	0x99c8	; 0x99c8 <PaperCut>
    be10:	16 c0       	rjmp	.+44     	; 0xbe3e <PrintIdle+0xf66>
	      break;
     case piFinishPrintIdle:	      
	      switch(IFType){
    be12:	80 91 00 01 	lds	r24, 0x0100
    be16:	81 30       	cpi	r24, 0x01	; 1
    be18:	19 f0       	breq	.+6      	; 0xbe20 <PrintIdle+0xf48>
    be1a:	82 30       	cpi	r24, 0x02	; 2
    be1c:	61 f4       	brne	.+24     	; 0xbe36 <PrintIdle+0xf5e>
    be1e:	03 c0       	rjmp	.+6      	; 0xbe26 <PrintIdle+0xf4e>
		  case IT_SLAVE:
		       sendMessage04();
    be20:	0e 94 62 53 	call	0xa6c4	; 0xa6c4 <sendMessage04>
    be24:	08 c0       	rjmp	.+16     	; 0xbe36 <PrintIdle+0xf5e>
		       break;
		  case IT_STANDALONE:
		  
		       UpdateStandaloneStatus((atoi(strFIP_ID)&0x0F),PS_PRINTED);
    be26:	8b ec       	ldi	r24, 0xCB	; 203
    be28:	98 e0       	ldi	r25, 0x08	; 8
    be2a:	0e 94 c3 b3 	call	0x16786	; 0x16786 <atoi>
    be2e:	8f 70       	andi	r24, 0x0F	; 15
    be30:	61 e1       	ldi	r22, 0x11	; 17
    be32:	0e 94 78 1d 	call	0x3af0	; 0x3af0 <UpdateStandaloneStatus>
			   //strPumpStatus[FIPAddr]=GetPumpStatusLabel(PUMP_OFF);			   
			   //IsNewPumpStatus=True;//UpdateDisplay

		       break;
		  }
		  IsBusyIdlePrinting=False;
    be36:	10 92 b4 01 	sts	0x01B4, r1
          stPrintIdle=piIdle;
    be3a:	10 92 56 02 	sts	0x0256, r1
	      break;	 
	 }
}
    be3e:	64 96       	adiw	r28, 0x14	; 20
    be40:	0f b6       	in	r0, 0x3f	; 63
    be42:	f8 94       	cli
    be44:	de bf       	out	0x3e, r29	; 62
    be46:	0f be       	out	0x3f, r0	; 63
    be48:	cd bf       	out	0x3d, r28	; 61
    be4a:	cf 91       	pop	r28
    be4c:	df 91       	pop	r29
    be4e:	1f 91       	pop	r17
    be50:	0f 91       	pop	r16
    be52:	08 95       	ret

0000be54 <systemPrinting>:
     

}

void systemPrinting(){
	 FreePrinting();
    be54:	0e 94 c6 53 	call	0xa78c	; 0xa78c <FreePrinting>
	 PrintIdle();
    be58:	0e 94 6c 57 	call	0xaed8	; 0xaed8 <PrintIdle>
}
    be5c:	08 95       	ret

0000be5e <procMessage11>:
}




void procMessage11(){
    be5e:	af 92       	push	r10
    be60:	bf 92       	push	r11
    be62:	cf 92       	push	r12
    be64:	df 92       	push	r13
    be66:	ef 92       	push	r14
    be68:	ff 92       	push	r15
    be6a:	0f 93       	push	r16
    be6c:	1f 93       	push	r17
    be6e:	df 93       	push	r29
    be70:	cf 93       	push	r28
    be72:	cd b7       	in	r28, 0x3d	; 61
    be74:	de b7       	in	r29, 0x3e	; 62
    be76:	c5 55       	subi	r28, 0x55	; 85
    be78:	d0 40       	sbci	r29, 0x00	; 0
    be7a:	0f b6       	in	r0, 0x3f	; 63
    be7c:	f8 94       	cli
    be7e:	de bf       	out	0x3e, r29	; 62
    be80:	0f be       	out	0x3f, r0	; 63
    be82:	cd bf       	out	0x3d, r28	; 61
    be84:	20 e0       	ldi	r18, 0x00	; 0
    be86:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    be88:	ae 01       	movw	r20, r28
    be8a:	46 5f       	subi	r20, 0xF6	; 246
    be8c:	5f 4f       	sbci	r21, 0xFF	; 255
    be8e:	fa 01       	movw	r30, r20
    be90:	e2 0f       	add	r30, r18
    be92:	f3 1f       	adc	r31, r19
    be94:	d9 01       	movw	r26, r18
    be96:	af 5a       	subi	r26, 0xAF	; 175
    be98:	b5 4f       	sbci	r27, 0xF5	; 245
    be9a:	9b 96       	adiw	r26, 0x2b	; 43
    be9c:	8c 91       	ld	r24, X
    be9e:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bea0:	2f 5f       	subi	r18, 0xFF	; 255
    bea2:	3f 4f       	sbci	r19, 0xFF	; 255
    bea4:	2a 30       	cpi	r18, 0x0A	; 10
    bea6:	31 05       	cpc	r19, r1
    bea8:	91 f7       	brne	.-28     	; 0xbe8e <procMessage11+0x30>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    beaa:	fa 01       	movw	r30, r20
    beac:	12 86       	std	Z+10, r1	; 0x0a
     char buffHeader[41];
	 char strProductName[13],strProductPrice[9],strTime[12],strDate[10];

     //Update Datetime
	 StrPosCopy(rcv_trans,strDate,43,10);//2004/09/14 19:05:36
	 FormatDate(DATE_SHORT_YEAR,strDate);
    beae:	81 e0       	ldi	r24, 0x01	; 1
    beb0:	ba 01       	movw	r22, r20
    beb2:	0e 94 c8 24 	call	0x4990	; 0x4990 <FormatDate>
    beb6:	20 e0       	ldi	r18, 0x00	; 0
    beb8:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    beba:	ae 01       	movw	r20, r28
    bebc:	4c 5e       	subi	r20, 0xEC	; 236
    bebe:	5f 4f       	sbci	r21, 0xFF	; 255
    bec0:	fa 01       	movw	r30, r20
    bec2:	e2 0f       	add	r30, r18
    bec4:	f3 1f       	adc	r31, r19
    bec6:	d9 01       	movw	r26, r18
    bec8:	af 5a       	subi	r26, 0xAF	; 175
    beca:	b5 4f       	sbci	r27, 0xF5	; 245
    becc:	d6 96       	adiw	r26, 0x36	; 54
    bece:	8c 91       	ld	r24, X
    bed0:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bed2:	2f 5f       	subi	r18, 0xFF	; 255
    bed4:	3f 4f       	sbci	r19, 0xFF	; 255
    bed6:	28 30       	cpi	r18, 0x08	; 8
    bed8:	31 05       	cpc	r19, r1
    beda:	91 f7       	brne	.-28     	; 0xbec0 <procMessage11+0x62>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    bedc:	1c 8e       	std	Y+28, r1	; 0x1c

     //Update Datetime
	 StrPosCopy(rcv_trans,strDate,43,10);//2004/09/14 19:05:36
	 FormatDate(DATE_SHORT_YEAR,strDate);
	 StrPosCopy(rcv_trans,strTime,54,8);
	 _datetime(_DATETIME_WRITE,strDate,strTime);
    bede:	81 e0       	ldi	r24, 0x01	; 1
    bee0:	be 01       	movw	r22, r28
    bee2:	66 5f       	subi	r22, 0xF6	; 246
    bee4:	7f 4f       	sbci	r23, 0xFF	; 255
    bee6:	0e 94 4f b1 	call	0x1629e	; 0x1629e <_datetime>
	  
     clearString(buffHeader);
    beea:	8e 01       	movw	r16, r28
    beec:	03 5d       	subi	r16, 0xD3	; 211
    beee:	1f 4f       	sbci	r17, 0xFF	; 255
    bef0:	c8 01       	movw	r24, r16
    bef2:	0e 94 83 26 	call	0x4d06	; 0x4d06 <clearString>
    bef6:	20 e0       	ldi	r18, 0x00	; 0
    bef8:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    befa:	f8 01       	movw	r30, r16
    befc:	e2 0f       	add	r30, r18
    befe:	f3 1f       	adc	r31, r19
    bf00:	d9 01       	movw	r26, r18
    bf02:	af 5a       	subi	r26, 0xAF	; 175
    bf04:	b5 4f       	sbci	r27, 0xF5	; 245
    bf06:	de 96       	adiw	r26, 0x3e	; 62
    bf08:	8c 91       	ld	r24, X
    bf0a:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bf0c:	2f 5f       	subi	r18, 0xFF	; 255
    bf0e:	3f 4f       	sbci	r19, 0xFF	; 255
    bf10:	28 32       	cpi	r18, 0x28	; 40
    bf12:	31 05       	cpc	r19, r1
    bf14:	91 f7       	brne	.-28     	; 0xbefa <procMessage11+0x9c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    bf16:	fe 01       	movw	r30, r28
    bf18:	eb 5a       	subi	r30, 0xAB	; 171
    bf1a:	ff 4f       	sbci	r31, 0xFF	; 255
    bf1c:	10 82       	st	Z, r1
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    bf1e:	87 e2       	ldi	r24, 0x27	; 39
    bf20:	92 e0       	ldi	r25, 0x02	; 2
    bf22:	b8 01       	movw	r22, r16
    bf24:	48 e2       	ldi	r20, 0x28	; 40
    bf26:	50 e0       	ldi	r21, 0x00	; 0
    bf28:	25 e0       	ldi	r18, 0x05	; 5
    bf2a:	33 e1       	ldi	r19, 0x13	; 19
    bf2c:	0e 94 0d b4 	call	0x1681a	; 0x1681a <__eewr_block>
    bf30:	20 e0       	ldi	r18, 0x00	; 0
    bf32:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    bf34:	be 01       	movw	r22, r28
    bf36:	63 5d       	subi	r22, 0xD3	; 211
    bf38:	7f 4f       	sbci	r23, 0xFF	; 255
    bf3a:	fb 01       	movw	r30, r22
    bf3c:	e2 0f       	add	r30, r18
    bf3e:	f3 1f       	adc	r31, r19
    bf40:	d9 01       	movw	r26, r18
    bf42:	a9 54       	subi	r26, 0x49	; 73
    bf44:	b5 4f       	sbci	r27, 0xF5	; 245
    bf46:	8c 91       	ld	r24, X
    bf48:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bf4a:	2f 5f       	subi	r18, 0xFF	; 255
    bf4c:	3f 4f       	sbci	r19, 0xFF	; 255
    bf4e:	28 32       	cpi	r18, 0x28	; 40
    bf50:	31 05       	cpc	r19, r1
    bf52:	99 f7       	brne	.-26     	; 0xbf3a <procMessage11+0xdc>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    bf54:	fe 01       	movw	r30, r28
    bf56:	eb 5a       	subi	r30, 0xAB	; 171
    bf58:	ff 4f       	sbci	r31, 0xFF	; 255
    bf5a:	10 82       	st	Z, r1
    bf5c:	80 e5       	ldi	r24, 0x50	; 80
    bf5e:	92 e0       	ldi	r25, 0x02	; 2
    bf60:	48 e2       	ldi	r20, 0x28	; 40
    bf62:	50 e0       	ldi	r21, 0x00	; 0
    bf64:	25 e0       	ldi	r18, 0x05	; 5
    bf66:	33 e1       	ldi	r19, 0x13	; 19
    bf68:	0e 94 0d b4 	call	0x1681a	; 0x1681a <__eewr_block>
    bf6c:	20 e0       	ldi	r18, 0x00	; 0
    bf6e:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    bf70:	be 01       	movw	r22, r28
    bf72:	63 5d       	subi	r22, 0xD3	; 211
    bf74:	7f 4f       	sbci	r23, 0xFF	; 255
    bf76:	fb 01       	movw	r30, r22
    bf78:	e2 0f       	add	r30, r18
    bf7a:	f3 1f       	adc	r31, r19
    bf7c:	d9 01       	movw	r26, r18
    bf7e:	a1 52       	subi	r26, 0x21	; 33
    bf80:	b5 4f       	sbci	r27, 0xF5	; 245
    bf82:	8c 91       	ld	r24, X
    bf84:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bf86:	2f 5f       	subi	r18, 0xFF	; 255
    bf88:	3f 4f       	sbci	r19, 0xFF	; 255
    bf8a:	28 32       	cpi	r18, 0x28	; 40
    bf8c:	31 05       	cpc	r19, r1
    bf8e:	99 f7       	brne	.-26     	; 0xbf76 <procMessage11+0x118>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    bf90:	fe 01       	movw	r30, r28
    bf92:	eb 5a       	subi	r30, 0xAB	; 171
    bf94:	ff 4f       	sbci	r31, 0xFF	; 255
    bf96:	10 82       	st	Z, r1
    bf98:	89 e7       	ldi	r24, 0x79	; 121
    bf9a:	92 e0       	ldi	r25, 0x02	; 2
    bf9c:	48 e2       	ldi	r20, 0x28	; 40
    bf9e:	50 e0       	ldi	r21, 0x00	; 0
    bfa0:	25 e0       	ldi	r18, 0x05	; 5
    bfa2:	33 e1       	ldi	r19, 0x13	; 19
    bfa4:	0e 94 0d b4 	call	0x1681a	; 0x1681a <__eewr_block>
    bfa8:	20 e0       	ldi	r18, 0x00	; 0
    bfaa:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    bfac:	be 01       	movw	r22, r28
    bfae:	63 5d       	subi	r22, 0xD3	; 211
    bfb0:	7f 4f       	sbci	r23, 0xFF	; 255
    bfb2:	fb 01       	movw	r30, r22
    bfb4:	e2 0f       	add	r30, r18
    bfb6:	f3 1f       	adc	r31, r19
    bfb8:	d9 01       	movw	r26, r18
    bfba:	a9 5f       	subi	r26, 0xF9	; 249
    bfbc:	b4 4f       	sbci	r27, 0xF4	; 244
    bfbe:	8c 91       	ld	r24, X
    bfc0:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bfc2:	2f 5f       	subi	r18, 0xFF	; 255
    bfc4:	3f 4f       	sbci	r19, 0xFF	; 255
    bfc6:	28 32       	cpi	r18, 0x28	; 40
    bfc8:	31 05       	cpc	r19, r1
    bfca:	99 f7       	brne	.-26     	; 0xbfb2 <procMessage11+0x154>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    bfcc:	fe 01       	movw	r30, r28
    bfce:	eb 5a       	subi	r30, 0xAB	; 171
    bfd0:	ff 4f       	sbci	r31, 0xFF	; 255
    bfd2:	10 82       	st	Z, r1
    bfd4:	82 ea       	ldi	r24, 0xA2	; 162
    bfd6:	92 e0       	ldi	r25, 0x02	; 2
    bfd8:	48 e2       	ldi	r20, 0x28	; 40
    bfda:	50 e0       	ldi	r21, 0x00	; 0
    bfdc:	25 e0       	ldi	r18, 0x05	; 5
    bfde:	33 e1       	ldi	r19, 0x13	; 19
    bfe0:	0e 94 0d b4 	call	0x1681a	; 0x1681a <__eewr_block>
    bfe4:	20 e0       	ldi	r18, 0x00	; 0
    bfe6:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    bfe8:	be 01       	movw	r22, r28
    bfea:	63 5d       	subi	r22, 0xD3	; 211
    bfec:	7f 4f       	sbci	r23, 0xFF	; 255
    bfee:	fb 01       	movw	r30, r22
    bff0:	e2 0f       	add	r30, r18
    bff2:	f3 1f       	adc	r31, r19
    bff4:	d9 01       	movw	r26, r18
    bff6:	a1 5d       	subi	r26, 0xD1	; 209
    bff8:	b4 4f       	sbci	r27, 0xF4	; 244
    bffa:	8c 91       	ld	r24, X
    bffc:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bffe:	2f 5f       	subi	r18, 0xFF	; 255
    c000:	3f 4f       	sbci	r19, 0xFF	; 255
    c002:	28 32       	cpi	r18, 0x28	; 40
    c004:	31 05       	cpc	r19, r1
    c006:	99 f7       	brne	.-26     	; 0xbfee <procMessage11+0x190>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    c008:	fe 01       	movw	r30, r28
    c00a:	eb 5a       	subi	r30, 0xAB	; 171
    c00c:	ff 4f       	sbci	r31, 0xFF	; 255
    c00e:	10 82       	st	Z, r1
    c010:	8b ec       	ldi	r24, 0xCB	; 203
    c012:	92 e0       	ldi	r25, 0x02	; 2
    c014:	48 e2       	ldi	r20, 0x28	; 40
    c016:	50 e0       	ldi	r21, 0x00	; 0
    c018:	25 e0       	ldi	r18, 0x05	; 5
    c01a:	33 e1       	ldi	r19, 0x13	; 19
    c01c:	0e 94 0d b4 	call	0x1681a	; 0x1681a <__eewr_block>
    c020:	20 e0       	ldi	r18, 0x00	; 0
    c022:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    c024:	be 01       	movw	r22, r28
    c026:	63 5d       	subi	r22, 0xD3	; 211
    c028:	7f 4f       	sbci	r23, 0xFF	; 255
    c02a:	fb 01       	movw	r30, r22
    c02c:	e2 0f       	add	r30, r18
    c02e:	f3 1f       	adc	r31, r19
    c030:	d9 01       	movw	r26, r18
    c032:	a9 5a       	subi	r26, 0xA9	; 169
    c034:	b4 4f       	sbci	r27, 0xF4	; 244
    c036:	8c 91       	ld	r24, X
    c038:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    c03a:	2f 5f       	subi	r18, 0xFF	; 255
    c03c:	3f 4f       	sbci	r19, 0xFF	; 255
    c03e:	28 32       	cpi	r18, 0x28	; 40
    c040:	31 05       	cpc	r19, r1
    c042:	99 f7       	brne	.-26     	; 0xc02a <procMessage11+0x1cc>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    c044:	fe 01       	movw	r30, r28
    c046:	eb 5a       	subi	r30, 0xAB	; 171
    c048:	ff 4f       	sbci	r31, 0xFF	; 255
    c04a:	10 82       	st	Z, r1
    c04c:	84 ef       	ldi	r24, 0xF4	; 244
    c04e:	92 e0       	ldi	r25, 0x02	; 2
    c050:	48 e2       	ldi	r20, 0x28	; 40
    c052:	50 e0       	ldi	r21, 0x00	; 0
    c054:	25 e0       	ldi	r18, 0x05	; 5
    c056:	33 e1       	ldi	r19, 0x13	; 19
    c058:	0e 94 0d b4 	call	0x1681a	; 0x1681a <__eewr_block>
    c05c:	20 e0       	ldi	r18, 0x00	; 0
    c05e:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    c060:	be 01       	movw	r22, r28
    c062:	63 5d       	subi	r22, 0xD3	; 211
    c064:	7f 4f       	sbci	r23, 0xFF	; 255
    c066:	fb 01       	movw	r30, r22
    c068:	e2 0f       	add	r30, r18
    c06a:	f3 1f       	adc	r31, r19
    c06c:	d9 01       	movw	r26, r18
    c06e:	a1 58       	subi	r26, 0x81	; 129
    c070:	b4 4f       	sbci	r27, 0xF4	; 244
    c072:	8c 91       	ld	r24, X
    c074:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    c076:	2f 5f       	subi	r18, 0xFF	; 255
    c078:	3f 4f       	sbci	r19, 0xFF	; 255
    c07a:	28 32       	cpi	r18, 0x28	; 40
    c07c:	31 05       	cpc	r19, r1
    c07e:	99 f7       	brne	.-26     	; 0xc066 <procMessage11+0x208>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    c080:	fe 01       	movw	r30, r28
    c082:	eb 5a       	subi	r30, 0xAB	; 171
    c084:	ff 4f       	sbci	r31, 0xFF	; 255
    c086:	10 82       	st	Z, r1
    c088:	8d e1       	ldi	r24, 0x1D	; 29
    c08a:	93 e0       	ldi	r25, 0x03	; 3
    c08c:	48 e2       	ldi	r20, 0x28	; 40
    c08e:	50 e0       	ldi	r21, 0x00	; 0
    c090:	25 e0       	ldi	r18, 0x05	; 5
    c092:	33 e1       	ldi	r19, 0x13	; 19
    c094:	0e 94 0d b4 	call	0x1681a	; 0x1681a <__eewr_block>
    c098:	20 e0       	ldi	r18, 0x00	; 0
    c09a:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    c09c:	be 01       	movw	r22, r28
    c09e:	63 5d       	subi	r22, 0xD3	; 211
    c0a0:	7f 4f       	sbci	r23, 0xFF	; 255
    c0a2:	fb 01       	movw	r30, r22
    c0a4:	e2 0f       	add	r30, r18
    c0a6:	f3 1f       	adc	r31, r19
    c0a8:	d9 01       	movw	r26, r18
    c0aa:	a9 55       	subi	r26, 0x59	; 89
    c0ac:	b4 4f       	sbci	r27, 0xF4	; 244
    c0ae:	8c 91       	ld	r24, X
    c0b0:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    c0b2:	2f 5f       	subi	r18, 0xFF	; 255
    c0b4:	3f 4f       	sbci	r19, 0xFF	; 255
    c0b6:	28 32       	cpi	r18, 0x28	; 40
    c0b8:	31 05       	cpc	r19, r1
    c0ba:	99 f7       	brne	.-26     	; 0xc0a2 <procMessage11+0x244>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    c0bc:	fe 01       	movw	r30, r28
    c0be:	eb 5a       	subi	r30, 0xAB	; 171
    c0c0:	ff 4f       	sbci	r31, 0xFF	; 255
    c0c2:	10 82       	st	Z, r1
    c0c4:	86 e4       	ldi	r24, 0x46	; 70
    c0c6:	93 e0       	ldi	r25, 0x03	; 3
    c0c8:	48 e2       	ldi	r20, 0x28	; 40
    c0ca:	50 e0       	ldi	r21, 0x00	; 0
    c0cc:	25 e0       	ldi	r18, 0x05	; 5
    c0ce:	33 e1       	ldi	r19, 0x13	; 19
    c0d0:	0e 94 0d b4 	call	0x1681a	; 0x1681a <__eewr_block>
    c0d4:	20 e0       	ldi	r18, 0x00	; 0
    c0d6:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    c0d8:	be 01       	movw	r22, r28
    c0da:	63 5d       	subi	r22, 0xD3	; 211
    c0dc:	7f 4f       	sbci	r23, 0xFF	; 255
    c0de:	fb 01       	movw	r30, r22
    c0e0:	e2 0f       	add	r30, r18
    c0e2:	f3 1f       	adc	r31, r19
    c0e4:	d9 01       	movw	r26, r18
    c0e6:	a1 53       	subi	r26, 0x31	; 49
    c0e8:	b4 4f       	sbci	r27, 0xF4	; 244
    c0ea:	8c 91       	ld	r24, X
    c0ec:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    c0ee:	2f 5f       	subi	r18, 0xFF	; 255
    c0f0:	3f 4f       	sbci	r19, 0xFF	; 255
    c0f2:	28 32       	cpi	r18, 0x28	; 40
    c0f4:	31 05       	cpc	r19, r1
    c0f6:	99 f7       	brne	.-26     	; 0xc0de <procMessage11+0x280>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    c0f8:	fe 01       	movw	r30, r28
    c0fa:	eb 5a       	subi	r30, 0xAB	; 171
    c0fc:	ff 4f       	sbci	r31, 0xFF	; 255
    c0fe:	10 82       	st	Z, r1
    c100:	8f e6       	ldi	r24, 0x6F	; 111
    c102:	93 e0       	ldi	r25, 0x03	; 3
    c104:	48 e2       	ldi	r20, 0x28	; 40
    c106:	50 e0       	ldi	r21, 0x00	; 0
    c108:	25 e0       	ldi	r18, 0x05	; 5
    c10a:	33 e1       	ldi	r19, 0x13	; 19
    c10c:	0e 94 0d b4 	call	0x1681a	; 0x1681a <__eewr_block>
    c110:	20 e0       	ldi	r18, 0x00	; 0
    c112:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    c114:	be 01       	movw	r22, r28
    c116:	63 5d       	subi	r22, 0xD3	; 211
    c118:	7f 4f       	sbci	r23, 0xFF	; 255
    c11a:	fb 01       	movw	r30, r22
    c11c:	e2 0f       	add	r30, r18
    c11e:	f3 1f       	adc	r31, r19
    c120:	d9 01       	movw	r26, r18
    c122:	a9 50       	subi	r26, 0x09	; 9
    c124:	b4 4f       	sbci	r27, 0xF4	; 244
    c126:	8c 91       	ld	r24, X
    c128:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    c12a:	2f 5f       	subi	r18, 0xFF	; 255
    c12c:	3f 4f       	sbci	r19, 0xFF	; 255
    c12e:	28 32       	cpi	r18, 0x28	; 40
    c130:	31 05       	cpc	r19, r1
    c132:	99 f7       	brne	.-26     	; 0xc11a <procMessage11+0x2bc>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    c134:	fe 01       	movw	r30, r28
    c136:	eb 5a       	subi	r30, 0xAB	; 171
    c138:	ff 4f       	sbci	r31, 0xFF	; 255
    c13a:	10 82       	st	Z, r1
    c13c:	88 e9       	ldi	r24, 0x98	; 152
    c13e:	93 e0       	ldi	r25, 0x03	; 3
    c140:	48 e2       	ldi	r20, 0x28	; 40
    c142:	50 e0       	ldi	r21, 0x00	; 0
    c144:	25 e0       	ldi	r18, 0x05	; 5
    c146:	33 e1       	ldi	r19, 0x13	; 19
    c148:	0e 94 0d b4 	call	0x1681a	; 0x1681a <__eewr_block>
    c14c:	0b eb       	ldi	r16, 0xBB	; 187
    c14e:	10 e0       	ldi	r17, 0x00	; 0
    c150:	97 e3       	ldi	r25, 0x37	; 55
    c152:	e9 2e       	mov	r14, r25
    c154:	9c e0       	ldi	r25, 0x0C	; 12
    c156:	f9 2e       	mov	r15, r25
    c158:	80 e2       	ldi	r24, 0x20	; 32
    c15a:	c8 2e       	mov	r12, r24
    c15c:	d1 2c       	mov	r13, r1
    c15e:	cc 0e       	add	r12, r28
    c160:	dd 1e       	adc	r13, r29
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    c162:	bc e2       	ldi	r27, 0x2C	; 44
    c164:	ab 2e       	mov	r10, r27
    c166:	b1 2c       	mov	r11, r1
    c168:	ac 0e       	add	r10, r28
    c16a:	bd 1e       	adc	r11, r29
    c16c:	f6 01       	movw	r30, r12
    c16e:	d7 01       	movw	r26, r14
	    Dest[i]=Source[IdxSource+i];
    c170:	8d 91       	ld	r24, X+
    c172:	81 93       	st	Z+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    c174:	ea 15       	cp	r30, r10
    c176:	fb 05       	cpc	r31, r11
    c178:	d9 f7       	brne	.-10     	; 0xc170 <procMessage11+0x312>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    c17a:	1c a6       	std	Y+44, r1	; 0x2c
     StrPosCopy(rcv_trans,buffHeader,422,40);
     eeprom_write_block((const void*) &buffHeader, (void*) &DefHeaderFooter[9], 40);
	 //ProductName
	 for(i=0;i<6;i++){
	    StrPosCopy(rcv_trans,strProductName,(486+(i*12)),12);
		RemSpaceLag(strProductName);
    c17c:	c6 01       	movw	r24, r12
    c17e:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <RemSpaceLag>
    c182:	c8 01       	movw	r24, r16
    c184:	b6 01       	movw	r22, r12
    c186:	4c e0       	ldi	r20, 0x0C	; 12
    c188:	50 e0       	ldi	r21, 0x00	; 0
    c18a:	25 e0       	ldi	r18, 0x05	; 5
    c18c:	33 e1       	ldi	r19, 0x13	; 19
    c18e:	0e 94 0d b4 	call	0x1681a	; 0x1681a <__eewr_block>
    c192:	03 5f       	subi	r16, 0xF3	; 243
    c194:	1f 4f       	sbci	r17, 0xFF	; 255
    c196:	8c e0       	ldi	r24, 0x0C	; 12
    c198:	90 e0       	ldi	r25, 0x00	; 0
    c19a:	e8 0e       	add	r14, r24
    c19c:	f9 1e       	adc	r15, r25
     StrPosCopy(rcv_trans,buffHeader,382,40);
     eeprom_write_block((const void*) &buffHeader, (void*) &DefHeaderFooter[8], 40);
     StrPosCopy(rcv_trans,buffHeader,422,40);
     eeprom_write_block((const void*) &buffHeader, (void*) &DefHeaderFooter[9], 40);
	 //ProductName
	 for(i=0;i<6;i++){
    c19e:	91 e0       	ldi	r25, 0x01	; 1
    c1a0:	09 30       	cpi	r16, 0x09	; 9
    c1a2:	19 07       	cpc	r17, r25
    c1a4:	19 f7       	brne	.-58     	; 0xc16c <procMessage11+0x30e>
    c1a6:	05 e8       	ldi	r16, 0x85	; 133
    c1a8:	10 e0       	ldi	r17, 0x00	; 0
    c1aa:	af e7       	ldi	r26, 0x7F	; 127
    c1ac:	ea 2e       	mov	r14, r26
    c1ae:	ac e0       	ldi	r26, 0x0C	; 12
    c1b0:	fa 2e       	mov	r15, r26
    c1b2:	6e 01       	movw	r12, r28
    c1b4:	08 94       	sec
    c1b6:	c1 1c       	adc	r12, r1
    c1b8:	d1 1c       	adc	r13, r1
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    c1ba:	f9 e0       	ldi	r31, 0x09	; 9
    c1bc:	af 2e       	mov	r10, r31
    c1be:	b1 2c       	mov	r11, r1
    c1c0:	ac 0e       	add	r10, r28
    c1c2:	bd 1e       	adc	r11, r29
     StrPosCopy(rcv_trans,buffHeader,382,40);
     eeprom_write_block((const void*) &buffHeader, (void*) &DefHeaderFooter[8], 40);
     StrPosCopy(rcv_trans,buffHeader,422,40);
     eeprom_write_block((const void*) &buffHeader, (void*) &DefHeaderFooter[9], 40);
	 //ProductName
	 for(i=0;i<6;i++){
    c1c4:	f6 01       	movw	r30, r12
    c1c6:	d7 01       	movw	r26, r14
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    c1c8:	8d 91       	ld	r24, X+
    c1ca:	81 93       	st	Z+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    c1cc:	ea 15       	cp	r30, r10
    c1ce:	fb 05       	cpc	r31, r11
    c1d0:	d9 f7       	brne	.-10     	; 0xc1c8 <procMessage11+0x36a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    c1d2:	19 86       	std	Y+9, r1	; 0x09
        eeprom_write_block((const void*) &strProductName, (void*) &DefProductName[i], 12);
	 }
	 //ProductPrice
	 for(i=0;i<6;i++){
        StrPosCopy(rcv_trans,strProductPrice,(558+(i*8)),8);
		RemSpaceLag(strProductPrice);
    c1d4:	c6 01       	movw	r24, r12
    c1d6:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <RemSpaceLag>
		RemZeroLead(strProductPrice);
    c1da:	c6 01       	movw	r24, r12
    c1dc:	0e 94 19 25 	call	0x4a32	; 0x4a32 <RemZeroLead>
		RemDecimal(strProductPrice);
    c1e0:	c6 01       	movw	r24, r12
    c1e2:	0e 94 11 24 	call	0x4822	; 0x4822 <RemDecimal>
    c1e6:	c8 01       	movw	r24, r16
    c1e8:	b6 01       	movw	r22, r12
    c1ea:	48 e0       	ldi	r20, 0x08	; 8
    c1ec:	50 e0       	ldi	r21, 0x00	; 0
    c1ee:	25 e0       	ldi	r18, 0x05	; 5
    c1f0:	33 e1       	ldi	r19, 0x13	; 19
    c1f2:	0e 94 0d b4 	call	0x1681a	; 0x1681a <__eewr_block>
    c1f6:	07 5f       	subi	r16, 0xF7	; 247
    c1f8:	1f 4f       	sbci	r17, 0xFF	; 255
    c1fa:	e8 e0       	ldi	r30, 0x08	; 8
    c1fc:	f0 e0       	ldi	r31, 0x00	; 0
    c1fe:	ee 0e       	add	r14, r30
    c200:	ff 1e       	adc	r15, r31
	    StrPosCopy(rcv_trans,strProductName,(486+(i*12)),12);
		RemSpaceLag(strProductName);
        eeprom_write_block((const void*) &strProductName, (void*) &DefProductName[i], 12);
	 }
	 //ProductPrice
	 for(i=0;i<6;i++){
    c202:	f0 e0       	ldi	r31, 0x00	; 0
    c204:	0b 3b       	cpi	r16, 0xBB	; 187
    c206:	1f 07       	cpc	r17, r31
    c208:	e9 f6       	brne	.-70     	; 0xc1c4 <procMessage11+0x366>
		RemSpaceLag(strProductPrice);
		RemZeroLead(strProductPrice);
		RemDecimal(strProductPrice);
        eeprom_write_block((const void*) &strProductPrice, (void*) &DefProductPrice[i], 8);
	 }
}
    c20a:	cb 5a       	subi	r28, 0xAB	; 171
    c20c:	df 4f       	sbci	r29, 0xFF	; 255
    c20e:	0f b6       	in	r0, 0x3f	; 63
    c210:	f8 94       	cli
    c212:	de bf       	out	0x3e, r29	; 62
    c214:	0f be       	out	0x3f, r0	; 63
    c216:	cd bf       	out	0x3d, r28	; 61
    c218:	cf 91       	pop	r28
    c21a:	df 91       	pop	r29
    c21c:	1f 91       	pop	r17
    c21e:	0f 91       	pop	r16
    c220:	ff 90       	pop	r15
    c222:	ef 90       	pop	r14
    c224:	df 90       	pop	r13
    c226:	cf 90       	pop	r12
    c228:	bf 90       	pop	r11
    c22a:	af 90       	pop	r10
    c22c:	08 95       	ret

0000c22e <FCloseShift>:
	 }
  return Result;
}


char FCloseShift(char ShiftType){//SHIFT_NONE,NEW_SHIFT,CONTINUE_SHIFT
    c22e:	df 92       	push	r13
    c230:	ef 92       	push	r14
    c232:	ff 92       	push	r15
    c234:	0f 93       	push	r16
    c236:	1f 93       	push	r17
    c238:	df 93       	push	r29
    c23a:	cf 93       	push	r28
    c23c:	cd b7       	in	r28, 0x3d	; 61
    c23e:	de b7       	in	r29, 0x3e	; 62
    c240:	64 97       	sbiw	r28, 0x14	; 20
    c242:	0f b6       	in	r0, 0x3f	; 63
    c244:	f8 94       	cli
    c246:	de bf       	out	0x3e, r29	; 62
    c248:	0f be       	out	0x3f, r0	; 63
    c24a:	cd bf       	out	0x3d, r28	; 61
    c24c:	18 2f       	mov	r17, r24
	 char KeyPressed;
	 char FIPAddr;


	 Result=MENU_NONE;
	 switch(stCloseShift){
    c24e:	80 91 9a 02 	lds	r24, 0x029A
    c252:	87 30       	cpi	r24, 0x07	; 7
    c254:	09 f4       	brne	.+2      	; 0xc258 <FCloseShift+0x2a>
    c256:	a0 c1       	rjmp	.+832    	; 0xc598 <FCloseShift+0x36a>
    c258:	88 30       	cpi	r24, 0x08	; 8
    c25a:	78 f4       	brcc	.+30     	; 0xc27a <FCloseShift+0x4c>
    c25c:	84 30       	cpi	r24, 0x04	; 4
    c25e:	09 f4       	brne	.+2      	; 0xc262 <FCloseShift+0x34>
    c260:	68 c0       	rjmp	.+208    	; 0xc332 <FCloseShift+0x104>
    c262:	85 30       	cpi	r24, 0x05	; 5
    c264:	18 f4       	brcc	.+6      	; 0xc26c <FCloseShift+0x3e>
    c266:	88 23       	and	r24, r24
    c268:	c1 f0       	breq	.+48     	; 0xc29a <FCloseShift+0x6c>
    c26a:	1c c2       	rjmp	.+1080   	; 0xc6a4 <FCloseShift+0x476>
    c26c:	85 30       	cpi	r24, 0x05	; 5
    c26e:	09 f4       	brne	.+2      	; 0xc272 <FCloseShift+0x44>
    c270:	a6 c0       	rjmp	.+332    	; 0xc3be <FCloseShift+0x190>
    c272:	86 30       	cpi	r24, 0x06	; 6
    c274:	09 f0       	breq	.+2      	; 0xc278 <FCloseShift+0x4a>
    c276:	16 c2       	rjmp	.+1068   	; 0xc6a4 <FCloseShift+0x476>
    c278:	a8 c0       	rjmp	.+336    	; 0xc3ca <FCloseShift+0x19c>
    c27a:	8a 30       	cpi	r24, 0x0A	; 10
    c27c:	09 f4       	brne	.+2      	; 0xc280 <FCloseShift+0x52>
    c27e:	d0 c1       	rjmp	.+928    	; 0xc620 <FCloseShift+0x3f2>
    c280:	8b 30       	cpi	r24, 0x0B	; 11
    c282:	20 f4       	brcc	.+8      	; 0xc28c <FCloseShift+0x5e>
    c284:	88 30       	cpi	r24, 0x08	; 8
    c286:	09 f0       	breq	.+2      	; 0xc28a <FCloseShift+0x5c>
    c288:	0d c2       	rjmp	.+1050   	; 0xc6a4 <FCloseShift+0x476>
    c28a:	8c c1       	rjmp	.+792    	; 0xc5a4 <FCloseShift+0x376>
    c28c:	8b 30       	cpi	r24, 0x0B	; 11
    c28e:	09 f4       	brne	.+2      	; 0xc292 <FCloseShift+0x64>
    c290:	05 c2       	rjmp	.+1034   	; 0xc69c <FCloseShift+0x46e>
    c292:	8c 30       	cpi	r24, 0x0C	; 12
    c294:	09 f0       	breq	.+2      	; 0xc298 <FCloseShift+0x6a>
    c296:	06 c2       	rjmp	.+1036   	; 0xc6a4 <FCloseShift+0x476>
    c298:	cc c1       	rjmp	.+920    	; 0xc632 <FCloseShift+0x404>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    c29a:	e1 99       	sbic	0x1c, 1	; 28
    c29c:	fe cf       	rjmp	.-4      	; 0xc29a <FCloseShift+0x6c>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    c29e:	89 e4       	ldi	r24, 0x49	; 73
    c2a0:	91 e0       	ldi	r25, 0x01	; 1
    c2a2:	9f bb       	out	0x1f, r25	; 31
    c2a4:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    c2a6:	e0 9a       	sbi	0x1c, 0	; 28
    c2a8:	8d b3       	in	r24, 0x1d	; 29
	 case csInitCloseShift:
	      ActivePump=eeprom_read_byte(&DefActivePump);
    c2aa:	80 93 50 01 	sts	0x0150, r24
		  IsPumpBusy=False;
    c2ae:	10 92 99 02 	sts	0x0299, r1
    c2b2:	ff 24       	eor	r15, r15
					
		       if (strPumpStatus[FIPAddr]==GetPumpStatusLabel(PS_TOTALIZER))
			        UpdateStandaloneStatus(GetPumpID(FIPAddr),PUMP_OFF);
					
               if (strPumpStatus[FIPAddr]==GetPumpStatusLabel(PUMP_BUSY))
			       IsPumpBusy=True;
    c2b4:	dd 24       	eor	r13, r13
    c2b6:	d3 94       	inc	r13
    c2b8:	36 c0       	rjmp	.+108    	; 0xc326 <FCloseShift+0xf8>
	 case csInitCloseShift:
	      ActivePump=eeprom_read_byte(&DefActivePump);
		  IsPumpBusy=False;
		  //FindBusy Pump
		  for (FIPAddr=0;FIPAddr<ActivePump;FIPAddr++){		       
		       if ((strPumpStatus[FIPAddr]!=GetPumpStatusLabel(PUMP_NONE))&&(strPumpStatus[FIPAddr]!=GetPumpStatusLabel(PUMP_OFF))&&(strPumpStatus[FIPAddr]!=GetPumpStatusLabel(PUMP_BUSY)))
    c2ba:	0f 2d       	mov	r16, r15
    c2bc:	10 e0       	ldi	r17, 0x00	; 0
    c2be:	f8 01       	movw	r30, r16
    c2c0:	ee 5f       	subi	r30, 0xFE	; 254
    c2c2:	fe 4f       	sbci	r31, 0xFE	; 254
    c2c4:	e0 80       	ld	r14, Z
    c2c6:	8e e0       	ldi	r24, 0x0E	; 14
    c2c8:	0e 94 7d 13 	call	0x26fa	; 0x26fa <GetPumpStatusLabel>
    c2cc:	e8 16       	cp	r14, r24
    c2ce:	81 f0       	breq	.+32     	; 0xc2f0 <FCloseShift+0xc2>
    c2d0:	86 e0       	ldi	r24, 0x06	; 6
    c2d2:	0e 94 7d 13 	call	0x26fa	; 0x26fa <GetPumpStatusLabel>
    c2d6:	e8 16       	cp	r14, r24
    c2d8:	59 f0       	breq	.+22     	; 0xc2f0 <FCloseShift+0xc2>
    c2da:	89 e0       	ldi	r24, 0x09	; 9
    c2dc:	0e 94 7d 13 	call	0x26fa	; 0x26fa <GetPumpStatusLabel>
    c2e0:	e8 16       	cp	r14, r24
    c2e2:	31 f0       	breq	.+12     	; 0xc2f0 <FCloseShift+0xc2>
				    UpdateStandaloneStatus(GetPumpID(FIPAddr),PUMP_OFF);
    c2e4:	8f 2d       	mov	r24, r15
    c2e6:	0e 94 d6 1d 	call	0x3bac	; 0x3bac <GetPumpID>
    c2ea:	66 e0       	ldi	r22, 0x06	; 6
    c2ec:	0e 94 78 1d 	call	0x3af0	; 0x3af0 <UpdateStandaloneStatus>
					
		       if (strPumpStatus[FIPAddr]==GetPumpStatusLabel(PS_TOTALIZER))
    c2f0:	84 e1       	ldi	r24, 0x14	; 20
    c2f2:	0e 94 7d 13 	call	0x26fa	; 0x26fa <GetPumpStatusLabel>
    c2f6:	f8 01       	movw	r30, r16
    c2f8:	ee 5f       	subi	r30, 0xFE	; 254
    c2fa:	fe 4f       	sbci	r31, 0xFE	; 254
    c2fc:	90 81       	ld	r25, Z
    c2fe:	98 17       	cp	r25, r24
    c300:	31 f4       	brne	.+12     	; 0xc30e <FCloseShift+0xe0>
			        UpdateStandaloneStatus(GetPumpID(FIPAddr),PUMP_OFF);
    c302:	8f 2d       	mov	r24, r15
    c304:	0e 94 d6 1d 	call	0x3bac	; 0x3bac <GetPumpID>
    c308:	66 e0       	ldi	r22, 0x06	; 6
    c30a:	0e 94 78 1d 	call	0x3af0	; 0x3af0 <UpdateStandaloneStatus>
					
               if (strPumpStatus[FIPAddr]==GetPumpStatusLabel(PUMP_BUSY))
    c30e:	89 e0       	ldi	r24, 0x09	; 9
    c310:	0e 94 7d 13 	call	0x26fa	; 0x26fa <GetPumpStatusLabel>
    c314:	0e 5f       	subi	r16, 0xFE	; 254
    c316:	1e 4f       	sbci	r17, 0xFE	; 254
    c318:	d8 01       	movw	r26, r16
    c31a:	9c 91       	ld	r25, X
    c31c:	98 17       	cp	r25, r24
    c31e:	11 f4       	brne	.+4      	; 0xc324 <FCloseShift+0xf6>
			       IsPumpBusy=True;
    c320:	d0 92 99 02 	sts	0x0299, r13
	 switch(stCloseShift){
	 case csInitCloseShift:
	      ActivePump=eeprom_read_byte(&DefActivePump);
		  IsPumpBusy=False;
		  //FindBusy Pump
		  for (FIPAddr=0;FIPAddr<ActivePump;FIPAddr++){		       
    c324:	f3 94       	inc	r15
    c326:	80 91 50 01 	lds	r24, 0x0150
    c32a:	f8 16       	cp	r15, r24
    c32c:	30 f2       	brcs	.-116    	; 0xc2ba <FCloseShift+0x8c>
					
               if (strPumpStatus[FIPAddr]==GetPumpStatusLabel(PUMP_BUSY))
			       IsPumpBusy=True;
			   }

          stCloseShift=csSendTotalizerALL;
    c32e:	84 e0       	ldi	r24, 0x04	; 4
    c330:	b2 c1       	rjmp	.+868    	; 0xc696 <FCloseShift+0x468>
			  */
	      break;
     case csWaitPumpLocked:	     
	      break;
     case csSendTotalizerALL:
	      lcd_clear();
    c332:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
		  lcd_printf(1,1,PSTR("Totalizer.."));
    c336:	81 e0       	ldi	r24, 0x01	; 1
    c338:	61 e0       	ldi	r22, 0x01	; 1
    c33a:	48 ed       	ldi	r20, 0xD8	; 216
    c33c:	55 e1       	ldi	r21, 0x15	; 21
    c33e:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		  
		  sprintf_P(lcdteks,PSTR("Wait Pump:%d "),(ActivePump-CountTotalizerSatus(strPumpStatus)));
    c342:	00 91 50 01 	lds	r16, 0x0150
    c346:	10 e0       	ldi	r17, 0x00	; 0
    c348:	82 e0       	ldi	r24, 0x02	; 2
    c34a:	91 e0       	ldi	r25, 0x01	; 1
    c34c:	0e 94 4c 30 	call	0x6098	; 0x6098 <CountTotalizerSatus>
    c350:	00 d0       	rcall	.+0      	; 0xc352 <FCloseShift+0x124>
    c352:	00 d0       	rcall	.+0      	; 0xc354 <FCloseShift+0x126>
    c354:	00 d0       	rcall	.+0      	; 0xc356 <FCloseShift+0x128>
    c356:	ed b7       	in	r30, 0x3d	; 61
    c358:	fe b7       	in	r31, 0x3e	; 62
    c35a:	31 96       	adiw	r30, 0x01	; 1
    c35c:	7e 01       	movw	r14, r28
    c35e:	08 94       	sec
    c360:	e1 1c       	adc	r14, r1
    c362:	f1 1c       	adc	r15, r1
    c364:	ad b7       	in	r26, 0x3d	; 61
    c366:	be b7       	in	r27, 0x3e	; 62
    c368:	12 96       	adiw	r26, 0x02	; 2
    c36a:	fc 92       	st	X, r15
    c36c:	ee 92       	st	-X, r14
    c36e:	11 97       	sbiw	r26, 0x01	; 1
    c370:	2a ec       	ldi	r18, 0xCA	; 202
    c372:	35 e1       	ldi	r19, 0x15	; 21
    c374:	33 83       	std	Z+3, r19	; 0x03
    c376:	22 83       	std	Z+2, r18	; 0x02
    c378:	08 1b       	sub	r16, r24
    c37a:	11 09       	sbc	r17, r1
    c37c:	15 83       	std	Z+5, r17	; 0x05
    c37e:	04 83       	std	Z+4, r16	; 0x04
    c380:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
		  lcd_print(2,1,lcdteks);
    c384:	ed b7       	in	r30, 0x3d	; 61
    c386:	fe b7       	in	r31, 0x3e	; 62
    c388:	36 96       	adiw	r30, 0x06	; 6
    c38a:	0f b6       	in	r0, 0x3f	; 63
    c38c:	f8 94       	cli
    c38e:	fe bf       	out	0x3e, r31	; 62
    c390:	0f be       	out	0x3f, r0	; 63
    c392:	ed bf       	out	0x3d, r30	; 61
    c394:	82 e0       	ldi	r24, 0x02	; 2
    c396:	61 e0       	ldi	r22, 0x01	; 1
    c398:	a7 01       	movw	r20, r14
    c39a:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>


          IsNewPumpStatus=True;
    c39e:	11 e0       	ldi	r17, 0x01	; 1
    c3a0:	10 93 01 01 	sts	0x0101, r17
		  DisplayPumpStatus(); 
    c3a4:	0e 94 97 44 	call	0x892e	; 0x892e <DisplayPumpStatus>
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    c3a8:	95 e0       	ldi	r25, 0x05	; 5
    c3aa:	90 93 b9 06 	sts	0x06B9, r25
	 PoolMsg=plMsg;
    c3ae:	82 e1       	ldi	r24, 0x12	; 18
    c3b0:	80 93 0a 0d 	sts	0x0D0A, r24
     IsControlPooling=True;
    c3b4:	10 93 87 01 	sts	0x0187, r17
          IsNewPumpStatus=True;
		  DisplayPumpStatus(); 
		  //SendCommand
	      //SendSlaveCommand(SC_TOTALIZER,PUMP_ALL);          
		  SendPoolingCommand(SC_TOTALIZER,PUMP_ALL);
		  stCloseShift=csDisplayPumpStatus;
    c3b8:	90 93 9a 02 	sts	0x029A, r25
    c3bc:	73 c1       	rjmp	.+742    	; 0xc6a4 <FCloseShift+0x476>
	      break;
     case csDisplayPumpStatus:
		  DisplayPumpStatus(); 
    c3be:	0e 94 97 44 	call	0x892e	; 0x892e <DisplayPumpStatus>
		  TimDisplay=0;         
    c3c2:	10 92 95 01 	sts	0x0195, r1
          stCloseShift=csWaitTotalizerComplete;
    c3c6:	86 e0       	ldi	r24, 0x06	; 6
    c3c8:	66 c1       	rjmp	.+716    	; 0xc696 <FCloseShift+0x468>
	      break;
     case csWaitTotalizerComplete:
	      KeyPressed=_key_scan(1);
    c3ca:	81 e0       	ldi	r24, 0x01	; 1
    c3cc:	0e 94 84 ae 	call	0x15d08	; 0x15d08 <_key_scan>
    c3d0:	d8 2e       	mov	r13, r24
		  if (IsNewPumpStatus==True){
    c3d2:	80 91 01 01 	lds	r24, 0x0101
    c3d6:	81 30       	cpi	r24, 0x01	; 1
    c3d8:	89 f5       	brne	.+98     	; 0xc43c <FCloseShift+0x20e>
			  sprintf_P(lcdteks,PSTR("Wait Pump:%d "),(ActivePump-CountTotalizerSatus(strPumpStatus)));
    c3da:	00 91 50 01 	lds	r16, 0x0150
    c3de:	10 e0       	ldi	r17, 0x00	; 0
    c3e0:	82 e0       	ldi	r24, 0x02	; 2
    c3e2:	91 e0       	ldi	r25, 0x01	; 1
    c3e4:	0e 94 4c 30 	call	0x6098	; 0x6098 <CountTotalizerSatus>
    c3e8:	00 d0       	rcall	.+0      	; 0xc3ea <FCloseShift+0x1bc>
    c3ea:	00 d0       	rcall	.+0      	; 0xc3ec <FCloseShift+0x1be>
    c3ec:	00 d0       	rcall	.+0      	; 0xc3ee <FCloseShift+0x1c0>
    c3ee:	ed b7       	in	r30, 0x3d	; 61
    c3f0:	fe b7       	in	r31, 0x3e	; 62
    c3f2:	31 96       	adiw	r30, 0x01	; 1
    c3f4:	7e 01       	movw	r14, r28
    c3f6:	08 94       	sec
    c3f8:	e1 1c       	adc	r14, r1
    c3fa:	f1 1c       	adc	r15, r1
    c3fc:	ad b7       	in	r26, 0x3d	; 61
    c3fe:	be b7       	in	r27, 0x3e	; 62
    c400:	12 96       	adiw	r26, 0x02	; 2
    c402:	fc 92       	st	X, r15
    c404:	ee 92       	st	-X, r14
    c406:	11 97       	sbiw	r26, 0x01	; 1
    c408:	2c eb       	ldi	r18, 0xBC	; 188
    c40a:	35 e1       	ldi	r19, 0x15	; 21
    c40c:	33 83       	std	Z+3, r19	; 0x03
    c40e:	22 83       	std	Z+2, r18	; 0x02
    c410:	08 1b       	sub	r16, r24
    c412:	11 09       	sbc	r17, r1
    c414:	15 83       	std	Z+5, r17	; 0x05
    c416:	04 83       	std	Z+4, r16	; 0x04
    c418:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
			  lcd_print(2,1,lcdteks);
    c41c:	ed b7       	in	r30, 0x3d	; 61
    c41e:	fe b7       	in	r31, 0x3e	; 62
    c420:	36 96       	adiw	r30, 0x06	; 6
    c422:	0f b6       	in	r0, 0x3f	; 63
    c424:	f8 94       	cli
    c426:	fe bf       	out	0x3e, r31	; 62
    c428:	0f be       	out	0x3f, r0	; 63
    c42a:	ed bf       	out	0x3d, r30	; 61
    c42c:	82 e0       	ldi	r24, 0x02	; 2
    c42e:	61 e0       	ldi	r22, 0x01	; 1
    c430:	a7 01       	movw	r20, r14
    c432:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
		  	  stCloseShift=csDisplayPumpStatus;	 
    c436:	85 e0       	ldi	r24, 0x05	; 5
    c438:	80 93 9a 02 	sts	0x029A, r24
		  }
		  if ((CountTotalizerSatus(strPumpStatus)>=ActivePump)&&(TimDisplay>5)){
    c43c:	82 e0       	ldi	r24, 0x02	; 2
    c43e:	91 e0       	ldi	r25, 0x01	; 1
    c440:	0e 94 4c 30 	call	0x6098	; 0x6098 <CountTotalizerSatus>
    c444:	90 91 50 01 	lds	r25, 0x0150
    c448:	89 17       	cp	r24, r25
    c44a:	a0 f0       	brcs	.+40     	; 0xc474 <FCloseShift+0x246>
    c44c:	80 91 95 01 	lds	r24, 0x0195
    c450:	86 30       	cpi	r24, 0x06	; 6
    c452:	80 f0       	brcs	.+32     	; 0xc474 <FCloseShift+0x246>
    c454:	10 e0       	ldi	r17, 0x00	; 0
    c456:	07 c0       	rjmp	.+14     	; 0xc466 <FCloseShift+0x238>
		      for (FIPAddr=0;FIPAddr<ActivePump;FIPAddr++)
			       UpdateStandaloneStatus(GetPumpID(FIPAddr),PUMP_OFF);
    c458:	81 2f       	mov	r24, r17
    c45a:	0e 94 d6 1d 	call	0x3bac	; 0x3bac <GetPumpID>
    c45e:	66 e0       	ldi	r22, 0x06	; 6
    c460:	0e 94 78 1d 	call	0x3af0	; 0x3af0 <UpdateStandaloneStatus>
			  sprintf_P(lcdteks,PSTR("Wait Pump:%d "),(ActivePump-CountTotalizerSatus(strPumpStatus)));
			  lcd_print(2,1,lcdteks);
		  	  stCloseShift=csDisplayPumpStatus;	 
		  }
		  if ((CountTotalizerSatus(strPumpStatus)>=ActivePump)&&(TimDisplay>5)){
		      for (FIPAddr=0;FIPAddr<ActivePump;FIPAddr++)
    c464:	1f 5f       	subi	r17, 0xFF	; 255
    c466:	80 91 50 01 	lds	r24, 0x0150
    c46a:	18 17       	cp	r17, r24
    c46c:	a8 f3       	brcs	.-22     	; 0xc458 <FCloseShift+0x22a>
			       UpdateStandaloneStatus(GetPumpID(FIPAddr),PUMP_OFF);

		      stCloseShift=csGenerateReport;		      
    c46e:	88 e0       	ldi	r24, 0x08	; 8
    c470:	80 93 9a 02 	sts	0x029A, r24
			  }
          //sprintf_P(lcdteks,PSTR("TimSend:%d"),TimDisplay);
		  //lcd_print(3,1,lcdteks);

          if ((TimDisplay>15)&&(IsPumpBusy!=True)){
    c474:	80 91 95 01 	lds	r24, 0x0195
    c478:	80 31       	cpi	r24, 0x10	; 16
    c47a:	08 f4       	brcc	.+2      	; 0xc47e <FCloseShift+0x250>
    c47c:	64 c0       	rjmp	.+200    	; 0xc546 <FCloseShift+0x318>
    c47e:	80 91 99 02 	lds	r24, 0x0299
    c482:	81 30       	cpi	r24, 0x01	; 1
    c484:	09 f4       	brne	.+2      	; 0xc488 <FCloseShift+0x25a>
    c486:	5f c0       	rjmp	.+190    	; 0xc546 <FCloseShift+0x318>
		      if(CountNoPumpSatus(strPumpStatus)>=eeprom_read_byte(&DefActivePump)){
    c488:	82 e0       	ldi	r24, 0x02	; 2
    c48a:	91 e0       	ldi	r25, 0x01	; 1
    c48c:	0e 94 5e 16 	call	0x2cbc	; 0x2cbc <CountNoPumpSatus>
    c490:	28 2f       	mov	r18, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    c492:	e1 99       	sbic	0x1c, 1	; 28
    c494:	fe cf       	rjmp	.-4      	; 0xc492 <FCloseShift+0x264>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    c496:	89 e4       	ldi	r24, 0x49	; 73
    c498:	91 e0       	ldi	r25, 0x01	; 1
    c49a:	9f bb       	out	0x1f, r25	; 31
    c49c:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    c49e:	e0 9a       	sbi	0x1c, 0	; 28
    c4a0:	8d b3       	in	r24, 0x1d	; 29
    c4a2:	28 17       	cp	r18, r24
    c4a4:	08 f4       	brcc	.+2      	; 0xc4a8 <FCloseShift+0x27a>
    c4a6:	4f c0       	rjmp	.+158    	; 0xc546 <FCloseShift+0x318>
			  //lcd_printf(2,1,PSTR("NoPumpFound  ")); 
			  //sprintf_P(lcdteks,PSTR("NoPumpFound:%d"),CountNoPumpSatus(strPumpStatus));
			  sprintf_P(lcdteks,PSTR("Error - No Pump:%d "),ActivePump-CountNoPumpSatus(strPumpStatus));
    c4a8:	00 91 50 01 	lds	r16, 0x0150
    c4ac:	10 e0       	ldi	r17, 0x00	; 0
    c4ae:	82 e0       	ldi	r24, 0x02	; 2
    c4b0:	91 e0       	ldi	r25, 0x01	; 1
    c4b2:	0e 94 5e 16 	call	0x2cbc	; 0x2cbc <CountNoPumpSatus>
    c4b6:	00 d0       	rcall	.+0      	; 0xc4b8 <FCloseShift+0x28a>
    c4b8:	00 d0       	rcall	.+0      	; 0xc4ba <FCloseShift+0x28c>
    c4ba:	00 d0       	rcall	.+0      	; 0xc4bc <FCloseShift+0x28e>
    c4bc:	ed b7       	in	r30, 0x3d	; 61
    c4be:	fe b7       	in	r31, 0x3e	; 62
    c4c0:	31 96       	adiw	r30, 0x01	; 1
    c4c2:	7e 01       	movw	r14, r28
    c4c4:	08 94       	sec
    c4c6:	e1 1c       	adc	r14, r1
    c4c8:	f1 1c       	adc	r15, r1
    c4ca:	ad b7       	in	r26, 0x3d	; 61
    c4cc:	be b7       	in	r27, 0x3e	; 62
    c4ce:	12 96       	adiw	r26, 0x02	; 2
    c4d0:	fc 92       	st	X, r15
    c4d2:	ee 92       	st	-X, r14
    c4d4:	11 97       	sbiw	r26, 0x01	; 1
    c4d6:	28 ea       	ldi	r18, 0xA8	; 168
    c4d8:	35 e1       	ldi	r19, 0x15	; 21
    c4da:	33 83       	std	Z+3, r19	; 0x03
    c4dc:	22 83       	std	Z+2, r18	; 0x02
    c4de:	08 1b       	sub	r16, r24
    c4e0:	11 09       	sbc	r17, r1
    c4e2:	15 83       	std	Z+5, r17	; 0x05
    c4e4:	04 83       	std	Z+4, r16	; 0x04
    c4e6:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
			  lcd_print(3,1,lcdteks);
    c4ea:	ed b7       	in	r30, 0x3d	; 61
    c4ec:	fe b7       	in	r31, 0x3e	; 62
    c4ee:	36 96       	adiw	r30, 0x06	; 6
    c4f0:	0f b6       	in	r0, 0x3f	; 63
    c4f2:	f8 94       	cli
    c4f4:	fe bf       	out	0x3e, r31	; 62
    c4f6:	0f be       	out	0x3f, r0	; 63
    c4f8:	ed bf       	out	0x3d, r30	; 61
    c4fa:	83 e0       	ldi	r24, 0x03	; 3
    c4fc:	61 e0       	ldi	r22, 0x01	; 1
    c4fe:	a7 01       	movw	r20, r14
    c500:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
    c504:	10 e0       	ldi	r17, 0x00	; 0
    c506:	11 c0       	rjmp	.+34     	; 0xc52a <FCloseShift+0x2fc>
			  
			  for (FIPAddr=0;FIPAddr<ActivePump;FIPAddr++){
		           if (strPumpStatus[FIPAddr]==GetPumpStatusLabel(PS_TOTALIZER))
    c508:	84 e1       	ldi	r24, 0x14	; 20
    c50a:	0e 94 7d 13 	call	0x26fa	; 0x26fa <GetPumpStatusLabel>
    c50e:	e1 2f       	mov	r30, r17
    c510:	f0 e0       	ldi	r31, 0x00	; 0
    c512:	ee 5f       	subi	r30, 0xFE	; 254
    c514:	fe 4f       	sbci	r31, 0xFE	; 254
    c516:	90 81       	ld	r25, Z
    c518:	98 17       	cp	r25, r24
    c51a:	31 f4       	brne	.+12     	; 0xc528 <FCloseShift+0x2fa>
			           UpdateStandaloneStatus(GetPumpID(FIPAddr),PUMP_OFF);
    c51c:	81 2f       	mov	r24, r17
    c51e:	0e 94 d6 1d 	call	0x3bac	; 0x3bac <GetPumpID>
    c522:	66 e0       	ldi	r22, 0x06	; 6
    c524:	0e 94 78 1d 	call	0x3af0	; 0x3af0 <UpdateStandaloneStatus>
			  //lcd_printf(2,1,PSTR("NoPumpFound  ")); 
			  //sprintf_P(lcdteks,PSTR("NoPumpFound:%d"),CountNoPumpSatus(strPumpStatus));
			  sprintf_P(lcdteks,PSTR("Error - No Pump:%d "),ActivePump-CountNoPumpSatus(strPumpStatus));
			  lcd_print(3,1,lcdteks);
			  
			  for (FIPAddr=0;FIPAddr<ActivePump;FIPAddr++){
    c528:	1f 5f       	subi	r17, 0xFF	; 255
    c52a:	80 91 50 01 	lds	r24, 0x0150
    c52e:	18 17       	cp	r17, r24
    c530:	58 f3       	brcs	.-42     	; 0xc508 <FCloseShift+0x2da>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    c532:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    c534:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    c536:	81 e0       	ldi	r24, 0x01	; 1
    c538:	80 93 bf 01 	sts	0x01BF, r24
		           if (strPumpStatus[FIPAddr]==GetPumpStatusLabel(PS_TOTALIZER))
			           UpdateStandaloneStatus(GetPumpID(FIPAddr),PUMP_OFF);
			  }

			  system_beep(1);
			  TimDisplay=0;
    c53c:	10 92 95 01 	sts	0x0195, r1
			  stCloseShift=csNoPumpFound;		     
    c540:	87 e0       	ldi	r24, 0x07	; 7
    c542:	80 93 9a 02 	sts	0x029A, r24
			  }			  
		  }
		  if (KeyPressed==_KEY_CANCEL){
    c546:	f7 ee       	ldi	r31, 0xE7	; 231
    c548:	df 16       	cp	r13, r31
    c54a:	09 f0       	breq	.+2      	; 0xc54e <FCloseShift+0x320>
    c54c:	ab c0       	rjmp	.+342    	; 0xc6a4 <FCloseShift+0x476>
			  sprintf_P(lcdteks,PSTR("Cancel"));
    c54e:	00 d0       	rcall	.+0      	; 0xc550 <FCloseShift+0x322>
    c550:	00 d0       	rcall	.+0      	; 0xc552 <FCloseShift+0x324>
    c552:	8e 01       	movw	r16, r28
    c554:	0f 5f       	subi	r16, 0xFF	; 255
    c556:	1f 4f       	sbci	r17, 0xFF	; 255
    c558:	ad b7       	in	r26, 0x3d	; 61
    c55a:	be b7       	in	r27, 0x3e	; 62
    c55c:	12 96       	adiw	r26, 0x02	; 2
    c55e:	1c 93       	st	X, r17
    c560:	0e 93       	st	-X, r16
    c562:	11 97       	sbiw	r26, 0x01	; 1
    c564:	81 ea       	ldi	r24, 0xA1	; 161
    c566:	95 e1       	ldi	r25, 0x15	; 21
    c568:	14 96       	adiw	r26, 0x04	; 4
    c56a:	9c 93       	st	X, r25
    c56c:	8e 93       	st	-X, r24
    c56e:	13 97       	sbiw	r26, 0x03	; 3
    c570:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
			  lcd_print(3,1,lcdteks);
    c574:	0f 90       	pop	r0
    c576:	0f 90       	pop	r0
    c578:	0f 90       	pop	r0
    c57a:	0f 90       	pop	r0
    c57c:	83 e0       	ldi	r24, 0x03	; 3
    c57e:	61 e0       	ldi	r22, 0x01	; 1
    c580:	a8 01       	movw	r20, r16
    c582:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    c586:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    c588:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    c58a:	81 e0       	ldi	r24, 0x01	; 1
    c58c:	80 93 bf 01 	sts	0x01BF, r24
		  }
		  if (KeyPressed==_KEY_CANCEL){
			  sprintf_P(lcdteks,PSTR("Cancel"));
			  lcd_print(3,1,lcdteks);
			  system_beep(1);
			  TimDisplay=0;
    c590:	10 92 95 01 	sts	0x0195, r1
			  stCloseShift=csNoPumpFound;		     		  
    c594:	87 e0       	ldi	r24, 0x07	; 7
    c596:	7f c0       	rjmp	.+254    	; 0xc696 <FCloseShift+0x468>
		  }
	      break;
     case csNoPumpFound:
	      if (TimDisplay>TIM_DISPLAY){
    c598:	80 91 95 01 	lds	r24, 0x0195
    c59c:	8b 30       	cpi	r24, 0x0B	; 11
    c59e:	08 f4       	brcc	.+2      	; 0xc5a2 <FCloseShift+0x374>
    c5a0:	81 c0       	rjmp	.+258    	; 0xc6a4 <FCloseShift+0x476>
    c5a2:	78 c0       	rjmp	.+240    	; 0xc694 <FCloseShift+0x466>
		      stCloseShift=csFinishCloseShift;
		  }	      
	      break;
     case csGenerateReport:
		  lcd_printf(1,1,PSTR("Printing Totalizer"));
    c5a4:	81 e0       	ldi	r24, 0x01	; 1
    c5a6:	61 e0       	ldi	r22, 0x01	; 1
    c5a8:	4e e8       	ldi	r20, 0x8E	; 142
    c5aa:	55 e1       	ldi	r21, 0x15	; 21
    c5ac:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
          _datetime(0, strSystemDate, strSystemTime);
    c5b0:	09 ec       	ldi	r16, 0xC9	; 201
    c5b2:	14 e0       	ldi	r17, 0x04	; 4
    c5b4:	28 ea       	ldi	r18, 0xA8	; 168
    c5b6:	e2 2e       	mov	r14, r18
    c5b8:	29 e0       	ldi	r18, 0x09	; 9
    c5ba:	f2 2e       	mov	r15, r18
    c5bc:	80 e0       	ldi	r24, 0x00	; 0
    c5be:	b8 01       	movw	r22, r16
    c5c0:	a7 01       	movw	r20, r14
    c5c2:	0e 94 4f b1 	call	0x1629e	; 0x1629e <_datetime>
		  sprintf_P(CurrentShiftDateTime,PSTR("%s %s"),strSystemDate,strSystemTime);
    c5c6:	ed b7       	in	r30, 0x3d	; 61
    c5c8:	fe b7       	in	r31, 0x3e	; 62
    c5ca:	38 97       	sbiw	r30, 0x08	; 8
    c5cc:	0f b6       	in	r0, 0x3f	; 63
    c5ce:	f8 94       	cli
    c5d0:	fe bf       	out	0x3e, r31	; 62
    c5d2:	0f be       	out	0x3f, r0	; 63
    c5d4:	ed bf       	out	0x3d, r30	; 61
    c5d6:	31 96       	adiw	r30, 0x01	; 1
    c5d8:	80 ea       	ldi	r24, 0xA0	; 160
    c5da:	98 e0       	ldi	r25, 0x08	; 8
    c5dc:	ad b7       	in	r26, 0x3d	; 61
    c5de:	be b7       	in	r27, 0x3e	; 62
    c5e0:	12 96       	adiw	r26, 0x02	; 2
    c5e2:	9c 93       	st	X, r25
    c5e4:	8e 93       	st	-X, r24
    c5e6:	11 97       	sbiw	r26, 0x01	; 1
    c5e8:	88 e8       	ldi	r24, 0x88	; 136
    c5ea:	95 e1       	ldi	r25, 0x15	; 21
    c5ec:	93 83       	std	Z+3, r25	; 0x03
    c5ee:	82 83       	std	Z+2, r24	; 0x02
    c5f0:	15 83       	std	Z+5, r17	; 0x05
    c5f2:	04 83       	std	Z+4, r16	; 0x04
    c5f4:	f7 82       	std	Z+7, r15	; 0x07
    c5f6:	e6 82       	std	Z+6, r14	; 0x06
    c5f8:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
		  IsGenerateReport=True;
    c5fc:	81 e0       	ldi	r24, 0x01	; 1
    c5fe:	80 93 89 01 	sts	0x0189, r24
		  IsFinishPrintingTotalizer=False;
    c602:	10 92 8a 01 	sts	0x018A, r1
		  stCloseShift=csWaitPrintTotalizerComplete;
    c606:	8a e0       	ldi	r24, 0x0A	; 10
    c608:	80 93 9a 02 	sts	0x029A, r24
    c60c:	80 e0       	ldi	r24, 0x00	; 0
    c60e:	ed b7       	in	r30, 0x3d	; 61
    c610:	fe b7       	in	r31, 0x3e	; 62
    c612:	38 96       	adiw	r30, 0x08	; 8
    c614:	0f b6       	in	r0, 0x3f	; 63
    c616:	f8 94       	cli
    c618:	fe bf       	out	0x3e, r31	; 62
    c61a:	0f be       	out	0x3f, r0	; 63
    c61c:	ed bf       	out	0x3d, r30	; 61
    c61e:	43 c0       	rjmp	.+134    	; 0xc6a6 <FCloseShift+0x478>
	      break;
     case csWaitTotalizerALL:
	      break;
     case csWaitPrintTotalizerComplete:
	      if (IsFinishPrintingTotalizer==True){
    c620:	80 91 8a 01 	lds	r24, 0x018A
    c624:	81 30       	cpi	r24, 0x01	; 1
    c626:	09 f0       	breq	.+2      	; 0xc62a <FCloseShift+0x3fc>
    c628:	3d c0       	rjmp	.+122    	; 0xc6a4 <FCloseShift+0x476>
		      IsFinishPrintingTotalizer=False;
    c62a:	10 92 8a 01 	sts	0x018A, r1
		      stCloseShift=csDumpShift;
    c62e:	8c e0       	ldi	r24, 0x0C	; 12
    c630:	32 c0       	rjmp	.+100    	; 0xc696 <FCloseShift+0x468>
		  }
	      break;
     case csDumpShift://Increment CurrentShift save Current to Last
		  lcd_printf(1,1,PSTR("Saving ShiftData.. "));
    c632:	81 e0       	ldi	r24, 0x01	; 1
    c634:	61 e0       	ldi	r22, 0x01	; 1
    c636:	44 e7       	ldi	r20, 0x74	; 116
    c638:	55 e1       	ldi	r21, 0x15	; 21
    c63a:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
	      if (ShiftType==CONTINUE_SHIFT)//Shift=Shift+1
    c63e:	12 30       	cpi	r17, 0x02	; 2
    c640:	71 f4       	brne	.+28     	; 0xc65e <FCloseShift+0x430>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    c642:	e1 99       	sbic	0x1c, 1	; 28
    c644:	fe cf       	rjmp	.-4      	; 0xc642 <FCloseShift+0x414>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    c646:	2f e3       	ldi	r18, 0x3F	; 63
    c648:	31 e0       	ldi	r19, 0x01	; 1
    c64a:	3f bb       	out	0x1f, r19	; 31
    c64c:	2e bb       	out	0x1e, r18	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    c64e:	e0 9a       	sbi	0x1c, 0	; 28
    c650:	8d b3       	in	r24, 0x1d	; 29
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    c652:	e1 99       	sbic	0x1c, 1	; 28
    c654:	fe cf       	rjmp	.-4      	; 0xc652 <FCloseShift+0x424>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    c656:	3f bb       	out	0x1f, r19	; 31
    c658:	2e bb       	out	0x1e, r18	; 30
		      eeprom_write_byte(&DefShift,eeprom_read_byte(&DefShift)+1);	 
    c65a:	8f 5f       	subi	r24, 0xFF	; 255
    c65c:	09 c0       	rjmp	.+18     	; 0xc670 <FCloseShift+0x442>
          else if (ShiftType==NEW_SHIFT)//Shift=1
    c65e:	11 30       	cpi	r17, 0x01	; 1
    c660:	69 f4       	brne	.+26     	; 0xc67c <FCloseShift+0x44e>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    c662:	e1 99       	sbic	0x1c, 1	; 28
    c664:	fe cf       	rjmp	.-4      	; 0xc662 <FCloseShift+0x434>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    c666:	8f e3       	ldi	r24, 0x3F	; 63
    c668:	91 e0       	ldi	r25, 0x01	; 1
    c66a:	9f bb       	out	0x1f, r25	; 31
    c66c:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    c66e:	81 e0       	ldi	r24, 0x01	; 1
    c670:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    c672:	0f b6       	in	r0, 0x3f	; 63
    c674:	f8 94       	cli
    c676:	e2 9a       	sbi	0x1c, 2	; 28
    c678:	e1 9a       	sbi	0x1c, 1	; 28
    c67a:	0f be       	out	0x3f, r0	; 63
		      eeprom_write_byte(&DefShift,1);	 

          SaveTotalizerCurrentToLast();
    c67c:	0e 94 6d 28 	call	0x50da	; 0x50da <SaveTotalizerCurrentToLast>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    c680:	83 e4       	ldi	r24, 0x43	; 67
    c682:	98 e0       	ldi	r25, 0x08	; 8
    c684:	60 ea       	ldi	r22, 0xA0	; 160
    c686:	78 e0       	ldi	r23, 0x08	; 8
    c688:	44 e1       	ldi	r20, 0x14	; 20
    c68a:	50 e0       	ldi	r21, 0x00	; 0
    c68c:	25 e0       	ldi	r18, 0x05	; 5
    c68e:	33 e1       	ldi	r19, 0x13	; 19
    c690:	0e 94 0d b4 	call	0x1681a	; 0x1681a <__eewr_block>
          eeprom_write_block((const void*) &CurrentShiftDateTime, (void*) &DefLastShiftDateTime,sizeof(DefLastShiftDateTime));
		  stCloseShift=csFinishCloseShift;
    c694:	8b e0       	ldi	r24, 0x0B	; 11
    c696:	80 93 9a 02 	sts	0x029A, r24
    c69a:	04 c0       	rjmp	.+8      	; 0xc6a4 <FCloseShift+0x476>
	      break;
     case csFinishCloseShift:
          stCloseShift=csInitCloseShift;
    c69c:	10 92 9a 02 	sts	0x029A, r1
    c6a0:	81 e0       	ldi	r24, 0x01	; 1
    c6a2:	01 c0       	rjmp	.+2      	; 0xc6a6 <FCloseShift+0x478>
    c6a4:	80 e0       	ldi	r24, 0x00	; 0
		  Result=MENU_DONE;
	      break;
	 }
	 //_uart_printf(0,1,PSTR("Close Shift"));	
   return Result;
}
    c6a6:	64 96       	adiw	r28, 0x14	; 20
    c6a8:	0f b6       	in	r0, 0x3f	; 63
    c6aa:	f8 94       	cli
    c6ac:	de bf       	out	0x3e, r29	; 62
    c6ae:	0f be       	out	0x3f, r0	; 63
    c6b0:	cd bf       	out	0x3d, r28	; 61
    c6b2:	cf 91       	pop	r28
    c6b4:	df 91       	pop	r29
    c6b6:	1f 91       	pop	r17
    c6b8:	0f 91       	pop	r16
    c6ba:	ff 90       	pop	r15
    c6bc:	ef 90       	pop	r14
    c6be:	df 90       	pop	r13
    c6c0:	08 95       	ret

0000c6c2 <FMenuShift>:
     char SubMenu,KeyChar,KeyPressed;

     char Result;

Result=MENU_NONE;
     switch(stMenuShift){
    c6c2:	80 91 9b 02 	lds	r24, 0x029B
    c6c6:	82 30       	cpi	r24, 0x02	; 2
    c6c8:	09 f4       	brne	.+2      	; 0xc6cc <FMenuShift+0xa>
    c6ca:	48 c0       	rjmp	.+144    	; 0xc75c <FMenuShift+0x9a>
    c6cc:	83 30       	cpi	r24, 0x03	; 3
    c6ce:	30 f4       	brcc	.+12     	; 0xc6dc <FMenuShift+0x1a>
    c6d0:	88 23       	and	r24, r24
    c6d2:	69 f0       	breq	.+26     	; 0xc6ee <FMenuShift+0x2c>
    c6d4:	81 30       	cpi	r24, 0x01	; 1
    c6d6:	09 f0       	breq	.+2      	; 0xc6da <FMenuShift+0x18>
    c6d8:	50 c0       	rjmp	.+160    	; 0xc77a <FMenuShift+0xb8>
    c6da:	25 c0       	rjmp	.+74     	; 0xc726 <FMenuShift+0x64>
    c6dc:	84 30       	cpi	r24, 0x04	; 4
    c6de:	09 f4       	brne	.+2      	; 0xc6e2 <FMenuShift+0x20>
    c6e0:	4c c0       	rjmp	.+152    	; 0xc77a <FMenuShift+0xb8>
    c6e2:	84 30       	cpi	r24, 0x04	; 4
    c6e4:	e8 f1       	brcs	.+122    	; 0xc760 <FMenuShift+0x9e>
    c6e6:	85 30       	cpi	r24, 0x05	; 5
    c6e8:	09 f0       	breq	.+2      	; 0xc6ec <FMenuShift+0x2a>
    c6ea:	47 c0       	rjmp	.+142    	; 0xc77a <FMenuShift+0xb8>
    c6ec:	42 c0       	rjmp	.+132    	; 0xc772 <FMenuShift+0xb0>
	 case msInitMenuShift:
	      lcd_clear();
    c6ee:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
		  lcd_printf(1,1,PSTR("1.Close Shift"));
    c6f2:	81 e0       	ldi	r24, 0x01	; 1
    c6f4:	61 e0       	ldi	r22, 0x01	; 1
    c6f6:	47 e0       	ldi	r20, 0x07	; 7
    c6f8:	56 e1       	ldi	r21, 0x16	; 22
    c6fa:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		  lcd_printf(2,1,PSTR("2.Close Day  "));
    c6fe:	82 e0       	ldi	r24, 0x02	; 2
    c700:	61 e0       	ldi	r22, 0x01	; 1
    c702:	49 ef       	ldi	r20, 0xF9	; 249
    c704:	55 e1       	ldi	r21, 0x15	; 21
    c706:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		  lcd_printf(3,1,PSTR("3.Lock Pump  "));
    c70a:	83 e0       	ldi	r24, 0x03	; 3
    c70c:	61 e0       	ldi	r22, 0x01	; 1
    c70e:	4b ee       	ldi	r20, 0xEB	; 235
    c710:	55 e1       	ldi	r21, 0x15	; 21
    c712:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		  lcd_printf(4,1,PSTR("*)Exit"));
    c716:	84 e0       	ldi	r24, 0x04	; 4
    c718:	61 e0       	ldi	r22, 0x01	; 1
    c71a:	44 ee       	ldi	r20, 0xE4	; 228
    c71c:	55 e1       	ldi	r21, 0x15	; 21
    c71e:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		  stMenuShift=msSelectShift;
    c722:	81 e0       	ldi	r24, 0x01	; 1
    c724:	18 c0       	rjmp	.+48     	; 0xc756 <FMenuShift+0x94>
	      break;
     case msSelectShift:
          KeyPressed=_key_scan(1);
    c726:	81 e0       	ldi	r24, 0x01	; 1
    c728:	0e 94 84 ae 	call	0x15d08	; 0x15d08 <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
    c72c:	0e 94 e5 ad 	call	0x15bca	; 0x15bca <_key_btn>
          switch(KeyChar){
    c730:	82 33       	cpi	r24, 0x32	; 50
    c732:	61 f0       	breq	.+24     	; 0xc74c <FMenuShift+0x8a>
    c734:	83 33       	cpi	r24, 0x33	; 51
    c736:	28 f4       	brcc	.+10     	; 0xc742 <FMenuShift+0x80>
    c738:	8a 32       	cpi	r24, 0x2A	; 42
    c73a:	61 f0       	breq	.+24     	; 0xc754 <FMenuShift+0x92>
    c73c:	81 33       	cpi	r24, 0x31	; 49
    c73e:	e9 f4       	brne	.+58     	; 0xc77a <FMenuShift+0xb8>
    c740:	03 c0       	rjmp	.+6      	; 0xc748 <FMenuShift+0x86>
    c742:	83 33       	cpi	r24, 0x33	; 51
    c744:	d1 f4       	brne	.+52     	; 0xc77a <FMenuShift+0xb8>
    c746:	04 c0       	rjmp	.+8      	; 0xc750 <FMenuShift+0x8e>
		  case '1':
		       SubMenu=MENU_NONE;
		       stMenuShift=msCloseShift;
    c748:	82 e0       	ldi	r24, 0x02	; 2
    c74a:	05 c0       	rjmp	.+10     	; 0xc756 <FMenuShift+0x94>
		       break; 
		  case '2':
		       SubMenu=MENU_NONE;
		       stMenuShift=msCloseDay;
    c74c:	83 e0       	ldi	r24, 0x03	; 3
    c74e:	03 c0       	rjmp	.+6      	; 0xc756 <FMenuShift+0x94>
		       break; 
		  case '3':
		       SubMenu=MENU_NONE;
		       stMenuShift=msLockPump;
    c750:	84 e0       	ldi	r24, 0x04	; 4
    c752:	01 c0       	rjmp	.+2      	; 0xc756 <FMenuShift+0x94>
		       break; 
		  case '*':
		       stMenuShift=msExitShift;
    c754:	85 e0       	ldi	r24, 0x05	; 5
    c756:	80 93 9b 02 	sts	0x029B, r24
    c75a:	09 c0       	rjmp	.+18     	; 0xc76e <FMenuShift+0xac>
		       break; 			   		  
		  }
		  break;
     case msCloseShift:
	      SubMenu=FCloseShift(CONTINUE_SHIFT);
    c75c:	82 e0       	ldi	r24, 0x02	; 2
    c75e:	01 c0       	rjmp	.+2      	; 0xc762 <FMenuShift+0xa0>
		  if (SubMenu==MENU_DONE)stMenuShift=msInitMenuShift;
		  //IsGenerateReport=True;		  
	      break;
     case msCloseDay:
	      SubMenu=FCloseShift(NEW_SHIFT);
    c760:	81 e0       	ldi	r24, 0x01	; 1
    c762:	0e 94 17 61 	call	0xc22e	; 0xc22e <FCloseShift>
		  if (SubMenu==MENU_DONE)stMenuShift=msInitMenuShift;
    c766:	81 30       	cpi	r24, 0x01	; 1
    c768:	41 f4       	brne	.+16     	; 0xc77a <FMenuShift+0xb8>
    c76a:	10 92 9b 02 	sts	0x029B, r1
    c76e:	80 e0       	ldi	r24, 0x00	; 0
    c770:	08 95       	ret
     case msLockPump:
	      SubMenu=FLockPump();
		  if (SubMenu==MENU_DONE)stMenuShift=msInitMenuShift;
	      break;
     case msExitShift:
          stMenuShift=msInitMenuShift;
    c772:	10 92 9b 02 	sts	0x029B, r1
    c776:	81 e0       	ldi	r24, 0x01	; 1
    c778:	08 95       	ret
    c77a:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;	 
	 } 
   return Result;
}
    c77c:	08 95       	ret

0000c77e <DisplayDateTime>:

void DisplayQueueFIP(){// FIP:#1#2#3#4#5

}

void DisplayDateTime(){
    c77e:	cf 92       	push	r12
    c780:	df 92       	push	r13
    c782:	ef 92       	push	r14
    c784:	ff 92       	push	r15
    c786:	0f 93       	push	r16
    c788:	1f 93       	push	r17
    c78a:	df 93       	push	r29
    c78c:	cf 93       	push	r28
    c78e:	cd b7       	in	r28, 0x3d	; 61
    c790:	de b7       	in	r29, 0x3e	; 62
    c792:	64 97       	sbiw	r28, 0x14	; 20
    c794:	0f b6       	in	r0, 0x3f	; 63
    c796:	f8 94       	cli
    c798:	de bf       	out	0x3e, r29	; 62
    c79a:	0f be       	out	0x3f, r0	; 63
    c79c:	cd bf       	out	0x3d, r28	; 61
char lcdteks[20];
	 _datetime(0, strSystemDate, strSystemTime);
    c79e:	49 ec       	ldi	r20, 0xC9	; 201
    c7a0:	e4 2e       	mov	r14, r20
    c7a2:	44 e0       	ldi	r20, 0x04	; 4
    c7a4:	f4 2e       	mov	r15, r20
    c7a6:	38 ea       	ldi	r19, 0xA8	; 168
    c7a8:	c3 2e       	mov	r12, r19
    c7aa:	39 e0       	ldi	r19, 0x09	; 9
    c7ac:	d3 2e       	mov	r13, r19
    c7ae:	80 e0       	ldi	r24, 0x00	; 0
    c7b0:	b7 01       	movw	r22, r14
    c7b2:	a6 01       	movw	r20, r12
    c7b4:	0e 94 4f b1 	call	0x1629e	; 0x1629e <_datetime>
	 sprintf_P(lcdteks,PSTR("%s %s"),strSystemDate,strSystemTime);
    c7b8:	8d b7       	in	r24, 0x3d	; 61
    c7ba:	9e b7       	in	r25, 0x3e	; 62
    c7bc:	08 97       	sbiw	r24, 0x08	; 8
    c7be:	0f b6       	in	r0, 0x3f	; 63
    c7c0:	f8 94       	cli
    c7c2:	9e bf       	out	0x3e, r25	; 62
    c7c4:	0f be       	out	0x3f, r0	; 63
    c7c6:	8d bf       	out	0x3d, r24	; 61
    c7c8:	ed b7       	in	r30, 0x3d	; 61
    c7ca:	fe b7       	in	r31, 0x3e	; 62
    c7cc:	31 96       	adiw	r30, 0x01	; 1
    c7ce:	8e 01       	movw	r16, r28
    c7d0:	0f 5f       	subi	r16, 0xFF	; 255
    c7d2:	1f 4f       	sbci	r17, 0xFF	; 255
    c7d4:	ad b7       	in	r26, 0x3d	; 61
    c7d6:	be b7       	in	r27, 0x3e	; 62
    c7d8:	12 96       	adiw	r26, 0x02	; 2
    c7da:	1c 93       	st	X, r17
    c7dc:	0e 93       	st	-X, r16
    c7de:	11 97       	sbiw	r26, 0x01	; 1
    c7e0:	85 e5       	ldi	r24, 0x55	; 85
    c7e2:	9c e1       	ldi	r25, 0x1C	; 28
    c7e4:	93 83       	std	Z+3, r25	; 0x03
    c7e6:	82 83       	std	Z+2, r24	; 0x02
    c7e8:	f5 82       	std	Z+5, r15	; 0x05
    c7ea:	e4 82       	std	Z+4, r14	; 0x04
    c7ec:	d7 82       	std	Z+7, r13	; 0x07
    c7ee:	c6 82       	std	Z+6, r12	; 0x06
    c7f0:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
	 lcd_print(2, 1, lcdteks);
    c7f4:	8d b7       	in	r24, 0x3d	; 61
    c7f6:	9e b7       	in	r25, 0x3e	; 62
    c7f8:	08 96       	adiw	r24, 0x08	; 8
    c7fa:	0f b6       	in	r0, 0x3f	; 63
    c7fc:	f8 94       	cli
    c7fe:	9e bf       	out	0x3e, r25	; 62
    c800:	0f be       	out	0x3f, r0	; 63
    c802:	8d bf       	out	0x3d, r24	; 61
    c804:	82 e0       	ldi	r24, 0x02	; 2
    c806:	61 e0       	ldi	r22, 0x01	; 1
    c808:	a8 01       	movw	r20, r16
    c80a:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
}
    c80e:	64 96       	adiw	r28, 0x14	; 20
    c810:	0f b6       	in	r0, 0x3f	; 63
    c812:	f8 94       	cli
    c814:	de bf       	out	0x3e, r29	; 62
    c816:	0f be       	out	0x3f, r0	; 63
    c818:	cd bf       	out	0x3d, r28	; 61
    c81a:	cf 91       	pop	r28
    c81c:	df 91       	pop	r29
    c81e:	1f 91       	pop	r17
    c820:	0f 91       	pop	r16
    c822:	ff 90       	pop	r15
    c824:	ef 90       	pop	r14
    c826:	df 90       	pop	r13
    c828:	cf 90       	pop	r12
    c82a:	08 95       	ret

0000c82c <_menu_datetime>:
		}
	}
}


void _menu_datetime(void){
    c82c:	8f 92       	push	r8
    c82e:	9f 92       	push	r9
    c830:	af 92       	push	r10
    c832:	bf 92       	push	r11
    c834:	cf 92       	push	r12
    c836:	df 92       	push	r13
    c838:	ef 92       	push	r14
    c83a:	ff 92       	push	r15
    c83c:	0f 93       	push	r16
    c83e:	1f 93       	push	r17
    c840:	df 93       	push	r29
    c842:	cf 93       	push	r28
    c844:	cd b7       	in	r28, 0x3d	; 61
    c846:	de b7       	in	r29, 0x3e	; 62
    c848:	c2 54       	subi	r28, 0x42	; 66
    c84a:	d0 40       	sbci	r29, 0x00	; 0
    c84c:	0f b6       	in	r0, 0x3f	; 63
    c84e:	f8 94       	cli
    c850:	de bf       	out	0x3e, r29	; 62
    c852:	0f be       	out	0x3f, r0	; 63
    c854:	cd bf       	out	0x3d, r28	; 61
	char	__key, __chr;
	char	__date[9];
	char	__time[9];
	char	__map[12][4] = {	{1,  8, 0, 3}, {1,  9, 0, 9}, {1, 11, 0, 1}, {1, 12, 0, 9},
								{1, 14, 0, 9}, {1, 15, 0, 9}, {2,  8, 0, 2}, {2,  9, 0, 9},
								{2, 11, 0, 5}, {2, 12, 0, 9}, {2, 14, 0, 5}, {2, 15, 0, 9}};
    c856:	de 01       	movw	r26, r28
    c858:	53 96       	adiw	r26, 0x13	; 19
    c85a:	e6 e1       	ldi	r30, 0x16	; 22
    c85c:	f1 e0       	ldi	r31, 0x01	; 1
    c85e:	80 e3       	ldi	r24, 0x30	; 48
    c860:	01 90       	ld	r0, Z+
    c862:	0d 92       	st	X+, r0
    c864:	81 50       	subi	r24, 0x01	; 1
    c866:	e1 f7       	brne	.-8      	; 0xc860 <_menu_datetime+0x34>

	_datetime(_DATETIME_READ, __date, __time);
    c868:	8e 01       	movw	r16, r28
    c86a:	0f 5f       	subi	r16, 0xFF	; 255
    c86c:	1f 4f       	sbci	r17, 0xFF	; 255
    c86e:	b8 01       	movw	r22, r16
    c870:	ae 01       	movw	r20, r28
    c872:	46 5f       	subi	r20, 0xF6	; 246
    c874:	5f 4f       	sbci	r21, 0xFF	; 255
    c876:	0e 94 4f b1 	call	0x1629e	; 0x1629e <_datetime>
    c87a:	85 e1       	ldi	r24, 0x15	; 21
    c87c:	88 2e       	mov	r8, r24
    c87e:	91 2c       	mov	r9, r1
    c880:	8c 0e       	add	r8, r28
    c882:	9d 1e       	adc	r9, r29
    c884:	d4 01       	movw	r26, r8
    c886:	20 e0       	ldi	r18, 0x00	; 0
    c888:	30 e0       	ldi	r19, 0x00	; 0
    c88a:	40 e0       	ldi	r20, 0x00	; 0
    c88c:	50 e0       	ldi	r21, 0x00	; 0
	for(__i = 0, __ii = 0; __i < 6; __i++, __ii++){
		if(__i == 2 || __i == 4)
    c88e:	22 30       	cpi	r18, 0x02	; 2
    c890:	31 05       	cpc	r19, r1
    c892:	19 f0       	breq	.+6      	; 0xc89a <_menu_datetime+0x6e>
    c894:	24 30       	cpi	r18, 0x04	; 4
    c896:	31 05       	cpc	r19, r1
    c898:	11 f4       	brne	.+4      	; 0xc89e <_menu_datetime+0x72>
			__ii++;
    c89a:	4f 5f       	subi	r20, 0xFF	; 255
    c89c:	5f 4f       	sbci	r21, 0xFF	; 255
		__map[__i][2] = __date[__ii];
    c89e:	f8 01       	movw	r30, r16
    c8a0:	e4 0f       	add	r30, r20
    c8a2:	f5 1f       	adc	r31, r21
    c8a4:	80 81       	ld	r24, Z
    c8a6:	8c 93       	st	X, r24
	char	__map[12][4] = {	{1,  8, 0, 3}, {1,  9, 0, 9}, {1, 11, 0, 1}, {1, 12, 0, 9},
								{1, 14, 0, 9}, {1, 15, 0, 9}, {2,  8, 0, 2}, {2,  9, 0, 9},
								{2, 11, 0, 5}, {2, 12, 0, 9}, {2, 14, 0, 5}, {2, 15, 0, 9}};

	_datetime(_DATETIME_READ, __date, __time);
	for(__i = 0, __ii = 0; __i < 6; __i++, __ii++){
    c8a8:	2f 5f       	subi	r18, 0xFF	; 255
    c8aa:	3f 4f       	sbci	r19, 0xFF	; 255
    c8ac:	14 96       	adiw	r26, 0x04	; 4
    c8ae:	26 30       	cpi	r18, 0x06	; 6
    c8b0:	31 05       	cpc	r19, r1
    c8b2:	19 f0       	breq	.+6      	; 0xc8ba <_menu_datetime+0x8e>
    c8b4:	4f 5f       	subi	r20, 0xFF	; 255
    c8b6:	5f 4f       	sbci	r21, 0xFF	; 255
    c8b8:	ea cf       	rjmp	.-44     	; 0xc88e <_menu_datetime+0x62>
    c8ba:	0d e2       	ldi	r16, 0x2D	; 45
    c8bc:	a0 2e       	mov	r10, r16
    c8be:	b1 2c       	mov	r11, r1
    c8c0:	ac 0e       	add	r10, r28
    c8c2:	bd 1e       	adc	r11, r29
    c8c4:	d5 01       	movw	r26, r10
    c8c6:	40 e0       	ldi	r20, 0x00	; 0
    c8c8:	50 e0       	ldi	r21, 0x00	; 0
		__map[__i][2] = __date[__ii];
	}
	for(__i = 6, __ii = 0; __i < 12; __i++, __ii++){
		if(__i == 8 || __i == 10)
			__ii++;
		__map[__i][2] = __time[__ii];
    c8ca:	1a e0       	ldi	r17, 0x0A	; 10
    c8cc:	e1 2e       	mov	r14, r17
    c8ce:	f1 2c       	mov	r15, r1
    c8d0:	ec 0e       	add	r14, r28
    c8d2:	fd 1e       	adc	r15, r29
		if(__i == 2 || __i == 4)
			__ii++;
		__map[__i][2] = __date[__ii];
	}
	for(__i = 6, __ii = 0; __i < 12; __i++, __ii++){
		if(__i == 8 || __i == 10)
    c8d4:	28 30       	cpi	r18, 0x08	; 8
    c8d6:	31 05       	cpc	r19, r1
    c8d8:	19 f0       	breq	.+6      	; 0xc8e0 <_menu_datetime+0xb4>
    c8da:	2a 30       	cpi	r18, 0x0A	; 10
    c8dc:	31 05       	cpc	r19, r1
    c8de:	11 f4       	brne	.+4      	; 0xc8e4 <_menu_datetime+0xb8>
			__ii++;
    c8e0:	4f 5f       	subi	r20, 0xFF	; 255
    c8e2:	5f 4f       	sbci	r21, 0xFF	; 255
		__map[__i][2] = __time[__ii];
    c8e4:	f7 01       	movw	r30, r14
    c8e6:	e4 0f       	add	r30, r20
    c8e8:	f5 1f       	adc	r31, r21
    c8ea:	80 81       	ld	r24, Z
    c8ec:	8c 93       	st	X, r24
	for(__i = 0, __ii = 0; __i < 6; __i++, __ii++){
		if(__i == 2 || __i == 4)
			__ii++;
		__map[__i][2] = __date[__ii];
	}
	for(__i = 6, __ii = 0; __i < 12; __i++, __ii++){
    c8ee:	2f 5f       	subi	r18, 0xFF	; 255
    c8f0:	3f 4f       	sbci	r19, 0xFF	; 255
    c8f2:	14 96       	adiw	r26, 0x04	; 4
    c8f4:	2c 30       	cpi	r18, 0x0C	; 12
    c8f6:	31 05       	cpc	r19, r1
    c8f8:	19 f0       	breq	.+6      	; 0xc900 <_menu_datetime+0xd4>
    c8fa:	4f 5f       	subi	r20, 0xFF	; 255
    c8fc:	5f 4f       	sbci	r21, 0xFF	; 255
    c8fe:	ea cf       	rjmp	.-44     	; 0xc8d4 <_menu_datetime+0xa8>
		if(__i == 8 || __i == 10)
			__ii++;
		__map[__i][2] = __time[__ii];
	}

	lcd_clear();_delay_ms(10);
    c900:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
    c904:	84 ec       	ldi	r24, 0xC4	; 196
    c906:	99 e0       	ldi	r25, 0x09	; 9
    c908:	01 97       	sbiw	r24, 0x01	; 1
    c90a:	f1 f7       	brne	.-4      	; 0xc908 <_menu_datetime+0xdc>
	lcd_printf(1, 1, PSTR("DATE : "));
    c90c:	81 e0       	ldi	r24, 0x01	; 1
    c90e:	61 e0       	ldi	r22, 0x01	; 1
    c910:	44 ed       	ldi	r20, 0xD4	; 212
    c912:	5b e0       	ldi	r21, 0x0B	; 11
    c914:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
	lcd_printf(2, 1, PSTR("TIME : "));
    c918:	82 e0       	ldi	r24, 0x02	; 2
    c91a:	61 e0       	ldi	r22, 0x01	; 1
    c91c:	4c ec       	ldi	r20, 0xCC	; 204
    c91e:	5b e0       	ldi	r21, 0x0B	; 11
    c920:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
	lcd_print(1, 8, __date);
    c924:	81 e0       	ldi	r24, 0x01	; 1
    c926:	68 e0       	ldi	r22, 0x08	; 8
    c928:	8e 01       	movw	r16, r28
    c92a:	0f 5f       	subi	r16, 0xFF	; 255
    c92c:	1f 4f       	sbci	r17, 0xFF	; 255
    c92e:	a8 01       	movw	r20, r16
    c930:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
	lcd_print(2, 8, __time);
    c934:	82 e0       	ldi	r24, 0x02	; 2
    c936:	68 e0       	ldi	r22, 0x08	; 8
    c938:	a7 01       	movw	r20, r14
    c93a:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
	lcd_printf(4, 1, PSTR("*)Cancel      #)Save"));
    c93e:	84 e0       	ldi	r24, 0x04	; 4
    c940:	61 e0       	ldi	r22, 0x01	; 1
    c942:	47 eb       	ldi	r20, 0xB7	; 183
    c944:	5b e0       	ldi	r21, 0x0B	; 11
    c946:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>

	__i = 0;
	lcd_xy(__map[__i][0], __map[__i][1]);
    c94a:	8b 89       	ldd	r24, Y+19	; 0x13
    c94c:	6c 89       	ldd	r22, Y+20	; 0x14
    c94e:	0e 94 ca ac 	call	0x15994	; 0x15994 <lcd_xy>
	CURSOR_SHOW;
    c952:	8f e0       	ldi	r24, 0x0F	; 15
    c954:	0e 94 37 ac 	call	0x1586e	; 0x1586e <lcd_command>
    c958:	ee 24       	eor	r14, r14
    c95a:	ff 24       	eor	r15, r15
					else
						goto LEWAT;
				}
			}
CETAK:
			__map[__i][2] = __chr;
    c95c:	68 01       	movw	r12, r16
	lcd_xy(__map[__i][0], __map[__i][1]);
	CURSOR_SHOW;

	while(1){
		
		__key = _key_scan(1);
    c95e:	81 e0       	ldi	r24, 0x01	; 1
    c960:	0e 94 84 ae 	call	0x15d08	; 0x15d08 <_key_scan>
    c964:	18 2f       	mov	r17, r24
		__chr = _key_btn(__key);
    c966:	0e 94 e5 ad 	call	0x15bca	; 0x15bca <_key_btn>
    c96a:	48 2f       	mov	r20, r24
		if(__chr >= 0x30 && __chr <= 0x39){
    c96c:	80 53       	subi	r24, 0x30	; 48
    c96e:	8a 30       	cpi	r24, 0x0A	; 10
    c970:	08 f0       	brcs	.+2      	; 0xc974 <_menu_datetime+0x148>
    c972:	72 c0       	rjmp	.+228    	; 0xca58 <_menu_datetime+0x22c>
			if(__i == 0 || __i == 2 || __i == 6 || __i == 8 || __i == 10){
    c974:	e1 14       	cp	r14, r1
    c976:	f1 04       	cpc	r15, r1
    c978:	81 f0       	breq	.+32     	; 0xc99a <_menu_datetime+0x16e>
    c97a:	82 e0       	ldi	r24, 0x02	; 2
    c97c:	e8 16       	cp	r14, r24
    c97e:	f1 04       	cpc	r15, r1
    c980:	61 f0       	breq	.+24     	; 0xc99a <_menu_datetime+0x16e>
    c982:	96 e0       	ldi	r25, 0x06	; 6
    c984:	e9 16       	cp	r14, r25
    c986:	f1 04       	cpc	r15, r1
    c988:	41 f0       	breq	.+16     	; 0xc99a <_menu_datetime+0x16e>
    c98a:	a8 e0       	ldi	r26, 0x08	; 8
    c98c:	ea 16       	cp	r14, r26
    c98e:	f1 04       	cpc	r15, r1
    c990:	21 f0       	breq	.+8      	; 0xc99a <_menu_datetime+0x16e>
    c992:	ba e0       	ldi	r27, 0x0A	; 10
    c994:	eb 16       	cp	r14, r27
    c996:	f1 04       	cpc	r15, r1
    c998:	81 f4       	brne	.+32     	; 0xc9ba <_menu_datetime+0x18e>
				if((__chr - 0x30) <= __map[__i][3])
    c99a:	84 2f       	mov	r24, r20
    c99c:	90 e0       	ldi	r25, 0x00	; 0
    c99e:	c0 97       	sbiw	r24, 0x30	; 48
    c9a0:	f7 01       	movw	r30, r14
    c9a2:	ee 0f       	add	r30, r30
    c9a4:	ff 1f       	adc	r31, r31
    c9a6:	ee 0f       	add	r30, r30
    c9a8:	ff 1f       	adc	r31, r31
    c9aa:	ec 0d       	add	r30, r12
    c9ac:	fd 1d       	adc	r31, r13
    c9ae:	25 89       	ldd	r18, Z+21	; 0x15
    c9b0:	30 e0       	ldi	r19, 0x00	; 0
    c9b2:	28 17       	cp	r18, r24
    c9b4:	39 07       	cpc	r19, r25
    c9b6:	84 f5       	brge	.+96     	; 0xca18 <_menu_datetime+0x1ec>
    c9b8:	4f c0       	rjmp	.+158    	; 0xca58 <_menu_datetime+0x22c>
					goto CETAK;
				else
					goto LEWAT;
			}
			if(__i == 1){
    c9ba:	81 e0       	ldi	r24, 0x01	; 1
    c9bc:	e8 16       	cp	r14, r24
    c9be:	f1 04       	cpc	r15, r1
    c9c0:	61 f4       	brne	.+24     	; 0xc9da <_menu_datetime+0x1ae>
				if((__map[0][2] - 0x30) < __map[0][3])
    c9c2:	2d 89       	ldd	r18, Y+21	; 0x15
    c9c4:	30 e0       	ldi	r19, 0x00	; 0
    c9c6:	2f 52       	subi	r18, 0x2F	; 47
    c9c8:	30 40       	sbci	r19, 0x00	; 0
    c9ca:	8e 89       	ldd	r24, Y+22	; 0x16
    c9cc:	90 e0       	ldi	r25, 0x00	; 0
    c9ce:	82 17       	cp	r24, r18
    c9d0:	93 07       	cpc	r25, r19
    c9d2:	14 f5       	brge	.+68     	; 0xca18 <_menu_datetime+0x1ec>
					goto CETAK;
				if((__map[0][2] - 0x30) >= __map[0][3]){
					if(__chr < 0x32)
    c9d4:	42 33       	cpi	r20, 0x32	; 50
    c9d6:	00 f1       	brcs	.+64     	; 0xca18 <_menu_datetime+0x1ec>
    c9d8:	3f c0       	rjmp	.+126    	; 0xca58 <_menu_datetime+0x22c>
						goto CETAK;
					else
						goto LEWAT;
				}
			}
			if(__i == 3){
    c9da:	93 e0       	ldi	r25, 0x03	; 3
    c9dc:	e9 16       	cp	r14, r25
    c9de:	f1 04       	cpc	r15, r1
    c9e0:	61 f4       	brne	.+24     	; 0xc9fa <_menu_datetime+0x1ce>
				if((__map[2][2] - 0x30) < __map[2][3])
    c9e2:	2d 8d       	ldd	r18, Y+29	; 0x1d
    c9e4:	30 e0       	ldi	r19, 0x00	; 0
    c9e6:	2f 52       	subi	r18, 0x2F	; 47
    c9e8:	30 40       	sbci	r19, 0x00	; 0
    c9ea:	8e 8d       	ldd	r24, Y+30	; 0x1e
    c9ec:	90 e0       	ldi	r25, 0x00	; 0
    c9ee:	82 17       	cp	r24, r18
    c9f0:	93 07       	cpc	r25, r19
    c9f2:	94 f4       	brge	.+36     	; 0xca18 <_menu_datetime+0x1ec>
					goto CETAK;
				if((__map[2][2] - 0x30) >= __map[2][3]){
					if(__chr < 0x33)
    c9f4:	43 33       	cpi	r20, 0x33	; 51
    c9f6:	80 f0       	brcs	.+32     	; 0xca18 <_menu_datetime+0x1ec>
    c9f8:	2f c0       	rjmp	.+94     	; 0xca58 <_menu_datetime+0x22c>
						goto CETAK;
					else
						goto LEWAT;
				}
			}
			if(__i == 7){
    c9fa:	a7 e0       	ldi	r26, 0x07	; 7
    c9fc:	ea 16       	cp	r14, r26
    c9fe:	f1 04       	cpc	r15, r1
    ca00:	59 f4       	brne	.+22     	; 0xca18 <_menu_datetime+0x1ec>
				if((__map[6][2] - 0x30) < __map[6][3])
    ca02:	2d a5       	ldd	r18, Y+45	; 0x2d
    ca04:	30 e0       	ldi	r19, 0x00	; 0
    ca06:	2f 52       	subi	r18, 0x2F	; 47
    ca08:	30 40       	sbci	r19, 0x00	; 0
    ca0a:	8e a5       	ldd	r24, Y+46	; 0x2e
    ca0c:	90 e0       	ldi	r25, 0x00	; 0
    ca0e:	82 17       	cp	r24, r18
    ca10:	93 07       	cpc	r25, r19
    ca12:	14 f4       	brge	.+4      	; 0xca18 <_menu_datetime+0x1ec>
					goto CETAK;
				if((__map[6][2] - 0x30) >= __map[6][3]){
					if(__chr < 0x34)
    ca14:	44 33       	cpi	r20, 0x34	; 52
    ca16:	00 f5       	brcc	.+64     	; 0xca58 <_menu_datetime+0x22c>
					else
						goto LEWAT;
				}
			}
CETAK:
			__map[__i][2] = __chr;
    ca18:	f7 01       	movw	r30, r14
    ca1a:	ee 0f       	add	r30, r30
    ca1c:	ff 1f       	adc	r31, r31
    ca1e:	ee 0f       	add	r30, r30
    ca20:	ff 1f       	adc	r31, r31
    ca22:	ec 0d       	add	r30, r12
    ca24:	fd 1d       	adc	r31, r13
    ca26:	44 8b       	std	Z+20, r20	; 0x14
			_lcd(__chr);
    ca28:	84 2f       	mov	r24, r20
    ca2a:	0e 94 a4 ac 	call	0x15948	; 0x15948 <_lcd>
			__i++;
    ca2e:	08 94       	sec
    ca30:	e1 1c       	adc	r14, r1
    ca32:	f1 1c       	adc	r15, r1
    ca34:	bc e0       	ldi	r27, 0x0C	; 12
    ca36:	eb 16       	cp	r14, r27
    ca38:	f1 04       	cpc	r15, r1
    ca3a:	1c f0       	brlt	.+6      	; 0xca42 <_menu_datetime+0x216>
    ca3c:	eb e0       	ldi	r30, 0x0B	; 11
    ca3e:	ee 2e       	mov	r14, r30
    ca40:	f1 2c       	mov	r15, r1
			if(__i > 11)
				__i = 11;
			lcd_xy(__map[__i][0], __map[__i][1]);
    ca42:	f7 01       	movw	r30, r14
    ca44:	ee 0f       	add	r30, r30
    ca46:	ff 1f       	adc	r31, r31
    ca48:	ee 0f       	add	r30, r30
    ca4a:	ff 1f       	adc	r31, r31
    ca4c:	ec 0d       	add	r30, r12
    ca4e:	fd 1d       	adc	r31, r13
    ca50:	82 89       	ldd	r24, Z+18	; 0x12
    ca52:	63 89       	ldd	r22, Z+19	; 0x13
    ca54:	0e 94 ca ac 	call	0x15994	; 0x15994 <lcd_xy>
LEWAT:		;
		}
		if(__key == _KEY_SHIFT){
    ca58:	1b 37       	cpi	r17, 0x7B	; 123
    ca5a:	59 f4       	brne	.+22     	; 0xca72 <_menu_datetime+0x246>
			__i++;
    ca5c:	08 94       	sec
    ca5e:	e1 1c       	adc	r14, r1
    ca60:	f1 1c       	adc	r15, r1
    ca62:	8c e0       	ldi	r24, 0x0C	; 12
    ca64:	e8 16       	cp	r14, r24
    ca66:	f1 04       	cpc	r15, r1
    ca68:	6c f0       	brlt	.+26     	; 0xca84 <_menu_datetime+0x258>
    ca6a:	6b e0       	ldi	r22, 0x0B	; 11
    ca6c:	e6 2e       	mov	r14, r22
    ca6e:	f1 2c       	mov	r15, r1
    ca70:	09 c0       	rjmp	.+18     	; 0xca84 <_menu_datetime+0x258>
			if(__i > 11)
				__i = 11;
			lcd_xy(__map[__i][0], __map[__i][1]);
		}
		if(__key == _KEY_CLEAR){
    ca72:	17 37       	cpi	r17, 0x77	; 119
    ca74:	99 f4       	brne	.+38     	; 0xca9c <_menu_datetime+0x270>
			__i--;
    ca76:	08 94       	sec
    ca78:	e1 08       	sbc	r14, r1
    ca7a:	f1 08       	sbc	r15, r1
    ca7c:	f7 fe       	sbrs	r15, 7
    ca7e:	02 c0       	rjmp	.+4      	; 0xca84 <_menu_datetime+0x258>
    ca80:	ee 24       	eor	r14, r14
    ca82:	ff 24       	eor	r15, r15
			if(__i <= 0)
				__i = 0;
			lcd_xy(__map[__i][0], __map[__i][1]);
    ca84:	f7 01       	movw	r30, r14
    ca86:	ee 0f       	add	r30, r30
    ca88:	ff 1f       	adc	r31, r31
    ca8a:	ee 0f       	add	r30, r30
    ca8c:	ff 1f       	adc	r31, r31
    ca8e:	ec 0d       	add	r30, r12
    ca90:	fd 1d       	adc	r31, r13
    ca92:	82 89       	ldd	r24, Z+18	; 0x12
    ca94:	63 89       	ldd	r22, Z+19	; 0x13
    ca96:	0e 94 ca ac 	call	0x15994	; 0x15994 <lcd_xy>
    ca9a:	61 cf       	rjmp	.-318    	; 0xc95e <_menu_datetime+0x132>
		}
		if(__key == _KEY_CANCEL)
    ca9c:	17 3e       	cpi	r17, 0xE7	; 231
    ca9e:	09 f4       	brne	.+2      	; 0xcaa2 <_menu_datetime+0x276>
    caa0:	49 c0       	rjmp	.+146    	; 0xcb34 <_menu_datetime+0x308>
			break;
		if(__key == _KEY_ENTER){
    caa2:	17 3b       	cpi	r17, 0xB7	; 183
    caa4:	09 f0       	breq	.+2      	; 0xcaa8 <_menu_datetime+0x27c>
    caa6:	5b cf       	rjmp	.-330    	; 0xc95e <_menu_datetime+0x132>
    caa8:	20 e0       	ldi	r18, 0x00	; 0
    caaa:	30 e0       	ldi	r19, 0x00	; 0
    caac:	40 e0       	ldi	r20, 0x00	; 0
    caae:	50 e0       	ldi	r21, 0x00	; 0
			for(__i = 0, __ii = 0; __i < 6; __i++, __ii++){
				if(__i == 2 || __i == 4)
					__ii++;
				__date[__ii] = __map[__i][2];
    cab0:	be 01       	movw	r22, r28
    cab2:	6f 5f       	subi	r22, 0xFF	; 255
    cab4:	7f 4f       	sbci	r23, 0xFF	; 255
		}
		if(__key == _KEY_CANCEL)
			break;
		if(__key == _KEY_ENTER){
			for(__i = 0, __ii = 0; __i < 6; __i++, __ii++){
				if(__i == 2 || __i == 4)
    cab6:	22 30       	cpi	r18, 0x02	; 2
    cab8:	31 05       	cpc	r19, r1
    caba:	19 f0       	breq	.+6      	; 0xcac2 <_menu_datetime+0x296>
    cabc:	24 30       	cpi	r18, 0x04	; 4
    cabe:	31 05       	cpc	r19, r1
    cac0:	11 f4       	brne	.+4      	; 0xcac6 <_menu_datetime+0x29a>
					__ii++;
    cac2:	4f 5f       	subi	r20, 0xFF	; 255
    cac4:	5f 4f       	sbci	r21, 0xFF	; 255
				__date[__ii] = __map[__i][2];
    cac6:	fb 01       	movw	r30, r22
    cac8:	e4 0f       	add	r30, r20
    caca:	f5 1f       	adc	r31, r21
    cacc:	d4 01       	movw	r26, r8
    cace:	8c 91       	ld	r24, X
    cad0:	80 83       	st	Z, r24
			lcd_xy(__map[__i][0], __map[__i][1]);
		}
		if(__key == _KEY_CANCEL)
			break;
		if(__key == _KEY_ENTER){
			for(__i = 0, __ii = 0; __i < 6; __i++, __ii++){
    cad2:	2f 5f       	subi	r18, 0xFF	; 255
    cad4:	3f 4f       	sbci	r19, 0xFF	; 255
    cad6:	84 e0       	ldi	r24, 0x04	; 4
    cad8:	90 e0       	ldi	r25, 0x00	; 0
    cada:	88 0e       	add	r8, r24
    cadc:	99 1e       	adc	r9, r25
    cade:	26 30       	cpi	r18, 0x06	; 6
    cae0:	31 05       	cpc	r19, r1
    cae2:	19 f0       	breq	.+6      	; 0xcaea <_menu_datetime+0x2be>
    cae4:	4f 5f       	subi	r20, 0xFF	; 255
    cae6:	5f 4f       	sbci	r21, 0xFF	; 255
    cae8:	e6 cf       	rjmp	.-52     	; 0xcab6 <_menu_datetime+0x28a>
    caea:	60 e0       	ldi	r22, 0x00	; 0
    caec:	70 e0       	ldi	r23, 0x00	; 0
				__date[__ii] = __map[__i][2];
			}
			for(__i = 6, __ii = 0; __i < 12; __i++, __ii++){
				if(__i == 8 || __i == 10)
					__ii++;
				__time[__ii] = __map[__i][2];
    caee:	ae 01       	movw	r20, r28
    caf0:	46 5f       	subi	r20, 0xF6	; 246
    caf2:	5f 4f       	sbci	r21, 0xFF	; 255
				if(__i == 2 || __i == 4)
					__ii++;
				__date[__ii] = __map[__i][2];
			}
			for(__i = 6, __ii = 0; __i < 12; __i++, __ii++){
				if(__i == 8 || __i == 10)
    caf4:	28 30       	cpi	r18, 0x08	; 8
    caf6:	31 05       	cpc	r19, r1
    caf8:	19 f0       	breq	.+6      	; 0xcb00 <_menu_datetime+0x2d4>
    cafa:	2a 30       	cpi	r18, 0x0A	; 10
    cafc:	31 05       	cpc	r19, r1
    cafe:	11 f4       	brne	.+4      	; 0xcb04 <_menu_datetime+0x2d8>
					__ii++;
    cb00:	6f 5f       	subi	r22, 0xFF	; 255
    cb02:	7f 4f       	sbci	r23, 0xFF	; 255
				__time[__ii] = __map[__i][2];
    cb04:	fa 01       	movw	r30, r20
    cb06:	e6 0f       	add	r30, r22
    cb08:	f7 1f       	adc	r31, r23
    cb0a:	d5 01       	movw	r26, r10
    cb0c:	8c 91       	ld	r24, X
    cb0e:	80 83       	st	Z, r24
			for(__i = 0, __ii = 0; __i < 6; __i++, __ii++){
				if(__i == 2 || __i == 4)
					__ii++;
				__date[__ii] = __map[__i][2];
			}
			for(__i = 6, __ii = 0; __i < 12; __i++, __ii++){
    cb10:	2f 5f       	subi	r18, 0xFF	; 255
    cb12:	3f 4f       	sbci	r19, 0xFF	; 255
    cb14:	84 e0       	ldi	r24, 0x04	; 4
    cb16:	90 e0       	ldi	r25, 0x00	; 0
    cb18:	a8 0e       	add	r10, r24
    cb1a:	b9 1e       	adc	r11, r25
    cb1c:	2c 30       	cpi	r18, 0x0C	; 12
    cb1e:	31 05       	cpc	r19, r1
    cb20:	19 f0       	breq	.+6      	; 0xcb28 <_menu_datetime+0x2fc>
    cb22:	6f 5f       	subi	r22, 0xFF	; 255
    cb24:	7f 4f       	sbci	r23, 0xFF	; 255
    cb26:	e6 cf       	rjmp	.-52     	; 0xcaf4 <_menu_datetime+0x2c8>
				if(__i == 8 || __i == 10)
					__ii++;
				__time[__ii] = __map[__i][2];
			}
			_datetime(_DATETIME_WRITE, __date, __time);
    cb28:	81 e0       	ldi	r24, 0x01	; 1
    cb2a:	be 01       	movw	r22, r28
    cb2c:	6f 5f       	subi	r22, 0xFF	; 255
    cb2e:	7f 4f       	sbci	r23, 0xFF	; 255
    cb30:	0e 94 4f b1 	call	0x1629e	; 0x1629e <_datetime>
			break;
		}
	}
	CURSOR_HIDE;
    cb34:	8c e0       	ldi	r24, 0x0C	; 12
    cb36:	0e 94 37 ac 	call	0x1586e	; 0x1586e <lcd_command>
}
    cb3a:	ce 5b       	subi	r28, 0xBE	; 190
    cb3c:	df 4f       	sbci	r29, 0xFF	; 255
    cb3e:	0f b6       	in	r0, 0x3f	; 63
    cb40:	f8 94       	cli
    cb42:	de bf       	out	0x3e, r29	; 62
    cb44:	0f be       	out	0x3f, r0	; 63
    cb46:	cd bf       	out	0x3d, r28	; 61
    cb48:	cf 91       	pop	r28
    cb4a:	df 91       	pop	r29
    cb4c:	1f 91       	pop	r17
    cb4e:	0f 91       	pop	r16
    cb50:	ff 90       	pop	r15
    cb52:	ef 90       	pop	r14
    cb54:	df 90       	pop	r13
    cb56:	cf 90       	pop	r12
    cb58:	bf 90       	pop	r11
    cb5a:	af 90       	pop	r10
    cb5c:	9f 90       	pop	r9
    cb5e:	8f 90       	pop	r8
    cb60:	08 95       	ret

0000cb62 <FSettingDatetime>:
	 }
     return Result;
}

char FSettingDatetime(){
     _menu_datetime();
    cb62:	0e 94 16 64 	call	0xc82c	; 0xc82c <_menu_datetime>
     return MENU_DONE;
}
    cb66:	81 e0       	ldi	r24, 0x01	; 1
    cb68:	08 95       	ret

0000cb6a <menu_FIP>:
	 }
  return Result;
}


char menu_FIP(char *xFIP,char *sFIPUsed){
    cb6a:	4f 92       	push	r4
    cb6c:	5f 92       	push	r5
    cb6e:	6f 92       	push	r6
    cb70:	7f 92       	push	r7
    cb72:	8f 92       	push	r8
    cb74:	9f 92       	push	r9
    cb76:	af 92       	push	r10
    cb78:	bf 92       	push	r11
    cb7a:	cf 92       	push	r12
    cb7c:	df 92       	push	r13
    cb7e:	ef 92       	push	r14
    cb80:	ff 92       	push	r15
    cb82:	0f 93       	push	r16
    cb84:	1f 93       	push	r17
    cb86:	df 93       	push	r29
    cb88:	cf 93       	push	r28
    cb8a:	cd b7       	in	r28, 0x3d	; 61
    cb8c:	de b7       	in	r29, 0x3e	; 62
    cb8e:	a2 97       	sbiw	r28, 0x22	; 34
    cb90:	0f b6       	in	r0, 0x3f	; 63
    cb92:	f8 94       	cli
    cb94:	de bf       	out	0x3e, r29	; 62
    cb96:	0f be       	out	0x3f, r0	; 63
    cb98:	cd bf       	out	0x3d, r28	; 61
    cb9a:	7c 01       	movw	r14, r24
    cb9c:	6b 01       	movw	r12, r22

       char KeyPressed=0,KeyChar;
       char Result=FIP_NONE;
       char FIP[8],strPumpL[3],strPumpR[3],lcdteks[20];

       switch(stEnterFIP){
    cb9e:	80 91 bf 02 	lds	r24, 0x02BF
    cba2:	81 30       	cpi	r24, 0x01	; 1
    cba4:	09 f4       	brne	.+2      	; 0xcba8 <menu_FIP+0x3e>
    cba6:	cf c0       	rjmp	.+414    	; 0xcd46 <menu_FIP+0x1dc>
    cba8:	81 30       	cpi	r24, 0x01	; 1
    cbaa:	20 f0       	brcs	.+8      	; 0xcbb4 <menu_FIP+0x4a>
    cbac:	82 30       	cpi	r24, 0x02	; 2
    cbae:	09 f0       	breq	.+2      	; 0xcbb2 <menu_FIP+0x48>
    cbb0:	4c c1       	rjmp	.+664    	; 0xce4a <menu_FIP+0x2e0>
    cbb2:	49 c1       	rjmp	.+658    	; 0xce46 <menu_FIP+0x2dc>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    cbb4:	8e 01       	movw	r16, r28
    cbb6:	09 5f       	subi	r16, 0xF9	; 249
    cbb8:	1f 4f       	sbci	r17, 0xFF	; 255
    cbba:	c8 01       	movw	r24, r16
    cbbc:	65 e4       	ldi	r22, 0x45	; 69
    cbbe:	70 e0       	ldi	r23, 0x00	; 0
    cbc0:	48 e0       	ldi	r20, 0x08	; 8
    cbc2:	50 e0       	ldi	r21, 0x00	; 0
    cbc4:	2d ef       	ldi	r18, 0xFD	; 253
    cbc6:	32 e1       	ldi	r19, 0x12	; 18
    cbc8:	0e 94 f1 b3 	call	0x167e2	; 0x167e2 <__eerd_block>
 	   case efInit:
	 	    eeprom_read_block((void*) &FIP, (const void*) &DefPumpMap, 8);
		    lcd_clear(); 
    cbcc:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
    cbd0:	f8 01       	movw	r30, r16
    cbd2:	20 e0       	ldi	r18, 0x00	; 0
    cbd4:	30 e0       	ldi	r19, 0x00	; 0
    cbd6:	07 c0       	rjmp	.+14     	; 0xcbe6 <menu_FIP+0x7c>
		    for (iLoop=0;iLoop<8;iLoop++){
			     if (FIP[iLoop]>99) FIP[iLoop]=0;
    cbd8:	80 81       	ld	r24, Z
    cbda:	84 36       	cpi	r24, 0x64	; 100
    cbdc:	08 f0       	brcs	.+2      	; 0xcbe0 <menu_FIP+0x76>
    cbde:	10 82       	st	Z, r1
    cbe0:	2f 5f       	subi	r18, 0xFF	; 255
    cbe2:	3f 4f       	sbci	r19, 0xFF	; 255
    cbe4:	31 96       	adiw	r30, 0x01	; 1

       switch(stEnterFIP){
 	   case efInit:
	 	    eeprom_read_block((void*) &FIP, (const void*) &DefPumpMap, 8);
		    lcd_clear(); 
		    for (iLoop=0;iLoop<8;iLoop++){
    cbe6:	28 30       	cpi	r18, 0x08	; 8
    cbe8:	31 05       	cpc	r19, r1
    cbea:	b0 f3       	brcs	.-20     	; 0xcbd8 <menu_FIP+0x6e>
			     if (FIP[iLoop]>99) FIP[iLoop]=0;
		    }
		    for(iLoop=0;iLoop<4;iLoop++){
    cbec:	10 92 bd 02 	sts	0x02BD, r1
    cbf0:	10 92 bc 02 	sts	0x02BC, r1
	     }String[Size]=0;
	 }
}

void leadingZero(char Val,char *StrResult){
     sprintf_P(StrResult,PSTR("%.2d"),Val);
    cbf4:	5e 01       	movw	r10, r28
    cbf6:	08 94       	sec
    cbf8:	a1 1c       	adc	r10, r1
    cbfa:	b1 1c       	adc	r11, r1
    cbfc:	54 e8       	ldi	r21, 0x84	; 132
    cbfe:	c5 2e       	mov	r12, r21
    cc00:	5d e0       	ldi	r21, 0x0D	; 13
    cc02:	d5 2e       	mov	r13, r21
    cc04:	47 e0       	ldi	r20, 0x07	; 7
    cc06:	44 2e       	mov	r4, r20
    cc08:	51 2c       	mov	r5, r1
    cc0a:	4c 0e       	add	r4, r28
    cc0c:	5d 1e       	adc	r5, r29
		    for (iLoop=0;iLoop<8;iLoop++){
			     if (FIP[iLoop]>99) FIP[iLoop]=0;
		    }
		    for(iLoop=0;iLoop<4;iLoop++){
		        leadingZero(FIP[iLoop],strPumpL);leadingZero(FIP[iLoop+4],strPumpR);
                sprintf_P(lcdteks,PSTR("%d.P%s | %d.P%s"),(iLoop+1),strPumpL,(iLoop+5),strPumpR);
    cc0e:	34 e0       	ldi	r19, 0x04	; 4
    cc10:	e3 2e       	mov	r14, r19
    cc12:	f1 2c       	mov	r15, r1
    cc14:	ec 0e       	add	r14, r28
    cc16:	fd 1e       	adc	r15, r29
    cc18:	2b e0       	ldi	r18, 0x0B	; 11
    cc1a:	62 2e       	mov	r6, r18
    cc1c:	71 2c       	mov	r7, r1
    cc1e:	6c 0e       	add	r6, r28
    cc20:	7d 1e       	adc	r7, r29
    cc22:	8e 01       	movw	r16, r28
    cc24:	01 5f       	subi	r16, 0xF1	; 241
    cc26:	1f 4f       	sbci	r17, 0xFF	; 255
    cc28:	9d ed       	ldi	r25, 0xDD	; 221
    cc2a:	89 2e       	mov	r8, r25
    cc2c:	9b e1       	ldi	r25, 0x1B	; 27
    cc2e:	99 2e       	mov	r9, r25
    cc30:	64 c0       	rjmp	.+200    	; 0xccfa <menu_FIP+0x190>
	     }String[Size]=0;
	 }
}

void leadingZero(char Val,char *StrResult){
     sprintf_P(StrResult,PSTR("%.2d"),Val);
    cc32:	00 d0       	rcall	.+0      	; 0xcc34 <menu_FIP+0xca>
    cc34:	00 d0       	rcall	.+0      	; 0xcc36 <menu_FIP+0xcc>
    cc36:	00 d0       	rcall	.+0      	; 0xcc38 <menu_FIP+0xce>
    cc38:	2d b7       	in	r18, 0x3d	; 61
    cc3a:	3e b7       	in	r19, 0x3e	; 62
    cc3c:	2f 5f       	subi	r18, 0xFF	; 255
    cc3e:	3f 4f       	sbci	r19, 0xFF	; 255
    cc40:	ed b7       	in	r30, 0x3d	; 61
    cc42:	fe b7       	in	r31, 0x3e	; 62
    cc44:	b2 82       	std	Z+2, r11	; 0x02
    cc46:	a1 82       	std	Z+1, r10	; 0x01
    cc48:	f9 01       	movw	r30, r18
    cc4a:	d3 82       	std	Z+3, r13	; 0x03
    cc4c:	c2 82       	std	Z+2, r12	; 0x02
    cc4e:	a4 0d       	add	r26, r4
    cc50:	b5 1d       	adc	r27, r5
    cc52:	8c 91       	ld	r24, X
    cc54:	84 83       	std	Z+4, r24	; 0x04
    cc56:	15 82       	std	Z+5, r1	; 0x05
    cc58:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    cc5c:	ad b7       	in	r26, 0x3d	; 61
    cc5e:	be b7       	in	r27, 0x3e	; 62
    cc60:	11 96       	adiw	r26, 0x01	; 1
    cc62:	ed b7       	in	r30, 0x3d	; 61
    cc64:	fe b7       	in	r31, 0x3e	; 62
    cc66:	f2 82       	std	Z+2, r15	; 0x02
    cc68:	e1 82       	std	Z+1, r14	; 0x01
    cc6a:	13 96       	adiw	r26, 0x03	; 3
    cc6c:	dc 92       	st	X, r13
    cc6e:	ce 92       	st	-X, r12
    cc70:	12 97       	sbiw	r26, 0x02	; 2
    cc72:	e0 91 bc 02 	lds	r30, 0x02BC
    cc76:	f0 91 bd 02 	lds	r31, 0x02BD
    cc7a:	e6 0d       	add	r30, r6
    cc7c:	f7 1d       	adc	r31, r7
    cc7e:	80 81       	ld	r24, Z
    cc80:	14 96       	adiw	r26, 0x04	; 4
    cc82:	8c 93       	st	X, r24
    cc84:	14 97       	sbiw	r26, 0x04	; 4
    cc86:	15 96       	adiw	r26, 0x05	; 5
    cc88:	1c 92       	st	X, r1
    cc8a:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
		    for (iLoop=0;iLoop<8;iLoop++){
			     if (FIP[iLoop]>99) FIP[iLoop]=0;
		    }
		    for(iLoop=0;iLoop<4;iLoop++){
		        leadingZero(FIP[iLoop],strPumpL);leadingZero(FIP[iLoop+4],strPumpR);
                sprintf_P(lcdteks,PSTR("%d.P%s | %d.P%s"),(iLoop+1),strPumpL,(iLoop+5),strPumpR);
    cc8e:	80 91 bc 02 	lds	r24, 0x02BC
    cc92:	90 91 bd 02 	lds	r25, 0x02BD
    cc96:	00 d0       	rcall	.+0      	; 0xcc98 <menu_FIP+0x12e>
    cc98:	00 d0       	rcall	.+0      	; 0xcc9a <menu_FIP+0x130>
    cc9a:	00 d0       	rcall	.+0      	; 0xcc9c <menu_FIP+0x132>
    cc9c:	ed b7       	in	r30, 0x3d	; 61
    cc9e:	fe b7       	in	r31, 0x3e	; 62
    cca0:	31 96       	adiw	r30, 0x01	; 1
    cca2:	ad b7       	in	r26, 0x3d	; 61
    cca4:	be b7       	in	r27, 0x3e	; 62
    cca6:	12 96       	adiw	r26, 0x02	; 2
    cca8:	1c 93       	st	X, r17
    ccaa:	0e 93       	st	-X, r16
    ccac:	11 97       	sbiw	r26, 0x01	; 1
    ccae:	93 82       	std	Z+3, r9	; 0x03
    ccb0:	82 82       	std	Z+2, r8	; 0x02
    ccb2:	01 96       	adiw	r24, 0x01	; 1
    ccb4:	95 83       	std	Z+5, r25	; 0x05
    ccb6:	84 83       	std	Z+4, r24	; 0x04
    ccb8:	b7 82       	std	Z+7, r11	; 0x07
    ccba:	a6 82       	std	Z+6, r10	; 0x06
    ccbc:	04 96       	adiw	r24, 0x04	; 4
    ccbe:	91 87       	std	Z+9, r25	; 0x09
    ccc0:	80 87       	std	Z+8, r24	; 0x08
    ccc2:	f3 86       	std	Z+11, r15	; 0x0b
    ccc4:	e2 86       	std	Z+10, r14	; 0x0a
    ccc6:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
			    lcd_print((iLoop+1),1,lcdteks);
    ccca:	ed b7       	in	r30, 0x3d	; 61
    cccc:	fe b7       	in	r31, 0x3e	; 62
    ccce:	3c 96       	adiw	r30, 0x0c	; 12
    ccd0:	0f b6       	in	r0, 0x3f	; 63
    ccd2:	f8 94       	cli
    ccd4:	fe bf       	out	0x3e, r31	; 62
    ccd6:	0f be       	out	0x3f, r0	; 63
    ccd8:	ed bf       	out	0x3d, r30	; 61
    ccda:	80 91 bc 02 	lds	r24, 0x02BC
    ccde:	8f 5f       	subi	r24, 0xFF	; 255
    cce0:	61 e0       	ldi	r22, 0x01	; 1
    cce2:	a8 01       	movw	r20, r16
    cce4:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
	 	    eeprom_read_block((void*) &FIP, (const void*) &DefPumpMap, 8);
		    lcd_clear(); 
		    for (iLoop=0;iLoop<8;iLoop++){
			     if (FIP[iLoop]>99) FIP[iLoop]=0;
		    }
		    for(iLoop=0;iLoop<4;iLoop++){
    cce8:	80 91 bc 02 	lds	r24, 0x02BC
    ccec:	90 91 bd 02 	lds	r25, 0x02BD
    ccf0:	01 96       	adiw	r24, 0x01	; 1
    ccf2:	90 93 bd 02 	sts	0x02BD, r25
    ccf6:	80 93 bc 02 	sts	0x02BC, r24
    ccfa:	a0 91 bc 02 	lds	r26, 0x02BC
    ccfe:	b0 91 bd 02 	lds	r27, 0x02BD
    cd02:	a4 30       	cpi	r26, 0x04	; 4
    cd04:	b1 05       	cpc	r27, r1
    cd06:	08 f4       	brcc	.+2      	; 0xcd0a <menu_FIP+0x1a0>
    cd08:	94 cf       	rjmp	.-216    	; 0xcc32 <menu_FIP+0xc8>
		        leadingZero(FIP[iLoop],strPumpL);leadingZero(FIP[iLoop+4],strPumpR);
                sprintf_P(lcdteks,PSTR("%d.P%s | %d.P%s"),(iLoop+1),strPumpL,(iLoop+5),strPumpR);
			    lcd_print((iLoop+1),1,lcdteks);
			}
		    lcd_printf(1,15,PSTR("FIP:_"));    //"1.P01 | 5.P05 FIP:_ "                                                                      
    cd0a:	81 e0       	ldi	r24, 0x01	; 1
    cd0c:	6f e0       	ldi	r22, 0x0F	; 15
    cd0e:	47 ed       	ldi	r20, 0xD7	; 215
    cd10:	5b e1       	ldi	r21, 0x1B	; 27
    cd12:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		    lcd_printf(2,15,PSTR("     "));    //"2.P02 | 6.P05       "
    cd16:	82 e0       	ldi	r24, 0x02	; 2
    cd18:	6f e0       	ldi	r22, 0x0F	; 15
    cd1a:	41 ed       	ldi	r20, 0xD1	; 209
    cd1c:	5b e1       	ldi	r21, 0x1B	; 27
    cd1e:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		    lcd_printf(3,15,PSTR("#)OK "));    //"3.P03 | 7.P07 #)OK  "
    cd22:	83 e0       	ldi	r24, 0x03	; 3
    cd24:	6f e0       	ldi	r22, 0x0F	; 15
    cd26:	4b ec       	ldi	r20, 0xCB	; 203
    cd28:	5b e1       	ldi	r21, 0x1B	; 27
    cd2a:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
	        lcd_printf(4,15,PSTR("*)Exit"));   //"4.P04 | 8.P08 *)Exit"				
    cd2e:	84 e0       	ldi	r24, 0x04	; 4
    cd30:	6f e0       	ldi	r22, 0x0F	; 15
    cd32:	44 ec       	ldi	r20, 0xC4	; 196
    cd34:	5b e1       	ldi	r21, 0x1B	; 27
    cd36:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		    iLoop=0;
    cd3a:	10 92 bd 02 	sts	0x02BD, r1
    cd3e:	10 92 bc 02 	sts	0x02BC, r1
		    stEnterFIP=efFIPInput;
    cd42:	81 e0       	ldi	r24, 0x01	; 1
    cd44:	7d c0       	rjmp	.+250    	; 0xce40 <menu_FIP+0x2d6>
	        break;
	   case efFIPInput:
		    iLoop++;
    cd46:	80 91 bc 02 	lds	r24, 0x02BC
    cd4a:	90 91 bd 02 	lds	r25, 0x02BD
    cd4e:	01 96       	adiw	r24, 0x01	; 1
    cd50:	90 93 bd 02 	sts	0x02BD, r25
    cd54:	80 93 bc 02 	sts	0x02BC, r24
		    KeyPressed=_key_scan(1);
    cd58:	81 e0       	ldi	r24, 0x01	; 1
    cd5a:	0e 94 84 ae 	call	0x15d08	; 0x15d08 <_key_scan>
    cd5e:	08 2f       	mov	r16, r24
		    KeyChar=_key_btn(KeyPressed);
    cd60:	0e 94 e5 ad 	call	0x15bca	; 0x15bca <_key_btn>
    cd64:	98 2f       	mov	r25, r24
		    if ((KeyChar>='1')&&(KeyChar<='8')){
    cd66:	18 2f       	mov	r17, r24
    cd68:	11 53       	subi	r17, 0x31	; 49
    cd6a:	18 30       	cpi	r17, 0x08	; 8
    cd6c:	60 f4       	brcc	.+24     	; 0xcd86 <menu_FIP+0x21c>
		 	     if (KeyCharLast!=KeyChar){
    cd6e:	80 91 4a 01 	lds	r24, 0x014A
    cd72:	89 17       	cp	r24, r25
    cd74:	41 f0       	breq	.+16     	; 0xcd86 <menu_FIP+0x21c>
				     KeyCharLast=KeyChar;
    cd76:	90 93 4a 01 	sts	0x014A, r25
				     iLoop=1000;
    cd7a:	88 ee       	ldi	r24, 0xE8	; 232
    cd7c:	93 e0       	ldi	r25, 0x03	; 3
    cd7e:	90 93 bd 02 	sts	0x02BD, r25
    cd82:	80 93 bc 02 	sts	0x02BC, r24
                 }
		    }
 		    if ((iLoop%2000)==0){
    cd86:	80 91 bc 02 	lds	r24, 0x02BC
    cd8a:	90 91 bd 02 	lds	r25, 0x02BD
    cd8e:	60 ed       	ldi	r22, 0xD0	; 208
    cd90:	77 e0       	ldi	r23, 0x07	; 7
    cd92:	0e 94 0a b7 	call	0x16e14	; 0x16e14 <__udivmodhi4>
    cd96:	89 2b       	or	r24, r25
    cd98:	39 f4       	brne	.+14     	; 0xcda8 <menu_FIP+0x23e>
		        lcd_xy(1,19);_lcd('_'); 
    cd9a:	81 e0       	ldi	r24, 0x01	; 1
    cd9c:	63 e1       	ldi	r22, 0x13	; 19
    cd9e:	0e 94 ca ac 	call	0x15994	; 0x15994 <lcd_xy>
    cda2:	8f e5       	ldi	r24, 0x5F	; 95
    cda4:	0e 94 a4 ac 	call	0x15948	; 0x15948 <_lcd>
			   }
           if ((iLoop%2000)==1000){
    cda8:	80 91 bc 02 	lds	r24, 0x02BC
    cdac:	90 91 bd 02 	lds	r25, 0x02BD
    cdb0:	60 ed       	ldi	r22, 0xD0	; 208
    cdb2:	77 e0       	ldi	r23, 0x07	; 7
    cdb4:	0e 94 0a b7 	call	0x16e14	; 0x16e14 <__udivmodhi4>
    cdb8:	88 5e       	subi	r24, 0xE8	; 232
    cdba:	93 40       	sbci	r25, 0x03	; 3
    cdbc:	41 f4       	brne	.+16     	; 0xcdce <menu_FIP+0x264>
			    lcd_xy(1,19);_lcd(KeyCharLast); 
    cdbe:	81 e0       	ldi	r24, 0x01	; 1
    cdc0:	63 e1       	ldi	r22, 0x13	; 19
    cdc2:	0e 94 ca ac 	call	0x15994	; 0x15994 <lcd_xy>
    cdc6:	80 91 4a 01 	lds	r24, 0x014A
    cdca:	0e 94 a4 ac 	call	0x15948	; 0x15948 <_lcd>
			   }

		   if (((KeyChar>='1')&&(KeyChar<='8'))||(KeyPressed==_KEY_ENTER)&&(KeyCharLast!=' ')){ 
    cdce:	18 30       	cpi	r17, 0x08	; 8
    cdd0:	30 f0       	brcs	.+12     	; 0xcdde <menu_FIP+0x274>
    cdd2:	07 3b       	cpi	r16, 0xB7	; 183
    cdd4:	91 f5       	brne	.+100    	; 0xce3a <menu_FIP+0x2d0>
    cdd6:	80 91 4a 01 	lds	r24, 0x014A
    cdda:	80 32       	cpi	r24, 0x20	; 32
    cddc:	b1 f1       	breq	.+108    	; 0xce4a <menu_FIP+0x2e0>
		         FIP_Used=FIP[KeyCharLast-'1'];
    cdde:	80 91 4a 01 	lds	r24, 0x014A
    cde2:	fe 01       	movw	r30, r28
    cde4:	ba 97       	sbiw	r30, 0x2a	; 42
    cde6:	e8 0f       	add	r30, r24
    cde8:	f1 1d       	adc	r31, r1
    cdea:	20 81       	ld	r18, Z
    cdec:	20 93 be 02 	sts	0x02BE, r18
				 if (FIP_Used<=99){
    cdf0:	24 36       	cpi	r18, 0x64	; 100
    cdf2:	f0 f4       	brcc	.+60     	; 0xce30 <menu_FIP+0x2c6>
                     //leadingZero(FIP_Used,sFIPUsed);
					 //xFIP[0]=FIP_Used;
					 *xFIP=FIP_Used;
    cdf4:	d7 01       	movw	r26, r14
    cdf6:	2c 93       	st	X, r18
					 sprintf_P(sFIPUsed,PSTR("%.2d"),FIP_Used);
    cdf8:	00 d0       	rcall	.+0      	; 0xcdfa <menu_FIP+0x290>
    cdfa:	00 d0       	rcall	.+0      	; 0xcdfc <menu_FIP+0x292>
    cdfc:	00 d0       	rcall	.+0      	; 0xcdfe <menu_FIP+0x294>
    cdfe:	ed b7       	in	r30, 0x3d	; 61
    ce00:	fe b7       	in	r31, 0x3e	; 62
    ce02:	31 96       	adiw	r30, 0x01	; 1
    ce04:	ad b7       	in	r26, 0x3d	; 61
    ce06:	be b7       	in	r27, 0x3e	; 62
    ce08:	12 96       	adiw	r26, 0x02	; 2
    ce0a:	dc 92       	st	X, r13
    ce0c:	ce 92       	st	-X, r12
    ce0e:	11 97       	sbiw	r26, 0x01	; 1
    ce10:	8f eb       	ldi	r24, 0xBF	; 191
    ce12:	9b e1       	ldi	r25, 0x1B	; 27
    ce14:	93 83       	std	Z+3, r25	; 0x03
    ce16:	82 83       	std	Z+2, r24	; 0x02
    ce18:	24 83       	std	Z+4, r18	; 0x04
    ce1a:	15 82       	std	Z+5, r1	; 0x05
    ce1c:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    ce20:	ed b7       	in	r30, 0x3d	; 61
    ce22:	fe b7       	in	r31, 0x3e	; 62
    ce24:	36 96       	adiw	r30, 0x06	; 6
    ce26:	0f b6       	in	r0, 0x3f	; 63
    ce28:	f8 94       	cli
    ce2a:	fe bf       	out	0x3e, r31	; 62
    ce2c:	0f be       	out	0x3f, r0	; 63
    ce2e:	ed bf       	out	0x3d, r30	; 61

					 }
				 Result=FIP_DONE;
                 stEnterFIP=efExitFIPInput;
    ce30:	82 e0       	ldi	r24, 0x02	; 2
    ce32:	80 93 bf 02 	sts	0x02BF, r24
    ce36:	80 e0       	ldi	r24, 0x00	; 0
    ce38:	09 c0       	rjmp	.+18     	; 0xce4c <menu_FIP+0x2e2>
		   }
		   else
		   if (KeyPressed==_KEY_CANCEL){
    ce3a:	07 3e       	cpi	r16, 0xE7	; 231
    ce3c:	31 f4       	brne	.+12     	; 0xce4a <menu_FIP+0x2e0>
               Result=FIP_CANCEL;
			   stEnterFIP=efExitFIPInput;
    ce3e:	82 e0       	ldi	r24, 0x02	; 2
    ce40:	80 93 bf 02 	sts	0x02BF, r24
    ce44:	03 c0       	rjmp	.+6      	; 0xce4c <menu_FIP+0x2e2>
		   }
	       break;
      case efExitFIPInput:
           stEnterFIP=efInit;
    ce46:	10 92 bf 02 	sts	0x02BF, r1
    ce4a:	81 e0       	ldi	r24, 0x01	; 1
	       break;
	 }
return Result;
}
    ce4c:	a2 96       	adiw	r28, 0x22	; 34
    ce4e:	0f b6       	in	r0, 0x3f	; 63
    ce50:	f8 94       	cli
    ce52:	de bf       	out	0x3e, r29	; 62
    ce54:	0f be       	out	0x3f, r0	; 63
    ce56:	cd bf       	out	0x3d, r28	; 61
    ce58:	cf 91       	pop	r28
    ce5a:	df 91       	pop	r29
    ce5c:	1f 91       	pop	r17
    ce5e:	0f 91       	pop	r16
    ce60:	ff 90       	pop	r15
    ce62:	ef 90       	pop	r14
    ce64:	df 90       	pop	r13
    ce66:	cf 90       	pop	r12
    ce68:	bf 90       	pop	r11
    ce6a:	af 90       	pop	r10
    ce6c:	9f 90       	pop	r9
    ce6e:	8f 90       	pop	r8
    ce70:	7f 90       	pop	r7
    ce72:	6f 90       	pop	r6
    ce74:	5f 90       	pop	r5
    ce76:	4f 90       	pop	r4
    ce78:	08 95       	ret

0000ce7a <FMenuEDCTransaction>:
	      break;
	 }
	 return Result;
}

char FMenuEDCTransaction(){
    ce7a:	0f 93       	push	r16
    ce7c:	1f 93       	push	r17
static char FIP_Used=0;
       char lcdteks[20],Result=MENU_NONE;
       char KeyPressed=0,KeyChar,FIPResult;

     Result=MENU_NONE;
	 switch(stEtransaction){
    ce7e:	80 91 b4 02 	lds	r24, 0x02B4
    ce82:	85 30       	cpi	r24, 0x05	; 5
    ce84:	09 f4       	brne	.+2      	; 0xce88 <FMenuEDCTransaction+0xe>
    ce86:	96 c0       	rjmp	.+300    	; 0xcfb4 <FMenuEDCTransaction+0x13a>
    ce88:	86 30       	cpi	r24, 0x06	; 6
    ce8a:	90 f4       	brcc	.+36     	; 0xceb0 <FMenuEDCTransaction+0x36>
    ce8c:	82 30       	cpi	r24, 0x02	; 2
    ce8e:	09 f4       	brne	.+2      	; 0xce92 <FMenuEDCTransaction+0x18>
    ce90:	52 c0       	rjmp	.+164    	; 0xcf36 <FMenuEDCTransaction+0xbc>
    ce92:	83 30       	cpi	r24, 0x03	; 3
    ce94:	30 f4       	brcc	.+12     	; 0xcea2 <FMenuEDCTransaction+0x28>
    ce96:	88 23       	and	r24, r24
    ce98:	f1 f0       	breq	.+60     	; 0xced6 <FMenuEDCTransaction+0x5c>
    ce9a:	81 30       	cpi	r24, 0x01	; 1
    ce9c:	09 f0       	breq	.+2      	; 0xcea0 <FMenuEDCTransaction+0x26>
    ce9e:	d2 c0       	rjmp	.+420    	; 0xd044 <FMenuEDCTransaction+0x1ca>
    cea0:	36 c0       	rjmp	.+108    	; 0xcf0e <FMenuEDCTransaction+0x94>
    cea2:	83 30       	cpi	r24, 0x03	; 3
    cea4:	09 f4       	brne	.+2      	; 0xcea8 <FMenuEDCTransaction+0x2e>
    cea6:	57 c0       	rjmp	.+174    	; 0xcf56 <FMenuEDCTransaction+0xdc>
    cea8:	84 30       	cpi	r24, 0x04	; 4
    ceaa:	09 f0       	breq	.+2      	; 0xceae <FMenuEDCTransaction+0x34>
    ceac:	cb c0       	rjmp	.+406    	; 0xd044 <FMenuEDCTransaction+0x1ca>
    ceae:	7c c0       	rjmp	.+248    	; 0xcfa8 <FMenuEDCTransaction+0x12e>
    ceb0:	88 30       	cpi	r24, 0x08	; 8
    ceb2:	09 f4       	brne	.+2      	; 0xceb6 <FMenuEDCTransaction+0x3c>
    ceb4:	b7 c0       	rjmp	.+366    	; 0xd024 <FMenuEDCTransaction+0x1aa>
    ceb6:	89 30       	cpi	r24, 0x09	; 9
    ceb8:	38 f4       	brcc	.+14     	; 0xcec8 <FMenuEDCTransaction+0x4e>
    ceba:	86 30       	cpi	r24, 0x06	; 6
    cebc:	09 f4       	brne	.+2      	; 0xcec0 <FMenuEDCTransaction+0x46>
    cebe:	8d c0       	rjmp	.+282    	; 0xcfda <FMenuEDCTransaction+0x160>
    cec0:	87 30       	cpi	r24, 0x07	; 7
    cec2:	09 f0       	breq	.+2      	; 0xcec6 <FMenuEDCTransaction+0x4c>
    cec4:	bf c0       	rjmp	.+382    	; 0xd044 <FMenuEDCTransaction+0x1ca>
    cec6:	8b c0       	rjmp	.+278    	; 0xcfde <FMenuEDCTransaction+0x164>
    cec8:	89 30       	cpi	r24, 0x09	; 9
    ceca:	09 f4       	brne	.+2      	; 0xcece <FMenuEDCTransaction+0x54>
    cecc:	b1 c0       	rjmp	.+354    	; 0xd030 <FMenuEDCTransaction+0x1b6>
    cece:	8a 30       	cpi	r24, 0x0A	; 10
    ced0:	09 f0       	breq	.+2      	; 0xced4 <FMenuEDCTransaction+0x5a>
    ced2:	b8 c0       	rjmp	.+368    	; 0xd044 <FMenuEDCTransaction+0x1ca>
    ced4:	b3 c0       	rjmp	.+358    	; 0xd03c <FMenuEDCTransaction+0x1c2>
	 case etInit:
	      lcd_clear();
    ced6:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
		  lcd_printf(1,1,PSTR("Select Card Type"));
    ceda:	81 e0       	ldi	r24, 0x01	; 1
    cedc:	61 e0       	ldi	r22, 0x01	; 1
    cede:	4a e4       	ldi	r20, 0x4A	; 74
    cee0:	5a e1       	ldi	r21, 0x1A	; 26
    cee2:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
          lcd_printf(1,1,PSTR("1.Debit/Flash Card  "));
    cee6:	81 e0       	ldi	r24, 0x01	; 1
    cee8:	61 e0       	ldi	r22, 0x01	; 1
    ceea:	45 e3       	ldi	r20, 0x35	; 53
    ceec:	5a e1       	ldi	r21, 0x1A	; 26
    ceee:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		  lcd_printf(2,1,PSTR("2.Credit Card       "));
    cef2:	82 e0       	ldi	r24, 0x02	; 2
    cef4:	61 e0       	ldi	r22, 0x01	; 1
    cef6:	40 e2       	ldi	r20, 0x20	; 32
    cef8:	5a e1       	ldi	r21, 0x1A	; 26
    cefa:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
	      lcd_printf(4,1,PSTR("[*]Back             "));
    cefe:	84 e0       	ldi	r24, 0x04	; 4
    cf00:	61 e0       	ldi	r22, 0x01	; 1
    cf02:	4b e0       	ldi	r20, 0x0B	; 11
    cf04:	5a e1       	ldi	r21, 0x1A	; 26
    cf06:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		  stEtransaction=etInputEDC;
    cf0a:	81 e0       	ldi	r24, 0x01	; 1
    cf0c:	63 c0       	rjmp	.+198    	; 0xcfd4 <FMenuEDCTransaction+0x15a>
	      break;
     case etInputEDC:
	 	  KeyPressed=_key_scan(1);
    cf0e:	81 e0       	ldi	r24, 0x01	; 1
    cf10:	0e 94 84 ae 	call	0x15d08	; 0x15d08 <_key_scan>
    cf14:	08 2f       	mov	r16, r24
		  KeyChar=_key_btn(KeyPressed);
    cf16:	0e 94 e5 ad 	call	0x15bca	; 0x15bca <_key_btn>
    cf1a:	98 2f       	mov	r25, r24
		  if ((KeyChar>='1')&&(KeyChar<='2')){
    cf1c:	81 53       	subi	r24, 0x31	; 49
    cf1e:	82 30       	cpi	r24, 0x02	; 2
    cf20:	30 f4       	brcc	.+12     	; 0xcf2e <FMenuEDCTransaction+0xb4>
		       EDCType=KeyChar-'0';
    cf22:	90 53       	subi	r25, 0x30	; 48
    cf24:	90 93 3f 09 	sts	0x093F, r25
		       stEtransaction=etSelectFIP;
    cf28:	82 e0       	ldi	r24, 0x02	; 2
    cf2a:	80 93 b4 02 	sts	0x02B4, r24
		     }
		  if (KeyPressed==_KEY_CANCEL)stEtransaction=etExitEDCTransaction;
    cf2e:	07 3e       	cpi	r16, 0xE7	; 231
    cf30:	09 f0       	breq	.+2      	; 0xcf34 <FMenuEDCTransaction+0xba>
    cf32:	88 c0       	rjmp	.+272    	; 0xd044 <FMenuEDCTransaction+0x1ca>
    cf34:	81 c0       	rjmp	.+258    	; 0xd038 <FMenuEDCTransaction+0x1be>
	      break;
	 case etSelectFIP:
	      FIPResult=menu_FIP(FIP_Used,strFIP_ID);
    cf36:	80 e0       	ldi	r24, 0x00	; 0
    cf38:	90 e0       	ldi	r25, 0x00	; 0
    cf3a:	6b ec       	ldi	r22, 0xCB	; 203
    cf3c:	78 e0       	ldi	r23, 0x08	; 8
    cf3e:	0e 94 b5 65 	call	0xcb6a	; 0xcb6a <menu_FIP>
		  if (FIPResult==FIP_DONE)stEtransaction=etInitMessage90;
    cf42:	88 23       	and	r24, r24
    cf44:	11 f4       	brne	.+4      	; 0xcf4a <FMenuEDCTransaction+0xd0>
    cf46:	83 e0       	ldi	r24, 0x03	; 3
    cf48:	45 c0       	rjmp	.+138    	; 0xcfd4 <FMenuEDCTransaction+0x15a>
		  else
		  if (FIPResult==FIP_CANCEL)stEtransaction=etInit;
    cf4a:	82 30       	cpi	r24, 0x02	; 2
    cf4c:	09 f0       	breq	.+2      	; 0xcf50 <FMenuEDCTransaction+0xd6>
    cf4e:	7a c0       	rjmp	.+244    	; 0xd044 <FMenuEDCTransaction+0x1ca>
    cf50:	10 92 b4 02 	sts	0x02B4, r1
    cf54:	77 c0       	rjmp	.+238    	; 0xd044 <FMenuEDCTransaction+0x1ca>
    cf56:	e5 ec       	ldi	r30, 0xC5	; 197
    cf58:	fd e0       	ldi	r31, 0x0D	; 13
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    cf5a:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    cf5c:	8d e0       	ldi	r24, 0x0D	; 13
    cf5e:	ea 3d       	cpi	r30, 0xDA	; 218
    cf60:	f8 07       	cpc	r31, r24
    cf62:	d9 f7       	brne	.-10     	; 0xcf5a <FMenuEDCTransaction+0xe0>
		  else
		  if (FIPResult==FIP_CANCEL)stEtransaction=etInit;
	      break;
     case etInitMessage90:
	      FillChar(strRef1,sizeof(strRef1),0);
	      if (EDCType==1){
    cf64:	80 91 3f 09 	lds	r24, 0x093F
    cf68:	81 30       	cpi	r24, 0x01	; 1
    cf6a:	19 f4       	brne	.+6      	; 0xcf72 <FMenuEDCTransaction+0xf8>
		      AddSpaceLag(strRef1,20);
    cf6c:	cf 01       	movw	r24, r30
    cf6e:	45 97       	sbiw	r24, 0x15	; 21
    cf70:	16 c0       	rjmp	.+44     	; 0xcf9e <FMenuEDCTransaction+0x124>
          }
		  else
	      if (EDCType==2){
    cf72:	82 30       	cpi	r24, 0x02	; 2
    cf74:	b9 f4       	brne	.+46     	; 0xcfa4 <FMenuEDCTransaction+0x12a>
		      sprintf_P(strRef1,PSTR("CREDITCARD"));
    cf76:	00 d0       	rcall	.+0      	; 0xcf78 <FMenuEDCTransaction+0xfe>
    cf78:	00 d0       	rcall	.+0      	; 0xcf7a <FMenuEDCTransaction+0x100>
    cf7a:	8f 01       	movw	r16, r30
    cf7c:	05 51       	subi	r16, 0x15	; 21
    cf7e:	10 40       	sbci	r17, 0x00	; 0
    cf80:	ed b7       	in	r30, 0x3d	; 61
    cf82:	fe b7       	in	r31, 0x3e	; 62
    cf84:	12 83       	std	Z+2, r17	; 0x02
    cf86:	01 83       	std	Z+1, r16	; 0x01
    cf88:	80 e0       	ldi	r24, 0x00	; 0
    cf8a:	9a e1       	ldi	r25, 0x1A	; 26
    cf8c:	94 83       	std	Z+4, r25	; 0x04
    cf8e:	83 83       	std	Z+3, r24	; 0x03
    cf90:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
			  AddSpaceLag(strRef1,20);
    cf94:	0f 90       	pop	r0
    cf96:	0f 90       	pop	r0
    cf98:	0f 90       	pop	r0
    cf9a:	0f 90       	pop	r0
    cf9c:	c8 01       	movw	r24, r16
    cf9e:	64 e1       	ldi	r22, 0x14	; 20
    cfa0:	0e 94 a0 2d 	call	0x5b40	; 0x5b40 <AddSpaceLag>
		  }	 
	      stEtransaction=etSendingMessage90;
    cfa4:	84 e0       	ldi	r24, 0x04	; 4
    cfa6:	16 c0       	rjmp	.+44     	; 0xcfd4 <FMenuEDCTransaction+0x15a>
	      break;
     case etSendingMessage90:
          sendMessage90();
    cfa8:	0e 94 08 4f 	call	0x9e10	; 0x9e10 <sendMessage90>
		  TimSend=0;
    cfac:	10 92 af 0d 	sts	0x0DAF, r1
          stEtransaction=etWaitReply;
    cfb0:	85 e0       	ldi	r24, 0x05	; 5
    cfb2:	10 c0       	rjmp	.+32     	; 0xcfd4 <FMenuEDCTransaction+0x15a>
	      break;
     case etWaitReply:
	      if (TimSend>TIM_SEND*2)stEtransaction=etNoConnection;
    cfb4:	80 91 af 0d 	lds	r24, 0x0DAF
    cfb8:	85 31       	cpi	r24, 0x15	; 21
    cfba:	18 f0       	brcs	.+6      	; 0xcfc2 <FMenuEDCTransaction+0x148>
    cfbc:	88 e0       	ldi	r24, 0x08	; 8
    cfbe:	80 93 b4 02 	sts	0x02B4, r24
		  if ((IsMessage91==True)||(IsMessage09==True))
    cfc2:	80 91 aa 01 	lds	r24, 0x01AA
    cfc6:	81 30       	cpi	r24, 0x01	; 1
    cfc8:	21 f0       	breq	.+8      	; 0xcfd2 <FMenuEDCTransaction+0x158>
    cfca:	80 91 a6 01 	lds	r24, 0x01A6
    cfce:	81 30       	cpi	r24, 0x01	; 1
    cfd0:	c9 f5       	brne	.+114    	; 0xd044 <FMenuEDCTransaction+0x1ca>
		       stEtransaction=etSuccesEDC;
    cfd2:	86 e0       	ldi	r24, 0x06	; 6
    cfd4:	80 93 b4 02 	sts	0x02B4, r24
    cfd8:	35 c0       	rjmp	.+106    	; 0xd044 <FMenuEDCTransaction+0x1ca>
	      break;
     case etSuccesEDC:
	      stEtransaction=etDisplayFreeMessage;
    cfda:	87 e0       	ldi	r24, 0x07	; 7
    cfdc:	fb cf       	rjmp	.-10     	; 0xcfd4 <FMenuEDCTransaction+0x15a>
	      break;
     case etDisplayFreeMessage:
	      if (IsMessage09==True){
    cfde:	80 91 a6 01 	lds	r24, 0x01A6
    cfe2:	81 30       	cpi	r24, 0x01	; 1
    cfe4:	19 f5       	brne	.+70     	; 0xd02c <FMenuEDCTransaction+0x1b2>
		      IsMessage09=False;
    cfe6:	10 92 a6 01 	sts	0x01A6, r1
	          procMessage09();
    cfea:	0e 94 28 17 	call	0x2e50	; 0x2e50 <procMessage09>
		      lcd_clear();
    cfee:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
		      lcd_print(1,1,strFreeMessageLine1);
    cff2:	81 e0       	ldi	r24, 0x01	; 1
    cff4:	61 e0       	ldi	r22, 0x01	; 1
    cff6:	46 ec       	ldi	r20, 0xC6	; 198
    cff8:	59 e0       	ldi	r21, 0x09	; 9
    cffa:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
		      lcd_print(2,1,strFreeMessageLine2);
    cffe:	82 e0       	ldi	r24, 0x02	; 2
    d000:	61 e0       	ldi	r22, 0x01	; 1
    d002:	45 eb       	ldi	r20, 0xB5	; 181
    d004:	58 e0       	ldi	r21, 0x08	; 8
    d006:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
		      lcd_print(3,1,strFreeMessageLine3);
    d00a:	83 e0       	ldi	r24, 0x03	; 3
    d00c:	61 e0       	ldi	r22, 0x01	; 1
    d00e:	40 e5       	ldi	r20, 0x50	; 80
    d010:	59 e0       	ldi	r21, 0x09	; 9
    d012:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
			  lcd_print(4,1,strFreeMessageLine4);
    d016:	84 e0       	ldi	r24, 0x04	; 4
    d018:	61 e0       	ldi	r22, 0x01	; 1
    d01a:	4d e0       	ldi	r20, 0x0D	; 13
    d01c:	5d e0       	ldi	r21, 0x0D	; 13
    d01e:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
    d022:	02 c0       	rjmp	.+4      	; 0xd028 <FMenuEDCTransaction+0x1ae>
			  TimDisplay=0;
			  }
		  stEtransaction=etDelayExit;
	      break;
     case etNoConnection:
	      lcd_clear();
    d024:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
		  TimDisplay=0;
    d028:	10 92 95 01 	sts	0x0195, r1
		  stEtransaction=etDelayExit;
    d02c:	89 e0       	ldi	r24, 0x09	; 9
    d02e:	d2 cf       	rjmp	.-92     	; 0xcfd4 <FMenuEDCTransaction+0x15a>
	      break;
     case etDelayExit:
	      if (TimDisplay>8)stEtransaction=etExitEDCTransaction;
    d030:	80 91 95 01 	lds	r24, 0x0195
    d034:	89 30       	cpi	r24, 0x09	; 9
    d036:	30 f0       	brcs	.+12     	; 0xd044 <FMenuEDCTransaction+0x1ca>
    d038:	8a e0       	ldi	r24, 0x0A	; 10
    d03a:	cc cf       	rjmp	.-104    	; 0xcfd4 <FMenuEDCTransaction+0x15a>
	      break;
     case etExitEDCTransaction:
	      stEtransaction=etInit;
    d03c:	10 92 b4 02 	sts	0x02B4, r1
    d040:	81 e0       	ldi	r24, 0x01	; 1
    d042:	01 c0       	rjmp	.+2      	; 0xd046 <FMenuEDCTransaction+0x1cc>
    d044:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
   return Result;
}
    d046:	1f 91       	pop	r17
    d048:	0f 91       	pop	r16
    d04a:	08 95       	ret

0000d04c <FMenuLoyalty>:
	      break;
	 }
  return Result;
}

char FMenuLoyalty(){
    d04c:	cf 92       	push	r12
    d04e:	df 92       	push	r13
    d050:	ef 92       	push	r14
    d052:	ff 92       	push	r15
    d054:	0f 93       	push	r16
    d056:	1f 93       	push	r17
    d058:	df 93       	push	r29
    d05a:	cf 93       	push	r28
    d05c:	cd b7       	in	r28, 0x3d	; 61
    d05e:	de b7       	in	r29, 0x3e	; 62
    d060:	64 97       	sbiw	r28, 0x14	; 20
    d062:	0f b6       	in	r0, 0x3f	; 63
    d064:	f8 94       	cli
    d066:	de bf       	out	0x3e, r29	; 62
    d068:	0f be       	out	0x3f, r0	; 63
    d06a:	cd bf       	out	0x3d, r28	; 61
       char FIPResult,FIP_USED;
	   char Result=MENU_NONE;
	   char KeyChar;

     Result=MENU_NONE;
	 switch(stLoyalty){
    d06c:	00 91 b8 02 	lds	r16, 0x02B8
    d070:	07 30       	cpi	r16, 0x07	; 7
    d072:	09 f4       	brne	.+2      	; 0xd076 <FMenuLoyalty+0x2a>
    d074:	08 c1       	rjmp	.+528    	; 0xd286 <FMenuLoyalty+0x23a>
    d076:	08 30       	cpi	r16, 0x08	; 8
    d078:	98 f4       	brcc	.+38     	; 0xd0a0 <FMenuLoyalty+0x54>
    d07a:	03 30       	cpi	r16, 0x03	; 3
    d07c:	09 f4       	brne	.+2      	; 0xd080 <FMenuLoyalty+0x34>
    d07e:	5d c0       	rjmp	.+186    	; 0xd13a <FMenuLoyalty+0xee>
    d080:	04 30       	cpi	r16, 0x04	; 4
    d082:	38 f4       	brcc	.+14     	; 0xd092 <FMenuLoyalty+0x46>
    d084:	01 30       	cpi	r16, 0x01	; 1
    d086:	09 f4       	brne	.+2      	; 0xd08a <FMenuLoyalty+0x3e>
    d088:	42 c0       	rjmp	.+132    	; 0xd10e <FMenuLoyalty+0xc2>
    d08a:	02 30       	cpi	r16, 0x02	; 2
    d08c:	08 f0       	brcs	.+2      	; 0xd090 <FMenuLoyalty+0x44>
    d08e:	63 c0       	rjmp	.+198    	; 0xd156 <FMenuLoyalty+0x10a>
    d090:	20 c0       	rjmp	.+64     	; 0xd0d2 <FMenuLoyalty+0x86>
    d092:	05 30       	cpi	r16, 0x05	; 5
    d094:	09 f4       	brne	.+2      	; 0xd098 <FMenuLoyalty+0x4c>
    d096:	a4 c0       	rjmp	.+328    	; 0xd1e0 <FMenuLoyalty+0x194>
    d098:	06 30       	cpi	r16, 0x06	; 6
    d09a:	08 f0       	brcs	.+2      	; 0xd09e <FMenuLoyalty+0x52>
    d09c:	be c0       	rjmp	.+380    	; 0xd21a <FMenuLoyalty+0x1ce>
    d09e:	8e c0       	rjmp	.+284    	; 0xd1bc <FMenuLoyalty+0x170>
    d0a0:	0b 30       	cpi	r16, 0x0B	; 11
    d0a2:	09 f4       	brne	.+2      	; 0xd0a6 <FMenuLoyalty+0x5a>
    d0a4:	3a c1       	rjmp	.+628    	; 0xd31a <FMenuLoyalty+0x2ce>
    d0a6:	0c 30       	cpi	r16, 0x0C	; 12
    d0a8:	38 f4       	brcc	.+14     	; 0xd0b8 <FMenuLoyalty+0x6c>
    d0aa:	09 30       	cpi	r16, 0x09	; 9
    d0ac:	09 f4       	brne	.+2      	; 0xd0b0 <FMenuLoyalty+0x64>
    d0ae:	f4 c0       	rjmp	.+488    	; 0xd298 <FMenuLoyalty+0x24c>
    d0b0:	0a 30       	cpi	r16, 0x0A	; 10
    d0b2:	08 f0       	brcs	.+2      	; 0xd0b6 <FMenuLoyalty+0x6a>
    d0b4:	14 c1       	rjmp	.+552    	; 0xd2de <FMenuLoyalty+0x292>
    d0b6:	ea c0       	rjmp	.+468    	; 0xd28c <FMenuLoyalty+0x240>
    d0b8:	0d 30       	cpi	r16, 0x0D	; 13
    d0ba:	09 f4       	brne	.+2      	; 0xd0be <FMenuLoyalty+0x72>
    d0bc:	f2 c1       	rjmp	.+996    	; 0xd4a2 <FMenuLoyalty+0x456>
    d0be:	0d 30       	cpi	r16, 0x0D	; 13
    d0c0:	08 f4       	brcc	.+2      	; 0xd0c4 <FMenuLoyalty+0x78>
    d0c2:	fb c1       	rjmp	.+1014   	; 0xd4ba <FMenuLoyalty+0x46e>
    d0c4:	0e 30       	cpi	r16, 0x0E	; 14
    d0c6:	09 f4       	brne	.+2      	; 0xd0ca <FMenuLoyalty+0x7e>
    d0c8:	0a c2       	rjmp	.+1044   	; 0xd4de <FMenuLoyalty+0x492>
    d0ca:	0f 30       	cpi	r16, 0x0F	; 15
    d0cc:	09 f0       	breq	.+2      	; 0xd0d0 <FMenuLoyalty+0x84>
    d0ce:	13 c2       	rjmp	.+1062   	; 0xd4f6 <FMenuLoyalty+0x4aa>
    d0d0:	0c c2       	rjmp	.+1048   	; 0xd4ea <FMenuLoyalty+0x49e>
	 case mlInit:
	      lcd_clear();
    d0d2:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
		  lcd_printf(1,1,PSTR("  Menu Loyalty   "));
    d0d6:	81 e0       	ldi	r24, 0x01	; 1
    d0d8:	61 e0       	ldi	r22, 0x01	; 1
    d0da:	47 e3       	ldi	r20, 0x37	; 55
    d0dc:	5b e1       	ldi	r21, 0x1B	; 27
    d0de:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
          lcd_printf(1,1,PSTR("1.Enquiry        "));
    d0e2:	81 e0       	ldi	r24, 0x01	; 1
    d0e4:	61 e0       	ldi	r22, 0x01	; 1
    d0e6:	45 e2       	ldi	r20, 0x25	; 37
    d0e8:	5b e1       	ldi	r21, 0x1B	; 27
    d0ea:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		  lcd_printf(2,1,PSTR("2.Loyalty Update "));
    d0ee:	82 e0       	ldi	r24, 0x02	; 2
    d0f0:	61 e0       	ldi	r22, 0x01	; 1
    d0f2:	43 e1       	ldi	r20, 0x13	; 19
    d0f4:	5b e1       	ldi	r21, 0x1B	; 27
    d0f6:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
	      lcd_printf(4,1,PSTR("[*]Back          "));
    d0fa:	84 e0       	ldi	r24, 0x04	; 4
    d0fc:	61 e0       	ldi	r22, 0x01	; 1
    d0fe:	41 e0       	ldi	r20, 0x01	; 1
    d100:	5b e1       	ldi	r21, 0x1B	; 27
    d102:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		  IsLoyaltyUpdate=False;
    d106:	10 92 b5 02 	sts	0x02B5, r1
		  stLoyalty=mlLoyaltySelect;
    d10a:	81 e0       	ldi	r24, 0x01	; 1
    d10c:	0a c0       	rjmp	.+20     	; 0xd122 <FMenuLoyalty+0xd6>
	      break;
	 case mlLoyaltySelect:
	 	  KeyPressed=_key_scan(1);
    d10e:	81 e0       	ldi	r24, 0x01	; 1
    d110:	0e 94 84 ae 	call	0x15d08	; 0x15d08 <_key_scan>
    d114:	80 93 b7 02 	sts	0x02B7, r24
		  if (KeyPressed==_KEY_1){
    d118:	8e 3e       	cpi	r24, 0xEE	; 238
    d11a:	31 f4       	brne	.+12     	; 0xd128 <FMenuLoyalty+0xdc>
		      IsLoyaltyUpdate=False;
    d11c:	10 92 b5 02 	sts	0x02B5, r1
		      stLoyalty=mlShowEnquiry;
    d120:	84 e0       	ldi	r24, 0x04	; 4
    d122:	80 93 b8 02 	sts	0x02B8, r24
    d126:	e7 c1       	rjmp	.+974    	; 0xd4f6 <FMenuLoyalty+0x4aa>
			  }
		  else
		  if (KeyPressed==_KEY_2){
    d128:	8e 3d       	cpi	r24, 0xDE	; 222
    d12a:	19 f4       	brne	.+6      	; 0xd132 <FMenuLoyalty+0xe6>
		      IsLoyaltyUpdate=True;
    d12c:	00 93 b5 02 	sts	0x02B5, r16
    d130:	6b c0       	rjmp	.+214    	; 0xd208 <FMenuLoyalty+0x1bc>
			  stLoyalty=mlSelectFIP;
			  }
		  if (KeyPressed==_KEY_CANCEL)stLoyalty=mlExitLoyalty;
    d132:	87 3e       	cpi	r24, 0xE7	; 231
    d134:	09 f4       	brne	.+2      	; 0xd138 <FMenuLoyalty+0xec>
    d136:	d7 c1       	rjmp	.+942    	; 0xd4e6 <FMenuLoyalty+0x49a>
    d138:	de c1       	rjmp	.+956    	; 0xd4f6 <FMenuLoyalty+0x4aa>
	      break;
     case mlSelectFIP:
	      FIPResult=menu_FIP(&FIP_Used,strFIP_ID);
    d13a:	86 eb       	ldi	r24, 0xB6	; 182
    d13c:	92 e0       	ldi	r25, 0x02	; 2
    d13e:	6b ec       	ldi	r22, 0xCB	; 203
    d140:	78 e0       	ldi	r23, 0x08	; 8
    d142:	0e 94 b5 65 	call	0xcb6a	; 0xcb6a <menu_FIP>
		  if (FIPResult==FIP_DONE)stLoyalty=mlUpdateLoyalty;
    d146:	88 23       	and	r24, r24
    d148:	11 f4       	brne	.+4      	; 0xd14e <FMenuLoyalty+0x102>
    d14a:	82 e0       	ldi	r24, 0x02	; 2
    d14c:	ea cf       	rjmp	.-44     	; 0xd122 <FMenuLoyalty+0xd6>
		  else
		  if (FIPResult==FIP_CANCEL)stLoyalty=mlInit;
    d14e:	82 30       	cpi	r24, 0x02	; 2
    d150:	09 f0       	breq	.+2      	; 0xd154 <FMenuLoyalty+0x108>
    d152:	d1 c1       	rjmp	.+930    	; 0xd4f6 <FMenuLoyalty+0x4aa>
    d154:	5b c0       	rjmp	.+182    	; 0xd20c <FMenuLoyalty+0x1c0>
	      break;
     case mlUpdateLoyalty: 
	      lcd_clear();
    d156:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
		  sprintf_P(lcdteks,PSTR("FIP:%s"),strFIP_ID);
    d15a:	00 d0       	rcall	.+0      	; 0xd15c <FMenuLoyalty+0x110>
    d15c:	00 d0       	rcall	.+0      	; 0xd15e <FMenuLoyalty+0x112>
    d15e:	00 d0       	rcall	.+0      	; 0xd160 <FMenuLoyalty+0x114>
    d160:	ed b7       	in	r30, 0x3d	; 61
    d162:	fe b7       	in	r31, 0x3e	; 62
    d164:	31 96       	adiw	r30, 0x01	; 1
    d166:	8e 01       	movw	r16, r28
    d168:	0f 5f       	subi	r16, 0xFF	; 255
    d16a:	1f 4f       	sbci	r17, 0xFF	; 255
    d16c:	ad b7       	in	r26, 0x3d	; 61
    d16e:	be b7       	in	r27, 0x3e	; 62
    d170:	12 96       	adiw	r26, 0x02	; 2
    d172:	1c 93       	st	X, r17
    d174:	0e 93       	st	-X, r16
    d176:	11 97       	sbiw	r26, 0x01	; 1
    d178:	8a ef       	ldi	r24, 0xFA	; 250
    d17a:	9a e1       	ldi	r25, 0x1A	; 26
    d17c:	93 83       	std	Z+3, r25	; 0x03
    d17e:	82 83       	std	Z+2, r24	; 0x02
    d180:	8b ec       	ldi	r24, 0xCB	; 203
    d182:	98 e0       	ldi	r25, 0x08	; 8
    d184:	95 83       	std	Z+5, r25	; 0x05
    d186:	84 83       	std	Z+4, r24	; 0x04
    d188:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
		  lcd_printf(1,1,PSTR("Tap Kartu RFID"));
    d18c:	8d b7       	in	r24, 0x3d	; 61
    d18e:	9e b7       	in	r25, 0x3e	; 62
    d190:	06 96       	adiw	r24, 0x06	; 6
    d192:	0f b6       	in	r0, 0x3f	; 63
    d194:	f8 94       	cli
    d196:	9e bf       	out	0x3e, r25	; 62
    d198:	0f be       	out	0x3f, r0	; 63
    d19a:	8d bf       	out	0x3d, r24	; 61
    d19c:	81 e0       	ldi	r24, 0x01	; 1
    d19e:	61 e0       	ldi	r22, 0x01	; 1
    d1a0:	4b ee       	ldi	r20, 0xEB	; 235
    d1a2:	5a e1       	ldi	r21, 0x1A	; 26
    d1a4:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		  lcd_print(2,1,lcdteks);
    d1a8:	82 e0       	ldi	r24, 0x02	; 2
    d1aa:	61 e0       	ldi	r22, 0x01	; 1
    d1ac:	a8 01       	movw	r20, r16
    d1ae:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
          lcd_printf(4,1,PSTR("[*]Back    [#]Exit"));
    d1b2:	84 e0       	ldi	r24, 0x04	; 4
    d1b4:	61 e0       	ldi	r22, 0x01	; 1
    d1b6:	48 ed       	ldi	r20, 0xD8	; 216
    d1b8:	5a e1       	ldi	r21, 0x1A	; 26
    d1ba:	0c c0       	rjmp	.+24     	; 0xd1d4 <FMenuLoyalty+0x188>
		  IsRFIDDetected=False;
	      stLoyalty=mlInputRFID;
	      break;
	 case mlShowEnquiry:
	      lcd_clear();
    d1bc:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
		  lcd_printf(1,1,PSTR("Tap Kartu RFID"));
    d1c0:	81 e0       	ldi	r24, 0x01	; 1
    d1c2:	61 e0       	ldi	r22, 0x01	; 1
    d1c4:	49 ec       	ldi	r20, 0xC9	; 201
    d1c6:	5a e1       	ldi	r21, 0x1A	; 26
    d1c8:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
          lcd_printf(4,1,PSTR("[*]Back    [#]Exit"));
    d1cc:	84 e0       	ldi	r24, 0x04	; 4
    d1ce:	61 e0       	ldi	r22, 0x01	; 1
    d1d0:	46 eb       	ldi	r20, 0xB6	; 182
    d1d2:	5a e1       	ldi	r21, 0x1A	; 26
    d1d4:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		  IsRFIDDetected=False;
    d1d8:	10 92 9b 01 	sts	0x019B, r1
		  stLoyalty=mlInputRFID;
    d1dc:	85 e0       	ldi	r24, 0x05	; 5
    d1de:	a1 cf       	rjmp	.-190    	; 0xd122 <FMenuLoyalty+0xd6>
	      break;
     case mlInputRFID:
	      if (IsRFIDDetected==True){
    d1e0:	80 91 9b 01 	lds	r24, 0x019B
    d1e4:	81 30       	cpi	r24, 0x01	; 1
    d1e6:	29 f4       	brne	.+10     	; 0xd1f2 <FMenuLoyalty+0x1a6>
		      IsRFIDDetected=False;
    d1e8:	10 92 9b 01 	sts	0x019B, r1
		      stLoyalty=mlShowProsesRFID;
    d1ec:	86 e0       	ldi	r24, 0x06	; 6
    d1ee:	80 93 b8 02 	sts	0x02B8, r24
		  }
	 	  KeyPressed=_key_scan(1);
    d1f2:	81 e0       	ldi	r24, 0x01	; 1
    d1f4:	0e 94 84 ae 	call	0x15d08	; 0x15d08 <_key_scan>
    d1f8:	80 93 b7 02 	sts	0x02B7, r24
		  if (KeyPressed==_KEY_CANCEL){
    d1fc:	87 3e       	cpi	r24, 0xE7	; 231
    d1fe:	49 f4       	brne	.+18     	; 0xd212 <FMenuLoyalty+0x1c6>
		      if (IsLoyaltyUpdate==True)
    d200:	80 91 b5 02 	lds	r24, 0x02B5
    d204:	81 30       	cpi	r24, 0x01	; 1
    d206:	11 f4       	brne	.+4      	; 0xd20c <FMenuLoyalty+0x1c0>
			       stLoyalty=mlSelectFIP;
    d208:	83 e0       	ldi	r24, 0x03	; 3
    d20a:	8b cf       	rjmp	.-234    	; 0xd122 <FMenuLoyalty+0xd6>
			  else stLoyalty=mlInit;
    d20c:	10 92 b8 02 	sts	0x02B8, r1
    d210:	72 c1       	rjmp	.+740    	; 0xd4f6 <FMenuLoyalty+0x4aa>
			  }
		  else
		  if (KeyPressed==_KEY_ENTER)stLoyalty=mlExitLoyalty;
    d212:	87 3b       	cpi	r24, 0xB7	; 183
    d214:	09 f0       	breq	.+2      	; 0xd218 <FMenuLoyalty+0x1cc>
    d216:	6f c1       	rjmp	.+734    	; 0xd4f6 <FMenuLoyalty+0x4aa>
    d218:	66 c1       	rjmp	.+716    	; 0xd4e6 <FMenuLoyalty+0x49a>
	      break;
     case mlShowProsesRFID:
	      lcd_clear();
    d21a:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
		  sprintf_P(lcdteks,PSTR("ID:%s"),strRFID);
    d21e:	00 d0       	rcall	.+0      	; 0xd220 <FMenuLoyalty+0x1d4>
    d220:	00 d0       	rcall	.+0      	; 0xd222 <FMenuLoyalty+0x1d6>
    d222:	00 d0       	rcall	.+0      	; 0xd224 <FMenuLoyalty+0x1d8>
    d224:	ed b7       	in	r30, 0x3d	; 61
    d226:	fe b7       	in	r31, 0x3e	; 62
    d228:	31 96       	adiw	r30, 0x01	; 1
    d22a:	8e 01       	movw	r16, r28
    d22c:	0f 5f       	subi	r16, 0xFF	; 255
    d22e:	1f 4f       	sbci	r17, 0xFF	; 255
    d230:	ad b7       	in	r26, 0x3d	; 61
    d232:	be b7       	in	r27, 0x3e	; 62
    d234:	12 96       	adiw	r26, 0x02	; 2
    d236:	1c 93       	st	X, r17
    d238:	0e 93       	st	-X, r16
    d23a:	11 97       	sbiw	r26, 0x01	; 1
    d23c:	80 eb       	ldi	r24, 0xB0	; 176
    d23e:	9a e1       	ldi	r25, 0x1A	; 26
    d240:	93 83       	std	Z+3, r25	; 0x03
    d242:	82 83       	std	Z+2, r24	; 0x02
    d244:	88 e8       	ldi	r24, 0x88	; 136
    d246:	9d e0       	ldi	r25, 0x0D	; 13
    d248:	95 83       	std	Z+5, r25	; 0x05
    d24a:	84 83       	std	Z+4, r24	; 0x04
    d24c:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
		  lcd_print (1,1,lcdteks);	      
    d250:	8d b7       	in	r24, 0x3d	; 61
    d252:	9e b7       	in	r25, 0x3e	; 62
    d254:	06 96       	adiw	r24, 0x06	; 6
    d256:	0f b6       	in	r0, 0x3f	; 63
    d258:	f8 94       	cli
    d25a:	9e bf       	out	0x3e, r25	; 62
    d25c:	0f be       	out	0x3f, r0	; 63
    d25e:	8d bf       	out	0x3d, r24	; 61
    d260:	81 e0       	ldi	r24, 0x01	; 1
    d262:	61 e0       	ldi	r22, 0x01	; 1
    d264:	a8 01       	movw	r20, r16
    d266:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
		  lcd_printf(2,1,PSTR("Proses"));	      
    d26a:	82 e0       	ldi	r24, 0x02	; 2
    d26c:	61 e0       	ldi	r22, 0x01	; 1
    d26e:	49 ea       	ldi	r20, 0xA9	; 169
    d270:	5a e1       	ldi	r21, 0x1A	; 26
    d272:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		  if (IsLoyaltyUpdate==True)stLoyalty=mlSendMessage24;
    d276:	80 91 b5 02 	lds	r24, 0x02B5
    d27a:	81 30       	cpi	r24, 0x01	; 1
    d27c:	11 f4       	brne	.+4      	; 0xd282 <FMenuLoyalty+0x236>
    d27e:	88 e0       	ldi	r24, 0x08	; 8
    d280:	50 cf       	rjmp	.-352    	; 0xd122 <FMenuLoyalty+0xd6>
		  else stLoyalty=mlSendMessage22;
    d282:	87 e0       	ldi	r24, 0x07	; 7
    d284:	4e cf       	rjmp	.-356    	; 0xd122 <FMenuLoyalty+0xd6>
	      break;
     case mlSendMessage22:
	      sendMessage22();
    d286:	0e 94 7a 52 	call	0xa4f4	; 0xa4f4 <sendMessage22>
    d28a:	02 c0       	rjmp	.+4      	; 0xd290 <FMenuLoyalty+0x244>
		  TimSend=0;		  
          stLoyalty=mlWaitReply;
	      break;
     case mlSendMessage24:
	      sendMessage24();
    d28c:	0e 94 ee 51 	call	0xa3dc	; 0xa3dc <sendMessage24>
		  TimSend=0;		  
    d290:	10 92 af 0d 	sts	0x0DAF, r1
          stLoyalty=mlWaitReply;
    d294:	89 e0       	ldi	r24, 0x09	; 9
    d296:	45 cf       	rjmp	.-374    	; 0xd122 <FMenuLoyalty+0xd6>
	      break;
     case mlWaitReply:
	      if (TimSend>(TIM_SEND*3))
    d298:	80 91 af 0d 	lds	r24, 0x0DAF
    d29c:	8f 31       	cpi	r24, 0x1F	; 31
    d29e:	18 f0       	brcs	.+6      	; 0xd2a6 <FMenuLoyalty+0x25a>
		      stLoyalty=mlNoConnection;
    d2a0:	8c e0       	ldi	r24, 0x0C	; 12
    d2a2:	80 93 b8 02 	sts	0x02B8, r24
	      if (IsMessage23==True){
    d2a6:	80 91 a5 01 	lds	r24, 0x01A5
    d2aa:	81 30       	cpi	r24, 0x01	; 1
    d2ac:	39 f4       	brne	.+14     	; 0xd2bc <FMenuLoyalty+0x270>
		      IsMessage23=False;
    d2ae:	10 92 a5 01 	sts	0x01A5, r1
			  procMessage23();
    d2b2:	0e 94 73 17 	call	0x2ee6	; 0x2ee6 <procMessage23>
			  stLoyalty=mlDispEnquiry;
    d2b6:	8b e0       	ldi	r24, 0x0B	; 11
    d2b8:	80 93 b8 02 	sts	0x02B8, r24
		  }
	      if (IsMessage09==True){
    d2bc:	80 91 a6 01 	lds	r24, 0x01A6
    d2c0:	81 30       	cpi	r24, 0x01	; 1
    d2c2:	39 f4       	brne	.+14     	; 0xd2d2 <FMenuLoyalty+0x286>
		      IsMessage09=False;
    d2c4:	10 92 a6 01 	sts	0x01A6, r1
	          procMessage09();
    d2c8:	0e 94 28 17 	call	0x2e50	; 0x2e50 <procMessage09>
              stLoyalty=mlDisplayFreeMessage;
    d2cc:	8a e0       	ldi	r24, 0x0A	; 10
    d2ce:	80 93 b8 02 	sts	0x02B8, r24
		  }
	      if (IsMessage99==True){
    d2d2:	80 91 a2 01 	lds	r24, 0x01A2
    d2d6:	81 30       	cpi	r24, 0x01	; 1
    d2d8:	09 f0       	breq	.+2      	; 0xd2dc <FMenuLoyalty+0x290>
    d2da:	0d c1       	rjmp	.+538    	; 0xd4f6 <FMenuLoyalty+0x4aa>
    d2dc:	1c c0       	rjmp	.+56     	; 0xd316 <FMenuLoyalty+0x2ca>
              stLoyalty=mlDelayExitLoyalty;
		  }
	      break;
     case mlDisplayFreeMessage:
		  lcd_clear();
    d2de:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
		  lcd_print(1,1,strFreeMessageLine1);
    d2e2:	81 e0       	ldi	r24, 0x01	; 1
    d2e4:	61 e0       	ldi	r22, 0x01	; 1
    d2e6:	46 ec       	ldi	r20, 0xC6	; 198
    d2e8:	59 e0       	ldi	r21, 0x09	; 9
    d2ea:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
		  lcd_print(2,1,strFreeMessageLine2);
    d2ee:	82 e0       	ldi	r24, 0x02	; 2
    d2f0:	61 e0       	ldi	r22, 0x01	; 1
    d2f2:	45 eb       	ldi	r20, 0xB5	; 181
    d2f4:	58 e0       	ldi	r21, 0x08	; 8
    d2f6:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
		  lcd_print(3,1,strFreeMessageLine3);
    d2fa:	83 e0       	ldi	r24, 0x03	; 3
    d2fc:	61 e0       	ldi	r22, 0x01	; 1
    d2fe:	40 e5       	ldi	r20, 0x50	; 80
    d300:	59 e0       	ldi	r21, 0x09	; 9
    d302:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
		  lcd_print(4,1,strFreeMessageLine4);
    d306:	84 e0       	ldi	r24, 0x04	; 4
    d308:	61 e0       	ldi	r22, 0x01	; 1
    d30a:	4d e0       	ldi	r20, 0x0D	; 13
    d30c:	5d e0       	ldi	r21, 0x0D	; 13
    d30e:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
		  TimDisplay=0;
    d312:	10 92 95 01 	sts	0x0195, r1
		  stLoyalty=mlDelayExitLoyalty;
    d316:	8e e0       	ldi	r24, 0x0E	; 14
    d318:	04 cf       	rjmp	.-504    	; 0xd122 <FMenuLoyalty+0xd6>
	      break;
     case mlDispEnquiry:	      
	      lcd_clear();
    d31a:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
		  RemSpaceLag(strCardID);RemSpaceLag(strCardHolder);
    d31e:	ed eb       	ldi	r30, 0xBD	; 189
    d320:	ce 2e       	mov	r12, r30
    d322:	ec e0       	ldi	r30, 0x0C	; 12
    d324:	de 2e       	mov	r13, r30
    d326:	c6 01       	movw	r24, r12
    d328:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <RemSpaceLag>
    d32c:	73 e3       	ldi	r23, 0x33	; 51
    d32e:	e7 2e       	mov	r14, r23
    d330:	74 e0       	ldi	r23, 0x04	; 4
    d332:	f7 2e       	mov	r15, r23
    d334:	c7 01       	movw	r24, r14
    d336:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <RemSpaceLag>
		  sprintf_P(lcdteks,PSTR("%s:%s"),strCardID,strCardHolder);
    d33a:	ad b7       	in	r26, 0x3d	; 61
    d33c:	be b7       	in	r27, 0x3e	; 62
    d33e:	18 97       	sbiw	r26, 0x08	; 8
    d340:	0f b6       	in	r0, 0x3f	; 63
    d342:	f8 94       	cli
    d344:	be bf       	out	0x3e, r27	; 62
    d346:	0f be       	out	0x3f, r0	; 63
    d348:	ad bf       	out	0x3d, r26	; 61
    d34a:	ed b7       	in	r30, 0x3d	; 61
    d34c:	fe b7       	in	r31, 0x3e	; 62
    d34e:	31 96       	adiw	r30, 0x01	; 1
    d350:	8e 01       	movw	r16, r28
    d352:	0f 5f       	subi	r16, 0xFF	; 255
    d354:	1f 4f       	sbci	r17, 0xFF	; 255
    d356:	12 96       	adiw	r26, 0x02	; 2
    d358:	1c 93       	st	X, r17
    d35a:	0e 93       	st	-X, r16
    d35c:	11 97       	sbiw	r26, 0x01	; 1
    d35e:	83 ea       	ldi	r24, 0xA3	; 163
    d360:	9a e1       	ldi	r25, 0x1A	; 26
    d362:	93 83       	std	Z+3, r25	; 0x03
    d364:	82 83       	std	Z+2, r24	; 0x02
    d366:	d5 82       	std	Z+5, r13	; 0x05
    d368:	c4 82       	std	Z+4, r12	; 0x04
    d36a:	f7 82       	std	Z+7, r15	; 0x07
    d36c:	e6 82       	std	Z+6, r14	; 0x06
    d36e:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
		  lcd_print(1,1,lcdteks);RemSpaceLag(strLoyCurrentPoints);
    d372:	8d b7       	in	r24, 0x3d	; 61
    d374:	9e b7       	in	r25, 0x3e	; 62
    d376:	08 96       	adiw	r24, 0x08	; 8
    d378:	0f b6       	in	r0, 0x3f	; 63
    d37a:	f8 94       	cli
    d37c:	9e bf       	out	0x3e, r25	; 62
    d37e:	0f be       	out	0x3f, r0	; 63
    d380:	8d bf       	out	0x3d, r24	; 61
    d382:	81 e0       	ldi	r24, 0x01	; 1
    d384:	61 e0       	ldi	r22, 0x01	; 1
    d386:	a8 01       	movw	r20, r16
    d388:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
    d38c:	69 e6       	ldi	r22, 0x69	; 105
    d38e:	e6 2e       	mov	r14, r22
    d390:	69 e0       	ldi	r22, 0x09	; 9
    d392:	f6 2e       	mov	r15, r22
    d394:	c7 01       	movw	r24, r14
    d396:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <RemSpaceLag>
		  sprintf_P(lcdteks,PSTR("Points:%s"),strLoyCurrentPoints);
    d39a:	00 d0       	rcall	.+0      	; 0xd39c <FMenuLoyalty+0x350>
    d39c:	00 d0       	rcall	.+0      	; 0xd39e <FMenuLoyalty+0x352>
    d39e:	00 d0       	rcall	.+0      	; 0xd3a0 <FMenuLoyalty+0x354>
    d3a0:	ed b7       	in	r30, 0x3d	; 61
    d3a2:	fe b7       	in	r31, 0x3e	; 62
    d3a4:	31 96       	adiw	r30, 0x01	; 1
    d3a6:	ad b7       	in	r26, 0x3d	; 61
    d3a8:	be b7       	in	r27, 0x3e	; 62
    d3aa:	12 96       	adiw	r26, 0x02	; 2
    d3ac:	1c 93       	st	X, r17
    d3ae:	0e 93       	st	-X, r16
    d3b0:	11 97       	sbiw	r26, 0x01	; 1
    d3b2:	89 e9       	ldi	r24, 0x99	; 153
    d3b4:	9a e1       	ldi	r25, 0x1A	; 26
    d3b6:	93 83       	std	Z+3, r25	; 0x03
    d3b8:	82 83       	std	Z+2, r24	; 0x02
    d3ba:	f5 82       	std	Z+5, r15	; 0x05
    d3bc:	e4 82       	std	Z+4, r14	; 0x04
    d3be:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
		  lcd_print(2,1,lcdteks);RemSpaceLag(strLoyCurrentPoints);
    d3c2:	8d b7       	in	r24, 0x3d	; 61
    d3c4:	9e b7       	in	r25, 0x3e	; 62
    d3c6:	06 96       	adiw	r24, 0x06	; 6
    d3c8:	0f b6       	in	r0, 0x3f	; 63
    d3ca:	f8 94       	cli
    d3cc:	9e bf       	out	0x3e, r25	; 62
    d3ce:	0f be       	out	0x3f, r0	; 63
    d3d0:	8d bf       	out	0x3d, r24	; 61
    d3d2:	82 e0       	ldi	r24, 0x02	; 2
    d3d4:	61 e0       	ldi	r22, 0x01	; 1
    d3d6:	a8 01       	movw	r20, r16
    d3d8:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
    d3dc:	c7 01       	movw	r24, r14
    d3de:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <RemSpaceLag>
		  sprintf_P(lcdteks,PSTR("CM Amt:%s"),strLoyCurrMonConsumeA);
    d3e2:	00 d0       	rcall	.+0      	; 0xd3e4 <FMenuLoyalty+0x398>
    d3e4:	00 d0       	rcall	.+0      	; 0xd3e6 <FMenuLoyalty+0x39a>
    d3e6:	00 d0       	rcall	.+0      	; 0xd3e8 <FMenuLoyalty+0x39c>
    d3e8:	ed b7       	in	r30, 0x3d	; 61
    d3ea:	fe b7       	in	r31, 0x3e	; 62
    d3ec:	31 96       	adiw	r30, 0x01	; 1
    d3ee:	ad b7       	in	r26, 0x3d	; 61
    d3f0:	be b7       	in	r27, 0x3e	; 62
    d3f2:	12 96       	adiw	r26, 0x02	; 2
    d3f4:	1c 93       	st	X, r17
    d3f6:	0e 93       	st	-X, r16
    d3f8:	11 97       	sbiw	r26, 0x01	; 1
    d3fa:	8f e8       	ldi	r24, 0x8F	; 143
    d3fc:	9a e1       	ldi	r25, 0x1A	; 26
    d3fe:	93 83       	std	Z+3, r25	; 0x03
    d400:	82 83       	std	Z+2, r24	; 0x02
    d402:	8d e8       	ldi	r24, 0x8D	; 141
    d404:	94 e0       	ldi	r25, 0x04	; 4
    d406:	95 83       	std	Z+5, r25	; 0x05
    d408:	84 83       	std	Z+4, r24	; 0x04
    d40a:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
		  lcd_print(3,1,lcdteks);RemSpaceLag(strLoyCurrentPoints);
    d40e:	8d b7       	in	r24, 0x3d	; 61
    d410:	9e b7       	in	r25, 0x3e	; 62
    d412:	06 96       	adiw	r24, 0x06	; 6
    d414:	0f b6       	in	r0, 0x3f	; 63
    d416:	f8 94       	cli
    d418:	9e bf       	out	0x3e, r25	; 62
    d41a:	0f be       	out	0x3f, r0	; 63
    d41c:	8d bf       	out	0x3d, r24	; 61
    d41e:	83 e0       	ldi	r24, 0x03	; 3
    d420:	61 e0       	ldi	r22, 0x01	; 1
    d422:	a8 01       	movw	r20, r16
    d424:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
    d428:	c7 01       	movw	r24, r14
    d42a:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <RemSpaceLag>
		  sprintf_P(lcdteks,PSTR("Cm Vol:%s"),strLoyCurrMonConsumeV);
    d42e:	00 d0       	rcall	.+0      	; 0xd430 <FMenuLoyalty+0x3e4>
    d430:	00 d0       	rcall	.+0      	; 0xd432 <FMenuLoyalty+0x3e6>
    d432:	00 d0       	rcall	.+0      	; 0xd434 <FMenuLoyalty+0x3e8>
    d434:	ed b7       	in	r30, 0x3d	; 61
    d436:	fe b7       	in	r31, 0x3e	; 62
    d438:	31 96       	adiw	r30, 0x01	; 1
    d43a:	ad b7       	in	r26, 0x3d	; 61
    d43c:	be b7       	in	r27, 0x3e	; 62
    d43e:	12 96       	adiw	r26, 0x02	; 2
    d440:	1c 93       	st	X, r17
    d442:	0e 93       	st	-X, r16
    d444:	11 97       	sbiw	r26, 0x01	; 1
    d446:	85 e8       	ldi	r24, 0x85	; 133
    d448:	9a e1       	ldi	r25, 0x1A	; 26
    d44a:	93 83       	std	Z+3, r25	; 0x03
    d44c:	82 83       	std	Z+2, r24	; 0x02
    d44e:	84 e2       	ldi	r24, 0x24	; 36
    d450:	9d e0       	ldi	r25, 0x0D	; 13
    d452:	95 83       	std	Z+5, r25	; 0x05
    d454:	84 83       	std	Z+4, r24	; 0x04
    d456:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
		  lcd_print(4,1,lcdteks);
    d45a:	8d b7       	in	r24, 0x3d	; 61
    d45c:	9e b7       	in	r25, 0x3e	; 62
    d45e:	06 96       	adiw	r24, 0x06	; 6
    d460:	0f b6       	in	r0, 0x3f	; 63
    d462:	f8 94       	cli
    d464:	9e bf       	out	0x3e, r25	; 62
    d466:	0f be       	out	0x3f, r0	; 63
    d468:	8d bf       	out	0x3d, r24	; 61
    d46a:	84 e0       	ldi	r24, 0x04	; 4
    d46c:	61 e0       	ldi	r22, 0x01	; 1
    d46e:	a8 01       	movw	r20, r16
    d470:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
		  TimDisplay=0;
    d474:	10 92 95 01 	sts	0x0195, r1
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    d478:	e1 99       	sbic	0x1c, 1	; 28
    d47a:	fe cf       	rjmp	.-4      	; 0xd478 <FMenuLoyalty+0x42c>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    d47c:	88 e3       	ldi	r24, 0x38	; 56
    d47e:	90 e0       	ldi	r25, 0x00	; 0
    d480:	9f bb       	out	0x1f, r25	; 31
    d482:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    d484:	e0 9a       	sbi	0x1c, 0	; 28
    d486:	8d b3       	in	r24, 0x1d	; 29

		  if (eeprom_read_byte(&DefNotifScreen)==1) {
    d488:	81 30       	cpi	r24, 0x01	; 1
    d48a:	09 f0       	breq	.+2      	; 0xd48e <FMenuLoyalty+0x442>
    d48c:	44 cf       	rjmp	.-376    	; 0xd316 <FMenuLoyalty+0x2ca>
		      stLoyalty=mlPressAnyKey;
    d48e:	8d e0       	ldi	r24, 0x0D	; 13
    d490:	80 93 b8 02 	sts	0x02B8, r24
			  lcd_printf(2,1,PSTR("Press Any Key"));
    d494:	82 e0       	ldi	r24, 0x02	; 2
    d496:	61 e0       	ldi	r22, 0x01	; 1
    d498:	47 e7       	ldi	r20, 0x77	; 119
    d49a:	5a e1       	ldi	r21, 0x1A	; 26
    d49c:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
    d4a0:	2a c0       	rjmp	.+84     	; 0xd4f6 <FMenuLoyalty+0x4aa>
          } else stLoyalty=mlDelayExitLoyalty;
		  break;
     case mlPressAnyKey:
	      KeyPressed=_key_scan(1);
    d4a2:	81 e0       	ldi	r24, 0x01	; 1
    d4a4:	0e 94 84 ae 	call	0x15d08	; 0x15d08 <_key_scan>
    d4a8:	80 93 b7 02 	sts	0x02B7, r24
	      KeyChar=_key_btn(KeyPressed);
    d4ac:	0e 94 e5 ad 	call	0x15bca	; 0x15bca <_key_btn>
	      switch(KeyChar){		  
    d4b0:	83 32       	cpi	r24, 0x23	; 35
    d4b2:	c9 f0       	breq	.+50     	; 0xd4e6 <FMenuLoyalty+0x49a>
    d4b4:	8a 32       	cpi	r24, 0x2A	; 42
    d4b6:	f9 f4       	brne	.+62     	; 0xd4f6 <FMenuLoyalty+0x4aa>
    d4b8:	16 c0       	rjmp	.+44     	; 0xd4e6 <FMenuLoyalty+0x49a>
               stLoyalty=mlExitLoyalty;
		       break;		  
		  }
	      break;
     case mlNoConnection:
	      lcd_clear();
    d4ba:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
		  lcd_printf(2,1,PSTR("TCP/IP ERROR "));
    d4be:	82 e0       	ldi	r24, 0x02	; 2
    d4c0:	61 e0       	ldi	r22, 0x01	; 1
    d4c2:	49 e6       	ldi	r20, 0x69	; 105
    d4c4:	5a e1       	ldi	r21, 0x1A	; 26
    d4c6:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		  lcd_printf(3,1,PSTR("No Connection"));
    d4ca:	83 e0       	ldi	r24, 0x03	; 3
    d4cc:	61 e0       	ldi	r22, 0x01	; 1
    d4ce:	4b e5       	ldi	r20, 0x5B	; 91
    d4d0:	5a e1       	ldi	r21, 0x1A	; 26
    d4d2:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		  TimDisplay=5;
    d4d6:	85 e0       	ldi	r24, 0x05	; 5
    d4d8:	80 93 95 01 	sts	0x0195, r24
    d4dc:	1c cf       	rjmp	.-456    	; 0xd316 <FMenuLoyalty+0x2ca>
		  stLoyalty=mlDelayExitLoyalty;
	      break;
     case mlDelayExitLoyalty:
          if(TimDisplay>=10)stLoyalty=mlExitLoyalty;
    d4de:	80 91 95 01 	lds	r24, 0x0195
    d4e2:	8a 30       	cpi	r24, 0x0A	; 10
    d4e4:	40 f0       	brcs	.+16     	; 0xd4f6 <FMenuLoyalty+0x4aa>
    d4e6:	8f e0       	ldi	r24, 0x0F	; 15
    d4e8:	1c ce       	rjmp	.-968    	; 0xd122 <FMenuLoyalty+0xd6>
	      break;
	 case mlExitLoyalty:
	      lcd_clear();
    d4ea:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
	      stLoyalty=mlInit;
    d4ee:	10 92 b8 02 	sts	0x02B8, r1
    d4f2:	81 e0       	ldi	r24, 0x01	; 1
    d4f4:	01 c0       	rjmp	.+2      	; 0xd4f8 <FMenuLoyalty+0x4ac>
    d4f6:	80 e0       	ldi	r24, 0x00	; 0
		  Result=MENU_DONE;
	      break;
	 }
	 return Result;
}
    d4f8:	64 96       	adiw	r28, 0x14	; 20
    d4fa:	0f b6       	in	r0, 0x3f	; 63
    d4fc:	f8 94       	cli
    d4fe:	de bf       	out	0x3e, r29	; 62
    d500:	0f be       	out	0x3f, r0	; 63
    d502:	cd bf       	out	0x3d, r28	; 61
    d504:	cf 91       	pop	r28
    d506:	df 91       	pop	r29
    d508:	1f 91       	pop	r17
    d50a:	0f 91       	pop	r16
    d50c:	ff 90       	pop	r15
    d50e:	ef 90       	pop	r14
    d510:	df 90       	pop	r13
    d512:	cf 90       	pop	r12
    d514:	08 95       	ret

0000d516 <ValidateRestoreCode>:
	     strKeyStamp[i]='0'+GeniusCalc(G_MULTY,(sSeed[i]-'0'),(sGCode[i]-'0'));		 
	 }strKeyStamp[strlen(sGCode)]=0;
     WrapCode(strKeyStamp);
}

char ValidateRestoreCode(char *sKeyStamp, char *sRestoreCode){//==RC_VALID
    d516:	ef 92       	push	r14
    d518:	ff 92       	push	r15
    d51a:	0f 93       	push	r16
    d51c:	1f 93       	push	r17
    d51e:	cf 93       	push	r28
    d520:	df 93       	push	r29
    d522:	ec 01       	movw	r28, r24
    d524:	7b 01       	movw	r14, r22

	 //  KeyStamp: [6]5585577 WrapCode6x
	 //sprintf_P(strSend,PSTR("KeyStamp:%s"),sKeyStamp);
	 //_uart_print(1,1,strSend);

	 nSum=sKeyStamp[0]-'0';
    d526:	08 81       	ld	r16, Y
    d528:	00 53       	subi	r16, 0x30	; 48
    d52a:	10 e0       	ldi	r17, 0x00	; 0
    d52c:	04 c0       	rjmp	.+8      	; 0xd536 <ValidateRestoreCode+0x20>
	 for (i=0;i<nSum;i++){
         WrapCode(sKeyStamp);
    d52e:	ce 01       	movw	r24, r28
    d530:	0e 94 d1 30 	call	0x61a2	; 0x61a2 <WrapCode>
	 //  KeyStamp: [6]5585577 WrapCode6x
	 //sprintf_P(strSend,PSTR("KeyStamp:%s"),sKeyStamp);
	 //_uart_print(1,1,strSend);

	 nSum=sKeyStamp[0]-'0';
	 for (i=0;i<nSum;i++){
    d534:	1f 5f       	subi	r17, 0xFF	; 255
    d536:	10 17       	cp	r17, r16
    d538:	d0 f3       	brcs	.-12     	; 0xd52e <ValidateRestoreCode+0x18>
	 //_uart_print(1,1,strSend);
     
	 //sprintf_P(strSend,PSTR("WrapStamp:%s"),sRestoreCode);
	 //_uart_print(1,1,strSend);

	 if (strcmp(sKeyStamp,sRestoreCode)==0)
    d53a:	ce 01       	movw	r24, r28
    d53c:	b7 01       	movw	r22, r14
    d53e:	0e 94 e8 b3 	call	0x167d0	; 0x167d0 <strcmp>
    d542:	00 97       	sbiw	r24, 0x00	; 0
    d544:	11 f0       	breq	.+4      	; 0xd54a <ValidateRestoreCode+0x34>
    d546:	82 e0       	ldi	r24, 0x02	; 2
    d548:	01 c0       	rjmp	.+2      	; 0xd54c <ValidateRestoreCode+0x36>
    d54a:	81 e0       	ldi	r24, 0x01	; 1
	     Result=RC_VALID;	 
     else Result=RC_INVALID;

   return Result;
}
    d54c:	df 91       	pop	r29
    d54e:	cf 91       	pop	r28
    d550:	1f 91       	pop	r17
    d552:	0f 91       	pop	r16
    d554:	ff 90       	pop	r15
    d556:	ef 90       	pop	r14
    d558:	08 95       	ret

0000d55a <ValidateGeniusCode>:
          }
	 }sTemp[iAdd]=0;
	 sprintf_P(strSource,PSTR("%s"),sTemp);
}

char ValidateGeniusCode(char *sDate, char *sGenCode){//==GC_VALID
    d55a:	ef 92       	push	r14
    d55c:	ff 92       	push	r15
    d55e:	0f 93       	push	r16
    d560:	1f 93       	push	r17
    d562:	df 93       	push	r29
    d564:	cf 93       	push	r28
    d566:	cd b7       	in	r28, 0x3d	; 61
    d568:	de b7       	in	r29, 0x3e	; 62
    d56a:	2a 97       	sbiw	r28, 0x0a	; 10
    d56c:	0f b6       	in	r0, 0x3f	; 63
    d56e:	f8 94       	cli
    d570:	de bf       	out	0x3e, r29	; 62
    d572:	0f be       	out	0x3f, r0	; 63
    d574:	cd bf       	out	0x3d, r28	; 61
    d576:	7b 01       	movw	r14, r22

         #ifdef DEBUG_GENIUS_CODE
		 sprintf_P(strSend,PSTR("[%s]"),sGenCode); 
         _uart_print(1,1,strSend);
		 #endif
	 if (strlen(sGenCode)==8){//Length musti  8
    d578:	fb 01       	movw	r30, r22
    d57a:	01 90       	ld	r0, Z+
    d57c:	00 20       	and	r0, r0
    d57e:	e9 f7       	brne	.-6      	; 0xd57a <ValidateGeniusCode+0x20>
    d580:	39 97       	sbiw	r30, 0x09	; 9
    d582:	e6 17       	cp	r30, r22
    d584:	f7 07       	cpc	r31, r23
    d586:	11 f0       	breq	.+4      	; 0xd58c <ValidateGeniusCode+0x32>
    d588:	80 e0       	ldi	r24, 0x00	; 0
    d58a:	11 c0       	rjmp	.+34     	; 0xd5ae <ValidateGeniusCode+0x54>
	     //sDate: 05012001		 
		 GenerateGeniusCode(sDate,sGenCode[0],sAutoGen);
    d58c:	fb 01       	movw	r30, r22
    d58e:	60 81       	ld	r22, Z
    d590:	8e 01       	movw	r16, r28
    d592:	0f 5f       	subi	r16, 0xFF	; 255
    d594:	1f 4f       	sbci	r17, 0xFF	; 255
    d596:	a8 01       	movw	r20, r16
    d598:	0e 94 cf 31 	call	0x639e	; 0x639e <GenerateGeniusCode>
         #ifdef DEBUG_GENIUS_CODE
		 sprintf_P(strSend,PSTR("%s|%s"),sAutoGen,sGenCode); 
         _uart_print(1,1,strSend);
		 #endif

         if (strcmp(sAutoGen,sGenCode)==0)
    d59c:	c8 01       	movw	r24, r16
    d59e:	b7 01       	movw	r22, r14
    d5a0:	0e 94 e8 b3 	call	0x167d0	; 0x167d0 <strcmp>
    d5a4:	00 97       	sbiw	r24, 0x00	; 0
    d5a6:	11 f0       	breq	.+4      	; 0xd5ac <ValidateGeniusCode+0x52>
    d5a8:	82 e0       	ldi	r24, 0x02	; 2
    d5aa:	01 c0       	rjmp	.+2      	; 0xd5ae <ValidateGeniusCode+0x54>
    d5ac:	81 e0       	ldi	r24, 0x01	; 1
         else Result=GC_INVALID;
	 }


   return Result;
}
    d5ae:	2a 96       	adiw	r28, 0x0a	; 10
    d5b0:	0f b6       	in	r0, 0x3f	; 63
    d5b2:	f8 94       	cli
    d5b4:	de bf       	out	0x3e, r29	; 62
    d5b6:	0f be       	out	0x3f, r0	; 63
    d5b8:	cd bf       	out	0x3d, r28	; 61
    d5ba:	cf 91       	pop	r28
    d5bc:	df 91       	pop	r29
    d5be:	1f 91       	pop	r17
    d5c0:	0f 91       	pop	r16
    d5c2:	ff 90       	pop	r15
    d5c4:	ef 90       	pop	r14
    d5c6:	08 95       	ret

0000d5c8 <FMenuSettingServerIP>:
		       break;     
		  }//EndSwitch	 
    return Result;
}

char FMenuSettingServerIP(){
    d5c8:	ff 92       	push	r15
    d5ca:	0f 93       	push	r16
    d5cc:	1f 93       	push	r17
    d5ce:	df 93       	push	r29
    d5d0:	cf 93       	push	r28
    d5d2:	cd b7       	in	r28, 0x3d	; 61
    d5d4:	de b7       	in	r29, 0x3e	; 62
    d5d6:	64 97       	sbiw	r28, 0x14	; 20
    d5d8:	0f b6       	in	r0, 0x3f	; 63
    d5da:	f8 94       	cli
    d5dc:	de bf       	out	0x3e, r29	; 62
    d5de:	0f be       	out	0x3f, r0	; 63
    d5e0:	cd bf       	out	0x3d, r28	; 61
     //Server IP
     //Old: 192.168.123.000
	 //New:   _.   .   .
	 //--------------------
	 //*)cancel    #)next
	 Result=MENU_NONE;
    d5e2:	10 92 7f 02 	sts	0x027F, r1
     switch(stClientIP){
    d5e6:	80 91 48 01 	lds	r24, 0x0148
    d5ea:	82 30       	cpi	r24, 0x02	; 2
    d5ec:	09 f4       	brne	.+2      	; 0xd5f0 <FMenuSettingServerIP+0x28>
    d5ee:	7b c0       	rjmp	.+246    	; 0xd6e6 <FMenuSettingServerIP+0x11e>
    d5f0:	83 30       	cpi	r24, 0x03	; 3
    d5f2:	20 f4       	brcc	.+8      	; 0xd5fc <FMenuSettingServerIP+0x34>
    d5f4:	81 30       	cpi	r24, 0x01	; 1
    d5f6:	09 f0       	breq	.+2      	; 0xd5fa <FMenuSettingServerIP+0x32>
    d5f8:	62 c2       	rjmp	.+1220   	; 0xdabe <FMenuSettingServerIP+0x4f6>
    d5fa:	07 c0       	rjmp	.+14     	; 0xd60a <FMenuSettingServerIP+0x42>
    d5fc:	83 30       	cpi	r24, 0x03	; 3
    d5fe:	09 f4       	brne	.+2      	; 0xd602 <FMenuSettingServerIP+0x3a>
    d600:	59 c2       	rjmp	.+1202   	; 0xdab4 <FMenuSettingServerIP+0x4ec>
    d602:	84 30       	cpi	r24, 0x04	; 4
    d604:	09 f0       	breq	.+2      	; 0xd608 <FMenuSettingServerIP+0x40>
    d606:	5b c2       	rjmp	.+1206   	; 0xdabe <FMenuSettingServerIP+0x4f6>
    d608:	47 c2       	rjmp	.+1166   	; 0xda98 <FMenuSettingServerIP+0x4d0>
		  case cipInit:
			   lcd_clear();
    d60a:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
	           lcd_printf(1,1,PSTR("Server IP"));
    d60e:	81 e0       	ldi	r24, 0x01	; 1
    d610:	61 e0       	ldi	r22, 0x01	; 1
    d612:	43 e4       	ldi	r20, 0x43	; 67
    d614:	53 e1       	ldi	r21, 0x13	; 19
    d616:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    d61a:	88 e7       	ldi	r24, 0x78	; 120
    d61c:	92 e0       	ldi	r25, 0x02	; 2
    d61e:	6c e2       	ldi	r22, 0x2C	; 44
    d620:	70 e0       	ldi	r23, 0x00	; 0
    d622:	44 e0       	ldi	r20, 0x04	; 4
    d624:	50 e0       	ldi	r21, 0x00	; 0
    d626:	2d ef       	ldi	r18, 0xFD	; 253
    d628:	32 e1       	ldi	r19, 0x12	; 18
    d62a:	0e 94 f1 b3 	call	0x167e2	; 0x167e2 <__eerd_block>
			   eeprom_read_block((void*)&IP_blok,(const void*)&DefServerIP,4);
	           sprintf_P(lcdteks,PSTR("Old: %d.%d.%d.%d"),IP_blok[0],IP_blok[1],IP_blok[2],IP_blok[3]);
    d62e:	8d b7       	in	r24, 0x3d	; 61
    d630:	9e b7       	in	r25, 0x3e	; 62
    d632:	0c 97       	sbiw	r24, 0x0c	; 12
    d634:	0f b6       	in	r0, 0x3f	; 63
    d636:	f8 94       	cli
    d638:	9e bf       	out	0x3e, r25	; 62
    d63a:	0f be       	out	0x3f, r0	; 63
    d63c:	8d bf       	out	0x3d, r24	; 61
    d63e:	ed b7       	in	r30, 0x3d	; 61
    d640:	fe b7       	in	r31, 0x3e	; 62
    d642:	31 96       	adiw	r30, 0x01	; 1
    d644:	8e 01       	movw	r16, r28
    d646:	0f 5f       	subi	r16, 0xFF	; 255
    d648:	1f 4f       	sbci	r17, 0xFF	; 255
    d64a:	ad b7       	in	r26, 0x3d	; 61
    d64c:	be b7       	in	r27, 0x3e	; 62
    d64e:	12 96       	adiw	r26, 0x02	; 2
    d650:	1c 93       	st	X, r17
    d652:	0e 93       	st	-X, r16
    d654:	11 97       	sbiw	r26, 0x01	; 1
    d656:	82 e3       	ldi	r24, 0x32	; 50
    d658:	93 e1       	ldi	r25, 0x13	; 19
    d65a:	93 83       	std	Z+3, r25	; 0x03
    d65c:	82 83       	std	Z+2, r24	; 0x02
    d65e:	80 91 78 02 	lds	r24, 0x0278
    d662:	84 83       	std	Z+4, r24	; 0x04
    d664:	15 82       	std	Z+5, r1	; 0x05
    d666:	80 91 79 02 	lds	r24, 0x0279
    d66a:	86 83       	std	Z+6, r24	; 0x06
    d66c:	17 82       	std	Z+7, r1	; 0x07
    d66e:	80 91 7a 02 	lds	r24, 0x027A
    d672:	80 87       	std	Z+8, r24	; 0x08
    d674:	11 86       	std	Z+9, r1	; 0x09
    d676:	80 91 7b 02 	lds	r24, 0x027B
    d67a:	82 87       	std	Z+10, r24	; 0x0a
    d67c:	13 86       	std	Z+11, r1	; 0x0b
    d67e:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
	           lcd_print(2,1,lcdteks);
    d682:	ed b7       	in	r30, 0x3d	; 61
    d684:	fe b7       	in	r31, 0x3e	; 62
    d686:	3c 96       	adiw	r30, 0x0c	; 12
    d688:	0f b6       	in	r0, 0x3f	; 63
    d68a:	f8 94       	cli
    d68c:	fe bf       	out	0x3e, r31	; 62
    d68e:	0f be       	out	0x3f, r0	; 63
    d690:	ed bf       	out	0x3d, r30	; 61
    d692:	82 e0       	ldi	r24, 0x02	; 2
    d694:	61 e0       	ldi	r22, 0x01	; 1
    d696:	a8 01       	movw	r20, r16
    d698:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
			   lcd_printf(3,1,PSTR("New:   _.   .   .   "));
    d69c:	83 e0       	ldi	r24, 0x03	; 3
    d69e:	61 e0       	ldi	r22, 0x01	; 1
    d6a0:	4d e1       	ldi	r20, 0x1D	; 29
    d6a2:	53 e1       	ldi	r21, 0x13	; 19
    d6a4:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
			   lcd_printf(4,1,PSTR("[*]cancel  [#]next  "));
    d6a8:	84 e0       	ldi	r24, 0x04	; 4
    d6aa:	61 e0       	ldi	r22, 0x01	; 1
    d6ac:	48 e0       	ldi	r20, 0x08	; 8
    d6ae:	53 e1       	ldi	r21, 0x13	; 19
    d6b0:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
               iLoop=0;
    d6b4:	10 92 77 02 	sts	0x0277, r1
    d6b8:	10 92 76 02 	sts	0x0276, r1
			   y=3,x=8;
    d6bc:	83 e0       	ldi	r24, 0x03	; 3
    d6be:	80 93 7d 02 	sts	0x027D, r24
    d6c2:	88 e0       	ldi	r24, 0x08	; 8
    d6c4:	80 93 7e 02 	sts	0x027E, r24
			   iInput=0; iBlok=0;
    d6c8:	10 92 7c 02 	sts	0x027C, r1
    d6cc:	10 92 75 02 	sts	0x0275, r1
    d6d0:	10 92 74 02 	sts	0x0274, r1
			   IPchar[0]='0';IPchar[1]='0';IPchar[2]='0';
    d6d4:	80 e3       	ldi	r24, 0x30	; 48
    d6d6:	80 93 81 02 	sts	0x0281, r24
    d6da:	80 93 82 02 	sts	0x0282, r24
    d6de:	80 93 83 02 	sts	0x0283, r24
			   stClientIP=cipInputIP; 
    d6e2:	82 e0       	ldi	r24, 0x02	; 2
    d6e4:	e4 c1       	rjmp	.+968    	; 0xdaae <FMenuSettingServerIP+0x4e6>
		       break;
          case cipInputIP:
			   //Blinking 60% _ 
			   iLoop++;
    d6e6:	80 91 76 02 	lds	r24, 0x0276
    d6ea:	90 91 77 02 	lds	r25, 0x0277
    d6ee:	01 96       	adiw	r24, 0x01	; 1
    d6f0:	90 93 77 02 	sts	0x0277, r25
    d6f4:	80 93 76 02 	sts	0x0276, r24
			   if ((iLoop%2000)==0){
    d6f8:	60 ed       	ldi	r22, 0xD0	; 208
    d6fa:	77 e0       	ldi	r23, 0x07	; 7
    d6fc:	0e 94 0a b7 	call	0x16e14	; 0x16e14 <__udivmodhi4>
    d700:	89 2b       	or	r24, r25
    d702:	81 f4       	brne	.+32     	; 0xd724 <FMenuSettingServerIP+0x15c>
			      lcd_put(y,(x+(iBlok*4)),'_'); 
    d704:	80 91 74 02 	lds	r24, 0x0274
    d708:	90 91 75 02 	lds	r25, 0x0275
    d70c:	88 0f       	add	r24, r24
    d70e:	99 1f       	adc	r25, r25
    d710:	88 0f       	add	r24, r24
    d712:	99 1f       	adc	r25, r25
    d714:	60 91 7e 02 	lds	r22, 0x027E
    d718:	68 0f       	add	r22, r24
    d71a:	80 91 7d 02 	lds	r24, 0x027D
    d71e:	4f e5       	ldi	r20, 0x5F	; 95
    d720:	0e 94 58 ad 	call	0x15ab0	; 0x15ab0 <lcd_put>
			   }
			   if ((iLoop%2000)==1000){
    d724:	80 91 76 02 	lds	r24, 0x0276
    d728:	90 91 77 02 	lds	r25, 0x0277
    d72c:	60 ed       	ldi	r22, 0xD0	; 208
    d72e:	77 e0       	ldi	r23, 0x07	; 7
    d730:	0e 94 0a b7 	call	0x16e14	; 0x16e14 <__udivmodhi4>
    d734:	88 5e       	subi	r24, 0xE8	; 232
    d736:	93 40       	sbci	r25, 0x03	; 3
    d738:	81 f4       	brne	.+32     	; 0xd75a <FMenuSettingServerIP+0x192>
			      lcd_put(y,(x+(iBlok*4)),' '); 
    d73a:	80 91 74 02 	lds	r24, 0x0274
    d73e:	90 91 75 02 	lds	r25, 0x0275
    d742:	88 0f       	add	r24, r24
    d744:	99 1f       	adc	r25, r25
    d746:	88 0f       	add	r24, r24
    d748:	99 1f       	adc	r25, r25
    d74a:	60 91 7e 02 	lds	r22, 0x027E
    d74e:	68 0f       	add	r22, r24
    d750:	80 91 7d 02 	lds	r24, 0x027D
    d754:	40 e2       	ldi	r20, 0x20	; 32
    d756:	0e 94 58 ad 	call	0x15ab0	; 0x15ab0 <lcd_put>
			   }
			   //GetKeyPressed
			   keyPressed=_key_scan(1);
    d75a:	81 e0       	ldi	r24, 0x01	; 1
    d75c:	0e 94 84 ae 	call	0x15d08	; 0x15d08 <_key_scan>
    d760:	f8 2e       	mov	r15, r24
			   keyChar=_key_btn(keyPressed);
    d762:	0e 94 e5 ad 	call	0x15bca	; 0x15bca <_key_btn>
    d766:	28 2f       	mov	r18, r24
               if ((keyChar>='0')&&(keyChar<='9')){
    d768:	80 53       	subi	r24, 0x30	; 48
    d76a:	8a 30       	cpi	r24, 0x0A	; 10
    d76c:	08 f0       	brcs	.+2      	; 0xd770 <FMenuSettingServerIP+0x1a8>
    d76e:	d6 c0       	rjmp	.+428    	; 0xd91c <FMenuSettingServerIP+0x354>
    d770:	80 e5       	ldi	r24, 0x50	; 80
    d772:	93 ec       	ldi	r25, 0xC3	; 195
    d774:	01 97       	sbiw	r24, 0x01	; 1
    d776:	f1 f7       	brne	.-4      	; 0xd774 <FMenuSettingServerIP+0x1ac>
			       _delay_ms(200);
			       IPchar[iInput]=keyChar;
    d778:	80 91 7c 02 	lds	r24, 0x027C
    d77c:	e8 2f       	mov	r30, r24
    d77e:	f0 e0       	ldi	r31, 0x00	; 0
    d780:	ef 57       	subi	r30, 0x7F	; 127
    d782:	fd 4f       	sbci	r31, 0xFD	; 253
    d784:	20 83       	st	Z, r18
				   iInput++;                    
    d786:	8f 5f       	subi	r24, 0xFF	; 255
    d788:	80 93 7c 02 	sts	0x027C, r24
				   for (i=1;i<(iInput+1);i++){
    d78c:	81 e0       	ldi	r24, 0x01	; 1
    d78e:	1c c0       	rjmp	.+56     	; 0xd7c8 <FMenuSettingServerIP+0x200>
				       lcd_xy(y,((x+(iBlok*4))-(3-i)));_lcd(IPchar[i-1]);
    d790:	80 91 7e 02 	lds	r24, 0x027E
    d794:	68 0f       	add	r22, r24
    d796:	63 50       	subi	r22, 0x03	; 3
    d798:	80 91 74 02 	lds	r24, 0x0274
    d79c:	90 91 75 02 	lds	r25, 0x0275
    d7a0:	88 0f       	add	r24, r24
    d7a2:	99 1f       	adc	r25, r25
    d7a4:	88 0f       	add	r24, r24
    d7a6:	99 1f       	adc	r25, r25
    d7a8:	68 0f       	add	r22, r24
    d7aa:	80 91 7d 02 	lds	r24, 0x027D
    d7ae:	0e 94 ca ac 	call	0x15994	; 0x15994 <lcd_xy>
    d7b2:	e0 91 80 02 	lds	r30, 0x0280
    d7b6:	f0 e0       	ldi	r31, 0x00	; 0
    d7b8:	e0 58       	subi	r30, 0x80	; 128
    d7ba:	fd 4f       	sbci	r31, 0xFD	; 253
    d7bc:	80 81       	ld	r24, Z
    d7be:	0e 94 a4 ac 	call	0x15948	; 0x15948 <_lcd>
			   keyChar=_key_btn(keyPressed);
               if ((keyChar>='0')&&(keyChar<='9')){
			       _delay_ms(200);
			       IPchar[iInput]=keyChar;
				   iInput++;                    
				   for (i=1;i<(iInput+1);i++){
    d7c2:	80 91 80 02 	lds	r24, 0x0280
    d7c6:	8f 5f       	subi	r24, 0xFF	; 255
    d7c8:	80 93 80 02 	sts	0x0280, r24
    d7cc:	70 91 7c 02 	lds	r23, 0x027C
    d7d0:	60 91 80 02 	lds	r22, 0x0280
    d7d4:	27 2f       	mov	r18, r23
    d7d6:	30 e0       	ldi	r19, 0x00	; 0
    d7d8:	86 2f       	mov	r24, r22
    d7da:	90 e0       	ldi	r25, 0x00	; 0
    d7dc:	28 17       	cp	r18, r24
    d7de:	39 07       	cpc	r19, r25
    d7e0:	bc f6       	brge	.-82     	; 0xd790 <FMenuSettingServerIP+0x1c8>
				       lcd_xy(y,((x+(iBlok*4))-(3-i)));_lcd(IPchar[i-1]);
				   }
                   //NextInput
				   if (iInput>=3){
    d7e2:	73 30       	cpi	r23, 0x03	; 3
    d7e4:	08 f4       	brcc	.+2      	; 0xd7e8 <FMenuSettingServerIP+0x220>
    d7e6:	91 c0       	rjmp	.+290    	; 0xd90a <FMenuSettingServerIP+0x342>
				       IP_blok[iBlok]=((IPchar[0]-'0')*100)+((IPchar[1]-'0')*10)+((IPchar[2]-'0'));
    d7e8:	40 91 74 02 	lds	r20, 0x0274
    d7ec:	50 91 75 02 	lds	r21, 0x0275
    d7f0:	fa 01       	movw	r30, r20
    d7f2:	e8 58       	subi	r30, 0x88	; 136
    d7f4:	fd 4f       	sbci	r31, 0xFD	; 253
    d7f6:	20 91 83 02 	lds	r18, 0x0283
    d7fa:	20 5d       	subi	r18, 0xD0	; 208
    d7fc:	80 91 81 02 	lds	r24, 0x0281
    d800:	34 e6       	ldi	r19, 0x64	; 100
    d802:	83 9f       	mul	r24, r19
    d804:	c0 01       	movw	r24, r0
    d806:	11 24       	eor	r1, r1
    d808:	28 0f       	add	r18, r24
    d80a:	80 91 82 02 	lds	r24, 0x0282
    d80e:	3a e0       	ldi	r19, 0x0A	; 10
    d810:	83 9f       	mul	r24, r19
    d812:	c0 01       	movw	r24, r0
    d814:	11 24       	eor	r1, r1
    d816:	28 0f       	add	r18, r24
    d818:	20 83       	st	Z, r18
					   IPchar[0]='0';IPchar[1]='0';IPchar[2]='0';
    d81a:	80 e3       	ldi	r24, 0x30	; 48
    d81c:	80 93 81 02 	sts	0x0281, r24
    d820:	80 93 82 02 	sts	0x0282, r24
    d824:	80 93 83 02 	sts	0x0283, r24
					   //Reposition Value
					   lcd_printf(y,((x+(iBlok*4))-iInput),PSTR("   "));
    d828:	44 0f       	add	r20, r20
    d82a:	55 1f       	adc	r21, r21
    d82c:	44 0f       	add	r20, r20
    d82e:	55 1f       	adc	r21, r21
    d830:	60 91 7e 02 	lds	r22, 0x027E
    d834:	64 0f       	add	r22, r20
    d836:	67 1b       	sub	r22, r23
    d838:	80 91 7d 02 	lds	r24, 0x027D
    d83c:	44 e0       	ldi	r20, 0x04	; 4
    d83e:	53 e1       	ldi	r21, 0x13	; 19
    d840:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
					   sprintf_P(lcdteks,PSTR("%d"),IP_blok[iBlok]);
    d844:	00 d0       	rcall	.+0      	; 0xd846 <FMenuSettingServerIP+0x27e>
    d846:	00 d0       	rcall	.+0      	; 0xd848 <FMenuSettingServerIP+0x280>
    d848:	00 d0       	rcall	.+0      	; 0xd84a <FMenuSettingServerIP+0x282>
    d84a:	ad b7       	in	r26, 0x3d	; 61
    d84c:	be b7       	in	r27, 0x3e	; 62
    d84e:	11 96       	adiw	r26, 0x01	; 1
    d850:	8e 01       	movw	r16, r28
    d852:	0f 5f       	subi	r16, 0xFF	; 255
    d854:	1f 4f       	sbci	r17, 0xFF	; 255
    d856:	ed b7       	in	r30, 0x3d	; 61
    d858:	fe b7       	in	r31, 0x3e	; 62
    d85a:	12 83       	std	Z+2, r17	; 0x02
    d85c:	01 83       	std	Z+1, r16	; 0x01
    d85e:	81 e0       	ldi	r24, 0x01	; 1
    d860:	93 e1       	ldi	r25, 0x13	; 19
    d862:	13 96       	adiw	r26, 0x03	; 3
    d864:	9c 93       	st	X, r25
    d866:	8e 93       	st	-X, r24
    d868:	12 97       	sbiw	r26, 0x02	; 2
    d86a:	e0 91 74 02 	lds	r30, 0x0274
    d86e:	f0 91 75 02 	lds	r31, 0x0275
    d872:	e8 58       	subi	r30, 0x88	; 136
    d874:	fd 4f       	sbci	r31, 0xFD	; 253
    d876:	80 81       	ld	r24, Z
    d878:	14 96       	adiw	r26, 0x04	; 4
    d87a:	8c 93       	st	X, r24
    d87c:	14 97       	sbiw	r26, 0x04	; 4
    d87e:	15 96       	adiw	r26, 0x05	; 5
    d880:	1c 92       	st	X, r1
    d882:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
                       lcd_print(y,1+((x+(iBlok*4))-strlen(lcdteks)),lcdteks);
    d886:	f8 01       	movw	r30, r16
    d888:	01 90       	ld	r0, Z+
    d88a:	00 20       	and	r0, r0
    d88c:	e9 f7       	brne	.-6      	; 0xd888 <FMenuSettingServerIP+0x2c0>
    d88e:	31 97       	sbiw	r30, 0x01	; 1
    d890:	e0 1b       	sub	r30, r16
    d892:	f1 0b       	sbc	r31, r17
    d894:	8d b7       	in	r24, 0x3d	; 61
    d896:	9e b7       	in	r25, 0x3e	; 62
    d898:	06 96       	adiw	r24, 0x06	; 6
    d89a:	0f b6       	in	r0, 0x3f	; 63
    d89c:	f8 94       	cli
    d89e:	9e bf       	out	0x3e, r25	; 62
    d8a0:	0f be       	out	0x3f, r0	; 63
    d8a2:	8d bf       	out	0x3d, r24	; 61
    d8a4:	60 91 7e 02 	lds	r22, 0x027E
    d8a8:	6f 5f       	subi	r22, 0xFF	; 255
    d8aa:	80 91 74 02 	lds	r24, 0x0274
    d8ae:	90 91 75 02 	lds	r25, 0x0275
    d8b2:	88 0f       	add	r24, r24
    d8b4:	99 1f       	adc	r25, r25
    d8b6:	88 0f       	add	r24, r24
    d8b8:	99 1f       	adc	r25, r25
    d8ba:	68 0f       	add	r22, r24
    d8bc:	6e 1b       	sub	r22, r30
    d8be:	80 91 7d 02 	lds	r24, 0x027D
    d8c2:	a8 01       	movw	r20, r16
    d8c4:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
					   if (iBlok>0)lcd_printf(y,1+((x+((iBlok-1)*4))),PSTR("."));
    d8c8:	80 91 74 02 	lds	r24, 0x0274
    d8cc:	90 91 75 02 	lds	r25, 0x0275
    d8d0:	00 97       	sbiw	r24, 0x00	; 0
    d8d2:	81 f0       	breq	.+32     	; 0xd8f4 <FMenuSettingServerIP+0x32c>
    d8d4:	60 91 7e 02 	lds	r22, 0x027E
    d8d8:	6f 5f       	subi	r22, 0xFF	; 255
    d8da:	81 50       	subi	r24, 0x01	; 1
    d8dc:	90 4c       	sbci	r25, 0xC0	; 192
    d8de:	88 0f       	add	r24, r24
    d8e0:	99 1f       	adc	r25, r25
    d8e2:	88 0f       	add	r24, r24
    d8e4:	99 1f       	adc	r25, r25
    d8e6:	68 0f       	add	r22, r24
    d8e8:	80 91 7d 02 	lds	r24, 0x027D
    d8ec:	4f ef       	ldi	r20, 0xFF	; 255
    d8ee:	52 e1       	ldi	r21, 0x12	; 18
    d8f0:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
					   iInput=0;
    d8f4:	10 92 7c 02 	sts	0x027C, r1
					   iBlok++;
    d8f8:	80 91 74 02 	lds	r24, 0x0274
    d8fc:	90 91 75 02 	lds	r25, 0x0275
    d900:	01 96       	adiw	r24, 0x01	; 1
    d902:	90 93 75 02 	sts	0x0275, r25
    d906:	80 93 74 02 	sts	0x0274, r24

				   }
				   if (iBlok>=4)stClientIP=cipStoreIPblok;
    d90a:	80 91 74 02 	lds	r24, 0x0274
    d90e:	90 91 75 02 	lds	r25, 0x0275
    d912:	04 97       	sbiw	r24, 0x04	; 4
    d914:	18 f0       	brcs	.+6      	; 0xd91c <FMenuSettingServerIP+0x354>
    d916:	84 e0       	ldi	r24, 0x04	; 4
    d918:	80 93 48 01 	sts	0x0148, r24
			   }

			   if (keyPressed==_KEY_CANCEL){
    d91c:	97 ee       	ldi	r25, 0xE7	; 231
    d91e:	f9 16       	cp	r15, r25
    d920:	09 f4       	brne	.+2      	; 0xd924 <FMenuSettingServerIP+0x35c>
    d922:	c4 c0       	rjmp	.+392    	; 0xdaac <FMenuSettingServerIP+0x4e4>
			       stClientIP=cipExit; 
			   }
			   else
			   if (keyPressed==_KEY_ENTER){
    d924:	a7 eb       	ldi	r26, 0xB7	; 183
    d926:	fa 16       	cp	r15, r26
    d928:	09 f0       	breq	.+2      	; 0xd92c <FMenuSettingServerIP+0x364>
    d92a:	c9 c0       	rjmp	.+402    	; 0xdabe <FMenuSettingServerIP+0x4f6>
			       //NextInput
			       if (iBlok<4){
    d92c:	40 91 74 02 	lds	r20, 0x0274
    d930:	50 91 75 02 	lds	r21, 0x0275
    d934:	44 30       	cpi	r20, 0x04	; 4
    d936:	51 05       	cpc	r21, r1
    d938:	08 f0       	brcs	.+2      	; 0xd93c <FMenuSettingServerIP+0x374>
    d93a:	a6 c0       	rjmp	.+332    	; 0xda88 <FMenuSettingServerIP+0x4c0>
				       if (iInput==1)IP_blok[iBlok]=((IPchar[0]-'0'));
    d93c:	80 91 7c 02 	lds	r24, 0x027C
    d940:	81 30       	cpi	r24, 0x01	; 1
    d942:	41 f4       	brne	.+16     	; 0xd954 <FMenuSettingServerIP+0x38c>
    d944:	fa 01       	movw	r30, r20
    d946:	e8 58       	subi	r30, 0x88	; 136
    d948:	fd 4f       	sbci	r31, 0xFD	; 253
    d94a:	80 91 81 02 	lds	r24, 0x0281
    d94e:	80 53       	subi	r24, 0x30	; 48
    d950:	80 83       	st	Z, r24
    d952:	22 c0       	rjmp	.+68     	; 0xd998 <FMenuSettingServerIP+0x3d0>
					   if (iInput==2)IP_blok[iBlok]=((IPchar[0]-'0')*10)+(IPchar[1]-'0');
    d954:	82 30       	cpi	r24, 0x02	; 2
    d956:	49 f4       	brne	.+18     	; 0xd96a <FMenuSettingServerIP+0x3a2>
    d958:	fa 01       	movw	r30, r20
    d95a:	e8 58       	subi	r30, 0x88	; 136
    d95c:	fd 4f       	sbci	r31, 0xFD	; 253
    d95e:	20 91 82 02 	lds	r18, 0x0282
    d962:	20 51       	subi	r18, 0x10	; 16
    d964:	80 91 81 02 	lds	r24, 0x0281
    d968:	11 c0       	rjmp	.+34     	; 0xd98c <FMenuSettingServerIP+0x3c4>
					   if (iInput==3)IP_blok[iBlok]=((IPchar[0]-'0')*100)+((IPchar[1]-'0')*10)+((IPchar[2]-'0'));
    d96a:	83 30       	cpi	r24, 0x03	; 3
    d96c:	a9 f4       	brne	.+42     	; 0xd998 <FMenuSettingServerIP+0x3d0>
    d96e:	fa 01       	movw	r30, r20
    d970:	e8 58       	subi	r30, 0x88	; 136
    d972:	fd 4f       	sbci	r31, 0xFD	; 253
    d974:	20 91 83 02 	lds	r18, 0x0283
    d978:	20 5d       	subi	r18, 0xD0	; 208
    d97a:	80 91 81 02 	lds	r24, 0x0281
    d97e:	34 e6       	ldi	r19, 0x64	; 100
    d980:	83 9f       	mul	r24, r19
    d982:	c0 01       	movw	r24, r0
    d984:	11 24       	eor	r1, r1
    d986:	28 0f       	add	r18, r24
    d988:	80 91 82 02 	lds	r24, 0x0282
    d98c:	3a e0       	ldi	r19, 0x0A	; 10
    d98e:	83 9f       	mul	r24, r19
    d990:	c0 01       	movw	r24, r0
    d992:	11 24       	eor	r1, r1
    d994:	28 0f       	add	r18, r24
    d996:	20 83       	st	Z, r18
				       
					   IPchar[0]='0';IPchar[1]='0';IPchar[2]='0';
    d998:	80 e3       	ldi	r24, 0x30	; 48
    d99a:	80 93 81 02 	sts	0x0281, r24
    d99e:	80 93 82 02 	sts	0x0282, r24
    d9a2:	80 93 83 02 	sts	0x0283, r24
					   //Reposition Value
					   lcd_printf(y,((x+(iBlok*4))-3),PSTR("   "));
    d9a6:	60 91 7e 02 	lds	r22, 0x027E
    d9aa:	63 50       	subi	r22, 0x03	; 3
    d9ac:	44 0f       	add	r20, r20
    d9ae:	55 1f       	adc	r21, r21
    d9b0:	44 0f       	add	r20, r20
    d9b2:	55 1f       	adc	r21, r21
    d9b4:	64 0f       	add	r22, r20
    d9b6:	80 91 7d 02 	lds	r24, 0x027D
    d9ba:	4b ef       	ldi	r20, 0xFB	; 251
    d9bc:	52 e1       	ldi	r21, 0x12	; 18
    d9be:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
					   sprintf_P(lcdteks,PSTR("%d"),IP_blok[iBlok]);
    d9c2:	00 d0       	rcall	.+0      	; 0xd9c4 <FMenuSettingServerIP+0x3fc>
    d9c4:	00 d0       	rcall	.+0      	; 0xd9c6 <FMenuSettingServerIP+0x3fe>
    d9c6:	00 d0       	rcall	.+0      	; 0xd9c8 <FMenuSettingServerIP+0x400>
    d9c8:	ad b7       	in	r26, 0x3d	; 61
    d9ca:	be b7       	in	r27, 0x3e	; 62
    d9cc:	11 96       	adiw	r26, 0x01	; 1
    d9ce:	8e 01       	movw	r16, r28
    d9d0:	0f 5f       	subi	r16, 0xFF	; 255
    d9d2:	1f 4f       	sbci	r17, 0xFF	; 255
    d9d4:	ed b7       	in	r30, 0x3d	; 61
    d9d6:	fe b7       	in	r31, 0x3e	; 62
    d9d8:	12 83       	std	Z+2, r17	; 0x02
    d9da:	01 83       	std	Z+1, r16	; 0x01
    d9dc:	88 ef       	ldi	r24, 0xF8	; 248
    d9de:	92 e1       	ldi	r25, 0x12	; 18
    d9e0:	13 96       	adiw	r26, 0x03	; 3
    d9e2:	9c 93       	st	X, r25
    d9e4:	8e 93       	st	-X, r24
    d9e6:	12 97       	sbiw	r26, 0x02	; 2
    d9e8:	e0 91 74 02 	lds	r30, 0x0274
    d9ec:	f0 91 75 02 	lds	r31, 0x0275
    d9f0:	e8 58       	subi	r30, 0x88	; 136
    d9f2:	fd 4f       	sbci	r31, 0xFD	; 253
    d9f4:	80 81       	ld	r24, Z
    d9f6:	14 96       	adiw	r26, 0x04	; 4
    d9f8:	8c 93       	st	X, r24
    d9fa:	14 97       	sbiw	r26, 0x04	; 4
    d9fc:	15 96       	adiw	r26, 0x05	; 5
    d9fe:	1c 92       	st	X, r1
    da00:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
                       lcd_print(y,1+((x+(iBlok*4))-strlen(lcdteks)),lcdteks);
    da04:	f8 01       	movw	r30, r16
    da06:	01 90       	ld	r0, Z+
    da08:	00 20       	and	r0, r0
    da0a:	e9 f7       	brne	.-6      	; 0xda06 <FMenuSettingServerIP+0x43e>
    da0c:	31 97       	sbiw	r30, 0x01	; 1
    da0e:	e0 1b       	sub	r30, r16
    da10:	f1 0b       	sbc	r31, r17
    da12:	8d b7       	in	r24, 0x3d	; 61
    da14:	9e b7       	in	r25, 0x3e	; 62
    da16:	06 96       	adiw	r24, 0x06	; 6
    da18:	0f b6       	in	r0, 0x3f	; 63
    da1a:	f8 94       	cli
    da1c:	9e bf       	out	0x3e, r25	; 62
    da1e:	0f be       	out	0x3f, r0	; 63
    da20:	8d bf       	out	0x3d, r24	; 61
    da22:	60 91 7e 02 	lds	r22, 0x027E
    da26:	6f 5f       	subi	r22, 0xFF	; 255
    da28:	80 91 74 02 	lds	r24, 0x0274
    da2c:	90 91 75 02 	lds	r25, 0x0275
    da30:	88 0f       	add	r24, r24
    da32:	99 1f       	adc	r25, r25
    da34:	88 0f       	add	r24, r24
    da36:	99 1f       	adc	r25, r25
    da38:	68 0f       	add	r22, r24
    da3a:	6e 1b       	sub	r22, r30
    da3c:	80 91 7d 02 	lds	r24, 0x027D
    da40:	a8 01       	movw	r20, r16
    da42:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>

					   if (iBlok>0)lcd_printf(y,1+((x+((iBlok-1)*4))),PSTR("."));
    da46:	80 91 74 02 	lds	r24, 0x0274
    da4a:	90 91 75 02 	lds	r25, 0x0275
    da4e:	00 97       	sbiw	r24, 0x00	; 0
    da50:	81 f0       	breq	.+32     	; 0xda72 <FMenuSettingServerIP+0x4aa>
    da52:	60 91 7e 02 	lds	r22, 0x027E
    da56:	6f 5f       	subi	r22, 0xFF	; 255
    da58:	81 50       	subi	r24, 0x01	; 1
    da5a:	90 4c       	sbci	r25, 0xC0	; 192
    da5c:	88 0f       	add	r24, r24
    da5e:	99 1f       	adc	r25, r25
    da60:	88 0f       	add	r24, r24
    da62:	99 1f       	adc	r25, r25
    da64:	68 0f       	add	r22, r24
    da66:	80 91 7d 02 	lds	r24, 0x027D
    da6a:	46 ef       	ldi	r20, 0xF6	; 246
    da6c:	52 e1       	ldi	r21, 0x12	; 18
    da6e:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
				       iInput=0;
    da72:	10 92 7c 02 	sts	0x027C, r1
					   iBlok++;	   
    da76:	80 91 74 02 	lds	r24, 0x0274
    da7a:	90 91 75 02 	lds	r25, 0x0275
    da7e:	01 96       	adiw	r24, 0x01	; 1
    da80:	90 93 75 02 	sts	0x0275, r25
    da84:	80 93 74 02 	sts	0x0274, r24
				   }
				   if (iBlok>=4)stClientIP=cipStoreIPblok;
    da88:	80 91 74 02 	lds	r24, 0x0274
    da8c:	90 91 75 02 	lds	r25, 0x0275
    da90:	04 97       	sbiw	r24, 0x04	; 4
    da92:	a8 f0       	brcs	.+42     	; 0xdabe <FMenuSettingServerIP+0x4f6>
    da94:	84 e0       	ldi	r24, 0x04	; 4
    da96:	0b c0       	rjmp	.+22     	; 0xdaae <FMenuSettingServerIP+0x4e6>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    da98:	8c e2       	ldi	r24, 0x2C	; 44
    da9a:	90 e0       	ldi	r25, 0x00	; 0
    da9c:	68 e7       	ldi	r22, 0x78	; 120
    da9e:	72 e0       	ldi	r23, 0x02	; 2
    daa0:	44 e0       	ldi	r20, 0x04	; 4
    daa2:	50 e0       	ldi	r21, 0x00	; 0
    daa4:	25 e0       	ldi	r18, 0x05	; 5
    daa6:	33 e1       	ldi	r19, 0x13	; 19
    daa8:	0e 94 0d b4 	call	0x1681a	; 0x1681a <__eewr_block>
			   }
		       break;
          case cipStoreIPblok:
		       //UpdateIPblok
			   eeprom_write_block((const void*) &IP_blok,(const void*) &DefServerIP,4);
			   stClientIP=cipExit;
    daac:	83 e0       	ldi	r24, 0x03	; 3
    daae:	80 93 48 01 	sts	0x0148, r24
    dab2:	05 c0       	rjmp	.+10     	; 0xdabe <FMenuSettingServerIP+0x4f6>
		       break; 
          case cipExit://Cancel IPConfig
			   stClientIP=cipInit;
    dab4:	81 e0       	ldi	r24, 0x01	; 1
    dab6:	80 93 48 01 	sts	0x0148, r24
			   Result=MENU_DONE;
    daba:	80 93 7f 02 	sts	0x027F, r24
		       break;     
		  }//EndSwitch	 
	return Result;
}
    dabe:	80 91 7f 02 	lds	r24, 0x027F
    dac2:	64 96       	adiw	r28, 0x14	; 20
    dac4:	0f b6       	in	r0, 0x3f	; 63
    dac6:	f8 94       	cli
    dac8:	de bf       	out	0x3e, r29	; 62
    daca:	0f be       	out	0x3f, r0	; 63
    dacc:	cd bf       	out	0x3d, r28	; 61
    dace:	cf 91       	pop	r28
    dad0:	df 91       	pop	r29
    dad2:	1f 91       	pop	r17
    dad4:	0f 91       	pop	r16
    dad6:	ff 90       	pop	r15
    dad8:	08 95       	ret

0000dada <FMenuSettingClientIP>:





char FMenuSettingClientIP(){
    dada:	ff 92       	push	r15
    dadc:	0f 93       	push	r16
    dade:	1f 93       	push	r17
    dae0:	df 93       	push	r29
    dae2:	cf 93       	push	r28
    dae4:	cd b7       	in	r28, 0x3d	; 61
    dae6:	de b7       	in	r29, 0x3e	; 62
    dae8:	64 97       	sbiw	r28, 0x14	; 20
    daea:	0f b6       	in	r0, 0x3f	; 63
    daec:	f8 94       	cli
    daee:	de bf       	out	0x3e, r29	; 62
    daf0:	0f be       	out	0x3f, r0	; 63
    daf2:	cd bf       	out	0x3d, r28	; 61
     //Client IP
     //Old: 192.168.123.000
	 //New:   _.   .   .
	 //--------------------
	 //*)cancel    #)next
     Result=MENU_NONE;
    daf4:	10 92 8f 02 	sts	0x028F, r1
	 switch(stClientIP){
    daf8:	80 91 49 01 	lds	r24, 0x0149
    dafc:	82 30       	cpi	r24, 0x02	; 2
    dafe:	09 f4       	brne	.+2      	; 0xdb02 <FMenuSettingClientIP+0x28>
    db00:	7b c0       	rjmp	.+246    	; 0xdbf8 <FMenuSettingClientIP+0x11e>
    db02:	83 30       	cpi	r24, 0x03	; 3
    db04:	20 f4       	brcc	.+8      	; 0xdb0e <FMenuSettingClientIP+0x34>
    db06:	81 30       	cpi	r24, 0x01	; 1
    db08:	09 f0       	breq	.+2      	; 0xdb0c <FMenuSettingClientIP+0x32>
    db0a:	62 c2       	rjmp	.+1220   	; 0xdfd0 <FMenuSettingClientIP+0x4f6>
    db0c:	07 c0       	rjmp	.+14     	; 0xdb1c <FMenuSettingClientIP+0x42>
    db0e:	83 30       	cpi	r24, 0x03	; 3
    db10:	09 f4       	brne	.+2      	; 0xdb14 <FMenuSettingClientIP+0x3a>
    db12:	59 c2       	rjmp	.+1202   	; 0xdfc6 <FMenuSettingClientIP+0x4ec>
    db14:	84 30       	cpi	r24, 0x04	; 4
    db16:	09 f0       	breq	.+2      	; 0xdb1a <FMenuSettingClientIP+0x40>
    db18:	5b c2       	rjmp	.+1206   	; 0xdfd0 <FMenuSettingClientIP+0x4f6>
    db1a:	47 c2       	rjmp	.+1166   	; 0xdfaa <FMenuSettingClientIP+0x4d0>
		  case cipInit:
			   lcd_clear();
    db1c:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
	           lcd_printf(1,1,PSTR("Client IP"));
    db20:	81 e0       	ldi	r24, 0x01	; 1
    db22:	61 e0       	ldi	r22, 0x01	; 1
    db24:	4a e9       	ldi	r20, 0x9A	; 154
    db26:	53 e1       	ldi	r21, 0x13	; 19
    db28:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    db2c:	88 e8       	ldi	r24, 0x88	; 136
    db2e:	92 e0       	ldi	r25, 0x02	; 2
    db30:	68 e2       	ldi	r22, 0x28	; 40
    db32:	70 e0       	ldi	r23, 0x00	; 0
    db34:	44 e0       	ldi	r20, 0x04	; 4
    db36:	50 e0       	ldi	r21, 0x00	; 0
    db38:	2d ef       	ldi	r18, 0xFD	; 253
    db3a:	32 e1       	ldi	r19, 0x12	; 18
    db3c:	0e 94 f1 b3 	call	0x167e2	; 0x167e2 <__eerd_block>
			   eeprom_read_block((void*)&IP_blok,(const void*)&DefClientIP,4);
	           sprintf_P(lcdteks,PSTR("Old: %d.%d.%d.%d"),IP_blok[0],IP_blok[1],IP_blok[2],IP_blok[3]);
    db40:	8d b7       	in	r24, 0x3d	; 61
    db42:	9e b7       	in	r25, 0x3e	; 62
    db44:	0c 97       	sbiw	r24, 0x0c	; 12
    db46:	0f b6       	in	r0, 0x3f	; 63
    db48:	f8 94       	cli
    db4a:	9e bf       	out	0x3e, r25	; 62
    db4c:	0f be       	out	0x3f, r0	; 63
    db4e:	8d bf       	out	0x3d, r24	; 61
    db50:	ed b7       	in	r30, 0x3d	; 61
    db52:	fe b7       	in	r31, 0x3e	; 62
    db54:	31 96       	adiw	r30, 0x01	; 1
    db56:	8e 01       	movw	r16, r28
    db58:	0f 5f       	subi	r16, 0xFF	; 255
    db5a:	1f 4f       	sbci	r17, 0xFF	; 255
    db5c:	ad b7       	in	r26, 0x3d	; 61
    db5e:	be b7       	in	r27, 0x3e	; 62
    db60:	12 96       	adiw	r26, 0x02	; 2
    db62:	1c 93       	st	X, r17
    db64:	0e 93       	st	-X, r16
    db66:	11 97       	sbiw	r26, 0x01	; 1
    db68:	89 e8       	ldi	r24, 0x89	; 137
    db6a:	93 e1       	ldi	r25, 0x13	; 19
    db6c:	93 83       	std	Z+3, r25	; 0x03
    db6e:	82 83       	std	Z+2, r24	; 0x02
    db70:	80 91 88 02 	lds	r24, 0x0288
    db74:	84 83       	std	Z+4, r24	; 0x04
    db76:	15 82       	std	Z+5, r1	; 0x05
    db78:	80 91 89 02 	lds	r24, 0x0289
    db7c:	86 83       	std	Z+6, r24	; 0x06
    db7e:	17 82       	std	Z+7, r1	; 0x07
    db80:	80 91 8a 02 	lds	r24, 0x028A
    db84:	80 87       	std	Z+8, r24	; 0x08
    db86:	11 86       	std	Z+9, r1	; 0x09
    db88:	80 91 8b 02 	lds	r24, 0x028B
    db8c:	82 87       	std	Z+10, r24	; 0x0a
    db8e:	13 86       	std	Z+11, r1	; 0x0b
    db90:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
	           lcd_print(2,1,lcdteks);
    db94:	ed b7       	in	r30, 0x3d	; 61
    db96:	fe b7       	in	r31, 0x3e	; 62
    db98:	3c 96       	adiw	r30, 0x0c	; 12
    db9a:	0f b6       	in	r0, 0x3f	; 63
    db9c:	f8 94       	cli
    db9e:	fe bf       	out	0x3e, r31	; 62
    dba0:	0f be       	out	0x3f, r0	; 63
    dba2:	ed bf       	out	0x3d, r30	; 61
    dba4:	82 e0       	ldi	r24, 0x02	; 2
    dba6:	61 e0       	ldi	r22, 0x01	; 1
    dba8:	a8 01       	movw	r20, r16
    dbaa:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
			   lcd_printf(3,1,PSTR("New:   _.   .   .   "));
    dbae:	83 e0       	ldi	r24, 0x03	; 3
    dbb0:	61 e0       	ldi	r22, 0x01	; 1
    dbb2:	44 e7       	ldi	r20, 0x74	; 116
    dbb4:	53 e1       	ldi	r21, 0x13	; 19
    dbb6:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
			   lcd_printf(4,1,PSTR("[*]cancel  [#]next  "));
    dbba:	84 e0       	ldi	r24, 0x04	; 4
    dbbc:	61 e0       	ldi	r22, 0x01	; 1
    dbbe:	4f e5       	ldi	r20, 0x5F	; 95
    dbc0:	53 e1       	ldi	r21, 0x13	; 19
    dbc2:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
               iLoop=0;
    dbc6:	10 92 87 02 	sts	0x0287, r1
    dbca:	10 92 86 02 	sts	0x0286, r1
			   y=3,x=8;
    dbce:	83 e0       	ldi	r24, 0x03	; 3
    dbd0:	80 93 8d 02 	sts	0x028D, r24
    dbd4:	88 e0       	ldi	r24, 0x08	; 8
    dbd6:	80 93 8e 02 	sts	0x028E, r24
			   iInput=0; iBlok=0;
    dbda:	10 92 8c 02 	sts	0x028C, r1
    dbde:	10 92 85 02 	sts	0x0285, r1
    dbe2:	10 92 84 02 	sts	0x0284, r1
			   IPchar[0]='0';IPchar[1]='0';IPchar[2]='0';
    dbe6:	80 e3       	ldi	r24, 0x30	; 48
    dbe8:	80 93 91 02 	sts	0x0291, r24
    dbec:	80 93 92 02 	sts	0x0292, r24
    dbf0:	80 93 93 02 	sts	0x0293, r24
			   stClientIP=cipInputIP; 
    dbf4:	82 e0       	ldi	r24, 0x02	; 2
    dbf6:	e4 c1       	rjmp	.+968    	; 0xdfc0 <FMenuSettingClientIP+0x4e6>
		       break;
          case cipInputIP:
			   //Blinking 60% _ 
			   iLoop++;
    dbf8:	80 91 86 02 	lds	r24, 0x0286
    dbfc:	90 91 87 02 	lds	r25, 0x0287
    dc00:	01 96       	adiw	r24, 0x01	; 1
    dc02:	90 93 87 02 	sts	0x0287, r25
    dc06:	80 93 86 02 	sts	0x0286, r24
			   if ((iLoop%2000)==0){
    dc0a:	60 ed       	ldi	r22, 0xD0	; 208
    dc0c:	77 e0       	ldi	r23, 0x07	; 7
    dc0e:	0e 94 0a b7 	call	0x16e14	; 0x16e14 <__udivmodhi4>
    dc12:	89 2b       	or	r24, r25
    dc14:	81 f4       	brne	.+32     	; 0xdc36 <FMenuSettingClientIP+0x15c>
			      lcd_put(y,(x+(iBlok*4)),'_'); 
    dc16:	80 91 84 02 	lds	r24, 0x0284
    dc1a:	90 91 85 02 	lds	r25, 0x0285
    dc1e:	88 0f       	add	r24, r24
    dc20:	99 1f       	adc	r25, r25
    dc22:	88 0f       	add	r24, r24
    dc24:	99 1f       	adc	r25, r25
    dc26:	60 91 8e 02 	lds	r22, 0x028E
    dc2a:	68 0f       	add	r22, r24
    dc2c:	80 91 8d 02 	lds	r24, 0x028D
    dc30:	4f e5       	ldi	r20, 0x5F	; 95
    dc32:	0e 94 58 ad 	call	0x15ab0	; 0x15ab0 <lcd_put>
			   }
			   if ((iLoop%2000)==1000){
    dc36:	80 91 86 02 	lds	r24, 0x0286
    dc3a:	90 91 87 02 	lds	r25, 0x0287
    dc3e:	60 ed       	ldi	r22, 0xD0	; 208
    dc40:	77 e0       	ldi	r23, 0x07	; 7
    dc42:	0e 94 0a b7 	call	0x16e14	; 0x16e14 <__udivmodhi4>
    dc46:	88 5e       	subi	r24, 0xE8	; 232
    dc48:	93 40       	sbci	r25, 0x03	; 3
    dc4a:	81 f4       	brne	.+32     	; 0xdc6c <FMenuSettingClientIP+0x192>
			      lcd_put(y,(x+(iBlok*4)),' '); 
    dc4c:	80 91 84 02 	lds	r24, 0x0284
    dc50:	90 91 85 02 	lds	r25, 0x0285
    dc54:	88 0f       	add	r24, r24
    dc56:	99 1f       	adc	r25, r25
    dc58:	88 0f       	add	r24, r24
    dc5a:	99 1f       	adc	r25, r25
    dc5c:	60 91 8e 02 	lds	r22, 0x028E
    dc60:	68 0f       	add	r22, r24
    dc62:	80 91 8d 02 	lds	r24, 0x028D
    dc66:	40 e2       	ldi	r20, 0x20	; 32
    dc68:	0e 94 58 ad 	call	0x15ab0	; 0x15ab0 <lcd_put>
			   }
			   //GetKeyPressed
			   keyPressed=_key_scan(1);
    dc6c:	81 e0       	ldi	r24, 0x01	; 1
    dc6e:	0e 94 84 ae 	call	0x15d08	; 0x15d08 <_key_scan>
    dc72:	f8 2e       	mov	r15, r24
			   keyChar=_key_btn(keyPressed);
    dc74:	0e 94 e5 ad 	call	0x15bca	; 0x15bca <_key_btn>
    dc78:	28 2f       	mov	r18, r24
               if ((keyChar>='0')&&(keyChar<='9')){
    dc7a:	80 53       	subi	r24, 0x30	; 48
    dc7c:	8a 30       	cpi	r24, 0x0A	; 10
    dc7e:	08 f0       	brcs	.+2      	; 0xdc82 <FMenuSettingClientIP+0x1a8>
    dc80:	d6 c0       	rjmp	.+428    	; 0xde2e <FMenuSettingClientIP+0x354>
    dc82:	80 e5       	ldi	r24, 0x50	; 80
    dc84:	93 ec       	ldi	r25, 0xC3	; 195
    dc86:	01 97       	sbiw	r24, 0x01	; 1
    dc88:	f1 f7       	brne	.-4      	; 0xdc86 <FMenuSettingClientIP+0x1ac>
			       _delay_ms(200);
			       IPchar[iInput]=keyChar;
    dc8a:	80 91 8c 02 	lds	r24, 0x028C
    dc8e:	e8 2f       	mov	r30, r24
    dc90:	f0 e0       	ldi	r31, 0x00	; 0
    dc92:	ef 56       	subi	r30, 0x6F	; 111
    dc94:	fd 4f       	sbci	r31, 0xFD	; 253
    dc96:	20 83       	st	Z, r18
				   iInput++;                    
    dc98:	8f 5f       	subi	r24, 0xFF	; 255
    dc9a:	80 93 8c 02 	sts	0x028C, r24
				   for (i=1;i<(iInput+1);i++){
    dc9e:	81 e0       	ldi	r24, 0x01	; 1
    dca0:	1c c0       	rjmp	.+56     	; 0xdcda <FMenuSettingClientIP+0x200>
				       lcd_xy(y,((x+(iBlok*4))-(3-i)));_lcd(IPchar[i-1]);
    dca2:	80 91 8e 02 	lds	r24, 0x028E
    dca6:	68 0f       	add	r22, r24
    dca8:	63 50       	subi	r22, 0x03	; 3
    dcaa:	80 91 84 02 	lds	r24, 0x0284
    dcae:	90 91 85 02 	lds	r25, 0x0285
    dcb2:	88 0f       	add	r24, r24
    dcb4:	99 1f       	adc	r25, r25
    dcb6:	88 0f       	add	r24, r24
    dcb8:	99 1f       	adc	r25, r25
    dcba:	68 0f       	add	r22, r24
    dcbc:	80 91 8d 02 	lds	r24, 0x028D
    dcc0:	0e 94 ca ac 	call	0x15994	; 0x15994 <lcd_xy>
    dcc4:	e0 91 90 02 	lds	r30, 0x0290
    dcc8:	f0 e0       	ldi	r31, 0x00	; 0
    dcca:	e0 57       	subi	r30, 0x70	; 112
    dccc:	fd 4f       	sbci	r31, 0xFD	; 253
    dcce:	80 81       	ld	r24, Z
    dcd0:	0e 94 a4 ac 	call	0x15948	; 0x15948 <_lcd>
			   keyChar=_key_btn(keyPressed);
               if ((keyChar>='0')&&(keyChar<='9')){
			       _delay_ms(200);
			       IPchar[iInput]=keyChar;
				   iInput++;                    
				   for (i=1;i<(iInput+1);i++){
    dcd4:	80 91 90 02 	lds	r24, 0x0290
    dcd8:	8f 5f       	subi	r24, 0xFF	; 255
    dcda:	80 93 90 02 	sts	0x0290, r24
    dcde:	70 91 8c 02 	lds	r23, 0x028C
    dce2:	60 91 90 02 	lds	r22, 0x0290
    dce6:	27 2f       	mov	r18, r23
    dce8:	30 e0       	ldi	r19, 0x00	; 0
    dcea:	86 2f       	mov	r24, r22
    dcec:	90 e0       	ldi	r25, 0x00	; 0
    dcee:	28 17       	cp	r18, r24
    dcf0:	39 07       	cpc	r19, r25
    dcf2:	bc f6       	brge	.-82     	; 0xdca2 <FMenuSettingClientIP+0x1c8>
				       lcd_xy(y,((x+(iBlok*4))-(3-i)));_lcd(IPchar[i-1]);
				   }
                   //NextInput
				   if (iInput>=3){
    dcf4:	73 30       	cpi	r23, 0x03	; 3
    dcf6:	08 f4       	brcc	.+2      	; 0xdcfa <FMenuSettingClientIP+0x220>
    dcf8:	91 c0       	rjmp	.+290    	; 0xde1c <FMenuSettingClientIP+0x342>
				       IP_blok[iBlok]=((IPchar[0]-'0')*100)+((IPchar[1]-'0')*10)+((IPchar[2]-'0'));
    dcfa:	40 91 84 02 	lds	r20, 0x0284
    dcfe:	50 91 85 02 	lds	r21, 0x0285
    dd02:	fa 01       	movw	r30, r20
    dd04:	e8 57       	subi	r30, 0x78	; 120
    dd06:	fd 4f       	sbci	r31, 0xFD	; 253
    dd08:	20 91 93 02 	lds	r18, 0x0293
    dd0c:	20 5d       	subi	r18, 0xD0	; 208
    dd0e:	80 91 91 02 	lds	r24, 0x0291
    dd12:	34 e6       	ldi	r19, 0x64	; 100
    dd14:	83 9f       	mul	r24, r19
    dd16:	c0 01       	movw	r24, r0
    dd18:	11 24       	eor	r1, r1
    dd1a:	28 0f       	add	r18, r24
    dd1c:	80 91 92 02 	lds	r24, 0x0292
    dd20:	3a e0       	ldi	r19, 0x0A	; 10
    dd22:	83 9f       	mul	r24, r19
    dd24:	c0 01       	movw	r24, r0
    dd26:	11 24       	eor	r1, r1
    dd28:	28 0f       	add	r18, r24
    dd2a:	20 83       	st	Z, r18
					   IPchar[0]='0';IPchar[1]='0';IPchar[2]='0';
    dd2c:	80 e3       	ldi	r24, 0x30	; 48
    dd2e:	80 93 91 02 	sts	0x0291, r24
    dd32:	80 93 92 02 	sts	0x0292, r24
    dd36:	80 93 93 02 	sts	0x0293, r24
					   //Reposition Value
					   lcd_printf(y,((x+(iBlok*4))-iInput),PSTR("   "));
    dd3a:	44 0f       	add	r20, r20
    dd3c:	55 1f       	adc	r21, r21
    dd3e:	44 0f       	add	r20, r20
    dd40:	55 1f       	adc	r21, r21
    dd42:	60 91 8e 02 	lds	r22, 0x028E
    dd46:	64 0f       	add	r22, r20
    dd48:	67 1b       	sub	r22, r23
    dd4a:	80 91 8d 02 	lds	r24, 0x028D
    dd4e:	4b e5       	ldi	r20, 0x5B	; 91
    dd50:	53 e1       	ldi	r21, 0x13	; 19
    dd52:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
					   sprintf_P(lcdteks,PSTR("%d"),IP_blok[iBlok]);
    dd56:	00 d0       	rcall	.+0      	; 0xdd58 <FMenuSettingClientIP+0x27e>
    dd58:	00 d0       	rcall	.+0      	; 0xdd5a <FMenuSettingClientIP+0x280>
    dd5a:	00 d0       	rcall	.+0      	; 0xdd5c <FMenuSettingClientIP+0x282>
    dd5c:	ad b7       	in	r26, 0x3d	; 61
    dd5e:	be b7       	in	r27, 0x3e	; 62
    dd60:	11 96       	adiw	r26, 0x01	; 1
    dd62:	8e 01       	movw	r16, r28
    dd64:	0f 5f       	subi	r16, 0xFF	; 255
    dd66:	1f 4f       	sbci	r17, 0xFF	; 255
    dd68:	ed b7       	in	r30, 0x3d	; 61
    dd6a:	fe b7       	in	r31, 0x3e	; 62
    dd6c:	12 83       	std	Z+2, r17	; 0x02
    dd6e:	01 83       	std	Z+1, r16	; 0x01
    dd70:	88 e5       	ldi	r24, 0x58	; 88
    dd72:	93 e1       	ldi	r25, 0x13	; 19
    dd74:	13 96       	adiw	r26, 0x03	; 3
    dd76:	9c 93       	st	X, r25
    dd78:	8e 93       	st	-X, r24
    dd7a:	12 97       	sbiw	r26, 0x02	; 2
    dd7c:	e0 91 84 02 	lds	r30, 0x0284
    dd80:	f0 91 85 02 	lds	r31, 0x0285
    dd84:	e8 57       	subi	r30, 0x78	; 120
    dd86:	fd 4f       	sbci	r31, 0xFD	; 253
    dd88:	80 81       	ld	r24, Z
    dd8a:	14 96       	adiw	r26, 0x04	; 4
    dd8c:	8c 93       	st	X, r24
    dd8e:	14 97       	sbiw	r26, 0x04	; 4
    dd90:	15 96       	adiw	r26, 0x05	; 5
    dd92:	1c 92       	st	X, r1
    dd94:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
                       lcd_print(y,1+((x+(iBlok*4))-strlen(lcdteks)),lcdteks);
    dd98:	f8 01       	movw	r30, r16
    dd9a:	01 90       	ld	r0, Z+
    dd9c:	00 20       	and	r0, r0
    dd9e:	e9 f7       	brne	.-6      	; 0xdd9a <FMenuSettingClientIP+0x2c0>
    dda0:	31 97       	sbiw	r30, 0x01	; 1
    dda2:	e0 1b       	sub	r30, r16
    dda4:	f1 0b       	sbc	r31, r17
    dda6:	8d b7       	in	r24, 0x3d	; 61
    dda8:	9e b7       	in	r25, 0x3e	; 62
    ddaa:	06 96       	adiw	r24, 0x06	; 6
    ddac:	0f b6       	in	r0, 0x3f	; 63
    ddae:	f8 94       	cli
    ddb0:	9e bf       	out	0x3e, r25	; 62
    ddb2:	0f be       	out	0x3f, r0	; 63
    ddb4:	8d bf       	out	0x3d, r24	; 61
    ddb6:	60 91 8e 02 	lds	r22, 0x028E
    ddba:	6f 5f       	subi	r22, 0xFF	; 255
    ddbc:	80 91 84 02 	lds	r24, 0x0284
    ddc0:	90 91 85 02 	lds	r25, 0x0285
    ddc4:	88 0f       	add	r24, r24
    ddc6:	99 1f       	adc	r25, r25
    ddc8:	88 0f       	add	r24, r24
    ddca:	99 1f       	adc	r25, r25
    ddcc:	68 0f       	add	r22, r24
    ddce:	6e 1b       	sub	r22, r30
    ddd0:	80 91 8d 02 	lds	r24, 0x028D
    ddd4:	a8 01       	movw	r20, r16
    ddd6:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
					   if (iBlok>0)lcd_printf(y,1+((x+((iBlok-1)*4))),PSTR("."));
    ddda:	80 91 84 02 	lds	r24, 0x0284
    ddde:	90 91 85 02 	lds	r25, 0x0285
    dde2:	00 97       	sbiw	r24, 0x00	; 0
    dde4:	81 f0       	breq	.+32     	; 0xde06 <FMenuSettingClientIP+0x32c>
    dde6:	60 91 8e 02 	lds	r22, 0x028E
    ddea:	6f 5f       	subi	r22, 0xFF	; 255
    ddec:	81 50       	subi	r24, 0x01	; 1
    ddee:	90 4c       	sbci	r25, 0xC0	; 192
    ddf0:	88 0f       	add	r24, r24
    ddf2:	99 1f       	adc	r25, r25
    ddf4:	88 0f       	add	r24, r24
    ddf6:	99 1f       	adc	r25, r25
    ddf8:	68 0f       	add	r22, r24
    ddfa:	80 91 8d 02 	lds	r24, 0x028D
    ddfe:	46 e5       	ldi	r20, 0x56	; 86
    de00:	53 e1       	ldi	r21, 0x13	; 19
    de02:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
					   iInput=0;
    de06:	10 92 8c 02 	sts	0x028C, r1
					   iBlok++;
    de0a:	80 91 84 02 	lds	r24, 0x0284
    de0e:	90 91 85 02 	lds	r25, 0x0285
    de12:	01 96       	adiw	r24, 0x01	; 1
    de14:	90 93 85 02 	sts	0x0285, r25
    de18:	80 93 84 02 	sts	0x0284, r24

				   }
				   if (iBlok>=4)stClientIP=cipStoreIPblok;
    de1c:	80 91 84 02 	lds	r24, 0x0284
    de20:	90 91 85 02 	lds	r25, 0x0285
    de24:	04 97       	sbiw	r24, 0x04	; 4
    de26:	18 f0       	brcs	.+6      	; 0xde2e <FMenuSettingClientIP+0x354>
    de28:	84 e0       	ldi	r24, 0x04	; 4
    de2a:	80 93 49 01 	sts	0x0149, r24
			   }

			   if (keyPressed==_KEY_CANCEL){
    de2e:	97 ee       	ldi	r25, 0xE7	; 231
    de30:	f9 16       	cp	r15, r25
    de32:	09 f4       	brne	.+2      	; 0xde36 <FMenuSettingClientIP+0x35c>
    de34:	c4 c0       	rjmp	.+392    	; 0xdfbe <FMenuSettingClientIP+0x4e4>
			       stClientIP=cipExit; 
			   }
			   else
			   if (keyPressed==_KEY_ENTER){
    de36:	a7 eb       	ldi	r26, 0xB7	; 183
    de38:	fa 16       	cp	r15, r26
    de3a:	09 f0       	breq	.+2      	; 0xde3e <FMenuSettingClientIP+0x364>
    de3c:	c9 c0       	rjmp	.+402    	; 0xdfd0 <FMenuSettingClientIP+0x4f6>
			       //NextInput
			       if (iBlok<4){
    de3e:	40 91 84 02 	lds	r20, 0x0284
    de42:	50 91 85 02 	lds	r21, 0x0285
    de46:	44 30       	cpi	r20, 0x04	; 4
    de48:	51 05       	cpc	r21, r1
    de4a:	08 f0       	brcs	.+2      	; 0xde4e <FMenuSettingClientIP+0x374>
    de4c:	a6 c0       	rjmp	.+332    	; 0xdf9a <FMenuSettingClientIP+0x4c0>
				       if (iInput==1)IP_blok[iBlok]=((IPchar[0]-'0'));
    de4e:	80 91 8c 02 	lds	r24, 0x028C
    de52:	81 30       	cpi	r24, 0x01	; 1
    de54:	41 f4       	brne	.+16     	; 0xde66 <FMenuSettingClientIP+0x38c>
    de56:	fa 01       	movw	r30, r20
    de58:	e8 57       	subi	r30, 0x78	; 120
    de5a:	fd 4f       	sbci	r31, 0xFD	; 253
    de5c:	80 91 91 02 	lds	r24, 0x0291
    de60:	80 53       	subi	r24, 0x30	; 48
    de62:	80 83       	st	Z, r24
    de64:	22 c0       	rjmp	.+68     	; 0xdeaa <FMenuSettingClientIP+0x3d0>
					   if (iInput==2)IP_blok[iBlok]=((IPchar[0]-'0')*10)+(IPchar[1]-'0');
    de66:	82 30       	cpi	r24, 0x02	; 2
    de68:	49 f4       	brne	.+18     	; 0xde7c <FMenuSettingClientIP+0x3a2>
    de6a:	fa 01       	movw	r30, r20
    de6c:	e8 57       	subi	r30, 0x78	; 120
    de6e:	fd 4f       	sbci	r31, 0xFD	; 253
    de70:	20 91 92 02 	lds	r18, 0x0292
    de74:	20 51       	subi	r18, 0x10	; 16
    de76:	80 91 91 02 	lds	r24, 0x0291
    de7a:	11 c0       	rjmp	.+34     	; 0xde9e <FMenuSettingClientIP+0x3c4>
					   if (iInput==3)IP_blok[iBlok]=((IPchar[0]-'0')*100)+((IPchar[1]-'0')*10)+((IPchar[2]-'0'));
    de7c:	83 30       	cpi	r24, 0x03	; 3
    de7e:	a9 f4       	brne	.+42     	; 0xdeaa <FMenuSettingClientIP+0x3d0>
    de80:	fa 01       	movw	r30, r20
    de82:	e8 57       	subi	r30, 0x78	; 120
    de84:	fd 4f       	sbci	r31, 0xFD	; 253
    de86:	20 91 93 02 	lds	r18, 0x0293
    de8a:	20 5d       	subi	r18, 0xD0	; 208
    de8c:	80 91 91 02 	lds	r24, 0x0291
    de90:	34 e6       	ldi	r19, 0x64	; 100
    de92:	83 9f       	mul	r24, r19
    de94:	c0 01       	movw	r24, r0
    de96:	11 24       	eor	r1, r1
    de98:	28 0f       	add	r18, r24
    de9a:	80 91 92 02 	lds	r24, 0x0292
    de9e:	3a e0       	ldi	r19, 0x0A	; 10
    dea0:	83 9f       	mul	r24, r19
    dea2:	c0 01       	movw	r24, r0
    dea4:	11 24       	eor	r1, r1
    dea6:	28 0f       	add	r18, r24
    dea8:	20 83       	st	Z, r18
				       
					   IPchar[0]='0';IPchar[1]='0';IPchar[2]='0';
    deaa:	80 e3       	ldi	r24, 0x30	; 48
    deac:	80 93 91 02 	sts	0x0291, r24
    deb0:	80 93 92 02 	sts	0x0292, r24
    deb4:	80 93 93 02 	sts	0x0293, r24
					   //Reposition Value
					   lcd_printf(y,((x+(iBlok*4))-3),PSTR("   "));
    deb8:	60 91 8e 02 	lds	r22, 0x028E
    debc:	63 50       	subi	r22, 0x03	; 3
    debe:	44 0f       	add	r20, r20
    dec0:	55 1f       	adc	r21, r21
    dec2:	44 0f       	add	r20, r20
    dec4:	55 1f       	adc	r21, r21
    dec6:	64 0f       	add	r22, r20
    dec8:	80 91 8d 02 	lds	r24, 0x028D
    decc:	42 e5       	ldi	r20, 0x52	; 82
    dece:	53 e1       	ldi	r21, 0x13	; 19
    ded0:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
					   sprintf_P(lcdteks,PSTR("%d"),IP_blok[iBlok]);
    ded4:	00 d0       	rcall	.+0      	; 0xded6 <FMenuSettingClientIP+0x3fc>
    ded6:	00 d0       	rcall	.+0      	; 0xded8 <FMenuSettingClientIP+0x3fe>
    ded8:	00 d0       	rcall	.+0      	; 0xdeda <FMenuSettingClientIP+0x400>
    deda:	ad b7       	in	r26, 0x3d	; 61
    dedc:	be b7       	in	r27, 0x3e	; 62
    dede:	11 96       	adiw	r26, 0x01	; 1
    dee0:	8e 01       	movw	r16, r28
    dee2:	0f 5f       	subi	r16, 0xFF	; 255
    dee4:	1f 4f       	sbci	r17, 0xFF	; 255
    dee6:	ed b7       	in	r30, 0x3d	; 61
    dee8:	fe b7       	in	r31, 0x3e	; 62
    deea:	12 83       	std	Z+2, r17	; 0x02
    deec:	01 83       	std	Z+1, r16	; 0x01
    deee:	8f e4       	ldi	r24, 0x4F	; 79
    def0:	93 e1       	ldi	r25, 0x13	; 19
    def2:	13 96       	adiw	r26, 0x03	; 3
    def4:	9c 93       	st	X, r25
    def6:	8e 93       	st	-X, r24
    def8:	12 97       	sbiw	r26, 0x02	; 2
    defa:	e0 91 84 02 	lds	r30, 0x0284
    defe:	f0 91 85 02 	lds	r31, 0x0285
    df02:	e8 57       	subi	r30, 0x78	; 120
    df04:	fd 4f       	sbci	r31, 0xFD	; 253
    df06:	80 81       	ld	r24, Z
    df08:	14 96       	adiw	r26, 0x04	; 4
    df0a:	8c 93       	st	X, r24
    df0c:	14 97       	sbiw	r26, 0x04	; 4
    df0e:	15 96       	adiw	r26, 0x05	; 5
    df10:	1c 92       	st	X, r1
    df12:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
                       lcd_print(y,1+((x+(iBlok*4))-strlen(lcdteks)),lcdteks);
    df16:	f8 01       	movw	r30, r16
    df18:	01 90       	ld	r0, Z+
    df1a:	00 20       	and	r0, r0
    df1c:	e9 f7       	brne	.-6      	; 0xdf18 <FMenuSettingClientIP+0x43e>
    df1e:	31 97       	sbiw	r30, 0x01	; 1
    df20:	e0 1b       	sub	r30, r16
    df22:	f1 0b       	sbc	r31, r17
    df24:	8d b7       	in	r24, 0x3d	; 61
    df26:	9e b7       	in	r25, 0x3e	; 62
    df28:	06 96       	adiw	r24, 0x06	; 6
    df2a:	0f b6       	in	r0, 0x3f	; 63
    df2c:	f8 94       	cli
    df2e:	9e bf       	out	0x3e, r25	; 62
    df30:	0f be       	out	0x3f, r0	; 63
    df32:	8d bf       	out	0x3d, r24	; 61
    df34:	60 91 8e 02 	lds	r22, 0x028E
    df38:	6f 5f       	subi	r22, 0xFF	; 255
    df3a:	80 91 84 02 	lds	r24, 0x0284
    df3e:	90 91 85 02 	lds	r25, 0x0285
    df42:	88 0f       	add	r24, r24
    df44:	99 1f       	adc	r25, r25
    df46:	88 0f       	add	r24, r24
    df48:	99 1f       	adc	r25, r25
    df4a:	68 0f       	add	r22, r24
    df4c:	6e 1b       	sub	r22, r30
    df4e:	80 91 8d 02 	lds	r24, 0x028D
    df52:	a8 01       	movw	r20, r16
    df54:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>

					   if (iBlok>0)lcd_printf(y,1+((x+((iBlok-1)*4))),PSTR("."));
    df58:	80 91 84 02 	lds	r24, 0x0284
    df5c:	90 91 85 02 	lds	r25, 0x0285
    df60:	00 97       	sbiw	r24, 0x00	; 0
    df62:	81 f0       	breq	.+32     	; 0xdf84 <FMenuSettingClientIP+0x4aa>
    df64:	60 91 8e 02 	lds	r22, 0x028E
    df68:	6f 5f       	subi	r22, 0xFF	; 255
    df6a:	81 50       	subi	r24, 0x01	; 1
    df6c:	90 4c       	sbci	r25, 0xC0	; 192
    df6e:	88 0f       	add	r24, r24
    df70:	99 1f       	adc	r25, r25
    df72:	88 0f       	add	r24, r24
    df74:	99 1f       	adc	r25, r25
    df76:	68 0f       	add	r22, r24
    df78:	80 91 8d 02 	lds	r24, 0x028D
    df7c:	4d e4       	ldi	r20, 0x4D	; 77
    df7e:	53 e1       	ldi	r21, 0x13	; 19
    df80:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
				       iInput=0;
    df84:	10 92 8c 02 	sts	0x028C, r1
					   iBlok++;	   
    df88:	80 91 84 02 	lds	r24, 0x0284
    df8c:	90 91 85 02 	lds	r25, 0x0285
    df90:	01 96       	adiw	r24, 0x01	; 1
    df92:	90 93 85 02 	sts	0x0285, r25
    df96:	80 93 84 02 	sts	0x0284, r24
				   }
				   if (iBlok>=4)stClientIP=cipStoreIPblok;
    df9a:	80 91 84 02 	lds	r24, 0x0284
    df9e:	90 91 85 02 	lds	r25, 0x0285
    dfa2:	04 97       	sbiw	r24, 0x04	; 4
    dfa4:	a8 f0       	brcs	.+42     	; 0xdfd0 <FMenuSettingClientIP+0x4f6>
    dfa6:	84 e0       	ldi	r24, 0x04	; 4
    dfa8:	0b c0       	rjmp	.+22     	; 0xdfc0 <FMenuSettingClientIP+0x4e6>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    dfaa:	88 e2       	ldi	r24, 0x28	; 40
    dfac:	90 e0       	ldi	r25, 0x00	; 0
    dfae:	68 e8       	ldi	r22, 0x88	; 136
    dfb0:	72 e0       	ldi	r23, 0x02	; 2
    dfb2:	44 e0       	ldi	r20, 0x04	; 4
    dfb4:	50 e0       	ldi	r21, 0x00	; 0
    dfb6:	25 e0       	ldi	r18, 0x05	; 5
    dfb8:	33 e1       	ldi	r19, 0x13	; 19
    dfba:	0e 94 0d b4 	call	0x1681a	; 0x1681a <__eewr_block>
			   }
		       break;
          case cipStoreIPblok://UpdateIPblok
			   eeprom_write_block((const void*) &IP_blok,(const void*) &DefClientIP,4);
			   stClientIP=cipExit;
    dfbe:	83 e0       	ldi	r24, 0x03	; 3
    dfc0:	80 93 49 01 	sts	0x0149, r24
    dfc4:	05 c0       	rjmp	.+10     	; 0xdfd0 <FMenuSettingClientIP+0x4f6>
		       break; 
          case cipExit://Cancel IPConfig
		       stClientIP=cipInit;
    dfc6:	81 e0       	ldi	r24, 0x01	; 1
    dfc8:	80 93 49 01 	sts	0x0149, r24
		       Result=MENU_DONE;
    dfcc:	80 93 8f 02 	sts	0x028F, r24
		       break;     
		  }//EndSwitch	 
    return Result;
}
    dfd0:	80 91 8f 02 	lds	r24, 0x028F
    dfd4:	64 96       	adiw	r28, 0x14	; 20
    dfd6:	0f b6       	in	r0, 0x3f	; 63
    dfd8:	f8 94       	cli
    dfda:	de bf       	out	0x3e, r29	; 62
    dfdc:	0f be       	out	0x3f, r0	; 63
    dfde:	cd bf       	out	0x3d, r28	; 61
    dfe0:	cf 91       	pop	r28
    dfe2:	df 91       	pop	r29
    dfe4:	1f 91       	pop	r17
    dfe6:	0f 91       	pop	r16
    dfe8:	ff 90       	pop	r15
    dfea:	08 95       	ret

0000dfec <DisplayStandaloneSequence>:
	 i++;
     _delay_ms(6500);
  return Result;
}

void DisplayStandaloneSequence(char x,char y, char PoolingSequence){
    dfec:	df 93       	push	r29
    dfee:	cf 93       	push	r28
    dff0:	cd b7       	in	r28, 0x3d	; 61
    dff2:	de b7       	in	r29, 0x3e	; 62
    dff4:	28 97       	sbiw	r28, 0x08	; 8
    dff6:	0f b6       	in	r0, 0x3f	; 63
    dff8:	f8 94       	cli
    dffa:	de bf       	out	0x3e, r29	; 62
    dffc:	0f be       	out	0x3f, r0	; 63
    dffe:	cd bf       	out	0x3d, r28	; 61
    e000:	58 2f       	mov	r21, r24
	 MapSequence[3]='/';
	 MapSequence[4]='-';
	 MapSequence[5]=164;//0x5C;
	 MapSequence[6]='|';
	 MapSequence[7]='/';
	 if (IsPoolingRestarted==False)lcd_put(x,y,MapSequence[(PoolingSequence%8)]);     
    e002:	80 91 86 01 	lds	r24, 0x0186
    e006:	88 23       	and	r24, r24
    e008:	a1 f4       	brne	.+40     	; 0xe032 <DisplayStandaloneSequence+0x46>

void DisplayStandaloneSequence(char x,char y, char PoolingSequence){
     char MapSequence[8];

     //sprintf_P(MapSequence,PSTR("-\|/-|/"));
	 MapSequence[0]='-';
    e00a:	3d e2       	ldi	r19, 0x2D	; 45
    e00c:	39 83       	std	Y+1, r19	; 0x01
	 MapSequence[1]='`';//0x5C;
    e00e:	80 e6       	ldi	r24, 0x60	; 96
    e010:	8a 83       	std	Y+2, r24	; 0x02
	 MapSequence[2]='|';
    e012:	2c e7       	ldi	r18, 0x7C	; 124
    e014:	2b 83       	std	Y+3, r18	; 0x03
	 MapSequence[3]='/';
    e016:	9f e2       	ldi	r25, 0x2F	; 47
    e018:	9c 83       	std	Y+4, r25	; 0x04
	 MapSequence[4]='-';
    e01a:	3d 83       	std	Y+5, r19	; 0x05
	 MapSequence[5]=164;//0x5C;
    e01c:	84 ea       	ldi	r24, 0xA4	; 164
    e01e:	8e 83       	std	Y+6, r24	; 0x06
	 MapSequence[6]='|';
    e020:	2f 83       	std	Y+7, r18	; 0x07
	 MapSequence[7]='/';
    e022:	98 87       	std	Y+8, r25	; 0x08
	 if (IsPoolingRestarted==False)lcd_put(x,y,MapSequence[(PoolingSequence%8)]);     
    e024:	47 70       	andi	r20, 0x07	; 7
    e026:	fe 01       	movw	r30, r28
    e028:	e4 0f       	add	r30, r20
    e02a:	f1 1d       	adc	r31, r1
    e02c:	85 2f       	mov	r24, r21
    e02e:	41 81       	ldd	r20, Z+1	; 0x01
    e030:	08 c0       	rjmp	.+16     	; 0xe042 <DisplayStandaloneSequence+0x56>
	 else if (IsPoolingRestarted==True){
    e032:	80 91 86 01 	lds	r24, 0x0186
    e036:	81 30       	cpi	r24, 0x01	; 1
    e038:	31 f4       	brne	.+12     	; 0xe046 <DisplayStandaloneSequence+0x5a>
	          IsPoolingRestarted=False;
    e03a:	10 92 86 01 	sts	0x0186, r1
	          lcd_put(x,y,'X');     
    e03e:	85 2f       	mov	r24, r21
    e040:	48 e5       	ldi	r20, 0x58	; 88
    e042:	0e 94 58 ad 	call	0x15ab0	; 0x15ab0 <lcd_put>
			  }

}
    e046:	28 96       	adiw	r28, 0x08	; 8
    e048:	0f b6       	in	r0, 0x3f	; 63
    e04a:	f8 94       	cli
    e04c:	de bf       	out	0x3e, r29	; 62
    e04e:	0f be       	out	0x3f, r0	; 63
    e050:	cd bf       	out	0x3d, r28	; 61
    e052:	cf 91       	pop	r28
    e054:	df 91       	pop	r29
    e056:	08 95       	ret

0000e058 <FSettingPumpPooling>:
	      break;
	 }
     return Result;
}

char FSettingPumpPooling(){//Parameter: PumpCount,
    e058:	0f 93       	push	r16
    e05a:	1f 93       	push	r17
    e05c:	df 93       	push	r29
    e05e:	cf 93       	push	r28
    e060:	cd b7       	in	r28, 0x3d	; 61
    e062:	de b7       	in	r29, 0x3e	; 62
    e064:	6a 97       	sbiw	r28, 0x1a	; 26
    e066:	0f b6       	in	r0, 0x3f	; 63
    e068:	f8 94       	cli
    e06a:	de bf       	out	0x3e, r29	; 62
    e06c:	0f be       	out	0x3f, r0	; 63
    e06e:	cd bf       	out	0x3d, r28	; 61
static char stPumpPooling=ppInitMenu;
	   char i,lcdteks[20];
	   char KeyChar,Addr=0,PPoolingSetting[6];
     
	 Result=MENU_NONE;
     switch(stPumpPooling){
    e070:	80 91 6c 02 	lds	r24, 0x026C
    e074:	82 30       	cpi	r24, 0x02	; 2
    e076:	09 f4       	brne	.+2      	; 0xe07a <FSettingPumpPooling+0x22>
    e078:	1b c1       	rjmp	.+566    	; 0xe2b0 <FSettingPumpPooling+0x258>
    e07a:	83 30       	cpi	r24, 0x03	; 3
    e07c:	30 f4       	brcc	.+12     	; 0xe08a <FSettingPumpPooling+0x32>
    e07e:	88 23       	and	r24, r24
    e080:	59 f0       	breq	.+22     	; 0xe098 <FSettingPumpPooling+0x40>
    e082:	81 30       	cpi	r24, 0x01	; 1
    e084:	09 f0       	breq	.+2      	; 0xe088 <FSettingPumpPooling+0x30>
    e086:	17 c2       	rjmp	.+1070   	; 0xe4b6 <FSettingPumpPooling+0x45e>
    e088:	09 c1       	rjmp	.+530    	; 0xe29c <FSettingPumpPooling+0x244>
    e08a:	83 30       	cpi	r24, 0x03	; 3
    e08c:	09 f4       	brne	.+2      	; 0xe090 <FSettingPumpPooling+0x38>
    e08e:	04 c2       	rjmp	.+1032   	; 0xe498 <FSettingPumpPooling+0x440>
    e090:	84 30       	cpi	r24, 0x04	; 4
    e092:	09 f0       	breq	.+2      	; 0xe096 <FSettingPumpPooling+0x3e>
    e094:	10 c2       	rjmp	.+1056   	; 0xe4b6 <FSettingPumpPooling+0x45e>
    e096:	0b c2       	rjmp	.+1046   	; 0xe4ae <FSettingPumpPooling+0x456>
	 case ppInitMenu:
          lcd_clear();
    e098:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
    e09c:	20 e0       	ldi	r18, 0x00	; 0
    e09e:	30 e0       	ldi	r19, 0x00	; 0
		  for (i=0;i<6;i++){
		      PPoolingSetting[i]=eeprom_read_byte(&DefPoolingPumpMax+i);
    e0a0:	ae 01       	movw	r20, r28
    e0a2:	4f 5f       	subi	r20, 0xFF	; 255
    e0a4:	5f 4f       	sbci	r21, 0xFF	; 255
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    e0a6:	e1 99       	sbic	0x1c, 1	; 28
    e0a8:	fe cf       	rjmp	.-4      	; 0xe0a6 <FSettingPumpPooling+0x4e>
    e0aa:	c9 01       	movw	r24, r18
    e0ac:	8c 5b       	subi	r24, 0xBC	; 188
    e0ae:	9e 4f       	sbci	r25, 0xFE	; 254
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    e0b0:	9f bb       	out	0x1f, r25	; 31
    e0b2:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    e0b4:	e0 9a       	sbi	0x1c, 0	; 28
    e0b6:	8d b3       	in	r24, 0x1d	; 29
    e0b8:	fa 01       	movw	r30, r20
    e0ba:	e2 0f       	add	r30, r18
    e0bc:	f3 1f       	adc	r31, r19
    e0be:	80 83       	st	Z, r24
    e0c0:	2f 5f       	subi	r18, 0xFF	; 255
    e0c2:	3f 4f       	sbci	r19, 0xFF	; 255
     
	 Result=MENU_NONE;
     switch(stPumpPooling){
	 case ppInitMenu:
          lcd_clear();
		  for (i=0;i<6;i++){
    e0c4:	26 30       	cpi	r18, 0x06	; 6
    e0c6:	31 05       	cpc	r19, r1
    e0c8:	71 f7       	brne	.-36     	; 0xe0a6 <FSettingPumpPooling+0x4e>
		      PPoolingSetting[i]=eeprom_read_byte(&DefPoolingPumpMax+i);
		  }

		  sprintf_P(lcdteks,PSTR("1.MaxPump:%d"),PPoolingSetting[0]);lcd_print(1,1,lcdteks);
    e0ca:	00 d0       	rcall	.+0      	; 0xe0cc <FSettingPumpPooling+0x74>
    e0cc:	00 d0       	rcall	.+0      	; 0xe0ce <FSettingPumpPooling+0x76>
    e0ce:	00 d0       	rcall	.+0      	; 0xe0d0 <FSettingPumpPooling+0x78>
    e0d0:	ed b7       	in	r30, 0x3d	; 61
    e0d2:	fe b7       	in	r31, 0x3e	; 62
    e0d4:	31 96       	adiw	r30, 0x01	; 1
    e0d6:	8e 01       	movw	r16, r28
    e0d8:	09 5f       	subi	r16, 0xF9	; 249
    e0da:	1f 4f       	sbci	r17, 0xFF	; 255
    e0dc:	ad b7       	in	r26, 0x3d	; 61
    e0de:	be b7       	in	r27, 0x3e	; 62
    e0e0:	12 96       	adiw	r26, 0x02	; 2
    e0e2:	1c 93       	st	X, r17
    e0e4:	0e 93       	st	-X, r16
    e0e6:	11 97       	sbiw	r26, 0x01	; 1
    e0e8:	8a ec       	ldi	r24, 0xCA	; 202
    e0ea:	9d e0       	ldi	r25, 0x0D	; 13
    e0ec:	93 83       	std	Z+3, r25	; 0x03
    e0ee:	82 83       	std	Z+2, r24	; 0x02
    e0f0:	89 81       	ldd	r24, Y+1	; 0x01
    e0f2:	84 83       	std	Z+4, r24	; 0x04
    e0f4:	15 82       	std	Z+5, r1	; 0x05
    e0f6:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    e0fa:	ed b7       	in	r30, 0x3d	; 61
    e0fc:	fe b7       	in	r31, 0x3e	; 62
    e0fe:	36 96       	adiw	r30, 0x06	; 6
    e100:	0f b6       	in	r0, 0x3f	; 63
    e102:	f8 94       	cli
    e104:	fe bf       	out	0x3e, r31	; 62
    e106:	0f be       	out	0x3f, r0	; 63
    e108:	ed bf       	out	0x3d, r30	; 61
    e10a:	81 e0       	ldi	r24, 0x01	; 1
    e10c:	61 e0       	ldi	r22, 0x01	; 1
    e10e:	a8 01       	movw	r20, r16
    e110:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
          sprintf_P(lcdteks,PSTR("2.nNoPump:%d"),PPoolingSetting[1]);lcd_print(2,1,lcdteks);
    e114:	00 d0       	rcall	.+0      	; 0xe116 <FSettingPumpPooling+0xbe>
    e116:	00 d0       	rcall	.+0      	; 0xe118 <FSettingPumpPooling+0xc0>
    e118:	00 d0       	rcall	.+0      	; 0xe11a <FSettingPumpPooling+0xc2>
    e11a:	ed b7       	in	r30, 0x3d	; 61
    e11c:	fe b7       	in	r31, 0x3e	; 62
    e11e:	31 96       	adiw	r30, 0x01	; 1
    e120:	ad b7       	in	r26, 0x3d	; 61
    e122:	be b7       	in	r27, 0x3e	; 62
    e124:	12 96       	adiw	r26, 0x02	; 2
    e126:	1c 93       	st	X, r17
    e128:	0e 93       	st	-X, r16
    e12a:	11 97       	sbiw	r26, 0x01	; 1
    e12c:	8d eb       	ldi	r24, 0xBD	; 189
    e12e:	9d e0       	ldi	r25, 0x0D	; 13
    e130:	93 83       	std	Z+3, r25	; 0x03
    e132:	82 83       	std	Z+2, r24	; 0x02
    e134:	8a 81       	ldd	r24, Y+2	; 0x02
    e136:	84 83       	std	Z+4, r24	; 0x04
    e138:	15 82       	std	Z+5, r1	; 0x05
    e13a:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    e13e:	ed b7       	in	r30, 0x3d	; 61
    e140:	fe b7       	in	r31, 0x3e	; 62
    e142:	36 96       	adiw	r30, 0x06	; 6
    e144:	0f b6       	in	r0, 0x3f	; 63
    e146:	f8 94       	cli
    e148:	fe bf       	out	0x3e, r31	; 62
    e14a:	0f be       	out	0x3f, r0	; 63
    e14c:	ed bf       	out	0x3d, r30	; 61
    e14e:	82 e0       	ldi	r24, 0x02	; 2
    e150:	61 e0       	ldi	r22, 0x01	; 1
    e152:	a8 01       	movw	r20, r16
    e154:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
          sprintf_P(lcdteks,PSTR("3.TrySend:%d"),PPoolingSetting[2]);lcd_print(3,1,lcdteks);
    e158:	00 d0       	rcall	.+0      	; 0xe15a <FSettingPumpPooling+0x102>
    e15a:	00 d0       	rcall	.+0      	; 0xe15c <FSettingPumpPooling+0x104>
    e15c:	00 d0       	rcall	.+0      	; 0xe15e <FSettingPumpPooling+0x106>
    e15e:	ed b7       	in	r30, 0x3d	; 61
    e160:	fe b7       	in	r31, 0x3e	; 62
    e162:	31 96       	adiw	r30, 0x01	; 1
    e164:	ad b7       	in	r26, 0x3d	; 61
    e166:	be b7       	in	r27, 0x3e	; 62
    e168:	12 96       	adiw	r26, 0x02	; 2
    e16a:	1c 93       	st	X, r17
    e16c:	0e 93       	st	-X, r16
    e16e:	11 97       	sbiw	r26, 0x01	; 1
    e170:	80 eb       	ldi	r24, 0xB0	; 176
    e172:	9d e0       	ldi	r25, 0x0D	; 13
    e174:	93 83       	std	Z+3, r25	; 0x03
    e176:	82 83       	std	Z+2, r24	; 0x02
    e178:	8b 81       	ldd	r24, Y+3	; 0x03
    e17a:	84 83       	std	Z+4, r24	; 0x04
    e17c:	15 82       	std	Z+5, r1	; 0x05
    e17e:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    e182:	ed b7       	in	r30, 0x3d	; 61
    e184:	fe b7       	in	r31, 0x3e	; 62
    e186:	36 96       	adiw	r30, 0x06	; 6
    e188:	0f b6       	in	r0, 0x3f	; 63
    e18a:	f8 94       	cli
    e18c:	fe bf       	out	0x3e, r31	; 62
    e18e:	0f be       	out	0x3f, r0	; 63
    e190:	ed bf       	out	0x3d, r30	; 61
    e192:	83 e0       	ldi	r24, 0x03	; 3
    e194:	61 e0       	ldi	r22, 0x01	; 1
    e196:	a8 01       	movw	r20, r16
    e198:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
          sprintf_P(lcdteks,PSTR("4.TimPool:%d"),PPoolingSetting[3]);lcd_print(4,1,lcdteks);
    e19c:	00 d0       	rcall	.+0      	; 0xe19e <FSettingPumpPooling+0x146>
    e19e:	00 d0       	rcall	.+0      	; 0xe1a0 <FSettingPumpPooling+0x148>
    e1a0:	00 d0       	rcall	.+0      	; 0xe1a2 <FSettingPumpPooling+0x14a>
    e1a2:	ed b7       	in	r30, 0x3d	; 61
    e1a4:	fe b7       	in	r31, 0x3e	; 62
    e1a6:	31 96       	adiw	r30, 0x01	; 1
    e1a8:	ad b7       	in	r26, 0x3d	; 61
    e1aa:	be b7       	in	r27, 0x3e	; 62
    e1ac:	12 96       	adiw	r26, 0x02	; 2
    e1ae:	1c 93       	st	X, r17
    e1b0:	0e 93       	st	-X, r16
    e1b2:	11 97       	sbiw	r26, 0x01	; 1
    e1b4:	83 ea       	ldi	r24, 0xA3	; 163
    e1b6:	9d e0       	ldi	r25, 0x0D	; 13
    e1b8:	93 83       	std	Z+3, r25	; 0x03
    e1ba:	82 83       	std	Z+2, r24	; 0x02
    e1bc:	8c 81       	ldd	r24, Y+4	; 0x04
    e1be:	84 83       	std	Z+4, r24	; 0x04
    e1c0:	15 82       	std	Z+5, r1	; 0x05
    e1c2:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    e1c6:	ed b7       	in	r30, 0x3d	; 61
    e1c8:	fe b7       	in	r31, 0x3e	; 62
    e1ca:	36 96       	adiw	r30, 0x06	; 6
    e1cc:	0f b6       	in	r0, 0x3f	; 63
    e1ce:	f8 94       	cli
    e1d0:	fe bf       	out	0x3e, r31	; 62
    e1d2:	0f be       	out	0x3f, r0	; 63
    e1d4:	ed bf       	out	0x3d, r30	; 61
    e1d6:	84 e0       	ldi	r24, 0x04	; 4
    e1d8:	61 e0       	ldi	r22, 0x01	; 1
    e1da:	a8 01       	movw	r20, r16
    e1dc:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
          sprintf_P(lcdteks,PSTR("5.Dly:%d"),PPoolingSetting[4]);lcd_print(1,13,lcdteks);
    e1e0:	00 d0       	rcall	.+0      	; 0xe1e2 <FSettingPumpPooling+0x18a>
    e1e2:	00 d0       	rcall	.+0      	; 0xe1e4 <FSettingPumpPooling+0x18c>
    e1e4:	00 d0       	rcall	.+0      	; 0xe1e6 <FSettingPumpPooling+0x18e>
    e1e6:	ed b7       	in	r30, 0x3d	; 61
    e1e8:	fe b7       	in	r31, 0x3e	; 62
    e1ea:	31 96       	adiw	r30, 0x01	; 1
    e1ec:	ad b7       	in	r26, 0x3d	; 61
    e1ee:	be b7       	in	r27, 0x3e	; 62
    e1f0:	12 96       	adiw	r26, 0x02	; 2
    e1f2:	1c 93       	st	X, r17
    e1f4:	0e 93       	st	-X, r16
    e1f6:	11 97       	sbiw	r26, 0x01	; 1
    e1f8:	8a e9       	ldi	r24, 0x9A	; 154
    e1fa:	9d e0       	ldi	r25, 0x0D	; 13
    e1fc:	93 83       	std	Z+3, r25	; 0x03
    e1fe:	82 83       	std	Z+2, r24	; 0x02
    e200:	8d 81       	ldd	r24, Y+5	; 0x05
    e202:	84 83       	std	Z+4, r24	; 0x04
    e204:	15 82       	std	Z+5, r1	; 0x05
    e206:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    e20a:	ed b7       	in	r30, 0x3d	; 61
    e20c:	fe b7       	in	r31, 0x3e	; 62
    e20e:	36 96       	adiw	r30, 0x06	; 6
    e210:	0f b6       	in	r0, 0x3f	; 63
    e212:	f8 94       	cli
    e214:	fe bf       	out	0x3e, r31	; 62
    e216:	0f be       	out	0x3f, r0	; 63
    e218:	ed bf       	out	0x3d, r30	; 61
    e21a:	81 e0       	ldi	r24, 0x01	; 1
    e21c:	6d e0       	ldi	r22, 0x0D	; 13
    e21e:	a8 01       	movw	r20, r16
    e220:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
          sprintf_P(lcdteks,PSTR("6.Act:%d"),PPoolingSetting[5]);lcd_print(2,13,lcdteks);
    e224:	00 d0       	rcall	.+0      	; 0xe226 <FSettingPumpPooling+0x1ce>
    e226:	00 d0       	rcall	.+0      	; 0xe228 <FSettingPumpPooling+0x1d0>
    e228:	00 d0       	rcall	.+0      	; 0xe22a <FSettingPumpPooling+0x1d2>
    e22a:	ed b7       	in	r30, 0x3d	; 61
    e22c:	fe b7       	in	r31, 0x3e	; 62
    e22e:	31 96       	adiw	r30, 0x01	; 1
    e230:	ad b7       	in	r26, 0x3d	; 61
    e232:	be b7       	in	r27, 0x3e	; 62
    e234:	12 96       	adiw	r26, 0x02	; 2
    e236:	1c 93       	st	X, r17
    e238:	0e 93       	st	-X, r16
    e23a:	11 97       	sbiw	r26, 0x01	; 1
    e23c:	81 e9       	ldi	r24, 0x91	; 145
    e23e:	9d e0       	ldi	r25, 0x0D	; 13
    e240:	93 83       	std	Z+3, r25	; 0x03
    e242:	82 83       	std	Z+2, r24	; 0x02
    e244:	8e 81       	ldd	r24, Y+6	; 0x06
    e246:	84 83       	std	Z+4, r24	; 0x04
    e248:	15 82       	std	Z+5, r1	; 0x05
    e24a:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    e24e:	ed b7       	in	r30, 0x3d	; 61
    e250:	fe b7       	in	r31, 0x3e	; 62
    e252:	36 96       	adiw	r30, 0x06	; 6
    e254:	0f b6       	in	r0, 0x3f	; 63
    e256:	f8 94       	cli
    e258:	fe bf       	out	0x3e, r31	; 62
    e25a:	0f be       	out	0x3f, r0	; 63
    e25c:	ed bf       	out	0x3d, r30	; 61
    e25e:	82 e0       	ldi	r24, 0x02	; 2
    e260:	6d e0       	ldi	r22, 0x0D	; 13
    e262:	a8 01       	movw	r20, r16
    e264:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
          sprintf_P(lcdteks,PSTR("[*]Exit"));lcd_print(4,13,lcdteks);
    e268:	00 d0       	rcall	.+0      	; 0xe26a <FSettingPumpPooling+0x212>
    e26a:	00 d0       	rcall	.+0      	; 0xe26c <FSettingPumpPooling+0x214>
    e26c:	ad b7       	in	r26, 0x3d	; 61
    e26e:	be b7       	in	r27, 0x3e	; 62
    e270:	12 96       	adiw	r26, 0x02	; 2
    e272:	1c 93       	st	X, r17
    e274:	0e 93       	st	-X, r16
    e276:	11 97       	sbiw	r26, 0x01	; 1
    e278:	89 e8       	ldi	r24, 0x89	; 137
    e27a:	9d e0       	ldi	r25, 0x0D	; 13
    e27c:	14 96       	adiw	r26, 0x04	; 4
    e27e:	9c 93       	st	X, r25
    e280:	8e 93       	st	-X, r24
    e282:	13 97       	sbiw	r26, 0x03	; 3
    e284:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    e288:	0f 90       	pop	r0
    e28a:	0f 90       	pop	r0
    e28c:	0f 90       	pop	r0
    e28e:	0f 90       	pop	r0
    e290:	84 e0       	ldi	r24, 0x04	; 4
    e292:	6d e0       	ldi	r22, 0x0D	; 13
    e294:	a8 01       	movw	r20, r16
    e296:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
    e29a:	08 c0       	rjmp	.+16     	; 0xe2ac <FSettingPumpPooling+0x254>

          stPumpPooling=ppPoolingSettingInput;
	      break;
     case ppDisplaySequence:
          IsNewPoolingSequence=False;
    e29c:	10 92 84 01 	sts	0x0184, r1
		  DisplayStandaloneSequence(3,14,iSequencePooling);
    e2a0:	83 e0       	ldi	r24, 0x03	; 3
    e2a2:	6e e0       	ldi	r22, 0x0E	; 14
    e2a4:	40 91 83 01 	lds	r20, 0x0183
    e2a8:	0e 94 f6 6f 	call	0xdfec	; 0xdfec <DisplayStandaloneSequence>
          stPumpPooling=ppPoolingSettingInput;
    e2ac:	82 e0       	ldi	r24, 0x02	; 2
    e2ae:	f1 c0       	rjmp	.+482    	; 0xe492 <FSettingPumpPooling+0x43a>
	      break;
     case ppPoolingSettingInput:
	      if(IsNewPoolingSequence==True)stPumpPooling=ppDisplaySequence;
    e2b0:	80 91 84 01 	lds	r24, 0x0184
    e2b4:	81 30       	cpi	r24, 0x01	; 1
    e2b6:	11 f4       	brne	.+4      	; 0xe2bc <FSettingPumpPooling+0x264>
    e2b8:	80 93 6c 02 	sts	0x026C, r24

          KeyChar=_key_btn(_key_scan(1));
    e2bc:	81 e0       	ldi	r24, 0x01	; 1
    e2be:	0e 94 84 ae 	call	0x15d08	; 0x15d08 <_key_scan>
    e2c2:	0e 94 e5 ad 	call	0x15bca	; 0x15bca <_key_btn>
		  if ((KeyChar>='1')&&(KeyChar<='6')){
    e2c6:	48 2f       	mov	r20, r24
    e2c8:	41 53       	subi	r20, 0x31	; 49
    e2ca:	46 30       	cpi	r20, 0x06	; 6
    e2cc:	10 f0       	brcs	.+4      	; 0xe2d2 <FSettingPumpPooling+0x27a>
    e2ce:	40 e0       	ldi	r20, 0x00	; 0
    e2d0:	04 c0       	rjmp	.+8      	; 0xe2da <FSettingPumpPooling+0x282>
		      Addr=KeyChar-'1';
			  TimSend=0;
    e2d2:	10 92 af 0d 	sts	0x0DAF, r1
			  IsStandaloneAcknoledge=False;
    e2d6:	10 92 85 01 	sts	0x0185, r1
          }
		  switch(KeyChar){
    e2da:	83 33       	cpi	r24, 0x33	; 51
    e2dc:	09 f4       	brne	.+2      	; 0xe2e0 <FSettingPumpPooling+0x288>
    e2de:	67 c0       	rjmp	.+206    	; 0xe3ae <FSettingPumpPooling+0x356>
    e2e0:	84 33       	cpi	r24, 0x34	; 52
    e2e2:	48 f4       	brcc	.+18     	; 0xe2f6 <FSettingPumpPooling+0x29e>
    e2e4:	81 33       	cpi	r24, 0x31	; 49
    e2e6:	89 f0       	breq	.+34     	; 0xe30a <FSettingPumpPooling+0x2b2>
    e2e8:	82 33       	cpi	r24, 0x32	; 50
    e2ea:	08 f0       	brcs	.+2      	; 0xe2ee <FSettingPumpPooling+0x296>
    e2ec:	3d c0       	rjmp	.+122    	; 0xe368 <FSettingPumpPooling+0x310>
    e2ee:	8a 32       	cpi	r24, 0x2A	; 42
    e2f0:	09 f0       	breq	.+2      	; 0xe2f4 <FSettingPumpPooling+0x29c>
    e2f2:	e1 c0       	rjmp	.+450    	; 0xe4b6 <FSettingPumpPooling+0x45e>
    e2f4:	cd c0       	rjmp	.+410    	; 0xe490 <FSettingPumpPooling+0x438>
    e2f6:	85 33       	cpi	r24, 0x35	; 53
    e2f8:	09 f4       	brne	.+2      	; 0xe2fc <FSettingPumpPooling+0x2a4>
    e2fa:	91 c0       	rjmp	.+290    	; 0xe41e <FSettingPumpPooling+0x3c6>
    e2fc:	85 33       	cpi	r24, 0x35	; 53
    e2fe:	08 f4       	brcc	.+2      	; 0xe302 <FSettingPumpPooling+0x2aa>
    e300:	78 c0       	rjmp	.+240    	; 0xe3f2 <FSettingPumpPooling+0x39a>
    e302:	86 33       	cpi	r24, 0x36	; 54
    e304:	09 f0       	breq	.+2      	; 0xe308 <FSettingPumpPooling+0x2b0>
    e306:	d7 c0       	rjmp	.+430    	; 0xe4b6 <FSettingPumpPooling+0x45e>
    e308:	a0 c0       	rjmp	.+320    	; 0xe44a <FSettingPumpPooling+0x3f2>
		  case '1'://MaxPump
		       PPoolingSetting[Addr]=((PPoolingSetting[Addr]+1)%17);
    e30a:	24 2f       	mov	r18, r20
    e30c:	30 e0       	ldi	r19, 0x00	; 0
    e30e:	fe 01       	movw	r30, r28
    e310:	31 96       	adiw	r30, 0x01	; 1
    e312:	e2 0f       	add	r30, r18
    e314:	f3 1f       	adc	r31, r19
    e316:	80 81       	ld	r24, Z
    e318:	90 e0       	ldi	r25, 0x00	; 0
    e31a:	01 96       	adiw	r24, 0x01	; 1
    e31c:	61 e1       	ldi	r22, 0x11	; 17
    e31e:	70 e0       	ldi	r23, 0x00	; 0
    e320:	0e 94 1e b7 	call	0x16e3c	; 0x16e3c <__divmodhi4>
    e324:	80 83       	st	Z, r24
			   if (PPoolingSetting[Addr]==0)PPoolingSetting[Addr]=1;
    e326:	88 23       	and	r24, r24
    e328:	11 f4       	brne	.+4      	; 0xe32e <FSettingPumpPooling+0x2d6>
    e32a:	81 e0       	ldi	r24, 0x01	; 1
    e32c:	80 83       	st	Z, r24
			   //SendSlaveCommand(SC_SET_POOLING_MAX_PUMP,PPoolingSetting[Addr]);
			   SendPoolingCommand(SC_SET_POOLING_MAX_PUMP,PPoolingSetting[Addr]);
    e32e:	2c 0f       	add	r18, r28
    e330:	3d 1f       	adc	r19, r29
    e332:	f9 01       	movw	r30, r18
    e334:	21 81       	ldd	r18, Z+1	; 0x01
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    e336:	85 e1       	ldi	r24, 0x15	; 21
    e338:	80 93 b9 06 	sts	0x06B9, r24
	 PoolMsg=plMsg;
    e33c:	20 93 0a 0d 	sts	0x0D0A, r18
     IsControlPooling=True;
    e340:	81 e0       	ldi	r24, 0x01	; 1
    e342:	80 93 87 01 	sts	0x0187, r24
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    e346:	e1 99       	sbic	0x1c, 1	; 28
    e348:	fe cf       	rjmp	.-4      	; 0xe346 <FSettingPumpPooling+0x2ee>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    e34a:	84 2f       	mov	r24, r20
    e34c:	90 e0       	ldi	r25, 0x00	; 0
    e34e:	8c 5b       	subi	r24, 0xBC	; 188
    e350:	9e 4f       	sbci	r25, 0xFE	; 254
    e352:	9f bb       	out	0x1f, r25	; 31
    e354:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    e356:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
    e358:	0f b6       	in	r0, 0x3f	; 63
    e35a:	f8 94       	cli
    e35c:	e2 9a       	sbi	0x1c, 2	; 28
    e35e:	e1 9a       	sbi	0x1c, 1	; 28
    e360:	0f be       	out	0x3f, r0	; 63
			   if (PPoolingSetting[Addr]==0)PPoolingSetting[Addr]=1;
			   //SendSlaveCommand(SC_SET_POOLING_MAX_PUMP,PPoolingSetting[Addr]);
			   SendPoolingCommand(SC_SET_POOLING_MAX_PUMP,PPoolingSetting[Addr]);

			   eeprom_write_byte(&DefPoolingPumpMax+Addr,PPoolingSetting[Addr]);
			   PumpCountMax=PPoolingSetting[Addr];
    e362:	20 93 4f 01 	sts	0x014F, r18
    e366:	21 c0       	rjmp	.+66     	; 0xe3aa <FSettingPumpPooling+0x352>
			   //stPumpPooling=ppInitMenu;
			   stPumpPooling=ppWaitPoolingRespond;
		       break;
		  case '2'://NoPump
		       PPoolingSetting[Addr]=((PPoolingSetting[Addr]+1)%21);
    e368:	fe 01       	movw	r30, r28
    e36a:	e4 0f       	add	r30, r20
    e36c:	f1 1d       	adc	r31, r1
    e36e:	81 81       	ldd	r24, Z+1	; 0x01
    e370:	90 e0       	ldi	r25, 0x00	; 0
    e372:	01 96       	adiw	r24, 0x01	; 1
    e374:	65 e1       	ldi	r22, 0x15	; 21
    e376:	70 e0       	ldi	r23, 0x00	; 0
    e378:	0e 94 1e b7 	call	0x16e3c	; 0x16e3c <__divmodhi4>
    e37c:	28 2f       	mov	r18, r24
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    e37e:	84 e1       	ldi	r24, 0x14	; 20
    e380:	80 93 b9 06 	sts	0x06B9, r24
	 PoolMsg=plMsg;
    e384:	20 93 0a 0d 	sts	0x0D0A, r18
     IsControlPooling=True;
    e388:	81 e0       	ldi	r24, 0x01	; 1
    e38a:	80 93 87 01 	sts	0x0187, r24
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    e38e:	e1 99       	sbic	0x1c, 1	; 28
    e390:	fe cf       	rjmp	.-4      	; 0xe38e <FSettingPumpPooling+0x336>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    e392:	84 2f       	mov	r24, r20
    e394:	90 e0       	ldi	r25, 0x00	; 0
    e396:	8c 5b       	subi	r24, 0xBC	; 188
    e398:	9e 4f       	sbci	r25, 0xFE	; 254
    e39a:	9f bb       	out	0x1f, r25	; 31
    e39c:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    e39e:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
    e3a0:	0f b6       	in	r0, 0x3f	; 63
    e3a2:	f8 94       	cli
    e3a4:	e2 9a       	sbi	0x1c, 2	; 28
    e3a6:	e1 9a       	sbi	0x1c, 1	; 28
    e3a8:	0f be       	out	0x3f, r0	; 63
			   //SendSlaveCommand(SC_SET_POOLING_NO_PUMP_COUNT,PPoolingSetting[Addr]);
			   SendPoolingCommand(SC_SET_POOLING_NO_PUMP_COUNT,PPoolingSetting[Addr]);

			   eeprom_write_byte(&DefPoolingPumpMax+Addr,PPoolingSetting[Addr]);
			   //stPumpPooling=ppInitMenu;
			   stPumpPooling=ppWaitPoolingRespond;
    e3aa:	83 e0       	ldi	r24, 0x03	; 3
    e3ac:	72 c0       	rjmp	.+228    	; 0xe492 <FSettingPumpPooling+0x43a>
		       break;
		  case '3'://TrySend
		       PPoolingSetting[Addr]=((PPoolingSetting[Addr]+1)%21);
    e3ae:	24 2f       	mov	r18, r20
    e3b0:	30 e0       	ldi	r19, 0x00	; 0
    e3b2:	fe 01       	movw	r30, r28
    e3b4:	31 96       	adiw	r30, 0x01	; 1
    e3b6:	e2 0f       	add	r30, r18
    e3b8:	f3 1f       	adc	r31, r19
    e3ba:	80 81       	ld	r24, Z
    e3bc:	90 e0       	ldi	r25, 0x00	; 0
    e3be:	01 96       	adiw	r24, 0x01	; 1
    e3c0:	65 e1       	ldi	r22, 0x15	; 21
    e3c2:	70 e0       	ldi	r23, 0x00	; 0
    e3c4:	0e 94 1e b7 	call	0x16e3c	; 0x16e3c <__divmodhi4>
    e3c8:	80 83       	st	Z, r24
			   if (PPoolingSetting[Addr]==0)PPoolingSetting[Addr]=1;
    e3ca:	88 23       	and	r24, r24
    e3cc:	11 f4       	brne	.+4      	; 0xe3d2 <FSettingPumpPooling+0x37a>
    e3ce:	81 e0       	ldi	r24, 0x01	; 1
    e3d0:	80 83       	st	Z, r24
			   //SendSlaveCommand(SC_SET_POOLING_SEND,PPoolingSetting[Addr]);
			   SendPoolingCommand(SC_SET_POOLING_SEND,PPoolingSetting[Addr]);
    e3d2:	2c 0f       	add	r18, r28
    e3d4:	3d 1f       	adc	r19, r29
    e3d6:	d9 01       	movw	r26, r18
    e3d8:	11 96       	adiw	r26, 0x01	; 1
    e3da:	2c 91       	ld	r18, X
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    e3dc:	86 e1       	ldi	r24, 0x16	; 22
    e3de:	80 93 b9 06 	sts	0x06B9, r24
	 PoolMsg=plMsg;
    e3e2:	20 93 0a 0d 	sts	0x0D0A, r18
     IsControlPooling=True;
    e3e6:	81 e0       	ldi	r24, 0x01	; 1
    e3e8:	80 93 87 01 	sts	0x0187, r24
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    e3ec:	e1 99       	sbic	0x1c, 1	; 28
    e3ee:	fe cf       	rjmp	.-4      	; 0xe3ec <FSettingPumpPooling+0x394>
    e3f0:	d0 cf       	rjmp	.-96     	; 0xe392 <FSettingPumpPooling+0x33a>
			   eeprom_write_byte(&DefPoolingPumpMax+Addr,PPoolingSetting[Addr]);
			   //stPumpPooling=ppInitMenu;
			   stPumpPooling=ppWaitPoolingRespond;
		       break;
		  case '4'://TimPool
		       PPoolingSetting[Addr]=((PPoolingSetting[Addr]+1)%21);
    e3f2:	fe 01       	movw	r30, r28
    e3f4:	e4 0f       	add	r30, r20
    e3f6:	f1 1d       	adc	r31, r1
    e3f8:	81 81       	ldd	r24, Z+1	; 0x01
    e3fa:	90 e0       	ldi	r25, 0x00	; 0
    e3fc:	01 96       	adiw	r24, 0x01	; 1
    e3fe:	65 e1       	ldi	r22, 0x15	; 21
    e400:	70 e0       	ldi	r23, 0x00	; 0
    e402:	0e 94 1e b7 	call	0x16e3c	; 0x16e3c <__divmodhi4>
    e406:	28 2f       	mov	r18, r24
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    e408:	87 e1       	ldi	r24, 0x17	; 23
    e40a:	80 93 b9 06 	sts	0x06B9, r24
	 PoolMsg=plMsg;
    e40e:	20 93 0a 0d 	sts	0x0D0A, r18
     IsControlPooling=True;
    e412:	81 e0       	ldi	r24, 0x01	; 1
    e414:	80 93 87 01 	sts	0x0187, r24
    e418:	e1 99       	sbic	0x1c, 1	; 28
    e41a:	fe cf       	rjmp	.-4      	; 0xe418 <FSettingPumpPooling+0x3c0>
    e41c:	ba cf       	rjmp	.-140    	; 0xe392 <FSettingPumpPooling+0x33a>
			   eeprom_write_byte(&DefPoolingPumpMax+Addr,PPoolingSetting[Addr]);
			   //stPumpPooling=ppInitMenu;
			   stPumpPooling=ppWaitPoolingRespond;
		       break;
		  case '5'://DelayNextPump
		       PPoolingSetting[Addr]=((PPoolingSetting[Addr]+1)%41); 
    e41e:	fe 01       	movw	r30, r28
    e420:	e4 0f       	add	r30, r20
    e422:	f1 1d       	adc	r31, r1
    e424:	81 81       	ldd	r24, Z+1	; 0x01
    e426:	90 e0       	ldi	r25, 0x00	; 0
    e428:	01 96       	adiw	r24, 0x01	; 1
    e42a:	69 e2       	ldi	r22, 0x29	; 41
    e42c:	70 e0       	ldi	r23, 0x00	; 0
    e42e:	0e 94 1e b7 	call	0x16e3c	; 0x16e3c <__divmodhi4>
    e432:	28 2f       	mov	r18, r24
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    e434:	88 e1       	ldi	r24, 0x18	; 24
    e436:	80 93 b9 06 	sts	0x06B9, r24
	 PoolMsg=plMsg;
    e43a:	20 93 0a 0d 	sts	0x0D0A, r18
     IsControlPooling=True;
    e43e:	81 e0       	ldi	r24, 0x01	; 1
    e440:	80 93 87 01 	sts	0x0187, r24
    e444:	e1 99       	sbic	0x1c, 1	; 28
    e446:	fe cf       	rjmp	.-4      	; 0xe444 <FSettingPumpPooling+0x3ec>
    e448:	a4 cf       	rjmp	.-184    	; 0xe392 <FSettingPumpPooling+0x33a>
			   eeprom_write_byte(&DefPoolingPumpMax+Addr,PPoolingSetting[Addr]);
			   //stPumpPooling=ppInitMenu;
               stPumpPooling=ppWaitPoolingRespond;
		       break;
		  case '6'://ActivePump
		       PPoolingSetting[Addr]=((PPoolingSetting[Addr]+1)%(1+eeprom_read_byte(&DefPoolingPumpMax))); 			       
    e44a:	fe 01       	movw	r30, r28
    e44c:	e4 0f       	add	r30, r20
    e44e:	f1 1d       	adc	r31, r1
    e450:	21 81       	ldd	r18, Z+1	; 0x01
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    e452:	e1 99       	sbic	0x1c, 1	; 28
    e454:	fe cf       	rjmp	.-4      	; 0xe452 <FSettingPumpPooling+0x3fa>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    e456:	84 e4       	ldi	r24, 0x44	; 68
    e458:	91 e0       	ldi	r25, 0x01	; 1
    e45a:	9f bb       	out	0x1f, r25	; 31
    e45c:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    e45e:	e0 9a       	sbi	0x1c, 0	; 28
    e460:	6d b3       	in	r22, 0x1d	; 29
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    e462:	e1 99       	sbic	0x1c, 1	; 28
    e464:	fe cf       	rjmp	.-4      	; 0xe462 <FSettingPumpPooling+0x40a>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    e466:	84 2f       	mov	r24, r20
    e468:	90 e0       	ldi	r25, 0x00	; 0
    e46a:	8c 5b       	subi	r24, 0xBC	; 188
    e46c:	9e 4f       	sbci	r25, 0xFE	; 254
    e46e:	9f bb       	out	0x1f, r25	; 31
    e470:	8e bb       	out	0x1e, r24	; 30
    e472:	82 2f       	mov	r24, r18
    e474:	90 e0       	ldi	r25, 0x00	; 0
    e476:	70 e0       	ldi	r23, 0x00	; 0
    e478:	6f 5f       	subi	r22, 0xFF	; 255
    e47a:	7f 4f       	sbci	r23, 0xFF	; 255
    e47c:	01 96       	adiw	r24, 0x01	; 1
    e47e:	0e 94 1e b7 	call	0x16e3c	; 0x16e3c <__divmodhi4>
#endif
    EEDR = __value;
    e482:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    e484:	0f b6       	in	r0, 0x3f	; 63
    e486:	f8 94       	cli
    e488:	e2 9a       	sbi	0x1c, 2	; 28
    e48a:	e1 9a       	sbi	0x1c, 1	; 28
    e48c:	0f be       	out	0x3f, r0	; 63
    e48e:	0c c0       	rjmp	.+24     	; 0xe4a8 <FSettingPumpPooling+0x450>
			   eeprom_write_byte(&DefPoolingPumpMax+Addr,PPoolingSetting[Addr]);
			   stPumpPooling=ppInitMenu;
		       break;
		  case '*'://Exit
		       stPumpPooling=ppExitSettingPooling;		            
    e490:	84 e0       	ldi	r24, 0x04	; 4
    e492:	80 93 6c 02 	sts	0x026C, r24
    e496:	0f c0       	rjmp	.+30     	; 0xe4b6 <FSettingPumpPooling+0x45e>
		       break;
		  }  
	      break;
     case ppWaitPoolingRespond:	    
	      if ((IsStandaloneAcknoledge==True)||(TimSend>5))stPumpPooling=ppInitMenu;
    e498:	80 91 85 01 	lds	r24, 0x0185
    e49c:	81 30       	cpi	r24, 0x01	; 1
    e49e:	21 f0       	breq	.+8      	; 0xe4a8 <FSettingPumpPooling+0x450>
    e4a0:	80 91 af 0d 	lds	r24, 0x0DAF
    e4a4:	86 30       	cpi	r24, 0x06	; 6
    e4a6:	38 f0       	brcs	.+14     	; 0xe4b6 <FSettingPumpPooling+0x45e>
    e4a8:	10 92 6c 02 	sts	0x026C, r1
    e4ac:	04 c0       	rjmp	.+8      	; 0xe4b6 <FSettingPumpPooling+0x45e>
	      break;
     case ppExitSettingPooling:
          stPumpPooling=ppInitMenu;
    e4ae:	10 92 6c 02 	sts	0x026C, r1
    e4b2:	81 e0       	ldi	r24, 0x01	; 1
    e4b4:	01 c0       	rjmp	.+2      	; 0xe4b8 <FSettingPumpPooling+0x460>
    e4b6:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
    }
return Result;
}
    e4b8:	6a 96       	adiw	r28, 0x1a	; 26
    e4ba:	0f b6       	in	r0, 0x3f	; 63
    e4bc:	f8 94       	cli
    e4be:	de bf       	out	0x3e, r29	; 62
    e4c0:	0f be       	out	0x3f, r0	; 63
    e4c2:	cd bf       	out	0x3d, r28	; 61
    e4c4:	cf 91       	pop	r28
    e4c6:	df 91       	pop	r29
    e4c8:	1f 91       	pop	r17
    e4ca:	0f 91       	pop	r16
    e4cc:	08 95       	ret

0000e4ce <DisplayTicker>:
	case tiDelayLeft:
         if (TimTicker>TICKER_DELAY)stDisplayTicker=tiRight;	     
	     break;
	}
*/
    if (TimTicker>(TICKER_DELAY*2+1)){
    e4ce:	80 91 93 01 	lds	r24, 0x0193
    e4d2:	86 31       	cpi	r24, 0x16	; 22
    e4d4:	38 f0       	brcs	.+14     	; 0xe4e4 <DisplayTicker+0x16>
	    lcd_put(4, 1, '>');
    e4d6:	84 e0       	ldi	r24, 0x04	; 4
    e4d8:	61 e0       	ldi	r22, 0x01	; 1
    e4da:	4e e3       	ldi	r20, 0x3E	; 62
    e4dc:	0e 94 58 ad 	call	0x15ab0	; 0x15ab0 <lcd_put>
		TimTicker=0;
    e4e0:	10 92 93 01 	sts	0x0193, r1
	}
    if (TimTicker==TICKER_DELAY){
    e4e4:	80 91 93 01 	lds	r24, 0x0193
    e4e8:	8a 30       	cpi	r24, 0x0A	; 10
    e4ea:	51 f4       	brne	.+20     	; 0xe500 <DisplayTicker+0x32>
	    lcd_put(4, 1, '<');
    e4ec:	84 e0       	ldi	r24, 0x04	; 4
    e4ee:	61 e0       	ldi	r22, 0x01	; 1
    e4f0:	4c e3       	ldi	r20, 0x3C	; 60
    e4f2:	0e 94 58 ad 	call	0x15ab0	; 0x15ab0 <lcd_put>
		TimTicker++;
    e4f6:	80 91 93 01 	lds	r24, 0x0193
    e4fa:	8f 5f       	subi	r24, 0xFF	; 255
    e4fc:	80 93 93 01 	sts	0x0193, r24
    e500:	08 95       	ret

0000e502 <DisplayIdle>:
	          lcd_put(x,y,'X');     
			  }

}

void DisplayIdle(){
    e502:	6f 92       	push	r6
    e504:	7f 92       	push	r7
    e506:	8f 92       	push	r8
    e508:	9f 92       	push	r9
    e50a:	af 92       	push	r10
    e50c:	bf 92       	push	r11
    e50e:	cf 92       	push	r12
    e510:	df 92       	push	r13
    e512:	ff 92       	push	r15
    e514:	0f 93       	push	r16
    e516:	1f 93       	push	r17
    e518:	df 93       	push	r29
    e51a:	cf 93       	push	r28
    e51c:	cd b7       	in	r28, 0x3d	; 61
    e51e:	de b7       	in	r29, 0x3e	; 62
    e520:	67 97       	sbiw	r28, 0x17	; 23
    e522:	0f b6       	in	r0, 0x3f	; 63
    e524:	f8 94       	cli
    e526:	de bf       	out	0x3e, r29	; 62
    e528:	0f be       	out	0x3f, r0	; 63
    e52a:	cd bf       	out	0x3d, r28	; 61
static unsigned int iLoopDisplayIdle=0;
static char stDispIdle=diScan;
     char i,iDisp;
     char lcdteks[20],sFIP[3];

     iLoopDisplayIdle++;
    e52c:	80 91 d5 02 	lds	r24, 0x02D5
    e530:	90 91 d6 02 	lds	r25, 0x02D6
    e534:	01 96       	adiw	r24, 0x01	; 1
    e536:	90 93 d6 02 	sts	0x02D6, r25
    e53a:	80 93 d5 02 	sts	0x02D5, r24
     //Setting DateTime ON

	if ((iLoopDisplayIdle%50)==0){
    e53e:	62 e3       	ldi	r22, 0x32	; 50
    e540:	70 e0       	ldi	r23, 0x00	; 0
    e542:	0e 94 0a b7 	call	0x16e14	; 0x16e14 <__udivmodhi4>
    e546:	89 2b       	or	r24, r25
    e548:	29 f5       	brne	.+74     	; 0xe594 <DisplayIdle+0x92>
	   if (IFType==IT_STANDALONE)DisplayPumpStatus();
    e54a:	80 91 00 01 	lds	r24, 0x0100
    e54e:	82 30       	cpi	r24, 0x02	; 2
    e550:	11 f4       	brne	.+4      	; 0xe556 <DisplayIdle+0x54>
    e552:	0e 94 97 44 	call	0x892e	; 0x892e <DisplayPumpStatus>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    e556:	e1 99       	sbic	0x1c, 1	; 28
    e558:	fe cf       	rjmp	.-4      	; 0xe556 <DisplayIdle+0x54>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    e55a:	87 e3       	ldi	r24, 0x37	; 55
    e55c:	90 e0       	ldi	r25, 0x00	; 0
    e55e:	9f bb       	out	0x1f, r25	; 31
    e560:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    e562:	e0 9a       	sbi	0x1c, 0	; 28
    e564:	8d b3       	in	r24, 0x1d	; 29
	   if(eeprom_read_byte(&DefShowDateTime)) DisplayDateTime();
    e566:	88 23       	and	r24, r24
    e568:	19 f0       	breq	.+6      	; 0xe570 <DisplayIdle+0x6e>
    e56a:	0e 94 bf 63 	call	0xc77e	; 0xc77e <DisplayDateTime>
    e56e:	02 c0       	rjmp	.+4      	; 0xe574 <DisplayIdle+0x72>
       else DisplayTicker();
    e570:	0e 94 67 72 	call	0xe4ce	; 0xe4ce <DisplayTicker>
	   //Display Standalone Sequnece
	   
	   if((IFType==IT_STANDALONE)&&(IsNewPoolingSequence==True)){
    e574:	80 91 00 01 	lds	r24, 0x0100
    e578:	82 30       	cpi	r24, 0x02	; 2
    e57a:	61 f4       	brne	.+24     	; 0xe594 <DisplayIdle+0x92>
    e57c:	80 91 84 01 	lds	r24, 0x0184
    e580:	81 30       	cpi	r24, 0x01	; 1
    e582:	41 f4       	brne	.+16     	; 0xe594 <DisplayIdle+0x92>
	       IsNewPoolingSequence=False;
    e584:	10 92 84 01 	sts	0x0184, r1
		   DisplayStandaloneSequence(4,18,iSequencePooling);
    e588:	84 e0       	ldi	r24, 0x04	; 4
    e58a:	62 e1       	ldi	r22, 0x12	; 18
    e58c:	40 91 83 01 	lds	r20, 0x0183
    e590:	0e 94 f6 6f 	call	0xdfec	; 0xdfec <DisplayStandaloneSequence>

	 }
     //DisplayPumpStatus Standalone Mode

	 //Display Printing FIP
	 switch (stDispIdle){
    e594:	f0 90 d4 02 	lds	r15, 0x02D4
    e598:	ff 20       	and	r15, r15
    e59a:	29 f0       	breq	.+10     	; 0xe5a6 <DisplayIdle+0xa4>
    e59c:	81 e0       	ldi	r24, 0x01	; 1
    e59e:	f8 16       	cp	r15, r24
    e5a0:	09 f0       	breq	.+2      	; 0xe5a4 <DisplayIdle+0xa2>
    e5a2:	58 c0       	rjmp	.+176    	; 0xe654 <DisplayIdle+0x152>
    e5a4:	2f c0       	rjmp	.+94     	; 0xe604 <DisplayIdle+0x102>
	 case diScan:
	      if (IsBusyIdlePrinting==True){
    e5a6:	f0 90 b4 01 	lds	r15, 0x01B4
    e5aa:	91 e0       	ldi	r25, 0x01	; 1
    e5ac:	f9 16       	cp	r15, r25
    e5ae:	09 f0       	breq	.+2      	; 0xe5b2 <DisplayIdle+0xb0>
    e5b0:	51 c0       	rjmp	.+162    	; 0xe654 <DisplayIdle+0x152>
		       sprintf_P(lcdteks,PSTR("Printing FIP%s "),strFIP_ID);
    e5b2:	00 d0       	rcall	.+0      	; 0xe5b4 <DisplayIdle+0xb2>
    e5b4:	00 d0       	rcall	.+0      	; 0xe5b6 <DisplayIdle+0xb4>
    e5b6:	00 d0       	rcall	.+0      	; 0xe5b8 <DisplayIdle+0xb6>
    e5b8:	ed b7       	in	r30, 0x3d	; 61
    e5ba:	fe b7       	in	r31, 0x3e	; 62
    e5bc:	31 96       	adiw	r30, 0x01	; 1
    e5be:	8e 01       	movw	r16, r28
    e5c0:	0c 5f       	subi	r16, 0xFC	; 252
    e5c2:	1f 4f       	sbci	r17, 0xFF	; 255
    e5c4:	ad b7       	in	r26, 0x3d	; 61
    e5c6:	be b7       	in	r27, 0x3e	; 62
    e5c8:	12 96       	adiw	r26, 0x02	; 2
    e5ca:	1c 93       	st	X, r17
    e5cc:	0e 93       	st	-X, r16
    e5ce:	11 97       	sbiw	r26, 0x01	; 1
    e5d0:	89 e3       	ldi	r24, 0x39	; 57
    e5d2:	9c e1       	ldi	r25, 0x1C	; 28
    e5d4:	93 83       	std	Z+3, r25	; 0x03
    e5d6:	82 83       	std	Z+2, r24	; 0x02
    e5d8:	8b ec       	ldi	r24, 0xCB	; 203
    e5da:	98 e0       	ldi	r25, 0x08	; 8
    e5dc:	95 83       	std	Z+5, r25	; 0x05
    e5de:	84 83       	std	Z+4, r24	; 0x04
    e5e0:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
			   lcd_print(3,1,lcdteks);
    e5e4:	ed b7       	in	r30, 0x3d	; 61
    e5e6:	fe b7       	in	r31, 0x3e	; 62
    e5e8:	36 96       	adiw	r30, 0x06	; 6
    e5ea:	0f b6       	in	r0, 0x3f	; 63
    e5ec:	f8 94       	cli
    e5ee:	fe bf       	out	0x3e, r31	; 62
    e5f0:	0f be       	out	0x3f, r0	; 63
    e5f2:	ed bf       	out	0x3d, r30	; 61
    e5f4:	83 e0       	ldi	r24, 0x03	; 3
    e5f6:	61 e0       	ldi	r22, 0x01	; 1
    e5f8:	a8 01       	movw	r20, r16
    e5fa:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
			   stDispIdle=diWaitNoBusy;
    e5fe:	f0 92 d4 02 	sts	0x02D4, r15
    e602:	28 c0       	rjmp	.+80     	; 0xe654 <DisplayIdle+0x152>
		  }         
	      break;
     case diWaitNoBusy:
	      if (IsBusyIdlePrinting==False){
    e604:	80 91 b4 01 	lds	r24, 0x01B4
    e608:	88 23       	and	r24, r24
    e60a:	21 f5       	brne	.+72     	; 0xe654 <DisplayIdle+0x152>
		       sprintf_P(lcdteks,PSTR("                    "));
    e60c:	00 d0       	rcall	.+0      	; 0xe60e <DisplayIdle+0x10c>
    e60e:	00 d0       	rcall	.+0      	; 0xe610 <DisplayIdle+0x10e>
    e610:	8e 01       	movw	r16, r28
    e612:	0c 5f       	subi	r16, 0xFC	; 252
    e614:	1f 4f       	sbci	r17, 0xFF	; 255
    e616:	ad b7       	in	r26, 0x3d	; 61
    e618:	be b7       	in	r27, 0x3e	; 62
    e61a:	12 96       	adiw	r26, 0x02	; 2
    e61c:	1c 93       	st	X, r17
    e61e:	0e 93       	st	-X, r16
    e620:	11 97       	sbiw	r26, 0x01	; 1
    e622:	84 e2       	ldi	r24, 0x24	; 36
    e624:	9c e1       	ldi	r25, 0x1C	; 28
    e626:	14 96       	adiw	r26, 0x04	; 4
    e628:	9c 93       	st	X, r25
    e62a:	8e 93       	st	-X, r24
    e62c:	13 97       	sbiw	r26, 0x03	; 3
    e62e:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
			   lcd_print(3,1,lcdteks);
    e632:	0f 90       	pop	r0
    e634:	0f 90       	pop	r0
    e636:	0f 90       	pop	r0
    e638:	0f 90       	pop	r0
    e63a:	83 e0       	ldi	r24, 0x03	; 3
    e63c:	61 e0       	ldi	r22, 0x01	; 1
    e63e:	a8 01       	movw	r20, r16
    e640:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
			   stDispIdle=diScan;
    e644:	10 92 d4 02 	sts	0x02D4, r1
			   if (nLocalAccount>0)IsViewFillingFIP=True;
    e648:	80 91 92 01 	lds	r24, 0x0192
    e64c:	88 23       	and	r24, r24
    e64e:	11 f0       	breq	.+4      	; 0xe654 <DisplayIdle+0x152>
    e650:	f0 92 99 01 	sts	0x0199, r15
		  }
	      break;     
	 }
	 //Display Filling FIP
	 if (IsViewFillingFIP==True){
    e654:	80 91 99 01 	lds	r24, 0x0199
    e658:	81 30       	cpi	r24, 0x01	; 1
    e65a:	09 f0       	breq	.+2      	; 0xe65e <DisplayIdle+0x15c>
    e65c:	69 c0       	rjmp	.+210    	; 0xe730 <DisplayIdle+0x22e>
	     IsViewFillingFIP=False;
    e65e:	10 92 99 01 	sts	0x0199, r1
		 if (nLocalAccount>0){
    e662:	80 91 92 01 	lds	r24, 0x0192
    e666:	88 23       	and	r24, r24
    e668:	09 f4       	brne	.+2      	; 0xe66c <DisplayIdle+0x16a>
    e66a:	5c c0       	rjmp	.+184    	; 0xe724 <DisplayIdle+0x222>
		     lcd_printf(3,1,PSTR("@FIP:"));
    e66c:	83 e0       	ldi	r24, 0x03	; 3
    e66e:	61 e0       	ldi	r22, 0x01	; 1
    e670:	4e e1       	ldi	r20, 0x1E	; 30
    e672:	5c e1       	ldi	r21, 0x1C	; 28
    e674:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
    e678:	ff 24       	eor	r15, r15
		     for (iDisp=0;iDisp<nLocalAccount;iDisp++){
			      //leadingZero(LocalAccountFIP[iDisp],sFIP);
				  sprintf_P(sFIP,PSTR("%.2d"),LocalAccountFIP[iDisp]);
    e67a:	5e 01       	movw	r10, r28
    e67c:	08 94       	sec
    e67e:	a1 1c       	adc	r10, r1
    e680:	b1 1c       	adc	r11, r1
    e682:	b9 e1       	ldi	r27, 0x19	; 25
    e684:	6b 2e       	mov	r6, r27
    e686:	bc e1       	ldi	r27, 0x1C	; 28
    e688:	7b 2e       	mov	r7, r27
			      sprintf_P(lcdteks,PSTR("#%s"),sFIP);
    e68a:	a4 e0       	ldi	r26, 0x04	; 4
    e68c:	ca 2e       	mov	r12, r26
    e68e:	d1 2c       	mov	r13, r1
    e690:	cc 0e       	add	r12, r28
    e692:	dd 1e       	adc	r13, r29
    e694:	f5 e1       	ldi	r31, 0x15	; 21
    e696:	8f 2e       	mov	r8, r31
    e698:	fc e1       	ldi	r31, 0x1C	; 28
    e69a:	9f 2e       	mov	r9, r31
    e69c:	3d c0       	rjmp	.+122    	; 0xe718 <DisplayIdle+0x216>
	     IsViewFillingFIP=False;
		 if (nLocalAccount>0){
		     lcd_printf(3,1,PSTR("@FIP:"));
		     for (iDisp=0;iDisp<nLocalAccount;iDisp++){
			      //leadingZero(LocalAccountFIP[iDisp],sFIP);
				  sprintf_P(sFIP,PSTR("%.2d"),LocalAccountFIP[iDisp]);
    e69e:	0f 2d       	mov	r16, r15
    e6a0:	10 e0       	ldi	r17, 0x00	; 0
    e6a2:	00 d0       	rcall	.+0      	; 0xe6a4 <DisplayIdle+0x1a2>
    e6a4:	00 d0       	rcall	.+0      	; 0xe6a6 <DisplayIdle+0x1a4>
    e6a6:	00 d0       	rcall	.+0      	; 0xe6a8 <DisplayIdle+0x1a6>
    e6a8:	ad b7       	in	r26, 0x3d	; 61
    e6aa:	be b7       	in	r27, 0x3e	; 62
    e6ac:	11 96       	adiw	r26, 0x01	; 1
    e6ae:	ed b7       	in	r30, 0x3d	; 61
    e6b0:	fe b7       	in	r31, 0x3e	; 62
    e6b2:	b2 82       	std	Z+2, r11	; 0x02
    e6b4:	a1 82       	std	Z+1, r10	; 0x01
    e6b6:	13 96       	adiw	r26, 0x03	; 3
    e6b8:	7c 92       	st	X, r7
    e6ba:	6e 92       	st	-X, r6
    e6bc:	12 97       	sbiw	r26, 0x02	; 2
    e6be:	f8 01       	movw	r30, r16
    e6c0:	eb 59       	subi	r30, 0x9B	; 155
    e6c2:	fb 4f       	sbci	r31, 0xFB	; 251
    e6c4:	80 81       	ld	r24, Z
    e6c6:	14 96       	adiw	r26, 0x04	; 4
    e6c8:	8c 93       	st	X, r24
    e6ca:	14 97       	sbiw	r26, 0x04	; 4
    e6cc:	15 96       	adiw	r26, 0x05	; 5
    e6ce:	1c 92       	st	X, r1
    e6d0:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
			      sprintf_P(lcdteks,PSTR("#%s"),sFIP);
    e6d4:	ed b7       	in	r30, 0x3d	; 61
    e6d6:	fe b7       	in	r31, 0x3e	; 62
    e6d8:	31 96       	adiw	r30, 0x01	; 1
    e6da:	ad b7       	in	r26, 0x3d	; 61
    e6dc:	be b7       	in	r27, 0x3e	; 62
    e6de:	12 96       	adiw	r26, 0x02	; 2
    e6e0:	dc 92       	st	X, r13
    e6e2:	ce 92       	st	-X, r12
    e6e4:	11 97       	sbiw	r26, 0x01	; 1
    e6e6:	93 82       	std	Z+3, r9	; 0x03
    e6e8:	82 82       	std	Z+2, r8	; 0x02
    e6ea:	b5 82       	std	Z+5, r11	; 0x05
    e6ec:	a4 82       	std	Z+4, r10	; 0x04
    e6ee:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
			      lcd_print(3,6+(iDisp*3),lcdteks);
    e6f2:	ed b7       	in	r30, 0x3d	; 61
    e6f4:	fe b7       	in	r31, 0x3e	; 62
    e6f6:	36 96       	adiw	r30, 0x06	; 6
    e6f8:	0f b6       	in	r0, 0x3f	; 63
    e6fa:	f8 94       	cli
    e6fc:	fe bf       	out	0x3e, r31	; 62
    e6fe:	0f be       	out	0x3f, r0	; 63
    e700:	ed bf       	out	0x3d, r30	; 61
    e702:	b8 01       	movw	r22, r16
    e704:	66 0f       	add	r22, r22
    e706:	77 1f       	adc	r23, r23
    e708:	60 0f       	add	r22, r16
    e70a:	71 1f       	adc	r23, r17
    e70c:	6a 5f       	subi	r22, 0xFA	; 250
    e70e:	83 e0       	ldi	r24, 0x03	; 3
    e710:	a6 01       	movw	r20, r12
    e712:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
	 //Display Filling FIP
	 if (IsViewFillingFIP==True){
	     IsViewFillingFIP=False;
		 if (nLocalAccount>0){
		     lcd_printf(3,1,PSTR("@FIP:"));
		     for (iDisp=0;iDisp<nLocalAccount;iDisp++){
    e716:	f3 94       	inc	r15
    e718:	80 91 92 01 	lds	r24, 0x0192
    e71c:	f8 16       	cp	r15, r24
    e71e:	08 f4       	brcc	.+2      	; 0xe722 <DisplayIdle+0x220>
    e720:	be cf       	rjmp	.-132    	; 0xe69e <DisplayIdle+0x19c>
    e722:	06 c0       	rjmp	.+12     	; 0xe730 <DisplayIdle+0x22e>
				  sprintf_P(sFIP,PSTR("%.2d"),LocalAccountFIP[iDisp]);
			      sprintf_P(lcdteks,PSTR("#%s"),sFIP);
			      lcd_print(3,6+(iDisp*3),lcdteks);
		     }
		 }else{
		 lcd_printf(3,1,PSTR("                    "));
    e724:	83 e0       	ldi	r24, 0x03	; 3
    e726:	61 e0       	ldi	r22, 0x01	; 1
    e728:	40 e0       	ldi	r20, 0x00	; 0
    e72a:	5c e1       	ldi	r21, 0x1C	; 28
    e72c:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		 }    
	 }
	 //Filling @FIP 
     if (IsCompleteFilling==True){
    e730:	80 91 ac 01 	lds	r24, 0x01AC
    e734:	81 30       	cpi	r24, 0x01	; 1
    e736:	c1 f4       	brne	.+48     	; 0xe768 <DisplayIdle+0x266>
	     IsCompleteFilling=False;
    e738:	10 92 ac 01 	sts	0x01AC, r1
	     if (nLocalAccount>0){
    e73c:	90 91 92 01 	lds	r25, 0x0192
    e740:	99 23       	and	r25, r25
    e742:	91 f0       	breq	.+36     	; 0xe768 <DisplayIdle+0x266>
    e744:	e5 e6       	ldi	r30, 0x65	; 101
    e746:	f4 e0       	ldi	r31, 0x04	; 4
			 for(i=0;i<nLocalAccount;i++){//Shift data
    e748:	29 2f       	mov	r18, r25
    e74a:	30 e0       	ldi	r19, 0x00	; 0
    e74c:	2e 0f       	add	r18, r30
    e74e:	3f 1f       	adc	r19, r31
    e750:	02 c0       	rjmp	.+4      	; 0xe756 <DisplayIdle+0x254>
			     LocalAccountFIP[i]=LocalAccountFIP[i+1];
    e752:	81 81       	ldd	r24, Z+1	; 0x01
    e754:	81 93       	st	Z+, r24
	 }
	 //Filling @FIP 
     if (IsCompleteFilling==True){
	     IsCompleteFilling=False;
	     if (nLocalAccount>0){
			 for(i=0;i<nLocalAccount;i++){//Shift data
    e756:	e2 17       	cp	r30, r18
    e758:	f3 07       	cpc	r31, r19
    e75a:	d9 f7       	brne	.-10     	; 0xe752 <DisplayIdle+0x250>
			     LocalAccountFIP[i]=LocalAccountFIP[i+1];
			 }
			 nLocalAccount--;
    e75c:	91 50       	subi	r25, 0x01	; 1
    e75e:	90 93 92 01 	sts	0x0192, r25
             IsViewFillingFIP=True; 
    e762:	81 e0       	ldi	r24, 0x01	; 1
    e764:	80 93 99 01 	sts	0x0199, r24
		 }
	 }
}
    e768:	67 96       	adiw	r28, 0x17	; 23
    e76a:	0f b6       	in	r0, 0x3f	; 63
    e76c:	f8 94       	cli
    e76e:	de bf       	out	0x3e, r29	; 62
    e770:	0f be       	out	0x3f, r0	; 63
    e772:	cd bf       	out	0x3d, r28	; 61
    e774:	cf 91       	pop	r28
    e776:	df 91       	pop	r29
    e778:	1f 91       	pop	r17
    e77a:	0f 91       	pop	r16
    e77c:	ff 90       	pop	r15
    e77e:	df 90       	pop	r13
    e780:	cf 90       	pop	r12
    e782:	bf 90       	pop	r11
    e784:	af 90       	pop	r10
    e786:	9f 90       	pop	r9
    e788:	8f 90       	pop	r8
    e78a:	7f 90       	pop	r7
    e78c:	6f 90       	pop	r6
    e78e:	08 95       	ret

0000e790 <systemMaster>:
	cbi(DDRB,2);sbi(PORTB,2);//MOSI Input
	cbi(DDRB,1);sbi(PORTB,1);//SCK  Input
}

void systemMaster(){
  	_spi_init(1, 0);         //Master
    e790:	81 e0       	ldi	r24, 0x01	; 1
    e792:	60 e0       	ldi	r22, 0x00	; 0
    e794:	0e 94 58 af 	call	0x15eb0	; 0x15eb0 <_spi_init>
    _spi_enable(_SPI_SLAVE); //Enable SS 
    e798:	81 e0       	ldi	r24, 0x01	; 1
    e79a:	0e 94 6b af 	call	0x15ed6	; 0x15ed6 <_spi_enable>
	cbi(DDRB,3);sbi(PORTB,3);//MISO Input
    e79e:	bb 98       	cbi	0x17, 3	; 23
    e7a0:	c3 9a       	sbi	0x18, 3	; 24
	sbi(DDRB,2);             //MOSI Output
    e7a2:	ba 9a       	sbi	0x17, 2	; 23
}
    e7a4:	08 95       	ret

0000e7a6 <systemSlave>:




void systemSlave(){
    _spi_enable(_SPI_NONE);	
    e7a6:	80 e0       	ldi	r24, 0x00	; 0
    e7a8:	0e 94 6b af 	call	0x15ed6	; 0x15ed6 <_spi_enable>
  	_spi_init(0, 1);         //Slave
    e7ac:	80 e0       	ldi	r24, 0x00	; 0
    e7ae:	61 e0       	ldi	r22, 0x01	; 1
    e7b0:	0e 94 58 af 	call	0x15eb0	; 0x15eb0 <_spi_init>
	sbi(DDRB,3);             //MISO Output
    e7b4:	bb 9a       	sbi	0x17, 3	; 23
	sbi(DDRB,3);sbi(PORTB,3);//MISO Output
    e7b6:	bb 9a       	sbi	0x17, 3	; 23
    e7b8:	c3 9a       	sbi	0x18, 3	; 24
	cbi(DDRB,2);sbi(PORTB,2);//MOSI Input
    e7ba:	ba 98       	cbi	0x17, 2	; 23
    e7bc:	c2 9a       	sbi	0x18, 2	; 24
	cbi(DDRB,1);sbi(PORTB,1);//SCK  Input
    e7be:	b9 98       	cbi	0x17, 1	; 23
    e7c0:	c1 9a       	sbi	0x18, 1	; 24
}
    e7c2:	08 95       	ret

0000e7c4 <EDCSendByte>:
    _spi_enable(_SPI_SLAVE); //Enable SS 
	cbi(DDRB,3);sbi(PORTB,3);//MISO Input
	sbi(DDRB,2);             //MOSI Output
}

void EDCSendByte(char EDCData){
    e7c4:	1f 93       	push	r17
    e7c6:	18 2f       	mov	r17, r24
     systemMaster();	 
    e7c8:	0e 94 c8 73 	call	0xe790	; 0xe790 <systemMaster>
     _spi(EDCData);
    e7cc:	81 2f       	mov	r24, r17
    e7ce:	0e 94 82 af 	call	0x15f04	; 0x15f04 <_spi>
     systemSlave();
    e7d2:	0e 94 d3 73 	call	0xe7a6	; 0xe7a6 <systemSlave>
}
    e7d6:	1f 91       	pop	r17
    e7d8:	08 95       	ret

0000e7da <SendEDCMessage>:
     char Result;
	 Result=xLRC^DataIn;
     return(Result);
}

void SendEDCMessage(){
    e7da:	cf 92       	push	r12
    e7dc:	df 92       	push	r13
    e7de:	ef 92       	push	r14
    e7e0:	ff 92       	push	r15
    e7e2:	0f 93       	push	r16
    e7e4:	1f 93       	push	r17
    e7e6:	df 93       	push	r29
    e7e8:	cf 93       	push	r28
    e7ea:	cd b7       	in	r28, 0x3d	; 61
    e7ec:	de b7       	in	r29, 0x3e	; 62
    e7ee:	ec 97       	sbiw	r28, 0x3c	; 60
    e7f0:	0f b6       	in	r0, 0x3f	; 63
    e7f2:	f8 94       	cli
    e7f4:	de bf       	out	0x3e, r29	; 62
    e7f6:	0f be       	out	0x3f, r0	; 63
    e7f8:	cd bf       	out	0x3d, r28	; 61

     //GenerateData
	 //sprintf_P(strAmount,PSTR("%d"),100);//Testing Only
	 //AddZeroLead(strAmount,8);
	 //_uart_printf(0,0,PSTR("StrStatus:"));_uart_print(0,1,strStatus);
     sprintf_P(SerialEDC,PSTR("02%s%s%s%s%s%s%s"),strTranNo,strFIP_ID,strDescription,strPrice,strVolume,strAmount,strStatus);     
    e7fa:	8d b7       	in	r24, 0x3d	; 61
    e7fc:	9e b7       	in	r25, 0x3e	; 62
    e7fe:	42 97       	sbiw	r24, 0x12	; 18
    e800:	0f b6       	in	r0, 0x3f	; 63
    e802:	f8 94       	cli
    e804:	9e bf       	out	0x3e, r25	; 62
    e806:	0f be       	out	0x3f, r0	; 63
    e808:	8d bf       	out	0x3d, r24	; 61
    e80a:	ed b7       	in	r30, 0x3d	; 61
    e80c:	fe b7       	in	r31, 0x3e	; 62
    e80e:	31 96       	adiw	r30, 0x01	; 1
    e810:	8e 01       	movw	r16, r28
    e812:	0f 5f       	subi	r16, 0xFF	; 255
    e814:	1f 4f       	sbci	r17, 0xFF	; 255
    e816:	ad b7       	in	r26, 0x3d	; 61
    e818:	be b7       	in	r27, 0x3e	; 62
    e81a:	12 96       	adiw	r26, 0x02	; 2
    e81c:	1c 93       	st	X, r17
    e81e:	0e 93       	st	-X, r16
    e820:	11 97       	sbiw	r26, 0x01	; 1
    e822:	8d ee       	ldi	r24, 0xED	; 237
    e824:	9b e1       	ldi	r25, 0x1B	; 27
    e826:	93 83       	std	Z+3, r25	; 0x03
    e828:	82 83       	std	Z+2, r24	; 0x02
    e82a:	8e eb       	ldi	r24, 0xBE	; 190
    e82c:	9d e0       	ldi	r25, 0x0D	; 13
    e82e:	95 83       	std	Z+5, r25	; 0x05
    e830:	84 83       	std	Z+4, r24	; 0x04
    e832:	8b ec       	ldi	r24, 0xCB	; 203
    e834:	98 e0       	ldi	r25, 0x08	; 8
    e836:	97 83       	std	Z+7, r25	; 0x07
    e838:	86 83       	std	Z+6, r24	; 0x06
    e83a:	80 e4       	ldi	r24, 0x40	; 64
    e83c:	99 e0       	ldi	r25, 0x09	; 9
    e83e:	91 87       	std	Z+9, r25	; 0x09
    e840:	80 87       	std	Z+8, r24	; 0x08
    e842:	80 eb       	ldi	r24, 0xB0	; 176
    e844:	96 e0       	ldi	r25, 0x06	; 6
    e846:	93 87       	std	Z+11, r25	; 0x0b
    e848:	82 87       	std	Z+10, r24	; 0x0a
    e84a:	84 e8       	ldi	r24, 0x84	; 132
    e84c:	94 e0       	ldi	r25, 0x04	; 4
    e84e:	95 87       	std	Z+13, r25	; 0x0d
    e850:	84 87       	std	Z+12, r24	; 0x0c
    e852:	87 ee       	ldi	r24, 0xE7	; 231
    e854:	9c e0       	ldi	r25, 0x0C	; 12
    e856:	97 87       	std	Z+15, r25	; 0x0f
    e858:	86 87       	std	Z+14, r24	; 0x0e
    e85a:	89 e9       	ldi	r24, 0x99	; 153
    e85c:	94 e0       	ldi	r25, 0x04	; 4
    e85e:	91 8b       	std	Z+17, r25	; 0x11
    e860:	80 8b       	std	Z+16, r24	; 0x10
    e862:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>

	 //SendingData
	 xCRC=0;EDCSendByte(0x02);
    e866:	8d b7       	in	r24, 0x3d	; 61
    e868:	9e b7       	in	r25, 0x3e	; 62
    e86a:	42 96       	adiw	r24, 0x12	; 18
    e86c:	0f b6       	in	r0, 0x3f	; 63
    e86e:	f8 94       	cli
    e870:	9e bf       	out	0x3e, r25	; 62
    e872:	0f be       	out	0x3f, r0	; 63
    e874:	8d bf       	out	0x3d, r24	; 61
    e876:	82 e0       	ldi	r24, 0x02	; 2
    e878:	0e 94 e2 73 	call	0xe7c4	; 0xe7c4 <EDCSendByte>
    e87c:	ff 24       	eor	r15, r15
    e87e:	92 e0       	ldi	r25, 0x02	; 2
    e880:	e9 2e       	mov	r14, r25
    e882:	84 ed       	ldi	r24, 0xD4	; 212
    e884:	c8 2e       	mov	r12, r24
    e886:	80 e3       	ldi	r24, 0x30	; 48
    e888:	d8 2e       	mov	r13, r24
    e88a:	0a c0       	rjmp	.+20     	; 0xe8a0 <SendEDCMessage+0xc6>
	 xCRC=CalcLRC(xCRC,0x02);	      
	 for (i=0;i<strlen(SerialEDC);i++){
          xCRC=CalcLRC(xCRC,SerialEDC[i]);
    e88c:	a0 0f       	add	r26, r16
    e88e:	b1 1f       	adc	r27, r17
    e890:	8c 91       	ld	r24, X
     systemSlave();
}

char CalcLRC(char xLRC,char DataIn){
     char Result;
	 Result=xLRC^DataIn;
    e892:	e8 26       	eor	r14, r24
	 //SendingData
	 xCRC=0;EDCSendByte(0x02);
	 xCRC=CalcLRC(xCRC,0x02);	      
	 for (i=0;i<strlen(SerialEDC);i++){
          xCRC=CalcLRC(xCRC,SerialEDC[i]);
          EDCSendByte(SerialEDC[i]);
    e894:	0e 94 e2 73 	call	0xe7c4	; 0xe7c4 <EDCSendByte>
    e898:	c6 01       	movw	r24, r12
    e89a:	01 97       	sbiw	r24, 0x01	; 1
    e89c:	f1 f7       	brne	.-4      	; 0xe89a <SendEDCMessage+0xc0>
     sprintf_P(SerialEDC,PSTR("02%s%s%s%s%s%s%s"),strTranNo,strFIP_ID,strDescription,strPrice,strVolume,strAmount,strStatus);     

	 //SendingData
	 xCRC=0;EDCSendByte(0x02);
	 xCRC=CalcLRC(xCRC,0x02);	      
	 for (i=0;i<strlen(SerialEDC);i++){
    e89e:	f3 94       	inc	r15
    e8a0:	f8 01       	movw	r30, r16
    e8a2:	01 90       	ld	r0, Z+
    e8a4:	00 20       	and	r0, r0
    e8a6:	e9 f7       	brne	.-6      	; 0xe8a2 <SendEDCMessage+0xc8>
    e8a8:	31 97       	sbiw	r30, 0x01	; 1
    e8aa:	e0 1b       	sub	r30, r16
    e8ac:	f1 0b       	sbc	r31, r17
    e8ae:	af 2d       	mov	r26, r15
    e8b0:	b0 e0       	ldi	r27, 0x00	; 0
    e8b2:	ae 17       	cp	r26, r30
    e8b4:	bf 07       	cpc	r27, r31
    e8b6:	50 f3       	brcs	.-44     	; 0xe88c <SendEDCMessage+0xb2>
          xCRC=CalcLRC(xCRC,SerialEDC[i]);
          EDCSendByte(SerialEDC[i]);
		  //_uart(0,1,SerialEDC[i]);
		  _delay_ms(SPI_EDC_DELAY);//min:8
	 }
     EDCSendByte(0x03);
    e8b8:	83 e0       	ldi	r24, 0x03	; 3
    e8ba:	0e 94 e2 73 	call	0xe7c4	; 0xe7c4 <EDCSendByte>
	 xCRC=CalcLRC(xCRC,0x03);	      
	 EDCSendByte(xCRC);
    e8be:	83 e0       	ldi	r24, 0x03	; 3
    e8c0:	8e 25       	eor	r24, r14
    e8c2:	0e 94 e2 73 	call	0xe7c4	; 0xe7c4 <EDCSendByte>
}
    e8c6:	ec 96       	adiw	r28, 0x3c	; 60
    e8c8:	0f b6       	in	r0, 0x3f	; 63
    e8ca:	f8 94       	cli
    e8cc:	de bf       	out	0x3e, r29	; 62
    e8ce:	0f be       	out	0x3f, r0	; 63
    e8d0:	cd bf       	out	0x3d, r28	; 61
    e8d2:	cf 91       	pop	r28
    e8d4:	df 91       	pop	r29
    e8d6:	1f 91       	pop	r17
    e8d8:	0f 91       	pop	r16
    e8da:	ff 90       	pop	r15
    e8dc:	ef 90       	pop	r14
    e8de:	df 90       	pop	r13
    e8e0:	cf 90       	pop	r12
    e8e2:	08 95       	ret

0000e8e4 <SendSlaveCommand>:
void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
	 PoolMsg=plMsg;
     IsControlPooling=True;
}
void SendSlaveCommand(char SlaveCommand,char SlaveMessage){     
    e8e4:	0f 93       	push	r16
    e8e6:	1f 93       	push	r17
    e8e8:	18 2f       	mov	r17, r24
    e8ea:	06 2f       	mov	r16, r22
	 systemMaster();
    e8ec:	0e 94 c8 73 	call	0xe790	; 0xe790 <systemMaster>
	 _spi(0x05);
    e8f0:	85 e0       	ldi	r24, 0x05	; 5
    e8f2:	0e 94 82 af 	call	0x15f04	; 0x15f04 <_spi>
	 _spi(SlaveCommand);
    e8f6:	81 2f       	mov	r24, r17
    e8f8:	0e 94 82 af 	call	0x15f04	; 0x15f04 <_spi>
	 _spi(SlaveMessage);
    e8fc:	80 2f       	mov	r24, r16
    e8fe:	0e 94 82 af 	call	0x15f04	; 0x15f04 <_spi>
	 _spi(0x06);
    e902:	86 e0       	ldi	r24, 0x06	; 6
    e904:	0e 94 82 af 	call	0x15f04	; 0x15f04 <_spi>
	 systemSlave();
    e908:	0e 94 d3 73 	call	0xe7a6	; 0xe7a6 <systemSlave>
}
    e90c:	1f 91       	pop	r17
    e90e:	0f 91       	pop	r16
    e910:	08 95       	ret

0000e912 <FSettingPumpID>:
     if ((*Value)>MinValue){
	     (*Value)--;
	 }else *Value=MaxValue;
}

char FSettingPumpID(){
    e912:	9f 92       	push	r9
    e914:	af 92       	push	r10
    e916:	bf 92       	push	r11
    e918:	cf 92       	push	r12
    e91a:	df 92       	push	r13
    e91c:	ef 92       	push	r14
    e91e:	ff 92       	push	r15
    e920:	0f 93       	push	r16
    e922:	1f 93       	push	r17
    e924:	df 93       	push	r29
    e926:	cf 93       	push	r28
    e928:	cd b7       	in	r28, 0x3d	; 61
    e92a:	de b7       	in	r29, 0x3e	; 62
    e92c:	64 97       	sbiw	r28, 0x14	; 20
    e92e:	0f b6       	in	r0, 0x3f	; 63
    e930:	f8 94       	cli
    e932:	de bf       	out	0x3e, r29	; 62
    e934:	0f be       	out	0x3f, r0	; 63
    e936:	cd bf       	out	0x3d, r28	; 61
	 char iLoop,Result,KeyChar,KeyPressed,i,j,CheckPump;
	 char lcdteks[20];
	 static char Idx,PPumpId[8],MsgPumpId,PumpCount;
     
	 Result=MENU_NONE;
	 switch (stMenuPumpID){
    e938:	80 91 6b 02 	lds	r24, 0x026B
    e93c:	85 30       	cpi	r24, 0x05	; 5
    e93e:	09 f4       	brne	.+2      	; 0xe942 <FSettingPumpID+0x30>
    e940:	85 c1       	rjmp	.+778    	; 0xec4c <FSettingPumpID+0x33a>
    e942:	86 30       	cpi	r24, 0x06	; 6
    e944:	90 f4       	brcc	.+36     	; 0xe96a <FSettingPumpID+0x58>
    e946:	82 30       	cpi	r24, 0x02	; 2
    e948:	09 f4       	brne	.+2      	; 0xe94c <FSettingPumpID+0x3a>
    e94a:	8f c0       	rjmp	.+286    	; 0xea6a <FSettingPumpID+0x158>
    e94c:	83 30       	cpi	r24, 0x03	; 3
    e94e:	30 f4       	brcc	.+12     	; 0xe95c <FSettingPumpID+0x4a>
    e950:	88 23       	and	r24, r24
    e952:	f1 f0       	breq	.+60     	; 0xe990 <FSettingPumpID+0x7e>
    e954:	81 30       	cpi	r24, 0x01	; 1
    e956:	09 f0       	breq	.+2      	; 0xe95a <FSettingPumpID+0x48>
    e958:	6c c2       	rjmp	.+1240   	; 0xee32 <FSettingPumpID+0x520>
    e95a:	2d c0       	rjmp	.+90     	; 0xe9b6 <FSettingPumpID+0xa4>
    e95c:	83 30       	cpi	r24, 0x03	; 3
    e95e:	09 f4       	brne	.+2      	; 0xe962 <FSettingPumpID+0x50>
    e960:	51 c1       	rjmp	.+674    	; 0xec04 <FSettingPumpID+0x2f2>
    e962:	84 30       	cpi	r24, 0x04	; 4
    e964:	09 f0       	breq	.+2      	; 0xe968 <FSettingPumpID+0x56>
    e966:	65 c2       	rjmp	.+1226   	; 0xee32 <FSettingPumpID+0x520>
    e968:	6a c1       	rjmp	.+724    	; 0xec3e <FSettingPumpID+0x32c>
    e96a:	88 30       	cpi	r24, 0x08	; 8
    e96c:	09 f4       	brne	.+2      	; 0xe970 <FSettingPumpID+0x5e>
    e96e:	f9 c1       	rjmp	.+1010   	; 0xed62 <FSettingPumpID+0x450>
    e970:	89 30       	cpi	r24, 0x09	; 9
    e972:	38 f4       	brcc	.+14     	; 0xe982 <FSettingPumpID+0x70>
    e974:	86 30       	cpi	r24, 0x06	; 6
    e976:	09 f4       	brne	.+2      	; 0xe97a <FSettingPumpID+0x68>
    e978:	98 c1       	rjmp	.+816    	; 0xecaa <FSettingPumpID+0x398>
    e97a:	87 30       	cpi	r24, 0x07	; 7
    e97c:	09 f0       	breq	.+2      	; 0xe980 <FSettingPumpID+0x6e>
    e97e:	59 c2       	rjmp	.+1202   	; 0xee32 <FSettingPumpID+0x520>
    e980:	3e c2       	rjmp	.+1148   	; 0xedfe <FSettingPumpID+0x4ec>
    e982:	89 30       	cpi	r24, 0x09	; 9
    e984:	09 f4       	brne	.+2      	; 0xe988 <FSettingPumpID+0x76>
    e986:	43 c2       	rjmp	.+1158   	; 0xee0e <FSettingPumpID+0x4fc>
    e988:	8a 30       	cpi	r24, 0x0A	; 10
    e98a:	09 f0       	breq	.+2      	; 0xe98e <FSettingPumpID+0x7c>
    e98c:	52 c2       	rjmp	.+1188   	; 0xee32 <FSettingPumpID+0x520>
    e98e:	45 c2       	rjmp	.+1162   	; 0xee1a <FSettingPumpID+0x508>
	 case mpInitPumpId:	      
	      //Disable PumpPooling
		  if (IFType==IT_STANDALONE)SendSlaveCommand(SC_STOP_POOL_SEQUENCE,0);
    e990:	80 91 00 01 	lds	r24, 0x0100
    e994:	82 30       	cpi	r24, 0x02	; 2
    e996:	21 f4       	brne	.+8      	; 0xe9a0 <FSettingPumpID+0x8e>
    e998:	8f e1       	ldi	r24, 0x1F	; 31
    e99a:	60 e0       	ldi	r22, 0x00	; 0
    e99c:	0e 94 72 74 	call	0xe8e4	; 0xe8e4 <SendSlaveCommand>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    e9a0:	81 e6       	ldi	r24, 0x61	; 97
    e9a2:	92 e0       	ldi	r25, 0x02	; 2
    e9a4:	65 e4       	ldi	r22, 0x45	; 69
    e9a6:	70 e0       	ldi	r23, 0x00	; 0
    e9a8:	48 e0       	ldi	r20, 0x08	; 8
    e9aa:	50 e0       	ldi	r21, 0x00	; 0
    e9ac:	2d ef       	ldi	r18, 0xFD	; 253
    e9ae:	32 e1       	ldi	r19, 0x12	; 18
    e9b0:	0e 94 f1 b3 	call	0x167e2	; 0x167e2 <__eerd_block>
    e9b4:	49 c1       	rjmp	.+658    	; 0xec48 <FSettingPumpID+0x336>
		  eeprom_read_block((void*) &PPumpId, (const void*) &DefPumpMap,8);
          stMenuPumpID=mpDisplayPumpId;
	      break;
	 case mpDisplayPumpId:
	      lcd_clear();		  
    e9b6:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
    e9ba:	e1 e6       	ldi	r30, 0x61	; 97
    e9bc:	ee 2e       	mov	r14, r30
    e9be:	e2 e0       	ldi	r30, 0x02	; 2
    e9c0:	fe 2e       	mov	r15, r30
    e9c2:	01 e0       	ldi	r16, 0x01	; 1
    e9c4:	10 e0       	ldi	r17, 0x00	; 0
		  for (iLoop=0;iLoop<4;iLoop++){
			  sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d"),(iLoop+1),PPumpId[iLoop],(iLoop+5),PPumpId[iLoop+4]);
    e9c6:	6e 01       	movw	r12, r28
    e9c8:	08 94       	sec
    e9ca:	c1 1c       	adc	r12, r1
    e9cc:	d1 1c       	adc	r13, r1
    e9ce:	76 ec       	ldi	r23, 0xC6	; 198
    e9d0:	a7 2e       	mov	r10, r23
    e9d2:	7c e0       	ldi	r23, 0x0C	; 12
    e9d4:	b7 2e       	mov	r11, r23
    e9d6:	8d b7       	in	r24, 0x3d	; 61
    e9d8:	9e b7       	in	r25, 0x3e	; 62
    e9da:	0c 97       	sbiw	r24, 0x0c	; 12
    e9dc:	0f b6       	in	r0, 0x3f	; 63
    e9de:	f8 94       	cli
    e9e0:	9e bf       	out	0x3e, r25	; 62
    e9e2:	0f be       	out	0x3f, r0	; 63
    e9e4:	8d bf       	out	0x3d, r24	; 61
    e9e6:	ed b7       	in	r30, 0x3d	; 61
    e9e8:	fe b7       	in	r31, 0x3e	; 62
    e9ea:	31 96       	adiw	r30, 0x01	; 1
    e9ec:	ad b7       	in	r26, 0x3d	; 61
    e9ee:	be b7       	in	r27, 0x3e	; 62
    e9f0:	12 96       	adiw	r26, 0x02	; 2
    e9f2:	dc 92       	st	X, r13
    e9f4:	ce 92       	st	-X, r12
    e9f6:	11 97       	sbiw	r26, 0x01	; 1
    e9f8:	b3 82       	std	Z+3, r11	; 0x03
    e9fa:	a2 82       	std	Z+2, r10	; 0x02
    e9fc:	15 83       	std	Z+5, r17	; 0x05
    e9fe:	04 83       	std	Z+4, r16	; 0x04
    ea00:	d7 01       	movw	r26, r14
    ea02:	8c 91       	ld	r24, X
    ea04:	86 83       	std	Z+6, r24	; 0x06
    ea06:	17 82       	std	Z+7, r1	; 0x07
    ea08:	0c 5f       	subi	r16, 0xFC	; 252
    ea0a:	1f 4f       	sbci	r17, 0xFF	; 255
    ea0c:	11 87       	std	Z+9, r17	; 0x09
    ea0e:	00 87       	std	Z+8, r16	; 0x08
    ea10:	04 50       	subi	r16, 0x04	; 4
    ea12:	10 40       	sbci	r17, 0x00	; 0
    ea14:	14 96       	adiw	r26, 0x04	; 4
    ea16:	8c 91       	ld	r24, X
    ea18:	82 87       	std	Z+10, r24	; 0x0a
    ea1a:	13 86       	std	Z+11, r1	; 0x0b
    ea1c:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
			  lcd_print((iLoop+1),1,lcdteks);
    ea20:	ed b7       	in	r30, 0x3d	; 61
    ea22:	fe b7       	in	r31, 0x3e	; 62
    ea24:	3c 96       	adiw	r30, 0x0c	; 12
    ea26:	0f b6       	in	r0, 0x3f	; 63
    ea28:	f8 94       	cli
    ea2a:	fe bf       	out	0x3e, r31	; 62
    ea2c:	0f be       	out	0x3f, r0	; 63
    ea2e:	ed bf       	out	0x3d, r30	; 61
    ea30:	80 2f       	mov	r24, r16
    ea32:	61 e0       	ldi	r22, 0x01	; 1
    ea34:	a6 01       	movw	r20, r12
    ea36:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
    ea3a:	08 94       	sec
    ea3c:	e1 1c       	adc	r14, r1
    ea3e:	f1 1c       	adc	r15, r1
    ea40:	0f 5f       	subi	r16, 0xFF	; 255
    ea42:	1f 4f       	sbci	r17, 0xFF	; 255
		  eeprom_read_block((void*) &PPumpId, (const void*) &DefPumpMap,8);
          stMenuPumpID=mpDisplayPumpId;
	      break;
	 case mpDisplayPumpId:
	      lcd_clear();		  
		  for (iLoop=0;iLoop<4;iLoop++){
    ea44:	f5 e6       	ldi	r31, 0x65	; 101
    ea46:	ef 16       	cp	r14, r31
    ea48:	f2 e0       	ldi	r31, 0x02	; 2
    ea4a:	ff 06       	cpc	r15, r31
    ea4c:	21 f6       	brne	.-120    	; 0xe9d6 <FSettingPumpID+0xc4>
			  sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d"),(iLoop+1),PPumpId[iLoop],(iLoop+5),PPumpId[iLoop+4]);
			  lcd_print((iLoop+1),1,lcdteks);
          }
          lcd_printf(3,15,PSTR("*)Back"));
    ea4e:	83 e0       	ldi	r24, 0x03	; 3
    ea50:	6f e0       	ldi	r22, 0x0F	; 15
    ea52:	4f eb       	ldi	r20, 0xBF	; 191
    ea54:	5c e0       	ldi	r21, 0x0C	; 12
    ea56:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
	      lcd_printf(4,15,PSTR("#)Save"));
    ea5a:	84 e0       	ldi	r24, 0x04	; 4
    ea5c:	6f e0       	ldi	r22, 0x0F	; 15
    ea5e:	48 eb       	ldi	r20, 0xB8	; 184
    ea60:	5c e0       	ldi	r21, 0x0C	; 12
    ea62:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
          stMenuPumpID=mpSelectInput;
    ea66:	82 e0       	ldi	r24, 0x02	; 2
    ea68:	cf c1       	rjmp	.+926    	; 0xee08 <FSettingPumpID+0x4f6>
	      break;
     case mpSelectInput:
	      KeyPressed=_key_scan(1);
    ea6a:	81 e0       	ldi	r24, 0x01	; 1
    ea6c:	0e 94 84 ae 	call	0x15d08	; 0x15d08 <_key_scan>
    ea70:	98 2e       	mov	r9, r24
	      KeyChar=_key_btn(KeyPressed);
    ea72:	0e 94 e5 ad 	call	0x15bca	; 0x15bca <_key_btn>
    ea76:	98 2f       	mov	r25, r24
          if ((KeyChar>='1') && (KeyChar<='8')){
    ea78:	81 53       	subi	r24, 0x31	; 49
    ea7a:	88 30       	cpi	r24, 0x08	; 8
    ea7c:	08 f0       	brcs	.+2      	; 0xea80 <FSettingPumpID+0x16e>
    ea7e:	85 c0       	rjmp	.+266    	; 0xeb8a <FSettingPumpID+0x278>
		      //eeprom_read_block((void*) &PPumpId, (const void*) &DefPumpMap,8);
			  switch(IFType){
    ea80:	80 91 00 01 	lds	r24, 0x0100
    ea84:	81 30       	cpi	r24, 0x01	; 1
    ea86:	19 f0       	breq	.+6      	; 0xea8e <FSettingPumpID+0x17c>
    ea88:	82 30       	cpi	r24, 0x02	; 2
    ea8a:	a1 f5       	brne	.+104    	; 0xeaf4 <FSettingPumpID+0x1e2>
    ea8c:	17 c0       	rjmp	.+46     	; 0xeabc <FSettingPumpID+0x1aa>
			  case IT_SLAVE:
			       if (IsShift==False)IncValue(&PPumpId[KeyChar-'1'],0,99);//PPumpId[KeyChar-'1']=((PPumpId[KeyChar-'1']+1)%100);
    ea8e:	80 91 6a 02 	lds	r24, 0x026A
    ea92:	88 23       	and	r24, r24
    ea94:	41 f4       	brne	.+16     	; 0xeaa6 <FSettingPumpID+0x194>
    ea96:	e9 2f       	mov	r30, r25
    ea98:	f0 e0       	ldi	r31, 0x00	; 0
    ea9a:	e0 5d       	subi	r30, 0xD0	; 208
    ea9c:	fd 4f       	sbci	r31, 0xFD	; 253
		}
	}
}

void IncValue(char *Value,char MinValue,char MaxValue){
     if ((*Value)<MaxValue){
    ea9e:	80 81       	ld	r24, Z
    eaa0:	83 36       	cpi	r24, 0x63	; 99
    eaa2:	c8 f4       	brcc	.+50     	; 0xead6 <FSettingPumpID+0x1c4>
    eaa4:	16 c0       	rjmp	.+44     	; 0xead2 <FSettingPumpID+0x1c0>
		      //eeprom_read_block((void*) &PPumpId, (const void*) &DefPumpMap,8);
			  switch(IFType){
			  case IT_SLAVE:
			       if (IsShift==False)IncValue(&PPumpId[KeyChar-'1'],0,99);//PPumpId[KeyChar-'1']=((PPumpId[KeyChar-'1']+1)%100);
				   else
				   if (IsShift==True)DecValue(&PPumpId[KeyChar-'1'],0,99);//PPumpId[KeyChar-'1']=100-(100-((PPumpId[KeyChar-'1']+1)%100));
    eaa6:	81 30       	cpi	r24, 0x01	; 1
    eaa8:	29 f5       	brne	.+74     	; 0xeaf4 <FSettingPumpID+0x1e2>
    eaaa:	e9 2f       	mov	r30, r25
    eaac:	f0 e0       	ldi	r31, 0x00	; 0
    eaae:	e0 5d       	subi	r30, 0xD0	; 208
    eab0:	fd 4f       	sbci	r31, 0xFD	; 253
	     (*Value)++;
	 }else *Value=MinValue;
}

void DecValue(char *Value,char MinValue,char MaxValue){
     if ((*Value)>MinValue){
    eab2:	80 81       	ld	r24, Z
    eab4:	88 23       	and	r24, r24
    eab6:	d1 f4       	brne	.+52     	; 0xeaec <FSettingPumpID+0x1da>
	     (*Value)--;
	 }else *Value=MaxValue;
    eab8:	83 e6       	ldi	r24, 0x63	; 99
    eaba:	1b c0       	rjmp	.+54     	; 0xeaf2 <FSettingPumpID+0x1e0>
			       if (IsShift==False)IncValue(&PPumpId[KeyChar-'1'],0,99);//PPumpId[KeyChar-'1']=((PPumpId[KeyChar-'1']+1)%100);
				   else
				   if (IsShift==True)DecValue(&PPumpId[KeyChar-'1'],0,99);//PPumpId[KeyChar-'1']=100-(100-((PPumpId[KeyChar-'1']+1)%100));
			       break;
              case IT_STANDALONE:
			       if (IsShift==False)IncValue(&PPumpId[KeyChar-'1'],0,16);//PPumpId[KeyChar-'1']=((PPumpId[KeyChar-'1']+1)%16);
    eabc:	80 91 6a 02 	lds	r24, 0x026A
    eac0:	88 23       	and	r24, r24
    eac2:	59 f4       	brne	.+22     	; 0xeada <FSettingPumpID+0x1c8>
    eac4:	e9 2f       	mov	r30, r25
    eac6:	f0 e0       	ldi	r31, 0x00	; 0
    eac8:	e0 5d       	subi	r30, 0xD0	; 208
    eaca:	fd 4f       	sbci	r31, 0xFD	; 253
		}
	}
}

void IncValue(char *Value,char MinValue,char MaxValue){
     if ((*Value)<MaxValue){
    eacc:	80 81       	ld	r24, Z
    eace:	80 31       	cpi	r24, 0x10	; 16
    ead0:	10 f4       	brcc	.+4      	; 0xead6 <FSettingPumpID+0x1c4>
	     (*Value)++;
    ead2:	8f 5f       	subi	r24, 0xFF	; 255
    ead4:	0e c0       	rjmp	.+28     	; 0xeaf2 <FSettingPumpID+0x1e0>
	 }else *Value=MinValue;
    ead6:	10 82       	st	Z, r1
    ead8:	0d c0       	rjmp	.+26     	; 0xeaf4 <FSettingPumpID+0x1e2>
				   if (IsShift==True)DecValue(&PPumpId[KeyChar-'1'],0,99);//PPumpId[KeyChar-'1']=100-(100-((PPumpId[KeyChar-'1']+1)%100));
			       break;
              case IT_STANDALONE:
			       if (IsShift==False)IncValue(&PPumpId[KeyChar-'1'],0,16);//PPumpId[KeyChar-'1']=((PPumpId[KeyChar-'1']+1)%16);
				   else
				   if (IsShift==True)DecValue(&PPumpId[KeyChar-'1'],0,16);//PPumpId[KeyChar-'1']=17-(17-((PPumpId[KeyChar-'1']+1)%17));
    eada:	81 30       	cpi	r24, 0x01	; 1
    eadc:	59 f4       	brne	.+22     	; 0xeaf4 <FSettingPumpID+0x1e2>
    eade:	e9 2f       	mov	r30, r25
    eae0:	f0 e0       	ldi	r31, 0x00	; 0
    eae2:	e0 5d       	subi	r30, 0xD0	; 208
    eae4:	fd 4f       	sbci	r31, 0xFD	; 253
	     (*Value)++;
	 }else *Value=MinValue;
}

void DecValue(char *Value,char MinValue,char MaxValue){
     if ((*Value)>MinValue){
    eae6:	80 81       	ld	r24, Z
    eae8:	88 23       	and	r24, r24
    eaea:	11 f0       	breq	.+4      	; 0xeaf0 <FSettingPumpID+0x1de>
	     (*Value)--;
    eaec:	81 50       	subi	r24, 0x01	; 1
    eaee:	01 c0       	rjmp	.+2      	; 0xeaf2 <FSettingPumpID+0x1e0>
	 }else *Value=MaxValue;
    eaf0:	80 e1       	ldi	r24, 0x10	; 16
    eaf2:	80 83       	st	Z, r24
    eaf4:	61 e6       	ldi	r22, 0x61	; 97
    eaf6:	e6 2e       	mov	r14, r22
    eaf8:	62 e0       	ldi	r22, 0x02	; 2
    eafa:	f6 2e       	mov	r15, r22
    eafc:	01 e0       	ldi	r16, 0x01	; 1
    eafe:	10 e0       	ldi	r17, 0x00	; 0
				   if (IsShift==True)DecValue(&PPumpId[KeyChar-'1'],0,16);//PPumpId[KeyChar-'1']=17-(17-((PPumpId[KeyChar-'1']+1)%17));
			       break;			  
			  }
			  //Redraw
			  for (iLoop=0;iLoop<4;iLoop++){
				  sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d"),(iLoop+1),PPumpId[iLoop],(iLoop+5),PPumpId[iLoop+4]);
    eb00:	6e 01       	movw	r12, r28
    eb02:	08 94       	sec
    eb04:	c1 1c       	adc	r12, r1
    eb06:	d1 1c       	adc	r13, r1
    eb08:	54 ea       	ldi	r21, 0xA4	; 164
    eb0a:	a5 2e       	mov	r10, r21
    eb0c:	5c e0       	ldi	r21, 0x0C	; 12
    eb0e:	b5 2e       	mov	r11, r21
    eb10:	8d b7       	in	r24, 0x3d	; 61
    eb12:	9e b7       	in	r25, 0x3e	; 62
    eb14:	0c 97       	sbiw	r24, 0x0c	; 12
    eb16:	0f b6       	in	r0, 0x3f	; 63
    eb18:	f8 94       	cli
    eb1a:	9e bf       	out	0x3e, r25	; 62
    eb1c:	0f be       	out	0x3f, r0	; 63
    eb1e:	8d bf       	out	0x3d, r24	; 61
    eb20:	ed b7       	in	r30, 0x3d	; 61
    eb22:	fe b7       	in	r31, 0x3e	; 62
    eb24:	31 96       	adiw	r30, 0x01	; 1
    eb26:	ad b7       	in	r26, 0x3d	; 61
    eb28:	be b7       	in	r27, 0x3e	; 62
    eb2a:	12 96       	adiw	r26, 0x02	; 2
    eb2c:	dc 92       	st	X, r13
    eb2e:	ce 92       	st	-X, r12
    eb30:	11 97       	sbiw	r26, 0x01	; 1
    eb32:	b3 82       	std	Z+3, r11	; 0x03
    eb34:	a2 82       	std	Z+2, r10	; 0x02
    eb36:	15 83       	std	Z+5, r17	; 0x05
    eb38:	04 83       	std	Z+4, r16	; 0x04
    eb3a:	d7 01       	movw	r26, r14
    eb3c:	8c 91       	ld	r24, X
    eb3e:	86 83       	std	Z+6, r24	; 0x06
    eb40:	17 82       	std	Z+7, r1	; 0x07
    eb42:	0c 5f       	subi	r16, 0xFC	; 252
    eb44:	1f 4f       	sbci	r17, 0xFF	; 255
    eb46:	11 87       	std	Z+9, r17	; 0x09
    eb48:	00 87       	std	Z+8, r16	; 0x08
    eb4a:	04 50       	subi	r16, 0x04	; 4
    eb4c:	10 40       	sbci	r17, 0x00	; 0
    eb4e:	14 96       	adiw	r26, 0x04	; 4
    eb50:	8c 91       	ld	r24, X
    eb52:	82 87       	std	Z+10, r24	; 0x0a
    eb54:	13 86       	std	Z+11, r1	; 0x0b
    eb56:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
				  lcd_print((iLoop+1),1,lcdteks);
    eb5a:	ed b7       	in	r30, 0x3d	; 61
    eb5c:	fe b7       	in	r31, 0x3e	; 62
    eb5e:	3c 96       	adiw	r30, 0x0c	; 12
    eb60:	0f b6       	in	r0, 0x3f	; 63
    eb62:	f8 94       	cli
    eb64:	fe bf       	out	0x3e, r31	; 62
    eb66:	0f be       	out	0x3f, r0	; 63
    eb68:	ed bf       	out	0x3d, r30	; 61
    eb6a:	80 2f       	mov	r24, r16
    eb6c:	61 e0       	ldi	r22, 0x01	; 1
    eb6e:	a6 01       	movw	r20, r12
    eb70:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
    eb74:	08 94       	sec
    eb76:	e1 1c       	adc	r14, r1
    eb78:	f1 1c       	adc	r15, r1
    eb7a:	0f 5f       	subi	r16, 0xFF	; 255
    eb7c:	1f 4f       	sbci	r17, 0xFF	; 255
				   else
				   if (IsShift==True)DecValue(&PPumpId[KeyChar-'1'],0,16);//PPumpId[KeyChar-'1']=17-(17-((PPumpId[KeyChar-'1']+1)%17));
			       break;			  
			  }
			  //Redraw
			  for (iLoop=0;iLoop<4;iLoop++){
    eb7e:	f5 e6       	ldi	r31, 0x65	; 101
    eb80:	ef 16       	cp	r14, r31
    eb82:	f2 e0       	ldi	r31, 0x02	; 2
    eb84:	ff 06       	cpc	r15, r31
    eb86:	21 f6       	brne	.-120    	; 0xeb10 <FSettingPumpID+0x1fe>
    eb88:	2b c0       	rjmp	.+86     	; 0xebe0 <FSettingPumpID+0x2ce>
				  sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d"),(iLoop+1),PPumpId[iLoop],(iLoop+5),PPumpId[iLoop+4]);
				  lcd_print((iLoop+1),1,lcdteks);
	          }
		  }else if (KeyChar=='#'){
    eb8a:	93 32       	cpi	r25, 0x23	; 35
    eb8c:	21 f5       	brne	.+72     	; 0xebd6 <FSettingPumpID+0x2c4>
    eb8e:	40 e0       	ldi	r20, 0x00	; 0
    eb90:	20 e0       	ldi	r18, 0x00	; 0
    eb92:	30 e0       	ldi	r19, 0x00	; 0
    eb94:	52 2f       	mov	r21, r18
		      //Evaluate same PumpID
			  PumpCount=0;
			  for (i=0;i<8;i++){
			       CheckPump=PPumpId[i];
    eb96:	f9 01       	movw	r30, r18
    eb98:	ef 59       	subi	r30, 0x9F	; 159
    eb9a:	fd 4f       	sbci	r31, 0xFD	; 253
    eb9c:	e0 81       	ld	r30, Z
				   if (CheckPump>0){
    eb9e:	ee 23       	and	r30, r30
    eba0:	69 f0       	breq	.+26     	; 0xebbc <FSettingPumpID+0x2aa>
    eba2:	a1 e6       	ldi	r26, 0x61	; 97
    eba4:	b2 e0       	ldi	r27, 0x02	; 2
    eba6:	90 e0       	ldi	r25, 0x00	; 0
				      for(j=0;j<8;j++){					      
					      if ((i!=j)&&(CheckPump==PPumpId[j]))
    eba8:	59 17       	cp	r21, r25
    ebaa:	21 f0       	breq	.+8      	; 0xebb4 <FSettingPumpID+0x2a2>
    ebac:	8c 91       	ld	r24, X
    ebae:	e8 17       	cp	r30, r24
    ebb0:	09 f4       	brne	.+2      	; 0xebb4 <FSettingPumpID+0x2a2>
						       PumpCount++;
    ebb2:	4f 5f       	subi	r20, 0xFF	; 255
		      //Evaluate same PumpID
			  PumpCount=0;
			  for (i=0;i<8;i++){
			       CheckPump=PPumpId[i];
				   if (CheckPump>0){
				      for(j=0;j<8;j++){					      
    ebb4:	9f 5f       	subi	r25, 0xFF	; 255
    ebb6:	11 96       	adiw	r26, 0x01	; 1
    ebb8:	98 30       	cpi	r25, 0x08	; 8
    ebba:	b1 f7       	brne	.-20     	; 0xeba8 <FSettingPumpID+0x296>
    ebbc:	2f 5f       	subi	r18, 0xFF	; 255
    ebbe:	3f 4f       	sbci	r19, 0xFF	; 255
				  lcd_print((iLoop+1),1,lcdteks);
	          }
		  }else if (KeyChar=='#'){
		      //Evaluate same PumpID
			  PumpCount=0;
			  for (i=0;i<8;i++){
    ebc0:	28 30       	cpi	r18, 0x08	; 8
    ebc2:	31 05       	cpc	r19, r1
    ebc4:	39 f7       	brne	.-50     	; 0xeb94 <FSettingPumpID+0x282>
    ebc6:	40 93 5f 02 	sts	0x025F, r20
					      if ((i!=j)&&(CheckPump==PPumpId[j]))
						       PumpCount++;
					  }
				    }				     
				  }			       			  			  
			  if (PumpCount>0) stMenuPumpID=mpSaveFailed;
    ebca:	44 23       	and	r20, r20
    ebcc:	11 f0       	breq	.+4      	; 0xebd2 <FSettingPumpID+0x2c0>
    ebce:	83 e0       	ldi	r24, 0x03	; 3
    ebd0:	05 c0       	rjmp	.+10     	; 0xebdc <FSettingPumpID+0x2ca>
			  else stMenuPumpID=mpSavingPumpId;
    ebd2:	85 e0       	ldi	r24, 0x05	; 5
    ebd4:	03 c0       	rjmp	.+6      	; 0xebdc <FSettingPumpID+0x2ca>
		  }	
		  else if (KeyChar=='*'){
    ebd6:	9a 32       	cpi	r25, 0x2A	; 42
    ebd8:	19 f4       	brne	.+6      	; 0xebe0 <FSettingPumpID+0x2ce>
		      stMenuPumpID=mpExitPumpId;
    ebda:	8a e0       	ldi	r24, 0x0A	; 10
    ebdc:	80 93 6b 02 	sts	0x026B, r24
		  }
		  if (KeyPressed==_KEY_SHIFT){
    ebe0:	8b e7       	ldi	r24, 0x7B	; 123
    ebe2:	98 16       	cp	r9, r24
    ebe4:	09 f0       	breq	.+2      	; 0xebe8 <FSettingPumpID+0x2d6>
    ebe6:	25 c1       	rjmp	.+586    	; 0xee32 <FSettingPumpID+0x520>
		      if (IsShift==False)IsShift=True;
    ebe8:	80 91 6a 02 	lds	r24, 0x026A
    ebec:	88 23       	and	r24, r24
    ebee:	21 f4       	brne	.+8      	; 0xebf8 <FSettingPumpID+0x2e6>
    ebf0:	81 e0       	ldi	r24, 0x01	; 1
    ebf2:	80 93 6a 02 	sts	0x026A, r24
    ebf6:	1d c1       	rjmp	.+570    	; 0xee32 <FSettingPumpID+0x520>
			  else
			  if (IsShift==True)IsShift=False;
    ebf8:	81 30       	cpi	r24, 0x01	; 1
    ebfa:	09 f0       	breq	.+2      	; 0xebfe <FSettingPumpID+0x2ec>
    ebfc:	1a c1       	rjmp	.+564    	; 0xee32 <FSettingPumpID+0x520>
    ebfe:	10 92 6a 02 	sts	0x026A, r1
    ec02:	17 c1       	rjmp	.+558    	; 0xee32 <FSettingPumpID+0x520>
		  }
	      break;
     case mpSaveFailed:
	      lcd_clear();
    ec04:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
		  lcd_printf(1,1,PSTR("      Warning!      "));
    ec08:	81 e0       	ldi	r24, 0x01	; 1
    ec0a:	61 e0       	ldi	r22, 0x01	; 1
    ec0c:	4f e8       	ldi	r20, 0x8F	; 143
    ec0e:	5c e0       	ldi	r21, 0x0C	; 12
    ec10:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		  lcd_printf(2,1,PSTR("  Duplicate PumpID  "));
    ec14:	82 e0       	ldi	r24, 0x02	; 2
    ec16:	61 e0       	ldi	r22, 0x01	; 1
    ec18:	4a e7       	ldi	r20, 0x7A	; 122
    ec1a:	5c e0       	ldi	r21, 0x0C	; 12
    ec1c:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		  lcd_printf(3,1,PSTR("    Not Allowed     "));		  
    ec20:	83 e0       	ldi	r24, 0x03	; 3
    ec22:	61 e0       	ldi	r22, 0x01	; 1
    ec24:	45 e6       	ldi	r20, 0x65	; 101
    ec26:	5c e0       	ldi	r21, 0x0C	; 12
    ec28:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    ec2c:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    ec2e:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    ec30:	82 e0       	ldi	r24, 0x02	; 2
    ec32:	80 93 bf 01 	sts	0x01BF, r24
	      lcd_clear();
		  lcd_printf(1,1,PSTR("      Warning!      "));
		  lcd_printf(2,1,PSTR("  Duplicate PumpID  "));
		  lcd_printf(3,1,PSTR("    Not Allowed     "));		  
		  system_beep(2);
	      TimDisplay=0;
    ec36:	10 92 95 01 	sts	0x0195, r1
	      stMenuPumpID=mpDisplayFailed;
    ec3a:	84 e0       	ldi	r24, 0x04	; 4
    ec3c:	e5 c0       	rjmp	.+458    	; 0xee08 <FSettingPumpID+0x4f6>
          break;	 
     case mpDisplayFailed:
	      if (TimDisplay>6) stMenuPumpID=mpDisplayPumpId;
    ec3e:	80 91 95 01 	lds	r24, 0x0195
    ec42:	87 30       	cpi	r24, 0x07	; 7
    ec44:	08 f4       	brcc	.+2      	; 0xec48 <FSettingPumpID+0x336>
    ec46:	f5 c0       	rjmp	.+490    	; 0xee32 <FSettingPumpID+0x520>
    ec48:	81 e0       	ldi	r24, 0x01	; 1
    ec4a:	de c0       	rjmp	.+444    	; 0xee08 <FSettingPumpID+0x4f6>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    ec4c:	85 e4       	ldi	r24, 0x45	; 69
    ec4e:	90 e0       	ldi	r25, 0x00	; 0
    ec50:	61 e6       	ldi	r22, 0x61	; 97
    ec52:	72 e0       	ldi	r23, 0x02	; 2
    ec54:	48 e0       	ldi	r20, 0x08	; 8
    ec56:	50 e0       	ldi	r21, 0x00	; 0
    ec58:	25 e0       	ldi	r18, 0x05	; 5
    ec5a:	33 e1       	ldi	r19, 0x13	; 19
    ec5c:	0e 94 0d b4 	call	0x1681a	; 0x1681a <__eewr_block>
	      break;
     case mpSavingPumpId:
	      eeprom_write_block((const void*) &PPumpId, (void*) &DefPumpMap, 8);
		  if (IFType==IT_STANDALONE){
    ec60:	80 91 00 01 	lds	r24, 0x0100
    ec64:	82 30       	cpi	r24, 0x02	; 2
    ec66:	e9 f4       	brne	.+58     	; 0xeca2 <FSettingPumpID+0x390>
		      //SendConfig to Slave
			  lcd_clear();
    ec68:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
              lcd_printf(1,1,PSTR("-PumpID-"));
    ec6c:	81 e0       	ldi	r24, 0x01	; 1
    ec6e:	61 e0       	ldi	r22, 0x01	; 1
    ec70:	4c e5       	ldi	r20, 0x5C	; 92
    ec72:	5c e0       	ldi	r21, 0x0C	; 12
    ec74:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
              lcd_printf(2,1,PSTR("Saving.."));
    ec78:	82 e0       	ldi	r24, 0x02	; 2
    ec7a:	61 e0       	ldi	r22, 0x01	; 1
    ec7c:	43 e5       	ldi	r20, 0x53	; 83
    ec7e:	5c e0       	ldi	r21, 0x0C	; 12
    ec80:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
			  Idx=0;
    ec84:	10 92 69 02 	sts	0x0269, r1
			  PumpCount=0;
    ec88:	10 92 5f 02 	sts	0x025F, r1
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    ec8c:	81 e6       	ldi	r24, 0x61	; 97
    ec8e:	92 e0       	ldi	r25, 0x02	; 2
    ec90:	65 e4       	ldi	r22, 0x45	; 69
    ec92:	70 e0       	ldi	r23, 0x00	; 0
    ec94:	48 e0       	ldi	r20, 0x08	; 8
    ec96:	50 e0       	ldi	r21, 0x00	; 0
    ec98:	2d ef       	ldi	r18, 0xFD	; 253
    ec9a:	32 e1       	ldi	r19, 0x12	; 18
    ec9c:	0e 94 f1 b3 	call	0x167e2	; 0x167e2 <__eerd_block>
    eca0:	b2 c0       	rjmp	.+356    	; 0xee06 <FSettingPumpID+0x4f4>
              eeprom_read_block((void*) &PPumpId, (const void*) &DefPumpMap,8);
              stMenuPumpID=mpSendConfigToSlave;
		  }else if (IFType==IT_SLAVE){
    eca2:	81 30       	cpi	r24, 0x01	; 1
    eca4:	09 f0       	breq	.+2      	; 0xeca8 <FSettingPumpID+0x396>
    eca6:	c5 c0       	rjmp	.+394    	; 0xee32 <FSettingPumpID+0x520>
    eca8:	b6 c0       	rjmp	.+364    	; 0xee16 <FSettingPumpID+0x504>
		      //SendConfig to Slave              
              stMenuPumpID=mpExitPumpId;
		  }
	      break;
     case mpSendConfigToSlave:
	      IsStandaloneAcknoledge=False;
    ecaa:	10 92 85 01 	sts	0x0185, r1
	      if (PPumpId[Idx]!=0){
    ecae:	90 91 69 02 	lds	r25, 0x0269
    ecb2:	29 2f       	mov	r18, r25
    ecb4:	30 e0       	ldi	r19, 0x00	; 0
    ecb6:	f9 01       	movw	r30, r18
    ecb8:	ef 59       	subi	r30, 0x9F	; 159
    ecba:	fd 4f       	sbci	r31, 0xFD	; 253
    ecbc:	60 81       	ld	r22, Z
    ecbe:	66 23       	and	r22, r22
    ecc0:	81 f0       	breq	.+32     	; 0xece2 <FSettingPumpID+0x3d0>
		      PumpCount++;
    ecc2:	80 91 5f 02 	lds	r24, 0x025F
    ecc6:	8f 5f       	subi	r24, 0xFF	; 255
    ecc8:	80 93 5f 02 	sts	0x025F, r24
		      MsgPumpId=((Idx<<4)|(0x0F&PPumpId[Idx]));//[Idx][PumpId]
    eccc:	6f 70       	andi	r22, 0x0F	; 15
    ecce:	44 e0       	ldi	r20, 0x04	; 4
    ecd0:	22 0f       	add	r18, r18
    ecd2:	33 1f       	adc	r19, r19
    ecd4:	4a 95       	dec	r20
    ecd6:	e1 f7       	brne	.-8      	; 0xecd0 <FSettingPumpID+0x3be>
    ecd8:	62 2b       	or	r22, r18
    ecda:	60 93 60 02 	sts	0x0260, r22
	         //SendPoolingCommand(SC_SET_PUMPID,MsgPumpId);
			  SendSlaveCommand(SC_SET_PUMPID,MsgPumpId);
    ecde:	8d e1       	ldi	r24, 0x1D	; 29
    ece0:	02 c0       	rjmp	.+4      	; 0xece6 <FSettingPumpID+0x3d4>
		  }else SendSlaveCommand(SC_CLEAR_PUMPID,Idx);//SendPoolingCommand(SC_CLEAR_PUMPID,Idx);
    ece2:	8e e1       	ldi	r24, 0x1E	; 30
    ece4:	69 2f       	mov	r22, r25
    ece6:	0e 94 72 74 	call	0xe8e4	; 0xe8e4 <SendSlaveCommand>
		  sprintf_P(lcdteks,PSTR("Id[%d]=%.2d  "),Idx+1,PPumpId[Idx]);
    ecea:	e0 91 69 02 	lds	r30, 0x0269
    ecee:	f0 e0       	ldi	r31, 0x00	; 0
    ecf0:	ad b7       	in	r26, 0x3d	; 61
    ecf2:	be b7       	in	r27, 0x3e	; 62
    ecf4:	18 97       	sbiw	r26, 0x08	; 8
    ecf6:	0f b6       	in	r0, 0x3f	; 63
    ecf8:	f8 94       	cli
    ecfa:	be bf       	out	0x3e, r27	; 62
    ecfc:	0f be       	out	0x3f, r0	; 63
    ecfe:	ad bf       	out	0x3d, r26	; 61
    ed00:	2d b7       	in	r18, 0x3d	; 61
    ed02:	3e b7       	in	r19, 0x3e	; 62
    ed04:	2f 5f       	subi	r18, 0xFF	; 255
    ed06:	3f 4f       	sbci	r19, 0xFF	; 255
    ed08:	8e 01       	movw	r16, r28
    ed0a:	0f 5f       	subi	r16, 0xFF	; 255
    ed0c:	1f 4f       	sbci	r17, 0xFF	; 255
    ed0e:	12 96       	adiw	r26, 0x02	; 2
    ed10:	1c 93       	st	X, r17
    ed12:	0e 93       	st	-X, r16
    ed14:	11 97       	sbiw	r26, 0x01	; 1
    ed16:	85 e4       	ldi	r24, 0x45	; 69
    ed18:	9c e0       	ldi	r25, 0x0C	; 12
    ed1a:	d9 01       	movw	r26, r18
    ed1c:	13 96       	adiw	r26, 0x03	; 3
    ed1e:	9c 93       	st	X, r25
    ed20:	8e 93       	st	-X, r24
    ed22:	12 97       	sbiw	r26, 0x02	; 2
    ed24:	31 96       	adiw	r30, 0x01	; 1
    ed26:	15 96       	adiw	r26, 0x05	; 5
    ed28:	fc 93       	st	X, r31
    ed2a:	ee 93       	st	-X, r30
    ed2c:	14 97       	sbiw	r26, 0x04	; 4
    ed2e:	31 97       	sbiw	r30, 0x01	; 1
    ed30:	ef 59       	subi	r30, 0x9F	; 159
    ed32:	fd 4f       	sbci	r31, 0xFD	; 253
    ed34:	80 81       	ld	r24, Z
    ed36:	16 96       	adiw	r26, 0x06	; 6
    ed38:	8c 93       	st	X, r24
    ed3a:	16 97       	sbiw	r26, 0x06	; 6
    ed3c:	17 96       	adiw	r26, 0x07	; 7
    ed3e:	1c 92       	st	X, r1
    ed40:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
		  lcd_print(3,1,lcdteks);
    ed44:	ed b7       	in	r30, 0x3d	; 61
    ed46:	fe b7       	in	r31, 0x3e	; 62
    ed48:	38 96       	adiw	r30, 0x08	; 8
    ed4a:	0f b6       	in	r0, 0x3f	; 63
    ed4c:	f8 94       	cli
    ed4e:	fe bf       	out	0x3e, r31	; 62
    ed50:	0f be       	out	0x3f, r0	; 63
    ed52:	ed bf       	out	0x3d, r30	; 61
    ed54:	83 e0       	ldi	r24, 0x03	; 3
    ed56:	61 e0       	ldi	r22, 0x01	; 1
    ed58:	a8 01       	movw	r20, r16
    ed5a:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
          stMenuPumpID=mpWaitSlaveReply;
    ed5e:	88 e0       	ldi	r24, 0x08	; 8
    ed60:	53 c0       	rjmp	.+166    	; 0xee08 <FSettingPumpID+0x4f6>
	      break;
     case mpWaitSlaveReply:
	      KeyPressed=_key_scan(1);
    ed62:	81 e0       	ldi	r24, 0x01	; 1
    ed64:	0e 94 84 ae 	call	0x15d08	; 0x15d08 <_key_scan>
	      KeyChar=_key_btn(KeyPressed);
    ed68:	0e 94 e5 ad 	call	0x15bca	; 0x15bca <_key_btn>
		  if (KeyChar=='*'){
    ed6c:	8a 32       	cpi	r24, 0x2A	; 42
    ed6e:	79 f4       	brne	.+30     	; 0xed8e <FSettingPumpID+0x47c>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    ed70:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    ed72:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    ed74:	82 e0       	ldi	r24, 0x02	; 2
    ed76:	80 93 bf 01 	sts	0x01BF, r24
     case mpWaitSlaveReply:
	      KeyPressed=_key_scan(1);
	      KeyChar=_key_btn(KeyPressed);
		  if (KeyChar=='*'){
		      system_beep(2);
		      lcd_printf(2,1,PSTR("Cancel     "));
    ed7a:	61 e0       	ldi	r22, 0x01	; 1
    ed7c:	49 e3       	ldi	r20, 0x39	; 57
    ed7e:	5c e0       	ldi	r21, 0x0C	; 12
    ed80:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
			  TimDisplay=0;
    ed84:	10 92 95 01 	sts	0x0195, r1
		      stMenuPumpID=mpDelayExitPumpId;
    ed88:	89 e0       	ldi	r24, 0x09	; 9
    ed8a:	80 93 6b 02 	sts	0x026B, r24
			  }
          if (IsStandaloneAcknoledge==True){
    ed8e:	80 91 85 01 	lds	r24, 0x0185
    ed92:	81 30       	cpi	r24, 0x01	; 1
    ed94:	09 f0       	breq	.+2      	; 0xed98 <FSettingPumpID+0x486>
    ed96:	4d c0       	rjmp	.+154    	; 0xee32 <FSettingPumpID+0x520>
		      Idx++;
    ed98:	80 91 69 02 	lds	r24, 0x0269
    ed9c:	8f 5f       	subi	r24, 0xFF	; 255
    ed9e:	80 93 69 02 	sts	0x0269, r24
		      if (Idx<8){//Finish, Send MaxPumpCount
    eda2:	88 30       	cpi	r24, 0x08	; 8
    eda4:	10 f5       	brcc	.+68     	; 0xedea <FSettingPumpID+0x4d8>
			      eeprom_write_byte(&DefPoolingPumpMax,PumpCount);
    eda6:	20 91 5f 02 	lds	r18, 0x025F
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    edaa:	e1 99       	sbic	0x1c, 1	; 28
    edac:	fe cf       	rjmp	.-4      	; 0xedaa <FSettingPumpID+0x498>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    edae:	84 e4       	ldi	r24, 0x44	; 68
    edb0:	91 e0       	ldi	r25, 0x01	; 1
    edb2:	9f bb       	out	0x1f, r25	; 31
    edb4:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    edb6:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
    edb8:	0f b6       	in	r0, 0x3f	; 63
    edba:	f8 94       	cli
    edbc:	e2 9a       	sbi	0x1c, 2	; 28
    edbe:	e1 9a       	sbi	0x1c, 1	; 28
    edc0:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    edc2:	e1 99       	sbic	0x1c, 1	; 28
    edc4:	fe cf       	rjmp	.-4      	; 0xedc2 <FSettingPumpID+0x4b0>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    edc6:	9f bb       	out	0x1f, r25	; 31
    edc8:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    edca:	e0 9a       	sbi	0x1c, 0	; 28
    edcc:	9d b3       	in	r25, 0x1d	; 29
				  PumpCountMax=eeprom_read_byte(&DefPoolingPumpMax);
    edce:	90 93 4f 01 	sts	0x014F, r25
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    edd2:	85 e1       	ldi	r24, 0x15	; 21
    edd4:	80 93 b9 06 	sts	0x06B9, r24
	 PoolMsg=plMsg;
    edd8:	90 93 0a 0d 	sts	0x0D0A, r25
     IsControlPooling=True;
    eddc:	81 e0       	ldi	r24, 0x01	; 1
    edde:	80 93 87 01 	sts	0x0187, r24
		      Idx++;
		      if (Idx<8){//Finish, Send MaxPumpCount
			      eeprom_write_byte(&DefPoolingPumpMax,PumpCount);
				  PumpCountMax=eeprom_read_byte(&DefPoolingPumpMax);
                  SendPoolingCommand(SC_SET_POOLING_MAX_PUMP,PumpCountMax);
			      TimDisplay=0;		 
    ede2:	10 92 95 01 	sts	0x0195, r1
				  stMenuPumpID=mpDelaySaveConfig;
    ede6:	87 e0       	ldi	r24, 0x07	; 7
    ede8:	0f c0       	rjmp	.+30     	; 0xee08 <FSettingPumpID+0x4f6>
			  }else{lcd_printf(2,1,PSTR("Completed"));
    edea:	82 e0       	ldi	r24, 0x02	; 2
    edec:	61 e0       	ldi	r22, 0x01	; 1
    edee:	4f e2       	ldi	r20, 0x2F	; 47
    edf0:	5c e0       	ldi	r21, 0x0C	; 12
    edf2:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
					TimDisplay=0;
    edf6:	10 92 95 01 	sts	0x0195, r1
				    stMenuPumpID=mpDelayExitPumpId;
    edfa:	89 e0       	ldi	r24, 0x09	; 9
    edfc:	05 c0       	rjmp	.+10     	; 0xee08 <FSettingPumpID+0x4f6>
				   }
			  }		  
	      break;
     case mpDelaySaveConfig:
	      if (TimDisplay>2)stMenuPumpID=mpSendConfigToSlave;
    edfe:	80 91 95 01 	lds	r24, 0x0195
    ee02:	83 30       	cpi	r24, 0x03	; 3
    ee04:	b0 f0       	brcs	.+44     	; 0xee32 <FSettingPumpID+0x520>
    ee06:	86 e0       	ldi	r24, 0x06	; 6
    ee08:	80 93 6b 02 	sts	0x026B, r24
    ee0c:	12 c0       	rjmp	.+36     	; 0xee32 <FSettingPumpID+0x520>
	      break;
     case mpDelayExitPumpId:
	      if (TimDisplay>8)stMenuPumpID=mpExitPumpId;
    ee0e:	80 91 95 01 	lds	r24, 0x0195
    ee12:	89 30       	cpi	r24, 0x09	; 9
    ee14:	70 f0       	brcs	.+28     	; 0xee32 <FSettingPumpID+0x520>
    ee16:	8a e0       	ldi	r24, 0x0A	; 10
    ee18:	f7 cf       	rjmp	.-18     	; 0xee08 <FSettingPumpID+0x4f6>
	      break;
     case mpExitPumpId:
	      if (IFType==IT_STANDALONE)
    ee1a:	80 91 00 01 	lds	r24, 0x0100
    ee1e:	82 30       	cpi	r24, 0x02	; 2
    ee20:	21 f4       	brne	.+8      	; 0xee2a <FSettingPumpID+0x518>
		      SendSlaveCommand(SC_START_POOL_SEQUENCE,0);
    ee22:	80 e2       	ldi	r24, 0x20	; 32
    ee24:	60 e0       	ldi	r22, 0x00	; 0
    ee26:	0e 94 72 74 	call	0xe8e4	; 0xe8e4 <SendSlaveCommand>
	      Result=MENU_DONE;
          stMenuPumpID=mpInitPumpId;
    ee2a:	10 92 6b 02 	sts	0x026B, r1
    ee2e:	81 e0       	ldi	r24, 0x01	; 1
    ee30:	01 c0       	rjmp	.+2      	; 0xee34 <FSettingPumpID+0x522>
    ee32:	80 e0       	ldi	r24, 0x00	; 0
	      break;
	 }
   return Result;
}
    ee34:	64 96       	adiw	r28, 0x14	; 20
    ee36:	0f b6       	in	r0, 0x3f	; 63
    ee38:	f8 94       	cli
    ee3a:	de bf       	out	0x3e, r29	; 62
    ee3c:	0f be       	out	0x3f, r0	; 63
    ee3e:	cd bf       	out	0x3d, r28	; 61
    ee40:	cf 91       	pop	r28
    ee42:	df 91       	pop	r29
    ee44:	1f 91       	pop	r17
    ee46:	0f 91       	pop	r16
    ee48:	ff 90       	pop	r15
    ee4a:	ef 90       	pop	r14
    ee4c:	df 90       	pop	r13
    ee4e:	cf 90       	pop	r12
    ee50:	bf 90       	pop	r11
    ee52:	af 90       	pop	r10
    ee54:	9f 90       	pop	r9
    ee56:	08 95       	ret

0000ee58 <_menu_pumpid>:

void _menu_pumpid(void){
	while(1){
	   if (FSettingPumpID()==MENU_DONE){
    ee58:	0e 94 89 74 	call	0xe912	; 0xe912 <FSettingPumpID>
    ee5c:	81 30       	cpi	r24, 0x01	; 1
    ee5e:	e1 f7       	brne	.-8      	; 0xee58 <_menu_pumpid>
	       break;
	   }	   
	}
}
    ee60:	08 95       	ret

0000ee62 <_menu_pump>:
        lcd_printf(4,15,PSTR("*)Exit"));
}



void _menu_pump(void){
    ee62:	cf 93       	push	r28
    ee64:	df 93       	push	r29
    ee66:	c4 ec       	ldi	r28, 0xC4	; 196
    ee68:	d9 e0       	ldi	r29, 0x09	; 9
	char __key;

	while(1){
		lcd_clear();_delay_ms(10);
    ee6a:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
    ee6e:	ce 01       	movw	r24, r28
    ee70:	01 97       	sbiw	r24, 0x01	; 1
    ee72:	f1 f7       	brne	.-4      	; 0xee70 <_menu_pump+0xe>
		lcd_printf(1, 1, PSTR("1)ID"));
    ee74:	81 e0       	ldi	r24, 0x01	; 1
    ee76:	61 e0       	ldi	r22, 0x01	; 1
    ee78:	43 e6       	ldi	r20, 0x63	; 99
    ee7a:	5d e0       	ldi	r21, 0x0D	; 13
    ee7c:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		lcd_printf(2, 1, PSTR("2)Product"));
    ee80:	82 e0       	ldi	r24, 0x02	; 2
    ee82:	61 e0       	ldi	r22, 0x01	; 1
    ee84:	49 e5       	ldi	r20, 0x59	; 89
    ee86:	5d e0       	ldi	r21, 0x0D	; 13
    ee88:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		lcd_printf(4, 1, PSTR("*)Exit"));
    ee8c:	84 e0       	ldi	r24, 0x04	; 4
    ee8e:	61 e0       	ldi	r22, 0x01	; 1
    ee90:	42 e5       	ldi	r20, 0x52	; 82
    ee92:	5d e0       	ldi	r21, 0x0D	; 13
    ee94:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>

		while(1){
			__key = _key_scan(1);
    ee98:	81 e0       	ldi	r24, 0x01	; 1
    ee9a:	0e 94 84 ae 	call	0x15d08	; 0x15d08 <_key_scan>
			if(__key == _KEY_CANCEL)
    ee9e:	87 3e       	cpi	r24, 0xE7	; 231
    eea0:	51 f0       	breq	.+20     	; 0xeeb6 <_menu_pump+0x54>
				return;
			if(__key == _KEY_1){
    eea2:	8e 3e       	cpi	r24, 0xEE	; 238
    eea4:	19 f4       	brne	.+6      	; 0xeeac <_menu_pump+0x4a>
				_menu_pumpid();
    eea6:	0e 94 2c 77 	call	0xee58	; 0xee58 <_menu_pumpid>
    eeaa:	df cf       	rjmp	.-66     	; 0xee6a <_menu_pump+0x8>
				break;
			}
			if(__key == _KEY_2){
    eeac:	8e 3d       	cpi	r24, 0xDE	; 222
    eeae:	a1 f7       	brne	.-24     	; 0xee98 <_menu_pump+0x36>
				_menu_pumpprod();
    eeb0:	0e 94 cf 4a 	call	0x959e	; 0x959e <_menu_pumpprod>
    eeb4:	da cf       	rjmp	.-76     	; 0xee6a <_menu_pump+0x8>
				break;
			}
		}
	}
}
    eeb6:	df 91       	pop	r29
    eeb8:	cf 91       	pop	r28
    eeba:	08 95       	ret

0000eebc <FMenuPumpType>:





void FMenuPumpType(){
    eebc:	cf 92       	push	r12
    eebe:	df 92       	push	r13
    eec0:	ef 92       	push	r14
    eec2:	ff 92       	push	r15
    eec4:	0f 93       	push	r16
    eec6:	1f 93       	push	r17
    eec8:	df 93       	push	r29
    eeca:	cf 93       	push	r28
    eecc:	cd b7       	in	r28, 0x3d	; 61
    eece:	de b7       	in	r29, 0x3e	; 62
    eed0:	a8 97       	sbiw	r28, 0x28	; 40
    eed2:	0f b6       	in	r0, 0x3f	; 63
    eed4:	f8 94       	cli
    eed6:	de bf       	out	0x3e, r29	; 62
    eed8:	0f be       	out	0x3f, r0	; 63
    eeda:	cd bf       	out	0x3d, r28	; 61
     stPumpType=ptInitMenu;
	 IsRunPumpType=True;
	 while(IsRunPumpType==True){
		  switch(stPumpType){
		  case ptInitMenu:
		       lcd_clear();
    eedc:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
			   lcd_printf(1,1,PSTR("-Dispenser Brand-"));
    eee0:	81 e0       	ldi	r24, 0x01	; 1
    eee2:	61 e0       	ldi	r22, 0x01	; 1
    eee4:	40 e4       	ldi	r20, 0x40	; 64
    eee6:	5d e0       	ldi	r21, 0x0D	; 13
    eee8:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    eeec:	e1 99       	sbic	0x1c, 1	; 28
    eeee:	fe cf       	rjmp	.-4      	; 0xeeec <FMenuPumpType+0x30>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    eef0:	87 e3       	ldi	r24, 0x37	; 55
    eef2:	91 e0       	ldi	r25, 0x01	; 1
    eef4:	9f bb       	out	0x1f, r25	; 31
    eef6:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    eef8:	e0 9a       	sbi	0x1c, 0	; 28
    eefa:	0d b3       	in	r16, 0x1d	; 29
			   IdxType=eeprom_read_byte(&DefDispenserBrand);
			   //Brand Selection
			   if (IdxType>=3) IdxType=0;
    eefc:	03 30       	cpi	r16, 0x03	; 3
    eefe:	08 f0       	brcs	.+2      	; 0xef02 <FMenuPumpType+0x46>
    ef00:	00 e0       	ldi	r16, 0x00	; 0
               strcpy_P(DispenserBrandName,(PGM_P)pgm_read_word(&(DefListDispenserName[IdxType])));
    ef02:	10 e0       	ldi	r17, 0x00	; 0
    ef04:	f8 01       	movw	r30, r16
    ef06:	ee 0f       	add	r30, r30
    ef08:	ff 1f       	adc	r31, r31
    ef0a:	eb 50       	subi	r30, 0x0B	; 11
    ef0c:	fd 4f       	sbci	r31, 0xFD	; 253
    ef0e:	65 91       	lpm	r22, Z+
    ef10:	74 91       	lpm	r23, Z+
    ef12:	f5 e1       	ldi	r31, 0x15	; 21
    ef14:	cf 2e       	mov	r12, r31
    ef16:	d1 2c       	mov	r13, r1
    ef18:	cc 0e       	add	r12, r28
    ef1a:	dd 1e       	adc	r13, r29
    ef1c:	c6 01       	movw	r24, r12
    ef1e:	0e 94 e1 b3 	call	0x167c2	; 0x167c2 <strcpy_P>
			   sprintf_P(lcdteks,PSTR("%d.%s"),IdxType+1,DispenserBrandName);
    ef22:	8d b7       	in	r24, 0x3d	; 61
    ef24:	9e b7       	in	r25, 0x3e	; 62
    ef26:	08 97       	sbiw	r24, 0x08	; 8
    ef28:	0f b6       	in	r0, 0x3f	; 63
    ef2a:	f8 94       	cli
    ef2c:	9e bf       	out	0x3e, r25	; 62
    ef2e:	0f be       	out	0x3f, r0	; 63
    ef30:	8d bf       	out	0x3d, r24	; 61
    ef32:	ed b7       	in	r30, 0x3d	; 61
    ef34:	fe b7       	in	r31, 0x3e	; 62
    ef36:	31 96       	adiw	r30, 0x01	; 1
    ef38:	7e 01       	movw	r14, r28
    ef3a:	08 94       	sec
    ef3c:	e1 1c       	adc	r14, r1
    ef3e:	f1 1c       	adc	r15, r1
    ef40:	ad b7       	in	r26, 0x3d	; 61
    ef42:	be b7       	in	r27, 0x3e	; 62
    ef44:	12 96       	adiw	r26, 0x02	; 2
    ef46:	fc 92       	st	X, r15
    ef48:	ee 92       	st	-X, r14
    ef4a:	11 97       	sbiw	r26, 0x01	; 1
    ef4c:	8a e3       	ldi	r24, 0x3A	; 58
    ef4e:	9d e0       	ldi	r25, 0x0D	; 13
    ef50:	93 83       	std	Z+3, r25	; 0x03
    ef52:	82 83       	std	Z+2, r24	; 0x02
    ef54:	0f 5f       	subi	r16, 0xFF	; 255
    ef56:	1f 4f       	sbci	r17, 0xFF	; 255
    ef58:	15 83       	std	Z+5, r17	; 0x05
    ef5a:	04 83       	std	Z+4, r16	; 0x04
    ef5c:	d7 82       	std	Z+7, r13	; 0x07
    ef5e:	c6 82       	std	Z+6, r12	; 0x06
    ef60:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
			   lcd_print(2,1,lcdteks);
    ef64:	8d b7       	in	r24, 0x3d	; 61
    ef66:	9e b7       	in	r25, 0x3e	; 62
    ef68:	08 96       	adiw	r24, 0x08	; 8
    ef6a:	0f b6       	in	r0, 0x3f	; 63
    ef6c:	f8 94       	cli
    ef6e:	9e bf       	out	0x3e, r25	; 62
    ef70:	0f be       	out	0x3f, r0	; 63
    ef72:	8d bf       	out	0x3d, r24	; 61
    ef74:	82 e0       	ldi	r24, 0x02	; 2
    ef76:	61 e0       	ldi	r22, 0x01	; 1
    ef78:	a7 01       	movw	r20, r14
    ef7a:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
			   lcd_printf(4,1,PSTR("[*]Exit  [#]Change "));
    ef7e:	84 e0       	ldi	r24, 0x04	; 4
    ef80:	61 e0       	ldi	r22, 0x01	; 1
    ef82:	46 e2       	ldi	r20, 0x26	; 38
    ef84:	5d e0       	ldi	r21, 0x0D	; 13
    ef86:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
			   if (IFType==IT_STANDALONE)
    ef8a:	80 91 00 01 	lds	r24, 0x0100
    ef8e:	82 30       	cpi	r24, 0x02	; 2
    ef90:	21 f4       	brne	.+8      	; 0xef9a <FMenuPumpType+0xde>
			       SendSlaveCommand(SC_STOP_POOL_SEQUENCE,0);
    ef92:	8f e1       	ldi	r24, 0x1F	; 31
    ef94:	60 e0       	ldi	r22, 0x00	; 0
    ef96:	0e 94 72 74 	call	0xe8e4	; 0xe8e4 <SendSlaveCommand>
			   stPumpType=ptSelectBrand;
	 		   break;
          case ptSelectBrand:
		       KeyPressed = _key_scan(1);
    ef9a:	81 e0       	ldi	r24, 0x01	; 1
    ef9c:	0e 94 84 ae 	call	0x15d08	; 0x15d08 <_key_scan>
		       KeyChar    = _key_btn(KeyPressed);
    efa0:	0e 94 e5 ad 	call	0x15bca	; 0x15bca <_key_btn>

			   if (KeyChar=='#'){
    efa4:	83 32       	cpi	r24, 0x23	; 35
    efa6:	09 f0       	breq	.+2      	; 0xefaa <FMenuPumpType+0xee>
    efa8:	2d c0       	rjmp	.+90     	; 0xf004 <FMenuPumpType+0x148>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    efaa:	e1 99       	sbic	0x1c, 1	; 28
    efac:	fe cf       	rjmp	.-4      	; 0xefaa <FMenuPumpType+0xee>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    efae:	07 e3       	ldi	r16, 0x37	; 55
    efb0:	11 e0       	ldi	r17, 0x01	; 1
    efb2:	1f bb       	out	0x1f, r17	; 31
    efb4:	0e bb       	out	0x1e, r16	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    efb6:	e0 9a       	sbi	0x1c, 0	; 28
    efb8:	8d b3       	in	r24, 0x1d	; 29
			       DispenserBrand=eeprom_read_byte(&DefDispenserBrand);
				   if (DispenserBrand<ST_WAYNE_DART)
    efba:	82 30       	cpi	r24, 0x02	; 2
    efbc:	20 f4       	brcc	.+8      	; 0xefc6 <FMenuPumpType+0x10a>
				        DispenserBrand++;
    efbe:	8f 5f       	subi	r24, 0xFF	; 255
    efc0:	80 93 51 01 	sts	0x0151, r24
    efc4:	02 c0       	rjmp	.+4      	; 0xefca <FMenuPumpType+0x10e>
				   else DispenserBrand=ST_NONE;
    efc6:	10 92 51 01 	sts	0x0151, r1
                   //Apply DecimalSetting  
				   SetDispenser(DispenserBrand);
    efca:	80 91 51 01 	lds	r24, 0x0151
    efce:	0e 94 5f 1a 	call	0x34be	; 0x34be <SetDispenser>

			       eeprom_write_byte(&DefDispenserBrand,DispenserBrand);
    efd2:	80 91 51 01 	lds	r24, 0x0151
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    efd6:	e1 99       	sbic	0x1c, 1	; 28
    efd8:	fe cf       	rjmp	.-4      	; 0xefd6 <FMenuPumpType+0x11a>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    efda:	1f bb       	out	0x1f, r17	; 31
    efdc:	0e bb       	out	0x1e, r16	; 30
#endif
    EEDR = __value;
    efde:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    efe0:	0f b6       	in	r0, 0x3f	; 63
    efe2:	f8 94       	cli
    efe4:	e2 9a       	sbi	0x1c, 2	; 28
    efe6:	e1 9a       	sbi	0x1c, 1	; 28
    efe8:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    efea:	e1 99       	sbic	0x1c, 1	; 28
    efec:	fe cf       	rjmp	.-4      	; 0xefea <FMenuPumpType+0x12e>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    efee:	1f bb       	out	0x1f, r17	; 31
    eff0:	0e bb       	out	0x1e, r16	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    eff2:	e0 9a       	sbi	0x1c, 0	; 28
    eff4:	6d b3       	in	r22, 0x1d	; 29
				   //SendPoolingCommand(SC_SET_PUMP_TYPE,eeprom_read_byte(&DefDispenserBrand));
				   SendSlaveCommand(SC_SET_PUMP_TYPE,eeprom_read_byte(&DefDispenserBrand));
    eff6:	8c e1       	ldi	r24, 0x1C	; 28
    eff8:	0e 94 72 74 	call	0xe8e4	; 0xe8e4 <SendSlaveCommand>
				   IsSetPumpType=True;//False;
    effc:	81 e0       	ldi	r24, 0x01	; 1
    effe:	80 93 13 01 	sts	0x0113, r24
    f002:	0c c0       	rjmp	.+24     	; 0xf01c <FMenuPumpType+0x160>
			       stPumpType=ptUpdated;			   
			   }else
			   if (KeyChar=='*'){
    f004:	8a 32       	cpi	r24, 0x2A	; 42
    f006:	09 f0       	breq	.+2      	; 0xf00a <FMenuPumpType+0x14e>
    f008:	c8 cf       	rjmp	.-112    	; 0xef9a <FMenuPumpType+0xde>
			       IsRunPumpType=False;
				   if (IFType==IT_STANDALONE)SendSlaveCommand(SC_START_POOL_SEQUENCE,0);
    f00a:	80 91 00 01 	lds	r24, 0x0100
    f00e:	82 30       	cpi	r24, 0x02	; 2
    f010:	51 f4       	brne	.+20     	; 0xf026 <FMenuPumpType+0x16a>
    f012:	80 e2       	ldi	r24, 0x20	; 32
    f014:	60 e0       	ldi	r22, 0x00	; 0
    f016:	0e 94 72 74 	call	0xe8e4	; 0xe8e4 <SendSlaveCommand>
    f01a:	05 c0       	rjmp	.+10     	; 0xf026 <FMenuPumpType+0x16a>
			   }
		       break;
          case ptUpdated:
		       if (IsSetPumpType==True){
    f01c:	80 91 13 01 	lds	r24, 0x0113
    f020:	81 30       	cpi	r24, 0x01	; 1
    f022:	e1 f7       	brne	.-8      	; 0xf01c <FMenuPumpType+0x160>
    f024:	5b cf       	rjmp	.-330    	; 0xeedc <FMenuPumpType+0x20>
			       stPumpType=ptInitMenu;
			   }
		       break;		         
	      }
	 }     
}
    f026:	a8 96       	adiw	r28, 0x28	; 40
    f028:	0f b6       	in	r0, 0x3f	; 63
    f02a:	f8 94       	cli
    f02c:	de bf       	out	0x3e, r29	; 62
    f02e:	0f be       	out	0x3f, r0	; 63
    f030:	cd bf       	out	0x3d, r28	; 61
    f032:	cf 91       	pop	r28
    f034:	df 91       	pop	r29
    f036:	1f 91       	pop	r17
    f038:	0f 91       	pop	r16
    f03a:	ff 90       	pop	r15
    f03c:	ef 90       	pop	r14
    f03e:	df 90       	pop	r13
    f040:	cf 90       	pop	r12
    f042:	08 95       	ret

0000f044 <FSettingPump>:
   return Result;
}

char FSettingPump(){
	 char __key,Result;
		lcd_clear();_delay_ms(10);
    f044:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
    f048:	84 ec       	ldi	r24, 0xC4	; 196
    f04a:	99 e0       	ldi	r25, 0x09	; 9
    f04c:	01 97       	sbiw	r24, 0x01	; 1
    f04e:	f1 f7       	brne	.-4      	; 0xf04c <FSettingPump+0x8>
		lcd_printf(1,1, PSTR("1)ID     "));
    f050:	81 e0       	ldi	r24, 0x01	; 1
    f052:	61 e0       	ldi	r22, 0x01	; 1
    f054:	46 ec       	ldi	r20, 0xC6	; 198
    f056:	51 e1       	ldi	r21, 0x11	; 17
    f058:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		lcd_printf(2,1, PSTR("2)Product"));
    f05c:	82 e0       	ldi	r24, 0x02	; 2
    f05e:	61 e0       	ldi	r22, 0x01	; 1
    f060:	4c eb       	ldi	r20, 0xBC	; 188
    f062:	51 e1       	ldi	r21, 0x11	; 17
    f064:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		if (IFType==IT_STANDALONE){
    f068:	80 91 00 01 	lds	r24, 0x0100
    f06c:	82 30       	cpi	r24, 0x02	; 2
    f06e:	61 f4       	brne	.+24     	; 0xf088 <FSettingPump+0x44>
		    lcd_printf(3,1, PSTR("3)Label  "));
    f070:	83 e0       	ldi	r24, 0x03	; 3
    f072:	61 e0       	ldi	r22, 0x01	; 1
    f074:	42 eb       	ldi	r20, 0xB2	; 178
    f076:	51 e1       	ldi	r21, 0x11	; 17
    f078:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		    lcd_printf(4,1, PSTR("4)Brand  *)Exit"));
    f07c:	84 e0       	ldi	r24, 0x04	; 4
    f07e:	61 e0       	ldi	r22, 0x01	; 1
    f080:	42 ea       	ldi	r20, 0xA2	; 162
    f082:	51 e1       	ldi	r21, 0x11	; 17
    f084:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		}

		while(1){
			__key = _key_scan(1);
    f088:	81 e0       	ldi	r24, 0x01	; 1
    f08a:	0e 94 84 ae 	call	0x15d08	; 0x15d08 <_key_scan>
			if(__key == _KEY_CANCEL)
    f08e:	87 3e       	cpi	r24, 0xE7	; 231
    f090:	d9 f0       	breq	.+54     	; 0xf0c8 <FSettingPump+0x84>
				break;
			if(__key == _KEY_1){
    f092:	8e 3e       	cpi	r24, 0xEE	; 238
    f094:	19 f4       	brne	.+6      	; 0xf09c <FSettingPump+0x58>
				_menu_pumpid();
    f096:	0e 94 2c 77 	call	0xee58	; 0xee58 <_menu_pumpid>
    f09a:	16 c0       	rjmp	.+44     	; 0xf0c8 <FSettingPump+0x84>
				break;
			}
			if(__key == _KEY_2){
    f09c:	8e 3d       	cpi	r24, 0xDE	; 222
    f09e:	19 f4       	brne	.+6      	; 0xf0a6 <FSettingPump+0x62>
				_menu_pumpprod();
    f0a0:	0e 94 cf 4a 	call	0x959e	; 0x959e <_menu_pumpprod>
    f0a4:	11 c0       	rjmp	.+34     	; 0xf0c8 <FSettingPump+0x84>
				break;
			}

			if((__key == _KEY_3)&&(IFType==IT_STANDALONE)){
    f0a6:	8e 3b       	cpi	r24, 0xBE	; 190
    f0a8:	39 f4       	brne	.+14     	; 0xf0b8 <FSettingPump+0x74>
    f0aa:	80 91 00 01 	lds	r24, 0x0100
    f0ae:	82 30       	cpi	r24, 0x02	; 2
    f0b0:	59 f7       	brne	.-42     	; 0xf088 <FSettingPump+0x44>
			    FMenuPumpLabel();
    f0b2:	0e 94 f8 4a 	call	0x95f0	; 0x95f0 <FMenuPumpLabel>
    f0b6:	08 c0       	rjmp	.+16     	; 0xf0c8 <FSettingPump+0x84>
				break;
			}
			if((__key == _KEY_4)&&(IFType==IT_STANDALONE)){
    f0b8:	8d 3e       	cpi	r24, 0xED	; 237
    f0ba:	31 f7       	brne	.-52     	; 0xf088 <FSettingPump+0x44>
    f0bc:	80 91 00 01 	lds	r24, 0x0100
    f0c0:	82 30       	cpi	r24, 0x02	; 2
    f0c2:	11 f7       	brne	.-60     	; 0xf088 <FSettingPump+0x44>
			    FMenuPumpType();
    f0c4:	0e 94 5e 77 	call	0xeebc	; 0xeebc <FMenuPumpType>

		}

	Result=MENU_DONE;
	return Result;
}
    f0c8:	81 e0       	ldi	r24, 0x01	; 1
    f0ca:	08 95       	ret

0000f0cc <InitializeConnection>:
void InitMemory(){
     PumpCountMax=eeprom_read_byte(&DefPoolingPumpMax);
	 ActivePump=eeprom_read_byte(&DefActivePump);
}

void InitializeConnection(){
    f0cc:	af 92       	push	r10
    f0ce:	bf 92       	push	r11
    f0d0:	cf 92       	push	r12
    f0d2:	df 92       	push	r13
    f0d4:	ef 92       	push	r14
    f0d6:	ff 92       	push	r15
    f0d8:	0f 93       	push	r16
    f0da:	1f 93       	push	r17
    f0dc:	df 93       	push	r29
    f0de:	cf 93       	push	r28
    f0e0:	cd b7       	in	r28, 0x3d	; 61
    f0e2:	de b7       	in	r29, 0x3e	; 62
    f0e4:	64 97       	sbiw	r28, 0x14	; 20
    f0e6:	0f b6       	in	r0, 0x3f	; 63
    f0e8:	f8 94       	cli
    f0ea:	de bf       	out	0x3e, r29	; 62
    f0ec:	0f be       	out	0x3f, r0	; 63
    f0ee:	cd bf       	out	0x3d, r28	; 61
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    f0f0:	e1 99       	sbic	0x1c, 1	; 28
    f0f2:	fe cf       	rjmp	.-4      	; 0xf0f0 <InitializeConnection+0x24>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    f0f4:	06 e3       	ldi	r16, 0x36	; 54
    f0f6:	a0 2e       	mov	r10, r16
    f0f8:	01 e0       	ldi	r16, 0x01	; 1
    f0fa:	b0 2e       	mov	r11, r16
    f0fc:	bf ba       	out	0x1f, r11	; 31
    f0fe:	ae ba       	out	0x1e, r10	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    f100:	e0 9a       	sbi	0x1c, 0	; 28
    f102:	9d b3       	in	r25, 0x1d	; 29
	unsigned int tConnect=0;
	char ForceType=IT_NONE,iCon=0,iTry=0;
	char lcdteks[20];
	IFType=eeprom_read_byte(&DefInitIFT);
    f104:	90 93 00 01 	sts	0x0100, r25
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    f108:	e1 99       	sbic	0x1c, 1	; 28
    f10a:	fe cf       	rjmp	.-4      	; 0xf108 <InitializeConnection+0x3c>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    f10c:	17 e3       	ldi	r17, 0x37	; 55
    f10e:	c1 2e       	mov	r12, r17
    f110:	11 e0       	ldi	r17, 0x01	; 1
    f112:	d1 2e       	mov	r13, r17
    f114:	df ba       	out	0x1f, r13	; 31
    f116:	ce ba       	out	0x1e, r12	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    f118:	e0 9a       	sbi	0x1c, 0	; 28
    f11a:	8d b3       	in	r24, 0x1d	; 29
	DispenserBrand=eeprom_read_byte(&DefDispenserBrand);
    f11c:	80 93 51 01 	sts	0x0151, r24

	//SendSlaveCommand(SC_STOP_POOL_SEQUENCE,0);

    //Send Msg10
	if  (IFType==IT_SLAVE){
    f120:	91 30       	cpi	r25, 0x01	; 1
    f122:	09 f0       	breq	.+2      	; 0xf126 <InitializeConnection+0x5a>
    f124:	59 c0       	rjmp	.+178    	; 0xf1d8 <InitializeConnection+0x10c>
	     SendSlaveCommand(SC_SLAVE,ST_NONE);
    f126:	81 e0       	ldi	r24, 0x01	; 1
    f128:	60 e0       	ldi	r22, 0x00	; 0
    f12a:	0e 94 72 74 	call	0xe8e4	; 0xe8e4 <SendSlaveCommand>
		 char_count=0;
    f12e:	10 92 8d 01 	sts	0x018D, r1
    f132:	10 92 8c 01 	sts	0x018C, r1
		 if (IsPowerOn==True){
    f136:	80 91 c9 03 	lds	r24, 0x03C9
    f13a:	81 30       	cpi	r24, 0x01	; 1
    f13c:	59 f4       	brne	.+22     	; 0xf154 <InitializeConnection+0x88>
		     IsPowerOn=False;
    f13e:	10 92 c9 03 	sts	0x03C9, r1
    f142:	80 e5       	ldi	r24, 0x50	; 80
    f144:	93 ec       	ldi	r25, 0xC3	; 195
    f146:	29 e1       	ldi	r18, 0x19	; 25
    f148:	30 e0       	ldi	r19, 0x00	; 0
    f14a:	f9 01       	movw	r30, r18
    f14c:	31 97       	sbiw	r30, 0x01	; 1
    f14e:	f1 f7       	brne	.-4      	; 0xf14c <InitializeConnection+0x80>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    f150:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    f152:	d9 f7       	brne	.-10     	; 0xf14a <InitializeConnection+0x7e>
		     _delay_ms(5000);
			 }
         sendMessage10();
    f154:	0e 94 ff 52 	call	0xa5fe	; 0xa5fe <sendMessage10>
         lcd_printf(4,1,PSTR("Connect         "));
    f158:	84 e0       	ldi	r24, 0x04	; 4
    f15a:	61 e0       	ldi	r22, 0x01	; 1
    f15c:	44 ec       	ldi	r20, 0xC4	; 196
    f15e:	5c e1       	ldi	r21, 0x1C	; 28
    f160:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		 lcd_printf(4,1,PSTR("Connect"));
    f164:	84 e0       	ldi	r24, 0x04	; 4
    f166:	61 e0       	ldi	r22, 0x01	; 1
    f168:	4c eb       	ldi	r20, 0xBC	; 188
    f16a:	5c e1       	ldi	r21, 0x1C	; 28
    f16c:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		 //EstablishConnection TCP/IP
		 IsMessage11=False;
    f170:	10 92 a3 01 	sts	0x01A3, r1
    f174:	ee 24       	eor	r14, r14
    f176:	ff 24       	eor	r15, r15
    f178:	10 e0       	ldi	r17, 0x00	; 0
    f17a:	00 e0       	ldi	r16, 0x00	; 0
    f17c:	29 c0       	rjmp	.+82     	; 0xf1d0 <InitializeConnection+0x104>
		  //SlaveIdentification		  
		 while (IsMessage11==False){
		        lcd_put(4,(8+iCon),'.');
    f17e:	61 2f       	mov	r22, r17
    f180:	68 5f       	subi	r22, 0xF8	; 248
    f182:	84 e0       	ldi	r24, 0x04	; 4
    f184:	4e e2       	ldi	r20, 0x2E	; 46
    f186:	0e 94 58 ad 	call	0x15ab0	; 0x15ab0 <lcd_put>
                tConnect++;
    f18a:	08 94       	sec
    f18c:	e1 1c       	adc	r14, r1
    f18e:	f1 1c       	adc	r15, r1
			    if ((tConnect%800)==0)iCon++;
    f190:	c7 01       	movw	r24, r14
    f192:	60 e2       	ldi	r22, 0x20	; 32
    f194:	73 e0       	ldi	r23, 0x03	; 3
    f196:	0e 94 0a b7 	call	0x16e14	; 0x16e14 <__udivmodhi4>
    f19a:	89 2b       	or	r24, r25
    f19c:	09 f4       	brne	.+2      	; 0xf1a0 <InitializeConnection+0xd4>
    f19e:	1f 5f       	subi	r17, 0xFF	; 255
			    if (iCon>8){
    f1a0:	19 30       	cpi	r17, 0x09	; 9
    f1a2:	70 f0       	brcs	.+28     	; 0xf1c0 <InitializeConnection+0xf4>
			        lcd_printf(4,1,PSTR("Connect         "));
    f1a4:	84 e0       	ldi	r24, 0x04	; 4
    f1a6:	61 e0       	ldi	r22, 0x01	; 1
    f1a8:	4b ea       	ldi	r20, 0xAB	; 171
    f1aa:	5c e1       	ldi	r21, 0x1C	; 28
    f1ac:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
				    sendMessage10();
    f1b0:	0e 94 ff 52 	call	0xa5fe	; 0xa5fe <sendMessage10>
				    SendSlaveCommand(SC_SLAVE,ST_NONE);
    f1b4:	81 e0       	ldi	r24, 0x01	; 1
    f1b6:	60 e0       	ldi	r22, 0x00	; 0
    f1b8:	0e 94 72 74 	call	0xe8e4	; 0xe8e4 <SendSlaveCommand>
			        iCon=0;
				    iTry++;}
    f1bc:	0f 5f       	subi	r16, 0xFF	; 255
    f1be:	10 e0       	ldi	r17, 0x00	; 0
			    if (iTry>3){
    f1c0:	04 30       	cpi	r16, 0x04	; 4
    f1c2:	30 f0       	brcs	.+12     	; 0xf1d0 <InitializeConnection+0x104>
			        //IsErrorTCPIP=True;
				    IsAdvanzStartupInfo=False;		
    f1c4:	10 92 ad 01 	sts	0x01AD, r1
					IFType=IT_STANDALONE;
    f1c8:	82 e0       	ldi	r24, 0x02	; 2
    f1ca:	80 93 00 01 	sts	0x0100, r24
    f1ce:	04 c0       	rjmp	.+8      	; 0xf1d8 <InitializeConnection+0x10c>
         lcd_printf(4,1,PSTR("Connect         "));
		 lcd_printf(4,1,PSTR("Connect"));
		 //EstablishConnection TCP/IP
		 IsMessage11=False;
		  //SlaveIdentification		  
		 while (IsMessage11==False){
    f1d0:	80 91 a3 01 	lds	r24, 0x01A3
    f1d4:	88 23       	and	r24, r24
    f1d6:	99 f2       	breq	.-90     	; 0xf17e <InitializeConnection+0xb2>
				    break;
			    }
            }//EndWhile
		}

	if (IFType==IT_STANDALONE){
    f1d8:	80 91 00 01 	lds	r24, 0x0100
    f1dc:	82 30       	cpi	r24, 0x02	; 2
    f1de:	09 f0       	breq	.+2      	; 0xf1e2 <InitializeConnection+0x116>
    f1e0:	72 c0       	rjmp	.+228    	; 0xf2c6 <InitializeConnection+0x1fa>
        IsStandAloneDetected=False;		
    f1e2:	10 92 9f 01 	sts	0x019F, r1
		SendSlaveCommand(SC_STANDALONE,DispenserBrand);
    f1e6:	60 91 51 01 	lds	r22, 0x0151
    f1ea:	0e 94 72 74 	call	0xe8e4	; 0xe8e4 <SendSlaveCommand>
		tConnect=0,iCon=0,iTry=0;
	    lcd_clear();
    f1ee:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
	    lcd_printf(1,1,PSTR("Scan Pump"));
    f1f2:	81 e0       	ldi	r24, 0x01	; 1
    f1f4:	61 e0       	ldi	r22, 0x01	; 1
    f1f6:	41 ea       	ldi	r20, 0xA1	; 161
    f1f8:	5c e1       	ldi	r21, 0x1C	; 28
    f1fa:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    f1fe:	e1 99       	sbic	0x1c, 1	; 28
    f200:	fe cf       	rjmp	.-4      	; 0xf1fe <InitializeConnection+0x132>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    f202:	df ba       	out	0x1f, r13	; 31
    f204:	ce ba       	out	0x1e, r12	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    f206:	e0 9a       	sbi	0x1c, 0	; 28
    f208:	8d b3       	in	r24, 0x1d	; 29
		strcpy_P(lcdteks,(PGM_P)pgm_read_word(&(DefListDispenserName[eeprom_read_byte(&DefDispenserBrand)])));
    f20a:	e8 2f       	mov	r30, r24
    f20c:	f0 e0       	ldi	r31, 0x00	; 0
    f20e:	ee 0f       	add	r30, r30
    f210:	ff 1f       	adc	r31, r31
    f212:	eb 50       	subi	r30, 0x0B	; 11
    f214:	fd 4f       	sbci	r31, 0xFD	; 253
    f216:	65 91       	lpm	r22, Z+
    f218:	74 91       	lpm	r23, Z+
    f21a:	8e 01       	movw	r16, r28
    f21c:	0f 5f       	subi	r16, 0xFF	; 255
    f21e:	1f 4f       	sbci	r17, 0xFF	; 255
    f220:	c8 01       	movw	r24, r16
    f222:	0e 94 e1 b3 	call	0x167c2	; 0x167c2 <strcpy_P>
		sprintf_P(lcdteks,PSTR("%s"),lcdteks);
    f226:	00 d0       	rcall	.+0      	; 0xf228 <InitializeConnection+0x15c>
    f228:	00 d0       	rcall	.+0      	; 0xf22a <InitializeConnection+0x15e>
    f22a:	00 d0       	rcall	.+0      	; 0xf22c <InitializeConnection+0x160>
    f22c:	ed b7       	in	r30, 0x3d	; 61
    f22e:	fe b7       	in	r31, 0x3e	; 62
    f230:	31 96       	adiw	r30, 0x01	; 1
    f232:	ad b7       	in	r26, 0x3d	; 61
    f234:	be b7       	in	r27, 0x3e	; 62
    f236:	12 96       	adiw	r26, 0x02	; 2
    f238:	1c 93       	st	X, r17
    f23a:	0e 93       	st	-X, r16
    f23c:	11 97       	sbiw	r26, 0x01	; 1
    f23e:	8e e9       	ldi	r24, 0x9E	; 158
    f240:	9c e1       	ldi	r25, 0x1C	; 28
    f242:	93 83       	std	Z+3, r25	; 0x03
    f244:	82 83       	std	Z+2, r24	; 0x02
    f246:	15 83       	std	Z+5, r17	; 0x05
    f248:	04 83       	std	Z+4, r16	; 0x04
    f24a:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
	    lcd_print(2,1,lcdteks);
    f24e:	8d b7       	in	r24, 0x3d	; 61
    f250:	9e b7       	in	r25, 0x3e	; 62
    f252:	06 96       	adiw	r24, 0x06	; 6
    f254:	0f b6       	in	r0, 0x3f	; 63
    f256:	f8 94       	cli
    f258:	9e bf       	out	0x3e, r25	; 62
    f25a:	0f be       	out	0x3f, r0	; 63
    f25c:	8d bf       	out	0x3d, r24	; 61
    f25e:	82 e0       	ldi	r24, 0x02	; 2
    f260:	61 e0       	ldi	r22, 0x01	; 1
    f262:	a8 01       	movw	r20, r16
    f264:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
    f268:	00 e0       	ldi	r16, 0x00	; 0
    f26a:	10 e0       	ldi	r17, 0x00	; 0
    f26c:	ff 24       	eor	r15, r15
    f26e:	dd 24       	eor	r13, r13
    f270:	26 c0       	rjmp	.+76     	; 0xf2be <InitializeConnection+0x1f2>

	    while (IsStandAloneDetected==False){
		       lcd_put(4,(1+iCon),'.');
    f272:	ef 2c       	mov	r14, r15
    f274:	e3 94       	inc	r14
    f276:	84 e0       	ldi	r24, 0x04	; 4
    f278:	6e 2d       	mov	r22, r14
    f27a:	4e e2       	ldi	r20, 0x2E	; 46
    f27c:	0e 94 58 ad 	call	0x15ab0	; 0x15ab0 <lcd_put>
		       tConnect++;
    f280:	0f 5f       	subi	r16, 0xFF	; 255
    f282:	1f 4f       	sbci	r17, 0xFF	; 255
		       if ((tConnect%100)==0)iCon++;
    f284:	c8 01       	movw	r24, r16
    f286:	64 e6       	ldi	r22, 0x64	; 100
    f288:	70 e0       	ldi	r23, 0x00	; 0
    f28a:	0e 94 0a b7 	call	0x16e14	; 0x16e14 <__udivmodhi4>
    f28e:	89 2b       	or	r24, r25
    f290:	09 f4       	brne	.+2      	; 0xf294 <InitializeConnection+0x1c8>
    f292:	fe 2c       	mov	r15, r14
		       if (iCon>16){
    f294:	90 e1       	ldi	r25, 0x10	; 16
    f296:	9f 15       	cp	r25, r15
    f298:	78 f4       	brcc	.+30     	; 0xf2b8 <InitializeConnection+0x1ec>
			       lcd_printf(4,1,PSTR("                   "));
    f29a:	84 e0       	ldi	r24, 0x04	; 4
    f29c:	61 e0       	ldi	r22, 0x01	; 1
    f29e:	4a e8       	ldi	r20, 0x8A	; 138
    f2a0:	5c e1       	ldi	r21, 0x1C	; 28
    f2a2:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
				   //IsStandaloneAcknoledge=False;
		           SendSlaveCommand(SC_STANDALONE,DispenserBrand);
    f2a6:	82 e0       	ldi	r24, 0x02	; 2
    f2a8:	60 91 51 01 	lds	r22, 0x0151
    f2ac:	0e 94 72 74 	call	0xe8e4	; 0xe8e4 <SendSlaveCommand>
                   //InitStandalone();

			       DisplayPumpStatus();
    f2b0:	0e 94 97 44 	call	0x892e	; 0x892e <DisplayPumpStatus>
			       iCon=0;
			       iTry++;}
    f2b4:	d3 94       	inc	r13
    f2b6:	ff 24       	eor	r15, r15
		           if (iTry>3) break; 
    f2b8:	a3 e0       	ldi	r26, 0x03	; 3
    f2ba:	ad 15       	cp	r26, r13
    f2bc:	20 f0       	brcs	.+8      	; 0xf2c6 <InitializeConnection+0x1fa>
	    lcd_printf(1,1,PSTR("Scan Pump"));
		strcpy_P(lcdteks,(PGM_P)pgm_read_word(&(DefListDispenserName[eeprom_read_byte(&DefDispenserBrand)])));
		sprintf_P(lcdteks,PSTR("%s"),lcdteks);
	    lcd_print(2,1,lcdteks);

	    while (IsStandAloneDetected==False){
    f2be:	80 91 9f 01 	lds	r24, 0x019F
    f2c2:	88 23       	and	r24, r24
    f2c4:	b1 f2       	breq	.-84     	; 0xf272 <InitializeConnection+0x1a6>
			       iCon=0;
			       iTry++;}
		           if (iTry>3) break; 
	    }
	}//EndIf
	if(IsMessage11==True){
    f2c6:	80 91 a3 01 	lds	r24, 0x01A3
    f2ca:	81 30       	cpi	r24, 0x01	; 1
    f2cc:	b9 f4       	brne	.+46     	; 0xf2fc <InitializeConnection+0x230>
	   lcd_printf(4,1,PSTR("Connected"));
    f2ce:	84 e0       	ldi	r24, 0x04	; 4
    f2d0:	61 e0       	ldi	r22, 0x01	; 1
    f2d2:	40 e8       	ldi	r20, 0x80	; 128
    f2d4:	5c e1       	ldi	r21, 0x1C	; 28
    f2d6:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    f2da:	e1 99       	sbic	0x1c, 1	; 28
    f2dc:	fe cf       	rjmp	.-4      	; 0xf2da <InitializeConnection+0x20e>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    f2de:	bf ba       	out	0x1f, r11	; 31
    f2e0:	ae ba       	out	0x1e, r10	; 30
#endif
    EEDR = __value;
    f2e2:	11 e0       	ldi	r17, 0x01	; 1
    f2e4:	1d bb       	out	0x1d, r17	; 29

    __asm__ __volatile__ (
    f2e6:	0f b6       	in	r0, 0x3f	; 63
    f2e8:	f8 94       	cli
    f2ea:	e2 9a       	sbi	0x1c, 2	; 28
    f2ec:	e1 9a       	sbi	0x1c, 1	; 28
    f2ee:	0f be       	out	0x3f, r0	; 63
	   eeprom_write_byte(&DefInitIFT,IT_SLAVE);
	   IFType=IT_SLAVE;
    f2f0:	10 93 00 01 	sts	0x0100, r17
	   //IsErrorTCPIP=False;
	   procMessage11();
    f2f4:	0e 94 2f 5f 	call	0xbe5e	; 0xbe5e <procMessage11>
	   IsAdvanzStartupInfo=True;
    f2f8:	10 93 ad 01 	sts	0x01AD, r17
	}
	if(IsStandAloneDetected==True){
    f2fc:	80 91 9f 01 	lds	r24, 0x019F
    f300:	81 30       	cpi	r24, 0x01	; 1
    f302:	99 f4       	brne	.+38     	; 0xf32a <InitializeConnection+0x25e>
	   lcd_printf(4,1,PSTR("PumpFound"));
    f304:	84 e0       	ldi	r24, 0x04	; 4
    f306:	61 e0       	ldi	r22, 0x01	; 1
    f308:	46 e7       	ldi	r20, 0x76	; 118
    f30a:	5c e1       	ldi	r21, 0x1C	; 28
    f30c:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    f310:	e1 99       	sbic	0x1c, 1	; 28
    f312:	fe cf       	rjmp	.-4      	; 0xf310 <InitializeConnection+0x244>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    f314:	bf ba       	out	0x1f, r11	; 31
    f316:	ae ba       	out	0x1e, r10	; 30
#endif
    EEDR = __value;
    f318:	82 e0       	ldi	r24, 0x02	; 2
    f31a:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    f31c:	0f b6       	in	r0, 0x3f	; 63
    f31e:	f8 94       	cli
    f320:	e2 9a       	sbi	0x1c, 2	; 28
    f322:	e1 9a       	sbi	0x1c, 1	; 28
    f324:	0f be       	out	0x3f, r0	; 63
	   eeprom_write_byte(&DefInitIFT,IT_STANDALONE);
	   IFType=IT_STANDALONE;
    f326:	80 93 00 01 	sts	0x0100, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    f32a:	e1 99       	sbic	0x1c, 1	; 28
    f32c:	fe cf       	rjmp	.-4      	; 0xf32a <InitializeConnection+0x25e>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    f32e:	85 e3       	ldi	r24, 0x35	; 53
    f330:	91 e0       	ldi	r25, 0x01	; 1
    f332:	9f bb       	out	0x1f, r25	; 31
    f334:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    f336:	e0 9a       	sbi	0x1c, 0	; 28
    f338:	8d b3       	in	r24, 0x1d	; 29
	}
	//PrintStatus
	if (eeprom_read_byte(&DefPrintInitialize)==True)GeneratePrintInit();
    f33a:	81 30       	cpi	r24, 0x01	; 1
    f33c:	11 f4       	brne	.+4      	; 0xf342 <InitializeConnection+0x276>
    f33e:	0e 94 92 32 	call	0x6524	; 0x6524 <GeneratePrintInit>
	if ((IsStandAloneDetected==False)&&(IsMessage11==False)){		
    f342:	80 91 9f 01 	lds	r24, 0x019F
    f346:	88 23       	and	r24, r24
    f348:	09 f0       	breq	.+2      	; 0xf34c <InitializeConnection+0x280>
    f34a:	38 c0       	rjmp	.+112    	; 0xf3bc <InitializeConnection+0x2f0>
    f34c:	80 91 a3 01 	lds	r24, 0x01A3
    f350:	88 23       	and	r24, r24
    f352:	09 f0       	breq	.+2      	; 0xf356 <InitializeConnection+0x28a>
    f354:	33 c0       	rjmp	.+102    	; 0xf3bc <InitializeConnection+0x2f0>
		 lcd_printf(2,1,PSTR("TCP/IP Error"));
    f356:	82 e0       	ldi	r24, 0x02	; 2
    f358:	61 e0       	ldi	r22, 0x01	; 1
    f35a:	49 e6       	ldi	r20, 0x69	; 105
    f35c:	5c e1       	ldi	r21, 0x1C	; 28
    f35e:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		 lcd_printf(3,1,PSTR("No Pump Found"));
    f362:	83 e0       	ldi	r24, 0x03	; 3
    f364:	61 e0       	ldi	r22, 0x01	; 1
    f366:	4b e5       	ldi	r20, 0x5B	; 91
    f368:	5c e1       	ldi	r21, 0x1C	; 28
    f36a:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
    f36e:	80 e2       	ldi	r24, 0x20	; 32
    f370:	9e e4       	ldi	r25, 0x4E	; 78
    f372:	29 e1       	ldi	r18, 0x19	; 25
    f374:	30 e0       	ldi	r19, 0x00	; 0
    f376:	f9 01       	movw	r30, r18
    f378:	31 97       	sbiw	r30, 0x01	; 1
    f37a:	f1 f7       	brne	.-4      	; 0xf378 <InitializeConnection+0x2ac>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    f37c:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    f37e:	d9 f7       	brne	.-10     	; 0xf376 <InitializeConnection+0x2aa>
		 _delay_ms(2000);
		 ForceType=systemForceType();
    f380:	0e 94 06 4c 	call	0x980c	; 0x980c <systemForceType>
		 if (ForceType=='1'){
    f384:	81 33       	cpi	r24, 0x31	; 49
    f386:	29 f4       	brne	.+10     	; 0xf392 <InitializeConnection+0x2c6>
		     IFType=IT_SLAVE;
    f388:	81 e0       	ldi	r24, 0x01	; 1
    f38a:	80 93 00 01 	sts	0x0100, r24
			 SendSlaveCommand(SC_SLAVE,ST_NONE);
    f38e:	60 e0       	ldi	r22, 0x00	; 0
    f390:	07 c0       	rjmp	.+14     	; 0xf3a0 <InitializeConnection+0x2d4>
         }
		 else
		 if (ForceType=='2'){
    f392:	82 33       	cpi	r24, 0x32	; 50
    f394:	39 f4       	brne	.+14     	; 0xf3a4 <InitializeConnection+0x2d8>
		     IFType=IT_STANDALONE;
    f396:	82 e0       	ldi	r24, 0x02	; 2
    f398:	80 93 00 01 	sts	0x0100, r24
			 SendSlaveCommand(SC_STANDALONE,DispenserBrand);
    f39c:	60 91 51 01 	lds	r22, 0x0151
    f3a0:	0e 94 72 74 	call	0xe8e4	; 0xe8e4 <SendSlaveCommand>

			 //SendPoolingCommand(SC_SET_POOLING_MAX_PUMP,eeprom_read_byte(&DefPoolingPumpMax));

			 //InitStandalone();
         }
		 eeprom_write_byte(&DefInitIFT,IFType);
    f3a4:	80 91 00 01 	lds	r24, 0x0100
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    f3a8:	e1 99       	sbic	0x1c, 1	; 28
    f3aa:	fe cf       	rjmp	.-4      	; 0xf3a8 <InitializeConnection+0x2dc>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    f3ac:	bf ba       	out	0x1f, r11	; 31
    f3ae:	ae ba       	out	0x1e, r10	; 30
#endif
    EEDR = __value;
    f3b0:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    f3b2:	0f b6       	in	r0, 0x3f	; 63
    f3b4:	f8 94       	cli
    f3b6:	e2 9a       	sbi	0x1c, 2	; 28
    f3b8:	e1 9a       	sbi	0x1c, 1	; 28
    f3ba:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    f3bc:	e1 99       	sbic	0x1c, 1	; 28
    f3be:	fe cf       	rjmp	.-4      	; 0xf3bc <InitializeConnection+0x2f0>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    f3c0:	84 e4       	ldi	r24, 0x44	; 68
    f3c2:	91 e0       	ldi	r25, 0x01	; 1
    f3c4:	9f bb       	out	0x1f, r25	; 31
    f3c6:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    f3c8:	e0 9a       	sbi	0x1c, 0	; 28
    f3ca:	8d b3       	in	r24, 0x1d	; 29

	 }
}

void InitMemory(){
     PumpCountMax=eeprom_read_byte(&DefPoolingPumpMax);
    f3cc:	80 93 4f 01 	sts	0x014F, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    f3d0:	e1 99       	sbic	0x1c, 1	; 28
    f3d2:	fe cf       	rjmp	.-4      	; 0xf3d0 <InitializeConnection+0x304>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    f3d4:	89 e4       	ldi	r24, 0x49	; 73
    f3d6:	91 e0       	ldi	r25, 0x01	; 1
    f3d8:	9f bb       	out	0x1f, r25	; 31
    f3da:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    f3dc:	e0 9a       	sbi	0x1c, 0	; 28
    f3de:	8d b3       	in	r24, 0x1d	; 29
	 ActivePump=eeprom_read_byte(&DefActivePump);
    f3e0:	80 93 50 01 	sts	0x0150, r24
         }
		 eeprom_write_byte(&DefInitIFT,IFType);
	}
	InitMemory();
	//SendSlaveCommand(SC_START_POOL_SEQUENCE,0);
}
    f3e4:	64 96       	adiw	r28, 0x14	; 20
    f3e6:	0f b6       	in	r0, 0x3f	; 63
    f3e8:	f8 94       	cli
    f3ea:	de bf       	out	0x3e, r29	; 62
    f3ec:	0f be       	out	0x3f, r0	; 63
    f3ee:	cd bf       	out	0x3d, r28	; 61
    f3f0:	cf 91       	pop	r28
    f3f2:	df 91       	pop	r29
    f3f4:	1f 91       	pop	r17
    f3f6:	0f 91       	pop	r16
    f3f8:	ff 90       	pop	r15
    f3fa:	ef 90       	pop	r14
    f3fc:	df 90       	pop	r13
    f3fe:	cf 90       	pop	r12
    f400:	bf 90       	pop	r11
    f402:	af 90       	pop	r10
    f404:	08 95       	ret

0000f406 <StoreStandaloneTransData>:
     SendSlaveCommand(SC_TOTALIZER_ACK,iPumpID);
	 UpdateStandaloneStatus((iPumpID&0x0F),PS_TOTALIZER);	 
}
         
			                                         //      STX     MSGID  PumpID              6        8        8
void StoreStandaloneTransData(char *strRawTransData){//  [0x50,0x05]  01      01      1       004500   00000200  00000012 [0x06,0x60] = 24
    f406:	2f 92       	push	r2
    f408:	3f 92       	push	r3
    f40a:	4f 92       	push	r4
    f40c:	5f 92       	push	r5
    f40e:	6f 92       	push	r6
    f410:	7f 92       	push	r7
    f412:	8f 92       	push	r8
    f414:	9f 92       	push	r9
    f416:	af 92       	push	r10
    f418:	bf 92       	push	r11
    f41a:	cf 92       	push	r12
    f41c:	df 92       	push	r13
    f41e:	ef 92       	push	r14
    f420:	ff 92       	push	r15
    f422:	0f 93       	push	r16
    f424:	1f 93       	push	r17
    f426:	df 93       	push	r29
    f428:	cf 93       	push	r28
    f42a:	cd b7       	in	r28, 0x3d	; 61
    f42c:	de b7       	in	r29, 0x3e	; 62
    f42e:	e1 97       	sbiw	r28, 0x31	; 49
    f430:	0f b6       	in	r0, 0x3f	; 63
    f432:	f8 94       	cli
    f434:	de bf       	out	0x3e, r29	; 62
    f436:	0f be       	out	0x3f, r0	; 63
    f438:	cd bf       	out	0x3d, r28	; 61
    f43a:	7c 01       	movw	r14, r24
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    f43c:	dc 01       	movw	r26, r24
    f43e:	12 96       	adiw	r26, 0x02	; 2
    f440:	8c 91       	ld	r24, X
    f442:	12 97       	sbiw	r26, 0x02	; 2
    f444:	89 83       	std	Y+1, r24	; 0x01
    f446:	13 96       	adiw	r26, 0x03	; 3
    f448:	8c 91       	ld	r24, X
    f44a:	8a 83       	std	Y+2, r24	; 0x02
	 }Dest[Length]=0;
    f44c:	1b 82       	std	Y+3, r1	; 0x03
	 char strSend[30];
	 char TransDigit;
	 char FIPAddr;
      
	 StrPosCopy(strRawTransData,strPumpID,2,2);
	 RemZeroLead(strPumpID);
    f44e:	8e 01       	movw	r16, r28
    f450:	0f 5f       	subi	r16, 0xFF	; 255
    f452:	1f 4f       	sbci	r17, 0xFF	; 255
    f454:	c8 01       	movw	r24, r16
    f456:	0e 94 19 25 	call	0x4a32	; 0x4a32 <RemZeroLead>
	 iPumpID=atoi(strPumpID); 
    f45a:	c8 01       	movw	r24, r16
    f45c:	0e 94 c3 b3 	call	0x16786	; 0x16786 <atoi>
    f460:	38 2e       	mov	r3, r24
	 
	 FIPAddr=GetFIPAddr(iPumpID);
    f462:	0e 94 41 1d 	call	0x3a82	; 0x3a82 <GetFIPAddr>
    f466:	d8 2e       	mov	r13, r24
	 if (FIPAddr>0){
    f468:	88 23       	and	r24, r24
    f46a:	09 f4       	brne	.+2      	; 0xf46e <StoreStandaloneTransData+0x68>
    f46c:	1a c2       	rjmp	.+1076   	; 0xf8a2 <StoreStandaloneTransData+0x49c>
	    Dest[IdxSource+i]=Source[i];
	 }Dest[IdxSource+Length]=0;
}
char CharPosCopy(char *Source, unsigned int IdxSource){
     char Result;
     Result=Source[IdxSource];
    f46e:	f7 01       	movw	r30, r14
    f470:	f4 81       	ldd	r31, Z+4	; 0x04
    f472:	f9 ab       	std	Y+49, r31	; 0x31

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    f474:	d7 01       	movw	r26, r14
    f476:	15 96       	adiw	r26, 0x05	; 5
    f478:	2c 90       	ld	r2, X
    f47a:	34 e0       	ldi	r19, 0x04	; 4
    f47c:	83 2e       	mov	r8, r19
    f47e:	91 2c       	mov	r9, r1
    f480:	8c 0e       	add	r8, r28
    f482:	9d 1e       	adc	r9, r29
    f484:	f4 01       	movw	r30, r8
    f486:	ce 01       	movw	r24, r28
    f488:	0b 96       	adiw	r24, 0x0b	; 11
	     strMemory[i]=data;
    f48a:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    f48c:	e8 17       	cp	r30, r24
    f48e:	f9 07       	cpc	r31, r25
    f490:	e1 f7       	brne	.-8      	; 0xf48a <StoreStandaloneTransData+0x84>
    f492:	2d e1       	ldi	r18, 0x1D	; 29
    f494:	62 2e       	mov	r6, r18
    f496:	71 2c       	mov	r7, r1
    f498:	6c 0e       	add	r6, r28
    f49a:	7d 1e       	adc	r7, r29
    f49c:	93 01       	movw	r18, r6
	     strMemory[i]=data;
    f49e:	ce 01       	movw	r24, r28
    f4a0:	87 96       	adiw	r24, 0x27	; 39
    f4a2:	f9 01       	movw	r30, r18
    f4a4:	11 92       	st	Z+, r1
    f4a6:	9f 01       	movw	r18, r30

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    f4a8:	e8 17       	cp	r30, r24
    f4aa:	f9 07       	cpc	r31, r25
    f4ac:	d1 f7       	brne	.-12     	; 0xf4a2 <StoreStandaloneTransData+0x9c>
    f4ae:	2f 01       	movw	r4, r30
	     strMemory[i]=data;
    f4b0:	ce 01       	movw	r24, r28
    f4b2:	c1 96       	adiw	r24, 0x31	; 49
    f4b4:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    f4b6:	e8 17       	cp	r30, r24
    f4b8:	f9 07       	cpc	r31, r25
    f4ba:	e1 f7       	brne	.-8      	; 0xf4b4 <StoreStandaloneTransData+0xae>
    f4bc:	a7 01       	movw	r20, r14
    f4be:	d7 01       	movw	r26, r14
    f4c0:	f4 01       	movw	r30, r8
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f4c2:	be 01       	movw	r22, r28
    f4c4:	66 5f       	subi	r22, 0xF6	; 246
    f4c6:	7f 4f       	sbci	r23, 0xFF	; 255
	    Dest[i]=Source[IdxSource+i];
    f4c8:	16 96       	adiw	r26, 0x06	; 6
    f4ca:	8c 91       	ld	r24, X
    f4cc:	16 97       	sbiw	r26, 0x06	; 6
    f4ce:	81 93       	st	Z+, r24
    f4d0:	11 96       	adiw	r26, 0x01	; 1
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f4d2:	e6 17       	cp	r30, r22
    f4d4:	f7 07       	cpc	r31, r23
    f4d6:	c1 f7       	brne	.-16     	; 0xf4c8 <StoreStandaloneTransData+0xc2>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f4d8:	1a 86       	std	Y+10, r1	; 0x0a
    f4da:	d7 01       	movw	r26, r14
    f4dc:	f3 01       	movw	r30, r6
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f4de:	be 01       	movw	r22, r28
    f4e0:	6b 5d       	subi	r22, 0xDB	; 219
    f4e2:	7f 4f       	sbci	r23, 0xFF	; 255
	    Dest[i]=Source[IdxSource+i];
    f4e4:	1c 96       	adiw	r26, 0x0c	; 12
    f4e6:	8c 91       	ld	r24, X
    f4e8:	1c 97       	sbiw	r26, 0x0c	; 12
    f4ea:	81 93       	st	Z+, r24
    f4ec:	11 96       	adiw	r26, 0x01	; 1
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f4ee:	e6 17       	cp	r30, r22
    f4f0:	f7 07       	cpc	r31, r23
    f4f2:	c1 f7       	brne	.-16     	; 0xf4e4 <StoreStandaloneTransData+0xde>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f4f4:	1d a2       	std	Y+37, r1	; 0x25
    f4f6:	f9 01       	movw	r30, r18
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f4f8:	be 01       	movw	r22, r28
    f4fa:	69 5d       	subi	r22, 0xD9	; 217
    f4fc:	7f 4f       	sbci	r23, 0xFF	; 255
    f4fe:	9e 01       	movw	r18, r28
    f500:	21 5d       	subi	r18, 0xD1	; 209
    f502:	3f 4f       	sbci	r19, 0xFF	; 255
	    Dest[i]=Source[IdxSource+i];
    f504:	da 01       	movw	r26, r20
    f506:	54 96       	adiw	r26, 0x14	; 20
    f508:	8c 91       	ld	r24, X
    f50a:	81 93       	st	Z+, r24
    f50c:	4f 5f       	subi	r20, 0xFF	; 255
    f50e:	5f 4f       	sbci	r21, 0xFF	; 255
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f510:	e2 17       	cp	r30, r18
    f512:	f3 07       	cpc	r31, r19
    f514:	b9 f7       	brne	.-18     	; 0xf504 <StoreStandaloneTransData+0xfe>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f516:	1f a6       	std	Y+47, r1	; 0x2f
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    f518:	f7 01       	movw	r30, r14
    f51a:	84 8d       	ldd	r24, Z+28	; 0x1c
    f51c:	80 53       	subi	r24, 0x30	; 48
    f51e:	8a 30       	cpi	r24, 0x0A	; 10
    f520:	98 f4       	brcc	.+38     	; 0xf548 <StoreStandaloneTransData+0x142>

		 TransDigit=Ord(CharPosCopy(strRawTransData,28));
		 //Normalize7Digit
		 //sprintf_P(strSend,PSTR("Digit: %d"),TransDigit);
		 //_uart_print(1,1,strSend);
		 if  (TransDigit==8){
    f522:	88 30       	cpi	r24, 0x08	; 8
    f524:	89 f4       	brne	.+34     	; 0xf548 <StoreStandaloneTransData+0x142>
			  StrPosCopy(strPMoney,strPMoney,0,strlen(strPMoney)-1);	 
    f526:	fb 01       	movw	r30, r22
    f528:	01 90       	ld	r0, Z+
    f52a:	00 20       	and	r0, r0
    f52c:	e9 f7       	brne	.-6      	; 0xf528 <StoreStandaloneTransData+0x122>
    f52e:	e6 1b       	sub	r30, r22
    f530:	f7 0b       	sbc	r31, r23
    f532:	32 97       	sbiw	r30, 0x02	; 2
    f534:	80 e0       	ldi	r24, 0x00	; 0
    f536:	90 e0       	ldi	r25, 0x00	; 0
    f538:	01 c0       	rjmp	.+2      	; 0xf53c <StoreStandaloneTransData+0x136>
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f53a:	01 96       	adiw	r24, 0x01	; 1
    f53c:	8e 17       	cp	r24, r30
    f53e:	9f 07       	cpc	r25, r31
    f540:	e0 f3       	brcs	.-8      	; 0xf53a <StoreStandaloneTransData+0x134>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f542:	ec 0f       	add	r30, r28
    f544:	fd 1f       	adc	r31, r29
    f546:	17 a2       	std	Z+39, r1	; 0x27
		 //sprintf_P(strSend,PSTR("Digit: %d"),TransDigit);
		 //_uart_print(1,1,strSend);
		 if  (TransDigit==8){
			  StrPosCopy(strPMoney,strPMoney,0,strlen(strPMoney)-1);	 
		 }
		 RemZeroLead(strPPU);
    f548:	94 e0       	ldi	r25, 0x04	; 4
    f54a:	e9 2e       	mov	r14, r25
    f54c:	f1 2c       	mov	r15, r1
    f54e:	ec 0e       	add	r14, r28
    f550:	fd 1e       	adc	r15, r29
    f552:	c7 01       	movw	r24, r14
    f554:	0e 94 19 25 	call	0x4a32	; 0x4a32 <RemZeroLead>
		 RemZeroLead(strPVolume);
    f558:	8d e1       	ldi	r24, 0x1D	; 29
    f55a:	a8 2e       	mov	r10, r24
    f55c:	b1 2c       	mov	r11, r1
    f55e:	ac 0e       	add	r10, r28
    f560:	bd 1e       	adc	r11, r29
    f562:	c5 01       	movw	r24, r10
    f564:	0e 94 19 25 	call	0x4a32	; 0x4a32 <RemZeroLead>
		 RemZeroLead(strPMoney);
    f568:	8e 01       	movw	r16, r28
    f56a:	09 5d       	subi	r16, 0xD9	; 217
    f56c:	1f 4f       	sbci	r17, 0xFF	; 255
    f56e:	c8 01       	movw	r24, r16
    f570:	0e 94 19 25 	call	0x4a32	; 0x4a32 <RemZeroLead>
		 //sprintf_P(strSend,PSTR("Money: %s"),strPMoney);
		 //_uart_print(1,1,strSend);


		 //Void Detection
		 if (atoi(strPMoney)==0)TransactionStatus=TS_VOID;
    f574:	c8 01       	movw	r24, r16
    f576:	0e 94 c3 b3 	call	0x16786	; 0x16786 <atoi>
    f57a:	89 2b       	or	r24, r25
    f57c:	09 f0       	breq	.+2      	; 0xf580 <StoreStandaloneTransData+0x17a>
    f57e:	46 c1       	rjmp	.+652    	; 0xf80c <StoreStandaloneTransData+0x406>
		 else TransactionStatus=TS_NEW;
		 
		 if (TransactionStatus==TS_VOID){//RejectData
			 UpdateStandaloneStatus((iPumpID&0x0F),PS_VOID);
    f580:	83 2d       	mov	r24, r3
    f582:	8f 70       	andi	r24, 0x0F	; 15
    f584:	63 e1       	ldi	r22, 0x13	; 19
    f586:	0e 94 78 1d 	call	0x3af0	; 0x3af0 <UpdateStandaloneStatus>
    f58a:	8b c1       	rjmp	.+790    	; 0xf8a2 <StoreStandaloneTransData+0x49c>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    f58c:	e1 99       	sbic	0x1c, 1	; 28
    f58e:	fe cf       	rjmp	.-4      	; 0xf58c <StoreStandaloneTransData+0x186>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    f590:	8f e3       	ldi	r24, 0x3F	; 63
    f592:	91 e0       	ldi	r25, 0x01	; 1
    f594:	9f bb       	out	0x1f, r25	; 31
    f596:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    f598:	e0 9a       	sbi	0x1c, 0	; 28
    f59a:	2d b3       	in	r18, 0x1d	; 29
			 //_uart_print(1,1,strPVolume);
			 
			 GenerateTransactionNum(strTranNo);		 
			 sprintf_P(strTransDate,PSTR("%s"),strSystemDate);
			 sprintf_P(strTransTime,PSTR("%s"),strSystemTime);
			 sprintf_P(strShift,PSTR("%d"),eeprom_read_byte(&DefShift));
    f59c:	00 d0       	rcall	.+0      	; 0xf59e <StoreStandaloneTransData+0x198>
    f59e:	00 d0       	rcall	.+0      	; 0xf5a0 <StoreStandaloneTransData+0x19a>
    f5a0:	00 d0       	rcall	.+0      	; 0xf5a2 <StoreStandaloneTransData+0x19c>
    f5a2:	ed b7       	in	r30, 0x3d	; 61
    f5a4:	fe b7       	in	r31, 0x3e	; 62
    f5a6:	31 96       	adiw	r30, 0x01	; 1
    f5a8:	8f e9       	ldi	r24, 0x9F	; 159
    f5aa:	9d e0       	ldi	r25, 0x0D	; 13
    f5ac:	ad b7       	in	r26, 0x3d	; 61
    f5ae:	be b7       	in	r27, 0x3e	; 62
    f5b0:	12 96       	adiw	r26, 0x02	; 2
    f5b2:	9c 93       	st	X, r25
    f5b4:	8e 93       	st	-X, r24
    f5b6:	11 97       	sbiw	r26, 0x01	; 1
    f5b8:	80 ed       	ldi	r24, 0xD0	; 208
    f5ba:	92 e2       	ldi	r25, 0x22	; 34
    f5bc:	93 83       	std	Z+3, r25	; 0x03
    f5be:	82 83       	std	Z+2, r24	; 0x02
    f5c0:	24 83       	std	Z+4, r18	; 0x04
    f5c2:	15 82       	std	Z+5, r1	; 0x05
    f5c4:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
					 
			 //TransNum,Date,Time
			 StrPosCopy(strTranNo,RecPumpData[FIPAddr].strTransNum,0,strlen(strTranNo));
    f5c8:	ee eb       	ldi	r30, 0xBE	; 190
    f5ca:	fd e0       	ldi	r31, 0x0D	; 13
    f5cc:	df 01       	movw	r26, r30
    f5ce:	0d 90       	ld	r0, X+
    f5d0:	00 20       	and	r0, r0
    f5d2:	e9 f7       	brne	.-6      	; 0xf5ce <StoreStandaloneTransData+0x1c8>
    f5d4:	9d 01       	movw	r18, r26
    f5d6:	21 50       	subi	r18, 0x01	; 1
    f5d8:	30 40       	sbci	r19, 0x00	; 0
    f5da:	2e 1b       	sub	r18, r30
    f5dc:	3f 0b       	sbc	r19, r31
    f5de:	85 e3       	ldi	r24, 0x35	; 53
    f5e0:	90 e0       	ldi	r25, 0x00	; 0
    f5e2:	c8 9e       	mul	r12, r24
    f5e4:	d0 01       	movw	r26, r0
    f5e6:	c9 9e       	mul	r12, r25
    f5e8:	b0 0d       	add	r27, r0
    f5ea:	d8 9e       	mul	r13, r24
    f5ec:	b0 0d       	add	r27, r0
    f5ee:	11 24       	eor	r1, r1
    f5f0:	a3 54       	subi	r26, 0x43	; 67
    f5f2:	b9 4f       	sbci	r27, 0xF9	; 249
    f5f4:	4d b7       	in	r20, 0x3d	; 61
    f5f6:	5e b7       	in	r21, 0x3e	; 62
    f5f8:	4a 5f       	subi	r20, 0xFA	; 250
    f5fa:	5f 4f       	sbci	r21, 0xFF	; 255
    f5fc:	0f b6       	in	r0, 0x3f	; 63
    f5fe:	f8 94       	cli
    f600:	5e bf       	out	0x3e, r21	; 62
    f602:	0f be       	out	0x3f, r0	; 63
    f604:	4d bf       	out	0x3d, r20	; 61
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f606:	a9 01       	movw	r20, r18
    f608:	4e 0f       	add	r20, r30
    f60a:	5f 1f       	adc	r21, r31
    f60c:	02 c0       	rjmp	.+4      	; 0xf612 <StoreStandaloneTransData+0x20c>
	    Dest[i]=Source[IdxSource+i];
    f60e:	81 91       	ld	r24, Z+
    f610:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f612:	e4 17       	cp	r30, r20
    f614:	f5 07       	cpc	r31, r21
    f616:	d9 f7       	brne	.-10     	; 0xf60e <StoreStandaloneTransData+0x208>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f618:	85 e3       	ldi	r24, 0x35	; 53
    f61a:	90 e0       	ldi	r25, 0x00	; 0
    f61c:	dc 01       	movw	r26, r24
    f61e:	ca 9e       	mul	r12, r26
    f620:	c0 01       	movw	r24, r0
    f622:	cb 9e       	mul	r12, r27
    f624:	90 0d       	add	r25, r0
    f626:	da 9e       	mul	r13, r26
    f628:	90 0d       	add	r25, r0
    f62a:	11 24       	eor	r1, r1
    f62c:	fc 01       	movw	r30, r24
    f62e:	e6 54       	subi	r30, 0x46	; 70
    f630:	f9 4f       	sbci	r31, 0xF9	; 249
    f632:	e2 0f       	add	r30, r18
    f634:	f3 1f       	adc	r31, r19
    f636:	13 82       	std	Z+3, r1	; 0x03
			 sprintf_P(strTransTime,PSTR("%s"),strSystemTime);
			 sprintf_P(strShift,PSTR("%d"),eeprom_read_byte(&DefShift));
					 
			 //TransNum,Date,Time
			 StrPosCopy(strTranNo,RecPumpData[FIPAddr].strTransNum,0,strlen(strTranNo));
			 StrPosCopy(strTransDate,RecPumpData[FIPAddr].strTransDate,0,strlen(strTransDate));
    f638:	fe 01       	movw	r30, r28
    f63a:	3b 96       	adiw	r30, 0x0b	; 11
    f63c:	df 01       	movw	r26, r30
    f63e:	0d 90       	ld	r0, X+
    f640:	00 20       	and	r0, r0
    f642:	e9 f7       	brne	.-6      	; 0xf63e <StoreStandaloneTransData+0x238>
    f644:	11 97       	sbiw	r26, 0x01	; 1
    f646:	ae 1b       	sub	r26, r30
    f648:	bf 0b       	sbc	r27, r31
    f64a:	bf 01       	movw	r22, r30
    f64c:	9c 01       	movw	r18, r24
    f64e:	2c 53       	subi	r18, 0x3C	; 60
    f650:	39 4f       	sbci	r19, 0xF9	; 249
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f652:	af 01       	movw	r20, r30
    f654:	4a 0f       	add	r20, r26
    f656:	5b 1f       	adc	r21, r27
    f658:	06 c0       	rjmp	.+12     	; 0xf666 <StoreStandaloneTransData+0x260>
	    Dest[i]=Source[IdxSource+i];
    f65a:	fb 01       	movw	r30, r22
    f65c:	81 91       	ld	r24, Z+
    f65e:	bf 01       	movw	r22, r30
    f660:	f9 01       	movw	r30, r18
    f662:	81 93       	st	Z+, r24
    f664:	9f 01       	movw	r18, r30
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f666:	64 17       	cp	r22, r20
    f668:	75 07       	cpc	r23, r21
    f66a:	b9 f7       	brne	.-18     	; 0xf65a <StoreStandaloneTransData+0x254>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f66c:	85 e3       	ldi	r24, 0x35	; 53
    f66e:	90 e0       	ldi	r25, 0x00	; 0
    f670:	9c 01       	movw	r18, r24
    f672:	c2 9e       	mul	r12, r18
    f674:	c0 01       	movw	r24, r0
    f676:	c3 9e       	mul	r12, r19
    f678:	90 0d       	add	r25, r0
    f67a:	d2 9e       	mul	r13, r18
    f67c:	90 0d       	add	r25, r0
    f67e:	11 24       	eor	r1, r1
    f680:	fc 01       	movw	r30, r24
    f682:	e6 54       	subi	r30, 0x46	; 70
    f684:	f9 4f       	sbci	r31, 0xF9	; 249
    f686:	ea 0f       	add	r30, r26
    f688:	fb 1f       	adc	r31, r27
    f68a:	12 86       	std	Z+10, r1	; 0x0a
			 sprintf_P(strShift,PSTR("%d"),eeprom_read_byte(&DefShift));
					 
			 //TransNum,Date,Time
			 StrPosCopy(strTranNo,RecPumpData[FIPAddr].strTransNum,0,strlen(strTranNo));
			 StrPosCopy(strTransDate,RecPumpData[FIPAddr].strTransDate,0,strlen(strTransDate));
			 StrPosCopy(strTransTime,RecPumpData[FIPAddr].strTransTime,0,strlen(strTransTime));
    f68c:	fe 01       	movw	r30, r28
    f68e:	74 96       	adiw	r30, 0x14	; 20
    f690:	df 01       	movw	r26, r30
    f692:	0d 90       	ld	r0, X+
    f694:	00 20       	and	r0, r0
    f696:	e9 f7       	brne	.-6      	; 0xf692 <StoreStandaloneTransData+0x28c>
    f698:	11 97       	sbiw	r26, 0x01	; 1
    f69a:	ae 1b       	sub	r26, r30
    f69c:	bf 0b       	sbc	r27, r31
    f69e:	bf 01       	movw	r22, r30
    f6a0:	9c 01       	movw	r18, r24
    f6a2:	23 53       	subi	r18, 0x33	; 51
    f6a4:	39 4f       	sbci	r19, 0xF9	; 249
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f6a6:	af 01       	movw	r20, r30
    f6a8:	4a 0f       	add	r20, r26
    f6aa:	5b 1f       	adc	r21, r27
    f6ac:	06 c0       	rjmp	.+12     	; 0xf6ba <StoreStandaloneTransData+0x2b4>
	    Dest[i]=Source[IdxSource+i];
    f6ae:	fb 01       	movw	r30, r22
    f6b0:	81 91       	ld	r24, Z+
    f6b2:	bf 01       	movw	r22, r30
    f6b4:	f9 01       	movw	r30, r18
    f6b6:	81 93       	st	Z+, r24
    f6b8:	9f 01       	movw	r18, r30
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f6ba:	64 17       	cp	r22, r20
    f6bc:	75 07       	cpc	r23, r21
    f6be:	b9 f7       	brne	.-18     	; 0xf6ae <StoreStandaloneTransData+0x2a8>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f6c0:	85 e3       	ldi	r24, 0x35	; 53
    f6c2:	90 e0       	ldi	r25, 0x00	; 0
    f6c4:	c8 9e       	mul	r12, r24
    f6c6:	70 01       	movw	r14, r0
    f6c8:	c9 9e       	mul	r12, r25
    f6ca:	f0 0c       	add	r15, r0
    f6cc:	d8 9e       	mul	r13, r24
    f6ce:	f0 0c       	add	r15, r0
    f6d0:	11 24       	eor	r1, r1
    f6d2:	87 01       	movw	r16, r14
    f6d4:	06 54       	subi	r16, 0x46	; 70
    f6d6:	19 4f       	sbci	r17, 0xF9	; 249
    f6d8:	a0 0f       	add	r26, r16
    f6da:	b1 1f       	adc	r27, r17
    f6dc:	53 96       	adiw	r26, 0x13	; 19
    f6de:	1c 92       	st	X, r1
			 //TransNum,Date,Time
			 StrPosCopy(strTranNo,RecPumpData[FIPAddr].strTransNum,0,strlen(strTranNo));
			 StrPosCopy(strTransDate,RecPumpData[FIPAddr].strTransDate,0,strlen(strTransDate));
			 StrPosCopy(strTransTime,RecPumpData[FIPAddr].strTransTime,0,strlen(strTransTime));
			 //Grade Nozzle Shift
			 RecPumpData[FIPAddr].Grade=PGrade;
    f6e0:	f0 ed       	ldi	r31, 0xD0	; 208
    f6e2:	2f 0e       	add	r2, r31
    f6e4:	d8 01       	movw	r26, r16
    f6e6:	2c 92       	st	X, r2
			 RecPumpData[FIPAddr].Nozzle=PNozzle;
    f6e8:	b9 a9       	ldd	r27, Y+49	; 0x31
    f6ea:	b0 53       	subi	r27, 0x30	; 48
    f6ec:	f8 01       	movw	r30, r16
    f6ee:	b1 83       	std	Z+1, r27	; 0x01
			 RecPumpData[FIPAddr].Shift=atoi(strShift);
    f6f0:	8f e9       	ldi	r24, 0x9F	; 159
    f6f2:	9d e0       	ldi	r25, 0x0D	; 13
    f6f4:	0e 94 c3 b3 	call	0x16786	; 0x16786 <atoi>
    f6f8:	d8 01       	movw	r26, r16
    f6fa:	12 96       	adiw	r26, 0x02	; 2
    f6fc:	8c 93       	st	X, r24
			 //Price Volume Money
			 StrPosCopy(strPPU,RecPumpData[FIPAddr].Price,0,strlen(strPPU));
    f6fe:	fe 01       	movw	r30, r28
    f700:	34 96       	adiw	r30, 0x04	; 4
    f702:	df 01       	movw	r26, r30
    f704:	0d 90       	ld	r0, X+
    f706:	00 20       	and	r0, r0
    f708:	e9 f7       	brne	.-6      	; 0xf704 <StoreStandaloneTransData+0x2fe>
    f70a:	11 97       	sbiw	r26, 0x01	; 1
    f70c:	ae 1b       	sub	r26, r30
    f70e:	bf 0b       	sbc	r27, r31
    f710:	97 01       	movw	r18, r14
    f712:	2a 52       	subi	r18, 0x2A	; 42
    f714:	39 4f       	sbci	r19, 0xF9	; 249
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f716:	af 01       	movw	r20, r30
    f718:	4a 0f       	add	r20, r26
    f71a:	5b 1f       	adc	r21, r27
    f71c:	06 c0       	rjmp	.+12     	; 0xf72a <StoreStandaloneTransData+0x324>
	    Dest[i]=Source[IdxSource+i];
    f71e:	f4 01       	movw	r30, r8
    f720:	81 91       	ld	r24, Z+
    f722:	4f 01       	movw	r8, r30
    f724:	f9 01       	movw	r30, r18
    f726:	81 93       	st	Z+, r24
    f728:	9f 01       	movw	r18, r30
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f72a:	84 16       	cp	r8, r20
    f72c:	95 06       	cpc	r9, r21
    f72e:	b9 f7       	brne	.-18     	; 0xf71e <StoreStandaloneTransData+0x318>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f730:	85 e3       	ldi	r24, 0x35	; 53
    f732:	90 e0       	ldi	r25, 0x00	; 0
    f734:	9c 01       	movw	r18, r24
    f736:	c2 9e       	mul	r12, r18
    f738:	c0 01       	movw	r24, r0
    f73a:	c3 9e       	mul	r12, r19
    f73c:	90 0d       	add	r25, r0
    f73e:	d2 9e       	mul	r13, r18
    f740:	90 0d       	add	r25, r0
    f742:	11 24       	eor	r1, r1
    f744:	fc 01       	movw	r30, r24
    f746:	e6 54       	subi	r30, 0x46	; 70
    f748:	f9 4f       	sbci	r31, 0xF9	; 249
    f74a:	ea 0f       	add	r30, r26
    f74c:	fb 1f       	adc	r31, r27
    f74e:	14 8e       	std	Z+28, r1	; 0x1c
			 RecPumpData[FIPAddr].Grade=PGrade;
			 RecPumpData[FIPAddr].Nozzle=PNozzle;
			 RecPumpData[FIPAddr].Shift=atoi(strShift);
			 //Price Volume Money
			 StrPosCopy(strPPU,RecPumpData[FIPAddr].Price,0,strlen(strPPU));
			 StrPosCopy(strPVolume,RecPumpData[FIPAddr].Volume,0,strlen(strPVolume));
    f750:	fe 01       	movw	r30, r28
    f752:	7d 96       	adiw	r30, 0x1d	; 29
    f754:	df 01       	movw	r26, r30
    f756:	0d 90       	ld	r0, X+
    f758:	00 20       	and	r0, r0
    f75a:	e9 f7       	brne	.-6      	; 0xf756 <StoreStandaloneTransData+0x350>
    f75c:	11 97       	sbiw	r26, 0x01	; 1
    f75e:	ae 1b       	sub	r26, r30
    f760:	bf 0b       	sbc	r27, r31
    f762:	9c 01       	movw	r18, r24
    f764:	23 52       	subi	r18, 0x23	; 35
    f766:	39 4f       	sbci	r19, 0xF9	; 249
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f768:	af 01       	movw	r20, r30
    f76a:	4a 0f       	add	r20, r26
    f76c:	5b 1f       	adc	r21, r27
    f76e:	06 c0       	rjmp	.+12     	; 0xf77c <StoreStandaloneTransData+0x376>
	    Dest[i]=Source[IdxSource+i];
    f770:	f3 01       	movw	r30, r6
    f772:	81 91       	ld	r24, Z+
    f774:	3f 01       	movw	r6, r30
    f776:	f9 01       	movw	r30, r18
    f778:	81 93       	st	Z+, r24
    f77a:	9f 01       	movw	r18, r30
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f77c:	64 16       	cp	r6, r20
    f77e:	75 06       	cpc	r7, r21
    f780:	b9 f7       	brne	.-18     	; 0xf770 <StoreStandaloneTransData+0x36a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f782:	85 e3       	ldi	r24, 0x35	; 53
    f784:	90 e0       	ldi	r25, 0x00	; 0
    f786:	9c 01       	movw	r18, r24
    f788:	c2 9e       	mul	r12, r18
    f78a:	c0 01       	movw	r24, r0
    f78c:	c3 9e       	mul	r12, r19
    f78e:	90 0d       	add	r25, r0
    f790:	d2 9e       	mul	r13, r18
    f792:	90 0d       	add	r25, r0
    f794:	11 24       	eor	r1, r1
    f796:	fc 01       	movw	r30, r24
    f798:	e6 54       	subi	r30, 0x46	; 70
    f79a:	f9 4f       	sbci	r31, 0xF9	; 249
    f79c:	ea 0f       	add	r30, r26
    f79e:	fb 1f       	adc	r31, r27
    f7a0:	13 a2       	std	Z+35, r1	; 0x23
			 RecPumpData[FIPAddr].Nozzle=PNozzle;
			 RecPumpData[FIPAddr].Shift=atoi(strShift);
			 //Price Volume Money
			 StrPosCopy(strPPU,RecPumpData[FIPAddr].Price,0,strlen(strPPU));
			 StrPosCopy(strPVolume,RecPumpData[FIPAddr].Volume,0,strlen(strPVolume));
			 StrPosCopy(strPMoney,RecPumpData[FIPAddr].Money,0,strlen(strPMoney));
    f7a2:	fe 01       	movw	r30, r28
    f7a4:	b7 96       	adiw	r30, 0x27	; 39
    f7a6:	df 01       	movw	r26, r30
    f7a8:	0d 90       	ld	r0, X+
    f7aa:	00 20       	and	r0, r0
    f7ac:	e9 f7       	brne	.-6      	; 0xf7a8 <StoreStandaloneTransData+0x3a2>
    f7ae:	11 97       	sbiw	r26, 0x01	; 1
    f7b0:	ae 1b       	sub	r26, r30
    f7b2:	bf 0b       	sbc	r27, r31
    f7b4:	9c 01       	movw	r18, r24
    f7b6:	2a 51       	subi	r18, 0x1A	; 26
    f7b8:	39 4f       	sbci	r19, 0xF9	; 249
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f7ba:	af 01       	movw	r20, r30
    f7bc:	4a 0f       	add	r20, r26
    f7be:	5b 1f       	adc	r21, r27
    f7c0:	06 c0       	rjmp	.+12     	; 0xf7ce <StoreStandaloneTransData+0x3c8>
	    Dest[i]=Source[IdxSource+i];
    f7c2:	f2 01       	movw	r30, r4
    f7c4:	81 91       	ld	r24, Z+
    f7c6:	2f 01       	movw	r4, r30
    f7c8:	f9 01       	movw	r30, r18
    f7ca:	81 93       	st	Z+, r24
    f7cc:	9f 01       	movw	r18, r30
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f7ce:	44 16       	cp	r4, r20
    f7d0:	55 06       	cpc	r5, r21
    f7d2:	b9 f7       	brne	.-18     	; 0xf7c2 <StoreStandaloneTransData+0x3bc>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f7d4:	85 e3       	ldi	r24, 0x35	; 53
    f7d6:	90 e0       	ldi	r25, 0x00	; 0
    f7d8:	c8 9e       	mul	r12, r24
    f7da:	f0 01       	movw	r30, r0
    f7dc:	c9 9e       	mul	r12, r25
    f7de:	f0 0d       	add	r31, r0
    f7e0:	d8 9e       	mul	r13, r24
    f7e2:	f0 0d       	add	r31, r0
    f7e4:	11 24       	eor	r1, r1
    f7e6:	e6 54       	subi	r30, 0x46	; 70
    f7e8:	f9 4f       	sbci	r31, 0xF9	; 249
    f7ea:	ea 0f       	add	r30, r26
    f7ec:	fb 1f       	adc	r31, r27
    f7ee:	14 a6       	std	Z+44, r1	; 0x2c
			 //Price Volume Money
			 StrPosCopy(strPPU,RecPumpData[FIPAddr].Price,0,strlen(strPPU));
			 StrPosCopy(strPVolume,RecPumpData[FIPAddr].Volume,0,strlen(strPVolume));
			 StrPosCopy(strPMoney,RecPumpData[FIPAddr].Money,0,strlen(strPMoney));

			 UpdateStandaloneStatus((iPumpID&0x0F),PS_PRINT_READY);
    f7f0:	83 2d       	mov	r24, r3
    f7f2:	8f 70       	andi	r24, 0x0F	; 15
    f7f4:	60 e1       	ldi	r22, 0x10	; 16
    f7f6:	0e 94 78 1d 	call	0x3af0	; 0x3af0 <UpdateStandaloneStatus>
			 
			 SetIncomingTransStatus(iPumpID,TS_NEW);		 
    f7fa:	83 2d       	mov	r24, r3
    f7fc:	62 e0       	ldi	r22, 0x02	; 2
    f7fe:	0e 94 11 1a 	call	0x3422	; 0x3422 <SetIncomingTransStatus>

			 SendSlaveCommand(SC_TRANSACTION_ACK,iPumpID);
    f802:	8b e0       	ldi	r24, 0x0B	; 11
    f804:	63 2d       	mov	r22, r3
    f806:	0e 94 72 74 	call	0xe8e4	; 0xe8e4 <SendSlaveCommand>
    f80a:	4b c0       	rjmp	.+150    	; 0xf8a2 <StoreStandaloneTransData+0x49c>
			 UpdateStandaloneStatus((iPumpID&0x0F),PS_VOID);
		 }
		 else 
		 if (TransactionStatus=TS_NEW){ 
			 //Update ReprintReady
			 ReprintReady[FIPAddr]=True;//Ready for Printing
    f80c:	da 94       	dec	r13
    f80e:	cd 2c       	mov	r12, r13
    f810:	dd 24       	eor	r13, r13
    f812:	f6 01       	movw	r30, r12
    f814:	ee 58       	subi	r30, 0x8E	; 142
    f816:	fe 4f       	sbci	r31, 0xFE	; 254
    f818:	81 e0       	ldi	r24, 0x01	; 1
    f81a:	80 83       	st	Z, r24
			  
			 FormatPrice(strPPU);
    f81c:	c7 01       	movw	r24, r14
    f81e:	0e 94 6d 34 	call	0x68da	; 0x68da <FormatPrice>
			 FormatMoney(strPMoney);
    f822:	c8 01       	movw	r24, r16
    f824:	0e 94 60 34 	call	0x68c0	; 0x68c0 <FormatMoney>
			 FormatVolume(strPVolume);
    f828:	c5 01       	movw	r24, r10
    f82a:	0e 94 53 34 	call	0x68a6	; 0x68a6 <FormatVolume>

			 //_uart_print(1,1,strPVolume);
			 
			 GenerateTransactionNum(strTranNo);		 
    f82e:	8e eb       	ldi	r24, 0xBE	; 190
    f830:	9d e0       	ldi	r25, 0x0D	; 13
    f832:	0e 94 d7 3f 	call	0x7fae	; 0x7fae <GenerateTransactionNum>
			 sprintf_P(strTransDate,PSTR("%s"),strSystemDate);
    f836:	00 d0       	rcall	.+0      	; 0xf838 <StoreStandaloneTransData+0x432>
    f838:	00 d0       	rcall	.+0      	; 0xf83a <StoreStandaloneTransData+0x434>
    f83a:	00 d0       	rcall	.+0      	; 0xf83c <StoreStandaloneTransData+0x436>
    f83c:	ed b7       	in	r30, 0x3d	; 61
    f83e:	fe b7       	in	r31, 0x3e	; 62
    f840:	31 96       	adiw	r30, 0x01	; 1
    f842:	ce 01       	movw	r24, r28
    f844:	0b 96       	adiw	r24, 0x0b	; 11
    f846:	ad b7       	in	r26, 0x3d	; 61
    f848:	be b7       	in	r27, 0x3e	; 62
    f84a:	12 96       	adiw	r26, 0x02	; 2
    f84c:	9c 93       	st	X, r25
    f84e:	8e 93       	st	-X, r24
    f850:	11 97       	sbiw	r26, 0x01	; 1
    f852:	86 ed       	ldi	r24, 0xD6	; 214
    f854:	92 e2       	ldi	r25, 0x22	; 34
    f856:	93 83       	std	Z+3, r25	; 0x03
    f858:	82 83       	std	Z+2, r24	; 0x02
    f85a:	89 ec       	ldi	r24, 0xC9	; 201
    f85c:	94 e0       	ldi	r25, 0x04	; 4
    f85e:	95 83       	std	Z+5, r25	; 0x05
    f860:	84 83       	std	Z+4, r24	; 0x04
    f862:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
			 sprintf_P(strTransTime,PSTR("%s"),strSystemTime);
    f866:	ed b7       	in	r30, 0x3d	; 61
    f868:	fe b7       	in	r31, 0x3e	; 62
    f86a:	31 96       	adiw	r30, 0x01	; 1
    f86c:	ce 01       	movw	r24, r28
    f86e:	44 96       	adiw	r24, 0x14	; 20
    f870:	ad b7       	in	r26, 0x3d	; 61
    f872:	be b7       	in	r27, 0x3e	; 62
    f874:	12 96       	adiw	r26, 0x02	; 2
    f876:	9c 93       	st	X, r25
    f878:	8e 93       	st	-X, r24
    f87a:	11 97       	sbiw	r26, 0x01	; 1
    f87c:	83 ed       	ldi	r24, 0xD3	; 211
    f87e:	92 e2       	ldi	r25, 0x22	; 34
    f880:	93 83       	std	Z+3, r25	; 0x03
    f882:	82 83       	std	Z+2, r24	; 0x02
    f884:	88 ea       	ldi	r24, 0xA8	; 168
    f886:	99 e0       	ldi	r25, 0x09	; 9
    f888:	95 83       	std	Z+5, r25	; 0x05
    f88a:	84 83       	std	Z+4, r24	; 0x04
    f88c:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    f890:	ed b7       	in	r30, 0x3d	; 61
    f892:	fe b7       	in	r31, 0x3e	; 62
    f894:	36 96       	adiw	r30, 0x06	; 6
    f896:	0f b6       	in	r0, 0x3f	; 63
    f898:	f8 94       	cli
    f89a:	fe bf       	out	0x3e, r31	; 62
    f89c:	0f be       	out	0x3f, r0	; 63
    f89e:	ed bf       	out	0x3d, r30	; 61
    f8a0:	75 ce       	rjmp	.-790    	; 0xf58c <StoreStandaloneTransData+0x186>

			 SendSlaveCommand(SC_TRANSACTION_ACK,iPumpID);
		 }		 
	 }    
     //_uart_print(0,1,strRawTransData);
}
    f8a2:	e1 96       	adiw	r28, 0x31	; 49
    f8a4:	0f b6       	in	r0, 0x3f	; 63
    f8a6:	f8 94       	cli
    f8a8:	de bf       	out	0x3e, r29	; 62
    f8aa:	0f be       	out	0x3f, r0	; 63
    f8ac:	cd bf       	out	0x3d, r28	; 61
    f8ae:	cf 91       	pop	r28
    f8b0:	df 91       	pop	r29
    f8b2:	1f 91       	pop	r17
    f8b4:	0f 91       	pop	r16
    f8b6:	ff 90       	pop	r15
    f8b8:	ef 90       	pop	r14
    f8ba:	df 90       	pop	r13
    f8bc:	cf 90       	pop	r12
    f8be:	bf 90       	pop	r11
    f8c0:	af 90       	pop	r10
    f8c2:	9f 90       	pop	r9
    f8c4:	8f 90       	pop	r8
    f8c6:	7f 90       	pop	r7
    f8c8:	6f 90       	pop	r6
    f8ca:	5f 90       	pop	r5
    f8cc:	4f 90       	pop	r4
    f8ce:	3f 90       	pop	r3
    f8d0:	2f 90       	pop	r2
    f8d2:	08 95       	ret

0000f8d4 <StoreStandaloneTotalizerData>:
	  systemEDC();
	  systemConfigProtocol();
	  //systemGeniusProtocol(); //AKR-->Protocol disabled
}

void StoreStandaloneTotalizerData(char *strRawTransData){//Sending FlowSPI_Protocol <STX>   [MsgID][PumpID][Volume1][Amount1][Volume2][Amount2][Volume3][Amount3][Volume4][Amount4][Volume5][Amount5][Volume6][Amount6]<ETX>
    f8d4:	2f 92       	push	r2
    f8d6:	3f 92       	push	r3
    f8d8:	4f 92       	push	r4
    f8da:	5f 92       	push	r5
    f8dc:	7f 92       	push	r7
    f8de:	8f 92       	push	r8
    f8e0:	9f 92       	push	r9
    f8e2:	af 92       	push	r10
    f8e4:	bf 92       	push	r11
    f8e6:	cf 92       	push	r12
    f8e8:	df 92       	push	r13
    f8ea:	ef 92       	push	r14
    f8ec:	ff 92       	push	r15
    f8ee:	0f 93       	push	r16
    f8f0:	1f 93       	push	r17
    f8f2:	df 93       	push	r29
    f8f4:	cf 93       	push	r28
    f8f6:	cd b7       	in	r28, 0x3d	; 61
    f8f8:	de b7       	in	r29, 0x3e	; 62
    f8fa:	a1 97       	sbiw	r28, 0x21	; 33
    f8fc:	0f b6       	in	r0, 0x3f	; 63
    f8fe:	f8 94       	cli
    f900:	de bf       	out	0x3e, r29	; 62
    f902:	0f be       	out	0x3f, r0	; 63
    f904:	cd bf       	out	0x3d, r28	; 61
    f906:	8c 01       	movw	r16, r24
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    f908:	fc 01       	movw	r30, r24
    f90a:	82 81       	ldd	r24, Z+2	; 0x02
    f90c:	89 83       	std	Y+1, r24	; 0x01
    f90e:	83 81       	ldd	r24, Z+3	; 0x03
    f910:	8a 83       	std	Y+2, r24	; 0x02
	 }Dest[Length]=0;
    f912:	1b 82       	std	Y+3, r1	; 0x03
	 //    _uart(1,1,strRawTransData[i]); 
	 // }

     StrPosCopy(strRawTransData,strPumpID,2,2);
	 //IdIFT(strPumpID);
	 iPumpID=atoi(strPumpID);  
    f914:	ce 01       	movw	r24, r28
    f916:	01 96       	adiw	r24, 0x01	; 1
    f918:	0e 94 c3 b3 	call	0x16786	; 0x16786 <atoi>
    f91c:	c8 2e       	mov	r12, r24
	 
	 FIPAddr=GetFIPAddr(iPumpID);
    f91e:	0e 94 41 1d 	call	0x3a82	; 0x3a82 <GetFIPAddr>
	 if (FIPAddr>0){
    f922:	88 23       	and	r24, r24
    f924:	09 f4       	brne	.+2      	; 0xf928 <StoreStandaloneTotalizerData+0x54>
    f926:	44 c0       	rjmp	.+136    	; 0xf9b0 <StoreStandaloneTotalizerData+0xdc>
	     FIPAddr=FIPAddr-1;
    f928:	78 2e       	mov	r7, r24
    f92a:	7a 94       	dec	r7
    f92c:	e0 e1       	ldi	r30, 0x10	; 16
    f92e:	ee 2e       	mov	r14, r30
    f930:	f1 2c       	mov	r15, r1
    f932:	e0 0e       	add	r14, r16
    f934:	f1 1e       	adc	r15, r17
    f936:	dd 24       	eor	r13, r13
    f938:	d3 94       	inc	r13
    f93a:	74 e0       	ldi	r23, 0x04	; 4
    f93c:	87 2e       	mov	r8, r23
    f93e:	91 2c       	mov	r9, r1
    f940:	8c 0e       	add	r8, r28
    f942:	9d 1e       	adc	r9, r29
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f944:	60 e1       	ldi	r22, 0x10	; 16
    f946:	26 2e       	mov	r2, r22
    f948:	31 2c       	mov	r3, r1
    f94a:	2c 0e       	add	r2, r28
    f94c:	3d 1e       	adc	r3, r29
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f94e:	53 e1       	ldi	r21, 0x13	; 19
    f950:	a5 2e       	mov	r10, r21
    f952:	b1 2c       	mov	r11, r1
    f954:	ac 0e       	add	r10, r28
    f956:	bd 1e       	adc	r11, r29
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f958:	4f e1       	ldi	r20, 0x1F	; 31
    f95a:	44 2e       	mov	r4, r20
    f95c:	51 2c       	mov	r5, r1
    f95e:	4c 0e       	add	r4, r28
    f960:	5d 1e       	adc	r5, r29
	 //IdIFT(strPumpID);
	 iPumpID=atoi(strPumpID);  
	 
	 FIPAddr=GetFIPAddr(iPumpID);
	 if (FIPAddr>0){
	     FIPAddr=FIPAddr-1;
    f962:	d7 01       	movw	r26, r14
    f964:	1c 97       	sbiw	r26, 0x0c	; 12
    f966:	f4 01       	movw	r30, r8
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    f968:	8d 91       	ld	r24, X+
    f96a:	81 93       	st	Z+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f96c:	e2 15       	cp	r30, r2
    f96e:	f3 05       	cpc	r31, r3
    f970:	d9 f7       	brne	.-10     	; 0xf968 <StoreStandaloneTotalizerData+0x94>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f972:	18 8a       	std	Y+16, r1	; 0x10
    f974:	f5 01       	movw	r30, r10
    f976:	d7 01       	movw	r26, r14
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    f978:	8d 91       	ld	r24, X+
    f97a:	81 93       	st	Z+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f97c:	e4 15       	cp	r30, r4
    f97e:	f5 05       	cpc	r31, r5
    f980:	d9 f7       	brne	.-10     	; 0xf978 <StoreStandaloneTotalizerData+0xa4>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f982:	1f 8e       	std	Y+31, r1	; 0x1f

		 for (iGrade=1;iGrade<=6;iGrade++){          
			  StrPosCopy(strRawTransData,strGVolume,(4+((iGrade-1)*24)),12);
			  StrPosCopy(strRawTransData,strGMoney,(16+((iGrade-1)*24)),12);
			  
			  SetTotalizerData(TVOLUME,TOTALIZER_NOW,FIPAddr,iGrade,strGVolume);
    f984:	80 e0       	ldi	r24, 0x00	; 0
    f986:	61 e0       	ldi	r22, 0x01	; 1
    f988:	47 2d       	mov	r20, r7
    f98a:	2d 2d       	mov	r18, r13
    f98c:	84 01       	movw	r16, r8
    f98e:	0e 94 ac 27 	call	0x4f58	; 0x4f58 <SetTotalizerData>
			  SetTotalizerData(TMONEY,TOTALIZER_NOW,FIPAddr,iGrade,strGMoney);
    f992:	81 e0       	ldi	r24, 0x01	; 1
    f994:	61 e0       	ldi	r22, 0x01	; 1
    f996:	47 2d       	mov	r20, r7
    f998:	2d 2d       	mov	r18, r13
    f99a:	85 01       	movw	r16, r10
    f99c:	0e 94 ac 27 	call	0x4f58	; 0x4f58 <SetTotalizerData>
	 FIPAddr=GetFIPAddr(iPumpID);
	 if (FIPAddr>0){
	     FIPAddr=FIPAddr-1;
		 //_uart_printf(1,1,PSTR("Totalizer:"));

		 for (iGrade=1;iGrade<=6;iGrade++){          
    f9a0:	d3 94       	inc	r13
    f9a2:	88 e1       	ldi	r24, 0x18	; 24
    f9a4:	90 e0       	ldi	r25, 0x00	; 0
    f9a6:	e8 0e       	add	r14, r24
    f9a8:	f9 1e       	adc	r15, r25
    f9aa:	97 e0       	ldi	r25, 0x07	; 7
    f9ac:	d9 16       	cp	r13, r25
    f9ae:	c9 f6       	brne	.-78     	; 0xf962 <StoreStandaloneTotalizerData+0x8e>
			  SetTotalizerData(TMONEY,TOTALIZER_NOW,FIPAddr,iGrade,strGMoney);
			  //sprintf_P(strSend,PSTR("Nozzle:%d Volume:%s Money:%s"),iGrade,strGVolume,strGMoney);
			  //_uart_print(0,1,strSend);
		 }	
	}
     SendSlaveCommand(SC_TOTALIZER_ACK,iPumpID);
    f9b0:	8d e0       	ldi	r24, 0x0D	; 13
    f9b2:	6c 2d       	mov	r22, r12
    f9b4:	0e 94 72 74 	call	0xe8e4	; 0xe8e4 <SendSlaveCommand>
	 UpdateStandaloneStatus((iPumpID&0x0F),PS_TOTALIZER);	 
    f9b8:	8c 2d       	mov	r24, r12
    f9ba:	8f 70       	andi	r24, 0x0F	; 15
    f9bc:	64 e1       	ldi	r22, 0x14	; 20
    f9be:	0e 94 78 1d 	call	0x3af0	; 0x3af0 <UpdateStandaloneStatus>
}
    f9c2:	a1 96       	adiw	r28, 0x21	; 33
    f9c4:	0f b6       	in	r0, 0x3f	; 63
    f9c6:	f8 94       	cli
    f9c8:	de bf       	out	0x3e, r29	; 62
    f9ca:	0f be       	out	0x3f, r0	; 63
    f9cc:	cd bf       	out	0x3d, r28	; 61
    f9ce:	cf 91       	pop	r28
    f9d0:	df 91       	pop	r29
    f9d2:	1f 91       	pop	r17
    f9d4:	0f 91       	pop	r16
    f9d6:	ff 90       	pop	r15
    f9d8:	ef 90       	pop	r14
    f9da:	df 90       	pop	r13
    f9dc:	cf 90       	pop	r12
    f9de:	bf 90       	pop	r11
    f9e0:	af 90       	pop	r10
    f9e2:	9f 90       	pop	r9
    f9e4:	8f 90       	pop	r8
    f9e6:	7f 90       	pop	r7
    f9e8:	5f 90       	pop	r5
    f9ea:	4f 90       	pop	r4
    f9ec:	3f 90       	pop	r3
    f9ee:	2f 90       	pop	r2
    f9f0:	08 95       	ret

0000f9f2 <ScanStandaloneFlow>:
	 _spi(SlaveMessage);
	 _spi(0x06);
	 systemSlave();
}

void ScanStandaloneFlow(char data){  //<STX>[PumpID][STA]<ETX> --> 0x07 0xF1 0xF2 0x08
    f9f2:	0f 93       	push	r16
    f9f4:	1f 93       	push	r17
    f9f6:	08 2f       	mov	r16, r24

      DataPumpID=0;
      DataPumpStatus=0;
	  MixData=0;
      //Shift data
      zDataFlow[4]=zDataFlow[3];
    f9f8:	80 91 fd 02 	lds	r24, 0x02FD
    f9fc:	80 93 fe 02 	sts	0x02FE, r24
	  zDataFlow[3]=zDataFlow[2];
    fa00:	80 91 fc 02 	lds	r24, 0x02FC
    fa04:	80 93 fd 02 	sts	0x02FD, r24
	  zDataFlow[2]=zDataFlow[1];
    fa08:	80 91 fb 02 	lds	r24, 0x02FB
    fa0c:	80 93 fc 02 	sts	0x02FC, r24
      zDataFlow[1]=zDataFlow[0];
    fa10:	90 91 fa 02 	lds	r25, 0x02FA
    fa14:	90 93 fb 02 	sts	0x02FB, r25
      zDataFlow[0]=data;
    fa18:	00 93 fa 02 	sts	0x02FA, r16

      //Scan UpdatedPumpStatus Flow
	  //<STX>[ID][STA]<ETX>: 0x07[ID STA]0x08
	  if((zDataFlow[2]==0x07)&&(zDataFlow[0]==0x08)){
    fa1c:	87 30       	cpi	r24, 0x07	; 7
    fa1e:	79 f4       	brne	.+30     	; 0xfa3e <ScanStandaloneFlow+0x4c>
    fa20:	08 30       	cpi	r16, 0x08	; 8
    fa22:	69 f4       	brne	.+26     	; 0xfa3e <ScanStandaloneFlow+0x4c>
          MixData=zDataFlow[1];
	      DataPumpID=((MixData&0xF0)>>4);
		  DataPumpStatus=(MixData&0x0F);
    fa24:	19 2f       	mov	r17, r25
    fa26:	1f 70       	andi	r17, 0x0F	; 15
		  UpdateStandaloneStatus(DataPumpID,DataPumpStatus);
    fa28:	89 2f       	mov	r24, r25
    fa2a:	82 95       	swap	r24
    fa2c:	8f 70       	andi	r24, 0x0F	; 15
    fa2e:	61 2f       	mov	r22, r17
    fa30:	0e 94 78 1d 	call	0x3af0	; 0x3af0 <UpdateStandaloneStatus>
		  if (DataPumpStatus!=PUMP_NONE)IsStandAloneDetected=True;
    fa34:	1e 30       	cpi	r17, 0x0E	; 14
    fa36:	19 f0       	breq	.+6      	; 0xfa3e <ScanStandaloneFlow+0x4c>
    fa38:	81 e0       	ldi	r24, 0x01	; 1
    fa3a:	80 93 9f 01 	sts	0x019F, r24
		  //sprintf_P(strSend,PSTR("PS:%d Id:%d"),MixData,DataPumpID);
		  //_uart_print(0,1,strSend);
	  }

	  //Scan Transaction Completion FEOT
	  if (IsStandaloneTrans==True){
    fa3e:	80 91 a0 01 	lds	r24, 0x01A0
    fa42:	81 30       	cpi	r24, 0x01	; 1
    fa44:	69 f4       	brne	.+26     	; 0xfa60 <ScanStandaloneFlow+0x6e>
	      strStandReceived[iFlow]=data;
    fa46:	80 91 f8 02 	lds	r24, 0x02F8
    fa4a:	90 91 f9 02 	lds	r25, 0x02F9
    fa4e:	fc 01       	movw	r30, r24
    fa50:	eb 5e       	subi	r30, 0xEB	; 235
    fa52:	fb 4f       	sbci	r31, 0xFB	; 251
    fa54:	00 83       	st	Z, r16
		  iFlow++;
    fa56:	01 96       	adiw	r24, 0x01	; 1
    fa58:	90 93 f9 02 	sts	0x02F9, r25
    fa5c:	80 93 f8 02 	sts	0x02F8, r24
	  }
	  if((zDataFlow[1]==0x05)&&(zDataFlow[0]==0x50)){
    fa60:	80 91 fb 02 	lds	r24, 0x02FB
    fa64:	85 30       	cpi	r24, 0x05	; 5
    fa66:	61 f4       	brne	.+24     	; 0xfa80 <ScanStandaloneFlow+0x8e>
    fa68:	80 91 fa 02 	lds	r24, 0x02FA
    fa6c:	80 35       	cpi	r24, 0x50	; 80
    fa6e:	41 f5       	brne	.+80     	; 0xfac0 <ScanStandaloneFlow+0xce>
	      IsStandaloneTrans=True;
    fa70:	81 e0       	ldi	r24, 0x01	; 1
    fa72:	80 93 a0 01 	sts	0x01A0, r24
		  iFlow=0;
    fa76:	10 92 f9 02 	sts	0x02F9, r1
    fa7a:	10 92 f8 02 	sts	0x02F8, r1
    fa7e:	20 c0       	rjmp	.+64     	; 0xfac0 <ScanStandaloneFlow+0xce>
	  }
	  if((zDataFlow[1]==0x06)&&(zDataFlow[0]==0x60)){
    fa80:	86 30       	cpi	r24, 0x06	; 6
    fa82:	f1 f4       	brne	.+60     	; 0xfac0 <ScanStandaloneFlow+0xce>
    fa84:	80 91 fa 02 	lds	r24, 0x02FA
    fa88:	80 36       	cpi	r24, 0x60	; 96
    fa8a:	d1 f4       	brne	.+52     	; 0xfac0 <ScanStandaloneFlow+0xce>
	      IsStandaloneTrans=False;
    fa8c:	10 92 a0 01 	sts	0x01A0, r1
	      strStandReceived[iFlow]=0;
    fa90:	e0 91 f8 02 	lds	r30, 0x02F8
    fa94:	f0 91 f9 02 	lds	r31, 0x02F9
    fa98:	eb 5e       	subi	r30, 0xEB	; 235
    fa9a:	fb 4f       	sbci	r31, 0xFB	; 251
    fa9c:	10 82       	st	Z, r1

		  //_uart_print(1,1,strStandReceived);

		  MsgIDx=GetMessageID(strStandReceived);
    fa9e:	85 e1       	ldi	r24, 0x15	; 21
    faa0:	94 e0       	ldi	r25, 0x04	; 4
    faa2:	0e 94 2c 44 	call	0x8858	; 0x8858 <GetMessageID>
          if (MsgIDx==0x01)StoreStandaloneTransData(strStandReceived);
    faa6:	81 30       	cpi	r24, 0x01	; 1
    faa8:	29 f4       	brne	.+10     	; 0xfab4 <ScanStandaloneFlow+0xc2>
    faaa:	85 e1       	ldi	r24, 0x15	; 21
    faac:	94 e0       	ldi	r25, 0x04	; 4
    faae:	0e 94 03 7a 	call	0xf406	; 0xf406 <StoreStandaloneTransData>
    fab2:	06 c0       	rjmp	.+12     	; 0xfac0 <ScanStandaloneFlow+0xce>
		  else
          if (MsgIDx==0x02)StoreStandaloneTotalizerData(strStandReceived);
    fab4:	82 30       	cpi	r24, 0x02	; 2
    fab6:	21 f4       	brne	.+8      	; 0xfac0 <ScanStandaloneFlow+0xce>
    fab8:	85 e1       	ldi	r24, 0x15	; 21
    faba:	94 e0       	ldi	r25, 0x04	; 4
    fabc:	0e 94 6a 7c 	call	0xf8d4	; 0xf8d4 <StoreStandaloneTotalizerData>
	  }
	  //AcknoledgeCommand
	  if ((zDataFlow[3]==0x09)&&(zDataFlow[0]==0x0A)){
    fac0:	80 91 fd 02 	lds	r24, 0x02FD
    fac4:	89 30       	cpi	r24, 0x09	; 9
    fac6:	c1 f5       	brne	.+112    	; 0xfb38 <ScanStandaloneFlow+0x146>
    fac8:	80 91 fa 02 	lds	r24, 0x02FA
    facc:	8a 30       	cpi	r24, 0x0A	; 10
    face:	a1 f5       	brne	.+104    	; 0xfb38 <ScanStandaloneFlow+0x146>
	      
	      AcknoledgePump=zDataFlow[1];
    fad0:	90 91 fb 02 	lds	r25, 0x02FB
    fad4:	90 93 23 0d 	sts	0x0D23, r25
	      AcknoledgeCommand=zDataFlow[2];	  
    fad8:	80 91 fc 02 	lds	r24, 0x02FC
    fadc:	80 93 af 06 	sts	0x06AF, r24
		  switch(AcknoledgeCommand){
    fae0:	89 31       	cpi	r24, 0x19	; 25
    fae2:	51 f0       	breq	.+20     	; 0xfaf8 <ScanStandaloneFlow+0x106>
    fae4:	8a 31       	cpi	r24, 0x1A	; 26
    fae6:	18 f4       	brcc	.+6      	; 0xfaee <ScanStandaloneFlow+0xfc>
    fae8:	85 30       	cpi	r24, 0x05	; 5
    faea:	19 f5       	brne	.+70     	; 0xfb32 <ScanStandaloneFlow+0x140>
    faec:	17 c0       	rjmp	.+46     	; 0xfb1c <ScanStandaloneFlow+0x12a>
    faee:	8a 31       	cpi	r24, 0x1A	; 26
    faf0:	c9 f0       	breq	.+50     	; 0xfb24 <ScanStandaloneFlow+0x132>
    faf2:	8c 31       	cpi	r24, 0x1C	; 28
    faf4:	f1 f4       	brne	.+60     	; 0xfb32 <ScanStandaloneFlow+0x140>
    faf6:	1a c0       	rjmp	.+52     	; 0xfb2c <ScanStandaloneFlow+0x13a>
		  case SC_LIVE_SEQUENCE:
		       iSequencePooling=AcknoledgePump;
    faf8:	90 93 83 01 	sts	0x0183, r25
			   IsNewPoolingSequence=True;
    fafc:	81 e0       	ldi	r24, 0x01	; 1
    fafe:	80 93 84 01 	sts	0x0184, r24
			   //SendPoolingCommand()
			   if (IsControlPooling==True){
    fb02:	80 91 87 01 	lds	r24, 0x0187
    fb06:	81 30       	cpi	r24, 0x01	; 1
    fb08:	a1 f4       	brne	.+40     	; 0xfb32 <ScanStandaloneFlow+0x140>
			       IsControlPooling=False;
    fb0a:	10 92 87 01 	sts	0x0187, r1
				   SendSlaveCommand(PoolCmd,PoolMsg);
    fb0e:	80 91 b9 06 	lds	r24, 0x06B9
    fb12:	60 91 0a 0d 	lds	r22, 0x0D0A
    fb16:	0e 94 72 74 	call	0xe8e4	; 0xe8e4 <SendSlaveCommand>
    fb1a:	0b c0       	rjmp	.+22     	; 0xfb32 <ScanStandaloneFlow+0x140>
                }
		       break;
          case SC_TOTALIZER:
		       IsTotalizerReceived=True;
    fb1c:	81 e0       	ldi	r24, 0x01	; 1
    fb1e:	80 93 b1 01 	sts	0x01B1, r24
    fb22:	07 c0       	rjmp	.+14     	; 0xfb32 <ScanStandaloneFlow+0x140>
		       break;
		  case SC_POOL_RESTARTED:
		       IsPoolingRestarted=True;
    fb24:	81 e0       	ldi	r24, 0x01	; 1
    fb26:	80 93 86 01 	sts	0x0186, r24
    fb2a:	03 c0       	rjmp	.+6      	; 0xfb32 <ScanStandaloneFlow+0x140>
		       break;
          case SC_SET_PUMP_TYPE:
		       IsSetPumpType=True;
    fb2c:	81 e0       	ldi	r24, 0x01	; 1
    fb2e:	80 93 13 01 	sts	0x0113, r24
		       break;
		  }
       IsStandaloneAcknoledge=True;
    fb32:	81 e0       	ldi	r24, 0x01	; 1
    fb34:	80 93 85 01 	sts	0x0185, r24
	  }
}
    fb38:	1f 91       	pop	r17
    fb3a:	0f 91       	pop	r16
    fb3c:	08 95       	ret

0000fb3e <__vector_17>:
//	  sprintf(SerialSend,"Length:%i",Length);	 
//	  _uart_print(1,0,SerialSend);
	 }
}

ISR(SPI_STC_vect){
    fb3e:	1f 92       	push	r1
    fb40:	0f 92       	push	r0
    fb42:	0f b6       	in	r0, 0x3f	; 63
    fb44:	0f 92       	push	r0
    fb46:	0b b6       	in	r0, 0x3b	; 59
    fb48:	0f 92       	push	r0
    fb4a:	11 24       	eor	r1, r1
    fb4c:	1f 93       	push	r17
    fb4e:	2f 93       	push	r18
    fb50:	3f 93       	push	r19
    fb52:	4f 93       	push	r20
    fb54:	5f 93       	push	r21
    fb56:	6f 93       	push	r22
    fb58:	7f 93       	push	r23
    fb5a:	8f 93       	push	r24
    fb5c:	9f 93       	push	r25
    fb5e:	af 93       	push	r26
    fb60:	bf 93       	push	r27
    fb62:	ef 93       	push	r30
    fb64:	ff 93       	push	r31
char dataSPI;
//char Reply=0;
    //_uart(0,1,SPDR);
	dataSPI=SPDR;
    fb66:	1f b1       	in	r17, 0x0f	; 15
	ScanRFIDFlow(dataSPI);
    fb68:	81 2f       	mov	r24, r17
    fb6a:	0e 94 7c 14 	call	0x28f8	; 0x28f8 <ScanRFIDFlow>
	if (IFType==IT_SLAVE)ScanEDCFlow(dataSPI);
    fb6e:	80 91 00 01 	lds	r24, 0x0100
    fb72:	81 30       	cpi	r24, 0x01	; 1
    fb74:	21 f4       	brne	.+8      	; 0xfb7e <__vector_17+0x40>
    fb76:	81 2f       	mov	r24, r17
    fb78:	0e 94 ba 13 	call	0x2774	; 0x2774 <ScanEDCFlow>
    fb7c:	05 c0       	rjmp	.+10     	; 0xfb88 <__vector_17+0x4a>
	else
	if (IFType==IT_STANDALONE)ScanStandaloneFlow(dataSPI);
    fb7e:	82 30       	cpi	r24, 0x02	; 2
    fb80:	19 f4       	brne	.+6      	; 0xfb88 <__vector_17+0x4a>
    fb82:	81 2f       	mov	r24, r17
    fb84:	0e 94 f9 7c 	call	0xf9f2	; 0xf9f2 <ScanStandaloneFlow>
}
    fb88:	ff 91       	pop	r31
    fb8a:	ef 91       	pop	r30
    fb8c:	bf 91       	pop	r27
    fb8e:	af 91       	pop	r26
    fb90:	9f 91       	pop	r25
    fb92:	8f 91       	pop	r24
    fb94:	7f 91       	pop	r23
    fb96:	6f 91       	pop	r22
    fb98:	5f 91       	pop	r21
    fb9a:	4f 91       	pop	r20
    fb9c:	3f 91       	pop	r19
    fb9e:	2f 91       	pop	r18
    fba0:	1f 91       	pop	r17
    fba2:	0f 90       	pop	r0
    fba4:	0b be       	out	0x3b, r0	; 59
    fba6:	0f 90       	pop	r0
    fba8:	0f be       	out	0x3f, r0	; 63
    fbaa:	0f 90       	pop	r0
    fbac:	1f 90       	pop	r1
    fbae:	18 95       	reti

0000fbb0 <UserInput>:
void ShowMessage(char *Message){//Display Message on Line3
     char i;
}


char UserInput(char TypeUI,char xPos, char yPos,char *strResult, unsigned int MaxValue, char MaxLength){
    fbb0:	8f 92       	push	r8
    fbb2:	9f 92       	push	r9
    fbb4:	af 92       	push	r10
    fbb6:	bf 92       	push	r11
    fbb8:	cf 92       	push	r12
    fbba:	df 92       	push	r13
    fbbc:	ef 92       	push	r14
    fbbe:	ff 92       	push	r15
    fbc0:	0f 93       	push	r16
    fbc2:	1f 93       	push	r17
    fbc4:	cf 93       	push	r28
    fbc6:	df 93       	push	r29
    fbc8:	f8 2e       	mov	r15, r24
    fbca:	96 2e       	mov	r9, r22
    fbcc:	d4 2e       	mov	r13, r20
    fbce:	e9 01       	movw	r28, r18
    fbd0:	58 01       	movw	r10, r16
    fbd2:	8e 2c       	mov	r8, r14
	 static char iHit=0,IsShifted=False,IsSameKey=False,IsNextKey=False,IsNewKey=False,IsFirst=False;//,KeyByte=0;
	 static unsigned int iLoop=0,KeyTimeout;//,TimerPressed=0,NewKeyTimeout;
	        unsigned int NumbValue=0;
	 char KeyPressed=0,KeyChar=0,iDisp=0;
     Result=USER_NONE;
	 switch(stUserInput){// 100 ->199 500 90
    fbd4:	10 91 d2 02 	lds	r17, 0x02D2
    fbd8:	12 30       	cpi	r17, 0x02	; 2
    fbda:	09 f4       	brne	.+2      	; 0xfbde <UserInput+0x2e>
    fbdc:	29 c2       	rjmp	.+1106   	; 0x10030 <UserInput+0x480>
    fbde:	13 30       	cpi	r17, 0x03	; 3
    fbe0:	30 f4       	brcc	.+12     	; 0xfbee <UserInput+0x3e>
    fbe2:	11 23       	and	r17, r17
    fbe4:	59 f0       	breq	.+22     	; 0xfbfc <UserInput+0x4c>
    fbe6:	11 30       	cpi	r17, 0x01	; 1
    fbe8:	09 f0       	breq	.+2      	; 0xfbec <UserInput+0x3c>
    fbea:	f2 c2       	rjmp	.+1508   	; 0x101d0 <UserInput+0x620>
    fbec:	2c c0       	rjmp	.+88     	; 0xfc46 <UserInput+0x96>
    fbee:	13 30       	cpi	r17, 0x03	; 3
    fbf0:	09 f4       	brne	.+2      	; 0xfbf4 <UserInput+0x44>
    fbf2:	73 c2       	rjmp	.+1254   	; 0x100da <UserInput+0x52a>
    fbf4:	14 30       	cpi	r17, 0x04	; 4
    fbf6:	09 f0       	breq	.+2      	; 0xfbfa <UserInput+0x4a>
    fbf8:	eb c2       	rjmp	.+1494   	; 0x101d0 <UserInput+0x620>
    fbfa:	ec c2       	rjmp	.+1496   	; 0x101d4 <UserInput+0x624>
	 case uiInit:
	      iLoop=0;
    fbfc:	10 92 c4 02 	sts	0x02C4, r1
    fc00:	10 92 c3 02 	sts	0x02C3, r1
		  stUserInput=uiInput;
		  xChar=xPos;yChar=yPos;
    fc04:	60 93 d1 02 	sts	0x02D1, r22
    fc08:	40 93 d0 02 	sts	0x02D0, r20
          iValuePos=0;
    fc0c:	10 92 cf 02 	sts	0x02CF, r1
		  KeyTimeout=0;
    fc10:	10 92 c2 02 	sts	0x02C2, r1
    fc14:	10 92 c1 02 	sts	0x02C1, r1
		  IsSameKey=False;
    fc18:	10 92 c8 02 	sts	0x02C8, r1
		  IsNextKey=False;
    fc1c:	10 92 c7 02 	sts	0x02C7, r1
		  IsNewKey=False;
    fc20:	10 92 c6 02 	sts	0x02C6, r1
		  IsShifted=True;
    fc24:	91 e0       	ldi	r25, 0x01	; 1
    fc26:	90 93 c9 02 	sts	0x02C9, r25
		  zKeyChar=' ';
    fc2a:	80 e2       	ldi	r24, 0x20	; 32
    fc2c:	80 93 ce 02 	sts	0x02CE, r24
		  iHit=0;
    fc30:	10 92 ca 02 	sts	0x02CA, r1
		  IsFirst=False;
    fc34:	10 92 c5 02 	sts	0x02C5, r1
		  IsDelete=False;
    fc38:	10 92 cb 02 	sts	0x02CB, r1
		  Result=USER_NO_DATA;
		  stUserInput=uiInput;
    fc3c:	90 93 d2 02 	sts	0x02D2, r25
    fc40:	b5 e0       	ldi	r27, 0x05	; 5
    fc42:	eb 2e       	mov	r14, r27
    fc44:	cb c2       	rjmp	.+1430   	; 0x101dc <UserInput+0x62c>
	      break;
	 case uiInput:
	      KeyPressed=_key_scan(1);                  //  _  ABC DEF GHI JKL MNO PQRS TUV WXYZ
    fc46:	81 e0       	ldi	r24, 0x01	; 1
    fc48:	0e 94 84 ae 	call	0x15d08	; 0x15d08 <_key_scan>
    fc4c:	c8 2e       	mov	r12, r24
		  KeyChar= _key_btn(KeyPressed);            //  1   2   3   4   5   6   7    8   9
    fc4e:	0e 94 e5 ad 	call	0x15bca	; 0x15bca <_key_btn>
    fc52:	e8 2e       	mov	r14, r24
		  if (KeyPressed==_KEY_SHIFT){
    fc54:	2b e7       	ldi	r18, 0x7B	; 123
    fc56:	c2 16       	cp	r12, r18
    fc58:	59 f4       	brne	.+22     	; 0xfc70 <UserInput+0xc0>
		      if (IsShifted==False)IsShifted=True;
    fc5a:	80 91 c9 02 	lds	r24, 0x02C9
    fc5e:	88 23       	and	r24, r24
    fc60:	19 f4       	brne	.+6      	; 0xfc68 <UserInput+0xb8>
    fc62:	10 93 c9 02 	sts	0x02C9, r17
    fc66:	04 c0       	rjmp	.+8      	; 0xfc70 <UserInput+0xc0>
			  else
		      if (IsShifted==True)IsShifted=False;
    fc68:	81 30       	cpi	r24, 0x01	; 1
    fc6a:	11 f4       	brne	.+4      	; 0xfc70 <UserInput+0xc0>
    fc6c:	10 92 c9 02 	sts	0x02C9, r1
			  }
          
		  if (IsSameKey==True){
    fc70:	80 91 c8 02 	lds	r24, 0x02C8
    fc74:	81 30       	cpi	r24, 0x01	; 1
    fc76:	e9 f4       	brne	.+58     	; 0xfcb2 <UserInput+0x102>
		      KeyTimeout++;
    fc78:	80 91 c1 02 	lds	r24, 0x02C1
    fc7c:	90 91 c2 02 	lds	r25, 0x02C2
    fc80:	01 96       	adiw	r24, 0x01	; 1
    fc82:	90 93 c2 02 	sts	0x02C2, r25
    fc86:	80 93 c1 02 	sts	0x02C1, r24
              if (KeyTimeout>1000){
    fc8a:	89 5e       	subi	r24, 0xE9	; 233
    fc8c:	93 40       	sbci	r25, 0x03	; 3
    fc8e:	88 f0       	brcs	.+34     	; 0xfcb2 <UserInput+0x102>
			      if (TypeUI==UI_ALPHANUM_PASSWORD)lcd_put(xChar,yChar,'*');
    fc90:	f5 e0       	ldi	r31, 0x05	; 5
    fc92:	ff 16       	cp	r15, r31
    fc94:	39 f4       	brne	.+14     	; 0xfca4 <UserInput+0xf4>
    fc96:	80 91 d1 02 	lds	r24, 0x02D1
    fc9a:	60 91 d0 02 	lds	r22, 0x02D0
    fc9e:	4a e2       	ldi	r20, 0x2A	; 42
    fca0:	0e 94 58 ad 	call	0x15ab0	; 0x15ab0 <lcd_put>

		          IsNextKey=True;
    fca4:	81 e0       	ldi	r24, 0x01	; 1
    fca6:	80 93 c7 02 	sts	0x02C7, r24
				  iLoop=0;
    fcaa:	10 92 c4 02 	sts	0x02C4, r1
    fcae:	10 92 c3 02 	sts	0x02C3, r1
			     }
              }
            
 
 		  //if (((KeyChar>='0')&&(KeyChar<='9')&&(iValuePos<=MaxLength))||(IsNextKey==True)){
		  if (((KeyChar>='0')&&(KeyChar<='9')&&(iValuePos<MaxLength))||(IsNextKey==True)){
    fcb2:	8e 2d       	mov	r24, r14
    fcb4:	80 53       	subi	r24, 0x30	; 48
    fcb6:	8a 30       	cpi	r24, 0x0A	; 10
    fcb8:	20 f4       	brcc	.+8      	; 0xfcc2 <UserInput+0x112>
    fcba:	80 91 cf 02 	lds	r24, 0x02CF
    fcbe:	88 15       	cp	r24, r8
    fcc0:	40 f0       	brcs	.+16     	; 0xfcd2 <UserInput+0x122>
    fcc2:	80 91 c7 02 	lds	r24, 0x02C7
    fcc6:	81 30       	cpi	r24, 0x01	; 1
    fcc8:	21 f0       	breq	.+8      	; 0xfcd2 <UserInput+0x122>
    fcca:	ee 24       	eor	r14, r14
    fccc:	00 e0       	ldi	r16, 0x00	; 0
    fcce:	10 e0       	ldi	r17, 0x00	; 0
    fcd0:	be c0       	rjmp	.+380    	; 0xfe4e <UserInput+0x29e>
    fcd2:	84 e2       	ldi	r24, 0x24	; 36
    fcd4:	94 ef       	ldi	r25, 0xF4	; 244
    fcd6:	01 97       	sbiw	r24, 0x01	; 1
    fcd8:	f1 f7       	brne	.-4      	; 0xfcd6 <UserInput+0x126>
		       _delay_ms(250);
		       strResult[iValuePos]=KeyChar;
    fcda:	80 91 cf 02 	lds	r24, 0x02CF
    fcde:	fe 01       	movw	r30, r28
    fce0:	e8 0f       	add	r30, r24
    fce2:	f1 1d       	adc	r31, r1
    fce4:	e0 82       	st	Z, r14
		       strResult[iValuePos+1]=0;
    fce6:	11 82       	std	Z+1, r1	; 0x01

			   if ((TypeUI==UI_NUMBER_R)||(TypeUI==UI_NUMBER_L)||(TypeUI==UI_NUM_PASSWORD)) 
    fce8:	8f 2d       	mov	r24, r15
    fcea:	81 50       	subi	r24, 0x01	; 1
    fcec:	82 30       	cpi	r24, 0x02	; 2
    fcee:	30 f0       	brcs	.+12     	; 0xfcfc <UserInput+0x14c>
    fcf0:	24 e0       	ldi	r18, 0x04	; 4
    fcf2:	f2 16       	cp	r15, r18
    fcf4:	19 f0       	breq	.+6      	; 0xfcfc <UserInput+0x14c>
    fcf6:	00 e0       	ldi	r16, 0x00	; 0
    fcf8:	10 e0       	ldi	r17, 0x00	; 0
    fcfa:	04 c0       	rjmp	.+8      	; 0xfd04 <UserInput+0x154>
			        NumbValue=atoi(strResult);
    fcfc:	ce 01       	movw	r24, r28
    fcfe:	0e 94 c3 b3 	call	0x16786	; 0x16786 <atoi>
    fd02:	8c 01       	movw	r16, r24
			   else NumbValue=0;
				
			   if ((TypeUI==UI_ALPHANUM_R)||(TypeUI==UI_ALPHANUM_PASSWORD)){
    fd04:	83 e0       	ldi	r24, 0x03	; 3
    fd06:	f8 16       	cp	r15, r24
    fd08:	21 f0       	breq	.+8      	; 0xfd12 <UserInput+0x162>
    fd0a:	e5 e0       	ldi	r30, 0x05	; 5
    fd0c:	fe 16       	cp	r15, r30
    fd0e:	09 f0       	breq	.+2      	; 0xfd12 <UserInput+0x162>
    fd10:	63 c0       	rjmp	.+198    	; 0xfdd8 <UserInput+0x228>
			       if (KeyChar!=zKeyChar){
    fd12:	80 91 ce 02 	lds	r24, 0x02CE
    fd16:	e8 16       	cp	r14, r24
    fd18:	71 f0       	breq	.+28     	; 0xfd36 <UserInput+0x186>
					   IsSameKey=False;
    fd1a:	10 92 c8 02 	sts	0x02C8, r1
					   IsNewKey=True;
    fd1e:	81 e0       	ldi	r24, 0x01	; 1
    fd20:	80 93 c6 02 	sts	0x02C6, r24
				       iHit=0;
    fd24:	10 92 ca 02 	sts	0x02CA, r1
					   iLoop=1000;
    fd28:	88 ee       	ldi	r24, 0xE8	; 232
    fd2a:	93 e0       	ldi	r25, 0x03	; 3
    fd2c:	90 93 c4 02 	sts	0x02C4, r25
    fd30:	80 93 c3 02 	sts	0x02C3, r24
    fd34:	51 c0       	rjmp	.+162    	; 0xfdd8 <UserInput+0x228>
				   }
                   else{
				   if (IsNewKey==True){
    fd36:	80 91 c6 02 	lds	r24, 0x02C6
    fd3a:	81 30       	cpi	r24, 0x01	; 1
    fd3c:	71 f4       	brne	.+28     	; 0xfd5a <UserInput+0x1aa>
					   IsNewKey=False;
    fd3e:	10 92 c6 02 	sts	0x02C6, r1
					   yChar--;
    fd42:	80 91 d0 02 	lds	r24, 0x02D0
    fd46:	81 50       	subi	r24, 0x01	; 1
    fd48:	80 93 d0 02 	sts	0x02D0, r24
					   if (iValuePos>0) iValuePos--;
    fd4c:	80 91 cf 02 	lds	r24, 0x02CF
    fd50:	88 23       	and	r24, r24
    fd52:	19 f0       	breq	.+6      	; 0xfd5a <UserInput+0x1aa>
    fd54:	81 50       	subi	r24, 0x01	; 1
    fd56:	80 93 cf 02 	sts	0x02CF, r24
					   }
				   KeyTimeout=0;
    fd5a:	10 92 c2 02 	sts	0x02C2, r1
    fd5e:	10 92 c1 02 	sts	0x02C1, r1
				   IsSameKey=True;
    fd62:	81 e0       	ldi	r24, 0x01	; 1
    fd64:	80 93 c8 02 	sts	0x02C8, r24
				   if (iHit<pgm_read_byte(&MaxKeyHit[(zKeyChar-'0')])) 
    fd68:	80 91 ca 02 	lds	r24, 0x02CA
    fd6c:	e0 91 ce 02 	lds	r30, 0x02CE
    fd70:	f0 e0       	ldi	r31, 0x00	; 0
    fd72:	e8 56       	subi	r30, 0x68	; 104
    fd74:	fd 4f       	sbci	r31, 0xFD	; 253
    fd76:	e4 91       	lpm	r30, Z+
    fd78:	8e 17       	cp	r24, r30
    fd7a:	20 f4       	brcc	.+8      	; 0xfd84 <UserInput+0x1d4>
				        iHit++;
    fd7c:	8f 5f       	subi	r24, 0xFF	; 255
    fd7e:	80 93 ca 02 	sts	0x02CA, r24
    fd82:	02 c0       	rjmp	.+4      	; 0xfd88 <UserInput+0x1d8>
                   else iHit=0;
    fd84:	10 92 ca 02 	sts	0x02CA, r1
				   iLoop=1000;
    fd88:	88 ee       	ldi	r24, 0xE8	; 232
    fd8a:	93 e0       	ldi	r25, 0x03	; 3
    fd8c:	90 93 c4 02 	sts	0x02C4, r25
    fd90:	80 93 c3 02 	sts	0x02C3, r24

                   zAlphaChar=AlphaChar;
    fd94:	80 91 cc 02 	lds	r24, 0x02CC
    fd98:	80 93 cd 02 	sts	0x02CD, r24
			       AlphaChar=_table_alphanum(IsShifted,KeyPressed,iHit);			   
    fd9c:	80 91 c9 02 	lds	r24, 0x02C9
    fda0:	6c 2d       	mov	r22, r12
    fda2:	40 91 ca 02 	lds	r20, 0x02CA
    fda6:	0e 94 37 ae 	call	0x15c6e	; 0x15c6e <_table_alphanum>
    fdaa:	80 93 cc 02 	sts	0x02CC, r24
                   
				   if (IsNextKey==True){
    fdae:	80 91 c7 02 	lds	r24, 0x02C7
    fdb2:	81 30       	cpi	r24, 0x01	; 1
    fdb4:	41 f4       	brne	.+16     	; 0xfdc6 <UserInput+0x216>
                       AlphaChar=zAlphaChar;       
    fdb6:	80 91 cd 02 	lds	r24, 0x02CD
    fdba:	80 93 cc 02 	sts	0x02CC, r24
					   IsNextKey=False;
    fdbe:	10 92 c7 02 	sts	0x02C7, r1
					   IsSameKey=False;
    fdc2:	10 92 c8 02 	sts	0x02C8, r1
				   }   
				   strResult[iValuePos]=AlphaChar;
    fdc6:	80 91 cf 02 	lds	r24, 0x02CF
    fdca:	fe 01       	movw	r30, r28
    fdcc:	e8 0f       	add	r30, r24
    fdce:	f1 1d       	adc	r31, r1
    fdd0:	80 91 cc 02 	lds	r24, 0x02CC
    fdd4:	80 83       	st	Z, r24
		           strResult[iValuePos+1]=0;
    fdd6:	11 82       	std	Z+1, r1	; 0x01
				 }//endElse 
				 
			   }//EndAlphaNum

			 if (TypeUI==UI_NUMBER_L){
    fdd8:	f2 e0       	ldi	r31, 0x02	; 2
    fdda:	ff 16       	cp	r15, r31
    fddc:	71 f4       	brne	.+28     	; 0xfdfa <UserInput+0x24a>
			    if ((NumbValue<=MaxValue)||(MaxValue==0)){
    fdde:	a0 16       	cp	r10, r16
    fde0:	b1 06       	cpc	r11, r17
    fde2:	18 f4       	brcc	.+6      	; 0xfdea <UserInput+0x23a>
    fde4:	a1 14       	cp	r10, r1
    fde6:	b1 04       	cpc	r11, r1
    fde8:	71 f5       	brne	.+92     	; 0xfe46 <UserInput+0x296>
				     iValuePos++;
    fdea:	80 91 cf 02 	lds	r24, 0x02CF
    fdee:	8f 5f       	subi	r24, 0xFF	; 255
    fdf0:	80 93 cf 02 	sts	0x02CF, r24
					 stUserInput=uiInputDisp;
    fdf4:	83 e0       	ldi	r24, 0x03	; 3
    fdf6:	80 93 d2 02 	sts	0x02D2, r24
				} 
			 }
  
			   if ((NumbValue<=MaxValue)||(MaxValue==0)){
    fdfa:	a0 16       	cp	r10, r16
    fdfc:	b1 06       	cpc	r11, r17
    fdfe:	18 f4       	brcc	.+6      	; 0xfe06 <UserInput+0x256>
    fe00:	a1 14       	cp	r10, r1
    fe02:	b1 04       	cpc	r11, r1
    fe04:	01 f5       	brne	.+64     	; 0xfe46 <UserInput+0x296>
			       if ((TypeUI==UI_NUMBER_R)||(TypeUI==UI_ALPHANUM_R)||
    fe06:	21 e0       	ldi	r18, 0x01	; 1
    fe08:	f2 16       	cp	r15, r18
    fe0a:	49 f0       	breq	.+18     	; 0xfe1e <UserInput+0x26e>
    fe0c:	83 e0       	ldi	r24, 0x03	; 3
    fe0e:	f8 16       	cp	r15, r24
    fe10:	31 f0       	breq	.+12     	; 0xfe1e <UserInput+0x26e>
    fe12:	e4 e0       	ldi	r30, 0x04	; 4
    fe14:	fe 16       	cp	r15, r30
    fe16:	19 f0       	breq	.+6      	; 0xfe1e <UserInput+0x26e>
    fe18:	f5 e0       	ldi	r31, 0x05	; 5
    fe1a:	ff 16       	cp	r15, r31
    fe1c:	a1 f4       	brne	.+40     	; 0xfe46 <UserInput+0x296>
				       (TypeUI==UI_NUM_PASSWORD)||(TypeUI==UI_ALPHANUM_PASSWORD)){
				      if (IsSameKey==False){
    fe1e:	80 91 c8 02 	lds	r24, 0x02C8
    fe22:	88 23       	and	r24, r24
    fe24:	69 f4       	brne	.+26     	; 0xfe40 <UserInput+0x290>
					      IsFirst=True;
    fe26:	81 e0       	ldi	r24, 0x01	; 1
    fe28:	80 93 c5 02 	sts	0x02C5, r24
					      iValuePos++;
    fe2c:	80 91 cf 02 	lds	r24, 0x02CF
    fe30:	8f 5f       	subi	r24, 0xFF	; 255
    fe32:	80 93 cf 02 	sts	0x02CF, r24
						  //FullEntry
						  if (iValuePos==MaxLength)Result=USER_FULL_ENTRY;
					      yChar++;
    fe36:	80 91 d0 02 	lds	r24, 0x02D0
    fe3a:	8f 5f       	subi	r24, 0xFF	; 255
    fe3c:	80 93 d0 02 	sts	0x02D0, r24
						  //yChar=(yChar+1;//Max Display

						  }
                  stUserInput=uiInputDisp;
    fe40:	83 e0       	ldi	r24, 0x03	; 3
    fe42:	80 93 d2 02 	sts	0x02D2, r24
				  }
			   }
              zKeyChar=KeyChar;
    fe46:	e0 92 ce 02 	sts	0x02CE, r14
    fe4a:	a4 e0       	ldi	r26, 0x04	; 4
    fe4c:	ea 2e       	mov	r14, r26
             Result=USER_ENTRY;
             }//EndKeyChar
			 
                 
              if ((TypeUI==UI_NUMBER_R)||(TypeUI==UI_NUMBER_L)||(TypeUI==UI_NUM_PASSWORD)){
    fe4e:	9f 2d       	mov	r25, r15
    fe50:	91 50       	subi	r25, 0x01	; 1
    fe52:	92 30       	cpi	r25, 0x02	; 2
    fe54:	18 f0       	brcs	.+6      	; 0xfe5c <UserInput+0x2ac>
    fe56:	24 e0       	ldi	r18, 0x04	; 4
    fe58:	f2 16       	cp	r15, r18
    fe5a:	71 f4       	brne	.+28     	; 0xfe78 <UserInput+0x2c8>
                   if((NumbValue>MaxValue)||(iValuePos==MaxLength)){
    fe5c:	a0 16       	cp	r10, r16
    fe5e:	b1 06       	cpc	r11, r17
    fe60:	20 f0       	brcs	.+8      	; 0xfe6a <UserInput+0x2ba>
    fe62:	80 91 cf 02 	lds	r24, 0x02CF
    fe66:	88 15       	cp	r24, r8
    fe68:	39 f4       	brne	.+14     	; 0xfe78 <UserInput+0x2c8>
			           if (MaxValue>0)system_beep(1);
    fe6a:	ab 28       	or	r10, r11
    fe6c:	29 f0       	breq	.+10     	; 0xfe78 <UserInput+0x2c8>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    fe6e:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    fe70:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    fe72:	81 e0       	ldi	r24, 0x01	; 1
    fe74:	80 93 bf 01 	sts	0x01BF, r24
			           if (MaxValue>0)system_beep(1);
				   }
                 }
		  
		  //CANCEL OK
		  if (KeyPressed==_KEY_CANCEL){
    fe78:	87 ee       	ldi	r24, 0xE7	; 231
    fe7a:	c8 16       	cp	r12, r24
    fe7c:	71 f4       	brne	.+28     	; 0xfe9a <UserInput+0x2ea>
		      if (iValuePos>0){
    fe7e:	80 91 cf 02 	lds	r24, 0x02CF
    fe82:	88 23       	and	r24, r24
    fe84:	41 f0       	breq	.+16     	; 0xfe96 <UserInput+0x2e6>
			      iLoop=1999;
    fe86:	8f ec       	ldi	r24, 0xCF	; 207
    fe88:	97 e0       	ldi	r25, 0x07	; 7
    fe8a:	90 93 c4 02 	sts	0x02C4, r25
    fe8e:	80 93 c3 02 	sts	0x02C3, r24
				  stUserInput=uiClearDisplay;
    fe92:	82 e0       	ldi	r24, 0x02	; 2
    fe94:	26 c0       	rjmp	.+76     	; 0xfee2 <UserInput+0x332>
				  }
			  else{
			      UserInputResult=USER_CANCEL;
    fe96:	81 e0       	ldi	r24, 0x01	; 1
    fe98:	21 c0       	rjmp	.+66     	; 0xfedc <UserInput+0x32c>
			      stUserInput=uiFinished;
				  }
		  }
		  else {
		  if (KeyPressed==_KEY_ENTER){
    fe9a:	e7 eb       	ldi	r30, 0xB7	; 183
    fe9c:	ce 16       	cp	r12, r30
    fe9e:	19 f5       	brne	.+70     	; 0xfee6 <UserInput+0x336>
		      strResult[iValuePos]=0;
    fea0:	80 91 cf 02 	lds	r24, 0x02CF
    fea4:	fe 01       	movw	r30, r28
    fea6:	e8 0f       	add	r30, r24
    fea8:	f1 1d       	adc	r31, r1
    feaa:	10 82       	st	Z, r1
			  if ((TypeUI==UI_NUMBER_R)||(TypeUI==UI_NUMBER_L)){
    feac:	92 30       	cpi	r25, 0x02	; 2
    feae:	a8 f4       	brcc	.+42     	; 0xfeda <UserInput+0x32a>
			       if (iValuePos==0)sprintf_P(strResult,PSTR("0"));
    feb0:	88 23       	and	r24, r24
    feb2:	81 f4       	brne	.+32     	; 0xfed4 <UserInput+0x324>
    feb4:	00 d0       	rcall	.+0      	; 0xfeb6 <UserInput+0x306>
    feb6:	00 d0       	rcall	.+0      	; 0xfeb8 <UserInput+0x308>
    feb8:	ed b7       	in	r30, 0x3d	; 61
    feba:	fe b7       	in	r31, 0x3e	; 62
    febc:	d2 83       	std	Z+2, r29	; 0x02
    febe:	c1 83       	std	Z+1, r28	; 0x01
    fec0:	8e ef       	ldi	r24, 0xFE	; 254
    fec2:	9b e1       	ldi	r25, 0x1B	; 27
    fec4:	94 83       	std	Z+4, r25	; 0x04
    fec6:	83 83       	std	Z+3, r24	; 0x03
    fec8:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    fecc:	0f 90       	pop	r0
    fece:	0f 90       	pop	r0
    fed0:	0f 90       	pop	r0
    fed2:	0f 90       	pop	r0
			       RemZeroLead(strResult);
    fed4:	ce 01       	movw	r24, r28
    fed6:	0e 94 19 25 	call	0x4a32	; 0x4a32 <RemZeroLead>
				  }
		      UserInputResult=USER_OK;
    feda:	83 e0       	ldi	r24, 0x03	; 3
    fedc:	80 93 d3 02 	sts	0x02D3, r24
		      stUserInput=uiFinished;
    fee0:	84 e0       	ldi	r24, 0x04	; 4
    fee2:	80 93 d2 02 	sts	0x02D2, r24
			  }
		  }//EndElse

		  if ((iLoop%2000)==0){
    fee6:	80 91 c3 02 	lds	r24, 0x02C3
    feea:	90 91 c4 02 	lds	r25, 0x02C4
    feee:	60 ed       	ldi	r22, 0xD0	; 208
    fef0:	77 e0       	ldi	r23, 0x07	; 7
    fef2:	0e 94 0a b7 	call	0x16e14	; 0x16e14 <__udivmodhi4>
    fef6:	89 2b       	or	r24, r25
    fef8:	09 f0       	breq	.+2      	; 0xfefc <UserInput+0x34c>
    fefa:	4b c0       	rjmp	.+150    	; 0xff92 <UserInput+0x3e2>
		      if (IsSameKey==True)
    fefc:	80 91 c8 02 	lds	r24, 0x02C8
    ff00:	81 30       	cpi	r24, 0x01	; 1
    ff02:	c9 f4       	brne	.+50     	; 0xff36 <UserInput+0x386>
			      //lcd_put(xChar,yChar,AlphaChar); 
				  lcd_put(xPos+((yPos+iValuePos-1)/20),yPos+(iValuePos%20),AlphaChar); 
    ff04:	20 91 cf 02 	lds	r18, 0x02CF
    ff08:	82 2f       	mov	r24, r18
    ff0a:	90 e0       	ldi	r25, 0x00	; 0
    ff0c:	01 97       	sbiw	r24, 0x01	; 1
    ff0e:	8d 0d       	add	r24, r13
    ff10:	91 1d       	adc	r25, r1
    ff12:	64 e1       	ldi	r22, 0x14	; 20
    ff14:	70 e0       	ldi	r23, 0x00	; 0
    ff16:	0e 94 1e b7 	call	0x16e3c	; 0x16e3c <__divmodhi4>
    ff1a:	36 2f       	mov	r19, r22
    ff1c:	82 2f       	mov	r24, r18
    ff1e:	64 e1       	ldi	r22, 0x14	; 20
    ff20:	0e 94 f1 b6 	call	0x16de2	; 0x16de2 <__udivmodqi4>
    ff24:	6d 2d       	mov	r22, r13
    ff26:	69 0f       	add	r22, r25
    ff28:	89 2d       	mov	r24, r9
    ff2a:	83 0f       	add	r24, r19
    ff2c:	40 91 cc 02 	lds	r20, 0x02CC
    ff30:	0e 94 58 ad 	call	0x15ab0	; 0x15ab0 <lcd_put>
    ff34:	2e c0       	rjmp	.+92     	; 0xff92 <UserInput+0x3e2>
			  else {
			      if((TypeUI==UI_ALPHANUM_PASSWORD)&&(iValuePos>0))lcd_put(xChar,yChar-1,'*'); 
    ff36:	f5 e0       	ldi	r31, 0x05	; 5
    ff38:	ff 16       	cp	r15, r31
    ff3a:	61 f4       	brne	.+24     	; 0xff54 <UserInput+0x3a4>
    ff3c:	80 91 cf 02 	lds	r24, 0x02CF
    ff40:	88 23       	and	r24, r24
    ff42:	41 f0       	breq	.+16     	; 0xff54 <UserInput+0x3a4>
    ff44:	60 91 d0 02 	lds	r22, 0x02D0
    ff48:	61 50       	subi	r22, 0x01	; 1
    ff4a:	80 91 d1 02 	lds	r24, 0x02D1
    ff4e:	4a e2       	ldi	r20, 0x2A	; 42
    ff50:	0e 94 58 ad 	call	0x15ab0	; 0x15ab0 <lcd_put>
			      //lcd_put(xChar,yChar,'_'); 
				  lcd_put(xPos+((yPos+iValuePos-1)/20),yPos+(iValuePos%20),'_'); 
    ff54:	20 91 cf 02 	lds	r18, 0x02CF
    ff58:	82 2f       	mov	r24, r18
    ff5a:	90 e0       	ldi	r25, 0x00	; 0
    ff5c:	01 97       	sbiw	r24, 0x01	; 1
    ff5e:	8d 0d       	add	r24, r13
    ff60:	91 1d       	adc	r25, r1
    ff62:	64 e1       	ldi	r22, 0x14	; 20
    ff64:	70 e0       	ldi	r23, 0x00	; 0
    ff66:	0e 94 1e b7 	call	0x16e3c	; 0x16e3c <__divmodhi4>
    ff6a:	36 2f       	mov	r19, r22
    ff6c:	82 2f       	mov	r24, r18
    ff6e:	64 e1       	ldi	r22, 0x14	; 20
    ff70:	0e 94 f1 b6 	call	0x16de2	; 0x16de2 <__udivmodqi4>
    ff74:	6d 2d       	mov	r22, r13
    ff76:	69 0f       	add	r22, r25
    ff78:	89 2d       	mov	r24, r9
    ff7a:	83 0f       	add	r24, r19
    ff7c:	4f e5       	ldi	r20, 0x5F	; 95
    ff7e:	0e 94 58 ad 	call	0x15ab0	; 0x15ab0 <lcd_put>

				  if (IsFirst==True){
    ff82:	80 91 c5 02 	lds	r24, 0x02C5
    ff86:	81 30       	cpi	r24, 0x01	; 1
    ff88:	21 f4       	brne	.+8      	; 0xff92 <UserInput+0x3e2>
				      IsFirst=False;
    ff8a:	10 92 c5 02 	sts	0x02C5, r1
				      zKeyChar=0;
    ff8e:	10 92 ce 02 	sts	0x02CE, r1
					  }
				  }
			  }
          if ((iLoop%2000)==1000){
    ff92:	80 91 c3 02 	lds	r24, 0x02C3
    ff96:	90 91 c4 02 	lds	r25, 0x02C4
    ff9a:	60 ed       	ldi	r22, 0xD0	; 208
    ff9c:	77 e0       	ldi	r23, 0x07	; 7
    ff9e:	0e 94 0a b7 	call	0x16e14	; 0x16e14 <__udivmodhi4>
    ffa2:	88 5e       	subi	r24, 0xE8	; 232
    ffa4:	93 40       	sbci	r25, 0x03	; 3
    ffa6:	d1 f5       	brne	.+116    	; 0x1001c <UserInput+0x46c>
		      if (IsSameKey==True){
    ffa8:	80 91 c8 02 	lds	r24, 0x02C8
    ffac:	81 30       	cpi	r24, 0x01	; 1
    ffae:	f9 f4       	brne	.+62     	; 0xffee <UserInput+0x43e>
			      if (TypeUI!=UI_NUM_PASSWORD)
    ffb0:	84 e0       	ldi	r24, 0x04	; 4
    ffb2:	f8 16       	cp	r15, r24
    ffb4:	b1 f0       	breq	.+44     	; 0xffe2 <UserInput+0x432>
				       //lcd_put(xChar,yChar,AlphaChar); 
					   lcd_put(xPos+((yPos+iValuePos-1)/20),yChar%21,AlphaChar); 
    ffb6:	80 91 cf 02 	lds	r24, 0x02CF
    ffba:	90 e0       	ldi	r25, 0x00	; 0
    ffbc:	01 97       	sbiw	r24, 0x01	; 1
    ffbe:	8d 0d       	add	r24, r13
    ffc0:	91 1d       	adc	r25, r1
    ffc2:	64 e1       	ldi	r22, 0x14	; 20
    ffc4:	70 e0       	ldi	r23, 0x00	; 0
    ffc6:	0e 94 1e b7 	call	0x16e3c	; 0x16e3c <__divmodhi4>
    ffca:	26 2f       	mov	r18, r22
    ffcc:	80 91 d0 02 	lds	r24, 0x02D0
    ffd0:	65 e1       	ldi	r22, 0x15	; 21
    ffd2:	0e 94 f1 b6 	call	0x16de2	; 0x16de2 <__udivmodqi4>
    ffd6:	89 2d       	mov	r24, r9
    ffd8:	82 0f       	add	r24, r18
    ffda:	69 2f       	mov	r22, r25
    ffdc:	40 91 cc 02 	lds	r20, 0x02CC
    ffe0:	1b c0       	rjmp	.+54     	; 0x10018 <UserInput+0x468>
					   
				  else lcd_put(xChar,yChar,'*'); 
    ffe2:	80 91 d1 02 	lds	r24, 0x02D1
    ffe6:	60 91 d0 02 	lds	r22, 0x02D0
    ffea:	4a e2       	ldi	r20, 0x2A	; 42
    ffec:	15 c0       	rjmp	.+42     	; 0x10018 <UserInput+0x468>
			  }
			  //else lcd_put(xChar,yChar,' '); 
			  else lcd_put(xPos+((yPos+iValuePos-1)/20),yPos+(iValuePos%20),' '); 			  
    ffee:	20 91 cf 02 	lds	r18, 0x02CF
    fff2:	82 2f       	mov	r24, r18
    fff4:	90 e0       	ldi	r25, 0x00	; 0
    fff6:	01 97       	sbiw	r24, 0x01	; 1
    fff8:	8d 0d       	add	r24, r13
    fffa:	91 1d       	adc	r25, r1
    fffc:	64 e1       	ldi	r22, 0x14	; 20
    fffe:	70 e0       	ldi	r23, 0x00	; 0
   10000:	0e 94 1e b7 	call	0x16e3c	; 0x16e3c <__divmodhi4>
   10004:	36 2f       	mov	r19, r22
   10006:	82 2f       	mov	r24, r18
   10008:	64 e1       	ldi	r22, 0x14	; 20
   1000a:	0e 94 f1 b6 	call	0x16de2	; 0x16de2 <__udivmodqi4>
   1000e:	d9 0e       	add	r13, r25
   10010:	89 2d       	mov	r24, r9
   10012:	83 0f       	add	r24, r19
   10014:	6d 2d       	mov	r22, r13
   10016:	40 e2       	ldi	r20, 0x20	; 32
   10018:	0e 94 58 ad 	call	0x15ab0	; 0x15ab0 <lcd_put>
			  }
          iLoop++;
   1001c:	80 91 c3 02 	lds	r24, 0x02C3
   10020:	90 91 c4 02 	lds	r25, 0x02C4
   10024:	01 96       	adiw	r24, 0x01	; 1
   10026:	90 93 c4 02 	sts	0x02C4, r25
   1002a:	80 93 c3 02 	sts	0x02C3, r24
   1002e:	d6 c0       	rjmp	.+428    	; 0x101dc <UserInput+0x62c>
          break;
     case uiClearDisplay:
          if (TypeUI==UI_NUMBER_L){
   10030:	e2 e0       	ldi	r30, 0x02	; 2
   10032:	8e 17       	cp	r24, r30
   10034:	99 f4       	brne	.+38     	; 0x1005c <UserInput+0x4ac>
		      lcd_put(xChar,(yChar-iValuePos),' '); // 123_ 1_
   10036:	60 91 d0 02 	lds	r22, 0x02D0
   1003a:	80 91 cf 02 	lds	r24, 0x02CF
   1003e:	68 1b       	sub	r22, r24
   10040:	80 91 d1 02 	lds	r24, 0x02D1
   10044:	40 e2       	ldi	r20, 0x20	; 32
   10046:	0e 94 58 ad 	call	0x15ab0	; 0x15ab0 <lcd_put>
		      strResult[iValuePos]=0;
   1004a:	80 91 cf 02 	lds	r24, 0x02CF
   1004e:	c8 0f       	add	r28, r24
   10050:	d1 1d       	adc	r29, r1
   10052:	18 82       	st	Y, r1
		      iValuePos--;
   10054:	81 50       	subi	r24, 0x01	; 1
   10056:	80 93 cf 02 	sts	0x02CF, r24
   1005a:	33 c0       	rjmp	.+102    	; 0x100c2 <UserInput+0x512>
			  }
          else
		  if ((TypeUI==UI_NUMBER_R)||(TypeUI==UI_ALPHANUM_R)||
   1005c:	f1 e0       	ldi	r31, 0x01	; 1
   1005e:	8f 17       	cp	r24, r31
   10060:	49 f0       	breq	.+18     	; 0x10074 <UserInput+0x4c4>
   10062:	23 e0       	ldi	r18, 0x03	; 3
   10064:	82 17       	cp	r24, r18
   10066:	31 f0       	breq	.+12     	; 0x10074 <UserInput+0x4c4>
   10068:	84 e0       	ldi	r24, 0x04	; 4
   1006a:	f8 16       	cp	r15, r24
   1006c:	19 f0       	breq	.+6      	; 0x10074 <UserInput+0x4c4>
   1006e:	e5 e0       	ldi	r30, 0x05	; 5
   10070:	fe 16       	cp	r15, r30
   10072:	39 f5       	brne	.+78     	; 0x100c2 <UserInput+0x512>
		      (TypeUI==UI_NUM_PASSWORD)||(TypeUI==UI_ALPHANUM_PASSWORD)){
		      //lcd_put(xChar,yChar,' '); // 123_ 1_
			  lcd_put(xPos+((yPos+iValuePos-1)/20),yPos+(iValuePos%20),' '); // 123_ 1_
   10074:	20 91 cf 02 	lds	r18, 0x02CF
   10078:	82 2f       	mov	r24, r18
   1007a:	90 e0       	ldi	r25, 0x00	; 0
   1007c:	01 97       	sbiw	r24, 0x01	; 1
   1007e:	8d 0d       	add	r24, r13
   10080:	91 1d       	adc	r25, r1
   10082:	64 e1       	ldi	r22, 0x14	; 20
   10084:	70 e0       	ldi	r23, 0x00	; 0
   10086:	0e 94 1e b7 	call	0x16e3c	; 0x16e3c <__divmodhi4>
   1008a:	36 2f       	mov	r19, r22
   1008c:	82 2f       	mov	r24, r18
   1008e:	64 e1       	ldi	r22, 0x14	; 20
   10090:	0e 94 f1 b6 	call	0x16de2	; 0x16de2 <__udivmodqi4>
   10094:	d9 0e       	add	r13, r25
   10096:	89 2d       	mov	r24, r9
   10098:	83 0f       	add	r24, r19
   1009a:	6d 2d       	mov	r22, r13
   1009c:	40 e2       	ldi	r20, 0x20	; 32
   1009e:	0e 94 58 ad 	call	0x15ab0	; 0x15ab0 <lcd_put>
			  
		      strResult[iValuePos]=0;
   100a2:	80 91 cf 02 	lds	r24, 0x02CF
   100a6:	c8 0f       	add	r28, r24
   100a8:	d1 1d       	adc	r29, r1
   100aa:	18 82       	st	Y, r1
		      iValuePos--;
   100ac:	81 50       	subi	r24, 0x01	; 1
   100ae:	80 93 cf 02 	sts	0x02CF, r24
			  yChar--;
   100b2:	80 91 d0 02 	lds	r24, 0x02D0
   100b6:	81 50       	subi	r24, 0x01	; 1
   100b8:	80 93 d0 02 	sts	0x02D0, r24
			  IsDelete=True;
   100bc:	81 e0       	ldi	r24, 0x01	; 1
   100be:	80 93 cb 02 	sts	0x02CB, r24
		  }
		  if (iValuePos==0)Result=USER_NO_DATA;		  
   100c2:	80 91 cf 02 	lds	r24, 0x02CF
   100c6:	88 23       	and	r24, r24
   100c8:	19 f4       	brne	.+6      	; 0x100d0 <UserInput+0x520>
   100ca:	f5 e0       	ldi	r31, 0x05	; 5
   100cc:	ef 2e       	mov	r14, r31
   100ce:	01 c0       	rjmp	.+2      	; 0x100d2 <UserInput+0x522>
   100d0:	ee 24       	eor	r14, r14
		  stUserInput=uiInputDisp;//Redraw
   100d2:	83 e0       	ldi	r24, 0x03	; 3
   100d4:	80 93 d2 02 	sts	0x02D2, r24
   100d8:	81 c0       	rjmp	.+258    	; 0x101dc <UserInput+0x62c>
	      break;      
     case uiInputDisp:
	      if(TypeUI==UI_ALPHANUM_PASSWORD){
   100da:	f5 e0       	ldi	r31, 0x05	; 5
   100dc:	8f 17       	cp	r24, r31
   100de:	19 f5       	brne	.+70     	; 0x10126 <UserInput+0x576>
			  if (iValuePos>0){
   100e0:	80 91 cf 02 	lds	r24, 0x02CF
   100e4:	88 23       	and	r24, r24
   100e6:	a9 f0       	breq	.+42     	; 0x10112 <UserInput+0x562>
                  lcd_put(xChar,(yChar-2),'*');
   100e8:	60 91 d0 02 	lds	r22, 0x02D0
   100ec:	62 50       	subi	r22, 0x02	; 2
   100ee:	80 91 d1 02 	lds	r24, 0x02D1
   100f2:	4a e2       	ldi	r20, 0x2A	; 42
   100f4:	0e 94 58 ad 	call	0x15ab0	; 0x15ab0 <lcd_put>
			      if (IsDelete==True){
   100f8:	80 91 cb 02 	lds	r24, 0x02CB
   100fc:	60 91 d0 02 	lds	r22, 0x02D0
   10100:	81 30       	cpi	r24, 0x01	; 1
   10102:	71 f0       	breq	.+28     	; 0x10120 <UserInput+0x570>
				      IsDelete=False;
			          lcd_put(xChar,(yChar-1),'*');
			          }
				  else lcd_put(xChar,(yChar-1),strResult[iValuePos-1]);
   10104:	61 50       	subi	r22, 0x01	; 1
   10106:	80 91 cf 02 	lds	r24, 0x02CF
   1010a:	c8 0f       	add	r28, r24
   1010c:	d1 1d       	adc	r29, r1
   1010e:	21 97       	sbiw	r28, 0x01	; 1
   10110:	4d c0       	rjmp	.+154    	; 0x101ac <UserInput+0x5fc>
			      }
			  else{ if(IsDelete==True){
   10112:	80 91 cb 02 	lds	r24, 0x02CB
   10116:	60 91 d0 02 	lds	r22, 0x02D0
   1011a:	81 30       	cpi	r24, 0x01	; 1
   1011c:	09 f0       	breq	.+2      	; 0x10120 <UserInput+0x570>
   1011e:	45 c0       	rjmp	.+138    	; 0x101aa <UserInput+0x5fa>
			           IsDelete=False;
   10120:	10 92 cb 02 	sts	0x02CB, r1
   10124:	4c c0       	rjmp	.+152    	; 0x101be <UserInput+0x60e>
					   lcd_put(xChar,(yChar-1),'*');
			           }
			        else lcd_put(xChar,(yChar-1),strResult[iValuePos]);
			  }
		  }else
	      if (TypeUI==UI_NUMBER_L){
   10126:	22 e0       	ldi	r18, 0x02	; 2
   10128:	82 17       	cp	r24, r18
   1012a:	a1 f4       	brne	.+40     	; 0x10154 <UserInput+0x5a4>
   1012c:	10 e0       	ldi	r17, 0x00	; 0
   1012e:	0d c0       	rjmp	.+26     	; 0x1014a <UserInput+0x59a>
	          for(iDisp=0;iDisp<iValuePos;iDisp++){
				  lcd_put(xChar,(yChar-(iValuePos-iDisp)),strResult[iDisp]);
   10130:	60 91 d0 02 	lds	r22, 0x02D0
   10134:	68 1b       	sub	r22, r24
   10136:	61 0f       	add	r22, r17
   10138:	fe 01       	movw	r30, r28
   1013a:	e1 0f       	add	r30, r17
   1013c:	f1 1d       	adc	r31, r1
   1013e:	80 91 d1 02 	lds	r24, 0x02D1
   10142:	40 81       	ld	r20, Z
   10144:	0e 94 58 ad 	call	0x15ab0	; 0x15ab0 <lcd_put>
			           }
			        else lcd_put(xChar,(yChar-1),strResult[iValuePos]);
			  }
		  }else
	      if (TypeUI==UI_NUMBER_L){
	          for(iDisp=0;iDisp<iValuePos;iDisp++){
   10148:	1f 5f       	subi	r17, 0xFF	; 255
   1014a:	80 91 cf 02 	lds	r24, 0x02CF
   1014e:	18 17       	cp	r17, r24
   10150:	78 f3       	brcs	.-34     	; 0x10130 <UserInput+0x580>
   10152:	3b c0       	rjmp	.+118    	; 0x101ca <UserInput+0x61a>
				  lcd_put(xChar,(yChar-(iValuePos-iDisp)),strResult[iDisp]);
		      }
		  }else
	      if ((TypeUI==UI_NUMBER_R)||(TypeUI==UI_ALPHANUM_R)){
   10154:	81 e0       	ldi	r24, 0x01	; 1
   10156:	f8 16       	cp	r15, r24
   10158:	19 f0       	breq	.+6      	; 0x10160 <UserInput+0x5b0>
   1015a:	e3 e0       	ldi	r30, 0x03	; 3
   1015c:	fe 16       	cp	r15, r30
   1015e:	51 f5       	brne	.+84     	; 0x101b4 <UserInput+0x604>
		      
			  //if (iValuePos>0) lcd_put(xChar,(yChar-1),strResult[iValuePos-1]);
			  if (iValuePos>0) lcd_put(xPos+((yPos+iValuePos-1)/21),yPos+((iValuePos-1)%20),strResult[iValuePos-1]);			  
   10160:	20 91 cf 02 	lds	r18, 0x02CF
   10164:	4d 2d       	mov	r20, r13
   10166:	50 e0       	ldi	r21, 0x00	; 0
   10168:	22 23       	and	r18, r18
   1016a:	c1 f0       	breq	.+48     	; 0x1019c <UserInput+0x5ec>
   1016c:	30 e0       	ldi	r19, 0x00	; 0
   1016e:	f9 01       	movw	r30, r18
   10170:	31 97       	sbiw	r30, 0x01	; 1
   10172:	cf 01       	movw	r24, r30
   10174:	84 0f       	add	r24, r20
   10176:	95 1f       	adc	r25, r21
   10178:	65 e1       	ldi	r22, 0x15	; 21
   1017a:	70 e0       	ldi	r23, 0x00	; 0
   1017c:	0e 94 1e b7 	call	0x16e3c	; 0x16e3c <__divmodhi4>
   10180:	46 2f       	mov	r20, r22
   10182:	cf 01       	movw	r24, r30
   10184:	64 e1       	ldi	r22, 0x14	; 20
   10186:	70 e0       	ldi	r23, 0x00	; 0
   10188:	0e 94 1e b7 	call	0x16e3c	; 0x16e3c <__divmodhi4>
   1018c:	d8 0e       	add	r13, r24
   1018e:	c2 0f       	add	r28, r18
   10190:	d3 1f       	adc	r29, r19
   10192:	21 97       	sbiw	r28, 0x01	; 1
   10194:	89 2d       	mov	r24, r9
   10196:	84 0f       	add	r24, r20
   10198:	6d 2d       	mov	r22, r13
   1019a:	0a c0       	rjmp	.+20     	; 0x101b0 <UserInput+0x600>
			  else{ if ((yChar-1)>=yPos)lcd_put(xChar,(yChar-1),strResult[iValuePos]);
   1019c:	60 91 d0 02 	lds	r22, 0x02D0
   101a0:	86 2f       	mov	r24, r22
   101a2:	90 e0       	ldi	r25, 0x00	; 0
   101a4:	48 17       	cp	r20, r24
   101a6:	59 07       	cpc	r21, r25
   101a8:	84 f4       	brge	.+32     	; 0x101ca <UserInput+0x61a>
   101aa:	61 50       	subi	r22, 0x01	; 1
   101ac:	80 91 d1 02 	lds	r24, 0x02D1
   101b0:	48 81       	ld	r20, Y
   101b2:	09 c0       	rjmp	.+18     	; 0x101c6 <UserInput+0x616>
			  }
		  }else
		  //DisplayAsterik *
		  if (TypeUI==UI_NUM_PASSWORD){
   101b4:	f4 e0       	ldi	r31, 0x04	; 4
   101b6:	ff 16       	cp	r15, r31
   101b8:	41 f4       	brne	.+16     	; 0x101ca <UserInput+0x61a>
		      lcd_put(xChar,(yChar-1),'*');
   101ba:	60 91 d0 02 	lds	r22, 0x02D0
   101be:	61 50       	subi	r22, 0x01	; 1
   101c0:	80 91 d1 02 	lds	r24, 0x02D1
   101c4:	4a e2       	ldi	r20, 0x2A	; 42
   101c6:	0e 94 58 ad 	call	0x15ab0	; 0x15ab0 <lcd_put>
		  }

          stUserInput=uiInput;
   101ca:	81 e0       	ldi	r24, 0x01	; 1
   101cc:	80 93 d2 02 	sts	0x02D2, r24
   101d0:	ee 24       	eor	r14, r14
   101d2:	04 c0       	rjmp	.+8      	; 0x101dc <UserInput+0x62c>
	      break;	 
     case uiFinished:
	      Result=UserInputResult;
   101d4:	e0 90 d3 02 	lds	r14, 0x02D3
	      stUserInput=uiInit;
   101d8:	10 92 d2 02 	sts	0x02D2, r1
	      break;
	 }
	 return Result;
}
   101dc:	8e 2d       	mov	r24, r14
   101de:	df 91       	pop	r29
   101e0:	cf 91       	pop	r28
   101e2:	1f 91       	pop	r17
   101e4:	0f 91       	pop	r16
   101e6:	ff 90       	pop	r15
   101e8:	ef 90       	pop	r14
   101ea:	df 90       	pop	r13
   101ec:	cf 90       	pop	r12
   101ee:	bf 90       	pop	r11
   101f0:	af 90       	pop	r10
   101f2:	9f 90       	pop	r9
   101f4:	8f 90       	pop	r8
   101f6:	08 95       	ret

000101f8 <TestUserInput>:
    //sprintf_P(strSend,PSTR("Pos:%d"),*Pos);
	//_uart_print(0,1,strSend);
}


char TestUserInput(){
   101f8:	6f 92       	push	r6
   101fa:	7f 92       	push	r7
   101fc:	8f 92       	push	r8
   101fe:	9f 92       	push	r9
   10200:	af 92       	push	r10
   10202:	bf 92       	push	r11
   10204:	cf 92       	push	r12
   10206:	df 92       	push	r13
   10208:	ef 92       	push	r14
   1020a:	ff 92       	push	r15
   1020c:	0f 93       	push	r16
   1020e:	1f 93       	push	r17
   10210:	df 93       	push	r29
   10212:	cf 93       	push	r28
   10214:	cd b7       	in	r28, 0x3d	; 61
   10216:	de b7       	in	r29, 0x3e	; 62
   10218:	ce 56       	subi	r28, 0x6E	; 110
   1021a:	d0 40       	sbci	r29, 0x00	; 0
   1021c:	0f b6       	in	r0, 0x3f	; 63
   1021e:	f8 94       	cli
   10220:	de bf       	out	0x3e, r29	; 62
   10222:	0f be       	out	0x3f, r0	; 63
   10224:	cd bf       	out	0x3d, r28	; 61
char lcdteks[20],strSend[30];
char SVolume[15],SMoney[15],STotalVolume[15],STotalMoney[15];
char Result;

char uiResult;
	uiResult=UserInput(UI_ALPHANUM_R,2,1,strNumber,0,10);
   10226:	69 ed       	ldi	r22, 0xD9	; 217
   10228:	66 2e       	mov	r6, r22
   1022a:	61 e0       	ldi	r22, 0x01	; 1
   1022c:	76 2e       	mov	r7, r22
   1022e:	83 e0       	ldi	r24, 0x03	; 3
   10230:	62 e0       	ldi	r22, 0x02	; 2
   10232:	41 e0       	ldi	r20, 0x01	; 1
   10234:	93 01       	movw	r18, r6
   10236:	00 e0       	ldi	r16, 0x00	; 0
   10238:	10 e0       	ldi	r17, 0x00	; 0
   1023a:	5a e0       	ldi	r21, 0x0A	; 10
   1023c:	e5 2e       	mov	r14, r21
   1023e:	0e 94 d8 7d 	call	0xfbb0	; 0xfbb0 <UserInput>
	Result=MENU_NONE;
    if (uiResult==USER_OK){
   10242:	83 30       	cpi	r24, 0x03	; 3
   10244:	09 f0       	breq	.+2      	; 0x10248 <TestUserInput+0x50>
   10246:	ed c1       	rjmp	.+986    	; 0x10622 <TestUserInput+0x42a>
	    sprintf_P(lcdteks,PSTR("Data:%s"),strNumber);
   10248:	00 d0       	rcall	.+0      	; 0x1024a <TestUserInput+0x52>
   1024a:	00 d0       	rcall	.+0      	; 0x1024c <TestUserInput+0x54>
   1024c:	00 d0       	rcall	.+0      	; 0x1024e <TestUserInput+0x56>
   1024e:	ed b7       	in	r30, 0x3d	; 61
   10250:	fe b7       	in	r31, 0x3e	; 62
   10252:	31 96       	adiw	r30, 0x01	; 1
   10254:	8e 01       	movw	r16, r28
   10256:	03 5c       	subi	r16, 0xC3	; 195
   10258:	1f 4f       	sbci	r17, 0xFF	; 255
   1025a:	ad b7       	in	r26, 0x3d	; 61
   1025c:	be b7       	in	r27, 0x3e	; 62
   1025e:	12 96       	adiw	r26, 0x02	; 2
   10260:	1c 93       	st	X, r17
   10262:	0e 93       	st	-X, r16
   10264:	11 97       	sbiw	r26, 0x01	; 1
   10266:	8e eb       	ldi	r24, 0xBE	; 190
   10268:	93 e0       	ldi	r25, 0x03	; 3
   1026a:	93 83       	std	Z+3, r25	; 0x03
   1026c:	82 83       	std	Z+2, r24	; 0x02
   1026e:	75 82       	std	Z+5, r7	; 0x05
   10270:	64 82       	std	Z+4, r6	; 0x04
   10272:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
	   lcd_print(3,1,lcdteks);
   10276:	8d b7       	in	r24, 0x3d	; 61
   10278:	9e b7       	in	r25, 0x3e	; 62
   1027a:	06 96       	adiw	r24, 0x06	; 6
   1027c:	0f b6       	in	r0, 0x3f	; 63
   1027e:	f8 94       	cli
   10280:	9e bf       	out	0x3e, r25	; 62
   10282:	0f be       	out	0x3f, r0	; 63
   10284:	8d bf       	out	0x3d, r24	; 61
   10286:	83 e0       	ldi	r24, 0x03	; 3
   10288:	61 e0       	ldi	r22, 0x01	; 1
   1028a:	a8 01       	movw	r20, r16
   1028c:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
	   //FormatCurrency(strNumber);
	   //FormatMoney(strNumber);
	   //RemZeroLead(strNumber);
	   sprintf_P(SVolume,PSTR("%s"),strNumber);
   10290:	00 d0       	rcall	.+0      	; 0x10292 <TestUserInput+0x9a>
   10292:	00 d0       	rcall	.+0      	; 0x10294 <TestUserInput+0x9c>
   10294:	00 d0       	rcall	.+0      	; 0x10296 <TestUserInput+0x9e>
   10296:	ed b7       	in	r30, 0x3d	; 61
   10298:	fe b7       	in	r31, 0x3e	; 62
   1029a:	31 96       	adiw	r30, 0x01	; 1
   1029c:	7e 01       	movw	r14, r28
   1029e:	08 94       	sec
   102a0:	e1 1c       	adc	r14, r1
   102a2:	f1 1c       	adc	r15, r1
   102a4:	ad b7       	in	r26, 0x3d	; 61
   102a6:	be b7       	in	r27, 0x3e	; 62
   102a8:	12 96       	adiw	r26, 0x02	; 2
   102aa:	fc 92       	st	X, r15
   102ac:	ee 92       	st	-X, r14
   102ae:	11 97       	sbiw	r26, 0x01	; 1
   102b0:	8b eb       	ldi	r24, 0xBB	; 187
   102b2:	93 e0       	ldi	r25, 0x03	; 3
   102b4:	93 83       	std	Z+3, r25	; 0x03
   102b6:	82 83       	std	Z+2, r24	; 0x02
   102b8:	75 82       	std	Z+5, r7	; 0x05
   102ba:	64 82       	std	Z+4, r6	; 0x04
   102bc:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
	   sprintf_P(SMoney,PSTR("%s"),strNumber);
   102c0:	ed b7       	in	r30, 0x3d	; 61
   102c2:	fe b7       	in	r31, 0x3e	; 62
   102c4:	31 96       	adiw	r30, 0x01	; 1
   102c6:	20 e1       	ldi	r18, 0x10	; 16
   102c8:	a2 2e       	mov	r10, r18
   102ca:	b1 2c       	mov	r11, r1
   102cc:	ac 0e       	add	r10, r28
   102ce:	bd 1e       	adc	r11, r29
   102d0:	ad b7       	in	r26, 0x3d	; 61
   102d2:	be b7       	in	r27, 0x3e	; 62
   102d4:	12 96       	adiw	r26, 0x02	; 2
   102d6:	bc 92       	st	X, r11
   102d8:	ae 92       	st	-X, r10
   102da:	11 97       	sbiw	r26, 0x01	; 1
   102dc:	88 eb       	ldi	r24, 0xB8	; 184
   102de:	93 e0       	ldi	r25, 0x03	; 3
   102e0:	93 83       	std	Z+3, r25	; 0x03
   102e2:	82 83       	std	Z+2, r24	; 0x02
   102e4:	75 82       	std	Z+5, r7	; 0x05
   102e6:	64 82       	std	Z+4, r6	; 0x04
   102e8:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
	   sprintf_P(STotalVolume,PSTR("%s"),strNumber);
   102ec:	ed b7       	in	r30, 0x3d	; 61
   102ee:	fe b7       	in	r31, 0x3e	; 62
   102f0:	31 96       	adiw	r30, 0x01	; 1
   102f2:	9f e1       	ldi	r25, 0x1F	; 31
   102f4:	89 2e       	mov	r8, r25
   102f6:	91 2c       	mov	r9, r1
   102f8:	8c 0e       	add	r8, r28
   102fa:	9d 1e       	adc	r9, r29
   102fc:	ad b7       	in	r26, 0x3d	; 61
   102fe:	be b7       	in	r27, 0x3e	; 62
   10300:	12 96       	adiw	r26, 0x02	; 2
   10302:	9c 92       	st	X, r9
   10304:	8e 92       	st	-X, r8
   10306:	11 97       	sbiw	r26, 0x01	; 1
   10308:	85 eb       	ldi	r24, 0xB5	; 181
   1030a:	93 e0       	ldi	r25, 0x03	; 3
   1030c:	93 83       	std	Z+3, r25	; 0x03
   1030e:	82 83       	std	Z+2, r24	; 0x02
   10310:	75 82       	std	Z+5, r7	; 0x05
   10312:	64 82       	std	Z+4, r6	; 0x04
   10314:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
	   sprintf_P(STotalMoney,PSTR("%s"),strNumber);
   10318:	ed b7       	in	r30, 0x3d	; 61
   1031a:	fe b7       	in	r31, 0x3e	; 62
   1031c:	31 96       	adiw	r30, 0x01	; 1
   1031e:	8e e2       	ldi	r24, 0x2E	; 46
   10320:	c8 2e       	mov	r12, r24
   10322:	d1 2c       	mov	r13, r1
   10324:	cc 0e       	add	r12, r28
   10326:	dd 1e       	adc	r13, r29
   10328:	ad b7       	in	r26, 0x3d	; 61
   1032a:	be b7       	in	r27, 0x3e	; 62
   1032c:	12 96       	adiw	r26, 0x02	; 2
   1032e:	dc 92       	st	X, r13
   10330:	ce 92       	st	-X, r12
   10332:	11 97       	sbiw	r26, 0x01	; 1
   10334:	82 eb       	ldi	r24, 0xB2	; 178
   10336:	93 e0       	ldi	r25, 0x03	; 3
   10338:	93 83       	std	Z+3, r25	; 0x03
   1033a:	82 83       	std	Z+2, r24	; 0x02
   1033c:	75 82       	std	Z+5, r7	; 0x05
   1033e:	64 82       	std	Z+4, r6	; 0x04
   10340:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>

	   sprintf_P(lcdteks,PSTR("Formated:%s"),strNumber);
   10344:	ed b7       	in	r30, 0x3d	; 61
   10346:	fe b7       	in	r31, 0x3e	; 62
   10348:	31 96       	adiw	r30, 0x01	; 1
   1034a:	ad b7       	in	r26, 0x3d	; 61
   1034c:	be b7       	in	r27, 0x3e	; 62
   1034e:	12 96       	adiw	r26, 0x02	; 2
   10350:	1c 93       	st	X, r17
   10352:	0e 93       	st	-X, r16
   10354:	11 97       	sbiw	r26, 0x01	; 1
   10356:	86 ea       	ldi	r24, 0xA6	; 166
   10358:	93 e0       	ldi	r25, 0x03	; 3
   1035a:	93 83       	std	Z+3, r25	; 0x03
   1035c:	82 83       	std	Z+2, r24	; 0x02
   1035e:	75 82       	std	Z+5, r7	; 0x05
   10360:	64 82       	std	Z+4, r6	; 0x04
   10362:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
       lcd_print(4,1,lcdteks);
   10366:	8d b7       	in	r24, 0x3d	; 61
   10368:	9e b7       	in	r25, 0x3e	; 62
   1036a:	06 96       	adiw	r24, 0x06	; 6
   1036c:	0f b6       	in	r0, 0x3f	; 63
   1036e:	f8 94       	cli
   10370:	9e bf       	out	0x3e, r25	; 62
   10372:	0f be       	out	0x3f, r0	; 63
   10374:	8d bf       	out	0x3d, r24	; 61
   10376:	84 e0       	ldi	r24, 0x04	; 4
   10378:	61 e0       	ldi	r22, 0x01	; 1
   1037a:	a8 01       	movw	r20, r16
   1037c:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
	   sprintf_P(strSend,PSTR("Raw:%s"),strNumber);
   10380:	00 d0       	rcall	.+0      	; 0x10382 <TestUserInput+0x18a>
   10382:	00 d0       	rcall	.+0      	; 0x10384 <TestUserInput+0x18c>
   10384:	00 d0       	rcall	.+0      	; 0x10386 <TestUserInput+0x18e>
   10386:	ed b7       	in	r30, 0x3d	; 61
   10388:	fe b7       	in	r31, 0x3e	; 62
   1038a:	31 96       	adiw	r30, 0x01	; 1
   1038c:	8e 01       	movw	r16, r28
   1038e:	0f 5a       	subi	r16, 0xAF	; 175
   10390:	1f 4f       	sbci	r17, 0xFF	; 255
   10392:	ad b7       	in	r26, 0x3d	; 61
   10394:	be b7       	in	r27, 0x3e	; 62
   10396:	12 96       	adiw	r26, 0x02	; 2
   10398:	1c 93       	st	X, r17
   1039a:	0e 93       	st	-X, r16
   1039c:	11 97       	sbiw	r26, 0x01	; 1
   1039e:	8f e9       	ldi	r24, 0x9F	; 159
   103a0:	93 e0       	ldi	r25, 0x03	; 3
   103a2:	93 83       	std	Z+3, r25	; 0x03
   103a4:	82 83       	std	Z+2, r24	; 0x02
   103a6:	75 82       	std	Z+5, r7	; 0x05
   103a8:	64 82       	std	Z+4, r6	; 0x04
   103aa:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
	   _uart_print(0,1,strSend);
   103ae:	8d b7       	in	r24, 0x3d	; 61
   103b0:	9e b7       	in	r25, 0x3e	; 62
   103b2:	06 96       	adiw	r24, 0x06	; 6
   103b4:	0f b6       	in	r0, 0x3f	; 63
   103b6:	f8 94       	cli
   103b8:	9e bf       	out	0x3e, r25	; 62
   103ba:	0f be       	out	0x3f, r0	; 63
   103bc:	8d bf       	out	0x3d, r24	; 61
   103be:	80 e0       	ldi	r24, 0x00	; 0
   103c0:	61 e0       	ldi	r22, 0x01	; 1
   103c2:	a8 01       	movw	r20, r16
   103c4:	0e 94 70 b2 	call	0x164e0	; 0x164e0 <_uart_print>

	   RemoveMinus(strNumber);
   103c8:	c3 01       	movw	r24, r6
   103ca:	0e 94 53 23 	call	0x46a6	; 0x46a6 <RemoveMinus>

	   sprintf_P(strSend,PSTR("Minus:%s"),strNumber);
   103ce:	00 d0       	rcall	.+0      	; 0x103d0 <TestUserInput+0x1d8>
   103d0:	00 d0       	rcall	.+0      	; 0x103d2 <TestUserInput+0x1da>
   103d2:	00 d0       	rcall	.+0      	; 0x103d4 <TestUserInput+0x1dc>
   103d4:	ed b7       	in	r30, 0x3d	; 61
   103d6:	fe b7       	in	r31, 0x3e	; 62
   103d8:	31 96       	adiw	r30, 0x01	; 1
   103da:	ad b7       	in	r26, 0x3d	; 61
   103dc:	be b7       	in	r27, 0x3e	; 62
   103de:	12 96       	adiw	r26, 0x02	; 2
   103e0:	1c 93       	st	X, r17
   103e2:	0e 93       	st	-X, r16
   103e4:	11 97       	sbiw	r26, 0x01	; 1
   103e6:	86 e9       	ldi	r24, 0x96	; 150
   103e8:	93 e0       	ldi	r25, 0x03	; 3
   103ea:	93 83       	std	Z+3, r25	; 0x03
   103ec:	82 83       	std	Z+2, r24	; 0x02
   103ee:	75 82       	std	Z+5, r7	; 0x05
   103f0:	64 82       	std	Z+4, r6	; 0x04
   103f2:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
	   _uart_print(0,1,strSend);
   103f6:	8d b7       	in	r24, 0x3d	; 61
   103f8:	9e b7       	in	r25, 0x3e	; 62
   103fa:	06 96       	adiw	r24, 0x06	; 6
   103fc:	0f b6       	in	r0, 0x3f	; 63
   103fe:	f8 94       	cli
   10400:	9e bf       	out	0x3e, r25	; 62
   10402:	0f be       	out	0x3f, r0	; 63
   10404:	8d bf       	out	0x3d, r24	; 61
   10406:	80 e0       	ldi	r24, 0x00	; 0
   10408:	61 e0       	ldi	r22, 0x01	; 1
   1040a:	a8 01       	movw	r20, r16
   1040c:	0e 94 70 b2 	call	0x164e0	; 0x164e0 <_uart_print>

       
	   RemZeroLead(strNumber);
   10410:	c3 01       	movw	r24, r6
   10412:	0e 94 19 25 	call	0x4a32	; 0x4a32 <RemZeroLead>
	   sprintf_P(strSend,PSTR("Removed:%s"),strNumber);
   10416:	00 d0       	rcall	.+0      	; 0x10418 <TestUserInput+0x220>
   10418:	00 d0       	rcall	.+0      	; 0x1041a <TestUserInput+0x222>
   1041a:	00 d0       	rcall	.+0      	; 0x1041c <TestUserInput+0x224>
   1041c:	ed b7       	in	r30, 0x3d	; 61
   1041e:	fe b7       	in	r31, 0x3e	; 62
   10420:	31 96       	adiw	r30, 0x01	; 1
   10422:	ad b7       	in	r26, 0x3d	; 61
   10424:	be b7       	in	r27, 0x3e	; 62
   10426:	12 96       	adiw	r26, 0x02	; 2
   10428:	1c 93       	st	X, r17
   1042a:	0e 93       	st	-X, r16
   1042c:	11 97       	sbiw	r26, 0x01	; 1
   1042e:	8b e8       	ldi	r24, 0x8B	; 139
   10430:	93 e0       	ldi	r25, 0x03	; 3
   10432:	93 83       	std	Z+3, r25	; 0x03
   10434:	82 83       	std	Z+2, r24	; 0x02
   10436:	75 82       	std	Z+5, r7	; 0x05
   10438:	64 82       	std	Z+4, r6	; 0x04
   1043a:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
	   _uart_print(0,1,strSend);
   1043e:	8d b7       	in	r24, 0x3d	; 61
   10440:	9e b7       	in	r25, 0x3e	; 62
   10442:	06 96       	adiw	r24, 0x06	; 6
   10444:	0f b6       	in	r0, 0x3f	; 63
   10446:	f8 94       	cli
   10448:	9e bf       	out	0x3e, r25	; 62
   1044a:	0f be       	out	0x3f, r0	; 63
   1044c:	8d bf       	out	0x3d, r24	; 61
   1044e:	80 e0       	ldi	r24, 0x00	; 0
   10450:	61 e0       	ldi	r22, 0x01	; 1
   10452:	a8 01       	movw	r20, r16
   10454:	0e 94 70 b2 	call	0x164e0	; 0x164e0 <_uart_print>

RemZeroLead(SVolume);
   10458:	c7 01       	movw	r24, r14
   1045a:	0e 94 19 25 	call	0x4a32	; 0x4a32 <RemZeroLead>
RemZeroLead(SMoney);
   1045e:	c5 01       	movw	r24, r10
   10460:	0e 94 19 25 	call	0x4a32	; 0x4a32 <RemZeroLead>
RemZeroLead(STotalVolume);
   10464:	c4 01       	movw	r24, r8
   10466:	0e 94 19 25 	call	0x4a32	; 0x4a32 <RemZeroLead>
RemZeroLead(STotalMoney);
   1046a:	c6 01       	movw	r24, r12
   1046c:	0e 94 19 25 	call	0x4a32	; 0x4a32 <RemZeroLead>
       
	   
	   FormatVolume(SVolume); 
   10470:	c7 01       	movw	r24, r14
   10472:	0e 94 53 34 	call	0x68a6	; 0x68a6 <FormatVolume>
	   FormatMoney(SMoney);
   10476:	c5 01       	movw	r24, r10
   10478:	0e 94 60 34 	call	0x68c0	; 0x68c0 <FormatMoney>
	   FormatTotalizerMoney(STotalVolume);
   1047c:	c4 01       	movw	r24, r8
   1047e:	0e 94 46 34 	call	0x688c	; 0x688c <FormatTotalizerMoney>
	   FormatTotalizerVolume(STotalMoney);
   10482:	c6 01       	movw	r24, r12
   10484:	0e 94 39 34 	call	0x6872	; 0x6872 <FormatTotalizerVolume>

	   sprintf_P(strSend,PSTR("Volume:%s"),SVolume);
   10488:	00 d0       	rcall	.+0      	; 0x1048a <TestUserInput+0x292>
   1048a:	00 d0       	rcall	.+0      	; 0x1048c <TestUserInput+0x294>
   1048c:	00 d0       	rcall	.+0      	; 0x1048e <TestUserInput+0x296>
   1048e:	ed b7       	in	r30, 0x3d	; 61
   10490:	fe b7       	in	r31, 0x3e	; 62
   10492:	31 96       	adiw	r30, 0x01	; 1
   10494:	ad b7       	in	r26, 0x3d	; 61
   10496:	be b7       	in	r27, 0x3e	; 62
   10498:	12 96       	adiw	r26, 0x02	; 2
   1049a:	1c 93       	st	X, r17
   1049c:	0e 93       	st	-X, r16
   1049e:	11 97       	sbiw	r26, 0x01	; 1
   104a0:	81 e8       	ldi	r24, 0x81	; 129
   104a2:	93 e0       	ldi	r25, 0x03	; 3
   104a4:	93 83       	std	Z+3, r25	; 0x03
   104a6:	82 83       	std	Z+2, r24	; 0x02
   104a8:	f5 82       	std	Z+5, r15	; 0x05
   104aa:	e4 82       	std	Z+4, r14	; 0x04
   104ac:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
	   _uart_print(0,1,strSend);
   104b0:	8d b7       	in	r24, 0x3d	; 61
   104b2:	9e b7       	in	r25, 0x3e	; 62
   104b4:	06 96       	adiw	r24, 0x06	; 6
   104b6:	0f b6       	in	r0, 0x3f	; 63
   104b8:	f8 94       	cli
   104ba:	9e bf       	out	0x3e, r25	; 62
   104bc:	0f be       	out	0x3f, r0	; 63
   104be:	8d bf       	out	0x3d, r24	; 61
   104c0:	80 e0       	ldi	r24, 0x00	; 0
   104c2:	61 e0       	ldi	r22, 0x01	; 1
   104c4:	a8 01       	movw	r20, r16
   104c6:	0e 94 70 b2 	call	0x164e0	; 0x164e0 <_uart_print>
	   sprintf_P(strSend,PSTR("Money:%s"),SMoney);
   104ca:	00 d0       	rcall	.+0      	; 0x104cc <TestUserInput+0x2d4>
   104cc:	00 d0       	rcall	.+0      	; 0x104ce <TestUserInput+0x2d6>
   104ce:	00 d0       	rcall	.+0      	; 0x104d0 <TestUserInput+0x2d8>
   104d0:	ed b7       	in	r30, 0x3d	; 61
   104d2:	fe b7       	in	r31, 0x3e	; 62
   104d4:	31 96       	adiw	r30, 0x01	; 1
   104d6:	ad b7       	in	r26, 0x3d	; 61
   104d8:	be b7       	in	r27, 0x3e	; 62
   104da:	12 96       	adiw	r26, 0x02	; 2
   104dc:	1c 93       	st	X, r17
   104de:	0e 93       	st	-X, r16
   104e0:	11 97       	sbiw	r26, 0x01	; 1
   104e2:	88 e7       	ldi	r24, 0x78	; 120
   104e4:	93 e0       	ldi	r25, 0x03	; 3
   104e6:	93 83       	std	Z+3, r25	; 0x03
   104e8:	82 83       	std	Z+2, r24	; 0x02
   104ea:	b5 82       	std	Z+5, r11	; 0x05
   104ec:	a4 82       	std	Z+4, r10	; 0x04
   104ee:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
	   _uart_print(0,1,strSend);
   104f2:	8d b7       	in	r24, 0x3d	; 61
   104f4:	9e b7       	in	r25, 0x3e	; 62
   104f6:	06 96       	adiw	r24, 0x06	; 6
   104f8:	0f b6       	in	r0, 0x3f	; 63
   104fa:	f8 94       	cli
   104fc:	9e bf       	out	0x3e, r25	; 62
   104fe:	0f be       	out	0x3f, r0	; 63
   10500:	8d bf       	out	0x3d, r24	; 61
   10502:	80 e0       	ldi	r24, 0x00	; 0
   10504:	61 e0       	ldi	r22, 0x01	; 1
   10506:	a8 01       	movw	r20, r16
   10508:	0e 94 70 b2 	call	0x164e0	; 0x164e0 <_uart_print>
	   sprintf_P(strSend,PSTR("TVolume:%s"),STotalVolume);
   1050c:	00 d0       	rcall	.+0      	; 0x1050e <TestUserInput+0x316>
   1050e:	00 d0       	rcall	.+0      	; 0x10510 <TestUserInput+0x318>
   10510:	00 d0       	rcall	.+0      	; 0x10512 <TestUserInput+0x31a>
   10512:	ed b7       	in	r30, 0x3d	; 61
   10514:	fe b7       	in	r31, 0x3e	; 62
   10516:	31 96       	adiw	r30, 0x01	; 1
   10518:	ad b7       	in	r26, 0x3d	; 61
   1051a:	be b7       	in	r27, 0x3e	; 62
   1051c:	12 96       	adiw	r26, 0x02	; 2
   1051e:	1c 93       	st	X, r17
   10520:	0e 93       	st	-X, r16
   10522:	11 97       	sbiw	r26, 0x01	; 1
   10524:	8d e6       	ldi	r24, 0x6D	; 109
   10526:	93 e0       	ldi	r25, 0x03	; 3
   10528:	93 83       	std	Z+3, r25	; 0x03
   1052a:	82 83       	std	Z+2, r24	; 0x02
   1052c:	95 82       	std	Z+5, r9	; 0x05
   1052e:	84 82       	std	Z+4, r8	; 0x04
   10530:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
	   _uart_print(0,1,strSend);
   10534:	8d b7       	in	r24, 0x3d	; 61
   10536:	9e b7       	in	r25, 0x3e	; 62
   10538:	06 96       	adiw	r24, 0x06	; 6
   1053a:	0f b6       	in	r0, 0x3f	; 63
   1053c:	f8 94       	cli
   1053e:	9e bf       	out	0x3e, r25	; 62
   10540:	0f be       	out	0x3f, r0	; 63
   10542:	8d bf       	out	0x3d, r24	; 61
   10544:	80 e0       	ldi	r24, 0x00	; 0
   10546:	61 e0       	ldi	r22, 0x01	; 1
   10548:	a8 01       	movw	r20, r16
   1054a:	0e 94 70 b2 	call	0x164e0	; 0x164e0 <_uart_print>
	   sprintf_P(strSend,PSTR("TMoney:%s"),STotalMoney);
   1054e:	00 d0       	rcall	.+0      	; 0x10550 <TestUserInput+0x358>
   10550:	00 d0       	rcall	.+0      	; 0x10552 <TestUserInput+0x35a>
   10552:	00 d0       	rcall	.+0      	; 0x10554 <TestUserInput+0x35c>
   10554:	ed b7       	in	r30, 0x3d	; 61
   10556:	fe b7       	in	r31, 0x3e	; 62
   10558:	31 96       	adiw	r30, 0x01	; 1
   1055a:	ad b7       	in	r26, 0x3d	; 61
   1055c:	be b7       	in	r27, 0x3e	; 62
   1055e:	12 96       	adiw	r26, 0x02	; 2
   10560:	1c 93       	st	X, r17
   10562:	0e 93       	st	-X, r16
   10564:	11 97       	sbiw	r26, 0x01	; 1
   10566:	83 e6       	ldi	r24, 0x63	; 99
   10568:	93 e0       	ldi	r25, 0x03	; 3
   1056a:	93 83       	std	Z+3, r25	; 0x03
   1056c:	82 83       	std	Z+2, r24	; 0x02
   1056e:	d5 82       	std	Z+5, r13	; 0x05
   10570:	c4 82       	std	Z+4, r12	; 0x04
   10572:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
	   _uart_print(0,1,strSend);
   10576:	8d b7       	in	r24, 0x3d	; 61
   10578:	9e b7       	in	r25, 0x3e	; 62
   1057a:	06 96       	adiw	r24, 0x06	; 6
   1057c:	0f b6       	in	r0, 0x3f	; 63
   1057e:	f8 94       	cli
   10580:	9e bf       	out	0x3e, r25	; 62
   10582:	0f be       	out	0x3f, r0	; 63
   10584:	8d bf       	out	0x3d, r24	; 61
   10586:	80 e0       	ldi	r24, 0x00	; 0
   10588:	61 e0       	ldi	r22, 0x01	; 1
   1058a:	a8 01       	movw	r20, r16
   1058c:	0e 94 70 b2 	call	0x164e0	; 0x164e0 <_uart_print>

	   FormatCurrency(SMoney);
   10590:	c5 01       	movw	r24, r10
   10592:	0e 94 09 33 	call	0x6612	; 0x6612 <FormatCurrency>
	   FormatCurrency(STotalMoney);
   10596:	c6 01       	movw	r24, r12
   10598:	0e 94 09 33 	call	0x6612	; 0x6612 <FormatCurrency>
    
	   sprintf_P(strSend,PSTR("FmtMoney:%s"),SMoney);
   1059c:	00 d0       	rcall	.+0      	; 0x1059e <TestUserInput+0x3a6>
   1059e:	00 d0       	rcall	.+0      	; 0x105a0 <TestUserInput+0x3a8>
   105a0:	00 d0       	rcall	.+0      	; 0x105a2 <TestUserInput+0x3aa>
   105a2:	ed b7       	in	r30, 0x3d	; 61
   105a4:	fe b7       	in	r31, 0x3e	; 62
   105a6:	31 96       	adiw	r30, 0x01	; 1
   105a8:	ad b7       	in	r26, 0x3d	; 61
   105aa:	be b7       	in	r27, 0x3e	; 62
   105ac:	12 96       	adiw	r26, 0x02	; 2
   105ae:	1c 93       	st	X, r17
   105b0:	0e 93       	st	-X, r16
   105b2:	11 97       	sbiw	r26, 0x01	; 1
   105b4:	87 e5       	ldi	r24, 0x57	; 87
   105b6:	93 e0       	ldi	r25, 0x03	; 3
   105b8:	93 83       	std	Z+3, r25	; 0x03
   105ba:	82 83       	std	Z+2, r24	; 0x02
   105bc:	b5 82       	std	Z+5, r11	; 0x05
   105be:	a4 82       	std	Z+4, r10	; 0x04
   105c0:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
	   _uart_print(0,1,strSend);
   105c4:	8d b7       	in	r24, 0x3d	; 61
   105c6:	9e b7       	in	r25, 0x3e	; 62
   105c8:	06 96       	adiw	r24, 0x06	; 6
   105ca:	0f b6       	in	r0, 0x3f	; 63
   105cc:	f8 94       	cli
   105ce:	9e bf       	out	0x3e, r25	; 62
   105d0:	0f be       	out	0x3f, r0	; 63
   105d2:	8d bf       	out	0x3d, r24	; 61
   105d4:	80 e0       	ldi	r24, 0x00	; 0
   105d6:	61 e0       	ldi	r22, 0x01	; 1
   105d8:	a8 01       	movw	r20, r16
   105da:	0e 94 70 b2 	call	0x164e0	; 0x164e0 <_uart_print>
	   sprintf_P(strSend,PSTR("FmtTMoney:%s"),STotalMoney);
   105de:	00 d0       	rcall	.+0      	; 0x105e0 <TestUserInput+0x3e8>
   105e0:	00 d0       	rcall	.+0      	; 0x105e2 <TestUserInput+0x3ea>
   105e2:	00 d0       	rcall	.+0      	; 0x105e4 <TestUserInput+0x3ec>
   105e4:	ed b7       	in	r30, 0x3d	; 61
   105e6:	fe b7       	in	r31, 0x3e	; 62
   105e8:	31 96       	adiw	r30, 0x01	; 1
   105ea:	ad b7       	in	r26, 0x3d	; 61
   105ec:	be b7       	in	r27, 0x3e	; 62
   105ee:	12 96       	adiw	r26, 0x02	; 2
   105f0:	1c 93       	st	X, r17
   105f2:	0e 93       	st	-X, r16
   105f4:	11 97       	sbiw	r26, 0x01	; 1
   105f6:	8a e4       	ldi	r24, 0x4A	; 74
   105f8:	93 e0       	ldi	r25, 0x03	; 3
   105fa:	93 83       	std	Z+3, r25	; 0x03
   105fc:	82 83       	std	Z+2, r24	; 0x02
   105fe:	d5 82       	std	Z+5, r13	; 0x05
   10600:	c4 82       	std	Z+4, r12	; 0x04
   10602:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
	   _uart_print(0,1,strSend);
   10606:	8d b7       	in	r24, 0x3d	; 61
   10608:	9e b7       	in	r25, 0x3e	; 62
   1060a:	06 96       	adiw	r24, 0x06	; 6
   1060c:	0f b6       	in	r0, 0x3f	; 63
   1060e:	f8 94       	cli
   10610:	9e bf       	out	0x3e, r25	; 62
   10612:	0f be       	out	0x3f, r0	; 63
   10614:	8d bf       	out	0x3d, r24	; 61
   10616:	80 e0       	ldi	r24, 0x00	; 0
   10618:	61 e0       	ldi	r22, 0x01	; 1
   1061a:	a8 01       	movw	r20, r16
   1061c:	0e 94 70 b2 	call	0x164e0	; 0x164e0 <_uart_print>
   10620:	02 c0       	rjmp	.+4      	; 0x10626 <TestUserInput+0x42e>


   	
	}else    
	if (uiResult==USER_CANCEL){
   10622:	81 30       	cpi	r24, 0x01	; 1
   10624:	11 f0       	breq	.+4      	; 0x1062a <TestUserInput+0x432>
   10626:	80 e0       	ldi	r24, 0x00	; 0
   10628:	0b c0       	rjmp	.+22     	; 0x10640 <TestUserInput+0x448>
	   lcd_clear();
   1062a:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
   1062e:	fe 01       	movw	r30, r28
   10630:	fd 96       	adiw	r30, 0x3d	; 61

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   10632:	cf 01       	movw	r24, r30
   10634:	0f 96       	adiw	r24, 0x0f	; 15
	     strMemory[i]=data;
   10636:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   10638:	e8 17       	cp	r30, r24
   1063a:	f9 07       	cpc	r31, r25
   1063c:	e1 f7       	brne	.-8      	; 0x10636 <TestUserInput+0x43e>
   1063e:	81 e0       	ldi	r24, 0x01	; 1
       Result=MENU_DONE;   
	   //lcd_printf(1,1,PSTR("InputNumber:"));
       //lcd_printf(2,1,PSTR("_         "));
	}
  return Result;
}
   10640:	c2 59       	subi	r28, 0x92	; 146
   10642:	df 4f       	sbci	r29, 0xFF	; 255
   10644:	0f b6       	in	r0, 0x3f	; 63
   10646:	f8 94       	cli
   10648:	de bf       	out	0x3e, r29	; 62
   1064a:	0f be       	out	0x3f, r0	; 63
   1064c:	cd bf       	out	0x3d, r28	; 61
   1064e:	cf 91       	pop	r28
   10650:	df 91       	pop	r29
   10652:	1f 91       	pop	r17
   10654:	0f 91       	pop	r16
   10656:	ff 90       	pop	r15
   10658:	ef 90       	pop	r14
   1065a:	df 90       	pop	r13
   1065c:	cf 90       	pop	r12
   1065e:	bf 90       	pop	r11
   10660:	af 90       	pop	r10
   10662:	9f 90       	pop	r9
   10664:	8f 90       	pop	r8
   10666:	7f 90       	pop	r7
   10668:	6f 90       	pop	r6
   1066a:	08 95       	ret

0001066c <FSettingDec>:

	Result=MENU_DONE;
	return Result;
}

char FSettingDec(){
   1066c:	df 92       	push	r13
   1066e:	ef 92       	push	r14
   10670:	ff 92       	push	r15
   10672:	0f 93       	push	r16
   10674:	1f 93       	push	r17
   10676:	df 93       	push	r29
   10678:	cf 93       	push	r28
   1067a:	cd b7       	in	r28, 0x3d	; 61
   1067c:	de b7       	in	r29, 0x3e	; 62
   1067e:	64 97       	sbiw	r28, 0x14	; 20
   10680:	0f b6       	in	r0, 0x3f	; 63
   10682:	f8 94       	cli
   10684:	de bf       	out	0x3e, r29	; 62
   10686:	0f be       	out	0x3f, r0	; 63
   10688:	cd bf       	out	0x3d, r28	; 61
static char stSettingDecimal=sdInitDisplay;
     char PDecimalConfig[4],Addr,KeyChar,Result;
	 char lcdteks[20];

     Result=MENU_NONE;
	 switch(stSettingDecimal){
   1068a:	80 91 70 02 	lds	r24, 0x0270
   1068e:	82 30       	cpi	r24, 0x02	; 2
   10690:	09 f4       	brne	.+2      	; 0x10694 <FSettingDec+0x28>
   10692:	c7 c0       	rjmp	.+398    	; 0x10822 <FSettingDec+0x1b6>
   10694:	83 30       	cpi	r24, 0x03	; 3
   10696:	30 f4       	brcc	.+12     	; 0x106a4 <FSettingDec+0x38>
   10698:	88 23       	and	r24, r24
   1069a:	71 f0       	breq	.+28     	; 0x106b8 <FSettingDec+0x4c>
   1069c:	81 30       	cpi	r24, 0x01	; 1
   1069e:	09 f0       	breq	.+2      	; 0x106a2 <FSettingDec+0x36>
   106a0:	c3 c1       	rjmp	.+902    	; 0x10a28 <FSettingDec+0x3bc>
   106a2:	92 c0       	rjmp	.+292    	; 0x107c8 <FSettingDec+0x15c>
   106a4:	84 30       	cpi	r24, 0x04	; 4
   106a6:	09 f4       	brne	.+2      	; 0x106aa <FSettingDec+0x3e>
   106a8:	b3 c1       	rjmp	.+870    	; 0x10a10 <FSettingDec+0x3a4>
   106aa:	84 30       	cpi	r24, 0x04	; 4
   106ac:	08 f4       	brcc	.+2      	; 0x106b0 <FSettingDec+0x44>
   106ae:	68 c1       	rjmp	.+720    	; 0x10980 <FSettingDec+0x314>
   106b0:	85 30       	cpi	r24, 0x05	; 5
   106b2:	09 f0       	breq	.+2      	; 0x106b6 <FSettingDec+0x4a>
   106b4:	b9 c1       	rjmp	.+882    	; 0x10a28 <FSettingDec+0x3bc>
   106b6:	b4 c1       	rjmp	.+872    	; 0x10a20 <FSettingDec+0x3b4>
	 case sdInitDisplay:
	      lcd_clear();         //"12345678901234567890
   106b8:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   106bc:	e1 99       	sbic	0x1c, 1	; 28
   106be:	fe cf       	rjmp	.-4      	; 0x106bc <FSettingDec+0x50>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   106c0:	89 e3       	ldi	r24, 0x39	; 57
   106c2:	90 e0       	ldi	r25, 0x00	; 0
   106c4:	9f bb       	out	0x1f, r25	; 31
   106c6:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   106c8:	e0 9a       	sbi	0x1c, 0	; 28
   106ca:	2d b3       	in	r18, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   106cc:	e1 99       	sbic	0x1c, 1	; 28
   106ce:	fe cf       	rjmp	.-4      	; 0x106cc <FSettingDec+0x60>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   106d0:	8a e3       	ldi	r24, 0x3A	; 58
   106d2:	90 e0       	ldi	r25, 0x00	; 0
   106d4:	9f bb       	out	0x1f, r25	; 31
   106d6:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   106d8:	e0 9a       	sbi	0x1c, 0	; 28
   106da:	ed b2       	in	r14, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   106dc:	e1 99       	sbic	0x1c, 1	; 28
   106de:	fe cf       	rjmp	.-4      	; 0x106dc <FSettingDec+0x70>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   106e0:	8b e3       	ldi	r24, 0x3B	; 59
   106e2:	90 e0       	ldi	r25, 0x00	; 0
   106e4:	9f bb       	out	0x1f, r25	; 31
   106e6:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   106e8:	e0 9a       	sbi	0x1c, 0	; 28
   106ea:	fd b2       	in	r15, 0x1d	; 29
		  PDecimalConfig[0]=eeprom_read_byte(&DefDecimalPrice);
		  PDecimalConfig[1]=eeprom_read_byte(&DefDecimalVolume);
		  PDecimalConfig[2]=eeprom_read_byte(&DefDecimalMoney);

		  sprintf_P(lcdteks,PSTR("1.Price :%d"),PDecimalConfig[0]);
   106ec:	00 d0       	rcall	.+0      	; 0x106ee <FSettingDec+0x82>
   106ee:	00 d0       	rcall	.+0      	; 0x106f0 <FSettingDec+0x84>
   106f0:	00 d0       	rcall	.+0      	; 0x106f2 <FSettingDec+0x86>
   106f2:	ed b7       	in	r30, 0x3d	; 61
   106f4:	fe b7       	in	r31, 0x3e	; 62
   106f6:	31 96       	adiw	r30, 0x01	; 1
   106f8:	8e 01       	movw	r16, r28
   106fa:	0f 5f       	subi	r16, 0xFF	; 255
   106fc:	1f 4f       	sbci	r17, 0xFF	; 255
   106fe:	ad b7       	in	r26, 0x3d	; 61
   10700:	be b7       	in	r27, 0x3e	; 62
   10702:	12 96       	adiw	r26, 0x02	; 2
   10704:	1c 93       	st	X, r17
   10706:	0e 93       	st	-X, r16
   10708:	11 97       	sbiw	r26, 0x01	; 1
   1070a:	86 e9       	ldi	r24, 0x96	; 150
   1070c:	91 e1       	ldi	r25, 0x11	; 17
   1070e:	93 83       	std	Z+3, r25	; 0x03
   10710:	82 83       	std	Z+2, r24	; 0x02
   10712:	24 83       	std	Z+4, r18	; 0x04
   10714:	15 82       	std	Z+5, r1	; 0x05
   10716:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
		  lcd_print(1,1,lcdteks);
   1071a:	8d b7       	in	r24, 0x3d	; 61
   1071c:	9e b7       	in	r25, 0x3e	; 62
   1071e:	06 96       	adiw	r24, 0x06	; 6
   10720:	0f b6       	in	r0, 0x3f	; 63
   10722:	f8 94       	cli
   10724:	9e bf       	out	0x3e, r25	; 62
   10726:	0f be       	out	0x3f, r0	; 63
   10728:	8d bf       	out	0x3d, r24	; 61
   1072a:	81 e0       	ldi	r24, 0x01	; 1
   1072c:	61 e0       	ldi	r22, 0x01	; 1
   1072e:	a8 01       	movw	r20, r16
   10730:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
		  sprintf_P(lcdteks,PSTR("2.Volume:%d"),PDecimalConfig[1]);
   10734:	00 d0       	rcall	.+0      	; 0x10736 <FSettingDec+0xca>
   10736:	00 d0       	rcall	.+0      	; 0x10738 <FSettingDec+0xcc>
   10738:	00 d0       	rcall	.+0      	; 0x1073a <FSettingDec+0xce>
   1073a:	ed b7       	in	r30, 0x3d	; 61
   1073c:	fe b7       	in	r31, 0x3e	; 62
   1073e:	31 96       	adiw	r30, 0x01	; 1
   10740:	ad b7       	in	r26, 0x3d	; 61
   10742:	be b7       	in	r27, 0x3e	; 62
   10744:	12 96       	adiw	r26, 0x02	; 2
   10746:	1c 93       	st	X, r17
   10748:	0e 93       	st	-X, r16
   1074a:	11 97       	sbiw	r26, 0x01	; 1
   1074c:	8a e8       	ldi	r24, 0x8A	; 138
   1074e:	91 e1       	ldi	r25, 0x11	; 17
   10750:	93 83       	std	Z+3, r25	; 0x03
   10752:	82 83       	std	Z+2, r24	; 0x02
   10754:	e4 82       	std	Z+4, r14	; 0x04
   10756:	15 82       	std	Z+5, r1	; 0x05
   10758:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
		  lcd_print(2,1,lcdteks);
   1075c:	8d b7       	in	r24, 0x3d	; 61
   1075e:	9e b7       	in	r25, 0x3e	; 62
   10760:	06 96       	adiw	r24, 0x06	; 6
   10762:	0f b6       	in	r0, 0x3f	; 63
   10764:	f8 94       	cli
   10766:	9e bf       	out	0x3e, r25	; 62
   10768:	0f be       	out	0x3f, r0	; 63
   1076a:	8d bf       	out	0x3d, r24	; 61
   1076c:	82 e0       	ldi	r24, 0x02	; 2
   1076e:	61 e0       	ldi	r22, 0x01	; 1
   10770:	a8 01       	movw	r20, r16
   10772:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
		  sprintf_P(lcdteks,PSTR("3.Money :%d"),PDecimalConfig[2]);
   10776:	00 d0       	rcall	.+0      	; 0x10778 <FSettingDec+0x10c>
   10778:	00 d0       	rcall	.+0      	; 0x1077a <FSettingDec+0x10e>
   1077a:	00 d0       	rcall	.+0      	; 0x1077c <FSettingDec+0x110>
   1077c:	ed b7       	in	r30, 0x3d	; 61
   1077e:	fe b7       	in	r31, 0x3e	; 62
   10780:	31 96       	adiw	r30, 0x01	; 1
   10782:	ad b7       	in	r26, 0x3d	; 61
   10784:	be b7       	in	r27, 0x3e	; 62
   10786:	12 96       	adiw	r26, 0x02	; 2
   10788:	1c 93       	st	X, r17
   1078a:	0e 93       	st	-X, r16
   1078c:	11 97       	sbiw	r26, 0x01	; 1
   1078e:	8e e7       	ldi	r24, 0x7E	; 126
   10790:	91 e1       	ldi	r25, 0x11	; 17
   10792:	93 83       	std	Z+3, r25	; 0x03
   10794:	82 83       	std	Z+2, r24	; 0x02
   10796:	f4 82       	std	Z+4, r15	; 0x04
   10798:	15 82       	std	Z+5, r1	; 0x05
   1079a:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
		  lcd_print(3,1,lcdteks);
   1079e:	8d b7       	in	r24, 0x3d	; 61
   107a0:	9e b7       	in	r25, 0x3e	; 62
   107a2:	06 96       	adiw	r24, 0x06	; 6
   107a4:	0f b6       	in	r0, 0x3f	; 63
   107a6:	f8 94       	cli
   107a8:	9e bf       	out	0x3e, r25	; 62
   107aa:	0f be       	out	0x3f, r0	; 63
   107ac:	8d bf       	out	0x3d, r24	; 61
   107ae:	83 e0       	ldi	r24, 0x03	; 3
   107b0:	61 e0       	ldi	r22, 0x01	; 1
   107b2:	a8 01       	movw	r20, r16
   107b4:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
		  lcd_printf(4,1,PSTR("[*]Back  [#]Next"));
   107b8:	84 e0       	ldi	r24, 0x04	; 4
   107ba:	61 e0       	ldi	r22, 0x01	; 1
   107bc:	4d e6       	ldi	r20, 0x6D	; 109
   107be:	51 e1       	ldi	r21, 0x11	; 17
   107c0:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		  stSettingDecimal=sdSelectKey1;
   107c4:	81 e0       	ldi	r24, 0x01	; 1
   107c6:	29 c1       	rjmp	.+594    	; 0x10a1a <FSettingDec+0x3ae>
		  break;
     case sdSelectKey1:
          KeyChar=_key_btn(_key_scan(1));
   107c8:	81 e0       	ldi	r24, 0x01	; 1
   107ca:	0e 94 84 ae 	call	0x15d08	; 0x15d08 <_key_scan>
   107ce:	0e 94 e5 ad 	call	0x15bca	; 0x15bca <_key_btn>
		  if ((KeyChar>='1')&&(KeyChar<='3')){
   107d2:	98 2f       	mov	r25, r24
   107d4:	91 53       	subi	r25, 0x31	; 49
   107d6:	93 30       	cpi	r25, 0x03	; 3
   107d8:	e0 f4       	brcc	.+56     	; 0x10812 <FSettingDec+0x1a6>
		      Addr=KeyChar-'1';
		  	  PDecimalConfig[Addr]=eeprom_read_byte(&DefDecimalPrice+Addr);
   107da:	29 2f       	mov	r18, r25
   107dc:	30 e0       	ldi	r19, 0x00	; 0
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   107de:	e1 99       	sbic	0x1c, 1	; 28
   107e0:	fe cf       	rjmp	.-4      	; 0x107de <FSettingDec+0x172>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   107e2:	c9 01       	movw	r24, r18
   107e4:	87 5c       	subi	r24, 0xC7	; 199
   107e6:	9f 4f       	sbci	r25, 0xFF	; 255
   107e8:	9f bb       	out	0x1f, r25	; 31
   107ea:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   107ec:	e0 9a       	sbi	0x1c, 0	; 28
   107ee:	8d b3       	in	r24, 0x1d	; 29
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   107f0:	e1 99       	sbic	0x1c, 1	; 28
   107f2:	fe cf       	rjmp	.-4      	; 0x107f0 <FSettingDec+0x184>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   107f4:	27 5c       	subi	r18, 0xC7	; 199
   107f6:	3f 4f       	sbci	r19, 0xFF	; 255
   107f8:	3f bb       	out	0x1f, r19	; 31
   107fa:	2e bb       	out	0x1e, r18	; 30
			  PDecimalConfig[Addr]=(PDecimalConfig[Addr]+1)%4;
   107fc:	90 e0       	ldi	r25, 0x00	; 0
   107fe:	01 96       	adiw	r24, 0x01	; 1
   10800:	83 70       	andi	r24, 0x03	; 3
   10802:	90 70       	andi	r25, 0x00	; 0
#endif
    EEDR = __value;
   10804:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
   10806:	0f b6       	in	r0, 0x3f	; 63
   10808:	f8 94       	cli
   1080a:	e2 9a       	sbi	0x1c, 2	; 28
   1080c:	e1 9a       	sbi	0x1c, 1	; 28
   1080e:	0f be       	out	0x3f, r0	; 63
   10810:	f6 c0       	rjmp	.+492    	; 0x109fe <FSettingDec+0x392>

			  eeprom_write_byte(&DefDecimalPrice+Addr,PDecimalConfig[Addr]);
              stSettingDecimal=sdInitDisplay;
		  }else if (KeyChar=='*') stSettingDecimal=sdExitSettingDecimal;
   10812:	8a 32       	cpi	r24, 0x2A	; 42
   10814:	11 f4       	brne	.+4      	; 0x1081a <FSettingDec+0x1ae>
   10816:	85 e0       	ldi	r24, 0x05	; 5
   10818:	00 c1       	rjmp	.+512    	; 0x10a1a <FSettingDec+0x3ae>
		  else if (KeyChar=='#') stSettingDecimal=sdInitDisplay2;
   1081a:	83 32       	cpi	r24, 0x23	; 35
   1081c:	09 f0       	breq	.+2      	; 0x10820 <FSettingDec+0x1b4>
   1081e:	04 c1       	rjmp	.+520    	; 0x10a28 <FSettingDec+0x3bc>
   10820:	fb c0       	rjmp	.+502    	; 0x10a18 <FSettingDec+0x3ac>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   10822:	e1 99       	sbic	0x1c, 1	; 28
   10824:	fe cf       	rjmp	.-4      	; 0x10822 <FSettingDec+0x1b6>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   10826:	8c e3       	ldi	r24, 0x3C	; 60
   10828:	90 e0       	ldi	r25, 0x00	; 0
   1082a:	9f bb       	out	0x1f, r25	; 31
   1082c:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   1082e:	e0 9a       	sbi	0x1c, 0	; 28
   10830:	2d b3       	in	r18, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   10832:	e1 99       	sbic	0x1c, 1	; 28
   10834:	fe cf       	rjmp	.-4      	; 0x10832 <FSettingDec+0x1c6>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   10836:	8d e3       	ldi	r24, 0x3D	; 61
   10838:	90 e0       	ldi	r25, 0x00	; 0
   1083a:	9f bb       	out	0x1f, r25	; 31
   1083c:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   1083e:	e0 9a       	sbi	0x1c, 0	; 28
   10840:	ed b2       	in	r14, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   10842:	e1 99       	sbic	0x1c, 1	; 28
   10844:	fe cf       	rjmp	.-4      	; 0x10842 <FSettingDec+0x1d6>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   10846:	8e e3       	ldi	r24, 0x3E	; 62
   10848:	90 e0       	ldi	r25, 0x00	; 0
   1084a:	9f bb       	out	0x1f, r25	; 31
   1084c:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   1084e:	e0 9a       	sbi	0x1c, 0	; 28
   10850:	dd b2       	in	r13, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   10852:	e1 99       	sbic	0x1c, 1	; 28
   10854:	fe cf       	rjmp	.-4      	; 0x10852 <FSettingDec+0x1e6>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   10856:	8f e3       	ldi	r24, 0x3F	; 63
   10858:	90 e0       	ldi	r25, 0x00	; 0
   1085a:	9f bb       	out	0x1f, r25	; 31
   1085c:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   1085e:	e0 9a       	sbi	0x1c, 0	; 28
   10860:	fd b2       	in	r15, 0x1d	; 29
     case sdInitDisplay2:
		  PDecimalConfig[0]=eeprom_read_byte(&DefDecimalTotalVolume);
		  PDecimalConfig[1]=eeprom_read_byte(&DefDecimalTotalMoney);
		  PDecimalConfig[2]=eeprom_read_byte(&DefDecimalMark);
		  PDecimalConfig[3]=eeprom_read_byte(&DefCurrencyMark);
		  sprintf_P(lcdteks,PSTR("1.T.Volume:%d  5.Test"),PDecimalConfig[0]);
   10862:	00 d0       	rcall	.+0      	; 0x10864 <FSettingDec+0x1f8>
   10864:	00 d0       	rcall	.+0      	; 0x10866 <FSettingDec+0x1fa>
   10866:	00 d0       	rcall	.+0      	; 0x10868 <FSettingDec+0x1fc>
   10868:	ed b7       	in	r30, 0x3d	; 61
   1086a:	fe b7       	in	r31, 0x3e	; 62
   1086c:	31 96       	adiw	r30, 0x01	; 1
   1086e:	8e 01       	movw	r16, r28
   10870:	0f 5f       	subi	r16, 0xFF	; 255
   10872:	1f 4f       	sbci	r17, 0xFF	; 255
   10874:	ad b7       	in	r26, 0x3d	; 61
   10876:	be b7       	in	r27, 0x3e	; 62
   10878:	12 96       	adiw	r26, 0x02	; 2
   1087a:	1c 93       	st	X, r17
   1087c:	0e 93       	st	-X, r16
   1087e:	11 97       	sbiw	r26, 0x01	; 1
   10880:	87 e5       	ldi	r24, 0x57	; 87
   10882:	91 e1       	ldi	r25, 0x11	; 17
   10884:	93 83       	std	Z+3, r25	; 0x03
   10886:	82 83       	std	Z+2, r24	; 0x02
   10888:	24 83       	std	Z+4, r18	; 0x04
   1088a:	15 82       	std	Z+5, r1	; 0x05
   1088c:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
		  lcd_print(1,1,lcdteks);
   10890:	8d b7       	in	r24, 0x3d	; 61
   10892:	9e b7       	in	r25, 0x3e	; 62
   10894:	06 96       	adiw	r24, 0x06	; 6
   10896:	0f b6       	in	r0, 0x3f	; 63
   10898:	f8 94       	cli
   1089a:	9e bf       	out	0x3e, r25	; 62
   1089c:	0f be       	out	0x3f, r0	; 63
   1089e:	8d bf       	out	0x3d, r24	; 61
   108a0:	81 e0       	ldi	r24, 0x01	; 1
   108a2:	61 e0       	ldi	r22, 0x01	; 1
   108a4:	a8 01       	movw	r20, r16
   108a6:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
		  sprintf_P(lcdteks,PSTR("2.T.Money :%d "),PDecimalConfig[1]);
   108aa:	00 d0       	rcall	.+0      	; 0x108ac <FSettingDec+0x240>
   108ac:	00 d0       	rcall	.+0      	; 0x108ae <FSettingDec+0x242>
   108ae:	00 d0       	rcall	.+0      	; 0x108b0 <FSettingDec+0x244>
   108b0:	ed b7       	in	r30, 0x3d	; 61
   108b2:	fe b7       	in	r31, 0x3e	; 62
   108b4:	31 96       	adiw	r30, 0x01	; 1
   108b6:	ad b7       	in	r26, 0x3d	; 61
   108b8:	be b7       	in	r27, 0x3e	; 62
   108ba:	12 96       	adiw	r26, 0x02	; 2
   108bc:	1c 93       	st	X, r17
   108be:	0e 93       	st	-X, r16
   108c0:	11 97       	sbiw	r26, 0x01	; 1
   108c2:	88 e4       	ldi	r24, 0x48	; 72
   108c4:	91 e1       	ldi	r25, 0x11	; 17
   108c6:	93 83       	std	Z+3, r25	; 0x03
   108c8:	82 83       	std	Z+2, r24	; 0x02
   108ca:	e4 82       	std	Z+4, r14	; 0x04
   108cc:	15 82       	std	Z+5, r1	; 0x05
   108ce:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
		  lcd_print(2,1,lcdteks);
   108d2:	8d b7       	in	r24, 0x3d	; 61
   108d4:	9e b7       	in	r25, 0x3e	; 62
   108d6:	06 96       	adiw	r24, 0x06	; 6
   108d8:	0f b6       	in	r0, 0x3f	; 63
   108da:	f8 94       	cli
   108dc:	9e bf       	out	0x3e, r25	; 62
   108de:	0f be       	out	0x3f, r0	; 63
   108e0:	8d bf       	out	0x3d, r24	; 61
   108e2:	82 e0       	ldi	r24, 0x02	; 2
   108e4:	61 e0       	ldi	r22, 0x01	; 1
   108e6:	a8 01       	movw	r20, r16
   108e8:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
		  sprintf_P(lcdteks,PSTR("3.Decimal :%c "),PDecimalConfig[2]);
   108ec:	00 d0       	rcall	.+0      	; 0x108ee <FSettingDec+0x282>
   108ee:	00 d0       	rcall	.+0      	; 0x108f0 <FSettingDec+0x284>
   108f0:	00 d0       	rcall	.+0      	; 0x108f2 <FSettingDec+0x286>
   108f2:	ed b7       	in	r30, 0x3d	; 61
   108f4:	fe b7       	in	r31, 0x3e	; 62
   108f6:	31 96       	adiw	r30, 0x01	; 1
   108f8:	ad b7       	in	r26, 0x3d	; 61
   108fa:	be b7       	in	r27, 0x3e	; 62
   108fc:	12 96       	adiw	r26, 0x02	; 2
   108fe:	1c 93       	st	X, r17
   10900:	0e 93       	st	-X, r16
   10902:	11 97       	sbiw	r26, 0x01	; 1
   10904:	89 e3       	ldi	r24, 0x39	; 57
   10906:	91 e1       	ldi	r25, 0x11	; 17
   10908:	93 83       	std	Z+3, r25	; 0x03
   1090a:	82 83       	std	Z+2, r24	; 0x02
   1090c:	d4 82       	std	Z+4, r13	; 0x04
   1090e:	15 82       	std	Z+5, r1	; 0x05
   10910:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
		  lcd_print(3,1,lcdteks);
   10914:	8d b7       	in	r24, 0x3d	; 61
   10916:	9e b7       	in	r25, 0x3e	; 62
   10918:	06 96       	adiw	r24, 0x06	; 6
   1091a:	0f b6       	in	r0, 0x3f	; 63
   1091c:	f8 94       	cli
   1091e:	9e bf       	out	0x3e, r25	; 62
   10920:	0f be       	out	0x3f, r0	; 63
   10922:	8d bf       	out	0x3d, r24	; 61
   10924:	83 e0       	ldi	r24, 0x03	; 3
   10926:	61 e0       	ldi	r22, 0x01	; 1
   10928:	a8 01       	movw	r20, r16
   1092a:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
		  sprintf_P(lcdteks,PSTR("4.Sparator:%c "),PDecimalConfig[3]);
   1092e:	00 d0       	rcall	.+0      	; 0x10930 <FSettingDec+0x2c4>
   10930:	00 d0       	rcall	.+0      	; 0x10932 <FSettingDec+0x2c6>
   10932:	00 d0       	rcall	.+0      	; 0x10934 <FSettingDec+0x2c8>
   10934:	ed b7       	in	r30, 0x3d	; 61
   10936:	fe b7       	in	r31, 0x3e	; 62
   10938:	31 96       	adiw	r30, 0x01	; 1
   1093a:	ad b7       	in	r26, 0x3d	; 61
   1093c:	be b7       	in	r27, 0x3e	; 62
   1093e:	12 96       	adiw	r26, 0x02	; 2
   10940:	1c 93       	st	X, r17
   10942:	0e 93       	st	-X, r16
   10944:	11 97       	sbiw	r26, 0x01	; 1
   10946:	8a e2       	ldi	r24, 0x2A	; 42
   10948:	91 e1       	ldi	r25, 0x11	; 17
   1094a:	93 83       	std	Z+3, r25	; 0x03
   1094c:	82 83       	std	Z+2, r24	; 0x02
   1094e:	f4 82       	std	Z+4, r15	; 0x04
   10950:	15 82       	std	Z+5, r1	; 0x05
   10952:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
		  lcd_print(4,1,lcdteks);
   10956:	8d b7       	in	r24, 0x3d	; 61
   10958:	9e b7       	in	r25, 0x3e	; 62
   1095a:	06 96       	adiw	r24, 0x06	; 6
   1095c:	0f b6       	in	r0, 0x3f	; 63
   1095e:	f8 94       	cli
   10960:	9e bf       	out	0x3e, r25	; 62
   10962:	0f be       	out	0x3f, r0	; 63
   10964:	8d bf       	out	0x3d, r24	; 61
   10966:	84 e0       	ldi	r24, 0x04	; 4
   10968:	61 e0       	ldi	r22, 0x01	; 1
   1096a:	a8 01       	movw	r20, r16
   1096c:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
		  lcd_printf(4,14,PSTR("*)Back"));
   10970:	84 e0       	ldi	r24, 0x04	; 4
   10972:	6e e0       	ldi	r22, 0x0E	; 14
   10974:	43 e2       	ldi	r20, 0x23	; 35
   10976:	51 e1       	ldi	r21, 0x11	; 17
   10978:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
	      stSettingDecimal=sdSelectKey2;
   1097c:	83 e0       	ldi	r24, 0x03	; 3
   1097e:	4d c0       	rjmp	.+154    	; 0x10a1a <FSettingDec+0x3ae>
	      break;
     case sdSelectKey2:
          KeyChar=_key_btn(_key_scan(1));
   10980:	81 e0       	ldi	r24, 0x01	; 1
   10982:	0e 94 84 ae 	call	0x15d08	; 0x15d08 <_key_scan>
   10986:	0e 94 e5 ad 	call	0x15bca	; 0x15bca <_key_btn>
   1098a:	28 2f       	mov	r18, r24
		  if ((KeyChar>='1')&&(KeyChar<='2')){
   1098c:	98 2f       	mov	r25, r24
   1098e:	91 53       	subi	r25, 0x31	; 49
   10990:	92 30       	cpi	r25, 0x02	; 2
   10992:	b0 f4       	brcc	.+44     	; 0x109c0 <FSettingDec+0x354>
		      Addr=KeyChar-'1';
		  	  PDecimalConfig[Addr]=eeprom_read_byte(&DefDecimalTotalVolume+Addr);
   10994:	29 2f       	mov	r18, r25
   10996:	30 e0       	ldi	r19, 0x00	; 0
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   10998:	e1 99       	sbic	0x1c, 1	; 28
   1099a:	fe cf       	rjmp	.-4      	; 0x10998 <FSettingDec+0x32c>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   1099c:	c9 01       	movw	r24, r18
   1099e:	84 5c       	subi	r24, 0xC4	; 196
   109a0:	9f 4f       	sbci	r25, 0xFF	; 255
   109a2:	9f bb       	out	0x1f, r25	; 31
   109a4:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   109a6:	e0 9a       	sbi	0x1c, 0	; 28
   109a8:	8d b3       	in	r24, 0x1d	; 29
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   109aa:	e1 99       	sbic	0x1c, 1	; 28
   109ac:	fe cf       	rjmp	.-4      	; 0x109aa <FSettingDec+0x33e>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   109ae:	24 5c       	subi	r18, 0xC4	; 196
   109b0:	3f 4f       	sbci	r19, 0xFF	; 255
   109b2:	3f bb       	out	0x1f, r19	; 31
   109b4:	2e bb       	out	0x1e, r18	; 30
		      PDecimalConfig[Addr]=(PDecimalConfig[Addr]+1)%4;
   109b6:	90 e0       	ldi	r25, 0x00	; 0
   109b8:	01 96       	adiw	r24, 0x01	; 1
   109ba:	83 70       	andi	r24, 0x03	; 3
   109bc:	90 70       	andi	r25, 0x00	; 0
   109be:	16 c0       	rjmp	.+44     	; 0x109ec <FSettingDec+0x380>

			  eeprom_write_byte(&DefDecimalTotalVolume+Addr,PDecimalConfig[Addr]);
              stSettingDecimal=sdInitDisplay2;
		  }else if ((KeyChar>='3')&&(KeyChar<='4')){
   109c0:	83 53       	subi	r24, 0x33	; 51
   109c2:	82 30       	cpi	r24, 0x02	; 2
   109c4:	d0 f4       	brcc	.+52     	; 0x109fa <FSettingDec+0x38e>
		      Addr=KeyChar-'1';
		  	  PDecimalConfig[Addr]=eeprom_read_byte(&DefDecimalTotalVolume+Addr);
   109c6:	09 2f       	mov	r16, r25
   109c8:	10 e0       	ldi	r17, 0x00	; 0
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   109ca:	e1 99       	sbic	0x1c, 1	; 28
   109cc:	fe cf       	rjmp	.-4      	; 0x109ca <FSettingDec+0x35e>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   109ce:	c8 01       	movw	r24, r16
   109d0:	84 5c       	subi	r24, 0xC4	; 196
   109d2:	9f 4f       	sbci	r25, 0xFF	; 255
   109d4:	9f bb       	out	0x1f, r25	; 31
   109d6:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   109d8:	e0 9a       	sbi	0x1c, 0	; 28
   109da:	8d b3       	in	r24, 0x1d	; 29
			  PDecimalConfig[Addr]=SelectMark(PDecimalConfig[Addr]);
   109dc:	0e 94 94 1e 	call	0x3d28	; 0x3d28 <SelectMark>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   109e0:	e1 99       	sbic	0x1c, 1	; 28
   109e2:	fe cf       	rjmp	.-4      	; 0x109e0 <FSettingDec+0x374>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   109e4:	04 5c       	subi	r16, 0xC4	; 196
   109e6:	1f 4f       	sbci	r17, 0xFF	; 255
   109e8:	1f bb       	out	0x1f, r17	; 31
   109ea:	0e bb       	out	0x1e, r16	; 30
#endif
    EEDR = __value;
   109ec:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
   109ee:	0f b6       	in	r0, 0x3f	; 63
   109f0:	f8 94       	cli
   109f2:	e2 9a       	sbi	0x1c, 2	; 28
   109f4:	e1 9a       	sbi	0x1c, 1	; 28
   109f6:	0f be       	out	0x3f, r0	; 63
   109f8:	0f c0       	rjmp	.+30     	; 0x10a18 <FSettingDec+0x3ac>
			  eeprom_write_byte(&DefDecimalTotalVolume+Addr,PDecimalConfig[Addr]);
              stSettingDecimal=sdInitDisplay2;
		  }else if (KeyChar=='*') stSettingDecimal=sdInitDisplay;
   109fa:	2a 32       	cpi	r18, 0x2A	; 42
   109fc:	19 f4       	brne	.+6      	; 0x10a04 <FSettingDec+0x398>
   109fe:	10 92 70 02 	sts	0x0270, r1
   10a02:	12 c0       	rjmp	.+36     	; 0x10a28 <FSettingDec+0x3bc>
		  else if (KeyChar=='5'){
   10a04:	25 33       	cpi	r18, 0x35	; 53
   10a06:	81 f4       	brne	.+32     	; 0x10a28 <FSettingDec+0x3bc>
		          lcd_clear();
   10a08:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
		          stSettingDecimal=sdTestInput;
   10a0c:	84 e0       	ldi	r24, 0x04	; 4
   10a0e:	05 c0       	rjmp	.+10     	; 0x10a1a <FSettingDec+0x3ae>
				  }
          break;
     case sdTestInput:
	      if (TestUserInput()==MENU_DONE)stSettingDecimal=sdInitDisplay2;
   10a10:	0e 94 fc 80 	call	0x101f8	; 0x101f8 <TestUserInput>
   10a14:	81 30       	cpi	r24, 0x01	; 1
   10a16:	41 f4       	brne	.+16     	; 0x10a28 <FSettingDec+0x3bc>
   10a18:	82 e0       	ldi	r24, 0x02	; 2
   10a1a:	80 93 70 02 	sts	0x0270, r24
   10a1e:	04 c0       	rjmp	.+8      	; 0x10a28 <FSettingDec+0x3bc>
	      break;
	 case sdExitSettingDecimal:
          stSettingDecimal=sdInitDisplay;
   10a20:	10 92 70 02 	sts	0x0270, r1
   10a24:	81 e0       	ldi	r24, 0x01	; 1
   10a26:	01 c0       	rjmp	.+2      	; 0x10a2a <FSettingDec+0x3be>
   10a28:	80 e0       	ldi	r24, 0x00	; 0
		  Result=MENU_DONE;
	      break;
	 }
    return Result;
}
   10a2a:	64 96       	adiw	r28, 0x14	; 20
   10a2c:	0f b6       	in	r0, 0x3f	; 63
   10a2e:	f8 94       	cli
   10a30:	de bf       	out	0x3e, r29	; 62
   10a32:	0f be       	out	0x3f, r0	; 63
   10a34:	cd bf       	out	0x3d, r28	; 61
   10a36:	cf 91       	pop	r28
   10a38:	df 91       	pop	r29
   10a3a:	1f 91       	pop	r17
   10a3c:	0f 91       	pop	r16
   10a3e:	ff 90       	pop	r15
   10a40:	ef 90       	pop	r14
   10a42:	df 90       	pop	r13
   10a44:	08 95       	ret

00010a46 <FTestCalculation>:
	 }
  return Result;
}


void FTestCalculation(){
   10a46:	cf 92       	push	r12
   10a48:	df 92       	push	r13
   10a4a:	ef 92       	push	r14
   10a4c:	ff 92       	push	r15
   10a4e:	0f 93       	push	r16
   10a50:	1f 93       	push	r17
   10a52:	df 93       	push	r29
   10a54:	cf 93       	push	r28
   10a56:	cd b7       	in	r28, 0x3d	; 61
   10a58:	de b7       	in	r29, 0x3e	; 62
   10a5a:	64 97       	sbiw	r28, 0x14	; 20
   10a5c:	0f b6       	in	r0, 0x3f	; 63
   10a5e:	f8 94       	cli
   10a60:	de bf       	out	0x3e, r29	; 62
   10a62:	0f be       	out	0x3f, r0	; 63
   10a64:	cd bf       	out	0x3d, r28	; 61
static char stTestCalc=tcInitData,uiResult=USER_NONE;
static char InputA[20],InputB[20],OutputC[20];
     char lcdteks[20],KeyChar;
     
	 switch(stTestCalc){
   10a66:	80 91 38 02 	lds	r24, 0x0238
   10a6a:	82 30       	cpi	r24, 0x02	; 2
   10a6c:	09 f4       	brne	.+2      	; 0x10a70 <FTestCalculation+0x2a>
   10a6e:	4b c0       	rjmp	.+150    	; 0x10b06 <FTestCalculation+0xc0>
   10a70:	83 30       	cpi	r24, 0x03	; 3
   10a72:	30 f4       	brcc	.+12     	; 0x10a80 <FTestCalculation+0x3a>
   10a74:	88 23       	and	r24, r24
   10a76:	71 f0       	breq	.+28     	; 0x10a94 <FTestCalculation+0x4e>
   10a78:	81 30       	cpi	r24, 0x01	; 1
   10a7a:	09 f0       	breq	.+2      	; 0x10a7e <FTestCalculation+0x38>
   10a7c:	e7 c0       	rjmp	.+462    	; 0x10c4c <FTestCalculation+0x206>
   10a7e:	2f c0       	rjmp	.+94     	; 0x10ade <FTestCalculation+0x98>
   10a80:	84 30       	cpi	r24, 0x04	; 4
   10a82:	09 f4       	brne	.+2      	; 0x10a86 <FTestCalculation+0x40>
   10a84:	82 c0       	rjmp	.+260    	; 0x10b8a <FTestCalculation+0x144>
   10a86:	84 30       	cpi	r24, 0x04	; 4
   10a88:	08 f4       	brcc	.+2      	; 0x10a8c <FTestCalculation+0x46>
   10a8a:	6d c0       	rjmp	.+218    	; 0x10b66 <FTestCalculation+0x120>
   10a8c:	85 30       	cpi	r24, 0x05	; 5
   10a8e:	09 f0       	breq	.+2      	; 0x10a92 <FTestCalculation+0x4c>
   10a90:	dd c0       	rjmp	.+442    	; 0x10c4c <FTestCalculation+0x206>
   10a92:	d1 c0       	rjmp	.+418    	; 0x10c36 <FTestCalculation+0x1f0>
	 case tcInitData:
	      lcd_clear();
   10a94:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
		  lcd_printf(1,1,PSTR("Operation Multiply"));
   10a98:	81 e0       	ldi	r24, 0x01	; 1
   10a9a:	61 e0       	ldi	r22, 0x01	; 1
   10a9c:	46 ea       	ldi	r20, 0xA6	; 166
   10a9e:	55 e0       	ldi	r21, 0x05	; 5
   10aa0:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		  lcd_printf(2,1,PSTR("InA:_"));
   10aa4:	82 e0       	ldi	r24, 0x02	; 2
   10aa6:	61 e0       	ldi	r22, 0x01	; 1
   10aa8:	40 ea       	ldi	r20, 0xA0	; 160
   10aaa:	55 e0       	ldi	r21, 0x05	; 5
   10aac:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
   10ab0:	a3 e2       	ldi	r26, 0x23	; 35
   10ab2:	b2 e0       	ldi	r27, 0x02	; 2
   10ab4:	fd 01       	movw	r30, r26
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
   10ab6:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   10ab8:	82 e0       	ldi	r24, 0x02	; 2
   10aba:	e7 33       	cpi	r30, 0x37	; 55
   10abc:	f8 07       	cpc	r31, r24
   10abe:	d9 f7       	brne	.-10     	; 0x10ab6 <FTestCalculation+0x70>
   10ac0:	74 97       	sbiw	r30, 0x14	; 20
	     strMemory[i]=data;
   10ac2:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   10ac4:	92 e0       	ldi	r25, 0x02	; 2
   10ac6:	e7 33       	cpi	r30, 0x37	; 55
   10ac8:	f9 07       	cpc	r31, r25
   10aca:	d9 f7       	brne	.-10     	; 0x10ac2 <FTestCalculation+0x7c>
	     strMemory[i]=data;
   10acc:	1d 92       	st	X+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   10ace:	82 e0       	ldi	r24, 0x02	; 2
   10ad0:	a7 33       	cpi	r26, 0x37	; 55
   10ad2:	b8 07       	cpc	r27, r24
   10ad4:	d9 f7       	brne	.-10     	; 0x10acc <FTestCalculation+0x86>
		  lcd_printf(2,1,PSTR("InA:_"));
		  FillChar(InputA,sizeof(InputA),0);
		  FillChar(InputA,sizeof(InputB),0);
		  FillChar(InputA,sizeof(OutputC),0);

		  uiResult=USER_NONE;
   10ad6:	10 92 37 02 	sts	0x0237, r1
          stTestCalc=tcInputA;
   10ada:	81 e0       	ldi	r24, 0x01	; 1
   10adc:	11 c0       	rjmp	.+34     	; 0x10b00 <FTestCalculation+0xba>
	      break;
     case tcInputA:
	      uiResult=UserInput(UI_ALPHANUM_R,2,5,InputA,0,15);
   10ade:	83 e0       	ldi	r24, 0x03	; 3
   10ae0:	62 e0       	ldi	r22, 0x02	; 2
   10ae2:	45 e0       	ldi	r20, 0x05	; 5
   10ae4:	23 e2       	ldi	r18, 0x23	; 35
   10ae6:	32 e0       	ldi	r19, 0x02	; 2
   10ae8:	00 e0       	ldi	r16, 0x00	; 0
   10aea:	10 e0       	ldi	r17, 0x00	; 0
   10aec:	9f e0       	ldi	r25, 0x0F	; 15
   10aee:	e9 2e       	mov	r14, r25
   10af0:	0e 94 d8 7d 	call	0xfbb0	; 0xfbb0 <UserInput>
   10af4:	80 93 37 02 	sts	0x0237, r24
	      if (uiResult==USER_OK)stTestCalc=tcDispInputA;
   10af8:	83 30       	cpi	r24, 0x03	; 3
   10afa:	09 f0       	breq	.+2      	; 0x10afe <FTestCalculation+0xb8>
   10afc:	a7 c0       	rjmp	.+334    	; 0x10c4c <FTestCalculation+0x206>
   10afe:	82 e0       	ldi	r24, 0x02	; 2
   10b00:	80 93 38 02 	sts	0x0238, r24
   10b04:	a3 c0       	rjmp	.+326    	; 0x10c4c <FTestCalculation+0x206>
	      break;
     case tcDispInputA:
	      sprintf_P(lcdteks,PSTR("InA:%s"),InputA);
   10b06:	00 d0       	rcall	.+0      	; 0x10b08 <FTestCalculation+0xc2>
   10b08:	00 d0       	rcall	.+0      	; 0x10b0a <FTestCalculation+0xc4>
   10b0a:	00 d0       	rcall	.+0      	; 0x10b0c <FTestCalculation+0xc6>
   10b0c:	ed b7       	in	r30, 0x3d	; 61
   10b0e:	fe b7       	in	r31, 0x3e	; 62
   10b10:	31 96       	adiw	r30, 0x01	; 1
   10b12:	8e 01       	movw	r16, r28
   10b14:	0f 5f       	subi	r16, 0xFF	; 255
   10b16:	1f 4f       	sbci	r17, 0xFF	; 255
   10b18:	ad b7       	in	r26, 0x3d	; 61
   10b1a:	be b7       	in	r27, 0x3e	; 62
   10b1c:	12 96       	adiw	r26, 0x02	; 2
   10b1e:	1c 93       	st	X, r17
   10b20:	0e 93       	st	-X, r16
   10b22:	11 97       	sbiw	r26, 0x01	; 1
   10b24:	89 e9       	ldi	r24, 0x99	; 153
   10b26:	95 e0       	ldi	r25, 0x05	; 5
   10b28:	93 83       	std	Z+3, r25	; 0x03
   10b2a:	82 83       	std	Z+2, r24	; 0x02
   10b2c:	83 e2       	ldi	r24, 0x23	; 35
   10b2e:	92 e0       	ldi	r25, 0x02	; 2
   10b30:	95 83       	std	Z+5, r25	; 0x05
   10b32:	84 83       	std	Z+4, r24	; 0x04
   10b34:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
		  lcd_print(2,1,lcdteks);
   10b38:	8d b7       	in	r24, 0x3d	; 61
   10b3a:	9e b7       	in	r25, 0x3e	; 62
   10b3c:	06 96       	adiw	r24, 0x06	; 6
   10b3e:	0f b6       	in	r0, 0x3f	; 63
   10b40:	f8 94       	cli
   10b42:	9e bf       	out	0x3e, r25	; 62
   10b44:	0f be       	out	0x3f, r0	; 63
   10b46:	8d bf       	out	0x3d, r24	; 61
   10b48:	82 e0       	ldi	r24, 0x02	; 2
   10b4a:	61 e0       	ldi	r22, 0x01	; 1
   10b4c:	a8 01       	movw	r20, r16
   10b4e:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
		  lcd_printf(3,1,PSTR("InB:_"));
   10b52:	83 e0       	ldi	r24, 0x03	; 3
   10b54:	61 e0       	ldi	r22, 0x01	; 1
   10b56:	43 e9       	ldi	r20, 0x93	; 147
   10b58:	55 e0       	ldi	r21, 0x05	; 5
   10b5a:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		  uiResult=USER_NONE;
   10b5e:	10 92 37 02 	sts	0x0237, r1
          stTestCalc=tcInputB;
   10b62:	83 e0       	ldi	r24, 0x03	; 3
   10b64:	cd cf       	rjmp	.-102    	; 0x10b00 <FTestCalculation+0xba>
	      break;
     case tcInputB:
	 	  uiResult=UserInput(UI_ALPHANUM_R,3,5,InputB,0,15);
   10b66:	83 e0       	ldi	r24, 0x03	; 3
   10b68:	63 e0       	ldi	r22, 0x03	; 3
   10b6a:	45 e0       	ldi	r20, 0x05	; 5
   10b6c:	2f e0       	ldi	r18, 0x0F	; 15
   10b6e:	32 e0       	ldi	r19, 0x02	; 2
   10b70:	00 e0       	ldi	r16, 0x00	; 0
   10b72:	10 e0       	ldi	r17, 0x00	; 0
   10b74:	bf e0       	ldi	r27, 0x0F	; 15
   10b76:	eb 2e       	mov	r14, r27
   10b78:	0e 94 d8 7d 	call	0xfbb0	; 0xfbb0 <UserInput>
   10b7c:	80 93 37 02 	sts	0x0237, r24
	      if (uiResult==USER_OK)stTestCalc=tcCalcualte;
   10b80:	83 30       	cpi	r24, 0x03	; 3
   10b82:	09 f0       	breq	.+2      	; 0x10b86 <FTestCalculation+0x140>
   10b84:	63 c0       	rjmp	.+198    	; 0x10c4c <FTestCalculation+0x206>
   10b86:	84 e0       	ldi	r24, 0x04	; 4
   10b88:	bb cf       	rjmp	.-138    	; 0x10b00 <FTestCalculation+0xba>
	      break;
     case tcCalcualte:
	      sprintf_P(lcdteks,PSTR("InB:%s"),InputB);
   10b8a:	00 d0       	rcall	.+0      	; 0x10b8c <FTestCalculation+0x146>
   10b8c:	00 d0       	rcall	.+0      	; 0x10b8e <FTestCalculation+0x148>
   10b8e:	00 d0       	rcall	.+0      	; 0x10b90 <FTestCalculation+0x14a>
   10b90:	ed b7       	in	r30, 0x3d	; 61
   10b92:	fe b7       	in	r31, 0x3e	; 62
   10b94:	31 96       	adiw	r30, 0x01	; 1
   10b96:	8e 01       	movw	r16, r28
   10b98:	0f 5f       	subi	r16, 0xFF	; 255
   10b9a:	1f 4f       	sbci	r17, 0xFF	; 255
   10b9c:	ad b7       	in	r26, 0x3d	; 61
   10b9e:	be b7       	in	r27, 0x3e	; 62
   10ba0:	12 96       	adiw	r26, 0x02	; 2
   10ba2:	1c 93       	st	X, r17
   10ba4:	0e 93       	st	-X, r16
   10ba6:	11 97       	sbiw	r26, 0x01	; 1
   10ba8:	8c e8       	ldi	r24, 0x8C	; 140
   10baa:	95 e0       	ldi	r25, 0x05	; 5
   10bac:	93 83       	std	Z+3, r25	; 0x03
   10bae:	82 83       	std	Z+2, r24	; 0x02
   10bb0:	af e0       	ldi	r26, 0x0F	; 15
   10bb2:	ea 2e       	mov	r14, r26
   10bb4:	a2 e0       	ldi	r26, 0x02	; 2
   10bb6:	fa 2e       	mov	r15, r26
   10bb8:	f5 82       	std	Z+5, r15	; 0x05
   10bba:	e4 82       	std	Z+4, r14	; 0x04
   10bbc:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
		  lcd_print(3,1,lcdteks);
   10bc0:	8d b7       	in	r24, 0x3d	; 61
   10bc2:	9e b7       	in	r25, 0x3e	; 62
   10bc4:	06 96       	adiw	r24, 0x06	; 6
   10bc6:	0f b6       	in	r0, 0x3f	; 63
   10bc8:	f8 94       	cli
   10bca:	9e bf       	out	0x3e, r25	; 62
   10bcc:	0f be       	out	0x3f, r0	; 63
   10bce:	8d bf       	out	0x3d, r24	; 61
   10bd0:	83 e0       	ldi	r24, 0x03	; 3
   10bd2:	61 e0       	ldi	r22, 0x01	; 1
   10bd4:	a8 01       	movw	r20, r16
   10bd6:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
		  //StrCalc(TMINUS,InputA,InputB,OutputC);
		  //StrCalc(TPLUS,InputA,InputB,OutputC);
		  StrCalc(TMULTIPLY,InputA,InputB,OutputC);
   10bda:	7b ef       	ldi	r23, 0xFB	; 251
   10bdc:	c7 2e       	mov	r12, r23
   10bde:	71 e0       	ldi	r23, 0x01	; 1
   10be0:	d7 2e       	mov	r13, r23
   10be2:	82 e0       	ldi	r24, 0x02	; 2
   10be4:	63 e2       	ldi	r22, 0x23	; 35
   10be6:	72 e0       	ldi	r23, 0x02	; 2
   10be8:	a7 01       	movw	r20, r14
   10bea:	96 01       	movw	r18, r12
   10bec:	0e 94 53 29 	call	0x52a6	; 0x52a6 <StrCalc>
	      sprintf_P(lcdteks,PSTR("A+B:%s"),OutputC);
   10bf0:	00 d0       	rcall	.+0      	; 0x10bf2 <FTestCalculation+0x1ac>
   10bf2:	00 d0       	rcall	.+0      	; 0x10bf4 <FTestCalculation+0x1ae>
   10bf4:	00 d0       	rcall	.+0      	; 0x10bf6 <FTestCalculation+0x1b0>
   10bf6:	ed b7       	in	r30, 0x3d	; 61
   10bf8:	fe b7       	in	r31, 0x3e	; 62
   10bfa:	31 96       	adiw	r30, 0x01	; 1
   10bfc:	ad b7       	in	r26, 0x3d	; 61
   10bfe:	be b7       	in	r27, 0x3e	; 62
   10c00:	12 96       	adiw	r26, 0x02	; 2
   10c02:	1c 93       	st	X, r17
   10c04:	0e 93       	st	-X, r16
   10c06:	11 97       	sbiw	r26, 0x01	; 1
   10c08:	85 e8       	ldi	r24, 0x85	; 133
   10c0a:	95 e0       	ldi	r25, 0x05	; 5
   10c0c:	93 83       	std	Z+3, r25	; 0x03
   10c0e:	82 83       	std	Z+2, r24	; 0x02
   10c10:	d5 82       	std	Z+5, r13	; 0x05
   10c12:	c4 82       	std	Z+4, r12	; 0x04
   10c14:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
		  lcd_print(4,1,lcdteks);
   10c18:	8d b7       	in	r24, 0x3d	; 61
   10c1a:	9e b7       	in	r25, 0x3e	; 62
   10c1c:	06 96       	adiw	r24, 0x06	; 6
   10c1e:	0f b6       	in	r0, 0x3f	; 63
   10c20:	f8 94       	cli
   10c22:	9e bf       	out	0x3e, r25	; 62
   10c24:	0f be       	out	0x3f, r0	; 63
   10c26:	8d bf       	out	0x3d, r24	; 61
   10c28:	84 e0       	ldi	r24, 0x04	; 4
   10c2a:	61 e0       	ldi	r22, 0x01	; 1
   10c2c:	a8 01       	movw	r20, r16
   10c2e:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
          stTestCalc=tcWaitEnter;
   10c32:	85 e0       	ldi	r24, 0x05	; 5
   10c34:	65 cf       	rjmp	.-310    	; 0x10b00 <FTestCalculation+0xba>
	      break;
     case tcWaitEnter:
	      KeyChar= _key_btn(_key_scan(1));       
   10c36:	81 e0       	ldi	r24, 0x01	; 1
   10c38:	0e 94 84 ae 	call	0x15d08	; 0x15d08 <_key_scan>
   10c3c:	0e 94 e5 ad 	call	0x15bca	; 0x15bca <_key_btn>
		  if (KeyChar=='#')stTestCalc=tcInitData;
   10c40:	83 32       	cpi	r24, 0x23	; 35
   10c42:	11 f0       	breq	.+4      	; 0x10c48 <FTestCalculation+0x202>
		  else
		  if (KeyChar=='*')stTestCalc=tcInitData;
   10c44:	8a 32       	cpi	r24, 0x2A	; 42
   10c46:	11 f4       	brne	.+4      	; 0x10c4c <FTestCalculation+0x206>
   10c48:	10 92 38 02 	sts	0x0238, r1
	      break;	 
	 }
}
   10c4c:	64 96       	adiw	r28, 0x14	; 20
   10c4e:	0f b6       	in	r0, 0x3f	; 63
   10c50:	f8 94       	cli
   10c52:	de bf       	out	0x3e, r29	; 62
   10c54:	0f be       	out	0x3f, r0	; 63
   10c56:	cd bf       	out	0x3d, r28	; 61
   10c58:	cf 91       	pop	r28
   10c5a:	df 91       	pop	r29
   10c5c:	1f 91       	pop	r17
   10c5e:	0f 91       	pop	r16
   10c60:	ff 90       	pop	r15
   10c62:	ef 90       	pop	r14
   10c64:	df 90       	pop	r13
   10c66:	cf 90       	pop	r12
   10c68:	08 95       	ret

00010c6a <FMenuTicket>:
	    StrResult[2]='0'+Val;
	    StrResult[3]=0;
		}   
}

char FMenuTicket(){
   10c6a:	ef 92       	push	r14
   10c6c:	0f 93       	push	r16
   10c6e:	1f 93       	push	r17
   10c70:	df 93       	push	r29
   10c72:	cf 93       	push	r28
   10c74:	cd b7       	in	r28, 0x3d	; 61
   10c76:	de b7       	in	r29, 0x3e	; 62
   10c78:	64 97       	sbiw	r28, 0x14	; 20
   10c7a:	0f b6       	in	r0, 0x3f	; 63
   10c7c:	f8 94       	cli
   10c7e:	de bf       	out	0x3e, r29	; 62
   10c80:	0f be       	out	0x3f, r0	; 63
   10c82:	cd bf       	out	0x3d, r28	; 61
static unsigned int iLoop=0;
     char uiResult=USER_NONE,KeyPressed,KeyChar;
     char Result=MENU_NONE,lcdteks[20];

    Result=MENU_NONE;   
    switch(stMenuTicket){
   10c84:	80 91 5d 02 	lds	r24, 0x025D
   10c88:	86 30       	cpi	r24, 0x06	; 6
   10c8a:	09 f4       	brne	.+2      	; 0x10c8e <FMenuTicket+0x24>
   10c8c:	bf c0       	rjmp	.+382    	; 0x10e0c <FMenuTicket+0x1a2>
   10c8e:	87 30       	cpi	r24, 0x07	; 7
   10c90:	88 f4       	brcc	.+34     	; 0x10cb4 <FMenuTicket+0x4a>
   10c92:	82 30       	cpi	r24, 0x02	; 2
   10c94:	e9 f1       	breq	.+122    	; 0x10d10 <FMenuTicket+0xa6>
   10c96:	83 30       	cpi	r24, 0x03	; 3
   10c98:	30 f4       	brcc	.+12     	; 0x10ca6 <FMenuTicket+0x3c>
   10c9a:	88 23       	and	r24, r24
   10c9c:	09 f1       	breq	.+66     	; 0x10ce0 <FMenuTicket+0x76>
   10c9e:	81 30       	cpi	r24, 0x01	; 1
   10ca0:	09 f0       	breq	.+2      	; 0x10ca4 <FMenuTicket+0x3a>
   10ca2:	21 c1       	rjmp	.+578    	; 0x10ee6 <FMenuTicket+0x27c>
   10ca4:	1f c0       	rjmp	.+62     	; 0x10ce4 <FMenuTicket+0x7a>
   10ca6:	84 30       	cpi	r24, 0x04	; 4
   10ca8:	09 f4       	brne	.+2      	; 0x10cac <FMenuTicket+0x42>
   10caa:	87 c0       	rjmp	.+270    	; 0x10dba <FMenuTicket+0x150>
   10cac:	85 30       	cpi	r24, 0x05	; 5
   10cae:	08 f0       	brcs	.+2      	; 0x10cb2 <FMenuTicket+0x48>
   10cb0:	a7 c0       	rjmp	.+334    	; 0x10e00 <FMenuTicket+0x196>
   10cb2:	4d c0       	rjmp	.+154    	; 0x10d4e <FMenuTicket+0xe4>
   10cb4:	89 30       	cpi	r24, 0x09	; 9
   10cb6:	09 f4       	brne	.+2      	; 0x10cba <FMenuTicket+0x50>
   10cb8:	f4 c0       	rjmp	.+488    	; 0x10ea2 <FMenuTicket+0x238>
   10cba:	8a 30       	cpi	r24, 0x0A	; 10
   10cbc:	38 f4       	brcc	.+14     	; 0x10ccc <FMenuTicket+0x62>
   10cbe:	87 30       	cpi	r24, 0x07	; 7
   10cc0:	09 f4       	brne	.+2      	; 0x10cc4 <FMenuTicket+0x5a>
   10cc2:	d2 c0       	rjmp	.+420    	; 0x10e68 <FMenuTicket+0x1fe>
   10cc4:	88 30       	cpi	r24, 0x08	; 8
   10cc6:	09 f0       	breq	.+2      	; 0x10cca <FMenuTicket+0x60>
   10cc8:	0e c1       	rjmp	.+540    	; 0x10ee6 <FMenuTicket+0x27c>
   10cca:	be c0       	rjmp	.+380    	; 0x10e48 <FMenuTicket+0x1de>
   10ccc:	8b 30       	cpi	r24, 0x0B	; 11
   10cce:	09 f4       	brne	.+2      	; 0x10cd2 <FMenuTicket+0x68>
   10cd0:	ee c0       	rjmp	.+476    	; 0x10eae <FMenuTicket+0x244>
   10cd2:	8b 30       	cpi	r24, 0x0B	; 11
   10cd4:	08 f4       	brcc	.+2      	; 0x10cd8 <FMenuTicket+0x6e>
   10cd6:	01 c1       	rjmp	.+514    	; 0x10eda <FMenuTicket+0x270>
   10cd8:	8c 30       	cpi	r24, 0x0C	; 12
   10cda:	09 f0       	breq	.+2      	; 0x10cde <FMenuTicket+0x74>
   10cdc:	04 c1       	rjmp	.+520    	; 0x10ee6 <FMenuTicket+0x27c>
   10cde:	ff c0       	rjmp	.+510    	; 0x10ede <FMenuTicket+0x274>
	case mtInit:
		 stMenuTicket=mtPlatNo;
   10ce0:	81 e0       	ldi	r24, 0x01	; 1
   10ce2:	79 c0       	rjmp	.+242    	; 0x10dd6 <FMenuTicket+0x16c>
	     break;
    case mtPlatNo:
	     lcd_clear();
   10ce4:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
	     lcd_printf(1,1,PSTR("Input Plat No: "));
   10ce8:	81 e0       	ldi	r24, 0x01	; 1
   10cea:	61 e0       	ldi	r22, 0x01	; 1
   10cec:	4a ef       	ldi	r20, 0xFA	; 250
   10cee:	5a e0       	ldi	r21, 0x0A	; 10
   10cf0:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
	     lcd_printf(2,1,PSTR("_"));
   10cf4:	82 e0       	ldi	r24, 0x02	; 2
   10cf6:	61 e0       	ldi	r22, 0x01	; 1
   10cf8:	48 ef       	ldi	r20, 0xF8	; 248
   10cfa:	5a e0       	ldi	r21, 0x0A	; 10
   10cfc:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
	     lcd_printf(4,1,PSTR("[*]Cancel  [#]Enter "));
   10d00:	84 e0       	ldi	r24, 0x04	; 4
   10d02:	61 e0       	ldi	r22, 0x01	; 1
   10d04:	43 ee       	ldi	r20, 0xE3	; 227
   10d06:	5a e0       	ldi	r21, 0x0A	; 10
   10d08:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		 uiResult=USER_NONE;
		 stMenuTicket=mtInputPlatNo;
   10d0c:	82 e0       	ldi	r24, 0x02	; 2
   10d0e:	63 c0       	rjmp	.+198    	; 0x10dd6 <FMenuTicket+0x16c>
	     break;
    case mtInputPlatNo:
	     uiResult=UserInput(UI_ALPHANUM_R,2,1,strLicPlate,0,10);
   10d10:	83 e0       	ldi	r24, 0x03	; 3
   10d12:	62 e0       	ldi	r22, 0x02	; 2
   10d14:	41 e0       	ldi	r20, 0x01	; 1
   10d16:	2e e2       	ldi	r18, 0x2E	; 46
   10d18:	3a e0       	ldi	r19, 0x0A	; 10
   10d1a:	00 e0       	ldi	r16, 0x00	; 0
   10d1c:	10 e0       	ldi	r17, 0x00	; 0
   10d1e:	7a e0       	ldi	r23, 0x0A	; 10
   10d20:	e7 2e       	mov	r14, r23
   10d22:	0e 94 d8 7d 	call	0xfbb0	; 0xfbb0 <UserInput>
		 if (uiResult==USER_OK)stMenuTicket=mtOdometer;
   10d26:	83 30       	cpi	r24, 0x03	; 3
   10d28:	09 f4       	brne	.+2      	; 0x10d2c <FMenuTicket+0xc2>
   10d2a:	55 c0       	rjmp	.+170    	; 0x10dd6 <FMenuTicket+0x16c>
		 else
		 if (uiResult==USER_CANCEL)stMenuTicket=mtExitMenuTicket;
   10d2c:	81 30       	cpi	r24, 0x01	; 1
   10d2e:	09 f4       	brne	.+2      	; 0x10d32 <FMenuTicket+0xc8>
   10d30:	d4 c0       	rjmp	.+424    	; 0x10eda <FMenuTicket+0x270>
         else
		 if (uiResult==USER_ENTRY)lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   10d32:	84 30       	cpi	r24, 0x04	; 4
   10d34:	21 f4       	brne	.+8      	; 0x10d3e <FMenuTicket+0xd4>
   10d36:	61 e0       	ldi	r22, 0x01	; 1
   10d38:	4e ec       	ldi	r20, 0xCE	; 206
   10d3a:	5a e0       	ldi	r21, 0x0A	; 10
   10d3c:	5e c0       	rjmp	.+188    	; 0x10dfa <FMenuTicket+0x190>
		 else
		 if (uiResult==USER_NO_DATA)lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   10d3e:	85 30       	cpi	r24, 0x05	; 5
   10d40:	09 f0       	breq	.+2      	; 0x10d44 <FMenuTicket+0xda>
   10d42:	d1 c0       	rjmp	.+418    	; 0x10ee6 <FMenuTicket+0x27c>
   10d44:	84 e0       	ldi	r24, 0x04	; 4
   10d46:	61 e0       	ldi	r22, 0x01	; 1
   10d48:	49 eb       	ldi	r20, 0xB9	; 185
   10d4a:	5a e0       	ldi	r21, 0x0A	; 10
   10d4c:	56 c0       	rjmp	.+172    	; 0x10dfa <FMenuTicket+0x190>
	     break;
    case mtOdometer:
	     lcd_clear();
   10d4e:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
		 sprintf_P(lcdteks,PSTR("Plat No: %s "),strLicPlate);
   10d52:	00 d0       	rcall	.+0      	; 0x10d54 <FMenuTicket+0xea>
   10d54:	00 d0       	rcall	.+0      	; 0x10d56 <FMenuTicket+0xec>
   10d56:	00 d0       	rcall	.+0      	; 0x10d58 <FMenuTicket+0xee>
   10d58:	ed b7       	in	r30, 0x3d	; 61
   10d5a:	fe b7       	in	r31, 0x3e	; 62
   10d5c:	31 96       	adiw	r30, 0x01	; 1
   10d5e:	8e 01       	movw	r16, r28
   10d60:	0f 5f       	subi	r16, 0xFF	; 255
   10d62:	1f 4f       	sbci	r17, 0xFF	; 255
   10d64:	ad b7       	in	r26, 0x3d	; 61
   10d66:	be b7       	in	r27, 0x3e	; 62
   10d68:	12 96       	adiw	r26, 0x02	; 2
   10d6a:	1c 93       	st	X, r17
   10d6c:	0e 93       	st	-X, r16
   10d6e:	11 97       	sbiw	r26, 0x01	; 1
   10d70:	8c ea       	ldi	r24, 0xAC	; 172
   10d72:	9a e0       	ldi	r25, 0x0A	; 10
   10d74:	93 83       	std	Z+3, r25	; 0x03
   10d76:	82 83       	std	Z+2, r24	; 0x02
   10d78:	8e e2       	ldi	r24, 0x2E	; 46
   10d7a:	9a e0       	ldi	r25, 0x0A	; 10
   10d7c:	95 83       	std	Z+5, r25	; 0x05
   10d7e:	84 83       	std	Z+4, r24	; 0x04
   10d80:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
	     lcd_print(1,1,lcdteks);
   10d84:	8d b7       	in	r24, 0x3d	; 61
   10d86:	9e b7       	in	r25, 0x3e	; 62
   10d88:	06 96       	adiw	r24, 0x06	; 6
   10d8a:	0f b6       	in	r0, 0x3f	; 63
   10d8c:	f8 94       	cli
   10d8e:	9e bf       	out	0x3e, r25	; 62
   10d90:	0f be       	out	0x3f, r0	; 63
   10d92:	8d bf       	out	0x3d, r24	; 61
   10d94:	81 e0       	ldi	r24, 0x01	; 1
   10d96:	61 e0       	ldi	r22, 0x01	; 1
   10d98:	a8 01       	movw	r20, r16
   10d9a:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
	     lcd_printf(2,1,PSTR("Odometer:_ "));
   10d9e:	82 e0       	ldi	r24, 0x02	; 2
   10da0:	61 e0       	ldi	r22, 0x01	; 1
   10da2:	40 ea       	ldi	r20, 0xA0	; 160
   10da4:	5a e0       	ldi	r21, 0x0A	; 10
   10da6:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
	     lcd_printf(4,1,PSTR("[*]Cancel  [#]Enter "));
   10daa:	84 e0       	ldi	r24, 0x04	; 4
   10dac:	61 e0       	ldi	r22, 0x01	; 1
   10dae:	4b e8       	ldi	r20, 0x8B	; 139
   10db0:	5a e0       	ldi	r21, 0x0A	; 10
   10db2:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		 uiResult=USER_NONE;
		 stMenuTicket=mtInputOdometer;
   10db6:	84 e0       	ldi	r24, 0x04	; 4
   10db8:	0e c0       	rjmp	.+28     	; 0x10dd6 <FMenuTicket+0x16c>
	     break;
    case mtInputOdometer:
	     uiResult=UserInput(UI_NUMBER_R,2,10,strOdometer,0,10);
   10dba:	81 e0       	ldi	r24, 0x01	; 1
   10dbc:	62 e0       	ldi	r22, 0x02	; 2
   10dbe:	4a e0       	ldi	r20, 0x0A	; 10
   10dc0:	22 ed       	ldi	r18, 0xD2	; 210
   10dc2:	34 e0       	ldi	r19, 0x04	; 4
   10dc4:	00 e0       	ldi	r16, 0x00	; 0
   10dc6:	10 e0       	ldi	r17, 0x00	; 0
   10dc8:	5a e0       	ldi	r21, 0x0A	; 10
   10dca:	e5 2e       	mov	r14, r21
   10dcc:	0e 94 d8 7d 	call	0xfbb0	; 0xfbb0 <UserInput>
		 if (uiResult==USER_OK)stMenuTicket=mtFIP;
   10dd0:	83 30       	cpi	r24, 0x03	; 3
   10dd2:	21 f4       	brne	.+8      	; 0x10ddc <FMenuTicket+0x172>
   10dd4:	85 e0       	ldi	r24, 0x05	; 5
   10dd6:	80 93 5d 02 	sts	0x025D, r24
   10dda:	85 c0       	rjmp	.+266    	; 0x10ee6 <FMenuTicket+0x27c>
		 else
		 if (uiResult==USER_CANCEL)stMenuTicket=mtPlatNo;
   10ddc:	81 30       	cpi	r24, 0x01	; 1
   10dde:	d9 f3       	breq	.-10     	; 0x10dd6 <FMenuTicket+0x16c>
		 else
		 if (uiResult==USER_ENTRY)lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   10de0:	84 30       	cpi	r24, 0x04	; 4
   10de2:	21 f4       	brne	.+8      	; 0x10dec <FMenuTicket+0x182>
   10de4:	61 e0       	ldi	r22, 0x01	; 1
   10de6:	46 e7       	ldi	r20, 0x76	; 118
   10de8:	5a e0       	ldi	r21, 0x0A	; 10
   10dea:	07 c0       	rjmp	.+14     	; 0x10dfa <FMenuTicket+0x190>
		 else
		 if (uiResult==USER_NO_DATA)lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   10dec:	85 30       	cpi	r24, 0x05	; 5
   10dee:	09 f0       	breq	.+2      	; 0x10df2 <FMenuTicket+0x188>
   10df0:	7a c0       	rjmp	.+244    	; 0x10ee6 <FMenuTicket+0x27c>
   10df2:	84 e0       	ldi	r24, 0x04	; 4
   10df4:	61 e0       	ldi	r22, 0x01	; 1
   10df6:	41 e6       	ldi	r20, 0x61	; 97
   10df8:	5a e0       	ldi	r21, 0x0A	; 10
   10dfa:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
   10dfe:	73 c0       	rjmp	.+230    	; 0x10ee6 <FMenuTicket+0x27c>
	     break;
    case mtFIP:
	     lcd_clear();
   10e00:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
		 _scr_pump();
   10e04:	0e 94 a0 45 	call	0x8b40	; 0x8b40 <_scr_pump>
		 stMenuTicket=mtInputFIP;
   10e08:	86 e0       	ldi	r24, 0x06	; 6
   10e0a:	e5 cf       	rjmp	.-54     	; 0x10dd6 <FMenuTicket+0x16c>
	     break;
    case mtInputFIP:
	     KeyPressed=_key_scan(1);
   10e0c:	81 e0       	ldi	r24, 0x01	; 1
   10e0e:	0e 94 84 ae 	call	0x15d08	; 0x15d08 <_key_scan>
   10e12:	18 2f       	mov	r17, r24
		 KeyChar=_key_btn(KeyPressed);
   10e14:	0e 94 e5 ad 	call	0x15bca	; 0x15bca <_key_btn>
		 if ((KeyChar>='1')&&(KeyChar<='8')){
   10e18:	81 53       	subi	r24, 0x31	; 49
   10e1a:	88 30       	cpi	r24, 0x08	; 8
   10e1c:	40 f4       	brcc	.+16     	; 0x10e2e <FMenuTicket+0x1c4>
		     FIP_Used=KeyChar-'0';
   10e1e:	8f 5f       	subi	r24, 0xFF	; 255
   10e20:	80 93 5a 02 	sts	0x025A, r24
			 zFIP_Used=FIP_Used;
   10e24:	80 93 59 02 	sts	0x0259, r24
		     stMenuTicket=mtSendMsg98;
   10e28:	87 e0       	ldi	r24, 0x07	; 7
   10e2a:	80 93 5d 02 	sts	0x025D, r24
		 }
		 if (KeyPressed==_KEY_CANCEL){
   10e2e:	17 3e       	cpi	r17, 0xE7	; 231
   10e30:	11 f4       	brne	.+4      	; 0x10e36 <FMenuTicket+0x1cc>
             stMenuTicket=mtOdometer;
   10e32:	83 e0       	ldi	r24, 0x03	; 3
   10e34:	d0 cf       	rjmp	.-96     	; 0x10dd6 <FMenuTicket+0x16c>
		 }else
		 if (KeyPressed==_KEY_ENTER){
   10e36:	17 3b       	cpi	r17, 0xB7	; 183
   10e38:	09 f0       	breq	.+2      	; 0x10e3c <FMenuTicket+0x1d2>
   10e3a:	55 c0       	rjmp	.+170    	; 0x10ee6 <FMenuTicket+0x27c>
		     FIP_Used=zFIP_Used;
   10e3c:	80 91 59 02 	lds	r24, 0x0259
   10e40:	80 93 5a 02 	sts	0x025A, r24
             stMenuTicket=mtInitWaitMessage99;
   10e44:	88 e0       	ldi	r24, 0x08	; 8
   10e46:	c7 cf       	rjmp	.-114    	; 0x10dd6 <FMenuTicket+0x16c>
		 }
	     break;	
    case mtInitWaitMessage99:
	     lcd_clear();
   10e48:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
		 lcd_printf(2,1,PSTR("Send Request"));
   10e4c:	82 e0       	ldi	r24, 0x02	; 2
   10e4e:	61 e0       	ldi	r22, 0x01	; 1
   10e50:	44 e5       	ldi	r20, 0x54	; 84
   10e52:	5a e0       	ldi	r21, 0x0A	; 10
   10e54:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		 lcd_printf(3,1,PSTR("Proses"));
   10e58:	83 e0       	ldi	r24, 0x03	; 3
   10e5a:	61 e0       	ldi	r22, 0x01	; 1
   10e5c:	4d e4       	ldi	r20, 0x4D	; 77
   10e5e:	5a e0       	ldi	r21, 0x0A	; 10
   10e60:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
         stMenuTicket=mtSendMsg98;
   10e64:	87 e0       	ldi	r24, 0x07	; 7
   10e66:	b7 cf       	rjmp	.-146    	; 0x10dd6 <FMenuTicket+0x16c>
	     break;
    case mtSendMsg98:
	     iPos=0;
   10e68:	10 92 5c 02 	sts	0x025C, r1
		 iSend=0;
   10e6c:	10 92 5b 02 	sts	0x025B, r1
		 IsMessage99=False;
   10e70:	10 92 a2 01 	sts	0x01A2, r1
		 TimSend=0;
   10e74:	10 92 af 0d 	sts	0x0DAF, r1
		 iLoop=0;
   10e78:	10 92 58 02 	sts	0x0258, r1
   10e7c:	10 92 57 02 	sts	0x0257, r1
		 if (IFType==IT_SLAVE)sendMessage98(FIP_Used);
   10e80:	80 91 00 01 	lds	r24, 0x0100
   10e84:	81 30       	cpi	r24, 0x01	; 1
   10e86:	29 f4       	brne	.+10     	; 0x10e92 <FMenuTicket+0x228>
   10e88:	80 91 5a 02 	lds	r24, 0x025A
   10e8c:	0e 94 01 4d 	call	0x9a02	; 0x9a02 <sendMessage98>
   10e90:	24 c0       	rjmp	.+72     	; 0x10eda <FMenuTicket+0x270>
		 else 
		 if (IFType==IT_STANDALONE)PrintStandalone(FIP_Used,False);
   10e92:	82 30       	cpi	r24, 0x02	; 2
   10e94:	11 f5       	brne	.+68     	; 0x10eda <FMenuTicket+0x270>
   10e96:	80 91 5a 02 	lds	r24, 0x025A
   10e9a:	60 e0       	ldi	r22, 0x00	; 0
   10e9c:	0e 94 f7 20 	call	0x41ee	; 0x41ee <PrintStandalone>
   10ea0:	1c c0       	rjmp	.+56     	; 0x10eda <FMenuTicket+0x270>
	                     stMenuTicket=mtSendMsg98;
				  }
			 }
		 }
		 */
		 if (IsMessage99==True){ 
   10ea2:	80 91 a2 01 	lds	r24, 0x01A2
   10ea6:	81 30       	cpi	r24, 0x01	; 1
   10ea8:	f1 f4       	brne	.+60     	; 0x10ee6 <FMenuTicket+0x27c>
		    stMenuTicket=mtMessage99Received;
   10eaa:	8a e0       	ldi	r24, 0x0A	; 10
   10eac:	94 cf       	rjmp	.-216    	; 0x10dd6 <FMenuTicket+0x16c>
	     break;
    case mtMessage99Received:
	     stMenuTicket=mtExitMenuTicket;
		 break;
    case mtNoConnection:
	     lcd_clear();
   10eae:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
		 lcd_printf(2,1,PSTR("Error No Connection"));
   10eb2:	82 e0       	ldi	r24, 0x02	; 2
   10eb4:	61 e0       	ldi	r22, 0x01	; 1
   10eb6:	49 e3       	ldi	r20, 0x39	; 57
   10eb8:	5a e0       	ldi	r21, 0x0A	; 10
   10eba:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   10ebe:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   10ec0:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   10ec2:	82 e0       	ldi	r24, 0x02	; 2
   10ec4:	80 93 bf 01 	sts	0x01BF, r24
   10ec8:	80 e2       	ldi	r24, 0x20	; 32
   10eca:	9e e4       	ldi	r25, 0x4E	; 78
   10ecc:	29 e1       	ldi	r18, 0x19	; 25
   10ece:	30 e0       	ldi	r19, 0x00	; 0
   10ed0:	f9 01       	movw	r30, r18
   10ed2:	31 97       	sbiw	r30, 0x01	; 1
   10ed4:	f1 f7       	brne	.-4      	; 0x10ed2 <FMenuTicket+0x268>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
   10ed6:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
   10ed8:	d9 f7       	brne	.-10     	; 0x10ed0 <FMenuTicket+0x266>
    case mtNoConnection:
	     lcd_clear();
		 lcd_printf(2,1,PSTR("Error No Connection"));
		 system_beep(2);
		 _delay_ms(2000);
         stMenuTicket=mtExitMenuTicket;
   10eda:	8c e0       	ldi	r24, 0x0C	; 12
   10edc:	7c cf       	rjmp	.-264    	; 0x10dd6 <FMenuTicket+0x16c>
	     break;
    case mtExitMenuTicket:
	     Result=MENU_DONE;
	     stMenuTicket=mtInit;
   10ede:	10 92 5d 02 	sts	0x025D, r1
   10ee2:	81 e0       	ldi	r24, 0x01	; 1
   10ee4:	01 c0       	rjmp	.+2      	; 0x10ee8 <FMenuTicket+0x27e>
   10ee6:	80 e0       	ldi	r24, 0x00	; 0
	     break;
	}
  return Result;
}
   10ee8:	64 96       	adiw	r28, 0x14	; 20
   10eea:	0f b6       	in	r0, 0x3f	; 63
   10eec:	f8 94       	cli
   10eee:	de bf       	out	0x3e, r29	; 62
   10ef0:	0f be       	out	0x3f, r0	; 63
   10ef2:	cd bf       	out	0x3d, r28	; 61
   10ef4:	cf 91       	pop	r28
   10ef6:	df 91       	pop	r29
   10ef8:	1f 91       	pop	r17
   10efa:	0f 91       	pop	r16
   10efc:	ef 90       	pop	r14
   10efe:	08 95       	ret

00010f00 <FSettingOperator>:
char FSettingHost(){
     _menu_host();
	 return MENU_DONE;
}

char FSettingOperator(){//Change Active Operator, Change Password
   10f00:	ef 92       	push	r14
   10f02:	0f 93       	push	r16
   10f04:	1f 93       	push	r17
   10f06:	df 93       	push	r29
   10f08:	cf 93       	push	r28
   10f0a:	cd b7       	in	r28, 0x3d	; 61
   10f0c:	de b7       	in	r29, 0x3e	; 62
   10f0e:	e5 97       	sbiw	r28, 0x35	; 53
   10f10:	0f b6       	in	r0, 0x3f	; 63
   10f12:	f8 94       	cli
   10f14:	de bf       	out	0x3e, r29	; 62
   10f16:	0f be       	out	0x3f, r0	; 63
   10f18:	cd bf       	out	0x3d, r28	; 61
	        char KeyPressed,KeyChar,lcdteks[20],strPassword[15];
			char strOperatorName[18];
			char uiResult=USER_NONE,Result=MENU_NONE;

	 Result=MENU_NONE;
	 switch(stSettingOperator){
   10f1a:	80 91 6f 02 	lds	r24, 0x026F
   10f1e:	87 30       	cpi	r24, 0x07	; 7
   10f20:	09 f4       	brne	.+2      	; 0x10f24 <FSettingOperator+0x24>
   10f22:	78 c1       	rjmp	.+752    	; 0x11214 <FSettingOperator+0x314>
   10f24:	88 30       	cpi	r24, 0x08	; 8
   10f26:	90 f4       	brcc	.+36     	; 0x10f4c <FSettingOperator+0x4c>
   10f28:	83 30       	cpi	r24, 0x03	; 3
   10f2a:	09 f4       	brne	.+2      	; 0x10f2e <FSettingOperator+0x2e>
   10f2c:	a0 c0       	rjmp	.+320    	; 0x1106e <FSettingOperator+0x16e>
   10f2e:	84 30       	cpi	r24, 0x04	; 4
   10f30:	30 f4       	brcc	.+12     	; 0x10f3e <FSettingOperator+0x3e>
   10f32:	81 30       	cpi	r24, 0x01	; 1
   10f34:	d1 f1       	breq	.+116    	; 0x10faa <FSettingOperator+0xaa>
   10f36:	82 30       	cpi	r24, 0x02	; 2
   10f38:	08 f0       	brcs	.+2      	; 0x10f3c <FSettingOperator+0x3c>
   10f3a:	4a c0       	rjmp	.+148    	; 0x10fd0 <FSettingOperator+0xd0>
   10f3c:	20 c0       	rjmp	.+64     	; 0x10f7e <FSettingOperator+0x7e>
   10f3e:	85 30       	cpi	r24, 0x05	; 5
   10f40:	09 f4       	brne	.+2      	; 0x10f44 <FSettingOperator+0x44>
   10f42:	39 c1       	rjmp	.+626    	; 0x111b6 <FSettingOperator+0x2b6>
   10f44:	86 30       	cpi	r24, 0x06	; 6
   10f46:	08 f0       	brcs	.+2      	; 0x10f4a <FSettingOperator+0x4a>
   10f48:	52 c1       	rjmp	.+676    	; 0x111ee <FSettingOperator+0x2ee>
   10f4a:	ff c0       	rjmp	.+510    	; 0x1114a <FSettingOperator+0x24a>
   10f4c:	8b 30       	cpi	r24, 0x0B	; 11
   10f4e:	09 f4       	brne	.+2      	; 0x10f52 <FSettingOperator+0x52>
   10f50:	23 c2       	rjmp	.+1094   	; 0x11398 <FSettingOperator+0x498>
   10f52:	8c 30       	cpi	r24, 0x0C	; 12
   10f54:	38 f4       	brcc	.+14     	; 0x10f64 <FSettingOperator+0x64>
   10f56:	89 30       	cpi	r24, 0x09	; 9
   10f58:	09 f4       	brne	.+2      	; 0x10f5c <FSettingOperator+0x5c>
   10f5a:	aa c1       	rjmp	.+852    	; 0x112b0 <FSettingOperator+0x3b0>
   10f5c:	8a 30       	cpi	r24, 0x0A	; 10
   10f5e:	08 f0       	brcs	.+2      	; 0x10f62 <FSettingOperator+0x62>
   10f60:	da c1       	rjmp	.+948    	; 0x11316 <FSettingOperator+0x416>
   10f62:	78 c1       	rjmp	.+752    	; 0x11254 <FSettingOperator+0x354>
   10f64:	8d 30       	cpi	r24, 0x0D	; 13
   10f66:	09 f4       	brne	.+2      	; 0x10f6a <FSettingOperator+0x6a>
   10f68:	9b c2       	rjmp	.+1334   	; 0x114a0 <FSettingOperator+0x5a0>
   10f6a:	8d 30       	cpi	r24, 0x0D	; 13
   10f6c:	08 f4       	brcc	.+2      	; 0x10f70 <FSettingOperator+0x70>
   10f6e:	1b c2       	rjmp	.+1078   	; 0x113a6 <FSettingOperator+0x4a6>
   10f70:	8e 30       	cpi	r24, 0x0E	; 14
   10f72:	09 f4       	brne	.+2      	; 0x10f76 <FSettingOperator+0x76>
   10f74:	9a c2       	rjmp	.+1332   	; 0x114aa <FSettingOperator+0x5aa>
   10f76:	8f 30       	cpi	r24, 0x0F	; 15
   10f78:	09 f0       	breq	.+2      	; 0x10f7c <FSettingOperator+0x7c>
   10f7a:	a2 c2       	rjmp	.+1348   	; 0x114c0 <FSettingOperator+0x5c0>
   10f7c:	9d c2       	rjmp	.+1338   	; 0x114b8 <FSettingOperator+0x5b8>
	 case soMenuOption:
	      lcd_clear();
   10f7e:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
		  lcd_printf(1,1,PSTR("1.Change Operator"));
   10f82:	81 e0       	ldi	r24, 0x01	; 1
   10f84:	61 e0       	ldi	r22, 0x01	; 1
   10f86:	41 e1       	ldi	r20, 0x11	; 17
   10f88:	51 e1       	ldi	r21, 0x11	; 17
   10f8a:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		  lcd_printf(2,1,PSTR("2.Change Password"));
   10f8e:	82 e0       	ldi	r24, 0x02	; 2
   10f90:	61 e0       	ldi	r22, 0x01	; 1
   10f92:	4f ef       	ldi	r20, 0xFF	; 255
   10f94:	50 e1       	ldi	r21, 0x10	; 16
   10f96:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		  lcd_printf(4,1,PSTR("[*]Back          "));
   10f9a:	84 e0       	ldi	r24, 0x04	; 4
   10f9c:	61 e0       	ldi	r22, 0x01	; 1
   10f9e:	4d ee       	ldi	r20, 0xED	; 237
   10fa0:	50 e1       	ldi	r21, 0x10	; 16
   10fa2:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
          stSettingOperator=soMenuOptionInput;
   10fa6:	81 e0       	ldi	r24, 0x01	; 1
   10fa8:	64 c2       	rjmp	.+1224   	; 0x11472 <FSettingOperator+0x572>
	      break;
     case soMenuOptionInput:
	      KeyPressed=_key_scan(1);
   10faa:	81 e0       	ldi	r24, 0x01	; 1
   10fac:	0e 94 84 ae 	call	0x15d08	; 0x15d08 <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
   10fb0:	0e 94 e5 ad 	call	0x15bca	; 0x15bca <_key_btn>
		  switch(KeyChar){
   10fb4:	81 33       	cpi	r24, 0x31	; 49
   10fb6:	31 f0       	breq	.+12     	; 0x10fc4 <FSettingOperator+0xc4>
   10fb8:	82 33       	cpi	r24, 0x32	; 50
   10fba:	31 f0       	breq	.+12     	; 0x10fc8 <FSettingOperator+0xc8>
   10fbc:	8a 32       	cpi	r24, 0x2A	; 42
   10fbe:	09 f0       	breq	.+2      	; 0x10fc2 <FSettingOperator+0xc2>
   10fc0:	7f c2       	rjmp	.+1278   	; 0x114c0 <FSettingOperator+0x5c0>
   10fc2:	04 c0       	rjmp	.+8      	; 0x10fcc <FSettingOperator+0xcc>
		  case '1':
		       stSettingOperator=soChangeOperatorInit;
   10fc4:	82 e0       	ldi	r24, 0x02	; 2
   10fc6:	55 c2       	rjmp	.+1194   	; 0x11472 <FSettingOperator+0x572>
		       break;
          case '2':
		       stSettingOperator=soChangePasswordInit;
   10fc8:	85 e0       	ldi	r24, 0x05	; 5
   10fca:	53 c2       	rjmp	.+1190   	; 0x11472 <FSettingOperator+0x572>
		       break;
          case '*':
		       stSettingOperator=soExitSettingOperator;
   10fcc:	8f e0       	ldi	r24, 0x0F	; 15
   10fce:	51 c2       	rjmp	.+1186   	; 0x11472 <FSettingOperator+0x572>
		       break;
		  }
	      break;
     case soChangeOperatorInit:
	      lcd_clear();		  
   10fd0:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
   10fd4:	8e 01       	movw	r16, r28
   10fd6:	00 5f       	subi	r16, 0xF0	; 240
   10fd8:	1f 4f       	sbci	r17, 0xFF	; 255
   10fda:	c8 01       	movw	r24, r16
   10fdc:	65 e1       	ldi	r22, 0x15	; 21
   10fde:	70 e0       	ldi	r23, 0x00	; 0
   10fe0:	42 e1       	ldi	r20, 0x12	; 18
   10fe2:	50 e0       	ldi	r21, 0x00	; 0
   10fe4:	2d ef       	ldi	r18, 0xFD	; 253
   10fe6:	32 e1       	ldi	r19, 0x12	; 18
   10fe8:	0e 94 f1 b3 	call	0x167e2	; 0x167e2 <__eerd_block>
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   10fec:	98 01       	movw	r18, r16
   10fee:	ce 01       	movw	r24, r28
   10ff0:	4f 96       	adiw	r24, 0x1f	; 31
	    Dest[i]=Source[IdxSource+i];
   10ff2:	0f 5f       	subi	r16, 0xFF	; 255
   10ff4:	1f 4f       	sbci	r17, 0xFF	; 255
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   10ff6:	08 17       	cp	r16, r24
   10ff8:	19 07       	cpc	r17, r25
   10ffa:	d9 f7       	brne	.-10     	; 0x10ff2 <FSettingOperator+0xf2>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   10ffc:	1f 8e       	std	Y+31, r1	; 0x1f
     case soChangeOperatorInit:
	      lcd_clear();		  
		  eeprom_read_block((void*) &strOperatorName, (const void*) &DefOperatorName,18);
		  StrPosCopy(strOperatorName,strOperatorName,0,15);

		  sprintf_P(lcdteks,PSTR("%s"),strOperatorName);
   10ffe:	00 d0       	rcall	.+0      	; 0x11000 <FSettingOperator+0x100>
   11000:	00 d0       	rcall	.+0      	; 0x11002 <FSettingOperator+0x102>
   11002:	00 d0       	rcall	.+0      	; 0x11004 <FSettingOperator+0x104>
   11004:	ed b7       	in	r30, 0x3d	; 61
   11006:	fe b7       	in	r31, 0x3e	; 62
   11008:	31 96       	adiw	r30, 0x01	; 1
   1100a:	8e 01       	movw	r16, r28
   1100c:	0e 5d       	subi	r16, 0xDE	; 222
   1100e:	1f 4f       	sbci	r17, 0xFF	; 255
   11010:	ad b7       	in	r26, 0x3d	; 61
   11012:	be b7       	in	r27, 0x3e	; 62
   11014:	12 96       	adiw	r26, 0x02	; 2
   11016:	1c 93       	st	X, r17
   11018:	0e 93       	st	-X, r16
   1101a:	11 97       	sbiw	r26, 0x01	; 1
   1101c:	8a ee       	ldi	r24, 0xEA	; 234
   1101e:	90 e1       	ldi	r25, 0x10	; 16
   11020:	93 83       	std	Z+3, r25	; 0x03
   11022:	82 83       	std	Z+2, r24	; 0x02
   11024:	24 83       	std	Z+4, r18	; 0x04
   11026:	35 83       	std	Z+5, r19	; 0x05
   11028:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
		  lcd_printf(1,1,PSTR("Name:"));
   1102c:	8d b7       	in	r24, 0x3d	; 61
   1102e:	9e b7       	in	r25, 0x3e	; 62
   11030:	06 96       	adiw	r24, 0x06	; 6
   11032:	0f b6       	in	r0, 0x3f	; 63
   11034:	f8 94       	cli
   11036:	9e bf       	out	0x3e, r25	; 62
   11038:	0f be       	out	0x3f, r0	; 63
   1103a:	8d bf       	out	0x3d, r24	; 61
   1103c:	81 e0       	ldi	r24, 0x01	; 1
   1103e:	61 e0       	ldi	r22, 0x01	; 1
   11040:	44 ee       	ldi	r20, 0xE4	; 228
   11042:	50 e1       	ldi	r21, 0x10	; 16
   11044:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		  lcd_print (1,6,lcdteks);
   11048:	81 e0       	ldi	r24, 0x01	; 1
   1104a:	66 e0       	ldi	r22, 0x06	; 6
   1104c:	a8 01       	movw	r20, r16
   1104e:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
		  lcd_printf(2,1,PSTR("New :_              "));
   11052:	82 e0       	ldi	r24, 0x02	; 2
   11054:	61 e0       	ldi	r22, 0x01	; 1
   11056:	4f ec       	ldi	r20, 0xCF	; 207
   11058:	50 e1       	ldi	r21, 0x10	; 16
   1105a:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		  lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   1105e:	84 e0       	ldi	r24, 0x04	; 4
   11060:	61 e0       	ldi	r22, 0x01	; 1
   11062:	4a eb       	ldi	r20, 0xBA	; 186
   11064:	50 e1       	ldi	r21, 0x10	; 16
   11066:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
          stSettingOperator=soOperatorNameInput;
   1106a:	83 e0       	ldi	r24, 0x03	; 3
   1106c:	02 c2       	rjmp	.+1028   	; 0x11472 <FSettingOperator+0x572>
	      break;
     case soOperatorNameInput:
          uiResult=USER_NONE;
	      uiResult=UserInput(UI_ALPHANUM_R,2,6,strFreeMessageLine1,0,16);
   1106e:	83 e0       	ldi	r24, 0x03	; 3
   11070:	62 e0       	ldi	r22, 0x02	; 2
   11072:	46 e0       	ldi	r20, 0x06	; 6
   11074:	26 ec       	ldi	r18, 0xC6	; 198
   11076:	39 e0       	ldi	r19, 0x09	; 9
   11078:	00 e0       	ldi	r16, 0x00	; 0
   1107a:	10 e0       	ldi	r17, 0x00	; 0
   1107c:	b0 e1       	ldi	r27, 0x10	; 16
   1107e:	eb 2e       	mov	r14, r27
   11080:	0e 94 d8 7d 	call	0xfbb0	; 0xfbb0 <UserInput>
		  switch(uiResult){
   11084:	83 30       	cpi	r24, 0x03	; 3
   11086:	51 f0       	breq	.+20     	; 0x1109c <FSettingOperator+0x19c>
   11088:	84 30       	cpi	r24, 0x04	; 4
   1108a:	08 f4       	brcc	.+2      	; 0x1108e <FSettingOperator+0x18e>
   1108c:	f2 c0       	rjmp	.+484    	; 0x11272 <FSettingOperator+0x372>
   1108e:	84 30       	cpi	r24, 0x04	; 4
   11090:	09 f4       	brne	.+2      	; 0x11094 <FSettingOperator+0x194>
   11092:	51 c0       	rjmp	.+162    	; 0x11136 <FSettingOperator+0x236>
   11094:	85 30       	cpi	r24, 0x05	; 5
   11096:	09 f0       	breq	.+2      	; 0x1109a <FSettingOperator+0x19a>
   11098:	13 c2       	rjmp	.+1062   	; 0x114c0 <FSettingOperator+0x5c0>
   1109a:	52 c0       	rjmp	.+164    	; 0x11140 <FSettingOperator+0x240>
		  case USER_OK:
		       lcd_clear();
   1109c:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
   110a0:	20 e0       	ldi	r18, 0x00	; 0
   110a2:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   110a4:	ae 01       	movw	r20, r28
   110a6:	40 5f       	subi	r20, 0xF0	; 240
   110a8:	5f 4f       	sbci	r21, 0xFF	; 255
   110aa:	fa 01       	movw	r30, r20
   110ac:	e2 0f       	add	r30, r18
   110ae:	f3 1f       	adc	r31, r19
   110b0:	d9 01       	movw	r26, r18
   110b2:	aa 53       	subi	r26, 0x3A	; 58
   110b4:	b6 4f       	sbci	r27, 0xF6	; 246
   110b6:	8c 91       	ld	r24, X
   110b8:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   110ba:	2f 5f       	subi	r18, 0xFF	; 255
   110bc:	3f 4f       	sbci	r19, 0xFF	; 255
   110be:	2f 30       	cpi	r18, 0x0F	; 15
   110c0:	31 05       	cpc	r19, r1
   110c2:	99 f7       	brne	.-26     	; 0x110aa <FSettingOperator+0x1aa>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   110c4:	1f 8e       	std	Y+31, r1	; 0x1f
	      uiResult=UserInput(UI_ALPHANUM_R,2,6,strFreeMessageLine1,0,16);
		  switch(uiResult){
		  case USER_OK:
		       lcd_clear();
			   StrPosCopy(strFreeMessageLine1,strOperatorName,0,15);
		       sprintf_P(lcdteks,PSTR("%s"),strOperatorName);
   110c6:	00 d0       	rcall	.+0      	; 0x110c8 <FSettingOperator+0x1c8>
   110c8:	00 d0       	rcall	.+0      	; 0x110ca <FSettingOperator+0x1ca>
   110ca:	00 d0       	rcall	.+0      	; 0x110cc <FSettingOperator+0x1cc>
   110cc:	ed b7       	in	r30, 0x3d	; 61
   110ce:	fe b7       	in	r31, 0x3e	; 62
   110d0:	31 96       	adiw	r30, 0x01	; 1
   110d2:	8e 01       	movw	r16, r28
   110d4:	0e 5d       	subi	r16, 0xDE	; 222
   110d6:	1f 4f       	sbci	r17, 0xFF	; 255
   110d8:	ad b7       	in	r26, 0x3d	; 61
   110da:	be b7       	in	r27, 0x3e	; 62
   110dc:	12 96       	adiw	r26, 0x02	; 2
   110de:	1c 93       	st	X, r17
   110e0:	0e 93       	st	-X, r16
   110e2:	11 97       	sbiw	r26, 0x01	; 1
   110e4:	87 eb       	ldi	r24, 0xB7	; 183
   110e6:	90 e1       	ldi	r25, 0x10	; 16
   110e8:	93 83       	std	Z+3, r25	; 0x03
   110ea:	82 83       	std	Z+2, r24	; 0x02
   110ec:	55 83       	std	Z+5, r21	; 0x05
   110ee:	44 83       	std	Z+4, r20	; 0x04
   110f0:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
			   lcd_printf(1,1,PSTR("New Operator:"));
   110f4:	8d b7       	in	r24, 0x3d	; 61
   110f6:	9e b7       	in	r25, 0x3e	; 62
   110f8:	06 96       	adiw	r24, 0x06	; 6
   110fa:	0f b6       	in	r0, 0x3f	; 63
   110fc:	f8 94       	cli
   110fe:	9e bf       	out	0x3e, r25	; 62
   11100:	0f be       	out	0x3f, r0	; 63
   11102:	8d bf       	out	0x3d, r24	; 61
   11104:	81 e0       	ldi	r24, 0x01	; 1
   11106:	61 e0       	ldi	r22, 0x01	; 1
   11108:	49 ea       	ldi	r20, 0xA9	; 169
   1110a:	50 e1       	ldi	r21, 0x10	; 16
   1110c:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
			   lcd_print (2,1,lcdteks);
   11110:	82 e0       	ldi	r24, 0x02	; 2
   11112:	61 e0       	ldi	r22, 0x01	; 1
   11114:	a8 01       	movw	r20, r16
   11116:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
			   lcd_printf(3,1,PSTR("Save?"));
   1111a:	83 e0       	ldi	r24, 0x03	; 3
   1111c:	61 e0       	ldi	r22, 0x01	; 1
   1111e:	43 ea       	ldi	r20, 0xA3	; 163
   11120:	50 e1       	ldi	r21, 0x10	; 16
   11122:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
			   lcd_printf(4,1,PSTR("[*]No    [#]Yes"));
   11126:	84 e0       	ldi	r24, 0x04	; 4
   11128:	61 e0       	ldi	r22, 0x01	; 1
   1112a:	43 e9       	ldi	r20, 0x93	; 147
   1112c:	50 e1       	ldi	r21, 0x10	; 16
   1112e:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
               stSettingOperator=soIsSaveOperatorName;
   11132:	84 e0       	ldi	r24, 0x04	; 4
   11134:	9e c1       	rjmp	.+828    	; 0x11472 <FSettingOperator+0x572>
		       break;
		  case USER_CANCEL:
               stSettingOperator=soMenuOption; 
		       break;
          case USER_ENTRY:
		       lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   11136:	84 e0       	ldi	r24, 0x04	; 4
   11138:	61 e0       	ldi	r22, 0x01	; 1
   1113a:	4e e7       	ldi	r20, 0x7E	; 126
   1113c:	50 e1       	ldi	r21, 0x10	; 16
   1113e:	29 c1       	rjmp	.+594    	; 0x11392 <FSettingOperator+0x492>
		       break;
          case USER_NO_DATA:
		       lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   11140:	84 e0       	ldi	r24, 0x04	; 4
   11142:	61 e0       	ldi	r22, 0x01	; 1
   11144:	49 e6       	ldi	r20, 0x69	; 105
   11146:	50 e1       	ldi	r21, 0x10	; 16
   11148:	24 c1       	rjmp	.+584    	; 0x11392 <FSettingOperator+0x492>
		       break;
		  }
	      break;
     case soIsSaveOperatorName:
          KeyPressed=_key_scan(1);
   1114a:	81 e0       	ldi	r24, 0x01	; 1
   1114c:	0e 94 84 ae 	call	0x15d08	; 0x15d08 <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
   11150:	0e 94 e5 ad 	call	0x15bca	; 0x15bca <_key_btn>
		  switch(KeyChar){
   11154:	83 32       	cpi	r24, 0x23	; 35
   11156:	09 f0       	breq	.+2      	; 0x1115a <FSettingOperator+0x25a>
   11158:	53 c0       	rjmp	.+166    	; 0x11200 <FSettingOperator+0x300>
          case '*':
		       stSettingOperator=soMenuOption;
		       break;
   1115a:	20 e0       	ldi	r18, 0x00	; 0
   1115c:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   1115e:	8e 01       	movw	r16, r28
   11160:	00 5f       	subi	r16, 0xF0	; 240
   11162:	1f 4f       	sbci	r17, 0xFF	; 255
   11164:	f8 01       	movw	r30, r16
   11166:	e2 0f       	add	r30, r18
   11168:	f3 1f       	adc	r31, r19
   1116a:	d9 01       	movw	r26, r18
   1116c:	aa 53       	subi	r26, 0x3A	; 58
   1116e:	b6 4f       	sbci	r27, 0xF6	; 246
   11170:	8c 91       	ld	r24, X
   11172:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   11174:	2f 5f       	subi	r18, 0xFF	; 255
   11176:	3f 4f       	sbci	r19, 0xFF	; 255
   11178:	2f 30       	cpi	r18, 0x0F	; 15
   1117a:	31 05       	cpc	r19, r1
   1117c:	99 f7       	brne	.-26     	; 0x11164 <FSettingOperator+0x264>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   1117e:	1f 8e       	std	Y+31, r1	; 0x1f
          case '*':
		       stSettingOperator=soMenuOption;
		       break;
          case '#':
		       StrPosCopy(strFreeMessageLine1,strOperatorName,0,15);
               AddSpaceLag(strOperatorName,18); 
   11180:	c8 01       	movw	r24, r16
   11182:	62 e1       	ldi	r22, 0x12	; 18
   11184:	0e 94 a0 2d 	call	0x5b40	; 0x5b40 <AddSpaceLag>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
   11188:	85 e1       	ldi	r24, 0x15	; 21
   1118a:	90 e0       	ldi	r25, 0x00	; 0
   1118c:	b8 01       	movw	r22, r16
   1118e:	42 e1       	ldi	r20, 0x12	; 18
   11190:	50 e0       	ldi	r21, 0x00	; 0
   11192:	25 e0       	ldi	r18, 0x05	; 5
   11194:	33 e1       	ldi	r19, 0x13	; 19
   11196:	0e 94 0d b4 	call	0x1681a	; 0x1681a <__eewr_block>
		       eeprom_write_block((const void*) &strOperatorName, (void*) &DefOperatorName,18);
		       lcd_printf(3,1,PSTR("Saved "));
   1119a:	83 e0       	ldi	r24, 0x03	; 3
   1119c:	61 e0       	ldi	r22, 0x01	; 1
   1119e:	42 e6       	ldi	r20, 0x62	; 98
   111a0:	50 e1       	ldi	r21, 0x10	; 16
   111a2:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
			   TimDisplay=0;
   111a6:	10 92 95 01 	sts	0x0195, r1
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   111aa:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   111ac:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   111ae:	81 e0       	ldi	r24, 0x01	; 1
   111b0:	80 93 bf 01 	sts	0x01BF, r24
   111b4:	46 c1       	rjmp	.+652    	; 0x11442 <FSettingOperator+0x542>
		       stSettingOperator=soDelayDisplaySaved;
		       break;
		  }	      
		  break;
     case soChangePasswordInit:
	      lcd_clear();
   111b6:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
		  lcd_printf(1,1,PSTR("-Change Password-"));
   111ba:	81 e0       	ldi	r24, 0x01	; 1
   111bc:	61 e0       	ldi	r22, 0x01	; 1
   111be:	40 e5       	ldi	r20, 0x50	; 80
   111c0:	50 e1       	ldi	r21, 0x10	; 16
   111c2:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		  lcd_printf(2,1,PSTR("1.Supervisor"));
   111c6:	82 e0       	ldi	r24, 0x02	; 2
   111c8:	61 e0       	ldi	r22, 0x01	; 1
   111ca:	43 e4       	ldi	r20, 0x43	; 67
   111cc:	50 e1       	ldi	r21, 0x10	; 16
   111ce:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		  lcd_printf(3,1,PSTR("2.Administrator"));
   111d2:	83 e0       	ldi	r24, 0x03	; 3
   111d4:	61 e0       	ldi	r22, 0x01	; 1
   111d6:	43 e3       	ldi	r20, 0x33	; 51
   111d8:	50 e1       	ldi	r21, 0x10	; 16
   111da:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		  lcd_printf(4,1,PSTR("[*]Back     "));
   111de:	84 e0       	ldi	r24, 0x04	; 4
   111e0:	61 e0       	ldi	r22, 0x01	; 1
   111e2:	46 e2       	ldi	r20, 0x26	; 38
   111e4:	50 e1       	ldi	r21, 0x10	; 16
   111e6:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
          stSettingOperator=soChangePasswordInput; 
   111ea:	86 e0       	ldi	r24, 0x06	; 6
   111ec:	42 c1       	rjmp	.+644    	; 0x11472 <FSettingOperator+0x572>
	      break;
     case soChangePasswordInput:
          KeyPressed=_key_scan(1);
   111ee:	81 e0       	ldi	r24, 0x01	; 1
   111f0:	0e 94 84 ae 	call	0x15d08	; 0x15d08 <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
   111f4:	0e 94 e5 ad 	call	0x15bca	; 0x15bca <_key_btn>
		  switch(KeyChar){
   111f8:	81 33       	cpi	r24, 0x31	; 49
   111fa:	31 f0       	breq	.+12     	; 0x11208 <FSettingOperator+0x308>
   111fc:	82 33       	cpi	r24, 0x32	; 50
   111fe:	31 f0       	breq	.+12     	; 0x1120c <FSettingOperator+0x30c>
   11200:	8a 32       	cpi	r24, 0x2A	; 42
   11202:	09 f0       	breq	.+2      	; 0x11206 <FSettingOperator+0x306>
   11204:	5d c1       	rjmp	.+698    	; 0x114c0 <FSettingOperator+0x5c0>
   11206:	55 c1       	rjmp	.+682    	; 0x114b2 <FSettingOperator+0x5b2>
		  case '1':		 
		       PassType=PT_SUPERVISOR;
   11208:	81 e0       	ldi	r24, 0x01	; 1
   1120a:	01 c0       	rjmp	.+2      	; 0x1120e <FSettingOperator+0x30e>
		       stSettingOperator=soOldPasswordDisplay;
		       break;
          case '2':		       
		       PassType=PT_ADMINISTRATOR;
   1120c:	82 e0       	ldi	r24, 0x02	; 2
   1120e:	80 93 6e 02 	sts	0x026E, r24
   11212:	75 c0       	rjmp	.+234    	; 0x112fe <FSettingOperator+0x3fe>
		       stSettingOperator=soMenuOption;
		       break;
		  }	      
	      break;
     case soOldPasswordDisplay:
	 	  lcd_clear();
   11214:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
	      if (PassType==PT_SUPERVISOR){
   11218:	80 91 6e 02 	lds	r24, 0x026E
   1121c:	81 30       	cpi	r24, 0x01	; 1
   1121e:	21 f4       	brne	.+8      	; 0x11228 <FSettingOperator+0x328>
		      lcd_printf(1,1,PSTR("-Supervisor-"));              
   11220:	61 e0       	ldi	r22, 0x01	; 1
   11222:	49 e1       	ldi	r20, 0x19	; 25
   11224:	50 e1       	ldi	r21, 0x10	; 16
   11226:	06 c0       	rjmp	.+12     	; 0x11234 <FSettingOperator+0x334>
		  }else if (PassType==PT_ADMINISTRATOR){		       
   11228:	82 30       	cpi	r24, 0x02	; 2
   1122a:	31 f4       	brne	.+12     	; 0x11238 <FSettingOperator+0x338>
		       lcd_printf(1,1,PSTR("-Administrator-"));			   
   1122c:	81 e0       	ldi	r24, 0x01	; 1
   1122e:	61 e0       	ldi	r22, 0x01	; 1
   11230:	49 e0       	ldi	r20, 0x09	; 9
   11232:	50 e1       	ldi	r21, 0x10	; 16
   11234:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		  }
		      lcd_printf(2,1,PSTR("Old:_"));
   11238:	82 e0       	ldi	r24, 0x02	; 2
   1123a:	61 e0       	ldi	r22, 0x01	; 1
   1123c:	43 e0       	ldi	r20, 0x03	; 3
   1123e:	50 e1       	ldi	r21, 0x10	; 16
   11240:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
			  lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   11244:	84 e0       	ldi	r24, 0x04	; 4
   11246:	61 e0       	ldi	r22, 0x01	; 1
   11248:	4e ee       	ldi	r20, 0xEE	; 238
   1124a:	5f e0       	ldi	r21, 0x0F	; 15
   1124c:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>

          stSettingOperator=soOldPasswordEntry;
   11250:	88 e0       	ldi	r24, 0x08	; 8
   11252:	0f c1       	rjmp	.+542    	; 0x11472 <FSettingOperator+0x572>
	      break;
     case soOldPasswordEntry:
          uiResult=USER_NONE;
          uiResult=UserInput(UI_NUM_PASSWORD,2,5,strFreeMessageLine1,0,8);           
   11254:	84 e0       	ldi	r24, 0x04	; 4
   11256:	62 e0       	ldi	r22, 0x02	; 2
   11258:	45 e0       	ldi	r20, 0x05	; 5
   1125a:	26 ec       	ldi	r18, 0xC6	; 198
   1125c:	39 e0       	ldi	r19, 0x09	; 9
   1125e:	00 e0       	ldi	r16, 0x00	; 0
   11260:	10 e0       	ldi	r17, 0x00	; 0
   11262:	a8 e0       	ldi	r26, 0x08	; 8
   11264:	ea 2e       	mov	r14, r26
   11266:	0e 94 d8 7d 	call	0xfbb0	; 0xfbb0 <UserInput>
		  switch(uiResult){
   1126a:	83 30       	cpi	r24, 0x03	; 3
   1126c:	61 f0       	breq	.+24     	; 0x11286 <FSettingOperator+0x386>
   1126e:	84 30       	cpi	r24, 0x04	; 4
   11270:	20 f4       	brcc	.+8      	; 0x1127a <FSettingOperator+0x37a>
   11272:	81 30       	cpi	r24, 0x01	; 1
   11274:	09 f0       	breq	.+2      	; 0x11278 <FSettingOperator+0x378>
   11276:	24 c1       	rjmp	.+584    	; 0x114c0 <FSettingOperator+0x5c0>
   11278:	1c c1       	rjmp	.+568    	; 0x114b2 <FSettingOperator+0x5b2>
   1127a:	84 30       	cpi	r24, 0x04	; 4
   1127c:	79 f0       	breq	.+30     	; 0x1129c <FSettingOperator+0x39c>
   1127e:	85 30       	cpi	r24, 0x05	; 5
   11280:	09 f0       	breq	.+2      	; 0x11284 <FSettingOperator+0x384>
   11282:	1e c1       	rjmp	.+572    	; 0x114c0 <FSettingOperator+0x5c0>
   11284:	10 c0       	rjmp	.+32     	; 0x112a6 <FSettingOperator+0x3a6>
		  case USER_OK:
		       lcd_printf(2,1,PSTR("New:_               "));
   11286:	82 e0       	ldi	r24, 0x02	; 2
   11288:	61 e0       	ldi	r22, 0x01	; 1
   1128a:	49 ed       	ldi	r20, 0xD9	; 217
   1128c:	5f e0       	ldi	r21, 0x0F	; 15
   1128e:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
			   lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   11292:	84 e0       	ldi	r24, 0x04	; 4
   11294:	61 e0       	ldi	r22, 0x01	; 1
   11296:	44 ec       	ldi	r20, 0xC4	; 196
   11298:	5f e0       	ldi	r21, 0x0F	; 15
   1129a:	6e c0       	rjmp	.+220    	; 0x11378 <FSettingOperator+0x478>
		       break;
		  case USER_CANCEL:
               stSettingOperator=soMenuOption; 
		       break;
          case USER_ENTRY:
		       lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   1129c:	84 e0       	ldi	r24, 0x04	; 4
   1129e:	61 e0       	ldi	r22, 0x01	; 1
   112a0:	4f ea       	ldi	r20, 0xAF	; 175
   112a2:	5f e0       	ldi	r21, 0x0F	; 15
   112a4:	76 c0       	rjmp	.+236    	; 0x11392 <FSettingOperator+0x492>
		       break;
          case USER_NO_DATA:
		       lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   112a6:	84 e0       	ldi	r24, 0x04	; 4
   112a8:	61 e0       	ldi	r22, 0x01	; 1
   112aa:	4a e9       	ldi	r20, 0x9A	; 154
   112ac:	5f e0       	ldi	r21, 0x0F	; 15
   112ae:	71 c0       	rjmp	.+226    	; 0x11392 <FSettingOperator+0x492>
		       break;
		  }
	      break;
     case soNewPasswordEntry1:
          uiResult=USER_NONE;
          uiResult=UserInput(UI_NUM_PASSWORD,2,5,strFreeMessageLine2,0,8);           
   112b0:	84 e0       	ldi	r24, 0x04	; 4
   112b2:	62 e0       	ldi	r22, 0x02	; 2
   112b4:	45 e0       	ldi	r20, 0x05	; 5
   112b6:	25 eb       	ldi	r18, 0xB5	; 181
   112b8:	38 e0       	ldi	r19, 0x08	; 8
   112ba:	00 e0       	ldi	r16, 0x00	; 0
   112bc:	10 e0       	ldi	r17, 0x00	; 0
   112be:	f8 e0       	ldi	r31, 0x08	; 8
   112c0:	ef 2e       	mov	r14, r31
   112c2:	0e 94 d8 7d 	call	0xfbb0	; 0xfbb0 <UserInput>
		  switch(uiResult){
   112c6:	83 30       	cpi	r24, 0x03	; 3
   112c8:	61 f0       	breq	.+24     	; 0x112e2 <FSettingOperator+0x3e2>
   112ca:	84 30       	cpi	r24, 0x04	; 4
   112cc:	20 f4       	brcc	.+8      	; 0x112d6 <FSettingOperator+0x3d6>
   112ce:	81 30       	cpi	r24, 0x01	; 1
   112d0:	09 f0       	breq	.+2      	; 0x112d4 <FSettingOperator+0x3d4>
   112d2:	f6 c0       	rjmp	.+492    	; 0x114c0 <FSettingOperator+0x5c0>
   112d4:	14 c0       	rjmp	.+40     	; 0x112fe <FSettingOperator+0x3fe>
   112d6:	84 30       	cpi	r24, 0x04	; 4
   112d8:	a1 f0       	breq	.+40     	; 0x11302 <FSettingOperator+0x402>
   112da:	85 30       	cpi	r24, 0x05	; 5
   112dc:	09 f0       	breq	.+2      	; 0x112e0 <FSettingOperator+0x3e0>
   112de:	f0 c0       	rjmp	.+480    	; 0x114c0 <FSettingOperator+0x5c0>
   112e0:	15 c0       	rjmp	.+42     	; 0x1130c <FSettingOperator+0x40c>
		  case USER_OK:
		       lcd_printf(3,1,PSTR("New:_               "));
   112e2:	83 e0       	ldi	r24, 0x03	; 3
   112e4:	61 e0       	ldi	r22, 0x01	; 1
   112e6:	45 e8       	ldi	r20, 0x85	; 133
   112e8:	5f e0       	ldi	r21, 0x0F	; 15
   112ea:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
			   lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   112ee:	84 e0       	ldi	r24, 0x04	; 4
   112f0:	61 e0       	ldi	r22, 0x01	; 1
   112f2:	40 e7       	ldi	r20, 0x70	; 112
   112f4:	5f e0       	ldi	r21, 0x0F	; 15
   112f6:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		       stSettingOperator=soNewPasswordEntry2;
   112fa:	8a e0       	ldi	r24, 0x0A	; 10
   112fc:	ba c0       	rjmp	.+372    	; 0x11472 <FSettingOperator+0x572>
		       break;
		  case USER_CANCEL:		       
			   stSettingOperator=soOldPasswordDisplay;
   112fe:	87 e0       	ldi	r24, 0x07	; 7
   11300:	b8 c0       	rjmp	.+368    	; 0x11472 <FSettingOperator+0x572>
		       break;
          case USER_ENTRY:
		       lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   11302:	84 e0       	ldi	r24, 0x04	; 4
   11304:	61 e0       	ldi	r22, 0x01	; 1
   11306:	4b e5       	ldi	r20, 0x5B	; 91
   11308:	5f e0       	ldi	r21, 0x0F	; 15
   1130a:	43 c0       	rjmp	.+134    	; 0x11392 <FSettingOperator+0x492>
		       break;
          case USER_NO_DATA:
		       lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   1130c:	84 e0       	ldi	r24, 0x04	; 4
   1130e:	61 e0       	ldi	r22, 0x01	; 1
   11310:	46 e4       	ldi	r20, 0x46	; 70
   11312:	5f e0       	ldi	r21, 0x0F	; 15
   11314:	3e c0       	rjmp	.+124    	; 0x11392 <FSettingOperator+0x492>
		       break;
		  }	      
	      break;
     case soNewPasswordEntry2:
          uiResult=USER_NONE;
          uiResult=UserInput(UI_NUM_PASSWORD,3,5,strFreeMessageLine3,0,8);           
   11316:	84 e0       	ldi	r24, 0x04	; 4
   11318:	63 e0       	ldi	r22, 0x03	; 3
   1131a:	45 e0       	ldi	r20, 0x05	; 5
   1131c:	20 e5       	ldi	r18, 0x50	; 80
   1131e:	39 e0       	ldi	r19, 0x09	; 9
   11320:	00 e0       	ldi	r16, 0x00	; 0
   11322:	10 e0       	ldi	r17, 0x00	; 0
   11324:	e8 e0       	ldi	r30, 0x08	; 8
   11326:	ee 2e       	mov	r14, r30
   11328:	0e 94 d8 7d 	call	0xfbb0	; 0xfbb0 <UserInput>
		  switch(uiResult){
   1132c:	83 30       	cpi	r24, 0x03	; 3
   1132e:	61 f0       	breq	.+24     	; 0x11348 <FSettingOperator+0x448>
   11330:	84 30       	cpi	r24, 0x04	; 4
   11332:	20 f4       	brcc	.+8      	; 0x1133c <FSettingOperator+0x43c>
   11334:	81 30       	cpi	r24, 0x01	; 1
   11336:	09 f0       	breq	.+2      	; 0x1133a <FSettingOperator+0x43a>
   11338:	c3 c0       	rjmp	.+390    	; 0x114c0 <FSettingOperator+0x5c0>
   1133a:	12 c0       	rjmp	.+36     	; 0x11360 <FSettingOperator+0x460>
   1133c:	84 30       	cpi	r24, 0x04	; 4
   1133e:	01 f1       	breq	.+64     	; 0x11380 <FSettingOperator+0x480>
   11340:	85 30       	cpi	r24, 0x05	; 5
   11342:	09 f0       	breq	.+2      	; 0x11346 <FSettingOperator+0x446>
   11344:	bd c0       	rjmp	.+378    	; 0x114c0 <FSettingOperator+0x5c0>
   11346:	21 c0       	rjmp	.+66     	; 0x1138a <FSettingOperator+0x48a>
		  case USER_OK:
		       lcd_clear();
   11348:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
               lcd_printf(2,1,PSTR("Validating.."));
   1134c:	82 e0       	ldi	r24, 0x02	; 2
   1134e:	61 e0       	ldi	r22, 0x01	; 1
   11350:	49 e3       	ldi	r20, 0x39	; 57
   11352:	5f e0       	ldi	r21, 0x0F	; 15
   11354:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
			   TimDisplay=0;
   11358:	10 92 95 01 	sts	0x0195, r1
		       stSettingOperator=soDispValidatePassword;
   1135c:	8b e0       	ldi	r24, 0x0B	; 11
   1135e:	89 c0       	rjmp	.+274    	; 0x11472 <FSettingOperator+0x572>
		       break;
		  case USER_CANCEL:
               lcd_clear();
   11360:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
               lcd_printf(2,1,PSTR("New:_               "));
   11364:	82 e0       	ldi	r24, 0x02	; 2
   11366:	61 e0       	ldi	r22, 0x01	; 1
   11368:	44 e2       	ldi	r20, 0x24	; 36
   1136a:	5f e0       	ldi	r21, 0x0F	; 15
   1136c:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
			   lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   11370:	84 e0       	ldi	r24, 0x04	; 4
   11372:	61 e0       	ldi	r22, 0x01	; 1
   11374:	4f e0       	ldi	r20, 0x0F	; 15
   11376:	5f e0       	ldi	r21, 0x0F	; 15
   11378:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		       stSettingOperator=soNewPasswordEntry1;
   1137c:	89 e0       	ldi	r24, 0x09	; 9
   1137e:	79 c0       	rjmp	.+242    	; 0x11472 <FSettingOperator+0x572>
		       break;
          case USER_ENTRY:
		       lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   11380:	84 e0       	ldi	r24, 0x04	; 4
   11382:	61 e0       	ldi	r22, 0x01	; 1
   11384:	4a ef       	ldi	r20, 0xFA	; 250
   11386:	5e e0       	ldi	r21, 0x0E	; 14
   11388:	04 c0       	rjmp	.+8      	; 0x11392 <FSettingOperator+0x492>
		       break;
          case USER_NO_DATA:
		       lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   1138a:	84 e0       	ldi	r24, 0x04	; 4
   1138c:	61 e0       	ldi	r22, 0x01	; 1
   1138e:	45 ee       	ldi	r20, 0xE5	; 229
   11390:	5e e0       	ldi	r21, 0x0E	; 14
   11392:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
   11396:	94 c0       	rjmp	.+296    	; 0x114c0 <FSettingOperator+0x5c0>
		       break;
		  }	      
	      break;
     case soDispValidatePassword:
	      if (TimDisplay>3)stSettingOperator=soValidatePassword;
   11398:	80 91 95 01 	lds	r24, 0x0195
   1139c:	84 30       	cpi	r24, 0x04	; 4
   1139e:	08 f4       	brcc	.+2      	; 0x113a2 <FSettingOperator+0x4a2>
   113a0:	8f c0       	rjmp	.+286    	; 0x114c0 <FSettingOperator+0x5c0>
   113a2:	8c e0       	ldi	r24, 0x0C	; 12
   113a4:	66 c0       	rjmp	.+204    	; 0x11472 <FSettingOperator+0x572>
	      break;
     case soValidatePassword:
          if (PassType==PT_SUPERVISOR) eeprom_read_block((void*) &strPassword, (const void*) &DefSysPassword, 10);		      			   
   113a6:	80 91 6e 02 	lds	r24, 0x026E
   113aa:	81 30       	cpi	r24, 0x01	; 1
   113ac:	29 f4       	brne	.+10     	; 0x113b8 <FSettingOperator+0x4b8>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
   113ae:	ce 01       	movw	r24, r28
   113b0:	01 96       	adiw	r24, 0x01	; 1
   113b2:	6b e0       	ldi	r22, 0x0B	; 11
   113b4:	70 e0       	ldi	r23, 0x00	; 0
   113b6:	06 c0       	rjmp	.+12     	; 0x113c4 <FSettingOperator+0x4c4>
		  else 
		  if (PassType==PT_ADMINISTRATOR) eeprom_read_block((void*) &strPassword, (const void*) &DefSpvPassword, 10);    
   113b8:	82 30       	cpi	r24, 0x02	; 2
   113ba:	51 f4       	brne	.+20     	; 0x113d0 <FSettingOperator+0x4d0>
   113bc:	ce 01       	movw	r24, r28
   113be:	01 96       	adiw	r24, 0x01	; 1
   113c0:	61 e0       	ldi	r22, 0x01	; 1
   113c2:	70 e0       	ldi	r23, 0x00	; 0
   113c4:	4a e0       	ldi	r20, 0x0A	; 10
   113c6:	50 e0       	ldi	r21, 0x00	; 0
   113c8:	2d ef       	ldi	r18, 0xFD	; 253
   113ca:	32 e1       	ldi	r19, 0x12	; 18
   113cc:	0e 94 f1 b3 	call	0x167e2	; 0x167e2 <__eerd_block>
		  
		  //Check Old Validity
		  if (strcmp(strPassword,strFreeMessageLine1)==0){//OldMessage Valid
   113d0:	ce 01       	movw	r24, r28
   113d2:	01 96       	adiw	r24, 0x01	; 1
   113d4:	66 ec       	ldi	r22, 0xC6	; 198
   113d6:	79 e0       	ldi	r23, 0x09	; 9
   113d8:	0e 94 e8 b3 	call	0x167d0	; 0x167d0 <strcmp>
   113dc:	00 97       	sbiw	r24, 0x00	; 0
   113de:	09 f0       	breq	.+2      	; 0x113e2 <FSettingOperator+0x4e2>
   113e0:	4b c0       	rjmp	.+150    	; 0x11478 <FSettingOperator+0x578>
              if (strcmp(strFreeMessageLine2,strFreeMessageLine3)==0){
   113e2:	85 eb       	ldi	r24, 0xB5	; 181
   113e4:	98 e0       	ldi	r25, 0x08	; 8
   113e6:	60 e5       	ldi	r22, 0x50	; 80
   113e8:	79 e0       	ldi	r23, 0x09	; 9
   113ea:	0e 94 e8 b3 	call	0x167d0	; 0x167d0 <strcmp>
   113ee:	00 97       	sbiw	r24, 0x00	; 0
   113f0:	51 f5       	brne	.+84     	; 0x11446 <FSettingOperator+0x546>
                  
			      if (PassType==PT_SUPERVISOR) eeprom_write_block((const void*) &strFreeMessageLine2, (void*) &DefSysPassword, 10);		      			   
   113f2:	80 91 6e 02 	lds	r24, 0x026E
   113f6:	81 30       	cpi	r24, 0x01	; 1
   113f8:	19 f4       	brne	.+6      	; 0x11400 <FSettingOperator+0x500>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
   113fa:	8b e0       	ldi	r24, 0x0B	; 11
   113fc:	90 e0       	ldi	r25, 0x00	; 0
   113fe:	04 c0       	rjmp	.+8      	; 0x11408 <FSettingOperator+0x508>
		          else 
		          if (PassType==PT_ADMINISTRATOR) eeprom_write_block((const void*) &strFreeMessageLine2, (void*) &DefSpvPassword, 10);    
   11400:	82 30       	cpi	r24, 0x02	; 2
   11402:	51 f4       	brne	.+20     	; 0x11418 <FSettingOperator+0x518>
   11404:	81 e0       	ldi	r24, 0x01	; 1
   11406:	90 e0       	ldi	r25, 0x00	; 0
   11408:	65 eb       	ldi	r22, 0xB5	; 181
   1140a:	78 e0       	ldi	r23, 0x08	; 8
   1140c:	4a e0       	ldi	r20, 0x0A	; 10
   1140e:	50 e0       	ldi	r21, 0x00	; 0
   11410:	25 e0       	ldi	r18, 0x05	; 5
   11412:	33 e1       	ldi	r19, 0x13	; 19
   11414:	0e 94 0d b4 	call	0x1681a	; 0x1681a <__eewr_block>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   11418:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   1141a:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   1141c:	81 e0       	ldi	r24, 0x01	; 1
   1141e:	80 93 bf 01 	sts	0x01BF, r24
			      if (PassType==PT_SUPERVISOR) eeprom_write_block((const void*) &strFreeMessageLine2, (void*) &DefSysPassword, 10);		      			   
		          else 
		          if (PassType==PT_ADMINISTRATOR) eeprom_write_block((const void*) &strFreeMessageLine2, (void*) &DefSpvPassword, 10);    

			      system_beep(1);
				  lcd_clear();
   11422:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
			      lcd_printf(2,1,PSTR("     Completed      "));
   11426:	82 e0       	ldi	r24, 0x02	; 2
   11428:	61 e0       	ldi	r22, 0x01	; 1
   1142a:	40 ed       	ldi	r20, 0xD0	; 208
   1142c:	5e e0       	ldi	r21, 0x0E	; 14
   1142e:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
			      lcd_printf(3,1,PSTR("   Password Saved   "));    
   11432:	83 e0       	ldi	r24, 0x03	; 3
   11434:	61 e0       	ldi	r22, 0x01	; 1
   11436:	4b eb       	ldi	r20, 0xBB	; 187
   11438:	5e e0       	ldi	r21, 0x0E	; 14
   1143a:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
				  TimDisplay=0;
   1143e:	10 92 95 01 	sts	0x0195, r1
				  stSettingOperator=soDelayDisplaySaved;
   11442:	8e e0       	ldi	r24, 0x0E	; 14
   11444:	16 c0       	rjmp	.+44     	; 0x11472 <FSettingOperator+0x572>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   11446:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   11448:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   1144a:	82 e0       	ldi	r24, 0x02	; 2
   1144c:	80 93 bf 01 	sts	0x01BF, r24
			      lcd_printf(3,1,PSTR("   Password Saved   "));    
				  TimDisplay=0;
				  stSettingOperator=soDelayDisplaySaved;
			  }else {
			  system_beep(2);
		      TimDisplay=0;
   11450:	10 92 95 01 	sts	0x0195, r1
		      lcd_clear();
   11454:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
		      lcd_printf(2,1,PSTR("      ERROR         "));
   11458:	82 e0       	ldi	r24, 0x02	; 2
   1145a:	61 e0       	ldi	r22, 0x01	; 1
   1145c:	46 ea       	ldi	r20, 0xA6	; 166
   1145e:	5e e0       	ldi	r21, 0x0E	; 14
   11460:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		      lcd_printf(3,1,PSTR("Invalid New Password"));
   11464:	83 e0       	ldi	r24, 0x03	; 3
   11466:	61 e0       	ldi	r22, 0x01	; 1
   11468:	41 e9       	ldi	r20, 0x91	; 145
   1146a:	5e e0       	ldi	r21, 0x0E	; 14
   1146c:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		      stSettingOperator=soDisplayInvalidPassword;
   11470:	8d e0       	ldi	r24, 0x0D	; 13
   11472:	80 93 6f 02 	sts	0x026F, r24
   11476:	24 c0       	rjmp	.+72     	; 0x114c0 <FSettingOperator+0x5c0>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   11478:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   1147a:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   1147c:	82 e0       	ldi	r24, 0x02	; 2
   1147e:	80 93 bf 01 	sts	0x01BF, r24
		      stSettingOperator=soDisplayInvalidPassword;
			  }
		  }else {
		   //InvalidOld Password
		   system_beep(2);
		   TimDisplay=0;
   11482:	10 92 95 01 	sts	0x0195, r1
		   lcd_clear();
   11486:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
		   lcd_printf(2,1,PSTR("      ERROR         "));
   1148a:	82 e0       	ldi	r24, 0x02	; 2
   1148c:	61 e0       	ldi	r22, 0x01	; 1
   1148e:	4c e7       	ldi	r20, 0x7C	; 124
   11490:	5e e0       	ldi	r21, 0x0E	; 14
   11492:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		   lcd_printf(3,1,PSTR("Invalid Old Password"));
   11496:	83 e0       	ldi	r24, 0x03	; 3
   11498:	61 e0       	ldi	r22, 0x01	; 1
   1149a:	47 e6       	ldi	r20, 0x67	; 103
   1149c:	5e e0       	ldi	r21, 0x0E	; 14
   1149e:	e6 cf       	rjmp	.-52     	; 0x1146c <FSettingOperator+0x56c>
		   stSettingOperator=soDisplayInvalidPassword;
		   }
	      break;
     case soDisplayInvalidPassword:
	      if (TimDisplay>6)stSettingOperator=soMenuOption;
   114a0:	80 91 95 01 	lds	r24, 0x0195
   114a4:	87 30       	cpi	r24, 0x07	; 7
   114a6:	60 f0       	brcs	.+24     	; 0x114c0 <FSettingOperator+0x5c0>
   114a8:	04 c0       	rjmp	.+8      	; 0x114b2 <FSettingOperator+0x5b2>
	      break;
     case soDelayDisplaySaved:
	      if (TimDisplay>4)stSettingOperator=soMenuOption;
   114aa:	80 91 95 01 	lds	r24, 0x0195
   114ae:	85 30       	cpi	r24, 0x05	; 5
   114b0:	38 f0       	brcs	.+14     	; 0x114c0 <FSettingOperator+0x5c0>
   114b2:	10 92 6f 02 	sts	0x026F, r1
   114b6:	04 c0       	rjmp	.+8      	; 0x114c0 <FSettingOperator+0x5c0>
	      break;
	 case soExitSettingOperator:
	      stSettingOperator=soMenuOption;
   114b8:	10 92 6f 02 	sts	0x026F, r1
   114bc:	81 e0       	ldi	r24, 0x01	; 1
   114be:	01 c0       	rjmp	.+2      	; 0x114c2 <FSettingOperator+0x5c2>
   114c0:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
     return Result;
}
   114c2:	e5 96       	adiw	r28, 0x35	; 53
   114c4:	0f b6       	in	r0, 0x3f	; 63
   114c6:	f8 94       	cli
   114c8:	de bf       	out	0x3e, r29	; 62
   114ca:	0f be       	out	0x3f, r0	; 63
   114cc:	cd bf       	out	0x3d, r28	; 61
   114ce:	cf 91       	pop	r28
   114d0:	df 91       	pop	r29
   114d2:	1f 91       	pop	r17
   114d4:	0f 91       	pop	r16
   114d6:	ef 90       	pop	r14
   114d8:	08 95       	ret

000114da <FSettingProduct>:

void menu_product(){

}

char FSettingProduct(){//Using strDescription
   114da:	6f 92       	push	r6
   114dc:	7f 92       	push	r7
   114de:	8f 92       	push	r8
   114e0:	9f 92       	push	r9
   114e2:	af 92       	push	r10
   114e4:	bf 92       	push	r11
   114e6:	cf 92       	push	r12
   114e8:	df 92       	push	r13
   114ea:	ef 92       	push	r14
   114ec:	ff 92       	push	r15
   114ee:	0f 93       	push	r16
   114f0:	1f 93       	push	r17
   114f2:	df 93       	push	r29
   114f4:	cf 93       	push	r28
   114f6:	cd b7       	in	r28, 0x3d	; 61
   114f8:	de b7       	in	r29, 0x3e	; 62
   114fa:	a1 97       	sbiw	r28, 0x21	; 33
   114fc:	0f b6       	in	r0, 0x3f	; 63
   114fe:	f8 94       	cli
   11500:	de bf       	out	0x3e, r29	; 62
   11502:	0f be       	out	0x3f, r0	; 63
   11504:	cd bf       	out	0x3d, r28	; 61
     char i;//,x,y;
	 char strProductName[13],lcdteks[20];
	 char Result=MENU_NONE;
	 
     Result=MENU_NONE;
     switch(stMenuProduct){
   11506:	80 91 72 02 	lds	r24, 0x0272
   1150a:	83 30       	cpi	r24, 0x03	; 3
   1150c:	09 f4       	brne	.+2      	; 0x11510 <FSettingProduct+0x36>
   1150e:	ff c0       	rjmp	.+510    	; 0x1170e <FSettingProduct+0x234>
   11510:	84 30       	cpi	r24, 0x04	; 4
   11512:	38 f4       	brcc	.+14     	; 0x11522 <FSettingProduct+0x48>
   11514:	81 30       	cpi	r24, 0x01	; 1
   11516:	09 f4       	brne	.+2      	; 0x1151a <FSettingProduct+0x40>
   11518:	72 c0       	rjmp	.+228    	; 0x115fe <FSettingProduct+0x124>
   1151a:	82 30       	cpi	r24, 0x02	; 2
   1151c:	08 f0       	brcs	.+2      	; 0x11520 <FSettingProduct+0x46>
   1151e:	82 c0       	rjmp	.+260    	; 0x11624 <FSettingProduct+0x14a>
   11520:	0a c0       	rjmp	.+20     	; 0x11536 <FSettingProduct+0x5c>
   11522:	85 30       	cpi	r24, 0x05	; 5
   11524:	09 f4       	brne	.+2      	; 0x11528 <FSettingProduct+0x4e>
   11526:	81 c1       	rjmp	.+770    	; 0x1182a <FSettingProduct+0x350>
   11528:	85 30       	cpi	r24, 0x05	; 5
   1152a:	08 f4       	brcc	.+2      	; 0x1152e <FSettingProduct+0x54>
   1152c:	9e c1       	rjmp	.+828    	; 0x1186a <FSettingProduct+0x390>
   1152e:	86 30       	cpi	r24, 0x06	; 6
   11530:	09 f0       	breq	.+2      	; 0x11534 <FSettingProduct+0x5a>
   11532:	c3 c1       	rjmp	.+902    	; 0x118ba <FSettingProduct+0x3e0>
   11534:	be c1       	rjmp	.+892    	; 0x118b2 <FSettingProduct+0x3d8>
	 case mpInitProduct:
	      //DisplayProductName
		  lcd_clear();
   11536:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
   1153a:	bb eb       	ldi	r27, 0xBB	; 187
   1153c:	cb 2e       	mov	r12, r27
   1153e:	b0 e0       	ldi	r27, 0x00	; 0
   11540:	db 2e       	mov	r13, r27
   11542:	a1 e0       	ldi	r26, 0x01	; 1
   11544:	ea 2e       	mov	r14, r26
   11546:	f1 2c       	mov	r15, r1
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
   11548:	4e 01       	movw	r8, r28
   1154a:	08 94       	sec
   1154c:	81 1c       	adc	r8, r1
   1154e:	91 1c       	adc	r9, r1
		  //lcd_printf(1,1,PSTR("Product:"));
	      for(i=0;i<6;i++){//234 
	          eeprom_read_block((void*) &strProductName, (const void*) &DefProductName[i], 13);
	          sprintf_P(lcdteks,PSTR("%d)%s"),(i+1),strProductName);
   11550:	fe e0       	ldi	r31, 0x0E	; 14
   11552:	af 2e       	mov	r10, r31
   11554:	b1 2c       	mov	r11, r1
   11556:	ac 0e       	add	r10, r28
   11558:	bd 1e       	adc	r11, r29
   1155a:	e8 e4       	ldi	r30, 0x48	; 72
   1155c:	6e 2e       	mov	r6, r30
   1155e:	e2 e1       	ldi	r30, 0x12	; 18
   11560:	7e 2e       	mov	r7, r30
			  lcd_print((((i)%4)+1),(((i)/4)*10)+1,lcdteks);
   11562:	0a e0       	ldi	r16, 0x0A	; 10
	 
     Result=MENU_NONE;
     switch(stMenuProduct){
	 case mpInitProduct:
	      //DisplayProductName
		  lcd_clear();
   11564:	1e 2d       	mov	r17, r14
   11566:	11 50       	subi	r17, 0x01	; 1
   11568:	c4 01       	movw	r24, r8
   1156a:	b6 01       	movw	r22, r12
   1156c:	4d e0       	ldi	r20, 0x0D	; 13
   1156e:	50 e0       	ldi	r21, 0x00	; 0
   11570:	2d ef       	ldi	r18, 0xFD	; 253
   11572:	32 e1       	ldi	r19, 0x12	; 18
   11574:	0e 94 f1 b3 	call	0x167e2	; 0x167e2 <__eerd_block>
		  //lcd_printf(1,1,PSTR("Product:"));
	      for(i=0;i<6;i++){//234 
	          eeprom_read_block((void*) &strProductName, (const void*) &DefProductName[i], 13);
	          sprintf_P(lcdteks,PSTR("%d)%s"),(i+1),strProductName);
   11578:	8d b7       	in	r24, 0x3d	; 61
   1157a:	9e b7       	in	r25, 0x3e	; 62
   1157c:	08 97       	sbiw	r24, 0x08	; 8
   1157e:	0f b6       	in	r0, 0x3f	; 63
   11580:	f8 94       	cli
   11582:	9e bf       	out	0x3e, r25	; 62
   11584:	0f be       	out	0x3f, r0	; 63
   11586:	8d bf       	out	0x3d, r24	; 61
   11588:	ed b7       	in	r30, 0x3d	; 61
   1158a:	fe b7       	in	r31, 0x3e	; 62
   1158c:	31 96       	adiw	r30, 0x01	; 1
   1158e:	ad b7       	in	r26, 0x3d	; 61
   11590:	be b7       	in	r27, 0x3e	; 62
   11592:	12 96       	adiw	r26, 0x02	; 2
   11594:	bc 92       	st	X, r11
   11596:	ae 92       	st	-X, r10
   11598:	11 97       	sbiw	r26, 0x01	; 1
   1159a:	73 82       	std	Z+3, r7	; 0x03
   1159c:	62 82       	std	Z+2, r6	; 0x02
   1159e:	f5 82       	std	Z+5, r15	; 0x05
   115a0:	e4 82       	std	Z+4, r14	; 0x04
   115a2:	97 82       	std	Z+7, r9	; 0x07
   115a4:	86 82       	std	Z+6, r8	; 0x06
   115a6:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
			  lcd_print((((i)%4)+1),(((i)/4)*10)+1,lcdteks);
   115aa:	8d b7       	in	r24, 0x3d	; 61
   115ac:	9e b7       	in	r25, 0x3e	; 62
   115ae:	08 96       	adiw	r24, 0x08	; 8
   115b0:	0f b6       	in	r0, 0x3f	; 63
   115b2:	f8 94       	cli
   115b4:	9e bf       	out	0x3e, r25	; 62
   115b6:	0f be       	out	0x3f, r0	; 63
   115b8:	8d bf       	out	0x3d, r24	; 61
   115ba:	61 2f       	mov	r22, r17
   115bc:	66 95       	lsr	r22
   115be:	66 95       	lsr	r22
   115c0:	60 9f       	mul	r22, r16
   115c2:	b0 01       	movw	r22, r0
   115c4:	11 24       	eor	r1, r1
   115c6:	6f 5f       	subi	r22, 0xFF	; 255
   115c8:	13 70       	andi	r17, 0x03	; 3
   115ca:	81 2f       	mov	r24, r17
   115cc:	8f 5f       	subi	r24, 0xFF	; 255
   115ce:	a5 01       	movw	r20, r10
   115d0:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
   115d4:	ad e0       	ldi	r26, 0x0D	; 13
   115d6:	b0 e0       	ldi	r27, 0x00	; 0
   115d8:	ca 0e       	add	r12, r26
   115da:	db 1e       	adc	r13, r27
   115dc:	08 94       	sec
   115de:	e1 1c       	adc	r14, r1
   115e0:	f1 1c       	adc	r15, r1
     switch(stMenuProduct){
	 case mpInitProduct:
	      //DisplayProductName
		  lcd_clear();
		  //lcd_printf(1,1,PSTR("Product:"));
	      for(i=0;i<6;i++){//234 
   115e2:	b9 e0       	ldi	r27, 0x09	; 9
   115e4:	cb 16       	cp	r12, r27
   115e6:	b1 e0       	ldi	r27, 0x01	; 1
   115e8:	db 06       	cpc	r13, r27
   115ea:	09 f0       	breq	.+2      	; 0x115ee <FSettingProduct+0x114>
   115ec:	bb cf       	rjmp	.-138    	; 0x11564 <FSettingProduct+0x8a>
	          eeprom_read_block((void*) &strProductName, (const void*) &DefProductName[i], 13);
	          sprintf_P(lcdteks,PSTR("%d)%s"),(i+1),strProductName);
			  lcd_print((((i)%4)+1),(((i)/4)*10)+1,lcdteks);
		  }
		  lcd_printf(4,11,PSTR("*)Back"));
   115ee:	84 e0       	ldi	r24, 0x04	; 4
   115f0:	6b e0       	ldi	r22, 0x0B	; 11
   115f2:	41 e4       	ldi	r20, 0x41	; 65
   115f4:	52 e1       	ldi	r21, 0x12	; 18
   115f6:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
          stMenuProduct=mpChangeProduct;
   115fa:	81 e0       	ldi	r24, 0x01	; 1
   115fc:	54 c1       	rjmp	.+680    	; 0x118a6 <FSettingProduct+0x3cc>
	      break;
     case mpChangeProduct:
		  KeyPressed=_key_scan(1);
   115fe:	81 e0       	ldi	r24, 0x01	; 1
   11600:	0e 94 84 ae 	call	0x15d08	; 0x15d08 <_key_scan>
   11604:	18 2f       	mov	r17, r24
		  KeyChar=_key_btn(KeyPressed);
   11606:	0e 94 e5 ad 	call	0x15bca	; 0x15bca <_key_btn>
		  if ((KeyChar>='1')&&(KeyChar<='6')){
   1160a:	81 53       	subi	r24, 0x31	; 49
   1160c:	86 30       	cpi	r24, 0x06	; 6
   1160e:	28 f4       	brcc	.+10     	; 0x1161a <FSettingProduct+0x140>
		      ProdID=KeyChar-'1';
   11610:	80 93 71 02 	sts	0x0271, r24
			  stMenuProduct=mpDispPrice;
   11614:	82 e0       	ldi	r24, 0x02	; 2
   11616:	80 93 72 02 	sts	0x0272, r24
		  }
		  if (KeyPressed==_KEY_CANCEL){
   1161a:	17 3e       	cpi	r17, 0xE7	; 231
   1161c:	09 f0       	breq	.+2      	; 0x11620 <FSettingProduct+0x146>
   1161e:	4d c1       	rjmp	.+666    	; 0x118ba <FSettingProduct+0x3e0>
		      stMenuProduct=mpExitMenuProduct;
   11620:	86 e0       	ldi	r24, 0x06	; 6
   11622:	41 c1       	rjmp	.+642    	; 0x118a6 <FSettingProduct+0x3cc>
   11624:	60 91 71 02 	lds	r22, 0x0271
   11628:	8d e0       	ldi	r24, 0x0D	; 13
   1162a:	68 9f       	mul	r22, r24
   1162c:	b0 01       	movw	r22, r0
   1162e:	11 24       	eor	r1, r1
   11630:	65 54       	subi	r22, 0x45	; 69
   11632:	7f 4f       	sbci	r23, 0xFF	; 255
   11634:	7e 01       	movw	r14, r28
   11636:	08 94       	sec
   11638:	e1 1c       	adc	r14, r1
   1163a:	f1 1c       	adc	r15, r1
   1163c:	c7 01       	movw	r24, r14
   1163e:	4d e0       	ldi	r20, 0x0D	; 13
   11640:	50 e0       	ldi	r21, 0x00	; 0
   11642:	2d ef       	ldi	r18, 0xFD	; 253
   11644:	32 e1       	ldi	r19, 0x12	; 18
   11646:	0e 94 f1 b3 	call	0x167e2	; 0x167e2 <__eerd_block>
		  }
	      break;
     case mpDispPrice:
	 	  eeprom_read_block((void*) &strProductName, (const void*) &DefProductName[ProdID], 13);
		  eeprom_read_block((void*) &strPrice, (const void*) &DefProductPrice[ProdID], 9);
		  sprintf_P(lcdteks,PSTR("1)%s"),strProductName);
   1164a:	70 eb       	ldi	r23, 0xB0	; 176
   1164c:	c7 2e       	mov	r12, r23
   1164e:	76 e0       	ldi	r23, 0x06	; 6
   11650:	d7 2e       	mov	r13, r23
   11652:	60 91 71 02 	lds	r22, 0x0271
   11656:	89 e0       	ldi	r24, 0x09	; 9
   11658:	68 9f       	mul	r22, r24
   1165a:	b0 01       	movw	r22, r0
   1165c:	11 24       	eor	r1, r1
   1165e:	6b 57       	subi	r22, 0x7B	; 123
   11660:	7f 4f       	sbci	r23, 0xFF	; 255
   11662:	c6 01       	movw	r24, r12
   11664:	49 e0       	ldi	r20, 0x09	; 9
   11666:	50 e0       	ldi	r21, 0x00	; 0
   11668:	2d ef       	ldi	r18, 0xFD	; 253
   1166a:	32 e1       	ldi	r19, 0x12	; 18
   1166c:	0e 94 f1 b3 	call	0x167e2	; 0x167e2 <__eerd_block>
   11670:	00 d0       	rcall	.+0      	; 0x11672 <FSettingProduct+0x198>
   11672:	00 d0       	rcall	.+0      	; 0x11674 <FSettingProduct+0x19a>
   11674:	00 d0       	rcall	.+0      	; 0x11676 <FSettingProduct+0x19c>
   11676:	ed b7       	in	r30, 0x3d	; 61
   11678:	fe b7       	in	r31, 0x3e	; 62
   1167a:	31 96       	adiw	r30, 0x01	; 1
   1167c:	8e 01       	movw	r16, r28
   1167e:	02 5f       	subi	r16, 0xF2	; 242
   11680:	1f 4f       	sbci	r17, 0xFF	; 255
   11682:	ad b7       	in	r26, 0x3d	; 61
   11684:	be b7       	in	r27, 0x3e	; 62
   11686:	12 96       	adiw	r26, 0x02	; 2
   11688:	1c 93       	st	X, r17
   1168a:	0e 93       	st	-X, r16
   1168c:	11 97       	sbiw	r26, 0x01	; 1
   1168e:	8c e3       	ldi	r24, 0x3C	; 60
   11690:	92 e1       	ldi	r25, 0x12	; 18
   11692:	93 83       	std	Z+3, r25	; 0x03
   11694:	82 83       	std	Z+2, r24	; 0x02
   11696:	f5 82       	std	Z+5, r15	; 0x05
   11698:	e4 82       	std	Z+4, r14	; 0x04
   1169a:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
		  lcd_clear();lcd_print(1,1,lcdteks);
   1169e:	8d b7       	in	r24, 0x3d	; 61
   116a0:	9e b7       	in	r25, 0x3e	; 62
   116a2:	06 96       	adiw	r24, 0x06	; 6
   116a4:	0f b6       	in	r0, 0x3f	; 63
   116a6:	f8 94       	cli
   116a8:	9e bf       	out	0x3e, r25	; 62
   116aa:	0f be       	out	0x3f, r0	; 63
   116ac:	8d bf       	out	0x3d, r24	; 61
   116ae:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
   116b2:	81 e0       	ldi	r24, 0x01	; 1
   116b4:	61 e0       	ldi	r22, 0x01	; 1
   116b6:	a8 01       	movw	r20, r16
   116b8:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
		  sprintf_P(lcdteks,PSTR("2)%s"),strPrice);
   116bc:	00 d0       	rcall	.+0      	; 0x116be <FSettingProduct+0x1e4>
   116be:	00 d0       	rcall	.+0      	; 0x116c0 <FSettingProduct+0x1e6>
   116c0:	00 d0       	rcall	.+0      	; 0x116c2 <FSettingProduct+0x1e8>
   116c2:	ed b7       	in	r30, 0x3d	; 61
   116c4:	fe b7       	in	r31, 0x3e	; 62
   116c6:	31 96       	adiw	r30, 0x01	; 1
   116c8:	ad b7       	in	r26, 0x3d	; 61
   116ca:	be b7       	in	r27, 0x3e	; 62
   116cc:	12 96       	adiw	r26, 0x02	; 2
   116ce:	1c 93       	st	X, r17
   116d0:	0e 93       	st	-X, r16
   116d2:	11 97       	sbiw	r26, 0x01	; 1
   116d4:	87 e3       	ldi	r24, 0x37	; 55
   116d6:	92 e1       	ldi	r25, 0x12	; 18
   116d8:	93 83       	std	Z+3, r25	; 0x03
   116da:	82 83       	std	Z+2, r24	; 0x02
   116dc:	d5 82       	std	Z+5, r13	; 0x05
   116de:	c4 82       	std	Z+4, r12	; 0x04
   116e0:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
		  lcd_print(2,1,lcdteks);
   116e4:	8d b7       	in	r24, 0x3d	; 61
   116e6:	9e b7       	in	r25, 0x3e	; 62
   116e8:	06 96       	adiw	r24, 0x06	; 6
   116ea:	0f b6       	in	r0, 0x3f	; 63
   116ec:	f8 94       	cli
   116ee:	9e bf       	out	0x3e, r25	; 62
   116f0:	0f be       	out	0x3f, r0	; 63
   116f2:	8d bf       	out	0x3d, r24	; 61
   116f4:	82 e0       	ldi	r24, 0x02	; 2
   116f6:	61 e0       	ldi	r22, 0x01	; 1
   116f8:	a8 01       	movw	r20, r16
   116fa:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
		  lcd_printf(4,1,PSTR("*)Back       "));
   116fe:	84 e0       	ldi	r24, 0x04	; 4
   11700:	61 e0       	ldi	r22, 0x01	; 1
   11702:	49 e2       	ldi	r20, 0x29	; 41
   11704:	52 e1       	ldi	r21, 0x12	; 18
   11706:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		  stMenuProduct=mpIsEdit;
   1170a:	83 e0       	ldi	r24, 0x03	; 3
   1170c:	cc c0       	rjmp	.+408    	; 0x118a6 <FSettingProduct+0x3cc>
	      break;
     case mpIsEdit:
		  KeyPressed=_key_scan(1);
   1170e:	81 e0       	ldi	r24, 0x01	; 1
   11710:	0e 94 84 ae 	call	0x15d08	; 0x15d08 <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
   11714:	0e 94 e5 ad 	call	0x15bca	; 0x15bca <_key_btn>
		  if (KeyChar=='*'){
   11718:	8a 32       	cpi	r24, 0x2A	; 42
   1171a:	09 f4       	brne	.+2      	; 0x1171e <FSettingProduct+0x244>
   1171c:	a3 c0       	rjmp	.+326    	; 0x11864 <FSettingProduct+0x38a>
		      stMenuProduct=mpInitProduct;
		  }else
		  if (KeyChar=='1'){
   1171e:	81 33       	cpi	r24, 0x31	; 49
   11720:	09 f0       	breq	.+2      	; 0x11724 <FSettingProduct+0x24a>
   11722:	4c c0       	rjmp	.+152    	; 0x117bc <FSettingProduct+0x2e2>
   11724:	60 91 71 02 	lds	r22, 0x0271
   11728:	8d e0       	ldi	r24, 0x0D	; 13
   1172a:	68 9f       	mul	r22, r24
   1172c:	b0 01       	movw	r22, r0
   1172e:	11 24       	eor	r1, r1
   11730:	65 54       	subi	r22, 0x45	; 69
   11732:	7f 4f       	sbci	r23, 0xFF	; 255
   11734:	8e 01       	movw	r16, r28
   11736:	0f 5f       	subi	r16, 0xFF	; 255
   11738:	1f 4f       	sbci	r17, 0xFF	; 255
   1173a:	c8 01       	movw	r24, r16
   1173c:	4d e0       	ldi	r20, 0x0D	; 13
   1173e:	50 e0       	ldi	r21, 0x00	; 0
   11740:	2d ef       	ldi	r18, 0xFD	; 253
   11742:	32 e1       	ldi	r19, 0x12	; 18
   11744:	0e 94 f1 b3 	call	0x167e2	; 0x167e2 <__eerd_block>
		      eeprom_read_block((void*) &strProductName, (const void*) &DefProductName[ProdID], 13);
		      sprintf_P(lcdteks,PSTR("Old:%s"),strProductName);
   11748:	00 d0       	rcall	.+0      	; 0x1174a <FSettingProduct+0x270>
   1174a:	00 d0       	rcall	.+0      	; 0x1174c <FSettingProduct+0x272>
   1174c:	00 d0       	rcall	.+0      	; 0x1174e <FSettingProduct+0x274>
   1174e:	ed b7       	in	r30, 0x3d	; 61
   11750:	fe b7       	in	r31, 0x3e	; 62
   11752:	31 96       	adiw	r30, 0x01	; 1
   11754:	6e e0       	ldi	r22, 0x0E	; 14
   11756:	e6 2e       	mov	r14, r22
   11758:	f1 2c       	mov	r15, r1
   1175a:	ec 0e       	add	r14, r28
   1175c:	fd 1e       	adc	r15, r29
   1175e:	ad b7       	in	r26, 0x3d	; 61
   11760:	be b7       	in	r27, 0x3e	; 62
   11762:	12 96       	adiw	r26, 0x02	; 2
   11764:	fc 92       	st	X, r15
   11766:	ee 92       	st	-X, r14
   11768:	11 97       	sbiw	r26, 0x01	; 1
   1176a:	82 e2       	ldi	r24, 0x22	; 34
   1176c:	92 e1       	ldi	r25, 0x12	; 18
   1176e:	93 83       	std	Z+3, r25	; 0x03
   11770:	82 83       	std	Z+2, r24	; 0x02
   11772:	15 83       	std	Z+5, r17	; 0x05
   11774:	04 83       	std	Z+4, r16	; 0x04
   11776:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
			  lcd_printf(1,1,PSTR("Edit Product Name   "));
   1177a:	8d b7       	in	r24, 0x3d	; 61
   1177c:	9e b7       	in	r25, 0x3e	; 62
   1177e:	06 96       	adiw	r24, 0x06	; 6
   11780:	0f b6       	in	r0, 0x3f	; 63
   11782:	f8 94       	cli
   11784:	9e bf       	out	0x3e, r25	; 62
   11786:	0f be       	out	0x3f, r0	; 63
   11788:	8d bf       	out	0x3d, r24	; 61
   1178a:	81 e0       	ldi	r24, 0x01	; 1
   1178c:	61 e0       	ldi	r22, 0x01	; 1
   1178e:	4d e0       	ldi	r20, 0x0D	; 13
   11790:	52 e1       	ldi	r21, 0x12	; 18
   11792:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		       lcd_print(2,1,lcdteks);
   11796:	82 e0       	ldi	r24, 0x02	; 2
   11798:	61 e0       	ldi	r22, 0x01	; 1
   1179a:	a7 01       	movw	r20, r14
   1179c:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
			  lcd_printf(3,1,PSTR("New:_"));
   117a0:	83 e0       	ldi	r24, 0x03	; 3
   117a2:	61 e0       	ldi	r22, 0x01	; 1
   117a4:	47 e0       	ldi	r20, 0x07	; 7
   117a6:	52 e1       	ldi	r21, 0x12	; 18
   117a8:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		      lcd_printf(4,1,PSTR("*)Back    #)OK      "));
   117ac:	84 e0       	ldi	r24, 0x04	; 4
   117ae:	61 e0       	ldi	r22, 0x01	; 1
   117b0:	42 ef       	ldi	r20, 0xF2	; 242
   117b2:	51 e1       	ldi	r21, 0x11	; 17
   117b4:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		      stMenuProduct=mpEditProductName;
   117b8:	85 e0       	ldi	r24, 0x05	; 5
   117ba:	75 c0       	rjmp	.+234    	; 0x118a6 <FSettingProduct+0x3cc>
		  }else
		  if (KeyChar=='2'){
   117bc:	82 33       	cpi	r24, 0x32	; 50
   117be:	09 f0       	breq	.+2      	; 0x117c2 <FSettingProduct+0x2e8>
   117c0:	7c c0       	rjmp	.+248    	; 0x118ba <FSettingProduct+0x3e0>
		      uiResult=USER_NONE;
		      sprintf_P(lcdteks,PSTR("Old:%s"),strPrice);
   117c2:	00 d0       	rcall	.+0      	; 0x117c4 <FSettingProduct+0x2ea>
   117c4:	00 d0       	rcall	.+0      	; 0x117c6 <FSettingProduct+0x2ec>
   117c6:	00 d0       	rcall	.+0      	; 0x117c8 <FSettingProduct+0x2ee>
   117c8:	ed b7       	in	r30, 0x3d	; 61
   117ca:	fe b7       	in	r31, 0x3e	; 62
   117cc:	31 96       	adiw	r30, 0x01	; 1
   117ce:	8e 01       	movw	r16, r28
   117d0:	02 5f       	subi	r16, 0xF2	; 242
   117d2:	1f 4f       	sbci	r17, 0xFF	; 255
   117d4:	ad b7       	in	r26, 0x3d	; 61
   117d6:	be b7       	in	r27, 0x3e	; 62
   117d8:	12 96       	adiw	r26, 0x02	; 2
   117da:	1c 93       	st	X, r17
   117dc:	0e 93       	st	-X, r16
   117de:	11 97       	sbiw	r26, 0x01	; 1
   117e0:	8b ee       	ldi	r24, 0xEB	; 235
   117e2:	91 e1       	ldi	r25, 0x11	; 17
   117e4:	93 83       	std	Z+3, r25	; 0x03
   117e6:	82 83       	std	Z+2, r24	; 0x02
   117e8:	80 eb       	ldi	r24, 0xB0	; 176
   117ea:	96 e0       	ldi	r25, 0x06	; 6
   117ec:	95 83       	std	Z+5, r25	; 0x05
   117ee:	84 83       	std	Z+4, r24	; 0x04
   117f0:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
		       lcd_print(2,1,lcdteks);
   117f4:	8d b7       	in	r24, 0x3d	; 61
   117f6:	9e b7       	in	r25, 0x3e	; 62
   117f8:	06 96       	adiw	r24, 0x06	; 6
   117fa:	0f b6       	in	r0, 0x3f	; 63
   117fc:	f8 94       	cli
   117fe:	9e bf       	out	0x3e, r25	; 62
   11800:	0f be       	out	0x3f, r0	; 63
   11802:	8d bf       	out	0x3d, r24	; 61
   11804:	82 e0       	ldi	r24, 0x02	; 2
   11806:	61 e0       	ldi	r22, 0x01	; 1
   11808:	a8 01       	movw	r20, r16
   1180a:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
			  lcd_printf(3,1,PSTR("New:_"));
   1180e:	83 e0       	ldi	r24, 0x03	; 3
   11810:	61 e0       	ldi	r22, 0x01	; 1
   11812:	45 ee       	ldi	r20, 0xE5	; 229
   11814:	51 e1       	ldi	r21, 0x11	; 17
   11816:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		      lcd_printf(4,1,PSTR("*)Back    #)OK      "));
   1181a:	84 e0       	ldi	r24, 0x04	; 4
   1181c:	61 e0       	ldi	r22, 0x01	; 1
   1181e:	40 ed       	ldi	r20, 0xD0	; 208
   11820:	51 e1       	ldi	r21, 0x11	; 17
   11822:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		      stMenuProduct=mpEditPrice;
   11826:	84 e0       	ldi	r24, 0x04	; 4
   11828:	3e c0       	rjmp	.+124    	; 0x118a6 <FSettingProduct+0x3cc>
		  }
	      break;
     case mpEditProductName:
	      uiResult=UserInput(UI_ALPHANUM_R,3,5,strDescription,0,10);
   1182a:	83 e0       	ldi	r24, 0x03	; 3
   1182c:	63 e0       	ldi	r22, 0x03	; 3
   1182e:	45 e0       	ldi	r20, 0x05	; 5
   11830:	20 e4       	ldi	r18, 0x40	; 64
   11832:	39 e0       	ldi	r19, 0x09	; 9
   11834:	00 e0       	ldi	r16, 0x00	; 0
   11836:	10 e0       	ldi	r17, 0x00	; 0
   11838:	5a e0       	ldi	r21, 0x0A	; 10
   1183a:	e5 2e       	mov	r14, r21
   1183c:	0e 94 d8 7d 	call	0xfbb0	; 0xfbb0 <UserInput>
		  if (uiResult==USER_OK){
   11840:	83 30       	cpi	r24, 0x03	; 3
   11842:	a1 f5       	brne	.+104    	; 0x118ac <FSettingProduct+0x3d2>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
   11844:	80 91 71 02 	lds	r24, 0x0271
   11848:	2d e0       	ldi	r18, 0x0D	; 13
   1184a:	82 9f       	mul	r24, r18
   1184c:	c0 01       	movw	r24, r0
   1184e:	11 24       	eor	r1, r1
   11850:	85 54       	subi	r24, 0x45	; 69
   11852:	9f 4f       	sbci	r25, 0xFF	; 255
   11854:	60 e4       	ldi	r22, 0x40	; 64
   11856:	79 e0       	ldi	r23, 0x09	; 9
   11858:	4d e0       	ldi	r20, 0x0D	; 13
   1185a:	50 e0       	ldi	r21, 0x00	; 0
   1185c:	25 e0       	ldi	r18, 0x05	; 5
   1185e:	33 e1       	ldi	r19, 0x13	; 19
   11860:	0e 94 0d b4 	call	0x1681a	; 0x1681a <__eewr_block>
		      eeprom_write_block((const void*)&strDescription,(void*)&DefProductName[ProdID], 13);
		      stMenuProduct=mpInitProduct;
   11864:	10 92 72 02 	sts	0x0272, r1
   11868:	28 c0       	rjmp	.+80     	; 0x118ba <FSettingProduct+0x3e0>
			  }
		  else
		  if (uiResult==USER_CANCEL)stMenuProduct=mpDispPrice;
	      break;
     case mpEditPrice:
	      uiResult=UserInput(UI_NUMBER_R,3,5,strPrice,0,7);
   1186a:	81 e0       	ldi	r24, 0x01	; 1
   1186c:	63 e0       	ldi	r22, 0x03	; 3
   1186e:	45 e0       	ldi	r20, 0x05	; 5
   11870:	20 eb       	ldi	r18, 0xB0	; 176
   11872:	36 e0       	ldi	r19, 0x06	; 6
   11874:	00 e0       	ldi	r16, 0x00	; 0
   11876:	10 e0       	ldi	r17, 0x00	; 0
   11878:	97 e0       	ldi	r25, 0x07	; 7
   1187a:	e9 2e       	mov	r14, r25
   1187c:	0e 94 d8 7d 	call	0xfbb0	; 0xfbb0 <UserInput>
		  if (uiResult==USER_OK){
   11880:	83 30       	cpi	r24, 0x03	; 3
   11882:	a1 f4       	brne	.+40     	; 0x118ac <FSettingProduct+0x3d2>
   11884:	80 91 71 02 	lds	r24, 0x0271
   11888:	29 e0       	ldi	r18, 0x09	; 9
   1188a:	82 9f       	mul	r24, r18
   1188c:	c0 01       	movw	r24, r0
   1188e:	11 24       	eor	r1, r1
   11890:	8b 57       	subi	r24, 0x7B	; 123
   11892:	9f 4f       	sbci	r25, 0xFF	; 255
   11894:	60 eb       	ldi	r22, 0xB0	; 176
   11896:	76 e0       	ldi	r23, 0x06	; 6
   11898:	49 e0       	ldi	r20, 0x09	; 9
   1189a:	50 e0       	ldi	r21, 0x00	; 0
   1189c:	25 e0       	ldi	r18, 0x05	; 5
   1189e:	33 e1       	ldi	r19, 0x13	; 19
   118a0:	0e 94 0d b4 	call	0x1681a	; 0x1681a <__eewr_block>
		      eeprom_write_block((const void*)&strPrice,(void*)&DefProductPrice[ProdID], 9);
		      stMenuProduct=mpDispPrice;//stMenuProduct=mpInit;
   118a4:	82 e0       	ldi	r24, 0x02	; 2
   118a6:	80 93 72 02 	sts	0x0272, r24
   118aa:	07 c0       	rjmp	.+14     	; 0x118ba <FSettingProduct+0x3e0>
			  }
		  else
		  if (uiResult==USER_CANCEL)stMenuProduct=mpDispPrice;
   118ac:	81 30       	cpi	r24, 0x01	; 1
   118ae:	29 f4       	brne	.+10     	; 0x118ba <FSettingProduct+0x3e0>
   118b0:	f9 cf       	rjmp	.-14     	; 0x118a4 <FSettingProduct+0x3ca>
	      break;
     case mpExitMenuProduct:
	      stMenuProduct=mpInitProduct;
   118b2:	10 92 72 02 	sts	0x0272, r1
   118b6:	81 e0       	ldi	r24, 0x01	; 1
   118b8:	01 c0       	rjmp	.+2      	; 0x118bc <FSettingProduct+0x3e2>
   118ba:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
   return Result;
}
   118bc:	a1 96       	adiw	r28, 0x21	; 33
   118be:	0f b6       	in	r0, 0x3f	; 63
   118c0:	f8 94       	cli
   118c2:	de bf       	out	0x3e, r29	; 62
   118c4:	0f be       	out	0x3f, r0	; 63
   118c6:	cd bf       	out	0x3d, r28	; 61
   118c8:	cf 91       	pop	r28
   118ca:	df 91       	pop	r29
   118cc:	1f 91       	pop	r17
   118ce:	0f 91       	pop	r16
   118d0:	ff 90       	pop	r15
   118d2:	ef 90       	pop	r14
   118d4:	df 90       	pop	r13
   118d6:	cf 90       	pop	r12
   118d8:	bf 90       	pop	r11
   118da:	af 90       	pop	r10
   118dc:	9f 90       	pop	r9
   118de:	8f 90       	pop	r8
   118e0:	7f 90       	pop	r7
   118e2:	6f 90       	pop	r6
   118e4:	08 95       	ret

000118e6 <FMenuSettingFooter>:
	 }
   //_menu_header();   
   return Result;
}

char FMenuSettingFooter(){
   118e6:	ef 92       	push	r14
   118e8:	0f 93       	push	r16
   118ea:	1f 93       	push	r17
   118ec:	df 93       	push	r29
   118ee:	cf 93       	push	r28
   118f0:	cd b7       	in	r28, 0x3d	; 61
   118f2:	de b7       	in	r29, 0x3e	; 62
   118f4:	c6 54       	subi	r28, 0x46	; 70
   118f6:	d0 40       	sbci	r29, 0x00	; 0
   118f8:	0f b6       	in	r0, 0x3f	; 63
   118fa:	f8 94       	cli
   118fc:	de bf       	out	0x3e, r29	; 62
   118fe:	0f be       	out	0x3f, r0	; 63
   11900:	cd bf       	out	0x3d, r28	; 61
	 char strHeaderFooter[50];
	 char KeyChar;
	 
	 Result=MENU_NONE;
     
	 switch (stSettingHeader){
   11902:	80 91 95 02 	lds	r24, 0x0295
   11906:	84 30       	cpi	r24, 0x04	; 4
   11908:	09 f4       	brne	.+2      	; 0x1190c <FMenuSettingFooter+0x26>
   1190a:	3b c1       	rjmp	.+630    	; 0x11b82 <FMenuSettingFooter+0x29c>
   1190c:	85 30       	cpi	r24, 0x05	; 5
   1190e:	40 f4       	brcc	.+16     	; 0x11920 <FMenuSettingFooter+0x3a>
   11910:	81 30       	cpi	r24, 0x01	; 1
   11912:	79 f1       	breq	.+94     	; 0x11972 <FMenuSettingFooter+0x8c>
   11914:	81 30       	cpi	r24, 0x01	; 1
   11916:	88 f0       	brcs	.+34     	; 0x1193a <FMenuSettingFooter+0x54>
   11918:	82 30       	cpi	r24, 0x02	; 2
   1191a:	09 f0       	breq	.+2      	; 0x1191e <FMenuSettingFooter+0x38>
   1191c:	7f c1       	rjmp	.+766    	; 0x11c1c <FMenuSettingFooter+0x336>
   1191e:	74 c0       	rjmp	.+232    	; 0x11a08 <FMenuSettingFooter+0x122>
   11920:	86 30       	cpi	r24, 0x06	; 6
   11922:	09 f4       	brne	.+2      	; 0x11926 <FMenuSettingFooter+0x40>
   11924:	d3 c0       	rjmp	.+422    	; 0x11acc <FMenuSettingFooter+0x1e6>
   11926:	86 30       	cpi	r24, 0x06	; 6
   11928:	08 f4       	brcc	.+2      	; 0x1192c <FMenuSettingFooter+0x46>
   1192a:	bd c0       	rjmp	.+378    	; 0x11aa6 <FMenuSettingFooter+0x1c0>
   1192c:	87 30       	cpi	r24, 0x07	; 7
   1192e:	09 f4       	brne	.+2      	; 0x11932 <FMenuSettingFooter+0x4c>
   11930:	37 c1       	rjmp	.+622    	; 0x11ba0 <FMenuSettingFooter+0x2ba>
   11932:	88 30       	cpi	r24, 0x08	; 8
   11934:	09 f0       	breq	.+2      	; 0x11938 <FMenuSettingFooter+0x52>
   11936:	72 c1       	rjmp	.+740    	; 0x11c1c <FMenuSettingFooter+0x336>
   11938:	6d c1       	rjmp	.+730    	; 0x11c14 <FMenuSettingFooter+0x32e>
	 case shInitHeader:
	      lcd_clear();
   1193a:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
		  lcd_printf(1,1,PSTR("1)Footer1  3)Footer3"));
   1193e:	81 e0       	ldi	r24, 0x01	; 1
   11940:	61 e0       	ldi	r22, 0x01	; 1
   11942:	4f e3       	ldi	r20, 0x3F	; 63
   11944:	54 e1       	ldi	r21, 0x14	; 20
   11946:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		  lcd_printf(2,1,PSTR("2)Footer2  4)Footer4"));
   1194a:	82 e0       	ldi	r24, 0x02	; 2
   1194c:	61 e0       	ldi	r22, 0x01	; 1
   1194e:	4a e2       	ldi	r20, 0x2A	; 42
   11950:	54 e1       	ldi	r21, 0x14	; 20
   11952:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		  lcd_printf(3,1,PSTR("                    "));
   11956:	83 e0       	ldi	r24, 0x03	; 3
   11958:	61 e0       	ldi	r22, 0x01	; 1
   1195a:	45 e1       	ldi	r20, 0x15	; 21
   1195c:	54 e1       	ldi	r21, 0x14	; 20
   1195e:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		  lcd_printf(4,1,PSTR("*)Exit              "));
   11962:	84 e0       	ldi	r24, 0x04	; 4
   11964:	61 e0       	ldi	r22, 0x01	; 1
   11966:	40 e0       	ldi	r20, 0x00	; 0
   11968:	54 e1       	ldi	r21, 0x14	; 20
   1196a:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		  stSettingHeader=shHeaderSelect;
   1196e:	81 e0       	ldi	r24, 0x01	; 1
   11970:	10 c1       	rjmp	.+544    	; 0x11b92 <FMenuSettingFooter+0x2ac>
	      break;
      case shHeaderSelect:
	      KeyChar=_key_btn(_key_scan(1));
   11972:	81 e0       	ldi	r24, 0x01	; 1
   11974:	0e 94 84 ae 	call	0x15d08	; 0x15d08 <_key_scan>
   11978:	0e 94 e5 ad 	call	0x15bca	; 0x15bca <_key_btn>
   1197c:	e8 2e       	mov	r14, r24
		  if ((KeyChar>='1')&&(KeyChar<='6')){
   1197e:	81 53       	subi	r24, 0x31	; 49
   11980:	86 30       	cpi	r24, 0x06	; 6
   11982:	e0 f5       	brcc	.+120    	; 0x119fc <FMenuSettingFooter+0x116>
		       HeaderIdx=KeyChar-'1';//
   11984:	80 93 94 02 	sts	0x0294, r24
			   lcd_clear();
   11988:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
			   sprintf_P(lcdteks,PSTR("Edit Footer%d "),HeaderIdx+1);
   1198c:	00 d0       	rcall	.+0      	; 0x1198e <FMenuSettingFooter+0xa8>
   1198e:	00 d0       	rcall	.+0      	; 0x11990 <FMenuSettingFooter+0xaa>
   11990:	00 d0       	rcall	.+0      	; 0x11992 <FMenuSettingFooter+0xac>
   11992:	ed b7       	in	r30, 0x3d	; 61
   11994:	fe b7       	in	r31, 0x3e	; 62
   11996:	31 96       	adiw	r30, 0x01	; 1
   11998:	8e 01       	movw	r16, r28
   1199a:	0f 5f       	subi	r16, 0xFF	; 255
   1199c:	1f 4f       	sbci	r17, 0xFF	; 255
   1199e:	ad b7       	in	r26, 0x3d	; 61
   119a0:	be b7       	in	r27, 0x3e	; 62
   119a2:	12 96       	adiw	r26, 0x02	; 2
   119a4:	1c 93       	st	X, r17
   119a6:	0e 93       	st	-X, r16
   119a8:	11 97       	sbiw	r26, 0x01	; 1
   119aa:	81 ef       	ldi	r24, 0xF1	; 241
   119ac:	93 e1       	ldi	r25, 0x13	; 19
   119ae:	93 83       	std	Z+3, r25	; 0x03
   119b0:	82 83       	std	Z+2, r24	; 0x02
   119b2:	80 91 94 02 	lds	r24, 0x0294
   119b6:	90 e0       	ldi	r25, 0x00	; 0
   119b8:	01 96       	adiw	r24, 0x01	; 1
   119ba:	95 83       	std	Z+5, r25	; 0x05
   119bc:	84 83       	std	Z+4, r24	; 0x04
   119be:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
			   lcd_print(1,1,lcdteks);
   119c2:	8d b7       	in	r24, 0x3d	; 61
   119c4:	9e b7       	in	r25, 0x3e	; 62
   119c6:	06 96       	adiw	r24, 0x06	; 6
   119c8:	0f b6       	in	r0, 0x3f	; 63
   119ca:	f8 94       	cli
   119cc:	9e bf       	out	0x3e, r25	; 62
   119ce:	0f be       	out	0x3f, r0	; 63
   119d0:	8d bf       	out	0x3d, r24	; 61
   119d2:	81 e0       	ldi	r24, 0x01	; 1
   119d4:	61 e0       	ldi	r22, 0x01	; 1
   119d6:	a8 01       	movw	r20, r16
   119d8:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
			   lcd_printf(4,1,PSTR("[*]Back  [#]OK"));
   119dc:	84 e0       	ldi	r24, 0x04	; 4
   119de:	61 e0       	ldi	r22, 0x01	; 1
   119e0:	42 ee       	ldi	r20, 0xE2	; 226
   119e2:	53 e1       	ldi	r21, 0x13	; 19
   119e4:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
   119e8:	ee ef       	ldi	r30, 0xFE	; 254
   119ea:	f4 e0       	ldi	r31, 0x04	; 4
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
   119ec:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   119ee:	96 e0       	ldi	r25, 0x06	; 6
   119f0:	ef 38       	cpi	r30, 0x8F	; 143
   119f2:	f9 07       	cpc	r31, r25
   119f4:	d9 f7       	brne	.-10     	; 0x119ec <FMenuSettingFooter+0x106>
			   lcd_clear();
			   sprintf_P(lcdteks,PSTR("Edit Footer%d "),HeaderIdx+1);
			   lcd_print(1,1,lcdteks);
			   lcd_printf(4,1,PSTR("[*]Back  [#]OK"));
			   FillChar(PrintBuffer,sizeof(PrintBuffer),0);
			   stSettingHeader=shEditHeader1;
   119f6:	82 e0       	ldi	r24, 0x02	; 2
   119f8:	80 93 95 02 	sts	0x0295, r24
		  }
		  if(KeyChar=='*')stSettingHeader=shExitSettingHeader;
   119fc:	aa e2       	ldi	r26, 0x2A	; 42
   119fe:	ea 16       	cp	r14, r26
   11a00:	09 f0       	breq	.+2      	; 0x11a04 <FMenuSettingFooter+0x11e>
   11a02:	0c c1       	rjmp	.+536    	; 0x11c1c <FMenuSettingFooter+0x336>
   11a04:	88 e0       	ldi	r24, 0x08	; 8
   11a06:	c5 c0       	rjmp	.+394    	; 0x11b92 <FMenuSettingFooter+0x2ac>
	      break;
     case shEditHeader1:
          //uiResult=UserInput(UI_ALPHANUM_R,2,1,strFreeMessageLine1,0,20);
		  uiResult=UserInput(UI_ALPHANUM_R,2,1,PrintBuffer,0,40);
   11a08:	83 e0       	ldi	r24, 0x03	; 3
   11a0a:	62 e0       	ldi	r22, 0x02	; 2
   11a0c:	41 e0       	ldi	r20, 0x01	; 1
   11a0e:	2e ef       	ldi	r18, 0xFE	; 254
   11a10:	34 e0       	ldi	r19, 0x04	; 4
   11a12:	00 e0       	ldi	r16, 0x00	; 0
   11a14:	10 e0       	ldi	r17, 0x00	; 0
   11a16:	98 e2       	ldi	r25, 0x28	; 40
   11a18:	e9 2e       	mov	r14, r25
   11a1a:	0e 94 d8 7d 	call	0xfbb0	; 0xfbb0 <UserInput>
		  if (uiResult==USER_OK){
   11a1e:	83 30       	cpi	r24, 0x03	; 3
   11a20:	f1 f5       	brne	.+124    	; 0x11a9e <FMenuSettingFooter+0x1b8>
			  lcd_clear();
   11a22:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
			  AddSpaceLag(PrintBuffer,40);
   11a26:	8e ef       	ldi	r24, 0xFE	; 254
   11a28:	94 e0       	ldi	r25, 0x04	; 4
   11a2a:	68 e2       	ldi	r22, 0x28	; 40
   11a2c:	0e 94 a0 2d 	call	0x5b40	; 0x5b40 <AddSpaceLag>
   11a30:	20 e0       	ldi	r18, 0x00	; 0
   11a32:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   11a34:	f9 01       	movw	r30, r18
   11a36:	ea 53       	subi	r30, 0x3A	; 58
   11a38:	f6 4f       	sbci	r31, 0xF6	; 246
   11a3a:	d9 01       	movw	r26, r18
   11a3c:	a2 50       	subi	r26, 0x02	; 2
   11a3e:	bb 4f       	sbci	r27, 0xFB	; 251
   11a40:	8c 91       	ld	r24, X
   11a42:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   11a44:	2f 5f       	subi	r18, 0xFF	; 255
   11a46:	3f 4f       	sbci	r19, 0xFF	; 255
   11a48:	24 31       	cpi	r18, 0x14	; 20
   11a4a:	31 05       	cpc	r19, r1
   11a4c:	99 f7       	brne	.-26     	; 0x11a34 <FMenuSettingFooter+0x14e>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   11a4e:	10 92 da 09 	sts	0x09DA, r1
   11a52:	e2 e1       	ldi	r30, 0x12	; 18
   11a54:	f5 e0       	ldi	r31, 0x05	; 5
   11a56:	a5 eb       	ldi	r26, 0xB5	; 181
   11a58:	b8 e0       	ldi	r27, 0x08	; 8
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   11a5a:	81 91       	ld	r24, Z+
   11a5c:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   11a5e:	85 e0       	ldi	r24, 0x05	; 5
   11a60:	e6 32       	cpi	r30, 0x26	; 38
   11a62:	f8 07       	cpc	r31, r24
   11a64:	d1 f7       	brne	.-12     	; 0x11a5a <FMenuSettingFooter+0x174>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   11a66:	10 92 c9 08 	sts	0x08C9, r1
			  lcd_clear();
			  AddSpaceLag(PrintBuffer,40);
			  StrPosCopy(PrintBuffer,strFreeMessageLine1,0,20);
			  StrPosCopy(PrintBuffer,strFreeMessageLine2,20,20);

			  lcd_print(1,1,strFreeMessageLine1);			  
   11a6a:	81 e0       	ldi	r24, 0x01	; 1
   11a6c:	61 e0       	ldi	r22, 0x01	; 1
   11a6e:	46 ec       	ldi	r20, 0xC6	; 198
   11a70:	59 e0       	ldi	r21, 0x09	; 9
   11a72:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
			  lcd_print(2,1,strFreeMessageLine2);			  
   11a76:	82 e0       	ldi	r24, 0x02	; 2
   11a78:	61 e0       	ldi	r22, 0x01	; 1
   11a7a:	45 eb       	ldi	r20, 0xB5	; 181
   11a7c:	58 e0       	ldi	r21, 0x08	; 8
   11a7e:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
			  
			  lcd_printf(3,1,PSTR("Align Center?"));
   11a82:	83 e0       	ldi	r24, 0x03	; 3
   11a84:	61 e0       	ldi	r22, 0x01	; 1
   11a86:	44 ed       	ldi	r20, 0xD4	; 212
   11a88:	53 e1       	ldi	r21, 0x13	; 19
   11a8a:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
			  lcd_printf(4,1,PSTR("[*]No  [#]Yes"));
   11a8e:	84 e0       	ldi	r24, 0x04	; 4
   11a90:	61 e0       	ldi	r22, 0x01	; 1
   11a92:	46 ec       	ldi	r20, 0xC6	; 198
   11a94:	53 e1       	ldi	r21, 0x13	; 19
   11a96:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		      stSettingHeader=shIsAlignCenter;
   11a9a:	85 e0       	ldi	r24, 0x05	; 5
   11a9c:	7a c0       	rjmp	.+244    	; 0x11b92 <FMenuSettingFooter+0x2ac>
		  }
		  else
		  if (uiResult==USER_CANCEL)stSettingHeader=shInitHeader;
   11a9e:	81 30       	cpi	r24, 0x01	; 1
   11aa0:	09 f0       	breq	.+2      	; 0x11aa4 <FMenuSettingFooter+0x1be>
   11aa2:	bc c0       	rjmp	.+376    	; 0x11c1c <FMenuSettingFooter+0x336>
   11aa4:	b4 c0       	rjmp	.+360    	; 0x11c0e <FMenuSettingFooter+0x328>
	      break;
     case shIsAlignCenter:
	      KeyChar=_key_btn(_key_scan(1));
   11aa6:	81 e0       	ldi	r24, 0x01	; 1
   11aa8:	0e 94 84 ae 	call	0x15d08	; 0x15d08 <_key_scan>
   11aac:	0e 94 e5 ad 	call	0x15bca	; 0x15bca <_key_btn>
          if(KeyChar=='#'){
   11ab0:	83 32       	cpi	r24, 0x23	; 35
   11ab2:	39 f4       	brne	.+14     	; 0x11ac2 <FMenuSettingFooter+0x1dc>
		      //AlignCenter			  
			  StrAlignCenter(PrintBuffer,40);
   11ab4:	8e ef       	ldi	r24, 0xFE	; 254
   11ab6:	94 e0       	ldi	r25, 0x04	; 4
   11ab8:	68 e2       	ldi	r22, 0x28	; 40
   11aba:	70 e0       	ldi	r23, 0x00	; 0
   11abc:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <StrAlignCenter>
   11ac0:	03 c0       	rjmp	.+6      	; 0x11ac8 <FMenuSettingFooter+0x1e2>
			  stSettingHeader=shIsSaveHeader;
		  } else if(KeyChar=='*')stSettingHeader=shIsSaveHeader;		 
   11ac2:	8a 32       	cpi	r24, 0x2A	; 42
   11ac4:	09 f0       	breq	.+2      	; 0x11ac8 <FMenuSettingFooter+0x1e2>
   11ac6:	aa c0       	rjmp	.+340    	; 0x11c1c <FMenuSettingFooter+0x336>
   11ac8:	86 e0       	ldi	r24, 0x06	; 6
   11aca:	63 c0       	rjmp	.+198    	; 0x11b92 <FMenuSettingFooter+0x2ac>
	      break;
     case shIsSaveHeader:
	      lcd_clear(); 
   11acc:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
   11ad0:	20 e0       	ldi	r18, 0x00	; 0
   11ad2:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   11ad4:	f9 01       	movw	r30, r18
   11ad6:	ea 53       	subi	r30, 0x3A	; 58
   11ad8:	f6 4f       	sbci	r31, 0xF6	; 246
   11ada:	d9 01       	movw	r26, r18
   11adc:	a2 50       	subi	r26, 0x02	; 2
   11ade:	bb 4f       	sbci	r27, 0xFB	; 251
   11ae0:	8c 91       	ld	r24, X
   11ae2:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   11ae4:	2f 5f       	subi	r18, 0xFF	; 255
   11ae6:	3f 4f       	sbci	r19, 0xFF	; 255
   11ae8:	24 31       	cpi	r18, 0x14	; 20
   11aea:	31 05       	cpc	r19, r1
   11aec:	99 f7       	brne	.-26     	; 0x11ad4 <FMenuSettingFooter+0x1ee>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   11aee:	10 92 da 09 	sts	0x09DA, r1
   11af2:	e2 e1       	ldi	r30, 0x12	; 18
   11af4:	f5 e0       	ldi	r31, 0x05	; 5
   11af6:	a5 eb       	ldi	r26, 0xB5	; 181
   11af8:	b8 e0       	ldi	r27, 0x08	; 8
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   11afa:	81 91       	ld	r24, Z+
   11afc:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   11afe:	95 e0       	ldi	r25, 0x05	; 5
   11b00:	e6 32       	cpi	r30, 0x26	; 38
   11b02:	f9 07       	cpc	r31, r25
   11b04:	d1 f7       	brne	.-12     	; 0x11afa <FMenuSettingFooter+0x214>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   11b06:	10 92 c9 08 	sts	0x08C9, r1
	      break;
     case shIsSaveHeader:
	      lcd_clear(); 
		  StrPosCopy(PrintBuffer,strFreeMessageLine1,0,20);
		  StrPosCopy(PrintBuffer,strFreeMessageLine2,20,20);
          lcd_print(1,1,strFreeMessageLine1);
   11b0a:	81 e0       	ldi	r24, 0x01	; 1
   11b0c:	61 e0       	ldi	r22, 0x01	; 1
   11b0e:	46 ec       	ldi	r20, 0xC6	; 198
   11b10:	59 e0       	ldi	r21, 0x09	; 9
   11b12:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
		  lcd_print(2,1,strFreeMessageLine2);
   11b16:	82 e0       	ldi	r24, 0x02	; 2
   11b18:	61 e0       	ldi	r22, 0x01	; 1
   11b1a:	45 eb       	ldi	r20, 0xB5	; 181
   11b1c:	58 e0       	ldi	r21, 0x08	; 8
   11b1e:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
		  sprintf_P(lcdteks,PSTR("Save Footer%d ?"),HeaderIdx+1);
   11b22:	00 d0       	rcall	.+0      	; 0x11b24 <FMenuSettingFooter+0x23e>
   11b24:	00 d0       	rcall	.+0      	; 0x11b26 <FMenuSettingFooter+0x240>
   11b26:	00 d0       	rcall	.+0      	; 0x11b28 <FMenuSettingFooter+0x242>
   11b28:	ed b7       	in	r30, 0x3d	; 61
   11b2a:	fe b7       	in	r31, 0x3e	; 62
   11b2c:	31 96       	adiw	r30, 0x01	; 1
   11b2e:	8e 01       	movw	r16, r28
   11b30:	0f 5f       	subi	r16, 0xFF	; 255
   11b32:	1f 4f       	sbci	r17, 0xFF	; 255
   11b34:	ad b7       	in	r26, 0x3d	; 61
   11b36:	be b7       	in	r27, 0x3e	; 62
   11b38:	12 96       	adiw	r26, 0x02	; 2
   11b3a:	1c 93       	st	X, r17
   11b3c:	0e 93       	st	-X, r16
   11b3e:	11 97       	sbiw	r26, 0x01	; 1
   11b40:	86 eb       	ldi	r24, 0xB6	; 182
   11b42:	93 e1       	ldi	r25, 0x13	; 19
   11b44:	93 83       	std	Z+3, r25	; 0x03
   11b46:	82 83       	std	Z+2, r24	; 0x02
   11b48:	80 91 94 02 	lds	r24, 0x0294
   11b4c:	90 e0       	ldi	r25, 0x00	; 0
   11b4e:	01 96       	adiw	r24, 0x01	; 1
   11b50:	95 83       	std	Z+5, r25	; 0x05
   11b52:	84 83       	std	Z+4, r24	; 0x04
   11b54:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
		  lcd_print(3,1,lcdteks);
   11b58:	8d b7       	in	r24, 0x3d	; 61
   11b5a:	9e b7       	in	r25, 0x3e	; 62
   11b5c:	06 96       	adiw	r24, 0x06	; 6
   11b5e:	0f b6       	in	r0, 0x3f	; 63
   11b60:	f8 94       	cli
   11b62:	9e bf       	out	0x3e, r25	; 62
   11b64:	0f be       	out	0x3f, r0	; 63
   11b66:	8d bf       	out	0x3d, r24	; 61
   11b68:	83 e0       	ldi	r24, 0x03	; 3
   11b6a:	61 e0       	ldi	r22, 0x01	; 1
   11b6c:	a8 01       	movw	r20, r16
   11b6e:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
		  lcd_printf(4,1,PSTR("[*]No [#]Yes"));		      
   11b72:	84 e0       	ldi	r24, 0x04	; 4
   11b74:	61 e0       	ldi	r22, 0x01	; 1
   11b76:	49 ea       	ldi	r20, 0xA9	; 169
   11b78:	53 e1       	ldi	r21, 0x13	; 19
   11b7a:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
	      stSettingHeader=shSaveHeaderQuestions;      
   11b7e:	84 e0       	ldi	r24, 0x04	; 4
   11b80:	08 c0       	rjmp	.+16     	; 0x11b92 <FMenuSettingFooter+0x2ac>
	      break;       
     case shSaveHeaderQuestions:
          KeyChar=_key_btn(_key_scan(1));
   11b82:	81 e0       	ldi	r24, 0x01	; 1
   11b84:	0e 94 84 ae 	call	0x15d08	; 0x15d08 <_key_scan>
   11b88:	0e 94 e5 ad 	call	0x15bca	; 0x15bca <_key_btn>
	      if(KeyChar=='#')stSettingHeader=shSaveHeader;
   11b8c:	83 32       	cpi	r24, 0x23	; 35
   11b8e:	21 f4       	brne	.+8      	; 0x11b98 <FMenuSettingFooter+0x2b2>
   11b90:	87 e0       	ldi	r24, 0x07	; 7
   11b92:	80 93 95 02 	sts	0x0295, r24
   11b96:	42 c0       	rjmp	.+132    	; 0x11c1c <FMenuSettingFooter+0x336>
		  else
          if(KeyChar=='*')stSettingHeader=shInitHeader;
   11b98:	8a 32       	cpi	r24, 0x2A	; 42
   11b9a:	09 f0       	breq	.+2      	; 0x11b9e <FMenuSettingFooter+0x2b8>
   11b9c:	3f c0       	rjmp	.+126    	; 0x11c1c <FMenuSettingFooter+0x336>
   11b9e:	37 c0       	rjmp	.+110    	; 0x11c0e <FMenuSettingFooter+0x328>
	      break;
     case shSaveHeader:
	      sprintf_P(strHeaderFooter,PSTR("%s%s"),strFreeMessageLine1,strFreeMessageLine2);
   11ba0:	ad b7       	in	r26, 0x3d	; 61
   11ba2:	be b7       	in	r27, 0x3e	; 62
   11ba4:	18 97       	sbiw	r26, 0x08	; 8
   11ba6:	0f b6       	in	r0, 0x3f	; 63
   11ba8:	f8 94       	cli
   11baa:	be bf       	out	0x3e, r27	; 62
   11bac:	0f be       	out	0x3f, r0	; 63
   11bae:	ad bf       	out	0x3d, r26	; 61
   11bb0:	ed b7       	in	r30, 0x3d	; 61
   11bb2:	fe b7       	in	r31, 0x3e	; 62
   11bb4:	31 96       	adiw	r30, 0x01	; 1
   11bb6:	8e 01       	movw	r16, r28
   11bb8:	0b 5e       	subi	r16, 0xEB	; 235
   11bba:	1f 4f       	sbci	r17, 0xFF	; 255
   11bbc:	12 96       	adiw	r26, 0x02	; 2
   11bbe:	1c 93       	st	X, r17
   11bc0:	0e 93       	st	-X, r16
   11bc2:	11 97       	sbiw	r26, 0x01	; 1
   11bc4:	84 ea       	ldi	r24, 0xA4	; 164
   11bc6:	93 e1       	ldi	r25, 0x13	; 19
   11bc8:	93 83       	std	Z+3, r25	; 0x03
   11bca:	82 83       	std	Z+2, r24	; 0x02
   11bcc:	86 ec       	ldi	r24, 0xC6	; 198
   11bce:	99 e0       	ldi	r25, 0x09	; 9
   11bd0:	95 83       	std	Z+5, r25	; 0x05
   11bd2:	84 83       	std	Z+4, r24	; 0x04
   11bd4:	85 eb       	ldi	r24, 0xB5	; 181
   11bd6:	98 e0       	ldi	r25, 0x08	; 8
   11bd8:	97 83       	std	Z+7, r25	; 0x07
   11bda:	86 83       	std	Z+6, r24	; 0x06
   11bdc:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
   11be0:	8d b7       	in	r24, 0x3d	; 61
   11be2:	9e b7       	in	r25, 0x3e	; 62
   11be4:	08 96       	adiw	r24, 0x08	; 8
   11be6:	0f b6       	in	r0, 0x3f	; 63
   11be8:	f8 94       	cli
   11bea:	9e bf       	out	0x3e, r25	; 62
   11bec:	0f be       	out	0x3f, r0	; 63
   11bee:	8d bf       	out	0x3d, r24	; 61
   11bf0:	80 91 94 02 	lds	r24, 0x0294
   11bf4:	29 e2       	ldi	r18, 0x29	; 41
   11bf6:	82 9f       	mul	r24, r18
   11bf8:	c0 01       	movw	r24, r0
   11bfa:	11 24       	eor	r1, r1
   11bfc:	83 5e       	subi	r24, 0xE3	; 227
   11bfe:	9c 4f       	sbci	r25, 0xFC	; 252
   11c00:	b8 01       	movw	r22, r16
   11c02:	48 e2       	ldi	r20, 0x28	; 40
   11c04:	50 e0       	ldi	r21, 0x00	; 0
   11c06:	25 e0       	ldi	r18, 0x05	; 5
   11c08:	33 e1       	ldi	r19, 0x13	; 19
   11c0a:	0e 94 0d b4 	call	0x1681a	; 0x1681a <__eewr_block>
	      eeprom_write_block((const void*) &strHeaderFooter, (void*) &DefHeaderFooter[HeaderIdx+6],40);
		  //eeprom_write_block((const void*) &PrintBuffer, (void*) &DefHeaderFooter[HeaderIdx+6],40);

          stSettingHeader=shInitHeader;
   11c0e:	10 92 95 02 	sts	0x0295, r1
   11c12:	04 c0       	rjmp	.+8      	; 0x11c1c <FMenuSettingFooter+0x336>
	      break;
     case shExitSettingHeader:
          stSettingHeader=shInitHeader;
   11c14:	10 92 95 02 	sts	0x0295, r1
   11c18:	81 e0       	ldi	r24, 0x01	; 1
   11c1a:	01 c0       	rjmp	.+2      	; 0x11c1e <FMenuSettingFooter+0x338>
   11c1c:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;	 
	 }
   return Result;
}
   11c1e:	ca 5b       	subi	r28, 0xBA	; 186
   11c20:	df 4f       	sbci	r29, 0xFF	; 255
   11c22:	0f b6       	in	r0, 0x3f	; 63
   11c24:	f8 94       	cli
   11c26:	de bf       	out	0x3e, r29	; 62
   11c28:	0f be       	out	0x3f, r0	; 63
   11c2a:	cd bf       	out	0x3d, r28	; 61
   11c2c:	cf 91       	pop	r28
   11c2e:	df 91       	pop	r29
   11c30:	1f 91       	pop	r17
   11c32:	0f 91       	pop	r16
   11c34:	ef 90       	pop	r14
   11c36:	08 95       	ret

00011c38 <FMenuSettingHeader>:
	      break;
	 }
   return Result;
}

char FMenuSettingHeader(){
   11c38:	ef 92       	push	r14
   11c3a:	0f 93       	push	r16
   11c3c:	1f 93       	push	r17
   11c3e:	df 93       	push	r29
   11c40:	cf 93       	push	r28
   11c42:	cd b7       	in	r28, 0x3d	; 61
   11c44:	de b7       	in	r29, 0x3e	; 62
   11c46:	c6 54       	subi	r28, 0x46	; 70
   11c48:	d0 40       	sbci	r29, 0x00	; 0
   11c4a:	0f b6       	in	r0, 0x3f	; 63
   11c4c:	f8 94       	cli
   11c4e:	de bf       	out	0x3e, r29	; 62
   11c50:	0f be       	out	0x3f, r0	; 63
   11c52:	cd bf       	out	0x3d, r28	; 61
	 char lcdteks[20];
	 char strHeaderFooter[50];
	 
	 Result=MENU_NONE;
     
	 switch (stSettingHeader){
   11c54:	80 91 97 02 	lds	r24, 0x0297
   11c58:	84 30       	cpi	r24, 0x04	; 4
   11c5a:	09 f4       	brne	.+2      	; 0x11c5e <FMenuSettingHeader+0x26>
   11c5c:	3b c1       	rjmp	.+630    	; 0x11ed4 <FMenuSettingHeader+0x29c>
   11c5e:	85 30       	cpi	r24, 0x05	; 5
   11c60:	40 f4       	brcc	.+16     	; 0x11c72 <FMenuSettingHeader+0x3a>
   11c62:	81 30       	cpi	r24, 0x01	; 1
   11c64:	79 f1       	breq	.+94     	; 0x11cc4 <FMenuSettingHeader+0x8c>
   11c66:	81 30       	cpi	r24, 0x01	; 1
   11c68:	88 f0       	brcs	.+34     	; 0x11c8c <FMenuSettingHeader+0x54>
   11c6a:	82 30       	cpi	r24, 0x02	; 2
   11c6c:	09 f0       	breq	.+2      	; 0x11c70 <FMenuSettingHeader+0x38>
   11c6e:	7f c1       	rjmp	.+766    	; 0x11f6e <FMenuSettingHeader+0x336>
   11c70:	74 c0       	rjmp	.+232    	; 0x11d5a <FMenuSettingHeader+0x122>
   11c72:	86 30       	cpi	r24, 0x06	; 6
   11c74:	09 f4       	brne	.+2      	; 0x11c78 <FMenuSettingHeader+0x40>
   11c76:	d3 c0       	rjmp	.+422    	; 0x11e1e <FMenuSettingHeader+0x1e6>
   11c78:	86 30       	cpi	r24, 0x06	; 6
   11c7a:	08 f4       	brcc	.+2      	; 0x11c7e <FMenuSettingHeader+0x46>
   11c7c:	bd c0       	rjmp	.+378    	; 0x11df8 <FMenuSettingHeader+0x1c0>
   11c7e:	87 30       	cpi	r24, 0x07	; 7
   11c80:	09 f4       	brne	.+2      	; 0x11c84 <FMenuSettingHeader+0x4c>
   11c82:	37 c1       	rjmp	.+622    	; 0x11ef2 <FMenuSettingHeader+0x2ba>
   11c84:	88 30       	cpi	r24, 0x08	; 8
   11c86:	09 f0       	breq	.+2      	; 0x11c8a <FMenuSettingHeader+0x52>
   11c88:	72 c1       	rjmp	.+740    	; 0x11f6e <FMenuSettingHeader+0x336>
   11c8a:	6d c1       	rjmp	.+730    	; 0x11f66 <FMenuSettingHeader+0x32e>
	 case shInitHeader:
	      lcd_clear();
   11c8c:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
		  lcd_printf(1,1,PSTR("1)Header1  4)Header4"));
   11c90:	81 e0       	ldi	r24, 0x01	; 1
   11c92:	61 e0       	ldi	r22, 0x01	; 1
   11c94:	4f ee       	ldi	r20, 0xEF	; 239
   11c96:	54 e1       	ldi	r21, 0x14	; 20
   11c98:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		  lcd_printf(2,1,PSTR("2)Header2  5)Header5"));
   11c9c:	82 e0       	ldi	r24, 0x02	; 2
   11c9e:	61 e0       	ldi	r22, 0x01	; 1
   11ca0:	4a ed       	ldi	r20, 0xDA	; 218
   11ca2:	54 e1       	ldi	r21, 0x14	; 20
   11ca4:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		  lcd_printf(3,1,PSTR("3)Header3  6)Header6"));
   11ca8:	83 e0       	ldi	r24, 0x03	; 3
   11caa:	61 e0       	ldi	r22, 0x01	; 1
   11cac:	45 ec       	ldi	r20, 0xC5	; 197
   11cae:	54 e1       	ldi	r21, 0x14	; 20
   11cb0:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		  lcd_printf(4,1,PSTR("*)Exit              "));
   11cb4:	84 e0       	ldi	r24, 0x04	; 4
   11cb6:	61 e0       	ldi	r22, 0x01	; 1
   11cb8:	40 eb       	ldi	r20, 0xB0	; 176
   11cba:	54 e1       	ldi	r21, 0x14	; 20
   11cbc:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		  stSettingHeader=shHeaderSelect;
   11cc0:	81 e0       	ldi	r24, 0x01	; 1
   11cc2:	10 c1       	rjmp	.+544    	; 0x11ee4 <FMenuSettingHeader+0x2ac>
	      break;
     case shHeaderSelect:
	      KeyChar=_key_btn(_key_scan(1));
   11cc4:	81 e0       	ldi	r24, 0x01	; 1
   11cc6:	0e 94 84 ae 	call	0x15d08	; 0x15d08 <_key_scan>
   11cca:	0e 94 e5 ad 	call	0x15bca	; 0x15bca <_key_btn>
   11cce:	e8 2e       	mov	r14, r24
		  if ((KeyChar>='1')&&(KeyChar<='6')){
   11cd0:	81 53       	subi	r24, 0x31	; 49
   11cd2:	86 30       	cpi	r24, 0x06	; 6
   11cd4:	e0 f5       	brcc	.+120    	; 0x11d4e <FMenuSettingHeader+0x116>
		       HeaderIdx=KeyChar-'1';//
   11cd6:	80 93 96 02 	sts	0x0296, r24
			   lcd_clear();
   11cda:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
			   sprintf_P(lcdteks,PSTR("Edit Header%d "),HeaderIdx+1);
   11cde:	00 d0       	rcall	.+0      	; 0x11ce0 <FMenuSettingHeader+0xa8>
   11ce0:	00 d0       	rcall	.+0      	; 0x11ce2 <FMenuSettingHeader+0xaa>
   11ce2:	00 d0       	rcall	.+0      	; 0x11ce4 <FMenuSettingHeader+0xac>
   11ce4:	ed b7       	in	r30, 0x3d	; 61
   11ce6:	fe b7       	in	r31, 0x3e	; 62
   11ce8:	31 96       	adiw	r30, 0x01	; 1
   11cea:	8e 01       	movw	r16, r28
   11cec:	0f 5f       	subi	r16, 0xFF	; 255
   11cee:	1f 4f       	sbci	r17, 0xFF	; 255
   11cf0:	ad b7       	in	r26, 0x3d	; 61
   11cf2:	be b7       	in	r27, 0x3e	; 62
   11cf4:	12 96       	adiw	r26, 0x02	; 2
   11cf6:	1c 93       	st	X, r17
   11cf8:	0e 93       	st	-X, r16
   11cfa:	11 97       	sbiw	r26, 0x01	; 1
   11cfc:	81 ea       	ldi	r24, 0xA1	; 161
   11cfe:	94 e1       	ldi	r25, 0x14	; 20
   11d00:	93 83       	std	Z+3, r25	; 0x03
   11d02:	82 83       	std	Z+2, r24	; 0x02
   11d04:	80 91 96 02 	lds	r24, 0x0296
   11d08:	90 e0       	ldi	r25, 0x00	; 0
   11d0a:	01 96       	adiw	r24, 0x01	; 1
   11d0c:	95 83       	std	Z+5, r25	; 0x05
   11d0e:	84 83       	std	Z+4, r24	; 0x04
   11d10:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
			   lcd_print(1,1,lcdteks);
   11d14:	8d b7       	in	r24, 0x3d	; 61
   11d16:	9e b7       	in	r25, 0x3e	; 62
   11d18:	06 96       	adiw	r24, 0x06	; 6
   11d1a:	0f b6       	in	r0, 0x3f	; 63
   11d1c:	f8 94       	cli
   11d1e:	9e bf       	out	0x3e, r25	; 62
   11d20:	0f be       	out	0x3f, r0	; 63
   11d22:	8d bf       	out	0x3d, r24	; 61
   11d24:	81 e0       	ldi	r24, 0x01	; 1
   11d26:	61 e0       	ldi	r22, 0x01	; 1
   11d28:	a8 01       	movw	r20, r16
   11d2a:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
			   lcd_printf(4,1,PSTR("[*]Back  [#]OK"));
   11d2e:	84 e0       	ldi	r24, 0x04	; 4
   11d30:	61 e0       	ldi	r22, 0x01	; 1
   11d32:	42 e9       	ldi	r20, 0x92	; 146
   11d34:	54 e1       	ldi	r21, 0x14	; 20
   11d36:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
   11d3a:	ee ef       	ldi	r30, 0xFE	; 254
   11d3c:	f4 e0       	ldi	r31, 0x04	; 4
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
   11d3e:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   11d40:	96 e0       	ldi	r25, 0x06	; 6
   11d42:	ef 38       	cpi	r30, 0x8F	; 143
   11d44:	f9 07       	cpc	r31, r25
   11d46:	d9 f7       	brne	.-10     	; 0x11d3e <FMenuSettingHeader+0x106>
			   lcd_clear();
			   sprintf_P(lcdteks,PSTR("Edit Header%d "),HeaderIdx+1);
			   lcd_print(1,1,lcdteks);
			   lcd_printf(4,1,PSTR("[*]Back  [#]OK"));
			   FillChar(PrintBuffer,sizeof(PrintBuffer),0);
			   stSettingHeader=shEditHeader1;
   11d48:	82 e0       	ldi	r24, 0x02	; 2
   11d4a:	80 93 97 02 	sts	0x0297, r24
		  }
		  if(KeyChar=='*')stSettingHeader=shExitSettingHeader;
   11d4e:	aa e2       	ldi	r26, 0x2A	; 42
   11d50:	ea 16       	cp	r14, r26
   11d52:	09 f0       	breq	.+2      	; 0x11d56 <FMenuSettingHeader+0x11e>
   11d54:	0c c1       	rjmp	.+536    	; 0x11f6e <FMenuSettingHeader+0x336>
   11d56:	88 e0       	ldi	r24, 0x08	; 8
   11d58:	c5 c0       	rjmp	.+394    	; 0x11ee4 <FMenuSettingHeader+0x2ac>
	      break;
     case shEditHeader1:
          //uiResult=UserInput(UI_ALPHANUM_R,2,1,strFreeMessageLine1,0,20);
		  uiResult=UserInput(UI_ALPHANUM_R,2,1,PrintBuffer,0,40);
   11d5a:	83 e0       	ldi	r24, 0x03	; 3
   11d5c:	62 e0       	ldi	r22, 0x02	; 2
   11d5e:	41 e0       	ldi	r20, 0x01	; 1
   11d60:	2e ef       	ldi	r18, 0xFE	; 254
   11d62:	34 e0       	ldi	r19, 0x04	; 4
   11d64:	00 e0       	ldi	r16, 0x00	; 0
   11d66:	10 e0       	ldi	r17, 0x00	; 0
   11d68:	58 e2       	ldi	r21, 0x28	; 40
   11d6a:	e5 2e       	mov	r14, r21
   11d6c:	0e 94 d8 7d 	call	0xfbb0	; 0xfbb0 <UserInput>
		  if (uiResult==USER_OK){
   11d70:	83 30       	cpi	r24, 0x03	; 3
   11d72:	f1 f5       	brne	.+124    	; 0x11df0 <FMenuSettingHeader+0x1b8>
			  lcd_clear();
   11d74:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
			  AddSpaceLag(PrintBuffer,40);
   11d78:	8e ef       	ldi	r24, 0xFE	; 254
   11d7a:	94 e0       	ldi	r25, 0x04	; 4
   11d7c:	68 e2       	ldi	r22, 0x28	; 40
   11d7e:	0e 94 a0 2d 	call	0x5b40	; 0x5b40 <AddSpaceLag>
   11d82:	20 e0       	ldi	r18, 0x00	; 0
   11d84:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   11d86:	f9 01       	movw	r30, r18
   11d88:	ea 53       	subi	r30, 0x3A	; 58
   11d8a:	f6 4f       	sbci	r31, 0xF6	; 246
   11d8c:	d9 01       	movw	r26, r18
   11d8e:	a2 50       	subi	r26, 0x02	; 2
   11d90:	bb 4f       	sbci	r27, 0xFB	; 251
   11d92:	8c 91       	ld	r24, X
   11d94:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   11d96:	2f 5f       	subi	r18, 0xFF	; 255
   11d98:	3f 4f       	sbci	r19, 0xFF	; 255
   11d9a:	24 31       	cpi	r18, 0x14	; 20
   11d9c:	31 05       	cpc	r19, r1
   11d9e:	99 f7       	brne	.-26     	; 0x11d86 <FMenuSettingHeader+0x14e>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   11da0:	10 92 da 09 	sts	0x09DA, r1
   11da4:	e2 e1       	ldi	r30, 0x12	; 18
   11da6:	f5 e0       	ldi	r31, 0x05	; 5
   11da8:	a5 eb       	ldi	r26, 0xB5	; 181
   11daa:	b8 e0       	ldi	r27, 0x08	; 8
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   11dac:	81 91       	ld	r24, Z+
   11dae:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   11db0:	85 e0       	ldi	r24, 0x05	; 5
   11db2:	e6 32       	cpi	r30, 0x26	; 38
   11db4:	f8 07       	cpc	r31, r24
   11db6:	d1 f7       	brne	.-12     	; 0x11dac <FMenuSettingHeader+0x174>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   11db8:	10 92 c9 08 	sts	0x08C9, r1
			  lcd_clear();
			  AddSpaceLag(PrintBuffer,40);
			  StrPosCopy(PrintBuffer,strFreeMessageLine1,0,20);
			  StrPosCopy(PrintBuffer,strFreeMessageLine2,20,20);

			  lcd_print(1,1,strFreeMessageLine1);			  
   11dbc:	81 e0       	ldi	r24, 0x01	; 1
   11dbe:	61 e0       	ldi	r22, 0x01	; 1
   11dc0:	46 ec       	ldi	r20, 0xC6	; 198
   11dc2:	59 e0       	ldi	r21, 0x09	; 9
   11dc4:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
			  lcd_print(2,1,strFreeMessageLine2);			  
   11dc8:	82 e0       	ldi	r24, 0x02	; 2
   11dca:	61 e0       	ldi	r22, 0x01	; 1
   11dcc:	45 eb       	ldi	r20, 0xB5	; 181
   11dce:	58 e0       	ldi	r21, 0x08	; 8
   11dd0:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
			  
			  lcd_printf(3,1,PSTR("Align Center?"));
   11dd4:	83 e0       	ldi	r24, 0x03	; 3
   11dd6:	61 e0       	ldi	r22, 0x01	; 1
   11dd8:	44 e8       	ldi	r20, 0x84	; 132
   11dda:	54 e1       	ldi	r21, 0x14	; 20
   11ddc:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
			  lcd_printf(4,1,PSTR("[*]No  [#]Yes"));
   11de0:	84 e0       	ldi	r24, 0x04	; 4
   11de2:	61 e0       	ldi	r22, 0x01	; 1
   11de4:	46 e7       	ldi	r20, 0x76	; 118
   11de6:	54 e1       	ldi	r21, 0x14	; 20
   11de8:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		      stSettingHeader=shIsAlignCenter;
   11dec:	85 e0       	ldi	r24, 0x05	; 5
   11dee:	7a c0       	rjmp	.+244    	; 0x11ee4 <FMenuSettingHeader+0x2ac>
		  }
		  else
		  if (uiResult==USER_CANCEL)stSettingHeader=shInitHeader;
   11df0:	81 30       	cpi	r24, 0x01	; 1
   11df2:	09 f0       	breq	.+2      	; 0x11df6 <FMenuSettingHeader+0x1be>
   11df4:	bc c0       	rjmp	.+376    	; 0x11f6e <FMenuSettingHeader+0x336>
   11df6:	b4 c0       	rjmp	.+360    	; 0x11f60 <FMenuSettingHeader+0x328>
	      break;
     case shIsAlignCenter:
	      KeyChar=_key_btn(_key_scan(1));
   11df8:	81 e0       	ldi	r24, 0x01	; 1
   11dfa:	0e 94 84 ae 	call	0x15d08	; 0x15d08 <_key_scan>
   11dfe:	0e 94 e5 ad 	call	0x15bca	; 0x15bca <_key_btn>
          if(KeyChar=='#'){
   11e02:	83 32       	cpi	r24, 0x23	; 35
   11e04:	39 f4       	brne	.+14     	; 0x11e14 <FMenuSettingHeader+0x1dc>
		      //AlignCenter			  
			  StrAlignCenter(PrintBuffer,40);
   11e06:	8e ef       	ldi	r24, 0xFE	; 254
   11e08:	94 e0       	ldi	r25, 0x04	; 4
   11e0a:	68 e2       	ldi	r22, 0x28	; 40
   11e0c:	70 e0       	ldi	r23, 0x00	; 0
   11e0e:	0e 94 a2 2f 	call	0x5f44	; 0x5f44 <StrAlignCenter>
   11e12:	03 c0       	rjmp	.+6      	; 0x11e1a <FMenuSettingHeader+0x1e2>
			  stSettingHeader=shIsSaveHeader;
		  } else if(KeyChar=='*')stSettingHeader=shIsSaveHeader;		 
   11e14:	8a 32       	cpi	r24, 0x2A	; 42
   11e16:	09 f0       	breq	.+2      	; 0x11e1a <FMenuSettingHeader+0x1e2>
   11e18:	aa c0       	rjmp	.+340    	; 0x11f6e <FMenuSettingHeader+0x336>
   11e1a:	86 e0       	ldi	r24, 0x06	; 6
   11e1c:	63 c0       	rjmp	.+198    	; 0x11ee4 <FMenuSettingHeader+0x2ac>
	      break;
     case shIsSaveHeader:
	      lcd_clear(); 
   11e1e:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
   11e22:	20 e0       	ldi	r18, 0x00	; 0
   11e24:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   11e26:	f9 01       	movw	r30, r18
   11e28:	ea 53       	subi	r30, 0x3A	; 58
   11e2a:	f6 4f       	sbci	r31, 0xF6	; 246
   11e2c:	d9 01       	movw	r26, r18
   11e2e:	a2 50       	subi	r26, 0x02	; 2
   11e30:	bb 4f       	sbci	r27, 0xFB	; 251
   11e32:	8c 91       	ld	r24, X
   11e34:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   11e36:	2f 5f       	subi	r18, 0xFF	; 255
   11e38:	3f 4f       	sbci	r19, 0xFF	; 255
   11e3a:	24 31       	cpi	r18, 0x14	; 20
   11e3c:	31 05       	cpc	r19, r1
   11e3e:	99 f7       	brne	.-26     	; 0x11e26 <FMenuSettingHeader+0x1ee>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   11e40:	10 92 da 09 	sts	0x09DA, r1
   11e44:	e2 e1       	ldi	r30, 0x12	; 18
   11e46:	f5 e0       	ldi	r31, 0x05	; 5
   11e48:	a5 eb       	ldi	r26, 0xB5	; 181
   11e4a:	b8 e0       	ldi	r27, 0x08	; 8
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   11e4c:	81 91       	ld	r24, Z+
   11e4e:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   11e50:	95 e0       	ldi	r25, 0x05	; 5
   11e52:	e6 32       	cpi	r30, 0x26	; 38
   11e54:	f9 07       	cpc	r31, r25
   11e56:	d1 f7       	brne	.-12     	; 0x11e4c <FMenuSettingHeader+0x214>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   11e58:	10 92 c9 08 	sts	0x08C9, r1
	      break;
     case shIsSaveHeader:
	      lcd_clear(); 
		  StrPosCopy(PrintBuffer,strFreeMessageLine1,0,20);
		  StrPosCopy(PrintBuffer,strFreeMessageLine2,20,20);
          lcd_print(1,1,strFreeMessageLine1);
   11e5c:	81 e0       	ldi	r24, 0x01	; 1
   11e5e:	61 e0       	ldi	r22, 0x01	; 1
   11e60:	46 ec       	ldi	r20, 0xC6	; 198
   11e62:	59 e0       	ldi	r21, 0x09	; 9
   11e64:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
		  lcd_print(2,1,strFreeMessageLine2);
   11e68:	82 e0       	ldi	r24, 0x02	; 2
   11e6a:	61 e0       	ldi	r22, 0x01	; 1
   11e6c:	45 eb       	ldi	r20, 0xB5	; 181
   11e6e:	58 e0       	ldi	r21, 0x08	; 8
   11e70:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
		  sprintf_P(lcdteks,PSTR("Save Header%d ?"),HeaderIdx+1);
   11e74:	00 d0       	rcall	.+0      	; 0x11e76 <FMenuSettingHeader+0x23e>
   11e76:	00 d0       	rcall	.+0      	; 0x11e78 <FMenuSettingHeader+0x240>
   11e78:	00 d0       	rcall	.+0      	; 0x11e7a <FMenuSettingHeader+0x242>
   11e7a:	ed b7       	in	r30, 0x3d	; 61
   11e7c:	fe b7       	in	r31, 0x3e	; 62
   11e7e:	31 96       	adiw	r30, 0x01	; 1
   11e80:	8e 01       	movw	r16, r28
   11e82:	0f 5f       	subi	r16, 0xFF	; 255
   11e84:	1f 4f       	sbci	r17, 0xFF	; 255
   11e86:	ad b7       	in	r26, 0x3d	; 61
   11e88:	be b7       	in	r27, 0x3e	; 62
   11e8a:	12 96       	adiw	r26, 0x02	; 2
   11e8c:	1c 93       	st	X, r17
   11e8e:	0e 93       	st	-X, r16
   11e90:	11 97       	sbiw	r26, 0x01	; 1
   11e92:	86 e6       	ldi	r24, 0x66	; 102
   11e94:	94 e1       	ldi	r25, 0x14	; 20
   11e96:	93 83       	std	Z+3, r25	; 0x03
   11e98:	82 83       	std	Z+2, r24	; 0x02
   11e9a:	80 91 96 02 	lds	r24, 0x0296
   11e9e:	90 e0       	ldi	r25, 0x00	; 0
   11ea0:	01 96       	adiw	r24, 0x01	; 1
   11ea2:	95 83       	std	Z+5, r25	; 0x05
   11ea4:	84 83       	std	Z+4, r24	; 0x04
   11ea6:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
		  lcd_print(3,1,lcdteks);
   11eaa:	8d b7       	in	r24, 0x3d	; 61
   11eac:	9e b7       	in	r25, 0x3e	; 62
   11eae:	06 96       	adiw	r24, 0x06	; 6
   11eb0:	0f b6       	in	r0, 0x3f	; 63
   11eb2:	f8 94       	cli
   11eb4:	9e bf       	out	0x3e, r25	; 62
   11eb6:	0f be       	out	0x3f, r0	; 63
   11eb8:	8d bf       	out	0x3d, r24	; 61
   11eba:	83 e0       	ldi	r24, 0x03	; 3
   11ebc:	61 e0       	ldi	r22, 0x01	; 1
   11ebe:	a8 01       	movw	r20, r16
   11ec0:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
		  lcd_printf(4,1,PSTR("[*]No [#]Yes"));		      
   11ec4:	84 e0       	ldi	r24, 0x04	; 4
   11ec6:	61 e0       	ldi	r22, 0x01	; 1
   11ec8:	49 e5       	ldi	r20, 0x59	; 89
   11eca:	54 e1       	ldi	r21, 0x14	; 20
   11ecc:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
	      stSettingHeader=shSaveHeaderQuestions;      
   11ed0:	84 e0       	ldi	r24, 0x04	; 4
   11ed2:	08 c0       	rjmp	.+16     	; 0x11ee4 <FMenuSettingHeader+0x2ac>
	      break;    
     case shSaveHeaderQuestions:
	      KeyChar=_key_btn(_key_scan(1));
   11ed4:	81 e0       	ldi	r24, 0x01	; 1
   11ed6:	0e 94 84 ae 	call	0x15d08	; 0x15d08 <_key_scan>
   11eda:	0e 94 e5 ad 	call	0x15bca	; 0x15bca <_key_btn>
	      if(KeyChar=='#')stSettingHeader=shSaveHeader;
   11ede:	83 32       	cpi	r24, 0x23	; 35
   11ee0:	21 f4       	brne	.+8      	; 0x11eea <FMenuSettingHeader+0x2b2>
   11ee2:	87 e0       	ldi	r24, 0x07	; 7
   11ee4:	80 93 97 02 	sts	0x0297, r24
   11ee8:	42 c0       	rjmp	.+132    	; 0x11f6e <FMenuSettingHeader+0x336>
		  else
          if(KeyChar=='*')stSettingHeader=shInitHeader;
   11eea:	8a 32       	cpi	r24, 0x2A	; 42
   11eec:	09 f0       	breq	.+2      	; 0x11ef0 <FMenuSettingHeader+0x2b8>
   11eee:	3f c0       	rjmp	.+126    	; 0x11f6e <FMenuSettingHeader+0x336>
   11ef0:	37 c0       	rjmp	.+110    	; 0x11f60 <FMenuSettingHeader+0x328>
	      break;
     case shSaveHeader:
	      sprintf_P(strHeaderFooter,PSTR("%s%s"),strFreeMessageLine1,strFreeMessageLine2);
   11ef2:	ad b7       	in	r26, 0x3d	; 61
   11ef4:	be b7       	in	r27, 0x3e	; 62
   11ef6:	18 97       	sbiw	r26, 0x08	; 8
   11ef8:	0f b6       	in	r0, 0x3f	; 63
   11efa:	f8 94       	cli
   11efc:	be bf       	out	0x3e, r27	; 62
   11efe:	0f be       	out	0x3f, r0	; 63
   11f00:	ad bf       	out	0x3d, r26	; 61
   11f02:	ed b7       	in	r30, 0x3d	; 61
   11f04:	fe b7       	in	r31, 0x3e	; 62
   11f06:	31 96       	adiw	r30, 0x01	; 1
   11f08:	8e 01       	movw	r16, r28
   11f0a:	0b 5e       	subi	r16, 0xEB	; 235
   11f0c:	1f 4f       	sbci	r17, 0xFF	; 255
   11f0e:	12 96       	adiw	r26, 0x02	; 2
   11f10:	1c 93       	st	X, r17
   11f12:	0e 93       	st	-X, r16
   11f14:	11 97       	sbiw	r26, 0x01	; 1
   11f16:	84 e5       	ldi	r24, 0x54	; 84
   11f18:	94 e1       	ldi	r25, 0x14	; 20
   11f1a:	93 83       	std	Z+3, r25	; 0x03
   11f1c:	82 83       	std	Z+2, r24	; 0x02
   11f1e:	86 ec       	ldi	r24, 0xC6	; 198
   11f20:	99 e0       	ldi	r25, 0x09	; 9
   11f22:	95 83       	std	Z+5, r25	; 0x05
   11f24:	84 83       	std	Z+4, r24	; 0x04
   11f26:	85 eb       	ldi	r24, 0xB5	; 181
   11f28:	98 e0       	ldi	r25, 0x08	; 8
   11f2a:	97 83       	std	Z+7, r25	; 0x07
   11f2c:	86 83       	std	Z+6, r24	; 0x06
   11f2e:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
   11f32:	8d b7       	in	r24, 0x3d	; 61
   11f34:	9e b7       	in	r25, 0x3e	; 62
   11f36:	08 96       	adiw	r24, 0x08	; 8
   11f38:	0f b6       	in	r0, 0x3f	; 63
   11f3a:	f8 94       	cli
   11f3c:	9e bf       	out	0x3e, r25	; 62
   11f3e:	0f be       	out	0x3f, r0	; 63
   11f40:	8d bf       	out	0x3d, r24	; 61
   11f42:	80 91 96 02 	lds	r24, 0x0296
   11f46:	29 e2       	ldi	r18, 0x29	; 41
   11f48:	82 9f       	mul	r24, r18
   11f4a:	c0 01       	movw	r24, r0
   11f4c:	11 24       	eor	r1, r1
   11f4e:	89 5d       	subi	r24, 0xD9	; 217
   11f50:	9d 4f       	sbci	r25, 0xFD	; 253
   11f52:	b8 01       	movw	r22, r16
   11f54:	48 e2       	ldi	r20, 0x28	; 40
   11f56:	50 e0       	ldi	r21, 0x00	; 0
   11f58:	25 e0       	ldi	r18, 0x05	; 5
   11f5a:	33 e1       	ldi	r19, 0x13	; 19
   11f5c:	0e 94 0d b4 	call	0x1681a	; 0x1681a <__eewr_block>
	      eeprom_write_block((const void*) &strHeaderFooter, (void*) &DefHeaderFooter[HeaderIdx],40);
		  //eeprom_write_block((const void*) &PrintBuffer, (void*) &DefHeaderFooter[HeaderIdx],40);
          stSettingHeader=shInitHeader;
   11f60:	10 92 97 02 	sts	0x0297, r1
   11f64:	04 c0       	rjmp	.+8      	; 0x11f6e <FMenuSettingHeader+0x336>
	      break;
     case shExitSettingHeader:
          stSettingHeader=shInitHeader;
   11f66:	10 92 97 02 	sts	0x0297, r1
   11f6a:	81 e0       	ldi	r24, 0x01	; 1
   11f6c:	01 c0       	rjmp	.+2      	; 0x11f70 <FMenuSettingHeader+0x338>
   11f6e:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;	 
	 }
   //_menu_header();   
   return Result;
}
   11f70:	ca 5b       	subi	r28, 0xBA	; 186
   11f72:	df 4f       	sbci	r29, 0xFF	; 255
   11f74:	0f b6       	in	r0, 0x3f	; 63
   11f76:	f8 94       	cli
   11f78:	de bf       	out	0x3e, r29	; 62
   11f7a:	0f be       	out	0x3f, r0	; 63
   11f7c:	cd bf       	out	0x3d, r28	; 61
   11f7e:	cf 91       	pop	r28
   11f80:	df 91       	pop	r29
   11f82:	1f 91       	pop	r17
   11f84:	0f 91       	pop	r16
   11f86:	ef 90       	pop	r14
   11f88:	08 95       	ret

00011f8a <FMenuAdminSettings>:

char FMenuAdminSettings(){
     static char stAdminSettings=asInitMenu;
	 char SubMenu,Result,KeyChar;
	 Result=MENU_NONE;
	 switch(stAdminSettings){
   11f8a:	80 91 98 02 	lds	r24, 0x0298
   11f8e:	83 30       	cpi	r24, 0x03	; 3
   11f90:	09 f4       	brne	.+2      	; 0x11f94 <FMenuAdminSettings+0xa>
   11f92:	6e c0       	rjmp	.+220    	; 0x12070 <FMenuAdminSettings+0xe6>
   11f94:	84 30       	cpi	r24, 0x04	; 4
   11f96:	30 f4       	brcc	.+12     	; 0x11fa4 <FMenuAdminSettings+0x1a>
   11f98:	81 30       	cpi	r24, 0x01	; 1
   11f9a:	e9 f1       	breq	.+122    	; 0x12016 <FMenuAdminSettings+0x8c>
   11f9c:	82 30       	cpi	r24, 0x02	; 2
   11f9e:	08 f0       	brcs	.+2      	; 0x11fa2 <FMenuAdminSettings+0x18>
   11fa0:	64 c0       	rjmp	.+200    	; 0x1206a <FMenuAdminSettings+0xe0>
   11fa2:	0d c0       	rjmp	.+26     	; 0x11fbe <FMenuAdminSettings+0x34>
   11fa4:	85 30       	cpi	r24, 0x05	; 5
   11fa6:	09 f4       	brne	.+2      	; 0x11faa <FMenuAdminSettings+0x20>
   11fa8:	66 c0       	rjmp	.+204    	; 0x12076 <FMenuAdminSettings+0xec>
   11faa:	85 30       	cpi	r24, 0x05	; 5
   11fac:	08 f4       	brcc	.+2      	; 0x11fb0 <FMenuAdminSettings+0x26>
   11fae:	6a c0       	rjmp	.+212    	; 0x12084 <FMenuAdminSettings+0xfa>
   11fb0:	86 30       	cpi	r24, 0x06	; 6
   11fb2:	09 f4       	brne	.+2      	; 0x11fb6 <FMenuAdminSettings+0x2c>
   11fb4:	63 c0       	rjmp	.+198    	; 0x1207c <FMenuAdminSettings+0xf2>
   11fb6:	87 30       	cpi	r24, 0x07	; 7
   11fb8:	09 f0       	breq	.+2      	; 0x11fbc <FMenuAdminSettings+0x32>
   11fba:	6c c0       	rjmp	.+216    	; 0x12094 <FMenuAdminSettings+0x10a>
   11fbc:	67 c0       	rjmp	.+206    	; 0x1208c <FMenuAdminSettings+0x102>
	 case asInitMenu:
          lcd_clear();
   11fbe:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
		  if (IFType==IT_SLAVE){
   11fc2:	80 91 00 01 	lds	r24, 0x0100
   11fc6:	81 30       	cpi	r24, 0x01	; 1
   11fc8:	51 f4       	brne	.+20     	; 0x11fde <FMenuAdminSettings+0x54>
		      lcd_printf(1,1, PSTR("1)Header    4)Client"));
   11fca:	61 e0       	ldi	r22, 0x01	; 1
   11fcc:	4f e5       	ldi	r20, 0x5F	; 95
   11fce:	55 e1       	ldi	r21, 0x15	; 21
   11fd0:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		      lcd_printf(2,1, PSTR("2)Footer    5)Server"));
   11fd4:	82 e0       	ldi	r24, 0x02	; 2
   11fd6:	61 e0       	ldi	r22, 0x01	; 1
   11fd8:	4a e4       	ldi	r20, 0x4A	; 74
   11fda:	55 e1       	ldi	r21, 0x15	; 21
   11fdc:	0c c0       	rjmp	.+24     	; 0x11ff6 <FMenuAdminSettings+0x6c>
		  }else
		  if (IFType==IT_STANDALONE){
   11fde:	82 30       	cpi	r24, 0x02	; 2
   11fe0:	61 f4       	brne	.+24     	; 0x11ffa <FMenuAdminSettings+0x70>
		      lcd_printf(1,1, PSTR("1)Header            "));
   11fe2:	81 e0       	ldi	r24, 0x01	; 1
   11fe4:	61 e0       	ldi	r22, 0x01	; 1
   11fe6:	45 e3       	ldi	r20, 0x35	; 53
   11fe8:	55 e1       	ldi	r21, 0x15	; 21
   11fea:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		      lcd_printf(2,1, PSTR("2)Footer            "));
   11fee:	82 e0       	ldi	r24, 0x02	; 2
   11ff0:	61 e0       	ldi	r22, 0x01	; 1
   11ff2:	40 e2       	ldi	r20, 0x20	; 32
   11ff4:	55 e1       	ldi	r21, 0x15	; 21
   11ff6:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		  }
		  lcd_printf(3,1, PSTR("3)Password          "));
   11ffa:	83 e0       	ldi	r24, 0x03	; 3
   11ffc:	61 e0       	ldi	r22, 0x01	; 1
   11ffe:	4b e0       	ldi	r20, 0x0B	; 11
   12000:	55 e1       	ldi	r21, 0x15	; 21
   12002:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		  lcd_printf(4,1, PSTR("*)Exit"));
   12006:	84 e0       	ldi	r24, 0x04	; 4
   12008:	61 e0       	ldi	r22, 0x01	; 1
   1200a:	44 e0       	ldi	r20, 0x04	; 4
   1200c:	55 e1       	ldi	r21, 0x15	; 21
   1200e:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		  stAdminSettings=asAdminSettingsOption;
   12012:	81 e0       	ldi	r24, 0x01	; 1
   12014:	27 c0       	rjmp	.+78     	; 0x12064 <FMenuAdminSettings+0xda>
		  break;
     case asAdminSettingsOption:
	      KeyChar=_key_btn(_key_scan(1));
   12016:	81 e0       	ldi	r24, 0x01	; 1
   12018:	0e 94 84 ae 	call	0x15d08	; 0x15d08 <_key_scan>
   1201c:	0e 94 e5 ad 	call	0x15bca	; 0x15bca <_key_btn>
   12020:	98 2f       	mov	r25, r24
		  switch(KeyChar){
   12022:	82 33       	cpi	r24, 0x32	; 50
   12024:	61 f0       	breq	.+24     	; 0x1203e <FMenuAdminSettings+0xb4>
   12026:	83 33       	cpi	r24, 0x33	; 51
   12028:	28 f4       	brcc	.+10     	; 0x12034 <FMenuAdminSettings+0xaa>
   1202a:	8a 32       	cpi	r24, 0x2A	; 42
   1202c:	61 f0       	breq	.+24     	; 0x12046 <FMenuAdminSettings+0xbc>
   1202e:	81 33       	cpi	r24, 0x31	; 49
   12030:	69 f4       	brne	.+26     	; 0x1204c <FMenuAdminSettings+0xc2>
   12032:	03 c0       	rjmp	.+6      	; 0x1203a <FMenuAdminSettings+0xb0>
   12034:	83 33       	cpi	r24, 0x33	; 51
   12036:	51 f4       	brne	.+20     	; 0x1204c <FMenuAdminSettings+0xc2>
   12038:	04 c0       	rjmp	.+8      	; 0x12042 <FMenuAdminSettings+0xb8>
		  case '1':stAdminSettings=asAdminSettingHeader;
   1203a:	82 e0       	ldi	r24, 0x02	; 2
   1203c:	05 c0       	rjmp	.+10     	; 0x12048 <FMenuAdminSettings+0xbe>
		       break;
		  case '2':stAdminSettings=asAdminSettingFooter;
   1203e:	83 e0       	ldi	r24, 0x03	; 3
   12040:	03 c0       	rjmp	.+6      	; 0x12048 <FMenuAdminSettings+0xbe>
		       break;
		  case '3':stAdminSettings=asAdminSettingPassword;
   12042:	84 e0       	ldi	r24, 0x04	; 4
   12044:	01 c0       	rjmp	.+2      	; 0x12048 <FMenuAdminSettings+0xbe>
		       break;
		  case '*':stAdminSettings=asExitAdminSetting;
   12046:	87 e0       	ldi	r24, 0x07	; 7
   12048:	80 93 98 02 	sts	0x0298, r24
		       break;			   
		  }
		  if (IFType==IT_SLAVE){
   1204c:	80 91 00 01 	lds	r24, 0x0100
   12050:	81 30       	cpi	r24, 0x01	; 1
   12052:	01 f5       	brne	.+64     	; 0x12094 <FMenuAdminSettings+0x10a>
			  switch(KeyChar){
   12054:	94 33       	cpi	r25, 0x34	; 52
   12056:	19 f0       	breq	.+6      	; 0x1205e <FMenuAdminSettings+0xd4>
   12058:	95 33       	cpi	r25, 0x35	; 53
   1205a:	e1 f4       	brne	.+56     	; 0x12094 <FMenuAdminSettings+0x10a>
   1205c:	02 c0       	rjmp	.+4      	; 0x12062 <FMenuAdminSettings+0xd8>
			  case '4':stAdminSettings=asAdminSettingClientIP;
   1205e:	85 e0       	ldi	r24, 0x05	; 5
   12060:	01 c0       	rjmp	.+2      	; 0x12064 <FMenuAdminSettings+0xda>
				   break;
			  case '5':stAdminSettings=asAdminSettingServerIP;
   12062:	86 e0       	ldi	r24, 0x06	; 6
   12064:	80 93 98 02 	sts	0x0298, r24
   12068:	0f c0       	rjmp	.+30     	; 0x12088 <FMenuAdminSettings+0xfe>
				   break;
			  }
		  }
	      break;
	 case asAdminSettingHeader:
	      SubMenu=FMenuSettingHeader();
   1206a:	0e 94 1c 8e 	call	0x11c38	; 0x11c38 <FMenuSettingHeader>
   1206e:	08 c0       	rjmp	.+16     	; 0x12080 <FMenuAdminSettings+0xf6>
	      if (SubMenu==MENU_DONE)stAdminSettings=asInitMenu;
	      break;
	 case asAdminSettingFooter:
	      SubMenu=FMenuSettingFooter();
   12070:	0e 94 73 8c 	call	0x118e6	; 0x118e6 <FMenuSettingFooter>
   12074:	05 c0       	rjmp	.+10     	; 0x12080 <FMenuAdminSettings+0xf6>
	 case asAdminSettingPassword:
	      SubMenu=FMenuSettingPassword();
	      if (SubMenu==MENU_DONE)stAdminSettings=asInitMenu;	 
	      break;
     case asAdminSettingClientIP:
	      SubMenu=FMenuSettingClientIP();
   12076:	0e 94 6d 6d 	call	0xdada	; 0xdada <FMenuSettingClientIP>
   1207a:	02 c0       	rjmp	.+4      	; 0x12080 <FMenuAdminSettings+0xf6>
	      if (SubMenu==MENU_DONE)stAdminSettings=asInitMenu;	 
	      break;
	 case asAdminSettingServerIP:
	      SubMenu=FMenuSettingServerIP();
   1207c:	0e 94 e4 6a 	call	0xd5c8	; 0xd5c8 <FMenuSettingServerIP>
	      if (SubMenu==MENU_DONE)stAdminSettings=asInitMenu;	 
   12080:	81 30       	cpi	r24, 0x01	; 1
   12082:	41 f4       	brne	.+16     	; 0x12094 <FMenuAdminSettings+0x10a>
   12084:	10 92 98 02 	sts	0x0298, r1
   12088:	80 e0       	ldi	r24, 0x00	; 0
   1208a:	08 95       	ret
	      break;
     case asExitAdminSetting:
	      stAdminSettings=asInitMenu;
   1208c:	10 92 98 02 	sts	0x0298, r1
   12090:	81 e0       	ldi	r24, 0x01	; 1
   12092:	08 95       	ret
   12094:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
   return Result;
}
   12096:	08 95       	ret

00012098 <FMenuMaster>:
     else Result=RC_INVALID;

   return Result;
}

char FMenuMaster(){ 
   12098:	ef 92       	push	r14
   1209a:	ff 92       	push	r15
   1209c:	0f 93       	push	r16
   1209e:	1f 93       	push	r17
   120a0:	df 93       	push	r29
   120a2:	cf 93       	push	r28
   120a4:	cd b7       	in	r28, 0x3d	; 61
   120a6:	de b7       	in	r29, 0x3e	; 62
   120a8:	e2 97       	sbiw	r28, 0x32	; 50
   120aa:	0f b6       	in	r0, 0x3f	; 63
   120ac:	f8 94       	cli
   120ae:	de bf       	out	0x3e, r29	; 62
   120b0:	0f be       	out	0x3f, r0	; 63
   120b2:	cd bf       	out	0x3d, r28	; 61
static char stMenuMaster=mmInitMaster;
     char KeyPressed,KeyChar,Result=MENU_NONE;
	 char uiResult,lcdteks[20],PTime[10],PDate[10],strNewPassword[10];
	 char strSend[20];

	 switch(stMenuMaster){
   120b4:	80 91 9d 02 	lds	r24, 0x029D
   120b8:	e8 2f       	mov	r30, r24
   120ba:	f0 e0       	ldi	r31, 0x00	; 0
   120bc:	e1 31       	cpi	r30, 0x11	; 17
   120be:	f1 05       	cpc	r31, r1
   120c0:	08 f0       	brcs	.+2      	; 0x120c4 <FMenuMaster+0x2c>
   120c2:	ed c1       	rjmp	.+986    	; 0x1249e <FMenuMaster+0x406>
   120c4:	e4 54       	subi	r30, 0x44	; 68
   120c6:	ff 4f       	sbci	r31, 0xFF	; 255
   120c8:	ee 0f       	add	r30, r30
   120ca:	ff 1f       	adc	r31, r31
   120cc:	05 90       	lpm	r0, Z+
   120ce:	f4 91       	lpm	r31, Z+
   120d0:	e0 2d       	mov	r30, r0
   120d2:	09 94       	ijmp
	 case mmInitMaster:
	      lcd_clear();
   120d4:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
		  lcd_printf(1,1,PSTR("-System Admin Level-"));
   120d8:	81 e0       	ldi	r24, 0x01	; 1
   120da:	61 e0       	ldi	r22, 0x01	; 1
   120dc:	45 ed       	ldi	r20, 0xD5	; 213
   120de:	57 e1       	ldi	r21, 0x17	; 23
   120e0:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		  lcd_printf(2,1,PSTR("1.Restore Password  "));
   120e4:	82 e0       	ldi	r24, 0x02	; 2
   120e6:	61 e0       	ldi	r22, 0x01	; 1
   120e8:	40 ec       	ldi	r20, 0xC0	; 192
   120ea:	57 e1       	ldi	r21, 0x17	; 23
   120ec:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		  lcd_printf(3,1,PSTR("2.Change Password   "));
   120f0:	83 e0       	ldi	r24, 0x03	; 3
   120f2:	61 e0       	ldi	r22, 0x01	; 1
   120f4:	4b ea       	ldi	r20, 0xAB	; 171
   120f6:	57 e1       	ldi	r21, 0x17	; 23
   120f8:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		  lcd_printf(4,1,PSTR("[*]Exit             "));
   120fc:	84 e0       	ldi	r24, 0x04	; 4
   120fe:	61 e0       	ldi	r22, 0x01	; 1
   12100:	46 e9       	ldi	r20, 0x96	; 150
   12102:	57 e1       	ldi	r21, 0x17	; 23
   12104:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>

		  //_uart_printf(1,1,PSTR("-System Admin Level-"));

		  stMenuMaster=mmMasterSelect;
   12108:	81 e0       	ldi	r24, 0x01	; 1
   1210a:	f3 c0       	rjmp	.+486    	; 0x122f2 <FMenuMaster+0x25a>
	      break;
     case mmMasterSelect:
	 	  KeyPressed=_key_scan(1);
   1210c:	81 e0       	ldi	r24, 0x01	; 1
   1210e:	0e 94 84 ae 	call	0x15d08	; 0x15d08 <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
   12112:	0e 94 e5 ad 	call	0x15bca	; 0x15bca <_key_btn>
          switch(KeyChar){
   12116:	81 33       	cpi	r24, 0x31	; 49
   12118:	09 f4       	brne	.+2      	; 0x1211c <FMenuMaster+0x84>
   1211a:	ea c0       	rjmp	.+468    	; 0x122f0 <FMenuMaster+0x258>
   1211c:	82 33       	cpi	r24, 0x32	; 50
   1211e:	21 f0       	breq	.+8      	; 0x12128 <FMenuMaster+0x90>
   12120:	8a 32       	cpi	r24, 0x2A	; 42
   12122:	09 f0       	breq	.+2      	; 0x12126 <FMenuMaster+0x8e>
   12124:	bc c1       	rjmp	.+888    	; 0x1249e <FMenuMaster+0x406>
   12126:	b5 c1       	rjmp	.+874    	; 0x12492 <FMenuMaster+0x3fa>
		  case '1':
               stMenuMaster=mmRestorePasswordMenu;
		       break;
		  case '2':
		       stMenuMaster=mmChangePassword;
   12128:	8e e0       	ldi	r24, 0x0E	; 14
   1212a:	e3 c0       	rjmp	.+454    	; 0x122f2 <FMenuMaster+0x25a>
		       stMenuMaster=mmExitMaster;
		       break;
		  }
	      break;
     case mmChangePassword:
	      stMenuMaster=mmInitMaster;
   1212c:	10 92 9d 02 	sts	0x029D, r1
   12130:	b6 c1       	rjmp	.+876    	; 0x1249e <FMenuMaster+0x406>
	      break;
     case mmRestorePasswordMenu:	      
	      lcd_clear();
   12132:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
		  lcd_printf(1,1,PSTR("Enter GeNiUs Code   "));
   12136:	81 e0       	ldi	r24, 0x01	; 1
   12138:	61 e0       	ldi	r22, 0x01	; 1
   1213a:	41 e8       	ldi	r20, 0x81	; 129
   1213c:	57 e1       	ldi	r21, 0x17	; 23
   1213e:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		  lcd_printf(2,1,PSTR("_                   "));
   12142:	82 e0       	ldi	r24, 0x02	; 2
   12144:	61 e0       	ldi	r22, 0x01	; 1
   12146:	4c e6       	ldi	r20, 0x6C	; 108
   12148:	57 e1       	ldi	r21, 0x17	; 23
   1214a:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		  lcd_printf(4,4,PSTR("[*]Cancel   [#]Enter"));
   1214e:	84 e0       	ldi	r24, 0x04	; 4
   12150:	64 e0       	ldi	r22, 0x04	; 4
   12152:	47 e5       	ldi	r20, 0x57	; 87
   12154:	57 e1       	ldi	r21, 0x17	; 23
   12156:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		  sprintf_P(strGeniusCode,PSTR(""));
   1215a:	00 d0       	rcall	.+0      	; 0x1215c <FMenuMaster+0xc4>
   1215c:	00 d0       	rcall	.+0      	; 0x1215e <FMenuMaster+0xc6>
   1215e:	84 ea       	ldi	r24, 0xA4	; 164
   12160:	96 e0       	ldi	r25, 0x06	; 6
   12162:	ad b7       	in	r26, 0x3d	; 61
   12164:	be b7       	in	r27, 0x3e	; 62
   12166:	12 96       	adiw	r26, 0x02	; 2
   12168:	9c 93       	st	X, r25
   1216a:	8e 93       	st	-X, r24
   1216c:	11 97       	sbiw	r26, 0x01	; 1
   1216e:	86 e5       	ldi	r24, 0x56	; 86
   12170:	97 e1       	ldi	r25, 0x17	; 23
   12172:	14 96       	adiw	r26, 0x04	; 4
   12174:	9c 93       	st	X, r25
   12176:	8e 93       	st	-X, r24
   12178:	13 97       	sbiw	r26, 0x03	; 3
   1217a:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
          stMenuMaster=mmGeniusCodeEntry;
   1217e:	83 e0       	ldi	r24, 0x03	; 3
   12180:	80 93 9d 02 	sts	0x029D, r24
   12184:	80 e0       	ldi	r24, 0x00	; 0
   12186:	0f 90       	pop	r0
   12188:	0f 90       	pop	r0
   1218a:	0f 90       	pop	r0
   1218c:	0f 90       	pop	r0
   1218e:	88 c1       	rjmp	.+784    	; 0x124a0 <FMenuMaster+0x408>
	      break;
     case mmGeniusCodeEntry:
	 	  uiResult=UserInput(UI_NUMBER_R,2,1,strGeniusCode,0,10);
   12190:	81 e0       	ldi	r24, 0x01	; 1
   12192:	62 e0       	ldi	r22, 0x02	; 2
   12194:	41 e0       	ldi	r20, 0x01	; 1
   12196:	24 ea       	ldi	r18, 0xA4	; 164
   12198:	36 e0       	ldi	r19, 0x06	; 6
   1219a:	00 e0       	ldi	r16, 0x00	; 0
   1219c:	10 e0       	ldi	r17, 0x00	; 0
   1219e:	fa e0       	ldi	r31, 0x0A	; 10
   121a0:	ef 2e       	mov	r14, r31
   121a2:	0e 94 d8 7d 	call	0xfbb0	; 0xfbb0 <UserInput>
		  switch(uiResult){
   121a6:	83 30       	cpi	r24, 0x03	; 3
   121a8:	49 f0       	breq	.+18     	; 0x121bc <FMenuMaster+0x124>
   121aa:	84 30       	cpi	r24, 0x04	; 4
   121ac:	08 f4       	brcc	.+2      	; 0x121b0 <FMenuMaster+0x118>
   121ae:	ef c0       	rjmp	.+478    	; 0x1238e <FMenuMaster+0x2f6>
   121b0:	84 30       	cpi	r24, 0x04	; 4
   121b2:	69 f0       	breq	.+26     	; 0x121ce <FMenuMaster+0x136>
   121b4:	85 30       	cpi	r24, 0x05	; 5
   121b6:	09 f0       	breq	.+2      	; 0x121ba <FMenuMaster+0x122>
   121b8:	72 c1       	rjmp	.+740    	; 0x1249e <FMenuMaster+0x406>
   121ba:	0e c0       	rjmp	.+28     	; 0x121d8 <FMenuMaster+0x140>
		  case USER_OK:
               
			   //_uart_printf(1,0,PSTR("GeniusCode: "));
			   //_uart_print(1,1,strGeniusCode);

		       _datetime(0, strSystemDate, strSystemTime);
   121bc:	80 e0       	ldi	r24, 0x00	; 0
   121be:	69 ec       	ldi	r22, 0xC9	; 201
   121c0:	74 e0       	ldi	r23, 0x04	; 4
   121c2:	48 ea       	ldi	r20, 0xA8	; 168
   121c4:	59 e0       	ldi	r21, 0x09	; 9
   121c6:	0e 94 4f b1 	call	0x1629e	; 0x1629e <_datetime>
               stMenuMaster=mmIsValidGeniusCode;
   121ca:	84 e0       	ldi	r24, 0x04	; 4
   121cc:	92 c0       	rjmp	.+292    	; 0x122f2 <FMenuMaster+0x25a>
		       break;
          case USER_CANCEL:
		       stMenuMaster=mmExitMaster;
		       break;
		  case USER_ENTRY:
		       lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   121ce:	84 e0       	ldi	r24, 0x04	; 4
   121d0:	61 e0       	ldi	r22, 0x01	; 1
   121d2:	41 e4       	ldi	r20, 0x41	; 65
   121d4:	57 e1       	ldi	r21, 0x17	; 23
   121d6:	f0 c0       	rjmp	.+480    	; 0x123b8 <FMenuMaster+0x320>
		       break;
          case USER_NO_DATA:
		       lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   121d8:	84 e0       	ldi	r24, 0x04	; 4
   121da:	61 e0       	ldi	r22, 0x01	; 1
   121dc:	4c e2       	ldi	r20, 0x2C	; 44
   121de:	57 e1       	ldi	r21, 0x17	; 23
   121e0:	eb c0       	rjmp	.+470    	; 0x123b8 <FMenuMaster+0x320>
		       break;
		  }
	      break;
     case mmIsValidGeniusCode:
	      //GetDate
		      sprintf_P(PDate,PSTR("%s"),strSystemDate);
   121e2:	00 d0       	rcall	.+0      	; 0x121e4 <FMenuMaster+0x14c>
   121e4:	00 d0       	rcall	.+0      	; 0x121e6 <FMenuMaster+0x14e>
   121e6:	00 d0       	rcall	.+0      	; 0x121e8 <FMenuMaster+0x150>
   121e8:	ed b7       	in	r30, 0x3d	; 61
   121ea:	fe b7       	in	r31, 0x3e	; 62
   121ec:	31 96       	adiw	r30, 0x01	; 1
   121ee:	8e 01       	movw	r16, r28
   121f0:	05 5f       	subi	r16, 0xF5	; 245
   121f2:	1f 4f       	sbci	r17, 0xFF	; 255
   121f4:	ad b7       	in	r26, 0x3d	; 61
   121f6:	be b7       	in	r27, 0x3e	; 62
   121f8:	12 96       	adiw	r26, 0x02	; 2
   121fa:	1c 93       	st	X, r17
   121fc:	0e 93       	st	-X, r16
   121fe:	11 97       	sbiw	r26, 0x01	; 1
   12200:	89 e2       	ldi	r24, 0x29	; 41
   12202:	97 e1       	ldi	r25, 0x17	; 23
   12204:	93 83       	std	Z+3, r25	; 0x03
   12206:	82 83       	std	Z+2, r24	; 0x02
   12208:	89 ec       	ldi	r24, 0xC9	; 201
   1220a:	94 e0       	ldi	r25, 0x04	; 4
   1220c:	95 83       	std	Z+5, r25	; 0x05
   1220e:	84 83       	std	Z+4, r24	; 0x04
   12210:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
			  RemoveChar(PDate,'/');
   12214:	ed b7       	in	r30, 0x3d	; 61
   12216:	fe b7       	in	r31, 0x3e	; 62
   12218:	36 96       	adiw	r30, 0x06	; 6
   1221a:	0f b6       	in	r0, 0x3f	; 63
   1221c:	f8 94       	cli
   1221e:	fe bf       	out	0x3e, r31	; 62
   12220:	0f be       	out	0x3f, r0	; 63
   12222:	ed bf       	out	0x3d, r30	; 61
   12224:	c8 01       	movw	r24, r16
   12226:	6f e2       	ldi	r22, 0x2F	; 47
   12228:	0e 94 7a 30 	call	0x60f4	; 0x60f4 <RemoveChar>
		  if (ValidateGeniusCode(PDate,strGeniusCode)==GC_VALID){
   1222c:	c8 01       	movw	r24, r16
   1222e:	64 ea       	ldi	r22, 0xA4	; 164
   12230:	76 e0       	ldi	r23, 0x06	; 6
   12232:	0e 94 ad 6a 	call	0xd55a	; 0xd55a <ValidateGeniusCode>
   12236:	81 30       	cpi	r24, 0x01	; 1
   12238:	09 f0       	breq	.+2      	; 0x1223c <FMenuMaster+0x1a4>
   1223a:	44 c0       	rjmp	.+136    	; 0x122c4 <FMenuMaster+0x22c>

		  	  sprintf_P(PTime,PSTR("%s"),strSystemTime);
   1223c:	00 d0       	rcall	.+0      	; 0x1223e <FMenuMaster+0x1a6>
   1223e:	00 d0       	rcall	.+0      	; 0x12240 <FMenuMaster+0x1a8>
   12240:	00 d0       	rcall	.+0      	; 0x12242 <FMenuMaster+0x1aa>
   12242:	ed b7       	in	r30, 0x3d	; 61
   12244:	fe b7       	in	r31, 0x3e	; 62
   12246:	31 96       	adiw	r30, 0x01	; 1
   12248:	8e 01       	movw	r16, r28
   1224a:	0f 5f       	subi	r16, 0xFF	; 255
   1224c:	1f 4f       	sbci	r17, 0xFF	; 255
   1224e:	ad b7       	in	r26, 0x3d	; 61
   12250:	be b7       	in	r27, 0x3e	; 62
   12252:	12 96       	adiw	r26, 0x02	; 2
   12254:	1c 93       	st	X, r17
   12256:	0e 93       	st	-X, r16
   12258:	11 97       	sbiw	r26, 0x01	; 1
   1225a:	86 e2       	ldi	r24, 0x26	; 38
   1225c:	97 e1       	ldi	r25, 0x17	; 23
   1225e:	93 83       	std	Z+3, r25	; 0x03
   12260:	82 83       	std	Z+2, r24	; 0x02
   12262:	88 ea       	ldi	r24, 0xA8	; 168
   12264:	99 e0       	ldi	r25, 0x09	; 9
   12266:	95 83       	std	Z+5, r25	; 0x05
   12268:	84 83       	std	Z+4, r24	; 0x04
   1226a:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
			  RemoveChar(PTime,':');sprintf_P(strKeyStamp,PSTR(""));
   1226e:	ed b7       	in	r30, 0x3d	; 61
   12270:	fe b7       	in	r31, 0x3e	; 62
   12272:	36 96       	adiw	r30, 0x06	; 6
   12274:	0f b6       	in	r0, 0x3f	; 63
   12276:	f8 94       	cli
   12278:	fe bf       	out	0x3e, r31	; 62
   1227a:	0f be       	out	0x3f, r0	; 63
   1227c:	ed bf       	out	0x3d, r30	; 61
   1227e:	c8 01       	movw	r24, r16
   12280:	6a e3       	ldi	r22, 0x3A	; 58
   12282:	0e 94 7a 30 	call	0x60f4	; 0x60f4 <RemoveChar>
   12286:	00 d0       	rcall	.+0      	; 0x12288 <FMenuMaster+0x1f0>
   12288:	00 d0       	rcall	.+0      	; 0x1228a <FMenuMaster+0x1f2>
   1228a:	e2 ee       	ldi	r30, 0xE2	; 226
   1228c:	ee 2e       	mov	r14, r30
   1228e:	e8 e0       	ldi	r30, 0x08	; 8
   12290:	fe 2e       	mov	r15, r30
   12292:	ad b7       	in	r26, 0x3d	; 61
   12294:	be b7       	in	r27, 0x3e	; 62
   12296:	12 96       	adiw	r26, 0x02	; 2
   12298:	fc 92       	st	X, r15
   1229a:	ee 92       	st	-X, r14
   1229c:	11 97       	sbiw	r26, 0x01	; 1
   1229e:	85 e2       	ldi	r24, 0x25	; 37
   122a0:	97 e1       	ldi	r25, 0x17	; 23
   122a2:	14 96       	adiw	r26, 0x04	; 4
   122a4:	9c 93       	st	X, r25
   122a6:	8e 93       	st	-X, r24
   122a8:	13 97       	sbiw	r26, 0x03	; 3
   122aa:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>

              //sprintf_P(strSend,PSTR("Time:%s"),PTime);
			  // _uart_print(1,1,strSend);

		      GenerateKeyStamp(PTime,strGeniusCode,strKeyStamp);			  
   122ae:	0f 90       	pop	r0
   122b0:	0f 90       	pop	r0
   122b2:	0f 90       	pop	r0
   122b4:	0f 90       	pop	r0
   122b6:	c8 01       	movw	r24, r16
   122b8:	64 ea       	ldi	r22, 0xA4	; 164
   122ba:	76 e0       	ldi	r23, 0x06	; 6
   122bc:	a7 01       	movw	r20, r14
   122be:	0e 94 3b 31 	call	0x6276	; 0x6276 <GenerateKeyStamp>
   122c2:	d2 c0       	rjmp	.+420    	; 0x12468 <FMenuMaster+0x3d0>
			  stMenuMaster=mmDisplayKeyStamp;
		  }else stMenuMaster=mmDisplayInvalidCode;
   122c4:	85 e0       	ldi	r24, 0x05	; 5
   122c6:	15 c0       	rjmp	.+42     	; 0x122f2 <FMenuMaster+0x25a>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   122c8:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   122ca:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   122cc:	81 e0       	ldi	r24, 0x01	; 1
   122ce:	80 93 bf 01 	sts	0x01BF, r24
			  stMenuMaster=mmDisplayKeyStamp;
		  }else stMenuMaster=mmDisplayInvalidCode;
	      break;
     case mmDisplayInvalidCode:
	      system_beep(1);
          lcd_printf(3,1,PSTR("Invalid Code        "));
   122d2:	83 e0       	ldi	r24, 0x03	; 3
   122d4:	61 e0       	ldi	r22, 0x01	; 1
   122d6:	40 e1       	ldi	r20, 0x10	; 16
   122d8:	57 e1       	ldi	r21, 0x17	; 23
   122da:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
          TimDisplay=0; 
   122de:	10 92 95 01 	sts	0x0195, r1
		  stMenuMaster=mmDelayDisplayInvalidCode;
   122e2:	86 e0       	ldi	r24, 0x06	; 6
   122e4:	06 c0       	rjmp	.+12     	; 0x122f2 <FMenuMaster+0x25a>
	      break;
     case mmDelayDisplayInvalidCode:
	      if (TimDisplay>5)stMenuMaster=mmRestorePasswordMenu;
   122e6:	80 91 95 01 	lds	r24, 0x0195
   122ea:	86 30       	cpi	r24, 0x06	; 6
   122ec:	08 f4       	brcc	.+2      	; 0x122f0 <FMenuMaster+0x258>
   122ee:	d7 c0       	rjmp	.+430    	; 0x1249e <FMenuMaster+0x406>
   122f0:	82 e0       	ldi	r24, 0x02	; 2
   122f2:	80 93 9d 02 	sts	0x029D, r24
   122f6:	d3 c0       	rjmp	.+422    	; 0x1249e <FMenuMaster+0x406>
	      break;
     case mmDisplayKeyStamp:
	      lcd_clear();
   122f8:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
		  sprintf_P(lcdteks,PSTR("Key Stamp:%s "),strKeyStamp);
   122fc:	00 d0       	rcall	.+0      	; 0x122fe <FMenuMaster+0x266>
   122fe:	00 d0       	rcall	.+0      	; 0x12300 <FMenuMaster+0x268>
   12300:	00 d0       	rcall	.+0      	; 0x12302 <FMenuMaster+0x26a>
   12302:	ed b7       	in	r30, 0x3d	; 61
   12304:	fe b7       	in	r31, 0x3e	; 62
   12306:	31 96       	adiw	r30, 0x01	; 1
   12308:	8e 01       	movw	r16, r28
   1230a:	01 5e       	subi	r16, 0xE1	; 225
   1230c:	1f 4f       	sbci	r17, 0xFF	; 255
   1230e:	ad b7       	in	r26, 0x3d	; 61
   12310:	be b7       	in	r27, 0x3e	; 62
   12312:	12 96       	adiw	r26, 0x02	; 2
   12314:	1c 93       	st	X, r17
   12316:	0e 93       	st	-X, r16
   12318:	11 97       	sbiw	r26, 0x01	; 1
   1231a:	82 e0       	ldi	r24, 0x02	; 2
   1231c:	97 e1       	ldi	r25, 0x17	; 23
   1231e:	93 83       	std	Z+3, r25	; 0x03
   12320:	82 83       	std	Z+2, r24	; 0x02
   12322:	82 ee       	ldi	r24, 0xE2	; 226
   12324:	98 e0       	ldi	r25, 0x08	; 8
   12326:	95 83       	std	Z+5, r25	; 0x05
   12328:	84 83       	std	Z+4, r24	; 0x04
   1232a:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
		  lcd_print(1,1,lcdteks);
   1232e:	ed b7       	in	r30, 0x3d	; 61
   12330:	fe b7       	in	r31, 0x3e	; 62
   12332:	36 96       	adiw	r30, 0x06	; 6
   12334:	0f b6       	in	r0, 0x3f	; 63
   12336:	f8 94       	cli
   12338:	fe bf       	out	0x3e, r31	; 62
   1233a:	0f be       	out	0x3f, r0	; 63
   1233c:	ed bf       	out	0x3d, r30	; 61
   1233e:	81 e0       	ldi	r24, 0x01	; 1
   12340:	61 e0       	ldi	r22, 0x01	; 1
   12342:	a8 01       	movw	r20, r16
   12344:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
		  lcd_printf(2,1,PSTR("Enter Restore Code  "));
   12348:	82 e0       	ldi	r24, 0x02	; 2
   1234a:	61 e0       	ldi	r22, 0x01	; 1
   1234c:	4d ee       	ldi	r20, 0xED	; 237
   1234e:	56 e1       	ldi	r21, 0x16	; 22
   12350:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		  lcd_printf(3,1,PSTR("_                   "));
   12354:	83 e0       	ldi	r24, 0x03	; 3
   12356:	61 e0       	ldi	r22, 0x01	; 1
   12358:	48 ed       	ldi	r20, 0xD8	; 216
   1235a:	56 e1       	ldi	r21, 0x16	; 22
   1235c:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		  lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   12360:	84 e0       	ldi	r24, 0x04	; 4
   12362:	61 e0       	ldi	r22, 0x01	; 1
   12364:	43 ec       	ldi	r20, 0xC3	; 195
   12366:	56 e1       	ldi	r21, 0x16	; 22
   12368:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
          stMenuMaster=mmRestoreCodeEntry;
   1236c:	88 e0       	ldi	r24, 0x08	; 8
   1236e:	c1 cf       	rjmp	.-126    	; 0x122f2 <FMenuMaster+0x25a>
	      break;
     case mmRestoreCodeEntry:
	 	  uiResult=UserInput(UI_NUMBER_R,3,1,strRestoreCode,0,10);
   12370:	81 e0       	ldi	r24, 0x01	; 1
   12372:	63 e0       	ldi	r22, 0x03	; 3
   12374:	41 e0       	ldi	r20, 0x01	; 1
   12376:	22 e9       	ldi	r18, 0x92	; 146
   12378:	3d e0       	ldi	r19, 0x0D	; 13
   1237a:	00 e0       	ldi	r16, 0x00	; 0
   1237c:	10 e0       	ldi	r17, 0x00	; 0
   1237e:	7a e0       	ldi	r23, 0x0A	; 10
   12380:	e7 2e       	mov	r14, r23
   12382:	0e 94 d8 7d 	call	0xfbb0	; 0xfbb0 <UserInput>
		  switch(uiResult){
   12386:	83 30       	cpi	r24, 0x03	; 3
   12388:	61 f0       	breq	.+24     	; 0x123a2 <FMenuMaster+0x30a>
   1238a:	84 30       	cpi	r24, 0x04	; 4
   1238c:	20 f4       	brcc	.+8      	; 0x12396 <FMenuMaster+0x2fe>
   1238e:	81 30       	cpi	r24, 0x01	; 1
   12390:	09 f0       	breq	.+2      	; 0x12394 <FMenuMaster+0x2fc>
   12392:	85 c0       	rjmp	.+266    	; 0x1249e <FMenuMaster+0x406>
   12394:	7e c0       	rjmp	.+252    	; 0x12492 <FMenuMaster+0x3fa>
   12396:	84 30       	cpi	r24, 0x04	; 4
   12398:	31 f0       	breq	.+12     	; 0x123a6 <FMenuMaster+0x30e>
   1239a:	85 30       	cpi	r24, 0x05	; 5
   1239c:	09 f0       	breq	.+2      	; 0x123a0 <FMenuMaster+0x308>
   1239e:	7f c0       	rjmp	.+254    	; 0x1249e <FMenuMaster+0x406>
   123a0:	07 c0       	rjmp	.+14     	; 0x123b0 <FMenuMaster+0x318>
		  case USER_OK:
               stMenuMaster=mmIsValidRestoreCode;
   123a2:	89 e0       	ldi	r24, 0x09	; 9
   123a4:	a6 cf       	rjmp	.-180    	; 0x122f2 <FMenuMaster+0x25a>
		       break;
          case USER_CANCEL:
		       stMenuMaster=mmExitMaster;
		       break;
		  case USER_ENTRY:
		       lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   123a6:	84 e0       	ldi	r24, 0x04	; 4
   123a8:	61 e0       	ldi	r22, 0x01	; 1
   123aa:	4e ea       	ldi	r20, 0xAE	; 174
   123ac:	56 e1       	ldi	r21, 0x16	; 22
   123ae:	04 c0       	rjmp	.+8      	; 0x123b8 <FMenuMaster+0x320>
		       break;
          case USER_NO_DATA:
		       lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   123b0:	84 e0       	ldi	r24, 0x04	; 4
   123b2:	61 e0       	ldi	r22, 0x01	; 1
   123b4:	49 e9       	ldi	r20, 0x99	; 153
   123b6:	56 e1       	ldi	r21, 0x16	; 22
   123b8:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
   123bc:	70 c0       	rjmp	.+224    	; 0x1249e <FMenuMaster+0x406>
		       break;
		  }
	      break;
     case mmIsValidRestoreCode:
	      if (ValidateRestoreCode(strKeyStamp,strRestoreCode)==RC_VALID){
   123be:	82 ee       	ldi	r24, 0xE2	; 226
   123c0:	98 e0       	ldi	r25, 0x08	; 8
   123c2:	62 e9       	ldi	r22, 0x92	; 146
   123c4:	7d e0       	ldi	r23, 0x0D	; 13
   123c6:	0e 94 8b 6a 	call	0xd516	; 0xd516 <ValidateRestoreCode>
   123ca:	81 30       	cpi	r24, 0x01	; 1
   123cc:	11 f4       	brne	.+4      	; 0x123d2 <FMenuMaster+0x33a>
		      stMenuMaster=mmRestorePassword;
   123ce:	8c e0       	ldi	r24, 0x0C	; 12
   123d0:	90 cf       	rjmp	.-224    	; 0x122f2 <FMenuMaster+0x25a>
		  }else stMenuMaster=mmDisplayInvalidRestoreCode;
   123d2:	8a e0       	ldi	r24, 0x0A	; 10
   123d4:	8e cf       	rjmp	.-228    	; 0x122f2 <FMenuMaster+0x25a>
	      break;
     case mmRestorePassword:
	      sprintf_P(strNewPassword,PSTR(SPV_DEFAULT_PASS));
   123d6:	00 d0       	rcall	.+0      	; 0x123d8 <FMenuMaster+0x340>
   123d8:	00 d0       	rcall	.+0      	; 0x123da <FMenuMaster+0x342>
   123da:	8e 01       	movw	r16, r28
   123dc:	0b 5e       	subi	r16, 0xEB	; 235
   123de:	1f 4f       	sbci	r17, 0xFF	; 255
   123e0:	ad b7       	in	r26, 0x3d	; 61
   123e2:	be b7       	in	r27, 0x3e	; 62
   123e4:	12 96       	adiw	r26, 0x02	; 2
   123e6:	1c 93       	st	X, r17
   123e8:	0e 93       	st	-X, r16
   123ea:	11 97       	sbiw	r26, 0x01	; 1
   123ec:	83 e9       	ldi	r24, 0x93	; 147
   123ee:	96 e1       	ldi	r25, 0x16	; 22
   123f0:	14 96       	adiw	r26, 0x04	; 4
   123f2:	9c 93       	st	X, r25
   123f4:	8e 93       	st	-X, r24
   123f6:	13 97       	sbiw	r26, 0x03	; 3
   123f8:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
   123fc:	0f 90       	pop	r0
   123fe:	0f 90       	pop	r0
   12400:	0f 90       	pop	r0
   12402:	0f 90       	pop	r0
   12404:	81 e0       	ldi	r24, 0x01	; 1
   12406:	90 e0       	ldi	r25, 0x00	; 0
   12408:	b8 01       	movw	r22, r16
   1240a:	4a e0       	ldi	r20, 0x0A	; 10
   1240c:	50 e0       	ldi	r21, 0x00	; 0
   1240e:	25 e0       	ldi	r18, 0x05	; 5
   12410:	33 e1       	ldi	r19, 0x13	; 19
   12412:	0e 94 0d b4 	call	0x1681a	; 0x1681a <__eewr_block>
		  eeprom_write_block((const void*) &strNewPassword,(void*) &DefSpvPassword,sizeof(DefSpvPassword));
		  sprintf_P(strNewPassword,PSTR(SYS_DEFAULT_PASS));
   12416:	00 d0       	rcall	.+0      	; 0x12418 <FMenuMaster+0x380>
   12418:	00 d0       	rcall	.+0      	; 0x1241a <FMenuMaster+0x382>
   1241a:	ed b7       	in	r30, 0x3d	; 61
   1241c:	fe b7       	in	r31, 0x3e	; 62
   1241e:	12 83       	std	Z+2, r17	; 0x02
   12420:	01 83       	std	Z+1, r16	; 0x01
   12422:	8d e8       	ldi	r24, 0x8D	; 141
   12424:	96 e1       	ldi	r25, 0x16	; 22
   12426:	94 83       	std	Z+4, r25	; 0x04
   12428:	83 83       	std	Z+3, r24	; 0x03
   1242a:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
   1242e:	0f 90       	pop	r0
   12430:	0f 90       	pop	r0
   12432:	0f 90       	pop	r0
   12434:	0f 90       	pop	r0
   12436:	8b e0       	ldi	r24, 0x0B	; 11
   12438:	90 e0       	ldi	r25, 0x00	; 0
   1243a:	b8 01       	movw	r22, r16
   1243c:	4a e0       	ldi	r20, 0x0A	; 10
   1243e:	50 e0       	ldi	r21, 0x00	; 0
   12440:	25 e0       	ldi	r18, 0x05	; 5
   12442:	33 e1       	ldi	r19, 0x13	; 19
   12444:	0e 94 0d b4 	call	0x1681a	; 0x1681a <__eewr_block>
		  eeprom_write_block((const void*) &strNewPassword,(void*) &DefSysPassword,sizeof(DefSysPassword));	      		  
	      stMenuMaster=mmDisplaySuccess;
   12448:	8d e0       	ldi	r24, 0x0D	; 13
   1244a:	53 cf       	rjmp	.-346    	; 0x122f2 <FMenuMaster+0x25a>
	      break;
     case mmDisplayInvalidRestoreCode:
	      lcd_printf(3,1,PSTR("Invalid Restore  "));
   1244c:	83 e0       	ldi	r24, 0x03	; 3
   1244e:	61 e0       	ldi	r22, 0x01	; 1
   12450:	4b e7       	ldi	r20, 0x7B	; 123
   12452:	56 e1       	ldi	r21, 0x16	; 22
   12454:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		  TimDisplay=0;
   12458:	10 92 95 01 	sts	0x0195, r1
          stMenuMaster=mmDelayInvalidRestoreCode;
   1245c:	8b e0       	ldi	r24, 0x0B	; 11
   1245e:	49 cf       	rjmp	.-366    	; 0x122f2 <FMenuMaster+0x25a>
	      break;
     case mmDelayInvalidRestoreCode:
	      if (TimDisplay>5)stMenuMaster=mmDisplayKeyStamp;
   12460:	80 91 95 01 	lds	r24, 0x0195
   12464:	86 30       	cpi	r24, 0x06	; 6
   12466:	d8 f0       	brcs	.+54     	; 0x1249e <FMenuMaster+0x406>
   12468:	87 e0       	ldi	r24, 0x07	; 7
   1246a:	43 cf       	rjmp	.-378    	; 0x122f2 <FMenuMaster+0x25a>
	      break;
     case mmDisplaySuccess:
	      //lcd_clear();
		  lcd_printf(3,1,PSTR("Password Restored"));
   1246c:	83 e0       	ldi	r24, 0x03	; 3
   1246e:	61 e0       	ldi	r22, 0x01	; 1
   12470:	49 e6       	ldi	r20, 0x69	; 105
   12472:	56 e1       	ldi	r21, 0x16	; 22
   12474:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   12478:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   1247a:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   1247c:	81 e0       	ldi	r24, 0x01	; 1
   1247e:	80 93 bf 01 	sts	0x01BF, r24
	      break;
     case mmDisplaySuccess:
	      //lcd_clear();
		  lcd_printf(3,1,PSTR("Password Restored"));
		  system_beep(1);
		  TimDisplay=0;
   12482:	10 92 95 01 	sts	0x0195, r1
          stMenuMaster=mmDelayExit;
   12486:	8f e0       	ldi	r24, 0x0F	; 15
   12488:	34 cf       	rjmp	.-408    	; 0x122f2 <FMenuMaster+0x25a>
	      break;
     case mmDelayExit:
	      if (TimDisplay>=5)stMenuMaster=mmExitMaster;
   1248a:	80 91 95 01 	lds	r24, 0x0195
   1248e:	85 30       	cpi	r24, 0x05	; 5
   12490:	30 f0       	brcs	.+12     	; 0x1249e <FMenuMaster+0x406>
   12492:	80 e1       	ldi	r24, 0x10	; 16
   12494:	2e cf       	rjmp	.-420    	; 0x122f2 <FMenuMaster+0x25a>
	      break;
     case mmExitMaster:
	      stMenuMaster=mmInitMaster;
   12496:	10 92 9d 02 	sts	0x029D, r1
   1249a:	81 e0       	ldi	r24, 0x01	; 1
   1249c:	01 c0       	rjmp	.+2      	; 0x124a0 <FMenuMaster+0x408>
   1249e:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
  return Result;

}
   124a0:	e2 96       	adiw	r28, 0x32	; 50
   124a2:	0f b6       	in	r0, 0x3f	; 63
   124a4:	f8 94       	cli
   124a6:	de bf       	out	0x3e, r29	; 62
   124a8:	0f be       	out	0x3f, r0	; 63
   124aa:	cd bf       	out	0x3d, r28	; 61
   124ac:	cf 91       	pop	r28
   124ae:	df 91       	pop	r29
   124b0:	1f 91       	pop	r17
   124b2:	0f 91       	pop	r16
   124b4:	ff 90       	pop	r15
   124b6:	ef 90       	pop	r14
   124b8:	08 95       	ret

000124ba <FMenuPassword>:
   return Result;	 
}



char FMenuPassword(){
   124ba:	af 92       	push	r10
   124bc:	bf 92       	push	r11
   124be:	cf 92       	push	r12
   124c0:	df 92       	push	r13
   124c2:	ef 92       	push	r14
   124c4:	0f 93       	push	r16
   124c6:	1f 93       	push	r17
   124c8:	df 93       	push	r29
   124ca:	cf 93       	push	r28
   124cc:	cd b7       	in	r28, 0x3d	; 61
   124ce:	de b7       	in	r29, 0x3e	; 62
   124d0:	6e 97       	sbiw	r28, 0x1e	; 30
   124d2:	0f b6       	in	r0, 0x3f	; 63
   124d4:	f8 94       	cli
   124d6:	de bf       	out	0x3e, r29	; 62
   124d8:	0f be       	out	0x3f, r0	; 63
   124da:	cd bf       	out	0x3d, r28	; 61
static char stMenuPasword=mpInitPassword,uiResult,strPassword[10],PassStatus=MP_NONE;;
char Result=MP_NONE,strMasterPass[10],strSystemPass[10],strAdminPass[10];

     Result=MP_NONE;
     switch(stMenuPasword){
   124dc:	e0 90 aa 02 	lds	r14, 0x02AA
   124e0:	81 e0       	ldi	r24, 0x01	; 1
   124e2:	e8 16       	cp	r14, r24
   124e4:	09 f1       	breq	.+66     	; 0x12528 <FMenuPassword+0x6e>
   124e6:	e8 16       	cp	r14, r24
   124e8:	48 f0       	brcs	.+18     	; 0x124fc <FMenuPassword+0x42>
   124ea:	e2 e0       	ldi	r30, 0x02	; 2
   124ec:	ee 16       	cp	r14, r30
   124ee:	09 f4       	brne	.+2      	; 0x124f2 <FMenuPassword+0x38>
   124f0:	3f c0       	rjmp	.+126    	; 0x12570 <FMenuPassword+0xb6>
   124f2:	f3 e0       	ldi	r31, 0x03	; 3
   124f4:	ef 16       	cp	r14, r31
   124f6:	09 f0       	breq	.+2      	; 0x124fa <FMenuPassword+0x40>
   124f8:	92 c0       	rjmp	.+292    	; 0x1261e <FMenuPassword+0x164>
   124fa:	8c c0       	rjmp	.+280    	; 0x12614 <FMenuPassword+0x15a>
	 case mpInitPassword:
	      lcd_clear();
   124fc:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
		  lcd_printf(1,1,PSTR("PASSWORD:"));
   12500:	81 e0       	ldi	r24, 0x01	; 1
   12502:	61 e0       	ldi	r22, 0x01	; 1
   12504:	46 e4       	ldi	r20, 0x46	; 70
   12506:	58 e1       	ldi	r21, 0x18	; 24
   12508:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		  lcd_printf(2,1,PSTR("_"));
   1250c:	82 e0       	ldi	r24, 0x02	; 2
   1250e:	61 e0       	ldi	r22, 0x01	; 1
   12510:	44 e4       	ldi	r20, 0x44	; 68
   12512:	58 e1       	ldi	r21, 0x18	; 24
   12514:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		  lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   12518:	84 e0       	ldi	r24, 0x04	; 4
   1251a:	61 e0       	ldi	r22, 0x01	; 1
   1251c:	4f e2       	ldi	r20, 0x2F	; 47
   1251e:	58 e1       	ldi	r21, 0x18	; 24
   12520:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		  FillChar(strPassword,0,sizeof(strPassword));
		  stMenuPasword=mpInputPasword;
   12524:	81 e0       	ldi	r24, 0x01	; 1
   12526:	73 c0       	rjmp	.+230    	; 0x1260e <FMenuPassword+0x154>
	      break;
     case mpInputPasword:
	 	      uiResult=UserInput(UI_NUM_PASSWORD,2,1,strPassword,0,8);
   12528:	84 e0       	ldi	r24, 0x04	; 4
   1252a:	62 e0       	ldi	r22, 0x02	; 2
   1252c:	41 e0       	ldi	r20, 0x01	; 1
   1252e:	2f e9       	ldi	r18, 0x9F	; 159
   12530:	32 e0       	ldi	r19, 0x02	; 2
   12532:	00 e0       	ldi	r16, 0x00	; 0
   12534:	10 e0       	ldi	r17, 0x00	; 0
   12536:	98 e0       	ldi	r25, 0x08	; 8
   12538:	e9 2e       	mov	r14, r25
   1253a:	0e 94 d8 7d 	call	0xfbb0	; 0xfbb0 <UserInput>
   1253e:	80 93 a9 02 	sts	0x02A9, r24
		  if (uiResult==USER_OK){
   12542:	83 30       	cpi	r24, 0x03	; 3
   12544:	11 f4       	brne	.+4      	; 0x1254a <FMenuPassword+0x90>
		      stMenuPasword=mpProcessPassword;
   12546:	82 e0       	ldi	r24, 0x02	; 2
   12548:	62 c0       	rjmp	.+196    	; 0x1260e <FMenuPassword+0x154>
			  }
		  else
		  if (uiResult==USER_CANCEL){
   1254a:	81 30       	cpi	r24, 0x01	; 1
   1254c:	09 f4       	brne	.+2      	; 0x12550 <FMenuPassword+0x96>
   1254e:	50 c0       	rjmp	.+160    	; 0x125f0 <FMenuPassword+0x136>
		      PassStatus=MP_CANCEL;
		      stMenuPasword=mpExit;
			  }
		  else
		  if (uiResult==USER_ENTRY)lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   12550:	84 30       	cpi	r24, 0x04	; 4
   12552:	21 f4       	brne	.+8      	; 0x1255c <FMenuPassword+0xa2>
   12554:	61 e0       	ldi	r22, 0x01	; 1
   12556:	4a e1       	ldi	r20, 0x1A	; 26
   12558:	58 e1       	ldi	r21, 0x18	; 24
   1255a:	07 c0       	rjmp	.+14     	; 0x1256a <FMenuPassword+0xb0>
		  else
		  if (uiResult==USER_NO_DATA)lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   1255c:	85 30       	cpi	r24, 0x05	; 5
   1255e:	09 f0       	breq	.+2      	; 0x12562 <FMenuPassword+0xa8>
   12560:	5e c0       	rjmp	.+188    	; 0x1261e <FMenuPassword+0x164>
   12562:	84 e0       	ldi	r24, 0x04	; 4
   12564:	61 e0       	ldi	r22, 0x01	; 1
   12566:	45 e0       	ldi	r20, 0x05	; 5
   12568:	58 e1       	ldi	r21, 0x18	; 24
   1256a:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
   1256e:	57 c0       	rjmp	.+174    	; 0x1261e <FMenuPassword+0x164>
          break;	 
	 case mpProcessPassword:
		      
	      sprintf_P(strMasterPass,PSTR(MASTER_PASSWORD)); 
   12570:	00 d0       	rcall	.+0      	; 0x12572 <FMenuPassword+0xb8>
   12572:	00 d0       	rcall	.+0      	; 0x12574 <FMenuPassword+0xba>
   12574:	8e 01       	movw	r16, r28
   12576:	0f 5f       	subi	r16, 0xFF	; 255
   12578:	1f 4f       	sbci	r17, 0xFF	; 255
   1257a:	ed b7       	in	r30, 0x3d	; 61
   1257c:	fe b7       	in	r31, 0x3e	; 62
   1257e:	12 83       	std	Z+2, r17	; 0x02
   12580:	01 83       	std	Z+1, r16	; 0x01
   12582:	8d ef       	ldi	r24, 0xFD	; 253
   12584:	97 e1       	ldi	r25, 0x17	; 23
   12586:	94 83       	std	Z+4, r25	; 0x04
   12588:	83 83       	std	Z+3, r24	; 0x03
   1258a:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
   1258e:	0f 90       	pop	r0
   12590:	0f 90       	pop	r0
   12592:	0f 90       	pop	r0
   12594:	0f 90       	pop	r0
   12596:	b5 e1       	ldi	r27, 0x15	; 21
   12598:	cb 2e       	mov	r12, r27
   1259a:	d1 2c       	mov	r13, r1
   1259c:	cc 0e       	add	r12, r28
   1259e:	dd 1e       	adc	r13, r29
   125a0:	c6 01       	movw	r24, r12
   125a2:	61 e0       	ldi	r22, 0x01	; 1
   125a4:	70 e0       	ldi	r23, 0x00	; 0
   125a6:	4a e0       	ldi	r20, 0x0A	; 10
   125a8:	50 e0       	ldi	r21, 0x00	; 0
   125aa:	2d ef       	ldi	r18, 0xFD	; 253
   125ac:	32 e1       	ldi	r19, 0x12	; 18
   125ae:	0e 94 f1 b3 	call	0x167e2	; 0x167e2 <__eerd_block>
	      eeprom_read_block((void*) &strAdminPass, (const void*) &DefSpvPassword, 10);
	      eeprom_read_block((void*) &strSystemPass, (const void*) &DefSysPassword, 10);
		  
		  if (strcmp(strMasterPass,strPassword)==0)
   125b2:	ab e0       	ldi	r26, 0x0B	; 11
   125b4:	aa 2e       	mov	r10, r26
   125b6:	b1 2c       	mov	r11, r1
   125b8:	ac 0e       	add	r10, r28
   125ba:	bd 1e       	adc	r11, r29
   125bc:	c5 01       	movw	r24, r10
   125be:	6b e0       	ldi	r22, 0x0B	; 11
   125c0:	70 e0       	ldi	r23, 0x00	; 0
   125c2:	4a e0       	ldi	r20, 0x0A	; 10
   125c4:	50 e0       	ldi	r21, 0x00	; 0
   125c6:	2d ef       	ldi	r18, 0xFD	; 253
   125c8:	32 e1       	ldi	r19, 0x12	; 18
   125ca:	0e 94 f1 b3 	call	0x167e2	; 0x167e2 <__eerd_block>
   125ce:	c8 01       	movw	r24, r16
   125d0:	6f e9       	ldi	r22, 0x9F	; 159
   125d2:	72 e0       	ldi	r23, 0x02	; 2
   125d4:	0e 94 e8 b3 	call	0x167d0	; 0x167d0 <strcmp>
   125d8:	00 97       	sbiw	r24, 0x00	; 0
   125da:	11 f4       	brne	.+4      	; 0x125e0 <FMenuPassword+0x126>
		       PassStatus=MP_VALID_MASTER;
   125dc:	83 e0       	ldi	r24, 0x03	; 3
   125de:	08 c0       	rjmp	.+16     	; 0x125f0 <FMenuPassword+0x136>
		  else
	      if (strcmp(strAdminPass,strPassword)==0){
   125e0:	c6 01       	movw	r24, r12
   125e2:	6f e9       	ldi	r22, 0x9F	; 159
   125e4:	72 e0       	ldi	r23, 0x02	; 2
   125e6:	0e 94 e8 b3 	call	0x167d0	; 0x167d0 <strcmp>
   125ea:	00 97       	sbiw	r24, 0x00	; 0
   125ec:	21 f4       	brne	.+8      	; 0x125f6 <FMenuPassword+0x13c>
		       PassStatus=MP_VALID_ADMIN;
   125ee:	84 e0       	ldi	r24, 0x04	; 4
   125f0:	80 93 9e 02 	sts	0x029E, r24
   125f4:	0b c0       	rjmp	.+22     	; 0x1260c <FMenuPassword+0x152>
               //lcd_printf(3,1,PSTR("Admin"));
               //_delay_ms(5000);
			   }
		  else if (strcmp(strSystemPass,strPassword)==0){
   125f6:	c5 01       	movw	r24, r10
   125f8:	6f e9       	ldi	r22, 0x9F	; 159
   125fa:	72 e0       	ldi	r23, 0x02	; 2
   125fc:	0e 94 e8 b3 	call	0x167d0	; 0x167d0 <strcmp>
   12600:	00 97       	sbiw	r24, 0x00	; 0
   12602:	11 f4       	brne	.+4      	; 0x12608 <FMenuPassword+0x14e>
		       PassStatus=MP_VALID_SYSTEM;
   12604:	85 e0       	ldi	r24, 0x05	; 5
   12606:	f4 cf       	rjmp	.-24     	; 0x125f0 <FMenuPassword+0x136>
			   //lcd_printf(3,1,PSTR("System"));
               //_delay_ms(5000);
			   }
		  else PassStatus=MP_INVALID;
   12608:	e0 92 9e 02 	sts	0x029E, r14
		  stMenuPasword=mpExit;
   1260c:	83 e0       	ldi	r24, 0x03	; 3
   1260e:	80 93 aa 02 	sts	0x02AA, r24
   12612:	05 c0       	rjmp	.+10     	; 0x1261e <FMenuPassword+0x164>
	      break;
	 case mpExit:
	      //lcd_print(3,1,strPassword);
		  //_delay_ms(5000);
	      stMenuPasword=mpInitPassword;
   12614:	10 92 aa 02 	sts	0x02AA, r1
	      Result=PassStatus;
   12618:	80 91 9e 02 	lds	r24, 0x029E
   1261c:	01 c0       	rjmp	.+2      	; 0x12620 <FMenuPassword+0x166>
   1261e:	80 e0       	ldi	r24, 0x00	; 0
	      break;
	 }
   return Result;
}
   12620:	6e 96       	adiw	r28, 0x1e	; 30
   12622:	0f b6       	in	r0, 0x3f	; 63
   12624:	f8 94       	cli
   12626:	de bf       	out	0x3e, r29	; 62
   12628:	0f be       	out	0x3f, r0	; 63
   1262a:	cd bf       	out	0x3d, r28	; 61
   1262c:	cf 91       	pop	r28
   1262e:	df 91       	pop	r29
   12630:	1f 91       	pop	r17
   12632:	0f 91       	pop	r16
   12634:	ef 90       	pop	r14
   12636:	df 90       	pop	r13
   12638:	cf 90       	pop	r12
   1263a:	bf 90       	pop	r11
   1263c:	af 90       	pop	r10
   1263e:	08 95       	ret

00012640 <FMenuReprint>:
	       break;
	 }
return Result;
}

char FMenuReprint(){
   12640:	0f 93       	push	r16
   12642:	1f 93       	push	r17
   12644:	df 93       	push	r29
   12646:	cf 93       	push	r28
   12648:	cd b7       	in	r28, 0x3d	; 61
   1264a:	de b7       	in	r29, 0x3e	; 62
   1264c:	64 97       	sbiw	r28, 0x14	; 20
   1264e:	0f b6       	in	r0, 0x3f	; 63
   12650:	f8 94       	cli
   12652:	de bf       	out	0x3e, r29	; 62
   12654:	0f be       	out	0x3f, r0	; 63
   12656:	cd bf       	out	0x3d, r28	; 61
static char KeyPressed=0,FIP_Used=0;
       char lcdteks[20],FIPResult,KeyChar;//,FIP_USED;
	   char PassResult,Result=MENU_NONE,ReprintResult;

     Result=MENU_NONE;
	 switch(stReprint){
   12658:	80 91 bb 02 	lds	r24, 0x02BB
   1265c:	87 30       	cpi	r24, 0x07	; 7
   1265e:	09 f4       	brne	.+2      	; 0x12662 <FMenuReprint+0x22>
   12660:	88 c0       	rjmp	.+272    	; 0x12772 <FMenuReprint+0x132>
   12662:	88 30       	cpi	r24, 0x08	; 8
   12664:	90 f4       	brcc	.+36     	; 0x1268a <FMenuReprint+0x4a>
   12666:	83 30       	cpi	r24, 0x03	; 3
   12668:	09 f4       	brne	.+2      	; 0x1266c <FMenuReprint+0x2c>
   1266a:	43 c0       	rjmp	.+134    	; 0x126f2 <FMenuReprint+0xb2>
   1266c:	84 30       	cpi	r24, 0x04	; 4
   1266e:	30 f4       	brcc	.+12     	; 0x1267c <FMenuReprint+0x3c>
   12670:	81 30       	cpi	r24, 0x01	; 1
   12672:	09 f4       	brne	.+2      	; 0x12676 <FMenuReprint+0x36>
   12674:	52 c0       	rjmp	.+164    	; 0x1271a <FMenuReprint+0xda>
   12676:	82 30       	cpi	r24, 0x02	; 2
   12678:	48 f5       	brcc	.+82     	; 0x126cc <FMenuReprint+0x8c>
   1267a:	1d c0       	rjmp	.+58     	; 0x126b6 <FMenuReprint+0x76>
   1267c:	85 30       	cpi	r24, 0x05	; 5
   1267e:	09 f4       	brne	.+2      	; 0x12682 <FMenuReprint+0x42>
   12680:	69 c0       	rjmp	.+210    	; 0x12754 <FMenuReprint+0x114>
   12682:	86 30       	cpi	r24, 0x06	; 6
   12684:	08 f0       	brcs	.+2      	; 0x12688 <FMenuReprint+0x48>
   12686:	4d c0       	rjmp	.+154    	; 0x12722 <FMenuReprint+0xe2>
   12688:	42 c0       	rjmp	.+132    	; 0x1270e <FMenuReprint+0xce>
   1268a:	8b 30       	cpi	r24, 0x0B	; 11
   1268c:	09 f4       	brne	.+2      	; 0x12690 <FMenuReprint+0x50>
   1268e:	d2 c0       	rjmp	.+420    	; 0x12834 <FMenuReprint+0x1f4>
   12690:	8c 30       	cpi	r24, 0x0C	; 12
   12692:	38 f4       	brcc	.+14     	; 0x126a2 <FMenuReprint+0x62>
   12694:	89 30       	cpi	r24, 0x09	; 9
   12696:	09 f4       	brne	.+2      	; 0x1269a <FMenuReprint+0x5a>
   12698:	b2 c0       	rjmp	.+356    	; 0x127fe <FMenuReprint+0x1be>
   1269a:	8a 30       	cpi	r24, 0x0A	; 10
   1269c:	08 f0       	brcs	.+2      	; 0x126a0 <FMenuReprint+0x60>
   1269e:	c4 c0       	rjmp	.+392    	; 0x12828 <FMenuReprint+0x1e8>
   126a0:	76 c0       	rjmp	.+236    	; 0x1278e <FMenuReprint+0x14e>
   126a2:	8d 30       	cpi	r24, 0x0D	; 13
   126a4:	09 f4       	brne	.+2      	; 0x126a8 <FMenuReprint+0x68>
   126a6:	e3 c0       	rjmp	.+454    	; 0x1286e <FMenuReprint+0x22e>
   126a8:	8d 30       	cpi	r24, 0x0D	; 13
   126aa:	08 f4       	brcc	.+2      	; 0x126ae <FMenuReprint+0x6e>
   126ac:	cd c0       	rjmp	.+410    	; 0x12848 <FMenuReprint+0x208>
   126ae:	8e 30       	cpi	r24, 0x0E	; 14
   126b0:	09 f0       	breq	.+2      	; 0x126b4 <FMenuReprint+0x74>
   126b2:	e6 c0       	rjmp	.+460    	; 0x12880 <FMenuReprint+0x240>
   126b4:	e1 c0       	rjmp	.+450    	; 0x12878 <FMenuReprint+0x238>
	 case rtInit:
	      lcd_clear();
   126b6:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
          if (IFType==IT_SLAVE)stReprint=rtFIP;
   126ba:	80 91 00 01 	lds	r24, 0x0100
   126be:	81 30       	cpi	r24, 0x01	; 1
   126c0:	09 f4       	brne	.+2      	; 0x126c4 <FMenuReprint+0x84>
   126c2:	ad c0       	rjmp	.+346    	; 0x1281e <FMenuReprint+0x1de>
		  else
		  if (IFType==IT_STANDALONE)stReprint=rtStandaloneFIP;//rtValidPassword;//rtStandaloneFIP;
   126c4:	82 30       	cpi	r24, 0x02	; 2
   126c6:	09 f0       	breq	.+2      	; 0x126ca <FMenuReprint+0x8a>
   126c8:	db c0       	rjmp	.+438    	; 0x12880 <FMenuReprint+0x240>
   126ca:	04 c0       	rjmp	.+8      	; 0x126d4 <FMenuReprint+0x94>
	      break;
     case rtValidPassword:
	      PassResult=FMenuPassword();
   126cc:	0e 94 5d 92 	call	0x124ba	; 0x124ba <FMenuPassword>
	      if (PassResult==MP_VALID_ADMIN)stReprint=rtStandaloneFIP;
   126d0:	84 30       	cpi	r24, 0x04	; 4
   126d2:	11 f4       	brne	.+4      	; 0x126d8 <FMenuReprint+0x98>
   126d4:	81 e0       	ldi	r24, 0x01	; 1
   126d6:	0a c0       	rjmp	.+20     	; 0x126ec <FMenuReprint+0xac>
		  else
	      if (PassResult==MP_VALID_SYSTEM)stReprint=rtInvalidPassword;
   126d8:	85 30       	cpi	r24, 0x05	; 5
   126da:	11 f0       	breq	.+4      	; 0x126e0 <FMenuReprint+0xa0>
          else
	      if (PassResult==MP_INVALID)stReprint=rtInvalidPassword;
   126dc:	82 30       	cpi	r24, 0x02	; 2
   126de:	11 f4       	brne	.+4      	; 0x126e4 <FMenuReprint+0xa4>
   126e0:	83 e0       	ldi	r24, 0x03	; 3
   126e2:	04 c0       	rjmp	.+8      	; 0x126ec <FMenuReprint+0xac>
		  else
	      if (PassResult==MP_CANCEL)stReprint=rtExitReprint;
   126e4:	81 30       	cpi	r24, 0x01	; 1
   126e6:	09 f0       	breq	.+2      	; 0x126ea <FMenuReprint+0xaa>
   126e8:	cb c0       	rjmp	.+406    	; 0x12880 <FMenuReprint+0x240>
   126ea:	8e e0       	ldi	r24, 0x0E	; 14
   126ec:	80 93 bb 02 	sts	0x02BB, r24
   126f0:	c7 c0       	rjmp	.+398    	; 0x12880 <FMenuReprint+0x240>
	      break;
     case rtInvalidPassword:
          TimDisplay=0;
   126f2:	10 92 95 01 	sts	0x0195, r1
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   126f6:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   126f8:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   126fa:	81 e0       	ldi	r24, 0x01	; 1
   126fc:	80 93 bf 01 	sts	0x01BF, r24
	      if (PassResult==MP_CANCEL)stReprint=rtExitReprint;
	      break;
     case rtInvalidPassword:
          TimDisplay=0;
		  system_beep(1);
		  lcd_printf(3,1,PSTR("Access Denied"));
   12700:	83 e0       	ldi	r24, 0x03	; 3
   12702:	61 e0       	ldi	r22, 0x01	; 1
   12704:	41 eb       	ldi	r20, 0xB1	; 177
   12706:	5b e1       	ldi	r21, 0x1B	; 27
   12708:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
   1270c:	30 c0       	rjmp	.+96     	; 0x1276e <FMenuReprint+0x12e>
          stReprint=rtTimDisplayInvalid;
	      break;
     case rtTimDisplayInvalid:
	      if (TimDisplay>2)stReprint=rtExitReprint;
   1270e:	80 91 95 01 	lds	r24, 0x0195
   12712:	83 30       	cpi	r24, 0x03	; 3
   12714:	08 f4       	brcc	.+2      	; 0x12718 <FMenuReprint+0xd8>
   12716:	b4 c0       	rjmp	.+360    	; 0x12880 <FMenuReprint+0x240>
   12718:	e8 cf       	rjmp	.-48     	; 0x126ea <FMenuReprint+0xaa>
	      break;
     case rtStandaloneFIP:
	      _scr_pump();
   1271a:	0e 94 a0 45 	call	0x8b40	; 0x8b40 <_scr_pump>
		  stReprint=rtStandaloneInputFIP;
   1271e:	86 e0       	ldi	r24, 0x06	; 6
   12720:	e5 cf       	rjmp	.-54     	; 0x126ec <FMenuReprint+0xac>
	      break;
     case rtStandaloneInputFIP:
		  KeyChar=_key_btn(_key_scan(1));
   12722:	81 e0       	ldi	r24, 0x01	; 1
   12724:	0e 94 84 ae 	call	0x15d08	; 0x15d08 <_key_scan>
   12728:	0e 94 e5 ad 	call	0x15bca	; 0x15bca <_key_btn>
   1272c:	98 2f       	mov	r25, r24
		  if ((KeyChar>='1')&&(KeyChar<='8')){
   1272e:	81 53       	subi	r24, 0x31	; 49
   12730:	88 30       	cpi	r24, 0x08	; 8
   12732:	60 f4       	brcc	.+24     	; 0x1274c <FMenuReprint+0x10c>
		       ReprintResult=PrintStandalone(KeyChar-'0',True);
   12734:	8f 5f       	subi	r24, 0xFF	; 255
   12736:	61 e0       	ldi	r22, 0x01	; 1
   12738:	0e 94 f7 20 	call	0x41ee	; 0x41ee <PrintStandalone>
			   if (ReprintResult==PS_NO_DATA)stReprint=rtDisplayNoTransaction;
   1273c:	82 31       	cpi	r24, 0x12	; 18
   1273e:	11 f4       	brne	.+4      	; 0x12744 <FMenuReprint+0x104>
   12740:	85 e0       	ldi	r24, 0x05	; 5
   12742:	d4 cf       	rjmp	.-88     	; 0x126ec <FMenuReprint+0xac>
			   else if (ReprintResult==PS_PRINTED)stReprint=rtExitReprint;
   12744:	81 31       	cpi	r24, 0x11	; 17
   12746:	09 f0       	breq	.+2      	; 0x1274a <FMenuReprint+0x10a>
   12748:	9b c0       	rjmp	.+310    	; 0x12880 <FMenuReprint+0x240>
   1274a:	cf cf       	rjmp	.-98     	; 0x126ea <FMenuReprint+0xaa>

		  }else if (KeyChar=='*')stReprint=rtExitReprint;
   1274c:	9a 32       	cpi	r25, 0x2A	; 42
   1274e:	09 f0       	breq	.+2      	; 0x12752 <FMenuReprint+0x112>
   12750:	97 c0       	rjmp	.+302    	; 0x12880 <FMenuReprint+0x240>
   12752:	cb cf       	rjmp	.-106    	; 0x126ea <FMenuReprint+0xaa>

	      break;
     case rtDisplayNoTransaction:
	      lcd_printf(3, 1,PSTR("Tidak Ada Transaksi "));
   12754:	83 e0       	ldi	r24, 0x03	; 3
   12756:	61 e0       	ldi	r22, 0x01	; 1
   12758:	4c e9       	ldi	r20, 0x9C	; 156
   1275a:	5b e1       	ldi	r21, 0x1B	; 27
   1275c:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   12760:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   12762:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   12764:	81 e0       	ldi	r24, 0x01	; 1
   12766:	80 93 bf 01 	sts	0x01BF, r24

	      break;
     case rtDisplayNoTransaction:
	      lcd_printf(3, 1,PSTR("Tidak Ada Transaksi "));
		  system_beep(1);
          TimDisplay=0;
   1276a:	10 92 95 01 	sts	0x0195, r1
		  stReprint=rtTimDisplayInvalid;
   1276e:	84 e0       	ldi	r24, 0x04	; 4
   12770:	bd cf       	rjmp	.-134    	; 0x126ec <FMenuReprint+0xac>
	      break;
	 case rtFIP:
	      FIPResult=menu_FIP(&FIP_Used,strFIP_ID);
   12772:	89 eb       	ldi	r24, 0xB9	; 185
   12774:	92 e0       	ldi	r25, 0x02	; 2
   12776:	6b ec       	ldi	r22, 0xCB	; 203
   12778:	78 e0       	ldi	r23, 0x08	; 8
   1277a:	0e 94 b5 65 	call	0xcb6a	; 0xcb6a <menu_FIP>
		  if (FIPResult==FIP_DONE){
   1277e:	88 23       	and	r24, r24
   12780:	11 f4       	brne	.+4      	; 0x12786 <FMenuReprint+0x146>
		      stReprint=rtRFID;
   12782:	88 e0       	ldi	r24, 0x08	; 8
   12784:	b3 cf       	rjmp	.-154    	; 0x126ec <FMenuReprint+0xac>
			  }
		  else
		  if (FIPResult==FIP_CANCEL)stReprint=rtExitReprint;
   12786:	82 30       	cpi	r24, 0x02	; 2
   12788:	09 f0       	breq	.+2      	; 0x1278c <FMenuReprint+0x14c>
   1278a:	7a c0       	rjmp	.+244    	; 0x12880 <FMenuReprint+0x240>
   1278c:	ae cf       	rjmp	.-164    	; 0x126ea <FMenuReprint+0xaa>
	      break;
	 case rtRFID:
	      lcd_clear();
   1278e:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
		  sprintf_P(lcdteks,PSTR("RePrint FIP:%s "),strFIP_ID);lcd_print(1,1,lcdteks);
   12792:	00 d0       	rcall	.+0      	; 0x12794 <FMenuReprint+0x154>
   12794:	00 d0       	rcall	.+0      	; 0x12796 <FMenuReprint+0x156>
   12796:	00 d0       	rcall	.+0      	; 0x12798 <FMenuReprint+0x158>
   12798:	ed b7       	in	r30, 0x3d	; 61
   1279a:	fe b7       	in	r31, 0x3e	; 62
   1279c:	31 96       	adiw	r30, 0x01	; 1
   1279e:	8e 01       	movw	r16, r28
   127a0:	0f 5f       	subi	r16, 0xFF	; 255
   127a2:	1f 4f       	sbci	r17, 0xFF	; 255
   127a4:	ad b7       	in	r26, 0x3d	; 61
   127a6:	be b7       	in	r27, 0x3e	; 62
   127a8:	12 96       	adiw	r26, 0x02	; 2
   127aa:	1c 93       	st	X, r17
   127ac:	0e 93       	st	-X, r16
   127ae:	11 97       	sbiw	r26, 0x01	; 1
   127b0:	8c e8       	ldi	r24, 0x8C	; 140
   127b2:	9b e1       	ldi	r25, 0x1B	; 27
   127b4:	93 83       	std	Z+3, r25	; 0x03
   127b6:	82 83       	std	Z+2, r24	; 0x02
   127b8:	8b ec       	ldi	r24, 0xCB	; 203
   127ba:	98 e0       	ldi	r25, 0x08	; 8
   127bc:	95 83       	std	Z+5, r25	; 0x05
   127be:	84 83       	std	Z+4, r24	; 0x04
   127c0:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
   127c4:	8d b7       	in	r24, 0x3d	; 61
   127c6:	9e b7       	in	r25, 0x3e	; 62
   127c8:	06 96       	adiw	r24, 0x06	; 6
   127ca:	0f b6       	in	r0, 0x3f	; 63
   127cc:	f8 94       	cli
   127ce:	9e bf       	out	0x3e, r25	; 62
   127d0:	0f be       	out	0x3f, r0	; 63
   127d2:	8d bf       	out	0x3d, r24	; 61
   127d4:	81 e0       	ldi	r24, 0x01	; 1
   127d6:	61 e0       	ldi	r22, 0x01	; 1
   127d8:	a8 01       	movw	r20, r16
   127da:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
		  lcd_printf(2,1,PSTR(  "Tap Supervisor Card"));
   127de:	82 e0       	ldi	r24, 0x02	; 2
   127e0:	61 e0       	ldi	r22, 0x01	; 1
   127e2:	48 e7       	ldi	r20, 0x78	; 120
   127e4:	5b e1       	ldi	r21, 0x1B	; 27
   127e6:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
          lcd_printf(4,1,PSTR(  "[*]Back    [#]Exit"));
   127ea:	84 e0       	ldi	r24, 0x04	; 4
   127ec:	61 e0       	ldi	r22, 0x01	; 1
   127ee:	45 e6       	ldi	r20, 0x65	; 101
   127f0:	5b e1       	ldi	r21, 0x1B	; 27
   127f2:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		  IsRFIDDetected=False;
   127f6:	10 92 9b 01 	sts	0x019B, r1
		  stReprint=rtInputRFID;
   127fa:	89 e0       	ldi	r24, 0x09	; 9
   127fc:	77 cf       	rjmp	.-274    	; 0x126ec <FMenuReprint+0xac>
	      break;
	 case rtInputRFID:
	      if (IsRFIDDetected==True){
   127fe:	80 91 9b 01 	lds	r24, 0x019B
   12802:	81 30       	cpi	r24, 0x01	; 1
   12804:	29 f4       	brne	.+10     	; 0x12810 <FMenuReprint+0x1d0>
		      IsRFIDDetected=False;
   12806:	10 92 9b 01 	sts	0x019B, r1
		      stReprint=rtSendMessage28;
   1280a:	8a e0       	ldi	r24, 0x0A	; 10
   1280c:	80 93 bb 02 	sts	0x02BB, r24
		  }
	 	  KeyPressed=_key_scan(1);
   12810:	81 e0       	ldi	r24, 0x01	; 1
   12812:	0e 94 84 ae 	call	0x15d08	; 0x15d08 <_key_scan>
   12816:	80 93 ba 02 	sts	0x02BA, r24
		  if (KeyPressed==_KEY_CANCEL){
   1281a:	87 3e       	cpi	r24, 0xE7	; 231
   1281c:	11 f4       	brne	.+4      	; 0x12822 <FMenuReprint+0x1e2>
		      stReprint=rtFIP;
   1281e:	87 e0       	ldi	r24, 0x07	; 7
   12820:	65 cf       	rjmp	.-310    	; 0x126ec <FMenuReprint+0xac>
			  }
		  else
		  if (KeyPressed==_KEY_ENTER)stReprint=rtExitReprint;
   12822:	87 3b       	cpi	r24, 0xB7	; 183
   12824:	69 f5       	brne	.+90     	; 0x12880 <FMenuReprint+0x240>
   12826:	61 cf       	rjmp	.-318    	; 0x126ea <FMenuReprint+0xaa>
	      break;
     case rtSendMessage28:
		  sendMessage28();
   12828:	0e 94 62 51 	call	0xa2c4	; 0xa2c4 <sendMessage28>
		  TimSend=0;
   1282c:	10 92 af 0d 	sts	0x0DAF, r1
		  stReprint=rtWaitReply;
   12830:	8b e0       	ldi	r24, 0x0B	; 11
   12832:	5c cf       	rjmp	.-328    	; 0x126ec <FMenuReprint+0xac>
		  break;
     case rtWaitReply:
	      if (TimSend>TIM_SEND*3)stReprint=rtNoConnection;
   12834:	80 91 af 0d 	lds	r24, 0x0DAF
   12838:	8f 31       	cpi	r24, 0x1F	; 31
   1283a:	18 f0       	brcs	.+6      	; 0x12842 <FMenuReprint+0x202>
   1283c:	8c e0       	ldi	r24, 0x0C	; 12
   1283e:	80 93 bb 02 	sts	0x02BB, r24
	      if (IsMessage99==True){
   12842:	80 91 a2 01 	lds	r24, 0x01A2
   12846:	4e cf       	rjmp	.-356    	; 0x126e4 <FMenuReprint+0xa4>
		      stReprint=rtExitReprint;
		  }
	      break;
     case rtNoConnection:
	      lcd_clear();
   12848:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
		  lcd_printf(2,1,PSTR("TCP/IP ERROR "));
   1284c:	82 e0       	ldi	r24, 0x02	; 2
   1284e:	61 e0       	ldi	r22, 0x01	; 1
   12850:	47 e5       	ldi	r20, 0x57	; 87
   12852:	5b e1       	ldi	r21, 0x1B	; 27
   12854:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		  lcd_printf(3,1,PSTR("No Connection"));
   12858:	83 e0       	ldi	r24, 0x03	; 3
   1285a:	61 e0       	ldi	r22, 0x01	; 1
   1285c:	49 e4       	ldi	r20, 0x49	; 73
   1285e:	5b e1       	ldi	r21, 0x1B	; 27
   12860:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		  TimDisplay=5;
   12864:	85 e0       	ldi	r24, 0x05	; 5
   12866:	80 93 95 01 	sts	0x0195, r24
		  stReprint=rtDelayExitReprint;
   1286a:	8d e0       	ldi	r24, 0x0D	; 13
   1286c:	3f cf       	rjmp	.-386    	; 0x126ec <FMenuReprint+0xac>
	      break;
     case rtDelayExitReprint:
	      if(TimDisplay>=10)stReprint=rtExitReprint;
   1286e:	80 91 95 01 	lds	r24, 0x0195
   12872:	8a 30       	cpi	r24, 0x0A	; 10
   12874:	28 f0       	brcs	.+10     	; 0x12880 <FMenuReprint+0x240>
   12876:	39 cf       	rjmp	.-398    	; 0x126ea <FMenuReprint+0xaa>
	      break;
	 case rtExitReprint:
	      stReprint=rtInit;
   12878:	10 92 bb 02 	sts	0x02BB, r1
   1287c:	81 e0       	ldi	r24, 0x01	; 1
   1287e:	01 c0       	rjmp	.+2      	; 0x12882 <FMenuReprint+0x242>
   12880:	80 e0       	ldi	r24, 0x00	; 0
		  Result=MENU_DONE;
	      break;
	 }
  return Result;
}
   12882:	64 96       	adiw	r28, 0x14	; 20
   12884:	0f b6       	in	r0, 0x3f	; 63
   12886:	f8 94       	cli
   12888:	de bf       	out	0x3e, r29	; 62
   1288a:	0f be       	out	0x3f, r0	; 63
   1288c:	cd bf       	out	0x3d, r28	; 61
   1288e:	cf 91       	pop	r28
   12890:	df 91       	pop	r29
   12892:	1f 91       	pop	r17
   12894:	0f 91       	pop	r16
   12896:	08 95       	ret

00012898 <FMenuAdmin>:

char FMenuAdmin(){
static char stMenuAdmin=maInitAdmin;
	 char SubMenu,KeyPressed,KeyChar,Result=MENU_NONE;
     
	 switch(stMenuAdmin){
   12898:	80 91 9c 02 	lds	r24, 0x029C
   1289c:	83 30       	cpi	r24, 0x03	; 3
   1289e:	09 f4       	brne	.+2      	; 0x128a2 <FMenuAdmin+0xa>
   128a0:	66 c0       	rjmp	.+204    	; 0x1296e <FMenuAdmin+0xd6>
   128a2:	84 30       	cpi	r24, 0x04	; 4
   128a4:	30 f4       	brcc	.+12     	; 0x128b2 <FMenuAdmin+0x1a>
   128a6:	81 30       	cpi	r24, 0x01	; 1
   128a8:	69 f1       	breq	.+90     	; 0x12904 <FMenuAdmin+0x6c>
   128aa:	82 30       	cpi	r24, 0x02	; 2
   128ac:	08 f0       	brcs	.+2      	; 0x128b0 <FMenuAdmin+0x18>
   128ae:	4d c0       	rjmp	.+154    	; 0x1294a <FMenuAdmin+0xb2>
   128b0:	0d c0       	rjmp	.+26     	; 0x128cc <FMenuAdmin+0x34>
   128b2:	85 30       	cpi	r24, 0x05	; 5
   128b4:	09 f4       	brne	.+2      	; 0x128b8 <FMenuAdmin+0x20>
   128b6:	4e c0       	rjmp	.+156    	; 0x12954 <FMenuAdmin+0xbc>
   128b8:	85 30       	cpi	r24, 0x05	; 5
   128ba:	08 f4       	brcc	.+2      	; 0x128be <FMenuAdmin+0x26>
   128bc:	49 c0       	rjmp	.+146    	; 0x12950 <FMenuAdmin+0xb8>
   128be:	86 30       	cpi	r24, 0x06	; 6
   128c0:	09 f4       	brne	.+2      	; 0x128c4 <FMenuAdmin+0x2c>
   128c2:	51 c0       	rjmp	.+162    	; 0x12966 <FMenuAdmin+0xce>
   128c4:	87 30       	cpi	r24, 0x07	; 7
   128c6:	09 f0       	breq	.+2      	; 0x128ca <FMenuAdmin+0x32>
   128c8:	5a c0       	rjmp	.+180    	; 0x1297e <FMenuAdmin+0xe6>
   128ca:	55 c0       	rjmp	.+170    	; 0x12976 <FMenuAdmin+0xde>
	 case maInitAdmin:
		  lcd_clear();
   128cc:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
		  lcd_printf(1,1,PSTR("1)RePrint           "));
   128d0:	81 e0       	ldi	r24, 0x01	; 1
   128d2:	61 e0       	ldi	r22, 0x01	; 1
   128d4:	44 e5       	ldi	r20, 0x54	; 84
   128d6:	56 e1       	ldi	r21, 0x16	; 22
   128d8:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		  lcd_printf(2,1,PSTR("2)CloseShift        "));
   128dc:	82 e0       	ldi	r24, 0x02	; 2
   128de:	61 e0       	ldi	r22, 0x01	; 1
   128e0:	4f e3       	ldi	r20, 0x3F	; 63
   128e2:	56 e1       	ldi	r21, 0x16	; 22
   128e4:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		  lcd_printf(3,1,PSTR("3)CloseDay          "));		  
   128e8:	83 e0       	ldi	r24, 0x03	; 3
   128ea:	61 e0       	ldi	r22, 0x01	; 1
   128ec:	4a e2       	ldi	r20, 0x2A	; 42
   128ee:	56 e1       	ldi	r21, 0x16	; 22
   128f0:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		  lcd_printf(4,1,PSTR("4)Settings   *)Exit "));
   128f4:	84 e0       	ldi	r24, 0x04	; 4
   128f6:	61 e0       	ldi	r22, 0x01	; 1
   128f8:	45 e1       	ldi	r20, 0x15	; 21
   128fa:	56 e1       	ldi	r21, 0x16	; 22
   128fc:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
	      stMenuAdmin=maSelectOptions;
   12900:	81 e0       	ldi	r24, 0x01	; 1
   12902:	2e c0       	rjmp	.+92     	; 0x12960 <FMenuAdmin+0xc8>
	      break;
	 case maSelectOptions:
          KeyPressed=_key_scan(1);
   12904:	81 e0       	ldi	r24, 0x01	; 1
   12906:	0e 94 84 ae 	call	0x15d08	; 0x15d08 <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
   1290a:	0e 94 e5 ad 	call	0x15bca	; 0x15bca <_key_btn>
		  switch (KeyChar){
   1290e:	82 33       	cpi	r24, 0x32	; 50
   12910:	71 f0       	breq	.+28     	; 0x1292e <FMenuAdmin+0x96>
   12912:	83 33       	cpi	r24, 0x33	; 51
   12914:	28 f4       	brcc	.+10     	; 0x12920 <FMenuAdmin+0x88>
   12916:	8a 32       	cpi	r24, 0x2A	; 42
   12918:	11 f1       	breq	.+68     	; 0x1295e <FMenuAdmin+0xc6>
   1291a:	81 33       	cpi	r24, 0x31	; 49
   1291c:	81 f5       	brne	.+96     	; 0x1297e <FMenuAdmin+0xe6>
   1291e:	05 c0       	rjmp	.+10     	; 0x1292a <FMenuAdmin+0x92>
   12920:	83 33       	cpi	r24, 0x33	; 51
   12922:	59 f0       	breq	.+22     	; 0x1293a <FMenuAdmin+0xa2>
   12924:	84 33       	cpi	r24, 0x34	; 52
   12926:	59 f5       	brne	.+86     	; 0x1297e <FMenuAdmin+0xe6>
   12928:	0e c0       	rjmp	.+28     	; 0x12946 <FMenuAdmin+0xae>
		  case '1':
		       stMenuAdmin=maMenuReprint;//maMenuAdminConfig;
   1292a:	82 e0       	ldi	r24, 0x02	; 2
   1292c:	19 c0       	rjmp	.+50     	; 0x12960 <FMenuAdmin+0xc8>
		       break;  
		  case '2':
		       if (IFType==IT_STANDALONE)
   1292e:	80 91 00 01 	lds	r24, 0x0100
   12932:	82 30       	cpi	r24, 0x02	; 2
   12934:	e1 f4       	brne	.+56     	; 0x1296e <FMenuAdmin+0xd6>
			       stMenuAdmin=maMenuCloseShift;
   12936:	84 e0       	ldi	r24, 0x04	; 4
   12938:	13 c0       	rjmp	.+38     	; 0x12960 <FMenuAdmin+0xc8>
               else stMenuAdmin=maInitAdmin;
		       break;  
		  case '3':
		       if (IFType==IT_STANDALONE)stMenuAdmin=maMenuCloseDay;
   1293a:	80 91 00 01 	lds	r24, 0x0100
   1293e:	82 30       	cpi	r24, 0x02	; 2
   12940:	b1 f4       	brne	.+44     	; 0x1296e <FMenuAdmin+0xd6>
   12942:	85 e0       	ldi	r24, 0x05	; 5
   12944:	0d c0       	rjmp	.+26     	; 0x12960 <FMenuAdmin+0xc8>
               else stMenuAdmin=maInitAdmin;
		       break;  
		  case '4':
		  	   stMenuAdmin=maMenuAdminSettings;
   12946:	86 e0       	ldi	r24, 0x06	; 6
   12948:	0b c0       	rjmp	.+22     	; 0x12960 <FMenuAdmin+0xc8>
    		   stMenuAdmin=maExitMenuAdmin;
		       break;  		  
		  }		  
	      break;
     case maMenuReprint:
	      SubMenu=FMenuReprint();
   1294a:	0e 94 20 93 	call	0x12640	; 0x12640 <FMenuReprint>
   1294e:	05 c0       	rjmp	.+10     	; 0x1295a <FMenuAdmin+0xc2>
	 case maMenuAdminConfig://ChangePassword[],RePrint,PumpTest
	      SubMenu=FSubMenuAdmin();
		  if (SubMenu==MENU_DONE)stMenuAdmin=maInitAdmin;
          break;	 
	 case maMenuCloseShift:
	 	  SubMenu=FCloseShift(CONTINUE_SHIFT);
   12950:	82 e0       	ldi	r24, 0x02	; 2
   12952:	01 c0       	rjmp	.+2      	; 0x12956 <FMenuAdmin+0xbe>
		  if (SubMenu==MENU_DONE)stMenuAdmin=maExitMenuAdmin;
	      break;
     case maMenuCloseDay://maMenuCloseShift,maMenuCloseDay
	 	  SubMenu=FCloseShift(NEW_SHIFT);
   12954:	81 e0       	ldi	r24, 0x01	; 1
   12956:	0e 94 17 61 	call	0xc22e	; 0xc22e <FCloseShift>
		  if (SubMenu==MENU_DONE)stMenuAdmin=maExitMenuAdmin;
   1295a:	81 30       	cpi	r24, 0x01	; 1
   1295c:	81 f4       	brne	.+32     	; 0x1297e <FMenuAdmin+0xe6>
   1295e:	87 e0       	ldi	r24, 0x07	; 7
   12960:	80 93 9c 02 	sts	0x029C, r24
   12964:	06 c0       	rjmp	.+12     	; 0x12972 <FMenuAdmin+0xda>
	      break;
     case maMenuAdminSettings:
	      SubMenu=FMenuAdminSettings();
   12966:	0e 94 c5 8f 	call	0x11f8a	; 0x11f8a <FMenuAdminSettings>
		  if (SubMenu==MENU_DONE)stMenuAdmin=maInitAdmin;	      
   1296a:	81 30       	cpi	r24, 0x01	; 1
   1296c:	41 f4       	brne	.+16     	; 0x1297e <FMenuAdmin+0xe6>
   1296e:	10 92 9c 02 	sts	0x029C, r1
   12972:	80 e0       	ldi	r24, 0x00	; 0
   12974:	08 95       	ret
	      break;
     case maExitMenuAdmin:
	      stMenuAdmin=maInitAdmin;	      
   12976:	10 92 9c 02 	sts	0x029C, r1
   1297a:	81 e0       	ldi	r24, 0x01	; 1
   1297c:	08 95       	ret
   1297e:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
          break;	 
	 }
   return Result;
}
   12980:	08 95       	ret

00012982 <FMenuChangeMOP>:
	      break;
	 }
   return Result;
}

char FMenuChangeMOP(){
   12982:	af 92       	push	r10
   12984:	bf 92       	push	r11
   12986:	cf 92       	push	r12
   12988:	df 92       	push	r13
   1298a:	ef 92       	push	r14
   1298c:	ff 92       	push	r15
   1298e:	0f 93       	push	r16
   12990:	1f 93       	push	r17
   12992:	df 93       	push	r29
   12994:	cf 93       	push	r28
   12996:	cd b7       	in	r28, 0x3d	; 61
   12998:	de b7       	in	r29, 0x3e	; 62
   1299a:	a3 97       	sbiw	r28, 0x23	; 35
   1299c:	0f b6       	in	r0, 0x3f	; 63
   1299e:	f8 94       	cli
   129a0:	de bf       	out	0x3e, r29	; 62
   129a2:	0f be       	out	0x3f, r0	; 63
   129a4:	cd bf       	out	0x3d, r28	; 61
       char lcdteks[20],i,msgResult;       
	   char strBankName[11],strSurcharge[4],Result;
       char uiResult,KeyPressed=0,KeyChar,FIPResult;

     Result=MENU_NONE; 
	 switch(stChangeMOP){
   129a6:	80 91 b3 02 	lds	r24, 0x02B3
   129aa:	e8 2f       	mov	r30, r24
   129ac:	f0 e0       	ldi	r31, 0x00	; 0
   129ae:	ee 31       	cpi	r30, 0x1E	; 30
   129b0:	f1 05       	cpc	r31, r1
   129b2:	08 f0       	brcs	.+2      	; 0x129b6 <FMenuChangeMOP+0x34>
   129b4:	0c c4       	rjmp	.+2072   	; 0x131ce <FMenuChangeMOP+0x84c>
   129b6:	e3 53       	subi	r30, 0x33	; 51
   129b8:	ff 4f       	sbci	r31, 0xFF	; 255
   129ba:	ee 0f       	add	r30, r30
   129bc:	ff 1f       	adc	r31, r31
   129be:	05 90       	lpm	r0, Z+
   129c0:	f4 91       	lpm	r31, Z+
   129c2:	e0 2d       	mov	r30, r0
   129c4:	09 94       	ijmp
	 case cmInit:
	      MOPType=PAY_NONE;
   129c6:	85 e0       	ldi	r24, 0x05	; 5
   129c8:	80 93 ba 01 	sts	0x01BA, r24
   129cc:	3c c1       	rjmp	.+632    	; 0x12c46 <FMenuChangeMOP+0x2c4>
		  stChangeMOP=cmDisplayMOPOption;
	      break;
	 case cmDisplayMOPOption: //12345678901234567890
	      lcd_clear();
   129ce:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
	      lcd_printf(1,1,PSTR("   Select Payment   "));
   129d2:	81 e0       	ldi	r24, 0x01	; 1
   129d4:	61 e0       	ldi	r22, 0x01	; 1
   129d6:	4b ee       	ldi	r20, 0xEB	; 235
   129d8:	59 e1       	ldi	r21, 0x19	; 25
   129da:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
	      lcd_printf(2,1,PSTR("1.Account 3.Voucher "));
   129de:	82 e0       	ldi	r24, 0x02	; 2
   129e0:	61 e0       	ldi	r22, 0x01	; 1
   129e2:	46 ed       	ldi	r20, 0xD6	; 214
   129e4:	59 e1       	ldi	r21, 0x19	; 25
   129e6:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
	      lcd_printf(3,1,PSTR("2.Bank    4.PumpTest"));
   129ea:	83 e0       	ldi	r24, 0x03	; 3
   129ec:	61 e0       	ldi	r22, 0x01	; 1
   129ee:	41 ec       	ldi	r20, 0xC1	; 193
   129f0:	59 e1       	ldi	r21, 0x19	; 25
   129f2:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
	      lcd_printf(4,1,PSTR("[*]Back             "));
   129f6:	84 e0       	ldi	r24, 0x04	; 4
   129f8:	61 e0       	ldi	r22, 0x01	; 1
   129fa:	4c ea       	ldi	r20, 0xAC	; 172
   129fc:	59 e1       	ldi	r21, 0x19	; 25
   129fe:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
          stChangeMOP=cmInputMOP;		 
   12a02:	82 e0       	ldi	r24, 0x02	; 2
   12a04:	a2 c1       	rjmp	.+836    	; 0x12d4a <FMenuChangeMOP+0x3c8>
		  break;
	 case cmInputMOP:
	      KeyPressed=_key_scan(1);
   12a06:	81 e0       	ldi	r24, 0x01	; 1
   12a08:	0e 94 84 ae 	call	0x15d08	; 0x15d08 <_key_scan>
   12a0c:	18 2f       	mov	r17, r24
		  KeyChar=_key_btn(KeyPressed);
   12a0e:	0e 94 e5 ad 	call	0x15bca	; 0x15bca <_key_btn>
   12a12:	98 2f       	mov	r25, r24
		  if ((KeyChar>='1')&&(KeyChar<='4')){
   12a14:	81 53       	subi	r24, 0x31	; 49
   12a16:	84 30       	cpi	r24, 0x04	; 4
   12a18:	f0 f4       	brcc	.+60     	; 0x12a56 <FMenuChangeMOP+0xd4>
              switch(KeyChar){
   12a1a:	92 33       	cpi	r25, 0x32	; 50
   12a1c:	61 f0       	breq	.+24     	; 0x12a36 <FMenuChangeMOP+0xb4>
   12a1e:	93 33       	cpi	r25, 0x33	; 51
   12a20:	18 f4       	brcc	.+6      	; 0x12a28 <FMenuChangeMOP+0xa6>
   12a22:	91 33       	cpi	r25, 0x31	; 49
   12a24:	c1 f4       	brne	.+48     	; 0x12a56 <FMenuChangeMOP+0xd4>
   12a26:	05 c0       	rjmp	.+10     	; 0x12a32 <FMenuChangeMOP+0xb0>
   12a28:	93 33       	cpi	r25, 0x33	; 51
   12a2a:	51 f0       	breq	.+20     	; 0x12a40 <FMenuChangeMOP+0xbe>
   12a2c:	94 33       	cpi	r25, 0x34	; 52
   12a2e:	99 f4       	brne	.+38     	; 0x12a56 <FMenuChangeMOP+0xd4>
   12a30:	0c c0       	rjmp	.+24     	; 0x12a4a <FMenuChangeMOP+0xc8>
		        case '1':MOPType=PAY_ACCOUNT; stChangeMOP=cmSelectFIP;         break;
   12a32:	81 e0       	ldi	r24, 0x01	; 1
   12a34:	0b c0       	rjmp	.+22     	; 0x12a4c <FMenuChangeMOP+0xca>
		        case '2':MOPType=PAY_BANK;    stChangeMOP=cmSelectBankName;    break;
   12a36:	82 e0       	ldi	r24, 0x02	; 2
   12a38:	80 93 ba 01 	sts	0x01BA, r24
   12a3c:	8b e0       	ldi	r24, 0x0B	; 11
   12a3e:	09 c0       	rjmp	.+18     	; 0x12a52 <FMenuChangeMOP+0xd0>
		        case '3':MOPType=PAY_VOUCHER; stChangeMOP=cmDispInputVoucher;  break;
   12a40:	83 e0       	ldi	r24, 0x03	; 3
   12a42:	80 93 ba 01 	sts	0x01BA, r24
   12a46:	8f e0       	ldi	r24, 0x0F	; 15
   12a48:	04 c0       	rjmp	.+8      	; 0x12a52 <FMenuChangeMOP+0xd0>
		        case '4':MOPType=PAY_PUMPTEST;stChangeMOP=cmSelectFIP;         break;
   12a4a:	84 e0       	ldi	r24, 0x04	; 4
   12a4c:	80 93 ba 01 	sts	0x01BA, r24
   12a50:	89 e0       	ldi	r24, 0x09	; 9
   12a52:	80 93 b3 02 	sts	0x02B3, r24
		     }
		  }
		  if (KeyPressed==_KEY_CANCEL) stChangeMOP=cmExitChangeMOP;
   12a56:	17 3e       	cpi	r17, 0xE7	; 231
   12a58:	09 f0       	breq	.+2      	; 0x12a5c <FMenuChangeMOP+0xda>
   12a5a:	b9 c3       	rjmp	.+1906   	; 0x131ce <FMenuChangeMOP+0x84c>
   12a5c:	b0 c3       	rjmp	.+1888   	; 0x131be <FMenuChangeMOP+0x83c>
	      break;
	 case cmDispInputVoucher://Enter Voucher number
          lcd_clear();
   12a5e:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
		  lcd_printf(1,1,PSTR("Kode Voucher"));
   12a62:	81 e0       	ldi	r24, 0x01	; 1
   12a64:	61 e0       	ldi	r22, 0x01	; 1
   12a66:	4f e9       	ldi	r20, 0x9F	; 159
   12a68:	59 e1       	ldi	r21, 0x19	; 25
   12a6a:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		  lcd_printf(2,1,PSTR("_"));
   12a6e:	82 e0       	ldi	r24, 0x02	; 2
   12a70:	61 e0       	ldi	r22, 0x01	; 1
   12a72:	4d e9       	ldi	r20, 0x9D	; 157
   12a74:	59 e1       	ldi	r21, 0x19	; 25
   12a76:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		  lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   12a7a:	84 e0       	ldi	r24, 0x04	; 4
   12a7c:	61 e0       	ldi	r22, 0x01	; 1
   12a7e:	48 e8       	ldi	r20, 0x88	; 136
   12a80:	59 e1       	ldi	r21, 0x19	; 25
   12a82:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
   12a86:	e3 e7       	ldi	r30, 0x73	; 115
   12a88:	fd e0       	ldi	r31, 0x0D	; 13
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
   12a8a:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   12a8c:	8d e0       	ldi	r24, 0x0D	; 13
   12a8e:	e8 38       	cpi	r30, 0x88	; 136
   12a90:	f8 07       	cpc	r31, r24
   12a92:	d9 f7       	brne	.-10     	; 0x12a8a <FMenuChangeMOP+0x108>
          lcd_clear();
		  lcd_printf(1,1,PSTR("Kode Voucher"));
		  lcd_printf(2,1,PSTR("_"));
		  lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
		  FillChar(strVoucherNum,sizeof(strVoucherNum),0);
          stChangeMOP=cmInputVoucher;		  
   12a94:	87 e0       	ldi	r24, 0x07	; 7
   12a96:	59 c1       	rjmp	.+690    	; 0x12d4a <FMenuChangeMOP+0x3c8>
	      break;
     case cmInputVoucher:
          uiResult=UserInput(UI_NUMBER_R,2,1,strVoucherNum,0,13);
   12a98:	81 e0       	ldi	r24, 0x01	; 1
   12a9a:	62 e0       	ldi	r22, 0x02	; 2
   12a9c:	41 e0       	ldi	r20, 0x01	; 1
   12a9e:	23 e7       	ldi	r18, 0x73	; 115
   12aa0:	3d e0       	ldi	r19, 0x0D	; 13
   12aa2:	00 e0       	ldi	r16, 0x00	; 0
   12aa4:	10 e0       	ldi	r17, 0x00	; 0
   12aa6:	5d e0       	ldi	r21, 0x0D	; 13
   12aa8:	e5 2e       	mov	r14, r21
   12aaa:	0e 94 d8 7d 	call	0xfbb0	; 0xfbb0 <UserInput>
	      if (uiResult==USER_OK){
   12aae:	83 30       	cpi	r24, 0x03	; 3
   12ab0:	11 f4       	brne	.+4      	; 0x12ab6 <FMenuChangeMOP+0x134>
		     stChangeMOP=cmSelectFIP;
   12ab2:	89 e0       	ldi	r24, 0x09	; 9
   12ab4:	4a c1       	rjmp	.+660    	; 0x12d4a <FMenuChangeMOP+0x3c8>
			 }
		  else
	      if (uiResult==USER_CANCEL)stChangeMOP=cmDisplayMOPOption;
   12ab6:	81 30       	cpi	r24, 0x01	; 1
   12ab8:	09 f4       	brne	.+2      	; 0x12abc <FMenuChangeMOP+0x13a>
   12aba:	47 c1       	rjmp	.+654    	; 0x12d4a <FMenuChangeMOP+0x3c8>
		  else
		  if (uiResult==USER_ENTRY)lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   12abc:	84 30       	cpi	r24, 0x04	; 4
   12abe:	21 f4       	brne	.+8      	; 0x12ac8 <FMenuChangeMOP+0x146>
   12ac0:	61 e0       	ldi	r22, 0x01	; 1
   12ac2:	43 e7       	ldi	r20, 0x73	; 115
   12ac4:	59 e1       	ldi	r21, 0x19	; 25
   12ac6:	29 c1       	rjmp	.+594    	; 0x12d1a <FMenuChangeMOP+0x398>
		  else
		  if (uiResult==USER_NO_DATA)lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   12ac8:	85 30       	cpi	r24, 0x05	; 5
   12aca:	09 f0       	breq	.+2      	; 0x12ace <FMenuChangeMOP+0x14c>
   12acc:	80 c3       	rjmp	.+1792   	; 0x131ce <FMenuChangeMOP+0x84c>
   12ace:	84 e0       	ldi	r24, 0x04	; 4
   12ad0:	61 e0       	ldi	r22, 0x01	; 1
   12ad2:	4e e5       	ldi	r20, 0x5E	; 94
   12ad4:	59 e1       	ldi	r21, 0x19	; 25
   12ad6:	21 c1       	rjmp	.+578    	; 0x12d1a <FMenuChangeMOP+0x398>
	      break;
	 case cmSelectFIP:
	      FIPResult=menu_FIP(&FIP_Used,strFIP_ID);
   12ad8:	82 eb       	ldi	r24, 0xB2	; 178
   12ada:	92 e0       	ldi	r25, 0x02	; 2
   12adc:	6b ec       	ldi	r22, 0xCB	; 203
   12ade:	78 e0       	ldi	r23, 0x08	; 8
   12ae0:	0e 94 b5 65 	call	0xcb6a	; 0xcb6a <menu_FIP>
		  if (FIPResult==FIP_DONE){
   12ae4:	88 23       	and	r24, r24
   12ae6:	11 f4       	brne	.+4      	; 0x12aec <FMenuChangeMOP+0x16a>
		      //sprintf_P(strFIP_ID,PSTR("%.2d"),FIP_Used);
		      stChangeMOP=cmFlowFIP;
   12ae8:	8e e0       	ldi	r24, 0x0E	; 14
   12aea:	2f c1       	rjmp	.+606    	; 0x12d4a <FMenuChangeMOP+0x3c8>
		  }
		  else
		  if (FIPResult==FIP_CANCEL){
   12aec:	82 30       	cpi	r24, 0x02	; 2
   12aee:	09 f0       	breq	.+2      	; 0x12af2 <FMenuChangeMOP+0x170>
   12af0:	6e c3       	rjmp	.+1756   	; 0x131ce <FMenuChangeMOP+0x84c>
		      if (MOPType==PAY_ACCOUNT)stChangeMOP=cmDisplayMOPOption;
   12af2:	80 91 ba 01 	lds	r24, 0x01BA
   12af6:	81 30       	cpi	r24, 0x01	; 1
   12af8:	09 f4       	brne	.+2      	; 0x12afc <FMenuChangeMOP+0x17a>
   12afa:	27 c1       	rjmp	.+590    	; 0x12d4a <FMenuChangeMOP+0x3c8>
		      if (MOPType==PAY_BANK)stChangeMOP=cmSelectBankName;
   12afc:	82 30       	cpi	r24, 0x02	; 2
   12afe:	09 f4       	brne	.+2      	; 0x12b02 <FMenuChangeMOP+0x180>
   12b00:	fd c0       	rjmp	.+506    	; 0x12cfc <FMenuChangeMOP+0x37a>
		      if (MOPType==PAY_VOUCHER)stChangeMOP=cmDispInputVoucher;
   12b02:	83 30       	cpi	r24, 0x03	; 3
   12b04:	11 f4       	brne	.+4      	; 0x12b0a <FMenuChangeMOP+0x188>
   12b06:	8f e0       	ldi	r24, 0x0F	; 15
   12b08:	20 c1       	rjmp	.+576    	; 0x12d4a <FMenuChangeMOP+0x3c8>
		      if (MOPType==PAY_PUMPTEST)stChangeMOP=cmDisplayMOPOption;		  
   12b0a:	84 30       	cpi	r24, 0x04	; 4
   12b0c:	09 f4       	brne	.+2      	; 0x12b10 <FMenuChangeMOP+0x18e>
   12b0e:	9b c0       	rjmp	.+310    	; 0x12c46 <FMenuChangeMOP+0x2c4>
   12b10:	5e c3       	rjmp	.+1724   	; 0x131ce <FMenuChangeMOP+0x84c>
     case cmSelectFIPInput:
		
	      break;
		  //Load Bank Information
	 case cmSelectBankName:
	      lcd_clear();
   12b12:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
		  lcd_printf(1,1,PSTR("Select Bank"));
   12b16:	81 e0       	ldi	r24, 0x01	; 1
   12b18:	61 e0       	ldi	r22, 0x01	; 1
   12b1a:	42 e5       	ldi	r20, 0x52	; 82
   12b1c:	59 e1       	ldi	r21, 0x19	; 25
   12b1e:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		  iLoop=0;
	      for(iLoop=0;iLoop<4;iLoop++){
   12b22:	10 92 ae 02 	sts	0x02AE, r1
   12b26:	10 92 ad 02 	sts	0x02AD, r1
   12b2a:	8e 01       	movw	r16, r28
   12b2c:	0b 5f       	subi	r16, 0xFB	; 251
   12b2e:	1f 4f       	sbci	r17, 0xFF	; 255
   12b30:	9b e0       	ldi	r25, 0x0B	; 11
   12b32:	a9 2e       	mov	r10, r25
   12b34:	b1 2c       	mov	r11, r1
			  eeprom_read_block((void*) &strBankName, (const void*) &DefBankName[iLoop], 11);
			  if (strlen(strBankName<=10)){
			     sprintf_P(lcdteks,PSTR("%d.%s"),(iLoop+1),strBankName);
   12b36:	80 e1       	ldi	r24, 0x10	; 16
   12b38:	e8 2e       	mov	r14, r24
   12b3a:	f1 2c       	mov	r15, r1
   12b3c:	ec 0e       	add	r14, r28
   12b3e:	fd 1e       	adc	r15, r29
   12b40:	bc e4       	ldi	r27, 0x4C	; 76
   12b42:	cb 2e       	mov	r12, r27
   12b44:	b9 e1       	ldi	r27, 0x19	; 25
   12b46:	db 2e       	mov	r13, r27
   12b48:	5d c0       	rjmp	.+186    	; 0x12c04 <FMenuChangeMOP+0x282>
   12b4a:	8a 9d       	mul	r24, r10
   12b4c:	b0 01       	movw	r22, r0
   12b4e:	8b 9d       	mul	r24, r11
   12b50:	70 0d       	add	r23, r0
   12b52:	9a 9d       	mul	r25, r10
   12b54:	70 0d       	add	r23, r0
   12b56:	11 24       	eor	r1, r1
   12b58:	67 5f       	subi	r22, 0xF7	; 247
   12b5a:	7e 4f       	sbci	r23, 0xFE	; 254
   12b5c:	c8 01       	movw	r24, r16
   12b5e:	4b e0       	ldi	r20, 0x0B	; 11
   12b60:	50 e0       	ldi	r21, 0x00	; 0
   12b62:	2d ef       	ldi	r18, 0xFD	; 253
   12b64:	32 e1       	ldi	r19, 0x12	; 18
   12b66:	0e 94 f1 b3 	call	0x167e2	; 0x167e2 <__eerd_block>
	      lcd_clear();
		  lcd_printf(1,1,PSTR("Select Bank"));
		  iLoop=0;
	      for(iLoop=0;iLoop<4;iLoop++){
			  eeprom_read_block((void*) &strBankName, (const void*) &DefBankName[iLoop], 11);
			  if (strlen(strBankName<=10)){
   12b6a:	e0 e0       	ldi	r30, 0x00	; 0
   12b6c:	f0 e0       	ldi	r31, 0x00	; 0
   12b6e:	0b 30       	cpi	r16, 0x0B	; 11
   12b70:	11 05       	cpc	r17, r1
   12b72:	10 f4       	brcc	.+4      	; 0x12b78 <FMenuChangeMOP+0x1f6>
   12b74:	e1 e0       	ldi	r30, 0x01	; 1
   12b76:	f0 e0       	ldi	r31, 0x00	; 0
   12b78:	80 81       	ld	r24, Z
   12b7a:	88 23       	and	r24, r24
   12b7c:	d1 f1       	breq	.+116    	; 0x12bf2 <FMenuChangeMOP+0x270>
			     sprintf_P(lcdteks,PSTR("%d.%s"),(iLoop+1),strBankName);
   12b7e:	ad b7       	in	r26, 0x3d	; 61
   12b80:	be b7       	in	r27, 0x3e	; 62
   12b82:	18 97       	sbiw	r26, 0x08	; 8
   12b84:	0f b6       	in	r0, 0x3f	; 63
   12b86:	f8 94       	cli
   12b88:	be bf       	out	0x3e, r27	; 62
   12b8a:	0f be       	out	0x3f, r0	; 63
   12b8c:	ad bf       	out	0x3d, r26	; 61
   12b8e:	ed b7       	in	r30, 0x3d	; 61
   12b90:	fe b7       	in	r31, 0x3e	; 62
   12b92:	31 96       	adiw	r30, 0x01	; 1
   12b94:	12 96       	adiw	r26, 0x02	; 2
   12b96:	fc 92       	st	X, r15
   12b98:	ee 92       	st	-X, r14
   12b9a:	11 97       	sbiw	r26, 0x01	; 1
   12b9c:	d3 82       	std	Z+3, r13	; 0x03
   12b9e:	c2 82       	std	Z+2, r12	; 0x02
   12ba0:	80 91 ad 02 	lds	r24, 0x02AD
   12ba4:	90 91 ae 02 	lds	r25, 0x02AE
   12ba8:	01 96       	adiw	r24, 0x01	; 1
   12baa:	95 83       	std	Z+5, r25	; 0x05
   12bac:	84 83       	std	Z+4, r24	; 0x04
   12bae:	17 83       	std	Z+7, r17	; 0x07
   12bb0:	06 83       	std	Z+6, r16	; 0x06
   12bb2:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
			     lcd_print((2+(iLoop%2)),(1+((iLoop/2)*12)),lcdteks);
   12bb6:	20 91 ad 02 	lds	r18, 0x02AD
   12bba:	30 91 ae 02 	lds	r19, 0x02AE
   12bbe:	ed b7       	in	r30, 0x3d	; 61
   12bc0:	fe b7       	in	r31, 0x3e	; 62
   12bc2:	38 96       	adiw	r30, 0x08	; 8
   12bc4:	0f b6       	in	r0, 0x3f	; 63
   12bc6:	f8 94       	cli
   12bc8:	fe bf       	out	0x3e, r31	; 62
   12bca:	0f be       	out	0x3f, r0	; 63
   12bcc:	ed bf       	out	0x3d, r30	; 61
   12bce:	82 2f       	mov	r24, r18
   12bd0:	81 70       	andi	r24, 0x01	; 1
   12bd2:	36 95       	lsr	r19
   12bd4:	27 95       	ror	r18
   12bd6:	b9 01       	movw	r22, r18
   12bd8:	66 0f       	add	r22, r22
   12bda:	77 1f       	adc	r23, r23
   12bdc:	62 0f       	add	r22, r18
   12bde:	73 1f       	adc	r23, r19
   12be0:	66 0f       	add	r22, r22
   12be2:	77 1f       	adc	r23, r23
   12be4:	66 0f       	add	r22, r22
   12be6:	77 1f       	adc	r23, r23
   12be8:	6f 5f       	subi	r22, 0xFF	; 255
   12bea:	8e 5f       	subi	r24, 0xFE	; 254
   12bec:	a7 01       	movw	r20, r14
   12bee:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
		  //Load Bank Information
	 case cmSelectBankName:
	      lcd_clear();
		  lcd_printf(1,1,PSTR("Select Bank"));
		  iLoop=0;
	      for(iLoop=0;iLoop<4;iLoop++){
   12bf2:	80 91 ad 02 	lds	r24, 0x02AD
   12bf6:	90 91 ae 02 	lds	r25, 0x02AE
   12bfa:	01 96       	adiw	r24, 0x01	; 1
   12bfc:	90 93 ae 02 	sts	0x02AE, r25
   12c00:	80 93 ad 02 	sts	0x02AD, r24
   12c04:	80 91 ad 02 	lds	r24, 0x02AD
   12c08:	90 91 ae 02 	lds	r25, 0x02AE
   12c0c:	84 30       	cpi	r24, 0x04	; 4
   12c0e:	91 05       	cpc	r25, r1
   12c10:	08 f4       	brcc	.+2      	; 0x12c14 <FMenuChangeMOP+0x292>
   12c12:	9b cf       	rjmp	.-202    	; 0x12b4a <FMenuChangeMOP+0x1c8>
			  if (strlen(strBankName<=10)){
			     sprintf_P(lcdteks,PSTR("%d.%s"),(iLoop+1),strBankName);
			     lcd_print((2+(iLoop%2)),(1+((iLoop/2)*12)),lcdteks);
				 }
		  }
	      lcd_printf(4,1,PSTR("[*]Back"));
   12c14:	84 e0       	ldi	r24, 0x04	; 4
   12c16:	61 e0       	ldi	r22, 0x01	; 1
   12c18:	44 e4       	ldi	r20, 0x44	; 68
   12c1a:	59 e1       	ldi	r21, 0x19	; 25
   12c1c:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		  stChangeMOP=cmSelectBankNameInput;
   12c20:	8c e0       	ldi	r24, 0x0C	; 12
   12c22:	93 c0       	rjmp	.+294    	; 0x12d4a <FMenuChangeMOP+0x3c8>
	      break;
     case cmSelectBankNameInput:
		  KeyPressed=_key_scan(1);
   12c24:	81 e0       	ldi	r24, 0x01	; 1
   12c26:	0e 94 84 ae 	call	0x15d08	; 0x15d08 <_key_scan>
   12c2a:	18 2f       	mov	r17, r24
		  KeyChar=_key_btn(KeyPressed);
   12c2c:	0e 94 e5 ad 	call	0x15bca	; 0x15bca <_key_btn>
          if ((KeyChar>='1')&&(KeyChar<='4')){
   12c30:	81 53       	subi	r24, 0x31	; 49
   12c32:	84 30       	cpi	r24, 0x04	; 4
   12c34:	28 f4       	brcc	.+10     	; 0x12c40 <FMenuChangeMOP+0x2be>
		      BankIdx=KeyChar-'1';
   12c36:	80 93 b1 02 	sts	0x02B1, r24
			  stChangeMOP=cmSelectFIP;
   12c3a:	89 e0       	ldi	r24, 0x09	; 9
   12c3c:	80 93 b3 02 	sts	0x02B3, r24
		  }
		  if (KeyPressed==_KEY_CANCEL) stChangeMOP=cmDisplayMOPOption;
   12c40:	17 3e       	cpi	r17, 0xE7	; 231
   12c42:	09 f0       	breq	.+2      	; 0x12c46 <FMenuChangeMOP+0x2c4>
   12c44:	c4 c2       	rjmp	.+1416   	; 0x131ce <FMenuChangeMOP+0x84c>
   12c46:	81 e0       	ldi	r24, 0x01	; 1
   12c48:	80 c0       	rjmp	.+256    	; 0x12d4a <FMenuChangeMOP+0x3c8>

	      break;
     case cmDispBankSurcharge:
	      lcd_clear();
   12c4a:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
   12c4e:	65 e0       	ldi	r22, 0x05	; 5
   12c50:	e6 2e       	mov	r14, r22
   12c52:	f1 2c       	mov	r15, r1
   12c54:	ec 0e       	add	r14, r28
   12c56:	fd 1e       	adc	r15, r29
   12c58:	60 91 b1 02 	lds	r22, 0x02B1
   12c5c:	8b e0       	ldi	r24, 0x0B	; 11
   12c5e:	68 9f       	mul	r22, r24
   12c60:	b0 01       	movw	r22, r0
   12c62:	11 24       	eor	r1, r1
   12c64:	67 5f       	subi	r22, 0xF7	; 247
   12c66:	7e 4f       	sbci	r23, 0xFE	; 254
   12c68:	c7 01       	movw	r24, r14
   12c6a:	4b e0       	ldi	r20, 0x0B	; 11
   12c6c:	50 e0       	ldi	r21, 0x00	; 0
   12c6e:	2d ef       	ldi	r18, 0xFD	; 253
   12c70:	32 e1       	ldi	r19, 0x12	; 18
   12c72:	0e 94 f1 b3 	call	0x167e2	; 0x167e2 <__eerd_block>
		  eeprom_read_block((void*) &strBankName, (const void*) &DefBankName[BankIdx], 11);
		  sprintf_P(lcdteks,PSTR("%s"),strBankName);
   12c76:	00 d0       	rcall	.+0      	; 0x12c78 <FMenuChangeMOP+0x2f6>
   12c78:	00 d0       	rcall	.+0      	; 0x12c7a <FMenuChangeMOP+0x2f8>
   12c7a:	00 d0       	rcall	.+0      	; 0x12c7c <FMenuChangeMOP+0x2fa>
   12c7c:	ed b7       	in	r30, 0x3d	; 61
   12c7e:	fe b7       	in	r31, 0x3e	; 62
   12c80:	31 96       	adiw	r30, 0x01	; 1
   12c82:	8e 01       	movw	r16, r28
   12c84:	00 5f       	subi	r16, 0xF0	; 240
   12c86:	1f 4f       	sbci	r17, 0xFF	; 255
   12c88:	ad b7       	in	r26, 0x3d	; 61
   12c8a:	be b7       	in	r27, 0x3e	; 62
   12c8c:	12 96       	adiw	r26, 0x02	; 2
   12c8e:	1c 93       	st	X, r17
   12c90:	0e 93       	st	-X, r16
   12c92:	11 97       	sbiw	r26, 0x01	; 1
   12c94:	81 e4       	ldi	r24, 0x41	; 65
   12c96:	99 e1       	ldi	r25, 0x19	; 25
   12c98:	93 83       	std	Z+3, r25	; 0x03
   12c9a:	82 83       	std	Z+2, r24	; 0x02
   12c9c:	f5 82       	std	Z+5, r15	; 0x05
   12c9e:	e4 82       	std	Z+4, r14	; 0x04
   12ca0:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
		  lcd_print(1,1,lcdteks);
   12ca4:	ed b7       	in	r30, 0x3d	; 61
   12ca6:	fe b7       	in	r31, 0x3e	; 62
   12ca8:	36 96       	adiw	r30, 0x06	; 6
   12caa:	0f b6       	in	r0, 0x3f	; 63
   12cac:	f8 94       	cli
   12cae:	fe bf       	out	0x3e, r31	; 62
   12cb0:	0f be       	out	0x3f, r0	; 63
   12cb2:	ed bf       	out	0x3d, r30	; 61
   12cb4:	81 e0       	ldi	r24, 0x01	; 1
   12cb6:	61 e0       	ldi	r22, 0x01	; 1
   12cb8:	a8 01       	movw	r20, r16
   12cba:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
		  lcd_printf(2,1,PSTR("Surcharge:   _%"));
   12cbe:	82 e0       	ldi	r24, 0x02	; 2
   12cc0:	61 e0       	ldi	r22, 0x01	; 1
   12cc2:	41 e3       	ldi	r20, 0x31	; 49
   12cc4:	59 e1       	ldi	r21, 0x19	; 25
   12cc6:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
	      lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   12cca:	84 e0       	ldi	r24, 0x04	; 4
   12ccc:	61 e0       	ldi	r22, 0x01	; 1
   12cce:	4c e1       	ldi	r20, 0x1C	; 28
   12cd0:	59 e1       	ldi	r21, 0x19	; 25
   12cd2:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
          stChangeMOP=cmInputBankSurcharge;
   12cd6:	8d e0       	ldi	r24, 0x0D	; 13
   12cd8:	38 c0       	rjmp	.+112    	; 0x12d4a <FMenuChangeMOP+0x3c8>
	      break;
	 case cmInputBankSurcharge:
	      //uiResult=UserInput(UI_NUMBER_L,2,14,ValueChar,100,3);
		  uiResult=UserInput(UI_NUMBER_L,2,14,strSurcharge,100,3);
   12cda:	82 e0       	ldi	r24, 0x02	; 2
   12cdc:	62 e0       	ldi	r22, 0x02	; 2
   12cde:	4e e0       	ldi	r20, 0x0E	; 14
   12ce0:	9e 01       	movw	r18, r28
   12ce2:	2f 5f       	subi	r18, 0xFF	; 255
   12ce4:	3f 4f       	sbci	r19, 0xFF	; 255
   12ce6:	04 e6       	ldi	r16, 0x64	; 100
   12ce8:	10 e0       	ldi	r17, 0x00	; 0
   12cea:	53 e0       	ldi	r21, 0x03	; 3
   12cec:	e5 2e       	mov	r14, r21
   12cee:	0e 94 d8 7d 	call	0xfbb0	; 0xfbb0 <UserInput>
	      if (uiResult==USER_OK)stChangeMOP=cmGenerateData;
   12cf2:	83 30       	cpi	r24, 0x03	; 3
   12cf4:	09 f4       	brne	.+2      	; 0x12cf8 <FMenuChangeMOP+0x376>
   12cf6:	c6 c0       	rjmp	.+396    	; 0x12e84 <FMenuChangeMOP+0x502>
		  else
	      if (uiResult==USER_CANCEL)stChangeMOP=cmSelectBankName;
   12cf8:	81 30       	cpi	r24, 0x01	; 1
   12cfa:	11 f4       	brne	.+4      	; 0x12d00 <FMenuChangeMOP+0x37e>
   12cfc:	8b e0       	ldi	r24, 0x0B	; 11
   12cfe:	25 c0       	rjmp	.+74     	; 0x12d4a <FMenuChangeMOP+0x3c8>
		  else
		  if (uiResult==USER_ENTRY)lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   12d00:	84 30       	cpi	r24, 0x04	; 4
   12d02:	21 f4       	brne	.+8      	; 0x12d0c <FMenuChangeMOP+0x38a>
   12d04:	61 e0       	ldi	r22, 0x01	; 1
   12d06:	47 e0       	ldi	r20, 0x07	; 7
   12d08:	59 e1       	ldi	r21, 0x19	; 25
   12d0a:	07 c0       	rjmp	.+14     	; 0x12d1a <FMenuChangeMOP+0x398>
		  else
		  if (uiResult==USER_NO_DATA)lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   12d0c:	85 30       	cpi	r24, 0x05	; 5
   12d0e:	09 f0       	breq	.+2      	; 0x12d12 <FMenuChangeMOP+0x390>
   12d10:	5e c2       	rjmp	.+1212   	; 0x131ce <FMenuChangeMOP+0x84c>
   12d12:	84 e0       	ldi	r24, 0x04	; 4
   12d14:	61 e0       	ldi	r22, 0x01	; 1
   12d16:	42 ef       	ldi	r20, 0xF2	; 242
   12d18:	58 e1       	ldi	r21, 0x18	; 24
   12d1a:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
   12d1e:	57 c2       	rjmp	.+1198   	; 0x131ce <FMenuChangeMOP+0x84c>
	      break;
     case cmFlowFIP:
          switch(MOPType){
   12d20:	80 91 ba 01 	lds	r24, 0x01BA
   12d24:	82 30       	cpi	r24, 0x02	; 2
   12d26:	61 f0       	breq	.+24     	; 0x12d40 <FMenuChangeMOP+0x3be>
   12d28:	83 30       	cpi	r24, 0x03	; 3
   12d2a:	20 f4       	brcc	.+8      	; 0x12d34 <FMenuChangeMOP+0x3b2>
   12d2c:	81 30       	cpi	r24, 0x01	; 1
   12d2e:	09 f0       	breq	.+2      	; 0x12d32 <FMenuChangeMOP+0x3b0>
   12d30:	4e c2       	rjmp	.+1180   	; 0x131ce <FMenuChangeMOP+0x84c>
   12d32:	0a c0       	rjmp	.+20     	; 0x12d48 <FMenuChangeMOP+0x3c6>
   12d34:	83 30       	cpi	r24, 0x03	; 3
   12d36:	31 f0       	breq	.+12     	; 0x12d44 <FMenuChangeMOP+0x3c2>
   12d38:	84 30       	cpi	r24, 0x04	; 4
   12d3a:	09 f0       	breq	.+2      	; 0x12d3e <FMenuChangeMOP+0x3bc>
   12d3c:	48 c2       	rjmp	.+1168   	; 0x131ce <FMenuChangeMOP+0x84c>
   12d3e:	04 c0       	rjmp	.+8      	; 0x12d48 <FMenuChangeMOP+0x3c6>
		  case PAY_ACCOUNT: stChangeMOP=cmDispCardTap;       break;
		  case PAY_BANK:    stChangeMOP=cmDispBankSurcharge; break;
   12d40:	81 e1       	ldi	r24, 0x11	; 17
   12d42:	03 c0       	rjmp	.+6      	; 0x12d4a <FMenuChangeMOP+0x3c8>
		  case PAY_VOUCHER: stChangeMOP=cmProsesVoucher;      break;
   12d44:	85 e1       	ldi	r24, 0x15	; 21
   12d46:	01 c0       	rjmp	.+2      	; 0x12d4a <FMenuChangeMOP+0x3c8>
		  case PAY_PUMPTEST:stChangeMOP=cmDispCardTap;       break;
   12d48:	82 e1       	ldi	r24, 0x12	; 18
   12d4a:	80 93 b3 02 	sts	0x02B3, r24
   12d4e:	3f c2       	rjmp	.+1150   	; 0x131ce <FMenuChangeMOP+0x84c>
		  }
	      break;
     case cmDispCardTap:
	      lcd_clear();
   12d50:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
	      lcd_printf(1,1,PSTR("Tap Kartu RFID"));
   12d54:	81 e0       	ldi	r24, 0x01	; 1
   12d56:	61 e0       	ldi	r22, 0x01	; 1
   12d58:	43 ee       	ldi	r20, 0xE3	; 227
   12d5a:	58 e1       	ldi	r21, 0x18	; 24
   12d5c:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		  sprintf_P(lcdteks,PSTR("FIP%s"),strFIP_ID);
   12d60:	00 d0       	rcall	.+0      	; 0x12d62 <FMenuChangeMOP+0x3e0>
   12d62:	00 d0       	rcall	.+0      	; 0x12d64 <FMenuChangeMOP+0x3e2>
   12d64:	00 d0       	rcall	.+0      	; 0x12d66 <FMenuChangeMOP+0x3e4>
   12d66:	ed b7       	in	r30, 0x3d	; 61
   12d68:	fe b7       	in	r31, 0x3e	; 62
   12d6a:	31 96       	adiw	r30, 0x01	; 1
   12d6c:	8e 01       	movw	r16, r28
   12d6e:	00 5f       	subi	r16, 0xF0	; 240
   12d70:	1f 4f       	sbci	r17, 0xFF	; 255
   12d72:	ad b7       	in	r26, 0x3d	; 61
   12d74:	be b7       	in	r27, 0x3e	; 62
   12d76:	12 96       	adiw	r26, 0x02	; 2
   12d78:	1c 93       	st	X, r17
   12d7a:	0e 93       	st	-X, r16
   12d7c:	11 97       	sbiw	r26, 0x01	; 1
   12d7e:	8d ed       	ldi	r24, 0xDD	; 221
   12d80:	98 e1       	ldi	r25, 0x18	; 24
   12d82:	93 83       	std	Z+3, r25	; 0x03
   12d84:	82 83       	std	Z+2, r24	; 0x02
   12d86:	8b ec       	ldi	r24, 0xCB	; 203
   12d88:	98 e0       	ldi	r25, 0x08	; 8
   12d8a:	95 83       	std	Z+5, r25	; 0x05
   12d8c:	84 83       	std	Z+4, r24	; 0x04
   12d8e:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
		  lcd_print(2,1,lcdteks);
   12d92:	ed b7       	in	r30, 0x3d	; 61
   12d94:	fe b7       	in	r31, 0x3e	; 62
   12d96:	36 96       	adiw	r30, 0x06	; 6
   12d98:	0f b6       	in	r0, 0x3f	; 63
   12d9a:	f8 94       	cli
   12d9c:	fe bf       	out	0x3e, r31	; 62
   12d9e:	0f be       	out	0x3f, r0	; 63
   12da0:	ed bf       	out	0x3d, r30	; 61
   12da2:	82 e0       	ldi	r24, 0x02	; 2
   12da4:	61 e0       	ldi	r22, 0x01	; 1
   12da6:	a8 01       	movw	r20, r16
   12da8:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
          lcd_printf(4,1,PSTR("[*]Back    [#]Exit"));
   12dac:	84 e0       	ldi	r24, 0x04	; 4
   12dae:	61 e0       	ldi	r22, 0x01	; 1
   12db0:	4a ec       	ldi	r20, 0xCA	; 202
   12db2:	58 e1       	ldi	r21, 0x18	; 24
   12db4:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		  IsRFIDDetected=False;
   12db8:	10 92 9b 01 	sts	0x019B, r1
          stChangeMOP=cmRFIDCardInput;
   12dbc:	83 e1       	ldi	r24, 0x13	; 19
   12dbe:	c5 cf       	rjmp	.-118    	; 0x12d4a <FMenuChangeMOP+0x3c8>
	      break;
	 case cmRFIDCardInput:
		  KeyPressed=_key_scan(1);
   12dc0:	81 e0       	ldi	r24, 0x01	; 1
   12dc2:	0e 94 84 ae 	call	0x15d08	; 0x15d08 <_key_scan>
   12dc6:	18 2f       	mov	r17, r24
		  KeyChar=_key_btn(KeyPressed);
   12dc8:	0e 94 e5 ad 	call	0x15bca	; 0x15bca <_key_btn>
		  if (KeyPressed==_KEY_ENTER){
   12dcc:	17 3b       	cpi	r17, 0xB7	; 183
   12dce:	11 f4       	brne	.+4      	; 0x12dd4 <FMenuChangeMOP+0x452>
		      stChangeMOP=cmExitChangeMOP;
   12dd0:	8c e1       	ldi	r24, 0x1C	; 28
   12dd2:	03 c0       	rjmp	.+6      	; 0x12dda <FMenuChangeMOP+0x458>
		  }
		  else
		  if (KeyPressed==_KEY_CANCEL){
   12dd4:	17 3e       	cpi	r17, 0xE7	; 231
   12dd6:	19 f4       	brne	.+6      	; 0x12dde <FMenuChangeMOP+0x45c>
   		      stChangeMOP=cmSelectFIP;
   12dd8:	89 e0       	ldi	r24, 0x09	; 9
   12dda:	80 93 b3 02 	sts	0x02B3, r24
			 }
          if (IsRFIDDetected==True){
   12dde:	80 91 9b 01 	lds	r24, 0x019B
   12de2:	81 30       	cpi	r24, 0x01	; 1
   12de4:	09 f0       	breq	.+2      	; 0x12de8 <FMenuChangeMOP+0x466>
   12de6:	f3 c1       	rjmp	.+998    	; 0x131ce <FMenuChangeMOP+0x84c>
		      IsRFIDDetected=False;
   12de8:	10 92 9b 01 	sts	0x019B, r1
			   stChangeMOP=cmProsesRFID;
   12dec:	84 e1       	ldi	r24, 0x14	; 20
   12dee:	ad cf       	rjmp	.-166    	; 0x12d4a <FMenuChangeMOP+0x3c8>
   12df0:	20 e0       	ldi	r18, 0x00	; 0
   12df2:	30 e0       	ldi	r19, 0x00	; 0
}

void ViewCardID(){//+12345678 -->12345678
     char i;
	 for(i=0;i<8;i++){         //00000000000012345678
		strCardID[i]=strRFID[i];
   12df4:	f9 01       	movw	r30, r18
   12df6:	e3 54       	subi	r30, 0x43	; 67
   12df8:	f3 4f       	sbci	r31, 0xF3	; 243
   12dfa:	d9 01       	movw	r26, r18
   12dfc:	a8 57       	subi	r26, 0x78	; 120
   12dfe:	b2 4f       	sbci	r27, 0xF2	; 242
   12e00:	8c 91       	ld	r24, X
   12e02:	80 83       	st	Z, r24
   12e04:	2f 5f       	subi	r18, 0xFF	; 255
   12e06:	3f 4f       	sbci	r19, 0xFF	; 255

}

void ViewCardID(){//+12345678 -->12345678
     char i;
	 for(i=0;i<8;i++){         //00000000000012345678
   12e08:	28 30       	cpi	r18, 0x08	; 8
   12e0a:	31 05       	cpc	r19, r1
   12e0c:	99 f7       	brne	.-26     	; 0x12df4 <FMenuChangeMOP+0x472>
		strCardID[i]=strRFID[i];
	 }strCardID[8]=0;     
   12e0e:	10 92 c5 0c 	sts	0x0CC5, r1
			   stChangeMOP=cmProsesRFID;
			 }
	      break;
     case cmProsesRFID:
	      ViewCardID();
          sprintf_P(lcdteks,PSTR("ID:%s"),strCardID);lcd_print(2,1,lcdteks);
   12e12:	00 d0       	rcall	.+0      	; 0x12e14 <FMenuChangeMOP+0x492>
   12e14:	00 d0       	rcall	.+0      	; 0x12e16 <FMenuChangeMOP+0x494>
   12e16:	00 d0       	rcall	.+0      	; 0x12e18 <FMenuChangeMOP+0x496>
   12e18:	ed b7       	in	r30, 0x3d	; 61
   12e1a:	fe b7       	in	r31, 0x3e	; 62
   12e1c:	31 96       	adiw	r30, 0x01	; 1
   12e1e:	8e 01       	movw	r16, r28
   12e20:	00 5f       	subi	r16, 0xF0	; 240
   12e22:	1f 4f       	sbci	r17, 0xFF	; 255
   12e24:	ad b7       	in	r26, 0x3d	; 61
   12e26:	be b7       	in	r27, 0x3e	; 62
   12e28:	12 96       	adiw	r26, 0x02	; 2
   12e2a:	1c 93       	st	X, r17
   12e2c:	0e 93       	st	-X, r16
   12e2e:	11 97       	sbiw	r26, 0x01	; 1
   12e30:	84 ec       	ldi	r24, 0xC4	; 196
   12e32:	98 e1       	ldi	r25, 0x18	; 24
   12e34:	93 83       	std	Z+3, r25	; 0x03
   12e36:	82 83       	std	Z+2, r24	; 0x02
   12e38:	8d eb       	ldi	r24, 0xBD	; 189
   12e3a:	9c e0       	ldi	r25, 0x0C	; 12
   12e3c:	95 83       	std	Z+5, r25	; 0x05
   12e3e:	84 83       	std	Z+4, r24	; 0x04
   12e40:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
   12e44:	ed b7       	in	r30, 0x3d	; 61
   12e46:	fe b7       	in	r31, 0x3e	; 62
   12e48:	36 96       	adiw	r30, 0x06	; 6
   12e4a:	0f b6       	in	r0, 0x3f	; 63
   12e4c:	f8 94       	cli
   12e4e:	fe bf       	out	0x3e, r31	; 62
   12e50:	0f be       	out	0x3f, r0	; 63
   12e52:	ed bf       	out	0x3d, r30	; 61
   12e54:	82 e0       	ldi	r24, 0x02	; 2
   12e56:	61 e0       	ldi	r22, 0x01	; 1
   12e58:	a8 01       	movw	r20, r16
   12e5a:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
          lcd_printf(3,1,PSTR("Proses"));
   12e5e:	83 e0       	ldi	r24, 0x03	; 3
   12e60:	61 e0       	ldi	r22, 0x01	; 1
   12e62:	4d eb       	ldi	r20, 0xBD	; 189
   12e64:	58 e1       	ldi	r21, 0x18	; 24
   12e66:	0c c0       	rjmp	.+24     	; 0x12e80 <FMenuChangeMOP+0x4fe>
		  stChangeMOP=cmGenerateData;
	      break;
     case cmProsesVoucher:
          lcd_clear();
   12e68:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
          lcd_printf(1,1,PSTR("-MOP Voucher-")); 
   12e6c:	81 e0       	ldi	r24, 0x01	; 1
   12e6e:	61 e0       	ldi	r22, 0x01	; 1
   12e70:	4f ea       	ldi	r20, 0xAF	; 175
   12e72:	58 e1       	ldi	r21, 0x18	; 24
   12e74:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
          lcd_printf(3,1,PSTR("Proses"));
   12e78:	83 e0       	ldi	r24, 0x03	; 3
   12e7a:	61 e0       	ldi	r22, 0x01	; 1
   12e7c:	48 ea       	ldi	r20, 0xA8	; 168
   12e7e:	58 e1       	ldi	r21, 0x18	; 24
   12e80:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		  stChangeMOP=cmGenerateData;
   12e84:	86 e1       	ldi	r24, 0x16	; 22
   12e86:	61 cf       	rjmp	.-318    	; 0x12d4a <FMenuChangeMOP+0x3c8>
	      break;
   12e88:	e5 ec       	ldi	r30, 0xC5	; 197
   12e8a:	fd e0       	ldi	r31, 0x0D	; 13
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
   12e8c:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   12e8e:	8d e0       	ldi	r24, 0x0D	; 13
   12e90:	ea 3d       	cpi	r30, 0xDA	; 218
   12e92:	f8 07       	cpc	r31, r24
   12e94:	d9 f7       	brne	.-10     	; 0x12e8c <FMenuChangeMOP+0x50a>
   12e96:	e2 ed       	ldi	r30, 0xD2	; 210
   12e98:	fc e0       	ldi	r31, 0x0C	; 12
	     strMemory[i]=data;
   12e9a:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   12e9c:	9c e0       	ldi	r25, 0x0C	; 12
   12e9e:	e7 3e       	cpi	r30, 0xE7	; 231
   12ea0:	f9 07       	cpc	r31, r25
   12ea2:	d9 f7       	brne	.-10     	; 0x12e9a <FMenuChangeMOP+0x518>
   12ea4:	e1 eb       	ldi	r30, 0xB1	; 177
   12ea6:	f9 e0       	ldi	r31, 0x09	; 9
	     strMemory[i]=data;
   12ea8:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   12eaa:	a9 e0       	ldi	r26, 0x09	; 9
   12eac:	e6 3c       	cpi	r30, 0xC6	; 198
   12eae:	fa 07       	cpc	r31, r26
   12eb0:	d9 f7       	brne	.-10     	; 0x12ea8 <FMenuChangeMOP+0x526>
   12eb2:	24 eb       	ldi	r18, 0xB4	; 180
   12eb4:	e2 2e       	mov	r14, r18
   12eb6:	24 e0       	ldi	r18, 0x04	; 4
   12eb8:	f2 2e       	mov	r15, r18
	     strMemory[i]=data;
   12eba:	f7 01       	movw	r30, r14
   12ebc:	11 92       	st	Z+, r1
   12ebe:	7f 01       	movw	r14, r30

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   12ec0:	f9 ec       	ldi	r31, 0xC9	; 201
   12ec2:	ef 16       	cp	r14, r31
   12ec4:	f4 e0       	ldi	r31, 0x04	; 4
   12ec6:	ff 06       	cpc	r15, r31
   12ec8:	c1 f7       	brne	.-16     	; 0x12eba <FMenuChangeMOP+0x538>
     case cmGenerateData:
	      FillChar(strRef1,sizeof(strRef1),0);
	      FillChar(strRef2,sizeof(strRef2),0);
	      FillChar(strRef3,sizeof(strRef3),0);
	      FillChar(strRef4,sizeof(strRef4),0);
          switch(MOPType){
   12eca:	80 91 ba 01 	lds	r24, 0x01BA
   12ece:	82 30       	cpi	r24, 0x02	; 2
   12ed0:	f1 f0       	breq	.+60     	; 0x12f0e <FMenuChangeMOP+0x58c>
   12ed2:	83 30       	cpi	r24, 0x03	; 3
   12ed4:	20 f4       	brcc	.+8      	; 0x12ede <FMenuChangeMOP+0x55c>
   12ed6:	81 30       	cpi	r24, 0x01	; 1
   12ed8:	09 f0       	breq	.+2      	; 0x12edc <FMenuChangeMOP+0x55a>
   12eda:	ad c0       	rjmp	.+346    	; 0x13036 <FMenuChangeMOP+0x6b4>
   12edc:	07 c0       	rjmp	.+14     	; 0x12eec <FMenuChangeMOP+0x56a>
   12ede:	83 30       	cpi	r24, 0x03	; 3
   12ee0:	09 f4       	brne	.+2      	; 0x12ee4 <FMenuChangeMOP+0x562>
   12ee2:	64 c0       	rjmp	.+200    	; 0x12fac <FMenuChangeMOP+0x62a>
   12ee4:	84 30       	cpi	r24, 0x04	; 4
   12ee6:	09 f0       	breq	.+2      	; 0x12eea <FMenuChangeMOP+0x568>
   12ee8:	a6 c0       	rjmp	.+332    	; 0x13036 <FMenuChangeMOP+0x6b4>
   12eea:	75 c0       	rjmp	.+234    	; 0x12fd6 <FMenuChangeMOP+0x654>
		  case PAY_ACCOUNT:
		       sprintf_P(strRef1,PSTR("%s"),strCardID); 
   12eec:	00 d0       	rcall	.+0      	; 0x12eee <FMenuChangeMOP+0x56c>
   12eee:	00 d0       	rcall	.+0      	; 0x12ef0 <FMenuChangeMOP+0x56e>
   12ef0:	00 d0       	rcall	.+0      	; 0x12ef2 <FMenuChangeMOP+0x570>
   12ef2:	ed b7       	in	r30, 0x3d	; 61
   12ef4:	fe b7       	in	r31, 0x3e	; 62
   12ef6:	31 96       	adiw	r30, 0x01	; 1
   12ef8:	85 ec       	ldi	r24, 0xC5	; 197
   12efa:	9d e0       	ldi	r25, 0x0D	; 13
   12efc:	ad b7       	in	r26, 0x3d	; 61
   12efe:	be b7       	in	r27, 0x3e	; 62
   12f00:	12 96       	adiw	r26, 0x02	; 2
   12f02:	9c 93       	st	X, r25
   12f04:	8e 93       	st	-X, r24
   12f06:	11 97       	sbiw	r26, 0x01	; 1
   12f08:	85 ea       	ldi	r24, 0xA5	; 165
   12f0a:	98 e1       	ldi	r25, 0x18	; 24
   12f0c:	84 c0       	rjmp	.+264    	; 0x13016 <FMenuChangeMOP+0x694>
   12f0e:	8e 01       	movw	r16, r28
   12f10:	0b 5f       	subi	r16, 0xFB	; 251
   12f12:	1f 4f       	sbci	r17, 0xFF	; 255
   12f14:	60 91 b1 02 	lds	r22, 0x02B1
   12f18:	8b e0       	ldi	r24, 0x0B	; 11
   12f1a:	68 9f       	mul	r22, r24
   12f1c:	b0 01       	movw	r22, r0
   12f1e:	11 24       	eor	r1, r1
   12f20:	67 5f       	subi	r22, 0xF7	; 247
   12f22:	7e 4f       	sbci	r23, 0xFE	; 254
   12f24:	c8 01       	movw	r24, r16
   12f26:	4b e0       	ldi	r20, 0x0B	; 11
   12f28:	50 e0       	ldi	r21, 0x00	; 0
   12f2a:	2d ef       	ldi	r18, 0xFD	; 253
   12f2c:	32 e1       	ldi	r19, 0x12	; 18
   12f2e:	0e 94 f1 b3 	call	0x167e2	; 0x167e2 <__eerd_block>
		       break;
		  case PAY_BANK:
		  	   eeprom_read_block((void*) &strBankName, (const void*) &DefBankName[BankIdx], 11);
		       sprintf_P(lcdteks,PSTR("%s"),strBankName);
   12f32:	00 d0       	rcall	.+0      	; 0x12f34 <FMenuChangeMOP+0x5b2>
   12f34:	00 d0       	rcall	.+0      	; 0x12f36 <FMenuChangeMOP+0x5b4>
   12f36:	00 d0       	rcall	.+0      	; 0x12f38 <FMenuChangeMOP+0x5b6>
   12f38:	ed b7       	in	r30, 0x3d	; 61
   12f3a:	fe b7       	in	r31, 0x3e	; 62
   12f3c:	31 96       	adiw	r30, 0x01	; 1
   12f3e:	ce 01       	movw	r24, r28
   12f40:	40 96       	adiw	r24, 0x10	; 16
   12f42:	ad b7       	in	r26, 0x3d	; 61
   12f44:	be b7       	in	r27, 0x3e	; 62
   12f46:	12 96       	adiw	r26, 0x02	; 2
   12f48:	9c 93       	st	X, r25
   12f4a:	8e 93       	st	-X, r24
   12f4c:	11 97       	sbiw	r26, 0x01	; 1
   12f4e:	82 ea       	ldi	r24, 0xA2	; 162
   12f50:	98 e1       	ldi	r25, 0x18	; 24
   12f52:	93 83       	std	Z+3, r25	; 0x03
   12f54:	82 83       	std	Z+2, r24	; 0x02
   12f56:	15 83       	std	Z+5, r17	; 0x05
   12f58:	04 83       	std	Z+4, r16	; 0x04
   12f5a:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
		       sprintf_P(strRef1,PSTR("%s"),strBankName); 
   12f5e:	ed b7       	in	r30, 0x3d	; 61
   12f60:	fe b7       	in	r31, 0x3e	; 62
   12f62:	31 96       	adiw	r30, 0x01	; 1
   12f64:	85 ec       	ldi	r24, 0xC5	; 197
   12f66:	9d e0       	ldi	r25, 0x0D	; 13
   12f68:	ad b7       	in	r26, 0x3d	; 61
   12f6a:	be b7       	in	r27, 0x3e	; 62
   12f6c:	12 96       	adiw	r26, 0x02	; 2
   12f6e:	9c 93       	st	X, r25
   12f70:	8e 93       	st	-X, r24
   12f72:	11 97       	sbiw	r26, 0x01	; 1
   12f74:	8f e9       	ldi	r24, 0x9F	; 159
   12f76:	98 e1       	ldi	r25, 0x18	; 24
   12f78:	93 83       	std	Z+3, r25	; 0x03
   12f7a:	82 83       	std	Z+2, r24	; 0x02
   12f7c:	15 83       	std	Z+5, r17	; 0x05
   12f7e:	04 83       	std	Z+4, r16	; 0x04
   12f80:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
		       sprintf_P(strRef4,PSTR("%s"),strSurcharge); 
   12f84:	ed b7       	in	r30, 0x3d	; 61
   12f86:	fe b7       	in	r31, 0x3e	; 62
   12f88:	31 96       	adiw	r30, 0x01	; 1
   12f8a:	8b ee       	ldi	r24, 0xEB	; 235
   12f8c:	9f ef       	ldi	r25, 0xFF	; 255
   12f8e:	e8 0e       	add	r14, r24
   12f90:	f9 1e       	adc	r15, r25
   12f92:	ad b7       	in	r26, 0x3d	; 61
   12f94:	be b7       	in	r27, 0x3e	; 62
   12f96:	12 96       	adiw	r26, 0x02	; 2
   12f98:	fc 92       	st	X, r15
   12f9a:	ee 92       	st	-X, r14
   12f9c:	11 97       	sbiw	r26, 0x01	; 1
   12f9e:	8c e9       	ldi	r24, 0x9C	; 156
   12fa0:	98 e1       	ldi	r25, 0x18	; 24
   12fa2:	93 83       	std	Z+3, r25	; 0x03
   12fa4:	82 83       	std	Z+2, r24	; 0x02
   12fa6:	ce 01       	movw	r24, r28
   12fa8:	01 96       	adiw	r24, 0x01	; 1
   12faa:	39 c0       	rjmp	.+114    	; 0x1301e <FMenuChangeMOP+0x69c>
		       break;
		  case PAY_VOUCHER://Load data Ref1=Voucher on cmVoucherInput
		  	   sprintf_P(strRef1,PSTR("%s"),strVoucherNum); 
   12fac:	00 d0       	rcall	.+0      	; 0x12fae <FMenuChangeMOP+0x62c>
   12fae:	00 d0       	rcall	.+0      	; 0x12fb0 <FMenuChangeMOP+0x62e>
   12fb0:	00 d0       	rcall	.+0      	; 0x12fb2 <FMenuChangeMOP+0x630>
   12fb2:	ed b7       	in	r30, 0x3d	; 61
   12fb4:	fe b7       	in	r31, 0x3e	; 62
   12fb6:	31 96       	adiw	r30, 0x01	; 1
   12fb8:	85 ec       	ldi	r24, 0xC5	; 197
   12fba:	9d e0       	ldi	r25, 0x0D	; 13
   12fbc:	ad b7       	in	r26, 0x3d	; 61
   12fbe:	be b7       	in	r27, 0x3e	; 62
   12fc0:	12 96       	adiw	r26, 0x02	; 2
   12fc2:	9c 93       	st	X, r25
   12fc4:	8e 93       	st	-X, r24
   12fc6:	11 97       	sbiw	r26, 0x01	; 1
   12fc8:	89 e9       	ldi	r24, 0x99	; 153
   12fca:	98 e1       	ldi	r25, 0x18	; 24
   12fcc:	93 83       	std	Z+3, r25	; 0x03
   12fce:	82 83       	std	Z+2, r24	; 0x02
   12fd0:	83 e7       	ldi	r24, 0x73	; 115
   12fd2:	9d e0       	ldi	r25, 0x0D	; 13
   12fd4:	24 c0       	rjmp	.+72     	; 0x1301e <FMenuChangeMOP+0x69c>
		       break;
		  case PAY_PUMPTEST:
		  	   sprintf_P(strRef1,PSTR("PUMP TEST")); 
   12fd6:	00 d0       	rcall	.+0      	; 0x12fd8 <FMenuChangeMOP+0x656>
   12fd8:	00 d0       	rcall	.+0      	; 0x12fda <FMenuChangeMOP+0x658>
   12fda:	85 ec       	ldi	r24, 0xC5	; 197
   12fdc:	9d e0       	ldi	r25, 0x0D	; 13
   12fde:	ad b7       	in	r26, 0x3d	; 61
   12fe0:	be b7       	in	r27, 0x3e	; 62
   12fe2:	12 96       	adiw	r26, 0x02	; 2
   12fe4:	9c 93       	st	X, r25
   12fe6:	8e 93       	st	-X, r24
   12fe8:	11 97       	sbiw	r26, 0x01	; 1
   12fea:	8f e8       	ldi	r24, 0x8F	; 143
   12fec:	98 e1       	ldi	r25, 0x18	; 24
   12fee:	14 96       	adiw	r26, 0x04	; 4
   12ff0:	9c 93       	st	X, r25
   12ff2:	8e 93       	st	-X, r24
   12ff4:	13 97       	sbiw	r26, 0x03	; 3
   12ff6:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
		  	   sprintf_P(strRef2,PSTR("%s"),strCardID); 	       
   12ffa:	00 d0       	rcall	.+0      	; 0x12ffc <FMenuChangeMOP+0x67a>
   12ffc:	ed b7       	in	r30, 0x3d	; 61
   12ffe:	fe b7       	in	r31, 0x3e	; 62
   13000:	31 96       	adiw	r30, 0x01	; 1
   13002:	82 ed       	ldi	r24, 0xD2	; 210
   13004:	9c e0       	ldi	r25, 0x0C	; 12
   13006:	ad b7       	in	r26, 0x3d	; 61
   13008:	be b7       	in	r27, 0x3e	; 62
   1300a:	12 96       	adiw	r26, 0x02	; 2
   1300c:	9c 93       	st	X, r25
   1300e:	8e 93       	st	-X, r24
   13010:	11 97       	sbiw	r26, 0x01	; 1
   13012:	8c e8       	ldi	r24, 0x8C	; 140
   13014:	98 e1       	ldi	r25, 0x18	; 24
   13016:	93 83       	std	Z+3, r25	; 0x03
   13018:	82 83       	std	Z+2, r24	; 0x02
   1301a:	8d eb       	ldi	r24, 0xBD	; 189
   1301c:	9c e0       	ldi	r25, 0x0C	; 12
   1301e:	95 83       	std	Z+5, r25	; 0x05
   13020:	84 83       	std	Z+4, r24	; 0x04
   13022:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
   13026:	ed b7       	in	r30, 0x3d	; 61
   13028:	fe b7       	in	r31, 0x3e	; 62
   1302a:	36 96       	adiw	r30, 0x06	; 6
   1302c:	0f b6       	in	r0, 0x3f	; 63
   1302e:	f8 94       	cli
   13030:	fe bf       	out	0x3e, r31	; 62
   13032:	0f be       	out	0x3f, r0	; 63
   13034:	ed bf       	out	0x3d, r30	; 61
	     }String[Size]=0;
	 }
}

void leadingZero(char Val,char *StrResult){
     sprintf_P(StrResult,PSTR("%.2d"),Val);
   13036:	00 d0       	rcall	.+0      	; 0x13038 <FMenuChangeMOP+0x6b6>
   13038:	00 d0       	rcall	.+0      	; 0x1303a <FMenuChangeMOP+0x6b8>
   1303a:	00 d0       	rcall	.+0      	; 0x1303c <FMenuChangeMOP+0x6ba>
   1303c:	ed b7       	in	r30, 0x3d	; 61
   1303e:	fe b7       	in	r31, 0x3e	; 62
   13040:	31 96       	adiw	r30, 0x01	; 1
   13042:	82 e6       	ldi	r24, 0x62	; 98
   13044:	98 e0       	ldi	r25, 0x08	; 8
   13046:	ad b7       	in	r26, 0x3d	; 61
   13048:	be b7       	in	r27, 0x3e	; 62
   1304a:	12 96       	adiw	r26, 0x02	; 2
   1304c:	9c 93       	st	X, r25
   1304e:	8e 93       	st	-X, r24
   13050:	11 97       	sbiw	r26, 0x01	; 1
   13052:	84 e8       	ldi	r24, 0x84	; 132
   13054:	9d e0       	ldi	r25, 0x0D	; 13
   13056:	93 83       	std	Z+3, r25	; 0x03
   13058:	82 83       	std	Z+2, r24	; 0x02
   1305a:	80 91 ba 01 	lds	r24, 0x01BA
   1305e:	84 83       	std	Z+4, r24	; 0x04
   13060:	15 82       	std	Z+5, r1	; 0x05
   13062:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
		  	   sprintf_P(strRef1,PSTR("PUMP TEST")); 
		  	   sprintf_P(strRef2,PSTR("%s"),strCardID); 	       
		       break;
		  }
		  leadingZero(MOPType,strPaymentType);
		  AddSpaceLead(strRef1,20);
   13066:	ed b7       	in	r30, 0x3d	; 61
   13068:	fe b7       	in	r31, 0x3e	; 62
   1306a:	36 96       	adiw	r30, 0x06	; 6
   1306c:	0f b6       	in	r0, 0x3f	; 63
   1306e:	f8 94       	cli
   13070:	fe bf       	out	0x3e, r31	; 62
   13072:	0f be       	out	0x3f, r0	; 63
   13074:	ed bf       	out	0x3d, r30	; 61
   13076:	85 ec       	ldi	r24, 0xC5	; 197
   13078:	9d e0       	ldi	r25, 0x0D	; 13
   1307a:	64 e1       	ldi	r22, 0x14	; 20
   1307c:	0e 94 39 2d 	call	0x5a72	; 0x5a72 <AddSpaceLead>
		  AddSpaceLead(strRef2,20);
   13080:	82 ed       	ldi	r24, 0xD2	; 210
   13082:	9c e0       	ldi	r25, 0x0C	; 12
   13084:	64 e1       	ldi	r22, 0x14	; 20
   13086:	0e 94 39 2d 	call	0x5a72	; 0x5a72 <AddSpaceLead>
		  AddSpaceLead(strRef3,20);
   1308a:	81 eb       	ldi	r24, 0xB1	; 177
   1308c:	99 e0       	ldi	r25, 0x09	; 9
   1308e:	64 e1       	ldi	r22, 0x14	; 20
   13090:	0e 94 39 2d 	call	0x5a72	; 0x5a72 <AddSpaceLead>
		  AddSpaceLead(strRef4,20);
   13094:	84 eb       	ldi	r24, 0xB4	; 180
   13096:	94 e0       	ldi	r25, 0x04	; 4
   13098:	64 e1       	ldi	r22, 0x14	; 20
   1309a:	0e 94 39 2d 	call	0x5a72	; 0x5a72 <AddSpaceLead>
		  iWait=0;
   1309e:	10 92 af 02 	sts	0x02AF, r1
		  IsMessage09=False;
   130a2:	10 92 a6 01 	sts	0x01A6, r1
		  stChangeMOP=cmSendMessage32;	      
   130a6:	87 e1       	ldi	r24, 0x17	; 23
   130a8:	50 ce       	rjmp	.-864    	; 0x12d4a <FMenuChangeMOP+0x3c8>
	      break;
     case cmSendMessage32://SendMessage32
	      sendMessage32();
   130aa:	0e 94 87 50 	call	0xa10e	; 0xa10e <sendMessage32>
		  iLoop=0;
   130ae:	10 92 ae 02 	sts	0x02AE, r1
   130b2:	10 92 ad 02 	sts	0x02AD, r1
		  iPos=0;
   130b6:	10 92 b0 02 	sts	0x02B0, r1
		  lcd_printf(3,1,PSTR("Please Wait"));
   130ba:	83 e0       	ldi	r24, 0x03	; 3
   130bc:	61 e0       	ldi	r22, 0x01	; 1
   130be:	40 e8       	ldi	r20, 0x80	; 128
   130c0:	58 e1       	ldi	r21, 0x18	; 24
   130c2:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		  stChangeMOP=cmWaitReplyMessage;	      
   130c6:	88 e1       	ldi	r24, 0x18	; 24
   130c8:	40 ce       	rjmp	.-896    	; 0x12d4a <FMenuChangeMOP+0x3c8>
	      break;
     case cmWaitReplyMessage:
          iLoop++;
   130ca:	80 91 ad 02 	lds	r24, 0x02AD
   130ce:	90 91 ae 02 	lds	r25, 0x02AE
   130d2:	01 96       	adiw	r24, 0x01	; 1
   130d4:	90 93 ae 02 	sts	0x02AE, r25
   130d8:	80 93 ad 02 	sts	0x02AD, r24
		  if ((iLoop%MSG_WAIT_TIMOUT)==0){
   130dc:	68 e9       	ldi	r22, 0x98	; 152
   130de:	7a e3       	ldi	r23, 0x3A	; 58
   130e0:	0e 94 0a b7 	call	0x16e14	; 0x16e14 <__udivmodhi4>
   130e4:	89 2b       	or	r24, r25
   130e6:	19 f5       	brne	.+70     	; 0x1312e <FMenuChangeMOP+0x7ac>
			 if (iPos<5){
   130e8:	60 91 b0 02 	lds	r22, 0x02B0
   130ec:	65 30       	cpi	r22, 0x05	; 5
   130ee:	68 f4       	brcc	.+26     	; 0x1310a <FMenuChangeMOP+0x788>
				 lcd_xy(3,(13+iPos));_lcd('.');
   130f0:	63 5f       	subi	r22, 0xF3	; 243
   130f2:	83 e0       	ldi	r24, 0x03	; 3
   130f4:	0e 94 ca ac 	call	0x15994	; 0x15994 <lcd_xy>
   130f8:	8e e2       	ldi	r24, 0x2E	; 46
   130fa:	0e 94 a4 ac 	call	0x15948	; 0x15948 <_lcd>
				 iPos++;
   130fe:	80 91 b0 02 	lds	r24, 0x02B0
   13102:	8f 5f       	subi	r24, 0xFF	; 255
   13104:	80 93 b0 02 	sts	0x02B0, r24
   13108:	12 c0       	rjmp	.+36     	; 0x1312e <FMenuChangeMOP+0x7ac>
				}
			 else{
				 iPos=0;
   1310a:	10 92 b0 02 	sts	0x02B0, r1
				 lcd_printf(3,(13+iPos),PSTR("       "));
   1310e:	83 e0       	ldi	r24, 0x03	; 3
   13110:	6d e0       	ldi	r22, 0x0D	; 13
   13112:	48 e7       	ldi	r20, 0x78	; 120
   13114:	58 e1       	ldi	r21, 0x18	; 24
   13116:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
				 //Resend Message32
				 if (iWait<5)stChangeMOP=cmSendMessage32;
   1311a:	90 91 af 02 	lds	r25, 0x02AF
   1311e:	95 30       	cpi	r25, 0x05	; 5
   13120:	18 f4       	brcc	.+6      	; 0x13128 <FMenuChangeMOP+0x7a6>
   13122:	87 e1       	ldi	r24, 0x17	; 23
   13124:	80 93 b3 02 	sts	0x02B3, r24
				iWait++;
   13128:	9f 5f       	subi	r25, 0xFF	; 255
   1312a:	90 93 af 02 	sts	0x02AF, r25
				}
		  }
		  if (iWait>5)stChangeMOP=cmNoReply;
   1312e:	80 91 af 02 	lds	r24, 0x02AF
   13132:	86 30       	cpi	r24, 0x06	; 6
   13134:	18 f0       	brcs	.+6      	; 0x1313c <FMenuChangeMOP+0x7ba>
   13136:	8a e1       	ldi	r24, 0x1A	; 26
   13138:	80 93 b3 02 	sts	0x02B3, r24
		  if (IsMessage09==True)stChangeMOP=cmDisplayFreeMessage;
   1313c:	80 91 a6 01 	lds	r24, 0x01A6
   13140:	81 30       	cpi	r24, 0x01	; 1
   13142:	19 f4       	brne	.+6      	; 0x1314a <FMenuChangeMOP+0x7c8>
   13144:	89 e1       	ldi	r24, 0x19	; 25
   13146:	80 93 b3 02 	sts	0x02B3, r24
		  if (IsMessage99==True)stChangeMOP=cmFinishChangeMOP;
   1314a:	80 91 a2 01 	lds	r24, 0x01A2
   1314e:	81 30       	cpi	r24, 0x01	; 1
   13150:	f1 f5       	brne	.+124    	; 0x131ce <FMenuChangeMOP+0x84c>
   13152:	37 c0       	rjmp	.+110    	; 0x131c2 <FMenuChangeMOP+0x840>
		  break;
     case cmDisplayFreeMessage:
	      IsMessage09=False;
   13154:	10 92 a6 01 	sts	0x01A6, r1
	      msgResult=procMessage09();
   13158:	0e 94 28 17 	call	0x2e50	; 0x2e50 <procMessage09>
		  lcd_clear();
   1315c:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
		  lcd_print(1,1,strFreeMessageLine1);
   13160:	81 e0       	ldi	r24, 0x01	; 1
   13162:	61 e0       	ldi	r22, 0x01	; 1
   13164:	46 ec       	ldi	r20, 0xC6	; 198
   13166:	59 e0       	ldi	r21, 0x09	; 9
   13168:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
		  lcd_print(2,1,strFreeMessageLine2);
   1316c:	82 e0       	ldi	r24, 0x02	; 2
   1316e:	61 e0       	ldi	r22, 0x01	; 1
   13170:	45 eb       	ldi	r20, 0xB5	; 181
   13172:	58 e0       	ldi	r21, 0x08	; 8
   13174:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
		  lcd_print(3,1,strFreeMessageLine3);
   13178:	83 e0       	ldi	r24, 0x03	; 3
   1317a:	61 e0       	ldi	r22, 0x01	; 1
   1317c:	40 e5       	ldi	r20, 0x50	; 80
   1317e:	59 e0       	ldi	r21, 0x09	; 9
   13180:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
		  lcd_print(4,1,strFreeMessageLine4);
   13184:	84 e0       	ldi	r24, 0x04	; 4
   13186:	61 e0       	ldi	r22, 0x01	; 1
   13188:	4d e0       	ldi	r20, 0x0D	; 13
   1318a:	5d e0       	ldi	r21, 0x0D	; 13
   1318c:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
   13190:	0e c0       	rjmp	.+28     	; 0x131ae <FMenuChangeMOP+0x82c>
		  TimDisplay=0;
          stChangeMOP=cmDelayMOP;
	      break;
     case cmNoReply:
	      lcd_clear();
   13192:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
		  lcd_printf(2,1,PSTR("No Reply    "));
   13196:	82 e0       	ldi	r24, 0x02	; 2
   13198:	61 e0       	ldi	r22, 0x01	; 1
   1319a:	4b e6       	ldi	r20, 0x6B	; 107
   1319c:	58 e1       	ldi	r21, 0x18	; 24
   1319e:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
	      lcd_printf(3,1,PSTR("TCP/IP Error"));
   131a2:	83 e0       	ldi	r24, 0x03	; 3
   131a4:	61 e0       	ldi	r22, 0x01	; 1
   131a6:	4e e5       	ldi	r20, 0x5E	; 94
   131a8:	58 e1       	ldi	r21, 0x18	; 24
   131aa:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		  TimDisplay=0;
   131ae:	10 92 95 01 	sts	0x0195, r1
          stChangeMOP=cmDelayMOP;
   131b2:	8b e1       	ldi	r24, 0x1B	; 27
   131b4:	ca cd       	rjmp	.-1132   	; 0x12d4a <FMenuChangeMOP+0x3c8>
	      break;
     case cmDelayMOP:
	      if (TimDisplay>9)stChangeMOP=cmExitChangeMOP;
   131b6:	80 91 95 01 	lds	r24, 0x0195
   131ba:	8a 30       	cpi	r24, 0x0A	; 10
   131bc:	40 f0       	brcs	.+16     	; 0x131ce <FMenuChangeMOP+0x84c>
   131be:	8c e1       	ldi	r24, 0x1C	; 28
   131c0:	c4 cd       	rjmp	.-1144   	; 0x12d4a <FMenuChangeMOP+0x3c8>
	      break;
     case cmExitChangeMOP:
	      stChangeMOP=cmFinishChangeMOP;
   131c2:	8d e1       	ldi	r24, 0x1D	; 29
   131c4:	c2 cd       	rjmp	.-1148   	; 0x12d4a <FMenuChangeMOP+0x3c8>
	      break;
     case cmFinishChangeMOP:
	      stChangeMOP=cmInit;
   131c6:	10 92 b3 02 	sts	0x02B3, r1
   131ca:	81 e0       	ldi	r24, 0x01	; 1
   131cc:	01 c0       	rjmp	.+2      	; 0x131d0 <FMenuChangeMOP+0x84e>
   131ce:	80 e0       	ldi	r24, 0x00	; 0
		  Result=MENU_DONE;
	      break;
	 }
  return Result;
}
   131d0:	a3 96       	adiw	r28, 0x23	; 35
   131d2:	0f b6       	in	r0, 0x3f	; 63
   131d4:	f8 94       	cli
   131d6:	de bf       	out	0x3e, r29	; 62
   131d8:	0f be       	out	0x3f, r0	; 63
   131da:	cd bf       	out	0x3d, r28	; 61
   131dc:	cf 91       	pop	r28
   131de:	df 91       	pop	r29
   131e0:	1f 91       	pop	r17
   131e2:	0f 91       	pop	r16
   131e4:	ff 90       	pop	r15
   131e6:	ef 90       	pop	r14
   131e8:	df 90       	pop	r13
   131ea:	cf 90       	pop	r12
   131ec:	bf 90       	pop	r11
   131ee:	af 90       	pop	r10
   131f0:	08 95       	ret

000131f2 <SetBaudRate>:
	 //Spooling HFCx 0000
	 cmdPrint=0b00010000|(1<<PRN_PAPER_CUT);
	 IsFreePrinting=True;
}

void SetBaudRate(char ComAddr,char brMap){//Com1..Com4
   131f2:	28 2f       	mov	r18, r24
   131f4:	96 2f       	mov	r25, r22
unsigned int brValue=9600;
char brMessage=0;

     if ((ComAddr>=1)&&(ComAddr<=2)){
   131f6:	81 50       	subi	r24, 0x01	; 1
   131f8:	82 30       	cpi	r24, 0x02	; 2
   131fa:	b8 f4       	brcc	.+46     	; 0x1322a <SetBaudRate+0x38>
	 }
}

int GetBaudrate(char brSetting){
int Result=0;
     switch(brSetting){
   131fc:	62 30       	cpi	r22, 0x02	; 2
   131fe:	59 f0       	breq	.+22     	; 0x13216 <SetBaudRate+0x24>
   13200:	62 30       	cpi	r22, 0x02	; 2
   13202:	18 f0       	brcs	.+6      	; 0x1320a <SetBaudRate+0x18>
   13204:	63 30       	cpi	r22, 0x03	; 3
   13206:	21 f4       	brne	.+8      	; 0x13210 <SetBaudRate+0x1e>
   13208:	09 c0       	rjmp	.+18     	; 0x1321c <SetBaudRate+0x2a>
   1320a:	40 e8       	ldi	r20, 0x80	; 128
   1320c:	55 e2       	ldi	r21, 0x25	; 37
   1320e:	08 c0       	rjmp	.+16     	; 0x13220 <SetBaudRate+0x2e>
   13210:	40 e0       	ldi	r20, 0x00	; 0
   13212:	50 e0       	ldi	r21, 0x00	; 0
   13214:	05 c0       	rjmp	.+10     	; 0x13220 <SetBaudRate+0x2e>
   13216:	40 e0       	ldi	r20, 0x00	; 0
   13218:	5b e4       	ldi	r21, 0x4B	; 75
   1321a:	02 c0       	rjmp	.+4      	; 0x13220 <SetBaudRate+0x2e>
   1321c:	4b e9       	ldi	r20, 0x9B	; 155
   1321e:	56 e1       	ldi	r21, 0x16	; 22
unsigned int brValue=9600;
char brMessage=0;

     if ((ComAddr>=1)&&(ComAddr<=2)){
	     brValue=GetBaudrate(brMap);
	      _uart_init((ComAddr-1),brValue);
   13220:	60 e0       	ldi	r22, 0x00	; 0
   13222:	70 e0       	ldi	r23, 0x00	; 0
   13224:	0e 94 40 b2 	call	0x16480	; 0x16480 <_uart_init>
   13228:	08 95       	ret
	 }else
     if ((ComAddr>=3)&&(ComAddr<=4)){
   1322a:	82 2f       	mov	r24, r18
   1322c:	83 50       	subi	r24, 0x03	; 3
   1322e:	82 30       	cpi	r24, 0x02	; 2
   13230:	a8 f4       	brcc	.+42     	; 0x1325c <SetBaudRate+0x6a>
	     //[COM][Baud]
		 brMessage=((ComAddr<<4)|(0x0F&brMap));
   13232:	9f 70       	andi	r25, 0x0F	; 15
   13234:	62 2f       	mov	r22, r18
   13236:	62 95       	swap	r22
   13238:	60 7f       	andi	r22, 0xF0	; 240
   1323a:	69 2b       	or	r22, r25
		 if (iSequencePooling>0)SendPoolingCommand(SC_BAUDRATE,brMessage);
   1323c:	80 91 83 01 	lds	r24, 0x0183
   13240:	88 23       	and	r24, r24
   13242:	49 f0       	breq	.+18     	; 0x13256 <SetBaudRate+0x64>
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
   13244:	86 e0       	ldi	r24, 0x06	; 6
   13246:	80 93 b9 06 	sts	0x06B9, r24
	 PoolMsg=plMsg;
   1324a:	60 93 0a 0d 	sts	0x0D0A, r22
     IsControlPooling=True;
   1324e:	81 e0       	ldi	r24, 0x01	; 1
   13250:	80 93 87 01 	sts	0x0187, r24
   13254:	08 95       	ret
	 }else
     if ((ComAddr>=3)&&(ComAddr<=4)){
	     //[COM][Baud]
		 brMessage=((ComAddr<<4)|(0x0F&brMap));
		 if (iSequencePooling>0)SendPoolingCommand(SC_BAUDRATE,brMessage);
		 else SendSlaveCommand(SC_BAUDRATE,brMessage);
   13256:	86 e0       	ldi	r24, 0x06	; 6
   13258:	0e 94 72 74 	call	0xe8e4	; 0xe8e4 <SendSlaveCommand>
   1325c:	08 95       	ret

0001325e <FSettingSystem>:
	      break;
	 }
     return Result;
}

char FSettingSystem(){
   1325e:	af 92       	push	r10
   13260:	bf 92       	push	r11
   13262:	cf 92       	push	r12
   13264:	df 92       	push	r13
   13266:	ef 92       	push	r14
   13268:	ff 92       	push	r15
   1326a:	0f 93       	push	r16
   1326c:	1f 93       	push	r17
   1326e:	df 93       	push	r29
   13270:	cf 93       	push	r28
   13272:	cd b7       	in	r28, 0x3d	; 61
   13274:	de b7       	in	r29, 0x3e	; 62
   13276:	64 97       	sbiw	r28, 0x14	; 20
   13278:	0f b6       	in	r0, 0x3f	; 63
   1327a:	f8 94       	cli
   1327c:	de bf       	out	0x3e, r29	; 62
   1327e:	0f be       	out	0x3f, r0	; 63
   13280:	cd bf       	out	0x3d, r28	; 61
       char SubMenu,Result=MENU_NONE;
	   char HGMode;
       char lcdteks[20];
	   int bValue;

     switch(stSettingSytem){
   13282:	80 91 6d 02 	lds	r24, 0x026D
   13286:	82 30       	cpi	r24, 0x02	; 2
   13288:	09 f4       	brne	.+2      	; 0x1328c <FSettingSystem+0x2e>
   1328a:	cf c0       	rjmp	.+414    	; 0x1342a <FSettingSystem+0x1cc>
   1328c:	83 30       	cpi	r24, 0x03	; 3
   1328e:	30 f4       	brcc	.+12     	; 0x1329c <FSettingSystem+0x3e>
   13290:	88 23       	and	r24, r24
   13292:	71 f0       	breq	.+28     	; 0x132b0 <FSettingSystem+0x52>
   13294:	81 30       	cpi	r24, 0x01	; 1
   13296:	09 f0       	breq	.+2      	; 0x1329a <FSettingSystem+0x3c>
   13298:	6f c1       	rjmp	.+734    	; 0x13578 <FSettingSystem+0x31a>
   1329a:	7f c0       	rjmp	.+254    	; 0x1339a <FSettingSystem+0x13c>
   1329c:	84 30       	cpi	r24, 0x04	; 4
   1329e:	09 f4       	brne	.+2      	; 0x132a2 <FSettingSystem+0x44>
   132a0:	60 c1       	rjmp	.+704    	; 0x13562 <FSettingSystem+0x304>
   132a2:	84 30       	cpi	r24, 0x04	; 4
   132a4:	08 f4       	brcc	.+2      	; 0x132a8 <FSettingSystem+0x4a>
   132a6:	2b c1       	rjmp	.+598    	; 0x134fe <FSettingSystem+0x2a0>
   132a8:	85 30       	cpi	r24, 0x05	; 5
   132aa:	09 f0       	breq	.+2      	; 0x132ae <FSettingSystem+0x50>
   132ac:	65 c1       	rjmp	.+714    	; 0x13578 <FSettingSystem+0x31a>
   132ae:	60 c1       	rjmp	.+704    	; 0x13570 <FSettingSystem+0x312>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   132b0:	e1 99       	sbic	0x1c, 1	; 28
   132b2:	fe cf       	rjmp	.-4      	; 0x132b0 <FSettingSystem+0x52>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   132b4:	86 e3       	ldi	r24, 0x36	; 54
   132b6:	91 e0       	ldi	r25, 0x01	; 1
   132b8:	9f bb       	out	0x1f, r25	; 31
   132ba:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   132bc:	e0 9a       	sbi	0x1c, 0	; 28
   132be:	2d b3       	in	r18, 0x1d	; 29
	 case ssInitSettingSystem:
	      IFType=eeprom_read_byte(&DefInitIFT);
   132c0:	20 93 00 01 	sts	0x0100, r18
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   132c4:	e1 99       	sbic	0x1c, 1	; 28
   132c6:	fe cf       	rjmp	.-4      	; 0x132c4 <FSettingSystem+0x66>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   132c8:	82 ec       	ldi	r24, 0xC2	; 194
   132ca:	93 e0       	ldi	r25, 0x03	; 3
   132cc:	9f bb       	out	0x1f, r25	; 31
   132ce:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   132d0:	e0 9a       	sbi	0x1c, 0	; 28
   132d2:	1d b3       	in	r17, 0x1d	; 29
		  HGMode=eeprom_read_byte(&DefHGMode);

	      if (IFType==IT_NONE)sprintf_P(lcdteks,PSTR("1.Mode:None"));
   132d4:	22 23       	and	r18, r18
   132d6:	69 f4       	brne	.+26     	; 0x132f2 <FSettingSystem+0x94>
   132d8:	00 d0       	rcall	.+0      	; 0x132da <FSettingSystem+0x7c>
   132da:	00 d0       	rcall	.+0      	; 0x132dc <FSettingSystem+0x7e>
   132dc:	ce 01       	movw	r24, r28
   132de:	01 96       	adiw	r24, 0x01	; 1
   132e0:	ad b7       	in	r26, 0x3d	; 61
   132e2:	be b7       	in	r27, 0x3e	; 62
   132e4:	12 96       	adiw	r26, 0x02	; 2
   132e6:	9c 93       	st	X, r25
   132e8:	8e 93       	st	-X, r24
   132ea:	11 97       	sbiw	r26, 0x01	; 1
   132ec:	8b e5       	ldi	r24, 0x5B	; 91
   132ee:	9e e0       	ldi	r25, 0x0E	; 14
   132f0:	1d c0       	rjmp	.+58     	; 0x1332c <FSettingSystem+0xce>
		  else
	      if (IFType==IT_SLAVE)sprintf_P(lcdteks,PSTR("1.Mode:Slave"));
   132f2:	21 30       	cpi	r18, 0x01	; 1
   132f4:	69 f4       	brne	.+26     	; 0x13310 <FSettingSystem+0xb2>
   132f6:	00 d0       	rcall	.+0      	; 0x132f8 <FSettingSystem+0x9a>
   132f8:	00 d0       	rcall	.+0      	; 0x132fa <FSettingSystem+0x9c>
   132fa:	ce 01       	movw	r24, r28
   132fc:	01 96       	adiw	r24, 0x01	; 1
   132fe:	ed b7       	in	r30, 0x3d	; 61
   13300:	fe b7       	in	r31, 0x3e	; 62
   13302:	92 83       	std	Z+2, r25	; 0x02
   13304:	81 83       	std	Z+1, r24	; 0x01
   13306:	8e e4       	ldi	r24, 0x4E	; 78
   13308:	9e e0       	ldi	r25, 0x0E	; 14
   1330a:	94 83       	std	Z+4, r25	; 0x04
   1330c:	83 83       	std	Z+3, r24	; 0x03
   1330e:	12 c0       	rjmp	.+36     	; 0x13334 <FSettingSystem+0xd6>
		  else
	      if (IFType==IT_STANDALONE)sprintf_P(lcdteks,PSTR("1.Mode:Standalone"));
   13310:	22 30       	cpi	r18, 0x02	; 2
   13312:	b1 f4       	brne	.+44     	; 0x13340 <FSettingSystem+0xe2>
   13314:	00 d0       	rcall	.+0      	; 0x13316 <FSettingSystem+0xb8>
   13316:	00 d0       	rcall	.+0      	; 0x13318 <FSettingSystem+0xba>
   13318:	ce 01       	movw	r24, r28
   1331a:	01 96       	adiw	r24, 0x01	; 1
   1331c:	ad b7       	in	r26, 0x3d	; 61
   1331e:	be b7       	in	r27, 0x3e	; 62
   13320:	12 96       	adiw	r26, 0x02	; 2
   13322:	9c 93       	st	X, r25
   13324:	8e 93       	st	-X, r24
   13326:	11 97       	sbiw	r26, 0x01	; 1
   13328:	8c e3       	ldi	r24, 0x3C	; 60
   1332a:	9e e0       	ldi	r25, 0x0E	; 14
   1332c:	14 96       	adiw	r26, 0x04	; 4
   1332e:	9c 93       	st	X, r25
   13330:	8e 93       	st	-X, r24
   13332:	13 97       	sbiw	r26, 0x03	; 3
   13334:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
   13338:	0f 90       	pop	r0
   1333a:	0f 90       	pop	r0
   1333c:	0f 90       	pop	r0
   1333e:	0f 90       	pop	r0

	      lcd_clear();
   13340:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
		  lcd_print(1,1,lcdteks);
   13344:	81 e0       	ldi	r24, 0x01	; 1
   13346:	61 e0       	ldi	r22, 0x01	; 1
   13348:	ae 01       	movw	r20, r28
   1334a:	4f 5f       	subi	r20, 0xFF	; 255
   1334c:	5f 4f       	sbci	r21, 0xFF	; 255
   1334e:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
		  lcd_printf(2,1,PSTR("2.Baudrate"));
   13352:	82 e0       	ldi	r24, 0x02	; 2
   13354:	61 e0       	ldi	r22, 0x01	; 1
   13356:	41 e3       	ldi	r20, 0x31	; 49
   13358:	5e e0       	ldi	r21, 0x0E	; 14
   1335a:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>

		  if (HGMode==HM_TTL)lcd_printf(3,1,PSTR("3.COM3:TTL"));
   1335e:	11 23       	and	r17, r17
   13360:	29 f4       	brne	.+10     	; 0x1336c <FSettingSystem+0x10e>
   13362:	83 e0       	ldi	r24, 0x03	; 3
   13364:	61 e0       	ldi	r22, 0x01	; 1
   13366:	46 e2       	ldi	r20, 0x26	; 38
   13368:	5e e0       	ldi	r21, 0x0E	; 14
   1336a:	0d c0       	rjmp	.+26     	; 0x13386 <FSettingSystem+0x128>
		  else
		  if (HGMode==HM_232)lcd_printf(3,1,PSTR("3.COM3:232"));
   1336c:	11 30       	cpi	r17, 0x01	; 1
   1336e:	29 f4       	brne	.+10     	; 0x1337a <FSettingSystem+0x11c>
   13370:	83 e0       	ldi	r24, 0x03	; 3
   13372:	61 e0       	ldi	r22, 0x01	; 1
   13374:	4b e1       	ldi	r20, 0x1B	; 27
   13376:	5e e0       	ldi	r21, 0x0E	; 14
   13378:	06 c0       	rjmp	.+12     	; 0x13386 <FSettingSystem+0x128>
		  else
		  if (HGMode==HM_485)lcd_printf(3,1,PSTR("3.COM3:485"));		  
   1337a:	12 30       	cpi	r17, 0x02	; 2
   1337c:	31 f4       	brne	.+12     	; 0x1338a <FSettingSystem+0x12c>
   1337e:	83 e0       	ldi	r24, 0x03	; 3
   13380:	61 e0       	ldi	r22, 0x01	; 1
   13382:	40 e1       	ldi	r20, 0x10	; 16
   13384:	5e e0       	ldi	r21, 0x0E	; 14
   13386:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		  lcd_printf(4,1,PSTR("[*]Back      "));
   1338a:	84 e0       	ldi	r24, 0x04	; 4
   1338c:	61 e0       	ldi	r22, 0x01	; 1
   1338e:	42 e0       	ldi	r20, 0x02	; 2
   13390:	5e e0       	ldi	r21, 0x0E	; 14
   13392:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		  stSettingSytem=ssMenuSelect;
   13396:	81 e0       	ldi	r24, 0x01	; 1
   13398:	e1 c0       	rjmp	.+450    	; 0x1355c <FSettingSystem+0x2fe>
	      break;
     case ssMenuSelect:
          KeyPressed=_key_scan(1);
   1339a:	81 e0       	ldi	r24, 0x01	; 1
   1339c:	0e 94 84 ae 	call	0x15d08	; 0x15d08 <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
   133a0:	0e 94 e5 ad 	call	0x15bca	; 0x15bca <_key_btn>
		  if (KeyChar=='1'){
   133a4:	81 33       	cpi	r24, 0x31	; 49
   133a6:	c1 f4       	brne	.+48     	; 0x133d8 <FSettingSystem+0x17a>
		      IFType=((IFType+1)%3);
   133a8:	80 91 00 01 	lds	r24, 0x0100
   133ac:	90 e0       	ldi	r25, 0x00	; 0
   133ae:	01 96       	adiw	r24, 0x01	; 1
   133b0:	63 e0       	ldi	r22, 0x03	; 3
   133b2:	70 e0       	ldi	r23, 0x00	; 0
   133b4:	0e 94 1e b7 	call	0x16e3c	; 0x16e3c <__divmodhi4>
   133b8:	80 93 00 01 	sts	0x0100, r24
			  SendSlaveCommand(IFType,DispenserBrand);
   133bc:	60 91 51 01 	lds	r22, 0x0151
   133c0:	0e 94 72 74 	call	0xe8e4	; 0xe8e4 <SendSlaveCommand>
			  eeprom_write_byte(&DefInitIFT,IFType);
   133c4:	20 91 00 01 	lds	r18, 0x0100
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   133c8:	e1 99       	sbic	0x1c, 1	; 28
   133ca:	fe cf       	rjmp	.-4      	; 0x133c8 <FSettingSystem+0x16a>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   133cc:	86 e3       	ldi	r24, 0x36	; 54
   133ce:	91 e0       	ldi	r25, 0x01	; 1
   133d0:	9f bb       	out	0x1f, r25	; 31
   133d2:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
   133d4:	2d bb       	out	0x1d, r18	; 29
   133d6:	1f c0       	rjmp	.+62     	; 0x13416 <FSettingSystem+0x1b8>
			  stSettingSytem=ssInitSettingSystem;
		  }
		  else
		  if (KeyChar=='2'){
   133d8:	82 33       	cpi	r24, 0x32	; 50
   133da:	09 f4       	brne	.+2      	; 0x133de <FSettingSystem+0x180>
   133dc:	ba c0       	rjmp	.+372    	; 0x13552 <FSettingSystem+0x2f4>
		      stSettingSytem=ssComSettings;
		  }
		  else
		  if (KeyChar=='3'){
   133de:	83 33       	cpi	r24, 0x33	; 51
   133e0:	01 f5       	brne	.+64     	; 0x13422 <FSettingSystem+0x1c4>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   133e2:	e1 99       	sbic	0x1c, 1	; 28
   133e4:	fe cf       	rjmp	.-4      	; 0x133e2 <FSettingSystem+0x184>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   133e6:	e2 ec       	ldi	r30, 0xC2	; 194
   133e8:	ee 2e       	mov	r14, r30
   133ea:	e3 e0       	ldi	r30, 0x03	; 3
   133ec:	fe 2e       	mov	r15, r30
   133ee:	ff ba       	out	0x1f, r15	; 31
   133f0:	ee ba       	out	0x1e, r14	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   133f2:	e0 9a       	sbi	0x1c, 0	; 28
   133f4:	8d b3       	in	r24, 0x1d	; 29
		      HGMode=eeprom_read_byte(&DefHGMode);
		      HGMode=((HGMode+1)%3);
   133f6:	90 e0       	ldi	r25, 0x00	; 0
   133f8:	01 96       	adiw	r24, 0x01	; 1
   133fa:	63 e0       	ldi	r22, 0x03	; 3
   133fc:	70 e0       	ldi	r23, 0x00	; 0
   133fe:	0e 94 1e b7 	call	0x16e3c	; 0x16e3c <__divmodhi4>
   13402:	18 2f       	mov	r17, r24
			  SendSlaveCommand(SC_HGM_MODE,HGMode);
   13404:	81 e2       	ldi	r24, 0x21	; 33
   13406:	61 2f       	mov	r22, r17
   13408:	0e 94 72 74 	call	0xe8e4	; 0xe8e4 <SendSlaveCommand>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   1340c:	e1 99       	sbic	0x1c, 1	; 28
   1340e:	fe cf       	rjmp	.-4      	; 0x1340c <FSettingSystem+0x1ae>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   13410:	ff ba       	out	0x1f, r15	; 31
   13412:	ee ba       	out	0x1e, r14	; 30
#endif
    EEDR = __value;
   13414:	1d bb       	out	0x1d, r17	; 29

    __asm__ __volatile__ (
   13416:	0f b6       	in	r0, 0x3f	; 63
   13418:	f8 94       	cli
   1341a:	e2 9a       	sbi	0x1c, 2	; 28
   1341c:	e1 9a       	sbi	0x1c, 1	; 28
   1341e:	0f be       	out	0x3f, r0	; 63
   13420:	a4 c0       	rjmp	.+328    	; 0x1356a <FSettingSystem+0x30c>
			  eeprom_write_byte(&DefHGMode,HGMode);
			  stSettingSytem=ssInitSettingSystem;
		  }
		  //else
		  if (KeyChar=='*'){
   13422:	8a 32       	cpi	r24, 0x2A	; 42
   13424:	09 f4       	brne	.+2      	; 0x13428 <FSettingSystem+0x1ca>
   13426:	99 c0       	rjmp	.+306    	; 0x1355a <FSettingSystem+0x2fc>
   13428:	a7 c0       	rjmp	.+334    	; 0x13578 <FSettingSystem+0x31a>
		      stSettingSytem=ssExitSystemSettings;
		  }		  
		  break;
	 case ssComSettings:
	      lcd_clear();
   1342a:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
		  lcd_printf(1,1,PSTR("     -Baudrate-     "));
   1342e:	81 e0       	ldi	r24, 0x01	; 1
   13430:	61 e0       	ldi	r22, 0x01	; 1
   13432:	4d ee       	ldi	r20, 0xED	; 237
   13434:	5d e0       	ldi	r21, 0x0D	; 13
   13436:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
   1343a:	01 e0       	ldi	r16, 0x01	; 1
   1343c:	10 e0       	ldi	r17, 0x00	; 0

		  for (i=0;i<4;i++){
		       bValue=GetBaudrate(eeprom_read_byte(&DefBaudrate[i]));
			   if (bValue==5787)bValue=12213;
		       sprintf_P(lcdteks,PSTR("COM%d:%d"),i+1,bValue);
   1343e:	6e 01       	movw	r12, r28
   13440:	08 94       	sec
   13442:	c1 1c       	adc	r12, r1
   13444:	d1 1c       	adc	r13, r1
   13446:	74 ee       	ldi	r23, 0xE4	; 228
   13448:	a7 2e       	mov	r10, r23
   1344a:	7d e0       	ldi	r23, 0x0D	; 13
   1344c:	b7 2e       	mov	r11, r23
			   lcd_print((2+(i%2)),1+(i/2*11),lcdteks);
   1344e:	6b e0       	ldi	r22, 0x0B	; 11
   13450:	e6 2e       	mov	r14, r22
		      stSettingSytem=ssExitSystemSettings;
		  }		  
		  break;
	 case ssComSettings:
	      lcd_clear();
		  lcd_printf(1,1,PSTR("     -Baudrate-     "));
   13452:	f0 2e       	mov	r15, r16
   13454:	fa 94       	dec	r15
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   13456:	e1 99       	sbic	0x1c, 1	; 28
   13458:	fe cf       	rjmp	.-4      	; 0x13456 <FSettingSystem+0x1f8>
   1345a:	c8 01       	movw	r24, r16
   1345c:	81 5c       	subi	r24, 0xC1	; 193
   1345e:	9e 4f       	sbci	r25, 0xFE	; 254
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   13460:	9f bb       	out	0x1f, r25	; 31
   13462:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   13464:	e0 9a       	sbi	0x1c, 0	; 28
   13466:	8d b3       	in	r24, 0x1d	; 29
	 }
}

int GetBaudrate(char brSetting){
int Result=0;
     switch(brSetting){
   13468:	82 30       	cpi	r24, 0x02	; 2
   1346a:	69 f0       	breq	.+26     	; 0x13486 <FSettingSystem+0x228>
   1346c:	82 30       	cpi	r24, 0x02	; 2
   1346e:	28 f0       	brcs	.+10     	; 0x1347a <FSettingSystem+0x21c>
   13470:	83 30       	cpi	r24, 0x03	; 3
   13472:	31 f4       	brne	.+12     	; 0x13480 <FSettingSystem+0x222>
   13474:	85 eb       	ldi	r24, 0xB5	; 181
   13476:	9f e2       	ldi	r25, 0x2F	; 47
   13478:	08 c0       	rjmp	.+16     	; 0x1348a <FSettingSystem+0x22c>
   1347a:	80 e8       	ldi	r24, 0x80	; 128
   1347c:	95 e2       	ldi	r25, 0x25	; 37
   1347e:	05 c0       	rjmp	.+10     	; 0x1348a <FSettingSystem+0x22c>
   13480:	80 e0       	ldi	r24, 0x00	; 0
   13482:	90 e0       	ldi	r25, 0x00	; 0
   13484:	02 c0       	rjmp	.+4      	; 0x1348a <FSettingSystem+0x22c>
   13486:	80 e0       	ldi	r24, 0x00	; 0
   13488:	9b e4       	ldi	r25, 0x4B	; 75
		  lcd_printf(1,1,PSTR("     -Baudrate-     "));

		  for (i=0;i<4;i++){
		       bValue=GetBaudrate(eeprom_read_byte(&DefBaudrate[i]));
			   if (bValue==5787)bValue=12213;
		       sprintf_P(lcdteks,PSTR("COM%d:%d"),i+1,bValue);
   1348a:	ed b7       	in	r30, 0x3d	; 61
   1348c:	fe b7       	in	r31, 0x3e	; 62
   1348e:	38 97       	sbiw	r30, 0x08	; 8
   13490:	0f b6       	in	r0, 0x3f	; 63
   13492:	f8 94       	cli
   13494:	fe bf       	out	0x3e, r31	; 62
   13496:	0f be       	out	0x3f, r0	; 63
   13498:	ed bf       	out	0x3d, r30	; 61
   1349a:	31 96       	adiw	r30, 0x01	; 1
   1349c:	ad b7       	in	r26, 0x3d	; 61
   1349e:	be b7       	in	r27, 0x3e	; 62
   134a0:	12 96       	adiw	r26, 0x02	; 2
   134a2:	dc 92       	st	X, r13
   134a4:	ce 92       	st	-X, r12
   134a6:	11 97       	sbiw	r26, 0x01	; 1
   134a8:	b3 82       	std	Z+3, r11	; 0x03
   134aa:	a2 82       	std	Z+2, r10	; 0x02
   134ac:	15 83       	std	Z+5, r17	; 0x05
   134ae:	04 83       	std	Z+4, r16	; 0x04
   134b0:	97 83       	std	Z+7, r25	; 0x07
   134b2:	86 83       	std	Z+6, r24	; 0x06
   134b4:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
			   lcd_print((2+(i%2)),1+(i/2*11),lcdteks);
   134b8:	ed b7       	in	r30, 0x3d	; 61
   134ba:	fe b7       	in	r31, 0x3e	; 62
   134bc:	38 96       	adiw	r30, 0x08	; 8
   134be:	0f b6       	in	r0, 0x3f	; 63
   134c0:	f8 94       	cli
   134c2:	fe bf       	out	0x3e, r31	; 62
   134c4:	0f be       	out	0x3f, r0	; 63
   134c6:	ed bf       	out	0x3d, r30	; 61
   134c8:	6f 2d       	mov	r22, r15
   134ca:	66 95       	lsr	r22
   134cc:	6e 9d       	mul	r22, r14
   134ce:	b0 01       	movw	r22, r0
   134d0:	11 24       	eor	r1, r1
   134d2:	6f 5f       	subi	r22, 0xFF	; 255
   134d4:	f1 e0       	ldi	r31, 0x01	; 1
   134d6:	ff 22       	and	r15, r31
   134d8:	8f 2d       	mov	r24, r15
   134da:	8e 5f       	subi	r24, 0xFE	; 254
   134dc:	a6 01       	movw	r20, r12
   134de:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
   134e2:	0f 5f       	subi	r16, 0xFF	; 255
   134e4:	1f 4f       	sbci	r17, 0xFF	; 255
		  break;
	 case ssComSettings:
	      lcd_clear();
		  lcd_printf(1,1,PSTR("     -Baudrate-     "));

		  for (i=0;i<4;i++){
   134e6:	05 30       	cpi	r16, 0x05	; 5
   134e8:	11 05       	cpc	r17, r1
   134ea:	09 f0       	breq	.+2      	; 0x134ee <FSettingSystem+0x290>
   134ec:	b2 cf       	rjmp	.-156    	; 0x13452 <FSettingSystem+0x1f4>
		       bValue=GetBaudrate(eeprom_read_byte(&DefBaudrate[i]));
			   if (bValue==5787)bValue=12213;
		       sprintf_P(lcdteks,PSTR("COM%d:%d"),i+1,bValue);
			   lcd_print((2+(i%2)),1+(i/2*11),lcdteks);
		  }
		  lcd_printf(4,1,PSTR("[*]Back     "));
   134ee:	84 e0       	ldi	r24, 0x04	; 4
   134f0:	61 e0       	ldi	r22, 0x01	; 1
   134f2:	47 ed       	ldi	r20, 0xD7	; 215
   134f4:	5d e0       	ldi	r21, 0x0D	; 13
   134f6:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		  stSettingSytem=ssBaudrateInput;
   134fa:	83 e0       	ldi	r24, 0x03	; 3
   134fc:	2f c0       	rjmp	.+94     	; 0x1355c <FSettingSystem+0x2fe>
	      break;
     case ssBaudrateInput:
	      KeyPressed=_key_scan(1);
   134fe:	81 e0       	ldi	r24, 0x01	; 1
   13500:	0e 94 84 ae 	call	0x15d08	; 0x15d08 <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
   13504:	0e 94 e5 ad 	call	0x15bca	; 0x15bca <_key_btn>
   13508:	28 2f       	mov	r18, r24
		  if ((KeyChar>='1')&&(KeyChar<='4')){
   1350a:	81 53       	subi	r24, 0x31	; 49
   1350c:	84 30       	cpi	r24, 0x04	; 4
   1350e:	18 f5       	brcc	.+70     	; 0x13556 <FSettingSystem+0x2f8>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   13510:	e1 99       	sbic	0x1c, 1	; 28
   13512:	fe cf       	rjmp	.-4      	; 0x13510 <FSettingSystem+0x2b2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   13514:	02 2f       	mov	r16, r18
   13516:	10 e0       	ldi	r17, 0x00	; 0
   13518:	01 5f       	subi	r16, 0xF1	; 241
   1351a:	1e 4f       	sbci	r17, 0xFE	; 254
   1351c:	1f bb       	out	0x1f, r17	; 31
   1351e:	0e bb       	out	0x1e, r16	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   13520:	e0 9a       	sbi	0x1c, 0	; 28
   13522:	8d b3       	in	r24, 0x1d	; 29
		       brVal=eeprom_read_byte(&DefBaudrate[KeyChar-'1']);
			   brVal=((brVal+1)%3)+1;
   13524:	90 e0       	ldi	r25, 0x00	; 0
   13526:	01 96       	adiw	r24, 0x01	; 1
   13528:	63 e0       	ldi	r22, 0x03	; 3
   1352a:	70 e0       	ldi	r23, 0x00	; 0
   1352c:	0e 94 1e b7 	call	0x16e3c	; 0x16e3c <__divmodhi4>
   13530:	f8 2e       	mov	r15, r24
   13532:	f3 94       	inc	r15
			   SetBaudRate(KeyChar-'0',brVal);
   13534:	82 2f       	mov	r24, r18
   13536:	80 53       	subi	r24, 0x30	; 48
   13538:	6f 2d       	mov	r22, r15
   1353a:	0e 94 f9 98 	call	0x131f2	; 0x131f2 <SetBaudRate>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   1353e:	e1 99       	sbic	0x1c, 1	; 28
   13540:	fe cf       	rjmp	.-4      	; 0x1353e <FSettingSystem+0x2e0>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   13542:	1f bb       	out	0x1f, r17	; 31
   13544:	0e bb       	out	0x1e, r16	; 30
#endif
    EEDR = __value;
   13546:	fd ba       	out	0x1d, r15	; 29

    __asm__ __volatile__ (
   13548:	0f b6       	in	r0, 0x3f	; 63
   1354a:	f8 94       	cli
   1354c:	e2 9a       	sbi	0x1c, 2	; 28
   1354e:	e1 9a       	sbi	0x1c, 1	; 28
   13550:	0f be       	out	0x3f, r0	; 63
			   eeprom_write_byte(&DefBaudrate[KeyChar-'1'],brVal);
               stSettingSytem=ssComSettings;
   13552:	82 e0       	ldi	r24, 0x02	; 2
   13554:	03 c0       	rjmp	.+6      	; 0x1355c <FSettingSystem+0x2fe>
		  }else if (KeyChar=='*')
   13556:	2a 32       	cpi	r18, 0x2A	; 42
   13558:	79 f4       	brne	.+30     	; 0x13578 <FSettingSystem+0x31a>
		      stSettingSytem=ssExitSystemSettings;		  	
   1355a:	85 e0       	ldi	r24, 0x05	; 5
   1355c:	80 93 6d 02 	sts	0x026D, r24
   13560:	0b c0       	rjmp	.+22     	; 0x13578 <FSettingSystem+0x31a>
	      break;
	 case ssPumpPoolingSettings:
          SubMenu=FSettingPumpPooling();
   13562:	0e 94 2c 70 	call	0xe058	; 0xe058 <FSettingPumpPooling>
		  if (SubMenu==MENU_DONE)stSettingSytem=ssInitSettingSystem;
   13566:	81 30       	cpi	r24, 0x01	; 1
   13568:	39 f4       	brne	.+14     	; 0x13578 <FSettingSystem+0x31a>
   1356a:	10 92 6d 02 	sts	0x026D, r1
   1356e:	04 c0       	rjmp	.+8      	; 0x13578 <FSettingSystem+0x31a>
	      break;
     case ssExitSystemSettings:
	      stSettingSytem=ssInitSettingSystem;
   13570:	10 92 6d 02 	sts	0x026D, r1
   13574:	81 e0       	ldi	r24, 0x01	; 1
   13576:	01 c0       	rjmp	.+2      	; 0x1357a <FSettingSystem+0x31c>
   13578:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
     return Result;
}
   1357a:	64 96       	adiw	r28, 0x14	; 20
   1357c:	0f b6       	in	r0, 0x3f	; 63
   1357e:	f8 94       	cli
   13580:	de bf       	out	0x3e, r29	; 62
   13582:	0f be       	out	0x3f, r0	; 63
   13584:	cd bf       	out	0x3d, r28	; 61
   13586:	cf 91       	pop	r28
   13588:	df 91       	pop	r29
   1358a:	1f 91       	pop	r17
   1358c:	0f 91       	pop	r16
   1358e:	ff 90       	pop	r15
   13590:	ef 90       	pop	r14
   13592:	df 90       	pop	r13
   13594:	cf 90       	pop	r12
   13596:	bf 90       	pop	r11
   13598:	af 90       	pop	r10
   1359a:	08 95       	ret

0001359c <FMenuSettings>:
char FMenuSettings(){
char Result=MENU_NONE;
static char stMenuSettings=msInit,PageSetting=1;
     char KeyPressed,KeyChar,SubMenu;

     switch(stMenuSettings){
   1359c:	80 91 73 02 	lds	r24, 0x0273
   135a0:	e8 2f       	mov	r30, r24
   135a2:	f0 e0       	ldi	r31, 0x00	; 0
   135a4:	e3 31       	cpi	r30, 0x13	; 19
   135a6:	f1 05       	cpc	r31, r1
   135a8:	08 f0       	brcs	.+2      	; 0x135ac <FMenuSettings+0x10>
   135aa:	bf c0       	rjmp	.+382    	; 0x1372a <FMenuSettings+0x18e>
   135ac:	e5 51       	subi	r30, 0x15	; 21
   135ae:	ff 4f       	sbci	r31, 0xFF	; 255
   135b0:	ee 0f       	add	r30, r30
   135b2:	ff 1f       	adc	r31, r31
   135b4:	05 90       	lpm	r0, Z+
   135b6:	f4 91       	lpm	r31, Z+
   135b8:	e0 2d       	mov	r30, r0
   135ba:	09 94       	ijmp
	 case msInit:
		  lcd_clear();
   135bc:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
		  PageSetting=1;
   135c0:	81 e0       	ldi	r24, 0x01	; 1
   135c2:	80 93 47 01 	sts	0x0147, r24
   135c6:	a9 c0       	rjmp	.+338    	; 0x1371a <FMenuSettings+0x17e>
		  stMenuSettings=msDisplayPage;
		  break;
	 case msDisplayPage:
	      stMenuSettings=msDisplayPage+PageSetting;
   135c8:	80 91 47 01 	lds	r24, 0x0147
   135cc:	8f 5f       	subi	r24, 0xFF	; 255
   135ce:	a5 c0       	rjmp	.+330    	; 0x1371a <FMenuSettings+0x17e>
          break; 	 
	 case msDisplayPage1:
		  lcd_printf(1, 1, PSTR("1)Product  5)Printer"));
   135d0:	81 e0       	ldi	r24, 0x01	; 1
   135d2:	61 e0       	ldi	r22, 0x01	; 1
   135d4:	41 ee       	ldi	r20, 0xE1	; 225
   135d6:	52 e1       	ldi	r21, 0x12	; 18
   135d8:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		  lcd_printf(2, 1, PSTR("2)Pump     6)Host   "));
   135dc:	82 e0       	ldi	r24, 0x02	; 2
   135de:	61 e0       	ldi	r22, 0x01	; 1
   135e0:	4c ec       	ldi	r20, 0xCC	; 204
   135e2:	52 e1       	ldi	r21, 0x12	; 18
   135e4:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		  lcd_printf(3, 1, PSTR("3)Decimal  7)Next   "));
   135e8:	83 e0       	ldi	r24, 0x03	; 3
   135ea:	61 e0       	ldi	r22, 0x01	; 1
   135ec:	47 eb       	ldi	r20, 0xB7	; 183
   135ee:	52 e1       	ldi	r21, 0x12	; 18
   135f0:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		  lcd_printf(4, 1, PSTR("4)Datetime *)Exit   "));
   135f4:	84 e0       	ldi	r24, 0x04	; 4
   135f6:	61 e0       	ldi	r22, 0x01	; 1
   135f8:	42 ea       	ldi	r20, 0xA2	; 162
   135fa:	52 e1       	ldi	r21, 0x12	; 18
   135fc:	16 c0       	rjmp	.+44     	; 0x1362a <FMenuSettings+0x8e>
		  stMenuSettings=msSelection;
	      break;
	 case msDisplayPage2:
		  lcd_printf(1, 1, PSTR("1)Operator          "));
   135fe:	81 e0       	ldi	r24, 0x01	; 1
   13600:	61 e0       	ldi	r22, 0x01	; 1
   13602:	4d e8       	ldi	r20, 0x8D	; 141
   13604:	52 e1       	ldi	r21, 0x12	; 18
   13606:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		  lcd_printf(2, 1, PSTR("2)System            "));
   1360a:	82 e0       	ldi	r24, 0x02	; 2
   1360c:	61 e0       	ldi	r22, 0x01	; 1
   1360e:	48 e7       	ldi	r20, 0x78	; 120
   13610:	52 e1       	ldi	r21, 0x12	; 18
   13612:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		  lcd_printf(3, 1, PSTR("3)PumpPooling       "));
   13616:	83 e0       	ldi	r24, 0x03	; 3
   13618:	61 e0       	ldi	r22, 0x01	; 1
   1361a:	43 e6       	ldi	r20, 0x63	; 99
   1361c:	52 e1       	ldi	r21, 0x12	; 18
   1361e:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		  lcd_printf(4, 1, PSTR("*)Back              "));
   13622:	84 e0       	ldi	r24, 0x04	; 4
   13624:	61 e0       	ldi	r22, 0x01	; 1
   13626:	4e e4       	ldi	r20, 0x4E	; 78
   13628:	52 e1       	ldi	r21, 0x12	; 18
   1362a:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		  stMenuSettings=msSelection;
   1362e:	84 e0       	ldi	r24, 0x04	; 4
   13630:	74 c0       	rjmp	.+232    	; 0x1371a <FMenuSettings+0x17e>
	      break;
	 case msSelection:
	      stMenuSettings=msSelection+PageSetting;
   13632:	80 91 47 01 	lds	r24, 0x0147
   13636:	8c 5f       	subi	r24, 0xFC	; 252
   13638:	70 c0       	rjmp	.+224    	; 0x1371a <FMenuSettings+0x17e>
          break;	 
	 case msSelectionPage1:
		  KeyPressed=_key_scan(1);
   1363a:	81 e0       	ldi	r24, 0x01	; 1
   1363c:	0e 94 84 ae 	call	0x15d08	; 0x15d08 <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
   13640:	0e 94 e5 ad 	call	0x15bca	; 0x15bca <_key_btn>
		  switch(KeyChar){
   13644:	84 33       	cpi	r24, 0x34	; 52
   13646:	d1 f0       	breq	.+52     	; 0x1367c <FMenuSettings+0xe0>
   13648:	85 33       	cpi	r24, 0x35	; 53
   1364a:	50 f4       	brcc	.+20     	; 0x13660 <FMenuSettings+0xc4>
   1364c:	82 33       	cpi	r24, 0x32	; 50
   1364e:	91 f0       	breq	.+36     	; 0x13674 <FMenuSettings+0xd8>
   13650:	83 33       	cpi	r24, 0x33	; 51
   13652:	90 f4       	brcc	.+36     	; 0x13678 <FMenuSettings+0xdc>
   13654:	8a 32       	cpi	r24, 0x2A	; 42
   13656:	d1 f0       	breq	.+52     	; 0x1368c <FMenuSettings+0xf0>
   13658:	81 33       	cpi	r24, 0x31	; 49
   1365a:	09 f0       	breq	.+2      	; 0x1365e <FMenuSettings+0xc2>
   1365c:	66 c0       	rjmp	.+204    	; 0x1372a <FMenuSettings+0x18e>
   1365e:	08 c0       	rjmp	.+16     	; 0x13670 <FMenuSettings+0xd4>
   13660:	86 33       	cpi	r24, 0x36	; 54
   13662:	81 f0       	breq	.+32     	; 0x13684 <FMenuSettings+0xe8>
   13664:	86 33       	cpi	r24, 0x36	; 54
   13666:	60 f0       	brcs	.+24     	; 0x13680 <FMenuSettings+0xe4>
   13668:	87 33       	cpi	r24, 0x37	; 55
   1366a:	09 f0       	breq	.+2      	; 0x1366e <FMenuSettings+0xd2>
   1366c:	5e c0       	rjmp	.+188    	; 0x1372a <FMenuSettings+0x18e>
   1366e:	0c c0       	rjmp	.+24     	; 0x13688 <FMenuSettings+0xec>
		  case '1':
		       stMenuSettings=msMenuSettingProduct;
   13670:	89 e0       	ldi	r24, 0x09	; 9
   13672:	53 c0       	rjmp	.+166    	; 0x1371a <FMenuSettings+0x17e>
		       break;
		  case '2': 
		       stMenuSettings=msMenuSettingPump;
   13674:	8a e0       	ldi	r24, 0x0A	; 10
   13676:	51 c0       	rjmp	.+162    	; 0x1371a <FMenuSettings+0x17e>
		       break;
		  case '3':
		       stMenuSettings=msMenuSettingDec;
   13678:	8b e0       	ldi	r24, 0x0B	; 11
   1367a:	4f c0       	rjmp	.+158    	; 0x1371a <FMenuSettings+0x17e>
		       break;
		  case '4':
		       stMenuSettings=msMenuSettingDatetime;
   1367c:	8c e0       	ldi	r24, 0x0C	; 12
   1367e:	4d c0       	rjmp	.+154    	; 0x1371a <FMenuSettings+0x17e>
		       break;
		  case '5':
		       stMenuSettings=msMenuSettingPrinter;
   13680:	8d e0       	ldi	r24, 0x0D	; 13
   13682:	4b c0       	rjmp	.+150    	; 0x1371a <FMenuSettings+0x17e>
		       break;
		  case '6':
		       stMenuSettings=msMenuSettingHost;
   13684:	8e e0       	ldi	r24, 0x0E	; 14
   13686:	49 c0       	rjmp	.+146    	; 0x1371a <FMenuSettings+0x17e>
		       break;
		  case '7':
		       stMenuSettings=msMenuSettingNextPage;
   13688:	87 e0       	ldi	r24, 0x07	; 7
   1368a:	47 c0       	rjmp	.+142    	; 0x1371a <FMenuSettings+0x17e>
		       break;
		  case '*':
		       stMenuSettings=msMenuSettingExit;
   1368c:	82 e1       	ldi	r24, 0x12	; 18
   1368e:	45 c0       	rjmp	.+138    	; 0x1371a <FMenuSettings+0x17e>
		       break;			   
		  }
	      break;
	 case msSelectionPage2:
	 	  KeyPressed=_key_scan(1);
   13690:	81 e0       	ldi	r24, 0x01	; 1
   13692:	0e 94 84 ae 	call	0x15d08	; 0x15d08 <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
   13696:	0e 94 e5 ad 	call	0x15bca	; 0x15bca <_key_btn>
		  switch(KeyChar){
   1369a:	82 33       	cpi	r24, 0x32	; 50
   1369c:	69 f0       	breq	.+26     	; 0x136b8 <FMenuSettings+0x11c>
   1369e:	83 33       	cpi	r24, 0x33	; 51
   136a0:	30 f4       	brcc	.+12     	; 0x136ae <FMenuSettings+0x112>
   136a2:	8a 32       	cpi	r24, 0x2A	; 42
   136a4:	69 f0       	breq	.+26     	; 0x136c0 <FMenuSettings+0x124>
   136a6:	81 33       	cpi	r24, 0x31	; 49
   136a8:	09 f0       	breq	.+2      	; 0x136ac <FMenuSettings+0x110>
   136aa:	3f c0       	rjmp	.+126    	; 0x1372a <FMenuSettings+0x18e>
   136ac:	03 c0       	rjmp	.+6      	; 0x136b4 <FMenuSettings+0x118>
   136ae:	83 33       	cpi	r24, 0x33	; 51
   136b0:	e1 f5       	brne	.+120    	; 0x1372a <FMenuSettings+0x18e>
   136b2:	04 c0       	rjmp	.+8      	; 0x136bc <FMenuSettings+0x120>
		  case '1':
		       stMenuSettings=msMenuSettingOperator;
   136b4:	8f e0       	ldi	r24, 0x0F	; 15
   136b6:	31 c0       	rjmp	.+98     	; 0x1371a <FMenuSettings+0x17e>
		       break;
		  case '2':
		       stMenuSettings=msMenuSettingSystem;
   136b8:	80 e1       	ldi	r24, 0x10	; 16
   136ba:	2f c0       	rjmp	.+94     	; 0x1371a <FMenuSettings+0x17e>
		       break;
		  case '3':
		       stMenuSettings=msMenuSettingPumpPooling;
   136bc:	81 e1       	ldi	r24, 0x11	; 17
   136be:	2d c0       	rjmp	.+90     	; 0x1371a <FMenuSettings+0x17e>
		       break;
		  case '*':
		       stMenuSettings=msMenuSettingBackPage;
   136c0:	88 e0       	ldi	r24, 0x08	; 8
   136c2:	2b c0       	rjmp	.+86     	; 0x1371a <FMenuSettings+0x17e>
		       break;		  
		  }
	      break;
		  
	 case msMenuSettingNextPage:
	      if (PageSetting<2)PageSetting++;
   136c4:	80 91 47 01 	lds	r24, 0x0147
   136c8:	82 30       	cpi	r24, 0x02	; 2
   136ca:	d8 f4       	brcc	.+54     	; 0x13702 <FMenuSettings+0x166>
   136cc:	8f 5f       	subi	r24, 0xFF	; 255
   136ce:	05 c0       	rjmp	.+10     	; 0x136da <FMenuSettings+0x13e>
		  stMenuSettings=msDisplayPage;
	      break;
	 case msMenuSettingBackPage:
	      if (PageSetting>1)PageSetting--;
   136d0:	80 91 47 01 	lds	r24, 0x0147
   136d4:	82 30       	cpi	r24, 0x02	; 2
   136d6:	a8 f0       	brcs	.+42     	; 0x13702 <FMenuSettings+0x166>
   136d8:	81 50       	subi	r24, 0x01	; 1
   136da:	80 93 47 01 	sts	0x0147, r24
   136de:	11 c0       	rjmp	.+34     	; 0x13702 <FMenuSettings+0x166>
		  stMenuSettings=msDisplayPage;
	      break;
//---Sub Menu Operations--------------------------------------------		  
     case msMenuSettingProduct:
	      SubMenu=FSettingProduct();
   136e0:	0e 94 6d 8a 	call	0x114da	; 0x114da <FSettingProduct>
   136e4:	18 c0       	rjmp	.+48     	; 0x13716 <FMenuSettings+0x17a>
		  if (SubMenu==MENU_DONE)stMenuSettings=msDisplayPage;
	      break;
	 case msMenuSettingPump:
	      SubMenu=FSettingPump();
   136e6:	0e 94 22 78 	call	0xf044	; 0xf044 <FSettingPump>
   136ea:	15 c0       	rjmp	.+42     	; 0x13716 <FMenuSettings+0x17a>
		  if (SubMenu==MENU_DONE)stMenuSettings=msDisplayPage;
	      break;
	 case msMenuSettingDec:
	      SubMenu=FSettingDec();
   136ec:	0e 94 36 83 	call	0x1066c	; 0x1066c <FSettingDec>
   136f0:	12 c0       	rjmp	.+36     	; 0x13716 <FMenuSettings+0x17a>
	 }
     return Result;
}

char FSettingDatetime(){
     _menu_datetime();
   136f2:	0e 94 16 64 	call	0xc82c	; 0xc82c <_menu_datetime>
   136f6:	05 c0       	rjmp	.+10     	; 0x13702 <FMenuSettings+0x166>
     return MENU_DONE;
}
char FSettingPrinter(){
     _menu_printer();
   136f8:	0e 94 dd 47 	call	0x8fba	; 0x8fba <_menu_printer>
   136fc:	02 c0       	rjmp	.+4      	; 0x13702 <FMenuSettings+0x166>
	 return MENU_DONE;
}
char FSettingHost(){
     _menu_host();
   136fe:	0e 94 2a 46 	call	0x8c54	; 0x8c54 <_menu_host>
	      SubMenu=FSettingPrinter();
		  if (SubMenu==MENU_DONE)stMenuSettings=msDisplayPage;
	      break;
	 case msMenuSettingHost:
	      SubMenu=FSettingHost();
		  if (SubMenu==MENU_DONE)stMenuSettings=msDisplayPage;
   13702:	81 e0       	ldi	r24, 0x01	; 1
   13704:	0a c0       	rjmp	.+20     	; 0x1371a <FMenuSettings+0x17e>
	      break;
     case msMenuSettingOperator:
          SubMenu=FSettingOperator();
   13706:	0e 94 80 87 	call	0x10f00	; 0x10f00 <FSettingOperator>
   1370a:	05 c0       	rjmp	.+10     	; 0x13716 <FMenuSettings+0x17a>
		  if (SubMenu==MENU_DONE)stMenuSettings=msDisplayPage;
	      break;
	 case msMenuSettingSystem:
	      SubMenu=FSettingSystem();
   1370c:	0e 94 2f 99 	call	0x1325e	; 0x1325e <FSettingSystem>
   13710:	02 c0       	rjmp	.+4      	; 0x13716 <FMenuSettings+0x17a>
		  if (SubMenu==MENU_DONE)stMenuSettings=msDisplayPage;
	      break;	 
     case msMenuSettingPumpPooling:
	      SubMenu=FSettingPumpPooling();
   13712:	0e 94 2c 70 	call	0xe058	; 0xe058 <FSettingPumpPooling>
		  if (SubMenu==MENU_DONE)stMenuSettings=msDisplayPage;
   13716:	81 30       	cpi	r24, 0x01	; 1
   13718:	41 f4       	brne	.+16     	; 0x1372a <FMenuSettings+0x18e>
   1371a:	80 93 73 02 	sts	0x0273, r24
   1371e:	80 e0       	ldi	r24, 0x00	; 0
   13720:	08 95       	ret
	      break;
//------------------------------------------------------------------
     case msMenuSettingExit:
	      stMenuSettings=msInit;
   13722:	10 92 73 02 	sts	0x0273, r1
   13726:	81 e0       	ldi	r24, 0x01	; 1
   13728:	08 95       	ret
   1372a:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
   return Result;
}
   1372c:	08 95       	ret

0001372e <FMenuAuthorization>:


char FMenuAuthorization(){
char Result=MENU_NONE,PassResult=MP_NONE,SubMenu=MENU_NONE;
static char stMenuAuthorization=maInit,PassTry=0;
     switch(stMenuAuthorization){
   1372e:	80 91 ac 02 	lds	r24, 0x02AC
   13732:	83 30       	cpi	r24, 0x03	; 3
   13734:	51 f1       	breq	.+84     	; 0x1378a <FMenuAuthorization+0x5c>
   13736:	84 30       	cpi	r24, 0x04	; 4
   13738:	28 f4       	brcc	.+10     	; 0x13744 <FMenuAuthorization+0x16>
   1373a:	81 30       	cpi	r24, 0x01	; 1
   1373c:	81 f0       	breq	.+32     	; 0x1375e <FMenuAuthorization+0x30>
   1373e:	82 30       	cpi	r24, 0x02	; 2
   13740:	38 f5       	brcc	.+78     	; 0x13790 <FMenuAuthorization+0x62>
   13742:	0a c0       	rjmp	.+20     	; 0x13758 <FMenuAuthorization+0x2a>
   13744:	85 30       	cpi	r24, 0x05	; 5
   13746:	61 f1       	breq	.+88     	; 0x137a0 <FMenuAuthorization+0x72>
   13748:	85 30       	cpi	r24, 0x05	; 5
   1374a:	28 f1       	brcs	.+74     	; 0x13796 <FMenuAuthorization+0x68>
   1374c:	86 30       	cpi	r24, 0x06	; 6
   1374e:	e1 f1       	breq	.+120    	; 0x137c8 <FMenuAuthorization+0x9a>
   13750:	87 30       	cpi	r24, 0x07	; 7
   13752:	09 f0       	breq	.+2      	; 0x13756 <FMenuAuthorization+0x28>
   13754:	4c c0       	rjmp	.+152    	; 0x137ee <FMenuAuthorization+0xc0>
   13756:	47 c0       	rjmp	.+142    	; 0x137e6 <FMenuAuthorization+0xb8>
	 case maInit:
	      PassTry=0;
   13758:	10 92 ab 02 	sts	0x02AB, r1
   1375c:	3d c0       	rjmp	.+122    	; 0x137d8 <FMenuAuthorization+0xaa>
		  stMenuAuthorization=maInputPassword;
	      break;
	 case maInputPassword:
	      PassResult=FMenuPassword();
   1375e:	0e 94 5d 92 	call	0x124ba	; 0x124ba <FMenuPassword>
		  switch(PassResult){
   13762:	83 30       	cpi	r24, 0x03	; 3
   13764:	e1 f1       	breq	.+120    	; 0x137de <FMenuAuthorization+0xb0>
   13766:	84 30       	cpi	r24, 0x04	; 4
   13768:	28 f4       	brcc	.+10     	; 0x13774 <FMenuAuthorization+0x46>
   1376a:	81 30       	cpi	r24, 0x01	; 1
   1376c:	b9 f1       	breq	.+110    	; 0x137dc <FMenuAuthorization+0xae>
   1376e:	82 30       	cpi	r24, 0x02	; 2
   13770:	f1 f5       	brne	.+124    	; 0x137ee <FMenuAuthorization+0xc0>
   13772:	09 c0       	rjmp	.+18     	; 0x13786 <FMenuAuthorization+0x58>
   13774:	84 30       	cpi	r24, 0x04	; 4
   13776:	19 f0       	breq	.+6      	; 0x1377e <FMenuAuthorization+0x50>
   13778:	85 30       	cpi	r24, 0x05	; 5
   1377a:	c9 f5       	brne	.+114    	; 0x137ee <FMenuAuthorization+0xc0>
   1377c:	02 c0       	rjmp	.+4      	; 0x13782 <FMenuAuthorization+0x54>
		  case MP_VALID_ADMIN:
		       stMenuAuthorization=maMenuAdmin;
   1377e:	82 e0       	ldi	r24, 0x02	; 2
   13780:	2e c0       	rjmp	.+92     	; 0x137de <FMenuAuthorization+0xb0>
		       break;
		  case MP_VALID_SYSTEM:
		       stMenuAuthorization=maMenuSettings;
   13782:	84 e0       	ldi	r24, 0x04	; 4
   13784:	2c c0       	rjmp	.+88     	; 0x137de <FMenuAuthorization+0xb0>
		       break;
		  case MP_INVALID:
		       stMenuAuthorization=maInvalidAuthorization;
   13786:	85 e0       	ldi	r24, 0x05	; 5
   13788:	2a c0       	rjmp	.+84     	; 0x137de <FMenuAuthorization+0xb0>
		  else
	      if (PassResult==MP_CANCEL)stMenuAuthorization=maExitAuthorization;
		  */
	      break;
	 case maMenuMaster:
	      SubMenu=FMenuMaster();
   1378a:	0e 94 4c 90 	call	0x12098	; 0x12098 <FMenuMaster>
   1378e:	05 c0       	rjmp	.+10     	; 0x1379a <FMenuAuthorization+0x6c>
		  if (SubMenu==MENU_DONE)stMenuAuthorization=maExitAuthorization;
	      break;
	 case maMenuAdmin:
          SubMenu=FMenuAdmin();
   13790:	0e 94 4c 94 	call	0x12898	; 0x12898 <FMenuAdmin>
   13794:	02 c0       	rjmp	.+4      	; 0x1379a <FMenuAuthorization+0x6c>
		  if (SubMenu==MENU_DONE)stMenuAuthorization=maExitAuthorization;          
		  break;
	 case maMenuSettings:
	      SubMenu=FMenuSettings();
   13796:	0e 94 ce 9a 	call	0x1359c	; 0x1359c <FMenuSettings>
		  if (SubMenu==MENU_DONE)stMenuAuthorization=maExitAuthorization;
   1379a:	81 30       	cpi	r24, 0x01	; 1
   1379c:	41 f5       	brne	.+80     	; 0x137ee <FMenuAuthorization+0xc0>
   1379e:	1e c0       	rjmp	.+60     	; 0x137dc <FMenuAuthorization+0xae>
          break;	 
	 case maInvalidAuthorization:
	      PassTry++;
   137a0:	80 91 ab 02 	lds	r24, 0x02AB
   137a4:	8f 5f       	subi	r24, 0xFF	; 255
   137a6:	80 93 ab 02 	sts	0x02AB, r24
	      TimDisplay=0;
   137aa:	10 92 95 01 	sts	0x0195, r1
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   137ae:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   137b0:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   137b2:	81 e0       	ldi	r24, 0x01	; 1
   137b4:	80 93 bf 01 	sts	0x01BF, r24
          break;	 
	 case maInvalidAuthorization:
	      PassTry++;
	      TimDisplay=0;
		  system_beep(1);
		  lcd_printf(3,1,PSTR("Access Denied"));
   137b8:	83 e0       	ldi	r24, 0x03	; 3
   137ba:	61 e0       	ldi	r22, 0x01	; 1
   137bc:	40 e5       	ldi	r20, 0x50	; 80
   137be:	58 e1       	ldi	r21, 0x18	; 24
   137c0:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		  stMenuAuthorization=maDelayExitAuthorization;
   137c4:	86 e0       	ldi	r24, 0x06	; 6
   137c6:	0b c0       	rjmp	.+22     	; 0x137de <FMenuAuthorization+0xb0>
          break;	 
	 case maDelayExitAuthorization:
	      if (TimDisplay>2){
   137c8:	80 91 95 01 	lds	r24, 0x0195
   137cc:	83 30       	cpi	r24, 0x03	; 3
   137ce:	78 f0       	brcs	.+30     	; 0x137ee <FMenuAuthorization+0xc0>
		      if (PassTry<3)stMenuAuthorization=maInputPassword;
   137d0:	80 91 ab 02 	lds	r24, 0x02AB
   137d4:	83 30       	cpi	r24, 0x03	; 3
   137d6:	10 f4       	brcc	.+4      	; 0x137dc <FMenuAuthorization+0xae>
   137d8:	81 e0       	ldi	r24, 0x01	; 1
   137da:	01 c0       	rjmp	.+2      	; 0x137de <FMenuAuthorization+0xb0>
			  else stMenuAuthorization=maExitAuthorization;
   137dc:	87 e0       	ldi	r24, 0x07	; 7
   137de:	80 93 ac 02 	sts	0x02AC, r24
   137e2:	80 e0       	ldi	r24, 0x00	; 0
   137e4:	08 95       	ret
		  }
	      break;
	 case maExitAuthorization:
	      stMenuAuthorization=maInit;
   137e6:	10 92 ac 02 	sts	0x02AC, r1
   137ea:	81 e0       	ldi	r24, 0x01	; 1
   137ec:	08 95       	ret
   137ee:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
   return Result;	 
}
   137f0:	08 95       	ret

000137f2 <InitComport>:
     	  break;	 
	 }
   return Result;
}

void InitComport(){
   137f2:	af 92       	push	r10
   137f4:	bf 92       	push	r11
   137f6:	cf 92       	push	r12
   137f8:	df 92       	push	r13
   137fa:	ff 92       	push	r15
   137fc:	0f 93       	push	r16
   137fe:	1f 93       	push	r17
   13800:	df 93       	push	r29
   13802:	cf 93       	push	r28
   13804:	cd b7       	in	r28, 0x3d	; 61
   13806:	de b7       	in	r29, 0x3e	; 62
   13808:	64 97       	sbiw	r28, 0x14	; 20
   1380a:	0f b6       	in	r0, 0x3f	; 63
   1380c:	f8 94       	cli
   1380e:	de bf       	out	0x3e, r29	; 62
   13810:	0f be       	out	0x3f, r0	; 63
   13812:	cd bf       	out	0x3d, r28	; 61
     char brMap,i=0,lcdteks[20];	 
	 int bValue;
	 lcd_printf(3, 1, PSTR("Initialize COM ..."));
   13814:	83 e0       	ldi	r24, 0x03	; 3
   13816:	61 e0       	ldi	r22, 0x01	; 1
   13818:	49 ee       	ldi	r20, 0xE9	; 233
   1381a:	5c e1       	ldi	r21, 0x1C	; 28
   1381c:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
   13820:	01 e0       	ldi	r16, 0x01	; 1
   13822:	10 e0       	ldi	r17, 0x00	; 0
     for(i=0;i<4;i++){
	     brMap=eeprom_read_byte(&DefBaudrate[i]);
		 bValue=GetBaudrate(brMap);
		 if (bValue==5787)bValue=12213;
		 sprintf_P(lcdteks,PSTR("COM%d:%i           "),i+1,bValue);
   13824:	6e 01       	movw	r12, r28
   13826:	08 94       	sec
   13828:	c1 1c       	adc	r12, r1
   1382a:	d1 1c       	adc	r13, r1
   1382c:	f5 ed       	ldi	r31, 0xD5	; 213
   1382e:	af 2e       	mov	r10, r31
   13830:	fc e1       	ldi	r31, 0x1C	; 28
   13832:	bf 2e       	mov	r11, r31
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   13834:	e1 99       	sbic	0x1c, 1	; 28
   13836:	fe cf       	rjmp	.-4      	; 0x13834 <InitComport+0x42>
   13838:	c8 01       	movw	r24, r16
   1383a:	81 5c       	subi	r24, 0xC1	; 193
   1383c:	9e 4f       	sbci	r25, 0xFE	; 254
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   1383e:	9f bb       	out	0x1f, r25	; 31
   13840:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   13842:	e0 9a       	sbi	0x1c, 0	; 28
   13844:	fd b2       	in	r15, 0x1d	; 29
	 }
}

int GetBaudrate(char brSetting){
int Result=0;
     switch(brSetting){
   13846:	22 e0       	ldi	r18, 0x02	; 2
   13848:	f2 16       	cp	r15, r18
   1384a:	71 f0       	breq	.+28     	; 0x13868 <InitComport+0x76>
   1384c:	f2 16       	cp	r15, r18
   1384e:	30 f0       	brcs	.+12     	; 0x1385c <InitComport+0x6a>
   13850:	33 e0       	ldi	r19, 0x03	; 3
   13852:	f3 16       	cp	r15, r19
   13854:	31 f4       	brne	.+12     	; 0x13862 <InitComport+0x70>
   13856:	85 eb       	ldi	r24, 0xB5	; 181
   13858:	9f e2       	ldi	r25, 0x2F	; 47
   1385a:	08 c0       	rjmp	.+16     	; 0x1386c <InitComport+0x7a>
   1385c:	80 e8       	ldi	r24, 0x80	; 128
   1385e:	95 e2       	ldi	r25, 0x25	; 37
   13860:	05 c0       	rjmp	.+10     	; 0x1386c <InitComport+0x7a>
   13862:	80 e0       	ldi	r24, 0x00	; 0
   13864:	90 e0       	ldi	r25, 0x00	; 0
   13866:	02 c0       	rjmp	.+4      	; 0x1386c <InitComport+0x7a>
   13868:	80 e0       	ldi	r24, 0x00	; 0
   1386a:	9b e4       	ldi	r25, 0x4B	; 75
	 lcd_printf(3, 1, PSTR("Initialize COM ..."));
     for(i=0;i<4;i++){
	     brMap=eeprom_read_byte(&DefBaudrate[i]);
		 bValue=GetBaudrate(brMap);
		 if (bValue==5787)bValue=12213;
		 sprintf_P(lcdteks,PSTR("COM%d:%i           "),i+1,bValue);
   1386c:	ad b7       	in	r26, 0x3d	; 61
   1386e:	be b7       	in	r27, 0x3e	; 62
   13870:	18 97       	sbiw	r26, 0x08	; 8
   13872:	0f b6       	in	r0, 0x3f	; 63
   13874:	f8 94       	cli
   13876:	be bf       	out	0x3e, r27	; 62
   13878:	0f be       	out	0x3f, r0	; 63
   1387a:	ad bf       	out	0x3d, r26	; 61
   1387c:	ed b7       	in	r30, 0x3d	; 61
   1387e:	fe b7       	in	r31, 0x3e	; 62
   13880:	31 96       	adiw	r30, 0x01	; 1
   13882:	12 96       	adiw	r26, 0x02	; 2
   13884:	dc 92       	st	X, r13
   13886:	ce 92       	st	-X, r12
   13888:	11 97       	sbiw	r26, 0x01	; 1
   1388a:	b3 82       	std	Z+3, r11	; 0x03
   1388c:	a2 82       	std	Z+2, r10	; 0x02
   1388e:	15 83       	std	Z+5, r17	; 0x05
   13890:	04 83       	std	Z+4, r16	; 0x04
   13892:	97 83       	std	Z+7, r25	; 0x07
   13894:	86 83       	std	Z+6, r24	; 0x06
   13896:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
		 lcd_print(4,1,lcdteks);
   1389a:	2d b7       	in	r18, 0x3d	; 61
   1389c:	3e b7       	in	r19, 0x3e	; 62
   1389e:	28 5f       	subi	r18, 0xF8	; 248
   138a0:	3f 4f       	sbci	r19, 0xFF	; 255
   138a2:	0f b6       	in	r0, 0x3f	; 63
   138a4:	f8 94       	cli
   138a6:	3e bf       	out	0x3e, r19	; 62
   138a8:	0f be       	out	0x3f, r0	; 63
   138aa:	2d bf       	out	0x3d, r18	; 61
   138ac:	84 e0       	ldi	r24, 0x04	; 4
   138ae:	61 e0       	ldi	r22, 0x01	; 1
   138b0:	a6 01       	movw	r20, r12
   138b2:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
		 SetBaudRate(i+1,brMap);
   138b6:	80 2f       	mov	r24, r16
   138b8:	6f 2d       	mov	r22, r15
   138ba:	0e 94 f9 98 	call	0x131f2	; 0x131f2 <SetBaudRate>
 	     TimDisplay=0;
   138be:	10 92 95 01 	sts	0x0195, r1
   138c2:	04 c0       	rjmp	.+8      	; 0x138cc <InitComport+0xda>
	     while(TimDisplay<2){
		     if (TimDisplay>2)break;
   138c4:	80 91 95 01 	lds	r24, 0x0195
   138c8:	83 30       	cpi	r24, 0x03	; 3
   138ca:	20 f4       	brcc	.+8      	; 0x138d4 <InitComport+0xe2>
		 if (bValue==5787)bValue=12213;
		 sprintf_P(lcdteks,PSTR("COM%d:%i           "),i+1,bValue);
		 lcd_print(4,1,lcdteks);
		 SetBaudRate(i+1,brMap);
 	     TimDisplay=0;
	     while(TimDisplay<2){
   138cc:	80 91 95 01 	lds	r24, 0x0195
   138d0:	82 30       	cpi	r24, 0x02	; 2
   138d2:	c0 f3       	brcs	.-16     	; 0x138c4 <InitComport+0xd2>
   138d4:	0f 5f       	subi	r16, 0xFF	; 255
   138d6:	1f 4f       	sbci	r17, 0xFF	; 255

void InitComport(){
     char brMap,i=0,lcdteks[20];	 
	 int bValue;
	 lcd_printf(3, 1, PSTR("Initialize COM ..."));
     for(i=0;i<4;i++){
   138d8:	05 30       	cpi	r16, 0x05	; 5
   138da:	11 05       	cpc	r17, r1
   138dc:	09 f0       	breq	.+2      	; 0x138e0 <InitComport+0xee>
   138de:	aa cf       	rjmp	.-172    	; 0x13834 <InitComport+0x42>
	     while(TimDisplay<2){
		     if (TimDisplay>2)break;
		 };

	 }
}
   138e0:	64 96       	adiw	r28, 0x14	; 20
   138e2:	0f b6       	in	r0, 0x3f	; 63
   138e4:	f8 94       	cli
   138e6:	de bf       	out	0x3e, r29	; 62
   138e8:	0f be       	out	0x3f, r0	; 63
   138ea:	cd bf       	out	0x3d, r28	; 61
   138ec:	cf 91       	pop	r28
   138ee:	df 91       	pop	r29
   138f0:	1f 91       	pop	r17
   138f2:	0f 91       	pop	r16
   138f4:	ff 90       	pop	r15
   138f6:	df 90       	pop	r13
   138f8:	cf 90       	pop	r12
   138fa:	bf 90       	pop	r11
   138fc:	af 90       	pop	r10
   138fe:	08 95       	ret

00013900 <sendMessage56>:
    _uart_print(1, 0,strSend);
	_uart(1, 1,0x02);

}

void sendMessage56(){
   13900:	0f 93       	push	r16
   13902:	1f 93       	push	r17
   13904:	df 93       	push	r29
   13906:	cf 93       	push	r28
   13908:	cd b7       	in	r28, 0x3d	; 61
   1390a:	de b7       	in	r29, 0x3e	; 62
   1390c:	ec 97       	sbiw	r28, 0x3c	; 60
   1390e:	0f b6       	in	r0, 0x3f	; 63
   13910:	f8 94       	cli
   13912:	de bf       	out	0x3e, r29	; 62
   13914:	0f be       	out	0x3f, r0	; 63
   13916:	cd bf       	out	0x3d, r28	; 61
	char strSend[60];
	_uart(1, 1,0x01);
   13918:	81 e0       	ldi	r24, 0x01	; 1
   1391a:	61 e0       	ldi	r22, 0x01	; 1
   1391c:	41 e0       	ldi	r20, 0x01	; 1
   1391e:	0e 94 53 b2 	call	0x164a6	; 0x164a6 <_uart>
	UpdateIFT_ID(); //ReadIFT_ID
   13922:	0e 94 71 1b 	call	0x36e2	; 0x36e2 <UpdateIFT_ID>
	UpdateSeqNum(); //UpdateSeqNum SeqNum++
   13926:	0e 94 46 1b 	call	0x368c	; 0x368c <UpdateSeqNum>
	UpdateClientIP();//ReadSourceIP
   1392a:	0e 94 3b 1f 	call	0x3e76	; 0x3e76 <UpdateClientIP>
	UpdateServerIP();//ReadDestIP
   1392e:	0e 94 d3 1e 	call	0x3da6	; 0x3da6 <UpdateServerIP>
	UpdateCardID();  //ReadCardID
   13932:	0e 94 ad 3f 	call	0x7f5a	; 0x7f5a <UpdateCardID>

	sprintf_P(strSend,PSTR("%s%s%s"),strIFT_ID,strSeqNum,strClientIP);
   13936:	8d b7       	in	r24, 0x3d	; 61
   13938:	9e b7       	in	r25, 0x3e	; 62
   1393a:	0a 97       	sbiw	r24, 0x0a	; 10
   1393c:	0f b6       	in	r0, 0x3f	; 63
   1393e:	f8 94       	cli
   13940:	9e bf       	out	0x3e, r25	; 62
   13942:	0f be       	out	0x3f, r0	; 63
   13944:	8d bf       	out	0x3d, r24	; 61
   13946:	ed b7       	in	r30, 0x3d	; 61
   13948:	fe b7       	in	r31, 0x3e	; 62
   1394a:	31 96       	adiw	r30, 0x01	; 1
   1394c:	8e 01       	movw	r16, r28
   1394e:	0f 5f       	subi	r16, 0xFF	; 255
   13950:	1f 4f       	sbci	r17, 0xFF	; 255
   13952:	ad b7       	in	r26, 0x3d	; 61
   13954:	be b7       	in	r27, 0x3e	; 62
   13956:	12 96       	adiw	r26, 0x02	; 2
   13958:	1c 93       	st	X, r17
   1395a:	0e 93       	st	-X, r16
   1395c:	11 97       	sbiw	r26, 0x01	; 1
   1395e:	87 e7       	ldi	r24, 0x77	; 119
   13960:	91 e2       	ldi	r25, 0x21	; 33
   13962:	93 83       	std	Z+3, r25	; 0x03
   13964:	82 83       	std	Z+2, r24	; 0x02
   13966:	8b ef       	ldi	r24, 0xFB	; 251
   13968:	94 e0       	ldi	r25, 0x04	; 4
   1396a:	95 83       	std	Z+5, r25	; 0x05
   1396c:	84 83       	std	Z+4, r24	; 0x04
   1396e:	87 e0       	ldi	r24, 0x07	; 7
   13970:	9d e0       	ldi	r25, 0x0D	; 13
   13972:	97 83       	std	Z+7, r25	; 0x07
   13974:	86 83       	std	Z+6, r24	; 0x06
   13976:	8d ee       	ldi	r24, 0xED	; 237
   13978:	98 e0       	ldi	r25, 0x08	; 8
   1397a:	91 87       	std	Z+9, r25	; 0x09
   1397c:	80 87       	std	Z+8, r24	; 0x08
   1397e:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    _uart_print(1, 0,strSend);
   13982:	8d b7       	in	r24, 0x3d	; 61
   13984:	9e b7       	in	r25, 0x3e	; 62
   13986:	0a 96       	adiw	r24, 0x0a	; 10
   13988:	0f b6       	in	r0, 0x3f	; 63
   1398a:	f8 94       	cli
   1398c:	9e bf       	out	0x3e, r25	; 62
   1398e:	0f be       	out	0x3f, r0	; 63
   13990:	8d bf       	out	0x3d, r24	; 61
   13992:	81 e0       	ldi	r24, 0x01	; 1
   13994:	60 e0       	ldi	r22, 0x00	; 0
   13996:	a8 01       	movw	r20, r16
   13998:	0e 94 70 b2 	call	0x164e0	; 0x164e0 <_uart_print>
	sprintf_P(strSend,PSTR("%s56"),strServerIP);
   1399c:	00 d0       	rcall	.+0      	; 0x1399e <sendMessage56+0x9e>
   1399e:	00 d0       	rcall	.+0      	; 0x139a0 <sendMessage56+0xa0>
   139a0:	00 d0       	rcall	.+0      	; 0x139a2 <sendMessage56+0xa2>
   139a2:	ed b7       	in	r30, 0x3d	; 61
   139a4:	fe b7       	in	r31, 0x3e	; 62
   139a6:	31 96       	adiw	r30, 0x01	; 1
   139a8:	ad b7       	in	r26, 0x3d	; 61
   139aa:	be b7       	in	r27, 0x3e	; 62
   139ac:	12 96       	adiw	r26, 0x02	; 2
   139ae:	1c 93       	st	X, r17
   139b0:	0e 93       	st	-X, r16
   139b2:	11 97       	sbiw	r26, 0x01	; 1
   139b4:	82 e7       	ldi	r24, 0x72	; 114
   139b6:	91 e2       	ldi	r25, 0x21	; 33
   139b8:	93 83       	std	Z+3, r25	; 0x03
   139ba:	82 83       	std	Z+2, r24	; 0x02
   139bc:	8a e1       	ldi	r24, 0x1A	; 26
   139be:	99 e0       	ldi	r25, 0x09	; 9
   139c0:	95 83       	std	Z+5, r25	; 0x05
   139c2:	84 83       	std	Z+4, r24	; 0x04
   139c4:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    _uart_print(1, 0,strSend);
   139c8:	8d b7       	in	r24, 0x3d	; 61
   139ca:	9e b7       	in	r25, 0x3e	; 62
   139cc:	06 96       	adiw	r24, 0x06	; 6
   139ce:	0f b6       	in	r0, 0x3f	; 63
   139d0:	f8 94       	cli
   139d2:	9e bf       	out	0x3e, r25	; 62
   139d4:	0f be       	out	0x3f, r0	; 63
   139d6:	8d bf       	out	0x3d, r24	; 61
   139d8:	81 e0       	ldi	r24, 0x01	; 1
   139da:	60 e0       	ldi	r22, 0x00	; 0
   139dc:	a8 01       	movw	r20, r16
   139de:	0e 94 70 b2 	call	0x164e0	; 0x164e0 <_uart_print>
    sprintf_P(strSend,PSTR("%s"),strCardID);
   139e2:	00 d0       	rcall	.+0      	; 0x139e4 <sendMessage56+0xe4>
   139e4:	00 d0       	rcall	.+0      	; 0x139e6 <sendMessage56+0xe6>
   139e6:	00 d0       	rcall	.+0      	; 0x139e8 <sendMessage56+0xe8>
   139e8:	ed b7       	in	r30, 0x3d	; 61
   139ea:	fe b7       	in	r31, 0x3e	; 62
   139ec:	31 96       	adiw	r30, 0x01	; 1
   139ee:	ad b7       	in	r26, 0x3d	; 61
   139f0:	be b7       	in	r27, 0x3e	; 62
   139f2:	12 96       	adiw	r26, 0x02	; 2
   139f4:	1c 93       	st	X, r17
   139f6:	0e 93       	st	-X, r16
   139f8:	11 97       	sbiw	r26, 0x01	; 1
   139fa:	8f e6       	ldi	r24, 0x6F	; 111
   139fc:	91 e2       	ldi	r25, 0x21	; 33
   139fe:	93 83       	std	Z+3, r25	; 0x03
   13a00:	82 83       	std	Z+2, r24	; 0x02
   13a02:	8d eb       	ldi	r24, 0xBD	; 189
   13a04:	9c e0       	ldi	r25, 0x0C	; 12
   13a06:	95 83       	std	Z+5, r25	; 0x05
   13a08:	84 83       	std	Z+4, r24	; 0x04
   13a0a:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
    _uart_print(1, 0,strSend);	
   13a0e:	8d b7       	in	r24, 0x3d	; 61
   13a10:	9e b7       	in	r25, 0x3e	; 62
   13a12:	06 96       	adiw	r24, 0x06	; 6
   13a14:	0f b6       	in	r0, 0x3f	; 63
   13a16:	f8 94       	cli
   13a18:	9e bf       	out	0x3e, r25	; 62
   13a1a:	0f be       	out	0x3f, r0	; 63
   13a1c:	8d bf       	out	0x3d, r24	; 61
   13a1e:	81 e0       	ldi	r24, 0x01	; 1
   13a20:	60 e0       	ldi	r22, 0x00	; 0
   13a22:	a8 01       	movw	r20, r16
   13a24:	0e 94 70 b2 	call	0x164e0	; 0x164e0 <_uart_print>

	_uart_printf(1,0,PSTR("AF968CFFB"));
   13a28:	81 e0       	ldi	r24, 0x01	; 1
   13a2a:	60 e0       	ldi	r22, 0x00	; 0
   13a2c:	45 e6       	ldi	r20, 0x65	; 101
   13a2e:	51 e2       	ldi	r21, 0x21	; 33
   13a30:	0e 94 98 b2 	call	0x16530	; 0x16530 <_uart_printf>
	_uart(1, 1,0x02);
   13a34:	81 e0       	ldi	r24, 0x01	; 1
   13a36:	61 e0       	ldi	r22, 0x01	; 1
   13a38:	42 e0       	ldi	r20, 0x02	; 2
   13a3a:	0e 94 53 b2 	call	0x164a6	; 0x164a6 <_uart>
}
   13a3e:	ec 96       	adiw	r28, 0x3c	; 60
   13a40:	0f b6       	in	r0, 0x3f	; 63
   13a42:	f8 94       	cli
   13a44:	de bf       	out	0x3e, r29	; 62
   13a46:	0f be       	out	0x3f, r0	; 63
   13a48:	cd bf       	out	0x3d, r28	; 61
   13a4a:	cf 91       	pop	r28
   13a4c:	df 91       	pop	r29
   13a4e:	1f 91       	pop	r17
   13a50:	0f 91       	pop	r16
   13a52:	08 95       	ret

00013a54 <FMenuLocalAccount>:
	 __key_lgtcnt = 0; 
	 PORTG=PORTG&0b11111101;
}


char FMenuLocalAccount(){
   13a54:	6f 92       	push	r6
   13a56:	7f 92       	push	r7
   13a58:	8f 92       	push	r8
   13a5a:	9f 92       	push	r9
   13a5c:	af 92       	push	r10
   13a5e:	bf 92       	push	r11
   13a60:	cf 92       	push	r12
   13a62:	df 92       	push	r13
   13a64:	ef 92       	push	r14
   13a66:	ff 92       	push	r15
   13a68:	0f 93       	push	r16
   13a6a:	1f 93       	push	r17
   13a6c:	df 93       	push	r29
   13a6e:	cf 93       	push	r28
   13a70:	cd b7       	in	r28, 0x3d	; 61
   13a72:	de b7       	in	r29, 0x3e	; 62
   13a74:	e4 97       	sbiw	r28, 0x34	; 52
   13a76:	0f b6       	in	r0, 0x3f	; 63
   13a78:	f8 94       	cli
   13a7a:	de bf       	out	0x3e, r29	; 62
   13a7c:	0f be       	out	0x3f, r0	; 63
   13a7e:	cd bf       	out	0x3d, r28	; 61
       char ProductName[11],strName[21];//,strPumpL[3],strPumpR[3];
       char Result;

	   Result=MENU_NONE;
	                                 //|   Local Account   |          
	       switch(stLocalAccount){   //|ID: ACD12345       |
   13a80:	80 91 4b 01 	lds	r24, 0x014B
   13a84:	90 e0       	ldi	r25, 0x00	; 0
   13a86:	fc 01       	movw	r30, r24
   13a88:	31 97       	sbiw	r30, 0x01	; 1
   13a8a:	ef 31       	cpi	r30, 0x1F	; 31
   13a8c:	f1 05       	cpc	r31, r1
   13a8e:	10 f0       	brcs	.+4      	; 0x13a94 <FMenuLocalAccount+0x40>
   13a90:	0c 94 d6 a5 	jmp	0x14bac	; 0x14bac <FMenuLocalAccount+0x1158>
   13a94:	e2 50       	subi	r30, 0x02	; 2
   13a96:	ff 4f       	sbci	r31, 0xFF	; 255
   13a98:	ee 0f       	add	r30, r30
   13a9a:	ff 1f       	adc	r31, r31
   13a9c:	05 90       	lpm	r0, Z+
   13a9e:	f4 91       	lpm	r31, Z+
   13aa0:	e0 2d       	mov	r30, r0
   13aa2:	09 94       	ijmp
	      }
     }      
}

void BackLightTrig(){    
     __key_light = 1; 
   13aa4:	81 e0       	ldi	r24, 0x01	; 1
   13aa6:	80 93 02 03 	sts	0x0302, r24
	 __key_lgtcnt = 0; 
   13aaa:	10 92 03 03 	sts	0x0303, r1
	 PORTG=PORTG&0b11111101;
   13aae:	80 91 65 00 	lds	r24, 0x0065
   13ab2:	8d 7f       	andi	r24, 0xFD	; 253
   13ab4:	80 93 65 00 	sts	0x0065, r24
   13ab8:	20 e0       	ldi	r18, 0x00	; 0
   13aba:	30 e0       	ldi	r19, 0x00	; 0
}

void ViewCardID(){//+12345678 -->12345678
     char i;
	 for(i=0;i<8;i++){         //00000000000012345678
		strCardID[i]=strRFID[i];
   13abc:	f9 01       	movw	r30, r18
   13abe:	e3 54       	subi	r30, 0x43	; 67
   13ac0:	f3 4f       	sbci	r31, 0xF3	; 243
   13ac2:	d9 01       	movw	r26, r18
   13ac4:	a8 57       	subi	r26, 0x78	; 120
   13ac6:	b2 4f       	sbci	r27, 0xF2	; 242
   13ac8:	8c 91       	ld	r24, X
   13aca:	80 83       	st	Z, r24
   13acc:	2f 5f       	subi	r18, 0xFF	; 255
   13ace:	3f 4f       	sbci	r19, 0xFF	; 255

}

void ViewCardID(){//+12345678 -->12345678
     char i;
	 for(i=0;i<8;i++){         //00000000000012345678
   13ad0:	28 30       	cpi	r18, 0x08	; 8
   13ad2:	31 05       	cpc	r19, r1
   13ad4:	99 f7       	brne	.-26     	; 0x13abc <FMenuLocalAccount+0x68>
		strCardID[i]=strRFID[i];
	 }strCardID[8]=0;     
   13ad6:	10 92 c5 0c 	sts	0x0CC5, r1
	       switch(stLocalAccount){   //|ID: ACD12345       |
	       case laInit:              //|Process ...        |
		        //Process RFID Data  //|                   |
				//UpdateCardID();
                BackLightTrig();ViewCardID();
	            lcd_clear();
   13ada:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
	            lcd_printf(1,1,PSTR("   Local Account   "));
   13ade:	81 e0       	ldi	r24, 0x01	; 1
   13ae0:	61 e0       	ldi	r22, 0x01	; 1
   13ae2:	4f eb       	ldi	r20, 0xBF	; 191
   13ae4:	50 e2       	ldi	r21, 0x20	; 32
   13ae6:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
	            sprintf_P(lcdteks,PSTR("ID:%s"),strCardID);lcd_print(2,1,lcdteks);
   13aea:	00 d0       	rcall	.+0      	; 0x13aec <FMenuLocalAccount+0x98>
   13aec:	00 d0       	rcall	.+0      	; 0x13aee <FMenuLocalAccount+0x9a>
   13aee:	00 d0       	rcall	.+0      	; 0x13af0 <FMenuLocalAccount+0x9c>
   13af0:	ed b7       	in	r30, 0x3d	; 61
   13af2:	fe b7       	in	r31, 0x3e	; 62
   13af4:	31 96       	adiw	r30, 0x01	; 1
   13af6:	8e 01       	movw	r16, r28
   13af8:	04 5f       	subi	r16, 0xF4	; 244
   13afa:	1f 4f       	sbci	r17, 0xFF	; 255
   13afc:	ad b7       	in	r26, 0x3d	; 61
   13afe:	be b7       	in	r27, 0x3e	; 62
   13b00:	12 96       	adiw	r26, 0x02	; 2
   13b02:	1c 93       	st	X, r17
   13b04:	0e 93       	st	-X, r16
   13b06:	11 97       	sbiw	r26, 0x01	; 1
   13b08:	89 eb       	ldi	r24, 0xB9	; 185
   13b0a:	90 e2       	ldi	r25, 0x20	; 32
   13b0c:	93 83       	std	Z+3, r25	; 0x03
   13b0e:	82 83       	std	Z+2, r24	; 0x02
   13b10:	8d eb       	ldi	r24, 0xBD	; 189
   13b12:	9c e0       	ldi	r25, 0x0C	; 12
   13b14:	95 83       	std	Z+5, r25	; 0x05
   13b16:	84 83       	std	Z+4, r24	; 0x04
   13b18:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
   13b1c:	ed b7       	in	r30, 0x3d	; 61
   13b1e:	fe b7       	in	r31, 0x3e	; 62
   13b20:	36 96       	adiw	r30, 0x06	; 6
   13b22:	0f b6       	in	r0, 0x3f	; 63
   13b24:	f8 94       	cli
   13b26:	fe bf       	out	0x3e, r31	; 62
   13b28:	0f be       	out	0x3f, r0	; 63
   13b2a:	ed bf       	out	0x3d, r30	; 61
   13b2c:	82 e0       	ldi	r24, 0x02	; 2
   13b2e:	61 e0       	ldi	r22, 0x01	; 1
   13b30:	a8 01       	movw	r20, r16
   13b32:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
                lcd_printf(3,1,PSTR("Proses"));
   13b36:	83 e0       	ldi	r24, 0x03	; 3
   13b38:	61 e0       	ldi	r22, 0x01	; 1
   13b3a:	42 eb       	ldi	r20, 0xB2	; 178
   13b3c:	50 e2       	ldi	r21, 0x20	; 32
   13b3e:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
				iPos=0;//iLoop=0;
   13b42:	10 92 e9 02 	sts	0x02E9, r1
				IsFullAuthorized=False;
   13b46:	10 92 d9 02 	sts	0x02D9, r1
		        stLocalAccount=laSendID;
   13b4a:	82 e0       	ldi	r24, 0x02	; 2
   13b4c:	0b c0       	rjmp	.+22     	; 0x13b64 <FMenuLocalAccount+0x110>
				break;         
           case laSendID://sendMessage56 
				IsMessage57=False;
   13b4e:	10 92 a8 01 	sts	0x01A8, r1
                sendMessage56();
   13b52:	0e 94 80 9c 	call	0x13900	; 0x13900 <sendMessage56>
				iWait=0;iPos=0;
   13b56:	10 92 e8 02 	sts	0x02E8, r1
   13b5a:	10 92 e9 02 	sts	0x02E9, r1
				//iLoop=0;
				TimSend=0;
   13b5e:	10 92 af 0d 	sts	0x0DAF, r1
				stLocalAccount=laWaitMessage57;
   13b62:	83 e0       	ldi	r24, 0x03	; 3
   13b64:	80 93 4b 01 	sts	0x014B, r24
   13b68:	0c 94 d6 a5 	jmp	0x14bac	; 0x14bac <FMenuLocalAccount+0x1158>
						 system_beep(2);
						 stLocalAccount=laConTimout;
				}
				*/
				
		        iLoop++;
   13b6c:	80 91 d7 02 	lds	r24, 0x02D7
   13b70:	90 91 d8 02 	lds	r25, 0x02D8
   13b74:	01 96       	adiw	r24, 0x01	; 1
   13b76:	90 93 d8 02 	sts	0x02D8, r25
   13b7a:	80 93 d7 02 	sts	0x02D7, r24
				if ((iLoop%MSG_WAIT_TIMOUT)==0){
   13b7e:	68 e9       	ldi	r22, 0x98	; 152
   13b80:	7a e3       	ldi	r23, 0x3A	; 58
   13b82:	0e 94 0a b7 	call	0x16e14	; 0x16e14 <__udivmodhi4>
   13b86:	89 2b       	or	r24, r25
   13b88:	e1 f4       	brne	.+56     	; 0x13bc2 <FMenuLocalAccount+0x16e>
				   if (iPos<5){
   13b8a:	60 91 e9 02 	lds	r22, 0x02E9
   13b8e:	65 30       	cpi	r22, 0x05	; 5
   13b90:	58 f4       	brcc	.+22     	; 0x13ba8 <FMenuLocalAccount+0x154>
					   lcd_put(3,(8+iPos),'.');
   13b92:	68 5f       	subi	r22, 0xF8	; 248
   13b94:	83 e0       	ldi	r24, 0x03	; 3
   13b96:	4e e2       	ldi	r20, 0x2E	; 46
   13b98:	0e 94 58 ad 	call	0x15ab0	; 0x15ab0 <lcd_put>
				       iPos++;
   13b9c:	80 91 e9 02 	lds	r24, 0x02E9
   13ba0:	8f 5f       	subi	r24, 0xFF	; 255
   13ba2:	80 93 e9 02 	sts	0x02E9, r24
   13ba6:	0d c0       	rjmp	.+26     	; 0x13bc2 <FMenuLocalAccount+0x16e>
					   }
				   else{
				       iPos=0;
   13ba8:	10 92 e9 02 	sts	0x02E9, r1
					   lcd_printf(3,(9+iPos),PSTR("       "));
   13bac:	83 e0       	ldi	r24, 0x03	; 3
   13bae:	69 e0       	ldi	r22, 0x09	; 9
   13bb0:	4a ea       	ldi	r20, 0xAA	; 170
   13bb2:	50 e2       	ldi	r21, 0x20	; 32
   13bb4:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
					   iWait++;
   13bb8:	80 91 e8 02 	lds	r24, 0x02E8
   13bbc:	8f 5f       	subi	r24, 0xFF	; 255
   13bbe:	80 93 e8 02 	sts	0x02E8, r24
					   }
				}
				if (iWait>3){
   13bc2:	80 91 e8 02 	lds	r24, 0x02E8
   13bc6:	84 30       	cpi	r24, 0x04	; 4
   13bc8:	50 f0       	brcs	.+20     	; 0x13bde <FMenuLocalAccount+0x18a>
				    stLocalAccount=laConTimout;
   13bca:	84 e0       	ldi	r24, 0x04	; 4
   13bcc:	80 93 4b 01 	sts	0x014B, r24
					TimLocAcc=0;
   13bd0:	10 92 bd 01 	sts	0x01BD, r1
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   13bd4:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   13bd6:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   13bd8:	82 e0       	ldi	r24, 0x02	; 2
   13bda:	80 93 bf 01 	sts	0x01BF, r24
				    stLocalAccount=laConTimout;
					TimLocAcc=0;
					system_beep(2);
				    }
                 
				if (IsMessage57==True){
   13bde:	80 91 a8 01 	lds	r24, 0x01A8
   13be2:	81 30       	cpi	r24, 0x01	; 1
   13be4:	09 f0       	breq	.+2      	; 0x13be8 <FMenuLocalAccount+0x194>
   13be6:	e2 c7       	rjmp	.+4036   	; 0x14bac <FMenuLocalAccount+0x1158>
				    IsMessage57=False;
   13be8:	10 92 a8 01 	sts	0x01A8, r1
				    stLocalAccount=laProcMessage57;
   13bec:	85 e0       	ldi	r24, 0x05	; 5
   13bee:	ba cf       	rjmp	.-140    	; 0x13b64 <FMenuLocalAccount+0x110>
					}
		        break;
           case laConTimout:
		        //IsErrorTCPIP=True;
				lcd_printf(3,1,PSTR("Sending Failed      "));
   13bf0:	83 e0       	ldi	r24, 0x03	; 3
   13bf2:	61 e0       	ldi	r22, 0x01	; 1
   13bf4:	45 e9       	ldi	r20, 0x95	; 149
   13bf6:	50 e2       	ldi	r21, 0x20	; 32
   13bf8:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
				lcd_printf(4,1,PSTR("TCP/IP Error        "));
   13bfc:	84 e0       	ldi	r24, 0x04	; 4
   13bfe:	61 e0       	ldi	r22, 0x01	; 1
   13c00:	40 e8       	ldi	r20, 0x80	; 128
   13c02:	50 e2       	ldi	r21, 0x20	; 32
   13c04:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
                if (TimLocAcc>2)  stLocalAccount=laExitLocAcc;
   13c08:	80 91 bd 01 	lds	r24, 0x01BD
   13c0c:	83 30       	cpi	r24, 0x03	; 3
   13c0e:	08 f4       	brcc	.+2      	; 0x13c12 <FMenuLocalAccount+0x1be>
   13c10:	cd c7       	rjmp	.+3994   	; 0x14bac <FMenuLocalAccount+0x1158>
   13c12:	c2 c7       	rjmp	.+3972   	; 0x14b98 <FMenuLocalAccount+0x1144>
		        break;
           case laProcMessage57://Process Message
				lcd_printf(3,1,PSTR("Data Received       "));
   13c14:	83 e0       	ldi	r24, 0x03	; 3
   13c16:	61 e0       	ldi	r22, 0x01	; 1
   13c18:	4b e6       	ldi	r20, 0x6B	; 107
   13c1a:	50 e2       	ldi	r21, 0x20	; 32
   13c1c:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
				LocAccStatus=GetLocAccStatus(procMessage57());
   13c20:	0e 94 f6 25 	call	0x4bec	; 0x4bec <procMessage57>


char GetLocAccStatus(char paramMessage57){
     char Result;
	 Result=LA_NONE;
     if (paramMessage57==MSG57_INVALID)Result=LA_INVALID;
   13c24:	81 30       	cpi	r24, 0x01	; 1
   13c26:	29 f0       	breq	.+10     	; 0x13c32 <FMenuLocalAccount+0x1de>
	 else
     if (paramMessage57==MSG57_VALID)Result=LA_VALID;
   13c28:	82 30       	cpi	r24, 0x02	; 2
   13c2a:	19 f0       	breq	.+6      	; 0x13c32 <FMenuLocalAccount+0x1de>
	 else
     if (paramMessage57==MSG57_LIMITED)Result=LA_LIMITED;
   13c2c:	83 30       	cpi	r24, 0x03	; 3
   13c2e:	09 f0       	breq	.+2      	; 0x13c32 <FMenuLocalAccount+0x1de>
   13c30:	80 e0       	ldi	r24, 0x00	; 0
				lcd_printf(4,1,PSTR("TCP/IP Error        "));
                if (TimLocAcc>2)  stLocalAccount=laExitLocAcc;
		        break;
           case laProcMessage57://Process Message
				lcd_printf(3,1,PSTR("Data Received       "));
				LocAccStatus=GetLocAccStatus(procMessage57());
   13c32:	80 93 ea 02 	sts	0x02EA, r24
				TimLocAcc=0;
   13c36:	10 92 bd 01 	sts	0x01BD, r1
				stLocalAccount=laDispStatus;
   13c3a:	86 e0       	ldi	r24, 0x06	; 6
   13c3c:	93 cf       	rjmp	.-218    	; 0x13b64 <FMenuLocalAccount+0x110>
		        break;
           case laDispStatus://Display Status
		        if (LocAccStatus==LA_INVALID){
   13c3e:	80 91 ea 02 	lds	r24, 0x02EA
   13c42:	81 30       	cpi	r24, 0x01	; 1
   13c44:	29 f4       	brne	.+10     	; 0x13c50 <FMenuLocalAccount+0x1fc>
					lcd_printf(3,1,PSTR("Tidak Terdaftar     "));    
   13c46:	83 e0       	ldi	r24, 0x03	; 3
   13c48:	61 e0       	ldi	r22, 0x01	; 1
   13c4a:	46 e5       	ldi	r20, 0x56	; 86
   13c4c:	50 e2       	ldi	r21, 0x20	; 32
   13c4e:	0d c0       	rjmp	.+26     	; 0x13c6a <FMenuLocalAccount+0x216>
					TimLocAcc=0;
				    stLocalAccount=laDelayExit;
				}
				else
                if (LocAccStatus==LA_VALID) {
   13c50:	82 30       	cpi	r24, 0x02	; 2
   13c52:	31 f4       	brne	.+12     	; 0x13c60 <FMenuLocalAccount+0x20c>
				    stLocalAccount=laDispValid; 
   13c54:	87 e0       	ldi	r24, 0x07	; 7
   13c56:	80 93 4b 01 	sts	0x014B, r24
					lcd_clear();
   13c5a:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
   13c5e:	0c c0       	rjmp	.+24     	; 0x13c78 <FMenuLocalAccount+0x224>
					}
				else
                if (LocAccStatus==LA_LIMITED){
   13c60:	83 30       	cpi	r24, 0x03	; 3
   13c62:	51 f4       	brne	.+20     	; 0x13c78 <FMenuLocalAccount+0x224>
					lcd_printf(3,1,PSTR("Kartu Terbatas      "));    
   13c64:	61 e0       	ldi	r22, 0x01	; 1
   13c66:	41 e4       	ldi	r20, 0x41	; 65
   13c68:	50 e2       	ldi	r21, 0x20	; 32
   13c6a:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
					TimLocAcc=0;
   13c6e:	10 92 bd 01 	sts	0x01BD, r1
				    stLocalAccount=laDelayExit;
   13c72:	8e e1       	ldi	r24, 0x1E	; 30
   13c74:	80 93 4b 01 	sts	0x014B, r24
				}
                if (TimLocAcc>5)stLocalAccount=laExitLocAcc;
   13c78:	80 91 bd 01 	lds	r24, 0x01BD
   13c7c:	86 30       	cpi	r24, 0x06	; 6
   13c7e:	08 f4       	brcc	.+2      	; 0x13c82 <FMenuLocalAccount+0x22e>
   13c80:	95 c7       	rjmp	.+3882   	; 0x14bac <FMenuLocalAccount+0x1158>
   13c82:	8a c7       	rjmp	.+3860   	; 0x14b98 <FMenuLocalAccount+0x1144>
		        break;
           case laDispValid://Display VALID ID
		        lcd_clear();
   13c84:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
				sprintf_P(strBalanceValue,PSTR("%s"),strBalance);
   13c88:	00 d0       	rcall	.+0      	; 0x13c8a <FMenuLocalAccount+0x236>
   13c8a:	00 d0       	rcall	.+0      	; 0x13c8c <FMenuLocalAccount+0x238>
   13c8c:	00 d0       	rcall	.+0      	; 0x13c8e <FMenuLocalAccount+0x23a>
   13c8e:	ed b7       	in	r30, 0x3d	; 61
   13c90:	fe b7       	in	r31, 0x3e	; 62
   13c92:	31 96       	adiw	r30, 0x01	; 1
   13c94:	86 e5       	ldi	r24, 0x56	; 86
   13c96:	9d e0       	ldi	r25, 0x0D	; 13
   13c98:	ad b7       	in	r26, 0x3d	; 61
   13c9a:	be b7       	in	r27, 0x3e	; 62
   13c9c:	12 96       	adiw	r26, 0x02	; 2
   13c9e:	9c 93       	st	X, r25
   13ca0:	8e 93       	st	-X, r24
   13ca2:	11 97       	sbiw	r26, 0x01	; 1
   13ca4:	8e e3       	ldi	r24, 0x3E	; 62
   13ca6:	90 e2       	ldi	r25, 0x20	; 32
   13ca8:	93 83       	std	Z+3, r25	; 0x03
   13caa:	82 83       	std	Z+2, r24	; 0x02
   13cac:	0f e2       	ldi	r16, 0x2F	; 47
   13cae:	1d e0       	ldi	r17, 0x0D	; 13
   13cb0:	15 83       	std	Z+5, r17	; 0x05
   13cb2:	04 83       	std	Z+4, r16	; 0x04
   13cb4:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
				FormatCurrency(strBalance);
   13cb8:	ed b7       	in	r30, 0x3d	; 61
   13cba:	fe b7       	in	r31, 0x3e	; 62
   13cbc:	36 96       	adiw	r30, 0x06	; 6
   13cbe:	0f b6       	in	r0, 0x3f	; 63
   13cc0:	f8 94       	cli
   13cc2:	fe bf       	out	0x3e, r31	; 62
   13cc4:	0f be       	out	0x3f, r0	; 63
   13cc6:	ed bf       	out	0x3d, r30	; 61
   13cc8:	c8 01       	movw	r24, r16
   13cca:	0e 94 09 33 	call	0x6612	; 0x6612 <FormatCurrency>
   13cce:	20 e0       	ldi	r18, 0x00	; 0
   13cd0:	30 e0       	ldi	r19, 0x00	; 0


void StringCopy(char *Source,char *Dest,char Length){
     char i;
	 for (i=0;i<Length;i++){
	     Dest[i]=Source[i];
   13cd2:	80 e2       	ldi	r24, 0x20	; 32
   13cd4:	e8 2e       	mov	r14, r24
   13cd6:	f1 2c       	mov	r15, r1
   13cd8:	ec 0e       	add	r14, r28
   13cda:	fd 1e       	adc	r15, r29
   13cdc:	f7 01       	movw	r30, r14
   13cde:	e2 0f       	add	r30, r18
   13ce0:	f3 1f       	adc	r31, r19
   13ce2:	d9 01       	movw	r26, r18
   13ce4:	ad 5c       	subi	r26, 0xCD	; 205
   13ce6:	bb 4f       	sbci	r27, 0xFB	; 251
   13ce8:	8c 91       	ld	r24, X
   13cea:	80 83       	st	Z, r24
   13cec:	2f 5f       	subi	r18, 0xFF	; 255
   13cee:	3f 4f       	sbci	r19, 0xFF	; 255
//Message 56


void StringCopy(char *Source,char *Dest,char Length){
     char i;
	 for (i=0;i<Length;i++){
   13cf0:	24 31       	cpi	r18, 0x14	; 20
   13cf2:	31 05       	cpc	r19, r1
   13cf4:	99 f7       	brne	.-26     	; 0x13cdc <FMenuLocalAccount+0x288>
	     Dest[i]=Source[i];
	 }Dest[Length]=0;
   13cf6:	1c aa       	std	Y+52, r1	; 0x34
		        lcd_clear();
				sprintf_P(strBalanceValue,PSTR("%s"),strBalance);
				FormatCurrency(strBalance);

		        StringCopy(strCardHolder,strName,20);  				                                                        
		        sprintf_P(lcdteks,PSTR("%s"),strCompName);               lcd_print(1,1,lcdteks);   //[CompName]
   13cf8:	00 d0       	rcall	.+0      	; 0x13cfa <FMenuLocalAccount+0x2a6>
   13cfa:	00 d0       	rcall	.+0      	; 0x13cfc <FMenuLocalAccount+0x2a8>
   13cfc:	00 d0       	rcall	.+0      	; 0x13cfe <FMenuLocalAccount+0x2aa>
   13cfe:	ed b7       	in	r30, 0x3d	; 61
   13d00:	fe b7       	in	r31, 0x3e	; 62
   13d02:	31 96       	adiw	r30, 0x01	; 1
   13d04:	8e 01       	movw	r16, r28
   13d06:	04 5f       	subi	r16, 0xF4	; 244
   13d08:	1f 4f       	sbci	r17, 0xFF	; 255
   13d0a:	ad b7       	in	r26, 0x3d	; 61
   13d0c:	be b7       	in	r27, 0x3e	; 62
   13d0e:	12 96       	adiw	r26, 0x02	; 2
   13d10:	1c 93       	st	X, r17
   13d12:	0e 93       	st	-X, r16
   13d14:	11 97       	sbiw	r26, 0x01	; 1
   13d16:	8b e3       	ldi	r24, 0x3B	; 59
   13d18:	90 e2       	ldi	r25, 0x20	; 32
   13d1a:	93 83       	std	Z+3, r25	; 0x03
   13d1c:	82 83       	std	Z+2, r24	; 0x02
   13d1e:	8b e8       	ldi	r24, 0x8B	; 139
   13d20:	98 e0       	ldi	r25, 0x08	; 8
   13d22:	95 83       	std	Z+5, r25	; 0x05
   13d24:	84 83       	std	Z+4, r24	; 0x04
   13d26:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
   13d2a:	ed b7       	in	r30, 0x3d	; 61
   13d2c:	fe b7       	in	r31, 0x3e	; 62
   13d2e:	36 96       	adiw	r30, 0x06	; 6
   13d30:	0f b6       	in	r0, 0x3f	; 63
   13d32:	f8 94       	cli
   13d34:	fe bf       	out	0x3e, r31	; 62
   13d36:	0f be       	out	0x3f, r0	; 63
   13d38:	ed bf       	out	0x3d, r30	; 61
   13d3a:	81 e0       	ldi	r24, 0x01	; 1
   13d3c:	61 e0       	ldi	r22, 0x01	; 1
   13d3e:	a8 01       	movw	r20, r16
   13d40:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
                //sprintf(lcdteks,"%s %s",strCardID,strName);    lcd_print(2,1,lcdteks);   //[Card ID][Card Holder]
				sprintf_P(lcdteks,PSTR("%s"),strName);                   lcd_print(2,1,lcdteks);   //[Card ID][Card Holder]
   13d44:	00 d0       	rcall	.+0      	; 0x13d46 <FMenuLocalAccount+0x2f2>
   13d46:	00 d0       	rcall	.+0      	; 0x13d48 <FMenuLocalAccount+0x2f4>
   13d48:	00 d0       	rcall	.+0      	; 0x13d4a <FMenuLocalAccount+0x2f6>
   13d4a:	ed b7       	in	r30, 0x3d	; 61
   13d4c:	fe b7       	in	r31, 0x3e	; 62
   13d4e:	31 96       	adiw	r30, 0x01	; 1
   13d50:	ad b7       	in	r26, 0x3d	; 61
   13d52:	be b7       	in	r27, 0x3e	; 62
   13d54:	12 96       	adiw	r26, 0x02	; 2
   13d56:	1c 93       	st	X, r17
   13d58:	0e 93       	st	-X, r16
   13d5a:	11 97       	sbiw	r26, 0x01	; 1
   13d5c:	88 e3       	ldi	r24, 0x38	; 56
   13d5e:	90 e2       	ldi	r25, 0x20	; 32
   13d60:	93 83       	std	Z+3, r25	; 0x03
   13d62:	82 83       	std	Z+2, r24	; 0x02
   13d64:	f5 82       	std	Z+5, r15	; 0x05
   13d66:	e4 82       	std	Z+4, r14	; 0x04
   13d68:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
   13d6c:	ed b7       	in	r30, 0x3d	; 61
   13d6e:	fe b7       	in	r31, 0x3e	; 62
   13d70:	36 96       	adiw	r30, 0x06	; 6
   13d72:	0f b6       	in	r0, 0x3f	; 63
   13d74:	f8 94       	cli
   13d76:	fe bf       	out	0x3e, r31	; 62
   13d78:	0f be       	out	0x3f, r0	; 63
   13d7a:	ed bf       	out	0x3d, r30	; 61
   13d7c:	82 e0       	ldi	r24, 0x02	; 2
   13d7e:	61 e0       	ldi	r22, 0x01	; 1
   13d80:	a8 01       	movw	r20, r16
   13d82:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
				sprintf_P(lcdteks,PSTR("%s %s"),strLicPlate,strBalance); lcd_print(3,1,lcdteks);   //[LicPlate][Balance] 
   13d86:	2d b7       	in	r18, 0x3d	; 61
   13d88:	3e b7       	in	r19, 0x3e	; 62
   13d8a:	28 50       	subi	r18, 0x08	; 8
   13d8c:	30 40       	sbci	r19, 0x00	; 0
   13d8e:	0f b6       	in	r0, 0x3f	; 63
   13d90:	f8 94       	cli
   13d92:	3e bf       	out	0x3e, r19	; 62
   13d94:	0f be       	out	0x3f, r0	; 63
   13d96:	2d bf       	out	0x3d, r18	; 61
   13d98:	ed b7       	in	r30, 0x3d	; 61
   13d9a:	fe b7       	in	r31, 0x3e	; 62
   13d9c:	31 96       	adiw	r30, 0x01	; 1
   13d9e:	ad b7       	in	r26, 0x3d	; 61
   13da0:	be b7       	in	r27, 0x3e	; 62
   13da2:	12 96       	adiw	r26, 0x02	; 2
   13da4:	1c 93       	st	X, r17
   13da6:	0e 93       	st	-X, r16
   13da8:	11 97       	sbiw	r26, 0x01	; 1
   13daa:	82 e3       	ldi	r24, 0x32	; 50
   13dac:	90 e2       	ldi	r25, 0x20	; 32
   13dae:	93 83       	std	Z+3, r25	; 0x03
   13db0:	82 83       	std	Z+2, r24	; 0x02
   13db2:	8e e2       	ldi	r24, 0x2E	; 46
   13db4:	9a e0       	ldi	r25, 0x0A	; 10
   13db6:	95 83       	std	Z+5, r25	; 0x05
   13db8:	84 83       	std	Z+4, r24	; 0x04
   13dba:	8f e2       	ldi	r24, 0x2F	; 47
   13dbc:	9d e0       	ldi	r25, 0x0D	; 13
   13dbe:	97 83       	std	Z+7, r25	; 0x07
   13dc0:	86 83       	std	Z+6, r24	; 0x06
   13dc2:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
   13dc6:	ed b7       	in	r30, 0x3d	; 61
   13dc8:	fe b7       	in	r31, 0x3e	; 62
   13dca:	38 96       	adiw	r30, 0x08	; 8
   13dcc:	0f b6       	in	r0, 0x3f	; 63
   13dce:	f8 94       	cli
   13dd0:	fe bf       	out	0x3e, r31	; 62
   13dd2:	0f be       	out	0x3f, r0	; 63
   13dd4:	ed bf       	out	0x3d, r30	; 61
   13dd6:	83 e0       	ldi	r24, 0x03	; 3
   13dd8:	61 e0       	ldi	r22, 0x01	; 1
   13dda:	a8 01       	movw	r20, r16
   13ddc:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
	            lcd_printf(4,1,PSTR("[*]Batal       [#]OK"));   //[*]Batal       [#]OK
   13de0:	84 e0       	ldi	r24, 0x04	; 4
   13de2:	61 e0       	ldi	r22, 0x01	; 1
   13de4:	4d e1       	ldi	r20, 0x1D	; 29
   13de6:	50 e2       	ldi	r21, 0x20	; 32
   13de8:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
				stLocalAccount=laDispValidInput;
   13dec:	88 e0       	ldi	r24, 0x08	; 8
   13dee:	ba ce       	rjmp	.-652    	; 0x13b64 <FMenuLocalAccount+0x110>
		        break;
           case laDispValidInput:
                KeyPressed=_key_scan(1);
   13df0:	81 e0       	ldi	r24, 0x01	; 1
   13df2:	0e 94 84 ae 	call	0x15d08	; 0x15d08 <_key_scan>
				if (KeyPressed==_KEY_ENTER) stLocalAccount=laSelectFIP;
   13df6:	87 3b       	cpi	r24, 0xB7	; 183
   13df8:	09 f4       	brne	.+2      	; 0x13dfc <FMenuLocalAccount+0x3a8>
   13dfa:	bd c1       	rjmp	.+890    	; 0x14176 <FMenuLocalAccount+0x722>
				else
				if (KeyPressed==_KEY_CANCEL)stLocalAccount=laExitLocAcc;
   13dfc:	87 3e       	cpi	r24, 0xE7	; 231
   13dfe:	09 f0       	breq	.+2      	; 0x13e02 <FMenuLocalAccount+0x3ae>
   13e00:	d5 c6       	rjmp	.+3498   	; 0x14bac <FMenuLocalAccount+0x1158>
   13e02:	ca c6       	rjmp	.+3476   	; 0x14b98 <FMenuLocalAccount+0x1144>
		        break;
           case laSelectFIP:      
			    FIPResult=menu_FIP(&FIP_Used,strFIP);
   13e04:	04 ee       	ldi	r16, 0xE4	; 228
   13e06:	12 e0       	ldi	r17, 0x02	; 2
   13e08:	8b ed       	ldi	r24, 0xDB	; 219
   13e0a:	92 e0       	ldi	r25, 0x02	; 2
   13e0c:	b8 01       	movw	r22, r16
   13e0e:	0e 94 b5 65 	call	0xcb6a	; 0xcb6a <menu_FIP>

			    if ((FIPResult==FIP_DONE)&&(FIP_Used>0)){
   13e12:	88 23       	and	r24, r24
   13e14:	09 f0       	breq	.+2      	; 0x13e18 <FMenuLocalAccount+0x3c4>
   13e16:	50 c0       	rjmp	.+160    	; 0x13eb8 <FMenuLocalAccount+0x464>
   13e18:	20 91 db 02 	lds	r18, 0x02DB
   13e1c:	22 23       	and	r18, r18
   13e1e:	09 f4       	brne	.+2      	; 0x13e22 <FMenuLocalAccount+0x3ce>
   13e20:	c5 c6       	rjmp	.+3466   	; 0x14bac <FMenuLocalAccount+0x1158>
                    sprintf_P(strFIP,PSTR("%.2d"),FIP_Used);
   13e22:	00 d0       	rcall	.+0      	; 0x13e24 <FMenuLocalAccount+0x3d0>
   13e24:	00 d0       	rcall	.+0      	; 0x13e26 <FMenuLocalAccount+0x3d2>
   13e26:	00 d0       	rcall	.+0      	; 0x13e28 <FMenuLocalAccount+0x3d4>
   13e28:	ed b7       	in	r30, 0x3d	; 61
   13e2a:	fe b7       	in	r31, 0x3e	; 62
   13e2c:	31 96       	adiw	r30, 0x01	; 1
   13e2e:	ad b7       	in	r26, 0x3d	; 61
   13e30:	be b7       	in	r27, 0x3e	; 62
   13e32:	12 96       	adiw	r26, 0x02	; 2
   13e34:	1c 93       	st	X, r17
   13e36:	0e 93       	st	-X, r16
   13e38:	11 97       	sbiw	r26, 0x01	; 1
   13e3a:	88 e1       	ldi	r24, 0x18	; 24
   13e3c:	90 e2       	ldi	r25, 0x20	; 32
   13e3e:	93 83       	std	Z+3, r25	; 0x03
   13e40:	82 83       	std	Z+2, r24	; 0x02
   13e42:	24 83       	std	Z+4, r18	; 0x04
   13e44:	15 82       	std	Z+5, r1	; 0x05
   13e46:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
					sprintf_P(strFIP_ID,PSTR("%.2d"),FIP_Used);
   13e4a:	ed b7       	in	r30, 0x3d	; 61
   13e4c:	fe b7       	in	r31, 0x3e	; 62
   13e4e:	31 96       	adiw	r30, 0x01	; 1
   13e50:	8b ec       	ldi	r24, 0xCB	; 203
   13e52:	98 e0       	ldi	r25, 0x08	; 8
   13e54:	ad b7       	in	r26, 0x3d	; 61
   13e56:	be b7       	in	r27, 0x3e	; 62
   13e58:	12 96       	adiw	r26, 0x02	; 2
   13e5a:	9c 93       	st	X, r25
   13e5c:	8e 93       	st	-X, r24
   13e5e:	11 97       	sbiw	r26, 0x01	; 1
   13e60:	83 e1       	ldi	r24, 0x13	; 19
   13e62:	90 e2       	ldi	r25, 0x20	; 32
   13e64:	93 83       	std	Z+3, r25	; 0x03
   13e66:	82 83       	std	Z+2, r24	; 0x02
   13e68:	80 91 db 02 	lds	r24, 0x02DB
   13e6c:	84 83       	std	Z+4, r24	; 0x04
   13e6e:	15 82       	std	Z+5, r1	; 0x05
   13e70:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
                    //Load Product Info
					if (GetFIPAddr(FIP_Used)>0) 
   13e74:	ed b7       	in	r30, 0x3d	; 61
   13e76:	fe b7       	in	r31, 0x3e	; 62
   13e78:	36 96       	adiw	r30, 0x06	; 6
   13e7a:	0f b6       	in	r0, 0x3f	; 63
   13e7c:	f8 94       	cli
   13e7e:	fe bf       	out	0x3e, r31	; 62
   13e80:	0f be       	out	0x3f, r0	; 63
   13e82:	ed bf       	out	0x3d, r30	; 61
   13e84:	80 91 db 02 	lds	r24, 0x02DB
   13e88:	0e 94 41 1d 	call	0x3a82	; 0x3a82 <GetFIPAddr>
   13e8c:	88 23       	and	r24, r24
   13e8e:	91 f0       	breq	.+36     	; 0x13eb4 <FMenuLocalAccount+0x460>
					    eeprom_read_block((void*) &ProductID, (const void*) &DefNozzleMap[GetFIPAddr(FIP_Used)-1], 6);
   13e90:	80 91 db 02 	lds	r24, 0x02DB
   13e94:	0e 94 41 1d 	call	0x3a82	; 0x3a82 <GetFIPAddr>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
   13e98:	96 e0       	ldi	r25, 0x06	; 6
   13e9a:	89 9f       	mul	r24, r25
   13e9c:	b0 01       	movw	r22, r0
   13e9e:	11 24       	eor	r1, r1
   13ea0:	61 5b       	subi	r22, 0xB1	; 177
   13ea2:	7f 4f       	sbci	r23, 0xFF	; 255
   13ea4:	8c ed       	ldi	r24, 0xDC	; 220
   13ea6:	92 e0       	ldi	r25, 0x02	; 2
   13ea8:	46 e0       	ldi	r20, 0x06	; 6
   13eaa:	50 e0       	ldi	r21, 0x00	; 0
   13eac:	2d ef       	ldi	r18, 0xFD	; 253
   13eae:	32 e1       	ldi	r19, 0x12	; 18
   13eb0:	0e 94 f1 b3 	call	0x167e2	; 0x167e2 <__eerd_block>
				    stLocalAccount=laSelectProduct;
   13eb4:	8b e0       	ldi	r24, 0x0B	; 11
   13eb6:	56 ce       	rjmp	.-852    	; 0x13b64 <FMenuLocalAccount+0x110>
				}
			    else if (FIPResult==FIP_CANCEL){
   13eb8:	82 30       	cpi	r24, 0x02	; 2
   13eba:	09 f0       	breq	.+2      	; 0x13ebe <FMenuLocalAccount+0x46a>
   13ebc:	77 c6       	rjmp	.+3310   	; 0x14bac <FMenuLocalAccount+0x1158>
				    stLocalAccount=laDispValid;
   13ebe:	87 e0       	ldi	r24, 0x07	; 7
   13ec0:	51 ce       	rjmp	.-862    	; 0x13b64 <FMenuLocalAccount+0x110>
		        break; 
           case laSelectFIPInput:

		        break;
           case laSelectProduct://NozzleID
				lcd_clear();
   13ec2:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
		        sprintf_P(lcdteks,PSTR("Pompa-%s"),strFIP);lcd_print(1,1,lcdteks);
   13ec6:	00 d0       	rcall	.+0      	; 0x13ec8 <FMenuLocalAccount+0x474>
   13ec8:	00 d0       	rcall	.+0      	; 0x13eca <FMenuLocalAccount+0x476>
   13eca:	00 d0       	rcall	.+0      	; 0x13ecc <FMenuLocalAccount+0x478>
   13ecc:	ed b7       	in	r30, 0x3d	; 61
   13ece:	fe b7       	in	r31, 0x3e	; 62
   13ed0:	31 96       	adiw	r30, 0x01	; 1
   13ed2:	8e 01       	movw	r16, r28
   13ed4:	04 5f       	subi	r16, 0xF4	; 244
   13ed6:	1f 4f       	sbci	r17, 0xFF	; 255
   13ed8:	ad b7       	in	r26, 0x3d	; 61
   13eda:	be b7       	in	r27, 0x3e	; 62
   13edc:	12 96       	adiw	r26, 0x02	; 2
   13ede:	1c 93       	st	X, r17
   13ee0:	0e 93       	st	-X, r16
   13ee2:	11 97       	sbiw	r26, 0x01	; 1
   13ee4:	8a e0       	ldi	r24, 0x0A	; 10
   13ee6:	90 e2       	ldi	r25, 0x20	; 32
   13ee8:	93 83       	std	Z+3, r25	; 0x03
   13eea:	82 83       	std	Z+2, r24	; 0x02
   13eec:	84 ee       	ldi	r24, 0xE4	; 228
   13eee:	92 e0       	ldi	r25, 0x02	; 2
   13ef0:	95 83       	std	Z+5, r25	; 0x05
   13ef2:	84 83       	std	Z+4, r24	; 0x04
   13ef4:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
   13ef8:	ed b7       	in	r30, 0x3d	; 61
   13efa:	fe b7       	in	r31, 0x3e	; 62
   13efc:	36 96       	adiw	r30, 0x06	; 6
   13efe:	0f b6       	in	r0, 0x3f	; 63
   13f00:	f8 94       	cli
   13f02:	fe bf       	out	0x3e, r31	; 62
   13f04:	0f be       	out	0x3f, r0	; 63
   13f06:	ed bf       	out	0x3d, r30	; 61
   13f08:	81 e0       	ldi	r24, 0x01	; 1
   13f0a:	61 e0       	ldi	r22, 0x01	; 1
   13f0c:	a8 01       	movw	r20, r16
   13f0e:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
				//Not MPD->Single Product
				if ((ProductID[0]>=1)&&(ProductID[0]<=6)&&
   13f12:	90 91 dc 02 	lds	r25, 0x02DC
   13f16:	89 2f       	mov	r24, r25
   13f18:	81 50       	subi	r24, 0x01	; 1
   13f1a:	86 30       	cpi	r24, 0x06	; 6
   13f1c:	08 f0       	brcs	.+2      	; 0x13f20 <FMenuLocalAccount+0x4cc>
   13f1e:	4e c0       	rjmp	.+156    	; 0x13fbc <FMenuLocalAccount+0x568>
   13f20:	80 91 dd 02 	lds	r24, 0x02DD
   13f24:	88 23       	and	r24, r24
   13f26:	09 f0       	breq	.+2      	; 0x13f2a <FMenuLocalAccount+0x4d6>
   13f28:	49 c0       	rjmp	.+146    	; 0x13fbc <FMenuLocalAccount+0x568>
   13f2a:	80 91 de 02 	lds	r24, 0x02DE
   13f2e:	88 23       	and	r24, r24
   13f30:	09 f0       	breq	.+2      	; 0x13f34 <FMenuLocalAccount+0x4e0>
   13f32:	44 c0       	rjmp	.+136    	; 0x13fbc <FMenuLocalAccount+0x568>
   13f34:	80 91 df 02 	lds	r24, 0x02DF
   13f38:	88 23       	and	r24, r24
   13f3a:	09 f0       	breq	.+2      	; 0x13f3e <FMenuLocalAccount+0x4ea>
   13f3c:	3f c0       	rjmp	.+126    	; 0x13fbc <FMenuLocalAccount+0x568>
				    (ProductID[1]==0)&&(ProductID[2]==0)&&(ProductID[3]==0)){
                     //Load 1st Product      					 
					 ProdId=ProductID[0];
   13f3e:	90 93 da 02 	sts	0x02DA, r25
   13f42:	6d e0       	ldi	r22, 0x0D	; 13
   13f44:	96 9f       	mul	r25, r22
   13f46:	b0 01       	movw	r22, r0
   13f48:	11 24       	eor	r1, r1
   13f4a:	62 55       	subi	r22, 0x52	; 82
   13f4c:	7f 4f       	sbci	r23, 0xFF	; 255
   13f4e:	8e 01       	movw	r16, r28
   13f50:	0f 5f       	subi	r16, 0xFF	; 255
   13f52:	1f 4f       	sbci	r17, 0xFF	; 255
   13f54:	c8 01       	movw	r24, r16
   13f56:	4a e0       	ldi	r20, 0x0A	; 10
   13f58:	50 e0       	ldi	r21, 0x00	; 0
   13f5a:	2d ef       	ldi	r18, 0xFD	; 253
   13f5c:	32 e1       	ldi	r19, 0x12	; 18
   13f5e:	0e 94 f1 b3 	call	0x167e2	; 0x167e2 <__eerd_block>
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   13f62:	ce 01       	movw	r24, r28
   13f64:	09 96       	adiw	r24, 0x09	; 9
	    Dest[i]=Source[IdxSource+i];
   13f66:	0f 5f       	subi	r16, 0xFF	; 255
   13f68:	1f 4f       	sbci	r17, 0xFF	; 255
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   13f6a:	08 17       	cp	r16, r24
   13f6c:	19 07       	cpc	r17, r25
   13f6e:	d9 f7       	brne	.-10     	; 0x13f66 <FMenuLocalAccount+0x512>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   13f70:	19 86       	std	Y+9, r1	; 0x09
				    (ProductID[1]==0)&&(ProductID[2]==0)&&(ProductID[3]==0)){
                     //Load 1st Product      					 
					 ProdId=ProductID[0];
					 eeprom_read_block((void*) &ProductName, (const void*) &DefProductName[ProdId-1],10);
					 StrPosCopy(ProductName,ProductName,0,8);
					 sprintf_P(strProduct,PSTR("%s"),ProductName);
   13f72:	00 d0       	rcall	.+0      	; 0x13f74 <FMenuLocalAccount+0x520>
   13f74:	00 d0       	rcall	.+0      	; 0x13f76 <FMenuLocalAccount+0x522>
   13f76:	00 d0       	rcall	.+0      	; 0x13f78 <FMenuLocalAccount+0x524>
   13f78:	ed b7       	in	r30, 0x3d	; 61
   13f7a:	fe b7       	in	r31, 0x3e	; 62
   13f7c:	31 96       	adiw	r30, 0x01	; 1
   13f7e:	80 e7       	ldi	r24, 0x70	; 112
   13f80:	98 e0       	ldi	r25, 0x08	; 8
   13f82:	ad b7       	in	r26, 0x3d	; 61
   13f84:	be b7       	in	r27, 0x3e	; 62
   13f86:	12 96       	adiw	r26, 0x02	; 2
   13f88:	9c 93       	st	X, r25
   13f8a:	8e 93       	st	-X, r24
   13f8c:	11 97       	sbiw	r26, 0x01	; 1
   13f8e:	87 e0       	ldi	r24, 0x07	; 7
   13f90:	90 e2       	ldi	r25, 0x20	; 32
   13f92:	93 83       	std	Z+3, r25	; 0x03
   13f94:	82 83       	std	Z+2, r24	; 0x02
   13f96:	ce 01       	movw	r24, r28
   13f98:	01 96       	adiw	r24, 0x01	; 1
   13f9a:	95 83       	std	Z+5, r25	; 0x05
   13f9c:	84 83       	std	Z+4, r24	; 0x04
   13f9e:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
                     stLocalAccount=laSelectBalanceType;
   13fa2:	8d e0       	ldi	r24, 0x0D	; 13
   13fa4:	80 93 4b 01 	sts	0x014B, r24
   13fa8:	80 e0       	ldi	r24, 0x00	; 0
   13faa:	ed b7       	in	r30, 0x3d	; 61
   13fac:	fe b7       	in	r31, 0x3e	; 62
   13fae:	36 96       	adiw	r30, 0x06	; 6
   13fb0:	0f b6       	in	r0, 0x3f	; 63
   13fb2:	f8 94       	cli
   13fb4:	fe bf       	out	0x3e, r31	; 62
   13fb6:	0f be       	out	0x3f, r0	; 63
   13fb8:	ed bf       	out	0x3d, r30	; 61
   13fba:	f9 c5       	rjmp	.+3058   	; 0x14bae <FMenuLocalAccount+0x115a>
					}else
                {
				//MultiProductDisplay Select:
				//Load Nozzle Configuration
				for(iNozzle=0;iNozzle<4;iNozzle++){
   13fbc:	10 92 e2 02 	sts	0x02E2, r1
				        eeprom_read_block((void*) &ProductName, (const void*) &DefProductName[ProdId-1],10);
						StrPosCopy(ProductName,ProductName,0,8);
					    sprintf_P(lcdteks,PSTR("%d.%s"),(iNozzle+1),ProductName);
                    }
					else{
					       sprintf_P(lcdteks,PSTR("     "));					
   13fc0:	0c e0       	ldi	r16, 0x0C	; 12
   13fc2:	e0 2e       	mov	r14, r16
   13fc4:	f1 2c       	mov	r15, r1
   13fc6:	ec 0e       	add	r14, r28
   13fc8:	fd 1e       	adc	r15, r29
   13fca:	1b ef       	ldi	r17, 0xFB	; 251
   13fcc:	81 2e       	mov	r8, r17
   13fce:	1f e1       	ldi	r17, 0x1F	; 31
   13fd0:	91 2e       	mov	r9, r17
   13fd2:	bd e0       	ldi	r27, 0x0D	; 13
   13fd4:	6b 2e       	mov	r6, r27
   13fd6:	8e 01       	movw	r16, r28
   13fd8:	0f 5f       	subi	r16, 0xFF	; 255
   13fda:	1f 4f       	sbci	r17, 0xFF	; 255
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   13fdc:	a9 e0       	ldi	r26, 0x09	; 9
   13fde:	aa 2e       	mov	r10, r26
   13fe0:	b1 2c       	mov	r11, r1
   13fe2:	ac 0e       	add	r10, r28
   13fe4:	bd 1e       	adc	r11, r29
                    //Masalah 0-->void
				    ProdId=ProductID[iNozzle];
					if ((ProdId>=1)&&(ProdId<=6)){
				        eeprom_read_block((void*) &ProductName, (const void*) &DefProductName[ProdId-1],10);
						StrPosCopy(ProductName,ProductName,0,8);
					    sprintf_P(lcdteks,PSTR("%d.%s"),(iNozzle+1),ProductName);
   13fe6:	f1 e0       	ldi	r31, 0x01	; 1
   13fe8:	cf 2e       	mov	r12, r31
   13fea:	f0 e2       	ldi	r31, 0x20	; 32
   13fec:	df 2e       	mov	r13, r31
                    }
					else{
					       sprintf_P(lcdteks,PSTR("     "));					
					}
				    lcd_print(2+(iNozzle%2),1+(iNozzle/2)*11,lcdteks);
   13fee:	eb e0       	ldi	r30, 0x0B	; 11
   13ff0:	7e 2e       	mov	r7, r30
   13ff2:	67 c0       	rjmp	.+206    	; 0x140c2 <FMenuLocalAccount+0x66e>
                {
				//MultiProductDisplay Select:
				//Load Nozzle Configuration
				for(iNozzle=0;iNozzle<4;iNozzle++){
                    //Masalah 0-->void
				    ProdId=ProductID[iNozzle];
   13ff4:	f0 e0       	ldi	r31, 0x00	; 0
   13ff6:	e4 52       	subi	r30, 0x24	; 36
   13ff8:	fd 4f       	sbci	r31, 0xFD	; 253
   13ffa:	e0 81       	ld	r30, Z
   13ffc:	e0 93 da 02 	sts	0x02DA, r30
					if ((ProdId>=1)&&(ProdId<=6)){
   14000:	8e 2f       	mov	r24, r30
   14002:	81 50       	subi	r24, 0x01	; 1
   14004:	86 30       	cpi	r24, 0x06	; 6
   14006:	c8 f5       	brcc	.+114    	; 0x1407a <FMenuLocalAccount+0x626>
   14008:	e6 9d       	mul	r30, r6
   1400a:	b0 01       	movw	r22, r0
   1400c:	11 24       	eor	r1, r1
   1400e:	62 55       	subi	r22, 0x52	; 82
   14010:	7f 4f       	sbci	r23, 0xFF	; 255
   14012:	c8 01       	movw	r24, r16
   14014:	4a e0       	ldi	r20, 0x0A	; 10
   14016:	50 e0       	ldi	r21, 0x00	; 0
   14018:	2d ef       	ldi	r18, 0xFD	; 253
   1401a:	32 e1       	ldi	r19, 0x12	; 18
   1401c:	0e 94 f1 b3 	call	0x167e2	; 0x167e2 <__eerd_block>
   14020:	c8 01       	movw	r24, r16
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   14022:	01 96       	adiw	r24, 0x01	; 1
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   14024:	8a 15       	cp	r24, r10
   14026:	9b 05       	cpc	r25, r11
   14028:	e1 f7       	brne	.-8      	; 0x14022 <FMenuLocalAccount+0x5ce>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   1402a:	19 86       	std	Y+9, r1	; 0x09
                    //Masalah 0-->void
				    ProdId=ProductID[iNozzle];
					if ((ProdId>=1)&&(ProdId<=6)){
				        eeprom_read_block((void*) &ProductName, (const void*) &DefProductName[ProdId-1],10);
						StrPosCopy(ProductName,ProductName,0,8);
					    sprintf_P(lcdteks,PSTR("%d.%s"),(iNozzle+1),ProductName);
   1402c:	2d b7       	in	r18, 0x3d	; 61
   1402e:	3e b7       	in	r19, 0x3e	; 62
   14030:	28 50       	subi	r18, 0x08	; 8
   14032:	30 40       	sbci	r19, 0x00	; 0
   14034:	0f b6       	in	r0, 0x3f	; 63
   14036:	f8 94       	cli
   14038:	3e bf       	out	0x3e, r19	; 62
   1403a:	0f be       	out	0x3f, r0	; 63
   1403c:	2d bf       	out	0x3d, r18	; 61
   1403e:	ed b7       	in	r30, 0x3d	; 61
   14040:	fe b7       	in	r31, 0x3e	; 62
   14042:	31 96       	adiw	r30, 0x01	; 1
   14044:	ad b7       	in	r26, 0x3d	; 61
   14046:	be b7       	in	r27, 0x3e	; 62
   14048:	12 96       	adiw	r26, 0x02	; 2
   1404a:	fc 92       	st	X, r15
   1404c:	ee 92       	st	-X, r14
   1404e:	11 97       	sbiw	r26, 0x01	; 1
   14050:	d3 82       	std	Z+3, r13	; 0x03
   14052:	c2 82       	std	Z+2, r12	; 0x02
   14054:	80 91 e2 02 	lds	r24, 0x02E2
   14058:	90 e0       	ldi	r25, 0x00	; 0
   1405a:	01 96       	adiw	r24, 0x01	; 1
   1405c:	95 83       	std	Z+5, r25	; 0x05
   1405e:	84 83       	std	Z+4, r24	; 0x04
   14060:	17 83       	std	Z+7, r17	; 0x07
   14062:	06 83       	std	Z+6, r16	; 0x06
   14064:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
   14068:	ed b7       	in	r30, 0x3d	; 61
   1406a:	fe b7       	in	r31, 0x3e	; 62
   1406c:	38 96       	adiw	r30, 0x08	; 8
   1406e:	0f b6       	in	r0, 0x3f	; 63
   14070:	f8 94       	cli
   14072:	fe bf       	out	0x3e, r31	; 62
   14074:	0f be       	out	0x3f, r0	; 63
   14076:	ed bf       	out	0x3d, r30	; 61
   14078:	12 c0       	rjmp	.+36     	; 0x1409e <FMenuLocalAccount+0x64a>
                    }
					else{
					       sprintf_P(lcdteks,PSTR("     "));					
   1407a:	00 d0       	rcall	.+0      	; 0x1407c <FMenuLocalAccount+0x628>
   1407c:	00 d0       	rcall	.+0      	; 0x1407e <FMenuLocalAccount+0x62a>
   1407e:	ad b7       	in	r26, 0x3d	; 61
   14080:	be b7       	in	r27, 0x3e	; 62
   14082:	12 96       	adiw	r26, 0x02	; 2
   14084:	fc 92       	st	X, r15
   14086:	ee 92       	st	-X, r14
   14088:	11 97       	sbiw	r26, 0x01	; 1
   1408a:	14 96       	adiw	r26, 0x04	; 4
   1408c:	9c 92       	st	X, r9
   1408e:	8e 92       	st	-X, r8
   14090:	13 97       	sbiw	r26, 0x03	; 3
   14092:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
   14096:	0f 90       	pop	r0
   14098:	0f 90       	pop	r0
   1409a:	0f 90       	pop	r0
   1409c:	0f 90       	pop	r0
					}
				    lcd_print(2+(iNozzle%2),1+(iNozzle/2)*11,lcdteks);
   1409e:	80 91 e2 02 	lds	r24, 0x02E2
   140a2:	68 2f       	mov	r22, r24
   140a4:	66 95       	lsr	r22
   140a6:	67 9d       	mul	r22, r7
   140a8:	b0 01       	movw	r22, r0
   140aa:	11 24       	eor	r1, r1
   140ac:	6f 5f       	subi	r22, 0xFF	; 255
   140ae:	81 70       	andi	r24, 0x01	; 1
   140b0:	8e 5f       	subi	r24, 0xFE	; 254
   140b2:	a7 01       	movw	r20, r14
   140b4:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
                     stLocalAccount=laSelectBalanceType;
					}else
                {
				//MultiProductDisplay Select:
				//Load Nozzle Configuration
				for(iNozzle=0;iNozzle<4;iNozzle++){
   140b8:	80 91 e2 02 	lds	r24, 0x02E2
   140bc:	8f 5f       	subi	r24, 0xFF	; 255
   140be:	80 93 e2 02 	sts	0x02E2, r24
   140c2:	e0 91 e2 02 	lds	r30, 0x02E2
   140c6:	e4 30       	cpi	r30, 0x04	; 4
   140c8:	08 f4       	brcc	.+2      	; 0x140cc <FMenuLocalAccount+0x678>
   140ca:	94 cf       	rjmp	.-216    	; 0x13ff4 <FMenuLocalAccount+0x5a0>
					else{
					       sprintf_P(lcdteks,PSTR("     "));					
					}
				    lcd_print(2+(iNozzle%2),1+(iNozzle/2)*11,lcdteks);
				}
	            lcd_printf(4,1,PSTR("[*]Back             "));   //"[*]Back             "				
   140cc:	84 e0       	ldi	r24, 0x04	; 4
   140ce:	61 e0       	ldi	r22, 0x01	; 1
   140d0:	46 ee       	ldi	r20, 0xE6	; 230
   140d2:	5f e1       	ldi	r21, 0x1F	; 31
   140d4:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
				stLocalAccount=laSelectProductInput;
   140d8:	8c e0       	ldi	r24, 0x0C	; 12
   140da:	44 cd       	rjmp	.-1400   	; 0x13b64 <FMenuLocalAccount+0x110>
				}
		        break; 
           case laSelectProductInput:
				KeyPressed=_key_scan(1);
   140dc:	81 e0       	ldi	r24, 0x01	; 1
   140de:	0e 94 84 ae 	call	0x15d08	; 0x15d08 <_key_scan>
   140e2:	e8 2e       	mov	r14, r24
			    KeyChar=_key_btn(KeyPressed);
   140e4:	0e 94 e5 ad 	call	0x15bca	; 0x15bca <_key_btn>
				if ((KeyChar>='1')&&(KeyChar<='4')){
   140e8:	81 53       	subi	r24, 0x31	; 49
   140ea:	84 30       	cpi	r24, 0x04	; 4
   140ec:	08 f0       	brcs	.+2      	; 0x140f0 <FMenuLocalAccount+0x69c>
   140ee:	3f c0       	rjmp	.+126    	; 0x1416e <FMenuLocalAccount+0x71a>
				    iNozzle=KeyChar-'1';
   140f0:	80 93 e2 02 	sts	0x02E2, r24
   140f4:	e8 2f       	mov	r30, r24
   140f6:	f0 e0       	ldi	r31, 0x00	; 0
   140f8:	e4 52       	subi	r30, 0x24	; 36
   140fa:	fd 4f       	sbci	r31, 0xFD	; 253
   140fc:	60 81       	ld	r22, Z
   140fe:	7d e0       	ldi	r23, 0x0D	; 13
   14100:	f7 2e       	mov	r15, r23
   14102:	6f 9d       	mul	r22, r15
   14104:	b0 01       	movw	r22, r0
   14106:	11 24       	eor	r1, r1
   14108:	62 55       	subi	r22, 0x52	; 82
   1410a:	7f 4f       	sbci	r23, 0xFF	; 255
   1410c:	8e 01       	movw	r16, r28
   1410e:	0f 5f       	subi	r16, 0xFF	; 255
   14110:	1f 4f       	sbci	r17, 0xFF	; 255
   14112:	c8 01       	movw	r24, r16
   14114:	4a e0       	ldi	r20, 0x0A	; 10
   14116:	50 e0       	ldi	r21, 0x00	; 0
   14118:	2d ef       	ldi	r18, 0xFD	; 253
   1411a:	32 e1       	ldi	r19, 0x12	; 18
   1411c:	0e 94 f1 b3 	call	0x167e2	; 0x167e2 <__eerd_block>
				    eeprom_read_block((void*) &ProductName, (const void*) &DefProductName[ProductID[iNozzle]-1],10);
					sprintf_P(strProduct,PSTR("%s"),ProductName);
   14120:	00 d0       	rcall	.+0      	; 0x14122 <FMenuLocalAccount+0x6ce>
   14122:	00 d0       	rcall	.+0      	; 0x14124 <FMenuLocalAccount+0x6d0>
   14124:	00 d0       	rcall	.+0      	; 0x14126 <FMenuLocalAccount+0x6d2>
   14126:	ed b7       	in	r30, 0x3d	; 61
   14128:	fe b7       	in	r31, 0x3e	; 62
   1412a:	31 96       	adiw	r30, 0x01	; 1
   1412c:	80 e7       	ldi	r24, 0x70	; 112
   1412e:	98 e0       	ldi	r25, 0x08	; 8
   14130:	ad b7       	in	r26, 0x3d	; 61
   14132:	be b7       	in	r27, 0x3e	; 62
   14134:	12 96       	adiw	r26, 0x02	; 2
   14136:	9c 93       	st	X, r25
   14138:	8e 93       	st	-X, r24
   1413a:	11 97       	sbiw	r26, 0x01	; 1
   1413c:	83 ee       	ldi	r24, 0xE3	; 227
   1413e:	9f e1       	ldi	r25, 0x1F	; 31
   14140:	93 83       	std	Z+3, r25	; 0x03
   14142:	82 83       	std	Z+2, r24	; 0x02
   14144:	15 83       	std	Z+5, r17	; 0x05
   14146:	04 83       	std	Z+4, r16	; 0x04
   14148:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
					NozzleID=iNozzle+1;
   1414c:	80 91 e2 02 	lds	r24, 0x02E2
   14150:	8f 5f       	subi	r24, 0xFF	; 255
   14152:	80 93 7f 08 	sts	0x087F, r24
                    stLocalAccount=laSelectBalanceType;
   14156:	f0 92 4b 01 	sts	0x014B, r15
					lcd_clear();
   1415a:	ed b7       	in	r30, 0x3d	; 61
   1415c:	fe b7       	in	r31, 0x3e	; 62
   1415e:	36 96       	adiw	r30, 0x06	; 6
   14160:	0f b6       	in	r0, 0x3f	; 63
   14162:	f8 94       	cli
   14164:	fe bf       	out	0x3e, r31	; 62
   14166:	0f be       	out	0x3f, r0	; 63
   14168:	ed bf       	out	0x3d, r30	; 61
   1416a:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
					}                
				if (KeyPressed==_KEY_CANCEL)stLocalAccount=laSelectFIP;//Back To Pump Selection
   1416e:	f7 ee       	ldi	r31, 0xE7	; 231
   14170:	ef 16       	cp	r14, r31
   14172:	09 f0       	breq	.+2      	; 0x14176 <FMenuLocalAccount+0x722>
   14174:	1b c5       	rjmp	.+2614   	; 0x14bac <FMenuLocalAccount+0x1158>
   14176:	89 e0       	ldi	r24, 0x09	; 9
   14178:	f5 cc       	rjmp	.-1558   	; 0x13b64 <FMenuLocalAccount+0x110>
		        break;
           case laSelectBalanceType:
		        lcd_clear();
   1417a:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
		        sprintf_P(lcdteks,PSTR("P%s-%s "),strFIP,strProduct);      
   1417e:	2d b7       	in	r18, 0x3d	; 61
   14180:	3e b7       	in	r19, 0x3e	; 62
   14182:	28 50       	subi	r18, 0x08	; 8
   14184:	30 40       	sbci	r19, 0x00	; 0
   14186:	0f b6       	in	r0, 0x3f	; 63
   14188:	f8 94       	cli
   1418a:	3e bf       	out	0x3e, r19	; 62
   1418c:	0f be       	out	0x3f, r0	; 63
   1418e:	2d bf       	out	0x3d, r18	; 61
   14190:	ed b7       	in	r30, 0x3d	; 61
   14192:	fe b7       	in	r31, 0x3e	; 62
   14194:	31 96       	adiw	r30, 0x01	; 1
   14196:	8e 01       	movw	r16, r28
   14198:	04 5f       	subi	r16, 0xF4	; 244
   1419a:	1f 4f       	sbci	r17, 0xFF	; 255
   1419c:	ad b7       	in	r26, 0x3d	; 61
   1419e:	be b7       	in	r27, 0x3e	; 62
   141a0:	12 96       	adiw	r26, 0x02	; 2
   141a2:	1c 93       	st	X, r17
   141a4:	0e 93       	st	-X, r16
   141a6:	11 97       	sbiw	r26, 0x01	; 1
   141a8:	8b ed       	ldi	r24, 0xDB	; 219
   141aa:	9f e1       	ldi	r25, 0x1F	; 31
   141ac:	93 83       	std	Z+3, r25	; 0x03
   141ae:	82 83       	std	Z+2, r24	; 0x02
   141b0:	84 ee       	ldi	r24, 0xE4	; 228
   141b2:	92 e0       	ldi	r25, 0x02	; 2
   141b4:	95 83       	std	Z+5, r25	; 0x05
   141b6:	84 83       	std	Z+4, r24	; 0x04
   141b8:	80 e7       	ldi	r24, 0x70	; 112
   141ba:	98 e0       	ldi	r25, 0x08	; 8
   141bc:	97 83       	std	Z+7, r25	; 0x07
   141be:	86 83       	std	Z+6, r24	; 0x06
   141c0:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
				 lcd_print(1,1,lcdteks);                        //"P01-Pertamax        "                                                                      
   141c4:	ed b7       	in	r30, 0x3d	; 61
   141c6:	fe b7       	in	r31, 0x3e	; 62
   141c8:	38 96       	adiw	r30, 0x08	; 8
   141ca:	0f b6       	in	r0, 0x3f	; 63
   141cc:	f8 94       	cli
   141ce:	fe bf       	out	0x3e, r31	; 62
   141d0:	0f be       	out	0x3f, r0	; 63
   141d2:	ed bf       	out	0x3d, r30	; 61
   141d4:	81 e0       	ldi	r24, 0x01	; 1
   141d6:	61 e0       	ldi	r22, 0x01	; 1
   141d8:	a8 01       	movw	r20, r16
   141da:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
		        lcd_printf(2,1,PSTR("[1]Volume           "));   //"[1]Premium          "                                                                      
   141de:	82 e0       	ldi	r24, 0x02	; 2
   141e0:	61 e0       	ldi	r22, 0x01	; 1
   141e2:	46 ec       	ldi	r20, 0xC6	; 198
   141e4:	5f e1       	ldi	r21, 0x1F	; 31
   141e6:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
				lcd_printf(3,1,PSTR("[2]Amount           "));   //"[2]Pertamax         "
   141ea:	83 e0       	ldi	r24, 0x03	; 3
   141ec:	61 e0       	ldi	r22, 0x01	; 1
   141ee:	41 eb       	ldi	r20, 0xB1	; 177
   141f0:	5f e1       	ldi	r21, 0x1F	; 31
   141f2:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
				lcd_printf(4,1,PSTR("[*]Back    [#]Next  "));   //"[*]Back             "						        
   141f6:	84 e0       	ldi	r24, 0x04	; 4
   141f8:	61 e0       	ldi	r22, 0x01	; 1
   141fa:	4c e9       	ldi	r20, 0x9C	; 156
   141fc:	5f e1       	ldi	r21, 0x1F	; 31
   141fe:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
	            //lcd_printf(4,1,PSTR("[*]Back    [#]Next  "));   //"[*]Back             "						        
                stLocalAccount=laSelectBalanceTypeInput;   
   14202:	8e e0       	ldi	r24, 0x0E	; 14
   14204:	af cc       	rjmp	.-1698   	; 0x13b64 <FMenuLocalAccount+0x110>
		        break;
           case laSelectBalanceTypeInput:
				KeyPressed=_key_scan(1);
   14206:	81 e0       	ldi	r24, 0x01	; 1
   14208:	0e 94 84 ae 	call	0x15d08	; 0x15d08 <_key_scan>
   1420c:	18 2f       	mov	r17, r24
			    KeyChar=_key_btn(KeyPressed);
   1420e:	0e 94 e5 ad 	call	0x15bca	; 0x15bca <_key_btn>
   14212:	98 2f       	mov	r25, r24
				if ((KeyChar>='1')&&(KeyChar<='2')){
   14214:	81 53       	subi	r24, 0x31	; 49
   14216:	82 30       	cpi	r24, 0x02	; 2
   14218:	80 f5       	brcc	.+96     	; 0x1427a <FMenuLocalAccount+0x826>
                    if(KeyChar=='1'){
   1421a:	91 33       	cpi	r25, 0x31	; 49
   1421c:	a1 f4       	brne	.+40     	; 0x14246 <FMenuLocalAccount+0x7f2>
					   BalanceType=1;
   1421e:	81 e0       	ldi	r24, 0x01	; 1
   14220:	80 93 e7 02 	sts	0x02E7, r24
					   sprintf_P(strBalanceType,PSTR("V"));
   14224:	00 d0       	rcall	.+0      	; 0x14226 <FMenuLocalAccount+0x7d2>
   14226:	00 d0       	rcall	.+0      	; 0x14228 <FMenuLocalAccount+0x7d4>
   14228:	82 eb       	ldi	r24, 0xB2	; 178
   1422a:	94 e0       	ldi	r25, 0x04	; 4
   1422c:	ad b7       	in	r26, 0x3d	; 61
   1422e:	be b7       	in	r27, 0x3e	; 62
   14230:	12 96       	adiw	r26, 0x02	; 2
   14232:	9c 93       	st	X, r25
   14234:	8e 93       	st	-X, r24
   14236:	11 97       	sbiw	r26, 0x01	; 1
   14238:	8a e9       	ldi	r24, 0x9A	; 154
   1423a:	9f e1       	ldi	r25, 0x1F	; 31
   1423c:	14 96       	adiw	r26, 0x04	; 4
   1423e:	9c 93       	st	X, r25
   14240:	8e 93       	st	-X, r24
   14242:	13 97       	sbiw	r26, 0x03	; 3
   14244:	11 c0       	rjmp	.+34     	; 0x14268 <FMenuLocalAccount+0x814>
					   }
					else
                    if(KeyChar=='2'){
   14246:	92 33       	cpi	r25, 0x32	; 50
   14248:	a9 f4       	brne	.+42     	; 0x14274 <FMenuLocalAccount+0x820>
					   BalanceType=2;
   1424a:	82 e0       	ldi	r24, 0x02	; 2
   1424c:	80 93 e7 02 	sts	0x02E7, r24
                       sprintf_P(strBalanceType,PSTR("A"));
   14250:	00 d0       	rcall	.+0      	; 0x14252 <FMenuLocalAccount+0x7fe>
   14252:	00 d0       	rcall	.+0      	; 0x14254 <FMenuLocalAccount+0x800>
   14254:	82 eb       	ldi	r24, 0xB2	; 178
   14256:	94 e0       	ldi	r25, 0x04	; 4
   14258:	ed b7       	in	r30, 0x3d	; 61
   1425a:	fe b7       	in	r31, 0x3e	; 62
   1425c:	92 83       	std	Z+2, r25	; 0x02
   1425e:	81 83       	std	Z+1, r24	; 0x01
   14260:	88 e9       	ldi	r24, 0x98	; 152
   14262:	9f e1       	ldi	r25, 0x1F	; 31
   14264:	94 83       	std	Z+4, r25	; 0x04
   14266:	83 83       	std	Z+3, r24	; 0x03
   14268:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
   1426c:	0f 90       	pop	r0
   1426e:	0f 90       	pop	r0
   14270:	0f 90       	pop	r0
   14272:	0f 90       	pop	r0
					   }
				    stLocalAccount=laBalanceValue;  
   14274:	8f e0       	ldi	r24, 0x0F	; 15
   14276:	80 93 4b 01 	sts	0x014B, r24
					}              
				if (KeyPressed==_KEY_CANCEL){
   1427a:	17 3e       	cpi	r17, 0xE7	; 231
   1427c:	c9 f4       	brne	.+50     	; 0x142b0 <FMenuLocalAccount+0x85c>
				    if ((ProductID[0]>=1)&&(ProductID[0]<=6)&&(ProductID[1]==0)&&(ProductID[2]==0)&&(ProductID[3]==0))
   1427e:	80 91 dc 02 	lds	r24, 0x02DC
   14282:	81 50       	subi	r24, 0x01	; 1
   14284:	86 30       	cpi	r24, 0x06	; 6
   14286:	70 f4       	brcc	.+28     	; 0x142a4 <FMenuLocalAccount+0x850>
   14288:	80 91 dd 02 	lds	r24, 0x02DD
   1428c:	88 23       	and	r24, r24
   1428e:	51 f4       	brne	.+20     	; 0x142a4 <FMenuLocalAccount+0x850>
   14290:	80 91 de 02 	lds	r24, 0x02DE
   14294:	88 23       	and	r24, r24
   14296:	31 f4       	brne	.+12     	; 0x142a4 <FMenuLocalAccount+0x850>
   14298:	80 91 df 02 	lds	r24, 0x02DF
   1429c:	88 23       	and	r24, r24
   1429e:	11 f4       	brne	.+4      	; 0x142a4 <FMenuLocalAccount+0x850>
					     stLocalAccount=laSelectFIP;//Back To FIP Select Non MPD
   142a0:	89 e0       	ldi	r24, 0x09	; 9
   142a2:	01 c0       	rjmp	.+2      	; 0x142a6 <FMenuLocalAccount+0x852>
                    else stLocalAccount=laSelectProduct;//Back To Product Selection MPD
   142a4:	8b e0       	ldi	r24, 0x0B	; 11
   142a6:	80 93 4b 01 	sts	0x014B, r24
					lcd_clear();
   142aa:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
   142ae:	7e c4       	rjmp	.+2300   	; 0x14bac <FMenuLocalAccount+0x1158>
					}
                else
				if (KeyPressed==_KEY_ENTER){
   142b0:	17 3b       	cpi	r17, 0xB7	; 183
   142b2:	09 f0       	breq	.+2      	; 0x142b6 <FMenuLocalAccount+0x862>
   142b4:	7b c4       	rjmp	.+2294   	; 0x14bac <FMenuLocalAccount+0x1158>
				    BalanceType=1;
   142b6:	11 e0       	ldi	r17, 0x01	; 1
   142b8:	10 93 e7 02 	sts	0x02E7, r17
					sprintf_P(strBalanceType,PSTR("A"));
   142bc:	00 d0       	rcall	.+0      	; 0x142be <FMenuLocalAccount+0x86a>
   142be:	00 d0       	rcall	.+0      	; 0x142c0 <FMenuLocalAccount+0x86c>
   142c0:	82 eb       	ldi	r24, 0xB2	; 178
   142c2:	94 e0       	ldi	r25, 0x04	; 4
   142c4:	ad b7       	in	r26, 0x3d	; 61
   142c6:	be b7       	in	r27, 0x3e	; 62
   142c8:	12 96       	adiw	r26, 0x02	; 2
   142ca:	9c 93       	st	X, r25
   142cc:	8e 93       	st	-X, r24
   142ce:	11 97       	sbiw	r26, 0x01	; 1
   142d0:	86 e9       	ldi	r24, 0x96	; 150
   142d2:	9f e1       	ldi	r25, 0x1F	; 31
   142d4:	14 96       	adiw	r26, 0x04	; 4
   142d6:	9c 93       	st	X, r25
   142d8:	8e 93       	st	-X, r24
   142da:	13 97       	sbiw	r26, 0x03	; 3
   142dc:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
					//sprintf_P(strBalanceValue,PSTR("999"));
					IsFullAuthorized=True;
   142e0:	10 93 d9 02 	sts	0x02D9, r17
                    stLocalAccount=laOdometer;//FullAuthorized
   142e4:	81 e1       	ldi	r24, 0x11	; 17
   142e6:	80 93 4b 01 	sts	0x014B, r24
   142ea:	80 e0       	ldi	r24, 0x00	; 0
   142ec:	0f 90       	pop	r0
   142ee:	0f 90       	pop	r0
   142f0:	0f 90       	pop	r0
   142f2:	0f 90       	pop	r0
   142f4:	5c c4       	rjmp	.+2232   	; 0x14bae <FMenuLocalAccount+0x115a>
					}

		        break;
           case laBalanceValue:
		        lcd_clear();
   142f6:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
		        if(BalanceType==1){
   142fa:	80 91 e7 02 	lds	r24, 0x02E7
   142fe:	81 30       	cpi	r24, 0x01	; 1
   14300:	f1 f5       	brne	.+124    	; 0x1437e <FMenuLocalAccount+0x92a>
		           sprintf_P(lcdteks,PSTR("P%s-%s "),strFIP,strProduct);      
   14302:	ed b7       	in	r30, 0x3d	; 61
   14304:	fe b7       	in	r31, 0x3e	; 62
   14306:	38 97       	sbiw	r30, 0x08	; 8
   14308:	0f b6       	in	r0, 0x3f	; 63
   1430a:	f8 94       	cli
   1430c:	fe bf       	out	0x3e, r31	; 62
   1430e:	0f be       	out	0x3f, r0	; 63
   14310:	ed bf       	out	0x3d, r30	; 61
   14312:	31 96       	adiw	r30, 0x01	; 1
   14314:	8e 01       	movw	r16, r28
   14316:	04 5f       	subi	r16, 0xF4	; 244
   14318:	1f 4f       	sbci	r17, 0xFF	; 255
   1431a:	ad b7       	in	r26, 0x3d	; 61
   1431c:	be b7       	in	r27, 0x3e	; 62
   1431e:	12 96       	adiw	r26, 0x02	; 2
   14320:	1c 93       	st	X, r17
   14322:	0e 93       	st	-X, r16
   14324:	11 97       	sbiw	r26, 0x01	; 1
   14326:	8e e8       	ldi	r24, 0x8E	; 142
   14328:	9f e1       	ldi	r25, 0x1F	; 31
   1432a:	93 83       	std	Z+3, r25	; 0x03
   1432c:	82 83       	std	Z+2, r24	; 0x02
   1432e:	84 ee       	ldi	r24, 0xE4	; 228
   14330:	92 e0       	ldi	r25, 0x02	; 2
   14332:	95 83       	std	Z+5, r25	; 0x05
   14334:	84 83       	std	Z+4, r24	; 0x04
   14336:	80 e7       	ldi	r24, 0x70	; 112
   14338:	98 e0       	ldi	r25, 0x08	; 8
   1433a:	97 83       	std	Z+7, r25	; 0x07
   1433c:	86 83       	std	Z+6, r24	; 0x06
   1433e:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
				    lcd_print(1,1,lcdteks);                        //"P01-Pertamax        "                                                                      
   14342:	ed b7       	in	r30, 0x3d	; 61
   14344:	fe b7       	in	r31, 0x3e	; 62
   14346:	38 96       	adiw	r30, 0x08	; 8
   14348:	0f b6       	in	r0, 0x3f	; 63
   1434a:	f8 94       	cli
   1434c:	fe bf       	out	0x3e, r31	; 62
   1434e:	0f be       	out	0x3f, r0	; 63
   14350:	ed bf       	out	0x3d, r30	; 61
   14352:	81 e0       	ldi	r24, 0x01	; 1
   14354:	61 e0       	ldi	r22, 0x01	; 1
   14356:	a8 01       	movw	r20, r16
   14358:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
		           lcd_printf(2,1,PSTR("[1]Volume:_         "));   //"[1]Volume:_         "                                                                      
   1435c:	82 e0       	ldi	r24, 0x02	; 2
   1435e:	61 e0       	ldi	r22, 0x01	; 1
   14360:	49 e7       	ldi	r20, 0x79	; 121
   14362:	5f e1       	ldi	r21, 0x1F	; 31
   14364:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
				   lcd_printf(3,1,PSTR("                    "));   //"                    "
   14368:	83 e0       	ldi	r24, 0x03	; 3
   1436a:	61 e0       	ldi	r22, 0x01	; 1
   1436c:	44 e6       	ldi	r20, 0x64	; 100
   1436e:	5f e1       	ldi	r21, 0x1F	; 31
   14370:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
	               lcd_printf(4,1,PSTR("[*]Back  [#]OK      "));   //"[*]Back  [#]OK     "						        
   14374:	84 e0       	ldi	r24, 0x04	; 4
   14376:	61 e0       	ldi	r22, 0x01	; 1
   14378:	4f e4       	ldi	r20, 0x4F	; 79
   1437a:	5f e1       	ldi	r21, 0x1F	; 31
   1437c:	43 c0       	rjmp	.+134    	; 0x14404 <FMenuLocalAccount+0x9b0>
				   }
                else
		        if(BalanceType==2){
   1437e:	82 30       	cpi	r24, 0x02	; 2
   14380:	09 f0       	breq	.+2      	; 0x14384 <FMenuLocalAccount+0x930>
   14382:	42 c0       	rjmp	.+132    	; 0x14408 <FMenuLocalAccount+0x9b4>
		           sprintf_P(lcdteks,PSTR("P%s-%s "),strFIP,strProduct);      
   14384:	2d b7       	in	r18, 0x3d	; 61
   14386:	3e b7       	in	r19, 0x3e	; 62
   14388:	28 50       	subi	r18, 0x08	; 8
   1438a:	30 40       	sbci	r19, 0x00	; 0
   1438c:	0f b6       	in	r0, 0x3f	; 63
   1438e:	f8 94       	cli
   14390:	3e bf       	out	0x3e, r19	; 62
   14392:	0f be       	out	0x3f, r0	; 63
   14394:	2d bf       	out	0x3d, r18	; 61
   14396:	ed b7       	in	r30, 0x3d	; 61
   14398:	fe b7       	in	r31, 0x3e	; 62
   1439a:	31 96       	adiw	r30, 0x01	; 1
   1439c:	8e 01       	movw	r16, r28
   1439e:	04 5f       	subi	r16, 0xF4	; 244
   143a0:	1f 4f       	sbci	r17, 0xFF	; 255
   143a2:	ad b7       	in	r26, 0x3d	; 61
   143a4:	be b7       	in	r27, 0x3e	; 62
   143a6:	12 96       	adiw	r26, 0x02	; 2
   143a8:	1c 93       	st	X, r17
   143aa:	0e 93       	st	-X, r16
   143ac:	11 97       	sbiw	r26, 0x01	; 1
   143ae:	87 e4       	ldi	r24, 0x47	; 71
   143b0:	9f e1       	ldi	r25, 0x1F	; 31
   143b2:	93 83       	std	Z+3, r25	; 0x03
   143b4:	82 83       	std	Z+2, r24	; 0x02
   143b6:	84 ee       	ldi	r24, 0xE4	; 228
   143b8:	92 e0       	ldi	r25, 0x02	; 2
   143ba:	95 83       	std	Z+5, r25	; 0x05
   143bc:	84 83       	std	Z+4, r24	; 0x04
   143be:	80 e7       	ldi	r24, 0x70	; 112
   143c0:	98 e0       	ldi	r25, 0x08	; 8
   143c2:	97 83       	std	Z+7, r25	; 0x07
   143c4:	86 83       	std	Z+6, r24	; 0x06
   143c6:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
				   lcd_print(1,1,lcdteks);                         //"P01-Pertamax        "                                                                      
   143ca:	ed b7       	in	r30, 0x3d	; 61
   143cc:	fe b7       	in	r31, 0x3e	; 62
   143ce:	38 96       	adiw	r30, 0x08	; 8
   143d0:	0f b6       	in	r0, 0x3f	; 63
   143d2:	f8 94       	cli
   143d4:	fe bf       	out	0x3e, r31	; 62
   143d6:	0f be       	out	0x3f, r0	; 63
   143d8:	ed bf       	out	0x3d, r30	; 61
   143da:	81 e0       	ldi	r24, 0x01	; 1
   143dc:	61 e0       	ldi	r22, 0x01	; 1
   143de:	a8 01       	movw	r20, r16
   143e0:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
		           lcd_printf(2,1,PSTR("                    "));   //"                    "                                                                      
   143e4:	82 e0       	ldi	r24, 0x02	; 2
   143e6:	61 e0       	ldi	r22, 0x01	; 1
   143e8:	42 e3       	ldi	r20, 0x32	; 50
   143ea:	5f e1       	ldi	r21, 0x1F	; 31
   143ec:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
				   lcd_printf(3,1,PSTR("[2]Amount:_         "));   //"[2]Amount:_         "
   143f0:	83 e0       	ldi	r24, 0x03	; 3
   143f2:	61 e0       	ldi	r22, 0x01	; 1
   143f4:	4d e1       	ldi	r20, 0x1D	; 29
   143f6:	5f e1       	ldi	r21, 0x1F	; 31
   143f8:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
	               lcd_printf(4,1,PSTR("[*]Back  [#]OK      "));   //"[*]Back  [#]OK      "			        
   143fc:	84 e0       	ldi	r24, 0x04	; 4
   143fe:	61 e0       	ldi	r22, 0x01	; 1
   14400:	48 e0       	ldi	r20, 0x08	; 8
   14402:	5f e1       	ldi	r21, 0x1F	; 31
   14404:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
				   }
                iLoop=0;
   14408:	10 92 d8 02 	sts	0x02D8, r1
   1440c:	10 92 d7 02 	sts	0x02D7, r1
				iValuePos=0;
   14410:	10 92 e3 02 	sts	0x02E3, r1
				//ValueChar[iValuePos]=' ';
		        stLocalAccount=laBalanceValueInput;  
   14414:	80 e1       	ldi	r24, 0x10	; 16
   14416:	a6 cb       	rjmp	.-2228   	; 0x13b64 <FMenuLocalAccount+0x110>
		        break; 
           case laBalanceValueInput:
		        uiResult=UserInput(UI_NUMBER_R,(1+BalanceType),11,strBalanceValue,0,10); 
   14418:	60 91 e7 02 	lds	r22, 0x02E7
   1441c:	6f 5f       	subi	r22, 0xFF	; 255
   1441e:	81 e0       	ldi	r24, 0x01	; 1
   14420:	4b e0       	ldi	r20, 0x0B	; 11
   14422:	26 e5       	ldi	r18, 0x56	; 86
   14424:	3d e0       	ldi	r19, 0x0D	; 13
   14426:	00 e0       	ldi	r16, 0x00	; 0
   14428:	10 e0       	ldi	r17, 0x00	; 0
   1442a:	5a e0       	ldi	r21, 0x0A	; 10
   1442c:	e5 2e       	mov	r14, r21
   1442e:	0e 94 d8 7d 	call	0xfbb0	; 0xfbb0 <UserInput>
				if (uiResult==USER_CANCEL){
   14432:	81 30       	cpi	r24, 0x01	; 1
   14434:	39 f4       	brne	.+14     	; 0x14444 <FMenuLocalAccount+0x9f0>
				    lcd_clear();
   14436:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
   1443a:	88 ea       	ldi	r24, 0xA8	; 168
   1443c:	91 e6       	ldi	r25, 0x61	; 97
   1443e:	01 97       	sbiw	r24, 0x01	; 1
   14440:	f1 f7       	brne	.-4      	; 0x1443e <FMenuLocalAccount+0x9ea>
   14442:	f9 c0       	rjmp	.+498    	; 0x14636 <FMenuLocalAccount+0xbe2>
					_delay_ms(100);		        
				    stLocalAccount=laSelectBalanceType;		        
					}
				else
				if (uiResult==USER_OK){				    
   14444:	83 30       	cpi	r24, 0x03	; 3
   14446:	09 f0       	breq	.+2      	; 0x1444a <FMenuLocalAccount+0x9f6>
   14448:	b1 c3       	rjmp	.+1890   	; 0x14bac <FMenuLocalAccount+0x1158>
				    stLocalAccount=laOdometer;
   1444a:	81 e1       	ldi	r24, 0x11	; 17
   1444c:	80 93 4b 01 	sts	0x014B, r24
					lcd_clear();
   14450:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
   14454:	88 ea       	ldi	r24, 0xA8	; 168
   14456:	91 e6       	ldi	r25, 0x61	; 97
   14458:	01 97       	sbiw	r24, 0x01	; 1
   1445a:	f1 f7       	brne	.-4      	; 0x14458 <FMenuLocalAccount+0xa04>
   1445c:	a7 c3       	rjmp	.+1870   	; 0x14bac <FMenuLocalAccount+0x1158>
					_delay_ms(100);		        
					}
*/
		        break;
           case laOdometer://GetOdometer			
		        lcd_clear();
   1445e:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
				if (IsFullAuthorized==True){
   14462:	80 91 d9 02 	lds	r24, 0x02D9
   14466:	81 30       	cpi	r24, 0x01	; 1
   14468:	09 f0       	breq	.+2      	; 0x1446c <FMenuLocalAccount+0xa18>
   1446a:	4a c0       	rjmp	.+148    	; 0x14500 <FMenuLocalAccount+0xaac>
				    lcd_printf(1,1,PSTR("Pump Product   Full"));
   1446c:	61 e0       	ldi	r22, 0x01	; 1
   1446e:	44 ef       	ldi	r20, 0xF4	; 244
   14470:	5e e1       	ldi	r21, 0x1E	; 30
   14472:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
					sprintf_P(lcdteks,PSTR("  %s %s "),strFIP,strProduct);    lcd_print(2,1,lcdteks);    //"P01  Pertamax       "
   14476:	2d b7       	in	r18, 0x3d	; 61
   14478:	3e b7       	in	r19, 0x3e	; 62
   1447a:	28 50       	subi	r18, 0x08	; 8
   1447c:	30 40       	sbci	r19, 0x00	; 0
   1447e:	0f b6       	in	r0, 0x3f	; 63
   14480:	f8 94       	cli
   14482:	3e bf       	out	0x3e, r19	; 62
   14484:	0f be       	out	0x3f, r0	; 63
   14486:	2d bf       	out	0x3d, r18	; 61
   14488:	ed b7       	in	r30, 0x3d	; 61
   1448a:	fe b7       	in	r31, 0x3e	; 62
   1448c:	31 96       	adiw	r30, 0x01	; 1
   1448e:	8e 01       	movw	r16, r28
   14490:	04 5f       	subi	r16, 0xF4	; 244
   14492:	1f 4f       	sbci	r17, 0xFF	; 255
   14494:	ad b7       	in	r26, 0x3d	; 61
   14496:	be b7       	in	r27, 0x3e	; 62
   14498:	12 96       	adiw	r26, 0x02	; 2
   1449a:	1c 93       	st	X, r17
   1449c:	0e 93       	st	-X, r16
   1449e:	11 97       	sbiw	r26, 0x01	; 1
   144a0:	8b ee       	ldi	r24, 0xEB	; 235
   144a2:	9e e1       	ldi	r25, 0x1E	; 30
   144a4:	93 83       	std	Z+3, r25	; 0x03
   144a6:	82 83       	std	Z+2, r24	; 0x02
   144a8:	84 ee       	ldi	r24, 0xE4	; 228
   144aa:	92 e0       	ldi	r25, 0x02	; 2
   144ac:	95 83       	std	Z+5, r25	; 0x05
   144ae:	84 83       	std	Z+4, r24	; 0x04
   144b0:	80 e7       	ldi	r24, 0x70	; 112
   144b2:	98 e0       	ldi	r25, 0x08	; 8
   144b4:	97 83       	std	Z+7, r25	; 0x07
   144b6:	86 83       	std	Z+6, r24	; 0x06
   144b8:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
   144bc:	ed b7       	in	r30, 0x3d	; 61
   144be:	fe b7       	in	r31, 0x3e	; 62
   144c0:	38 96       	adiw	r30, 0x08	; 8
   144c2:	0f b6       	in	r0, 0x3f	; 63
   144c4:	f8 94       	cli
   144c6:	fe bf       	out	0x3e, r31	; 62
   144c8:	0f be       	out	0x3f, r0	; 63
   144ca:	ed bf       	out	0x3d, r30	; 61
   144cc:	82 e0       	ldi	r24, 0x02	; 2
   144ce:	61 e0       	ldi	r22, 0x01	; 1
   144d0:	a8 01       	movw	r20, r16
   144d2:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
		            sprintf_P(lcdteks,PSTR("  Tank"));            lcd_print(2,14,lcdteks);   //"P01  Pertamax 500000"
   144d6:	00 d0       	rcall	.+0      	; 0x144d8 <FMenuLocalAccount+0xa84>
   144d8:	00 d0       	rcall	.+0      	; 0x144da <FMenuLocalAccount+0xa86>
   144da:	ad b7       	in	r26, 0x3d	; 61
   144dc:	be b7       	in	r27, 0x3e	; 62
   144de:	12 96       	adiw	r26, 0x02	; 2
   144e0:	1c 93       	st	X, r17
   144e2:	0e 93       	st	-X, r16
   144e4:	11 97       	sbiw	r26, 0x01	; 1
   144e6:	84 ee       	ldi	r24, 0xE4	; 228
   144e8:	9e e1       	ldi	r25, 0x1E	; 30
   144ea:	14 96       	adiw	r26, 0x04	; 4
   144ec:	9c 93       	st	X, r25
   144ee:	8e 93       	st	-X, r24
   144f0:	13 97       	sbiw	r26, 0x03	; 3
   144f2:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
   144f6:	0f 90       	pop	r0
   144f8:	0f 90       	pop	r0
   144fa:	0f 90       	pop	r0
   144fc:	0f 90       	pop	r0
   144fe:	5e c0       	rjmp	.+188    	; 0x145bc <FMenuLocalAccount+0xb68>
				}
                else{
		            if (BalanceType==1) lcd_printf(1,1,PSTR("Pump Product Volume"));
   14500:	80 91 e7 02 	lds	r24, 0x02E7
   14504:	81 30       	cpi	r24, 0x01	; 1
   14506:	29 f4       	brne	.+10     	; 0x14512 <FMenuLocalAccount+0xabe>
   14508:	61 e0       	ldi	r22, 0x01	; 1
   1450a:	40 ed       	ldi	r20, 0xD0	; 208
   1450c:	5e e1       	ldi	r21, 0x1E	; 30
   1450e:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
                    if (BalanceType==2) lcd_printf(1,1,PSTR("Pump Product Amount"));//"Pump Product  Amount" 
   14512:	80 91 e7 02 	lds	r24, 0x02E7
   14516:	82 30       	cpi	r24, 0x02	; 2
   14518:	31 f4       	brne	.+12     	; 0x14526 <FMenuLocalAccount+0xad2>
   1451a:	81 e0       	ldi	r24, 0x01	; 1
   1451c:	61 e0       	ldi	r22, 0x01	; 1
   1451e:	4c eb       	ldi	r20, 0xBC	; 188
   14520:	5e e1       	ldi	r21, 0x1E	; 30
   14522:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
					sprintf_P(lcdteks,PSTR("  %s %s "),strFIP,strProduct);    lcd_print(2,1,lcdteks);    //"P01  Pertamax       "
   14526:	ed b7       	in	r30, 0x3d	; 61
   14528:	fe b7       	in	r31, 0x3e	; 62
   1452a:	38 97       	sbiw	r30, 0x08	; 8
   1452c:	0f b6       	in	r0, 0x3f	; 63
   1452e:	f8 94       	cli
   14530:	fe bf       	out	0x3e, r31	; 62
   14532:	0f be       	out	0x3f, r0	; 63
   14534:	ed bf       	out	0x3d, r30	; 61
   14536:	31 96       	adiw	r30, 0x01	; 1
   14538:	8e 01       	movw	r16, r28
   1453a:	04 5f       	subi	r16, 0xF4	; 244
   1453c:	1f 4f       	sbci	r17, 0xFF	; 255
   1453e:	ad b7       	in	r26, 0x3d	; 61
   14540:	be b7       	in	r27, 0x3e	; 62
   14542:	12 96       	adiw	r26, 0x02	; 2
   14544:	1c 93       	st	X, r17
   14546:	0e 93       	st	-X, r16
   14548:	11 97       	sbiw	r26, 0x01	; 1
   1454a:	83 eb       	ldi	r24, 0xB3	; 179
   1454c:	9e e1       	ldi	r25, 0x1E	; 30
   1454e:	93 83       	std	Z+3, r25	; 0x03
   14550:	82 83       	std	Z+2, r24	; 0x02
   14552:	84 ee       	ldi	r24, 0xE4	; 228
   14554:	92 e0       	ldi	r25, 0x02	; 2
   14556:	95 83       	std	Z+5, r25	; 0x05
   14558:	84 83       	std	Z+4, r24	; 0x04
   1455a:	80 e7       	ldi	r24, 0x70	; 112
   1455c:	98 e0       	ldi	r25, 0x08	; 8
   1455e:	97 83       	std	Z+7, r25	; 0x07
   14560:	86 83       	std	Z+6, r24	; 0x06
   14562:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
   14566:	ed b7       	in	r30, 0x3d	; 61
   14568:	fe b7       	in	r31, 0x3e	; 62
   1456a:	38 96       	adiw	r30, 0x08	; 8
   1456c:	0f b6       	in	r0, 0x3f	; 63
   1456e:	f8 94       	cli
   14570:	fe bf       	out	0x3e, r31	; 62
   14572:	0f be       	out	0x3f, r0	; 63
   14574:	ed bf       	out	0x3d, r30	; 61
   14576:	82 e0       	ldi	r24, 0x02	; 2
   14578:	61 e0       	ldi	r22, 0x01	; 1
   1457a:	a8 01       	movw	r20, r16
   1457c:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
		            sprintf_P(lcdteks,PSTR("%s "),strBalanceValue);            lcd_print(2,14,lcdteks);   //"P01  Pertamax 500000"
   14580:	00 d0       	rcall	.+0      	; 0x14582 <FMenuLocalAccount+0xb2e>
   14582:	00 d0       	rcall	.+0      	; 0x14584 <FMenuLocalAccount+0xb30>
   14584:	00 d0       	rcall	.+0      	; 0x14586 <FMenuLocalAccount+0xb32>
   14586:	ed b7       	in	r30, 0x3d	; 61
   14588:	fe b7       	in	r31, 0x3e	; 62
   1458a:	31 96       	adiw	r30, 0x01	; 1
   1458c:	ad b7       	in	r26, 0x3d	; 61
   1458e:	be b7       	in	r27, 0x3e	; 62
   14590:	12 96       	adiw	r26, 0x02	; 2
   14592:	1c 93       	st	X, r17
   14594:	0e 93       	st	-X, r16
   14596:	11 97       	sbiw	r26, 0x01	; 1
   14598:	8f ea       	ldi	r24, 0xAF	; 175
   1459a:	9e e1       	ldi	r25, 0x1E	; 30
   1459c:	93 83       	std	Z+3, r25	; 0x03
   1459e:	82 83       	std	Z+2, r24	; 0x02
   145a0:	86 e5       	ldi	r24, 0x56	; 86
   145a2:	9d e0       	ldi	r25, 0x0D	; 13
   145a4:	95 83       	std	Z+5, r25	; 0x05
   145a6:	84 83       	std	Z+4, r24	; 0x04
   145a8:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
   145ac:	ed b7       	in	r30, 0x3d	; 61
   145ae:	fe b7       	in	r31, 0x3e	; 62
   145b0:	36 96       	adiw	r30, 0x06	; 6
   145b2:	0f b6       	in	r0, 0x3f	; 63
   145b4:	f8 94       	cli
   145b6:	fe bf       	out	0x3e, r31	; 62
   145b8:	0f be       	out	0x3f, r0	; 63
   145ba:	ed bf       	out	0x3d, r30	; 61
   145bc:	82 e0       	ldi	r24, 0x02	; 2
   145be:	6e e0       	ldi	r22, 0x0E	; 14
   145c0:	a8 01       	movw	r20, r16
   145c2:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>

				}
				lcd_printf(3,1,PSTR("Odometer:_       "));                                //"Odometer:_          "
   145c6:	83 e0       	ldi	r24, 0x03	; 3
   145c8:	61 e0       	ldi	r22, 0x01	; 1
   145ca:	4d e9       	ldi	r20, 0x9D	; 157
   145cc:	5e e1       	ldi	r21, 0x1E	; 30
   145ce:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
	            lcd_printf(4,1,PSTR("[*]Back  [#]OK   "));                                //"[*]Back  [#]OK      "						        
   145d2:	84 e0       	ldi	r24, 0x04	; 4
   145d4:	61 e0       	ldi	r22, 0x01	; 1
   145d6:	4b e8       	ldi	r20, 0x8B	; 139
   145d8:	5e e1       	ldi	r21, 0x1E	; 30
   145da:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
				ClearMem(strOdometer);
   145de:	82 ed       	ldi	r24, 0xD2	; 210
   145e0:	94 e0       	ldi	r25, 0x04	; 4
   145e2:	0e 94 7f ad 	call	0x15afe	; 0x15afe <ClearMem>
		        stLocalAccount=laOdometerInput;
   145e6:	82 e1       	ldi	r24, 0x12	; 18
   145e8:	bd ca       	rjmp	.-2694   	; 0x13b64 <FMenuLocalAccount+0x110>
		        break;
           case laOdometerInput:
				uiResult=UserInput(UI_NUMBER_R,3,10,strOdometer,0,10);
   145ea:	22 ed       	ldi	r18, 0xD2	; 210
   145ec:	c2 2e       	mov	r12, r18
   145ee:	24 e0       	ldi	r18, 0x04	; 4
   145f0:	d2 2e       	mov	r13, r18
   145f2:	81 e0       	ldi	r24, 0x01	; 1
   145f4:	63 e0       	ldi	r22, 0x03	; 3
   145f6:	4a e0       	ldi	r20, 0x0A	; 10
   145f8:	96 01       	movw	r18, r12
   145fa:	00 e0       	ldi	r16, 0x00	; 0
   145fc:	10 e0       	ldi	r17, 0x00	; 0
   145fe:	9a e0       	ldi	r25, 0x0A	; 10
   14600:	e9 2e       	mov	r14, r25
   14602:	0e 94 d8 7d 	call	0xfbb0	; 0xfbb0 <UserInput>
				if (uiResult==USER_OK){
   14606:	83 30       	cpi	r24, 0x03	; 3
   14608:	79 f4       	brne	.+30     	; 0x14628 <FMenuLocalAccount+0xbd4>
				    if ((strlen(strOdometer)==1)&&(strOdometer[0]=='0'))
   1460a:	f6 01       	movw	r30, r12
   1460c:	01 90       	ld	r0, Z+
   1460e:	00 20       	and	r0, r0
   14610:	e9 f7       	brne	.-6      	; 0x1460c <FMenuLocalAccount+0xbb8>
   14612:	e4 5d       	subi	r30, 0xD4	; 212
   14614:	f4 40       	sbci	r31, 0x04	; 4
   14616:	31 f4       	brne	.+12     	; 0x14624 <FMenuLocalAccount+0xbd0>
   14618:	80 91 d2 04 	lds	r24, 0x04D2
   1461c:	80 33       	cpi	r24, 0x30	; 48
   1461e:	11 f4       	brne	.+4      	; 0x14624 <FMenuLocalAccount+0xbd0>
					    strOdometer[0]=0;
   14620:	10 92 d2 04 	sts	0x04D2, r1
				    stLocalAccount=laDataConfirm;
   14624:	83 e1       	ldi	r24, 0x13	; 19
   14626:	9e ca       	rjmp	.-2756   	; 0x13b64 <FMenuLocalAccount+0x110>
					}
			    else
			    if (uiResult==USER_CANCEL){
   14628:	81 30       	cpi	r24, 0x01	; 1
   1462a:	09 f0       	breq	.+2      	; 0x1462e <FMenuLocalAccount+0xbda>
   1462c:	bf c2       	rjmp	.+1406   	; 0x14bac <FMenuLocalAccount+0x1158>
				    if (IsFullAuthorized==True)
   1462e:	80 91 d9 02 	lds	r24, 0x02D9
   14632:	81 30       	cpi	r24, 0x01	; 1
   14634:	11 f4       	brne	.+4      	; 0x1463a <FMenuLocalAccount+0xbe6>
					     stLocalAccount=laSelectBalanceType;
   14636:	8d e0       	ldi	r24, 0x0D	; 13
   14638:	95 ca       	rjmp	.-2774   	; 0x13b64 <FMenuLocalAccount+0x110>
					else stLocalAccount=laBalanceValue;		        
   1463a:	8f e0       	ldi	r24, 0x0F	; 15
   1463c:	93 ca       	rjmp	.-2778   	; 0x13b64 <FMenuLocalAccount+0x110>
				 }
		        break;
           case laDataConfirm: 
		        lcd_clear();
   1463e:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
   14642:	ec e3       	ldi	r30, 0x3C	; 60
   14644:	f4 e0       	ldi	r31, 0x04	; 4
   14646:	de 01       	movw	r26, r28
   14648:	90 96       	adiw	r26, 0x20	; 32
	 }Dest[Length]=0;
}
void StringCopyPos(char *Source,char *Dest,char SrcPos,char Length){
     char i;
	 for (i=0;i<Length;i++){
	     Dest[i]=Source[SrcPos+i];
   1464a:	81 91       	ld	r24, Z+
   1464c:	8d 93       	st	X+, r24
	     Dest[i]=Source[i];
	 }Dest[Length]=0;
}
void StringCopyPos(char *Source,char *Dest,char SrcPos,char Length){
     char i;
	 for (i=0;i<Length;i++){
   1464e:	34 e0       	ldi	r19, 0x04	; 4
   14650:	e6 34       	cpi	r30, 0x46	; 70
   14652:	f3 07       	cpc	r31, r19
   14654:	d1 f7       	brne	.-12     	; 0x1464a <FMenuLocalAccount+0xbf6>
	     Dest[i]=Source[SrcPos+i];
	 }Dest[Length]=0;
   14656:	1a a6       	std	Y+42, r1	; 0x2a
				 }
		        break;
           case laDataConfirm: 
		        lcd_clear();
		        StringCopyPos(strCardHolder,strName,9,10);                                          //Data Confirmation   
                sprintf_P(lcdteks,PSTR("%s "),strName);                  lcd_print(1,1,lcdteks);    //"Iyan The Man        "
   14658:	00 d0       	rcall	.+0      	; 0x1465a <FMenuLocalAccount+0xc06>
   1465a:	00 d0       	rcall	.+0      	; 0x1465c <FMenuLocalAccount+0xc08>
   1465c:	00 d0       	rcall	.+0      	; 0x1465e <FMenuLocalAccount+0xc0a>
   1465e:	ed b7       	in	r30, 0x3d	; 61
   14660:	fe b7       	in	r31, 0x3e	; 62
   14662:	31 96       	adiw	r30, 0x01	; 1
   14664:	8e 01       	movw	r16, r28
   14666:	04 5f       	subi	r16, 0xF4	; 244
   14668:	1f 4f       	sbci	r17, 0xFF	; 255
   1466a:	ad b7       	in	r26, 0x3d	; 61
   1466c:	be b7       	in	r27, 0x3e	; 62
   1466e:	12 96       	adiw	r26, 0x02	; 2
   14670:	1c 93       	st	X, r17
   14672:	0e 93       	st	-X, r16
   14674:	11 97       	sbiw	r26, 0x01	; 1
   14676:	87 e8       	ldi	r24, 0x87	; 135
   14678:	9e e1       	ldi	r25, 0x1E	; 30
   1467a:	93 83       	std	Z+3, r25	; 0x03
   1467c:	82 83       	std	Z+2, r24	; 0x02
   1467e:	ce 01       	movw	r24, r28
   14680:	80 96       	adiw	r24, 0x20	; 32
   14682:	95 83       	std	Z+5, r25	; 0x05
   14684:	84 83       	std	Z+4, r24	; 0x04
   14686:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
   1468a:	ed b7       	in	r30, 0x3d	; 61
   1468c:	fe b7       	in	r31, 0x3e	; 62
   1468e:	36 96       	adiw	r30, 0x06	; 6
   14690:	0f b6       	in	r0, 0x3f	; 63
   14692:	f8 94       	cli
   14694:	fe bf       	out	0x3e, r31	; 62
   14696:	0f be       	out	0x3f, r0	; 63
   14698:	ed bf       	out	0x3d, r30	; 61
   1469a:	81 e0       	ldi	r24, 0x01	; 1
   1469c:	61 e0       	ldi	r22, 0x01	; 1
   1469e:	a8 01       	movw	r20, r16
   146a0:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
		        sprintf_P(lcdteks,PSTR("ID: %s"),strCardID);             lcd_print(2,1,lcdteks);    //"ID1CCDA565 OD:123456"
   146a4:	00 d0       	rcall	.+0      	; 0x146a6 <FMenuLocalAccount+0xc52>
   146a6:	00 d0       	rcall	.+0      	; 0x146a8 <FMenuLocalAccount+0xc54>
   146a8:	00 d0       	rcall	.+0      	; 0x146aa <FMenuLocalAccount+0xc56>
   146aa:	ed b7       	in	r30, 0x3d	; 61
   146ac:	fe b7       	in	r31, 0x3e	; 62
   146ae:	31 96       	adiw	r30, 0x01	; 1
   146b0:	ad b7       	in	r26, 0x3d	; 61
   146b2:	be b7       	in	r27, 0x3e	; 62
   146b4:	12 96       	adiw	r26, 0x02	; 2
   146b6:	1c 93       	st	X, r17
   146b8:	0e 93       	st	-X, r16
   146ba:	11 97       	sbiw	r26, 0x01	; 1
   146bc:	80 e8       	ldi	r24, 0x80	; 128
   146be:	9e e1       	ldi	r25, 0x1E	; 30
   146c0:	93 83       	std	Z+3, r25	; 0x03
   146c2:	82 83       	std	Z+2, r24	; 0x02
   146c4:	8d eb       	ldi	r24, 0xBD	; 189
   146c6:	9c e0       	ldi	r25, 0x0C	; 12
   146c8:	95 83       	std	Z+5, r25	; 0x05
   146ca:	84 83       	std	Z+4, r24	; 0x04
   146cc:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
   146d0:	ed b7       	in	r30, 0x3d	; 61
   146d2:	fe b7       	in	r31, 0x3e	; 62
   146d4:	36 96       	adiw	r30, 0x06	; 6
   146d6:	0f b6       	in	r0, 0x3f	; 63
   146d8:	f8 94       	cli
   146da:	fe bf       	out	0x3e, r31	; 62
   146dc:	0f be       	out	0x3f, r0	; 63
   146de:	ed bf       	out	0x3d, r30	; 61
   146e0:	82 e0       	ldi	r24, 0x02	; 2
   146e2:	61 e0       	ldi	r22, 0x01	; 1
   146e4:	a8 01       	movw	r20, r16
   146e6:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
				sprintf_P(lcdteks,PSTR("%s  %s "),strFIP,strProduct);    lcd_print(3,1,lcdteks);    //"P01  Pertamax 500000"
   146ea:	2d b7       	in	r18, 0x3d	; 61
   146ec:	3e b7       	in	r19, 0x3e	; 62
   146ee:	28 50       	subi	r18, 0x08	; 8
   146f0:	30 40       	sbci	r19, 0x00	; 0
   146f2:	0f b6       	in	r0, 0x3f	; 63
   146f4:	f8 94       	cli
   146f6:	3e bf       	out	0x3e, r19	; 62
   146f8:	0f be       	out	0x3f, r0	; 63
   146fa:	2d bf       	out	0x3d, r18	; 61
   146fc:	ed b7       	in	r30, 0x3d	; 61
   146fe:	fe b7       	in	r31, 0x3e	; 62
   14700:	31 96       	adiw	r30, 0x01	; 1
   14702:	ad b7       	in	r26, 0x3d	; 61
   14704:	be b7       	in	r27, 0x3e	; 62
   14706:	12 96       	adiw	r26, 0x02	; 2
   14708:	1c 93       	st	X, r17
   1470a:	0e 93       	st	-X, r16
   1470c:	11 97       	sbiw	r26, 0x01	; 1
   1470e:	88 e7       	ldi	r24, 0x78	; 120
   14710:	9e e1       	ldi	r25, 0x1E	; 30
   14712:	93 83       	std	Z+3, r25	; 0x03
   14714:	82 83       	std	Z+2, r24	; 0x02
   14716:	84 ee       	ldi	r24, 0xE4	; 228
   14718:	92 e0       	ldi	r25, 0x02	; 2
   1471a:	95 83       	std	Z+5, r25	; 0x05
   1471c:	84 83       	std	Z+4, r24	; 0x04
   1471e:	80 e7       	ldi	r24, 0x70	; 112
   14720:	98 e0       	ldi	r25, 0x08	; 8
   14722:	97 83       	std	Z+7, r25	; 0x07
   14724:	86 83       	std	Z+6, r24	; 0x06
   14726:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
   1472a:	ed b7       	in	r30, 0x3d	; 61
   1472c:	fe b7       	in	r31, 0x3e	; 62
   1472e:	38 96       	adiw	r30, 0x08	; 8
   14730:	0f b6       	in	r0, 0x3f	; 63
   14732:	f8 94       	cli
   14734:	fe bf       	out	0x3e, r31	; 62
   14736:	0f be       	out	0x3f, r0	; 63
   14738:	ed bf       	out	0x3d, r30	; 61
   1473a:	83 e0       	ldi	r24, 0x03	; 3
   1473c:	61 e0       	ldi	r22, 0x01	; 1
   1473e:	a8 01       	movw	r20, r16
   14740:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
		        if (IsFullAuthorized==True){
   14744:	80 91 d9 02 	lds	r24, 0x02D9
   14748:	81 30       	cpi	r24, 0x01	; 1
   1474a:	39 f4       	brne	.+14     	; 0x1475a <FMenuLocalAccount+0xd06>
                    lcd_printf(3,15,PSTR(" Full"));
   1474c:	83 e0       	ldi	r24, 0x03	; 3
   1474e:	6f e0       	ldi	r22, 0x0F	; 15
   14750:	42 e7       	ldi	r20, 0x72	; 114
   14752:	5e e1       	ldi	r21, 0x1E	; 30
   14754:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
   14758:	23 c0       	rjmp	.+70     	; 0x147a0 <FMenuLocalAccount+0xd4c>
				}
				else {
				    sprintf_P(lcdteks,PSTR("%s "),strBalanceValue);          lcd_print(3,15,lcdteks);   //"[*]Back [0]ESC [#]OK " 
   1475a:	00 d0       	rcall	.+0      	; 0x1475c <FMenuLocalAccount+0xd08>
   1475c:	00 d0       	rcall	.+0      	; 0x1475e <FMenuLocalAccount+0xd0a>
   1475e:	00 d0       	rcall	.+0      	; 0x14760 <FMenuLocalAccount+0xd0c>
   14760:	ed b7       	in	r30, 0x3d	; 61
   14762:	fe b7       	in	r31, 0x3e	; 62
   14764:	31 96       	adiw	r30, 0x01	; 1
   14766:	ad b7       	in	r26, 0x3d	; 61
   14768:	be b7       	in	r27, 0x3e	; 62
   1476a:	12 96       	adiw	r26, 0x02	; 2
   1476c:	1c 93       	st	X, r17
   1476e:	0e 93       	st	-X, r16
   14770:	11 97       	sbiw	r26, 0x01	; 1
   14772:	8e e6       	ldi	r24, 0x6E	; 110
   14774:	9e e1       	ldi	r25, 0x1E	; 30
   14776:	93 83       	std	Z+3, r25	; 0x03
   14778:	82 83       	std	Z+2, r24	; 0x02
   1477a:	86 e5       	ldi	r24, 0x56	; 86
   1477c:	9d e0       	ldi	r25, 0x0D	; 13
   1477e:	95 83       	std	Z+5, r25	; 0x05
   14780:	84 83       	std	Z+4, r24	; 0x04
   14782:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
   14786:	ed b7       	in	r30, 0x3d	; 61
   14788:	fe b7       	in	r31, 0x3e	; 62
   1478a:	36 96       	adiw	r30, 0x06	; 6
   1478c:	0f b6       	in	r0, 0x3f	; 63
   1478e:	f8 94       	cli
   14790:	fe bf       	out	0x3e, r31	; 62
   14792:	0f be       	out	0x3f, r0	; 63
   14794:	ed bf       	out	0x3d, r30	; 61
   14796:	83 e0       	ldi	r24, 0x03	; 3
   14798:	6f e0       	ldi	r22, 0x0F	; 15
   1479a:	a8 01       	movw	r20, r16
   1479c:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
					}
	            lcd_printf(4,1,PSTR("[*]Back [0]ESC [#]OK"));    
   147a0:	84 e0       	ldi	r24, 0x04	; 4
   147a2:	61 e0       	ldi	r22, 0x01	; 1
   147a4:	49 e5       	ldi	r20, 0x59	; 89
   147a6:	5e e1       	ldi	r21, 0x1E	; 30
   147a8:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
                stLocalAccount=laDataConfirmInput;
   147ac:	84 e1       	ldi	r24, 0x14	; 20
   147ae:	da c9       	rjmp	.-3148   	; 0x13b64 <FMenuLocalAccount+0x110>
                //while(1){};   
		        break;
           case laDataConfirmInput:
                KeyPressed=_key_scan(1);
   147b0:	81 e0       	ldi	r24, 0x01	; 1
   147b2:	0e 94 84 ae 	call	0x15d08	; 0x15d08 <_key_scan>
                if (KeyPressed==_KEY_CANCEL)stLocalAccount=laOdometer;		        
   147b6:	87 3e       	cpi	r24, 0xE7	; 231
   147b8:	11 f4       	brne	.+4      	; 0x147be <FMenuLocalAccount+0xd6a>
   147ba:	81 e1       	ldi	r24, 0x11	; 17
   147bc:	d3 c9       	rjmp	.-3162   	; 0x13b64 <FMenuLocalAccount+0x110>
				else
				if (KeyPressed==_KEY_ENTER)stLocalAccount=laProceedTransaction;
   147be:	87 3b       	cpi	r24, 0xB7	; 183
   147c0:	11 f4       	brne	.+4      	; 0x147c6 <FMenuLocalAccount+0xd72>
   147c2:	85 e1       	ldi	r24, 0x15	; 21
   147c4:	cf c9       	rjmp	.-3170   	; 0x13b64 <FMenuLocalAccount+0x110>
				else
				if (KeyPressed==_KEY_0){
   147c6:	87 3d       	cpi	r24, 0xD7	; 215
   147c8:	09 f0       	breq	.+2      	; 0x147cc <FMenuLocalAccount+0xd78>
   147ca:	f0 c1       	rjmp	.+992    	; 0x14bac <FMenuLocalAccount+0x1158>
				   //ShowCancel
				   TimLocAcc=0;
   147cc:	10 92 bd 01 	sts	0x01BD, r1
                   lcd_clear();
   147d0:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
				   lcd_printf(1,1,PSTR("Cancel Transaction  "));    //"Cancel Transaction"
   147d4:	81 e0       	ldi	r24, 0x01	; 1
   147d6:	61 e0       	ldi	r22, 0x01	; 1
   147d8:	44 e4       	ldi	r20, 0x44	; 68
   147da:	5e e1       	ldi	r21, 0x1E	; 30
   147dc:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
   147e0:	d4 c1       	rjmp	.+936    	; 0x14b8a <FMenuLocalAccount+0x1136>
				   stLocalAccount=laDelayExit;
				   }
		        break;
           case laProceedTransaction:
		        sendMessage58();
   147e2:	0e 94 af 4f 	call	0x9f5e	; 0x9f5e <sendMessage58>
                RemZeroLead(strCardID);
   147e6:	8d eb       	ldi	r24, 0xBD	; 189
   147e8:	9c e0       	ldi	r25, 0x0C	; 12
   147ea:	0e 94 19 25 	call	0x4a32	; 0x4a32 <RemZeroLead>
                RemZeroLead(strBalanceValue);
   147ee:	b6 e5       	ldi	r27, 0x56	; 86
   147f0:	eb 2e       	mov	r14, r27
   147f2:	bd e0       	ldi	r27, 0x0D	; 13
   147f4:	fb 2e       	mov	r15, r27
   147f6:	c7 01       	movw	r24, r14
   147f8:	0e 94 19 25 	call	0x4a32	; 0x4a32 <RemZeroLead>
				sprintf_P(lcdteks,PSTR("P%s %s "),strFIP,strProduct);       lcd_print(1,1,lcdteks);    //"P01  Pertamax 500000"
   147fc:	2d b7       	in	r18, 0x3d	; 61
   147fe:	3e b7       	in	r19, 0x3e	; 62
   14800:	28 50       	subi	r18, 0x08	; 8
   14802:	30 40       	sbci	r19, 0x00	; 0
   14804:	0f b6       	in	r0, 0x3f	; 63
   14806:	f8 94       	cli
   14808:	3e bf       	out	0x3e, r19	; 62
   1480a:	0f be       	out	0x3f, r0	; 63
   1480c:	2d bf       	out	0x3d, r18	; 61
   1480e:	ed b7       	in	r30, 0x3d	; 61
   14810:	fe b7       	in	r31, 0x3e	; 62
   14812:	31 96       	adiw	r30, 0x01	; 1
   14814:	8e 01       	movw	r16, r28
   14816:	04 5f       	subi	r16, 0xF4	; 244
   14818:	1f 4f       	sbci	r17, 0xFF	; 255
   1481a:	ad b7       	in	r26, 0x3d	; 61
   1481c:	be b7       	in	r27, 0x3e	; 62
   1481e:	12 96       	adiw	r26, 0x02	; 2
   14820:	1c 93       	st	X, r17
   14822:	0e 93       	st	-X, r16
   14824:	11 97       	sbiw	r26, 0x01	; 1
   14826:	8c e3       	ldi	r24, 0x3C	; 60
   14828:	9e e1       	ldi	r25, 0x1E	; 30
   1482a:	93 83       	std	Z+3, r25	; 0x03
   1482c:	82 83       	std	Z+2, r24	; 0x02
   1482e:	84 ee       	ldi	r24, 0xE4	; 228
   14830:	92 e0       	ldi	r25, 0x02	; 2
   14832:	95 83       	std	Z+5, r25	; 0x05
   14834:	84 83       	std	Z+4, r24	; 0x04
   14836:	80 e7       	ldi	r24, 0x70	; 112
   14838:	98 e0       	ldi	r25, 0x08	; 8
   1483a:	97 83       	std	Z+7, r25	; 0x07
   1483c:	86 83       	std	Z+6, r24	; 0x06
   1483e:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
   14842:	ed b7       	in	r30, 0x3d	; 61
   14844:	fe b7       	in	r31, 0x3e	; 62
   14846:	38 96       	adiw	r30, 0x08	; 8
   14848:	0f b6       	in	r0, 0x3f	; 63
   1484a:	f8 94       	cli
   1484c:	fe bf       	out	0x3e, r31	; 62
   1484e:	0f be       	out	0x3f, r0	; 63
   14850:	ed bf       	out	0x3d, r30	; 61
   14852:	81 e0       	ldi	r24, 0x01	; 1
   14854:	61 e0       	ldi	r22, 0x01	; 1
   14856:	a8 01       	movw	r20, r16
   14858:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
		        sprintf_P(lcdteks,PSTR("%s"),strBalanceValue);              lcd_print(1,15,lcdteks);   //"ID1CCDA565          " 
   1485c:	00 d0       	rcall	.+0      	; 0x1485e <FMenuLocalAccount+0xe0a>
   1485e:	00 d0       	rcall	.+0      	; 0x14860 <FMenuLocalAccount+0xe0c>
   14860:	00 d0       	rcall	.+0      	; 0x14862 <FMenuLocalAccount+0xe0e>
   14862:	ed b7       	in	r30, 0x3d	; 61
   14864:	fe b7       	in	r31, 0x3e	; 62
   14866:	31 96       	adiw	r30, 0x01	; 1
   14868:	ad b7       	in	r26, 0x3d	; 61
   1486a:	be b7       	in	r27, 0x3e	; 62
   1486c:	12 96       	adiw	r26, 0x02	; 2
   1486e:	1c 93       	st	X, r17
   14870:	0e 93       	st	-X, r16
   14872:	11 97       	sbiw	r26, 0x01	; 1
   14874:	89 e3       	ldi	r24, 0x39	; 57
   14876:	9e e1       	ldi	r25, 0x1E	; 30
   14878:	93 83       	std	Z+3, r25	; 0x03
   1487a:	82 83       	std	Z+2, r24	; 0x02
   1487c:	f5 82       	std	Z+5, r15	; 0x05
   1487e:	e4 82       	std	Z+4, r14	; 0x04
   14880:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
   14884:	ed b7       	in	r30, 0x3d	; 61
   14886:	fe b7       	in	r31, 0x3e	; 62
   14888:	36 96       	adiw	r30, 0x06	; 6
   1488a:	0f b6       	in	r0, 0x3f	; 63
   1488c:	f8 94       	cli
   1488e:	fe bf       	out	0x3e, r31	; 62
   14890:	0f be       	out	0x3f, r0	; 63
   14892:	ed bf       	out	0x3d, r30	; 61
   14894:	81 e0       	ldi	r24, 0x01	; 1
   14896:	6f e0       	ldi	r22, 0x0F	; 15
   14898:	a8 01       	movw	r20, r16
   1489a:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
                lcd_printf(3,1,PSTR("Mohon Tunggu        "));                                         //"Mohon Tunggu ...    "
   1489e:	83 e0       	ldi	r24, 0x03	; 3
   148a0:	61 e0       	ldi	r22, 0x01	; 1
   148a2:	44 e2       	ldi	r20, 0x24	; 36
   148a4:	5e e1       	ldi	r21, 0x1E	; 30
   148a6:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		        lcd_printf(4,1,PSTR("                    "));                                  //"                    "
   148aa:	84 e0       	ldi	r24, 0x04	; 4
   148ac:	61 e0       	ldi	r22, 0x01	; 1
   148ae:	4f e0       	ldi	r20, 0x0F	; 15
   148b0:	5e e1       	ldi	r21, 0x1E	; 30
   148b2:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
				IsMessage00=False;
   148b6:	10 92 a1 01 	sts	0x01A1, r1
				TimLocAcc=0;
   148ba:	10 92 bd 01 	sts	0x01BD, r1
				iLoop=0;iPos=0;iWait=0;
   148be:	10 92 d8 02 	sts	0x02D8, r1
   148c2:	10 92 d7 02 	sts	0x02D7, r1
   148c6:	10 92 e9 02 	sts	0x02E9, r1
   148ca:	10 92 e8 02 	sts	0x02E8, r1
				stLocalAccount=laWaitMessage00;
   148ce:	87 e1       	ldi	r24, 0x17	; 23
   148d0:	49 c9       	rjmp	.-3438   	; 0x13b64 <FMenuLocalAccount+0x110>
		        break;
           case laWaitMessage00:
                iLoop++;
   148d2:	80 91 d7 02 	lds	r24, 0x02D7
   148d6:	90 91 d8 02 	lds	r25, 0x02D8
   148da:	01 96       	adiw	r24, 0x01	; 1
   148dc:	90 93 d8 02 	sts	0x02D8, r25
   148e0:	80 93 d7 02 	sts	0x02D7, r24
				if ((iLoop%MSG_WAIT_TIMOUT)==0){
   148e4:	68 e9       	ldi	r22, 0x98	; 152
   148e6:	7a e3       	ldi	r23, 0x3A	; 58
   148e8:	0e 94 0a b7 	call	0x16e14	; 0x16e14 <__udivmodhi4>
   148ec:	89 2b       	or	r24, r25
   148ee:	e1 f4       	brne	.+56     	; 0x14928 <FMenuLocalAccount+0xed4>
				   if (iPos<5){
   148f0:	60 91 e9 02 	lds	r22, 0x02E9
   148f4:	65 30       	cpi	r22, 0x05	; 5
   148f6:	58 f4       	brcc	.+22     	; 0x1490e <FMenuLocalAccount+0xeba>
				       iPos++;
   148f8:	6f 5f       	subi	r22, 0xFF	; 255
   148fa:	60 93 e9 02 	sts	0x02E9, r22
					   lcd_xy(3,(14+iPos));_lcd('.');
   148fe:	62 5f       	subi	r22, 0xF2	; 242
   14900:	83 e0       	ldi	r24, 0x03	; 3
   14902:	0e 94 ca ac 	call	0x15994	; 0x15994 <lcd_xy>
   14906:	8e e2       	ldi	r24, 0x2E	; 46
   14908:	0e 94 a4 ac 	call	0x15948	; 0x15948 <_lcd>
   1490c:	0d c0       	rjmp	.+26     	; 0x14928 <FMenuLocalAccount+0xed4>
					   }
				   else{
				       iPos=0;
   1490e:	10 92 e9 02 	sts	0x02E9, r1
					   lcd_printf(3,(14+iPos),PSTR("       "));
   14912:	83 e0       	ldi	r24, 0x03	; 3
   14914:	6e e0       	ldi	r22, 0x0E	; 14
   14916:	47 e0       	ldi	r20, 0x07	; 7
   14918:	5e e1       	ldi	r21, 0x1E	; 30
   1491a:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
					   iWait++;
   1491e:	80 91 e8 02 	lds	r24, 0x02E8
   14922:	8f 5f       	subi	r24, 0xFF	; 255
   14924:	80 93 e8 02 	sts	0x02E8, r24
					   }
				}
				if (iWait>5){
   14928:	80 91 e8 02 	lds	r24, 0x02E8
   1492c:	86 30       	cpi	r24, 0x06	; 6
   1492e:	50 f0       	brcs	.+20     	; 0x14944 <FMenuLocalAccount+0xef0>
				    stLocalAccount=laConTimout;
   14930:	84 e0       	ldi	r24, 0x04	; 4
   14932:	80 93 4b 01 	sts	0x014B, r24
					TimLocAcc=0;
   14936:	10 92 bd 01 	sts	0x01BD, r1
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   1493a:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   1493c:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   1493e:	82 e0       	ldi	r24, 0x02	; 2
   14940:	80 93 bf 01 	sts	0x01BF, r24
				if (iWait>5){
				    stLocalAccount=laConTimout;
					TimLocAcc=0;
					system_beep(2);
				    }
				if (IsMessage00==True){
   14944:	80 91 a1 01 	lds	r24, 0x01A1
   14948:	81 30       	cpi	r24, 0x01	; 1
   1494a:	09 f0       	breq	.+2      	; 0x1494e <FMenuLocalAccount+0xefa>
   1494c:	2f c1       	rjmp	.+606    	; 0x14bac <FMenuLocalAccount+0x1158>
                    IsMessage00=False;
   1494e:	10 92 a1 01 	sts	0x01A1, r1
				    stLocalAccount=laProcMessage00;
   14952:	88 e1       	ldi	r24, 0x18	; 24
   14954:	07 c9       	rjmp	.-3570   	; 0x13b64 <FMenuLocalAccount+0x110>
*/
char procMessage00(){
     char Result,strSend[10];
	 Result=MSG00_NACK;
	 //Message57
	 if((rcv_trans[0]==0x01)&&(transLength==MSG00_LENGTH)){
   14956:	80 91 51 0a 	lds	r24, 0x0A51
   1495a:	81 30       	cpi	r24, 0x01	; 1
   1495c:	51 f4       	brne	.+20     	; 0x14972 <FMenuLocalAccount+0xf1e>
   1495e:	80 91 8e 01 	lds	r24, 0x018E
   14962:	90 91 8f 01 	lds	r25, 0x018F
   14966:	8f 97       	sbiw	r24, 0x2f	; 47
   14968:	21 f4       	brne	.+8      	; 0x14972 <FMenuLocalAccount+0xf1e>
	     //Reply
		 Result=(CharPosCopy(rcv_trans,37)-'0');
   1496a:	80 91 76 0a 	lds	r24, 0x0A76
   1496e:	80 53       	subi	r24, 0x30	; 48
   14970:	01 c0       	rjmp	.+2      	; 0x14974 <FMenuLocalAccount+0xf20>
   14972:	80 e0       	ldi	r24, 0x00	; 0
                    IsMessage00=False;
				    stLocalAccount=laProcMessage00;
					}
		        break;
           case laProcMessage00:
		        LocAccStatus=procMessage00();
   14974:	80 93 ea 02 	sts	0x02EA, r24
                lcd_clear();
   14978:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
		        switch(LocAccStatus){
   1497c:	10 91 ea 02 	lds	r17, 0x02EA
   14980:	11 30       	cpi	r17, 0x01	; 1
   14982:	51 f0       	breq	.+20     	; 0x14998 <FMenuLocalAccount+0xf44>
   14984:	11 30       	cpi	r17, 0x01	; 1
   14986:	18 f0       	brcs	.+6      	; 0x1498e <FMenuLocalAccount+0xf3a>
   14988:	13 30       	cpi	r17, 0x03	; 3
   1498a:	51 f5       	brne	.+84     	; 0x149e0 <FMenuLocalAccount+0xf8c>
   1498c:	1b c0       	rjmp	.+54     	; 0x149c4 <FMenuLocalAccount+0xf70>
				case MSG00_NACK:
                     lcd_printf(2,1,PSTR("Authorisasi Gagal   "));
   1498e:	82 e0       	ldi	r24, 0x02	; 2
   14990:	61 e0       	ldi	r22, 0x01	; 1
   14992:	42 ef       	ldi	r20, 0xF2	; 242
   14994:	5d e1       	ldi	r21, 0x1D	; 29
   14996:	1a c0       	rjmp	.+52     	; 0x149cc <FMenuLocalAccount+0xf78>
					 system_beep(2); 
					 stLocalAccount=laDelayExit;
				     break;
                case MSG00_ACK:
				     lcd_printf(2,1,PSTR("Authorisasi Berhasil"));
   14998:	82 e0       	ldi	r24, 0x02	; 2
   1499a:	61 e0       	ldi	r22, 0x01	; 1
   1499c:	4d ed       	ldi	r20, 0xDD	; 221
   1499e:	5d e1       	ldi	r21, 0x1D	; 29
   149a0:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
				     LocalAccountFIP[nLocalAccount]=FIP_Used;
   149a4:	90 91 92 01 	lds	r25, 0x0192
   149a8:	e9 2f       	mov	r30, r25
   149aa:	f0 e0       	ldi	r31, 0x00	; 0
   149ac:	eb 59       	subi	r30, 0x9B	; 155
   149ae:	fb 4f       	sbci	r31, 0xFB	; 251
   149b0:	80 91 db 02 	lds	r24, 0x02DB
   149b4:	80 83       	st	Z, r24
					 nLocalAccount++;
   149b6:	9f 5f       	subi	r25, 0xFF	; 255
   149b8:	90 93 92 01 	sts	0x0192, r25
					 IsViewFillingFIP=True;
   149bc:	10 93 99 01 	sts	0x0199, r17
					 stLocalAccount=laViewStatus;
   149c0:	86 e1       	ldi	r24, 0x16	; 22
   149c2:	0c c0       	rjmp	.+24     	; 0x149dc <FMenuLocalAccount+0xf88>
				     break;
                case MSG00_NO_FIP:
                     lcd_printf(2,1,PSTR("FIP Tidak Siap    "));
   149c4:	82 e0       	ldi	r24, 0x02	; 2
   149c6:	61 e0       	ldi	r22, 0x01	; 1
   149c8:	4a ec       	ldi	r20, 0xCA	; 202
   149ca:	5d e1       	ldi	r21, 0x1D	; 29
   149cc:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   149d0:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   149d2:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   149d4:	82 e0       	ldi	r24, 0x02	; 2
   149d6:	80 93 bf 01 	sts	0x01BF, r24
					 stLocalAccount=laViewStatus;
				     break;
                case MSG00_NO_FIP:
                     lcd_printf(2,1,PSTR("FIP Tidak Siap    "));
					 system_beep(2);
					 stLocalAccount=laDelayExit;
   149da:	8e e1       	ldi	r24, 0x1E	; 30
   149dc:	80 93 4b 01 	sts	0x014B, r24
				     break;
				}
				TimLocAcc=0;
   149e0:	10 92 bd 01 	sts	0x01BD, r1
				ClearMem(strOdometer);
   149e4:	82 ed       	ldi	r24, 0xD2	; 210
   149e6:	94 e0       	ldi	r25, 0x04	; 4
   149e8:	0e 94 7f ad 	call	0x15afe	; 0x15afe <ClearMem>
	            ClearMem(strLicPlate);
   149ec:	8e e2       	ldi	r24, 0x2E	; 46
   149ee:	9a e0       	ldi	r25, 0x0A	; 10
   149f0:	0e 94 7f ad 	call	0x15afe	; 0x15afe <ClearMem>
   149f4:	db c0       	rjmp	.+438    	; 0x14bac <FMenuLocalAccount+0x1158>
		        break;
           case laViewStatus:
                if (TimLocAcc>20)stLocalAccount=laExitLocAcc;//laDisplayTransaction;
   149f6:	80 91 bd 01 	lds	r24, 0x01BD
   149fa:	85 31       	cpi	r24, 0x15	; 21
   149fc:	08 f4       	brcc	.+2      	; 0x14a00 <FMenuLocalAccount+0xfac>
   149fe:	d6 c0       	rjmp	.+428    	; 0x14bac <FMenuLocalAccount+0x1158>
   14a00:	cb c0       	rjmp	.+406    	; 0x14b98 <FMenuLocalAccount+0x1144>
		        break; 
           case laDisplayTransaction:
		        lcd_clear();
   14a02:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
                sprintf_P(lcdteks,PSTR("P%s %s "),strFIP,strProduct); lcd_print(1,1,lcdteks);    //"P01  Pertamax 500000"
   14a06:	2d b7       	in	r18, 0x3d	; 61
   14a08:	3e b7       	in	r19, 0x3e	; 62
   14a0a:	28 50       	subi	r18, 0x08	; 8
   14a0c:	30 40       	sbci	r19, 0x00	; 0
   14a0e:	0f b6       	in	r0, 0x3f	; 63
   14a10:	f8 94       	cli
   14a12:	3e bf       	out	0x3e, r19	; 62
   14a14:	0f be       	out	0x3f, r0	; 63
   14a16:	2d bf       	out	0x3d, r18	; 61
   14a18:	ed b7       	in	r30, 0x3d	; 61
   14a1a:	fe b7       	in	r31, 0x3e	; 62
   14a1c:	31 96       	adiw	r30, 0x01	; 1
   14a1e:	ac e0       	ldi	r26, 0x0C	; 12
   14a20:	ea 2e       	mov	r14, r26
   14a22:	f1 2c       	mov	r15, r1
   14a24:	ec 0e       	add	r14, r28
   14a26:	fd 1e       	adc	r15, r29
   14a28:	ad b7       	in	r26, 0x3d	; 61
   14a2a:	be b7       	in	r27, 0x3e	; 62
   14a2c:	12 96       	adiw	r26, 0x02	; 2
   14a2e:	fc 92       	st	X, r15
   14a30:	ee 92       	st	-X, r14
   14a32:	11 97       	sbiw	r26, 0x01	; 1
   14a34:	82 ec       	ldi	r24, 0xC2	; 194
   14a36:	9d e1       	ldi	r25, 0x1D	; 29
   14a38:	93 83       	std	Z+3, r25	; 0x03
   14a3a:	82 83       	std	Z+2, r24	; 0x02
   14a3c:	84 ee       	ldi	r24, 0xE4	; 228
   14a3e:	92 e0       	ldi	r25, 0x02	; 2
   14a40:	95 83       	std	Z+5, r25	; 0x05
   14a42:	84 83       	std	Z+4, r24	; 0x04
   14a44:	80 e7       	ldi	r24, 0x70	; 112
   14a46:	98 e0       	ldi	r25, 0x08	; 8
   14a48:	97 83       	std	Z+7, r25	; 0x07
   14a4a:	86 83       	std	Z+6, r24	; 0x06
   14a4c:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
   14a50:	ed b7       	in	r30, 0x3d	; 61
   14a52:	fe b7       	in	r31, 0x3e	; 62
   14a54:	38 96       	adiw	r30, 0x08	; 8
   14a56:	0f b6       	in	r0, 0x3f	; 63
   14a58:	f8 94       	cli
   14a5a:	fe bf       	out	0x3e, r31	; 62
   14a5c:	0f be       	out	0x3f, r0	; 63
   14a5e:	ed bf       	out	0x3d, r30	; 61
   14a60:	81 e0       	ldi	r24, 0x01	; 1
   14a62:	61 e0       	ldi	r22, 0x01	; 1
   14a64:	a7 01       	movw	r20, r14
   14a66:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
		        sprintf_P(lcdteks,PSTR("%s"),strBalanceValue);        lcd_print(1,15,lcdteks);   //"ID1CCDA565          " 
   14a6a:	00 d0       	rcall	.+0      	; 0x14a6c <FMenuLocalAccount+0x1018>
   14a6c:	00 d0       	rcall	.+0      	; 0x14a6e <FMenuLocalAccount+0x101a>
   14a6e:	00 d0       	rcall	.+0      	; 0x14a70 <FMenuLocalAccount+0x101c>
   14a70:	ed b7       	in	r30, 0x3d	; 61
   14a72:	fe b7       	in	r31, 0x3e	; 62
   14a74:	31 96       	adiw	r30, 0x01	; 1
   14a76:	ad b7       	in	r26, 0x3d	; 61
   14a78:	be b7       	in	r27, 0x3e	; 62
   14a7a:	12 96       	adiw	r26, 0x02	; 2
   14a7c:	fc 92       	st	X, r15
   14a7e:	ee 92       	st	-X, r14
   14a80:	11 97       	sbiw	r26, 0x01	; 1
   14a82:	8f eb       	ldi	r24, 0xBF	; 191
   14a84:	9d e1       	ldi	r25, 0x1D	; 29
   14a86:	93 83       	std	Z+3, r25	; 0x03
   14a88:	82 83       	std	Z+2, r24	; 0x02
   14a8a:	86 e5       	ldi	r24, 0x56	; 86
   14a8c:	9d e0       	ldi	r25, 0x0D	; 13
   14a8e:	95 83       	std	Z+5, r25	; 0x05
   14a90:	84 83       	std	Z+4, r24	; 0x04
   14a92:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
   14a96:	ed b7       	in	r30, 0x3d	; 61
   14a98:	fe b7       	in	r31, 0x3e	; 62
   14a9a:	36 96       	adiw	r30, 0x06	; 6
   14a9c:	0f b6       	in	r0, 0x3f	; 63
   14a9e:	f8 94       	cli
   14aa0:	fe bf       	out	0x3e, r31	; 62
   14aa2:	0f be       	out	0x3f, r0	; 63
   14aa4:	ed bf       	out	0x3d, r30	; 61
   14aa6:	81 e0       	ldi	r24, 0x01	; 1
   14aa8:	6f e0       	ldi	r22, 0x0F	; 15
   14aaa:	a7 01       	movw	r20, r14
   14aac:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
                RemSpaceLead(strCardID);
   14ab0:	0d eb       	ldi	r16, 0xBD	; 189
   14ab2:	1c e0       	ldi	r17, 0x0C	; 12
   14ab4:	c8 01       	movw	r24, r16
   14ab6:	0e 94 61 25 	call	0x4ac2	; 0x4ac2 <RemSpaceLead>
				sprintf_P(lcdteks,PSTR("ID: %s"),strCardID);          lcd_print(2,1,lcdteks);
   14aba:	00 d0       	rcall	.+0      	; 0x14abc <FMenuLocalAccount+0x1068>
   14abc:	00 d0       	rcall	.+0      	; 0x14abe <FMenuLocalAccount+0x106a>
   14abe:	00 d0       	rcall	.+0      	; 0x14ac0 <FMenuLocalAccount+0x106c>
   14ac0:	ed b7       	in	r30, 0x3d	; 61
   14ac2:	fe b7       	in	r31, 0x3e	; 62
   14ac4:	31 96       	adiw	r30, 0x01	; 1
   14ac6:	ad b7       	in	r26, 0x3d	; 61
   14ac8:	be b7       	in	r27, 0x3e	; 62
   14aca:	12 96       	adiw	r26, 0x02	; 2
   14acc:	fc 92       	st	X, r15
   14ace:	ee 92       	st	-X, r14
   14ad0:	11 97       	sbiw	r26, 0x01	; 1
   14ad2:	88 eb       	ldi	r24, 0xB8	; 184
   14ad4:	9d e1       	ldi	r25, 0x1D	; 29
   14ad6:	93 83       	std	Z+3, r25	; 0x03
   14ad8:	82 83       	std	Z+2, r24	; 0x02
   14ada:	15 83       	std	Z+5, r17	; 0x05
   14adc:	04 83       	std	Z+4, r16	; 0x04
   14ade:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
   14ae2:	ed b7       	in	r30, 0x3d	; 61
   14ae4:	fe b7       	in	r31, 0x3e	; 62
   14ae6:	36 96       	adiw	r30, 0x06	; 6
   14ae8:	0f b6       	in	r0, 0x3f	; 63
   14aea:	f8 94       	cli
   14aec:	fe bf       	out	0x3e, r31	; 62
   14aee:	0f be       	out	0x3f, r0	; 63
   14af0:	ed bf       	out	0x3d, r30	; 61
   14af2:	82 e0       	ldi	r24, 0x02	; 2
   14af4:	61 e0       	ldi	r22, 0x01	; 1
   14af6:	a7 01       	movw	r20, r14
   14af8:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>
				TimLocAcc=0;
   14afc:	10 92 bd 01 	sts	0x01BD, r1
		        IsCompleteFilling=False;
   14b00:	10 92 ac 01 	sts	0x01AC, r1
				stLocalAccount=laWaitFilling;
   14b04:	8d e1       	ldi	r24, 0x1D	; 29
   14b06:	2e c8       	rjmp	.-4004   	; 0x13b64 <FMenuLocalAccount+0x110>
		        break; 
           case laWaitFilling:
				if ((IsCompleteFilling==True)||(TimLocAcc>FILLING_TIMOUT)){
   14b08:	80 91 ac 01 	lds	r24, 0x01AC
   14b0c:	81 30       	cpi	r24, 0x01	; 1
   14b0e:	29 f0       	breq	.+10     	; 0x14b1a <FMenuLocalAccount+0x10c6>
   14b10:	80 91 bd 01 	lds	r24, 0x01BD
   14b14:	8b 30       	cpi	r24, 0x0B	; 11
   14b16:	08 f4       	brcc	.+2      	; 0x14b1a <FMenuLocalAccount+0x10c6>
   14b18:	49 c0       	rjmp	.+146    	; 0x14bac <FMenuLocalAccount+0x1158>
				    IsCompleteFilling=False;
   14b1a:	10 92 ac 01 	sts	0x01AC, r1
				    stLocalAccount=laSuccessTransaction;
   14b1e:	89 e1       	ldi	r24, 0x19	; 25
   14b20:	80 93 4b 01 	sts	0x014B, r24
					TimLocAcc=0;
   14b24:	10 92 bd 01 	sts	0x01BD, r1
   14b28:	41 c0       	rjmp	.+130    	; 0x14bac <FMenuLocalAccount+0x1158>
					}
		        break;
           case laSuccessTransaction:
				lcd_clear();lcd_printf(2,1,PSTR("Transaksi Selesai"));
   14b2a:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
   14b2e:	82 e0       	ldi	r24, 0x02	; 2
   14b30:	61 e0       	ldi	r22, 0x01	; 1
   14b32:	46 ea       	ldi	r20, 0xA6	; 166
   14b34:	5d e1       	ldi	r21, 0x1D	; 29
   14b36:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
				//Show Status FIP
				sprintf_P(lcdteks,PSTR("Fueling @FIP:#%d"),FIP_Used);
   14b3a:	00 d0       	rcall	.+0      	; 0x14b3c <FMenuLocalAccount+0x10e8>
   14b3c:	00 d0       	rcall	.+0      	; 0x14b3e <FMenuLocalAccount+0x10ea>
   14b3e:	00 d0       	rcall	.+0      	; 0x14b40 <FMenuLocalAccount+0x10ec>
   14b40:	ed b7       	in	r30, 0x3d	; 61
   14b42:	fe b7       	in	r31, 0x3e	; 62
   14b44:	31 96       	adiw	r30, 0x01	; 1
   14b46:	8e 01       	movw	r16, r28
   14b48:	04 5f       	subi	r16, 0xF4	; 244
   14b4a:	1f 4f       	sbci	r17, 0xFF	; 255
   14b4c:	ad b7       	in	r26, 0x3d	; 61
   14b4e:	be b7       	in	r27, 0x3e	; 62
   14b50:	12 96       	adiw	r26, 0x02	; 2
   14b52:	1c 93       	st	X, r17
   14b54:	0e 93       	st	-X, r16
   14b56:	11 97       	sbiw	r26, 0x01	; 1
   14b58:	85 e9       	ldi	r24, 0x95	; 149
   14b5a:	9d e1       	ldi	r25, 0x1D	; 29
   14b5c:	93 83       	std	Z+3, r25	; 0x03
   14b5e:	82 83       	std	Z+2, r24	; 0x02
   14b60:	80 91 db 02 	lds	r24, 0x02DB
   14b64:	84 83       	std	Z+4, r24	; 0x04
   14b66:	15 82       	std	Z+5, r1	; 0x05
   14b68:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
				lcd_print(3,1,lcdteks);
   14b6c:	ed b7       	in	r30, 0x3d	; 61
   14b6e:	fe b7       	in	r31, 0x3e	; 62
   14b70:	36 96       	adiw	r30, 0x06	; 6
   14b72:	0f b6       	in	r0, 0x3f	; 63
   14b74:	f8 94       	cli
   14b76:	fe bf       	out	0x3e, r31	; 62
   14b78:	0f be       	out	0x3f, r0	; 63
   14b7a:	ed bf       	out	0x3d, r30	; 61
   14b7c:	83 e0       	ldi	r24, 0x03	; 3
   14b7e:	61 e0       	ldi	r22, 0x01	; 1
   14b80:	a8 01       	movw	r20, r16
   14b82:	0e 94 e6 ac 	call	0x159cc	; 0x159cc <lcd_print>

				TimLocAcc=0;
				stLocalAccount=laDelayExit;
		        break;
           case laFailedTransaction:
		        TimLocAcc=0;
   14b86:	10 92 bd 01 	sts	0x01BD, r1
		        //Show Failed Report
				stLocalAccount=laDelayExit;
   14b8a:	8e e1       	ldi	r24, 0x1E	; 30
   14b8c:	0c 94 b2 9d 	jmp	0x13b64	; 0x13b64 <FMenuLocalAccount+0x110>
		        break;
           case laDelayExit:
		        if (TimLocAcc>15)stLocalAccount=laExitLocAcc;
   14b90:	80 91 bd 01 	lds	r24, 0x01BD
   14b94:	80 31       	cpi	r24, 0x10	; 16
   14b96:	50 f0       	brcs	.+20     	; 0x14bac <FMenuLocalAccount+0x1158>
   14b98:	8f e1       	ldi	r24, 0x1F	; 31
   14b9a:	0c 94 b2 9d 	jmp	0x13b64	; 0x13b64 <FMenuLocalAccount+0x110>
		        break;
           case laExitLocAcc:
		        Result=MENU_DONE;
				stLocalAccount=laInit;
   14b9e:	81 e0       	ldi	r24, 0x01	; 1
   14ba0:	80 93 4b 01 	sts	0x014B, r24
				lcd_clear();
   14ba4:	0e 94 3f ad 	call	0x15a7e	; 0x15a7e <lcd_clear>
   14ba8:	81 e0       	ldi	r24, 0x01	; 1
   14baa:	01 c0       	rjmp	.+2      	; 0x14bae <FMenuLocalAccount+0x115a>
   14bac:	80 e0       	ldi	r24, 0x00	; 0
		        break;
	       }//EndSwitch
return Result;
}
   14bae:	e4 96       	adiw	r28, 0x34	; 52
   14bb0:	0f b6       	in	r0, 0x3f	; 63
   14bb2:	f8 94       	cli
   14bb4:	de bf       	out	0x3e, r29	; 62
   14bb6:	0f be       	out	0x3f, r0	; 63
   14bb8:	cd bf       	out	0x3d, r28	; 61
   14bba:	cf 91       	pop	r28
   14bbc:	df 91       	pop	r29
   14bbe:	1f 91       	pop	r17
   14bc0:	0f 91       	pop	r16
   14bc2:	ff 90       	pop	r15
   14bc4:	ef 90       	pop	r14
   14bc6:	df 90       	pop	r13
   14bc8:	cf 90       	pop	r12
   14bca:	bf 90       	pop	r11
   14bcc:	af 90       	pop	r10
   14bce:	9f 90       	pop	r9
   14bd0:	8f 90       	pop	r8
   14bd2:	7f 90       	pop	r7
   14bd4:	6f 90       	pop	r6
   14bd6:	08 95       	ret

00014bd8 <SendConfigParamater>:
          stConfigProtocol=cpWaitSend;
	      break;
	 }
}

void SendConfigParamater(){
   14bd8:	8f 92       	push	r8
   14bda:	9f 92       	push	r9
   14bdc:	af 92       	push	r10
   14bde:	bf 92       	push	r11
   14be0:	cf 92       	push	r12
   14be2:	df 92       	push	r13
   14be4:	ef 92       	push	r14
   14be6:	ff 92       	push	r15
   14be8:	0f 93       	push	r16
   14bea:	1f 93       	push	r17
   14bec:	df 93       	push	r29
   14bee:	cf 93       	push	r28
   14bf0:	cd b7       	in	r28, 0x3d	; 61
   14bf2:	de b7       	in	r29, 0x3e	; 62
   14bf4:	c5 56       	subi	r28, 0x65	; 101
   14bf6:	d0 40       	sbci	r29, 0x00	; 0
   14bf8:	0f b6       	in	r0, 0x3f	; 63
   14bfa:	f8 94       	cli
   14bfc:	de bf       	out	0x3e, r29	; 62
   14bfe:	0f be       	out	0x3f, r0	; 63
   14c00:	cd bf       	out	0x3d, r28	; 61
char i,j,strSend[60];
char strEEPROM[41],xEEPROM;

     //Start
	 _uart_printf(1,0,PSTR("<"));
   14c02:	81 e0       	ldi	r24, 0x01	; 1
   14c04:	60 e0       	ldi	r22, 0x00	; 0
   14c06:	46 e8       	ldi	r20, 0x86	; 134
   14c08:	52 e2       	ldi	r21, 0x22	; 34
   14c0a:	0e 94 98 b2 	call	0x16530	; 0x16530 <_uart_printf>
   14c0e:	07 e2       	ldi	r16, 0x27	; 39
   14c10:	12 e0       	ldi	r17, 0x02	; 2
   14c12:	6e 01       	movw	r12, r28
   14c14:	08 94       	sec
   14c16:	c1 1c       	adc	r12, r1
   14c18:	d1 1c       	adc	r13, r1
     //Header Footer 400
	 for (i=0;i<10;i++){
	      eeprom_read_block((void*) &strEEPROM, (const void*) &DefHeaderFooter[i],sizeof(DefHeaderFooter[i]));
		  FillChar(strSend,0,sizeof(strSend));
	      sprintf_P(strSend,PSTR("%s"),strEEPROM);
   14c1a:	9a e2       	ldi	r25, 0x2A	; 42
   14c1c:	e9 2e       	mov	r14, r25
   14c1e:	f1 2c       	mov	r15, r1
   14c20:	ec 0e       	add	r14, r28
   14c22:	fd 1e       	adc	r15, r29
   14c24:	83 e8       	ldi	r24, 0x83	; 131
   14c26:	a8 2e       	mov	r10, r24
   14c28:	82 e2       	ldi	r24, 0x22	; 34
   14c2a:	b8 2e       	mov	r11, r24
   14c2c:	c6 01       	movw	r24, r12
   14c2e:	b8 01       	movw	r22, r16
   14c30:	49 e2       	ldi	r20, 0x29	; 41
   14c32:	50 e0       	ldi	r21, 0x00	; 0
   14c34:	2d ef       	ldi	r18, 0xFD	; 253
   14c36:	32 e1       	ldi	r19, 0x12	; 18
   14c38:	0e 94 f1 b3 	call	0x167e2	; 0x167e2 <__eerd_block>
   14c3c:	00 d0       	rcall	.+0      	; 0x14c3e <SendConfigParamater+0x66>
   14c3e:	00 d0       	rcall	.+0      	; 0x14c40 <SendConfigParamater+0x68>
   14c40:	00 d0       	rcall	.+0      	; 0x14c42 <SendConfigParamater+0x6a>
   14c42:	ed b7       	in	r30, 0x3d	; 61
   14c44:	fe b7       	in	r31, 0x3e	; 62
   14c46:	31 96       	adiw	r30, 0x01	; 1
   14c48:	ad b7       	in	r26, 0x3d	; 61
   14c4a:	be b7       	in	r27, 0x3e	; 62
   14c4c:	12 96       	adiw	r26, 0x02	; 2
   14c4e:	fc 92       	st	X, r15
   14c50:	ee 92       	st	-X, r14
   14c52:	11 97       	sbiw	r26, 0x01	; 1
   14c54:	b3 82       	std	Z+3, r11	; 0x03
   14c56:	a2 82       	std	Z+2, r10	; 0x02
   14c58:	d5 82       	std	Z+5, r13	; 0x05
   14c5a:	c4 82       	std	Z+4, r12	; 0x04
   14c5c:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
		  AddSpaceLag(strSend,40);
   14c60:	ed b7       	in	r30, 0x3d	; 61
   14c62:	fe b7       	in	r31, 0x3e	; 62
   14c64:	36 96       	adiw	r30, 0x06	; 6
   14c66:	0f b6       	in	r0, 0x3f	; 63
   14c68:	f8 94       	cli
   14c6a:	fe bf       	out	0x3e, r31	; 62
   14c6c:	0f be       	out	0x3f, r0	; 63
   14c6e:	ed bf       	out	0x3d, r30	; 61
   14c70:	c7 01       	movw	r24, r14
   14c72:	68 e2       	ldi	r22, 0x28	; 40
   14c74:	0e 94 a0 2d 	call	0x5b40	; 0x5b40 <AddSpaceLag>
		  _uart_print(1,0,strSend);
   14c78:	81 e0       	ldi	r24, 0x01	; 1
   14c7a:	60 e0       	ldi	r22, 0x00	; 0
   14c7c:	a7 01       	movw	r20, r14
   14c7e:	0e 94 70 b2 	call	0x164e0	; 0x164e0 <_uart_print>
   14c82:	07 5d       	subi	r16, 0xD7	; 215
   14c84:	1f 4f       	sbci	r17, 0xFF	; 255
char strEEPROM[41],xEEPROM;

     //Start
	 _uart_printf(1,0,PSTR("<"));
     //Header Footer 400
	 for (i=0;i<10;i++){
   14c86:	f3 e0       	ldi	r31, 0x03	; 3
   14c88:	01 3c       	cpi	r16, 0xC1	; 193
   14c8a:	1f 07       	cpc	r17, r31
   14c8c:	79 f6       	brne	.-98     	; 0x14c2c <SendConfigParamater+0x54>
   14c8e:	0b eb       	ldi	r16, 0xBB	; 187
   14c90:	10 e0       	ldi	r17, 0x00	; 0
   14c92:	6e 01       	movw	r12, r28
   14c94:	08 94       	sec
   14c96:	c1 1c       	adc	r12, r1
   14c98:	d1 1c       	adc	r13, r1
	 }
	 //ProductName 72 
	 for (i=0;i<6;i++){
		 eeprom_read_block((void*) &strEEPROM, (const void*) &DefProductName[i],sizeof(DefProductName[i]));
		 FillChar(strSend,0,sizeof(strSend));
	     sprintf_P(strSend,PSTR("%s"),strEEPROM);
   14c9a:	ba e2       	ldi	r27, 0x2A	; 42
   14c9c:	eb 2e       	mov	r14, r27
   14c9e:	f1 2c       	mov	r15, r1
   14ca0:	ec 0e       	add	r14, r28
   14ca2:	fd 1e       	adc	r15, r29
   14ca4:	a0 e8       	ldi	r26, 0x80	; 128
   14ca6:	aa 2e       	mov	r10, r26
   14ca8:	a2 e2       	ldi	r26, 0x22	; 34
   14caa:	ba 2e       	mov	r11, r26
   14cac:	c6 01       	movw	r24, r12
   14cae:	b8 01       	movw	r22, r16
   14cb0:	4d e0       	ldi	r20, 0x0D	; 13
   14cb2:	50 e0       	ldi	r21, 0x00	; 0
   14cb4:	2d ef       	ldi	r18, 0xFD	; 253
   14cb6:	32 e1       	ldi	r19, 0x12	; 18
   14cb8:	0e 94 f1 b3 	call	0x167e2	; 0x167e2 <__eerd_block>
   14cbc:	00 d0       	rcall	.+0      	; 0x14cbe <SendConfigParamater+0xe6>
   14cbe:	00 d0       	rcall	.+0      	; 0x14cc0 <SendConfigParamater+0xe8>
   14cc0:	00 d0       	rcall	.+0      	; 0x14cc2 <SendConfigParamater+0xea>
   14cc2:	ed b7       	in	r30, 0x3d	; 61
   14cc4:	fe b7       	in	r31, 0x3e	; 62
   14cc6:	31 96       	adiw	r30, 0x01	; 1
   14cc8:	ad b7       	in	r26, 0x3d	; 61
   14cca:	be b7       	in	r27, 0x3e	; 62
   14ccc:	12 96       	adiw	r26, 0x02	; 2
   14cce:	fc 92       	st	X, r15
   14cd0:	ee 92       	st	-X, r14
   14cd2:	11 97       	sbiw	r26, 0x01	; 1
   14cd4:	b3 82       	std	Z+3, r11	; 0x03
   14cd6:	a2 82       	std	Z+2, r10	; 0x02
   14cd8:	d5 82       	std	Z+5, r13	; 0x05
   14cda:	c4 82       	std	Z+4, r12	; 0x04
   14cdc:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
		 AddSpaceLag(strSend,12);
   14ce0:	ed b7       	in	r30, 0x3d	; 61
   14ce2:	fe b7       	in	r31, 0x3e	; 62
   14ce4:	36 96       	adiw	r30, 0x06	; 6
   14ce6:	0f b6       	in	r0, 0x3f	; 63
   14ce8:	f8 94       	cli
   14cea:	fe bf       	out	0x3e, r31	; 62
   14cec:	0f be       	out	0x3f, r0	; 63
   14cee:	ed bf       	out	0x3d, r30	; 61
   14cf0:	c7 01       	movw	r24, r14
   14cf2:	6c e0       	ldi	r22, 0x0C	; 12
   14cf4:	0e 94 a0 2d 	call	0x5b40	; 0x5b40 <AddSpaceLag>
		 _uart_print(1,0,strSend);
   14cf8:	81 e0       	ldi	r24, 0x01	; 1
   14cfa:	60 e0       	ldi	r22, 0x00	; 0
   14cfc:	a7 01       	movw	r20, r14
   14cfe:	0e 94 70 b2 	call	0x164e0	; 0x164e0 <_uart_print>
   14d02:	03 5f       	subi	r16, 0xF3	; 243
   14d04:	1f 4f       	sbci	r17, 0xFF	; 255
	      sprintf_P(strSend,PSTR("%s"),strEEPROM);
		  AddSpaceLag(strSend,40);
		  _uart_print(1,0,strSend);
	 }
	 //ProductName 72 
	 for (i=0;i<6;i++){
   14d06:	f1 e0       	ldi	r31, 0x01	; 1
   14d08:	09 30       	cpi	r16, 0x09	; 9
   14d0a:	1f 07       	cpc	r17, r31
   14d0c:	79 f6       	brne	.-98     	; 0x14cac <SendConfigParamater+0xd4>
   14d0e:	05 e8       	ldi	r16, 0x85	; 133
   14d10:	10 e0       	ldi	r17, 0x00	; 0
   14d12:	6e 01       	movw	r12, r28
   14d14:	08 94       	sec
   14d16:	c1 1c       	adc	r12, r1
   14d18:	d1 1c       	adc	r13, r1
	 }
	 //ProductPrice 30
	 for (i=0;i<6;i++){
		 eeprom_read_block((void*) &strEEPROM, (const void*) &DefProductPrice[i],sizeof(DefProductPrice[i]));
		 FillChar(strSend,0,sizeof(strSend));
	     sprintf_P(strSend,PSTR("%s"),strEEPROM);
   14d1a:	fa e2       	ldi	r31, 0x2A	; 42
   14d1c:	ef 2e       	mov	r14, r31
   14d1e:	f1 2c       	mov	r15, r1
   14d20:	ec 0e       	add	r14, r28
   14d22:	fd 1e       	adc	r15, r29
   14d24:	ed e7       	ldi	r30, 0x7D	; 125
   14d26:	ae 2e       	mov	r10, r30
   14d28:	e2 e2       	ldi	r30, 0x22	; 34
   14d2a:	be 2e       	mov	r11, r30
   14d2c:	c6 01       	movw	r24, r12
   14d2e:	b8 01       	movw	r22, r16
   14d30:	49 e0       	ldi	r20, 0x09	; 9
   14d32:	50 e0       	ldi	r21, 0x00	; 0
   14d34:	2d ef       	ldi	r18, 0xFD	; 253
   14d36:	32 e1       	ldi	r19, 0x12	; 18
   14d38:	0e 94 f1 b3 	call	0x167e2	; 0x167e2 <__eerd_block>
   14d3c:	00 d0       	rcall	.+0      	; 0x14d3e <SendConfigParamater+0x166>
   14d3e:	00 d0       	rcall	.+0      	; 0x14d40 <SendConfigParamater+0x168>
   14d40:	00 d0       	rcall	.+0      	; 0x14d42 <SendConfigParamater+0x16a>
   14d42:	ed b7       	in	r30, 0x3d	; 61
   14d44:	fe b7       	in	r31, 0x3e	; 62
   14d46:	31 96       	adiw	r30, 0x01	; 1
   14d48:	ad b7       	in	r26, 0x3d	; 61
   14d4a:	be b7       	in	r27, 0x3e	; 62
   14d4c:	12 96       	adiw	r26, 0x02	; 2
   14d4e:	fc 92       	st	X, r15
   14d50:	ee 92       	st	-X, r14
   14d52:	11 97       	sbiw	r26, 0x01	; 1
   14d54:	b3 82       	std	Z+3, r11	; 0x03
   14d56:	a2 82       	std	Z+2, r10	; 0x02
   14d58:	d5 82       	std	Z+5, r13	; 0x05
   14d5a:	c4 82       	std	Z+4, r12	; 0x04
   14d5c:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
		 AddSpaceLag(strSend,5);
   14d60:	ed b7       	in	r30, 0x3d	; 61
   14d62:	fe b7       	in	r31, 0x3e	; 62
   14d64:	36 96       	adiw	r30, 0x06	; 6
   14d66:	0f b6       	in	r0, 0x3f	; 63
   14d68:	f8 94       	cli
   14d6a:	fe bf       	out	0x3e, r31	; 62
   14d6c:	0f be       	out	0x3f, r0	; 63
   14d6e:	ed bf       	out	0x3d, r30	; 61
   14d70:	c7 01       	movw	r24, r14
   14d72:	65 e0       	ldi	r22, 0x05	; 5
   14d74:	0e 94 a0 2d 	call	0x5b40	; 0x5b40 <AddSpaceLag>
		 _uart_print(1,0,strSend);
   14d78:	81 e0       	ldi	r24, 0x01	; 1
   14d7a:	60 e0       	ldi	r22, 0x00	; 0
   14d7c:	a7 01       	movw	r20, r14
   14d7e:	0e 94 70 b2 	call	0x164e0	; 0x164e0 <_uart_print>
   14d82:	07 5f       	subi	r16, 0xF7	; 247
   14d84:	1f 4f       	sbci	r17, 0xFF	; 255
	     sprintf_P(strSend,PSTR("%s"),strEEPROM);
		 AddSpaceLag(strSend,12);
		 _uart_print(1,0,strSend);
	 }
	 //ProductPrice 30
	 for (i=0;i<6;i++){
   14d86:	f0 e0       	ldi	r31, 0x00	; 0
   14d88:	0b 3b       	cpi	r16, 0xBB	; 187
   14d8a:	1f 07       	cpc	r17, r31
   14d8c:	79 f6       	brne	.-98     	; 0x14d2c <SendConfigParamater+0x154>
   14d8e:	05 e4       	ldi	r16, 0x45	; 69
   14d90:	10 e0       	ldi	r17, 0x00	; 0
	 //PumpID Config 8
	 for (i=0;i<8;i++){
	      xEEPROM=eeprom_read_byte(&DefPumpMap[i]);
		  if (xEEPROM>=100)xEEPROM=0;
		  FillChar(strSend,0,sizeof(strSend));
	      sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
   14d92:	7a e2       	ldi	r23, 0x2A	; 42
   14d94:	e7 2e       	mov	r14, r23
   14d96:	f1 2c       	mov	r15, r1
   14d98:	ec 0e       	add	r14, r28
   14d9a:	fd 1e       	adc	r15, r29
   14d9c:	68 e7       	ldi	r22, 0x78	; 120
   14d9e:	c6 2e       	mov	r12, r22
   14da0:	62 e2       	ldi	r22, 0x22	; 34
   14da2:	d6 2e       	mov	r13, r22
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   14da4:	e1 99       	sbic	0x1c, 1	; 28
   14da6:	fe cf       	rjmp	.-4      	; 0x14da4 <SendConfigParamater+0x1cc>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   14da8:	1f bb       	out	0x1f, r17	; 31
   14daa:	0e bb       	out	0x1e, r16	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   14dac:	e0 9a       	sbi	0x1c, 0	; 28
   14dae:	8d b3       	in	r24, 0x1d	; 29
		 _uart_print(1,0,strSend);
	 }
	 //PumpID Config 8
	 for (i=0;i<8;i++){
	      xEEPROM=eeprom_read_byte(&DefPumpMap[i]);
		  if (xEEPROM>=100)xEEPROM=0;
   14db0:	84 36       	cpi	r24, 0x64	; 100
   14db2:	08 f0       	brcs	.+2      	; 0x14db6 <SendConfigParamater+0x1de>
   14db4:	80 e0       	ldi	r24, 0x00	; 0
		  FillChar(strSend,0,sizeof(strSend));
	      sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
   14db6:	00 d0       	rcall	.+0      	; 0x14db8 <SendConfigParamater+0x1e0>
   14db8:	00 d0       	rcall	.+0      	; 0x14dba <SendConfigParamater+0x1e2>
   14dba:	00 d0       	rcall	.+0      	; 0x14dbc <SendConfigParamater+0x1e4>
   14dbc:	ed b7       	in	r30, 0x3d	; 61
   14dbe:	fe b7       	in	r31, 0x3e	; 62
   14dc0:	31 96       	adiw	r30, 0x01	; 1
   14dc2:	ad b7       	in	r26, 0x3d	; 61
   14dc4:	be b7       	in	r27, 0x3e	; 62
   14dc6:	12 96       	adiw	r26, 0x02	; 2
   14dc8:	fc 92       	st	X, r15
   14dca:	ee 92       	st	-X, r14
   14dcc:	11 97       	sbiw	r26, 0x01	; 1
   14dce:	d3 82       	std	Z+3, r13	; 0x03
   14dd0:	c2 82       	std	Z+2, r12	; 0x02
   14dd2:	84 83       	std	Z+4, r24	; 0x04
   14dd4:	15 82       	std	Z+5, r1	; 0x05
   14dd6:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
		  AddSpaceLag(strSend,2);
   14dda:	ed b7       	in	r30, 0x3d	; 61
   14ddc:	fe b7       	in	r31, 0x3e	; 62
   14dde:	36 96       	adiw	r30, 0x06	; 6
   14de0:	0f b6       	in	r0, 0x3f	; 63
   14de2:	f8 94       	cli
   14de4:	fe bf       	out	0x3e, r31	; 62
   14de6:	0f be       	out	0x3f, r0	; 63
   14de8:	ed bf       	out	0x3d, r30	; 61
   14dea:	c7 01       	movw	r24, r14
   14dec:	62 e0       	ldi	r22, 0x02	; 2
   14dee:	0e 94 a0 2d 	call	0x5b40	; 0x5b40 <AddSpaceLag>
		 _uart_print(1,0,strSend);
   14df2:	81 e0       	ldi	r24, 0x01	; 1
   14df4:	60 e0       	ldi	r22, 0x00	; 0
   14df6:	a7 01       	movw	r20, r14
   14df8:	0e 94 70 b2 	call	0x164e0	; 0x164e0 <_uart_print>
   14dfc:	0f 5f       	subi	r16, 0xFF	; 255
   14dfe:	1f 4f       	sbci	r17, 0xFF	; 255
	     sprintf_P(strSend,PSTR("%s"),strEEPROM);
		 AddSpaceLag(strSend,5);
		 _uart_print(1,0,strSend);
	 }
	 //PumpID Config 8
	 for (i=0;i<8;i++){
   14e00:	f0 e0       	ldi	r31, 0x00	; 0
   14e02:	0d 34       	cpi	r16, 0x4D	; 77
   14e04:	1f 07       	cpc	r17, r31
   14e06:	71 f6       	brne	.-100    	; 0x14da4 <SendConfigParamater+0x1cc>
   14e08:	55 e5       	ldi	r21, 0x55	; 85
   14e0a:	e5 2e       	mov	r14, r21
   14e0c:	50 e0       	ldi	r21, 0x00	; 0
   14e0e:	f5 2e       	mov	r15, r21
	 //PumpID NozzleConfig 48
	 for (i=0;i<8;i++){
	      for (j=0;j<6;j++){
		       xEEPROM=eeprom_read_byte(&DefNozzleMap[i][j]);     
			   if (xEEPROM>=10)xEEPROM=0;
			   sprintf_P(strSend,PSTR("%d"),xEEPROM);
   14e10:	4a e2       	ldi	r20, 0x2A	; 42
   14e12:	a4 2e       	mov	r10, r20
   14e14:	b1 2c       	mov	r11, r1
   14e16:	ac 0e       	add	r10, r28
   14e18:	bd 1e       	adc	r11, r29
   14e1a:	35 e7       	ldi	r19, 0x75	; 117
   14e1c:	83 2e       	mov	r8, r19
   14e1e:	32 e2       	ldi	r19, 0x22	; 34
   14e20:	93 2e       	mov	r9, r19
   14e22:	37 c0       	rjmp	.+110    	; 0x14e92 <SendConfigParamater+0x2ba>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   14e24:	e1 99       	sbic	0x1c, 1	; 28
   14e26:	fe cf       	rjmp	.-4      	; 0x14e24 <SendConfigParamater+0x24c>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   14e28:	1f bb       	out	0x1f, r17	; 31
   14e2a:	0e bb       	out	0x1e, r16	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   14e2c:	e0 9a       	sbi	0x1c, 0	; 28
   14e2e:	8d b3       	in	r24, 0x1d	; 29
	 }
	 //PumpID NozzleConfig 48
	 for (i=0;i<8;i++){
	      for (j=0;j<6;j++){
		       xEEPROM=eeprom_read_byte(&DefNozzleMap[i][j]);     
			   if (xEEPROM>=10)xEEPROM=0;
   14e30:	8a 30       	cpi	r24, 0x0A	; 10
   14e32:	08 f0       	brcs	.+2      	; 0x14e36 <SendConfigParamater+0x25e>
   14e34:	80 e0       	ldi	r24, 0x00	; 0
			   sprintf_P(strSend,PSTR("%d"),xEEPROM);
   14e36:	00 d0       	rcall	.+0      	; 0x14e38 <SendConfigParamater+0x260>
   14e38:	00 d0       	rcall	.+0      	; 0x14e3a <SendConfigParamater+0x262>
   14e3a:	00 d0       	rcall	.+0      	; 0x14e3c <SendConfigParamater+0x264>
   14e3c:	ed b7       	in	r30, 0x3d	; 61
   14e3e:	fe b7       	in	r31, 0x3e	; 62
   14e40:	31 96       	adiw	r30, 0x01	; 1
   14e42:	ad b7       	in	r26, 0x3d	; 61
   14e44:	be b7       	in	r27, 0x3e	; 62
   14e46:	12 96       	adiw	r26, 0x02	; 2
   14e48:	bc 92       	st	X, r11
   14e4a:	ae 92       	st	-X, r10
   14e4c:	11 97       	sbiw	r26, 0x01	; 1
   14e4e:	93 82       	std	Z+3, r9	; 0x03
   14e50:	82 82       	std	Z+2, r8	; 0x02
   14e52:	84 83       	std	Z+4, r24	; 0x04
   14e54:	15 82       	std	Z+5, r1	; 0x05
   14e56:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
			   _uart_print(1,0,strSend);
   14e5a:	ed b7       	in	r30, 0x3d	; 61
   14e5c:	fe b7       	in	r31, 0x3e	; 62
   14e5e:	36 96       	adiw	r30, 0x06	; 6
   14e60:	0f b6       	in	r0, 0x3f	; 63
   14e62:	f8 94       	cli
   14e64:	fe bf       	out	0x3e, r31	; 62
   14e66:	0f be       	out	0x3f, r0	; 63
   14e68:	ed bf       	out	0x3d, r30	; 61
   14e6a:	81 e0       	ldi	r24, 0x01	; 1
   14e6c:	60 e0       	ldi	r22, 0x00	; 0
   14e6e:	a5 01       	movw	r20, r10
   14e70:	0e 94 70 b2 	call	0x164e0	; 0x164e0 <_uart_print>
		  AddSpaceLag(strSend,2);
		 _uart_print(1,0,strSend);
	 }
	 //PumpID NozzleConfig 48
	 for (i=0;i<8;i++){
	      for (j=0;j<6;j++){
   14e74:	d3 94       	inc	r13
   14e76:	0f 5f       	subi	r16, 0xFF	; 255
   14e78:	1f 4f       	sbci	r17, 0xFF	; 255
   14e7a:	f6 e0       	ldi	r31, 0x06	; 6
   14e7c:	df 16       	cp	r13, r31
   14e7e:	91 f6       	brne	.-92     	; 0x14e24 <SendConfigParamater+0x24c>
   14e80:	86 e0       	ldi	r24, 0x06	; 6
   14e82:	90 e0       	ldi	r25, 0x00	; 0
   14e84:	e8 0e       	add	r14, r24
   14e86:	f9 1e       	adc	r15, r25
	      sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
		  AddSpaceLag(strSend,2);
		 _uart_print(1,0,strSend);
	 }
	 //PumpID NozzleConfig 48
	 for (i=0;i<8;i++){
   14e88:	95 e8       	ldi	r25, 0x85	; 133
   14e8a:	e9 16       	cp	r14, r25
   14e8c:	90 e0       	ldi	r25, 0x00	; 0
   14e8e:	f9 06       	cpc	r15, r25
   14e90:	19 f0       	breq	.+6      	; 0x14e98 <SendConfigParamater+0x2c0>
   14e92:	87 01       	movw	r16, r14
   14e94:	dd 24       	eor	r13, r13
   14e96:	c6 cf       	rjmp	.-116    	; 0x14e24 <SendConfigParamater+0x24c>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   14e98:	e1 99       	sbic	0x1c, 1	; 28
   14e9a:	fe cf       	rjmp	.-4      	; 0x14e98 <SendConfigParamater+0x2c0>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   14e9c:	81 ec       	ldi	r24, 0xC1	; 193
   14e9e:	93 e0       	ldi	r25, 0x03	; 3
   14ea0:	9f bb       	out	0x1f, r25	; 31
   14ea2:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   14ea4:	e0 9a       	sbi	0x1c, 0	; 28
   14ea6:	8d b3       	in	r24, 0x1d	; 29
   14ea8:	9e 01       	movw	r18, r28
   14eaa:	26 5d       	subi	r18, 0xD6	; 214
   14eac:	3f 4f       	sbci	r19, 0xFF	; 255
			   _uart_print(1,0,strSend);
		  }
	 }
	 //PrintNoMoney
	 xEEPROM=eeprom_read_byte(&DefPrintMoney);
	 if (xEEPROM==True){
   14eae:	81 30       	cpi	r24, 0x01	; 1
   14eb0:	79 f4       	brne	.+30     	; 0x14ed0 <SendConfigParamater+0x2f8>
		 sprintf_P(strSend,PSTR("1"));
   14eb2:	00 d0       	rcall	.+0      	; 0x14eb4 <SendConfigParamater+0x2dc>
   14eb4:	00 d0       	rcall	.+0      	; 0x14eb6 <SendConfigParamater+0x2de>
   14eb6:	ad b7       	in	r26, 0x3d	; 61
   14eb8:	be b7       	in	r27, 0x3e	; 62
   14eba:	12 96       	adiw	r26, 0x02	; 2
   14ebc:	3c 93       	st	X, r19
   14ebe:	2e 93       	st	-X, r18
   14ec0:	11 97       	sbiw	r26, 0x01	; 1
   14ec2:	83 e7       	ldi	r24, 0x73	; 115
   14ec4:	92 e2       	ldi	r25, 0x22	; 34
   14ec6:	14 96       	adiw	r26, 0x04	; 4
   14ec8:	9c 93       	st	X, r25
   14eca:	8e 93       	st	-X, r24
   14ecc:	13 97       	sbiw	r26, 0x03	; 3
   14ece:	0a c0       	rjmp	.+20     	; 0x14ee4 <SendConfigParamater+0x30c>
	 }else{
	     sprintf_P(strSend,PSTR("0"));
   14ed0:	00 d0       	rcall	.+0      	; 0x14ed2 <SendConfigParamater+0x2fa>
   14ed2:	00 d0       	rcall	.+0      	; 0x14ed4 <SendConfigParamater+0x2fc>
   14ed4:	ed b7       	in	r30, 0x3d	; 61
   14ed6:	fe b7       	in	r31, 0x3e	; 62
   14ed8:	32 83       	std	Z+2, r19	; 0x02
   14eda:	21 83       	std	Z+1, r18	; 0x01
   14edc:	81 e7       	ldi	r24, 0x71	; 113
   14ede:	92 e2       	ldi	r25, 0x22	; 34
   14ee0:	94 83       	std	Z+4, r25	; 0x04
   14ee2:	83 83       	std	Z+3, r24	; 0x03
   14ee4:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
   14ee8:	0f 90       	pop	r0
   14eea:	0f 90       	pop	r0
   14eec:	0f 90       	pop	r0
   14eee:	0f 90       	pop	r0
	 }_uart_print(1,0,strSend);
   14ef0:	81 e0       	ldi	r24, 0x01	; 1
   14ef2:	60 e0       	ldi	r22, 0x00	; 0
   14ef4:	ae 01       	movw	r20, r28
   14ef6:	46 5d       	subi	r20, 0xD6	; 214
   14ef8:	5f 4f       	sbci	r21, 0xFF	; 255
   14efa:	0e 94 70 b2 	call	0x164e0	; 0x164e0 <_uart_print>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   14efe:	e1 99       	sbic	0x1c, 1	; 28
   14f00:	fe cf       	rjmp	.-4      	; 0x14efe <SendConfigParamater+0x326>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   14f02:	80 e0       	ldi	r24, 0x00	; 0
   14f04:	90 e0       	ldi	r25, 0x00	; 0
   14f06:	9f bb       	out	0x1f, r25	; 31
   14f08:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   14f0a:	e0 9a       	sbi	0x1c, 0	; 28
   14f0c:	2d b3       	in	r18, 0x1d	; 29
	 //TermId
     xEEPROM=eeprom_read_byte(&DefIFT_ID);     
     sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
   14f0e:	00 d0       	rcall	.+0      	; 0x14f10 <SendConfigParamater+0x338>
   14f10:	00 d0       	rcall	.+0      	; 0x14f12 <SendConfigParamater+0x33a>
   14f12:	00 d0       	rcall	.+0      	; 0x14f14 <SendConfigParamater+0x33c>
   14f14:	ed b7       	in	r30, 0x3d	; 61
   14f16:	fe b7       	in	r31, 0x3e	; 62
   14f18:	31 96       	adiw	r30, 0x01	; 1
   14f1a:	8e 01       	movw	r16, r28
   14f1c:	06 5d       	subi	r16, 0xD6	; 214
   14f1e:	1f 4f       	sbci	r17, 0xFF	; 255
   14f20:	ad b7       	in	r26, 0x3d	; 61
   14f22:	be b7       	in	r27, 0x3e	; 62
   14f24:	12 96       	adiw	r26, 0x02	; 2
   14f26:	1c 93       	st	X, r17
   14f28:	0e 93       	st	-X, r16
   14f2a:	11 97       	sbiw	r26, 0x01	; 1
   14f2c:	8c e6       	ldi	r24, 0x6C	; 108
   14f2e:	92 e2       	ldi	r25, 0x22	; 34
   14f30:	93 83       	std	Z+3, r25	; 0x03
   14f32:	82 83       	std	Z+2, r24	; 0x02
   14f34:	24 83       	std	Z+4, r18	; 0x04
   14f36:	15 82       	std	Z+5, r1	; 0x05
   14f38:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
     _uart_print(1,0,strSend);
   14f3c:	ed b7       	in	r30, 0x3d	; 61
   14f3e:	fe b7       	in	r31, 0x3e	; 62
   14f40:	36 96       	adiw	r30, 0x06	; 6
   14f42:	0f b6       	in	r0, 0x3f	; 63
   14f44:	f8 94       	cli
   14f46:	fe bf       	out	0x3e, r31	; 62
   14f48:	0f be       	out	0x3f, r0	; 63
   14f4a:	ed bf       	out	0x3d, r30	; 61
   14f4c:	81 e0       	ldi	r24, 0x01	; 1
   14f4e:	60 e0       	ldi	r22, 0x00	; 0
   14f50:	a8 01       	movw	r20, r16
   14f52:	0e 94 70 b2 	call	0x164e0	; 0x164e0 <_uart_print>
   14f56:	2d e4       	ldi	r18, 0x4D	; 77
   14f58:	e2 2e       	mov	r14, r18
   14f5a:	20 e0       	ldi	r18, 0x00	; 0
   14f5c:	f2 2e       	mov	r15, r18
	 //PumpLabel
     for (i=0;i<8;i++){
	      xEEPROM=eeprom_read_byte(&DefPumpLabel[i]);
		  if (xEEPROM>=100)xEEPROM=0;
		  FillChar(strSend,0,sizeof(strSend));
	      sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
   14f5e:	d0 2e       	mov	r13, r16
   14f60:	01 2f       	mov	r16, r17
   14f62:	97 e6       	ldi	r25, 0x67	; 103
   14f64:	a9 2e       	mov	r10, r25
   14f66:	92 e2       	ldi	r25, 0x22	; 34
   14f68:	b9 2e       	mov	r11, r25
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   14f6a:	e1 99       	sbic	0x1c, 1	; 28
   14f6c:	fe cf       	rjmp	.-4      	; 0x14f6a <SendConfigParamater+0x392>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   14f6e:	ff ba       	out	0x1f, r15	; 31
   14f70:	ee ba       	out	0x1e, r14	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   14f72:	e0 9a       	sbi	0x1c, 0	; 28
   14f74:	8d b3       	in	r24, 0x1d	; 29
     sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
     _uart_print(1,0,strSend);
	 //PumpLabel
     for (i=0;i<8;i++){
	      xEEPROM=eeprom_read_byte(&DefPumpLabel[i]);
		  if (xEEPROM>=100)xEEPROM=0;
   14f76:	84 36       	cpi	r24, 0x64	; 100
   14f78:	08 f0       	brcs	.+2      	; 0x14f7c <SendConfigParamater+0x3a4>
   14f7a:	80 e0       	ldi	r24, 0x00	; 0
		  FillChar(strSend,0,sizeof(strSend));
	      sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
   14f7c:	00 d0       	rcall	.+0      	; 0x14f7e <SendConfigParamater+0x3a6>
   14f7e:	00 d0       	rcall	.+0      	; 0x14f80 <SendConfigParamater+0x3a8>
   14f80:	00 d0       	rcall	.+0      	; 0x14f82 <SendConfigParamater+0x3aa>
   14f82:	ed b7       	in	r30, 0x3d	; 61
   14f84:	fe b7       	in	r31, 0x3e	; 62
   14f86:	31 96       	adiw	r30, 0x01	; 1
   14f88:	ad b7       	in	r26, 0x3d	; 61
   14f8a:	be b7       	in	r27, 0x3e	; 62
   14f8c:	11 96       	adiw	r26, 0x01	; 1
   14f8e:	dc 92       	st	X, r13
   14f90:	11 97       	sbiw	r26, 0x01	; 1
   14f92:	12 96       	adiw	r26, 0x02	; 2
   14f94:	0c 93       	st	X, r16
   14f96:	b3 82       	std	Z+3, r11	; 0x03
   14f98:	a2 82       	std	Z+2, r10	; 0x02
   14f9a:	84 83       	std	Z+4, r24	; 0x04
   14f9c:	15 82       	std	Z+5, r1	; 0x05
   14f9e:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
		  AddSpaceLag(strSend,2);
   14fa2:	ed b7       	in	r30, 0x3d	; 61
   14fa4:	fe b7       	in	r31, 0x3e	; 62
   14fa6:	36 96       	adiw	r30, 0x06	; 6
   14fa8:	0f b6       	in	r0, 0x3f	; 63
   14faa:	f8 94       	cli
   14fac:	fe bf       	out	0x3e, r31	; 62
   14fae:	0f be       	out	0x3f, r0	; 63
   14fb0:	ed bf       	out	0x3d, r30	; 61
   14fb2:	8d 2d       	mov	r24, r13
   14fb4:	90 2f       	mov	r25, r16
   14fb6:	62 e0       	ldi	r22, 0x02	; 2
   14fb8:	0e 94 a0 2d 	call	0x5b40	; 0x5b40 <AddSpaceLag>
		 _uart_print(1,0,strSend);
   14fbc:	81 e0       	ldi	r24, 0x01	; 1
   14fbe:	60 e0       	ldi	r22, 0x00	; 0
   14fc0:	4d 2d       	mov	r20, r13
   14fc2:	50 2f       	mov	r21, r16
   14fc4:	0e 94 70 b2 	call	0x164e0	; 0x164e0 <_uart_print>
   14fc8:	08 94       	sec
   14fca:	e1 1c       	adc	r14, r1
   14fcc:	f1 1c       	adc	r15, r1
	 //TermId
     xEEPROM=eeprom_read_byte(&DefIFT_ID);     
     sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
     _uart_print(1,0,strSend);
	 //PumpLabel
     for (i=0;i<8;i++){
   14fce:	f5 e5       	ldi	r31, 0x55	; 85
   14fd0:	ef 16       	cp	r14, r31
   14fd2:	f0 e0       	ldi	r31, 0x00	; 0
   14fd4:	ff 06       	cpc	r15, r31
   14fd6:	49 f6       	brne	.-110    	; 0x14f6a <SendConfigParamater+0x392>
		  FillChar(strSend,0,sizeof(strSend));
	      sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
		  AddSpaceLag(strSend,2);
		 _uart_print(1,0,strSend);
	 }
	 _uart_printf(1,1,PSTR(">"));
   14fd8:	81 e0       	ldi	r24, 0x01	; 1
   14fda:	61 e0       	ldi	r22, 0x01	; 1
   14fdc:	45 e6       	ldi	r20, 0x65	; 101
   14fde:	52 e2       	ldi	r21, 0x22	; 34
   14fe0:	0e 94 98 b2 	call	0x16530	; 0x16530 <_uart_printf>
	 //End
}
   14fe4:	cb 59       	subi	r28, 0x9B	; 155
   14fe6:	df 4f       	sbci	r29, 0xFF	; 255
   14fe8:	0f b6       	in	r0, 0x3f	; 63
   14fea:	f8 94       	cli
   14fec:	de bf       	out	0x3e, r29	; 62
   14fee:	0f be       	out	0x3f, r0	; 63
   14ff0:	cd bf       	out	0x3d, r28	; 61
   14ff2:	cf 91       	pop	r28
   14ff4:	df 91       	pop	r29
   14ff6:	1f 91       	pop	r17
   14ff8:	0f 91       	pop	r16
   14ffa:	ff 90       	pop	r15
   14ffc:	ef 90       	pop	r14
   14ffe:	df 90       	pop	r13
   15000:	cf 90       	pop	r12
   15002:	bf 90       	pop	r11
   15004:	af 90       	pop	r10
   15006:	9f 90       	pop	r9
   15008:	8f 90       	pop	r8
   1500a:	08 95       	ret

0001500c <SaveConfigParameter>:
     char Result;
	 Result=False;
   return Result;
}

void SaveConfigParameter(){
   1500c:	8f 92       	push	r8
   1500e:	9f 92       	push	r9
   15010:	af 92       	push	r10
   15012:	bf 92       	push	r11
   15014:	cf 92       	push	r12
   15016:	df 92       	push	r13
   15018:	ef 92       	push	r14
   1501a:	ff 92       	push	r15
   1501c:	0f 93       	push	r16
   1501e:	1f 93       	push	r17
   15020:	df 93       	push	r29
   15022:	cf 93       	push	r28
   15024:	cd b7       	in	r28, 0x3d	; 61
   15026:	de b7       	in	r29, 0x3e	; 62
   15028:	c6 54       	subi	r28, 0x46	; 70
   1502a:	d0 40       	sbci	r29, 0x00	; 0
   1502c:	0f b6       	in	r0, 0x3f	; 63
   1502e:	f8 94       	cli
   15030:	de bf       	out	0x3e, r29	; 62
   15032:	0f be       	out	0x3f, r0	; 63
   15034:	cd bf       	out	0x3d, r28	; 61
char i,j;
char strEEPROM[50],xEEPROM;
unsigned int StrPos;
char strSend[20];
     
	 sprintf_P(strSend,PSTR("Length:%d"),transLength);
   15036:	00 d0       	rcall	.+0      	; 0x15038 <SaveConfigParameter+0x2c>
   15038:	00 d0       	rcall	.+0      	; 0x1503a <SaveConfigParameter+0x2e>
   1503a:	00 d0       	rcall	.+0      	; 0x1503c <SaveConfigParameter+0x30>
   1503c:	ed b7       	in	r30, 0x3d	; 61
   1503e:	fe b7       	in	r31, 0x3e	; 62
   15040:	31 96       	adiw	r30, 0x01	; 1
   15042:	8e 01       	movw	r16, r28
   15044:	0f 5f       	subi	r16, 0xFF	; 255
   15046:	1f 4f       	sbci	r17, 0xFF	; 255
   15048:	ad b7       	in	r26, 0x3d	; 61
   1504a:	be b7       	in	r27, 0x3e	; 62
   1504c:	12 96       	adiw	r26, 0x02	; 2
   1504e:	1c 93       	st	X, r17
   15050:	0e 93       	st	-X, r16
   15052:	11 97       	sbiw	r26, 0x01	; 1
   15054:	8f e9       	ldi	r24, 0x9F	; 159
   15056:	92 e2       	ldi	r25, 0x22	; 34
   15058:	93 83       	std	Z+3, r25	; 0x03
   1505a:	82 83       	std	Z+2, r24	; 0x02
   1505c:	80 91 8e 01 	lds	r24, 0x018E
   15060:	90 91 8f 01 	lds	r25, 0x018F
   15064:	95 83       	std	Z+5, r25	; 0x05
   15066:	84 83       	std	Z+4, r24	; 0x04
   15068:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
	 _uart_print(1,1,strSend);
   1506c:	ed b7       	in	r30, 0x3d	; 61
   1506e:	fe b7       	in	r31, 0x3e	; 62
   15070:	36 96       	adiw	r30, 0x06	; 6
   15072:	0f b6       	in	r0, 0x3f	; 63
   15074:	f8 94       	cli
   15076:	fe bf       	out	0x3e, r31	; 62
   15078:	0f be       	out	0x3f, r0	; 63
   1507a:	ed bf       	out	0x3d, r30	; 61
   1507c:	81 e0       	ldi	r24, 0x01	; 1
   1507e:	61 e0       	ldi	r22, 0x01	; 1
   15080:	a8 01       	movw	r20, r16
   15082:	0e 94 70 b2 	call	0x164e0	; 0x164e0 <_uart_print>

     StrPos=0;
	 _uart_printf(1,1,PSTR("<Saving>")); 
   15086:	81 e0       	ldi	r24, 0x01	; 1
   15088:	61 e0       	ldi	r22, 0x01	; 1
   1508a:	46 e9       	ldi	r20, 0x96	; 150
   1508c:	52 e2       	ldi	r21, 0x22	; 34
   1508e:	0e 94 98 b2 	call	0x16530	; 0x16530 <_uart_printf>
   15092:	07 e2       	ldi	r16, 0x27	; 39
   15094:	12 e0       	ldi	r17, 0x02	; 2
   15096:	41 e5       	ldi	r20, 0x51	; 81
   15098:	e4 2e       	mov	r14, r20
   1509a:	4a e0       	ldi	r20, 0x0A	; 10
   1509c:	f4 2e       	mov	r15, r20
   1509e:	35 e1       	ldi	r19, 0x15	; 21
   150a0:	a3 2e       	mov	r10, r19
   150a2:	b1 2c       	mov	r11, r1
   150a4:	ac 0e       	add	r10, r28
   150a6:	bd 1e       	adc	r11, r29
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   150a8:	2d e3       	ldi	r18, 0x3D	; 61
   150aa:	c2 2e       	mov	r12, r18
   150ac:	d1 2c       	mov	r13, r1
   150ae:	cc 0e       	add	r12, r28
   150b0:	dd 1e       	adc	r13, r29
     
	 sprintf_P(strSend,PSTR("Length:%d"),transLength);
	 _uart_print(1,1,strSend);

     StrPos=0;
	 _uart_printf(1,1,PSTR("<Saving>")); 
   150b2:	d7 01       	movw	r26, r14
   150b4:	f5 01       	movw	r30, r10
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   150b6:	8d 91       	ld	r24, X+
   150b8:	81 93       	st	Z+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   150ba:	ec 15       	cp	r30, r12
   150bc:	fd 05       	cpc	r31, r13
   150be:	d9 f7       	brne	.-10     	; 0x150b6 <SaveConfigParameter+0xaa>
	 _uart_printf(1,1,PSTR("<Saving>")); 
     //HeaderFooter
	 for(i=0;i<10;i++){
         FillChar(strEEPROM,0,sizeof(strEEPROM));   
		 StrPosCopy(rcv_trans,strEEPROM,(StrPos+(40*i)),40);
		 strEEPROM[40]=0;
   150c0:	1d ae       	std	Y+61, r1	; 0x3d
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
   150c2:	c8 01       	movw	r24, r16
   150c4:	b5 01       	movw	r22, r10
   150c6:	49 e2       	ldi	r20, 0x29	; 41
   150c8:	50 e0       	ldi	r21, 0x00	; 0
   150ca:	25 e0       	ldi	r18, 0x05	; 5
   150cc:	33 e1       	ldi	r19, 0x13	; 19
   150ce:	0e 94 0d b4 	call	0x1681a	; 0x1681a <__eewr_block>
   150d2:	07 5d       	subi	r16, 0xD7	; 215
   150d4:	1f 4f       	sbci	r17, 0xFF	; 255
   150d6:	88 e2       	ldi	r24, 0x28	; 40
   150d8:	90 e0       	ldi	r25, 0x00	; 0
   150da:	e8 0e       	add	r14, r24
   150dc:	f9 1e       	adc	r15, r25
	 _uart_print(1,1,strSend);

     StrPos=0;
	 _uart_printf(1,1,PSTR("<Saving>")); 
     //HeaderFooter
	 for(i=0;i<10;i++){
   150de:	93 e0       	ldi	r25, 0x03	; 3
   150e0:	01 3c       	cpi	r16, 0xC1	; 193
   150e2:	19 07       	cpc	r17, r25
   150e4:	31 f7       	brne	.-52     	; 0x150b2 <SaveConfigParameter+0xa6>
   150e6:	0b eb       	ldi	r16, 0xBB	; 187
   150e8:	10 e0       	ldi	r17, 0x00	; 0
   150ea:	91 ee       	ldi	r25, 0xE1	; 225
   150ec:	e9 2e       	mov	r14, r25
   150ee:	9b e0       	ldi	r25, 0x0B	; 11
   150f0:	f9 2e       	mov	r15, r25
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   150f2:	85 e1       	ldi	r24, 0x15	; 21
   150f4:	c8 2e       	mov	r12, r24
   150f6:	d1 2c       	mov	r13, r1
   150f8:	cc 0e       	add	r12, r28
   150fa:	dd 1e       	adc	r13, r29
   150fc:	b1 e2       	ldi	r27, 0x21	; 33
   150fe:	8b 2e       	mov	r8, r27
   15100:	91 2c       	mov	r9, r1
   15102:	8c 0e       	add	r8, r28
   15104:	9d 1e       	adc	r9, r29
	 _uart_print(1,1,strSend);

     StrPos=0;
	 _uart_printf(1,1,PSTR("<Saving>")); 
     //HeaderFooter
	 for(i=0;i<10;i++){
   15106:	d7 01       	movw	r26, r14
   15108:	f5 01       	movw	r30, r10
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   1510a:	8d 91       	ld	r24, X+
   1510c:	81 93       	st	Z+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   1510e:	e8 15       	cp	r30, r8
   15110:	f9 05       	cpc	r31, r9
   15112:	d9 f7       	brne	.-10     	; 0x1510a <SaveConfigParameter+0xfe>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   15114:	19 a2       	std	Y+33, r1	; 0x21
	 //ProductName
	 StrPos=(40*10);
	 for(i=0;i<6;i++){
         FillChar(strEEPROM,0,sizeof(strEEPROM));   
		 StrPosCopy(rcv_trans,strEEPROM,(StrPos+(12*i)),12);
		 RemSpaceLag(strEEPROM);
   15116:	c6 01       	movw	r24, r12
   15118:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <RemSpaceLag>
		 strEEPROM[strlen(strEEPROM)]=0;
   1511c:	f6 01       	movw	r30, r12
   1511e:	01 90       	ld	r0, Z+
   15120:	00 20       	and	r0, r0
   15122:	e9 f7       	brne	.-6      	; 0x1511e <SaveConfigParameter+0x112>
   15124:	31 97       	sbiw	r30, 0x01	; 1
   15126:	10 82       	st	Z, r1
   15128:	c8 01       	movw	r24, r16
   1512a:	b6 01       	movw	r22, r12
   1512c:	4d e0       	ldi	r20, 0x0D	; 13
   1512e:	50 e0       	ldi	r21, 0x00	; 0
   15130:	25 e0       	ldi	r18, 0x05	; 5
   15132:	33 e1       	ldi	r19, 0x13	; 19
   15134:	0e 94 0d b4 	call	0x1681a	; 0x1681a <__eewr_block>
   15138:	03 5f       	subi	r16, 0xF3	; 243
   1513a:	1f 4f       	sbci	r17, 0xFF	; 255
   1513c:	ac e0       	ldi	r26, 0x0C	; 12
   1513e:	b0 e0       	ldi	r27, 0x00	; 0
   15140:	ea 0e       	add	r14, r26
   15142:	fb 1e       	adc	r15, r27
		 eeprom_write_block((const void*) &strEEPROM, (void*) &DefHeaderFooter[i],41);
		 //_uart_print(1,1,strEEPROM);
	 }
	 //ProductName
	 StrPos=(40*10);
	 for(i=0;i<6;i++){
   15144:	b1 e0       	ldi	r27, 0x01	; 1
   15146:	09 30       	cpi	r16, 0x09	; 9
   15148:	1b 07       	cpc	r17, r27
   1514a:	e9 f6       	brne	.-70     	; 0x15106 <SaveConfigParameter+0xfa>
   1514c:	05 e8       	ldi	r16, 0x85	; 133
   1514e:	10 e0       	ldi	r17, 0x00	; 0
   15150:	a9 e2       	ldi	r26, 0x29	; 41
   15152:	ea 2e       	mov	r14, r26
   15154:	ac e0       	ldi	r26, 0x0C	; 12
   15156:	fa 2e       	mov	r15, r26
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   15158:	f5 e1       	ldi	r31, 0x15	; 21
   1515a:	cf 2e       	mov	r12, r31
   1515c:	d1 2c       	mov	r13, r1
   1515e:	cc 0e       	add	r12, r28
   15160:	dd 1e       	adc	r13, r29
   15162:	ea e1       	ldi	r30, 0x1A	; 26
   15164:	8e 2e       	mov	r8, r30
   15166:	91 2c       	mov	r9, r1
   15168:	8c 0e       	add	r8, r28
   1516a:	9d 1e       	adc	r9, r29
		 eeprom_write_block((const void*) &strEEPROM, (void*) &DefHeaderFooter[i],41);
		 //_uart_print(1,1,strEEPROM);
	 }
	 //ProductName
	 StrPos=(40*10);
	 for(i=0;i<6;i++){
   1516c:	d7 01       	movw	r26, r14
   1516e:	f5 01       	movw	r30, r10
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   15170:	8d 91       	ld	r24, X+
   15172:	81 93       	st	Z+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   15174:	e8 15       	cp	r30, r8
   15176:	f9 05       	cpc	r31, r9
   15178:	d9 f7       	brne	.-10     	; 0x15170 <SaveConfigParameter+0x164>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   1517a:	1a 8e       	std	Y+26, r1	; 0x1a
	 //ProductPrice
	 StrPos=(40*10)+(12*6);
	 for(i=0;i<6;i++){
         FillChar(strEEPROM,0,sizeof(strEEPROM));   
		 StrPosCopy(rcv_trans,strEEPROM,(StrPos+(5*i)),5);
		 RemSpaceLag(strEEPROM);
   1517c:	c6 01       	movw	r24, r12
   1517e:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <RemSpaceLag>
   15182:	c8 01       	movw	r24, r16
   15184:	b6 01       	movw	r22, r12
   15186:	49 e0       	ldi	r20, 0x09	; 9
   15188:	50 e0       	ldi	r21, 0x00	; 0
   1518a:	25 e0       	ldi	r18, 0x05	; 5
   1518c:	33 e1       	ldi	r19, 0x13	; 19
   1518e:	0e 94 0d b4 	call	0x1681a	; 0x1681a <__eewr_block>
   15192:	07 5f       	subi	r16, 0xF7	; 247
   15194:	1f 4f       	sbci	r17, 0xFF	; 255
   15196:	e5 e0       	ldi	r30, 0x05	; 5
   15198:	f0 e0       	ldi	r31, 0x00	; 0
   1519a:	ee 0e       	add	r14, r30
   1519c:	ff 1e       	adc	r15, r31
		// _uart_print(1,1,strEEPROM);

	 }    
	 //ProductPrice
	 StrPos=(40*10)+(12*6);
	 for(i=0;i<6;i++){
   1519e:	f0 e0       	ldi	r31, 0x00	; 0
   151a0:	0b 3b       	cpi	r16, 0xBB	; 187
   151a2:	1f 07       	cpc	r17, r31
   151a4:	19 f7       	brne	.-58     	; 0x1516c <SaveConfigParameter+0x160>
   151a6:	07 e4       	ldi	r16, 0x47	; 71
   151a8:	1c e0       	ldi	r17, 0x0C	; 12
   151aa:	75 e4       	ldi	r23, 0x45	; 69
   151ac:	e7 2e       	mov	r14, r23
   151ae:	70 e0       	ldi	r23, 0x00	; 0
   151b0:	f7 2e       	mov	r15, r23
	 //PumpID Config
	 StrPos=(40*10)+(12*6)+(5*6);
	 for(i=0;i<8;i++){
         FillChar(strEEPROM,0,sizeof(strEEPROM));   
		 StrPosCopy(rcv_trans,strEEPROM,(StrPos+(2*i)),2);
		 RemZeroLead(strEEPROM);
   151b2:	65 e1       	ldi	r22, 0x15	; 21
   151b4:	c6 2e       	mov	r12, r22
   151b6:	d1 2c       	mov	r13, r1
   151b8:	cc 0e       	add	r12, r28
   151ba:	dd 1e       	adc	r13, r29
		 xEEPROM=atoi(strEEPROM);
         eeprom_write_byte(&DefPumpMap[i],xEEPROM);
		 sprintf_P(strSend,PSTR("%d"),xEEPROM);
   151bc:	4e 01       	movw	r8, r28
   151be:	08 94       	sec
   151c0:	81 1c       	adc	r8, r1
   151c2:	91 1c       	adc	r9, r1
   151c4:	53 e9       	ldi	r21, 0x93	; 147
   151c6:	a5 2e       	mov	r10, r21
   151c8:	52 e2       	ldi	r21, 0x22	; 34
   151ca:	b5 2e       	mov	r11, r21
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   151cc:	d8 01       	movw	r26, r16
   151ce:	8c 91       	ld	r24, X
   151d0:	8d 8b       	std	Y+21, r24	; 0x15
   151d2:	11 96       	adiw	r26, 0x01	; 1
   151d4:	8c 91       	ld	r24, X
   151d6:	8e 8b       	std	Y+22, r24	; 0x16
	 }Dest[Length]=0;
   151d8:	1f 8a       	std	Y+23, r1	; 0x17
	 //PumpID Config
	 StrPos=(40*10)+(12*6)+(5*6);
	 for(i=0;i<8;i++){
         FillChar(strEEPROM,0,sizeof(strEEPROM));   
		 StrPosCopy(rcv_trans,strEEPROM,(StrPos+(2*i)),2);
		 RemZeroLead(strEEPROM);
   151da:	c6 01       	movw	r24, r12
   151dc:	0e 94 19 25 	call	0x4a32	; 0x4a32 <RemZeroLead>
		 xEEPROM=atoi(strEEPROM);
   151e0:	c6 01       	movw	r24, r12
   151e2:	0e 94 c3 b3 	call	0x16786	; 0x16786 <atoi>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   151e6:	e1 99       	sbic	0x1c, 1	; 28
   151e8:	fe cf       	rjmp	.-4      	; 0x151e6 <SaveConfigParameter+0x1da>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   151ea:	ff ba       	out	0x1f, r15	; 31
   151ec:	ee ba       	out	0x1e, r14	; 30
#endif
    EEDR = __value;
   151ee:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
   151f0:	0f b6       	in	r0, 0x3f	; 63
   151f2:	f8 94       	cli
   151f4:	e2 9a       	sbi	0x1c, 2	; 28
   151f6:	e1 9a       	sbi	0x1c, 1	; 28
   151f8:	0f be       	out	0x3f, r0	; 63
         eeprom_write_byte(&DefPumpMap[i],xEEPROM);
		 sprintf_P(strSend,PSTR("%d"),xEEPROM);
   151fa:	00 d0       	rcall	.+0      	; 0x151fc <SaveConfigParameter+0x1f0>
   151fc:	00 d0       	rcall	.+0      	; 0x151fe <SaveConfigParameter+0x1f2>
   151fe:	00 d0       	rcall	.+0      	; 0x15200 <SaveConfigParameter+0x1f4>
   15200:	ed b7       	in	r30, 0x3d	; 61
   15202:	fe b7       	in	r31, 0x3e	; 62
   15204:	31 96       	adiw	r30, 0x01	; 1
   15206:	ad b7       	in	r26, 0x3d	; 61
   15208:	be b7       	in	r27, 0x3e	; 62
   1520a:	12 96       	adiw	r26, 0x02	; 2
   1520c:	9c 92       	st	X, r9
   1520e:	8e 92       	st	-X, r8
   15210:	11 97       	sbiw	r26, 0x01	; 1
   15212:	b3 82       	std	Z+3, r11	; 0x03
   15214:	a2 82       	std	Z+2, r10	; 0x02
   15216:	84 83       	std	Z+4, r24	; 0x04
   15218:	15 82       	std	Z+5, r1	; 0x05
   1521a:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
   1521e:	0e 5f       	subi	r16, 0xFE	; 254
   15220:	1f 4f       	sbci	r17, 0xFF	; 255
   15222:	08 94       	sec
   15224:	e1 1c       	adc	r14, r1
   15226:	f1 1c       	adc	r15, r1
		// _uart_print(1,1,strEEPROM);

	 }    
	 //PumpID Config
	 StrPos=(40*10)+(12*6)+(5*6);
	 for(i=0;i<8;i++){
   15228:	ed b7       	in	r30, 0x3d	; 61
   1522a:	fe b7       	in	r31, 0x3e	; 62
   1522c:	36 96       	adiw	r30, 0x06	; 6
   1522e:	0f b6       	in	r0, 0x3f	; 63
   15230:	f8 94       	cli
   15232:	fe bf       	out	0x3e, r31	; 62
   15234:	0f be       	out	0x3f, r0	; 63
   15236:	ed bf       	out	0x3d, r30	; 61
   15238:	fc e0       	ldi	r31, 0x0C	; 12
   1523a:	07 35       	cpi	r16, 0x57	; 87
   1523c:	1f 07       	cpc	r17, r31
   1523e:	09 f0       	breq	.+2      	; 0x15242 <SaveConfigParameter+0x236>
   15240:	c5 cf       	rjmp	.-118    	; 0x151cc <SaveConfigParameter+0x1c0>
   15242:	45 e5       	ldi	r20, 0x55	; 85
   15244:	50 e0       	ldi	r21, 0x00	; 0
   15246:	b8 01       	movw	r22, r16
   15248:	1d c0       	rjmp	.+58     	; 0x15284 <SaveConfigParameter+0x278>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
   1524a:	90 81       	ld	r25, Z
   1524c:	90 53       	subi	r25, 0x30	; 48
   1524e:	9a 30       	cpi	r25, 0x0A	; 10
   15250:	08 f0       	brcs	.+2      	; 0x15254 <SaveConfigParameter+0x248>
   15252:	90 e0       	ldi	r25, 0x00	; 0
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   15254:	e1 99       	sbic	0x1c, 1	; 28
   15256:	fe cf       	rjmp	.-4      	; 0x15254 <SaveConfigParameter+0x248>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   15258:	3f bb       	out	0x1f, r19	; 31
   1525a:	2e bb       	out	0x1e, r18	; 30
#endif
    EEDR = __value;
   1525c:	9d bb       	out	0x1d, r25	; 29

    __asm__ __volatile__ (
   1525e:	0f b6       	in	r0, 0x3f	; 63
   15260:	f8 94       	cli
   15262:	e2 9a       	sbi	0x1c, 2	; 28
   15264:	e1 9a       	sbi	0x1c, 1	; 28
   15266:	0f be       	out	0x3f, r0	; 63

	 }    
	 //PumpNozzle
	 StrPos=(40*10)+(12*6)+(5*6)+(2*8);
	 for (i=0;i<8;i++){
	     for (j=0;j<6;j++){
   15268:	8f 5f       	subi	r24, 0xFF	; 255
   1526a:	31 96       	adiw	r30, 0x01	; 1
   1526c:	2f 5f       	subi	r18, 0xFF	; 255
   1526e:	3f 4f       	sbci	r19, 0xFF	; 255
   15270:	86 30       	cpi	r24, 0x06	; 6
   15272:	59 f7       	brne	.-42     	; 0x1524a <SaveConfigParameter+0x23e>
   15274:	4a 5f       	subi	r20, 0xFA	; 250
   15276:	5f 4f       	sbci	r21, 0xFF	; 255
   15278:	6a 5f       	subi	r22, 0xFA	; 250
   1527a:	7f 4f       	sbci	r23, 0xFF	; 255
		// _uart_print(1,1,strSend); 

	 }    
	 //PumpNozzle
	 StrPos=(40*10)+(12*6)+(5*6)+(2*8);
	 for (i=0;i<8;i++){
   1527c:	80 e0       	ldi	r24, 0x00	; 0
   1527e:	45 38       	cpi	r20, 0x85	; 133
   15280:	58 07       	cpc	r21, r24
   15282:	21 f0       	breq	.+8      	; 0x1528c <SaveConfigParameter+0x280>
   15284:	fb 01       	movw	r30, r22
   15286:	9a 01       	movw	r18, r20
   15288:	80 e0       	ldi	r24, 0x00	; 0
   1528a:	df cf       	rjmp	.-66     	; 0x1524a <SaveConfigParameter+0x23e>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
   1528c:	80 91 87 0c 	lds	r24, 0x0C87
   15290:	80 53       	subi	r24, 0x30	; 48
   15292:	8a 30       	cpi	r24, 0x0A	; 10
   15294:	10 f0       	brcs	.+4      	; 0x1529a <SaveConfigParameter+0x28e>
   15296:	20 e0       	ldi	r18, 0x00	; 0
   15298:	03 c0       	rjmp	.+6      	; 0x152a0 <SaveConfigParameter+0x294>
   1529a:	81 11       	cpse	r24, r1
   1529c:	81 e0       	ldi	r24, 0x01	; 1
   1529e:	28 2f       	mov	r18, r24
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   152a0:	e1 99       	sbic	0x1c, 1	; 28
   152a2:	fe cf       	rjmp	.-4      	; 0x152a0 <SaveConfigParameter+0x294>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   152a4:	81 ec       	ldi	r24, 0xC1	; 193
   152a6:	93 e0       	ldi	r25, 0x03	; 3
   152a8:	9f bb       	out	0x1f, r25	; 31
   152aa:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
   152ac:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
   152ae:	0f b6       	in	r0, 0x3f	; 63
   152b0:	f8 94       	cli
   152b2:	e2 9a       	sbi	0x1c, 2	; 28
   152b4:	e1 9a       	sbi	0x1c, 1	; 28
   152b6:	0f be       	out	0x3f, r0	; 63
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   152b8:	80 91 88 0c 	lds	r24, 0x0C88
   152bc:	8d 8b       	std	Y+21, r24	; 0x15
   152be:	80 91 89 0c 	lds	r24, 0x0C89
   152c2:	8e 8b       	std	Y+22, r24	; 0x16
	 }Dest[Length]=0;
   152c4:	1f 8a       	std	Y+23, r1	; 0x17

	 //TermID
	 StrPos=(40*10)+(12*6)+(5*6)+(2*8)+(6*8)+1;
     FillChar(strEEPROM,0,sizeof(strEEPROM));   
	 StrPosCopy(rcv_trans,strEEPROM,StrPos,2);
	 RemZeroLead(strEEPROM);
   152c6:	8e 01       	movw	r16, r28
   152c8:	0b 5e       	subi	r16, 0xEB	; 235
   152ca:	1f 4f       	sbci	r17, 0xFF	; 255
   152cc:	c8 01       	movw	r24, r16
   152ce:	0e 94 19 25 	call	0x4a32	; 0x4a32 <RemZeroLead>
	 xEEPROM=atoi(strEEPROM);
   152d2:	c8 01       	movw	r24, r16
   152d4:	0e 94 c3 b3 	call	0x16786	; 0x16786 <atoi>
   152d8:	28 2f       	mov	r18, r24
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   152da:	e1 99       	sbic	0x1c, 1	; 28
   152dc:	fe cf       	rjmp	.-4      	; 0x152da <SaveConfigParameter+0x2ce>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   152de:	80 e0       	ldi	r24, 0x00	; 0
   152e0:	90 e0       	ldi	r25, 0x00	; 0
   152e2:	9f bb       	out	0x1f, r25	; 31
   152e4:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
   152e6:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
   152e8:	0f b6       	in	r0, 0x3f	; 63
   152ea:	f8 94       	cli
   152ec:	e2 9a       	sbi	0x1c, 2	; 28
   152ee:	e1 9a       	sbi	0x1c, 1	; 28
   152f0:	0f be       	out	0x3f, r0	; 63
	 eeprom_write_byte(&DefIFT_ID,xEEPROM);
	 sprintf_P(strSend,PSTR("%d"),xEEPROM);
   152f2:	00 d0       	rcall	.+0      	; 0x152f4 <SaveConfigParameter+0x2e8>
   152f4:	00 d0       	rcall	.+0      	; 0x152f6 <SaveConfigParameter+0x2ea>
   152f6:	00 d0       	rcall	.+0      	; 0x152f8 <SaveConfigParameter+0x2ec>
   152f8:	ed b7       	in	r30, 0x3d	; 61
   152fa:	fe b7       	in	r31, 0x3e	; 62
   152fc:	31 96       	adiw	r30, 0x01	; 1
   152fe:	8e 01       	movw	r16, r28
   15300:	0f 5f       	subi	r16, 0xFF	; 255
   15302:	1f 4f       	sbci	r17, 0xFF	; 255
   15304:	ad b7       	in	r26, 0x3d	; 61
   15306:	be b7       	in	r27, 0x3e	; 62
   15308:	12 96       	adiw	r26, 0x02	; 2
   1530a:	1c 93       	st	X, r17
   1530c:	0e 93       	st	-X, r16
   1530e:	11 97       	sbiw	r26, 0x01	; 1
   15310:	80 e9       	ldi	r24, 0x90	; 144
   15312:	92 e2       	ldi	r25, 0x22	; 34
   15314:	93 83       	std	Z+3, r25	; 0x03
   15316:	82 83       	std	Z+2, r24	; 0x02
   15318:	24 83       	std	Z+4, r18	; 0x04
   1531a:	15 82       	std	Z+5, r1	; 0x05
   1531c:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
   15320:	4a e8       	ldi	r20, 0x8A	; 138
   15322:	e4 2e       	mov	r14, r20
   15324:	4c e0       	ldi	r20, 0x0C	; 12
   15326:	f4 2e       	mov	r15, r20
   15328:	3d e4       	ldi	r19, 0x4D	; 77
   1532a:	c3 2e       	mov	r12, r19
   1532c:	30 e0       	ldi	r19, 0x00	; 0
   1532e:	d3 2e       	mov	r13, r19
   15330:	ed b7       	in	r30, 0x3d	; 61
   15332:	fe b7       	in	r31, 0x3e	; 62
   15334:	36 96       	adiw	r30, 0x06	; 6
   15336:	0f b6       	in	r0, 0x3f	; 63
   15338:	f8 94       	cli
   1533a:	fe bf       	out	0x3e, r31	; 62
   1533c:	0f be       	out	0x3f, r0	; 63
   1533e:	ed bf       	out	0x3d, r30	; 61
	 //PumpLabel
	 StrPos=(40*10)+(12*6)+(5*6)+(2*8)+(6*8)+1+2;
	 for(i=0;i<8;i++){
         FillChar(strEEPROM,0,sizeof(strEEPROM));   
		 StrPosCopy(rcv_trans,strEEPROM,(StrPos+(2*i)),2);
		 RemZeroLead(strEEPROM);
   15340:	25 e1       	ldi	r18, 0x15	; 21
   15342:	a2 2e       	mov	r10, r18
   15344:	b1 2c       	mov	r11, r1
   15346:	ac 0e       	add	r10, r28
   15348:	bd 1e       	adc	r11, r29
		 xEEPROM=atoi(strEEPROM);
         eeprom_write_byte(&DefPumpLabel[i],xEEPROM);
		 sprintf_P(strSend,PSTR("%d"),xEEPROM);
   1534a:	48 01       	movw	r8, r16
   1534c:	0d e8       	ldi	r16, 0x8D	; 141
   1534e:	12 e2       	ldi	r17, 0x22	; 34
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   15350:	d7 01       	movw	r26, r14
   15352:	8c 91       	ld	r24, X
   15354:	8d 8b       	std	Y+21, r24	; 0x15
   15356:	11 96       	adiw	r26, 0x01	; 1
   15358:	8c 91       	ld	r24, X
   1535a:	8e 8b       	std	Y+22, r24	; 0x16
	 }Dest[Length]=0;
   1535c:	1f 8a       	std	Y+23, r1	; 0x17
	 //PumpLabel
	 StrPos=(40*10)+(12*6)+(5*6)+(2*8)+(6*8)+1+2;
	 for(i=0;i<8;i++){
         FillChar(strEEPROM,0,sizeof(strEEPROM));   
		 StrPosCopy(rcv_trans,strEEPROM,(StrPos+(2*i)),2);
		 RemZeroLead(strEEPROM);
   1535e:	c5 01       	movw	r24, r10
   15360:	0e 94 19 25 	call	0x4a32	; 0x4a32 <RemZeroLead>
		 xEEPROM=atoi(strEEPROM);
   15364:	c5 01       	movw	r24, r10
   15366:	0e 94 c3 b3 	call	0x16786	; 0x16786 <atoi>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   1536a:	e1 99       	sbic	0x1c, 1	; 28
   1536c:	fe cf       	rjmp	.-4      	; 0x1536a <SaveConfigParameter+0x35e>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   1536e:	df ba       	out	0x1f, r13	; 31
   15370:	ce ba       	out	0x1e, r12	; 30
#endif
    EEDR = __value;
   15372:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
   15374:	0f b6       	in	r0, 0x3f	; 63
   15376:	f8 94       	cli
   15378:	e2 9a       	sbi	0x1c, 2	; 28
   1537a:	e1 9a       	sbi	0x1c, 1	; 28
   1537c:	0f be       	out	0x3f, r0	; 63
         eeprom_write_byte(&DefPumpLabel[i],xEEPROM);
		 sprintf_P(strSend,PSTR("%d"),xEEPROM);
   1537e:	00 d0       	rcall	.+0      	; 0x15380 <SaveConfigParameter+0x374>
   15380:	00 d0       	rcall	.+0      	; 0x15382 <SaveConfigParameter+0x376>
   15382:	00 d0       	rcall	.+0      	; 0x15384 <SaveConfigParameter+0x378>
   15384:	ed b7       	in	r30, 0x3d	; 61
   15386:	fe b7       	in	r31, 0x3e	; 62
   15388:	31 96       	adiw	r30, 0x01	; 1
   1538a:	ad b7       	in	r26, 0x3d	; 61
   1538c:	be b7       	in	r27, 0x3e	; 62
   1538e:	11 96       	adiw	r26, 0x01	; 1
   15390:	8c 92       	st	X, r8
   15392:	11 97       	sbiw	r26, 0x01	; 1
   15394:	12 96       	adiw	r26, 0x02	; 2
   15396:	9c 92       	st	X, r9
   15398:	13 83       	std	Z+3, r17	; 0x03
   1539a:	02 83       	std	Z+2, r16	; 0x02
   1539c:	84 83       	std	Z+4, r24	; 0x04
   1539e:	15 82       	std	Z+5, r1	; 0x05
   153a0:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
   153a4:	e2 e0       	ldi	r30, 0x02	; 2
   153a6:	f0 e0       	ldi	r31, 0x00	; 0
   153a8:	ee 0e       	add	r14, r30
   153aa:	ff 1e       	adc	r15, r31
   153ac:	08 94       	sec
   153ae:	c1 1c       	adc	r12, r1
   153b0:	d1 1c       	adc	r13, r1
	 sprintf_P(strSend,PSTR("%d"),xEEPROM);
//	 _uart_print(1,1,strSend); 

	 //PumpLabel
	 StrPos=(40*10)+(12*6)+(5*6)+(2*8)+(6*8)+1+2;
	 for(i=0;i<8;i++){
   153b2:	8d b7       	in	r24, 0x3d	; 61
   153b4:	9e b7       	in	r25, 0x3e	; 62
   153b6:	06 96       	adiw	r24, 0x06	; 6
   153b8:	0f b6       	in	r0, 0x3f	; 63
   153ba:	f8 94       	cli
   153bc:	9e bf       	out	0x3e, r25	; 62
   153be:	0f be       	out	0x3f, r0	; 63
   153c0:	8d bf       	out	0x3d, r24	; 61
   153c2:	9a e9       	ldi	r25, 0x9A	; 154
   153c4:	e9 16       	cp	r14, r25
   153c6:	9c e0       	ldi	r25, 0x0C	; 12
   153c8:	f9 06       	cpc	r15, r25
   153ca:	09 f0       	breq	.+2      	; 0x153ce <SaveConfigParameter+0x3c2>
   153cc:	c1 cf       	rjmp	.-126    	; 0x15350 <SaveConfigParameter+0x344>
		 xEEPROM=atoi(strEEPROM);
         eeprom_write_byte(&DefPumpLabel[i],xEEPROM);
		 sprintf_P(strSend,PSTR("%d"),xEEPROM);
//		 _uart_print(1,1,strSend); 
	 }    
	 _uart_printf(1,1,PSTR("<OK>")); 
   153ce:	81 e0       	ldi	r24, 0x01	; 1
   153d0:	61 e0       	ldi	r22, 0x01	; 1
   153d2:	48 e8       	ldi	r20, 0x88	; 136
   153d4:	52 e2       	ldi	r21, 0x22	; 34
   153d6:	0e 94 98 b2 	call	0x16530	; 0x16530 <_uart_printf>
}
   153da:	ca 5b       	subi	r28, 0xBA	; 186
   153dc:	df 4f       	sbci	r29, 0xFF	; 255
   153de:	0f b6       	in	r0, 0x3f	; 63
   153e0:	f8 94       	cli
   153e2:	de bf       	out	0x3e, r29	; 62
   153e4:	0f be       	out	0x3f, r0	; 63
   153e6:	cd bf       	out	0x3d, r28	; 61
   153e8:	cf 91       	pop	r28
   153ea:	df 91       	pop	r29
   153ec:	1f 91       	pop	r17
   153ee:	0f 91       	pop	r16
   153f0:	ff 90       	pop	r15
   153f2:	ef 90       	pop	r14
   153f4:	df 90       	pop	r13
   153f6:	cf 90       	pop	r12
   153f8:	bf 90       	pop	r11
   153fa:	af 90       	pop	r10
   153fc:	9f 90       	pop	r9
   153fe:	8f 90       	pop	r8
   15400:	08 95       	ret

00015402 <systemConfigProtocol>:



void systemConfigProtocol(){
     static char stConfigProtocol=cpWaitSend;
	 switch(stConfigProtocol){
   15402:	80 91 f3 02 	lds	r24, 0x02F3
   15406:	81 30       	cpi	r24, 0x01	; 1
   15408:	c1 f0       	breq	.+48     	; 0x1543a <systemConfigProtocol+0x38>
   1540a:	81 30       	cpi	r24, 0x01	; 1
   1540c:	18 f0       	brcs	.+6      	; 0x15414 <systemConfigProtocol+0x12>
   1540e:	82 30       	cpi	r24, 0x02	; 2
   15410:	e9 f4       	brne	.+58     	; 0x1544c <systemConfigProtocol+0x4a>
   15412:	18 c0       	rjmp	.+48     	; 0x15444 <systemConfigProtocol+0x42>
	 case cpWaitSend:
	      switch(ConfigCommand){
   15414:	80 91 b2 01 	lds	r24, 0x01B2
   15418:	81 30       	cpi	r24, 0x01	; 1
   1541a:	31 f0       	breq	.+12     	; 0x15428 <systemConfigProtocol+0x26>
   1541c:	82 30       	cpi	r24, 0x02	; 2
   1541e:	51 f4       	brne	.+20     	; 0x15434 <systemConfigProtocol+0x32>
		  case CC_SEND_CONFIG:
		       ConfigCommand=CC_NONE;
   15420:	10 92 b2 01 	sts	0x01B2, r1
			   stConfigProtocol=cpSendingParameter;
   15424:	81 e0       	ldi	r24, 0x01	; 1
   15426:	03 c0       	rjmp	.+6      	; 0x1542e <systemConfigProtocol+0x2c>
		       break;
		  case CC_SAVE_CONFIG:
		       ConfigCommand=CC_NONE;
   15428:	10 92 b2 01 	sts	0x01B2, r1
			   stConfigProtocol=cpSavingParameter;
   1542c:	82 e0       	ldi	r24, 0x02	; 2
   1542e:	80 93 f3 02 	sts	0x02F3, r24
   15432:	08 95       	ret
		       break;
          default:
		       ConfigCommand=CC_NONE;
   15434:	10 92 b2 01 	sts	0x01B2, r1
   15438:	08 95       	ret
		       break;
		  }
	      break;
     case cpSendingParameter:
	      SendConfigParamater();
   1543a:	0e 94 ec a5 	call	0x14bd8	; 0x14bd8 <SendConfigParamater>
          stConfigProtocol=cpWaitSend;
   1543e:	10 92 f3 02 	sts	0x02F3, r1
   15442:	08 95       	ret
	      break;
     case cpSavingParameter:
          SaveConfigParameter();
   15444:	0e 94 06 a8 	call	0x1500c	; 0x1500c <SaveConfigParameter>
          stConfigProtocol=cpWaitSend;
   15448:	10 92 f3 02 	sts	0x02F3, r1
   1544c:	08 95       	ret

0001544e <FMenuIdle>:
	     ProcTimeOut++;
	}
	TimSend++;
}

void FMenuIdle(){
   1544e:	1f 93       	push	r17
	static char stMenuIdle=miInit,ButtonID=0,PrintStandaloneResult=PS_NONE;
	       char KeyPressed=0,KeyChar=0;
	       char lcdteks[20];

	switch(stMenuIdle){
   15450:	80 91 00 03 	lds	r24, 0x0300
   15454:	e8 2f       	mov	r30, r24
   15456:	f0 e0       	ldi	r31, 0x00	; 0
   15458:	e9 31       	cpi	r30, 0x19	; 25
   1545a:	f1 05       	cpc	r31, r1
   1545c:	08 f0       	brcs	.+2      	; 0x15460 <FMenuIdle+0x12>
   1545e:	80 c1       	rjmp	.+768    	; 0x15760 <FMenuIdle+0x312>
   15460:	e3 5e       	subi	r30, 0xE3	; 227
   15462:	fe 4f       	sbci	r31, 0xFE	; 254
   15464:	ee 0f       	add	r30, r30
   15466:	ff 1f       	adc	r31, r31
   15468:	05 90       	lpm	r0, Z+
   1546a:	f4 91       	lpm	r31, Z+
   1546c:	e0 2d       	mov	r30, r0
   1546e:	09 94       	ijmp
	case miInit:
         DisplayScreenIdle();
   15470:	0e 94 37 45 	call	0x8a6e	; 0x8a6e <DisplayScreenIdle>
   15474:	3c c1       	rjmp	.+632    	; 0x156ee <FMenuIdle+0x2a0>
		 stMenuIdle=miScan;		
	     break;
	case miScan:
         //Scan Key Pressed 
		 KeyPressed=_key_scan(1);
   15476:	81 e0       	ldi	r24, 0x01	; 1
   15478:	0e 94 84 ae 	call	0x15d08	; 0x15d08 <_key_scan>
   1547c:	18 2f       	mov	r17, r24
		 KeyChar= _key_btn(KeyPressed);       
   1547e:	0e 94 e5 ad 	call	0x15bca	; 0x15bca <_key_btn>

		 switch(KeyPressed){
   15482:	1b 3b       	cpi	r17, 0xBB	; 187
   15484:	09 f4       	brne	.+2      	; 0x15488 <FMenuIdle+0x3a>
   15486:	7a c0       	rjmp	.+244    	; 0x1557c <FMenuIdle+0x12e>
   15488:	1c 3b       	cpi	r17, 0xBC	; 188
   1548a:	70 f4       	brcc	.+28     	; 0x154a8 <FMenuIdle+0x5a>
   1548c:	1b 37       	cpi	r17, 0x7B	; 123
   1548e:	69 f1       	breq	.+90     	; 0x154ea <FMenuIdle+0x9c>
   15490:	1c 37       	cpi	r17, 0x7C	; 124
   15492:	20 f4       	brcc	.+8      	; 0x1549c <FMenuIdle+0x4e>
   15494:	17 37       	cpi	r17, 0x77	; 119
   15496:	09 f0       	breq	.+2      	; 0x1549a <FMenuIdle+0x4c>
   15498:	63 c1       	rjmp	.+710    	; 0x15760 <FMenuIdle+0x312>
   1549a:	2e c0       	rjmp	.+92     	; 0x154f8 <FMenuIdle+0xaa>
   1549c:	1d 37       	cpi	r17, 0x7D	; 125
   1549e:	e9 f0       	breq	.+58     	; 0x154da <FMenuIdle+0x8c>
   154a0:	1e 37       	cpi	r17, 0x7E	; 126
   154a2:	09 f0       	breq	.+2      	; 0x154a6 <FMenuIdle+0x58>
   154a4:	5d c1       	rjmp	.+698    	; 0x15760 <FMenuIdle+0x312>
   154a6:	12 c0       	rjmp	.+36     	; 0x154cc <FMenuIdle+0x7e>
   154a8:	1d 3d       	cpi	r17, 0xDD	; 221
   154aa:	09 f4       	brne	.+2      	; 0x154ae <FMenuIdle+0x60>
   154ac:	4f c0       	rjmp	.+158    	; 0x1554c <FMenuIdle+0xfe>
   154ae:	1e 3d       	cpi	r17, 0xDE	; 222
   154b0:	38 f4       	brcc	.+14     	; 0x154c0 <FMenuIdle+0x72>
   154b2:	1d 3b       	cpi	r17, 0xBD	; 189
   154b4:	09 f4       	brne	.+2      	; 0x154b8 <FMenuIdle+0x6a>
   154b6:	56 c0       	rjmp	.+172    	; 0x15564 <FMenuIdle+0x116>
   154b8:	17 3d       	cpi	r17, 0xD7	; 215
   154ba:	09 f0       	breq	.+2      	; 0x154be <FMenuIdle+0x70>
   154bc:	51 c1       	rjmp	.+674    	; 0x15760 <FMenuIdle+0x312>
   154be:	27 c0       	rjmp	.+78     	; 0x1550e <FMenuIdle+0xc0>
   154c0:	1e 3d       	cpi	r17, 0xDE	; 222
   154c2:	61 f1       	breq	.+88     	; 0x1551c <FMenuIdle+0xce>
   154c4:	1d 3e       	cpi	r17, 0xED	; 237
   154c6:	09 f0       	breq	.+2      	; 0x154ca <FMenuIdle+0x7c>
   154c8:	4b c1       	rjmp	.+662    	; 0x15760 <FMenuIdle+0x312>
   154ca:	34 c0       	rjmp	.+104    	; 0x15534 <FMenuIdle+0xe6>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   154cc:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   154ce:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   154d0:	92 e0       	ldi	r25, 0x02	; 2
   154d2:	90 93 bf 01 	sts	0x01BF, r25
         //Scan Key Pressed 
		 KeyPressed=_key_scan(1);
		 KeyChar= _key_btn(KeyPressed);       

		 switch(KeyPressed){
		 case _KEY_TIKET:system_beep(2);ButtonID=1;stMenuIdle=miDisplayProses;break;
   154d6:	81 e0       	ldi	r24, 0x01	; 1
   154d8:	15 c0       	rjmp	.+42     	; 0x15504 <FMenuIdle+0xb6>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   154da:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   154dc:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   154de:	82 e0       	ldi	r24, 0x02	; 2
   154e0:	80 93 bf 01 	sts	0x01BF, r24
		 KeyPressed=_key_scan(1);
		 KeyChar= _key_btn(KeyPressed);       

		 switch(KeyPressed){
		 case _KEY_TIKET:system_beep(2);ButtonID=1;stMenuIdle=miDisplayProses;break;
		 case _KEY_MENU: system_beep(2);ButtonID=2;stMenuIdle=miDisplayProses;break;
   154e4:	80 93 ff 02 	sts	0x02FF, r24
   154e8:	39 c1       	rjmp	.+626    	; 0x1575c <FMenuIdle+0x30e>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   154ea:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   154ec:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   154ee:	92 e0       	ldi	r25, 0x02	; 2
   154f0:	90 93 bf 01 	sts	0x01BF, r25
		 KeyChar= _key_btn(KeyPressed);       

		 switch(KeyPressed){
		 case _KEY_TIKET:system_beep(2);ButtonID=1;stMenuIdle=miDisplayProses;break;
		 case _KEY_MENU: system_beep(2);ButtonID=2;stMenuIdle=miDisplayProses;break;
		 case _KEY_SHIFT:system_beep(2);ButtonID=3;stMenuIdle=miDisplayProses;break;
   154f4:	83 e0       	ldi	r24, 0x03	; 3
   154f6:	06 c0       	rjmp	.+12     	; 0x15504 <FMenuIdle+0xb6>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   154f8:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   154fa:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   154fc:	92 e0       	ldi	r25, 0x02	; 2
   154fe:	90 93 bf 01 	sts	0x01BF, r25

		 switch(KeyPressed){
		 case _KEY_TIKET:system_beep(2);ButtonID=1;stMenuIdle=miDisplayProses;break;
		 case _KEY_MENU: system_beep(2);ButtonID=2;stMenuIdle=miDisplayProses;break;
		 case _KEY_SHIFT:system_beep(2);ButtonID=3;stMenuIdle=miDisplayProses;break;
		 case _KEY_CLEAR:system_beep(2);ButtonID=4;stMenuIdle=miDisplayProses;break;//stMenuIdle=miTestMsg56;break;//miDisplayProses;break;
   15502:	84 e0       	ldi	r24, 0x04	; 4
   15504:	80 93 ff 02 	sts	0x02FF, r24
   15508:	90 93 00 03 	sts	0x0300, r25
   1550c:	29 c1       	rjmp	.+594    	; 0x15760 <FMenuIdle+0x312>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   1550e:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   15510:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   15512:	82 e0       	ldi	r24, 0x02	; 2
   15514:	80 93 bf 01 	sts	0x01BF, r24
		 switch(KeyPressed){
		 case _KEY_TIKET:system_beep(2);ButtonID=1;stMenuIdle=miDisplayProses;break;
		 case _KEY_MENU: system_beep(2);ButtonID=2;stMenuIdle=miDisplayProses;break;
		 case _KEY_SHIFT:system_beep(2);ButtonID=3;stMenuIdle=miDisplayProses;break;
		 case _KEY_CLEAR:system_beep(2);ButtonID=4;stMenuIdle=miDisplayProses;break;//stMenuIdle=miTestMsg56;break;//miDisplayProses;break;
		 case _KEY_0:    system_beep(2);           stMenuIdle=miRunTicket;    break;
   15518:	8c e0       	ldi	r24, 0x0C	; 12
   1551a:	20 c1       	rjmp	.+576    	; 0x1575c <FMenuIdle+0x30e>
	   //case _KEY_1:    system_beep(2);           stMenuIdle=miRunTotalizer; break;
		 case _KEY_2: if(IFType==IT_SLAVE) {system_beep(2); stMenuIdle=miRunEDC;}       break;
   1551c:	80 91 00 01 	lds	r24, 0x0100
   15520:	81 30       	cpi	r24, 0x01	; 1
   15522:	09 f0       	breq	.+2      	; 0x15526 <FMenuIdle+0xd8>
   15524:	1d c1       	rjmp	.+570    	; 0x15760 <FMenuIdle+0x312>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   15526:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   15528:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   1552a:	82 e0       	ldi	r24, 0x02	; 2
   1552c:	80 93 bf 01 	sts	0x01BF, r24
		 case _KEY_MENU: system_beep(2);ButtonID=2;stMenuIdle=miDisplayProses;break;
		 case _KEY_SHIFT:system_beep(2);ButtonID=3;stMenuIdle=miDisplayProses;break;
		 case _KEY_CLEAR:system_beep(2);ButtonID=4;stMenuIdle=miDisplayProses;break;//stMenuIdle=miTestMsg56;break;//miDisplayProses;break;
		 case _KEY_0:    system_beep(2);           stMenuIdle=miRunTicket;    break;
	   //case _KEY_1:    system_beep(2);           stMenuIdle=miRunTotalizer; break;
		 case _KEY_2: if(IFType==IT_SLAVE) {system_beep(2); stMenuIdle=miRunEDC;}       break;
   15530:	80 e1       	ldi	r24, 0x10	; 16
   15532:	14 c1       	rjmp	.+552    	; 0x1575c <FMenuIdle+0x30e>
	   //case _KEY_3:    system_beep(2);           stMenuIdle=miClearTotalizer;break;
		 case _KEY_4: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunReprint;}   break;
   15534:	80 91 00 01 	lds	r24, 0x0100
   15538:	81 30       	cpi	r24, 0x01	; 1
   1553a:	09 f0       	breq	.+2      	; 0x1553e <FMenuIdle+0xf0>
   1553c:	11 c1       	rjmp	.+546    	; 0x15760 <FMenuIdle+0x312>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   1553e:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   15540:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   15542:	82 e0       	ldi	r24, 0x02	; 2
   15544:	80 93 bf 01 	sts	0x01BF, r24
		 case _KEY_CLEAR:system_beep(2);ButtonID=4;stMenuIdle=miDisplayProses;break;//stMenuIdle=miTestMsg56;break;//miDisplayProses;break;
		 case _KEY_0:    system_beep(2);           stMenuIdle=miRunTicket;    break;
	   //case _KEY_1:    system_beep(2);           stMenuIdle=miRunTotalizer; break;
		 case _KEY_2: if(IFType==IT_SLAVE) {system_beep(2); stMenuIdle=miRunEDC;}       break;
	   //case _KEY_3:    system_beep(2);           stMenuIdle=miClearTotalizer;break;
		 case _KEY_4: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunReprint;}   break;
   15548:	82 e1       	ldi	r24, 0x12	; 18
   1554a:	08 c1       	rjmp	.+528    	; 0x1575c <FMenuIdle+0x30e>
		 case _KEY_5: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunLoyalty;}   break;
   1554c:	80 91 00 01 	lds	r24, 0x0100
   15550:	81 30       	cpi	r24, 0x01	; 1
   15552:	09 f0       	breq	.+2      	; 0x15556 <FMenuIdle+0x108>
   15554:	05 c1       	rjmp	.+522    	; 0x15760 <FMenuIdle+0x312>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   15556:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   15558:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   1555a:	82 e0       	ldi	r24, 0x02	; 2
   1555c:	80 93 bf 01 	sts	0x01BF, r24
		 case _KEY_0:    system_beep(2);           stMenuIdle=miRunTicket;    break;
	   //case _KEY_1:    system_beep(2);           stMenuIdle=miRunTotalizer; break;
		 case _KEY_2: if(IFType==IT_SLAVE) {system_beep(2); stMenuIdle=miRunEDC;}       break;
	   //case _KEY_3:    system_beep(2);           stMenuIdle=miClearTotalizer;break;
		 case _KEY_4: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunReprint;}   break;
		 case _KEY_5: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunLoyalty;}   break;
   15560:	81 e1       	ldi	r24, 0x11	; 17
   15562:	fc c0       	rjmp	.+504    	; 0x1575c <FMenuIdle+0x30e>
		 case _KEY_6: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunChangeMOP;} break;
   15564:	80 91 00 01 	lds	r24, 0x0100
   15568:	81 30       	cpi	r24, 0x01	; 1
   1556a:	09 f0       	breq	.+2      	; 0x1556e <FMenuIdle+0x120>
   1556c:	f9 c0       	rjmp	.+498    	; 0x15760 <FMenuIdle+0x312>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   1556e:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   15570:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   15572:	82 e0       	ldi	r24, 0x02	; 2
   15574:	80 93 bf 01 	sts	0x01BF, r24
	   //case _KEY_1:    system_beep(2);           stMenuIdle=miRunTotalizer; break;
		 case _KEY_2: if(IFType==IT_SLAVE) {system_beep(2); stMenuIdle=miRunEDC;}       break;
	   //case _KEY_3:    system_beep(2);           stMenuIdle=miClearTotalizer;break;
		 case _KEY_4: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunReprint;}   break;
		 case _KEY_5: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunLoyalty;}   break;
		 case _KEY_6: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunChangeMOP;} break;
   15578:	8f e0       	ldi	r24, 0x0F	; 15
   1557a:	f0 c0       	rjmp	.+480    	; 0x1575c <FMenuIdle+0x30e>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   1557c:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   1557e:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   15580:	82 e0       	ldi	r24, 0x02	; 2
   15582:	80 93 bf 01 	sts	0x01BF, r24
	   //case _KEY_3:    system_beep(2);           stMenuIdle=miClearTotalizer;break;
		 case _KEY_4: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunReprint;}   break;
		 case _KEY_5: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunLoyalty;}   break;
		 case _KEY_6: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunChangeMOP;} break;
		 //case _KEY_8:    system_beep(2);           stMenuIdle=miRunTestChar;   break;
		 case _KEY_9:    system_beep(2);stMenuIdle=miRunAuth;      break;
   15586:	8d e0       	ldi	r24, 0x0D	; 13
   15588:	e9 c0       	rjmp	.+466    	; 0x1575c <FMenuIdle+0x30e>
		 }
	     break;
    case miTestMsg56:
	     sprintf_P(strCardID,PSTR("4356A31A"));
   1558a:	00 d0       	rcall	.+0      	; 0x1558c <FMenuIdle+0x13e>
   1558c:	00 d0       	rcall	.+0      	; 0x1558e <FMenuIdle+0x140>
   1558e:	8d eb       	ldi	r24, 0xBD	; 189
   15590:	9c e0       	ldi	r25, 0x0C	; 12
   15592:	ed b7       	in	r30, 0x3d	; 61
   15594:	fe b7       	in	r31, 0x3e	; 62
   15596:	92 83       	std	Z+2, r25	; 0x02
   15598:	81 83       	std	Z+1, r24	; 0x01
   1559a:	81 eb       	ldi	r24, 0xB1	; 177
   1559c:	93 e2       	ldi	r25, 0x23	; 35
   1559e:	94 83       	std	Z+4, r25	; 0x04
   155a0:	83 83       	std	Z+3, r24	; 0x03
   155a2:	0e 94 31 b4 	call	0x16862	; 0x16862 <sprintf_P>
	     sendMessage56();
   155a6:	0f 90       	pop	r0
   155a8:	0f 90       	pop	r0
   155aa:	0f 90       	pop	r0
   155ac:	0f 90       	pop	r0
   155ae:	0e 94 80 9c 	call	0x13900	; 0x13900 <sendMessage56>
         stMenuIdle=miDisplayProses;
   155b2:	82 e0       	ldi	r24, 0x02	; 2
   155b4:	d3 c0       	rjmp	.+422    	; 0x1575c <FMenuIdle+0x30e>
	     break;
	case miDisplayProses:
	     if (IsBusyIdlePrinting==False){
   155b6:	80 91 b4 01 	lds	r24, 0x01B4
   155ba:	88 23       	and	r24, r24
   155bc:	09 f0       	breq	.+2      	; 0x155c0 <FMenuIdle+0x172>
   155be:	97 c0       	rjmp	.+302    	; 0x156ee <FMenuIdle+0x2a0>
		     lcd_printf(3,1,PSTR("SedangProses"));
   155c0:	83 e0       	ldi	r24, 0x03	; 3
   155c2:	61 e0       	ldi	r22, 0x01	; 1
   155c4:	44 ea       	ldi	r20, 0xA4	; 164
   155c6:	53 e2       	ldi	r21, 0x23	; 35
   155c8:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
	         TimDisplay=0;
   155cc:	10 92 95 01 	sts	0x0195, r1
			 stMenuIdle=miWaitProses;
   155d0:	83 e0       	ldi	r24, 0x03	; 3
   155d2:	c4 c0       	rjmp	.+392    	; 0x1575c <FMenuIdle+0x30e>
         }else stMenuIdle=miScan;
	     break;
    case miWaitProses:
	     if (TimDisplay>1){
   155d4:	80 91 95 01 	lds	r24, 0x0195
   155d8:	82 30       	cpi	r24, 0x02	; 2
   155da:	08 f4       	brcc	.+2      	; 0x155de <FMenuIdle+0x190>
   155dc:	c1 c0       	rjmp	.+386    	; 0x15760 <FMenuIdle+0x312>
		     if (IFType==IT_SLAVE)stMenuIdle=miSendMessage98;
   155de:	80 91 00 01 	lds	r24, 0x0100
   155e2:	81 30       	cpi	r24, 0x01	; 1
   155e4:	11 f4       	brne	.+4      	; 0x155ea <FMenuIdle+0x19c>
   155e6:	84 e0       	ldi	r24, 0x04	; 4
   155e8:	b9 c0       	rjmp	.+370    	; 0x1575c <FMenuIdle+0x30e>
			 else
		     if (IFType==IT_STANDALONE)stMenuIdle=miPrintStandalone;
   155ea:	82 30       	cpi	r24, 0x02	; 2
   155ec:	09 f0       	breq	.+2      	; 0x155f0 <FMenuIdle+0x1a2>
   155ee:	b8 c0       	rjmp	.+368    	; 0x15760 <FMenuIdle+0x312>
   155f0:	87 e0       	ldi	r24, 0x07	; 7
   155f2:	b4 c0       	rjmp	.+360    	; 0x1575c <FMenuIdle+0x30e>
		 }
	     break;
    case miPrintStandalone:
	     PrintStandaloneResult=PrintStandalone(ButtonID,False);
   155f4:	80 91 ff 02 	lds	r24, 0x02FF
   155f8:	60 e0       	ldi	r22, 0x00	; 0
   155fa:	0e 94 f7 20 	call	0x41ee	; 0x41ee <PrintStandalone>
   155fe:	80 93 4c 01 	sts	0x014C, r24
	     if (PrintStandaloneResult==PS_PRINTED)stMenuIdle=miReady;
   15602:	81 31       	cpi	r24, 0x11	; 17
   15604:	09 f4       	brne	.+2      	; 0x15608 <FMenuIdle+0x1ba>
   15606:	a9 c0       	rjmp	.+338    	; 0x1575a <FMenuIdle+0x30c>
		 else
		 if (PrintStandaloneResult==PS_NO_DATA)stMenuIdle=miDisplayNoTransaction;
   15608:	82 31       	cpi	r24, 0x12	; 18
   1560a:	09 f0       	breq	.+2      	; 0x1560e <FMenuIdle+0x1c0>
   1560c:	a9 c0       	rjmp	.+338    	; 0x15760 <FMenuIdle+0x312>
   1560e:	88 e0       	ldi	r24, 0x08	; 8
   15610:	a5 c0       	rjmp	.+330    	; 0x1575c <FMenuIdle+0x30e>
	     break;
    case miDisplayNoTransaction:
	     lcd_printf(3, 1,PSTR("Tidak Ada Transaksi "));
   15612:	83 e0       	ldi	r24, 0x03	; 3
   15614:	61 e0       	ldi	r22, 0x01	; 1
   15616:	4f e8       	ldi	r20, 0x8F	; 143
   15618:	53 e2       	ldi	r21, 0x23	; 35
   1561a:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
         TimDisplay=0;
   1561e:	10 92 95 01 	sts	0x0195, r1
		 stMenuIdle=miWaitDisplayNoTransaction;
   15622:	89 e0       	ldi	r24, 0x09	; 9
   15624:	9b c0       	rjmp	.+310    	; 0x1575c <FMenuIdle+0x30e>
	     break;
    case miWaitDisplayNoTransaction:
	     if (TimDisplay>1){
   15626:	80 91 95 01 	lds	r24, 0x0195
   1562a:	82 30       	cpi	r24, 0x02	; 2
   1562c:	08 f4       	brcc	.+2      	; 0x15630 <FMenuIdle+0x1e2>
   1562e:	98 c0       	rjmp	.+304    	; 0x15760 <FMenuIdle+0x312>
	         lcd_printf(3,1,PSTR("Ready...            "));
   15630:	83 e0       	ldi	r24, 0x03	; 3
   15632:	61 e0       	ldi	r22, 0x01	; 1
   15634:	4a e7       	ldi	r20, 0x7A	; 122
   15636:	53 e2       	ldi	r21, 0x23	; 35
   15638:	32 c0       	rjmp	.+100    	; 0x1569e <FMenuIdle+0x250>
		     stMenuIdle=miWaitReady;
			 TimDisplay=0;
		 }
	     break;
    case miSendMessage98:
	     lcd_printf(3,1,PSTR("Please Wait..       "));
   1563a:	83 e0       	ldi	r24, 0x03	; 3
   1563c:	61 e0       	ldi	r22, 0x01	; 1
   1563e:	45 e6       	ldi	r20, 0x65	; 101
   15640:	53 e2       	ldi	r21, 0x23	; 35
   15642:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
	     sendMessage98(ButtonID);
   15646:	80 91 ff 02 	lds	r24, 0x02FF
   1564a:	0e 94 01 4d 	call	0x9a02	; 0x9a02 <sendMessage98>
		 ProcTimeOut=0;
   1564e:	10 92 be 01 	sts	0x01BE, r1
		 stMenuIdle=miWaitPlease;
   15652:	85 e0       	ldi	r24, 0x05	; 5
   15654:	83 c0       	rjmp	.+262    	; 0x1575c <FMenuIdle+0x30e>
	     break;
    case miWaitPlease:
         if (ProcTimeOut>TIM_NO_RESPONSE){
   15656:	80 91 be 01 	lds	r24, 0x01BE
   1565a:	8f 30       	cpi	r24, 0x0F	; 15
   1565c:	58 f0       	brcs	.+22     	; 0x15674 <FMenuIdle+0x226>
	         lcd_printf(3,1,PSTR("No Response..       "));
   1565e:	83 e0       	ldi	r24, 0x03	; 3
   15660:	61 e0       	ldi	r22, 0x01	; 1
   15662:	40 e5       	ldi	r20, 0x50	; 80
   15664:	53 e2       	ldi	r21, 0x23	; 35
   15666:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		     stMenuIdle=miNoResponse;
   1566a:	86 e0       	ldi	r24, 0x06	; 6
   1566c:	80 93 00 03 	sts	0x0300, r24
			 TimDisplay=0;		 
   15670:	10 92 95 01 	sts	0x0195, r1
		 }
		 if ((IsMessage99==True)||(IsMessage00==True)){
   15674:	80 91 a2 01 	lds	r24, 0x01A2
   15678:	81 30       	cpi	r24, 0x01	; 1
   1567a:	29 f0       	breq	.+10     	; 0x15686 <FMenuIdle+0x238>
   1567c:	80 91 a1 01 	lds	r24, 0x01A1
   15680:	81 30       	cpi	r24, 0x01	; 1
   15682:	09 f0       	breq	.+2      	; 0x15686 <FMenuIdle+0x238>
   15684:	6d c0       	rjmp	.+218    	; 0x15760 <FMenuIdle+0x312>
		     ClearMem(strOdometer);
   15686:	82 ed       	ldi	r24, 0xD2	; 210
   15688:	94 e0       	ldi	r25, 0x04	; 4
   1568a:	0e 94 7f ad 	call	0x15afe	; 0x15afe <ClearMem>
		     ClearMem(strLicPlate);
   1568e:	8e e2       	ldi	r24, 0x2E	; 46
   15690:	9a e0       	ldi	r25, 0x0A	; 10
   15692:	0e 94 7f ad 	call	0x15afe	; 0x15afe <ClearMem>
	         lcd_printf(3,1,PSTR("Ready...            "));
   15696:	83 e0       	ldi	r24, 0x03	; 3
   15698:	61 e0       	ldi	r22, 0x01	; 1
   1569a:	4b e3       	ldi	r20, 0x3B	; 59
   1569c:	53 e2       	ldi	r21, 0x23	; 35
   1569e:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		     stMenuIdle=miWaitReady;
   156a2:	8a e0       	ldi	r24, 0x0A	; 10
   156a4:	80 93 00 03 	sts	0x0300, r24
			 TimDisplay=0;
   156a8:	10 92 95 01 	sts	0x0195, r1
   156ac:	59 c0       	rjmp	.+178    	; 0x15760 <FMenuIdle+0x312>
			 }
	     break;
    case miNoResponse:
         if (TimDisplay>1){
   156ae:	80 91 95 01 	lds	r24, 0x0195
   156b2:	82 30       	cpi	r24, 0x02	; 2
   156b4:	08 f4       	brcc	.+2      	; 0x156b8 <FMenuIdle+0x26a>
   156b6:	54 c0       	rjmp	.+168    	; 0x15760 <FMenuIdle+0x312>
	         lcd_printf(3,1,PSTR("Ready...            "));
   156b8:	83 e0       	ldi	r24, 0x03	; 3
   156ba:	61 e0       	ldi	r22, 0x01	; 1
   156bc:	46 e2       	ldi	r20, 0x26	; 38
   156be:	53 e2       	ldi	r21, 0x23	; 35
   156c0:	ee cf       	rjmp	.-36     	; 0x1569e <FMenuIdle+0x250>
		     stMenuIdle=miWaitReady;
			 TimDisplay=0;
			 }	     
	     break;
    case miWaitReady:
         if (TimDisplay>1){
   156c2:	80 91 95 01 	lds	r24, 0x0195
   156c6:	82 30       	cpi	r24, 0x02	; 2
   156c8:	08 f4       	brcc	.+2      	; 0x156cc <FMenuIdle+0x27e>
   156ca:	4a c0       	rjmp	.+148    	; 0x15760 <FMenuIdle+0x312>
	         lcd_printf(3,1,PSTR("                "));
   156cc:	83 e0       	ldi	r24, 0x03	; 3
   156ce:	61 e0       	ldi	r22, 0x01	; 1
   156d0:	45 e1       	ldi	r20, 0x15	; 21
   156d2:	53 e2       	ldi	r21, 0x23	; 35
   156d4:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		     stMenuIdle=miReady;
   156d8:	8b e0       	ldi	r24, 0x0B	; 11
   156da:	e4 cf       	rjmp	.-56     	; 0x156a4 <FMenuIdle+0x256>
			 TimDisplay=0;
			 }	     
	     break;
    case miReady:
	     DisplayScreenIdle();
   156dc:	0e 94 37 45 	call	0x8a6e	; 0x8a6e <DisplayScreenIdle>
		 if (IFType==IT_STANDALONE)IsNewPumpStatus=True;
   156e0:	80 91 00 01 	lds	r24, 0x0100
   156e4:	82 30       	cpi	r24, 0x02	; 2
   156e6:	19 f4       	brne	.+6      	; 0x156ee <FMenuIdle+0x2a0>
   156e8:	81 e0       	ldi	r24, 0x01	; 1
   156ea:	80 93 01 01 	sts	0x0101, r24
		 stMenuIdle=miScan;
   156ee:	81 e0       	ldi	r24, 0x01	; 1
   156f0:	35 c0       	rjmp	.+106    	; 0x1575c <FMenuIdle+0x30e>
	     break;
	case miRunTicket://Slave,Standalone
		 if (FMenuTicket()==MENU_DONE)
   156f2:	0e 94 35 86 	call	0x10c6a	; 0x10c6a <FMenuTicket>
   156f6:	2f c0       	rjmp	.+94     	; 0x15756 <FMenuIdle+0x308>
		     stMenuIdle=miReady;
	     break;
	case miRunAuth://Slave,Standalone
		 if (FMenuAuthorization()==MENU_DONE)
   156f8:	0e 94 97 9b 	call	0x1372e	; 0x1372e <FMenuAuthorization>
   156fc:	2c c0       	rjmp	.+88     	; 0x15756 <FMenuIdle+0x308>
		     stMenuIdle=miReady;
	     break;
		 
    case miRunLocalAccount://Slave
		 if (FMenuLocalAccount()==MENU_DONE)
   156fe:	0e 94 2a 9d 	call	0x13a54	; 0x13a54 <FMenuLocalAccount>
   15702:	29 c0       	rjmp	.+82     	; 0x15756 <FMenuIdle+0x308>
		     stMenuIdle=miReady;
	     break;  
    case miRunChangeMOP://Slave
	     if (FMenuChangeMOP()==MENU_DONE)
   15704:	0e 94 c1 94 	call	0x12982	; 0x12982 <FMenuChangeMOP>
   15708:	26 c0       	rjmp	.+76     	; 0x15756 <FMenuIdle+0x308>
		     stMenuIdle=miReady;
	     break;
    case miRunEDC://Slave
	     if (FMenuEDCTransaction()==MENU_DONE)
   1570a:	0e 94 3d 67 	call	0xce7a	; 0xce7a <FMenuEDCTransaction>
   1570e:	23 c0       	rjmp	.+70     	; 0x15756 <FMenuIdle+0x308>
		     stMenuIdle=miReady;
         break;
    case miRunLoyalty://Slave
	     if (FMenuLoyalty()==MENU_DONE)
   15710:	0e 94 26 68 	call	0xd04c	; 0xd04c <FMenuLoyalty>
   15714:	20 c0       	rjmp	.+64     	; 0x15756 <FMenuIdle+0x308>
		     stMenuIdle=miReady;
	     break;
    case miRunReprint://Slave,Standalone
	     if (FMenuReprint()==MENU_DONE)
   15716:	0e 94 20 93 	call	0x12640	; 0x12640 <FMenuReprint>
   1571a:	1d c0       	rjmp	.+58     	; 0x15756 <FMenuIdle+0x308>
		     stMenuIdle=miReady;
	     break;
    case miRunViewFreeMessage://Slave
	     if (FViewFreeMessage()==MENU_DONE)
   1571c:	0e 94 fd 44 	call	0x89fa	; 0x89fa <FViewFreeMessage>
   15720:	1a c0       	rjmp	.+52     	; 0x15756 <FMenuIdle+0x308>
		     stMenuIdle=miReady;
	     break;
    case miClearTotalizer://Standalone
	     lcd_printf(3,1,PSTR("Clear Data Totalizer"));
   15722:	83 e0       	ldi	r24, 0x03	; 3
   15724:	61 e0       	ldi	r22, 0x01	; 1
   15726:	40 e0       	ldi	r20, 0x00	; 0
   15728:	53 e2       	ldi	r21, 0x23	; 35
   1572a:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
	     ResetTotalizer(TOTALIZER_LAST);
   1572e:	80 e0       	ldi	r24, 0x00	; 0
   15730:	0e 94 e0 28 	call	0x51c0	; 0x51c0 <ResetTotalizer>
         ResetTotalizer(TOTALIZER_NOW);
   15734:	81 e0       	ldi	r24, 0x01	; 1
   15736:	0e 94 e0 28 	call	0x51c0	; 0x51c0 <ResetTotalizer>
   1573a:	0f c0       	rjmp	.+30     	; 0x1575a <FMenuIdle+0x30c>
         stMenuIdle=miReady;	      
	     break;
    case miRunTotalizer://Standalone
	     lcd_printf(3,1,PSTR("TotalizerAll     "));
   1573c:	83 e0       	ldi	r24, 0x03	; 3
   1573e:	61 e0       	ldi	r22, 0x01	; 1
   15740:	4e ee       	ldi	r20, 0xEE	; 238
   15742:	52 e2       	ldi	r21, 0x22	; 34
   15744:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
	     SendSlaveCommand(SC_TOTALIZER,PUMP_ALL);
   15748:	85 e0       	ldi	r24, 0x05	; 5
   1574a:	62 e1       	ldi	r22, 0x12	; 18
   1574c:	0e 94 72 74 	call	0xe8e4	; 0xe8e4 <SendSlaveCommand>
   15750:	04 c0       	rjmp	.+8      	; 0x1575a <FMenuIdle+0x30c>
		 stMenuIdle=miReady;	      
	     break;
    case miRunTestChar:	     
 	     if (FTestChar()==MENU_DONE)
   15752:	0e 94 4b 44 	call	0x8896	; 0x8896 <FTestChar>
   15756:	81 30       	cpi	r24, 0x01	; 1
   15758:	19 f4       	brne	.+6      	; 0x15760 <FMenuIdle+0x312>
         stMenuIdle=miReady;
   1575a:	8b e0       	ldi	r24, 0x0B	; 11
   1575c:	80 93 00 03 	sts	0x0300, r24
	     break;
	}
//----------SYSTEM_PROC--------------------------------

        //Bank InfoUpdated
        if (IsMessage21==True){
   15760:	80 91 a4 01 	lds	r24, 0x01A4
   15764:	81 30       	cpi	r24, 0x01	; 1
   15766:	21 f4       	brne	.+8      	; 0x15770 <FMenuIdle+0x322>
		    IsMessage21=False;
   15768:	10 92 a4 01 	sts	0x01A4, r1
			procMessage21();
   1576c:	0e 94 f4 1c 	call	0x39e8	; 0x39e8 <procMessage21>

        }
        //Transaction Status
        if (IsMessage00==True){
   15770:	80 91 a1 01 	lds	r24, 0x01A1
   15774:	81 30       	cpi	r24, 0x01	; 1
   15776:	91 f4       	brne	.+36     	; 0x1579c <FMenuIdle+0x34e>
		    IsMessage00=False;
   15778:	10 92 a1 01 	sts	0x01A1, r1
*/
char procMessage00(){
     char Result,strSend[10];
	 Result=MSG00_NACK;
	 //Message57
	 if((rcv_trans[0]==0x01)&&(transLength==MSG00_LENGTH)){
   1577c:	20 91 51 0a 	lds	r18, 0x0A51
   15780:	21 30       	cpi	r18, 0x01	; 1
   15782:	61 f4       	brne	.+24     	; 0x1579c <FMenuIdle+0x34e>
   15784:	80 91 8e 01 	lds	r24, 0x018E
   15788:	90 91 8f 01 	lds	r25, 0x018F
   1578c:	8f 97       	sbiw	r24, 0x2f	; 47
   1578e:	31 f4       	brne	.+12     	; 0x1579c <FMenuIdle+0x34e>

        }
        //Transaction Status
        if (IsMessage00==True){
		    IsMessage00=False;
			if (procMessage00()==MSG00_NO_PRINT){
   15790:	80 91 76 0a 	lds	r24, 0x0A76
   15794:	84 33       	cpi	r24, 0x34	; 52
   15796:	11 f4       	brne	.+4      	; 0x1579c <FMenuIdle+0x34e>
			    IsNoTransaction=True;
   15798:	20 93 ae 01 	sts	0x01AE, r18
				}
		}
  
		//Send EDC Message Information;
		if (IsSendMessageEDC==True){
   1579c:	80 91 9a 01 	lds	r24, 0x019A
   157a0:	81 30       	cpi	r24, 0x01	; 1
   157a2:	21 f4       	brne	.+8      	; 0x157ac <FMenuIdle+0x35e>
		    IsSendMessageEDC=False;
   157a4:	10 92 9a 01 	sts	0x019A, r1
			SendEDCMessage();
   157a8:	0e 94 ed 73 	call	0xe7da	; 0xe7da <SendEDCMessage>
		}
		if (IsEDCApproved==True){
   157ac:	80 91 9c 01 	lds	r24, 0x019C
   157b0:	81 30       	cpi	r24, 0x01	; 1
   157b2:	21 f4       	brne	.+8      	; 0x157bc <FMenuIdle+0x36e>
		    IsEDCApproved=False;
   157b4:	10 92 9c 01 	sts	0x019C, r1
            sendMessage92();
   157b8:	0e 94 29 4e 	call	0x9c52	; 0x9c52 <sendMessage92>
		}
		if (IsVoidTransaction==True){
   157bc:	80 91 9e 01 	lds	r24, 0x019E
   157c0:	81 30       	cpi	r24, 0x01	; 1
   157c2:	21 f4       	brne	.+8      	; 0x157cc <FMenuIdle+0x37e>
		    IsVoidTransaction=False;
   157c4:	10 92 9e 01 	sts	0x019E, r1
            sendMessage94();
   157c8:	0e 94 82 4d 	call	0x9b04	; 0x9b04 <sendMessage94>
		}


        //Message99 Detection 
        if (IsMessage99==True){
   157cc:	10 91 a2 01 	lds	r17, 0x01A2
   157d0:	11 30       	cpi	r17, 0x01	; 1
   157d2:	31 f4       	brne	.+12     	; 0x157e0 <FMenuIdle+0x392>
	        IsMessage99=False;
   157d4:	10 92 a2 01 	sts	0x01A2, r1
		    procMessage99();
   157d8:	0e 94 f3 41 	call	0x83e6	; 0x83e6 <procMessage99>
		    IsPrinting=True;
   157dc:	10 93 af 01 	sts	0x01AF, r17
		}
		//No Transaction
		if (IsNoTransaction==True){
   157e0:	80 91 ae 01 	lds	r24, 0x01AE
   157e4:	81 30       	cpi	r24, 0x01	; 1
   157e6:	41 f4       	brne	.+16     	; 0x157f8 <FMenuIdle+0x3aa>
			IsNoTransaction=False;
   157e8:	10 92 ae 01 	sts	0x01AE, r1
			lcd_printf(3, 1,PSTR("Tidak Ada Transaksi "));
   157ec:	83 e0       	ldi	r24, 0x03	; 3
   157ee:	61 e0       	ldi	r22, 0x01	; 1
   157f0:	49 ed       	ldi	r20, 0xD9	; 217
   157f2:	52 e2       	ldi	r21, 0x22	; 34
   157f4:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
		}
        
		//Display Idle
		if (stMenuIdle==miScan){//||(stMenuIdle=miWaitPlease)){ 
   157f8:	80 91 00 03 	lds	r24, 0x0300
   157fc:	81 30       	cpi	r24, 0x01	; 1
   157fe:	11 f4       	brne	.+4      	; 0x15804 <FMenuIdle+0x3b6>
		    DisplayIdle();			
   15800:	0e 94 81 72 	call	0xe502	; 0xe502 <DisplayIdle>
			}        

        //Display FreeMessage
		if (stMenuIdle==miScan){ 
   15804:	80 91 00 03 	lds	r24, 0x0300
   15808:	81 30       	cpi	r24, 0x01	; 1
   1580a:	59 f4       	brne	.+22     	; 0x15822 <FMenuIdle+0x3d4>
		    if (IsMessage09==True){
   1580c:	80 91 a6 01 	lds	r24, 0x01A6
   15810:	81 30       	cpi	r24, 0x01	; 1
   15812:	39 f4       	brne	.+14     	; 0x15822 <FMenuIdle+0x3d4>
			    IsMessage09=False;
   15814:	10 92 a6 01 	sts	0x01A6, r1
				procMessage09();
   15818:	0e 94 28 17 	call	0x2e50	; 0x2e50 <procMessage09>
				stMenuIdle=miRunViewFreeMessage;
   1581c:	83 e1       	ldi	r24, 0x13	; 19
   1581e:	80 93 00 03 	sts	0x0300, r24
			   }
			}

        //LocalAccount Scanning
		if ((stMenuIdle==miScan)&&(IsRFIDDetected==True)){
   15822:	80 91 00 03 	lds	r24, 0x0300
   15826:	81 30       	cpi	r24, 0x01	; 1
   15828:	71 f4       	brne	.+28     	; 0x15846 <FMenuIdle+0x3f8>
   1582a:	80 91 9b 01 	lds	r24, 0x019B
   1582e:	81 30       	cpi	r24, 0x01	; 1
   15830:	51 f4       	brne	.+20     	; 0x15846 <FMenuIdle+0x3f8>
		    IsRFIDDetected=False;
   15832:	10 92 9b 01 	sts	0x019B, r1
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   15836:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   15838:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   1583a:	82 e0       	ldi	r24, 0x02	; 2
   1583c:	80 93 bf 01 	sts	0x01BF, r24

        //LocalAccount Scanning
		if ((stMenuIdle==miScan)&&(IsRFIDDetected==True)){
		    IsRFIDDetected=False;
		    system_beep(2);           
			stMenuIdle=miRunLocalAccount;
   15840:	8e e0       	ldi	r24, 0x0E	; 14
   15842:	80 93 00 03 	sts	0x0300, r24
		}
        //Print Spooling
		if (IsMessage81==True){
   15846:	10 91 a9 01 	lds	r17, 0x01A9
   1584a:	11 30       	cpi	r17, 0x01	; 1
   1584c:	41 f4       	brne	.+16     	; 0x1585e <FMenuIdle+0x410>
		    IsMessage81=False;
   1584e:	10 92 a9 01 	sts	0x01A9, r1
			//Spooling HFCS 0000 : Header, Footer, Copy , Scrool [Copy:16x max]
			cmdPrint=procMessage81();
   15852:	0e 94 05 18 	call	0x300a	; 0x300a <procMessage81>
   15856:	80 93 b7 01 	sts	0x01B7, r24
			IsFreePrinting=True;
   1585a:	10 93 ab 01 	sts	0x01AB, r17
         }

    //SystemService
      systemGenerateReport();
   1585e:	0e 94 7a 34 	call	0x68f4	; 0x68f4 <systemGenerateReport>
      systemPrinting();
   15862:	0e 94 2a 5f 	call	0xbe54	; 0xbe54 <systemPrinting>
	  systemEDC();
	  systemConfigProtocol();
   15866:	0e 94 01 aa 	call	0x15402	; 0x15402 <systemConfigProtocol>
	  //systemGeniusProtocol(); //AKR-->Protocol disabled
}
   1586a:	1f 91       	pop	r17
   1586c:	08 95       	ret

0001586e <lcd_command>:
	lcd_command(0x0c);
	lcd_command(0x06);
}

void lcd_command(unsigned char __chr){
	_LCD_PORT = __chr & 0xF0;
   1586e:	98 2f       	mov	r25, r24
   15870:	90 7f       	andi	r25, 0xF0	; 240
   15872:	95 bb       	out	0x15, r25	; 21
	cbi(_LCD_PORT, _LCD_RS);
   15874:	ab 98       	cbi	0x15, 3	; 21
	sbi(_LCD_PORT, _LCD_E);
   15876:	a9 9a       	sbi	0x15, 1	; 21
   15878:	48 ee       	ldi	r20, 0xE8	; 232
   1587a:	53 e0       	ldi	r21, 0x03	; 3
   1587c:	fa 01       	movw	r30, r20
   1587e:	31 97       	sbiw	r30, 0x01	; 1
   15880:	f1 f7       	brne	.-4      	; 0x1587e <lcd_command+0x10>
	_LCD_BUSY;
	cbi(_LCD_PORT, _LCD_E);
   15882:	a9 98       	cbi	0x15, 1	; 21
   15884:	fa 01       	movw	r30, r20
   15886:	31 97       	sbiw	r30, 0x01	; 1
   15888:	f1 f7       	brne	.-4      	; 0x15886 <lcd_command+0x18>
	_LCD_BUSY;

	_LCD_PORT = (__chr & 0x0F) << 4;
   1588a:	28 2f       	mov	r18, r24
   1588c:	30 e0       	ldi	r19, 0x00	; 0
   1588e:	94 e0       	ldi	r25, 0x04	; 4
   15890:	22 0f       	add	r18, r18
   15892:	33 1f       	adc	r19, r19
   15894:	9a 95       	dec	r25
   15896:	e1 f7       	brne	.-8      	; 0x15890 <lcd_command+0x22>
   15898:	25 bb       	out	0x15, r18	; 21
	cbi(_LCD_PORT, _LCD_RS);
   1589a:	ab 98       	cbi	0x15, 3	; 21
	sbi(_LCD_PORT, _LCD_E);
   1589c:	a9 9a       	sbi	0x15, 1	; 21
   1589e:	fa 01       	movw	r30, r20
   158a0:	31 97       	sbiw	r30, 0x01	; 1
   158a2:	f1 f7       	brne	.-4      	; 0x158a0 <lcd_command+0x32>
	_LCD_BUSY;
	cbi(_LCD_PORT, _LCD_E);
   158a4:	a9 98       	cbi	0x15, 1	; 21
   158a6:	fa 01       	movw	r30, r20
   158a8:	31 97       	sbiw	r30, 0x01	; 1
   158aa:	f1 f7       	brne	.-4      	; 0x158a8 <lcd_command+0x3a>
	_LCD_BUSY;
	_LCD_BUSY;
	if (__chr==0x01) _delay_ms(50);
   158ac:	fa 01       	movw	r30, r20
   158ae:	31 97       	sbiw	r30, 0x01	; 1
   158b0:	f1 f7       	brne	.-4      	; 0x158ae <lcd_command+0x40>
   158b2:	81 30       	cpi	r24, 0x01	; 1
   158b4:	21 f4       	brne	.+8      	; 0x158be <lcd_command+0x50>
   158b6:	84 ed       	ldi	r24, 0xD4	; 212
   158b8:	90 e3       	ldi	r25, 0x30	; 48
   158ba:	01 97       	sbiw	r24, 0x01	; 1
   158bc:	f1 f7       	brne	.-4      	; 0x158ba <lcd_command+0x4c>
   158be:	08 95       	ret

000158c0 <lcd_init>:
   158c0:	86 ea       	ldi	r24, 0xA6	; 166
   158c2:	9e e0       	ldi	r25, 0x0E	; 14
   158c4:	01 97       	sbiw	r24, 0x01	; 1
   158c6:	f1 f7       	brne	.-4      	; 0x158c4 <lcd_init+0x4>

#define _LCD_BUSY	_delay_ms(4);

void lcd_init(void){
	_delay_ms(15);
	_LCD_PORT = 0x00;
   158c8:	15 ba       	out	0x15, r1	; 21
	_LCD_DDR |= (1 << _LCD_D7) | (1 << _LCD_D6) | (1 << _LCD_D5) | (1 << _LCD_D4);
   158ca:	84 b3       	in	r24, 0x14	; 20
   158cc:	80 6f       	ori	r24, 0xF0	; 240
   158ce:	84 bb       	out	0x14, r24	; 20
	_LCD_DDR |= (1 << _LCD_E) | (1 << _LCD_RW) | (1 << _LCD_RS);
   158d0:	84 b3       	in	r24, 0x14	; 20
   158d2:	8e 60       	ori	r24, 0x0E	; 14
   158d4:	84 bb       	out	0x14, r24	; 20

	_LCD_PORT = 0x30;
   158d6:	20 e3       	ldi	r18, 0x30	; 48
   158d8:	25 bb       	out	0x15, r18	; 21
	sbi(_LCD_PORT, _LCD_E);
   158da:	a9 9a       	sbi	0x15, 1	; 21
   158dc:	88 ee       	ldi	r24, 0xE8	; 232
   158de:	93 e0       	ldi	r25, 0x03	; 3
   158e0:	fc 01       	movw	r30, r24
   158e2:	31 97       	sbiw	r30, 0x01	; 1
   158e4:	f1 f7       	brne	.-4      	; 0x158e2 <lcd_init+0x22>
	_LCD_BUSY;
	cbi(_LCD_PORT, _LCD_E);
   158e6:	a9 98       	cbi	0x15, 1	; 21
   158e8:	fc 01       	movw	r30, r24
   158ea:	31 97       	sbiw	r30, 0x01	; 1
   158ec:	f1 f7       	brne	.-4      	; 0x158ea <lcd_init+0x2a>
	_LCD_BUSY;

	_LCD_PORT = 0x30;
   158ee:	25 bb       	out	0x15, r18	; 21
	sbi(_LCD_PORT, _LCD_E);
   158f0:	a9 9a       	sbi	0x15, 1	; 21
   158f2:	fc 01       	movw	r30, r24
   158f4:	31 97       	sbiw	r30, 0x01	; 1
   158f6:	f1 f7       	brne	.-4      	; 0x158f4 <lcd_init+0x34>
	_LCD_BUSY;
	cbi(_LCD_PORT, _LCD_E);
   158f8:	a9 98       	cbi	0x15, 1	; 21
   158fa:	fc 01       	movw	r30, r24
   158fc:	31 97       	sbiw	r30, 0x01	; 1
   158fe:	f1 f7       	brne	.-4      	; 0x158fc <lcd_init+0x3c>
	_LCD_BUSY;

	_LCD_PORT = 0x30;
   15900:	25 bb       	out	0x15, r18	; 21
	sbi(_LCD_PORT, _LCD_E);
   15902:	a9 9a       	sbi	0x15, 1	; 21
   15904:	fc 01       	movw	r30, r24
   15906:	31 97       	sbiw	r30, 0x01	; 1
   15908:	f1 f7       	brne	.-4      	; 0x15906 <lcd_init+0x46>
	_LCD_BUSY;
	cbi(_LCD_PORT, _LCD_E);
   1590a:	a9 98       	cbi	0x15, 1	; 21
   1590c:	fc 01       	movw	r30, r24
   1590e:	31 97       	sbiw	r30, 0x01	; 1
   15910:	f1 f7       	brne	.-4      	; 0x1590e <lcd_init+0x4e>
	_LCD_BUSY;

	_LCD_PORT = 0x20;
   15912:	20 e2       	ldi	r18, 0x20	; 32
   15914:	25 bb       	out	0x15, r18	; 21
	sbi(_LCD_PORT, _LCD_E);
   15916:	a9 9a       	sbi	0x15, 1	; 21
   15918:	fc 01       	movw	r30, r24
   1591a:	31 97       	sbiw	r30, 0x01	; 1
   1591c:	f1 f7       	brne	.-4      	; 0x1591a <lcd_init+0x5a>
	_LCD_BUSY;
	cbi(_LCD_PORT, _LCD_E);
   1591e:	a9 98       	cbi	0x15, 1	; 21
   15920:	01 97       	sbiw	r24, 0x01	; 1
   15922:	f1 f7       	brne	.-4      	; 0x15920 <lcd_init+0x60>
	_LCD_BUSY;

	_LIGHT_PORT = 0x01;
   15924:	81 e0       	ldi	r24, 0x01	; 1
   15926:	80 93 65 00 	sts	0x0065, r24
	_LIGHT_DDR |= (1 << _LIGHT_PIN);
   1592a:	e4 e6       	ldi	r30, 0x64	; 100
   1592c:	f0 e0       	ldi	r31, 0x00	; 0
   1592e:	80 81       	ld	r24, Z
   15930:	82 60       	ori	r24, 0x02	; 2
   15932:	80 83       	st	Z, r24

	lcd_command(0x28);
   15934:	88 e2       	ldi	r24, 0x28	; 40
   15936:	0e 94 37 ac 	call	0x1586e	; 0x1586e <lcd_command>
	lcd_command(0x0c);
   1593a:	8c e0       	ldi	r24, 0x0C	; 12
   1593c:	0e 94 37 ac 	call	0x1586e	; 0x1586e <lcd_command>
	lcd_command(0x06);
   15940:	86 e0       	ldi	r24, 0x06	; 6
   15942:	0e 94 37 ac 	call	0x1586e	; 0x1586e <lcd_command>
}
   15946:	08 95       	ret

00015948 <_lcd>:
	if (__chr==0x01) _delay_ms(50);

}

void _lcd(unsigned char __chr){
	_LCD_PORT =((__chr & 0xF0));
   15948:	28 2f       	mov	r18, r24
   1594a:	20 7f       	andi	r18, 0xF0	; 240
   1594c:	25 bb       	out	0x15, r18	; 21
	sbi(_LCD_PORT, _LCD_RS);
   1594e:	ab 9a       	sbi	0x15, 3	; 21
	sbi(_LCD_PORT, _LCD_E);
   15950:	a9 9a       	sbi	0x15, 1	; 21
	cbi(_LCD_PORT, _LCD_E);
   15952:	a9 98       	cbi	0x15, 1	; 21

	_LCD_PORT = (((__chr & 0x0F) << 4));
   15954:	90 e0       	ldi	r25, 0x00	; 0
   15956:	24 e0       	ldi	r18, 0x04	; 4
   15958:	88 0f       	add	r24, r24
   1595a:	99 1f       	adc	r25, r25
   1595c:	2a 95       	dec	r18
   1595e:	e1 f7       	brne	.-8      	; 0x15958 <_lcd+0x10>
   15960:	85 bb       	out	0x15, r24	; 21
	sbi(_LCD_PORT, _LCD_RS);
   15962:	ab 9a       	sbi	0x15, 3	; 21
	sbi(_LCD_PORT, _LCD_E);
   15964:	a9 9a       	sbi	0x15, 1	; 21
	cbi(_LCD_PORT, _LCD_E);
   15966:	a9 98       	cbi	0x15, 1	; 21
   15968:	88 ee       	ldi	r24, 0xE8	; 232
   1596a:	93 e0       	ldi	r25, 0x03	; 3
   1596c:	01 97       	sbiw	r24, 0x01	; 1
   1596e:	f1 f7       	brne	.-4      	; 0x1596c <_lcd+0x24>
	_LCD_BUSY;
	_delay_ms(1);
}
   15970:	8a ef       	ldi	r24, 0xFA	; 250
   15972:	90 e0       	ldi	r25, 0x00	; 0
   15974:	01 97       	sbiw	r24, 0x01	; 1
   15976:	f1 f7       	brne	.-4      	; 0x15974 <_lcd+0x2c>
   15978:	08 95       	ret

0001597a <lcd_string>:
     lcd_printf(2,1,PSTR("                    "));
     lcd_printf(3,1,PSTR("                    "));
     lcd_printf(4,1,PSTR("                    "));
}

void lcd_string(char *__string){
   1597a:	cf 93       	push	r28
   1597c:	df 93       	push	r29
   1597e:	ec 01       	movw	r28, r24
   15980:	03 c0       	rjmp	.+6      	; 0x15988 <lcd_string+0xe>
	while(*__string)
		_lcd(*__string++);
   15982:	21 96       	adiw	r28, 0x01	; 1
   15984:	0e 94 a4 ac 	call	0x15948	; 0x15948 <_lcd>
     lcd_printf(3,1,PSTR("                    "));
     lcd_printf(4,1,PSTR("                    "));
}

void lcd_string(char *__string){
	while(*__string)
   15988:	88 81       	ld	r24, Y
   1598a:	88 23       	and	r24, r24
   1598c:	d1 f7       	brne	.-12     	; 0x15982 <lcd_string+0x8>
		_lcd(*__string++);
}
   1598e:	df 91       	pop	r29
   15990:	cf 91       	pop	r28
   15992:	08 95       	ret

00015994 <lcd_xy>:

void lcd_xy(unsigned char __x, unsigned char __y){
	switch(__x){
   15994:	82 30       	cpi	r24, 0x02	; 2
   15996:	69 f0       	breq	.+26     	; 0x159b2 <lcd_xy+0x1e>
   15998:	83 30       	cpi	r24, 0x03	; 3
   1599a:	18 f4       	brcc	.+6      	; 0x159a2 <lcd_xy+0xe>
   1599c:	81 30       	cpi	r24, 0x01	; 1
   1599e:	a9 f4       	brne	.+42     	; 0x159ca <lcd_xy+0x36>
   159a0:	05 c0       	rjmp	.+10     	; 0x159ac <lcd_xy+0x18>
   159a2:	83 30       	cpi	r24, 0x03	; 3
   159a4:	49 f0       	breq	.+18     	; 0x159b8 <lcd_xy+0x24>
   159a6:	84 30       	cpi	r24, 0x04	; 4
   159a8:	81 f4       	brne	.+32     	; 0x159ca <lcd_xy+0x36>
   159aa:	0b c0       	rjmp	.+22     	; 0x159c2 <lcd_xy+0x2e>
		case 1:
			lcd_command(0x80 + __y - 1);
   159ac:	86 2f       	mov	r24, r22
   159ae:	81 58       	subi	r24, 0x81	; 129
   159b0:	05 c0       	rjmp	.+10     	; 0x159bc <lcd_xy+0x28>
			break;
		case 2:
			lcd_command(0xC0 + __y - 1);
   159b2:	86 2f       	mov	r24, r22
   159b4:	81 54       	subi	r24, 0x41	; 65
   159b6:	02 c0       	rjmp	.+4      	; 0x159bc <lcd_xy+0x28>
			break;
		case 3:
			lcd_command(0x94 + __y - 1);
   159b8:	86 2f       	mov	r24, r22
   159ba:	8d 56       	subi	r24, 0x6D	; 109
   159bc:	0e 94 37 ac 	call	0x1586e	; 0x1586e <lcd_command>
   159c0:	08 95       	ret
			break;
		case 4:
			lcd_command(0xD4 + __y - 1);
   159c2:	86 2f       	mov	r24, r22
   159c4:	8d 52       	subi	r24, 0x2D	; 45
   159c6:	0e 94 37 ac 	call	0x1586e	; 0x1586e <lcd_command>
   159ca:	08 95       	ret

000159cc <lcd_print>:
	 for (i=0;i<strlen(string);i++){
          string[i]=0;
	 }     
}

void lcd_print(unsigned char __x, unsigned char __y, char *__string){
   159cc:	df 92       	push	r13
   159ce:	ef 92       	push	r14
   159d0:	ff 92       	push	r15
   159d2:	0f 93       	push	r16
   159d4:	1f 93       	push	r17
   159d6:	cf 93       	push	r28
   159d8:	df 93       	push	r29
   159da:	06 2f       	mov	r16, r22
   159dc:	d4 2e       	mov	r13, r20
   159de:	15 2f       	mov	r17, r21
    char yPos,iPos=0;//Modified by Iyan string [20] maks
	lcd_xy(__x, __y);
   159e0:	0e 94 ca ac 	call	0x15994	; 0x15994 <lcd_xy>
   159e4:	2d 2d       	mov	r18, r13
   159e6:	31 2f       	mov	r19, r17
   159e8:	c9 01       	movw	r24, r18
   159ea:	ec 01       	movw	r28, r24
	iPos=0;
	while((*__string)&&(iPos<=(20-__y))){
   159ec:	34 e1       	ldi	r19, 0x14	; 20
   159ee:	e3 2e       	mov	r14, r19
   159f0:	f1 2c       	mov	r15, r1
   159f2:	e0 1a       	sub	r14, r16
   159f4:	f1 08       	sbc	r15, r1
   159f6:	04 c0       	rjmp	.+8      	; 0x15a00 <lcd_print+0x34>
		_lcd(*__string);__string++;
   159f8:	82 2f       	mov	r24, r18
   159fa:	0e 94 a4 ac 	call	0x15948	; 0x15948 <_lcd>
   159fe:	21 96       	adiw	r28, 0x01	; 1
   15a00:	9e 01       	movw	r18, r28
   15a02:	2d 19       	sub	r18, r13
   15a04:	82 2f       	mov	r24, r18

void lcd_print(unsigned char __x, unsigned char __y, char *__string){
    char yPos,iPos=0;//Modified by Iyan string [20] maks
	lcd_xy(__x, __y);
	iPos=0;
	while((*__string)&&(iPos<=(20-__y))){
   15a06:	28 81       	ld	r18, Y
   15a08:	22 23       	and	r18, r18
   15a0a:	21 f0       	breq	.+8      	; 0x15a14 <lcd_print+0x48>
   15a0c:	90 e0       	ldi	r25, 0x00	; 0
   15a0e:	e8 16       	cp	r14, r24
   15a10:	f9 06       	cpc	r15, r25
   15a12:	94 f7       	brge	.-28     	; 0x159f8 <lcd_print+0x2c>
		_lcd(*__string);__string++;
		iPos++;
		}    
}
   15a14:	df 91       	pop	r29
   15a16:	cf 91       	pop	r28
   15a18:	1f 91       	pop	r17
   15a1a:	0f 91       	pop	r16
   15a1c:	ff 90       	pop	r15
   15a1e:	ef 90       	pop	r14
   15a20:	df 90       	pop	r13
   15a22:	08 95       	ret

00015a24 <lcd_printf>:

void lcd_printf(unsigned char __x, unsigned char __y, char *__string){
   15a24:	df 92       	push	r13
   15a26:	ef 92       	push	r14
   15a28:	ff 92       	push	r15
   15a2a:	0f 93       	push	r16
   15a2c:	1f 93       	push	r17
   15a2e:	cf 93       	push	r28
   15a30:	df 93       	push	r29
   15a32:	06 2f       	mov	r16, r22
   15a34:	d4 2e       	mov	r13, r20
   15a36:	15 2f       	mov	r17, r21
    char iPos=0;
	lcd_xy(__x, __y);
   15a38:	0e 94 ca ac 	call	0x15994	; 0x15994 <lcd_xy>
   15a3c:	8d 2d       	mov	r24, r13
   15a3e:	91 2f       	mov	r25, r17
   15a40:	fc 01       	movw	r30, r24
   15a42:	ef 01       	movw	r28, r30
	iPos=0;
	while((pgm_read_byte(&(*__string)))&&(iPos<=(20-__y))){
   15a44:	44 e1       	ldi	r20, 0x14	; 20
   15a46:	e4 2e       	mov	r14, r20
   15a48:	f1 2c       	mov	r15, r1
   15a4a:	e0 1a       	sub	r14, r16
   15a4c:	f1 08       	sbc	r15, r1
   15a4e:	04 c0       	rjmp	.+8      	; 0x15a58 <lcd_printf+0x34>
		_lcd(pgm_read_byte(&(*__string)));
   15a50:	82 2f       	mov	r24, r18
   15a52:	0e 94 a4 ac 	call	0x15948	; 0x15948 <_lcd>
		__string++;
   15a56:	21 96       	adiw	r28, 0x01	; 1
   15a58:	9e 01       	movw	r18, r28
   15a5a:	2d 19       	sub	r18, r13
   15a5c:	82 2f       	mov	r24, r18

void lcd_printf(unsigned char __x, unsigned char __y, char *__string){
    char iPos=0;
	lcd_xy(__x, __y);
	iPos=0;
	while((pgm_read_byte(&(*__string)))&&(iPos<=(20-__y))){
   15a5e:	fe 01       	movw	r30, r28
   15a60:	24 91       	lpm	r18, Z+
   15a62:	22 23       	and	r18, r18
   15a64:	21 f0       	breq	.+8      	; 0x15a6e <lcd_printf+0x4a>
   15a66:	90 e0       	ldi	r25, 0x00	; 0
   15a68:	e8 16       	cp	r14, r24
   15a6a:	f9 06       	cpc	r15, r25
   15a6c:	8c f7       	brge	.-30     	; 0x15a50 <lcd_printf+0x2c>
		_lcd(pgm_read_byte(&(*__string)));
		__string++;
		iPos++;
		}
}
   15a6e:	df 91       	pop	r29
   15a70:	cf 91       	pop	r28
   15a72:	1f 91       	pop	r17
   15a74:	0f 91       	pop	r16
   15a76:	ff 90       	pop	r15
   15a78:	ef 90       	pop	r14
   15a7a:	df 90       	pop	r13
   15a7c:	08 95       	ret

00015a7e <lcd_clear>:
	_LCD_BUSY;
	_delay_ms(1);
}

void lcd_clear(){
     lcd_printf(1,1,PSTR("                    "));
   15a7e:	81 e0       	ldi	r24, 0x01	; 1
   15a80:	61 e0       	ldi	r22, 0x01	; 1
   15a82:	49 ef       	ldi	r20, 0xF9	; 249
   15a84:	53 e2       	ldi	r21, 0x23	; 35
   15a86:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
     lcd_printf(2,1,PSTR("                    "));
   15a8a:	82 e0       	ldi	r24, 0x02	; 2
   15a8c:	61 e0       	ldi	r22, 0x01	; 1
   15a8e:	44 ee       	ldi	r20, 0xE4	; 228
   15a90:	53 e2       	ldi	r21, 0x23	; 35
   15a92:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
     lcd_printf(3,1,PSTR("                    "));
   15a96:	83 e0       	ldi	r24, 0x03	; 3
   15a98:	61 e0       	ldi	r22, 0x01	; 1
   15a9a:	4f ec       	ldi	r20, 0xCF	; 207
   15a9c:	53 e2       	ldi	r21, 0x23	; 35
   15a9e:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
     lcd_printf(4,1,PSTR("                    "));
   15aa2:	84 e0       	ldi	r24, 0x04	; 4
   15aa4:	61 e0       	ldi	r22, 0x01	; 1
   15aa6:	4a eb       	ldi	r20, 0xBA	; 186
   15aa8:	53 e2       	ldi	r21, 0x23	; 35
   15aaa:	0e 94 12 ad 	call	0x15a24	; 0x15a24 <lcd_printf>
}
   15aae:	08 95       	ret

00015ab0 <lcd_put>:
		__string++;
		iPos++;
		}
}

void lcd_put(unsigned char __x, unsigned char __y, unsigned char __chr){
   15ab0:	1f 93       	push	r17
   15ab2:	14 2f       	mov	r17, r20
	lcd_xy(__x, __y);
   15ab4:	0e 94 ca ac 	call	0x15994	; 0x15994 <lcd_xy>
	_lcd(__chr);
   15ab8:	81 2f       	mov	r24, r17
   15aba:	0e 94 a4 ac 	call	0x15948	; 0x15948 <_lcd>
}
   15abe:	1f 91       	pop	r17
   15ac0:	08 95       	ret

00015ac2 <lcd_cgram>:

void lcd_cgram(unsigned char location, char *ptr){
   15ac2:	0f 93       	push	r16
   15ac4:	1f 93       	push	r17
   15ac6:	cf 93       	push	r28
   15ac8:	df 93       	push	r29
   15aca:	8b 01       	movw	r16, r22
	unsigned char i;
    if(location < 8){
   15acc:	88 30       	cpi	r24, 0x08	; 8
   15ace:	90 f4       	brcc	.+36     	; 0x15af4 <lcd_cgram+0x32>
		lcd_command(0x40 + (location * 8));
   15ad0:	88 0f       	add	r24, r24
   15ad2:	88 0f       	add	r24, r24
   15ad4:	88 0f       	add	r24, r24
   15ad6:	80 5c       	subi	r24, 0xC0	; 192
   15ad8:	0e 94 37 ac 	call	0x1586e	; 0x1586e <lcd_command>
   15adc:	c0 e0       	ldi	r28, 0x00	; 0
   15ade:	d0 e0       	ldi	r29, 0x00	; 0
		for(i = 0; i < 8; i++)
			_lcd(ptr[i]);
   15ae0:	f8 01       	movw	r30, r16
   15ae2:	ec 0f       	add	r30, r28
   15ae4:	fd 1f       	adc	r31, r29
   15ae6:	80 81       	ld	r24, Z
   15ae8:	0e 94 a4 ac 	call	0x15948	; 0x15948 <_lcd>
   15aec:	21 96       	adiw	r28, 0x01	; 1

void lcd_cgram(unsigned char location, char *ptr){
	unsigned char i;
    if(location < 8){
		lcd_command(0x40 + (location * 8));
		for(i = 0; i < 8; i++)
   15aee:	c8 30       	cpi	r28, 0x08	; 8
   15af0:	d1 05       	cpc	r29, r1
   15af2:	b1 f7       	brne	.-20     	; 0x15ae0 <lcd_cgram+0x1e>
			_lcd(ptr[i]);
	}
}
   15af4:	df 91       	pop	r29
   15af6:	cf 91       	pop	r28
   15af8:	1f 91       	pop	r17
   15afa:	0f 91       	pop	r16
   15afc:	08 95       	ret

00015afe <ClearMem>:
			lcd_command(0xD4 + __y - 1);
			break;
	}
}

void ClearMem(char *string){
   15afe:	cf 93       	push	r28
   15b00:	df 93       	push	r29
   15b02:	20 e0       	ldi	r18, 0x00	; 0
   15b04:	04 c0       	rjmp	.+8      	; 0x15b0e <ClearMem+0x10>
     char i;
	 for (i=0;i<strlen(string);i++){
          string[i]=0;
   15b06:	c8 0f       	add	r28, r24
   15b08:	d9 1f       	adc	r29, r25
   15b0a:	18 82       	st	Y, r1
	}
}

void ClearMem(char *string){
     char i;
	 for (i=0;i<strlen(string);i++){
   15b0c:	2f 5f       	subi	r18, 0xFF	; 255
   15b0e:	c2 2f       	mov	r28, r18
   15b10:	d0 e0       	ldi	r29, 0x00	; 0
   15b12:	fc 01       	movw	r30, r24
   15b14:	01 90       	ld	r0, Z+
   15b16:	00 20       	and	r0, r0
   15b18:	e9 f7       	brne	.-6      	; 0x15b14 <ClearMem+0x16>
   15b1a:	31 97       	sbiw	r30, 0x01	; 1
   15b1c:	e8 1b       	sub	r30, r24
   15b1e:	f9 0b       	sbc	r31, r25
   15b20:	ce 17       	cp	r28, r30
   15b22:	df 07       	cpc	r29, r31
   15b24:	80 f3       	brcs	.-32     	; 0x15b06 <ClearMem+0x8>
          string[i]=0;
	 }     
}
   15b26:	df 91       	pop	r29
   15b28:	cf 91       	pop	r28
   15b2a:	08 95       	ret

00015b2c <_key_hit>:
													 {'7', 'P', 'Q', 'R', 'S', '\0'},
											         {'8', 'T', 'U', 'V', '\0'}, 
													 {'9', 'W', 'X', 'Y', 'Z', '\0'}}};
const unsigned char __maxchar[10] PROGMEM = {2, 4, 3, 3, 3, 3, 3, 4, 3, 4};

char _key_hit(void){
   15b2c:	df 93       	push	r29
   15b2e:	cf 93       	push	r28
   15b30:	00 d0       	rcall	.+0      	; 0x15b32 <_key_hit+0x6>
   15b32:	00 d0       	rcall	.+0      	; 0x15b34 <_key_hit+0x8>
   15b34:	cd b7       	in	r28, 0x3d	; 61
   15b36:	de b7       	in	r29, 0x3e	; 62
	unsigned char	i, keyhit=0x00;
	unsigned char	outmap[4] = {0xef, 0xdf, 0xbf, 0x7f};
   15b38:	8f ee       	ldi	r24, 0xEF	; 239
   15b3a:	89 83       	std	Y+1, r24	; 0x01
   15b3c:	8f ed       	ldi	r24, 0xDF	; 223
   15b3e:	8a 83       	std	Y+2, r24	; 0x02
   15b40:	8f eb       	ldi	r24, 0xBF	; 191
   15b42:	8b 83       	std	Y+3, r24	; 0x03
   15b44:	8f e7       	ldi	r24, 0x7F	; 127
   15b46:	8c 83       	std	Y+4, r24	; 0x04
   15b48:	de 01       	movw	r26, r28
   15b4a:	11 96       	adiw	r26, 0x01	; 1
   15b4c:	2a ef       	ldi	r18, 0xFA	; 250
   15b4e:	30 e0       	ldi	r19, 0x00	; 0

	for(i=0; i<4; i++){
   15b50:	ae 01       	movw	r20, r28
   15b52:	4b 5f       	subi	r20, 0xFB	; 251
   15b54:	5f 4f       	sbci	r21, 0xFF	; 255
   15b56:	c9 01       	movw	r24, r18
   15b58:	01 97       	sbiw	r24, 0x01	; 1
   15b5a:	f1 f7       	brne	.-4      	; 0x15b58 <_key_hit+0x2c>
		_delay_ms(1);
		_KEY_PORT = outmap[i];
   15b5c:	8c 91       	ld	r24, X
   15b5e:	80 93 62 00 	sts	0x0062, r24
   15b62:	f9 01       	movw	r30, r18
   15b64:	31 97       	sbiw	r30, 0x01	; 1
   15b66:	f1 f7       	brne	.-4      	; 0x15b64 <_key_hit+0x38>
		_delay_ms(1);
		keyhit = _KEY_MATRIX;
   15b68:	90 b1       	in	r25, 0x00	; 0
		if (keyhit!=outmap[i]) 
   15b6a:	98 17       	cp	r25, r24
   15b6c:	21 f4       	brne	.+8      	; 0x15b76 <_key_hit+0x4a>
		    break;
   15b6e:	11 96       	adiw	r26, 0x01	; 1

char _key_hit(void){
	unsigned char	i, keyhit=0x00;
	unsigned char	outmap[4] = {0xef, 0xdf, 0xbf, 0x7f};

	for(i=0; i<4; i++){
   15b70:	a4 17       	cp	r26, r20
   15b72:	b5 07       	cpc	r27, r21
   15b74:	81 f7       	brne	.-32     	; 0x15b56 <_key_hit+0x2a>
		keyhit = _KEY_MATRIX;
		if (keyhit!=outmap[i]) 
		    break;
	}
	return keyhit;
}
   15b76:	89 2f       	mov	r24, r25
   15b78:	0f 90       	pop	r0
   15b7a:	0f 90       	pop	r0
   15b7c:	0f 90       	pop	r0
   15b7e:	0f 90       	pop	r0
   15b80:	cf 91       	pop	r28
   15b82:	df 91       	pop	r29
   15b84:	08 95       	ret

00015b86 <_key_crr>:

char _key_crr(char __key){
	if(	__key != _KEY_1 && __key != _KEY_2 &&
   15b86:	8e 3e       	cpi	r24, 0xEE	; 238
   15b88:	f9 f0       	breq	.+62     	; 0x15bc8 <_key_crr+0x42>
   15b8a:	8e 3d       	cpi	r24, 0xDE	; 222
   15b8c:	e9 f0       	breq	.+58     	; 0x15bc8 <_key_crr+0x42>
   15b8e:	8e 3b       	cpi	r24, 0xBE	; 190
   15b90:	d9 f0       	breq	.+54     	; 0x15bc8 <_key_crr+0x42>
   15b92:	8d 3e       	cpi	r24, 0xED	; 237
   15b94:	c9 f0       	breq	.+50     	; 0x15bc8 <_key_crr+0x42>
   15b96:	8d 3d       	cpi	r24, 0xDD	; 221
   15b98:	b9 f0       	breq	.+46     	; 0x15bc8 <_key_crr+0x42>
   15b9a:	8d 3b       	cpi	r24, 0xBD	; 189
   15b9c:	a9 f0       	breq	.+42     	; 0x15bc8 <_key_crr+0x42>
   15b9e:	8b 3e       	cpi	r24, 0xEB	; 235
   15ba0:	99 f0       	breq	.+38     	; 0x15bc8 <_key_crr+0x42>
   15ba2:	8b 3d       	cpi	r24, 0xDB	; 219
   15ba4:	89 f0       	breq	.+34     	; 0x15bc8 <_key_crr+0x42>
   15ba6:	8b 3b       	cpi	r24, 0xBB	; 187
   15ba8:	79 f0       	breq	.+30     	; 0x15bc8 <_key_crr+0x42>
   15baa:	87 3d       	cpi	r24, 0xD7	; 215
   15bac:	69 f0       	breq	.+26     	; 0x15bc8 <_key_crr+0x42>
   15bae:	87 3e       	cpi	r24, 0xE7	; 231
   15bb0:	59 f0       	breq	.+22     	; 0x15bc8 <_key_crr+0x42>
   15bb2:	87 3b       	cpi	r24, 0xB7	; 183
   15bb4:	49 f0       	breq	.+18     	; 0x15bc8 <_key_crr+0x42>
   15bb6:	8e 37       	cpi	r24, 0x7E	; 126
   15bb8:	39 f0       	breq	.+14     	; 0x15bc8 <_key_crr+0x42>
   15bba:	8d 37       	cpi	r24, 0x7D	; 125
   15bbc:	29 f0       	breq	.+10     	; 0x15bc8 <_key_crr+0x42>
   15bbe:	8b 37       	cpi	r24, 0x7B	; 123
   15bc0:	19 f0       	breq	.+6      	; 0x15bc8 <_key_crr+0x42>
   15bc2:	87 37       	cpi	r24, 0x77	; 119
   15bc4:	09 f0       	breq	.+2      	; 0x15bc8 <_key_crr+0x42>
   15bc6:	80 e0       	ldi	r24, 0x00	; 0
		__key != _KEY_CANCEL && __key != _KEY_ENTER &&
		__key != _KEY_TIKET && __key != _KEY_MENU &&
		__key != _KEY_SHIFT && __key != _KEY_CLEAR)
		return _KEY_NULL;
	return __key;
}
   15bc8:	08 95       	ret

00015bca <_key_btn>:

char _key_btn(char __key){
	char __keychar = 0;
	
	switch (__key){
   15bca:	8e 3b       	cpi	r24, 0xBE	; 190
   15bcc:	91 f1       	breq	.+100    	; 0x15c32 <_key_btn+0x68>
   15bce:	8f 3b       	cpi	r24, 0xBF	; 191
   15bd0:	a8 f4       	brcc	.+42     	; 0x15bfc <_key_btn+0x32>
   15bd2:	8e 37       	cpi	r24, 0x7E	; 126
   15bd4:	09 f4       	brne	.+2      	; 0x15bd8 <_key_btn+0xe>
   15bd6:	41 c0       	rjmp	.+130    	; 0x15c5a <_key_btn+0x90>
   15bd8:	8f 37       	cpi	r24, 0x7F	; 127
   15bda:	48 f4       	brcc	.+18     	; 0x15bee <_key_btn+0x24>
   15bdc:	8b 37       	cpi	r24, 0x7B	; 123
   15bde:	09 f4       	brne	.+2      	; 0x15be2 <_key_btn+0x18>
   15be0:	40 c0       	rjmp	.+128    	; 0x15c62 <_key_btn+0x98>
   15be2:	8d 37       	cpi	r24, 0x7D	; 125
   15be4:	e1 f1       	breq	.+120    	; 0x15c5e <_key_btn+0x94>
   15be6:	87 37       	cpi	r24, 0x77	; 119
   15be8:	09 f0       	breq	.+2      	; 0x15bec <_key_btn+0x22>
   15bea:	3f c0       	rjmp	.+126    	; 0x15c6a <_key_btn+0xa0>
   15bec:	3c c0       	rjmp	.+120    	; 0x15c66 <_key_btn+0x9c>
   15bee:	8b 3b       	cpi	r24, 0xBB	; 187
   15bf0:	61 f1       	breq	.+88     	; 0x15c4a <_key_btn+0x80>
   15bf2:	8d 3b       	cpi	r24, 0xBD	; 189
   15bf4:	21 f1       	breq	.+72     	; 0x15c3e <_key_btn+0x74>
   15bf6:	87 3b       	cpi	r24, 0xB7	; 183
   15bf8:	c1 f5       	brne	.+112    	; 0x15c6a <_key_btn+0xa0>
   15bfa:	2d c0       	rjmp	.+90     	; 0x15c56 <_key_btn+0x8c>
   15bfc:	8e 3d       	cpi	r24, 0xDE	; 222
   15bfe:	a9 f0       	breq	.+42     	; 0x15c2a <_key_btn+0x60>
   15c00:	8f 3d       	cpi	r24, 0xDF	; 223
   15c02:	38 f4       	brcc	.+14     	; 0x15c12 <_key_btn+0x48>
   15c04:	8b 3d       	cpi	r24, 0xDB	; 219
   15c06:	f9 f0       	breq	.+62     	; 0x15c46 <_key_btn+0x7c>
   15c08:	8d 3d       	cpi	r24, 0xDD	; 221
   15c0a:	b9 f0       	breq	.+46     	; 0x15c3a <_key_btn+0x70>
   15c0c:	87 3d       	cpi	r24, 0xD7	; 215
   15c0e:	69 f5       	brne	.+90     	; 0x15c6a <_key_btn+0xa0>
   15c10:	1e c0       	rjmp	.+60     	; 0x15c4e <_key_btn+0x84>
   15c12:	8b 3e       	cpi	r24, 0xEB	; 235
   15c14:	b1 f0       	breq	.+44     	; 0x15c42 <_key_btn+0x78>
   15c16:	8c 3e       	cpi	r24, 0xEC	; 236
   15c18:	18 f4       	brcc	.+6      	; 0x15c20 <_key_btn+0x56>
   15c1a:	87 3e       	cpi	r24, 0xE7	; 231
   15c1c:	31 f5       	brne	.+76     	; 0x15c6a <_key_btn+0xa0>
   15c1e:	19 c0       	rjmp	.+50     	; 0x15c52 <_key_btn+0x88>
   15c20:	8d 3e       	cpi	r24, 0xED	; 237
   15c22:	49 f0       	breq	.+18     	; 0x15c36 <_key_btn+0x6c>
   15c24:	8e 3e       	cpi	r24, 0xEE	; 238
   15c26:	09 f5       	brne	.+66     	; 0x15c6a <_key_btn+0xa0>
   15c28:	02 c0       	rjmp	.+4      	; 0x15c2e <_key_btn+0x64>
   15c2a:	82 e3       	ldi	r24, 0x32	; 50
   15c2c:	08 95       	ret
   15c2e:	81 e3       	ldi	r24, 0x31	; 49
   15c30:	08 95       	ret
   15c32:	83 e3       	ldi	r24, 0x33	; 51
   15c34:	08 95       	ret
		case 0xDE:
			__keychar = 0x32; //2
			break;
		case 0xBE:
			__keychar = 0x33; //3
			break;
   15c36:	84 e3       	ldi	r24, 0x34	; 52
   15c38:	08 95       	ret
		case 0xED:
			__keychar = 0x34; //4
			break;
   15c3a:	85 e3       	ldi	r24, 0x35	; 53
   15c3c:	08 95       	ret
		case 0xDD:
			__keychar = 0x35; //5
			break;
   15c3e:	86 e3       	ldi	r24, 0x36	; 54
   15c40:	08 95       	ret
		case 0xBD:
			__keychar = 0x36; //6
			break;
   15c42:	87 e3       	ldi	r24, 0x37	; 55
   15c44:	08 95       	ret
		case 0xEB:
			__keychar = 0x37; //7
			break;
   15c46:	88 e3       	ldi	r24, 0x38	; 56
   15c48:	08 95       	ret
		case 0xDB:
			__keychar = 0x38; //8
			break;
   15c4a:	89 e3       	ldi	r24, 0x39	; 57
   15c4c:	08 95       	ret
		case 0xBB:
			__keychar = 0x39; //9
			break;
   15c4e:	80 e3       	ldi	r24, 0x30	; 48
   15c50:	08 95       	ret
		case 0xD7:
			__keychar = 0x30; //0
			break;
   15c52:	8a e2       	ldi	r24, 0x2A	; 42
   15c54:	08 95       	ret
		case 0xE7:
			__keychar = 0x2a; //*
			break;
   15c56:	83 e2       	ldi	r24, 0x23	; 35
   15c58:	08 95       	ret
		case 0xB7:
			__keychar = 0x23; //#
			break;
   15c5a:	81 ef       	ldi	r24, 0xF1	; 241
   15c5c:	08 95       	ret
		case 0x7E:
			__keychar = 0xF1; //Menu 1
			break;
   15c5e:	82 ef       	ldi	r24, 0xF2	; 242
   15c60:	08 95       	ret
		case 0x7D:
			__keychar = 0xF2; //Menu 2
			break;
   15c62:	83 ef       	ldi	r24, 0xF3	; 243
   15c64:	08 95       	ret
		case 0x7B:
			__keychar = 0xF3; //Menu 3
			break;
   15c66:	84 ef       	ldi	r24, 0xF4	; 244
   15c68:	08 95       	ret
		case 0x77:
			__keychar = 0xF4; //Menu 4
			break;
   15c6a:	80 e0       	ldi	r24, 0x00	; 0
			__keychar = 0x00;
			break;

	}
	return __keychar;
}
   15c6c:	08 95       	ret

00015c6e <_table_alphanum>:
	}
	_PAD_1st;
	return __key;
}

char _table_alphanum(char __caps, char __key, char __hit){
   15c6e:	98 2f       	mov	r25, r24
unsigned char __retchar = 0;

	switch(__key){
   15c70:	6d 3d       	cpi	r22, 0xDD	; 221
   15c72:	11 f1       	breq	.+68     	; 0x15cb8 <_table_alphanum+0x4a>
   15c74:	6e 3d       	cpi	r22, 0xDE	; 222
   15c76:	60 f4       	brcc	.+24     	; 0x15c90 <_table_alphanum+0x22>
   15c78:	6d 3b       	cpi	r22, 0xBD	; 189
   15c7a:	01 f1       	breq	.+64     	; 0x15cbc <_table_alphanum+0x4e>
   15c7c:	6e 3b       	cpi	r22, 0xBE	; 190
   15c7e:	18 f4       	brcc	.+6      	; 0x15c86 <_table_alphanum+0x18>
   15c80:	6b 3b       	cpi	r22, 0xBB	; 187
   15c82:	21 f5       	brne	.+72     	; 0x15ccc <_table_alphanum+0x5e>
   15c84:	21 c0       	rjmp	.+66     	; 0x15cc8 <_table_alphanum+0x5a>
   15c86:	6e 3b       	cpi	r22, 0xBE	; 190
   15c88:	99 f0       	breq	.+38     	; 0x15cb0 <_table_alphanum+0x42>
   15c8a:	6b 3d       	cpi	r22, 0xDB	; 219
   15c8c:	f9 f4       	brne	.+62     	; 0x15ccc <_table_alphanum+0x5e>
   15c8e:	1a c0       	rjmp	.+52     	; 0x15cc4 <_table_alphanum+0x56>
   15c90:	6b 3e       	cpi	r22, 0xEB	; 235
   15c92:	b1 f0       	breq	.+44     	; 0x15cc0 <_table_alphanum+0x52>
   15c94:	6c 3e       	cpi	r22, 0xEC	; 236
   15c96:	18 f4       	brcc	.+6      	; 0x15c9e <_table_alphanum+0x30>
   15c98:	6e 3d       	cpi	r22, 0xDE	; 222
   15c9a:	c1 f4       	brne	.+48     	; 0x15ccc <_table_alphanum+0x5e>
   15c9c:	05 c0       	rjmp	.+10     	; 0x15ca8 <_table_alphanum+0x3a>
   15c9e:	6d 3e       	cpi	r22, 0xED	; 237
   15ca0:	49 f0       	breq	.+18     	; 0x15cb4 <_table_alphanum+0x46>
   15ca2:	6e 3e       	cpi	r22, 0xEE	; 238
   15ca4:	99 f4       	brne	.+38     	; 0x15ccc <_table_alphanum+0x5e>
   15ca6:	02 c0       	rjmp	.+4      	; 0x15cac <_table_alphanum+0x3e>
   15ca8:	82 e0       	ldi	r24, 0x02	; 2
   15caa:	11 c0       	rjmp	.+34     	; 0x15cce <_table_alphanum+0x60>
   15cac:	81 e0       	ldi	r24, 0x01	; 1
   15cae:	0f c0       	rjmp	.+30     	; 0x15cce <_table_alphanum+0x60>
   15cb0:	83 e0       	ldi	r24, 0x03	; 3
   15cb2:	0d c0       	rjmp	.+26     	; 0x15cce <_table_alphanum+0x60>
		case 0xDE:
			__key = 2; //2
			break;
		case 0xBE:
			__key = 3; //3
			break;
   15cb4:	84 e0       	ldi	r24, 0x04	; 4
   15cb6:	0b c0       	rjmp	.+22     	; 0x15cce <_table_alphanum+0x60>
		case 0xED:
			__key = 4; //4
			break;
   15cb8:	85 e0       	ldi	r24, 0x05	; 5
   15cba:	09 c0       	rjmp	.+18     	; 0x15cce <_table_alphanum+0x60>
		case 0xDD:
			__key = 5; //5
			break;
   15cbc:	86 e0       	ldi	r24, 0x06	; 6
   15cbe:	07 c0       	rjmp	.+14     	; 0x15cce <_table_alphanum+0x60>
		case 0xBD:
			__key = 6; //6
			break;
   15cc0:	87 e0       	ldi	r24, 0x07	; 7
   15cc2:	05 c0       	rjmp	.+10     	; 0x15cce <_table_alphanum+0x60>
		case 0xEB:
			__key = 7; //7
			break;
   15cc4:	88 e0       	ldi	r24, 0x08	; 8
   15cc6:	03 c0       	rjmp	.+6      	; 0x15cce <_table_alphanum+0x60>
		case 0xDB:
			__key = 8; //8
			break;
   15cc8:	89 e0       	ldi	r24, 0x09	; 9
   15cca:	01 c0       	rjmp	.+2      	; 0x15cce <_table_alphanum+0x60>
		case 0xBB:
			__key = 9; //9
			break;
   15ccc:	80 e0       	ldi	r24, 0x00	; 0
		default:
			__key = 0;
			break;	
	}

	if(__hit <= pgm_read_byte(&__maxchar[__key]))
   15cce:	28 2f       	mov	r18, r24
   15cd0:	30 e0       	ldi	r19, 0x00	; 0
   15cd2:	f9 01       	movw	r30, r18
   15cd4:	ea 57       	subi	r30, 0x7A	; 122
   15cd6:	fb 4d       	sbci	r31, 0xDB	; 219
   15cd8:	e4 91       	lpm	r30, Z+
   15cda:	e4 17       	cp	r30, r20
   15cdc:	10 f4       	brcc	.+4      	; 0x15ce2 <_table_alphanum+0x74>
   15cde:	80 e0       	ldi	r24, 0x00	; 0
   15ce0:	08 95       	ret
		__retchar = pgm_read_byte(&__alphanum[__caps][__key][__hit]);
   15ce2:	ec e3       	ldi	r30, 0x3C	; 60
   15ce4:	9e 9f       	mul	r25, r30
   15ce6:	f0 01       	movw	r30, r0
   15ce8:	11 24       	eor	r1, r1
   15cea:	e4 0f       	add	r30, r20
   15cec:	f1 1d       	adc	r31, r1
   15cee:	c9 01       	movw	r24, r18
   15cf0:	88 0f       	add	r24, r24
   15cf2:	99 1f       	adc	r25, r25
   15cf4:	82 0f       	add	r24, r18
   15cf6:	93 1f       	adc	r25, r19
   15cf8:	88 0f       	add	r24, r24
   15cfa:	99 1f       	adc	r25, r25
   15cfc:	e8 0f       	add	r30, r24
   15cfe:	f9 1f       	adc	r31, r25
   15d00:	e2 5f       	subi	r30, 0xF2	; 242
   15d02:	fb 4d       	sbci	r31, 0xDB	; 219
   15d04:	84 91       	lpm	r24, Z+
	else __retchar = '\0';

	return __retchar;
}
   15d06:	08 95       	ret

00015d08 <_key_scan>:





char _key_scan(char __select){
   15d08:	8f 92       	push	r8
   15d0a:	9f 92       	push	r9
   15d0c:	af 92       	push	r10
   15d0e:	bf 92       	push	r11
   15d10:	cf 92       	push	r12
   15d12:	df 92       	push	r13
   15d14:	ef 92       	push	r14
   15d16:	ff 92       	push	r15
   15d18:	0f 93       	push	r16
   15d1a:	1f 93       	push	r17
   15d1c:	df 93       	push	r29
   15d1e:	cf 93       	push	r28
   15d20:	00 d0       	rcall	.+0      	; 0x15d22 <_key_scan+0x1a>
   15d22:	00 d0       	rcall	.+0      	; 0x15d24 <_key_scan+0x1c>
   15d24:	cd b7       	in	r28, 0x3d	; 61
   15d26:	de b7       	in	r29, 0x3e	; 62
   15d28:	18 2f       	mov	r17, r24
	char	__key = 0;

	if(__select==_PAD_SINGLE || __select==_PAD_MULTI){
   15d2a:	81 50       	subi	r24, 0x01	; 1
   15d2c:	82 30       	cpi	r24, 0x02	; 2
   15d2e:	08 f0       	brcs	.+2      	; 0x15d32 <_key_scan+0x2a>
   15d30:	aa c0       	rjmp	.+340    	; 0x15e86 <_key_scan+0x17e>
													 {'9', 'W', 'X', 'Y', 'Z', '\0'}}};
const unsigned char __maxchar[10] PROGMEM = {2, 4, 3, 3, 3, 3, 3, 4, 3, 4};

char _key_hit(void){
	unsigned char	i, keyhit=0x00;
	unsigned char	outmap[4] = {0xef, 0xdf, 0xbf, 0x7f};
   15d32:	8f ee       	ldi	r24, 0xEF	; 239
   15d34:	89 83       	std	Y+1, r24	; 0x01
   15d36:	8f ed       	ldi	r24, 0xDF	; 223
   15d38:	8a 83       	std	Y+2, r24	; 0x02
   15d3a:	8f eb       	ldi	r24, 0xBF	; 191
   15d3c:	8b 83       	std	Y+3, r24	; 0x03
   15d3e:	8f e7       	ldi	r24, 0x7F	; 127
   15d40:	8c 83       	std	Y+4, r24	; 0x04
   15d42:	de 01       	movw	r26, r28
   15d44:	11 96       	adiw	r26, 0x01	; 1
   15d46:	2a ef       	ldi	r18, 0xFA	; 250
   15d48:	30 e0       	ldi	r19, 0x00	; 0

	for(i=0; i<4; i++){
   15d4a:	ae 01       	movw	r20, r28
   15d4c:	4b 5f       	subi	r20, 0xFB	; 251
   15d4e:	5f 4f       	sbci	r21, 0xFF	; 255
   15d50:	c9 01       	movw	r24, r18
   15d52:	01 97       	sbiw	r24, 0x01	; 1
   15d54:	f1 f7       	brne	.-4      	; 0x15d52 <_key_scan+0x4a>
		_delay_ms(1);
		_KEY_PORT = outmap[i];
   15d56:	8c 91       	ld	r24, X
   15d58:	80 93 62 00 	sts	0x0062, r24
   15d5c:	f9 01       	movw	r30, r18
   15d5e:	31 97       	sbiw	r30, 0x01	; 1
   15d60:	f1 f7       	brne	.-4      	; 0x15d5e <_key_scan+0x56>
		_delay_ms(1);
		keyhit = _KEY_MATRIX;
   15d62:	90 b1       	in	r25, 0x00	; 0
		if (keyhit!=outmap[i]) 
   15d64:	98 17       	cp	r25, r24
   15d66:	21 f4       	brne	.+8      	; 0x15d70 <_key_scan+0x68>
   15d68:	11 96       	adiw	r26, 0x01	; 1

char _key_hit(void){
	unsigned char	i, keyhit=0x00;
	unsigned char	outmap[4] = {0xef, 0xdf, 0xbf, 0x7f};

	for(i=0; i<4; i++){
   15d6a:	a4 17       	cp	r26, r20
   15d6c:	b5 07       	cpc	r27, r21
   15d6e:	81 f7       	brne	.-32     	; 0x15d50 <_key_scan+0x48>
char _key_scan(char __select){
	char	__key = 0;

	if(__select==_PAD_SINGLE || __select==_PAD_MULTI){
		__key = _key_hit();
		__key = _key_crr(__key);
   15d70:	89 2f       	mov	r24, r25
   15d72:	0e 94 c3 ad 	call	0x15b86	; 0x15b86 <_key_crr>
   15d76:	28 2f       	mov	r18, r24

		if(__key!=_KEY_NULL){
   15d78:	88 23       	and	r24, r24
   15d7a:	09 f4       	brne	.+2      	; 0x15d7e <_key_scan+0x76>
   15d7c:	85 c0       	rjmp	.+266    	; 0x15e88 <_key_scan+0x180>
			_LIGHT_SET;
   15d7e:	91 e0       	ldi	r25, 0x01	; 1
   15d80:	90 93 02 03 	sts	0x0302, r25
   15d84:	10 92 03 03 	sts	0x0303, r1
   15d88:	80 91 65 00 	lds	r24, 0x0065
   15d8c:	8d 7f       	andi	r24, 0xFD	; 253
   15d8e:	80 93 65 00 	sts	0x0065, r24
			if(__sec_par)
   15d92:	80 91 c8 03 	lds	r24, 0x03C8
   15d96:	88 23       	and	r24, r24
   15d98:	31 f0       	breq	.+12     	; 0x15da6 <_key_scan+0x9e>
				_SEC_ON;
   15d9a:	90 93 0a 03 	sts	0x030A, r25
   15d9e:	10 92 42 03 	sts	0x0342, r1
   15da2:	10 92 0b 03 	sts	0x030B, r1

			if(_IS1st){
   15da6:	80 91 04 03 	lds	r24, 0x0304
   15daa:	88 23       	and	r24, r24
   15dac:	71 f4       	brne	.+28     	; 0x15dca <_key_scan+0xc2>
				if(	__key == _KEY_CANCEL || __key == _KEY_ENTER)
   15dae:	27 3e       	cpi	r18, 0xE7	; 231
   15db0:	11 f0       	breq	.+4      	; 0x15db6 <_key_scan+0xae>
   15db2:	27 3b       	cpi	r18, 0xB7	; 183
   15db4:	31 f4       	brne	.+12     	; 0x15dc2 <_key_scan+0xba>
					if(__lock_num)
   15db6:	80 91 01 03 	lds	r24, 0x0301
   15dba:	88 23       	and	r24, r24
   15dbc:	11 f0       	breq	.+4      	; 0x15dc2 <_key_scan+0xba>
						__lock_num = 0;
   15dbe:	10 92 01 03 	sts	0x0301, r1
				_PAD_2nd;
   15dc2:	81 e0       	ldi	r24, 0x01	; 1
   15dc4:	80 93 04 03 	sts	0x0304, r24
   15dc8:	59 c0       	rjmp	.+178    	; 0x15e7c <_key_scan+0x174>
				_delay_ms(5);
				return __key;
			}
			if(_IS2nd){
   15dca:	81 30       	cpi	r24, 0x01	; 1
   15dcc:	09 f0       	breq	.+2      	; 0x15dd0 <_key_scan+0xc8>
   15dce:	5c c0       	rjmp	.+184    	; 0x15e88 <_key_scan+0x180>
				if(__select==_PAD_MULTI){
   15dd0:	12 30       	cpi	r17, 0x02	; 2
   15dd2:	21 f5       	brne	.+72     	; 0x15e1c <_key_scan+0x114>
					if(	__key==_KEY_0 || __key==_KEY_1 || __key==_KEY_2 || __key==_KEY_3||
   15dd4:	27 3d       	cpi	r18, 0xD7	; 215
   15dd6:	91 f0       	breq	.+36     	; 0x15dfc <_key_scan+0xf4>
   15dd8:	2e 3e       	cpi	r18, 0xEE	; 238
   15dda:	81 f0       	breq	.+32     	; 0x15dfc <_key_scan+0xf4>
   15ddc:	2e 3d       	cpi	r18, 0xDE	; 222
   15dde:	71 f0       	breq	.+28     	; 0x15dfc <_key_scan+0xf4>
   15de0:	2e 3b       	cpi	r18, 0xBE	; 190
   15de2:	61 f0       	breq	.+24     	; 0x15dfc <_key_scan+0xf4>
   15de4:	2d 3e       	cpi	r18, 0xED	; 237
   15de6:	51 f0       	breq	.+20     	; 0x15dfc <_key_scan+0xf4>
   15de8:	2d 3d       	cpi	r18, 0xDD	; 221
   15dea:	41 f0       	breq	.+16     	; 0x15dfc <_key_scan+0xf4>
   15dec:	2d 3b       	cpi	r18, 0xBD	; 189
   15dee:	31 f0       	breq	.+12     	; 0x15dfc <_key_scan+0xf4>
   15df0:	2b 3e       	cpi	r18, 0xEB	; 235
   15df2:	21 f0       	breq	.+8      	; 0x15dfc <_key_scan+0xf4>
   15df4:	2b 3d       	cpi	r18, 0xDB	; 219
   15df6:	11 f0       	breq	.+4      	; 0x15dfc <_key_scan+0xf4>
   15df8:	2b 3b       	cpi	r18, 0xBB	; 187
   15dfa:	81 f4       	brne	.+32     	; 0x15e1c <_key_scan+0x114>
						__key==_KEY_4 || __key==_KEY_5 || __key==_KEY_6 ||
						__key==_KEY_7 || __key==_KEY_8 || __key==_KEY_9){
						if(__lock_num){
   15dfc:	80 91 01 03 	lds	r24, 0x0301
   15e00:	88 23       	and	r24, r24
   15e02:	49 f0       	breq	.+18     	; 0x15e16 <_key_scan+0x10e>
							_SHIFT_SET;
   15e04:	81 e0       	ldi	r24, 0x01	; 1
   15e06:	80 93 05 03 	sts	0x0305, r24
   15e0a:	10 92 06 03 	sts	0x0306, r1
							CURSOR_HIDE;
   15e0e:	8c e0       	ldi	r24, 0x0C	; 12
   15e10:	0e 94 37 ac 	call	0x1586e	; 0x1586e <lcd_command>
   15e14:	03 c0       	rjmp	.+6      	; 0x15e1c <_key_scan+0x114>
						}
						else
							__lock_num = 1;
   15e16:	81 e0       	ldi	r24, 0x01	; 1
   15e18:	80 93 01 03 	sts	0x0301, r24
													 {'9', 'W', 'X', 'Y', 'Z', '\0'}}};
const unsigned char __maxchar[10] PROGMEM = {2, 4, 3, 3, 3, 3, 3, 4, 3, 4};

char _key_hit(void){
	unsigned char	i, keyhit=0x00;
	unsigned char	outmap[4] = {0xef, 0xdf, 0xbf, 0x7f};
   15e1c:	ff ee       	ldi	r31, 0xEF	; 239
   15e1e:	8f 2e       	mov	r8, r31
   15e20:	ef ed       	ldi	r30, 0xDF	; 223
   15e22:	9e 2e       	mov	r9, r30
   15e24:	7f eb       	ldi	r23, 0xBF	; 191
   15e26:	a7 2e       	mov	r10, r23
   15e28:	6f e7       	ldi	r22, 0x7F	; 127
   15e2a:	b6 2e       	mov	r11, r22
   15e2c:	6e 01       	movw	r12, r28
   15e2e:	08 94       	sec
   15e30:	c1 1c       	adc	r12, r1
   15e32:	d1 1c       	adc	r13, r1
   15e34:	0a ef       	ldi	r16, 0xFA	; 250
   15e36:	10 e0       	ldi	r17, 0x00	; 0

	for(i=0; i<4; i++){
   15e38:	55 e0       	ldi	r21, 0x05	; 5
   15e3a:	e5 2e       	mov	r14, r21
   15e3c:	f1 2c       	mov	r15, r1
   15e3e:	ec 0e       	add	r14, r28
   15e40:	fd 1e       	adc	r15, r29
													 {'9', 'W', 'X', 'Y', 'Z', '\0'}}};
const unsigned char __maxchar[10] PROGMEM = {2, 4, 3, 3, 3, 3, 3, 4, 3, 4};

char _key_hit(void){
	unsigned char	i, keyhit=0x00;
	unsigned char	outmap[4] = {0xef, 0xdf, 0xbf, 0x7f};
   15e42:	89 82       	std	Y+1, r8	; 0x01
   15e44:	9a 82       	std	Y+2, r9	; 0x02
   15e46:	ab 82       	std	Y+3, r10	; 0x03
   15e48:	bc 82       	std	Y+4, r11	; 0x04
   15e4a:	d6 01       	movw	r26, r12
   15e4c:	c8 01       	movw	r24, r16
   15e4e:	01 97       	sbiw	r24, 0x01	; 1
   15e50:	f1 f7       	brne	.-4      	; 0x15e4e <_key_scan+0x146>

	for(i=0; i<4; i++){
		_delay_ms(1);
		_KEY_PORT = outmap[i];
   15e52:	8c 91       	ld	r24, X
   15e54:	80 93 62 00 	sts	0x0062, r24
   15e58:	f8 01       	movw	r30, r16
   15e5a:	31 97       	sbiw	r30, 0x01	; 1
   15e5c:	f1 f7       	brne	.-4      	; 0x15e5a <_key_scan+0x152>
		_delay_ms(1);
		keyhit = _KEY_MATRIX;
   15e5e:	90 b1       	in	r25, 0x00	; 0
		if (keyhit!=outmap[i]) 
   15e60:	98 17       	cp	r25, r24
   15e62:	21 f4       	brne	.+8      	; 0x15e6c <_key_scan+0x164>
   15e64:	11 96       	adiw	r26, 0x01	; 1

char _key_hit(void){
	unsigned char	i, keyhit=0x00;
	unsigned char	outmap[4] = {0xef, 0xdf, 0xbf, 0x7f};

	for(i=0; i<4; i++){
   15e66:	ae 15       	cp	r26, r14
   15e68:	bf 05       	cpc	r27, r15
   15e6a:	81 f7       	brne	.-32     	; 0x15e4c <_key_scan+0x144>
							__lock_num = 1;
					}
				}
				do{
					__key = _key_hit();
					__key = _key_crr(__key);
   15e6c:	89 2f       	mov	r24, r25
   15e6e:	0e 94 c3 ad 	call	0x15b86	; 0x15b86 <_key_crr>
   15e72:	28 2f       	mov	r18, r24
				}while(__key!=_KEY_NULL);
   15e74:	88 23       	and	r24, r24
   15e76:	29 f7       	brne	.-54     	; 0x15e42 <_key_scan+0x13a>
				_PAD_1st;
   15e78:	10 92 04 03 	sts	0x0304, r1
   15e7c:	82 ee       	ldi	r24, 0xE2	; 226
   15e7e:	94 e0       	ldi	r25, 0x04	; 4
   15e80:	01 97       	sbiw	r24, 0x01	; 1
   15e82:	f1 f7       	brne	.-4      	; 0x15e80 <_key_scan+0x178>
   15e84:	03 c0       	rjmp	.+6      	; 0x15e8c <_key_scan+0x184>
				_delay_ms(5);
				return _KEY_NULL;
   15e86:	20 e0       	ldi	r18, 0x00	; 0
			}
		}
	}
	_PAD_1st;
   15e88:	10 92 04 03 	sts	0x0304, r1
	return __key;
}
   15e8c:	82 2f       	mov	r24, r18
   15e8e:	0f 90       	pop	r0
   15e90:	0f 90       	pop	r0
   15e92:	0f 90       	pop	r0
   15e94:	0f 90       	pop	r0
   15e96:	cf 91       	pop	r28
   15e98:	df 91       	pop	r29
   15e9a:	1f 91       	pop	r17
   15e9c:	0f 91       	pop	r16
   15e9e:	ff 90       	pop	r15
   15ea0:	ef 90       	pop	r14
   15ea2:	df 90       	pop	r13
   15ea4:	cf 90       	pop	r12
   15ea6:	bf 90       	pop	r11
   15ea8:	af 90       	pop	r10
   15eaa:	9f 90       	pop	r9
   15eac:	8f 90       	pop	r8
   15eae:	08 95       	ret

00015eb0 <_spi_init>:
unsigned char	__spi_i;
unsigned char	__spi_isstart = 0;
unsigned char	__spi_ismessage = 0;

void _spi_init(unsigned char __mode, unsigned char __interrupt){
	if(__mode){
   15eb0:	88 23       	and	r24, r24
   15eb2:	41 f0       	breq	.+16     	; 0x15ec4 <_spi_init+0x14>
		_SPI_DDR = (1 << _SPI_MOSI) | (1 << _SPI_SCK);
   15eb4:	86 e0       	ldi	r24, 0x06	; 6
   15eb6:	87 bb       	out	0x17, r24	; 23
		if(__interrupt)
   15eb8:	66 23       	and	r22, r22
   15eba:	11 f0       	breq	.+4      	; 0x15ec0 <_spi_init+0x10>
			SPCR = (1 << SPIE) | (1 << SPE) | (1 << MSTR) | (1 << SPR1);
   15ebc:	82 ed       	ldi	r24, 0xD2	; 210
   15ebe:	09 c0       	rjmp	.+18     	; 0x15ed2 <_spi_init+0x22>
		else
			SPCR = (1 << SPE) | (1 << MSTR) | (1 << SPR1);
   15ec0:	82 e5       	ldi	r24, 0x52	; 82
   15ec2:	07 c0       	rjmp	.+14     	; 0x15ed2 <_spi_init+0x22>
	}
	else{
		_SPI_DDR = (1 << _SPI_MISO);
   15ec4:	88 e0       	ldi	r24, 0x08	; 8
   15ec6:	87 bb       	out	0x17, r24	; 23
		if(__interrupt)
   15ec8:	66 23       	and	r22, r22
   15eca:	11 f0       	breq	.+4      	; 0x15ed0 <_spi_init+0x20>
			SPCR = (1 << SPIE) | (1 << SPE);
   15ecc:	80 ec       	ldi	r24, 0xC0	; 192
   15ece:	01 c0       	rjmp	.+2      	; 0x15ed2 <_spi_init+0x22>
		else
			SPCR = (1 << SPE);
   15ed0:	80 e4       	ldi	r24, 0x40	; 64
   15ed2:	8d b9       	out	0x0d, r24	; 13
   15ed4:	08 95       	ret

00015ed6 <_spi_enable>:
	}
}

void _spi_enable(unsigned char __select){
	if(__select == 0){
   15ed6:	88 23       	and	r24, r24
   15ed8:	19 f4       	brne	.+6      	; 0x15ee0 <_spi_enable+0xa>
		sbi(_SLAVE_PORT, _SLAVE_PIN);
   15eda:	db 9a       	sbi	0x1b, 3	; 27
		sbi(_MMC_PORT, _MMC_PIN);
   15edc:	1b 9a       	sbi	0x03, 3	; 3
   15ede:	08 95       	ret
	}
	if(__select == 1){
   15ee0:	81 30       	cpi	r24, 0x01	; 1
   15ee2:	39 f4       	brne	.+14     	; 0x15ef2 <_spi_enable+0x1c>
		sbi(_MMC_PORT, _MMC_PIN);
   15ee4:	1b 9a       	sbi	0x03, 3	; 3
   15ee6:	82 ee       	ldi	r24, 0xE2	; 226
   15ee8:	94 e0       	ldi	r25, 0x04	; 4
   15eea:	01 97       	sbiw	r24, 0x01	; 1
   15eec:	f1 f7       	brne	.-4      	; 0x15eea <_spi_enable+0x14>
		_delay_ms(5);
		cbi(_SLAVE_PORT, _SLAVE_PIN);
   15eee:	db 98       	cbi	0x1b, 3	; 27
   15ef0:	08 95       	ret
	}
	if(__select == 2){
   15ef2:	82 30       	cpi	r24, 0x02	; 2
   15ef4:	31 f4       	brne	.+12     	; 0x15f02 <_spi_enable+0x2c>
		sbi(_SLAVE_PORT, _SLAVE_PIN);
   15ef6:	db 9a       	sbi	0x1b, 3	; 27
   15ef8:	82 ee       	ldi	r24, 0xE2	; 226
   15efa:	94 e0       	ldi	r25, 0x04	; 4
   15efc:	01 97       	sbiw	r24, 0x01	; 1
   15efe:	f1 f7       	brne	.-4      	; 0x15efc <_spi_enable+0x26>
		_delay_ms(5);
		cbi(_MMC_PORT, _MMC_PIN);
   15f00:	1b 98       	cbi	0x03, 3	; 3
   15f02:	08 95       	ret

00015f04 <_spi>:
	}
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
   15f04:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1 << SPIF)));
   15f06:	77 9b       	sbis	0x0e, 7	; 14
   15f08:	fe cf       	rjmp	.-4      	; 0x15f06 <_spi+0x2>
	return SPDR;
   15f0a:	8f b1       	in	r24, 0x0f	; 15
}
   15f0c:	08 95       	ret

00015f0e <_spi_rx>:


unsigned char _spi_rx(unsigned char __select){
	unsigned char __i = 0;

	_spi_enable(__select);
   15f0e:	0e 94 6b af 	call	0x15ed6	; 0x15ed6 <_spi_enable>
		cbi(_MMC_PORT, _MMC_PIN);
	}
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
   15f12:	81 e4       	ldi	r24, 0x41	; 65
   15f14:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1 << SPIF)));
   15f16:	77 9b       	sbis	0x0e, 7	; 14
   15f18:	fe cf       	rjmp	.-4      	; 0x15f16 <_spi_rx+0x8>
	return SPDR;
   15f1a:	8f b1       	in	r24, 0x0f	; 15
unsigned char _spi_rx(unsigned char __select){
	unsigned char __i = 0;

	_spi_enable(__select);

		__spi_char = _spi(0x41);
   15f1c:	80 93 eb 0d 	sts	0x0DEB, r24
		if(__spi_char==0xff) return 0;
   15f20:	8f 3f       	cpi	r24, 0xFF	; 255
   15f22:	11 f4       	brne	.+4      	; 0x15f28 <_spi_rx+0x1a>
   15f24:	80 e0       	ldi	r24, 0x00	; 0
   15f26:	08 95       	ret
		if(__spi_char==0x55) return 1;
   15f28:	85 35       	cpi	r24, 0x55	; 85
   15f2a:	11 f4       	brne	.+4      	; 0x15f30 <_spi_rx+0x22>
   15f2c:	81 e0       	ldi	r24, 0x01	; 1
   15f2e:	08 95       	ret
		if(__spi_char==0x02) return 2;
   15f30:	82 30       	cpi	r24, 0x02	; 2
   15f32:	21 f0       	breq	.+8      	; 0x15f3c <_spi_rx+0x2e>
	_spi_enable(_SPI_NONE);
   15f34:	80 e0       	ldi	r24, 0x00	; 0
   15f36:	0e 94 6b af 	call	0x15ed6	; 0x15ed6 <_spi_enable>
   15f3a:	85 e1       	ldi	r24, 0x15	; 21
	return 21;
}
   15f3c:	08 95       	ret

00015f3e <_spi_tx>:

unsigned char _spi_tx(unsigned char __command, unsigned char __select, char* __message){
   15f3e:	1f 93       	push	r17
   15f40:	cf 93       	push	r28
   15f42:	df 93       	push	r29
   15f44:	18 2f       	mov	r17, r24
   15f46:	86 2f       	mov	r24, r22
   15f48:	ea 01       	movw	r28, r20
	_spi_enable(__select);
   15f4a:	0e 94 6b af 	call	0x15ed6	; 0x15ed6 <_spi_enable>
		cbi(_MMC_PORT, _MMC_PIN);
	}
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
   15f4e:	8b e7       	ldi	r24, 0x7B	; 123
   15f50:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1 << SPIF)));
   15f52:	77 9b       	sbis	0x0e, 7	; 14
   15f54:	fe cf       	rjmp	.-4      	; 0x15f52 <_spi_tx+0x14>
	return SPDR;
   15f56:	8f b1       	in	r24, 0x0f	; 15
		cbi(_MMC_PORT, _MMC_PIN);
	}
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
   15f58:	1f b9       	out	0x0f, r17	; 15
	while(!(SPSR & (1 << SPIF)));
   15f5a:	77 9b       	sbis	0x0e, 7	; 14
   15f5c:	fe cf       	rjmp	.-4      	; 0x15f5a <_spi_tx+0x1c>
	return SPDR;
   15f5e:	8f b1       	in	r24, 0x0f	; 15
unsigned char _spi_tx(unsigned char __command, unsigned char __select, char* __message){
	_spi_enable(__select);
	_spi(0x7B);
	_spi(__command);

	if(strlen(__message) > 0){
   15f60:	88 81       	ld	r24, Y
   15f62:	88 23       	and	r24, r24
   15f64:	91 f0       	breq	.+36     	; 0x15f8a <_spi_tx+0x4c>
		cbi(_MMC_PORT, _MMC_PIN);
	}
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
   15f66:	88 e2       	ldi	r24, 0x28	; 40
   15f68:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1 << SPIF)));
   15f6a:	77 9b       	sbis	0x0e, 7	; 14
   15f6c:	fe cf       	rjmp	.-4      	; 0x15f6a <_spi_tx+0x2c>
   15f6e:	04 c0       	rjmp	.+8      	; 0x15f78 <_spi_tx+0x3a>
		cbi(_MMC_PORT, _MMC_PIN);
	}
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
   15f70:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1 << SPIF)));
   15f72:	77 9b       	sbis	0x0e, 7	; 14
   15f74:	fe cf       	rjmp	.-4      	; 0x15f72 <_spi_tx+0x34>
	_spi(__command);

	if(strlen(__message) > 0){
		_spi(0x28);
		while(*__message)
			_spi(*__message++);
   15f76:	21 96       	adiw	r28, 0x01	; 1
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
	while(!(SPSR & (1 << SPIF)));
	return SPDR;
   15f78:	8f b1       	in	r24, 0x0f	; 15
	_spi(0x7B);
	_spi(__command);

	if(strlen(__message) > 0){
		_spi(0x28);
		while(*__message)
   15f7a:	88 81       	ld	r24, Y
   15f7c:	88 23       	and	r24, r24
   15f7e:	c1 f7       	brne	.-16     	; 0x15f70 <_spi_tx+0x32>
		cbi(_MMC_PORT, _MMC_PIN);
	}
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
   15f80:	89 e2       	ldi	r24, 0x29	; 41
   15f82:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1 << SPIF)));
   15f84:	77 9b       	sbis	0x0e, 7	; 14
   15f86:	fe cf       	rjmp	.-4      	; 0x15f84 <_spi_tx+0x46>
	return SPDR;
   15f88:	8f b1       	in	r24, 0x0f	; 15
		cbi(_MMC_PORT, _MMC_PIN);
	}
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
   15f8a:	8d e7       	ldi	r24, 0x7D	; 125
   15f8c:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1 << SPIF)));
   15f8e:	77 9b       	sbis	0x0e, 7	; 14
   15f90:	fe cf       	rjmp	.-4      	; 0x15f8e <_spi_tx+0x50>
	return SPDR;
   15f92:	8f b1       	in	r24, 0x0f	; 15
			_spi(*__message++);
		_spi(0x29);
	}

	_spi(0x7D);
	_spi_enable(_SPI_NONE);
   15f94:	80 e0       	ldi	r24, 0x00	; 0
   15f96:	0e 94 6b af 	call	0x15ed6	; 0x15ed6 <_spi_enable>
	return 0;
}
   15f9a:	80 e0       	ldi	r24, 0x00	; 0
   15f9c:	df 91       	pop	r29
   15f9e:	cf 91       	pop	r28
   15fa0:	1f 91       	pop	r17
   15fa2:	08 95       	ret

00015fa4 <_spi_txnum>:

unsigned char _spi_txnum(unsigned char __command, unsigned char __select, char* __message, unsigned char __num){
   15fa4:	ff 92       	push	r15
   15fa6:	0f 93       	push	r16
   15fa8:	1f 93       	push	r17
   15faa:	86 2f       	mov	r24, r22
   15fac:	14 2f       	mov	r17, r20
   15fae:	05 2f       	mov	r16, r21
   15fb0:	f2 2e       	mov	r15, r18
	unsigned char	__i;

	_spi_enable(__select);
   15fb2:	0e 94 6b af 	call	0x15ed6	; 0x15ed6 <_spi_enable>
		cbi(_MMC_PORT, _MMC_PIN);
	}
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
   15fb6:	82 e0       	ldi	r24, 0x02	; 2
   15fb8:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1 << SPIF)));
   15fba:	77 9b       	sbis	0x0e, 7	; 14
   15fbc:	fe cf       	rjmp	.-4      	; 0x15fba <_spi_txnum+0x16>
	return SPDR;
   15fbe:	8f b1       	in	r24, 0x0f	; 15
	unsigned char	__i;

	_spi_enable(__select);
	_spi(0x02);

	if(__num > 0){
   15fc0:	ff 20       	and	r15, r15
   15fc2:	79 f0       	breq	.+30     	; 0x15fe2 <_spi_txnum+0x3e>
   15fc4:	81 2f       	mov	r24, r17
   15fc6:	90 2f       	mov	r25, r16
   15fc8:	9c 01       	movw	r18, r24
   15fca:	f9 01       	movw	r30, r18
   15fcc:	90 e0       	ldi	r25, 0x00	; 0
   15fce:	07 c0       	rjmp	.+14     	; 0x15fde <_spi_txnum+0x3a>
		for(__i = 0; __i < __num; __i++) _spi(__message[__i]);
   15fd0:	80 81       	ld	r24, Z
		cbi(_MMC_PORT, _MMC_PIN);
	}
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
   15fd2:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1 << SPIF)));
   15fd4:	77 9b       	sbis	0x0e, 7	; 14
   15fd6:	fe cf       	rjmp	.-4      	; 0x15fd4 <_spi_txnum+0x30>
	return SPDR;
   15fd8:	8f b1       	in	r24, 0x0f	; 15

	_spi_enable(__select);
	_spi(0x02);

	if(__num > 0){
		for(__i = 0; __i < __num; __i++) _spi(__message[__i]);
   15fda:	9f 5f       	subi	r25, 0xFF	; 255
   15fdc:	31 96       	adiw	r30, 0x01	; 1
   15fde:	9f 15       	cp	r25, r15
   15fe0:	b8 f3       	brcs	.-18     	; 0x15fd0 <_spi_txnum+0x2c>
		cbi(_MMC_PORT, _MMC_PIN);
	}
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
   15fe2:	83 e0       	ldi	r24, 0x03	; 3
   15fe4:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1 << SPIF)));
   15fe6:	77 9b       	sbis	0x0e, 7	; 14
   15fe8:	fe cf       	rjmp	.-4      	; 0x15fe6 <_spi_txnum+0x42>
	return SPDR;
   15fea:	8f b1       	in	r24, 0x0f	; 15
	if(__num > 0){
		for(__i = 0; __i < __num; __i++) _spi(__message[__i]);
				}// for

	_spi(0x03);
	_spi_enable(_SPI_NONE);
   15fec:	80 e0       	ldi	r24, 0x00	; 0
   15fee:	0e 94 6b af 	call	0x15ed6	; 0x15ed6 <_spi_enable>
	return 0;
}
   15ff2:	80 e0       	ldi	r24, 0x00	; 0
   15ff4:	1f 91       	pop	r17
   15ff6:	0f 91       	pop	r16
   15ff8:	ff 90       	pop	r15
   15ffa:	08 95       	ret

00015ffc <_spi_interrupt>:

unsigned char _spi_interrupt(void){
	__spi_char = SPDR;
   15ffc:	9f b1       	in	r25, 0x0f	; 15
   15ffe:	90 93 eb 0d 	sts	0x0DEB, r25

	if(__spi_char == 0xFF){
   16002:	9f 3f       	cpi	r25, 0xFF	; 255
   16004:	e9 f4       	brne	.+58     	; 0x16040 <_spi_interrupt+0x44>
		if(__spi_istransmit){
   16006:	80 91 3e 03 	lds	r24, 0x033E
   1600a:	88 23       	and	r24, r24
   1600c:	b9 f0       	breq	.+46     	; 0x1603c <_spi_interrupt+0x40>
			SPDR = __command[__spi_i];
   1600e:	90 91 ea 0d 	lds	r25, 0x0DEA
   16012:	e9 2f       	mov	r30, r25
   16014:	f0 e0       	ldi	r31, 0x00	; 0
   16016:	e4 5f       	subi	r30, 0xF4	; 244
   16018:	fc 4f       	sbci	r31, 0xFC	; 252
   1601a:	80 81       	ld	r24, Z
   1601c:	8f b9       	out	0x0f, r24	; 15
			if(__command[__spi_i] == 0x7D){
   1601e:	8d 37       	cpi	r24, 0x7D	; 125
   16020:	19 f4       	brne	.+6      	; 0x16028 <_spi_interrupt+0x2c>
				__spi_i = 0;
   16022:	10 92 ea 0d 	sts	0x0DEA, r1
   16026:	07 c0       	rjmp	.+14     	; 0x16036 <_spi_interrupt+0x3a>
				__spi_istransmit = 0;
			}
			else{
				__spi_i++;
   16028:	89 2f       	mov	r24, r25
   1602a:	8f 5f       	subi	r24, 0xFF	; 255
   1602c:	80 93 ea 0d 	sts	0x0DEA, r24
				if(__spi_i == _MAX_COMMAND)
   16030:	82 33       	cpi	r24, 0x32	; 50
   16032:	09 f0       	breq	.+2      	; 0x16036 <_spi_interrupt+0x3a>
   16034:	3f c0       	rjmp	.+126    	; 0x160b4 <_spi_interrupt+0xb8>
					__spi_istransmit = 0;
   16036:	10 92 3e 03 	sts	0x033E, r1
   1603a:	3c c0       	rjmp	.+120    	; 0x160b4 <_spi_interrupt+0xb8>
			}
		}
		else
			SPDR = 0xFF;
   1603c:	9f b9       	out	0x0f, r25	; 15
   1603e:	3a c0       	rjmp	.+116    	; 0x160b4 <_spi_interrupt+0xb8>
	}
	else{
		if(__spi_char == 0x7D && __spi_isstart){
   16040:	9d 37       	cpi	r25, 0x7D	; 125
   16042:	69 f4       	brne	.+26     	; 0x1605e <_spi_interrupt+0x62>
   16044:	80 91 07 03 	lds	r24, 0x0307
   16048:	88 23       	and	r24, r24
   1604a:	49 f0       	breq	.+18     	; 0x1605e <_spi_interrupt+0x62>
			__spi_isstart = 0;
   1604c:	10 92 07 03 	sts	0x0307, r1
			__spi_ismessage = 0;
   16050:	10 92 08 03 	sts	0x0308, r1
			__spi_i = 0;
   16054:	10 92 ea 0d 	sts	0x0DEA, r1
			__command_flag = 1;
   16058:	81 e0       	ldi	r24, 0x01	; 1
   1605a:	80 93 41 03 	sts	0x0341, r24
		}
		if(__spi_isstart && __spi_ismessage){
   1605e:	20 91 07 03 	lds	r18, 0x0307
   16062:	22 23       	and	r18, r18
   16064:	f1 f0       	breq	.+60     	; 0x160a2 <_spi_interrupt+0xa6>
   16066:	80 91 08 03 	lds	r24, 0x0308
   1606a:	88 23       	and	r24, r24
   1606c:	29 f1       	breq	.+74     	; 0x160b8 <_spi_interrupt+0xbc>
			if(__spi_char != 0x29){
   1606e:	99 32       	cpi	r25, 0x29	; 41
   16070:	c1 f0       	breq	.+48     	; 0x160a2 <_spi_interrupt+0xa6>
				__package[__spi_i] = __spi_char;
   16072:	80 91 ea 0d 	lds	r24, 0x0DEA
   16076:	e8 2f       	mov	r30, r24
   16078:	f0 e0       	ldi	r31, 0x00	; 0
   1607a:	ea 5b       	subi	r30, 0xBA	; 186
   1607c:	fc 4f       	sbci	r31, 0xFC	; 252
   1607e:	90 83       	st	Z, r25
				__package[__spi_i + 1] = '\0';
   16080:	11 82       	std	Z+1, r1	; 0x01
				__spi_i++;
   16082:	8f 5f       	subi	r24, 0xFF	; 255
   16084:	80 93 ea 0d 	sts	0x0DEA, r24
				if(__spi_i == _MAX_PACKAGE)
   16088:	82 38       	cpi	r24, 0x82	; 130
   1608a:	59 f4       	brne	.+22     	; 0x160a2 <_spi_interrupt+0xa6>
					__spi_i = 0;
   1608c:	10 92 ea 0d 	sts	0x0DEA, r1
   16090:	08 c0       	rjmp	.+16     	; 0x160a2 <_spi_interrupt+0xa6>
			}
		}
		if(__spi_isstart && !__spi_ismessage){
			if(__spi_char == 0x28){
				__spi_ismessage = 1;
   16092:	81 e0       	ldi	r24, 0x01	; 1
   16094:	80 93 08 03 	sts	0x0308, r24
				__spi_i = 0;
   16098:	10 92 ea 0d 	sts	0x0DEA, r1
   1609c:	0b c0       	rjmp	.+22     	; 0x160b4 <_spi_interrupt+0xb8>
			}
			else
				__command_set = __spi_char;
   1609e:	90 93 43 03 	sts	0x0343, r25
		}
		if(__spi_char == 0x7B && !__spi_isstart){
   160a2:	9b 37       	cpi	r25, 0x7B	; 123
   160a4:	39 f4       	brne	.+14     	; 0x160b4 <_spi_interrupt+0xb8>
   160a6:	22 23       	and	r18, r18
   160a8:	29 f4       	brne	.+10     	; 0x160b4 <_spi_interrupt+0xb8>
			__spi_isstart = 1;
   160aa:	81 e0       	ldi	r24, 0x01	; 1
   160ac:	80 93 07 03 	sts	0x0307, r24
			__spi_ismessage = 0;
   160b0:	10 92 08 03 	sts	0x0308, r1
		}
	}

	return 0;
}
   160b4:	80 e0       	ldi	r24, 0x00	; 0
   160b6:	08 95       	ret
				if(__spi_i == _MAX_PACKAGE)
					__spi_i = 0;
			}
		}
		if(__spi_isstart && !__spi_ismessage){
			if(__spi_char == 0x28){
   160b8:	98 32       	cpi	r25, 0x28	; 40
   160ba:	89 f7       	brne	.-30     	; 0x1609e <_spi_interrupt+0xa2>
   160bc:	ea cf       	rjmp	.-44     	; 0x16092 <_spi_interrupt+0x96>

000160be <_spi_command>:
	}

	return 0;
}

void _spi_command(unsigned char __cmd, char* __cell){
   160be:	fb 01       	movw	r30, r22
	unsigned char __i = 0;

	__command[__i++] = 0x7B;
   160c0:	9b e7       	ldi	r25, 0x7B	; 123
   160c2:	90 93 0c 03 	sts	0x030C, r25
	__command[__i++] = __cmd;
   160c6:	80 93 0d 03 	sts	0x030D, r24

	if(strlen(__cell) > 0){
   160ca:	80 81       	ld	r24, Z
   160cc:	88 23       	and	r24, r24
   160ce:	11 f4       	brne	.+4      	; 0x160d4 <_spi_command+0x16>
   160d0:	92 e0       	ldi	r25, 0x02	; 2
   160d2:	16 c0       	rjmp	.+44     	; 0x16100 <_spi_command+0x42>
		__command[__i++] = 0x28;
   160d4:	88 e2       	ldi	r24, 0x28	; 40
   160d6:	80 93 0e 03 	sts	0x030E, r24
   160da:	83 e0       	ldi	r24, 0x03	; 3
   160dc:	05 c0       	rjmp	.+10     	; 0x160e8 <_spi_command+0x2a>

		while(*__cell)
			__command[__i++] = *__cell++;
   160de:	a4 5f       	subi	r26, 0xF4	; 244
   160e0:	bc 4f       	sbci	r27, 0xFC	; 252
   160e2:	9c 93       	st	X, r25
   160e4:	82 2f       	mov	r24, r18
   160e6:	31 96       	adiw	r30, 0x01	; 1
	__command[__i++] = __cmd;

	if(strlen(__cell) > 0){
		__command[__i++] = 0x28;

		while(*__cell)
   160e8:	90 81       	ld	r25, Z
   160ea:	a8 2f       	mov	r26, r24
   160ec:	b0 e0       	ldi	r27, 0x00	; 0
   160ee:	28 2f       	mov	r18, r24
   160f0:	2f 5f       	subi	r18, 0xFF	; 255
   160f2:	99 23       	and	r25, r25
   160f4:	a1 f7       	brne	.-24     	; 0x160de <_spi_command+0x20>
			__command[__i++] = *__cell++;

		__command[__i++] = 0x29;
   160f6:	a4 5f       	subi	r26, 0xF4	; 244
   160f8:	bc 4f       	sbci	r27, 0xFC	; 252
   160fa:	89 e2       	ldi	r24, 0x29	; 41
   160fc:	8c 93       	st	X, r24
   160fe:	92 2f       	mov	r25, r18
	}

	__command[__i++] = 0x7D;
   16100:	e9 2f       	mov	r30, r25
   16102:	f0 e0       	ldi	r31, 0x00	; 0
   16104:	e4 5f       	subi	r30, 0xF4	; 244
   16106:	fc 4f       	sbci	r31, 0xFC	; 252
   16108:	8d e7       	ldi	r24, 0x7D	; 125
   1610a:	80 83       	st	Z, r24
	__command[__i++] = '\0';
   1610c:	9f 5f       	subi	r25, 0xFF	; 255
   1610e:	e9 2f       	mov	r30, r25
   16110:	f0 e0       	ldi	r31, 0x00	; 0
   16112:	e4 5f       	subi	r30, 0xF4	; 244
   16114:	fc 4f       	sbci	r31, 0xFC	; 252
   16116:	10 82       	st	Z, r1
}
   16118:	08 95       	ret

0001611a <_rtc>:

#include <compat/twi.h>

#include "RTC.h"

unsigned char _rtc(int __addr, int __len, char* __datetime, unsigned char __dir){
   1611a:	98 2f       	mov	r25, r24
	int				__twcr;
	unsigned char	__i = 0;
	
	if(__dir){
   1611c:	22 23       	and	r18, r18
   1611e:	09 f4       	brne	.+2      	; 0x16122 <_rtc+0x8>
   16120:	49 c0       	rjmp	.+146    	; 0x161b4 <_rtc+0x9a>
		TWCR = _BV(TWINT) | _BV(TWSTA) | _BV(TWEN);
   16122:	84 ea       	ldi	r24, 0xA4	; 164
   16124:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   16128:	80 91 74 00 	lds	r24, 0x0074
   1612c:	87 ff       	sbrs	r24, 7
   1612e:	fc cf       	rjmp	.-8      	; 0x16128 <_rtc+0xe>
		if(TW_STATUS != TW_START)
   16130:	80 91 71 00 	lds	r24, 0x0071
   16134:	88 7f       	andi	r24, 0xF8	; 248
   16136:	88 30       	cpi	r24, 0x08	; 8
   16138:	09 f0       	breq	.+2      	; 0x1613c <_rtc+0x22>
   1613a:	af c0       	rjmp	.+350    	; 0x1629a <_rtc+0x180>
			return 1;

		TWDR = _DS1307W;
   1613c:	80 ed       	ldi	r24, 0xD0	; 208
   1613e:	80 93 73 00 	sts	0x0073, r24
		TWCR = _BV(TWINT) | _BV(TWEN);
   16142:	84 e8       	ldi	r24, 0x84	; 132
   16144:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   16148:	80 91 74 00 	lds	r24, 0x0074
   1614c:	87 ff       	sbrs	r24, 7
   1614e:	fc cf       	rjmp	.-8      	; 0x16148 <_rtc+0x2e>
		if(TW_STATUS != TW_MT_SLA_ACK)
   16150:	80 91 71 00 	lds	r24, 0x0071
   16154:	88 7f       	andi	r24, 0xF8	; 248
   16156:	88 31       	cpi	r24, 0x18	; 24
   16158:	09 f0       	breq	.+2      	; 0x1615c <_rtc+0x42>
   1615a:	9f c0       	rjmp	.+318    	; 0x1629a <_rtc+0x180>
			return 1;

		TWDR = __addr;
   1615c:	90 93 73 00 	sts	0x0073, r25
		TWCR = _BV(TWINT) | _BV(TWEN);
   16160:	84 e8       	ldi	r24, 0x84	; 132
   16162:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   16166:	80 91 74 00 	lds	r24, 0x0074
   1616a:	87 ff       	sbrs	r24, 7
   1616c:	fc cf       	rjmp	.-8      	; 0x16166 <_rtc+0x4c>
		if(TW_STATUS != TW_MT_DATA_ACK)
   1616e:	80 91 71 00 	lds	r24, 0x0071
   16172:	88 7f       	andi	r24, 0xF8	; 248
   16174:	88 32       	cpi	r24, 0x28	; 40
   16176:	09 f0       	breq	.+2      	; 0x1617a <_rtc+0x60>
   16178:	90 c0       	rjmp	.+288    	; 0x1629a <_rtc+0x180>
   1617a:	9b 01       	movw	r18, r22
			return 1;

		for(; __len > 0; __len--){
			TWDR = __datetime[__i++];
			TWCR = _BV(TWINT) | _BV(TWEN);
   1617c:	94 e8       	ldi	r25, 0x84	; 132
   1617e:	14 c0       	rjmp	.+40     	; 0x161a8 <_rtc+0x8e>
		_rtc_response;
		if(TW_STATUS != TW_MT_DATA_ACK)
			return 1;

		for(; __len > 0; __len--){
			TWDR = __datetime[__i++];
   16180:	fa 01       	movw	r30, r20
   16182:	e8 0f       	add	r30, r24
   16184:	f1 1d       	adc	r31, r1
   16186:	80 81       	ld	r24, Z
   16188:	80 93 73 00 	sts	0x0073, r24
			TWCR = _BV(TWINT) | _BV(TWEN);
   1618c:	90 93 74 00 	sts	0x0074, r25
			_rtc_response;
   16190:	80 91 74 00 	lds	r24, 0x0074
   16194:	87 ff       	sbrs	r24, 7
   16196:	fc cf       	rjmp	.-8      	; 0x16190 <_rtc+0x76>
			if(TW_STATUS == TW_MT_DATA_NACK)
   16198:	80 91 71 00 	lds	r24, 0x0071
   1619c:	88 7f       	andi	r24, 0xF8	; 248
   1619e:	80 33       	cpi	r24, 0x30	; 48
   161a0:	09 f4       	brne	.+2      	; 0x161a4 <_rtc+0x8a>
   161a2:	7b c0       	rjmp	.+246    	; 0x1629a <_rtc+0x180>
		TWCR = _BV(TWINT) | _BV(TWEN);
		_rtc_response;
		if(TW_STATUS != TW_MT_DATA_ACK)
			return 1;

		for(; __len > 0; __len--){
   161a4:	21 50       	subi	r18, 0x01	; 1
   161a6:	30 40       	sbci	r19, 0x00	; 0
   161a8:	86 2f       	mov	r24, r22
   161aa:	82 1b       	sub	r24, r18
   161ac:	12 16       	cp	r1, r18
   161ae:	13 06       	cpc	r1, r19
   161b0:	3c f3       	brlt	.-50     	; 0x16180 <_rtc+0x66>
   161b2:	6e c0       	rjmp	.+220    	; 0x16290 <_rtc+0x176>
		}

		TWCR = _BV(TWINT) | _BV(TWSTO) | _BV(TWEN);
	}
	else{
		TWCR =_BV(TWINT) | _BV(TWSTA) | _BV(TWEN);
   161b4:	84 ea       	ldi	r24, 0xA4	; 164
   161b6:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   161ba:	80 91 74 00 	lds	r24, 0x0074
   161be:	87 ff       	sbrs	r24, 7
   161c0:	fc cf       	rjmp	.-8      	; 0x161ba <_rtc+0xa0>
		if(TW_STATUS != TW_START)
   161c2:	80 91 71 00 	lds	r24, 0x0071
   161c6:	88 7f       	andi	r24, 0xF8	; 248
   161c8:	88 30       	cpi	r24, 0x08	; 8
   161ca:	09 f0       	breq	.+2      	; 0x161ce <_rtc+0xb4>
   161cc:	66 c0       	rjmp	.+204    	; 0x1629a <_rtc+0x180>
			return 1;

		TWDR = _DS1307W;
   161ce:	80 ed       	ldi	r24, 0xD0	; 208
   161d0:	80 93 73 00 	sts	0x0073, r24
		TWCR = _BV(TWINT) | _BV(TWEN);
   161d4:	84 e8       	ldi	r24, 0x84	; 132
   161d6:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   161da:	80 91 74 00 	lds	r24, 0x0074
   161de:	87 ff       	sbrs	r24, 7
   161e0:	fc cf       	rjmp	.-8      	; 0x161da <_rtc+0xc0>
		if(TW_STATUS != TW_MT_SLA_ACK)
   161e2:	80 91 71 00 	lds	r24, 0x0071
   161e6:	88 7f       	andi	r24, 0xF8	; 248
   161e8:	88 31       	cpi	r24, 0x18	; 24
   161ea:	09 f0       	breq	.+2      	; 0x161ee <_rtc+0xd4>
   161ec:	56 c0       	rjmp	.+172    	; 0x1629a <_rtc+0x180>
			return 1;

		TWDR = __addr;
   161ee:	90 93 73 00 	sts	0x0073, r25
		TWCR = _BV(TWINT) | _BV(TWEN);
   161f2:	84 e8       	ldi	r24, 0x84	; 132
   161f4:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   161f8:	80 91 74 00 	lds	r24, 0x0074
   161fc:	87 ff       	sbrs	r24, 7
   161fe:	fc cf       	rjmp	.-8      	; 0x161f8 <_rtc+0xde>
		if(TW_STATUS != TW_MT_DATA_ACK)
   16200:	80 91 71 00 	lds	r24, 0x0071
   16204:	88 7f       	andi	r24, 0xF8	; 248
   16206:	88 32       	cpi	r24, 0x28	; 40
   16208:	09 f0       	breq	.+2      	; 0x1620c <_rtc+0xf2>
   1620a:	47 c0       	rjmp	.+142    	; 0x1629a <_rtc+0x180>
			return 1;

		TWCR =_BV(TWINT) | _BV(TWSTA) | _BV(TWEN);
   1620c:	84 ea       	ldi	r24, 0xA4	; 164
   1620e:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   16212:	80 91 74 00 	lds	r24, 0x0074
   16216:	87 ff       	sbrs	r24, 7
   16218:	fc cf       	rjmp	.-8      	; 0x16212 <_rtc+0xf8>
		if(TW_STATUS != TW_REP_START)
   1621a:	80 91 71 00 	lds	r24, 0x0071
   1621e:	88 7f       	andi	r24, 0xF8	; 248
   16220:	80 31       	cpi	r24, 0x10	; 16
   16222:	d9 f5       	brne	.+118    	; 0x1629a <_rtc+0x180>
			return 1;

		TWDR = _DS1307R;
   16224:	81 ed       	ldi	r24, 0xD1	; 209
   16226:	80 93 73 00 	sts	0x0073, r24
		TWCR =_BV(TWINT) | _BV(TWEN);
   1622a:	84 e8       	ldi	r24, 0x84	; 132
   1622c:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   16230:	80 91 74 00 	lds	r24, 0x0074
   16234:	87 ff       	sbrs	r24, 7
   16236:	fc cf       	rjmp	.-8      	; 0x16230 <_rtc+0x116>
		if(TW_STATUS != TW_MR_SLA_ACK)
   16238:	80 91 71 00 	lds	r24, 0x0071
   1623c:	88 7f       	andi	r24, 0xF8	; 248
   1623e:	80 34       	cpi	r24, 0x40	; 64
   16240:	61 f5       	brne	.+88     	; 0x1629a <_rtc+0x180>
   16242:	24 ec       	ldi	r18, 0xC4	; 196
   16244:	30 e0       	ldi	r19, 0x00	; 0
   16246:	90 e0       	ldi	r25, 0x00	; 0
   16248:	20 c0       	rjmp	.+64     	; 0x1628a <_rtc+0x170>
			return 1;

		for(__twcr = _BV(TWINT) | _BV(TWEN) | _BV(TWEA); __len > 0; __len--){
			if(__len == 1)
   1624a:	61 30       	cpi	r22, 0x01	; 1
   1624c:	71 05       	cpc	r23, r1
   1624e:	11 f4       	brne	.+4      	; 0x16254 <_rtc+0x13a>
   16250:	24 e8       	ldi	r18, 0x84	; 132
   16252:	30 e0       	ldi	r19, 0x00	; 0
				__twcr = _BV(TWINT) | _BV(TWEN);
			TWCR = __twcr;
   16254:	20 93 74 00 	sts	0x0074, r18
			_rtc_response;
   16258:	80 91 74 00 	lds	r24, 0x0074
   1625c:	87 ff       	sbrs	r24, 7
   1625e:	fc cf       	rjmp	.-8      	; 0x16258 <_rtc+0x13e>
			if(TW_STATUS == TW_MR_DATA_NACK)
   16260:	80 91 71 00 	lds	r24, 0x0071
   16264:	88 7f       	andi	r24, 0xF8	; 248
   16266:	88 35       	cpi	r24, 0x58	; 88
   16268:	11 f4       	brne	.+4      	; 0x1626e <_rtc+0x154>
   1626a:	60 e0       	ldi	r22, 0x00	; 0
   1626c:	70 e0       	ldi	r23, 0x00	; 0
				__len = 0;
			if(TW_STATUS == TW_MR_DATA_ACK)
   1626e:	80 91 71 00 	lds	r24, 0x0071
   16272:	88 7f       	andi	r24, 0xF8	; 248
   16274:	80 35       	cpi	r24, 0x50	; 80
   16276:	39 f4       	brne	.+14     	; 0x16286 <_rtc+0x16c>
				__datetime[__i++] = TWDR;
   16278:	80 91 73 00 	lds	r24, 0x0073
   1627c:	fa 01       	movw	r30, r20
   1627e:	e9 0f       	add	r30, r25
   16280:	f1 1d       	adc	r31, r1
   16282:	80 83       	st	Z, r24
   16284:	9f 5f       	subi	r25, 0xFF	; 255
		TWCR =_BV(TWINT) | _BV(TWEN);
		_rtc_response;
		if(TW_STATUS != TW_MR_SLA_ACK)
			return 1;

		for(__twcr = _BV(TWINT) | _BV(TWEN) | _BV(TWEA); __len > 0; __len--){
   16286:	61 50       	subi	r22, 0x01	; 1
   16288:	70 40       	sbci	r23, 0x00	; 0
   1628a:	16 16       	cp	r1, r22
   1628c:	17 06       	cpc	r1, r23
   1628e:	ec f2       	brlt	.-70     	; 0x1624a <_rtc+0x130>
			if(TW_STATUS == TW_MR_DATA_NACK)
				__len = 0;
			if(TW_STATUS == TW_MR_DATA_ACK)
				__datetime[__i++] = TWDR;
		}
		TWCR = _BV(TWINT) | _BV(TWSTO) | _BV(TWEN);
   16290:	84 e9       	ldi	r24, 0x94	; 148
   16292:	80 93 74 00 	sts	0x0074, r24
   16296:	80 e0       	ldi	r24, 0x00	; 0
   16298:	08 95       	ret
   1629a:	81 e0       	ldi	r24, 0x01	; 1
	}

    return 0;
}
   1629c:	08 95       	ret

0001629e <_datetime>:

void _datetime(unsigned char __mode, char* __date, char* __time){
   1629e:	ef 92       	push	r14
   162a0:	ff 92       	push	r15
   162a2:	0f 93       	push	r16
   162a4:	1f 93       	push	r17
   162a6:	df 93       	push	r29
   162a8:	cf 93       	push	r28
   162aa:	cd b7       	in	r28, 0x3d	; 61
   162ac:	de b7       	in	r29, 0x3e	; 62
   162ae:	64 97       	sbiw	r28, 0x14	; 20
   162b0:	0f b6       	in	r0, 0x3f	; 63
   162b2:	f8 94       	cli
   162b4:	de bf       	out	0x3e, r29	; 62
   162b6:	0f be       	out	0x3f, r0	; 63
   162b8:	cd bf       	out	0x3d, r28	; 61
   162ba:	28 2f       	mov	r18, r24
   162bc:	8b 01       	movw	r16, r22
   162be:	7a 01       	movw	r14, r20
   162c0:	ae 01       	movw	r20, r28
   162c2:	4f 5f       	subi	r20, 0xFF	; 255
   162c4:	5f 4f       	sbci	r21, 0xFF	; 255
	char	__datetime[20];

	if(__mode){
   162c6:	88 23       	and	r24, r24
   162c8:	99 f1       	breq	.+102    	; 0x16330 <_datetime+0x92>
		__datetime[4] = (((__date[0] - 0x30) & 0x0F) << 4) + ((__date[1] - 0x30) & 0x0F);
   162ca:	fb 01       	movw	r30, r22
   162cc:	90 81       	ld	r25, Z
   162ce:	92 95       	swap	r25
   162d0:	90 7f       	andi	r25, 0xF0	; 240
   162d2:	81 81       	ldd	r24, Z+1	; 0x01
   162d4:	8f 70       	andi	r24, 0x0F	; 15
   162d6:	98 0f       	add	r25, r24
   162d8:	9d 83       	std	Y+5, r25	; 0x05
		__datetime[5] = (((__date[3] - 0x30) & 0x0F) << 4) + ((__date[4] - 0x30) & 0x0F);
   162da:	93 81       	ldd	r25, Z+3	; 0x03
   162dc:	92 95       	swap	r25
   162de:	90 7f       	andi	r25, 0xF0	; 240
   162e0:	84 81       	ldd	r24, Z+4	; 0x04
   162e2:	8f 70       	andi	r24, 0x0F	; 15
   162e4:	98 0f       	add	r25, r24
   162e6:	9e 83       	std	Y+6, r25	; 0x06
		__datetime[6] = (((__date[6] - 0x30) & 0x0F) << 4) + ((__date[7] - 0x30) & 0x0F);
   162e8:	96 81       	ldd	r25, Z+6	; 0x06
   162ea:	92 95       	swap	r25
   162ec:	90 7f       	andi	r25, 0xF0	; 240
   162ee:	87 81       	ldd	r24, Z+7	; 0x07
   162f0:	8f 70       	andi	r24, 0x0F	; 15
   162f2:	98 0f       	add	r25, r24
   162f4:	9f 83       	std	Y+7, r25	; 0x07

		__datetime[2] = (((__time[0] - 0x30) & 0x0F) << 4) + ((__time[1] - 0x30) & 0x0F);
   162f6:	f7 01       	movw	r30, r14
   162f8:	90 81       	ld	r25, Z
   162fa:	92 95       	swap	r25
   162fc:	90 7f       	andi	r25, 0xF0	; 240
   162fe:	81 81       	ldd	r24, Z+1	; 0x01
   16300:	8f 70       	andi	r24, 0x0F	; 15
   16302:	98 0f       	add	r25, r24
   16304:	9b 83       	std	Y+3, r25	; 0x03
		__datetime[1] = (((__time[3] - 0x30) & 0x0F) << 4) + ((__time[4] - 0x30) & 0x0F);
   16306:	93 81       	ldd	r25, Z+3	; 0x03
   16308:	92 95       	swap	r25
   1630a:	90 7f       	andi	r25, 0xF0	; 240
   1630c:	84 81       	ldd	r24, Z+4	; 0x04
   1630e:	8f 70       	andi	r24, 0x0F	; 15
   16310:	98 0f       	add	r25, r24
   16312:	9a 83       	std	Y+2, r25	; 0x02
		__datetime[0] = (((__time[6] - 0x30) & 0x0F) << 4) + ((__time[7] - 0x30) & 0x0F);
   16314:	96 81       	ldd	r25, Z+6	; 0x06
   16316:	92 95       	swap	r25
   16318:	90 7f       	andi	r25, 0xF0	; 240
   1631a:	87 81       	ldd	r24, Z+7	; 0x07
   1631c:	8f 70       	andi	r24, 0x0F	; 15
   1631e:	98 0f       	add	r25, r24
   16320:	99 83       	std	Y+1, r25	; 0x01
		_rtc(0, 8, __datetime, __mode);
   16322:	80 e0       	ldi	r24, 0x00	; 0
   16324:	90 e0       	ldi	r25, 0x00	; 0
   16326:	68 e0       	ldi	r22, 0x08	; 8
   16328:	70 e0       	ldi	r23, 0x00	; 0
   1632a:	0e 94 8d b0 	call	0x1611a	; 0x1611a <_rtc>
   1632e:	4a c0       	rjmp	.+148    	; 0x163c4 <_datetime+0x126>
	}
	else
		if(_rtc(0, 8, __datetime, __mode) != 1){
   16330:	80 e0       	ldi	r24, 0x00	; 0
   16332:	90 e0       	ldi	r25, 0x00	; 0
   16334:	68 e0       	ldi	r22, 0x08	; 8
   16336:	70 e0       	ldi	r23, 0x00	; 0
   16338:	20 e0       	ldi	r18, 0x00	; 0
   1633a:	0e 94 8d b0 	call	0x1611a	; 0x1611a <_rtc>
   1633e:	81 30       	cpi	r24, 0x01	; 1
   16340:	09 f4       	brne	.+2      	; 0x16344 <_datetime+0xa6>
   16342:	40 c0       	rjmp	.+128    	; 0x163c4 <_datetime+0x126>
			__date[0] = (__datetime[4] >> 4) + 0x30;
   16344:	9d 81       	ldd	r25, Y+5	; 0x05
   16346:	89 2f       	mov	r24, r25
   16348:	82 95       	swap	r24
   1634a:	8f 70       	andi	r24, 0x0F	; 15
   1634c:	80 5d       	subi	r24, 0xD0	; 208
   1634e:	f8 01       	movw	r30, r16
   16350:	80 83       	st	Z, r24
			__date[1] = (__datetime[4] & 0x0F) + 0x30;
   16352:	9f 70       	andi	r25, 0x0F	; 15
   16354:	90 5d       	subi	r25, 0xD0	; 208
   16356:	91 83       	std	Z+1, r25	; 0x01
			__date[2] = '/';
   16358:	2f e2       	ldi	r18, 0x2F	; 47
   1635a:	22 83       	std	Z+2, r18	; 0x02
			__date[3] = (__datetime[5] >> 4) + 0x30;
   1635c:	9e 81       	ldd	r25, Y+6	; 0x06
   1635e:	89 2f       	mov	r24, r25
   16360:	82 95       	swap	r24
   16362:	8f 70       	andi	r24, 0x0F	; 15
   16364:	80 5d       	subi	r24, 0xD0	; 208
   16366:	83 83       	std	Z+3, r24	; 0x03
			__date[4] = (__datetime[5] & 0x0F) + 0x30;
   16368:	9f 70       	andi	r25, 0x0F	; 15
   1636a:	90 5d       	subi	r25, 0xD0	; 208
   1636c:	94 83       	std	Z+4, r25	; 0x04
			__date[5] = '/';
   1636e:	25 83       	std	Z+5, r18	; 0x05
			__date[6] = (__datetime[6] >> 4) + 0x30;
   16370:	9f 81       	ldd	r25, Y+7	; 0x07
   16372:	89 2f       	mov	r24, r25
   16374:	82 95       	swap	r24
   16376:	8f 70       	andi	r24, 0x0F	; 15
   16378:	80 5d       	subi	r24, 0xD0	; 208
   1637a:	86 83       	std	Z+6, r24	; 0x06
			__date[7] = (__datetime[6] & 0x0F) + 0x30;
   1637c:	9f 70       	andi	r25, 0x0F	; 15
   1637e:	90 5d       	subi	r25, 0xD0	; 208
   16380:	97 83       	std	Z+7, r25	; 0x07
			__date[8] = '\0';
   16382:	10 86       	std	Z+8, r1	; 0x08

			__time[0] = (__datetime[2] >> 4) + 0x30;
   16384:	9b 81       	ldd	r25, Y+3	; 0x03
   16386:	89 2f       	mov	r24, r25
   16388:	82 95       	swap	r24
   1638a:	8f 70       	andi	r24, 0x0F	; 15
   1638c:	80 5d       	subi	r24, 0xD0	; 208
   1638e:	f7 01       	movw	r30, r14
   16390:	80 83       	st	Z, r24
			__time[1] = (__datetime[2] & 0x0F) + 0x30;
   16392:	9f 70       	andi	r25, 0x0F	; 15
   16394:	90 5d       	subi	r25, 0xD0	; 208
   16396:	91 83       	std	Z+1, r25	; 0x01
			__time[2] = ':';
   16398:	2a e3       	ldi	r18, 0x3A	; 58
   1639a:	22 83       	std	Z+2, r18	; 0x02
			__time[3] = (__datetime[1] >> 4) + 0x30;
   1639c:	9a 81       	ldd	r25, Y+2	; 0x02
   1639e:	89 2f       	mov	r24, r25
   163a0:	82 95       	swap	r24
   163a2:	8f 70       	andi	r24, 0x0F	; 15
   163a4:	80 5d       	subi	r24, 0xD0	; 208
   163a6:	83 83       	std	Z+3, r24	; 0x03
			__time[4] = (__datetime[1] & 0x0F) + 0x30;
   163a8:	9f 70       	andi	r25, 0x0F	; 15
   163aa:	90 5d       	subi	r25, 0xD0	; 208
   163ac:	94 83       	std	Z+4, r25	; 0x04
			__time[5] = ':';
   163ae:	25 83       	std	Z+5, r18	; 0x05
			__time[6] = (__datetime[0] >> 4) + 0x30;
   163b0:	99 81       	ldd	r25, Y+1	; 0x01
   163b2:	89 2f       	mov	r24, r25
   163b4:	82 95       	swap	r24
   163b6:	8f 70       	andi	r24, 0x0F	; 15
   163b8:	80 5d       	subi	r24, 0xD0	; 208
   163ba:	86 83       	std	Z+6, r24	; 0x06
			__time[7] = (__datetime[0] & 0x0F) + 0x30;
   163bc:	9f 70       	andi	r25, 0x0F	; 15
   163be:	90 5d       	subi	r25, 0xD0	; 208
   163c0:	97 83       	std	Z+7, r25	; 0x07
			__time[8] = '\0';
   163c2:	10 86       	std	Z+8, r1	; 0x08
		}
}
   163c4:	64 96       	adiw	r28, 0x14	; 20
   163c6:	0f b6       	in	r0, 0x3f	; 63
   163c8:	f8 94       	cli
   163ca:	de bf       	out	0x3e, r29	; 62
   163cc:	0f be       	out	0x3f, r0	; 63
   163ce:	cd bf       	out	0x3d, r28	; 61
   163d0:	cf 91       	pop	r28
   163d2:	df 91       	pop	r29
   163d4:	1f 91       	pop	r17
   163d6:	0f 91       	pop	r16
   163d8:	ff 90       	pop	r15
   163da:	ef 90       	pop	r14
   163dc:	08 95       	ret

000163de <_day>:

unsigned char _day(void){
   163de:	df 93       	push	r29
   163e0:	cf 93       	push	r28
   163e2:	cd b7       	in	r28, 0x3d	; 61
   163e4:	de b7       	in	r29, 0x3e	; 62
   163e6:	64 97       	sbiw	r28, 0x14	; 20
   163e8:	0f b6       	in	r0, 0x3f	; 63
   163ea:	f8 94       	cli
   163ec:	de bf       	out	0x3e, r29	; 62
   163ee:	0f be       	out	0x3f, r0	; 63
   163f0:	cd bf       	out	0x3d, r28	; 61
	char	__datetime[20];

	if(_rtc(0, 8, __datetime, 0) != 1)
   163f2:	80 e0       	ldi	r24, 0x00	; 0
   163f4:	90 e0       	ldi	r25, 0x00	; 0
   163f6:	68 e0       	ldi	r22, 0x08	; 8
   163f8:	70 e0       	ldi	r23, 0x00	; 0
   163fa:	ae 01       	movw	r20, r28
   163fc:	4f 5f       	subi	r20, 0xFF	; 255
   163fe:	5f 4f       	sbci	r21, 0xFF	; 255
   16400:	20 e0       	ldi	r18, 0x00	; 0
   16402:	0e 94 8d b0 	call	0x1611a	; 0x1611a <_rtc>
   16406:	81 30       	cpi	r24, 0x01	; 1
   16408:	11 f4       	brne	.+4      	; 0x1640e <_day+0x30>
   1640a:	80 e0       	ldi	r24, 0x00	; 0
   1640c:	02 c0       	rjmp	.+4      	; 0x16412 <_day+0x34>
		return __datetime[3] & 0x0F;
   1640e:	8c 81       	ldd	r24, Y+4	; 0x04
   16410:	8f 70       	andi	r24, 0x0F	; 15
	return 0;
   16412:	64 96       	adiw	r28, 0x14	; 20
   16414:	0f b6       	in	r0, 0x3f	; 63
   16416:	f8 94       	cli
   16418:	de bf       	out	0x3e, r29	; 62
   1641a:	0f be       	out	0x3f, r0	; 63
   1641c:	cd bf       	out	0x3d, r28	; 61
   1641e:	cf 91       	pop	r28
   16420:	df 91       	pop	r29
   16422:	08 95       	ret

00016424 <_uart_baudrate>:
	}

	_uart_baudrate(__com, __baudrate);
}

void _uart_baudrate(unsigned char __com, unsigned long __baudrate){
   16424:	1f 93       	push	r17
   16426:	18 2f       	mov	r17, r24
   16428:	9a 01       	movw	r18, r20
   1642a:	ab 01       	movw	r20, r22
	unsigned long __br;

	__br = (unsigned long)((_CPU_DEFAULT + (__baudrate * 8)) / (__baudrate * 16) - 1);
   1642c:	ca 01       	movw	r24, r20
   1642e:	b9 01       	movw	r22, r18
   16430:	60 50       	subi	r22, 0x00	; 0
   16432:	70 4e       	sbci	r23, 0xE0	; 224
   16434:	83 4e       	sbci	r24, 0xE3	; 227
   16436:	9f 4f       	sbci	r25, 0xFF	; 255
   16438:	f3 e0       	ldi	r31, 0x03	; 3
   1643a:	66 0f       	add	r22, r22
   1643c:	77 1f       	adc	r23, r23
   1643e:	88 1f       	adc	r24, r24
   16440:	99 1f       	adc	r25, r25
   16442:	fa 95       	dec	r31
   16444:	d1 f7       	brne	.-12     	; 0x1643a <_uart_baudrate+0x16>
   16446:	e4 e0       	ldi	r30, 0x04	; 4
   16448:	22 0f       	add	r18, r18
   1644a:	33 1f       	adc	r19, r19
   1644c:	44 1f       	adc	r20, r20
   1644e:	55 1f       	adc	r21, r21
   16450:	ea 95       	dec	r30
   16452:	d1 f7       	brne	.-12     	; 0x16448 <_uart_baudrate+0x24>
   16454:	0e 94 31 b7 	call	0x16e62	; 0x16e62 <__udivmodsi4>
   16458:	21 50       	subi	r18, 0x01	; 1
   1645a:	30 40       	sbci	r19, 0x00	; 0
   1645c:	40 40       	sbci	r20, 0x00	; 0
   1645e:	50 40       	sbci	r21, 0x00	; 0
   16460:	bb 27       	eor	r27, r27
   16462:	a5 2f       	mov	r26, r21
   16464:	94 2f       	mov	r25, r20
   16466:	83 2f       	mov	r24, r19

	if(__com){
   16468:	11 23       	and	r17, r17
   1646a:	29 f0       	breq	.+10     	; 0x16476 <_uart_baudrate+0x52>
		UBRR1L = __br;
   1646c:	20 93 99 00 	sts	0x0099, r18
		UBRR1H = __br >> 8;
   16470:	80 93 98 00 	sts	0x0098, r24
   16474:	03 c0       	rjmp	.+6      	; 0x1647c <_uart_baudrate+0x58>
	}
	else{
		UBRR0L = __br;
   16476:	29 b9       	out	0x09, r18	; 9
		UBRR0H = __br >> 8;
   16478:	80 93 90 00 	sts	0x0090, r24
	}
}
   1647c:	1f 91       	pop	r17
   1647e:	08 95       	ret

00016480 <_uart_init>:
#include <util/delay.h>
#include <string.h>

#include "UART.h"

void _uart_init(unsigned char __com, unsigned long __baudrate){
   16480:	98 2f       	mov	r25, r24
	if(__com){
   16482:	88 23       	and	r24, r24
   16484:	39 f0       	breq	.+14     	; 0x16494 <_uart_init+0x14>
		UCSR1B = _BV(RXCIE1) | _BV(RXEN1) | _BV(TXEN1);
   16486:	88 e9       	ldi	r24, 0x98	; 152
   16488:	80 93 9a 00 	sts	0x009A, r24
		UCSR1C = _BV(UCSZ11) | _BV(UCSZ10);
   1648c:	86 e0       	ldi	r24, 0x06	; 6
   1648e:	80 93 9d 00 	sts	0x009D, r24
   16492:	05 c0       	rjmp	.+10     	; 0x1649e <_uart_init+0x1e>
	}
	else{
		UCSR0B = _BV(RXCIE0) | _BV(RXEN0) | _BV(TXEN0);
   16494:	88 e9       	ldi	r24, 0x98	; 152
   16496:	8a b9       	out	0x0a, r24	; 10
		UCSR0C = _BV(UCSZ01) | _BV(UCSZ00);
   16498:	86 e0       	ldi	r24, 0x06	; 6
   1649a:	80 93 95 00 	sts	0x0095, r24
	}

	_uart_baudrate(__com, __baudrate);
   1649e:	89 2f       	mov	r24, r25
   164a0:	0e 94 12 b2 	call	0x16424	; 0x16424 <_uart_baudrate>
}
   164a4:	08 95       	ret

000164a6 <_uart>:
		UBRR0H = __br >> 8;
	}
}

unsigned char _uart(unsigned char __com, unsigned char __dir, unsigned char __chr){
	if(__com){
   164a6:	88 23       	and	r24, r24
   164a8:	81 f0       	breq	.+32     	; 0x164ca <_uart+0x24>
		if(__dir){
   164aa:	66 23       	and	r22, r22
   164ac:	39 f0       	breq	.+14     	; 0x164bc <_uart+0x16>
			loop_until_bit_is_set(UCSR1A, UDRE1);
   164ae:	80 91 9b 00 	lds	r24, 0x009B
   164b2:	85 ff       	sbrs	r24, 5
   164b4:	fc cf       	rjmp	.-8      	; 0x164ae <_uart+0x8>
			UDR1 = __chr;
   164b6:	40 93 9c 00 	sts	0x009C, r20
   164ba:	0c c0       	rjmp	.+24     	; 0x164d4 <_uart+0x2e>
		}
		else{
			loop_until_bit_is_set(UCSR1A, RXC);
   164bc:	80 91 9b 00 	lds	r24, 0x009B
   164c0:	87 ff       	sbrs	r24, 7
   164c2:	fc cf       	rjmp	.-8      	; 0x164bc <_uart+0x16>
			return UDR1;
   164c4:	80 91 9c 00 	lds	r24, 0x009C
   164c8:	08 95       	ret
		}
	}
	else{
		if(__dir){
   164ca:	66 23       	and	r22, r22
   164cc:	29 f0       	breq	.+10     	; 0x164d8 <_uart+0x32>
			loop_until_bit_is_set(UCSR0A, UDRE0);
   164ce:	5d 9b       	sbis	0x0b, 5	; 11
   164d0:	fe cf       	rjmp	.-4      	; 0x164ce <_uart+0x28>
			UDR0 = __chr;
   164d2:	4c b9       	out	0x0c, r20	; 12
   164d4:	81 e0       	ldi	r24, 0x01	; 1
   164d6:	08 95       	ret
		}
		else{
			loop_until_bit_is_set(UCSR0A,  RXC);
   164d8:	5f 9b       	sbis	0x0b, 7	; 11
   164da:	fe cf       	rjmp	.-4      	; 0x164d8 <_uart+0x32>
			return UDR0;
   164dc:	8c b1       	in	r24, 0x0c	; 12
		}

	}

	return 1;
}
   164de:	08 95       	ret

000164e0 <_uart_print>:

void _uart_print(unsigned char __com, unsigned char __ret, char *__str){
   164e0:	0f 93       	push	r16
   164e2:	1f 93       	push	r17
   164e4:	cf 93       	push	r28
   164e6:	df 93       	push	r29
   164e8:	18 2f       	mov	r17, r24
   164ea:	06 2f       	mov	r16, r22
   164ec:	ea 01       	movw	r28, r20
	if(strlen(__str)>0)
   164ee:	88 81       	ld	r24, Y
   164f0:	88 23       	and	r24, r24
   164f2:	31 f4       	brne	.+12     	; 0x16500 <_uart_print+0x20>
   164f4:	08 c0       	rjmp	.+16     	; 0x16506 <_uart_print+0x26>
		while(*__str)
		     _uart(__com, 1, *__str++);
   164f6:	21 96       	adiw	r28, 0x01	; 1
   164f8:	81 2f       	mov	r24, r17
   164fa:	61 e0       	ldi	r22, 0x01	; 1
   164fc:	0e 94 53 b2 	call	0x164a6	; 0x164a6 <_uart>
	return 1;
}

void _uart_print(unsigned char __com, unsigned char __ret, char *__str){
	if(strlen(__str)>0)
		while(*__str)
   16500:	48 81       	ld	r20, Y
   16502:	44 23       	and	r20, r20
   16504:	c1 f7       	brne	.-16     	; 0x164f6 <_uart_print+0x16>
		     _uart(__com, 1, *__str++);

	if(__ret){
   16506:	00 23       	and	r16, r16
   16508:	51 f0       	breq	.+20     	; 0x1651e <_uart_print+0x3e>
		_uart(__com, 1, 0x0D);
   1650a:	81 2f       	mov	r24, r17
   1650c:	61 e0       	ldi	r22, 0x01	; 1
   1650e:	4d e0       	ldi	r20, 0x0D	; 13
   16510:	0e 94 53 b2 	call	0x164a6	; 0x164a6 <_uart>
		_uart(__com, 1, 0x0A);
   16514:	81 2f       	mov	r24, r17
   16516:	61 e0       	ldi	r22, 0x01	; 1
   16518:	4a e0       	ldi	r20, 0x0A	; 10
   1651a:	0e 94 53 b2 	call	0x164a6	; 0x164a6 <_uart>
   1651e:	82 ee       	ldi	r24, 0xE2	; 226
   16520:	94 e0       	ldi	r25, 0x04	; 4
   16522:	01 97       	sbiw	r24, 0x01	; 1
   16524:	f1 f7       	brne	.-4      	; 0x16522 <_uart_print+0x42>
	}
	_delay_ms(5);
}
   16526:	df 91       	pop	r29
   16528:	cf 91       	pop	r28
   1652a:	1f 91       	pop	r17
   1652c:	0f 91       	pop	r16
   1652e:	08 95       	ret

00016530 <_uart_printf>:

void _uart_printf(unsigned char __com, unsigned char __ret, char *__str){
   16530:	0f 93       	push	r16
   16532:	1f 93       	push	r17
   16534:	cf 93       	push	r28
   16536:	df 93       	push	r29
   16538:	18 2f       	mov	r17, r24
   1653a:	06 2f       	mov	r16, r22
   1653c:	ea 01       	movw	r28, r20
   1653e:	07 c0       	rjmp	.+14     	; 0x1654e <_uart_printf+0x1e>
	while(pgm_read_byte(&(*__str)))
		_uart(__com, 1, pgm_read_byte(&(*__str++)));
   16540:	21 96       	adiw	r28, 0x01	; 1
   16542:	f9 01       	movw	r30, r18
   16544:	44 91       	lpm	r20, Z+
   16546:	81 2f       	mov	r24, r17
   16548:	61 e0       	ldi	r22, 0x01	; 1
   1654a:	0e 94 53 b2 	call	0x164a6	; 0x164a6 <_uart>
   1654e:	9e 01       	movw	r18, r28
	}
	_delay_ms(5);
}

void _uart_printf(unsigned char __com, unsigned char __ret, char *__str){
	while(pgm_read_byte(&(*__str)))
   16550:	fe 01       	movw	r30, r28
   16552:	84 91       	lpm	r24, Z+
   16554:	88 23       	and	r24, r24
   16556:	a1 f7       	brne	.-24     	; 0x16540 <_uart_printf+0x10>
		_uart(__com, 1, pgm_read_byte(&(*__str++)));

	if(__ret){
   16558:	00 23       	and	r16, r16
   1655a:	51 f0       	breq	.+20     	; 0x16570 <_uart_printf+0x40>
		_uart(__com, 1, 0x0D);
   1655c:	81 2f       	mov	r24, r17
   1655e:	61 e0       	ldi	r22, 0x01	; 1
   16560:	4d e0       	ldi	r20, 0x0D	; 13
   16562:	0e 94 53 b2 	call	0x164a6	; 0x164a6 <_uart>
		_uart(__com, 1, 0x0A);
   16566:	81 2f       	mov	r24, r17
   16568:	61 e0       	ldi	r22, 0x01	; 1
   1656a:	4a e0       	ldi	r20, 0x0A	; 10
   1656c:	0e 94 53 b2 	call	0x164a6	; 0x164a6 <_uart>
   16570:	86 ea       	ldi	r24, 0xA6	; 166
   16572:	9e e0       	ldi	r25, 0x0E	; 14
   16574:	01 97       	sbiw	r24, 0x01	; 1
   16576:	f1 f7       	brne	.-4      	; 0x16574 <_uart_printf+0x44>
	}
	_delay_ms(15);
}
   16578:	df 91       	pop	r29
   1657a:	cf 91       	pop	r28
   1657c:	1f 91       	pop	r17
   1657e:	0f 91       	pop	r16
   16580:	08 95       	ret

00016582 <Int2Str>:

void Int2Str(char* __string, unsigned long __value){
   16582:	6f 92       	push	r6
   16584:	7f 92       	push	r7
   16586:	8f 92       	push	r8
   16588:	9f 92       	push	r9
   1658a:	af 92       	push	r10
   1658c:	bf 92       	push	r11
   1658e:	cf 92       	push	r12
   16590:	df 92       	push	r13
   16592:	ef 92       	push	r14
   16594:	ff 92       	push	r15
   16596:	0f 93       	push	r16
   16598:	1f 93       	push	r17
   1659a:	cf 93       	push	r28
   1659c:	df 93       	push	r29
   1659e:	ec 01       	movw	r28, r24
	char			__flag = 0, __i = 0, __count;
	unsigned long	__num, __devider = 1000000000;
	int				__tmp;

	if(__value == 0){
   165a0:	41 15       	cp	r20, r1
   165a2:	51 05       	cpc	r21, r1
   165a4:	61 05       	cpc	r22, r1
   165a6:	71 05       	cpc	r23, r1
   165a8:	21 f4       	brne	.+8      	; 0x165b2 <Int2Str+0x30>
		__string[0] = '0';
   165aa:	80 e3       	ldi	r24, 0x30	; 48
   165ac:	88 83       	st	Y, r24
		__string[1] = '\0';
   165ae:	19 82       	std	Y+1, r1	; 0x01
   165b0:	48 c0       	rjmp	.+144    	; 0x16642 <Int2Str+0xc0>
		return;
   165b2:	4a 01       	movw	r8, r20
   165b4:	5b 01       	movw	r10, r22
   165b6:	10 e0       	ldi	r17, 0x00	; 0
   165b8:	00 e0       	ldi	r16, 0x00	; 0
   165ba:	77 24       	eor	r7, r7
   165bc:	c1 2c       	mov	r12, r1
   165be:	ba ec       	ldi	r27, 0xCA	; 202
   165c0:	db 2e       	mov	r13, r27
   165c2:	ba e9       	ldi	r27, 0x9A	; 154
   165c4:	eb 2e       	mov	r14, r27
   165c6:	bb e3       	ldi	r27, 0x3B	; 59
   165c8:	fb 2e       	mov	r15, r27
			if(!__flag)
				__flag = 1;
		}
		else
			if(__flag)
				__string[__i++] = 0x30;
   165ca:	a0 e3       	ldi	r26, 0x30	; 48
   165cc:	6a 2e       	mov	r6, r26
		return;
	}

	__num = __value;
	for(__count = 0; __count < 10; __count++){
		if(__num >= __devider){
   165ce:	8c 14       	cp	r8, r12
   165d0:	9d 04       	cpc	r9, r13
   165d2:	ae 04       	cpc	r10, r14
   165d4:	bf 04       	cpc	r11, r15
   165d6:	d0 f0       	brcs	.+52     	; 0x1660c <Int2Str+0x8a>
			__tmp = (int)(__num / __devider);
   165d8:	c5 01       	movw	r24, r10
   165da:	b4 01       	movw	r22, r8
   165dc:	a7 01       	movw	r20, r14
   165de:	96 01       	movw	r18, r12
   165e0:	0e 94 31 b7 	call	0x16e62	; 0x16e62 <__udivmodsi4>
   165e4:	12 2f       	mov	r17, r18
			__num = __num % __devider;
   165e6:	c5 01       	movw	r24, r10
   165e8:	b4 01       	movw	r22, r8
   165ea:	a7 01       	movw	r20, r14
   165ec:	96 01       	movw	r18, r12
   165ee:	0e 94 31 b7 	call	0x16e62	; 0x16e62 <__udivmodsi4>
   165f2:	ac 01       	movw	r20, r24
   165f4:	cb 01       	movw	r24, r22
   165f6:	da 01       	movw	r26, r20
   165f8:	4c 01       	movw	r8, r24
   165fa:	5d 01       	movw	r10, r26
			__string[__i++] = __tmp + 0x30;
   165fc:	fe 01       	movw	r30, r28
   165fe:	e0 0f       	add	r30, r16
   16600:	f1 1d       	adc	r31, r1
   16602:	10 5d       	subi	r17, 0xD0	; 208
   16604:	10 83       	st	Z, r17
   16606:	0f 5f       	subi	r16, 0xFF	; 255
   16608:	11 e0       	ldi	r17, 0x01	; 1
   1660a:	07 c0       	rjmp	.+14     	; 0x1661a <Int2Str+0x98>
			if(!__flag)
				__flag = 1;
		}
		else
			if(__flag)
   1660c:	11 23       	and	r17, r17
   1660e:	29 f0       	breq	.+10     	; 0x1661a <Int2Str+0x98>
				__string[__i++] = 0x30;
   16610:	fe 01       	movw	r30, r28
   16612:	e0 0f       	add	r30, r16
   16614:	f1 1d       	adc	r31, r1
   16616:	60 82       	st	Z, r6
   16618:	0f 5f       	subi	r16, 0xFF	; 255
		__string[1] = '\0';
		return;
	}

	__num = __value;
	for(__count = 0; __count < 10; __count++){
   1661a:	73 94       	inc	r7
   1661c:	8a e0       	ldi	r24, 0x0A	; 10
   1661e:	78 16       	cp	r7, r24
   16620:	69 f0       	breq	.+26     	; 0x1663c <Int2Str+0xba>
				__flag = 1;
		}
		else
			if(__flag)
				__string[__i++] = 0x30;
		__devider = __devider / 10;
   16622:	c7 01       	movw	r24, r14
   16624:	b6 01       	movw	r22, r12
   16626:	2a e0       	ldi	r18, 0x0A	; 10
   16628:	30 e0       	ldi	r19, 0x00	; 0
   1662a:	40 e0       	ldi	r20, 0x00	; 0
   1662c:	50 e0       	ldi	r21, 0x00	; 0
   1662e:	0e 94 31 b7 	call	0x16e62	; 0x16e62 <__udivmodsi4>
   16632:	c9 01       	movw	r24, r18
   16634:	da 01       	movw	r26, r20
   16636:	6c 01       	movw	r12, r24
   16638:	7d 01       	movw	r14, r26
   1663a:	c9 cf       	rjmp	.-110    	; 0x165ce <Int2Str+0x4c>
	}
	__string[__i] = '\0';
   1663c:	c0 0f       	add	r28, r16
   1663e:	d1 1d       	adc	r29, r1
   16640:	18 82       	st	Y, r1
}
   16642:	df 91       	pop	r29
   16644:	cf 91       	pop	r28
   16646:	1f 91       	pop	r17
   16648:	0f 91       	pop	r16
   1664a:	ff 90       	pop	r15
   1664c:	ef 90       	pop	r14
   1664e:	df 90       	pop	r13
   16650:	cf 90       	pop	r12
   16652:	bf 90       	pop	r11
   16654:	af 90       	pop	r10
   16656:	9f 90       	pop	r9
   16658:	8f 90       	pop	r8
   1665a:	7f 90       	pop	r7
   1665c:	6f 90       	pop	r6
   1665e:	08 95       	ret

00016660 <Str2Int>:

unsigned long Str2Int(char* __string){
   16660:	6f 92       	push	r6
   16662:	7f 92       	push	r7
   16664:	8f 92       	push	r8
   16666:	9f 92       	push	r9
   16668:	af 92       	push	r10
   1666a:	bf 92       	push	r11
   1666c:	cf 92       	push	r12
   1666e:	df 92       	push	r13
   16670:	ef 92       	push	r14
   16672:	ff 92       	push	r15
   16674:	0f 93       	push	r16
   16676:	1f 93       	push	r17
   16678:	cf 93       	push	r28
   1667a:	df 93       	push	r29
   1667c:	ec 01       	movw	r28, r24
	unsigned char	__i, __len;
	unsigned long	__multiplier = 1, __retval = 0;

	__len = strlen(__string);
   1667e:	dc 01       	movw	r26, r24
   16680:	0d 90       	ld	r0, X+
   16682:	00 20       	and	r0, r0
   16684:	e9 f7       	brne	.-6      	; 0x16680 <Str2Int+0x20>
   16686:	11 97       	sbiw	r26, 0x01	; 1
   16688:	7a 2e       	mov	r7, r26
   1668a:	78 1a       	sub	r7, r24

	if(__len > 0 && __len < 11){
   1668c:	87 2d       	mov	r24, r7
   1668e:	81 50       	subi	r24, 0x01	; 1
   16690:	8a 30       	cpi	r24, 0x0A	; 10
   16692:	08 f0       	brcs	.+2      	; 0x16696 <Str2Int+0x36>
   16694:	64 c0       	rjmp	.+200    	; 0x1675e <Str2Int+0xfe>
   16696:	4e 01       	movw	r8, r28
   16698:	fe 01       	movw	r30, r28
		__devider = __devider / 10;
	}
	__string[__i] = '\0';
}

unsigned long Str2Int(char* __string){
   1669a:	6c 2e       	mov	r6, r28
   1669c:	05 c0       	rjmp	.+10     	; 0x166a8 <Str2Int+0x48>

	__len = strlen(__string);

	if(__len > 0 && __len < 11){
		for(__i = 0; __i < __len; __i++)
			if(__string[__i] < 0x30 || __string[__i] > 0x39)
   1669e:	81 91       	ld	r24, Z+
   166a0:	80 53       	subi	r24, 0x30	; 48
   166a2:	8a 30       	cpi	r24, 0x0A	; 10
   166a4:	08 f0       	brcs	.+2      	; 0x166a8 <Str2Int+0x48>
   166a6:	5b c0       	rjmp	.+182    	; 0x1675e <Str2Int+0xfe>
	unsigned long	__multiplier = 1, __retval = 0;

	__len = strlen(__string);

	if(__len > 0 && __len < 11){
		for(__i = 0; __i < __len; __i++)
   166a8:	8e 2f       	mov	r24, r30
   166aa:	86 19       	sub	r24, r6
   166ac:	87 15       	cp	r24, r7
   166ae:	b8 f3       	brcs	.-18     	; 0x1669e <Str2Int+0x3e>
			if(__string[__i] < 0x30 || __string[__i] > 0x39)
				return 0;
		if(__len == 10){
   166b0:	8a e0       	ldi	r24, 0x0A	; 10
   166b2:	78 16       	cp	r7, r24
   166b4:	f9 f4       	brne	.+62     	; 0x166f4 <Str2Int+0x94>
			if(__string[0] < 0x30 || __string[0] > 0x32)
   166b6:	98 81       	ld	r25, Y
   166b8:	89 2f       	mov	r24, r25
   166ba:	80 53       	subi	r24, 0x30	; 48
   166bc:	83 30       	cpi	r24, 0x03	; 3
   166be:	08 f0       	brcs	.+2      	; 0x166c2 <Str2Int+0x62>
   166c0:	4e c0       	rjmp	.+156    	; 0x1675e <Str2Int+0xfe>
				return 0;
			if(__string[0] == 0x32){
   166c2:	92 33       	cpi	r25, 0x32	; 50
   166c4:	b9 f4       	brne	.+46     	; 0x166f4 <Str2Int+0x94>
   166c6:	fe 01       	movw	r30, r28
   166c8:	91 e0       	ldi	r25, 0x01	; 1
				for(__i = 1; __i < __len; __i++)
					if(__string[__i] < 0x30 || __string[__i] > 0x30)
   166ca:	81 81       	ldd	r24, Z+1	; 0x01
   166cc:	80 33       	cpi	r24, 0x30	; 48
   166ce:	09 f0       	breq	.+2      	; 0x166d2 <Str2Int+0x72>
   166d0:	46 c0       	rjmp	.+140    	; 0x1675e <Str2Int+0xfe>
				return 0;
		if(__len == 10){
			if(__string[0] < 0x30 || __string[0] > 0x32)
				return 0;
			if(__string[0] == 0x32){
				for(__i = 1; __i < __len; __i++)
   166d2:	9f 5f       	subi	r25, 0xFF	; 255
   166d4:	31 96       	adiw	r30, 0x01	; 1
   166d6:	9a 30       	cpi	r25, 0x0A	; 10
   166d8:	c1 f7       	brne	.-16     	; 0x166ca <Str2Int+0x6a>
   166da:	0c c0       	rjmp	.+24     	; 0x166f4 <Str2Int+0x94>
					if(__string[__i] < 0x30 || __string[__i] > 0x30)
						return 0;
			}
		}
		for(__i = 0; __i < __len - 1; __i++)
			__multiplier *= 10;
   166dc:	c6 01       	movw	r24, r12
   166de:	b5 01       	movw	r22, r10
   166e0:	2a e0       	ldi	r18, 0x0A	; 10
   166e2:	30 e0       	ldi	r19, 0x00	; 0
   166e4:	40 e0       	ldi	r20, 0x00	; 0
   166e6:	50 e0       	ldi	r21, 0x00	; 0
   166e8:	0e 94 d2 b6 	call	0x16da4	; 0x16da4 <__mulsi3>
   166ec:	5b 01       	movw	r10, r22
   166ee:	6c 01       	movw	r12, r24
				for(__i = 1; __i < __len; __i++)
					if(__string[__i] < 0x30 || __string[__i] > 0x30)
						return 0;
			}
		}
		for(__i = 0; __i < __len - 1; __i++)
   166f0:	1f 5f       	subi	r17, 0xFF	; 255
   166f2:	09 c0       	rjmp	.+18     	; 0x16706 <Str2Int+0xa6>
   166f4:	10 e0       	ldi	r17, 0x00	; 0
   166f6:	01 e0       	ldi	r16, 0x01	; 1
   166f8:	a0 2e       	mov	r10, r16
   166fa:	b1 2c       	mov	r11, r1
   166fc:	c1 2c       	mov	r12, r1
   166fe:	d1 2c       	mov	r13, r1
   16700:	c7 2d       	mov	r28, r7
   16702:	d0 e0       	ldi	r29, 0x00	; 0
   16704:	21 97       	sbiw	r28, 0x01	; 1
   16706:	81 2f       	mov	r24, r17
   16708:	90 e0       	ldi	r25, 0x00	; 0
   1670a:	8c 17       	cp	r24, r28
   1670c:	9d 07       	cpc	r25, r29
   1670e:	34 f3       	brlt	.-52     	; 0x166dc <Str2Int+0x7c>
   16710:	ee 24       	eor	r14, r14
   16712:	ff 24       	eor	r15, r15
   16714:	87 01       	movw	r16, r14
   16716:	1e c0       	rjmp	.+60     	; 0x16754 <Str2Int+0xf4>
			__multiplier *= 10;
		for(__i = 0; __i < __len; __i++, __multiplier /= 10)
			__retval += ((unsigned long)(__string[__i] - 0x30) * __multiplier);
   16718:	f4 01       	movw	r30, r8
   1671a:	21 91       	ld	r18, Z+
   1671c:	4f 01       	movw	r8, r30
   1671e:	30 e0       	ldi	r19, 0x00	; 0
   16720:	20 53       	subi	r18, 0x30	; 48
   16722:	30 40       	sbci	r19, 0x00	; 0
   16724:	44 27       	eor	r20, r20
   16726:	37 fd       	sbrc	r19, 7
   16728:	40 95       	com	r20
   1672a:	54 2f       	mov	r21, r20
   1672c:	c6 01       	movw	r24, r12
   1672e:	b5 01       	movw	r22, r10
   16730:	0e 94 d2 b6 	call	0x16da4	; 0x16da4 <__mulsi3>
   16734:	e6 0e       	add	r14, r22
   16736:	f7 1e       	adc	r15, r23
   16738:	08 1f       	adc	r16, r24
   1673a:	19 1f       	adc	r17, r25
						return 0;
			}
		}
		for(__i = 0; __i < __len - 1; __i++)
			__multiplier *= 10;
		for(__i = 0; __i < __len; __i++, __multiplier /= 10)
   1673c:	c6 01       	movw	r24, r12
   1673e:	b5 01       	movw	r22, r10
   16740:	2a e0       	ldi	r18, 0x0A	; 10
   16742:	30 e0       	ldi	r19, 0x00	; 0
   16744:	40 e0       	ldi	r20, 0x00	; 0
   16746:	50 e0       	ldi	r21, 0x00	; 0
   16748:	0e 94 31 b7 	call	0x16e62	; 0x16e62 <__udivmodsi4>
   1674c:	c9 01       	movw	r24, r18
   1674e:	da 01       	movw	r26, r20
   16750:	5c 01       	movw	r10, r24
   16752:	6d 01       	movw	r12, r26
   16754:	88 2d       	mov	r24, r8
   16756:	86 19       	sub	r24, r6
   16758:	87 15       	cp	r24, r7
   1675a:	f0 f2       	brcs	.-68     	; 0x16718 <Str2Int+0xb8>
   1675c:	03 c0       	rjmp	.+6      	; 0x16764 <Str2Int+0x104>
   1675e:	ee 24       	eor	r14, r14
   16760:	ff 24       	eor	r15, r15
   16762:	87 01       	movw	r16, r14
			__retval += ((unsigned long)(__string[__i] - 0x30) * __multiplier);
	}
	return __retval;
}
   16764:	b7 01       	movw	r22, r14
   16766:	c8 01       	movw	r24, r16
   16768:	df 91       	pop	r29
   1676a:	cf 91       	pop	r28
   1676c:	1f 91       	pop	r17
   1676e:	0f 91       	pop	r16
   16770:	ff 90       	pop	r15
   16772:	ef 90       	pop	r14
   16774:	df 90       	pop	r13
   16776:	cf 90       	pop	r12
   16778:	bf 90       	pop	r11
   1677a:	af 90       	pop	r10
   1677c:	9f 90       	pop	r9
   1677e:	8f 90       	pop	r8
   16780:	7f 90       	pop	r7
   16782:	6f 90       	pop	r6
   16784:	08 95       	ret

00016786 <atoi>:
   16786:	fc 01       	movw	r30, r24
   16788:	88 27       	eor	r24, r24
   1678a:	99 27       	eor	r25, r25
   1678c:	e8 94       	clt
   1678e:	21 91       	ld	r18, Z+
   16790:	20 32       	cpi	r18, 0x20	; 32
   16792:	e9 f3       	breq	.-6      	; 0x1678e <atoi+0x8>
   16794:	29 30       	cpi	r18, 0x09	; 9
   16796:	10 f0       	brcs	.+4      	; 0x1679c <atoi+0x16>
   16798:	2e 30       	cpi	r18, 0x0E	; 14
   1679a:	c8 f3       	brcs	.-14     	; 0x1678e <atoi+0x8>
   1679c:	2b 32       	cpi	r18, 0x2B	; 43
   1679e:	41 f0       	breq	.+16     	; 0x167b0 <atoi+0x2a>
   167a0:	2d 32       	cpi	r18, 0x2D	; 45
   167a2:	39 f4       	brne	.+14     	; 0x167b2 <atoi+0x2c>
   167a4:	68 94       	set
   167a6:	04 c0       	rjmp	.+8      	; 0x167b0 <atoi+0x2a>
   167a8:	0e 94 29 b4 	call	0x16852	; 0x16852 <__mulhi_const_10>
   167ac:	82 0f       	add	r24, r18
   167ae:	91 1d       	adc	r25, r1
   167b0:	21 91       	ld	r18, Z+
   167b2:	20 53       	subi	r18, 0x30	; 48
   167b4:	2a 30       	cpi	r18, 0x0A	; 10
   167b6:	c0 f3       	brcs	.-16     	; 0x167a8 <atoi+0x22>
   167b8:	1e f4       	brtc	.+6      	; 0x167c0 <atoi+0x3a>
   167ba:	90 95       	com	r25
   167bc:	81 95       	neg	r24
   167be:	9f 4f       	sbci	r25, 0xFF	; 255
   167c0:	08 95       	ret

000167c2 <strcpy_P>:
   167c2:	fb 01       	movw	r30, r22
   167c4:	dc 01       	movw	r26, r24
   167c6:	05 90       	lpm	r0, Z+
   167c8:	0d 92       	st	X+, r0
   167ca:	00 20       	and	r0, r0
   167cc:	e1 f7       	brne	.-8      	; 0x167c6 <strcpy_P+0x4>
   167ce:	08 95       	ret

000167d0 <strcmp>:
   167d0:	fb 01       	movw	r30, r22
   167d2:	dc 01       	movw	r26, r24
   167d4:	8d 91       	ld	r24, X+
   167d6:	01 90       	ld	r0, Z+
   167d8:	80 19       	sub	r24, r0
   167da:	01 10       	cpse	r0, r1
   167dc:	d9 f3       	breq	.-10     	; 0x167d4 <strcmp+0x4>
   167de:	99 0b       	sbc	r25, r25
   167e0:	08 95       	ret

000167e2 <__eerd_block>:
   167e2:	a0 e0       	ldi	r26, 0x00	; 0
   167e4:	b0 e0       	ldi	r27, 0x00	; 0
   167e6:	e7 ef       	ldi	r30, 0xF7	; 247
   167e8:	f3 eb       	ldi	r31, 0xB3	; 179
   167ea:	0c 94 5d b7 	jmp	0x16eba	; 0x16eba <__prologue_saves__+0x14>
   167ee:	7c 01       	movw	r14, r24
   167f0:	eb 01       	movw	r28, r22
   167f2:	8a 01       	movw	r16, r20
   167f4:	69 01       	movw	r12, r18
   167f6:	09 c0       	rjmp	.+18     	; 0x1680a <__eerd_block+0x28>
   167f8:	ce 01       	movw	r24, r28
   167fa:	21 96       	adiw	r28, 0x01	; 1
   167fc:	f6 01       	movw	r30, r12
   167fe:	09 95       	icall
   16800:	f7 01       	movw	r30, r14
   16802:	81 93       	st	Z+, r24
   16804:	7f 01       	movw	r14, r30
   16806:	01 50       	subi	r16, 0x01	; 1
   16808:	10 40       	sbci	r17, 0x00	; 0
   1680a:	01 15       	cp	r16, r1
   1680c:	11 05       	cpc	r17, r1
   1680e:	a1 f7       	brne	.-24     	; 0x167f8 <__eerd_block+0x16>
   16810:	cd b7       	in	r28, 0x3d	; 61
   16812:	de b7       	in	r29, 0x3e	; 62
   16814:	e8 e0       	ldi	r30, 0x08	; 8
   16816:	0c 94 79 b7 	jmp	0x16ef2	; 0x16ef2 <__epilogue_restores__+0x14>

0001681a <__eewr_block>:
   1681a:	a0 e0       	ldi	r26, 0x00	; 0
   1681c:	b0 e0       	ldi	r27, 0x00	; 0
   1681e:	e3 e1       	ldi	r30, 0x13	; 19
   16820:	f4 eb       	ldi	r31, 0xB4	; 180
   16822:	0c 94 5d b7 	jmp	0x16eba	; 0x16eba <__prologue_saves__+0x14>
   16826:	ec 01       	movw	r28, r24
   16828:	7b 01       	movw	r14, r22
   1682a:	8a 01       	movw	r16, r20
   1682c:	69 01       	movw	r12, r18
   1682e:	09 c0       	rjmp	.+18     	; 0x16842 <__eewr_block+0x28>
   16830:	ce 01       	movw	r24, r28
   16832:	21 96       	adiw	r28, 0x01	; 1
   16834:	f7 01       	movw	r30, r14
   16836:	61 91       	ld	r22, Z+
   16838:	7f 01       	movw	r14, r30
   1683a:	f6 01       	movw	r30, r12
   1683c:	09 95       	icall
   1683e:	01 50       	subi	r16, 0x01	; 1
   16840:	10 40       	sbci	r17, 0x00	; 0
   16842:	01 15       	cp	r16, r1
   16844:	11 05       	cpc	r17, r1
   16846:	a1 f7       	brne	.-24     	; 0x16830 <__eewr_block+0x16>
   16848:	cd b7       	in	r28, 0x3d	; 61
   1684a:	de b7       	in	r29, 0x3e	; 62
   1684c:	e8 e0       	ldi	r30, 0x08	; 8
   1684e:	0c 94 79 b7 	jmp	0x16ef2	; 0x16ef2 <__epilogue_restores__+0x14>

00016852 <__mulhi_const_10>:
   16852:	7a e0       	ldi	r23, 0x0A	; 10
   16854:	97 9f       	mul	r25, r23
   16856:	90 2d       	mov	r25, r0
   16858:	87 9f       	mul	r24, r23
   1685a:	80 2d       	mov	r24, r0
   1685c:	91 0d       	add	r25, r1
   1685e:	11 24       	eor	r1, r1
   16860:	08 95       	ret

00016862 <sprintf_P>:
   16862:	ae e0       	ldi	r26, 0x0E	; 14
   16864:	b0 e0       	ldi	r27, 0x00	; 0
   16866:	e7 e3       	ldi	r30, 0x37	; 55
   16868:	f4 eb       	ldi	r31, 0xB4	; 180
   1686a:	0c 94 61 b7 	jmp	0x16ec2	; 0x16ec2 <__prologue_saves__+0x1c>
   1686e:	0d 89       	ldd	r16, Y+21	; 0x15
   16870:	1e 89       	ldd	r17, Y+22	; 0x16
   16872:	8e e0       	ldi	r24, 0x0E	; 14
   16874:	8c 83       	std	Y+4, r24	; 0x04
   16876:	1a 83       	std	Y+2, r17	; 0x02
   16878:	09 83       	std	Y+1, r16	; 0x01
   1687a:	8f ef       	ldi	r24, 0xFF	; 255
   1687c:	9f e7       	ldi	r25, 0x7F	; 127
   1687e:	9e 83       	std	Y+6, r25	; 0x06
   16880:	8d 83       	std	Y+5, r24	; 0x05
   16882:	9e 01       	movw	r18, r28
   16884:	27 5e       	subi	r18, 0xE7	; 231
   16886:	3f 4f       	sbci	r19, 0xFF	; 255
   16888:	ce 01       	movw	r24, r28
   1688a:	01 96       	adiw	r24, 0x01	; 1
   1688c:	6f 89       	ldd	r22, Y+23	; 0x17
   1688e:	78 8d       	ldd	r23, Y+24	; 0x18
   16890:	a9 01       	movw	r20, r18
   16892:	0e 94 55 b4 	call	0x168aa	; 0x168aa <vfprintf>
   16896:	2f 81       	ldd	r18, Y+7	; 0x07
   16898:	38 85       	ldd	r19, Y+8	; 0x08
   1689a:	02 0f       	add	r16, r18
   1689c:	13 1f       	adc	r17, r19
   1689e:	f8 01       	movw	r30, r16
   168a0:	10 82       	st	Z, r1
   168a2:	2e 96       	adiw	r28, 0x0e	; 14
   168a4:	e4 e0       	ldi	r30, 0x04	; 4
   168a6:	0c 94 7d b7 	jmp	0x16efa	; 0x16efa <__epilogue_restores__+0x1c>

000168aa <vfprintf>:
   168aa:	ab e0       	ldi	r26, 0x0B	; 11
   168ac:	b0 e0       	ldi	r27, 0x00	; 0
   168ae:	eb e5       	ldi	r30, 0x5B	; 91
   168b0:	f4 eb       	ldi	r31, 0xB4	; 180
   168b2:	0c 94 53 b7 	jmp	0x16ea6	; 0x16ea6 <__prologue_saves__>
   168b6:	3c 01       	movw	r6, r24
   168b8:	2b 01       	movw	r4, r22
   168ba:	5a 01       	movw	r10, r20
   168bc:	fc 01       	movw	r30, r24
   168be:	17 82       	std	Z+7, r1	; 0x07
   168c0:	16 82       	std	Z+6, r1	; 0x06
   168c2:	83 81       	ldd	r24, Z+3	; 0x03
   168c4:	81 fd       	sbrc	r24, 1
   168c6:	03 c0       	rjmp	.+6      	; 0x168ce <vfprintf+0x24>
   168c8:	6f ef       	ldi	r22, 0xFF	; 255
   168ca:	7f ef       	ldi	r23, 0xFF	; 255
   168cc:	c6 c1       	rjmp	.+908    	; 0x16c5a <vfprintf+0x3b0>
   168ce:	9a e0       	ldi	r25, 0x0A	; 10
   168d0:	89 2e       	mov	r8, r25
   168d2:	1e 01       	movw	r2, r28
   168d4:	08 94       	sec
   168d6:	21 1c       	adc	r2, r1
   168d8:	31 1c       	adc	r3, r1
   168da:	f3 01       	movw	r30, r6
   168dc:	23 81       	ldd	r18, Z+3	; 0x03
   168de:	f2 01       	movw	r30, r4
   168e0:	23 fd       	sbrc	r18, 3
   168e2:	85 91       	lpm	r24, Z+
   168e4:	23 ff       	sbrs	r18, 3
   168e6:	81 91       	ld	r24, Z+
   168e8:	2f 01       	movw	r4, r30
   168ea:	88 23       	and	r24, r24
   168ec:	09 f4       	brne	.+2      	; 0x168f0 <vfprintf+0x46>
   168ee:	b2 c1       	rjmp	.+868    	; 0x16c54 <vfprintf+0x3aa>
   168f0:	85 32       	cpi	r24, 0x25	; 37
   168f2:	39 f4       	brne	.+14     	; 0x16902 <vfprintf+0x58>
   168f4:	23 fd       	sbrc	r18, 3
   168f6:	85 91       	lpm	r24, Z+
   168f8:	23 ff       	sbrs	r18, 3
   168fa:	81 91       	ld	r24, Z+
   168fc:	2f 01       	movw	r4, r30
   168fe:	85 32       	cpi	r24, 0x25	; 37
   16900:	29 f4       	brne	.+10     	; 0x1690c <vfprintf+0x62>
   16902:	90 e0       	ldi	r25, 0x00	; 0
   16904:	b3 01       	movw	r22, r6
   16906:	0e 94 48 b6 	call	0x16c90	; 0x16c90 <fputc>
   1690a:	e7 cf       	rjmp	.-50     	; 0x168da <vfprintf+0x30>
   1690c:	98 2f       	mov	r25, r24
   1690e:	ff 24       	eor	r15, r15
   16910:	ee 24       	eor	r14, r14
   16912:	99 24       	eor	r9, r9
   16914:	ff e1       	ldi	r31, 0x1F	; 31
   16916:	ff 15       	cp	r31, r15
   16918:	d0 f0       	brcs	.+52     	; 0x1694e <vfprintf+0xa4>
   1691a:	9b 32       	cpi	r25, 0x2B	; 43
   1691c:	69 f0       	breq	.+26     	; 0x16938 <vfprintf+0x8e>
   1691e:	9c 32       	cpi	r25, 0x2C	; 44
   16920:	28 f4       	brcc	.+10     	; 0x1692c <vfprintf+0x82>
   16922:	90 32       	cpi	r25, 0x20	; 32
   16924:	59 f0       	breq	.+22     	; 0x1693c <vfprintf+0x92>
   16926:	93 32       	cpi	r25, 0x23	; 35
   16928:	91 f4       	brne	.+36     	; 0x1694e <vfprintf+0xa4>
   1692a:	0e c0       	rjmp	.+28     	; 0x16948 <vfprintf+0x9e>
   1692c:	9d 32       	cpi	r25, 0x2D	; 45
   1692e:	49 f0       	breq	.+18     	; 0x16942 <vfprintf+0x98>
   16930:	90 33       	cpi	r25, 0x30	; 48
   16932:	69 f4       	brne	.+26     	; 0x1694e <vfprintf+0xa4>
   16934:	41 e0       	ldi	r20, 0x01	; 1
   16936:	24 c0       	rjmp	.+72     	; 0x16980 <vfprintf+0xd6>
   16938:	52 e0       	ldi	r21, 0x02	; 2
   1693a:	f5 2a       	or	r15, r21
   1693c:	84 e0       	ldi	r24, 0x04	; 4
   1693e:	f8 2a       	or	r15, r24
   16940:	28 c0       	rjmp	.+80     	; 0x16992 <vfprintf+0xe8>
   16942:	98 e0       	ldi	r25, 0x08	; 8
   16944:	f9 2a       	or	r15, r25
   16946:	25 c0       	rjmp	.+74     	; 0x16992 <vfprintf+0xe8>
   16948:	e0 e1       	ldi	r30, 0x10	; 16
   1694a:	fe 2a       	or	r15, r30
   1694c:	22 c0       	rjmp	.+68     	; 0x16992 <vfprintf+0xe8>
   1694e:	f7 fc       	sbrc	r15, 7
   16950:	29 c0       	rjmp	.+82     	; 0x169a4 <vfprintf+0xfa>
   16952:	89 2f       	mov	r24, r25
   16954:	80 53       	subi	r24, 0x30	; 48
   16956:	8a 30       	cpi	r24, 0x0A	; 10
   16958:	70 f4       	brcc	.+28     	; 0x16976 <vfprintf+0xcc>
   1695a:	f6 fe       	sbrs	r15, 6
   1695c:	05 c0       	rjmp	.+10     	; 0x16968 <vfprintf+0xbe>
   1695e:	98 9c       	mul	r9, r8
   16960:	90 2c       	mov	r9, r0
   16962:	11 24       	eor	r1, r1
   16964:	98 0e       	add	r9, r24
   16966:	15 c0       	rjmp	.+42     	; 0x16992 <vfprintf+0xe8>
   16968:	e8 9c       	mul	r14, r8
   1696a:	e0 2c       	mov	r14, r0
   1696c:	11 24       	eor	r1, r1
   1696e:	e8 0e       	add	r14, r24
   16970:	f0 e2       	ldi	r31, 0x20	; 32
   16972:	ff 2a       	or	r15, r31
   16974:	0e c0       	rjmp	.+28     	; 0x16992 <vfprintf+0xe8>
   16976:	9e 32       	cpi	r25, 0x2E	; 46
   16978:	29 f4       	brne	.+10     	; 0x16984 <vfprintf+0xda>
   1697a:	f6 fc       	sbrc	r15, 6
   1697c:	6b c1       	rjmp	.+726    	; 0x16c54 <vfprintf+0x3aa>
   1697e:	40 e4       	ldi	r20, 0x40	; 64
   16980:	f4 2a       	or	r15, r20
   16982:	07 c0       	rjmp	.+14     	; 0x16992 <vfprintf+0xe8>
   16984:	9c 36       	cpi	r25, 0x6C	; 108
   16986:	19 f4       	brne	.+6      	; 0x1698e <vfprintf+0xe4>
   16988:	50 e8       	ldi	r21, 0x80	; 128
   1698a:	f5 2a       	or	r15, r21
   1698c:	02 c0       	rjmp	.+4      	; 0x16992 <vfprintf+0xe8>
   1698e:	98 36       	cpi	r25, 0x68	; 104
   16990:	49 f4       	brne	.+18     	; 0x169a4 <vfprintf+0xfa>
   16992:	f2 01       	movw	r30, r4
   16994:	23 fd       	sbrc	r18, 3
   16996:	95 91       	lpm	r25, Z+
   16998:	23 ff       	sbrs	r18, 3
   1699a:	91 91       	ld	r25, Z+
   1699c:	2f 01       	movw	r4, r30
   1699e:	99 23       	and	r25, r25
   169a0:	09 f0       	breq	.+2      	; 0x169a4 <vfprintf+0xfa>
   169a2:	b8 cf       	rjmp	.-144    	; 0x16914 <vfprintf+0x6a>
   169a4:	89 2f       	mov	r24, r25
   169a6:	85 54       	subi	r24, 0x45	; 69
   169a8:	83 30       	cpi	r24, 0x03	; 3
   169aa:	18 f0       	brcs	.+6      	; 0x169b2 <vfprintf+0x108>
   169ac:	80 52       	subi	r24, 0x20	; 32
   169ae:	83 30       	cpi	r24, 0x03	; 3
   169b0:	38 f4       	brcc	.+14     	; 0x169c0 <vfprintf+0x116>
   169b2:	44 e0       	ldi	r20, 0x04	; 4
   169b4:	50 e0       	ldi	r21, 0x00	; 0
   169b6:	a4 0e       	add	r10, r20
   169b8:	b5 1e       	adc	r11, r21
   169ba:	5f e3       	ldi	r21, 0x3F	; 63
   169bc:	59 83       	std	Y+1, r21	; 0x01
   169be:	0f c0       	rjmp	.+30     	; 0x169de <vfprintf+0x134>
   169c0:	93 36       	cpi	r25, 0x63	; 99
   169c2:	31 f0       	breq	.+12     	; 0x169d0 <vfprintf+0x126>
   169c4:	93 37       	cpi	r25, 0x73	; 115
   169c6:	79 f0       	breq	.+30     	; 0x169e6 <vfprintf+0x13c>
   169c8:	93 35       	cpi	r25, 0x53	; 83
   169ca:	09 f0       	breq	.+2      	; 0x169ce <vfprintf+0x124>
   169cc:	56 c0       	rjmp	.+172    	; 0x16a7a <vfprintf+0x1d0>
   169ce:	20 c0       	rjmp	.+64     	; 0x16a10 <vfprintf+0x166>
   169d0:	f5 01       	movw	r30, r10
   169d2:	80 81       	ld	r24, Z
   169d4:	89 83       	std	Y+1, r24	; 0x01
   169d6:	42 e0       	ldi	r20, 0x02	; 2
   169d8:	50 e0       	ldi	r21, 0x00	; 0
   169da:	a4 0e       	add	r10, r20
   169dc:	b5 1e       	adc	r11, r21
   169de:	61 01       	movw	r12, r2
   169e0:	01 e0       	ldi	r16, 0x01	; 1
   169e2:	10 e0       	ldi	r17, 0x00	; 0
   169e4:	12 c0       	rjmp	.+36     	; 0x16a0a <vfprintf+0x160>
   169e6:	f5 01       	movw	r30, r10
   169e8:	c0 80       	ld	r12, Z
   169ea:	d1 80       	ldd	r13, Z+1	; 0x01
   169ec:	f6 fc       	sbrc	r15, 6
   169ee:	03 c0       	rjmp	.+6      	; 0x169f6 <vfprintf+0x14c>
   169f0:	6f ef       	ldi	r22, 0xFF	; 255
   169f2:	7f ef       	ldi	r23, 0xFF	; 255
   169f4:	02 c0       	rjmp	.+4      	; 0x169fa <vfprintf+0x150>
   169f6:	69 2d       	mov	r22, r9
   169f8:	70 e0       	ldi	r23, 0x00	; 0
   169fa:	42 e0       	ldi	r20, 0x02	; 2
   169fc:	50 e0       	ldi	r21, 0x00	; 0
   169fe:	a4 0e       	add	r10, r20
   16a00:	b5 1e       	adc	r11, r21
   16a02:	c6 01       	movw	r24, r12
   16a04:	0e 94 3d b6 	call	0x16c7a	; 0x16c7a <strnlen>
   16a08:	8c 01       	movw	r16, r24
   16a0a:	5f e7       	ldi	r21, 0x7F	; 127
   16a0c:	f5 22       	and	r15, r21
   16a0e:	14 c0       	rjmp	.+40     	; 0x16a38 <vfprintf+0x18e>
   16a10:	f5 01       	movw	r30, r10
   16a12:	c0 80       	ld	r12, Z
   16a14:	d1 80       	ldd	r13, Z+1	; 0x01
   16a16:	f6 fc       	sbrc	r15, 6
   16a18:	03 c0       	rjmp	.+6      	; 0x16a20 <vfprintf+0x176>
   16a1a:	6f ef       	ldi	r22, 0xFF	; 255
   16a1c:	7f ef       	ldi	r23, 0xFF	; 255
   16a1e:	02 c0       	rjmp	.+4      	; 0x16a24 <vfprintf+0x17a>
   16a20:	69 2d       	mov	r22, r9
   16a22:	70 e0       	ldi	r23, 0x00	; 0
   16a24:	42 e0       	ldi	r20, 0x02	; 2
   16a26:	50 e0       	ldi	r21, 0x00	; 0
   16a28:	a4 0e       	add	r10, r20
   16a2a:	b5 1e       	adc	r11, r21
   16a2c:	c6 01       	movw	r24, r12
   16a2e:	0e 94 32 b6 	call	0x16c64	; 0x16c64 <strnlen_P>
   16a32:	8c 01       	movw	r16, r24
   16a34:	50 e8       	ldi	r21, 0x80	; 128
   16a36:	f5 2a       	or	r15, r21
   16a38:	f3 fe       	sbrs	r15, 3
   16a3a:	07 c0       	rjmp	.+14     	; 0x16a4a <vfprintf+0x1a0>
   16a3c:	1a c0       	rjmp	.+52     	; 0x16a72 <vfprintf+0x1c8>
   16a3e:	80 e2       	ldi	r24, 0x20	; 32
   16a40:	90 e0       	ldi	r25, 0x00	; 0
   16a42:	b3 01       	movw	r22, r6
   16a44:	0e 94 48 b6 	call	0x16c90	; 0x16c90 <fputc>
   16a48:	ea 94       	dec	r14
   16a4a:	8e 2d       	mov	r24, r14
   16a4c:	90 e0       	ldi	r25, 0x00	; 0
   16a4e:	08 17       	cp	r16, r24
   16a50:	19 07       	cpc	r17, r25
   16a52:	a8 f3       	brcs	.-22     	; 0x16a3e <vfprintf+0x194>
   16a54:	0e c0       	rjmp	.+28     	; 0x16a72 <vfprintf+0x1c8>
   16a56:	f6 01       	movw	r30, r12
   16a58:	f7 fc       	sbrc	r15, 7
   16a5a:	85 91       	lpm	r24, Z+
   16a5c:	f7 fe       	sbrs	r15, 7
   16a5e:	81 91       	ld	r24, Z+
   16a60:	6f 01       	movw	r12, r30
   16a62:	90 e0       	ldi	r25, 0x00	; 0
   16a64:	b3 01       	movw	r22, r6
   16a66:	0e 94 48 b6 	call	0x16c90	; 0x16c90 <fputc>
   16a6a:	e1 10       	cpse	r14, r1
   16a6c:	ea 94       	dec	r14
   16a6e:	01 50       	subi	r16, 0x01	; 1
   16a70:	10 40       	sbci	r17, 0x00	; 0
   16a72:	01 15       	cp	r16, r1
   16a74:	11 05       	cpc	r17, r1
   16a76:	79 f7       	brne	.-34     	; 0x16a56 <vfprintf+0x1ac>
   16a78:	ea c0       	rjmp	.+468    	; 0x16c4e <vfprintf+0x3a4>
   16a7a:	94 36       	cpi	r25, 0x64	; 100
   16a7c:	11 f0       	breq	.+4      	; 0x16a82 <vfprintf+0x1d8>
   16a7e:	99 36       	cpi	r25, 0x69	; 105
   16a80:	69 f5       	brne	.+90     	; 0x16adc <vfprintf+0x232>
   16a82:	f7 fe       	sbrs	r15, 7
   16a84:	08 c0       	rjmp	.+16     	; 0x16a96 <vfprintf+0x1ec>
   16a86:	f5 01       	movw	r30, r10
   16a88:	20 81       	ld	r18, Z
   16a8a:	31 81       	ldd	r19, Z+1	; 0x01
   16a8c:	42 81       	ldd	r20, Z+2	; 0x02
   16a8e:	53 81       	ldd	r21, Z+3	; 0x03
   16a90:	84 e0       	ldi	r24, 0x04	; 4
   16a92:	90 e0       	ldi	r25, 0x00	; 0
   16a94:	0a c0       	rjmp	.+20     	; 0x16aaa <vfprintf+0x200>
   16a96:	f5 01       	movw	r30, r10
   16a98:	80 81       	ld	r24, Z
   16a9a:	91 81       	ldd	r25, Z+1	; 0x01
   16a9c:	9c 01       	movw	r18, r24
   16a9e:	44 27       	eor	r20, r20
   16aa0:	37 fd       	sbrc	r19, 7
   16aa2:	40 95       	com	r20
   16aa4:	54 2f       	mov	r21, r20
   16aa6:	82 e0       	ldi	r24, 0x02	; 2
   16aa8:	90 e0       	ldi	r25, 0x00	; 0
   16aaa:	a8 0e       	add	r10, r24
   16aac:	b9 1e       	adc	r11, r25
   16aae:	9f e6       	ldi	r25, 0x6F	; 111
   16ab0:	f9 22       	and	r15, r25
   16ab2:	57 ff       	sbrs	r21, 7
   16ab4:	09 c0       	rjmp	.+18     	; 0x16ac8 <vfprintf+0x21e>
   16ab6:	50 95       	com	r21
   16ab8:	40 95       	com	r20
   16aba:	30 95       	com	r19
   16abc:	21 95       	neg	r18
   16abe:	3f 4f       	sbci	r19, 0xFF	; 255
   16ac0:	4f 4f       	sbci	r20, 0xFF	; 255
   16ac2:	5f 4f       	sbci	r21, 0xFF	; 255
   16ac4:	e0 e8       	ldi	r30, 0x80	; 128
   16ac6:	fe 2a       	or	r15, r30
   16ac8:	ca 01       	movw	r24, r20
   16aca:	b9 01       	movw	r22, r18
   16acc:	a1 01       	movw	r20, r2
   16ace:	2a e0       	ldi	r18, 0x0A	; 10
   16ad0:	30 e0       	ldi	r19, 0x00	; 0
   16ad2:	0e 94 74 b6 	call	0x16ce8	; 0x16ce8 <__ultoa_invert>
   16ad6:	d8 2e       	mov	r13, r24
   16ad8:	d2 18       	sub	r13, r2
   16ada:	40 c0       	rjmp	.+128    	; 0x16b5c <vfprintf+0x2b2>
   16adc:	95 37       	cpi	r25, 0x75	; 117
   16ade:	29 f4       	brne	.+10     	; 0x16aea <vfprintf+0x240>
   16ae0:	1f 2d       	mov	r17, r15
   16ae2:	1f 7e       	andi	r17, 0xEF	; 239
   16ae4:	2a e0       	ldi	r18, 0x0A	; 10
   16ae6:	30 e0       	ldi	r19, 0x00	; 0
   16ae8:	1d c0       	rjmp	.+58     	; 0x16b24 <vfprintf+0x27a>
   16aea:	1f 2d       	mov	r17, r15
   16aec:	19 7f       	andi	r17, 0xF9	; 249
   16aee:	9f 36       	cpi	r25, 0x6F	; 111
   16af0:	61 f0       	breq	.+24     	; 0x16b0a <vfprintf+0x260>
   16af2:	90 37       	cpi	r25, 0x70	; 112
   16af4:	20 f4       	brcc	.+8      	; 0x16afe <vfprintf+0x254>
   16af6:	98 35       	cpi	r25, 0x58	; 88
   16af8:	09 f0       	breq	.+2      	; 0x16afc <vfprintf+0x252>
   16afa:	ac c0       	rjmp	.+344    	; 0x16c54 <vfprintf+0x3aa>
   16afc:	0f c0       	rjmp	.+30     	; 0x16b1c <vfprintf+0x272>
   16afe:	90 37       	cpi	r25, 0x70	; 112
   16b00:	39 f0       	breq	.+14     	; 0x16b10 <vfprintf+0x266>
   16b02:	98 37       	cpi	r25, 0x78	; 120
   16b04:	09 f0       	breq	.+2      	; 0x16b08 <vfprintf+0x25e>
   16b06:	a6 c0       	rjmp	.+332    	; 0x16c54 <vfprintf+0x3aa>
   16b08:	04 c0       	rjmp	.+8      	; 0x16b12 <vfprintf+0x268>
   16b0a:	28 e0       	ldi	r18, 0x08	; 8
   16b0c:	30 e0       	ldi	r19, 0x00	; 0
   16b0e:	0a c0       	rjmp	.+20     	; 0x16b24 <vfprintf+0x27a>
   16b10:	10 61       	ori	r17, 0x10	; 16
   16b12:	14 fd       	sbrc	r17, 4
   16b14:	14 60       	ori	r17, 0x04	; 4
   16b16:	20 e1       	ldi	r18, 0x10	; 16
   16b18:	30 e0       	ldi	r19, 0x00	; 0
   16b1a:	04 c0       	rjmp	.+8      	; 0x16b24 <vfprintf+0x27a>
   16b1c:	14 fd       	sbrc	r17, 4
   16b1e:	16 60       	ori	r17, 0x06	; 6
   16b20:	20 e1       	ldi	r18, 0x10	; 16
   16b22:	32 e0       	ldi	r19, 0x02	; 2
   16b24:	17 ff       	sbrs	r17, 7
   16b26:	08 c0       	rjmp	.+16     	; 0x16b38 <vfprintf+0x28e>
   16b28:	f5 01       	movw	r30, r10
   16b2a:	60 81       	ld	r22, Z
   16b2c:	71 81       	ldd	r23, Z+1	; 0x01
   16b2e:	82 81       	ldd	r24, Z+2	; 0x02
   16b30:	93 81       	ldd	r25, Z+3	; 0x03
   16b32:	44 e0       	ldi	r20, 0x04	; 4
   16b34:	50 e0       	ldi	r21, 0x00	; 0
   16b36:	08 c0       	rjmp	.+16     	; 0x16b48 <vfprintf+0x29e>
   16b38:	f5 01       	movw	r30, r10
   16b3a:	80 81       	ld	r24, Z
   16b3c:	91 81       	ldd	r25, Z+1	; 0x01
   16b3e:	bc 01       	movw	r22, r24
   16b40:	80 e0       	ldi	r24, 0x00	; 0
   16b42:	90 e0       	ldi	r25, 0x00	; 0
   16b44:	42 e0       	ldi	r20, 0x02	; 2
   16b46:	50 e0       	ldi	r21, 0x00	; 0
   16b48:	a4 0e       	add	r10, r20
   16b4a:	b5 1e       	adc	r11, r21
   16b4c:	a1 01       	movw	r20, r2
   16b4e:	0e 94 74 b6 	call	0x16ce8	; 0x16ce8 <__ultoa_invert>
   16b52:	d8 2e       	mov	r13, r24
   16b54:	d2 18       	sub	r13, r2
   16b56:	8f e7       	ldi	r24, 0x7F	; 127
   16b58:	f8 2e       	mov	r15, r24
   16b5a:	f1 22       	and	r15, r17
   16b5c:	f6 fe       	sbrs	r15, 6
   16b5e:	0b c0       	rjmp	.+22     	; 0x16b76 <vfprintf+0x2cc>
   16b60:	5e ef       	ldi	r21, 0xFE	; 254
   16b62:	f5 22       	and	r15, r21
   16b64:	d9 14       	cp	r13, r9
   16b66:	38 f4       	brcc	.+14     	; 0x16b76 <vfprintf+0x2cc>
   16b68:	f4 fe       	sbrs	r15, 4
   16b6a:	07 c0       	rjmp	.+14     	; 0x16b7a <vfprintf+0x2d0>
   16b6c:	f2 fc       	sbrc	r15, 2
   16b6e:	05 c0       	rjmp	.+10     	; 0x16b7a <vfprintf+0x2d0>
   16b70:	8f ee       	ldi	r24, 0xEF	; 239
   16b72:	f8 22       	and	r15, r24
   16b74:	02 c0       	rjmp	.+4      	; 0x16b7a <vfprintf+0x2d0>
   16b76:	1d 2d       	mov	r17, r13
   16b78:	01 c0       	rjmp	.+2      	; 0x16b7c <vfprintf+0x2d2>
   16b7a:	19 2d       	mov	r17, r9
   16b7c:	f4 fe       	sbrs	r15, 4
   16b7e:	0d c0       	rjmp	.+26     	; 0x16b9a <vfprintf+0x2f0>
   16b80:	fe 01       	movw	r30, r28
   16b82:	ed 0d       	add	r30, r13
   16b84:	f1 1d       	adc	r31, r1
   16b86:	80 81       	ld	r24, Z
   16b88:	80 33       	cpi	r24, 0x30	; 48
   16b8a:	19 f4       	brne	.+6      	; 0x16b92 <vfprintf+0x2e8>
   16b8c:	99 ee       	ldi	r25, 0xE9	; 233
   16b8e:	f9 22       	and	r15, r25
   16b90:	08 c0       	rjmp	.+16     	; 0x16ba2 <vfprintf+0x2f8>
   16b92:	1f 5f       	subi	r17, 0xFF	; 255
   16b94:	f2 fe       	sbrs	r15, 2
   16b96:	05 c0       	rjmp	.+10     	; 0x16ba2 <vfprintf+0x2f8>
   16b98:	03 c0       	rjmp	.+6      	; 0x16ba0 <vfprintf+0x2f6>
   16b9a:	8f 2d       	mov	r24, r15
   16b9c:	86 78       	andi	r24, 0x86	; 134
   16b9e:	09 f0       	breq	.+2      	; 0x16ba2 <vfprintf+0x2f8>
   16ba0:	1f 5f       	subi	r17, 0xFF	; 255
   16ba2:	0f 2d       	mov	r16, r15
   16ba4:	f3 fc       	sbrc	r15, 3
   16ba6:	14 c0       	rjmp	.+40     	; 0x16bd0 <vfprintf+0x326>
   16ba8:	f0 fe       	sbrs	r15, 0
   16baa:	0f c0       	rjmp	.+30     	; 0x16bca <vfprintf+0x320>
   16bac:	1e 15       	cp	r17, r14
   16bae:	10 f0       	brcs	.+4      	; 0x16bb4 <vfprintf+0x30a>
   16bb0:	9d 2c       	mov	r9, r13
   16bb2:	0b c0       	rjmp	.+22     	; 0x16bca <vfprintf+0x320>
   16bb4:	9d 2c       	mov	r9, r13
   16bb6:	9e 0c       	add	r9, r14
   16bb8:	91 1a       	sub	r9, r17
   16bba:	1e 2d       	mov	r17, r14
   16bbc:	06 c0       	rjmp	.+12     	; 0x16bca <vfprintf+0x320>
   16bbe:	80 e2       	ldi	r24, 0x20	; 32
   16bc0:	90 e0       	ldi	r25, 0x00	; 0
   16bc2:	b3 01       	movw	r22, r6
   16bc4:	0e 94 48 b6 	call	0x16c90	; 0x16c90 <fputc>
   16bc8:	1f 5f       	subi	r17, 0xFF	; 255
   16bca:	1e 15       	cp	r17, r14
   16bcc:	c0 f3       	brcs	.-16     	; 0x16bbe <vfprintf+0x314>
   16bce:	04 c0       	rjmp	.+8      	; 0x16bd8 <vfprintf+0x32e>
   16bd0:	1e 15       	cp	r17, r14
   16bd2:	10 f4       	brcc	.+4      	; 0x16bd8 <vfprintf+0x32e>
   16bd4:	e1 1a       	sub	r14, r17
   16bd6:	01 c0       	rjmp	.+2      	; 0x16bda <vfprintf+0x330>
   16bd8:	ee 24       	eor	r14, r14
   16bda:	04 ff       	sbrs	r16, 4
   16bdc:	0f c0       	rjmp	.+30     	; 0x16bfc <vfprintf+0x352>
   16bde:	80 e3       	ldi	r24, 0x30	; 48
   16be0:	90 e0       	ldi	r25, 0x00	; 0
   16be2:	b3 01       	movw	r22, r6
   16be4:	0e 94 48 b6 	call	0x16c90	; 0x16c90 <fputc>
   16be8:	02 ff       	sbrs	r16, 2
   16bea:	1d c0       	rjmp	.+58     	; 0x16c26 <vfprintf+0x37c>
   16bec:	01 fd       	sbrc	r16, 1
   16bee:	03 c0       	rjmp	.+6      	; 0x16bf6 <vfprintf+0x34c>
   16bf0:	88 e7       	ldi	r24, 0x78	; 120
   16bf2:	90 e0       	ldi	r25, 0x00	; 0
   16bf4:	0e c0       	rjmp	.+28     	; 0x16c12 <vfprintf+0x368>
   16bf6:	88 e5       	ldi	r24, 0x58	; 88
   16bf8:	90 e0       	ldi	r25, 0x00	; 0
   16bfa:	0b c0       	rjmp	.+22     	; 0x16c12 <vfprintf+0x368>
   16bfc:	80 2f       	mov	r24, r16
   16bfe:	86 78       	andi	r24, 0x86	; 134
   16c00:	91 f0       	breq	.+36     	; 0x16c26 <vfprintf+0x37c>
   16c02:	01 ff       	sbrs	r16, 1
   16c04:	02 c0       	rjmp	.+4      	; 0x16c0a <vfprintf+0x360>
   16c06:	8b e2       	ldi	r24, 0x2B	; 43
   16c08:	01 c0       	rjmp	.+2      	; 0x16c0c <vfprintf+0x362>
   16c0a:	80 e2       	ldi	r24, 0x20	; 32
   16c0c:	f7 fc       	sbrc	r15, 7
   16c0e:	8d e2       	ldi	r24, 0x2D	; 45
   16c10:	90 e0       	ldi	r25, 0x00	; 0
   16c12:	b3 01       	movw	r22, r6
   16c14:	0e 94 48 b6 	call	0x16c90	; 0x16c90 <fputc>
   16c18:	06 c0       	rjmp	.+12     	; 0x16c26 <vfprintf+0x37c>
   16c1a:	80 e3       	ldi	r24, 0x30	; 48
   16c1c:	90 e0       	ldi	r25, 0x00	; 0
   16c1e:	b3 01       	movw	r22, r6
   16c20:	0e 94 48 b6 	call	0x16c90	; 0x16c90 <fputc>
   16c24:	9a 94       	dec	r9
   16c26:	d9 14       	cp	r13, r9
   16c28:	c0 f3       	brcs	.-16     	; 0x16c1a <vfprintf+0x370>
   16c2a:	da 94       	dec	r13
   16c2c:	f1 01       	movw	r30, r2
   16c2e:	ed 0d       	add	r30, r13
   16c30:	f1 1d       	adc	r31, r1
   16c32:	80 81       	ld	r24, Z
   16c34:	90 e0       	ldi	r25, 0x00	; 0
   16c36:	b3 01       	movw	r22, r6
   16c38:	0e 94 48 b6 	call	0x16c90	; 0x16c90 <fputc>
   16c3c:	dd 20       	and	r13, r13
   16c3e:	a9 f7       	brne	.-22     	; 0x16c2a <vfprintf+0x380>
   16c40:	06 c0       	rjmp	.+12     	; 0x16c4e <vfprintf+0x3a4>
   16c42:	80 e2       	ldi	r24, 0x20	; 32
   16c44:	90 e0       	ldi	r25, 0x00	; 0
   16c46:	b3 01       	movw	r22, r6
   16c48:	0e 94 48 b6 	call	0x16c90	; 0x16c90 <fputc>
   16c4c:	ea 94       	dec	r14
   16c4e:	ee 20       	and	r14, r14
   16c50:	c1 f7       	brne	.-16     	; 0x16c42 <vfprintf+0x398>
   16c52:	43 ce       	rjmp	.-890    	; 0x168da <vfprintf+0x30>
   16c54:	f3 01       	movw	r30, r6
   16c56:	66 81       	ldd	r22, Z+6	; 0x06
   16c58:	77 81       	ldd	r23, Z+7	; 0x07
   16c5a:	cb 01       	movw	r24, r22
   16c5c:	2b 96       	adiw	r28, 0x0b	; 11
   16c5e:	e2 e1       	ldi	r30, 0x12	; 18
   16c60:	0c 94 6f b7 	jmp	0x16ede	; 0x16ede <__epilogue_restores__>

00016c64 <strnlen_P>:
   16c64:	fc 01       	movw	r30, r24
   16c66:	05 90       	lpm	r0, Z+
   16c68:	61 50       	subi	r22, 0x01	; 1
   16c6a:	70 40       	sbci	r23, 0x00	; 0
   16c6c:	01 10       	cpse	r0, r1
   16c6e:	d8 f7       	brcc	.-10     	; 0x16c66 <strnlen_P+0x2>
   16c70:	80 95       	com	r24
   16c72:	90 95       	com	r25
   16c74:	8e 0f       	add	r24, r30
   16c76:	9f 1f       	adc	r25, r31
   16c78:	08 95       	ret

00016c7a <strnlen>:
   16c7a:	fc 01       	movw	r30, r24
   16c7c:	61 50       	subi	r22, 0x01	; 1
   16c7e:	70 40       	sbci	r23, 0x00	; 0
   16c80:	01 90       	ld	r0, Z+
   16c82:	01 10       	cpse	r0, r1
   16c84:	d8 f7       	brcc	.-10     	; 0x16c7c <strnlen+0x2>
   16c86:	80 95       	com	r24
   16c88:	90 95       	com	r25
   16c8a:	8e 0f       	add	r24, r30
   16c8c:	9f 1f       	adc	r25, r31
   16c8e:	08 95       	ret

00016c90 <fputc>:
   16c90:	0f 93       	push	r16
   16c92:	1f 93       	push	r17
   16c94:	cf 93       	push	r28
   16c96:	df 93       	push	r29
   16c98:	8c 01       	movw	r16, r24
   16c9a:	eb 01       	movw	r28, r22
   16c9c:	8b 81       	ldd	r24, Y+3	; 0x03
   16c9e:	81 ff       	sbrs	r24, 1
   16ca0:	1b c0       	rjmp	.+54     	; 0x16cd8 <fputc+0x48>
   16ca2:	82 ff       	sbrs	r24, 2
   16ca4:	0d c0       	rjmp	.+26     	; 0x16cc0 <fputc+0x30>
   16ca6:	2e 81       	ldd	r18, Y+6	; 0x06
   16ca8:	3f 81       	ldd	r19, Y+7	; 0x07
   16caa:	8c 81       	ldd	r24, Y+4	; 0x04
   16cac:	9d 81       	ldd	r25, Y+5	; 0x05
   16cae:	28 17       	cp	r18, r24
   16cb0:	39 07       	cpc	r19, r25
   16cb2:	64 f4       	brge	.+24     	; 0x16ccc <fputc+0x3c>
   16cb4:	e8 81       	ld	r30, Y
   16cb6:	f9 81       	ldd	r31, Y+1	; 0x01
   16cb8:	01 93       	st	Z+, r16
   16cba:	f9 83       	std	Y+1, r31	; 0x01
   16cbc:	e8 83       	st	Y, r30
   16cbe:	06 c0       	rjmp	.+12     	; 0x16ccc <fputc+0x3c>
   16cc0:	e8 85       	ldd	r30, Y+8	; 0x08
   16cc2:	f9 85       	ldd	r31, Y+9	; 0x09
   16cc4:	80 2f       	mov	r24, r16
   16cc6:	09 95       	icall
   16cc8:	89 2b       	or	r24, r25
   16cca:	31 f4       	brne	.+12     	; 0x16cd8 <fputc+0x48>
   16ccc:	8e 81       	ldd	r24, Y+6	; 0x06
   16cce:	9f 81       	ldd	r25, Y+7	; 0x07
   16cd0:	01 96       	adiw	r24, 0x01	; 1
   16cd2:	9f 83       	std	Y+7, r25	; 0x07
   16cd4:	8e 83       	std	Y+6, r24	; 0x06
   16cd6:	02 c0       	rjmp	.+4      	; 0x16cdc <fputc+0x4c>
   16cd8:	0f ef       	ldi	r16, 0xFF	; 255
   16cda:	1f ef       	ldi	r17, 0xFF	; 255
   16cdc:	c8 01       	movw	r24, r16
   16cde:	df 91       	pop	r29
   16ce0:	cf 91       	pop	r28
   16ce2:	1f 91       	pop	r17
   16ce4:	0f 91       	pop	r16
   16ce6:	08 95       	ret

00016ce8 <__ultoa_invert>:
   16ce8:	fa 01       	movw	r30, r20
   16cea:	aa 27       	eor	r26, r26
   16cec:	28 30       	cpi	r18, 0x08	; 8
   16cee:	51 f1       	breq	.+84     	; 0x16d44 <__ultoa_invert+0x5c>
   16cf0:	20 31       	cpi	r18, 0x10	; 16
   16cf2:	81 f1       	breq	.+96     	; 0x16d54 <__ultoa_invert+0x6c>
   16cf4:	e8 94       	clt
   16cf6:	6f 93       	push	r22
   16cf8:	6e 7f       	andi	r22, 0xFE	; 254
   16cfa:	6e 5f       	subi	r22, 0xFE	; 254
   16cfc:	7f 4f       	sbci	r23, 0xFF	; 255
   16cfe:	8f 4f       	sbci	r24, 0xFF	; 255
   16d00:	9f 4f       	sbci	r25, 0xFF	; 255
   16d02:	af 4f       	sbci	r26, 0xFF	; 255
   16d04:	b1 e0       	ldi	r27, 0x01	; 1
   16d06:	3e d0       	rcall	.+124    	; 0x16d84 <__ultoa_invert+0x9c>
   16d08:	b4 e0       	ldi	r27, 0x04	; 4
   16d0a:	3c d0       	rcall	.+120    	; 0x16d84 <__ultoa_invert+0x9c>
   16d0c:	67 0f       	add	r22, r23
   16d0e:	78 1f       	adc	r23, r24
   16d10:	89 1f       	adc	r24, r25
   16d12:	9a 1f       	adc	r25, r26
   16d14:	a1 1d       	adc	r26, r1
   16d16:	68 0f       	add	r22, r24
   16d18:	79 1f       	adc	r23, r25
   16d1a:	8a 1f       	adc	r24, r26
   16d1c:	91 1d       	adc	r25, r1
   16d1e:	a1 1d       	adc	r26, r1
   16d20:	6a 0f       	add	r22, r26
   16d22:	71 1d       	adc	r23, r1
   16d24:	81 1d       	adc	r24, r1
   16d26:	91 1d       	adc	r25, r1
   16d28:	a1 1d       	adc	r26, r1
   16d2a:	20 d0       	rcall	.+64     	; 0x16d6c <__ultoa_invert+0x84>
   16d2c:	09 f4       	brne	.+2      	; 0x16d30 <__ultoa_invert+0x48>
   16d2e:	68 94       	set
   16d30:	3f 91       	pop	r19
   16d32:	2a e0       	ldi	r18, 0x0A	; 10
   16d34:	26 9f       	mul	r18, r22
   16d36:	11 24       	eor	r1, r1
   16d38:	30 19       	sub	r19, r0
   16d3a:	30 5d       	subi	r19, 0xD0	; 208
   16d3c:	31 93       	st	Z+, r19
   16d3e:	de f6       	brtc	.-74     	; 0x16cf6 <__ultoa_invert+0xe>
   16d40:	cf 01       	movw	r24, r30
   16d42:	08 95       	ret
   16d44:	46 2f       	mov	r20, r22
   16d46:	47 70       	andi	r20, 0x07	; 7
   16d48:	40 5d       	subi	r20, 0xD0	; 208
   16d4a:	41 93       	st	Z+, r20
   16d4c:	b3 e0       	ldi	r27, 0x03	; 3
   16d4e:	0f d0       	rcall	.+30     	; 0x16d6e <__ultoa_invert+0x86>
   16d50:	c9 f7       	brne	.-14     	; 0x16d44 <__ultoa_invert+0x5c>
   16d52:	f6 cf       	rjmp	.-20     	; 0x16d40 <__ultoa_invert+0x58>
   16d54:	46 2f       	mov	r20, r22
   16d56:	4f 70       	andi	r20, 0x0F	; 15
   16d58:	40 5d       	subi	r20, 0xD0	; 208
   16d5a:	4a 33       	cpi	r20, 0x3A	; 58
   16d5c:	18 f0       	brcs	.+6      	; 0x16d64 <__ultoa_invert+0x7c>
   16d5e:	49 5d       	subi	r20, 0xD9	; 217
   16d60:	31 fd       	sbrc	r19, 1
   16d62:	40 52       	subi	r20, 0x20	; 32
   16d64:	41 93       	st	Z+, r20
   16d66:	02 d0       	rcall	.+4      	; 0x16d6c <__ultoa_invert+0x84>
   16d68:	a9 f7       	brne	.-22     	; 0x16d54 <__ultoa_invert+0x6c>
   16d6a:	ea cf       	rjmp	.-44     	; 0x16d40 <__ultoa_invert+0x58>
   16d6c:	b4 e0       	ldi	r27, 0x04	; 4
   16d6e:	a6 95       	lsr	r26
   16d70:	97 95       	ror	r25
   16d72:	87 95       	ror	r24
   16d74:	77 95       	ror	r23
   16d76:	67 95       	ror	r22
   16d78:	ba 95       	dec	r27
   16d7a:	c9 f7       	brne	.-14     	; 0x16d6e <__ultoa_invert+0x86>
   16d7c:	00 97       	sbiw	r24, 0x00	; 0
   16d7e:	61 05       	cpc	r22, r1
   16d80:	71 05       	cpc	r23, r1
   16d82:	08 95       	ret
   16d84:	9b 01       	movw	r18, r22
   16d86:	ac 01       	movw	r20, r24
   16d88:	0a 2e       	mov	r0, r26
   16d8a:	06 94       	lsr	r0
   16d8c:	57 95       	ror	r21
   16d8e:	47 95       	ror	r20
   16d90:	37 95       	ror	r19
   16d92:	27 95       	ror	r18
   16d94:	ba 95       	dec	r27
   16d96:	c9 f7       	brne	.-14     	; 0x16d8a <__ultoa_invert+0xa2>
   16d98:	62 0f       	add	r22, r18
   16d9a:	73 1f       	adc	r23, r19
   16d9c:	84 1f       	adc	r24, r20
   16d9e:	95 1f       	adc	r25, r21
   16da0:	a0 1d       	adc	r26, r0
   16da2:	08 95       	ret

00016da4 <__mulsi3>:
   16da4:	62 9f       	mul	r22, r18
   16da6:	d0 01       	movw	r26, r0
   16da8:	73 9f       	mul	r23, r19
   16daa:	f0 01       	movw	r30, r0
   16dac:	82 9f       	mul	r24, r18
   16dae:	e0 0d       	add	r30, r0
   16db0:	f1 1d       	adc	r31, r1
   16db2:	64 9f       	mul	r22, r20
   16db4:	e0 0d       	add	r30, r0
   16db6:	f1 1d       	adc	r31, r1
   16db8:	92 9f       	mul	r25, r18
   16dba:	f0 0d       	add	r31, r0
   16dbc:	83 9f       	mul	r24, r19
   16dbe:	f0 0d       	add	r31, r0
   16dc0:	74 9f       	mul	r23, r20
   16dc2:	f0 0d       	add	r31, r0
   16dc4:	65 9f       	mul	r22, r21
   16dc6:	f0 0d       	add	r31, r0
   16dc8:	99 27       	eor	r25, r25
   16dca:	72 9f       	mul	r23, r18
   16dcc:	b0 0d       	add	r27, r0
   16dce:	e1 1d       	adc	r30, r1
   16dd0:	f9 1f       	adc	r31, r25
   16dd2:	63 9f       	mul	r22, r19
   16dd4:	b0 0d       	add	r27, r0
   16dd6:	e1 1d       	adc	r30, r1
   16dd8:	f9 1f       	adc	r31, r25
   16dda:	bd 01       	movw	r22, r26
   16ddc:	cf 01       	movw	r24, r30
   16dde:	11 24       	eor	r1, r1
   16de0:	08 95       	ret

00016de2 <__udivmodqi4>:
   16de2:	99 1b       	sub	r25, r25
   16de4:	79 e0       	ldi	r23, 0x09	; 9
   16de6:	04 c0       	rjmp	.+8      	; 0x16df0 <__udivmodqi4_ep>

00016de8 <__udivmodqi4_loop>:
   16de8:	99 1f       	adc	r25, r25
   16dea:	96 17       	cp	r25, r22
   16dec:	08 f0       	brcs	.+2      	; 0x16df0 <__udivmodqi4_ep>
   16dee:	96 1b       	sub	r25, r22

00016df0 <__udivmodqi4_ep>:
   16df0:	88 1f       	adc	r24, r24
   16df2:	7a 95       	dec	r23
   16df4:	c9 f7       	brne	.-14     	; 0x16de8 <__udivmodqi4_loop>
   16df6:	80 95       	com	r24
   16df8:	08 95       	ret

00016dfa <__divmodqi4>:
   16dfa:	87 fb       	bst	r24, 7
   16dfc:	08 2e       	mov	r0, r24
   16dfe:	06 26       	eor	r0, r22
   16e00:	87 fd       	sbrc	r24, 7
   16e02:	81 95       	neg	r24
   16e04:	67 fd       	sbrc	r22, 7
   16e06:	61 95       	neg	r22
   16e08:	ec df       	rcall	.-40     	; 0x16de2 <__udivmodqi4>
   16e0a:	0e f4       	brtc	.+2      	; 0x16e0e <__divmodqi4_1>
   16e0c:	91 95       	neg	r25

00016e0e <__divmodqi4_1>:
   16e0e:	07 fc       	sbrc	r0, 7
   16e10:	81 95       	neg	r24

00016e12 <__divmodqi4_exit>:
   16e12:	08 95       	ret

00016e14 <__udivmodhi4>:
   16e14:	aa 1b       	sub	r26, r26
   16e16:	bb 1b       	sub	r27, r27
   16e18:	51 e1       	ldi	r21, 0x11	; 17
   16e1a:	07 c0       	rjmp	.+14     	; 0x16e2a <__udivmodhi4_ep>

00016e1c <__udivmodhi4_loop>:
   16e1c:	aa 1f       	adc	r26, r26
   16e1e:	bb 1f       	adc	r27, r27
   16e20:	a6 17       	cp	r26, r22
   16e22:	b7 07       	cpc	r27, r23
   16e24:	10 f0       	brcs	.+4      	; 0x16e2a <__udivmodhi4_ep>
   16e26:	a6 1b       	sub	r26, r22
   16e28:	b7 0b       	sbc	r27, r23

00016e2a <__udivmodhi4_ep>:
   16e2a:	88 1f       	adc	r24, r24
   16e2c:	99 1f       	adc	r25, r25
   16e2e:	5a 95       	dec	r21
   16e30:	a9 f7       	brne	.-22     	; 0x16e1c <__udivmodhi4_loop>
   16e32:	80 95       	com	r24
   16e34:	90 95       	com	r25
   16e36:	bc 01       	movw	r22, r24
   16e38:	cd 01       	movw	r24, r26
   16e3a:	08 95       	ret

00016e3c <__divmodhi4>:
   16e3c:	97 fb       	bst	r25, 7
   16e3e:	09 2e       	mov	r0, r25
   16e40:	07 26       	eor	r0, r23
   16e42:	0a d0       	rcall	.+20     	; 0x16e58 <__divmodhi4_neg1>
   16e44:	77 fd       	sbrc	r23, 7
   16e46:	04 d0       	rcall	.+8      	; 0x16e50 <__divmodhi4_neg2>
   16e48:	e5 df       	rcall	.-54     	; 0x16e14 <__udivmodhi4>
   16e4a:	06 d0       	rcall	.+12     	; 0x16e58 <__divmodhi4_neg1>
   16e4c:	00 20       	and	r0, r0
   16e4e:	1a f4       	brpl	.+6      	; 0x16e56 <__divmodhi4_exit>

00016e50 <__divmodhi4_neg2>:
   16e50:	70 95       	com	r23
   16e52:	61 95       	neg	r22
   16e54:	7f 4f       	sbci	r23, 0xFF	; 255

00016e56 <__divmodhi4_exit>:
   16e56:	08 95       	ret

00016e58 <__divmodhi4_neg1>:
   16e58:	f6 f7       	brtc	.-4      	; 0x16e56 <__divmodhi4_exit>
   16e5a:	90 95       	com	r25
   16e5c:	81 95       	neg	r24
   16e5e:	9f 4f       	sbci	r25, 0xFF	; 255
   16e60:	08 95       	ret

00016e62 <__udivmodsi4>:
   16e62:	a1 e2       	ldi	r26, 0x21	; 33
   16e64:	1a 2e       	mov	r1, r26
   16e66:	aa 1b       	sub	r26, r26
   16e68:	bb 1b       	sub	r27, r27
   16e6a:	fd 01       	movw	r30, r26
   16e6c:	0d c0       	rjmp	.+26     	; 0x16e88 <__udivmodsi4_ep>

00016e6e <__udivmodsi4_loop>:
   16e6e:	aa 1f       	adc	r26, r26
   16e70:	bb 1f       	adc	r27, r27
   16e72:	ee 1f       	adc	r30, r30
   16e74:	ff 1f       	adc	r31, r31
   16e76:	a2 17       	cp	r26, r18
   16e78:	b3 07       	cpc	r27, r19
   16e7a:	e4 07       	cpc	r30, r20
   16e7c:	f5 07       	cpc	r31, r21
   16e7e:	20 f0       	brcs	.+8      	; 0x16e88 <__udivmodsi4_ep>
   16e80:	a2 1b       	sub	r26, r18
   16e82:	b3 0b       	sbc	r27, r19
   16e84:	e4 0b       	sbc	r30, r20
   16e86:	f5 0b       	sbc	r31, r21

00016e88 <__udivmodsi4_ep>:
   16e88:	66 1f       	adc	r22, r22
   16e8a:	77 1f       	adc	r23, r23
   16e8c:	88 1f       	adc	r24, r24
   16e8e:	99 1f       	adc	r25, r25
   16e90:	1a 94       	dec	r1
   16e92:	69 f7       	brne	.-38     	; 0x16e6e <__udivmodsi4_loop>
   16e94:	60 95       	com	r22
   16e96:	70 95       	com	r23
   16e98:	80 95       	com	r24
   16e9a:	90 95       	com	r25
   16e9c:	9b 01       	movw	r18, r22
   16e9e:	ac 01       	movw	r20, r24
   16ea0:	bd 01       	movw	r22, r26
   16ea2:	cf 01       	movw	r24, r30
   16ea4:	08 95       	ret

00016ea6 <__prologue_saves__>:
   16ea6:	2f 92       	push	r2
   16ea8:	3f 92       	push	r3
   16eaa:	4f 92       	push	r4
   16eac:	5f 92       	push	r5
   16eae:	6f 92       	push	r6
   16eb0:	7f 92       	push	r7
   16eb2:	8f 92       	push	r8
   16eb4:	9f 92       	push	r9
   16eb6:	af 92       	push	r10
   16eb8:	bf 92       	push	r11
   16eba:	cf 92       	push	r12
   16ebc:	df 92       	push	r13
   16ebe:	ef 92       	push	r14
   16ec0:	ff 92       	push	r15
   16ec2:	0f 93       	push	r16
   16ec4:	1f 93       	push	r17
   16ec6:	cf 93       	push	r28
   16ec8:	df 93       	push	r29
   16eca:	cd b7       	in	r28, 0x3d	; 61
   16ecc:	de b7       	in	r29, 0x3e	; 62
   16ece:	ca 1b       	sub	r28, r26
   16ed0:	db 0b       	sbc	r29, r27
   16ed2:	0f b6       	in	r0, 0x3f	; 63
   16ed4:	f8 94       	cli
   16ed6:	de bf       	out	0x3e, r29	; 62
   16ed8:	0f be       	out	0x3f, r0	; 63
   16eda:	cd bf       	out	0x3d, r28	; 61
   16edc:	09 94       	ijmp

00016ede <__epilogue_restores__>:
   16ede:	2a 88       	ldd	r2, Y+18	; 0x12
   16ee0:	39 88       	ldd	r3, Y+17	; 0x11
   16ee2:	48 88       	ldd	r4, Y+16	; 0x10
   16ee4:	5f 84       	ldd	r5, Y+15	; 0x0f
   16ee6:	6e 84       	ldd	r6, Y+14	; 0x0e
   16ee8:	7d 84       	ldd	r7, Y+13	; 0x0d
   16eea:	8c 84       	ldd	r8, Y+12	; 0x0c
   16eec:	9b 84       	ldd	r9, Y+11	; 0x0b
   16eee:	aa 84       	ldd	r10, Y+10	; 0x0a
   16ef0:	b9 84       	ldd	r11, Y+9	; 0x09
   16ef2:	c8 84       	ldd	r12, Y+8	; 0x08
   16ef4:	df 80       	ldd	r13, Y+7	; 0x07
   16ef6:	ee 80       	ldd	r14, Y+6	; 0x06
   16ef8:	fd 80       	ldd	r15, Y+5	; 0x05
   16efa:	0c 81       	ldd	r16, Y+4	; 0x04
   16efc:	1b 81       	ldd	r17, Y+3	; 0x03
   16efe:	aa 81       	ldd	r26, Y+2	; 0x02
   16f00:	b9 81       	ldd	r27, Y+1	; 0x01
   16f02:	ce 0f       	add	r28, r30
   16f04:	d1 1d       	adc	r29, r1
   16f06:	0f b6       	in	r0, 0x3f	; 63
   16f08:	f8 94       	cli
   16f0a:	de bf       	out	0x3e, r29	; 62
   16f0c:	0f be       	out	0x3f, r0	; 63
   16f0e:	cd bf       	out	0x3d, r28	; 61
   16f10:	ed 01       	movw	r28, r26
   16f12:	08 95       	ret

00016f14 <_exit>:
   16f14:	f8 94       	cli

00016f16 <__stop_program>:
   16f16:	ff cf       	rjmp	.-2      	; 0x16f16 <__stop_program>
