
master4.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000005e  00800100  0001722a  000172de  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0001722a  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000d31  0080015e  0080015e  0001733c  2**0
                  ALLOC
  3 .eeprom       00000857  00810000  00810000  0001733c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .debug_aranges 000000e0  00000000  00000000  00017b93  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_pubnames 00002750  00000000  00000000  00017c73  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00013729  00000000  00000000  0001a3c3  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000c3b  00000000  00000000  0002daec  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000e1dd  00000000  00000000  0002e727  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001220  00000000  00000000  0003c904  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00005343  00000000  00000000  0003db24  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000765d  00000000  00000000  00042e67  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000006f0  00000000  00000000  0004a4c4  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 41 12 	jmp	0x2482	; 0x2482 <__ctors_end>
       4:	0c 94 60 12 	jmp	0x24c0	; 0x24c0 <__bad_interrupt>
       8:	0c 94 60 12 	jmp	0x24c0	; 0x24c0 <__bad_interrupt>
       c:	0c 94 60 12 	jmp	0x24c0	; 0x24c0 <__bad_interrupt>
      10:	0c 94 60 12 	jmp	0x24c0	; 0x24c0 <__bad_interrupt>
      14:	0c 94 60 12 	jmp	0x24c0	; 0x24c0 <__bad_interrupt>
      18:	0c 94 60 12 	jmp	0x24c0	; 0x24c0 <__bad_interrupt>
      1c:	0c 94 60 12 	jmp	0x24c0	; 0x24c0 <__bad_interrupt>
      20:	0c 94 60 12 	jmp	0x24c0	; 0x24c0 <__bad_interrupt>
      24:	0c 94 60 12 	jmp	0x24c0	; 0x24c0 <__bad_interrupt>
      28:	0c 94 60 12 	jmp	0x24c0	; 0x24c0 <__bad_interrupt>
      2c:	0c 94 60 12 	jmp	0x24c0	; 0x24c0 <__bad_interrupt>
      30:	0c 94 0a 13 	jmp	0x2614	; 0x2614 <__vector_12>
      34:	0c 94 60 12 	jmp	0x24c0	; 0x24c0 <__bad_interrupt>
      38:	0c 94 60 12 	jmp	0x24c0	; 0x24c0 <__bad_interrupt>
      3c:	0c 94 60 12 	jmp	0x24c0	; 0x24c0 <__bad_interrupt>
      40:	0c 94 60 12 	jmp	0x24c0	; 0x24c0 <__bad_interrupt>
      44:	0c 94 12 7d 	jmp	0xfa24	; 0xfa24 <__vector_17>
      48:	0c 94 c3 14 	jmp	0x2986	; 0x2986 <__vector_18>
      4c:	0c 94 60 12 	jmp	0x24c0	; 0x24c0 <__bad_interrupt>
      50:	0c 94 60 12 	jmp	0x24c0	; 0x24c0 <__bad_interrupt>
      54:	0c 94 60 12 	jmp	0x24c0	; 0x24c0 <__bad_interrupt>
      58:	0c 94 60 12 	jmp	0x24c0	; 0x24c0 <__bad_interrupt>
      5c:	0c 94 60 12 	jmp	0x24c0	; 0x24c0 <__bad_interrupt>
      60:	0c 94 60 12 	jmp	0x24c0	; 0x24c0 <__bad_interrupt>
      64:	0c 94 60 12 	jmp	0x24c0	; 0x24c0 <__bad_interrupt>
      68:	0c 94 60 12 	jmp	0x24c0	; 0x24c0 <__bad_interrupt>
      6c:	0c 94 60 12 	jmp	0x24c0	; 0x24c0 <__bad_interrupt>
      70:	0c 94 60 12 	jmp	0x24c0	; 0x24c0 <__bad_interrupt>
      74:	0c 94 60 12 	jmp	0x24c0	; 0x24c0 <__bad_interrupt>
      78:	0c 94 08 42 	jmp	0x8410	; 0x8410 <__vector_30>
      7c:	0c 94 60 12 	jmp	0x24c0	; 0x24c0 <__bad_interrupt>
      80:	0c 94 60 12 	jmp	0x24c0	; 0x24c0 <__bad_interrupt>
      84:	0c 94 60 12 	jmp	0x24c0	; 0x24c0 <__bad_interrupt>
      88:	0c 94 60 12 	jmp	0x24c0	; 0x24c0 <__bad_interrupt>
      8c:	a2 13       	cpse	r26, r18
      8e:	a0 13       	cpse	r26, r16
      90:	a4 13       	cpse	r26, r20
      92:	a6 13       	cpse	r26, r22
      94:	a8 13       	cpse	r26, r24
      96:	aa 13       	cpse	r26, r26
      98:	ac 13       	cpse	r26, r28
      9a:	ae 13       	cpse	r26, r30
      9c:	b0 13       	cpse	r27, r16
      9e:	b2 13       	cpse	r27, r18
      a0:	b4 13       	cpse	r27, r20
      a2:	b6 13       	cpse	r27, r22
      a4:	b8 13       	cpse	r27, r24
      a6:	c6 13       	cpse	r28, r22
      a8:	ba 13       	cpse	r27, r26
      aa:	c6 13       	cpse	r28, r22
      ac:	bc 13       	cpse	r27, r28
      ae:	be 13       	cpse	r27, r30
      b0:	c6 13       	cpse	r28, r22
      b2:	c0 13       	cpse	r28, r16
      b4:	c2 13       	cpse	r28, r18
      b6:	c4 13       	cpse	r28, r20
      b8:	c6 13       	cpse	r28, r22
      ba:	c6 13       	cpse	r28, r22
      bc:	ba 13       	cpse	r27, r26
      be:	ac 13       	cpse	r26, r28
      c0:	c6 13       	cpse	r28, r22
      c2:	ae 13       	cpse	r26, r30
      c4:	b2 13       	cpse	r27, r18
      c6:	b6 13       	cpse	r27, r22
      c8:	c1 54       	subi	r28, 0x41	; 65
      ca:	d9 54       	subi	r29, 0x49	; 73
      cc:	eb 54       	subi	r30, 0x4B	; 75
      ce:	20 55       	subi	r18, 0x50	; 80
      d0:	51 55       	subi	r21, 0x51	; 81
      d2:	67 55       	subi	r22, 0x57	; 87
      d4:	9c 55       	subi	r25, 0x5C	; 92
      d6:	d6 55       	subi	r29, 0x56	; 86
      d8:	1a 56       	subi	r17, 0x6A	; 106
      da:	22 56       	subi	r18, 0x62	; 98
      dc:	3a 56       	subi	r19, 0x6A	; 106
      de:	46 56       	subi	r20, 0x66	; 102
      e0:	78 56       	subi	r23, 0x68	; 104
      e2:	b9 56       	subi	r27, 0x69	; 105
      e4:	d6 56       	subi	r29, 0x66	; 102
      e6:	f0 56       	subi	r31, 0x60	; 96
      e8:	30 57       	subi	r19, 0x70	; 112
      ea:	37 55       	subi	r19, 0x57	; 87
      ec:	f2 55       	subi	r31, 0x52	; 82
      ee:	93 56       	subi	r25, 0x63	; 99
      f0:	bc 55       	subi	r27, 0x5C	; 92
      f2:	56 57       	subi	r21, 0x76	; 118
      f4:	6c 57       	subi	r22, 0x7C	; 124
      f6:	71 57       	subi	r23, 0x71	; 113
      f8:	aa 57       	subi	r26, 0x7A	; 122
      fa:	db 57       	subi	r29, 0x7B	; 123
      fc:	20 58       	subi	r18, 0x80	; 128
      fe:	40 58       	subi	r20, 0x80	; 128
     100:	5e 58       	subi	r21, 0x8E	; 142
     102:	98 58       	subi	r25, 0x88	; 136
     104:	fb 58       	subi	r31, 0x8B	; 139
     106:	3f 5d       	subi	r19, 0xDF	; 223
     108:	c1 57       	subi	r28, 0x71	; 113
     10a:	67 5d       	subi	r22, 0xD7	; 215
     10c:	c7 5d       	subi	r28, 0xD7	; 215
     10e:	81 5d       	subi	r24, 0xD1	; 209
     110:	ac 5d       	subi	r26, 0xDC	; 220
     112:	01 5e       	subi	r16, 0xE1	; 225
     114:	e1 5d       	subi	r30, 0xD1	; 209
     116:	1a 5e       	subi	r17, 0xEA	; 234
     118:	35 5e       	subi	r19, 0xE5	; 229
     11a:	47 5e       	subi	r20, 0xE7	; 231
     11c:	0b 59       	subi	r16, 0x9B	; 155
     11e:	2b 59       	subi	r18, 0x9B	; 155
     120:	52 59       	subi	r21, 0x92	; 146
     122:	61 59       	subi	r22, 0x91	; 145
     124:	7f 59       	subi	r23, 0x9F	; 159
     126:	96 59       	subi	r25, 0x96	; 150
     128:	c2 59       	subi	r28, 0x92	; 146
     12a:	d9 59       	subi	r29, 0x99	; 153
     12c:	05 5a       	subi	r16, 0xA5	; 165
     12e:	25 5a       	subi	r18, 0xA5	; 165
     130:	56 5a       	subi	r21, 0xA6	; 166
     132:	65 5a       	subi	r22, 0xA5	; 165
     134:	be 5a       	subi	r27, 0xAE	; 174
     136:	35 5b       	subi	r19, 0xB5	; 181
     138:	49 5b       	subi	r20, 0xB9	; 185
     13a:	24 5c       	subi	r18, 0xC4	; 196
     13c:	24 5c       	subi	r18, 0xC4	; 196
     13e:	5d 5b       	subi	r21, 0xBD	; 189
     140:	71 5b       	subi	r23, 0xB1	; 177
     142:	79 5b       	subi	r23, 0xB9	; 185
     144:	95 5b       	subi	r25, 0xB5	; 181
     146:	a9 5b       	subi	r26, 0xB9	; 185
     148:	b6 5b       	subi	r27, 0xB6	; 182
     14a:	cd 5b       	subi	r28, 0xBD	; 189
     14c:	e4 5b       	subi	r30, 0xB4	; 180
     14e:	02 5c       	subi	r16, 0xC2	; 194
     150:	27 5c       	subi	r18, 0xC7	; 199
     152:	3e 5c       	subi	r19, 0xCE	; 206
     154:	55 5c       	subi	r21, 0xC5	; 197
     156:	6c 5c       	subi	r22, 0xCC	; 204
     158:	83 5c       	subi	r24, 0xC3	; 195
     15a:	9a 5c       	subi	r25, 0xCA	; 202
     15c:	b1 5c       	subi	r27, 0xC1	; 193
     15e:	c8 5c       	subi	r28, 0xC8	; 200
     160:	d7 5c       	subi	r29, 0xC7	; 199
     162:	ee 5c       	subi	r30, 0xCE	; 206
     164:	11 5d       	subi	r17, 0xD1	; 209
     166:	0b 90       	.word	0x900b	; ????
     168:	27 90       	elpm	r2, Z+
     16a:	3a 90       	ld	r3, -Y
     16c:	69 90       	ld	r6, Y+
     16e:	92 90       	ld	r9, -Z
     170:	05 91       	lpm	r16, Z+
     172:	17 91       	elpm	r17, Z+
     174:	20 91 5c 91 	lds	r18, 0x915C
     178:	83 91       	.word	0x9183	; ????
     17a:	ca 91       	ld	r28, -Y	; undefined
     17c:	d4 91       	lpm	r29, Z+
     17e:	8f 91       	pop	r24
     180:	da 91       	ld	r29, -Y	; undefined
     182:	37 90       	elpm	r3, Z+
     184:	ec 91       	ld	r30, X
     186:	f2 91       	ld	r31, -Z	; undefined
     188:	94 94       	.word	0x9494	; ????
     18a:	98 94       	clz
     18c:	b4 94       	.word	0x94b4	; ????
     18e:	b0 98       	cbi	0x16, 0	; 22
     190:	b0 98       	cbi	0x16, 0	; 22
     192:	b0 98       	cbi	0x16, 0	; 22
     194:	b0 98       	cbi	0x16, 0	; 22
     196:	06 95       	lsr	r16
     198:	b0 98       	cbi	0x16, 0	; 22
     19a:	28 95       	.word	0x9528	; ????
     19c:	b0 98       	cbi	0x16, 0	; 22
     19e:	47 95       	ror	r20
     1a0:	d0 95       	com	r29
     1a2:	30 96       	adiw	r30, 0x00	; 0
     1a4:	54 96       	adiw	r26, 0x14	; 20
     1a6:	e5 94       	asr	r14
     1a8:	b0 98       	cbi	0x16, 0	; 22
     1aa:	e8 95       	spm
     1ac:	6c 96       	adiw	r28, 0x1c	; 28
     1ae:	a4 96       	adiw	r28, 0x24	; 36
     1b0:	c1 96       	adiw	r24, 0x31	; 49
     1b2:	fd 96       	adiw	r30, 0x3d	; 61
     1b4:	0d 97       	sbiw	r24, 0x0d	; 13
     1b6:	1e 98       	cbi	0x03, 6	; 3
     1b8:	2e 98       	cbi	0x05, 6	; 5
     1ba:	73 98       	cbi	0x0e, 3	; 14
     1bc:	92 98       	cbi	0x12, 2	; 18
     1be:	a4 98       	cbi	0x14, 4	; 20
     1c0:	aa 98       	cbi	0x15, 2	; 21
     1c2:	ac 98       	cbi	0x15, 4	; 21
     1c4:	a7 9a       	sbi	0x14, 7	; 20
     1c6:	ad 9a       	sbi	0x15, 5	; 21
     1c8:	b1 9a       	sbi	0x16, 1	; 22
     1ca:	c8 9a       	sbi	0x19, 0	; 25
     1cc:	e2 9a       	sbi	0x1c, 2	; 28
     1ce:	e6 9a       	sbi	0x1c, 6	; 28
     1d0:	15 9b       	sbis	0x02, 5	; 2
     1d2:	34 9b       	sbis	0x06, 4	; 6
     1d4:	3a 9b       	sbis	0x07, 2	; 7
     1d6:	43 9b       	sbis	0x08, 3	; 8
     1d8:	46 9b       	sbis	0x08, 6	; 8
     1da:	49 9b       	sbis	0x09, 1	; 9
     1dc:	4c 9b       	sbis	0x09, 4	; 9
     1de:	4f 9b       	sbis	0x09, 7	; 9
     1e0:	52 9b       	sbis	0x0a, 2	; 10
     1e2:	58 9b       	sbis	0x0b, 0	; 11
     1e4:	5b 9b       	sbis	0x0b, 3	; 11
     1e6:	5e 9b       	sbis	0x0b, 6	; 11
     1e8:	68 9b       	sbis	0x0d, 0	; 13
     1ea:	2b 9d       	mul	r18, r11
     1ec:	84 9d       	mul	r24, r4
     1ee:	92 9d       	mul	r25, r2
     1f0:	da 9d       	mul	r29, r10
     1f2:	f0 9d       	mul	r31, r0
     1f4:	07 9e       	mul	r0, r23
     1f6:	30 9e       	mul	r3, r16
     1f8:	e6 9e       	mul	r14, r22
     1fa:	f4 9e       	mul	r15, r20
     1fc:	73 9f       	mul	r23, r19
     1fe:	1f a0       	ldd	r1, Y+39	; 0x27
     200:	23 a1       	ldd	r18, Z+35	; 0x23
     202:	74 a1       	ldd	r23, Z+36	; 0x24
     204:	ba a1       	ldd	r27, Y+34	; 0x22
     206:	37 a2       	std	Z+39, r3	; 0x27
     208:	cb a2       	std	Y+35, r12	; 0x23
     20a:	71 a3       	std	Z+33, r23	; 0x21
     20c:	37 a4       	ldd	r3, Z+47	; 0x2f
     20e:	63 a4       	ldd	r6, Z+43	; 0x2b
     210:	1c a5       	ldd	r17, Y+44	; 0x2c
     212:	39 a5       	ldd	r19, Y+41	; 0x29
     214:	4f a6       	std	Y+47, r4	; 0x2f
     216:	b3 a5       	ldd	r27, Z+43	; 0x2b
     218:	fa a5       	ldd	r31, Y+42	; 0x2a
     21a:	f0 a6       	std	Z+40, r15	; 0x28
     21c:	1e a7       	std	Y+46, r17	; 0x2e
     21e:	33 a7       	std	Z+43, r19	; 0x2b
     220:	57 a6       	std	Z+47, r5	; 0x2f
     222:	db a6       	std	Y+43, r13	; 0x2b
     224:	24 a7       	std	Z+44, r18	; 0x2c
     226:	2c a7       	std	Y+44, r18	; 0x2c
     228:	91 ab       	std	Z+49, r25	; 0x31
     22a:	94 ab       	std	Z+52, r25	; 0x34
     22c:	56 ac       	ldd	r5, Z+62	; 0x3e
     22e:	65 ac       	ldd	r6, Z+61	; 0x3d
     230:	98 ac       	ldd	r9, Y+56	; 0x38
     232:	a8 ac       	ldd	r10, Y+56	; 0x38
     234:	d6 ac       	ldd	r13, Z+62	; 0x3e
     236:	75 ac       	ldd	r7, Z+61	; 0x3d
     238:	84 ac       	ldd	r8, Z+60	; 0x3c
     23a:	8e ac       	ldd	r8, Y+62	; 0x3e
     23c:	e0 ac       	ldd	r14, Z+56	; 0x38
     23e:	ed ac       	ldd	r14, Y+61	; 0x3d
     240:	f8 ac       	ldd	r15, Y+56	; 0x38
     242:	fb ac       	ldd	r15, Y+59	; 0x3b
     244:	fe ac       	ldd	r15, Y+62	; 0x3e
     246:	01 ad       	ldd	r16, Z+57	; 0x39
     248:	04 ad       	ldd	r16, Z+60	; 0x3c
     24a:	07 ad       	ldd	r16, Z+63	; 0x3f
     24c:	0a ad       	ldd	r16, Y+58	; 0x3a
     24e:	0d ad       	ldd	r16, Y+61	; 0x3d
     250:	2f ad       	ldd	r18, Y+63	; 0x3f
     252:	1d ad       	ldd	r17, Y+61	; 0x3d
     254:	10 ad       	ldd	r17, Z+56	; 0x38
     256:	28 ad       	ldd	r18, Y+56	; 0x38
     258:	40 ac       	ldd	r4, Z+56	; 0x38

0000025a <__logo>:
     25a:	00 00 00 01 01 01 05 09 00 00 00 11 11 11 15 15     ................
     26a:	11 00 00 00 00 10 10 10 14 12 00 0f 07 03 01 01     ................
     27a:	01 01 00 00 11 11 11 11 11 11 00 00 00 1e 1c 18     ................
     28a:	10 10 10 10 00 00 1f 1b 15 17 17 15 1b 1f 00 14     ................
     29a:	14 08 08 07 04 06 04 00                             ........

000002a2 <__c.3009>:
     2a2:	49 6e 69 74 69 61 6c 69 7a 65 2e 2e 2e 20 00        Initialize... .

000002b1 <__c.2993>:
     2b1:	57 61 74 63 68 44 6f 67 00                          WatchDog.

000002ba <__c.2991>:
     2ba:	42 72 6f 77 6e 4f 75 74 00                          BrownOut.

000002c3 <__c.2989>:
     2c3:	45 78 74 65 72 6e 61 6c 00                          External.

000002cc <__c.2987>:
     2cc:	50 6f 77 65 72 4f 6e 00                             PowerOn.

000002d4 <__prodloc>:
     2d4:	01 06 02 06 01 0d 02 0d 01 14 02 14                 ............

000002e0 <__prntloc>:
     2e0:	01 08 02 08 03 08 04 08 01 13 02 13                 ............

000002ec <__prntlmt>:
     2ec:	02 03 04 02 0f 0f                                   ......

000002f2 <__prntstr>:
     2f2:	01 01 00 00 00 00                                   ......

000002f8 <__hostloc>:
     2f8:	01 0a 02 0a 03 0a                                   ......

000002fe <MaxKeyHit>:
     2fe:	02 04 03 03 03 03 03 04 03 04                       ..........

00000308 <strDispenserName1>:
     308:	4e 2f 41 00                                         N/A.

0000030c <strDispenserName2>:
     30c:	47 69 6c 62 61 72 63 6f 00                          Gilbarco.

00000315 <strDispenserName3>:
     315:	57 61 79 6e 65 20 44 41 52 54 00                    Wayne DART.

00000320 <strDispenserName4>:
     320:	54 61 74 73 75 6e 6f 00                             Tatsuno.

00000328 <strDispenserName5>:
     328:	4c 47 00                                            LG.

0000032b <DefListDispenserName>:
     32b:	08 03 0c 03 15 03 20 03 28 03                       ...... .(.

00000335 <__c.10076>:
     335:	4d 72 2e 42 69 67 00                                Mr.Big.

0000033c <__c.9981>:
     33c:	25 64 00                                            %d.

0000033f <__c.9979>:
     33f:	54 25 2e 32 64 25 2e 32 64 25 73 25 73 25 73 25     T%.2d%.2d%s%s%s%
     34f:	73 25 73 25 73 3a 00                                s%s%s:.

00000356 <__c.9930>:
     356:	32 30 25 73 2f 25 73 2f 25 73 20 25 73 3a 25 73     20%s/%s/%s %s:%s
     366:	3a 25 73 00                                         :%s.

0000036a <__c.9902>:
     36a:	25 73 00                                            %s.

0000036d <__c.9893>:
     36d:	25 73 00                                            %s.

00000370 <__c.9842>:
     370:	25 63 25 2e 32 64 3a 00                             %c%.2d:.

00000378 <__c.9821>:
     378:	43 54 53 52 50 00                                   CTSRP.

0000037e <__c.9797>:
     37e:	3a 00                                               :.

00000380 <__c.9741>:
     380:	46 6d 74 54 4d 6f 6e 65 79 3a 25 73 00              FmtTMoney:%s.

0000038d <__c.9739>:
     38d:	46 6d 74 4d 6f 6e 65 79 3a 25 73 00                 FmtMoney:%s.

00000399 <__c.9737>:
     399:	54 4d 6f 6e 65 79 3a 25 73 00                       TMoney:%s.

000003a3 <__c.9735>:
     3a3:	54 56 6f 6c 75 6d 65 3a 25 73 00                    TVolume:%s.

000003ae <__c.9733>:
     3ae:	4d 6f 6e 65 79 3a 25 73 00                          Money:%s.

000003b7 <__c.9731>:
     3b7:	56 6f 6c 75 6d 65 3a 25 73 00                       Volume:%s.

000003c1 <__c.9729>:
     3c1:	52 65 6d 6f 76 65 64 3a 25 73 00                    Removed:%s.

000003cc <__c.9727>:
     3cc:	4d 69 6e 75 73 3a 25 73 00                          Minus:%s.

000003d5 <__c.9725>:
     3d5:	52 61 77 3a 25 73 00                                Raw:%s.

000003dc <__c.9723>:
     3dc:	46 6f 72 6d 61 74 65 64 3a 25 73 00                 Formated:%s.

000003e8 <__c.9721>:
     3e8:	25 73 00                                            %s.

000003eb <__c.9719>:
     3eb:	25 73 00                                            %s.

000003ee <__c.9717>:
     3ee:	25 73 00                                            %s.

000003f1 <__c.9715>:
     3f1:	25 73 00                                            %s.

000003f4 <__c.9713>:
     3f4:	44 61 74 61 3a 25 73 00                             Data:%s.

000003fc <__c.9602>:
     3fc:	4e 2f 41 00                                         N/A.

00000400 <__c.9582>:
     400:	25 73 00                                            %s.

00000403 <__c.9577>:
	...

00000404 <__c.9450>:
     404:	25 64 2e 25 73 25 73 25 73 00                       %d.%s%s%s.

0000040e <__c.9448>:
     40e:	25 64 2e 25 73 25 73 25 73 25 73 25 73 00           %d.%s%s%s%s%s.

0000041c <__c.9440>:
     41c:	54 4f 54 41 4c 20 25 73 25 73 00                    TOTAL %s%s.

00000427 <__c.9438>:
     427:	54 4f 54 41 4c 20 25 73 25 73 25 73 25 73 00        TOTAL %s%s%s%s.

00000436 <__c.9434>:
     436:	25 73 25 73 00                                      %s%s.

0000043b <__c.9432>:
     43b:	25 73 25 73 25 73 25 73 00                          %s%s%s%s.

00000444 <__c.9430>:
     444:	25 73 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 20 20 20     %s-----------   
     454:	20 20 20 20 20 20 20 20 20 20 20 20 20 00                        .

00000462 <__c.9428>:
     462:	25 73 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 20 20 20     %s-----------   
     472:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 00           -------------.

00000480 <__c.9426>:
     480:	41 77 61 6c 20 3a 25 73 25 73 00                    Awal :%s%s.

0000048b <__c.9424>:
     48b:	41 77 61 6c 20 3a 25 73 25 73 25 73 25 73 00        Awal :%s%s%s%s.

0000049a <__c.9422>:
     49a:	41 6b 68 69 72 3a 25 73 25 73 00                    Akhir:%s%s.

000004a5 <__c.9420>:
     4a5:	41 6b 68 69 72 3a 25 73 25 73 25 73 25 73 00        Akhir:%s%s%s%s.

000004b4 <__c.9418>:
     4b4:	50 25 64 2e 25 64 20 2d 20 25 73 20 00              P%d.%d - %s .

000004c1 <__c.9416>:
     4c1:	50 25 64 2e 25 64 20 2d 20 25 73 20 25 73 20 25     P%d.%d - %s %s %
     4d1:	73 00                                               s.

000004d3 <__c.9414>:
     4d3:	48 61 72 67 61 3a 20 52 70 2e 25 73 00              Harga: Rp.%s.

000004e0 <__c.9410>:
     4e0:	4e 2f 41 00                                         N/A.

000004e4 <__c.9406>:
     4e4:	50 55 4d 50 2d 50 52 4f 44 55 43 54 20 20 20 56     PUMP-PRODUCT   V
     4f4:	4f 4c 55 4d 45 28 4c 29 20 20 20 20 20 20 20 20     OLUME(L)        
     504:	20 20 20 20 20 20 00                                      .

0000050b <__c.9404>:
     50b:	50 55 4d 50 2d 50 52 4f 44 55 43 54 20 20 20 56     PUMP-PRODUCT   V
     51b:	4f 4c 55 4d 45 28 4c 29 20 20 20 20 52 55 50 49     OLUME(L)    RUPI
     52b:	41 48 28 52 50 29 00                                AH(RP).

00000532 <__c.9400>:
     532:	41 6b 68 69 72 20 53 68 69 66 74 20 3a 20 25 73     Akhir Shift : %s
     542:	20 00                                                .

00000544 <__c.9398>:
     544:	41 77 61 6c 20 20 53 68 69 66 74 20 3a 20 25 73     Awal  Shift : %s
     554:	20 00                                                .

00000556 <__c.9396>:
     556:	54 65 72 6d 69 6e 61 6c 20 49 44 20 3a 20 25 2e     Terminal ID : %.
     566:	32 64 20 20 20 20 20 20 20 20 20 20 20 20 20 20     2d              
     576:	20 20 20 20 20 00                                        .

0000057c <__c.9394>:
     57c:	20 20 20 20 20 20 20 20 4c 61 70 6f 72 61 6e 20             Laporan 
     58c:	54 75 74 75 70 20 53 68 69 66 74 3a 20 25 73 20     Tutup Shift: %s 
     59c:	20 20 20 20 20 00                                        .

000005a2 <__c.9391>:
     5a2:	25 64 00                                            %d.

000005a5 <__c.9333>:
     5a5:	25 73 00                                            %s.

000005a8 <__c.9328>:
     5a8:	30 00                                               0.

000005aa <__c.9326>:
     5aa:	30 00                                               0.

000005ac <__c.9162>:
     5ac:	25 73 00                                            %s.

000005af <__c.9160>:
     5af:	25 73 00                                            %s.

000005b2 <__c.9158>:
     5b2:	25 73 00                                            %s.

000005b5 <__c.9156>:
     5b5:	25 73 00                                            %s.

000005b8 <__c.9154>:
     5b8:	25 73 00                                            %s.

000005bb <__c.9068>:
     5bb:	41 2b 42 3a 25 73 00                                A+B:%s.

000005c2 <__c.9066>:
     5c2:	49 6e 42 3a 25 73 00                                InB:%s.

000005c9 <__c.9062>:
     5c9:	49 6e 42 3a 5f 00                                   InB:_.

000005cf <__c.9060>:
     5cf:	49 6e 41 3a 25 73 00                                InA:%s.

000005d6 <__c.9055>:
     5d6:	49 6e 41 3a 5f 00                                   InA:_.

000005dc <__c.9053>:
     5dc:	4f 70 65 72 61 74 69 6f 6e 20 4d 75 6c 74 69 70     Operation Multip
     5ec:	6c 79 00                                            ly.

000005ef <__c.8924>:
     5ef:	25 73 00                                            %s.

000005f2 <__c.8836>:
     5f2:	30 30 30 30 30 30 30 30 00                          00000000.

000005fb <__c.8679>:
     5fb:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
     60b:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
     61b:	20 20 20 00                                            .

0000061f <__c.8677>:
     61f:	20 20 20 20 20 20 20 20 20 20 20 20 20 44 55 50                  DUP
     62f:	4c 49 43 41 54 45 20 43 4f 50 59 20 20 20 20 20     LICATE COPY     
     63f:	20 20 20 00                                            .

00000643 <__c.8530>:
     643:	20 20 20 20 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d         ------------
     653:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     663:	2d 2d 00                                            --.

00000666 <__c.8527>:
     666:	20 20 20 20 20 53 75 72 63 68 61 72 67 65 20 41          Surcharge A
     676:	6d 74 3a 20 25 73 00                                mt: %s.

0000067d <__c.8524>:
     67d:	20 20 20 20 20 53 75 72 63 68 61 72 67 65 20 44          Surcharge D
     68d:	73 63 3a 20 25 73 00                                sc: %s.

00000694 <__c.8521>:
     694:	20 20 20 20 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d         ------------
     6a4:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     6b4:	2d 2d 00                                            --.

000006b7 <__c.8518>:
     6b7:	20 20 20 20 20 4d 6f 6e 74 68 20 43 6f 6e 73 20          Month Cons 
     6c7:	41 20 3a 20 52 70 2e 25 73 00                       A : Rp.%s.

000006d1 <__c.8515>:
     6d1:	20 20 20 20 20 4d 6f 6e 74 68 20 43 6f 6e 73 20          Month Cons 
     6e1:	56 20 3a 20 25 73 20 4c 00                          V : %s L.

000006ea <__c.8512>:
     6ea:	20 20 20 20 20 54 6f 74 61 6c 20 52 65 64 65 65          Total Redee
     6fa:	6d 20 3a 20 25 73 00                                m : %s.

00000701 <__c.8509>:
     701:	20 20 20 20 20 45 78 70 69 72 79 20 20 20 20 20          Expiry     
     711:	20 20 3a 20 25 73 00                                  : %s.

00000718 <__c.8506>:
     718:	20 20 20 20 20 43 75 72 72 20 50 6f 69 6e 74 73          Curr Points
     728:	20 20 3a 20 25 73 00                                  : %s.

0000072f <__c.8503>:
     72f:	20 20 20 20 20 50 72 65 76 20 50 6f 69 6e 74 73          Prev Points
     73f:	20 20 3a 20 25 73 00                                  : %s.

00000746 <__c.8500>:
     746:	20 20 20 20 20 47 61 69 6e 20 50 6f 69 6e 74 73          Gain Points
     756:	20 20 3a 20 25 73 00                                  : %s.

0000075d <__c.8497>:
     75d:	20 20 20 20 20 43 6f 72 70 20 4e 61 6d 65 20 20          Corp Name  
     76d:	20 20 3a 20 25 73 00                                  : %s.

00000774 <__c.8494>:
     774:	20 20 20 20 20 43 6f 72 70 20 49 44 20 20 20 20          Corp ID    
     784:	20 20 3a 20 25 73 00                                  : %s.

0000078b <__c.8491>:
     78b:	20 20 20 20 20 43 61 72 64 20 48 6f 6c 64 65 72          Card Holder
     79b:	20 20 3a 20 25 73 20 00                               : %s .

000007a3 <__c.8488>:
     7a3:	20 20 20 20 20 43 61 72 64 20 49 44 20 20 20 20          Card ID    
     7b3:	20 20 3a 20 25 73 00                                  : %s.

000007ba <__c.8485>:
     7ba:	20 20 20 20 20 20 20 20 20 4c 4f 59 41 4c 54 59              LOYALTY
     7ca:	20 49 4e 46 4f 52 4d 41 54 49 4f 4e 20 20 20 20      INFORMATION    
     7da:	20 20 00                                              .

000007dd <__c.8482>:
     7dd:	20 20 20 20 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d         ------------
     7ed:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     7fd:	2d 2d 00                                            --.

00000800 <__c.8479>:
     800:	20 20 20 20 2e 25 73 00                                 .%s.

00000808 <__c.8475>:
     808:	20 20 20 20 54 61 6e 64 61 20 54 61 6e 67 61 6e         Tanda Tangan
     818:	20 20 28 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f       (_____________
     828:	5f 29 00                                            _).

0000082b <__c.8470>:
     82b:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
     83b:	20 20 20 20 20 20 00                                      .

00000842 <__c.8467>:
     842:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
     852:	20 20 20 20 20 20 00                                      .

00000859 <__c.8464>:
     859:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
     869:	20 00                                                .

0000086b <__c.8462>:
     86b:	20 20 00                                              .

0000086e <__c.8460>:
     86e:	20 20 20 20 41 70 70 72 20 43 6f 64 65 3a 20 25         Appr Code: %
     87e:	73 00                                               s.

00000880 <__c.8458>:
     880:	25 73 20 20 00                                      %s  .

00000885 <__c.8456>:
     885:	20 20 20 20 4e 61 6d 61 20 20 20 20 20 3a 20 25         Nama     : %
     895:	73 00                                               s.

00000897 <__c.8453>:
     897:	20 20 20 20 20 20 20 20 20 20 2a 2a 2a 20 50 55               *** PU
     8a7:	4d 50 20 54 45 53 54 20 2a 2a 2a 20 20 20 20 20     MP TEST ***     
     8b7:	20 20 00                                              .

000008ba <__c.8451>:
     8ba:	20 20 20 20 56 6f 75 63 68 65 72 20 4e 6f 3a 20         Voucher No: 
     8ca:	25 73 00                                            %s.

000008cd <__c.8449>:
     8cd:	20 20 20 20 4b 61 72 74 75 20 49 44 20 3a 20 25         Kartu ID : %
     8dd:	73 00                                               s.

000008df <__c.8446>:
     8df:	20 20 20 20 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d         ------------
     8ef:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     8ff:	2d 2d 00                                            --.

00000902 <__c.8443>:
     902:	20 20 20 20 20 20 4f 64 6f 6d 65 74 65 72 20 20           Odometer  
     912:	20 20 3a 20 25 73 00                                  : %s.

00000919 <__c.8440>:
     919:	20 20 20 20 20 20 4e 6f 2e 50 6f 6c 69 73 69 20           No.Polisi 
     929:	20 20 3a 20 25 73 00                                  : %s.

00000930 <__c.8437>:
	...

00000931 <__c.8435>:
     931:	20 20 20 20 20 20 4a 6d 6c 20 52 75 70 69 61 68           Jml Rupiah
     941:	20 20 3a 20 52 70 2e 25 73 00                         : Rp.%s.

0000094b <__c.8432>:
     94b:	20 20 20 20 20 20 4a 6d 6c 20 4c 69 74 65 72 20           Jml Liter 
     95b:	20 20 3a 20 25 73 20 4c 00                            : %s L.

00000964 <__c.8429>:
	...

00000965 <__c.8427>:
     965:	20 20 20 20 20 20 48 61 72 67 61 2f 4c 20 20 20           Harga/L   
     975:	20 20 3a 20 52 70 2e 25 73 00                         : Rp.%s.

0000097f <__c.8424>:
     97f:	20 20 20 20 20 20 50 72 6f 64 75 6b 20 20 20 20           Produk    
     98f:	20 20 3a 20 25 73 00                                  : %s.

00000996 <__c.8421>:
     996:	20 20 20 20 20 20 50 75 6c 61 75 2f 50 6f 6d 70           Pulau/Pomp
     9a6:	61 20 3a 20 5b 25 73 5d 2d 25 73 00                 a : [%s]-%s.

000009b2 <__c.8418>:
     9b2:	20 20 20 20 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d         ------------
     9c2:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     9d2:	2d 2d 00                                            --.

000009d5 <__c.8415>:
     9d5:	20 20 20 20 20 20 57 61 6b 74 75 3a 20 25 73 20           Waktu: %s 
     9e5:	25 73 20 00                                         %s .

000009e9 <__c.8411>:
     9e9:	20 20 20 20 20 20 53 68 69 66 74 3a 20 25 73 20           Shift: %s 
     9f9:	20 4e 6f 2e 54 72 61 6e 73 3a 20 25 73 20 00         No.Trans: %s .

00000a08 <__c.8394>:
     a08:	20 00                                                .

00000a0a <__c.8392>:
     a0a:	20 20 20 20 20 20 20 20 20 20 20 20 20 44 55 50                  DUP
     a1a:	4c 49 43 41 54 45 20 43 4f 50 59 20 20 20 20 20     LICATE COPY     
     a2a:	20 20 20 00                                            .

00000a2e <__c.7990>:
     a2e:	45 72 72 6f 72 20 4e 6f 20 43 6f 6e 6e 65 63 74     Error No Connect
     a3e:	69 6f 6e 00                                         ion.

00000a42 <__c.7984>:
     a42:	50 72 6f 73 65 73 00                                Proses.

00000a49 <__c.7982>:
     a49:	53 65 6e 64 20 52 65 71 75 65 73 74 00              Send Request.

00000a56 <__c.7977>:
     a56:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
     a66:	6e 74 65 72 00                                      nter.

00000a6b <__c.7975>:
     a6b:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
     a7b:	6e 74 65 72 00                                      nter.

00000a80 <__c.7972>:
     a80:	5b 2a 5d 43 61 6e 63 65 6c 20 20 5b 23 5d 45 6e     [*]Cancel  [#]En
     a90:	74 65 72 20 00                                      ter .

00000a95 <__c.7970>:
     a95:	4f 64 6f 6d 65 74 65 72 3a 5f 20 00                 Odometer:_ .

00000aa1 <__c.7968>:
     aa1:	50 6c 61 74 20 4e 6f 3a 20 25 73 20 00              Plat No: %s .

00000aae <__c.7965>:
     aae:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
     abe:	6e 74 65 72 00                                      nter.

00000ac3 <__c.7963>:
     ac3:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
     ad3:	6e 74 65 72 00                                      nter.

00000ad8 <__c.7960>:
     ad8:	5b 2a 5d 43 61 6e 63 65 6c 20 20 5b 23 5d 45 6e     [*]Cancel  [#]En
     ae8:	74 65 72 20 00                                      ter .

00000aed <__c.7958>:
     aed:	5f 00                                               _.

00000aef <__c.7956>:
     aef:	49 6e 70 75 74 20 50 6c 61 74 20 4e 6f 3a 20 00     Input Plat No: .

00000aff <__c.7877>:
     aff:	23 29 53 61 76 65 00                                #)Save.

00000b06 <__c.7875>:
     b06:	34 29 54 65 72 6d 49 44 3a 25 64 20 00              4)TermID:%d .

00000b13 <__c.7857>:
     b13:	23 29 53 61 76 65 00                                #)Save.

00000b1a <__c.7855>:
     b1a:	34 29 54 65 72 6d 49 44 3a 25 64 20 00              4)TermID:%d .

00000b27 <__c.7853>:
     b27:	33 29 4e 6f 74 69 66 20 3a 20 20 20 20 20 2a 29     3)Notif :     *)
     b37:	45 78 69 74 00                                      Exit.

00000b3c <__c.7851>:
     b3c:	32 29 44 2f 54 20 20 20 3a 00                       2)D/T   :.

00000b46 <__c.7849>:
     b46:	31 29 4d 6f 6e 65 79 20 3a 00                       1)Money :.

00000b50 <__c.7775>:
     b50:	34 29 43 75 74 20 3a 20 20 2a 29 45 78 69 74 00     4)Cut :  *)Exit.

00000b60 <__c.7773>:
     b60:	33 29 4c 6f 67 6f 3a 20 20 23 29 53 61 76 65 00     3)Logo:  #)Save.

00000b70 <__c.7771>:
     b70:	32 29 53 69 7a 65 3a 20 20 36 29 53 70 61 63 65     2)Size:  6)Space
     b80:	20 3a 00                                             :.

00000b83 <__c.7769>:
     b83:	31 29 54 79 70 65 3a 20 20 35 29 53 63 72 6f 6c     1)Type:  5)Scrol
     b93:	6c 3a 00                                            l:.

00000b96 <__c.7705>:
     b96:	2a 29 43 61 6e 63 65 6c 20 20 20 20 20 20 23 29     *)Cancel      #)
     ba6:	53 61 76 65 00                                      Save.

00000bab <__c.7703>:
     bab:	54 49 4d 45 20 3a 20 00                             TIME : .

00000bb3 <__c.7701>:
     bb3:	44 41 54 45 20 3a 20 00                             DATE : .

00000bbb <__c.7636>:
     bbb:	2a 29 45 78 69 74 20 20 20 20 20 20 20 20 23 29     *)Exit        #)
     bcb:	53 61 76 65 00                                      Save.

00000bd0 <__c.7634>:
     bd0:	32 29 4e 32 3a 20 20 34 29 4e 34 3a 20 20 36 29     2)N2:  4)N4:  6)
     be0:	4e 36 3a 00                                         N6:.

00000be4 <__c.7632>:
     be4:	31 29 4e 31 3a 20 20 33 29 4e 33 3a 20 20 35 29     1)N1:  3)N3:  5)
     bf4:	4e 35 3a 00                                         N5:.

00000bf8 <__c.7630>:
     bf8:	50 72 6f 64 75 63 74 20 46 49 50 25 2e 32 64 00     Product FIP%.2d.

00000c08 <__c.7546>:
     c08:	43 6f 6d 70 6c 65 74 65 64 00                       Completed.

00000c12 <__c.7544>:
     c12:	43 61 6e 63 65 6c 20 20 20 20 20 00                 Cancel     .

00000c1e <__c.7541>:
     c1e:	49 64 5b 25 64 5d 3d 25 2e 32 64 20 20 00           Id[%d]=%.2d  .

00000c2c <__c.7538>:
     c2c:	53 61 76 69 6e 67 2e 2e 00                          Saving...

00000c35 <__c.7536>:
     c35:	2d 50 75 6d 70 49 44 2d 00                          -PumpID-.

00000c3e <__c.7532>:
     c3e:	20 20 20 20 4e 6f 74 20 41 6c 6c 6f 77 65 64 20         Not Allowed 
     c4e:	20 20 20 20 00                                          .

00000c53 <__c.7530>:
     c53:	20 20 44 75 70 6c 69 63 61 74 65 20 50 75 6d 70       Duplicate Pump
     c63:	49 44 20 20 00                                      ID  .

00000c68 <__c.7528>:
     c68:	20 20 20 20 20 20 57 61 72 6e 69 6e 67 21 20 20           Warning!  
     c78:	20 20 20 20 00                                          .

00000c7d <__c.7516>:
     c7d:	25 64 2e 50 25 2e 32 64 20 7c 20 25 64 2e 50 25     %d.P%.2d | %d.P%
     c8d:	2e 32 64 00                                         .2d.

00000c91 <__c.7510>:
     c91:	23 29 53 61 76 65 00                                #)Save.

00000c98 <__c.7508>:
     c98:	2a 29 42 61 63 6b 00                                *)Back.

00000c9f <__c.7503>:
     c9f:	25 64 2e 50 25 2e 32 64 20 7c 20 25 64 2e 50 25     %d.P%.2d | %d.P%
     caf:	2e 32 64 00                                         .2d.

00000cb3 <__c.7454>:
     cb3:	25 2e 32 64 00                                      %.2d.

00000cb8 <__c.7448>:
     cb8:	25 2e 32 64 00                                      %.2d.

00000cbd <__c.7446>:
     cbd:	34 29 34 3a 20 20 20 38 29 38 3a 20 20 20 2a 29     4)4:   8)8:   *)
     ccd:	45 78 69 74 00                                      Exit.

00000cd2 <__c.7444>:
     cd2:	33 29 33 3a 20 20 20 37 29 37 3a 20 20 20 23 29     3)3:   7)7:   #)
     ce2:	53 61 76 65 00                                      Save.

00000ce7 <__c.7442>:
     ce7:	32 29 32 3a 20 20 20 36 29 36 3a 00                 2)2:   6)6:.

00000cf3 <__c.7440>:
     cf3:	31 29 31 3a 20 20 20 35 29 35 3a 00                 1)1:   5)5:.

00000cff <__c.7406>:
     cff:	5b 2a 5d 45 78 69 74 20 20 5b 23 5d 43 68 61 6e     [*]Exit  [#]Chan
     d0f:	67 65 20 00                                         ge .

00000d13 <__c.7404>:
     d13:	25 64 2e 25 73 00                                   %d.%s.

00000d19 <__c.7399>:
     d19:	2d 44 69 73 70 65 6e 73 65 72 20 42 72 61 6e 64     -Dispenser Brand
     d29:	2d 00                                               -.

00000d2b <__c.7383>:
     d2b:	2a 29 45 78 69 74 00                                *)Exit.

00000d32 <__c.7381>:
     d32:	32 29 50 72 6f 64 75 63 74 00                       2)Product.

00000d3c <__c.7379>:
     d3c:	31 29 49 44 00                                      1)ID.

00000d41 <__c.7364>:
     d41:	2a 29 45 78 69 74 00                                *)Exit.

00000d48 <__c.7359>:
     d48:	25 64 2e 50 25 2e 32 64 20 7c 20 25 64 2e 50 25     %d.P%.2d | %d.P%
     d58:	2e 32 64 20 00                                      .2d .

00000d5d <__c.7350>:
     d5d:	25 2e 32 64 00                                      %.2d.

00000d62 <__c.7149>:
     d62:	5b 2a 5d 45 78 69 74 00                             [*]Exit.

00000d6a <__c.7147>:
     d6a:	36 2e 41 63 74 3a 25 64 00                          6.Act:%d.

00000d73 <__c.7145>:
     d73:	35 2e 44 6c 79 3a 25 64 00                          5.Dly:%d.

00000d7c <__c.7143>:
     d7c:	34 2e 54 69 6d 50 6f 6f 6c 3a 25 64 00              4.TimPool:%d.

00000d89 <__c.7141>:
     d89:	33 2e 54 72 79 53 65 6e 64 3a 25 64 00              3.TrySend:%d.

00000d96 <__c.7139>:
     d96:	32 2e 6e 4e 6f 50 75 6d 70 3a 25 64 00              2.nNoPump:%d.

00000da3 <__c.7137>:
     da3:	31 2e 4d 61 78 50 75 6d 70 3a 25 64 00              1.MaxPump:%d.

00000db0 <__c.7078>:
     db0:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 00              [*]Back     .

00000dbd <__c.7073>:
     dbd:	43 4f 4d 25 64 3a 25 64 00                          COM%d:%d.

00000dc6 <__c.7071>:
     dc6:	20 20 20 20 20 2d 42 61 75 64 72 61 74 65 2d 20          -Baudrate- 
     dd6:	20 20 20 20 00                                          .

00000ddb <__c.7066>:
     ddb:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 20 00           [*]Back      .

00000de9 <__c.7064>:
     de9:	33 2e 43 4f 4d 33 3a 34 38 35 00                    3.COM3:485.

00000df4 <__c.7062>:
     df4:	33 2e 43 4f 4d 33 3a 32 33 32 00                    3.COM3:232.

00000dff <__c.7060>:
     dff:	33 2e 43 4f 4d 33 3a 54 54 4c 00                    3.COM3:TTL.

00000e0a <__c.7058>:
     e0a:	32 2e 42 61 75 64 72 61 74 65 00                    2.Baudrate.

00000e15 <__c.7056>:
     e15:	31 2e 4d 6f 64 65 3a 53 74 61 6e 64 61 6c 6f 6e     1.Mode:Standalon
     e25:	65 00                                               e.

00000e27 <__c.7054>:
     e27:	31 2e 4d 6f 64 65 3a 53 6c 61 76 65 00              1.Mode:Slave.

00000e34 <__c.7052>:
     e34:	31 2e 4d 6f 64 65 3a 4e 6f 6e 65 00                 1.Mode:None.

00000e40 <__c.7005>:
     e40:	49 6e 76 61 6c 69 64 20 4f 6c 64 20 50 61 73 73     Invalid Old Pass
     e50:	77 6f 72 64 00                                      word.

00000e55 <__c.7003>:
     e55:	20 20 20 20 20 20 45 52 52 4f 52 20 20 20 20 20           ERROR     
     e65:	20 20 20 20 00                                          .

00000e6a <__c.7001>:
     e6a:	49 6e 76 61 6c 69 64 20 4e 65 77 20 50 61 73 73     Invalid New Pass
     e7a:	77 6f 72 64 00                                      word.

00000e7f <__c.6999>:
     e7f:	20 20 20 20 20 20 45 52 52 4f 52 20 20 20 20 20           ERROR     
     e8f:	20 20 20 20 00                                          .

00000e94 <__c.6997>:
     e94:	20 20 20 50 61 73 73 77 6f 72 64 20 53 61 76 65        Password Save
     ea4:	64 20 20 20 00                                      d   .

00000ea9 <__c.6995>:
     ea9:	20 20 20 20 20 43 6f 6d 70 6c 65 74 65 64 20 20          Completed  
     eb9:	20 20 20 20 00                                          .

00000ebe <__c.6991>:
     ebe:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
     ece:	6e 74 65 72 00                                      nter.

00000ed3 <__c.6988>:
     ed3:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
     ee3:	6e 74 65 72 00                                      nter.

00000ee8 <__c.6985>:
     ee8:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
     ef8:	6e 74 65 72 00                                      nter.

00000efd <__c.6983>:
     efd:	4e 65 77 3a 5f 20 20 20 20 20 20 20 20 20 20 20     New:_           
     f0d:	20 20 20 20 00                                          .

00000f12 <__c.6979>:
     f12:	56 61 6c 69 64 61 74 69 6e 67 2e 2e 00              Validating...

00000f1f <__c.6975>:
     f1f:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
     f2f:	6e 74 65 72 00                                      nter.

00000f34 <__c.6972>:
     f34:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
     f44:	6e 74 65 72 00                                      nter.

00000f49 <__c.6967>:
     f49:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
     f59:	6e 74 65 72 00                                      nter.

00000f5e <__c.6965>:
     f5e:	4e 65 77 3a 5f 20 20 20 20 20 20 20 20 20 20 20     New:_           
     f6e:	20 20 20 20 00                                          .

00000f73 <__c.6961>:
     f73:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
     f83:	6e 74 65 72 00                                      nter.

00000f88 <__c.6958>:
     f88:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
     f98:	6e 74 65 72 00                                      nter.

00000f9d <__c.6953>:
     f9d:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
     fad:	6e 74 65 72 00                                      nter.

00000fb2 <__c.6951>:
     fb2:	4e 65 77 3a 5f 20 20 20 20 20 20 20 20 20 20 20     New:_           
     fc2:	20 20 20 20 00                                          .

00000fc7 <__c.6947>:
     fc7:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
     fd7:	6e 74 65 72 00                                      nter.

00000fdc <__c.6945>:
     fdc:	4f 6c 64 3a 5f 00                                   Old:_.

00000fe2 <__c.6943>:
     fe2:	2d 41 64 6d 69 6e 69 73 74 72 61 74 6f 72 2d 00     -Administrator-.

00000ff2 <__c.6941>:
     ff2:	2d 53 75 70 65 72 76 69 73 6f 72 2d 00              -Supervisor-.

00000fff <__c.6933>:
     fff:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 00              [*]Back     .

0000100c <__c.6931>:
    100c:	32 2e 41 64 6d 69 6e 69 73 74 72 61 74 6f 72 00     2.Administrator.

0000101c <__c.6929>:
    101c:	31 2e 53 75 70 65 72 76 69 73 6f 72 00              1.Supervisor.

00001029 <__c.6927>:
    1029:	2d 43 68 61 6e 67 65 20 50 61 73 73 77 6f 72 64     -Change Password
    1039:	2d 00                                               -.

0000103b <__c.6924>:
    103b:	53 61 76 65 64 20 00                                Saved .

00001042 <__c.6918>:
    1042:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    1052:	6e 74 65 72 00                                      nter.

00001057 <__c.6915>:
    1057:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
    1067:	6e 74 65 72 00                                      nter.

0000106c <__c.6910>:
    106c:	5b 2a 5d 4e 6f 20 20 20 20 5b 23 5d 59 65 73 00     [*]No    [#]Yes.

0000107c <__c.6908>:
    107c:	53 61 76 65 3f 00                                   Save?.

00001082 <__c.6906>:
    1082:	4e 65 77 20 4f 70 65 72 61 74 6f 72 3a 00           New Operator:.

00001090 <__c.6904>:
    1090:	25 73 00                                            %s.

00001093 <__c.6900>:
    1093:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    10a3:	6e 74 65 72 00                                      nter.

000010a8 <__c.6898>:
    10a8:	4e 65 77 20 3a 5f 20 20 20 20 20 20 20 20 20 20     New :_          
    10b8:	20 20 20 20 00                                          .

000010bd <__c.6896>:
    10bd:	4e 61 6d 65 3a 00                                   Name:.

000010c3 <__c.6894>:
    10c3:	25 73 00                                            %s.

000010c6 <__c.6885>:
    10c6:	32 2e 43 68 61 6e 67 65 20 50 61 73 73 77 6f 72     2.Change Passwor
    10d6:	64 00                                               d.

000010d8 <__c.6883>:
    10d8:	31 2e 43 68 61 6e 67 65 20 4f 70 65 72 61 74 6f     1.Change Operato
    10e8:	72 00                                               r.

000010ea <__c.6800>:
    10ea:	2a 29 42 61 63 6b 00                                *)Back.

000010f1 <__c.6798>:
    10f1:	34 2e 53 70 61 72 61 74 6f 72 3a 25 63 20 00        4.Sparator:%c .

00001100 <__c.6796>:
    1100:	33 2e 44 65 63 69 6d 61 6c 20 3a 25 63 20 00        3.Decimal :%c .

0000110f <__c.6794>:
    110f:	32 2e 54 2e 4d 6f 6e 65 79 20 3a 25 64 20 00        2.T.Money :%d .

0000111e <__c.6792>:
    111e:	31 2e 54 2e 56 6f 6c 75 6d 65 3a 25 64 20 20 35     1.T.Volume:%d  5
    112e:	2e 54 65 73 74 00                                   .Test.

00001134 <__c.6787>:
    1134:	5b 2a 5d 42 61 63 6b 20 20 5b 23 5d 4e 65 78 74     [*]Back  [#]Next
	...

00001145 <__c.6785>:
    1145:	33 2e 4d 6f 6e 65 79 20 3a 25 64 00                 3.Money :%d.

00001151 <__c.6783>:
    1151:	32 2e 56 6f 6c 75 6d 65 3a 25 64 00                 2.Volume:%d.

0000115d <__c.6781>:
    115d:	31 2e 50 72 69 63 65 20 3a 25 64 00                 1.Price :%d.

00001169 <__c.6764>:
    1169:	34 29 42 72 61 6e 64 20 20 2a 29 45 78 69 74 00     4)Brand  *)Exit.

00001179 <__c.6762>:
    1179:	33 29 4c 61 62 65 6c 20 20 00                       3)Label  .

00001183 <__c.6760>:
    1183:	32 29 50 72 6f 64 75 63 74 00                       2)Product.

0000118d <__c.6758>:
    118d:	31 29 49 44 20 20 20 20 20 00                       1)ID     .

00001197 <__c.6717>:
    1197:	2a 29 42 61 63 6b 20 20 20 20 23 29 4f 4b 20 20     *)Back    #)OK  
    11a7:	20 20 20 20 00                                          .

000011ac <__c.6715>:
    11ac:	4e 65 77 3a 5f 00                                   New:_.

000011b2 <__c.6713>:
    11b2:	4f 6c 64 3a 25 73 00                                Old:%s.

000011b9 <__c.6711>:
    11b9:	2a 29 42 61 63 6b 20 20 20 20 23 29 4f 4b 20 20     *)Back    #)OK  
    11c9:	20 20 20 20 00                                          .

000011ce <__c.6709>:
    11ce:	4e 65 77 3a 5f 00                                   New:_.

000011d4 <__c.6707>:
    11d4:	45 64 69 74 20 50 72 6f 64 75 63 74 20 4e 61 6d     Edit Product Nam
    11e4:	65 20 20 20 00                                      e   .

000011e9 <__c.6705>:
    11e9:	4f 6c 64 3a 25 73 00                                Old:%s.

000011f0 <__c.6702>:
    11f0:	2a 29 42 61 63 6b 20 20 20 20 20 20 20 00           *)Back       .

000011fe <__c.6700>:
    11fe:	32 29 25 73 00                                      2)%s.

00001203 <__c.6698>:
    1203:	31 29 25 73 00                                      1)%s.

00001208 <__c.6693>:
    1208:	2a 29 42 61 63 6b 00                                *)Back.

0000120f <__c.6688>:
    120f:	25 64 29 25 73 00                                   %d)%s.

00001215 <__c.6615>:
    1215:	2a 29 42 61 63 6b 20 20 20 20 20 20 20 20 20 20     *)Back          
    1225:	20 20 20 20 00                                          .

0000122a <__c.6613>:
    122a:	33 29 50 75 6d 70 50 6f 6f 6c 69 6e 67 20 20 20     3)PumpPooling   
    123a:	20 20 20 20 00                                          .

0000123f <__c.6611>:
    123f:	32 29 53 79 73 74 65 6d 20 20 20 20 20 20 20 20     2)System        
    124f:	20 20 20 20 00                                          .

00001254 <__c.6609>:
    1254:	31 29 4f 70 65 72 61 74 6f 72 20 20 20 20 20 20     1)Operator      
    1264:	20 20 20 20 00                                          .

00001269 <__c.6606>:
    1269:	34 29 44 61 74 65 74 69 6d 65 20 2a 29 45 78 69     4)Datetime *)Exi
    1279:	74 20 20 20 00                                      t   .

0000127e <__c.6604>:
    127e:	33 29 44 65 63 69 6d 61 6c 20 20 37 29 4e 65 78     3)Decimal  7)Nex
    128e:	74 20 20 20 00                                      t   .

00001293 <__c.6602>:
    1293:	32 29 50 75 6d 70 20 20 20 20 20 36 29 48 6f 73     2)Pump     6)Hos
    12a3:	74 20 20 20 00                                      t   .

000012a8 <__c.6600>:
    12a8:	31 29 50 72 6f 64 75 63 74 20 20 35 29 50 72 69     1)Product  5)Pri
    12b8:	6e 74 65 72 00                                      nter.

000012bd <__c.6513>:
    12bd:	2e 00                                               ..

000012bf <__c.6511>:
    12bf:	25 64 00                                            %d.

000012c2 <__c.6509>:
    12c2:	20 20 20 00                                            .

000012c6 <__c.6507>:
    12c6:	2e 00                                               ..

000012c8 <__c.6505>:
    12c8:	25 64 00                                            %d.

000012cb <__c.6503>:
    12cb:	20 20 20 00                                            .

000012cf <__c.6496>:
    12cf:	5b 2a 5d 63 61 6e 63 65 6c 20 20 5b 23 5d 6e 65     [*]cancel  [#]ne
    12df:	78 74 20 20 00                                      xt  .

000012e4 <__c.6494>:
    12e4:	4e 65 77 3a 20 20 20 5f 2e 20 20 20 2e 20 20 20     New:   _.   .   
    12f4:	2e 20 20 20 00                                      .   .

000012f9 <__c.6492>:
    12f9:	4f 6c 64 3a 20 25 64 2e 25 64 2e 25 64 2e 25 64     Old: %d.%d.%d.%d
	...

0000130a <__c.6490>:
    130a:	53 65 72 76 65 72 20 49 50 00                       Server IP.

00001314 <__c.6399>:
    1314:	2e 00                                               ..

00001316 <__c.6397>:
    1316:	25 64 00                                            %d.

00001319 <__c.6395>:
    1319:	20 20 20 00                                            .

0000131d <__c.6393>:
    131d:	2e 00                                               ..

0000131f <__c.6391>:
    131f:	25 64 00                                            %d.

00001322 <__c.6389>:
    1322:	20 20 20 00                                            .

00001326 <__c.6382>:
    1326:	5b 2a 5d 63 61 6e 63 65 6c 20 20 5b 23 5d 6e 65     [*]cancel  [#]ne
    1336:	78 74 20 20 00                                      xt  .

0000133b <__c.6380>:
    133b:	4e 65 77 3a 20 20 20 5f 2e 20 20 20 2e 20 20 20     New:   _.   .   
    134b:	2e 20 20 20 00                                      .   .

00001350 <__c.6378>:
    1350:	4f 6c 64 3a 20 25 64 2e 25 64 2e 25 64 2e 25 64     Old: %d.%d.%d.%d
	...

00001361 <__c.6376>:
    1361:	43 6c 69 65 6e 74 20 49 50 00                       Client IP.

0000136b <__c.6333>:
    136b:	25 73 25 73 00                                      %s%s.

00001370 <__c.6329>:
    1370:	5b 2a 5d 4e 6f 20 5b 23 5d 59 65 73 00              [*]No [#]Yes.

0000137d <__c.6327>:
    137d:	53 61 76 65 20 46 6f 6f 74 65 72 25 64 20 3f 00     Save Footer%d ?.

0000138d <__c.6323>:
    138d:	5b 2a 5d 4e 6f 20 20 5b 23 5d 59 65 73 00           [*]No  [#]Yes.

0000139b <__c.6321>:
    139b:	41 6c 69 67 6e 20 43 65 6e 74 65 72 3f 00           Align Center?.

000013a9 <__c.6318>:
    13a9:	5b 2a 5d 42 61 63 6b 20 20 5b 23 5d 4f 4b 00        [*]Back  [#]OK.

000013b8 <__c.6316>:
    13b8:	45 64 69 74 20 46 6f 6f 74 65 72 25 64 20 00        Edit Footer%d .

000013c7 <__c.6312>:
    13c7:	2a 29 45 78 69 74 20 20 20 20 20 20 20 20 20 20     *)Exit          
    13d7:	20 20 20 20 00                                          .

000013dc <__c.6310>:
    13dc:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    13ec:	20 20 20 20 00                                          .

000013f1 <__c.6308>:
    13f1:	32 29 46 6f 6f 74 65 72 32 20 20 34 29 46 6f 6f     2)Footer2  4)Foo
    1401:	74 65 72 34 00                                      ter4.

00001406 <__c.6306>:
    1406:	31 29 46 6f 6f 74 65 72 31 20 20 33 29 46 6f 6f     1)Footer1  3)Foo
    1416:	74 65 72 33 00                                      ter3.

0000141b <__c.6274>:
    141b:	25 73 25 73 00                                      %s%s.

00001420 <__c.6270>:
    1420:	5b 2a 5d 4e 6f 20 5b 23 5d 59 65 73 00              [*]No [#]Yes.

0000142d <__c.6268>:
    142d:	53 61 76 65 20 48 65 61 64 65 72 25 64 20 3f 00     Save Header%d ?.

0000143d <__c.6264>:
    143d:	5b 2a 5d 4e 6f 20 20 5b 23 5d 59 65 73 00           [*]No  [#]Yes.

0000144b <__c.6262>:
    144b:	41 6c 69 67 6e 20 43 65 6e 74 65 72 3f 00           Align Center?.

00001459 <__c.6259>:
    1459:	5b 2a 5d 42 61 63 6b 20 20 5b 23 5d 4f 4b 00        [*]Back  [#]OK.

00001468 <__c.6257>:
    1468:	45 64 69 74 20 48 65 61 64 65 72 25 64 20 00        Edit Header%d .

00001477 <__c.6253>:
    1477:	2a 29 45 78 69 74 20 20 20 20 20 20 20 20 20 20     *)Exit          
    1487:	20 20 20 20 00                                          .

0000148c <__c.6251>:
    148c:	33 29 48 65 61 64 65 72 33 20 20 36 29 48 65 61     3)Header3  6)Hea
    149c:	64 65 72 36 00                                      der6.

000014a1 <__c.6249>:
    14a1:	32 29 48 65 61 64 65 72 32 20 20 35 29 48 65 61     2)Header2  5)Hea
    14b1:	64 65 72 35 00                                      der5.

000014b6 <__c.6247>:
    14b6:	31 29 48 65 61 64 65 72 31 20 20 34 29 48 65 61     1)Header1  4)Hea
    14c6:	64 65 72 34 00                                      der4.

000014cb <__c.6204>:
    14cb:	2a 29 45 78 69 74 00                                *)Exit.

000014d2 <__c.6202>:
    14d2:	33 29 50 61 73 73 77 6f 72 64 20 20 20 20 20 20     3)Password      
    14e2:	20 20 20 20 00                                          .

000014e7 <__c.6200>:
    14e7:	32 29 46 6f 6f 74 65 72 20 20 20 20 20 20 20 20     2)Footer        
    14f7:	20 20 20 20 00                                          .

000014fc <__c.6198>:
    14fc:	31 29 48 65 61 64 65 72 20 20 20 20 20 20 20 20     1)Header        
    150c:	20 20 20 20 00                                          .

00001511 <__c.6196>:
    1511:	32 29 46 6f 6f 74 65 72 20 20 20 20 35 29 53 65     2)Footer    5)Se
    1521:	72 76 65 72 00                                      rver.

00001526 <__c.6194>:
    1526:	31 29 48 65 61 64 65 72 20 20 20 20 34 29 43 6c     1)Header    4)Cl
    1536:	69 65 6e 74 00                                      ient.

0000153b <__c.6140>:
    153b:	53 61 76 69 6e 67 20 53 68 69 66 74 44 61 74 61     Saving ShiftData
    154b:	2e 2e 20 00                                         .. .

0000154f <__c.6135>:
    154f:	25 73 20 25 73 00                                   %s %s.

00001555 <__c.6133>:
    1555:	50 72 69 6e 74 69 6e 67 20 54 6f 74 61 6c 69 7a     Printing Totaliz
    1565:	65 72 00                                            er.

00001568 <__c.6129>:
    1568:	43 61 6e 63 65 6c 00                                Cancel.

0000156f <__c.6124>:
    156f:	45 72 72 6f 72 20 2d 20 4e 6f 20 50 75 6d 70 3a     Error - No Pump:
    157f:	25 64 20 00                                         %d .

00001583 <__c.6119>:
    1583:	57 61 69 74 20 50 75 6d 70 3a 25 64 20 00           Wait Pump:%d .

00001591 <__c.6115>:
    1591:	57 61 69 74 20 50 75 6d 70 3a 25 64 20 00           Wait Pump:%d .

0000159f <__c.6113>:
    159f:	54 6f 74 61 6c 69 7a 65 72 2e 2e 00                 Totalizer...

000015ab <__c.6041>:
    15ab:	2a 29 45 78 69 74 00                                *)Exit.

000015b2 <__c.6039>:
    15b2:	33 2e 4c 6f 63 6b 20 50 75 6d 70 20 20 00           3.Lock Pump  .

000015c0 <__c.6037>:
    15c0:	32 2e 43 6c 6f 73 65 20 44 61 79 20 20 00           2.Close Day  .

000015ce <__c.6035>:
    15ce:	31 2e 43 6c 6f 73 65 20 53 68 69 66 74 00           1.Close Shift.

000015dc <__c.5993>:
    15dc:	34 29 53 65 74 74 69 6e 67 73 20 20 20 2a 29 45     4)Settings   *)E
    15ec:	78 69 74 20 00                                      xit .

000015f1 <__c.5991>:
    15f1:	33 29 43 6c 6f 73 65 44 61 79 20 20 20 20 20 20     3)CloseDay      
    1601:	20 20 20 20 00                                          .

00001606 <__c.5989>:
    1606:	32 29 43 6c 6f 73 65 53 68 69 66 74 20 20 20 20     2)CloseShift    
    1616:	20 20 20 20 00                                          .

0000161b <__c.5987>:
    161b:	31 29 52 65 50 72 69 6e 74 20 20 20 20 20 20 20     1)RePrint       
    162b:	20 20 20 20 00                                          .

00001630 <__c.5957>:
    1630:	50 61 73 73 77 6f 72 64 20 52 65 73 74 6f 72 65     Password Restore
    1640:	64 00                                               d.

00001642 <__c.5953>:
    1642:	49 6e 76 61 6c 69 64 20 52 65 73 74 6f 72 65 20     Invalid Restore 
    1652:	20 00                                                .

00001654 <__c.5950>:
    1654:	30 30 30 30 30 00                                   00000.

0000165a <__c.5948>:
    165a:	31 31 31 31 31 00                                   11111.

00001660 <__c.5944>:
    1660:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    1670:	6e 74 65 72 00                                      nter.

00001675 <__c.5941>:
    1675:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
    1685:	6e 74 65 72 00                                      nter.

0000168a <__c.5934>:
    168a:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    169a:	6e 74 65 72 00                                      nter.

0000169f <__c.5932>:
    169f:	5f 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20     _               
    16af:	20 20 20 20 00                                          .

000016b4 <__c.5930>:
    16b4:	45 6e 74 65 72 20 52 65 73 74 6f 72 65 20 43 6f     Enter Restore Co
    16c4:	64 65 20 20 00                                      de  .

000016c9 <__c.5928>:
    16c9:	4b 65 79 20 53 74 61 6d 70 3a 25 73 20 00           Key Stamp:%s .

000016d7 <__c.5924>:
    16d7:	49 6e 76 61 6c 69 64 20 43 6f 64 65 20 20 20 20     Invalid Code    
    16e7:	20 20 20 20 00                                          .

000016ec <__c.5921>:
	...

000016ed <__c.5919>:
    16ed:	25 73 00                                            %s.

000016f0 <__c.5917>:
    16f0:	25 73 00                                            %s.

000016f3 <__c.5914>:
    16f3:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    1703:	6e 74 65 72 00                                      nter.

00001708 <__c.5911>:
    1708:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
    1718:	6e 74 65 72 00                                      nter.

0000171d <__c.5904>:
	...

0000171e <__c.5902>:
    171e:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    172e:	6e 74 65 72 00                                      nter.

00001733 <__c.5900>:
    1733:	5f 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20     _               
    1743:	20 20 20 20 00                                          .

00001748 <__c.5898>:
    1748:	45 6e 74 65 72 20 47 65 4e 69 55 73 20 43 6f 64     Enter GeNiUs Cod
    1758:	65 20 20 20 00                                      e   .

0000175d <__c.5888>:
    175d:	5b 2a 5d 45 78 69 74 20 20 20 20 20 20 20 20 20     [*]Exit         
    176d:	20 20 20 20 00                                          .

00001772 <__c.5886>:
    1772:	32 2e 43 68 61 6e 67 65 20 50 61 73 73 77 6f 72     2.Change Passwor
    1782:	64 20 20 20 00                                      d   .

00001787 <__c.5884>:
    1787:	31 2e 52 65 73 74 6f 72 65 20 50 61 73 73 77 6f     1.Restore Passwo
    1797:	72 64 20 20 00                                      rd  .

0000179c <__c.5882>:
    179c:	2d 53 79 73 74 65 6d 20 41 64 6d 69 6e 20 4c 65     -System Admin Le
    17ac:	76 65 6c 2d 00                                      vel-.

000017b1 <__c.5823>:
    17b1:	25 73 25 73 00                                      %s%s.

000017b6 <__c.5795>:
    17b6:	25 73 00                                            %s.

000017b9 <__c.5762>:
    17b9:	25 63 00                                            %c.

000017bc <__c.5760>:
    17bc:	32 30 25 73 00                                      20%s.

000017c1 <__c.5738>:
    17c1:	25 73 00                                            %s.

000017c4 <__c.5689>:
    17c4:	34 32 36 34 36 33 36 00                             4264636.

000017cc <__c.5686>:
    17cc:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    17dc:	6e 74 65 72 00                                      nter.

000017e1 <__c.5684>:
    17e1:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
    17f1:	6e 74 65 72 00                                      nter.

000017f6 <__c.5680>:
    17f6:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    1806:	6e 74 65 72 00                                      nter.

0000180b <__c.5678>:
    180b:	5f 00                                               _.

0000180d <__c.5676>:
    180d:	50 41 53 53 57 4f 52 44 3a 00                       PASSWORD:.

00001817 <__c.5648>:
    1817:	41 63 63 65 73 73 20 44 65 6e 69 65 64 00           Access Denied.

00001825 <__c.5571>:
    1825:	54 43 50 2f 49 50 20 45 72 72 6f 72 00              TCP/IP Error.

00001832 <__c.5569>:
    1832:	4e 6f 20 52 65 70 6c 79 20 20 20 20 00              No Reply    .

0000183f <__c.5565>:
    183f:	20 20 20 20 20 20 20 00                                    .

00001847 <__c.5562>:
    1847:	50 6c 65 61 73 65 20 57 61 69 74 00                 Please Wait.

00001853 <__c.5559>:
    1853:	25 73 00                                            %s.

00001856 <__c.5557>:
    1856:	50 55 4d 50 20 54 45 53 54 00                       PUMP TEST.

00001860 <__c.5554>:
    1860:	25 73 00                                            %s.

00001863 <__c.5551>:
    1863:	25 73 00                                            %s.

00001866 <__c.5549>:
    1866:	25 73 00                                            %s.

00001869 <__c.5547>:
    1869:	25 73 00                                            %s.

0000186c <__c.5543>:
    186c:	25 73 00                                            %s.

0000186f <__c.5539>:
    186f:	50 72 6f 73 65 73 00                                Proses.

00001876 <__c.5537>:
    1876:	2d 4d 4f 50 20 56 6f 75 63 68 65 72 2d 00           -MOP Voucher-.

00001884 <__c.5534>:
    1884:	50 72 6f 73 65 73 00                                Proses.

0000188b <__c.5532>:
    188b:	49 44 3a 25 73 00                                   ID:%s.

00001891 <__c.5528>:
    1891:	5b 2a 5d 42 61 63 6b 20 20 20 20 5b 23 5d 45 78     [*]Back    [#]Ex
    18a1:	69 74 00                                            it.

000018a4 <__c.5526>:
    18a4:	46 49 50 25 73 00                                   FIP%s.

000018aa <__c.5524>:
    18aa:	54 61 70 20 4b 61 72 74 75 20 52 46 49 44 00        Tap Kartu RFID.

000018b9 <__c.5515>:
    18b9:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    18c9:	6e 74 65 72 00                                      nter.

000018ce <__c.5513>:
    18ce:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
    18de:	6e 74 65 72 00                                      nter.

000018e3 <__c.5510>:
    18e3:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    18f3:	6e 74 65 72 00                                      nter.

000018f8 <__c.5508>:
    18f8:	53 75 72 63 68 61 72 67 65 3a 20 20 20 5f 25 00     Surcharge:   _%.

00001908 <__c.5506>:
    1908:	25 73 00                                            %s.

0000190b <__c.5502>:
    190b:	5b 2a 5d 42 61 63 6b 00                             [*]Back.

00001913 <__c.5497>:
    1913:	25 64 2e 25 73 00                                   %d.%s.

00001919 <__c.5495>:
    1919:	53 65 6c 65 63 74 20 42 61 6e 6b 00                 Select Bank.

00001925 <__c.5490>:
    1925:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    1935:	6e 74 65 72 00                                      nter.

0000193a <__c.5488>:
    193a:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
    194a:	6e 74 65 72 00                                      nter.

0000194f <__c.5485>:
    194f:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    195f:	6e 74 65 72 00                                      nter.

00001964 <__c.5483>:
    1964:	5f 00                                               _.

00001966 <__c.5481>:
    1966:	4b 6f 64 65 20 56 6f 75 63 68 65 72 00              Kode Voucher.

00001973 <__c.5472>:
    1973:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 20 20 20 20     [*]Back         
    1983:	20 20 20 20 00                                          .

00001988 <__c.5470>:
    1988:	32 2e 42 61 6e 6b 20 20 20 20 34 2e 50 75 6d 70     2.Bank    4.Pump
    1998:	54 65 73 74 00                                      Test.

0000199d <__c.5468>:
    199d:	31 2e 41 63 63 6f 75 6e 74 20 33 2e 56 6f 75 63     1.Account 3.Vouc
    19ad:	68 65 72 20 00                                      her .

000019b2 <__c.5466>:
    19b2:	20 20 20 53 65 6c 65 63 74 20 50 61 79 6d 65 6e        Select Paymen
    19c2:	74 20 20 20 00                                      t   .

000019c7 <__c.5413>:
    19c7:	43 52 45 44 49 54 43 41 52 44 00                    CREDITCARD.

000019d2 <__c.5407>:
    19d2:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 20 20 20 20     [*]Back         
    19e2:	20 20 20 20 00                                          .

000019e7 <__c.5405>:
    19e7:	32 2e 43 72 65 64 69 74 20 43 61 72 64 20 20 20     2.Credit Card   
    19f7:	20 20 20 20 00                                          .

000019fc <__c.5403>:
    19fc:	31 2e 44 65 62 69 74 2f 46 6c 61 73 68 20 43 61     1.Debit/Flash Ca
    1a0c:	72 64 20 20 00                                      rd  .

00001a11 <__c.5401>:
    1a11:	53 65 6c 65 63 74 20 43 61 72 64 20 54 79 70 65     Select Card Type
	...

00001a22 <__c.5367>:
    1a22:	4e 6f 20 43 6f 6e 6e 65 63 74 69 6f 6e 00           No Connection.

00001a30 <__c.5365>:
    1a30:	54 43 50 2f 49 50 20 45 52 52 4f 52 20 00           TCP/IP ERROR .

00001a3e <__c.5358>:
    1a3e:	50 72 65 73 73 20 41 6e 79 20 4b 65 79 00           Press Any Key.

00001a4c <__c.5356>:
    1a4c:	43 6d 20 56 6f 6c 3a 25 73 00                       Cm Vol:%s.

00001a56 <__c.5354>:
    1a56:	43 4d 20 41 6d 74 3a 25 73 00                       CM Amt:%s.

00001a60 <__c.5352>:
    1a60:	50 6f 69 6e 74 73 3a 25 73 00                       Points:%s.

00001a6a <__c.5350>:
    1a6a:	25 73 3a 25 73 00                                   %s:%s.

00001a70 <__c.5343>:
    1a70:	50 72 6f 73 65 73 00                                Proses.

00001a77 <__c.5341>:
    1a77:	49 44 3a 25 73 00                                   ID:%s.

00001a7d <__c.5337>:
    1a7d:	5b 2a 5d 42 61 63 6b 20 20 20 20 5b 23 5d 45 78     [*]Back    [#]Ex
    1a8d:	69 74 00                                            it.

00001a90 <__c.5335>:
    1a90:	54 61 70 20 4b 61 72 74 75 20 52 46 49 44 00        Tap Kartu RFID.

00001a9f <__c.5332>:
    1a9f:	5b 2a 5d 42 61 63 6b 20 20 20 20 5b 23 5d 45 78     [*]Back    [#]Ex
    1aaf:	69 74 00                                            it.

00001ab2 <__c.5330>:
    1ab2:	54 61 70 20 4b 61 72 74 75 20 52 46 49 44 00        Tap Kartu RFID.

00001ac1 <__c.5328>:
    1ac1:	46 49 50 3a 25 73 00                                FIP:%s.

00001ac8 <__c.5322>:
    1ac8:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 20 20 20 20     [*]Back         
    1ad8:	20 00                                                .

00001ada <__c.5320>:
    1ada:	32 2e 4c 6f 79 61 6c 74 79 20 55 70 64 61 74 65     2.Loyalty Update
    1aea:	20 00                                                .

00001aec <__c.5318>:
    1aec:	31 2e 45 6e 71 75 69 72 79 20 20 20 20 20 20 20     1.Enquiry       
    1afc:	20 00                                                .

00001afe <__c.5316>:
    1afe:	20 20 4d 65 6e 75 20 4c 6f 79 61 6c 74 79 20 20       Menu Loyalty  
    1b0e:	20 00                                                .

00001b10 <__c.5281>:
    1b10:	4e 6f 20 43 6f 6e 6e 65 63 74 69 6f 6e 00           No Connection.

00001b1e <__c.5279>:
    1b1e:	54 43 50 2f 49 50 20 45 52 52 4f 52 20 00           TCP/IP ERROR .

00001b2c <__c.5273>:
    1b2c:	5b 2a 5d 42 61 63 6b 20 20 20 20 5b 23 5d 45 78     [*]Back    [#]Ex
    1b3c:	69 74 00                                            it.

00001b3f <__c.5271>:
    1b3f:	54 61 70 20 53 75 70 65 72 76 69 73 6f 72 20 43     Tap Supervisor C
    1b4f:	61 72 64 00                                         ard.

00001b53 <__c.5269>:
    1b53:	52 65 50 72 69 6e 74 20 46 49 50 3a 25 73 20 00     RePrint FIP:%s .

00001b63 <__c.5265>:
    1b63:	54 69 64 61 6b 20 41 64 61 20 54 72 61 6e 73 61     Tidak Ada Transa
    1b73:	6b 73 69 20 00                                      ksi .

00001b78 <__c.5259>:
    1b78:	41 63 63 65 73 73 20 44 65 6e 69 65 64 00           Access Denied.

00001b86 <__c.5213>:
    1b86:	2a 29 45 78 69 74 00                                *)Exit.

00001b8d <__c.5211>:
    1b8d:	23 29 4f 4b 20 00                                   #)OK .

00001b93 <__c.5209>:
    1b93:	20 20 20 20 20 00                                        .

00001b99 <__c.5207>:
    1b99:	46 49 50 3a 5f 00                                   FIP:_.

00001b9f <__c.5202>:
    1b9f:	25 64 2e 50 25 73 20 7c 20 25 64 2e 50 25 73 00     %d.P%s | %d.P%s.

00001baf <__c.5153>:
    1baf:	30 32 25 73 25 73 25 73 25 73 25 73 25 73 25 73     02%s%s%s%s%s%s%s
	...

00001bc0 <__c.5010>:
    1bc0:	30 00                                               0.

00001bc2 <__c.4941>:
    1bc2:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    1bd2:	20 20 20 20 00                                          .

00001bd7 <__c.4936>:
    1bd7:	23 25 73 00                                         #%s.

00001bdb <__c.4934>:
    1bdb:	25 2e 32 64 00                                      %.2d.

00001be0 <__c.4932>:
    1be0:	40 46 49 50 3a 00                                   @FIP:.

00001be6 <__c.4930>:
    1be6:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    1bf6:	20 20 20 20 00                                          .

00001bfb <__c.4926>:
    1bfb:	50 72 69 6e 74 69 6e 67 20 46 49 50 25 73 20 00     Printing FIP%s .

00001c0b <__c.4900>:
    1c0b:	44 3a 25 64 20 43 3a 25 63 20 20 00                 D:%d C:%c  .

00001c17 <__c.4881>:
    1c17:	25 73 20 25 73 00                                   %s %s.

00001c1d <__c.4854>:
    1c1d:	4e 6f 20 50 75 6d 70 20 46 6f 75 6e 64 00           No Pump Found.

00001c2b <__c.4852>:
    1c2b:	54 43 50 2f 49 50 20 45 72 72 6f 72 00              TCP/IP Error.

00001c38 <__c.4850>:
    1c38:	50 75 6d 70 46 6f 75 6e 64 00                       PumpFound.

00001c42 <__c.4848>:
    1c42:	43 6f 6e 6e 65 63 74 65 64 00                       Connected.

00001c4c <__c.4843>:
    1c4c:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    1c5c:	20 20 20 00                                            .

00001c60 <__c.4841>:
    1c60:	25 73 00                                            %s.

00001c63 <__c.4836>:
    1c63:	53 63 61 6e 20 50 75 6d 70 00                       Scan Pump.

00001c6d <__c.4831>:
    1c6d:	43 6f 6e 6e 65 63 74 20 20 20 20 20 20 20 20 20     Connect         
	...

00001c7e <__c.4829>:
    1c7e:	43 6f 6e 6e 65 63 74 00                             Connect.

00001c86 <__c.4827>:
    1c86:	43 6f 6e 6e 65 63 74 20 20 20 20 20 20 20 20 20     Connect         
	...

00001c97 <__c.4800>:
    1c97:	43 4f 4d 25 64 3a 25 69 20 20 20 20 20 20 20 20     COM%d:%i        
    1ca7:	20 20 20 00                                            .

00001cab <__c.4798>:
    1cab:	49 6e 69 74 69 61 6c 69 7a 65 20 43 4f 4d 20 2e     Initialize COM .
    1cbb:	2e 2e 00                                            ...

00001cbe <__c.4759>:
    1cbe:	0a 47 65 4e 69 55 73 20 54 69 63 6b 65 74 20 50     .GeNiUs Ticket P
    1cce:	72 69 6e 74 65 72 20 0a 20 56 65 72 73 69 6f 6e     rinter . Version
    1cde:	3a 25 73 0a 20 4c 61 73 74 20 55 70 64 61 74 65     :%s. Last Update
    1cee:	20 25 73 20 0a 20 48 61 6e 69 6e 64 6f 20 41 75      %s . Hanindo Au
    1cfe:	74 6f 6d 61 74 69 6f 6e 20 53 6f 6c 75 74 69 6f     tomation Solutio
    1d0e:	6e 73 20 0a 20 77 77 77 2e 68 61 6e 69 6e 64 6f     ns . www.hanindo
    1d1e:	67 72 6f 75 70 2e 63 6f 6d 0a 0a 0a 0a 0a 0a 0a     group.com.......
    1d2e:	0a 00                                               ..

00001d30 <__c.4757>:
    1d30:	31 34 2f 30 32 2f 32 30 31 31 00                    14/02/2011.

00001d3b <__c.4755>:
    1d3b:	32 2e 33 35 00                                      2.35.

00001d40 <__c.4746>:
    1d40:	25 73 25 73 25 73 25 73 39 38 25 2e 32 64 46 39     %s%s%s%s98%.2dF9
    1d50:	36 38 43 46 46 42 00                                68CFFB.

00001d57 <__c.4623>:
    1d57:	46 75 65 6c 69 6e 67 20 40 46 49 50 3a 23 25 64     Fueling @FIP:#%d
	...

00001d68 <__c.4621>:
    1d68:	54 72 61 6e 73 61 6b 73 69 20 53 65 6c 65 73 61     Transaksi Selesa
    1d78:	69 00                                               i.

00001d7a <__c.4617>:
    1d7a:	49 44 3a 20 25 73 00                                ID: %s.

00001d81 <__c.4615>:
    1d81:	25 73 00                                            %s.

00001d84 <__c.4613>:
    1d84:	50 25 73 20 25 73 20 00                             P%s %s .

00001d8c <__c.4609>:
    1d8c:	46 49 50 20 54 69 64 61 6b 20 53 69 61 70 20 20     FIP Tidak Siap  
    1d9c:	20 20 00                                              .

00001d9f <__c.4606>:
    1d9f:	41 75 74 68 6f 72 69 73 61 73 69 20 42 65 72 68     Authorisasi Berh
    1daf:	61 73 69 6c 00                                      asil.

00001db4 <__c.4602>:
    1db4:	41 75 74 68 6f 72 69 73 61 73 69 20 47 61 67 61     Authorisasi Gaga
    1dc4:	6c 20 20 20 00                                      l   .

00001dc9 <__c.4598>:
    1dc9:	20 20 20 20 20 20 20 00                                    .

00001dd1 <__c.4595>:
    1dd1:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    1de1:	20 20 20 20 00                                          .

00001de6 <__c.4593>:
    1de6:	4d 6f 68 6f 6e 20 54 75 6e 67 67 75 20 20 20 20     Mohon Tunggu    
    1df6:	20 20 20 20 00                                          .

00001dfb <__c.4591>:
    1dfb:	25 73 00                                            %s.

00001dfe <__c.4589>:
    1dfe:	50 25 73 20 25 73 20 00                             P%s %s .

00001e06 <__c.4586>:
    1e06:	43 61 6e 63 65 6c 20 54 72 61 6e 73 61 63 74 69     Cancel Transacti
    1e16:	6f 6e 20 20 00                                      on  .

00001e1b <__c.4583>:
    1e1b:	5b 2a 5d 42 61 63 6b 20 5b 30 5d 45 53 43 20 5b     [*]Back [0]ESC [
    1e2b:	23 5d 4f 4b 00                                      #]OK.

00001e30 <__c.4581>:
    1e30:	25 73 20 00                                         %s .

00001e34 <__c.4579>:
    1e34:	20 46 75 6c 6c 00                                    Full.

00001e3a <__c.4577>:
    1e3a:	25 73 20 20 25 73 20 00                             %s  %s .

00001e42 <__c.4575>:
    1e42:	49 44 3a 20 25 73 00                                ID: %s.

00001e49 <__c.4573>:
    1e49:	25 73 20 00                                         %s .

00001e4d <__c.4569>:
    1e4d:	5b 2a 5d 42 61 63 6b 20 20 5b 23 5d 4f 4b 20 20     [*]Back  [#]OK  
    1e5d:	20 00                                                .

00001e5f <__c.4567>:
    1e5f:	4f 64 6f 6d 65 74 65 72 3a 5f 20 20 20 20 20 20     Odometer:_      
    1e6f:	20 00                                                .

00001e71 <__c.4565>:
    1e71:	25 73 20 00                                         %s .

00001e75 <__c.4563>:
    1e75:	20 20 25 73 20 25 73 20 00                            %s %s .

00001e7e <__c.4561>:
    1e7e:	50 75 6d 70 20 50 72 6f 64 75 63 74 20 41 6d 6f     Pump Product Amo
    1e8e:	75 6e 74 00                                         unt.

00001e92 <__c.4559>:
    1e92:	50 75 6d 70 20 50 72 6f 64 75 63 74 20 56 6f 6c     Pump Product Vol
    1ea2:	75 6d 65 00                                         ume.

00001ea6 <__c.4557>:
    1ea6:	20 20 54 61 6e 6b 00                                  Tank.

00001ead <__c.4555>:
    1ead:	20 20 25 73 20 25 73 20 00                            %s %s .

00001eb6 <__c.4553>:
    1eb6:	50 75 6d 70 20 50 72 6f 64 75 63 74 20 20 20 46     Pump Product   F
    1ec6:	75 6c 6c 00                                         ull.

00001eca <__c.4550>:
    1eca:	25 73 00                                            %s.

00001ecd <__c.4547>:
    1ecd:	5b 2a 5d 42 61 63 6b 20 20 5b 23 5d 4f 4b 20 20     [*]Back  [#]OK  
    1edd:	20 20 20 20 00                                          .

00001ee2 <__c.4545>:
    1ee2:	5b 32 5d 41 6d 6f 75 6e 74 3a 5f 20 20 20 20 20     [2]Amount:_     
    1ef2:	20 20 20 20 00                                          .

00001ef7 <__c.4543>:
    1ef7:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    1f07:	20 20 20 20 00                                          .

00001f0c <__c.4541>:
    1f0c:	50 25 73 2d 25 73 20 00                             P%s-%s .

00001f14 <__c.4539>:
    1f14:	5b 2a 5d 42 61 63 6b 20 20 5b 23 5d 4f 4b 20 20     [*]Back  [#]OK  
    1f24:	20 20 20 20 00                                          .

00001f29 <__c.4537>:
    1f29:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    1f39:	20 20 20 20 00                                          .

00001f3e <__c.4535>:
    1f3e:	5b 31 5d 56 6f 6c 75 6d 65 3a 5f 20 20 20 20 20     [1]Volume:_     
    1f4e:	20 20 20 20 00                                          .

00001f53 <__c.4533>:
    1f53:	50 25 73 2d 25 73 20 00                             P%s-%s .

00001f5b <__c.4530>:
    1f5b:	41 00                                               A.

00001f5d <__c.4528>:
    1f5d:	41 00                                               A.

00001f5f <__c.4526>:
    1f5f:	56 00                                               V.

00001f61 <__c.4523>:
    1f61:	5b 2a 5d 42 61 63 6b 20 20 20 20 5b 23 5d 4e 65     [*]Back    [#]Ne
    1f71:	78 74 20 20 00                                      xt  .

00001f76 <__c.4521>:
    1f76:	5b 32 5d 41 6d 6f 75 6e 74 20 20 20 20 20 20 20     [2]Amount       
    1f86:	20 20 20 20 00                                          .

00001f8b <__c.4519>:
    1f8b:	5b 31 5d 56 6f 6c 75 6d 65 20 20 20 20 20 20 20     [1]Volume       
    1f9b:	20 20 20 20 00                                          .

00001fa0 <__c.4517>:
    1fa0:	50 25 73 2d 25 73 20 00                             P%s-%s .

00001fa8 <__c.4514>:
    1fa8:	25 73 00                                            %s.

00001fab <__c.4511>:
    1fab:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 20 20 20 20     [*]Back         
    1fbb:	20 20 20 20 00                                          .

00001fc0 <__c.4506>:
    1fc0:	20 20 20 20 20 00                                        .

00001fc6 <__c.4504>:
    1fc6:	25 64 2e 25 73 00                                   %d.%s.

00001fcc <__c.4502>:
    1fcc:	25 73 00                                            %s.

00001fcf <__c.4500>:
    1fcf:	50 6f 6d 70 61 2d 25 73 00                          Pompa-%s.

00001fd8 <__c.4497>:
    1fd8:	25 2e 32 64 00                                      %.2d.

00001fdd <__c.4495>:
    1fdd:	25 2e 32 64 00                                      %.2d.

00001fe2 <__c.4492>:
    1fe2:	2a 29 45 78 69 74 00                                *)Exit.

00001fe9 <__c.4490>:
    1fe9:	23 29 4f 4b 20 00                                   #)OK .

00001fef <__c.4488>:
    1fef:	20 20 20 20 20 00                                        .

00001ff5 <__c.4486>:
    1ff5:	46 49 50 3a 5f 00                                   FIP:_.

00001ffb <__c.4481>:
    1ffb:	25 64 2e 50 25 2e 32 64 20 7c 20 25 64 2e 50 25     %d.P%.2d | %d.P%
    200b:	2e 32 64 00                                         .2d.

0000200f <__c.4477>:
    200f:	5b 2a 5d 42 61 74 61 6c 20 20 20 20 20 20 20 5b     [*]Batal       [
    201f:	23 5d 4f 4b 00                                      #]OK.

00002024 <__c.4475>:
    2024:	25 73 20 25 73 00                                   %s %s.

0000202a <__c.4473>:
    202a:	25 73 00                                            %s.

0000202d <__c.4471>:
    202d:	25 73 00                                            %s.

00002030 <__c.4469>:
    2030:	25 73 00                                            %s.

00002033 <__c.4466>:
    2033:	4b 61 72 74 75 20 54 65 72 62 61 74 61 73 20 20     Kartu Terbatas  
    2043:	20 20 20 20 00                                          .

00002048 <__c.4464>:
    2048:	54 69 64 61 6b 20 54 65 72 64 61 66 74 61 72 20     Tidak Terdaftar 
    2058:	20 20 20 20 00                                          .

0000205d <__c.4461>:
    205d:	44 61 74 61 20 52 65 63 65 69 76 65 64 20 20 20     Data Received   
    206d:	20 20 20 20 00                                          .

00002072 <__c.4458>:
    2072:	54 43 50 2f 49 50 20 45 72 72 6f 72 20 20 20 20     TCP/IP Error    
    2082:	20 20 20 20 00                                          .

00002087 <__c.4456>:
    2087:	53 65 6e 64 69 6e 67 20 46 61 69 6c 65 64 20 20     Sending Failed  
    2097:	20 20 20 20 00                                          .

0000209c <__c.4453>:
    209c:	20 20 20 20 20 20 20 00                                    .

000020a4 <__c.4448>:
    20a4:	50 72 6f 73 65 73 00                                Proses.

000020ab <__c.4446>:
    20ab:	49 44 3a 25 73 00                                   ID:%s.

000020b1 <__c.4444>:
    20b1:	20 20 20 4c 6f 63 61 6c 20 41 63 63 6f 75 6e 74        Local Account
    20c1:	20 20 20 00                                            .

000020c5 <__c.4252>:
    20c5:	25 2e 32 64 00                                      %.2d.

000020ca <__c.4247>:
    20ca:	45 39 34 34 35 35 31 32 00                          E9445512.

000020d3 <__c.4245>:
    20d3:	25 73 25 73 00                                      %s%s.

000020d8 <__c.4243>:
    20d8:	25 73 25 73 25 73 25 73 39 34 00                    %s%s%s%s94.

000020e3 <__c.4238>:
    20e3:	45 39 34 34 35 35 31 32 00                          E9445512.

000020ec <__c.4236>:
    20ec:	25 73 25 73 25 73 00                                %s%s%s.

000020f3 <__c.4234>:
    20f3:	25 73 25 73 25 73 25 73 00                          %s%s%s%s.

000020fc <__c.4232>:
    20fc:	25 73 25 73 25 73 25 73 39 32 00                    %s%s%s%s92.

00002107 <__c.4227>:
    2107:	45 39 34 34 35 35 31 32 00                          E9445512.

00002110 <__c.4225>:
    2110:	25 73 25 73 00                                      %s%s.

00002115 <__c.4223>:
    2115:	25 73 25 73 25 73 25 73 39 30 00                    %s%s%s%s90.

00002120 <__c.4214>:
    2120:	25 64 46 30 30 30 30 30 30 30 45 31 32 33 34 35     %dF0000000E12345
    2130:	36 46 46 46 46 46 25 73 45 39 34 34 35 35 31 32     6FFFFF%sE9445512
	...

00002141 <__c.4212>:
    2141:	25 73 25 73 25 64 25 73 25 73 00                    %s%s%d%s%s.

0000214c <__c.4210>:
    214c:	25 73 25 73 25 73 25 73 35 38 00                    %s%s%s%s58.

00002157 <__c.4205>:
    2157:	41 46 39 36 38 43 46 46 42 00                       AF968CFFB.

00002161 <__c.4203>:
    2161:	25 73 00                                            %s.

00002164 <__c.4201>:
    2164:	25 73 35 36 00                                      %s56.

00002169 <__c.4199>:
    2169:	25 73 25 73 25 73 00                                %s%s%s.

00002170 <__c.4194>:
    2170:	46 39 36 38 43 46 46 42 00                          F968CFFB.

00002179 <__c.4192>:
    2179:	25 73 25 73 00                                      %s%s.

0000217e <__c.4190>:
    217e:	25 73 25 73 25 73 25 73 00                          %s%s%s%s.

00002187 <__c.4188>:
    2187:	25 73 25 73 25 73 25 73 33 32 00                    %s%s%s%s32.

00002192 <__c.4183>:
    2192:	25 73 25 73 46 39 36 38 43 46 46 42 00              %s%sF968CFFB.

0000219f <__c.4181>:
    219f:	25 73 25 73 25 73 25 73 32 38 00                    %s%s%s%s28.

000021aa <__c.4176>:
    21aa:	25 73 25 73 46 39 36 38 43 46 46 42 00              %s%sF968CFFB.

000021b7 <__c.4174>:
    21b7:	25 73 25 73 25 73 25 73 32 34 00                    %s%s%s%s24.

000021c2 <__c.4169>:
    21c2:	25 73 46 39 36 38 43 46 46 42 00                    %sF968CFFB.

000021cd <__c.4167>:
    21cd:	25 73 25 73 25 73 25 73 32 32 00                    %s%s%s%s22.

000021d8 <__c.4162>:
    21d8:	25 73 25 73 25 73 25 73 31 30 46 39 36 38 43 46     %s%s%s%s10F968CF
    21e8:	46 42 00                                            FB.

000021eb <__c.4157>:
    21eb:	25 73 25 73 25 73 25 73 30 34 25 73 31 46 39 36     %s%s%s%s04%s1F96
    21fb:	38 43 46 46 42 00                                   8CFFB.

00002201 <__c.4143>:
    2201:	25 73 2e 25 73 2e 25 73 2e 25 73 00                 %s.%s.%s.%s.

0000220d <__c.4124>:
    220d:	25 73 2e 25 73 2e 25 73 2e 25 73 00                 %s.%s.%s.%s.

00002219 <__c.4057>:
    2219:	25 73 20 25 73 00                                   %s %s.

0000221f <__c.4055>:
    221f:	32 2e 33 35 00                                      2.35.

00002224 <__c.4053>:
    2224:	47 65 4e 69 55 73 00                                GeNiUs.

0000222b <__c.4039>:
    222b:	50 72 65 73 73 20 61 6e 79 20 6b 65 79 2e 2e 20     Press any key.. 
    223b:	20 20 20 20 00                                          .

00002240 <__c.4027>:
    2240:	5b 31 5d 53 6c 61 76 65 20 5b 32 5d 53 74 61 6e     [1]Slave [2]Stan
    2250:	64 61 6c 6f 6e 65 00                                dalone.

00002257 <__c.3948>:
    2257:	3e 00                                               >.

00002259 <__c.3943>:
    2259:	25 2e 32 64 00                                      %.2d.

0000225e <__c.3941>:
    225e:	25 2e 32 64 00                                      %.2d.

00002263 <__c.3939>:
    2263:	30 00                                               0.

00002265 <__c.3937>:
    2265:	31 00                                               1.

00002267 <__c.3929>:
    2267:	25 64 00                                            %d.

0000226a <__c.3924>:
    226a:	25 2e 32 64 00                                      %.2d.

0000226f <__c.3919>:
    226f:	25 73 00                                            %s.

00002272 <__c.3914>:
    2272:	25 73 00                                            %s.

00002275 <__c.3909>:
    2275:	25 73 00                                            %s.

00002278 <__c.3907>:
    2278:	3c 00                                               <.

0000227a <__c.3839>:
    227a:	3c 4f 4b 3e 00                                      <OK>.

0000227f <__c.3834>:
    227f:	25 64 00                                            %d.

00002282 <__c.3832>:
    2282:	25 64 00                                            %d.

00002285 <__c.3821>:
    2285:	25 64 00                                            %d.

00002288 <__c.3810>:
    2288:	3c 53 61 76 69 6e 67 3e 00                          <Saving>.

00002291 <__c.3808>:
    2291:	4c 65 6e 67 74 68 3a 25 64 00                       Length:%d.

0000229b <__c.3622>:
    229b:	25 73 00                                            %s.

0000229e <__c.3564>:
    229e:	25 73 00                                            %s.

000022a1 <__c.3562>:
    22a1:	25 73 00                                            %s.

000022a4 <__c.3560>:
    22a4:	25 73 00                                            %s.

000022a7 <__c.3558>:
    22a7:	25 73 00                                            %s.

000022aa <__c.3556>:
    22aa:	25 2e 32 64 00                                      %.2d.

000022af <__c.3554>:
    22af:	25 64 00                                            %d.

000022b2 <__c.3552>:
    22b2:	25 73 00                                            %s.

000022b5 <__c.3550>:
    22b5:	25 73 00                                            %s.

000022b8 <__c.3548>:
    22b8:	25 73 00                                            %s.

000022bb <__c.3546>:
    22bb:	25 64 00                                            %d.

000022be <__c.3544>:
    22be:	4e 2f 41 00                                         N/A.

000022c2 <__c.3445>:
    22c2:	25 64 00                                            %d.

000022c5 <__c.3443>:
    22c5:	25 73 00                                            %s.

000022c8 <__c.3441>:
    22c8:	25 73 00                                            %s.

000022cb <__c.3356>:
    22cb:	54 69 64 61 6b 20 41 64 61 20 54 72 61 6e 73 61     Tidak Ada Transa
    22db:	6b 73 69 20 00                                      ksi .

000022e0 <__c.3353>:
    22e0:	54 6f 74 61 6c 69 7a 65 72 41 6c 6c 20 20 20 20     TotalizerAll    
    22f0:	20 00                                                .

000022f2 <__c.3350>:
    22f2:	43 6c 65 61 72 20 44 61 74 61 20 54 6f 74 61 6c     Clear Data Total
    2302:	69 7a 65 72 00                                      izer.

00002307 <__c.3338>:
    2307:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
	...

00002318 <__c.3335>:
    2318:	52 65 61 64 79 2e 2e 2e 20 20 20 20 20 20 20 20     Ready...        
    2328:	20 20 20 20 00                                          .

0000232d <__c.3332>:
    232d:	52 65 61 64 79 2e 2e 2e 20 20 20 20 20 20 20 20     Ready...        
    233d:	20 20 20 20 00                                          .

00002342 <__c.3330>:
    2342:	4e 6f 20 52 65 73 70 6f 6e 73 65 2e 2e 20 20 20     No Response..   
    2352:	20 20 20 20 00                                          .

00002357 <__c.3327>:
    2357:	50 6c 65 61 73 65 20 57 61 69 74 2e 2e 20 20 20     Please Wait..   
    2367:	20 20 20 20 00                                          .

0000236c <__c.3324>:
    236c:	52 65 61 64 79 2e 2e 2e 20 20 20 20 20 20 20 20     Ready...        
    237c:	20 20 20 20 00                                          .

00002381 <__c.3321>:
    2381:	54 69 64 61 6b 20 41 64 61 20 54 72 61 6e 73 61     Tidak Ada Transa
    2391:	6b 73 69 20 00                                      ksi .

00002396 <__c.3316>:
    2396:	53 65 64 61 6e 67 50 72 6f 73 65 73 00              SedangProses.

000023a3 <__c.3313>:
    23a3:	34 33 35 36 41 33 31 41 00                          4356A31A.

000023ac <__c.1750>:
    23ac:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    23bc:	20 20 20 20 00                                          .

000023c1 <__c.1748>:
    23c1:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    23d1:	20 20 20 20 00                                          .

000023d6 <__c.1746>:
    23d6:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    23e6:	20 20 20 20 00                                          .

000023eb <__c.1744>:
    23eb:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    23fb:	20 20 20 20 00                                          .

00002400 <__alphanum>:
    2400:	30 20 2e 00 00 00 31 2e 2c 3f 21 00 32 61 62 63     0 ....1.,?!.2abc
    2410:	00 00 33 64 65 66 00 00 34 67 68 69 00 00 35 6a     ..3def..4ghi..5j
    2420:	6b 6c 00 00 36 6d 6e 6f 00 00 37 70 71 72 73 00     kl..6mno..7pqrs.
    2430:	38 74 75 76 00 00 39 77 78 79 7a 00 30 20 2e 00     8tuv..9wxyz.0 ..
    2440:	00 00 31 26 40 2b 2d 00 32 41 42 43 00 00 33 44     ..1&@+-.2ABC..3D
    2450:	45 46 00 00 34 47 48 49 00 00 35 4a 4b 4c 00 00     EF..4GHI..5JKL..
    2460:	36 4d 4e 4f 00 00 37 50 51 52 53 00 38 54 55 56     6MNO..7PQRS.8TUV
    2470:	00 00 39 57 58 59 5a 00                             ..9WXYZ.

00002478 <__maxchar>:
    2478:	02 04 03 03 03 03 03 04 03 04                       ..........

00002482 <__ctors_end>:
    2482:	11 24       	eor	r1, r1
    2484:	1f be       	out	0x3f, r1	; 63
    2486:	cf ef       	ldi	r28, 0xFF	; 255
    2488:	d0 e1       	ldi	r29, 0x10	; 16
    248a:	de bf       	out	0x3e, r29	; 62
    248c:	cd bf       	out	0x3d, r28	; 61

0000248e <__do_copy_data>:
    248e:	11 e0       	ldi	r17, 0x01	; 1
    2490:	a0 e0       	ldi	r26, 0x00	; 0
    2492:	b1 e0       	ldi	r27, 0x01	; 1
    2494:	ea e2       	ldi	r30, 0x2A	; 42
    2496:	f2 e7       	ldi	r31, 0x72	; 114
    2498:	01 e0       	ldi	r16, 0x01	; 1
    249a:	0b bf       	out	0x3b, r16	; 59
    249c:	02 c0       	rjmp	.+4      	; 0x24a2 <__do_copy_data+0x14>
    249e:	07 90       	elpm	r0, Z+
    24a0:	0d 92       	st	X+, r0
    24a2:	ae 35       	cpi	r26, 0x5E	; 94
    24a4:	b1 07       	cpc	r27, r17
    24a6:	d9 f7       	brne	.-10     	; 0x249e <__do_copy_data+0x10>

000024a8 <__do_clear_bss>:
    24a8:	1e e0       	ldi	r17, 0x0E	; 14
    24aa:	ae e5       	ldi	r26, 0x5E	; 94
    24ac:	b1 e0       	ldi	r27, 0x01	; 1
    24ae:	01 c0       	rjmp	.+2      	; 0x24b2 <.do_clear_bss_start>

000024b0 <.do_clear_bss_loop>:
    24b0:	1d 92       	st	X+, r1

000024b2 <.do_clear_bss_start>:
    24b2:	af 38       	cpi	r26, 0x8F	; 143
    24b4:	b1 07       	cpc	r27, r17
    24b6:	e1 f7       	brne	.-8      	; 0x24b0 <.do_clear_bss_loop>
    24b8:	0e 94 f1 12 	call	0x25e2	; 0x25e2 <main>
    24bc:	0c 94 13 b9 	jmp	0x17226	; 0x17226 <_exit>

000024c0 <__bad_interrupt>:
    24c0:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000024c4 <systemOnReset>:
	};
}


void systemOnReset(){
     IsPowerOn=False;
    24c4:	10 92 9a 04 	sts	0x049A, r1
     if (MCUCSR & 1){   // Power-on Reset
    24c8:	04 b6       	in	r0, 0x34	; 52
    24ca:	00 fe       	sbrs	r0, 0
    24cc:	0b c0       	rjmp	.+22     	; 0x24e4 <systemOnReset+0x20>
         MCUCSR=0;lcd_printf(1,1,PSTR("PowerOn"));//Wiznet Blm Ready
    24ce:	14 be       	out	0x34, r1	; 52
    24d0:	81 e0       	ldi	r24, 0x01	; 1
    24d2:	61 e0       	ldi	r22, 0x01	; 1
    24d4:	4c ec       	ldi	r20, 0xCC	; 204
    24d6:	52 e0       	ldi	r21, 0x02	; 2
    24d8:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		 IsPowerOn=True;
    24dc:	81 e0       	ldi	r24, 0x01	; 1
    24de:	80 93 9a 04 	sts	0x049A, r24
    24e2:	18 c0       	rjmp	.+48     	; 0x2514 <systemOnReset+0x50>
         }
     else 
     if (MCUCSR & 2){   // External Reset
    24e4:	04 b6       	in	r0, 0x34	; 52
    24e6:	01 fe       	sbrs	r0, 1
    24e8:	06 c0       	rjmp	.+12     	; 0x24f6 <systemOnReset+0x32>
         MCUCSR=0;lcd_printf(1,1,PSTR("External"));
    24ea:	14 be       	out	0x34, r1	; 52
    24ec:	81 e0       	ldi	r24, 0x01	; 1
    24ee:	61 e0       	ldi	r22, 0x01	; 1
    24f0:	43 ec       	ldi	r20, 0xC3	; 195
    24f2:	52 e0       	ldi	r21, 0x02	; 2
    24f4:	0d c0       	rjmp	.+26     	; 0x2510 <systemOnReset+0x4c>
        }
     else 
     if (MCUCSR & 4){   // Brown-Out Reset
    24f6:	04 b6       	in	r0, 0x34	; 52
    24f8:	02 fe       	sbrs	r0, 2
    24fa:	06 c0       	rjmp	.+12     	; 0x2508 <systemOnReset+0x44>
         MCUCSR=0;lcd_printf(1,1,PSTR("BrownOut"));
    24fc:	14 be       	out	0x34, r1	; 52
    24fe:	81 e0       	ldi	r24, 0x01	; 1
    2500:	61 e0       	ldi	r22, 0x01	; 1
    2502:	4a eb       	ldi	r20, 0xBA	; 186
    2504:	52 e0       	ldi	r21, 0x02	; 2
    2506:	04 c0       	rjmp	.+8      	; 0x2510 <systemOnReset+0x4c>
         }
     else		  // Watchdog Reset
        {
         lcd_printf(1,1,PSTR("WatchDog"));
    2508:	81 e0       	ldi	r24, 0x01	; 1
    250a:	61 e0       	ldi	r22, 0x01	; 1
    250c:	41 eb       	ldi	r20, 0xB1	; 177
    250e:	52 e0       	ldi	r21, 0x02	; 2
    2510:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
        };
     MCUCSR=0;		  
    2514:	14 be       	out	0x34, r1	; 52
    2516:	80 ee       	ldi	r24, 0xE0	; 224
    2518:	9e e2       	ldi	r25, 0x2E	; 46
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    251a:	20 e7       	ldi	r18, 0x70	; 112
    251c:	31 e0       	ldi	r19, 0x01	; 1
    251e:	f9 01       	movw	r30, r18
    2520:	31 97       	sbiw	r30, 0x01	; 1
    2522:	f1 f7       	brne	.-4      	; 0x2520 <systemOnReset+0x5c>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2524:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2526:	d9 f7       	brne	.-10     	; 0x251e <systemOnReset+0x5a>
	 _delay_ms(1200);
}
    2528:	08 95       	ret

0000252a <SystemInit>:


void SystemInit(){
	unsigned int __delay =300;
	lcd_init();
    252a:	0e 94 e2 ad 	call	0x15bc4	; 0x15bc4 <lcd_init>
	lcd_clear();
    252e:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
	BackLightTrig();
    2532:	0e 94 0a 16 	call	0x2c14	; 0x2c14 <BackLightTrig>
	systemOnReset();
    2536:	0e 94 62 12 	call	0x24c4	; 0x24c4 <systemOnReset>

	lcd_printf(4, 1, PSTR("Initialize... "));
    253a:	84 e0       	ldi	r24, 0x04	; 4
    253c:	61 e0       	ldi	r22, 0x01	; 1
    253e:	42 ea       	ldi	r20, 0xA2	; 162
    2540:	52 e0       	ldi	r21, 0x02	; 2
    2542:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
    2546:	88 eb       	ldi	r24, 0xB8	; 184
    2548:	9b e0       	ldi	r25, 0x0B	; 11
    254a:	20 e7       	ldi	r18, 0x70	; 112
    254c:	31 e0       	ldi	r19, 0x01	; 1
    254e:	f9 01       	movw	r30, r18
    2550:	31 97       	sbiw	r30, 0x01	; 1
    2552:	f1 f7       	brne	.-4      	; 0x2550 <SystemInit+0x26>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2554:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2556:	d9 f7       	brne	.-10     	; 0x254e <SystemInit+0x24>
	_delay_ms(__delay);
	PORTA = 0XFF;		// Buffer for PORTA
    2558:	9f ef       	ldi	r25, 0xFF	; 255
    255a:	9b bb       	out	0x1b, r25	; 27
	DDRA = 0xFF;		// Pin 3 out (SS _SPI_SLAVE)
    255c:	9a bb       	out	0x1a, r25	; 26
	sbi(PORTA, 3);		// Disable SS _SPI_SLAVE
    255e:	db 9a       	sbi	0x1b, 3	; 27

	//Buzzer PORTB.5
	PORTB = 0xFF;DDRB = 0xFF;
    2560:	98 bb       	out	0x18, r25	; 24
    2562:	97 bb       	out	0x17, r25	; 23
	PORTD = 0b00001101;
    2564:	8d e0       	ldi	r24, 0x0D	; 13
    2566:	82 bb       	out	0x12, r24	; 18
    DDRD =  0b00001001;
    2568:	89 e0       	ldi	r24, 0x09	; 9
    256a:	81 bb       	out	0x11, r24	; 17

	TWBR = 0xFF;
    256c:	90 93 70 00 	sts	0x0070, r25
    //MMC
	PORTE = 0x0E;		// Buffer for PORTE
    2570:	8e e0       	ldi	r24, 0x0E	; 14
    2572:	83 b9       	out	0x03, r24	; 3
	DDRE = 0x0E;		// Pin 3 out (SS _SPI_MMC), pin 2 out (HB)
    2574:	82 b9       	out	0x02, r24	; 2
	sbi(PORTE, 3);		// Disable SS _SPI_MMC
    2576:	1b 9a       	sbi	0x03, 3	; 3
	cbi(PORTE, 2);		// HB on
    2578:	1a 98       	cbi	0x03, 2	; 3

	//Keypad
	PORTF = 0xFF;		// Buffer for PORTF
    257a:	90 93 62 00 	sts	0x0062, r25
	DDRF = 0xF0;		// 4 bit row, 4 bit column
    257e:	80 ef       	ldi	r24, 0xF0	; 240
    2580:	80 93 61 00 	sts	0x0061, r24

  	_spi_init(0,1);//Slave
    2584:	80 e0       	ldi	r24, 0x00	; 0
    2586:	61 e0       	ldi	r22, 0x01	; 1
    2588:	0e 94 da b0 	call	0x161b4	; 0x161b4 <_spi_init>
	sbi(DDRB,3);sbi(PORTB,3);//MISO Output
    258c:	bb 9a       	sbi	0x17, 3	; 23
    258e:	c3 9a       	sbi	0x18, 3	; 24
	cbi(DDRB,2);sbi(PORTB,2);//MOSI Input
    2590:	ba 98       	cbi	0x17, 2	; 23
    2592:	c2 9a       	sbi	0x18, 2	; 24
	cbi(DDRB,1);sbi(PORTB,1);//SCK  Input
    2594:	b9 98       	cbi	0x17, 1	; 23
    2596:	c1 9a       	sbi	0x18, 1	; 24

	TCCR1B |= (1 << WGM12);
    2598:	8e b5       	in	r24, 0x2e	; 46
    259a:	88 60       	ori	r24, 0x08	; 8
    259c:	8e bd       	out	0x2e, r24	; 46
	TIMSK |= (1 << OCIE1A);
    259e:	87 b7       	in	r24, 0x37	; 55
    25a0:	80 61       	ori	r24, 0x10	; 16
    25a2:	87 bf       	out	0x37, r24	; 55
	sei();          //1/14745600=0,06781684028uS *1400 = 100uS 65535-1400+1=64136
    25a4:	78 94       	sei
	OCR1A   = 15624;//49911 -->0,33847384982639 ms
    25a6:	88 e0       	ldi	r24, 0x08	; 8
    25a8:	9d e3       	ldi	r25, 0x3D	; 61
    25aa:	9b bd       	out	0x2b, r25	; 43
    25ac:	8a bd       	out	0x2a, r24	; 42
	TCCR1B |= ((1 << CS10) | (1 << CS11));
    25ae:	8e b5       	in	r24, 0x2e	; 46
    25b0:	83 60       	ori	r24, 0x03	; 3
    25b2:	8e bd       	out	0x2e, r24	; 46

	SendSlaveCommand(SC_SLAVE,ST_NONE);
    25b4:	81 e0       	ldi	r24, 0x01	; 1
    25b6:	60 e0       	ldi	r22, 0x00	; 0
    25b8:	0e 94 de 73 	call	0xe7bc	; 0xe7bc <SendSlaveCommand>
	
	InitComport();
    25bc:	0e 94 d6 9b 	call	0x137ac	; 0x137ac <InitComport>
	_LIGHT_SET;
    25c0:	81 e0       	ldi	r24, 0x01	; 1
    25c2:	80 93 bf 03 	sts	0x03BF, r24
    25c6:	10 92 c0 03 	sts	0x03C0, r1
    25ca:	80 91 65 00 	lds	r24, 0x0065
    25ce:	8d 7f       	andi	r24, 0xFD	; 253
    25d0:	80 93 65 00 	sts	0x0065, r24
	InitPrinter();
    25d4:	0e 94 26 4d 	call	0x9a4c	; 0x9a4c <InitPrinter>
    InitializeConnection();
    25d8:	0e 94 d9 77 	call	0xefb2	; 0xefb2 <InitializeConnection>
	lcd_clear(); 
    25dc:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
}
    25e0:	08 95       	ret

000025e2 <main>:
void SystemInit();
//void TestUserInput();

//Program Utama
int main(){
	SystemInit();
    25e2:	0e 94 95 12 	call	0x252a	; 0x252a <SystemInit>
	while(1){
	//FTestChar();
	//TestUserInput();
    FMenuIdle();
    25e6:	0e 94 80 ab 	call	0x15700	; 0x15700 <FMenuIdle>
    25ea:	fd cf       	rjmp	.-6      	; 0x25e6 <main+0x4>

000025ec <eeprom_read_byte>:

/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    25ec:	9c 01       	movw	r18, r24
    do {} while (!eeprom_is_ready ());
    25ee:	e1 99       	sbic	0x1c, 1	; 28
    25f0:	fe cf       	rjmp	.-4      	; 0x25ee <eeprom_read_byte+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    25f2:	3f bb       	out	0x1f, r19	; 31
    25f4:	2e bb       	out	0x1e, r18	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    25f6:	e0 9a       	sbi	0x1c, 0	; 28
    25f8:	8d b3       	in	r24, 0x1d	; 29
        : "i" (_SFR_IO_ADDR(EECR)),
          "i" (EERE),
          "i" (_SFR_IO_ADDR(EEDR))
    );
    return __result;
}
    25fa:	08 95       	ret

000025fc <eeprom_write_byte>:

/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    25fc:	9c 01       	movw	r18, r24
    do {} while (!eeprom_is_ready ());
    25fe:	e1 99       	sbic	0x1c, 1	; 28
    2600:	fe cf       	rjmp	.-4      	; 0x25fe <eeprom_write_byte+0x2>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2602:	3f bb       	out	0x1f, r19	; 31
    2604:	2e bb       	out	0x1e, r18	; 30
#endif
    EEDR = __value;
    2606:	6d bb       	out	0x1d, r22	; 29

    __asm__ __volatile__ (
    2608:	0f b6       	in	r0, 0x3f	; 63
    260a:	f8 94       	cli
    260c:	e2 9a       	sbi	0x1c, 2	; 28
    260e:	e1 9a       	sbi	0x1c, 1	; 28
    2610:	0f be       	out	0x3f, r0	; 63
          [__sreg]  "i" (_SFR_IO_ADDR(SREG)),
          [__eemwe] "i" (EEMWE),
          [__eewe]  "i" (EEWE)
        : "r0"
    );
}
    2612:	08 95       	ret

00002614 <__vector_12>:
	  strDispenserName3,
	  strDispenserName4,
	  strDispenserName5,
};

ISR(TIMER1_COMPA_vect){//Timer Overflow 1ms
    2614:	1f 92       	push	r1
    2616:	0f 92       	push	r0
    2618:	0f b6       	in	r0, 0x3f	; 63
    261a:	0f 92       	push	r0
    261c:	11 24       	eor	r1, r1
    261e:	2f 93       	push	r18
    2620:	6f 93       	push	r22
    2622:	7f 93       	push	r23
    2624:	8f 93       	push	r24
    2626:	9f 93       	push	r25
		   __sec_sign = 1;
		 }
	}
*/
	//_light_ticker();
	if(__key_light == 1){
    2628:	80 91 bf 03 	lds	r24, 0x03BF
    262c:	81 30       	cpi	r24, 0x01	; 1
    262e:	81 f4       	brne	.+32     	; 0x2650 <__vector_12+0x3c>
		__key_lgtcnt++;
    2630:	80 91 c0 03 	lds	r24, 0x03C0
    2634:	8f 5f       	subi	r24, 0xFF	; 255
    2636:	80 93 c0 03 	sts	0x03C0, r24
		if(__key_lgtcnt == 150){
    263a:	86 39       	cpi	r24, 0x96	; 150
    263c:	49 f4       	brne	.+18     	; 0x2650 <__vector_12+0x3c>
		   __key_light = 0; 
    263e:	10 92 bf 03 	sts	0x03BF, r1
		   __key_lgtcnt = 0; 
    2642:	10 92 c0 03 	sts	0x03C0, r1
		   sbi(PORTG, 1);
    2646:	80 91 65 00 	lds	r24, 0x0065
    264a:	82 60       	ori	r24, 0x02	; 2
    264c:	80 93 65 00 	sts	0x0065, r24
		   }
	}
	

	__i_timer++;
    2650:	80 91 bd 03 	lds	r24, 0x03BD
    2654:	8f 5f       	subi	r24, 0xFF	; 255
    2656:	80 93 bd 03 	sts	0x03BD, r24
	if (__i_timer > 5){
    265a:	86 30       	cpi	r24, 0x06	; 6
    265c:	30 f0       	brcs	.+12     	; 0x266a <__vector_12+0x56>
		__i_timer = 0;
    265e:	10 92 bd 03 	sts	0x03BD, r1
		PORTE = PORTE^0x04;
    2662:	83 b1       	in	r24, 0x03	; 3
    2664:	94 e0       	ldi	r25, 0x04	; 4
    2666:	89 27       	eor	r24, r25
    2668:	83 b9       	out	0x03, r24	; 3
	}
	//Beep
	if (TimBeep>0){
    266a:	80 91 d6 01 	lds	r24, 0x01D6
    266e:	90 91 d7 01 	lds	r25, 0x01D7
    2672:	00 97       	sbiw	r24, 0x00	; 0
    2674:	41 f0       	breq	.+16     	; 0x2686 <__vector_12+0x72>
	    TimBeep--;
    2676:	01 97       	sbiw	r24, 0x01	; 1
    2678:	90 93 d7 01 	sts	0x01D7, r25
    267c:	80 93 d6 01 	sts	0x01D6, r24
		DDRB=(DDRB|0b00100000);
    2680:	bd 9a       	sbi	0x17, 5	; 23
	    PORTB=(PORTB&0b11011111);
    2682:	c5 98       	cbi	0x18, 5	; 24
    2684:	05 c0       	rjmp	.+10     	; 0x2690 <__vector_12+0x7c>
	    }
	else{PORTB=(PORTB|~PORTB);
    2686:	98 b3       	in	r25, 0x18	; 24
    2688:	88 b3       	in	r24, 0x18	; 24
    268a:	80 95       	com	r24
    268c:	89 2b       	or	r24, r25
    268e:	88 bb       	out	0x18, r24	; 24
		}
    //LocalAccount
	TimLocAcc++;
    2690:	80 91 d2 01 	lds	r24, 0x01D2
    2694:	90 91 d3 01 	lds	r25, 0x01D3
    2698:	01 96       	adiw	r24, 0x01	; 1
    269a:	90 93 d3 01 	sts	0x01D3, r25
    269e:	80 93 d2 01 	sts	0x01D2, r24
	//DisplaTicker
    TimTicker++;
    26a2:	80 91 a5 01 	lds	r24, 0x01A5
    26a6:	8f 5f       	subi	r24, 0xFF	; 255
    26a8:	80 93 a5 01 	sts	0x01A5, r24
	TimPressed++;
    26ac:	20 91 a6 01 	lds	r18, 0x01A6
    26b0:	2f 5f       	subi	r18, 0xFF	; 255
    26b2:	20 93 a6 01 	sts	0x01A6, r18
	if ((TimPressed%5)==0){
    26b6:	82 2f       	mov	r24, r18
    26b8:	65 e0       	ldi	r22, 0x05	; 5
    26ba:	0e 94 7a b8 	call	0x170f4	; 0x170f4 <__udivmodqi4>
    26be:	99 23       	and	r25, r25
    26c0:	71 f4       	brne	.+28     	; 0x26de <__vector_12+0xca>
	    TimDisplay++;
    26c2:	80 91 a7 01 	lds	r24, 0x01A7
    26c6:	8f 5f       	subi	r24, 0xFF	; 255
    26c8:	80 93 a7 01 	sts	0x01A7, r24
		TimPrintBusy++;
    26cc:	80 91 cc 01 	lds	r24, 0x01CC
    26d0:	90 91 cd 01 	lds	r25, 0x01CD
    26d4:	01 96       	adiw	r24, 0x01	; 1
    26d6:	90 93 cd 01 	sts	0x01CD, r25
    26da:	80 93 cc 01 	sts	0x01CC, r24
		//FBackLight();
	}
	if ((TimPressed%PRESSED_DELAY)==0){
    26de:	82 2f       	mov	r24, r18
    26e0:	6a e0       	ldi	r22, 0x0A	; 10
    26e2:	0e 94 7a b8 	call	0x170f4	; 0x170f4 <__udivmodqi4>
    26e6:	99 23       	and	r25, r25
    26e8:	49 f4       	brne	.+18     	; 0x26fc <__vector_12+0xe8>
	     ProcTimeOut++;
    26ea:	80 91 d8 01 	lds	r24, 0x01D8
    26ee:	90 91 d9 01 	lds	r25, 0x01D9
    26f2:	01 96       	adiw	r24, 0x01	; 1
    26f4:	90 93 d9 01 	sts	0x01D9, r25
    26f8:	80 93 d8 01 	sts	0x01D8, r24
	}
	TimSend++;
    26fc:	80 91 a8 01 	lds	r24, 0x01A8
    2700:	90 91 a9 01 	lds	r25, 0x01A9
    2704:	01 96       	adiw	r24, 0x01	; 1
    2706:	90 93 a9 01 	sts	0x01A9, r25
    270a:	80 93 a8 01 	sts	0x01A8, r24
}
    270e:	9f 91       	pop	r25
    2710:	8f 91       	pop	r24
    2712:	7f 91       	pop	r23
    2714:	6f 91       	pop	r22
    2716:	2f 91       	pop	r18
    2718:	0f 90       	pop	r0
    271a:	0f be       	out	0x3f, r0	; 63
    271c:	0f 90       	pop	r0
    271e:	1f 90       	pop	r1
    2720:	18 95       	reti

00002722 <RePrintStandalone>:

char RePrintStandalone(char FIPAddr){
     char Result=PS_NONE;

   return Result;
}
    2722:	86 e1       	ldi	r24, 0x16	; 22
    2724:	08 95       	ret

00002726 <GetPumpStatusLabel>:


char GetPumpStatusLabel(char xPumpStatus){
     char Result;

	 switch(xPumpStatus){
    2726:	e8 2f       	mov	r30, r24
    2728:	f0 e0       	ldi	r31, 0x00	; 0
    272a:	ee 31       	cpi	r30, 0x1E	; 30
    272c:	f1 05       	cpc	r31, r1
    272e:	70 f5       	brcc	.+92     	; 0x278c <GetPumpStatusLabel+0x66>
    2730:	ea 5b       	subi	r30, 0xBA	; 186
    2732:	ff 4f       	sbci	r31, 0xFF	; 255
    2734:	ee 0f       	add	r30, r30
    2736:	ff 1f       	adc	r31, r31
    2738:	05 90       	lpm	r0, Z+
    273a:	f4 91       	lpm	r31, Z+
    273c:	e0 2d       	mov	r30, r0
    273e:	09 94       	ijmp
    2740:	81 e3       	ldi	r24, 0x31	; 49
    2742:	08 95       	ret
    2744:	85 e4       	ldi	r24, 0x45	; 69
    2746:	08 95       	ret
    2748:	82 e3       	ldi	r24, 0x32	; 50
    274a:	08 95       	ret
	 case PUMP_ST1: 
	      Result='1';
		  break;
	 case PUMP_ST2: 
	 	  Result='2';
		  break;
    274c:	83 e3       	ldi	r24, 0x33	; 51
    274e:	08 95       	ret
     case PUMP_ST3:
	 	  Result='3';
		  break;	
    2750:	84 e3       	ldi	r24, 0x34	; 52
    2752:	08 95       	ret
	 case PUMP_ST4: 
          Result='4';
		  break;
    2754:	85 e3       	ldi	r24, 0x35	; 53
    2756:	08 95       	ret
	 case PUMP_ST5: 
	 	  Result='5';
		  break;
    2758:	89 e6       	ldi	r24, 0x69	; 105
    275a:	08 95       	ret
	 case PUMP_OFF: 
	 case PW_ONLINE:
	 	  Result='i';
		  break;
    275c:	8e e6       	ldi	r24, 0x6E	; 110
    275e:	08 95       	ret
     case PW_CALL:
	 case PUMP_CALL: 
	 	  Result='n';
		  break;     
    2760:	81 e6       	ldi	r24, 0x61	; 97
    2762:	08 95       	ret
	 case PUMP_AUTH: 
	 	  Result='a';
		  break;
    2764:	84 e6       	ldi	r24, 0x64	; 100
    2766:	08 95       	ret
     case PW_AUTHORIZED:
	 case PUMP_BUSY: 
	 	  Result='d';
		  break;
    2768:	8f e4       	ldi	r24, 0x4F	; 79
    276a:	08 95       	ret
	 case PUMP_PEOT: 
	 	  Result='O';
		  break;
    276c:	86 e4       	ldi	r24, 0x46	; 70
    276e:	08 95       	ret
     case PW_END_DELIVERY:
	 case PUMP_FEOT: 
	 	  Result='F';
		  break;
    2770:	83 e5       	ldi	r24, 0x53	; 83
    2772:	08 95       	ret
	 case PUMP_STOP: 
	 	  Result='S';
		  break;
    2774:	8d e2       	ldi	r24, 0x2D	; 45
    2776:	08 95       	ret
	 case PUMP_NONE:
	 case PW_DISCONNECT:
	 	  Result='-';
		  break;
    2778:	80 e5       	ldi	r24, 0x50	; 80
    277a:	08 95       	ret
     case PS_PRINT_READY:
	      Result='P';
 	      break;
    277c:	89 e4       	ldi	r24, 0x49	; 73
    277e:	08 95       	ret
     case PS_PRINTED:
	      Result='I';
 	      break;
    2780:	86 e5       	ldi	r24, 0x56	; 86
    2782:	08 95       	ret
     case PS_VOID:
	      Result='V';
	      break;
    2784:	84 e5       	ldi	r24, 0x54	; 84
    2786:	08 95       	ret
     case PS_TOTALIZER:
	      Result='T';
	      break;
    2788:	84 e7       	ldi	r24, 0x74	; 116
    278a:	08 95       	ret
     case PS_FINISH_TOTALIZER:
	      Result='t';
	      break;
    278c:	88 e7       	ldi	r24, 0x78	; 120
	 default:
          Result='x';
		  break;         	 
	 }
  return Result;	 
}
    278e:	08 95       	ret

00002790 <SendPoolingCommand>:
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    2790:	80 93 8a 07 	sts	0x078A, r24
	 PoolMsg=plMsg;
    2794:	60 93 ae 0d 	sts	0x0DAE, r22
     IsControlPooling=True;
    2798:	81 e0       	ldi	r24, 0x01	; 1
    279a:	80 93 97 01 	sts	0x0197, r24
}
    279e:	08 95       	ret

000027a0 <ScanEDCFlow>:
	 RemZeroLead(strMsgID);
	 Result=atoi(strMsgID);
  return Result;
}

void ScanEDCFlow(char data){
    27a0:	28 2f       	mov	r18, r24
     char i;

	 //_uart(0,1,data);

     //EDC-MSG
     if (data==0x02){
    27a2:	82 30       	cpi	r24, 0x02	; 2
    27a4:	39 f4       	brne	.+14     	; 0x27b4 <ScanEDCFlow+0x14>
	     IsEDCFlow=True;
    27a6:	81 e0       	ldi	r24, 0x01	; 1
    27a8:	80 93 b1 03 	sts	0x03B1, r24
		 nFlow=0;
    27ac:	10 92 af 03 	sts	0x03AF, r1
    27b0:	10 92 ae 03 	sts	0x03AE, r1
	 }//FillMessage
     if (IsEDCFlow==True){
    27b4:	80 91 b1 03 	lds	r24, 0x03B1
    27b8:	81 30       	cpi	r24, 0x01	; 1
    27ba:	69 f4       	brne	.+26     	; 0x27d6 <ScanEDCFlow+0x36>
	     rcv_trans[nFlow]=data;
    27bc:	80 91 ae 03 	lds	r24, 0x03AE
    27c0:	90 91 af 03 	lds	r25, 0x03AF
    27c4:	fc 01       	movw	r30, r24
    27c6:	eb 50       	subi	r30, 0x0B	; 11
    27c8:	f5 4f       	sbci	r31, 0xF5	; 245
    27ca:	20 83       	st	Z, r18
		 nFlow++;
    27cc:	01 96       	adiw	r24, 0x01	; 1
    27ce:	90 93 af 03 	sts	0x03AF, r25
    27d2:	80 93 ae 03 	sts	0x03AE, r24
	 }//CloseMessage
	 if ((data==0x03)||(nFlow>=MSG03_LENGTH)){
    27d6:	23 30       	cpi	r18, 0x03	; 3
    27d8:	41 f0       	breq	.+16     	; 0x27ea <ScanEDCFlow+0x4a>
    27da:	80 91 ae 03 	lds	r24, 0x03AE
    27de:	90 91 af 03 	lds	r25, 0x03AF
    27e2:	8d 34       	cpi	r24, 0x4D	; 77
    27e4:	91 05       	cpc	r25, r1
    27e6:	08 f4       	brcc	.+2      	; 0x27ea <ScanEDCFlow+0x4a>
    27e8:	9b c0       	rjmp	.+310    	; 0x2920 <ScanEDCFlow+0x180>
	     //for(i=0;i<nFlow;i++){_uart(0,1,rcv_trans[i]);}
	     IsEDCFlow=False;
    27ea:	10 92 b1 03 	sts	0x03B1, r1
		 EDCMsgCode=((rcv_trans[1]-'0')*10)+(rcv_trans[2]-'0');
    27ee:	30 91 f7 0a 	lds	r19, 0x0AF7
    27f2:	30 51       	subi	r19, 0x10	; 16
    27f4:	80 91 f6 0a 	lds	r24, 0x0AF6
    27f8:	2a e0       	ldi	r18, 0x0A	; 10
    27fa:	82 9f       	mul	r24, r18
    27fc:	c0 01       	movw	r24, r0
    27fe:	11 24       	eor	r1, r1
    2800:	38 0f       	add	r19, r24
    2802:	30 93 b0 03 	sts	0x03B0, r19

		 if (EDCMsgCode==0x03){
    2806:	33 30       	cpi	r19, 0x03	; 3
    2808:	09 f0       	breq	.+2      	; 0x280c <ScanEDCFlow+0x6c>
    280a:	65 c0       	rjmp	.+202    	; 0x28d6 <ScanEDCFlow+0x136>
    280c:	e8 ef       	ldi	r30, 0xF8	; 248
    280e:	fa e0       	ldi	r31, 0x0A	; 10
    2810:	a1 e6       	ldi	r26, 0x61	; 97
    2812:	be e0       	ldi	r27, 0x0E	; 14
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2814:	81 91       	ld	r24, Z+
    2816:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2818:	8a e0       	ldi	r24, 0x0A	; 10
    281a:	ee 3f       	cpi	r30, 0xFE	; 254
    281c:	f8 07       	cpc	r31, r24
    281e:	d1 f7       	brne	.-12     	; 0x2814 <ScanEDCFlow+0x74>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2820:	10 92 67 0e 	sts	0x0E67, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2824:	80 81       	ld	r24, Z
    2826:	80 93 9c 09 	sts	0x099C, r24
    282a:	81 81       	ldd	r24, Z+1	; 0x01
    282c:	80 93 9d 09 	sts	0x099D, r24
	 }Dest[Length]=0;
    2830:	10 92 9e 09 	sts	0x099E, r1
    2834:	32 96       	adiw	r30, 0x02	; 2
    2836:	ad e7       	ldi	r26, 0x7D	; 125
    2838:	be e0       	ldi	r27, 0x0E	; 14
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    283a:	81 91       	ld	r24, Z+
    283c:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    283e:	8b e0       	ldi	r24, 0x0B	; 11
    2840:	ef 30       	cpi	r30, 0x0F	; 15
    2842:	f8 07       	cpc	r31, r24
    2844:	d1 f7       	brne	.-12     	; 0x283a <ScanEDCFlow+0x9a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2846:	10 92 8c 0e 	sts	0x0E8C, r1
    284a:	a1 e6       	ldi	r26, 0x61	; 97
    284c:	bd e0       	ldi	r27, 0x0D	; 13
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    284e:	81 91       	ld	r24, Z+
    2850:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2852:	8b e0       	ldi	r24, 0x0B	; 11
    2854:	e2 32       	cpi	r30, 0x22	; 34
    2856:	f8 07       	cpc	r31, r24
    2858:	d1 f7       	brne	.-12     	; 0x284e <ScanEDCFlow+0xae>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    285a:	10 92 74 0d 	sts	0x0D74, r1
    285e:	20 e0       	ldi	r18, 0x00	; 0
    2860:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2862:	f9 01       	movw	r30, r18
    2864:	ec 51       	subi	r30, 0x1C	; 28
    2866:	f6 4f       	sbci	r31, 0xF6	; 246
    2868:	d9 01       	movw	r26, r18
    286a:	ab 50       	subi	r26, 0x0B	; 11
    286c:	b5 4f       	sbci	r27, 0xF5	; 245
    286e:	9d 96       	adiw	r26, 0x2d	; 45
    2870:	8c 91       	ld	r24, X
    2872:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2874:	2f 5f       	subi	r18, 0xFF	; 255
    2876:	3f 4f       	sbci	r19, 0xFF	; 255
    2878:	26 30       	cpi	r18, 0x06	; 6
    287a:	31 05       	cpc	r19, r1
    287c:	91 f7       	brne	.-28     	; 0x2862 <ScanEDCFlow+0xc2>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    287e:	10 92 ea 09 	sts	0x09EA, r1
    2882:	20 e0       	ldi	r18, 0x00	; 0
    2884:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2886:	f9 01       	movw	r30, r18
    2888:	ea 5c       	subi	r30, 0xCA	; 202
    288a:	f6 4f       	sbci	r31, 0xF6	; 246
    288c:	d9 01       	movw	r26, r18
    288e:	ab 50       	subi	r26, 0x0B	; 11
    2890:	b5 4f       	sbci	r27, 0xF5	; 245
    2892:	d3 96       	adiw	r26, 0x33	; 51
    2894:	8c 91       	ld	r24, X
    2896:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2898:	2f 5f       	subi	r18, 0xFF	; 255
    289a:	3f 4f       	sbci	r19, 0xFF	; 255
    289c:	2a 30       	cpi	r18, 0x0A	; 10
    289e:	31 05       	cpc	r19, r1
    28a0:	91 f7       	brne	.-28     	; 0x2886 <ScanEDCFlow+0xe6>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    28a2:	10 92 40 09 	sts	0x0940, r1
    28a6:	20 e0       	ldi	r18, 0x00	; 0
    28a8:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    28aa:	f9 01       	movw	r30, r18
    28ac:	e9 56       	subi	r30, 0x69	; 105
    28ae:	f2 4f       	sbci	r31, 0xF2	; 242
    28b0:	d9 01       	movw	r26, r18
    28b2:	ab 50       	subi	r26, 0x0B	; 11
    28b4:	b5 4f       	sbci	r27, 0xF5	; 245
    28b6:	dd 96       	adiw	r26, 0x3d	; 61
    28b8:	8c 91       	ld	r24, X
    28ba:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    28bc:	2f 5f       	subi	r18, 0xFF	; 255
    28be:	3f 4f       	sbci	r19, 0xFF	; 255
    28c0:	2e 30       	cpi	r18, 0x0E	; 14
    28c2:	31 05       	cpc	r19, r1
    28c4:	91 f7       	brne	.-28     	; 0x28aa <ScanEDCFlow+0x10a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    28c6:	10 92 a5 0d 	sts	0x0DA5, r1
             StrPosCopy(rcv_trans,strCardType,11,15);
             StrPosCopy(rcv_trans,strCardID,26,19);
             StrPosCopy(rcv_trans,strApprovalCode,45,6);
             StrPosCopy(rcv_trans,strInvoiceNumber,51,10);
             StrPosCopy(rcv_trans,strDateTime,61,14);
		     IsEDCApproved=True;//Sending Message 92
    28ca:	81 e0       	ldi	r24, 0x01	; 1
    28cc:	80 93 b0 01 	sts	0x01B0, r24
			 IsPrintApprovalCode=True;
    28d0:	80 93 b1 01 	sts	0x01B1, r24
    28d4:	08 95       	ret
	    }else
		 if (EDCMsgCode==0x04){
    28d6:	34 30       	cpi	r19, 0x04	; 4
    28d8:	19 f5       	brne	.+70     	; 0x2920 <ScanEDCFlow+0x180>
    28da:	e8 ef       	ldi	r30, 0xF8	; 248
    28dc:	fa e0       	ldi	r31, 0x0A	; 10
    28de:	a4 ee       	ldi	r26, 0xE4	; 228
    28e0:	b9 e0       	ldi	r27, 0x09	; 9
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    28e2:	81 91       	ld	r24, Z+
    28e4:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    28e6:	8a e0       	ldi	r24, 0x0A	; 10
    28e8:	ee 3f       	cpi	r30, 0xFE	; 254
    28ea:	f8 07       	cpc	r31, r24
    28ec:	d1 f7       	brne	.-12     	; 0x28e2 <ScanEDCFlow+0x142>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    28ee:	10 92 ea 09 	sts	0x09EA, r1
    28f2:	a6 e3       	ldi	r26, 0x36	; 54
    28f4:	b9 e0       	ldi	r27, 0x09	; 9
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    28f6:	81 91       	ld	r24, Z+
    28f8:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    28fa:	8b e0       	ldi	r24, 0x0B	; 11
    28fc:	e8 30       	cpi	r30, 0x08	; 8
    28fe:	f8 07       	cpc	r31, r24
    2900:	d1 f7       	brne	.-12     	; 0x28f6 <ScanEDCFlow+0x156>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2902:	10 92 40 09 	sts	0x0940, r1
    2906:	a7 e9       	ldi	r26, 0x97	; 151
    2908:	bd e0       	ldi	r27, 0x0D	; 13
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    290a:	81 91       	ld	r24, Z+
    290c:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    290e:	8b e0       	ldi	r24, 0x0B	; 11
    2910:	e6 31       	cpi	r30, 0x16	; 22
    2912:	f8 07       	cpc	r31, r24
    2914:	d1 f7       	brne	.-12     	; 0x290a <ScanEDCFlow+0x16a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2916:	10 92 a5 0d 	sts	0x0DA5, r1
	    }else
		 if (EDCMsgCode==0x04){
             StrPosCopy(rcv_trans,strApprovalCode,3,6);
             StrPosCopy(rcv_trans,strInvoiceNumber,9,10);
             StrPosCopy(rcv_trans,strDateTime,19,14);
			 IsVoidTransaction=True;
    291a:	81 e0       	ldi	r24, 0x01	; 1
    291c:	80 93 b2 01 	sts	0x01B2, r24
    2920:	08 95       	ret

00002922 <ScanHiddenKeyFlow>:
	    }
    }//MSGDetection
}

void ScanHiddenKeyFlow(char KeyIn){
}
    2922:	08 95       	ret

00002924 <ScanRFIDFlow>:


void ScanRFIDFlow(char data){//                   12 11 10 9  8  7  6  5  4  3  2  1  0
    2924:	98 2f       	mov	r25, r24
    2926:	e4 e7       	ldi	r30, 0x74	; 116
    2928:	fa e0       	ldi	r31, 0x0A	; 10
     char i=0,strSerial[20]; //Shift Data Serial; 02 32 33 44 31 30 41 36 43 0D 0A 0A 03 
	                                                //2 50 51 65 68 68 68 54 67 13 10 3

	 for(i=0;i<19;i++){
        strSerialFlow[19-i]=strSerialFlow[18-i];   
    292a:	80 81       	ld	r24, Z
    292c:	81 83       	std	Z+1, r24	; 0x01
    292e:	31 97       	sbiw	r30, 0x01	; 1

void ScanRFIDFlow(char data){//                   12 11 10 9  8  7  6  5  4  3  2  1  0
     char i=0,strSerial[20]; //Shift Data Serial; 02 32 33 44 31 30 41 36 43 0D 0A 0A 03 
	                                                //2 50 51 65 68 68 68 54 67 13 10 3

	 for(i=0;i<19;i++){
    2930:	8a e0       	ldi	r24, 0x0A	; 10
    2932:	e1 36       	cpi	r30, 0x61	; 97
    2934:	f8 07       	cpc	r31, r24
    2936:	c9 f7       	brne	.-14     	; 0x292a <ScanRFIDFlow+0x6>
        strSerialFlow[19-i]=strSerialFlow[18-i];   
	 }  strSerialFlow[0]=data;
    2938:	9f 01       	movw	r18, r30
    293a:	2f 5f       	subi	r18, 0xFF	; 255
    293c:	3f 4f       	sbci	r19, 0xFF	; 255
    293e:	91 83       	std	Z+1, r25	; 0x01
	 //Detection
	 if ((strSerialFlow[11]==0x02)&&(strSerialFlow[1]==0x0A)&&(strSerialFlow[0]==0x03)){
    2940:	84 85       	ldd	r24, Z+12	; 0x0c
    2942:	82 30       	cpi	r24, 0x02	; 2
    2944:	f9 f4       	brne	.+62     	; 0x2984 <ScanRFIDFlow+0x60>
    2946:	80 91 63 0a 	lds	r24, 0x0A63
    294a:	8a 30       	cpi	r24, 0x0A	; 10
    294c:	d9 f4       	brne	.+54     	; 0x2984 <ScanRFIDFlow+0x60>
    294e:	93 30       	cpi	r25, 0x03	; 3
    2950:	c9 f4       	brne	.+50     	; 0x2984 <ScanRFIDFlow+0x60>
    2952:	f9 01       	movw	r30, r18
    2954:	3a 96       	adiw	r30, 0x0a	; 10
    2956:	ac e2       	ldi	r26, 0x2C	; 44
    2958:	be e0       	ldi	r27, 0x0E	; 14
		for(i=0;i<8;i++) strRFID[i]=strSerialFlow[10-i];
    295a:	80 81       	ld	r24, Z
    295c:	8d 93       	st	X+, r24
    295e:	31 97       	sbiw	r30, 0x01	; 1
    2960:	8a e0       	ldi	r24, 0x0A	; 10
    2962:	e4 36       	cpi	r30, 0x64	; 100
    2964:	f8 07       	cpc	r31, r24
    2966:	c9 f7       	brne	.-14     	; 0x295a <ScanRFIDFlow+0x36>
        strRFID[8]=0;
    2968:	10 92 34 0e 	sts	0x0E34, r1
	    IsRFIDDetected=True;
    296c:	81 e0       	ldi	r24, 0x01	; 1
    296e:	80 93 af 01 	sts	0x01AF, r24
     }      
}

void BackLightTrig(){
     //TimBackLight=0;
__key_light = 1; __key_lgtcnt = 0; PORTG=PORTG&0b11111101;
    2972:	80 93 bf 03 	sts	0x03BF, r24
    2976:	10 92 c0 03 	sts	0x03C0, r1
    297a:	80 91 65 00 	lds	r24, 0x0065
    297e:	8d 7f       	andi	r24, 0xFD	; 253
    2980:	80 93 65 00 	sts	0x0065, r24
    2984:	08 95       	ret

00002986 <__vector_18>:
	if (IFType==IT_SLAVE)ScanEDCFlow(dataSPI);
	else
	if (IFType==IT_STANDALONE)ScanStandaloneFlow(dataSPI);
}

ISR(USART0_RX_vect){
    2986:	1f 92       	push	r1
    2988:	0f 92       	push	r0
    298a:	0f b6       	in	r0, 0x3f	; 63
    298c:	0f 92       	push	r0
    298e:	11 24       	eor	r1, r1
    2990:	8f 93       	push	r24
    2992:	9f 93       	push	r25
	char dataRX0,IsSPI=False;
	dataRX0= UDR0;
    2994:	9c b1       	in	r25, 0x0c	; 12
	//PrintBusyDetection
	if ((IsBusyIdlePrinting==True)||(IsBusyFreePrinting==True)){
    2996:	80 91 c8 01 	lds	r24, 0x01C8
    299a:	81 30       	cpi	r24, 0x01	; 1
    299c:	21 f0       	breq	.+8      	; 0x29a6 <__vector_18+0x20>
    299e:	80 91 ca 01 	lds	r24, 0x01CA
    29a2:	81 30       	cpi	r24, 0x01	; 1
    29a4:	51 f4       	brne	.+20     	; 0x29ba <__vector_18+0x34>
	    if (dataRX0==19)IsBusyPrint=True;
    29a6:	93 31       	cpi	r25, 0x13	; 19
    29a8:	21 f4       	brne	.+8      	; 0x29b2 <__vector_18+0x2c>
    29aa:	81 e0       	ldi	r24, 0x01	; 1
    29ac:	80 93 c9 01 	sts	0x01C9, r24
    29b0:	04 c0       	rjmp	.+8      	; 0x29ba <__vector_18+0x34>
		else 
	    if (dataRX0==17)IsBusyPrint=False;	
    29b2:	91 31       	cpi	r25, 0x11	; 17
    29b4:	11 f4       	brne	.+4      	; 0x29ba <__vector_18+0x34>
    29b6:	10 92 c9 01 	sts	0x01C9, r1
	}
}
    29ba:	9f 91       	pop	r25
    29bc:	8f 91       	pop	r24
    29be:	0f 90       	pop	r0
    29c0:	0f be       	out	0x3f, r0	; 63
    29c2:	0f 90       	pop	r0
    29c4:	1f 90       	pop	r1
    29c6:	18 95       	reti

000029c8 <ScanCommand>:

char ScanCommand(char *strFlow,char *fCommand){
     char Result;
	 Result=False;
   return Result;
}
    29c8:	80 e0       	ldi	r24, 0x00	; 0
    29ca:	08 95       	ret

000029cc <ConfigProtocol>:
	 }
	 _uart_printf(1,1,PSTR(">"));
	 //End
}

void ConfigProtocol(char dataIn){
    29cc:	28 2f       	mov	r18, r24
     static char Conflow[7];
    //Configuration Data Request 
	if ((Conflow[6]=='i')&&(Conflow[5]=='C')&&(Conflow[4]=='o')&&(Conflow[3]=='n')&&(Conflow[2]=='f')&&(Conflow[1]=='?')&&(Conflow[0]==0x0D)&&(dataIn==0x0A)){
    29ce:	80 91 ac 03 	lds	r24, 0x03AC
    29d2:	89 36       	cpi	r24, 0x69	; 105
    29d4:	e9 f4       	brne	.+58     	; 0x2a10 <ConfigProtocol+0x44>
    29d6:	80 91 ab 03 	lds	r24, 0x03AB
    29da:	83 34       	cpi	r24, 0x43	; 67
    29dc:	c9 f4       	brne	.+50     	; 0x2a10 <ConfigProtocol+0x44>
    29de:	80 91 aa 03 	lds	r24, 0x03AA
    29e2:	8f 36       	cpi	r24, 0x6F	; 111
    29e4:	a9 f4       	brne	.+42     	; 0x2a10 <ConfigProtocol+0x44>
    29e6:	80 91 a9 03 	lds	r24, 0x03A9
    29ea:	8e 36       	cpi	r24, 0x6E	; 110
    29ec:	89 f4       	brne	.+34     	; 0x2a10 <ConfigProtocol+0x44>
    29ee:	80 91 a8 03 	lds	r24, 0x03A8
    29f2:	86 36       	cpi	r24, 0x66	; 102
    29f4:	69 f4       	brne	.+26     	; 0x2a10 <ConfigProtocol+0x44>
    29f6:	80 91 a7 03 	lds	r24, 0x03A7
    29fa:	8f 33       	cpi	r24, 0x3F	; 63
    29fc:	49 f4       	brne	.+18     	; 0x2a10 <ConfigProtocol+0x44>
    29fe:	80 91 a6 03 	lds	r24, 0x03A6
    2a02:	8d 30       	cpi	r24, 0x0D	; 13
    2a04:	29 f4       	brne	.+10     	; 0x2a10 <ConfigProtocol+0x44>
    2a06:	2a 30       	cpi	r18, 0x0A	; 10
    2a08:	19 f4       	brne	.+6      	; 0x2a10 <ConfigProtocol+0x44>
	     //SendConfigParamater();        
		 ConfigCommand=CC_SEND_CONFIG;
    2a0a:	82 e0       	ldi	r24, 0x02	; 2
    2a0c:	80 93 c6 01 	sts	0x01C6, r24
	}

	if (IsConfigFlow==True){        
    2a10:	80 91 98 01 	lds	r24, 0x0198
    2a14:	81 30       	cpi	r24, 0x01	; 1
    2a16:	69 f4       	brne	.+26     	; 0x2a32 <ConfigProtocol+0x66>
	    rcv_trans[char_count]=dataIn;
    2a18:	80 91 9c 01 	lds	r24, 0x019C
    2a1c:	90 91 9d 01 	lds	r25, 0x019D
    2a20:	fc 01       	movw	r30, r24
    2a22:	eb 50       	subi	r30, 0x0B	; 11
    2a24:	f5 4f       	sbci	r31, 0xF5	; 245
    2a26:	20 83       	st	Z, r18
	    char_count++; 
    2a28:	01 96       	adiw	r24, 0x01	; 1
    2a2a:	90 93 9d 01 	sts	0x019D, r25
    2a2e:	80 93 9c 01 	sts	0x019C, r24
	}
	if ((Conflow[0]==0x04)&&(dataIn==0x40)){
    2a32:	80 91 a6 03 	lds	r24, 0x03A6
    2a36:	84 30       	cpi	r24, 0x04	; 4
    2a38:	51 f4       	brne	.+20     	; 0x2a4e <ConfigProtocol+0x82>
    2a3a:	20 34       	cpi	r18, 0x40	; 64
    2a3c:	e9 f4       	brne	.+58     	; 0x2a78 <ConfigProtocol+0xac>
	     IsConfigFlow=True;
    2a3e:	81 e0       	ldi	r24, 0x01	; 1
    2a40:	80 93 98 01 	sts	0x0198, r24
		 char_count=0;
    2a44:	10 92 9d 01 	sts	0x019D, r1
    2a48:	10 92 9c 01 	sts	0x019C, r1
    2a4c:	15 c0       	rjmp	.+42     	; 0x2a78 <ConfigProtocol+0xac>
	}
	//SavingData
	if ((Conflow[0]==0x05)&&(dataIn==0x50)){
    2a4e:	85 30       	cpi	r24, 0x05	; 5
    2a50:	99 f4       	brne	.+38     	; 0x2a78 <ConfigProtocol+0xac>
    2a52:	20 35       	cpi	r18, 0x50	; 80
    2a54:	89 f4       	brne	.+34     	; 0x2a78 <ConfigProtocol+0xac>
	     transLength=char_count;
    2a56:	80 91 9c 01 	lds	r24, 0x019C
    2a5a:	90 91 9d 01 	lds	r25, 0x019D
    2a5e:	90 93 9f 01 	sts	0x019F, r25
    2a62:	80 93 9e 01 	sts	0x019E, r24
		 char_count=0;
    2a66:	10 92 9d 01 	sts	0x019D, r1
    2a6a:	10 92 9c 01 	sts	0x019C, r1
	     IsConfigFlow=False;
    2a6e:	10 92 98 01 	sts	0x0198, r1
		 ConfigCommand=CC_SAVE_CONFIG;
    2a72:	81 e0       	ldi	r24, 0x01	; 1
    2a74:	80 93 c6 01 	sts	0x01C6, r24
		 //SaveConfigParameter();
	}

	//Shifting
	Conflow[6]=Conflow[5];
    2a78:	80 91 ab 03 	lds	r24, 0x03AB
    2a7c:	80 93 ac 03 	sts	0x03AC, r24
	Conflow[5]=Conflow[4];
    2a80:	80 91 aa 03 	lds	r24, 0x03AA
    2a84:	80 93 ab 03 	sts	0x03AB, r24
	Conflow[4]=Conflow[3];
    2a88:	80 91 a9 03 	lds	r24, 0x03A9
    2a8c:	80 93 aa 03 	sts	0x03AA, r24
	Conflow[3]=Conflow[2];
    2a90:	80 91 a8 03 	lds	r24, 0x03A8
    2a94:	80 93 a9 03 	sts	0x03A9, r24
	Conflow[2]=Conflow[1];
    2a98:	80 91 a7 03 	lds	r24, 0x03A7
    2a9c:	80 93 a8 03 	sts	0x03A8, r24
	Conflow[1]=Conflow[0];
    2aa0:	80 91 a6 03 	lds	r24, 0x03A6
    2aa4:	80 93 a7 03 	sts	0x03A7, r24
	Conflow[0]=dataIn;
    2aa8:	20 93 a6 03 	sts	0x03A6, r18

}
    2aac:	08 95       	ret

00002aae <system_beep>:
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    2aae:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    2ab0:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    2ab2:	90 93 d7 01 	sts	0x01D7, r25
    2ab6:	80 93 d6 01 	sts	0x01D6, r24
}
    2aba:	08 95       	ret

00002abc <systemRestart>:
	 iRestart=0;
	 while(iRestart<100){
	       strRestart[iRestart]=iRestart;
	       iRestart++;	 
	 }
}
    2abc:	08 95       	ret

00002abe <Low>:

char Low(char X){
     char Result;
	 Result=(0x0F&X);
	 return Result;
}
    2abe:	8f 70       	andi	r24, 0x0F	; 15
    2ac0:	08 95       	ret

00002ac2 <High>:
char High(char X){
     char Result;
	 Result=((X>>4)&(0x0F));
	 return Result;
}
    2ac2:	82 95       	swap	r24
    2ac4:	8f 70       	andi	r24, 0x0F	; 15
    2ac6:	08 95       	ret

00002ac8 <Str>:
char Str(char H){
    2ac8:	98 2f       	mov	r25, r24
unsigned char Conv=0;
        if ((H>=0)&&(H<=9)) Conv='0'+H;
    2aca:	8a 30       	cpi	r24, 0x0A	; 10
    2acc:	10 f4       	brcc	.+4      	; 0x2ad2 <Str+0xa>
    2ace:	80 5d       	subi	r24, 0xD0	; 208
    2ad0:	08 95       	ret
        else
        if ((H>=0x0A)&&(H<=0x0F)) Conv='A'+(H-10);    
    2ad2:	8a 50       	subi	r24, 0x0A	; 10
    2ad4:	86 30       	cpi	r24, 0x06	; 6
    2ad6:	10 f0       	brcs	.+4      	; 0x2adc <Str+0x14>
    2ad8:	80 e0       	ldi	r24, 0x00	; 0
    2ada:	08 95       	ret
    2adc:	89 2f       	mov	r24, r25
    2ade:	89 5c       	subi	r24, 0xC9	; 201
        return (Conv);
}
    2ae0:	08 95       	ret

00002ae2 <charToHex>:

void charToHex(char X, char *Result){
    2ae2:	28 2f       	mov	r18, r24
    2ae4:	fb 01       	movw	r30, r22
	 Result=(0x0F&X);
	 return Result;
}
char High(char X){
     char Result;
	 Result=((X>>4)&(0x0F));
    2ae6:	98 2f       	mov	r25, r24
    2ae8:	92 95       	swap	r25
    2aea:	9f 70       	andi	r25, 0x0F	; 15
	 return Result;
}
char Str(char H){
unsigned char Conv=0;
        if ((H>=0)&&(H<=9)) Conv='0'+H;
    2aec:	9a 30       	cpi	r25, 0x0A	; 10
    2aee:	18 f4       	brcc	.+6      	; 0x2af6 <charToHex+0x14>
    2af0:	89 2f       	mov	r24, r25
    2af2:	80 5d       	subi	r24, 0xD0	; 208
    2af4:	08 c0       	rjmp	.+16     	; 0x2b06 <charToHex+0x24>
        else
        if ((H>=0x0A)&&(H<=0x0F)) Conv='A'+(H-10);    
    2af6:	89 2f       	mov	r24, r25
    2af8:	8a 50       	subi	r24, 0x0A	; 10
    2afa:	86 30       	cpi	r24, 0x06	; 6
    2afc:	10 f0       	brcs	.+4      	; 0x2b02 <charToHex+0x20>
    2afe:	80 e0       	ldi	r24, 0x00	; 0
    2b00:	02 c0       	rjmp	.+4      	; 0x2b06 <charToHex+0x24>
    2b02:	89 2f       	mov	r24, r25
    2b04:	89 5c       	subi	r24, 0xC9	; 201
        return (Conv);
}

void charToHex(char X, char *Result){
     Result[0]=Str(High(X));
    2b06:	80 83       	st	Z, r24
	lcd_print(1,1,lcdteks);
}

char Low(char X){
     char Result;
	 Result=(0x0F&X);
    2b08:	92 2f       	mov	r25, r18
    2b0a:	9f 70       	andi	r25, 0x0F	; 15
	 Result=((X>>4)&(0x0F));
	 return Result;
}
char Str(char H){
unsigned char Conv=0;
        if ((H>=0)&&(H<=9)) Conv='0'+H;
    2b0c:	9a 30       	cpi	r25, 0x0A	; 10
    2b0e:	18 f4       	brcc	.+6      	; 0x2b16 <charToHex+0x34>
    2b10:	89 2f       	mov	r24, r25
    2b12:	80 5d       	subi	r24, 0xD0	; 208
    2b14:	08 c0       	rjmp	.+16     	; 0x2b26 <charToHex+0x44>
        else
        if ((H>=0x0A)&&(H<=0x0F)) Conv='A'+(H-10);    
    2b16:	89 2f       	mov	r24, r25
    2b18:	8a 50       	subi	r24, 0x0A	; 10
    2b1a:	86 30       	cpi	r24, 0x06	; 6
    2b1c:	10 f0       	brcs	.+4      	; 0x2b22 <charToHex+0x40>
    2b1e:	80 e0       	ldi	r24, 0x00	; 0
    2b20:	02 c0       	rjmp	.+4      	; 0x2b26 <charToHex+0x44>
    2b22:	89 2f       	mov	r24, r25
    2b24:	89 5c       	subi	r24, 0xC9	; 201
        return (Conv);
}

void charToHex(char X, char *Result){
     Result[0]=Str(High(X));
	 Result[1]=Str(Low(X));
    2b26:	81 83       	std	Z+1, r24	; 0x01
	 Result[2]=0;
    2b28:	12 82       	std	Z+2, r1	; 0x02
	 
}
    2b2a:	08 95       	ret

00002b2c <strToInt>:

char strToInt(char *str){
    2b2c:	fc 01       	movw	r30, r24
     char Result;
     Result=(((str[0]-'0')*10) +(str[0]-'0'));
    2b2e:	80 81       	ld	r24, Z
    2b30:	2a e0       	ldi	r18, 0x0A	; 10
    2b32:	82 9f       	mul	r24, r18
    2b34:	90 01       	movw	r18, r0
    2b36:	11 24       	eor	r1, r1
    2b38:	80 51       	subi	r24, 0x10	; 16
	 return Result;
}
    2b3a:	82 0f       	add	r24, r18
    2b3c:	08 95       	ret

00002b3e <intToStr>:

void intToStr(char X, char *str){
    2b3e:	58 2f       	mov	r21, r24
    2b40:	fb 01       	movw	r30, r22
     char R,P,S;
	 R=X/100;
    2b42:	64 e6       	ldi	r22, 0x64	; 100
    2b44:	0e 94 7a b8 	call	0x170f4	; 0x170f4 <__udivmodqi4>
    2b48:	a8 2f       	mov	r26, r24
	 P=(X%100)/10;
    2b4a:	85 2f       	mov	r24, r21
    2b4c:	0e 94 7a b8 	call	0x170f4	; 0x170f4 <__udivmodqi4>
    2b50:	89 2f       	mov	r24, r25
    2b52:	6a e0       	ldi	r22, 0x0A	; 10
    2b54:	0e 94 7a b8 	call	0x170f4	; 0x170f4 <__udivmodqi4>
    2b58:	48 2f       	mov	r20, r24
	 S=X-(R*100)-(P*10);
    2b5a:	8c e9       	ldi	r24, 0x9C	; 156
    2b5c:	9f ef       	ldi	r25, 0xFF	; 255
    2b5e:	a8 9f       	mul	r26, r24
    2b60:	80 2d       	mov	r24, r0
    2b62:	11 24       	eor	r1, r1
    2b64:	85 0f       	add	r24, r21
    2b66:	26 ef       	ldi	r18, 0xF6	; 246
    2b68:	3f ef       	ldi	r19, 0xFF	; 255
    2b6a:	42 9f       	mul	r20, r18
    2b6c:	90 2d       	mov	r25, r0
    2b6e:	11 24       	eor	r1, r1
    2b70:	98 0f       	add	r25, r24
	 if (X>=100){
    2b72:	54 36       	cpi	r21, 0x64	; 100
    2b74:	40 f0       	brcs	.+16     	; 0x2b86 <intToStr+0x48>
	     str[0]=('0'+R);
    2b76:	a0 5d       	subi	r26, 0xD0	; 208
    2b78:	a0 83       	st	Z, r26
	     str[1]=('0'+P);
    2b7a:	40 5d       	subi	r20, 0xD0	; 208
    2b7c:	41 83       	std	Z+1, r20	; 0x01
	     str[2]=('0'+S);
    2b7e:	90 5d       	subi	r25, 0xD0	; 208
    2b80:	92 83       	std	Z+2, r25	; 0x02
	     str[3]=0;
    2b82:	13 82       	std	Z+3, r1	; 0x03
    2b84:	08 95       	ret
	 if ((X>=10)&&(X>100)){
	     str[0]=('0'+P);
	     str[1]=('0'+S);
	     str[2]=0;
	 }else 
	 if (X<=10){
    2b86:	5b 30       	cpi	r21, 0x0B	; 11
    2b88:	18 f4       	brcc	.+6      	; 0x2b90 <intToStr+0x52>
	     str[0]=('0'+S);
    2b8a:	90 5d       	subi	r25, 0xD0	; 208
    2b8c:	90 83       	st	Z, r25
	     str[1]=0;
    2b8e:	11 82       	std	Z+1, r1	; 0x01
    2b90:	08 95       	ret

00002b92 <ViewCardID>:
		else strCardID[i]=strRFID[i-(20-LengthID)];
	 }strCardID[20]=0;

}

void ViewCardID(){//+12345678 -->12345678
    2b92:	20 e0       	ldi	r18, 0x00	; 0
    2b94:	30 e0       	ldi	r19, 0x00	; 0
     char i;
	 for(i=0;i<8;i++){         //00000000000012345678
		strCardID[i]=strRFID[i];
    2b96:	f9 01       	movw	r30, r18
    2b98:	ef 59       	subi	r30, 0x9F	; 159
    2b9a:	f2 4f       	sbci	r31, 0xF2	; 242
    2b9c:	d9 01       	movw	r26, r18
    2b9e:	a4 5d       	subi	r26, 0xD4	; 212
    2ba0:	b1 4f       	sbci	r27, 0xF1	; 241
    2ba2:	8c 91       	ld	r24, X
    2ba4:	80 83       	st	Z, r24
    2ba6:	2f 5f       	subi	r18, 0xFF	; 255
    2ba8:	3f 4f       	sbci	r19, 0xFF	; 255

}

void ViewCardID(){//+12345678 -->12345678
     char i;
	 for(i=0;i<8;i++){         //00000000000012345678
    2baa:	28 30       	cpi	r18, 0x08	; 8
    2bac:	31 05       	cpc	r19, r1
    2bae:	99 f7       	brne	.-26     	; 0x2b96 <ViewCardID+0x4>
		strCardID[i]=strRFID[i];
	 }strCardID[8]=0;     
    2bb0:	10 92 69 0d 	sts	0x0D69, r1
}
    2bb4:	08 95       	ret

00002bb6 <StringCopy>:
//Message 56


void StringCopy(char *Source,char *Dest,char Length){
    2bb6:	cf 93       	push	r28
    2bb8:	df 93       	push	r29
    2bba:	db 01       	movw	r26, r22
    2bbc:	ec 01       	movw	r28, r24
    2bbe:	20 e0       	ldi	r18, 0x00	; 0
    2bc0:	30 e0       	ldi	r19, 0x00	; 0
    2bc2:	07 c0       	rjmp	.+14     	; 0x2bd2 <StringCopy+0x1c>
     char i;
	 for (i=0;i<Length;i++){
	     Dest[i]=Source[i];
    2bc4:	fd 01       	movw	r30, r26
    2bc6:	e2 0f       	add	r30, r18
    2bc8:	f3 1f       	adc	r31, r19
    2bca:	89 91       	ld	r24, Y+
    2bcc:	80 83       	st	Z, r24
    2bce:	2f 5f       	subi	r18, 0xFF	; 255
    2bd0:	3f 4f       	sbci	r19, 0xFF	; 255
//Message 56


void StringCopy(char *Source,char *Dest,char Length){
     char i;
	 for (i=0;i<Length;i++){
    2bd2:	24 17       	cp	r18, r20
    2bd4:	b8 f3       	brcs	.-18     	; 0x2bc4 <StringCopy+0xe>
	     Dest[i]=Source[i];
	 }Dest[Length]=0;
    2bd6:	a4 0f       	add	r26, r20
    2bd8:	b1 1d       	adc	r27, r1
    2bda:	1c 92       	st	X, r1
}
    2bdc:	df 91       	pop	r29
    2bde:	cf 91       	pop	r28
    2be0:	08 95       	ret

00002be2 <StringCopyPos>:
void StringCopyPos(char *Source,char *Dest,char SrcPos,char Length){
    2be2:	cf 93       	push	r28
    2be4:	df 93       	push	r29
    2be6:	db 01       	movw	r26, r22
    2be8:	ec 01       	movw	r28, r24
    2bea:	c4 0f       	add	r28, r20
    2bec:	d1 1d       	adc	r29, r1
    2bee:	40 e0       	ldi	r20, 0x00	; 0
    2bf0:	50 e0       	ldi	r21, 0x00	; 0
    2bf2:	07 c0       	rjmp	.+14     	; 0x2c02 <StringCopyPos+0x20>
     char i;
	 for (i=0;i<Length;i++){
	     Dest[i]=Source[SrcPos+i];
    2bf4:	fd 01       	movw	r30, r26
    2bf6:	e4 0f       	add	r30, r20
    2bf8:	f5 1f       	adc	r31, r21
    2bfa:	89 91       	ld	r24, Y+
    2bfc:	80 83       	st	Z, r24
    2bfe:	4f 5f       	subi	r20, 0xFF	; 255
    2c00:	5f 4f       	sbci	r21, 0xFF	; 255
	     Dest[i]=Source[i];
	 }Dest[Length]=0;
}
void StringCopyPos(char *Source,char *Dest,char SrcPos,char Length){
     char i;
	 for (i=0;i<Length;i++){
    2c02:	42 17       	cp	r20, r18
    2c04:	b8 f3       	brcs	.-18     	; 0x2bf4 <StringCopyPos+0x12>
	     Dest[i]=Source[SrcPos+i];
	 }Dest[Length]=0;
    2c06:	a2 0f       	add	r26, r18
    2c08:	b1 1d       	adc	r27, r1
    2c0a:	1c 92       	st	X, r1
}
    2c0c:	df 91       	pop	r29
    2c0e:	cf 91       	pop	r28
    2c10:	08 95       	ret

00002c12 <TestLocalAccount>:

void TestLocalAccount(){

}
    2c12:	08 95       	ret

00002c14 <BackLightTrig>:
     }      
}

void BackLightTrig(){
     //TimBackLight=0;
__key_light = 1; __key_lgtcnt = 0; PORTG=PORTG&0b11111101;
    2c14:	81 e0       	ldi	r24, 0x01	; 1
    2c16:	80 93 bf 03 	sts	0x03BF, r24
    2c1a:	10 92 c0 03 	sts	0x03C0, r1
    2c1e:	e5 e6       	ldi	r30, 0x65	; 101
    2c20:	f0 e0       	ldi	r31, 0x00	; 0
    2c22:	80 81       	ld	r24, Z
    2c24:	8d 7f       	andi	r24, 0xFD	; 253
    2c26:	80 83       	st	Z, r24
}
    2c28:	08 95       	ret

00002c2a <FBackLight>:

void FBackLight(){
     if (TimBackLight>0){
    2c2a:	20 91 a2 01 	lds	r18, 0x01A2
    2c2e:	30 91 a3 01 	lds	r19, 0x01A3
    2c32:	21 15       	cp	r18, r1
    2c34:	31 05       	cpc	r19, r1
    2c36:	61 f0       	breq	.+24     	; 0x2c50 <FBackLight+0x26>
	     PORTG=PORTG&0xFD;
    2c38:	80 91 65 00 	lds	r24, 0x0065
    2c3c:	8d 7f       	andi	r24, 0xFD	; 253
    2c3e:	80 93 65 00 	sts	0x0065, r24
	     TimBackLight--;
    2c42:	21 50       	subi	r18, 0x01	; 1
    2c44:	30 40       	sbci	r19, 0x00	; 0
    2c46:	30 93 a3 01 	sts	0x01A3, r19
    2c4a:	20 93 a2 01 	sts	0x01A2, r18
    2c4e:	08 95       	ret
		 }
	 else PORTG=PORTG|0x02;
    2c50:	80 91 65 00 	lds	r24, 0x0065
    2c54:	82 60       	ori	r24, 0x02	; 2
    2c56:	80 93 65 00 	sts	0x0065, r24
    2c5a:	08 95       	ret

00002c5c <GetBaudrate>:
	 }
}

int GetBaudrate(char brSetting){
int Result=0;
     switch(brSetting){
    2c5c:	82 30       	cpi	r24, 0x02	; 2
    2c5e:	59 f0       	breq	.+22     	; 0x2c76 <GetBaudrate+0x1a>
    2c60:	82 30       	cpi	r24, 0x02	; 2
    2c62:	18 f0       	brcs	.+6      	; 0x2c6a <GetBaudrate+0xe>
    2c64:	83 30       	cpi	r24, 0x03	; 3
    2c66:	21 f4       	brne	.+8      	; 0x2c70 <GetBaudrate+0x14>
    2c68:	09 c0       	rjmp	.+18     	; 0x2c7c <GetBaudrate+0x20>
    2c6a:	20 e8       	ldi	r18, 0x80	; 128
    2c6c:	35 e2       	ldi	r19, 0x25	; 37
    2c6e:	08 c0       	rjmp	.+16     	; 0x2c80 <GetBaudrate+0x24>
    2c70:	20 e0       	ldi	r18, 0x00	; 0
    2c72:	30 e0       	ldi	r19, 0x00	; 0
    2c74:	05 c0       	rjmp	.+10     	; 0x2c80 <GetBaudrate+0x24>
    2c76:	20 e0       	ldi	r18, 0x00	; 0
    2c78:	3b e4       	ldi	r19, 0x4B	; 75
    2c7a:	02 c0       	rjmp	.+4      	; 0x2c80 <GetBaudrate+0x24>
	 case br9600: 
	      Result=9600;
	      break;
	 case br19200:
	      Result=19200;
	      break;
    2c7c:	2b e9       	ldi	r18, 0x9B	; 155
    2c7e:	36 e1       	ldi	r19, 0x16	; 22
	 case br5787:
	      Result=5787;
     	  break;	 
	 }
   return Result;
}
    2c80:	c9 01       	movw	r24, r18
    2c82:	08 95       	ret

00002c84 <InitMemory>:
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2c84:	e1 99       	sbic	0x1c, 1	; 28
    2c86:	fe cf       	rjmp	.-4      	; 0x2c84 <InitMemory>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2c88:	84 e4       	ldi	r24, 0x44	; 68
    2c8a:	91 e0       	ldi	r25, 0x01	; 1
    2c8c:	9f bb       	out	0x1f, r25	; 31
    2c8e:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2c90:	e0 9a       	sbi	0x1c, 0	; 28
    2c92:	8d b3       	in	r24, 0x1d	; 29

	 }
}

void InitMemory(){
     PumpCountMax=eeprom_read_byte(&DefPoolingPumpMax);
    2c94:	80 93 5f 01 	sts	0x015F, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2c98:	e1 99       	sbic	0x1c, 1	; 28
    2c9a:	fe cf       	rjmp	.-4      	; 0x2c98 <InitMemory+0x14>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2c9c:	89 e4       	ldi	r24, 0x49	; 73
    2c9e:	91 e0       	ldi	r25, 0x01	; 1
    2ca0:	9f bb       	out	0x1f, r25	; 31
    2ca2:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2ca4:	e0 9a       	sbi	0x1c, 0	; 28
    2ca6:	8d b3       	in	r24, 0x1d	; 29
	 ActivePump=eeprom_read_byte(&DefActivePump);
    2ca8:	80 93 60 01 	sts	0x0160, r24
}
    2cac:	08 95       	ret

00002cae <InitStandalone>:
	      RunInitStandalone=False;
	      break;
	 }
  }
  */
}
    2cae:	08 95       	ret

00002cb0 <DisplayQueueFIP>:


void DisplayQueueFIP(){// FIP:#1#2#3#4#5

}
    2cb0:	08 95       	ret

00002cb2 <ShowMessage>:
	 }
}

void ShowMessage(char *Message){//Display Message on Line3
     char i;
}
    2cb2:	08 95       	ret

00002cb4 <CalcLRC>:

char CalcLRC(char xLRC,char DataIn){
     char Result;
	 Result=xLRC^DataIn;
     return(Result);
}
    2cb4:	86 27       	eor	r24, r22
    2cb6:	08 95       	ret

00002cb8 <systemEDC>:
}

void systemEDC(){//EDC Handler
     

}
    2cb8:	08 95       	ret

00002cba <GeniusCalc>:


char GeniusCalc(char cOption, char valA, char valB){
     char valC_H,valC_L,xValA,xValB,Result;
	 Result=0;
     switch(cOption){
    2cba:	88 23       	and	r24, r24
    2cbc:	19 f0       	breq	.+6      	; 0x2cc4 <GeniusCalc+0xa>
    2cbe:	81 30       	cpi	r24, 0x01	; 1
    2cc0:	49 f5       	brne	.+82     	; 0x2d14 <GeniusCalc+0x5a>
    2cc2:	11 c0       	rjmp	.+34     	; 0x2ce6 <GeniusCalc+0x2c>
	 case G_PLUS:                  // 5 + 8 = 1 + 3 = 4
	      valC_H=(valA+valB)/10;   //  
    2cc4:	26 2f       	mov	r18, r22
    2cc6:	30 e0       	ldi	r19, 0x00	; 0
    2cc8:	24 0f       	add	r18, r20
    2cca:	31 1d       	adc	r19, r1
		  valC_L=(valA+valB)%10;   //
	      Result=valC_H+valC_L;
    2ccc:	c9 01       	movw	r24, r18
    2cce:	6a e0       	ldi	r22, 0x0A	; 10
    2cd0:	70 e0       	ldi	r23, 0x00	; 0
    2cd2:	0e 94 a7 b8 	call	0x1714e	; 0x1714e <__divmodhi4>
    2cd6:	48 2f       	mov	r20, r24
    2cd8:	c9 01       	movw	r24, r18
    2cda:	6a e0       	ldi	r22, 0x0A	; 10
    2cdc:	70 e0       	ldi	r23, 0x00	; 0
    2cde:	0e 94 a7 b8 	call	0x1714e	; 0x1714e <__divmodhi4>
    2ce2:	46 0f       	add	r20, r22
    2ce4:	18 c0       	rjmp	.+48     	; 0x2d16 <GeniusCalc+0x5c>
	      break;
	 case G_MULTY:                 
	      if (valA>0)xValA=valA;
    2ce6:	66 23       	and	r22, r22
    2ce8:	09 f4       	brne	.+2      	; 0x2cec <GeniusCalc+0x32>
    2cea:	61 e0       	ldi	r22, 0x01	; 1
		  else xValA=1;
	      if (valB>0)xValB=valB;
    2cec:	44 23       	and	r20, r20
    2cee:	09 f4       	brne	.+2      	; 0x2cf2 <GeniusCalc+0x38>
    2cf0:	41 e0       	ldi	r20, 0x01	; 1
		  else xValB=1;
	      valC_H=(xValA*xValB)/10;   //  
    2cf2:	46 9f       	mul	r20, r22
    2cf4:	90 01       	movw	r18, r0
    2cf6:	11 24       	eor	r1, r1
    2cf8:	c9 01       	movw	r24, r18
    2cfa:	6a e0       	ldi	r22, 0x0A	; 10
    2cfc:	70 e0       	ldi	r23, 0x00	; 0
    2cfe:	0e 94 a7 b8 	call	0x1714e	; 0x1714e <__divmodhi4>
    2d02:	46 2f       	mov	r20, r22
		  valC_L=(xValA*xValB)%10;   //
    2d04:	c9 01       	movw	r24, r18
    2d06:	6a e0       	ldi	r22, 0x0A	; 10
    2d08:	70 e0       	ldi	r23, 0x00	; 0
    2d0a:	0e 94 a7 b8 	call	0x1714e	; 0x1714e <__divmodhi4>
    2d0e:	64 2f       	mov	r22, r20
    2d10:	48 2f       	mov	r20, r24
    2d12:	d8 cf       	rjmp	.-80     	; 0x2cc4 <GeniusCalc+0xa>
    2d14:	40 e0       	ldi	r20, 0x00	; 0
	 case G_MINUS:
	      
	      break;
	 }
   return Result;
}
    2d16:	84 2f       	mov	r24, r20
    2d18:	08 95       	ret

00002d1a <FSubMenuAdmin>:

char FSubMenuAdmin(){
     char Result;
	 Result=MENU_DONE;
   return Result;
}
    2d1a:	81 e0       	ldi	r24, 0x01	; 1
    2d1c:	08 95       	ret

00002d1e <CountNoPumpSatus>:
	      break;	 
	 } 
   return Result;
}

char CountNoPumpSatus(char *strPumpStatusTotalizer){
    2d1e:	ff 92       	push	r15
    2d20:	0f 93       	push	r16
    2d22:	1f 93       	push	r17
    2d24:	cf 93       	push	r28
    2d26:	df 93       	push	r29
char i,Result;
     Result=0;
	 for (i=0;i<PumpCountMax;i++){
    2d28:	f0 90 5f 01 	lds	r15, 0x015F
    2d2c:	ec 01       	movw	r28, r24
    2d2e:	00 e0       	ldi	r16, 0x00	; 0
    2d30:	10 e0       	ldi	r17, 0x00	; 0
    2d32:	09 c0       	rjmp	.+18     	; 0x2d46 <CountNoPumpSatus+0x28>
	      if (strPumpStatusTotalizer[i]==GetPumpStatusLabel(PUMP_NONE)){
    2d34:	8e e0       	ldi	r24, 0x0E	; 14
    2d36:	0e 94 93 13 	call	0x2726	; 0x2726 <GetPumpStatusLabel>
    2d3a:	98 81       	ld	r25, Y
    2d3c:	98 17       	cp	r25, r24
    2d3e:	09 f4       	brne	.+2      	; 0x2d42 <CountNoPumpSatus+0x24>
		      Result++;		  
    2d40:	1f 5f       	subi	r17, 0xFF	; 255
}

char CountNoPumpSatus(char *strPumpStatusTotalizer){
char i,Result;
     Result=0;
	 for (i=0;i<PumpCountMax;i++){
    2d42:	0f 5f       	subi	r16, 0xFF	; 255
    2d44:	21 96       	adiw	r28, 0x01	; 1
    2d46:	0f 15       	cp	r16, r15
    2d48:	a8 f3       	brcs	.-22     	; 0x2d34 <CountNoPumpSatus+0x16>
	      if (strPumpStatusTotalizer[i]==GetPumpStatusLabel(PUMP_NONE)){
		      Result++;		  
		  }	 
	 }
  return Result;
}
    2d4a:	81 2f       	mov	r24, r17
    2d4c:	df 91       	pop	r29
    2d4e:	cf 91       	pop	r28
    2d50:	1f 91       	pop	r17
    2d52:	0f 91       	pop	r16
    2d54:	ff 90       	pop	r15
    2d56:	08 95       	ret

00002d58 <FCloseDay>:
   return Result;
}

char FCloseDay(){

}
    2d58:	08 95       	ret

00002d5a <FLockPump>:
char FLockPump(){

}
    2d5a:	08 95       	ret

00002d5c <FMenuSettingPassword>:
char FMenuSettingPassword(){
     char Result;
   //_menu_password();
   Result=MENU_DONE;
   return Result;
}
    2d5c:	81 e0       	ldi	r24, 0x01	; 1
    2d5e:	08 95       	ret

00002d60 <menu_product>:
   return Result;
}

void menu_product(){

}
    2d60:	08 95       	ret

00002d62 <IncValue>:
            lcd_print(xPos,yPos,strLabel);
		}
	}
}

void IncValue(char *Value,char MinValue,char MaxValue){
    2d62:	fc 01       	movw	r30, r24
     if ((*Value)<MaxValue){
    2d64:	80 81       	ld	r24, Z
    2d66:	84 17       	cp	r24, r20
    2d68:	18 f4       	brcc	.+6      	; 0x2d70 <IncValue+0xe>
	     (*Value)++;
    2d6a:	8f 5f       	subi	r24, 0xFF	; 255
    2d6c:	80 83       	st	Z, r24
    2d6e:	08 95       	ret
	 }else *Value=MinValue;
    2d70:	60 83       	st	Z, r22
    2d72:	08 95       	ret

00002d74 <DecValue>:
}

void DecValue(char *Value,char MinValue,char MaxValue){
    2d74:	fc 01       	movw	r30, r24
     if ((*Value)>MinValue){
    2d76:	80 81       	ld	r24, Z
    2d78:	68 17       	cp	r22, r24
    2d7a:	18 f4       	brcc	.+6      	; 0x2d82 <DecValue+0xe>
	     (*Value)--;
    2d7c:	81 50       	subi	r24, 0x01	; 1
    2d7e:	80 83       	st	Z, r24
    2d80:	08 95       	ret
	 }else *Value=MaxValue;
    2d82:	40 83       	st	Z, r20
    2d84:	08 95       	ret

00002d86 <zeroIP>:
		 
		}

	}
}
void zeroIP(unsigned char Val,char *StrResult){
    2d86:	58 2f       	mov	r21, r24
    2d88:	fb 01       	movw	r30, r22
     unsigned char R,P,S;
	 if (Val>=100){
    2d8a:	84 36       	cpi	r24, 0x64	; 100
    2d8c:	00 f1       	brcs	.+64     	; 0x2dce <zeroIP+0x48>
	    R=(Val/100);
    2d8e:	64 e6       	ldi	r22, 0x64	; 100
    2d90:	0e 94 7a b8 	call	0x170f4	; 0x170f4 <__udivmodqi4>
    2d94:	48 2f       	mov	r20, r24
        P=((Val%100)/10);
    2d96:	85 2f       	mov	r24, r21
    2d98:	0e 94 7a b8 	call	0x170f4	; 0x170f4 <__udivmodqi4>
    2d9c:	89 2f       	mov	r24, r25
    2d9e:	6a e0       	ldi	r22, 0x0A	; 10
    2da0:	0e 94 7a b8 	call	0x170f4	; 0x170f4 <__udivmodqi4>
		S=Val-((R*100)+(P*10)); 
        StrResult[0]='0'+R;//+(Val/100);
    2da4:	40 5d       	subi	r20, 0xD0	; 208
    2da6:	40 83       	st	Z, r20
    2da8:	40 53       	subi	r20, 0x30	; 48
	    StrResult[1]='0'+P;//+((Val%100)/10);
    2daa:	80 5d       	subi	r24, 0xD0	; 208
    2dac:	81 83       	std	Z+1, r24	; 0x01
    2dae:	80 53       	subi	r24, 0x30	; 48
		StrResult[2]='0'+S;//+(Val-((Val/100)*100)-((Val%100)/10));
    2db0:	50 5d       	subi	r21, 0xD0	; 208
    2db2:	2c e9       	ldi	r18, 0x9C	; 156
    2db4:	3f ef       	ldi	r19, 0xFF	; 255
    2db6:	42 9f       	mul	r20, r18
    2db8:	40 2d       	mov	r20, r0
    2dba:	11 24       	eor	r1, r1
    2dbc:	45 0f       	add	r20, r21
    2dbe:	26 ef       	ldi	r18, 0xF6	; 246
    2dc0:	3f ef       	ldi	r19, 0xFF	; 255
    2dc2:	82 9f       	mul	r24, r18
    2dc4:	80 2d       	mov	r24, r0
    2dc6:	11 24       	eor	r1, r1
    2dc8:	84 0f       	add	r24, r20
    2dca:	82 83       	std	Z+2, r24	; 0x02
    2dcc:	10 c0       	rjmp	.+32     	; 0x2dee <zeroIP+0x68>
		StrResult[3]=0;
		}else     
	 if ((Val>=10)&&(Val<100)){
    2dce:	8a 50       	subi	r24, 0x0A	; 10
    2dd0:	8a 35       	cpi	r24, 0x5A	; 90
    2dd2:	78 f4       	brcc	.+30     	; 0x2df2 <zeroIP+0x6c>
        StrResult[0]='0';
    2dd4:	80 e3       	ldi	r24, 0x30	; 48
    2dd6:	80 83       	st	Z, r24
	    StrResult[1]=('0'+(Val/10));
    2dd8:	85 2f       	mov	r24, r21
    2dda:	6a e0       	ldi	r22, 0x0A	; 10
    2ddc:	0e 94 7a b8 	call	0x170f4	; 0x170f4 <__udivmodqi4>
    2de0:	80 5d       	subi	r24, 0xD0	; 208
    2de2:	81 83       	std	Z+1, r24	; 0x01
		StrResult[2]=('0'+(Val%10));
    2de4:	85 2f       	mov	r24, r21
    2de6:	0e 94 7a b8 	call	0x170f4	; 0x170f4 <__udivmodqi4>
    2dea:	90 5d       	subi	r25, 0xD0	; 208
    2dec:	92 83       	std	Z+2, r25	; 0x02
		StrResult[3]=0;
    2dee:	13 82       	std	Z+3, r1	; 0x03
    2df0:	08 95       	ret
		}
     else
	 if (Val<10){
    2df2:	5a 30       	cpi	r21, 0x0A	; 10
    2df4:	30 f4       	brcc	.+12     	; 0x2e02 <zeroIP+0x7c>
	    StrResult[0]='0';
    2df6:	80 e3       	ldi	r24, 0x30	; 48
    2df8:	80 83       	st	Z, r24
		StrResult[1]='0';
    2dfa:	81 83       	std	Z+1, r24	; 0x01
	    StrResult[2]='0'+Val;
    2dfc:	50 5d       	subi	r21, 0xD0	; 208
    2dfe:	52 83       	std	Z+2, r21	; 0x02
	    StrResult[3]=0;
    2e00:	13 82       	std	Z+3, r1	; 0x03
    2e02:	08 95       	ret

00002e04 <GetLocAccStatus>:


char GetLocAccStatus(char paramMessage57){
     char Result;
	 Result=LA_NONE;
     if (paramMessage57==MSG57_INVALID)Result=LA_INVALID;
    2e04:	81 30       	cpi	r24, 0x01	; 1
    2e06:	29 f0       	breq	.+10     	; 0x2e12 <GetLocAccStatus+0xe>
	 else
     if (paramMessage57==MSG57_VALID)Result=LA_VALID;
    2e08:	82 30       	cpi	r24, 0x02	; 2
    2e0a:	19 f0       	breq	.+6      	; 0x2e12 <GetLocAccStatus+0xe>
	 else
     if (paramMessage57==MSG57_LIMITED)Result=LA_LIMITED;
    2e0c:	83 30       	cpi	r24, 0x03	; 3
    2e0e:	09 f0       	breq	.+2      	; 0x2e12 <GetLocAccStatus+0xe>
    2e10:	80 e0       	ldi	r24, 0x00	; 0
	 return Result;
}
    2e12:	08 95       	ret

00002e14 <FTestRemZero>:
	     RemZeroLead(strTest);  
		 _uart_print(0,1,strTest);

	while (1){};
  #endif
}
    2e14:	08 95       	ret

00002e16 <StrPosCopy>:
     nAddedSpace=(Length-srcLength)/2;
     AddSpaceLead(Source,srcLength+nAddedSpace);
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
    2e16:	cf 93       	push	r28
    2e18:	df 93       	push	r29
    2e1a:	eb 01       	movw	r28, r22
    2e1c:	da 01       	movw	r26, r20
    2e1e:	a8 0f       	add	r26, r24
    2e20:	b9 1f       	adc	r27, r25
    2e22:	40 e0       	ldi	r20, 0x00	; 0
    2e24:	50 e0       	ldi	r21, 0x00	; 0
    2e26:	07 c0       	rjmp	.+14     	; 0x2e36 <StrPosCopy+0x20>
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2e28:	fe 01       	movw	r30, r28
    2e2a:	e4 0f       	add	r30, r20
    2e2c:	f5 1f       	adc	r31, r21
    2e2e:	8d 91       	ld	r24, X+
    2e30:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2e32:	4f 5f       	subi	r20, 0xFF	; 255
    2e34:	5f 4f       	sbci	r21, 0xFF	; 255
    2e36:	42 17       	cp	r20, r18
    2e38:	53 07       	cpc	r21, r19
    2e3a:	b0 f3       	brcs	.-20     	; 0x2e28 <StrPosCopy+0x12>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2e3c:	c2 0f       	add	r28, r18
    2e3e:	d3 1f       	adc	r29, r19
    2e40:	18 82       	st	Y, r1
}
    2e42:	df 91       	pop	r29
    2e44:	cf 91       	pop	r28
    2e46:	08 95       	ret

00002e48 <StrPosPaste>:
void StrPosPaste(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
    2e48:	0f 93       	push	r16
    2e4a:	1f 93       	push	r17
    2e4c:	cf 93       	push	r28
    2e4e:	df 93       	push	r29
    2e50:	8c 01       	movw	r16, r24
    2e52:	db 01       	movw	r26, r22
    2e54:	eb 01       	movw	r28, r22
    2e56:	c4 0f       	add	r28, r20
    2e58:	d5 1f       	adc	r29, r21
    2e5a:	60 e0       	ldi	r22, 0x00	; 0
    2e5c:	70 e0       	ldi	r23, 0x00	; 0
    2e5e:	07 c0       	rjmp	.+14     	; 0x2e6e <StrPosPaste+0x26>
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[IdxSource+i]=Source[i];
    2e60:	f8 01       	movw	r30, r16
    2e62:	e6 0f       	add	r30, r22
    2e64:	f7 1f       	adc	r31, r23
    2e66:	80 81       	ld	r24, Z
    2e68:	89 93       	st	Y+, r24
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
}
void StrPosPaste(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2e6a:	6f 5f       	subi	r22, 0xFF	; 255
    2e6c:	7f 4f       	sbci	r23, 0xFF	; 255
    2e6e:	62 17       	cp	r22, r18
    2e70:	73 07       	cpc	r23, r19
    2e72:	b0 f3       	brcs	.-20     	; 0x2e60 <StrPosPaste+0x18>
	    Dest[IdxSource+i]=Source[i];
	 }Dest[IdxSource+Length]=0;
    2e74:	a4 0f       	add	r26, r20
    2e76:	b5 1f       	adc	r27, r21
    2e78:	a2 0f       	add	r26, r18
    2e7a:	b3 1f       	adc	r27, r19
    2e7c:	1c 92       	st	X, r1
}
    2e7e:	df 91       	pop	r29
    2e80:	cf 91       	pop	r28
    2e82:	1f 91       	pop	r17
    2e84:	0f 91       	pop	r16
    2e86:	08 95       	ret

00002e88 <CharPosCopy>:
char CharPosCopy(char *Source, unsigned int IdxSource){
    2e88:	fb 01       	movw	r30, r22
    2e8a:	e8 0f       	add	r30, r24
    2e8c:	f9 1f       	adc	r31, r25
     char Result;
     Result=Source[IdxSource];
	 return Result;
}
    2e8e:	80 81       	ld	r24, Z
    2e90:	08 95       	ret

00002e92 <procMessage00>:
*/
char procMessage00(){
     char Result,strSend[10];
	 Result=MSG00_NACK;
	 //Message57
	 if((rcv_trans[0]==0x01)&&(transLength==MSG00_LENGTH)){
    2e92:	80 91 f5 0a 	lds	r24, 0x0AF5
    2e96:	81 30       	cpi	r24, 0x01	; 1
    2e98:	51 f4       	brne	.+20     	; 0x2eae <procMessage00+0x1c>
    2e9a:	80 91 9e 01 	lds	r24, 0x019E
    2e9e:	90 91 9f 01 	lds	r25, 0x019F
    2ea2:	8f 97       	sbiw	r24, 0x2f	; 47
    2ea4:	21 f4       	brne	.+8      	; 0x2eae <procMessage00+0x1c>
	     //Reply
		 Result=(CharPosCopy(rcv_trans,37)-'0');
    2ea6:	80 91 1a 0b 	lds	r24, 0x0B1A
    2eaa:	80 53       	subi	r24, 0x30	; 48
    2eac:	08 95       	ret
    2eae:	80 e0       	ldi	r24, 0x00	; 0
		 //sprintf(strSend,"R=%d",Result);
		 //_uart_print(0,1,strSend);
		 //*/
		 }
     return Result;
}
    2eb0:	08 95       	ret

00002eb2 <procMessage09>:
	    Dest[IdxSource+i]=Source[i];
	 }Dest[IdxSource+Length]=0;
}
char CharPosCopy(char *Source, unsigned int IdxSource){
     char Result;
     Result=Source[IdxSource];
    2eb2:	90 91 1c 0b 	lds	r25, 0x0B1C
    2eb6:	20 e0       	ldi	r18, 0x00	; 0
    2eb8:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2eba:	f9 01       	movw	r30, r18
    2ebc:	e9 56       	subi	r30, 0x69	; 105
    2ebe:	f5 4f       	sbci	r31, 0xF5	; 245
    2ec0:	d9 01       	movw	r26, r18
    2ec2:	ab 50       	subi	r26, 0x0B	; 11
    2ec4:	b5 4f       	sbci	r27, 0xF5	; 245
    2ec6:	97 96       	adiw	r26, 0x27	; 39
    2ec8:	8c 91       	ld	r24, X
    2eca:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2ecc:	2f 5f       	subi	r18, 0xFF	; 255
    2ece:	3f 4f       	sbci	r19, 0xFF	; 255
    2ed0:	24 31       	cpi	r18, 0x14	; 20
    2ed2:	31 05       	cpc	r19, r1
    2ed4:	91 f7       	brne	.-28     	; 0x2eba <procMessage09+0x8>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2ed6:	10 92 ab 0a 	sts	0x0AAB, r1
    2eda:	20 e0       	ldi	r18, 0x00	; 0
    2edc:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2ede:	f9 01       	movw	r30, r18
    2ee0:	ea 57       	subi	r30, 0x7A	; 122
    2ee2:	f6 4f       	sbci	r31, 0xF6	; 246
    2ee4:	d9 01       	movw	r26, r18
    2ee6:	ab 50       	subi	r26, 0x0B	; 11
    2ee8:	b5 4f       	sbci	r27, 0xF5	; 245
    2eea:	db 96       	adiw	r26, 0x3b	; 59
    2eec:	8c 91       	ld	r24, X
    2eee:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2ef0:	2f 5f       	subi	r18, 0xFF	; 255
    2ef2:	3f 4f       	sbci	r19, 0xFF	; 255
    2ef4:	24 31       	cpi	r18, 0x14	; 20
    2ef6:	31 05       	cpc	r19, r1
    2ef8:	91 f7       	brne	.-28     	; 0x2ede <procMessage09+0x2c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2efa:	10 92 9a 09 	sts	0x099A, r1
    2efe:	20 e0       	ldi	r18, 0x00	; 0
    2f00:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2f02:	f9 01       	movw	r30, r18
    2f04:	ef 5d       	subi	r30, 0xDF	; 223
    2f06:	f5 4f       	sbci	r31, 0xF5	; 245
    2f08:	d9 01       	movw	r26, r18
    2f0a:	ac 5b       	subi	r26, 0xBC	; 188
    2f0c:	b4 4f       	sbci	r27, 0xF4	; 244
    2f0e:	8c 91       	ld	r24, X
    2f10:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2f12:	2f 5f       	subi	r18, 0xFF	; 255
    2f14:	3f 4f       	sbci	r19, 0xFF	; 255
    2f16:	24 31       	cpi	r18, 0x14	; 20
    2f18:	31 05       	cpc	r19, r1
    2f1a:	99 f7       	brne	.-26     	; 0x2f02 <procMessage09+0x50>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2f1c:	10 92 35 0a 	sts	0x0A35, r1
    2f20:	20 e0       	ldi	r18, 0x00	; 0
    2f22:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2f24:	f9 01       	movw	r30, r18
    2f26:	ef 54       	subi	r30, 0x4F	; 79
    2f28:	f2 4f       	sbci	r31, 0xF2	; 242
    2f2a:	d9 01       	movw	r26, r18
    2f2c:	a8 5a       	subi	r26, 0xA8	; 168
    2f2e:	b4 4f       	sbci	r27, 0xF4	; 244
    2f30:	8c 91       	ld	r24, X
    2f32:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2f34:	2f 5f       	subi	r18, 0xFF	; 255
    2f36:	3f 4f       	sbci	r19, 0xFF	; 255
    2f38:	24 31       	cpi	r18, 0x14	; 20
    2f3a:	31 05       	cpc	r19, r1
    2f3c:	99 f7       	brne	.-26     	; 0x2f24 <procMessage09+0x72>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2f3e:	10 92 c5 0d 	sts	0x0DC5, r1
       StrPosCopy(rcv_trans,strFreeMessageLine1,39,20);
       StrPosCopy(rcv_trans,strFreeMessageLine2,59,20);
       StrPosCopy(rcv_trans,strFreeMessageLine3,79,20);
       StrPosCopy(rcv_trans,strFreeMessageLine4,99,20);
	 return Result;
}
    2f42:	89 2f       	mov	r24, r25
    2f44:	80 53       	subi	r24, 0x30	; 48
    2f46:	08 95       	ret

00002f48 <procMessage23>:
		 eeprom_write_block((const void*)&strBankName, (void*)&DefBankName[i], 11);
	 }
	 return Result;
}

char procMessage23(){
    2f48:	20 e0       	ldi	r18, 0x00	; 0
    2f4a:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2f4c:	f9 01       	movw	r30, r18
    2f4e:	ef 59       	subi	r30, 0x9F	; 159
    2f50:	f2 4f       	sbci	r31, 0xF2	; 242
    2f52:	d9 01       	movw	r26, r18
    2f54:	ab 50       	subi	r26, 0x0B	; 11
    2f56:	b5 4f       	sbci	r27, 0xF5	; 245
    2f58:	95 96       	adiw	r26, 0x25	; 37
    2f5a:	8c 91       	ld	r24, X
    2f5c:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2f5e:	2f 5f       	subi	r18, 0xFF	; 255
    2f60:	3f 4f       	sbci	r19, 0xFF	; 255
    2f62:	24 31       	cpi	r18, 0x14	; 20
    2f64:	31 05       	cpc	r19, r1
    2f66:	91 f7       	brne	.-28     	; 0x2f4c <procMessage23+0x4>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2f68:	10 92 75 0d 	sts	0x0D75, r1
    2f6c:	20 e0       	ldi	r18, 0x00	; 0
    2f6e:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2f70:	f9 01       	movw	r30, r18
    2f72:	ec 5f       	subi	r30, 0xFC	; 252
    2f74:	fa 4f       	sbci	r31, 0xFA	; 250
    2f76:	d9 01       	movw	r26, r18
    2f78:	ab 50       	subi	r26, 0x0B	; 11
    2f7a:	b5 4f       	sbci	r27, 0xF5	; 245
    2f7c:	d9 96       	adiw	r26, 0x39	; 57
    2f7e:	8c 91       	ld	r24, X
    2f80:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2f82:	2f 5f       	subi	r18, 0xFF	; 255
    2f84:	3f 4f       	sbci	r19, 0xFF	; 255
    2f86:	2e 31       	cpi	r18, 0x1E	; 30
    2f88:	31 05       	cpc	r19, r1
    2f8a:	91 f7       	brne	.-28     	; 0x2f70 <procMessage23+0x28>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2f8c:	10 92 22 05 	sts	0x0522, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2f90:	80 91 4c 0b 	lds	r24, 0x0B4C
    2f94:	80 93 6a 05 	sts	0x056A, r24
	 }Dest[Length]=0;
    2f98:	10 92 6b 05 	sts	0x056B, r1
    2f9c:	20 e0       	ldi	r18, 0x00	; 0
    2f9e:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2fa0:	f9 01       	movw	r30, r18
    2fa2:	e6 5c       	subi	r30, 0xC6	; 198
    2fa4:	f5 4f       	sbci	r31, 0xF5	; 245
    2fa6:	d9 01       	movw	r26, r18
    2fa8:	a3 5b       	subi	r26, 0xB3	; 179
    2faa:	b4 4f       	sbci	r27, 0xF4	; 244
    2fac:	8c 91       	ld	r24, X
    2fae:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2fb0:	2f 5f       	subi	r18, 0xFF	; 255
    2fb2:	3f 4f       	sbci	r19, 0xFF	; 255
    2fb4:	28 30       	cpi	r18, 0x08	; 8
    2fb6:	31 05       	cpc	r19, r1
    2fb8:	99 f7       	brne	.-26     	; 0x2fa0 <procMessage23+0x58>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2fba:	10 92 42 0a 	sts	0x0A42, r1
    2fbe:	20 e0       	ldi	r18, 0x00	; 0
    2fc0:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2fc2:	f9 01       	movw	r30, r18
    2fc4:	e2 5a       	subi	r30, 0xA2	; 162
    2fc6:	fa 4f       	sbci	r31, 0xFA	; 250
    2fc8:	d9 01       	movw	r26, r18
    2fca:	ab 5a       	subi	r26, 0xAB	; 171
    2fcc:	b4 4f       	sbci	r27, 0xF4	; 244
    2fce:	8c 91       	ld	r24, X
    2fd0:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2fd2:	2f 5f       	subi	r18, 0xFF	; 255
    2fd4:	3f 4f       	sbci	r19, 0xFF	; 255
    2fd6:	2a 30       	cpi	r18, 0x0A	; 10
    2fd8:	31 05       	cpc	r19, r1
    2fda:	99 f7       	brne	.-26     	; 0x2fc2 <procMessage23+0x7a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2fdc:	10 92 68 05 	sts	0x0568, r1
    2fe0:	20 e0       	ldi	r18, 0x00	; 0
    2fe2:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2fe4:	f9 01       	movw	r30, r18
    2fe6:	e8 53       	subi	r30, 0x38	; 56
    2fe8:	f2 4f       	sbci	r31, 0xF2	; 242
    2fea:	d9 01       	movw	r26, r18
    2fec:	a1 5a       	subi	r26, 0xA1	; 161
    2fee:	b4 4f       	sbci	r27, 0xF4	; 244
    2ff0:	8c 91       	ld	r24, X
    2ff2:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2ff4:	2f 5f       	subi	r18, 0xFF	; 255
    2ff6:	3f 4f       	sbci	r19, 0xFF	; 255
    2ff8:	2a 30       	cpi	r18, 0x0A	; 10
    2ffa:	31 05       	cpc	r19, r1
    2ffc:	99 f7       	brne	.-26     	; 0x2fe4 <procMessage23+0x9c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2ffe:	10 92 d2 0d 	sts	0x0DD2, r1
    3002:	20 e0       	ldi	r18, 0x00	; 0
    3004:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    3006:	f9 01       	movw	r30, r18
    3008:	e9 56       	subi	r30, 0x69	; 105
    300a:	f2 4f       	sbci	r31, 0xF2	; 242
    300c:	d9 01       	movw	r26, r18
    300e:	a7 59       	subi	r26, 0x97	; 151
    3010:	b4 4f       	sbci	r27, 0xF4	; 244
    3012:	8c 91       	ld	r24, X
    3014:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    3016:	2f 5f       	subi	r18, 0xFF	; 255
    3018:	3f 4f       	sbci	r19, 0xFF	; 255
    301a:	23 31       	cpi	r18, 0x13	; 19
    301c:	31 05       	cpc	r19, r1
    301e:	99 f7       	brne	.-26     	; 0x3006 <procMessage23+0xbe>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    3020:	10 92 aa 0d 	sts	0x0DAA, r1
    3024:	20 e0       	ldi	r18, 0x00	; 0
    3026:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    3028:	f9 01       	movw	r30, r18
    302a:	e5 57       	subi	r30, 0x75	; 117
    302c:	f2 4f       	sbci	r31, 0xF2	; 242
    302e:	d9 01       	movw	r26, r18
    3030:	a4 58       	subi	r26, 0x84	; 132
    3032:	b4 4f       	sbci	r27, 0xF4	; 244
    3034:	8c 91       	ld	r24, X
    3036:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    3038:	2f 5f       	subi	r18, 0xFF	; 255
    303a:	3f 4f       	sbci	r19, 0xFF	; 255
    303c:	27 30       	cpi	r18, 0x07	; 7
    303e:	31 05       	cpc	r19, r1
    3040:	99 f7       	brne	.-26     	; 0x3028 <procMessage23+0xe0>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    3042:	10 92 92 0d 	sts	0x0D92, r1
    3046:	20 e0       	ldi	r18, 0x00	; 0
    3048:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    304a:	f9 01       	movw	r30, r18
    304c:	e5 56       	subi	r30, 0x65	; 101
    304e:	fb 4f       	sbci	r31, 0xFB	; 251
    3050:	d9 01       	movw	r26, r18
    3052:	ad 57       	subi	r26, 0x7D	; 125
    3054:	b4 4f       	sbci	r27, 0xF4	; 244
    3056:	8c 91       	ld	r24, X
    3058:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    305a:	2f 5f       	subi	r18, 0xFF	; 255
    305c:	3f 4f       	sbci	r19, 0xFF	; 255
    305e:	24 30       	cpi	r18, 0x04	; 4
    3060:	31 05       	cpc	r19, r1
    3062:	99 f7       	brne	.-26     	; 0x304a <procMessage23+0x102>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    3064:	10 92 9f 04 	sts	0x049F, r1
     StrPosCopy(rcv_trans,strLoyCurrMonConsumeV,106,10);
     StrPosCopy(rcv_trans,strDateTime,116,19);
     StrPosCopy(rcv_trans,strAmount,135,7);
     StrPosCopy(rcv_trans,strGainPoints,142,4);
     return Result;
}
    3068:	80 e0       	ldi	r24, 0x00	; 0
    306a:	08 95       	ret

0000306c <procMessage81>:
_uart_print(0,1,strCardID);
*/	
     return Result;
}

char procMessage81(){// Result: HFCS0000
    306c:	cf 93       	push	r28
    306e:	df 93       	push	r29
     char Result=0,PrintCopy=0;//
	 char lcdteks[20];
	 //PrintHeader
     if ((CharPosCopy(rcv_trans,37))=='Y') Result=(Result|(1<<7));
    3070:	80 91 1a 0b 	lds	r24, 0x0B1A
    3074:	89 35       	cpi	r24, 0x59	; 89
    3076:	11 f4       	brne	.+4      	; 0x307c <procMessage81+0x10>
    3078:	90 e8       	ldi	r25, 0x80	; 128
    307a:	01 c0       	rjmp	.+2      	; 0x307e <procMessage81+0x12>
    307c:	90 e0       	ldi	r25, 0x00	; 0
     //PrintFooter
	 if ((CharPosCopy(rcv_trans,38))=='Y') Result=(Result|(1<<6));
    307e:	80 91 1b 0b 	lds	r24, 0x0B1B
    3082:	89 35       	cpi	r24, 0x59	; 89
    3084:	09 f4       	brne	.+2      	; 0x3088 <procMessage81+0x1c>
    3086:	90 64       	ori	r25, 0x40	; 64
	 //PaperCut
     if ((CharPosCopy(rcv_trans,39))=='Y') Result=(Result|(1<<5));
    3088:	80 91 1c 0b 	lds	r24, 0x0B1C
    308c:	89 35       	cpi	r24, 0x59	; 89
    308e:	09 f4       	brne	.+2      	; 0x3092 <procMessage81+0x26>
    3090:	90 62       	ori	r25, 0x20	; 32
	 //Scrool
	 Result=(Result|(1<<4));
    3092:	90 61       	ori	r25, 0x10	; 16

	 //Copies
	 PrintCopy=(CharPosCopy(rcv_trans,40)-'0');
    3094:	80 91 1d 0b 	lds	r24, 0x0B1D
    3098:	80 53       	subi	r24, 0x30	; 48
     if (PrintCopy<=16) Result=Result|PrintCopy;
    309a:	81 31       	cpi	r24, 0x11	; 17
    309c:	08 f4       	brcc	.+2      	; 0x30a0 <procMessage81+0x34>
    309e:	98 2b       	or	r25, r24
	 //Spooling
     StrPosCopy(rcv_trans,PrintBuffer,44,LengthMessage81);
    30a0:	c0 91 a0 01 	lds	r28, 0x01A0
    30a4:	d0 91 a1 01 	lds	r29, 0x01A1
    30a8:	20 e0       	ldi	r18, 0x00	; 0
    30aa:	30 e0       	ldi	r19, 0x00	; 0
    30ac:	0b c0       	rjmp	.+22     	; 0x30c4 <procMessage81+0x58>
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    30ae:	f9 01       	movw	r30, r18
    30b0:	e1 53       	subi	r30, 0x31	; 49
    30b2:	fa 4f       	sbci	r31, 0xFA	; 250
    30b4:	d9 01       	movw	r26, r18
    30b6:	ab 50       	subi	r26, 0x0B	; 11
    30b8:	b5 4f       	sbci	r27, 0xF5	; 245
    30ba:	9c 96       	adiw	r26, 0x2c	; 44
    30bc:	8c 91       	ld	r24, X
    30be:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    30c0:	2f 5f       	subi	r18, 0xFF	; 255
    30c2:	3f 4f       	sbci	r19, 0xFF	; 255
    30c4:	2c 17       	cp	r18, r28
    30c6:	3d 07       	cpc	r19, r29
    30c8:	90 f3       	brcs	.-28     	; 0x30ae <procMessage81+0x42>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    30ca:	c1 53       	subi	r28, 0x31	; 49
    30cc:	da 4f       	sbci	r29, 0xFA	; 250
    30ce:	18 82       	st	Y, r1
	 //sprintf(lcdteks,"cmdPrint:%d ",Result);
     //_uart_print(0,1,lcdteks);

	 //while(1){};
	 return Result;
}
    30d0:	89 2f       	mov	r24, r25
    30d2:	df 91       	pop	r29
    30d4:	cf 91       	pop	r28
    30d6:	08 95       	ret

000030d8 <FillChar>:
	 if(CutType== 1) { _uart(_COM_PRINTER, 1, 0x6D);}
	 if(CutType== 2) {_uart(_COM_PRINTER, 1, 0x69);}

}

void FillChar(char *strMemory, unsigned int Length,char data){
    30d8:	20 e0       	ldi	r18, 0x00	; 0
    30da:	30 e0       	ldi	r19, 0x00	; 0
    30dc:	06 c0       	rjmp	.+12     	; 0x30ea <FillChar+0x12>
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    30de:	fc 01       	movw	r30, r24
    30e0:	e2 0f       	add	r30, r18
    30e2:	f3 1f       	adc	r31, r19
    30e4:	40 83       	st	Z, r20

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    30e6:	2f 5f       	subi	r18, 0xFF	; 255
    30e8:	3f 4f       	sbci	r19, 0xFF	; 255
    30ea:	26 17       	cp	r18, r22
    30ec:	37 07       	cpc	r19, r23
    30ee:	b8 f3       	brcs	.-18     	; 0x30de <FillChar+0x6>
	     strMemory[i]=data;
	 }
}
    30f0:	08 95       	ret

000030f2 <ProcMessage91>:

void ProcMessage91(){
    30f2:	20 e0       	ldi	r18, 0x00	; 0
    30f4:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    30f6:	f9 01       	movw	r30, r18
    30f8:	ef 59       	subi	r30, 0x9F	; 159
    30fa:	f1 4f       	sbci	r31, 0xF1	; 241
    30fc:	d9 01       	movw	r26, r18
    30fe:	ab 50       	subi	r26, 0x0B	; 11
    3100:	b5 4f       	sbci	r27, 0xF5	; 245
    3102:	95 96       	adiw	r26, 0x25	; 37
    3104:	8c 91       	ld	r24, X
    3106:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    3108:	2f 5f       	subi	r18, 0xFF	; 255
    310a:	3f 4f       	sbci	r19, 0xFF	; 255
    310c:	26 30       	cpi	r18, 0x06	; 6
    310e:	31 05       	cpc	r19, r1
    3110:	91 f7       	brne	.-28     	; 0x30f6 <ProcMessage91+0x4>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    3112:	10 92 67 0e 	sts	0x0E67, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    3116:	80 91 20 0b 	lds	r24, 0x0B20
    311a:	80 93 9c 09 	sts	0x099C, r24
    311e:	80 91 21 0b 	lds	r24, 0x0B21
    3122:	80 93 9d 09 	sts	0x099D, r24
	 }Dest[Length]=0;
    3126:	10 92 9e 09 	sts	0x099E, r1
    312a:	20 e0       	ldi	r18, 0x00	; 0
    312c:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    312e:	f9 01       	movw	r30, r18
    3130:	ef 5e       	subi	r30, 0xEF	; 239
    3132:	f5 4f       	sbci	r31, 0xF5	; 245
    3134:	d9 01       	movw	r26, r18
    3136:	ab 50       	subi	r26, 0x0B	; 11
    3138:	b5 4f       	sbci	r27, 0xF5	; 245
    313a:	9d 96       	adiw	r26, 0x2d	; 45
    313c:	8c 91       	ld	r24, X
    313e:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    3140:	2f 5f       	subi	r18, 0xFF	; 255
    3142:	3f 4f       	sbci	r19, 0xFF	; 255
    3144:	2f 30       	cpi	r18, 0x0F	; 15
    3146:	31 05       	cpc	r19, r1
    3148:	91 f7       	brne	.-28     	; 0x312e <ProcMessage91+0x3c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    314a:	10 92 20 0a 	sts	0x0A20, r1
    314e:	20 e0       	ldi	r18, 0x00	; 0
    3150:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    3152:	f9 01       	movw	r30, r18
    3154:	ef 57       	subi	r30, 0x7F	; 127
    3156:	f8 4f       	sbci	r31, 0xF8	; 248
    3158:	d9 01       	movw	r26, r18
    315a:	ab 50       	subi	r26, 0x0B	; 11
    315c:	b5 4f       	sbci	r27, 0xF5	; 245
    315e:	dc 96       	adiw	r26, 0x3c	; 60
    3160:	8c 91       	ld	r24, X
    3162:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    3164:	2f 5f       	subi	r18, 0xFF	; 255
    3166:	3f 4f       	sbci	r19, 0xFF	; 255
    3168:	26 30       	cpi	r18, 0x06	; 6
    316a:	31 05       	cpc	r19, r1
    316c:	91 f7       	brne	.-28     	; 0x3152 <ProcMessage91+0x60>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    316e:	10 92 87 07 	sts	0x0787, r1
    3172:	20 e0       	ldi	r18, 0x00	; 0
    3174:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    3176:	f9 01       	movw	r30, r18
    3178:	eb 5a       	subi	r30, 0xAB	; 171
    317a:	fa 4f       	sbci	r31, 0xFA	; 250
    317c:	d9 01       	movw	r26, r18
    317e:	a9 5c       	subi	r26, 0xC9	; 201
    3180:	b4 4f       	sbci	r27, 0xF4	; 244
    3182:	8c 91       	ld	r24, X
    3184:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    3186:	2f 5f       	subi	r18, 0xFF	; 255
    3188:	3f 4f       	sbci	r19, 0xFF	; 255
    318a:	28 30       	cpi	r18, 0x08	; 8
    318c:	31 05       	cpc	r19, r1
    318e:	99 f7       	brne	.-26     	; 0x3176 <ProcMessage91+0x84>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    3190:	10 92 5d 05 	sts	0x055D, r1
    3194:	20 e0       	ldi	r18, 0x00	; 0
    3196:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    3198:	f9 01       	movw	r30, r18
    319a:	e5 57       	subi	r30, 0x75	; 117
    319c:	f2 4f       	sbci	r31, 0xF2	; 242
    319e:	d9 01       	movw	r26, r18
    31a0:	a1 5c       	subi	r26, 0xC1	; 193
    31a2:	b4 4f       	sbci	r27, 0xF4	; 244
    31a4:	8c 91       	ld	r24, X
    31a6:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    31a8:	2f 5f       	subi	r18, 0xFF	; 255
    31aa:	3f 4f       	sbci	r19, 0xFF	; 255
    31ac:	28 30       	cpi	r18, 0x08	; 8
    31ae:	31 05       	cpc	r19, r1
    31b0:	99 f7       	brne	.-26     	; 0x3198 <ProcMessage91+0xa6>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    31b2:	10 92 93 0d 	sts	0x0D93, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    31b6:	80 91 47 0b 	lds	r24, 0x0B47
    31ba:	80 93 6a 05 	sts	0x056A, r24
	 }Dest[Length]=0;
    31be:	10 92 6b 05 	sts	0x056B, r1
    31c2:	20 e0       	ldi	r18, 0x00	; 0
    31c4:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    31c6:	f9 01       	movw	r30, r18
    31c8:	e4 52       	subi	r30, 0x24	; 36
    31ca:	fb 4f       	sbci	r31, 0xFB	; 251
    31cc:	d9 01       	movw	r26, r18
    31ce:	a8 5b       	subi	r26, 0xB8	; 184
    31d0:	b4 4f       	sbci	r27, 0xF4	; 244
    31d2:	8c 91       	ld	r24, X
    31d4:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    31d6:	2f 5f       	subi	r18, 0xFF	; 255
    31d8:	3f 4f       	sbci	r19, 0xFF	; 255
    31da:	29 30       	cpi	r18, 0x09	; 9
    31dc:	31 05       	cpc	r19, r1
    31de:	99 f7       	brne	.-26     	; 0x31c6 <ProcMessage91+0xd4>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    31e0:	10 92 e5 04 	sts	0x04E5, r1
     StrPosCopy(rcv_trans,strPrice,60,6);
     StrPosCopy(rcv_trans,strVolume,66,8);
     StrPosCopy(rcv_trans,strAmount,74,8); 
	 StrPosCopy(rcv_trans,strStatus,82,1);
     StrPosCopy(rcv_trans,strSurcharge,83,9);    
}
    31e4:	08 95       	ret

000031e6 <IdentifyMessage>:
        //sprintf_P(strSerial,PSTR("RFID:%s"),strRFID);
        //_uart_print(0,1,strSerial);
	 }
}

void IdentifyMessage(char STX,unsigned int Length){
    31e6:	1f 93       	push	r17
   if (STX==0x01){
    31e8:	81 30       	cpi	r24, 0x01	; 1
    31ea:	09 f0       	breq	.+2      	; 0x31ee <IdentifyMessage+0x8>
    31ec:	5f c0       	rjmp	.+190    	; 0x32ac <IdentifyMessage+0xc6>
	    if ((Length==MSG00_LENGTH)||(MsgCode==0)) IsMessage00=True;//47
    31ee:	6f 32       	cpi	r22, 0x2F	; 47
    31f0:	71 05       	cpc	r23, r1
    31f2:	21 f0       	breq	.+8      	; 0x31fc <IdentifyMessage+0x16>
    31f4:	80 91 24 01 	lds	r24, 0x0124
    31f8:	88 23       	and	r24, r24
    31fa:	21 f4       	brne	.+8      	; 0x3204 <IdentifyMessage+0x1e>
    31fc:	81 e0       	ldi	r24, 0x01	; 1
    31fe:	80 93 b5 01 	sts	0x01B5, r24
    3202:	4a c0       	rjmp	.+148    	; 0x3298 <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG09_LENGTH)||(MsgCode==9)) IsMessage09=True;//615
    3204:	6c 36       	cpi	r22, 0x6C	; 108
    3206:	71 05       	cpc	r23, r1
    3208:	11 f0       	breq	.+4      	; 0x320e <IdentifyMessage+0x28>
    320a:	89 30       	cpi	r24, 0x09	; 9
    320c:	21 f4       	brne	.+8      	; 0x3216 <IdentifyMessage+0x30>
    320e:	81 e0       	ldi	r24, 0x01	; 1
    3210:	80 93 ba 01 	sts	0x01BA, r24
    3214:	41 c0       	rjmp	.+130    	; 0x3298 <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG11_LENGTH)||(MsgCode==11)) IsMessage11=True;//615
    3216:	92 e0       	ldi	r25, 0x02	; 2
    3218:	67 36       	cpi	r22, 0x67	; 103
    321a:	79 07       	cpc	r23, r25
    321c:	11 f0       	breq	.+4      	; 0x3222 <IdentifyMessage+0x3c>
    321e:	8b 30       	cpi	r24, 0x0B	; 11
    3220:	21 f4       	brne	.+8      	; 0x322a <IdentifyMessage+0x44>
    3222:	81 e0       	ldi	r24, 0x01	; 1
    3224:	80 93 b7 01 	sts	0x01B7, r24
    3228:	37 c0       	rjmp	.+110    	; 0x3298 <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG23_LENGTH)||(MsgCode==23)) IsMessage23=True;//145
    322a:	61 39       	cpi	r22, 0x91	; 145
    322c:	71 05       	cpc	r23, r1
    322e:	11 f0       	breq	.+4      	; 0x3234 <IdentifyMessage+0x4e>
    3230:	87 31       	cpi	r24, 0x17	; 23
    3232:	21 f4       	brne	.+8      	; 0x323c <IdentifyMessage+0x56>
    3234:	81 e0       	ldi	r24, 0x01	; 1
    3236:	80 93 b9 01 	sts	0x01B9, r24
    323a:	2e c0       	rjmp	.+92     	; 0x3298 <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG57_LENGTH)||(MsgCode==57)) IsMessage57=True;//230
    323c:	66 3e       	cpi	r22, 0xE6	; 230
    323e:	71 05       	cpc	r23, r1
    3240:	11 f0       	breq	.+4      	; 0x3246 <IdentifyMessage+0x60>
    3242:	89 33       	cpi	r24, 0x39	; 57
    3244:	21 f4       	brne	.+8      	; 0x324e <IdentifyMessage+0x68>
    3246:	81 e0       	ldi	r24, 0x01	; 1
    3248:	80 93 bc 01 	sts	0x01BC, r24
    324c:	25 c0       	rjmp	.+74     	; 0x3298 <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG99_LENGTH)||(MsgCode==99)) IsMessage99=True;//378
    324e:	91 e0       	ldi	r25, 0x01	; 1
    3250:	68 39       	cpi	r22, 0x98	; 152
    3252:	79 07       	cpc	r23, r25
    3254:	11 f0       	breq	.+4      	; 0x325a <IdentifyMessage+0x74>
    3256:	83 36       	cpi	r24, 0x63	; 99
    3258:	21 f4       	brne	.+8      	; 0x3262 <IdentifyMessage+0x7c>
    325a:	81 e0       	ldi	r24, 0x01	; 1
    325c:	80 93 b6 01 	sts	0x01B6, r24
    3260:	1b c0       	rjmp	.+54     	; 0x3298 <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG81_LENGTH)||(MsgCode==81)) IsMessage81=True;//426
    3262:	91 e0       	ldi	r25, 0x01	; 1
    3264:	66 3b       	cpi	r22, 0xB6	; 182
    3266:	79 07       	cpc	r23, r25
    3268:	11 f0       	breq	.+4      	; 0x326e <IdentifyMessage+0x88>
    326a:	81 35       	cpi	r24, 0x51	; 81
    326c:	21 f4       	brne	.+8      	; 0x3276 <IdentifyMessage+0x90>
    326e:	81 e0       	ldi	r24, 0x01	; 1
    3270:	80 93 bd 01 	sts	0x01BD, r24
    3274:	11 c0       	rjmp	.+34     	; 0x3298 <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG91_LENGTH)||(MsgCode==91)) IsMessage91=True;//426
    3276:	6c 35       	cpi	r22, 0x5C	; 92
    3278:	71 05       	cpc	r23, r1
    327a:	11 f0       	breq	.+4      	; 0x3280 <IdentifyMessage+0x9a>
    327c:	8b 35       	cpi	r24, 0x5B	; 91
    327e:	21 f4       	brne	.+8      	; 0x3288 <IdentifyMessage+0xa2>
    3280:	81 e0       	ldi	r24, 0x01	; 1
    3282:	80 93 be 01 	sts	0x01BE, r24
    3286:	08 c0       	rjmp	.+16     	; 0x3298 <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG21_LENGTH)||(MsgCode==21)) IsMessage21=True;//426
    3288:	66 35       	cpi	r22, 0x56	; 86
    328a:	71 05       	cpc	r23, r1
    328c:	11 f0       	breq	.+4      	; 0x3292 <IdentifyMessage+0xac>
    328e:	85 31       	cpi	r24, 0x15	; 21
    3290:	19 f4       	brne	.+6      	; 0x3298 <IdentifyMessage+0xb2>
    3292:	81 e0       	ldi	r24, 0x01	; 1
    3294:	80 93 b8 01 	sts	0x01B8, r24

        //EDC AdvanZ Respond
		if (IsMessage91==True){
    3298:	10 91 be 01 	lds	r17, 0x01BE
    329c:	11 30       	cpi	r17, 0x01	; 1
    329e:	31 f4       	brne	.+12     	; 0x32ac <IdentifyMessage+0xc6>
		    IsMessage91=False;
    32a0:	10 92 be 01 	sts	0x01BE, r1
		    ProcMessage91();
    32a4:	0e 94 79 18 	call	0x30f2	; 0x30f2 <ProcMessage91>
			IsSendMessageEDC=True;
    32a8:	10 93 ae 01 	sts	0x01AE, r17
		  }

//	  sprintf(SerialSend,"Length:%i",Length);	 
//	  _uart_print(1,0,SerialSend);
	 }
}
    32ac:	1f 91       	pop	r17
    32ae:	08 95       	ret

000032b0 <Tab>:

	  }
     return Result;     
}

void Tab(char *sTab, char nTab){
    32b0:	fc 01       	movw	r30, r24
    32b2:	dc 01       	movw	r26, r24
    32b4:	80 e0       	ldi	r24, 0x00	; 0
     char i;
	 for(i=0;i<nTab;i++){
	     sTab[i]=' ';
    32b6:	90 e2       	ldi	r25, 0x20	; 32
    32b8:	02 c0       	rjmp	.+4      	; 0x32be <Tab+0xe>
    32ba:	9d 93       	st	X+, r25
     return Result;     
}

void Tab(char *sTab, char nTab){
     char i;
	 for(i=0;i<nTab;i++){
    32bc:	8f 5f       	subi	r24, 0xFF	; 255
    32be:	86 17       	cp	r24, r22
    32c0:	e0 f3       	brcs	.-8      	; 0x32ba <Tab+0xa>
	     sTab[i]=' ';
	 }sTab[nTab]=0;
    32c2:	e6 0f       	add	r30, r22
    32c4:	f1 1d       	adc	r31, r1
    32c6:	10 82       	st	Z, r1
}
    32c8:	08 95       	ret

000032ca <_f_inttostr>:
}



//Old Function
void _f_inttostr(char* __string, unsigned long __value){
    32ca:	6f 92       	push	r6
    32cc:	7f 92       	push	r7
    32ce:	8f 92       	push	r8
    32d0:	9f 92       	push	r9
    32d2:	af 92       	push	r10
    32d4:	bf 92       	push	r11
    32d6:	cf 92       	push	r12
    32d8:	df 92       	push	r13
    32da:	ef 92       	push	r14
    32dc:	ff 92       	push	r15
    32de:	0f 93       	push	r16
    32e0:	1f 93       	push	r17
    32e2:	cf 93       	push	r28
    32e4:	df 93       	push	r29
    32e6:	ec 01       	movw	r28, r24
	char			__flag = 0, __i = 0, __count;
	unsigned long	__num, __devider = 1000000000;
	int				__tmp;

	if(__value == 0){
    32e8:	41 15       	cp	r20, r1
    32ea:	51 05       	cpc	r21, r1
    32ec:	61 05       	cpc	r22, r1
    32ee:	71 05       	cpc	r23, r1
    32f0:	21 f4       	brne	.+8      	; 0x32fa <_f_inttostr+0x30>
		__string[0] = '0';
    32f2:	80 e3       	ldi	r24, 0x30	; 48
    32f4:	88 83       	st	Y, r24
		__string[1] = '\0';
    32f6:	19 82       	std	Y+1, r1	; 0x01
    32f8:	48 c0       	rjmp	.+144    	; 0x338a <_f_inttostr+0xc0>
		return;
    32fa:	4a 01       	movw	r8, r20
    32fc:	5b 01       	movw	r10, r22
    32fe:	10 e0       	ldi	r17, 0x00	; 0
    3300:	00 e0       	ldi	r16, 0x00	; 0
    3302:	77 24       	eor	r7, r7
    3304:	c1 2c       	mov	r12, r1
    3306:	9a ec       	ldi	r25, 0xCA	; 202
    3308:	d9 2e       	mov	r13, r25
    330a:	9a e9       	ldi	r25, 0x9A	; 154
    330c:	e9 2e       	mov	r14, r25
    330e:	9b e3       	ldi	r25, 0x3B	; 59
    3310:	f9 2e       	mov	r15, r25
			if(!__flag)
				__flag = 1;
		}
		else
			if(__flag)
				__string[__i++] = 0x30;
    3312:	80 e3       	ldi	r24, 0x30	; 48
    3314:	68 2e       	mov	r6, r24
		return;
	}

	__num = __value;
	for(__count = 0; __count < 10; __count++){
		if(__num >= __devider){
    3316:	8c 14       	cp	r8, r12
    3318:	9d 04       	cpc	r9, r13
    331a:	ae 04       	cpc	r10, r14
    331c:	bf 04       	cpc	r11, r15
    331e:	d0 f0       	brcs	.+52     	; 0x3354 <_f_inttostr+0x8a>
			__tmp = (int)(__num / __devider);
    3320:	c5 01       	movw	r24, r10
    3322:	b4 01       	movw	r22, r8
    3324:	a7 01       	movw	r20, r14
    3326:	96 01       	movw	r18, r12
    3328:	0e 94 ba b8 	call	0x17174	; 0x17174 <__udivmodsi4>
    332c:	12 2f       	mov	r17, r18
			__num = __num % __devider;
    332e:	c5 01       	movw	r24, r10
    3330:	b4 01       	movw	r22, r8
    3332:	a7 01       	movw	r20, r14
    3334:	96 01       	movw	r18, r12
    3336:	0e 94 ba b8 	call	0x17174	; 0x17174 <__udivmodsi4>
    333a:	ac 01       	movw	r20, r24
    333c:	cb 01       	movw	r24, r22
    333e:	da 01       	movw	r26, r20
    3340:	4c 01       	movw	r8, r24
    3342:	5d 01       	movw	r10, r26
			__string[__i++] = __tmp + 0x30;
    3344:	fe 01       	movw	r30, r28
    3346:	e0 0f       	add	r30, r16
    3348:	f1 1d       	adc	r31, r1
    334a:	10 5d       	subi	r17, 0xD0	; 208
    334c:	10 83       	st	Z, r17
    334e:	0f 5f       	subi	r16, 0xFF	; 255
    3350:	11 e0       	ldi	r17, 0x01	; 1
    3352:	07 c0       	rjmp	.+14     	; 0x3362 <_f_inttostr+0x98>
			if(!__flag)
				__flag = 1;
		}
		else
			if(__flag)
    3354:	11 23       	and	r17, r17
    3356:	29 f0       	breq	.+10     	; 0x3362 <_f_inttostr+0x98>
				__string[__i++] = 0x30;
    3358:	fe 01       	movw	r30, r28
    335a:	e0 0f       	add	r30, r16
    335c:	f1 1d       	adc	r31, r1
    335e:	60 82       	st	Z, r6
    3360:	0f 5f       	subi	r16, 0xFF	; 255
		__string[1] = '\0';
		return;
	}

	__num = __value;
	for(__count = 0; __count < 10; __count++){
    3362:	73 94       	inc	r7
    3364:	8a e0       	ldi	r24, 0x0A	; 10
    3366:	78 16       	cp	r7, r24
    3368:	69 f0       	breq	.+26     	; 0x3384 <_f_inttostr+0xba>
				__flag = 1;
		}
		else
			if(__flag)
				__string[__i++] = 0x30;
		__devider = __devider / 10;
    336a:	c7 01       	movw	r24, r14
    336c:	b6 01       	movw	r22, r12
    336e:	2a e0       	ldi	r18, 0x0A	; 10
    3370:	30 e0       	ldi	r19, 0x00	; 0
    3372:	40 e0       	ldi	r20, 0x00	; 0
    3374:	50 e0       	ldi	r21, 0x00	; 0
    3376:	0e 94 ba b8 	call	0x17174	; 0x17174 <__udivmodsi4>
    337a:	c9 01       	movw	r24, r18
    337c:	da 01       	movw	r26, r20
    337e:	6c 01       	movw	r12, r24
    3380:	7d 01       	movw	r14, r26
    3382:	c9 cf       	rjmp	.-110    	; 0x3316 <_f_inttostr+0x4c>
	}
	__string[__i] = '\0';
    3384:	c0 0f       	add	r28, r16
    3386:	d1 1d       	adc	r29, r1
    3388:	18 82       	st	Y, r1
}
    338a:	df 91       	pop	r29
    338c:	cf 91       	pop	r28
    338e:	1f 91       	pop	r17
    3390:	0f 91       	pop	r16
    3392:	ff 90       	pop	r15
    3394:	ef 90       	pop	r14
    3396:	df 90       	pop	r13
    3398:	cf 90       	pop	r12
    339a:	bf 90       	pop	r11
    339c:	af 90       	pop	r10
    339e:	9f 90       	pop	r9
    33a0:	8f 90       	pop	r8
    33a2:	7f 90       	pop	r7
    33a4:	6f 90       	pop	r6
    33a6:	08 95       	ret

000033a8 <StrToRaw>:
			  }
		  }
	 }
}
                                       //12byte->6Byte         0 1 2 3  
void StrToRaw(char *Source,char *Dest){//Source: "1234567890AB"
    33a8:	dc 01       	movw	r26, r24
    33aa:	20 e0       	ldi	r18, 0x00	; 0
    33ac:	30 e0       	ldi	r19, 0x00	; 0
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    33ae:	9c 91       	ld	r25, X
    33b0:	90 53       	subi	r25, 0x30	; 48
    33b2:	9a 30       	cpi	r25, 0x0A	; 10
    33b4:	08 f0       	brcs	.+2      	; 0x33b8 <StrToRaw+0x10>
    33b6:	90 e0       	ldi	r25, 0x00	; 0
	 char xRaw=0;
	 for (i=0;i<6;i++){
	      xA=Ord(Source[(2*i)]);
		  xB=(0x0F&Ord(Source[(2*i)+1]));
	      xRaw=((xA<<4) | xB);
	      Dest[i]=xRaw;
    33b8:	11 96       	adiw	r26, 0x01	; 1
    33ba:	8c 91       	ld	r24, X
    33bc:	11 97       	sbiw	r26, 0x01	; 1
    33be:	80 53       	subi	r24, 0x30	; 48
    33c0:	8a 30       	cpi	r24, 0x0A	; 10
    33c2:	08 f0       	brcs	.+2      	; 0x33c6 <StrToRaw+0x1e>
    33c4:	80 e0       	ldi	r24, 0x00	; 0
    33c6:	fb 01       	movw	r30, r22
    33c8:	e2 0f       	add	r30, r18
    33ca:	f3 1f       	adc	r31, r19
    33cc:	8f 70       	andi	r24, 0x0F	; 15
    33ce:	92 95       	swap	r25
    33d0:	90 7f       	andi	r25, 0xF0	; 240
    33d2:	98 2b       	or	r25, r24
    33d4:	90 83       	st	Z, r25
    33d6:	2f 5f       	subi	r18, 0xFF	; 255
    33d8:	3f 4f       	sbci	r19, 0xFF	; 255
    33da:	12 96       	adiw	r26, 0x02	; 2
}
                                       //12byte->6Byte         0 1 2 3  
void StrToRaw(char *Source,char *Dest){//Source: "1234567890AB"
     char i,xA,xB;                //Dest  :  12345678 
	 char xRaw=0;
	 for (i=0;i<6;i++){
    33dc:	26 30       	cpi	r18, 0x06	; 6
    33de:	31 05       	cpc	r19, r1
    33e0:	31 f7       	brne	.-52     	; 0x33ae <StrToRaw+0x6>
	      xA=Ord(Source[(2*i)]);
		  xB=(0x0F&Ord(Source[(2*i)+1]));
	      xRaw=((xA<<4) | xB);
	      Dest[i]=xRaw;
	 }	      
}
    33e2:	08 95       	ret

000033e4 <RawToStr>:
void RawToStr(char *Source,char *Dest){//Source:   1234567890AB
    33e4:	cf 93       	push	r28
    33e6:	df 93       	push	r29
    33e8:	eb 01       	movw	r28, r22
    33ea:	db 01       	movw	r26, r22
    33ec:	20 e0       	ldi	r18, 0x00	; 0
    33ee:	30 e0       	ldi	r19, 0x00	; 0
     unsigned char i,xRaw,cA,cB;               //Dest  :  "12345678" 
	 for (i=0;i<6;i++){
	      cA=Chr(Source[i]>>4);
    33f0:	fc 01       	movw	r30, r24
    33f2:	e2 0f       	add	r30, r18
    33f4:	f3 1f       	adc	r31, r19
    33f6:	e0 81       	ld	r30, Z
    33f8:	4e 2f       	mov	r20, r30
    33fa:	42 95       	swap	r20
    33fc:	4f 70       	andi	r20, 0x0F	; 15
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    33fe:	4a 30       	cpi	r20, 0x0A	; 10
    3400:	10 f0       	brcs	.+4      	; 0x3406 <RawToStr+0x22>
    3402:	40 e3       	ldi	r20, 0x30	; 48
    3404:	01 c0       	rjmp	.+2      	; 0x3408 <RawToStr+0x24>
	    Result='0'+X;
    3406:	40 5d       	subi	r20, 0xD0	; 208
}
void RawToStr(char *Source,char *Dest){//Source:   1234567890AB
     unsigned char i,xRaw,cA,cB;               //Dest  :  "12345678" 
	 for (i=0;i<6;i++){
	      cA=Chr(Source[i]>>4);
	      cB=Chr(Source[i]&0x0F);
    3408:	ef 70       	andi	r30, 0x0F	; 15
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    340a:	ea 30       	cpi	r30, 0x0A	; 10
    340c:	10 f0       	brcs	.+4      	; 0x3412 <RawToStr+0x2e>
    340e:	e0 e3       	ldi	r30, 0x30	; 48
    3410:	01 c0       	rjmp	.+2      	; 0x3414 <RawToStr+0x30>
	    Result='0'+X;
    3412:	e0 5d       	subi	r30, 0xD0	; 208
void RawToStr(char *Source,char *Dest){//Source:   1234567890AB
     unsigned char i,xRaw,cA,cB;               //Dest  :  "12345678" 
	 for (i=0;i<6;i++){
	      cA=Chr(Source[i]>>4);
	      cB=Chr(Source[i]&0x0F);
          Dest[2*i]=cA;
    3414:	4c 93       	st	X, r20
          Dest[(2*i)+1]=cB;
    3416:	11 96       	adiw	r26, 0x01	; 1
    3418:	ec 93       	st	X, r30
    341a:	11 97       	sbiw	r26, 0x01	; 1
    341c:	2f 5f       	subi	r18, 0xFF	; 255
    341e:	3f 4f       	sbci	r19, 0xFF	; 255
    3420:	12 96       	adiw	r26, 0x02	; 2
	      Dest[i]=xRaw;
	 }	      
}
void RawToStr(char *Source,char *Dest){//Source:   1234567890AB
     unsigned char i,xRaw,cA,cB;               //Dest  :  "12345678" 
	 for (i=0;i<6;i++){
    3422:	26 30       	cpi	r18, 0x06	; 6
    3424:	31 05       	cpc	r19, r1
    3426:	21 f7       	brne	.-56     	; 0x33f0 <RawToStr+0xc>
	      cA=Chr(Source[i]>>4);
	      cB=Chr(Source[i]&0x0F);
          Dest[2*i]=cA;
          Dest[(2*i)+1]=cB;
	 }Dest[12]=0;
    3428:	1c 86       	std	Y+12, r1	; 0x0c
}
    342a:	df 91       	pop	r29
    342c:	cf 91       	pop	r28
    342e:	08 95       	ret

00003430 <CalcMinus>:
}

char CalcMinus(char A, char B){
     signed char xC;//,xA,xB;
	 char Result;
	 if (A>=B) xC=((A-'0')-(B-'0'));
    3430:	86 17       	cp	r24, r22
    3432:	08 f4       	brcc	.+2      	; 0x3436 <CalcMinus+0x6>
	 else xC=10+((A-'0')-(B-'0'));//
    3434:	86 5f       	subi	r24, 0xF6	; 246
    3436:	86 1b       	sub	r24, r22
	 Result='0'+xC;
  return Result;
}
    3438:	80 5d       	subi	r24, 0xD0	; 208
    343a:	08 95       	ret

0000343c <CalcPlus>:

char CalcPlus(char A, char B){
    343c:	80 56       	subi	r24, 0x60	; 96
    343e:	86 0f       	add	r24, r22
    3440:	6a e0       	ldi	r22, 0x0A	; 10
    3442:	0e 94 86 b8 	call	0x1710c	; 0x1710c <__divmodqi4>
     signed char xA,xB,xC;
	 char Result;
	 xC=((A-'0')+(B-'0'));
     Result='0'+(xC%10);  
   return Result;
}
    3446:	89 2f       	mov	r24, r25
    3448:	80 5d       	subi	r24, 0xD0	; 208
    344a:	08 95       	ret

0000344c <Chr>:
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    344c:	8a 30       	cpi	r24, 0x0A	; 10
    344e:	10 f0       	brcs	.+4      	; 0x3454 <Chr+0x8>
    3450:	80 e3       	ldi	r24, 0x30	; 48
    3452:	08 95       	ret
	    Result='0'+X;
    3454:	80 5d       	subi	r24, 0xD0	; 208
	 }
	return Result;
}
    3456:	08 95       	ret

00003458 <Ord>:
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    3458:	80 53       	subi	r24, 0x30	; 48
    345a:	8a 30       	cpi	r24, 0x0A	; 10
    345c:	08 f0       	brcs	.+2      	; 0x3460 <Ord+0x8>
    345e:	80 e0       	ldi	r24, 0x00	; 0
	    Result=c-'0';
	 }
	return Result;
}
    3460:	08 95       	ret

00003462 <GetTabSpace>:
	     StrCalc(TPLUS,prevSeg,currSeg,prevSeg);
	 }
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
    3462:	48 2f       	mov	r20, r24
    3464:	fb 01       	movw	r30, r22
     char i,nTab;
	 if (TabLength>0){
    3466:	18 16       	cp	r1, r24
    3468:	64 f4       	brge	.+24     	; 0x3482 <GetTabSpace+0x20>
		 nTab=TabLength;//%40;
    346a:	56 2f       	mov	r21, r22
    346c:	db 01       	movw	r26, r22
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    346e:	90 e2       	ldi	r25, 0x20	; 32
    3470:	9d 93       	st	X+, r25

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    3472:	8a 2f       	mov	r24, r26
    3474:	85 1b       	sub	r24, r21
    3476:	84 17       	cp	r24, r20
    3478:	d8 f3       	brcs	.-10     	; 0x3470 <GetTabSpace+0xe>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    347a:	e4 0f       	add	r30, r20
    347c:	f1 1d       	adc	r31, r1
    347e:	10 82       	st	Z, r1
    3480:	08 95       	ret
     }else{
	 strTab[0]=' ';
    3482:	80 e2       	ldi	r24, 0x20	; 32
    3484:	80 83       	st	Z, r24
	 strTab[1]=0;
    3486:	11 82       	std	Z+1, r1	; 0x01
    3488:	08 95       	ret

0000348a <GetBorderValue>:

}

char GetBorderValue(char BoderType){
     char Result=0;
	 switch (BoderType){
    348a:	86 30       	cpi	r24, 0x06	; 6
    348c:	51 f1       	breq	.+84     	; 0x34e2 <GetBorderValue+0x58>
    348e:	87 30       	cpi	r24, 0x07	; 7
    3490:	70 f4       	brcc	.+28     	; 0x34ae <GetBorderValue+0x24>
    3492:	83 30       	cpi	r24, 0x03	; 3
    3494:	11 f1       	breq	.+68     	; 0x34da <GetBorderValue+0x50>
    3496:	84 30       	cpi	r24, 0x04	; 4
    3498:	28 f4       	brcc	.+10     	; 0x34a4 <GetBorderValue+0x1a>
    349a:	81 30       	cpi	r24, 0x01	; 1
    349c:	c1 f0       	breq	.+48     	; 0x34ce <GetBorderValue+0x44>
    349e:	82 30       	cpi	r24, 0x02	; 2
    34a0:	c1 f4       	brne	.+48     	; 0x34d2 <GetBorderValue+0x48>
    34a2:	19 c0       	rjmp	.+50     	; 0x34d6 <GetBorderValue+0x4c>
    34a4:	84 30       	cpi	r24, 0x04	; 4
    34a6:	d9 f0       	breq	.+54     	; 0x34de <GetBorderValue+0x54>
    34a8:	85 30       	cpi	r24, 0x05	; 5
    34aa:	99 f4       	brne	.+38     	; 0x34d2 <GetBorderValue+0x48>
    34ac:	22 c0       	rjmp	.+68     	; 0x34f2 <GetBorderValue+0x68>
    34ae:	89 30       	cpi	r24, 0x09	; 9
    34b0:	f1 f0       	breq	.+60     	; 0x34ee <GetBorderValue+0x64>
    34b2:	8a 30       	cpi	r24, 0x0A	; 10
    34b4:	28 f4       	brcc	.+10     	; 0x34c0 <GetBorderValue+0x36>
    34b6:	87 30       	cpi	r24, 0x07	; 7
    34b8:	b1 f0       	breq	.+44     	; 0x34e6 <GetBorderValue+0x5c>
    34ba:	88 30       	cpi	r24, 0x08	; 8
    34bc:	51 f4       	brne	.+20     	; 0x34d2 <GetBorderValue+0x48>
    34be:	15 c0       	rjmp	.+42     	; 0x34ea <GetBorderValue+0x60>
    34c0:	8b 30       	cpi	r24, 0x0B	; 11
    34c2:	d9 f0       	breq	.+54     	; 0x34fa <GetBorderValue+0x70>
    34c4:	8b 30       	cpi	r24, 0x0B	; 11
    34c6:	b8 f0       	brcs	.+46     	; 0x34f6 <GetBorderValue+0x6c>
    34c8:	8c 30       	cpi	r24, 0x0C	; 12
    34ca:	19 f4       	brne	.+6      	; 0x34d2 <GetBorderValue+0x48>
    34cc:	18 c0       	rjmp	.+48     	; 0x34fe <GetBorderValue+0x74>
    34ce:	8a ed       	ldi	r24, 0xDA	; 218
    34d0:	08 95       	ret
    34d2:	80 e0       	ldi	r24, 0x00	; 0
    34d4:	08 95       	ret
    34d6:	82 ec       	ldi	r24, 0xC2	; 194
    34d8:	08 95       	ret
		case btTopLeft: 
		     Result=0xDA;
			 break;
		case btTopCenter: 
		     Result=0xC2;
			 break;
    34da:	8f eb       	ldi	r24, 0xBF	; 191
    34dc:	08 95       	ret
		case btTopRight:
		     Result=0xBF;		 
			 break;
    34de:	83 ec       	ldi	r24, 0xC3	; 195
    34e0:	08 95       	ret
		case btMiddleLeft: 
			 Result=0xC3;
			 break;
    34e2:	84 eb       	ldi	r24, 0xB4	; 180
    34e4:	08 95       	ret
		case btMiddleRight: 
			 Result=0xB4;
			 break;
    34e6:	80 ec       	ldi	r24, 0xC0	; 192
    34e8:	08 95       	ret
		case btBottomLeft: 
		     Result=0xC0;
			 break;
    34ea:	81 ec       	ldi	r24, 0xC1	; 193
    34ec:	08 95       	ret
		case btBottomCenter: 
			 Result=0xC1;
			 break;
    34ee:	89 ed       	ldi	r24, 0xD9	; 217
    34f0:	08 95       	ret
		case btBottomRight: 
			 Result=0xD9;
			 break;
    34f2:	85 ec       	ldi	r24, 0xC5	; 197
    34f4:	08 95       	ret
        case btMiddleCenter:
		     Result=0xC5;
		     break;
    34f6:	83 eb       	ldi	r24, 0xB3	; 179
    34f8:	08 95       	ret
		case btVertical: 
			 Result=0xB3;
			 break;
    34fa:	84 ec       	ldi	r24, 0xC4	; 196
    34fc:	08 95       	ret
		case btHorizontal:
			 Result=0xC4;
			 break;	 
    34fe:	8d e0       	ldi	r24, 0x0D	; 13
        case btNewLine:
		     Result=0x0D;
			 break;	 
	 }
   return Result;
}
    3500:	08 95       	ret

00003502 <InserBorder>:

void InserBorder(char BorderType, char *strPrnBuffer,char nLength,unsigned int *Pos){
    3502:	bf 92       	push	r11
    3504:	cf 92       	push	r12
    3506:	df 92       	push	r13
    3508:	ef 92       	push	r14
    350a:	ff 92       	push	r15
    350c:	0f 93       	push	r16
    350e:	1f 93       	push	r17
    3510:	cf 93       	push	r28
    3512:	df 93       	push	r29
    3514:	b8 2e       	mov	r11, r24
    3516:	8b 01       	movw	r16, r22
    3518:	e4 2e       	mov	r14, r20
    351a:	69 01       	movw	r12, r18
     char i;//,BorderValue=0;
	 unsigned int StartPos,iPos=0;
	 
	 iPos=*Pos;
    351c:	f9 01       	movw	r30, r18
    351e:	c0 81       	ld	r28, Z
    3520:	d1 81       	ldd	r29, Z+1	; 0x01
    3522:	0c 0f       	add	r16, r28
    3524:	1d 1f       	adc	r17, r29
    3526:	ff 24       	eor	r15, r15
    3528:	07 c0       	rjmp	.+14     	; 0x3538 <InserBorder+0x36>
	 StartPos=iPos;
	 for (i=0;i<nLength;i++){
	      strPrnBuffer[iPos]=GetBorderValue(BorderType);
    352a:	8b 2d       	mov	r24, r11
    352c:	0e 94 45 1a 	call	0x348a	; 0x348a <GetBorderValue>
    3530:	f8 01       	movw	r30, r16
    3532:	81 93       	st	Z+, r24
    3534:	8f 01       	movw	r16, r30
     char i;//,BorderValue=0;
	 unsigned int StartPos,iPos=0;
	 
	 iPos=*Pos;
	 StartPos=iPos;
	 for (i=0;i<nLength;i++){
    3536:	f3 94       	inc	r15
    3538:	fe 14       	cp	r15, r14
    353a:	b8 f3       	brcs	.-18     	; 0x352a <InserBorder+0x28>
	 //for (i=0;i<nLength;i++){
	 //     if (strPrnBuffer[i+StartPos]!=GetBorderValue(BorderType)){
//		      strPrnBuffer[i+StartPos]=GetBorderValue(BorderType);
//		  }
//	 }
     *Pos=iPos;
    353c:	ce 0d       	add	r28, r14
    353e:	d1 1d       	adc	r29, r1
    3540:	f6 01       	movw	r30, r12
    3542:	d1 83       	std	Z+1, r29	; 0x01
    3544:	c0 83       	st	Z, r28
}
    3546:	df 91       	pop	r29
    3548:	cf 91       	pop	r28
    354a:	1f 91       	pop	r17
    354c:	0f 91       	pop	r16
    354e:	ff 90       	pop	r15
    3550:	ef 90       	pop	r14
    3552:	df 90       	pop	r13
    3554:	cf 90       	pop	r12
    3556:	bf 90       	pop	r11
    3558:	08 95       	ret

0000355a <GeniusSendPumpStatus>:
   return Result;
}

void GeniusSendPumpStatus(char iPumpID){
     
}
    355a:	08 95       	ret

0000355c <GeniusSendStopPump>:
void GeniusSendStopPump(char iPumpID){
}
    355c:	08 95       	ret

0000355e <GeniusSendResumePump>:
void GeniusSendResumePump(char iPumpID){
}
    355e:	08 95       	ret

00003560 <GeniusSendPumpPreset>:
void GeniusSendPumpPreset(char iPumpID){
}
    3560:	08 95       	ret

00003562 <SetIncomingTransStatus>:
	 sprintf_P(strSend,PSTR("%d"),cSum);
	 _uart_print(1,1,strSend);	 
}


void SetIncomingTransStatus(char iPumpID,char xTransStatus){
    3562:	e8 2f       	mov	r30, r24
char iStatus,xMaskA,xMaskB,xMaskC,xPumpID;
	 xPumpID=(iPumpID&0x0F);
    3564:	28 2f       	mov	r18, r24
    3566:	2f 70       	andi	r18, 0x0F	; 15
     iStatus=IncomingTransaction[xPumpID/8];
    3568:	82 2f       	mov	r24, r18
    356a:	86 95       	lsr	r24
    356c:	86 95       	lsr	r24
    356e:	86 95       	lsr	r24
    3570:	a8 2f       	mov	r26, r24
    3572:	b0 e0       	ldi	r27, 0x00	; 0
    3574:	a1 55       	subi	r26, 0x51	; 81
    3576:	b2 4f       	sbci	r27, 0xF2	; 242
    3578:	4c 91       	ld	r20, X
	 if (xTransStatus==TS_NEW){
    357a:	62 30       	cpi	r22, 0x02	; 2
    357c:	59 f4       	brne	.+22     	; 0x3594 <SetIncomingTransStatus+0x32>
	     iStatus=(iStatus|(1<<(xPumpID%8)));	 
    357e:	27 70       	andi	r18, 0x07	; 7
    3580:	81 e0       	ldi	r24, 0x01	; 1
    3582:	90 e0       	ldi	r25, 0x00	; 0
    3584:	02 c0       	rjmp	.+4      	; 0x358a <SetIncomingTransStatus+0x28>
    3586:	88 0f       	add	r24, r24
    3588:	99 1f       	adc	r25, r25
    358a:	2a 95       	dec	r18
    358c:	e2 f7       	brpl	.-8      	; 0x3586 <SetIncomingTransStatus+0x24>
    358e:	48 2b       	or	r20, r24
		 IncomingTransaction[xPumpID/8]=iStatus;
    3590:	4c 93       	st	X, r20
    3592:	08 95       	ret
	 }else if (xTransStatus==TS_OLD){
    3594:	63 30       	cpi	r22, 0x03	; 3
    3596:	b1 f4       	brne	.+44     	; 0x35c4 <SetIncomingTransStatus+0x62>
		 xMaskA=(0xFE<<(xPumpID%8));
    3598:	27 70       	andi	r18, 0x07	; 7
    359a:	8e ef       	ldi	r24, 0xFE	; 254
    359c:	90 e0       	ldi	r25, 0x00	; 0
    359e:	01 c0       	rjmp	.+2      	; 0x35a2 <SetIncomingTransStatus+0x40>
    35a0:	88 0f       	add	r24, r24
    35a2:	2a 95       	dec	r18
    35a4:	ea f7       	brpl	.-6      	; 0x35a0 <SetIncomingTransStatus+0x3e>
		 xMaskB=(~xMaskA)>>1;
		 xMaskC=xMaskA|xMaskB;
		 iStatus=iStatus&xMaskC;
		 IncomingTransaction[iPumpID/8]=iStatus;
    35a6:	e6 95       	lsr	r30
    35a8:	e6 95       	lsr	r30
    35aa:	e6 95       	lsr	r30
    35ac:	f0 e0       	ldi	r31, 0x00	; 0
    35ae:	e1 55       	subi	r30, 0x51	; 81
    35b0:	f2 4f       	sbci	r31, 0xF2	; 242
    35b2:	28 2f       	mov	r18, r24
    35b4:	30 e0       	ldi	r19, 0x00	; 0
    35b6:	20 95       	com	r18
    35b8:	30 95       	com	r19
    35ba:	35 95       	asr	r19
    35bc:	27 95       	ror	r18
    35be:	82 2b       	or	r24, r18
    35c0:	84 23       	and	r24, r20
    35c2:	80 83       	st	Z, r24
    35c4:	08 95       	ret

000035c6 <GetIncomingTransStatus>:
	 }
}
char GetIncomingTransStatus(char iPumpID){
     char xPumpID,Result;
	 xPumpID=(iPumpID&0x0F);
    35c6:	8f 70       	andi	r24, 0x0F	; 15
	 Result=TS_NONE;
     if((IncomingTransaction[xPumpID/8]>>(xPumpID%8))==1){
    35c8:	e8 2f       	mov	r30, r24
    35ca:	e6 95       	lsr	r30
    35cc:	e6 95       	lsr	r30
    35ce:	e6 95       	lsr	r30
    35d0:	f0 e0       	ldi	r31, 0x00	; 0
    35d2:	e1 55       	subi	r30, 0x51	; 81
    35d4:	f2 4f       	sbci	r31, 0xF2	; 242
    35d6:	90 81       	ld	r25, Z
    35d8:	29 2f       	mov	r18, r25
    35da:	30 e0       	ldi	r19, 0x00	; 0
    35dc:	87 70       	andi	r24, 0x07	; 7
    35de:	02 c0       	rjmp	.+4      	; 0x35e4 <GetIncomingTransStatus+0x1e>
    35e0:	35 95       	asr	r19
    35e2:	27 95       	ror	r18
    35e4:	8a 95       	dec	r24
    35e6:	e2 f7       	brpl	.-8      	; 0x35e0 <GetIncomingTransStatus+0x1a>
    35e8:	21 30       	cpi	r18, 0x01	; 1
    35ea:	31 05       	cpc	r19, r1
    35ec:	11 f4       	brne	.+4      	; 0x35f2 <GetIncomingTransStatus+0x2c>
    35ee:	82 e0       	ldi	r24, 0x02	; 2
    35f0:	08 95       	ret
	     Result=TS_NEW;
	 }else
     if((IncomingTransaction[xPumpID/8]>>(xPumpID%8))==0){
    35f2:	23 2b       	or	r18, r19
    35f4:	11 f4       	brne	.+4      	; 0x35fa <GetIncomingTransStatus+0x34>
    35f6:	83 e0       	ldi	r24, 0x03	; 3
    35f8:	08 95       	ret
    35fa:	80 e0       	ldi	r24, 0x00	; 0
	     Result=TS_OLD;
	 }
   return Result;
}
    35fc:	08 95       	ret

000035fe <SetDispenser>:
		  }
	      break;
	 }
}

void SetDispenser(char DispType){
    35fe:	df 93       	push	r29
    3600:	cf 93       	push	r28
    3602:	00 d0       	rcall	.+0      	; 0x3604 <SetDispenser+0x6>
    3604:	00 d0       	rcall	.+0      	; 0x3606 <SetDispenser+0x8>
    3606:	0f 92       	push	r0
    3608:	cd b7       	in	r28, 0x3d	; 61
    360a:	de b7       	in	r29, 0x3e	; 62
    360c:	98 2f       	mov	r25, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    360e:	e1 99       	sbic	0x1c, 1	; 28
    3610:	fe cf       	rjmp	.-4      	; 0x360e <SetDispenser+0x10>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3612:	27 e3       	ldi	r18, 0x37	; 55
    3614:	31 e0       	ldi	r19, 0x01	; 1
    3616:	3f bb       	out	0x1f, r19	; 31
    3618:	2e bb       	out	0x1e, r18	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    361a:	e0 9a       	sbi	0x1c, 0	; 28
    361c:	8d b3       	in	r24, 0x1d	; 29
     char CurrentDispenser;
	 char i,DecimalSetting[5];
     CurrentDispenser=eeprom_read_byte(&DefDispenserBrand);
	 if (CurrentDispenser!=DispType){
    361e:	89 17       	cp	r24, r25
    3620:	51 f0       	breq	.+20     	; 0x3636 <SetDispenser+0x38>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    3622:	e1 99       	sbic	0x1c, 1	; 28
    3624:	fe cf       	rjmp	.-4      	; 0x3622 <SetDispenser+0x24>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3626:	3f bb       	out	0x1f, r19	; 31
    3628:	2e bb       	out	0x1e, r18	; 30
#endif
    EEDR = __value;
    362a:	9d bb       	out	0x1d, r25	; 29

    __asm__ __volatile__ (
    362c:	0f b6       	in	r0, 0x3f	; 63
    362e:	f8 94       	cli
    3630:	e2 9a       	sbi	0x1c, 2	; 28
    3632:	e1 9a       	sbi	0x1c, 1	; 28
    3634:	0f be       	out	0x3f, r0	; 63
	     eeprom_write_byte(&DefDispenserBrand,DispType);
	 }
     //Apply Setting for Pump respectively
	 switch(DispType){
    3636:	91 30       	cpi	r25, 0x01	; 1
    3638:	19 f0       	breq	.+6      	; 0x3640 <SetDispenser+0x42>
    363a:	92 30       	cpi	r25, 0x02	; 2
    363c:	71 f4       	brne	.+28     	; 0x365a <SetDispenser+0x5c>
    363e:	08 c0       	rjmp	.+16     	; 0x3650 <SetDispenser+0x52>
	 case ST_GILBARCO:
          DecimalSetting[0]=0;//Price
    3640:	19 82       	std	Y+1, r1	; 0x01
		  DecimalSetting[1]=3;//Volume
    3642:	83 e0       	ldi	r24, 0x03	; 3
    3644:	8a 83       	std	Y+2, r24	; 0x02
		  DecimalSetting[2]=0;//Money
    3646:	1b 82       	std	Y+3, r1	; 0x03
		  DecimalSetting[3]=2;//TotalVolume
    3648:	82 e0       	ldi	r24, 0x02	; 2
    364a:	8c 83       	std	Y+4, r24	; 0x04
		  DecimalSetting[4]=0;//TotalMoney 
    364c:	1d 82       	std	Y+5, r1	; 0x05
    364e:	05 c0       	rjmp	.+10     	; 0x365a <SetDispenser+0x5c>
	      break;
	 case ST_WAYNE_DART:
          DecimalSetting[0]=0;//Price
    3650:	19 82       	std	Y+1, r1	; 0x01
		  DecimalSetting[1]=2;//Volume
    3652:	9a 83       	std	Y+2, r25	; 0x02
		  DecimalSetting[2]=0;//Money
    3654:	1b 82       	std	Y+3, r1	; 0x03
		  DecimalSetting[3]=2;//TotalVolume
    3656:	9c 83       	std	Y+4, r25	; 0x04
		  DecimalSetting[4]=2;//TotalMoney 
    3658:	9d 83       	std	Y+5, r25	; 0x05
    365a:	29 e3       	ldi	r18, 0x39	; 57
    365c:	30 e0       	ldi	r19, 0x00	; 0
    365e:	fe 01       	movw	r30, r28
    3660:	31 96       	adiw	r30, 0x01	; 1
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    3662:	e1 99       	sbic	0x1c, 1	; 28
    3664:	fe cf       	rjmp	.-4      	; 0x3662 <SetDispenser+0x64>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3666:	3f bb       	out	0x1f, r19	; 31
    3668:	2e bb       	out	0x1e, r18	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    366a:	e0 9a       	sbi	0x1c, 0	; 28
    366c:	8d b3       	in	r24, 0x1d	; 29
	      break;	 
	 }
	 //ApplyChanges
     for (i=0;i<5;i++){
	     if (eeprom_read_byte(&DefDecimalPrice+i)!=DecimalSetting[i]){
    366e:	90 81       	ld	r25, Z
    3670:	89 17       	cp	r24, r25
    3672:	51 f0       	breq	.+20     	; 0x3688 <SetDispenser+0x8a>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    3674:	e1 99       	sbic	0x1c, 1	; 28
    3676:	fe cf       	rjmp	.-4      	; 0x3674 <SetDispenser+0x76>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3678:	3f bb       	out	0x1f, r19	; 31
    367a:	2e bb       	out	0x1e, r18	; 30
#endif
    EEDR = __value;
    367c:	9d bb       	out	0x1d, r25	; 29

    __asm__ __volatile__ (
    367e:	0f b6       	in	r0, 0x3f	; 63
    3680:	f8 94       	cli
    3682:	e2 9a       	sbi	0x1c, 2	; 28
    3684:	e1 9a       	sbi	0x1c, 1	; 28
    3686:	0f be       	out	0x3f, r0	; 63
    3688:	2f 5f       	subi	r18, 0xFF	; 255
    368a:	3f 4f       	sbci	r19, 0xFF	; 255
    368c:	31 96       	adiw	r30, 0x01	; 1
		  DecimalSetting[3]=2;//TotalVolume
		  DecimalSetting[4]=2;//TotalMoney 
	      break;	 
	 }
	 //ApplyChanges
     for (i=0;i<5;i++){
    368e:	80 e0       	ldi	r24, 0x00	; 0
    3690:	2e 33       	cpi	r18, 0x3E	; 62
    3692:	38 07       	cpc	r19, r24
    3694:	31 f7       	brne	.-52     	; 0x3662 <SetDispenser+0x64>
	     if (eeprom_read_byte(&DefDecimalPrice+i)!=DecimalSetting[i]){
		     eeprom_write_byte(&DefDecimalPrice+i,DecimalSetting[i]);
		 }
	 }
}
    3696:	0f 90       	pop	r0
    3698:	0f 90       	pop	r0
    369a:	0f 90       	pop	r0
    369c:	0f 90       	pop	r0
    369e:	0f 90       	pop	r0
    36a0:	cf 91       	pop	r28
    36a2:	df 91       	pop	r29
    36a4:	08 95       	ret

000036a6 <ComposeDatetime>:
	}
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalTotalMoney),2,Result);
}


void ComposeDatetime(char *Result){// 2010/10/01 16:27:44
    36a6:	df 93       	push	r29
    36a8:	cf 93       	push	r28
    36aa:	cd b7       	in	r28, 0x3d	; 61
    36ac:	de b7       	in	r29, 0x3e	; 62
    36ae:	62 97       	sbiw	r28, 0x12	; 18
    36b0:	0f b6       	in	r0, 0x3f	; 63
    36b2:	f8 94       	cli
    36b4:	de bf       	out	0x3e, r29	; 62
    36b6:	0f be       	out	0x3f, r0	; 63
    36b8:	cd bf       	out	0x3d, r28	; 61
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    36ba:	20 91 9a 05 	lds	r18, 0x059A
    36be:	2f 83       	std	Y+7, r18	; 0x07
    36c0:	20 91 9b 05 	lds	r18, 0x059B
    36c4:	28 87       	std	Y+8, r18	; 0x08
	 }Dest[Length]=0;
    36c6:	20 91 9d 05 	lds	r18, 0x059D
    36ca:	2c 83       	std	Y+4, r18	; 0x04
    36cc:	20 91 9e 05 	lds	r18, 0x059E
    36d0:	2d 83       	std	Y+5, r18	; 0x05
    36d2:	20 91 a0 05 	lds	r18, 0x05A0
    36d6:	29 83       	std	Y+1, r18	; 0x01
    36d8:	20 91 a1 05 	lds	r18, 0x05A1
    36dc:	2a 83       	std	Y+2, r18	; 0x02
    36de:	20 91 79 0a 	lds	r18, 0x0A79
    36e2:	2a 87       	std	Y+10, r18	; 0x0a
    36e4:	20 91 7a 0a 	lds	r18, 0x0A7A
    36e8:	2b 87       	std	Y+11, r18	; 0x0b
    36ea:	20 91 7c 0a 	lds	r18, 0x0A7C
    36ee:	2d 87       	std	Y+13, r18	; 0x0d
    36f0:	20 91 7d 0a 	lds	r18, 0x0A7D
    36f4:	2e 87       	std	Y+14, r18	; 0x0e
    36f6:	20 91 7f 0a 	lds	r18, 0x0A7F
    36fa:	28 8b       	std	Y+16, r18	; 0x10
    36fc:	20 91 80 0a 	lds	r18, 0x0A80
    3700:	29 8b       	std	Y+17, r18	; 0x11
    3702:	1a 8a       	std	Y+18, r1	; 0x12
    3704:	1f 86       	std	Y+15, r1	; 0x0f
    3706:	1c 86       	std	Y+12, r1	; 0x0c
    3708:	1b 82       	std	Y+3, r1	; 0x03
    370a:	1e 82       	std	Y+6, r1	; 0x06
    370c:	19 86       	std	Y+9, r1	; 0x09
     StrPosCopy(strSystemDate,sYear,6,2);

     StrPosCopy(strSystemTime,sHour,0,2);
     StrPosCopy(strSystemTime,sMinute,3,2);
     StrPosCopy(strSystemTime,sSecond,6,2);
	 sprintf_P(Result,PSTR("20%s/%s/%s %s:%s:%s"),sYear,sMonth,sDay,sHour,sMinute,sSecond);
    370e:	2d b7       	in	r18, 0x3d	; 61
    3710:	3e b7       	in	r19, 0x3e	; 62
    3712:	20 51       	subi	r18, 0x10	; 16
    3714:	30 40       	sbci	r19, 0x00	; 0
    3716:	0f b6       	in	r0, 0x3f	; 63
    3718:	f8 94       	cli
    371a:	3e bf       	out	0x3e, r19	; 62
    371c:	0f be       	out	0x3f, r0	; 63
    371e:	2d bf       	out	0x3d, r18	; 61
    3720:	ed b7       	in	r30, 0x3d	; 61
    3722:	fe b7       	in	r31, 0x3e	; 62
    3724:	31 96       	adiw	r30, 0x01	; 1
    3726:	ad b7       	in	r26, 0x3d	; 61
    3728:	be b7       	in	r27, 0x3e	; 62
    372a:	12 96       	adiw	r26, 0x02	; 2
    372c:	9c 93       	st	X, r25
    372e:	8e 93       	st	-X, r24
    3730:	11 97       	sbiw	r26, 0x01	; 1
    3732:	86 e5       	ldi	r24, 0x56	; 86
    3734:	93 e0       	ldi	r25, 0x03	; 3
    3736:	93 83       	std	Z+3, r25	; 0x03
    3738:	82 83       	std	Z+2, r24	; 0x02
    373a:	ce 01       	movw	r24, r28
    373c:	01 96       	adiw	r24, 0x01	; 1
    373e:	95 83       	std	Z+5, r25	; 0x05
    3740:	84 83       	std	Z+4, r24	; 0x04
    3742:	ce 01       	movw	r24, r28
    3744:	04 96       	adiw	r24, 0x04	; 4
    3746:	97 83       	std	Z+7, r25	; 0x07
    3748:	86 83       	std	Z+6, r24	; 0x06
    374a:	ce 01       	movw	r24, r28
    374c:	07 96       	adiw	r24, 0x07	; 7
    374e:	91 87       	std	Z+9, r25	; 0x09
    3750:	80 87       	std	Z+8, r24	; 0x08
    3752:	ce 01       	movw	r24, r28
    3754:	0a 96       	adiw	r24, 0x0a	; 10
    3756:	93 87       	std	Z+11, r25	; 0x0b
    3758:	82 87       	std	Z+10, r24	; 0x0a
    375a:	ce 01       	movw	r24, r28
    375c:	0d 96       	adiw	r24, 0x0d	; 13
    375e:	95 87       	std	Z+13, r25	; 0x0d
    3760:	84 87       	std	Z+12, r24	; 0x0c
    3762:	ce 01       	movw	r24, r28
    3764:	40 96       	adiw	r24, 0x10	; 16
    3766:	97 87       	std	Z+15, r25	; 0x0f
    3768:	86 87       	std	Z+14, r24	; 0x0e
    376a:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    376e:	2d b7       	in	r18, 0x3d	; 61
    3770:	3e b7       	in	r19, 0x3e	; 62
    3772:	20 5f       	subi	r18, 0xF0	; 240
    3774:	3f 4f       	sbci	r19, 0xFF	; 255
    3776:	0f b6       	in	r0, 0x3f	; 63
    3778:	f8 94       	cli
    377a:	3e bf       	out	0x3e, r19	; 62
    377c:	0f be       	out	0x3f, r0	; 63
    377e:	2d bf       	out	0x3d, r18	; 61
}
    3780:	62 96       	adiw	r28, 0x12	; 18
    3782:	0f b6       	in	r0, 0x3f	; 63
    3784:	f8 94       	cli
    3786:	de bf       	out	0x3e, r29	; 62
    3788:	0f be       	out	0x3f, r0	; 63
    378a:	cd bf       	out	0x3d, r28	; 61
    378c:	cf 91       	pop	r28
    378e:	df 91       	pop	r29
    3790:	08 95       	ret

00003792 <leadingZero>:
		}
     else {
	    sprintf_P(StrResult,PSTR("%d"),Val);
	 }
	 */
     sprintf_P(StrResult,PSTR("%.2d"),Val);
    3792:	00 d0       	rcall	.+0      	; 0x3794 <leadingZero+0x2>
    3794:	00 d0       	rcall	.+0      	; 0x3796 <leadingZero+0x4>
    3796:	00 d0       	rcall	.+0      	; 0x3798 <leadingZero+0x6>
    3798:	ed b7       	in	r30, 0x3d	; 61
    379a:	fe b7       	in	r31, 0x3e	; 62
    379c:	31 96       	adiw	r30, 0x01	; 1
    379e:	ad b7       	in	r26, 0x3d	; 61
    37a0:	be b7       	in	r27, 0x3e	; 62
    37a2:	12 96       	adiw	r26, 0x02	; 2
    37a4:	7c 93       	st	X, r23
    37a6:	6e 93       	st	-X, r22
    37a8:	11 97       	sbiw	r26, 0x01	; 1
    37aa:	2d e5       	ldi	r18, 0x5D	; 93
    37ac:	3d e0       	ldi	r19, 0x0D	; 13
    37ae:	33 83       	std	Z+3, r19	; 0x03
    37b0:	22 83       	std	Z+2, r18	; 0x02
    37b2:	84 83       	std	Z+4, r24	; 0x04
    37b4:	15 82       	std	Z+5, r1	; 0x05
    37b6:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    37ba:	8d b7       	in	r24, 0x3d	; 61
    37bc:	9e b7       	in	r25, 0x3e	; 62
    37be:	06 96       	adiw	r24, 0x06	; 6
    37c0:	0f b6       	in	r0, 0x3f	; 63
    37c2:	f8 94       	cli
    37c4:	9e bf       	out	0x3e, r25	; 62
    37c6:	0f be       	out	0x3f, r0	; 63
    37c8:	8d bf       	out	0x3d, r24	; 61

}
    37ca:	08 95       	ret

000037cc <UpdateSeqNum>:
	 sprintf_P(strIFT_ID,PSTR("%.2d"),IdIFT);
	 //leadingZero(IdIFT,strIFT_ID);
}

void UpdateSeqNum(){
     if (SeqNum<100)SeqNum++;
    37cc:	80 91 d1 01 	lds	r24, 0x01D1
    37d0:	84 36       	cpi	r24, 0x64	; 100
    37d2:	20 f4       	brcc	.+8      	; 0x37dc <UpdateSeqNum+0x10>
    37d4:	8f 5f       	subi	r24, 0xFF	; 255
    37d6:	80 93 d1 01 	sts	0x01D1, r24
    37da:	02 c0       	rjmp	.+4      	; 0x37e0 <UpdateSeqNum+0x14>
	 else SeqNum=0;
    37dc:	10 92 d1 01 	sts	0x01D1, r1
		}
     else {
	    sprintf_P(StrResult,PSTR("%d"),Val);
	 }
	 */
     sprintf_P(StrResult,PSTR("%.2d"),Val);
    37e0:	00 d0       	rcall	.+0      	; 0x37e2 <UpdateSeqNum+0x16>
    37e2:	00 d0       	rcall	.+0      	; 0x37e4 <UpdateSeqNum+0x18>
    37e4:	00 d0       	rcall	.+0      	; 0x37e6 <UpdateSeqNum+0x1a>
    37e6:	ed b7       	in	r30, 0x3d	; 61
    37e8:	fe b7       	in	r31, 0x3e	; 62
    37ea:	31 96       	adiw	r30, 0x01	; 1
    37ec:	8b ea       	ldi	r24, 0xAB	; 171
    37ee:	9d e0       	ldi	r25, 0x0D	; 13
    37f0:	ad b7       	in	r26, 0x3d	; 61
    37f2:	be b7       	in	r27, 0x3e	; 62
    37f4:	12 96       	adiw	r26, 0x02	; 2
    37f6:	9c 93       	st	X, r25
    37f8:	8e 93       	st	-X, r24
    37fa:	11 97       	sbiw	r26, 0x01	; 1
    37fc:	8d e5       	ldi	r24, 0x5D	; 93
    37fe:	9d e0       	ldi	r25, 0x0D	; 13
    3800:	93 83       	std	Z+3, r25	; 0x03
    3802:	82 83       	std	Z+2, r24	; 0x02
    3804:	80 91 d1 01 	lds	r24, 0x01D1
    3808:	84 83       	std	Z+4, r24	; 0x04
    380a:	15 82       	std	Z+5, r1	; 0x05
    380c:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    3810:	8d b7       	in	r24, 0x3d	; 61
    3812:	9e b7       	in	r25, 0x3e	; 62
    3814:	06 96       	adiw	r24, 0x06	; 6
    3816:	0f b6       	in	r0, 0x3f	; 63
    3818:	f8 94       	cli
    381a:	9e bf       	out	0x3e, r25	; 62
    381c:	0f be       	out	0x3f, r0	; 63
    381e:	8d bf       	out	0x3d, r24	; 61

void UpdateSeqNum(){
     if (SeqNum<100)SeqNum++;
	 else SeqNum=0;
	 leadingZero(SeqNum,strSeqNum);
} 
    3820:	08 95       	ret

00003822 <UpdateIFT_ID>:
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    3822:	e1 99       	sbic	0x1c, 1	; 28
    3824:	fe cf       	rjmp	.-4      	; 0x3822 <UpdateIFT_ID>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3826:	80 e0       	ldi	r24, 0x00	; 0
    3828:	90 e0       	ldi	r25, 0x00	; 0
    382a:	9f bb       	out	0x1f, r25	; 31
    382c:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    382e:	e0 9a       	sbi	0x1c, 0	; 28
    3830:	8d b3       	in	r24, 0x1d	; 29

void UpdateIFT_ID(){
     char IdIFT;
     //sprintf_P(strIFT_ID,PSTR("%.2d"),eeprom_read_byte(&DefIFT_ID));
	 IdIFT=(eeprom_read_byte(&DefIFT_ID)%100);
	 sprintf_P(strIFT_ID,PSTR("%.2d"),IdIFT);
    3832:	00 d0       	rcall	.+0      	; 0x3834 <UpdateIFT_ID+0x12>
    3834:	00 d0       	rcall	.+0      	; 0x3836 <UpdateIFT_ID+0x14>
    3836:	00 d0       	rcall	.+0      	; 0x3838 <UpdateIFT_ID+0x16>
    3838:	ed b7       	in	r30, 0x3d	; 61
    383a:	fe b7       	in	r31, 0x3e	; 62
    383c:	31 96       	adiw	r30, 0x01	; 1
    383e:	2c ec       	ldi	r18, 0xCC	; 204
    3840:	35 e0       	ldi	r19, 0x05	; 5
    3842:	ad b7       	in	r26, 0x3d	; 61
    3844:	be b7       	in	r27, 0x3e	; 62
    3846:	12 96       	adiw	r26, 0x02	; 2
    3848:	3c 93       	st	X, r19
    384a:	2e 93       	st	-X, r18
    384c:	11 97       	sbiw	r26, 0x01	; 1
    384e:	25 ec       	ldi	r18, 0xC5	; 197
    3850:	30 e2       	ldi	r19, 0x20	; 32
    3852:	33 83       	std	Z+3, r19	; 0x03
    3854:	22 83       	std	Z+2, r18	; 0x02
    3856:	64 e6       	ldi	r22, 0x64	; 100
    3858:	0e 94 7a b8 	call	0x170f4	; 0x170f4 <__udivmodqi4>
    385c:	94 83       	std	Z+4, r25	; 0x04
    385e:	15 82       	std	Z+5, r1	; 0x05
    3860:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    3864:	8d b7       	in	r24, 0x3d	; 61
    3866:	9e b7       	in	r25, 0x3e	; 62
    3868:	06 96       	adiw	r24, 0x06	; 6
    386a:	0f b6       	in	r0, 0x3f	; 63
    386c:	f8 94       	cli
    386e:	9e bf       	out	0x3e, r25	; 62
    3870:	0f be       	out	0x3f, r0	; 63
    3872:	8d bf       	out	0x3d, r24	; 61
	 //leadingZero(IdIFT,strIFT_ID);
}
    3874:	08 95       	ret

00003876 <MasterReset>:
	 }
}

#define DEF_OPERATOR_NAME "Mr.Big"

void MasterReset(){
    3876:	df 92       	push	r13
    3878:	ef 92       	push	r14
    387a:	ff 92       	push	r15
    387c:	0f 93       	push	r16
    387e:	1f 93       	push	r17
    3880:	df 93       	push	r29
    3882:	cf 93       	push	r28
    3884:	cd b7       	in	r28, 0x3d	; 61
    3886:	de b7       	in	r29, 0x3e	; 62
    3888:	ec 97       	sbiw	r28, 0x3c	; 60
    388a:	0f b6       	in	r0, 0x3f	; 63
    388c:	f8 94       	cli
    388e:	de bf       	out	0x3e, r29	; 62
    3890:	0f be       	out	0x3f, r0	; 63
    3892:	cd bf       	out	0x3d, r28	; 61
     char strEEP[50];
	 char xArray[10];
     //Restore All Stored EEPROM data to the Default
     sprintf_P(strEEP,PSTR(DEF_OPERATOR_NAME));
    3894:	00 d0       	rcall	.+0      	; 0x3896 <MasterReset+0x20>
    3896:	00 d0       	rcall	.+0      	; 0x3898 <MasterReset+0x22>
    3898:	8e 01       	movw	r16, r28
    389a:	05 5f       	subi	r16, 0xF5	; 245
    389c:	1f 4f       	sbci	r17, 0xFF	; 255
    389e:	ed b7       	in	r30, 0x3d	; 61
    38a0:	fe b7       	in	r31, 0x3e	; 62
    38a2:	12 83       	std	Z+2, r17	; 0x02
    38a4:	01 83       	std	Z+1, r16	; 0x01
    38a6:	85 e3       	ldi	r24, 0x35	; 53
    38a8:	93 e0       	ldi	r25, 0x03	; 3
    38aa:	94 83       	std	Z+4, r25	; 0x04
    38ac:	83 83       	std	Z+3, r24	; 0x03
    38ae:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    38b2:	0f 90       	pop	r0
    38b4:	0f 90       	pop	r0
    38b6:	0f 90       	pop	r0
    38b8:	0f 90       	pop	r0
    38ba:	85 e1       	ldi	r24, 0x15	; 21
    38bc:	90 e0       	ldi	r25, 0x00	; 0
    38be:	b8 01       	movw	r22, r16
    38c0:	43 e1       	ldi	r20, 0x13	; 19
    38c2:	50 e0       	ldi	r21, 0x00	; 0
    38c4:	2e ef       	ldi	r18, 0xFE	; 254
    38c6:	32 e1       	ldi	r19, 0x12	; 18
    38c8:	0e 94 96 b5 	call	0x16b2c	; 0x16b2c <__eewr_block>
	 eeprom_write_block((const void*)&strEEP, (void*) &DefOperatorName, sizeof(DefOperatorName));

	 xArray[0]=192;	 xArray[1]=168; 	 xArray[2]=16;	 xArray[3]=70; 
    38cc:	e0 ec       	ldi	r30, 0xC0	; 192
    38ce:	de 2e       	mov	r13, r30
    38d0:	d9 82       	std	Y+1, r13	; 0x01
    38d2:	78 ea       	ldi	r23, 0xA8	; 168
    38d4:	e7 2e       	mov	r14, r23
    38d6:	ea 82       	std	Y+2, r14	; 0x02
    38d8:	60 e1       	ldi	r22, 0x10	; 16
    38da:	f6 2e       	mov	r15, r22
    38dc:	fb 82       	std	Y+3, r15	; 0x03
    38de:	86 e4       	ldi	r24, 0x46	; 70
    38e0:	8c 83       	std	Y+4, r24	; 0x04
    38e2:	88 e2       	ldi	r24, 0x28	; 40
    38e4:	90 e0       	ldi	r25, 0x00	; 0
    38e6:	8e 01       	movw	r16, r28
    38e8:	0f 5f       	subi	r16, 0xFF	; 255
    38ea:	1f 4f       	sbci	r17, 0xFF	; 255
    38ec:	b8 01       	movw	r22, r16
    38ee:	44 e0       	ldi	r20, 0x04	; 4
    38f0:	50 e0       	ldi	r21, 0x00	; 0
    38f2:	2e ef       	ldi	r18, 0xFE	; 254
    38f4:	32 e1       	ldi	r19, 0x12	; 18
    38f6:	0e 94 96 b5 	call	0x16b2c	; 0x16b2c <__eewr_block>
	 eeprom_write_block((const void*) &xArray, (void*) &DefClientIP, 4);

	 xArray[0]=192;	 xArray[1]=168; 	 xArray[2]=16;	 xArray[3]=180; 
    38fa:	d9 82       	std	Y+1, r13	; 0x01
    38fc:	ea 82       	std	Y+2, r14	; 0x02
    38fe:	fb 82       	std	Y+3, r15	; 0x03
    3900:	84 eb       	ldi	r24, 0xB4	; 180
    3902:	8c 83       	std	Y+4, r24	; 0x04
    3904:	8c e2       	ldi	r24, 0x2C	; 44
    3906:	90 e0       	ldi	r25, 0x00	; 0
    3908:	b8 01       	movw	r22, r16
    390a:	44 e0       	ldi	r20, 0x04	; 4
    390c:	50 e0       	ldi	r21, 0x00	; 0
    390e:	2e ef       	ldi	r18, 0xFE	; 254
    3910:	32 e1       	ldi	r19, 0x12	; 18
    3912:	0e 94 96 b5 	call	0x16b2c	; 0x16b2c <__eewr_block>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    3916:	e1 99       	sbic	0x1c, 1	; 28
    3918:	fe cf       	rjmp	.-4      	; 0x3916 <MasterReset+0xa0>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    391a:	80 e3       	ldi	r24, 0x30	; 48
    391c:	90 e0       	ldi	r25, 0x00	; 0
    391e:	9f bb       	out	0x1f, r25	; 31
    3920:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    3922:	81 e0       	ldi	r24, 0x01	; 1
    3924:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    3926:	0f b6       	in	r0, 0x3f	; 63
    3928:	f8 94       	cli
    392a:	e2 9a       	sbi	0x1c, 2	; 28
    392c:	e1 9a       	sbi	0x1c, 1	; 28
    392e:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    3930:	e1 99       	sbic	0x1c, 1	; 28
    3932:	fe cf       	rjmp	.-4      	; 0x3930 <MasterReset+0xba>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3934:	81 e3       	ldi	r24, 0x31	; 49
    3936:	90 e0       	ldi	r25, 0x00	; 0
    3938:	9f bb       	out	0x1f, r25	; 31
    393a:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    393c:	87 e0       	ldi	r24, 0x07	; 7
    393e:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    3940:	0f b6       	in	r0, 0x3f	; 63
    3942:	f8 94       	cli
    3944:	e2 9a       	sbi	0x1c, 2	; 28
    3946:	e1 9a       	sbi	0x1c, 1	; 28
    3948:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    394a:	e1 99       	sbic	0x1c, 1	; 28
    394c:	fe cf       	rjmp	.-4      	; 0x394a <MasterReset+0xd4>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    394e:	82 e3       	ldi	r24, 0x32	; 50
    3950:	90 e0       	ldi	r25, 0x00	; 0
    3952:	9f bb       	out	0x1f, r25	; 31
    3954:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    3956:	85 e0       	ldi	r24, 0x05	; 5
    3958:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    395a:	0f b6       	in	r0, 0x3f	; 63
    395c:	f8 94       	cli
    395e:	e2 9a       	sbi	0x1c, 2	; 28
    3960:	e1 9a       	sbi	0x1c, 1	; 28
    3962:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    3964:	e1 99       	sbic	0x1c, 1	; 28
    3966:	fe cf       	rjmp	.-4      	; 0x3964 <MasterReset+0xee>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3968:	83 e3       	ldi	r24, 0x33	; 51
    396a:	90 e0       	ldi	r25, 0x00	; 0
    396c:	9f bb       	out	0x1f, r25	; 31
    396e:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    3970:	82 e0       	ldi	r24, 0x02	; 2
    3972:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    3974:	0f b6       	in	r0, 0x3f	; 63
    3976:	f8 94       	cli
    3978:	e2 9a       	sbi	0x1c, 2	; 28
    397a:	e1 9a       	sbi	0x1c, 1	; 28
    397c:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    397e:	e1 99       	sbic	0x1c, 1	; 28
    3980:	fe cf       	rjmp	.-4      	; 0x397e <MasterReset+0x108>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3982:	84 e3       	ldi	r24, 0x34	; 52
    3984:	90 e0       	ldi	r25, 0x00	; 0
    3986:	9f bb       	out	0x1f, r25	; 31
    3988:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    398a:	1d ba       	out	0x1d, r1	; 29

    __asm__ __volatile__ (
    398c:	0f b6       	in	r0, 0x3f	; 63
    398e:	f8 94       	cli
    3990:	e2 9a       	sbi	0x1c, 2	; 28
    3992:	e1 9a       	sbi	0x1c, 1	; 28
    3994:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    3996:	e1 99       	sbic	0x1c, 1	; 28
    3998:	fe cf       	rjmp	.-4      	; 0x3996 <MasterReset+0x120>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    399a:	85 e3       	ldi	r24, 0x35	; 53
    399c:	90 e0       	ldi	r25, 0x00	; 0
    399e:	9f bb       	out	0x1f, r25	; 31
    39a0:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    39a2:	83 e0       	ldi	r24, 0x03	; 3
    39a4:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    39a6:	0f b6       	in	r0, 0x3f	; 63
    39a8:	f8 94       	cli
    39aa:	e2 9a       	sbi	0x1c, 2	; 28
    39ac:	e1 9a       	sbi	0x1c, 1	; 28
    39ae:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    39b0:	e1 99       	sbic	0x1c, 1	; 28
    39b2:	fe cf       	rjmp	.-4      	; 0x39b0 <MasterReset+0x13a>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    39b4:	86 e3       	ldi	r24, 0x36	; 54
    39b6:	90 e0       	ldi	r25, 0x00	; 0
    39b8:	9f bb       	out	0x1f, r25	; 31
    39ba:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    39bc:	1d ba       	out	0x1d, r1	; 29

    __asm__ __volatile__ (
    39be:	0f b6       	in	r0, 0x3f	; 63
    39c0:	f8 94       	cli
    39c2:	e2 9a       	sbi	0x1c, 2	; 28
    39c4:	e1 9a       	sbi	0x1c, 1	; 28
    39c6:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    39c8:	e1 99       	sbic	0x1c, 1	; 28
    39ca:	fe cf       	rjmp	.-4      	; 0x39c8 <MasterReset+0x152>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    39cc:	87 e3       	ldi	r24, 0x37	; 55
    39ce:	90 e0       	ldi	r25, 0x00	; 0
    39d0:	9f bb       	out	0x1f, r25	; 31
    39d2:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    39d4:	81 e0       	ldi	r24, 0x01	; 1
    39d6:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    39d8:	0f b6       	in	r0, 0x3f	; 63
    39da:	f8 94       	cli
    39dc:	e2 9a       	sbi	0x1c, 2	; 28
    39de:	e1 9a       	sbi	0x1c, 1	; 28
    39e0:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    39e2:	e1 99       	sbic	0x1c, 1	; 28
    39e4:	fe cf       	rjmp	.-4      	; 0x39e2 <MasterReset+0x16c>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    39e6:	88 e3       	ldi	r24, 0x38	; 56
    39e8:	90 e0       	ldi	r25, 0x00	; 0
    39ea:	9f bb       	out	0x1f, r25	; 31
    39ec:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    39ee:	81 e0       	ldi	r24, 0x01	; 1
    39f0:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    39f2:	0f b6       	in	r0, 0x3f	; 63
    39f4:	f8 94       	cli
    39f6:	e2 9a       	sbi	0x1c, 2	; 28
    39f8:	e1 9a       	sbi	0x1c, 1	; 28
    39fa:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    39fc:	e1 99       	sbic	0x1c, 1	; 28
    39fe:	fe cf       	rjmp	.-4      	; 0x39fc <MasterReset+0x186>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3a00:	89 e3       	ldi	r24, 0x39	; 57
    3a02:	90 e0       	ldi	r25, 0x00	; 0
    3a04:	9f bb       	out	0x1f, r25	; 31
    3a06:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    3a08:	1d ba       	out	0x1d, r1	; 29

    __asm__ __volatile__ (
    3a0a:	0f b6       	in	r0, 0x3f	; 63
    3a0c:	f8 94       	cli
    3a0e:	e2 9a       	sbi	0x1c, 2	; 28
    3a10:	e1 9a       	sbi	0x1c, 1	; 28
    3a12:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    3a14:	e1 99       	sbic	0x1c, 1	; 28
    3a16:	fe cf       	rjmp	.-4      	; 0x3a14 <MasterReset+0x19e>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3a18:	8a e3       	ldi	r24, 0x3A	; 58
    3a1a:	90 e0       	ldi	r25, 0x00	; 0
    3a1c:	9f bb       	out	0x1f, r25	; 31
    3a1e:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    3a20:	83 e0       	ldi	r24, 0x03	; 3
    3a22:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    3a24:	0f b6       	in	r0, 0x3f	; 63
    3a26:	f8 94       	cli
    3a28:	e2 9a       	sbi	0x1c, 2	; 28
    3a2a:	e1 9a       	sbi	0x1c, 1	; 28
    3a2c:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    3a2e:	e1 99       	sbic	0x1c, 1	; 28
    3a30:	fe cf       	rjmp	.-4      	; 0x3a2e <MasterReset+0x1b8>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3a32:	8b e3       	ldi	r24, 0x3B	; 59
    3a34:	90 e0       	ldi	r25, 0x00	; 0
    3a36:	9f bb       	out	0x1f, r25	; 31
    3a38:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    3a3a:	1d ba       	out	0x1d, r1	; 29

    __asm__ __volatile__ (
    3a3c:	0f b6       	in	r0, 0x3f	; 63
    3a3e:	f8 94       	cli
    3a40:	e2 9a       	sbi	0x1c, 2	; 28
    3a42:	e1 9a       	sbi	0x1c, 1	; 28
    3a44:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    3a46:	e1 99       	sbic	0x1c, 1	; 28
    3a48:	fe cf       	rjmp	.-4      	; 0x3a46 <MasterReset+0x1d0>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3a4a:	8c e3       	ldi	r24, 0x3C	; 60
    3a4c:	90 e0       	ldi	r25, 0x00	; 0
    3a4e:	9f bb       	out	0x1f, r25	; 31
    3a50:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    3a52:	82 e0       	ldi	r24, 0x02	; 2
    3a54:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    3a56:	0f b6       	in	r0, 0x3f	; 63
    3a58:	f8 94       	cli
    3a5a:	e2 9a       	sbi	0x1c, 2	; 28
    3a5c:	e1 9a       	sbi	0x1c, 1	; 28
    3a5e:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    3a60:	e1 99       	sbic	0x1c, 1	; 28
    3a62:	fe cf       	rjmp	.-4      	; 0x3a60 <MasterReset+0x1ea>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3a64:	8d e3       	ldi	r24, 0x3D	; 61
    3a66:	90 e0       	ldi	r25, 0x00	; 0
    3a68:	9f bb       	out	0x1f, r25	; 31
    3a6a:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    3a6c:	1d ba       	out	0x1d, r1	; 29

    __asm__ __volatile__ (
    3a6e:	0f b6       	in	r0, 0x3f	; 63
    3a70:	f8 94       	cli
    3a72:	e2 9a       	sbi	0x1c, 2	; 28
    3a74:	e1 9a       	sbi	0x1c, 1	; 28
    3a76:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    3a78:	e1 99       	sbic	0x1c, 1	; 28
    3a7a:	fe cf       	rjmp	.-4      	; 0x3a78 <MasterReset+0x202>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3a7c:	8e e3       	ldi	r24, 0x3E	; 62
    3a7e:	90 e0       	ldi	r25, 0x00	; 0
    3a80:	9f bb       	out	0x1f, r25	; 31
    3a82:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    3a84:	8c e2       	ldi	r24, 0x2C	; 44
    3a86:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    3a88:	0f b6       	in	r0, 0x3f	; 63
    3a8a:	f8 94       	cli
    3a8c:	e2 9a       	sbi	0x1c, 2	; 28
    3a8e:	e1 9a       	sbi	0x1c, 1	; 28
    3a90:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    3a92:	e1 99       	sbic	0x1c, 1	; 28
    3a94:	fe cf       	rjmp	.-4      	; 0x3a92 <MasterReset+0x21c>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3a96:	8f e3       	ldi	r24, 0x3F	; 63
    3a98:	90 e0       	ldi	r25, 0x00	; 0
    3a9a:	9f bb       	out	0x1f, r25	; 31
    3a9c:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    3a9e:	9e e2       	ldi	r25, 0x2E	; 46
    3aa0:	9d bb       	out	0x1d, r25	; 29

    __asm__ __volatile__ (
    3aa2:	0f b6       	in	r0, 0x3f	; 63
    3aa4:	f8 94       	cli
    3aa6:	e2 9a       	sbi	0x1c, 2	; 28
    3aa8:	e1 9a       	sbi	0x1c, 1	; 28
    3aaa:	0f be       	out	0x3f, r0	; 63
	 eeprom_write_byte(&DefDecimalTotalVolume,2);
	 eeprom_write_byte(&DefDecimalTotalMoney,0);
	 eeprom_write_byte(&DefDecimalMark,',');
	 eeprom_write_byte(&DefCurrencyMark,'.');

	 xArray[0]=',';	 xArray[1]='.'; 	 xArray[2]=' ';	 xArray[3]='/';  xArray[4]='-'; 
    3aac:	8c e2       	ldi	r24, 0x2C	; 44
    3aae:	89 83       	std	Y+1, r24	; 0x01
    3ab0:	9a 83       	std	Y+2, r25	; 0x02
    3ab2:	80 e2       	ldi	r24, 0x20	; 32
    3ab4:	8b 83       	std	Y+3, r24	; 0x03
    3ab6:	8f e2       	ldi	r24, 0x2F	; 47
    3ab8:	8c 83       	std	Y+4, r24	; 0x04
    3aba:	8d e2       	ldi	r24, 0x2D	; 45
    3abc:	8d 83       	std	Y+5, r24	; 0x05
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    3abe:	80 e4       	ldi	r24, 0x40	; 64
    3ac0:	90 e0       	ldi	r25, 0x00	; 0
    3ac2:	8e 01       	movw	r16, r28
    3ac4:	0f 5f       	subi	r16, 0xFF	; 255
    3ac6:	1f 4f       	sbci	r17, 0xFF	; 255
    3ac8:	b8 01       	movw	r22, r16
    3aca:	45 e0       	ldi	r20, 0x05	; 5
    3acc:	50 e0       	ldi	r21, 0x00	; 0
    3ace:	2e ef       	ldi	r18, 0xFE	; 254
    3ad0:	32 e1       	ldi	r19, 0x12	; 18
    3ad2:	0e 94 96 b5 	call	0x16b2c	; 0x16b2c <__eewr_block>
	 eeprom_write_block((const void*) &xArray, (void*) &DefMarkMap, 5);

	 xArray[0]=1;	 xArray[1]=2; 	 xArray[2]=0;	 xArray[3]=0; xArray[4]=0;	 xArray[5]=0; xArray[6]=0;	 	 
    3ad6:	81 e0       	ldi	r24, 0x01	; 1
    3ad8:	89 83       	std	Y+1, r24	; 0x01
    3ada:	82 e0       	ldi	r24, 0x02	; 2
    3adc:	8a 83       	std	Y+2, r24	; 0x02
    3ade:	1b 82       	std	Y+3, r1	; 0x03
    3ae0:	1c 82       	std	Y+4, r1	; 0x04
    3ae2:	1d 82       	std	Y+5, r1	; 0x05
    3ae4:	1e 82       	std	Y+6, r1	; 0x06
    3ae6:	1f 82       	std	Y+7, r1	; 0x07
    3ae8:	85 e4       	ldi	r24, 0x45	; 69
    3aea:	90 e0       	ldi	r25, 0x00	; 0
    3aec:	b8 01       	movw	r22, r16
    3aee:	48 e0       	ldi	r20, 0x08	; 8
    3af0:	50 e0       	ldi	r21, 0x00	; 0
    3af2:	2e ef       	ldi	r18, 0xFE	; 254
    3af4:	32 e1       	ldi	r19, 0x12	; 18
    3af6:	0e 94 96 b5 	call	0x16b2c	; 0x16b2c <__eewr_block>
	 eeprom_write_block((const void*) &xArray, (void*) &DefPumpMap, 8);
	 eeprom_write_block((const void*) &xArray, (void*) &DefPumpLabel, 8);

      

}
    3afa:	8d e4       	ldi	r24, 0x4D	; 77
    3afc:	90 e0       	ldi	r25, 0x00	; 0
    3afe:	b8 01       	movw	r22, r16
    3b00:	48 e0       	ldi	r20, 0x08	; 8
    3b02:	50 e0       	ldi	r21, 0x00	; 0
    3b04:	2e ef       	ldi	r18, 0xFE	; 254
    3b06:	32 e1       	ldi	r19, 0x12	; 18
    3b08:	0e 94 96 b5 	call	0x16b2c	; 0x16b2c <__eewr_block>
    3b0c:	ec 96       	adiw	r28, 0x3c	; 60
    3b0e:	0f b6       	in	r0, 0x3f	; 63
    3b10:	f8 94       	cli
    3b12:	de bf       	out	0x3e, r29	; 62
    3b14:	0f be       	out	0x3f, r0	; 63
    3b16:	cd bf       	out	0x3d, r28	; 61
    3b18:	cf 91       	pop	r28
    3b1a:	df 91       	pop	r29
    3b1c:	1f 91       	pop	r17
    3b1e:	0f 91       	pop	r16
    3b20:	ff 90       	pop	r15
    3b22:	ef 90       	pop	r14
    3b24:	df 90       	pop	r13
    3b26:	08 95       	ret

00003b28 <procMessage21>:
       StrPosCopy(rcv_trans,strFreeMessageLine3,79,20);
       StrPosCopy(rcv_trans,strFreeMessageLine4,99,20);
	 return Result;
}

char procMessage21(){
    3b28:	af 92       	push	r10
    3b2a:	bf 92       	push	r11
    3b2c:	cf 92       	push	r12
    3b2e:	df 92       	push	r13
    3b30:	ef 92       	push	r14
    3b32:	ff 92       	push	r15
    3b34:	0f 93       	push	r16
    3b36:	1f 93       	push	r17
    3b38:	df 93       	push	r29
    3b3a:	cf 93       	push	r28
    3b3c:	cd b7       	in	r28, 0x3d	; 61
    3b3e:	de b7       	in	r29, 0x3e	; 62
    3b40:	2b 97       	sbiw	r28, 0x0b	; 11
    3b42:	0f b6       	in	r0, 0x3f	; 63
    3b44:	f8 94       	cli
    3b46:	de bf       	out	0x3e, r29	; 62
    3b48:	0f be       	out	0x3f, r0	; 63
    3b4a:	cd bf       	out	0x3d, r28	; 61
    3b4c:	09 e0       	ldi	r16, 0x09	; 9
    3b4e:	11 e0       	ldi	r17, 0x01	; 1
    3b50:	aa e1       	ldi	r26, 0x1A	; 26
    3b52:	ea 2e       	mov	r14, r26
    3b54:	ab e0       	ldi	r26, 0x0B	; 11
    3b56:	fa 2e       	mov	r15, r26
    3b58:	6e 01       	movw	r12, r28
    3b5a:	08 94       	sec
    3b5c:	c1 1c       	adc	r12, r1
    3b5e:	d1 1c       	adc	r13, r1
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    3b60:	fb e0       	ldi	r31, 0x0B	; 11
    3b62:	af 2e       	mov	r10, r31
    3b64:	b1 2c       	mov	r11, r1
    3b66:	ac 0e       	add	r10, r28
    3b68:	bd 1e       	adc	r11, r29
       StrPosCopy(rcv_trans,strFreeMessageLine3,79,20);
       StrPosCopy(rcv_trans,strFreeMessageLine4,99,20);
	 return Result;
}

char procMessage21(){
    3b6a:	f6 01       	movw	r30, r12
    3b6c:	d7 01       	movw	r26, r14
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    3b6e:	8d 91       	ld	r24, X+
    3b70:	81 93       	st	Z+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    3b72:	ea 15       	cp	r30, r10
    3b74:	fb 05       	cpc	r31, r11
    3b76:	d9 f7       	brne	.-10     	; 0x3b6e <procMessage21+0x46>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    3b78:	1b 86       	std	Y+11, r1	; 0x0b
    3b7a:	c8 01       	movw	r24, r16
    3b7c:	b6 01       	movw	r22, r12
    3b7e:	4b e0       	ldi	r20, 0x0B	; 11
    3b80:	50 e0       	ldi	r21, 0x00	; 0
    3b82:	2e ef       	ldi	r18, 0xFE	; 254
    3b84:	32 e1       	ldi	r19, 0x12	; 18
    3b86:	0e 94 96 b5 	call	0x16b2c	; 0x16b2c <__eewr_block>
    3b8a:	05 5f       	subi	r16, 0xF5	; 245
    3b8c:	1f 4f       	sbci	r17, 0xFF	; 255
    3b8e:	8a e0       	ldi	r24, 0x0A	; 10
    3b90:	90 e0       	ldi	r25, 0x00	; 0
    3b92:	e8 0e       	add	r14, r24
    3b94:	f9 1e       	adc	r15, r25
}

char procMessage21(){
     char i,Result,strBankName[11];
	 Result=0;
	 for(i=0;i<4;i++){
    3b96:	91 e0       	ldi	r25, 0x01	; 1
    3b98:	05 33       	cpi	r16, 0x35	; 53
    3b9a:	19 07       	cpc	r17, r25
    3b9c:	31 f7       	brne	.-52     	; 0x3b6a <procMessage21+0x42>
         StrPosCopy(rcv_trans,strBankName,(37+(i*10)),10);
		 //Result=((Result<<1)|SaveToEEPROM(strBankName,DefBankName[i],11)); 
		 eeprom_write_block((const void*)&strBankName, (void*)&DefBankName[i], 11);
	 }
	 return Result;
}
    3b9e:	80 e0       	ldi	r24, 0x00	; 0
    3ba0:	2b 96       	adiw	r28, 0x0b	; 11
    3ba2:	0f b6       	in	r0, 0x3f	; 63
    3ba4:	f8 94       	cli
    3ba6:	de bf       	out	0x3e, r29	; 62
    3ba8:	0f be       	out	0x3f, r0	; 63
    3baa:	cd bf       	out	0x3d, r28	; 61
    3bac:	cf 91       	pop	r28
    3bae:	df 91       	pop	r29
    3bb0:	1f 91       	pop	r17
    3bb2:	0f 91       	pop	r16
    3bb4:	ff 90       	pop	r15
    3bb6:	ef 90       	pop	r14
    3bb8:	df 90       	pop	r13
    3bba:	cf 90       	pop	r12
    3bbc:	bf 90       	pop	r11
    3bbe:	af 90       	pop	r10
    3bc0:	08 95       	ret

00003bc2 <GetFIPAddr>:
	    Result=PPumpID[FIPAddr-1];
	 }
   return Result;
}

char GetFIPAddr(char iPumpID){
    3bc2:	ff 92       	push	r15
    3bc4:	0f 93       	push	r16
    3bc6:	1f 93       	push	r17
    3bc8:	df 93       	push	r29
    3bca:	cf 93       	push	r28
    3bcc:	cd b7       	in	r28, 0x3d	; 61
    3bce:	de b7       	in	r29, 0x3e	; 62
    3bd0:	28 97       	sbiw	r28, 0x08	; 8
    3bd2:	0f b6       	in	r0, 0x3f	; 63
    3bd4:	f8 94       	cli
    3bd6:	de bf       	out	0x3e, r29	; 62
    3bd8:	0f be       	out	0x3f, r0	; 63
    3bda:	cd bf       	out	0x3d, r28	; 61
    3bdc:	f8 2e       	mov	r15, r24
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    3bde:	8e 01       	movw	r16, r28
    3be0:	0f 5f       	subi	r16, 0xFF	; 255
    3be2:	1f 4f       	sbci	r17, 0xFF	; 255
    3be4:	c8 01       	movw	r24, r16
    3be6:	65 e4       	ldi	r22, 0x45	; 69
    3be8:	70 e0       	ldi	r23, 0x00	; 0
    3bea:	48 e0       	ldi	r20, 0x08	; 8
    3bec:	50 e0       	ldi	r21, 0x00	; 0
    3bee:	26 ef       	ldi	r18, 0xF6	; 246
    3bf0:	32 e1       	ldi	r19, 0x12	; 18
    3bf2:	0e 94 7a b5 	call	0x16af4	; 0x16af4 <__eerd_block>
    3bf6:	f8 01       	movw	r30, r16
char i,PPumpID[8],Result;     
	 Result=0; 
	 eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap,8);
     for(i=0;i<8;i++){
    3bf8:	9e 01       	movw	r18, r28
    3bfa:	27 5f       	subi	r18, 0xF7	; 247
    3bfc:	3f 4f       	sbci	r19, 0xFF	; 255
    3bfe:	9e 2f       	mov	r25, r30
    3c00:	90 1b       	sub	r25, r16
	     if (PPumpID[i]==iPumpID){
    3c02:	80 81       	ld	r24, Z
    3c04:	8f 15       	cp	r24, r15
    3c06:	19 f4       	brne	.+6      	; 0x3c0e <GetFIPAddr+0x4c>
		     Result=i+1;
    3c08:	89 2f       	mov	r24, r25
    3c0a:	8f 5f       	subi	r24, 0xFF	; 255
    3c0c:	05 c0       	rjmp	.+10     	; 0x3c18 <GetFIPAddr+0x56>
			 break;
    3c0e:	31 96       	adiw	r30, 0x01	; 1

char GetFIPAddr(char iPumpID){
char i,PPumpID[8],Result;     
	 Result=0; 
	 eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap,8);
     for(i=0;i<8;i++){
    3c10:	e2 17       	cp	r30, r18
    3c12:	f3 07       	cpc	r31, r19
    3c14:	a1 f7       	brne	.-24     	; 0x3bfe <GetFIPAddr+0x3c>
    3c16:	80 e0       	ldi	r24, 0x00	; 0
		     Result=i+1;
			 break;
		 }
	 }
   return Result;
}
    3c18:	28 96       	adiw	r28, 0x08	; 8
    3c1a:	0f b6       	in	r0, 0x3f	; 63
    3c1c:	f8 94       	cli
    3c1e:	de bf       	out	0x3e, r29	; 62
    3c20:	0f be       	out	0x3f, r0	; 63
    3c22:	cd bf       	out	0x3d, r28	; 61
    3c24:	cf 91       	pop	r28
    3c26:	df 91       	pop	r29
    3c28:	1f 91       	pop	r17
    3c2a:	0f 91       	pop	r16
    3c2c:	ff 90       	pop	r15
    3c2e:	08 95       	ret

00003c30 <UpdateStandaloneStatus>:
		 sprintf_P(lcdteks,PSTR("%s"),SPump);
         lcd_print(4,1,lcdteks);
     	 }
}

void UpdateStandaloneStatus(char xPumpID,char xPumpStatus){//xPumpID: (1-16)&0x0F
    3c30:	ff 92       	push	r15
    3c32:	0f 93       	push	r16
    3c34:	1f 93       	push	r17
    3c36:	cf 93       	push	r28
    3c38:	df 93       	push	r29
    3c3a:	28 2f       	mov	r18, r24
    3c3c:	f6 2e       	mov	r15, r22
char strSend[20],iPumpID; //[xxxxxxxxxPx]
char iAddr;

	 if (xPumpID<16){
    3c3e:	80 31       	cpi	r24, 0x10	; 16
    3c40:	08 f0       	brcs	.+2      	; 0x3c44 <UpdateStandaloneStatus+0x14>
    3c42:	4e c0       	rjmp	.+156    	; 0x3ce0 <UpdateStandaloneStatus+0xb0>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    3c44:	e1 99       	sbic	0x1c, 1	; 28
    3c46:	fe cf       	rjmp	.-4      	; 0x3c44 <UpdateStandaloneStatus+0x14>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3c48:	87 e3       	ldi	r24, 0x37	; 55
    3c4a:	91 e0       	ldi	r25, 0x01	; 1
    3c4c:	9f bb       	out	0x1f, r25	; 31
    3c4e:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    3c50:	e0 9a       	sbi	0x1c, 0	; 28
    3c52:	8d b3       	in	r24, 0x1d	; 29
	     DispenserBrand=eeprom_read_byte(&DefDispenserBrand);
    3c54:	80 93 61 01 	sts	0x0161, r24
	     switch(DispenserBrand){
    3c58:	81 50       	subi	r24, 0x01	; 1
    3c5a:	82 30       	cpi	r24, 0x02	; 2
    3c5c:	08 f4       	brcc	.+2      	; 0x3c60 <UpdateStandaloneStatus+0x30>
    3c5e:	82 2f       	mov	r24, r18
	     case ST_WAYNE_DART:
              iPumpID=xPumpID;
	          break;				   
	     }

		 iAddr=GetFIPAddr(iPumpID);
    3c60:	0e 94 e1 1d 	call	0x3bc2	; 0x3bc2 <GetFIPAddr>
		 if (iAddr>0){
    3c64:	88 23       	and	r24, r24
    3c66:	e1 f1       	breq	.+120    	; 0x3ce0 <UpdateStandaloneStatus+0xb0>
		     iAddr=iAddr-1;
			 if (strPumpStatus[iAddr]!=GetPumpStatusLabel(PS_PRINT_READY)){//iFdiiiiiiiiiiiii
    3c68:	81 50       	subi	r24, 0x01	; 1
    3c6a:	c8 2f       	mov	r28, r24
    3c6c:	d0 e0       	ldi	r29, 0x00	; 0
    3c6e:	80 e1       	ldi	r24, 0x10	; 16
    3c70:	0e 94 93 13 	call	0x2726	; 0x2726 <GetPumpStatusLabel>
    3c74:	8e 01       	movw	r16, r28
    3c76:	0e 5e       	subi	r16, 0xEE	; 238
    3c78:	1e 4f       	sbci	r17, 0xFE	; 254
    3c7a:	f8 01       	movw	r30, r16
    3c7c:	90 81       	ld	r25, Z
    3c7e:	98 17       	cp	r25, r24
    3c80:	b1 f0       	breq	.+44     	; 0x3cae <UpdateStandaloneStatus+0x7e>
		         if (xPumpStatus!=PS_PRINT_READY)
    3c82:	f0 e1       	ldi	r31, 0x10	; 16
    3c84:	ff 16       	cp	r15, r31
    3c86:	21 f0       	breq	.+8      	; 0x3c90 <UpdateStandaloneStatus+0x60>
				     CurrentPumpStatus[iAddr]=xPumpStatus;
    3c88:	fe 01       	movw	r30, r28
    3c8a:	ee 59       	subi	r30, 0x9E	; 158
    3c8c:	fe 4f       	sbci	r31, 0xFE	; 254
    3c8e:	f0 82       	st	Z, r15
			     strPumpStatus[iAddr]=GetPumpStatusLabel(xPumpStatus);
    3c90:	8f 2d       	mov	r24, r15
    3c92:	0e 94 93 13 	call	0x2726	; 0x2726 <GetPumpStatusLabel>
    3c96:	8e 01       	movw	r16, r28
    3c98:	0e 5e       	subi	r16, 0xEE	; 238
    3c9a:	1e 4f       	sbci	r17, 0xFE	; 254
    3c9c:	f8 01       	movw	r30, r16
    3c9e:	80 83       	st	Z, r24
                 if (xPumpStatus==PS_FINISH_TOTALIZER)
    3ca0:	f5 e1       	ldi	r31, 0x15	; 21
    3ca2:	ff 16       	cp	r15, r31
    3ca4:	c1 f4       	brne	.+48     	; 0x3cd6 <UpdateStandaloneStatus+0xa6>
				     strPumpStatus[iAddr]=GetPumpStatusLabel(CurrentPumpStatus[iAddr]);
    3ca6:	ce 59       	subi	r28, 0x9E	; 158
    3ca8:	de 4f       	sbci	r29, 0xFE	; 254
    3caa:	88 81       	ld	r24, Y
    3cac:	10 c0       	rjmp	.+32     	; 0x3cce <UpdateStandaloneStatus+0x9e>
    3cae:	fe 01       	movw	r30, r28
    3cb0:	ee 59       	subi	r30, 0x9E	; 158
    3cb2:	fe 4f       	sbci	r31, 0xFE	; 254
		     }else if ((strPumpStatus[iAddr]==GetPumpStatusLabel(PS_PRINT_READY))||(xPumpStatus==PUMP_FEOT)||(xPumpStatus==PS_PRINTED)||(xPumpStatus==PS_TOTALIZER)){//P
			     if (xPumpStatus==PS_PRINTED){
    3cb4:	81 e1       	ldi	r24, 0x11	; 17
    3cb6:	f8 16       	cp	r15, r24
    3cb8:	11 f4       	brne	.+4      	; 0x3cbe <UpdateStandaloneStatus+0x8e>
				 //New

				     //if (CurrentPumpStatus[iAddr]!=GetPumpStatusLabel(PS_PRINT_READY))
			             strPumpStatus[iAddr]=GetPumpStatusLabel(CurrentPumpStatus[iAddr]);
    3cba:	80 81       	ld	r24, Z
    3cbc:	08 c0       	rjmp	.+16     	; 0x3cce <UpdateStandaloneStatus+0x9e>
					 //    CurrentPumpStatus[iAddr]=PUMP_OFF;
					 //    strPumpStatus[iAddr]=GetPumpStatusLabel(PUMP_OFF);
					 //}

				  }
			     else CurrentPumpStatus[iAddr]=xPumpStatus;			 
    3cbe:	f0 82       	st	Z, r15
			 if (xPumpStatus==PUMP_FEOT){
    3cc0:	8b e0       	ldi	r24, 0x0B	; 11
    3cc2:	f8 16       	cp	r15, r24
    3cc4:	21 f0       	breq	.+8      	; 0x3cce <UpdateStandaloneStatus+0x9e>
			     CurrentPumpStatus[iAddr]=xPumpStatus;
			     strPumpStatus[iAddr]=GetPumpStatusLabel(CurrentPumpStatus[iAddr]);
				 }
             else if (xPumpStatus==PS_TOTALIZER){
    3cc6:	f4 e1       	ldi	r31, 0x14	; 20
    3cc8:	ff 16       	cp	r15, r31
    3cca:	29 f4       	brne	.+10     	; 0x3cd6 <UpdateStandaloneStatus+0xa6>
			      strPumpStatus[iAddr]=GetPumpStatusLabel(xPumpStatus);
    3ccc:	84 e1       	ldi	r24, 0x14	; 20
    3cce:	0e 94 93 13 	call	0x2726	; 0x2726 <GetPumpStatusLabel>
    3cd2:	f8 01       	movw	r30, r16
    3cd4:	80 83       	st	Z, r24
				 }
		 }		 	     
         strPumpStatus[16]=0;
    3cd6:	10 92 22 01 	sts	0x0122, r1
	     IsNewPumpStatus=True;		 
    3cda:	81 e0       	ldi	r24, 0x01	; 1
    3cdc:	80 93 11 01 	sts	0x0111, r24
		 }		 
	 }
}
    3ce0:	df 91       	pop	r29
    3ce2:	cf 91       	pop	r28
    3ce4:	1f 91       	pop	r17
    3ce6:	0f 91       	pop	r16
    3ce8:	ff 90       	pop	r15
    3cea:	08 95       	ret

00003cec <GetPumpID>:
     StrPosCopy(strSystemTime,sSecond,6,2);
	 sprintf_P(Result,PSTR("20%s/%s/%s %s:%s:%s"),sYear,sMonth,sDay,sHour,sMinute,sSecond);
}


char GetPumpID(char FIPAddr){//Find Stored PumpID in PumpMap
    3cec:	1f 93       	push	r17
    3cee:	df 93       	push	r29
    3cf0:	cf 93       	push	r28
    3cf2:	cd b7       	in	r28, 0x3d	; 61
    3cf4:	de b7       	in	r29, 0x3e	; 62
    3cf6:	28 97       	sbiw	r28, 0x08	; 8
    3cf8:	0f b6       	in	r0, 0x3f	; 63
    3cfa:	f8 94       	cli
    3cfc:	de bf       	out	0x3e, r29	; 62
    3cfe:	0f be       	out	0x3f, r0	; 63
    3d00:	cd bf       	out	0x3d, r28	; 61
    3d02:	18 2f       	mov	r17, r24
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    3d04:	ce 01       	movw	r24, r28
    3d06:	01 96       	adiw	r24, 0x01	; 1
    3d08:	65 e4       	ldi	r22, 0x45	; 69
    3d0a:	70 e0       	ldi	r23, 0x00	; 0
    3d0c:	48 e0       	ldi	r20, 0x08	; 8
    3d0e:	50 e0       	ldi	r21, 0x00	; 0
    3d10:	26 ef       	ldi	r18, 0xF6	; 246
    3d12:	32 e1       	ldi	r19, 0x12	; 18
    3d14:	0e 94 7a b5 	call	0x16af4	; 0x16af4 <__eerd_block>
     char PPumpID[8],Result;     
     eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap,8);
	 Result=0;
	 if ((FIPAddr>0) && (FIPAddr<8)){
    3d18:	81 2f       	mov	r24, r17
    3d1a:	81 50       	subi	r24, 0x01	; 1
    3d1c:	87 30       	cpi	r24, 0x07	; 7
    3d1e:	10 f0       	brcs	.+4      	; 0x3d24 <GetPumpID+0x38>
    3d20:	80 e0       	ldi	r24, 0x00	; 0
    3d22:	04 c0       	rjmp	.+8      	; 0x3d2c <GetPumpID+0x40>
	    Result=PPumpID[FIPAddr-1];
    3d24:	fe 01       	movw	r30, r28
    3d26:	e1 0f       	add	r30, r17
    3d28:	f1 1d       	adc	r31, r1
    3d2a:	80 81       	ld	r24, Z
	 }
   return Result;
}
    3d2c:	28 96       	adiw	r28, 0x08	; 8
    3d2e:	0f b6       	in	r0, 0x3f	; 63
    3d30:	f8 94       	cli
    3d32:	de bf       	out	0x3e, r29	; 62
    3d34:	0f be       	out	0x3f, r0	; 63
    3d36:	cd bf       	out	0x3d, r28	; 61
    3d38:	cf 91       	pop	r28
    3d3a:	df 91       	pop	r29
    3d3c:	1f 91       	pop	r17
    3d3e:	08 95       	ret

00003d40 <GetTotalizerData>:
	 if (TType==TMONEY)eeprom_write_block((const void*)&rawValue,(void*)&(TotalMoney[TAddr][iPumpAddr][iGrade]), sizeof(rawValue));
}



void GetTotalizerData(char TType, char TAddr, char xPumpAddr, char xGradeAddr, char *strValue){// 0 1 1 "0000000"
    3d40:	0f 93       	push	r16
    3d42:	1f 93       	push	r17
    3d44:	df 93       	push	r29
    3d46:	cf 93       	push	r28
    3d48:	00 d0       	rcall	.+0      	; 0x3d4a <GetTotalizerData+0xa>
    3d4a:	00 d0       	rcall	.+0      	; 0x3d4c <GetTotalizerData+0xc>
    3d4c:	00 d0       	rcall	.+0      	; 0x3d4e <GetTotalizerData+0xe>
    3d4e:	cd b7       	in	r28, 0x3d	; 61
    3d50:	de b7       	in	r29, 0x3e	; 62
    3d52:	96 2f       	mov	r25, r22
     char rawValue[6],iPumpAddr,iGrade;

	 iPumpAddr=(xPumpAddr&0x0F);
    3d54:	4f 70       	andi	r20, 0x0F	; 15
	 if ((xGradeAddr>=1)&&(xGradeAddr<=6))
    3d56:	21 50       	subi	r18, 0x01	; 1
    3d58:	26 30       	cpi	r18, 0x06	; 6
    3d5a:	08 f4       	brcc	.+2      	; 0x3d5e <GetTotalizerData+0x1e>
    3d5c:	52 2f       	mov	r21, r18
	     iGrade=xGradeAddr-1;
     
//TotalVolume[2][16][6][6];
//GetTotalizerData(TVOLUME,TOTALIZER_LAST,PumpNum,xGrade,strLastVolume);
	 if (TType==TVOLUME)eeprom_read_block((void*) &rawValue, (const void*) &(TotalVolume[TAddr][iPumpAddr][iGrade]), sizeof(rawValue));
    3d5e:	88 23       	and	r24, r24
    3d60:	d9 f4       	brne	.+54     	; 0x3d98 <GetTotalizerData+0x58>
    3d62:	64 e2       	ldi	r22, 0x24	; 36
    3d64:	46 9f       	mul	r20, r22
    3d66:	b0 01       	movw	r22, r0
    3d68:	11 24       	eor	r1, r1
    3d6a:	29 2f       	mov	r18, r25
    3d6c:	30 e0       	ldi	r19, 0x00	; 0
    3d6e:	80 e2       	ldi	r24, 0x20	; 32
    3d70:	91 e0       	ldi	r25, 0x01	; 1
    3d72:	fc 01       	movw	r30, r24
    3d74:	2e 9f       	mul	r18, r30
    3d76:	c0 01       	movw	r24, r0
    3d78:	2f 9f       	mul	r18, r31
    3d7a:	90 0d       	add	r25, r0
    3d7c:	3e 9f       	mul	r19, r30
    3d7e:	90 0d       	add	r25, r0
    3d80:	11 24       	eor	r1, r1
    3d82:	68 0f       	add	r22, r24
    3d84:	79 1f       	adc	r23, r25
    3d86:	86 e0       	ldi	r24, 0x06	; 6
    3d88:	58 9f       	mul	r21, r24
    3d8a:	c0 01       	movw	r24, r0
    3d8c:	11 24       	eor	r1, r1
    3d8e:	68 0f       	add	r22, r24
    3d90:	79 1f       	adc	r23, r25
    3d92:	6d 53       	subi	r22, 0x3D	; 61
    3d94:	7c 4f       	sbci	r23, 0xFC	; 252
    3d96:	1c c0       	rjmp	.+56     	; 0x3dd0 <GetTotalizerData+0x90>
	 else 
	 if (TType==TMONEY)eeprom_read_block((void*) &rawValue, (const void*) &(TotalMoney[TAddr][iPumpAddr][iGrade]), sizeof(rawValue));
    3d98:	81 30       	cpi	r24, 0x01	; 1
    3d9a:	11 f5       	brne	.+68     	; 0x3de0 <GetTotalizerData+0xa0>
    3d9c:	64 e2       	ldi	r22, 0x24	; 36
    3d9e:	46 9f       	mul	r20, r22
    3da0:	b0 01       	movw	r22, r0
    3da2:	11 24       	eor	r1, r1
    3da4:	29 2f       	mov	r18, r25
    3da6:	30 e0       	ldi	r19, 0x00	; 0
    3da8:	80 e2       	ldi	r24, 0x20	; 32
    3daa:	91 e0       	ldi	r25, 0x01	; 1
    3dac:	fc 01       	movw	r30, r24
    3dae:	2e 9f       	mul	r18, r30
    3db0:	c0 01       	movw	r24, r0
    3db2:	2f 9f       	mul	r18, r31
    3db4:	90 0d       	add	r25, r0
    3db6:	3e 9f       	mul	r19, r30
    3db8:	90 0d       	add	r25, r0
    3dba:	11 24       	eor	r1, r1
    3dbc:	68 0f       	add	r22, r24
    3dbe:	79 1f       	adc	r23, r25
    3dc0:	86 e0       	ldi	r24, 0x06	; 6
    3dc2:	58 9f       	mul	r21, r24
    3dc4:	c0 01       	movw	r24, r0
    3dc6:	11 24       	eor	r1, r1
    3dc8:	68 0f       	add	r22, r24
    3dca:	79 1f       	adc	r23, r25
    3dcc:	6d 5f       	subi	r22, 0xFD	; 253
    3dce:	79 4f       	sbci	r23, 0xF9	; 249
    3dd0:	ce 01       	movw	r24, r28
    3dd2:	01 96       	adiw	r24, 0x01	; 1
    3dd4:	46 e0       	ldi	r20, 0x06	; 6
    3dd6:	50 e0       	ldi	r21, 0x00	; 0
    3dd8:	26 ef       	ldi	r18, 0xF6	; 246
    3dda:	32 e1       	ldi	r19, 0x12	; 18
    3ddc:	0e 94 7a b5 	call	0x16af4	; 0x16af4 <__eerd_block>
	 //Convert RawData to String 
	 RawToStr(rawValue,strValue);
    3de0:	ce 01       	movw	r24, r28
    3de2:	01 96       	adiw	r24, 0x01	; 1
    3de4:	b8 01       	movw	r22, r16
    3de6:	0e 94 f2 19 	call	0x33e4	; 0x33e4 <RawToStr>
}
    3dea:	26 96       	adiw	r28, 0x06	; 6
    3dec:	0f b6       	in	r0, 0x3f	; 63
    3dee:	f8 94       	cli
    3df0:	de bf       	out	0x3e, r29	; 62
    3df2:	0f be       	out	0x3f, r0	; 63
    3df4:	cd bf       	out	0x3d, r28	; 61
    3df6:	cf 91       	pop	r28
    3df8:	df 91       	pop	r29
    3dfa:	1f 91       	pop	r17
    3dfc:	0f 91       	pop	r16
    3dfe:	08 95       	ret

00003e00 <SaveToEEPROM>:
     return Result;
}



char SaveToEEPROM(char *Src,char *Dest,unsigned int Length){
    3e00:	ef 92       	push	r14
    3e02:	ff 92       	push	r15
    3e04:	0f 93       	push	r16
    3e06:	1f 93       	push	r17
    3e08:	df 93       	push	r29
    3e0a:	cf 93       	push	r28
    3e0c:	cd b7       	in	r28, 0x3d	; 61
    3e0e:	de b7       	in	r29, 0x3e	; 62
    3e10:	ac 97       	sbiw	r28, 0x2c	; 44
    3e12:	0f b6       	in	r0, 0x3f	; 63
    3e14:	f8 94       	cli
    3e16:	de bf       	out	0x3e, r29	; 62
    3e18:	0f be       	out	0x3f, r0	; 63
    3e1a:	cd bf       	out	0x3d, r28	; 61
    3e1c:	9a a7       	std	Y+42, r25	; 0x2a
    3e1e:	89 a7       	std	Y+41, r24	; 0x29
    3e20:	7c a7       	std	Y+44, r23	; 0x2c
    3e22:	6b a7       	std	Y+43, r22	; 0x2b
    3e24:	7a 01       	movw	r14, r20
    3e26:	8e 01       	movw	r16, r28
    3e28:	05 5d       	subi	r16, 0xD5	; 213
    3e2a:	1f 4f       	sbci	r17, 0xFF	; 255
    3e2c:	c8 01       	movw	r24, r16
    3e2e:	be 01       	movw	r22, r28
    3e30:	6f 5f       	subi	r22, 0xFF	; 255
    3e32:	7f 4f       	sbci	r23, 0xFF	; 255
    3e34:	26 ef       	ldi	r18, 0xF6	; 246
    3e36:	32 e1       	ldi	r19, 0x12	; 18
    3e38:	0e 94 7a b5 	call	0x16af4	; 0x16af4 <__eerd_block>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    3e3c:	c8 01       	movw	r24, r16
    3e3e:	be 01       	movw	r22, r28
    3e40:	67 5d       	subi	r22, 0xD7	; 215
    3e42:	7f 4f       	sbci	r23, 0xFF	; 255
    3e44:	a7 01       	movw	r20, r14
    3e46:	2e ef       	ldi	r18, 0xFE	; 254
    3e48:	32 e1       	ldi	r19, 0x12	; 18
    3e4a:	0e 94 96 b5 	call	0x16b2c	; 0x16b2c <__eewr_block>
     char strCompare[40];
	 //Read Previous Data
     eeprom_read_block((void*)&Dest,(const void*)&strCompare, Length);
     //if 
     eeprom_write_block((const void*)&Src,(void*)&Dest, Length);
}
    3e4e:	ac 96       	adiw	r28, 0x2c	; 44
    3e50:	0f b6       	in	r0, 0x3f	; 63
    3e52:	f8 94       	cli
    3e54:	de bf       	out	0x3e, r29	; 62
    3e56:	0f be       	out	0x3f, r0	; 63
    3e58:	cd bf       	out	0x3d, r28	; 61
    3e5a:	cf 91       	pop	r28
    3e5c:	df 91       	pop	r29
    3e5e:	1f 91       	pop	r17
    3e60:	0f 91       	pop	r16
    3e62:	ff 90       	pop	r15
    3e64:	ef 90       	pop	r14
    3e66:	08 95       	ret

00003e68 <SelectMark>:
	      break;
	 }
    return Result;
}

char SelectMark(char InMark){
    3e68:	df 92       	push	r13
    3e6a:	ef 92       	push	r14
    3e6c:	ff 92       	push	r15
    3e6e:	0f 93       	push	r16
    3e70:	1f 93       	push	r17
    3e72:	df 93       	push	r29
    3e74:	cf 93       	push	r28
    3e76:	00 d0       	rcall	.+0      	; 0x3e78 <SelectMark+0x10>
    3e78:	00 d0       	rcall	.+0      	; 0x3e7a <SelectMark+0x12>
    3e7a:	0f 92       	push	r0
    3e7c:	cd b7       	in	r28, 0x3d	; 61
    3e7e:	de b7       	in	r29, 0x3e	; 62
    3e80:	d8 2e       	mov	r13, r24
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    3e82:	8e 01       	movw	r16, r28
    3e84:	0f 5f       	subi	r16, 0xFF	; 255
    3e86:	1f 4f       	sbci	r17, 0xFF	; 255
    3e88:	c8 01       	movw	r24, r16
    3e8a:	60 e4       	ldi	r22, 0x40	; 64
    3e8c:	70 e0       	ldi	r23, 0x00	; 0
    3e8e:	45 e0       	ldi	r20, 0x05	; 5
    3e90:	50 e0       	ldi	r21, 0x00	; 0
    3e92:	26 ef       	ldi	r18, 0xF6	; 246
    3e94:	32 e1       	ldi	r19, 0x12	; 18
    3e96:	0e 94 7a b5 	call	0x16af4	; 0x16af4 <__eerd_block>
    3e9a:	ed 2d       	mov	r30, r13
    3e9c:	21 e0       	ldi	r18, 0x01	; 1
    3e9e:	30 e0       	ldi	r19, 0x00	; 0
     eeprom_read_block((void*)&PMark,(const void*)&DefMarkMap, sizeof(DefMarkMap));
	 Length=sizeof(DefMarkMap);
	 Result=InMark;
     for(i=0;i<Length;i++){
	     if (InMark==PMark[i])
		     Result=PMark[(i+1)%Length];
    3ea0:	78 01       	movw	r14, r16
char i,Result,PMark[5],Length;
     eeprom_read_block((void*)&PMark,(const void*)&DefMarkMap, sizeof(DefMarkMap));
	 Length=sizeof(DefMarkMap);
	 Result=InMark;
     for(i=0;i<Length;i++){
	     if (InMark==PMark[i])
    3ea2:	d8 01       	movw	r26, r16
    3ea4:	8c 91       	ld	r24, X
    3ea6:	d8 16       	cp	r13, r24
    3ea8:	49 f4       	brne	.+18     	; 0x3ebc <SelectMark+0x54>
		     Result=PMark[(i+1)%Length];
    3eaa:	c9 01       	movw	r24, r18
    3eac:	65 e0       	ldi	r22, 0x05	; 5
    3eae:	70 e0       	ldi	r23, 0x00	; 0
    3eb0:	0e 94 a7 b8 	call	0x1714e	; 0x1714e <__divmodhi4>
    3eb4:	f7 01       	movw	r30, r14
    3eb6:	e8 0f       	add	r30, r24
    3eb8:	f9 1f       	adc	r31, r25
    3eba:	e0 81       	ld	r30, Z
    3ebc:	0f 5f       	subi	r16, 0xFF	; 255
    3ebe:	1f 4f       	sbci	r17, 0xFF	; 255
    3ec0:	2f 5f       	subi	r18, 0xFF	; 255
    3ec2:	3f 4f       	sbci	r19, 0xFF	; 255
char SelectMark(char InMark){
char i,Result,PMark[5],Length;
     eeprom_read_block((void*)&PMark,(const void*)&DefMarkMap, sizeof(DefMarkMap));
	 Length=sizeof(DefMarkMap);
	 Result=InMark;
     for(i=0;i<Length;i++){
    3ec4:	26 30       	cpi	r18, 0x06	; 6
    3ec6:	31 05       	cpc	r19, r1
    3ec8:	61 f7       	brne	.-40     	; 0x3ea2 <SelectMark+0x3a>
	     if (InMark==PMark[i])
		     Result=PMark[(i+1)%Length];
	 }
     return Result;
}
    3eca:	8e 2f       	mov	r24, r30
    3ecc:	0f 90       	pop	r0
    3ece:	0f 90       	pop	r0
    3ed0:	0f 90       	pop	r0
    3ed2:	0f 90       	pop	r0
    3ed4:	0f 90       	pop	r0
    3ed6:	cf 91       	pop	r28
    3ed8:	df 91       	pop	r29
    3eda:	1f 91       	pop	r17
    3edc:	0f 91       	pop	r16
    3ede:	ff 90       	pop	r15
    3ee0:	ef 90       	pop	r14
    3ee2:	df 90       	pop	r13
    3ee4:	08 95       	ret

00003ee6 <UpdateServerIP>:
	 for(i=0;i<4;i++){
	     zeroIP(IP_blok[i],strIP[i]);
	 }
     sprintf_P(strClientIP,PSTR("%s.%s.%s.%s"),strIP[0],strIP[1],strIP[2],strIP[3]);
}
void UpdateServerIP(){     
    3ee6:	cf 92       	push	r12
    3ee8:	df 92       	push	r13
    3eea:	ef 92       	push	r14
    3eec:	ff 92       	push	r15
    3eee:	0f 93       	push	r16
    3ef0:	1f 93       	push	r17
    3ef2:	df 93       	push	r29
    3ef4:	cf 93       	push	r28
    3ef6:	cd b7       	in	r28, 0x3d	; 61
    3ef8:	de b7       	in	r29, 0x3e	; 62
    3efa:	64 97       	sbiw	r28, 0x14	; 20
    3efc:	0f b6       	in	r0, 0x3f	; 63
    3efe:	f8 94       	cli
    3f00:	de bf       	out	0x3e, r29	; 62
    3f02:	0f be       	out	0x3f, r0	; 63
    3f04:	cd bf       	out	0x3d, r28	; 61
    3f06:	8e 01       	movw	r16, r28
    3f08:	0f 5f       	subi	r16, 0xFF	; 255
    3f0a:	1f 4f       	sbci	r17, 0xFF	; 255
    3f0c:	c8 01       	movw	r24, r16
    3f0e:	6c e2       	ldi	r22, 0x2C	; 44
    3f10:	70 e0       	ldi	r23, 0x00	; 0
    3f12:	44 e0       	ldi	r20, 0x04	; 4
    3f14:	50 e0       	ldi	r21, 0x00	; 0
    3f16:	26 ef       	ldi	r18, 0xF6	; 246
    3f18:	32 e1       	ldi	r19, 0x12	; 18
    3f1a:	0e 94 7a b5 	call	0x16af4	; 0x16af4 <__eerd_block>
    3f1e:	78 01       	movw	r14, r16
    3f20:	8e 01       	movw	r16, r28
    3f22:	0b 5f       	subi	r16, 0xFB	; 251
    3f24:	1f 4f       	sbci	r17, 0xFF	; 255
	 char strIP[4][4];
	 //192.168.016.180
     eeprom_read_block((void*)&IP_blok,(const void*)&DefServerIP,4);

	 for(i=0;i<4;i++){
	     zeroIP(IP_blok[i],strIP[i]);
    3f26:	68 01       	movw	r12, r16
    3f28:	d7 01       	movw	r26, r14
    3f2a:	8d 91       	ld	r24, X+
    3f2c:	7d 01       	movw	r14, r26
    3f2e:	b8 01       	movw	r22, r16
    3f30:	0e 94 c3 16 	call	0x2d86	; 0x2d86 <zeroIP>
    3f34:	0c 5f       	subi	r16, 0xFC	; 252
    3f36:	1f 4f       	sbci	r17, 0xFF	; 255
     char i,IP_blok[4];
	 char strIP[4][4];
	 //192.168.016.180
     eeprom_read_block((void*)&IP_blok,(const void*)&DefServerIP,4);

	 for(i=0;i<4;i++){
    3f38:	ec 14       	cp	r14, r12
    3f3a:	fd 04       	cpc	r15, r13
    3f3c:	a9 f7       	brne	.-22     	; 0x3f28 <UpdateServerIP+0x42>
	     zeroIP(IP_blok[i],strIP[i]);
	 }
		 sprintf_P(strServerIP,PSTR("%s.%s.%s.%s"),strIP[0],strIP[1],strIP[2],strIP[3]);
    3f3e:	ed b7       	in	r30, 0x3d	; 61
    3f40:	fe b7       	in	r31, 0x3e	; 62
    3f42:	3c 97       	sbiw	r30, 0x0c	; 12
    3f44:	0f b6       	in	r0, 0x3f	; 63
    3f46:	f8 94       	cli
    3f48:	fe bf       	out	0x3e, r31	; 62
    3f4a:	0f be       	out	0x3f, r0	; 63
    3f4c:	ed bf       	out	0x3d, r30	; 61
    3f4e:	31 96       	adiw	r30, 0x01	; 1
    3f50:	8b ee       	ldi	r24, 0xEB	; 235
    3f52:	99 e0       	ldi	r25, 0x09	; 9
    3f54:	ad b7       	in	r26, 0x3d	; 61
    3f56:	be b7       	in	r27, 0x3e	; 62
    3f58:	12 96       	adiw	r26, 0x02	; 2
    3f5a:	9c 93       	st	X, r25
    3f5c:	8e 93       	st	-X, r24
    3f5e:	11 97       	sbiw	r26, 0x01	; 1
    3f60:	81 e0       	ldi	r24, 0x01	; 1
    3f62:	92 e2       	ldi	r25, 0x22	; 34
    3f64:	93 83       	std	Z+3, r25	; 0x03
    3f66:	82 83       	std	Z+2, r24	; 0x02
    3f68:	f5 82       	std	Z+5, r15	; 0x05
    3f6a:	e4 82       	std	Z+4, r14	; 0x04
    3f6c:	ce 01       	movw	r24, r28
    3f6e:	09 96       	adiw	r24, 0x09	; 9
    3f70:	97 83       	std	Z+7, r25	; 0x07
    3f72:	86 83       	std	Z+6, r24	; 0x06
    3f74:	ce 01       	movw	r24, r28
    3f76:	0d 96       	adiw	r24, 0x0d	; 13
    3f78:	91 87       	std	Z+9, r25	; 0x09
    3f7a:	80 87       	std	Z+8, r24	; 0x08
    3f7c:	ce 01       	movw	r24, r28
    3f7e:	41 96       	adiw	r24, 0x11	; 17
    3f80:	93 87       	std	Z+11, r25	; 0x0b
    3f82:	82 87       	std	Z+10, r24	; 0x0a
    3f84:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    3f88:	ed b7       	in	r30, 0x3d	; 61
    3f8a:	fe b7       	in	r31, 0x3e	; 62
    3f8c:	3c 96       	adiw	r30, 0x0c	; 12
    3f8e:	0f b6       	in	r0, 0x3f	; 63
    3f90:	f8 94       	cli
    3f92:	fe bf       	out	0x3e, r31	; 62
    3f94:	0f be       	out	0x3f, r0	; 63
    3f96:	ed bf       	out	0x3d, r30	; 61
}
    3f98:	64 96       	adiw	r28, 0x14	; 20
    3f9a:	0f b6       	in	r0, 0x3f	; 63
    3f9c:	f8 94       	cli
    3f9e:	de bf       	out	0x3e, r29	; 62
    3fa0:	0f be       	out	0x3f, r0	; 63
    3fa2:	cd bf       	out	0x3d, r28	; 61
    3fa4:	cf 91       	pop	r28
    3fa6:	df 91       	pop	r29
    3fa8:	1f 91       	pop	r17
    3faa:	0f 91       	pop	r16
    3fac:	ff 90       	pop	r15
    3fae:	ef 90       	pop	r14
    3fb0:	df 90       	pop	r13
    3fb2:	cf 90       	pop	r12
    3fb4:	08 95       	ret

00003fb6 <UpdateClientIP>:
	     str[0]=('0'+S);
	     str[1]=0;
	 }
}

void UpdateClientIP(){     
    3fb6:	cf 92       	push	r12
    3fb8:	df 92       	push	r13
    3fba:	ef 92       	push	r14
    3fbc:	ff 92       	push	r15
    3fbe:	0f 93       	push	r16
    3fc0:	1f 93       	push	r17
    3fc2:	df 93       	push	r29
    3fc4:	cf 93       	push	r28
    3fc6:	cd b7       	in	r28, 0x3d	; 61
    3fc8:	de b7       	in	r29, 0x3e	; 62
    3fca:	68 97       	sbiw	r28, 0x18	; 24
    3fcc:	0f b6       	in	r0, 0x3f	; 63
    3fce:	f8 94       	cli
    3fd0:	de bf       	out	0x3e, r29	; 62
    3fd2:	0f be       	out	0x3f, r0	; 63
    3fd4:	cd bf       	out	0x3d, r28	; 61
    3fd6:	8e 01       	movw	r16, r28
    3fd8:	0f 5f       	subi	r16, 0xFF	; 255
    3fda:	1f 4f       	sbci	r17, 0xFF	; 255
    3fdc:	c8 01       	movw	r24, r16
    3fde:	68 e2       	ldi	r22, 0x28	; 40
    3fe0:	70 e0       	ldi	r23, 0x00	; 0
    3fe2:	44 e0       	ldi	r20, 0x04	; 4
    3fe4:	50 e0       	ldi	r21, 0x00	; 0
    3fe6:	26 ef       	ldi	r18, 0xF6	; 246
    3fe8:	32 e1       	ldi	r19, 0x12	; 18
    3fea:	0e 94 7a b5 	call	0x16af4	; 0x16af4 <__eerd_block>
    3fee:	78 01       	movw	r14, r16
    3ff0:	8e 01       	movw	r16, r28
    3ff2:	0b 5f       	subi	r16, 0xFB	; 251
    3ff4:	1f 4f       	sbci	r17, 0xFF	; 255
	 char strIP[4][5];
	 //192.168.010.002
     eeprom_read_block((void*)&IP_blok,(const void*)&DefClientIP,4);

	 for(i=0;i<4;i++){
	     zeroIP(IP_blok[i],strIP[i]);
    3ff6:	68 01       	movw	r12, r16
    3ff8:	d7 01       	movw	r26, r14
    3ffa:	8d 91       	ld	r24, X+
    3ffc:	7d 01       	movw	r14, r26
    3ffe:	b8 01       	movw	r22, r16
    4000:	0e 94 c3 16 	call	0x2d86	; 0x2d86 <zeroIP>
    4004:	0b 5f       	subi	r16, 0xFB	; 251
    4006:	1f 4f       	sbci	r17, 0xFF	; 255
     char i,IP_blok[4];
	 char strIP[4][5];
	 //192.168.010.002
     eeprom_read_block((void*)&IP_blok,(const void*)&DefClientIP,4);

	 for(i=0;i<4;i++){
    4008:	ec 14       	cp	r14, r12
    400a:	fd 04       	cpc	r15, r13
    400c:	a9 f7       	brne	.-22     	; 0x3ff8 <UpdateClientIP+0x42>
	     zeroIP(IP_blok[i],strIP[i]);
	 }
     sprintf_P(strClientIP,PSTR("%s.%s.%s.%s"),strIP[0],strIP[1],strIP[2],strIP[3]);
    400e:	ed b7       	in	r30, 0x3d	; 61
    4010:	fe b7       	in	r31, 0x3e	; 62
    4012:	3c 97       	sbiw	r30, 0x0c	; 12
    4014:	0f b6       	in	r0, 0x3f	; 63
    4016:	f8 94       	cli
    4018:	fe bf       	out	0x3e, r31	; 62
    401a:	0f be       	out	0x3f, r0	; 63
    401c:	ed bf       	out	0x3d, r30	; 61
    401e:	31 96       	adiw	r30, 0x01	; 1
    4020:	8e eb       	ldi	r24, 0xBE	; 190
    4022:	99 e0       	ldi	r25, 0x09	; 9
    4024:	ad b7       	in	r26, 0x3d	; 61
    4026:	be b7       	in	r27, 0x3e	; 62
    4028:	12 96       	adiw	r26, 0x02	; 2
    402a:	9c 93       	st	X, r25
    402c:	8e 93       	st	-X, r24
    402e:	11 97       	sbiw	r26, 0x01	; 1
    4030:	8d e0       	ldi	r24, 0x0D	; 13
    4032:	92 e2       	ldi	r25, 0x22	; 34
    4034:	93 83       	std	Z+3, r25	; 0x03
    4036:	82 83       	std	Z+2, r24	; 0x02
    4038:	f5 82       	std	Z+5, r15	; 0x05
    403a:	e4 82       	std	Z+4, r14	; 0x04
    403c:	ce 01       	movw	r24, r28
    403e:	0a 96       	adiw	r24, 0x0a	; 10
    4040:	97 83       	std	Z+7, r25	; 0x07
    4042:	86 83       	std	Z+6, r24	; 0x06
    4044:	ce 01       	movw	r24, r28
    4046:	0f 96       	adiw	r24, 0x0f	; 15
    4048:	91 87       	std	Z+9, r25	; 0x09
    404a:	80 87       	std	Z+8, r24	; 0x08
    404c:	ce 01       	movw	r24, r28
    404e:	44 96       	adiw	r24, 0x14	; 20
    4050:	93 87       	std	Z+11, r25	; 0x0b
    4052:	82 87       	std	Z+10, r24	; 0x0a
    4054:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    4058:	ed b7       	in	r30, 0x3d	; 61
    405a:	fe b7       	in	r31, 0x3e	; 62
    405c:	3c 96       	adiw	r30, 0x0c	; 12
    405e:	0f b6       	in	r0, 0x3f	; 63
    4060:	f8 94       	cli
    4062:	fe bf       	out	0x3e, r31	; 62
    4064:	0f be       	out	0x3f, r0	; 63
    4066:	ed bf       	out	0x3d, r30	; 61
}
    4068:	68 96       	adiw	r28, 0x18	; 24
    406a:	0f b6       	in	r0, 0x3f	; 63
    406c:	f8 94       	cli
    406e:	de bf       	out	0x3e, r29	; 62
    4070:	0f be       	out	0x3f, r0	; 63
    4072:	cd bf       	out	0x3d, r28	; 61
    4074:	cf 91       	pop	r28
    4076:	df 91       	pop	r29
    4078:	1f 91       	pop	r17
    407a:	0f 91       	pop	r16
    407c:	ff 90       	pop	r15
    407e:	ef 90       	pop	r14
    4080:	df 90       	pop	r13
    4082:	cf 90       	pop	r12
    4084:	08 95       	ret

00004086 <GenerateStandaloneTransData>:

     eeprom_write_block((const void*)&PTransNum,(void*)&DefTransactionNumber,sizeof(DefTransactionNumber));
}


char GenerateStandaloneTransData(char xPumpID, char *PNozzle){//[1,2,3..16]->[1,2,3..0]
    4086:	cf 92       	push	r12
    4088:	df 92       	push	r13
    408a:	ef 92       	push	r14
    408c:	ff 92       	push	r15
    408e:	0f 93       	push	r16
    4090:	1f 93       	push	r17
    4092:	df 93       	push	r29
    4094:	cf 93       	push	r28
    4096:	cd b7       	in	r28, 0x3d	; 61
    4098:	de b7       	in	r29, 0x3e	; 62
    409a:	2f 97       	sbiw	r28, 0x0f	; 15
    409c:	0f b6       	in	r0, 0x3f	; 63
    409e:	f8 94       	cli
    40a0:	de bf       	out	0x3e, r29	; 62
    40a2:	0f be       	out	0x3f, r0	; 63
    40a4:	cd bf       	out	0x3d, r28	; 61
    40a6:	e8 2e       	mov	r14, r24
    40a8:	8b 01       	movw	r16, r22
     char Result=GS_NONE;
	 char strSend[30];
	 char FIPAddr;

	 iPumpID=(xPumpID&0x0F);
	 FIPAddr=GetFIPAddr(iPumpID);
    40aa:	8f 70       	andi	r24, 0x0F	; 15
    40ac:	0e 94 e1 1d 	call	0x3bc2	; 0x3bc2 <GetFIPAddr>
     if (FIPAddr>0){
    40b0:	88 23       	and	r24, r24
    40b2:	09 f4       	brne	.+2      	; 0x40b6 <GenerateStandaloneTransData+0x30>
    40b4:	2d c1       	rjmp	.+602    	; 0x4310 <GenerateStandaloneTransData+0x28a>
	     FIPAddr=FIPAddr-1;
		 iProdID=PNozzle[RecPumpData[FIPAddr].Grade];
    40b6:	81 50       	subi	r24, 0x01	; 1
    40b8:	c8 2e       	mov	r12, r24
    40ba:	dd 24       	eor	r13, r13
    40bc:	85 e3       	ldi	r24, 0x35	; 53
    40be:	90 e0       	ldi	r25, 0x00	; 0
    40c0:	c8 9e       	mul	r12, r24
    40c2:	f0 01       	movw	r30, r0
    40c4:	c9 9e       	mul	r12, r25
    40c6:	f0 0d       	add	r31, r0
    40c8:	d8 9e       	mul	r13, r24
    40ca:	f0 0d       	add	r31, r0
    40cc:	11 24       	eor	r1, r1
    40ce:	e5 57       	subi	r30, 0x75	; 117
    40d0:	f8 4f       	sbci	r31, 0xF8	; 248
    40d2:	80 81       	ld	r24, Z
    40d4:	08 0f       	add	r16, r24
    40d6:	11 1d       	adc	r17, r1
    40d8:	d8 01       	movw	r26, r16
    40da:	2c 91       	ld	r18, X
    40dc:	ce 01       	movw	r24, r28
    40de:	01 96       	adiw	r24, 0x01	; 1

		 if (iProdID>0) eeprom_read_block((void*) &ProductName, (const void*) &DefProductName[iProdID-1],sizeof(DefProductName[iProdID-1]));
    40e0:	22 23       	and	r18, r18
    40e2:	69 f0       	breq	.+26     	; 0x40fe <GenerateStandaloneTransData+0x78>
    40e4:	6d e0       	ldi	r22, 0x0D	; 13
    40e6:	26 9f       	mul	r18, r22
    40e8:	b0 01       	movw	r22, r0
    40ea:	11 24       	eor	r1, r1
    40ec:	62 55       	subi	r22, 0x52	; 82
    40ee:	7f 4f       	sbci	r23, 0xFF	; 255
    40f0:	4d e0       	ldi	r20, 0x0D	; 13
    40f2:	50 e0       	ldi	r21, 0x00	; 0
    40f4:	26 ef       	ldi	r18, 0xF6	; 246
    40f6:	32 e1       	ldi	r19, 0x12	; 18
    40f8:	0e 94 7a b5 	call	0x16af4	; 0x16af4 <__eerd_block>
    40fc:	10 c0       	rjmp	.+32     	; 0x411e <GenerateStandaloneTransData+0x98>
		 else sprintf_P(ProductName,PSTR("N/A"));
    40fe:	00 d0       	rcall	.+0      	; 0x4100 <GenerateStandaloneTransData+0x7a>
    4100:	00 d0       	rcall	.+0      	; 0x4102 <GenerateStandaloneTransData+0x7c>
    4102:	ed b7       	in	r30, 0x3d	; 61
    4104:	fe b7       	in	r31, 0x3e	; 62
    4106:	92 83       	std	Z+2, r25	; 0x02
    4108:	81 83       	std	Z+1, r24	; 0x01
    410a:	8e eb       	ldi	r24, 0xBE	; 190
    410c:	92 e2       	ldi	r25, 0x22	; 34
    410e:	94 83       	std	Z+4, r25	; 0x04
    4110:	83 83       	std	Z+3, r24	; 0x03
    4112:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    4116:	0f 90       	pop	r0
    4118:	0f 90       	pop	r0
    411a:	0f 90       	pop	r0
    411c:	0f 90       	pop	r0
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    411e:	e1 99       	sbic	0x1c, 1	; 28
    4120:	fe cf       	rjmp	.-4      	; 0x411e <GenerateStandaloneTransData+0x98>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    4122:	80 e0       	ldi	r24, 0x00	; 0
    4124:	90 e0       	ldi	r25, 0x00	; 0
    4126:	9f bb       	out	0x1f, r25	; 31
    4128:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    412a:	e0 9a       	sbi	0x1c, 0	; 28
    412c:	fd b2       	in	r15, 0x1d	; 29

		 TermID=eeprom_read_byte(&DefIFT_ID);

		 //Shift,TransNum,Date,Time
		 sprintf_P(strShift,PSTR("%d"),RecPumpData[FIPAddr].Shift);
    412e:	00 d0       	rcall	.+0      	; 0x4130 <GenerateStandaloneTransData+0xaa>
    4130:	00 d0       	rcall	.+0      	; 0x4132 <GenerateStandaloneTransData+0xac>
    4132:	00 d0       	rcall	.+0      	; 0x4134 <GenerateStandaloneTransData+0xae>
    4134:	ad b7       	in	r26, 0x3d	; 61
    4136:	be b7       	in	r27, 0x3e	; 62
    4138:	11 96       	adiw	r26, 0x01	; 1
    413a:	83 e4       	ldi	r24, 0x43	; 67
    413c:	9e e0       	ldi	r25, 0x0E	; 14
    413e:	ed b7       	in	r30, 0x3d	; 61
    4140:	fe b7       	in	r31, 0x3e	; 62
    4142:	92 83       	std	Z+2, r25	; 0x02
    4144:	81 83       	std	Z+1, r24	; 0x01
    4146:	8b eb       	ldi	r24, 0xBB	; 187
    4148:	92 e2       	ldi	r25, 0x22	; 34
    414a:	13 96       	adiw	r26, 0x03	; 3
    414c:	9c 93       	st	X, r25
    414e:	8e 93       	st	-X, r24
    4150:	12 97       	sbiw	r26, 0x02	; 2
    4152:	85 e3       	ldi	r24, 0x35	; 53
    4154:	90 e0       	ldi	r25, 0x00	; 0
    4156:	c8 9e       	mul	r12, r24
    4158:	80 01       	movw	r16, r0
    415a:	c9 9e       	mul	r12, r25
    415c:	10 0d       	add	r17, r0
    415e:	d8 9e       	mul	r13, r24
    4160:	10 0d       	add	r17, r0
    4162:	11 24       	eor	r1, r1
    4164:	f8 01       	movw	r30, r16
    4166:	e5 57       	subi	r30, 0x75	; 117
    4168:	f8 4f       	sbci	r31, 0xF8	; 248
    416a:	82 81       	ldd	r24, Z+2	; 0x02
    416c:	14 96       	adiw	r26, 0x04	; 4
    416e:	8c 93       	st	X, r24
    4170:	14 97       	sbiw	r26, 0x04	; 4
    4172:	15 96       	adiw	r26, 0x05	; 5
    4174:	1c 92       	st	X, r1
    4176:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
		 sprintf_P(strTranNo,PSTR("%s"),RecPumpData[FIPAddr].strTransNum);
    417a:	ed b7       	in	r30, 0x3d	; 61
    417c:	fe b7       	in	r31, 0x3e	; 62
    417e:	31 96       	adiw	r30, 0x01	; 1
    4180:	81 e6       	ldi	r24, 0x61	; 97
    4182:	9e e0       	ldi	r25, 0x0E	; 14
    4184:	ad b7       	in	r26, 0x3d	; 61
    4186:	be b7       	in	r27, 0x3e	; 62
    4188:	12 96       	adiw	r26, 0x02	; 2
    418a:	9c 93       	st	X, r25
    418c:	8e 93       	st	-X, r24
    418e:	11 97       	sbiw	r26, 0x01	; 1
    4190:	88 eb       	ldi	r24, 0xB8	; 184
    4192:	92 e2       	ldi	r25, 0x22	; 34
    4194:	93 83       	std	Z+3, r25	; 0x03
    4196:	82 83       	std	Z+2, r24	; 0x02
    4198:	c8 01       	movw	r24, r16
    419a:	82 57       	subi	r24, 0x72	; 114
    419c:	98 4f       	sbci	r25, 0xF8	; 248
    419e:	95 83       	std	Z+5, r25	; 0x05
    41a0:	84 83       	std	Z+4, r24	; 0x04
    41a2:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
	     sprintf_P(strDate,PSTR("%s"),RecPumpData[FIPAddr].strTransDate);
    41a6:	ed b7       	in	r30, 0x3d	; 61
    41a8:	fe b7       	in	r31, 0x3e	; 62
    41aa:	31 96       	adiw	r30, 0x01	; 1
    41ac:	81 e5       	ldi	r24, 0x51	; 81
    41ae:	99 e0       	ldi	r25, 0x09	; 9
    41b0:	ad b7       	in	r26, 0x3d	; 61
    41b2:	be b7       	in	r27, 0x3e	; 62
    41b4:	12 96       	adiw	r26, 0x02	; 2
    41b6:	9c 93       	st	X, r25
    41b8:	8e 93       	st	-X, r24
    41ba:	11 97       	sbiw	r26, 0x01	; 1
    41bc:	85 eb       	ldi	r24, 0xB5	; 181
    41be:	92 e2       	ldi	r25, 0x22	; 34
    41c0:	93 83       	std	Z+3, r25	; 0x03
    41c2:	82 83       	std	Z+2, r24	; 0x02
    41c4:	c8 01       	movw	r24, r16
    41c6:	8b 56       	subi	r24, 0x6B	; 107
    41c8:	98 4f       	sbci	r25, 0xF8	; 248
    41ca:	95 83       	std	Z+5, r25	; 0x05
    41cc:	84 83       	std	Z+4, r24	; 0x04
    41ce:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
		 sprintf_P(strTime,PSTR("%s"),RecPumpData[FIPAddr].strTransTime);	 
    41d2:	ed b7       	in	r30, 0x3d	; 61
    41d4:	fe b7       	in	r31, 0x3e	; 62
    41d6:	31 96       	adiw	r30, 0x01	; 1
    41d8:	8d e2       	ldi	r24, 0x2D	; 45
    41da:	95 e0       	ldi	r25, 0x05	; 5
    41dc:	ad b7       	in	r26, 0x3d	; 61
    41de:	be b7       	in	r27, 0x3e	; 62
    41e0:	12 96       	adiw	r26, 0x02	; 2
    41e2:	9c 93       	st	X, r25
    41e4:	8e 93       	st	-X, r24
    41e6:	11 97       	sbiw	r26, 0x01	; 1
    41e8:	82 eb       	ldi	r24, 0xB2	; 178
    41ea:	92 e2       	ldi	r25, 0x22	; 34
    41ec:	93 83       	std	Z+3, r25	; 0x03
    41ee:	82 83       	std	Z+2, r24	; 0x02
    41f0:	c8 01       	movw	r24, r16
    41f2:	82 56       	subi	r24, 0x62	; 98
    41f4:	98 4f       	sbci	r25, 0xF8	; 248
    41f6:	95 83       	std	Z+5, r25	; 0x05
    41f8:	84 83       	std	Z+4, r24	; 0x04
    41fa:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>

	     //TermID,FIP_ID,Product
		 sprintf_P(strIslandID,PSTR("%d"),TermID);
    41fe:	ed b7       	in	r30, 0x3d	; 61
    4200:	fe b7       	in	r31, 0x3e	; 62
    4202:	31 96       	adiw	r30, 0x01	; 1
    4204:	8f ec       	ldi	r24, 0xCF	; 207
    4206:	9a e0       	ldi	r25, 0x0A	; 10
    4208:	ad b7       	in	r26, 0x3d	; 61
    420a:	be b7       	in	r27, 0x3e	; 62
    420c:	12 96       	adiw	r26, 0x02	; 2
    420e:	9c 93       	st	X, r25
    4210:	8e 93       	st	-X, r24
    4212:	11 97       	sbiw	r26, 0x01	; 1
    4214:	8f ea       	ldi	r24, 0xAF	; 175
    4216:	92 e2       	ldi	r25, 0x22	; 34
    4218:	93 83       	std	Z+3, r25	; 0x03
    421a:	82 83       	std	Z+2, r24	; 0x02
    421c:	f4 82       	std	Z+4, r15	; 0x04
    421e:	15 82       	std	Z+5, r1	; 0x05
    4220:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
		 sprintf_P(strFIP_ID,PSTR("%.2d"),xPumpID);
    4224:	ed b7       	in	r30, 0x3d	; 61
    4226:	fe b7       	in	r31, 0x3e	; 62
    4228:	31 96       	adiw	r30, 0x01	; 1
    422a:	8c e9       	ldi	r24, 0x9C	; 156
    422c:	99 e0       	ldi	r25, 0x09	; 9
    422e:	ad b7       	in	r26, 0x3d	; 61
    4230:	be b7       	in	r27, 0x3e	; 62
    4232:	12 96       	adiw	r26, 0x02	; 2
    4234:	9c 93       	st	X, r25
    4236:	8e 93       	st	-X, r24
    4238:	11 97       	sbiw	r26, 0x01	; 1
    423a:	8a ea       	ldi	r24, 0xAA	; 170
    423c:	92 e2       	ldi	r25, 0x22	; 34
    423e:	93 83       	std	Z+3, r25	; 0x03
    4240:	82 83       	std	Z+2, r24	; 0x02
    4242:	e4 82       	std	Z+4, r14	; 0x04
    4244:	15 82       	std	Z+5, r1	; 0x05
    4246:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
	     sprintf_P(strDescription,PSTR("%s"),ProductName);
    424a:	ed b7       	in	r30, 0x3d	; 61
    424c:	fe b7       	in	r31, 0x3e	; 62
    424e:	31 96       	adiw	r30, 0x01	; 1
    4250:	81 e1       	ldi	r24, 0x11	; 17
    4252:	9a e0       	ldi	r25, 0x0A	; 10
    4254:	ad b7       	in	r26, 0x3d	; 61
    4256:	be b7       	in	r27, 0x3e	; 62
    4258:	12 96       	adiw	r26, 0x02	; 2
    425a:	9c 93       	st	X, r25
    425c:	8e 93       	st	-X, r24
    425e:	11 97       	sbiw	r26, 0x01	; 1
    4260:	87 ea       	ldi	r24, 0xA7	; 167
    4262:	92 e2       	ldi	r25, 0x22	; 34
    4264:	93 83       	std	Z+3, r25	; 0x03
    4266:	82 83       	std	Z+2, r24	; 0x02
    4268:	ce 01       	movw	r24, r28
    426a:	01 96       	adiw	r24, 0x01	; 1
    426c:	95 83       	std	Z+5, r25	; 0x05
    426e:	84 83       	std	Z+4, r24	; 0x04
    4270:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>

		 //Price Volume Money
		 sprintf_P(strPrice,PSTR("%s"),RecPumpData[FIPAddr].Price);
    4274:	ed b7       	in	r30, 0x3d	; 61
    4276:	fe b7       	in	r31, 0x3e	; 62
    4278:	31 96       	adiw	r30, 0x01	; 1
    427a:	81 e8       	ldi	r24, 0x81	; 129
    427c:	97 e0       	ldi	r25, 0x07	; 7
    427e:	ad b7       	in	r26, 0x3d	; 61
    4280:	be b7       	in	r27, 0x3e	; 62
    4282:	12 96       	adiw	r26, 0x02	; 2
    4284:	9c 93       	st	X, r25
    4286:	8e 93       	st	-X, r24
    4288:	11 97       	sbiw	r26, 0x01	; 1
    428a:	84 ea       	ldi	r24, 0xA4	; 164
    428c:	92 e2       	ldi	r25, 0x22	; 34
    428e:	93 83       	std	Z+3, r25	; 0x03
    4290:	82 83       	std	Z+2, r24	; 0x02
    4292:	c8 01       	movw	r24, r16
    4294:	89 55       	subi	r24, 0x59	; 89
    4296:	98 4f       	sbci	r25, 0xF8	; 248
    4298:	95 83       	std	Z+5, r25	; 0x05
    429a:	84 83       	std	Z+4, r24	; 0x04
    429c:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
	     sprintf_P(strVolume,PSTR("%s"),RecPumpData[FIPAddr].Volume);
    42a0:	ed b7       	in	r30, 0x3d	; 61
    42a2:	fe b7       	in	r31, 0x3e	; 62
    42a4:	31 96       	adiw	r30, 0x01	; 1
    42a6:	85 e5       	ldi	r24, 0x55	; 85
    42a8:	95 e0       	ldi	r25, 0x05	; 5
    42aa:	ad b7       	in	r26, 0x3d	; 61
    42ac:	be b7       	in	r27, 0x3e	; 62
    42ae:	12 96       	adiw	r26, 0x02	; 2
    42b0:	9c 93       	st	X, r25
    42b2:	8e 93       	st	-X, r24
    42b4:	11 97       	sbiw	r26, 0x01	; 1
    42b6:	81 ea       	ldi	r24, 0xA1	; 161
    42b8:	92 e2       	ldi	r25, 0x22	; 34
    42ba:	93 83       	std	Z+3, r25	; 0x03
    42bc:	82 83       	std	Z+2, r24	; 0x02
    42be:	c8 01       	movw	r24, r16
    42c0:	82 55       	subi	r24, 0x52	; 82
    42c2:	98 4f       	sbci	r25, 0xF8	; 248
    42c4:	95 83       	std	Z+5, r25	; 0x05
    42c6:	84 83       	std	Z+4, r24	; 0x04
    42c8:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
		 sprintf_P(strAmount,PSTR("%s"),RecPumpData[FIPAddr].Money);
    42cc:	ed b7       	in	r30, 0x3d	; 61
    42ce:	fe b7       	in	r31, 0x3e	; 62
    42d0:	31 96       	adiw	r30, 0x01	; 1
    42d2:	8b e8       	ldi	r24, 0x8B	; 139
    42d4:	9d e0       	ldi	r25, 0x0D	; 13
    42d6:	ad b7       	in	r26, 0x3d	; 61
    42d8:	be b7       	in	r27, 0x3e	; 62
    42da:	12 96       	adiw	r26, 0x02	; 2
    42dc:	9c 93       	st	X, r25
    42de:	8e 93       	st	-X, r24
    42e0:	11 97       	sbiw	r26, 0x01	; 1
    42e2:	8e e9       	ldi	r24, 0x9E	; 158
    42e4:	92 e2       	ldi	r25, 0x22	; 34
    42e6:	93 83       	std	Z+3, r25	; 0x03
    42e8:	82 83       	std	Z+2, r24	; 0x02
    42ea:	09 54       	subi	r16, 0x49	; 73
    42ec:	18 4f       	sbci	r17, 0xF8	; 248
    42ee:	15 83       	std	Z+5, r17	; 0x05
    42f0:	04 83       	std	Z+4, r16	; 0x04
    42f2:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>

		 MOPType=MOP_CASH;
    42f6:	10 92 cf 01 	sts	0x01CF, r1
	     IsPrinting=True;	 
    42fa:	81 e0       	ldi	r24, 0x01	; 1
    42fc:	80 93 c3 01 	sts	0x01C3, r24
    4300:	ed b7       	in	r30, 0x3d	; 61
    4302:	fe b7       	in	r31, 0x3e	; 62
    4304:	36 96       	adiw	r30, 0x06	; 6
    4306:	0f b6       	in	r0, 0x3f	; 63
    4308:	f8 94       	cli
    430a:	fe bf       	out	0x3e, r31	; 62
    430c:	0f be       	out	0x3f, r0	; 63
    430e:	ed bf       	out	0x3d, r30	; 61
	 }
	 //ProductName	 
	 //iProdID=PNozzle[RecPumpData[iPumpID].Nozzle];
	 //BAsedOnGrade
   return Result;
}
    4310:	2f 96       	adiw	r28, 0x0f	; 15
    4312:	0f b6       	in	r0, 0x3f	; 63
    4314:	f8 94       	cli
    4316:	de bf       	out	0x3e, r29	; 62
    4318:	0f be       	out	0x3f, r0	; 63
    431a:	cd bf       	out	0x3d, r28	; 61
    431c:	cf 91       	pop	r28
    431e:	df 91       	pop	r29
    4320:	1f 91       	pop	r17
    4322:	0f 91       	pop	r16
    4324:	ff 90       	pop	r15
    4326:	ef 90       	pop	r14
    4328:	df 90       	pop	r13
    432a:	cf 90       	pop	r12
    432c:	08 95       	ret

0000432e <PrintStandalone>:
     char Result=PS_NONE;

   return Result;
}

char PrintStandalone(char FIPAddr,char IsReprint){
    432e:	ef 92       	push	r14
    4330:	ff 92       	push	r15
    4332:	0f 93       	push	r16
    4334:	1f 93       	push	r17
    4336:	df 93       	push	r29
    4338:	cf 93       	push	r28
    433a:	00 d0       	rcall	.+0      	; 0x433c <PrintStandalone+0xe>
    433c:	00 d0       	rcall	.+0      	; 0x433e <PrintStandalone+0x10>
    433e:	00 d0       	rcall	.+0      	; 0x4340 <PrintStandalone+0x12>
    4340:	cd b7       	in	r28, 0x3d	; 61
    4342:	de b7       	in	r29, 0x3e	; 62
    4344:	f8 2e       	mov	r15, r24
    4346:	06 2f       	mov	r16, r22
	 char LFIPAddr;
	      
	 Result=PS_NO_DATA;

//	 eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap, 8);
	 iPumpID=GetPumpID(FIPAddr);//PPumpID[FIPAddr-1];
    4348:	0e 94 76 1e 	call	0x3cec	; 0x3cec <GetPumpID>
    434c:	e8 2e       	mov	r14, r24
     LFIPAddr=GetFIPAddr(iPumpID);
    434e:	0e 94 e1 1d 	call	0x3bc2	; 0x3bc2 <GetFIPAddr>
    4352:	18 2f       	mov	r17, r24

     if (LFIPAddr>0){
    4354:	88 23       	and	r24, r24
    4356:	99 f1       	breq	.+102    	; 0x43be <PrintStandalone+0x90>
	     LFIPAddr=LFIPAddr-1;
	     if ((IsReprint==True)||(iPumpID>0)&&(strPumpStatus[LFIPAddr]==GetPumpStatusLabel(PS_PRINT_READY))){    	 
    4358:	01 30       	cpi	r16, 0x01	; 1
    435a:	69 f0       	breq	.+26     	; 0x4376 <PrintStandalone+0x48>
    435c:	ee 20       	and	r14, r14
    435e:	79 f1       	breq	.+94     	; 0x43be <PrintStandalone+0x90>
    4360:	80 e1       	ldi	r24, 0x10	; 16
    4362:	0e 94 93 13 	call	0x2726	; 0x2726 <GetPumpStatusLabel>
    4366:	11 50       	subi	r17, 0x01	; 1
    4368:	e1 2f       	mov	r30, r17
    436a:	f0 e0       	ldi	r31, 0x00	; 0
    436c:	ee 5e       	subi	r30, 0xEE	; 238
    436e:	fe 4f       	sbci	r31, 0xFE	; 254
    4370:	90 81       	ld	r25, Z
    4372:	98 17       	cp	r25, r24
    4374:	21 f5       	brne	.+72     	; 0x43be <PrintStandalone+0x90>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    4376:	66 e0       	ldi	r22, 0x06	; 6
    4378:	f6 9e       	mul	r15, r22
    437a:	b0 01       	movw	r22, r0
    437c:	11 24       	eor	r1, r1
    437e:	61 5b       	subi	r22, 0xB1	; 177
    4380:	7f 4f       	sbci	r23, 0xFF	; 255
    4382:	ce 01       	movw	r24, r28
    4384:	01 96       	adiw	r24, 0x01	; 1
    4386:	46 e0       	ldi	r20, 0x06	; 6
    4388:	50 e0       	ldi	r21, 0x00	; 0
    438a:	26 ef       	ldi	r18, 0xF6	; 246
    438c:	32 e1       	ldi	r19, 0x12	; 18
    438e:	0e 94 7a b5 	call	0x16af4	; 0x16af4 <__eerd_block>
		     eeprom_read_block((void*) &PProductID, (const void*) &DefNozzleMap[FIPAddr-1], 6);		 
		     if (((ReprintReady[FIPAddr-1]==True))||(IsReprint==False)){
    4392:	ef 2d       	mov	r30, r15
    4394:	f0 e0       	ldi	r31, 0x00	; 0
    4396:	ef 57       	subi	r30, 0x7F	; 127
    4398:	fe 4f       	sbci	r31, 0xFE	; 254
    439a:	80 81       	ld	r24, Z
    439c:	81 30       	cpi	r24, 0x01	; 1
    439e:	19 f0       	breq	.+6      	; 0x43a6 <PrintStandalone+0x78>
    43a0:	00 23       	and	r16, r16
    43a2:	29 f0       	breq	.+10     	; 0x43ae <PrintStandalone+0x80>
    43a4:	0c c0       	rjmp	.+24     	; 0x43be <PrintStandalone+0x90>
			       if (IsReprint==True)IsReprintTicket=True;
    43a6:	01 30       	cpi	r16, 0x01	; 1
    43a8:	11 f4       	brne	.+4      	; 0x43ae <PrintStandalone+0x80>
    43aa:	00 93 92 01 	sts	0x0192, r16
			       GenerateStandaloneTransData(iPumpID,PProductID);		 			   
    43ae:	8e 2d       	mov	r24, r14
    43b0:	be 01       	movw	r22, r28
    43b2:	6f 5f       	subi	r22, 0xFF	; 255
    43b4:	7f 4f       	sbci	r23, 0xFF	; 255
    43b6:	0e 94 43 20 	call	0x4086	; 0x4086 <GenerateStandaloneTransData>
    43ba:	81 e1       	ldi	r24, 0x11	; 17
    43bc:	01 c0       	rjmp	.+2      	; 0x43c0 <PrintStandalone+0x92>
    43be:	82 e1       	ldi	r24, 0x12	; 18
			 }//else Result=PS_NO_DATA;
		 }
		 //else Result=PS_NO_DATA;    		    
	 }	
   return Result;
}
    43c0:	26 96       	adiw	r28, 0x06	; 6
    43c2:	0f b6       	in	r0, 0x3f	; 63
    43c4:	f8 94       	cli
    43c6:	de bf       	out	0x3e, r29	; 62
    43c8:	0f be       	out	0x3f, r0	; 63
    43ca:	cd bf       	out	0x3d, r28	; 61
    43cc:	cf 91       	pop	r28
    43ce:	df 91       	pop	r29
    43d0:	1f 91       	pop	r17
    43d2:	0f 91       	pop	r16
    43d4:	ff 90       	pop	r15
    43d6:	ef 90       	pop	r14
    43d8:	08 95       	ret

000043da <SumChecksum>:
	Geniflow[1]=Geniflow[0];
	Geniflow[0]=dataIn;
*/
}

char SumChecksum(char *strChecked){
    43da:	ac 01       	movw	r20, r24
     unsigned int SigmaSum=0;
	 char i,Result;
	 for(i=0;i<strlen(strChecked);i++){
    43dc:	dc 01       	movw	r26, r24
    43de:	0d 90       	ld	r0, X+
    43e0:	00 20       	and	r0, r0
    43e2:	e9 f7       	brne	.-6      	; 0x43de <SumChecksum+0x4>
    43e4:	11 97       	sbiw	r26, 0x01	; 1
    43e6:	a8 1b       	sub	r26, r24
    43e8:	b9 0b       	sbc	r27, r25
    43ea:	20 e0       	ldi	r18, 0x00	; 0
    43ec:	30 e0       	ldi	r19, 0x00	; 0
    43ee:	90 e0       	ldi	r25, 0x00	; 0
    43f0:	06 c0       	rjmp	.+12     	; 0x43fe <SumChecksum+0x24>
	     SigmaSum=SigmaSum+strChecked[i];
    43f2:	e4 0f       	add	r30, r20
    43f4:	f5 1f       	adc	r31, r21
    43f6:	80 81       	ld	r24, Z
    43f8:	28 0f       	add	r18, r24
    43fa:	31 1d       	adc	r19, r1
}

char SumChecksum(char *strChecked){
     unsigned int SigmaSum=0;
	 char i,Result;
	 for(i=0;i<strlen(strChecked);i++){
    43fc:	9f 5f       	subi	r25, 0xFF	; 255
    43fe:	e9 2f       	mov	r30, r25
    4400:	f0 e0       	ldi	r31, 0x00	; 0
    4402:	ea 17       	cp	r30, r26
    4404:	fb 07       	cpc	r31, r27
    4406:	a8 f3       	brcs	.-22     	; 0x43f2 <SumChecksum+0x18>
	     SigmaSum=SigmaSum+strChecked[i];
	 }
	 Result=(SigmaSum%255);
    4408:	c9 01       	movw	r24, r18
    440a:	6f ef       	ldi	r22, 0xFF	; 255
    440c:	70 e0       	ldi	r23, 0x00	; 0
    440e:	0e 94 93 b8 	call	0x17126	; 0x17126 <__udivmodhi4>
	 if (Result==0)Result=255;
    4412:	88 23       	and	r24, r24
    4414:	09 f4       	brne	.+2      	; 0x4418 <SumChecksum+0x3e>
    4416:	8f ef       	ldi	r24, 0xFF	; 255
   return Result;
}
    4418:	08 95       	ret

0000441a <IsGeniusCommand>:
	 sprintf_P(strSend,PSTR("%s"),sCSum);
	 _uart_print(1,1,strSend);
*/
}

char IsGeniusCommand(char GCommand){
    441a:	ff 92       	push	r15
    441c:	0f 93       	push	r16
    441e:	1f 93       	push	r17
    4420:	df 93       	push	r29
    4422:	cf 93       	push	r28
    4424:	cd b7       	in	r28, 0x3d	; 61
    4426:	de b7       	in	r29, 0x3e	; 62
    4428:	2a 97       	sbiw	r28, 0x0a	; 10
    442a:	0f b6       	in	r0, 0x3f	; 63
    442c:	f8 94       	cli
    442e:	de bf       	out	0x3e, r29	; 62
    4430:	0f be       	out	0x3f, r0	; 63
    4432:	cd bf       	out	0x3d, r28	; 61
    4434:	f8 2e       	mov	r15, r24
     char i,Result,CommandList[10];
     Result=False;
	 sprintf_P(CommandList,PSTR("CTSRP"));
    4436:	00 d0       	rcall	.+0      	; 0x4438 <IsGeniusCommand+0x1e>
    4438:	00 d0       	rcall	.+0      	; 0x443a <IsGeniusCommand+0x20>
    443a:	8e 01       	movw	r16, r28
    443c:	0f 5f       	subi	r16, 0xFF	; 255
    443e:	1f 4f       	sbci	r17, 0xFF	; 255
    4440:	ed b7       	in	r30, 0x3d	; 61
    4442:	fe b7       	in	r31, 0x3e	; 62
    4444:	12 83       	std	Z+2, r17	; 0x02
    4446:	01 83       	std	Z+1, r16	; 0x01
    4448:	88 e7       	ldi	r24, 0x78	; 120
    444a:	93 e0       	ldi	r25, 0x03	; 3
    444c:	94 83       	std	Z+4, r25	; 0x04
    444e:	83 83       	std	Z+3, r24	; 0x03
    4450:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
	 for(i=0;i<strlen(CommandList);i++){
    4454:	d8 01       	movw	r26, r16
    4456:	0d 90       	ld	r0, X+
    4458:	00 20       	and	r0, r0
    445a:	e9 f7       	brne	.-6      	; 0x4456 <IsGeniusCommand+0x3c>
    445c:	11 97       	sbiw	r26, 0x01	; 1
    445e:	a0 1b       	sub	r26, r16
    4460:	b1 0b       	sbc	r27, r17
    4462:	90 e0       	ldi	r25, 0x00	; 0
    4464:	0f 90       	pop	r0
    4466:	0f 90       	pop	r0
    4468:	0f 90       	pop	r0
    446a:	0f 90       	pop	r0
	    if (CommandList[i]==GCommand){
    446c:	98 01       	movw	r18, r16
    446e:	08 c0       	rjmp	.+16     	; 0x4480 <IsGeniusCommand+0x66>
    4470:	e2 0f       	add	r30, r18
    4472:	f3 1f       	adc	r31, r19
    4474:	80 81       	ld	r24, Z
    4476:	8f 15       	cp	r24, r15
    4478:	11 f4       	brne	.+4      	; 0x447e <IsGeniusCommand+0x64>
    447a:	81 e0       	ldi	r24, 0x01	; 1
    447c:	07 c0       	rjmp	.+14     	; 0x448c <IsGeniusCommand+0x72>

char IsGeniusCommand(char GCommand){
     char i,Result,CommandList[10];
     Result=False;
	 sprintf_P(CommandList,PSTR("CTSRP"));
	 for(i=0;i<strlen(CommandList);i++){
    447e:	9f 5f       	subi	r25, 0xFF	; 255
    4480:	e9 2f       	mov	r30, r25
    4482:	f0 e0       	ldi	r31, 0x00	; 0
    4484:	ea 17       	cp	r30, r26
    4486:	fb 07       	cpc	r31, r27
    4488:	98 f3       	brcs	.-26     	; 0x4470 <IsGeniusCommand+0x56>
    448a:	80 e0       	ldi	r24, 0x00	; 0
		    Result=True;
			break;
			}
	 }
   return Result;	 
}
    448c:	2a 96       	adiw	r28, 0x0a	; 10
    448e:	0f b6       	in	r0, 0x3f	; 63
    4490:	f8 94       	cli
    4492:	de bf       	out	0x3e, r29	; 62
    4494:	0f be       	out	0x3f, r0	; 63
    4496:	cd bf       	out	0x3d, r28	; 61
    4498:	cf 91       	pop	r28
    449a:	df 91       	pop	r29
    449c:	1f 91       	pop	r17
    449e:	0f 91       	pop	r16
    44a0:	ff 90       	pop	r15
    44a2:	08 95       	ret

000044a4 <Pos>:
  return Result;
}
		

//Genius Protocol Version:1.0 AKR
int Pos(char *Substr, char *String){//1245:4645
    44a4:	0f 93       	push	r16
    44a6:	1f 93       	push	r17
    44a8:	cf 93       	push	r28
    44aa:	df 93       	push	r29
    44ac:	ac 01       	movw	r20, r24
    char i,j,CountMatch;
	char Length,subLen,PosFound;

	Length=strlen(String);
    44ae:	fb 01       	movw	r30, r22
    44b0:	01 90       	ld	r0, Z+
    44b2:	00 20       	and	r0, r0
    44b4:	e9 f7       	brne	.-6      	; 0x44b0 <Pos+0xc>
    44b6:	31 97       	sbiw	r30, 0x01	; 1
    44b8:	1e 2f       	mov	r17, r30
    44ba:	16 1b       	sub	r17, r22
	subLen=strlen(Substr);
    44bc:	fc 01       	movw	r30, r24
    44be:	01 90       	ld	r0, Z+
    44c0:	00 20       	and	r0, r0
    44c2:	e9 f7       	brne	.-6      	; 0x44be <Pos+0x1a>
    44c4:	31 97       	sbiw	r30, 0x01	; 1
    44c6:	0e 2f       	mov	r16, r30
    44c8:	08 1b       	sub	r16, r24
    44ca:	db 01       	movw	r26, r22
    44cc:	60 e0       	ldi	r22, 0x00	; 0
    44ce:	18 c0       	rjmp	.+48     	; 0x4500 <Pos+0x5c>
	PosFound=Length;
	for(i=0;i<Length;i++){
	    if (String[i]==Substr[0]){
    44d0:	9c 91       	ld	r25, X
    44d2:	fa 01       	movw	r30, r20
    44d4:	80 81       	ld	r24, Z
    44d6:	98 17       	cp	r25, r24
    44d8:	89 f4       	brne	.+34     	; 0x44fc <Pos+0x58>
    44da:	ed 01       	movw	r28, r26
    44dc:	20 e0       	ldi	r18, 0x00	; 0
    44de:	30 e0       	ldi	r19, 0x00	; 0
    44e0:	09 c0       	rjmp	.+18     	; 0x44f4 <Pos+0x50>
		    CountMatch=0;
			for(j=0;j<subLen;j++){
			    //notFound
			    if (Substr[j]==String[i+j]){
    44e2:	fa 01       	movw	r30, r20
    44e4:	e2 0f       	add	r30, r18
    44e6:	f3 1f       	adc	r31, r19
    44e8:	90 81       	ld	r25, Z
    44ea:	89 91       	ld	r24, Y+
    44ec:	2f 5f       	subi	r18, 0xFF	; 255
    44ee:	3f 4f       	sbci	r19, 0xFF	; 255
    44f0:	98 17       	cp	r25, r24
    44f2:	21 f4       	brne	.+8      	; 0x44fc <Pos+0x58>
	subLen=strlen(Substr);
	PosFound=Length;
	for(i=0;i<Length;i++){
	    if (String[i]==Substr[0]){
		    CountMatch=0;
			for(j=0;j<subLen;j++){
    44f4:	20 17       	cp	r18, r16
    44f6:	a8 f3       	brcs	.-22     	; 0x44e2 <Pos+0x3e>
    44f8:	86 2f       	mov	r24, r22
    44fa:	05 c0       	rjmp	.+10     	; 0x4506 <Pos+0x62>
	char Length,subLen,PosFound;

	Length=strlen(String);
	subLen=strlen(Substr);
	PosFound=Length;
	for(i=0;i<Length;i++){
    44fc:	6f 5f       	subi	r22, 0xFF	; 255
    44fe:	11 96       	adiw	r26, 0x01	; 1
    4500:	61 17       	cp	r22, r17
    4502:	30 f3       	brcs	.-52     	; 0x44d0 <Pos+0x2c>
    4504:	81 2f       	mov	r24, r17
			    break;  
			}
		}
	}
  return  PosFound;
}
    4506:	90 e0       	ldi	r25, 0x00	; 0
    4508:	df 91       	pop	r29
    450a:	cf 91       	pop	r28
    450c:	1f 91       	pop	r17
    450e:	0f 91       	pop	r16
    4510:	08 95       	ret

00004512 <CreateReport>:
//		  }
//	 }
     *Pos=iPos;
}

void CreateReport(char *strData, char *strPrnBuffer, unsigned int *Pos){
    4512:	7f 92       	push	r7
    4514:	8f 92       	push	r8
    4516:	9f 92       	push	r9
    4518:	af 92       	push	r10
    451a:	bf 92       	push	r11
    451c:	cf 92       	push	r12
    451e:	df 92       	push	r13
    4520:	ef 92       	push	r14
    4522:	ff 92       	push	r15
    4524:	0f 93       	push	r16
    4526:	1f 93       	push	r17
    4528:	cf 93       	push	r28
    452a:	df 93       	push	r29
    452c:	5c 01       	movw	r10, r24
    452e:	6b 01       	movw	r12, r22
    4530:	4a 01       	movw	r8, r20
     unsigned int iPos,PosResult,Length;
	 char i,strSend[20];
	 Length=strlen(strData);
    4532:	ec 01       	movw	r28, r24
    4534:	09 90       	ld	r0, Y+
    4536:	00 20       	and	r0, r0
    4538:	e9 f7       	brne	.-6      	; 0x4534 <CreateReport+0x22>
    453a:	21 97       	sbiw	r28, 0x01	; 1
    453c:	c8 1b       	sub	r28, r24
    453e:	d9 0b       	sbc	r29, r25
    4540:	cb 32       	cpi	r28, 0x2B	; 43
    4542:	d1 05       	cpc	r29, r1
    4544:	10 f0       	brcs	.+4      	; 0x454a <CreateReport+0x38>
    4546:	ca e2       	ldi	r28, 0x2A	; 42
    4548:	d0 e0       	ldi	r29, 0x00	; 0
	 if (Length>BORDER_LENGTH)Length=BORDER_LENGTH;
     
	 iPos=*Pos;
    454a:	f4 01       	movw	r30, r8
    454c:	00 81       	ld	r16, Z
    454e:	11 81       	ldd	r17, Z+1	; 0x01
	 strPrnBuffer[iPos]=GetBorderValue(btVertical);
    4550:	76 01       	movw	r14, r12
    4552:	e0 0e       	add	r14, r16
    4554:	f1 1e       	adc	r15, r17
    4556:	8a e0       	ldi	r24, 0x0A	; 10
    4558:	0e 94 45 1a 	call	0x348a	; 0x348a <GetBorderValue>
    455c:	78 2e       	mov	r7, r24
    455e:	f7 01       	movw	r30, r14
    4560:	80 83       	st	Z, r24
     iPos++;
    4562:	98 01       	movw	r18, r16
    4564:	2f 5f       	subi	r18, 0xFF	; 255
    4566:	3f 4f       	sbci	r19, 0xFF	; 255
    4568:	d7 01       	movw	r26, r14
    456a:	90 e0       	ldi	r25, 0x00	; 0
    456c:	07 c0       	rjmp	.+14     	; 0x457c <CreateReport+0x6a>

	 for (i=0;i<Length;i++){	      
	      strPrnBuffer[iPos]=strData[i];	      	 
    456e:	ea 0d       	add	r30, r10
    4570:	fb 1d       	adc	r31, r11
    4572:	80 81       	ld	r24, Z
    4574:	8c 93       	st	X, r24
		  iPos++;
    4576:	2f 5f       	subi	r18, 0xFF	; 255
    4578:	3f 4f       	sbci	r19, 0xFF	; 255
     
	 iPos=*Pos;
	 strPrnBuffer[iPos]=GetBorderValue(btVertical);
     iPos++;

	 for (i=0;i<Length;i++){	      
    457a:	9f 5f       	subi	r25, 0xFF	; 255
    457c:	e9 2f       	mov	r30, r25
    457e:	f0 e0       	ldi	r31, 0x00	; 0
    4580:	11 96       	adiw	r26, 0x01	; 1
    4582:	ec 17       	cp	r30, r28
    4584:	fd 07       	cpc	r31, r29
    4586:	98 f3       	brcs	.-26     	; 0x456e <CreateReport+0x5c>
    4588:	62 2f       	mov	r22, r18
	      strPrnBuffer[iPos]=strData[i];	      	 
		  iPos++;
	 }
	 if (Length<BORDER_LENGTH){
    458a:	ca 32       	cpi	r28, 0x2A	; 42
    458c:	d1 05       	cpc	r29, r1
    458e:	91 f0       	breq	.+36     	; 0x45b4 <CreateReport+0xa2>
    4590:	f6 01       	movw	r30, r12
    4592:	e2 0f       	add	r30, r18
    4594:	f3 1f       	adc	r31, r19
	     for (i=0;i<(BORDER_LENGTH-Length);i++){	      
    4596:	4a e2       	ldi	r20, 0x2A	; 42
    4598:	50 e0       	ldi	r21, 0x00	; 0
    459a:	4c 1b       	sub	r20, r28
    459c:	5d 0b       	sbc	r21, r29
	          strPrnBuffer[iPos]=' ';
    459e:	70 e2       	ldi	r23, 0x20	; 32
    45a0:	03 c0       	rjmp	.+6      	; 0x45a8 <CreateReport+0x96>
    45a2:	71 93       	st	Z+, r23
		      iPos++;
    45a4:	2f 5f       	subi	r18, 0xFF	; 255
    45a6:	3f 4f       	sbci	r19, 0xFF	; 255
	 for (i=0;i<Length;i++){	      
	      strPrnBuffer[iPos]=strData[i];	      	 
		  iPos++;
	 }
	 if (Length<BORDER_LENGTH){
	     for (i=0;i<(BORDER_LENGTH-Length);i++){	      
    45a8:	82 2f       	mov	r24, r18
    45aa:	86 1b       	sub	r24, r22
    45ac:	90 e0       	ldi	r25, 0x00	; 0
    45ae:	84 17       	cp	r24, r20
    45b0:	95 07       	cpc	r25, r21
    45b2:	b8 f3       	brcs	.-18     	; 0x45a2 <CreateReport+0x90>
	          strPrnBuffer[iPos]=' ';
		      iPos++;
	     }	    
	 }
	 strPrnBuffer[iPos]=GetBorderValue(btVertical);
    45b4:	f6 01       	movw	r30, r12
    45b6:	e2 0f       	add	r30, r18
    45b8:	f3 1f       	adc	r31, r19
    45ba:	70 82       	st	Z, r7
     iPos++;
    45bc:	c9 01       	movw	r24, r18
    45be:	01 96       	adiw	r24, 0x01	; 1
     //PosResult=*Pos+Length;
	 strPrnBuffer[iPos]=0x0D; 
    45c0:	c8 0e       	add	r12, r24
    45c2:	d9 1e       	adc	r13, r25
    45c4:	2d e0       	ldi	r18, 0x0D	; 13
    45c6:	f6 01       	movw	r30, r12
    45c8:	20 83       	st	Z, r18
	 iPos++;

   //*Pos=PosResult+1;
   *Pos=iPos;
    45ca:	01 96       	adiw	r24, 0x01	; 1
    45cc:	f4 01       	movw	r30, r8
    45ce:	91 83       	std	Z+1, r25	; 0x01
    45d0:	80 83       	st	Z, r24
    //sprintf_P(strSend,PSTR("Pos:%d"),*Pos);
	//_uart_print(0,1,strSend);
}
    45d2:	df 91       	pop	r29
    45d4:	cf 91       	pop	r28
    45d6:	1f 91       	pop	r17
    45d8:	0f 91       	pop	r16
    45da:	ff 90       	pop	r15
    45dc:	ef 90       	pop	r14
    45de:	df 90       	pop	r13
    45e0:	cf 90       	pop	r12
    45e2:	bf 90       	pop	r11
    45e4:	af 90       	pop	r10
    45e6:	9f 90       	pop	r9
    45e8:	8f 90       	pop	r8
    45ea:	7f 90       	pop	r7
    45ec:	08 95       	ret

000045ee <AddList>:

//AddListTotal(xGrade,strRef1);
void ClearList(char *strList){
     FillChar(strList,strlen(strList),0);
}
void AddList(char GradeId, char *strList){
    45ee:	38 2f       	mov	r19, r24
    45f0:	ab 01       	movw	r20, r22
     char i,iPos,Length,IsFound=False;	 
	 if ((GradeId>=1)&&((GradeId<=6))){
    45f2:	81 50       	subi	r24, 0x01	; 1
    45f4:	86 30       	cpi	r24, 0x06	; 6
    45f6:	68 f5       	brcc	.+90     	; 0x4652 <AddList+0x64>
		 iPos=0;
		 IsFound=False;	
		 Length=strlen(strList);
    45f8:	fb 01       	movw	r30, r22
    45fa:	01 90       	ld	r0, Z+
    45fc:	00 20       	and	r0, r0
    45fe:	e9 f7       	brne	.-6      	; 0x45fa <AddList+0xc>
    4600:	31 97       	sbiw	r30, 0x01	; 1
    4602:	e6 1b       	sub	r30, r22
    4604:	f7 0b       	sbc	r31, r23
    4606:	7e 2f       	mov	r23, r30
	     if (Length>0){
    4608:	ee 23       	and	r30, r30
    460a:	11 f4       	brne	.+4      	; 0x4610 <AddList+0x22>
    460c:	20 e0       	ldi	r18, 0x00	; 0
    460e:	14 c0       	rjmp	.+40     	; 0x4638 <AddList+0x4a>
    4610:	80 e0       	ldi	r24, 0x00	; 0
    4612:	90 e0       	ldi	r25, 0x00	; 0
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
	    Result='0'+X;
    4614:	63 2f       	mov	r22, r19
    4616:	60 5d       	subi	r22, 0xD0	; 208
		 Length=strlen(strList);
	     if (Length>0){
			 for (i=0;i<Length;i++){//"123"
			      //_uart(1,1,strList[i]);
			      iPos++;
			      if (strList[i]==Chr(GradeId)){
    4618:	fa 01       	movw	r30, r20
    461a:	e8 0f       	add	r30, r24
    461c:	f9 1f       	adc	r31, r25
    461e:	e0 81       	ld	r30, Z
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    4620:	3a 30       	cpi	r19, 0x0A	; 10
    4622:	10 f0       	brcs	.+4      	; 0x4628 <AddList+0x3a>
    4624:	20 e3       	ldi	r18, 0x30	; 48
    4626:	01 c0       	rjmp	.+2      	; 0x462a <AddList+0x3c>
	    Result='0'+X;
    4628:	26 2f       	mov	r18, r22
		 Length=strlen(strList);
	     if (Length>0){
			 for (i=0;i<Length;i++){//"123"
			      //_uart(1,1,strList[i]);
			      iPos++;
			      if (strList[i]==Chr(GradeId)){
    462a:	e2 17       	cp	r30, r18
    462c:	91 f0       	breq	.+36     	; 0x4652 <AddList+0x64>
    462e:	28 2f       	mov	r18, r24
    4630:	2f 5f       	subi	r18, 0xFF	; 255
    4632:	01 96       	adiw	r24, 0x01	; 1
	 if ((GradeId>=1)&&((GradeId<=6))){
		 iPos=0;
		 IsFound=False;	
		 Length=strlen(strList);
	     if (Length>0){
			 for (i=0;i<Length;i++){//"123"
    4634:	87 17       	cp	r24, r23
    4636:	80 f3       	brcs	.-32     	; 0x4618 <AddList+0x2a>
					  break;
				  }
			 }
	     }
		 if (IsFound==False){
		     strList[iPos]=Chr(GradeId);
    4638:	62 2f       	mov	r22, r18
    463a:	70 e0       	ldi	r23, 0x00	; 0
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    463c:	3a 30       	cpi	r19, 0x0A	; 10
    463e:	10 f0       	brcs	.+4      	; 0x4644 <AddList+0x56>
    4640:	80 e3       	ldi	r24, 0x30	; 48
    4642:	02 c0       	rjmp	.+4      	; 0x4648 <AddList+0x5a>
	    Result='0'+X;
    4644:	83 2f       	mov	r24, r19
    4646:	80 5d       	subi	r24, 0xD0	; 208
					  break;
				  }
			 }
	     }
		 if (IsFound==False){
		     strList[iPos]=Chr(GradeId);
    4648:	fa 01       	movw	r30, r20
    464a:	e6 0f       	add	r30, r22
    464c:	f7 1f       	adc	r31, r23
    464e:	80 83       	st	Z, r24
		     strList[iPos+1]=0;
    4650:	11 82       	std	Z+1, r1	; 0x01
    4652:	08 95       	ret

00004654 <ClearList>:
	 AddSpaceLag(strProductName,10);
}

//AddListTotal(xGrade,strRef1);
void ClearList(char *strList){
     FillChar(strList,strlen(strList),0);
    4654:	dc 01       	movw	r26, r24
    4656:	0d 90       	ld	r0, X+
    4658:	00 20       	and	r0, r0
    465a:	e9 f7       	brne	.-6      	; 0x4656 <ClearList+0x2>
    465c:	11 97       	sbiw	r26, 0x01	; 1
    465e:	a8 1b       	sub	r26, r24
    4660:	b9 0b       	sbc	r27, r25
    4662:	20 e0       	ldi	r18, 0x00	; 0
    4664:	30 e0       	ldi	r19, 0x00	; 0
    4666:	06 c0       	rjmp	.+12     	; 0x4674 <ClearList+0x20>
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    4668:	fc 01       	movw	r30, r24
    466a:	e2 0f       	add	r30, r18
    466c:	f3 1f       	adc	r31, r19
    466e:	10 82       	st	Z, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    4670:	2f 5f       	subi	r18, 0xFF	; 255
    4672:	3f 4f       	sbci	r19, 0xFF	; 255
    4674:	2a 17       	cp	r18, r26
    4676:	3b 07       	cpc	r19, r27
    4678:	b8 f3       	brcs	.-18     	; 0x4668 <ClearList+0x14>
}

//AddListTotal(xGrade,strRef1);
void ClearList(char *strList){
     FillChar(strList,strlen(strList),0);
}
    467a:	08 95       	ret

0000467c <CalcSegmen>:
		 */
		 CalcMultiply(strA,strB,strC);
	 }
}

void CalcSegmen(char *strMain, char cNum, char *strResult){
    467c:	6f 92       	push	r6
    467e:	7f 92       	push	r7
    4680:	8f 92       	push	r8
    4682:	9f 92       	push	r9
    4684:	bf 92       	push	r11
    4686:	cf 92       	push	r12
    4688:	df 92       	push	r13
    468a:	ef 92       	push	r14
    468c:	ff 92       	push	r15
    468e:	0f 93       	push	r16
    4690:	1f 93       	push	r17
    4692:	df 93       	push	r29
    4694:	cf 93       	push	r28
    4696:	cd b7       	in	r28, 0x3d	; 61
    4698:	de b7       	in	r29, 0x3e	; 62
    469a:	64 97       	sbiw	r28, 0x14	; 20
    469c:	0f b6       	in	r0, 0x3f	; 63
    469e:	f8 94       	cli
    46a0:	de bf       	out	0x3e, r29	; 62
    46a2:	0f be       	out	0x3f, r0	; 63
    46a4:	cd bf       	out	0x3d, r28	; 61
    46a6:	7c 01       	movw	r14, r24
    46a8:	6a 01       	movw	r12, r20
    46aa:	bb 24       	eor	r11, r11
    46ac:	30 e0       	ldi	r19, 0x00	; 0

	 xResNext=0;
     xRes=0;

	 for(i=0;i<strlen(strMain);i++){           
         xCalc=(strMain[strlen(strMain)-1-i]-'0')*(cNum-'0')+xResNext;//Hasil
    46ae:	06 2f       	mov	r16, r22
    46b0:	10 e0       	ldi	r17, 0x00	; 0
    46b2:	00 53       	subi	r16, 0x30	; 48
    46b4:	10 40       	sbci	r17, 0x00	; 0
		 xRes=xCalc%10;
		 xResNext=xCalc/10;
	     tmpResult[i]='0'+xRes;	 
    46b6:	3e 01       	movw	r6, r28
    46b8:	08 94       	sec
    46ba:	61 1c       	adc	r6, r1
    46bc:	71 1c       	adc	r7, r1
		 tmpResult[i+1]=0;
    46be:	b2 e0       	ldi	r27, 0x02	; 2
    46c0:	8b 2e       	mov	r8, r27
    46c2:	91 2c       	mov	r9, r1
    46c4:	8c 0e       	add	r8, r28
    46c6:	9d 1e       	adc	r9, r29
    46c8:	24 c0       	rjmp	.+72     	; 0x4712 <CalcSegmen+0x96>

	 xResNext=0;
     xRes=0;

	 for(i=0;i<strlen(strMain);i++){           
         xCalc=(strMain[strlen(strMain)-1-i]-'0')*(cNum-'0')+xResNext;//Hasil
    46ca:	11 97       	sbiw	r26, 0x01	; 1
    46cc:	a4 1b       	sub	r26, r20
    46ce:	b5 0b       	sbc	r27, r21
    46d0:	ae 0d       	add	r26, r14
    46d2:	bf 1d       	adc	r27, r15
    46d4:	8c 91       	ld	r24, X
    46d6:	90 e0       	ldi	r25, 0x00	; 0
    46d8:	c0 97       	sbiw	r24, 0x30	; 48
    46da:	bc 01       	movw	r22, r24
    46dc:	60 9f       	mul	r22, r16
    46de:	c0 01       	movw	r24, r0
    46e0:	61 9f       	mul	r22, r17
    46e2:	90 0d       	add	r25, r0
    46e4:	70 9f       	mul	r23, r16
    46e6:	90 0d       	add	r25, r0
    46e8:	11 24       	eor	r1, r1
    46ea:	23 2f       	mov	r18, r19
    46ec:	28 0f       	add	r18, r24
		 xRes=xCalc%10;
		 xResNext=xCalc/10;
    46ee:	82 2f       	mov	r24, r18
    46f0:	6a e0       	ldi	r22, 0x0A	; 10
    46f2:	0e 94 7a b8 	call	0x170f4	; 0x170f4 <__udivmodqi4>
    46f6:	38 2f       	mov	r19, r24
	     tmpResult[i]='0'+xRes;	 
    46f8:	f3 01       	movw	r30, r6
    46fa:	e4 0f       	add	r30, r20
    46fc:	f5 1f       	adc	r31, r21
    46fe:	82 2f       	mov	r24, r18
    4700:	0e 94 7a b8 	call	0x170f4	; 0x170f4 <__udivmodqi4>
    4704:	90 5d       	subi	r25, 0xD0	; 208
    4706:	90 83       	st	Z, r25
		 tmpResult[i+1]=0;
    4708:	48 0d       	add	r20, r8
    470a:	59 1d       	adc	r21, r9
    470c:	fa 01       	movw	r30, r20
    470e:	10 82       	st	Z, r1
	 char i,lenR,xCalc,xRes,xResNext,tmpResult[20];

	 xResNext=0;
     xRes=0;

	 for(i=0;i<strlen(strMain);i++){           
    4710:	b3 94       	inc	r11
    4712:	4b 2d       	mov	r20, r11
    4714:	50 e0       	ldi	r21, 0x00	; 0
    4716:	d7 01       	movw	r26, r14
    4718:	0d 90       	ld	r0, X+
    471a:	00 20       	and	r0, r0
    471c:	e9 f7       	brne	.-6      	; 0x4718 <CalcSegmen+0x9c>
    471e:	11 97       	sbiw	r26, 0x01	; 1
    4720:	ae 19       	sub	r26, r14
    4722:	bf 09       	sbc	r27, r15
    4724:	4a 17       	cp	r20, r26
    4726:	5b 07       	cpc	r21, r27
    4728:	80 f2       	brcs	.-96     	; 0x46ca <CalcSegmen+0x4e>
		 xRes=xCalc%10;
		 xResNext=xCalc/10;
	     tmpResult[i]='0'+xRes;	 
		 tmpResult[i+1]=0;
	 }
	 if (xResNext>0){
    472a:	33 23       	and	r19, r19
    472c:	89 f0       	breq	.+34     	; 0x4750 <CalcSegmen+0xd4>
	     lenR=strlen(tmpResult);
    472e:	fe 01       	movw	r30, r28
    4730:	31 96       	adiw	r30, 0x01	; 1
    4732:	df 01       	movw	r26, r30
    4734:	0d 90       	ld	r0, X+
    4736:	00 20       	and	r0, r0
    4738:	e9 f7       	brne	.-6      	; 0x4734 <CalcSegmen+0xb8>
    473a:	11 97       	sbiw	r26, 0x01	; 1
	     tmpResult[lenR]='0'+xResNext;
    473c:	ae 1b       	sub	r26, r30
    473e:	b0 e0       	ldi	r27, 0x00	; 0
    4740:	ea 0f       	add	r30, r26
    4742:	fb 1f       	adc	r31, r27
    4744:	30 5d       	subi	r19, 0xD0	; 208
    4746:	30 83       	st	Z, r19
		 tmpResult[lenR+1]=0;	 
    4748:	ac 0f       	add	r26, r28
    474a:	bd 1f       	adc	r27, r29
    474c:	12 96       	adiw	r26, 0x02	; 2
    474e:	1c 92       	st	X, r1
	 }
	 lenR=strlen(tmpResult);
    4750:	de 01       	movw	r26, r28
    4752:	11 96       	adiw	r26, 0x01	; 1
    4754:	fd 01       	movw	r30, r26
    4756:	01 90       	ld	r0, Z+
    4758:	00 20       	and	r0, r0
    475a:	e9 f7       	brne	.-6      	; 0x4756 <CalcSegmen+0xda>
    475c:	31 97       	sbiw	r30, 0x01	; 1
    475e:	9e 2f       	mov	r25, r30
    4760:	9a 1b       	sub	r25, r26
    4762:	a9 0f       	add	r26, r25
    4764:	b1 1d       	adc	r27, r1
    4766:	f6 01       	movw	r30, r12
    4768:	02 c0       	rjmp	.+4      	; 0x476e <CalcSegmen+0xf2>
	 for (i=0;i<lenR;i++){
	     strResult[i]=tmpResult[lenR-1-i];
    476a:	8c 91       	ld	r24, X
    476c:	81 93       	st	Z+, r24
    476e:	11 97       	sbiw	r26, 0x01	; 1
	     lenR=strlen(tmpResult);
	     tmpResult[lenR]='0'+xResNext;
		 tmpResult[lenR+1]=0;	 
	 }
	 lenR=strlen(tmpResult);
	 for (i=0;i<lenR;i++){
    4770:	ac 17       	cp	r26, r28
    4772:	bd 07       	cpc	r27, r29
    4774:	d1 f7       	brne	.-12     	; 0x476a <CalcSegmen+0xee>
	     strResult[i]=tmpResult[lenR-1-i];
	 }
	 strResult[lenR]=0;
    4776:	c9 0e       	add	r12, r25
    4778:	d1 1c       	adc	r13, r1
    477a:	f6 01       	movw	r30, r12
    477c:	10 82       	st	Z, r1
}
    477e:	64 96       	adiw	r28, 0x14	; 20
    4780:	0f b6       	in	r0, 0x3f	; 63
    4782:	f8 94       	cli
    4784:	de bf       	out	0x3e, r29	; 62
    4786:	0f be       	out	0x3f, r0	; 63
    4788:	cd bf       	out	0x3d, r28	; 61
    478a:	cf 91       	pop	r28
    478c:	df 91       	pop	r29
    478e:	1f 91       	pop	r17
    4790:	0f 91       	pop	r16
    4792:	ff 90       	pop	r15
    4794:	ef 90       	pop	r14
    4796:	df 90       	pop	r13
    4798:	cf 90       	pop	r12
    479a:	bf 90       	pop	r11
    479c:	9f 90       	pop	r9
    479e:	8f 90       	pop	r8
    47a0:	7f 90       	pop	r7
    47a2:	6f 90       	pop	r6
    47a4:	08 95       	ret

000047a6 <GetMinusPos>:
		  if (KeyChar=='*')stTestCalc=tcInitData;
	      break;	 
	 }
}

char GetMinusPos(char *strNumber){
    47a6:	ac 01       	movw	r20, r24
char i,Result;
     Result=0;
     for(i=0;i<strlen(strNumber);i++){
    47a8:	dc 01       	movw	r26, r24
    47aa:	0d 90       	ld	r0, X+
    47ac:	00 20       	and	r0, r0
    47ae:	e9 f7       	brne	.-6      	; 0x47aa <GetMinusPos+0x4>
    47b0:	11 97       	sbiw	r26, 0x01	; 1
    47b2:	a8 1b       	sub	r26, r24
    47b4:	b9 0b       	sbc	r27, r25
    47b6:	20 e0       	ldi	r18, 0x00	; 0
    47b8:	0a c0       	rjmp	.+20     	; 0x47ce <GetMinusPos+0x28>
	     if (strNumber[i]=='-'){
    47ba:	e4 0f       	add	r30, r20
    47bc:	f5 1f       	adc	r31, r21
    47be:	80 81       	ld	r24, Z
    47c0:	92 2f       	mov	r25, r18
    47c2:	9f 5f       	subi	r25, 0xFF	; 255
    47c4:	8d 32       	cpi	r24, 0x2D	; 45
    47c6:	11 f4       	brne	.+4      	; 0x47cc <GetMinusPos+0x26>
		     Result=i+1;
    47c8:	89 2f       	mov	r24, r25
    47ca:	08 95       	ret
}

char GetMinusPos(char *strNumber){
char i,Result;
     Result=0;
     for(i=0;i<strlen(strNumber);i++){
    47cc:	29 2f       	mov	r18, r25
    47ce:	e2 2f       	mov	r30, r18
    47d0:	f0 e0       	ldi	r31, 0x00	; 0
    47d2:	ea 17       	cp	r30, r26
    47d4:	fb 07       	cpc	r31, r27
    47d6:	88 f3       	brcs	.-30     	; 0x47ba <GetMinusPos+0x14>
    47d8:	80 e0       	ldi	r24, 0x00	; 0
		     Result=i+1;
			 break;
		 }
	 }
  return Result;     
}
    47da:	08 95       	ret

000047dc <IsMinus>:

char IsMinus(char *strNumber){
char i,Result=False;
     Result=False;
	 if (GetMinusPos(strNumber)>0){
    47dc:	0e 94 d3 23 	call	0x47a6	; 0x47a6 <GetMinusPos>
    47e0:	81 11       	cpse	r24, r1
    47e2:	81 e0       	ldi	r24, 0x01	; 1
	     Result=True;
	 }     
  return Result;
}
    47e4:	08 95       	ret

000047e6 <RemoveMinus>:

void RemoveMinus(char *strNumber){
    47e6:	cf 93       	push	r28
    47e8:	df 93       	push	r29
    47ea:	ec 01       	movw	r28, r24
     char MinPos,Length;

     if (IsMinus(strNumber)==True){
    47ec:	0e 94 ee 23 	call	0x47dc	; 0x47dc <IsMinus>
    47f0:	81 30       	cpi	r24, 0x01	; 1
    47f2:	19 f5       	brne	.+70     	; 0x483a <RemoveMinus+0x54>
	     MinPos=GetMinusPos(strNumber);
    47f4:	ce 01       	movw	r24, r28
    47f6:	0e 94 d3 23 	call	0x47a6	; 0x47a6 <GetMinusPos>
		 Length=strlen(strNumber);
    47fa:	de 01       	movw	r26, r28
    47fc:	0d 90       	ld	r0, X+
    47fe:	00 20       	and	r0, r0
    4800:	e9 f7       	brne	.-6      	; 0x47fc <RemoveMinus+0x16>
    4802:	11 97       	sbiw	r26, 0x01	; 1
		 StrPosCopy(strNumber,strNumber,MinPos,(Length-MinPos));	      
    4804:	ac 1b       	sub	r26, r28
    4806:	b0 e0       	ldi	r27, 0x00	; 0
    4808:	90 e0       	ldi	r25, 0x00	; 0
    480a:	a8 1b       	sub	r26, r24
    480c:	b9 0b       	sbc	r27, r25
    480e:	ae 01       	movw	r20, r28
    4810:	48 0f       	add	r20, r24
    4812:	59 1f       	adc	r21, r25
    4814:	20 e0       	ldi	r18, 0x00	; 0
    4816:	30 e0       	ldi	r19, 0x00	; 0
    4818:	0a c0       	rjmp	.+20     	; 0x482e <RemoveMinus+0x48>
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    481a:	be 01       	movw	r22, r28
    481c:	62 0f       	add	r22, r18
    481e:	73 1f       	adc	r23, r19
    4820:	fa 01       	movw	r30, r20
    4822:	81 91       	ld	r24, Z+
    4824:	af 01       	movw	r20, r30
    4826:	fb 01       	movw	r30, r22
    4828:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    482a:	2f 5f       	subi	r18, 0xFF	; 255
    482c:	3f 4f       	sbci	r19, 0xFF	; 255
    482e:	2a 17       	cp	r18, r26
    4830:	3b 07       	cpc	r19, r27
    4832:	98 f3       	brcs	.-26     	; 0x481a <RemoveMinus+0x34>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    4834:	ac 0f       	add	r26, r28
    4836:	bd 1f       	adc	r27, r29
    4838:	1c 92       	st	X, r1
     if (IsMinus(strNumber)==True){
	     MinPos=GetMinusPos(strNumber);
		 Length=strlen(strNumber);
		 StrPosCopy(strNumber,strNumber,MinPos,(Length-MinPos));	      
	 }
}
    483a:	df 91       	pop	r29
    483c:	cf 91       	pop	r28
    483e:	08 95       	ret

00004840 <IsMoreThan>:
	    Result=c-'0';
	 }
	return Result;
}

char IsMoreThan(char *strA, char *strB){
    4840:	ac 01       	movw	r20, r24
    4842:	27 2f       	mov	r18, r23
     char i,LengthA,LengthB,Result=False;
	 char strSend[20];	 
     //Check Length
	 LengthA=strlen(strA);
    4844:	fc 01       	movw	r30, r24
    4846:	01 90       	ld	r0, Z+
    4848:	00 20       	and	r0, r0
    484a:	e9 f7       	brne	.-6      	; 0x4846 <IsMoreThan+0x6>
    484c:	31 97       	sbiw	r30, 0x01	; 1
    484e:	7e 2f       	mov	r23, r30
    4850:	78 1b       	sub	r23, r24
	 LengthB=strlen(strB);
    4852:	a6 2f       	mov	r26, r22
    4854:	b2 2f       	mov	r27, r18
    4856:	fd 01       	movw	r30, r26
    4858:	01 90       	ld	r0, Z+
    485a:	00 20       	and	r0, r0
    485c:	e9 f7       	brne	.-6      	; 0x4858 <IsMoreThan+0x18>
    485e:	31 97       	sbiw	r30, 0x01	; 1
    4860:	e6 1b       	sub	r30, r22
	 Result=False;
	 if (LengthA>LengthB)Result=True;
    4862:	e7 17       	cp	r30, r23
    4864:	48 f1       	brcs	.+82     	; 0x48b8 <IsMoreThan+0x78>
	 else 
	 if (LengthA==LengthB){          //456755 
    4866:	7e 17       	cp	r23, r30
    4868:	49 f5       	brne	.+82     	; 0x48bc <IsMoreThan+0x7c>
    486a:	86 2f       	mov	r24, r22
    486c:	92 2f       	mov	r25, r18
    486e:	9c 01       	movw	r18, r24
    4870:	d9 01       	movw	r26, r18
    4872:	20 e0       	ldi	r18, 0x00	; 0
    4874:	30 e0       	ldi	r19, 0x00	; 0
    4876:	1d c0       	rjmp	.+58     	; 0x48b2 <IsMoreThan+0x72>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    4878:	fa 01       	movw	r30, r20
    487a:	e2 0f       	add	r30, r18
    487c:	f3 1f       	adc	r31, r19
    487e:	e0 81       	ld	r30, Z
    4880:	e0 53       	subi	r30, 0x30	; 48
    4882:	ea 30       	cpi	r30, 0x0A	; 10
    4884:	10 f0       	brcs	.+4      	; 0x488a <IsMoreThan+0x4a>
    4886:	60 e0       	ldi	r22, 0x00	; 0
    4888:	01 c0       	rjmp	.+2      	; 0x488c <IsMoreThan+0x4c>
    488a:	6e 2f       	mov	r22, r30
	 Result=False;
	 if (LengthA>LengthB)Result=True;
	 else 
	 if (LengthA==LengthB){          //456755 
	     for(i=0;i<LengthA;i++){    //456410   
		     if (Ord(strA[i])>Ord(strB[i])){
    488c:	8c 91       	ld	r24, X
    488e:	80 53       	subi	r24, 0x30	; 48
    4890:	8a 30       	cpi	r24, 0x0A	; 10
    4892:	10 f0       	brcs	.+4      	; 0x4898 <IsMoreThan+0x58>
    4894:	90 e0       	ldi	r25, 0x00	; 0
    4896:	01 c0       	rjmp	.+2      	; 0x489a <IsMoreThan+0x5a>
    4898:	98 2f       	mov	r25, r24
    489a:	96 17       	cp	r25, r22
    489c:	68 f0       	brcs	.+26     	; 0x48b8 <IsMoreThan+0x78>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    489e:	ea 30       	cpi	r30, 0x0A	; 10
    48a0:	08 f0       	brcs	.+2      	; 0x48a4 <IsMoreThan+0x64>
    48a2:	e0 e0       	ldi	r30, 0x00	; 0
	 if (LengthA==LengthB){          //456755 
	     for(i=0;i<LengthA;i++){    //456410   
		     if (Ord(strA[i])>Ord(strB[i])){
			     Result=True;
				 break;
			 }else if (Ord(strA[i])<Ord(strB[i])){
    48a4:	8a 30       	cpi	r24, 0x0A	; 10
    48a6:	10 f4       	brcc	.+4      	; 0x48ac <IsMoreThan+0x6c>
    48a8:	e8 17       	cp	r30, r24
    48aa:	40 f0       	brcs	.+16     	; 0x48bc <IsMoreThan+0x7c>
    48ac:	2f 5f       	subi	r18, 0xFF	; 255
    48ae:	3f 4f       	sbci	r19, 0xFF	; 255
    48b0:	11 96       	adiw	r26, 0x01	; 1
	 LengthB=strlen(strB);
	 Result=False;
	 if (LengthA>LengthB)Result=True;
	 else 
	 if (LengthA==LengthB){          //456755 
	     for(i=0;i<LengthA;i++){    //456410   
    48b2:	27 17       	cp	r18, r23
    48b4:	08 f3       	brcs	.-62     	; 0x4878 <IsMoreThan+0x38>
    48b6:	02 c0       	rjmp	.+4      	; 0x48bc <IsMoreThan+0x7c>
    48b8:	81 e0       	ldi	r24, 0x01	; 1
    48ba:	08 95       	ret
    48bc:	80 e0       	ldi	r24, 0x00	; 0
				 break;
			 }			 		 
		 }
	 }
  return Result;
}
    48be:	08 95       	ret

000048c0 <IsZerroAll>:
   return Result;
}

char IsZerroAll(char *strZerro){
     char i,Length,nZerro=0,Result;
	 Length=strlen(strZerro);
    48c0:	fc 01       	movw	r30, r24
    48c2:	01 90       	ld	r0, Z+
    48c4:	00 20       	and	r0, r0
    48c6:	e9 f7       	brne	.-6      	; 0x48c2 <IsZerroAll+0x2>
    48c8:	31 97       	sbiw	r30, 0x01	; 1
    48ca:	e8 1b       	sub	r30, r24
    48cc:	dc 01       	movw	r26, r24
    48ce:	ae 0f       	add	r26, r30
    48d0:	b1 1d       	adc	r27, r1
    48d2:	90 e0       	ldi	r25, 0x00	; 0
    48d4:	20 e0       	ldi	r18, 0x00	; 0
    48d6:	06 c0       	rjmp	.+12     	; 0x48e4 <IsZerroAll+0x24>
	 nZerro=0;
	 Result=False;
	 for(i=0;i<Length;i++){
	     if (strZerro[Length-i]=='0')nZerro++;
    48d8:	8c 91       	ld	r24, X
    48da:	80 33       	cpi	r24, 0x30	; 48
    48dc:	09 f4       	brne	.+2      	; 0x48e0 <IsZerroAll+0x20>
    48de:	2f 5f       	subi	r18, 0xFF	; 255
char IsZerroAll(char *strZerro){
     char i,Length,nZerro=0,Result;
	 Length=strlen(strZerro);
	 nZerro=0;
	 Result=False;
	 for(i=0;i<Length;i++){
    48e0:	9f 5f       	subi	r25, 0xFF	; 255
    48e2:	11 97       	sbiw	r26, 0x01	; 1
    48e4:	9e 17       	cp	r25, r30
    48e6:	c0 f3       	brcs	.-16     	; 0x48d8 <IsZerroAll+0x18>
    48e8:	80 e0       	ldi	r24, 0x00	; 0
    48ea:	2e 17       	cp	r18, r30
    48ec:	09 f4       	brne	.+2      	; 0x48f0 <IsZerroAll+0x30>
    48ee:	81 e0       	ldi	r24, 0x01	; 1
	     if (strZerro[Length-i]=='0')nZerro++;
	 }if (nZerro==Length) Result=True;
  return Result;
}
    48f0:	08 95       	ret

000048f2 <PstrCopy>:
     _uart(_COM_PRINTER, 1, 0x0D);     
     _uart(_COM_PRINTER, 1, 0x0A);

}

void PstrCopy(char *Dest,char *Source){
    48f2:	cf 93       	push	r28
    48f4:	df 93       	push	r29
    48f6:	20 e0       	ldi	r18, 0x00	; 0
    48f8:	08 c0       	rjmp	.+16     	; 0x490a <PstrCopy+0x18>
     char i=0;
	 for(i=0;i<strlen(Source);i++){
	    Dest[i]=pgm_read_byte(&Source[i]);
    48fa:	fb 01       	movw	r30, r22
    48fc:	ec 0f       	add	r30, r28
    48fe:	fd 1f       	adc	r31, r29
    4900:	e4 91       	lpm	r30, Z+
    4902:	c8 0f       	add	r28, r24
    4904:	d9 1f       	adc	r29, r25
    4906:	e8 83       	st	Y, r30

}

void PstrCopy(char *Dest,char *Source){
     char i=0;
	 for(i=0;i<strlen(Source);i++){
    4908:	2f 5f       	subi	r18, 0xFF	; 255
    490a:	c2 2f       	mov	r28, r18
    490c:	d0 e0       	ldi	r29, 0x00	; 0
    490e:	fb 01       	movw	r30, r22
    4910:	01 90       	ld	r0, Z+
    4912:	00 20       	and	r0, r0
    4914:	e9 f7       	brne	.-6      	; 0x4910 <PstrCopy+0x1e>
    4916:	31 97       	sbiw	r30, 0x01	; 1
    4918:	e6 1b       	sub	r30, r22
    491a:	f7 0b       	sbc	r31, r23
    491c:	ce 17       	cp	r28, r30
    491e:	df 07       	cpc	r29, r31
    4920:	60 f3       	brcs	.-40     	; 0x48fa <PstrCopy+0x8>
	    Dest[i]=pgm_read_byte(&Source[i]);
	 }
}
    4922:	df 91       	pop	r29
    4924:	cf 91       	pop	r28
    4926:	08 95       	ret

00004928 <SpaceOnly>:
	     if (strDecimal[i]==DecPointMark)
		     strDecimal[i]=0;
	 }
}

char SpaceOnly(char *string){
    4928:	ac 01       	movw	r20, r24
     char Result,nChar=0;
	 unsigned int i=0;
	 nChar=0;
	 Result=False;
	 for(i=0;i<strlen(string);i++){
    492a:	dc 01       	movw	r26, r24
    492c:	0d 90       	ld	r0, X+
    492e:	00 20       	and	r0, r0
    4930:	e9 f7       	brne	.-6      	; 0x492c <SpaceOnly+0x4>
    4932:	11 97       	sbiw	r26, 0x01	; 1
    4934:	a8 1b       	sub	r26, r24
    4936:	b9 0b       	sbc	r27, r25
    4938:	90 e0       	ldi	r25, 0x00	; 0
    493a:	20 e0       	ldi	r18, 0x00	; 0
    493c:	30 e0       	ldi	r19, 0x00	; 0
    493e:	09 c0       	rjmp	.+18     	; 0x4952 <SpaceOnly+0x2a>
	    if(string[i]!=' ') nChar++;
    4940:	fa 01       	movw	r30, r20
    4942:	e2 0f       	add	r30, r18
    4944:	f3 1f       	adc	r31, r19
    4946:	80 81       	ld	r24, Z
    4948:	80 32       	cpi	r24, 0x20	; 32
    494a:	09 f0       	breq	.+2      	; 0x494e <SpaceOnly+0x26>
    494c:	9f 5f       	subi	r25, 0xFF	; 255
char SpaceOnly(char *string){
     char Result,nChar=0;
	 unsigned int i=0;
	 nChar=0;
	 Result=False;
	 for(i=0;i<strlen(string);i++){
    494e:	2f 5f       	subi	r18, 0xFF	; 255
    4950:	3f 4f       	sbci	r19, 0xFF	; 255
    4952:	2a 17       	cp	r18, r26
    4954:	3b 07       	cpc	r19, r27
    4956:	a0 f3       	brcs	.-24     	; 0x4940 <SpaceOnly+0x18>
    4958:	80 e0       	ldi	r24, 0x00	; 0
    495a:	99 23       	and	r25, r25
    495c:	09 f4       	brne	.+2      	; 0x4960 <SpaceOnly+0x38>
    495e:	81 e0       	ldi	r24, 0x01	; 1
	 }
	 if (nChar>0) Result=False;
	 else Result=True;

	 return Result;
}
    4960:	08 95       	ret

00004962 <RemDecimal>:
	 }
}



void RemDecimal(char *strDecimal){//4500.00-->4500
    4962:	9c 01       	movw	r18, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    4964:	e1 99       	sbic	0x1c, 1	; 28
    4966:	fe cf       	rjmp	.-4      	; 0x4964 <RemDecimal+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    4968:	8e e3       	ldi	r24, 0x3E	; 62
    496a:	90 e0       	ldi	r25, 0x00	; 0
    496c:	9f bb       	out	0x1f, r25	; 31
    496e:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    4970:	e0 9a       	sbi	0x1c, 0	; 28
    4972:	5d b3       	in	r21, 0x1d	; 29
    4974:	40 e0       	ldi	r20, 0x00	; 0
    4976:	08 c0       	rjmp	.+16     	; 0x4988 <RemDecimal+0x26>
char i,DecPointMark;
     DecPointMark=eeprom_read_byte(&DefDecimalMark);	 

     for(i=0;i<strlen(strDecimal);i++){
	     if (strDecimal[i]==DecPointMark)
    4978:	f9 01       	movw	r30, r18
    497a:	e8 0f       	add	r30, r24
    497c:	f9 1f       	adc	r31, r25
    497e:	80 81       	ld	r24, Z
    4980:	85 17       	cp	r24, r21
    4982:	09 f4       	brne	.+2      	; 0x4986 <RemDecimal+0x24>
		     strDecimal[i]=0;
    4984:	10 82       	st	Z, r1

void RemDecimal(char *strDecimal){//4500.00-->4500
char i,DecPointMark;
     DecPointMark=eeprom_read_byte(&DefDecimalMark);	 

     for(i=0;i<strlen(strDecimal);i++){
    4986:	4f 5f       	subi	r20, 0xFF	; 255
    4988:	84 2f       	mov	r24, r20
    498a:	90 e0       	ldi	r25, 0x00	; 0
    498c:	f9 01       	movw	r30, r18
    498e:	01 90       	ld	r0, Z+
    4990:	00 20       	and	r0, r0
    4992:	e9 f7       	brne	.-6      	; 0x498e <RemDecimal+0x2c>
    4994:	31 97       	sbiw	r30, 0x01	; 1
    4996:	e2 1b       	sub	r30, r18
    4998:	f3 0b       	sbc	r31, r19
    499a:	8e 17       	cp	r24, r30
    499c:	9f 07       	cpc	r25, r31
    499e:	60 f3       	brcs	.-40     	; 0x4978 <RemDecimal+0x16>
	     if (strDecimal[i]==DecPointMark)
		     strDecimal[i]=0;
	 }
}
    49a0:	08 95       	ret

000049a2 <GetProductPrice>:
          stGenerateReport=grScanAction;
	      break;
	 }
}
//SaveTotalProduct(xGrade,strDeltaVolume,strDeltaMoney);
void GetProductPrice(char *sPrice,char xPumpID,char xNozzle){
    49a2:	cf 92       	push	r12
    49a4:	df 92       	push	r13
    49a6:	ef 92       	push	r14
    49a8:	ff 92       	push	r15
    49aa:	0f 93       	push	r16
    49ac:	1f 93       	push	r17
    49ae:	df 93       	push	r29
    49b0:	cf 93       	push	r28
    49b2:	cd b7       	in	r28, 0x3d	; 61
    49b4:	de b7       	in	r29, 0x3e	; 62
    49b6:	67 97       	sbiw	r28, 0x17	; 23
    49b8:	0f b6       	in	r0, 0x3f	; 63
    49ba:	f8 94       	cli
    49bc:	de bf       	out	0x3e, r29	; 62
    49be:	0f be       	out	0x3f, r0	; 63
    49c0:	cd bf       	out	0x3d, r28	; 61
    49c2:	7c 01       	movw	r14, r24
    49c4:	d6 2e       	mov	r13, r22
    49c6:	c4 2e       	mov	r12, r20
char i,PPumpID[8],PProdID[6],strPrice[9],iPumpID,xProductID;
     sprintf_P(sPrice,PSTR(""));
    49c8:	00 d0       	rcall	.+0      	; 0x49ca <GetProductPrice+0x28>
    49ca:	00 d0       	rcall	.+0      	; 0x49cc <GetProductPrice+0x2a>
    49cc:	ad b7       	in	r26, 0x3d	; 61
    49ce:	be b7       	in	r27, 0x3e	; 62
    49d0:	12 96       	adiw	r26, 0x02	; 2
    49d2:	9c 93       	st	X, r25
    49d4:	8e 93       	st	-X, r24
    49d6:	11 97       	sbiw	r26, 0x01	; 1
    49d8:	83 e0       	ldi	r24, 0x03	; 3
    49da:	94 e0       	ldi	r25, 0x04	; 4
    49dc:	14 96       	adiw	r26, 0x04	; 4
    49de:	9c 93       	st	X, r25
    49e0:	8e 93       	st	-X, r24
    49e2:	13 97       	sbiw	r26, 0x03	; 3
    49e4:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    49e8:	0f 90       	pop	r0
    49ea:	0f 90       	pop	r0
    49ec:	0f 90       	pop	r0
    49ee:	0f 90       	pop	r0
    49f0:	8e 01       	movw	r16, r28
    49f2:	09 5f       	subi	r16, 0xF9	; 249
    49f4:	1f 4f       	sbci	r17, 0xFF	; 255
    49f6:	c8 01       	movw	r24, r16
    49f8:	65 e4       	ldi	r22, 0x45	; 69
    49fa:	70 e0       	ldi	r23, 0x00	; 0
    49fc:	48 e0       	ldi	r20, 0x08	; 8
    49fe:	50 e0       	ldi	r21, 0x00	; 0
    4a00:	26 ef       	ldi	r18, 0xF6	; 246
    4a02:	32 e1       	ldi	r19, 0x12	; 18
    4a04:	0e 94 7a b5 	call	0x16af4	; 0x16af4 <__eerd_block>
    4a08:	f8 01       	movw	r30, r16
     //FindPumpID
	 eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap,8);
	 iPumpID=0;
	 for(i=0;i<8;i++){
    4a0a:	9e 01       	movw	r18, r28
    4a0c:	21 5f       	subi	r18, 0xF1	; 241
    4a0e:	3f 4f       	sbci	r19, 0xFF	; 255
    4a10:	9e 2f       	mov	r25, r30
    4a12:	90 1b       	sub	r25, r16
	     if (PPumpID[i]==xPumpID){
    4a14:	80 81       	ld	r24, Z
    4a16:	8d 15       	cp	r24, r13
    4a18:	11 f4       	brne	.+4      	; 0x4a1e <GetProductPrice+0x7c>
    4a1a:	89 2f       	mov	r24, r25
    4a1c:	05 c0       	rjmp	.+10     	; 0x4a28 <GetProductPrice+0x86>
    4a1e:	31 96       	adiw	r30, 0x01	; 1
char i,PPumpID[8],PProdID[6],strPrice[9],iPumpID,xProductID;
     sprintf_P(sPrice,PSTR(""));
     //FindPumpID
	 eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap,8);
	 iPumpID=0;
	 for(i=0;i<8;i++){
    4a20:	e2 17       	cp	r30, r18
    4a22:	f3 07       	cpc	r31, r19
    4a24:	a9 f7       	brne	.-22     	; 0x4a10 <GetProductPrice+0x6e>
    4a26:	80 e0       	ldi	r24, 0x00	; 0
	     if (PPumpID[i]==xPumpID){
		     iPumpID=i;
			 break;
		 }	 
	 }
	 if ((iPumpID>=0)&&(xNozzle<6)){
    4a28:	b5 e0       	ldi	r27, 0x05	; 5
    4a2a:	bc 15       	cp	r27, r12
    4a2c:	08 f4       	brcc	.+2      	; 0x4a30 <GetProductPrice+0x8e>
    4a2e:	41 c0       	rjmp	.+130    	; 0x4ab2 <GetProductPrice+0x110>
    4a30:	66 e0       	ldi	r22, 0x06	; 6
    4a32:	86 9f       	mul	r24, r22
    4a34:	b0 01       	movw	r22, r0
    4a36:	11 24       	eor	r1, r1
    4a38:	6b 5a       	subi	r22, 0xAB	; 171
    4a3a:	7f 4f       	sbci	r23, 0xFF	; 255
    4a3c:	ce 01       	movw	r24, r28
    4a3e:	01 96       	adiw	r24, 0x01	; 1
    4a40:	46 e0       	ldi	r20, 0x06	; 6
    4a42:	50 e0       	ldi	r21, 0x00	; 0
    4a44:	26 ef       	ldi	r18, 0xF6	; 246
    4a46:	32 e1       	ldi	r19, 0x12	; 18
    4a48:	0e 94 7a b5 	call	0x16af4	; 0x16af4 <__eerd_block>
         eeprom_read_block((void*) &PProdID,(const void*) &DefNozzleMap[iPumpID],6);
         xProductID=PProdID[xNozzle-1];
		 //Price
		 eeprom_read_block((void*) &strPrice, (const void*) &DefProductPrice[xProductID-1], 9);
		 RemDecimal(strPrice);
    4a4c:	8e 01       	movw	r16, r28
    4a4e:	01 5f       	subi	r16, 0xF1	; 241
    4a50:	1f 4f       	sbci	r17, 0xFF	; 255
    4a52:	fe 01       	movw	r30, r28
    4a54:	ec 0d       	add	r30, r12
    4a56:	f1 1d       	adc	r31, r1
    4a58:	60 81       	ld	r22, Z
    4a5a:	89 e0       	ldi	r24, 0x09	; 9
    4a5c:	68 9f       	mul	r22, r24
    4a5e:	b0 01       	movw	r22, r0
    4a60:	11 24       	eor	r1, r1
    4a62:	64 58       	subi	r22, 0x84	; 132
    4a64:	7f 4f       	sbci	r23, 0xFF	; 255
    4a66:	c8 01       	movw	r24, r16
    4a68:	49 e0       	ldi	r20, 0x09	; 9
    4a6a:	50 e0       	ldi	r21, 0x00	; 0
    4a6c:	26 ef       	ldi	r18, 0xF6	; 246
    4a6e:	32 e1       	ldi	r19, 0x12	; 18
    4a70:	0e 94 7a b5 	call	0x16af4	; 0x16af4 <__eerd_block>
    4a74:	c8 01       	movw	r24, r16
    4a76:	0e 94 b1 24 	call	0x4962	; 0x4962 <RemDecimal>
		 sprintf_P(sPrice,PSTR("%s"),strPrice);
    4a7a:	00 d0       	rcall	.+0      	; 0x4a7c <GetProductPrice+0xda>
    4a7c:	00 d0       	rcall	.+0      	; 0x4a7e <GetProductPrice+0xdc>
    4a7e:	00 d0       	rcall	.+0      	; 0x4a80 <GetProductPrice+0xde>
    4a80:	ed b7       	in	r30, 0x3d	; 61
    4a82:	fe b7       	in	r31, 0x3e	; 62
    4a84:	31 96       	adiw	r30, 0x01	; 1
    4a86:	ad b7       	in	r26, 0x3d	; 61
    4a88:	be b7       	in	r27, 0x3e	; 62
    4a8a:	12 96       	adiw	r26, 0x02	; 2
    4a8c:	fc 92       	st	X, r15
    4a8e:	ee 92       	st	-X, r14
    4a90:	11 97       	sbiw	r26, 0x01	; 1
    4a92:	80 e0       	ldi	r24, 0x00	; 0
    4a94:	94 e0       	ldi	r25, 0x04	; 4
    4a96:	93 83       	std	Z+3, r25	; 0x03
    4a98:	82 83       	std	Z+2, r24	; 0x02
    4a9a:	15 83       	std	Z+5, r17	; 0x05
    4a9c:	04 83       	std	Z+4, r16	; 0x04
    4a9e:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    4aa2:	ed b7       	in	r30, 0x3d	; 61
    4aa4:	fe b7       	in	r31, 0x3e	; 62
    4aa6:	36 96       	adiw	r30, 0x06	; 6
    4aa8:	0f b6       	in	r0, 0x3f	; 63
    4aaa:	f8 94       	cli
    4aac:	fe bf       	out	0x3e, r31	; 62
    4aae:	0f be       	out	0x3f, r0	; 63
    4ab0:	ed bf       	out	0x3d, r30	; 61
	 }    
	 //Clear Decimal

}
    4ab2:	67 96       	adiw	r28, 0x17	; 23
    4ab4:	0f b6       	in	r0, 0x3f	; 63
    4ab6:	f8 94       	cli
    4ab8:	de bf       	out	0x3e, r29	; 62
    4aba:	0f be       	out	0x3f, r0	; 63
    4abc:	cd bf       	out	0x3d, r28	; 61
    4abe:	cf 91       	pop	r28
    4ac0:	df 91       	pop	r29
    4ac2:	1f 91       	pop	r17
    4ac4:	0f 91       	pop	r16
    4ac6:	ff 90       	pop	r15
    4ac8:	ef 90       	pop	r14
    4aca:	df 90       	pop	r13
    4acc:	cf 90       	pop	r12
    4ace:	08 95       	ret

00004ad0 <FormatDate>:
	 }     
   }
}

              //Fmt:DATE_LONG_YEAR,DATE_SHORT_YEAR //0123456789    0123456789 
void FormatDate(char FmtYear, char *Date){         //2010/06/16 -> 16/06/2010
    4ad0:	df 93       	push	r29
    4ad2:	cf 93       	push	r28
    4ad4:	cd b7       	in	r28, 0x3d	; 61
    4ad6:	de b7       	in	r29, 0x3e	; 62
    4ad8:	2b 97       	sbiw	r28, 0x0b	; 11
    4ada:	0f b6       	in	r0, 0x3f	; 63
    4adc:	f8 94       	cli
    4ade:	de bf       	out	0x3e, r29	; 62
    4ae0:	0f be       	out	0x3f, r0	; 63
    4ae2:	cd bf       	out	0x3d, r28	; 61
    4ae4:	98 2f       	mov	r25, r24
    4ae6:	9b 01       	movw	r18, r22
     char i,sDate[11];

     sDate[0]=Date[8];
    4ae8:	fb 01       	movw	r30, r22
    4aea:	80 85       	ldd	r24, Z+8	; 0x08
    4aec:	89 83       	std	Y+1, r24	; 0x01
	 sDate[1]=Date[9];
    4aee:	81 85       	ldd	r24, Z+9	; 0x09
    4af0:	8a 83       	std	Y+2, r24	; 0x02
     sDate[2]=Date[7];
    4af2:	87 81       	ldd	r24, Z+7	; 0x07
    4af4:	8b 83       	std	Y+3, r24	; 0x03
	 sDate[3]=Date[5];
    4af6:	85 81       	ldd	r24, Z+5	; 0x05
    4af8:	8c 83       	std	Y+4, r24	; 0x04
     sDate[4]=Date[6];
    4afa:	86 81       	ldd	r24, Z+6	; 0x06
    4afc:	8d 83       	std	Y+5, r24	; 0x05
	 sDate[5]=Date[4];
    4afe:	84 81       	ldd	r24, Z+4	; 0x04
    4b00:	8e 83       	std	Y+6, r24	; 0x06
	 switch(FmtYear){
    4b02:	99 23       	and	r25, r25
    4b04:	19 f0       	breq	.+6      	; 0x4b0c <FormatDate+0x3c>
    4b06:	91 30       	cpi	r25, 0x01	; 1
    4b08:	59 f4       	brne	.+22     	; 0x4b20 <FormatDate+0x50>
    4b0a:	0f c0       	rjmp	.+30     	; 0x4b2a <FormatDate+0x5a>
	 case DATE_LONG_YEAR:
	 	  for(i=0;i<4;i++)sDate[i+6]=Date[i];
    4b0c:	fb 01       	movw	r30, r22
    4b0e:	80 81       	ld	r24, Z
    4b10:	8f 83       	std	Y+7, r24	; 0x07
    4b12:	81 81       	ldd	r24, Z+1	; 0x01
    4b14:	88 87       	std	Y+8, r24	; 0x08
    4b16:	82 81       	ldd	r24, Z+2	; 0x02
    4b18:	89 87       	std	Y+9, r24	; 0x09
    4b1a:	83 81       	ldd	r24, Z+3	; 0x03
    4b1c:	8a 87       	std	Y+10, r24	; 0x0a
          sDate[10]=0;
    4b1e:	1b 86       	std	Y+11, r1	; 0x0b
    4b20:	90 e0       	ldi	r25, 0x00	; 0
	      for(i=0;i<2;i++)sDate[i+6]=Date[i+2];
          sDate[8]=0;
	      break;
	 }
	 //replace
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
    4b22:	ae 01       	movw	r20, r28
    4b24:	4f 5f       	subi	r20, 0xFF	; 255
    4b26:	5f 4f       	sbci	r21, 0xFF	; 255
    4b28:	0f c0       	rjmp	.+30     	; 0x4b48 <FormatDate+0x78>
	 case DATE_LONG_YEAR:
	 	  for(i=0;i<4;i++)sDate[i+6]=Date[i];
          sDate[10]=0;
	      break;
	 case DATE_SHORT_YEAR:
	      for(i=0;i<2;i++)sDate[i+6]=Date[i+2];
    4b2a:	fb 01       	movw	r30, r22
    4b2c:	82 81       	ldd	r24, Z+2	; 0x02
    4b2e:	8f 83       	std	Y+7, r24	; 0x07
    4b30:	83 81       	ldd	r24, Z+3	; 0x03
    4b32:	88 87       	std	Y+8, r24	; 0x08
          sDate[8]=0;
    4b34:	19 86       	std	Y+9, r1	; 0x09
    4b36:	f4 cf       	rjmp	.-24     	; 0x4b20 <FormatDate+0x50>
	      break;
	 }
	 //replace
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
    4b38:	f9 01       	movw	r30, r18
    4b3a:	ea 0f       	add	r30, r26
    4b3c:	fb 1f       	adc	r31, r27
    4b3e:	a4 0f       	add	r26, r20
    4b40:	b5 1f       	adc	r27, r21
    4b42:	8c 91       	ld	r24, X
    4b44:	80 83       	st	Z, r24
    4b46:	9f 5f       	subi	r25, 0xFF	; 255
    4b48:	a9 2f       	mov	r26, r25
    4b4a:	b0 e0       	ldi	r27, 0x00	; 0
    4b4c:	fa 01       	movw	r30, r20
    4b4e:	01 90       	ld	r0, Z+
    4b50:	00 20       	and	r0, r0
    4b52:	e9 f7       	brne	.-6      	; 0x4b4e <FormatDate+0x7e>
    4b54:	31 97       	sbiw	r30, 0x01	; 1
    4b56:	e4 1b       	sub	r30, r20
    4b58:	f5 0b       	sbc	r31, r21
    4b5a:	ae 17       	cp	r26, r30
    4b5c:	bf 07       	cpc	r27, r31
    4b5e:	60 f3       	brcs	.-40     	; 0x4b38 <FormatDate+0x68>
}
    4b60:	2b 96       	adiw	r28, 0x0b	; 11
    4b62:	0f b6       	in	r0, 0x3f	; 63
    4b64:	f8 94       	cli
    4b66:	de bf       	out	0x3e, r29	; 62
    4b68:	0f be       	out	0x3f, r0	; 63
    4b6a:	cd bf       	out	0x3d, r28	; 61
    4b6c:	cf 91       	pop	r28
    4b6e:	df 91       	pop	r29
    4b70:	08 95       	ret

00004b72 <RemZeroLead>:

	while (1){};
  #endif
}

void RemZeroLead(char *Zeroed){//Remove Zero Character 00001004 000050000 0 
    4b72:	cf 93       	push	r28
    4b74:	df 93       	push	r29
    4b76:	ec 01       	movw	r28, r24
unsigned char i=0,Length=0,ZeroPos=0,IsFound=False;;
     IsFound=False;
     ZeroPos=0;Length=strlen(Zeroed);
    4b78:	fc 01       	movw	r30, r24
    4b7a:	01 90       	ld	r0, Z+
    4b7c:	00 20       	and	r0, r0
    4b7e:	e9 f7       	brne	.-6      	; 0x4b7a <RemZeroLead+0x8>
    4b80:	31 97       	sbiw	r30, 0x01	; 1
    4b82:	e8 1b       	sub	r30, r24
  if ((Length>1)&&(Zeroed[0]=='0')){
    4b84:	e2 30       	cpi	r30, 0x02	; 2
    4b86:	d0 f1       	brcs	.+116    	; 0x4bfc <RemZeroLead+0x8a>
    4b88:	88 81       	ld	r24, Y
    4b8a:	80 33       	cpi	r24, 0x30	; 48
    4b8c:	b9 f5       	brne	.+110    	; 0x4bfc <RemZeroLead+0x8a>
    4b8e:	4c 2f       	mov	r20, r28
    4b90:	de 01       	movw	r26, r28
    4b92:	90 e0       	ldi	r25, 0x00	; 0
	 if (Zeroed[0]=='0'){
         for(i=0;i<Length;i++){//00000000->0
	         if ((Zeroed[i]=='0')&&(Zeroed[i+1]=='0')&&(IsFound==False)) ZeroPos++;
    4b94:	8c 91       	ld	r24, X
    4b96:	80 33       	cpi	r24, 0x30	; 48
    4b98:	69 f4       	brne	.+26     	; 0x4bb4 <RemZeroLead+0x42>
    4b9a:	11 96       	adiw	r26, 0x01	; 1
    4b9c:	8c 91       	ld	r24, X
    4b9e:	11 97       	sbiw	r26, 0x01	; 1
    4ba0:	80 33       	cpi	r24, 0x30	; 48
    4ba2:	11 f4       	brne	.+4      	; 0x4ba8 <RemZeroLead+0x36>
    4ba4:	9f 5f       	subi	r25, 0xFF	; 255
    4ba6:	06 c0       	rjmp	.+12     	; 0x4bb4 <RemZeroLead+0x42>
             if ((Zeroed[i]=='0')&&(Zeroed[i+1]!='0')){
			     if ((Zeroed[i+1]=='.')||(Zeroed[i+1]==','))ZeroPos--;
    4ba8:	8e 32       	cpi	r24, 0x2E	; 46
    4baa:	11 f0       	breq	.+4      	; 0x4bb0 <RemZeroLead+0x3e>
    4bac:	8c 32       	cpi	r24, 0x2C	; 44
    4bae:	41 f4       	brne	.+16     	; 0x4bc0 <RemZeroLead+0x4e>
    4bb0:	91 50       	subi	r25, 0x01	; 1
    4bb2:	06 c0       	rjmp	.+12     	; 0x4bc0 <RemZeroLead+0x4e>
    4bb4:	11 96       	adiw	r26, 0x01	; 1
unsigned char i=0,Length=0,ZeroPos=0,IsFound=False;;
     IsFound=False;
     ZeroPos=0;Length=strlen(Zeroed);
  if ((Length>1)&&(Zeroed[0]=='0')){
	 if (Zeroed[0]=='0'){
         for(i=0;i<Length;i++){//00000000->0
    4bb6:	8a 2f       	mov	r24, r26
    4bb8:	84 1b       	sub	r24, r20
    4bba:	8e 17       	cp	r24, r30
    4bbc:	58 f3       	brcs	.-42     	; 0x4b94 <RemZeroLead+0x22>
    4bbe:	01 c0       	rjmp	.+2      	; 0x4bc2 <RemZeroLead+0x50>
		         IsFound=True;
			     break;			  
			     }
	      }

		  if (IsFound==True)ZeroPos++;
    4bc0:	9f 5f       	subi	r25, 0xFF	; 255
		  if (ZeroPos>=Length)ZeroPos=Length-1;
    4bc2:	9e 17       	cp	r25, r30
    4bc4:	10 f0       	brcs	.+4      	; 0x4bca <RemZeroLead+0x58>
    4bc6:	9e 2f       	mov	r25, r30
    4bc8:	91 50       	subi	r25, 0x01	; 1
    4bca:	40 e0       	ldi	r20, 0x00	; 0
          for(i=0;i<(Length-ZeroPos);i++){
    4bcc:	89 2f       	mov	r24, r25
    4bce:	90 e0       	ldi	r25, 0x00	; 0
    4bd0:	2e 2f       	mov	r18, r30
    4bd2:	30 e0       	ldi	r19, 0x00	; 0
    4bd4:	28 1b       	sub	r18, r24
    4bd6:	39 0b       	sbc	r19, r25
	          Zeroed[i]=Zeroed[i+ZeroPos];
    4bd8:	be 01       	movw	r22, r28
    4bda:	68 0f       	add	r22, r24
    4bdc:	79 1f       	adc	r23, r25
    4bde:	09 c0       	rjmp	.+18     	; 0x4bf2 <RemZeroLead+0x80>
    4be0:	fe 01       	movw	r30, r28
    4be2:	ea 0f       	add	r30, r26
    4be4:	fb 1f       	adc	r31, r27
    4be6:	a6 0f       	add	r26, r22
    4be8:	b7 1f       	adc	r27, r23
    4bea:	8c 91       	ld	r24, X
    4bec:	80 83       	st	Z, r24
		      Zeroed[i+1]=0;
    4bee:	11 82       	std	Z+1, r1	; 0x01
			     }
	      }

		  if (IsFound==True)ZeroPos++;
		  if (ZeroPos>=Length)ZeroPos=Length-1;
          for(i=0;i<(Length-ZeroPos);i++){
    4bf0:	4f 5f       	subi	r20, 0xFF	; 255
    4bf2:	a4 2f       	mov	r26, r20
    4bf4:	b0 e0       	ldi	r27, 0x00	; 0
    4bf6:	a2 17       	cp	r26, r18
    4bf8:	b3 07       	cpc	r27, r19
    4bfa:	94 f3       	brlt	.-28     	; 0x4be0 <RemZeroLead+0x6e>
	          Zeroed[i]=Zeroed[i+ZeroPos];
		      Zeroed[i+1]=0;
	   }//Zeroed[Length-ZeroPos]=0;
	 }     
   }
}
    4bfc:	df 91       	pop	r29
    4bfe:	cf 91       	pop	r28
    4c00:	08 95       	ret

00004c02 <RemSpaceLead>:
	 if (Spaced[PosSpaced]==' ')Spaced[PosSpaced]=0;
	 if (Spaced[0]==' ')Spaced[0]=0;
	 Spaced[strlen(Spaced)]=0;
}

void RemSpaceLead(char *Zeroed){//Remove Space Character SSSSSS1234 12340234
    4c02:	cf 93       	push	r28
    4c04:	df 93       	push	r29
    4c06:	ec 01       	movw	r28, r24
unsigned char i=0,Length=0,ZeroPos=0,IsFound=False;;
     ZeroPos=0;Length=strlen(Zeroed);
    4c08:	fc 01       	movw	r30, r24
    4c0a:	01 90       	ld	r0, Z+
    4c0c:	00 20       	and	r0, r0
    4c0e:	e9 f7       	brne	.-6      	; 0x4c0a <RemSpaceLead+0x8>
    4c10:	31 97       	sbiw	r30, 0x01	; 1
    4c12:	6e 2f       	mov	r22, r30
    4c14:	68 1b       	sub	r22, r24
	 if ((Length>1)&&(Zeroed[0]==' ')){
    4c16:	62 30       	cpi	r22, 0x02	; 2
    4c18:	e0 f1       	brcs	.+120    	; 0x4c92 <RemSpaceLead+0x90>
    4c1a:	88 81       	ld	r24, Y
    4c1c:	80 32       	cpi	r24, 0x20	; 32
    4c1e:	c9 f5       	brne	.+114    	; 0x4c92 <RemSpaceLead+0x90>
    4c20:	4c 2f       	mov	r20, r28
    4c22:	fe 01       	movw	r30, r28
    4c24:	20 e0       	ldi	r18, 0x00	; 0
    4c26:	90 e0       	ldi	r25, 0x00	; 0
	     for(i=0;i<Length;i++){
		     if ((Zeroed[i]==' ')&&(Zeroed[i+1]==' ')&&(IsFound==False)) ZeroPos++;
    4c28:	80 81       	ld	r24, Z
    4c2a:	80 32       	cpi	r24, 0x20	; 32
    4c2c:	41 f4       	brne	.+16     	; 0x4c3e <RemSpaceLead+0x3c>
    4c2e:	81 81       	ldd	r24, Z+1	; 0x01
    4c30:	80 32       	cpi	r24, 0x20	; 32
    4c32:	21 f4       	brne	.+8      	; 0x4c3c <RemSpaceLead+0x3a>
    4c34:	22 23       	and	r18, r18
    4c36:	19 f4       	brne	.+6      	; 0x4c3e <RemSpaceLead+0x3c>
    4c38:	9f 5f       	subi	r25, 0xFF	; 255
    4c3a:	01 c0       	rjmp	.+2      	; 0x4c3e <RemSpaceLead+0x3c>
    4c3c:	21 e0       	ldi	r18, 0x01	; 1
    4c3e:	31 96       	adiw	r30, 0x01	; 1

void RemSpaceLead(char *Zeroed){//Remove Space Character SSSSSS1234 12340234
unsigned char i=0,Length=0,ZeroPos=0,IsFound=False;;
     ZeroPos=0;Length=strlen(Zeroed);
	 if ((Length>1)&&(Zeroed[0]==' ')){
	     for(i=0;i<Length;i++){
    4c40:	8e 2f       	mov	r24, r30
    4c42:	84 1b       	sub	r24, r20
    4c44:	86 17       	cp	r24, r22
    4c46:	80 f3       	brcs	.-32     	; 0x4c28 <RemSpaceLead+0x26>
		     if ((Zeroed[i]==' ')&&(Zeroed[i+1]==' ')&&(IsFound==False)) ZeroPos++;
	         if((Zeroed[i]==' ')&&(Zeroed[i+1]!=' '))IsFound=True;
		 }ZeroPos++;
    4c48:	39 2f       	mov	r19, r25
    4c4a:	3f 5f       	subi	r19, 0xFF	; 255
    4c4c:	20 e0       	ldi	r18, 0x00	; 0
	     for(i=0;i<strlen(Zeroed);i++){
		     Zeroed[i]=Zeroed[i+ZeroPos];
    4c4e:	43 2f       	mov	r20, r19
    4c50:	50 e0       	ldi	r21, 0x00	; 0
    4c52:	09 c0       	rjmp	.+18     	; 0x4c66 <RemSpaceLead+0x64>
    4c54:	fe 01       	movw	r30, r28
    4c56:	e8 0f       	add	r30, r24
    4c58:	f9 1f       	adc	r31, r25
    4c5a:	df 01       	movw	r26, r30
    4c5c:	a4 0f       	add	r26, r20
    4c5e:	b5 1f       	adc	r27, r21
    4c60:	8c 91       	ld	r24, X
    4c62:	80 83       	st	Z, r24
	 if ((Length>1)&&(Zeroed[0]==' ')){
	     for(i=0;i<Length;i++){
		     if ((Zeroed[i]==' ')&&(Zeroed[i+1]==' ')&&(IsFound==False)) ZeroPos++;
	         if((Zeroed[i]==' ')&&(Zeroed[i+1]!=' '))IsFound=True;
		 }ZeroPos++;
	     for(i=0;i<strlen(Zeroed);i++){
    4c64:	2f 5f       	subi	r18, 0xFF	; 255
    4c66:	82 2f       	mov	r24, r18
    4c68:	90 e0       	ldi	r25, 0x00	; 0
    4c6a:	fe 01       	movw	r30, r28
    4c6c:	01 90       	ld	r0, Z+
    4c6e:	00 20       	and	r0, r0
    4c70:	e9 f7       	brne	.-6      	; 0x4c6c <RemSpaceLead+0x6a>
    4c72:	31 97       	sbiw	r30, 0x01	; 1
    4c74:	ec 1b       	sub	r30, r28
    4c76:	fd 0b       	sbc	r31, r29
    4c78:	8e 17       	cp	r24, r30
    4c7a:	9f 07       	cpc	r25, r31
    4c7c:	58 f3       	brcs	.-42     	; 0x4c54 <RemSpaceLead+0x52>
		     Zeroed[i]=Zeroed[i+ZeroPos];
		 }
		 //Clearence
		 for(i=(Length-ZeroPos);i<Length;i++){
    4c7e:	86 2f       	mov	r24, r22
    4c80:	83 1b       	sub	r24, r19
    4c82:	05 c0       	rjmp	.+10     	; 0x4c8e <RemSpaceLead+0x8c>
		     Zeroed[i]=0;
    4c84:	fe 01       	movw	r30, r28
    4c86:	e8 0f       	add	r30, r24
    4c88:	f1 1d       	adc	r31, r1
    4c8a:	10 82       	st	Z, r1
		 }ZeroPos++;
	     for(i=0;i<strlen(Zeroed);i++){
		     Zeroed[i]=Zeroed[i+ZeroPos];
		 }
		 //Clearence
		 for(i=(Length-ZeroPos);i<Length;i++){
    4c8c:	8f 5f       	subi	r24, 0xFF	; 255
    4c8e:	86 17       	cp	r24, r22
    4c90:	c8 f3       	brcs	.-14     	; 0x4c84 <RemSpaceLead+0x82>
		     Zeroed[i]=0;
		 }
     }
}
    4c92:	df 91       	pop	r29
    4c94:	cf 91       	pop	r28
    4c96:	08 95       	ret

00004c98 <RemSpaceLag>:
	 if (Spaced[0]==' ')Spaced[0]=0;
	 Spaced[strlen(Spaced)]=0;
}
*/
                                                      //012345678
void RemSpaceLag(char *Spaced){//Remove Space Character 1234SSSSS L=9 i=0 i=7
    4c98:	0f 93       	push	r16
    4c9a:	1f 93       	push	r17
    4c9c:	cf 93       	push	r28
    4c9e:	df 93       	push	r29
    4ca0:	ec 01       	movw	r28, r24
unsigned char i=0,Length=0,PosSpaced=0;
     Length=strlen(Spaced);
    4ca2:	dc 01       	movw	r26, r24
    4ca4:	0d 90       	ld	r0, X+
    4ca6:	00 20       	and	r0, r0
    4ca8:	e9 f7       	brne	.-6      	; 0x4ca4 <RemSpaceLag+0xc>
    4caa:	11 97       	sbiw	r26, 0x01	; 1
    4cac:	a8 1b       	sub	r26, r24
    4cae:	b0 e0       	ldi	r27, 0x00	; 0
    4cb0:	20 e0       	ldi	r18, 0x00	; 0
    4cb2:	30 e0       	ldi	r19, 0x00	; 0
     for(i=0;i<(Length-1);i++){
    4cb4:	6a 2f       	mov	r22, r26
    4cb6:	70 e0       	ldi	r23, 0x00	; 0
    4cb8:	8b 01       	movw	r16, r22
    4cba:	01 50       	subi	r16, 0x01	; 1
    4cbc:	10 40       	sbci	r17, 0x00	; 0
	     if ((Spaced[Length-i-2]==' ')&&(Spaced[Length-i-1]==' ')){
		      Spaced[Length-i-1]=0;
    4cbe:	a1 50       	subi	r26, 0x01	; 1
    4cc0:	16 c0       	rjmp	.+44     	; 0x4cee <RemSpaceLag+0x56>
                                                      //012345678
void RemSpaceLag(char *Spaced){//Remove Space Character 1234SSSSS L=9 i=0 i=7
unsigned char i=0,Length=0,PosSpaced=0;
     Length=strlen(Spaced);
     for(i=0;i<(Length-1);i++){
	     if ((Spaced[Length-i-2]==' ')&&(Spaced[Length-i-1]==' ')){
    4cc2:	ab 01       	movw	r20, r22
    4cc4:	48 1b       	sub	r20, r24
    4cc6:	59 0b       	sbc	r21, r25
    4cc8:	fe 01       	movw	r30, r28
    4cca:	e4 0f       	add	r30, r20
    4ccc:	f5 1f       	adc	r31, r21
    4cce:	32 97       	sbiw	r30, 0x02	; 2
    4cd0:	80 81       	ld	r24, Z
    4cd2:	80 32       	cpi	r24, 0x20	; 32
    4cd4:	89 f4       	brne	.+34     	; 0x4cf8 <RemSpaceLag+0x60>
    4cd6:	fa 01       	movw	r30, r20
    4cd8:	31 97       	sbiw	r30, 0x01	; 1
    4cda:	ec 0f       	add	r30, r28
    4cdc:	fd 1f       	adc	r31, r29
    4cde:	2f 5f       	subi	r18, 0xFF	; 255
    4ce0:	3f 4f       	sbci	r19, 0xFF	; 255
    4ce2:	80 81       	ld	r24, Z
    4ce4:	80 32       	cpi	r24, 0x20	; 32
    4ce6:	41 f4       	brne	.+16     	; 0x4cf8 <RemSpaceLag+0x60>
		      Spaced[Length-i-1]=0;
    4ce8:	10 82       	st	Z, r1
    4cea:	ba 2f       	mov	r27, r26
    4cec:	b2 1b       	sub	r27, r18
*/
                                                      //012345678
void RemSpaceLag(char *Spaced){//Remove Space Character 1234SSSSS L=9 i=0 i=7
unsigned char i=0,Length=0,PosSpaced=0;
     Length=strlen(Spaced);
     for(i=0;i<(Length-1);i++){
    4cee:	82 2f       	mov	r24, r18
    4cf0:	90 e0       	ldi	r25, 0x00	; 0
    4cf2:	80 17       	cp	r24, r16
    4cf4:	91 07       	cpc	r25, r17
    4cf6:	2c f3       	brlt	.-54     	; 0x4cc2 <RemSpaceLag+0x2a>
		      Spaced[Length-i-1]=0;
			  PosSpaced=Length-i-2;
			  }
         else break;
	 }
	 if (Spaced[PosSpaced]==' ')Spaced[PosSpaced]=0;
    4cf8:	fe 01       	movw	r30, r28
    4cfa:	eb 0f       	add	r30, r27
    4cfc:	f1 1d       	adc	r31, r1
    4cfe:	80 81       	ld	r24, Z
    4d00:	80 32       	cpi	r24, 0x20	; 32
    4d02:	09 f4       	brne	.+2      	; 0x4d06 <RemSpaceLag+0x6e>
    4d04:	10 82       	st	Z, r1
	 if (Spaced[0]==' ')Spaced[0]=0;
    4d06:	88 81       	ld	r24, Y
    4d08:	80 32       	cpi	r24, 0x20	; 32
    4d0a:	09 f4       	brne	.+2      	; 0x4d0e <RemSpaceLag+0x76>
    4d0c:	18 82       	st	Y, r1
	 Spaced[strlen(Spaced)]=0;
    4d0e:	fe 01       	movw	r30, r28
    4d10:	01 90       	ld	r0, Z+
    4d12:	00 20       	and	r0, r0
    4d14:	e9 f7       	brne	.-6      	; 0x4d10 <RemSpaceLag+0x78>
    4d16:	31 97       	sbiw	r30, 0x01	; 1
    4d18:	ec 1b       	sub	r30, r28
    4d1a:	fd 0b       	sbc	r31, r29
    4d1c:	ec 0f       	add	r30, r28
    4d1e:	fd 1f       	adc	r31, r29
    4d20:	10 82       	st	Z, r1
}
    4d22:	df 91       	pop	r29
    4d24:	cf 91       	pop	r28
    4d26:	1f 91       	pop	r17
    4d28:	0f 91       	pop	r16
    4d2a:	08 95       	ret

00004d2c <procMessage57>:
     StrPosCopy(rcv_trans,strAmount,135,7);
     StrPosCopy(rcv_trans,strGainPoints,142,4);
     return Result;
}

char procMessage57(){
    4d2c:	1f 93       	push	r17
	    Dest[IdxSource+i]=Source[i];
	 }Dest[IdxSource+Length]=0;
}
char CharPosCopy(char *Source, unsigned int IdxSource){
     char Result;
     Result=Source[IdxSource];
    4d2e:	10 91 2e 0b 	lds	r17, 0x0B2E
    4d32:	20 e0       	ldi	r18, 0x00	; 0
    4d34:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    4d36:	f9 01       	movw	r30, r18
    4d38:	eb 50       	subi	r30, 0x0B	; 11
    4d3a:	f5 4f       	sbci	r31, 0xF5	; 245
    4d3c:	d9 01       	movw	r26, r18
    4d3e:	af 59       	subi	r26, 0x9F	; 159
    4d40:	b2 4f       	sbci	r27, 0xF2	; 242
    4d42:	95 96       	adiw	r26, 0x25	; 37
    4d44:	8c 91       	ld	r24, X
    4d46:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    4d48:	2f 5f       	subi	r18, 0xFF	; 255
    4d4a:	3f 4f       	sbci	r19, 0xFF	; 255
    4d4c:	24 31       	cpi	r18, 0x14	; 20
    4d4e:	31 05       	cpc	r19, r1
    4d50:	91 f7       	brne	.-28     	; 0x4d36 <procMessage57+0xa>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    4d52:	10 92 09 0b 	sts	0x0B09, r1
	 
	     //Card Status
		 Result=(CharPosCopy(rcv_trans,57)-'0')+1;
		 //CardID
		 StrPosCopy(strCardID,rcv_trans,37,20);
		 RemSpaceLead(strCardID);
    4d56:	81 e6       	ldi	r24, 0x61	; 97
    4d58:	9d e0       	ldi	r25, 0x0D	; 13
    4d5a:	0e 94 01 26 	call	0x4c02	; 0x4c02 <RemSpaceLead>
    4d5e:	20 e0       	ldi	r18, 0x00	; 0
    4d60:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    4d62:	f9 01       	movw	r30, r18
    4d64:	ec 5f       	subi	r30, 0xFC	; 252
    4d66:	fa 4f       	sbci	r31, 0xFA	; 250
    4d68:	d9 01       	movw	r26, r18
    4d6a:	ab 50       	subi	r26, 0x0B	; 11
    4d6c:	b5 4f       	sbci	r27, 0xF5	; 245
    4d6e:	dc 96       	adiw	r26, 0x3c	; 60
    4d70:	8c 91       	ld	r24, X
    4d72:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    4d74:	2f 5f       	subi	r18, 0xFF	; 255
    4d76:	3f 4f       	sbci	r19, 0xFF	; 255
    4d78:	28 32       	cpi	r18, 0x28	; 40
    4d7a:	31 05       	cpc	r19, r1
    4d7c:	91 f7       	brne	.-28     	; 0x4d62 <procMessage57+0x36>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    4d7e:	10 92 2c 05 	sts	0x052C, r1
		 //CardID
		 StrPosCopy(strCardID,rcv_trans,37,20);
		 RemSpaceLead(strCardID);
	     //Card Holder
		 StrPosCopy(rcv_trans,strCardHolder,60,40);
		 RemSpaceLag(strCardHolder);
    4d82:	84 e0       	ldi	r24, 0x04	; 4
    4d84:	95 e0       	ldi	r25, 0x05	; 5
    4d86:	0e 94 4c 26 	call	0x4c98	; 0x4c98 <RemSpaceLag>
    4d8a:	20 e0       	ldi	r18, 0x00	; 0
    4d8c:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    4d8e:	f9 01       	movw	r30, r18
    4d90:	e5 5c       	subi	r30, 0xC5	; 197
    4d92:	fa 4f       	sbci	r31, 0xFA	; 250
    4d94:	d9 01       	movw	r26, r18
    4d96:	a3 57       	subi	r26, 0x73	; 115
    4d98:	b4 4f       	sbci	r27, 0xF4	; 244
    4d9a:	8c 91       	ld	r24, X
    4d9c:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    4d9e:	2f 5f       	subi	r18, 0xFF	; 255
    4da0:	3f 4f       	sbci	r19, 0xFF	; 255
    4da2:	29 31       	cpi	r18, 0x19	; 25
    4da4:	31 05       	cpc	r19, r1
    4da6:	99 f7       	brne	.-26     	; 0x4d8e <procMessage57+0x62>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    4da8:	10 92 54 05 	sts	0x0554, r1
	     //Card Holder
		 StrPosCopy(rcv_trans,strCardHolder,60,40);
		 RemSpaceLag(strCardHolder);
		 //BalanceTypePrint
		 StrPosCopy(rcv_trans,strBalanceTypePrint,154-2,25);
		 RemSpaceLag(strBalanceTypePrint);
    4dac:	8b e3       	ldi	r24, 0x3B	; 59
    4dae:	95 e0       	ldi	r25, 0x05	; 5
    4db0:	0e 94 4c 26 	call	0x4c98	; 0x4c98 <RemSpaceLag>
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    4db4:	80 91 a6 0b 	lds	r24, 0x0BA6
    4db8:	80 93 c5 04 	sts	0x04C5, r24
	 }Dest[Length]=0;
    4dbc:	10 92 c6 04 	sts	0x04C6, r1
    4dc0:	20 e0       	ldi	r18, 0x00	; 0
    4dc2:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    4dc4:	f9 01       	movw	r30, r18
    4dc6:	ed 52       	subi	r30, 0x2D	; 45
    4dc8:	f2 4f       	sbci	r31, 0xF2	; 242
    4dca:	d9 01       	movw	r26, r18
    4dcc:	a9 55       	subi	r26, 0x59	; 89
    4dce:	b4 4f       	sbci	r27, 0xF4	; 244
    4dd0:	8c 91       	ld	r24, X
    4dd2:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    4dd4:	2f 5f       	subi	r18, 0xFF	; 255
    4dd6:	3f 4f       	sbci	r19, 0xFF	; 255
    4dd8:	2d 30       	cpi	r18, 0x0D	; 13
    4dda:	31 05       	cpc	r19, r1
    4ddc:	99 f7       	brne	.-26     	; 0x4dc4 <procMessage57+0x98>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    4dde:	10 92 e0 0d 	sts	0x0DE0, r1
		 RemSpaceLag(strBalanceTypePrint);
         //BalanceTypeCode
		 StrPosCopy(rcv_trans,strBalanceCode,177,1);
		 //Balance
		 StrPosCopy(rcv_trans,strBalance,178,13);
		 RemSpaceLead(strBalance);
    4de2:	83 ed       	ldi	r24, 0xD3	; 211
    4de4:	9d e0       	ldi	r25, 0x0D	; 13
    4de6:	0e 94 01 26 	call	0x4c02	; 0x4c02 <RemSpaceLead>
    4dea:	20 e0       	ldi	r18, 0x00	; 0
    4dec:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    4dee:	f9 01       	movw	r30, r18
    4df0:	ee 52       	subi	r30, 0x2E	; 46
    4df2:	f5 4f       	sbci	r31, 0xF5	; 245
    4df4:	d9 01       	movw	r26, r18
    4df6:	ac 54       	subi	r26, 0x4C	; 76
    4df8:	b4 4f       	sbci	r27, 0xF4	; 244
    4dfa:	8c 91       	ld	r24, X
    4dfc:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    4dfe:	2f 5f       	subi	r18, 0xFF	; 255
    4e00:	3f 4f       	sbci	r19, 0xFF	; 255
    4e02:	2a 30       	cpi	r18, 0x0A	; 10
    4e04:	31 05       	cpc	r19, r1
    4e06:	99 f7       	brne	.-26     	; 0x4dee <procMessage57+0xc2>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    4e08:	10 92 dc 0a 	sts	0x0ADC, r1
		 //Balance
		 StrPosCopy(rcv_trans,strBalance,178,13);
		 RemSpaceLead(strBalance);
		 //LicPlate
		 StrPosCopy(rcv_trans,strLicPlate,193-2,10);
		 RemSpaceLag(strLicPlate);
    4e0c:	82 ed       	ldi	r24, 0xD2	; 210
    4e0e:	9a e0       	ldi	r25, 0x0A	; 10
    4e10:	0e 94 4c 26 	call	0x4c98	; 0x4c98 <RemSpaceLag>
    4e14:	20 e0       	ldi	r18, 0x00	; 0
    4e16:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    4e18:	f9 01       	movw	r30, r18
    4e1a:	e4 5a       	subi	r30, 0xA4	; 164
    4e1c:	f6 4f       	sbci	r31, 0xF6	; 246
    4e1e:	d9 01       	movw	r26, r18
    4e20:	a2 54       	subi	r26, 0x42	; 66
    4e22:	b4 4f       	sbci	r27, 0xF4	; 244
    4e24:	8c 91       	ld	r24, X
    4e26:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    4e28:	2f 5f       	subi	r18, 0xFF	; 255
    4e2a:	3f 4f       	sbci	r19, 0xFF	; 255
    4e2c:	24 31       	cpi	r18, 0x14	; 20
    4e2e:	31 05       	cpc	r19, r1
    4e30:	99 f7       	brne	.-26     	; 0x4e18 <procMessage57+0xec>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    4e32:	10 92 70 09 	sts	0x0970, r1
		 //LicPlate
		 StrPosCopy(rcv_trans,strLicPlate,193-2,10);
		 RemSpaceLag(strLicPlate);
		 //CompName
		 StrPosCopy(rcv_trans,strCompName,203-2,20);
		 RemSpaceLag(strCompName);
    4e36:	8c e5       	ldi	r24, 0x5C	; 92
    4e38:	99 e0       	ldi	r25, 0x09	; 9
    4e3a:	0e 94 4c 26 	call	0x4c98	; 0x4c98 <RemSpaceLag>
		 _uart_print(0,1,strCompName);
		 
_uart_print(0,1,strCardID);
*/	
     return Result;
}
    4e3e:	81 2f       	mov	r24, r17
    4e40:	8f 52       	subi	r24, 0x2F	; 47
    4e42:	1f 91       	pop	r17
    4e44:	08 95       	ret

00004e46 <clearString>:
	     break;
	}
  return Result;
}

void clearString(char *str){
    4e46:	20 e0       	ldi	r18, 0x00	; 0
    4e48:	30 e0       	ldi	r19, 0x00	; 0
    4e4a:	06 c0       	rjmp	.+12     	; 0x4e58 <clearString+0x12>
     int i;
	 for(i=0;i<strlen(str);i++){
	    str[i]=0;
    4e4c:	fc 01       	movw	r30, r24
    4e4e:	e2 0f       	add	r30, r18
    4e50:	f3 1f       	adc	r31, r19
    4e52:	10 82       	st	Z, r1
  return Result;
}

void clearString(char *str){
     int i;
	 for(i=0;i<strlen(str);i++){
    4e54:	2f 5f       	subi	r18, 0xFF	; 255
    4e56:	3f 4f       	sbci	r19, 0xFF	; 255
    4e58:	fc 01       	movw	r30, r24
    4e5a:	01 90       	ld	r0, Z+
    4e5c:	00 20       	and	r0, r0
    4e5e:	e9 f7       	brne	.-6      	; 0x4e5a <clearString+0x14>
    4e60:	31 97       	sbiw	r30, 0x01	; 1
    4e62:	e8 1b       	sub	r30, r24
    4e64:	f9 0b       	sbc	r31, r25
    4e66:	2e 17       	cp	r18, r30
    4e68:	3f 07       	cpc	r19, r31
    4e6a:	80 f3       	brcs	.-32     	; 0x4e4c <clearString+0x6>
	    str[i]=0;
	 }
}
    4e6c:	08 95       	ret

00004e6e <AddZeroLead>:
	 }String[Size]=0;
  }
}


void AddZeroLead(char *String,unsigned char Size){// 1234 ->0000001234
    4e6e:	bf 92       	push	r11
    4e70:	cf 92       	push	r12
    4e72:	df 92       	push	r13
    4e74:	ef 92       	push	r14
    4e76:	ff 92       	push	r15
    4e78:	0f 93       	push	r16
    4e7a:	1f 93       	push	r17
    4e7c:	df 93       	push	r29
    4e7e:	cf 93       	push	r28
    4e80:	cd b7       	in	r28, 0x3d	; 61
    4e82:	de b7       	in	r29, 0x3e	; 62
    4e84:	6e 97       	sbiw	r28, 0x1e	; 30
    4e86:	0f b6       	in	r0, 0x3f	; 63
    4e88:	f8 94       	cli
    4e8a:	de bf       	out	0x3e, r29	; 62
    4e8c:	0f be       	out	0x3f, r0	; 63
    4e8e:	cd bf       	out	0x3d, r28	; 61
    4e90:	8c 01       	movw	r16, r24
     char i,Length,strAdded[30];
     Length=strlen(String);
    4e92:	fc 01       	movw	r30, r24
    4e94:	01 90       	ld	r0, Z+
    4e96:	00 20       	and	r0, r0
    4e98:	e9 f7       	brne	.-6      	; 0x4e94 <AddZeroLead+0x26>
    4e9a:	31 97       	sbiw	r30, 0x01	; 1
    4e9c:	2e 2f       	mov	r18, r30
    4e9e:	28 1b       	sub	r18, r24

	 if (Size>Length){
    4ea0:	26 17       	cp	r18, r22
    4ea2:	e0 f5       	brcc	.+120    	; 0x4f1c <AddZeroLead+0xae>
    4ea4:	7e 01       	movw	r14, r28
    4ea6:	08 94       	sec
    4ea8:	e1 1c       	adc	r14, r1
    4eaa:	f1 1c       	adc	r15, r1
    4eac:	f7 01       	movw	r30, r14
	 }String[Size]=0;
  }
}


void AddZeroLead(char *String,unsigned char Size){// 1234 ->0000001234
    4eae:	be 2c       	mov	r11, r14
     char i,Length,strAdded[30];
     Length=strlen(String);

	 if (Size>Length){
         for(i=0;i<Size;i++){
	         strAdded[i]='0';
    4eb0:	90 e3       	ldi	r25, 0x30	; 48
    4eb2:	01 c0       	rjmp	.+2      	; 0x4eb6 <AddZeroLead+0x48>
    4eb4:	91 93       	st	Z+, r25
void AddZeroLead(char *String,unsigned char Size){// 1234 ->0000001234
     char i,Length,strAdded[30];
     Length=strlen(String);

	 if (Size>Length){
         for(i=0;i<Size;i++){
    4eb6:	8e 2f       	mov	r24, r30
    4eb8:	8b 19       	sub	r24, r11
    4eba:	86 17       	cp	r24, r22
    4ebc:	d8 f3       	brcs	.-10     	; 0x4eb4 <AddZeroLead+0x46>
	         strAdded[i]='0';
	     }strAdded[Size]=0;
    4ebe:	46 2f       	mov	r20, r22
    4ec0:	50 e0       	ldi	r21, 0x00	; 0
    4ec2:	ce 01       	movw	r24, r28
    4ec4:	01 96       	adiw	r24, 0x01	; 1
    4ec6:	fc 01       	movw	r30, r24
    4ec8:	e4 0f       	add	r30, r20
    4eca:	f5 1f       	adc	r31, r21
    4ecc:	10 82       	st	Z, r1
	     //Copy
         for(i=(Size-Length);i<Size;i++){
    4ece:	76 2f       	mov	r23, r22
    4ed0:	72 1b       	sub	r23, r18
    4ed2:	6c 01       	movw	r12, r24
	         strAdded[i]=String[i-(Size-Length)];
    4ed4:	30 e0       	ldi	r19, 0x00	; 0
    4ed6:	24 1b       	sub	r18, r20
    4ed8:	35 0b       	sbc	r19, r21
    4eda:	0c c0       	rjmp	.+24     	; 0x4ef4 <AddZeroLead+0x86>
    4edc:	e7 2f       	mov	r30, r23
    4ede:	f0 e0       	ldi	r31, 0x00	; 0
    4ee0:	d6 01       	movw	r26, r12
    4ee2:	ae 0f       	add	r26, r30
    4ee4:	bf 1f       	adc	r27, r31
    4ee6:	e0 0f       	add	r30, r16
    4ee8:	f1 1f       	adc	r31, r17
    4eea:	e2 0f       	add	r30, r18
    4eec:	f3 1f       	adc	r31, r19
    4eee:	80 81       	ld	r24, Z
    4ef0:	8c 93       	st	X, r24
	 if (Size>Length){
         for(i=0;i<Size;i++){
	         strAdded[i]='0';
	     }strAdded[Size]=0;
	     //Copy
         for(i=(Size-Length);i<Size;i++){
    4ef2:	7f 5f       	subi	r23, 0xFF	; 255
    4ef4:	76 17       	cp	r23, r22
    4ef6:	90 f3       	brcs	.-28     	; 0x4edc <AddZeroLead+0x6e>
	         strAdded[i]=String[i-(Size-Length)];
	     }strAdded[Size]=0;
    4ef8:	4c 0d       	add	r20, r12
    4efa:	5d 1d       	adc	r21, r13
    4efc:	da 01       	movw	r26, r20
    4efe:	1c 92       	st	X, r1
    4f00:	f8 01       	movw	r30, r16
    4f02:	04 c0       	rjmp	.+8      	; 0x4f0c <AddZeroLead+0x9e>
	     //Zeroed
         for(i=0;i<Size;i++){
	         String[i]=strAdded[i];
    4f04:	d7 01       	movw	r26, r14
    4f06:	8d 91       	ld	r24, X+
    4f08:	7d 01       	movw	r14, r26
    4f0a:	81 93       	st	Z+, r24
	     //Copy
         for(i=(Size-Length);i<Size;i++){
	         strAdded[i]=String[i-(Size-Length)];
	     }strAdded[Size]=0;
	     //Zeroed
         for(i=0;i<Size;i++){
    4f0c:	8e 2d       	mov	r24, r14
    4f0e:	8b 19       	sub	r24, r11
    4f10:	86 17       	cp	r24, r22
    4f12:	c0 f3       	brcs	.-16     	; 0x4f04 <AddZeroLead+0x96>
	         String[i]=strAdded[i];
	     }String[Size]=0;
    4f14:	06 0f       	add	r16, r22
    4f16:	11 1d       	adc	r17, r1
    4f18:	f8 01       	movw	r30, r16
    4f1a:	10 82       	st	Z, r1
	 }
}
    4f1c:	6e 96       	adiw	r28, 0x1e	; 30
    4f1e:	0f b6       	in	r0, 0x3f	; 63
    4f20:	f8 94       	cli
    4f22:	de bf       	out	0x3e, r29	; 62
    4f24:	0f be       	out	0x3f, r0	; 63
    4f26:	cd bf       	out	0x3d, r28	; 61
    4f28:	cf 91       	pop	r28
    4f2a:	df 91       	pop	r29
    4f2c:	1f 91       	pop	r17
    4f2e:	0f 91       	pop	r16
    4f30:	ff 90       	pop	r15
    4f32:	ef 90       	pop	r14
    4f34:	df 90       	pop	r13
    4f36:	cf 90       	pop	r12
    4f38:	bf 90       	pop	r11
    4f3a:	08 95       	ret

00004f3c <GetTotalizerMoney>:
	     FIPAddr=FIPAddr-1;	     
	     GetTotalizerData(TVOLUME,TOTALIZER_NOW,FIPAddr,iGrade,Result);
	 }
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalTotalVolume),2,Result);
}
void GetTotalizerMoney(char iPumpID,char iGrade, char *Result){
    4f3c:	0f 93       	push	r16
    4f3e:	1f 93       	push	r17
    4f40:	cf 93       	push	r28
    4f42:	df 93       	push	r29
    4f44:	18 2f       	mov	r17, r24
    4f46:	06 2f       	mov	r16, r22
    4f48:	ea 01       	movw	r28, r20
     char FIPAddr;
     AddZeroLead(Result,13); 
    4f4a:	ca 01       	movw	r24, r20
    4f4c:	6d e0       	ldi	r22, 0x0D	; 13
    4f4e:	0e 94 37 27 	call	0x4e6e	; 0x4e6e <AddZeroLead>
	 FIPAddr=GetFIPAddr(iPumpID);
    4f52:	81 2f       	mov	r24, r17
    4f54:	0e 94 e1 1d 	call	0x3bc2	; 0x3bc2 <GetFIPAddr>
    4f58:	48 2f       	mov	r20, r24
	 if (FIPAddr>0){
    4f5a:	88 23       	and	r24, r24
    4f5c:	39 f0       	breq	.+14     	; 0x4f6c <GetTotalizerMoney+0x30>
	    FIPAddr=FIPAddr-1;
	    GetTotalizerData(TMONEY,TOTALIZER_NOW,FIPAddr,iGrade,Result);
    4f5e:	41 50       	subi	r20, 0x01	; 1
    4f60:	81 e0       	ldi	r24, 0x01	; 1
    4f62:	61 e0       	ldi	r22, 0x01	; 1
    4f64:	20 2f       	mov	r18, r16
    4f66:	8e 01       	movw	r16, r28
    4f68:	0e 94 a0 1e 	call	0x3d40	; 0x3d40 <GetTotalizerData>
	}
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalTotalMoney),2,Result);
}
    4f6c:	df 91       	pop	r29
    4f6e:	cf 91       	pop	r28
    4f70:	1f 91       	pop	r17
    4f72:	0f 91       	pop	r16
    4f74:	08 95       	ret

00004f76 <GetTotalizerVolume>:
     AddZeroLead(Result,10);
	 sprintf_P(Result,PSTR("%s"),RecPumpData[iPumpID&0x0F].Money);
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalMoney),3,Result);
}

void GetTotalizerVolume(char iPumpID,char iGrade,char *Result){
    4f76:	0f 93       	push	r16
    4f78:	1f 93       	push	r17
    4f7a:	cf 93       	push	r28
    4f7c:	df 93       	push	r29
    4f7e:	18 2f       	mov	r17, r24
    4f80:	06 2f       	mov	r16, r22
    4f82:	ea 01       	movw	r28, r20
     char FIPAddr;
     AddZeroLead(Result,11);
    4f84:	ca 01       	movw	r24, r20
    4f86:	6b e0       	ldi	r22, 0x0B	; 11
    4f88:	0e 94 37 27 	call	0x4e6e	; 0x4e6e <AddZeroLead>
	 FIPAddr=GetFIPAddr(iPumpID);
    4f8c:	81 2f       	mov	r24, r17
    4f8e:	0e 94 e1 1d 	call	0x3bc2	; 0x3bc2 <GetFIPAddr>
    4f92:	48 2f       	mov	r20, r24
	 if (FIPAddr>0){
    4f94:	88 23       	and	r24, r24
    4f96:	39 f0       	breq	.+14     	; 0x4fa6 <GetTotalizerVolume+0x30>
	     FIPAddr=FIPAddr-1;	     
	     GetTotalizerData(TVOLUME,TOTALIZER_NOW,FIPAddr,iGrade,Result);
    4f98:	41 50       	subi	r20, 0x01	; 1
    4f9a:	80 e0       	ldi	r24, 0x00	; 0
    4f9c:	61 e0       	ldi	r22, 0x01	; 1
    4f9e:	20 2f       	mov	r18, r16
    4fa0:	8e 01       	movw	r16, r28
    4fa2:	0e 94 a0 1e 	call	0x3d40	; 0x3d40 <GetTotalizerData>
	 }
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalTotalVolume),2,Result);
}
    4fa6:	df 91       	pop	r29
    4fa8:	cf 91       	pop	r28
    4faa:	1f 91       	pop	r17
    4fac:	0f 91       	pop	r16
    4fae:	08 95       	ret

00004fb0 <GetTransactionMoney>:
void GetTransactionVolume(char iPumpID,char *Result){
     AddZeroLead(Result,10);
     sprintf_P(Result,PSTR("%s"),RecPumpData[iPumpID&0x0F].Volume); 
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalVolume),3,Result);
}
void GetTransactionMoney(char iPumpID,char *Result){
    4fb0:	ef 92       	push	r14
    4fb2:	ff 92       	push	r15
    4fb4:	0f 93       	push	r16
    4fb6:	1f 93       	push	r17
    4fb8:	08 2f       	mov	r16, r24
    4fba:	7b 01       	movw	r14, r22
     AddZeroLead(Result,10);
    4fbc:	cb 01       	movw	r24, r22
    4fbe:	6a e0       	ldi	r22, 0x0A	; 10
    4fc0:	0e 94 37 27 	call	0x4e6e	; 0x4e6e <AddZeroLead>
	 sprintf_P(Result,PSTR("%s"),RecPumpData[iPumpID&0x0F].Money);
    4fc4:	00 d0       	rcall	.+0      	; 0x4fc6 <GetTransactionMoney+0x16>
    4fc6:	00 d0       	rcall	.+0      	; 0x4fc8 <GetTransactionMoney+0x18>
    4fc8:	00 d0       	rcall	.+0      	; 0x4fca <GetTransactionMoney+0x1a>
    4fca:	ed b7       	in	r30, 0x3d	; 61
    4fcc:	fe b7       	in	r31, 0x3e	; 62
    4fce:	31 96       	adiw	r30, 0x01	; 1
    4fd0:	ad b7       	in	r26, 0x3d	; 61
    4fd2:	be b7       	in	r27, 0x3e	; 62
    4fd4:	12 96       	adiw	r26, 0x02	; 2
    4fd6:	fc 92       	st	X, r15
    4fd8:	ee 92       	st	-X, r14
    4fda:	11 97       	sbiw	r26, 0x01	; 1
    4fdc:	8a e6       	ldi	r24, 0x6A	; 106
    4fde:	93 e0       	ldi	r25, 0x03	; 3
    4fe0:	93 83       	std	Z+3, r25	; 0x03
    4fe2:	82 83       	std	Z+2, r24	; 0x02
    4fe4:	10 e0       	ldi	r17, 0x00	; 0
    4fe6:	0f 70       	andi	r16, 0x0F	; 15
    4fe8:	10 70       	andi	r17, 0x00	; 0
    4fea:	85 e3       	ldi	r24, 0x35	; 53
    4fec:	90 e0       	ldi	r25, 0x00	; 0
    4fee:	9c 01       	movw	r18, r24
    4ff0:	02 9f       	mul	r16, r18
    4ff2:	c0 01       	movw	r24, r0
    4ff4:	03 9f       	mul	r16, r19
    4ff6:	90 0d       	add	r25, r0
    4ff8:	12 9f       	mul	r17, r18
    4ffa:	90 0d       	add	r25, r0
    4ffc:	11 24       	eor	r1, r1
    4ffe:	89 54       	subi	r24, 0x49	; 73
    5000:	98 4f       	sbci	r25, 0xF8	; 248
    5002:	95 83       	std	Z+5, r25	; 0x05
    5004:	84 83       	std	Z+4, r24	; 0x04
    5006:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    500a:	8d b7       	in	r24, 0x3d	; 61
    500c:	9e b7       	in	r25, 0x3e	; 62
    500e:	06 96       	adiw	r24, 0x06	; 6
    5010:	0f b6       	in	r0, 0x3f	; 63
    5012:	f8 94       	cli
    5014:	9e bf       	out	0x3e, r25	; 62
    5016:	0f be       	out	0x3f, r0	; 63
    5018:	8d bf       	out	0x3d, r24	; 61
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalMoney),3,Result);
}
    501a:	1f 91       	pop	r17
    501c:	0f 91       	pop	r16
    501e:	ff 90       	pop	r15
    5020:	ef 90       	pop	r14
    5022:	08 95       	ret

00005024 <GetTransactionVolume>:
     }
*/
     FormatDecimal(Result,CurrentDecimal);
}

void GetTransactionVolume(char iPumpID,char *Result){
    5024:	ef 92       	push	r14
    5026:	ff 92       	push	r15
    5028:	0f 93       	push	r16
    502a:	1f 93       	push	r17
    502c:	08 2f       	mov	r16, r24
    502e:	7b 01       	movw	r14, r22
     AddZeroLead(Result,10);
    5030:	cb 01       	movw	r24, r22
    5032:	6a e0       	ldi	r22, 0x0A	; 10
    5034:	0e 94 37 27 	call	0x4e6e	; 0x4e6e <AddZeroLead>
     sprintf_P(Result,PSTR("%s"),RecPumpData[iPumpID&0x0F].Volume); 
    5038:	00 d0       	rcall	.+0      	; 0x503a <GetTransactionVolume+0x16>
    503a:	00 d0       	rcall	.+0      	; 0x503c <GetTransactionVolume+0x18>
    503c:	00 d0       	rcall	.+0      	; 0x503e <GetTransactionVolume+0x1a>
    503e:	ed b7       	in	r30, 0x3d	; 61
    5040:	fe b7       	in	r31, 0x3e	; 62
    5042:	31 96       	adiw	r30, 0x01	; 1
    5044:	ad b7       	in	r26, 0x3d	; 61
    5046:	be b7       	in	r27, 0x3e	; 62
    5048:	12 96       	adiw	r26, 0x02	; 2
    504a:	fc 92       	st	X, r15
    504c:	ee 92       	st	-X, r14
    504e:	11 97       	sbiw	r26, 0x01	; 1
    5050:	8d e6       	ldi	r24, 0x6D	; 109
    5052:	93 e0       	ldi	r25, 0x03	; 3
    5054:	93 83       	std	Z+3, r25	; 0x03
    5056:	82 83       	std	Z+2, r24	; 0x02
    5058:	10 e0       	ldi	r17, 0x00	; 0
    505a:	0f 70       	andi	r16, 0x0F	; 15
    505c:	10 70       	andi	r17, 0x00	; 0
    505e:	85 e3       	ldi	r24, 0x35	; 53
    5060:	90 e0       	ldi	r25, 0x00	; 0
    5062:	9c 01       	movw	r18, r24
    5064:	02 9f       	mul	r16, r18
    5066:	c0 01       	movw	r24, r0
    5068:	03 9f       	mul	r16, r19
    506a:	90 0d       	add	r25, r0
    506c:	12 9f       	mul	r17, r18
    506e:	90 0d       	add	r25, r0
    5070:	11 24       	eor	r1, r1
    5072:	82 55       	subi	r24, 0x52	; 82
    5074:	98 4f       	sbci	r25, 0xF8	; 248
    5076:	95 83       	std	Z+5, r25	; 0x05
    5078:	84 83       	std	Z+4, r24	; 0x04
    507a:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    507e:	8d b7       	in	r24, 0x3d	; 61
    5080:	9e b7       	in	r25, 0x3e	; 62
    5082:	06 96       	adiw	r24, 0x06	; 6
    5084:	0f b6       	in	r0, 0x3f	; 63
    5086:	f8 94       	cli
    5088:	9e bf       	out	0x3e, r25	; 62
    508a:	0f be       	out	0x3f, r0	; 63
    508c:	8d bf       	out	0x3d, r24	; 61
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalVolume),3,Result);
}
    508e:	1f 91       	pop	r17
    5090:	0f 91       	pop	r16
    5092:	ff 90       	pop	r15
    5094:	ef 90       	pop	r14
    5096:	08 95       	ret

00005098 <SetTotalizerData>:
			  }
		  }
	 }
}

void SetTotalizerData(char TType, char TAddr, char xPumpAddr, char xGradeAddr, char *strValue){// 0 1 1 "00000000"
    5098:	af 92       	push	r10
    509a:	bf 92       	push	r11
    509c:	cf 92       	push	r12
    509e:	df 92       	push	r13
    50a0:	ef 92       	push	r14
    50a2:	ff 92       	push	r15
    50a4:	0f 93       	push	r16
    50a6:	1f 93       	push	r17
    50a8:	df 93       	push	r29
    50aa:	cf 93       	push	r28
    50ac:	cd b7       	in	r28, 0x3d	; 61
    50ae:	de b7       	in	r29, 0x3e	; 62
    50b0:	65 97       	sbiw	r28, 0x15	; 21
    50b2:	0f b6       	in	r0, 0x3f	; 63
    50b4:	f8 94       	cli
    50b6:	de bf       	out	0x3e, r29	; 62
    50b8:	0f be       	out	0x3f, r0	; 63
    50ba:	cd bf       	out	0x3d, r28	; 61
    50bc:	d8 2e       	mov	r13, r24
    50be:	c6 2e       	mov	r12, r22
    50c0:	b4 2e       	mov	r11, r20
    50c2:	a2 2e       	mov	r10, r18
     char rawValue[6],iPumpAddr,iGrade;
	 char strPValue[15];
	 char Idx;
	 char strSend[30];
	 //Convert String to RawData
	 if (strlen(strValue)<=12){
    50c4:	d8 01       	movw	r26, r16
    50c6:	0d 90       	ld	r0, X+
    50c8:	00 20       	and	r0, r0
    50ca:	e9 f7       	brne	.-6      	; 0x50c6 <SetTotalizerData+0x2e>
    50cc:	11 97       	sbiw	r26, 0x01	; 1
    50ce:	a0 1b       	sub	r26, r16
    50d0:	b1 0b       	sbc	r27, r17
    50d2:	87 e0       	ldi	r24, 0x07	; 7
    50d4:	e8 2e       	mov	r14, r24
    50d6:	f1 2c       	mov	r15, r1
    50d8:	ec 0e       	add	r14, r28
    50da:	fd 1e       	adc	r15, r29
    50dc:	ad 30       	cpi	r26, 0x0D	; 13
    50de:	b1 05       	cpc	r27, r1
    50e0:	58 f5       	brcc	.+86     	; 0x5138 <SetTotalizerData+0xa0>
	     sprintf_P(strPValue,PSTR("%s"),strValue);
    50e2:	00 d0       	rcall	.+0      	; 0x50e4 <SetTotalizerData+0x4c>
    50e4:	00 d0       	rcall	.+0      	; 0x50e6 <SetTotalizerData+0x4e>
    50e6:	00 d0       	rcall	.+0      	; 0x50e8 <SetTotalizerData+0x50>
    50e8:	ed b7       	in	r30, 0x3d	; 61
    50ea:	fe b7       	in	r31, 0x3e	; 62
    50ec:	31 96       	adiw	r30, 0x01	; 1
    50ee:	ad b7       	in	r26, 0x3d	; 61
    50f0:	be b7       	in	r27, 0x3e	; 62
    50f2:	12 96       	adiw	r26, 0x02	; 2
    50f4:	fc 92       	st	X, r15
    50f6:	ee 92       	st	-X, r14
    50f8:	11 97       	sbiw	r26, 0x01	; 1
    50fa:	8f ee       	ldi	r24, 0xEF	; 239
    50fc:	95 e0       	ldi	r25, 0x05	; 5
    50fe:	93 83       	std	Z+3, r25	; 0x03
    5100:	82 83       	std	Z+2, r24	; 0x02
    5102:	15 83       	std	Z+5, r17	; 0x05
    5104:	04 83       	std	Z+4, r16	; 0x04
    5106:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
		 if (strlen(strPValue)<12)AddZeroLead(strPValue,12);
    510a:	f7 01       	movw	r30, r14
    510c:	01 90       	ld	r0, Z+
    510e:	00 20       	and	r0, r0
    5110:	e9 f7       	brne	.-6      	; 0x510c <SetTotalizerData+0x74>
    5112:	31 97       	sbiw	r30, 0x01	; 1
    5114:	ee 19       	sub	r30, r14
    5116:	ff 09       	sbc	r31, r15
    5118:	6d b7       	in	r22, 0x3d	; 61
    511a:	7e b7       	in	r23, 0x3e	; 62
    511c:	6a 5f       	subi	r22, 0xFA	; 250
    511e:	7f 4f       	sbci	r23, 0xFF	; 255
    5120:	0f b6       	in	r0, 0x3f	; 63
    5122:	f8 94       	cli
    5124:	7e bf       	out	0x3e, r23	; 62
    5126:	0f be       	out	0x3f, r0	; 63
    5128:	6d bf       	out	0x3d, r22	; 61
    512a:	3c 97       	sbiw	r30, 0x0c	; 12
    512c:	a0 f4       	brcc	.+40     	; 0x5156 <SetTotalizerData+0xbe>
    512e:	c7 01       	movw	r24, r14
    5130:	6c e0       	ldi	r22, 0x0C	; 12
    5132:	0e 94 37 27 	call	0x4e6e	; 0x4e6e <AddZeroLead>
    5136:	0f c0       	rjmp	.+30     	; 0x5156 <SetTotalizerData+0xbe>
    5138:	8a 2f       	mov	r24, r26
    513a:	8c 50       	subi	r24, 0x0C	; 12
    513c:	f8 01       	movw	r30, r16
    513e:	e8 0f       	add	r30, r24
    5140:	f1 1d       	adc	r31, r1
    5142:	d7 01       	movw	r26, r14
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    5144:	9e 01       	movw	r18, r28
    5146:	2d 5e       	subi	r18, 0xED	; 237
    5148:	3f 4f       	sbci	r19, 0xFF	; 255
	    Dest[i]=Source[IdxSource+i];
    514a:	81 91       	ld	r24, Z+
    514c:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    514e:	a2 17       	cp	r26, r18
    5150:	b3 07       	cpc	r27, r19
    5152:	d9 f7       	brne	.-10     	; 0x514a <SetTotalizerData+0xb2>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    5154:	1b 8a       	std	Y+19, r1	; 0x13
	 else {//Lebih dari 8: 0123456789
	     Idx=strlen(strValue)-12;
	     StrPosCopy(strValue,strPValue,Idx,12);
	 }

	 iPumpAddr=(xPumpAddr&0x0F);
    5156:	0b 2d       	mov	r16, r11
    5158:	0f 70       	andi	r16, 0x0F	; 15
	 if ((xGradeAddr>=1)&&(xGradeAddr<=6))
    515a:	1a 2d       	mov	r17, r10
    515c:	11 50       	subi	r17, 0x01	; 1
    515e:	16 30       	cpi	r17, 0x06	; 6
    5160:	08 f0       	brcs	.+2      	; 0x5164 <SetTotalizerData+0xcc>
    5162:	10 e0       	ldi	r17, 0x00	; 0
	     iGrade=xGradeAddr-1;
	 StrToRaw(strPValue,rawValue);
    5164:	ce 01       	movw	r24, r28
    5166:	07 96       	adiw	r24, 0x07	; 7
    5168:	7e 01       	movw	r14, r28
    516a:	08 94       	sec
    516c:	e1 1c       	adc	r14, r1
    516e:	f1 1c       	adc	r15, r1
    5170:	b7 01       	movw	r22, r14
    5172:	0e 94 d4 19 	call	0x33a8	; 0x33a8 <StrToRaw>

	 if (TType==TVOLUME)eeprom_write_block((const void*)&rawValue,(void*)&(TotalVolume[TAddr][iPumpAddr][iGrade]), sizeof(rawValue));
    5176:	dd 20       	and	r13, r13
    5178:	d9 f4       	brne	.+54     	; 0x51b0 <SetTotalizerData+0x118>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    517a:	84 e2       	ldi	r24, 0x24	; 36
    517c:	08 9f       	mul	r16, r24
    517e:	c0 01       	movw	r24, r0
    5180:	11 24       	eor	r1, r1
    5182:	4c 2d       	mov	r20, r12
    5184:	50 e0       	ldi	r21, 0x00	; 0
    5186:	20 e2       	ldi	r18, 0x20	; 32
    5188:	31 e0       	ldi	r19, 0x01	; 1
    518a:	d9 01       	movw	r26, r18
    518c:	4a 9f       	mul	r20, r26
    518e:	90 01       	movw	r18, r0
    5190:	4b 9f       	mul	r20, r27
    5192:	30 0d       	add	r19, r0
    5194:	5a 9f       	mul	r21, r26
    5196:	30 0d       	add	r19, r0
    5198:	11 24       	eor	r1, r1
    519a:	82 0f       	add	r24, r18
    519c:	93 1f       	adc	r25, r19
    519e:	26 e0       	ldi	r18, 0x06	; 6
    51a0:	12 9f       	mul	r17, r18
    51a2:	90 01       	movw	r18, r0
    51a4:	11 24       	eor	r1, r1
    51a6:	82 0f       	add	r24, r18
    51a8:	93 1f       	adc	r25, r19
    51aa:	8d 53       	subi	r24, 0x3D	; 61
    51ac:	9c 4f       	sbci	r25, 0xFC	; 252
    51ae:	1d c0       	rjmp	.+58     	; 0x51ea <SetTotalizerData+0x152>
	 else 
	 if (TType==TMONEY)eeprom_write_block((const void*)&rawValue,(void*)&(TotalMoney[TAddr][iPumpAddr][iGrade]), sizeof(rawValue));
    51b0:	b1 e0       	ldi	r27, 0x01	; 1
    51b2:	db 16       	cp	r13, r27
    51b4:	09 f5       	brne	.+66     	; 0x51f8 <SetTotalizerData+0x160>
    51b6:	84 e2       	ldi	r24, 0x24	; 36
    51b8:	08 9f       	mul	r16, r24
    51ba:	c0 01       	movw	r24, r0
    51bc:	11 24       	eor	r1, r1
    51be:	4c 2d       	mov	r20, r12
    51c0:	50 e0       	ldi	r21, 0x00	; 0
    51c2:	20 e2       	ldi	r18, 0x20	; 32
    51c4:	31 e0       	ldi	r19, 0x01	; 1
    51c6:	b9 01       	movw	r22, r18
    51c8:	46 9f       	mul	r20, r22
    51ca:	90 01       	movw	r18, r0
    51cc:	47 9f       	mul	r20, r23
    51ce:	30 0d       	add	r19, r0
    51d0:	56 9f       	mul	r21, r22
    51d2:	30 0d       	add	r19, r0
    51d4:	11 24       	eor	r1, r1
    51d6:	82 0f       	add	r24, r18
    51d8:	93 1f       	adc	r25, r19
    51da:	26 e0       	ldi	r18, 0x06	; 6
    51dc:	12 9f       	mul	r17, r18
    51de:	90 01       	movw	r18, r0
    51e0:	11 24       	eor	r1, r1
    51e2:	82 0f       	add	r24, r18
    51e4:	93 1f       	adc	r25, r19
    51e6:	8d 5f       	subi	r24, 0xFD	; 253
    51e8:	99 4f       	sbci	r25, 0xF9	; 249
    51ea:	b7 01       	movw	r22, r14
    51ec:	46 e0       	ldi	r20, 0x06	; 6
    51ee:	50 e0       	ldi	r21, 0x00	; 0
    51f0:	2e ef       	ldi	r18, 0xFE	; 254
    51f2:	32 e1       	ldi	r19, 0x12	; 18
    51f4:	0e 94 96 b5 	call	0x16b2c	; 0x16b2c <__eewr_block>
}
    51f8:	65 96       	adiw	r28, 0x15	; 21
    51fa:	0f b6       	in	r0, 0x3f	; 63
    51fc:	f8 94       	cli
    51fe:	de bf       	out	0x3e, r29	; 62
    5200:	0f be       	out	0x3f, r0	; 63
    5202:	cd bf       	out	0x3d, r28	; 61
    5204:	cf 91       	pop	r28
    5206:	df 91       	pop	r29
    5208:	1f 91       	pop	r17
    520a:	0f 91       	pop	r16
    520c:	ff 90       	pop	r15
    520e:	ef 90       	pop	r14
    5210:	df 90       	pop	r13
    5212:	cf 90       	pop	r12
    5214:	bf 90       	pop	r11
    5216:	af 90       	pop	r10
    5218:	08 95       	ret

0000521a <SaveTotalizerCurrentToLast>:
	 }Dest[12]=0;
}

//SetTotalizerData(TVOLUME,TOTALIZER_NOW,1,1,strVolume)

void SaveTotalizerCurrentToLast(){
    521a:	4f 92       	push	r4
    521c:	5f 92       	push	r5
    521e:	7f 92       	push	r7
    5220:	8f 92       	push	r8
    5222:	9f 92       	push	r9
    5224:	af 92       	push	r10
    5226:	bf 92       	push	r11
    5228:	cf 92       	push	r12
    522a:	df 92       	push	r13
    522c:	ef 92       	push	r14
    522e:	ff 92       	push	r15
    5230:	0f 93       	push	r16
    5232:	1f 93       	push	r17
    5234:	df 93       	push	r29
    5236:	cf 93       	push	r28
    5238:	cd b7       	in	r28, 0x3d	; 61
    523a:	de b7       	in	r29, 0x3e	; 62
    523c:	2f 97       	sbiw	r28, 0x0f	; 15
    523e:	0f b6       	in	r0, 0x3f	; 63
    5240:	f8 94       	cli
    5242:	de bf       	out	0x3e, r29	; 62
    5244:	0f be       	out	0x3f, r0	; 63
    5246:	cd bf       	out	0x3d, r28	; 61
    5248:	77 24       	eor	r7, r7
    524a:	73 94       	inc	r7
	 
	 for (iPump=1;iPump<=16;iPump++){//Pump
	      FIPAddr=GetFIPAddr(iPump);
		  if (FIPAddr>0){
		      FIPAddr=FIPAddr-1;
			  for(iGrade=1;iGrade<=6;iGrade++){
    524c:	4e 01       	movw	r8, r28
    524e:	08 94       	sec
    5250:	81 1c       	adc	r8, r1
    5252:	91 1c       	adc	r9, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    5254:	90 e1       	ldi	r25, 0x10	; 16
    5256:	49 2e       	mov	r4, r25
    5258:	51 2c       	mov	r5, r1
    525a:	4c 0e       	add	r4, r28
    525c:	5d 1e       	adc	r5, r29
     char iPump,iGrade;
     char strValue[15];
     char FIPAddr;
	 
	 for (iPump=1;iPump<=16;iPump++){//Pump
	      FIPAddr=GetFIPAddr(iPump);
    525e:	87 2d       	mov	r24, r7
    5260:	0e 94 e1 1d 	call	0x3bc2	; 0x3bc2 <GetFIPAddr>
		  if (FIPAddr>0){
    5264:	88 23       	and	r24, r24
    5266:	91 f1       	breq	.+100    	; 0x52cc <SaveTotalizerCurrentToLast+0xb2>
		      FIPAddr=FIPAddr-1;
    5268:	a8 2e       	mov	r10, r24
    526a:	aa 94       	dec	r10
    526c:	bb 24       	eor	r11, r11
    526e:	b3 94       	inc	r11
    5270:	2a c0       	rjmp	.+84     	; 0x52c6 <SaveTotalizerCurrentToLast+0xac>
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    5272:	f7 01       	movw	r30, r14
    5274:	11 92       	st	Z+, r1
    5276:	7f 01       	movw	r14, r30

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    5278:	e4 15       	cp	r30, r4
    527a:	f5 05       	cpc	r31, r5
    527c:	d1 f7       	brne	.-12     	; 0x5272 <SaveTotalizerCurrentToLast+0x58>
	      FIPAddr=GetFIPAddr(iPump);
		  if (FIPAddr>0){
		      FIPAddr=FIPAddr-1;
			  for(iGrade=1;iGrade<=6;iGrade++){
				  FillChar(strValue,sizeof(strValue),0);
				  GetTotalizerData(TVOLUME,TOTALIZER_NOW,FIPAddr,iGrade,strValue);
    527e:	80 e0       	ldi	r24, 0x00	; 0
    5280:	61 e0       	ldi	r22, 0x01	; 1
    5282:	4a 2d       	mov	r20, r10
    5284:	2b 2d       	mov	r18, r11
    5286:	84 01       	movw	r16, r8
    5288:	0e 94 a0 1e 	call	0x3d40	; 0x3d40 <GetTotalizerData>
				  SetTotalizerData(TVOLUME,TOTALIZER_LAST,FIPAddr,iGrade,strValue);
    528c:	80 e0       	ldi	r24, 0x00	; 0
    528e:	60 e0       	ldi	r22, 0x00	; 0
    5290:	4a 2d       	mov	r20, r10
    5292:	2b 2d       	mov	r18, r11
    5294:	0e 94 4c 28 	call	0x5098	; 0x5098 <SetTotalizerData>
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    5298:	f6 01       	movw	r30, r12
    529a:	11 92       	st	Z+, r1
    529c:	6f 01       	movw	r12, r30

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    529e:	ee 15       	cp	r30, r14
    52a0:	ff 05       	cpc	r31, r15
    52a2:	d1 f7       	brne	.-12     	; 0x5298 <SaveTotalizerCurrentToLast+0x7e>
			  for(iGrade=1;iGrade<=6;iGrade++){
				  FillChar(strValue,sizeof(strValue),0);
				  GetTotalizerData(TVOLUME,TOTALIZER_NOW,FIPAddr,iGrade,strValue);
				  SetTotalizerData(TVOLUME,TOTALIZER_LAST,FIPAddr,iGrade,strValue);
				  FillChar(strValue,sizeof(strValue),0);
				  GetTotalizerData(TMONEY,TOTALIZER_NOW,FIPAddr,iGrade,strValue);
    52a4:	81 e0       	ldi	r24, 0x01	; 1
    52a6:	61 e0       	ldi	r22, 0x01	; 1
    52a8:	4a 2d       	mov	r20, r10
    52aa:	2b 2d       	mov	r18, r11
    52ac:	84 01       	movw	r16, r8
    52ae:	0e 94 a0 1e 	call	0x3d40	; 0x3d40 <GetTotalizerData>
				  SetTotalizerData(TMONEY,TOTALIZER_LAST,FIPAddr,iGrade,strValue);
    52b2:	81 e0       	ldi	r24, 0x01	; 1
    52b4:	60 e0       	ldi	r22, 0x00	; 0
    52b6:	4a 2d       	mov	r20, r10
    52b8:	2b 2d       	mov	r18, r11
    52ba:	0e 94 4c 28 	call	0x5098	; 0x5098 <SetTotalizerData>
	 
	 for (iPump=1;iPump<=16;iPump++){//Pump
	      FIPAddr=GetFIPAddr(iPump);
		  if (FIPAddr>0){
		      FIPAddr=FIPAddr-1;
			  for(iGrade=1;iGrade<=6;iGrade++){
    52be:	b3 94       	inc	r11
    52c0:	f7 e0       	ldi	r31, 0x07	; 7
    52c2:	bf 16       	cp	r11, r31
    52c4:	19 f0       	breq	.+6      	; 0x52cc <SaveTotalizerCurrentToLast+0xb2>
    52c6:	64 01       	movw	r12, r8
    52c8:	74 01       	movw	r14, r8
    52ca:	d3 cf       	rjmp	.-90     	; 0x5272 <SaveTotalizerCurrentToLast+0x58>
void SaveTotalizerCurrentToLast(){
     char iPump,iGrade;
     char strValue[15];
     char FIPAddr;
	 
	 for (iPump=1;iPump<=16;iPump++){//Pump
    52cc:	73 94       	inc	r7
    52ce:	81 e1       	ldi	r24, 0x11	; 17
    52d0:	78 16       	cp	r7, r24
    52d2:	29 f6       	brne	.-118    	; 0x525e <SaveTotalizerCurrentToLast+0x44>
				  GetTotalizerData(TMONEY,TOTALIZER_NOW,FIPAddr,iGrade,strValue);
				  SetTotalizerData(TMONEY,TOTALIZER_LAST,FIPAddr,iGrade,strValue);
			  }
		  }
	 }
}
    52d4:	2f 96       	adiw	r28, 0x0f	; 15
    52d6:	0f b6       	in	r0, 0x3f	; 63
    52d8:	f8 94       	cli
    52da:	de bf       	out	0x3e, r29	; 62
    52dc:	0f be       	out	0x3f, r0	; 63
    52de:	cd bf       	out	0x3d, r28	; 61
    52e0:	cf 91       	pop	r28
    52e2:	df 91       	pop	r29
    52e4:	1f 91       	pop	r17
    52e6:	0f 91       	pop	r16
    52e8:	ff 90       	pop	r15
    52ea:	ef 90       	pop	r14
    52ec:	df 90       	pop	r13
    52ee:	cf 90       	pop	r12
    52f0:	bf 90       	pop	r11
    52f2:	af 90       	pop	r10
    52f4:	9f 90       	pop	r9
    52f6:	8f 90       	pop	r8
    52f8:	7f 90       	pop	r7
    52fa:	5f 90       	pop	r5
    52fc:	4f 90       	pop	r4
    52fe:	08 95       	ret

00005300 <ResetTotalizer>:


//-------------------Totalizer-----------------------------------------
//TAddr{TOTALIZER_LAST,TOTALIZER_NOW}
//TType:{TNONE,TVOLUME,TMONEY};
void ResetTotalizer(char TAddr){//Clear All TotalizerData;
    5300:	af 92       	push	r10
    5302:	bf 92       	push	r11
    5304:	cf 92       	push	r12
    5306:	df 92       	push	r13
    5308:	ef 92       	push	r14
    530a:	ff 92       	push	r15
    530c:	0f 93       	push	r16
    530e:	1f 93       	push	r17
    5310:	df 93       	push	r29
    5312:	cf 93       	push	r28
    5314:	cd b7       	in	r28, 0x3d	; 61
    5316:	de b7       	in	r29, 0x3e	; 62
    5318:	29 97       	sbiw	r28, 0x09	; 9
    531a:	0f b6       	in	r0, 0x3f	; 63
    531c:	f8 94       	cli
    531e:	de bf       	out	0x3e, r29	; 62
    5320:	0f be       	out	0x3f, r0	; 63
    5322:	cd bf       	out	0x3d, r28	; 61
    5324:	a8 2e       	mov	r10, r24
     char iPump,iGrade;
     char strValue[9];
	 char FIPAddr;
	 
	 sprintf_P(strValue,PSTR("00000000"));
    5326:	00 d0       	rcall	.+0      	; 0x5328 <ResetTotalizer+0x28>
    5328:	00 d0       	rcall	.+0      	; 0x532a <ResetTotalizer+0x2a>
    532a:	6e 01       	movw	r12, r28
    532c:	08 94       	sec
    532e:	c1 1c       	adc	r12, r1
    5330:	d1 1c       	adc	r13, r1
    5332:	ed b7       	in	r30, 0x3d	; 61
    5334:	fe b7       	in	r31, 0x3e	; 62
    5336:	d2 82       	std	Z+2, r13	; 0x02
    5338:	c1 82       	std	Z+1, r12	; 0x01
    533a:	82 ef       	ldi	r24, 0xF2	; 242
    533c:	95 e0       	ldi	r25, 0x05	; 5
    533e:	94 83       	std	Z+4, r25	; 0x04
    5340:	83 83       	std	Z+3, r24	; 0x03
    5342:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    5346:	ee 24       	eor	r14, r14
    5348:	e3 94       	inc	r14
    534a:	0f 90       	pop	r0
    534c:	0f 90       	pop	r0
    534e:	0f 90       	pop	r0
    5350:	0f 90       	pop	r0
	 for (iPump=1;iPump<=16;iPump++){//Pump
	      FIPAddr=GetFIPAddr(iPump);
    5352:	8e 2d       	mov	r24, r14
    5354:	0e 94 e1 1d 	call	0x3bc2	; 0x3bc2 <GetFIPAddr>
		  if (FIPAddr>0){
    5358:	88 23       	and	r24, r24
    535a:	a9 f0       	breq	.+42     	; 0x5386 <ResetTotalizer+0x86>
		      FIPAddr=FIPAddr-1;
    535c:	b8 2e       	mov	r11, r24
    535e:	ba 94       	dec	r11
    5360:	ff 24       	eor	r15, r15
    5362:	f3 94       	inc	r15
			  for(iGrade=1;iGrade<=6;iGrade++){
				  SetTotalizerData(TVOLUME,TAddr,FIPAddr,iGrade,strValue);
    5364:	80 e0       	ldi	r24, 0x00	; 0
    5366:	6a 2d       	mov	r22, r10
    5368:	4b 2d       	mov	r20, r11
    536a:	2f 2d       	mov	r18, r15
    536c:	86 01       	movw	r16, r12
    536e:	0e 94 4c 28 	call	0x5098	; 0x5098 <SetTotalizerData>
				  SetTotalizerData(TMONEY,TAddr,FIPAddr,iGrade,strValue);
    5372:	81 e0       	ldi	r24, 0x01	; 1
    5374:	6a 2d       	mov	r22, r10
    5376:	4b 2d       	mov	r20, r11
    5378:	2f 2d       	mov	r18, r15
    537a:	0e 94 4c 28 	call	0x5098	; 0x5098 <SetTotalizerData>
	 sprintf_P(strValue,PSTR("00000000"));
	 for (iPump=1;iPump<=16;iPump++){//Pump
	      FIPAddr=GetFIPAddr(iPump);
		  if (FIPAddr>0){
		      FIPAddr=FIPAddr-1;
			  for(iGrade=1;iGrade<=6;iGrade++){
    537e:	f3 94       	inc	r15
    5380:	f7 e0       	ldi	r31, 0x07	; 7
    5382:	ff 16       	cp	r15, r31
    5384:	79 f7       	brne	.-34     	; 0x5364 <ResetTotalizer+0x64>
     char iPump,iGrade;
     char strValue[9];
	 char FIPAddr;
	 
	 sprintf_P(strValue,PSTR("00000000"));
	 for (iPump=1;iPump<=16;iPump++){//Pump
    5386:	e3 94       	inc	r14
    5388:	81 e1       	ldi	r24, 0x11	; 17
    538a:	e8 16       	cp	r14, r24
    538c:	11 f7       	brne	.-60     	; 0x5352 <ResetTotalizer+0x52>
				  SetTotalizerData(TVOLUME,TAddr,FIPAddr,iGrade,strValue);
				  SetTotalizerData(TMONEY,TAddr,FIPAddr,iGrade,strValue);
			  }
		  }
	 }
}
    538e:	29 96       	adiw	r28, 0x09	; 9
    5390:	0f b6       	in	r0, 0x3f	; 63
    5392:	f8 94       	cli
    5394:	de bf       	out	0x3e, r29	; 62
    5396:	0f be       	out	0x3f, r0	; 63
    5398:	cd bf       	out	0x3d, r28	; 61
    539a:	cf 91       	pop	r28
    539c:	df 91       	pop	r29
    539e:	1f 91       	pop	r17
    53a0:	0f 91       	pop	r16
    53a2:	ff 90       	pop	r15
    53a4:	ef 90       	pop	r14
    53a6:	df 90       	pop	r13
    53a8:	cf 90       	pop	r12
    53aa:	bf 90       	pop	r11
    53ac:	af 90       	pop	r10
    53ae:	08 95       	ret

000053b0 <AddZeroLag>:
	         String[i]=strAdded[i];
	     }String[Size]=0;
	 }
}

void AddZeroLag(char *String,unsigned char Size){// [123]->12300
    53b0:	cf 93       	push	r28
    53b2:	df 93       	push	r29
    53b4:	ec 01       	movw	r28, r24
char i,Length;
     Length=strlen(String);
    53b6:	dc 01       	movw	r26, r24
    53b8:	0d 90       	ld	r0, X+
    53ba:	00 20       	and	r0, r0
    53bc:	e9 f7       	brne	.-6      	; 0x53b8 <AddZeroLag+0x8>
    53be:	11 97       	sbiw	r26, 0x01	; 1
    53c0:	a8 1b       	sub	r26, r24
    53c2:	b9 0b       	sbc	r27, r25
  if (Length<Size){   
    53c4:	a6 17       	cp	r26, r22
    53c6:	60 f4       	brcc	.+24     	; 0x53e0 <AddZeroLag+0x30>
    53c8:	8a 2f       	mov	r24, r26
     for(i=Length;i<Size;i++){
	    String[i]='0';
    53ca:	90 e3       	ldi	r25, 0x30	; 48
    53cc:	fe 01       	movw	r30, r28
    53ce:	e8 0f       	add	r30, r24
    53d0:	f1 1d       	adc	r31, r1
    53d2:	90 83       	st	Z, r25

void AddZeroLag(char *String,unsigned char Size){// [123]->12300
char i,Length;
     Length=strlen(String);
  if (Length<Size){   
     for(i=Length;i<Size;i++){
    53d4:	8f 5f       	subi	r24, 0xFF	; 255
    53d6:	86 17       	cp	r24, r22
    53d8:	c8 f3       	brcs	.-14     	; 0x53cc <AddZeroLag+0x1c>
	    String[i]='0';
	 }String[Size]=0;
    53da:	c6 0f       	add	r28, r22
    53dc:	d1 1d       	adc	r29, r1
    53de:	18 82       	st	Y, r1
  }
}
    53e0:	df 91       	pop	r29
    53e2:	cf 91       	pop	r28
    53e4:	08 95       	ret

000053e6 <StrCalc>:
     
	 //if (NinePos<Length-4)
	 StrCalc(TPLUS,strMaxValue,strOverflowed,strOverflowed);
}
                                                                   //     1111111 
void StrCalc(char TOperation, char *strA , char *strB, char *strC){//  A: 00000000
    53e6:	3f 92       	push	r3
    53e8:	4f 92       	push	r4
    53ea:	5f 92       	push	r5
    53ec:	6f 92       	push	r6
    53ee:	7f 92       	push	r7
    53f0:	8f 92       	push	r8
    53f2:	9f 92       	push	r9
    53f4:	af 92       	push	r10
    53f6:	bf 92       	push	r11
    53f8:	cf 92       	push	r12
    53fa:	df 92       	push	r13
    53fc:	ef 92       	push	r14
    53fe:	ff 92       	push	r15
    5400:	0f 93       	push	r16
    5402:	1f 93       	push	r17
    5404:	df 93       	push	r29
    5406:	cf 93       	push	r28
    5408:	cd b7       	in	r28, 0x3d	; 61
    540a:	de b7       	in	r29, 0x3e	; 62
    540c:	c8 55       	subi	r28, 0x58	; 88
    540e:	d0 40       	sbci	r29, 0x00	; 0
    5410:	0f b6       	in	r0, 0x3f	; 63
    5412:	f8 94       	cli
    5414:	de bf       	out	0x3e, r29	; 62
    5416:	0f be       	out	0x3f, r0	; 63
    5418:	cd bf       	out	0x3d, r28	; 61
    541a:	68 2e       	mov	r6, r24
    541c:	67 96       	adiw	r28, 0x17	; 23
    541e:	7f af       	std	Y+63, r23	; 0x3f
    5420:	6e af       	std	Y+62, r22	; 0x3e
    5422:	67 97       	sbiw	r28, 0x17	; 23
    5424:	69 96       	adiw	r28, 0x19	; 25
    5426:	5f af       	std	Y+63, r21	; 0x3f
    5428:	4e af       	std	Y+62, r20	; 0x3e
    542a:	69 97       	sbiw	r28, 0x19	; 25
    542c:	59 01       	movw	r10, r18
    542e:	fe 01       	movw	r30, r28
    5430:	31 96       	adiw	r30, 0x01	; 1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    5432:	ce 01       	movw	r24, r28
    5434:	45 96       	adiw	r24, 0x15	; 21
	     strMemory[i]=data;
    5436:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    5438:	e8 17       	cp	r30, r24
    543a:	f9 07       	cpc	r31, r25
    543c:	e1 f7       	brne	.-8      	; 0x5436 <StrCalc+0x50>
	     strMemory[i]=data;
    543e:	ce 01       	movw	r24, r28
    5440:	89 96       	adiw	r24, 0x29	; 41
    5442:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    5444:	e8 17       	cp	r30, r24
    5446:	f9 07       	cpc	r31, r25
    5448:	e1 f7       	brne	.-8      	; 0x5442 <StrCalc+0x5c>
    544a:	fe 01       	movw	r30, r28
    544c:	fd 96       	adiw	r30, 0x3d	; 61
	     strMemory[i]=data;
    544e:	cf 01       	movw	r24, r30
    5450:	44 96       	adiw	r24, 0x14	; 20
    5452:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    5454:	e8 17       	cp	r30, r24
    5456:	f9 07       	cpc	r31, r25
    5458:	e1 f7       	brne	.-8      	; 0x5452 <StrCalc+0x6c>
	 FillChar(tmpB,sizeof(tmpB),0);
	 FillChar(Result,sizeof(Result),0);
                                            // -5    -5     5    5
	                                        // -6 -   6 -  -6 -  6 -
                                            // -5+6   
	 sprintf_P(tmpA,PSTR("%s"),strA);       // 
    545a:	00 d0       	rcall	.+0      	; 0x545c <StrCalc+0x76>
    545c:	00 d0       	rcall	.+0      	; 0x545e <StrCalc+0x78>
    545e:	00 d0       	rcall	.+0      	; 0x5460 <StrCalc+0x7a>
    5460:	ed b7       	in	r30, 0x3d	; 61
    5462:	fe b7       	in	r31, 0x3e	; 62
    5464:	31 96       	adiw	r30, 0x01	; 1
    5466:	8e 01       	movw	r16, r28
    5468:	0f 5f       	subi	r16, 0xFF	; 255
    546a:	1f 4f       	sbci	r17, 0xFF	; 255
    546c:	ad b7       	in	r26, 0x3d	; 61
    546e:	be b7       	in	r27, 0x3e	; 62
    5470:	12 96       	adiw	r26, 0x02	; 2
    5472:	1c 93       	st	X, r17
    5474:	0e 93       	st	-X, r16
    5476:	11 97       	sbiw	r26, 0x01	; 1
    5478:	88 eb       	ldi	r24, 0xB8	; 184
    547a:	95 e0       	ldi	r25, 0x05	; 5
    547c:	93 83       	std	Z+3, r25	; 0x03
    547e:	82 83       	std	Z+2, r24	; 0x02
    5480:	67 96       	adiw	r28, 0x17	; 23
    5482:	2e ad       	ldd	r18, Y+62	; 0x3e
    5484:	3f ad       	ldd	r19, Y+63	; 0x3f
    5486:	67 97       	sbiw	r28, 0x17	; 23
    5488:	35 83       	std	Z+5, r19	; 0x05
    548a:	24 83       	std	Z+4, r18	; 0x04
    548c:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
	 sprintf_P(tmpB,PSTR("%s"),strB);  
    5490:	ed b7       	in	r30, 0x3d	; 61
    5492:	fe b7       	in	r31, 0x3e	; 62
    5494:	31 96       	adiw	r30, 0x01	; 1
    5496:	ce 01       	movw	r24, r28
    5498:	45 96       	adiw	r24, 0x15	; 21
    549a:	ad b7       	in	r26, 0x3d	; 61
    549c:	be b7       	in	r27, 0x3e	; 62
    549e:	12 96       	adiw	r26, 0x02	; 2
    54a0:	9c 93       	st	X, r25
    54a2:	8e 93       	st	-X, r24
    54a4:	11 97       	sbiw	r26, 0x01	; 1
    54a6:	85 eb       	ldi	r24, 0xB5	; 181
    54a8:	95 e0       	ldi	r25, 0x05	; 5
    54aa:	93 83       	std	Z+3, r25	; 0x03
    54ac:	82 83       	std	Z+2, r24	; 0x02
    54ae:	69 96       	adiw	r28, 0x19	; 25
    54b0:	2e ad       	ldd	r18, Y+62	; 0x3e
    54b2:	3f ad       	ldd	r19, Y+63	; 0x3f
    54b4:	69 97       	sbiw	r28, 0x19	; 25
    54b6:	35 83       	std	Z+5, r19	; 0x05
    54b8:	24 83       	std	Z+4, r18	; 0x04
    54ba:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>

     if (IsMinus(tmpA)==True){
    54be:	8d b7       	in	r24, 0x3d	; 61
    54c0:	9e b7       	in	r25, 0x3e	; 62
    54c2:	06 96       	adiw	r24, 0x06	; 6
    54c4:	0f b6       	in	r0, 0x3f	; 63
    54c6:	f8 94       	cli
    54c8:	9e bf       	out	0x3e, r25	; 62
    54ca:	0f be       	out	0x3f, r0	; 63
    54cc:	8d bf       	out	0x3d, r24	; 61
    54ce:	c8 01       	movw	r24, r16
    54d0:	0e 94 ee 23 	call	0x47dc	; 0x47dc <IsMinus>
    54d4:	81 30       	cpi	r24, 0x01	; 1
    54d6:	21 f0       	breq	.+8      	; 0x54e0 <StrCalc+0xfa>
    54d8:	65 96       	adiw	r28, 0x15	; 21
    54da:	1f ae       	std	Y+63, r1	; 0x3f
    54dc:	65 97       	sbiw	r28, 0x15	; 21
    54de:	07 c0       	rjmp	.+14     	; 0x54ee <StrCalc+0x108>
	     RemoveMinus(tmpA);
    54e0:	c8 01       	movw	r24, r16
    54e2:	0e 94 f3 23 	call	0x47e6	; 0x47e6 <RemoveMinus>
    54e6:	91 e0       	ldi	r25, 0x01	; 1
    54e8:	65 96       	adiw	r28, 0x15	; 21
    54ea:	9f af       	std	Y+63, r25	; 0x3f
    54ec:	65 97       	sbiw	r28, 0x15	; 21
		 IsMinA=True;
	 }
     if (IsMinus(tmpB)==True){
    54ee:	8e 01       	movw	r16, r28
    54f0:	0b 5e       	subi	r16, 0xEB	; 235
    54f2:	1f 4f       	sbci	r17, 0xFF	; 255
    54f4:	c8 01       	movw	r24, r16
    54f6:	0e 94 ee 23 	call	0x47dc	; 0x47dc <IsMinus>
    54fa:	81 30       	cpi	r24, 0x01	; 1
    54fc:	21 f0       	breq	.+8      	; 0x5506 <StrCalc+0x120>
    54fe:	64 96       	adiw	r28, 0x14	; 20
    5500:	1f ae       	std	Y+63, r1	; 0x3f
    5502:	64 97       	sbiw	r28, 0x14	; 20
    5504:	07 c0       	rjmp	.+14     	; 0x5514 <StrCalc+0x12e>
	     RemoveMinus(tmpB);
    5506:	c8 01       	movw	r24, r16
    5508:	0e 94 f3 23 	call	0x47e6	; 0x47e6 <RemoveMinus>
    550c:	a1 e0       	ldi	r26, 0x01	; 1
    550e:	64 96       	adiw	r28, 0x14	; 20
    5510:	af af       	std	Y+63, r26	; 0x3f
    5512:	64 97       	sbiw	r28, 0x14	; 20
		 IsMinB=True;
	 }    	

     lenA=strlen(tmpA);
    5514:	fe 01       	movw	r30, r28
    5516:	31 96       	adiw	r30, 0x01	; 1
    5518:	df 01       	movw	r26, r30
    551a:	0d 90       	ld	r0, X+
    551c:	00 20       	and	r0, r0
    551e:	e9 f7       	brne	.-6      	; 0x551a <StrCalc+0x134>
    5520:	cd 01       	movw	r24, r26
    5522:	01 97       	sbiw	r24, 0x01	; 1
    5524:	8e 1b       	sub	r24, r30
    5526:	9f 0b       	sbc	r25, r31
     lenB=strlen(tmpB);
    5528:	de 01       	movw	r26, r28
    552a:	55 96       	adiw	r26, 0x15	; 21
    552c:	fd 01       	movw	r30, r26
    552e:	01 90       	ld	r0, Z+
    5530:	00 20       	and	r0, r0
    5532:	e9 f7       	brne	.-6      	; 0x552e <StrCalc+0x148>
    5534:	31 97       	sbiw	r30, 0x01	; 1
     /*
	 sprintf_P(strSend,PSTR("A:%s"),strA);	 _uart_print(0,1,strSend);
	 sprintf_P(strSend,PSTR("B:%s"),strB);	 _uart_print(0,1,strSend);
     */

     AddZeroLead(tmpA,FixLen+1);
    5536:	1e 2f       	mov	r17, r30
    5538:	1a 1b       	sub	r17, r26
    553a:	18 17       	cp	r17, r24
    553c:	08 f4       	brcc	.+2      	; 0x5540 <StrCalc+0x15a>
    553e:	18 2f       	mov	r17, r24
    5540:	1f 5f       	subi	r17, 0xFF	; 255
    5542:	7e 01       	movw	r14, r28
    5544:	08 94       	sec
    5546:	e1 1c       	adc	r14, r1
    5548:	f1 1c       	adc	r15, r1
    554a:	c7 01       	movw	r24, r14
    554c:	61 2f       	mov	r22, r17
    554e:	0e 94 37 27 	call	0x4e6e	; 0x4e6e <AddZeroLead>
     AddZeroLead(tmpB,FixLen+1);
    5552:	f5 e1       	ldi	r31, 0x15	; 21
    5554:	cf 2e       	mov	r12, r31
    5556:	d1 2c       	mov	r13, r1
    5558:	cc 0e       	add	r12, r28
    555a:	dd 1e       	adc	r13, r29
    555c:	c6 01       	movw	r24, r12
    555e:	61 2f       	mov	r22, r17
    5560:	0e 94 37 27 	call	0x4e6e	; 0x4e6e <AddZeroLead>
	 _uart_print(0,1,strSend);
	 sprintf_P(strSend,PSTR("B:%s"),strB);
	 _uart_print(0,1,strSend);
	 */

     lenA=strlen(tmpA);
    5564:	f7 01       	movw	r30, r14
    5566:	01 90       	ld	r0, Z+
    5568:	00 20       	and	r0, r0
    556a:	e9 f7       	brne	.-6      	; 0x5566 <StrCalc+0x180>
    556c:	31 97       	sbiw	r30, 0x01	; 1
    556e:	7e 2e       	mov	r7, r30
    5570:	7e 18       	sub	r7, r14
     lenB=strlen(tmpB);
    5572:	f6 01       	movw	r30, r12
    5574:	01 90       	ld	r0, Z+
    5576:	00 20       	and	r0, r0
    5578:	e9 f7       	brne	.-6      	; 0x5574 <StrCalc+0x18e>
    557a:	31 97       	sbiw	r30, 0x01	; 1
    557c:	9e 2e       	mov	r9, r30
    557e:	9c 18       	sub	r9, r12
     IsNegative=False;
	 
	 IsNegative=False;
	 IsSwap=False;

	 if (IsMoreThan(tmpB,tmpA)==True){
    5580:	c6 01       	movw	r24, r12
    5582:	b7 01       	movw	r22, r14
    5584:	0e 94 20 24 	call	0x4840	; 0x4840 <IsMoreThan>
    5588:	81 30       	cpi	r24, 0x01	; 1
    558a:	11 f0       	breq	.+4      	; 0x5590 <StrCalc+0x1aa>
    558c:	80 e0       	ldi	r24, 0x00	; 0
    558e:	42 c0       	rjmp	.+132    	; 0x5614 <StrCalc+0x22e>
	     IsSwap=True;
         sprintf_P(tmpC,PSTR("%s"),tmpA);
    5590:	00 d0       	rcall	.+0      	; 0x5592 <StrCalc+0x1ac>
    5592:	00 d0       	rcall	.+0      	; 0x5594 <StrCalc+0x1ae>
    5594:	00 d0       	rcall	.+0      	; 0x5596 <StrCalc+0x1b0>
    5596:	ed b7       	in	r30, 0x3d	; 61
    5598:	fe b7       	in	r31, 0x3e	; 62
    559a:	31 96       	adiw	r30, 0x01	; 1
    559c:	8e 01       	movw	r16, r28
    559e:	07 5d       	subi	r16, 0xD7	; 215
    55a0:	1f 4f       	sbci	r17, 0xFF	; 255
    55a2:	ad b7       	in	r26, 0x3d	; 61
    55a4:	be b7       	in	r27, 0x3e	; 62
    55a6:	12 96       	adiw	r26, 0x02	; 2
    55a8:	1c 93       	st	X, r17
    55aa:	0e 93       	st	-X, r16
    55ac:	11 97       	sbiw	r26, 0x01	; 1
    55ae:	82 eb       	ldi	r24, 0xB2	; 178
    55b0:	95 e0       	ldi	r25, 0x05	; 5
    55b2:	93 83       	std	Z+3, r25	; 0x03
    55b4:	82 83       	std	Z+2, r24	; 0x02
    55b6:	f5 82       	std	Z+5, r15	; 0x05
    55b8:	e4 82       	std	Z+4, r14	; 0x04
    55ba:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
		 sprintf_P(tmpA,PSTR("%s"),tmpB);
    55be:	ed b7       	in	r30, 0x3d	; 61
    55c0:	fe b7       	in	r31, 0x3e	; 62
    55c2:	31 96       	adiw	r30, 0x01	; 1
    55c4:	ad b7       	in	r26, 0x3d	; 61
    55c6:	be b7       	in	r27, 0x3e	; 62
    55c8:	12 96       	adiw	r26, 0x02	; 2
    55ca:	fc 92       	st	X, r15
    55cc:	ee 92       	st	-X, r14
    55ce:	11 97       	sbiw	r26, 0x01	; 1
    55d0:	8f ea       	ldi	r24, 0xAF	; 175
    55d2:	95 e0       	ldi	r25, 0x05	; 5
    55d4:	93 83       	std	Z+3, r25	; 0x03
    55d6:	82 83       	std	Z+2, r24	; 0x02
    55d8:	d5 82       	std	Z+5, r13	; 0x05
    55da:	c4 82       	std	Z+4, r12	; 0x04
    55dc:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
		 sprintf_P(tmpB,PSTR("%s"),tmpC);
    55e0:	ed b7       	in	r30, 0x3d	; 61
    55e2:	fe b7       	in	r31, 0x3e	; 62
    55e4:	31 96       	adiw	r30, 0x01	; 1
    55e6:	ad b7       	in	r26, 0x3d	; 61
    55e8:	be b7       	in	r27, 0x3e	; 62
    55ea:	12 96       	adiw	r26, 0x02	; 2
    55ec:	dc 92       	st	X, r13
    55ee:	ce 92       	st	-X, r12
    55f0:	11 97       	sbiw	r26, 0x01	; 1
    55f2:	8c ea       	ldi	r24, 0xAC	; 172
    55f4:	95 e0       	ldi	r25, 0x05	; 5
    55f6:	93 83       	std	Z+3, r25	; 0x03
    55f8:	82 83       	std	Z+2, r24	; 0x02
    55fa:	15 83       	std	Z+5, r17	; 0x05
    55fc:	04 83       	std	Z+4, r16	; 0x04
    55fe:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    5602:	81 e0       	ldi	r24, 0x01	; 1
    5604:	ed b7       	in	r30, 0x3d	; 61
    5606:	fe b7       	in	r31, 0x3e	; 62
    5608:	36 96       	adiw	r30, 0x06	; 6
    560a:	0f b6       	in	r0, 0x3f	; 63
    560c:	f8 94       	cli
    560e:	fe bf       	out	0x3e, r31	; 62
    5610:	0f be       	out	0x3f, r0	; 63
    5612:	ed bf       	out	0x3d, r30	; 61
	 }
    
	if (TOperation==TMINUS){
    5614:	66 20       	and	r6, r6
    5616:	39 f5       	brne	.+78     	; 0x5666 <StrCalc+0x280>
	    TCalc=TOperation;
		IsNegative=False;
		if (IsSwap==True){
    5618:	81 30       	cpi	r24, 0x01	; 1
    561a:	99 f4       	brne	.+38     	; 0x5642 <StrCalc+0x25c>
		    if ((IsMinA==True)&&(IsMinB==True)){IsNegative=False;TCalc=TMINUS;}
    561c:	65 96       	adiw	r28, 0x15	; 21
    561e:	ff ad       	ldd	r31, Y+63	; 0x3f
    5620:	65 97       	sbiw	r28, 0x15	; 21
    5622:	f1 30       	cpi	r31, 0x01	; 1
    5624:	39 f4       	brne	.+14     	; 0x5634 <StrCalc+0x24e>
    5626:	64 96       	adiw	r28, 0x14	; 20
    5628:	2f ad       	ldd	r18, Y+63	; 0x3f
    562a:	64 97       	sbiw	r28, 0x14	; 20
    562c:	21 30       	cpi	r18, 0x01	; 1
    562e:	09 f0       	breq	.+2      	; 0x5632 <StrCalc+0x24c>
    5630:	9e c1       	rjmp	.+828    	; 0x596e <StrCalc+0x588>
    5632:	42 c0       	rjmp	.+132    	; 0x56b8 <StrCalc+0x2d2>
            else if ((IsMinA==True)&&(IsMinB==False)){IsNegative=True;TCalc=TPLUS;}
            else if ((IsMinA==False)&&(IsMinB==True)){IsNegative=False;TCalc=TPLUS;}
    5634:	64 96       	adiw	r28, 0x14	; 20
    5636:	3f ad       	ldd	r19, Y+63	; 0x3f
    5638:	64 97       	sbiw	r28, 0x14	; 20
    563a:	31 30       	cpi	r19, 0x01	; 1
    563c:	09 f0       	breq	.+2      	; 0x5640 <StrCalc+0x25a>
    563e:	8e c1       	rjmp	.+796    	; 0x595c <StrCalc+0x576>
    5640:	92 c1       	rjmp	.+804    	; 0x5966 <StrCalc+0x580>
            else if ((IsMinA==False)&&(IsMinB==False)){IsNegative=True;TCalc=TMINUS;}
		}else
		if (IsSwap==False){
		    if ((IsMinA==True)&&(IsMinB==True)){IsNegative=True;TCalc=TMINUS;}
    5642:	65 96       	adiw	r28, 0x15	; 21
    5644:	8f ad       	ldd	r24, Y+63	; 0x3f
    5646:	65 97       	sbiw	r28, 0x15	; 21
    5648:	81 30       	cpi	r24, 0x01	; 1
    564a:	39 f4       	brne	.+14     	; 0x565a <StrCalc+0x274>
    564c:	64 96       	adiw	r28, 0x14	; 20
    564e:	9f ad       	ldd	r25, Y+63	; 0x3f
    5650:	64 97       	sbiw	r28, 0x14	; 20
    5652:	91 30       	cpi	r25, 0x01	; 1
    5654:	09 f0       	breq	.+2      	; 0x5658 <StrCalc+0x272>
    5656:	8b c1       	rjmp	.+790    	; 0x596e <StrCalc+0x588>
    5658:	81 c1       	rjmp	.+770    	; 0x595c <StrCalc+0x576>
            else if ((IsMinA==True)&&(IsMinB==False)){IsNegative=True;TCalc=TPLUS;}
            else if ((IsMinA==False)&&(IsMinB==True)){IsNegative=False;TCalc=TPLUS;}
    565a:	64 96       	adiw	r28, 0x14	; 20
    565c:	af ad       	ldd	r26, Y+63	; 0x3f
    565e:	64 97       	sbiw	r28, 0x14	; 20
    5660:	a1 30       	cpi	r26, 0x01	; 1
    5662:	51 f5       	brne	.+84     	; 0x56b8 <StrCalc+0x2d2>
    5664:	80 c1       	rjmp	.+768    	; 0x5966 <StrCalc+0x580>
            else if ((IsMinA==False)&&(IsMinB==False)){IsNegative=False;TCalc=TMINUS;}
		}
	 }else
	if (TOperation==TPLUS){
    5666:	b1 e0       	ldi	r27, 0x01	; 1
    5668:	6b 16       	cp	r6, r27
    566a:	31 f5       	brne	.+76     	; 0x56b8 <StrCalc+0x2d2>
	    TCalc=TOperation;
		IsNegative=False;
		if (IsSwap==True){
    566c:	81 30       	cpi	r24, 0x01	; 1
    566e:	91 f4       	brne	.+36     	; 0x5694 <StrCalc+0x2ae>
		    if ((IsMinA==True)&&(IsMinB==True)){IsNegative=True;TCalc=TPLUS;}
    5670:	65 96       	adiw	r28, 0x15	; 21
    5672:	ef ad       	ldd	r30, Y+63	; 0x3f
    5674:	65 97       	sbiw	r28, 0x15	; 21
    5676:	e1 30       	cpi	r30, 0x01	; 1
    5678:	31 f4       	brne	.+12     	; 0x5686 <StrCalc+0x2a0>
    567a:	64 96       	adiw	r28, 0x14	; 20
    567c:	ff ad       	ldd	r31, Y+63	; 0x3f
    567e:	64 97       	sbiw	r28, 0x14	; 20
    5680:	f1 30       	cpi	r31, 0x01	; 1
    5682:	d1 f4       	brne	.+52     	; 0x56b8 <StrCalc+0x2d2>
    5684:	74 c1       	rjmp	.+744    	; 0x596e <StrCalc+0x588>
            else if ((IsMinA==True)&&(IsMinB==False)){IsNegative=False;TCalc=TMINUS;}
            else if ((IsMinA==False)&&(IsMinB==True)){IsNegative=True;TCalc=TMINUS;}
    5686:	64 96       	adiw	r28, 0x14	; 20
    5688:	2f ad       	ldd	r18, Y+63	; 0x3f
    568a:	64 97       	sbiw	r28, 0x14	; 20
    568c:	21 30       	cpi	r18, 0x01	; 1
    568e:	09 f0       	breq	.+2      	; 0x5692 <StrCalc+0x2ac>
    5690:	6a c1       	rjmp	.+724    	; 0x5966 <StrCalc+0x580>
    5692:	64 c1       	rjmp	.+712    	; 0x595c <StrCalc+0x576>
            else if ((IsMinA==False)&&(IsMinB==False)){IsNegative=False;TCalc=TPLUS;}
		}else
		if (IsSwap==False){
		    if ((IsMinA==True)&&(IsMinB==True)){IsNegative=True;TCalc=TPLUS;}
    5694:	65 96       	adiw	r28, 0x15	; 21
    5696:	3f ad       	ldd	r19, Y+63	; 0x3f
    5698:	65 97       	sbiw	r28, 0x15	; 21
    569a:	31 30       	cpi	r19, 0x01	; 1
    569c:	39 f4       	brne	.+14     	; 0x56ac <StrCalc+0x2c6>
    569e:	64 96       	adiw	r28, 0x14	; 20
    56a0:	8f ad       	ldd	r24, Y+63	; 0x3f
    56a2:	64 97       	sbiw	r28, 0x14	; 20
    56a4:	81 30       	cpi	r24, 0x01	; 1
    56a6:	09 f0       	breq	.+2      	; 0x56aa <StrCalc+0x2c4>
    56a8:	59 c1       	rjmp	.+690    	; 0x595c <StrCalc+0x576>
    56aa:	61 c1       	rjmp	.+706    	; 0x596e <StrCalc+0x588>
            else if ((IsMinA==True)&&(IsMinB==False)){IsNegative=True;TCalc=TMINUS;}
            else if ((IsMinA==False)&&(IsMinB==True)){IsNegative=False;TCalc=TMINUS;}
    56ac:	64 96       	adiw	r28, 0x14	; 20
    56ae:	9f ad       	ldd	r25, Y+63	; 0x3f
    56b0:	64 97       	sbiw	r28, 0x14	; 20
    56b2:	91 30       	cpi	r25, 0x01	; 1
    56b4:	09 f0       	breq	.+2      	; 0x56b8 <StrCalc+0x2d2>
    56b6:	57 c1       	rjmp	.+686    	; 0x5966 <StrCalc+0x580>
   // A: 100000
   // B: 000001 -
   // -----------
   // C: 099999

	 if (TCalc==TMINUS){
    56b8:	62 96       	adiw	r28, 0x12	; 18
    56ba:	1f ae       	std	Y+63, r1	; 0x3f
    56bc:	62 97       	sbiw	r28, 0x12	; 18
     
	 //if (NinePos<Length-4)
	 StrCalc(TPLUS,strMaxValue,strOverflowed,strOverflowed);
}
                                                                   //     1111111 
void StrCalc(char TOperation, char *strA , char *strB, char *strC){//  A: 00000000
    56be:	e7 2c       	mov	r14, r7
    56c0:	ff 24       	eor	r15, r15
    56c2:	67 01       	movw	r12, r14
    56c4:	08 94       	sec
    56c6:	c1 08       	sbc	r12, r1
    56c8:	d1 08       	sbc	r13, r1
    56ca:	ae 01       	movw	r20, r28
    56cc:	43 5c       	subi	r20, 0xC3	; 195
    56ce:	5f 4f       	sbci	r21, 0xFF	; 255
    56d0:	4c 0d       	add	r20, r12
    56d2:	5d 1d       	adc	r21, r13
    56d4:	ce 01       	movw	r24, r28
    56d6:	01 96       	adiw	r24, 0x01	; 1
    56d8:	8c 01       	movw	r16, r24
    56da:	0c 0d       	add	r16, r12
    56dc:	1d 1d       	adc	r17, r13
    56de:	be 01       	movw	r22, r28
    56e0:	69 0d       	add	r22, r9
    56e2:	71 1d       	adc	r23, r1
    56e4:	6c 5e       	subi	r22, 0xEC	; 236
    56e6:	7f 4f       	sbci	r23, 0xFF	; 255
    56e8:	99 24       	eor	r9, r9
			     Result[lenA-i-1]=Chr(Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
			 }else
			 if (Ord(tmpA[lenA-i-1])<Ord(tmpB[lenB-i-1])){
			 //Pinjaman
			     for(j=i+1;j<lenA;j++){
				     if (tmpA[lenA-j-1]=='0')tmpA[lenA-j-1]='9';
    56ea:	2c 01       	movw	r4, r24
    56ec:	e9 e3       	ldi	r30, 0x39	; 57
    56ee:	8e 2e       	mov	r8, r30
					 if (tmpA[lenA-j-1]!='0'){
					     tmpA[lenA-j-1]=Chr(Ord(tmpA[lenA-j-1])-1);
						 break;
					 }				 
				 }
				 Result[lenA-i-1]=Chr(10+Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
    56f0:	9a e0       	ldi	r25, 0x0A	; 10
    56f2:	52 c0       	rjmp	.+164    	; 0x5798 <StrCalc+0x3b2>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    56f4:	d8 01       	movw	r26, r16
    56f6:	8c 91       	ld	r24, X
    56f8:	80 53       	subi	r24, 0x30	; 48
    56fa:	8a 30       	cpi	r24, 0x0A	; 10
    56fc:	10 f0       	brcs	.+4      	; 0x5702 <StrCalc+0x31c>
    56fe:	20 e0       	ldi	r18, 0x00	; 0
    5700:	01 c0       	rjmp	.+2      	; 0x5704 <StrCalc+0x31e>
    5702:	28 2f       	mov	r18, r24
   // -----------
   // C: 099999

	 if (TCalc==TMINUS){
	     for(i=0;i<lenA;i++){		 
		     if (Ord(tmpA[lenA-i-1])>=Ord(tmpB[lenB-i-1])){
    5704:	fb 01       	movw	r30, r22
    5706:	30 81       	ld	r19, Z
    5708:	30 53       	subi	r19, 0x30	; 48
    570a:	3a 30       	cpi	r19, 0x0A	; 10
    570c:	10 f4       	brcc	.+4      	; 0x5712 <StrCalc+0x32c>
    570e:	23 17       	cp	r18, r19
    5710:	40 f0       	brcs	.+16     	; 0x5722 <StrCalc+0x33c>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    5712:	8a 30       	cpi	r24, 0x0A	; 10
    5714:	08 f0       	brcs	.+2      	; 0x5718 <StrCalc+0x332>
    5716:	80 e0       	ldi	r24, 0x00	; 0

	 if (TCalc==TMINUS){
	     for(i=0;i<lenA;i++){		 
		     if (Ord(tmpA[lenA-i-1])>=Ord(tmpB[lenB-i-1])){
			 //Cukup
			     Result[lenA-i-1]=Chr(Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
    5718:	3a 30       	cpi	r19, 0x0A	; 10
    571a:	08 f0       	brcs	.+2      	; 0x571e <StrCalc+0x338>
    571c:	30 e0       	ldi	r19, 0x00	; 0
    571e:	83 1b       	sub	r24, r19
    5720:	2d c0       	rjmp	.+90     	; 0x577c <StrCalc+0x396>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    5722:	8a 30       	cpi	r24, 0x0A	; 10
    5724:	10 f4       	brcc	.+4      	; 0x572a <StrCalc+0x344>
	     for(i=0;i<lenA;i++){		 
		     if (Ord(tmpA[lenA-i-1])>=Ord(tmpB[lenB-i-1])){
			 //Cukup
			     Result[lenA-i-1]=Chr(Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
			 }else
			 if (Ord(tmpA[lenA-i-1])<Ord(tmpB[lenB-i-1])){
    5726:	83 17       	cp	r24, r19
    5728:	80 f5       	brcc	.+96     	; 0x578a <StrCalc+0x3a4>
    572a:	29 2d       	mov	r18, r9
    572c:	0a c0       	rjmp	.+20     	; 0x5742 <StrCalc+0x35c>
			 //Pinjaman
			     for(j=i+1;j<lenA;j++){
				     if (tmpA[lenA-j-1]=='0')tmpA[lenA-j-1]='9';
    572e:	f6 01       	movw	r30, r12
    5730:	e2 1b       	sub	r30, r18
    5732:	f1 09       	sbc	r31, r1
    5734:	d2 01       	movw	r26, r4
    5736:	ae 0f       	add	r26, r30
    5738:	bf 1f       	adc	r27, r31
    573a:	8c 91       	ld	r24, X
    573c:	80 33       	cpi	r24, 0x30	; 48
    573e:	29 f4       	brne	.+10     	; 0x574a <StrCalc+0x364>
    5740:	8c 92       	st	X, r8
			 //Cukup
			     Result[lenA-i-1]=Chr(Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
			 }else
			 if (Ord(tmpA[lenA-i-1])<Ord(tmpB[lenB-i-1])){
			 //Pinjaman
			     for(j=i+1;j<lenA;j++){
    5742:	2f 5f       	subi	r18, 0xFF	; 255
    5744:	27 15       	cp	r18, r7
    5746:	98 f3       	brcs	.-26     	; 0x572e <StrCalc+0x348>
    5748:	10 c0       	rjmp	.+32     	; 0x576a <StrCalc+0x384>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    574a:	28 2f       	mov	r18, r24
    574c:	20 53       	subi	r18, 0x30	; 48
    574e:	2a 30       	cpi	r18, 0x0A	; 10
    5750:	08 f0       	brcs	.+2      	; 0x5754 <StrCalc+0x36e>
    5752:	20 e0       	ldi	r18, 0x00	; 0
			 //Pinjaman
			     for(j=i+1;j<lenA;j++){
				     if (tmpA[lenA-j-1]=='0')tmpA[lenA-j-1]='9';
					 else
					 if (tmpA[lenA-j-1]!='0'){
					     tmpA[lenA-j-1]=Chr(Ord(tmpA[lenA-j-1])-1);
    5754:	82 2f       	mov	r24, r18
    5756:	81 50       	subi	r24, 0x01	; 1
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    5758:	8a 30       	cpi	r24, 0x0A	; 10
    575a:	10 f0       	brcs	.+4      	; 0x5760 <StrCalc+0x37a>
    575c:	80 e3       	ldi	r24, 0x30	; 48
    575e:	02 c0       	rjmp	.+4      	; 0x5764 <StrCalc+0x37e>
	    Result='0'+X;
    5760:	82 2f       	mov	r24, r18
    5762:	81 5d       	subi	r24, 0xD1	; 209
			 //Pinjaman
			     for(j=i+1;j<lenA;j++){
				     if (tmpA[lenA-j-1]=='0')tmpA[lenA-j-1]='9';
					 else
					 if (tmpA[lenA-j-1]!='0'){
					     tmpA[lenA-j-1]=Chr(Ord(tmpA[lenA-j-1])-1);
    5764:	e4 0d       	add	r30, r4
    5766:	f5 1d       	adc	r31, r5
    5768:	80 83       	st	Z, r24
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    576a:	f8 01       	movw	r30, r16
    576c:	20 81       	ld	r18, Z
    576e:	20 53       	subi	r18, 0x30	; 48
    5770:	2a 30       	cpi	r18, 0x0A	; 10
    5772:	08 f0       	brcs	.+2      	; 0x5776 <StrCalc+0x390>
    5774:	20 e0       	ldi	r18, 0x00	; 0
					 if (tmpA[lenA-j-1]!='0'){
					     tmpA[lenA-j-1]=Chr(Ord(tmpA[lenA-j-1])-1);
						 break;
					 }				 
				 }
				 Result[lenA-i-1]=Chr(10+Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
    5776:	89 2f       	mov	r24, r25
    5778:	83 1b       	sub	r24, r19
    577a:	82 0f       	add	r24, r18
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    577c:	8a 30       	cpi	r24, 0x0A	; 10
    577e:	10 f0       	brcs	.+4      	; 0x5784 <StrCalc+0x39e>
    5780:	80 e3       	ldi	r24, 0x30	; 48
    5782:	01 c0       	rjmp	.+2      	; 0x5786 <StrCalc+0x3a0>
	    Result='0'+X;
    5784:	80 5d       	subi	r24, 0xD0	; 208
					 if (tmpA[lenA-j-1]!='0'){
					     tmpA[lenA-j-1]=Chr(Ord(tmpA[lenA-j-1])-1);
						 break;
					 }				 
				 }
				 Result[lenA-i-1]=Chr(10+Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
    5786:	da 01       	movw	r26, r20
    5788:	8c 93       	st	X, r24
   // B: 000001 -
   // -----------
   // C: 099999

	 if (TCalc==TMINUS){
	     for(i=0;i<lenA;i++){		 
    578a:	93 94       	inc	r9
    578c:	41 50       	subi	r20, 0x01	; 1
    578e:	50 40       	sbci	r21, 0x00	; 0
    5790:	01 50       	subi	r16, 0x01	; 1
    5792:	10 40       	sbci	r17, 0x00	; 0
    5794:	61 50       	subi	r22, 0x01	; 1
    5796:	70 40       	sbci	r23, 0x00	; 0
    5798:	97 14       	cp	r9, r7
    579a:	08 f4       	brcc	.+2      	; 0x579e <StrCalc+0x3b8>
    579c:	ab cf       	rjmp	.-170    	; 0x56f4 <StrCalc+0x30e>
						 break;
					 }				 
				 }
				 Result[lenA-i-1]=Chr(10+Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
			 }
		 }Result[lenA]=0;		    
    579e:	8e 01       	movw	r16, r28
    57a0:	03 5c       	subi	r16, 0xC3	; 195
    57a2:	1f 4f       	sbci	r17, 0xFF	; 255
    57a4:	e0 0e       	add	r14, r16
    57a6:	f1 1e       	adc	r15, r17
    57a8:	f7 01       	movw	r30, r14
    57aa:	10 82       	st	Z, r1
       RemZeroLead(Result);
    57ac:	c8 01       	movw	r24, r16
    57ae:	0e 94 b9 25 	call	0x4b72	; 0x4b72 <RemZeroLead>
//	 sprintf_P(strSend,PSTR("C':%s"),Result);
//	 _uart_print(0,1,strSend);
		 
		 FixLen=strlen(Result);
    57b2:	f8 01       	movw	r30, r16
    57b4:	01 90       	ld	r0, Z+
    57b6:	00 20       	and	r0, r0
    57b8:	e9 f7       	brne	.-6      	; 0x57b4 <StrCalc+0x3ce>
    57ba:	31 97       	sbiw	r30, 0x01	; 1
    57bc:	3e 2f       	mov	r19, r30
    57be:	30 1b       	sub	r19, r16
    57c0:	d8 01       	movw	r26, r16
    57c2:	20 e0       	ldi	r18, 0x00	; 0
    57c4:	90 e0       	ldi	r25, 0x00	; 0
		 iPos=0;
		 for(i=0;i<FixLen;i++){
		     if ((i==0)&&(IsNegative==True)){
			     strC[iPos]='-';
    57c6:	4d e2       	ldi	r20, 0x2D	; 45
    57c8:	13 c0       	rjmp	.+38     	; 0x57f0 <StrCalc+0x40a>
//	 _uart_print(0,1,strSend);
		 
		 FixLen=strlen(Result);
		 iPos=0;
		 for(i=0;i<FixLen;i++){
		     if ((i==0)&&(IsNegative==True)){
    57ca:	22 23       	and	r18, r18
    57cc:	51 f4       	brne	.+20     	; 0x57e2 <StrCalc+0x3fc>
    57ce:	62 96       	adiw	r28, 0x12	; 18
    57d0:	ff ad       	ldd	r31, Y+63	; 0x3f
    57d2:	62 97       	sbiw	r28, 0x12	; 18
    57d4:	f1 30       	cpi	r31, 0x01	; 1
    57d6:	29 f4       	brne	.+10     	; 0x57e2 <StrCalc+0x3fc>
			     strC[iPos]='-';
    57d8:	f5 01       	movw	r30, r10
    57da:	e9 0f       	add	r30, r25
    57dc:	f1 1d       	adc	r31, r1
    57de:	40 83       	st	Z, r20
				 iPos++;
    57e0:	9f 5f       	subi	r25, 0xFF	; 255
			 }
		     strC[iPos]=Result[i];
    57e2:	f5 01       	movw	r30, r10
    57e4:	e9 0f       	add	r30, r25
    57e6:	f1 1d       	adc	r31, r1
    57e8:	8d 91       	ld	r24, X+
    57ea:	80 83       	st	Z, r24
			 iPos++;
    57ec:	9f 5f       	subi	r25, 0xFF	; 255
//	 sprintf_P(strSend,PSTR("C':%s"),Result);
//	 _uart_print(0,1,strSend);
		 
		 FixLen=strlen(Result);
		 iPos=0;
		 for(i=0;i<FixLen;i++){
    57ee:	2f 5f       	subi	r18, 0xFF	; 255
    57f0:	23 17       	cp	r18, r19
    57f2:	58 f3       	brcs	.-42     	; 0x57ca <StrCalc+0x3e4>
			     strC[iPos]='-';
				 iPos++;
			 }
		     strC[iPos]=Result[i];
			 iPos++;
		 }strC[iPos]=0;
    57f4:	f5 01       	movw	r30, r10
    57f6:	e9 0f       	add	r30, r25
    57f8:	f1 1d       	adc	r31, r1
    57fa:	10 82       	st	Z, r1
    57fc:	a0 c0       	rjmp	.+320    	; 0x593e <StrCalc+0x558>
	 }
	 else                     //         1
	 if (TCalc==TPLUS){  //A:099999999
    57fe:	7d e3       	ldi	r23, 0x3D	; 61
    5800:	e7 2e       	mov	r14, r23
    5802:	f1 2c       	mov	r15, r1
    5804:	ec 0e       	add	r14, r28
    5806:	fd 1e       	adc	r15, r29
    5808:	ae 01       	movw	r20, r28
    580a:	49 0d       	add	r20, r9
    580c:	51 1d       	adc	r21, r1
    580e:	4c 5e       	subi	r20, 0xEC	; 236
    5810:	5f 4f       	sbci	r21, 0xFF	; 255
     
	 //if (NinePos<Length-4)
	 StrCalc(TPLUS,strMaxValue,strOverflowed,strOverflowed);
}
                                                                   //     1111111 
void StrCalc(char TOperation, char *strA , char *strB, char *strC){//  A: 00000000
    5812:	07 2d       	mov	r16, r7
    5814:	10 e0       	ldi	r17, 0x00	; 0
    5816:	48 01       	movw	r8, r16
    5818:	08 94       	sec
    581a:	81 08       	sbc	r8, r1
    581c:	91 08       	sbc	r9, r1
    581e:	ce 01       	movw	r24, r28
    5820:	01 96       	adiw	r24, 0x01	; 1
    5822:	6c 01       	movw	r12, r24
    5824:	c8 0c       	add	r12, r8
    5826:	d9 1c       	adc	r13, r9
    5828:	30 e0       	ldi	r19, 0x00	; 0
    582a:	20 e0       	ldi	r18, 0x00	; 0
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    582c:	2c 01       	movw	r4, r24
                 //Lebih
				 Result[i]=Chr(newC%10);
				 zMin=newC/10;
			     for(j=i+1;j<lenA;j++){
				     if ((Ord(tmpA[lenA-j-1])+zMin)>=10){
					     tmpA[lenA-j-1]=Chr((Ord(tmpA[lenA-j-1])+zMin)%10);
    582e:	60 e3       	ldi	r22, 0x30	; 48
    5830:	36 2e       	mov	r3, r22
    5832:	47 c0       	rjmp	.+142    	; 0x58c2 <StrCalc+0x4dc>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    5834:	d6 01       	movw	r26, r12
    5836:	9c 91       	ld	r25, X
    5838:	90 53       	subi	r25, 0x30	; 48
    583a:	9a 30       	cpi	r25, 0x0A	; 10
    583c:	08 f0       	brcs	.+2      	; 0x5840 <StrCalc+0x45a>
    583e:	90 e0       	ldi	r25, 0x00	; 0
	 }
	 else                     //         1
	 if (TCalc==TPLUS){  //A:099999999
	     zMin=0;              //B:000000001
	     for(i=0;i<lenA;i++){ //C:       00
		     newC=(Ord(tmpA[lenA-i-1])+Ord(tmpB[lenB-i-1]));			 
    5840:	fa 01       	movw	r30, r20
    5842:	80 81       	ld	r24, Z
    5844:	80 53       	subi	r24, 0x30	; 48
    5846:	8a 30       	cpi	r24, 0x0A	; 10
    5848:	08 f0       	brcs	.+2      	; 0x584c <StrCalc+0x466>
    584a:	80 e0       	ldi	r24, 0x00	; 0
    584c:	89 0f       	add	r24, r25
			 if (newC<10){
    584e:	8a 30       	cpi	r24, 0x0A	; 10
    5850:	18 f4       	brcc	.+6      	; 0x5858 <StrCalc+0x472>
			     Result[i]=Chr(newC);
    5852:	80 5d       	subi	r24, 0xD0	; 208
    5854:	d7 01       	movw	r26, r14
    5856:	28 c0       	rjmp	.+80     	; 0x58a8 <StrCalc+0x4c2>
				 zMin=newC/10;
			 }else if (newC>=10){
                 //Lebih
				 Result[i]=Chr(newC%10);
    5858:	6a e0       	ldi	r22, 0x0A	; 10
    585a:	0e 94 7a b8 	call	0x170f4	; 0x170f4 <__udivmodqi4>
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    585e:	9a 30       	cpi	r25, 0x0A	; 10
    5860:	10 f0       	brcs	.+4      	; 0x5866 <StrCalc+0x480>
    5862:	90 e3       	ldi	r25, 0x30	; 48
    5864:	01 c0       	rjmp	.+2      	; 0x5868 <StrCalc+0x482>
	    Result='0'+X;
    5866:	90 5d       	subi	r25, 0xD0	; 208
			 if (newC<10){
			     Result[i]=Chr(newC);
				 zMin=newC/10;
			 }else if (newC>=10){
                 //Lebih
				 Result[i]=Chr(newC%10);
    5868:	f7 01       	movw	r30, r14
    586a:	90 83       	st	Z, r25
    586c:	83 2f       	mov	r24, r19
    586e:	0e c0       	rjmp	.+28     	; 0x588c <StrCalc+0x4a6>
				 zMin=newC/10;
			     for(j=i+1;j<lenA;j++){
				     if ((Ord(tmpA[lenA-j-1])+zMin)>=10){
    5870:	d4 01       	movw	r26, r8
    5872:	a8 1b       	sub	r26, r24
    5874:	b1 09       	sbc	r27, r1
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    5876:	f2 01       	movw	r30, r4
    5878:	ea 0f       	add	r30, r26
    587a:	fb 1f       	adc	r31, r27
    587c:	90 81       	ld	r25, Z
    587e:	90 53       	subi	r25, 0x30	; 48
    5880:	9a 30       	cpi	r25, 0x0A	; 10
    5882:	08 f0       	brcs	.+2      	; 0x5886 <StrCalc+0x4a0>
    5884:	79 c0       	rjmp	.+242    	; 0x5978 <StrCalc+0x592>
			 }else if (newC>=10){
                 //Lebih
				 Result[i]=Chr(newC%10);
				 zMin=newC/10;
			     for(j=i+1;j<lenA;j++){
				     if ((Ord(tmpA[lenA-j-1])+zMin)>=10){
    5886:	99 30       	cpi	r25, 0x09	; 9
    5888:	29 f4       	brne	.+10     	; 0x5894 <StrCalc+0x4ae>
					     tmpA[lenA-j-1]=Chr((Ord(tmpA[lenA-j-1])+zMin)%10);
    588a:	30 82       	st	Z, r3
				 zMin=newC/10;
			 }else if (newC>=10){
                 //Lebih
				 Result[i]=Chr(newC%10);
				 zMin=newC/10;
			     for(j=i+1;j<lenA;j++){
    588c:	8f 5f       	subi	r24, 0xFF	; 255
    588e:	87 15       	cp	r24, r7
    5890:	78 f3       	brcs	.-34     	; 0x5870 <StrCalc+0x48a>
    5892:	0d c0       	rjmp	.+26     	; 0x58ae <StrCalc+0x4c8>
				     if ((Ord(tmpA[lenA-j-1])+zMin)>=10){
					     tmpA[lenA-j-1]=Chr((Ord(tmpA[lenA-j-1])+zMin)%10);
						 zMin=1;
					 }else{
					     tmpA[lenA-j-1]=Chr((Ord(tmpA[lenA-j-1])+zMin));
    5894:	89 2f       	mov	r24, r25
    5896:	8f 5f       	subi	r24, 0xFF	; 255
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    5898:	8a 30       	cpi	r24, 0x0A	; 10
    589a:	10 f0       	brcs	.+4      	; 0x58a0 <StrCalc+0x4ba>
    589c:	80 e3       	ldi	r24, 0x30	; 48
    589e:	02 c0       	rjmp	.+4      	; 0x58a4 <StrCalc+0x4be>
	    Result='0'+X;
    58a0:	89 2f       	mov	r24, r25
    58a2:	8f 5c       	subi	r24, 0xCF	; 207
			     for(j=i+1;j<lenA;j++){
				     if ((Ord(tmpA[lenA-j-1])+zMin)>=10){
					     tmpA[lenA-j-1]=Chr((Ord(tmpA[lenA-j-1])+zMin)%10);
						 zMin=1;
					 }else{
					     tmpA[lenA-j-1]=Chr((Ord(tmpA[lenA-j-1])+zMin));
    58a4:	a4 0d       	add	r26, r4
    58a6:	b5 1d       	adc	r27, r5
    58a8:	8c 93       	st	X, r24
    58aa:	20 e0       	ldi	r18, 0x00	; 0
    58ac:	01 c0       	rjmp	.+2      	; 0x58b0 <StrCalc+0x4ca>
				 zMin=newC/10;
			 }else if (newC>=10){
                 //Lebih
				 Result[i]=Chr(newC%10);
				 zMin=newC/10;
			     for(j=i+1;j<lenA;j++){
    58ae:	21 e0       	ldi	r18, 0x01	; 1
		 }strC[iPos]=0;
	 }
	 else                     //         1
	 if (TCalc==TPLUS){  //A:099999999
	     zMin=0;              //B:000000001
	     for(i=0;i<lenA;i++){ //C:       00
    58b0:	3f 5f       	subi	r19, 0xFF	; 255
    58b2:	08 94       	sec
    58b4:	e1 1c       	adc	r14, r1
    58b6:	f1 1c       	adc	r15, r1
    58b8:	41 50       	subi	r20, 0x01	; 1
    58ba:	50 40       	sbci	r21, 0x00	; 0
    58bc:	08 94       	sec
    58be:	c1 08       	sbc	r12, r1
    58c0:	d1 08       	sbc	r13, r1
    58c2:	37 15       	cp	r19, r7
    58c4:	08 f4       	brcc	.+2      	; 0x58c8 <StrCalc+0x4e2>
    58c6:	b6 cf       	rjmp	.-148    	; 0x5834 <StrCalc+0x44e>
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
	    Result='0'+X;
    58c8:	20 5d       	subi	r18, 0xD0	; 208
				 }//EndFor j                
			   }//End else
			 }//EndFor

		  //Result[lenA]==Chr(zMin); ???
		  Result[lenA]=Chr(zMin);
    58ca:	de 01       	movw	r26, r28
    58cc:	dd 96       	adiw	r26, 0x3d	; 61
    58ce:	fd 01       	movw	r30, r26
    58d0:	e0 0f       	add	r30, r16
    58d2:	f1 1f       	adc	r31, r17
    58d4:	20 83       	st	Z, r18
		  Result[lenA+1]=0;
    58d6:	0c 0f       	add	r16, r28
    58d8:	1d 1f       	adc	r17, r29
    58da:	f8 01       	movw	r30, r16
    58dc:	16 ae       	std	Z+62, r1	; 0x3e
		 FixLen=strlen(Result);
		 for(i=0;i<FixLen;i++){
		     strC[i]=Result[FixLen-i-1];
		 }strC[FixLen]=0;
*/
         FixLen=strlen(Result);
    58de:	fd 01       	movw	r30, r26
    58e0:	01 90       	ld	r0, Z+
    58e2:	00 20       	and	r0, r0
    58e4:	e9 f7       	brne	.-6      	; 0x58e0 <StrCalc+0x4fa>
    58e6:	31 97       	sbiw	r30, 0x01	; 1
    58e8:	5e 2f       	mov	r21, r30
    58ea:	5a 1b       	sub	r21, r26
    58ec:	25 2f       	mov	r18, r21
    58ee:	30 e0       	ldi	r19, 0x00	; 0
    58f0:	21 50       	subi	r18, 0x01	; 1
    58f2:	30 40       	sbci	r19, 0x00	; 0
    58f4:	2a 0f       	add	r18, r26
    58f6:	3b 1f       	adc	r19, r27
    58f8:	40 e0       	ldi	r20, 0x00	; 0
    58fa:	90 e0       	ldi	r25, 0x00	; 0
		 iPos=0;
		 for(i=0;i<FixLen;i++){
		     if ((i==0)&&(IsNegative==True)){
			     strC[iPos]='-';
    58fc:	6d e2       	ldi	r22, 0x2D	; 45
    58fe:	16 c0       	rjmp	.+44     	; 0x592c <StrCalc+0x546>
		 }strC[FixLen]=0;
*/
         FixLen=strlen(Result);
		 iPos=0;
		 for(i=0;i<FixLen;i++){
		     if ((i==0)&&(IsNegative==True)){
    5900:	44 23       	and	r20, r20
    5902:	51 f4       	brne	.+20     	; 0x5918 <StrCalc+0x532>
    5904:	63 96       	adiw	r28, 0x13	; 19
    5906:	ff ad       	ldd	r31, Y+63	; 0x3f
    5908:	63 97       	sbiw	r28, 0x13	; 19
    590a:	f1 30       	cpi	r31, 0x01	; 1
    590c:	29 f4       	brne	.+10     	; 0x5918 <StrCalc+0x532>
			     strC[iPos]='-';
    590e:	f5 01       	movw	r30, r10
    5910:	e9 0f       	add	r30, r25
    5912:	f1 1d       	adc	r31, r1
    5914:	60 83       	st	Z, r22
				 iPos++;
    5916:	9f 5f       	subi	r25, 0xFF	; 255
			 }
		     strC[iPos]=Result[FixLen-i-1];
    5918:	f5 01       	movw	r30, r10
    591a:	e9 0f       	add	r30, r25
    591c:	f1 1d       	adc	r31, r1
    591e:	d9 01       	movw	r26, r18
    5920:	8c 91       	ld	r24, X
    5922:	80 83       	st	Z, r24
			 iPos++;
    5924:	9f 5f       	subi	r25, 0xFF	; 255
		     strC[i]=Result[FixLen-i-1];
		 }strC[FixLen]=0;
*/
         FixLen=strlen(Result);
		 iPos=0;
		 for(i=0;i<FixLen;i++){
    5926:	4f 5f       	subi	r20, 0xFF	; 255
    5928:	21 50       	subi	r18, 0x01	; 1
    592a:	30 40       	sbci	r19, 0x00	; 0
    592c:	45 17       	cp	r20, r21
    592e:	40 f3       	brcs	.-48     	; 0x5900 <StrCalc+0x51a>
			     strC[iPos]='-';
				 iPos++;
			 }
		     strC[iPos]=Result[FixLen-i-1];
			 iPos++;
		 }strC[iPos]=0;
    5930:	f5 01       	movw	r30, r10
    5932:	e9 0f       	add	r30, r25
    5934:	f1 1d       	adc	r31, r1
    5936:	10 82       	st	Z, r1

       RemZeroLead(strC);
    5938:	c5 01       	movw	r24, r10
    593a:	0e 94 b9 25 	call	0x4b72	; 0x4b72 <RemZeroLead>
  //    sprintf_P(strSend,PSTR("C':%s"),strC);
//	 _uart_print(0,1,strSend);

	 }//EndIf 

	 if (TOperation==TMULTIPLY){
    593e:	b2 e0       	ldi	r27, 0x02	; 2
    5940:	6b 16       	cp	r6, r27
    5942:	e1 f4       	brne	.+56     	; 0x597c <StrCalc+0x596>
		 valA=atol(strA);
		 valB=atol(strB);
		 valC=valA*valB;		 
         ltoa(valC,strC,10);
		 */
		 CalcMultiply(strA,strB,strC);
    5944:	67 96       	adiw	r28, 0x17	; 23
    5946:	8e ad       	ldd	r24, Y+62	; 0x3e
    5948:	9f ad       	ldd	r25, Y+63	; 0x3f
    594a:	67 97       	sbiw	r28, 0x17	; 23
    594c:	69 96       	adiw	r28, 0x19	; 25
    594e:	6e ad       	ldd	r22, Y+62	; 0x3e
    5950:	7f ad       	ldd	r23, Y+63	; 0x3f
    5952:	69 97       	sbiw	r28, 0x19	; 25
    5954:	a5 01       	movw	r20, r10
    5956:	0e 94 d7 2c 	call	0x59ae	; 0x59ae <CalcMultiply>
    595a:	10 c0       	rjmp	.+32     	; 0x597c <StrCalc+0x596>
	 }
}
    595c:	e1 e0       	ldi	r30, 0x01	; 1
    595e:	62 96       	adiw	r28, 0x12	; 18
    5960:	ef af       	std	Y+63, r30	; 0x3f
    5962:	62 97       	sbiw	r28, 0x12	; 18
    5964:	ac ce       	rjmp	.-680    	; 0x56be <StrCalc+0x2d8>
    5966:	63 96       	adiw	r28, 0x13	; 19
    5968:	1f ae       	std	Y+63, r1	; 0x3f
    596a:	63 97       	sbiw	r28, 0x13	; 19
    596c:	48 cf       	rjmp	.-368    	; 0x57fe <StrCalc+0x418>
    596e:	f1 e0       	ldi	r31, 0x01	; 1
    5970:	63 96       	adiw	r28, 0x13	; 19
    5972:	ff af       	std	Y+63, r31	; 0x3f
    5974:	63 97       	sbiw	r28, 0x13	; 19
    5976:	43 cf       	rjmp	.-378    	; 0x57fe <StrCalc+0x418>
    5978:	90 e0       	ldi	r25, 0x00	; 0
    597a:	8c cf       	rjmp	.-232    	; 0x5894 <StrCalc+0x4ae>
    597c:	c8 5a       	subi	r28, 0xA8	; 168
    597e:	df 4f       	sbci	r29, 0xFF	; 255
    5980:	0f b6       	in	r0, 0x3f	; 63
    5982:	f8 94       	cli
    5984:	de bf       	out	0x3e, r29	; 62
    5986:	0f be       	out	0x3f, r0	; 63
    5988:	cd bf       	out	0x3d, r28	; 61
    598a:	cf 91       	pop	r28
    598c:	df 91       	pop	r29
    598e:	1f 91       	pop	r17
    5990:	0f 91       	pop	r16
    5992:	ff 90       	pop	r15
    5994:	ef 90       	pop	r14
    5996:	df 90       	pop	r13
    5998:	cf 90       	pop	r12
    599a:	bf 90       	pop	r11
    599c:	af 90       	pop	r10
    599e:	9f 90       	pop	r9
    59a0:	8f 90       	pop	r8
    59a2:	7f 90       	pop	r7
    59a4:	6f 90       	pop	r6
    59a6:	5f 90       	pop	r5
    59a8:	4f 90       	pop	r4
    59aa:	3f 90       	pop	r3
    59ac:	08 95       	ret

000059ae <CalcMultiply>:
	 }
	 strResult[lenR]=0;
}


void CalcMultiply(char *strA,char *strB,char *strC){
    59ae:	4f 92       	push	r4
    59b0:	5f 92       	push	r5
    59b2:	6f 92       	push	r6
    59b4:	7f 92       	push	r7
    59b6:	8f 92       	push	r8
    59b8:	9f 92       	push	r9
    59ba:	af 92       	push	r10
    59bc:	bf 92       	push	r11
    59be:	cf 92       	push	r12
    59c0:	df 92       	push	r13
    59c2:	ef 92       	push	r14
    59c4:	ff 92       	push	r15
    59c6:	0f 93       	push	r16
    59c8:	1f 93       	push	r17
    59ca:	df 93       	push	r29
    59cc:	cf 93       	push	r28
    59ce:	cd b7       	in	r28, 0x3d	; 61
    59d0:	de b7       	in	r29, 0x3e	; 62
    59d2:	a8 97       	sbiw	r28, 0x28	; 40
    59d4:	0f b6       	in	r0, 0x3f	; 63
    59d6:	f8 94       	cli
    59d8:	de bf       	out	0x3e, r29	; 62
    59da:	0f be       	out	0x3f, r0	; 63
    59dc:	cd bf       	out	0x3d, r28	; 61
    59de:	3c 01       	movw	r6, r24
    59e0:	6b 01       	movw	r12, r22
    59e2:	2a 01       	movw	r4, r20
	 
	 */
	 char i,lenB;
	 char prevSeg[20],currSeg[20];

     RemZeroLead(strA);
    59e4:	0e 94 b9 25 	call	0x4b72	; 0x4b72 <RemZeroLead>
     RemZeroLead(strB);
    59e8:	c6 01       	movw	r24, r12
    59ea:	0e 94 b9 25 	call	0x4b72	; 0x4b72 <RemZeroLead>
	 lenB=strlen(strB);
    59ee:	d6 01       	movw	r26, r12
    59f0:	0d 90       	ld	r0, X+
    59f2:	00 20       	and	r0, r0
    59f4:	e9 f7       	brne	.-6      	; 0x59f0 <CalcMultiply+0x42>
    59f6:	11 97       	sbiw	r26, 0x01	; 1
    59f8:	8a 2e       	mov	r8, r26
    59fa:	8c 18       	sub	r8, r12
	 sprintf_P(prevSeg,PSTR("0"));
    59fc:	00 d0       	rcall	.+0      	; 0x59fe <CalcMultiply+0x50>
    59fe:	00 d0       	rcall	.+0      	; 0x5a00 <CalcMultiply+0x52>
    5a00:	8e 01       	movw	r16, r28
    5a02:	0f 5f       	subi	r16, 0xFF	; 255
    5a04:	1f 4f       	sbci	r17, 0xFF	; 255
    5a06:	ad b7       	in	r26, 0x3d	; 61
    5a08:	be b7       	in	r27, 0x3e	; 62
    5a0a:	12 96       	adiw	r26, 0x02	; 2
    5a0c:	1c 93       	st	X, r17
    5a0e:	0e 93       	st	-X, r16
    5a10:	11 97       	sbiw	r26, 0x01	; 1
    5a12:	8a ea       	ldi	r24, 0xAA	; 170
    5a14:	95 e0       	ldi	r25, 0x05	; 5
    5a16:	14 96       	adiw	r26, 0x04	; 4
    5a18:	9c 93       	st	X, r25
    5a1a:	8e 93       	st	-X, r24
    5a1c:	13 97       	sbiw	r26, 0x03	; 3
    5a1e:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
	 sprintf_P(currSeg,PSTR("0"));
    5a22:	a5 e1       	ldi	r26, 0x15	; 21
    5a24:	ea 2e       	mov	r14, r26
    5a26:	f1 2c       	mov	r15, r1
    5a28:	ec 0e       	add	r14, r28
    5a2a:	fd 1e       	adc	r15, r29
    5a2c:	ed b7       	in	r30, 0x3d	; 61
    5a2e:	fe b7       	in	r31, 0x3e	; 62
    5a30:	f2 82       	std	Z+2, r15	; 0x02
    5a32:	e1 82       	std	Z+1, r14	; 0x01
    5a34:	88 ea       	ldi	r24, 0xA8	; 168
    5a36:	95 e0       	ldi	r25, 0x05	; 5
    5a38:	94 83       	std	Z+4, r25	; 0x04
    5a3a:	83 83       	std	Z+3, r24	; 0x03
    5a3c:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    5a40:	bb 24       	eor	r11, r11
    5a42:	0f 90       	pop	r0
    5a44:	0f 90       	pop	r0
    5a46:	0f 90       	pop	r0
    5a48:	0f 90       	pop	r0
    5a4a:	a0 2e       	mov	r10, r16
    5a4c:	91 2e       	mov	r9, r17

	 for(i=0;i<strlen(strB);i++){
	     //
         CalcSegmen(strA,strB[lenB-1-i],currSeg);
    5a4e:	08 2d       	mov	r16, r8
    5a50:	10 e0       	ldi	r17, 0x00	; 0
    5a52:	01 50       	subi	r16, 0x01	; 1
    5a54:	10 40       	sbci	r17, 0x00	; 0
    5a56:	1f c0       	rjmp	.+62     	; 0x5a96 <CalcMultiply+0xe8>
    5a58:	f8 01       	movw	r30, r16
    5a5a:	e8 1b       	sub	r30, r24
    5a5c:	f9 0b       	sbc	r31, r25
    5a5e:	ec 0d       	add	r30, r12
    5a60:	fd 1d       	adc	r31, r13
    5a62:	c3 01       	movw	r24, r6
    5a64:	60 81       	ld	r22, Z
    5a66:	a7 01       	movw	r20, r14
    5a68:	0e 94 3e 23 	call	0x467c	; 0x467c <CalcSegmen>
         AddZeroLag(currSeg,strlen(currSeg)+i);
    5a6c:	f7 01       	movw	r30, r14
    5a6e:	01 90       	ld	r0, Z+
    5a70:	00 20       	and	r0, r0
    5a72:	e9 f7       	brne	.-6      	; 0x5a6e <CalcMultiply+0xc0>
    5a74:	31 97       	sbiw	r30, 0x01	; 1
    5a76:	ee 19       	sub	r30, r14
    5a78:	ff 09       	sbc	r31, r15
    5a7a:	6b 2d       	mov	r22, r11
    5a7c:	6e 0f       	add	r22, r30
    5a7e:	c7 01       	movw	r24, r14
    5a80:	0e 94 d8 29 	call	0x53b0	; 0x53b0 <AddZeroLag>
	     StrCalc(TPLUS,prevSeg,currSeg,prevSeg);
    5a84:	81 e0       	ldi	r24, 0x01	; 1
    5a86:	6a 2d       	mov	r22, r10
    5a88:	79 2d       	mov	r23, r9
    5a8a:	a7 01       	movw	r20, r14
    5a8c:	2a 2d       	mov	r18, r10
    5a8e:	39 2d       	mov	r19, r9
    5a90:	0e 94 f3 29 	call	0x53e6	; 0x53e6 <StrCalc>
     RemZeroLead(strB);
	 lenB=strlen(strB);
	 sprintf_P(prevSeg,PSTR("0"));
	 sprintf_P(currSeg,PSTR("0"));

	 for(i=0;i<strlen(strB);i++){
    5a94:	b3 94       	inc	r11
    5a96:	f6 01       	movw	r30, r12
    5a98:	01 90       	ld	r0, Z+
    5a9a:	00 20       	and	r0, r0
    5a9c:	e9 f7       	brne	.-6      	; 0x5a98 <CalcMultiply+0xea>
    5a9e:	31 97       	sbiw	r30, 0x01	; 1
    5aa0:	ec 19       	sub	r30, r12
    5aa2:	fd 09       	sbc	r31, r13
    5aa4:	8b 2d       	mov	r24, r11
    5aa6:	90 e0       	ldi	r25, 0x00	; 0
    5aa8:	8e 17       	cp	r24, r30
    5aaa:	9f 07       	cpc	r25, r31
    5aac:	a8 f2       	brcs	.-86     	; 0x5a58 <CalcMultiply+0xaa>
	     //
         CalcSegmen(strA,strB[lenB-1-i],currSeg);
         AddZeroLag(currSeg,strlen(currSeg)+i);
	     StrCalc(TPLUS,prevSeg,currSeg,prevSeg);
	 }
	 sprintf_P(strC,PSTR("%s"),prevSeg);
    5aae:	00 d0       	rcall	.+0      	; 0x5ab0 <CalcMultiply+0x102>
    5ab0:	00 d0       	rcall	.+0      	; 0x5ab2 <CalcMultiply+0x104>
    5ab2:	00 d0       	rcall	.+0      	; 0x5ab4 <CalcMultiply+0x106>
    5ab4:	ed b7       	in	r30, 0x3d	; 61
    5ab6:	fe b7       	in	r31, 0x3e	; 62
    5ab8:	31 96       	adiw	r30, 0x01	; 1
    5aba:	ad b7       	in	r26, 0x3d	; 61
    5abc:	be b7       	in	r27, 0x3e	; 62
    5abe:	12 96       	adiw	r26, 0x02	; 2
    5ac0:	5c 92       	st	X, r5
    5ac2:	4e 92       	st	-X, r4
    5ac4:	11 97       	sbiw	r26, 0x01	; 1
    5ac6:	85 ea       	ldi	r24, 0xA5	; 165
    5ac8:	95 e0       	ldi	r25, 0x05	; 5
    5aca:	93 83       	std	Z+3, r25	; 0x03
    5acc:	82 83       	std	Z+2, r24	; 0x02
    5ace:	a4 82       	std	Z+4, r10	; 0x04
    5ad0:	95 82       	std	Z+5, r9	; 0x05
    5ad2:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    5ad6:	ed b7       	in	r30, 0x3d	; 61
    5ad8:	fe b7       	in	r31, 0x3e	; 62
    5ada:	36 96       	adiw	r30, 0x06	; 6
    5adc:	0f b6       	in	r0, 0x3f	; 63
    5ade:	f8 94       	cli
    5ae0:	fe bf       	out	0x3e, r31	; 62
    5ae2:	0f be       	out	0x3f, r0	; 63
    5ae4:	ed bf       	out	0x3d, r30	; 61
}
    5ae6:	a8 96       	adiw	r28, 0x28	; 40
    5ae8:	0f b6       	in	r0, 0x3f	; 63
    5aea:	f8 94       	cli
    5aec:	de bf       	out	0x3e, r29	; 62
    5aee:	0f be       	out	0x3f, r0	; 63
    5af0:	cd bf       	out	0x3d, r28	; 61
    5af2:	cf 91       	pop	r28
    5af4:	df 91       	pop	r29
    5af6:	1f 91       	pop	r17
    5af8:	0f 91       	pop	r16
    5afa:	ff 90       	pop	r15
    5afc:	ef 90       	pop	r14
    5afe:	df 90       	pop	r13
    5b00:	cf 90       	pop	r12
    5b02:	bf 90       	pop	r11
    5b04:	af 90       	pop	r10
    5b06:	9f 90       	pop	r9
    5b08:	8f 90       	pop	r8
    5b0a:	7f 90       	pop	r7
    5b0c:	6f 90       	pop	r6
    5b0e:	5f 90       	pop	r5
    5b10:	4f 90       	pop	r4
    5b12:	08 95       	ret

00005b14 <NormalizeOverflow>:
		 Length=strlen(strNumber);
		 StrPosCopy(strNumber,strNumber,MinPos,(Length-MinPos));	      
	 }
}

void NormalizeOverflow(char *strOverflowed){
    5b14:	cf 92       	push	r12
    5b16:	df 92       	push	r13
    5b18:	ef 92       	push	r14
    5b1a:	ff 92       	push	r15
    5b1c:	0f 93       	push	r16
    5b1e:	1f 93       	push	r17
    5b20:	df 93       	push	r29
    5b22:	cf 93       	push	r28
    5b24:	cd b7       	in	r28, 0x3d	; 61
    5b26:	de b7       	in	r29, 0x3e	; 62
    5b28:	64 97       	sbiw	r28, 0x14	; 20
    5b2a:	0f b6       	in	r0, 0x3f	; 63
    5b2c:	f8 94       	cli
    5b2e:	de bf       	out	0x3e, r29	; 62
    5b30:	0f be       	out	0x3f, r0	; 63
    5b32:	cd bf       	out	0x3d, r28	; 61
    5b34:	d8 2e       	mov	r13, r24
    5b36:	c9 2e       	mov	r12, r25
char i,Length,strMaxValue[20];//-99999999

     Length=strlen(strOverflowed);//-999453
    5b38:	a8 2f       	mov	r26, r24
    5b3a:	b9 2f       	mov	r27, r25
    5b3c:	fd 01       	movw	r30, r26
    5b3e:	01 90       	ld	r0, Z+
    5b40:	00 20       	and	r0, r0
    5b42:	e9 f7       	brne	.-6      	; 0x5b3e <NormalizeOverflow+0x2a>
    5b44:	31 97       	sbiw	r30, 0x01	; 1
    5b46:	4e 2f       	mov	r20, r30
    5b48:	48 1b       	sub	r20, r24
    5b4a:	20 e0       	ldi	r18, 0x00	; 0
    5b4c:	30 e0       	ldi	r19, 0x00	; 0
    5b4e:	7e 01       	movw	r14, r28
    5b50:	08 94       	sec
    5b52:	e1 1c       	adc	r14, r1
    5b54:	f1 1c       	adc	r15, r1
    5b56:	04 2f       	mov	r16, r20
    5b58:	10 e0       	ldi	r17, 0x00	; 0
    5b5a:	0e c0       	rjmp	.+28     	; 0x5b78 <NormalizeOverflow+0x64>
     for(i=0;i<Length;i++){//123456
	     strMaxValue[i]='0'+((Length-i)/Length);
    5b5c:	f7 01       	movw	r30, r14
    5b5e:	e2 0f       	add	r30, r18
    5b60:	f3 1f       	adc	r31, r19
    5b62:	c8 01       	movw	r24, r16
    5b64:	82 1b       	sub	r24, r18
    5b66:	93 0b       	sbc	r25, r19
    5b68:	64 2f       	mov	r22, r20
    5b6a:	70 e0       	ldi	r23, 0x00	; 0
    5b6c:	0e 94 a7 b8 	call	0x1714e	; 0x1714e <__divmodhi4>
    5b70:	60 5d       	subi	r22, 0xD0	; 208
    5b72:	60 83       	st	Z, r22
    5b74:	2f 5f       	subi	r18, 0xFF	; 255
    5b76:	3f 4f       	sbci	r19, 0xFF	; 255

void NormalizeOverflow(char *strOverflowed){
char i,Length,strMaxValue[20];//-99999999

     Length=strlen(strOverflowed);//-999453
     for(i=0;i<Length;i++){//123456
    5b78:	24 17       	cp	r18, r20
    5b7a:	80 f3       	brcs	.-32     	; 0x5b5c <NormalizeOverflow+0x48>
	     strMaxValue[i]='0'+((Length-i)/Length);
	 }strMaxValue[Length]=0;
    5b7c:	0e 0d       	add	r16, r14
    5b7e:	1f 1d       	adc	r17, r15
    5b80:	f8 01       	movw	r30, r16
    5b82:	10 82       	st	Z, r1
     
	 //if (NinePos<Length-4)
	 StrCalc(TPLUS,strMaxValue,strOverflowed,strOverflowed);
    5b84:	81 e0       	ldi	r24, 0x01	; 1
    5b86:	b7 01       	movw	r22, r14
    5b88:	4d 2d       	mov	r20, r13
    5b8a:	5c 2d       	mov	r21, r12
    5b8c:	2d 2d       	mov	r18, r13
    5b8e:	3c 2d       	mov	r19, r12
    5b90:	0e 94 f3 29 	call	0x53e6	; 0x53e6 <StrCalc>
}
    5b94:	64 96       	adiw	r28, 0x14	; 20
    5b96:	0f b6       	in	r0, 0x3f	; 63
    5b98:	f8 94       	cli
    5b9a:	de bf       	out	0x3e, r29	; 62
    5b9c:	0f be       	out	0x3f, r0	; 63
    5b9e:	cd bf       	out	0x3d, r28	; 61
    5ba0:	cf 91       	pop	r28
    5ba2:	df 91       	pop	r29
    5ba4:	1f 91       	pop	r17
    5ba6:	0f 91       	pop	r16
    5ba8:	ff 90       	pop	r15
    5baa:	ef 90       	pop	r14
    5bac:	df 90       	pop	r13
    5bae:	cf 90       	pop	r12
    5bb0:	08 95       	ret

00005bb2 <AddSpaceLead>:
	    String[i]=' ';
	 }String[Size]=0;
  }
}

void AddSpaceLead(char *String,unsigned char Size){//
    5bb2:	bf 92       	push	r11
    5bb4:	cf 92       	push	r12
    5bb6:	df 92       	push	r13
    5bb8:	ef 92       	push	r14
    5bba:	ff 92       	push	r15
    5bbc:	0f 93       	push	r16
    5bbe:	1f 93       	push	r17
    5bc0:	df 93       	push	r29
    5bc2:	cf 93       	push	r28
    5bc4:	cd b7       	in	r28, 0x3d	; 61
    5bc6:	de b7       	in	r29, 0x3e	; 62
    5bc8:	e2 97       	sbiw	r28, 0x32	; 50
    5bca:	0f b6       	in	r0, 0x3f	; 63
    5bcc:	f8 94       	cli
    5bce:	de bf       	out	0x3e, r29	; 62
    5bd0:	0f be       	out	0x3f, r0	; 63
    5bd2:	cd bf       	out	0x3d, r28	; 61
    5bd4:	8c 01       	movw	r16, r24
     char i,Length,strAdded[50];
     Length=strlen(String);
    5bd6:	fc 01       	movw	r30, r24
    5bd8:	01 90       	ld	r0, Z+
    5bda:	00 20       	and	r0, r0
    5bdc:	e9 f7       	brne	.-6      	; 0x5bd8 <AddSpaceLead+0x26>
    5bde:	31 97       	sbiw	r30, 0x01	; 1
    5be0:	2e 2f       	mov	r18, r30
    5be2:	28 1b       	sub	r18, r24

	 if (Size>Length){
    5be4:	26 17       	cp	r18, r22
    5be6:	e0 f5       	brcc	.+120    	; 0x5c60 <AddSpaceLead+0xae>
    5be8:	7e 01       	movw	r14, r28
    5bea:	08 94       	sec
    5bec:	e1 1c       	adc	r14, r1
    5bee:	f1 1c       	adc	r15, r1
    5bf0:	f7 01       	movw	r30, r14
	    String[i]=' ';
	 }String[Size]=0;
  }
}

void AddSpaceLead(char *String,unsigned char Size){//
    5bf2:	be 2c       	mov	r11, r14
     char i,Length,strAdded[50];
     Length=strlen(String);

	 if (Size>Length){
         for(i=0;i<Size;i++){
	         strAdded[i]=' ';
    5bf4:	90 e2       	ldi	r25, 0x20	; 32
    5bf6:	01 c0       	rjmp	.+2      	; 0x5bfa <AddSpaceLead+0x48>
    5bf8:	91 93       	st	Z+, r25
void AddSpaceLead(char *String,unsigned char Size){//
     char i,Length,strAdded[50];
     Length=strlen(String);

	 if (Size>Length){
         for(i=0;i<Size;i++){
    5bfa:	8e 2f       	mov	r24, r30
    5bfc:	8b 19       	sub	r24, r11
    5bfe:	86 17       	cp	r24, r22
    5c00:	d8 f3       	brcs	.-10     	; 0x5bf8 <AddSpaceLead+0x46>
	         strAdded[i]=' ';
	     }strAdded[Size]=0;
    5c02:	46 2f       	mov	r20, r22
    5c04:	50 e0       	ldi	r21, 0x00	; 0
    5c06:	ce 01       	movw	r24, r28
    5c08:	01 96       	adiw	r24, 0x01	; 1
    5c0a:	fc 01       	movw	r30, r24
    5c0c:	e4 0f       	add	r30, r20
    5c0e:	f5 1f       	adc	r31, r21
    5c10:	10 82       	st	Z, r1
	     //Copy
         for(i=(Size-Length);i<Size;i++){
    5c12:	76 2f       	mov	r23, r22
    5c14:	72 1b       	sub	r23, r18
    5c16:	6c 01       	movw	r12, r24
	         strAdded[i]=String[i-(Size-Length)];
    5c18:	30 e0       	ldi	r19, 0x00	; 0
    5c1a:	24 1b       	sub	r18, r20
    5c1c:	35 0b       	sbc	r19, r21
    5c1e:	0c c0       	rjmp	.+24     	; 0x5c38 <AddSpaceLead+0x86>
    5c20:	e7 2f       	mov	r30, r23
    5c22:	f0 e0       	ldi	r31, 0x00	; 0
    5c24:	d6 01       	movw	r26, r12
    5c26:	ae 0f       	add	r26, r30
    5c28:	bf 1f       	adc	r27, r31
    5c2a:	e0 0f       	add	r30, r16
    5c2c:	f1 1f       	adc	r31, r17
    5c2e:	e2 0f       	add	r30, r18
    5c30:	f3 1f       	adc	r31, r19
    5c32:	80 81       	ld	r24, Z
    5c34:	8c 93       	st	X, r24
	 if (Size>Length){
         for(i=0;i<Size;i++){
	         strAdded[i]=' ';
	     }strAdded[Size]=0;
	     //Copy
         for(i=(Size-Length);i<Size;i++){
    5c36:	7f 5f       	subi	r23, 0xFF	; 255
    5c38:	76 17       	cp	r23, r22
    5c3a:	90 f3       	brcs	.-28     	; 0x5c20 <AddSpaceLead+0x6e>
	         strAdded[i]=String[i-(Size-Length)];
	     }strAdded[Size]=0;
    5c3c:	4c 0d       	add	r20, r12
    5c3e:	5d 1d       	adc	r21, r13
    5c40:	da 01       	movw	r26, r20
    5c42:	1c 92       	st	X, r1
    5c44:	f8 01       	movw	r30, r16
    5c46:	04 c0       	rjmp	.+8      	; 0x5c50 <AddSpaceLead+0x9e>
	     //Spaced
         for(i=0;i<Size;i++){
	         String[i]=strAdded[i];
    5c48:	d7 01       	movw	r26, r14
    5c4a:	8d 91       	ld	r24, X+
    5c4c:	7d 01       	movw	r14, r26
    5c4e:	81 93       	st	Z+, r24
	     //Copy
         for(i=(Size-Length);i<Size;i++){
	         strAdded[i]=String[i-(Size-Length)];
	     }strAdded[Size]=0;
	     //Spaced
         for(i=0;i<Size;i++){
    5c50:	8e 2d       	mov	r24, r14
    5c52:	8b 19       	sub	r24, r11
    5c54:	86 17       	cp	r24, r22
    5c56:	c0 f3       	brcs	.-16     	; 0x5c48 <AddSpaceLead+0x96>
	         String[i]=strAdded[i];
	     }String[Size]=0;
    5c58:	06 0f       	add	r16, r22
    5c5a:	11 1d       	adc	r17, r1
    5c5c:	f8 01       	movw	r30, r16
    5c5e:	10 82       	st	Z, r1
	 }
}
    5c60:	e2 96       	adiw	r28, 0x32	; 50
    5c62:	0f b6       	in	r0, 0x3f	; 63
    5c64:	f8 94       	cli
    5c66:	de bf       	out	0x3e, r29	; 62
    5c68:	0f be       	out	0x3f, r0	; 63
    5c6a:	cd bf       	out	0x3d, r28	; 61
    5c6c:	cf 91       	pop	r28
    5c6e:	df 91       	pop	r29
    5c70:	1f 91       	pop	r17
    5c72:	0f 91       	pop	r16
    5c74:	ff 90       	pop	r15
    5c76:	ef 90       	pop	r14
    5c78:	df 90       	pop	r13
    5c7a:	cf 90       	pop	r12
    5c7c:	bf 90       	pop	r11
    5c7e:	08 95       	ret

00005c80 <AddSpaceLag>:
	 }
}



void AddSpaceLag(char *String,unsigned char Size){// [CREDITCARD             ]
    5c80:	cf 93       	push	r28
    5c82:	df 93       	push	r29
    5c84:	ec 01       	movw	r28, r24
char i,Length;
     Length=strlen(String);
    5c86:	dc 01       	movw	r26, r24
    5c88:	0d 90       	ld	r0, X+
    5c8a:	00 20       	and	r0, r0
    5c8c:	e9 f7       	brne	.-6      	; 0x5c88 <AddSpaceLag+0x8>
    5c8e:	11 97       	sbiw	r26, 0x01	; 1
    5c90:	a8 1b       	sub	r26, r24
    5c92:	b9 0b       	sbc	r27, r25
  if (Length<Size){   
    5c94:	a6 17       	cp	r26, r22
    5c96:	60 f4       	brcc	.+24     	; 0x5cb0 <AddSpaceLag+0x30>
    5c98:	8a 2f       	mov	r24, r26
     for(i=Length;i<Size;i++){
	    String[i]=' ';
    5c9a:	90 e2       	ldi	r25, 0x20	; 32
    5c9c:	fe 01       	movw	r30, r28
    5c9e:	e8 0f       	add	r30, r24
    5ca0:	f1 1d       	adc	r31, r1
    5ca2:	90 83       	st	Z, r25

void AddSpaceLag(char *String,unsigned char Size){// [CREDITCARD             ]
char i,Length;
     Length=strlen(String);
  if (Length<Size){   
     for(i=Length;i<Size;i++){
    5ca4:	8f 5f       	subi	r24, 0xFF	; 255
    5ca6:	86 17       	cp	r24, r22
    5ca8:	c8 f3       	brcs	.-14     	; 0x5c9c <AddSpaceLag+0x1c>
	    String[i]=' ';
	 }String[Size]=0;
    5caa:	c6 0f       	add	r28, r22
    5cac:	d1 1d       	adc	r29, r1
    5cae:	18 82       	st	Y, r1
  }
}
    5cb0:	df 91       	pop	r29
    5cb2:	cf 91       	pop	r28
    5cb4:	08 95       	ret

00005cb6 <GetProductName>:
	 }    
	 //Clear Decimal

}

void GetProductName(char GradeId,char *strProductName){
    5cb6:	0f 93       	push	r16
    5cb8:	1f 93       	push	r17
    5cba:	df 93       	push	r29
    5cbc:	cf 93       	push	r28
    5cbe:	cd b7       	in	r28, 0x3d	; 61
    5cc0:	de b7       	in	r29, 0x3e	; 62
    5cc2:	2c 97       	sbiw	r28, 0x0c	; 12
    5cc4:	0f b6       	in	r0, 0x3f	; 63
    5cc6:	f8 94       	cli
    5cc8:	de bf       	out	0x3e, r29	; 62
    5cca:	0f be       	out	0x3f, r0	; 63
    5ccc:	cd bf       	out	0x3d, r28	; 61
    5cce:	48 2f       	mov	r20, r24
    5cd0:	8b 01       	movw	r16, r22
    5cd2:	fe 01       	movw	r30, r28
    5cd4:	31 96       	adiw	r30, 0x01	; 1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    5cd6:	9e 01       	movw	r18, r28
    5cd8:	23 5f       	subi	r18, 0xF3	; 243
    5cda:	3f 4f       	sbci	r19, 0xFF	; 255
	     strMemory[i]=data;
    5cdc:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    5cde:	e2 17       	cp	r30, r18
    5ce0:	f3 07       	cpc	r31, r19
    5ce2:	e1 f7       	brne	.-8      	; 0x5cdc <GetProductName+0x26>
    5ce4:	ce 01       	movw	r24, r28
    5ce6:	01 96       	adiw	r24, 0x01	; 1

void GetProductName(char GradeId,char *strProductName){
char SProductName[12],i,Length;
     FillChar(SProductName,sizeof(SProductName),0); 
	 //eeprom_read_block((void*) &SProductName, (const void*) &DefProductName[GradeId-1],10);
	 if (GradeId>0) eeprom_read_block((void*) &SProductName, (const void*) &DefProductName[GradeId-1],10);
    5ce8:	44 23       	and	r20, r20
    5cea:	69 f0       	breq	.+26     	; 0x5d06 <GetProductName+0x50>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    5cec:	6d e0       	ldi	r22, 0x0D	; 13
    5cee:	46 9f       	mul	r20, r22
    5cf0:	b0 01       	movw	r22, r0
    5cf2:	11 24       	eor	r1, r1
    5cf4:	62 55       	subi	r22, 0x52	; 82
    5cf6:	7f 4f       	sbci	r23, 0xFF	; 255
    5cf8:	4a e0       	ldi	r20, 0x0A	; 10
    5cfa:	50 e0       	ldi	r21, 0x00	; 0
    5cfc:	26 ef       	ldi	r18, 0xF6	; 246
    5cfe:	32 e1       	ldi	r19, 0x12	; 18
    5d00:	0e 94 7a b5 	call	0x16af4	; 0x16af4 <__eerd_block>
    5d04:	14 c0       	rjmp	.+40     	; 0x5d2e <GetProductName+0x78>
	 else sprintf_P(SProductName,PSTR("N/A"));
    5d06:	00 d0       	rcall	.+0      	; 0x5d08 <GetProductName+0x52>
    5d08:	00 d0       	rcall	.+0      	; 0x5d0a <GetProductName+0x54>
    5d0a:	ad b7       	in	r26, 0x3d	; 61
    5d0c:	be b7       	in	r27, 0x3e	; 62
    5d0e:	12 96       	adiw	r26, 0x02	; 2
    5d10:	9c 93       	st	X, r25
    5d12:	8e 93       	st	-X, r24
    5d14:	11 97       	sbiw	r26, 0x01	; 1
    5d16:	8c ef       	ldi	r24, 0xFC	; 252
    5d18:	93 e0       	ldi	r25, 0x03	; 3
    5d1a:	14 96       	adiw	r26, 0x04	; 4
    5d1c:	9c 93       	st	X, r25
    5d1e:	8e 93       	st	-X, r24
    5d20:	13 97       	sbiw	r26, 0x03	; 3
    5d22:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    5d26:	0f 90       	pop	r0
    5d28:	0f 90       	pop	r0
    5d2a:	0f 90       	pop	r0
    5d2c:	0f 90       	pop	r0

     Length=strlen(SProductName);
    5d2e:	de 01       	movw	r26, r28
    5d30:	11 96       	adiw	r26, 0x01	; 1
    5d32:	fd 01       	movw	r30, r26
    5d34:	01 90       	ld	r0, Z+
    5d36:	00 20       	and	r0, r0
    5d38:	e9 f7       	brne	.-6      	; 0x5d34 <GetProductName+0x7e>
    5d3a:	31 97       	sbiw	r30, 0x01	; 1
    5d3c:	ea 1b       	sub	r30, r26
    5d3e:	eb 30       	cpi	r30, 0x0B	; 11
    5d40:	08 f0       	brcs	.+2      	; 0x5d44 <GetProductName+0x8e>
    5d42:	ea e0       	ldi	r30, 0x0A	; 10
    5d44:	ae 01       	movw	r20, r28
    5d46:	4f 5f       	subi	r20, 0xFF	; 255
    5d48:	5f 4f       	sbci	r21, 0xFF	; 255
    5d4a:	98 01       	movw	r18, r16
    5d4c:	ba 01       	movw	r22, r20
    5d4e:	06 c0       	rjmp	.+12     	; 0x5d5c <GetProductName+0xa6>
	 if (Length>10)Length=10;

	 for(i=0;i<Length;i++){
	     strProductName[i]=SProductName[i];
    5d50:	db 01       	movw	r26, r22
    5d52:	8d 91       	ld	r24, X+
    5d54:	bd 01       	movw	r22, r26
    5d56:	d9 01       	movw	r26, r18
    5d58:	8d 93       	st	X+, r24
    5d5a:	9d 01       	movw	r18, r26
	 else sprintf_P(SProductName,PSTR("N/A"));

     Length=strlen(SProductName);
	 if (Length>10)Length=10;

	 for(i=0;i<Length;i++){
    5d5c:	86 2f       	mov	r24, r22
    5d5e:	84 1b       	sub	r24, r20
    5d60:	8e 17       	cp	r24, r30
    5d62:	b0 f3       	brcs	.-20     	; 0x5d50 <GetProductName+0x9a>
	     strProductName[i]=SProductName[i];
	 }strProductName[Length]=0;
    5d64:	c8 01       	movw	r24, r16
    5d66:	8e 0f       	add	r24, r30
    5d68:	91 1d       	adc	r25, r1
    5d6a:	fc 01       	movw	r30, r24
    5d6c:	10 82       	st	Z, r1

	 AddSpaceLag(strProductName,10);
    5d6e:	c8 01       	movw	r24, r16
    5d70:	6a e0       	ldi	r22, 0x0A	; 10
    5d72:	0e 94 40 2e 	call	0x5c80	; 0x5c80 <AddSpaceLag>
}
    5d76:	2c 96       	adiw	r28, 0x0c	; 12
    5d78:	0f b6       	in	r0, 0x3f	; 63
    5d7a:	f8 94       	cli
    5d7c:	de bf       	out	0x3e, r29	; 62
    5d7e:	0f be       	out	0x3f, r0	; 63
    5d80:	cd bf       	out	0x3d, r28	; 61
    5d82:	cf 91       	pop	r28
    5d84:	df 91       	pop	r29
    5d86:	1f 91       	pop	r17
    5d88:	0f 91       	pop	r16
    5d8a:	08 95       	ret

00005d8c <GeniusSendLastTransaction>:
}
void GeniusSendPumpPreset(char iPumpID){
}


void GeniusSendLastTransaction(char iPumpID){
    5d8c:	2f 92       	push	r2
    5d8e:	3f 92       	push	r3
    5d90:	4f 92       	push	r4
    5d92:	5f 92       	push	r5
    5d94:	6f 92       	push	r6
    5d96:	7f 92       	push	r7
    5d98:	8f 92       	push	r8
    5d9a:	9f 92       	push	r9
    5d9c:	af 92       	push	r10
    5d9e:	bf 92       	push	r11
    5da0:	cf 92       	push	r12
    5da2:	df 92       	push	r13
    5da4:	ef 92       	push	r14
    5da6:	ff 92       	push	r15
    5da8:	0f 93       	push	r16
    5daa:	1f 93       	push	r17
    5dac:	df 93       	push	r29
    5dae:	cf 93       	push	r28
    5db0:	cd b7       	in	r28, 0x3d	; 61
    5db2:	de b7       	in	r29, 0x3e	; 62
    5db4:	c0 5b       	subi	r28, 0xB0	; 176
    5db6:	d0 40       	sbci	r29, 0x00	; 0
    5db8:	0f b6       	in	r0, 0x3f	; 63
    5dba:	f8 94       	cli
    5dbc:	de bf       	out	0x3e, r29	; 62
    5dbe:	0f be       	out	0x3f, r0	; 63
    5dc0:	cd bf       	out	0x3d, r28	; 61
    5dc2:	e8 2e       	mov	r14, r24
    5dc4:	fe 01       	movw	r30, r28
    5dc6:	37 96       	adiw	r30, 0x07	; 7

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    5dc8:	ce 01       	movw	r24, r28
    5dca:	46 96       	adiw	r24, 0x16	; 22
	     strMemory[i]=data;
    5dcc:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    5dce:	e8 17       	cp	r30, r24
    5dd0:	f9 07       	cpc	r31, r25
    5dd2:	e1 f7       	brne	.-8      	; 0x5dcc <GeniusSendLastTransaction+0x40>
	     strMemory[i]=data;
    5dd4:	ce 01       	movw	r24, r28
    5dd6:	85 96       	adiw	r24, 0x25	; 37
    5dd8:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    5dda:	e8 17       	cp	r30, r24
    5ddc:	f9 07       	cpc	r31, r25
    5dde:	e1 f7       	brne	.-8      	; 0x5dd8 <GeniusSendLastTransaction+0x4c>
	     strMemory[i]=data;
    5de0:	ce 01       	movw	r24, r28
    5de2:	c4 96       	adiw	r24, 0x34	; 52
    5de4:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    5de6:	e8 17       	cp	r30, r24
    5de8:	f9 07       	cpc	r31, r25
    5dea:	e1 f7       	brne	.-8      	; 0x5de4 <GeniusSendLastTransaction+0x58>
	     strMemory[i]=data;
    5dec:	cf 01       	movw	r24, r30
    5dee:	3f 01       	movw	r6, r30
    5df0:	0f 96       	adiw	r24, 0x0f	; 15
    5df2:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    5df4:	e8 17       	cp	r30, r24
    5df6:	f9 07       	cpc	r31, r25
    5df8:	e1 f7       	brne	.-8      	; 0x5df2 <GeniusSendLastTransaction+0x66>
	 FillChar(STotalVolume,sizeof(STotalVolume),0);
	 FillChar(STotalMoney,sizeof(STotalMoney),0);
	      

	 //Generate
	 FIPAddr=GetFIPAddr(iPumpID);
    5dfa:	8e 2d       	mov	r24, r14
    5dfc:	0e 94 e1 1d 	call	0x3bc2	; 0x3bc2 <GetFIPAddr>
    5e00:	96 e0       	ldi	r25, 0x06	; 6
    5e02:	89 9f       	mul	r24, r25
    5e04:	b0 01       	movw	r22, r0
    5e06:	11 24       	eor	r1, r1
    5e08:	61 5b       	subi	r22, 0xB1	; 177
    5e0a:	7f 4f       	sbci	r23, 0xFF	; 255
    5e0c:	8e 01       	movw	r16, r28
    5e0e:	0f 5f       	subi	r16, 0xFF	; 255
    5e10:	1f 4f       	sbci	r17, 0xFF	; 255
    5e12:	c8 01       	movw	r24, r16
    5e14:	46 e0       	ldi	r20, 0x06	; 6
    5e16:	50 e0       	ldi	r21, 0x00	; 0
    5e18:	26 ef       	ldi	r18, 0xF6	; 246
    5e1a:	32 e1       	ldi	r19, 0x12	; 18
    5e1c:	0e 94 7a b5 	call	0x16af4	; 0x16af4 <__eerd_block>
     eeprom_read_block((void*) &PProductID, (const void*) &DefNozzleMap[FIPAddr-1], 6);
	 iNozzle=RecPumpData[iPumpID&0x0F].Grade;
    5e20:	2e 2c       	mov	r2, r14
    5e22:	33 24       	eor	r3, r3
    5e24:	91 01       	movw	r18, r2
    5e26:	2f 70       	andi	r18, 0x0F	; 15
    5e28:	30 70       	andi	r19, 0x00	; 0
    5e2a:	85 e3       	ldi	r24, 0x35	; 53
    5e2c:	90 e0       	ldi	r25, 0x00	; 0
    5e2e:	28 9f       	mul	r18, r24
    5e30:	f0 01       	movw	r30, r0
    5e32:	29 9f       	mul	r18, r25
    5e34:	f0 0d       	add	r31, r0
    5e36:	38 9f       	mul	r19, r24
    5e38:	f0 0d       	add	r31, r0
    5e3a:	11 24       	eor	r1, r1
    5e3c:	e5 57       	subi	r30, 0x75	; 117
    5e3e:	f8 4f       	sbci	r31, 0xF8	; 248
    5e40:	f0 80       	ld	r15, Z
	 iProdID=PProductID[iNozzle];
    5e42:	4f 2c       	mov	r4, r15
    5e44:	55 24       	eor	r5, r5

	 GetProductName(iProdID,strProduct);
    5e46:	04 0d       	add	r16, r4
    5e48:	15 1d       	adc	r17, r5
    5e4a:	d8 01       	movw	r26, r16
    5e4c:	8c 91       	ld	r24, X
    5e4e:	61 e4       	ldi	r22, 0x41	; 65
    5e50:	79 e0       	ldi	r23, 0x09	; 9
    5e52:	0e 94 5b 2e 	call	0x5cb6	; 0x5cb6 <GetProductName>
	 GetTransactionVolume(iPumpID,SVolume);
    5e56:	87 e0       	ldi	r24, 0x07	; 7
    5e58:	88 2e       	mov	r8, r24
    5e5a:	91 2c       	mov	r9, r1
    5e5c:	8c 0e       	add	r8, r28
    5e5e:	9d 1e       	adc	r9, r29
    5e60:	8e 2d       	mov	r24, r14
    5e62:	b4 01       	movw	r22, r8
    5e64:	0e 94 12 28 	call	0x5024	; 0x5024 <GetTransactionVolume>
	 GetTransactionMoney(iPumpID,SMoney);
    5e68:	06 e1       	ldi	r16, 0x16	; 22
    5e6a:	a0 2e       	mov	r10, r16
    5e6c:	b1 2c       	mov	r11, r1
    5e6e:	ac 0e       	add	r10, r28
    5e70:	bd 1e       	adc	r11, r29
    5e72:	8e 2d       	mov	r24, r14
    5e74:	b5 01       	movw	r22, r10
    5e76:	0e 94 d8 27 	call	0x4fb0	; 0x4fb0 <GetTransactionMoney>
	 GetTotalizerVolume(iPumpID,iNozzle,STotalVolume);
    5e7a:	15 e2       	ldi	r17, 0x25	; 37
    5e7c:	c1 2e       	mov	r12, r17
    5e7e:	d1 2c       	mov	r13, r1
    5e80:	cc 0e       	add	r12, r28
    5e82:	dd 1e       	adc	r13, r29
    5e84:	8e 2d       	mov	r24, r14
    5e86:	6f 2d       	mov	r22, r15
    5e88:	a6 01       	movw	r20, r12
    5e8a:	0e 94 bb 27 	call	0x4f76	; 0x4f76 <GetTotalizerVolume>
	 GetTotalizerMoney(iPumpID,iNozzle,STotalMoney);
    5e8e:	8e 2d       	mov	r24, r14
    5e90:	6f 2d       	mov	r22, r15
    5e92:	a3 01       	movw	r20, r6
    5e94:	0e 94 9e 27 	call	0x4f3c	; 0x4f3c <GetTotalizerMoney>
	 
     ComposeDatetime(SDatetime);
    5e98:	b3 e4       	ldi	r27, 0x43	; 67
    5e9a:	eb 2e       	mov	r14, r27
    5e9c:	f1 2c       	mov	r15, r1
    5e9e:	ec 0e       	add	r14, r28
    5ea0:	fd 1e       	adc	r15, r29
    5ea2:	c7 01       	movw	r24, r14
    5ea4:	0e 94 53 1b 	call	0x36a6	; 0x36a6 <ComposeDatetime>

	 //Compose
	 sprintf_P(strSend,PSTR("T%.2d%.2d%s%s%s%s%s%s:"),iPumpID,iNozzle,strProduct,SDatetime,SVolume,SMoney,STotalVolume,STotalMoney);
    5ea8:	ed b7       	in	r30, 0x3d	; 61
    5eaa:	fe b7       	in	r31, 0x3e	; 62
    5eac:	74 97       	sbiw	r30, 0x14	; 20
    5eae:	0f b6       	in	r0, 0x3f	; 63
    5eb0:	f8 94       	cli
    5eb2:	fe bf       	out	0x3e, r31	; 62
    5eb4:	0f be       	out	0x3f, r0	; 63
    5eb6:	ed bf       	out	0x3d, r30	; 61
    5eb8:	31 96       	adiw	r30, 0x01	; 1
    5eba:	8e 01       	movw	r16, r28
    5ebc:	09 5a       	subi	r16, 0xA9	; 169
    5ebe:	1f 4f       	sbci	r17, 0xFF	; 255
    5ec0:	ad b7       	in	r26, 0x3d	; 61
    5ec2:	be b7       	in	r27, 0x3e	; 62
    5ec4:	12 96       	adiw	r26, 0x02	; 2
    5ec6:	1c 93       	st	X, r17
    5ec8:	0e 93       	st	-X, r16
    5eca:	11 97       	sbiw	r26, 0x01	; 1
    5ecc:	8f e3       	ldi	r24, 0x3F	; 63
    5ece:	93 e0       	ldi	r25, 0x03	; 3
    5ed0:	93 83       	std	Z+3, r25	; 0x03
    5ed2:	82 83       	std	Z+2, r24	; 0x02
    5ed4:	35 82       	std	Z+5, r3	; 0x05
    5ed6:	24 82       	std	Z+4, r2	; 0x04
    5ed8:	57 82       	std	Z+7, r5	; 0x07
    5eda:	46 82       	std	Z+6, r4	; 0x06
    5edc:	81 e4       	ldi	r24, 0x41	; 65
    5ede:	99 e0       	ldi	r25, 0x09	; 9
    5ee0:	91 87       	std	Z+9, r25	; 0x09
    5ee2:	80 87       	std	Z+8, r24	; 0x08
    5ee4:	f3 86       	std	Z+11, r15	; 0x0b
    5ee6:	e2 86       	std	Z+10, r14	; 0x0a
    5ee8:	95 86       	std	Z+13, r9	; 0x0d
    5eea:	84 86       	std	Z+12, r8	; 0x0c
    5eec:	b7 86       	std	Z+15, r11	; 0x0f
    5eee:	a6 86       	std	Z+14, r10	; 0x0e
    5ef0:	d1 8a       	std	Z+17, r13	; 0x11
    5ef2:	c0 8a       	std	Z+16, r12	; 0x10
    5ef4:	62 8a       	std	Z+18, r6	; 0x12
    5ef6:	73 8a       	std	Z+19, r7	; 0x13
    5ef8:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
	 cSum=SumChecksum(strSend);
    5efc:	ad b7       	in	r26, 0x3d	; 61
    5efe:	be b7       	in	r27, 0x3e	; 62
    5f00:	54 96       	adiw	r26, 0x14	; 20
    5f02:	0f b6       	in	r0, 0x3f	; 63
    5f04:	f8 94       	cli
    5f06:	be bf       	out	0x3e, r27	; 62
    5f08:	0f be       	out	0x3f, r0	; 63
    5f0a:	ad bf       	out	0x3d, r26	; 61
    5f0c:	c8 01       	movw	r24, r16
    5f0e:	0e 94 ed 21 	call	0x43da	; 0x43da <SumChecksum>
    5f12:	e8 2e       	mov	r14, r24
	 _uart_print(1,0,strSend);
    5f14:	81 e0       	ldi	r24, 0x01	; 1
    5f16:	60 e0       	ldi	r22, 0x00	; 0
    5f18:	a8 01       	movw	r20, r16
    5f1a:	0e 94 f2 b3 	call	0x167e4	; 0x167e4 <_uart_print>
    5f1e:	f8 01       	movw	r30, r16

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    5f20:	c8 01       	movw	r24, r16
    5f22:	f9 2e       	mov	r15, r25
    5f24:	ce 01       	movw	r24, r28
    5f26:	8f 54       	subi	r24, 0x4F	; 79
    5f28:	9f 4f       	sbci	r25, 0xFF	; 255
	     strMemory[i]=data;
    5f2a:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    5f2c:	e8 17       	cp	r30, r24
    5f2e:	f9 07       	cpc	r31, r25
    5f30:	e1 f7       	brne	.-8      	; 0x5f2a <GeniusSendLastTransaction+0x19e>
	 //Compose
	 sprintf_P(strSend,PSTR("T%.2d%.2d%s%s%s%s%s%s:"),iPumpID,iNozzle,strProduct,SDatetime,SVolume,SMoney,STotalVolume,STotalMoney);
	 cSum=SumChecksum(strSend);
	 _uart_print(1,0,strSend);
	 FillChar(strSend,sizeof(strSend),0);      
	 sprintf_P(strSend,PSTR("%d"),cSum);
    5f32:	00 d0       	rcall	.+0      	; 0x5f34 <GeniusSendLastTransaction+0x1a8>
    5f34:	00 d0       	rcall	.+0      	; 0x5f36 <GeniusSendLastTransaction+0x1aa>
    5f36:	00 d0       	rcall	.+0      	; 0x5f38 <GeniusSendLastTransaction+0x1ac>
    5f38:	ed b7       	in	r30, 0x3d	; 61
    5f3a:	fe b7       	in	r31, 0x3e	; 62
    5f3c:	31 96       	adiw	r30, 0x01	; 1
    5f3e:	ad b7       	in	r26, 0x3d	; 61
    5f40:	be b7       	in	r27, 0x3e	; 62
    5f42:	11 96       	adiw	r26, 0x01	; 1
    5f44:	0c 93       	st	X, r16
    5f46:	11 97       	sbiw	r26, 0x01	; 1
    5f48:	12 96       	adiw	r26, 0x02	; 2
    5f4a:	fc 92       	st	X, r15
    5f4c:	8c e3       	ldi	r24, 0x3C	; 60
    5f4e:	93 e0       	ldi	r25, 0x03	; 3
    5f50:	93 83       	std	Z+3, r25	; 0x03
    5f52:	82 83       	std	Z+2, r24	; 0x02
    5f54:	e4 82       	std	Z+4, r14	; 0x04
    5f56:	15 82       	std	Z+5, r1	; 0x05
    5f58:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
	 _uart_print(1,1,strSend);	 
    5f5c:	ed b7       	in	r30, 0x3d	; 61
    5f5e:	fe b7       	in	r31, 0x3e	; 62
    5f60:	36 96       	adiw	r30, 0x06	; 6
    5f62:	0f b6       	in	r0, 0x3f	; 63
    5f64:	f8 94       	cli
    5f66:	fe bf       	out	0x3e, r31	; 62
    5f68:	0f be       	out	0x3f, r0	; 63
    5f6a:	ed bf       	out	0x3d, r30	; 61
    5f6c:	81 e0       	ldi	r24, 0x01	; 1
    5f6e:	61 e0       	ldi	r22, 0x01	; 1
    5f70:	40 2f       	mov	r20, r16
    5f72:	5f 2d       	mov	r21, r15
    5f74:	0e 94 f2 b3 	call	0x167e4	; 0x167e4 <_uart_print>
}
    5f78:	c0 55       	subi	r28, 0x50	; 80
    5f7a:	df 4f       	sbci	r29, 0xFF	; 255
    5f7c:	0f b6       	in	r0, 0x3f	; 63
    5f7e:	f8 94       	cli
    5f80:	de bf       	out	0x3e, r29	; 62
    5f82:	0f be       	out	0x3f, r0	; 63
    5f84:	cd bf       	out	0x3d, r28	; 61
    5f86:	cf 91       	pop	r28
    5f88:	df 91       	pop	r29
    5f8a:	1f 91       	pop	r17
    5f8c:	0f 91       	pop	r16
    5f8e:	ff 90       	pop	r15
    5f90:	ef 90       	pop	r14
    5f92:	df 90       	pop	r13
    5f94:	cf 90       	pop	r12
    5f96:	bf 90       	pop	r11
    5f98:	af 90       	pop	r10
    5f9a:	9f 90       	pop	r9
    5f9c:	8f 90       	pop	r8
    5f9e:	7f 90       	pop	r7
    5fa0:	6f 90       	pop	r6
    5fa2:	5f 90       	pop	r5
    5fa4:	4f 90       	pop	r4
    5fa6:	3f 90       	pop	r3
    5fa8:	2f 90       	pop	r2
    5faa:	08 95       	ret

00005fac <systemGeniusProtocol>:

void systemGeniusProtocol(){
static char stGeniusProtocol=gpInitScan;
static char iPumpID;
	 
	 switch(stGeniusProtocol){
    5fac:	80 91 dc 01 	lds	r24, 0x01DC
    5fb0:	83 30       	cpi	r24, 0x03	; 3
    5fb2:	71 f1       	breq	.+92     	; 0x6010 <systemGeniusProtocol+0x64>
    5fb4:	84 30       	cpi	r24, 0x04	; 4
    5fb6:	28 f4       	brcc	.+10     	; 0x5fc2 <systemGeniusProtocol+0x16>
    5fb8:	81 30       	cpi	r24, 0x01	; 1
    5fba:	81 f0       	breq	.+32     	; 0x5fdc <systemGeniusProtocol+0x30>
    5fbc:	82 30       	cpi	r24, 0x02	; 2
    5fbe:	c0 f4       	brcc	.+48     	; 0x5ff0 <systemGeniusProtocol+0x44>
    5fc0:	09 c0       	rjmp	.+18     	; 0x5fd4 <systemGeniusProtocol+0x28>
    5fc2:	85 30       	cpi	r24, 0x05	; 5
    5fc4:	09 f4       	brne	.+2      	; 0x5fc8 <systemGeniusProtocol+0x1c>
    5fc6:	49 c0       	rjmp	.+146    	; 0x605a <systemGeniusProtocol+0xae>
    5fc8:	85 30       	cpi	r24, 0x05	; 5
    5fca:	c0 f1       	brcs	.+112    	; 0x603c <systemGeniusProtocol+0x90>
    5fcc:	86 30       	cpi	r24, 0x06	; 6
    5fce:	09 f0       	breq	.+2      	; 0x5fd2 <systemGeniusProtocol+0x26>
    5fd0:	60 c0       	rjmp	.+192    	; 0x6092 <systemGeniusProtocol+0xe6>
    5fd2:	4d c0       	rjmp	.+154    	; 0x606e <systemGeniusProtocol+0xc2>
	 case gpInitScan:
	      iPumpID=1;
    5fd4:	81 e0       	ldi	r24, 0x01	; 1
    5fd6:	80 93 db 01 	sts	0x01DB, r24
    5fda:	46 c0       	rjmp	.+140    	; 0x6068 <systemGeniusProtocol+0xbc>
          stGeniusProtocol=gpScanNewTransaction;
	      break;
	 case gpScanNewTransaction:
	      if (GetIncomingTransStatus(PumpID)==TS_NEW){
    5fdc:	80 91 da 01 	lds	r24, 0x01DA
    5fe0:	0e 94 e3 1a 	call	0x35c6	; 0x35c6 <GetIncomingTransStatus>
    5fe4:	82 30       	cpi	r24, 0x02	; 2
    5fe6:	09 f0       	breq	.+2      	; 0x5fea <systemGeniusProtocol+0x3e>
    5fe8:	54 c0       	rjmp	.+168    	; 0x6092 <systemGeniusProtocol+0xe6>
		      IsTotalizerReceived=False;
    5fea:	10 92 c5 01 	sts	0x01C5, r1
    5fee:	3c c0       	rjmp	.+120    	; 0x6068 <systemGeniusProtocol+0xbc>
		      stGeniusProtocol=gpRequestTotalizer;
		  }
	      break;
     case gpRequestTotalizer:
	      SendPoolingCommand(SC_TOTALIZER,iPumpID);
    5ff0:	90 91 db 01 	lds	r25, 0x01DB
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    5ff4:	85 e0       	ldi	r24, 0x05	; 5
    5ff6:	80 93 8a 07 	sts	0x078A, r24
	 PoolMsg=plMsg;
    5ffa:	90 93 ae 0d 	sts	0x0DAE, r25
     IsControlPooling=True;
    5ffe:	81 e0       	ldi	r24, 0x01	; 1
    6000:	80 93 97 01 	sts	0x0197, r24
		      stGeniusProtocol=gpRequestTotalizer;
		  }
	      break;
     case gpRequestTotalizer:
	      SendPoolingCommand(SC_TOTALIZER,iPumpID);
		  TimSend=0;
    6004:	10 92 a9 01 	sts	0x01A9, r1
    6008:	10 92 a8 01 	sts	0x01A8, r1
		  stGeniusProtocol=gpWaitRequestedTotalizer;
    600c:	83 e0       	ldi	r24, 0x03	; 3
    600e:	2c c0       	rjmp	.+88     	; 0x6068 <systemGeniusProtocol+0xbc>
	      break;
     case gpWaitRequestedTotalizer:
	      if ((IsTotalizerReceived==True)&&(AcknoledgePump==iPumpID)){
    6010:	80 91 c5 01 	lds	r24, 0x01C5
    6014:	81 30       	cpi	r24, 0x01	; 1
    6016:	59 f4       	brne	.+22     	; 0x602e <systemGeniusProtocol+0x82>
    6018:	90 91 c7 0d 	lds	r25, 0x0DC7
    601c:	80 91 db 01 	lds	r24, 0x01DB
    6020:	98 17       	cp	r25, r24
    6022:	29 f4       	brne	.+10     	; 0x602e <systemGeniusProtocol+0x82>
		      IsTotalizerReceived=False;
    6024:	10 92 c5 01 	sts	0x01C5, r1
			  stGeniusProtocol=gpSendTransactionData;
    6028:	84 e0       	ldi	r24, 0x04	; 4
    602a:	80 93 dc 01 	sts	0x01DC, r24
		  }
	      if (TimSend>TIM_SEND*2)stGeniusProtocol=gpNextPumpScan;
    602e:	80 91 a8 01 	lds	r24, 0x01A8
    6032:	90 91 a9 01 	lds	r25, 0x01A9
    6036:	45 97       	sbiw	r24, 0x15	; 21
    6038:	60 f1       	brcs	.+88     	; 0x6092 <systemGeniusProtocol+0xe6>
    603a:	15 c0       	rjmp	.+42     	; 0x6066 <systemGeniusProtocol+0xba>
	      break;
     case gpSendTransactionData:
          GeniusSendLastTransaction(iPumpID);
    603c:	80 91 db 01 	lds	r24, 0x01DB
    6040:	0e 94 c6 2e 	call	0x5d8c	; 0x5d8c <GeniusSendLastTransaction>
		  SetIncomingTransStatus(iPumpID,TS_OLD);
    6044:	80 91 db 01 	lds	r24, 0x01DB
    6048:	63 e0       	ldi	r22, 0x03	; 3
    604a:	0e 94 b1 1a 	call	0x3562	; 0x3562 <SetIncomingTransStatus>
		  
		  TimSend=0;
    604e:	10 92 a9 01 	sts	0x01A9, r1
    6052:	10 92 a8 01 	sts	0x01A8, r1
          stGeniusProtocol=gpDelayNextPumpScan;
    6056:	85 e0       	ldi	r24, 0x05	; 5
    6058:	07 c0       	rjmp	.+14     	; 0x6068 <systemGeniusProtocol+0xbc>
	      break;
     case gpDelayNextPumpScan:
          if (TimSend>1)stGeniusProtocol=gpNextPumpScan;
    605a:	80 91 a8 01 	lds	r24, 0x01A8
    605e:	90 91 a9 01 	lds	r25, 0x01A9
    6062:	02 97       	sbiw	r24, 0x02	; 2
    6064:	b0 f0       	brcs	.+44     	; 0x6092 <systemGeniusProtocol+0xe6>
    6066:	86 e0       	ldi	r24, 0x06	; 6
    6068:	80 93 dc 01 	sts	0x01DC, r24
    606c:	08 95       	ret
	      break;
     case gpNextPumpScan:
          if (iPumpID<=eeprom_read_byte(&DefPoolingPumpMax)){
    606e:	20 91 db 01 	lds	r18, 0x01DB
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    6072:	e1 99       	sbic	0x1c, 1	; 28
    6074:	fe cf       	rjmp	.-4      	; 0x6072 <systemGeniusProtocol+0xc6>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    6076:	84 e4       	ldi	r24, 0x44	; 68
    6078:	91 e0       	ldi	r25, 0x01	; 1
    607a:	9f bb       	out	0x1f, r25	; 31
    607c:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    607e:	e0 9a       	sbi	0x1c, 0	; 28
    6080:	8d b3       	in	r24, 0x1d	; 29
    6082:	82 17       	cp	r24, r18
    6084:	30 f0       	brcs	.+12     	; 0x6092 <systemGeniusProtocol+0xe6>
		      iPumpID++;
    6086:	2f 5f       	subi	r18, 0xFF	; 255
    6088:	20 93 db 01 	sts	0x01DB, r18
              stGeniusProtocol=gpScanNewTransaction;
    608c:	81 e0       	ldi	r24, 0x01	; 1
    608e:	80 93 dc 01 	sts	0x01DC, r24
    6092:	08 95       	ret

00006094 <StrAlignCenter>:
	 }
	 //replace
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrAlignCenter(char *Source, unsigned int Length){
    6094:	ef 92       	push	r14
    6096:	ff 92       	push	r15
    6098:	0f 93       	push	r16
    609a:	1f 93       	push	r17
    609c:	18 2f       	mov	r17, r24
    609e:	09 2f       	mov	r16, r25
    60a0:	7b 01       	movw	r14, r22
char nAddedSpace,srcLength;
     RemSpaceLag(Source);
    60a2:	0e 94 4c 26 	call	0x4c98	; 0x4c98 <RemSpaceLag>
	 RemSpaceLead(Source);
    60a6:	81 2f       	mov	r24, r17
    60a8:	90 2f       	mov	r25, r16
    60aa:	0e 94 01 26 	call	0x4c02	; 0x4c02 <RemSpaceLead>
	 srcLength=strlen(Source);
    60ae:	a1 2f       	mov	r26, r17
    60b0:	b0 2f       	mov	r27, r16
    60b2:	fd 01       	movw	r30, r26
    60b4:	01 90       	ld	r0, Z+
    60b6:	00 20       	and	r0, r0
    60b8:	e9 f7       	brne	.-6      	; 0x60b4 <StrAlignCenter+0x20>
    60ba:	31 97       	sbiw	r30, 0x01	; 1
    60bc:	e1 1b       	sub	r30, r17
     nAddedSpace=(Length-srcLength)/2;
     AddSpaceLead(Source,srcLength+nAddedSpace);
    60be:	c7 01       	movw	r24, r14
    60c0:	8e 1b       	sub	r24, r30
    60c2:	91 09       	sbc	r25, r1
    60c4:	96 95       	lsr	r25
    60c6:	87 95       	ror	r24
    60c8:	e8 0f       	add	r30, r24
    60ca:	81 2f       	mov	r24, r17
    60cc:	90 2f       	mov	r25, r16
    60ce:	6e 2f       	mov	r22, r30
    60d0:	0e 94 d9 2d 	call	0x5bb2	; 0x5bb2 <AddSpaceLead>
	 AddSpaceLag(Source,Length);
    60d4:	81 2f       	mov	r24, r17
    60d6:	90 2f       	mov	r25, r16
    60d8:	6e 2d       	mov	r22, r14
    60da:	0e 94 40 2e 	call	0x5c80	; 0x5c80 <AddSpaceLag>
}
    60de:	1f 91       	pop	r17
    60e0:	0f 91       	pop	r16
    60e2:	ff 90       	pop	r15
    60e4:	ef 90       	pop	r14
    60e6:	08 95       	ret

000060e8 <AddCharLead>:
	 }String[Size]=0;
  }

}

void AddCharLead(char *String,char CharAdded,unsigned char Size){//
    60e8:	bf 92       	push	r11
    60ea:	cf 92       	push	r12
    60ec:	df 92       	push	r13
    60ee:	ef 92       	push	r14
    60f0:	ff 92       	push	r15
    60f2:	0f 93       	push	r16
    60f4:	1f 93       	push	r17
    60f6:	df 93       	push	r29
    60f8:	cf 93       	push	r28
    60fa:	cd b7       	in	r28, 0x3d	; 61
    60fc:	de b7       	in	r29, 0x3e	; 62
    60fe:	6e 97       	sbiw	r28, 0x1e	; 30
    6100:	0f b6       	in	r0, 0x3f	; 63
    6102:	f8 94       	cli
    6104:	de bf       	out	0x3e, r29	; 62
    6106:	0f be       	out	0x3f, r0	; 63
    6108:	cd bf       	out	0x3d, r28	; 61
    610a:	8c 01       	movw	r16, r24
    610c:	e4 2e       	mov	r14, r20
     char i,Length,strAdded[30];
     Length=strlen(String);
    610e:	fc 01       	movw	r30, r24
    6110:	01 90       	ld	r0, Z+
    6112:	00 20       	and	r0, r0
    6114:	e9 f7       	brne	.-6      	; 0x6110 <AddCharLead+0x28>
    6116:	31 97       	sbiw	r30, 0x01	; 1
    6118:	2e 2f       	mov	r18, r30
    611a:	28 1b       	sub	r18, r24

	 if (Size>Length){
    611c:	24 17       	cp	r18, r20
    611e:	d0 f5       	brcc	.+116    	; 0x6194 <AddCharLead+0xac>
    6120:	ae 01       	movw	r20, r28
    6122:	4f 5f       	subi	r20, 0xFF	; 255
    6124:	5f 4f       	sbci	r21, 0xFF	; 255
    6126:	fa 01       	movw	r30, r20
	 }String[Size]=0;
  }

}

void AddCharLead(char *String,char CharAdded,unsigned char Size){//
    6128:	b4 2e       	mov	r11, r20
    612a:	01 c0       	rjmp	.+2      	; 0x612e <AddCharLead+0x46>
     char i,Length,strAdded[30];
     Length=strlen(String);

	 if (Size>Length){
         for(i=0;i<Size;i++){
	         strAdded[i]=CharAdded;
    612c:	61 93       	st	Z+, r22
void AddCharLead(char *String,char CharAdded,unsigned char Size){//
     char i,Length,strAdded[30];
     Length=strlen(String);

	 if (Size>Length){
         for(i=0;i<Size;i++){
    612e:	8e 2f       	mov	r24, r30
    6130:	8b 19       	sub	r24, r11
    6132:	8e 15       	cp	r24, r14
    6134:	d8 f3       	brcs	.-10     	; 0x612c <AddCharLead+0x44>
	         strAdded[i]=CharAdded;
	     }strAdded[Size]=0;
    6136:	6e 2d       	mov	r22, r14
    6138:	70 e0       	ldi	r23, 0x00	; 0
    613a:	ce 01       	movw	r24, r28
    613c:	01 96       	adiw	r24, 0x01	; 1
    613e:	fc 01       	movw	r30, r24
    6140:	e6 0f       	add	r30, r22
    6142:	f7 1f       	adc	r31, r23
    6144:	10 82       	st	Z, r1
	     //Copy
         for(i=(Size-Length);i<Size;i++){
    6146:	fe 2c       	mov	r15, r14
    6148:	f2 1a       	sub	r15, r18
    614a:	6c 01       	movw	r12, r24
	         strAdded[i]=String[i-(Size-Length)];
    614c:	30 e0       	ldi	r19, 0x00	; 0
    614e:	26 1b       	sub	r18, r22
    6150:	37 0b       	sbc	r19, r23
    6152:	0c c0       	rjmp	.+24     	; 0x616c <AddCharLead+0x84>
    6154:	ef 2d       	mov	r30, r15
    6156:	f0 e0       	ldi	r31, 0x00	; 0
    6158:	d6 01       	movw	r26, r12
    615a:	ae 0f       	add	r26, r30
    615c:	bf 1f       	adc	r27, r31
    615e:	e0 0f       	add	r30, r16
    6160:	f1 1f       	adc	r31, r17
    6162:	e2 0f       	add	r30, r18
    6164:	f3 1f       	adc	r31, r19
    6166:	80 81       	ld	r24, Z
    6168:	8c 93       	st	X, r24
	 if (Size>Length){
         for(i=0;i<Size;i++){
	         strAdded[i]=CharAdded;
	     }strAdded[Size]=0;
	     //Copy
         for(i=(Size-Length);i<Size;i++){
    616a:	f3 94       	inc	r15
    616c:	fe 14       	cp	r15, r14
    616e:	90 f3       	brcs	.-28     	; 0x6154 <AddCharLead+0x6c>
	         strAdded[i]=String[i-(Size-Length)];
	     }strAdded[Size]=0;
    6170:	6c 0d       	add	r22, r12
    6172:	7d 1d       	adc	r23, r13
    6174:	db 01       	movw	r26, r22
    6176:	1c 92       	st	X, r1
    6178:	f8 01       	movw	r30, r16
    617a:	04 c0       	rjmp	.+8      	; 0x6184 <AddCharLead+0x9c>
	     //Spaced
         for(i=0;i<Size;i++){
	         String[i]=strAdded[i];
    617c:	da 01       	movw	r26, r20
    617e:	8d 91       	ld	r24, X+
    6180:	ad 01       	movw	r20, r26
    6182:	81 93       	st	Z+, r24
	     //Copy
         for(i=(Size-Length);i<Size;i++){
	         strAdded[i]=String[i-(Size-Length)];
	     }strAdded[Size]=0;
	     //Spaced
         for(i=0;i<Size;i++){
    6184:	84 2f       	mov	r24, r20
    6186:	8b 19       	sub	r24, r11
    6188:	8e 15       	cp	r24, r14
    618a:	c0 f3       	brcs	.-16     	; 0x617c <AddCharLead+0x94>
	         String[i]=strAdded[i];
	     }String[Size]=0;
    618c:	0e 0d       	add	r16, r14
    618e:	11 1d       	adc	r17, r1
    6190:	f8 01       	movw	r30, r16
    6192:	10 82       	st	Z, r1
	 }
}
    6194:	6e 96       	adiw	r28, 0x1e	; 30
    6196:	0f b6       	in	r0, 0x3f	; 63
    6198:	f8 94       	cli
    619a:	de bf       	out	0x3e, r29	; 62
    619c:	0f be       	out	0x3f, r0	; 63
    619e:	cd bf       	out	0x3d, r28	; 61
    61a0:	cf 91       	pop	r28
    61a2:	df 91       	pop	r29
    61a4:	1f 91       	pop	r17
    61a6:	0f 91       	pop	r16
    61a8:	ff 90       	pop	r15
    61aa:	ef 90       	pop	r14
    61ac:	df 90       	pop	r13
    61ae:	cf 90       	pop	r12
    61b0:	bf 90       	pop	r11
    61b2:	08 95       	ret

000061b4 <AddCharLag>:
    }
return Result;
}

//String Processing
void AddCharLag(char *String,char CharAdded,unsigned char Size){
    61b4:	cf 93       	push	r28
    61b6:	df 93       	push	r29
    61b8:	ec 01       	movw	r28, r24
char i,Length;
     Length=strlen(String);
    61ba:	dc 01       	movw	r26, r24
    61bc:	0d 90       	ld	r0, X+
    61be:	00 20       	and	r0, r0
    61c0:	e9 f7       	brne	.-6      	; 0x61bc <AddCharLag+0x8>
    61c2:	11 97       	sbiw	r26, 0x01	; 1
    61c4:	a8 1b       	sub	r26, r24
    61c6:	b9 0b       	sbc	r27, r25
  if (Length<Size){   
    61c8:	a4 17       	cp	r26, r20
    61ca:	58 f4       	brcc	.+22     	; 0x61e2 <AddCharLag+0x2e>
    61cc:	8a 2f       	mov	r24, r26
     for(i=Length;i<Size;i++){
	    String[i]=CharAdded;
    61ce:	fe 01       	movw	r30, r28
    61d0:	e8 0f       	add	r30, r24
    61d2:	f1 1d       	adc	r31, r1
    61d4:	60 83       	st	Z, r22
//String Processing
void AddCharLag(char *String,char CharAdded,unsigned char Size){
char i,Length;
     Length=strlen(String);
  if (Length<Size){   
     for(i=Length;i<Size;i++){
    61d6:	8f 5f       	subi	r24, 0xFF	; 255
    61d8:	84 17       	cp	r24, r20
    61da:	c8 f3       	brcs	.-14     	; 0x61ce <AddCharLag+0x1a>
	    String[i]=CharAdded;
	 }String[Size]=0;
    61dc:	c4 0f       	add	r28, r20
    61de:	d1 1d       	adc	r29, r1
    61e0:	18 82       	st	Y, r1
  }

}
    61e2:	df 91       	pop	r29
    61e4:	cf 91       	pop	r28
    61e6:	08 95       	ret

000061e8 <CountTotalizerSatus>:
		      Result++;		  
		  }	 
	 }
  return Result;
}
char CountTotalizerSatus(char *strPumpStatusTotalizer){
    61e8:	cf 92       	push	r12
    61ea:	df 92       	push	r13
    61ec:	ef 92       	push	r14
    61ee:	ff 92       	push	r15
    61f0:	0f 93       	push	r16
    61f2:	1f 93       	push	r17
    61f4:	cf 93       	push	r28
    61f6:	df 93       	push	r29
    61f8:	7c 01       	movw	r14, r24
char i,Result;
     Result=0;
	 for (i=0;i<strlen(strPumpStatusTotalizer);i++){
    61fa:	dc 01       	movw	r26, r24
    61fc:	0d 90       	ld	r0, X+
    61fe:	00 20       	and	r0, r0
    6200:	e9 f7       	brne	.-6      	; 0x61fc <CountTotalizerSatus+0x14>
    6202:	8d 01       	movw	r16, r26
    6204:	01 50       	subi	r16, 0x01	; 1
    6206:	10 40       	sbci	r17, 0x00	; 0
    6208:	08 1b       	sub	r16, r24
    620a:	19 0b       	sbc	r17, r25
    620c:	cc 24       	eor	r12, r12
    620e:	dd 24       	eor	r13, r13
    6210:	0a c0       	rjmp	.+20     	; 0x6226 <CountTotalizerSatus+0x3e>
	      if (strPumpStatusTotalizer[i]==GetPumpStatusLabel(PS_TOTALIZER)){
    6212:	84 e1       	ldi	r24, 0x14	; 20
    6214:	0e 94 93 13 	call	0x2726	; 0x2726 <GetPumpStatusLabel>
    6218:	ce 0d       	add	r28, r14
    621a:	df 1d       	adc	r29, r15
    621c:	98 81       	ld	r25, Y
    621e:	98 17       	cp	r25, r24
    6220:	09 f4       	brne	.+2      	; 0x6224 <CountTotalizerSatus+0x3c>
		      Result++;		  
    6222:	d3 94       	inc	r13
  return Result;
}
char CountTotalizerSatus(char *strPumpStatusTotalizer){
char i,Result;
     Result=0;
	 for (i=0;i<strlen(strPumpStatusTotalizer);i++){
    6224:	c3 94       	inc	r12
    6226:	cc 2d       	mov	r28, r12
    6228:	d0 e0       	ldi	r29, 0x00	; 0
    622a:	c0 17       	cp	r28, r16
    622c:	d1 07       	cpc	r29, r17
    622e:	88 f3       	brcs	.-30     	; 0x6212 <CountTotalizerSatus+0x2a>
	      if (strPumpStatusTotalizer[i]==GetPumpStatusLabel(PS_TOTALIZER)){
		      Result++;		  
		  }	 
	 }
  return Result;
}
    6230:	8d 2d       	mov	r24, r13
    6232:	df 91       	pop	r29
    6234:	cf 91       	pop	r28
    6236:	1f 91       	pop	r17
    6238:	0f 91       	pop	r16
    623a:	ff 90       	pop	r15
    623c:	ef 90       	pop	r14
    623e:	df 90       	pop	r13
    6240:	cf 90       	pop	r12
    6242:	08 95       	ret

00006244 <RemoveChar>:
	   sprintf_P(strSend,PSTR("Wrap:%s"),strDestCode);
	   _uart_print(1,1,strSend);     
	 #endif
}

void RemoveChar(char *strSource, char cRem){
    6244:	1f 93       	push	r17
    6246:	df 93       	push	r29
    6248:	cf 93       	push	r28
    624a:	cd b7       	in	r28, 0x3d	; 61
    624c:	de b7       	in	r29, 0x3e	; 62
    624e:	64 97       	sbiw	r28, 0x14	; 20
    6250:	0f b6       	in	r0, 0x3f	; 63
    6252:	f8 94       	cli
    6254:	de bf       	out	0x3e, r29	; 62
    6256:	0f be       	out	0x3f, r0	; 63
    6258:	cd bf       	out	0x3d, r28	; 61
    625a:	16 2f       	mov	r17, r22
    625c:	50 e0       	ldi	r21, 0x00	; 0
    625e:	40 e0       	ldi	r20, 0x00	; 0
     char i,iAdd,sTemp[20];
     iAdd=0;
	 for(i=0;i<strlen(strSource);i++){
	     if (strSource[i]!=cRem){
		     sTemp[iAdd]=strSource[i];
    6260:	be 01       	movw	r22, r28
    6262:	6f 5f       	subi	r22, 0xFF	; 255
    6264:	7f 4f       	sbci	r23, 0xFF	; 255
    6266:	0c c0       	rjmp	.+24     	; 0x6280 <RemoveChar+0x3c>

void RemoveChar(char *strSource, char cRem){
     char i,iAdd,sTemp[20];
     iAdd=0;
	 for(i=0;i<strlen(strSource);i++){
	     if (strSource[i]!=cRem){
    6268:	28 0f       	add	r18, r24
    626a:	39 1f       	adc	r19, r25
    626c:	d9 01       	movw	r26, r18
    626e:	2c 91       	ld	r18, X
    6270:	21 17       	cp	r18, r17
    6272:	29 f0       	breq	.+10     	; 0x627e <RemoveChar+0x3a>
		     sTemp[iAdd]=strSource[i];
    6274:	fb 01       	movw	r30, r22
    6276:	e4 0f       	add	r30, r20
    6278:	f1 1d       	adc	r31, r1
    627a:	20 83       	st	Z, r18
			 iAdd++;
    627c:	4f 5f       	subi	r20, 0xFF	; 255
}

void RemoveChar(char *strSource, char cRem){
     char i,iAdd,sTemp[20];
     iAdd=0;
	 for(i=0;i<strlen(strSource);i++){
    627e:	5f 5f       	subi	r21, 0xFF	; 255
    6280:	25 2f       	mov	r18, r21
    6282:	30 e0       	ldi	r19, 0x00	; 0
    6284:	fc 01       	movw	r30, r24
    6286:	01 90       	ld	r0, Z+
    6288:	00 20       	and	r0, r0
    628a:	e9 f7       	brne	.-6      	; 0x6286 <RemoveChar+0x42>
    628c:	31 97       	sbiw	r30, 0x01	; 1
    628e:	e8 1b       	sub	r30, r24
    6290:	f9 0b       	sbc	r31, r25
    6292:	2e 17       	cp	r18, r30
    6294:	3f 07       	cpc	r19, r31
    6296:	40 f3       	brcs	.-48     	; 0x6268 <RemoveChar+0x24>
	     if (strSource[i]!=cRem){
		     sTemp[iAdd]=strSource[i];
			 iAdd++;
          }
	 }sTemp[iAdd]=0;
    6298:	9e 01       	movw	r18, r28
    629a:	2f 5f       	subi	r18, 0xFF	; 255
    629c:	3f 4f       	sbci	r19, 0xFF	; 255
    629e:	f9 01       	movw	r30, r18
    62a0:	e4 0f       	add	r30, r20
    62a2:	f1 1d       	adc	r31, r1
    62a4:	10 82       	st	Z, r1
	 sprintf_P(strSource,PSTR("%s"),sTemp);
    62a6:	00 d0       	rcall	.+0      	; 0x62a8 <RemoveChar+0x64>
    62a8:	00 d0       	rcall	.+0      	; 0x62aa <RemoveChar+0x66>
    62aa:	00 d0       	rcall	.+0      	; 0x62ac <RemoveChar+0x68>
    62ac:	ed b7       	in	r30, 0x3d	; 61
    62ae:	fe b7       	in	r31, 0x3e	; 62
    62b0:	31 96       	adiw	r30, 0x01	; 1
    62b2:	ad b7       	in	r26, 0x3d	; 61
    62b4:	be b7       	in	r27, 0x3e	; 62
    62b6:	12 96       	adiw	r26, 0x02	; 2
    62b8:	9c 93       	st	X, r25
    62ba:	8e 93       	st	-X, r24
    62bc:	11 97       	sbiw	r26, 0x01	; 1
    62be:	86 eb       	ldi	r24, 0xB6	; 182
    62c0:	97 e1       	ldi	r25, 0x17	; 23
    62c2:	93 83       	std	Z+3, r25	; 0x03
    62c4:	82 83       	std	Z+2, r24	; 0x02
    62c6:	35 83       	std	Z+5, r19	; 0x05
    62c8:	24 83       	std	Z+4, r18	; 0x04
    62ca:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    62ce:	ed b7       	in	r30, 0x3d	; 61
    62d0:	fe b7       	in	r31, 0x3e	; 62
    62d2:	36 96       	adiw	r30, 0x06	; 6
    62d4:	0f b6       	in	r0, 0x3f	; 63
    62d6:	f8 94       	cli
    62d8:	fe bf       	out	0x3e, r31	; 62
    62da:	0f be       	out	0x3f, r0	; 63
    62dc:	ed bf       	out	0x3d, r30	; 61
}
    62de:	64 96       	adiw	r28, 0x14	; 20
    62e0:	0f b6       	in	r0, 0x3f	; 63
    62e2:	f8 94       	cli
    62e4:	de bf       	out	0x3e, r29	; 62
    62e6:	0f be       	out	0x3f, r0	; 63
    62e8:	cd bf       	out	0x3d, r28	; 61
    62ea:	cf 91       	pop	r28
    62ec:	df 91       	pop	r29
    62ee:	1f 91       	pop	r17
    62f0:	08 95       	ret

000062f2 <WrapCode>:
	      break;
	 }
   return Result;
}

void WrapCode(char *strRawCode){
    62f2:	8f 92       	push	r8
    62f4:	9f 92       	push	r9
    62f6:	bf 92       	push	r11
    62f8:	cf 92       	push	r12
    62fa:	df 92       	push	r13
    62fc:	ef 92       	push	r14
    62fe:	ff 92       	push	r15
    6300:	0f 93       	push	r16
    6302:	1f 93       	push	r17
    6304:	df 93       	push	r29
    6306:	cf 93       	push	r28
    6308:	cd b7       	in	r28, 0x3d	; 61
    630a:	de b7       	in	r29, 0x3e	; 62
    630c:	2f 97       	sbiw	r28, 0x0f	; 15
    630e:	0f b6       	in	r0, 0x3f	; 63
    6310:	f8 94       	cli
    6312:	de bf       	out	0x3e, r29	; 62
    6314:	0f be       	out	0x3f, r0	; 63
    6316:	cd bf       	out	0x3d, r28	; 61
    6318:	6c 01       	movw	r12, r24
    631a:	bb 24       	eor	r11, r11
    631c:	40 e0       	ldi	r20, 0x00	; 0
    631e:	4e 01       	movw	r8, r28
    6320:	08 94       	sec
    6322:	81 1c       	adc	r8, r1
    6324:	91 1c       	adc	r9, r1
    6326:	12 c0       	rjmp	.+36     	; 0x634c <WrapCode+0x5a>
     char i,seedKey;
	 char strTemp[15];
	 //62678677 ->68846445
	 seedKey=0;
	 for (i=0;i<strlen(strRawCode);i++){
	      strTemp[i]='0'+GeniusCalc(G_PLUS,(strRawCode[i]-'0'),seedKey);
    6328:	86 01       	movw	r16, r12
    632a:	0e 0d       	add	r16, r14
    632c:	1f 1d       	adc	r17, r15
    632e:	d8 01       	movw	r26, r16
    6330:	6c 91       	ld	r22, X
    6332:	60 53       	subi	r22, 0x30	; 48
    6334:	80 e0       	ldi	r24, 0x00	; 0
    6336:	0e 94 5d 16 	call	0x2cba	; 0x2cba <GeniusCalc>
    633a:	e8 0c       	add	r14, r8
    633c:	f9 1c       	adc	r15, r9
    633e:	80 5d       	subi	r24, 0xD0	; 208
    6340:	f7 01       	movw	r30, r14
    6342:	80 83       	st	Z, r24
		  seedKey=strRawCode[i]-'0';
    6344:	d8 01       	movw	r26, r16
    6346:	4c 91       	ld	r20, X
    6348:	40 53       	subi	r20, 0x30	; 48
void WrapCode(char *strRawCode){
     char i,seedKey;
	 char strTemp[15];
	 //62678677 ->68846445
	 seedKey=0;
	 for (i=0;i<strlen(strRawCode);i++){
    634a:	b3 94       	inc	r11
    634c:	eb 2c       	mov	r14, r11
    634e:	ff 24       	eor	r15, r15
    6350:	d6 01       	movw	r26, r12
    6352:	0d 90       	ld	r0, X+
    6354:	00 20       	and	r0, r0
    6356:	e9 f7       	brne	.-6      	; 0x6352 <WrapCode+0x60>
    6358:	11 97       	sbiw	r26, 0x01	; 1
    635a:	ac 19       	sub	r26, r12
    635c:	bd 09       	sbc	r27, r13
    635e:	ea 16       	cp	r14, r26
    6360:	fb 06       	cpc	r15, r27
    6362:	10 f3       	brcs	.-60     	; 0x6328 <WrapCode+0x36>
	      strTemp[i]='0'+GeniusCalc(G_PLUS,(strRawCode[i]-'0'),seedKey);
		  seedKey=strRawCode[i]-'0';
	 }strTemp[strlen(strRawCode)]=0;
    6364:	a8 0d       	add	r26, r8
    6366:	b9 1d       	adc	r27, r9
    6368:	1c 92       	st	X, r1
     sprintf_P(strRawCode,PSTR("%s"),strTemp);
    636a:	00 d0       	rcall	.+0      	; 0x636c <WrapCode+0x7a>
    636c:	00 d0       	rcall	.+0      	; 0x636e <WrapCode+0x7c>
    636e:	00 d0       	rcall	.+0      	; 0x6370 <WrapCode+0x7e>
    6370:	ed b7       	in	r30, 0x3d	; 61
    6372:	fe b7       	in	r31, 0x3e	; 62
    6374:	31 96       	adiw	r30, 0x01	; 1
    6376:	ad b7       	in	r26, 0x3d	; 61
    6378:	be b7       	in	r27, 0x3e	; 62
    637a:	12 96       	adiw	r26, 0x02	; 2
    637c:	dc 92       	st	X, r13
    637e:	ce 92       	st	-X, r12
    6380:	11 97       	sbiw	r26, 0x01	; 1
    6382:	81 ec       	ldi	r24, 0xC1	; 193
    6384:	97 e1       	ldi	r25, 0x17	; 23
    6386:	93 83       	std	Z+3, r25	; 0x03
    6388:	82 83       	std	Z+2, r24	; 0x02
    638a:	95 82       	std	Z+5, r9	; 0x05
    638c:	84 82       	std	Z+4, r8	; 0x04
    638e:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    6392:	ed b7       	in	r30, 0x3d	; 61
    6394:	fe b7       	in	r31, 0x3e	; 62
    6396:	36 96       	adiw	r30, 0x06	; 6
    6398:	0f b6       	in	r0, 0x3f	; 63
    639a:	f8 94       	cli
    639c:	fe bf       	out	0x3e, r31	; 62
    639e:	0f be       	out	0x3f, r0	; 63
    63a0:	ed bf       	out	0x3d, r30	; 61
}
    63a2:	2f 96       	adiw	r28, 0x0f	; 15
    63a4:	0f b6       	in	r0, 0x3f	; 63
    63a6:	f8 94       	cli
    63a8:	de bf       	out	0x3e, r29	; 62
    63aa:	0f be       	out	0x3f, r0	; 63
    63ac:	cd bf       	out	0x3d, r28	; 61
    63ae:	cf 91       	pop	r28
    63b0:	df 91       	pop	r29
    63b2:	1f 91       	pop	r17
    63b4:	0f 91       	pop	r16
    63b6:	ff 90       	pop	r15
    63b8:	ef 90       	pop	r14
    63ba:	df 90       	pop	r13
    63bc:	cf 90       	pop	r12
    63be:	bf 90       	pop	r11
    63c0:	9f 90       	pop	r9
    63c2:	8f 90       	pop	r8
    63c4:	08 95       	ret

000063c6 <GenerateKeyStamp>:


   return Result;
}

void GenerateKeyStamp(char *sTime, char *sGCode, char *strKeyStamp){//
    63c6:	8f 92       	push	r8
    63c8:	9f 92       	push	r9
    63ca:	af 92       	push	r10
    63cc:	bf 92       	push	r11
    63ce:	df 92       	push	r13
    63d0:	ef 92       	push	r14
    63d2:	ff 92       	push	r15
    63d4:	0f 93       	push	r16
    63d6:	1f 93       	push	r17
    63d8:	df 93       	push	r29
    63da:	cf 93       	push	r28
    63dc:	cd b7       	in	r28, 0x3d	; 61
    63de:	de b7       	in	r29, 0x3e	; 62
    63e0:	2d 97       	sbiw	r28, 0x0d	; 13
    63e2:	0f b6       	in	r0, 0x3f	; 63
    63e4:	f8 94       	cli
    63e6:	de bf       	out	0x3e, r29	; 62
    63e8:	0f be       	out	0x3f, r0	; 63
    63ea:	cd bf       	out	0x3d, r28	; 61
    63ec:	9c 01       	movw	r18, r24
    63ee:	7b 01       	movw	r14, r22
    63f0:	5a 01       	movw	r10, r20
	             65585577
	 */
     char seedIdx,sSeed[10],sAdd[3],i;
     
	 seedIdx=(sTime[5]-'0')%8; 
	 sAdd[0]=sGCode[seedIdx];
    63f2:	dc 01       	movw	r26, r24
    63f4:	15 96       	adiw	r26, 0x05	; 5
    63f6:	8c 91       	ld	r24, X
    63f8:	90 e0       	ldi	r25, 0x00	; 0
    63fa:	c0 97       	sbiw	r24, 0x30	; 48
    63fc:	68 e0       	ldi	r22, 0x08	; 8
    63fe:	70 e0       	ldi	r23, 0x00	; 0
    6400:	0e 94 a7 b8 	call	0x1714e	; 0x1714e <__divmodhi4>
    6404:	f7 01       	movw	r30, r14
    6406:	e8 0f       	add	r30, r24
    6408:	f1 1d       	adc	r31, r1
    640a:	80 81       	ld	r24, Z
    640c:	89 83       	std	Y+1, r24	; 0x01
     seedIdx=(sTime[6]-'0')%8;
	 sAdd[1]=sGCode[seedIdx];
    640e:	f9 01       	movw	r30, r18
    6410:	86 81       	ldd	r24, Z+6	; 0x06
    6412:	90 e0       	ldi	r25, 0x00	; 0
    6414:	c0 97       	sbiw	r24, 0x30	; 48
    6416:	68 e0       	ldi	r22, 0x08	; 8
    6418:	70 e0       	ldi	r23, 0x00	; 0
    641a:	0e 94 a7 b8 	call	0x1714e	; 0x1714e <__divmodhi4>
    641e:	f7 01       	movw	r30, r14
    6420:	e8 0f       	add	r30, r24
    6422:	f1 1d       	adc	r31, r1
    6424:	80 81       	ld	r24, Z
    6426:	8a 83       	std	Y+2, r24	; 0x02
	 sAdd[2]=0;
    6428:	1b 82       	std	Y+3, r1	; 0x03

	 sprintf_P(sSeed,PSTR("%s%s"),sTime,sAdd);
    642a:	8d b7       	in	r24, 0x3d	; 61
    642c:	9e b7       	in	r25, 0x3e	; 62
    642e:	08 97       	sbiw	r24, 0x08	; 8
    6430:	0f b6       	in	r0, 0x3f	; 63
    6432:	f8 94       	cli
    6434:	9e bf       	out	0x3e, r25	; 62
    6436:	0f be       	out	0x3f, r0	; 63
    6438:	8d bf       	out	0x3d, r24	; 61
    643a:	ed b7       	in	r30, 0x3d	; 61
    643c:	fe b7       	in	r31, 0x3e	; 62
    643e:	31 96       	adiw	r30, 0x01	; 1
    6440:	8e 01       	movw	r16, r28
    6442:	0c 5f       	subi	r16, 0xFC	; 252
    6444:	1f 4f       	sbci	r17, 0xFF	; 255
    6446:	ad b7       	in	r26, 0x3d	; 61
    6448:	be b7       	in	r27, 0x3e	; 62
    644a:	12 96       	adiw	r26, 0x02	; 2
    644c:	1c 93       	st	X, r17
    644e:	0e 93       	st	-X, r16
    6450:	11 97       	sbiw	r26, 0x01	; 1
    6452:	81 eb       	ldi	r24, 0xB1	; 177
    6454:	97 e1       	ldi	r25, 0x17	; 23
    6456:	93 83       	std	Z+3, r25	; 0x03
    6458:	82 83       	std	Z+2, r24	; 0x02
    645a:	35 83       	std	Z+5, r19	; 0x05
    645c:	24 83       	std	Z+4, r18	; 0x04
    645e:	ce 01       	movw	r24, r28
    6460:	01 96       	adiw	r24, 0x01	; 1
    6462:	97 83       	std	Z+7, r25	; 0x07
    6464:	86 83       	std	Z+6, r24	; 0x06
    6466:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    646a:	dd 24       	eor	r13, r13
    646c:	ed b7       	in	r30, 0x3d	; 61
    646e:	fe b7       	in	r31, 0x3e	; 62
    6470:	38 96       	adiw	r30, 0x08	; 8
    6472:	0f b6       	in	r0, 0x3f	; 63
    6474:	f8 94       	cli
    6476:	fe bf       	out	0x3e, r31	; 62
    6478:	0f be       	out	0x3f, r0	; 63
    647a:	ed bf       	out	0x3d, r30	; 61
     for(i=0;i<strlen(sGCode);i++){
	     strKeyStamp[i]='0'+GeniusCalc(G_MULTY,(sSeed[i]-'0'),(sGCode[i]-'0'));		 
    647c:	48 01       	movw	r8, r16
    647e:	13 c0       	rjmp	.+38     	; 0x64a6 <GenerateKeyStamp+0xe0>
    6480:	f4 01       	movw	r30, r8
    6482:	e0 0f       	add	r30, r16
    6484:	f1 1f       	adc	r31, r17
    6486:	60 81       	ld	r22, Z
    6488:	60 53       	subi	r22, 0x30	; 48
    648a:	f7 01       	movw	r30, r14
    648c:	e0 0f       	add	r30, r16
    648e:	f1 1f       	adc	r31, r17
    6490:	40 81       	ld	r20, Z
    6492:	40 53       	subi	r20, 0x30	; 48
    6494:	81 e0       	ldi	r24, 0x01	; 1
    6496:	0e 94 5d 16 	call	0x2cba	; 0x2cba <GeniusCalc>
    649a:	0a 0d       	add	r16, r10
    649c:	1b 1d       	adc	r17, r11
    649e:	80 5d       	subi	r24, 0xD0	; 208
    64a0:	d8 01       	movw	r26, r16
    64a2:	8c 93       	st	X, r24
     seedIdx=(sTime[6]-'0')%8;
	 sAdd[1]=sGCode[seedIdx];
	 sAdd[2]=0;

	 sprintf_P(sSeed,PSTR("%s%s"),sTime,sAdd);
     for(i=0;i<strlen(sGCode);i++){
    64a4:	d3 94       	inc	r13
    64a6:	0d 2d       	mov	r16, r13
    64a8:	10 e0       	ldi	r17, 0x00	; 0
    64aa:	d7 01       	movw	r26, r14
    64ac:	0d 90       	ld	r0, X+
    64ae:	00 20       	and	r0, r0
    64b0:	e9 f7       	brne	.-6      	; 0x64ac <GenerateKeyStamp+0xe6>
    64b2:	11 97       	sbiw	r26, 0x01	; 1
    64b4:	ae 19       	sub	r26, r14
    64b6:	bf 09       	sbc	r27, r15
    64b8:	0a 17       	cp	r16, r26
    64ba:	1b 07       	cpc	r17, r27
    64bc:	08 f3       	brcs	.-62     	; 0x6480 <GenerateKeyStamp+0xba>
	     strKeyStamp[i]='0'+GeniusCalc(G_MULTY,(sSeed[i]-'0'),(sGCode[i]-'0'));		 
	 }strKeyStamp[strlen(sGCode)]=0;
    64be:	aa 0d       	add	r26, r10
    64c0:	bb 1d       	adc	r27, r11
    64c2:	1c 92       	st	X, r1
     WrapCode(strKeyStamp);
    64c4:	c5 01       	movw	r24, r10
    64c6:	0e 94 79 31 	call	0x62f2	; 0x62f2 <WrapCode>
}
    64ca:	2d 96       	adiw	r28, 0x0d	; 13
    64cc:	0f b6       	in	r0, 0x3f	; 63
    64ce:	f8 94       	cli
    64d0:	de bf       	out	0x3e, r29	; 62
    64d2:	0f be       	out	0x3f, r0	; 63
    64d4:	cd bf       	out	0x3d, r28	; 61
    64d6:	cf 91       	pop	r28
    64d8:	df 91       	pop	r29
    64da:	1f 91       	pop	r17
    64dc:	0f 91       	pop	r16
    64de:	ff 90       	pop	r15
    64e0:	ef 90       	pop	r14
    64e2:	df 90       	pop	r13
    64e4:	bf 90       	pop	r11
    64e6:	af 90       	pop	r10
    64e8:	9f 90       	pop	r9
    64ea:	8f 90       	pop	r8
    64ec:	08 95       	ret

000064ee <GenerateGeniusCode>:
		  seedKey=strRawCode[i]-'0';
	 }strTemp[strlen(strRawCode)]=0;
     sprintf_P(strRawCode,PSTR("%s"),strTemp);
}

void GenerateGeniusCode(char *srcDate, char cSeed, char *strDestCode){
    64ee:	af 92       	push	r10
    64f0:	bf 92       	push	r11
    64f2:	cf 92       	push	r12
    64f4:	df 92       	push	r13
    64f6:	ef 92       	push	r14
    64f8:	ff 92       	push	r15
    64fa:	0f 93       	push	r16
    64fc:	1f 93       	push	r17
    64fe:	df 93       	push	r29
    6500:	cf 93       	push	r28
    6502:	cd b7       	in	r28, 0x3d	; 61
    6504:	de b7       	in	r29, 0x3e	; 62
    6506:	28 97       	sbiw	r28, 0x08	; 8
    6508:	0f b6       	in	r0, 0x3f	; 63
    650a:	f8 94       	cli
    650c:	de bf       	out	0x3e, r29	; 62
    650e:	0f be       	out	0x3f, r0	; 63
    6510:	cd bf       	out	0x3d, r28	; 61
    6512:	7c 01       	movw	r14, r24
    6514:	c6 2e       	mov	r12, r22
    6516:	5a 01       	movw	r10, r20
	    sprintf_P(strSend,PSTR("Date[%s]"),srcDate);
		_uart_print(1,1,strSend);
     #endif
    

	 StrPosCopy(srcDate,AddYear,strlen(srcDate)-2,2);
    6518:	fc 01       	movw	r30, r24
    651a:	01 90       	ld	r0, Z+
    651c:	00 20       	and	r0, r0
    651e:	e9 f7       	brne	.-6      	; 0x651a <GenerateGeniusCode+0x2c>
    6520:	e8 1b       	sub	r30, r24
    6522:	f9 0b       	sbc	r31, r25
    6524:	33 97       	sbiw	r30, 0x03	; 3
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    6526:	e8 0f       	add	r30, r24
    6528:	f9 1f       	adc	r31, r25
    652a:	80 81       	ld	r24, Z
    652c:	89 83       	std	Y+1, r24	; 0x01
    652e:	81 81       	ldd	r24, Z+1	; 0x01
    6530:	8a 83       	std	Y+2, r24	; 0x02
	 }Dest[Length]=0;
    6532:	1b 82       	std	Y+3, r1	; 0x03
    #ifdef DEBUG_GENIUS_CODE
	    sprintf_P(strSend,PSTR("Year:[%s]"),AddYear);
		_uart_print(1,1,strSend);
     #endif

	 sprintf_P(SYear,PSTR("20%s"),AddYear);
    6534:	00 d0       	rcall	.+0      	; 0x6536 <GenerateGeniusCode+0x48>
    6536:	00 d0       	rcall	.+0      	; 0x6538 <GenerateGeniusCode+0x4a>
    6538:	00 d0       	rcall	.+0      	; 0x653a <GenerateGeniusCode+0x4c>
    653a:	ed b7       	in	r30, 0x3d	; 61
    653c:	fe b7       	in	r31, 0x3e	; 62
    653e:	31 96       	adiw	r30, 0x01	; 1
    6540:	8e 01       	movw	r16, r28
    6542:	0c 5f       	subi	r16, 0xFC	; 252
    6544:	1f 4f       	sbci	r17, 0xFF	; 255
    6546:	ad b7       	in	r26, 0x3d	; 61
    6548:	be b7       	in	r27, 0x3e	; 62
    654a:	12 96       	adiw	r26, 0x02	; 2
    654c:	1c 93       	st	X, r17
    654e:	0e 93       	st	-X, r16
    6550:	11 97       	sbiw	r26, 0x01	; 1
    6552:	8c eb       	ldi	r24, 0xBC	; 188
    6554:	97 e1       	ldi	r25, 0x17	; 23
    6556:	93 83       	std	Z+3, r25	; 0x03
    6558:	82 83       	std	Z+2, r24	; 0x02
    655a:	ce 01       	movw	r24, r28
    655c:	01 96       	adiw	r24, 0x01	; 1
    655e:	95 83       	std	Z+5, r25	; 0x05
    6560:	84 83       	std	Z+4, r24	; 0x04
    6562:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
	 StrPosPaste(SYear,srcDate,strlen(srcDate)-2,strlen(SYear));
    6566:	d7 01       	movw	r26, r14
    6568:	0d 90       	ld	r0, X+
    656a:	00 20       	and	r0, r0
    656c:	e9 f7       	brne	.-6      	; 0x6568 <GenerateGeniusCode+0x7a>
    656e:	9d 01       	movw	r18, r26
    6570:	21 50       	subi	r18, 0x01	; 1
    6572:	30 40       	sbci	r19, 0x00	; 0
    6574:	2e 19       	sub	r18, r14
    6576:	3f 09       	sbc	r19, r15
    6578:	d8 01       	movw	r26, r16
    657a:	0d 90       	ld	r0, X+
    657c:	00 20       	and	r0, r0
    657e:	e9 f7       	brne	.-6      	; 0x657a <GenerateGeniusCode+0x8c>
    6580:	11 97       	sbiw	r26, 0x01	; 1
    6582:	a0 1b       	sub	r26, r16
    6584:	b1 0b       	sbc	r27, r17
    6586:	22 50       	subi	r18, 0x02	; 2
    6588:	30 40       	sbci	r19, 0x00	; 0
    658a:	b7 01       	movw	r22, r14
    658c:	62 0f       	add	r22, r18
    658e:	73 1f       	adc	r23, r19
    6590:	2e 5f       	subi	r18, 0xFE	; 254
    6592:	3f 4f       	sbci	r19, 0xFF	; 255
    6594:	40 e0       	ldi	r20, 0x00	; 0
    6596:	50 e0       	ldi	r21, 0x00	; 0
    6598:	ed b7       	in	r30, 0x3d	; 61
    659a:	fe b7       	in	r31, 0x3e	; 62
    659c:	36 96       	adiw	r30, 0x06	; 6
    659e:	0f b6       	in	r0, 0x3f	; 63
    65a0:	f8 94       	cli
    65a2:	fe bf       	out	0x3e, r31	; 62
    65a4:	0f be       	out	0x3f, r0	; 63
    65a6:	ed bf       	out	0x3d, r30	; 61
    65a8:	09 c0       	rjmp	.+18     	; 0x65bc <GenerateGeniusCode+0xce>
	 }Dest[Length]=0;
}
void StrPosPaste(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[IdxSource+i]=Source[i];
    65aa:	f8 01       	movw	r30, r16
    65ac:	e4 0f       	add	r30, r20
    65ae:	f5 1f       	adc	r31, r21
    65b0:	80 81       	ld	r24, Z
    65b2:	fb 01       	movw	r30, r22
    65b4:	81 93       	st	Z+, r24
    65b6:	bf 01       	movw	r22, r30
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
}
void StrPosPaste(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    65b8:	4f 5f       	subi	r20, 0xFF	; 255
    65ba:	5f 4f       	sbci	r21, 0xFF	; 255
    65bc:	4a 17       	cp	r20, r26
    65be:	5b 07       	cpc	r21, r27
    65c0:	a0 f3       	brcs	.-24     	; 0x65aa <GenerateGeniusCode+0xbc>
	    Dest[IdxSource+i]=Source[i];
	 }Dest[IdxSource+Length]=0;
    65c2:	ae 0d       	add	r26, r14
    65c4:	bf 1d       	adc	r27, r15
    65c6:	a2 0f       	add	r26, r18
    65c8:	b3 1f       	adc	r27, r19
    65ca:	12 97       	sbiw	r26, 0x02	; 2
    65cc:	1c 92       	st	X, r1
	 #ifdef DEBUG_GENIUS_CODE
	    sprintf_P(strSend,PSTR("NewDate[%s]"),srcDate);
		_uart_print(1,1,strSend);
     #endif

	 sprintf_P(strDestCode,PSTR("%c"),cSeed);     
    65ce:	00 d0       	rcall	.+0      	; 0x65d0 <GenerateGeniusCode+0xe2>
    65d0:	00 d0       	rcall	.+0      	; 0x65d2 <GenerateGeniusCode+0xe4>
    65d2:	00 d0       	rcall	.+0      	; 0x65d4 <GenerateGeniusCode+0xe6>
    65d4:	ed b7       	in	r30, 0x3d	; 61
    65d6:	fe b7       	in	r31, 0x3e	; 62
    65d8:	31 96       	adiw	r30, 0x01	; 1
    65da:	ad b7       	in	r26, 0x3d	; 61
    65dc:	be b7       	in	r27, 0x3e	; 62
    65de:	12 96       	adiw	r26, 0x02	; 2
    65e0:	bc 92       	st	X, r11
    65e2:	ae 92       	st	-X, r10
    65e4:	11 97       	sbiw	r26, 0x01	; 1
    65e6:	89 eb       	ldi	r24, 0xB9	; 185
    65e8:	97 e1       	ldi	r25, 0x17	; 23
    65ea:	93 83       	std	Z+3, r25	; 0x03
    65ec:	82 83       	std	Z+2, r24	; 0x02
    65ee:	c4 82       	std	Z+4, r12	; 0x04
    65f0:	15 82       	std	Z+5, r1	; 0x05
    65f2:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    65f6:	dd 24       	eor	r13, r13
    65f8:	d3 94       	inc	r13
    65fa:	ed b7       	in	r30, 0x3d	; 61
    65fc:	fe b7       	in	r31, 0x3e	; 62
    65fe:	36 96       	adiw	r30, 0x06	; 6
    6600:	0f b6       	in	r0, 0x3f	; 63
    6602:	f8 94       	cli
    6604:	fe bf       	out	0x3e, r31	; 62
    6606:	0f be       	out	0x3f, r0	; 63
    6608:	ed bf       	out	0x3d, r30	; 61
	 GCalcOpt=G_PLUS;
	 for (i=1;i<strlen(srcDate);i++){
	      strDestCode[i]='0'+GeniusCalc(GCalcOpt,(cSeed-'0'),(srcDate[i]-'0'));	 
    660a:	f0 ed       	ldi	r31, 0xD0	; 208
    660c:	cf 0e       	add	r12, r31
    660e:	0f c0       	rjmp	.+30     	; 0x662e <GenerateGeniusCode+0x140>
    6610:	f7 01       	movw	r30, r14
    6612:	e0 0f       	add	r30, r16
    6614:	f1 1f       	adc	r31, r17
    6616:	40 81       	ld	r20, Z
    6618:	40 53       	subi	r20, 0x30	; 48
    661a:	80 e0       	ldi	r24, 0x00	; 0
    661c:	6c 2d       	mov	r22, r12
    661e:	0e 94 5d 16 	call	0x2cba	; 0x2cba <GeniusCalc>
    6622:	0a 0d       	add	r16, r10
    6624:	1b 1d       	adc	r17, r11
    6626:	80 5d       	subi	r24, 0xD0	; 208
    6628:	d8 01       	movw	r26, r16
    662a:	8c 93       	st	X, r24
		_uart_print(1,1,strSend);
     #endif

	 sprintf_P(strDestCode,PSTR("%c"),cSeed);     
	 GCalcOpt=G_PLUS;
	 for (i=1;i<strlen(srcDate);i++){
    662c:	d3 94       	inc	r13
    662e:	0d 2d       	mov	r16, r13
    6630:	10 e0       	ldi	r17, 0x00	; 0
    6632:	d7 01       	movw	r26, r14
    6634:	0d 90       	ld	r0, X+
    6636:	00 20       	and	r0, r0
    6638:	e9 f7       	brne	.-6      	; 0x6634 <GenerateGeniusCode+0x146>
    663a:	11 97       	sbiw	r26, 0x01	; 1
    663c:	ae 19       	sub	r26, r14
    663e:	bf 09       	sbc	r27, r15
    6640:	0a 17       	cp	r16, r26
    6642:	1b 07       	cpc	r17, r27
    6644:	28 f3       	brcs	.-54     	; 0x6610 <GenerateGeniusCode+0x122>
	      strDestCode[i]='0'+GeniusCalc(GCalcOpt,(cSeed-'0'),(srcDate[i]-'0'));	 
	 }strDestCode[strlen(srcDate)]=0;
    6646:	aa 0d       	add	r26, r10
    6648:	bb 1d       	adc	r27, r11
    664a:	1c 92       	st	X, r1
	 #ifdef DEBUG_GENIUS_CODE
       sprintf_P(strSend,PSTR("1st:%s"),strDestCode);
	   _uart_print(1,1,strSend);     
	 #endif

	 WrapCode(strDestCode);
    664c:	c5 01       	movw	r24, r10
    664e:	0e 94 79 31 	call	0x62f2	; 0x62f2 <WrapCode>
	 #ifdef DEBUG_GENIUS_CODE
	   sprintf_P(strSend,PSTR("Wrap:%s"),strDestCode);
	   _uart_print(1,1,strSend);     
	 #endif
}
    6652:	28 96       	adiw	r28, 0x08	; 8
    6654:	0f b6       	in	r0, 0x3f	; 63
    6656:	f8 94       	cli
    6658:	de bf       	out	0x3e, r29	; 62
    665a:	0f be       	out	0x3f, r0	; 63
    665c:	cd bf       	out	0x3d, r28	; 61
    665e:	cf 91       	pop	r28
    6660:	df 91       	pop	r29
    6662:	1f 91       	pop	r17
    6664:	0f 91       	pop	r16
    6666:	ff 90       	pop	r15
    6668:	ef 90       	pop	r14
    666a:	df 90       	pop	r13
    666c:	cf 90       	pop	r12
    666e:	bf 90       	pop	r11
    6670:	af 90       	pop	r10
    6672:	08 95       	ret

00006674 <GeneratePrintInit>:
	IsBusyMsg11=True;
}



void GeneratePrintInit(){//Create Initialize Print 
    6674:	cf 92       	push	r12
    6676:	df 92       	push	r13
    6678:	ef 92       	push	r14
    667a:	ff 92       	push	r15
    667c:	0f 93       	push	r16
    667e:	1f 93       	push	r17
    6680:	df 93       	push	r29
    6682:	cf 93       	push	r28
    6684:	cd b7       	in	r28, 0x3d	; 61
    6686:	de b7       	in	r29, 0x3e	; 62
    6688:	62 97       	sbiw	r28, 0x12	; 18
    668a:	0f b6       	in	r0, 0x3f	; 63
    668c:	f8 94       	cli
    668e:	de bf       	out	0x3e, r29	; 62
    6690:	0f be       	out	0x3f, r0	; 63
    6692:	cd bf       	out	0x3d, r28	; 61
     char strVernum[6],strVerdate[12];
	 sprintf_P(strVernum,PSTR(VERSION_NUM));
    6694:	00 d0       	rcall	.+0      	; 0x6696 <GeneratePrintInit+0x22>
    6696:	00 d0       	rcall	.+0      	; 0x6698 <GeneratePrintInit+0x24>
    6698:	6e 01       	movw	r12, r28
    669a:	08 94       	sec
    669c:	c1 1c       	adc	r12, r1
    669e:	d1 1c       	adc	r13, r1
    66a0:	ad b7       	in	r26, 0x3d	; 61
    66a2:	be b7       	in	r27, 0x3e	; 62
    66a4:	12 96       	adiw	r26, 0x02	; 2
    66a6:	dc 92       	st	X, r13
    66a8:	ce 92       	st	-X, r12
    66aa:	11 97       	sbiw	r26, 0x01	; 1
    66ac:	8b e3       	ldi	r24, 0x3B	; 59
    66ae:	9d e1       	ldi	r25, 0x1D	; 29
    66b0:	14 96       	adiw	r26, 0x04	; 4
    66b2:	9c 93       	st	X, r25
    66b4:	8e 93       	st	-X, r24
    66b6:	13 97       	sbiw	r26, 0x03	; 3
    66b8:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
	 sprintf_P(strVerdate,PSTR(VERSION_DATE));
    66bc:	37 e0       	ldi	r19, 0x07	; 7
    66be:	e3 2e       	mov	r14, r19
    66c0:	f1 2c       	mov	r15, r1
    66c2:	ec 0e       	add	r14, r28
    66c4:	fd 1e       	adc	r15, r29
    66c6:	ed b7       	in	r30, 0x3d	; 61
    66c8:	fe b7       	in	r31, 0x3e	; 62
    66ca:	f2 82       	std	Z+2, r15	; 0x02
    66cc:	e1 82       	std	Z+1, r14	; 0x01
    66ce:	80 e3       	ldi	r24, 0x30	; 48
    66d0:	9d e1       	ldi	r25, 0x1D	; 29
    66d2:	94 83       	std	Z+4, r25	; 0x04
    66d4:	83 83       	std	Z+3, r24	; 0x03
    66d6:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
     sprintf_P(PrintBuffer,PSTR("\nGeNiUs Ticket Printer \n Version:%s\n Last Update %s \n Hanindo Automation Solutions \n www.hanindogroup.com\n\n\n\n\n\n\n\n"),strVernum,strVerdate);
    66da:	00 d0       	rcall	.+0      	; 0x66dc <GeneratePrintInit+0x68>
    66dc:	00 d0       	rcall	.+0      	; 0x66de <GeneratePrintInit+0x6a>
    66de:	ed b7       	in	r30, 0x3d	; 61
    66e0:	fe b7       	in	r31, 0x3e	; 62
    66e2:	31 96       	adiw	r30, 0x01	; 1
    66e4:	0f ec       	ldi	r16, 0xCF	; 207
    66e6:	15 e0       	ldi	r17, 0x05	; 5
    66e8:	ad b7       	in	r26, 0x3d	; 61
    66ea:	be b7       	in	r27, 0x3e	; 62
    66ec:	12 96       	adiw	r26, 0x02	; 2
    66ee:	1c 93       	st	X, r17
    66f0:	0e 93       	st	-X, r16
    66f2:	11 97       	sbiw	r26, 0x01	; 1
    66f4:	8e eb       	ldi	r24, 0xBE	; 190
    66f6:	9c e1       	ldi	r25, 0x1C	; 28
    66f8:	93 83       	std	Z+3, r25	; 0x03
    66fa:	82 83       	std	Z+2, r24	; 0x02
    66fc:	d5 82       	std	Z+5, r13	; 0x05
    66fe:	c4 82       	std	Z+4, r12	; 0x04
    6700:	f7 82       	std	Z+7, r15	; 0x07
    6702:	e6 82       	std	Z+6, r14	; 0x06
    6704:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
	 _uart_print(0,1,PrintBuffer);
    6708:	ed b7       	in	r30, 0x3d	; 61
    670a:	fe b7       	in	r31, 0x3e	; 62
    670c:	38 96       	adiw	r30, 0x08	; 8
    670e:	0f b6       	in	r0, 0x3f	; 63
    6710:	f8 94       	cli
    6712:	fe bf       	out	0x3e, r31	; 62
    6714:	0f be       	out	0x3f, r0	; 63
    6716:	ed bf       	out	0x3d, r30	; 61
    6718:	80 e0       	ldi	r24, 0x00	; 0
    671a:	61 e0       	ldi	r22, 0x01	; 1
    671c:	a8 01       	movw	r20, r16
    671e:	0e 94 f2 b3 	call	0x167e4	; 0x167e4 <_uart_print>
	 LengthMessage81=strlen(PrintBuffer);
    6722:	f8 01       	movw	r30, r16
    6724:	01 90       	ld	r0, Z+
    6726:	00 20       	and	r0, r0
    6728:	e9 f7       	brne	.-6      	; 0x6724 <GeneratePrintInit+0xb0>
    672a:	31 97       	sbiw	r30, 0x01	; 1
    672c:	e0 1b       	sub	r30, r16
    672e:	f1 0b       	sbc	r31, r17
    6730:	f0 93 a1 01 	sts	0x01A1, r31
    6734:	e0 93 a0 01 	sts	0x01A0, r30
	 //Spooling HFCx 0000
	 cmdPrint=0b00010000|(1<<PRN_PAPER_CUT);
    6738:	80 e3       	ldi	r24, 0x30	; 48
    673a:	80 93 cb 01 	sts	0x01CB, r24
	 IsFreePrinting=True;
    673e:	81 e0       	ldi	r24, 0x01	; 1
    6740:	80 93 bf 01 	sts	0x01BF, r24
}
    6744:	62 96       	adiw	r28, 0x12	; 18
    6746:	0f b6       	in	r0, 0x3f	; 63
    6748:	f8 94       	cli
    674a:	de bf       	out	0x3e, r29	; 62
    674c:	0f be       	out	0x3f, r0	; 63
    674e:	cd bf       	out	0x3d, r28	; 61
    6750:	cf 91       	pop	r28
    6752:	df 91       	pop	r29
    6754:	1f 91       	pop	r17
    6756:	0f 91       	pop	r16
    6758:	ff 90       	pop	r15
    675a:	ef 90       	pop	r14
    675c:	df 90       	pop	r13
    675e:	cf 90       	pop	r12
    6760:	08 95       	ret

00006762 <FormatCurrency>:
     DecCfg=eeprom_read_byte(&DefDecimalTotalVolume);
	 FormatDecimal(strRawVolume,DecCfg);
}


void FormatCurrency(char *strCurrency){// 5000000.00 5,000,000.00
    6762:	9f 92       	push	r9
    6764:	af 92       	push	r10
    6766:	bf 92       	push	r11
    6768:	cf 92       	push	r12
    676a:	df 92       	push	r13
    676c:	ef 92       	push	r14
    676e:	ff 92       	push	r15
    6770:	0f 93       	push	r16
    6772:	1f 93       	push	r17
    6774:	df 93       	push	r29
    6776:	cf 93       	push	r28
    6778:	cd b7       	in	r28, 0x3d	; 61
    677a:	de b7       	in	r29, 0x3e	; 62
    677c:	64 97       	sbiw	r28, 0x14	; 20
    677e:	0f b6       	in	r0, 0x3f	; 63
    6780:	f8 94       	cli
    6782:	de bf       	out	0x3e, r29	; 62
    6784:	0f be       	out	0x3f, r0	; 63
    6786:	cd bf       	out	0x3d, r28	; 61
    6788:	6c 01       	movw	r12, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    678a:	e1 99       	sbic	0x1c, 1	; 28
    678c:	fe cf       	rjmp	.-4      	; 0x678a <FormatCurrency+0x28>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    678e:	8f e3       	ldi	r24, 0x3F	; 63
    6790:	90 e0       	ldi	r25, 0x00	; 0
    6792:	9f bb       	out	0x1f, r25	; 31
    6794:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    6796:	e0 9a       	sbi	0x1c, 0	; 28
    6798:	9d b2       	in	r9, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    679a:	e1 99       	sbic	0x1c, 1	; 28
    679c:	fe cf       	rjmp	.-4      	; 0x679a <FormatCurrency+0x38>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    679e:	8e e3       	ldi	r24, 0x3E	; 62
    67a0:	90 e0       	ldi	r25, 0x00	; 0
    67a2:	9f bb       	out	0x1f, r25	; 31
    67a4:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    67a6:	e0 9a       	sbi	0x1c, 0	; 28
    67a8:	3d b3       	in	r19, 0x1d	; 29
	 char CurrencyMark,DecimalMark;

	 CurrencyMark=eeprom_read_byte(&DefCurrencyMark);
	 DecimalMark=eeprom_read_byte(&DefDecimalMark);

	 Length=strlen(strCurrency);//123,456
    67aa:	f6 01       	movw	r30, r12
    67ac:	01 90       	ld	r0, Z+
    67ae:	00 20       	and	r0, r0
    67b0:	e9 f7       	brne	.-6      	; 0x67ac <FormatCurrency+0x4a>
    67b2:	31 97       	sbiw	r30, 0x01	; 1
    67b4:	ee 2e       	mov	r14, r30
    67b6:	ec 18       	sub	r14, r12
    67b8:	fe 01       	movw	r30, r28
    67ba:	31 96       	adiw	r30, 0x01	; 1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    67bc:	ce 01       	movw	r24, r28
    67be:	45 96       	adiw	r24, 0x15	; 21
	     strMemory[i]=data;
    67c0:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    67c2:	e8 17       	cp	r30, r24
    67c4:	f9 07       	cpc	r31, r25
    67c6:	e1 f7       	brne	.-8      	; 0x67c0 <FormatCurrency+0x5e>
    67c8:	f6 01       	movw	r30, r12
    67ca:	fe 2c       	mov	r15, r14
    67cc:	80 e0       	ldi	r24, 0x00	; 0
    67ce:	20 e0       	ldi	r18, 0x00	; 0
    67d0:	09 c0       	rjmp	.+18     	; 0x67e4 <FormatCurrency+0x82>
	 dotPos=Length;
	 nComa=0;
	 FillChar(fmtCurrency,sizeof(fmtCurrency),0);
	 //Detection
	 for(i=0;i<Length;i++){// 123,456 
	     if (strCurrency[i]==DecimalMark) dotPos=i;//3
    67d2:	90 81       	ld	r25, Z
    67d4:	93 17       	cp	r25, r19
    67d6:	09 f4       	brne	.+2      	; 0x67da <FormatCurrency+0x78>
    67d8:	f8 2e       	mov	r15, r24
		 if (strCurrency[i]==CurrencyMark) nComa++;//0
    67da:	99 15       	cp	r25, r9
    67dc:	09 f4       	brne	.+2      	; 0x67e0 <FormatCurrency+0x7e>
    67de:	2f 5f       	subi	r18, 0xFF	; 255
	 Length=strlen(strCurrency);//123,456
	 dotPos=Length;
	 nComa=0;
	 FillChar(fmtCurrency,sizeof(fmtCurrency),0);
	 //Detection
	 for(i=0;i<Length;i++){// 123,456 
    67e0:	8f 5f       	subi	r24, 0xFF	; 255
    67e2:	31 96       	adiw	r30, 0x01	; 1
    67e4:	8e 15       	cp	r24, r14
    67e6:	a8 f3       	brcs	.-22     	; 0x67d2 <FormatCurrency+0x70>
	     if (strCurrency[i]==DecimalMark) dotPos=i;//3
		 if (strCurrency[i]==CurrencyMark) nComa++;//0
	 }

	 if((nComa==0)&&(dotPos>3)){		 
    67e8:	22 23       	and	r18, r18
    67ea:	09 f0       	breq	.+2      	; 0x67ee <FormatCurrency+0x8c>
    67ec:	5e c0       	rjmp	.+188    	; 0x68aa <FormatCurrency+0x148>
    67ee:	83 e0       	ldi	r24, 0x03	; 3
    67f0:	8f 15       	cp	r24, r15
    67f2:	08 f0       	brcs	.+2      	; 0x67f6 <FormatCurrency+0x94>
    67f4:	5a c0       	rjmp	.+180    	; 0x68aa <FormatCurrency+0x148>
    67f6:	40 e0       	ldi	r20, 0x00	; 0
    67f8:	20 e0       	ldi	r18, 0x00	; 0
    67fa:	30 e0       	ldi	r19, 0x00	; 0
         iPos=0;
	     for(i=0;i<dotPos;i++){
	         if ((((dotPos-i)%3)==0)&&(i<(dotPos))&&(i>0)){ 
    67fc:	af 2c       	mov	r10, r15
    67fe:	bb 24       	eor	r11, r11
		        fmtCurrency[iPos]=CurrencyMark;
    6800:	8e 01       	movw	r16, r28
    6802:	0f 5f       	subi	r16, 0xFF	; 255
    6804:	1f 4f       	sbci	r17, 0xFF	; 255
	 }

	 if((nComa==0)&&(dotPos>3)){		 
         iPos=0;
	     for(i=0;i<dotPos;i++){
	         if ((((dotPos-i)%3)==0)&&(i<(dotPos))&&(i>0)){ 
    6806:	c5 01       	movw	r24, r10
    6808:	82 1b       	sub	r24, r18
    680a:	93 0b       	sbc	r25, r19
    680c:	63 e0       	ldi	r22, 0x03	; 3
    680e:	70 e0       	ldi	r23, 0x00	; 0
    6810:	0e 94 a7 b8 	call	0x1714e	; 0x1714e <__divmodhi4>
    6814:	89 2b       	or	r24, r25
    6816:	49 f4       	brne	.+18     	; 0x682a <FormatCurrency+0xc8>
    6818:	2f 15       	cp	r18, r15
    681a:	38 f4       	brcc	.+14     	; 0x682a <FormatCurrency+0xc8>
    681c:	22 23       	and	r18, r18
    681e:	29 f0       	breq	.+10     	; 0x682a <FormatCurrency+0xc8>
		        fmtCurrency[iPos]=CurrencyMark;
    6820:	f8 01       	movw	r30, r16
    6822:	e4 0f       	add	r30, r20
    6824:	f1 1d       	adc	r31, r1
    6826:	90 82       	st	Z, r9
		        iPos++;
    6828:	4f 5f       	subi	r20, 0xFF	; 255
		        }
		        fmtCurrency[iPos]=strCurrency[i];
    682a:	d8 01       	movw	r26, r16
    682c:	a4 0f       	add	r26, r20
    682e:	b1 1d       	adc	r27, r1
    6830:	f6 01       	movw	r30, r12
    6832:	e2 0f       	add	r30, r18
    6834:	f3 1f       	adc	r31, r19
    6836:	80 81       	ld	r24, Z
    6838:	8c 93       	st	X, r24
			    iPos++;
    683a:	4f 5f       	subi	r20, 0xFF	; 255
			    fmtCurrency[iPos]=0;
    683c:	f8 01       	movw	r30, r16
    683e:	e4 0f       	add	r30, r20
    6840:	f1 1d       	adc	r31, r1
    6842:	10 82       	st	Z, r1
    6844:	2f 5f       	subi	r18, 0xFF	; 255
    6846:	3f 4f       	sbci	r19, 0xFF	; 255
		 if (strCurrency[i]==CurrencyMark) nComa++;//0
	 }

	 if((nComa==0)&&(dotPos>3)){		 
         iPos=0;
	     for(i=0;i<dotPos;i++){
    6848:	2f 15       	cp	r18, r15
    684a:	e8 f2       	brcs	.-70     	; 0x6806 <FormatCurrency+0xa4>
    684c:	9f 2d       	mov	r25, r15
			    iPos++;
			    fmtCurrency[iPos]=0;
	         }
         
	     for(i=dotPos;i<Length;i++){
		        fmtCurrency[iPos]=strCurrency[i];
    684e:	9e 01       	movw	r18, r28
    6850:	2f 5f       	subi	r18, 0xFF	; 255
    6852:	3f 4f       	sbci	r19, 0xFF	; 255
    6854:	0e c0       	rjmp	.+28     	; 0x6872 <FormatCurrency+0x110>
    6856:	d9 01       	movw	r26, r18
    6858:	a4 0f       	add	r26, r20
    685a:	b1 1d       	adc	r27, r1
    685c:	f6 01       	movw	r30, r12
    685e:	e9 0f       	add	r30, r25
    6860:	f1 1d       	adc	r31, r1
    6862:	80 81       	ld	r24, Z
    6864:	8c 93       	st	X, r24
			    iPos++;
    6866:	4f 5f       	subi	r20, 0xFF	; 255
			    fmtCurrency[iPos]=0;
    6868:	f9 01       	movw	r30, r18
    686a:	e4 0f       	add	r30, r20
    686c:	f1 1d       	adc	r31, r1
    686e:	10 82       	st	Z, r1
		        fmtCurrency[iPos]=strCurrency[i];
			    iPos++;
			    fmtCurrency[iPos]=0;
	         }
         
	     for(i=dotPos;i<Length;i++){
    6870:	9f 5f       	subi	r25, 0xFF	; 255
    6872:	9e 15       	cp	r25, r14
    6874:	80 f3       	brcs	.-32     	; 0x6856 <FormatCurrency+0xf4>
    6876:	90 e0       	ldi	r25, 0x00	; 0
		        fmtCurrency[iPos]=strCurrency[i];
			    iPos++;
			    fmtCurrency[iPos]=0;
	         }
	      for(i=0;i<strlen(fmtCurrency);i++){
    6878:	9e 01       	movw	r18, r28
    687a:	2f 5f       	subi	r18, 0xFF	; 255
    687c:	3f 4f       	sbci	r19, 0xFF	; 255
    687e:	09 c0       	rjmp	.+18     	; 0x6892 <FormatCurrency+0x130>
	          strCurrency[i]=fmtCurrency[i];
    6880:	f6 01       	movw	r30, r12
    6882:	ea 0f       	add	r30, r26
    6884:	fb 1f       	adc	r31, r27
    6886:	a2 0f       	add	r26, r18
    6888:	b3 1f       	adc	r27, r19
    688a:	8c 91       	ld	r24, X
    688c:	80 83       	st	Z, r24
			  strCurrency[i+1]=0;
    688e:	11 82       	std	Z+1, r1	; 0x01
	     for(i=dotPos;i<Length;i++){
		        fmtCurrency[iPos]=strCurrency[i];
			    iPos++;
			    fmtCurrency[iPos]=0;
	         }
	      for(i=0;i<strlen(fmtCurrency);i++){
    6890:	9f 5f       	subi	r25, 0xFF	; 255
    6892:	a9 2f       	mov	r26, r25
    6894:	b0 e0       	ldi	r27, 0x00	; 0
    6896:	f9 01       	movw	r30, r18
    6898:	01 90       	ld	r0, Z+
    689a:	00 20       	and	r0, r0
    689c:	e9 f7       	brne	.-6      	; 0x6898 <FormatCurrency+0x136>
    689e:	31 97       	sbiw	r30, 0x01	; 1
    68a0:	e2 1b       	sub	r30, r18
    68a2:	f3 0b       	sbc	r31, r19
    68a4:	ae 17       	cp	r26, r30
    68a6:	bf 07       	cpc	r27, r31
    68a8:	58 f3       	brcs	.-42     	; 0x6880 <FormatCurrency+0x11e>
	          strCurrency[i]=fmtCurrency[i];
			  strCurrency[i+1]=0;
	      }
     }      
}
    68aa:	64 96       	adiw	r28, 0x14	; 20
    68ac:	0f b6       	in	r0, 0x3f	; 63
    68ae:	f8 94       	cli
    68b0:	de bf       	out	0x3e, r29	; 62
    68b2:	0f be       	out	0x3f, r0	; 63
    68b4:	cd bf       	out	0x3d, r28	; 61
    68b6:	cf 91       	pop	r28
    68b8:	df 91       	pop	r29
    68ba:	1f 91       	pop	r17
    68bc:	0f 91       	pop	r16
    68be:	ff 90       	pop	r15
    68c0:	ef 90       	pop	r14
    68c2:	df 90       	pop	r13
    68c4:	cf 90       	pop	r12
    68c6:	bf 90       	pop	r11
    68c8:	af 90       	pop	r10
    68ca:	9f 90       	pop	r9
    68cc:	08 95       	ret

000068ce <FormatDecimal>:

void TestLocalAccount(){

}

void FormatDecimal(char *strRawData, char DecimalCfg){// 9-> 0,009 0,234 123 
    68ce:	ef 92       	push	r14
    68d0:	ff 92       	push	r15
    68d2:	0f 93       	push	r16
    68d4:	1f 93       	push	r17
    68d6:	df 93       	push	r29
    68d8:	cf 93       	push	r28
    68da:	cd b7       	in	r28, 0x3d	; 61
    68dc:	de b7       	in	r29, 0x3e	; 62
    68de:	64 97       	sbiw	r28, 0x14	; 20
    68e0:	0f b6       	in	r0, 0x3f	; 63
    68e2:	f8 94       	cli
    68e4:	de bf       	out	0x3e, r29	; 62
    68e6:	0f be       	out	0x3f, r0	; 63
    68e8:	cd bf       	out	0x3d, r28	; 61
    68ea:	8c 01       	movw	r16, r24
     char i,iPos,CommaPos,Length=0;                 //1->0,01 
	 char strDecimalFormated[20];
	 char DecPointMark;
     if (DecimalCfg>0){    
    68ec:	66 23       	and	r22, r22
    68ee:	09 f4       	brne	.+2      	; 0x68f2 <FormatDecimal+0x24>
    68f0:	56 c0       	rjmp	.+172    	; 0x699e <FormatDecimal+0xd0>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    68f2:	e1 99       	sbic	0x1c, 1	; 28
    68f4:	fe cf       	rjmp	.-4      	; 0x68f2 <FormatDecimal+0x24>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    68f6:	8e e3       	ldi	r24, 0x3E	; 62
    68f8:	90 e0       	ldi	r25, 0x00	; 0
    68fa:	9f bb       	out	0x1f, r25	; 31
    68fc:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    68fe:	e0 9a       	sbi	0x1c, 0	; 28
    6900:	ed b2       	in	r14, 0x1d	; 29
		 DecPointMark=eeprom_read_byte(&DefDecimalMark);	 
		 Length=strlen(strRawData);
    6902:	f8 01       	movw	r30, r16
    6904:	01 90       	ld	r0, Z+
    6906:	00 20       	and	r0, r0
    6908:	e9 f7       	brne	.-6      	; 0x6904 <FormatDecimal+0x36>
    690a:	31 97       	sbiw	r30, 0x01	; 1
    690c:	3e 2f       	mov	r19, r30
    690e:	30 1b       	sub	r19, r16

		 if (Length>DecimalCfg)CommaPos=Length-DecimalCfg;
    6910:	63 17       	cp	r22, r19
    6912:	b8 f5       	brcc	.+110    	; 0x6982 <FormatDecimal+0xb4>
    6914:	f3 2e       	mov	r15, r19
    6916:	f6 1a       	sub	r15, r22
    6918:	b8 01       	movw	r22, r16
    691a:	d8 01       	movw	r26, r16
    691c:	20 e0       	ldi	r18, 0x00	; 0
    691e:	90 e0       	ldi	r25, 0x00	; 0

		 
		 iPos=0;
		 for(i=0;i<Length;i++){
			 if (i==CommaPos){
				 strDecimalFormated[iPos]=DecPointMark;
    6920:	ae 01       	movw	r20, r28
    6922:	4f 5f       	subi	r20, 0xFF	; 255
    6924:	5f 4f       	sbci	r21, 0xFF	; 255
    6926:	0e c0       	rjmp	.+28     	; 0x6944 <FormatDecimal+0x76>
			 }

		 
		 iPos=0;
		 for(i=0;i<Length;i++){
			 if (i==CommaPos){
    6928:	2f 15       	cp	r18, r15
    692a:	29 f4       	brne	.+10     	; 0x6936 <FormatDecimal+0x68>
				 strDecimalFormated[iPos]=DecPointMark;
    692c:	fa 01       	movw	r30, r20
    692e:	e9 0f       	add	r30, r25
    6930:	f1 1d       	adc	r31, r1
    6932:	e0 82       	st	Z, r14
				 iPos++;
    6934:	9f 5f       	subi	r25, 0xFF	; 255
			}
			strDecimalFormated[iPos]=strRawData[i];
    6936:	fa 01       	movw	r30, r20
    6938:	e9 0f       	add	r30, r25
    693a:	f1 1d       	adc	r31, r1
    693c:	8d 91       	ld	r24, X+
    693e:	80 83       	st	Z, r24
			//strDecimalFormated[iPos+1]=0;
			iPos++;
    6940:	9f 5f       	subi	r25, 0xFF	; 255
			 CommaPos=1;
			 }

		 
		 iPos=0;
		 for(i=0;i<Length;i++){
    6942:	2f 5f       	subi	r18, 0xFF	; 255
    6944:	23 17       	cp	r18, r19
    6946:	80 f3       	brcs	.-32     	; 0x6928 <FormatDecimal+0x5a>
				 iPos++;
			}
			strDecimalFormated[iPos]=strRawData[i];
			//strDecimalFormated[iPos+1]=0;
			iPos++;
		 }strDecimalFormated[iPos]=0;
    6948:	9e 01       	movw	r18, r28
    694a:	2f 5f       	subi	r18, 0xFF	; 255
    694c:	3f 4f       	sbci	r19, 0xFF	; 255
    694e:	f9 01       	movw	r30, r18
    6950:	e9 0f       	add	r30, r25
    6952:	f1 1d       	adc	r31, r1
    6954:	10 82       	st	Z, r1
		 
         //_uart_print(1,1,strDecimalFormated); 

		 Length=strlen(strDecimalFormated);
    6956:	f9 01       	movw	r30, r18
    6958:	01 90       	ld	r0, Z+
    695a:	00 20       	and	r0, r0
    695c:	e9 f7       	brne	.-6      	; 0x6958 <FormatDecimal+0x8a>
    695e:	31 97       	sbiw	r30, 0x01	; 1
    6960:	9e 2f       	mov	r25, r30
    6962:	92 1b       	sub	r25, r18
    6964:	d9 01       	movw	r26, r18
    6966:	04 c0       	rjmp	.+8      	; 0x6970 <FormatDecimal+0xa2>
		 for(i=0;i<Length;i++){
			 strRawData[i]=strDecimalFormated[i];
    6968:	8d 91       	ld	r24, X+
    696a:	fb 01       	movw	r30, r22
    696c:	81 93       	st	Z+, r24
    696e:	bf 01       	movw	r22, r30
		 }strDecimalFormated[iPos]=0;
		 
         //_uart_print(1,1,strDecimalFormated); 

		 Length=strlen(strDecimalFormated);
		 for(i=0;i<Length;i++){
    6970:	8a 2f       	mov	r24, r26
    6972:	82 1b       	sub	r24, r18
    6974:	89 17       	cp	r24, r25
    6976:	c0 f3       	brcs	.-16     	; 0x6968 <FormatDecimal+0x9a>
			 strRawData[i]=strDecimalFormated[i];
		 }strRawData[Length]=0;
    6978:	09 0f       	add	r16, r25
    697a:	11 1d       	adc	r17, r1
    697c:	f8 01       	movw	r30, r16
    697e:	10 82       	st	Z, r1
    6980:	0e c0       	rjmp	.+28     	; 0x699e <FormatDecimal+0xd0>
		 if (Length>DecimalCfg)CommaPos=Length-DecimalCfg;
		 else CommaPos=1;


		 if (Length<=DecimalCfg){// 123 -> 0123
			 AddZeroLead(strRawData,(DecimalCfg+1));
    6982:	6f 5f       	subi	r22, 0xFF	; 255
    6984:	c8 01       	movw	r24, r16
    6986:	0e 94 37 27 	call	0x4e6e	; 0x4e6e <AddZeroLead>
			 //AddZeroLead(strRawData,(DecimalCfg+2));
			 Length=strlen(strRawData);
    698a:	f8 01       	movw	r30, r16
    698c:	01 90       	ld	r0, Z+
    698e:	00 20       	and	r0, r0
    6990:	e9 f7       	brne	.-6      	; 0x698c <FormatDecimal+0xbe>
    6992:	31 97       	sbiw	r30, 0x01	; 1
    6994:	3e 2f       	mov	r19, r30
    6996:	30 1b       	sub	r19, r16
    6998:	ff 24       	eor	r15, r15
    699a:	f3 94       	inc	r15
    699c:	bd cf       	rjmp	.-134    	; 0x6918 <FormatDecimal+0x4a>
		 for(i=0;i<Length;i++){
			 strRawData[i]=strDecimalFormated[i];
		 }strRawData[Length]=0;
	 }
          //_uart_print(1,1,strRawData); 
}
    699e:	64 96       	adiw	r28, 0x14	; 20
    69a0:	0f b6       	in	r0, 0x3f	; 63
    69a2:	f8 94       	cli
    69a4:	de bf       	out	0x3e, r29	; 62
    69a6:	0f be       	out	0x3f, r0	; 63
    69a8:	cd bf       	out	0x3d, r28	; 61
    69aa:	cf 91       	pop	r28
    69ac:	df 91       	pop	r29
    69ae:	1f 91       	pop	r17
    69b0:	0f 91       	pop	r16
    69b2:	ff 90       	pop	r15
    69b4:	ef 90       	pop	r14
    69b6:	08 95       	ret

000069b8 <NormalizeDecimal>:
	 Result=(SigmaSum%255);
	 if (Result==0)Result=255;
   return Result;
}

void NormalizeDecimal(char CurrentDecimal, char NewDecimal, char *Result){// 01234567,89
    69b8:	68 2f       	mov	r22, r24
    69ba:	ca 01       	movw	r24, r20
		 StrPosCopy(Result,SResult,DeltaDec,Length-DeltaDec);
		 	           
	 
     }
*/
     FormatDecimal(Result,CurrentDecimal);
    69bc:	0e 94 67 34 	call	0x68ce	; 0x68ce <FormatDecimal>
}
    69c0:	08 95       	ret

000069c2 <FormatTotalizerVolume>:
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalTotalMoney);
	 FormatDecimal(strRawMoney,DecCfg);
}

void FormatTotalizerVolume(char *strRawVolume){//96->0,96 
    69c2:	9c 01       	movw	r18, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    69c4:	e1 99       	sbic	0x1c, 1	; 28
    69c6:	fe cf       	rjmp	.-4      	; 0x69c4 <FormatTotalizerVolume+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    69c8:	8c e3       	ldi	r24, 0x3C	; 60
    69ca:	90 e0       	ldi	r25, 0x00	; 0
    69cc:	9f bb       	out	0x1f, r25	; 31
    69ce:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    69d0:	e0 9a       	sbi	0x1c, 0	; 28
    69d2:	6d b3       	in	r22, 0x1d	; 29
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalTotalVolume);
	 FormatDecimal(strRawVolume,DecCfg);
    69d4:	c9 01       	movw	r24, r18
    69d6:	0e 94 67 34 	call	0x68ce	; 0x68ce <FormatDecimal>
}
    69da:	08 95       	ret

000069dc <FormatTotalizerMoney>:
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalVolume);
	 FormatDecimal(strRawVolume,DecCfg);
}

void FormatTotalizerMoney(char *strRawMoney){
    69dc:	9c 01       	movw	r18, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    69de:	e1 99       	sbic	0x1c, 1	; 28
    69e0:	fe cf       	rjmp	.-4      	; 0x69de <FormatTotalizerMoney+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    69e2:	8d e3       	ldi	r24, 0x3D	; 61
    69e4:	90 e0       	ldi	r25, 0x00	; 0
    69e6:	9f bb       	out	0x1f, r25	; 31
    69e8:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    69ea:	e0 9a       	sbi	0x1c, 0	; 28
    69ec:	6d b3       	in	r22, 0x1d	; 29
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalTotalMoney);
	 FormatDecimal(strRawMoney,DecCfg);
    69ee:	c9 01       	movw	r24, r18
    69f0:	0e 94 67 34 	call	0x68ce	; 0x68ce <FormatDecimal>
}
    69f4:	08 95       	ret

000069f6 <FormatVolume>:
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalMoney);
	 FormatDecimal(strRawMoney,DecCfg);
}

void FormatVolume(char *strRawVolume){//96->0,96 
    69f6:	9c 01       	movw	r18, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    69f8:	e1 99       	sbic	0x1c, 1	; 28
    69fa:	fe cf       	rjmp	.-4      	; 0x69f8 <FormatVolume+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    69fc:	8a e3       	ldi	r24, 0x3A	; 58
    69fe:	90 e0       	ldi	r25, 0x00	; 0
    6a00:	9f bb       	out	0x1f, r25	; 31
    6a02:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    6a04:	e0 9a       	sbi	0x1c, 0	; 28
    6a06:	6d b3       	in	r22, 0x1d	; 29
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalVolume);
	 FormatDecimal(strRawVolume,DecCfg);
    6a08:	c9 01       	movw	r24, r18
    6a0a:	0e 94 67 34 	call	0x68ce	; 0x68ce <FormatDecimal>
}
    6a0e:	08 95       	ret

00006a10 <FormatMoney>:
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalPrice);
	 FormatDecimal(strRawPrice,DecCfg);
}

void FormatMoney(char *strRawMoney){
    6a10:	9c 01       	movw	r18, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    6a12:	e1 99       	sbic	0x1c, 1	; 28
    6a14:	fe cf       	rjmp	.-4      	; 0x6a12 <FormatMoney+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    6a16:	8b e3       	ldi	r24, 0x3B	; 59
    6a18:	90 e0       	ldi	r25, 0x00	; 0
    6a1a:	9f bb       	out	0x1f, r25	; 31
    6a1c:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    6a1e:	e0 9a       	sbi	0x1c, 0	; 28
    6a20:	6d b3       	in	r22, 0x1d	; 29
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalMoney);
	 FormatDecimal(strRawMoney,DecCfg);
    6a22:	c9 01       	movw	r24, r18
    6a24:	0e 94 67 34 	call	0x68ce	; 0x68ce <FormatDecimal>
}
    6a28:	08 95       	ret

00006a2a <FormatPrice>:
		 }strRawData[Length]=0;
	 }
          //_uart_print(1,1,strRawData); 
}

void FormatPrice(char *strRawPrice){
    6a2a:	9c 01       	movw	r18, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    6a2c:	e1 99       	sbic	0x1c, 1	; 28
    6a2e:	fe cf       	rjmp	.-4      	; 0x6a2c <FormatPrice+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    6a30:	89 e3       	ldi	r24, 0x39	; 57
    6a32:	90 e0       	ldi	r25, 0x00	; 0
    6a34:	9f bb       	out	0x1f, r25	; 31
    6a36:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    6a38:	e0 9a       	sbi	0x1c, 0	; 28
    6a3a:	6d b3       	in	r22, 0x1d	; 29
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalPrice);
	 FormatDecimal(strRawPrice,DecCfg);
    6a3c:	c9 01       	movw	r24, r18
    6a3e:	0e 94 67 34 	call	0x68ce	; 0x68ce <FormatDecimal>
}
    6a42:	08 95       	ret

00006a44 <systemGenerateReport>:
	 }
}

//Spooling HFCS 0000 : Header, Footer, Copy , Scrool [Copy:16x max]
//			cmdPrint=procMessage81();
void systemGenerateReport(){
    6a44:	2f 92       	push	r2
    6a46:	3f 92       	push	r3
    6a48:	4f 92       	push	r4
    6a4a:	5f 92       	push	r5
    6a4c:	6f 92       	push	r6
    6a4e:	7f 92       	push	r7
    6a50:	8f 92       	push	r8
    6a52:	9f 92       	push	r9
    6a54:	af 92       	push	r10
    6a56:	bf 92       	push	r11
    6a58:	cf 92       	push	r12
    6a5a:	df 92       	push	r13
    6a5c:	ef 92       	push	r14
    6a5e:	ff 92       	push	r15
    6a60:	0f 93       	push	r16
    6a62:	1f 93       	push	r17
    6a64:	df 93       	push	r29
    6a66:	cf 93       	push	r28
    6a68:	cd b7       	in	r28, 0x3d	; 61
    6a6a:	de b7       	in	r29, 0x3e	; 62
    6a6c:	c8 5f       	subi	r28, 0xF8	; 248
    6a6e:	d0 40       	sbci	r29, 0x00	; 0
    6a70:	0f b6       	in	r0, 0x3f	; 63
    6a72:	f8 94       	cli
    6a74:	de bf       	out	0x3e, r29	; 62
    6a76:	0f be       	out	0x3f, r0	; 63
    6a78:	cd bf       	out	0x3d, r28	; 61
	   char strTabSpace[20],strTabSpace2[20];
	   char iTotal;//,PadLength;
	   char sPrice[10],strProductPrice[20];
	   char FIPAddr;

     switch(stGenerateReport){
    6a7a:	10 91 14 02 	lds	r17, 0x0214
    6a7e:	16 30       	cpi	r17, 0x06	; 6
    6a80:	09 f4       	brne	.+2      	; 0x6a84 <systemGenerateReport+0x40>
    6a82:	5d c2       	rjmp	.+1210   	; 0x6f3e <systemGenerateReport+0x4fa>
    6a84:	17 30       	cpi	r17, 0x07	; 7
    6a86:	98 f4       	brcc	.+38     	; 0x6aae <systemGenerateReport+0x6a>
    6a88:	12 30       	cpi	r17, 0x02	; 2
    6a8a:	09 f4       	brne	.+2      	; 0x6a8e <systemGenerateReport+0x4a>
    6a8c:	a7 c0       	rjmp	.+334    	; 0x6bdc <systemGenerateReport+0x198>
    6a8e:	13 30       	cpi	r17, 0x03	; 3
    6a90:	38 f4       	brcc	.+14     	; 0x6aa0 <systemGenerateReport+0x5c>
    6a92:	11 23       	and	r17, r17
    6a94:	31 f1       	breq	.+76     	; 0x6ae2 <systemGenerateReport+0x9e>
    6a96:	11 30       	cpi	r17, 0x01	; 1
    6a98:	11 f0       	breq	.+4      	; 0x6a9e <systemGenerateReport+0x5a>
    6a9a:	0c 94 3b 40 	jmp	0x8076	; 0x8076 <systemGenerateReport+0x1632>
    6a9e:	2d c0       	rjmp	.+90     	; 0x6afa <systemGenerateReport+0xb6>
    6aa0:	14 30       	cpi	r17, 0x04	; 4
    6aa2:	09 f4       	brne	.+2      	; 0x6aa6 <systemGenerateReport+0x62>
    6aa4:	c8 c1       	rjmp	.+912    	; 0x6e36 <systemGenerateReport+0x3f2>
    6aa6:	15 30       	cpi	r17, 0x05	; 5
    6aa8:	08 f0       	brcs	.+2      	; 0x6aac <systemGenerateReport+0x68>
    6aaa:	4c c7       	rjmp	.+3736   	; 0x7944 <systemGenerateReport+0xf00>
    6aac:	bb c1       	rjmp	.+886    	; 0x6e24 <systemGenerateReport+0x3e0>
    6aae:	19 30       	cpi	r17, 0x09	; 9
    6ab0:	09 f4       	brne	.+2      	; 0x6ab4 <systemGenerateReport+0x70>
    6ab2:	48 c7       	rjmp	.+3728   	; 0x7944 <systemGenerateReport+0xf00>
    6ab4:	1a 30       	cpi	r17, 0x0A	; 10
    6ab6:	40 f4       	brcc	.+16     	; 0x6ac8 <systemGenerateReport+0x84>
    6ab8:	17 30       	cpi	r17, 0x07	; 7
    6aba:	09 f4       	brne	.+2      	; 0x6abe <systemGenerateReport+0x7a>
    6abc:	aa c2       	rjmp	.+1364   	; 0x7012 <systemGenerateReport+0x5ce>
    6abe:	18 30       	cpi	r17, 0x08	; 8
    6ac0:	11 f0       	breq	.+4      	; 0x6ac6 <systemGenerateReport+0x82>
    6ac2:	0c 94 3b 40 	jmp	0x8076	; 0x8076 <systemGenerateReport+0x1632>
    6ac6:	b3 c2       	rjmp	.+1382   	; 0x702e <systemGenerateReport+0x5ea>
    6ac8:	1b 30       	cpi	r17, 0x0B	; 11
    6aca:	11 f4       	brne	.+4      	; 0x6ad0 <systemGenerateReport+0x8c>
    6acc:	0c 94 2e 40 	jmp	0x805c	; 0x805c <systemGenerateReport+0x1618>
    6ad0:	1b 30       	cpi	r17, 0x0B	; 11
    6ad2:	08 f4       	brcc	.+2      	; 0x6ad6 <systemGenerateReport+0x92>
    6ad4:	3e c7       	rjmp	.+3708   	; 0x7952 <systemGenerateReport+0xf0e>
    6ad6:	1c 30       	cpi	r17, 0x0C	; 12
    6ad8:	11 f0       	breq	.+4      	; 0x6ade <systemGenerateReport+0x9a>
    6ada:	0c 94 3b 40 	jmp	0x8076	; 0x8076 <systemGenerateReport+0x1632>
    6ade:	0c 94 36 40 	jmp	0x806c	; 0x806c <systemGenerateReport+0x1628>
	 case grScanAction://Wait for Complete incoming Totalizer data	      
		  if (IsGenerateReport==True){
    6ae2:	80 91 99 01 	lds	r24, 0x0199
    6ae6:	81 30       	cpi	r24, 0x01	; 1
    6ae8:	11 f0       	breq	.+4      	; 0x6aee <systemGenerateReport+0xaa>
    6aea:	0c 94 3b 40 	jmp	0x8076	; 0x8076 <systemGenerateReport+0x1632>
		      IsGenerateReport=False;
    6aee:	10 92 99 01 	sts	0x0199, r1
			  IsFinishPrintingTotalizer=False;
    6af2:	10 92 9a 01 	sts	0x019A, r1
    6af6:	0c 94 33 40 	jmp	0x8066	; 0x8066 <systemGenerateReport+0x1622>
			  stGenerateReport=grInitData;
		  }
	      break;
	 case grInitData:
	      xPump=1;
    6afa:	10 93 13 02 	sts	0x0213, r17
		  xNozzle=1;
    6afe:	10 93 12 02 	sts	0x0212, r17
		  RepPos=0;
    6b02:	10 92 03 02 	sts	0x0203, r1
    6b06:	10 92 02 02 	sts	0x0202, r1
    6b0a:	ef ec       	ldi	r30, 0xCF	; 207
    6b0c:	f5 e0       	ldi	r31, 0x05	; 5
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    6b0e:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    6b10:	87 e0       	ldi	r24, 0x07	; 7
    6b12:	e0 36       	cpi	r30, 0x60	; 96
    6b14:	f8 07       	cpc	r31, r24
    6b16:	d9 f7       	brne	.-10     	; 0x6b0e <systemGenerateReport+0xca>
    6b18:	fe 01       	movw	r30, r28
    6b1a:	eb 55       	subi	r30, 0x5B	; 91
    6b1c:	ff 4f       	sbci	r31, 0xFF	; 255
	     strMemory[i]=data;
    6b1e:	ce 01       	movw	r24, r28
    6b20:	8b 50       	subi	r24, 0x0B	; 11
    6b22:	9f 4f       	sbci	r25, 0xFF	; 255
    6b24:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    6b26:	e8 17       	cp	r30, r24
    6b28:	f9 07       	cpc	r31, r25
    6b2a:	e1 f7       	brne	.-8      	; 0x6b24 <systemGenerateReport+0xe0>
    6b2c:	fe 01       	movw	r30, r28
    6b2e:	f7 96       	adiw	r30, 0x37	; 55
	     strMemory[i]=data;
    6b30:	cf 01       	movw	r24, r30
    6b32:	0f 96       	adiw	r24, 0x0f	; 15
    6b34:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    6b36:	e8 17       	cp	r30, r24
    6b38:	f9 07       	cpc	r31, r25
    6b3a:	e1 f7       	brne	.-8      	; 0x6b34 <systemGenerateReport+0xf0>
    6b3c:	fe 01       	movw	r30, r28
    6b3e:	ea 5b       	subi	r30, 0xBA	; 186
    6b40:	ff 4f       	sbci	r31, 0xFF	; 255
	     strMemory[i]=data;
    6b42:	cf 01       	movw	r24, r30
    6b44:	0f 96       	adiw	r24, 0x0f	; 15
    6b46:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    6b48:	e8 17       	cp	r30, r24
    6b4a:	f9 07       	cpc	r31, r25
    6b4c:	e1 f7       	brne	.-8      	; 0x6b46 <systemGenerateReport+0x102>
    6b4e:	ec ef       	ldi	r30, 0xFC	; 252
    6b50:	f9 e0       	ldi	r31, 0x09	; 9
	     strMemory[i]=data;
    6b52:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    6b54:	9a e0       	ldi	r25, 0x0A	; 10
    6b56:	e0 31       	cpi	r30, 0x10	; 16
    6b58:	f9 07       	cpc	r31, r25
    6b5a:	d9 f7       	brne	.-10     	; 0x6b52 <systemGenerateReport+0x10e>
    6b5c:	ed ea       	ldi	r30, 0xAD	; 173
    6b5e:	fa e0       	ldi	r31, 0x0A	; 10
	     strMemory[i]=data;
    6b60:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    6b62:	aa e0       	ldi	r26, 0x0A	; 10
    6b64:	e1 3c       	cpi	r30, 0xC1	; 193
    6b66:	fa 07       	cpc	r31, r26
    6b68:	d9 f7       	brne	.-10     	; 0x6b60 <systemGenerateReport+0x11c>
    6b6a:	e8 e0       	ldi	r30, 0x08	; 8
    6b6c:	fe e0       	ldi	r31, 0x0E	; 14
	     strMemory[i]=data;
    6b6e:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    6b70:	be e0       	ldi	r27, 0x0E	; 14
    6b72:	e7 31       	cpi	r30, 0x17	; 23
    6b74:	fb 07       	cpc	r31, r27
    6b76:	d9 f7       	brne	.-10     	; 0x6b6e <systemGenerateReport+0x12a>
    6b78:	ed ed       	ldi	r30, 0xDD	; 221
    6b7a:	fa e0       	ldi	r31, 0x0A	; 10
	     strMemory[i]=data;
    6b7c:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    6b7e:	8a e0       	ldi	r24, 0x0A	; 10
    6b80:	ec 3e       	cpi	r30, 0xEC	; 236
    6b82:	f8 07       	cpc	r31, r24
    6b84:	d9 f7       	brne	.-10     	; 0x6b7c <systemGenerateReport+0x138>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    6b86:	e1 99       	sbic	0x1c, 1	; 28
    6b88:	fe cf       	rjmp	.-4      	; 0x6b86 <systemGenerateReport+0x142>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    6b8a:	8f e3       	ldi	r24, 0x3F	; 63
    6b8c:	91 e0       	ldi	r25, 0x01	; 1
    6b8e:	9f bb       	out	0x1f, r25	; 31
    6b90:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    6b92:	e0 9a       	sbi	0x1c, 0	; 28
    6b94:	2d b3       	in	r18, 0x1d	; 29
		  FillChar(strTotalMoney,sizeof(strTotalMoney),0);


		  FillChar(strDeltaMoney,sizeof(strDeltaMoney),0);
		  FillChar(strDeltaVolume,sizeof(strDeltaVolume),0);
		  sprintf_P(strShift,PSTR("%d"),eeprom_read_byte(&DefShift));
    6b96:	00 d0       	rcall	.+0      	; 0x6b98 <systemGenerateReport+0x154>
    6b98:	00 d0       	rcall	.+0      	; 0x6b9a <systemGenerateReport+0x156>
    6b9a:	00 d0       	rcall	.+0      	; 0x6b9c <systemGenerateReport+0x158>
    6b9c:	ed b7       	in	r30, 0x3d	; 61
    6b9e:	fe b7       	in	r31, 0x3e	; 62
    6ba0:	31 96       	adiw	r30, 0x01	; 1
    6ba2:	83 e4       	ldi	r24, 0x43	; 67
    6ba4:	9e e0       	ldi	r25, 0x0E	; 14
    6ba6:	ad b7       	in	r26, 0x3d	; 61
    6ba8:	be b7       	in	r27, 0x3e	; 62
    6baa:	12 96       	adiw	r26, 0x02	; 2
    6bac:	9c 93       	st	X, r25
    6bae:	8e 93       	st	-X, r24
    6bb0:	11 97       	sbiw	r26, 0x01	; 1
    6bb2:	82 ea       	ldi	r24, 0xA2	; 162
    6bb4:	95 e0       	ldi	r25, 0x05	; 5
    6bb6:	93 83       	std	Z+3, r25	; 0x03
    6bb8:	82 83       	std	Z+2, r24	; 0x02
    6bba:	24 83       	std	Z+4, r18	; 0x04
    6bbc:	15 82       	std	Z+5, r1	; 0x05
    6bbe:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>

          stGenerateReport=grCreateReportHeader;
    6bc2:	82 e0       	ldi	r24, 0x02	; 2
    6bc4:	80 93 14 02 	sts	0x0214, r24
    6bc8:	ed b7       	in	r30, 0x3d	; 61
    6bca:	fe b7       	in	r31, 0x3e	; 62
    6bcc:	36 96       	adiw	r30, 0x06	; 6
    6bce:	0f b6       	in	r0, 0x3f	; 63
    6bd0:	f8 94       	cli
    6bd2:	fe bf       	out	0x3e, r31	; 62
    6bd4:	0f be       	out	0x3f, r0	; 63
    6bd6:	ed bf       	out	0x3d, r30	; 61
    6bd8:	0c 94 3b 40 	jmp	0x8076	; 0x8076 <systemGenerateReport+0x1632>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    6bdc:	ce 01       	movw	r24, r28
    6bde:	8b 5a       	subi	r24, 0xAB	; 171
    6be0:	9f 4f       	sbci	r25, 0xFF	; 255
    6be2:	63 e4       	ldi	r22, 0x43	; 67
    6be4:	78 e0       	ldi	r23, 0x08	; 8
    6be6:	44 e1       	ldi	r20, 0x14	; 20
    6be8:	50 e0       	ldi	r21, 0x00	; 0
    6bea:	26 ef       	ldi	r18, 0xF6	; 246
    6bec:	32 e1       	ldi	r19, 0x12	; 18
    6bee:	0e 94 7a b5 	call	0x16af4	; 0x16af4 <__eerd_block>
	      break;
	 case grCreateReportHeader://Border: btTopLeft,btTopCenter,btTopRight,btMiddleLeft,btMiddleCenter,btMiddleRight,btBottomLeft,btBottomCenter,btBottomRight,btVertical,btHorizontal
		  eeprom_read_block((void*) &LastShiftDateTime, (const void*) &DefLastShiftDateTime, sizeof(DefLastShiftDateTime));
          
		  InserBorder(btTopLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btTopRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);
    6bf2:	81 e0       	ldi	r24, 0x01	; 1
    6bf4:	6f ec       	ldi	r22, 0xCF	; 207
    6bf6:	75 e0       	ldi	r23, 0x05	; 5
    6bf8:	41 e0       	ldi	r20, 0x01	; 1
    6bfa:	22 e0       	ldi	r18, 0x02	; 2
    6bfc:	32 e0       	ldi	r19, 0x02	; 2
    6bfe:	0e 94 81 1a 	call	0x3502	; 0x3502 <InserBorder>
    6c02:	8b e0       	ldi	r24, 0x0B	; 11
    6c04:	6f ec       	ldi	r22, 0xCF	; 207
    6c06:	75 e0       	ldi	r23, 0x05	; 5
    6c08:	4a e2       	ldi	r20, 0x2A	; 42
    6c0a:	22 e0       	ldi	r18, 0x02	; 2
    6c0c:	32 e0       	ldi	r19, 0x02	; 2
    6c0e:	0e 94 81 1a 	call	0x3502	; 0x3502 <InserBorder>
    6c12:	83 e0       	ldi	r24, 0x03	; 3
    6c14:	6f ec       	ldi	r22, 0xCF	; 207
    6c16:	75 e0       	ldi	r23, 0x05	; 5
    6c18:	41 e0       	ldi	r20, 0x01	; 1
    6c1a:	22 e0       	ldi	r18, 0x02	; 2
    6c1c:	32 e0       	ldi	r19, 0x02	; 2
    6c1e:	0e 94 81 1a 	call	0x3502	; 0x3502 <InserBorder>
    6c22:	8c e0       	ldi	r24, 0x0C	; 12
    6c24:	6f ec       	ldi	r22, 0xCF	; 207
    6c26:	75 e0       	ldi	r23, 0x05	; 5
    6c28:	41 e0       	ldi	r20, 0x01	; 1
    6c2a:	22 e0       	ldi	r18, 0x02	; 2
    6c2c:	32 e0       	ldi	r19, 0x02	; 2
    6c2e:	0e 94 81 1a 	call	0x3502	; 0x3502 <InserBorder>
	      sprintf_P(strReport,PSTR("        Laporan Tutup Shift: %s      "),strShift);CreateReport(strReport,PrintBuffer,&RepPos);
    6c32:	00 d0       	rcall	.+0      	; 0x6c34 <systemGenerateReport+0x1f0>
    6c34:	00 d0       	rcall	.+0      	; 0x6c36 <systemGenerateReport+0x1f2>
    6c36:	00 d0       	rcall	.+0      	; 0x6c38 <systemGenerateReport+0x1f4>
    6c38:	ed b7       	in	r30, 0x3d	; 61
    6c3a:	fe b7       	in	r31, 0x3e	; 62
    6c3c:	31 96       	adiw	r30, 0x01	; 1
    6c3e:	8e 01       	movw	r16, r28
    6c40:	0b 55       	subi	r16, 0x5B	; 91
    6c42:	1f 4f       	sbci	r17, 0xFF	; 255
    6c44:	ad b7       	in	r26, 0x3d	; 61
    6c46:	be b7       	in	r27, 0x3e	; 62
    6c48:	12 96       	adiw	r26, 0x02	; 2
    6c4a:	1c 93       	st	X, r17
    6c4c:	0e 93       	st	-X, r16
    6c4e:	11 97       	sbiw	r26, 0x01	; 1
    6c50:	8c e7       	ldi	r24, 0x7C	; 124
    6c52:	95 e0       	ldi	r25, 0x05	; 5
    6c54:	93 83       	std	Z+3, r25	; 0x03
    6c56:	82 83       	std	Z+2, r24	; 0x02
    6c58:	83 e4       	ldi	r24, 0x43	; 67
    6c5a:	9e e0       	ldi	r25, 0x0E	; 14
    6c5c:	95 83       	std	Z+5, r25	; 0x05
    6c5e:	84 83       	std	Z+4, r24	; 0x04
    6c60:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    6c64:	ed b7       	in	r30, 0x3d	; 61
    6c66:	fe b7       	in	r31, 0x3e	; 62
    6c68:	36 96       	adiw	r30, 0x06	; 6
    6c6a:	0f b6       	in	r0, 0x3f	; 63
    6c6c:	f8 94       	cli
    6c6e:	fe bf       	out	0x3e, r31	; 62
    6c70:	0f be       	out	0x3f, r0	; 63
    6c72:	ed bf       	out	0x3d, r30	; 61
    6c74:	c8 01       	movw	r24, r16
    6c76:	6f ec       	ldi	r22, 0xCF	; 207
    6c78:	75 e0       	ldi	r23, 0x05	; 5
    6c7a:	42 e0       	ldi	r20, 0x02	; 2
    6c7c:	52 e0       	ldi	r21, 0x02	; 2
    6c7e:	0e 94 89 22 	call	0x4512	; 0x4512 <CreateReport>
		  InserBorder(btMiddleLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btMiddleRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);     
    6c82:	84 e0       	ldi	r24, 0x04	; 4
    6c84:	6f ec       	ldi	r22, 0xCF	; 207
    6c86:	75 e0       	ldi	r23, 0x05	; 5
    6c88:	41 e0       	ldi	r20, 0x01	; 1
    6c8a:	22 e0       	ldi	r18, 0x02	; 2
    6c8c:	32 e0       	ldi	r19, 0x02	; 2
    6c8e:	0e 94 81 1a 	call	0x3502	; 0x3502 <InserBorder>
    6c92:	8b e0       	ldi	r24, 0x0B	; 11
    6c94:	6f ec       	ldi	r22, 0xCF	; 207
    6c96:	75 e0       	ldi	r23, 0x05	; 5
    6c98:	4a e2       	ldi	r20, 0x2A	; 42
    6c9a:	22 e0       	ldi	r18, 0x02	; 2
    6c9c:	32 e0       	ldi	r19, 0x02	; 2
    6c9e:	0e 94 81 1a 	call	0x3502	; 0x3502 <InserBorder>
    6ca2:	86 e0       	ldi	r24, 0x06	; 6
    6ca4:	6f ec       	ldi	r22, 0xCF	; 207
    6ca6:	75 e0       	ldi	r23, 0x05	; 5
    6ca8:	41 e0       	ldi	r20, 0x01	; 1
    6caa:	22 e0       	ldi	r18, 0x02	; 2
    6cac:	32 e0       	ldi	r19, 0x02	; 2
    6cae:	0e 94 81 1a 	call	0x3502	; 0x3502 <InserBorder>
    6cb2:	8c e0       	ldi	r24, 0x0C	; 12
    6cb4:	6f ec       	ldi	r22, 0xCF	; 207
    6cb6:	75 e0       	ldi	r23, 0x05	; 5
    6cb8:	41 e0       	ldi	r20, 0x01	; 1
    6cba:	22 e0       	ldi	r18, 0x02	; 2
    6cbc:	32 e0       	ldi	r19, 0x02	; 2
    6cbe:	0e 94 81 1a 	call	0x3502	; 0x3502 <InserBorder>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    6cc2:	e1 99       	sbic	0x1c, 1	; 28
    6cc4:	fe cf       	rjmp	.-4      	; 0x6cc2 <systemGenerateReport+0x27e>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    6cc6:	80 e0       	ldi	r24, 0x00	; 0
    6cc8:	90 e0       	ldi	r25, 0x00	; 0
    6cca:	9f bb       	out	0x1f, r25	; 31
    6ccc:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    6cce:	e0 9a       	sbi	0x1c, 0	; 28
    6cd0:	2d b3       	in	r18, 0x1d	; 29
	      sprintf_P(strReport,PSTR("Terminal ID : %.2d                   "),eeprom_read_byte(&DefIFT_ID));CreateReport(strReport,PrintBuffer,&RepPos);
    6cd2:	00 d0       	rcall	.+0      	; 0x6cd4 <systemGenerateReport+0x290>
    6cd4:	00 d0       	rcall	.+0      	; 0x6cd6 <systemGenerateReport+0x292>
    6cd6:	00 d0       	rcall	.+0      	; 0x6cd8 <systemGenerateReport+0x294>
    6cd8:	ed b7       	in	r30, 0x3d	; 61
    6cda:	fe b7       	in	r31, 0x3e	; 62
    6cdc:	31 96       	adiw	r30, 0x01	; 1
    6cde:	8e 01       	movw	r16, r28
    6ce0:	0b 55       	subi	r16, 0x5B	; 91
    6ce2:	1f 4f       	sbci	r17, 0xFF	; 255
    6ce4:	ad b7       	in	r26, 0x3d	; 61
    6ce6:	be b7       	in	r27, 0x3e	; 62
    6ce8:	12 96       	adiw	r26, 0x02	; 2
    6cea:	1c 93       	st	X, r17
    6cec:	0e 93       	st	-X, r16
    6cee:	11 97       	sbiw	r26, 0x01	; 1
    6cf0:	86 e5       	ldi	r24, 0x56	; 86
    6cf2:	95 e0       	ldi	r25, 0x05	; 5
    6cf4:	93 83       	std	Z+3, r25	; 0x03
    6cf6:	82 83       	std	Z+2, r24	; 0x02
    6cf8:	24 83       	std	Z+4, r18	; 0x04
    6cfa:	15 82       	std	Z+5, r1	; 0x05
    6cfc:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    6d00:	ed b7       	in	r30, 0x3d	; 61
    6d02:	fe b7       	in	r31, 0x3e	; 62
    6d04:	36 96       	adiw	r30, 0x06	; 6
    6d06:	0f b6       	in	r0, 0x3f	; 63
    6d08:	f8 94       	cli
    6d0a:	fe bf       	out	0x3e, r31	; 62
    6d0c:	0f be       	out	0x3f, r0	; 63
    6d0e:	ed bf       	out	0x3d, r30	; 61
    6d10:	c8 01       	movw	r24, r16
    6d12:	6f ec       	ldi	r22, 0xCF	; 207
    6d14:	75 e0       	ldi	r23, 0x05	; 5
    6d16:	42 e0       	ldi	r20, 0x02	; 2
    6d18:	52 e0       	ldi	r21, 0x02	; 2
    6d1a:	0e 94 89 22 	call	0x4512	; 0x4512 <CreateReport>
	      sprintf_P(strReport,PSTR("Awal  Shift : %s "),LastShiftDateTime);             CreateReport(strReport,PrintBuffer,&RepPos);
    6d1e:	00 d0       	rcall	.+0      	; 0x6d20 <systemGenerateReport+0x2dc>
    6d20:	00 d0       	rcall	.+0      	; 0x6d22 <systemGenerateReport+0x2de>
    6d22:	00 d0       	rcall	.+0      	; 0x6d24 <systemGenerateReport+0x2e0>
    6d24:	ed b7       	in	r30, 0x3d	; 61
    6d26:	fe b7       	in	r31, 0x3e	; 62
    6d28:	31 96       	adiw	r30, 0x01	; 1
    6d2a:	ad b7       	in	r26, 0x3d	; 61
    6d2c:	be b7       	in	r27, 0x3e	; 62
    6d2e:	12 96       	adiw	r26, 0x02	; 2
    6d30:	1c 93       	st	X, r17
    6d32:	0e 93       	st	-X, r16
    6d34:	11 97       	sbiw	r26, 0x01	; 1
    6d36:	84 e4       	ldi	r24, 0x44	; 68
    6d38:	95 e0       	ldi	r25, 0x05	; 5
    6d3a:	93 83       	std	Z+3, r25	; 0x03
    6d3c:	82 83       	std	Z+2, r24	; 0x02
    6d3e:	ce 01       	movw	r24, r28
    6d40:	8b 5a       	subi	r24, 0xAB	; 171
    6d42:	9f 4f       	sbci	r25, 0xFF	; 255
    6d44:	95 83       	std	Z+5, r25	; 0x05
    6d46:	84 83       	std	Z+4, r24	; 0x04
    6d48:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    6d4c:	ed b7       	in	r30, 0x3d	; 61
    6d4e:	fe b7       	in	r31, 0x3e	; 62
    6d50:	36 96       	adiw	r30, 0x06	; 6
    6d52:	0f b6       	in	r0, 0x3f	; 63
    6d54:	f8 94       	cli
    6d56:	fe bf       	out	0x3e, r31	; 62
    6d58:	0f be       	out	0x3f, r0	; 63
    6d5a:	ed bf       	out	0x3d, r30	; 61
    6d5c:	c8 01       	movw	r24, r16
    6d5e:	6f ec       	ldi	r22, 0xCF	; 207
    6d60:	75 e0       	ldi	r23, 0x05	; 5
    6d62:	42 e0       	ldi	r20, 0x02	; 2
    6d64:	52 e0       	ldi	r21, 0x02	; 2
    6d66:	0e 94 89 22 	call	0x4512	; 0x4512 <CreateReport>
	      sprintf_P(strReport,PSTR("Akhir Shift : %s "),CurrentShiftDateTime);      CreateReport(strReport,PrintBuffer,&RepPos);
    6d6a:	00 d0       	rcall	.+0      	; 0x6d6c <systemGenerateReport+0x328>
    6d6c:	00 d0       	rcall	.+0      	; 0x6d6e <systemGenerateReport+0x32a>
    6d6e:	00 d0       	rcall	.+0      	; 0x6d70 <systemGenerateReport+0x32c>
    6d70:	ed b7       	in	r30, 0x3d	; 61
    6d72:	fe b7       	in	r31, 0x3e	; 62
    6d74:	31 96       	adiw	r30, 0x01	; 1
    6d76:	ad b7       	in	r26, 0x3d	; 61
    6d78:	be b7       	in	r27, 0x3e	; 62
    6d7a:	12 96       	adiw	r26, 0x02	; 2
    6d7c:	1c 93       	st	X, r17
    6d7e:	0e 93       	st	-X, r16
    6d80:	11 97       	sbiw	r26, 0x01	; 1
    6d82:	82 e3       	ldi	r24, 0x32	; 50
    6d84:	95 e0       	ldi	r25, 0x05	; 5
    6d86:	93 83       	std	Z+3, r25	; 0x03
    6d88:	82 83       	std	Z+2, r24	; 0x02
    6d8a:	81 e7       	ldi	r24, 0x71	; 113
    6d8c:	99 e0       	ldi	r25, 0x09	; 9
    6d8e:	95 83       	std	Z+5, r25	; 0x05
    6d90:	84 83       	std	Z+4, r24	; 0x04
    6d92:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    6d96:	ed b7       	in	r30, 0x3d	; 61
    6d98:	fe b7       	in	r31, 0x3e	; 62
    6d9a:	36 96       	adiw	r30, 0x06	; 6
    6d9c:	0f b6       	in	r0, 0x3f	; 63
    6d9e:	f8 94       	cli
    6da0:	fe bf       	out	0x3e, r31	; 62
    6da2:	0f be       	out	0x3f, r0	; 63
    6da4:	ed bf       	out	0x3d, r30	; 61
    6da6:	c8 01       	movw	r24, r16
    6da8:	6f ec       	ldi	r22, 0xCF	; 207
    6daa:	75 e0       	ldi	r23, 0x05	; 5
    6dac:	42 e0       	ldi	r20, 0x02	; 2
    6dae:	52 e0       	ldi	r21, 0x02	; 2
    6db0:	0e 94 89 22 	call	0x4512	; 0x4512 <CreateReport>
	      //sprintf_P(strReport,PSTR("Transaksi   : %s "),DeltaTransaction);      CreateReport(strReport,PrintBuffer,&RepPos);
          InserBorder(btBottomLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btBottomRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);
    6db4:	87 e0       	ldi	r24, 0x07	; 7
    6db6:	6f ec       	ldi	r22, 0xCF	; 207
    6db8:	75 e0       	ldi	r23, 0x05	; 5
    6dba:	41 e0       	ldi	r20, 0x01	; 1
    6dbc:	22 e0       	ldi	r18, 0x02	; 2
    6dbe:	32 e0       	ldi	r19, 0x02	; 2
    6dc0:	0e 94 81 1a 	call	0x3502	; 0x3502 <InserBorder>
    6dc4:	8b e0       	ldi	r24, 0x0B	; 11
    6dc6:	6f ec       	ldi	r22, 0xCF	; 207
    6dc8:	75 e0       	ldi	r23, 0x05	; 5
    6dca:	4a e2       	ldi	r20, 0x2A	; 42
    6dcc:	22 e0       	ldi	r18, 0x02	; 2
    6dce:	32 e0       	ldi	r19, 0x02	; 2
    6dd0:	0e 94 81 1a 	call	0x3502	; 0x3502 <InserBorder>
    6dd4:	89 e0       	ldi	r24, 0x09	; 9
    6dd6:	6f ec       	ldi	r22, 0xCF	; 207
    6dd8:	75 e0       	ldi	r23, 0x05	; 5
    6dda:	41 e0       	ldi	r20, 0x01	; 1
    6ddc:	22 e0       	ldi	r18, 0x02	; 2
    6dde:	32 e0       	ldi	r19, 0x02	; 2
    6de0:	0e 94 81 1a 	call	0x3502	; 0x3502 <InserBorder>
    6de4:	8c e0       	ldi	r24, 0x0C	; 12
    6de6:	6f ec       	ldi	r22, 0xCF	; 207
    6de8:	75 e0       	ldi	r23, 0x05	; 5
    6dea:	41 e0       	ldi	r20, 0x01	; 1
    6dec:	22 e0       	ldi	r18, 0x02	; 2
    6dee:	32 e0       	ldi	r19, 0x02	; 2
    6df0:	0e 94 81 1a 	call	0x3502	; 0x3502 <InserBorder>
		  /*
	      if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("PUMP-PRODUCT   VOLUME(L)    RUPIAH(RP)"));         
	      else sprintf_P(strReport,PSTR("PUMP-PRODUCT   VOLUME(L)              "));CreateReport(strReport,PrintBuffer,&RepPos);
          InserBorder(btBottomLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btBottomRight,PrintBuffer,1,&RepPos);//InserBorder(btNewLine,PrintBuffer,1,&RepPos);         		 
          */
		  ClearList(GradeList);
    6df4:	84 e0       	ldi	r24, 0x04	; 4
    6df6:	92 e0       	ldi	r25, 0x02	; 2
    6df8:	0e 94 2a 23 	call	0x4654	; 0x4654 <ClearList>
		  cmdPrint=0b10000000;//PrintHeader
    6dfc:	80 e8       	ldi	r24, 0x80	; 128
    6dfe:	80 93 cb 01 	sts	0x01CB, r24
		  LengthMessage81=RepPos+1;
    6e02:	80 91 02 02 	lds	r24, 0x0202
    6e06:	90 91 03 02 	lds	r25, 0x0203
    6e0a:	01 96       	adiw	r24, 0x01	; 1
    6e0c:	90 93 a1 01 	sts	0x01A1, r25
    6e10:	80 93 a0 01 	sts	0x01A0, r24
		  IsFreePrinting=True;
    6e14:	81 e0       	ldi	r24, 0x01	; 1
    6e16:	80 93 bf 01 	sts	0x01BF, r24
          IsBusyFreePrinting=True;
    6e1a:	80 93 ca 01 	sts	0x01CA, r24
		  		  
          stGenerateReport=grWaitPrinted1;
    6e1e:	83 e0       	ldi	r24, 0x03	; 3
    6e20:	0c 94 33 40 	jmp	0x8066	; 0x8066 <systemGenerateReport+0x1622>
	      break;
     case grWaitPrinted1:
          if (IsBusyFreePrinting==False)
    6e24:	80 91 ca 01 	lds	r24, 0x01CA
    6e28:	88 23       	and	r24, r24
    6e2a:	11 f0       	breq	.+4      	; 0x6e30 <systemGenerateReport+0x3ec>
    6e2c:	0c 94 3b 40 	jmp	0x8076	; 0x8076 <systemGenerateReport+0x1632>
		      stGenerateReport=grGenerateLabel;//grGenerateReportData;//grFinishGenerateReport;
    6e30:	84 e0       	ldi	r24, 0x04	; 4
    6e32:	0c 94 33 40 	jmp	0x8066	; 0x8066 <systemGenerateReport+0x1622>
	      break;
     case grGenerateLabel:
          RepPos=0;
    6e36:	10 92 03 02 	sts	0x0203, r1
    6e3a:	10 92 02 02 	sts	0x0202, r1
          InserBorder(btTopLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btTopRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          
    6e3e:	81 e0       	ldi	r24, 0x01	; 1
    6e40:	6f ec       	ldi	r22, 0xCF	; 207
    6e42:	75 e0       	ldi	r23, 0x05	; 5
    6e44:	41 e0       	ldi	r20, 0x01	; 1
    6e46:	22 e0       	ldi	r18, 0x02	; 2
    6e48:	32 e0       	ldi	r19, 0x02	; 2
    6e4a:	0e 94 81 1a 	call	0x3502	; 0x3502 <InserBorder>
    6e4e:	8b e0       	ldi	r24, 0x0B	; 11
    6e50:	6f ec       	ldi	r22, 0xCF	; 207
    6e52:	75 e0       	ldi	r23, 0x05	; 5
    6e54:	4a e2       	ldi	r20, 0x2A	; 42
    6e56:	22 e0       	ldi	r18, 0x02	; 2
    6e58:	32 e0       	ldi	r19, 0x02	; 2
    6e5a:	0e 94 81 1a 	call	0x3502	; 0x3502 <InserBorder>
    6e5e:	83 e0       	ldi	r24, 0x03	; 3
    6e60:	6f ec       	ldi	r22, 0xCF	; 207
    6e62:	75 e0       	ldi	r23, 0x05	; 5
    6e64:	41 e0       	ldi	r20, 0x01	; 1
    6e66:	22 e0       	ldi	r18, 0x02	; 2
    6e68:	32 e0       	ldi	r19, 0x02	; 2
    6e6a:	0e 94 81 1a 	call	0x3502	; 0x3502 <InserBorder>
    6e6e:	8c e0       	ldi	r24, 0x0C	; 12
    6e70:	6f ec       	ldi	r22, 0xCF	; 207
    6e72:	75 e0       	ldi	r23, 0x05	; 5
    6e74:	41 e0       	ldi	r20, 0x01	; 1
    6e76:	22 e0       	ldi	r18, 0x02	; 2
    6e78:	32 e0       	ldi	r19, 0x02	; 2
    6e7a:	0e 94 81 1a 	call	0x3502	; 0x3502 <InserBorder>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    6e7e:	e1 99       	sbic	0x1c, 1	; 28
    6e80:	fe cf       	rjmp	.-4      	; 0x6e7e <systemGenerateReport+0x43a>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    6e82:	81 ec       	ldi	r24, 0xC1	; 193
    6e84:	93 e0       	ldi	r25, 0x03	; 3
    6e86:	9f bb       	out	0x1f, r25	; 31
    6e88:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    6e8a:	e0 9a       	sbi	0x1c, 0	; 28
    6e8c:	8d b3       	in	r24, 0x1d	; 29
    6e8e:	9e 01       	movw	r18, r28
    6e90:	2b 55       	subi	r18, 0x5B	; 91
    6e92:	3f 4f       	sbci	r19, 0xFF	; 255
	      if (eeprom_read_byte(&DefPrintMoney)==True)
    6e94:	81 30       	cpi	r24, 0x01	; 1
    6e96:	79 f4       	brne	.+30     	; 0x6eb6 <systemGenerateReport+0x472>
		       sprintf_P(strReport,PSTR("PUMP-PRODUCT   VOLUME(L)    RUPIAH(RP)"));         
    6e98:	00 d0       	rcall	.+0      	; 0x6e9a <systemGenerateReport+0x456>
    6e9a:	00 d0       	rcall	.+0      	; 0x6e9c <systemGenerateReport+0x458>
    6e9c:	ad b7       	in	r26, 0x3d	; 61
    6e9e:	be b7       	in	r27, 0x3e	; 62
    6ea0:	12 96       	adiw	r26, 0x02	; 2
    6ea2:	3c 93       	st	X, r19
    6ea4:	2e 93       	st	-X, r18
    6ea6:	11 97       	sbiw	r26, 0x01	; 1
    6ea8:	8b e0       	ldi	r24, 0x0B	; 11
    6eaa:	95 e0       	ldi	r25, 0x05	; 5
    6eac:	14 96       	adiw	r26, 0x04	; 4
    6eae:	9c 93       	st	X, r25
    6eb0:	8e 93       	st	-X, r24
    6eb2:	13 97       	sbiw	r26, 0x03	; 3
    6eb4:	0a c0       	rjmp	.+20     	; 0x6eca <systemGenerateReport+0x486>
	      else sprintf_P(strReport,PSTR("PUMP-PRODUCT   VOLUME(L)              "));CreateReport(strReport,PrintBuffer,&RepPos);
    6eb6:	00 d0       	rcall	.+0      	; 0x6eb8 <systemGenerateReport+0x474>
    6eb8:	00 d0       	rcall	.+0      	; 0x6eba <systemGenerateReport+0x476>
    6eba:	ed b7       	in	r30, 0x3d	; 61
    6ebc:	fe b7       	in	r31, 0x3e	; 62
    6ebe:	32 83       	std	Z+2, r19	; 0x02
    6ec0:	21 83       	std	Z+1, r18	; 0x01
    6ec2:	84 ee       	ldi	r24, 0xE4	; 228
    6ec4:	94 e0       	ldi	r25, 0x04	; 4
    6ec6:	94 83       	std	Z+4, r25	; 0x04
    6ec8:	83 83       	std	Z+3, r24	; 0x03
    6eca:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    6ece:	0f 90       	pop	r0
    6ed0:	0f 90       	pop	r0
    6ed2:	0f 90       	pop	r0
    6ed4:	0f 90       	pop	r0
    6ed6:	ce 01       	movw	r24, r28
    6ed8:	8b 55       	subi	r24, 0x5B	; 91
    6eda:	9f 4f       	sbci	r25, 0xFF	; 255
    6edc:	6f ec       	ldi	r22, 0xCF	; 207
    6ede:	75 e0       	ldi	r23, 0x05	; 5
    6ee0:	42 e0       	ldi	r20, 0x02	; 2
    6ee2:	52 e0       	ldi	r21, 0x02	; 2
    6ee4:	0e 94 89 22 	call	0x4512	; 0x4512 <CreateReport>
          InserBorder(btBottomLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btBottomRight,PrintBuffer,1,&RepPos);//InserBorder(btNewLine,PrintBuffer,1,&RepPos);         		 
    6ee8:	87 e0       	ldi	r24, 0x07	; 7
    6eea:	6f ec       	ldi	r22, 0xCF	; 207
    6eec:	75 e0       	ldi	r23, 0x05	; 5
    6eee:	41 e0       	ldi	r20, 0x01	; 1
    6ef0:	22 e0       	ldi	r18, 0x02	; 2
    6ef2:	32 e0       	ldi	r19, 0x02	; 2
    6ef4:	0e 94 81 1a 	call	0x3502	; 0x3502 <InserBorder>
    6ef8:	8b e0       	ldi	r24, 0x0B	; 11
    6efa:	6f ec       	ldi	r22, 0xCF	; 207
    6efc:	75 e0       	ldi	r23, 0x05	; 5
    6efe:	4a e2       	ldi	r20, 0x2A	; 42
    6f00:	22 e0       	ldi	r18, 0x02	; 2
    6f02:	32 e0       	ldi	r19, 0x02	; 2
    6f04:	0e 94 81 1a 	call	0x3502	; 0x3502 <InserBorder>
    6f08:	89 e0       	ldi	r24, 0x09	; 9
    6f0a:	6f ec       	ldi	r22, 0xCF	; 207
    6f0c:	75 e0       	ldi	r23, 0x05	; 5
    6f0e:	41 e0       	ldi	r20, 0x01	; 1
    6f10:	22 e0       	ldi	r18, 0x02	; 2
    6f12:	32 e0       	ldi	r19, 0x02	; 2
    6f14:	0e 94 81 1a 	call	0x3502	; 0x3502 <InserBorder>
          
		  cmdPrint=0b00000000;
    6f18:	10 92 cb 01 	sts	0x01CB, r1
		  LengthMessage81=RepPos+1;
    6f1c:	80 91 02 02 	lds	r24, 0x0202
    6f20:	90 91 03 02 	lds	r25, 0x0203
    6f24:	01 96       	adiw	r24, 0x01	; 1
    6f26:	90 93 a1 01 	sts	0x01A1, r25
    6f2a:	80 93 a0 01 	sts	0x01A0, r24

		  IsFreePrinting=True;
    6f2e:	81 e0       	ldi	r24, 0x01	; 1
    6f30:	80 93 bf 01 	sts	0x01BF, r24
	      IsBusyFreePrinting=True;
    6f34:	80 93 ca 01 	sts	0x01CA, r24

		  stGenerateReport=grWaitLabelPrinted;
    6f38:	85 e0       	ldi	r24, 0x05	; 5
    6f3a:	0c 94 33 40 	jmp	0x8066	; 0x8066 <systemGenerateReport+0x1622>
          if (IsBusyFreePrinting==False)
		      stGenerateReport=grGenerateReportData;//grFinishGenerateReport;
	      break;
     case grGenerateReportData:
	      //Generate: PumpNum, Nozzle, Product
	      if ((xPump>=1)&&(xPump<=8)){
    6f3e:	80 91 13 02 	lds	r24, 0x0213
    6f42:	81 50       	subi	r24, 0x01	; 1
    6f44:	88 30       	cpi	r24, 0x08	; 8
    6f46:	10 f0       	brcs	.+4      	; 0x6f4c <systemGenerateReport+0x508>
    6f48:	0c 94 3b 40 	jmp	0x8076	; 0x8076 <systemGenerateReport+0x1632>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    6f4c:	ce 01       	movw	r24, r28
    6f4e:	07 96       	adiw	r24, 0x07	; 7
    6f50:	65 e4       	ldi	r22, 0x45	; 69
    6f52:	70 e0       	ldi	r23, 0x00	; 0
    6f54:	48 e0       	ldi	r20, 0x08	; 8
    6f56:	50 e0       	ldi	r21, 0x00	; 0
    6f58:	26 ef       	ldi	r18, 0xF6	; 246
    6f5a:	32 e1       	ldi	r19, 0x12	; 18
    6f5c:	0e 94 7a b5 	call	0x16af4	; 0x16af4 <__eerd_block>
		      eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap, 8);
			  PumpNum=PPumpID[xPump-1];
    6f60:	90 91 13 02 	lds	r25, 0x0213
    6f64:	fe 01       	movw	r30, r28
    6f66:	e9 0f       	add	r30, r25
    6f68:	f1 1d       	adc	r31, r1
    6f6a:	86 81       	ldd	r24, Z+6	; 0x06
    6f6c:	80 93 10 02 	sts	0x0210, r24
			  if (PumpNum>0){
    6f70:	88 23       	and	r24, r24
    6f72:	09 f4       	brne	.+2      	; 0x6f76 <systemGenerateReport+0x532>
    6f74:	4b c0       	rjmp	.+150    	; 0x700c <systemGenerateReport+0x5c8>
    6f76:	91 9f       	mul	r25, r17
    6f78:	b0 01       	movw	r22, r0
    6f7a:	11 24       	eor	r1, r1
    6f7c:	61 5b       	subi	r22, 0xB1	; 177
    6f7e:	7f 4f       	sbci	r23, 0xFF	; 255
    6f80:	ce 01       	movw	r24, r28
    6f82:	01 96       	adiw	r24, 0x01	; 1
    6f84:	46 e0       	ldi	r20, 0x06	; 6
    6f86:	50 e0       	ldi	r21, 0x00	; 0
    6f88:	26 ef       	ldi	r18, 0xF6	; 246
    6f8a:	32 e1       	ldi	r19, 0x12	; 18
    6f8c:	0e 94 7a b5 	call	0x16af4	; 0x16af4 <__eerd_block>
				  eeprom_read_block((void*) &PProductID, (const void*) &DefNozzleMap[xPump-1], 6);
				  xGrade=PProductID[xNozzle-1];
    6f90:	80 91 12 02 	lds	r24, 0x0212
    6f94:	fe 01       	movw	r30, r28
    6f96:	e8 0f       	add	r30, r24
    6f98:	f1 1d       	adc	r31, r1
    6f9a:	80 81       	ld	r24, Z
    6f9c:	80 93 11 02 	sts	0x0211, r24
    6fa0:	61 e4       	ldi	r22, 0x41	; 65
    6fa2:	c6 2e       	mov	r12, r22
    6fa4:	69 e0       	ldi	r22, 0x09	; 9
    6fa6:	d6 2e       	mov	r13, r22

				  if (xGrade>0){
    6fa8:	88 23       	and	r24, r24
    6faa:	99 f0       	breq	.+38     	; 0x6fd2 <systemGenerateReport+0x58e>
				      GetProductName(xGrade,strProduct);
    6fac:	b6 01       	movw	r22, r12
    6fae:	0e 94 5b 2e 	call	0x5cb6	; 0x5cb6 <GetProductName>
                      GradeUsed=xGrade;
    6fb2:	80 91 11 02 	lds	r24, 0x0211
    6fb6:	80 93 0e 02 	sts	0x020E, r24
					  xGrade=xNozzle;//
    6fba:	80 91 12 02 	lds	r24, 0x0212
    6fbe:	80 93 11 02 	sts	0x0211, r24
					  PumpNozzle=xNozzle;
    6fc2:	80 93 0f 02 	sts	0x020F, r24
					  xNozzle++;
    6fc6:	8f 5f       	subi	r24, 0xFF	; 255
    6fc8:	80 93 12 02 	sts	0x0212, r24
					  stGenerateReport=grCreateReportTotalizer;
    6fcc:	88 e0       	ldi	r24, 0x08	; 8
    6fce:	0c 94 33 40 	jmp	0x8066	; 0x8066 <systemGenerateReport+0x1622>
				  }
				  else{sprintf_P(strProduct,PSTR("N/A"));			  
    6fd2:	00 d0       	rcall	.+0      	; 0x6fd4 <systemGenerateReport+0x590>
    6fd4:	00 d0       	rcall	.+0      	; 0x6fd6 <systemGenerateReport+0x592>
    6fd6:	ad b7       	in	r26, 0x3d	; 61
    6fd8:	be b7       	in	r27, 0x3e	; 62
    6fda:	12 96       	adiw	r26, 0x02	; 2
    6fdc:	dc 92       	st	X, r13
    6fde:	ce 92       	st	-X, r12
    6fe0:	11 97       	sbiw	r26, 0x01	; 1
    6fe2:	80 ee       	ldi	r24, 0xE0	; 224
    6fe4:	94 e0       	ldi	r25, 0x04	; 4
    6fe6:	14 96       	adiw	r26, 0x04	; 4
    6fe8:	9c 93       	st	X, r25
    6fea:	8e 93       	st	-X, r24
    6fec:	13 97       	sbiw	r26, 0x03	; 3
    6fee:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
					   xNozzle++;
    6ff2:	80 91 12 02 	lds	r24, 0x0212
    6ff6:	8f 5f       	subi	r24, 0xFF	; 255
    6ff8:	80 93 12 02 	sts	0x0212, r24
					   if (xNozzle>6)stGenerateReport=grNextPump;
    6ffc:	0f 90       	pop	r0
    6ffe:	0f 90       	pop	r0
    7000:	0f 90       	pop	r0
    7002:	0f 90       	pop	r0
    7004:	87 30       	cpi	r24, 0x07	; 7
    7006:	10 f4       	brcc	.+4      	; 0x700c <systemGenerateReport+0x5c8>
    7008:	0c 94 3b 40 	jmp	0x8076	; 0x8076 <systemGenerateReport+0x1632>
					  }
				}else stGenerateReport=grNextPump;
    700c:	87 e0       	ldi	r24, 0x07	; 7
    700e:	0c 94 33 40 	jmp	0x8066	; 0x8066 <systemGenerateReport+0x1622>
			  }
	      break;
     case grNextPump:
	      xNozzle=1;
    7012:	81 e0       	ldi	r24, 0x01	; 1
    7014:	80 93 12 02 	sts	0x0212, r24
	      xPump++;
    7018:	80 91 13 02 	lds	r24, 0x0213
    701c:	8f 5f       	subi	r24, 0xFF	; 255
    701e:	80 93 13 02 	sts	0x0213, r24
	      if (xPump>8)stGenerateReport=grCreateReportFooter;
    7022:	89 30       	cpi	r24, 0x09	; 9
    7024:	08 f4       	brcc	.+2      	; 0x7028 <systemGenerateReport+0x5e4>
    7026:	93 c4       	rjmp	.+2342   	; 0x794e <systemGenerateReport+0xf0a>
    7028:	8a e0       	ldi	r24, 0x0A	; 10
    702a:	0c 94 33 40 	jmp	0x8066	; 0x8066 <systemGenerateReport+0x1622>
		  else stGenerateReport=grGenerateReportData;
	      break;
     case grCreateReportTotalizer:

          RepPos=0;
    702e:	10 92 03 02 	sts	0x0203, r1
    7032:	10 92 02 02 	sts	0x0202, r1
    7036:	ef ec       	ldi	r30, 0xCF	; 207
    7038:	f5 e0       	ldi	r31, 0x05	; 5
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    703a:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    703c:	b7 e0       	ldi	r27, 0x07	; 7
    703e:	e0 36       	cpi	r30, 0x60	; 96
    7040:	fb 07       	cpc	r31, r27
    7042:	d9 f7       	brne	.-10     	; 0x703a <systemGenerateReport+0x5f6>
    7044:	fe 01       	movw	r30, r28
    7046:	eb 55       	subi	r30, 0x5B	; 91
    7048:	ff 4f       	sbci	r31, 0xFF	; 255
	     strMemory[i]=data;
    704a:	ce 01       	movw	r24, r28
    704c:	8b 50       	subi	r24, 0x0B	; 11
    704e:	9f 4f       	sbci	r25, 0xFF	; 255
    7050:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7052:	e8 17       	cp	r30, r24
    7054:	f9 07       	cpc	r31, r25
    7056:	e1 f7       	brne	.-8      	; 0x7050 <systemGenerateReport+0x60c>
    7058:	e8 e0       	ldi	r30, 0x08	; 8
    705a:	fe e0       	ldi	r31, 0x0E	; 14
	     strMemory[i]=data;
    705c:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    705e:	8e e0       	ldi	r24, 0x0E	; 14
    7060:	e7 31       	cpi	r30, 0x17	; 23
    7062:	f8 07       	cpc	r31, r24
    7064:	d9 f7       	brne	.-10     	; 0x705c <systemGenerateReport+0x618>
    7066:	ed ed       	ldi	r30, 0xDD	; 221
    7068:	fa e0       	ldi	r31, 0x0A	; 10
	     strMemory[i]=data;
    706a:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    706c:	9a e0       	ldi	r25, 0x0A	; 10
    706e:	ec 3e       	cpi	r30, 0xEC	; 236
    7070:	f9 07       	cpc	r31, r25
    7072:	d9 f7       	brne	.-10     	; 0x706a <systemGenerateReport+0x626>
    7074:	fe 01       	movw	r30, r28
    7076:	79 96       	adiw	r30, 0x19	; 25
	     strMemory[i]=data;
    7078:	ce 01       	movw	r24, r28
    707a:	88 96       	adiw	r24, 0x28	; 40
    707c:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    707e:	e8 17       	cp	r30, r24
    7080:	f9 07       	cpc	r31, r25
    7082:	e1 f7       	brne	.-8      	; 0x707c <systemGenerateReport+0x638>
	     strMemory[i]=data;
    7084:	ce 01       	movw	r24, r28
    7086:	c7 96       	adiw	r24, 0x37	; 55
    7088:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    708a:	e8 17       	cp	r30, r24
    708c:	f9 07       	cpc	r31, r25
    708e:	e1 f7       	brne	.-8      	; 0x7088 <systemGenerateReport+0x644>
	     strMemory[i]=data;
    7090:	cf 01       	movw	r24, r30
    7092:	0f 96       	adiw	r24, 0x0f	; 15
    7094:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7096:	e8 17       	cp	r30, r24
    7098:	f9 07       	cpc	r31, r25
    709a:	e1 f7       	brne	.-8      	; 0x7094 <systemGenerateReport+0x650>
    709c:	fe 01       	movw	r30, r28
    709e:	ea 5b       	subi	r30, 0xBA	; 186
    70a0:	ff 4f       	sbci	r31, 0xFF	; 255
	     strMemory[i]=data;
    70a2:	cf 01       	movw	r24, r30
    70a4:	ee 2e       	mov	r14, r30
    70a6:	d9 2e       	mov	r13, r25
    70a8:	0f 96       	adiw	r24, 0x0f	; 15
    70aa:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    70ac:	e8 17       	cp	r30, r24
    70ae:	f9 07       	cpc	r31, r25
    70b0:	e1 f7       	brne	.-8      	; 0x70aa <systemGenerateReport+0x666>
		  FillChar(strLastMoney,sizeof(strLastMoney),0);

		  FillChar(strCurrentVolume,sizeof(strCurrentVolume),0);
		  FillChar(strCurrentMoney,sizeof(strCurrentMoney),0);

          FIPAddr=GetFIPAddr(PumpNum); 
    70b2:	80 91 10 02 	lds	r24, 0x0210
    70b6:	0e 94 e1 1d 	call	0x3bc2	; 0x3bc2 <GetFIPAddr>
		  if (FIPAddr>0){
    70ba:	88 23       	and	r24, r24
    70bc:	49 f1       	breq	.+82     	; 0x7110 <systemGenerateReport+0x6cc>
		      FIPAddr=FIPAddr-1;		  
    70be:	f8 2e       	mov	r15, r24
    70c0:	fa 94       	dec	r15
			  GetTotalizerData(TVOLUME,TOTALIZER_LAST,FIPAddr,PumpNozzle,strLastVolume);
    70c2:	80 e0       	ldi	r24, 0x00	; 0
    70c4:	60 e0       	ldi	r22, 0x00	; 0
    70c6:	4f 2d       	mov	r20, r15
    70c8:	20 91 0f 02 	lds	r18, 0x020F
    70cc:	8e 01       	movw	r16, r28
    70ce:	07 5e       	subi	r16, 0xE7	; 231
    70d0:	1f 4f       	sbci	r17, 0xFF	; 255
    70d2:	0e 94 a0 1e 	call	0x3d40	; 0x3d40 <GetTotalizerData>
			  GetTotalizerData(TMONEY,TOTALIZER_LAST,FIPAddr,PumpNozzle,strLastMoney);
    70d6:	81 e0       	ldi	r24, 0x01	; 1
    70d8:	60 e0       	ldi	r22, 0x00	; 0
    70da:	4f 2d       	mov	r20, r15
    70dc:	20 91 0f 02 	lds	r18, 0x020F
    70e0:	8e 01       	movw	r16, r28
    70e2:	08 5d       	subi	r16, 0xD8	; 216
    70e4:	1f 4f       	sbci	r17, 0xFF	; 255
    70e6:	0e 94 a0 1e 	call	0x3d40	; 0x3d40 <GetTotalizerData>

			  GetTotalizerData(TVOLUME,TOTALIZER_NOW,FIPAddr,PumpNozzle,strCurrentVolume);
    70ea:	80 e0       	ldi	r24, 0x00	; 0
    70ec:	61 e0       	ldi	r22, 0x01	; 1
    70ee:	4f 2d       	mov	r20, r15
    70f0:	20 91 0f 02 	lds	r18, 0x020F
    70f4:	8e 01       	movw	r16, r28
    70f6:	09 5c       	subi	r16, 0xC9	; 201
    70f8:	1f 4f       	sbci	r17, 0xFF	; 255
    70fa:	0e 94 a0 1e 	call	0x3d40	; 0x3d40 <GetTotalizerData>
			  GetTotalizerData(TMONEY,TOTALIZER_NOW,FIPAddr,PumpNozzle,strCurrentMoney);
    70fe:	81 e0       	ldi	r24, 0x01	; 1
    7100:	61 e0       	ldi	r22, 0x01	; 1
    7102:	4f 2d       	mov	r20, r15
    7104:	20 91 0f 02 	lds	r18, 0x020F
    7108:	0e 2d       	mov	r16, r14
    710a:	1d 2d       	mov	r17, r13
    710c:	0e 94 a0 1e 	call	0x3d40	; 0x3d40 <GetTotalizerData>
		  }

		  StrCalc(TMINUS,strCurrentVolume,strLastVolume,strDeltaVolume);
    7110:	80 e0       	ldi	r24, 0x00	; 0
    7112:	be 01       	movw	r22, r28
    7114:	69 5c       	subi	r22, 0xC9	; 201
    7116:	7f 4f       	sbci	r23, 0xFF	; 255
    7118:	ae 01       	movw	r20, r28
    711a:	47 5e       	subi	r20, 0xE7	; 231
    711c:	5f 4f       	sbci	r21, 0xFF	; 255
    711e:	2d ed       	ldi	r18, 0xDD	; 221
    7120:	3a e0       	ldi	r19, 0x0A	; 10
    7122:	0e 94 f3 29 	call	0x53e6	; 0x53e6 <StrCalc>

		  if (IsMinus(strDeltaVolume)==True)
    7126:	8d ed       	ldi	r24, 0xDD	; 221
    7128:	9a e0       	ldi	r25, 0x0A	; 10
    712a:	0e 94 ee 23 	call	0x47dc	; 0x47dc <IsMinus>
    712e:	81 30       	cpi	r24, 0x01	; 1
    7130:	21 f4       	brne	.+8      	; 0x713a <systemGenerateReport+0x6f6>
		      NormalizeOverflow(strDeltaVolume);
    7132:	8d ed       	ldi	r24, 0xDD	; 221
    7134:	9a e0       	ldi	r25, 0x0A	; 10
    7136:	0e 94 8a 2d 	call	0x5b14	; 0x5b14 <NormalizeOverflow>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    713a:	e1 99       	sbic	0x1c, 1	; 28
    713c:	fe cf       	rjmp	.-4      	; 0x713a <systemGenerateReport+0x6f6>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    713e:	57 e3       	ldi	r21, 0x37	; 55
    7140:	85 2e       	mov	r8, r21
    7142:	51 e0       	ldi	r21, 0x01	; 1
    7144:	95 2e       	mov	r9, r21
    7146:	9f ba       	out	0x1f, r9	; 31
    7148:	8e ba       	out	0x1e, r8	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    714a:	e0 9a       	sbi	0x1c, 0	; 28
    714c:	8d b3       	in	r24, 0x1d	; 29

		  //Calculate Wayne Estimated Total Money
		  if (eeprom_read_byte(&DefDispenserBrand)==ST_WAYNE_DART){
    714e:	82 30       	cpi	r24, 0x02	; 2
    7150:	79 f4       	brne	.+30     	; 0x7170 <systemGenerateReport+0x72c>
              GetProductPrice(sPrice,PumpNum,PumpNozzle);//Money = Price x Volume
    7152:	8e 01       	movw	r16, r28
    7154:	01 5f       	subi	r16, 0xF1	; 241
    7156:	1f 4f       	sbci	r17, 0xFF	; 255
    7158:	c8 01       	movw	r24, r16
    715a:	60 91 10 02 	lds	r22, 0x0210
    715e:	40 91 0f 02 	lds	r20, 0x020F
    7162:	0e 94 d1 24 	call	0x49a2	; 0x49a2 <GetProductPrice>
			  StrCalc(TMULTIPLY,sPrice,strDeltaVolume,strDeltaMoney);
    7166:	82 e0       	ldi	r24, 0x02	; 2
    7168:	b8 01       	movw	r22, r16
    716a:	4d ed       	ldi	r20, 0xDD	; 221
    716c:	5a e0       	ldi	r21, 0x0A	; 10
    716e:	07 c0       	rjmp	.+14     	; 0x717e <systemGenerateReport+0x73a>
			  
		  }else StrCalc(TMINUS,strCurrentMoney,strLastMoney,strDeltaMoney);
    7170:	80 e0       	ldi	r24, 0x00	; 0
    7172:	be 01       	movw	r22, r28
    7174:	6a 5b       	subi	r22, 0xBA	; 186
    7176:	7f 4f       	sbci	r23, 0xFF	; 255
    7178:	ae 01       	movw	r20, r28
    717a:	48 5d       	subi	r20, 0xD8	; 216
    717c:	5f 4f       	sbci	r21, 0xFF	; 255
    717e:	28 e0       	ldi	r18, 0x08	; 8
    7180:	3e e0       	ldi	r19, 0x0E	; 14
    7182:	0e 94 f3 29 	call	0x53e6	; 0x53e6 <StrCalc>

		  if (IsMinus(strDeltaMoney)==True)
    7186:	88 e0       	ldi	r24, 0x08	; 8
    7188:	9e e0       	ldi	r25, 0x0E	; 14
    718a:	0e 94 ee 23 	call	0x47dc	; 0x47dc <IsMinus>
    718e:	81 30       	cpi	r24, 0x01	; 1
    7190:	21 f4       	brne	.+8      	; 0x719a <systemGenerateReport+0x756>
		      NormalizeOverflow(strDeltaMoney);
    7192:	88 e0       	ldi	r24, 0x08	; 8
    7194:	9e e0       	ldi	r25, 0x0E	; 14
    7196:	0e 94 8a 2d 	call	0x5b14	; 0x5b14 <NormalizeOverflow>

		  AddList(GradeUsed,GradeList);
    719a:	80 91 0e 02 	lds	r24, 0x020E
    719e:	64 e0       	ldi	r22, 0x04	; 4
    71a0:	72 e0       	ldi	r23, 0x02	; 2
    71a2:	0e 94 f7 22 	call	0x45ee	; 0x45ee <AddList>
		  
		  StrCalc(TPLUS,strTotalVolume,strDeltaVolume,strTotalVolume);
    71a6:	81 e0       	ldi	r24, 0x01	; 1
    71a8:	6c ef       	ldi	r22, 0xFC	; 252
    71aa:	79 e0       	ldi	r23, 0x09	; 9
    71ac:	4d ed       	ldi	r20, 0xDD	; 221
    71ae:	5a e0       	ldi	r21, 0x0A	; 10
    71b0:	9b 01       	movw	r18, r22
    71b2:	0e 94 f3 29 	call	0x53e6	; 0x53e6 <StrCalc>
		  StrCalc(TPLUS,strTotalMoney,strDeltaMoney,strTotalMoney);
    71b6:	81 e0       	ldi	r24, 0x01	; 1
    71b8:	6d ea       	ldi	r22, 0xAD	; 173
    71ba:	7a e0       	ldi	r23, 0x0A	; 10
    71bc:	48 e0       	ldi	r20, 0x08	; 8
    71be:	5e e0       	ldi	r21, 0x0E	; 14
    71c0:	9b 01       	movw	r18, r22
    71c2:	0e 94 f3 29 	call	0x53e6	; 0x53e6 <StrCalc>


		  RemZeroLead(strDeltaMoney);
    71c6:	88 e0       	ldi	r24, 0x08	; 8
    71c8:	9e e0       	ldi	r25, 0x0E	; 14
    71ca:	0e 94 b9 25 	call	0x4b72	; 0x4b72 <RemZeroLead>
		  RemZeroLead(strCurrentMoney);
    71ce:	46 e4       	ldi	r20, 0x46	; 70
    71d0:	c4 2e       	mov	r12, r20
    71d2:	d1 2c       	mov	r13, r1
    71d4:	cc 0e       	add	r12, r28
    71d6:	dd 1e       	adc	r13, r29
    71d8:	c6 01       	movw	r24, r12
    71da:	0e 94 b9 25 	call	0x4b72	; 0x4b72 <RemZeroLead>
		  RemZeroLead(strLastMoney);
    71de:	38 e2       	ldi	r19, 0x28	; 40
    71e0:	e3 2e       	mov	r14, r19
    71e2:	f1 2c       	mov	r15, r1
    71e4:	ec 0e       	add	r14, r28
    71e6:	fd 1e       	adc	r15, r29
    71e8:	c7 01       	movw	r24, r14
    71ea:	0e 94 b9 25 	call	0x4b72	; 0x4b72 <RemZeroLead>

          RemZeroLead(strDeltaVolume);
    71ee:	8d ed       	ldi	r24, 0xDD	; 221
    71f0:	9a e0       	ldi	r25, 0x0A	; 10
    71f2:	0e 94 b9 25 	call	0x4b72	; 0x4b72 <RemZeroLead>
          RemZeroLead(strCurrentVolume);
    71f6:	27 e3       	ldi	r18, 0x37	; 55
    71f8:	a2 2e       	mov	r10, r18
    71fa:	b1 2c       	mov	r11, r1
    71fc:	ac 0e       	add	r10, r28
    71fe:	bd 1e       	adc	r11, r29
    7200:	c5 01       	movw	r24, r10
    7202:	0e 94 b9 25 	call	0x4b72	; 0x4b72 <RemZeroLead>
          RemZeroLead(strLastVolume);
    7206:	8e 01       	movw	r16, r28
    7208:	07 5e       	subi	r16, 0xE7	; 231
    720a:	1f 4f       	sbci	r17, 0xFF	; 255
    720c:	c8 01       	movw	r24, r16
    720e:	0e 94 b9 25 	call	0x4b72	; 0x4b72 <RemZeroLead>

		  FormatTotalizerMoney(strDeltaMoney);
    7212:	88 e0       	ldi	r24, 0x08	; 8
    7214:	9e e0       	ldi	r25, 0x0E	; 14
    7216:	0e 94 ee 34 	call	0x69dc	; 0x69dc <FormatTotalizerMoney>
		  FormatTotalizerMoney(strCurrentMoney);
    721a:	c6 01       	movw	r24, r12
    721c:	0e 94 ee 34 	call	0x69dc	; 0x69dc <FormatTotalizerMoney>
		  FormatTotalizerMoney(strLastMoney);
    7220:	c7 01       	movw	r24, r14
    7222:	0e 94 ee 34 	call	0x69dc	; 0x69dc <FormatTotalizerMoney>

		  FormatTotalizerVolume(strDeltaVolume);
    7226:	8d ed       	ldi	r24, 0xDD	; 221
    7228:	9a e0       	ldi	r25, 0x0A	; 10
    722a:	0e 94 e1 34 	call	0x69c2	; 0x69c2 <FormatTotalizerVolume>
		  FormatTotalizerVolume(strLastVolume);
    722e:	c8 01       	movw	r24, r16
    7230:	0e 94 e1 34 	call	0x69c2	; 0x69c2 <FormatTotalizerVolume>
		  FormatTotalizerVolume(strCurrentVolume); 
    7234:	c5 01       	movw	r24, r10
    7236:	0e 94 e1 34 	call	0x69c2	; 0x69c2 <FormatTotalizerVolume>

          FormatCurrency(strDeltaMoney);
    723a:	88 e0       	ldi	r24, 0x08	; 8
    723c:	9e e0       	ldi	r25, 0x0E	; 14
    723e:	0e 94 b1 33 	call	0x6762	; 0x6762 <FormatCurrency>
		  FormatCurrency(strCurrentMoney);
    7242:	c6 01       	movw	r24, r12
    7244:	0e 94 b1 33 	call	0x6762	; 0x6762 <FormatCurrency>
		  FormatCurrency(strLastMoney);
    7248:	c7 01       	movw	r24, r14
    724a:	0e 94 b1 33 	call	0x6762	; 0x6762 <FormatCurrency>

		  FormatCurrency(strDeltaVolume);		  
    724e:	8d ed       	ldi	r24, 0xDD	; 221
    7250:	9a e0       	ldi	r25, 0x0A	; 10
    7252:	0e 94 b1 33 	call	0x6762	; 0x6762 <FormatCurrency>
		  FormatCurrency(strLastVolume);
    7256:	c8 01       	movw	r24, r16
    7258:	0e 94 b1 33 	call	0x6762	; 0x6762 <FormatCurrency>
          FormatCurrency(strCurrentVolume);
    725c:	c5 01       	movw	r24, r10
    725e:	0e 94 b1 33 	call	0x6762	; 0x6762 <FormatCurrency>


          InserBorder(btTopLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btTopRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          
    7262:	81 e0       	ldi	r24, 0x01	; 1
    7264:	6f ec       	ldi	r22, 0xCF	; 207
    7266:	75 e0       	ldi	r23, 0x05	; 5
    7268:	41 e0       	ldi	r20, 0x01	; 1
    726a:	22 e0       	ldi	r18, 0x02	; 2
    726c:	32 e0       	ldi	r19, 0x02	; 2
    726e:	0e 94 81 1a 	call	0x3502	; 0x3502 <InserBorder>
    7272:	8b e0       	ldi	r24, 0x0B	; 11
    7274:	6f ec       	ldi	r22, 0xCF	; 207
    7276:	75 e0       	ldi	r23, 0x05	; 5
    7278:	4a e2       	ldi	r20, 0x2A	; 42
    727a:	22 e0       	ldi	r18, 0x02	; 2
    727c:	32 e0       	ldi	r19, 0x02	; 2
    727e:	0e 94 81 1a 	call	0x3502	; 0x3502 <InserBorder>
    7282:	83 e0       	ldi	r24, 0x03	; 3
    7284:	6f ec       	ldi	r22, 0xCF	; 207
    7286:	75 e0       	ldi	r23, 0x05	; 5
    7288:	41 e0       	ldi	r20, 0x01	; 1
    728a:	22 e0       	ldi	r18, 0x02	; 2
    728c:	32 e0       	ldi	r19, 0x02	; 2
    728e:	0e 94 81 1a 	call	0x3502	; 0x3502 <InserBorder>
    7292:	8c e0       	ldi	r24, 0x0C	; 12
    7294:	6f ec       	ldi	r22, 0xCF	; 207
    7296:	75 e0       	ldi	r23, 0x05	; 5
    7298:	41 e0       	ldi	r20, 0x01	; 1
    729a:	22 e0       	ldi	r18, 0x02	; 2
    729c:	32 e0       	ldi	r19, 0x02	; 2
    729e:	0e 94 81 1a 	call	0x3502	; 0x3502 <InserBorder>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    72a2:	e1 99       	sbic	0x1c, 1	; 28
    72a4:	fe cf       	rjmp	.-4      	; 0x72a2 <systemGenerateReport+0x85e>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    72a6:	9f ba       	out	0x1f, r9	; 31
    72a8:	8e ba       	out	0x1e, r8	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    72aa:	e0 9a       	sbi	0x1c, 0	; 28
    72ac:	8d b3       	in	r24, 0x1d	; 29
    72ae:	91 e4       	ldi	r25, 0x41	; 65
    72b0:	c9 2e       	mov	r12, r25
    72b2:	99 e0       	ldi	r25, 0x09	; 9
    72b4:	d9 2e       	mov	r13, r25
          if (eeprom_read_byte(&DefDispenserBrand)==ST_WAYNE_DART){
    72b6:	82 30       	cpi	r24, 0x02	; 2
    72b8:	09 f0       	breq	.+2      	; 0x72bc <systemGenerateReport+0x878>
    72ba:	84 c0       	rjmp	.+264    	; 0x73c4 <systemGenerateReport+0x980>
		      GetProductPrice(sPrice,PumpNum,PumpNozzle);
    72bc:	0f e0       	ldi	r16, 0x0F	; 15
    72be:	e0 2e       	mov	r14, r16
    72c0:	f1 2c       	mov	r15, r1
    72c2:	ec 0e       	add	r14, r28
    72c4:	fd 1e       	adc	r15, r29
    72c6:	c7 01       	movw	r24, r14
    72c8:	60 91 10 02 	lds	r22, 0x0210
    72cc:	40 91 0f 02 	lds	r20, 0x020F
    72d0:	0e 94 d1 24 	call	0x49a2	; 0x49a2 <GetProductPrice>
			  sprintf_P(strProductPrice,PSTR("Harga: Rp.%s"),sPrice);
    72d4:	00 d0       	rcall	.+0      	; 0x72d6 <systemGenerateReport+0x892>
    72d6:	00 d0       	rcall	.+0      	; 0x72d8 <systemGenerateReport+0x894>
    72d8:	00 d0       	rcall	.+0      	; 0x72da <systemGenerateReport+0x896>
    72da:	ed b7       	in	r30, 0x3d	; 61
    72dc:	fe b7       	in	r31, 0x3e	; 62
    72de:	31 96       	adiw	r30, 0x01	; 1
    72e0:	8e 01       	movw	r16, r28
    72e2:	0f 56       	subi	r16, 0x6F	; 111
    72e4:	1f 4f       	sbci	r17, 0xFF	; 255
    72e6:	ad b7       	in	r26, 0x3d	; 61
    72e8:	be b7       	in	r27, 0x3e	; 62
    72ea:	12 96       	adiw	r26, 0x02	; 2
    72ec:	1c 93       	st	X, r17
    72ee:	0e 93       	st	-X, r16
    72f0:	11 97       	sbiw	r26, 0x01	; 1
    72f2:	83 ed       	ldi	r24, 0xD3	; 211
    72f4:	94 e0       	ldi	r25, 0x04	; 4
    72f6:	93 83       	std	Z+3, r25	; 0x03
    72f8:	82 83       	std	Z+2, r24	; 0x02
    72fa:	f5 82       	std	Z+5, r15	; 0x05
    72fc:	e4 82       	std	Z+4, r14	; 0x04
    72fe:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>

		      GetTabSpace(((17+10-strlen(strProduct))-strlen(strProductPrice)),strTabSpace2);
    7302:	d6 01       	movw	r26, r12
    7304:	0d 90       	ld	r0, X+
    7306:	00 20       	and	r0, r0
    7308:	e9 f7       	brne	.-6      	; 0x7304 <systemGenerateReport+0x8c0>
    730a:	11 97       	sbiw	r26, 0x01	; 1
    730c:	ac 19       	sub	r26, r12
    730e:	bd 09       	sbc	r27, r13
    7310:	f8 01       	movw	r30, r16
    7312:	01 90       	ld	r0, Z+
    7314:	00 20       	and	r0, r0
    7316:	e9 f7       	brne	.-6      	; 0x7312 <systemGenerateReport+0x8ce>
    7318:	31 97       	sbiw	r30, 0x01	; 1
    731a:	0e 1b       	sub	r16, r30
    731c:	0a 1b       	sub	r16, r26
    731e:	05 5e       	subi	r16, 0xE5	; 229
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    7320:	ed b7       	in	r30, 0x3d	; 61
    7322:	fe b7       	in	r31, 0x3e	; 62
    7324:	36 96       	adiw	r30, 0x06	; 6
    7326:	0f b6       	in	r0, 0x3f	; 63
    7328:	f8 94       	cli
    732a:	fe bf       	out	0x3e, r31	; 62
    732c:	0f be       	out	0x3f, r0	; 63
    732e:	ed bf       	out	0x3d, r30	; 61
    7330:	fe 01       	movw	r30, r28
    7332:	e3 58       	subi	r30, 0x83	; 131
    7334:	ff 4f       	sbci	r31, 0xFF	; 255
    7336:	10 16       	cp	r1, r16
    7338:	74 f4       	brge	.+28     	; 0x7356 <systemGenerateReport+0x912>
    733a:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    733c:	90 e2       	ldi	r25, 0x20	; 32
    733e:	02 c0       	rjmp	.+4      	; 0x7344 <systemGenerateReport+0x900>
    7340:	91 93       	st	Z+, r25

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    7342:	8f 5f       	subi	r24, 0xFF	; 255
    7344:	80 17       	cp	r24, r16
    7346:	e0 f3       	brcs	.-8      	; 0x7340 <systemGenerateReport+0x8fc>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    7348:	fe 01       	movw	r30, r28
    734a:	e3 58       	subi	r30, 0x83	; 131
    734c:	ff 4f       	sbci	r31, 0xFF	; 255
    734e:	e0 0f       	add	r30, r16
    7350:	f1 1d       	adc	r31, r1
    7352:	10 82       	st	Z, r1
    7354:	03 c0       	rjmp	.+6      	; 0x735c <systemGenerateReport+0x918>
     }else{
	 strTab[0]=' ';
    7356:	80 e2       	ldi	r24, 0x20	; 32
    7358:	80 83       	st	Z, r24
	 strTab[1]=0;
    735a:	11 82       	std	Z+1, r1	; 0x01
          if (eeprom_read_byte(&DefDispenserBrand)==ST_WAYNE_DART){
		      GetProductPrice(sPrice,PumpNum,PumpNozzle);
			  sprintf_P(strProductPrice,PSTR("Harga: Rp.%s"),sPrice);

		      GetTabSpace(((17+10-strlen(strProduct))-strlen(strProductPrice)),strTabSpace2);
		      sprintf_P(strReport,PSTR("P%d.%d - %s %s %s"),PumpNum,PumpNozzle,strProduct,strTabSpace2,strProductPrice);
    735c:	8d b7       	in	r24, 0x3d	; 61
    735e:	9e b7       	in	r25, 0x3e	; 62
    7360:	0e 97       	sbiw	r24, 0x0e	; 14
    7362:	0f b6       	in	r0, 0x3f	; 63
    7364:	f8 94       	cli
    7366:	9e bf       	out	0x3e, r25	; 62
    7368:	0f be       	out	0x3f, r0	; 63
    736a:	8d bf       	out	0x3d, r24	; 61
    736c:	ed b7       	in	r30, 0x3d	; 61
    736e:	fe b7       	in	r31, 0x3e	; 62
    7370:	31 96       	adiw	r30, 0x01	; 1
    7372:	ce 01       	movw	r24, r28
    7374:	8b 55       	subi	r24, 0x5B	; 91
    7376:	9f 4f       	sbci	r25, 0xFF	; 255
    7378:	ad b7       	in	r26, 0x3d	; 61
    737a:	be b7       	in	r27, 0x3e	; 62
    737c:	12 96       	adiw	r26, 0x02	; 2
    737e:	9c 93       	st	X, r25
    7380:	8e 93       	st	-X, r24
    7382:	11 97       	sbiw	r26, 0x01	; 1
    7384:	81 ec       	ldi	r24, 0xC1	; 193
    7386:	94 e0       	ldi	r25, 0x04	; 4
    7388:	93 83       	std	Z+3, r25	; 0x03
    738a:	82 83       	std	Z+2, r24	; 0x02
    738c:	80 91 10 02 	lds	r24, 0x0210
    7390:	84 83       	std	Z+4, r24	; 0x04
    7392:	15 82       	std	Z+5, r1	; 0x05
    7394:	80 91 0f 02 	lds	r24, 0x020F
    7398:	86 83       	std	Z+6, r24	; 0x06
    739a:	17 82       	std	Z+7, r1	; 0x07
    739c:	81 e4       	ldi	r24, 0x41	; 65
    739e:	99 e0       	ldi	r25, 0x09	; 9
    73a0:	91 87       	std	Z+9, r25	; 0x09
    73a2:	80 87       	std	Z+8, r24	; 0x08
    73a4:	ce 01       	movw	r24, r28
    73a6:	83 58       	subi	r24, 0x83	; 131
    73a8:	9f 4f       	sbci	r25, 0xFF	; 255
    73aa:	93 87       	std	Z+11, r25	; 0x0b
    73ac:	82 87       	std	Z+10, r24	; 0x0a
    73ae:	ce 01       	movw	r24, r28
    73b0:	8f 56       	subi	r24, 0x6F	; 111
    73b2:	9f 4f       	sbci	r25, 0xFF	; 255
    73b4:	95 87       	std	Z+13, r25	; 0x0d
    73b6:	84 87       	std	Z+12, r24	; 0x0c
    73b8:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    73bc:	ed b7       	in	r30, 0x3d	; 61
    73be:	fe b7       	in	r31, 0x3e	; 62
    73c0:	3e 96       	adiw	r30, 0x0e	; 14
    73c2:	27 c0       	rjmp	.+78     	; 0x7412 <systemGenerateReport+0x9ce>
		  }
		  else sprintf_P(strReport,PSTR("P%d.%d - %s "),PumpNum,PumpNozzle,strProduct);
    73c4:	8d b7       	in	r24, 0x3d	; 61
    73c6:	9e b7       	in	r25, 0x3e	; 62
    73c8:	0a 97       	sbiw	r24, 0x0a	; 10
    73ca:	0f b6       	in	r0, 0x3f	; 63
    73cc:	f8 94       	cli
    73ce:	9e bf       	out	0x3e, r25	; 62
    73d0:	0f be       	out	0x3f, r0	; 63
    73d2:	8d bf       	out	0x3d, r24	; 61
    73d4:	ed b7       	in	r30, 0x3d	; 61
    73d6:	fe b7       	in	r31, 0x3e	; 62
    73d8:	31 96       	adiw	r30, 0x01	; 1
    73da:	ce 01       	movw	r24, r28
    73dc:	8b 55       	subi	r24, 0x5B	; 91
    73de:	9f 4f       	sbci	r25, 0xFF	; 255
    73e0:	ad b7       	in	r26, 0x3d	; 61
    73e2:	be b7       	in	r27, 0x3e	; 62
    73e4:	12 96       	adiw	r26, 0x02	; 2
    73e6:	9c 93       	st	X, r25
    73e8:	8e 93       	st	-X, r24
    73ea:	11 97       	sbiw	r26, 0x01	; 1
    73ec:	84 eb       	ldi	r24, 0xB4	; 180
    73ee:	94 e0       	ldi	r25, 0x04	; 4
    73f0:	93 83       	std	Z+3, r25	; 0x03
    73f2:	82 83       	std	Z+2, r24	; 0x02
    73f4:	80 91 10 02 	lds	r24, 0x0210
    73f8:	84 83       	std	Z+4, r24	; 0x04
    73fa:	15 82       	std	Z+5, r1	; 0x05
    73fc:	80 91 0f 02 	lds	r24, 0x020F
    7400:	86 83       	std	Z+6, r24	; 0x06
    7402:	17 82       	std	Z+7, r1	; 0x07
    7404:	d1 86       	std	Z+9, r13	; 0x09
    7406:	c0 86       	std	Z+8, r12	; 0x08
    7408:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    740c:	ed b7       	in	r30, 0x3d	; 61
    740e:	fe b7       	in	r31, 0x3e	; 62
    7410:	3a 96       	adiw	r30, 0x0a	; 10
    7412:	0f b6       	in	r0, 0x3f	; 63
    7414:	f8 94       	cli
    7416:	fe bf       	out	0x3e, r31	; 62
    7418:	0f be       	out	0x3f, r0	; 63
    741a:	ed bf       	out	0x3d, r30	; 61
		  CreateReport(strReport,PrintBuffer,&RepPos);
    741c:	ce 01       	movw	r24, r28
    741e:	8b 55       	subi	r24, 0x5B	; 91
    7420:	9f 4f       	sbci	r25, 0xFF	; 255
    7422:	6f ec       	ldi	r22, 0xCF	; 207
    7424:	75 e0       	ldi	r23, 0x05	; 5
    7426:	42 e0       	ldi	r20, 0x02	; 2
    7428:	52 e0       	ldi	r21, 0x02	; 2
    742a:	0e 94 89 22 	call	0x4512	; 0x4512 <CreateReport>
          InserBorder(btMiddleLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btMiddleRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          
    742e:	84 e0       	ldi	r24, 0x04	; 4
    7430:	6f ec       	ldi	r22, 0xCF	; 207
    7432:	75 e0       	ldi	r23, 0x05	; 5
    7434:	41 e0       	ldi	r20, 0x01	; 1
    7436:	22 e0       	ldi	r18, 0x02	; 2
    7438:	32 e0       	ldi	r19, 0x02	; 2
    743a:	0e 94 81 1a 	call	0x3502	; 0x3502 <InserBorder>
    743e:	8b e0       	ldi	r24, 0x0B	; 11
    7440:	6f ec       	ldi	r22, 0xCF	; 207
    7442:	75 e0       	ldi	r23, 0x05	; 5
    7444:	4a e2       	ldi	r20, 0x2A	; 42
    7446:	22 e0       	ldi	r18, 0x02	; 2
    7448:	32 e0       	ldi	r19, 0x02	; 2
    744a:	0e 94 81 1a 	call	0x3502	; 0x3502 <InserBorder>
    744e:	86 e0       	ldi	r24, 0x06	; 6
    7450:	6f ec       	ldi	r22, 0xCF	; 207
    7452:	75 e0       	ldi	r23, 0x05	; 5
    7454:	41 e0       	ldi	r20, 0x01	; 1
    7456:	22 e0       	ldi	r18, 0x02	; 2
    7458:	32 e0       	ldi	r19, 0x02	; 2
    745a:	0e 94 81 1a 	call	0x3502	; 0x3502 <InserBorder>
    745e:	8c e0       	ldi	r24, 0x0C	; 12
    7460:	6f ec       	ldi	r22, 0xCF	; 207
    7462:	75 e0       	ldi	r23, 0x05	; 5
    7464:	41 e0       	ldi	r20, 0x01	; 1
    7466:	22 e0       	ldi	r18, 0x02	; 2
    7468:	32 e0       	ldi	r19, 0x02	; 2
    746a:	0e 94 81 1a 	call	0x3502	; 0x3502 <InserBorder>

		  GetTabSpace((17-strlen(strCurrentVolume)),strTabSpace);
    746e:	de 01       	movw	r26, r28
    7470:	d7 96       	adiw	r26, 0x37	; 55
    7472:	fd 01       	movw	r30, r26
    7474:	01 90       	ld	r0, Z+
    7476:	00 20       	and	r0, r0
    7478:	e9 f7       	brne	.-6      	; 0x7474 <systemGenerateReport+0xa30>
    747a:	9a 2f       	mov	r25, r26
    747c:	9e 1b       	sub	r25, r30
    747e:	9e 5e       	subi	r25, 0xEE	; 238
    7480:	de 01       	movw	r26, r28
    7482:	a7 59       	subi	r26, 0x97	; 151
    7484:	bf 4f       	sbci	r27, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    7486:	19 16       	cp	r1, r25
    7488:	7c f4       	brge	.+30     	; 0x74a8 <systemGenerateReport+0xa64>
    748a:	fd 01       	movw	r30, r26
    748c:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    748e:	20 e2       	ldi	r18, 0x20	; 32
    7490:	02 c0       	rjmp	.+4      	; 0x7496 <systemGenerateReport+0xa52>
    7492:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    7494:	8f 5f       	subi	r24, 0xFF	; 255
    7496:	89 17       	cp	r24, r25
    7498:	e0 f3       	brcs	.-8      	; 0x7492 <systemGenerateReport+0xa4e>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    749a:	fe 01       	movw	r30, r28
    749c:	e7 59       	subi	r30, 0x97	; 151
    749e:	ff 4f       	sbci	r31, 0xFF	; 255
    74a0:	e9 0f       	add	r30, r25
    74a2:	f1 1d       	adc	r31, r1
    74a4:	10 82       	st	Z, r1
    74a6:	04 c0       	rjmp	.+8      	; 0x74b0 <systemGenerateReport+0xa6c>
     }else{
	 strTab[0]=' ';
    74a8:	80 e2       	ldi	r24, 0x20	; 32
    74aa:	8c 93       	st	X, r24
	 strTab[1]=0;
    74ac:	11 96       	adiw	r26, 0x01	; 1
    74ae:	1c 92       	st	X, r1
		  else sprintf_P(strReport,PSTR("P%d.%d - %s "),PumpNum,PumpNozzle,strProduct);
		  CreateReport(strReport,PrintBuffer,&RepPos);
          InserBorder(btMiddleLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btMiddleRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          

		  GetTabSpace((17-strlen(strCurrentVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strCurrentMoney)),strTabSpace2);
    74b0:	de 01       	movw	r26, r28
    74b2:	aa 5b       	subi	r26, 0xBA	; 186
    74b4:	bf 4f       	sbci	r27, 0xFF	; 255
    74b6:	fd 01       	movw	r30, r26
    74b8:	01 90       	ld	r0, Z+
    74ba:	00 20       	and	r0, r0
    74bc:	e9 f7       	brne	.-6      	; 0x74b8 <systemGenerateReport+0xa74>
    74be:	ae 1b       	sub	r26, r30
    74c0:	a0 5f       	subi	r26, 0xF0	; 240
    74c2:	fe 01       	movw	r30, r28
    74c4:	e3 58       	subi	r30, 0x83	; 131
    74c6:	ff 4f       	sbci	r31, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    74c8:	1a 16       	cp	r1, r26
    74ca:	74 f4       	brge	.+28     	; 0x74e8 <systemGenerateReport+0xaa4>
    74cc:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    74ce:	90 e2       	ldi	r25, 0x20	; 32
    74d0:	02 c0       	rjmp	.+4      	; 0x74d6 <systemGenerateReport+0xa92>
    74d2:	91 93       	st	Z+, r25

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    74d4:	8f 5f       	subi	r24, 0xFF	; 255
    74d6:	8a 17       	cp	r24, r26
    74d8:	e0 f3       	brcs	.-8      	; 0x74d2 <systemGenerateReport+0xa8e>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    74da:	fe 01       	movw	r30, r28
    74dc:	e3 58       	subi	r30, 0x83	; 131
    74de:	ff 4f       	sbci	r31, 0xFF	; 255
    74e0:	ea 0f       	add	r30, r26
    74e2:	f1 1d       	adc	r31, r1
    74e4:	10 82       	st	Z, r1
    74e6:	03 c0       	rjmp	.+6      	; 0x74ee <systemGenerateReport+0xaaa>
     }else{
	 strTab[0]=' ';
    74e8:	80 e2       	ldi	r24, 0x20	; 32
    74ea:	80 83       	st	Z, r24
	 strTab[1]=0;
    74ec:	11 82       	std	Z+1, r1	; 0x01
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    74ee:	e1 99       	sbic	0x1c, 1	; 28
    74f0:	fe cf       	rjmp	.-4      	; 0x74ee <systemGenerateReport+0xaaa>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    74f2:	11 ec       	ldi	r17, 0xC1	; 193
    74f4:	e1 2e       	mov	r14, r17
    74f6:	13 e0       	ldi	r17, 0x03	; 3
    74f8:	f1 2e       	mov	r15, r17
    74fa:	ff ba       	out	0x1f, r15	; 31
    74fc:	ee ba       	out	0x1e, r14	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    74fe:	e0 9a       	sbi	0x1c, 0	; 28
    7500:	8d b3       	in	r24, 0x1d	; 29
    7502:	9e 01       	movw	r18, r28
    7504:	2b 55       	subi	r18, 0x5B	; 91
    7506:	3f 4f       	sbci	r19, 0xFF	; 255
    7508:	ae 01       	movw	r20, r28
    750a:	49 5c       	subi	r20, 0xC9	; 201
    750c:	5f 4f       	sbci	r21, 0xFF	; 255
    750e:	de 01       	movw	r26, r28
    7510:	a7 59       	subi	r26, 0x97	; 151
    7512:	bf 4f       	sbci	r27, 0xFF	; 255
          InserBorder(btMiddleLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btMiddleRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          

		  GetTabSpace((17-strlen(strCurrentVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strCurrentMoney)),strTabSpace2);
		  //PrintMoney
		  if (eeprom_read_byte(&DefPrintMoney)==True) sprintf_P(strReport,PSTR("Akhir:%s%s%s%s"),strTabSpace,strCurrentVolume,strTabSpace2,strCurrentMoney);//CreateReport(strReport,PrintBuffer,&RepPos);
    7514:	81 30       	cpi	r24, 0x01	; 1
    7516:	49 f5       	brne	.+82     	; 0x756a <systemGenerateReport+0xb26>
    7518:	8d b7       	in	r24, 0x3d	; 61
    751a:	9e b7       	in	r25, 0x3e	; 62
    751c:	0c 97       	sbiw	r24, 0x0c	; 12
    751e:	0f b6       	in	r0, 0x3f	; 63
    7520:	f8 94       	cli
    7522:	9e bf       	out	0x3e, r25	; 62
    7524:	0f be       	out	0x3f, r0	; 63
    7526:	8d bf       	out	0x3d, r24	; 61
    7528:	6d b7       	in	r22, 0x3d	; 61
    752a:	7e b7       	in	r23, 0x3e	; 62
    752c:	6f 5f       	subi	r22, 0xFF	; 255
    752e:	7f 4f       	sbci	r23, 0xFF	; 255
    7530:	ed b7       	in	r30, 0x3d	; 61
    7532:	fe b7       	in	r31, 0x3e	; 62
    7534:	32 83       	std	Z+2, r19	; 0x02
    7536:	21 83       	std	Z+1, r18	; 0x01
    7538:	85 ea       	ldi	r24, 0xA5	; 165
    753a:	94 e0       	ldi	r25, 0x04	; 4
    753c:	fb 01       	movw	r30, r22
    753e:	93 83       	std	Z+3, r25	; 0x03
    7540:	82 83       	std	Z+2, r24	; 0x02
    7542:	b5 83       	std	Z+5, r27	; 0x05
    7544:	a4 83       	std	Z+4, r26	; 0x04
    7546:	57 83       	std	Z+7, r21	; 0x07
    7548:	46 83       	std	Z+6, r20	; 0x06
    754a:	ce 01       	movw	r24, r28
    754c:	83 58       	subi	r24, 0x83	; 131
    754e:	9f 4f       	sbci	r25, 0xFF	; 255
    7550:	91 87       	std	Z+9, r25	; 0x09
    7552:	80 87       	std	Z+8, r24	; 0x08
    7554:	ce 01       	movw	r24, r28
    7556:	8a 5b       	subi	r24, 0xBA	; 186
    7558:	9f 4f       	sbci	r25, 0xFF	; 255
    755a:	93 87       	std	Z+11, r25	; 0x0b
    755c:	82 87       	std	Z+10, r24	; 0x0a
    755e:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    7562:	8d b7       	in	r24, 0x3d	; 61
    7564:	9e b7       	in	r25, 0x3e	; 62
    7566:	0c 96       	adiw	r24, 0x0c	; 12
    7568:	1c c0       	rjmp	.+56     	; 0x75a2 <systemGenerateReport+0xb5e>
		  else sprintf_P(strReport,PSTR("Akhir:%s%s"),strTabSpace,strCurrentVolume);
    756a:	ed b7       	in	r30, 0x3d	; 61
    756c:	fe b7       	in	r31, 0x3e	; 62
    756e:	38 97       	sbiw	r30, 0x08	; 8
    7570:	0f b6       	in	r0, 0x3f	; 63
    7572:	f8 94       	cli
    7574:	fe bf       	out	0x3e, r31	; 62
    7576:	0f be       	out	0x3f, r0	; 63
    7578:	ed bf       	out	0x3d, r30	; 61
    757a:	6d b7       	in	r22, 0x3d	; 61
    757c:	7e b7       	in	r23, 0x3e	; 62
    757e:	6f 5f       	subi	r22, 0xFF	; 255
    7580:	7f 4f       	sbci	r23, 0xFF	; 255
    7582:	32 83       	std	Z+2, r19	; 0x02
    7584:	21 83       	std	Z+1, r18	; 0x01
    7586:	8a e9       	ldi	r24, 0x9A	; 154
    7588:	94 e0       	ldi	r25, 0x04	; 4
    758a:	fb 01       	movw	r30, r22
    758c:	93 83       	std	Z+3, r25	; 0x03
    758e:	82 83       	std	Z+2, r24	; 0x02
    7590:	b5 83       	std	Z+5, r27	; 0x05
    7592:	a4 83       	std	Z+4, r26	; 0x04
    7594:	57 83       	std	Z+7, r21	; 0x07
    7596:	46 83       	std	Z+6, r20	; 0x06
    7598:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    759c:	8d b7       	in	r24, 0x3d	; 61
    759e:	9e b7       	in	r25, 0x3e	; 62
    75a0:	08 96       	adiw	r24, 0x08	; 8
    75a2:	0f b6       	in	r0, 0x3f	; 63
    75a4:	f8 94       	cli
    75a6:	9e bf       	out	0x3e, r25	; 62
    75a8:	0f be       	out	0x3f, r0	; 63
    75aa:	8d bf       	out	0x3d, r24	; 61
		  CreateReport(strReport,PrintBuffer,&RepPos);
    75ac:	ce 01       	movw	r24, r28
    75ae:	8b 55       	subi	r24, 0x5B	; 91
    75b0:	9f 4f       	sbci	r25, 0xFF	; 255
    75b2:	6f ec       	ldi	r22, 0xCF	; 207
    75b4:	75 e0       	ldi	r23, 0x05	; 5
    75b6:	42 e0       	ldi	r20, 0x02	; 2
    75b8:	52 e0       	ldi	r21, 0x02	; 2
    75ba:	0e 94 89 22 	call	0x4512	; 0x4512 <CreateReport>

		  GetTabSpace((17-strlen(strLastVolume)),strTabSpace);
    75be:	de 01       	movw	r26, r28
    75c0:	59 96       	adiw	r26, 0x19	; 25
    75c2:	fd 01       	movw	r30, r26
    75c4:	01 90       	ld	r0, Z+
    75c6:	00 20       	and	r0, r0
    75c8:	e9 f7       	brne	.-6      	; 0x75c4 <systemGenerateReport+0xb80>
    75ca:	9a 2f       	mov	r25, r26
    75cc:	9e 1b       	sub	r25, r30
    75ce:	9e 5e       	subi	r25, 0xEE	; 238
    75d0:	de 01       	movw	r26, r28
    75d2:	a7 59       	subi	r26, 0x97	; 151
    75d4:	bf 4f       	sbci	r27, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    75d6:	19 16       	cp	r1, r25
    75d8:	7c f4       	brge	.+30     	; 0x75f8 <systemGenerateReport+0xbb4>
    75da:	fd 01       	movw	r30, r26
    75dc:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    75de:	20 e2       	ldi	r18, 0x20	; 32
    75e0:	02 c0       	rjmp	.+4      	; 0x75e6 <systemGenerateReport+0xba2>
    75e2:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    75e4:	8f 5f       	subi	r24, 0xFF	; 255
    75e6:	89 17       	cp	r24, r25
    75e8:	e0 f3       	brcs	.-8      	; 0x75e2 <systemGenerateReport+0xb9e>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    75ea:	fe 01       	movw	r30, r28
    75ec:	e7 59       	subi	r30, 0x97	; 151
    75ee:	ff 4f       	sbci	r31, 0xFF	; 255
    75f0:	e9 0f       	add	r30, r25
    75f2:	f1 1d       	adc	r31, r1
    75f4:	10 82       	st	Z, r1
    75f6:	04 c0       	rjmp	.+8      	; 0x7600 <systemGenerateReport+0xbbc>
     }else{
	 strTab[0]=' ';
    75f8:	80 e2       	ldi	r24, 0x20	; 32
    75fa:	8c 93       	st	X, r24
	 strTab[1]=0;
    75fc:	11 96       	adiw	r26, 0x01	; 1
    75fe:	1c 92       	st	X, r1
		  if (eeprom_read_byte(&DefPrintMoney)==True) sprintf_P(strReport,PSTR("Akhir:%s%s%s%s"),strTabSpace,strCurrentVolume,strTabSpace2,strCurrentMoney);//CreateReport(strReport,PrintBuffer,&RepPos);
		  else sprintf_P(strReport,PSTR("Akhir:%s%s"),strTabSpace,strCurrentVolume);
		  CreateReport(strReport,PrintBuffer,&RepPos);

		  GetTabSpace((17-strlen(strLastVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strLastMoney)),strTabSpace2);
    7600:	de 01       	movw	r26, r28
    7602:	98 96       	adiw	r26, 0x28	; 40
    7604:	fd 01       	movw	r30, r26
    7606:	01 90       	ld	r0, Z+
    7608:	00 20       	and	r0, r0
    760a:	e9 f7       	brne	.-6      	; 0x7606 <systemGenerateReport+0xbc2>
    760c:	ae 1b       	sub	r26, r30
    760e:	a0 5f       	subi	r26, 0xF0	; 240
    7610:	fe 01       	movw	r30, r28
    7612:	e3 58       	subi	r30, 0x83	; 131
    7614:	ff 4f       	sbci	r31, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    7616:	1a 16       	cp	r1, r26
    7618:	74 f4       	brge	.+28     	; 0x7636 <systemGenerateReport+0xbf2>
    761a:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    761c:	90 e2       	ldi	r25, 0x20	; 32
    761e:	02 c0       	rjmp	.+4      	; 0x7624 <systemGenerateReport+0xbe0>
    7620:	91 93       	st	Z+, r25

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    7622:	8f 5f       	subi	r24, 0xFF	; 255
    7624:	8a 17       	cp	r24, r26
    7626:	e0 f3       	brcs	.-8      	; 0x7620 <systemGenerateReport+0xbdc>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    7628:	fe 01       	movw	r30, r28
    762a:	e3 58       	subi	r30, 0x83	; 131
    762c:	ff 4f       	sbci	r31, 0xFF	; 255
    762e:	ea 0f       	add	r30, r26
    7630:	f1 1d       	adc	r31, r1
    7632:	10 82       	st	Z, r1
    7634:	03 c0       	rjmp	.+6      	; 0x763c <systemGenerateReport+0xbf8>
     }else{
	 strTab[0]=' ';
    7636:	80 e2       	ldi	r24, 0x20	; 32
    7638:	80 83       	st	Z, r24
	 strTab[1]=0;
    763a:	11 82       	std	Z+1, r1	; 0x01
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    763c:	e1 99       	sbic	0x1c, 1	; 28
    763e:	fe cf       	rjmp	.-4      	; 0x763c <systemGenerateReport+0xbf8>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    7640:	ff ba       	out	0x1f, r15	; 31
    7642:	ee ba       	out	0x1e, r14	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    7644:	e0 9a       	sbi	0x1c, 0	; 28
    7646:	8d b3       	in	r24, 0x1d	; 29
    7648:	9e 01       	movw	r18, r28
    764a:	2b 55       	subi	r18, 0x5B	; 91
    764c:	3f 4f       	sbci	r19, 0xFF	; 255
    764e:	ae 01       	movw	r20, r28
    7650:	47 5e       	subi	r20, 0xE7	; 231
    7652:	5f 4f       	sbci	r21, 0xFF	; 255
    7654:	de 01       	movw	r26, r28
    7656:	a7 59       	subi	r26, 0x97	; 151
    7658:	bf 4f       	sbci	r27, 0xFF	; 255
		  CreateReport(strReport,PrintBuffer,&RepPos);

		  GetTabSpace((17-strlen(strLastVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strLastMoney)),strTabSpace2);
		  //PrintMoney
		  if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("Awal :%s%s%s%s"),strTabSpace,strLastVolume,strTabSpace2,strLastMoney);//CreateReport(strReport,PrintBuffer,&RepPos);
    765a:	81 30       	cpi	r24, 0x01	; 1
    765c:	31 f5       	brne	.+76     	; 0x76aa <systemGenerateReport+0xc66>
    765e:	ed b7       	in	r30, 0x3d	; 61
    7660:	fe b7       	in	r31, 0x3e	; 62
    7662:	3c 97       	sbiw	r30, 0x0c	; 12
    7664:	0f b6       	in	r0, 0x3f	; 63
    7666:	f8 94       	cli
    7668:	fe bf       	out	0x3e, r31	; 62
    766a:	0f be       	out	0x3f, r0	; 63
    766c:	ed bf       	out	0x3d, r30	; 61
    766e:	6d b7       	in	r22, 0x3d	; 61
    7670:	7e b7       	in	r23, 0x3e	; 62
    7672:	6f 5f       	subi	r22, 0xFF	; 255
    7674:	7f 4f       	sbci	r23, 0xFF	; 255
    7676:	32 83       	std	Z+2, r19	; 0x02
    7678:	21 83       	std	Z+1, r18	; 0x01
    767a:	8b e8       	ldi	r24, 0x8B	; 139
    767c:	94 e0       	ldi	r25, 0x04	; 4
    767e:	fb 01       	movw	r30, r22
    7680:	93 83       	std	Z+3, r25	; 0x03
    7682:	82 83       	std	Z+2, r24	; 0x02
    7684:	b5 83       	std	Z+5, r27	; 0x05
    7686:	a4 83       	std	Z+4, r26	; 0x04
    7688:	57 83       	std	Z+7, r21	; 0x07
    768a:	46 83       	std	Z+6, r20	; 0x06
    768c:	ce 01       	movw	r24, r28
    768e:	83 58       	subi	r24, 0x83	; 131
    7690:	9f 4f       	sbci	r25, 0xFF	; 255
    7692:	91 87       	std	Z+9, r25	; 0x09
    7694:	80 87       	std	Z+8, r24	; 0x08
    7696:	ce 01       	movw	r24, r28
    7698:	88 96       	adiw	r24, 0x28	; 40
    769a:	93 87       	std	Z+11, r25	; 0x0b
    769c:	82 87       	std	Z+10, r24	; 0x0a
    769e:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    76a2:	8d b7       	in	r24, 0x3d	; 61
    76a4:	9e b7       	in	r25, 0x3e	; 62
    76a6:	0c 96       	adiw	r24, 0x0c	; 12
    76a8:	1c c0       	rjmp	.+56     	; 0x76e2 <systemGenerateReport+0xc9e>
		  else sprintf_P(strReport,PSTR("Awal :%s%s"),strTabSpace,strLastVolume);
    76aa:	ed b7       	in	r30, 0x3d	; 61
    76ac:	fe b7       	in	r31, 0x3e	; 62
    76ae:	38 97       	sbiw	r30, 0x08	; 8
    76b0:	0f b6       	in	r0, 0x3f	; 63
    76b2:	f8 94       	cli
    76b4:	fe bf       	out	0x3e, r31	; 62
    76b6:	0f be       	out	0x3f, r0	; 63
    76b8:	ed bf       	out	0x3d, r30	; 61
    76ba:	6d b7       	in	r22, 0x3d	; 61
    76bc:	7e b7       	in	r23, 0x3e	; 62
    76be:	6f 5f       	subi	r22, 0xFF	; 255
    76c0:	7f 4f       	sbci	r23, 0xFF	; 255
    76c2:	32 83       	std	Z+2, r19	; 0x02
    76c4:	21 83       	std	Z+1, r18	; 0x01
    76c6:	80 e8       	ldi	r24, 0x80	; 128
    76c8:	94 e0       	ldi	r25, 0x04	; 4
    76ca:	fb 01       	movw	r30, r22
    76cc:	93 83       	std	Z+3, r25	; 0x03
    76ce:	82 83       	std	Z+2, r24	; 0x02
    76d0:	b5 83       	std	Z+5, r27	; 0x05
    76d2:	a4 83       	std	Z+4, r26	; 0x04
    76d4:	57 83       	std	Z+7, r21	; 0x07
    76d6:	46 83       	std	Z+6, r20	; 0x06
    76d8:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    76dc:	8d b7       	in	r24, 0x3d	; 61
    76de:	9e b7       	in	r25, 0x3e	; 62
    76e0:	08 96       	adiw	r24, 0x08	; 8
    76e2:	0f b6       	in	r0, 0x3f	; 63
    76e4:	f8 94       	cli
    76e6:	9e bf       	out	0x3e, r25	; 62
    76e8:	0f be       	out	0x3f, r0	; 63
    76ea:	8d bf       	out	0x3d, r24	; 61
		  CreateReport(strReport,PrintBuffer,&RepPos);
    76ec:	ce 01       	movw	r24, r28
    76ee:	8b 55       	subi	r24, 0x5B	; 91
    76f0:	9f 4f       	sbci	r25, 0xFF	; 255
    76f2:	6f ec       	ldi	r22, 0xCF	; 207
    76f4:	75 e0       	ldi	r23, 0x05	; 5
    76f6:	42 e0       	ldi	r20, 0x02	; 2
    76f8:	52 e0       	ldi	r21, 0x02	; 2
    76fa:	0e 94 89 22 	call	0x4512	; 0x4512 <CreateReport>
    76fe:	8e 01       	movw	r16, r28
    7700:	07 59       	subi	r16, 0x97	; 151
    7702:	1f 4f       	sbci	r17, 0xFF	; 255
    7704:	f8 01       	movw	r30, r16
void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    7706:	20 e2       	ldi	r18, 0x20	; 32

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    7708:	d8 01       	movw	r26, r16
    770a:	c8 01       	movw	r24, r16
    770c:	0c 96       	adiw	r24, 0x0c	; 12
		     strTab[i]=' ';
    770e:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    7710:	e8 17       	cp	r30, r24
    7712:	f9 07       	cpc	r31, r25
    7714:	e1 f7       	brne	.-8      	; 0x770e <systemGenerateReport+0xcca>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    7716:	1c 96       	adiw	r26, 0x0c	; 12
    7718:	1c 92       	st	X, r1
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    771a:	e1 99       	sbic	0x1c, 1	; 28
    771c:	fe cf       	rjmp	.-4      	; 0x771a <systemGenerateReport+0xcd6>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    771e:	ff ba       	out	0x1f, r15	; 31
    7720:	ee ba       	out	0x1e, r14	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    7722:	e0 9a       	sbi	0x1c, 0	; 28
    7724:	8d b3       	in	r24, 0x1d	; 29
    7726:	9e 01       	movw	r18, r28
    7728:	2b 55       	subi	r18, 0x5B	; 91
    772a:	3f 4f       	sbci	r19, 0xFF	; 255
    772c:	de 01       	movw	r26, r28
    772e:	a7 59       	subi	r26, 0x97	; 151
    7730:	bf 4f       	sbci	r27, 0xFF	; 255
		  else sprintf_P(strReport,PSTR("Awal :%s%s"),strTabSpace,strLastVolume);
		  CreateReport(strReport,PrintBuffer,&RepPos);

		  GetTabSpace(12,strTabSpace);
          //PrintMoney
          if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("%s-----------   -------------"),strTabSpace);//CreateReport(strReport,PrintBuffer,&RepPos);
    7732:	81 30       	cpi	r24, 0x01	; 1
    7734:	71 f4       	brne	.+28     	; 0x7752 <systemGenerateReport+0xd0e>
    7736:	00 d0       	rcall	.+0      	; 0x7738 <systemGenerateReport+0xcf4>
    7738:	00 d0       	rcall	.+0      	; 0x773a <systemGenerateReport+0xcf6>
    773a:	00 d0       	rcall	.+0      	; 0x773c <systemGenerateReport+0xcf8>
    773c:	4d b7       	in	r20, 0x3d	; 61
    773e:	5e b7       	in	r21, 0x3e	; 62
    7740:	4f 5f       	subi	r20, 0xFF	; 255
    7742:	5f 4f       	sbci	r21, 0xFF	; 255
    7744:	ed b7       	in	r30, 0x3d	; 61
    7746:	fe b7       	in	r31, 0x3e	; 62
    7748:	32 83       	std	Z+2, r19	; 0x02
    774a:	21 83       	std	Z+1, r18	; 0x01
    774c:	82 e6       	ldi	r24, 0x62	; 98
    774e:	94 e0       	ldi	r25, 0x04	; 4
    7750:	0d c0       	rjmp	.+26     	; 0x776c <systemGenerateReport+0xd28>
		  else sprintf_P(strReport,PSTR("%s-----------                "),strTabSpace);CreateReport(strReport,PrintBuffer,&RepPos);
    7752:	00 d0       	rcall	.+0      	; 0x7754 <systemGenerateReport+0xd10>
    7754:	00 d0       	rcall	.+0      	; 0x7756 <systemGenerateReport+0xd12>
    7756:	00 d0       	rcall	.+0      	; 0x7758 <systemGenerateReport+0xd14>
    7758:	4d b7       	in	r20, 0x3d	; 61
    775a:	5e b7       	in	r21, 0x3e	; 62
    775c:	4f 5f       	subi	r20, 0xFF	; 255
    775e:	5f 4f       	sbci	r21, 0xFF	; 255
    7760:	ed b7       	in	r30, 0x3d	; 61
    7762:	fe b7       	in	r31, 0x3e	; 62
    7764:	32 83       	std	Z+2, r19	; 0x02
    7766:	21 83       	std	Z+1, r18	; 0x01
    7768:	84 e4       	ldi	r24, 0x44	; 68
    776a:	94 e0       	ldi	r25, 0x04	; 4
    776c:	fa 01       	movw	r30, r20
    776e:	93 83       	std	Z+3, r25	; 0x03
    7770:	82 83       	std	Z+2, r24	; 0x02
    7772:	b5 83       	std	Z+5, r27	; 0x05
    7774:	a4 83       	std	Z+4, r26	; 0x04
    7776:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    777a:	8d b7       	in	r24, 0x3d	; 61
    777c:	9e b7       	in	r25, 0x3e	; 62
    777e:	06 96       	adiw	r24, 0x06	; 6
    7780:	0f b6       	in	r0, 0x3f	; 63
    7782:	f8 94       	cli
    7784:	9e bf       	out	0x3e, r25	; 62
    7786:	0f be       	out	0x3f, r0	; 63
    7788:	8d bf       	out	0x3d, r24	; 61
    778a:	ce 01       	movw	r24, r28
    778c:	8b 55       	subi	r24, 0x5B	; 91
    778e:	9f 4f       	sbci	r25, 0xFF	; 255
    7790:	6f ec       	ldi	r22, 0xCF	; 207
    7792:	75 e0       	ldi	r23, 0x05	; 5
    7794:	42 e0       	ldi	r20, 0x02	; 2
    7796:	52 e0       	ldi	r21, 0x02	; 2
    7798:	0e 94 89 22 	call	0x4512	; 0x4512 <CreateReport>

		  GetTabSpace((23-strlen(strDeltaVolume)),strTabSpace);
    779c:	ed ed       	ldi	r30, 0xDD	; 221
    779e:	fa e0       	ldi	r31, 0x0A	; 10
    77a0:	01 90       	ld	r0, Z+
    77a2:	00 20       	and	r0, r0
    77a4:	e9 f7       	brne	.-6      	; 0x77a0 <systemGenerateReport+0xd5c>
    77a6:	31 97       	sbiw	r30, 0x01	; 1
    77a8:	ed 5d       	subi	r30, 0xDD	; 221
    77aa:	fa 40       	sbci	r31, 0x0A	; 10
    77ac:	97 e1       	ldi	r25, 0x17	; 23
    77ae:	9e 1b       	sub	r25, r30
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    77b0:	19 16       	cp	r1, r25
    77b2:	84 f4       	brge	.+32     	; 0x77d4 <systemGenerateReport+0xd90>
    77b4:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    77b6:	20 e2       	ldi	r18, 0x20	; 32
    77b8:	04 c0       	rjmp	.+8      	; 0x77c2 <systemGenerateReport+0xd7e>
    77ba:	d8 01       	movw	r26, r16
    77bc:	2d 93       	st	X+, r18
    77be:	8d 01       	movw	r16, r26

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    77c0:	8f 5f       	subi	r24, 0xFF	; 255
    77c2:	89 17       	cp	r24, r25
    77c4:	d0 f3       	brcs	.-12     	; 0x77ba <systemGenerateReport+0xd76>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    77c6:	fe 01       	movw	r30, r28
    77c8:	e7 59       	subi	r30, 0x97	; 151
    77ca:	ff 4f       	sbci	r31, 0xFF	; 255
    77cc:	e9 0f       	add	r30, r25
    77ce:	f1 1d       	adc	r31, r1
    77d0:	10 82       	st	Z, r1
    77d2:	06 c0       	rjmp	.+12     	; 0x77e0 <systemGenerateReport+0xd9c>
     }else{
	 strTab[0]=' ';
    77d4:	fe 01       	movw	r30, r28
    77d6:	e7 59       	subi	r30, 0x97	; 151
    77d8:	ff 4f       	sbci	r31, 0xFF	; 255
    77da:	80 e2       	ldi	r24, 0x20	; 32
    77dc:	80 83       	st	Z, r24
	 strTab[1]=0;
    77de:	11 82       	std	Z+1, r1	; 0x01
          //PrintMoney
          if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("%s-----------   -------------"),strTabSpace);//CreateReport(strReport,PrintBuffer,&RepPos);
		  else sprintf_P(strReport,PSTR("%s-----------                "),strTabSpace);CreateReport(strReport,PrintBuffer,&RepPos);

		  GetTabSpace((23-strlen(strDeltaVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strDeltaMoney)),strTabSpace2);
    77e0:	e8 e0       	ldi	r30, 0x08	; 8
    77e2:	fe e0       	ldi	r31, 0x0E	; 14
    77e4:	01 90       	ld	r0, Z+
    77e6:	00 20       	and	r0, r0
    77e8:	e9 f7       	brne	.-6      	; 0x77e4 <systemGenerateReport+0xda0>
    77ea:	31 97       	sbiw	r30, 0x01	; 1
    77ec:	e8 50       	subi	r30, 0x08	; 8
    77ee:	fe 40       	sbci	r31, 0x0E	; 14
    77f0:	9f e0       	ldi	r25, 0x0F	; 15
    77f2:	9e 1b       	sub	r25, r30
    77f4:	fe 01       	movw	r30, r28
    77f6:	e3 58       	subi	r30, 0x83	; 131
    77f8:	ff 4f       	sbci	r31, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    77fa:	19 16       	cp	r1, r25
    77fc:	74 f4       	brge	.+28     	; 0x781a <systemGenerateReport+0xdd6>
    77fe:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    7800:	20 e2       	ldi	r18, 0x20	; 32
    7802:	02 c0       	rjmp	.+4      	; 0x7808 <systemGenerateReport+0xdc4>
    7804:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    7806:	8f 5f       	subi	r24, 0xFF	; 255
    7808:	89 17       	cp	r24, r25
    780a:	e0 f3       	brcs	.-8      	; 0x7804 <systemGenerateReport+0xdc0>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    780c:	fe 01       	movw	r30, r28
    780e:	e3 58       	subi	r30, 0x83	; 131
    7810:	ff 4f       	sbci	r31, 0xFF	; 255
    7812:	e9 0f       	add	r30, r25
    7814:	f1 1d       	adc	r31, r1
    7816:	10 82       	st	Z, r1
    7818:	03 c0       	rjmp	.+6      	; 0x7820 <systemGenerateReport+0xddc>
     }else{
	 strTab[0]=' ';
    781a:	80 e2       	ldi	r24, 0x20	; 32
    781c:	80 83       	st	Z, r24
	 strTab[1]=0;
    781e:	11 82       	std	Z+1, r1	; 0x01
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    7820:	e1 99       	sbic	0x1c, 1	; 28
    7822:	fe cf       	rjmp	.-4      	; 0x7820 <systemGenerateReport+0xddc>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    7824:	ff ba       	out	0x1f, r15	; 31
    7826:	ee ba       	out	0x1e, r14	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    7828:	e0 9a       	sbi	0x1c, 0	; 28
    782a:	8d b3       	in	r24, 0x1d	; 29
    782c:	9e 01       	movw	r18, r28
    782e:	2b 55       	subi	r18, 0x5B	; 91
    7830:	3f 4f       	sbci	r19, 0xFF	; 255
    7832:	4d ed       	ldi	r20, 0xDD	; 221
    7834:	5a e0       	ldi	r21, 0x0A	; 10
    7836:	de 01       	movw	r26, r28
    7838:	a7 59       	subi	r26, 0x97	; 151
    783a:	bf 4f       	sbci	r27, 0xFF	; 255
		  else sprintf_P(strReport,PSTR("%s-----------                "),strTabSpace);CreateReport(strReport,PrintBuffer,&RepPos);

		  GetTabSpace((23-strlen(strDeltaVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strDeltaMoney)),strTabSpace2);
          //PrintMoney
		  if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("%s%s%s%s"),strTabSpace,strDeltaVolume,strTabSpace2,strDeltaMoney);//CreateReport(strReport,PrintBuffer,&RepPos);
    783c:	81 30       	cpi	r24, 0x01	; 1
    783e:	31 f5       	brne	.+76     	; 0x788c <systemGenerateReport+0xe48>
    7840:	ed b7       	in	r30, 0x3d	; 61
    7842:	fe b7       	in	r31, 0x3e	; 62
    7844:	3c 97       	sbiw	r30, 0x0c	; 12
    7846:	0f b6       	in	r0, 0x3f	; 63
    7848:	f8 94       	cli
    784a:	fe bf       	out	0x3e, r31	; 62
    784c:	0f be       	out	0x3f, r0	; 63
    784e:	ed bf       	out	0x3d, r30	; 61
    7850:	6d b7       	in	r22, 0x3d	; 61
    7852:	7e b7       	in	r23, 0x3e	; 62
    7854:	6f 5f       	subi	r22, 0xFF	; 255
    7856:	7f 4f       	sbci	r23, 0xFF	; 255
    7858:	32 83       	std	Z+2, r19	; 0x02
    785a:	21 83       	std	Z+1, r18	; 0x01
    785c:	8b e3       	ldi	r24, 0x3B	; 59
    785e:	94 e0       	ldi	r25, 0x04	; 4
    7860:	fb 01       	movw	r30, r22
    7862:	93 83       	std	Z+3, r25	; 0x03
    7864:	82 83       	std	Z+2, r24	; 0x02
    7866:	b5 83       	std	Z+5, r27	; 0x05
    7868:	a4 83       	std	Z+4, r26	; 0x04
    786a:	57 83       	std	Z+7, r21	; 0x07
    786c:	46 83       	std	Z+6, r20	; 0x06
    786e:	ce 01       	movw	r24, r28
    7870:	83 58       	subi	r24, 0x83	; 131
    7872:	9f 4f       	sbci	r25, 0xFF	; 255
    7874:	91 87       	std	Z+9, r25	; 0x09
    7876:	80 87       	std	Z+8, r24	; 0x08
    7878:	88 e0       	ldi	r24, 0x08	; 8
    787a:	9e e0       	ldi	r25, 0x0E	; 14
    787c:	93 87       	std	Z+11, r25	; 0x0b
    787e:	82 87       	std	Z+10, r24	; 0x0a
    7880:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    7884:	8d b7       	in	r24, 0x3d	; 61
    7886:	9e b7       	in	r25, 0x3e	; 62
    7888:	0c 96       	adiw	r24, 0x0c	; 12
    788a:	1c c0       	rjmp	.+56     	; 0x78c4 <systemGenerateReport+0xe80>
          else sprintf_P(strReport,PSTR("%s%s"),strTabSpace,strDeltaVolume);CreateReport(strReport,PrintBuffer,&RepPos);
    788c:	ed b7       	in	r30, 0x3d	; 61
    788e:	fe b7       	in	r31, 0x3e	; 62
    7890:	38 97       	sbiw	r30, 0x08	; 8
    7892:	0f b6       	in	r0, 0x3f	; 63
    7894:	f8 94       	cli
    7896:	fe bf       	out	0x3e, r31	; 62
    7898:	0f be       	out	0x3f, r0	; 63
    789a:	ed bf       	out	0x3d, r30	; 61
    789c:	6d b7       	in	r22, 0x3d	; 61
    789e:	7e b7       	in	r23, 0x3e	; 62
    78a0:	6f 5f       	subi	r22, 0xFF	; 255
    78a2:	7f 4f       	sbci	r23, 0xFF	; 255
    78a4:	32 83       	std	Z+2, r19	; 0x02
    78a6:	21 83       	std	Z+1, r18	; 0x01
    78a8:	86 e3       	ldi	r24, 0x36	; 54
    78aa:	94 e0       	ldi	r25, 0x04	; 4
    78ac:	fb 01       	movw	r30, r22
    78ae:	93 83       	std	Z+3, r25	; 0x03
    78b0:	82 83       	std	Z+2, r24	; 0x02
    78b2:	b5 83       	std	Z+5, r27	; 0x05
    78b4:	a4 83       	std	Z+4, r26	; 0x04
    78b6:	57 83       	std	Z+7, r21	; 0x07
    78b8:	46 83       	std	Z+6, r20	; 0x06
    78ba:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    78be:	8d b7       	in	r24, 0x3d	; 61
    78c0:	9e b7       	in	r25, 0x3e	; 62
    78c2:	08 96       	adiw	r24, 0x08	; 8
    78c4:	0f b6       	in	r0, 0x3f	; 63
    78c6:	f8 94       	cli
    78c8:	9e bf       	out	0x3e, r25	; 62
    78ca:	0f be       	out	0x3f, r0	; 63
    78cc:	8d bf       	out	0x3d, r24	; 61
    78ce:	ce 01       	movw	r24, r28
    78d0:	8b 55       	subi	r24, 0x5B	; 91
    78d2:	9f 4f       	sbci	r25, 0xFF	; 255
    78d4:	6f ec       	ldi	r22, 0xCF	; 207
    78d6:	75 e0       	ldi	r23, 0x05	; 5
    78d8:	42 e0       	ldi	r20, 0x02	; 2
    78da:	52 e0       	ldi	r21, 0x02	; 2
    78dc:	0e 94 89 22 	call	0x4512	; 0x4512 <CreateReport>

          InserBorder(btBottomLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btBottomRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);
    78e0:	87 e0       	ldi	r24, 0x07	; 7
    78e2:	6f ec       	ldi	r22, 0xCF	; 207
    78e4:	75 e0       	ldi	r23, 0x05	; 5
    78e6:	41 e0       	ldi	r20, 0x01	; 1
    78e8:	22 e0       	ldi	r18, 0x02	; 2
    78ea:	32 e0       	ldi	r19, 0x02	; 2
    78ec:	0e 94 81 1a 	call	0x3502	; 0x3502 <InserBorder>
    78f0:	8b e0       	ldi	r24, 0x0B	; 11
    78f2:	6f ec       	ldi	r22, 0xCF	; 207
    78f4:	75 e0       	ldi	r23, 0x05	; 5
    78f6:	4a e2       	ldi	r20, 0x2A	; 42
    78f8:	22 e0       	ldi	r18, 0x02	; 2
    78fa:	32 e0       	ldi	r19, 0x02	; 2
    78fc:	0e 94 81 1a 	call	0x3502	; 0x3502 <InserBorder>
    7900:	89 e0       	ldi	r24, 0x09	; 9
    7902:	6f ec       	ldi	r22, 0xCF	; 207
    7904:	75 e0       	ldi	r23, 0x05	; 5
    7906:	41 e0       	ldi	r20, 0x01	; 1
    7908:	22 e0       	ldi	r18, 0x02	; 2
    790a:	32 e0       	ldi	r19, 0x02	; 2
    790c:	0e 94 81 1a 	call	0x3502	; 0x3502 <InserBorder>
    7910:	8c e0       	ldi	r24, 0x0C	; 12
    7912:	6f ec       	ldi	r22, 0xCF	; 207
    7914:	75 e0       	ldi	r23, 0x05	; 5
    7916:	41 e0       	ldi	r20, 0x01	; 1
    7918:	22 e0       	ldi	r18, 0x02	; 2
    791a:	32 e0       	ldi	r19, 0x02	; 2
    791c:	0e 94 81 1a 	call	0x3502	; 0x3502 <InserBorder>


          cmdPrint=0b00000000;
    7920:	10 92 cb 01 	sts	0x01CB, r1
		  LengthMessage81=RepPos+1;
    7924:	80 91 02 02 	lds	r24, 0x0202
    7928:	90 91 03 02 	lds	r25, 0x0203
    792c:	01 96       	adiw	r24, 0x01	; 1
    792e:	90 93 a1 01 	sts	0x01A1, r25
    7932:	80 93 a0 01 	sts	0x01A0, r24

		  IsFreePrinting=True;
    7936:	81 e0       	ldi	r24, 0x01	; 1
    7938:	80 93 bf 01 	sts	0x01BF, r24
	      IsBusyFreePrinting=True;
    793c:	80 93 ca 01 	sts	0x01CA, r24

	      stGenerateReport=grWaitPrinted2;
    7940:	89 e0       	ldi	r24, 0x09	; 9
    7942:	91 c3       	rjmp	.+1826   	; 0x8066 <systemGenerateReport+0x1622>
	      break;
     case grWaitPrinted2:
	 
          if (IsBusyFreePrinting==False)stGenerateReport=grGenerateReportData;
    7944:	80 91 ca 01 	lds	r24, 0x01CA
    7948:	88 23       	and	r24, r24
    794a:	09 f0       	breq	.+2      	; 0x794e <systemGenerateReport+0xf0a>
    794c:	94 c3       	rjmp	.+1832   	; 0x8076 <systemGenerateReport+0x1632>
    794e:	86 e0       	ldi	r24, 0x06	; 6
    7950:	8a c3       	rjmp	.+1812   	; 0x8066 <systemGenerateReport+0x1622>
	      break;
     case grCreateReportFooter:
          RepPos=0;
    7952:	10 92 03 02 	sts	0x0203, r1
    7956:	10 92 02 02 	sts	0x0202, r1
    795a:	ef ec       	ldi	r30, 0xCF	; 207
    795c:	f5 e0       	ldi	r31, 0x05	; 5
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    795e:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7960:	97 e0       	ldi	r25, 0x07	; 7
    7962:	e0 36       	cpi	r30, 0x60	; 96
    7964:	f9 07       	cpc	r31, r25
    7966:	d9 f7       	brne	.-10     	; 0x795e <systemGenerateReport+0xf1a>
    7968:	fe 01       	movw	r30, r28
    796a:	eb 55       	subi	r30, 0x5B	; 91
    796c:	ff 4f       	sbci	r31, 0xFF	; 255
	     strMemory[i]=data;
    796e:	ce 01       	movw	r24, r28
    7970:	8b 50       	subi	r24, 0x0B	; 11
    7972:	9f 4f       	sbci	r25, 0xFF	; 255
    7974:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7976:	e8 17       	cp	r30, r24
    7978:	f9 07       	cpc	r31, r25
    797a:	e1 f7       	brne	.-8      	; 0x7974 <systemGenerateReport+0xf30>
     case grCreateReportFooter:
          RepPos=0;
		  FillChar(PrintBuffer,sizeof(PrintBuffer),0);
		  FillChar(strReport,sizeof(strReport),0);

		  RemZeroLead(strTotalMoney);
    797c:	8d ea       	ldi	r24, 0xAD	; 173
    797e:	9a e0       	ldi	r25, 0x0A	; 10
    7980:	0e 94 b9 25 	call	0x4b72	; 0x4b72 <RemZeroLead>
		  RemZeroLead(strTotalVolume);
    7984:	0c ef       	ldi	r16, 0xFC	; 252
    7986:	19 e0       	ldi	r17, 0x09	; 9
    7988:	c8 01       	movw	r24, r16
    798a:	0e 94 b9 25 	call	0x4b72	; 0x4b72 <RemZeroLead>

		  FormatTotalizerMoney(strTotalMoney);
    798e:	8d ea       	ldi	r24, 0xAD	; 173
    7990:	9a e0       	ldi	r25, 0x0A	; 10
    7992:	0e 94 ee 34 	call	0x69dc	; 0x69dc <FormatTotalizerMoney>
		  FormatCurrency(strTotalMoney);
    7996:	8d ea       	ldi	r24, 0xAD	; 173
    7998:	9a e0       	ldi	r25, 0x0A	; 10
    799a:	0e 94 b1 33 	call	0x6762	; 0x6762 <FormatCurrency>
		  FormatTotalizerVolume(strTotalVolume);
    799e:	c8 01       	movw	r24, r16
    79a0:	0e 94 e1 34 	call	0x69c2	; 0x69c2 <FormatTotalizerVolume>
		  FormatCurrency(strTotalVolume);
    79a4:	c8 01       	movw	r24, r16
    79a6:	0e 94 b1 33 	call	0x6762	; 0x6762 <FormatCurrency>

          //Test
		  //RemZeroLead(strTotalMoney);
		  //RemZeroLead(strTotalVolume);

		  InserBorder(btTopLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btTopRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          
    79aa:	81 e0       	ldi	r24, 0x01	; 1
    79ac:	6f ec       	ldi	r22, 0xCF	; 207
    79ae:	75 e0       	ldi	r23, 0x05	; 5
    79b0:	41 e0       	ldi	r20, 0x01	; 1
    79b2:	22 e0       	ldi	r18, 0x02	; 2
    79b4:	32 e0       	ldi	r19, 0x02	; 2
    79b6:	0e 94 81 1a 	call	0x3502	; 0x3502 <InserBorder>
    79ba:	8b e0       	ldi	r24, 0x0B	; 11
    79bc:	6f ec       	ldi	r22, 0xCF	; 207
    79be:	75 e0       	ldi	r23, 0x05	; 5
    79c0:	4a e2       	ldi	r20, 0x2A	; 42
    79c2:	22 e0       	ldi	r18, 0x02	; 2
    79c4:	32 e0       	ldi	r19, 0x02	; 2
    79c6:	0e 94 81 1a 	call	0x3502	; 0x3502 <InserBorder>
    79ca:	83 e0       	ldi	r24, 0x03	; 3
    79cc:	6f ec       	ldi	r22, 0xCF	; 207
    79ce:	75 e0       	ldi	r23, 0x05	; 5
    79d0:	41 e0       	ldi	r20, 0x01	; 1
    79d2:	22 e0       	ldi	r18, 0x02	; 2
    79d4:	32 e0       	ldi	r19, 0x02	; 2
    79d6:	0e 94 81 1a 	call	0x3502	; 0x3502 <InserBorder>
    79da:	8c e0       	ldi	r24, 0x0C	; 12
    79dc:	6f ec       	ldi	r22, 0xCF	; 207
    79de:	75 e0       	ldi	r23, 0x05	; 5
    79e0:	41 e0       	ldi	r20, 0x01	; 1
    79e2:	22 e0       	ldi	r18, 0x02	; 2
    79e4:	32 e0       	ldi	r19, 0x02	; 2
    79e6:	0e 94 81 1a 	call	0x3502	; 0x3502 <InserBorder>
		  GetTabSpace((17-strlen(strTotalVolume)),strTabSpace);
    79ea:	d8 01       	movw	r26, r16
    79ec:	0d 90       	ld	r0, X+
    79ee:	00 20       	and	r0, r0
    79f0:	e9 f7       	brne	.-6      	; 0x79ec <systemGenerateReport+0xfa8>
    79f2:	8d 01       	movw	r16, r26
    79f4:	01 50       	subi	r16, 0x01	; 1
    79f6:	10 40       	sbci	r17, 0x00	; 0
    79f8:	0c 5f       	subi	r16, 0xFC	; 252
    79fa:	19 40       	sbci	r17, 0x09	; 9
    79fc:	91 e1       	ldi	r25, 0x11	; 17
    79fe:	90 1b       	sub	r25, r16
    7a00:	de 01       	movw	r26, r28
    7a02:	a7 59       	subi	r26, 0x97	; 151
    7a04:	bf 4f       	sbci	r27, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    7a06:	19 16       	cp	r1, r25
    7a08:	7c f4       	brge	.+30     	; 0x7a28 <systemGenerateReport+0xfe4>
    7a0a:	fd 01       	movw	r30, r26
    7a0c:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    7a0e:	20 e2       	ldi	r18, 0x20	; 32
    7a10:	02 c0       	rjmp	.+4      	; 0x7a16 <systemGenerateReport+0xfd2>
    7a12:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    7a14:	8f 5f       	subi	r24, 0xFF	; 255
    7a16:	89 17       	cp	r24, r25
    7a18:	e0 f3       	brcs	.-8      	; 0x7a12 <systemGenerateReport+0xfce>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    7a1a:	fe 01       	movw	r30, r28
    7a1c:	e7 59       	subi	r30, 0x97	; 151
    7a1e:	ff 4f       	sbci	r31, 0xFF	; 255
    7a20:	e9 0f       	add	r30, r25
    7a22:	f1 1d       	adc	r31, r1
    7a24:	10 82       	st	Z, r1
    7a26:	04 c0       	rjmp	.+8      	; 0x7a30 <systemGenerateReport+0xfec>
     }else{
	 strTab[0]=' ';
    7a28:	80 e2       	ldi	r24, 0x20	; 32
    7a2a:	8c 93       	st	X, r24
	 strTab[1]=0;
    7a2c:	11 96       	adiw	r26, 0x01	; 1
    7a2e:	1c 92       	st	X, r1
		  //RemZeroLead(strTotalMoney);
		  //RemZeroLead(strTotalVolume);

		  InserBorder(btTopLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btTopRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          
		  GetTabSpace((17-strlen(strTotalVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strTotalMoney)),strTabSpace2);
    7a30:	ed ea       	ldi	r30, 0xAD	; 173
    7a32:	fa e0       	ldi	r31, 0x0A	; 10
    7a34:	01 90       	ld	r0, Z+
    7a36:	00 20       	and	r0, r0
    7a38:	e9 f7       	brne	.-6      	; 0x7a34 <systemGenerateReport+0xff0>
    7a3a:	31 97       	sbiw	r30, 0x01	; 1
    7a3c:	ed 5a       	subi	r30, 0xAD	; 173
    7a3e:	fa 40       	sbci	r31, 0x0A	; 10
    7a40:	9f e0       	ldi	r25, 0x0F	; 15
    7a42:	9e 1b       	sub	r25, r30
    7a44:	fe 01       	movw	r30, r28
    7a46:	e3 58       	subi	r30, 0x83	; 131
    7a48:	ff 4f       	sbci	r31, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    7a4a:	19 16       	cp	r1, r25
    7a4c:	74 f4       	brge	.+28     	; 0x7a6a <systemGenerateReport+0x1026>
    7a4e:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    7a50:	20 e2       	ldi	r18, 0x20	; 32
    7a52:	02 c0       	rjmp	.+4      	; 0x7a58 <systemGenerateReport+0x1014>
    7a54:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    7a56:	8f 5f       	subi	r24, 0xFF	; 255
    7a58:	89 17       	cp	r24, r25
    7a5a:	e0 f3       	brcs	.-8      	; 0x7a54 <systemGenerateReport+0x1010>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    7a5c:	fe 01       	movw	r30, r28
    7a5e:	e3 58       	subi	r30, 0x83	; 131
    7a60:	ff 4f       	sbci	r31, 0xFF	; 255
    7a62:	e9 0f       	add	r30, r25
    7a64:	f1 1d       	adc	r31, r1
    7a66:	10 82       	st	Z, r1
    7a68:	03 c0       	rjmp	.+6      	; 0x7a70 <systemGenerateReport+0x102c>
     }else{
	 strTab[0]=' ';
    7a6a:	80 e2       	ldi	r24, 0x20	; 32
    7a6c:	80 83       	st	Z, r24
	 strTab[1]=0;
    7a6e:	11 82       	std	Z+1, r1	; 0x01
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    7a70:	e1 99       	sbic	0x1c, 1	; 28
    7a72:	fe cf       	rjmp	.-4      	; 0x7a70 <systemGenerateReport+0x102c>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    7a74:	e1 ec       	ldi	r30, 0xC1	; 193
    7a76:	f3 e0       	ldi	r31, 0x03	; 3
    7a78:	ff bb       	out	0x1f, r31	; 31
    7a7a:	ee bb       	out	0x1e, r30	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    7a7c:	e0 9a       	sbi	0x1c, 0	; 28
    7a7e:	8d b3       	in	r24, 0x1d	; 29
    7a80:	9e 01       	movw	r18, r28
    7a82:	2b 55       	subi	r18, 0x5B	; 91
    7a84:	3f 4f       	sbci	r19, 0xFF	; 255
    7a86:	4c ef       	ldi	r20, 0xFC	; 252
    7a88:	59 e0       	ldi	r21, 0x09	; 9
    7a8a:	de 01       	movw	r26, r28
    7a8c:	a7 59       	subi	r26, 0x97	; 151
    7a8e:	bf 4f       	sbci	r27, 0xFF	; 255

		  InserBorder(btTopLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btTopRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          
		  GetTabSpace((17-strlen(strTotalVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strTotalMoney)),strTabSpace2);
          //PrintMoney
		  if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("TOTAL %s%s%s%s"),strTabSpace,strTotalVolume,strTabSpace2,strTotalMoney);//CreateReport(strReport,PrintBuffer,&RepPos);
    7a90:	81 30       	cpi	r24, 0x01	; 1
    7a92:	41 f5       	brne	.+80     	; 0x7ae4 <systemGenerateReport+0x10a0>
    7a94:	8d b7       	in	r24, 0x3d	; 61
    7a96:	9e b7       	in	r25, 0x3e	; 62
    7a98:	0c 97       	sbiw	r24, 0x0c	; 12
    7a9a:	0f b6       	in	r0, 0x3f	; 63
    7a9c:	f8 94       	cli
    7a9e:	9e bf       	out	0x3e, r25	; 62
    7aa0:	0f be       	out	0x3f, r0	; 63
    7aa2:	8d bf       	out	0x3d, r24	; 61
    7aa4:	6d b7       	in	r22, 0x3d	; 61
    7aa6:	7e b7       	in	r23, 0x3e	; 62
    7aa8:	6f 5f       	subi	r22, 0xFF	; 255
    7aaa:	7f 4f       	sbci	r23, 0xFF	; 255
    7aac:	ed b7       	in	r30, 0x3d	; 61
    7aae:	fe b7       	in	r31, 0x3e	; 62
    7ab0:	32 83       	std	Z+2, r19	; 0x02
    7ab2:	21 83       	std	Z+1, r18	; 0x01
    7ab4:	87 e2       	ldi	r24, 0x27	; 39
    7ab6:	94 e0       	ldi	r25, 0x04	; 4
    7ab8:	fb 01       	movw	r30, r22
    7aba:	93 83       	std	Z+3, r25	; 0x03
    7abc:	82 83       	std	Z+2, r24	; 0x02
    7abe:	b5 83       	std	Z+5, r27	; 0x05
    7ac0:	a4 83       	std	Z+4, r26	; 0x04
    7ac2:	57 83       	std	Z+7, r21	; 0x07
    7ac4:	46 83       	std	Z+6, r20	; 0x06
    7ac6:	ce 01       	movw	r24, r28
    7ac8:	83 58       	subi	r24, 0x83	; 131
    7aca:	9f 4f       	sbci	r25, 0xFF	; 255
    7acc:	91 87       	std	Z+9, r25	; 0x09
    7ace:	80 87       	std	Z+8, r24	; 0x08
    7ad0:	8d ea       	ldi	r24, 0xAD	; 173
    7ad2:	9a e0       	ldi	r25, 0x0A	; 10
    7ad4:	93 87       	std	Z+11, r25	; 0x0b
    7ad6:	82 87       	std	Z+10, r24	; 0x0a
    7ad8:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    7adc:	8d b7       	in	r24, 0x3d	; 61
    7ade:	9e b7       	in	r25, 0x3e	; 62
    7ae0:	0c 96       	adiw	r24, 0x0c	; 12
    7ae2:	1c c0       	rjmp	.+56     	; 0x7b1c <systemGenerateReport+0x10d8>
		  else sprintf_P(strReport,PSTR("TOTAL %s%s"),strTabSpace,strTotalVolume);CreateReport(strReport,PrintBuffer,&RepPos);
    7ae4:	ed b7       	in	r30, 0x3d	; 61
    7ae6:	fe b7       	in	r31, 0x3e	; 62
    7ae8:	38 97       	sbiw	r30, 0x08	; 8
    7aea:	0f b6       	in	r0, 0x3f	; 63
    7aec:	f8 94       	cli
    7aee:	fe bf       	out	0x3e, r31	; 62
    7af0:	0f be       	out	0x3f, r0	; 63
    7af2:	ed bf       	out	0x3d, r30	; 61
    7af4:	6d b7       	in	r22, 0x3d	; 61
    7af6:	7e b7       	in	r23, 0x3e	; 62
    7af8:	6f 5f       	subi	r22, 0xFF	; 255
    7afa:	7f 4f       	sbci	r23, 0xFF	; 255
    7afc:	32 83       	std	Z+2, r19	; 0x02
    7afe:	21 83       	std	Z+1, r18	; 0x01
    7b00:	8c e1       	ldi	r24, 0x1C	; 28
    7b02:	94 e0       	ldi	r25, 0x04	; 4
    7b04:	fb 01       	movw	r30, r22
    7b06:	93 83       	std	Z+3, r25	; 0x03
    7b08:	82 83       	std	Z+2, r24	; 0x02
    7b0a:	b5 83       	std	Z+5, r27	; 0x05
    7b0c:	a4 83       	std	Z+4, r26	; 0x04
    7b0e:	57 83       	std	Z+7, r21	; 0x07
    7b10:	46 83       	std	Z+6, r20	; 0x06
    7b12:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    7b16:	8d b7       	in	r24, 0x3d	; 61
    7b18:	9e b7       	in	r25, 0x3e	; 62
    7b1a:	08 96       	adiw	r24, 0x08	; 8
    7b1c:	0f b6       	in	r0, 0x3f	; 63
    7b1e:	f8 94       	cli
    7b20:	9e bf       	out	0x3e, r25	; 62
    7b22:	0f be       	out	0x3f, r0	; 63
    7b24:	8d bf       	out	0x3d, r24	; 61
    7b26:	ce 01       	movw	r24, r28
    7b28:	8b 55       	subi	r24, 0x5B	; 91
    7b2a:	9f 4f       	sbci	r25, 0xFF	; 255
    7b2c:	6f ec       	ldi	r22, 0xCF	; 207
    7b2e:	75 e0       	ldi	r23, 0x05	; 5
    7b30:	42 e0       	ldi	r20, 0x02	; 2
    7b32:	52 e0       	ldi	r21, 0x02	; 2
    7b34:	0e 94 89 22 	call	0x4512	; 0x4512 <CreateReport>

		  InserBorder(btMiddleLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btMiddleRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);     	      
    7b38:	84 e0       	ldi	r24, 0x04	; 4
    7b3a:	6f ec       	ldi	r22, 0xCF	; 207
    7b3c:	75 e0       	ldi	r23, 0x05	; 5
    7b3e:	41 e0       	ldi	r20, 0x01	; 1
    7b40:	22 e0       	ldi	r18, 0x02	; 2
    7b42:	32 e0       	ldi	r19, 0x02	; 2
    7b44:	0e 94 81 1a 	call	0x3502	; 0x3502 <InserBorder>
    7b48:	8b e0       	ldi	r24, 0x0B	; 11
    7b4a:	6f ec       	ldi	r22, 0xCF	; 207
    7b4c:	75 e0       	ldi	r23, 0x05	; 5
    7b4e:	4a e2       	ldi	r20, 0x2A	; 42
    7b50:	22 e0       	ldi	r18, 0x02	; 2
    7b52:	32 e0       	ldi	r19, 0x02	; 2
    7b54:	0e 94 81 1a 	call	0x3502	; 0x3502 <InserBorder>
    7b58:	86 e0       	ldi	r24, 0x06	; 6
    7b5a:	6f ec       	ldi	r22, 0xCF	; 207
    7b5c:	75 e0       	ldi	r23, 0x05	; 5
    7b5e:	41 e0       	ldi	r20, 0x01	; 1
    7b60:	22 e0       	ldi	r18, 0x02	; 2
    7b62:	32 e0       	ldi	r19, 0x02	; 2
    7b64:	0e 94 81 1a 	call	0x3502	; 0x3502 <InserBorder>
    7b68:	8c e0       	ldi	r24, 0x0C	; 12
    7b6a:	6f ec       	ldi	r22, 0xCF	; 207
    7b6c:	75 e0       	ldi	r23, 0x05	; 5
    7b6e:	41 e0       	ldi	r20, 0x01	; 1
    7b70:	22 e0       	ldi	r18, 0x02	; 2
    7b72:	32 e0       	ldi	r19, 0x02	; 2
    7b74:	0e 94 81 1a 	call	0x3502	; 0x3502 <InserBorder>
    7b78:	ee 24       	eor	r14, r14

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7b7a:	b8 e2       	ldi	r27, 0x28	; 40
    7b7c:	2b 2e       	mov	r2, r27
    7b7e:	31 2c       	mov	r3, r1
    7b80:	2c 0e       	add	r2, r28
    7b82:	3d 1e       	adc	r3, r29
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    7b84:	a7 e3       	ldi	r26, 0x37	; 55
    7b86:	6a 2e       	mov	r6, r26
    7b88:	71 2c       	mov	r7, r1
    7b8a:	6c 0e       	add	r6, r28
    7b8c:	7d 1e       	adc	r7, r29
    7b8e:	d3 01       	movw	r26, r6
    7b90:	1f 96       	adiw	r26, 0x0f	; 15
    7b92:	cb 50       	subi	r28, 0x0B	; 11
    7b94:	df 4f       	sbci	r29, 0xFF	; 255
    7b96:	b9 83       	std	Y+1, r27	; 0x01
    7b98:	a8 83       	st	Y, r26
    7b9a:	c5 5f       	subi	r28, 0xF5	; 245
    7b9c:	d0 40       	sbci	r29, 0x00	; 0
    7b9e:	f6 e4       	ldi	r31, 0x46	; 70
    7ba0:	4f 2e       	mov	r4, r31
    7ba2:	51 2c       	mov	r5, r1
    7ba4:	4c 0e       	add	r4, r28
    7ba6:	5d 1e       	adc	r5, r29
    7ba8:	f2 01       	movw	r30, r4
    7baa:	3f 96       	adiw	r30, 0x0f	; 15
    7bac:	c9 50       	subi	r28, 0x09	; 9
    7bae:	df 4f       	sbci	r29, 0xFF	; 255
    7bb0:	f9 83       	std	Y+1, r31	; 0x01
    7bb2:	e8 83       	st	Y, r30
    7bb4:	c7 5f       	subi	r28, 0xF7	; 247
    7bb6:	d0 40       	sbci	r29, 0x00	; 0
    7bb8:	ed e7       	ldi	r30, 0x7D	; 125
    7bba:	8e 2e       	mov	r8, r30
    7bbc:	91 2c       	mov	r9, r1
    7bbe:	8c 0e       	add	r8, r28
    7bc0:	9d 1e       	adc	r9, r29
    7bc2:	e3 c1       	rjmp	.+966    	; 0x7f8a <systemGenerateReport+0x1546>
    7bc4:	f5 01       	movw	r30, r10
    7bc6:	ec 5f       	subi	r30, 0xFC	; 252
    7bc8:	fd 4f       	sbci	r31, 0xFD	; 253
    7bca:	80 81       	ld	r24, Z
    7bcc:	80 53       	subi	r24, 0x30	; 48
    7bce:	8a 30       	cpi	r24, 0x0A	; 10
    7bd0:	08 f0       	brcs	.+2      	; 0x7bd4 <systemGenerateReport+0x1190>
    7bd2:	80 e0       	ldi	r24, 0x00	; 0
		  else sprintf_P(strReport,PSTR("TOTAL %s%s"),strTabSpace,strTotalVolume);CreateReport(strReport,PrintBuffer,&RepPos);

		  InserBorder(btMiddleLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btMiddleRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);     	      

		  for(iTotal=0;iTotal<strlen(GradeList);iTotal++){
		      xGrade=Ord(GradeList[iTotal]);
    7bd4:	80 93 11 02 	sts	0x0211, r24
			  if (xGrade>0){
    7bd8:	88 23       	and	r24, r24
    7bda:	09 f4       	brne	.+2      	; 0x7bde <systemGenerateReport+0x119a>
    7bdc:	d5 c1       	rjmp	.+938    	; 0x7f88 <systemGenerateReport+0x1544>
			      GetProductName(xGrade,strProduct);
    7bde:	61 e4       	ldi	r22, 0x41	; 65
    7be0:	79 e0       	ldi	r23, 0x09	; 9
    7be2:	0e 94 5b 2e 	call	0x5cb6	; 0x5cb6 <GetProductName>
    7be6:	ec ef       	ldi	r30, 0xFC	; 252
    7be8:	f9 e0       	ldi	r31, 0x09	; 9
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    7bea:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7bec:	8a e0       	ldi	r24, 0x0A	; 10
    7bee:	e0 31       	cpi	r30, 0x10	; 16
    7bf0:	f8 07       	cpc	r31, r24
    7bf2:	d9 f7       	brne	.-10     	; 0x7bea <systemGenerateReport+0x11a6>
    7bf4:	ed ea       	ldi	r30, 0xAD	; 173
    7bf6:	fa e0       	ldi	r31, 0x0A	; 10
	     strMemory[i]=data;
    7bf8:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7bfa:	9a e0       	ldi	r25, 0x0A	; 10
    7bfc:	e1 3c       	cpi	r30, 0xC1	; 193
    7bfe:	f9 07       	cpc	r31, r25
    7c00:	d9 f7       	brne	.-10     	; 0x7bf8 <systemGenerateReport+0x11b4>
			      GetProductName(xGrade,strProduct);
				  
				  FillChar(strTotalVolume,sizeof(strTotalVolume),0);
				  FillChar(strTotalMoney,sizeof(strTotalMoney),0);

				  for(xPump=1;xPump<=8;xPump++){
    7c02:	81 e0       	ldi	r24, 0x01	; 1
    7c04:	80 93 13 02 	sts	0x0213, r24

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7c08:	79 e1       	ldi	r23, 0x19	; 25
    7c0a:	c7 2e       	mov	r12, r23
    7c0c:	d1 2c       	mov	r13, r1
    7c0e:	cc 0e       	add	r12, r28
    7c10:	dd 1e       	adc	r13, r29
    7c12:	e6 c0       	rjmp	.+460    	; 0x7de0 <systemGenerateReport+0x139c>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    7c14:	ce 01       	movw	r24, r28
    7c16:	07 96       	adiw	r24, 0x07	; 7
    7c18:	65 e4       	ldi	r22, 0x45	; 69
    7c1a:	70 e0       	ldi	r23, 0x00	; 0
    7c1c:	48 e0       	ldi	r20, 0x08	; 8
    7c1e:	50 e0       	ldi	r21, 0x00	; 0
    7c20:	26 ef       	ldi	r18, 0xF6	; 246
    7c22:	32 e1       	ldi	r19, 0x12	; 18
    7c24:	0e 94 7a b5 	call	0x16af4	; 0x16af4 <__eerd_block>
				  FillChar(strTotalVolume,sizeof(strTotalVolume),0);
				  FillChar(strTotalMoney,sizeof(strTotalMoney),0);

				  for(xPump=1;xPump<=8;xPump++){
				      eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap, 8);
			          PumpNum=PPumpID[xPump-1];
    7c28:	80 91 13 02 	lds	r24, 0x0213
    7c2c:	fe 01       	movw	r30, r28
    7c2e:	e8 0f       	add	r30, r24
    7c30:	f1 1d       	adc	r31, r1
    7c32:	86 81       	ldd	r24, Z+6	; 0x06
    7c34:	80 93 10 02 	sts	0x0210, r24
					  if (PumpNum>0){
    7c38:	88 23       	and	r24, r24
    7c3a:	09 f4       	brne	.+2      	; 0x7c3e <systemGenerateReport+0x11fa>
    7c3c:	cc c0       	rjmp	.+408    	; 0x7dd6 <systemGenerateReport+0x1392>
						  for (xNozzle=1;xNozzle<=6;xNozzle++){
    7c3e:	81 e0       	ldi	r24, 0x01	; 1
    7c40:	c3 c0       	rjmp	.+390    	; 0x7dc8 <systemGenerateReport+0x1384>
    7c42:	60 91 13 02 	lds	r22, 0x0213
    7c46:	a6 e0       	ldi	r26, 0x06	; 6
    7c48:	6a 9f       	mul	r22, r26
    7c4a:	b0 01       	movw	r22, r0
    7c4c:	11 24       	eor	r1, r1
    7c4e:	61 5b       	subi	r22, 0xB1	; 177
    7c50:	7f 4f       	sbci	r23, 0xFF	; 255
    7c52:	ce 01       	movw	r24, r28
    7c54:	01 96       	adiw	r24, 0x01	; 1
    7c56:	46 e0       	ldi	r20, 0x06	; 6
    7c58:	50 e0       	ldi	r21, 0x00	; 0
    7c5a:	26 ef       	ldi	r18, 0xF6	; 246
    7c5c:	32 e1       	ldi	r19, 0x12	; 18
    7c5e:	0e 94 7a b5 	call	0x16af4	; 0x16af4 <__eerd_block>
							  eeprom_read_block((void*) &PProductID, (const void*) &DefNozzleMap[xPump-1], 6);
							  //Found Grade
						      if (PProductID[xNozzle-1]==xGrade){
    7c62:	80 91 12 02 	lds	r24, 0x0212
    7c66:	fe 01       	movw	r30, r28
    7c68:	e8 0f       	add	r30, r24
    7c6a:	f1 1d       	adc	r31, r1
    7c6c:	90 81       	ld	r25, Z
    7c6e:	80 91 11 02 	lds	r24, 0x0211
    7c72:	98 17       	cp	r25, r24
    7c74:	09 f0       	breq	.+2      	; 0x7c78 <systemGenerateReport+0x1234>
    7c76:	a5 c0       	rjmp	.+330    	; 0x7dc2 <systemGenerateReport+0x137e>
    7c78:	e8 e0       	ldi	r30, 0x08	; 8
    7c7a:	fe e0       	ldi	r31, 0x0E	; 14
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    7c7c:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7c7e:	be e0       	ldi	r27, 0x0E	; 14
    7c80:	e7 31       	cpi	r30, 0x17	; 23
    7c82:	fb 07       	cpc	r31, r27
    7c84:	d9 f7       	brne	.-10     	; 0x7c7c <systemGenerateReport+0x1238>
    7c86:	ed ed       	ldi	r30, 0xDD	; 221
    7c88:	fa e0       	ldi	r31, 0x0A	; 10
	     strMemory[i]=data;
    7c8a:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7c8c:	8a e0       	ldi	r24, 0x0A	; 10
    7c8e:	ec 3e       	cpi	r30, 0xEC	; 236
    7c90:	f8 07       	cpc	r31, r24
    7c92:	d9 f7       	brne	.-10     	; 0x7c8a <systemGenerateReport+0x1246>
    7c94:	f6 01       	movw	r30, r12
	     strMemory[i]=data;
    7c96:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7c98:	e2 15       	cp	r30, r2
    7c9a:	f3 05       	cpc	r31, r3
    7c9c:	e1 f7       	brne	.-8      	; 0x7c96 <systemGenerateReport+0x1252>
    7c9e:	f1 01       	movw	r30, r2
	     strMemory[i]=data;
    7ca0:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7ca2:	e6 15       	cp	r30, r6
    7ca4:	f7 05       	cpc	r31, r7
    7ca6:	e1 f7       	brne	.-8      	; 0x7ca0 <systemGenerateReport+0x125c>
    7ca8:	f3 01       	movw	r30, r6
	     strMemory[i]=data;
    7caa:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7cac:	cb 50       	subi	r28, 0x0B	; 11
    7cae:	df 4f       	sbci	r29, 0xFF	; 255
    7cb0:	a8 81       	ld	r26, Y
    7cb2:	b9 81       	ldd	r27, Y+1	; 0x01
    7cb4:	c5 5f       	subi	r28, 0xF5	; 245
    7cb6:	d0 40       	sbci	r29, 0x00	; 0
    7cb8:	ea 17       	cp	r30, r26
    7cba:	fb 07       	cpc	r31, r27
    7cbc:	b1 f7       	brne	.-20     	; 0x7caa <systemGenerateReport+0x1266>
    7cbe:	f2 01       	movw	r30, r4
	     strMemory[i]=data;
    7cc0:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7cc2:	c9 50       	subi	r28, 0x09	; 9
    7cc4:	df 4f       	sbci	r29, 0xFF	; 255
    7cc6:	88 81       	ld	r24, Y
    7cc8:	99 81       	ldd	r25, Y+1	; 0x01
    7cca:	c7 5f       	subi	r28, 0xF7	; 247
    7ccc:	d0 40       	sbci	r29, 0x00	; 0
    7cce:	e8 17       	cp	r30, r24
    7cd0:	f9 07       	cpc	r31, r25
    7cd2:	b1 f7       	brne	.-20     	; 0x7cc0 <systemGenerateReport+0x127c>
								  FillChar(strLastVolume,sizeof(strLastVolume),0);
								  FillChar(strLastMoney,sizeof(strLastMoney),0);
								  FillChar(strCurrentVolume,sizeof(strCurrentVolume),0);
								  FillChar(strCurrentMoney,sizeof(strCurrentMoney),0);

								  PumpNozzle=xNozzle;
    7cd4:	80 91 12 02 	lds	r24, 0x0212
    7cd8:	80 93 0f 02 	sts	0x020F, r24
								  
								  FIPAddr=GetFIPAddr(PumpNum); 
    7cdc:	80 91 10 02 	lds	r24, 0x0210
    7ce0:	0e 94 e1 1d 	call	0x3bc2	; 0x3bc2 <GetFIPAddr>
								  if (FIPAddr>0){
    7ce4:	88 23       	and	r24, r24
    7ce6:	11 f1       	breq	.+68     	; 0x7d2c <systemGenerateReport+0x12e8>
									  FIPAddr=FIPAddr-1;							  							  							      
    7ce8:	f8 2e       	mov	r15, r24
    7cea:	fa 94       	dec	r15
									  GetTotalizerData(TVOLUME,TOTALIZER_LAST,FIPAddr,PumpNozzle,strLastVolume);
    7cec:	80 e0       	ldi	r24, 0x00	; 0
    7cee:	60 e0       	ldi	r22, 0x00	; 0
    7cf0:	4f 2d       	mov	r20, r15
    7cf2:	20 91 0f 02 	lds	r18, 0x020F
    7cf6:	86 01       	movw	r16, r12
    7cf8:	0e 94 a0 1e 	call	0x3d40	; 0x3d40 <GetTotalizerData>
									  GetTotalizerData(TMONEY,TOTALIZER_LAST,FIPAddr,PumpNozzle,strLastMoney);
    7cfc:	81 e0       	ldi	r24, 0x01	; 1
    7cfe:	60 e0       	ldi	r22, 0x00	; 0
    7d00:	4f 2d       	mov	r20, r15
    7d02:	20 91 0f 02 	lds	r18, 0x020F
    7d06:	81 01       	movw	r16, r2
    7d08:	0e 94 a0 1e 	call	0x3d40	; 0x3d40 <GetTotalizerData>

									  GetTotalizerData(TVOLUME,TOTALIZER_NOW,FIPAddr,PumpNozzle,strCurrentVolume);
    7d0c:	80 e0       	ldi	r24, 0x00	; 0
    7d0e:	61 e0       	ldi	r22, 0x01	; 1
    7d10:	4f 2d       	mov	r20, r15
    7d12:	20 91 0f 02 	lds	r18, 0x020F
    7d16:	83 01       	movw	r16, r6
    7d18:	0e 94 a0 1e 	call	0x3d40	; 0x3d40 <GetTotalizerData>
									  GetTotalizerData(TMONEY,TOTALIZER_NOW,FIPAddr,PumpNozzle,strCurrentMoney);
    7d1c:	81 e0       	ldi	r24, 0x01	; 1
    7d1e:	61 e0       	ldi	r22, 0x01	; 1
    7d20:	4f 2d       	mov	r20, r15
    7d22:	20 91 0f 02 	lds	r18, 0x020F
    7d26:	82 01       	movw	r16, r4
    7d28:	0e 94 a0 1e 	call	0x3d40	; 0x3d40 <GetTotalizerData>
								  }

								  StrCalc(TMINUS,strCurrentVolume,strLastVolume,strDeltaVolume);
    7d2c:	80 e0       	ldi	r24, 0x00	; 0
    7d2e:	b3 01       	movw	r22, r6
    7d30:	a6 01       	movw	r20, r12
    7d32:	2d ed       	ldi	r18, 0xDD	; 221
    7d34:	3a e0       	ldi	r19, 0x0A	; 10
    7d36:	0e 94 f3 29 	call	0x53e6	; 0x53e6 <StrCalc>
								  if (IsMinus(strDeltaVolume)==True)
    7d3a:	8d ed       	ldi	r24, 0xDD	; 221
    7d3c:	9a e0       	ldi	r25, 0x0A	; 10
    7d3e:	0e 94 ee 23 	call	0x47dc	; 0x47dc <IsMinus>
    7d42:	81 30       	cpi	r24, 0x01	; 1
    7d44:	21 f4       	brne	.+8      	; 0x7d4e <systemGenerateReport+0x130a>
								      NormalizeOverflow(strDeltaVolume);
    7d46:	8d ed       	ldi	r24, 0xDD	; 221
    7d48:	9a e0       	ldi	r25, 0x0A	; 10
    7d4a:	0e 94 8a 2d 	call	0x5b14	; 0x5b14 <NormalizeOverflow>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    7d4e:	e1 99       	sbic	0x1c, 1	; 28
    7d50:	fe cf       	rjmp	.-4      	; 0x7d4e <systemGenerateReport+0x130a>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    7d52:	a7 e3       	ldi	r26, 0x37	; 55
    7d54:	b1 e0       	ldi	r27, 0x01	; 1
    7d56:	bf bb       	out	0x1f, r27	; 31
    7d58:	ae bb       	out	0x1e, r26	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    7d5a:	e0 9a       	sbi	0x1c, 0	; 28
    7d5c:	8d b3       	in	r24, 0x1d	; 29


								  //Calculate Wayne Estimated Total Money
								  if (eeprom_read_byte(&DefDispenserBrand)==ST_WAYNE_DART){
    7d5e:	82 30       	cpi	r24, 0x02	; 2
    7d60:	79 f4       	brne	.+30     	; 0x7d80 <systemGenerateReport+0x133c>
						              GetProductPrice(sPrice,PumpNum,PumpNozzle);//Money = Price x Volume
    7d62:	ce 01       	movw	r24, r28
    7d64:	0f 96       	adiw	r24, 0x0f	; 15
    7d66:	60 91 10 02 	lds	r22, 0x0210
    7d6a:	40 91 0f 02 	lds	r20, 0x020F
    7d6e:	0e 94 d1 24 	call	0x49a2	; 0x49a2 <GetProductPrice>
									  StrCalc(TMULTIPLY,sPrice,strDeltaVolume,strDeltaMoney);
    7d72:	82 e0       	ldi	r24, 0x02	; 2
    7d74:	be 01       	movw	r22, r28
    7d76:	61 5f       	subi	r22, 0xF1	; 241
    7d78:	7f 4f       	sbci	r23, 0xFF	; 255
    7d7a:	4d ed       	ldi	r20, 0xDD	; 221
    7d7c:	5a e0       	ldi	r21, 0x0A	; 10
    7d7e:	03 c0       	rjmp	.+6      	; 0x7d86 <systemGenerateReport+0x1342>
								  }else StrCalc(TMINUS,strCurrentMoney,strLastMoney,strDeltaMoney);
    7d80:	80 e0       	ldi	r24, 0x00	; 0
    7d82:	b2 01       	movw	r22, r4
    7d84:	a1 01       	movw	r20, r2
    7d86:	28 e0       	ldi	r18, 0x08	; 8
    7d88:	3e e0       	ldi	r19, 0x0E	; 14
    7d8a:	0e 94 f3 29 	call	0x53e6	; 0x53e6 <StrCalc>
								  //StrCalc(TMINUS,strCurrentMoney,strLastMoney,strDeltaMoney);
								  if (IsMinus(strDeltaMoney)==True)
    7d8e:	88 e0       	ldi	r24, 0x08	; 8
    7d90:	9e e0       	ldi	r25, 0x0E	; 14
    7d92:	0e 94 ee 23 	call	0x47dc	; 0x47dc <IsMinus>
    7d96:	81 30       	cpi	r24, 0x01	; 1
    7d98:	21 f4       	brne	.+8      	; 0x7da2 <systemGenerateReport+0x135e>
								      NormalizeOverflow(strDeltaMoney);
    7d9a:	88 e0       	ldi	r24, 0x08	; 8
    7d9c:	9e e0       	ldi	r25, 0x0E	; 14
    7d9e:	0e 94 8a 2d 	call	0x5b14	; 0x5b14 <NormalizeOverflow>
		  
								  StrCalc(TPLUS,strTotalVolume,strDeltaVolume,strTotalVolume);
    7da2:	81 e0       	ldi	r24, 0x01	; 1
    7da4:	6c ef       	ldi	r22, 0xFC	; 252
    7da6:	79 e0       	ldi	r23, 0x09	; 9
    7da8:	4d ed       	ldi	r20, 0xDD	; 221
    7daa:	5a e0       	ldi	r21, 0x0A	; 10
    7dac:	9b 01       	movw	r18, r22
    7dae:	0e 94 f3 29 	call	0x53e6	; 0x53e6 <StrCalc>
								  StrCalc(TPLUS,strTotalMoney,strDeltaMoney,strTotalMoney);
    7db2:	81 e0       	ldi	r24, 0x01	; 1
    7db4:	6d ea       	ldi	r22, 0xAD	; 173
    7db6:	7a e0       	ldi	r23, 0x0A	; 10
    7db8:	48 e0       	ldi	r20, 0x08	; 8
    7dba:	5e e0       	ldi	r21, 0x0E	; 14
    7dbc:	9b 01       	movw	r18, r22
    7dbe:	0e 94 f3 29 	call	0x53e6	; 0x53e6 <StrCalc>

				  for(xPump=1;xPump<=8;xPump++){
				      eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap, 8);
			          PumpNum=PPumpID[xPump-1];
					  if (PumpNum>0){
						  for (xNozzle=1;xNozzle<=6;xNozzle++){
    7dc2:	80 91 12 02 	lds	r24, 0x0212
    7dc6:	8f 5f       	subi	r24, 0xFF	; 255
    7dc8:	80 93 12 02 	sts	0x0212, r24
    7dcc:	80 91 12 02 	lds	r24, 0x0212
    7dd0:	87 30       	cpi	r24, 0x07	; 7
    7dd2:	08 f4       	brcc	.+2      	; 0x7dd6 <systemGenerateReport+0x1392>
    7dd4:	36 cf       	rjmp	.-404    	; 0x7c42 <systemGenerateReport+0x11fe>
			      GetProductName(xGrade,strProduct);
				  
				  FillChar(strTotalVolume,sizeof(strTotalVolume),0);
				  FillChar(strTotalMoney,sizeof(strTotalMoney),0);

				  for(xPump=1;xPump<=8;xPump++){
    7dd6:	80 91 13 02 	lds	r24, 0x0213
    7dda:	8f 5f       	subi	r24, 0xFF	; 255
    7ddc:	80 93 13 02 	sts	0x0213, r24
    7de0:	80 91 13 02 	lds	r24, 0x0213
    7de4:	89 30       	cpi	r24, 0x09	; 9
    7de6:	08 f4       	brcc	.+2      	; 0x7dea <systemGenerateReport+0x13a6>
    7de8:	15 cf       	rjmp	.-470    	; 0x7c14 <systemGenerateReport+0x11d0>
							  }
						  }
					  }				  
				  }

				  RemZeroLead(strTotalMoney);
    7dea:	8d ea       	ldi	r24, 0xAD	; 173
    7dec:	9a e0       	ldi	r25, 0x0A	; 10
    7dee:	0e 94 b9 25 	call	0x4b72	; 0x4b72 <RemZeroLead>
				  RemZeroLead(strTotalVolume);
    7df2:	0c ef       	ldi	r16, 0xFC	; 252
    7df4:	19 e0       	ldi	r17, 0x09	; 9
    7df6:	c8 01       	movw	r24, r16
    7df8:	0e 94 b9 25 	call	0x4b72	; 0x4b72 <RemZeroLead>

				  FormatTotalizerMoney(strTotalMoney);
    7dfc:	8d ea       	ldi	r24, 0xAD	; 173
    7dfe:	9a e0       	ldi	r25, 0x0A	; 10
    7e00:	0e 94 ee 34 	call	0x69dc	; 0x69dc <FormatTotalizerMoney>
				  FormatCurrency(strTotalMoney);
    7e04:	8d ea       	ldi	r24, 0xAD	; 173
    7e06:	9a e0       	ldi	r25, 0x0A	; 10
    7e08:	0e 94 b1 33 	call	0x6762	; 0x6762 <FormatCurrency>

				  FormatTotalizerVolume(strTotalVolume);
    7e0c:	c8 01       	movw	r24, r16
    7e0e:	0e 94 e1 34 	call	0x69c2	; 0x69c2 <FormatTotalizerVolume>
				  FormatCurrency(strTotalVolume);
    7e12:	c8 01       	movw	r24, r16
    7e14:	0e 94 b1 33 	call	0x6762	; 0x6762 <FormatCurrency>
		          //Test
				 // RemZeroLead(strTotalMoney);
				 // RemZeroLead(strTotalVolume);


			      GetTabSpace((21-strlen(strProduct)-strlen(strTotalVolume)),strTabSpace);
    7e18:	e1 e4       	ldi	r30, 0x41	; 65
    7e1a:	f9 e0       	ldi	r31, 0x09	; 9
    7e1c:	01 90       	ld	r0, Z+
    7e1e:	00 20       	and	r0, r0
    7e20:	e9 f7       	brne	.-6      	; 0x7e1c <systemGenerateReport+0x13d8>
    7e22:	31 97       	sbiw	r30, 0x01	; 1
    7e24:	e1 54       	subi	r30, 0x41	; 65
    7e26:	f9 40       	sbci	r31, 0x09	; 9
    7e28:	d8 01       	movw	r26, r16
    7e2a:	0d 90       	ld	r0, X+
    7e2c:	00 20       	and	r0, r0
    7e2e:	e9 f7       	brne	.-6      	; 0x7e2a <systemGenerateReport+0x13e6>
    7e30:	8d 01       	movw	r16, r26
    7e32:	01 50       	subi	r16, 0x01	; 1
    7e34:	10 40       	sbci	r17, 0x00	; 0
    7e36:	0c 5f       	subi	r16, 0xFC	; 252
    7e38:	19 40       	sbci	r17, 0x09	; 9
    7e3a:	8e 2f       	mov	r24, r30
    7e3c:	81 95       	neg	r24
    7e3e:	80 1b       	sub	r24, r16
    7e40:	8b 5e       	subi	r24, 0xEB	; 235
    7e42:	de 01       	movw	r26, r28
    7e44:	a7 59       	subi	r26, 0x97	; 151
    7e46:	bf 4f       	sbci	r27, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    7e48:	18 16       	cp	r1, r24
    7e4a:	7c f4       	brge	.+30     	; 0x7e6a <systemGenerateReport+0x1426>
    7e4c:	fd 01       	movw	r30, r26
    7e4e:	90 e0       	ldi	r25, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    7e50:	20 e2       	ldi	r18, 0x20	; 32
    7e52:	02 c0       	rjmp	.+4      	; 0x7e58 <systemGenerateReport+0x1414>
    7e54:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    7e56:	9f 5f       	subi	r25, 0xFF	; 255
    7e58:	98 17       	cp	r25, r24
    7e5a:	e0 f3       	brcs	.-8      	; 0x7e54 <systemGenerateReport+0x1410>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    7e5c:	fe 01       	movw	r30, r28
    7e5e:	e7 59       	subi	r30, 0x97	; 151
    7e60:	ff 4f       	sbci	r31, 0xFF	; 255
    7e62:	e8 0f       	add	r30, r24
    7e64:	f1 1d       	adc	r31, r1
    7e66:	10 82       	st	Z, r1
    7e68:	04 c0       	rjmp	.+8      	; 0x7e72 <systemGenerateReport+0x142e>
     }else{
	 strTab[0]=' ';
    7e6a:	80 e2       	ldi	r24, 0x20	; 32
    7e6c:	8c 93       	st	X, r24
	 strTab[1]=0;
    7e6e:	11 96       	adiw	r26, 0x01	; 1
    7e70:	1c 92       	st	X, r1
				 // RemZeroLead(strTotalMoney);
				 // RemZeroLead(strTotalVolume);


			      GetTabSpace((21-strlen(strProduct)-strlen(strTotalVolume)),strTabSpace);
			      GetTabSpace((15-strlen(strTotalMoney)),strTabSpace2);
    7e72:	ed ea       	ldi	r30, 0xAD	; 173
    7e74:	fa e0       	ldi	r31, 0x0A	; 10
    7e76:	01 90       	ld	r0, Z+
    7e78:	00 20       	and	r0, r0
    7e7a:	e9 f7       	brne	.-6      	; 0x7e76 <systemGenerateReport+0x1432>
    7e7c:	31 97       	sbiw	r30, 0x01	; 1
    7e7e:	ed 5a       	subi	r30, 0xAD	; 173
    7e80:	fa 40       	sbci	r31, 0x0A	; 10
    7e82:	9f e0       	ldi	r25, 0x0F	; 15
    7e84:	9e 1b       	sub	r25, r30
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    7e86:	19 16       	cp	r1, r25
    7e88:	6c f4       	brge	.+26     	; 0x7ea4 <systemGenerateReport+0x1460>
    7e8a:	f4 01       	movw	r30, r8
    7e8c:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    7e8e:	20 e2       	ldi	r18, 0x20	; 32
    7e90:	02 c0       	rjmp	.+4      	; 0x7e96 <systemGenerateReport+0x1452>
    7e92:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    7e94:	8f 5f       	subi	r24, 0xFF	; 255
    7e96:	89 17       	cp	r24, r25
    7e98:	e0 f3       	brcs	.-8      	; 0x7e92 <systemGenerateReport+0x144e>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    7e9a:	f4 01       	movw	r30, r8
    7e9c:	e9 0f       	add	r30, r25
    7e9e:	f1 1d       	adc	r31, r1
    7ea0:	10 82       	st	Z, r1
    7ea2:	04 c0       	rjmp	.+8      	; 0x7eac <systemGenerateReport+0x1468>
     }else{
	 strTab[0]=' ';
    7ea4:	80 e2       	ldi	r24, 0x20	; 32
    7ea6:	f4 01       	movw	r30, r8
    7ea8:	80 83       	st	Z, r24
	 strTab[1]=0;
    7eaa:	11 82       	std	Z+1, r1	; 0x01
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    7eac:	e1 99       	sbic	0x1c, 1	; 28
    7eae:	fe cf       	rjmp	.-4      	; 0x7eac <systemGenerateReport+0x1468>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    7eb0:	81 ec       	ldi	r24, 0xC1	; 193
    7eb2:	93 e0       	ldi	r25, 0x03	; 3
    7eb4:	9f bb       	out	0x1f, r25	; 31
    7eb6:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    7eb8:	e0 9a       	sbi	0x1c, 0	; 28
    7eba:	8d b3       	in	r24, 0x1d	; 29
    7ebc:	9e 01       	movw	r18, r28
    7ebe:	2b 55       	subi	r18, 0x5B	; 91
    7ec0:	3f 4f       	sbci	r19, 0xFF	; 255
    7ec2:	4c ef       	ldi	r20, 0xFC	; 252
    7ec4:	59 e0       	ldi	r21, 0x09	; 9
    7ec6:	61 e4       	ldi	r22, 0x41	; 65
    7ec8:	c6 2e       	mov	r12, r22
    7eca:	69 e0       	ldi	r22, 0x09	; 9
    7ecc:	d6 2e       	mov	r13, r22
    7ece:	de 01       	movw	r26, r28
    7ed0:	a7 59       	subi	r26, 0x97	; 151
    7ed2:	bf 4f       	sbci	r27, 0xFF	; 255
    7ed4:	b5 01       	movw	r22, r10
    7ed6:	6f 5f       	subi	r22, 0xFF	; 255
    7ed8:	7f 4f       	sbci	r23, 0xFF	; 255

			      GetTabSpace((21-strlen(strProduct)-strlen(strTotalVolume)),strTabSpace);
			      GetTabSpace((15-strlen(strTotalMoney)),strTabSpace2);

				  //PrintMoney
		          if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("%d.%s%s%s%s%s"),iTotal+1,strProduct,strTabSpace,strTotalVolume,strTabSpace2,strTotalMoney);
    7eda:	81 30       	cpi	r24, 0x01	; 1
    7edc:	39 f5       	brne	.+78     	; 0x7f2c <systemGenerateReport+0x14e8>
    7ede:	ed b7       	in	r30, 0x3d	; 61
    7ee0:	fe b7       	in	r31, 0x3e	; 62
    7ee2:	70 97       	sbiw	r30, 0x10	; 16
    7ee4:	0f b6       	in	r0, 0x3f	; 63
    7ee6:	f8 94       	cli
    7ee8:	fe bf       	out	0x3e, r31	; 62
    7eea:	0f be       	out	0x3f, r0	; 63
    7eec:	ed bf       	out	0x3d, r30	; 61
    7eee:	0d b7       	in	r16, 0x3d	; 61
    7ef0:	1e b7       	in	r17, 0x3e	; 62
    7ef2:	0f 5f       	subi	r16, 0xFF	; 255
    7ef4:	1f 4f       	sbci	r17, 0xFF	; 255
    7ef6:	32 83       	std	Z+2, r19	; 0x02
    7ef8:	21 83       	std	Z+1, r18	; 0x01
    7efa:	8e e0       	ldi	r24, 0x0E	; 14
    7efc:	94 e0       	ldi	r25, 0x04	; 4
    7efe:	f8 01       	movw	r30, r16
    7f00:	93 83       	std	Z+3, r25	; 0x03
    7f02:	82 83       	std	Z+2, r24	; 0x02
    7f04:	75 83       	std	Z+5, r23	; 0x05
    7f06:	64 83       	std	Z+4, r22	; 0x04
    7f08:	d7 82       	std	Z+7, r13	; 0x07
    7f0a:	c6 82       	std	Z+6, r12	; 0x06
    7f0c:	b1 87       	std	Z+9, r27	; 0x09
    7f0e:	a0 87       	std	Z+8, r26	; 0x08
    7f10:	53 87       	std	Z+11, r21	; 0x0b
    7f12:	42 87       	std	Z+10, r20	; 0x0a
    7f14:	95 86       	std	Z+13, r9	; 0x0d
    7f16:	84 86       	std	Z+12, r8	; 0x0c
    7f18:	8d ea       	ldi	r24, 0xAD	; 173
    7f1a:	9a e0       	ldi	r25, 0x0A	; 10
    7f1c:	97 87       	std	Z+15, r25	; 0x0f
    7f1e:	86 87       	std	Z+14, r24	; 0x0e
    7f20:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    7f24:	8d b7       	in	r24, 0x3d	; 61
    7f26:	9e b7       	in	r25, 0x3e	; 62
    7f28:	40 96       	adiw	r24, 0x10	; 16
    7f2a:	20 c0       	rjmp	.+64     	; 0x7f6c <systemGenerateReport+0x1528>
				  else sprintf_P(strReport,PSTR("%d.%s%s%s"),iTotal+1,strProduct,strTabSpace,strTotalVolume);
    7f2c:	ed b7       	in	r30, 0x3d	; 61
    7f2e:	fe b7       	in	r31, 0x3e	; 62
    7f30:	3c 97       	sbiw	r30, 0x0c	; 12
    7f32:	0f b6       	in	r0, 0x3f	; 63
    7f34:	f8 94       	cli
    7f36:	fe bf       	out	0x3e, r31	; 62
    7f38:	0f be       	out	0x3f, r0	; 63
    7f3a:	ed bf       	out	0x3d, r30	; 61
    7f3c:	0d b7       	in	r16, 0x3d	; 61
    7f3e:	1e b7       	in	r17, 0x3e	; 62
    7f40:	0f 5f       	subi	r16, 0xFF	; 255
    7f42:	1f 4f       	sbci	r17, 0xFF	; 255
    7f44:	32 83       	std	Z+2, r19	; 0x02
    7f46:	21 83       	std	Z+1, r18	; 0x01
    7f48:	84 e0       	ldi	r24, 0x04	; 4
    7f4a:	94 e0       	ldi	r25, 0x04	; 4
    7f4c:	f8 01       	movw	r30, r16
    7f4e:	93 83       	std	Z+3, r25	; 0x03
    7f50:	82 83       	std	Z+2, r24	; 0x02
    7f52:	75 83       	std	Z+5, r23	; 0x05
    7f54:	64 83       	std	Z+4, r22	; 0x04
    7f56:	d7 82       	std	Z+7, r13	; 0x07
    7f58:	c6 82       	std	Z+6, r12	; 0x06
    7f5a:	b1 87       	std	Z+9, r27	; 0x09
    7f5c:	a0 87       	std	Z+8, r26	; 0x08
    7f5e:	53 87       	std	Z+11, r21	; 0x0b
    7f60:	42 87       	std	Z+10, r20	; 0x0a
    7f62:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    7f66:	8d b7       	in	r24, 0x3d	; 61
    7f68:	9e b7       	in	r25, 0x3e	; 62
    7f6a:	0c 96       	adiw	r24, 0x0c	; 12
    7f6c:	0f b6       	in	r0, 0x3f	; 63
    7f6e:	f8 94       	cli
    7f70:	9e bf       	out	0x3e, r25	; 62
    7f72:	0f be       	out	0x3f, r0	; 63
    7f74:	8d bf       	out	0x3d, r24	; 61

				  CreateReport(strReport,PrintBuffer,&RepPos);
    7f76:	ce 01       	movw	r24, r28
    7f78:	8b 55       	subi	r24, 0x5B	; 91
    7f7a:	9f 4f       	sbci	r25, 0xFF	; 255
    7f7c:	6f ec       	ldi	r22, 0xCF	; 207
    7f7e:	75 e0       	ldi	r23, 0x05	; 5
    7f80:	42 e0       	ldi	r20, 0x02	; 2
    7f82:	52 e0       	ldi	r21, 0x02	; 2
    7f84:	0e 94 89 22 	call	0x4512	; 0x4512 <CreateReport>
		  if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("TOTAL %s%s%s%s"),strTabSpace,strTotalVolume,strTabSpace2,strTotalMoney);//CreateReport(strReport,PrintBuffer,&RepPos);
		  else sprintf_P(strReport,PSTR("TOTAL %s%s"),strTabSpace,strTotalVolume);CreateReport(strReport,PrintBuffer,&RepPos);

		  InserBorder(btMiddleLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btMiddleRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);     	      

		  for(iTotal=0;iTotal<strlen(GradeList);iTotal++){
    7f88:	e3 94       	inc	r14
    7f8a:	e4 e0       	ldi	r30, 0x04	; 4
    7f8c:	f2 e0       	ldi	r31, 0x02	; 2
    7f8e:	01 90       	ld	r0, Z+
    7f90:	00 20       	and	r0, r0
    7f92:	e9 f7       	brne	.-6      	; 0x7f8e <systemGenerateReport+0x154a>
    7f94:	31 97       	sbiw	r30, 0x01	; 1
    7f96:	e4 50       	subi	r30, 0x04	; 4
    7f98:	f2 40       	sbci	r31, 0x02	; 2
    7f9a:	ae 2c       	mov	r10, r14
    7f9c:	bb 24       	eor	r11, r11
    7f9e:	ae 16       	cp	r10, r30
    7fa0:	bf 06       	cpc	r11, r31
    7fa2:	08 f4       	brcc	.+2      	; 0x7fa6 <systemGenerateReport+0x1562>
    7fa4:	0f ce       	rjmp	.-994    	; 0x7bc4 <systemGenerateReport+0x1180>
				  else sprintf_P(strReport,PSTR("%d.%s%s%s"),iTotal+1,strProduct,strTabSpace,strTotalVolume);

				  CreateReport(strReport,PrintBuffer,&RepPos);
               }
		  }
          InserBorder(btBottomLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btBottomRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);
    7fa6:	87 e0       	ldi	r24, 0x07	; 7
    7fa8:	6f ec       	ldi	r22, 0xCF	; 207
    7faa:	75 e0       	ldi	r23, 0x05	; 5
    7fac:	41 e0       	ldi	r20, 0x01	; 1
    7fae:	22 e0       	ldi	r18, 0x02	; 2
    7fb0:	32 e0       	ldi	r19, 0x02	; 2
    7fb2:	0e 94 81 1a 	call	0x3502	; 0x3502 <InserBorder>
    7fb6:	8b e0       	ldi	r24, 0x0B	; 11
    7fb8:	6f ec       	ldi	r22, 0xCF	; 207
    7fba:	75 e0       	ldi	r23, 0x05	; 5
    7fbc:	4a e2       	ldi	r20, 0x2A	; 42
    7fbe:	22 e0       	ldi	r18, 0x02	; 2
    7fc0:	32 e0       	ldi	r19, 0x02	; 2
    7fc2:	0e 94 81 1a 	call	0x3502	; 0x3502 <InserBorder>
    7fc6:	89 e0       	ldi	r24, 0x09	; 9
    7fc8:	6f ec       	ldi	r22, 0xCF	; 207
    7fca:	75 e0       	ldi	r23, 0x05	; 5
    7fcc:	41 e0       	ldi	r20, 0x01	; 1
    7fce:	22 e0       	ldi	r18, 0x02	; 2
    7fd0:	32 e0       	ldi	r19, 0x02	; 2
    7fd2:	0e 94 81 1a 	call	0x3502	; 0x3502 <InserBorder>
    7fd6:	8c e0       	ldi	r24, 0x0C	; 12
    7fd8:	6f ec       	ldi	r22, 0xCF	; 207
    7fda:	75 e0       	ldi	r23, 0x05	; 5
    7fdc:	41 e0       	ldi	r20, 0x01	; 1
    7fde:	22 e0       	ldi	r18, 0x02	; 2
    7fe0:	32 e0       	ldi	r19, 0x02	; 2
    7fe2:	0e 94 81 1a 	call	0x3502	; 0x3502 <InserBorder>
		  InserBorder(btNewLine,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);
    7fe6:	8c e0       	ldi	r24, 0x0C	; 12
    7fe8:	6f ec       	ldi	r22, 0xCF	; 207
    7fea:	75 e0       	ldi	r23, 0x05	; 5
    7fec:	41 e0       	ldi	r20, 0x01	; 1
    7fee:	22 e0       	ldi	r18, 0x02	; 2
    7ff0:	32 e0       	ldi	r19, 0x02	; 2
    7ff2:	0e 94 81 1a 	call	0x3502	; 0x3502 <InserBorder>
    7ff6:	8c e0       	ldi	r24, 0x0C	; 12
    7ff8:	6f ec       	ldi	r22, 0xCF	; 207
    7ffa:	75 e0       	ldi	r23, 0x05	; 5
    7ffc:	41 e0       	ldi	r20, 0x01	; 1
    7ffe:	22 e0       	ldi	r18, 0x02	; 2
    8000:	32 e0       	ldi	r19, 0x02	; 2
    8002:	0e 94 81 1a 	call	0x3502	; 0x3502 <InserBorder>
    8006:	8c e0       	ldi	r24, 0x0C	; 12
    8008:	6f ec       	ldi	r22, 0xCF	; 207
    800a:	75 e0       	ldi	r23, 0x05	; 5
    800c:	41 e0       	ldi	r20, 0x01	; 1
    800e:	22 e0       	ldi	r18, 0x02	; 2
    8010:	32 e0       	ldi	r19, 0x02	; 2
    8012:	0e 94 81 1a 	call	0x3502	; 0x3502 <InserBorder>
    8016:	8c e0       	ldi	r24, 0x0C	; 12
    8018:	6f ec       	ldi	r22, 0xCF	; 207
    801a:	75 e0       	ldi	r23, 0x05	; 5
    801c:	41 e0       	ldi	r20, 0x01	; 1
    801e:	22 e0       	ldi	r18, 0x02	; 2
    8020:	32 e0       	ldi	r19, 0x02	; 2
    8022:	0e 94 81 1a 	call	0x3502	; 0x3502 <InserBorder>
    8026:	8c e0       	ldi	r24, 0x0C	; 12
    8028:	6f ec       	ldi	r22, 0xCF	; 207
    802a:	75 e0       	ldi	r23, 0x05	; 5
    802c:	41 e0       	ldi	r20, 0x01	; 1
    802e:	22 e0       	ldi	r18, 0x02	; 2
    8030:	32 e0       	ldi	r19, 0x02	; 2
    8032:	0e 94 81 1a 	call	0x3502	; 0x3502 <InserBorder>


          cmdPrint=0b00010000|(1<<PRN_PAPER_CUT);
    8036:	80 e3       	ldi	r24, 0x30	; 48
    8038:	80 93 cb 01 	sts	0x01CB, r24
		  LengthMessage81=RepPos+1;
    803c:	80 91 02 02 	lds	r24, 0x0202
    8040:	90 91 03 02 	lds	r25, 0x0203
    8044:	01 96       	adiw	r24, 0x01	; 1
    8046:	90 93 a1 01 	sts	0x01A1, r25
    804a:	80 93 a0 01 	sts	0x01A0, r24
		  IsFreePrinting=True;
    804e:	81 e0       	ldi	r24, 0x01	; 1
    8050:	80 93 bf 01 	sts	0x01BF, r24
	      IsBusyFreePrinting=True; 
    8054:	80 93 ca 01 	sts	0x01CA, r24
         	       
	      stGenerateReport=grWaitPrinted3;
    8058:	8b e0       	ldi	r24, 0x0B	; 11
    805a:	05 c0       	rjmp	.+10     	; 0x8066 <systemGenerateReport+0x1622>
	      break;
     case grWaitPrinted3:
          if (IsBusyFreePrinting==False)stGenerateReport=grFinishGenerateReport;
    805c:	80 91 ca 01 	lds	r24, 0x01CA
    8060:	88 23       	and	r24, r24
    8062:	49 f4       	brne	.+18     	; 0x8076 <systemGenerateReport+0x1632>
    8064:	8c e0       	ldi	r24, 0x0C	; 12
    8066:	80 93 14 02 	sts	0x0214, r24
    806a:	05 c0       	rjmp	.+10     	; 0x8076 <systemGenerateReport+0x1632>
	      break;
     case grFinishGenerateReport:
	      IsFinishPrintingTotalizer=True;
    806c:	81 e0       	ldi	r24, 0x01	; 1
    806e:	80 93 9a 01 	sts	0x019A, r24
          stGenerateReport=grScanAction;
    8072:	10 92 14 02 	sts	0x0214, r1
	      break;
	 }
}
    8076:	c8 50       	subi	r28, 0x08	; 8
    8078:	df 4f       	sbci	r29, 0xFF	; 255
    807a:	0f b6       	in	r0, 0x3f	; 63
    807c:	f8 94       	cli
    807e:	de bf       	out	0x3e, r29	; 62
    8080:	0f be       	out	0x3f, r0	; 63
    8082:	cd bf       	out	0x3d, r28	; 61
    8084:	cf 91       	pop	r28
    8086:	df 91       	pop	r29
    8088:	1f 91       	pop	r17
    808a:	0f 91       	pop	r16
    808c:	ff 90       	pop	r15
    808e:	ef 90       	pop	r14
    8090:	df 90       	pop	r13
    8092:	cf 90       	pop	r12
    8094:	bf 90       	pop	r11
    8096:	af 90       	pop	r10
    8098:	9f 90       	pop	r9
    809a:	8f 90       	pop	r8
    809c:	7f 90       	pop	r7
    809e:	6f 90       	pop	r6
    80a0:	5f 90       	pop	r5
    80a2:	4f 90       	pop	r4
    80a4:	3f 90       	pop	r3
    80a6:	2f 90       	pop	r2
    80a8:	08 95       	ret

000080aa <UpdateCardID>:
	 else SeqNum=0;
	 leadingZero(SeqNum,strSeqNum);
} 


void UpdateCardID(){
    80aa:	cf 93       	push	r28
    80ac:	df 93       	push	r29
     char i,LengthID;
	 LengthID=strlen(strRFID);  //           +12345678  
    80ae:	ec e2       	ldi	r30, 0x2C	; 44
    80b0:	fe e0       	ldi	r31, 0x0E	; 14
    80b2:	01 90       	ld	r0, Z+
    80b4:	00 20       	and	r0, r0
    80b6:	e9 f7       	brne	.-6      	; 0x80b2 <UpdateCardID+0x8>
    80b8:	31 97       	sbiw	r30, 0x01	; 1
    80ba:	ec 52       	subi	r30, 0x2C	; 44
    80bc:	fe 40       	sbci	r31, 0x0E	; 14
    80be:	a1 e6       	ldi	r26, 0x61	; 97
    80c0:	bd e0       	ldi	r27, 0x0D	; 13
	 else SeqNum=0;
	 leadingZero(SeqNum,strSeqNum);
} 


void UpdateCardID(){
    80c2:	f0 e0       	ldi	r31, 0x00	; 0
    80c4:	ef 01       	movw	r28, r30
    80c6:	c8 5e       	subi	r28, 0xE8	; 232
    80c8:	d1 4f       	sbci	r29, 0xF1	; 241
    80ca:	20 e0       	ldi	r18, 0x00	; 0
    80cc:	30 e0       	ldi	r19, 0x00	; 0
     char i,LengthID;
	 LengthID=strlen(strRFID);  //           +12345678  
	 for(i=0;i<20;i++){         //SSSSSSSSSSSS12345678
	    if (i<(20-LengthID))strCardID[i]=' ';
    80ce:	44 e1       	ldi	r20, 0x14	; 20
    80d0:	50 e0       	ldi	r21, 0x00	; 0
    80d2:	4e 1b       	sub	r20, r30
    80d4:	5f 0b       	sbc	r21, r31
    80d6:	90 e2       	ldi	r25, 0x20	; 32
    80d8:	24 17       	cp	r18, r20
    80da:	35 07       	cpc	r19, r21
    80dc:	14 f4       	brge	.+4      	; 0x80e2 <UpdateCardID+0x38>
    80de:	9c 93       	st	X, r25
    80e0:	02 c0       	rjmp	.+4      	; 0x80e6 <UpdateCardID+0x3c>
		else strCardID[i]=strRFID[i-(20-LengthID)];
    80e2:	88 81       	ld	r24, Y
    80e4:	8c 93       	st	X, r24
    80e6:	2f 5f       	subi	r18, 0xFF	; 255
    80e8:	3f 4f       	sbci	r19, 0xFF	; 255
    80ea:	11 96       	adiw	r26, 0x01	; 1
    80ec:	21 96       	adiw	r28, 0x01	; 1


void UpdateCardID(){
     char i,LengthID;
	 LengthID=strlen(strRFID);  //           +12345678  
	 for(i=0;i<20;i++){         //SSSSSSSSSSSS12345678
    80ee:	24 31       	cpi	r18, 0x14	; 20
    80f0:	31 05       	cpc	r19, r1
    80f2:	91 f7       	brne	.-28     	; 0x80d8 <UpdateCardID+0x2e>
	    if (i<(20-LengthID))strCardID[i]=' ';
		else strCardID[i]=strRFID[i-(20-LengthID)];
	 }strCardID[20]=0;
    80f4:	10 92 75 0d 	sts	0x0D75, r1

}
    80f8:	df 91       	pop	r29
    80fa:	cf 91       	pop	r28
    80fc:	08 95       	ret

000080fe <GenerateTransactionNum>:
		 //else Result=PS_NO_DATA;    		    
	 }	
   return Result;
}

void GenerateTransactionNum(char *sTransNumber){//Create and Save TransactionNumber to EEPROM
    80fe:	cf 92       	push	r12
    8100:	df 92       	push	r13
    8102:	ef 92       	push	r14
    8104:	ff 92       	push	r15
    8106:	0f 93       	push	r16
    8108:	1f 93       	push	r17
    810a:	df 93       	push	r29
    810c:	cf 93       	push	r28
    810e:	cd b7       	in	r28, 0x3d	; 61
    8110:	de b7       	in	r29, 0x3e	; 62
    8112:	27 97       	sbiw	r28, 0x07	; 7
    8114:	0f b6       	in	r0, 0x3f	; 63
    8116:	f8 94       	cli
    8118:	de bf       	out	0x3e, r29	; 62
    811a:	0f be       	out	0x3f, r0	; 63
    811c:	cd bf       	out	0x3d, r28	; 61
    811e:	6c 01       	movw	r12, r24
    8120:	fe 01       	movw	r30, r28
    8122:	31 96       	adiw	r30, 0x01	; 1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    8124:	ce 01       	movw	r24, r28
    8126:	08 96       	adiw	r24, 0x08	; 8
	     strMemory[i]=data;
    8128:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    812a:	e8 17       	cp	r30, r24
    812c:	f9 07       	cpc	r31, r25
    812e:	e1 f7       	brne	.-8      	; 0x8128 <GenerateTransactionNum+0x2a>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    8130:	8e 01       	movw	r16, r28
    8132:	0f 5f       	subi	r16, 0xFF	; 255
    8134:	1f 4f       	sbci	r17, 0xFF	; 255
    8136:	c8 01       	movw	r24, r16
    8138:	68 e3       	ldi	r22, 0x38	; 56
    813a:	71 e0       	ldi	r23, 0x01	; 1
    813c:	47 e0       	ldi	r20, 0x07	; 7
    813e:	50 e0       	ldi	r21, 0x00	; 0
    8140:	26 ef       	ldi	r18, 0xF6	; 246
    8142:	32 e1       	ldi	r19, 0x12	; 18
    8144:	0e 94 7a b5 	call	0x16af4	; 0x16af4 <__eerd_block>
     char i,PTransNum[7],cNum,xNum=0,xAdd=0,Length=0;
	 FillChar(PTransNum,sizeof(PTransNum),0);//"999999"->"000000"
     eeprom_read_block((void*) &PTransNum, (const void*) &DefTransactionNumber,sizeof(DefTransactionNumber));
     xAdd=1;
	 xNum=0;
	 Length=strlen(PTransNum);
    8148:	f8 01       	movw	r30, r16
    814a:	01 90       	ld	r0, Z+
    814c:	00 20       	and	r0, r0
    814e:	e9 f7       	brne	.-6      	; 0x814a <GenerateTransactionNum+0x4c>
    8150:	31 97       	sbiw	r30, 0x01	; 1
    8152:	e0 1b       	sub	r30, r16
		 //else Result=PS_NO_DATA;    		    
	 }	
   return Result;
}

void GenerateTransactionNum(char *sTransNumber){//Create and Save TransactionNumber to EEPROM
    8154:	f0 e0       	ldi	r31, 0x00	; 0
    8156:	0e 0f       	add	r16, r30
    8158:	1f 1f       	adc	r17, r31
    815a:	31 97       	sbiw	r30, 0x01	; 1
    815c:	76 01       	movw	r14, r12
    815e:	ee 0e       	add	r14, r30
    8160:	ff 1e       	adc	r15, r31
    8162:	31 96       	adiw	r30, 0x01	; 1
    8164:	61 e0       	ldi	r22, 0x01	; 1
    8166:	19 c0       	rjmp	.+50     	; 0x819a <GenerateTransactionNum+0x9c>
	 xNum=0;
	 Length=strlen(PTransNum);

	 for(i=0;i<Length;i++){//[000009] 999999 123456
	     xNum=PTransNum[Length-i-1]-'0';		 
		 cNum='0'+((xNum+xAdd)%10);
    8168:	d8 01       	movw	r26, r16
    816a:	2c 91       	ld	r18, X
    816c:	20 53       	subi	r18, 0x30	; 48
    816e:	30 e0       	ldi	r19, 0x00	; 0
    8170:	26 0f       	add	r18, r22
    8172:	31 1d       	adc	r19, r1
    8174:	c9 01       	movw	r24, r18
    8176:	6a e0       	ldi	r22, 0x0A	; 10
    8178:	70 e0       	ldi	r23, 0x00	; 0
    817a:	0e 94 a7 b8 	call	0x1714e	; 0x1714e <__divmodhi4>
    817e:	48 2f       	mov	r20, r24
    8180:	40 5d       	subi	r20, 0xD0	; 208
		 xAdd=((xNum+xAdd)/10);
    8182:	c9 01       	movw	r24, r18
    8184:	6a e0       	ldi	r22, 0x0A	; 10
    8186:	70 e0       	ldi	r23, 0x00	; 0
    8188:	0e 94 a7 b8 	call	0x1714e	; 0x1714e <__divmodhi4>
		 PTransNum[Length-i-1]=cNum;
    818c:	d8 01       	movw	r26, r16
    818e:	4c 93       	st	X, r20
		 sTransNumber[Length-i-1]=cNum;
    8190:	d7 01       	movw	r26, r14
    8192:	4c 93       	st	X, r20
    8194:	08 94       	sec
    8196:	e1 08       	sbc	r14, r1
    8198:	f1 08       	sbc	r15, r1
    819a:	01 50       	subi	r16, 0x01	; 1
    819c:	10 40       	sbci	r17, 0x00	; 0
     eeprom_read_block((void*) &PTransNum, (const void*) &DefTransactionNumber,sizeof(DefTransactionNumber));
     xAdd=1;
	 xNum=0;
	 Length=strlen(PTransNum);

	 for(i=0;i<Length;i++){//[000009] 999999 123456
    819e:	0c 17       	cp	r16, r28
    81a0:	1d 07       	cpc	r17, r29
    81a2:	11 f7       	brne	.-60     	; 0x8168 <GenerateTransactionNum+0x6a>
		 cNum='0'+((xNum+xAdd)%10);
		 xAdd=((xNum+xAdd)/10);
		 PTransNum[Length-i-1]=cNum;
		 sTransNumber[Length-i-1]=cNum;
	 }
	 sTransNumber[Length]=0;
    81a4:	ce 0e       	add	r12, r30
    81a6:	df 1e       	adc	r13, r31
    81a8:	d6 01       	movw	r26, r12
    81aa:	1c 92       	st	X, r1
	 PTransNum[Length]=0;
    81ac:	be 01       	movw	r22, r28
    81ae:	6f 5f       	subi	r22, 0xFF	; 255
    81b0:	7f 4f       	sbci	r23, 0xFF	; 255
    81b2:	e6 0f       	add	r30, r22
    81b4:	f7 1f       	adc	r31, r23
    81b6:	10 82       	st	Z, r1
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    81b8:	88 e3       	ldi	r24, 0x38	; 56
    81ba:	91 e0       	ldi	r25, 0x01	; 1
    81bc:	47 e0       	ldi	r20, 0x07	; 7
    81be:	50 e0       	ldi	r21, 0x00	; 0
    81c0:	2e ef       	ldi	r18, 0xFE	; 254
    81c2:	32 e1       	ldi	r19, 0x12	; 18
    81c4:	0e 94 96 b5 	call	0x16b2c	; 0x16b2c <__eewr_block>

     eeprom_write_block((const void*)&PTransNum,(void*)&DefTransactionNumber,sizeof(DefTransactionNumber));
}
    81c8:	27 96       	adiw	r28, 0x07	; 7
    81ca:	0f b6       	in	r0, 0x3f	; 63
    81cc:	f8 94       	cli
    81ce:	de bf       	out	0x3e, r29	; 62
    81d0:	0f be       	out	0x3f, r0	; 63
    81d2:	cd bf       	out	0x3d, r28	; 61
    81d4:	cf 91       	pop	r28
    81d6:	df 91       	pop	r29
    81d8:	1f 91       	pop	r17
    81da:	0f 91       	pop	r16
    81dc:	ff 90       	pop	r15
    81de:	ef 90       	pop	r14
    81e0:	df 90       	pop	r13
    81e2:	cf 90       	pop	r12
    81e4:	08 95       	ret

000081e6 <GetParameter>:
	}
  return  PosFound;
}


void GetParameter(char *GFlow,char FLength,char *GCmd,char *GPumpID, char *GeniCSum){
    81e6:	8f 92       	push	r8
    81e8:	9f 92       	push	r9
    81ea:	af 92       	push	r10
    81ec:	bf 92       	push	r11
    81ee:	cf 92       	push	r12
    81f0:	df 92       	push	r13
    81f2:	ef 92       	push	r14
    81f4:	ff 92       	push	r15
    81f6:	0f 93       	push	r16
    81f8:	1f 93       	push	r17
    81fa:	df 93       	push	r29
    81fc:	cf 93       	push	r28
    81fe:	cd b7       	in	r28, 0x3d	; 61
    8200:	de b7       	in	r29, 0x3e	; 62
    8202:	a7 97       	sbiw	r28, 0x27	; 39
    8204:	0f b6       	in	r0, 0x3f	; 63
    8206:	f8 94       	cli
    8208:	de bf       	out	0x3e, r29	; 62
    820a:	0f be       	out	0x3f, r0	; 63
    820c:	cd bf       	out	0x3d, r28	; 61
    820e:	79 01       	movw	r14, r18
    8210:	48 01       	movw	r8, r16
    8212:	e6 2f       	mov	r30, r22
    8214:	f0 e0       	ldi	r31, 0x00	; 0
    8216:	31 97       	sbiw	r30, 0x01	; 1
    8218:	e8 0f       	add	r30, r24
    821a:	f9 1f       	adc	r31, r25
    821c:	9e 01       	movw	r18, r28
    821e:	26 5f       	subi	r18, 0xF6	; 246
    8220:	3f 4f       	sbci	r19, 0xFF	; 255
    8222:	d9 01       	movw	r26, r18
    8224:	03 c0       	rjmp	.+6      	; 0x822c <GetParameter+0x46>
char strSend[20],strSub[3];
int SumLength;

     //TransposeFlow
     for (i=0;i<FLength;i++){	 
	     SGeniusFlow[i]=GFlow[FLength-i-1];
    8226:	80 81       	ld	r24, Z
    8228:	8d 93       	st	X+, r24
    822a:	31 97       	sbiw	r30, 0x01	; 1
char SGeniusFlow[30];
char strSend[20],strSub[3];
int SumLength;

     //TransposeFlow
     for (i=0;i<FLength;i++){	 
    822c:	8a 2f       	mov	r24, r26
    822e:	82 1b       	sub	r24, r18
    8230:	86 17       	cp	r24, r22
    8232:	c8 f3       	brcs	.-14     	; 0x8226 <GetParameter+0x40>
	     SGeniusFlow[i]=GFlow[FLength-i-1];
	 }SGeniusFlow[FLength]=0;
    8234:	c6 2e       	mov	r12, r22
    8236:	dd 24       	eor	r13, r13
    8238:	ea e0       	ldi	r30, 0x0A	; 10
    823a:	ae 2e       	mov	r10, r30
    823c:	b1 2c       	mov	r11, r1
    823e:	ac 0e       	add	r10, r28
    8240:	bd 1e       	adc	r11, r29
    8242:	f5 01       	movw	r30, r10
    8244:	ec 0d       	add	r30, r12
    8246:	fd 1d       	adc	r31, r13
    8248:	10 82       	st	Z, r1

	 xCmd=CharPosCopy(SGeniusFlow,0);
	 *GCmd=xCmd;
    824a:	8a 85       	ldd	r24, Y+10	; 0x0a
    824c:	fa 01       	movw	r30, r20
    824e:	80 83       	st	Z, r24
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8250:	8b 85       	ldd	r24, Y+11	; 0x0b
    8252:	89 83       	std	Y+1, r24	; 0x01
    8254:	8c 85       	ldd	r24, Y+12	; 0x0c
    8256:	8a 83       	std	Y+2, r24	; 0x02
	 }Dest[Length]=0;
    8258:	1b 82       	std	Y+3, r1	; 0x03
	 }SGeniusFlow[FLength]=0;

	 xCmd=CharPosCopy(SGeniusFlow,0);
	 *GCmd=xCmd;
	 StrPosCopy(SGeniusFlow,sPumpID,1,2);
	 xPumpID=atoi(sPumpID);
    825a:	ce 01       	movw	r24, r28
    825c:	01 96       	adiw	r24, 0x01	; 1
    825e:	0e 94 45 b5 	call	0x16a8a	; 0x16a8a <atoi>
	 *GPumpID=xPumpID;
    8262:	f7 01       	movw	r30, r14
    8264:	80 83       	st	Z, r24
	 sprintf_P(strSub,PSTR(":"));
    8266:	00 d0       	rcall	.+0      	; 0x8268 <GetParameter+0x82>
    8268:	00 d0       	rcall	.+0      	; 0x826a <GetParameter+0x84>
    826a:	77 e0       	ldi	r23, 0x07	; 7
    826c:	e7 2e       	mov	r14, r23
    826e:	f1 2c       	mov	r15, r1
    8270:	ec 0e       	add	r14, r28
    8272:	fd 1e       	adc	r15, r29
    8274:	ed b7       	in	r30, 0x3d	; 61
    8276:	fe b7       	in	r31, 0x3e	; 62
    8278:	f2 82       	std	Z+2, r15	; 0x02
    827a:	e1 82       	std	Z+1, r14	; 0x01
    827c:	8e e7       	ldi	r24, 0x7E	; 126
    827e:	93 e0       	ldi	r25, 0x03	; 3
    8280:	94 83       	std	Z+4, r25	; 0x04
    8282:	83 83       	std	Z+3, r24	; 0x03
    8284:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
	 if (Pos(strSub,SGeniusFlow)<FLength){
    8288:	0f 90       	pop	r0
    828a:	0f 90       	pop	r0
    828c:	0f 90       	pop	r0
    828e:	0f 90       	pop	r0
    8290:	c7 01       	movw	r24, r14
    8292:	b5 01       	movw	r22, r10
    8294:	0e 94 52 22 	call	0x44a4	; 0x44a4 <Pos>
    8298:	8c 15       	cp	r24, r12
    829a:	9d 05       	cpc	r25, r13
    829c:	4c f5       	brge	.+82     	; 0x82f0 <GetParameter+0x10a>
	     SumLength=FLength-Pos(strSub,SGeniusFlow);
    829e:	c7 01       	movw	r24, r14
    82a0:	b5 01       	movw	r22, r10
    82a2:	0e 94 52 22 	call	0x44a4	; 0x44a4 <Pos>
    82a6:	8c 01       	movw	r16, r24
	 	 StrPosCopy(SGeniusFlow,sCSum,Pos(strSub,SGeniusFlow)+1,SumLength);
    82a8:	c7 01       	movw	r24, r14
    82aa:	b5 01       	movw	r22, r10
    82ac:	0e 94 52 22 	call	0x44a4	; 0x44a4 <Pos>
    82b0:	a6 01       	movw	r20, r12
    82b2:	40 1b       	sub	r20, r16
    82b4:	51 0b       	sbc	r21, r17
    82b6:	d5 01       	movw	r26, r10
    82b8:	a8 0f       	add	r26, r24
    82ba:	b9 1f       	adc	r27, r25
    82bc:	20 e0       	ldi	r18, 0x00	; 0
    82be:	30 e0       	ldi	r19, 0x00	; 0
    82c0:	be 01       	movw	r22, r28
    82c2:	6c 5f       	subi	r22, 0xFC	; 252
    82c4:	7f 4f       	sbci	r23, 0xFF	; 255
    82c6:	07 c0       	rjmp	.+14     	; 0x82d6 <GetParameter+0xf0>
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    82c8:	fb 01       	movw	r30, r22
    82ca:	e2 0f       	add	r30, r18
    82cc:	f3 1f       	adc	r31, r19
    82ce:	8c 91       	ld	r24, X
    82d0:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    82d2:	2f 5f       	subi	r18, 0xFF	; 255
    82d4:	3f 4f       	sbci	r19, 0xFF	; 255
    82d6:	11 96       	adiw	r26, 0x01	; 1
    82d8:	24 17       	cp	r18, r20
    82da:	35 07       	cpc	r19, r21
    82dc:	a8 f3       	brcs	.-22     	; 0x82c8 <GetParameter+0xe2>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    82de:	46 0f       	add	r20, r22
    82e0:	57 1f       	adc	r21, r23
    82e2:	fa 01       	movw	r30, r20
    82e4:	10 82       	st	Z, r1
	 *GPumpID=xPumpID;
	 sprintf_P(strSub,PSTR(":"));
	 if (Pos(strSub,SGeniusFlow)<FLength){
	     SumLength=FLength-Pos(strSub,SGeniusFlow);
	 	 StrPosCopy(SGeniusFlow,sCSum,Pos(strSub,SGeniusFlow)+1,SumLength);
		 xCsum=atoi(sCSum);
    82e6:	cb 01       	movw	r24, r22
    82e8:	0e 94 45 b5 	call	0x16a8a	; 0x16a8a <atoi>
	     *GeniCSum=xCsum;
    82ec:	f4 01       	movw	r30, r8
    82ee:	80 83       	st	Z, r24
	 sprintf_P(strSend,PSTR("%d"),xPumpID);
	 _uart_print(1,1,strSend);
	 sprintf_P(strSend,PSTR("%s"),sCSum);
	 _uart_print(1,1,strSend);
*/
}
    82f0:	a7 96       	adiw	r28, 0x27	; 39
    82f2:	0f b6       	in	r0, 0x3f	; 63
    82f4:	f8 94       	cli
    82f6:	de bf       	out	0x3e, r29	; 62
    82f8:	0f be       	out	0x3f, r0	; 63
    82fa:	cd bf       	out	0x3d, r28	; 61
    82fc:	cf 91       	pop	r28
    82fe:	df 91       	pop	r29
    8300:	1f 91       	pop	r17
    8302:	0f 91       	pop	r16
    8304:	ff 90       	pop	r15
    8306:	ef 90       	pop	r14
    8308:	df 90       	pop	r13
    830a:	cf 90       	pop	r12
    830c:	bf 90       	pop	r11
    830e:	af 90       	pop	r10
    8310:	9f 90       	pop	r9
    8312:	8f 90       	pop	r8
    8314:	08 95       	ret

00008316 <GeniusProtocol>:
   return Result;	 
}

//enum eGeniusProtocolCommand{GP_PUMP_STATUS,GP_PUMP_LAST_TRANSACTION,GP_PUMP_STOP,GP_PUMP_RESUME,GP_PUMP_PRESET};

void GeniusProtocol(char dataIn){
    8316:	ff 92       	push	r15
    8318:	0f 93       	push	r16
    831a:	1f 93       	push	r17
    831c:	df 93       	push	r29
    831e:	cf 93       	push	r28
    8320:	cd b7       	in	r28, 0x3d	; 61
    8322:	de b7       	in	r29, 0x3e	; 62
    8324:	67 97       	sbiw	r28, 0x17	; 23
    8326:	0f b6       	in	r0, 0x3f	; 63
    8328:	f8 94       	cli
    832a:	de bf       	out	0x3e, r29	; 62
    832c:	0f be       	out	0x3f, r0	; 63
    832e:	cd bf       	out	0x3d, r28	; 61
    8330:	f8 2e       	mov	r15, r24
	 char i,GeniCmd,GeniPumpID,GeniCSum;//,sCmd[7];
	 char strSend[20];

    //_uart(1,1,dataIn);

	if (dataIn==0x0D){	
    8332:	8d e0       	ldi	r24, 0x0D	; 13
    8334:	f8 16       	cp	r15, r24
    8336:	09 f0       	breq	.+2      	; 0x833a <GeniusProtocol+0x24>
    8338:	45 c0       	rjmp	.+138    	; 0x83c4 <GeniusProtocol+0xae>
	    GetParameter(Geniflow,FlowLength,&GeniCmd,&GeniPumpID,&GeniCSum);
    833a:	8f ed       	ldi	r24, 0xDF	; 223
    833c:	91 e0       	ldi	r25, 0x01	; 1
    833e:	60 91 de 01 	lds	r22, 0x01DE
    8342:	ae 01       	movw	r20, r28
    8344:	4f 5f       	subi	r20, 0xFF	; 255
    8346:	5f 4f       	sbci	r21, 0xFF	; 255
    8348:	9e 01       	movw	r18, r28
    834a:	2e 5f       	subi	r18, 0xFE	; 254
    834c:	3f 4f       	sbci	r19, 0xFF	; 255
    834e:	8e 01       	movw	r16, r28
    8350:	0d 5f       	subi	r16, 0xFD	; 253
    8352:	1f 4f       	sbci	r17, 0xFF	; 255
    8354:	0e 94 f3 40 	call	0x81e6	; 0x81e6 <GetParameter>
		FlowLength=0;
    8358:	10 92 de 01 	sts	0x01DE, r1
		IsGeniusFlow=False;
    835c:	10 92 dd 01 	sts	0x01DD, r1
		FillChar(strSend,0,sizeof(strSend));
		sprintf_P(strSend,PSTR("%c%.2d:"),GeniCmd,GeniPumpID);
    8360:	ad b7       	in	r26, 0x3d	; 61
    8362:	be b7       	in	r27, 0x3e	; 62
    8364:	18 97       	sbiw	r26, 0x08	; 8
    8366:	0f b6       	in	r0, 0x3f	; 63
    8368:	f8 94       	cli
    836a:	be bf       	out	0x3e, r27	; 62
    836c:	0f be       	out	0x3f, r0	; 63
    836e:	ad bf       	out	0x3d, r26	; 61
    8370:	ed b7       	in	r30, 0x3d	; 61
    8372:	fe b7       	in	r31, 0x3e	; 62
    8374:	31 96       	adiw	r30, 0x01	; 1
    8376:	8e 01       	movw	r16, r28
    8378:	0c 5f       	subi	r16, 0xFC	; 252
    837a:	1f 4f       	sbci	r17, 0xFF	; 255
    837c:	12 96       	adiw	r26, 0x02	; 2
    837e:	1c 93       	st	X, r17
    8380:	0e 93       	st	-X, r16
    8382:	11 97       	sbiw	r26, 0x01	; 1
    8384:	80 e7       	ldi	r24, 0x70	; 112
    8386:	93 e0       	ldi	r25, 0x03	; 3
    8388:	93 83       	std	Z+3, r25	; 0x03
    838a:	82 83       	std	Z+2, r24	; 0x02
    838c:	89 81       	ldd	r24, Y+1	; 0x01
    838e:	84 83       	std	Z+4, r24	; 0x04
    8390:	15 82       	std	Z+5, r1	; 0x05
    8392:	8a 81       	ldd	r24, Y+2	; 0x02
    8394:	86 83       	std	Z+6, r24	; 0x06
    8396:	17 82       	std	Z+7, r1	; 0x07
    8398:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
		//_uart_print(1,1,strSend);


		if ((SumChecksum(strSend))==GeniCSum){
    839c:	8d b7       	in	r24, 0x3d	; 61
    839e:	9e b7       	in	r25, 0x3e	; 62
    83a0:	08 96       	adiw	r24, 0x08	; 8
    83a2:	0f b6       	in	r0, 0x3f	; 63
    83a4:	f8 94       	cli
    83a6:	9e bf       	out	0x3e, r25	; 62
    83a8:	0f be       	out	0x3f, r0	; 63
    83aa:	8d bf       	out	0x3d, r24	; 61
    83ac:	c8 01       	movw	r24, r16
    83ae:	0e 94 ed 21 	call	0x43da	; 0x43da <SumChecksum>
    83b2:	9b 81       	ldd	r25, Y+3	; 0x03
    83b4:	89 17       	cp	r24, r25
    83b6:	31 f4       	brne	.+12     	; 0x83c4 <GeniusProtocol+0xae>
		     switch(GeniCmd){
    83b8:	89 81       	ldd	r24, Y+1	; 0x01
    83ba:	84 35       	cpi	r24, 0x54	; 84
    83bc:	19 f4       	brne	.+6      	; 0x83c4 <GeniusProtocol+0xae>
			 case 'C'://PumpStatus
			      GeniusSendPumpStatus(GeniPumpID);
			      break;
             case 'T'://Transaction Request: T01:239<0D>
			      GeniusSendLastTransaction(GeniPumpID);
    83be:	8a 81       	ldd	r24, Y+2	; 0x02
    83c0:	0e 94 c6 2e 	call	0x5d8c	; 0x5d8c <GeniusSendLastTransaction>
    83c4:	e1 ef       	ldi	r30, 0xF1	; 241
    83c6:	f1 e0       	ldi	r31, 0x01	; 1
			 }
		}
	}
	//Shifting
	for(i=19;i>0;i--){
	    Geniflow[i]=Geniflow[i-1];	
    83c8:	80 81       	ld	r24, Z
    83ca:	81 83       	std	Z+1, r24	; 0x01
    83cc:	31 97       	sbiw	r30, 0x01	; 1
			      break;
			 }
		}
	}
	//Shifting
	for(i=19;i>0;i--){
    83ce:	91 e0       	ldi	r25, 0x01	; 1
    83d0:	ee 3d       	cpi	r30, 0xDE	; 222
    83d2:	f9 07       	cpc	r31, r25
    83d4:	c9 f7       	brne	.-14     	; 0x83c8 <GeniusProtocol+0xb2>
	    Geniflow[i]=Geniflow[i-1];	
	}Geniflow[0]=dataIn;
    83d6:	f1 82       	std	Z+1, r15	; 0x01

	if (IsGeniusCommand(dataIn)==True)IsGeniusFlow=True;
    83d8:	8f 2d       	mov	r24, r15
    83da:	0e 94 0d 22 	call	0x441a	; 0x441a <IsGeniusCommand>
    83de:	81 30       	cpi	r24, 0x01	; 1
    83e0:	11 f4       	brne	.+4      	; 0x83e6 <GeniusProtocol+0xd0>
    83e2:	80 93 dd 01 	sts	0x01DD, r24
	if (IsGeniusFlow==True)FlowLength++;
    83e6:	80 91 dd 01 	lds	r24, 0x01DD
    83ea:	81 30       	cpi	r24, 0x01	; 1
    83ec:	29 f4       	brne	.+10     	; 0x83f8 <GeniusProtocol+0xe2>
    83ee:	80 91 de 01 	lds	r24, 0x01DE
    83f2:	8f 5f       	subi	r24, 0xFF	; 255
    83f4:	80 93 de 01 	sts	0x01DE, r24
	Geniflow[3]=Geniflow[2];
	Geniflow[2]=Geniflow[1];
	Geniflow[1]=Geniflow[0];
	Geniflow[0]=dataIn;
*/
}
    83f8:	67 96       	adiw	r28, 0x17	; 23
    83fa:	0f b6       	in	r0, 0x3f	; 63
    83fc:	f8 94       	cli
    83fe:	de bf       	out	0x3e, r29	; 62
    8400:	0f be       	out	0x3f, r0	; 63
    8402:	cd bf       	out	0x3d, r28	; 61
    8404:	cf 91       	pop	r28
    8406:	df 91       	pop	r29
    8408:	1f 91       	pop	r17
    840a:	0f 91       	pop	r16
    840c:	ff 90       	pop	r15
    840e:	08 95       	ret

00008410 <__vector_30>:
}

// NotSuccessful! 


ISR(USART1_RX_vect){
    8410:	1f 92       	push	r1
    8412:	0f 92       	push	r0
    8414:	0f b6       	in	r0, 0x3f	; 63
    8416:	0f 92       	push	r0
    8418:	0b b6       	in	r0, 0x3b	; 59
    841a:	0f 92       	push	r0
    841c:	11 24       	eor	r1, r1
    841e:	1f 93       	push	r17
    8420:	2f 93       	push	r18
    8422:	3f 93       	push	r19
    8424:	4f 93       	push	r20
    8426:	5f 93       	push	r21
    8428:	6f 93       	push	r22
    842a:	7f 93       	push	r23
    842c:	8f 93       	push	r24
    842e:	9f 93       	push	r25
    8430:	af 93       	push	r26
    8432:	bf 93       	push	r27
    8434:	ef 93       	push	r30
    8436:	ff 93       	push	r31
	char dataTX1,serialSend[12];
	static char IsAdvanZProtocol=False;
	unsigned int i;
	dataTX1 = UDR1;
    8438:	10 91 9c 00 	lds	r17, 0x009C

	//NewPacket
	if (IsNewPacket==True){
    843c:	80 91 9b 01 	lds	r24, 0x019B
    8440:	81 30       	cpi	r24, 0x01	; 1
    8442:	51 f4       	brne	.+20     	; 0x8458 <__vector_30+0x48>
	    if (dataTX1==0x01){
    8444:	11 30       	cpi	r17, 0x01	; 1
    8446:	41 f4       	brne	.+16     	; 0x8458 <__vector_30+0x48>
		    char_count=0;
    8448:	10 92 9d 01 	sts	0x019D, r1
    844c:	10 92 9c 01 	sts	0x019C, r1
            IsNewPacket=False;
    8450:	10 92 9b 01 	sts	0x019B, r1
			IsAdvanZProtocol=True;
    8454:	10 93 a5 03 	sts	0x03A5, r17
			}
	}
    //Save data to buffer if AdvanZ MSG
	if (IsAdvanZProtocol==True){
    8458:	80 91 a5 03 	lds	r24, 0x03A5
    845c:	81 30       	cpi	r24, 0x01	; 1
    845e:	69 f4       	brne	.+26     	; 0x847a <__vector_30+0x6a>
	    rcv_trans[char_count]=dataTX1;
    8460:	80 91 9c 01 	lds	r24, 0x019C
    8464:	90 91 9d 01 	lds	r25, 0x019D
    8468:	fc 01       	movw	r30, r24
    846a:	eb 50       	subi	r30, 0x0B	; 11
    846c:	f5 4f       	sbci	r31, 0xF5	; 245
    846e:	10 83       	st	Z, r17
	    char_count++; 
    8470:	01 96       	adiw	r24, 0x01	; 1
    8472:	90 93 9d 01 	sts	0x019D, r25
    8476:	80 93 9c 01 	sts	0x019C, r24
	}

	if (dataTX1==0x02){
    847a:	12 30       	cpi	r17, 0x02	; 2
    847c:	b1 f5       	brne	.+108    	; 0x84ea <__vector_30+0xda>
		transLength=char_count;
    847e:	60 91 9c 01 	lds	r22, 0x019C
    8482:	70 91 9d 01 	lds	r23, 0x019D
    8486:	70 93 9f 01 	sts	0x019F, r23
    848a:	60 93 9e 01 	sts	0x019E, r22
		char_count=0;
    848e:	10 92 9d 01 	sts	0x019D, r1
    8492:	10 92 9c 01 	sts	0x019C, r1
		IsAdvanZProtocol=False;
    8496:	10 92 a5 03 	sts	0x03A5, r1

		//MessageIdentification
        if (MsgCode!=MSG_NONE)MsgCode=MSG_NONE;
	    MsgCode=((rcv_trans[35]-'0')*10)+(rcv_trans[36]-'0');
    849a:	20 91 19 0b 	lds	r18, 0x0B19
    849e:	20 51       	subi	r18, 0x10	; 16
    84a0:	80 91 18 0b 	lds	r24, 0x0B18
    84a4:	3a e0       	ldi	r19, 0x0A	; 10
    84a6:	83 9f       	mul	r24, r19
    84a8:	c0 01       	movw	r24, r0
    84aa:	11 24       	eor	r1, r1
    84ac:	28 0f       	add	r18, r24
    84ae:	20 93 24 01 	sts	0x0124, r18
     
	    IdentifyMessage(rcv_trans[0],transLength);
    84b2:	80 91 f5 0a 	lds	r24, 0x0AF5
    84b6:	0e 94 f3 18 	call	0x31e6	; 0x31e6 <IdentifyMessage>
		IsNewPacket=True;
    84ba:	21 e0       	ldi	r18, 0x01	; 1
    84bc:	20 93 9b 01 	sts	0x019B, r18

		if ((rcv_trans[35]=='8')&&(rcv_trans[36]=='1')){
    84c0:	80 91 18 0b 	lds	r24, 0x0B18
    84c4:	88 33       	cpi	r24, 0x38	; 56
    84c6:	89 f4       	brne	.+34     	; 0x84ea <__vector_30+0xda>
    84c8:	80 91 19 0b 	lds	r24, 0x0B19
    84cc:	81 33       	cpi	r24, 0x31	; 49
    84ce:	69 f4       	brne	.+26     	; 0x84ea <__vector_30+0xda>
		   LengthMessage81=transLength-12-44;
    84d0:	80 91 9e 01 	lds	r24, 0x019E
    84d4:	90 91 9f 01 	lds	r25, 0x019F
    84d8:	c8 97       	sbiw	r24, 0x38	; 56
    84da:	90 93 a1 01 	sts	0x01A1, r25
    84de:	80 93 a0 01 	sts	0x01A0, r24
		   IsMessage81=True;
    84e2:	20 93 bd 01 	sts	0x01BD, r18
		   IsCompleteFilling=True;
    84e6:	20 93 c0 01 	sts	0x01C0, r18
		

	}//Endif(dataTX1==0x02)

	//ConfigDetection: iConf?<0D><0A>
	if (IsNewPacket!=True)ConfigProtocol(dataTX1);
    84ea:	80 91 9b 01 	lds	r24, 0x019B
    84ee:	81 30       	cpi	r24, 0x01	; 1
    84f0:	19 f0       	breq	.+6      	; 0x84f8 <__vector_30+0xe8>
    84f2:	81 2f       	mov	r24, r17
    84f4:	0e 94 e6 14 	call	0x29cc	; 0x29cc <ConfigProtocol>
	//GeniusDetection: [CMD][MSG][CSUM][0x0D]
	if ((IFType==IT_STANDALONE)&&(IsNewPacket!=True))GeniusProtocol(dataTX1);		
    84f8:	80 91 10 01 	lds	r24, 0x0110
    84fc:	82 30       	cpi	r24, 0x02	; 2
    84fe:	39 f4       	brne	.+14     	; 0x850e <__vector_30+0xfe>
    8500:	80 91 9b 01 	lds	r24, 0x019B
    8504:	81 30       	cpi	r24, 0x01	; 1
    8506:	19 f0       	breq	.+6      	; 0x850e <__vector_30+0xfe>
    8508:	81 2f       	mov	r24, r17
    850a:	0e 94 8b 41 	call	0x8316	; 0x8316 <GeniusProtocol>
    //_uart(0,1,dataTX1);
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}
    850e:	ff 91       	pop	r31
    8510:	ef 91       	pop	r30
    8512:	bf 91       	pop	r27
    8514:	af 91       	pop	r26
    8516:	9f 91       	pop	r25
    8518:	8f 91       	pop	r24
    851a:	7f 91       	pop	r23
    851c:	6f 91       	pop	r22
    851e:	5f 91       	pop	r21
    8520:	4f 91       	pop	r20
    8522:	3f 91       	pop	r19
    8524:	2f 91       	pop	r18
    8526:	1f 91       	pop	r17
    8528:	0f 90       	pop	r0
    852a:	0b be       	out	0x3b, r0	; 59
    852c:	0f 90       	pop	r0
    852e:	0f be       	out	0x3f, r0	; 63
    8530:	0f 90       	pop	r0
    8532:	1f 90       	pop	r1
    8534:	18 95       	reti

00008536 <procMessage99>:
     StrPosCopy(rcv_trans,strAmount,74,8); 
	 StrPosCopy(rcv_trans,strStatus,82,1);
     StrPosCopy(rcv_trans,strSurcharge,83,9);    
}

char procMessage99(){//<STX>[IFT IDSeq N Srce IPDest IPMsg CodeTran NoShiftDateTimeIsland IDFIP IDProduct IDDescriptionPriceVolumeAmountMOP TypeMOP NameCard IDCard HolderBalance Type Balance MeterVolume MeterAmount Current TimePrint Count Checksum ETX
    8536:	0f 93       	push	r16
    8538:	1f 93       	push	r17
     char Result;
	 Result=MSG99_NONE;
	 //Message99
	 if((rcv_trans[0]==0x01)&&(transLength>=378)){
    853a:	80 91 f5 0a 	lds	r24, 0x0AF5
    853e:	81 30       	cpi	r24, 0x01	; 1
    8540:	09 f0       	breq	.+2      	; 0x8544 <procMessage99+0xe>
    8542:	2e c2       	rjmp	.+1116   	; 0x89a0 <procMessage99+0x46a>
    8544:	80 91 9e 01 	lds	r24, 0x019E
    8548:	90 91 9f 01 	lds	r25, 0x019F
    854c:	8a 57       	subi	r24, 0x7A	; 122
    854e:	91 40       	sbci	r25, 0x01	; 1
    8550:	08 f4       	brcc	.+2      	; 0x8554 <procMessage99+0x1e>
    8552:	26 c2       	rjmp	.+1100   	; 0x89a0 <procMessage99+0x46a>
    8554:	20 e0       	ldi	r18, 0x00	; 0
    8556:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8558:	f9 01       	movw	r30, r18
    855a:	ef 59       	subi	r30, 0x9F	; 159
    855c:	f1 4f       	sbci	r31, 0xF1	; 241
    855e:	d9 01       	movw	r26, r18
    8560:	ab 50       	subi	r26, 0x0B	; 11
    8562:	b5 4f       	sbci	r27, 0xF5	; 245
    8564:	95 96       	adiw	r26, 0x25	; 37
    8566:	8c 91       	ld	r24, X
    8568:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    856a:	2f 5f       	subi	r18, 0xFF	; 255
    856c:	3f 4f       	sbci	r19, 0xFF	; 255
    856e:	26 30       	cpi	r18, 0x06	; 6
    8570:	31 05       	cpc	r19, r1
    8572:	91 f7       	brne	.-28     	; 0x8558 <procMessage99+0x22>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8574:	10 92 67 0e 	sts	0x0E67, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8578:	80 91 20 0b 	lds	r24, 0x0B20
    857c:	80 93 43 0e 	sts	0x0E43, r24
	 }Dest[Length]=0;
    8580:	10 92 44 0e 	sts	0x0E44, r1
	 Result=MSG99_NONE;
	 //Message99
	 if((rcv_trans[0]==0x01)&&(transLength>=378)){
       StrPosCopy(rcv_trans,strTranNo,37,6);//Transaction Number
       StrPosCopy(rcv_trans,strShift,43,1);
       Shift=(CharPosCopy(rcv_trans,43)-'0');
    8584:	80 53       	subi	r24, 0x30	; 48
    8586:	80 93 d0 01 	sts	0x01D0, r24
    858a:	20 e0       	ldi	r18, 0x00	; 0
    858c:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    858e:	f9 01       	movw	r30, r18
    8590:	ef 5a       	subi	r30, 0xAF	; 175
    8592:	f6 4f       	sbci	r31, 0xF6	; 246
    8594:	d9 01       	movw	r26, r18
    8596:	ab 50       	subi	r26, 0x0B	; 11
    8598:	b5 4f       	sbci	r27, 0xF5	; 245
    859a:	9c 96       	adiw	r26, 0x2c	; 44
    859c:	8c 91       	ld	r24, X
    859e:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    85a0:	2f 5f       	subi	r18, 0xFF	; 255
    85a2:	3f 4f       	sbci	r19, 0xFF	; 255
    85a4:	2a 30       	cpi	r18, 0x0A	; 10
    85a6:	31 05       	cpc	r19, r1
    85a8:	91 f7       	brne	.-28     	; 0x858e <procMessage99+0x58>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    85aa:	10 92 5b 09 	sts	0x095B, r1
    85ae:	20 e0       	ldi	r18, 0x00	; 0
    85b0:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    85b2:	f9 01       	movw	r30, r18
    85b4:	e3 5d       	subi	r30, 0xD3	; 211
    85b6:	fa 4f       	sbci	r31, 0xFA	; 250
    85b8:	d9 01       	movw	r26, r18
    85ba:	ab 50       	subi	r26, 0x0B	; 11
    85bc:	b5 4f       	sbci	r27, 0xF5	; 245
    85be:	d6 96       	adiw	r26, 0x36	; 54
    85c0:	8c 91       	ld	r24, X
    85c2:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    85c4:	2f 5f       	subi	r18, 0xFF	; 255
    85c6:	3f 4f       	sbci	r19, 0xFF	; 255
    85c8:	28 30       	cpi	r18, 0x08	; 8
    85ca:	31 05       	cpc	r19, r1
    85cc:	91 f7       	brne	.-28     	; 0x85b2 <procMessage99+0x7c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    85ce:	10 92 35 05 	sts	0x0535, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    85d2:	80 91 33 0b 	lds	r24, 0x0B33
    85d6:	80 93 cf 0a 	sts	0x0ACF, r24
    85da:	80 91 34 0b 	lds	r24, 0x0B34
    85de:	80 93 d0 0a 	sts	0x0AD0, r24
	 }Dest[Length]=0;
    85e2:	10 92 d1 0a 	sts	0x0AD1, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    85e6:	80 91 35 0b 	lds	r24, 0x0B35
    85ea:	80 93 9c 09 	sts	0x099C, r24
    85ee:	80 91 36 0b 	lds	r24, 0x0B36
    85f2:	80 93 9d 09 	sts	0x099D, r24
	 }Dest[Length]=0;
    85f6:	10 92 9e 09 	sts	0x099E, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    85fa:	80 91 37 0b 	lds	r24, 0x0B37
    85fe:	80 93 76 0a 	sts	0x0A76, r24
    8602:	80 91 38 0b 	lds	r24, 0x0B38
    8606:	80 93 77 0a 	sts	0x0A77, r24
	 }Dest[Length]=0;
    860a:	10 92 78 0a 	sts	0x0A78, r1
    860e:	20 e0       	ldi	r18, 0x00	; 0
    8610:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8612:	f9 01       	movw	r30, r18
    8614:	ef 5e       	subi	r30, 0xEF	; 239
    8616:	f5 4f       	sbci	r31, 0xF5	; 245
    8618:	d9 01       	movw	r26, r18
    861a:	a7 5c       	subi	r26, 0xC7	; 199
    861c:	b4 4f       	sbci	r27, 0xF4	; 244
    861e:	8c 91       	ld	r24, X
    8620:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8622:	2f 5f       	subi	r18, 0xFF	; 255
    8624:	3f 4f       	sbci	r19, 0xFF	; 255
    8626:	2f 30       	cpi	r18, 0x0F	; 15
    8628:	31 05       	cpc	r19, r1
    862a:	99 f7       	brne	.-26     	; 0x8612 <procMessage99+0xdc>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    862c:	10 92 20 0a 	sts	0x0A20, r1
    8630:	20 e0       	ldi	r18, 0x00	; 0
    8632:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8634:	f9 01       	movw	r30, r18
    8636:	ef 57       	subi	r30, 0x7F	; 127
    8638:	f8 4f       	sbci	r31, 0xF8	; 248
    863a:	d9 01       	movw	r26, r18
    863c:	a8 5b       	subi	r26, 0xB8	; 184
    863e:	b4 4f       	sbci	r27, 0xF4	; 244
    8640:	8c 91       	ld	r24, X
    8642:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8644:	2f 5f       	subi	r18, 0xFF	; 255
    8646:	3f 4f       	sbci	r19, 0xFF	; 255
    8648:	28 30       	cpi	r18, 0x08	; 8
    864a:	31 05       	cpc	r19, r1
    864c:	99 f7       	brne	.-26     	; 0x8634 <procMessage99+0xfe>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    864e:	10 92 89 07 	sts	0x0789, r1
    8652:	20 e0       	ldi	r18, 0x00	; 0
    8654:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8656:	f9 01       	movw	r30, r18
    8658:	eb 5a       	subi	r30, 0xAB	; 171
    865a:	fa 4f       	sbci	r31, 0xFA	; 250
    865c:	d9 01       	movw	r26, r18
    865e:	a0 5b       	subi	r26, 0xB0	; 176
    8660:	b4 4f       	sbci	r27, 0xF4	; 244
    8662:	8c 91       	ld	r24, X
    8664:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8666:	2f 5f       	subi	r18, 0xFF	; 255
    8668:	3f 4f       	sbci	r19, 0xFF	; 255
    866a:	28 30       	cpi	r18, 0x08	; 8
    866c:	31 05       	cpc	r19, r1
    866e:	99 f7       	brne	.-26     	; 0x8656 <procMessage99+0x120>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8670:	10 92 5d 05 	sts	0x055D, r1
    8674:	20 e0       	ldi	r18, 0x00	; 0
    8676:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8678:	f9 01       	movw	r30, r18
    867a:	e5 57       	subi	r30, 0x75	; 117
    867c:	f2 4f       	sbci	r31, 0xF2	; 242
    867e:	d9 01       	movw	r26, r18
    8680:	a8 5a       	subi	r26, 0xA8	; 168
    8682:	b4 4f       	sbci	r27, 0xF4	; 244
    8684:	8c 91       	ld	r24, X
    8686:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8688:	2f 5f       	subi	r18, 0xFF	; 255
    868a:	3f 4f       	sbci	r19, 0xFF	; 255
    868c:	2a 30       	cpi	r18, 0x0A	; 10
    868e:	31 05       	cpc	r19, r1
    8690:	99 f7       	brne	.-26     	; 0x8678 <procMessage99+0x142>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8692:	10 92 95 0d 	sts	0x0D95, r1

	   //FillChar(strAmount,sizeof(strAmount),0);
       StrPosCopy(rcv_trans,strAmount,99,10);

       //StrPosCopy(rcv_trans,strMOPType,109,1);
       MOPType=(CharPosCopy(rcv_trans,109)-'0');
    8696:	80 91 62 0b 	lds	r24, 0x0B62
    869a:	80 53       	subi	r24, 0x30	; 48
    869c:	80 93 cf 01 	sts	0x01CF, r24
    86a0:	20 e0       	ldi	r18, 0x00	; 0
    86a2:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    86a4:	f9 01       	movw	r30, r18
    86a6:	e0 5a       	subi	r30, 0xA0	; 160
    86a8:	f8 4f       	sbci	r31, 0xF8	; 248
    86aa:	d9 01       	movw	r26, r18
    86ac:	ad 59       	subi	r26, 0x9D	; 157
    86ae:	b4 4f       	sbci	r27, 0xF4	; 244
    86b0:	8c 91       	ld	r24, X
    86b2:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    86b4:	2f 5f       	subi	r18, 0xFF	; 255
    86b6:	3f 4f       	sbci	r19, 0xFF	; 255
    86b8:	24 31       	cpi	r18, 0x14	; 20
    86ba:	31 05       	cpc	r19, r1
    86bc:	99 f7       	brne	.-26     	; 0x86a4 <procMessage99+0x16e>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    86be:	10 92 74 07 	sts	0x0774, r1
    86c2:	20 e0       	ldi	r18, 0x00	; 0
    86c4:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    86c6:	f9 01       	movw	r30, r18
    86c8:	ef 59       	subi	r30, 0x9F	; 159
    86ca:	f2 4f       	sbci	r31, 0xF2	; 242
    86cc:	d9 01       	movw	r26, r18
    86ce:	a9 58       	subi	r26, 0x89	; 137
    86d0:	b4 4f       	sbci	r27, 0xF4	; 244
    86d2:	8c 91       	ld	r24, X
    86d4:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    86d6:	2f 5f       	subi	r18, 0xFF	; 255
    86d8:	3f 4f       	sbci	r19, 0xFF	; 255
    86da:	24 31       	cpi	r18, 0x14	; 20
    86dc:	31 05       	cpc	r19, r1
    86de:	99 f7       	brne	.-26     	; 0x86c6 <procMessage99+0x190>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    86e0:	10 92 75 0d 	sts	0x0D75, r1
    86e4:	20 e0       	ldi	r18, 0x00	; 0
    86e6:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    86e8:	f9 01       	movw	r30, r18
    86ea:	ec 5f       	subi	r30, 0xFC	; 252
    86ec:	fa 4f       	sbci	r31, 0xFA	; 250
    86ee:	d9 01       	movw	r26, r18
    86f0:	a5 57       	subi	r26, 0x75	; 117
    86f2:	b4 4f       	sbci	r27, 0xF4	; 244
    86f4:	8c 91       	ld	r24, X
    86f6:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    86f8:	2f 5f       	subi	r18, 0xFF	; 255
    86fa:	3f 4f       	sbci	r19, 0xFF	; 255
    86fc:	28 32       	cpi	r18, 0x28	; 40
    86fe:	31 05       	cpc	r19, r1
    8700:	99 f7       	brne	.-26     	; 0x86e8 <procMessage99+0x1b2>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8702:	10 92 2c 05 	sts	0x052C, r1
    8706:	20 e0       	ldi	r18, 0x00	; 0
    8708:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    870a:	f9 01       	movw	r30, r18
    870c:	e5 5c       	subi	r30, 0xC5	; 197
    870e:	fa 4f       	sbci	r31, 0xFA	; 250
    8710:	d9 01       	movw	r26, r18
    8712:	ad 54       	subi	r26, 0x4D	; 77
    8714:	b4 4f       	sbci	r27, 0xF4	; 244
    8716:	8c 91       	ld	r24, X
    8718:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    871a:	2f 5f       	subi	r18, 0xFF	; 255
    871c:	3f 4f       	sbci	r19, 0xFF	; 255
    871e:	29 31       	cpi	r18, 0x19	; 25
    8720:	31 05       	cpc	r19, r1
    8722:	99 f7       	brne	.-26     	; 0x870a <procMessage99+0x1d4>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8724:	10 92 54 05 	sts	0x0554, r1
    8728:	20 e0       	ldi	r18, 0x00	; 0
    872a:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    872c:	f9 01       	movw	r30, r18
    872e:	ed 52       	subi	r30, 0x2D	; 45
    8730:	f2 4f       	sbci	r31, 0xF2	; 242
    8732:	d9 01       	movw	r26, r18
    8734:	a4 53       	subi	r26, 0x34	; 52
    8736:	b4 4f       	sbci	r27, 0xF4	; 244
    8738:	8c 91       	ld	r24, X
    873a:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    873c:	2f 5f       	subi	r18, 0xFF	; 255
    873e:	3f 4f       	sbci	r19, 0xFF	; 255
    8740:	2d 30       	cpi	r18, 0x0D	; 13
    8742:	31 05       	cpc	r19, r1
    8744:	99 f7       	brne	.-26     	; 0x872c <procMessage99+0x1f6>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8746:	10 92 e0 0d 	sts	0x0DE0, r1
    874a:	20 e0       	ldi	r18, 0x00	; 0
    874c:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    874e:	f9 01       	movw	r30, r18
    8750:	e4 59       	subi	r30, 0x94	; 148
    8752:	fa 4f       	sbci	r31, 0xFA	; 250
    8754:	d9 01       	movw	r26, r18
    8756:	a7 52       	subi	r26, 0x27	; 39
    8758:	b4 4f       	sbci	r27, 0xF4	; 244
    875a:	8c 91       	ld	r24, X
    875c:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    875e:	2f 5f       	subi	r18, 0xFF	; 255
    8760:	3f 4f       	sbci	r19, 0xFF	; 255
    8762:	2d 30       	cpi	r18, 0x0D	; 13
    8764:	31 05       	cpc	r19, r1
    8766:	99 f7       	brne	.-26     	; 0x874e <procMessage99+0x218>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8768:	10 92 79 05 	sts	0x0579, r1
    876c:	20 e0       	ldi	r18, 0x00	; 0
    876e:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8770:	f9 01       	movw	r30, r18
    8772:	ef 53       	subi	r30, 0x3F	; 63
    8774:	f5 4f       	sbci	r31, 0xF5	; 245
    8776:	d9 01       	movw	r26, r18
    8778:	aa 51       	subi	r26, 0x1A	; 26
    877a:	b4 4f       	sbci	r27, 0xF4	; 244
    877c:	8c 91       	ld	r24, X
    877e:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8780:	2f 5f       	subi	r18, 0xFF	; 255
    8782:	3f 4f       	sbci	r19, 0xFF	; 255
    8784:	2d 30       	cpi	r18, 0x0D	; 13
    8786:	31 05       	cpc	r19, r1
    8788:	99 f7       	brne	.-26     	; 0x8770 <procMessage99+0x23a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    878a:	10 92 ce 0a 	sts	0x0ACE, r1
    878e:	20 e0       	ldi	r18, 0x00	; 0
    8790:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8792:	f9 01       	movw	r30, r18
    8794:	e1 56       	subi	r30, 0x61	; 97
    8796:	f6 4f       	sbci	r31, 0xF6	; 246
    8798:	d9 01       	movw	r26, r18
    879a:	ad 50       	subi	r26, 0x0D	; 13
    879c:	b4 4f       	sbci	r27, 0xF4	; 244
    879e:	8c 91       	ld	r24, X
    87a0:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    87a2:	2f 5f       	subi	r18, 0xFF	; 255
    87a4:	3f 4f       	sbci	r19, 0xFF	; 255
    87a6:	23 31       	cpi	r18, 0x13	; 19
    87a8:	31 05       	cpc	r19, r1
    87aa:	99 f7       	brne	.-26     	; 0x8792 <procMessage99+0x25c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    87ac:	10 92 b2 09 	sts	0x09B2, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    87b0:	80 91 06 0c 	lds	r24, 0x0C06
    87b4:	80 93 5e 0e 	sts	0x0E5E, r24
    87b8:	80 91 07 0c 	lds	r24, 0x0C07
    87bc:	80 93 5f 0e 	sts	0x0E5F, r24
	 }Dest[Length]=0;
    87c0:	10 92 60 0e 	sts	0x0E60, r1
    87c4:	20 e0       	ldi	r18, 0x00	; 0
    87c6:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    87c8:	f9 01       	movw	r30, r18
    87ca:	e4 51       	subi	r30, 0x14	; 20
    87cc:	f5 4f       	sbci	r31, 0xF5	; 245
    87ce:	d9 01       	movw	r26, r18
    87d0:	a8 5f       	subi	r26, 0xF8	; 248
    87d2:	b3 4f       	sbci	r27, 0xF3	; 243
    87d4:	8c 91       	ld	r24, X
    87d6:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    87d8:	2f 5f       	subi	r18, 0xFF	; 255
    87da:	3f 4f       	sbci	r19, 0xFF	; 255
    87dc:	28 30       	cpi	r18, 0x08	; 8
    87de:	31 05       	cpc	r19, r1
    87e0:	99 f7       	brne	.-26     	; 0x87c8 <procMessage99+0x292>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    87e2:	10 92 f4 0a 	sts	0x0AF4, r1
    87e6:	20 e0       	ldi	r18, 0x00	; 0
    87e8:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    87ea:	f9 01       	movw	r30, r18
    87ec:	e5 56       	subi	r30, 0x65	; 101
    87ee:	fb 4f       	sbci	r31, 0xFB	; 251
    87f0:	d9 01       	movw	r26, r18
    87f2:	a0 5f       	subi	r26, 0xF0	; 240
    87f4:	b3 4f       	sbci	r27, 0xF3	; 243
    87f6:	8c 91       	ld	r24, X
    87f8:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    87fa:	2f 5f       	subi	r18, 0xFF	; 255
    87fc:	3f 4f       	sbci	r19, 0xFF	; 255
    87fe:	28 30       	cpi	r18, 0x08	; 8
    8800:	31 05       	cpc	r19, r1
    8802:	99 f7       	brne	.-26     	; 0x87ea <procMessage99+0x2b4>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8804:	10 92 a3 04 	sts	0x04A3, r1
    8808:	20 e0       	ldi	r18, 0x00	; 0
    880a:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    880c:	f9 01       	movw	r30, r18
    880e:	e9 53       	subi	r30, 0x39	; 57
    8810:	fb 4f       	sbci	r31, 0xFB	; 251
    8812:	d9 01       	movw	r26, r18
    8814:	a8 5e       	subi	r26, 0xE8	; 232
    8816:	b3 4f       	sbci	r27, 0xF3	; 243
    8818:	8c 91       	ld	r24, X
    881a:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    881c:	2f 5f       	subi	r18, 0xFF	; 255
    881e:	3f 4f       	sbci	r19, 0xFF	; 255
    8820:	24 31       	cpi	r18, 0x14	; 20
    8822:	31 05       	cpc	r19, r1
    8824:	99 f7       	brne	.-26     	; 0x880c <procMessage99+0x2d6>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8826:	10 92 db 04 	sts	0x04DB, r1
    882a:	20 e0       	ldi	r18, 0x00	; 0
    882c:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    882e:	f9 01       	movw	r30, r18
    8830:	ec 55       	subi	r30, 0x5C	; 92
    8832:	fb 4f       	sbci	r31, 0xFB	; 251
    8834:	d9 01       	movw	r26, r18
    8836:	a4 5d       	subi	r26, 0xD4	; 212
    8838:	b3 4f       	sbci	r27, 0xF3	; 243
    883a:	8c 91       	ld	r24, X
    883c:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    883e:	2f 5f       	subi	r18, 0xFF	; 255
    8840:	3f 4f       	sbci	r19, 0xFF	; 255
    8842:	2e 31       	cpi	r18, 0x1E	; 30
    8844:	31 05       	cpc	r19, r1
    8846:	99 f7       	brne	.-26     	; 0x882e <procMessage99+0x2f8>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8848:	10 92 c2 04 	sts	0x04C2, r1
    884c:	20 e0       	ldi	r18, 0x00	; 0
    884e:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8850:	f9 01       	movw	r30, r18
    8852:	e6 5c       	subi	r30, 0xC6	; 198
    8854:	f5 4f       	sbci	r31, 0xF5	; 245
    8856:	d9 01       	movw	r26, r18
    8858:	a6 5b       	subi	r26, 0xB6	; 182
    885a:	b3 4f       	sbci	r27, 0xF3	; 243
    885c:	8c 91       	ld	r24, X
    885e:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8860:	2f 5f       	subi	r18, 0xFF	; 255
    8862:	3f 4f       	sbci	r19, 0xFF	; 255
    8864:	28 30       	cpi	r18, 0x08	; 8
    8866:	31 05       	cpc	r19, r1
    8868:	99 f7       	brne	.-26     	; 0x8850 <procMessage99+0x31a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    886a:	10 92 42 0a 	sts	0x0A42, r1
    886e:	20 e0       	ldi	r18, 0x00	; 0
    8870:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8872:	f9 01       	movw	r30, r18
    8874:	e2 5a       	subi	r30, 0xA2	; 162
    8876:	fa 4f       	sbci	r31, 0xFA	; 250
    8878:	d9 01       	movw	r26, r18
    887a:	ae 5a       	subi	r26, 0xAE	; 174
    887c:	b3 4f       	sbci	r27, 0xF3	; 243
    887e:	8c 91       	ld	r24, X
    8880:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8882:	2f 5f       	subi	r18, 0xFF	; 255
    8884:	3f 4f       	sbci	r19, 0xFF	; 255
    8886:	2a 30       	cpi	r18, 0x0A	; 10
    8888:	31 05       	cpc	r19, r1
    888a:	99 f7       	brne	.-26     	; 0x8872 <procMessage99+0x33c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    888c:	10 92 68 05 	sts	0x0568, r1
    8890:	20 e0       	ldi	r18, 0x00	; 0
    8892:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8894:	f9 01       	movw	r30, r18
    8896:	e8 53       	subi	r30, 0x38	; 56
    8898:	f2 4f       	sbci	r31, 0xF2	; 242
    889a:	d9 01       	movw	r26, r18
    889c:	a4 5a       	subi	r26, 0xA4	; 164
    889e:	b3 4f       	sbci	r27, 0xF3	; 243
    88a0:	8c 91       	ld	r24, X
    88a2:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    88a4:	2f 5f       	subi	r18, 0xFF	; 255
    88a6:	3f 4f       	sbci	r19, 0xFF	; 255
    88a8:	2a 30       	cpi	r18, 0x0A	; 10
    88aa:	31 05       	cpc	r19, r1
    88ac:	99 f7       	brne	.-26     	; 0x8894 <procMessage99+0x35e>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    88ae:	10 92 d2 0d 	sts	0x0DD2, r1
    88b2:	20 e0       	ldi	r18, 0x00	; 0
    88b4:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    88b6:	f9 01       	movw	r30, r18
    88b8:	e1 53       	subi	r30, 0x31	; 49
    88ba:	f6 4f       	sbci	r31, 0xF6	; 246
    88bc:	d9 01       	movw	r26, r18
    88be:	aa 59       	subi	r26, 0x9A	; 154
    88c0:	b3 4f       	sbci	r27, 0xF3	; 243
    88c2:	8c 91       	ld	r24, X
    88c4:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    88c6:	2f 5f       	subi	r18, 0xFF	; 255
    88c8:	3f 4f       	sbci	r19, 0xFF	; 255
    88ca:	24 31       	cpi	r18, 0x14	; 20
    88cc:	31 05       	cpc	r19, r1
    88ce:	99 f7       	brne	.-26     	; 0x88b6 <procMessage99+0x380>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    88d0:	10 92 e3 09 	sts	0x09E3, r1
    88d4:	20 e0       	ldi	r18, 0x00	; 0
    88d6:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    88d8:	f9 01       	movw	r30, r18
    88da:	e9 5a       	subi	r30, 0xA9	; 169
    88dc:	f5 4f       	sbci	r31, 0xF5	; 245
    88de:	d9 01       	movw	r26, r18
    88e0:	a6 58       	subi	r26, 0x86	; 134
    88e2:	b3 4f       	sbci	r27, 0xF3	; 243
    88e4:	8c 91       	ld	r24, X
    88e6:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    88e8:	2f 5f       	subi	r18, 0xFF	; 255
    88ea:	3f 4f       	sbci	r19, 0xFF	; 255
    88ec:	2a 30       	cpi	r18, 0x0A	; 10
    88ee:	31 05       	cpc	r19, r1
    88f0:	99 f7       	brne	.-26     	; 0x88d8 <procMessage99+0x3a2>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    88f2:	10 92 61 0a 	sts	0x0A61, r1
    88f6:	20 e0       	ldi	r18, 0x00	; 0
    88f8:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    88fa:	f9 01       	movw	r30, r18
    88fc:	e6 58       	subi	r30, 0x86	; 134
    88fe:	fa 4f       	sbci	r31, 0xFA	; 250
    8900:	d9 01       	movw	r26, r18
    8902:	ac 57       	subi	r26, 0x7C	; 124
    8904:	b3 4f       	sbci	r27, 0xF3	; 243
    8906:	8c 91       	ld	r24, X
    8908:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    890a:	2f 5f       	subi	r18, 0xFF	; 255
    890c:	3f 4f       	sbci	r19, 0xFF	; 255
    890e:	28 30       	cpi	r18, 0x08	; 8
    8910:	31 05       	cpc	r19, r1
    8912:	99 f7       	brne	.-26     	; 0x88fa <procMessage99+0x3c4>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8914:	10 92 82 05 	sts	0x0582, r1
    8918:	20 e0       	ldi	r18, 0x00	; 0
    891a:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    891c:	f9 01       	movw	r30, r18
    891e:	ed 5a       	subi	r30, 0xAD	; 173
    8920:	f1 4f       	sbci	r31, 0xF1	; 241
    8922:	d9 01       	movw	r26, r18
    8924:	a4 57       	subi	r26, 0x74	; 116
    8926:	b3 4f       	sbci	r27, 0xF3	; 243
    8928:	8c 91       	ld	r24, X
    892a:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    892c:	2f 5f       	subi	r18, 0xFF	; 255
    892e:	3f 4f       	sbci	r19, 0xFF	; 255
    8930:	2a 30       	cpi	r18, 0x0A	; 10
    8932:	31 05       	cpc	r19, r1
    8934:	99 f7       	brne	.-26     	; 0x891c <procMessage99+0x3e6>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8936:	10 92 5d 0e 	sts	0x0E5D, r1
    893a:	20 e0       	ldi	r18, 0x00	; 0
    893c:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    893e:	f9 01       	movw	r30, r18
    8940:	eb 51       	subi	r30, 0x1B	; 27
    8942:	f2 4f       	sbci	r31, 0xF2	; 242
    8944:	d9 01       	movw	r26, r18
    8946:	aa 56       	subi	r26, 0x6A	; 106
    8948:	b3 4f       	sbci	r27, 0xF3	; 243
    894a:	8c 91       	ld	r24, X
    894c:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    894e:	2f 5f       	subi	r18, 0xFF	; 255
    8950:	3f 4f       	sbci	r19, 0xFF	; 255
    8952:	24 31       	cpi	r18, 0x14	; 20
    8954:	31 05       	cpc	r19, r1
    8956:	99 f7       	brne	.-26     	; 0x893e <procMessage99+0x408>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8958:	10 92 f9 0d 	sts	0x0DF9, r1
    895c:	20 e0       	ldi	r18, 0x00	; 0
    895e:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8960:	f9 01       	movw	r30, r18
    8962:	e3 55       	subi	r30, 0x53	; 83
    8964:	fa 4f       	sbci	r31, 0xFA	; 250
    8966:	d9 01       	movw	r26, r18
    8968:	a6 55       	subi	r26, 0x56	; 86
    896a:	b3 4f       	sbci	r27, 0xF3	; 243
    896c:	8c 91       	ld	r24, X
    896e:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8970:	2f 5f       	subi	r18, 0xFF	; 255
    8972:	3f 4f       	sbci	r19, 0xFF	; 255
    8974:	2e 31       	cpi	r18, 0x1E	; 30
    8976:	31 05       	cpc	r19, r1
    8978:	99 f7       	brne	.-26     	; 0x8960 <procMessage99+0x42a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    897a:	10 92 cb 05 	sts	0x05CB, r1
       StrPosCopy(rcv_trans,strCorporateName,437,30);
	   //


	   //FIP Detection LocalAccount Null Filling
	   if ((nLocalAccount>0)&&(LocalAccountFIP[0]==atoi(strFIP_ID))){
    897e:	80 91 a4 01 	lds	r24, 0x01A4
    8982:	88 23       	and	r24, r24
    8984:	69 f0       	breq	.+26     	; 0x89a0 <procMessage99+0x46a>
    8986:	00 91 36 05 	lds	r16, 0x0536
    898a:	10 e0       	ldi	r17, 0x00	; 0
    898c:	8c e9       	ldi	r24, 0x9C	; 156
    898e:	99 e0       	ldi	r25, 0x09	; 9
    8990:	0e 94 45 b5 	call	0x16a8a	; 0x16a8a <atoi>
    8994:	08 17       	cp	r16, r24
    8996:	19 07       	cpc	r17, r25
    8998:	19 f4       	brne	.+6      	; 0x89a0 <procMessage99+0x46a>
	        IsCompleteFilling=True;
    899a:	81 e0       	ldi	r24, 0x01	; 1
    899c:	80 93 c0 01 	sts	0x01C0, r24
	   }

	  }
     return Result;     
}
    89a0:	80 e0       	ldi	r24, 0x00	; 0
    89a2:	1f 91       	pop	r17
    89a4:	0f 91       	pop	r16
    89a6:	08 95       	ret

000089a8 <GetMessageID>:
		  }
       IsStandaloneAcknoledge=True;
	  }
}

char GetMessageID(char *strMessageFlow){
    89a8:	0f 93       	push	r16
    89aa:	1f 93       	push	r17
    89ac:	df 93       	push	r29
    89ae:	cf 93       	push	r28
    89b0:	00 d0       	rcall	.+0      	; 0x89b2 <GetMessageID+0xa>
    89b2:	0f 92       	push	r0
    89b4:	cd b7       	in	r28, 0x3d	; 61
    89b6:	de b7       	in	r29, 0x3e	; 62
    89b8:	fc 01       	movw	r30, r24
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    89ba:	80 81       	ld	r24, Z
    89bc:	89 83       	std	Y+1, r24	; 0x01
    89be:	81 81       	ldd	r24, Z+1	; 0x01
    89c0:	8a 83       	std	Y+2, r24	; 0x02
	 }Dest[Length]=0;
    89c2:	1b 82       	std	Y+3, r1	; 0x03
}

char GetMessageID(char *strMessageFlow){
     char Result,strMsgID[3];
	 StrPosCopy(strMessageFlow,strMsgID,0,2);
	 RemZeroLead(strMsgID);
    89c4:	8e 01       	movw	r16, r28
    89c6:	0f 5f       	subi	r16, 0xFF	; 255
    89c8:	1f 4f       	sbci	r17, 0xFF	; 255
    89ca:	c8 01       	movw	r24, r16
    89cc:	0e 94 b9 25 	call	0x4b72	; 0x4b72 <RemZeroLead>
	 Result=atoi(strMsgID);
    89d0:	c8 01       	movw	r24, r16
    89d2:	0e 94 45 b5 	call	0x16a8a	; 0x16a8a <atoi>
  return Result;
}
    89d6:	0f 90       	pop	r0
    89d8:	0f 90       	pop	r0
    89da:	0f 90       	pop	r0
    89dc:	cf 91       	pop	r28
    89de:	df 91       	pop	r29
    89e0:	1f 91       	pop	r17
    89e2:	0f 91       	pop	r16
    89e4:	08 95       	ret

000089e6 <FTestChar>:
         if (TimTicker>TICKER_DELAY)stDisplayTicker=tiRight;	     
	     break;
	}
}

char FTestChar(){
    89e6:	0f 93       	push	r16
    89e8:	1f 93       	push	r17
    89ea:	df 93       	push	r29
    89ec:	cf 93       	push	r28
    89ee:	cd b7       	in	r28, 0x3d	; 61
    89f0:	de b7       	in	r29, 0x3e	; 62
    89f2:	64 97       	sbiw	r28, 0x14	; 20
    89f4:	0f b6       	in	r0, 0x3f	; 63
    89f6:	f8 94       	cli
    89f8:	de bf       	out	0x3e, r29	; 62
    89fa:	0f be       	out	0x3f, r0	; 63
    89fc:	cd bf       	out	0x3d, r28	; 61
char lcdteks[20],Result;
static char i=0;
     Result=MENU_NONE;
     sprintf_P(lcdteks,PSTR("D:%d C:%c  "),i,i);
    89fe:	20 91 70 03 	lds	r18, 0x0370
    8a02:	8d b7       	in	r24, 0x3d	; 61
    8a04:	9e b7       	in	r25, 0x3e	; 62
    8a06:	08 97       	sbiw	r24, 0x08	; 8
    8a08:	0f b6       	in	r0, 0x3f	; 63
    8a0a:	f8 94       	cli
    8a0c:	9e bf       	out	0x3e, r25	; 62
    8a0e:	0f be       	out	0x3f, r0	; 63
    8a10:	8d bf       	out	0x3d, r24	; 61
    8a12:	ed b7       	in	r30, 0x3d	; 61
    8a14:	fe b7       	in	r31, 0x3e	; 62
    8a16:	31 96       	adiw	r30, 0x01	; 1
    8a18:	8e 01       	movw	r16, r28
    8a1a:	0f 5f       	subi	r16, 0xFF	; 255
    8a1c:	1f 4f       	sbci	r17, 0xFF	; 255
    8a1e:	ad b7       	in	r26, 0x3d	; 61
    8a20:	be b7       	in	r27, 0x3e	; 62
    8a22:	12 96       	adiw	r26, 0x02	; 2
    8a24:	1c 93       	st	X, r17
    8a26:	0e 93       	st	-X, r16
    8a28:	11 97       	sbiw	r26, 0x01	; 1
    8a2a:	8b e0       	ldi	r24, 0x0B	; 11
    8a2c:	9c e1       	ldi	r25, 0x1C	; 28
    8a2e:	93 83       	std	Z+3, r25	; 0x03
    8a30:	82 83       	std	Z+2, r24	; 0x02
    8a32:	24 83       	std	Z+4, r18	; 0x04
    8a34:	15 82       	std	Z+5, r1	; 0x05
    8a36:	26 83       	std	Z+6, r18	; 0x06
    8a38:	17 82       	std	Z+7, r1	; 0x07
    8a3a:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
     lcd_print(1,1,lcdteks);
    8a3e:	8d b7       	in	r24, 0x3d	; 61
    8a40:	9e b7       	in	r25, 0x3e	; 62
    8a42:	08 96       	adiw	r24, 0x08	; 8
    8a44:	0f b6       	in	r0, 0x3f	; 63
    8a46:	f8 94       	cli
    8a48:	9e bf       	out	0x3e, r25	; 62
    8a4a:	0f be       	out	0x3f, r0	; 63
    8a4c:	8d bf       	out	0x3d, r24	; 61
    8a4e:	81 e0       	ldi	r24, 0x01	; 1
    8a50:	61 e0       	ldi	r22, 0x01	; 1
    8a52:	a8 01       	movw	r20, r16
    8a54:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
	 if (i==0xFF)Result=MENU_DONE;
    8a58:	20 91 70 03 	lds	r18, 0x0370
	 i++;
    8a5c:	2f 5f       	subi	r18, 0xFF	; 255
    8a5e:	20 93 70 03 	sts	0x0370, r18
    8a62:	21 50       	subi	r18, 0x01	; 1
    8a64:	88 ee       	ldi	r24, 0xE8	; 232
    8a66:	9d ef       	ldi	r25, 0xFD	; 253
    8a68:	49 e1       	ldi	r20, 0x19	; 25
    8a6a:	50 e0       	ldi	r21, 0x00	; 0
    8a6c:	fa 01       	movw	r30, r20
    8a6e:	31 97       	sbiw	r30, 0x01	; 1
    8a70:	f1 f7       	brne	.-4      	; 0x8a6e <FTestChar+0x88>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    8a72:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    8a74:	d9 f7       	brne	.-10     	; 0x8a6c <FTestChar+0x86>
    8a76:	80 e0       	ldi	r24, 0x00	; 0
    8a78:	2f 3f       	cpi	r18, 0xFF	; 255
    8a7a:	09 f4       	brne	.+2      	; 0x8a7e <FTestChar+0x98>
    8a7c:	81 e0       	ldi	r24, 0x01	; 1
     _delay_ms(6500);
  return Result;
}
    8a7e:	64 96       	adiw	r28, 0x14	; 20
    8a80:	0f b6       	in	r0, 0x3f	; 63
    8a82:	f8 94       	cli
    8a84:	de bf       	out	0x3e, r29	; 62
    8a86:	0f be       	out	0x3f, r0	; 63
    8a88:	cd bf       	out	0x3d, r28	; 61
    8a8a:	cf 91       	pop	r28
    8a8c:	df 91       	pop	r29
    8a8e:	1f 91       	pop	r17
    8a90:	0f 91       	pop	r16
    8a92:	08 95       	ret

00008a94 <DisplayPumpStatus>:
		  break;         	 
	 }
  return Result;	 
}

void DisplayPumpStatus(){
    8a94:	0f 93       	push	r16
    8a96:	1f 93       	push	r17
    8a98:	df 93       	push	r29
    8a9a:	cf 93       	push	r28
    8a9c:	cd b7       	in	r28, 0x3d	; 61
    8a9e:	de b7       	in	r29, 0x3e	; 62
    8aa0:	a8 97       	sbiw	r28, 0x28	; 40
    8aa2:	0f b6       	in	r0, 0x3f	; 63
    8aa4:	f8 94       	cli
    8aa6:	de bf       	out	0x3e, r29	; 62
    8aa8:	0f be       	out	0x3f, r0	; 63
    8aaa:	cd bf       	out	0x3d, r28	; 61
     char SPump[20],lcdteks[20];

	 if (IsNewPumpStatus==True){
    8aac:	80 91 11 01 	lds	r24, 0x0111
    8ab0:	81 30       	cpi	r24, 0x01	; 1
    8ab2:	09 f0       	breq	.+2      	; 0x8ab6 <DisplayPumpStatus+0x22>
    8ab4:	4a c0       	rjmp	.+148    	; 0x8b4a <DisplayPumpStatus+0xb6>
	     IsNewPumpStatus=False;
    8ab6:	10 92 11 01 	sts	0x0111, r1
     }      
}

void BackLightTrig(){
     //TimBackLight=0;
__key_light = 1; __key_lgtcnt = 0; PORTG=PORTG&0b11111101;
    8aba:	80 93 bf 03 	sts	0x03BF, r24
    8abe:	10 92 c0 03 	sts	0x03C0, r1
    8ac2:	80 91 65 00 	lds	r24, 0x0065
    8ac6:	8d 7f       	andi	r24, 0xFD	; 253
    8ac8:	80 93 65 00 	sts	0x0065, r24
     char SPump[20],lcdteks[20];

	 if (IsNewPumpStatus==True){
	     IsNewPumpStatus=False;
		 BackLightTrig();
		 StrPosCopy(strPumpStatus,SPump,0,PumpCountMax);
    8acc:	80 91 5f 01 	lds	r24, 0x015F
    8ad0:	48 2f       	mov	r20, r24
    8ad2:	50 e0       	ldi	r21, 0x00	; 0
    8ad4:	20 e0       	ldi	r18, 0x00	; 0
    8ad6:	30 e0       	ldi	r19, 0x00	; 0
    8ad8:	be 01       	movw	r22, r28
    8ada:	6f 5f       	subi	r22, 0xFF	; 255
    8adc:	7f 4f       	sbci	r23, 0xFF	; 255
    8ade:	0a c0       	rjmp	.+20     	; 0x8af4 <DisplayPumpStatus+0x60>
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8ae0:	fb 01       	movw	r30, r22
    8ae2:	e2 0f       	add	r30, r18
    8ae4:	f3 1f       	adc	r31, r19
    8ae6:	d9 01       	movw	r26, r18
    8ae8:	ae 5e       	subi	r26, 0xEE	; 238
    8aea:	be 4f       	sbci	r27, 0xFE	; 254
    8aec:	8c 91       	ld	r24, X
    8aee:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8af0:	2f 5f       	subi	r18, 0xFF	; 255
    8af2:	3f 4f       	sbci	r19, 0xFF	; 255
    8af4:	24 17       	cp	r18, r20
    8af6:	35 07       	cpc	r19, r21
    8af8:	98 f3       	brcs	.-26     	; 0x8ae0 <DisplayPumpStatus+0x4c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8afa:	46 0f       	add	r20, r22
    8afc:	57 1f       	adc	r21, r23
    8afe:	da 01       	movw	r26, r20
    8b00:	1c 92       	st	X, r1

	 if (IsNewPumpStatus==True){
	     IsNewPumpStatus=False;
		 BackLightTrig();
		 StrPosCopy(strPumpStatus,SPump,0,PumpCountMax);
		 sprintf_P(lcdteks,PSTR("%s"),SPump);
    8b02:	00 d0       	rcall	.+0      	; 0x8b04 <DisplayPumpStatus+0x70>
    8b04:	00 d0       	rcall	.+0      	; 0x8b06 <DisplayPumpStatus+0x72>
    8b06:	00 d0       	rcall	.+0      	; 0x8b08 <DisplayPumpStatus+0x74>
    8b08:	ed b7       	in	r30, 0x3d	; 61
    8b0a:	fe b7       	in	r31, 0x3e	; 62
    8b0c:	31 96       	adiw	r30, 0x01	; 1
    8b0e:	8e 01       	movw	r16, r28
    8b10:	0b 5e       	subi	r16, 0xEB	; 235
    8b12:	1f 4f       	sbci	r17, 0xFF	; 255
    8b14:	ad b7       	in	r26, 0x3d	; 61
    8b16:	be b7       	in	r27, 0x3e	; 62
    8b18:	12 96       	adiw	r26, 0x02	; 2
    8b1a:	1c 93       	st	X, r17
    8b1c:	0e 93       	st	-X, r16
    8b1e:	11 97       	sbiw	r26, 0x01	; 1
    8b20:	8b e9       	ldi	r24, 0x9B	; 155
    8b22:	92 e2       	ldi	r25, 0x22	; 34
    8b24:	93 83       	std	Z+3, r25	; 0x03
    8b26:	82 83       	std	Z+2, r24	; 0x02
    8b28:	75 83       	std	Z+5, r23	; 0x05
    8b2a:	64 83       	std	Z+4, r22	; 0x04
    8b2c:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
         lcd_print(4,1,lcdteks);
    8b30:	ed b7       	in	r30, 0x3d	; 61
    8b32:	fe b7       	in	r31, 0x3e	; 62
    8b34:	36 96       	adiw	r30, 0x06	; 6
    8b36:	0f b6       	in	r0, 0x3f	; 63
    8b38:	f8 94       	cli
    8b3a:	fe bf       	out	0x3e, r31	; 62
    8b3c:	0f be       	out	0x3f, r0	; 63
    8b3e:	ed bf       	out	0x3d, r30	; 61
    8b40:	84 e0       	ldi	r24, 0x04	; 4
    8b42:	61 e0       	ldi	r22, 0x01	; 1
    8b44:	a8 01       	movw	r20, r16
    8b46:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
     	 }
}
    8b4a:	a8 96       	adiw	r28, 0x28	; 40
    8b4c:	0f b6       	in	r0, 0x3f	; 63
    8b4e:	f8 94       	cli
    8b50:	de bf       	out	0x3e, r29	; 62
    8b52:	0f be       	out	0x3f, r0	; 63
    8b54:	cd bf       	out	0x3d, r28	; 61
    8b56:	cf 91       	pop	r28
    8b58:	df 91       	pop	r29
    8b5a:	1f 91       	pop	r17
    8b5c:	0f 91       	pop	r16
    8b5e:	08 95       	ret

00008b60 <FViewFreeMessage>:
char FViewFreeMessage(){
static char stFreeMessage=fmInit;
       char Result=MENU_NONE;
     
	 Result=MENU_NONE;
	 switch(stFreeMessage){
    8b60:	80 91 59 03 	lds	r24, 0x0359
    8b64:	81 30       	cpi	r24, 0x01	; 1
    8b66:	49 f0       	breq	.+18     	; 0x8b7a <FViewFreeMessage+0x1a>
    8b68:	81 30       	cpi	r24, 0x01	; 1
    8b6a:	28 f0       	brcs	.+10     	; 0x8b76 <FViewFreeMessage+0x16>
    8b6c:	82 30       	cpi	r24, 0x02	; 2
    8b6e:	19 f1       	breq	.+70     	; 0x8bb6 <FViewFreeMessage+0x56>
    8b70:	83 30       	cpi	r24, 0x03	; 3
    8b72:	71 f5       	brne	.+92     	; 0x8bd0 <FViewFreeMessage+0x70>
    8b74:	29 c0       	rjmp	.+82     	; 0x8bc8 <FViewFreeMessage+0x68>
	 case fmInit:
	      stFreeMessage=fmDisplayFreeMessage;
    8b76:	81 e0       	ldi	r24, 0x01	; 1
    8b78:	23 c0       	rjmp	.+70     	; 0x8bc0 <FViewFreeMessage+0x60>
	      break;
     case fmDisplayFreeMessage:
		  lcd_clear();
    8b7a:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
		  lcd_print(1,1,strFreeMessageLine1);
    8b7e:	81 e0       	ldi	r24, 0x01	; 1
    8b80:	61 e0       	ldi	r22, 0x01	; 1
    8b82:	47 e9       	ldi	r20, 0x97	; 151
    8b84:	5a e0       	ldi	r21, 0x0A	; 10
    8b86:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
		  lcd_print(2,1,strFreeMessageLine2);
    8b8a:	82 e0       	ldi	r24, 0x02	; 2
    8b8c:	61 e0       	ldi	r22, 0x01	; 1
    8b8e:	46 e8       	ldi	r20, 0x86	; 134
    8b90:	59 e0       	ldi	r21, 0x09	; 9
    8b92:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
		  lcd_print(3,1,strFreeMessageLine3);
    8b96:	83 e0       	ldi	r24, 0x03	; 3
    8b98:	61 e0       	ldi	r22, 0x01	; 1
    8b9a:	41 e2       	ldi	r20, 0x21	; 33
    8b9c:	5a e0       	ldi	r21, 0x0A	; 10
    8b9e:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
		  lcd_print(4,1,strFreeMessageLine4);
    8ba2:	84 e0       	ldi	r24, 0x04	; 4
    8ba4:	61 e0       	ldi	r22, 0x01	; 1
    8ba6:	41 eb       	ldi	r20, 0xB1	; 177
    8ba8:	5d e0       	ldi	r21, 0x0D	; 13
    8baa:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
	      TimDisplay=0;
    8bae:	10 92 a7 01 	sts	0x01A7, r1
	      stFreeMessage=fmDelayViewMesage;
    8bb2:	82 e0       	ldi	r24, 0x02	; 2
    8bb4:	05 c0       	rjmp	.+10     	; 0x8bc0 <FViewFreeMessage+0x60>
	      break;
	 case fmDelayViewMesage:  
	      if (TimDisplay>TIM_FREE_MESSAGE)stFreeMessage=fmFinishFreeMessage;
    8bb6:	80 91 a7 01 	lds	r24, 0x01A7
    8bba:	8b 30       	cpi	r24, 0x0B	; 11
    8bbc:	48 f0       	brcs	.+18     	; 0x8bd0 <FViewFreeMessage+0x70>
    8bbe:	83 e0       	ldi	r24, 0x03	; 3
    8bc0:	80 93 59 03 	sts	0x0359, r24
    8bc4:	80 e0       	ldi	r24, 0x00	; 0
    8bc6:	08 95       	ret
	      break;
     case fmFinishFreeMessage:
          stFreeMessage=fmInit;
    8bc8:	10 92 59 03 	sts	0x0359, r1
    8bcc:	81 e0       	ldi	r24, 0x01	; 1
    8bce:	08 95       	ret
    8bd0:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
  return Result;
}
    8bd2:	08 95       	ret

00008bd4 <_scr_idle>:
		if ((__num>='0')&&(__num<='9')||(IsStandAloneDetected==True)) 
		break;
	 }
}

void _scr_idle(void){
    8bd4:	cf 92       	push	r12
    8bd6:	df 92       	push	r13
    8bd8:	ef 92       	push	r14
    8bda:	ff 92       	push	r15
    8bdc:	0f 93       	push	r16
    8bde:	1f 93       	push	r17
    8be0:	df 93       	push	r29
    8be2:	cf 93       	push	r28
    8be4:	cd b7       	in	r28, 0x3d	; 61
    8be6:	de b7       	in	r29, 0x3e	; 62
    8be8:	a8 97       	sbiw	r28, 0x28	; 40
    8bea:	0f b6       	in	r0, 0x3f	; 63
    8bec:	f8 94       	cli
    8bee:	de bf       	out	0x3e, r29	; 62
    8bf0:	0f be       	out	0x3f, r0	; 63
    8bf2:	cd bf       	out	0x3d, r28	; 61
char strCodeName[10],strVersion[10],lcdteks[20];
    sprintf_P(strCodeName,PSTR(CODE_NAME)); 
    8bf4:	00 d0       	rcall	.+0      	; 0x8bf6 <_scr_idle+0x22>
    8bf6:	00 d0       	rcall	.+0      	; 0x8bf8 <_scr_idle+0x24>
    8bf8:	6e 01       	movw	r12, r28
    8bfa:	08 94       	sec
    8bfc:	c1 1c       	adc	r12, r1
    8bfe:	d1 1c       	adc	r13, r1
    8c00:	ad b7       	in	r26, 0x3d	; 61
    8c02:	be b7       	in	r27, 0x3e	; 62
    8c04:	12 96       	adiw	r26, 0x02	; 2
    8c06:	dc 92       	st	X, r13
    8c08:	ce 92       	st	-X, r12
    8c0a:	11 97       	sbiw	r26, 0x01	; 1
    8c0c:	84 e2       	ldi	r24, 0x24	; 36
    8c0e:	92 e2       	ldi	r25, 0x22	; 34
    8c10:	14 96       	adiw	r26, 0x04	; 4
    8c12:	9c 93       	st	X, r25
    8c14:	8e 93       	st	-X, r24
    8c16:	13 97       	sbiw	r26, 0x03	; 3
    8c18:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    sprintf_P(strVersion,PSTR(VERSION_NUM)); 
    8c1c:	fb e0       	ldi	r31, 0x0B	; 11
    8c1e:	ef 2e       	mov	r14, r31
    8c20:	f1 2c       	mov	r15, r1
    8c22:	ec 0e       	add	r14, r28
    8c24:	fd 1e       	adc	r15, r29
    8c26:	ed b7       	in	r30, 0x3d	; 61
    8c28:	fe b7       	in	r31, 0x3e	; 62
    8c2a:	f2 82       	std	Z+2, r15	; 0x02
    8c2c:	e1 82       	std	Z+1, r14	; 0x01
    8c2e:	8f e1       	ldi	r24, 0x1F	; 31
    8c30:	92 e2       	ldi	r25, 0x22	; 34
    8c32:	94 83       	std	Z+4, r25	; 0x04
    8c34:	83 83       	std	Z+3, r24	; 0x03
    8c36:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    sprintf_P(lcdteks,PSTR("%s %s"),strCodeName,strVersion); 
    8c3a:	00 d0       	rcall	.+0      	; 0x8c3c <_scr_idle+0x68>
    8c3c:	00 d0       	rcall	.+0      	; 0x8c3e <_scr_idle+0x6a>
    8c3e:	ed b7       	in	r30, 0x3d	; 61
    8c40:	fe b7       	in	r31, 0x3e	; 62
    8c42:	31 96       	adiw	r30, 0x01	; 1
    8c44:	8e 01       	movw	r16, r28
    8c46:	0b 5e       	subi	r16, 0xEB	; 235
    8c48:	1f 4f       	sbci	r17, 0xFF	; 255
    8c4a:	ad b7       	in	r26, 0x3d	; 61
    8c4c:	be b7       	in	r27, 0x3e	; 62
    8c4e:	12 96       	adiw	r26, 0x02	; 2
    8c50:	1c 93       	st	X, r17
    8c52:	0e 93       	st	-X, r16
    8c54:	11 97       	sbiw	r26, 0x01	; 1
    8c56:	89 e1       	ldi	r24, 0x19	; 25
    8c58:	92 e2       	ldi	r25, 0x22	; 34
    8c5a:	93 83       	std	Z+3, r25	; 0x03
    8c5c:	82 83       	std	Z+2, r24	; 0x02
    8c5e:	d5 82       	std	Z+5, r13	; 0x05
    8c60:	c4 82       	std	Z+4, r12	; 0x04
    8c62:	f7 82       	std	Z+7, r15	; 0x07
    8c64:	e6 82       	std	Z+6, r14	; 0x06
    8c66:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
	lcd_clear();
    8c6a:	ed b7       	in	r30, 0x3d	; 61
    8c6c:	fe b7       	in	r31, 0x3e	; 62
    8c6e:	38 96       	adiw	r30, 0x08	; 8
    8c70:	0f b6       	in	r0, 0x3f	; 63
    8c72:	f8 94       	cli
    8c74:	fe bf       	out	0x3e, r31	; 62
    8c76:	0f be       	out	0x3f, r0	; 63
    8c78:	ed bf       	out	0x3d, r30	; 61
    8c7a:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
	lcd_print(1,1,lcdteks);
    8c7e:	81 e0       	ldi	r24, 0x01	; 1
    8c80:	61 e0       	ldi	r22, 0x01	; 1
    8c82:	a8 01       	movw	r20, r16
    8c84:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
}
    8c88:	a8 96       	adiw	r28, 0x28	; 40
    8c8a:	0f b6       	in	r0, 0x3f	; 63
    8c8c:	f8 94       	cli
    8c8e:	de bf       	out	0x3e, r29	; 62
    8c90:	0f be       	out	0x3f, r0	; 63
    8c92:	cd bf       	out	0x3d, r28	; 61
    8c94:	cf 91       	pop	r28
    8c96:	df 91       	pop	r29
    8c98:	1f 91       	pop	r17
    8c9a:	0f 91       	pop	r16
    8c9c:	ff 90       	pop	r15
    8c9e:	ef 90       	pop	r14
    8ca0:	df 90       	pop	r13
    8ca2:	cf 90       	pop	r12
    8ca4:	08 95       	ret

00008ca6 <_scr_pump>:
	 }
	 */
     sprintf_P(StrResult,PSTR("%.2d"),Val);

}
void _scr_pump(void){
    8ca6:	8f 92       	push	r8
    8ca8:	9f 92       	push	r9
    8caa:	af 92       	push	r10
    8cac:	bf 92       	push	r11
    8cae:	cf 92       	push	r12
    8cb0:	df 92       	push	r13
    8cb2:	ef 92       	push	r14
    8cb4:	ff 92       	push	r15
    8cb6:	0f 93       	push	r16
    8cb8:	1f 93       	push	r17
    8cba:	df 93       	push	r29
    8cbc:	cf 93       	push	r28
    8cbe:	cd b7       	in	r28, 0x3d	; 61
    8cc0:	de b7       	in	r29, 0x3e	; 62
    8cc2:	6c 97       	sbiw	r28, 0x1c	; 28
    8cc4:	0f b6       	in	r0, 0x3f	; 63
    8cc6:	f8 94       	cli
    8cc8:	de bf       	out	0x3e, r29	; 62
    8cca:	0f be       	out	0x3f, r0	; 63
    8ccc:	cd bf       	out	0x3d, r28	; 61
	 //char strPumpL[3],strPumpR[3];
	 char __pump_id[8];
	 char i;
     char lcdteks[20];
	 lcd_clear();_delay_ms(10);
    8cce:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
    8cd2:	84 ec       	ldi	r24, 0xC4	; 196
    8cd4:	99 e0       	ldi	r25, 0x09	; 9
    8cd6:	01 97       	sbiw	r24, 0x01	; 1
    8cd8:	f1 f7       	brne	.-4      	; 0x8cd6 <_scr_pump+0x30>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    8cda:	8e 01       	movw	r16, r28
    8cdc:	0f 5f       	subi	r16, 0xFF	; 255
    8cde:	1f 4f       	sbci	r17, 0xFF	; 255
    8ce0:	c8 01       	movw	r24, r16
    8ce2:	65 e4       	ldi	r22, 0x45	; 69
    8ce4:	70 e0       	ldi	r23, 0x00	; 0
    8ce6:	48 e0       	ldi	r20, 0x08	; 8
    8ce8:	50 e0       	ldi	r21, 0x00	; 0
    8cea:	26 ef       	ldi	r18, 0xF6	; 246
    8cec:	32 e1       	ldi	r19, 0x12	; 18
    8cee:	0e 94 7a b5 	call	0x16af4	; 0x16af4 <__eerd_block>
    8cf2:	78 01       	movw	r14, r16
    8cf4:	01 e0       	ldi	r16, 0x01	; 1
    8cf6:	10 e0       	ldi	r17, 0x00	; 0
		eeprom_read_block((void*) &__pump_id, (const void*) &DefPumpMap, 8);
        for (i=0;i<4;i++){
             //leadingZero(__pump_id[i],strPumpL);
			 //leadingZero(__pump_id[i+4],strPumpR);
             //sprintf_P(lcdteks,PSTR("%d.P%s | %.P%s  "),(i+1),strPumpL,(i+5),strPumpR);
			 sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d "),(i+1),__pump_id[i],(i+5),__pump_id[i+4]);
    8cf8:	89 e0       	ldi	r24, 0x09	; 9
    8cfa:	c8 2e       	mov	r12, r24
    8cfc:	d1 2c       	mov	r13, r1
    8cfe:	cc 0e       	add	r12, r28
    8d00:	dd 1e       	adc	r13, r29
    8d02:	b8 e4       	ldi	r27, 0x48	; 72
    8d04:	8b 2e       	mov	r8, r27
    8d06:	bd e0       	ldi	r27, 0x0D	; 13
    8d08:	9b 2e       	mov	r9, r27
	 char i;
     char lcdteks[20];
	 lcd_clear();_delay_ms(10);
	 //Display
		eeprom_read_block((void*) &__pump_id, (const void*) &DefPumpMap, 8);
        for (i=0;i<4;i++){
    8d0a:	a5 e0       	ldi	r26, 0x05	; 5
    8d0c:	aa 2e       	mov	r10, r26
    8d0e:	b1 2c       	mov	r11, r1
    8d10:	ac 0e       	add	r10, r28
    8d12:	bd 1e       	adc	r11, r29
             //leadingZero(__pump_id[i],strPumpL);
			 //leadingZero(__pump_id[i+4],strPumpR);
             //sprintf_P(lcdteks,PSTR("%d.P%s | %.P%s  "),(i+1),strPumpL,(i+5),strPumpR);
			 sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d "),(i+1),__pump_id[i],(i+5),__pump_id[i+4]);
    8d14:	8d b7       	in	r24, 0x3d	; 61
    8d16:	9e b7       	in	r25, 0x3e	; 62
    8d18:	0c 97       	sbiw	r24, 0x0c	; 12
    8d1a:	0f b6       	in	r0, 0x3f	; 63
    8d1c:	f8 94       	cli
    8d1e:	9e bf       	out	0x3e, r25	; 62
    8d20:	0f be       	out	0x3f, r0	; 63
    8d22:	8d bf       	out	0x3d, r24	; 61
    8d24:	ed b7       	in	r30, 0x3d	; 61
    8d26:	fe b7       	in	r31, 0x3e	; 62
    8d28:	31 96       	adiw	r30, 0x01	; 1
    8d2a:	ad b7       	in	r26, 0x3d	; 61
    8d2c:	be b7       	in	r27, 0x3e	; 62
    8d2e:	12 96       	adiw	r26, 0x02	; 2
    8d30:	dc 92       	st	X, r13
    8d32:	ce 92       	st	-X, r12
    8d34:	11 97       	sbiw	r26, 0x01	; 1
    8d36:	93 82       	std	Z+3, r9	; 0x03
    8d38:	82 82       	std	Z+2, r8	; 0x02
    8d3a:	15 83       	std	Z+5, r17	; 0x05
    8d3c:	04 83       	std	Z+4, r16	; 0x04
    8d3e:	d7 01       	movw	r26, r14
    8d40:	8c 91       	ld	r24, X
    8d42:	86 83       	std	Z+6, r24	; 0x06
    8d44:	17 82       	std	Z+7, r1	; 0x07
    8d46:	0c 5f       	subi	r16, 0xFC	; 252
    8d48:	1f 4f       	sbci	r17, 0xFF	; 255
    8d4a:	11 87       	std	Z+9, r17	; 0x09
    8d4c:	00 87       	std	Z+8, r16	; 0x08
    8d4e:	04 50       	subi	r16, 0x04	; 4
    8d50:	10 40       	sbci	r17, 0x00	; 0
    8d52:	14 96       	adiw	r26, 0x04	; 4
    8d54:	8c 91       	ld	r24, X
    8d56:	82 87       	std	Z+10, r24	; 0x0a
    8d58:	13 86       	std	Z+11, r1	; 0x0b
    8d5a:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
			 lcd_print((i+1),1,lcdteks);
    8d5e:	8d b7       	in	r24, 0x3d	; 61
    8d60:	9e b7       	in	r25, 0x3e	; 62
    8d62:	0c 96       	adiw	r24, 0x0c	; 12
    8d64:	0f b6       	in	r0, 0x3f	; 63
    8d66:	f8 94       	cli
    8d68:	9e bf       	out	0x3e, r25	; 62
    8d6a:	0f be       	out	0x3f, r0	; 63
    8d6c:	8d bf       	out	0x3d, r24	; 61
    8d6e:	80 2f       	mov	r24, r16
    8d70:	61 e0       	ldi	r22, 0x01	; 1
    8d72:	a6 01       	movw	r20, r12
    8d74:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
    8d78:	08 94       	sec
    8d7a:	e1 1c       	adc	r14, r1
    8d7c:	f1 1c       	adc	r15, r1
    8d7e:	0f 5f       	subi	r16, 0xFF	; 255
    8d80:	1f 4f       	sbci	r17, 0xFF	; 255
	 char i;
     char lcdteks[20];
	 lcd_clear();_delay_ms(10);
	 //Display
		eeprom_read_block((void*) &__pump_id, (const void*) &DefPumpMap, 8);
        for (i=0;i<4;i++){
    8d82:	ea 14       	cp	r14, r10
    8d84:	fb 04       	cpc	r15, r11
    8d86:	31 f6       	brne	.-116    	; 0x8d14 <_scr_pump+0x6e>
			 //leadingZero(__pump_id[i+4],strPumpR);
             //sprintf_P(lcdteks,PSTR("%d.P%s | %.P%s  "),(i+1),strPumpL,(i+5),strPumpR);
			 sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d "),(i+1),__pump_id[i],(i+5),__pump_id[i+4]);
			 lcd_print((i+1),1,lcdteks);
		}
        lcd_printf(4,15,PSTR("*)Exit"));
    8d88:	84 e0       	ldi	r24, 0x04	; 4
    8d8a:	6f e0       	ldi	r22, 0x0F	; 15
    8d8c:	41 e4       	ldi	r20, 0x41	; 65
    8d8e:	5d e0       	ldi	r21, 0x0D	; 13
    8d90:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
}
    8d94:	6c 96       	adiw	r28, 0x1c	; 28
    8d96:	0f b6       	in	r0, 0x3f	; 63
    8d98:	f8 94       	cli
    8d9a:	de bf       	out	0x3e, r29	; 62
    8d9c:	0f be       	out	0x3f, r0	; 63
    8d9e:	cd bf       	out	0x3d, r28	; 61
    8da0:	cf 91       	pop	r28
    8da2:	df 91       	pop	r29
    8da4:	1f 91       	pop	r17
    8da6:	0f 91       	pop	r16
    8da8:	ff 90       	pop	r15
    8daa:	ef 90       	pop	r14
    8dac:	df 90       	pop	r13
    8dae:	cf 90       	pop	r12
    8db0:	bf 90       	pop	r11
    8db2:	af 90       	pop	r10
    8db4:	9f 90       	pop	r9
    8db6:	8f 90       	pop	r8
    8db8:	08 95       	ret

00008dba <_menu_host>:
			lcd_print(__x, __y, __buff);
		}
	}
}

void _menu_host(void){
    8dba:	2f 92       	push	r2
    8dbc:	3f 92       	push	r3
    8dbe:	4f 92       	push	r4
    8dc0:	5f 92       	push	r5
    8dc2:	6f 92       	push	r6
    8dc4:	7f 92       	push	r7
    8dc6:	8f 92       	push	r8
    8dc8:	9f 92       	push	r9
    8dca:	af 92       	push	r10
    8dcc:	bf 92       	push	r11
    8dce:	cf 92       	push	r12
    8dd0:	df 92       	push	r13
    8dd2:	ef 92       	push	r14
    8dd4:	ff 92       	push	r15
    8dd6:	0f 93       	push	r16
    8dd8:	1f 93       	push	r17
    8dda:	df 93       	push	r29
    8ddc:	cf 93       	push	r28
    8dde:	cd b7       	in	r28, 0x3d	; 61
    8de0:	de b7       	in	r29, 0x3e	; 62
    8de2:	6d 97       	sbiw	r28, 0x1d	; 29
    8de4:	0f b6       	in	r0, 0x3f	; 63
    8de6:	f8 94       	cli
    8de8:	de bf       	out	0x3e, r29	; 62
    8dea:	0f be       	out	0x3f, r0	; 63
    8dec:	cd bf       	out	0x3d, r28	; 61
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    8dee:	e1 99       	sbic	0x1c, 1	; 28
    8df0:	fe cf       	rjmp	.-4      	; 0x8dee <_menu_host+0x34>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    8df2:	21 ec       	ldi	r18, 0xC1	; 193
    8df4:	33 e0       	ldi	r19, 0x03	; 3
    8df6:	3f bb       	out	0x1f, r19	; 31
    8df8:	2e bb       	out	0x1e, r18	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    8dfa:	e0 9a       	sbi	0x1c, 0	; 28
    8dfc:	8d b3       	in	r24, 0x1d	; 29
	char 			__value[4];
	unsigned char	__i, __x, __y, __key, __num, __buff[5];
	char lcdteks[20];
	static char TermID;

	__value[0] = eeprom_read_byte(&DefPrintMoney);
    8dfe:	89 83       	std	Y+1, r24	; 0x01
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    8e00:	e1 99       	sbic	0x1c, 1	; 28
    8e02:	fe cf       	rjmp	.-4      	; 0x8e00 <_menu_host+0x46>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    8e04:	f7 e3       	ldi	r31, 0x37	; 55
    8e06:	2f 2e       	mov	r2, r31
    8e08:	f0 e0       	ldi	r31, 0x00	; 0
    8e0a:	3f 2e       	mov	r3, r31
    8e0c:	3f ba       	out	0x1f, r3	; 31
    8e0e:	2e ba       	out	0x1e, r2	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    8e10:	e0 9a       	sbi	0x1c, 0	; 28
    8e12:	8d b3       	in	r24, 0x1d	; 29
	__value[1] = eeprom_read_byte(&DefShowDateTime);
    8e14:	8a 83       	std	Y+2, r24	; 0x02
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    8e16:	e1 99       	sbic	0x1c, 1	; 28
    8e18:	fe cf       	rjmp	.-4      	; 0x8e16 <_menu_host+0x5c>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    8e1a:	e8 e3       	ldi	r30, 0x38	; 56
    8e1c:	4e 2e       	mov	r4, r30
    8e1e:	e0 e0       	ldi	r30, 0x00	; 0
    8e20:	5e 2e       	mov	r5, r30
    8e22:	5f ba       	out	0x1f, r5	; 31
    8e24:	4e ba       	out	0x1e, r4	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    8e26:	e0 9a       	sbi	0x1c, 0	; 28
    8e28:	8d b3       	in	r24, 0x1d	; 29
	__value[2] = eeprom_read_byte(&DefNotifScreen);
    8e2a:	8b 83       	std	Y+3, r24	; 0x03
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    8e2c:	e1 99       	sbic	0x1c, 1	; 28
    8e2e:	fe cf       	rjmp	.-4      	; 0x8e2c <_menu_host+0x72>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    8e30:	70 e0       	ldi	r23, 0x00	; 0
    8e32:	67 2e       	mov	r6, r23
    8e34:	70 e0       	ldi	r23, 0x00	; 0
    8e36:	77 2e       	mov	r7, r23
    8e38:	7f ba       	out	0x1f, r7	; 31
    8e3a:	6e ba       	out	0x1e, r6	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    8e3c:	e0 9a       	sbi	0x1c, 0	; 28
    8e3e:	8d b3       	in	r24, 0x1d	; 29
	TermID= eeprom_read_byte(&DefIFT_ID);
    8e40:	80 93 d1 02 	sts	0x02D1, r24


	lcd_clear();_delay_ms(10);
    8e44:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
    8e48:	84 ec       	ldi	r24, 0xC4	; 196
    8e4a:	99 e0       	ldi	r25, 0x09	; 9
    8e4c:	01 97       	sbiw	r24, 0x01	; 1
    8e4e:	f1 f7       	brne	.-4      	; 0x8e4c <_menu_host+0x92>
	lcd_printf(1, 1, PSTR("1)Money :"));
    8e50:	81 e0       	ldi	r24, 0x01	; 1
    8e52:	61 e0       	ldi	r22, 0x01	; 1
    8e54:	46 e4       	ldi	r20, 0x46	; 70
    8e56:	5b e0       	ldi	r21, 0x0B	; 11
    8e58:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
	lcd_printf(2, 1, PSTR("2)D/T   :"));
    8e5c:	82 e0       	ldi	r24, 0x02	; 2
    8e5e:	61 e0       	ldi	r22, 0x01	; 1
    8e60:	4c e3       	ldi	r20, 0x3C	; 60
    8e62:	5b e0       	ldi	r21, 0x0B	; 11
    8e64:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
	lcd_printf(3, 1, PSTR("3)Notif :     *)Exit"));
    8e68:	83 e0       	ldi	r24, 0x03	; 3
    8e6a:	61 e0       	ldi	r22, 0x01	; 1
    8e6c:	47 e2       	ldi	r20, 0x27	; 39
    8e6e:	5b e0       	ldi	r21, 0x0B	; 11
    8e70:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
   sprintf_P(lcdteks,PSTR("4)TermID:%d "),TermID);
    8e74:	00 d0       	rcall	.+0      	; 0x8e76 <_menu_host+0xbc>
    8e76:	00 d0       	rcall	.+0      	; 0x8e78 <_menu_host+0xbe>
    8e78:	00 d0       	rcall	.+0      	; 0x8e7a <_menu_host+0xc0>
    8e7a:	ed b7       	in	r30, 0x3d	; 61
    8e7c:	fe b7       	in	r31, 0x3e	; 62
    8e7e:	31 96       	adiw	r30, 0x01	; 1
    8e80:	8e 01       	movw	r16, r28
    8e82:	06 5f       	subi	r16, 0xF6	; 246
    8e84:	1f 4f       	sbci	r17, 0xFF	; 255
    8e86:	ad b7       	in	r26, 0x3d	; 61
    8e88:	be b7       	in	r27, 0x3e	; 62
    8e8a:	12 96       	adiw	r26, 0x02	; 2
    8e8c:	1c 93       	st	X, r17
    8e8e:	0e 93       	st	-X, r16
    8e90:	11 97       	sbiw	r26, 0x01	; 1
    8e92:	8a e1       	ldi	r24, 0x1A	; 26
    8e94:	9b e0       	ldi	r25, 0x0B	; 11
    8e96:	93 83       	std	Z+3, r25	; 0x03
    8e98:	82 83       	std	Z+2, r24	; 0x02
    8e9a:	80 91 d1 02 	lds	r24, 0x02D1
    8e9e:	84 83       	std	Z+4, r24	; 0x04
    8ea0:	15 82       	std	Z+5, r1	; 0x05
    8ea2:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
		 lcd_print(4, 1,lcdteks);
    8ea6:	ed b7       	in	r30, 0x3d	; 61
    8ea8:	fe b7       	in	r31, 0x3e	; 62
    8eaa:	36 96       	adiw	r30, 0x06	; 6
    8eac:	0f b6       	in	r0, 0x3f	; 63
    8eae:	f8 94       	cli
    8eb0:	fe bf       	out	0x3e, r31	; 62
    8eb2:	0f be       	out	0x3f, r0	; 63
    8eb4:	ed bf       	out	0x3d, r30	; 61
    8eb6:	84 e0       	ldi	r24, 0x04	; 4
    8eb8:	61 e0       	ldi	r22, 0x01	; 1
    8eba:	a8 01       	movw	r20, r16
    8ebc:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
	lcd_printf(4, 15, PSTR("#)Save"));
    8ec0:	84 e0       	ldi	r24, 0x04	; 4
    8ec2:	6f e0       	ldi	r22, 0x0F	; 15
    8ec4:	43 e1       	ldi	r20, 0x13	; 19
    8ec6:	5b e0       	ldi	r21, 0x0B	; 11
    8ec8:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
    8ecc:	68 ef       	ldi	r22, 0xF8	; 248
    8ece:	e6 2e       	mov	r14, r22
    8ed0:	62 e0       	ldi	r22, 0x02	; 2
    8ed2:	f6 2e       	mov	r15, r22
    8ed4:	6e 01       	movw	r12, r28
    8ed6:	08 94       	sec
    8ed8:	c1 1c       	adc	r12, r1
    8eda:	d1 1c       	adc	r13, r1

	for(__i = 0; __i < 3; __i++){
		__x = pgm_read_byte(&__hostloc[__i][0]);
		__y = pgm_read_byte(&__hostloc[__i][1]);
		_f_inttostr(__buff, __value[__i]);
    8edc:	55 e0       	ldi	r21, 0x05	; 5
    8ede:	a5 2e       	mov	r10, r21
    8ee0:	b1 2c       	mov	r11, r1
    8ee2:	ac 0e       	add	r10, r28
    8ee4:	bd 1e       	adc	r11, r29
   sprintf_P(lcdteks,PSTR("4)TermID:%d "),TermID);
		 lcd_print(4, 1,lcdteks);
	lcd_printf(4, 15, PSTR("#)Save"));

	for(__i = 0; __i < 3; __i++){
		__x = pgm_read_byte(&__hostloc[__i][0]);
    8ee6:	f7 01       	movw	r30, r14
    8ee8:	04 91       	lpm	r16, Z+
		__y = pgm_read_byte(&__hostloc[__i][1]);
    8eea:	08 94       	sec
    8eec:	e1 1c       	adc	r14, r1
    8eee:	f1 1c       	adc	r15, r1
    8ef0:	f7 01       	movw	r30, r14
    8ef2:	14 91       	lpm	r17, Z+
		_f_inttostr(__buff, __value[__i]);
    8ef4:	d6 01       	movw	r26, r12
    8ef6:	4d 91       	ld	r20, X+
    8ef8:	6d 01       	movw	r12, r26
    8efa:	50 e0       	ldi	r21, 0x00	; 0
    8efc:	60 e0       	ldi	r22, 0x00	; 0
    8efe:	70 e0       	ldi	r23, 0x00	; 0
    8f00:	c5 01       	movw	r24, r10
    8f02:	0e 94 65 19 	call	0x32ca	; 0x32ca <_f_inttostr>
		lcd_print(__x, __y, __buff);
    8f06:	80 2f       	mov	r24, r16
    8f08:	61 2f       	mov	r22, r17
    8f0a:	a5 01       	movw	r20, r10
    8f0c:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
    8f10:	08 94       	sec
    8f12:	e1 1c       	adc	r14, r1
    8f14:	f1 1c       	adc	r15, r1
	lcd_printf(3, 1, PSTR("3)Notif :     *)Exit"));
   sprintf_P(lcdteks,PSTR("4)TermID:%d "),TermID);
		 lcd_print(4, 1,lcdteks);
	lcd_printf(4, 15, PSTR("#)Save"));

	for(__i = 0; __i < 3; __i++){
    8f16:	be ef       	ldi	r27, 0xFE	; 254
    8f18:	eb 16       	cp	r14, r27
    8f1a:	b2 e0       	ldi	r27, 0x02	; 2
    8f1c:	fb 06       	cpc	r15, r27
    8f1e:	19 f7       	brne	.-58     	; 0x8ee6 <_menu_host+0x12c>
			lcd_print(__x, __y, __buff);
		}else
		if (__num=='4'){
		    if (TermID<=99)TermID++;
			else TermID=1;
	     sprintf_P(lcdteks,PSTR("4)TermID:%d "),TermID);
    8f20:	4a e0       	ldi	r20, 0x0A	; 10
    8f22:	a4 2e       	mov	r10, r20
    8f24:	b1 2c       	mov	r11, r1
    8f26:	ac 0e       	add	r10, r28
    8f28:	bd 1e       	adc	r11, r29
    8f2a:	36 e0       	ldi	r19, 0x06	; 6
    8f2c:	83 2e       	mov	r8, r19
    8f2e:	3b e0       	ldi	r19, 0x0B	; 11
    8f30:	93 2e       	mov	r9, r19
			eeprom_write_byte(&DefNotifScreen, __value[2]);
			eeprom_write_byte(&DefIFT_ID,TermID);
			break;
		}
		if(__num >= 0x31 && __num <= 0x33){
			if(__value[__num - 0x31] == 1)
    8f32:	6e 01       	movw	r12, r28
    8f34:	08 94       	sec
    8f36:	c1 1c       	adc	r12, r1
    8f38:	d1 1c       	adc	r13, r1
				__value[__num - 0x31] = 0;
			else
				__value[__num - 0x31]++;
			__x = pgm_read_byte(&__hostloc[__num - 0x31][0]);
			__y = pgm_read_byte(&__hostloc[__num - 0x31][1]);
			_f_inttostr(__buff, __value[__num - 0x31]);
    8f3a:	25 e0       	ldi	r18, 0x05	; 5
    8f3c:	e2 2e       	mov	r14, r18
    8f3e:	f1 2c       	mov	r15, r1
    8f40:	ec 0e       	add	r14, r28
    8f42:	fd 1e       	adc	r15, r29
		_f_inttostr(__buff, __value[__i]);
		lcd_print(__x, __y, __buff);
	}

	while(1){
		__key = _key_scan(1);
    8f44:	81 e0       	ldi	r24, 0x01	; 1
    8f46:	0e 94 06 b0 	call	0x1600c	; 0x1600c <_key_scan>
    8f4a:	18 2f       	mov	r17, r24
		__num = _key_btn(__key);
    8f4c:	0e 94 67 af 	call	0x15ece	; 0x15ece <_key_btn>
    8f50:	98 2f       	mov	r25, r24

		if(__key == _KEY_CANCEL)
    8f52:	17 3e       	cpi	r17, 0xE7	; 231
    8f54:	09 f4       	brne	.+2      	; 0x8f58 <_menu_host+0x19e>
    8f56:	95 c0       	rjmp	.+298    	; 0x9082 <_menu_host+0x2c8>
			return;
		if(__key==_KEY_ENTER){
    8f58:	17 3b       	cpi	r17, 0xB7	; 183
    8f5a:	09 f0       	breq	.+2      	; 0x8f5e <_menu_host+0x1a4>
    8f5c:	30 c0       	rjmp	.+96     	; 0x8fbe <_menu_host+0x204>
			eeprom_write_byte(&DefPrintMoney, __value[0]);
    8f5e:	89 81       	ldd	r24, Y+1	; 0x01
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    8f60:	e1 99       	sbic	0x1c, 1	; 28
    8f62:	fe cf       	rjmp	.-4      	; 0x8f60 <_menu_host+0x1a6>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    8f64:	e1 ec       	ldi	r30, 0xC1	; 193
    8f66:	f3 e0       	ldi	r31, 0x03	; 3
    8f68:	ff bb       	out	0x1f, r31	; 31
    8f6a:	ee bb       	out	0x1e, r30	; 30
#endif
    EEDR = __value;
    8f6c:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    8f6e:	0f b6       	in	r0, 0x3f	; 63
    8f70:	f8 94       	cli
    8f72:	e2 9a       	sbi	0x1c, 2	; 28
    8f74:	e1 9a       	sbi	0x1c, 1	; 28
    8f76:	0f be       	out	0x3f, r0	; 63
			eeprom_write_byte(&DefShowDateTime, __value[1]);
    8f78:	8a 81       	ldd	r24, Y+2	; 0x02
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    8f7a:	e1 99       	sbic	0x1c, 1	; 28
    8f7c:	fe cf       	rjmp	.-4      	; 0x8f7a <_menu_host+0x1c0>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    8f7e:	3f ba       	out	0x1f, r3	; 31
    8f80:	2e ba       	out	0x1e, r2	; 30
#endif
    EEDR = __value;
    8f82:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    8f84:	0f b6       	in	r0, 0x3f	; 63
    8f86:	f8 94       	cli
    8f88:	e2 9a       	sbi	0x1c, 2	; 28
    8f8a:	e1 9a       	sbi	0x1c, 1	; 28
    8f8c:	0f be       	out	0x3f, r0	; 63
			eeprom_write_byte(&DefNotifScreen, __value[2]);
    8f8e:	8b 81       	ldd	r24, Y+3	; 0x03
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    8f90:	e1 99       	sbic	0x1c, 1	; 28
    8f92:	fe cf       	rjmp	.-4      	; 0x8f90 <_menu_host+0x1d6>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    8f94:	5f ba       	out	0x1f, r5	; 31
    8f96:	4e ba       	out	0x1e, r4	; 30
#endif
    EEDR = __value;
    8f98:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    8f9a:	0f b6       	in	r0, 0x3f	; 63
    8f9c:	f8 94       	cli
    8f9e:	e2 9a       	sbi	0x1c, 2	; 28
    8fa0:	e1 9a       	sbi	0x1c, 1	; 28
    8fa2:	0f be       	out	0x3f, r0	; 63
			eeprom_write_byte(&DefIFT_ID,TermID);
    8fa4:	80 91 d1 02 	lds	r24, 0x02D1
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    8fa8:	e1 99       	sbic	0x1c, 1	; 28
    8faa:	fe cf       	rjmp	.-4      	; 0x8fa8 <_menu_host+0x1ee>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    8fac:	7f ba       	out	0x1f, r7	; 31
    8fae:	6e ba       	out	0x1e, r6	; 30
#endif
    EEDR = __value;
    8fb0:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    8fb2:	0f b6       	in	r0, 0x3f	; 63
    8fb4:	f8 94       	cli
    8fb6:	e2 9a       	sbi	0x1c, 2	; 28
    8fb8:	e1 9a       	sbi	0x1c, 1	; 28
    8fba:	0f be       	out	0x3f, r0	; 63
    8fbc:	62 c0       	rjmp	.+196    	; 0x9082 <_menu_host+0x2c8>
			break;
		}
		if(__num >= 0x31 && __num <= 0x33){
    8fbe:	81 53       	subi	r24, 0x31	; 49
    8fc0:	83 30       	cpi	r24, 0x03	; 3
    8fc2:	58 f5       	brcc	.+86     	; 0x901a <_menu_host+0x260>
			if(__value[__num - 0x31] == 1)
    8fc4:	a9 2f       	mov	r26, r25
    8fc6:	b0 e0       	ldi	r27, 0x00	; 0
    8fc8:	d1 97       	sbiw	r26, 0x31	; 49
    8fca:	f6 01       	movw	r30, r12
    8fcc:	ea 0f       	add	r30, r26
    8fce:	fb 1f       	adc	r31, r27
    8fd0:	80 81       	ld	r24, Z
    8fd2:	81 30       	cpi	r24, 0x01	; 1
    8fd4:	11 f4       	brne	.+4      	; 0x8fda <_menu_host+0x220>
				__value[__num - 0x31] = 0;
    8fd6:	10 82       	st	Z, r1
    8fd8:	02 c0       	rjmp	.+4      	; 0x8fde <_menu_host+0x224>
			else
				__value[__num - 0x31]++;
    8fda:	8f 5f       	subi	r24, 0xFF	; 255
    8fdc:	80 83       	st	Z, r24
			__x = pgm_read_byte(&__hostloc[__num - 0x31][0]);
    8fde:	29 2f       	mov	r18, r25
    8fe0:	30 e0       	ldi	r19, 0x00	; 0
    8fe2:	21 53       	subi	r18, 0x31	; 49
    8fe4:	30 40       	sbci	r19, 0x00	; 0
    8fe6:	22 0f       	add	r18, r18
    8fe8:	33 1f       	adc	r19, r19
    8fea:	c9 01       	movw	r24, r18
    8fec:	88 50       	subi	r24, 0x08	; 8
    8fee:	9d 4f       	sbci	r25, 0xFD	; 253
    8ff0:	fc 01       	movw	r30, r24
    8ff2:	04 91       	lpm	r16, Z+
			__y = pgm_read_byte(&__hostloc[__num - 0x31][1]);
    8ff4:	27 50       	subi	r18, 0x07	; 7
    8ff6:	3d 4f       	sbci	r19, 0xFD	; 253
    8ff8:	f9 01       	movw	r30, r18
    8ffa:	14 91       	lpm	r17, Z+
			_f_inttostr(__buff, __value[__num - 0x31]);
    8ffc:	ac 0d       	add	r26, r12
    8ffe:	bd 1d       	adc	r27, r13
    9000:	4c 91       	ld	r20, X
    9002:	50 e0       	ldi	r21, 0x00	; 0
    9004:	60 e0       	ldi	r22, 0x00	; 0
    9006:	70 e0       	ldi	r23, 0x00	; 0
    9008:	c7 01       	movw	r24, r14
    900a:	0e 94 65 19 	call	0x32ca	; 0x32ca <_f_inttostr>
			lcd_print(__x, __y, __buff);
    900e:	80 2f       	mov	r24, r16
    9010:	61 2f       	mov	r22, r17
    9012:	a7 01       	movw	r20, r14
    9014:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
    9018:	95 cf       	rjmp	.-214    	; 0x8f44 <_menu_host+0x18a>
		}else
		if (__num=='4'){
    901a:	94 33       	cpi	r25, 0x34	; 52
    901c:	09 f0       	breq	.+2      	; 0x9020 <_menu_host+0x266>
    901e:	92 cf       	rjmp	.-220    	; 0x8f44 <_menu_host+0x18a>
		    if (TermID<=99)TermID++;
    9020:	80 91 d1 02 	lds	r24, 0x02D1
    9024:	84 36       	cpi	r24, 0x64	; 100
    9026:	10 f4       	brcc	.+4      	; 0x902c <_menu_host+0x272>
    9028:	8f 5f       	subi	r24, 0xFF	; 255
    902a:	01 c0       	rjmp	.+2      	; 0x902e <_menu_host+0x274>
			else TermID=1;
    902c:	81 e0       	ldi	r24, 0x01	; 1
    902e:	80 93 d1 02 	sts	0x02D1, r24
	     sprintf_P(lcdteks,PSTR("4)TermID:%d "),TermID);
    9032:	00 d0       	rcall	.+0      	; 0x9034 <_menu_host+0x27a>
    9034:	00 d0       	rcall	.+0      	; 0x9036 <_menu_host+0x27c>
    9036:	00 d0       	rcall	.+0      	; 0x9038 <_menu_host+0x27e>
    9038:	ed b7       	in	r30, 0x3d	; 61
    903a:	fe b7       	in	r31, 0x3e	; 62
    903c:	31 96       	adiw	r30, 0x01	; 1
    903e:	ad b7       	in	r26, 0x3d	; 61
    9040:	be b7       	in	r27, 0x3e	; 62
    9042:	12 96       	adiw	r26, 0x02	; 2
    9044:	bc 92       	st	X, r11
    9046:	ae 92       	st	-X, r10
    9048:	11 97       	sbiw	r26, 0x01	; 1
    904a:	93 82       	std	Z+3, r9	; 0x03
    904c:	82 82       	std	Z+2, r8	; 0x02
    904e:	80 91 d1 02 	lds	r24, 0x02D1
    9052:	84 83       	std	Z+4, r24	; 0x04
    9054:	15 82       	std	Z+5, r1	; 0x05
    9056:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
		 lcd_print(4, 1,lcdteks);lcd_printf(4, 15, PSTR("#)Save"));
    905a:	ed b7       	in	r30, 0x3d	; 61
    905c:	fe b7       	in	r31, 0x3e	; 62
    905e:	36 96       	adiw	r30, 0x06	; 6
    9060:	0f b6       	in	r0, 0x3f	; 63
    9062:	f8 94       	cli
    9064:	fe bf       	out	0x3e, r31	; 62
    9066:	0f be       	out	0x3f, r0	; 63
    9068:	ed bf       	out	0x3d, r30	; 61
    906a:	84 e0       	ldi	r24, 0x04	; 4
    906c:	61 e0       	ldi	r22, 0x01	; 1
    906e:	a5 01       	movw	r20, r10
    9070:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
    9074:	84 e0       	ldi	r24, 0x04	; 4
    9076:	6f e0       	ldi	r22, 0x0F	; 15
    9078:	4f ef       	ldi	r20, 0xFF	; 255
    907a:	5a e0       	ldi	r21, 0x0A	; 10
    907c:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
    9080:	61 cf       	rjmp	.-318    	; 0x8f44 <_menu_host+0x18a>
		 
		}

	}
}
    9082:	6d 96       	adiw	r28, 0x1d	; 29
    9084:	0f b6       	in	r0, 0x3f	; 63
    9086:	f8 94       	cli
    9088:	de bf       	out	0x3e, r29	; 62
    908a:	0f be       	out	0x3f, r0	; 63
    908c:	cd bf       	out	0x3d, r28	; 61
    908e:	cf 91       	pop	r28
    9090:	df 91       	pop	r29
    9092:	1f 91       	pop	r17
    9094:	0f 91       	pop	r16
    9096:	ff 90       	pop	r15
    9098:	ef 90       	pop	r14
    909a:	df 90       	pop	r13
    909c:	cf 90       	pop	r12
    909e:	bf 90       	pop	r11
    90a0:	af 90       	pop	r10
    90a2:	9f 90       	pop	r9
    90a4:	8f 90       	pop	r8
    90a6:	7f 90       	pop	r7
    90a8:	6f 90       	pop	r6
    90aa:	5f 90       	pop	r5
    90ac:	4f 90       	pop	r4
    90ae:	3f 90       	pop	r3
    90b0:	2f 90       	pop	r2
    90b2:	08 95       	ret

000090b4 <FSettingHost>:
char FSettingPrinter(){
     _menu_printer();
	 return MENU_DONE;
}
char FSettingHost(){
     _menu_host();
    90b4:	0e 94 dd 46 	call	0x8dba	; 0x8dba <_menu_host>
	 return MENU_DONE;
}
    90b8:	81 e0       	ldi	r24, 0x01	; 1
    90ba:	08 95       	ret

000090bc <_menu_pumpprodinput>:
//**********************************************************************
// subrutin merubah produk
// parameter di simpan di __pump_prod
//**********************************************************************

void _menu_pumpprodinput(unsigned char __select){
    90bc:	8f 92       	push	r8
    90be:	9f 92       	push	r9
    90c0:	af 92       	push	r10
    90c2:	bf 92       	push	r11
    90c4:	cf 92       	push	r12
    90c6:	df 92       	push	r13
    90c8:	ef 92       	push	r14
    90ca:	ff 92       	push	r15
    90cc:	0f 93       	push	r16
    90ce:	1f 93       	push	r17
    90d0:	df 93       	push	r29
    90d2:	cf 93       	push	r28
    90d4:	cd b7       	in	r28, 0x3d	; 61
    90d6:	de b7       	in	r29, 0x3e	; 62
    90d8:	a7 97       	sbiw	r28, 0x27	; 39
    90da:	0f b6       	in	r0, 0x3f	; 63
    90dc:	f8 94       	cli
    90de:	de bf       	out	0x3e, r29	; 62
    90e0:	0f be       	out	0x3f, r0	; 63
    90e2:	cd bf       	out	0x3d, r28	; 61
    90e4:	b8 2e       	mov	r11, r24
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    90e6:	8e 01       	movw	r16, r28
    90e8:	04 5f       	subi	r16, 0xF4	; 244
    90ea:	1f 4f       	sbci	r17, 0xFF	; 255
    90ec:	c8 01       	movw	r24, r16
    90ee:	65 e4       	ldi	r22, 0x45	; 69
    90f0:	70 e0       	ldi	r23, 0x00	; 0
    90f2:	48 e0       	ldi	r20, 0x08	; 8
    90f4:	50 e0       	ldi	r21, 0x00	; 0
    90f6:	26 ef       	ldi	r18, 0xF6	; 246
    90f8:	32 e1       	ldi	r19, 0x12	; 18
    90fa:	0e 94 7a b5 	call	0x16af4	; 0x16af4 <__eerd_block>
	char 			__pump_prod[6],__pump_id[8];
	unsigned char	__i, __x, __y, __key, __num, __buff[5];
	char lcdteks[20];

	eeprom_read_block((void*) &__pump_id, (const void*) &DefPumpMap, 8);
	eeprom_read_block((void*) &__pump_prod, (const void*) &DefNozzleMap[__select], 6);
    90fe:	86 e0       	ldi	r24, 0x06	; 6
    9100:	b8 9e       	mul	r11, r24
    9102:	40 01       	movw	r8, r0
    9104:	11 24       	eor	r1, r1
    9106:	85 e5       	ldi	r24, 0x55	; 85
    9108:	90 e0       	ldi	r25, 0x00	; 0
    910a:	88 0e       	add	r8, r24
    910c:	99 1e       	adc	r9, r25
    910e:	26 e0       	ldi	r18, 0x06	; 6
    9110:	c2 2e       	mov	r12, r18
    9112:	d1 2c       	mov	r13, r1
    9114:	cc 0e       	add	r12, r28
    9116:	dd 1e       	adc	r13, r29
    9118:	c6 01       	movw	r24, r12
    911a:	b4 01       	movw	r22, r8
    911c:	46 e0       	ldi	r20, 0x06	; 6
    911e:	50 e0       	ldi	r21, 0x00	; 0
    9120:	26 ef       	ldi	r18, 0xF6	; 246
    9122:	32 e1       	ldi	r19, 0x12	; 18
    9124:	0e 94 7a b5 	call	0x16af4	; 0x16af4 <__eerd_block>

	lcd_clear();_delay_ms(10);
    9128:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
    912c:	84 ec       	ldi	r24, 0xC4	; 196
    912e:	99 e0       	ldi	r25, 0x09	; 9
    9130:	01 97       	sbiw	r24, 0x01	; 1
    9132:	f1 f7       	brne	.-4      	; 0x9130 <_menu_pumpprodinput+0x74>
    sprintf_P(lcdteks, PSTR("Product FIP%.2d"),__pump_id[__select]);
    9134:	00 d0       	rcall	.+0      	; 0x9136 <_menu_pumpprodinput+0x7a>
    9136:	00 d0       	rcall	.+0      	; 0x9138 <_menu_pumpprodinput+0x7c>
    9138:	00 d0       	rcall	.+0      	; 0x913a <_menu_pumpprodinput+0x7e>
    913a:	ed b7       	in	r30, 0x3d	; 61
    913c:	fe b7       	in	r31, 0x3e	; 62
    913e:	31 96       	adiw	r30, 0x01	; 1
    9140:	94 e1       	ldi	r25, 0x14	; 20
    9142:	e9 2e       	mov	r14, r25
    9144:	f1 2c       	mov	r15, r1
    9146:	ec 0e       	add	r14, r28
    9148:	fd 1e       	adc	r15, r29
    914a:	ad b7       	in	r26, 0x3d	; 61
    914c:	be b7       	in	r27, 0x3e	; 62
    914e:	12 96       	adiw	r26, 0x02	; 2
    9150:	fc 92       	st	X, r15
    9152:	ee 92       	st	-X, r14
    9154:	11 97       	sbiw	r26, 0x01	; 1
    9156:	88 ef       	ldi	r24, 0xF8	; 248
    9158:	9b e0       	ldi	r25, 0x0B	; 11
    915a:	93 83       	std	Z+3, r25	; 0x03
    915c:	82 83       	std	Z+2, r24	; 0x02
    915e:	0b 0d       	add	r16, r11
    9160:	11 1d       	adc	r17, r1
    9162:	d8 01       	movw	r26, r16
    9164:	8c 91       	ld	r24, X
    9166:	84 83       	std	Z+4, r24	; 0x04
    9168:	15 82       	std	Z+5, r1	; 0x05
    916a:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    lcd_print(1, 1,lcdteks);
    916e:	ed b7       	in	r30, 0x3d	; 61
    9170:	fe b7       	in	r31, 0x3e	; 62
    9172:	36 96       	adiw	r30, 0x06	; 6
    9174:	0f b6       	in	r0, 0x3f	; 63
    9176:	f8 94       	cli
    9178:	fe bf       	out	0x3e, r31	; 62
    917a:	0f be       	out	0x3f, r0	; 63
    917c:	ed bf       	out	0x3d, r30	; 61
    917e:	81 e0       	ldi	r24, 0x01	; 1
    9180:	61 e0       	ldi	r22, 0x01	; 1
    9182:	a7 01       	movw	r20, r14
    9184:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>

	lcd_printf(2, 1, PSTR("1)N1:  3)N3:  5)N5:"));
    9188:	82 e0       	ldi	r24, 0x02	; 2
    918a:	61 e0       	ldi	r22, 0x01	; 1
    918c:	44 ee       	ldi	r20, 0xE4	; 228
    918e:	5b e0       	ldi	r21, 0x0B	; 11
    9190:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
	lcd_printf(3, 1, PSTR("2)N2:  4)N4:  6)N6:"));
    9194:	83 e0       	ldi	r24, 0x03	; 3
    9196:	61 e0       	ldi	r22, 0x01	; 1
    9198:	40 ed       	ldi	r20, 0xD0	; 208
    919a:	5b e0       	ldi	r21, 0x0B	; 11
    919c:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
	lcd_printf(4, 1, PSTR("*)Exit        #)Save"));
    91a0:	84 e0       	ldi	r24, 0x04	; 4
    91a2:	61 e0       	ldi	r22, 0x01	; 1
    91a4:	4b eb       	ldi	r20, 0xBB	; 187
    91a6:	5b e0       	ldi	r21, 0x0B	; 11
    91a8:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
    91ac:	84 ed       	ldi	r24, 0xD4	; 212
    91ae:	e8 2e       	mov	r14, r24
    91b0:	82 e0       	ldi	r24, 0x02	; 2
    91b2:	f8 2e       	mov	r15, r24

	for(__i = 0; __i < 6; __i++){
		__x = pgm_read_byte(&__prodloc[__i][0]);
		__y = pgm_read_byte(&__prodloc[__i][1]);
		_f_inttostr(__buff, __pump_prod[__i]);
    91b4:	5e 01       	movw	r10, r28
    91b6:	08 94       	sec
    91b8:	a1 1c       	adc	r10, r1
    91ba:	b1 1c       	adc	r11, r1
	lcd_printf(2, 1, PSTR("1)N1:  3)N3:  5)N5:"));
	lcd_printf(3, 1, PSTR("2)N2:  4)N4:  6)N6:"));
	lcd_printf(4, 1, PSTR("*)Exit        #)Save"));

	for(__i = 0; __i < 6; __i++){
		__x = pgm_read_byte(&__prodloc[__i][0]);
    91bc:	f7 01       	movw	r30, r14
    91be:	04 91       	lpm	r16, Z+
		__y = pgm_read_byte(&__prodloc[__i][1]);
    91c0:	08 94       	sec
    91c2:	e1 1c       	adc	r14, r1
    91c4:	f1 1c       	adc	r15, r1
    91c6:	f7 01       	movw	r30, r14
    91c8:	14 91       	lpm	r17, Z+
		_f_inttostr(__buff, __pump_prod[__i]);
    91ca:	d6 01       	movw	r26, r12
    91cc:	4d 91       	ld	r20, X+
    91ce:	6d 01       	movw	r12, r26
    91d0:	50 e0       	ldi	r21, 0x00	; 0
    91d2:	60 e0       	ldi	r22, 0x00	; 0
    91d4:	70 e0       	ldi	r23, 0x00	; 0
    91d6:	c5 01       	movw	r24, r10
    91d8:	0e 94 65 19 	call	0x32ca	; 0x32ca <_f_inttostr>
		lcd_print(__x+1, __y, __buff);
    91dc:	80 2f       	mov	r24, r16
    91de:	8f 5f       	subi	r24, 0xFF	; 255
    91e0:	61 2f       	mov	r22, r17
    91e2:	a5 01       	movw	r20, r10
    91e4:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
    91e8:	08 94       	sec
    91ea:	e1 1c       	adc	r14, r1
    91ec:	f1 1c       	adc	r15, r1

	lcd_printf(2, 1, PSTR("1)N1:  3)N3:  5)N5:"));
	lcd_printf(3, 1, PSTR("2)N2:  4)N4:  6)N6:"));
	lcd_printf(4, 1, PSTR("*)Exit        #)Save"));

	for(__i = 0; __i < 6; __i++){
    91ee:	b0 ee       	ldi	r27, 0xE0	; 224
    91f0:	eb 16       	cp	r14, r27
    91f2:	b2 e0       	ldi	r27, 0x02	; 2
    91f4:	fb 06       	cpc	r15, r27
    91f6:	11 f7       	brne	.-60     	; 0x91bc <_menu_pumpprodinput+0x100>
		if(__key == _KEY_ENTER){
			eeprom_write_block((const void*) &__pump_prod, (void*) &DefNozzleMap[__select], 6);
			return;
		}
		if(__num >= '1' && __num <= '6'){
			if(__pump_prod[__num - '1'] == 6)
    91f8:	06 e0       	ldi	r16, 0x06	; 6
    91fa:	c0 2e       	mov	r12, r16
    91fc:	d1 2c       	mov	r13, r1
    91fe:	cc 0e       	add	r12, r28
    9200:	dd 1e       	adc	r13, r29
			else
				__pump_prod[__num - '1']++;

			__x = pgm_read_byte(&__prodloc[__num - 0x31][0]);
			__y = pgm_read_byte(&__prodloc[__num - 0x31][1]);
			_f_inttostr(__buff, __pump_prod[__num - 0x31]);
    9202:	7e 01       	movw	r14, r28
    9204:	08 94       	sec
    9206:	e1 1c       	adc	r14, r1
    9208:	f1 1c       	adc	r15, r1
		lcd_print(__x+1, __y, __buff);
	}

	while(1){
		
		__key = _key_scan(1);
    920a:	81 e0       	ldi	r24, 0x01	; 1
    920c:	0e 94 06 b0 	call	0x1600c	; 0x1600c <_key_scan>
    9210:	18 2f       	mov	r17, r24
		__num = _key_btn(__key);
    9212:	0e 94 67 af 	call	0x15ece	; 0x15ece <_key_btn>
    9216:	98 2f       	mov	r25, r24
		if(__key == _KEY_CANCEL)
    9218:	17 3e       	cpi	r17, 0xE7	; 231
    921a:	09 f4       	brne	.+2      	; 0x921e <_menu_pumpprodinput+0x162>
    921c:	3c c0       	rjmp	.+120    	; 0x9296 <_menu_pumpprodinput+0x1da>
			return;
		if(__key == _KEY_ENTER){
    921e:	17 3b       	cpi	r17, 0xB7	; 183
    9220:	59 f4       	brne	.+22     	; 0x9238 <_menu_pumpprodinput+0x17c>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    9222:	c4 01       	movw	r24, r8
    9224:	be 01       	movw	r22, r28
    9226:	6a 5f       	subi	r22, 0xFA	; 250
    9228:	7f 4f       	sbci	r23, 0xFF	; 255
    922a:	46 e0       	ldi	r20, 0x06	; 6
    922c:	50 e0       	ldi	r21, 0x00	; 0
    922e:	2e ef       	ldi	r18, 0xFE	; 254
    9230:	32 e1       	ldi	r19, 0x12	; 18
    9232:	0e 94 96 b5 	call	0x16b2c	; 0x16b2c <__eewr_block>
    9236:	2f c0       	rjmp	.+94     	; 0x9296 <_menu_pumpprodinput+0x1da>
			eeprom_write_block((const void*) &__pump_prod, (void*) &DefNozzleMap[__select], 6);
			return;
		}
		if(__num >= '1' && __num <= '6'){
    9238:	81 53       	subi	r24, 0x31	; 49
    923a:	86 30       	cpi	r24, 0x06	; 6
    923c:	30 f7       	brcc	.-52     	; 0x920a <_menu_pumpprodinput+0x14e>
			if(__pump_prod[__num - '1'] == 6)
    923e:	a9 2f       	mov	r26, r25
    9240:	b0 e0       	ldi	r27, 0x00	; 0
    9242:	d1 97       	sbiw	r26, 0x31	; 49
    9244:	f6 01       	movw	r30, r12
    9246:	ea 0f       	add	r30, r26
    9248:	fb 1f       	adc	r31, r27
    924a:	80 81       	ld	r24, Z
    924c:	86 30       	cpi	r24, 0x06	; 6
    924e:	11 f4       	brne	.+4      	; 0x9254 <_menu_pumpprodinput+0x198>
				__pump_prod[__num - '1'] = 0;
    9250:	10 82       	st	Z, r1
    9252:	02 c0       	rjmp	.+4      	; 0x9258 <_menu_pumpprodinput+0x19c>
			else
				__pump_prod[__num - '1']++;
    9254:	8f 5f       	subi	r24, 0xFF	; 255
    9256:	80 83       	st	Z, r24

			__x = pgm_read_byte(&__prodloc[__num - 0x31][0]);
    9258:	29 2f       	mov	r18, r25
    925a:	30 e0       	ldi	r19, 0x00	; 0
    925c:	21 53       	subi	r18, 0x31	; 49
    925e:	30 40       	sbci	r19, 0x00	; 0
    9260:	22 0f       	add	r18, r18
    9262:	33 1f       	adc	r19, r19
    9264:	c9 01       	movw	r24, r18
    9266:	8c 52       	subi	r24, 0x2C	; 44
    9268:	9d 4f       	sbci	r25, 0xFD	; 253
    926a:	fc 01       	movw	r30, r24
    926c:	04 91       	lpm	r16, Z+
			__y = pgm_read_byte(&__prodloc[__num - 0x31][1]);
    926e:	2b 52       	subi	r18, 0x2B	; 43
    9270:	3d 4f       	sbci	r19, 0xFD	; 253
    9272:	f9 01       	movw	r30, r18
    9274:	14 91       	lpm	r17, Z+
			_f_inttostr(__buff, __pump_prod[__num - 0x31]);
    9276:	ac 0d       	add	r26, r12
    9278:	bd 1d       	adc	r27, r13
    927a:	4c 91       	ld	r20, X
    927c:	50 e0       	ldi	r21, 0x00	; 0
    927e:	60 e0       	ldi	r22, 0x00	; 0
    9280:	70 e0       	ldi	r23, 0x00	; 0
    9282:	c7 01       	movw	r24, r14
    9284:	0e 94 65 19 	call	0x32ca	; 0x32ca <_f_inttostr>
			lcd_print(__x+1, __y, __buff);
    9288:	80 2f       	mov	r24, r16
    928a:	8f 5f       	subi	r24, 0xFF	; 255
    928c:	61 2f       	mov	r22, r17
    928e:	a7 01       	movw	r20, r14
    9290:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
    9294:	ba cf       	rjmp	.-140    	; 0x920a <_menu_pumpprodinput+0x14e>
		}
	}
}
    9296:	a7 96       	adiw	r28, 0x27	; 39
    9298:	0f b6       	in	r0, 0x3f	; 63
    929a:	f8 94       	cli
    929c:	de bf       	out	0x3e, r29	; 62
    929e:	0f be       	out	0x3f, r0	; 63
    92a0:	cd bf       	out	0x3d, r28	; 61
    92a2:	cf 91       	pop	r28
    92a4:	df 91       	pop	r29
    92a6:	1f 91       	pop	r17
    92a8:	0f 91       	pop	r16
    92aa:	ff 90       	pop	r15
    92ac:	ef 90       	pop	r14
    92ae:	df 90       	pop	r13
    92b0:	cf 90       	pop	r12
    92b2:	bf 90       	pop	r11
    92b4:	af 90       	pop	r10
    92b6:	9f 90       	pop	r9
    92b8:	8f 90       	pop	r8
    92ba:	08 95       	ret

000092bc <_menu_pumpprod>:
	       break;
	   }	   
	}
}

void _menu_pumpprod(void){
    92bc:	cf 93       	push	r28
    92be:	df 93       	push	r29
    92c0:	c4 ec       	ldi	r28, 0xC4	; 196
    92c2:	d9 e0       	ldi	r29, 0x09	; 9
	char __key;
	//char __pump_id[8];
	while(1){
		lcd_clear();_delay_ms(10);
    92c4:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
    92c8:	ce 01       	movw	r24, r28
    92ca:	01 97       	sbiw	r24, 0x01	; 1
    92cc:	f1 f7       	brne	.-4      	; 0x92ca <_menu_pumpprod+0xe>
		_scr_pump();
    92ce:	0e 94 53 46 	call	0x8ca6	; 0x8ca6 <_scr_pump>
		while(1){
			__key = _key_scan(1);
    92d2:	81 e0       	ldi	r24, 0x01	; 1
    92d4:	0e 94 06 b0 	call	0x1600c	; 0x1600c <_key_scan>
			if( __key == _KEY_1 || __key == _KEY_2 || __key == _KEY_3 ||
    92d8:	8e 3e       	cpi	r24, 0xEE	; 238
    92da:	71 f0       	breq	.+28     	; 0x92f8 <_menu_pumpprod+0x3c>
    92dc:	8e 3d       	cpi	r24, 0xDE	; 222
    92de:	61 f0       	breq	.+24     	; 0x92f8 <_menu_pumpprod+0x3c>
    92e0:	8e 3b       	cpi	r24, 0xBE	; 190
    92e2:	51 f0       	breq	.+20     	; 0x92f8 <_menu_pumpprod+0x3c>
    92e4:	8d 3e       	cpi	r24, 0xED	; 237
    92e6:	41 f0       	breq	.+16     	; 0x92f8 <_menu_pumpprod+0x3c>
    92e8:	8d 3d       	cpi	r24, 0xDD	; 221
    92ea:	31 f0       	breq	.+12     	; 0x92f8 <_menu_pumpprod+0x3c>
    92ec:	8d 3b       	cpi	r24, 0xBD	; 189
    92ee:	21 f0       	breq	.+8      	; 0x92f8 <_menu_pumpprod+0x3c>
    92f0:	8b 3e       	cpi	r24, 0xEB	; 235
    92f2:	11 f0       	breq	.+4      	; 0x92f8 <_menu_pumpprod+0x3c>
    92f4:	8b 3d       	cpi	r24, 0xDB	; 219
    92f6:	31 f4       	brne	.+12     	; 0x9304 <_menu_pumpprod+0x48>
				__key == _KEY_4 || __key == _KEY_5 || __key == _KEY_6 ||
				__key == _KEY_7 || __key == _KEY_8){
				_menu_pumpprodinput(_key_btn(__key) - 0x31);
    92f8:	0e 94 67 af 	call	0x15ece	; 0x15ece <_key_btn>
    92fc:	81 53       	subi	r24, 0x31	; 49
    92fe:	0e 94 5e 48 	call	0x90bc	; 0x90bc <_menu_pumpprodinput>
    9302:	e0 cf       	rjmp	.-64     	; 0x92c4 <_menu_pumpprod+0x8>
				break;
			}
			if(__key == _KEY_CANCEL)
    9304:	87 3e       	cpi	r24, 0xE7	; 231
    9306:	29 f7       	brne	.-54     	; 0x92d2 <_menu_pumpprod+0x16>
				return;
		}
	}
}
    9308:	df 91       	pop	r29
    930a:	cf 91       	pop	r28
    930c:	08 95       	ret

0000930e <FMenuPumpLabel>:
		       break;		         
	      }
	 }     
}

void FMenuPumpLabel(){
    930e:	6f 92       	push	r6
    9310:	7f 92       	push	r7
    9312:	8f 92       	push	r8
    9314:	9f 92       	push	r9
    9316:	af 92       	push	r10
    9318:	bf 92       	push	r11
    931a:	cf 92       	push	r12
    931c:	df 92       	push	r13
    931e:	ef 92       	push	r14
    9320:	ff 92       	push	r15
    9322:	1f 93       	push	r17
    9324:	df 93       	push	r29
    9326:	cf 93       	push	r28
    9328:	cd b7       	in	r28, 0x3d	; 61
    932a:	de b7       	in	r29, 0x3e	; 62
    932c:	2d 97       	sbiw	r28, 0x0d	; 13
    932e:	0f b6       	in	r0, 0x3f	; 63
    9330:	f8 94       	cli
    9332:	de bf       	out	0x3e, r29	; 62
    9334:	0f be       	out	0x3f, r0	; 63
    9336:	cd bf       	out	0x3d, r28	; 61
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    9338:	76 e0       	ldi	r23, 0x06	; 6
    933a:	c7 2e       	mov	r12, r23
    933c:	d1 2c       	mov	r13, r1
    933e:	cc 0e       	add	r12, r28
    9340:	dd 1e       	adc	r13, r29
    9342:	c6 01       	movw	r24, r12
    9344:	6d e4       	ldi	r22, 0x4D	; 77
    9346:	70 e0       	ldi	r23, 0x00	; 0
    9348:	48 e0       	ldi	r20, 0x08	; 8
    934a:	50 e0       	ldi	r21, 0x00	; 0
    934c:	26 ef       	ldi	r18, 0xF6	; 246
    934e:	32 e1       	ldi	r19, 0x12	; 18
    9350:	0e 94 7a b5 	call	0x16af4	; 0x16af4 <__eerd_block>
	char PPumpLabel[8];
	unsigned char i, xPos,yPos,KeyPressed,KeyChar,strLabel[5];
	static char MaxCountId=16;

	eeprom_read_block((void*) &PPumpLabel, (const void*) &DefPumpLabel, 8);
	MaxCountId=99;
    9354:	83 e6       	ldi	r24, 0x63	; 99
    9356:	80 93 56 01 	sts	0x0156, r24
	lcd_clear();_delay_ms(10);
    935a:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
    935e:	84 ec       	ldi	r24, 0xC4	; 196
    9360:	99 e0       	ldi	r25, 0x09	; 9
    9362:	01 97       	sbiw	r24, 0x01	; 1
    9364:	f1 f7       	brne	.-4      	; 0x9362 <FMenuPumpLabel+0x54>
	lcd_printf(1, 1, PSTR("1)1:   5)5:"));
    9366:	81 e0       	ldi	r24, 0x01	; 1
    9368:	61 e0       	ldi	r22, 0x01	; 1
    936a:	43 ef       	ldi	r20, 0xF3	; 243
    936c:	5c e0       	ldi	r21, 0x0C	; 12
    936e:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
	lcd_printf(2, 1, PSTR("2)2:   6)6:"));
    9372:	82 e0       	ldi	r24, 0x02	; 2
    9374:	61 e0       	ldi	r22, 0x01	; 1
    9376:	47 ee       	ldi	r20, 0xE7	; 231
    9378:	5c e0       	ldi	r21, 0x0C	; 12
    937a:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
	lcd_printf(3, 1, PSTR("3)3:   7)7:   #)Save"));
    937e:	83 e0       	ldi	r24, 0x03	; 3
    9380:	61 e0       	ldi	r22, 0x01	; 1
    9382:	42 ed       	ldi	r20, 0xD2	; 210
    9384:	5c e0       	ldi	r21, 0x0C	; 12
    9386:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
	lcd_printf(4, 1, PSTR("4)4:   8)8:   *)Exit"));
    938a:	84 e0       	ldi	r24, 0x04	; 4
    938c:	61 e0       	ldi	r22, 0x01	; 1
    938e:	4d eb       	ldi	r20, 0xBD	; 189
    9390:	5c e0       	ldi	r21, 0x0C	; 12
    9392:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
    9396:	76 01       	movw	r14, r12

	for(i=0;i< 8;i++){
	    sprintf_P(strLabel,PSTR("%.2d"),PPumpLabel[i]);
    9398:	5e 01       	movw	r10, r28
    939a:	08 94       	sec
    939c:	a1 1c       	adc	r10, r1
    939e:	b1 1c       	adc	r11, r1
    93a0:	68 eb       	ldi	r22, 0xB8	; 184
    93a2:	66 2e       	mov	r6, r22
    93a4:	6c e0       	ldi	r22, 0x0C	; 12
    93a6:	76 2e       	mov	r7, r22
	lcd_printf(1, 1, PSTR("1)1:   5)5:"));
	lcd_printf(2, 1, PSTR("2)2:   6)6:"));
	lcd_printf(3, 1, PSTR("3)3:   7)7:   #)Save"));
	lcd_printf(4, 1, PSTR("4)4:   8)8:   *)Exit"));

	for(i=0;i< 8;i++){
    93a8:	5e e0       	ldi	r21, 0x0E	; 14
    93aa:	85 2e       	mov	r8, r21
    93ac:	91 2c       	mov	r9, r1
    93ae:	8c 0e       	add	r8, r28
    93b0:	9d 1e       	adc	r9, r29
	MaxCountId=99;
	lcd_clear();_delay_ms(10);
	lcd_printf(1, 1, PSTR("1)1:   5)5:"));
	lcd_printf(2, 1, PSTR("2)2:   6)6:"));
	lcd_printf(3, 1, PSTR("3)3:   7)7:   #)Save"));
	lcd_printf(4, 1, PSTR("4)4:   8)8:   *)Exit"));
    93b2:	1e 2d       	mov	r17, r14
    93b4:	1c 19       	sub	r17, r12

	for(i=0;i< 8;i++){
	    sprintf_P(strLabel,PSTR("%.2d"),PPumpLabel[i]);
    93b6:	00 d0       	rcall	.+0      	; 0x93b8 <FMenuPumpLabel+0xaa>
    93b8:	00 d0       	rcall	.+0      	; 0x93ba <FMenuPumpLabel+0xac>
    93ba:	00 d0       	rcall	.+0      	; 0x93bc <FMenuPumpLabel+0xae>
    93bc:	ed b7       	in	r30, 0x3d	; 61
    93be:	fe b7       	in	r31, 0x3e	; 62
    93c0:	31 96       	adiw	r30, 0x01	; 1
    93c2:	ad b7       	in	r26, 0x3d	; 61
    93c4:	be b7       	in	r27, 0x3e	; 62
    93c6:	12 96       	adiw	r26, 0x02	; 2
    93c8:	bc 92       	st	X, r11
    93ca:	ae 92       	st	-X, r10
    93cc:	11 97       	sbiw	r26, 0x01	; 1
    93ce:	73 82       	std	Z+3, r7	; 0x03
    93d0:	62 82       	std	Z+2, r6	; 0x02
    93d2:	d7 01       	movw	r26, r14
    93d4:	8d 91       	ld	r24, X+
    93d6:	7d 01       	movw	r14, r26
    93d8:	84 83       	std	Z+4, r24	; 0x04
    93da:	15 82       	std	Z+5, r1	; 0x05
    93dc:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
		xPos=1+(i%4);
		yPos=5+(i/4)*8;
        lcd_print(xPos,yPos,strLabel);
    93e0:	ed b7       	in	r30, 0x3d	; 61
    93e2:	fe b7       	in	r31, 0x3e	; 62
    93e4:	36 96       	adiw	r30, 0x06	; 6
    93e6:	0f b6       	in	r0, 0x3f	; 63
    93e8:	f8 94       	cli
    93ea:	fe bf       	out	0x3e, r31	; 62
    93ec:	0f be       	out	0x3f, r0	; 63
    93ee:	ed bf       	out	0x3d, r30	; 61
    93f0:	61 2f       	mov	r22, r17
    93f2:	66 95       	lsr	r22
    93f4:	66 95       	lsr	r22
    93f6:	66 0f       	add	r22, r22
    93f8:	66 0f       	add	r22, r22
    93fa:	66 0f       	add	r22, r22
    93fc:	6b 5f       	subi	r22, 0xFB	; 251
    93fe:	13 70       	andi	r17, 0x03	; 3
    9400:	81 2f       	mov	r24, r17
    9402:	8f 5f       	subi	r24, 0xFF	; 255
    9404:	a5 01       	movw	r20, r10
    9406:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
	lcd_printf(1, 1, PSTR("1)1:   5)5:"));
	lcd_printf(2, 1, PSTR("2)2:   6)6:"));
	lcd_printf(3, 1, PSTR("3)3:   7)7:   #)Save"));
	lcd_printf(4, 1, PSTR("4)4:   8)8:   *)Exit"));

	for(i=0;i< 8;i++){
    940a:	e8 14       	cp	r14, r8
    940c:	f9 04       	cpc	r15, r9
    940e:	89 f6       	brne	.-94     	; 0x93b2 <FMenuPumpLabel+0xa4>
			eeprom_write_block((const void*) &PPumpLabel, (void*) &DefPumpLabel, 8);
			break;
		}
		if ((KeyChar>='1') && (KeyChar<= '8')){
		     i=(KeyChar-'1');
			if(PPumpLabel[i] == MaxCountId)
    9410:	46 e0       	ldi	r20, 0x06	; 6
    9412:	c4 2e       	mov	r12, r20
    9414:	d1 2c       	mov	r13, r1
    9416:	cc 0e       	add	r12, r28
    9418:	dd 1e       	adc	r13, r29
			   PPumpLabel[i] = 0;
			else
			   PPumpLabel[i]++;
            xPos=1+(i%4);
		    yPos=5+(i/4)*8;
			sprintf_P(strLabel,PSTR("%.2d"),PPumpLabel[i]);
    941a:	7e 01       	movw	r14, r28
    941c:	08 94       	sec
    941e:	e1 1c       	adc	r14, r1
    9420:	f1 1c       	adc	r15, r1
    9422:	33 eb       	ldi	r19, 0xB3	; 179
    9424:	a3 2e       	mov	r10, r19
    9426:	3c e0       	ldi	r19, 0x0C	; 12
    9428:	b3 2e       	mov	r11, r19
		yPos=5+(i/4)*8;
        lcd_print(xPos,yPos,strLabel);
	}

	while(1){
		KeyPressed = _key_scan(1);
    942a:	81 e0       	ldi	r24, 0x01	; 1
    942c:	0e 94 06 b0 	call	0x1600c	; 0x1600c <_key_scan>
    9430:	18 2f       	mov	r17, r24
		KeyChar    = _key_btn(KeyPressed);
    9432:	0e 94 67 af 	call	0x15ece	; 0x15ece <_key_btn>
		if(KeyPressed == _KEY_CANCEL)break;
    9436:	17 3e       	cpi	r17, 0xE7	; 231
    9438:	09 f4       	brne	.+2      	; 0x943c <FMenuPumpLabel+0x12e>
    943a:	4b c0       	rjmp	.+150    	; 0x94d2 <FMenuPumpLabel+0x1c4>
		else
		if(KeyPressed == _KEY_ENTER){
    943c:	17 3b       	cpi	r17, 0xB7	; 183
    943e:	61 f4       	brne	.+24     	; 0x9458 <FMenuPumpLabel+0x14a>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    9440:	8d e4       	ldi	r24, 0x4D	; 77
    9442:	90 e0       	ldi	r25, 0x00	; 0
    9444:	be 01       	movw	r22, r28
    9446:	6a 5f       	subi	r22, 0xFA	; 250
    9448:	7f 4f       	sbci	r23, 0xFF	; 255
    944a:	48 e0       	ldi	r20, 0x08	; 8
    944c:	50 e0       	ldi	r21, 0x00	; 0
    944e:	2e ef       	ldi	r18, 0xFE	; 254
    9450:	32 e1       	ldi	r19, 0x12	; 18
    9452:	0e 94 96 b5 	call	0x16b2c	; 0x16b2c <__eewr_block>
    9456:	3d c0       	rjmp	.+122    	; 0x94d2 <FMenuPumpLabel+0x1c4>
			eeprom_write_block((const void*) &PPumpLabel, (void*) &DefPumpLabel, 8);
			break;
		}
		if ((KeyChar>='1') && (KeyChar<= '8')){
    9458:	18 2f       	mov	r17, r24
    945a:	11 53       	subi	r17, 0x31	; 49
    945c:	18 30       	cpi	r17, 0x08	; 8
    945e:	28 f7       	brcc	.-54     	; 0x942a <FMenuPumpLabel+0x11c>
		     i=(KeyChar-'1');
			if(PPumpLabel[i] == MaxCountId)
    9460:	a1 2f       	mov	r26, r17
    9462:	b0 e0       	ldi	r27, 0x00	; 0
    9464:	f6 01       	movw	r30, r12
    9466:	ea 0f       	add	r30, r26
    9468:	fb 1f       	adc	r31, r27
    946a:	90 81       	ld	r25, Z
    946c:	80 91 56 01 	lds	r24, 0x0156
    9470:	98 17       	cp	r25, r24
    9472:	11 f4       	brne	.+4      	; 0x9478 <FMenuPumpLabel+0x16a>
			   PPumpLabel[i] = 0;
    9474:	10 82       	st	Z, r1
    9476:	02 c0       	rjmp	.+4      	; 0x947c <FMenuPumpLabel+0x16e>
			else
			   PPumpLabel[i]++;
    9478:	9f 5f       	subi	r25, 0xFF	; 255
    947a:	90 83       	st	Z, r25
            xPos=1+(i%4);
		    yPos=5+(i/4)*8;
			sprintf_P(strLabel,PSTR("%.2d"),PPumpLabel[i]);
    947c:	00 d0       	rcall	.+0      	; 0x947e <FMenuPumpLabel+0x170>
    947e:	00 d0       	rcall	.+0      	; 0x9480 <FMenuPumpLabel+0x172>
    9480:	00 d0       	rcall	.+0      	; 0x9482 <FMenuPumpLabel+0x174>
    9482:	2d b7       	in	r18, 0x3d	; 61
    9484:	3e b7       	in	r19, 0x3e	; 62
    9486:	2f 5f       	subi	r18, 0xFF	; 255
    9488:	3f 4f       	sbci	r19, 0xFF	; 255
    948a:	ed b7       	in	r30, 0x3d	; 61
    948c:	fe b7       	in	r31, 0x3e	; 62
    948e:	f2 82       	std	Z+2, r15	; 0x02
    9490:	e1 82       	std	Z+1, r14	; 0x01
    9492:	f9 01       	movw	r30, r18
    9494:	b3 82       	std	Z+3, r11	; 0x03
    9496:	a2 82       	std	Z+2, r10	; 0x02
    9498:	ac 0d       	add	r26, r12
    949a:	bd 1d       	adc	r27, r13
    949c:	8c 91       	ld	r24, X
    949e:	84 83       	std	Z+4, r24	; 0x04
    94a0:	15 82       	std	Z+5, r1	; 0x05
    94a2:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
            lcd_print(xPos,yPos,strLabel);
    94a6:	8d b7       	in	r24, 0x3d	; 61
    94a8:	9e b7       	in	r25, 0x3e	; 62
    94aa:	06 96       	adiw	r24, 0x06	; 6
    94ac:	0f b6       	in	r0, 0x3f	; 63
    94ae:	f8 94       	cli
    94b0:	9e bf       	out	0x3e, r25	; 62
    94b2:	0f be       	out	0x3f, r0	; 63
    94b4:	8d bf       	out	0x3d, r24	; 61
    94b6:	61 2f       	mov	r22, r17
    94b8:	66 95       	lsr	r22
    94ba:	66 95       	lsr	r22
    94bc:	66 0f       	add	r22, r22
    94be:	66 0f       	add	r22, r22
    94c0:	66 0f       	add	r22, r22
    94c2:	6b 5f       	subi	r22, 0xFB	; 251
    94c4:	13 70       	andi	r17, 0x03	; 3
    94c6:	81 2f       	mov	r24, r17
    94c8:	8f 5f       	subi	r24, 0xFF	; 255
    94ca:	a7 01       	movw	r20, r14
    94cc:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
    94d0:	ac cf       	rjmp	.-168    	; 0x942a <FMenuPumpLabel+0x11c>
		}
	}
}
    94d2:	2d 96       	adiw	r28, 0x0d	; 13
    94d4:	0f b6       	in	r0, 0x3f	; 63
    94d6:	f8 94       	cli
    94d8:	de bf       	out	0x3e, r29	; 62
    94da:	0f be       	out	0x3f, r0	; 63
    94dc:	cd bf       	out	0x3d, r28	; 61
    94de:	cf 91       	pop	r28
    94e0:	df 91       	pop	r29
    94e2:	1f 91       	pop	r17
    94e4:	ff 90       	pop	r15
    94e6:	ef 90       	pop	r14
    94e8:	df 90       	pop	r13
    94ea:	cf 90       	pop	r12
    94ec:	bf 90       	pop	r11
    94ee:	af 90       	pop	r10
    94f0:	9f 90       	pop	r9
    94f2:	8f 90       	pop	r8
    94f4:	7f 90       	pop	r7
    94f6:	6f 90       	pop	r6
    94f8:	08 95       	ret

000094fa <system_stop>:
	return Result;
}

void system_stop(){
	 char __key,__num;
	 lcd_printf(4,1,PSTR("Press any key..     "));
    94fa:	84 e0       	ldi	r24, 0x04	; 4
    94fc:	61 e0       	ldi	r22, 0x01	; 1
    94fe:	4b e2       	ldi	r20, 0x2B	; 43
    9500:	52 e2       	ldi	r21, 0x22	; 34
    9502:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    9506:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    9508:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    950a:	85 e0       	ldi	r24, 0x05	; 5
    950c:	90 e0       	ldi	r25, 0x00	; 0
    950e:	90 93 d7 01 	sts	0x01D7, r25
    9512:	80 93 d6 01 	sts	0x01D6, r24
void system_stop(){
	 char __key,__num;
	 lcd_printf(4,1,PSTR("Press any key..     "));
	 system_beep(5);
	 while(1){
		__key = _key_scan(1);
    9516:	81 e0       	ldi	r24, 0x01	; 1
    9518:	0e 94 06 b0 	call	0x1600c	; 0x1600c <_key_scan>
		__num = _key_btn(__key);
    951c:	0e 94 67 af 	call	0x15ece	; 0x15ece <_key_btn>
		if ((__num>='0')&&(__num<='9')||(IsStandAloneDetected==True)) 
    9520:	80 53       	subi	r24, 0x30	; 48
    9522:	8a 30       	cpi	r24, 0x0A	; 10
    9524:	20 f0       	brcs	.+8      	; 0x952e <system_stop+0x34>
    9526:	80 91 b3 01 	lds	r24, 0x01B3
    952a:	81 30       	cpi	r24, 0x01	; 1
    952c:	a1 f7       	brne	.-24     	; 0x9516 <system_stop+0x1c>
    952e:	08 95       	ret

00009530 <systemForceType>:
	 }
}

char systemForceType(){
     char Result,KeyChar;
	 lcd_printf(4,1,PSTR("[1]Slave [2]Standalone"));
    9530:	84 e0       	ldi	r24, 0x04	; 4
    9532:	61 e0       	ldi	r22, 0x01	; 1
    9534:	40 e4       	ldi	r20, 0x40	; 64
    9536:	52 e2       	ldi	r21, 0x22	; 34
    9538:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    953c:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    953e:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    9540:	81 e0       	ldi	r24, 0x01	; 1
    9542:	90 e0       	ldi	r25, 0x00	; 0
    9544:	90 93 d7 01 	sts	0x01D7, r25
    9548:	80 93 d6 01 	sts	0x01D6, r24
    954c:	80 e5       	ldi	r24, 0x50	; 80
    954e:	93 ec       	ldi	r25, 0xC3	; 195
    9550:	01 97       	sbiw	r24, 0x01	; 1
    9552:	f1 f7       	brne	.-4      	; 0x9550 <systemForceType+0x20>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    9554:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    9556:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    9558:	82 e0       	ldi	r24, 0x02	; 2
    955a:	90 e0       	ldi	r25, 0x00	; 0
    955c:	90 93 d7 01 	sts	0x01D7, r25
    9560:	80 93 d6 01 	sts	0x01D6, r24
	 lcd_printf(4,1,PSTR("[1]Slave [2]Standalone"));
	 system_beep(1);
	 _delay_ms(200);
	 system_beep(2);
	 while(1){
	    KeyChar=_key_btn(_key_scan(1));
    9564:	81 e0       	ldi	r24, 0x01	; 1
    9566:	0e 94 06 b0 	call	0x1600c	; 0x1600c <_key_scan>
    956a:	0e 94 67 af 	call	0x15ece	; 0x15ece <_key_btn>
    956e:	98 2f       	mov	r25, r24
		if ((KeyChar=='1')||(KeyChar=='2')){
    9570:	81 53       	subi	r24, 0x31	; 49
    9572:	82 30       	cpi	r24, 0x02	; 2
    9574:	b8 f7       	brcc	.-18     	; 0x9564 <systemForceType+0x34>
		    Result=KeyChar;
			break;
		}
	 }
	return Result;
}
    9576:	89 2f       	mov	r24, r25
    9578:	08 95       	ret

0000957a <_f_punctuation>:
				__string[__i++] = 0x30;
		__devider = __devider / 10;
	}
	__string[__i] = '\0';
}
void _f_punctuation(char* __string, unsigned char __mode, unsigned char __length, unsigned char __decimal){
    957a:	bf 92       	push	r11
    957c:	cf 92       	push	r12
    957e:	df 92       	push	r13
    9580:	ef 92       	push	r14
    9582:	ff 92       	push	r15
    9584:	0f 93       	push	r16
    9586:	1f 93       	push	r17
    9588:	df 93       	push	r29
    958a:	cf 93       	push	r28
    958c:	cd b7       	in	r28, 0x3d	; 61
    958e:	de b7       	in	r29, 0x3e	; 62
    9590:	2f 97       	sbiw	r28, 0x0f	; 15
    9592:	0f b6       	in	r0, 0x3f	; 63
    9594:	f8 94       	cli
    9596:	de bf       	out	0x3e, r29	; 62
    9598:	0f be       	out	0x3f, r0	; 63
    959a:	cd bf       	out	0x3d, r28	; 61
    959c:	8c 01       	movw	r16, r24
    959e:	c6 2e       	mov	r12, r22
    95a0:	d4 2e       	mov	r13, r20
    95a2:	62 2f       	mov	r22, r18
	char __buff[15] = {"000000000000000"};
    95a4:	de 01       	movw	r26, r28
    95a6:	11 96       	adiw	r26, 0x01	; 1
    95a8:	e0 e0       	ldi	r30, 0x00	; 0
    95aa:	f1 e0       	ldi	r31, 0x01	; 1
    95ac:	8f e0       	ldi	r24, 0x0F	; 15
    95ae:	01 90       	ld	r0, Z+
    95b0:	0d 92       	st	X+, r0
    95b2:	81 50       	subi	r24, 0x01	; 1
    95b4:	e1 f7       	brne	.-8      	; 0x95ae <_f_punctuation+0x34>
	char  __point = 0,  __len;
	unsigned char __i, __ii,__counter = 0;

	__len = strlen(__string);
    95b6:	f8 01       	movw	r30, r16
    95b8:	01 90       	ld	r0, Z+
    95ba:	00 20       	and	r0, r0
    95bc:	e9 f7       	brne	.-6      	; 0x95b8 <_f_punctuation+0x3e>
    95be:	31 97       	sbiw	r30, 0x01	; 1
    95c0:	3e 2f       	mov	r19, r30
    95c2:	30 1b       	sub	r19, r16
	if(__mode == 0){
    95c4:	cc 20       	and	r12, r12
    95c6:	11 f5       	brne	.+68     	; 0x960c <_f_punctuation+0x92>
		__buff[__length] = '\0';
    95c8:	8d 2d       	mov	r24, r13
    95ca:	90 e0       	ldi	r25, 0x00	; 0
    95cc:	fe 01       	movw	r30, r28
    95ce:	e8 0f       	add	r30, r24
    95d0:	f9 1f       	adc	r31, r25
    95d2:	11 82       	std	Z+1, r1	; 0x01
		for(__i = __length, __ii = __len - 1; __i > (__length - __len); __i--, __ii--)
    95d4:	23 2f       	mov	r18, r19
    95d6:	21 50       	subi	r18, 0x01	; 1
    95d8:	4d 2d       	mov	r20, r13
    95da:	bc 01       	movw	r22, r24
    95dc:	63 1b       	sub	r22, r19
    95de:	71 09       	sbc	r23, r1
    95e0:	09 c0       	rjmp	.+18     	; 0x95f4 <_f_punctuation+0x7a>
			__buff[__i - 1] = __string[__ii];
    95e2:	ac 0f       	add	r26, r28
    95e4:	bd 1f       	adc	r27, r29
    95e6:	f8 01       	movw	r30, r16
    95e8:	e2 0f       	add	r30, r18
    95ea:	f1 1d       	adc	r31, r1
    95ec:	80 81       	ld	r24, Z
    95ee:	8c 93       	st	X, r24
	unsigned char __i, __ii,__counter = 0;

	__len = strlen(__string);
	if(__mode == 0){
		__buff[__length] = '\0';
		for(__i = __length, __ii = __len - 1; __i > (__length - __len); __i--, __ii--)
    95f0:	41 50       	subi	r20, 0x01	; 1
    95f2:	21 50       	subi	r18, 0x01	; 1
    95f4:	a4 2f       	mov	r26, r20
    95f6:	b0 e0       	ldi	r27, 0x00	; 0
    95f8:	6a 17       	cp	r22, r26
    95fa:	7b 07       	cpc	r23, r27
    95fc:	94 f3       	brlt	.-28     	; 0x95e2 <_f_punctuation+0x68>
			__buff[__i - 1] = __string[__ii];
		strcpy(__string, __buff);
    95fe:	c8 01       	movw	r24, r16
    9600:	be 01       	movw	r22, r28
    9602:	6f 5f       	subi	r22, 0xFF	; 255
    9604:	7f 4f       	sbci	r23, 0xFF	; 255
    9606:	0e 94 73 b5 	call	0x16ae6	; 0x16ae6 <strcpy>
    960a:	90 c0       	rjmp	.+288    	; 0x972c <_f_punctuation+0x1b2>
	}
	else{
		if(__decimal > 0){
    960c:	66 23       	and	r22, r22
    960e:	61 f1       	breq	.+88     	; 0x9668 <_f_punctuation+0xee>
    9610:	a3 2f       	mov	r26, r19
    9612:	b0 e0       	ldi	r27, 0x00	; 0
    9614:	11 97       	sbiw	r26, 0x01	; 1
    9616:	a0 0f       	add	r26, r16
    9618:	b1 1f       	adc	r27, r17
    961a:	90 e0       	ldi	r25, 0x00	; 0
    961c:	ae 01       	movw	r20, r28
    961e:	4f 5f       	subi	r20, 0xFF	; 255
    9620:	5f 4f       	sbci	r21, 0xFF	; 255
			for(__i = 0; __i < __decimal; __i++){
				if(__i < __len)
					__buff[__counter++] = __string[__len - 1 - __i];
				else
					__buff[__counter++] = '0';
    9622:	20 e3       	ldi	r18, 0x30	; 48
    9624:	0e c0       	rjmp	.+28     	; 0x9642 <_f_punctuation+0xc8>
    9626:	e9 2f       	mov	r30, r25
    9628:	f0 e0       	ldi	r31, 0x00	; 0
		strcpy(__string, __buff);
	}
	else{
		if(__decimal > 0){
			for(__i = 0; __i < __decimal; __i++){
				if(__i < __len)
    962a:	93 17       	cp	r25, r19
    962c:	28 f4       	brcc	.+10     	; 0x9638 <_f_punctuation+0xbe>
					__buff[__counter++] = __string[__len - 1 - __i];
    962e:	e4 0f       	add	r30, r20
    9630:	f5 1f       	adc	r31, r21
    9632:	8c 91       	ld	r24, X
    9634:	80 83       	st	Z, r24
    9636:	03 c0       	rjmp	.+6      	; 0x963e <_f_punctuation+0xc4>
				else
					__buff[__counter++] = '0';
    9638:	e4 0f       	add	r30, r20
    963a:	f5 1f       	adc	r31, r21
    963c:	20 83       	st	Z, r18
			__buff[__i - 1] = __string[__ii];
		strcpy(__string, __buff);
	}
	else{
		if(__decimal > 0){
			for(__i = 0; __i < __decimal; __i++){
    963e:	9f 5f       	subi	r25, 0xFF	; 255
    9640:	11 97       	sbiw	r26, 0x01	; 1
    9642:	96 17       	cp	r25, r22
    9644:	80 f3       	brcs	.-32     	; 0x9626 <_f_punctuation+0xac>
				if(__i < __len)
					__buff[__counter++] = __string[__len - 1 - __i];
				else
					__buff[__counter++] = '0';
			}
			__buff[__counter++] = ',';
    9646:	de 01       	movw	r26, r28
    9648:	11 96       	adiw	r26, 0x01	; 1
    964a:	fd 01       	movw	r30, r26
    964c:	e6 0f       	add	r30, r22
    964e:	f1 1d       	adc	r31, r1
    9650:	8c e2       	ldi	r24, 0x2C	; 44
    9652:	80 83       	st	Z, r24
    9654:	56 2f       	mov	r21, r22
    9656:	5f 5f       	subi	r21, 0xFF	; 255
		}
		if(__decimal > 0 && __len <= 2)
    9658:	33 30       	cpi	r19, 0x03	; 3
    965a:	48 f4       	brcc	.+18     	; 0x966e <_f_punctuation+0xf4>
			__buff[__counter++] = '0';
    965c:	a5 0f       	add	r26, r21
    965e:	b1 1d       	adc	r27, r1
    9660:	80 e3       	ldi	r24, 0x30	; 48
    9662:	8c 93       	st	X, r24
    9664:	5f 5f       	subi	r21, 0xFF	; 255
    9666:	32 c0       	rjmp	.+100    	; 0x96cc <_f_punctuation+0x152>
		else{
			if(__len > 1){
    9668:	32 30       	cpi	r19, 0x02	; 2
    966a:	68 f1       	brcs	.+90     	; 0x96c6 <_f_punctuation+0x14c>
    966c:	50 e0       	ldi	r21, 0x00	; 0
				for(	__i = 0, __ii = __len - 1 - __decimal; __i < __len - __decimal;
    966e:	31 50       	subi	r19, 0x01	; 1
    9670:	b3 2e       	mov	r11, r19
    9672:	b6 1a       	sub	r11, r22
    9674:	3f 5f       	subi	r19, 0xFF	; 255
    9676:	70 e0       	ldi	r23, 0x00	; 0
    9678:	40 e0       	ldi	r20, 0x00	; 0
    967a:	23 2f       	mov	r18, r19
    967c:	30 e0       	ldi	r19, 0x00	; 0
    967e:	26 1b       	sub	r18, r22
    9680:	31 09       	sbc	r19, r1
						__i++, __point++, __ii--){
					if(__point == 3){
						__point = 0;
						__buff[__counter++] = '.';
    9682:	7e 01       	movw	r14, r28
    9684:	08 94       	sec
    9686:	e1 1c       	adc	r14, r1
    9688:	f1 1c       	adc	r15, r1
    968a:	6e e2       	ldi	r22, 0x2E	; 46
    968c:	14 c0       	rjmp	.+40     	; 0x96b6 <_f_punctuation+0x13c>
			__buff[__counter++] = '0';
		else{
			if(__len > 1){
				for(	__i = 0, __ii = __len - 1 - __decimal; __i < __len - __decimal;
						__i++, __point++, __ii--){
					if(__point == 3){
    968e:	73 30       	cpi	r23, 0x03	; 3
    9690:	31 f4       	brne	.+12     	; 0x969e <_f_punctuation+0x124>
						__point = 0;
						__buff[__counter++] = '.';
    9692:	f7 01       	movw	r30, r14
    9694:	e5 0f       	add	r30, r21
    9696:	f1 1d       	adc	r31, r1
    9698:	60 83       	st	Z, r22
    969a:	5f 5f       	subi	r21, 0xFF	; 255
    969c:	70 e0       	ldi	r23, 0x00	; 0
					}
					__buff[__counter++] = __string[__ii];
    969e:	f7 01       	movw	r30, r14
    96a0:	e5 0f       	add	r30, r21
    96a2:	f1 1d       	adc	r31, r1
    96a4:	c8 01       	movw	r24, r16
    96a6:	8a 0f       	add	r24, r26
    96a8:	91 1d       	adc	r25, r1
    96aa:	dc 01       	movw	r26, r24
    96ac:	8c 91       	ld	r24, X
    96ae:	80 83       	st	Z, r24
    96b0:	5f 5f       	subi	r21, 0xFF	; 255
		if(__decimal > 0 && __len <= 2)
			__buff[__counter++] = '0';
		else{
			if(__len > 1){
				for(	__i = 0, __ii = __len - 1 - __decimal; __i < __len - __decimal;
						__i++, __point++, __ii--){
    96b2:	4f 5f       	subi	r20, 0xFF	; 255
    96b4:	7f 5f       	subi	r23, 0xFF	; 255
    96b6:	ab 2d       	mov	r26, r11
    96b8:	a4 1b       	sub	r26, r20
		}
		if(__decimal > 0 && __len <= 2)
			__buff[__counter++] = '0';
		else{
			if(__len > 1){
				for(	__i = 0, __ii = __len - 1 - __decimal; __i < __len - __decimal;
    96ba:	84 2f       	mov	r24, r20
    96bc:	90 e0       	ldi	r25, 0x00	; 0
    96be:	82 17       	cp	r24, r18
    96c0:	93 07       	cpc	r25, r19
    96c2:	2c f3       	brlt	.-54     	; 0x968e <_f_punctuation+0x114>
    96c4:	03 c0       	rjmp	.+6      	; 0x96cc <_f_punctuation+0x152>
					}
					__buff[__counter++] = __string[__ii];
				}
			}
			else
				__buff[__counter++] = '0';
    96c6:	80 e3       	ldi	r24, 0x30	; 48
    96c8:	89 83       	std	Y+1, r24	; 0x01
    96ca:	51 e0       	ldi	r21, 0x01	; 1
		}
		if(__mode == 1){
    96cc:	91 e0       	ldi	r25, 0x01	; 1
    96ce:	c9 16       	cp	r12, r25
    96d0:	79 f4       	brne	.+30     	; 0x96f0 <_f_punctuation+0x176>
    96d2:	fe 01       	movw	r30, r28
    96d4:	31 96       	adiw	r30, 0x01	; 1
    96d6:	e5 0f       	add	r30, r21
    96d8:	f1 1d       	adc	r31, r1
    96da:	d8 01       	movw	r26, r16
    96dc:	02 c0       	rjmp	.+4      	; 0x96e2 <_f_punctuation+0x168>
			for(__i = 0; __i < __counter; __i++)
				__string[__i] = __buff[__counter - 1 - __i];
    96de:	80 81       	ld	r24, Z
    96e0:	8d 93       	st	X+, r24
    96e2:	31 97       	sbiw	r30, 0x01	; 1
			}
			else
				__buff[__counter++] = '0';
		}
		if(__mode == 1){
			for(__i = 0; __i < __counter; __i++)
    96e4:	ec 17       	cp	r30, r28
    96e6:	fd 07       	cpc	r31, r29
    96e8:	d1 f7       	brne	.-12     	; 0x96de <_f_punctuation+0x164>
				__string[__i] = __buff[__counter - 1 - __i];
			__string[__counter] = '\0';
    96ea:	05 0f       	add	r16, r21
    96ec:	11 1d       	adc	r17, r1
    96ee:	1c c0       	rjmp	.+56     	; 0x9728 <_f_punctuation+0x1ae>
		}
		if(__mode == 2){
    96f0:	f2 e0       	ldi	r31, 0x02	; 2
    96f2:	cf 16       	cp	r12, r31
    96f4:	d9 f4       	brne	.+54     	; 0x972c <_f_punctuation+0x1b2>
    96f6:	f8 01       	movw	r30, r16
    96f8:	80 e0       	ldi	r24, 0x00	; 0
			for(__i = 0; __i < __length; __i++)
				__string[__i] = 0x20;
    96fa:	90 e2       	ldi	r25, 0x20	; 32
    96fc:	02 c0       	rjmp	.+4      	; 0x9702 <_f_punctuation+0x188>
    96fe:	91 93       	st	Z+, r25
			for(__i = 0; __i < __counter; __i++)
				__string[__i] = __buff[__counter - 1 - __i];
			__string[__counter] = '\0';
		}
		if(__mode == 2){
			for(__i = 0; __i < __length; __i++)
    9700:	8f 5f       	subi	r24, 0xFF	; 255
    9702:	8d 15       	cp	r24, r13
    9704:	e0 f3       	brcs	.-8      	; 0x96fe <_f_punctuation+0x184>
				__string[__i] = 0x20;
			for(__i = 0, __ii = __length - 1; __i < __counter; __i++, __ii--)
    9706:	de 01       	movw	r26, r28
    9708:	11 96       	adiw	r26, 0x01	; 1
    970a:	9d 2d       	mov	r25, r13
    970c:	91 50       	subi	r25, 0x01	; 1
    970e:	29 2f       	mov	r18, r25
    9710:	25 1b       	sub	r18, r21
    9712:	06 c0       	rjmp	.+12     	; 0x9720 <_f_punctuation+0x1a6>
				__string[__ii] = __buff[__i];
    9714:	f8 01       	movw	r30, r16
    9716:	e9 0f       	add	r30, r25
    9718:	f1 1d       	adc	r31, r1
    971a:	8d 91       	ld	r24, X+
    971c:	80 83       	st	Z, r24
			__string[__counter] = '\0';
		}
		if(__mode == 2){
			for(__i = 0; __i < __length; __i++)
				__string[__i] = 0x20;
			for(__i = 0, __ii = __length - 1; __i < __counter; __i++, __ii--)
    971e:	91 50       	subi	r25, 0x01	; 1
    9720:	92 17       	cp	r25, r18
    9722:	c1 f7       	brne	.-16     	; 0x9714 <_f_punctuation+0x19a>
				__string[__ii] = __buff[__i];
			__string[__length] = '\0';
    9724:	0d 0d       	add	r16, r13
    9726:	11 1d       	adc	r17, r1
    9728:	f8 01       	movw	r30, r16
    972a:	10 82       	st	Z, r1
		}
	}
}
    972c:	2f 96       	adiw	r28, 0x0f	; 15
    972e:	0f b6       	in	r0, 0x3f	; 63
    9730:	f8 94       	cli
    9732:	de bf       	out	0x3e, r29	; 62
    9734:	0f be       	out	0x3f, r0	; 63
    9736:	cd bf       	out	0x3d, r28	; 61
    9738:	cf 91       	pop	r28
    973a:	df 91       	pop	r29
    973c:	1f 91       	pop	r17
    973e:	0f 91       	pop	r16
    9740:	ff 90       	pop	r15
    9742:	ef 90       	pop	r14
    9744:	df 90       	pop	r13
    9746:	cf 90       	pop	r12
    9748:	bf 90       	pop	r11
    974a:	08 95       	ret

0000974c <_menu_printer>:
}

//*************************************************************************
//  ngeset printer

void _menu_printer(void){
    974c:	2f 92       	push	r2
    974e:	3f 92       	push	r3
    9750:	4f 92       	push	r4
    9752:	5f 92       	push	r5
    9754:	6f 92       	push	r6
    9756:	7f 92       	push	r7
    9758:	8f 92       	push	r8
    975a:	9f 92       	push	r9
    975c:	af 92       	push	r10
    975e:	bf 92       	push	r11
    9760:	cf 92       	push	r12
    9762:	df 92       	push	r13
    9764:	ef 92       	push	r14
    9766:	ff 92       	push	r15
    9768:	0f 93       	push	r16
    976a:	1f 93       	push	r17
    976c:	df 93       	push	r29
    976e:	cf 93       	push	r28
    9770:	cd b7       	in	r28, 0x3d	; 61
    9772:	de b7       	in	r29, 0x3e	; 62
    9774:	2c 97       	sbiw	r28, 0x0c	; 12
    9776:	0f b6       	in	r0, 0x3f	; 63
    9778:	f8 94       	cli
    977a:	de bf       	out	0x3e, r29	; 62
    977c:	0f be       	out	0x3f, r0	; 63
    977e:	cd bf       	out	0x3d, r28	; 61
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    9780:	e1 99       	sbic	0x1c, 1	; 28
    9782:	fe cf       	rjmp	.-4      	; 0x9780 <_menu_printer+0x34>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    9784:	80 e3       	ldi	r24, 0x30	; 48
    9786:	90 e0       	ldi	r25, 0x00	; 0
    9788:	9f bb       	out	0x1f, r25	; 31
    978a:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    978c:	e0 9a       	sbi	0x1c, 0	; 28
    978e:	5d b3       	in	r21, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    9790:	e1 99       	sbic	0x1c, 1	; 28
    9792:	fe cf       	rjmp	.-4      	; 0x9790 <_menu_printer+0x44>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    9794:	e5 e3       	ldi	r30, 0x35	; 53
    9796:	f0 e0       	ldi	r31, 0x00	; 0
    9798:	ff bb       	out	0x1f, r31	; 31
    979a:	ee bb       	out	0x1e, r30	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    979c:	e0 9a       	sbi	0x1c, 0	; 28
    979e:	4d b3       	in	r20, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    97a0:	e1 99       	sbic	0x1c, 1	; 28
    97a2:	fe cf       	rjmp	.-4      	; 0x97a0 <_menu_printer+0x54>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    97a4:	84 e3       	ldi	r24, 0x34	; 52
    97a6:	90 e0       	ldi	r25, 0x00	; 0
    97a8:	9f bb       	out	0x1f, r25	; 31
    97aa:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    97ac:	e0 9a       	sbi	0x1c, 0	; 28
    97ae:	3d b3       	in	r19, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    97b0:	e1 99       	sbic	0x1c, 1	; 28
    97b2:	fe cf       	rjmp	.-4      	; 0x97b0 <_menu_printer+0x64>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    97b4:	e3 e3       	ldi	r30, 0x33	; 51
    97b6:	f0 e0       	ldi	r31, 0x00	; 0
    97b8:	ff bb       	out	0x1f, r31	; 31
    97ba:	ee bb       	out	0x1e, r30	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    97bc:	e0 9a       	sbi	0x1c, 0	; 28
    97be:	2d b3       	in	r18, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    97c0:	e1 99       	sbic	0x1c, 1	; 28
    97c2:	fe cf       	rjmp	.-4      	; 0x97c0 <_menu_printer+0x74>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    97c4:	11 e3       	ldi	r17, 0x31	; 49
    97c6:	21 2e       	mov	r2, r17
    97c8:	10 e0       	ldi	r17, 0x00	; 0
    97ca:	31 2e       	mov	r3, r17
    97cc:	3f ba       	out	0x1f, r3	; 31
    97ce:	2e ba       	out	0x1e, r2	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    97d0:	e0 9a       	sbi	0x1c, 0	; 28
    97d2:	9d b3       	in	r25, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    97d4:	e1 99       	sbic	0x1c, 1	; 28
    97d6:	fe cf       	rjmp	.-4      	; 0x97d4 <_menu_printer+0x88>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    97d8:	b2 e3       	ldi	r27, 0x32	; 50
    97da:	4b 2e       	mov	r4, r27
    97dc:	b0 e0       	ldi	r27, 0x00	; 0
    97de:	5b 2e       	mov	r5, r27
    97e0:	5f ba       	out	0x1f, r5	; 31
    97e2:	4e ba       	out	0x1e, r4	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    97e4:	e0 9a       	sbi	0x1c, 0	; 28
    97e6:	8d b3       	in	r24, 0x1d	; 29
	char 			__value[6];
	char	__i, __x, __y, __lmt, __start, __key, __num, __buff[6];
//	char lcdteks[20];

	__value[0] = eeprom_read_byte(&DefPrinterType);
    97e8:	59 83       	std	Y+1, r21	; 0x01
	__value[1] = eeprom_read_byte(&DefPrintSize);
    97ea:	4a 83       	std	Y+2, r20	; 0x02
	__value[2] = eeprom_read_byte(&DefPrintLogo);
    97ec:	3b 83       	std	Y+3, r19	; 0x03
	__value[3] = eeprom_read_byte(&DefPrintAutoCut);
    97ee:	2c 83       	std	Y+4, r18	; 0x04
	__value[4] = eeprom_read_byte(&DefPrintScrollEnd);
    97f0:	9d 83       	std	Y+5, r25	; 0x05
	__value[5] = eeprom_read_byte(&DefPrintScrollSpace);
    97f2:	8e 83       	std	Y+6, r24	; 0x06

	lcd_clear();
    97f4:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
	lcd_printf(1, 1, PSTR("1)Type:  5)Scroll:"));
    97f8:	81 e0       	ldi	r24, 0x01	; 1
    97fa:	61 e0       	ldi	r22, 0x01	; 1
    97fc:	43 e8       	ldi	r20, 0x83	; 131
    97fe:	5b e0       	ldi	r21, 0x0B	; 11
    9800:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
	lcd_printf(2, 1, PSTR("2)Size:  6)Space :"));
    9804:	82 e0       	ldi	r24, 0x02	; 2
    9806:	61 e0       	ldi	r22, 0x01	; 1
    9808:	40 e7       	ldi	r20, 0x70	; 112
    980a:	5b e0       	ldi	r21, 0x0B	; 11
    980c:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
	lcd_printf(3, 1, PSTR("3)Logo:  #)Save"));
    9810:	83 e0       	ldi	r24, 0x03	; 3
    9812:	61 e0       	ldi	r22, 0x01	; 1
    9814:	40 e6       	ldi	r20, 0x60	; 96
    9816:	5b e0       	ldi	r21, 0x0B	; 11
    9818:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
	lcd_printf(4, 1, PSTR("4)Cut :  *)Exit"));
    981c:	84 e0       	ldi	r24, 0x04	; 4
    981e:	61 e0       	ldi	r22, 0x01	; 1
    9820:	40 e5       	ldi	r20, 0x50	; 80
    9822:	5b e0       	ldi	r21, 0x0B	; 11
    9824:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
    9828:	00 ee       	ldi	r16, 0xE0	; 224
    982a:	12 e0       	ldi	r17, 0x02	; 2
    982c:	4e 01       	movw	r8, r28
    982e:	08 94       	sec
    9830:	81 1c       	adc	r8, r1
    9832:	91 1c       	adc	r9, r1
    9834:	74 01       	movw	r14, r8

	for(__i = 0; __i < 6; __i++){
		__x = pgm_read_byte(&__prntloc[__i][0]);
		__y = pgm_read_byte(&__prntloc[__i][1]);
		_f_inttostr(__buff, __value[__i]);
    9836:	a7 e0       	ldi	r26, 0x07	; 7
    9838:	ca 2e       	mov	r12, r26
    983a:	d1 2c       	mov	r13, r1
    983c:	cc 0e       	add	r12, r28
    983e:	dd 1e       	adc	r13, r29
	lcd_printf(2, 1, PSTR("2)Size:  6)Space :"));
	lcd_printf(3, 1, PSTR("3)Logo:  #)Save"));
	lcd_printf(4, 1, PSTR("4)Cut :  *)Exit"));

	for(__i = 0; __i < 6; __i++){
		__x = pgm_read_byte(&__prntloc[__i][0]);
    9840:	f8 01       	movw	r30, r16
    9842:	a4 90       	lpm	r10, Z+
		__y = pgm_read_byte(&__prntloc[__i][1]);
    9844:	0f 5f       	subi	r16, 0xFF	; 255
    9846:	1f 4f       	sbci	r17, 0xFF	; 255
    9848:	f8 01       	movw	r30, r16
    984a:	b4 90       	lpm	r11, Z+
    984c:	01 50       	subi	r16, 0x01	; 1
    984e:	10 40       	sbci	r17, 0x00	; 0
		_f_inttostr(__buff, __value[__i]);
    9850:	f7 01       	movw	r30, r14
    9852:	40 81       	ld	r20, Z
    9854:	50 e0       	ldi	r21, 0x00	; 0
    9856:	60 e0       	ldi	r22, 0x00	; 0
    9858:	70 e0       	ldi	r23, 0x00	; 0
    985a:	c6 01       	movw	r24, r12
    985c:	0e 94 65 19 	call	0x32ca	; 0x32ca <_f_inttostr>
		if(__i == 4)_f_punctuation(__buff, 0, 2, 0);
    9860:	8e 2d       	mov	r24, r14
    9862:	88 19       	sub	r24, r8
    9864:	84 30       	cpi	r24, 0x04	; 4
    9866:	31 f4       	brne	.+12     	; 0x9874 <_menu_printer+0x128>
    9868:	c6 01       	movw	r24, r12
    986a:	60 e0       	ldi	r22, 0x00	; 0
    986c:	42 e0       	ldi	r20, 0x02	; 2
    986e:	20 e0       	ldi	r18, 0x00	; 0
    9870:	0e 94 bd 4a 	call	0x957a	; 0x957a <_f_punctuation>
		lcd_print(__x, __y, __buff);
    9874:	8a 2d       	mov	r24, r10
    9876:	6b 2d       	mov	r22, r11
    9878:	a6 01       	movw	r20, r12
    987a:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
    987e:	0e 5f       	subi	r16, 0xFE	; 254
    9880:	1f 4f       	sbci	r17, 0xFF	; 255
    9882:	08 94       	sec
    9884:	e1 1c       	adc	r14, r1
    9886:	f1 1c       	adc	r15, r1
	lcd_printf(1, 1, PSTR("1)Type:  5)Scroll:"));
	lcd_printf(2, 1, PSTR("2)Size:  6)Space :"));
	lcd_printf(3, 1, PSTR("3)Logo:  #)Save"));
	lcd_printf(4, 1, PSTR("4)Cut :  *)Exit"));

	for(__i = 0; __i < 6; __i++){
    9888:	f2 e0       	ldi	r31, 0x02	; 2
    988a:	0c 3e       	cpi	r16, 0xEC	; 236
    988c:	1f 07       	cpc	r17, r31
    988e:	c1 f6       	brne	.-80     	; 0x9840 <_menu_printer+0xf4>

		}
		if(__num >= 0x31 && __num <= 0x36){
			__lmt = pgm_read_byte(&__prntlmt[__num - 0x31]);
			__start = pgm_read_byte(&__prntstr[__num - 0x31]);
			if(__value[__num - 0x31] == __lmt)
    9890:	3e 01       	movw	r6, r28
    9892:	08 94       	sec
    9894:	61 1c       	adc	r6, r1
    9896:	71 1c       	adc	r7, r1
				__value[__num - 0x31] = __start;
			else
				__value[__num - 0x31]++;
			__x = pgm_read_byte(&__prntloc[__num - 0x31][0]);
			__y = pgm_read_byte(&__prntloc[__num - 0x31][1]);
			_f_inttostr(__buff, __value[__num - 0x31]);
    9898:	f7 e0       	ldi	r31, 0x07	; 7
    989a:	cf 2e       	mov	r12, r31
    989c:	d1 2c       	mov	r13, r1
    989e:	cc 0e       	add	r12, r28
    98a0:	dd 1e       	adc	r13, r29
		__key = _key_scan(1);
		__num = _key_btn(__key);
		if(__key == _KEY_CANCEL)
			return;
		if(__key==_KEY_ENTER){
			eeprom_write_byte(&DefPrinterType, __value[0]);
    98a2:	89 80       	ldd	r8, Y+1	; 0x01
			eeprom_write_byte(&DefPrintSize, __value[1]);
    98a4:	9a 80       	ldd	r9, Y+2	; 0x02
			eeprom_write_byte(&DefPrintLogo, __value[2]);
    98a6:	ab 80       	ldd	r10, Y+3	; 0x03
			eeprom_write_byte(&DefPrintAutoCut, __value[3]);
    98a8:	bc 80       	ldd	r11, Y+4	; 0x04
			eeprom_write_byte(&DefPrintScrollEnd, __value[4]);
    98aa:	ed 80       	ldd	r14, Y+5	; 0x05
			eeprom_write_byte(&DefPrintScrollSpace, __value[5]);
    98ac:	fe 80       	ldd	r15, Y+6	; 0x06
	}
    //sprintf_P(lcdteks,PSTR("6)Space :%.2d"),__value[5]);
	//lcd_print(2,10,lcdteks);

	while(1){	
		__key = _key_scan(1);
    98ae:	81 e0       	ldi	r24, 0x01	; 1
    98b0:	0e 94 06 b0 	call	0x1600c	; 0x1600c <_key_scan>
    98b4:	18 2f       	mov	r17, r24
		__num = _key_btn(__key);
    98b6:	0e 94 67 af 	call	0x15ece	; 0x15ece <_key_btn>
    98ba:	08 2f       	mov	r16, r24
		if(__key == _KEY_CANCEL)
    98bc:	17 3e       	cpi	r17, 0xE7	; 231
    98be:	09 f4       	brne	.+2      	; 0x98c2 <_menu_printer+0x176>
    98c0:	85 c0       	rjmp	.+266    	; 0x99cc <_menu_printer+0x280>
			return;
		if(__key==_KEY_ENTER){
    98c2:	17 3b       	cpi	r17, 0xB7	; 183
    98c4:	09 f0       	breq	.+2      	; 0x98c8 <_menu_printer+0x17c>
    98c6:	44 c0       	rjmp	.+136    	; 0x9950 <_menu_printer+0x204>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    98c8:	e1 99       	sbic	0x1c, 1	; 28
    98ca:	fe cf       	rjmp	.-4      	; 0x98c8 <_menu_printer+0x17c>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    98cc:	80 e3       	ldi	r24, 0x30	; 48
    98ce:	90 e0       	ldi	r25, 0x00	; 0
    98d0:	9f bb       	out	0x1f, r25	; 31
    98d2:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    98d4:	8d ba       	out	0x1d, r8	; 29

    __asm__ __volatile__ (
    98d6:	0f b6       	in	r0, 0x3f	; 63
    98d8:	f8 94       	cli
    98da:	e2 9a       	sbi	0x1c, 2	; 28
    98dc:	e1 9a       	sbi	0x1c, 1	; 28
    98de:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    98e0:	e1 99       	sbic	0x1c, 1	; 28
    98e2:	fe cf       	rjmp	.-4      	; 0x98e0 <_menu_printer+0x194>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    98e4:	e5 e3       	ldi	r30, 0x35	; 53
    98e6:	f0 e0       	ldi	r31, 0x00	; 0
    98e8:	ff bb       	out	0x1f, r31	; 31
    98ea:	ee bb       	out	0x1e, r30	; 30
#endif
    EEDR = __value;
    98ec:	9d ba       	out	0x1d, r9	; 29

    __asm__ __volatile__ (
    98ee:	0f b6       	in	r0, 0x3f	; 63
    98f0:	f8 94       	cli
    98f2:	e2 9a       	sbi	0x1c, 2	; 28
    98f4:	e1 9a       	sbi	0x1c, 1	; 28
    98f6:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    98f8:	e1 99       	sbic	0x1c, 1	; 28
    98fa:	fe cf       	rjmp	.-4      	; 0x98f8 <_menu_printer+0x1ac>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    98fc:	84 e3       	ldi	r24, 0x34	; 52
    98fe:	90 e0       	ldi	r25, 0x00	; 0
    9900:	9f bb       	out	0x1f, r25	; 31
    9902:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    9904:	ad ba       	out	0x1d, r10	; 29

    __asm__ __volatile__ (
    9906:	0f b6       	in	r0, 0x3f	; 63
    9908:	f8 94       	cli
    990a:	e2 9a       	sbi	0x1c, 2	; 28
    990c:	e1 9a       	sbi	0x1c, 1	; 28
    990e:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    9910:	e1 99       	sbic	0x1c, 1	; 28
    9912:	fe cf       	rjmp	.-4      	; 0x9910 <_menu_printer+0x1c4>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    9914:	e3 e3       	ldi	r30, 0x33	; 51
    9916:	f0 e0       	ldi	r31, 0x00	; 0
    9918:	ff bb       	out	0x1f, r31	; 31
    991a:	ee bb       	out	0x1e, r30	; 30
#endif
    EEDR = __value;
    991c:	bd ba       	out	0x1d, r11	; 29

    __asm__ __volatile__ (
    991e:	0f b6       	in	r0, 0x3f	; 63
    9920:	f8 94       	cli
    9922:	e2 9a       	sbi	0x1c, 2	; 28
    9924:	e1 9a       	sbi	0x1c, 1	; 28
    9926:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    9928:	e1 99       	sbic	0x1c, 1	; 28
    992a:	fe cf       	rjmp	.-4      	; 0x9928 <_menu_printer+0x1dc>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    992c:	3f ba       	out	0x1f, r3	; 31
    992e:	2e ba       	out	0x1e, r2	; 30
#endif
    EEDR = __value;
    9930:	ed ba       	out	0x1d, r14	; 29

    __asm__ __volatile__ (
    9932:	0f b6       	in	r0, 0x3f	; 63
    9934:	f8 94       	cli
    9936:	e2 9a       	sbi	0x1c, 2	; 28
    9938:	e1 9a       	sbi	0x1c, 1	; 28
    993a:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    993c:	e1 99       	sbic	0x1c, 1	; 28
    993e:	fe cf       	rjmp	.-4      	; 0x993c <_menu_printer+0x1f0>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    9940:	5f ba       	out	0x1f, r5	; 31
    9942:	4e ba       	out	0x1e, r4	; 30
#endif
    EEDR = __value;
    9944:	fd ba       	out	0x1d, r15	; 29

    __asm__ __volatile__ (
    9946:	0f b6       	in	r0, 0x3f	; 63
    9948:	f8 94       	cli
    994a:	e2 9a       	sbi	0x1c, 2	; 28
    994c:	e1 9a       	sbi	0x1c, 1	; 28
    994e:	0f be       	out	0x3f, r0	; 63
			eeprom_write_byte(&DefPrintAutoCut, __value[3]);
			eeprom_write_byte(&DefPrintScrollEnd, __value[4]);
			eeprom_write_byte(&DefPrintScrollSpace, __value[5]);

		}
		if(__num >= 0x31 && __num <= 0x36){
    9950:	80 2f       	mov	r24, r16
    9952:	81 53       	subi	r24, 0x31	; 49
    9954:	86 30       	cpi	r24, 0x06	; 6
    9956:	08 f0       	brcs	.+2      	; 0x995a <_menu_printer+0x20e>
    9958:	aa cf       	rjmp	.-172    	; 0x98ae <_menu_printer+0x162>
			__lmt = pgm_read_byte(&__prntlmt[__num - 0x31]);
    995a:	a0 2f       	mov	r26, r16
    995c:	b0 e0       	ldi	r27, 0x00	; 0
    995e:	d1 97       	sbiw	r26, 0x31	; 49
    9960:	fd 01       	movw	r30, r26
    9962:	e4 51       	subi	r30, 0x14	; 20
    9964:	fd 4f       	sbci	r31, 0xFD	; 253
    9966:	24 91       	lpm	r18, Z+
			__start = pgm_read_byte(&__prntstr[__num - 0x31]);
    9968:	fd 01       	movw	r30, r26
    996a:	ee 50       	subi	r30, 0x0E	; 14
    996c:	fd 4f       	sbci	r31, 0xFD	; 253
    996e:	94 91       	lpm	r25, Z+
			if(__value[__num - 0x31] == __lmt)
    9970:	f3 01       	movw	r30, r6
    9972:	ea 0f       	add	r30, r26
    9974:	fb 1f       	adc	r31, r27
    9976:	80 81       	ld	r24, Z
    9978:	82 17       	cp	r24, r18
    997a:	11 f4       	brne	.+4      	; 0x9980 <_menu_printer+0x234>
				__value[__num - 0x31] = __start;
    997c:	90 83       	st	Z, r25
    997e:	02 c0       	rjmp	.+4      	; 0x9984 <_menu_printer+0x238>
			else
				__value[__num - 0x31]++;
    9980:	8f 5f       	subi	r24, 0xFF	; 255
    9982:	80 83       	st	Z, r24
			__x = pgm_read_byte(&__prntloc[__num - 0x31][0]);
    9984:	9d 01       	movw	r18, r26
    9986:	22 0f       	add	r18, r18
    9988:	33 1f       	adc	r19, r19
    998a:	c9 01       	movw	r24, r18
    998c:	80 52       	subi	r24, 0x20	; 32
    998e:	9d 4f       	sbci	r25, 0xFD	; 253
    9990:	fc 01       	movw	r30, r24
    9992:	f4 90       	lpm	r15, Z+
			__y = pgm_read_byte(&__prntloc[__num - 0x31][1]);
    9994:	2f 51       	subi	r18, 0x1F	; 31
    9996:	3d 4f       	sbci	r19, 0xFD	; 253
    9998:	f9 01       	movw	r30, r18
    999a:	14 91       	lpm	r17, Z+
			_f_inttostr(__buff, __value[__num - 0x31]);
    999c:	a6 0d       	add	r26, r6
    999e:	b7 1d       	adc	r27, r7
    99a0:	4c 91       	ld	r20, X
    99a2:	50 e0       	ldi	r21, 0x00	; 0
    99a4:	60 e0       	ldi	r22, 0x00	; 0
    99a6:	70 e0       	ldi	r23, 0x00	; 0
    99a8:	c6 01       	movw	r24, r12
    99aa:	0e 94 65 19 	call	0x32ca	; 0x32ca <_f_inttostr>
			if((__num == 0x35)||(__num == 0x36))
    99ae:	05 53       	subi	r16, 0x35	; 53
    99b0:	02 30       	cpi	r16, 0x02	; 2
    99b2:	30 f4       	brcc	.+12     	; 0x99c0 <_menu_printer+0x274>
				_f_punctuation(__buff, 0, 2, 0);
    99b4:	c6 01       	movw	r24, r12
    99b6:	60 e0       	ldi	r22, 0x00	; 0
    99b8:	42 e0       	ldi	r20, 0x02	; 2
    99ba:	20 e0       	ldi	r18, 0x00	; 0
    99bc:	0e 94 bd 4a 	call	0x957a	; 0x957a <_f_punctuation>
			lcd_print(__x, __y, __buff);
    99c0:	8f 2d       	mov	r24, r15
    99c2:	61 2f       	mov	r22, r17
    99c4:	a6 01       	movw	r20, r12
    99c6:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
    99ca:	6b cf       	rjmp	.-298    	; 0x98a2 <_menu_printer+0x156>
		}
	}
}
    99cc:	2c 96       	adiw	r28, 0x0c	; 12
    99ce:	0f b6       	in	r0, 0x3f	; 63
    99d0:	f8 94       	cli
    99d2:	de bf       	out	0x3e, r29	; 62
    99d4:	0f be       	out	0x3f, r0	; 63
    99d6:	cd bf       	out	0x3d, r28	; 61
    99d8:	cf 91       	pop	r28
    99da:	df 91       	pop	r29
    99dc:	1f 91       	pop	r17
    99de:	0f 91       	pop	r16
    99e0:	ff 90       	pop	r15
    99e2:	ef 90       	pop	r14
    99e4:	df 90       	pop	r13
    99e6:	cf 90       	pop	r12
    99e8:	bf 90       	pop	r11
    99ea:	af 90       	pop	r10
    99ec:	9f 90       	pop	r9
    99ee:	8f 90       	pop	r8
    99f0:	7f 90       	pop	r7
    99f2:	6f 90       	pop	r6
    99f4:	5f 90       	pop	r5
    99f6:	4f 90       	pop	r4
    99f8:	3f 90       	pop	r3
    99fa:	2f 90       	pop	r2
    99fc:	08 95       	ret

000099fe <FSettingPrinter>:
char FSettingDatetime(){
     _menu_datetime();
     return MENU_DONE;
}
char FSettingPrinter(){
     _menu_printer();
    99fe:	0e 94 a6 4b 	call	0x974c	; 0x974c <_menu_printer>
	 return MENU_DONE;
}
    9a02:	81 e0       	ldi	r24, 0x01	; 1
    9a04:	08 95       	ret

00009a06 <SendPrint>:
	 for(i=0;i<strlen(Source);i++){
	    Dest[i]=pgm_read_byte(&Source[i]);
	 }
}

void SendPrint(char xSend,char xSendLead){
    9a06:	1f 93       	push	r17
    9a08:	18 2f       	mov	r17, r24
static char zSend;     
	 if (xSend==0x19){
    9a0a:	89 31       	cpi	r24, 0x19	; 25
    9a0c:	59 f4       	brne	.+22     	; 0x9a24 <SendPrint+0x1e>
	     if (zSend==xSendLead)_uart(_COM_PRINTER,1,xSendLead);
    9a0e:	40 91 89 02 	lds	r20, 0x0289
    9a12:	46 17       	cp	r20, r22
    9a14:	19 f4       	brne	.+6      	; 0x9a1c <SendPrint+0x16>
    9a16:	80 e0       	ldi	r24, 0x00	; 0
    9a18:	61 e0       	ldi	r22, 0x01	; 1
    9a1a:	07 c0       	rjmp	.+14     	; 0x9a2a <SendPrint+0x24>
		 else _uart(_COM_PRINTER,1,' ');	 
    9a1c:	80 e0       	ldi	r24, 0x00	; 0
    9a1e:	61 e0       	ldi	r22, 0x01	; 1
    9a20:	40 e2       	ldi	r20, 0x20	; 32
    9a22:	03 c0       	rjmp	.+6      	; 0x9a2a <SendPrint+0x24>
	 } 
	 else _uart(_COM_PRINTER,1,xSend);
    9a24:	80 e0       	ldi	r24, 0x00	; 0
    9a26:	61 e0       	ldi	r22, 0x01	; 1
    9a28:	41 2f       	mov	r20, r17
    9a2a:	0e 94 d5 b3 	call	0x167aa	; 0x167aa <_uart>
	 zSend=xSend;
    9a2e:	10 93 89 02 	sts	0x0289, r17
}
    9a32:	1f 91       	pop	r17
    9a34:	08 95       	ret

00009a36 <CarriegeReturn>:
	      break;	 
	 }
}

void CarriegeReturn(){
     _uart(_COM_PRINTER, 1, 0x0D);     
    9a36:	80 e0       	ldi	r24, 0x00	; 0
    9a38:	61 e0       	ldi	r22, 0x01	; 1
    9a3a:	4d e0       	ldi	r20, 0x0D	; 13
    9a3c:	0e 94 d5 b3 	call	0x167aa	; 0x167aa <_uart>
     _uart(_COM_PRINTER, 1, 0x0A);
    9a40:	80 e0       	ldi	r24, 0x00	; 0
    9a42:	61 e0       	ldi	r22, 0x01	; 1
    9a44:	4a e0       	ldi	r20, 0x0A	; 10
    9a46:	0e 94 d5 b3 	call	0x167aa	; 0x167aa <_uart>

}
    9a4a:	08 95       	ret

00009a4c <InitPrinter>:
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    9a4c:	e1 99       	sbic	0x1c, 1	; 28
    9a4e:	fe cf       	rjmp	.-4      	; 0x9a4c <InitPrinter>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    9a50:	80 e3       	ldi	r24, 0x30	; 48
    9a52:	90 e0       	ldi	r25, 0x00	; 0
    9a54:	9f bb       	out	0x1f, r25	; 31
    9a56:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    9a58:	e0 9a       	sbi	0x1c, 0	; 28
    9a5a:	8d b3       	in	r24, 0x1d	; 29
void InitPrinter(){
char PrinterType;
     PrinterType=eeprom_read_byte(&DefPrinterType);
    //Custom Printer TG02
	//Density Lowest: 1D 7C 00
	if (PrinterType==PT_CUSTOM_TG02){
    9a5c:	81 30       	cpi	r24, 0x01	; 1
    9a5e:	71 f5       	brne	.+92     	; 0x9abc <InitPrinter+0x70>
		_uart(_COM_PRINTER, 1, 0x1D);_uart(_COM_PRINTER, 1, 0x7C);_uart(_COM_PRINTER, 1, 0x00);
    9a60:	80 e0       	ldi	r24, 0x00	; 0
    9a62:	61 e0       	ldi	r22, 0x01	; 1
    9a64:	4d e1       	ldi	r20, 0x1D	; 29
    9a66:	0e 94 d5 b3 	call	0x167aa	; 0x167aa <_uart>
    9a6a:	80 e0       	ldi	r24, 0x00	; 0
    9a6c:	61 e0       	ldi	r22, 0x01	; 1
    9a6e:	4c e7       	ldi	r20, 0x7C	; 124
    9a70:	0e 94 d5 b3 	call	0x167aa	; 0x167aa <_uart>
    9a74:	80 e0       	ldi	r24, 0x00	; 0
    9a76:	61 e0       	ldi	r22, 0x01	; 1
    9a78:	40 e0       	ldi	r20, 0x00	; 0
    9a7a:	0e 94 d5 b3 	call	0x167aa	; 0x167aa <_uart>
		//Double Strike ON : 1B 47 01
		_uart(_COM_PRINTER, 1, 0x1B);_uart(_COM_PRINTER, 1, 0x47);_uart(_COM_PRINTER, 1, 0x01);
    9a7e:	80 e0       	ldi	r24, 0x00	; 0
    9a80:	61 e0       	ldi	r22, 0x01	; 1
    9a82:	4b e1       	ldi	r20, 0x1B	; 27
    9a84:	0e 94 d5 b3 	call	0x167aa	; 0x167aa <_uart>
    9a88:	80 e0       	ldi	r24, 0x00	; 0
    9a8a:	61 e0       	ldi	r22, 0x01	; 1
    9a8c:	47 e4       	ldi	r20, 0x47	; 71
    9a8e:	0e 94 d5 b3 	call	0x167aa	; 0x167aa <_uart>
    9a92:	80 e0       	ldi	r24, 0x00	; 0
    9a94:	61 e0       	ldi	r22, 0x01	; 1
    9a96:	41 e0       	ldi	r20, 0x01	; 1
    9a98:	0e 94 d5 b3 	call	0x167aa	; 0x167aa <_uart>
		//Font Setting: 1D 21 01
		_uart(_COM_PRINTER, 1, 0x1D);_uart(_COM_PRINTER, 1, 0x21);_uart(_COM_PRINTER, 1, 0x01);   
    9a9c:	80 e0       	ldi	r24, 0x00	; 0
    9a9e:	61 e0       	ldi	r22, 0x01	; 1
    9aa0:	4d e1       	ldi	r20, 0x1D	; 29
    9aa2:	0e 94 d5 b3 	call	0x167aa	; 0x167aa <_uart>
    9aa6:	80 e0       	ldi	r24, 0x00	; 0
    9aa8:	61 e0       	ldi	r22, 0x01	; 1
    9aaa:	41 e2       	ldi	r20, 0x21	; 33
    9aac:	0e 94 d5 b3 	call	0x167aa	; 0x167aa <_uart>
    9ab0:	80 e0       	ldi	r24, 0x00	; 0
    9ab2:	61 e0       	ldi	r22, 0x01	; 1
    9ab4:	41 e0       	ldi	r20, 0x01	; 1
    9ab6:	0e 94 d5 b3 	call	0x167aa	; 0x167aa <_uart>
    9aba:	08 95       	ret
		}
    else
	if (PrinterType==PT_CUSTOM_CUBE){
    9abc:	82 30       	cpi	r24, 0x02	; 2
    9abe:	69 f5       	brne	.+90     	; 0x9b1a <InitPrinter+0xce>
        //Print Density 0%
		_uart(_COM_PRINTER, 1, 0x1D);_uart(_COM_PRINTER, 1, 0x7C);_uart(_COM_PRINTER, 1, 0x04);
    9ac0:	80 e0       	ldi	r24, 0x00	; 0
    9ac2:	61 e0       	ldi	r22, 0x01	; 1
    9ac4:	4d e1       	ldi	r20, 0x1D	; 29
    9ac6:	0e 94 d5 b3 	call	0x167aa	; 0x167aa <_uart>
    9aca:	80 e0       	ldi	r24, 0x00	; 0
    9acc:	61 e0       	ldi	r22, 0x01	; 1
    9ace:	4c e7       	ldi	r20, 0x7C	; 124
    9ad0:	0e 94 d5 b3 	call	0x167aa	; 0x167aa <_uart>
    9ad4:	80 e0       	ldi	r24, 0x00	; 0
    9ad6:	61 e0       	ldi	r22, 0x01	; 1
    9ad8:	44 e0       	ldi	r20, 0x04	; 4
    9ada:	0e 94 d5 b3 	call	0x167aa	; 0x167aa <_uart>
		//Double Strike OFF : 1B 47 00
		_uart(_COM_PRINTER, 1, 0x1B);_uart(_COM_PRINTER, 1, 0x47);_uart(_COM_PRINTER, 1, 0x00);
    9ade:	80 e0       	ldi	r24, 0x00	; 0
    9ae0:	61 e0       	ldi	r22, 0x01	; 1
    9ae2:	4b e1       	ldi	r20, 0x1B	; 27
    9ae4:	0e 94 d5 b3 	call	0x167aa	; 0x167aa <_uart>
    9ae8:	80 e0       	ldi	r24, 0x00	; 0
    9aea:	61 e0       	ldi	r22, 0x01	; 1
    9aec:	47 e4       	ldi	r20, 0x47	; 71
    9aee:	0e 94 d5 b3 	call	0x167aa	; 0x167aa <_uart>
    9af2:	80 e0       	ldi	r24, 0x00	; 0
    9af4:	61 e0       	ldi	r22, 0x01	; 1
    9af6:	40 e0       	ldi	r20, 0x00	; 0
    9af8:	0e 94 d5 b3 	call	0x167aa	; 0x167aa <_uart>
		//Font Setting: 1D 21 01
		_uart(_COM_PRINTER, 1, 0x1D);_uart(_COM_PRINTER, 1, 0x21);_uart(_COM_PRINTER, 1, 0x00);   
    9afc:	80 e0       	ldi	r24, 0x00	; 0
    9afe:	61 e0       	ldi	r22, 0x01	; 1
    9b00:	4d e1       	ldi	r20, 0x1D	; 29
    9b02:	0e 94 d5 b3 	call	0x167aa	; 0x167aa <_uart>
    9b06:	80 e0       	ldi	r24, 0x00	; 0
    9b08:	61 e0       	ldi	r22, 0x01	; 1
    9b0a:	41 e2       	ldi	r20, 0x21	; 33
    9b0c:	0e 94 d5 b3 	call	0x167aa	; 0x167aa <_uart>
    9b10:	80 e0       	ldi	r24, 0x00	; 0
    9b12:	61 e0       	ldi	r22, 0x01	; 1
    9b14:	40 e0       	ldi	r20, 0x00	; 0
    9b16:	0e 94 d5 b3 	call	0x167aa	; 0x167aa <_uart>
    9b1a:	08 95       	ret

00009b1c <PrintNormalHeight>:
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    9b1c:	e1 99       	sbic	0x1c, 1	; 28
    9b1e:	fe cf       	rjmp	.-4      	; 0x9b1c <PrintNormalHeight>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    9b20:	80 e3       	ldi	r24, 0x30	; 48
    9b22:	90 e0       	ldi	r25, 0x00	; 0
    9b24:	9f bb       	out	0x1f, r25	; 31
    9b26:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    9b28:	e0 9a       	sbi	0x1c, 0	; 28
    9b2a:	8d b3       	in	r24, 0x1d	; 29
}

void PrintNormalHeight(){
char PrinterType;
     PrinterType=eeprom_read_byte(&DefPrinterType);
	 if (PrinterType==PT_CUSTOM_CUBE){
    9b2c:	82 30       	cpi	r24, 0x02	; 2
    9b2e:	79 f4       	brne	.+30     	; 0x9b4e <PrintNormalHeight+0x32>
	     _uart(_COM_PRINTER, 1, 0x1D);_uart(_COM_PRINTER, 1, 0x21);_uart(_COM_PRINTER, 1, 0x00);
    9b30:	80 e0       	ldi	r24, 0x00	; 0
    9b32:	61 e0       	ldi	r22, 0x01	; 1
    9b34:	4d e1       	ldi	r20, 0x1D	; 29
    9b36:	0e 94 d5 b3 	call	0x167aa	; 0x167aa <_uart>
    9b3a:	80 e0       	ldi	r24, 0x00	; 0
    9b3c:	61 e0       	ldi	r22, 0x01	; 1
    9b3e:	41 e2       	ldi	r20, 0x21	; 33
    9b40:	0e 94 d5 b3 	call	0x167aa	; 0x167aa <_uart>
    9b44:	80 e0       	ldi	r24, 0x00	; 0
    9b46:	61 e0       	ldi	r22, 0x01	; 1
    9b48:	40 e0       	ldi	r20, 0x00	; 0
    9b4a:	0e 94 d5 b3 	call	0x167aa	; 0x167aa <_uart>
    9b4e:	08 95       	ret

00009b50 <PrintDoubleHeight>:
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    9b50:	e1 99       	sbic	0x1c, 1	; 28
    9b52:	fe cf       	rjmp	.-4      	; 0x9b50 <PrintDoubleHeight>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    9b54:	80 e3       	ldi	r24, 0x30	; 48
    9b56:	90 e0       	ldi	r25, 0x00	; 0
    9b58:	9f bb       	out	0x1f, r25	; 31
    9b5a:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    9b5c:	e0 9a       	sbi	0x1c, 0	; 28
    9b5e:	8d b3       	in	r24, 0x1d	; 29
//void SetPrinterCharacterWidth

void PrintDoubleHeight(){
char PrinterType;
     PrinterType=eeprom_read_byte(&DefPrinterType);
	 if (PrinterType==PT_CUSTOM_CUBE){
    9b60:	82 30       	cpi	r24, 0x02	; 2
    9b62:	79 f4       	brne	.+30     	; 0x9b82 <PrintDoubleHeight+0x32>
	     _uart(_COM_PRINTER, 1, 0x1D);_uart(_COM_PRINTER, 1, 0x21);_uart(_COM_PRINTER, 1, 0x01);
    9b64:	80 e0       	ldi	r24, 0x00	; 0
    9b66:	61 e0       	ldi	r22, 0x01	; 1
    9b68:	4d e1       	ldi	r20, 0x1D	; 29
    9b6a:	0e 94 d5 b3 	call	0x167aa	; 0x167aa <_uart>
    9b6e:	80 e0       	ldi	r24, 0x00	; 0
    9b70:	61 e0       	ldi	r22, 0x01	; 1
    9b72:	41 e2       	ldi	r20, 0x21	; 33
    9b74:	0e 94 d5 b3 	call	0x167aa	; 0x167aa <_uart>
    9b78:	80 e0       	ldi	r24, 0x00	; 0
    9b7a:	61 e0       	ldi	r22, 0x01	; 1
    9b7c:	41 e0       	ldi	r20, 0x01	; 1
    9b7e:	0e 94 d5 b3 	call	0x167aa	; 0x167aa <_uart>
    9b82:	08 95       	ret

00009b84 <PaperCut>:

	 return Result;
}


void PaperCut(){
    9b84:	1f 93       	push	r17
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    9b86:	e1 99       	sbic	0x1c, 1	; 28
    9b88:	fe cf       	rjmp	.-4      	; 0x9b86 <PaperCut+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    9b8a:	83 e3       	ldi	r24, 0x33	; 51
    9b8c:	90 e0       	ldi	r25, 0x00	; 0
    9b8e:	9f bb       	out	0x1f, r25	; 31
    9b90:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    9b92:	e0 9a       	sbi	0x1c, 0	; 28
    9b94:	1d b3       	in	r17, 0x1d	; 29
     char CutType;
     CutType= eeprom_read_byte(&DefPrintAutoCut);
     _uart(_COM_PRINTER, 1, 0x1B);
    9b96:	80 e0       	ldi	r24, 0x00	; 0
    9b98:	61 e0       	ldi	r22, 0x01	; 1
    9b9a:	4b e1       	ldi	r20, 0x1B	; 27
    9b9c:	0e 94 d5 b3 	call	0x167aa	; 0x167aa <_uart>
	 if(CutType== 1) { _uart(_COM_PRINTER, 1, 0x6D);}
    9ba0:	11 30       	cpi	r17, 0x01	; 1
    9ba2:	21 f4       	brne	.+8      	; 0x9bac <PaperCut+0x28>
    9ba4:	80 e0       	ldi	r24, 0x00	; 0
    9ba6:	61 e0       	ldi	r22, 0x01	; 1
    9ba8:	4d e6       	ldi	r20, 0x6D	; 109
    9baa:	05 c0       	rjmp	.+10     	; 0x9bb6 <PaperCut+0x32>
	 if(CutType== 2) {_uart(_COM_PRINTER, 1, 0x69);}
    9bac:	12 30       	cpi	r17, 0x02	; 2
    9bae:	29 f4       	brne	.+10     	; 0x9bba <PaperCut+0x36>
    9bb0:	80 e0       	ldi	r24, 0x00	; 0
    9bb2:	61 e0       	ldi	r22, 0x01	; 1
    9bb4:	49 e6       	ldi	r20, 0x69	; 105
    9bb6:	0e 94 d5 b3 	call	0x167aa	; 0x167aa <_uart>

}
    9bba:	1f 91       	pop	r17
    9bbc:	08 95       	ret

00009bbe <sendMessage98>:
		        break;
	       }//EndSwitch
return Result;
}

void sendMessage98(char PumpID){
    9bbe:	ff 92       	push	r15
    9bc0:	0f 93       	push	r16
    9bc2:	1f 93       	push	r17
    9bc4:	df 93       	push	r29
    9bc6:	cf 93       	push	r28
    9bc8:	cd b7       	in	r28, 0x3d	; 61
    9bca:	de b7       	in	r29, 0x3e	; 62
    9bcc:	ea 97       	sbiw	r28, 0x3a	; 58
    9bce:	0f b6       	in	r0, 0x3f	; 63
    9bd0:	f8 94       	cli
    9bd2:	de bf       	out	0x3e, r29	; 62
    9bd4:	0f be       	out	0x3f, r0	; 63
    9bd6:	cd bf       	out	0x3d, r28	; 61
    9bd8:	f8 2e       	mov	r15, r24
	char __pump_id[8];
	char strSend[50];
	char xFIP_ID;
	
	_uart(1, 1,0x01);
    9bda:	81 e0       	ldi	r24, 0x01	; 1
    9bdc:	61 e0       	ldi	r22, 0x01	; 1
    9bde:	41 e0       	ldi	r20, 0x01	; 1
    9be0:	0e 94 d5 b3 	call	0x167aa	; 0x167aa <_uart>
    UpdateIFT_ID(); //ReadIFT_ID
    9be4:	0e 94 11 1c 	call	0x3822	; 0x3822 <UpdateIFT_ID>
	UpdateSeqNum(); //UpdateSeqNum SeqNum++
    9be8:	0e 94 e6 1b 	call	0x37cc	; 0x37cc <UpdateSeqNum>
	UpdateClientIP();//ReadSourceIP
    9bec:	0e 94 db 1f 	call	0x3fb6	; 0x3fb6 <UpdateClientIP>
	UpdateServerIP();//ReadDestIP
    9bf0:	0e 94 73 1f 	call	0x3ee6	; 0x3ee6 <UpdateServerIP>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    9bf4:	ce 01       	movw	r24, r28
    9bf6:	01 96       	adiw	r24, 0x01	; 1
    9bf8:	65 e4       	ldi	r22, 0x45	; 69
    9bfa:	70 e0       	ldi	r23, 0x00	; 0
    9bfc:	48 e0       	ldi	r20, 0x08	; 8
    9bfe:	50 e0       	ldi	r21, 0x00	; 0
    9c00:	26 ef       	ldi	r18, 0xF6	; 246
    9c02:	32 e1       	ldi	r19, 0x12	; 18
    9c04:	0e 94 7a b5 	call	0x16af4	; 0x16af4 <__eerd_block>
	eeprom_read_block((void*) &__pump_id, (const void*) &DefPumpMap, 8);
	xFIP_ID=__pump_id[PumpID-1];
	//if (xFIP_ID>16)xFIP_ID=16;
	sprintf_P(strSend,PSTR("%s%s%s%s98%.2dF968CFFB"),strIFT_ID,strSeqNum,strClientIP,strServerIP,xFIP_ID);
    9c08:	8d b7       	in	r24, 0x3d	; 61
    9c0a:	9e b7       	in	r25, 0x3e	; 62
    9c0c:	0e 97       	sbiw	r24, 0x0e	; 14
    9c0e:	0f b6       	in	r0, 0x3f	; 63
    9c10:	f8 94       	cli
    9c12:	9e bf       	out	0x3e, r25	; 62
    9c14:	0f be       	out	0x3f, r0	; 63
    9c16:	8d bf       	out	0x3d, r24	; 61
    9c18:	ad b7       	in	r26, 0x3d	; 61
    9c1a:	be b7       	in	r27, 0x3e	; 62
    9c1c:	11 96       	adiw	r26, 0x01	; 1
    9c1e:	8e 01       	movw	r16, r28
    9c20:	07 5f       	subi	r16, 0xF7	; 247
    9c22:	1f 4f       	sbci	r17, 0xFF	; 255
    9c24:	ed b7       	in	r30, 0x3d	; 61
    9c26:	fe b7       	in	r31, 0x3e	; 62
    9c28:	12 83       	std	Z+2, r17	; 0x02
    9c2a:	01 83       	std	Z+1, r16	; 0x01
    9c2c:	80 e4       	ldi	r24, 0x40	; 64
    9c2e:	9d e1       	ldi	r25, 0x1D	; 29
    9c30:	13 96       	adiw	r26, 0x03	; 3
    9c32:	9c 93       	st	X, r25
    9c34:	8e 93       	st	-X, r24
    9c36:	12 97       	sbiw	r26, 0x02	; 2
    9c38:	8c ec       	ldi	r24, 0xCC	; 204
    9c3a:	95 e0       	ldi	r25, 0x05	; 5
    9c3c:	15 96       	adiw	r26, 0x05	; 5
    9c3e:	9c 93       	st	X, r25
    9c40:	8e 93       	st	-X, r24
    9c42:	14 97       	sbiw	r26, 0x04	; 4
    9c44:	8b ea       	ldi	r24, 0xAB	; 171
    9c46:	9d e0       	ldi	r25, 0x0D	; 13
    9c48:	17 96       	adiw	r26, 0x07	; 7
    9c4a:	9c 93       	st	X, r25
    9c4c:	8e 93       	st	-X, r24
    9c4e:	16 97       	sbiw	r26, 0x06	; 6
    9c50:	8e eb       	ldi	r24, 0xBE	; 190
    9c52:	99 e0       	ldi	r25, 0x09	; 9
    9c54:	19 96       	adiw	r26, 0x09	; 9
    9c56:	9c 93       	st	X, r25
    9c58:	8e 93       	st	-X, r24
    9c5a:	18 97       	sbiw	r26, 0x08	; 8
    9c5c:	8b ee       	ldi	r24, 0xEB	; 235
    9c5e:	99 e0       	ldi	r25, 0x09	; 9
    9c60:	1b 96       	adiw	r26, 0x0b	; 11
    9c62:	9c 93       	st	X, r25
    9c64:	8e 93       	st	-X, r24
    9c66:	1a 97       	sbiw	r26, 0x0a	; 10
    9c68:	fe 01       	movw	r30, r28
    9c6a:	ef 0d       	add	r30, r15
    9c6c:	f1 1d       	adc	r31, r1
    9c6e:	80 81       	ld	r24, Z
    9c70:	1c 96       	adiw	r26, 0x0c	; 12
    9c72:	8c 93       	st	X, r24
    9c74:	1c 97       	sbiw	r26, 0x0c	; 12
    9c76:	1d 96       	adiw	r26, 0x0d	; 13
    9c78:	1c 92       	st	X, r1
    9c7a:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
	_uart_print(1, 0,strSend);
    9c7e:	8d b7       	in	r24, 0x3d	; 61
    9c80:	9e b7       	in	r25, 0x3e	; 62
    9c82:	0e 96       	adiw	r24, 0x0e	; 14
    9c84:	0f b6       	in	r0, 0x3f	; 63
    9c86:	f8 94       	cli
    9c88:	9e bf       	out	0x3e, r25	; 62
    9c8a:	0f be       	out	0x3f, r0	; 63
    9c8c:	8d bf       	out	0x3d, r24	; 61
    9c8e:	81 e0       	ldi	r24, 0x01	; 1
    9c90:	60 e0       	ldi	r22, 0x00	; 0
    9c92:	a8 01       	movw	r20, r16
    9c94:	0e 94 f2 b3 	call	0x167e4	; 0x167e4 <_uart_print>
	_uart(1, 1,0x02);
    9c98:	81 e0       	ldi	r24, 0x01	; 1
    9c9a:	61 e0       	ldi	r22, 0x01	; 1
    9c9c:	42 e0       	ldi	r20, 0x02	; 2
    9c9e:	0e 94 d5 b3 	call	0x167aa	; 0x167aa <_uart>
	IsBusyMsg11=True;
    9ca2:	81 e0       	ldi	r24, 0x01	; 1
    9ca4:	80 93 c4 01 	sts	0x01C4, r24
}
    9ca8:	ea 96       	adiw	r28, 0x3a	; 58
    9caa:	0f b6       	in	r0, 0x3f	; 63
    9cac:	f8 94       	cli
    9cae:	de bf       	out	0x3e, r29	; 62
    9cb0:	0f be       	out	0x3f, r0	; 63
    9cb2:	cd bf       	out	0x3d, r28	; 61
    9cb4:	cf 91       	pop	r28
    9cb6:	df 91       	pop	r29
    9cb8:	1f 91       	pop	r17
    9cba:	0f 91       	pop	r16
    9cbc:	ff 90       	pop	r15
    9cbe:	08 95       	ret

00009cc0 <sendMessage94>:
    //_uart_print(0, 0,strSend);
    _uart_print(1, 0,strSend);
	_uart(1, 1,0x02);
}

void sendMessage94(){//Void Transaction Message
    9cc0:	0f 93       	push	r16
    9cc2:	1f 93       	push	r17
    9cc4:	df 93       	push	r29
    9cc6:	cf 93       	push	r28
    9cc8:	cd b7       	in	r28, 0x3d	; 61
    9cca:	de b7       	in	r29, 0x3e	; 62
    9ccc:	c0 55       	subi	r28, 0x50	; 80
    9cce:	d0 40       	sbci	r29, 0x00	; 0
    9cd0:	0f b6       	in	r0, 0x3f	; 63
    9cd2:	f8 94       	cli
    9cd4:	de bf       	out	0x3e, r29	; 62
    9cd6:	0f be       	out	0x3f, r0	; 63
    9cd8:	cd bf       	out	0x3d, r28	; 61
	char strSend[80];
	_uart(1, 1,0x01);
    9cda:	81 e0       	ldi	r24, 0x01	; 1
    9cdc:	61 e0       	ldi	r22, 0x01	; 1
    9cde:	41 e0       	ldi	r20, 0x01	; 1
    9ce0:	0e 94 d5 b3 	call	0x167aa	; 0x167aa <_uart>
	UpdateIFT_ID(); //ReadIFT_ID
    9ce4:	0e 94 11 1c 	call	0x3822	; 0x3822 <UpdateIFT_ID>
	UpdateSeqNum(); //UpdateSeqNum SeqNum++
    9ce8:	0e 94 e6 1b 	call	0x37cc	; 0x37cc <UpdateSeqNum>
	UpdateClientIP();//ReadSourceIP
    9cec:	0e 94 db 1f 	call	0x3fb6	; 0x3fb6 <UpdateClientIP>
	UpdateServerIP();//ReadDestIP
    9cf0:	0e 94 73 1f 	call	0x3ee6	; 0x3ee6 <UpdateServerIP>
	sprintf_P(strSend,PSTR("%s%s%s%s94"),strIFT_ID,strSeqNum,strClientIP,strServerIP);
    9cf4:	8d b7       	in	r24, 0x3d	; 61
    9cf6:	9e b7       	in	r25, 0x3e	; 62
    9cf8:	0c 97       	sbiw	r24, 0x0c	; 12
    9cfa:	0f b6       	in	r0, 0x3f	; 63
    9cfc:	f8 94       	cli
    9cfe:	9e bf       	out	0x3e, r25	; 62
    9d00:	0f be       	out	0x3f, r0	; 63
    9d02:	8d bf       	out	0x3d, r24	; 61
    9d04:	ed b7       	in	r30, 0x3d	; 61
    9d06:	fe b7       	in	r31, 0x3e	; 62
    9d08:	31 96       	adiw	r30, 0x01	; 1
    9d0a:	8e 01       	movw	r16, r28
    9d0c:	0f 5f       	subi	r16, 0xFF	; 255
    9d0e:	1f 4f       	sbci	r17, 0xFF	; 255
    9d10:	ad b7       	in	r26, 0x3d	; 61
    9d12:	be b7       	in	r27, 0x3e	; 62
    9d14:	12 96       	adiw	r26, 0x02	; 2
    9d16:	1c 93       	st	X, r17
    9d18:	0e 93       	st	-X, r16
    9d1a:	11 97       	sbiw	r26, 0x01	; 1
    9d1c:	88 ed       	ldi	r24, 0xD8	; 216
    9d1e:	90 e2       	ldi	r25, 0x20	; 32
    9d20:	93 83       	std	Z+3, r25	; 0x03
    9d22:	82 83       	std	Z+2, r24	; 0x02
    9d24:	8c ec       	ldi	r24, 0xCC	; 204
    9d26:	95 e0       	ldi	r25, 0x05	; 5
    9d28:	95 83       	std	Z+5, r25	; 0x05
    9d2a:	84 83       	std	Z+4, r24	; 0x04
    9d2c:	8b ea       	ldi	r24, 0xAB	; 171
    9d2e:	9d e0       	ldi	r25, 0x0D	; 13
    9d30:	97 83       	std	Z+7, r25	; 0x07
    9d32:	86 83       	std	Z+6, r24	; 0x06
    9d34:	8e eb       	ldi	r24, 0xBE	; 190
    9d36:	99 e0       	ldi	r25, 0x09	; 9
    9d38:	91 87       	std	Z+9, r25	; 0x09
    9d3a:	80 87       	std	Z+8, r24	; 0x08
    9d3c:	8b ee       	ldi	r24, 0xEB	; 235
    9d3e:	99 e0       	ldi	r25, 0x09	; 9
    9d40:	93 87       	std	Z+11, r25	; 0x0b
    9d42:	82 87       	std	Z+10, r24	; 0x0a
    9d44:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    _uart_print(1, 0,strSend);
    9d48:	ed b7       	in	r30, 0x3d	; 61
    9d4a:	fe b7       	in	r31, 0x3e	; 62
    9d4c:	3c 96       	adiw	r30, 0x0c	; 12
    9d4e:	0f b6       	in	r0, 0x3f	; 63
    9d50:	f8 94       	cli
    9d52:	fe bf       	out	0x3e, r31	; 62
    9d54:	0f be       	out	0x3f, r0	; 63
    9d56:	ed bf       	out	0x3d, r30	; 61
    9d58:	81 e0       	ldi	r24, 0x01	; 1
    9d5a:	60 e0       	ldi	r22, 0x00	; 0
    9d5c:	a8 01       	movw	r20, r16
    9d5e:	0e 94 f2 b3 	call	0x167e4	; 0x167e4 <_uart_print>
    //_uart_print(0, 0,strSend);
	sprintf_P(strSend,PSTR("%s%s"),strInvoiceNumber,strDateTime);
    9d62:	8d b7       	in	r24, 0x3d	; 61
    9d64:	9e b7       	in	r25, 0x3e	; 62
    9d66:	08 97       	sbiw	r24, 0x08	; 8
    9d68:	0f b6       	in	r0, 0x3f	; 63
    9d6a:	f8 94       	cli
    9d6c:	9e bf       	out	0x3e, r25	; 62
    9d6e:	0f be       	out	0x3f, r0	; 63
    9d70:	8d bf       	out	0x3d, r24	; 61
    9d72:	ed b7       	in	r30, 0x3d	; 61
    9d74:	fe b7       	in	r31, 0x3e	; 62
    9d76:	31 96       	adiw	r30, 0x01	; 1
    9d78:	ad b7       	in	r26, 0x3d	; 61
    9d7a:	be b7       	in	r27, 0x3e	; 62
    9d7c:	12 96       	adiw	r26, 0x02	; 2
    9d7e:	1c 93       	st	X, r17
    9d80:	0e 93       	st	-X, r16
    9d82:	11 97       	sbiw	r26, 0x01	; 1
    9d84:	83 ed       	ldi	r24, 0xD3	; 211
    9d86:	90 e2       	ldi	r25, 0x20	; 32
    9d88:	93 83       	std	Z+3, r25	; 0x03
    9d8a:	82 83       	std	Z+2, r24	; 0x02
    9d8c:	86 e3       	ldi	r24, 0x36	; 54
    9d8e:	99 e0       	ldi	r25, 0x09	; 9
    9d90:	95 83       	std	Z+5, r25	; 0x05
    9d92:	84 83       	std	Z+4, r24	; 0x04
    9d94:	87 e9       	ldi	r24, 0x97	; 151
    9d96:	9d e0       	ldi	r25, 0x0D	; 13
    9d98:	97 83       	std	Z+7, r25	; 0x07
    9d9a:	86 83       	std	Z+6, r24	; 0x06
    9d9c:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    _uart_print(1, 0,strSend);
    9da0:	ed b7       	in	r30, 0x3d	; 61
    9da2:	fe b7       	in	r31, 0x3e	; 62
    9da4:	38 96       	adiw	r30, 0x08	; 8
    9da6:	0f b6       	in	r0, 0x3f	; 63
    9da8:	f8 94       	cli
    9daa:	fe bf       	out	0x3e, r31	; 62
    9dac:	0f be       	out	0x3f, r0	; 63
    9dae:	ed bf       	out	0x3d, r30	; 61
    9db0:	81 e0       	ldi	r24, 0x01	; 1
    9db2:	60 e0       	ldi	r22, 0x00	; 0
    9db4:	a8 01       	movw	r20, r16
    9db6:	0e 94 f2 b3 	call	0x167e4	; 0x167e4 <_uart_print>
	sprintf_P(strSend,PSTR("E9445512"));
    9dba:	00 d0       	rcall	.+0      	; 0x9dbc <sendMessage94+0xfc>
    9dbc:	00 d0       	rcall	.+0      	; 0x9dbe <sendMessage94+0xfe>
    9dbe:	ad b7       	in	r26, 0x3d	; 61
    9dc0:	be b7       	in	r27, 0x3e	; 62
    9dc2:	12 96       	adiw	r26, 0x02	; 2
    9dc4:	1c 93       	st	X, r17
    9dc6:	0e 93       	st	-X, r16
    9dc8:	11 97       	sbiw	r26, 0x01	; 1
    9dca:	8a ec       	ldi	r24, 0xCA	; 202
    9dcc:	90 e2       	ldi	r25, 0x20	; 32
    9dce:	14 96       	adiw	r26, 0x04	; 4
    9dd0:	9c 93       	st	X, r25
    9dd2:	8e 93       	st	-X, r24
    9dd4:	13 97       	sbiw	r26, 0x03	; 3
    9dd6:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    //_uart_print(0, 0,strSend);
    _uart_print(1, 0,strSend);
    9dda:	0f 90       	pop	r0
    9ddc:	0f 90       	pop	r0
    9dde:	0f 90       	pop	r0
    9de0:	0f 90       	pop	r0
    9de2:	81 e0       	ldi	r24, 0x01	; 1
    9de4:	60 e0       	ldi	r22, 0x00	; 0
    9de6:	a8 01       	movw	r20, r16
    9de8:	0e 94 f2 b3 	call	0x167e4	; 0x167e4 <_uart_print>
	_uart(1, 1,0x02);
    9dec:	81 e0       	ldi	r24, 0x01	; 1
    9dee:	61 e0       	ldi	r22, 0x01	; 1
    9df0:	42 e0       	ldi	r20, 0x02	; 2
    9df2:	0e 94 d5 b3 	call	0x167aa	; 0x167aa <_uart>
}
    9df6:	c0 5b       	subi	r28, 0xB0	; 176
    9df8:	df 4f       	sbci	r29, 0xFF	; 255
    9dfa:	0f b6       	in	r0, 0x3f	; 63
    9dfc:	f8 94       	cli
    9dfe:	de bf       	out	0x3e, r29	; 62
    9e00:	0f be       	out	0x3f, r0	; 63
    9e02:	cd bf       	out	0x3d, r28	; 61
    9e04:	cf 91       	pop	r28
    9e06:	df 91       	pop	r29
    9e08:	1f 91       	pop	r17
    9e0a:	0f 91       	pop	r16
    9e0c:	08 95       	ret

00009e0e <sendMessage92>:
	sprintf_P(strSend,PSTR("E9445512"));
    _uart_print(1, 0,strSend);
	_uart(1, 1,0x02);
}

void sendMessage92(){
    9e0e:	0f 93       	push	r16
    9e10:	1f 93       	push	r17
    9e12:	df 93       	push	r29
    9e14:	cf 93       	push	r28
    9e16:	cd b7       	in	r28, 0x3d	; 61
    9e18:	de b7       	in	r29, 0x3e	; 62
    9e1a:	c0 55       	subi	r28, 0x50	; 80
    9e1c:	d0 40       	sbci	r29, 0x00	; 0
    9e1e:	0f b6       	in	r0, 0x3f	; 63
    9e20:	f8 94       	cli
    9e22:	de bf       	out	0x3e, r29	; 62
    9e24:	0f be       	out	0x3f, r0	; 63
    9e26:	cd bf       	out	0x3d, r28	; 61
	char strSend[80];
	_uart(1, 1,0x01);
    9e28:	81 e0       	ldi	r24, 0x01	; 1
    9e2a:	61 e0       	ldi	r22, 0x01	; 1
    9e2c:	41 e0       	ldi	r20, 0x01	; 1
    9e2e:	0e 94 d5 b3 	call	0x167aa	; 0x167aa <_uart>
	UpdateIFT_ID(); //ReadIFT_ID
    9e32:	0e 94 11 1c 	call	0x3822	; 0x3822 <UpdateIFT_ID>
	UpdateSeqNum(); //UpdateSeqNum SeqNum++
    9e36:	0e 94 e6 1b 	call	0x37cc	; 0x37cc <UpdateSeqNum>
	UpdateClientIP();//ReadSourceIP
    9e3a:	0e 94 db 1f 	call	0x3fb6	; 0x3fb6 <UpdateClientIP>
	UpdateServerIP();//ReadDestIP
    9e3e:	0e 94 73 1f 	call	0x3ee6	; 0x3ee6 <UpdateServerIP>
	sprintf_P(strSend,PSTR("%s%s%s%s92"),strIFT_ID,strSeqNum,strClientIP,strServerIP);
    9e42:	8d b7       	in	r24, 0x3d	; 61
    9e44:	9e b7       	in	r25, 0x3e	; 62
    9e46:	0c 97       	sbiw	r24, 0x0c	; 12
    9e48:	0f b6       	in	r0, 0x3f	; 63
    9e4a:	f8 94       	cli
    9e4c:	9e bf       	out	0x3e, r25	; 62
    9e4e:	0f be       	out	0x3f, r0	; 63
    9e50:	8d bf       	out	0x3d, r24	; 61
    9e52:	ed b7       	in	r30, 0x3d	; 61
    9e54:	fe b7       	in	r31, 0x3e	; 62
    9e56:	31 96       	adiw	r30, 0x01	; 1
    9e58:	8e 01       	movw	r16, r28
    9e5a:	0f 5f       	subi	r16, 0xFF	; 255
    9e5c:	1f 4f       	sbci	r17, 0xFF	; 255
    9e5e:	ad b7       	in	r26, 0x3d	; 61
    9e60:	be b7       	in	r27, 0x3e	; 62
    9e62:	12 96       	adiw	r26, 0x02	; 2
    9e64:	1c 93       	st	X, r17
    9e66:	0e 93       	st	-X, r16
    9e68:	11 97       	sbiw	r26, 0x01	; 1
    9e6a:	8c ef       	ldi	r24, 0xFC	; 252
    9e6c:	90 e2       	ldi	r25, 0x20	; 32
    9e6e:	93 83       	std	Z+3, r25	; 0x03
    9e70:	82 83       	std	Z+2, r24	; 0x02
    9e72:	8c ec       	ldi	r24, 0xCC	; 204
    9e74:	95 e0       	ldi	r25, 0x05	; 5
    9e76:	95 83       	std	Z+5, r25	; 0x05
    9e78:	84 83       	std	Z+4, r24	; 0x04
    9e7a:	8b ea       	ldi	r24, 0xAB	; 171
    9e7c:	9d e0       	ldi	r25, 0x0D	; 13
    9e7e:	97 83       	std	Z+7, r25	; 0x07
    9e80:	86 83       	std	Z+6, r24	; 0x06
    9e82:	8e eb       	ldi	r24, 0xBE	; 190
    9e84:	99 e0       	ldi	r25, 0x09	; 9
    9e86:	91 87       	std	Z+9, r25	; 0x09
    9e88:	80 87       	std	Z+8, r24	; 0x08
    9e8a:	8b ee       	ldi	r24, 0xEB	; 235
    9e8c:	99 e0       	ldi	r25, 0x09	; 9
    9e8e:	93 87       	std	Z+11, r25	; 0x0b
    9e90:	82 87       	std	Z+10, r24	; 0x0a
    9e92:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    _uart_print(1, 0,strSend);
    9e96:	ed b7       	in	r30, 0x3d	; 61
    9e98:	fe b7       	in	r31, 0x3e	; 62
    9e9a:	3c 96       	adiw	r30, 0x0c	; 12
    9e9c:	0f b6       	in	r0, 0x3f	; 63
    9e9e:	f8 94       	cli
    9ea0:	fe bf       	out	0x3e, r31	; 62
    9ea2:	0f be       	out	0x3f, r0	; 63
    9ea4:	ed bf       	out	0x3d, r30	; 61
    9ea6:	81 e0       	ldi	r24, 0x01	; 1
    9ea8:	60 e0       	ldi	r22, 0x00	; 0
    9eaa:	a8 01       	movw	r20, r16
    9eac:	0e 94 f2 b3 	call	0x167e4	; 0x167e4 <_uart_print>
    //_uart_print(0, 0,strSend);
	sprintf_P(strSend,PSTR("%s%s%s%s"),strTranNo,strFIP_ID,strCardType,strCardID);
    9eb0:	8d b7       	in	r24, 0x3d	; 61
    9eb2:	9e b7       	in	r25, 0x3e	; 62
    9eb4:	0c 97       	sbiw	r24, 0x0c	; 12
    9eb6:	0f b6       	in	r0, 0x3f	; 63
    9eb8:	f8 94       	cli
    9eba:	9e bf       	out	0x3e, r25	; 62
    9ebc:	0f be       	out	0x3f, r0	; 63
    9ebe:	8d bf       	out	0x3d, r24	; 61
    9ec0:	ed b7       	in	r30, 0x3d	; 61
    9ec2:	fe b7       	in	r31, 0x3e	; 62
    9ec4:	31 96       	adiw	r30, 0x01	; 1
    9ec6:	ad b7       	in	r26, 0x3d	; 61
    9ec8:	be b7       	in	r27, 0x3e	; 62
    9eca:	12 96       	adiw	r26, 0x02	; 2
    9ecc:	1c 93       	st	X, r17
    9ece:	0e 93       	st	-X, r16
    9ed0:	11 97       	sbiw	r26, 0x01	; 1
    9ed2:	83 ef       	ldi	r24, 0xF3	; 243
    9ed4:	90 e2       	ldi	r25, 0x20	; 32
    9ed6:	93 83       	std	Z+3, r25	; 0x03
    9ed8:	82 83       	std	Z+2, r24	; 0x02
    9eda:	81 e6       	ldi	r24, 0x61	; 97
    9edc:	9e e0       	ldi	r25, 0x0E	; 14
    9ede:	95 83       	std	Z+5, r25	; 0x05
    9ee0:	84 83       	std	Z+4, r24	; 0x04
    9ee2:	8c e9       	ldi	r24, 0x9C	; 156
    9ee4:	99 e0       	ldi	r25, 0x09	; 9
    9ee6:	97 83       	std	Z+7, r25	; 0x07
    9ee8:	86 83       	std	Z+6, r24	; 0x06
    9eea:	8d e7       	ldi	r24, 0x7D	; 125
    9eec:	9e e0       	ldi	r25, 0x0E	; 14
    9eee:	91 87       	std	Z+9, r25	; 0x09
    9ef0:	80 87       	std	Z+8, r24	; 0x08
    9ef2:	81 e6       	ldi	r24, 0x61	; 97
    9ef4:	9d e0       	ldi	r25, 0x0D	; 13
    9ef6:	93 87       	std	Z+11, r25	; 0x0b
    9ef8:	82 87       	std	Z+10, r24	; 0x0a
    9efa:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    _uart_print(1, 0,strSend);
    9efe:	ed b7       	in	r30, 0x3d	; 61
    9f00:	fe b7       	in	r31, 0x3e	; 62
    9f02:	3c 96       	adiw	r30, 0x0c	; 12
    9f04:	0f b6       	in	r0, 0x3f	; 63
    9f06:	f8 94       	cli
    9f08:	fe bf       	out	0x3e, r31	; 62
    9f0a:	0f be       	out	0x3f, r0	; 63
    9f0c:	ed bf       	out	0x3d, r30	; 61
    9f0e:	81 e0       	ldi	r24, 0x01	; 1
    9f10:	60 e0       	ldi	r22, 0x00	; 0
    9f12:	a8 01       	movw	r20, r16
    9f14:	0e 94 f2 b3 	call	0x167e4	; 0x167e4 <_uart_print>
    //_uart_print(0, 0,strSend);
	sprintf_P(strSend,PSTR("%s%s%s"),strApprovalCode,strInvoiceNumber,strDateTime);
    9f18:	8d b7       	in	r24, 0x3d	; 61
    9f1a:	9e b7       	in	r25, 0x3e	; 62
    9f1c:	0a 97       	sbiw	r24, 0x0a	; 10
    9f1e:	0f b6       	in	r0, 0x3f	; 63
    9f20:	f8 94       	cli
    9f22:	9e bf       	out	0x3e, r25	; 62
    9f24:	0f be       	out	0x3f, r0	; 63
    9f26:	8d bf       	out	0x3d, r24	; 61
    9f28:	ed b7       	in	r30, 0x3d	; 61
    9f2a:	fe b7       	in	r31, 0x3e	; 62
    9f2c:	31 96       	adiw	r30, 0x01	; 1
    9f2e:	ad b7       	in	r26, 0x3d	; 61
    9f30:	be b7       	in	r27, 0x3e	; 62
    9f32:	12 96       	adiw	r26, 0x02	; 2
    9f34:	1c 93       	st	X, r17
    9f36:	0e 93       	st	-X, r16
    9f38:	11 97       	sbiw	r26, 0x01	; 1
    9f3a:	8c ee       	ldi	r24, 0xEC	; 236
    9f3c:	90 e2       	ldi	r25, 0x20	; 32
    9f3e:	93 83       	std	Z+3, r25	; 0x03
    9f40:	82 83       	std	Z+2, r24	; 0x02
    9f42:	84 ee       	ldi	r24, 0xE4	; 228
    9f44:	99 e0       	ldi	r25, 0x09	; 9
    9f46:	95 83       	std	Z+5, r25	; 0x05
    9f48:	84 83       	std	Z+4, r24	; 0x04
    9f4a:	86 e3       	ldi	r24, 0x36	; 54
    9f4c:	99 e0       	ldi	r25, 0x09	; 9
    9f4e:	97 83       	std	Z+7, r25	; 0x07
    9f50:	86 83       	std	Z+6, r24	; 0x06
    9f52:	87 e9       	ldi	r24, 0x97	; 151
    9f54:	9d e0       	ldi	r25, 0x0D	; 13
    9f56:	91 87       	std	Z+9, r25	; 0x09
    9f58:	80 87       	std	Z+8, r24	; 0x08
    9f5a:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    _uart_print(1, 0,strSend);
    9f5e:	ed b7       	in	r30, 0x3d	; 61
    9f60:	fe b7       	in	r31, 0x3e	; 62
    9f62:	3a 96       	adiw	r30, 0x0a	; 10
    9f64:	0f b6       	in	r0, 0x3f	; 63
    9f66:	f8 94       	cli
    9f68:	fe bf       	out	0x3e, r31	; 62
    9f6a:	0f be       	out	0x3f, r0	; 63
    9f6c:	ed bf       	out	0x3d, r30	; 61
    9f6e:	81 e0       	ldi	r24, 0x01	; 1
    9f70:	60 e0       	ldi	r22, 0x00	; 0
    9f72:	a8 01       	movw	r20, r16
    9f74:	0e 94 f2 b3 	call	0x167e4	; 0x167e4 <_uart_print>
    //_uart_print(0, 0,strSend);
	sprintf_P(strSend,PSTR("E9445512"));
    9f78:	00 d0       	rcall	.+0      	; 0x9f7a <sendMessage92+0x16c>
    9f7a:	00 d0       	rcall	.+0      	; 0x9f7c <sendMessage92+0x16e>
    9f7c:	ad b7       	in	r26, 0x3d	; 61
    9f7e:	be b7       	in	r27, 0x3e	; 62
    9f80:	12 96       	adiw	r26, 0x02	; 2
    9f82:	1c 93       	st	X, r17
    9f84:	0e 93       	st	-X, r16
    9f86:	11 97       	sbiw	r26, 0x01	; 1
    9f88:	83 ee       	ldi	r24, 0xE3	; 227
    9f8a:	90 e2       	ldi	r25, 0x20	; 32
    9f8c:	14 96       	adiw	r26, 0x04	; 4
    9f8e:	9c 93       	st	X, r25
    9f90:	8e 93       	st	-X, r24
    9f92:	13 97       	sbiw	r26, 0x03	; 3
    9f94:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    //_uart_print(0, 0,strSend);
    _uart_print(1, 0,strSend);
    9f98:	0f 90       	pop	r0
    9f9a:	0f 90       	pop	r0
    9f9c:	0f 90       	pop	r0
    9f9e:	0f 90       	pop	r0
    9fa0:	81 e0       	ldi	r24, 0x01	; 1
    9fa2:	60 e0       	ldi	r22, 0x00	; 0
    9fa4:	a8 01       	movw	r20, r16
    9fa6:	0e 94 f2 b3 	call	0x167e4	; 0x167e4 <_uart_print>
	_uart(1, 1,0x02);
    9faa:	81 e0       	ldi	r24, 0x01	; 1
    9fac:	61 e0       	ldi	r22, 0x01	; 1
    9fae:	42 e0       	ldi	r20, 0x02	; 2
    9fb0:	0e 94 d5 b3 	call	0x167aa	; 0x167aa <_uart>
}
    9fb4:	c0 5b       	subi	r28, 0xB0	; 176
    9fb6:	df 4f       	sbci	r29, 0xFF	; 255
    9fb8:	0f b6       	in	r0, 0x3f	; 63
    9fba:	f8 94       	cli
    9fbc:	de bf       	out	0x3e, r29	; 62
    9fbe:	0f be       	out	0x3f, r0	; 63
    9fc0:	cd bf       	out	0x3d, r28	; 61
    9fc2:	cf 91       	pop	r28
    9fc4:	df 91       	pop	r29
    9fc6:	1f 91       	pop	r17
    9fc8:	0f 91       	pop	r16
    9fca:	08 95       	ret

00009fcc <sendMessage90>:
	sprintf_P(strSend,PSTR("%dF0000000E123456FFFFF%sE9445512"),CardType,strOdometer);
    _uart_print(1, 0,strSend);
	_uart(1, 1,0x02);
}

void sendMessage90(){
    9fcc:	0f 93       	push	r16
    9fce:	1f 93       	push	r17
    9fd0:	df 93       	push	r29
    9fd2:	cf 93       	push	r28
    9fd4:	cd b7       	in	r28, 0x3d	; 61
    9fd6:	de b7       	in	r29, 0x3e	; 62
    9fd8:	c0 55       	subi	r28, 0x50	; 80
    9fda:	d0 40       	sbci	r29, 0x00	; 0
    9fdc:	0f b6       	in	r0, 0x3f	; 63
    9fde:	f8 94       	cli
    9fe0:	de bf       	out	0x3e, r29	; 62
    9fe2:	0f be       	out	0x3f, r0	; 63
    9fe4:	cd bf       	out	0x3d, r28	; 61
	char strSend[80];
	_uart(1, 1,0x01);
    9fe6:	81 e0       	ldi	r24, 0x01	; 1
    9fe8:	61 e0       	ldi	r22, 0x01	; 1
    9fea:	41 e0       	ldi	r20, 0x01	; 1
    9fec:	0e 94 d5 b3 	call	0x167aa	; 0x167aa <_uart>
	UpdateIFT_ID(); //ReadIFT_ID
    9ff0:	0e 94 11 1c 	call	0x3822	; 0x3822 <UpdateIFT_ID>
	UpdateSeqNum(); //UpdateSeqNum SeqNum++
    9ff4:	0e 94 e6 1b 	call	0x37cc	; 0x37cc <UpdateSeqNum>
	UpdateClientIP();//ReadSourceIP
    9ff8:	0e 94 db 1f 	call	0x3fb6	; 0x3fb6 <UpdateClientIP>
	UpdateServerIP();//ReadDestIP
    9ffc:	0e 94 73 1f 	call	0x3ee6	; 0x3ee6 <UpdateServerIP>
	sprintf_P(strSend,PSTR("%s%s%s%s90"),strIFT_ID,strSeqNum,strClientIP,strServerIP);
    a000:	8d b7       	in	r24, 0x3d	; 61
    a002:	9e b7       	in	r25, 0x3e	; 62
    a004:	0c 97       	sbiw	r24, 0x0c	; 12
    a006:	0f b6       	in	r0, 0x3f	; 63
    a008:	f8 94       	cli
    a00a:	9e bf       	out	0x3e, r25	; 62
    a00c:	0f be       	out	0x3f, r0	; 63
    a00e:	8d bf       	out	0x3d, r24	; 61
    a010:	ed b7       	in	r30, 0x3d	; 61
    a012:	fe b7       	in	r31, 0x3e	; 62
    a014:	31 96       	adiw	r30, 0x01	; 1
    a016:	8e 01       	movw	r16, r28
    a018:	0f 5f       	subi	r16, 0xFF	; 255
    a01a:	1f 4f       	sbci	r17, 0xFF	; 255
    a01c:	ad b7       	in	r26, 0x3d	; 61
    a01e:	be b7       	in	r27, 0x3e	; 62
    a020:	12 96       	adiw	r26, 0x02	; 2
    a022:	1c 93       	st	X, r17
    a024:	0e 93       	st	-X, r16
    a026:	11 97       	sbiw	r26, 0x01	; 1
    a028:	85 e1       	ldi	r24, 0x15	; 21
    a02a:	91 e2       	ldi	r25, 0x21	; 33
    a02c:	93 83       	std	Z+3, r25	; 0x03
    a02e:	82 83       	std	Z+2, r24	; 0x02
    a030:	8c ec       	ldi	r24, 0xCC	; 204
    a032:	95 e0       	ldi	r25, 0x05	; 5
    a034:	95 83       	std	Z+5, r25	; 0x05
    a036:	84 83       	std	Z+4, r24	; 0x04
    a038:	8b ea       	ldi	r24, 0xAB	; 171
    a03a:	9d e0       	ldi	r25, 0x0D	; 13
    a03c:	97 83       	std	Z+7, r25	; 0x07
    a03e:	86 83       	std	Z+6, r24	; 0x06
    a040:	8e eb       	ldi	r24, 0xBE	; 190
    a042:	99 e0       	ldi	r25, 0x09	; 9
    a044:	91 87       	std	Z+9, r25	; 0x09
    a046:	80 87       	std	Z+8, r24	; 0x08
    a048:	8b ee       	ldi	r24, 0xEB	; 235
    a04a:	99 e0       	ldi	r25, 0x09	; 9
    a04c:	93 87       	std	Z+11, r25	; 0x0b
    a04e:	82 87       	std	Z+10, r24	; 0x0a
    a050:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    _uart_print(1, 0,strSend);
    a054:	ed b7       	in	r30, 0x3d	; 61
    a056:	fe b7       	in	r31, 0x3e	; 62
    a058:	3c 96       	adiw	r30, 0x0c	; 12
    a05a:	0f b6       	in	r0, 0x3f	; 63
    a05c:	f8 94       	cli
    a05e:	fe bf       	out	0x3e, r31	; 62
    a060:	0f be       	out	0x3f, r0	; 63
    a062:	ed bf       	out	0x3d, r30	; 61
    a064:	81 e0       	ldi	r24, 0x01	; 1
    a066:	60 e0       	ldi	r22, 0x00	; 0
    a068:	a8 01       	movw	r20, r16
    a06a:	0e 94 f2 b3 	call	0x167e4	; 0x167e4 <_uart_print>
	sprintf_P(strSend,PSTR("%s%s"),strFIP_ID,strRef1);
    a06e:	8d b7       	in	r24, 0x3d	; 61
    a070:	9e b7       	in	r25, 0x3e	; 62
    a072:	08 97       	sbiw	r24, 0x08	; 8
    a074:	0f b6       	in	r0, 0x3f	; 63
    a076:	f8 94       	cli
    a078:	9e bf       	out	0x3e, r25	; 62
    a07a:	0f be       	out	0x3f, r0	; 63
    a07c:	8d bf       	out	0x3d, r24	; 61
    a07e:	ed b7       	in	r30, 0x3d	; 61
    a080:	fe b7       	in	r31, 0x3e	; 62
    a082:	31 96       	adiw	r30, 0x01	; 1
    a084:	ad b7       	in	r26, 0x3d	; 61
    a086:	be b7       	in	r27, 0x3e	; 62
    a088:	12 96       	adiw	r26, 0x02	; 2
    a08a:	1c 93       	st	X, r17
    a08c:	0e 93       	st	-X, r16
    a08e:	11 97       	sbiw	r26, 0x01	; 1
    a090:	80 e1       	ldi	r24, 0x10	; 16
    a092:	91 e2       	ldi	r25, 0x21	; 33
    a094:	93 83       	std	Z+3, r25	; 0x03
    a096:	82 83       	std	Z+2, r24	; 0x02
    a098:	8c e9       	ldi	r24, 0x9C	; 156
    a09a:	99 e0       	ldi	r25, 0x09	; 9
    a09c:	95 83       	std	Z+5, r25	; 0x05
    a09e:	84 83       	std	Z+4, r24	; 0x04
    a0a0:	88 e6       	ldi	r24, 0x68	; 104
    a0a2:	9e e0       	ldi	r25, 0x0E	; 14
    a0a4:	97 83       	std	Z+7, r25	; 0x07
    a0a6:	86 83       	std	Z+6, r24	; 0x06
    a0a8:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    _uart_print(1, 0,strSend);
    a0ac:	ed b7       	in	r30, 0x3d	; 61
    a0ae:	fe b7       	in	r31, 0x3e	; 62
    a0b0:	38 96       	adiw	r30, 0x08	; 8
    a0b2:	0f b6       	in	r0, 0x3f	; 63
    a0b4:	f8 94       	cli
    a0b6:	fe bf       	out	0x3e, r31	; 62
    a0b8:	0f be       	out	0x3f, r0	; 63
    a0ba:	ed bf       	out	0x3d, r30	; 61
    a0bc:	81 e0       	ldi	r24, 0x01	; 1
    a0be:	60 e0       	ldi	r22, 0x00	; 0
    a0c0:	a8 01       	movw	r20, r16
    a0c2:	0e 94 f2 b3 	call	0x167e4	; 0x167e4 <_uart_print>
	sprintf_P(strSend,PSTR("E9445512"));
    a0c6:	00 d0       	rcall	.+0      	; 0xa0c8 <sendMessage90+0xfc>
    a0c8:	00 d0       	rcall	.+0      	; 0xa0ca <sendMessage90+0xfe>
    a0ca:	ad b7       	in	r26, 0x3d	; 61
    a0cc:	be b7       	in	r27, 0x3e	; 62
    a0ce:	12 96       	adiw	r26, 0x02	; 2
    a0d0:	1c 93       	st	X, r17
    a0d2:	0e 93       	st	-X, r16
    a0d4:	11 97       	sbiw	r26, 0x01	; 1
    a0d6:	87 e0       	ldi	r24, 0x07	; 7
    a0d8:	91 e2       	ldi	r25, 0x21	; 33
    a0da:	14 96       	adiw	r26, 0x04	; 4
    a0dc:	9c 93       	st	X, r25
    a0de:	8e 93       	st	-X, r24
    a0e0:	13 97       	sbiw	r26, 0x03	; 3
    a0e2:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    _uart_print(1, 0,strSend);
    a0e6:	0f 90       	pop	r0
    a0e8:	0f 90       	pop	r0
    a0ea:	0f 90       	pop	r0
    a0ec:	0f 90       	pop	r0
    a0ee:	81 e0       	ldi	r24, 0x01	; 1
    a0f0:	60 e0       	ldi	r22, 0x00	; 0
    a0f2:	a8 01       	movw	r20, r16
    a0f4:	0e 94 f2 b3 	call	0x167e4	; 0x167e4 <_uart_print>
	_uart(1, 1,0x02);
    a0f8:	81 e0       	ldi	r24, 0x01	; 1
    a0fa:	61 e0       	ldi	r22, 0x01	; 1
    a0fc:	42 e0       	ldi	r20, 0x02	; 2
    a0fe:	0e 94 d5 b3 	call	0x167aa	; 0x167aa <_uart>
}
    a102:	c0 5b       	subi	r28, 0xB0	; 176
    a104:	df 4f       	sbci	r29, 0xFF	; 255
    a106:	0f b6       	in	r0, 0x3f	; 63
    a108:	f8 94       	cli
    a10a:	de bf       	out	0x3e, r29	; 62
    a10c:	0f be       	out	0x3f, r0	; 63
    a10e:	cd bf       	out	0x3d, r28	; 61
    a110:	cf 91       	pop	r28
    a112:	df 91       	pop	r29
    a114:	1f 91       	pop	r17
    a116:	0f 91       	pop	r16
    a118:	08 95       	ret

0000a11a <sendMessage58>:

	_uart_printf(1,0,PSTR("AF968CFFB"));
	_uart(1, 1,0x02);
}

void sendMessage58(){
    a11a:	cf 92       	push	r12
    a11c:	df 92       	push	r13
    a11e:	ef 92       	push	r14
    a120:	ff 92       	push	r15
    a122:	0f 93       	push	r16
    a124:	1f 93       	push	r17
    a126:	df 93       	push	r29
    a128:	cf 93       	push	r28
    a12a:	cd b7       	in	r28, 0x3d	; 61
    a12c:	de b7       	in	r29, 0x3e	; 62
    a12e:	c0 55       	subi	r28, 0x50	; 80
    a130:	d0 40       	sbci	r29, 0x00	; 0
    a132:	0f b6       	in	r0, 0x3f	; 63
    a134:	f8 94       	cli
    a136:	de bf       	out	0x3e, r29	; 62
    a138:	0f be       	out	0x3f, r0	; 63
    a13a:	cd bf       	out	0x3d, r28	; 61
	char strSend[80];
	_uart(1, 1,0x01);
    a13c:	81 e0       	ldi	r24, 0x01	; 1
    a13e:	61 e0       	ldi	r22, 0x01	; 1
    a140:	41 e0       	ldi	r20, 0x01	; 1
    a142:	0e 94 d5 b3 	call	0x167aa	; 0x167aa <_uart>
	UpdateIFT_ID(); //ReadIFT_ID
    a146:	0e 94 11 1c 	call	0x3822	; 0x3822 <UpdateIFT_ID>
	UpdateSeqNum(); //UpdateSeqNum SeqNum++
    a14a:	0e 94 e6 1b 	call	0x37cc	; 0x37cc <UpdateSeqNum>
	UpdateClientIP();//ReadSourceIP
    a14e:	0e 94 db 1f 	call	0x3fb6	; 0x3fb6 <UpdateClientIP>
	UpdateServerIP();//ReadDestIP
    a152:	0e 94 73 1f 	call	0x3ee6	; 0x3ee6 <UpdateServerIP>
	UpdateCardID();  //ReadCardID
    a156:	0e 94 55 40 	call	0x80aa	; 0x80aa <UpdateCardID>
	sprintf_P(strSend,PSTR("%s%s%s%s58"),strIFT_ID,strSeqNum,strClientIP,strServerIP);
    a15a:	8d b7       	in	r24, 0x3d	; 61
    a15c:	9e b7       	in	r25, 0x3e	; 62
    a15e:	0c 97       	sbiw	r24, 0x0c	; 12
    a160:	0f b6       	in	r0, 0x3f	; 63
    a162:	f8 94       	cli
    a164:	9e bf       	out	0x3e, r25	; 62
    a166:	0f be       	out	0x3f, r0	; 63
    a168:	8d bf       	out	0x3d, r24	; 61
    a16a:	ed b7       	in	r30, 0x3d	; 61
    a16c:	fe b7       	in	r31, 0x3e	; 62
    a16e:	31 96       	adiw	r30, 0x01	; 1
    a170:	8e 01       	movw	r16, r28
    a172:	0f 5f       	subi	r16, 0xFF	; 255
    a174:	1f 4f       	sbci	r17, 0xFF	; 255
    a176:	ad b7       	in	r26, 0x3d	; 61
    a178:	be b7       	in	r27, 0x3e	; 62
    a17a:	12 96       	adiw	r26, 0x02	; 2
    a17c:	1c 93       	st	X, r17
    a17e:	0e 93       	st	-X, r16
    a180:	11 97       	sbiw	r26, 0x01	; 1
    a182:	8c e4       	ldi	r24, 0x4C	; 76
    a184:	91 e2       	ldi	r25, 0x21	; 33
    a186:	93 83       	std	Z+3, r25	; 0x03
    a188:	82 83       	std	Z+2, r24	; 0x02
    a18a:	8c ec       	ldi	r24, 0xCC	; 204
    a18c:	95 e0       	ldi	r25, 0x05	; 5
    a18e:	95 83       	std	Z+5, r25	; 0x05
    a190:	84 83       	std	Z+4, r24	; 0x04
    a192:	8b ea       	ldi	r24, 0xAB	; 171
    a194:	9d e0       	ldi	r25, 0x0D	; 13
    a196:	97 83       	std	Z+7, r25	; 0x07
    a198:	86 83       	std	Z+6, r24	; 0x06
    a19a:	8e eb       	ldi	r24, 0xBE	; 190
    a19c:	99 e0       	ldi	r25, 0x09	; 9
    a19e:	91 87       	std	Z+9, r25	; 0x09
    a1a0:	80 87       	std	Z+8, r24	; 0x08
    a1a2:	8b ee       	ldi	r24, 0xEB	; 235
    a1a4:	99 e0       	ldi	r25, 0x09	; 9
    a1a6:	93 87       	std	Z+11, r25	; 0x0b
    a1a8:	82 87       	std	Z+10, r24	; 0x0a
    a1aa:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    _uart_print(1, 0,strSend);
    a1ae:	8d b7       	in	r24, 0x3d	; 61
    a1b0:	9e b7       	in	r25, 0x3e	; 62
    a1b2:	0c 96       	adiw	r24, 0x0c	; 12
    a1b4:	0f b6       	in	r0, 0x3f	; 63
    a1b6:	f8 94       	cli
    a1b8:	9e bf       	out	0x3e, r25	; 62
    a1ba:	0f be       	out	0x3f, r0	; 63
    a1bc:	8d bf       	out	0x3d, r24	; 61
    a1be:	81 e0       	ldi	r24, 0x01	; 1
    a1c0:	60 e0       	ldi	r22, 0x00	; 0
    a1c2:	a8 01       	movw	r20, r16
    a1c4:	0e 94 f2 b3 	call	0x167e4	; 0x167e4 <_uart_print>
	AddSpaceLead(strBalanceValue,13);
    a1c8:	9a ef       	ldi	r25, 0xFA	; 250
    a1ca:	e9 2e       	mov	r14, r25
    a1cc:	9d e0       	ldi	r25, 0x0D	; 13
    a1ce:	f9 2e       	mov	r15, r25
    a1d0:	c7 01       	movw	r24, r14
    a1d2:	6d e0       	ldi	r22, 0x0D	; 13
    a1d4:	0e 94 d9 2d 	call	0x5bb2	; 0x5bb2 <AddSpaceLead>
	AddSpaceLead(strOdometer,10);
    a1d8:	83 ea       	ldi	r24, 0xA3	; 163
    a1da:	c8 2e       	mov	r12, r24
    a1dc:	85 e0       	ldi	r24, 0x05	; 5
    a1de:	d8 2e       	mov	r13, r24
    a1e0:	c6 01       	movw	r24, r12
    a1e2:	6a e0       	ldi	r22, 0x0A	; 10
    a1e4:	0e 94 d9 2d 	call	0x5bb2	; 0x5bb2 <AddSpaceLead>
	sprintf_P(strSend,PSTR("%s%s%d%s%s"),strCardID,strFIP_ID,NozzleID,strBalanceType,strBalanceValue);
    a1e8:	ad b7       	in	r26, 0x3d	; 61
    a1ea:	be b7       	in	r27, 0x3e	; 62
    a1ec:	1e 97       	sbiw	r26, 0x0e	; 14
    a1ee:	0f b6       	in	r0, 0x3f	; 63
    a1f0:	f8 94       	cli
    a1f2:	be bf       	out	0x3e, r27	; 62
    a1f4:	0f be       	out	0x3f, r0	; 63
    a1f6:	ad bf       	out	0x3d, r26	; 61
    a1f8:	ed b7       	in	r30, 0x3d	; 61
    a1fa:	fe b7       	in	r31, 0x3e	; 62
    a1fc:	31 96       	adiw	r30, 0x01	; 1
    a1fe:	12 96       	adiw	r26, 0x02	; 2
    a200:	1c 93       	st	X, r17
    a202:	0e 93       	st	-X, r16
    a204:	11 97       	sbiw	r26, 0x01	; 1
    a206:	81 e4       	ldi	r24, 0x41	; 65
    a208:	91 e2       	ldi	r25, 0x21	; 33
    a20a:	93 83       	std	Z+3, r25	; 0x03
    a20c:	82 83       	std	Z+2, r24	; 0x02
    a20e:	81 e6       	ldi	r24, 0x61	; 97
    a210:	9d e0       	ldi	r25, 0x0D	; 13
    a212:	95 83       	std	Z+5, r25	; 0x05
    a214:	84 83       	std	Z+4, r24	; 0x04
    a216:	8c e9       	ldi	r24, 0x9C	; 156
    a218:	99 e0       	ldi	r25, 0x09	; 9
    a21a:	97 83       	std	Z+7, r25	; 0x07
    a21c:	86 83       	std	Z+6, r24	; 0x06
    a21e:	80 91 50 09 	lds	r24, 0x0950
    a222:	80 87       	std	Z+8, r24	; 0x08
    a224:	11 86       	std	Z+9, r1	; 0x09
    a226:	83 e8       	ldi	r24, 0x83	; 131
    a228:	95 e0       	ldi	r25, 0x05	; 5
    a22a:	93 87       	std	Z+11, r25	; 0x0b
    a22c:	82 87       	std	Z+10, r24	; 0x0a
    a22e:	f5 86       	std	Z+13, r15	; 0x0d
    a230:	e4 86       	std	Z+12, r14	; 0x0c
    a232:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    _uart_print(1, 0,strSend);
    a236:	8d b7       	in	r24, 0x3d	; 61
    a238:	9e b7       	in	r25, 0x3e	; 62
    a23a:	0e 96       	adiw	r24, 0x0e	; 14
    a23c:	0f b6       	in	r0, 0x3f	; 63
    a23e:	f8 94       	cli
    a240:	9e bf       	out	0x3e, r25	; 62
    a242:	0f be       	out	0x3f, r0	; 63
    a244:	8d bf       	out	0x3d, r24	; 61
    a246:	81 e0       	ldi	r24, 0x01	; 1
    a248:	60 e0       	ldi	r22, 0x00	; 0
    a24a:	a8 01       	movw	r20, r16
    a24c:	0e 94 f2 b3 	call	0x167e4	; 0x167e4 <_uart_print>

	CardType=0;
    a250:	10 92 69 05 	sts	0x0569, r1
	sprintf_P(strSend,PSTR("%dF0000000E123456FFFFF%sE9445512"),CardType,strOdometer);
    a254:	ad b7       	in	r26, 0x3d	; 61
    a256:	be b7       	in	r27, 0x3e	; 62
    a258:	18 97       	sbiw	r26, 0x08	; 8
    a25a:	0f b6       	in	r0, 0x3f	; 63
    a25c:	f8 94       	cli
    a25e:	be bf       	out	0x3e, r27	; 62
    a260:	0f be       	out	0x3f, r0	; 63
    a262:	ad bf       	out	0x3d, r26	; 61
    a264:	ed b7       	in	r30, 0x3d	; 61
    a266:	fe b7       	in	r31, 0x3e	; 62
    a268:	31 96       	adiw	r30, 0x01	; 1
    a26a:	12 96       	adiw	r26, 0x02	; 2
    a26c:	1c 93       	st	X, r17
    a26e:	0e 93       	st	-X, r16
    a270:	11 97       	sbiw	r26, 0x01	; 1
    a272:	80 e2       	ldi	r24, 0x20	; 32
    a274:	91 e2       	ldi	r25, 0x21	; 33
    a276:	93 83       	std	Z+3, r25	; 0x03
    a278:	82 83       	std	Z+2, r24	; 0x02
    a27a:	15 82       	std	Z+5, r1	; 0x05
    a27c:	14 82       	std	Z+4, r1	; 0x04
    a27e:	d7 82       	std	Z+7, r13	; 0x07
    a280:	c6 82       	std	Z+6, r12	; 0x06
    a282:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    _uart_print(1, 0,strSend);
    a286:	8d b7       	in	r24, 0x3d	; 61
    a288:	9e b7       	in	r25, 0x3e	; 62
    a28a:	08 96       	adiw	r24, 0x08	; 8
    a28c:	0f b6       	in	r0, 0x3f	; 63
    a28e:	f8 94       	cli
    a290:	9e bf       	out	0x3e, r25	; 62
    a292:	0f be       	out	0x3f, r0	; 63
    a294:	8d bf       	out	0x3d, r24	; 61
    a296:	81 e0       	ldi	r24, 0x01	; 1
    a298:	60 e0       	ldi	r22, 0x00	; 0
    a29a:	a8 01       	movw	r20, r16
    a29c:	0e 94 f2 b3 	call	0x167e4	; 0x167e4 <_uart_print>
	_uart(1, 1,0x02);
    a2a0:	81 e0       	ldi	r24, 0x01	; 1
    a2a2:	61 e0       	ldi	r22, 0x01	; 1
    a2a4:	42 e0       	ldi	r20, 0x02	; 2
    a2a6:	0e 94 d5 b3 	call	0x167aa	; 0x167aa <_uart>
}
    a2aa:	c0 5b       	subi	r28, 0xB0	; 176
    a2ac:	df 4f       	sbci	r29, 0xFF	; 255
    a2ae:	0f b6       	in	r0, 0x3f	; 63
    a2b0:	f8 94       	cli
    a2b2:	de bf       	out	0x3e, r29	; 62
    a2b4:	0f be       	out	0x3f, r0	; 63
    a2b6:	cd bf       	out	0x3d, r28	; 61
    a2b8:	cf 91       	pop	r28
    a2ba:	df 91       	pop	r29
    a2bc:	1f 91       	pop	r17
    a2be:	0f 91       	pop	r16
    a2c0:	ff 90       	pop	r15
    a2c2:	ef 90       	pop	r14
    a2c4:	df 90       	pop	r13
    a2c6:	cf 90       	pop	r12
    a2c8:	08 95       	ret

0000a2ca <sendMessage32>:
	_uart(1, 1,0x02);
}



void sendMessage32(){//Msg32: <01>[ID][Seq][SrcIP][DestIP][MsgCode][FIP][PaymentType][Ref1][Ref2][Ref3][Ref4]<02>
    a2ca:	0f 93       	push	r16
    a2cc:	1f 93       	push	r17
    a2ce:	df 93       	push	r29
    a2d0:	cf 93       	push	r28
    a2d2:	cd b7       	in	r28, 0x3d	; 61
    a2d4:	de b7       	in	r29, 0x3e	; 62
    a2d6:	c0 55       	subi	r28, 0x50	; 80
    a2d8:	d0 40       	sbci	r29, 0x00	; 0
    a2da:	0f b6       	in	r0, 0x3f	; 63
    a2dc:	f8 94       	cli
    a2de:	de bf       	out	0x3e, r29	; 62
    a2e0:	0f be       	out	0x3f, r0	; 63
    a2e2:	cd bf       	out	0x3d, r28	; 61
	char strSend[80];
	UpdateIFT_ID(); //ReadIFT_ID
    a2e4:	0e 94 11 1c 	call	0x3822	; 0x3822 <UpdateIFT_ID>
	UpdateSeqNum(); //UpdateSeqNum SeqNum++
    a2e8:	0e 94 e6 1b 	call	0x37cc	; 0x37cc <UpdateSeqNum>
	UpdateClientIP();//ReadSourceIP
    a2ec:	0e 94 db 1f 	call	0x3fb6	; 0x3fb6 <UpdateClientIP>
	UpdateServerIP();//ReadDestIP
    a2f0:	0e 94 73 1f 	call	0x3ee6	; 0x3ee6 <UpdateServerIP>
	_uart(1, 1,0x01);
    a2f4:	81 e0       	ldi	r24, 0x01	; 1
    a2f6:	61 e0       	ldi	r22, 0x01	; 1
    a2f8:	41 e0       	ldi	r20, 0x01	; 1
    a2fa:	0e 94 d5 b3 	call	0x167aa	; 0x167aa <_uart>
	sprintf_P(strSend,PSTR("%s%s%s%s32"),strIFT_ID,strSeqNum,strClientIP,strServerIP);
    a2fe:	8d b7       	in	r24, 0x3d	; 61
    a300:	9e b7       	in	r25, 0x3e	; 62
    a302:	0c 97       	sbiw	r24, 0x0c	; 12
    a304:	0f b6       	in	r0, 0x3f	; 63
    a306:	f8 94       	cli
    a308:	9e bf       	out	0x3e, r25	; 62
    a30a:	0f be       	out	0x3f, r0	; 63
    a30c:	8d bf       	out	0x3d, r24	; 61
    a30e:	ed b7       	in	r30, 0x3d	; 61
    a310:	fe b7       	in	r31, 0x3e	; 62
    a312:	31 96       	adiw	r30, 0x01	; 1
    a314:	8e 01       	movw	r16, r28
    a316:	0f 5f       	subi	r16, 0xFF	; 255
    a318:	1f 4f       	sbci	r17, 0xFF	; 255
    a31a:	ad b7       	in	r26, 0x3d	; 61
    a31c:	be b7       	in	r27, 0x3e	; 62
    a31e:	12 96       	adiw	r26, 0x02	; 2
    a320:	1c 93       	st	X, r17
    a322:	0e 93       	st	-X, r16
    a324:	11 97       	sbiw	r26, 0x01	; 1
    a326:	87 e8       	ldi	r24, 0x87	; 135
    a328:	91 e2       	ldi	r25, 0x21	; 33
    a32a:	93 83       	std	Z+3, r25	; 0x03
    a32c:	82 83       	std	Z+2, r24	; 0x02
    a32e:	8c ec       	ldi	r24, 0xCC	; 204
    a330:	95 e0       	ldi	r25, 0x05	; 5
    a332:	95 83       	std	Z+5, r25	; 0x05
    a334:	84 83       	std	Z+4, r24	; 0x04
    a336:	8b ea       	ldi	r24, 0xAB	; 171
    a338:	9d e0       	ldi	r25, 0x0D	; 13
    a33a:	97 83       	std	Z+7, r25	; 0x07
    a33c:	86 83       	std	Z+6, r24	; 0x06
    a33e:	8e eb       	ldi	r24, 0xBE	; 190
    a340:	99 e0       	ldi	r25, 0x09	; 9
    a342:	91 87       	std	Z+9, r25	; 0x09
    a344:	80 87       	std	Z+8, r24	; 0x08
    a346:	8b ee       	ldi	r24, 0xEB	; 235
    a348:	99 e0       	ldi	r25, 0x09	; 9
    a34a:	93 87       	std	Z+11, r25	; 0x0b
    a34c:	82 87       	std	Z+10, r24	; 0x0a
    a34e:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    _uart_print(1, 0,strSend);
    a352:	ed b7       	in	r30, 0x3d	; 61
    a354:	fe b7       	in	r31, 0x3e	; 62
    a356:	3c 96       	adiw	r30, 0x0c	; 12
    a358:	0f b6       	in	r0, 0x3f	; 63
    a35a:	f8 94       	cli
    a35c:	fe bf       	out	0x3e, r31	; 62
    a35e:	0f be       	out	0x3f, r0	; 63
    a360:	ed bf       	out	0x3d, r30	; 61
    a362:	81 e0       	ldi	r24, 0x01	; 1
    a364:	60 e0       	ldi	r22, 0x00	; 0
    a366:	a8 01       	movw	r20, r16
    a368:	0e 94 f2 b3 	call	0x167e4	; 0x167e4 <_uart_print>
	sprintf_P(strSend,PSTR("%s%s%s%s"),strFIP_ID,strPaymentType,strRef1,strRef2);
    a36c:	8d b7       	in	r24, 0x3d	; 61
    a36e:	9e b7       	in	r25, 0x3e	; 62
    a370:	0c 97       	sbiw	r24, 0x0c	; 12
    a372:	0f b6       	in	r0, 0x3f	; 63
    a374:	f8 94       	cli
    a376:	9e bf       	out	0x3e, r25	; 62
    a378:	0f be       	out	0x3f, r0	; 63
    a37a:	8d bf       	out	0x3d, r24	; 61
    a37c:	ed b7       	in	r30, 0x3d	; 61
    a37e:	fe b7       	in	r31, 0x3e	; 62
    a380:	31 96       	adiw	r30, 0x01	; 1
    a382:	ad b7       	in	r26, 0x3d	; 61
    a384:	be b7       	in	r27, 0x3e	; 62
    a386:	12 96       	adiw	r26, 0x02	; 2
    a388:	1c 93       	st	X, r17
    a38a:	0e 93       	st	-X, r16
    a38c:	11 97       	sbiw	r26, 0x01	; 1
    a38e:	8e e7       	ldi	r24, 0x7E	; 126
    a390:	91 e2       	ldi	r25, 0x21	; 33
    a392:	93 83       	std	Z+3, r25	; 0x03
    a394:	82 83       	std	Z+2, r24	; 0x02
    a396:	8c e9       	ldi	r24, 0x9C	; 156
    a398:	99 e0       	ldi	r25, 0x09	; 9
    a39a:	95 83       	std	Z+5, r25	; 0x05
    a39c:	84 83       	std	Z+4, r24	; 0x04
    a39e:	83 e3       	ldi	r24, 0x33	; 51
    a3a0:	99 e0       	ldi	r25, 0x09	; 9
    a3a2:	97 83       	std	Z+7, r25	; 0x07
    a3a4:	86 83       	std	Z+6, r24	; 0x06
    a3a6:	88 e6       	ldi	r24, 0x68	; 104
    a3a8:	9e e0       	ldi	r25, 0x0E	; 14
    a3aa:	91 87       	std	Z+9, r25	; 0x09
    a3ac:	80 87       	std	Z+8, r24	; 0x08
    a3ae:	86 e7       	ldi	r24, 0x76	; 118
    a3b0:	9d e0       	ldi	r25, 0x0D	; 13
    a3b2:	93 87       	std	Z+11, r25	; 0x0b
    a3b4:	82 87       	std	Z+10, r24	; 0x0a
    a3b6:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    _uart_print(1, 0,strSend);
    a3ba:	ed b7       	in	r30, 0x3d	; 61
    a3bc:	fe b7       	in	r31, 0x3e	; 62
    a3be:	3c 96       	adiw	r30, 0x0c	; 12
    a3c0:	0f b6       	in	r0, 0x3f	; 63
    a3c2:	f8 94       	cli
    a3c4:	fe bf       	out	0x3e, r31	; 62
    a3c6:	0f be       	out	0x3f, r0	; 63
    a3c8:	ed bf       	out	0x3d, r30	; 61
    a3ca:	81 e0       	ldi	r24, 0x01	; 1
    a3cc:	60 e0       	ldi	r22, 0x00	; 0
    a3ce:	a8 01       	movw	r20, r16
    a3d0:	0e 94 f2 b3 	call	0x167e4	; 0x167e4 <_uart_print>
	sprintf_P(strSend,PSTR("%s%s"),strRef3,strRef4);
    a3d4:	8d b7       	in	r24, 0x3d	; 61
    a3d6:	9e b7       	in	r25, 0x3e	; 62
    a3d8:	08 97       	sbiw	r24, 0x08	; 8
    a3da:	0f b6       	in	r0, 0x3f	; 63
    a3dc:	f8 94       	cli
    a3de:	9e bf       	out	0x3e, r25	; 62
    a3e0:	0f be       	out	0x3f, r0	; 63
    a3e2:	8d bf       	out	0x3d, r24	; 61
    a3e4:	ed b7       	in	r30, 0x3d	; 61
    a3e6:	fe b7       	in	r31, 0x3e	; 62
    a3e8:	31 96       	adiw	r30, 0x01	; 1
    a3ea:	ad b7       	in	r26, 0x3d	; 61
    a3ec:	be b7       	in	r27, 0x3e	; 62
    a3ee:	12 96       	adiw	r26, 0x02	; 2
    a3f0:	1c 93       	st	X, r17
    a3f2:	0e 93       	st	-X, r16
    a3f4:	11 97       	sbiw	r26, 0x01	; 1
    a3f6:	89 e7       	ldi	r24, 0x79	; 121
    a3f8:	91 e2       	ldi	r25, 0x21	; 33
    a3fa:	93 83       	std	Z+3, r25	; 0x03
    a3fc:	82 83       	std	Z+2, r24	; 0x02
    a3fe:	82 e8       	ldi	r24, 0x82	; 130
    a400:	9a e0       	ldi	r25, 0x0A	; 10
    a402:	95 83       	std	Z+5, r25	; 0x05
    a404:	84 83       	std	Z+4, r24	; 0x04
    a406:	85 e8       	ldi	r24, 0x85	; 133
    a408:	95 e0       	ldi	r25, 0x05	; 5
    a40a:	97 83       	std	Z+7, r25	; 0x07
    a40c:	86 83       	std	Z+6, r24	; 0x06
    a40e:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    _uart_print(1, 0,strSend);
    a412:	ed b7       	in	r30, 0x3d	; 61
    a414:	fe b7       	in	r31, 0x3e	; 62
    a416:	38 96       	adiw	r30, 0x08	; 8
    a418:	0f b6       	in	r0, 0x3f	; 63
    a41a:	f8 94       	cli
    a41c:	fe bf       	out	0x3e, r31	; 62
    a41e:	0f be       	out	0x3f, r0	; 63
    a420:	ed bf       	out	0x3d, r30	; 61
    a422:	81 e0       	ldi	r24, 0x01	; 1
    a424:	60 e0       	ldi	r22, 0x00	; 0
    a426:	a8 01       	movw	r20, r16
    a428:	0e 94 f2 b3 	call	0x167e4	; 0x167e4 <_uart_print>
	sprintf_P(strSend,PSTR("F968CFFB"));
    a42c:	00 d0       	rcall	.+0      	; 0xa42e <sendMessage32+0x164>
    a42e:	00 d0       	rcall	.+0      	; 0xa430 <sendMessage32+0x166>
    a430:	ad b7       	in	r26, 0x3d	; 61
    a432:	be b7       	in	r27, 0x3e	; 62
    a434:	12 96       	adiw	r26, 0x02	; 2
    a436:	1c 93       	st	X, r17
    a438:	0e 93       	st	-X, r16
    a43a:	11 97       	sbiw	r26, 0x01	; 1
    a43c:	80 e7       	ldi	r24, 0x70	; 112
    a43e:	91 e2       	ldi	r25, 0x21	; 33
    a440:	14 96       	adiw	r26, 0x04	; 4
    a442:	9c 93       	st	X, r25
    a444:	8e 93       	st	-X, r24
    a446:	13 97       	sbiw	r26, 0x03	; 3
    a448:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    _uart_print(1, 0,strSend);
    a44c:	0f 90       	pop	r0
    a44e:	0f 90       	pop	r0
    a450:	0f 90       	pop	r0
    a452:	0f 90       	pop	r0
    a454:	81 e0       	ldi	r24, 0x01	; 1
    a456:	60 e0       	ldi	r22, 0x00	; 0
    a458:	a8 01       	movw	r20, r16
    a45a:	0e 94 f2 b3 	call	0x167e4	; 0x167e4 <_uart_print>
	_uart(1, 1,0x02);
    a45e:	81 e0       	ldi	r24, 0x01	; 1
    a460:	61 e0       	ldi	r22, 0x01	; 1
    a462:	42 e0       	ldi	r20, 0x02	; 2
    a464:	0e 94 d5 b3 	call	0x167aa	; 0x167aa <_uart>

}
    a468:	c0 5b       	subi	r28, 0xB0	; 176
    a46a:	df 4f       	sbci	r29, 0xFF	; 255
    a46c:	0f b6       	in	r0, 0x3f	; 63
    a46e:	f8 94       	cli
    a470:	de bf       	out	0x3e, r29	; 62
    a472:	0f be       	out	0x3f, r0	; 63
    a474:	cd bf       	out	0x3d, r28	; 61
    a476:	cf 91       	pop	r28
    a478:	df 91       	pop	r29
    a47a:	1f 91       	pop	r17
    a47c:	0f 91       	pop	r16
    a47e:	08 95       	ret

0000a480 <sendMessage28>:
	sprintf_P(strSend,PSTR("%s%sF968CFFB"),strCardID,strFIP_ID);
    _uart_print(1, 0,strSend);
	_uart(1, 1,0x02);
}

void sendMessage28(){//Msg28: <01>[0103192.168.016.070192.168.016.18024[FIP][CardID]F968CFFB]<02>
    a480:	0f 93       	push	r16
    a482:	1f 93       	push	r17
    a484:	df 93       	push	r29
    a486:	cf 93       	push	r28
    a488:	cd b7       	in	r28, 0x3d	; 61
    a48a:	de b7       	in	r29, 0x3e	; 62
    a48c:	ec 97       	sbiw	r28, 0x3c	; 60
    a48e:	0f b6       	in	r0, 0x3f	; 63
    a490:	f8 94       	cli
    a492:	de bf       	out	0x3e, r29	; 62
    a494:	0f be       	out	0x3f, r0	; 63
    a496:	cd bf       	out	0x3d, r28	; 61
	char strSend[60];
	_uart(1, 1,0x01);
    a498:	81 e0       	ldi	r24, 0x01	; 1
    a49a:	61 e0       	ldi	r22, 0x01	; 1
    a49c:	41 e0       	ldi	r20, 0x01	; 1
    a49e:	0e 94 d5 b3 	call	0x167aa	; 0x167aa <_uart>
	UpdateIFT_ID(); //ReadIFT_ID
    a4a2:	0e 94 11 1c 	call	0x3822	; 0x3822 <UpdateIFT_ID>
	UpdateSeqNum(); //UpdateSeqNum SeqNum++
    a4a6:	0e 94 e6 1b 	call	0x37cc	; 0x37cc <UpdateSeqNum>
	UpdateClientIP();//ReadSourceIP
    a4aa:	0e 94 db 1f 	call	0x3fb6	; 0x3fb6 <UpdateClientIP>
	UpdateServerIP();//ReadDestIP
    a4ae:	0e 94 73 1f 	call	0x3ee6	; 0x3ee6 <UpdateServerIP>
	sprintf_P(strSend,PSTR("%s%s%s%s28"),strIFT_ID,strSeqNum,strClientIP,strServerIP);
    a4b2:	8d b7       	in	r24, 0x3d	; 61
    a4b4:	9e b7       	in	r25, 0x3e	; 62
    a4b6:	0c 97       	sbiw	r24, 0x0c	; 12
    a4b8:	0f b6       	in	r0, 0x3f	; 63
    a4ba:	f8 94       	cli
    a4bc:	9e bf       	out	0x3e, r25	; 62
    a4be:	0f be       	out	0x3f, r0	; 63
    a4c0:	8d bf       	out	0x3d, r24	; 61
    a4c2:	ed b7       	in	r30, 0x3d	; 61
    a4c4:	fe b7       	in	r31, 0x3e	; 62
    a4c6:	31 96       	adiw	r30, 0x01	; 1
    a4c8:	8e 01       	movw	r16, r28
    a4ca:	0f 5f       	subi	r16, 0xFF	; 255
    a4cc:	1f 4f       	sbci	r17, 0xFF	; 255
    a4ce:	ad b7       	in	r26, 0x3d	; 61
    a4d0:	be b7       	in	r27, 0x3e	; 62
    a4d2:	12 96       	adiw	r26, 0x02	; 2
    a4d4:	1c 93       	st	X, r17
    a4d6:	0e 93       	st	-X, r16
    a4d8:	11 97       	sbiw	r26, 0x01	; 1
    a4da:	8f e9       	ldi	r24, 0x9F	; 159
    a4dc:	91 e2       	ldi	r25, 0x21	; 33
    a4de:	93 83       	std	Z+3, r25	; 0x03
    a4e0:	82 83       	std	Z+2, r24	; 0x02
    a4e2:	8c ec       	ldi	r24, 0xCC	; 204
    a4e4:	95 e0       	ldi	r25, 0x05	; 5
    a4e6:	95 83       	std	Z+5, r25	; 0x05
    a4e8:	84 83       	std	Z+4, r24	; 0x04
    a4ea:	8b ea       	ldi	r24, 0xAB	; 171
    a4ec:	9d e0       	ldi	r25, 0x0D	; 13
    a4ee:	97 83       	std	Z+7, r25	; 0x07
    a4f0:	86 83       	std	Z+6, r24	; 0x06
    a4f2:	8e eb       	ldi	r24, 0xBE	; 190
    a4f4:	99 e0       	ldi	r25, 0x09	; 9
    a4f6:	91 87       	std	Z+9, r25	; 0x09
    a4f8:	80 87       	std	Z+8, r24	; 0x08
    a4fa:	8b ee       	ldi	r24, 0xEB	; 235
    a4fc:	99 e0       	ldi	r25, 0x09	; 9
    a4fe:	93 87       	std	Z+11, r25	; 0x0b
    a500:	82 87       	std	Z+10, r24	; 0x0a
    a502:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    _uart_print(1, 0,strSend);
    a506:	8d b7       	in	r24, 0x3d	; 61
    a508:	9e b7       	in	r25, 0x3e	; 62
    a50a:	0c 96       	adiw	r24, 0x0c	; 12
    a50c:	0f b6       	in	r0, 0x3f	; 63
    a50e:	f8 94       	cli
    a510:	9e bf       	out	0x3e, r25	; 62
    a512:	0f be       	out	0x3f, r0	; 63
    a514:	8d bf       	out	0x3d, r24	; 61
    a516:	81 e0       	ldi	r24, 0x01	; 1
    a518:	60 e0       	ldi	r22, 0x00	; 0
    a51a:	a8 01       	movw	r20, r16
    a51c:	0e 94 f2 b3 	call	0x167e4	; 0x167e4 <_uart_print>
	UpdateCardID();
    a520:	0e 94 55 40 	call	0x80aa	; 0x80aa <UpdateCardID>
	sprintf_P(strSend,PSTR("%s%sF968CFFB"),strFIP_ID,strCardID);
    a524:	ad b7       	in	r26, 0x3d	; 61
    a526:	be b7       	in	r27, 0x3e	; 62
    a528:	18 97       	sbiw	r26, 0x08	; 8
    a52a:	0f b6       	in	r0, 0x3f	; 63
    a52c:	f8 94       	cli
    a52e:	be bf       	out	0x3e, r27	; 62
    a530:	0f be       	out	0x3f, r0	; 63
    a532:	ad bf       	out	0x3d, r26	; 61
    a534:	ed b7       	in	r30, 0x3d	; 61
    a536:	fe b7       	in	r31, 0x3e	; 62
    a538:	31 96       	adiw	r30, 0x01	; 1
    a53a:	12 96       	adiw	r26, 0x02	; 2
    a53c:	1c 93       	st	X, r17
    a53e:	0e 93       	st	-X, r16
    a540:	11 97       	sbiw	r26, 0x01	; 1
    a542:	82 e9       	ldi	r24, 0x92	; 146
    a544:	91 e2       	ldi	r25, 0x21	; 33
    a546:	93 83       	std	Z+3, r25	; 0x03
    a548:	82 83       	std	Z+2, r24	; 0x02
    a54a:	8c e9       	ldi	r24, 0x9C	; 156
    a54c:	99 e0       	ldi	r25, 0x09	; 9
    a54e:	95 83       	std	Z+5, r25	; 0x05
    a550:	84 83       	std	Z+4, r24	; 0x04
    a552:	81 e6       	ldi	r24, 0x61	; 97
    a554:	9d e0       	ldi	r25, 0x0D	; 13
    a556:	97 83       	std	Z+7, r25	; 0x07
    a558:	86 83       	std	Z+6, r24	; 0x06
    a55a:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    _uart_print(1, 0,strSend);
    a55e:	8d b7       	in	r24, 0x3d	; 61
    a560:	9e b7       	in	r25, 0x3e	; 62
    a562:	08 96       	adiw	r24, 0x08	; 8
    a564:	0f b6       	in	r0, 0x3f	; 63
    a566:	f8 94       	cli
    a568:	9e bf       	out	0x3e, r25	; 62
    a56a:	0f be       	out	0x3f, r0	; 63
    a56c:	8d bf       	out	0x3d, r24	; 61
    a56e:	81 e0       	ldi	r24, 0x01	; 1
    a570:	60 e0       	ldi	r22, 0x00	; 0
    a572:	a8 01       	movw	r20, r16
    a574:	0e 94 f2 b3 	call	0x167e4	; 0x167e4 <_uart_print>
	_uart(1, 1,0x02);
    a578:	81 e0       	ldi	r24, 0x01	; 1
    a57a:	61 e0       	ldi	r22, 0x01	; 1
    a57c:	42 e0       	ldi	r20, 0x02	; 2
    a57e:	0e 94 d5 b3 	call	0x167aa	; 0x167aa <_uart>
}
    a582:	ec 96       	adiw	r28, 0x3c	; 60
    a584:	0f b6       	in	r0, 0x3f	; 63
    a586:	f8 94       	cli
    a588:	de bf       	out	0x3e, r29	; 62
    a58a:	0f be       	out	0x3f, r0	; 63
    a58c:	cd bf       	out	0x3d, r28	; 61
    a58e:	cf 91       	pop	r28
    a590:	df 91       	pop	r29
    a592:	1f 91       	pop	r17
    a594:	0f 91       	pop	r16
    a596:	08 95       	ret

0000a598 <sendMessage24>:
	sprintf_P(strSend,PSTR("%sF968CFFB"),strCardID);
    _uart_print(1, 0,strSend);
	_uart(1, 1,0x02);
}

void sendMessage24(){//Msg24: <01>[0103192.168.016.070192.168.016.18022[CardID]F968CFFB]<02>
    a598:	0f 93       	push	r16
    a59a:	1f 93       	push	r17
    a59c:	df 93       	push	r29
    a59e:	cf 93       	push	r28
    a5a0:	cd b7       	in	r28, 0x3d	; 61
    a5a2:	de b7       	in	r29, 0x3e	; 62
    a5a4:	ec 97       	sbiw	r28, 0x3c	; 60
    a5a6:	0f b6       	in	r0, 0x3f	; 63
    a5a8:	f8 94       	cli
    a5aa:	de bf       	out	0x3e, r29	; 62
    a5ac:	0f be       	out	0x3f, r0	; 63
    a5ae:	cd bf       	out	0x3d, r28	; 61
	char strSend[60];
	_uart(1, 1,0x01);
    a5b0:	81 e0       	ldi	r24, 0x01	; 1
    a5b2:	61 e0       	ldi	r22, 0x01	; 1
    a5b4:	41 e0       	ldi	r20, 0x01	; 1
    a5b6:	0e 94 d5 b3 	call	0x167aa	; 0x167aa <_uart>
	UpdateIFT_ID(); //ReadIFT_ID
    a5ba:	0e 94 11 1c 	call	0x3822	; 0x3822 <UpdateIFT_ID>
	UpdateSeqNum(); //UpdateSeqNum SeqNum++
    a5be:	0e 94 e6 1b 	call	0x37cc	; 0x37cc <UpdateSeqNum>
	UpdateClientIP();//ReadSourceIP
    a5c2:	0e 94 db 1f 	call	0x3fb6	; 0x3fb6 <UpdateClientIP>
	UpdateServerIP();//ReadDestIP
    a5c6:	0e 94 73 1f 	call	0x3ee6	; 0x3ee6 <UpdateServerIP>
	sprintf_P(strSend,PSTR("%s%s%s%s24"),strIFT_ID,strSeqNum,strClientIP,strServerIP);
    a5ca:	8d b7       	in	r24, 0x3d	; 61
    a5cc:	9e b7       	in	r25, 0x3e	; 62
    a5ce:	0c 97       	sbiw	r24, 0x0c	; 12
    a5d0:	0f b6       	in	r0, 0x3f	; 63
    a5d2:	f8 94       	cli
    a5d4:	9e bf       	out	0x3e, r25	; 62
    a5d6:	0f be       	out	0x3f, r0	; 63
    a5d8:	8d bf       	out	0x3d, r24	; 61
    a5da:	ed b7       	in	r30, 0x3d	; 61
    a5dc:	fe b7       	in	r31, 0x3e	; 62
    a5de:	31 96       	adiw	r30, 0x01	; 1
    a5e0:	8e 01       	movw	r16, r28
    a5e2:	0f 5f       	subi	r16, 0xFF	; 255
    a5e4:	1f 4f       	sbci	r17, 0xFF	; 255
    a5e6:	ad b7       	in	r26, 0x3d	; 61
    a5e8:	be b7       	in	r27, 0x3e	; 62
    a5ea:	12 96       	adiw	r26, 0x02	; 2
    a5ec:	1c 93       	st	X, r17
    a5ee:	0e 93       	st	-X, r16
    a5f0:	11 97       	sbiw	r26, 0x01	; 1
    a5f2:	87 eb       	ldi	r24, 0xB7	; 183
    a5f4:	91 e2       	ldi	r25, 0x21	; 33
    a5f6:	93 83       	std	Z+3, r25	; 0x03
    a5f8:	82 83       	std	Z+2, r24	; 0x02
    a5fa:	8c ec       	ldi	r24, 0xCC	; 204
    a5fc:	95 e0       	ldi	r25, 0x05	; 5
    a5fe:	95 83       	std	Z+5, r25	; 0x05
    a600:	84 83       	std	Z+4, r24	; 0x04
    a602:	8b ea       	ldi	r24, 0xAB	; 171
    a604:	9d e0       	ldi	r25, 0x0D	; 13
    a606:	97 83       	std	Z+7, r25	; 0x07
    a608:	86 83       	std	Z+6, r24	; 0x06
    a60a:	8e eb       	ldi	r24, 0xBE	; 190
    a60c:	99 e0       	ldi	r25, 0x09	; 9
    a60e:	91 87       	std	Z+9, r25	; 0x09
    a610:	80 87       	std	Z+8, r24	; 0x08
    a612:	8b ee       	ldi	r24, 0xEB	; 235
    a614:	99 e0       	ldi	r25, 0x09	; 9
    a616:	93 87       	std	Z+11, r25	; 0x0b
    a618:	82 87       	std	Z+10, r24	; 0x0a
    a61a:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    _uart_print(1, 0,strSend);
    a61e:	8d b7       	in	r24, 0x3d	; 61
    a620:	9e b7       	in	r25, 0x3e	; 62
    a622:	0c 96       	adiw	r24, 0x0c	; 12
    a624:	0f b6       	in	r0, 0x3f	; 63
    a626:	f8 94       	cli
    a628:	9e bf       	out	0x3e, r25	; 62
    a62a:	0f be       	out	0x3f, r0	; 63
    a62c:	8d bf       	out	0x3d, r24	; 61
    a62e:	81 e0       	ldi	r24, 0x01	; 1
    a630:	60 e0       	ldi	r22, 0x00	; 0
    a632:	a8 01       	movw	r20, r16
    a634:	0e 94 f2 b3 	call	0x167e4	; 0x167e4 <_uart_print>
	UpdateCardID();
    a638:	0e 94 55 40 	call	0x80aa	; 0x80aa <UpdateCardID>
	sprintf_P(strSend,PSTR("%s%sF968CFFB"),strCardID,strFIP_ID);
    a63c:	ad b7       	in	r26, 0x3d	; 61
    a63e:	be b7       	in	r27, 0x3e	; 62
    a640:	18 97       	sbiw	r26, 0x08	; 8
    a642:	0f b6       	in	r0, 0x3f	; 63
    a644:	f8 94       	cli
    a646:	be bf       	out	0x3e, r27	; 62
    a648:	0f be       	out	0x3f, r0	; 63
    a64a:	ad bf       	out	0x3d, r26	; 61
    a64c:	ed b7       	in	r30, 0x3d	; 61
    a64e:	fe b7       	in	r31, 0x3e	; 62
    a650:	31 96       	adiw	r30, 0x01	; 1
    a652:	12 96       	adiw	r26, 0x02	; 2
    a654:	1c 93       	st	X, r17
    a656:	0e 93       	st	-X, r16
    a658:	11 97       	sbiw	r26, 0x01	; 1
    a65a:	8a ea       	ldi	r24, 0xAA	; 170
    a65c:	91 e2       	ldi	r25, 0x21	; 33
    a65e:	93 83       	std	Z+3, r25	; 0x03
    a660:	82 83       	std	Z+2, r24	; 0x02
    a662:	81 e6       	ldi	r24, 0x61	; 97
    a664:	9d e0       	ldi	r25, 0x0D	; 13
    a666:	95 83       	std	Z+5, r25	; 0x05
    a668:	84 83       	std	Z+4, r24	; 0x04
    a66a:	8c e9       	ldi	r24, 0x9C	; 156
    a66c:	99 e0       	ldi	r25, 0x09	; 9
    a66e:	97 83       	std	Z+7, r25	; 0x07
    a670:	86 83       	std	Z+6, r24	; 0x06
    a672:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    _uart_print(1, 0,strSend);
    a676:	8d b7       	in	r24, 0x3d	; 61
    a678:	9e b7       	in	r25, 0x3e	; 62
    a67a:	08 96       	adiw	r24, 0x08	; 8
    a67c:	0f b6       	in	r0, 0x3f	; 63
    a67e:	f8 94       	cli
    a680:	9e bf       	out	0x3e, r25	; 62
    a682:	0f be       	out	0x3f, r0	; 63
    a684:	8d bf       	out	0x3d, r24	; 61
    a686:	81 e0       	ldi	r24, 0x01	; 1
    a688:	60 e0       	ldi	r22, 0x00	; 0
    a68a:	a8 01       	movw	r20, r16
    a68c:	0e 94 f2 b3 	call	0x167e4	; 0x167e4 <_uart_print>
	_uart(1, 1,0x02);
    a690:	81 e0       	ldi	r24, 0x01	; 1
    a692:	61 e0       	ldi	r22, 0x01	; 1
    a694:	42 e0       	ldi	r20, 0x02	; 2
    a696:	0e 94 d5 b3 	call	0x167aa	; 0x167aa <_uart>
}
    a69a:	ec 96       	adiw	r28, 0x3c	; 60
    a69c:	0f b6       	in	r0, 0x3f	; 63
    a69e:	f8 94       	cli
    a6a0:	de bf       	out	0x3e, r29	; 62
    a6a2:	0f be       	out	0x3f, r0	; 63
    a6a4:	cd bf       	out	0x3d, r28	; 61
    a6a6:	cf 91       	pop	r28
    a6a8:	df 91       	pop	r29
    a6aa:	1f 91       	pop	r17
    a6ac:	0f 91       	pop	r16
    a6ae:	08 95       	ret

0000a6b0 <sendMessage22>:
    _uart_print(1, 0,strSend);
	_uart(1, 1,0x02);
	IsNewPacket=True;
}

void sendMessage22(){//Msg22: <01>[0103192.168.016.070192.168.016.18022[CardID]F968CFFB]<02>
    a6b0:	0f 93       	push	r16
    a6b2:	1f 93       	push	r17
    a6b4:	df 93       	push	r29
    a6b6:	cf 93       	push	r28
    a6b8:	cd b7       	in	r28, 0x3d	; 61
    a6ba:	de b7       	in	r29, 0x3e	; 62
    a6bc:	ec 97       	sbiw	r28, 0x3c	; 60
    a6be:	0f b6       	in	r0, 0x3f	; 63
    a6c0:	f8 94       	cli
    a6c2:	de bf       	out	0x3e, r29	; 62
    a6c4:	0f be       	out	0x3f, r0	; 63
    a6c6:	cd bf       	out	0x3d, r28	; 61
	char strSend[60];
	_uart(1, 1,0x01);
    a6c8:	81 e0       	ldi	r24, 0x01	; 1
    a6ca:	61 e0       	ldi	r22, 0x01	; 1
    a6cc:	41 e0       	ldi	r20, 0x01	; 1
    a6ce:	0e 94 d5 b3 	call	0x167aa	; 0x167aa <_uart>
	UpdateIFT_ID(); //ReadIFT_ID
    a6d2:	0e 94 11 1c 	call	0x3822	; 0x3822 <UpdateIFT_ID>
	UpdateSeqNum(); //UpdateSeqNum SeqNum++
    a6d6:	0e 94 e6 1b 	call	0x37cc	; 0x37cc <UpdateSeqNum>
	UpdateClientIP();//ReadSourceIP
    a6da:	0e 94 db 1f 	call	0x3fb6	; 0x3fb6 <UpdateClientIP>
	UpdateServerIP();//ReadDestIP
    a6de:	0e 94 73 1f 	call	0x3ee6	; 0x3ee6 <UpdateServerIP>
	sprintf_P(strSend,PSTR("%s%s%s%s22"),strIFT_ID,strSeqNum,strClientIP,strServerIP);
    a6e2:	8d b7       	in	r24, 0x3d	; 61
    a6e4:	9e b7       	in	r25, 0x3e	; 62
    a6e6:	0c 97       	sbiw	r24, 0x0c	; 12
    a6e8:	0f b6       	in	r0, 0x3f	; 63
    a6ea:	f8 94       	cli
    a6ec:	9e bf       	out	0x3e, r25	; 62
    a6ee:	0f be       	out	0x3f, r0	; 63
    a6f0:	8d bf       	out	0x3d, r24	; 61
    a6f2:	ed b7       	in	r30, 0x3d	; 61
    a6f4:	fe b7       	in	r31, 0x3e	; 62
    a6f6:	31 96       	adiw	r30, 0x01	; 1
    a6f8:	8e 01       	movw	r16, r28
    a6fa:	0f 5f       	subi	r16, 0xFF	; 255
    a6fc:	1f 4f       	sbci	r17, 0xFF	; 255
    a6fe:	ad b7       	in	r26, 0x3d	; 61
    a700:	be b7       	in	r27, 0x3e	; 62
    a702:	12 96       	adiw	r26, 0x02	; 2
    a704:	1c 93       	st	X, r17
    a706:	0e 93       	st	-X, r16
    a708:	11 97       	sbiw	r26, 0x01	; 1
    a70a:	8d ec       	ldi	r24, 0xCD	; 205
    a70c:	91 e2       	ldi	r25, 0x21	; 33
    a70e:	93 83       	std	Z+3, r25	; 0x03
    a710:	82 83       	std	Z+2, r24	; 0x02
    a712:	8c ec       	ldi	r24, 0xCC	; 204
    a714:	95 e0       	ldi	r25, 0x05	; 5
    a716:	95 83       	std	Z+5, r25	; 0x05
    a718:	84 83       	std	Z+4, r24	; 0x04
    a71a:	8b ea       	ldi	r24, 0xAB	; 171
    a71c:	9d e0       	ldi	r25, 0x0D	; 13
    a71e:	97 83       	std	Z+7, r25	; 0x07
    a720:	86 83       	std	Z+6, r24	; 0x06
    a722:	8e eb       	ldi	r24, 0xBE	; 190
    a724:	99 e0       	ldi	r25, 0x09	; 9
    a726:	91 87       	std	Z+9, r25	; 0x09
    a728:	80 87       	std	Z+8, r24	; 0x08
    a72a:	8b ee       	ldi	r24, 0xEB	; 235
    a72c:	99 e0       	ldi	r25, 0x09	; 9
    a72e:	93 87       	std	Z+11, r25	; 0x0b
    a730:	82 87       	std	Z+10, r24	; 0x0a
    a732:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    _uart_print(1, 0,strSend);
    a736:	8d b7       	in	r24, 0x3d	; 61
    a738:	9e b7       	in	r25, 0x3e	; 62
    a73a:	0c 96       	adiw	r24, 0x0c	; 12
    a73c:	0f b6       	in	r0, 0x3f	; 63
    a73e:	f8 94       	cli
    a740:	9e bf       	out	0x3e, r25	; 62
    a742:	0f be       	out	0x3f, r0	; 63
    a744:	8d bf       	out	0x3d, r24	; 61
    a746:	81 e0       	ldi	r24, 0x01	; 1
    a748:	60 e0       	ldi	r22, 0x00	; 0
    a74a:	a8 01       	movw	r20, r16
    a74c:	0e 94 f2 b3 	call	0x167e4	; 0x167e4 <_uart_print>
	UpdateCardID();
    a750:	0e 94 55 40 	call	0x80aa	; 0x80aa <UpdateCardID>
	sprintf_P(strSend,PSTR("%sF968CFFB"),strCardID);
    a754:	00 d0       	rcall	.+0      	; 0xa756 <sendMessage22+0xa6>
    a756:	00 d0       	rcall	.+0      	; 0xa758 <sendMessage22+0xa8>
    a758:	00 d0       	rcall	.+0      	; 0xa75a <sendMessage22+0xaa>
    a75a:	ed b7       	in	r30, 0x3d	; 61
    a75c:	fe b7       	in	r31, 0x3e	; 62
    a75e:	31 96       	adiw	r30, 0x01	; 1
    a760:	ad b7       	in	r26, 0x3d	; 61
    a762:	be b7       	in	r27, 0x3e	; 62
    a764:	12 96       	adiw	r26, 0x02	; 2
    a766:	1c 93       	st	X, r17
    a768:	0e 93       	st	-X, r16
    a76a:	11 97       	sbiw	r26, 0x01	; 1
    a76c:	82 ec       	ldi	r24, 0xC2	; 194
    a76e:	91 e2       	ldi	r25, 0x21	; 33
    a770:	93 83       	std	Z+3, r25	; 0x03
    a772:	82 83       	std	Z+2, r24	; 0x02
    a774:	81 e6       	ldi	r24, 0x61	; 97
    a776:	9d e0       	ldi	r25, 0x0D	; 13
    a778:	95 83       	std	Z+5, r25	; 0x05
    a77a:	84 83       	std	Z+4, r24	; 0x04
    a77c:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    _uart_print(1, 0,strSend);
    a780:	8d b7       	in	r24, 0x3d	; 61
    a782:	9e b7       	in	r25, 0x3e	; 62
    a784:	06 96       	adiw	r24, 0x06	; 6
    a786:	0f b6       	in	r0, 0x3f	; 63
    a788:	f8 94       	cli
    a78a:	9e bf       	out	0x3e, r25	; 62
    a78c:	0f be       	out	0x3f, r0	; 63
    a78e:	8d bf       	out	0x3d, r24	; 61
    a790:	81 e0       	ldi	r24, 0x01	; 1
    a792:	60 e0       	ldi	r22, 0x00	; 0
    a794:	a8 01       	movw	r20, r16
    a796:	0e 94 f2 b3 	call	0x167e4	; 0x167e4 <_uart_print>
	_uart(1, 1,0x02);
    a79a:	81 e0       	ldi	r24, 0x01	; 1
    a79c:	61 e0       	ldi	r22, 0x01	; 1
    a79e:	42 e0       	ldi	r20, 0x02	; 2
    a7a0:	0e 94 d5 b3 	call	0x167aa	; 0x167aa <_uart>
}
    a7a4:	ec 96       	adiw	r28, 0x3c	; 60
    a7a6:	0f b6       	in	r0, 0x3f	; 63
    a7a8:	f8 94       	cli
    a7aa:	de bf       	out	0x3e, r29	; 62
    a7ac:	0f be       	out	0x3f, r0	; 63
    a7ae:	cd bf       	out	0x3d, r28	; 61
    a7b0:	cf 91       	pop	r28
    a7b2:	df 91       	pop	r29
    a7b4:	1f 91       	pop	r17
    a7b6:	0f 91       	pop	r16
    a7b8:	08 95       	ret

0000a7ba <sendMessage10>:
     _uart_print(1, 0,strSend);
	 _uart(1, 1,0x02);
}

/*Subrutine Msg10*/
void sendMessage10(){//Msg10: <01>[0103192.168.016.070192.168.016.18010F968CFFB]<02>
    a7ba:	0f 93       	push	r16
    a7bc:	1f 93       	push	r17
    a7be:	df 93       	push	r29
    a7c0:	cf 93       	push	r28
    a7c2:	cd b7       	in	r28, 0x3d	; 61
    a7c4:	de b7       	in	r29, 0x3e	; 62
    a7c6:	ec 97       	sbiw	r28, 0x3c	; 60
    a7c8:	0f b6       	in	r0, 0x3f	; 63
    a7ca:	f8 94       	cli
    a7cc:	de bf       	out	0x3e, r29	; 62
    a7ce:	0f be       	out	0x3f, r0	; 63
    a7d0:	cd bf       	out	0x3d, r28	; 61
	char strSend[60];
	_uart(1, 1,0x01);
    a7d2:	81 e0       	ldi	r24, 0x01	; 1
    a7d4:	61 e0       	ldi	r22, 0x01	; 1
    a7d6:	41 e0       	ldi	r20, 0x01	; 1
    a7d8:	0e 94 d5 b3 	call	0x167aa	; 0x167aa <_uart>
	UpdateIFT_ID(); //ReadIFT_ID
    a7dc:	0e 94 11 1c 	call	0x3822	; 0x3822 <UpdateIFT_ID>
	UpdateSeqNum(); //UpdateSeqNum SeqNum++
    a7e0:	0e 94 e6 1b 	call	0x37cc	; 0x37cc <UpdateSeqNum>
	UpdateClientIP();//ReadSourceIP
    a7e4:	0e 94 db 1f 	call	0x3fb6	; 0x3fb6 <UpdateClientIP>
	UpdateServerIP();//ReadDestIP
    a7e8:	0e 94 73 1f 	call	0x3ee6	; 0x3ee6 <UpdateServerIP>
	sprintf_P(strSend,PSTR("%s%s%s%s10F968CFFB"),strIFT_ID,strSeqNum,strClientIP,strServerIP);
    a7ec:	8d b7       	in	r24, 0x3d	; 61
    a7ee:	9e b7       	in	r25, 0x3e	; 62
    a7f0:	0c 97       	sbiw	r24, 0x0c	; 12
    a7f2:	0f b6       	in	r0, 0x3f	; 63
    a7f4:	f8 94       	cli
    a7f6:	9e bf       	out	0x3e, r25	; 62
    a7f8:	0f be       	out	0x3f, r0	; 63
    a7fa:	8d bf       	out	0x3d, r24	; 61
    a7fc:	ed b7       	in	r30, 0x3d	; 61
    a7fe:	fe b7       	in	r31, 0x3e	; 62
    a800:	31 96       	adiw	r30, 0x01	; 1
    a802:	8e 01       	movw	r16, r28
    a804:	0f 5f       	subi	r16, 0xFF	; 255
    a806:	1f 4f       	sbci	r17, 0xFF	; 255
    a808:	ad b7       	in	r26, 0x3d	; 61
    a80a:	be b7       	in	r27, 0x3e	; 62
    a80c:	12 96       	adiw	r26, 0x02	; 2
    a80e:	1c 93       	st	X, r17
    a810:	0e 93       	st	-X, r16
    a812:	11 97       	sbiw	r26, 0x01	; 1
    a814:	88 ed       	ldi	r24, 0xD8	; 216
    a816:	91 e2       	ldi	r25, 0x21	; 33
    a818:	93 83       	std	Z+3, r25	; 0x03
    a81a:	82 83       	std	Z+2, r24	; 0x02
    a81c:	8c ec       	ldi	r24, 0xCC	; 204
    a81e:	95 e0       	ldi	r25, 0x05	; 5
    a820:	95 83       	std	Z+5, r25	; 0x05
    a822:	84 83       	std	Z+4, r24	; 0x04
    a824:	8b ea       	ldi	r24, 0xAB	; 171
    a826:	9d e0       	ldi	r25, 0x0D	; 13
    a828:	97 83       	std	Z+7, r25	; 0x07
    a82a:	86 83       	std	Z+6, r24	; 0x06
    a82c:	8e eb       	ldi	r24, 0xBE	; 190
    a82e:	99 e0       	ldi	r25, 0x09	; 9
    a830:	91 87       	std	Z+9, r25	; 0x09
    a832:	80 87       	std	Z+8, r24	; 0x08
    a834:	8b ee       	ldi	r24, 0xEB	; 235
    a836:	99 e0       	ldi	r25, 0x09	; 9
    a838:	93 87       	std	Z+11, r25	; 0x0b
    a83a:	82 87       	std	Z+10, r24	; 0x0a
    a83c:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    _uart_print(1, 0,strSend);
    a840:	8d b7       	in	r24, 0x3d	; 61
    a842:	9e b7       	in	r25, 0x3e	; 62
    a844:	0c 96       	adiw	r24, 0x0c	; 12
    a846:	0f b6       	in	r0, 0x3f	; 63
    a848:	f8 94       	cli
    a84a:	9e bf       	out	0x3e, r25	; 62
    a84c:	0f be       	out	0x3f, r0	; 63
    a84e:	8d bf       	out	0x3d, r24	; 61
    a850:	81 e0       	ldi	r24, 0x01	; 1
    a852:	60 e0       	ldi	r22, 0x00	; 0
    a854:	a8 01       	movw	r20, r16
    a856:	0e 94 f2 b3 	call	0x167e4	; 0x167e4 <_uart_print>
	_uart(1, 1,0x02);
    a85a:	81 e0       	ldi	r24, 0x01	; 1
    a85c:	61 e0       	ldi	r22, 0x01	; 1
    a85e:	42 e0       	ldi	r20, 0x02	; 2
    a860:	0e 94 d5 b3 	call	0x167aa	; 0x167aa <_uart>
	IsNewPacket=True;
    a864:	81 e0       	ldi	r24, 0x01	; 1
    a866:	80 93 9b 01 	sts	0x019B, r24
}
    a86a:	ec 96       	adiw	r28, 0x3c	; 60
    a86c:	0f b6       	in	r0, 0x3f	; 63
    a86e:	f8 94       	cli
    a870:	de bf       	out	0x3e, r29	; 62
    a872:	0f be       	out	0x3f, r0	; 63
    a874:	cd bf       	out	0x3d, r28	; 61
    a876:	cf 91       	pop	r28
    a878:	df 91       	pop	r29
    a87a:	1f 91       	pop	r17
    a87c:	0f 91       	pop	r16
    a87e:	08 95       	ret

0000a880 <sendMessage04>:
     

//}

/*Subrutine Msg04*/
void sendMessage04(){   //      <STX>[IFTID][Seq][No][SrceIP][DestIP][MsgCode][ReceiptNo][Value][Checksum][ETX]
    a880:	0f 93       	push	r16
    a882:	1f 93       	push	r17
    a884:	df 93       	push	r29
    a886:	cf 93       	push	r28
    a888:	cd b7       	in	r28, 0x3d	; 61
    a88a:	de b7       	in	r29, 0x3e	; 62
    a88c:	ec 97       	sbiw	r28, 0x3c	; 60
    a88e:	0f b6       	in	r0, 0x3f	; 63
    a890:	f8 94       	cli
    a892:	de bf       	out	0x3e, r29	; 62
    a894:	0f be       	out	0x3f, r0	; 63
    a896:	cd bf       	out	0x3d, r28	; 61
                        //Msg04: <01>[01][03][192.168.000.101][192.168.000.001][04][000001]0F968CFFB]<02>
	 char strSend[60];
	 _uart(1, 1,0x01);
    a898:	81 e0       	ldi	r24, 0x01	; 1
    a89a:	61 e0       	ldi	r22, 0x01	; 1
    a89c:	41 e0       	ldi	r20, 0x01	; 1
    a89e:	0e 94 d5 b3 	call	0x167aa	; 0x167aa <_uart>
	 UpdateIFT_ID(); //ReadIFT_ID
    a8a2:	0e 94 11 1c 	call	0x3822	; 0x3822 <UpdateIFT_ID>
	 UpdateSeqNum(); //UpdateSeqNum SeqNum++
    a8a6:	0e 94 e6 1b 	call	0x37cc	; 0x37cc <UpdateSeqNum>
	 UpdateClientIP();//ReadSourceIP
    a8aa:	0e 94 db 1f 	call	0x3fb6	; 0x3fb6 <UpdateClientIP>
	 UpdateServerIP();//ReadDestIP
    a8ae:	0e 94 73 1f 	call	0x3ee6	; 0x3ee6 <UpdateServerIP>
	 //strTranNo = strReceiptNum
	 sprintf_P(strSend,PSTR("%s%s%s%s04%s1F968CFFB"),strIFT_ID,strSeqNum,strClientIP,strServerIP,strTranNo);
    a8b2:	8d b7       	in	r24, 0x3d	; 61
    a8b4:	9e b7       	in	r25, 0x3e	; 62
    a8b6:	0e 97       	sbiw	r24, 0x0e	; 14
    a8b8:	0f b6       	in	r0, 0x3f	; 63
    a8ba:	f8 94       	cli
    a8bc:	9e bf       	out	0x3e, r25	; 62
    a8be:	0f be       	out	0x3f, r0	; 63
    a8c0:	8d bf       	out	0x3d, r24	; 61
    a8c2:	ed b7       	in	r30, 0x3d	; 61
    a8c4:	fe b7       	in	r31, 0x3e	; 62
    a8c6:	31 96       	adiw	r30, 0x01	; 1
    a8c8:	8e 01       	movw	r16, r28
    a8ca:	0f 5f       	subi	r16, 0xFF	; 255
    a8cc:	1f 4f       	sbci	r17, 0xFF	; 255
    a8ce:	ad b7       	in	r26, 0x3d	; 61
    a8d0:	be b7       	in	r27, 0x3e	; 62
    a8d2:	12 96       	adiw	r26, 0x02	; 2
    a8d4:	1c 93       	st	X, r17
    a8d6:	0e 93       	st	-X, r16
    a8d8:	11 97       	sbiw	r26, 0x01	; 1
    a8da:	8b ee       	ldi	r24, 0xEB	; 235
    a8dc:	91 e2       	ldi	r25, 0x21	; 33
    a8de:	93 83       	std	Z+3, r25	; 0x03
    a8e0:	82 83       	std	Z+2, r24	; 0x02
    a8e2:	8c ec       	ldi	r24, 0xCC	; 204
    a8e4:	95 e0       	ldi	r25, 0x05	; 5
    a8e6:	95 83       	std	Z+5, r25	; 0x05
    a8e8:	84 83       	std	Z+4, r24	; 0x04
    a8ea:	8b ea       	ldi	r24, 0xAB	; 171
    a8ec:	9d e0       	ldi	r25, 0x0D	; 13
    a8ee:	97 83       	std	Z+7, r25	; 0x07
    a8f0:	86 83       	std	Z+6, r24	; 0x06
    a8f2:	8e eb       	ldi	r24, 0xBE	; 190
    a8f4:	99 e0       	ldi	r25, 0x09	; 9
    a8f6:	91 87       	std	Z+9, r25	; 0x09
    a8f8:	80 87       	std	Z+8, r24	; 0x08
    a8fa:	8b ee       	ldi	r24, 0xEB	; 235
    a8fc:	99 e0       	ldi	r25, 0x09	; 9
    a8fe:	93 87       	std	Z+11, r25	; 0x0b
    a900:	82 87       	std	Z+10, r24	; 0x0a
    a902:	81 e6       	ldi	r24, 0x61	; 97
    a904:	9e e0       	ldi	r25, 0x0E	; 14
    a906:	95 87       	std	Z+13, r25	; 0x0d
    a908:	84 87       	std	Z+12, r24	; 0x0c
    a90a:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
     _uart_print(1, 0,strSend);
    a90e:	8d b7       	in	r24, 0x3d	; 61
    a910:	9e b7       	in	r25, 0x3e	; 62
    a912:	0e 96       	adiw	r24, 0x0e	; 14
    a914:	0f b6       	in	r0, 0x3f	; 63
    a916:	f8 94       	cli
    a918:	9e bf       	out	0x3e, r25	; 62
    a91a:	0f be       	out	0x3f, r0	; 63
    a91c:	8d bf       	out	0x3d, r24	; 61
    a91e:	81 e0       	ldi	r24, 0x01	; 1
    a920:	60 e0       	ldi	r22, 0x00	; 0
    a922:	a8 01       	movw	r20, r16
    a924:	0e 94 f2 b3 	call	0x167e4	; 0x167e4 <_uart_print>
	 _uart(1, 1,0x02);
    a928:	81 e0       	ldi	r24, 0x01	; 1
    a92a:	61 e0       	ldi	r22, 0x01	; 1
    a92c:	42 e0       	ldi	r20, 0x02	; 2
    a92e:	0e 94 d5 b3 	call	0x167aa	; 0x167aa <_uart>
}
    a932:	ec 96       	adiw	r28, 0x3c	; 60
    a934:	0f b6       	in	r0, 0x3f	; 63
    a936:	f8 94       	cli
    a938:	de bf       	out	0x3e, r29	; 62
    a93a:	0f be       	out	0x3f, r0	; 63
    a93c:	cd bf       	out	0x3d, r28	; 61
    a93e:	cf 91       	pop	r28
    a940:	df 91       	pop	r29
    a942:	1f 91       	pop	r17
    a944:	0f 91       	pop	r16
    a946:	08 95       	ret

0000a948 <FreePrinting>:
	 } 
	 else _uart(_COM_PRINTER,1,xSend);
	 zSend=xSend;
}

void FreePrinting(){
    a948:	0f 93       	push	r16
    a94a:	1f 93       	push	r17
static char iPrinted=0,iHeader=0,iFooter=0,PrintCopy=0,iMargin=0,iScroll=0,nScroll=0;
static char strHeader[41];
static unsigned int iSend=0,LSend=0,iLoop=0;

     //Normalize FreePrintIdleState
     if ((IsFreePrinting==True)&&(stFreePrinting!=fpInit)){
    a94c:	20 91 bf 01 	lds	r18, 0x01BF
    a950:	21 30       	cpi	r18, 0x01	; 1
    a952:	31 f4       	brne	.+12     	; 0xa960 <FreePrinting+0x18>
    a954:	80 91 25 01 	lds	r24, 0x0125
    a958:	81 30       	cpi	r24, 0x01	; 1
    a95a:	11 f0       	breq	.+4      	; 0xa960 <FreePrinting+0x18>
	     stFreePrinting=fpInit;
    a95c:	20 93 25 01 	sts	0x0125, r18
	 }

	 switch (stFreePrinting){
    a960:	80 91 25 01 	lds	r24, 0x0125
    a964:	90 e0       	ldi	r25, 0x00	; 0
    a966:	fc 01       	movw	r30, r24
    a968:	31 97       	sbiw	r30, 0x01	; 1
    a96a:	e5 31       	cpi	r30, 0x15	; 21
    a96c:	f1 05       	cpc	r31, r1
    a96e:	08 f0       	brcs	.+2      	; 0xa972 <FreePrinting+0x2a>
    a970:	7e c2       	rjmp	.+1276   	; 0xae6e <FreePrinting+0x526>
    a972:	ec 59       	subi	r30, 0x9C	; 156
    a974:	ff 4f       	sbci	r31, 0xFF	; 255
    a976:	ee 0f       	add	r30, r30
    a978:	ff 1f       	adc	r31, r31
    a97a:	05 90       	lpm	r0, Z+
    a97c:	f4 91       	lpm	r31, Z+
    a97e:	e0 2d       	mov	r30, r0
    a980:	09 94       	ijmp
     case fpInit:
	      //_uart_printf(0,1,PSTR("fpInit"));
	      if (IsFreePrinting==True){
    a982:	21 30       	cpi	r18, 0x01	; 1
    a984:	09 f0       	breq	.+2      	; 0xa988 <FreePrinting+0x40>
    a986:	73 c2       	rjmp	.+1254   	; 0xae6e <FreePrinting+0x526>
		      IsFreePrinting=False;
    a988:	10 92 bf 01 	sts	0x01BF, r1
			  IsBusyFreePrinting=True;
    a98c:	20 93 ca 01 	sts	0x01CA, r18
			  IsBusyPrint=False;
    a990:	10 92 c9 01 	sts	0x01C9, r1
			  iPrinted=0,iFooter=0;
    a994:	10 92 88 02 	sts	0x0288, r1
    a998:	10 92 86 02 	sts	0x0286, r1

			  PrintCopy=(cmdPrint&0x0F);
    a99c:	80 91 cb 01 	lds	r24, 0x01CB
    a9a0:	8f 70       	andi	r24, 0x0F	; 15
    a9a2:	80 93 85 02 	sts	0x0285, r24

			  //cmdPrint=cmdPrint|0b00100000;
			  //PrintCopy=2;

			  stFreePrinting=fpInitHeader;
    a9a6:	82 e0       	ldi	r24, 0x02	; 2
    a9a8:	80 93 25 01 	sts	0x0125, r24
			  InitPrinter();
    a9ac:	0e 94 26 4d 	call	0x9a4c	; 0x9a4c <InitPrinter>
    a9b0:	5e c2       	rjmp	.+1212   	; 0xae6e <FreePrinting+0x526>
			  }
	      break;
     case fpInitHeader:
	      //_uart_printf(0,1,PSTR("fpInitHeader"));
		  iHeader=0;
    a9b2:	10 92 87 02 	sts	0x0287, r1
	      if (((cmdPrint&0b10000000)>>7)==1){
    a9b6:	80 91 cb 01 	lds	r24, 0x01CB
    a9ba:	88 1f       	adc	r24, r24
    a9bc:	88 27       	eor	r24, r24
    a9be:	88 1f       	adc	r24, r24
    a9c0:	90 e0       	ldi	r25, 0x00	; 0
    a9c2:	81 30       	cpi	r24, 0x01	; 1
    a9c4:	91 05       	cpc	r25, r1
    a9c6:	21 f1       	breq	.+72     	; 0xaa10 <FreePrinting+0xc8>
		      stFreePrinting=fpLoadHeader;
			  }
		  else
	      if (((cmdPrint&0b10000000)>>7)==0) stFreePrinting=fpInitMessage;	      
    a9c8:	89 2b       	or	r24, r25
    a9ca:	09 f0       	breq	.+2      	; 0xa9ce <FreePrinting+0x86>
    a9cc:	50 c2       	rjmp	.+1184   	; 0xae6e <FreePrinting+0x526>
    a9ce:	85 e0       	ldi	r24, 0x05	; 5
    a9d0:	80 93 25 01 	sts	0x0125, r24
    a9d4:	4c c2       	rjmp	.+1176   	; 0xae6e <FreePrinting+0x526>
    a9d6:	60 91 87 02 	lds	r22, 0x0287
    a9da:	89 e2       	ldi	r24, 0x29	; 41
    a9dc:	68 9f       	mul	r22, r24
    a9de:	b0 01       	movw	r22, r0
    a9e0:	11 24       	eor	r1, r1
    a9e2:	69 5d       	subi	r22, 0xD9	; 217
    a9e4:	7d 4f       	sbci	r23, 0xFD	; 253
    a9e6:	89 e5       	ldi	r24, 0x59	; 89
    a9e8:	92 e0       	ldi	r25, 0x02	; 2
    a9ea:	48 e2       	ldi	r20, 0x28	; 40
    a9ec:	50 e0       	ldi	r21, 0x00	; 0
    a9ee:	26 ef       	ldi	r18, 0xF6	; 246
    a9f0:	32 e1       	ldi	r19, 0x12	; 18
    a9f2:	0e 94 7a b5 	call	0x16af4	; 0x16af4 <__eerd_block>
	      break;
     case fpLoadHeader:
	      //_uart_printf(0,1,PSTR("fpLoadHeader"));
          //Header 1
	      eeprom_read_block((void*) &strHeader, (const void*) &DefHeaderFooter[iHeader], 40);
		  iHeader++;
    a9f6:	00 91 87 02 	lds	r16, 0x0287
    a9fa:	0f 5f       	subi	r16, 0xFF	; 255
    a9fc:	00 93 87 02 	sts	0x0287, r16
		  if (iHeader<6){
    aa00:	06 30       	cpi	r16, 0x06	; 6
    aa02:	28 f7       	brcc	.-54     	; 0xa9ce <FreePrinting+0x86>
		      if (SpaceOnly(strHeader)==True){
    aa04:	89 e5       	ldi	r24, 0x59	; 89
    aa06:	92 e0       	ldi	r25, 0x02	; 2
    aa08:	0e 94 94 24 	call	0x4928	; 0x4928 <SpaceOnly>
    aa0c:	81 30       	cpi	r24, 0x01	; 1
    aa0e:	11 f4       	brne	.+4      	; 0xaa14 <FreePrinting+0xcc>
			      stFreePrinting=fpLoadHeader;
    aa10:	83 e0       	ldi	r24, 0x03	; 3
    aa12:	de cf       	rjmp	.-68     	; 0xa9d0 <FreePrinting+0x88>
				  }	      
			  else{
			      stFreePrinting=fpPrintHeader;
    aa14:	84 e0       	ldi	r24, 0x04	; 4
    aa16:	80 93 25 01 	sts	0x0125, r24
			      iSend=0;
    aa1a:	10 92 58 02 	sts	0x0258, r1
    aa1e:	10 92 57 02 	sts	0x0257, r1
				  iLoop=0;
    aa22:	10 92 54 02 	sts	0x0254, r1
    aa26:	10 92 53 02 	sts	0x0253, r1
				  //PrintDoubleHeight on 1st Header
				  if (iHeader==1) PrintDoubleHeight();
    aa2a:	01 30       	cpi	r16, 0x01	; 1
    aa2c:	19 f4       	brne	.+6      	; 0xaa34 <FreePrinting+0xec>
    aa2e:	0e 94 a8 4d 	call	0x9b50	; 0x9b50 <PrintDoubleHeight>
    aa32:	1d c2       	rjmp	.+1082   	; 0xae6e <FreePrinting+0x526>
				  else 
				  if (iHeader==2) PrintNormalHeight();
    aa34:	02 30       	cpi	r16, 0x02	; 2
    aa36:	09 f0       	breq	.+2      	; 0xaa3a <FreePrinting+0xf2>
    aa38:	1a c2       	rjmp	.+1076   	; 0xae6e <FreePrinting+0x526>
    aa3a:	0e 94 8e 4d 	call	0x9b1c	; 0x9b1c <PrintNormalHeight>
    aa3e:	17 c2       	rjmp	.+1070   	; 0xae6e <FreePrinting+0x526>
		  {stFreePrinting=fpInitMessage;
		  }
	      break;
     case fpPrintHeader:
	      //_uart_printf(0,1,PSTR("fpPrintHeader"));
		  if (iSend<40){
    aa40:	80 91 57 02 	lds	r24, 0x0257
    aa44:	90 91 58 02 	lds	r25, 0x0258
    aa48:	88 97       	sbiw	r24, 0x28	; 40
    aa4a:	78 f4       	brcc	.+30     	; 0xaa6a <FreePrinting+0x122>
		      iLoop++;
    aa4c:	80 91 53 02 	lds	r24, 0x0253
    aa50:	90 91 54 02 	lds	r25, 0x0254
    aa54:	01 96       	adiw	r24, 0x01	; 1
    aa56:	90 93 54 02 	sts	0x0254, r25
    aa5a:	80 93 53 02 	sts	0x0253, r24
			  if ((iLoop%PRINT_DELAY)==0){
			     //_uart(_COM_PRINTER,1,strHeader[iSend]);
		         //iSend++;
				 TimPrintBusy=0;
    aa5e:	10 92 cd 01 	sts	0x01CD, r1
    aa62:	10 92 cc 01 	sts	0x01CC, r1
				 stFreePrinting=fpCheckPrintStatusHeader;
    aa66:	82 e1       	ldi	r24, 0x12	; 18
    aa68:	b3 cf       	rjmp	.-154    	; 0xa9d0 <FreePrinting+0x88>
				 }
			  }
          else{ 
		     stFreePrinting=fpLoadHeader;
    aa6a:	83 e0       	ldi	r24, 0x03	; 3
    aa6c:	57 c1       	rjmp	.+686    	; 0xad1c <FreePrinting+0x3d4>
			 CarriegeReturn();
		  }
	      break;

     case fpCheckPrintStatusHeader:
	      if (IsBusyPrint==False){
    aa6e:	80 91 c9 01 	lds	r24, 0x01C9
    aa72:	88 23       	and	r24, r24
    aa74:	09 f0       	breq	.+2      	; 0xaa78 <FreePrinting+0x130>
    aa76:	71 c1       	rjmp	.+738    	; 0xad5a <FreePrinting+0x412>
		      _uart(_COM_PRINTER,1,strHeader[iSend]);
    aa78:	e0 91 57 02 	lds	r30, 0x0257
    aa7c:	f0 91 58 02 	lds	r31, 0x0258
    aa80:	e7 5a       	subi	r30, 0xA7	; 167
    aa82:	fd 4f       	sbci	r31, 0xFD	; 253
    aa84:	61 e0       	ldi	r22, 0x01	; 1
    aa86:	40 81       	ld	r20, Z
    aa88:	0e 94 d5 b3 	call	0x167aa	; 0x167aa <_uart>
		      iSend++;
    aa8c:	80 91 57 02 	lds	r24, 0x0257
    aa90:	90 91 58 02 	lds	r25, 0x0258
    aa94:	01 96       	adiw	r24, 0x01	; 1
    aa96:	90 93 58 02 	sts	0x0258, r25
    aa9a:	80 93 57 02 	sts	0x0257, r24
		      stFreePrinting=fpPrintHeader;
    aa9e:	84 e0       	ldi	r24, 0x04	; 4
    aaa0:	5a c1       	rjmp	.+692    	; 0xad56 <FreePrinting+0x40e>
			  }
	      break;

     case fpInitMessage:
	      //_uart_printf(0,1,PSTR("fpInitMessage"));
	      iSend=0;iLoop=0;
    aaa2:	10 92 58 02 	sts	0x0258, r1
    aaa6:	10 92 57 02 	sts	0x0257, r1
    aaaa:	10 92 54 02 	sts	0x0254, r1
    aaae:	10 92 53 02 	sts	0x0253, r1
          stFreePrinting=fpPrintMessage; 
    aab2:	08 e0       	ldi	r16, 0x08	; 8
    aab4:	00 93 25 01 	sts	0x0125, r16
		  CarriegeReturn();
    aab8:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <CarriegeReturn>
		  if (iPrinted>0) stFreePrinting=fpInitDuplicate;
    aabc:	80 91 88 02 	lds	r24, 0x0288
    aac0:	88 23       	and	r24, r24
    aac2:	11 f0       	breq	.+4      	; 0xaac8 <FreePrinting+0x180>
    aac4:	86 e0       	ldi	r24, 0x06	; 6
    aac6:	84 cf       	rjmp	.-248    	; 0xa9d0 <FreePrinting+0x88>
		  else stFreePrinting=fpPrintMessage; 
    aac8:	00 93 25 01 	sts	0x0125, r16
    aacc:	d0 c1       	rjmp	.+928    	; 0xae6e <FreePrinting+0x526>
	      break;
     case fpInitDuplicate:
	      //_uart_printf(0,1,PSTR("fpInitDuplicate"));
          if (iPrinted>0)sprintf_P(strHeader,PSTR("             DUPLICATE COPY        "));
    aace:	80 91 88 02 	lds	r24, 0x0288
    aad2:	29 e5       	ldi	r18, 0x59	; 89
    aad4:	32 e0       	ldi	r19, 0x02	; 2
    aad6:	88 23       	and	r24, r24
    aad8:	49 f0       	breq	.+18     	; 0xaaec <FreePrinting+0x1a4>
    aada:	00 d0       	rcall	.+0      	; 0xaadc <FreePrinting+0x194>
    aadc:	00 d0       	rcall	.+0      	; 0xaade <FreePrinting+0x196>
    aade:	ed b7       	in	r30, 0x3d	; 61
    aae0:	fe b7       	in	r31, 0x3e	; 62
    aae2:	32 83       	std	Z+2, r19	; 0x02
    aae4:	21 83       	std	Z+1, r18	; 0x01
    aae6:	8f e1       	ldi	r24, 0x1F	; 31
    aae8:	96 e0       	ldi	r25, 0x06	; 6
    aaea:	08 c0       	rjmp	.+16     	; 0xaafc <FreePrinting+0x1b4>
          else           sprintf_P(strHeader,PSTR("                                   "));
    aaec:	00 d0       	rcall	.+0      	; 0xaaee <FreePrinting+0x1a6>
    aaee:	00 d0       	rcall	.+0      	; 0xaaf0 <FreePrinting+0x1a8>
    aaf0:	ed b7       	in	r30, 0x3d	; 61
    aaf2:	fe b7       	in	r31, 0x3e	; 62
    aaf4:	32 83       	std	Z+2, r19	; 0x02
    aaf6:	21 83       	std	Z+1, r18	; 0x01
    aaf8:	8b ef       	ldi	r24, 0xFB	; 251
    aafa:	95 e0       	ldi	r25, 0x05	; 5
    aafc:	94 83       	std	Z+4, r25	; 0x04
    aafe:	83 83       	std	Z+3, r24	; 0x03
    ab00:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    ab04:	0f 90       	pop	r0
    ab06:	0f 90       	pop	r0
    ab08:	0f 90       	pop	r0
    ab0a:	0f 90       	pop	r0
		  iSend=0;
    ab0c:	10 92 58 02 	sts	0x0258, r1
    ab10:	10 92 57 02 	sts	0x0257, r1
		  iLoop=0;
    ab14:	10 92 54 02 	sts	0x0254, r1
    ab18:	10 92 53 02 	sts	0x0253, r1
		  LSend=strlen(strHeader);
    ab1c:	e9 e5       	ldi	r30, 0x59	; 89
    ab1e:	f2 e0       	ldi	r31, 0x02	; 2
    ab20:	01 90       	ld	r0, Z+
    ab22:	00 20       	and	r0, r0
    ab24:	e9 f7       	brne	.-6      	; 0xab20 <FreePrinting+0x1d8>
    ab26:	31 97       	sbiw	r30, 0x01	; 1
    ab28:	e9 55       	subi	r30, 0x59	; 89
    ab2a:	f2 40       	sbci	r31, 0x02	; 2
    ab2c:	f0 93 56 02 	sts	0x0256, r31
    ab30:	e0 93 55 02 	sts	0x0255, r30
          stFreePrinting=fpPrintDuplicate; 
    ab34:	87 e0       	ldi	r24, 0x07	; 7
    ab36:	4c cf       	rjmp	.-360    	; 0xa9d0 <FreePrinting+0x88>
	      break;
     case fpPrintDuplicate:
	      //_uart_printf(0,1,PSTR("fpPrintDuplicate"));
		  if (iSend<LSend){
    ab38:	20 91 57 02 	lds	r18, 0x0257
    ab3c:	30 91 58 02 	lds	r19, 0x0258
    ab40:	80 91 55 02 	lds	r24, 0x0255
    ab44:	90 91 56 02 	lds	r25, 0x0256
    ab48:	28 17       	cp	r18, r24
    ab4a:	39 07       	cpc	r19, r25
    ab4c:	78 f4       	brcc	.+30     	; 0xab6c <FreePrinting+0x224>
		      iLoop++;
    ab4e:	80 91 53 02 	lds	r24, 0x0253
    ab52:	90 91 54 02 	lds	r25, 0x0254
    ab56:	01 96       	adiw	r24, 0x01	; 1
    ab58:	90 93 54 02 	sts	0x0254, r25
    ab5c:	80 93 53 02 	sts	0x0253, r24
			  if((iLoop%PRINT_DELAY)==0){
			     //_uart(_COM_PRINTER,1,strHeader[iSend]);
				 //iSend++;
				 TimPrintBusy=0;
    ab60:	10 92 cd 01 	sts	0x01CD, r1
    ab64:	10 92 cc 01 	sts	0x01CC, r1
                 stFreePrinting=fpCheckPrintStatusDuplicate;
    ab68:	85 e1       	ldi	r24, 0x15	; 21
    ab6a:	32 cf       	rjmp	.-412    	; 0xa9d0 <FreePrinting+0x88>
				 }
			  }
          else {
		     iSend=0;
    ab6c:	10 92 58 02 	sts	0x0258, r1
    ab70:	10 92 57 02 	sts	0x0257, r1
		     stFreePrinting=fpPrintMessage;
    ab74:	88 e0       	ldi	r24, 0x08	; 8
    ab76:	d2 c0       	rjmp	.+420    	; 0xad1c <FreePrinting+0x3d4>
			 CarriegeReturn();	      
			 }
	      break;
     case fpCheckPrintStatusDuplicate:
	      if (IsBusyPrint==False){
    ab78:	80 91 c9 01 	lds	r24, 0x01C9
    ab7c:	88 23       	and	r24, r24
    ab7e:	09 f0       	breq	.+2      	; 0xab82 <FreePrinting+0x23a>
    ab80:	ec c0       	rjmp	.+472    	; 0xad5a <FreePrinting+0x412>
		      _uart(_COM_PRINTER,1,strHeader[iSend]);
    ab82:	e0 91 57 02 	lds	r30, 0x0257
    ab86:	f0 91 58 02 	lds	r31, 0x0258
    ab8a:	e7 5a       	subi	r30, 0xA7	; 167
    ab8c:	fd 4f       	sbci	r31, 0xFD	; 253
    ab8e:	61 e0       	ldi	r22, 0x01	; 1
    ab90:	40 81       	ld	r20, Z
    ab92:	0e 94 d5 b3 	call	0x167aa	; 0x167aa <_uart>
		      iSend++;
    ab96:	80 91 57 02 	lds	r24, 0x0257
    ab9a:	90 91 58 02 	lds	r25, 0x0258
    ab9e:	01 96       	adiw	r24, 0x01	; 1
    aba0:	90 93 58 02 	sts	0x0258, r25
    aba4:	80 93 57 02 	sts	0x0257, r24
		      stFreePrinting=fpPrintDuplicate;
    aba8:	87 e0       	ldi	r24, 0x07	; 7
    abaa:	d5 c0       	rjmp	.+426    	; 0xad56 <FreePrinting+0x40e>
		      stFreePrinting=fpFinishFreePrinting;
			  }
	      break;

     case fpPrintMessage:
		  if (iSend<LengthMessage81){
    abac:	20 91 57 02 	lds	r18, 0x0257
    abb0:	30 91 58 02 	lds	r19, 0x0258
    abb4:	80 91 a0 01 	lds	r24, 0x01A0
    abb8:	90 91 a1 01 	lds	r25, 0x01A1
    abbc:	28 17       	cp	r18, r24
    abbe:	39 07       	cpc	r19, r25
    abc0:	78 f4       	brcc	.+30     	; 0xabe0 <FreePrinting+0x298>
		      iLoop++;
    abc2:	80 91 53 02 	lds	r24, 0x0253
    abc6:	90 91 54 02 	lds	r25, 0x0254
    abca:	01 96       	adiw	r24, 0x01	; 1
    abcc:	90 93 54 02 	sts	0x0254, r25
    abd0:	80 93 53 02 	sts	0x0253, r24
			  if((iLoop%PRINT_DELAY)==0){
			     TimPrintBusy=0;
    abd4:	10 92 cd 01 	sts	0x01CD, r1
    abd8:	10 92 cc 01 	sts	0x01CC, r1
				 stFreePrinting=fpCheckPrintStatusMessage;
    abdc:	83 e1       	ldi	r24, 0x13	; 19
    abde:	f8 ce       	rjmp	.-528    	; 0xa9d0 <FreePrinting+0x88>
				 }
			  }
          else stFreePrinting=fpInitFooter;
    abe0:	8b e0       	ldi	r24, 0x0B	; 11
    abe2:	f6 ce       	rjmp	.-532    	; 0xa9d0 <FreePrinting+0x88>
	      break;
     
     case fpCheckPrintStatusMessage:
	      if (IsBusyPrint==False){
    abe4:	80 91 c9 01 	lds	r24, 0x01C9
    abe8:	88 23       	and	r24, r24
    abea:	09 f0       	breq	.+2      	; 0xabee <FreePrinting+0x2a6>
    abec:	b6 c0       	rjmp	.+364    	; 0xad5a <FreePrinting+0x412>
              if ((PrintBuffer[iSend]!=0x0D)||(PrintBuffer[iSend]!=0x0A))
			      SendPrint(PrintBuffer[iSend],PrintBuffer[iSend+1]);
    abee:	e0 91 57 02 	lds	r30, 0x0257
    abf2:	f0 91 58 02 	lds	r31, 0x0258
    abf6:	e1 53       	subi	r30, 0x31	; 49
    abf8:	fa 4f       	sbci	r31, 0xFA	; 250
    abfa:	80 81       	ld	r24, Z
    abfc:	61 81       	ldd	r22, Z+1	; 0x01
    abfe:	0e 94 03 4d 	call	0x9a06	; 0x9a06 <SendPrint>
			     // _uart(_COM_PRINTER,1,PrintBuffer[iSend]);
              if ((PrintBuffer[iSend]==0x0D)||(PrintBuffer[iSend+1]==0x0A))
    ac02:	e0 91 57 02 	lds	r30, 0x0257
    ac06:	f0 91 58 02 	lds	r31, 0x0258
    ac0a:	e1 53       	subi	r30, 0x31	; 49
    ac0c:	fa 4f       	sbci	r31, 0xFA	; 250
    ac0e:	80 81       	ld	r24, Z
    ac10:	8d 30       	cpi	r24, 0x0D	; 13
    ac12:	19 f0       	breq	.+6      	; 0xac1a <FreePrinting+0x2d2>
    ac14:	81 81       	ldd	r24, Z+1	; 0x01
    ac16:	8a 30       	cpi	r24, 0x0A	; 10
    ac18:	11 f4       	brne	.+4      	; 0xac1e <FreePrinting+0x2d6>
			     CarriegeReturn();
    ac1a:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <CarriegeReturn>
             iSend++;
    ac1e:	80 91 57 02 	lds	r24, 0x0257
    ac22:	90 91 58 02 	lds	r25, 0x0258
    ac26:	01 96       	adiw	r24, 0x01	; 1
    ac28:	90 93 58 02 	sts	0x0258, r25
    ac2c:	80 93 57 02 	sts	0x0257, r24
		     stFreePrinting=fpPrintMessage;
    ac30:	88 e0       	ldi	r24, 0x08	; 8
    ac32:	91 c0       	rjmp	.+290    	; 0xad56 <FreePrinting+0x40e>
		      stFreePrinting=fpFinishFreePrinting;
			  }
	      break;
     //SpaceAdded
	 case fpInitSpace:
	      iLoop=0;
    ac34:	10 92 54 02 	sts	0x0254, r1
    ac38:	10 92 53 02 	sts	0x0253, r1
		  iMargin=0;
    ac3c:	10 92 84 02 	sts	0x0284, r1
		  stFreePrinting=fpPrintMargin;
    ac40:	8a e0       	ldi	r24, 0x0A	; 10
    ac42:	c6 ce       	rjmp	.-628    	; 0xa9d0 <FreePrinting+0x88>
	      break;
	 case fpPrintMargin:
		  if (iMargin<PRINT_MARGIN){
    ac44:	80 91 84 02 	lds	r24, 0x0284
    ac48:	85 30       	cpi	r24, 0x05	; 5
    ac4a:	90 f4       	brcc	.+36     	; 0xac70 <FreePrinting+0x328>
		      iMargin++;
    ac4c:	8f 5f       	subi	r24, 0xFF	; 255
    ac4e:	80 93 84 02 	sts	0x0284, r24
		      iLoop++;
    ac52:	80 91 53 02 	lds	r24, 0x0253
    ac56:	90 91 54 02 	lds	r25, 0x0254
    ac5a:	01 96       	adiw	r24, 0x01	; 1
    ac5c:	90 93 54 02 	sts	0x0254, r25
    ac60:	80 93 53 02 	sts	0x0253, r24
	          if ((iLoop%PRINT_DELAY)==0)_uart(_COM_PRINTER,1,' ');
    ac64:	80 e0       	ldi	r24, 0x00	; 0
    ac66:	61 e0       	ldi	r22, 0x01	; 1
    ac68:	40 e2       	ldi	r20, 0x20	; 32
    ac6a:	0e 94 d5 b3 	call	0x167aa	; 0x167aa <_uart>
    ac6e:	ff c0       	rjmp	.+510    	; 0xae6e <FreePrinting+0x526>
			 }
          else stFreePrinting=fpPrintMessage;
    ac70:	88 e0       	ldi	r24, 0x08	; 8
    ac72:	ae ce       	rjmp	.-676    	; 0xa9d0 <FreePrinting+0x88>
	      break;
     case fpInitFooter:
	      //_uart_printf(0,1,PSTR("fpInitFooter"));
          if (((cmdPrint&0b01000000)>>6)==1){
    ac74:	80 91 cb 01 	lds	r24, 0x01CB
    ac78:	86 ff       	sbrs	r24, 6
    ac7a:	06 c0       	rjmp	.+12     	; 0xac88 <FreePrinting+0x340>
		      stFreePrinting=fpLoadFooter;
    ac7c:	8c e0       	ldi	r24, 0x0C	; 12
    ac7e:	80 93 25 01 	sts	0x0125, r24
			  iFooter=0;
    ac82:	10 92 86 02 	sts	0x0286, r1
    ac86:	f3 c0       	rjmp	.+486    	; 0xae6e <FreePrinting+0x526>
			  }
		  else
	      if (((cmdPrint&0b01000000)>>6)==0) stFreePrinting=fpPaperCut;//fpInitScroll;	                
    ac88:	80 e1       	ldi	r24, 0x10	; 16
    ac8a:	a2 ce       	rjmp	.-700    	; 0xa9d0 <FreePrinting+0x88>
    ac8c:	60 91 86 02 	lds	r22, 0x0286
    ac90:	89 e2       	ldi	r24, 0x29	; 41
    ac92:	68 9f       	mul	r22, r24
    ac94:	b0 01       	movw	r22, r0
    ac96:	11 24       	eor	r1, r1
    ac98:	63 5e       	subi	r22, 0xE3	; 227
    ac9a:	7c 4f       	sbci	r23, 0xFC	; 252
    ac9c:	89 e5       	ldi	r24, 0x59	; 89
    ac9e:	92 e0       	ldi	r25, 0x02	; 2
    aca0:	48 e2       	ldi	r20, 0x28	; 40
    aca2:	50 e0       	ldi	r21, 0x00	; 0
    aca4:	26 ef       	ldi	r18, 0xF6	; 246
    aca6:	32 e1       	ldi	r19, 0x12	; 18
    aca8:	0e 94 7a b5 	call	0x16af4	; 0x16af4 <__eerd_block>
	      break;
     case fpLoadFooter:
	 	  //_uart_printf(0,1,PSTR("fpLoadFooter"));
          //Footer 1
	      eeprom_read_block((void*) &strHeader, (const void*) &DefHeaderFooter[6+iFooter], 40);
		  iFooter++;
    acac:	80 91 86 02 	lds	r24, 0x0286
    acb0:	8f 5f       	subi	r24, 0xFF	; 255
    acb2:	80 93 86 02 	sts	0x0286, r24
		  if (iFooter<4){
    acb6:	84 30       	cpi	r24, 0x04	; 4
    acb8:	90 f4       	brcc	.+36     	; 0xacde <FreePrinting+0x396>
		      if (SpaceOnly(strHeader)==True){
    acba:	89 e5       	ldi	r24, 0x59	; 89
    acbc:	92 e0       	ldi	r25, 0x02	; 2
    acbe:	0e 94 94 24 	call	0x4928	; 0x4928 <SpaceOnly>
    acc2:	81 30       	cpi	r24, 0x01	; 1
    acc4:	11 f4       	brne	.+4      	; 0xacca <FreePrinting+0x382>
			      stFreePrinting=fpLoadFooter;
    acc6:	8c e0       	ldi	r24, 0x0C	; 12
    acc8:	83 ce       	rjmp	.-762    	; 0xa9d0 <FreePrinting+0x88>
				  }
			  else{
			      iSend=0;
    acca:	10 92 58 02 	sts	0x0258, r1
    acce:	10 92 57 02 	sts	0x0257, r1
				  iLoop=0;
    acd2:	10 92 54 02 	sts	0x0254, r1
    acd6:	10 92 53 02 	sts	0x0253, r1
				  stFreePrinting=fpPrintFooter;
    acda:	8d e0       	ldi	r24, 0x0D	; 13
    acdc:	79 ce       	rjmp	.-782    	; 0xa9d0 <FreePrinting+0x88>
			      }
		  }else{
		    CarriegeReturn();
    acde:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <CarriegeReturn>
			iPrinted++;
    ace2:	80 91 88 02 	lds	r24, 0x0288
    ace6:	8f 5f       	subi	r24, 0xFF	; 255
    ace8:	80 93 88 02 	sts	0x0288, r24

			//if (eeprom_read_byte(&DefPrinterType)==PT_CUSTOM_CUBE){
			    stFreePrinting=fpInitScroll;
    acec:	8e e0       	ldi	r24, 0x0E	; 14
    acee:	70 ce       	rjmp	.-800    	; 0xa9d0 <FreePrinting+0x88>
			//}else stFreePrinting=fpPaperCut;

			}
	      break;
     case fpPrintFooter:
		  if (iSend<40){
    acf0:	80 91 57 02 	lds	r24, 0x0257
    acf4:	90 91 58 02 	lds	r25, 0x0258
    acf8:	88 97       	sbiw	r24, 0x28	; 40
    acfa:	78 f4       	brcc	.+30     	; 0xad1a <FreePrinting+0x3d2>
		      iLoop++;
    acfc:	80 91 53 02 	lds	r24, 0x0253
    ad00:	90 91 54 02 	lds	r25, 0x0254
    ad04:	01 96       	adiw	r24, 0x01	; 1
    ad06:	90 93 54 02 	sts	0x0254, r25
    ad0a:	80 93 53 02 	sts	0x0253, r24
			  if((iLoop%PRINT_DELAY)==0){
		        //_uart(_COM_PRINTER,1,strHeader[iSend]);
		        //iSend++;
				TimPrintBusy=0;
    ad0e:	10 92 cd 01 	sts	0x01CD, r1
    ad12:	10 92 cc 01 	sts	0x01CC, r1
				stFreePrinting=fpCheckPrintStatusFooter;
    ad16:	84 e1       	ldi	r24, 0x14	; 20
    ad18:	5b ce       	rjmp	.-842    	; 0xa9d0 <FreePrinting+0x88>
				}
			  }
          else {
		      stFreePrinting=fpLoadFooter;
    ad1a:	8c e0       	ldi	r24, 0x0C	; 12
    ad1c:	80 93 25 01 	sts	0x0125, r24
			  CarriegeReturn();
    ad20:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <CarriegeReturn>
    ad24:	a4 c0       	rjmp	.+328    	; 0xae6e <FreePrinting+0x526>
			  }
	      break;
     
	 case fpCheckPrintStatusFooter:
	      if (IsBusyPrint==False){
    ad26:	80 91 c9 01 	lds	r24, 0x01C9
    ad2a:	88 23       	and	r24, r24
    ad2c:	b1 f4       	brne	.+44     	; 0xad5a <FreePrinting+0x412>
		      _uart(_COM_PRINTER,1,strHeader[iSend]);
    ad2e:	e0 91 57 02 	lds	r30, 0x0257
    ad32:	f0 91 58 02 	lds	r31, 0x0258
    ad36:	e7 5a       	subi	r30, 0xA7	; 167
    ad38:	fd 4f       	sbci	r31, 0xFD	; 253
    ad3a:	61 e0       	ldi	r22, 0x01	; 1
    ad3c:	40 81       	ld	r20, Z
    ad3e:	0e 94 d5 b3 	call	0x167aa	; 0x167aa <_uart>
		      iSend++;
    ad42:	80 91 57 02 	lds	r24, 0x0257
    ad46:	90 91 58 02 	lds	r25, 0x0258
    ad4a:	01 96       	adiw	r24, 0x01	; 1
    ad4c:	90 93 58 02 	sts	0x0258, r25
    ad50:	80 93 57 02 	sts	0x0257, r24
		      stFreePrinting=fpPrintFooter;
    ad54:	8d e0       	ldi	r24, 0x0D	; 13
    ad56:	80 93 25 01 	sts	0x0125, r24
		  }
		  if (TimPrintBusy>TIM_BUSY_PRINT){
    ad5a:	80 91 cc 01 	lds	r24, 0x01CC
    ad5e:	90 91 cd 01 	lds	r25, 0x01CD
    ad62:	0b 97       	sbiw	r24, 0x0b	; 11
    ad64:	0c f4       	brge	.+2      	; 0xad68 <FreePrinting+0x420>
    ad66:	83 c0       	rjmp	.+262    	; 0xae6e <FreePrinting+0x526>
		      IsPrintERROR=True;
    ad68:	81 e0       	ldi	r24, 0x01	; 1
    ad6a:	80 93 c7 01 	sts	0x01C7, r24
		      stFreePrinting=fpFinishFreePrinting;
    ad6e:	81 e1       	ldi	r24, 0x11	; 17
    ad70:	2f ce       	rjmp	.-930    	; 0xa9d0 <FreePrinting+0x88>
			  }
	      break;

     case fpInitScroll:
	      iScroll=0;
    ad72:	10 92 83 02 	sts	0x0283, r1
		  iSend=0;
    ad76:	10 92 58 02 	sts	0x0258, r1
    ad7a:	10 92 57 02 	sts	0x0257, r1
		  if (iPrinted<PrintCopy)
    ad7e:	90 91 88 02 	lds	r25, 0x0288
    ad82:	80 91 85 02 	lds	r24, 0x0285
    ad86:	98 17       	cp	r25, r24
    ad88:	28 f4       	brcc	.+10     	; 0xad94 <FreePrinting+0x44c>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    ad8a:	e1 99       	sbic	0x1c, 1	; 28
    ad8c:	fe cf       	rjmp	.-4      	; 0xad8a <FreePrinting+0x442>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    ad8e:	82 e3       	ldi	r24, 0x32	; 50
    ad90:	90 e0       	ldi	r25, 0x00	; 0
    ad92:	04 c0       	rjmp	.+8      	; 0xad9c <FreePrinting+0x454>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    ad94:	e1 99       	sbic	0x1c, 1	; 28
    ad96:	fe cf       	rjmp	.-4      	; 0xad94 <FreePrinting+0x44c>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    ad98:	81 e3       	ldi	r24, 0x31	; 49
    ad9a:	90 e0       	ldi	r25, 0x00	; 0
    ad9c:	9f bb       	out	0x1f, r25	; 31
    ad9e:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    ada0:	e0 9a       	sbi	0x1c, 0	; 28
    ada2:	8d b3       	in	r24, 0x1d	; 29
		      nScroll=eeprom_read_byte(&DefPrintScrollSpace);
		  else if (iPrinted>=PrintCopy)
		  	  nScroll=eeprom_read_byte(&DefPrintScrollEnd);
    ada4:	80 93 82 02 	sts	0x0282, r24

          stFreePrinting=fpScrollPaper;
    ada8:	8f e0       	ldi	r24, 0x0F	; 15
    adaa:	12 ce       	rjmp	.-988    	; 0xa9d0 <FreePrinting+0x88>
	      break;
     case fpScrollPaper:
	      if (iScroll>nScroll)stFreePrinting=fpPaperCut;
    adac:	90 91 83 02 	lds	r25, 0x0283
    adb0:	80 91 82 02 	lds	r24, 0x0282
    adb4:	89 17       	cp	r24, r25
    adb6:	18 f4       	brcc	.+6      	; 0xadbe <FreePrinting+0x476>
    adb8:	80 e1       	ldi	r24, 0x10	; 16
    adba:	80 93 25 01 	sts	0x0125, r24
		  iSend++;
    adbe:	80 91 57 02 	lds	r24, 0x0257
    adc2:	90 91 58 02 	lds	r25, 0x0258
    adc6:	01 96       	adiw	r24, 0x01	; 1
    adc8:	90 93 58 02 	sts	0x0258, r25
    adcc:	80 93 57 02 	sts	0x0257, r24
		  if (iSend%PRINT_DELAY==0){
		      CarriegeReturn();
    add0:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <CarriegeReturn>
			  iScroll++;
    add4:	80 91 83 02 	lds	r24, 0x0283
    add8:	8f 5f       	subi	r24, 0xFF	; 255
    adda:	80 93 83 02 	sts	0x0283, r24
    adde:	47 c0       	rjmp	.+142    	; 0xae6e <FreePrinting+0x526>
			  }
	      break;
     case fpPaperCut:
		  //_uart_printf(0,1,PSTR("fpPaperCut"));
		  //iPrinted++;
          if (iPrinted<PrintCopy){
    ade0:	90 91 88 02 	lds	r25, 0x0288
    ade4:	80 91 85 02 	lds	r24, 0x0285
    ade8:	98 17       	cp	r25, r24
    adea:	20 f4       	brcc	.+8      	; 0xadf4 <FreePrinting+0x4ac>
		      CarriegeReturn();
    adec:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <CarriegeReturn>
              stFreePrinting=fpInitHeader;
    adf0:	82 e0       	ldi	r24, 0x02	; 2
    adf2:	07 c0       	rjmp	.+14     	; 0xae02 <FreePrinting+0x4ba>
			  }
          else{
		      if (IFType==IT_SLAVE)sendMessage04();
    adf4:	80 91 10 01 	lds	r24, 0x0110
    adf8:	81 30       	cpi	r24, 0x01	; 1
    adfa:	11 f4       	brne	.+4      	; 0xae00 <FreePrinting+0x4b8>
    adfc:	0e 94 40 54 	call	0xa880	; 0xa880 <sendMessage04>
		      stFreePrinting=fpFinishFreePrinting;
    ae00:	81 e1       	ldi	r24, 0x11	; 17
    ae02:	80 93 25 01 	sts	0x0125, r24
			  }

		  if (((cmdPrint&0b00100000)>>5)==1){
    ae06:	80 91 cb 01 	lds	r24, 0x01CB
    ae0a:	85 ff       	sbrs	r24, 5
    ae0c:	30 c0       	rjmp	.+96     	; 0xae6e <FreePrinting+0x526>
		      if (iPrinted==0){
    ae0e:	80 91 88 02 	lds	r24, 0x0288
    ae12:	88 23       	and	r24, r24
    ae14:	31 f4       	brne	.+12     	; 0xae22 <FreePrinting+0x4da>
			      CarriegeReturn();_delay_ms(50);
    ae16:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <CarriegeReturn>
    ae1a:	84 ed       	ldi	r24, 0xD4	; 212
    ae1c:	90 e3       	ldi	r25, 0x30	; 48
    ae1e:	01 97       	sbiw	r24, 0x01	; 1
    ae20:	f1 f7       	brne	.-4      	; 0xae1e <FreePrinting+0x4d6>
				 }
              //HFCS 0000 : Header, Footer, Copy , Scrool [Copy:16x max]
		      if ((iPrinted==PrintCopy)){
    ae22:	90 91 88 02 	lds	r25, 0x0288
    ae26:	80 91 85 02 	lds	r24, 0x0285
    ae2a:	98 17       	cp	r25, r24
    ae2c:	b1 f4       	brne	.+44     	; 0xae5a <FreePrinting+0x512>
			      // if (((cmdPrint&0b00010000)>>4)==1){
				       CarriegeReturn();_delay_ms(50);
    ae2e:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <CarriegeReturn>
    ae32:	04 ed       	ldi	r16, 0xD4	; 212
    ae34:	10 e3       	ldi	r17, 0x30	; 48
    ae36:	c8 01       	movw	r24, r16
    ae38:	01 97       	sbiw	r24, 0x01	; 1
    ae3a:	f1 f7       	brne	.-4      	; 0xae38 <FreePrinting+0x4f0>
					   CarriegeReturn();_delay_ms(50);
    ae3c:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <CarriegeReturn>
    ae40:	c8 01       	movw	r24, r16
    ae42:	01 97       	sbiw	r24, 0x01	; 1
    ae44:	f1 f7       	brne	.-4      	; 0xae42 <FreePrinting+0x4fa>
					   CarriegeReturn();_delay_ms(50);
    ae46:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <CarriegeReturn>
    ae4a:	c8 01       	movw	r24, r16
    ae4c:	01 97       	sbiw	r24, 0x01	; 1
    ae4e:	f1 f7       	brne	.-4      	; 0xae4c <FreePrinting+0x504>
					   CarriegeReturn();_delay_ms(50);
    ae50:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <CarriegeReturn>
    ae54:	c8 01       	movw	r24, r16
    ae56:	01 97       	sbiw	r24, 0x01	; 1
    ae58:	f1 f7       	brne	.-4      	; 0xae56 <FreePrinting+0x50e>
				   //}
				 }
		      PaperCut();
    ae5a:	0e 94 c2 4d 	call	0x9b84	; 0x9b84 <PaperCut>
    ae5e:	07 c0       	rjmp	.+14     	; 0xae6e <FreePrinting+0x526>
		   }
	      break;
     case fpFinishFreePrinting:
	 	  //_uart_printf(0,1,PSTR("fpFinished"));
		  IsBusyFreePrinting=False;
    ae60:	10 92 ca 01 	sts	0x01CA, r1
	      stFreePrinting=fpInit;
    ae64:	81 e0       	ldi	r24, 0x01	; 1
    ae66:	80 93 25 01 	sts	0x0125, r24
		  iPrinted=0;
    ae6a:	10 92 88 02 	sts	0x0288, r1
	      break;
	 }//EndCase
}
    ae6e:	1f 91       	pop	r17
    ae70:	0f 91       	pop	r16
    ae72:	08 95       	ret

0000ae74 <PrintIdle>:
		//Font Setting: 1D 21 01
		_uart(_COM_PRINTER, 1, 0x1D);_uart(_COM_PRINTER, 1, 0x21);_uart(_COM_PRINTER, 1, 0x00);   
		}
}

void PrintIdle(){
    ae74:	cf 93       	push	r28
    ae76:	df 93       	push	r29
		_uart_print(1,1,strSend);
	 }
	 #endif

     //Normalize PrintIdleState
     if ((IsPrinting==True)&&(stPrintIdle!=piIdle)){
    ae78:	80 91 c3 01 	lds	r24, 0x01C3
    ae7c:	81 30       	cpi	r24, 0x01	; 1
    ae7e:	31 f4       	brne	.+12     	; 0xae8c <PrintIdle+0x18>
    ae80:	80 91 c6 02 	lds	r24, 0x02C6
    ae84:	88 23       	and	r24, r24
    ae86:	11 f0       	breq	.+4      	; 0xae8c <PrintIdle+0x18>
	     stPrintIdle=piIdle;
    ae88:	10 92 c6 02 	sts	0x02C6, r1
	 }

     switch(stPrintIdle){
    ae8c:	80 91 c6 02 	lds	r24, 0x02C6
    ae90:	e8 2f       	mov	r30, r24
    ae92:	f0 e0       	ldi	r31, 0x00	; 0
    ae94:	e5 31       	cpi	r30, 0x15	; 21
    ae96:	f1 05       	cpc	r31, r1
    ae98:	08 f0       	brcs	.+2      	; 0xae9c <PrintIdle+0x28>
    ae9a:	0f c7       	rjmp	.+3614   	; 0xbcba <PrintIdle+0xe46>
    ae9c:	e7 58       	subi	r30, 0x87	; 135
    ae9e:	ff 4f       	sbci	r31, 0xFF	; 255
    aea0:	ee 0f       	add	r30, r30
    aea2:	ff 1f       	adc	r31, r31
    aea4:	05 90       	lpm	r0, Z+
    aea6:	f4 91       	lpm	r31, Z+
    aea8:	e0 2d       	mov	r30, r0
    aeaa:	09 94       	ijmp
	 case piIdle:
	      if (IsPrinting==True){
    aeac:	80 91 c3 01 	lds	r24, 0x01C3
    aeb0:	81 30       	cpi	r24, 0x01	; 1
    aeb2:	09 f0       	breq	.+2      	; 0xaeb6 <PrintIdle+0x42>
    aeb4:	02 c7       	rjmp	.+3588   	; 0xbcba <PrintIdle+0xe46>
		      IsPrinting=False;
    aeb6:	10 92 c3 01 	sts	0x01C3, r1
			  IsBusyIdlePrinting=True;
    aeba:	80 93 c8 01 	sts	0x01C8, r24
			  IsBusyPrint=False;
    aebe:	10 92 c9 01 	sts	0x01C9, r1
			  iPrinted=0;
    aec2:	10 92 8b 02 	sts	0x028B, r1
			  PrintCopy=0;
    aec6:	10 92 8a 02 	sts	0x028A, r1
		      stPrintIdle=piInit;
    aeca:	80 93 c6 02 	sts	0x02C6, r24
			  InitPrinter();
    aece:	0e 94 26 4d 	call	0x9a4c	; 0x9a4c <InitPrinter>
			  IsSignedField=False;
    aed2:	10 92 92 02 	sts	0x0292, r1
    aed6:	f1 c6       	rjmp	.+3554   	; 0xbcba <PrintIdle+0xe46>
			  }
	      break;
	 case piInit:
	      iHeader=0;
    aed8:	10 92 c5 02 	sts	0x02C5, r1
		  CarriegeReturn();
    aedc:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <CarriegeReturn>
    aee0:	1d c0       	rjmp	.+58     	; 0xaf1c <PrintIdle+0xa8>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    aee2:	60 91 c5 02 	lds	r22, 0x02C5
    aee6:	89 e2       	ldi	r24, 0x29	; 41
    aee8:	68 9f       	mul	r22, r24
    aeea:	b0 01       	movw	r22, r0
    aeec:	11 24       	eor	r1, r1
    aeee:	69 5d       	subi	r22, 0xD9	; 217
    aef0:	7d 4f       	sbci	r23, 0xFD	; 253
    aef2:	85 e9       	ldi	r24, 0x95	; 149
    aef4:	92 e0       	ldi	r25, 0x02	; 2
    aef6:	49 e2       	ldi	r20, 0x29	; 41
    aef8:	50 e0       	ldi	r21, 0x00	; 0
    aefa:	26 ef       	ldi	r18, 0xF6	; 246
    aefc:	32 e1       	ldi	r19, 0x12	; 18
    aefe:	0e 94 7a b5 	call	0x16af4	; 0x16af4 <__eerd_block>
		  stPrintIdle=piLoadHeader;
	      break;
     case piLoadHeader:
	      eeprom_read_block((void*) &strPrint, (const void*) &DefHeaderFooter[iHeader], sizeof(DefHeaderFooter[iHeader]));
		  iHeader++;
    af02:	80 91 c5 02 	lds	r24, 0x02C5
    af06:	8f 5f       	subi	r24, 0xFF	; 255
    af08:	80 93 c5 02 	sts	0x02C5, r24
		  if (iHeader<6){
    af0c:	86 30       	cpi	r24, 0x06	; 6
    af0e:	00 f5       	brcc	.+64     	; 0xaf50 <PrintIdle+0xdc>
		      if (SpaceOnly(strPrint)==True){
    af10:	85 e9       	ldi	r24, 0x95	; 149
    af12:	92 e0       	ldi	r25, 0x02	; 2
    af14:	0e 94 94 24 	call	0x4928	; 0x4928 <SpaceOnly>
    af18:	81 30       	cpi	r24, 0x01	; 1
    af1a:	11 f4       	brne	.+4      	; 0xaf20 <PrintIdle+0xac>
			      stPrintIdle=piLoadHeader;
    af1c:	82 e0       	ldi	r24, 0x02	; 2
    af1e:	a2 c6       	rjmp	.+3396   	; 0xbc64 <PrintIdle+0xdf0>
				  }	      
			  else{
			      stPrintIdle=piPrintHeader;
    af20:	83 e0       	ldi	r24, 0x03	; 3
    af22:	80 93 c6 02 	sts	0x02C6, r24
			      iSend=0;
    af26:	10 92 91 02 	sts	0x0291, r1
    af2a:	10 92 90 02 	sts	0x0290, r1
				  iLoop=0;
    af2e:	10 92 8d 02 	sts	0x028D, r1
    af32:	10 92 8c 02 	sts	0x028C, r1
				  //PrintDoubleHeight on 1st Header
				  if (iHeader==1) PrintDoubleHeight();
    af36:	80 91 c5 02 	lds	r24, 0x02C5
    af3a:	81 30       	cpi	r24, 0x01	; 1
    af3c:	19 f4       	brne	.+6      	; 0xaf44 <PrintIdle+0xd0>
    af3e:	0e 94 a8 4d 	call	0x9b50	; 0x9b50 <PrintDoubleHeight>
    af42:	bb c6       	rjmp	.+3446   	; 0xbcba <PrintIdle+0xe46>
				  else 
				  if (iHeader==2) PrintNormalHeight();
    af44:	82 30       	cpi	r24, 0x02	; 2
    af46:	09 f0       	breq	.+2      	; 0xaf4a <PrintIdle+0xd6>
    af48:	b8 c6       	rjmp	.+3440   	; 0xbcba <PrintIdle+0xe46>
    af4a:	0e 94 8e 4d 	call	0x9b1c	; 0x9b1c <PrintNormalHeight>
    af4e:	b5 c6       	rjmp	.+3434   	; 0xbcba <PrintIdle+0xe46>
			   }
		  }else{stPrintIdle=piInitDuplicate; //stPrintIdle=piInitMessage;//
    af50:	84 e0       	ldi	r24, 0x04	; 4
    af52:	88 c6       	rjmp	.+3344   	; 0xbc64 <PrintIdle+0xdf0>
		        //else stPrintIdle=piInitMessage;
		  }
	      break;
	 case piPrintHeader:
		  if (iSend<40){
    af54:	80 91 90 02 	lds	r24, 0x0290
    af58:	90 91 91 02 	lds	r25, 0x0291
    af5c:	88 97       	sbiw	r24, 0x28	; 40
    af5e:	78 f4       	brcc	.+30     	; 0xaf7e <PrintIdle+0x10a>
		      iLoop++;
    af60:	80 91 8c 02 	lds	r24, 0x028C
    af64:	90 91 8d 02 	lds	r25, 0x028D
    af68:	01 96       	adiw	r24, 0x01	; 1
    af6a:	90 93 8d 02 	sts	0x028D, r25
    af6e:	80 93 8c 02 	sts	0x028C, r24
			  if ((iLoop%PRINT_DELAY)==0){
				 TimPrintBusy=0;
    af72:	10 92 cd 01 	sts	0x01CD, r1
    af76:	10 92 cc 01 	sts	0x01CC, r1
				 stPrintIdle=piCheckPrintStatusHeader;
    af7a:	8b e0       	ldi	r24, 0x0B	; 11
    af7c:	73 c6       	rjmp	.+3302   	; 0xbc64 <PrintIdle+0xdf0>
				 }
			  }
          else{ 
		     stPrintIdle=piLoadHeader;
    af7e:	82 e0       	ldi	r24, 0x02	; 2
    af80:	01 c6       	rjmp	.+3074   	; 0xbb84 <PrintIdle+0xd10>
			 CarriegeReturn();
		  }
	      break;
     case piCheckPrintStatusHeader:
	      if (IsBusyPrint==False){
    af82:	80 91 c9 01 	lds	r24, 0x01C9
    af86:	88 23       	and	r24, r24
    af88:	09 f0       	breq	.+2      	; 0xaf8c <PrintIdle+0x118>
    af8a:	62 c6       	rjmp	.+3268   	; 0xbc50 <PrintIdle+0xddc>
		      _uart(_COM_PRINTER,1,strPrint[iSend]);
    af8c:	e0 91 90 02 	lds	r30, 0x0290
    af90:	f0 91 91 02 	lds	r31, 0x0291
    af94:	eb 56       	subi	r30, 0x6B	; 107
    af96:	fd 4f       	sbci	r31, 0xFD	; 253
    af98:	61 e0       	ldi	r22, 0x01	; 1
    af9a:	40 81       	ld	r20, Z
    af9c:	0e 94 d5 b3 	call	0x167aa	; 0x167aa <_uart>
		      iSend++;
    afa0:	80 91 90 02 	lds	r24, 0x0290
    afa4:	90 91 91 02 	lds	r25, 0x0291
    afa8:	01 96       	adiw	r24, 0x01	; 1
    afaa:	90 93 91 02 	sts	0x0291, r25
    afae:	80 93 90 02 	sts	0x0290, r24
		      stPrintIdle=piPrintHeader;
    afb2:	83 e0       	ldi	r24, 0x03	; 3
    afb4:	4b c6       	rjmp	.+3222   	; 0xbc4c <PrintIdle+0xdd8>
		      stPrintIdle=piFinishPrintIdle;
			  }
	      break;

     case piInitDuplicate:
          if ((iPrinted>0)||(IsReprintTicket==True)){
    afb6:	80 91 8b 02 	lds	r24, 0x028B
    afba:	88 23       	and	r24, r24
    afbc:	21 f4       	brne	.+8      	; 0xafc6 <PrintIdle+0x152>
    afbe:	80 91 92 01 	lds	r24, 0x0192
    afc2:	81 30       	cpi	r24, 0x01	; 1
    afc4:	a9 f4       	brne	.+42     	; 0xaff0 <PrintIdle+0x17c>
		      IsReprintTicket=False;
    afc6:	10 92 92 01 	sts	0x0192, r1
		      CarriegeReturn(); 
    afca:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <CarriegeReturn>
		      sprintf_P(strPrint,PSTR("             DUPLICATE COPY        "));
    afce:	00 d0       	rcall	.+0      	; 0xafd0 <PrintIdle+0x15c>
    afd0:	00 d0       	rcall	.+0      	; 0xafd2 <PrintIdle+0x15e>
    afd2:	85 e9       	ldi	r24, 0x95	; 149
    afd4:	92 e0       	ldi	r25, 0x02	; 2
    afd6:	ad b7       	in	r26, 0x3d	; 61
    afd8:	be b7       	in	r27, 0x3e	; 62
    afda:	12 96       	adiw	r26, 0x02	; 2
    afdc:	9c 93       	st	X, r25
    afde:	8e 93       	st	-X, r24
    afe0:	11 97       	sbiw	r26, 0x01	; 1
    afe2:	8a e0       	ldi	r24, 0x0A	; 10
    afe4:	9a e0       	ldi	r25, 0x0A	; 10
    afe6:	14 96       	adiw	r26, 0x04	; 4
    afe8:	9c 93       	st	X, r25
    afea:	8e 93       	st	-X, r24
    afec:	13 97       	sbiw	r26, 0x03	; 3
    afee:	0c c0       	rjmp	.+24     	; 0xb008 <PrintIdle+0x194>
		      }
          else{           sprintf_P(strPrint,PSTR(" "));
    aff0:	00 d0       	rcall	.+0      	; 0xaff2 <PrintIdle+0x17e>
    aff2:	00 d0       	rcall	.+0      	; 0xaff4 <PrintIdle+0x180>
    aff4:	85 e9       	ldi	r24, 0x95	; 149
    aff6:	92 e0       	ldi	r25, 0x02	; 2
    aff8:	ed b7       	in	r30, 0x3d	; 61
    affa:	fe b7       	in	r31, 0x3e	; 62
    affc:	92 83       	std	Z+2, r25	; 0x02
    affe:	81 83       	std	Z+1, r24	; 0x01
    b000:	88 e0       	ldi	r24, 0x08	; 8
    b002:	9a e0       	ldi	r25, 0x0A	; 10
    b004:	94 83       	std	Z+4, r25	; 0x04
    b006:	83 83       	std	Z+3, r24	; 0x03
    b008:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    b00c:	0f 90       	pop	r0
    b00e:	0f 90       	pop	r0
    b010:	0f 90       	pop	r0
    b012:	0f 90       	pop	r0
		      }
		  iSend=0;
    b014:	10 92 91 02 	sts	0x0291, r1
    b018:	10 92 90 02 	sts	0x0290, r1
		  iLoop=0;
    b01c:	10 92 8d 02 	sts	0x028D, r1
    b020:	10 92 8c 02 	sts	0x028C, r1
		  LSend=strlen(strPrint);
    b024:	e5 e9       	ldi	r30, 0x95	; 149
    b026:	f2 e0       	ldi	r31, 0x02	; 2
    b028:	01 90       	ld	r0, Z+
    b02a:	00 20       	and	r0, r0
    b02c:	e9 f7       	brne	.-6      	; 0xb028 <PrintIdle+0x1b4>
    b02e:	31 97       	sbiw	r30, 0x01	; 1
    b030:	e5 59       	subi	r30, 0x95	; 149
    b032:	f2 40       	sbci	r31, 0x02	; 2
    b034:	f0 93 8f 02 	sts	0x028F, r31
    b038:	e0 93 8e 02 	sts	0x028E, r30
          stPrintIdle=piPrintDuplicate; 
    b03c:	85 e0       	ldi	r24, 0x05	; 5
    b03e:	12 c6       	rjmp	.+3108   	; 0xbc64 <PrintIdle+0xdf0>
	      break;
     case piPrintDuplicate:
		  if (iSend<LSend){
    b040:	20 91 90 02 	lds	r18, 0x0290
    b044:	30 91 91 02 	lds	r19, 0x0291
    b048:	80 91 8e 02 	lds	r24, 0x028E
    b04c:	90 91 8f 02 	lds	r25, 0x028F
    b050:	28 17       	cp	r18, r24
    b052:	39 07       	cpc	r19, r25
    b054:	78 f4       	brcc	.+30     	; 0xb074 <PrintIdle+0x200>
		      iLoop++;
    b056:	80 91 8c 02 	lds	r24, 0x028C
    b05a:	90 91 8d 02 	lds	r25, 0x028D
    b05e:	01 96       	adiw	r24, 0x01	; 1
    b060:	90 93 8d 02 	sts	0x028D, r25
    b064:	80 93 8c 02 	sts	0x028C, r24
			  if((iLoop%PRINT_DELAY)==0){
				 TimPrintBusy=0;
    b068:	10 92 cd 01 	sts	0x01CD, r1
    b06c:	10 92 cc 01 	sts	0x01CC, r1
                 stPrintIdle=piCheckPrintStatusDuplicate;
    b070:	86 e0       	ldi	r24, 0x06	; 6
    b072:	f8 c5       	rjmp	.+3056   	; 0xbc64 <PrintIdle+0xdf0>
				 }
			  }
          else {
		     iSend=0;
    b074:	10 92 91 02 	sts	0x0291, r1
    b078:	10 92 90 02 	sts	0x0290, r1
		     stPrintIdle=piInitMessage;
    b07c:	87 e0       	ldi	r24, 0x07	; 7
    b07e:	f2 c5       	rjmp	.+3044   	; 0xbc64 <PrintIdle+0xdf0>
			 }
	      break;
     case piCheckPrintStatusDuplicate:
	      if (IsBusyPrint==False){
    b080:	80 91 c9 01 	lds	r24, 0x01C9
    b084:	88 23       	and	r24, r24
    b086:	09 f0       	breq	.+2      	; 0xb08a <PrintIdle+0x216>
    b088:	e3 c5       	rjmp	.+3014   	; 0xbc50 <PrintIdle+0xddc>
		      _uart(_COM_PRINTER,1,strPrint[iSend]);
    b08a:	e0 91 90 02 	lds	r30, 0x0290
    b08e:	f0 91 91 02 	lds	r31, 0x0291
    b092:	eb 56       	subi	r30, 0x6B	; 107
    b094:	fd 4f       	sbci	r31, 0xFD	; 253
    b096:	61 e0       	ldi	r22, 0x01	; 1
    b098:	40 81       	ld	r20, Z
    b09a:	0e 94 d5 b3 	call	0x167aa	; 0x167aa <_uart>
    b09e:	84 ec       	ldi	r24, 0xC4	; 196
    b0a0:	99 e0       	ldi	r25, 0x09	; 9
    b0a2:	01 97       	sbiw	r24, 0x01	; 1
    b0a4:	f1 f7       	brne	.-4      	; 0xb0a2 <PrintIdle+0x22e>
			  _delay_ms(10);
		      iSend++;
    b0a6:	80 91 90 02 	lds	r24, 0x0290
    b0aa:	90 91 91 02 	lds	r25, 0x0291
    b0ae:	01 96       	adiw	r24, 0x01	; 1
    b0b0:	90 93 91 02 	sts	0x0291, r25
    b0b4:	80 93 90 02 	sts	0x0290, r24
		      stPrintIdle=piPrintDuplicate;
    b0b8:	85 e0       	ldi	r24, 0x05	; 5
    b0ba:	c8 c5       	rjmp	.+2960   	; 0xbc4c <PrintIdle+0xdd8>
		      stPrintIdle=piFinishPrintIdle;
			  }
	      break;

     case piInitMessage:
	      iSend=0;iLoop=0;
    b0bc:	10 92 91 02 	sts	0x0291, r1
    b0c0:	10 92 90 02 	sts	0x0290, r1
    b0c4:	10 92 8d 02 	sts	0x028D, r1
    b0c8:	10 92 8c 02 	sts	0x028C, r1
		  iMessage=0;
    b0cc:	10 92 94 02 	sts	0x0294, r1
		  switch(MOPType){
    b0d0:	80 91 cf 01 	lds	r24, 0x01CF
    b0d4:	83 30       	cpi	r24, 0x03	; 3
    b0d6:	81 f0       	breq	.+32     	; 0xb0f8 <PrintIdle+0x284>
    b0d8:	84 30       	cpi	r24, 0x04	; 4
    b0da:	28 f4       	brcc	.+10     	; 0xb0e6 <PrintIdle+0x272>
    b0dc:	81 30       	cpi	r24, 0x01	; 1
    b0de:	61 f0       	breq	.+24     	; 0xb0f8 <PrintIdle+0x284>
    b0e0:	82 30       	cpi	r24, 0x02	; 2
    b0e2:	40 f4       	brcc	.+16     	; 0xb0f4 <PrintIdle+0x280>
    b0e4:	10 c0       	rjmp	.+32     	; 0xb106 <PrintIdle+0x292>
    b0e6:	88 30       	cpi	r24, 0x08	; 8
    b0e8:	49 f0       	breq	.+18     	; 0xb0fc <PrintIdle+0x288>
    b0ea:	89 30       	cpi	r24, 0x09	; 9
    b0ec:	61 f0       	breq	.+24     	; 0xb106 <PrintIdle+0x292>
    b0ee:	87 30       	cpi	r24, 0x07	; 7
    b0f0:	51 f4       	brne	.+20     	; 0xb106 <PrintIdle+0x292>
    b0f2:	02 c0       	rjmp	.+4      	; 0xb0f8 <PrintIdle+0x284>
		  case MOP_CASH:
		       MessageLine=10;
			   PrintCopy=1;
		       break;
          case MOP_CREDIT_CARD:
		       MessageLine=10;
    b0f4:	8a e0       	ldi	r24, 0x0A	; 10
    b0f6:	03 c0       	rjmp	.+6      	; 0xb0fe <PrintIdle+0x28a>
          case MOP_LOCAL_ACCOUNT:
		       MessageLine=20;
			   PrintCopy=2;
		       break;
          case MOP_VOUCHER:
		       MessageLine=20;
    b0f8:	84 e1       	ldi	r24, 0x14	; 20
    b0fa:	01 c0       	rjmp	.+2      	; 0xb0fe <PrintIdle+0x28a>
			   PrintCopy=2;
		       break;
          case MOP_PUMP_TEST:
		       MessageLine=12;
    b0fc:	8c e0       	ldi	r24, 0x0C	; 12
    b0fe:	80 93 93 02 	sts	0x0293, r24
			   PrintCopy=2;
    b102:	82 e0       	ldi	r24, 0x02	; 2
    b104:	04 c0       	rjmp	.+8      	; 0xb10e <PrintIdle+0x29a>
          case MOP_VOID_CARD:
		       MessageLine=10;
			   PrintCopy=1;
		       break;          
          default:
		       MessageLine=10;
    b106:	8a e0       	ldi	r24, 0x0A	; 10
    b108:	80 93 93 02 	sts	0x0293, r24
			   PrintCopy=1;
    b10c:	81 e0       	ldi	r24, 0x01	; 1
    b10e:	80 93 8a 02 	sts	0x028A, r24
		       break; 
		  }
		  //LoyaltyDetection
          if ((strlen(strLoyCardID)>0)&&(SpaceOnly(strLoyCardID)==False)){
    b112:	80 91 c7 04 	lds	r24, 0x04C7
    b116:	88 23       	and	r24, r24
    b118:	49 f0       	breq	.+18     	; 0xb12c <PrintIdle+0x2b8>
    b11a:	87 ec       	ldi	r24, 0xC7	; 199
    b11c:	94 e0       	ldi	r25, 0x04	; 4
    b11e:	0e 94 94 24 	call	0x4928	; 0x4928 <SpaceOnly>
    b122:	88 23       	and	r24, r24
    b124:	19 f4       	brne	.+6      	; 0xb12c <PrintIdle+0x2b8>
		       MessageLine=33;
    b126:	81 e2       	ldi	r24, 0x21	; 33
    b128:	80 93 93 02 	sts	0x0293, r24
		  }
          //stPrintIdle=piLoadMessage;
		  stPrintIdle=piFormatingMessage;
    b12c:	88 e0       	ldi	r24, 0x08	; 8
    b12e:	9a c5       	rjmp	.+2868   	; 0xbc64 <PrintIdle+0xdf0>
	      break;
     case piFormatingMessage:
	      if (iPrinted==0){
    b130:	80 91 8b 02 	lds	r24, 0x028B
    b134:	88 23       	and	r24, r24
    b136:	09 f0       	breq	.+2      	; 0xb13a <PrintIdle+0x2c6>
    b138:	c8 c4       	rjmp	.+2448   	; 0xbaca <PrintIdle+0xc56>

		      FormatDate(DATE_LONG_YEAR,strDate);
    b13a:	61 e5       	ldi	r22, 0x51	; 81
    b13c:	79 e0       	ldi	r23, 0x09	; 9
    b13e:	0e 94 68 25 	call	0x4ad0	; 0x4ad0 <FormatDate>
              RemZeroLead(strIslandID);
    b142:	8f ec       	ldi	r24, 0xCF	; 207
    b144:	9a e0       	ldi	r25, 0x0A	; 10
    b146:	0e 94 b9 25 	call	0x4b72	; 0x4b72 <RemZeroLead>
			  RemZeroLead(strFIP_ID);
    b14a:	8c e9       	ldi	r24, 0x9C	; 156
    b14c:	99 e0       	ldi	r25, 0x09	; 9
    b14e:	0e 94 b9 25 	call	0x4b72	; 0x4b72 <RemZeroLead>
		      RemZeroLead(strPrice);              
    b152:	81 e8       	ldi	r24, 0x81	; 129
    b154:	97 e0       	ldi	r25, 0x07	; 7
    b156:	0e 94 b9 25 	call	0x4b72	; 0x4b72 <RemZeroLead>
              if (IFType==IT_SLAVE)
    b15a:	80 91 10 01 	lds	r24, 0x0110
    b15e:	81 30       	cpi	r24, 0x01	; 1
    b160:	21 f4       	brne	.+8      	; 0xb16a <PrintIdle+0x2f6>
			      RemZeroLead(strVolume);
    b162:	85 e5       	ldi	r24, 0x55	; 85
    b164:	95 e0       	ldi	r25, 0x05	; 5
    b166:	0e 94 b9 25 	call	0x4b72	; 0x4b72 <RemZeroLead>
              RemZeroLead(strAmount);
    b16a:	8b e8       	ldi	r24, 0x8B	; 139
    b16c:	9d e0       	ldi	r25, 0x0D	; 13
    b16e:	0e 94 b9 25 	call	0x4b72	; 0x4b72 <RemZeroLead>

			  RemDecimal(strPrice);
    b172:	81 e8       	ldi	r24, 0x81	; 129
    b174:	97 e0       	ldi	r25, 0x07	; 7
    b176:	0e 94 b1 24 	call	0x4962	; 0x4962 <RemDecimal>
			  RemDecimal(strAmount);
    b17a:	8b e8       	ldi	r24, 0x8B	; 139
    b17c:	9d e0       	ldi	r25, 0x0D	; 13
    b17e:	0e 94 b1 24 	call	0x4962	; 0x4962 <RemDecimal>
	  
			  FormatCurrency(strPrice);
    b182:	81 e8       	ldi	r24, 0x81	; 129
    b184:	97 e0       	ldi	r25, 0x07	; 7
    b186:	0e 94 b1 33 	call	0x6762	; 0x6762 <FormatCurrency>
			  FormatCurrency(strAmount);
    b18a:	8b e8       	ldi	r24, 0x8B	; 139
    b18c:	9d e0       	ldi	r25, 0x0D	; 13
    b18e:	0e 94 b1 33 	call	0x6762	; 0x6762 <FormatCurrency>
              if (IFType==IT_SLAVE){
    b192:	80 91 10 01 	lds	r24, 0x0110
    b196:	81 30       	cpi	r24, 0x01	; 1
    b198:	09 f0       	breq	.+2      	; 0xb19c <PrintIdle+0x328>
    b19a:	97 c4       	rjmp	.+2350   	; 0xbaca <PrintIdle+0xc56>
		          RemSpaceLag(strCardID);
    b19c:	81 e6       	ldi	r24, 0x61	; 97
    b19e:	9d e0       	ldi	r25, 0x0D	; 13
    b1a0:	0e 94 4c 26 	call	0x4c98	; 0x4c98 <RemSpaceLag>
		          RemSpaceLag(strCardHolder);
    b1a4:	84 e0       	ldi	r24, 0x04	; 4
    b1a6:	95 e0       	ldi	r25, 0x05	; 5
    b1a8:	0e 94 4c 26 	call	0x4c98	; 0x4c98 <RemSpaceLag>
		          RemSpaceLag(strMOPName);
    b1ac:	80 e6       	ldi	r24, 0x60	; 96
    b1ae:	97 e0       	ldi	r25, 0x07	; 7
    b1b0:	0e 94 4c 26 	call	0x4c98	; 0x4c98 <RemSpaceLag>
		          RemSpaceLag(strLoyCardHolder);
    b1b4:	84 ea       	ldi	r24, 0xA4	; 164
    b1b6:	94 e0       	ldi	r25, 0x04	; 4
    b1b8:	0e 94 4c 26 	call	0x4c98	; 0x4c98 <RemSpaceLag>
		          RemSpaceLag(strCorporateID);
    b1bc:	85 ee       	ldi	r24, 0xE5	; 229
    b1be:	9d e0       	ldi	r25, 0x0D	; 13
    b1c0:	0e 94 4c 26 	call	0x4c98	; 0x4c98 <RemSpaceLag>
		          RemSpaceLag(strCorporateName);
    b1c4:	8d ea       	ldi	r24, 0xAD	; 173
    b1c6:	95 e0       	ldi	r25, 0x05	; 5
    b1c8:	0e 94 4c 26 	call	0x4c98	; 0x4c98 <RemSpaceLag>
		          RemSpaceLag(strLoyRedeemPoints);
    b1cc:	8a e7       	ldi	r24, 0x7A	; 122
    b1ce:	95 e0       	ldi	r25, 0x05	; 5
    b1d0:	0e 94 4c 26 	call	0x4c98	; 0x4c98 <RemSpaceLag>
		          RemSpaceLag(strLoyCurrMonConsumeV);
    b1d4:	88 ec       	ldi	r24, 0xC8	; 200
    b1d6:	9d e0       	ldi	r25, 0x0D	; 13
    b1d8:	0e 94 4c 26 	call	0x4c98	; 0x4c98 <RemSpaceLag>
				  RemSpaceLag(strLoyCurrMonConsumeA);
    b1dc:	8e e5       	ldi	r24, 0x5E	; 94
    b1de:	95 e0       	ldi	r25, 0x05	; 5
    b1e0:	0e 94 4c 26 	call	0x4c98	; 0x4c98 <RemSpaceLag>
		          FormatCurrency(strLoyCurrMonConsumeV);              
    b1e4:	88 ec       	ldi	r24, 0xC8	; 200
    b1e6:	9d e0       	ldi	r25, 0x0D	; 13
    b1e8:	0e 94 b1 33 	call	0x6762	; 0x6762 <FormatCurrency>
		          FormatCurrency(strLoyCurrMonConsumeA);
    b1ec:	8e e5       	ldi	r24, 0x5E	; 94
    b1ee:	95 e0       	ldi	r25, 0x05	; 5
    b1f0:	0e 94 b1 33 	call	0x6762	; 0x6762 <FormatCurrency>
    b1f4:	6a c4       	rjmp	.+2260   	; 0xbaca <PrintIdle+0xc56>
			   }
		  }
          stPrintIdle=piLoadMessage;
	      break;
     case piLoadMessage:
	      switch(iMessage){
    b1f6:	80 91 94 02 	lds	r24, 0x0294
    b1fa:	e8 2f       	mov	r30, r24
    b1fc:	f0 e0       	ldi	r31, 0x00	; 0
    b1fe:	e5 32       	cpi	r30, 0x25	; 37
    b200:	f1 05       	cpc	r31, r1
    b202:	08 f0       	brcs	.+2      	; 0xb206 <PrintIdle+0x392>
    b204:	26 c4       	rjmp	.+2124   	; 0xba52 <PrintIdle+0xbde>
    b206:	e2 57       	subi	r30, 0x72	; 114
    b208:	ff 4f       	sbci	r31, 0xFF	; 255
    b20a:	ee 0f       	add	r30, r30
    b20c:	ff 1f       	adc	r31, r31
    b20e:	05 90       	lpm	r0, Z+
    b210:	f4 91       	lpm	r31, Z+
    b212:	e0 2d       	mov	r30, r0
    b214:	09 94       	ijmp
		  case 0:
		       CarriegeReturn();
    b216:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("      Shift: %s  No.Trans: %s "),strShift,strTranNo);
    b21a:	8d b7       	in	r24, 0x3d	; 61
    b21c:	9e b7       	in	r25, 0x3e	; 62
    b21e:	08 97       	sbiw	r24, 0x08	; 8
    b220:	0f b6       	in	r0, 0x3f	; 63
    b222:	f8 94       	cli
    b224:	9e bf       	out	0x3e, r25	; 62
    b226:	0f be       	out	0x3f, r0	; 63
    b228:	8d bf       	out	0x3d, r24	; 61
    b22a:	ed b7       	in	r30, 0x3d	; 61
    b22c:	fe b7       	in	r31, 0x3e	; 62
    b22e:	31 96       	adiw	r30, 0x01	; 1
    b230:	85 e9       	ldi	r24, 0x95	; 149
    b232:	92 e0       	ldi	r25, 0x02	; 2
    b234:	ad b7       	in	r26, 0x3d	; 61
    b236:	be b7       	in	r27, 0x3e	; 62
    b238:	12 96       	adiw	r26, 0x02	; 2
    b23a:	9c 93       	st	X, r25
    b23c:	8e 93       	st	-X, r24
    b23e:	11 97       	sbiw	r26, 0x01	; 1
    b240:	89 ee       	ldi	r24, 0xE9	; 233
    b242:	99 e0       	ldi	r25, 0x09	; 9
    b244:	93 83       	std	Z+3, r25	; 0x03
    b246:	82 83       	std	Z+2, r24	; 0x02
    b248:	83 e4       	ldi	r24, 0x43	; 67
    b24a:	9e e0       	ldi	r25, 0x0E	; 14
    b24c:	95 83       	std	Z+5, r25	; 0x05
    b24e:	84 83       	std	Z+4, r24	; 0x04
    b250:	81 e6       	ldi	r24, 0x61	; 97
    b252:	9e e0       	ldi	r25, 0x0E	; 14
    b254:	1f c0       	rjmp	.+62     	; 0xb294 <PrintIdle+0x420>
		       break;
		  case 1:
		       //FormatDate(strDate);
			   CarriegeReturn();
    b256:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("      Waktu: %s %s "),strDate,strTime);
    b25a:	8d b7       	in	r24, 0x3d	; 61
    b25c:	9e b7       	in	r25, 0x3e	; 62
    b25e:	08 97       	sbiw	r24, 0x08	; 8
    b260:	0f b6       	in	r0, 0x3f	; 63
    b262:	f8 94       	cli
    b264:	9e bf       	out	0x3e, r25	; 62
    b266:	0f be       	out	0x3f, r0	; 63
    b268:	8d bf       	out	0x3d, r24	; 61
    b26a:	ed b7       	in	r30, 0x3d	; 61
    b26c:	fe b7       	in	r31, 0x3e	; 62
    b26e:	31 96       	adiw	r30, 0x01	; 1
    b270:	85 e9       	ldi	r24, 0x95	; 149
    b272:	92 e0       	ldi	r25, 0x02	; 2
    b274:	ad b7       	in	r26, 0x3d	; 61
    b276:	be b7       	in	r27, 0x3e	; 62
    b278:	12 96       	adiw	r26, 0x02	; 2
    b27a:	9c 93       	st	X, r25
    b27c:	8e 93       	st	-X, r24
    b27e:	11 97       	sbiw	r26, 0x01	; 1
    b280:	85 ed       	ldi	r24, 0xD5	; 213
    b282:	99 e0       	ldi	r25, 0x09	; 9
    b284:	93 83       	std	Z+3, r25	; 0x03
    b286:	82 83       	std	Z+2, r24	; 0x02
    b288:	81 e5       	ldi	r24, 0x51	; 81
    b28a:	99 e0       	ldi	r25, 0x09	; 9
    b28c:	95 83       	std	Z+5, r25	; 0x05
    b28e:	84 83       	std	Z+4, r24	; 0x04
    b290:	8d e2       	ldi	r24, 0x2D	; 45
    b292:	95 e0       	ldi	r25, 0x05	; 5
    b294:	97 83       	std	Z+7, r25	; 0x07
    b296:	86 83       	std	Z+6, r24	; 0x06
    b298:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    b29c:	ed b7       	in	r30, 0x3d	; 61
    b29e:	fe b7       	in	r31, 0x3e	; 62
    b2a0:	38 96       	adiw	r30, 0x08	; 8
    b2a2:	b9 c3       	rjmp	.+1906   	; 0xba16 <PrintIdle+0xba2>
		       break;
		  case 2:
		       CarriegeReturn();
    b2a4:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("    ------------------------------"));
    b2a8:	00 d0       	rcall	.+0      	; 0xb2aa <PrintIdle+0x436>
    b2aa:	00 d0       	rcall	.+0      	; 0xb2ac <PrintIdle+0x438>
    b2ac:	85 e9       	ldi	r24, 0x95	; 149
    b2ae:	92 e0       	ldi	r25, 0x02	; 2
    b2b0:	ad b7       	in	r26, 0x3d	; 61
    b2b2:	be b7       	in	r27, 0x3e	; 62
    b2b4:	12 96       	adiw	r26, 0x02	; 2
    b2b6:	9c 93       	st	X, r25
    b2b8:	8e 93       	st	-X, r24
    b2ba:	11 97       	sbiw	r26, 0x01	; 1
    b2bc:	82 eb       	ldi	r24, 0xB2	; 178
    b2be:	99 e0       	ldi	r25, 0x09	; 9
    b2c0:	be c3       	rjmp	.+1916   	; 0xba3e <PrintIdle+0xbca>
		       break;
		  case 3:
		       CarriegeReturn();
    b2c2:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <CarriegeReturn>
			   //RemZeroLead(strIslandID);
			   //RemZeroLead(strFIP_ID);
		       sprintf_P(strPrint,PSTR("      Pulau/Pompa : [%s]-%s"),strIslandID,strFIP_ID);
    b2c6:	ed b7       	in	r30, 0x3d	; 61
    b2c8:	fe b7       	in	r31, 0x3e	; 62
    b2ca:	38 97       	sbiw	r30, 0x08	; 8
    b2cc:	0f b6       	in	r0, 0x3f	; 63
    b2ce:	f8 94       	cli
    b2d0:	fe bf       	out	0x3e, r31	; 62
    b2d2:	0f be       	out	0x3f, r0	; 63
    b2d4:	ed bf       	out	0x3d, r30	; 61
    b2d6:	31 96       	adiw	r30, 0x01	; 1
    b2d8:	85 e9       	ldi	r24, 0x95	; 149
    b2da:	92 e0       	ldi	r25, 0x02	; 2
    b2dc:	ad b7       	in	r26, 0x3d	; 61
    b2de:	be b7       	in	r27, 0x3e	; 62
    b2e0:	12 96       	adiw	r26, 0x02	; 2
    b2e2:	9c 93       	st	X, r25
    b2e4:	8e 93       	st	-X, r24
    b2e6:	11 97       	sbiw	r26, 0x01	; 1
    b2e8:	86 e9       	ldi	r24, 0x96	; 150
    b2ea:	99 e0       	ldi	r25, 0x09	; 9
    b2ec:	93 83       	std	Z+3, r25	; 0x03
    b2ee:	82 83       	std	Z+2, r24	; 0x02
    b2f0:	8f ec       	ldi	r24, 0xCF	; 207
    b2f2:	9a e0       	ldi	r25, 0x0A	; 10
    b2f4:	95 83       	std	Z+5, r25	; 0x05
    b2f6:	84 83       	std	Z+4, r24	; 0x04
    b2f8:	8c e9       	ldi	r24, 0x9C	; 156
    b2fa:	99 e0       	ldi	r25, 0x09	; 9
    b2fc:	cb cf       	rjmp	.-106    	; 0xb294 <PrintIdle+0x420>
		       break;
		  case 4:
		       CarriegeReturn();
    b2fe:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <CarriegeReturn>
			   sprintf_P(strPrint,PSTR("      Produk      : %s"),strDescription);
    b302:	00 d0       	rcall	.+0      	; 0xb304 <PrintIdle+0x490>
    b304:	00 d0       	rcall	.+0      	; 0xb306 <PrintIdle+0x492>
    b306:	00 d0       	rcall	.+0      	; 0xb308 <PrintIdle+0x494>
    b308:	ed b7       	in	r30, 0x3d	; 61
    b30a:	fe b7       	in	r31, 0x3e	; 62
    b30c:	31 96       	adiw	r30, 0x01	; 1
    b30e:	85 e9       	ldi	r24, 0x95	; 149
    b310:	92 e0       	ldi	r25, 0x02	; 2
    b312:	ad b7       	in	r26, 0x3d	; 61
    b314:	be b7       	in	r27, 0x3e	; 62
    b316:	12 96       	adiw	r26, 0x02	; 2
    b318:	9c 93       	st	X, r25
    b31a:	8e 93       	st	-X, r24
    b31c:	11 97       	sbiw	r26, 0x01	; 1
    b31e:	8f e7       	ldi	r24, 0x7F	; 127
    b320:	99 e0       	ldi	r25, 0x09	; 9
    b322:	93 83       	std	Z+3, r25	; 0x03
    b324:	82 83       	std	Z+2, r24	; 0x02
    b326:	81 e1       	ldi	r24, 0x11	; 17
    b328:	9a e0       	ldi	r25, 0x0A	; 10
    b32a:	6e c3       	rjmp	.+1756   	; 0xba08 <PrintIdle+0xb94>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    b32c:	e1 99       	sbic	0x1c, 1	; 28
    b32e:	fe cf       	rjmp	.-4      	; 0xb32c <PrintIdle+0x4b8>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    b330:	81 ec       	ldi	r24, 0xC1	; 193
    b332:	93 e0       	ldi	r25, 0x03	; 3
    b334:	9f bb       	out	0x1f, r25	; 31
    b336:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    b338:	e0 9a       	sbi	0x1c, 0	; 28
    b33a:	8d b3       	in	r24, 0x1d	; 29
    b33c:	c5 e9       	ldi	r28, 0x95	; 149
    b33e:	d2 e0       	ldi	r29, 0x02	; 2
		       break;
		  case 5:
		       //RemZeroLead(strPrice);
               //FormatCurrency(strPrice);
               if (eeprom_read_byte(&DefPrintMoney)==True){
    b340:	81 30       	cpi	r24, 0x01	; 1
    b342:	a9 f4       	brne	.+42     	; 0xb36e <PrintIdle+0x4fa>
			   	   CarriegeReturn();
    b344:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("      Harga/L     : Rp.%s"),strPrice);
    b348:	00 d0       	rcall	.+0      	; 0xb34a <PrintIdle+0x4d6>
    b34a:	00 d0       	rcall	.+0      	; 0xb34c <PrintIdle+0x4d8>
    b34c:	00 d0       	rcall	.+0      	; 0xb34e <PrintIdle+0x4da>
    b34e:	ed b7       	in	r30, 0x3d	; 61
    b350:	fe b7       	in	r31, 0x3e	; 62
    b352:	31 96       	adiw	r30, 0x01	; 1
    b354:	ad b7       	in	r26, 0x3d	; 61
    b356:	be b7       	in	r27, 0x3e	; 62
    b358:	12 96       	adiw	r26, 0x02	; 2
    b35a:	dc 93       	st	X, r29
    b35c:	ce 93       	st	-X, r28
    b35e:	11 97       	sbiw	r26, 0x01	; 1
    b360:	85 e6       	ldi	r24, 0x65	; 101
    b362:	99 e0       	ldi	r25, 0x09	; 9
    b364:	93 83       	std	Z+3, r25	; 0x03
    b366:	82 83       	std	Z+2, r24	; 0x02
    b368:	81 e8       	ldi	r24, 0x81	; 129
    b36a:	97 e0       	ldi	r25, 0x07	; 7
    b36c:	4d c3       	rjmp	.+1690   	; 0xba08 <PrintIdle+0xb94>
			   }else sprintf_P(strPrint,PSTR(""));
    b36e:	00 d0       	rcall	.+0      	; 0xb370 <PrintIdle+0x4fc>
    b370:	00 d0       	rcall	.+0      	; 0xb372 <PrintIdle+0x4fe>
    b372:	ad b7       	in	r26, 0x3d	; 61
    b374:	be b7       	in	r27, 0x3e	; 62
    b376:	12 96       	adiw	r26, 0x02	; 2
    b378:	dc 93       	st	X, r29
    b37a:	ce 93       	st	-X, r28
    b37c:	11 97       	sbiw	r26, 0x01	; 1
    b37e:	84 e6       	ldi	r24, 0x64	; 100
    b380:	99 e0       	ldi	r25, 0x09	; 9
    b382:	5d c3       	rjmp	.+1722   	; 0xba3e <PrintIdle+0xbca>

		       break;
		  case 6:
		       //RemZeroLead(strVolume);
		       CarriegeReturn();
    b384:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <CarriegeReturn>
			   sprintf_P(strPrint,PSTR("      Jml Liter   : %s L"),strVolume);
    b388:	00 d0       	rcall	.+0      	; 0xb38a <PrintIdle+0x516>
    b38a:	00 d0       	rcall	.+0      	; 0xb38c <PrintIdle+0x518>
    b38c:	00 d0       	rcall	.+0      	; 0xb38e <PrintIdle+0x51a>
    b38e:	ed b7       	in	r30, 0x3d	; 61
    b390:	fe b7       	in	r31, 0x3e	; 62
    b392:	31 96       	adiw	r30, 0x01	; 1
    b394:	85 e9       	ldi	r24, 0x95	; 149
    b396:	92 e0       	ldi	r25, 0x02	; 2
    b398:	ad b7       	in	r26, 0x3d	; 61
    b39a:	be b7       	in	r27, 0x3e	; 62
    b39c:	12 96       	adiw	r26, 0x02	; 2
    b39e:	9c 93       	st	X, r25
    b3a0:	8e 93       	st	-X, r24
    b3a2:	11 97       	sbiw	r26, 0x01	; 1
    b3a4:	8b e4       	ldi	r24, 0x4B	; 75
    b3a6:	99 e0       	ldi	r25, 0x09	; 9
    b3a8:	93 83       	std	Z+3, r25	; 0x03
    b3aa:	82 83       	std	Z+2, r24	; 0x02
    b3ac:	85 e5       	ldi	r24, 0x55	; 85
    b3ae:	95 e0       	ldi	r25, 0x05	; 5
    b3b0:	2b c3       	rjmp	.+1622   	; 0xba08 <PrintIdle+0xb94>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    b3b2:	e1 99       	sbic	0x1c, 1	; 28
    b3b4:	fe cf       	rjmp	.-4      	; 0xb3b2 <PrintIdle+0x53e>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    b3b6:	81 ec       	ldi	r24, 0xC1	; 193
    b3b8:	93 e0       	ldi	r25, 0x03	; 3
    b3ba:	9f bb       	out	0x1f, r25	; 31
    b3bc:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    b3be:	e0 9a       	sbi	0x1c, 0	; 28
    b3c0:	8d b3       	in	r24, 0x1d	; 29
    b3c2:	c5 e9       	ldi	r28, 0x95	; 149
    b3c4:	d2 e0       	ldi	r29, 0x02	; 2
		       break;
		  case 7:
		       //RemZeroLead(strAmount);		       
			   //FormatCurrency(strAmount);
               if (eeprom_read_byte(&DefPrintMoney)==True){
    b3c6:	81 30       	cpi	r24, 0x01	; 1
    b3c8:	a9 f4       	brne	.+42     	; 0xb3f4 <PrintIdle+0x580>
			   	   CarriegeReturn();
    b3ca:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("      Jml Rupiah  : Rp.%s"),strAmount);
    b3ce:	00 d0       	rcall	.+0      	; 0xb3d0 <PrintIdle+0x55c>
    b3d0:	00 d0       	rcall	.+0      	; 0xb3d2 <PrintIdle+0x55e>
    b3d2:	00 d0       	rcall	.+0      	; 0xb3d4 <PrintIdle+0x560>
    b3d4:	ed b7       	in	r30, 0x3d	; 61
    b3d6:	fe b7       	in	r31, 0x3e	; 62
    b3d8:	31 96       	adiw	r30, 0x01	; 1
    b3da:	ad b7       	in	r26, 0x3d	; 61
    b3dc:	be b7       	in	r27, 0x3e	; 62
    b3de:	12 96       	adiw	r26, 0x02	; 2
    b3e0:	dc 93       	st	X, r29
    b3e2:	ce 93       	st	-X, r28
    b3e4:	11 97       	sbiw	r26, 0x01	; 1
    b3e6:	81 e3       	ldi	r24, 0x31	; 49
    b3e8:	99 e0       	ldi	r25, 0x09	; 9
    b3ea:	93 83       	std	Z+3, r25	; 0x03
    b3ec:	82 83       	std	Z+2, r24	; 0x02
    b3ee:	8b e8       	ldi	r24, 0x8B	; 139
    b3f0:	9d e0       	ldi	r25, 0x0D	; 13
    b3f2:	0a c3       	rjmp	.+1556   	; 0xba08 <PrintIdle+0xb94>
			   }else sprintf_P(strPrint,PSTR(""));
    b3f4:	00 d0       	rcall	.+0      	; 0xb3f6 <PrintIdle+0x582>
    b3f6:	00 d0       	rcall	.+0      	; 0xb3f8 <PrintIdle+0x584>
    b3f8:	ad b7       	in	r26, 0x3d	; 61
    b3fa:	be b7       	in	r27, 0x3e	; 62
    b3fc:	12 96       	adiw	r26, 0x02	; 2
    b3fe:	dc 93       	st	X, r29
    b400:	ce 93       	st	-X, r28
    b402:	11 97       	sbiw	r26, 0x01	; 1
    b404:	80 e3       	ldi	r24, 0x30	; 48
    b406:	99 e0       	ldi	r25, 0x09	; 9
    b408:	1a c3       	rjmp	.+1588   	; 0xba3e <PrintIdle+0xbca>

		       break;
		  case 8:
		       if ((strlen(strLicPlate)>0)&&(SpaceOnly(strLicPlate)==False)){
    b40a:	c2 ed       	ldi	r28, 0xD2	; 210
    b40c:	da e0       	ldi	r29, 0x0A	; 10
    b40e:	80 91 d2 0a 	lds	r24, 0x0AD2
    b412:	88 23       	and	r24, r24
    b414:	09 f4       	brne	.+2      	; 0xb418 <PrintIdle+0x5a4>
    b416:	18 c2       	rjmp	.+1072   	; 0xb848 <PrintIdle+0x9d4>
    b418:	ce 01       	movw	r24, r28
    b41a:	0e 94 94 24 	call	0x4928	; 0x4928 <SpaceOnly>
    b41e:	88 23       	and	r24, r24
    b420:	09 f0       	breq	.+2      	; 0xb424 <PrintIdle+0x5b0>
    b422:	12 c2       	rjmp	.+1060   	; 0xb848 <PrintIdle+0x9d4>
			       CarriegeReturn();
    b424:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("      No.Polisi   : %s"),strLicPlate);
    b428:	00 d0       	rcall	.+0      	; 0xb42a <PrintIdle+0x5b6>
    b42a:	00 d0       	rcall	.+0      	; 0xb42c <PrintIdle+0x5b8>
    b42c:	00 d0       	rcall	.+0      	; 0xb42e <PrintIdle+0x5ba>
    b42e:	ed b7       	in	r30, 0x3d	; 61
    b430:	fe b7       	in	r31, 0x3e	; 62
    b432:	31 96       	adiw	r30, 0x01	; 1
    b434:	85 e9       	ldi	r24, 0x95	; 149
    b436:	92 e0       	ldi	r25, 0x02	; 2
    b438:	ad b7       	in	r26, 0x3d	; 61
    b43a:	be b7       	in	r27, 0x3e	; 62
    b43c:	12 96       	adiw	r26, 0x02	; 2
    b43e:	9c 93       	st	X, r25
    b440:	8e 93       	st	-X, r24
    b442:	11 97       	sbiw	r26, 0x01	; 1
    b444:	89 e1       	ldi	r24, 0x19	; 25
    b446:	99 e0       	ldi	r25, 0x09	; 9
    b448:	1f c0       	rjmp	.+62     	; 0xb488 <PrintIdle+0x614>
                   ClearMem(strLicPlate);
				   }
               else ClearMem(strPrint);
		       break;
		  case 9:
		       if ((strlen(strOdometer)>0)&&(SpaceOnly(strOdometer)==False)){
    b44a:	c3 ea       	ldi	r28, 0xA3	; 163
    b44c:	d5 e0       	ldi	r29, 0x05	; 5
    b44e:	80 91 a3 05 	lds	r24, 0x05A3
    b452:	88 23       	and	r24, r24
    b454:	09 f4       	brne	.+2      	; 0xb458 <PrintIdle+0x5e4>
    b456:	f8 c1       	rjmp	.+1008   	; 0xb848 <PrintIdle+0x9d4>
    b458:	ce 01       	movw	r24, r28
    b45a:	0e 94 94 24 	call	0x4928	; 0x4928 <SpaceOnly>
    b45e:	88 23       	and	r24, r24
    b460:	09 f0       	breq	.+2      	; 0xb464 <PrintIdle+0x5f0>
    b462:	f2 c1       	rjmp	.+996    	; 0xb848 <PrintIdle+0x9d4>
			       CarriegeReturn();
    b464:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <CarriegeReturn>
		           sprintf_P(strPrint,PSTR("      Odometer    : %s"),strOdometer);
    b468:	00 d0       	rcall	.+0      	; 0xb46a <PrintIdle+0x5f6>
    b46a:	00 d0       	rcall	.+0      	; 0xb46c <PrintIdle+0x5f8>
    b46c:	00 d0       	rcall	.+0      	; 0xb46e <PrintIdle+0x5fa>
    b46e:	ed b7       	in	r30, 0x3d	; 61
    b470:	fe b7       	in	r31, 0x3e	; 62
    b472:	31 96       	adiw	r30, 0x01	; 1
    b474:	85 e9       	ldi	r24, 0x95	; 149
    b476:	92 e0       	ldi	r25, 0x02	; 2
    b478:	ad b7       	in	r26, 0x3d	; 61
    b47a:	be b7       	in	r27, 0x3e	; 62
    b47c:	12 96       	adiw	r26, 0x02	; 2
    b47e:	9c 93       	st	X, r25
    b480:	8e 93       	st	-X, r24
    b482:	11 97       	sbiw	r26, 0x01	; 1
    b484:	82 e0       	ldi	r24, 0x02	; 2
    b486:	99 e0       	ldi	r25, 0x09	; 9
    b488:	93 83       	std	Z+3, r25	; 0x03
    b48a:	82 83       	std	Z+2, r24	; 0x02
    b48c:	d5 83       	std	Z+5, r29	; 0x05
    b48e:	c4 83       	std	Z+4, r28	; 0x04
    b490:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
				   ClearMem(strOdometer);
    b494:	ed b7       	in	r30, 0x3d	; 61
    b496:	fe b7       	in	r31, 0x3e	; 62
    b498:	36 96       	adiw	r30, 0x06	; 6
    b49a:	0f b6       	in	r0, 0x3f	; 63
    b49c:	f8 94       	cli
    b49e:	fe bf       	out	0x3e, r31	; 62
    b4a0:	0f be       	out	0x3f, r0	; 63
    b4a2:	ed bf       	out	0x3d, r30	; 61
    b4a4:	ce 01       	movw	r24, r28
    b4a6:	0e 94 01 af 	call	0x15e02	; 0x15e02 <ClearMem>
    b4aa:	d3 c2       	rjmp	.+1446   	; 0xba52 <PrintIdle+0xbde>
			   }else ClearMem(strPrint);
		       break;
		  case 10:
		       CarriegeReturn();
    b4ac:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("    ------------------------------"));
    b4b0:	00 d0       	rcall	.+0      	; 0xb4b2 <PrintIdle+0x63e>
    b4b2:	00 d0       	rcall	.+0      	; 0xb4b4 <PrintIdle+0x640>
    b4b4:	85 e9       	ldi	r24, 0x95	; 149
    b4b6:	92 e0       	ldi	r25, 0x02	; 2
    b4b8:	ad b7       	in	r26, 0x3d	; 61
    b4ba:	be b7       	in	r27, 0x3e	; 62
    b4bc:	12 96       	adiw	r26, 0x02	; 2
    b4be:	9c 93       	st	X, r25
    b4c0:	8e 93       	st	-X, r24
    b4c2:	11 97       	sbiw	r26, 0x01	; 1
    b4c4:	8f ed       	ldi	r24, 0xDF	; 223
    b4c6:	98 e0       	ldi	r25, 0x08	; 8
    b4c8:	ba c2       	rjmp	.+1396   	; 0xba3e <PrintIdle+0xbca>
		       break;
          //ChangeMOPPrint
		  case 11:
			   if ((MOPType==MOP_LOCAL_ACCOUNT)||(MOPType==MOP_DEBIT_CARD)||(MOPType==MOP_LOYALTY_LOCAL_ACCOUNT)){
    b4ca:	80 91 cf 01 	lds	r24, 0x01CF
    b4ce:	81 30       	cpi	r24, 0x01	; 1
    b4d0:	21 f0       	breq	.+8      	; 0xb4da <PrintIdle+0x666>
    b4d2:	83 30       	cpi	r24, 0x03	; 3
    b4d4:	11 f0       	breq	.+4      	; 0xb4da <PrintIdle+0x666>
    b4d6:	86 30       	cpi	r24, 0x06	; 6
    b4d8:	b9 f4       	brne	.+46     	; 0xb508 <PrintIdle+0x694>
			       //RemSpaceLag(strCardID);
				   CarriegeReturn();
    b4da:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("    Kartu ID : %s"),strCardID);
    b4de:	00 d0       	rcall	.+0      	; 0xb4e0 <PrintIdle+0x66c>
    b4e0:	00 d0       	rcall	.+0      	; 0xb4e2 <PrintIdle+0x66e>
    b4e2:	00 d0       	rcall	.+0      	; 0xb4e4 <PrintIdle+0x670>
    b4e4:	ed b7       	in	r30, 0x3d	; 61
    b4e6:	fe b7       	in	r31, 0x3e	; 62
    b4e8:	31 96       	adiw	r30, 0x01	; 1
    b4ea:	85 e9       	ldi	r24, 0x95	; 149
    b4ec:	92 e0       	ldi	r25, 0x02	; 2
    b4ee:	ad b7       	in	r26, 0x3d	; 61
    b4f0:	be b7       	in	r27, 0x3e	; 62
    b4f2:	12 96       	adiw	r26, 0x02	; 2
    b4f4:	9c 93       	st	X, r25
    b4f6:	8e 93       	st	-X, r24
    b4f8:	11 97       	sbiw	r26, 0x01	; 1
    b4fa:	8d ec       	ldi	r24, 0xCD	; 205
    b4fc:	98 e0       	ldi	r25, 0x08	; 8
    b4fe:	93 83       	std	Z+3, r25	; 0x03
    b500:	82 83       	std	Z+2, r24	; 0x02
    b502:	81 e6       	ldi	r24, 0x61	; 97
    b504:	9d e0       	ldi	r25, 0x0D	; 13
    b506:	18 c0       	rjmp	.+48     	; 0xb538 <PrintIdle+0x6c4>
				   IsSignedField=True;
				   }
	           else
			   if (MOPType==MOP_VOUCHER){
    b508:	87 30       	cpi	r24, 0x07	; 7
    b50a:	f1 f4       	brne	.+60     	; 0xb548 <PrintIdle+0x6d4>
			       //RemSpaceLag(strCardID);
				   CarriegeReturn();
    b50c:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("    Voucher No: %s"),strVoucherNum);
    b510:	00 d0       	rcall	.+0      	; 0xb512 <PrintIdle+0x69e>
    b512:	00 d0       	rcall	.+0      	; 0xb514 <PrintIdle+0x6a0>
    b514:	00 d0       	rcall	.+0      	; 0xb516 <PrintIdle+0x6a2>
    b516:	ed b7       	in	r30, 0x3d	; 61
    b518:	fe b7       	in	r31, 0x3e	; 62
    b51a:	31 96       	adiw	r30, 0x01	; 1
    b51c:	85 e9       	ldi	r24, 0x95	; 149
    b51e:	92 e0       	ldi	r25, 0x02	; 2
    b520:	ad b7       	in	r26, 0x3d	; 61
    b522:	be b7       	in	r27, 0x3e	; 62
    b524:	12 96       	adiw	r26, 0x02	; 2
    b526:	9c 93       	st	X, r25
    b528:	8e 93       	st	-X, r24
    b52a:	11 97       	sbiw	r26, 0x01	; 1
    b52c:	8a eb       	ldi	r24, 0xBA	; 186
    b52e:	98 e0       	ldi	r25, 0x08	; 8
    b530:	93 83       	std	Z+3, r25	; 0x03
    b532:	82 83       	std	Z+2, r24	; 0x02
    b534:	87 e1       	ldi	r24, 0x17	; 23
    b536:	9e e0       	ldi	r25, 0x0E	; 14
    b538:	95 83       	std	Z+5, r25	; 0x05
    b53a:	84 83       	std	Z+4, r24	; 0x04
    b53c:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
				   IsSignedField=True;
    b540:	81 e0       	ldi	r24, 0x01	; 1
    b542:	80 93 92 02 	sts	0x0292, r24
    b546:	64 c2       	rjmp	.+1224   	; 0xba10 <PrintIdle+0xb9c>
    b548:	c5 e9       	ldi	r28, 0x95	; 149
    b54a:	d2 e0       	ldi	r29, 0x02	; 2
				   }
			   else
			   if (MOPType==MOP_PUMP_TEST) {
    b54c:	88 30       	cpi	r24, 0x08	; 8
    b54e:	09 f0       	breq	.+2      	; 0xb552 <PrintIdle+0x6de>
    b550:	a9 cf       	rjmp	.-174    	; 0xb4a4 <PrintIdle+0x630>
			       CarriegeReturn();
    b552:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("          *** PUMP TEST ***       "));
    b556:	00 d0       	rcall	.+0      	; 0xb558 <PrintIdle+0x6e4>
    b558:	00 d0       	rcall	.+0      	; 0xb55a <PrintIdle+0x6e6>
    b55a:	ad b7       	in	r26, 0x3d	; 61
    b55c:	be b7       	in	r27, 0x3e	; 62
    b55e:	12 96       	adiw	r26, 0x02	; 2
    b560:	dc 93       	st	X, r29
    b562:	ce 93       	st	-X, r28
    b564:	11 97       	sbiw	r26, 0x01	; 1
    b566:	87 e9       	ldi	r24, 0x97	; 151
    b568:	98 e0       	ldi	r25, 0x08	; 8
    b56a:	14 96       	adiw	r26, 0x04	; 4
    b56c:	9c 93       	st	X, r25
    b56e:	8e 93       	st	-X, r24
    b570:	13 97       	sbiw	r26, 0x03	; 3
    b572:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
				   IsSignedField=False;
    b576:	10 92 92 02 	sts	0x0292, r1
    b57a:	67 c2       	rjmp	.+1230   	; 0xba4a <PrintIdle+0xbd6>
				   }
               else ClearMem(strPrint);
		       break;
          case 12:
			   if (MOPType==MOP_LOCAL_ACCOUNT) {
    b57c:	80 91 cf 01 	lds	r24, 0x01CF
    b580:	81 30       	cpi	r24, 0x01	; 1
    b582:	99 f4       	brne	.+38     	; 0xb5aa <PrintIdle+0x736>
			       //RemSpaceLag(strCardHolder);
				   CarriegeReturn();
    b584:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("    Nama     : %s"),strCardHolder);
    b588:	00 d0       	rcall	.+0      	; 0xb58a <PrintIdle+0x716>
    b58a:	00 d0       	rcall	.+0      	; 0xb58c <PrintIdle+0x718>
    b58c:	00 d0       	rcall	.+0      	; 0xb58e <PrintIdle+0x71a>
    b58e:	ed b7       	in	r30, 0x3d	; 61
    b590:	fe b7       	in	r31, 0x3e	; 62
    b592:	31 96       	adiw	r30, 0x01	; 1
    b594:	85 e9       	ldi	r24, 0x95	; 149
    b596:	92 e0       	ldi	r25, 0x02	; 2
    b598:	ad b7       	in	r26, 0x3d	; 61
    b59a:	be b7       	in	r27, 0x3e	; 62
    b59c:	12 96       	adiw	r26, 0x02	; 2
    b59e:	9c 93       	st	X, r25
    b5a0:	8e 93       	st	-X, r24
    b5a2:	11 97       	sbiw	r26, 0x01	; 1
    b5a4:	85 e8       	ldi	r24, 0x85	; 133
    b5a6:	98 e0       	ldi	r25, 0x08	; 8
    b5a8:	3a c0       	rjmp	.+116    	; 0xb61e <PrintIdle+0x7aa>
				   }
               else 
               if (MOPType==MOP_DEBIT_CARD) {//EDCApprovalCode
    b5aa:	83 30       	cpi	r24, 0x03	; 3
    b5ac:	e9 f5       	brne	.+122    	; 0xb628 <PrintIdle+0x7b4>
			       if (IsPrintApprovalCode==True){
    b5ae:	80 91 b1 01 	lds	r24, 0x01B1
    b5b2:	81 30       	cpi	r24, 0x01	; 1
    b5b4:	11 f5       	brne	.+68     	; 0xb5fa <PrintIdle+0x786>
				       IsPrintApprovalCode=False;
    b5b6:	10 92 b1 01 	sts	0x01B1, r1
					   FillChar(strCardHolder,0,sizeof(strCardHolder));
					   sprintf_P(strCardHolder,PSTR("%s  "),strApprovalCode);
    b5ba:	00 d0       	rcall	.+0      	; 0xb5bc <PrintIdle+0x748>
    b5bc:	00 d0       	rcall	.+0      	; 0xb5be <PrintIdle+0x74a>
    b5be:	00 d0       	rcall	.+0      	; 0xb5c0 <PrintIdle+0x74c>
    b5c0:	ed b7       	in	r30, 0x3d	; 61
    b5c2:	fe b7       	in	r31, 0x3e	; 62
    b5c4:	31 96       	adiw	r30, 0x01	; 1
    b5c6:	84 e0       	ldi	r24, 0x04	; 4
    b5c8:	95 e0       	ldi	r25, 0x05	; 5
    b5ca:	ad b7       	in	r26, 0x3d	; 61
    b5cc:	be b7       	in	r27, 0x3e	; 62
    b5ce:	12 96       	adiw	r26, 0x02	; 2
    b5d0:	9c 93       	st	X, r25
    b5d2:	8e 93       	st	-X, r24
    b5d4:	11 97       	sbiw	r26, 0x01	; 1
    b5d6:	80 e8       	ldi	r24, 0x80	; 128
    b5d8:	98 e0       	ldi	r25, 0x08	; 8
    b5da:	93 83       	std	Z+3, r25	; 0x03
    b5dc:	82 83       	std	Z+2, r24	; 0x02
    b5de:	84 ee       	ldi	r24, 0xE4	; 228
    b5e0:	99 e0       	ldi	r25, 0x09	; 9
    b5e2:	95 83       	std	Z+5, r25	; 0x05
    b5e4:	84 83       	std	Z+4, r24	; 0x04
    b5e6:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    b5ea:	ed b7       	in	r30, 0x3d	; 61
    b5ec:	fe b7       	in	r31, 0x3e	; 62
    b5ee:	36 96       	adiw	r30, 0x06	; 6
    b5f0:	0f b6       	in	r0, 0x3f	; 63
    b5f2:	f8 94       	cli
    b5f4:	fe bf       	out	0x3e, r31	; 62
    b5f6:	0f be       	out	0x3f, r0	; 63
    b5f8:	ed bf       	out	0x3d, r30	; 61
				   }
			       //RemSpaceLag(strCardHolder);
				   CarriegeReturn();
    b5fa:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("    Appr Code: %s"),strCardHolder);
    b5fe:	00 d0       	rcall	.+0      	; 0xb600 <PrintIdle+0x78c>
    b600:	00 d0       	rcall	.+0      	; 0xb602 <PrintIdle+0x78e>
    b602:	00 d0       	rcall	.+0      	; 0xb604 <PrintIdle+0x790>
    b604:	ed b7       	in	r30, 0x3d	; 61
    b606:	fe b7       	in	r31, 0x3e	; 62
    b608:	31 96       	adiw	r30, 0x01	; 1
    b60a:	85 e9       	ldi	r24, 0x95	; 149
    b60c:	92 e0       	ldi	r25, 0x02	; 2
    b60e:	ad b7       	in	r26, 0x3d	; 61
    b610:	be b7       	in	r27, 0x3e	; 62
    b612:	12 96       	adiw	r26, 0x02	; 2
    b614:	9c 93       	st	X, r25
    b616:	8e 93       	st	-X, r24
    b618:	11 97       	sbiw	r26, 0x01	; 1
    b61a:	8e e6       	ldi	r24, 0x6E	; 110
    b61c:	98 e0       	ldi	r25, 0x08	; 8
    b61e:	93 83       	std	Z+3, r25	; 0x03
    b620:	82 83       	std	Z+2, r24	; 0x02
    b622:	84 e0       	ldi	r24, 0x04	; 4
    b624:	95 e0       	ldi	r25, 0x05	; 5
    b626:	f0 c1       	rjmp	.+992    	; 0xba08 <PrintIdle+0xb94>
				   }
               else
			   if (MOPType==MOP_VOUCHER){
    b628:	87 30       	cpi	r24, 0x07	; 7
    b62a:	79 f4       	brne	.+30     	; 0xb64a <PrintIdle+0x7d6>
			       CarriegeReturn();
    b62c:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("  "));
    b630:	00 d0       	rcall	.+0      	; 0xb632 <PrintIdle+0x7be>
    b632:	00 d0       	rcall	.+0      	; 0xb634 <PrintIdle+0x7c0>
    b634:	85 e9       	ldi	r24, 0x95	; 149
    b636:	92 e0       	ldi	r25, 0x02	; 2
    b638:	ad b7       	in	r26, 0x3d	; 61
    b63a:	be b7       	in	r27, 0x3e	; 62
    b63c:	12 96       	adiw	r26, 0x02	; 2
    b63e:	9c 93       	st	X, r25
    b640:	8e 93       	st	-X, r24
    b642:	11 97       	sbiw	r26, 0x01	; 1
    b644:	8b e6       	ldi	r24, 0x6B	; 107
    b646:	98 e0       	ldi	r25, 0x08	; 8
    b648:	fa c1       	rjmp	.+1012   	; 0xba3e <PrintIdle+0xbca>
    b64a:	c5 e9       	ldi	r28, 0x95	; 149
    b64c:	d2 e0       	ldi	r29, 0x02	; 2
				   }
			   else
			   if (MOPType==MOP_PUMP_TEST) {
    b64e:	88 30       	cpi	r24, 0x08	; 8
    b650:	09 f0       	breq	.+2      	; 0xb654 <PrintIdle+0x7e0>
    b652:	28 cf       	rjmp	.-432    	; 0xb4a4 <PrintIdle+0x630>
			       CarriegeReturn();
    b654:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("                 "));
    b658:	00 d0       	rcall	.+0      	; 0xb65a <PrintIdle+0x7e6>
    b65a:	00 d0       	rcall	.+0      	; 0xb65c <PrintIdle+0x7e8>
    b65c:	ed b7       	in	r30, 0x3d	; 61
    b65e:	fe b7       	in	r31, 0x3e	; 62
    b660:	d2 83       	std	Z+2, r29	; 0x02
    b662:	c1 83       	std	Z+1, r28	; 0x01
    b664:	89 e5       	ldi	r24, 0x59	; 89
    b666:	98 e0       	ldi	r25, 0x08	; 8
    b668:	25 c0       	rjmp	.+74     	; 0xb6b4 <PrintIdle+0x840>
				   }
               else ClearMem(strPrint);
		       break;
          case 13:
		       if (IsSignedField==True){
    b66a:	80 91 92 02 	lds	r24, 0x0292
    b66e:	c5 e9       	ldi	r28, 0x95	; 149
    b670:	d2 e0       	ldi	r29, 0x02	; 2
    b672:	81 30       	cpi	r24, 0x01	; 1
    b674:	09 f0       	breq	.+2      	; 0xb678 <PrintIdle+0x804>
    b676:	16 cf       	rjmp	.-468    	; 0xb4a4 <PrintIdle+0x630>
			       CarriegeReturn();
    b678:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("                      "));
    b67c:	00 d0       	rcall	.+0      	; 0xb67e <PrintIdle+0x80a>
    b67e:	00 d0       	rcall	.+0      	; 0xb680 <PrintIdle+0x80c>
    b680:	ad b7       	in	r26, 0x3d	; 61
    b682:	be b7       	in	r27, 0x3e	; 62
    b684:	12 96       	adiw	r26, 0x02	; 2
    b686:	dc 93       	st	X, r29
    b688:	ce 93       	st	-X, r28
    b68a:	11 97       	sbiw	r26, 0x01	; 1
    b68c:	82 e4       	ldi	r24, 0x42	; 66
    b68e:	98 e0       	ldi	r25, 0x08	; 8
    b690:	d6 c1       	rjmp	.+940    	; 0xba3e <PrintIdle+0xbca>
               }else ClearMem(strPrint);
		       break;
          case 14:
		       if (IsSignedField==True){
    b692:	80 91 92 02 	lds	r24, 0x0292
    b696:	c5 e9       	ldi	r28, 0x95	; 149
    b698:	d2 e0       	ldi	r29, 0x02	; 2
    b69a:	81 30       	cpi	r24, 0x01	; 1
    b69c:	09 f0       	breq	.+2      	; 0xb6a0 <PrintIdle+0x82c>
    b69e:	02 cf       	rjmp	.-508    	; 0xb4a4 <PrintIdle+0x630>
			       CarriegeReturn();
    b6a0:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("                      "));
    b6a4:	00 d0       	rcall	.+0      	; 0xb6a6 <PrintIdle+0x832>
    b6a6:	00 d0       	rcall	.+0      	; 0xb6a8 <PrintIdle+0x834>
    b6a8:	ed b7       	in	r30, 0x3d	; 61
    b6aa:	fe b7       	in	r31, 0x3e	; 62
    b6ac:	d2 83       	std	Z+2, r29	; 0x02
    b6ae:	c1 83       	std	Z+1, r28	; 0x01
    b6b0:	8b e2       	ldi	r24, 0x2B	; 43
    b6b2:	98 e0       	ldi	r25, 0x08	; 8
    b6b4:	94 83       	std	Z+4, r25	; 0x04
    b6b6:	83 83       	std	Z+3, r24	; 0x03
    b6b8:	c6 c1       	rjmp	.+908    	; 0xba46 <PrintIdle+0xbd2>
			       //sprintf_P(strPrint,PSTR("                      "));
				   ClearMem(strPrint);
               }else ClearMem(strPrint);
		       break;
          case 17:
		       if (IsSignedField==True){
    b6ba:	80 91 92 02 	lds	r24, 0x0292
    b6be:	c5 e9       	ldi	r28, 0x95	; 149
    b6c0:	d2 e0       	ldi	r29, 0x02	; 2
    b6c2:	81 30       	cpi	r24, 0x01	; 1
    b6c4:	09 f0       	breq	.+2      	; 0xb6c8 <PrintIdle+0x854>
    b6c6:	ee ce       	rjmp	.-548    	; 0xb4a4 <PrintIdle+0x630>
			       CarriegeReturn();
    b6c8:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("    Tanda Tangan  (______________)"));
    b6cc:	00 d0       	rcall	.+0      	; 0xb6ce <PrintIdle+0x85a>
    b6ce:	00 d0       	rcall	.+0      	; 0xb6d0 <PrintIdle+0x85c>
    b6d0:	ad b7       	in	r26, 0x3d	; 61
    b6d2:	be b7       	in	r27, 0x3e	; 62
    b6d4:	12 96       	adiw	r26, 0x02	; 2
    b6d6:	dc 93       	st	X, r29
    b6d8:	ce 93       	st	-X, r28
    b6da:	11 97       	sbiw	r26, 0x01	; 1
    b6dc:	88 e0       	ldi	r24, 0x08	; 8
    b6de:	98 e0       	ldi	r25, 0x08	; 8
    b6e0:	ae c1       	rjmp	.+860    	; 0xba3e <PrintIdle+0xbca>
               }else ClearMem(strPrint);
		       break;
          case 18:
		       if (IsSignedField==True){
    b6e2:	80 91 92 02 	lds	r24, 0x0292
    b6e6:	81 30       	cpi	r24, 0x01	; 1
    b6e8:	09 f0       	breq	.+2      	; 0xb6ec <PrintIdle+0x878>
    b6ea:	ae c0       	rjmp	.+348    	; 0xb848 <PrintIdle+0x9d4>
			       IsSignedField=False;
    b6ec:	10 92 92 02 	sts	0x0292, r1
    b6f0:	ab c0       	rjmp	.+342    	; 0xb848 <PrintIdle+0x9d4>
			       //sprintf_P(strPrint,PSTR("                      "));
				   ClearMem(strPrint);
               }else ClearMem(strPrint);
		       break;
          case 19://PrintMOP Name
		       if (MOPType!=MOP_CASH){
    b6f2:	80 91 cf 01 	lds	r24, 0x01CF
    b6f6:	c5 e9       	ldi	r28, 0x95	; 149
    b6f8:	d2 e0       	ldi	r29, 0x02	; 2
    b6fa:	88 23       	and	r24, r24
    b6fc:	09 f4       	brne	.+2      	; 0xb700 <PrintIdle+0x88c>
    b6fe:	d2 ce       	rjmp	.-604    	; 0xb4a4 <PrintIdle+0x630>
			       CarriegeReturn();
    b700:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <CarriegeReturn>
			       //RemSpaceLag(strMOPName);
			       sprintf_P(strPrint,PSTR("    .%s"),strMOPName);
    b704:	00 d0       	rcall	.+0      	; 0xb706 <PrintIdle+0x892>
    b706:	00 d0       	rcall	.+0      	; 0xb708 <PrintIdle+0x894>
    b708:	00 d0       	rcall	.+0      	; 0xb70a <PrintIdle+0x896>
    b70a:	ed b7       	in	r30, 0x3d	; 61
    b70c:	fe b7       	in	r31, 0x3e	; 62
    b70e:	31 96       	adiw	r30, 0x01	; 1
    b710:	ad b7       	in	r26, 0x3d	; 61
    b712:	be b7       	in	r27, 0x3e	; 62
    b714:	12 96       	adiw	r26, 0x02	; 2
    b716:	dc 93       	st	X, r29
    b718:	ce 93       	st	-X, r28
    b71a:	11 97       	sbiw	r26, 0x01	; 1
    b71c:	80 e0       	ldi	r24, 0x00	; 0
    b71e:	98 e0       	ldi	r25, 0x08	; 8
    b720:	93 83       	std	Z+3, r25	; 0x03
    b722:	82 83       	std	Z+2, r24	; 0x02
    b724:	80 e6       	ldi	r24, 0x60	; 96
    b726:	97 e0       	ldi	r25, 0x07	; 7
    b728:	6f c1       	rjmp	.+734    	; 0xba08 <PrintIdle+0xb94>
			   }else ClearMem(strPrint);
		       break;
		  case 20:
		       if (MOPType!=MOP_CASH){
    b72a:	80 91 cf 01 	lds	r24, 0x01CF
    b72e:	c5 e9       	ldi	r28, 0x95	; 149
    b730:	d2 e0       	ldi	r29, 0x02	; 2
    b732:	88 23       	and	r24, r24
    b734:	09 f4       	brne	.+2      	; 0xb738 <PrintIdle+0x8c4>
    b736:	b6 ce       	rjmp	.-660    	; 0xb4a4 <PrintIdle+0x630>
			       CarriegeReturn();
    b738:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <CarriegeReturn>
		           sprintf_P(strPrint,PSTR("    ------------------------------"));
    b73c:	00 d0       	rcall	.+0      	; 0xb73e <PrintIdle+0x8ca>
    b73e:	00 d0       	rcall	.+0      	; 0xb740 <PrintIdle+0x8cc>
    b740:	ad b7       	in	r26, 0x3d	; 61
    b742:	be b7       	in	r27, 0x3e	; 62
    b744:	12 96       	adiw	r26, 0x02	; 2
    b746:	dc 93       	st	X, r29
    b748:	ce 93       	st	-X, r28
    b74a:	11 97       	sbiw	r26, 0x01	; 1
    b74c:	8d ed       	ldi	r24, 0xDD	; 221
    b74e:	97 e0       	ldi	r25, 0x07	; 7
    b750:	76 c1       	rjmp	.+748    	; 0xba3e <PrintIdle+0xbca>
			   }else ClearMem(strPrint);
		       break;          
          //Loyalty
		  case 21:
		       CarriegeReturn();
    b752:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("         LOYALTY INFORMATION      "));
    b756:	00 d0       	rcall	.+0      	; 0xb758 <PrintIdle+0x8e4>
    b758:	00 d0       	rcall	.+0      	; 0xb75a <PrintIdle+0x8e6>
    b75a:	85 e9       	ldi	r24, 0x95	; 149
    b75c:	92 e0       	ldi	r25, 0x02	; 2
    b75e:	ed b7       	in	r30, 0x3d	; 61
    b760:	fe b7       	in	r31, 0x3e	; 62
    b762:	92 83       	std	Z+2, r25	; 0x02
    b764:	81 83       	std	Z+1, r24	; 0x01
    b766:	8a eb       	ldi	r24, 0xBA	; 186
    b768:	97 e0       	ldi	r25, 0x07	; 7
    b76a:	a4 cf       	rjmp	.-184    	; 0xb6b4 <PrintIdle+0x840>
		       break; 			            
		  case 22:
		       CarriegeReturn();
    b76c:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("     Card ID      : %s"),strLoyCardID);
    b770:	00 d0       	rcall	.+0      	; 0xb772 <PrintIdle+0x8fe>
    b772:	00 d0       	rcall	.+0      	; 0xb774 <PrintIdle+0x900>
    b774:	00 d0       	rcall	.+0      	; 0xb776 <PrintIdle+0x902>
    b776:	ed b7       	in	r30, 0x3d	; 61
    b778:	fe b7       	in	r31, 0x3e	; 62
    b77a:	31 96       	adiw	r30, 0x01	; 1
    b77c:	85 e9       	ldi	r24, 0x95	; 149
    b77e:	92 e0       	ldi	r25, 0x02	; 2
    b780:	ad b7       	in	r26, 0x3d	; 61
    b782:	be b7       	in	r27, 0x3e	; 62
    b784:	12 96       	adiw	r26, 0x02	; 2
    b786:	9c 93       	st	X, r25
    b788:	8e 93       	st	-X, r24
    b78a:	11 97       	sbiw	r26, 0x01	; 1
    b78c:	83 ea       	ldi	r24, 0xA3	; 163
    b78e:	97 e0       	ldi	r25, 0x07	; 7
    b790:	93 83       	std	Z+3, r25	; 0x03
    b792:	82 83       	std	Z+2, r24	; 0x02
    b794:	87 ec       	ldi	r24, 0xC7	; 199
    b796:	94 e0       	ldi	r25, 0x04	; 4
    b798:	37 c1       	rjmp	.+622    	; 0xba08 <PrintIdle+0xb94>
		       break;
		  case 23:
		       CarriegeReturn();
    b79a:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <CarriegeReturn>
			   //RemSpaceLag(strLoyCardHolder);
		       sprintf_P(strPrint,PSTR("     Card Holder  : %s "),strLoyCardHolder);
    b79e:	00 d0       	rcall	.+0      	; 0xb7a0 <PrintIdle+0x92c>
    b7a0:	00 d0       	rcall	.+0      	; 0xb7a2 <PrintIdle+0x92e>
    b7a2:	00 d0       	rcall	.+0      	; 0xb7a4 <PrintIdle+0x930>
    b7a4:	ed b7       	in	r30, 0x3d	; 61
    b7a6:	fe b7       	in	r31, 0x3e	; 62
    b7a8:	31 96       	adiw	r30, 0x01	; 1
    b7aa:	85 e9       	ldi	r24, 0x95	; 149
    b7ac:	92 e0       	ldi	r25, 0x02	; 2
    b7ae:	ad b7       	in	r26, 0x3d	; 61
    b7b0:	be b7       	in	r27, 0x3e	; 62
    b7b2:	12 96       	adiw	r26, 0x02	; 2
    b7b4:	9c 93       	st	X, r25
    b7b6:	8e 93       	st	-X, r24
    b7b8:	11 97       	sbiw	r26, 0x01	; 1
    b7ba:	8b e8       	ldi	r24, 0x8B	; 139
    b7bc:	97 e0       	ldi	r25, 0x07	; 7
    b7be:	93 83       	std	Z+3, r25	; 0x03
    b7c0:	82 83       	std	Z+2, r24	; 0x02
    b7c2:	84 ea       	ldi	r24, 0xA4	; 164
    b7c4:	94 e0       	ldi	r25, 0x04	; 4
    b7c6:	20 c1       	rjmp	.+576    	; 0xba08 <PrintIdle+0xb94>
		       break;
		  case 24:
		       if ((strlen(strCorporateID)>0)&&(SpaceOnly(strCorporateID)==False)){
    b7c8:	c5 ee       	ldi	r28, 0xE5	; 229
    b7ca:	dd e0       	ldi	r29, 0x0D	; 13
    b7cc:	80 91 e5 0d 	lds	r24, 0x0DE5
    b7d0:	88 23       	and	r24, r24
    b7d2:	d1 f1       	breq	.+116    	; 0xb848 <PrintIdle+0x9d4>
    b7d4:	ce 01       	movw	r24, r28
    b7d6:	0e 94 94 24 	call	0x4928	; 0x4928 <SpaceOnly>
    b7da:	88 23       	and	r24, r24
    b7dc:	a9 f5       	brne	.+106    	; 0xb848 <PrintIdle+0x9d4>
		           CarriegeReturn();
    b7de:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <CarriegeReturn>
				   //RemSpaceLag(strCorporateID);
		           sprintf_P(strPrint,PSTR("     Corp ID      : %s"),strCorporateID);
    b7e2:	00 d0       	rcall	.+0      	; 0xb7e4 <PrintIdle+0x970>
    b7e4:	00 d0       	rcall	.+0      	; 0xb7e6 <PrintIdle+0x972>
    b7e6:	00 d0       	rcall	.+0      	; 0xb7e8 <PrintIdle+0x974>
    b7e8:	ed b7       	in	r30, 0x3d	; 61
    b7ea:	fe b7       	in	r31, 0x3e	; 62
    b7ec:	31 96       	adiw	r30, 0x01	; 1
    b7ee:	85 e9       	ldi	r24, 0x95	; 149
    b7f0:	92 e0       	ldi	r25, 0x02	; 2
    b7f2:	ad b7       	in	r26, 0x3d	; 61
    b7f4:	be b7       	in	r27, 0x3e	; 62
    b7f6:	12 96       	adiw	r26, 0x02	; 2
    b7f8:	9c 93       	st	X, r25
    b7fa:	8e 93       	st	-X, r24
    b7fc:	11 97       	sbiw	r26, 0x01	; 1
    b7fe:	84 e7       	ldi	r24, 0x74	; 116
    b800:	97 e0       	ldi	r25, 0x07	; 7
    b802:	1d c0       	rjmp	.+58     	; 0xb83e <PrintIdle+0x9ca>
			   }else ClearMem(strPrint);
		       break;
		  case 25:
		       if ((strlen(strCorporateName)>0)&&(SpaceOnly(strCorporateName)==False)){
    b804:	cd ea       	ldi	r28, 0xAD	; 173
    b806:	d5 e0       	ldi	r29, 0x05	; 5
    b808:	80 91 ad 05 	lds	r24, 0x05AD
    b80c:	88 23       	and	r24, r24
    b80e:	e1 f0       	breq	.+56     	; 0xb848 <PrintIdle+0x9d4>
    b810:	ce 01       	movw	r24, r28
    b812:	0e 94 94 24 	call	0x4928	; 0x4928 <SpaceOnly>
    b816:	88 23       	and	r24, r24
    b818:	b9 f4       	brne	.+46     	; 0xb848 <PrintIdle+0x9d4>
		           CarriegeReturn();
    b81a:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <CarriegeReturn>
				   //RemSpaceLag(strCorporateName);
		           sprintf_P(strPrint,PSTR("     Corp Name    : %s"),strCorporateName);
    b81e:	00 d0       	rcall	.+0      	; 0xb820 <PrintIdle+0x9ac>
    b820:	00 d0       	rcall	.+0      	; 0xb822 <PrintIdle+0x9ae>
    b822:	00 d0       	rcall	.+0      	; 0xb824 <PrintIdle+0x9b0>
    b824:	ed b7       	in	r30, 0x3d	; 61
    b826:	fe b7       	in	r31, 0x3e	; 62
    b828:	31 96       	adiw	r30, 0x01	; 1
    b82a:	85 e9       	ldi	r24, 0x95	; 149
    b82c:	92 e0       	ldi	r25, 0x02	; 2
    b82e:	ad b7       	in	r26, 0x3d	; 61
    b830:	be b7       	in	r27, 0x3e	; 62
    b832:	12 96       	adiw	r26, 0x02	; 2
    b834:	9c 93       	st	X, r25
    b836:	8e 93       	st	-X, r24
    b838:	11 97       	sbiw	r26, 0x01	; 1
    b83a:	8d e5       	ldi	r24, 0x5D	; 93
    b83c:	97 e0       	ldi	r25, 0x07	; 7
    b83e:	93 83       	std	Z+3, r25	; 0x03
    b840:	82 83       	std	Z+2, r24	; 0x02
    b842:	d5 83       	std	Z+5, r29	; 0x05
    b844:	c4 83       	std	Z+4, r28	; 0x04
    b846:	e2 c0       	rjmp	.+452    	; 0xba0c <PrintIdle+0xb98>
			   }else ClearMem(strPrint);
    b848:	85 e9       	ldi	r24, 0x95	; 149
    b84a:	92 e0       	ldi	r25, 0x02	; 2
    b84c:	2c ce       	rjmp	.-936    	; 0xb4a6 <PrintIdle+0x632>
		       break;
		  case 26:
		       CarriegeReturn();
    b84e:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("     Gain Points  : %s"),strGainPoints);
    b852:	00 d0       	rcall	.+0      	; 0xb854 <PrintIdle+0x9e0>
    b854:	00 d0       	rcall	.+0      	; 0xb856 <PrintIdle+0x9e2>
    b856:	00 d0       	rcall	.+0      	; 0xb858 <PrintIdle+0x9e4>
    b858:	ed b7       	in	r30, 0x3d	; 61
    b85a:	fe b7       	in	r31, 0x3e	; 62
    b85c:	31 96       	adiw	r30, 0x01	; 1
    b85e:	85 e9       	ldi	r24, 0x95	; 149
    b860:	92 e0       	ldi	r25, 0x02	; 2
    b862:	ad b7       	in	r26, 0x3d	; 61
    b864:	be b7       	in	r27, 0x3e	; 62
    b866:	12 96       	adiw	r26, 0x02	; 2
    b868:	9c 93       	st	X, r25
    b86a:	8e 93       	st	-X, r24
    b86c:	11 97       	sbiw	r26, 0x01	; 1
    b86e:	86 e4       	ldi	r24, 0x46	; 70
    b870:	97 e0       	ldi	r25, 0x07	; 7
    b872:	93 83       	std	Z+3, r25	; 0x03
    b874:	82 83       	std	Z+2, r24	; 0x02
    b876:	8b e9       	ldi	r24, 0x9B	; 155
    b878:	94 e0       	ldi	r25, 0x04	; 4
    b87a:	c6 c0       	rjmp	.+396    	; 0xba08 <PrintIdle+0xb94>
		       break;
		  case 27:
		       CarriegeReturn();
    b87c:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("     Prev Points  : %s"),strPrevPoints);
    b880:	00 d0       	rcall	.+0      	; 0xb882 <PrintIdle+0xa0e>
    b882:	00 d0       	rcall	.+0      	; 0xb884 <PrintIdle+0xa10>
    b884:	00 d0       	rcall	.+0      	; 0xb886 <PrintIdle+0xa12>
    b886:	ed b7       	in	r30, 0x3d	; 61
    b888:	fe b7       	in	r31, 0x3e	; 62
    b88a:	31 96       	adiw	r30, 0x01	; 1
    b88c:	85 e9       	ldi	r24, 0x95	; 149
    b88e:	92 e0       	ldi	r25, 0x02	; 2
    b890:	ad b7       	in	r26, 0x3d	; 61
    b892:	be b7       	in	r27, 0x3e	; 62
    b894:	12 96       	adiw	r26, 0x02	; 2
    b896:	9c 93       	st	X, r25
    b898:	8e 93       	st	-X, r24
    b89a:	11 97       	sbiw	r26, 0x01	; 1
    b89c:	8f e2       	ldi	r24, 0x2F	; 47
    b89e:	97 e0       	ldi	r25, 0x07	; 7
    b8a0:	93 83       	std	Z+3, r25	; 0x03
    b8a2:	82 83       	std	Z+2, r24	; 0x02
    b8a4:	8c ee       	ldi	r24, 0xEC	; 236
    b8a6:	9a e0       	ldi	r25, 0x0A	; 10
    b8a8:	af c0       	rjmp	.+350    	; 0xba08 <PrintIdle+0xb94>
		       break;
		  case 28:
		       CarriegeReturn();
    b8aa:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("     Curr Points  : %s"),strLoyCurrentPoints);
    b8ae:	00 d0       	rcall	.+0      	; 0xb8b0 <PrintIdle+0xa3c>
    b8b0:	00 d0       	rcall	.+0      	; 0xb8b2 <PrintIdle+0xa3e>
    b8b2:	00 d0       	rcall	.+0      	; 0xb8b4 <PrintIdle+0xa40>
    b8b4:	ed b7       	in	r30, 0x3d	; 61
    b8b6:	fe b7       	in	r31, 0x3e	; 62
    b8b8:	31 96       	adiw	r30, 0x01	; 1
    b8ba:	85 e9       	ldi	r24, 0x95	; 149
    b8bc:	92 e0       	ldi	r25, 0x02	; 2
    b8be:	ad b7       	in	r26, 0x3d	; 61
    b8c0:	be b7       	in	r27, 0x3e	; 62
    b8c2:	12 96       	adiw	r26, 0x02	; 2
    b8c4:	9c 93       	st	X, r25
    b8c6:	8e 93       	st	-X, r24
    b8c8:	11 97       	sbiw	r26, 0x01	; 1
    b8ca:	88 e1       	ldi	r24, 0x18	; 24
    b8cc:	97 e0       	ldi	r25, 0x07	; 7
    b8ce:	93 83       	std	Z+3, r25	; 0x03
    b8d0:	82 83       	std	Z+2, r24	; 0x02
    b8d2:	8a e3       	ldi	r24, 0x3A	; 58
    b8d4:	9a e0       	ldi	r25, 0x0A	; 10
    b8d6:	98 c0       	rjmp	.+304    	; 0xba08 <PrintIdle+0xb94>
		       break;
		  case 29:
		       CarriegeReturn();
    b8d8:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("     Expiry       : %s"),strLoyExpiry);
    b8dc:	00 d0       	rcall	.+0      	; 0xb8de <PrintIdle+0xa6a>
    b8de:	00 d0       	rcall	.+0      	; 0xb8e0 <PrintIdle+0xa6c>
    b8e0:	00 d0       	rcall	.+0      	; 0xb8e2 <PrintIdle+0xa6e>
    b8e2:	ed b7       	in	r30, 0x3d	; 61
    b8e4:	fe b7       	in	r31, 0x3e	; 62
    b8e6:	31 96       	adiw	r30, 0x01	; 1
    b8e8:	85 e9       	ldi	r24, 0x95	; 149
    b8ea:	92 e0       	ldi	r25, 0x02	; 2
    b8ec:	ad b7       	in	r26, 0x3d	; 61
    b8ee:	be b7       	in	r27, 0x3e	; 62
    b8f0:	12 96       	adiw	r26, 0x02	; 2
    b8f2:	9c 93       	st	X, r25
    b8f4:	8e 93       	st	-X, r24
    b8f6:	11 97       	sbiw	r26, 0x01	; 1
    b8f8:	81 e0       	ldi	r24, 0x01	; 1
    b8fa:	97 e0       	ldi	r25, 0x07	; 7
    b8fc:	93 83       	std	Z+3, r25	; 0x03
    b8fe:	82 83       	std	Z+2, r24	; 0x02
    b900:	83 e5       	ldi	r24, 0x53	; 83
    b902:	9e e0       	ldi	r25, 0x0E	; 14
    b904:	81 c0       	rjmp	.+258    	; 0xba08 <PrintIdle+0xb94>
		       break;
		  case 30:
		       CarriegeReturn();
    b906:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <CarriegeReturn>
			   //RemSpaceLag(strLoyRedeemPoints);
		       sprintf_P(strPrint,PSTR("     Total Redeem : %s"),strLoyRedeemPoints);
    b90a:	00 d0       	rcall	.+0      	; 0xb90c <PrintIdle+0xa98>
    b90c:	00 d0       	rcall	.+0      	; 0xb90e <PrintIdle+0xa9a>
    b90e:	00 d0       	rcall	.+0      	; 0xb910 <PrintIdle+0xa9c>
    b910:	ed b7       	in	r30, 0x3d	; 61
    b912:	fe b7       	in	r31, 0x3e	; 62
    b914:	31 96       	adiw	r30, 0x01	; 1
    b916:	85 e9       	ldi	r24, 0x95	; 149
    b918:	92 e0       	ldi	r25, 0x02	; 2
    b91a:	ad b7       	in	r26, 0x3d	; 61
    b91c:	be b7       	in	r27, 0x3e	; 62
    b91e:	12 96       	adiw	r26, 0x02	; 2
    b920:	9c 93       	st	X, r25
    b922:	8e 93       	st	-X, r24
    b924:	11 97       	sbiw	r26, 0x01	; 1
    b926:	8a ee       	ldi	r24, 0xEA	; 234
    b928:	96 e0       	ldi	r25, 0x06	; 6
    b92a:	93 83       	std	Z+3, r25	; 0x03
    b92c:	82 83       	std	Z+2, r24	; 0x02
    b92e:	8a e7       	ldi	r24, 0x7A	; 122
    b930:	95 e0       	ldi	r25, 0x05	; 5
    b932:	6a c0       	rjmp	.+212    	; 0xba08 <PrintIdle+0xb94>
		       break;
		  case 31:
		       CarriegeReturn();
    b934:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <CarriegeReturn>
			   //RemSpaceLag(strLoyCurrMonConsumeV);
			   //FormatCurrency(strLoyCurrMonConsumeV);
		       sprintf_P(strPrint,PSTR("     Month Cons V : %s L"),strLoyCurrMonConsumeV);
    b938:	00 d0       	rcall	.+0      	; 0xb93a <PrintIdle+0xac6>
    b93a:	00 d0       	rcall	.+0      	; 0xb93c <PrintIdle+0xac8>
    b93c:	00 d0       	rcall	.+0      	; 0xb93e <PrintIdle+0xaca>
    b93e:	ed b7       	in	r30, 0x3d	; 61
    b940:	fe b7       	in	r31, 0x3e	; 62
    b942:	31 96       	adiw	r30, 0x01	; 1
    b944:	85 e9       	ldi	r24, 0x95	; 149
    b946:	92 e0       	ldi	r25, 0x02	; 2
    b948:	ad b7       	in	r26, 0x3d	; 61
    b94a:	be b7       	in	r27, 0x3e	; 62
    b94c:	12 96       	adiw	r26, 0x02	; 2
    b94e:	9c 93       	st	X, r25
    b950:	8e 93       	st	-X, r24
    b952:	11 97       	sbiw	r26, 0x01	; 1
    b954:	81 ed       	ldi	r24, 0xD1	; 209
    b956:	96 e0       	ldi	r25, 0x06	; 6
    b958:	93 83       	std	Z+3, r25	; 0x03
    b95a:	82 83       	std	Z+2, r24	; 0x02
    b95c:	88 ec       	ldi	r24, 0xC8	; 200
    b95e:	9d e0       	ldi	r25, 0x0D	; 13
    b960:	53 c0       	rjmp	.+166    	; 0xba08 <PrintIdle+0xb94>
		       break;
		  case 32:
		       CarriegeReturn();
    b962:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <CarriegeReturn>
			   //RemSpaceLag(strLoyCurrMonConsumeA);
			   //FormatCurrency(strLoyCurrMonConsumeA);
		       sprintf_P(strPrint,PSTR("     Month Cons A : Rp.%s"),strLoyCurrMonConsumeA);
    b966:	00 d0       	rcall	.+0      	; 0xb968 <PrintIdle+0xaf4>
    b968:	00 d0       	rcall	.+0      	; 0xb96a <PrintIdle+0xaf6>
    b96a:	00 d0       	rcall	.+0      	; 0xb96c <PrintIdle+0xaf8>
    b96c:	ed b7       	in	r30, 0x3d	; 61
    b96e:	fe b7       	in	r31, 0x3e	; 62
    b970:	31 96       	adiw	r30, 0x01	; 1
    b972:	85 e9       	ldi	r24, 0x95	; 149
    b974:	92 e0       	ldi	r25, 0x02	; 2
    b976:	ad b7       	in	r26, 0x3d	; 61
    b978:	be b7       	in	r27, 0x3e	; 62
    b97a:	12 96       	adiw	r26, 0x02	; 2
    b97c:	9c 93       	st	X, r25
    b97e:	8e 93       	st	-X, r24
    b980:	11 97       	sbiw	r26, 0x01	; 1
    b982:	87 eb       	ldi	r24, 0xB7	; 183
    b984:	96 e0       	ldi	r25, 0x06	; 6
    b986:	93 83       	std	Z+3, r25	; 0x03
    b988:	82 83       	std	Z+2, r24	; 0x02
    b98a:	8e e5       	ldi	r24, 0x5E	; 94
    b98c:	95 e0       	ldi	r25, 0x05	; 5
    b98e:	3c c0       	rjmp	.+120    	; 0xba08 <PrintIdle+0xb94>
		       break;
		  case 33://EndOfLoyalty
		       CarriegeReturn();
    b990:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("    ------------------------------"));
    b994:	00 d0       	rcall	.+0      	; 0xb996 <PrintIdle+0xb22>
    b996:	00 d0       	rcall	.+0      	; 0xb998 <PrintIdle+0xb24>
    b998:	85 e9       	ldi	r24, 0x95	; 149
    b99a:	92 e0       	ldi	r25, 0x02	; 2
    b99c:	ad b7       	in	r26, 0x3d	; 61
    b99e:	be b7       	in	r27, 0x3e	; 62
    b9a0:	12 96       	adiw	r26, 0x02	; 2
    b9a2:	9c 93       	st	X, r25
    b9a4:	8e 93       	st	-X, r24
    b9a6:	11 97       	sbiw	r26, 0x01	; 1
    b9a8:	84 e9       	ldi	r24, 0x94	; 148
    b9aa:	96 e0       	ldi	r25, 0x06	; 6
    b9ac:	48 c0       	rjmp	.+144    	; 0xba3e <PrintIdle+0xbca>
		       break;
		  case 34:
		       CarriegeReturn();
    b9ae:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("     Surcharge Dsc: %s"),strSurchargeDesc);
    b9b2:	00 d0       	rcall	.+0      	; 0xb9b4 <PrintIdle+0xb40>
    b9b4:	00 d0       	rcall	.+0      	; 0xb9b6 <PrintIdle+0xb42>
    b9b6:	00 d0       	rcall	.+0      	; 0xb9b8 <PrintIdle+0xb44>
    b9b8:	ed b7       	in	r30, 0x3d	; 61
    b9ba:	fe b7       	in	r31, 0x3e	; 62
    b9bc:	31 96       	adiw	r30, 0x01	; 1
    b9be:	85 e9       	ldi	r24, 0x95	; 149
    b9c0:	92 e0       	ldi	r25, 0x02	; 2
    b9c2:	ad b7       	in	r26, 0x3d	; 61
    b9c4:	be b7       	in	r27, 0x3e	; 62
    b9c6:	12 96       	adiw	r26, 0x02	; 2
    b9c8:	9c 93       	st	X, r25
    b9ca:	8e 93       	st	-X, r24
    b9cc:	11 97       	sbiw	r26, 0x01	; 1
    b9ce:	8d e7       	ldi	r24, 0x7D	; 125
    b9d0:	96 e0       	ldi	r25, 0x06	; 6
    b9d2:	93 83       	std	Z+3, r25	; 0x03
    b9d4:	82 83       	std	Z+2, r24	; 0x02
    b9d6:	8f ec       	ldi	r24, 0xCF	; 207
    b9d8:	99 e0       	ldi	r25, 0x09	; 9
    b9da:	16 c0       	rjmp	.+44     	; 0xba08 <PrintIdle+0xb94>
		       break;
		  case 35:
		       CarriegeReturn();
    b9dc:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("     Surcharge Amt: %s"),strSurchargeAmount);
    b9e0:	00 d0       	rcall	.+0      	; 0xb9e2 <PrintIdle+0xb6e>
    b9e2:	00 d0       	rcall	.+0      	; 0xb9e4 <PrintIdle+0xb70>
    b9e4:	00 d0       	rcall	.+0      	; 0xb9e6 <PrintIdle+0xb72>
    b9e6:	ed b7       	in	r30, 0x3d	; 61
    b9e8:	fe b7       	in	r31, 0x3e	; 62
    b9ea:	31 96       	adiw	r30, 0x01	; 1
    b9ec:	85 e9       	ldi	r24, 0x95	; 149
    b9ee:	92 e0       	ldi	r25, 0x02	; 2
    b9f0:	ad b7       	in	r26, 0x3d	; 61
    b9f2:	be b7       	in	r27, 0x3e	; 62
    b9f4:	12 96       	adiw	r26, 0x02	; 2
    b9f6:	9c 93       	st	X, r25
    b9f8:	8e 93       	st	-X, r24
    b9fa:	11 97       	sbiw	r26, 0x01	; 1
    b9fc:	86 e6       	ldi	r24, 0x66	; 102
    b9fe:	96 e0       	ldi	r25, 0x06	; 6
    ba00:	93 83       	std	Z+3, r25	; 0x03
    ba02:	82 83       	std	Z+2, r24	; 0x02
    ba04:	87 e5       	ldi	r24, 0x57	; 87
    ba06:	9a e0       	ldi	r25, 0x0A	; 10
    ba08:	95 83       	std	Z+5, r25	; 0x05
    ba0a:	84 83       	std	Z+4, r24	; 0x04
    ba0c:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    ba10:	ed b7       	in	r30, 0x3d	; 61
    ba12:	fe b7       	in	r31, 0x3e	; 62
    ba14:	36 96       	adiw	r30, 0x06	; 6
    ba16:	0f b6       	in	r0, 0x3f	; 63
    ba18:	f8 94       	cli
    ba1a:	fe bf       	out	0x3e, r31	; 62
    ba1c:	0f be       	out	0x3f, r0	; 63
    ba1e:	ed bf       	out	0x3d, r30	; 61
    ba20:	18 c0       	rjmp	.+48     	; 0xba52 <PrintIdle+0xbde>
		       break;
		  case 36:
		       CarriegeReturn();
    ba22:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("    ------------------------------"));
    ba26:	00 d0       	rcall	.+0      	; 0xba28 <PrintIdle+0xbb4>
    ba28:	00 d0       	rcall	.+0      	; 0xba2a <PrintIdle+0xbb6>
    ba2a:	85 e9       	ldi	r24, 0x95	; 149
    ba2c:	92 e0       	ldi	r25, 0x02	; 2
    ba2e:	ad b7       	in	r26, 0x3d	; 61
    ba30:	be b7       	in	r27, 0x3e	; 62
    ba32:	12 96       	adiw	r26, 0x02	; 2
    ba34:	9c 93       	st	X, r25
    ba36:	8e 93       	st	-X, r24
    ba38:	11 97       	sbiw	r26, 0x01	; 1
    ba3a:	83 e4       	ldi	r24, 0x43	; 67
    ba3c:	96 e0       	ldi	r25, 0x06	; 6
    ba3e:	14 96       	adiw	r26, 0x04	; 4
    ba40:	9c 93       	st	X, r25
    ba42:	8e 93       	st	-X, r24
    ba44:	13 97       	sbiw	r26, 0x03	; 3
    ba46:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    ba4a:	0f 90       	pop	r0
    ba4c:	0f 90       	pop	r0
    ba4e:	0f 90       	pop	r0
    ba50:	0f 90       	pop	r0
		       break;
		  }
		  iLoop=0;iSend=0;LSend=strlen(strPrint);
    ba52:	10 92 8d 02 	sts	0x028D, r1
    ba56:	10 92 8c 02 	sts	0x028C, r1
    ba5a:	10 92 91 02 	sts	0x0291, r1
    ba5e:	10 92 90 02 	sts	0x0290, r1
    ba62:	e5 e9       	ldi	r30, 0x95	; 149
    ba64:	f2 e0       	ldi	r31, 0x02	; 2
    ba66:	01 90       	ld	r0, Z+
    ba68:	00 20       	and	r0, r0
    ba6a:	e9 f7       	brne	.-6      	; 0xba66 <PrintIdle+0xbf2>
    ba6c:	31 97       	sbiw	r30, 0x01	; 1
    ba6e:	e5 59       	subi	r30, 0x95	; 149
    ba70:	f2 40       	sbci	r31, 0x02	; 2
    ba72:	f0 93 8f 02 	sts	0x028F, r31
    ba76:	e0 93 8e 02 	sts	0x028E, r30
          stPrintIdle=piPrintMessage;
    ba7a:	8a e0       	ldi	r24, 0x0A	; 10
    ba7c:	f3 c0       	rjmp	.+486    	; 0xbc64 <PrintIdle+0xdf0>
	      break;
     case piPrintMessage:
	      if (iSend<LSend){
    ba7e:	20 91 90 02 	lds	r18, 0x0290
    ba82:	30 91 91 02 	lds	r19, 0x0291
    ba86:	80 91 8e 02 	lds	r24, 0x028E
    ba8a:	90 91 8f 02 	lds	r25, 0x028F
    ba8e:	28 17       	cp	r18, r24
    ba90:	39 07       	cpc	r19, r25
    ba92:	78 f4       	brcc	.+30     	; 0xbab2 <PrintIdle+0xc3e>
		      iLoop++;
    ba94:	80 91 8c 02 	lds	r24, 0x028C
    ba98:	90 91 8d 02 	lds	r25, 0x028D
    ba9c:	01 96       	adiw	r24, 0x01	; 1
    ba9e:	90 93 8d 02 	sts	0x028D, r25
    baa2:	80 93 8c 02 	sts	0x028C, r24
			  if((iLoop%PRINT_DELAY)==0){
				 TimPrintBusy=0;
    baa6:	10 92 cd 01 	sts	0x01CD, r1
    baaa:	10 92 cc 01 	sts	0x01CC, r1
				 stPrintIdle=piCheckPrintStatusMessage;
    baae:	8c e0       	ldi	r24, 0x0C	; 12
    bab0:	d9 c0       	rjmp	.+434    	; 0xbc64 <PrintIdle+0xdf0>
				 }
			  }
          else{iMessage++;
    bab2:	80 91 94 02 	lds	r24, 0x0294
    bab6:	8f 5f       	subi	r24, 0xFF	; 255
    bab8:	80 93 94 02 	sts	0x0294, r24
		      if (iMessage>MessageLine){
    babc:	90 91 93 02 	lds	r25, 0x0293
    bac0:	98 17       	cp	r25, r24
    bac2:	18 f4       	brcc	.+6      	; 0xbaca <PrintIdle+0xc56>
			      iFooter=0;
    bac4:	10 92 c4 02 	sts	0x02C4, r1
    bac8:	5c c0       	rjmp	.+184    	; 0xbb82 <PrintIdle+0xd0e>
				  stPrintIdle=piLoadFooter;
				  CarriegeReturn();
			  }
			  else stPrintIdle=piLoadMessage;
    baca:	89 e0       	ldi	r24, 0x09	; 9
    bacc:	cb c0       	rjmp	.+406    	; 0xbc64 <PrintIdle+0xdf0>
			  }
	      break;
     case piCheckPrintStatusMessage:
	      if (IsBusyPrint==False){
    bace:	80 91 c9 01 	lds	r24, 0x01C9
    bad2:	88 23       	and	r24, r24
    bad4:	09 f0       	breq	.+2      	; 0xbad8 <PrintIdle+0xc64>
    bad6:	bc c0       	rjmp	.+376    	; 0xbc50 <PrintIdle+0xddc>
		      _uart(_COM_PRINTER,1,strPrint[iSend]);
    bad8:	e0 91 90 02 	lds	r30, 0x0290
    badc:	f0 91 91 02 	lds	r31, 0x0291
    bae0:	eb 56       	subi	r30, 0x6B	; 107
    bae2:	fd 4f       	sbci	r31, 0xFD	; 253
    bae4:	61 e0       	ldi	r22, 0x01	; 1
    bae6:	40 81       	ld	r20, Z
    bae8:	0e 94 d5 b3 	call	0x167aa	; 0x167aa <_uart>
		      iSend++;
    baec:	80 91 90 02 	lds	r24, 0x0290
    baf0:	90 91 91 02 	lds	r25, 0x0291
    baf4:	01 96       	adiw	r24, 0x01	; 1
    baf6:	90 93 91 02 	sts	0x0291, r25
    bafa:	80 93 90 02 	sts	0x0290, r24
		      stPrintIdle=piPrintMessage;
    bafe:	8a e0       	ldi	r24, 0x0A	; 10
    bb00:	a5 c0       	rjmp	.+330    	; 0xbc4c <PrintIdle+0xdd8>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    bb02:	60 91 c4 02 	lds	r22, 0x02C4
    bb06:	89 e2       	ldi	r24, 0x29	; 41
    bb08:	68 9f       	mul	r22, r24
    bb0a:	b0 01       	movw	r22, r0
    bb0c:	11 24       	eor	r1, r1
    bb0e:	63 5e       	subi	r22, 0xE3	; 227
    bb10:	7c 4f       	sbci	r23, 0xFC	; 252
    bb12:	85 e9       	ldi	r24, 0x95	; 149
    bb14:	92 e0       	ldi	r25, 0x02	; 2
    bb16:	48 e2       	ldi	r20, 0x28	; 40
    bb18:	50 e0       	ldi	r21, 0x00	; 0
    bb1a:	26 ef       	ldi	r18, 0xF6	; 246
    bb1c:	32 e1       	ldi	r19, 0x12	; 18
    bb1e:	0e 94 7a b5 	call	0x16af4	; 0x16af4 <__eerd_block>
	      break;
		       
     case piLoadFooter:
	      FillChar(strPrint,0,sizeof(strPrint));
	      eeprom_read_block((void*) &strPrint, (const void*) &DefHeaderFooter[6+iFooter], 40);
		  iFooter++;
    bb22:	80 91 c4 02 	lds	r24, 0x02C4
    bb26:	8f 5f       	subi	r24, 0xFF	; 255
    bb28:	80 93 c4 02 	sts	0x02C4, r24
		  if (iFooter<=4){
    bb2c:	85 30       	cpi	r24, 0x05	; 5
    bb2e:	90 f4       	brcc	.+36     	; 0xbb54 <PrintIdle+0xce0>
		      if (SpaceOnly(strPrint)==True){
    bb30:	85 e9       	ldi	r24, 0x95	; 149
    bb32:	92 e0       	ldi	r25, 0x02	; 2
    bb34:	0e 94 94 24 	call	0x4928	; 0x4928 <SpaceOnly>
    bb38:	81 30       	cpi	r24, 0x01	; 1
    bb3a:	11 f4       	brne	.+4      	; 0xbb40 <PrintIdle+0xccc>
			      stPrintIdle=piLoadFooter;
    bb3c:	8e e0       	ldi	r24, 0x0E	; 14
    bb3e:	92 c0       	rjmp	.+292    	; 0xbc64 <PrintIdle+0xdf0>
				  }
			  else{
			      iSend=0;
    bb40:	10 92 91 02 	sts	0x0291, r1
    bb44:	10 92 90 02 	sts	0x0290, r1
				  iLoop=0;
    bb48:	10 92 8d 02 	sts	0x028D, r1
    bb4c:	10 92 8c 02 	sts	0x028C, r1
				  stPrintIdle=piPrintFooter;
    bb50:	8f e0       	ldi	r24, 0x0F	; 15
    bb52:	88 c0       	rjmp	.+272    	; 0xbc64 <PrintIdle+0xdf0>
				  //RemSpaceLag(strPrint);
				  //CarriegeReturn();
			      }
		  }else{stPrintIdle=piInitScroll;
    bb54:	81 e1       	ldi	r24, 0x11	; 17
    bb56:	86 c0       	rjmp	.+268    	; 0xbc64 <PrintIdle+0xdf0>
		        //iPrinted++;
			}
	      break;
     case piPrintFooter:
		  if (iSend<40){
    bb58:	80 91 90 02 	lds	r24, 0x0290
    bb5c:	90 91 91 02 	lds	r25, 0x0291
    bb60:	88 97       	sbiw	r24, 0x28	; 40
    bb62:	78 f4       	brcc	.+30     	; 0xbb82 <PrintIdle+0xd0e>
		      iLoop++;
    bb64:	80 91 8c 02 	lds	r24, 0x028C
    bb68:	90 91 8d 02 	lds	r25, 0x028D
    bb6c:	01 96       	adiw	r24, 0x01	; 1
    bb6e:	90 93 8d 02 	sts	0x028D, r25
    bb72:	80 93 8c 02 	sts	0x028C, r24
			  if((iLoop%PRINT_DELAY)==0){
				TimPrintBusy=0;
    bb76:	10 92 cd 01 	sts	0x01CD, r1
    bb7a:	10 92 cc 01 	sts	0x01CC, r1
				stPrintIdle=piCheckPrintStatusFooter;
    bb7e:	8d e0       	ldi	r24, 0x0D	; 13
    bb80:	71 c0       	rjmp	.+226    	; 0xbc64 <PrintIdle+0xdf0>
				}
			  }
          else {
		      stPrintIdle=piLoadFooter;
    bb82:	8e e0       	ldi	r24, 0x0E	; 14
    bb84:	80 93 c6 02 	sts	0x02C6, r24
			  CarriegeReturn();
    bb88:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <CarriegeReturn>
    bb8c:	96 c0       	rjmp	.+300    	; 0xbcba <PrintIdle+0xe46>
			  }
	      break;
     case piCheckPrintStatusFooter:
	      if (IsBusyPrint==False){
    bb8e:	80 91 c9 01 	lds	r24, 0x01C9
    bb92:	88 23       	and	r24, r24
    bb94:	09 f0       	breq	.+2      	; 0xbb98 <PrintIdle+0xd24>
    bb96:	5c c0       	rjmp	.+184    	; 0xbc50 <PrintIdle+0xddc>
		      _uart(_COM_PRINTER,1,strPrint[iSend]);
    bb98:	e0 91 90 02 	lds	r30, 0x0290
    bb9c:	f0 91 91 02 	lds	r31, 0x0291
    bba0:	eb 56       	subi	r30, 0x6B	; 107
    bba2:	fd 4f       	sbci	r31, 0xFD	; 253
    bba4:	61 e0       	ldi	r22, 0x01	; 1
    bba6:	40 81       	ld	r20, Z
    bba8:	0e 94 d5 b3 	call	0x167aa	; 0x167aa <_uart>
		      iSend++;
    bbac:	80 91 90 02 	lds	r24, 0x0290
    bbb0:	90 91 91 02 	lds	r25, 0x0291
    bbb4:	01 96       	adiw	r24, 0x01	; 1
    bbb6:	90 93 91 02 	sts	0x0291, r25
    bbba:	80 93 90 02 	sts	0x0290, r24
		      stPrintIdle=piPrintFooter;
    bbbe:	8f e0       	ldi	r24, 0x0F	; 15
    bbc0:	45 c0       	rjmp	.+138    	; 0xbc4c <PrintIdle+0xdd8>
		      stPrintIdle=piFinishPrintIdle;
			  }
	      break;

     case piInitScroll:
	      iPrinted++;
    bbc2:	90 91 8b 02 	lds	r25, 0x028B
    bbc6:	9f 5f       	subi	r25, 0xFF	; 255
    bbc8:	90 93 8b 02 	sts	0x028B, r25
		  iScroll=0;
    bbcc:	10 92 c3 02 	sts	0x02C3, r1
		  iLoop=0;
    bbd0:	10 92 8d 02 	sts	0x028D, r1
    bbd4:	10 92 8c 02 	sts	0x028C, r1
		  if (iPrinted<PrintCopy){
    bbd8:	80 91 8a 02 	lds	r24, 0x028A
    bbdc:	98 17       	cp	r25, r24
    bbde:	28 f4       	brcc	.+10     	; 0xbbea <PrintIdle+0xd76>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    bbe0:	e1 99       	sbic	0x1c, 1	; 28
    bbe2:	fe cf       	rjmp	.-4      	; 0xbbe0 <PrintIdle+0xd6c>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    bbe4:	82 e3       	ldi	r24, 0x32	; 50
    bbe6:	90 e0       	ldi	r25, 0x00	; 0
    bbe8:	04 c0       	rjmp	.+8      	; 0xbbf2 <PrintIdle+0xd7e>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    bbea:	e1 99       	sbic	0x1c, 1	; 28
    bbec:	fe cf       	rjmp	.-4      	; 0xbbea <PrintIdle+0xd76>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    bbee:	81 e3       	ldi	r24, 0x31	; 49
    bbf0:	90 e0       	ldi	r25, 0x00	; 0
    bbf2:	9f bb       	out	0x1f, r25	; 31
    bbf4:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    bbf6:	e0 9a       	sbi	0x1c, 0	; 28
    bbf8:	8d b3       	in	r24, 0x1d	; 29
		      nScroll=eeprom_read_byte(&DefPrintScrollSpace);
		  }else if (iPrinted>=PrintCopy){		  	  
		      nScroll=eeprom_read_byte(&DefPrintScrollEnd);
    bbfa:	80 93 c2 02 	sts	0x02C2, r24
		  if (eeprom_read_byte(&DefPrinterType)==PT_CUSTOM_TG02){
		      _uart_printf(0,1,PSTR("----Scrolled2-----"));

		      stPrintIdle=piPaperCut;
		  }*/
          stPrintIdle=piScrollPaper;              
    bbfe:	80 e1       	ldi	r24, 0x10	; 16
    bc00:	31 c0       	rjmp	.+98     	; 0xbc64 <PrintIdle+0xdf0>
	      break;
     case piScrollPaper:
	      iLoop++;
    bc02:	80 91 8c 02 	lds	r24, 0x028C
    bc06:	90 91 8d 02 	lds	r25, 0x028D
    bc0a:	01 96       	adiw	r24, 0x01	; 1
    bc0c:	90 93 8d 02 	sts	0x028D, r25
    bc10:	80 93 8c 02 	sts	0x028C, r24
		  if (iLoop%PRINT_DELAY==0){
			  TimPrintBusy=0;
    bc14:	10 92 cd 01 	sts	0x01CD, r1
    bc18:	10 92 cc 01 	sts	0x01CC, r1
			  stPrintIdle=piCheckPrintStatusScroll;
    bc1c:	82 e1       	ldi	r24, 0x12	; 18
    bc1e:	80 93 c6 02 	sts	0x02C6, r24
			  }
	      if (iScroll>nScroll)stPrintIdle=piPaperCut;
    bc22:	90 91 c3 02 	lds	r25, 0x02C3
    bc26:	80 91 c2 02 	lds	r24, 0x02C2
    bc2a:	89 17       	cp	r24, r25
    bc2c:	08 f0       	brcs	.+2      	; 0xbc30 <PrintIdle+0xdbc>
    bc2e:	45 c0       	rjmp	.+138    	; 0xbcba <PrintIdle+0xe46>
    bc30:	83 e1       	ldi	r24, 0x13	; 19
    bc32:	18 c0       	rjmp	.+48     	; 0xbc64 <PrintIdle+0xdf0>
	      break;
     case piCheckPrintStatusScroll:
	      if (IsBusyPrint==False){
    bc34:	80 91 c9 01 	lds	r24, 0x01C9
    bc38:	88 23       	and	r24, r24
    bc3a:	51 f4       	brne	.+20     	; 0xbc50 <PrintIdle+0xddc>
		      iScroll++;
    bc3c:	80 91 c3 02 	lds	r24, 0x02C3
    bc40:	8f 5f       	subi	r24, 0xFF	; 255
    bc42:	80 93 c3 02 	sts	0x02C3, r24
		      CarriegeReturn();
    bc46:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <CarriegeReturn>
		      stPrintIdle=piScrollPaper;
    bc4a:	80 e1       	ldi	r24, 0x10	; 16
    bc4c:	80 93 c6 02 	sts	0x02C6, r24
		  }
		  if (TimPrintBusy>TIM_BUSY_PRINT){
    bc50:	80 91 cc 01 	lds	r24, 0x01CC
    bc54:	90 91 cd 01 	lds	r25, 0x01CD
    bc58:	0b 97       	sbiw	r24, 0x0b	; 11
    bc5a:	7c f1       	brlt	.+94     	; 0xbcba <PrintIdle+0xe46>
		      IsPrintERROR=True;
    bc5c:	81 e0       	ldi	r24, 0x01	; 1
    bc5e:	80 93 c7 01 	sts	0x01C7, r24
		      stPrintIdle=piFinishPrintIdle;
    bc62:	84 e1       	ldi	r24, 0x14	; 20
    bc64:	80 93 c6 02 	sts	0x02C6, r24
    bc68:	28 c0       	rjmp	.+80     	; 0xbcba <PrintIdle+0xe46>
	      break;
     case piPaperCut:
	      //sprintf_P(strSend,PSTR("i:%d Copy:%d"),iPrinted,PrintCopy);
		  //_uart_print(0,1,strSend);

          if (iPrinted>=PrintCopy){
    bc6a:	90 91 8b 02 	lds	r25, 0x028B
    bc6e:	80 91 8a 02 	lds	r24, 0x028A
    bc72:	98 17       	cp	r25, r24
    bc74:	10 f0       	brcs	.+4      	; 0xbc7a <PrintIdle+0xe06>
		      stPrintIdle=piFinishPrintIdle;
    bc76:	84 e1       	ldi	r24, 0x14	; 20
    bc78:	05 c0       	rjmp	.+10     	; 0xbc84 <PrintIdle+0xe10>
			  }
		  else {CarriegeReturn();
    bc7a:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <CarriegeReturn>
		        CarriegeReturn();
    bc7e:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <CarriegeReturn>
		        stPrintIdle=piInit;
    bc82:	81 e0       	ldi	r24, 0x01	; 1
    bc84:	80 93 c6 02 	sts	0x02C6, r24
		       }
		  PaperCut();
    bc88:	0e 94 c2 4d 	call	0x9b84	; 0x9b84 <PaperCut>
    bc8c:	16 c0       	rjmp	.+44     	; 0xbcba <PrintIdle+0xe46>
	      break;
     case piFinishPrintIdle:	      
	      switch(IFType){
    bc8e:	80 91 10 01 	lds	r24, 0x0110
    bc92:	81 30       	cpi	r24, 0x01	; 1
    bc94:	19 f0       	breq	.+6      	; 0xbc9c <PrintIdle+0xe28>
    bc96:	82 30       	cpi	r24, 0x02	; 2
    bc98:	61 f4       	brne	.+24     	; 0xbcb2 <PrintIdle+0xe3e>
    bc9a:	03 c0       	rjmp	.+6      	; 0xbca2 <PrintIdle+0xe2e>
		  case IT_SLAVE:
		       sendMessage04();
    bc9c:	0e 94 40 54 	call	0xa880	; 0xa880 <sendMessage04>
    bca0:	08 c0       	rjmp	.+16     	; 0xbcb2 <PrintIdle+0xe3e>
		       break;
		  case IT_STANDALONE:
		  
		       UpdateStandaloneStatus((atoi(strFIP_ID)&0x0F),PS_PRINTED);
    bca2:	8c e9       	ldi	r24, 0x9C	; 156
    bca4:	99 e0       	ldi	r25, 0x09	; 9
    bca6:	0e 94 45 b5 	call	0x16a8a	; 0x16a8a <atoi>
    bcaa:	8f 70       	andi	r24, 0x0F	; 15
    bcac:	61 e1       	ldi	r22, 0x11	; 17
    bcae:	0e 94 18 1e 	call	0x3c30	; 0x3c30 <UpdateStandaloneStatus>
			   //strPumpStatus[FIPAddr]=GetPumpStatusLabel(PUMP_OFF);			   
			   //IsNewPumpStatus=True;//UpdateDisplay

		       break;
		  }
		  IsBusyIdlePrinting=False;
    bcb2:	10 92 c8 01 	sts	0x01C8, r1
          stPrintIdle=piIdle;
    bcb6:	10 92 c6 02 	sts	0x02C6, r1
	      break;	 
	 }
}
    bcba:	df 91       	pop	r29
    bcbc:	cf 91       	pop	r28
    bcbe:	08 95       	ret

0000bcc0 <systemPrinting>:
     

}

void systemPrinting(){
	 FreePrinting();
    bcc0:	0e 94 a4 54 	call	0xa948	; 0xa948 <FreePrinting>
	 PrintIdle();
    bcc4:	0e 94 3a 57 	call	0xae74	; 0xae74 <PrintIdle>
}
    bcc8:	08 95       	ret

0000bcca <procMessage11>:
}




void procMessage11(){
    bcca:	af 92       	push	r10
    bccc:	bf 92       	push	r11
    bcce:	cf 92       	push	r12
    bcd0:	df 92       	push	r13
    bcd2:	ef 92       	push	r14
    bcd4:	ff 92       	push	r15
    bcd6:	0f 93       	push	r16
    bcd8:	1f 93       	push	r17
    bcda:	df 93       	push	r29
    bcdc:	cf 93       	push	r28
    bcde:	cd b7       	in	r28, 0x3d	; 61
    bce0:	de b7       	in	r29, 0x3e	; 62
    bce2:	c5 55       	subi	r28, 0x55	; 85
    bce4:	d0 40       	sbci	r29, 0x00	; 0
    bce6:	0f b6       	in	r0, 0x3f	; 63
    bce8:	f8 94       	cli
    bcea:	de bf       	out	0x3e, r29	; 62
    bcec:	0f be       	out	0x3f, r0	; 63
    bcee:	cd bf       	out	0x3d, r28	; 61
    bcf0:	20 e0       	ldi	r18, 0x00	; 0
    bcf2:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    bcf4:	ae 01       	movw	r20, r28
    bcf6:	46 5f       	subi	r20, 0xF6	; 246
    bcf8:	5f 4f       	sbci	r21, 0xFF	; 255
    bcfa:	fa 01       	movw	r30, r20
    bcfc:	e2 0f       	add	r30, r18
    bcfe:	f3 1f       	adc	r31, r19
    bd00:	d9 01       	movw	r26, r18
    bd02:	ab 50       	subi	r26, 0x0B	; 11
    bd04:	b5 4f       	sbci	r27, 0xF5	; 245
    bd06:	9b 96       	adiw	r26, 0x2b	; 43
    bd08:	8c 91       	ld	r24, X
    bd0a:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bd0c:	2f 5f       	subi	r18, 0xFF	; 255
    bd0e:	3f 4f       	sbci	r19, 0xFF	; 255
    bd10:	2a 30       	cpi	r18, 0x0A	; 10
    bd12:	31 05       	cpc	r19, r1
    bd14:	91 f7       	brne	.-28     	; 0xbcfa <procMessage11+0x30>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    bd16:	fa 01       	movw	r30, r20
    bd18:	12 86       	std	Z+10, r1	; 0x0a
     char buffHeader[41];
	 char strProductName[13],strProductPrice[9],strTime[12],strDate[10];

     //Update Datetime
	 StrPosCopy(rcv_trans,strDate,43,10);//2004/09/14 19:05:36
	 FormatDate(DATE_SHORT_YEAR,strDate);
    bd1a:	81 e0       	ldi	r24, 0x01	; 1
    bd1c:	ba 01       	movw	r22, r20
    bd1e:	0e 94 68 25 	call	0x4ad0	; 0x4ad0 <FormatDate>
    bd22:	20 e0       	ldi	r18, 0x00	; 0
    bd24:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    bd26:	ae 01       	movw	r20, r28
    bd28:	4c 5e       	subi	r20, 0xEC	; 236
    bd2a:	5f 4f       	sbci	r21, 0xFF	; 255
    bd2c:	fa 01       	movw	r30, r20
    bd2e:	e2 0f       	add	r30, r18
    bd30:	f3 1f       	adc	r31, r19
    bd32:	d9 01       	movw	r26, r18
    bd34:	ab 50       	subi	r26, 0x0B	; 11
    bd36:	b5 4f       	sbci	r27, 0xF5	; 245
    bd38:	d6 96       	adiw	r26, 0x36	; 54
    bd3a:	8c 91       	ld	r24, X
    bd3c:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bd3e:	2f 5f       	subi	r18, 0xFF	; 255
    bd40:	3f 4f       	sbci	r19, 0xFF	; 255
    bd42:	28 30       	cpi	r18, 0x08	; 8
    bd44:	31 05       	cpc	r19, r1
    bd46:	91 f7       	brne	.-28     	; 0xbd2c <procMessage11+0x62>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    bd48:	1c 8e       	std	Y+28, r1	; 0x1c

     //Update Datetime
	 StrPosCopy(rcv_trans,strDate,43,10);//2004/09/14 19:05:36
	 FormatDate(DATE_SHORT_YEAR,strDate);
	 StrPosCopy(rcv_trans,strTime,54,8);
	 _datetime(_DATETIME_WRITE,strDate,strTime);
    bd4a:	81 e0       	ldi	r24, 0x01	; 1
    bd4c:	be 01       	movw	r22, r28
    bd4e:	66 5f       	subi	r22, 0xF6	; 246
    bd50:	7f 4f       	sbci	r23, 0xFF	; 255
    bd52:	0e 94 d1 b2 	call	0x165a2	; 0x165a2 <_datetime>
	  
     clearString(buffHeader);
    bd56:	8e 01       	movw	r16, r28
    bd58:	03 5d       	subi	r16, 0xD3	; 211
    bd5a:	1f 4f       	sbci	r17, 0xFF	; 255
    bd5c:	c8 01       	movw	r24, r16
    bd5e:	0e 94 23 27 	call	0x4e46	; 0x4e46 <clearString>
    bd62:	20 e0       	ldi	r18, 0x00	; 0
    bd64:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    bd66:	f8 01       	movw	r30, r16
    bd68:	e2 0f       	add	r30, r18
    bd6a:	f3 1f       	adc	r31, r19
    bd6c:	d9 01       	movw	r26, r18
    bd6e:	ab 50       	subi	r26, 0x0B	; 11
    bd70:	b5 4f       	sbci	r27, 0xF5	; 245
    bd72:	de 96       	adiw	r26, 0x3e	; 62
    bd74:	8c 91       	ld	r24, X
    bd76:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bd78:	2f 5f       	subi	r18, 0xFF	; 255
    bd7a:	3f 4f       	sbci	r19, 0xFF	; 255
    bd7c:	28 32       	cpi	r18, 0x28	; 40
    bd7e:	31 05       	cpc	r19, r1
    bd80:	91 f7       	brne	.-28     	; 0xbd66 <procMessage11+0x9c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    bd82:	fe 01       	movw	r30, r28
    bd84:	eb 5a       	subi	r30, 0xAB	; 171
    bd86:	ff 4f       	sbci	r31, 0xFF	; 255
    bd88:	10 82       	st	Z, r1
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    bd8a:	87 e2       	ldi	r24, 0x27	; 39
    bd8c:	92 e0       	ldi	r25, 0x02	; 2
    bd8e:	b8 01       	movw	r22, r16
    bd90:	48 e2       	ldi	r20, 0x28	; 40
    bd92:	50 e0       	ldi	r21, 0x00	; 0
    bd94:	2e ef       	ldi	r18, 0xFE	; 254
    bd96:	32 e1       	ldi	r19, 0x12	; 18
    bd98:	0e 94 96 b5 	call	0x16b2c	; 0x16b2c <__eewr_block>
    bd9c:	20 e0       	ldi	r18, 0x00	; 0
    bd9e:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    bda0:	be 01       	movw	r22, r28
    bda2:	63 5d       	subi	r22, 0xD3	; 211
    bda4:	7f 4f       	sbci	r23, 0xFF	; 255
    bda6:	fb 01       	movw	r30, r22
    bda8:	e2 0f       	add	r30, r18
    bdaa:	f3 1f       	adc	r31, r19
    bdac:	d9 01       	movw	r26, r18
    bdae:	a5 5a       	subi	r26, 0xA5	; 165
    bdb0:	b4 4f       	sbci	r27, 0xF4	; 244
    bdb2:	8c 91       	ld	r24, X
    bdb4:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bdb6:	2f 5f       	subi	r18, 0xFF	; 255
    bdb8:	3f 4f       	sbci	r19, 0xFF	; 255
    bdba:	28 32       	cpi	r18, 0x28	; 40
    bdbc:	31 05       	cpc	r19, r1
    bdbe:	99 f7       	brne	.-26     	; 0xbda6 <procMessage11+0xdc>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    bdc0:	fe 01       	movw	r30, r28
    bdc2:	eb 5a       	subi	r30, 0xAB	; 171
    bdc4:	ff 4f       	sbci	r31, 0xFF	; 255
    bdc6:	10 82       	st	Z, r1
    bdc8:	80 e5       	ldi	r24, 0x50	; 80
    bdca:	92 e0       	ldi	r25, 0x02	; 2
    bdcc:	48 e2       	ldi	r20, 0x28	; 40
    bdce:	50 e0       	ldi	r21, 0x00	; 0
    bdd0:	2e ef       	ldi	r18, 0xFE	; 254
    bdd2:	32 e1       	ldi	r19, 0x12	; 18
    bdd4:	0e 94 96 b5 	call	0x16b2c	; 0x16b2c <__eewr_block>
    bdd8:	20 e0       	ldi	r18, 0x00	; 0
    bdda:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    bddc:	be 01       	movw	r22, r28
    bdde:	63 5d       	subi	r22, 0xD3	; 211
    bde0:	7f 4f       	sbci	r23, 0xFF	; 255
    bde2:	fb 01       	movw	r30, r22
    bde4:	e2 0f       	add	r30, r18
    bde6:	f3 1f       	adc	r31, r19
    bde8:	d9 01       	movw	r26, r18
    bdea:	ad 57       	subi	r26, 0x7D	; 125
    bdec:	b4 4f       	sbci	r27, 0xF4	; 244
    bdee:	8c 91       	ld	r24, X
    bdf0:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bdf2:	2f 5f       	subi	r18, 0xFF	; 255
    bdf4:	3f 4f       	sbci	r19, 0xFF	; 255
    bdf6:	28 32       	cpi	r18, 0x28	; 40
    bdf8:	31 05       	cpc	r19, r1
    bdfa:	99 f7       	brne	.-26     	; 0xbde2 <procMessage11+0x118>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    bdfc:	fe 01       	movw	r30, r28
    bdfe:	eb 5a       	subi	r30, 0xAB	; 171
    be00:	ff 4f       	sbci	r31, 0xFF	; 255
    be02:	10 82       	st	Z, r1
    be04:	89 e7       	ldi	r24, 0x79	; 121
    be06:	92 e0       	ldi	r25, 0x02	; 2
    be08:	48 e2       	ldi	r20, 0x28	; 40
    be0a:	50 e0       	ldi	r21, 0x00	; 0
    be0c:	2e ef       	ldi	r18, 0xFE	; 254
    be0e:	32 e1       	ldi	r19, 0x12	; 18
    be10:	0e 94 96 b5 	call	0x16b2c	; 0x16b2c <__eewr_block>
    be14:	20 e0       	ldi	r18, 0x00	; 0
    be16:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    be18:	be 01       	movw	r22, r28
    be1a:	63 5d       	subi	r22, 0xD3	; 211
    be1c:	7f 4f       	sbci	r23, 0xFF	; 255
    be1e:	fb 01       	movw	r30, r22
    be20:	e2 0f       	add	r30, r18
    be22:	f3 1f       	adc	r31, r19
    be24:	d9 01       	movw	r26, r18
    be26:	a5 55       	subi	r26, 0x55	; 85
    be28:	b4 4f       	sbci	r27, 0xF4	; 244
    be2a:	8c 91       	ld	r24, X
    be2c:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    be2e:	2f 5f       	subi	r18, 0xFF	; 255
    be30:	3f 4f       	sbci	r19, 0xFF	; 255
    be32:	28 32       	cpi	r18, 0x28	; 40
    be34:	31 05       	cpc	r19, r1
    be36:	99 f7       	brne	.-26     	; 0xbe1e <procMessage11+0x154>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    be38:	fe 01       	movw	r30, r28
    be3a:	eb 5a       	subi	r30, 0xAB	; 171
    be3c:	ff 4f       	sbci	r31, 0xFF	; 255
    be3e:	10 82       	st	Z, r1
    be40:	82 ea       	ldi	r24, 0xA2	; 162
    be42:	92 e0       	ldi	r25, 0x02	; 2
    be44:	48 e2       	ldi	r20, 0x28	; 40
    be46:	50 e0       	ldi	r21, 0x00	; 0
    be48:	2e ef       	ldi	r18, 0xFE	; 254
    be4a:	32 e1       	ldi	r19, 0x12	; 18
    be4c:	0e 94 96 b5 	call	0x16b2c	; 0x16b2c <__eewr_block>
    be50:	20 e0       	ldi	r18, 0x00	; 0
    be52:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    be54:	be 01       	movw	r22, r28
    be56:	63 5d       	subi	r22, 0xD3	; 211
    be58:	7f 4f       	sbci	r23, 0xFF	; 255
    be5a:	fb 01       	movw	r30, r22
    be5c:	e2 0f       	add	r30, r18
    be5e:	f3 1f       	adc	r31, r19
    be60:	d9 01       	movw	r26, r18
    be62:	ad 52       	subi	r26, 0x2D	; 45
    be64:	b4 4f       	sbci	r27, 0xF4	; 244
    be66:	8c 91       	ld	r24, X
    be68:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    be6a:	2f 5f       	subi	r18, 0xFF	; 255
    be6c:	3f 4f       	sbci	r19, 0xFF	; 255
    be6e:	28 32       	cpi	r18, 0x28	; 40
    be70:	31 05       	cpc	r19, r1
    be72:	99 f7       	brne	.-26     	; 0xbe5a <procMessage11+0x190>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    be74:	fe 01       	movw	r30, r28
    be76:	eb 5a       	subi	r30, 0xAB	; 171
    be78:	ff 4f       	sbci	r31, 0xFF	; 255
    be7a:	10 82       	st	Z, r1
    be7c:	8b ec       	ldi	r24, 0xCB	; 203
    be7e:	92 e0       	ldi	r25, 0x02	; 2
    be80:	48 e2       	ldi	r20, 0x28	; 40
    be82:	50 e0       	ldi	r21, 0x00	; 0
    be84:	2e ef       	ldi	r18, 0xFE	; 254
    be86:	32 e1       	ldi	r19, 0x12	; 18
    be88:	0e 94 96 b5 	call	0x16b2c	; 0x16b2c <__eewr_block>
    be8c:	20 e0       	ldi	r18, 0x00	; 0
    be8e:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    be90:	be 01       	movw	r22, r28
    be92:	63 5d       	subi	r22, 0xD3	; 211
    be94:	7f 4f       	sbci	r23, 0xFF	; 255
    be96:	fb 01       	movw	r30, r22
    be98:	e2 0f       	add	r30, r18
    be9a:	f3 1f       	adc	r31, r19
    be9c:	d9 01       	movw	r26, r18
    be9e:	a5 50       	subi	r26, 0x05	; 5
    bea0:	b4 4f       	sbci	r27, 0xF4	; 244
    bea2:	8c 91       	ld	r24, X
    bea4:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bea6:	2f 5f       	subi	r18, 0xFF	; 255
    bea8:	3f 4f       	sbci	r19, 0xFF	; 255
    beaa:	28 32       	cpi	r18, 0x28	; 40
    beac:	31 05       	cpc	r19, r1
    beae:	99 f7       	brne	.-26     	; 0xbe96 <procMessage11+0x1cc>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    beb0:	fe 01       	movw	r30, r28
    beb2:	eb 5a       	subi	r30, 0xAB	; 171
    beb4:	ff 4f       	sbci	r31, 0xFF	; 255
    beb6:	10 82       	st	Z, r1
    beb8:	84 ef       	ldi	r24, 0xF4	; 244
    beba:	92 e0       	ldi	r25, 0x02	; 2
    bebc:	48 e2       	ldi	r20, 0x28	; 40
    bebe:	50 e0       	ldi	r21, 0x00	; 0
    bec0:	2e ef       	ldi	r18, 0xFE	; 254
    bec2:	32 e1       	ldi	r19, 0x12	; 18
    bec4:	0e 94 96 b5 	call	0x16b2c	; 0x16b2c <__eewr_block>
    bec8:	20 e0       	ldi	r18, 0x00	; 0
    beca:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    becc:	be 01       	movw	r22, r28
    bece:	63 5d       	subi	r22, 0xD3	; 211
    bed0:	7f 4f       	sbci	r23, 0xFF	; 255
    bed2:	fb 01       	movw	r30, r22
    bed4:	e2 0f       	add	r30, r18
    bed6:	f3 1f       	adc	r31, r19
    bed8:	d9 01       	movw	r26, r18
    beda:	ad 5d       	subi	r26, 0xDD	; 221
    bedc:	b3 4f       	sbci	r27, 0xF3	; 243
    bede:	8c 91       	ld	r24, X
    bee0:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bee2:	2f 5f       	subi	r18, 0xFF	; 255
    bee4:	3f 4f       	sbci	r19, 0xFF	; 255
    bee6:	28 32       	cpi	r18, 0x28	; 40
    bee8:	31 05       	cpc	r19, r1
    beea:	99 f7       	brne	.-26     	; 0xbed2 <procMessage11+0x208>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    beec:	fe 01       	movw	r30, r28
    beee:	eb 5a       	subi	r30, 0xAB	; 171
    bef0:	ff 4f       	sbci	r31, 0xFF	; 255
    bef2:	10 82       	st	Z, r1
    bef4:	8d e1       	ldi	r24, 0x1D	; 29
    bef6:	93 e0       	ldi	r25, 0x03	; 3
    bef8:	48 e2       	ldi	r20, 0x28	; 40
    befa:	50 e0       	ldi	r21, 0x00	; 0
    befc:	2e ef       	ldi	r18, 0xFE	; 254
    befe:	32 e1       	ldi	r19, 0x12	; 18
    bf00:	0e 94 96 b5 	call	0x16b2c	; 0x16b2c <__eewr_block>
    bf04:	20 e0       	ldi	r18, 0x00	; 0
    bf06:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    bf08:	be 01       	movw	r22, r28
    bf0a:	63 5d       	subi	r22, 0xD3	; 211
    bf0c:	7f 4f       	sbci	r23, 0xFF	; 255
    bf0e:	fb 01       	movw	r30, r22
    bf10:	e2 0f       	add	r30, r18
    bf12:	f3 1f       	adc	r31, r19
    bf14:	d9 01       	movw	r26, r18
    bf16:	a5 5b       	subi	r26, 0xB5	; 181
    bf18:	b3 4f       	sbci	r27, 0xF3	; 243
    bf1a:	8c 91       	ld	r24, X
    bf1c:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bf1e:	2f 5f       	subi	r18, 0xFF	; 255
    bf20:	3f 4f       	sbci	r19, 0xFF	; 255
    bf22:	28 32       	cpi	r18, 0x28	; 40
    bf24:	31 05       	cpc	r19, r1
    bf26:	99 f7       	brne	.-26     	; 0xbf0e <procMessage11+0x244>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    bf28:	fe 01       	movw	r30, r28
    bf2a:	eb 5a       	subi	r30, 0xAB	; 171
    bf2c:	ff 4f       	sbci	r31, 0xFF	; 255
    bf2e:	10 82       	st	Z, r1
    bf30:	86 e4       	ldi	r24, 0x46	; 70
    bf32:	93 e0       	ldi	r25, 0x03	; 3
    bf34:	48 e2       	ldi	r20, 0x28	; 40
    bf36:	50 e0       	ldi	r21, 0x00	; 0
    bf38:	2e ef       	ldi	r18, 0xFE	; 254
    bf3a:	32 e1       	ldi	r19, 0x12	; 18
    bf3c:	0e 94 96 b5 	call	0x16b2c	; 0x16b2c <__eewr_block>
    bf40:	20 e0       	ldi	r18, 0x00	; 0
    bf42:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    bf44:	be 01       	movw	r22, r28
    bf46:	63 5d       	subi	r22, 0xD3	; 211
    bf48:	7f 4f       	sbci	r23, 0xFF	; 255
    bf4a:	fb 01       	movw	r30, r22
    bf4c:	e2 0f       	add	r30, r18
    bf4e:	f3 1f       	adc	r31, r19
    bf50:	d9 01       	movw	r26, r18
    bf52:	ad 58       	subi	r26, 0x8D	; 141
    bf54:	b3 4f       	sbci	r27, 0xF3	; 243
    bf56:	8c 91       	ld	r24, X
    bf58:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bf5a:	2f 5f       	subi	r18, 0xFF	; 255
    bf5c:	3f 4f       	sbci	r19, 0xFF	; 255
    bf5e:	28 32       	cpi	r18, 0x28	; 40
    bf60:	31 05       	cpc	r19, r1
    bf62:	99 f7       	brne	.-26     	; 0xbf4a <procMessage11+0x280>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    bf64:	fe 01       	movw	r30, r28
    bf66:	eb 5a       	subi	r30, 0xAB	; 171
    bf68:	ff 4f       	sbci	r31, 0xFF	; 255
    bf6a:	10 82       	st	Z, r1
    bf6c:	8f e6       	ldi	r24, 0x6F	; 111
    bf6e:	93 e0       	ldi	r25, 0x03	; 3
    bf70:	48 e2       	ldi	r20, 0x28	; 40
    bf72:	50 e0       	ldi	r21, 0x00	; 0
    bf74:	2e ef       	ldi	r18, 0xFE	; 254
    bf76:	32 e1       	ldi	r19, 0x12	; 18
    bf78:	0e 94 96 b5 	call	0x16b2c	; 0x16b2c <__eewr_block>
    bf7c:	20 e0       	ldi	r18, 0x00	; 0
    bf7e:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    bf80:	be 01       	movw	r22, r28
    bf82:	63 5d       	subi	r22, 0xD3	; 211
    bf84:	7f 4f       	sbci	r23, 0xFF	; 255
    bf86:	fb 01       	movw	r30, r22
    bf88:	e2 0f       	add	r30, r18
    bf8a:	f3 1f       	adc	r31, r19
    bf8c:	d9 01       	movw	r26, r18
    bf8e:	a5 56       	subi	r26, 0x65	; 101
    bf90:	b3 4f       	sbci	r27, 0xF3	; 243
    bf92:	8c 91       	ld	r24, X
    bf94:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bf96:	2f 5f       	subi	r18, 0xFF	; 255
    bf98:	3f 4f       	sbci	r19, 0xFF	; 255
    bf9a:	28 32       	cpi	r18, 0x28	; 40
    bf9c:	31 05       	cpc	r19, r1
    bf9e:	99 f7       	brne	.-26     	; 0xbf86 <procMessage11+0x2bc>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    bfa0:	fe 01       	movw	r30, r28
    bfa2:	eb 5a       	subi	r30, 0xAB	; 171
    bfa4:	ff 4f       	sbci	r31, 0xFF	; 255
    bfa6:	10 82       	st	Z, r1
    bfa8:	88 e9       	ldi	r24, 0x98	; 152
    bfaa:	93 e0       	ldi	r25, 0x03	; 3
    bfac:	48 e2       	ldi	r20, 0x28	; 40
    bfae:	50 e0       	ldi	r21, 0x00	; 0
    bfb0:	2e ef       	ldi	r18, 0xFE	; 254
    bfb2:	32 e1       	ldi	r19, 0x12	; 18
    bfb4:	0e 94 96 b5 	call	0x16b2c	; 0x16b2c <__eewr_block>
    bfb8:	0b eb       	ldi	r16, 0xBB	; 187
    bfba:	10 e0       	ldi	r17, 0x00	; 0
    bfbc:	6b ed       	ldi	r22, 0xDB	; 219
    bfbe:	e6 2e       	mov	r14, r22
    bfc0:	6c e0       	ldi	r22, 0x0C	; 12
    bfc2:	f6 2e       	mov	r15, r22
    bfc4:	50 e2       	ldi	r21, 0x20	; 32
    bfc6:	c5 2e       	mov	r12, r21
    bfc8:	d1 2c       	mov	r13, r1
    bfca:	cc 0e       	add	r12, r28
    bfcc:	dd 1e       	adc	r13, r29
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bfce:	4c e2       	ldi	r20, 0x2C	; 44
    bfd0:	a4 2e       	mov	r10, r20
    bfd2:	b1 2c       	mov	r11, r1
    bfd4:	ac 0e       	add	r10, r28
    bfd6:	bd 1e       	adc	r11, r29
    bfd8:	f6 01       	movw	r30, r12
    bfda:	d7 01       	movw	r26, r14
	    Dest[i]=Source[IdxSource+i];
    bfdc:	8d 91       	ld	r24, X+
    bfde:	81 93       	st	Z+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bfe0:	ea 15       	cp	r30, r10
    bfe2:	fb 05       	cpc	r31, r11
    bfe4:	d9 f7       	brne	.-10     	; 0xbfdc <procMessage11+0x312>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    bfe6:	1c a6       	std	Y+44, r1	; 0x2c
     StrPosCopy(rcv_trans,buffHeader,422,40);
     eeprom_write_block((const void*) &buffHeader, (void*) &DefHeaderFooter[9], 40);
	 //ProductName
	 for(i=0;i<6;i++){
	    StrPosCopy(rcv_trans,strProductName,(486+(i*12)),12);
		RemSpaceLag(strProductName);
    bfe8:	c6 01       	movw	r24, r12
    bfea:	0e 94 4c 26 	call	0x4c98	; 0x4c98 <RemSpaceLag>
    bfee:	c8 01       	movw	r24, r16
    bff0:	b6 01       	movw	r22, r12
    bff2:	4c e0       	ldi	r20, 0x0C	; 12
    bff4:	50 e0       	ldi	r21, 0x00	; 0
    bff6:	2e ef       	ldi	r18, 0xFE	; 254
    bff8:	32 e1       	ldi	r19, 0x12	; 18
    bffa:	0e 94 96 b5 	call	0x16b2c	; 0x16b2c <__eewr_block>
    bffe:	03 5f       	subi	r16, 0xF3	; 243
    c000:	1f 4f       	sbci	r17, 0xFF	; 255
    c002:	8c e0       	ldi	r24, 0x0C	; 12
    c004:	90 e0       	ldi	r25, 0x00	; 0
    c006:	e8 0e       	add	r14, r24
    c008:	f9 1e       	adc	r15, r25
     StrPosCopy(rcv_trans,buffHeader,382,40);
     eeprom_write_block((const void*) &buffHeader, (void*) &DefHeaderFooter[8], 40);
     StrPosCopy(rcv_trans,buffHeader,422,40);
     eeprom_write_block((const void*) &buffHeader, (void*) &DefHeaderFooter[9], 40);
	 //ProductName
	 for(i=0;i<6;i++){
    c00a:	91 e0       	ldi	r25, 0x01	; 1
    c00c:	09 30       	cpi	r16, 0x09	; 9
    c00e:	19 07       	cpc	r17, r25
    c010:	19 f7       	brne	.-58     	; 0xbfd8 <procMessage11+0x30e>
    c012:	05 e8       	ldi	r16, 0x85	; 133
    c014:	10 e0       	ldi	r17, 0x00	; 0
    c016:	33 e2       	ldi	r19, 0x23	; 35
    c018:	e3 2e       	mov	r14, r19
    c01a:	3d e0       	ldi	r19, 0x0D	; 13
    c01c:	f3 2e       	mov	r15, r19
    c01e:	6e 01       	movw	r12, r28
    c020:	08 94       	sec
    c022:	c1 1c       	adc	r12, r1
    c024:	d1 1c       	adc	r13, r1
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    c026:	29 e0       	ldi	r18, 0x09	; 9
    c028:	a2 2e       	mov	r10, r18
    c02a:	b1 2c       	mov	r11, r1
    c02c:	ac 0e       	add	r10, r28
    c02e:	bd 1e       	adc	r11, r29
     StrPosCopy(rcv_trans,buffHeader,382,40);
     eeprom_write_block((const void*) &buffHeader, (void*) &DefHeaderFooter[8], 40);
     StrPosCopy(rcv_trans,buffHeader,422,40);
     eeprom_write_block((const void*) &buffHeader, (void*) &DefHeaderFooter[9], 40);
	 //ProductName
	 for(i=0;i<6;i++){
    c030:	f6 01       	movw	r30, r12
    c032:	d7 01       	movw	r26, r14
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    c034:	8d 91       	ld	r24, X+
    c036:	81 93       	st	Z+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    c038:	ea 15       	cp	r30, r10
    c03a:	fb 05       	cpc	r31, r11
    c03c:	d9 f7       	brne	.-10     	; 0xc034 <procMessage11+0x36a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    c03e:	19 86       	std	Y+9, r1	; 0x09
        eeprom_write_block((const void*) &strProductName, (void*) &DefProductName[i], 12);
	 }
	 //ProductPrice
	 for(i=0;i<6;i++){
        StrPosCopy(rcv_trans,strProductPrice,(558+(i*8)),8);
		RemSpaceLag(strProductPrice);
    c040:	c6 01       	movw	r24, r12
    c042:	0e 94 4c 26 	call	0x4c98	; 0x4c98 <RemSpaceLag>
		RemZeroLead(strProductPrice);
    c046:	c6 01       	movw	r24, r12
    c048:	0e 94 b9 25 	call	0x4b72	; 0x4b72 <RemZeroLead>
		RemDecimal(strProductPrice);
    c04c:	c6 01       	movw	r24, r12
    c04e:	0e 94 b1 24 	call	0x4962	; 0x4962 <RemDecimal>
    c052:	c8 01       	movw	r24, r16
    c054:	b6 01       	movw	r22, r12
    c056:	48 e0       	ldi	r20, 0x08	; 8
    c058:	50 e0       	ldi	r21, 0x00	; 0
    c05a:	2e ef       	ldi	r18, 0xFE	; 254
    c05c:	32 e1       	ldi	r19, 0x12	; 18
    c05e:	0e 94 96 b5 	call	0x16b2c	; 0x16b2c <__eewr_block>
    c062:	07 5f       	subi	r16, 0xF7	; 247
    c064:	1f 4f       	sbci	r17, 0xFF	; 255
    c066:	e8 e0       	ldi	r30, 0x08	; 8
    c068:	f0 e0       	ldi	r31, 0x00	; 0
    c06a:	ee 0e       	add	r14, r30
    c06c:	ff 1e       	adc	r15, r31
	    StrPosCopy(rcv_trans,strProductName,(486+(i*12)),12);
		RemSpaceLag(strProductName);
        eeprom_write_block((const void*) &strProductName, (void*) &DefProductName[i], 12);
	 }
	 //ProductPrice
	 for(i=0;i<6;i++){
    c06e:	f0 e0       	ldi	r31, 0x00	; 0
    c070:	0b 3b       	cpi	r16, 0xBB	; 187
    c072:	1f 07       	cpc	r17, r31
    c074:	e9 f6       	brne	.-70     	; 0xc030 <procMessage11+0x366>
		RemSpaceLag(strProductPrice);
		RemZeroLead(strProductPrice);
		RemDecimal(strProductPrice);
        eeprom_write_block((const void*) &strProductPrice, (void*) &DefProductPrice[i], 8);
	 }
}
    c076:	cb 5a       	subi	r28, 0xAB	; 171
    c078:	df 4f       	sbci	r29, 0xFF	; 255
    c07a:	0f b6       	in	r0, 0x3f	; 63
    c07c:	f8 94       	cli
    c07e:	de bf       	out	0x3e, r29	; 62
    c080:	0f be       	out	0x3f, r0	; 63
    c082:	cd bf       	out	0x3d, r28	; 61
    c084:	cf 91       	pop	r28
    c086:	df 91       	pop	r29
    c088:	1f 91       	pop	r17
    c08a:	0f 91       	pop	r16
    c08c:	ff 90       	pop	r15
    c08e:	ef 90       	pop	r14
    c090:	df 90       	pop	r13
    c092:	cf 90       	pop	r12
    c094:	bf 90       	pop	r11
    c096:	af 90       	pop	r10
    c098:	08 95       	ret

0000c09a <FCloseShift>:
	 }
  return Result;
}


char FCloseShift(char ShiftType){//SHIFT_NONE,NEW_SHIFT,CONTINUE_SHIFT
    c09a:	df 92       	push	r13
    c09c:	ef 92       	push	r14
    c09e:	ff 92       	push	r15
    c0a0:	0f 93       	push	r16
    c0a2:	1f 93       	push	r17
    c0a4:	df 93       	push	r29
    c0a6:	cf 93       	push	r28
    c0a8:	cd b7       	in	r28, 0x3d	; 61
    c0aa:	de b7       	in	r29, 0x3e	; 62
    c0ac:	64 97       	sbiw	r28, 0x14	; 20
    c0ae:	0f b6       	in	r0, 0x3f	; 63
    c0b0:	f8 94       	cli
    c0b2:	de bf       	out	0x3e, r29	; 62
    c0b4:	0f be       	out	0x3f, r0	; 63
    c0b6:	cd bf       	out	0x3d, r28	; 61
    c0b8:	18 2f       	mov	r17, r24
	 char KeyPressed;
	 char FIPAddr;


	 Result=MENU_NONE;
	 switch(stCloseShift){
    c0ba:	80 91 20 03 	lds	r24, 0x0320
    c0be:	87 30       	cpi	r24, 0x07	; 7
    c0c0:	09 f4       	brne	.+2      	; 0xc0c4 <FCloseShift+0x2a>
    c0c2:	a6 c1       	rjmp	.+844    	; 0xc410 <FCloseShift+0x376>
    c0c4:	88 30       	cpi	r24, 0x08	; 8
    c0c6:	78 f4       	brcc	.+30     	; 0xc0e6 <FCloseShift+0x4c>
    c0c8:	84 30       	cpi	r24, 0x04	; 4
    c0ca:	09 f4       	brne	.+2      	; 0xc0ce <FCloseShift+0x34>
    c0cc:	68 c0       	rjmp	.+208    	; 0xc19e <FCloseShift+0x104>
    c0ce:	85 30       	cpi	r24, 0x05	; 5
    c0d0:	18 f4       	brcc	.+6      	; 0xc0d8 <FCloseShift+0x3e>
    c0d2:	88 23       	and	r24, r24
    c0d4:	c1 f0       	breq	.+48     	; 0xc106 <FCloseShift+0x6c>
    c0d6:	22 c2       	rjmp	.+1092   	; 0xc51c <FCloseShift+0x482>
    c0d8:	85 30       	cpi	r24, 0x05	; 5
    c0da:	09 f4       	brne	.+2      	; 0xc0de <FCloseShift+0x44>
    c0dc:	a6 c0       	rjmp	.+332    	; 0xc22a <FCloseShift+0x190>
    c0de:	86 30       	cpi	r24, 0x06	; 6
    c0e0:	09 f0       	breq	.+2      	; 0xc0e4 <FCloseShift+0x4a>
    c0e2:	1c c2       	rjmp	.+1080   	; 0xc51c <FCloseShift+0x482>
    c0e4:	a8 c0       	rjmp	.+336    	; 0xc236 <FCloseShift+0x19c>
    c0e6:	8a 30       	cpi	r24, 0x0A	; 10
    c0e8:	09 f4       	brne	.+2      	; 0xc0ec <FCloseShift+0x52>
    c0ea:	d6 c1       	rjmp	.+940    	; 0xc498 <FCloseShift+0x3fe>
    c0ec:	8b 30       	cpi	r24, 0x0B	; 11
    c0ee:	20 f4       	brcc	.+8      	; 0xc0f8 <FCloseShift+0x5e>
    c0f0:	88 30       	cpi	r24, 0x08	; 8
    c0f2:	09 f0       	breq	.+2      	; 0xc0f6 <FCloseShift+0x5c>
    c0f4:	13 c2       	rjmp	.+1062   	; 0xc51c <FCloseShift+0x482>
    c0f6:	92 c1       	rjmp	.+804    	; 0xc41c <FCloseShift+0x382>
    c0f8:	8b 30       	cpi	r24, 0x0B	; 11
    c0fa:	09 f4       	brne	.+2      	; 0xc0fe <FCloseShift+0x64>
    c0fc:	0b c2       	rjmp	.+1046   	; 0xc514 <FCloseShift+0x47a>
    c0fe:	8c 30       	cpi	r24, 0x0C	; 12
    c100:	09 f0       	breq	.+2      	; 0xc104 <FCloseShift+0x6a>
    c102:	0c c2       	rjmp	.+1048   	; 0xc51c <FCloseShift+0x482>
    c104:	d2 c1       	rjmp	.+932    	; 0xc4aa <FCloseShift+0x410>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    c106:	e1 99       	sbic	0x1c, 1	; 28
    c108:	fe cf       	rjmp	.-4      	; 0xc106 <FCloseShift+0x6c>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    c10a:	89 e4       	ldi	r24, 0x49	; 73
    c10c:	91 e0       	ldi	r25, 0x01	; 1
    c10e:	9f bb       	out	0x1f, r25	; 31
    c110:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    c112:	e0 9a       	sbi	0x1c, 0	; 28
    c114:	8d b3       	in	r24, 0x1d	; 29
	 case csInitCloseShift:
	      ActivePump=eeprom_read_byte(&DefActivePump);
    c116:	80 93 60 01 	sts	0x0160, r24
		  IsPumpBusy=False;
    c11a:	10 92 1f 03 	sts	0x031F, r1
    c11e:	ff 24       	eor	r15, r15
					
		       if (strPumpStatus[FIPAddr]==GetPumpStatusLabel(PS_TOTALIZER))
			        UpdateStandaloneStatus(GetPumpID(FIPAddr),PUMP_OFF);
					
               if (strPumpStatus[FIPAddr]==GetPumpStatusLabel(PUMP_BUSY))
			       IsPumpBusy=True;
    c120:	dd 24       	eor	r13, r13
    c122:	d3 94       	inc	r13
    c124:	36 c0       	rjmp	.+108    	; 0xc192 <FCloseShift+0xf8>
	 case csInitCloseShift:
	      ActivePump=eeprom_read_byte(&DefActivePump);
		  IsPumpBusy=False;
		  //FindBusy Pump
		  for (FIPAddr=0;FIPAddr<ActivePump;FIPAddr++){		       
		       if ((strPumpStatus[FIPAddr]!=GetPumpStatusLabel(PUMP_NONE))&&(strPumpStatus[FIPAddr]!=GetPumpStatusLabel(PUMP_OFF))&&(strPumpStatus[FIPAddr]!=GetPumpStatusLabel(PUMP_BUSY)))
    c126:	0f 2d       	mov	r16, r15
    c128:	10 e0       	ldi	r17, 0x00	; 0
    c12a:	f8 01       	movw	r30, r16
    c12c:	ee 5e       	subi	r30, 0xEE	; 238
    c12e:	fe 4f       	sbci	r31, 0xFE	; 254
    c130:	e0 80       	ld	r14, Z
    c132:	8e e0       	ldi	r24, 0x0E	; 14
    c134:	0e 94 93 13 	call	0x2726	; 0x2726 <GetPumpStatusLabel>
    c138:	e8 16       	cp	r14, r24
    c13a:	81 f0       	breq	.+32     	; 0xc15c <FCloseShift+0xc2>
    c13c:	86 e0       	ldi	r24, 0x06	; 6
    c13e:	0e 94 93 13 	call	0x2726	; 0x2726 <GetPumpStatusLabel>
    c142:	e8 16       	cp	r14, r24
    c144:	59 f0       	breq	.+22     	; 0xc15c <FCloseShift+0xc2>
    c146:	89 e0       	ldi	r24, 0x09	; 9
    c148:	0e 94 93 13 	call	0x2726	; 0x2726 <GetPumpStatusLabel>
    c14c:	e8 16       	cp	r14, r24
    c14e:	31 f0       	breq	.+12     	; 0xc15c <FCloseShift+0xc2>
				    UpdateStandaloneStatus(GetPumpID(FIPAddr),PUMP_OFF);
    c150:	8f 2d       	mov	r24, r15
    c152:	0e 94 76 1e 	call	0x3cec	; 0x3cec <GetPumpID>
    c156:	66 e0       	ldi	r22, 0x06	; 6
    c158:	0e 94 18 1e 	call	0x3c30	; 0x3c30 <UpdateStandaloneStatus>
					
		       if (strPumpStatus[FIPAddr]==GetPumpStatusLabel(PS_TOTALIZER))
    c15c:	84 e1       	ldi	r24, 0x14	; 20
    c15e:	0e 94 93 13 	call	0x2726	; 0x2726 <GetPumpStatusLabel>
    c162:	f8 01       	movw	r30, r16
    c164:	ee 5e       	subi	r30, 0xEE	; 238
    c166:	fe 4f       	sbci	r31, 0xFE	; 254
    c168:	90 81       	ld	r25, Z
    c16a:	98 17       	cp	r25, r24
    c16c:	31 f4       	brne	.+12     	; 0xc17a <FCloseShift+0xe0>
			        UpdateStandaloneStatus(GetPumpID(FIPAddr),PUMP_OFF);
    c16e:	8f 2d       	mov	r24, r15
    c170:	0e 94 76 1e 	call	0x3cec	; 0x3cec <GetPumpID>
    c174:	66 e0       	ldi	r22, 0x06	; 6
    c176:	0e 94 18 1e 	call	0x3c30	; 0x3c30 <UpdateStandaloneStatus>
					
               if (strPumpStatus[FIPAddr]==GetPumpStatusLabel(PUMP_BUSY))
    c17a:	89 e0       	ldi	r24, 0x09	; 9
    c17c:	0e 94 93 13 	call	0x2726	; 0x2726 <GetPumpStatusLabel>
    c180:	0e 5e       	subi	r16, 0xEE	; 238
    c182:	1e 4f       	sbci	r17, 0xFE	; 254
    c184:	d8 01       	movw	r26, r16
    c186:	9c 91       	ld	r25, X
    c188:	98 17       	cp	r25, r24
    c18a:	11 f4       	brne	.+4      	; 0xc190 <FCloseShift+0xf6>
			       IsPumpBusy=True;
    c18c:	d0 92 1f 03 	sts	0x031F, r13
	 switch(stCloseShift){
	 case csInitCloseShift:
	      ActivePump=eeprom_read_byte(&DefActivePump);
		  IsPumpBusy=False;
		  //FindBusy Pump
		  for (FIPAddr=0;FIPAddr<ActivePump;FIPAddr++){		       
    c190:	f3 94       	inc	r15
    c192:	80 91 60 01 	lds	r24, 0x0160
    c196:	f8 16       	cp	r15, r24
    c198:	30 f2       	brcs	.-116    	; 0xc126 <FCloseShift+0x8c>
					
               if (strPumpStatus[FIPAddr]==GetPumpStatusLabel(PUMP_BUSY))
			       IsPumpBusy=True;
			   }

          stCloseShift=csSendTotalizerALL;
    c19a:	84 e0       	ldi	r24, 0x04	; 4
    c19c:	b8 c1       	rjmp	.+880    	; 0xc50e <FCloseShift+0x474>
			  */
	      break;
     case csWaitPumpLocked:	     
	      break;
     case csSendTotalizerALL:
	      lcd_clear();
    c19e:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
		  lcd_printf(1,1,PSTR("Totalizer.."));
    c1a2:	81 e0       	ldi	r24, 0x01	; 1
    c1a4:	61 e0       	ldi	r22, 0x01	; 1
    c1a6:	4f e9       	ldi	r20, 0x9F	; 159
    c1a8:	55 e1       	ldi	r21, 0x15	; 21
    c1aa:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		  
		  sprintf_P(lcdteks,PSTR("Wait Pump:%d "),(ActivePump-CountTotalizerSatus(strPumpStatus)));
    c1ae:	00 91 60 01 	lds	r16, 0x0160
    c1b2:	10 e0       	ldi	r17, 0x00	; 0
    c1b4:	82 e1       	ldi	r24, 0x12	; 18
    c1b6:	91 e0       	ldi	r25, 0x01	; 1
    c1b8:	0e 94 f4 30 	call	0x61e8	; 0x61e8 <CountTotalizerSatus>
    c1bc:	00 d0       	rcall	.+0      	; 0xc1be <FCloseShift+0x124>
    c1be:	00 d0       	rcall	.+0      	; 0xc1c0 <FCloseShift+0x126>
    c1c0:	00 d0       	rcall	.+0      	; 0xc1c2 <FCloseShift+0x128>
    c1c2:	ed b7       	in	r30, 0x3d	; 61
    c1c4:	fe b7       	in	r31, 0x3e	; 62
    c1c6:	31 96       	adiw	r30, 0x01	; 1
    c1c8:	7e 01       	movw	r14, r28
    c1ca:	08 94       	sec
    c1cc:	e1 1c       	adc	r14, r1
    c1ce:	f1 1c       	adc	r15, r1
    c1d0:	ad b7       	in	r26, 0x3d	; 61
    c1d2:	be b7       	in	r27, 0x3e	; 62
    c1d4:	12 96       	adiw	r26, 0x02	; 2
    c1d6:	fc 92       	st	X, r15
    c1d8:	ee 92       	st	-X, r14
    c1da:	11 97       	sbiw	r26, 0x01	; 1
    c1dc:	21 e9       	ldi	r18, 0x91	; 145
    c1de:	35 e1       	ldi	r19, 0x15	; 21
    c1e0:	33 83       	std	Z+3, r19	; 0x03
    c1e2:	22 83       	std	Z+2, r18	; 0x02
    c1e4:	08 1b       	sub	r16, r24
    c1e6:	11 09       	sbc	r17, r1
    c1e8:	15 83       	std	Z+5, r17	; 0x05
    c1ea:	04 83       	std	Z+4, r16	; 0x04
    c1ec:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
		  lcd_print(2,1,lcdteks);
    c1f0:	ed b7       	in	r30, 0x3d	; 61
    c1f2:	fe b7       	in	r31, 0x3e	; 62
    c1f4:	36 96       	adiw	r30, 0x06	; 6
    c1f6:	0f b6       	in	r0, 0x3f	; 63
    c1f8:	f8 94       	cli
    c1fa:	fe bf       	out	0x3e, r31	; 62
    c1fc:	0f be       	out	0x3f, r0	; 63
    c1fe:	ed bf       	out	0x3d, r30	; 61
    c200:	82 e0       	ldi	r24, 0x02	; 2
    c202:	61 e0       	ldi	r22, 0x01	; 1
    c204:	a7 01       	movw	r20, r14
    c206:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>


          IsNewPumpStatus=True;
    c20a:	11 e0       	ldi	r17, 0x01	; 1
    c20c:	10 93 11 01 	sts	0x0111, r17
		  DisplayPumpStatus(); 
    c210:	0e 94 4a 45 	call	0x8a94	; 0x8a94 <DisplayPumpStatus>
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    c214:	95 e0       	ldi	r25, 0x05	; 5
    c216:	90 93 8a 07 	sts	0x078A, r25
	 PoolMsg=plMsg;
    c21a:	82 e1       	ldi	r24, 0x12	; 18
    c21c:	80 93 ae 0d 	sts	0x0DAE, r24
     IsControlPooling=True;
    c220:	10 93 97 01 	sts	0x0197, r17
          IsNewPumpStatus=True;
		  DisplayPumpStatus(); 
		  //SendCommand
	      //SendSlaveCommand(SC_TOTALIZER,PUMP_ALL);          
		  SendPoolingCommand(SC_TOTALIZER,PUMP_ALL);
		  stCloseShift=csDisplayPumpStatus;
    c224:	90 93 20 03 	sts	0x0320, r25
    c228:	79 c1       	rjmp	.+754    	; 0xc51c <FCloseShift+0x482>
	      break;
     case csDisplayPumpStatus:
		  DisplayPumpStatus(); 
    c22a:	0e 94 4a 45 	call	0x8a94	; 0x8a94 <DisplayPumpStatus>
		  TimDisplay=0;         
    c22e:	10 92 a7 01 	sts	0x01A7, r1
          stCloseShift=csWaitTotalizerComplete;
    c232:	86 e0       	ldi	r24, 0x06	; 6
    c234:	6c c1       	rjmp	.+728    	; 0xc50e <FCloseShift+0x474>
	      break;
     case csWaitTotalizerComplete:
	      KeyPressed=_key_scan(1);
    c236:	81 e0       	ldi	r24, 0x01	; 1
    c238:	0e 94 06 b0 	call	0x1600c	; 0x1600c <_key_scan>
    c23c:	d8 2e       	mov	r13, r24
		  if (IsNewPumpStatus==True){
    c23e:	80 91 11 01 	lds	r24, 0x0111
    c242:	81 30       	cpi	r24, 0x01	; 1
    c244:	89 f5       	brne	.+98     	; 0xc2a8 <FCloseShift+0x20e>
			  sprintf_P(lcdteks,PSTR("Wait Pump:%d "),(ActivePump-CountTotalizerSatus(strPumpStatus)));
    c246:	00 91 60 01 	lds	r16, 0x0160
    c24a:	10 e0       	ldi	r17, 0x00	; 0
    c24c:	82 e1       	ldi	r24, 0x12	; 18
    c24e:	91 e0       	ldi	r25, 0x01	; 1
    c250:	0e 94 f4 30 	call	0x61e8	; 0x61e8 <CountTotalizerSatus>
    c254:	00 d0       	rcall	.+0      	; 0xc256 <FCloseShift+0x1bc>
    c256:	00 d0       	rcall	.+0      	; 0xc258 <FCloseShift+0x1be>
    c258:	00 d0       	rcall	.+0      	; 0xc25a <FCloseShift+0x1c0>
    c25a:	ed b7       	in	r30, 0x3d	; 61
    c25c:	fe b7       	in	r31, 0x3e	; 62
    c25e:	31 96       	adiw	r30, 0x01	; 1
    c260:	7e 01       	movw	r14, r28
    c262:	08 94       	sec
    c264:	e1 1c       	adc	r14, r1
    c266:	f1 1c       	adc	r15, r1
    c268:	ad b7       	in	r26, 0x3d	; 61
    c26a:	be b7       	in	r27, 0x3e	; 62
    c26c:	12 96       	adiw	r26, 0x02	; 2
    c26e:	fc 92       	st	X, r15
    c270:	ee 92       	st	-X, r14
    c272:	11 97       	sbiw	r26, 0x01	; 1
    c274:	23 e8       	ldi	r18, 0x83	; 131
    c276:	35 e1       	ldi	r19, 0x15	; 21
    c278:	33 83       	std	Z+3, r19	; 0x03
    c27a:	22 83       	std	Z+2, r18	; 0x02
    c27c:	08 1b       	sub	r16, r24
    c27e:	11 09       	sbc	r17, r1
    c280:	15 83       	std	Z+5, r17	; 0x05
    c282:	04 83       	std	Z+4, r16	; 0x04
    c284:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
			  lcd_print(2,1,lcdteks);
    c288:	ed b7       	in	r30, 0x3d	; 61
    c28a:	fe b7       	in	r31, 0x3e	; 62
    c28c:	36 96       	adiw	r30, 0x06	; 6
    c28e:	0f b6       	in	r0, 0x3f	; 63
    c290:	f8 94       	cli
    c292:	fe bf       	out	0x3e, r31	; 62
    c294:	0f be       	out	0x3f, r0	; 63
    c296:	ed bf       	out	0x3d, r30	; 61
    c298:	82 e0       	ldi	r24, 0x02	; 2
    c29a:	61 e0       	ldi	r22, 0x01	; 1
    c29c:	a7 01       	movw	r20, r14
    c29e:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
		  	  stCloseShift=csDisplayPumpStatus;	 
    c2a2:	85 e0       	ldi	r24, 0x05	; 5
    c2a4:	80 93 20 03 	sts	0x0320, r24
		  }
		  if ((CountTotalizerSatus(strPumpStatus)>=ActivePump)&&(TimDisplay>5)){
    c2a8:	82 e1       	ldi	r24, 0x12	; 18
    c2aa:	91 e0       	ldi	r25, 0x01	; 1
    c2ac:	0e 94 f4 30 	call	0x61e8	; 0x61e8 <CountTotalizerSatus>
    c2b0:	90 91 60 01 	lds	r25, 0x0160
    c2b4:	89 17       	cp	r24, r25
    c2b6:	a0 f0       	brcs	.+40     	; 0xc2e0 <FCloseShift+0x246>
    c2b8:	80 91 a7 01 	lds	r24, 0x01A7
    c2bc:	86 30       	cpi	r24, 0x06	; 6
    c2be:	80 f0       	brcs	.+32     	; 0xc2e0 <FCloseShift+0x246>
    c2c0:	10 e0       	ldi	r17, 0x00	; 0
    c2c2:	07 c0       	rjmp	.+14     	; 0xc2d2 <FCloseShift+0x238>
		      for (FIPAddr=0;FIPAddr<ActivePump;FIPAddr++)
			       UpdateStandaloneStatus(GetPumpID(FIPAddr),PUMP_OFF);
    c2c4:	81 2f       	mov	r24, r17
    c2c6:	0e 94 76 1e 	call	0x3cec	; 0x3cec <GetPumpID>
    c2ca:	66 e0       	ldi	r22, 0x06	; 6
    c2cc:	0e 94 18 1e 	call	0x3c30	; 0x3c30 <UpdateStandaloneStatus>
			  sprintf_P(lcdteks,PSTR("Wait Pump:%d "),(ActivePump-CountTotalizerSatus(strPumpStatus)));
			  lcd_print(2,1,lcdteks);
		  	  stCloseShift=csDisplayPumpStatus;	 
		  }
		  if ((CountTotalizerSatus(strPumpStatus)>=ActivePump)&&(TimDisplay>5)){
		      for (FIPAddr=0;FIPAddr<ActivePump;FIPAddr++)
    c2d0:	1f 5f       	subi	r17, 0xFF	; 255
    c2d2:	80 91 60 01 	lds	r24, 0x0160
    c2d6:	18 17       	cp	r17, r24
    c2d8:	a8 f3       	brcs	.-22     	; 0xc2c4 <FCloseShift+0x22a>
			       UpdateStandaloneStatus(GetPumpID(FIPAddr),PUMP_OFF);

		      stCloseShift=csGenerateReport;		      
    c2da:	88 e0       	ldi	r24, 0x08	; 8
    c2dc:	80 93 20 03 	sts	0x0320, r24
			  }
          //sprintf_P(lcdteks,PSTR("TimSend:%d"),TimDisplay);
		  //lcd_print(3,1,lcdteks);

          if ((TimDisplay>15)&&(IsPumpBusy!=True)){
    c2e0:	80 91 a7 01 	lds	r24, 0x01A7
    c2e4:	80 31       	cpi	r24, 0x10	; 16
    c2e6:	08 f4       	brcc	.+2      	; 0xc2ea <FCloseShift+0x250>
    c2e8:	67 c0       	rjmp	.+206    	; 0xc3b8 <FCloseShift+0x31e>
    c2ea:	80 91 1f 03 	lds	r24, 0x031F
    c2ee:	81 30       	cpi	r24, 0x01	; 1
    c2f0:	09 f4       	brne	.+2      	; 0xc2f4 <FCloseShift+0x25a>
    c2f2:	62 c0       	rjmp	.+196    	; 0xc3b8 <FCloseShift+0x31e>
		      if(CountNoPumpSatus(strPumpStatus)>=eeprom_read_byte(&DefActivePump)){
    c2f4:	82 e1       	ldi	r24, 0x12	; 18
    c2f6:	91 e0       	ldi	r25, 0x01	; 1
    c2f8:	0e 94 8f 16 	call	0x2d1e	; 0x2d1e <CountNoPumpSatus>
    c2fc:	28 2f       	mov	r18, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    c2fe:	e1 99       	sbic	0x1c, 1	; 28
    c300:	fe cf       	rjmp	.-4      	; 0xc2fe <FCloseShift+0x264>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    c302:	89 e4       	ldi	r24, 0x49	; 73
    c304:	91 e0       	ldi	r25, 0x01	; 1
    c306:	9f bb       	out	0x1f, r25	; 31
    c308:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    c30a:	e0 9a       	sbi	0x1c, 0	; 28
    c30c:	8d b3       	in	r24, 0x1d	; 29
    c30e:	28 17       	cp	r18, r24
    c310:	08 f4       	brcc	.+2      	; 0xc314 <FCloseShift+0x27a>
    c312:	52 c0       	rjmp	.+164    	; 0xc3b8 <FCloseShift+0x31e>
			  //lcd_printf(2,1,PSTR("NoPumpFound  ")); 
			  //sprintf_P(lcdteks,PSTR("NoPumpFound:%d"),CountNoPumpSatus(strPumpStatus));
			  sprintf_P(lcdteks,PSTR("Error - No Pump:%d "),ActivePump-CountNoPumpSatus(strPumpStatus));
    c314:	00 91 60 01 	lds	r16, 0x0160
    c318:	10 e0       	ldi	r17, 0x00	; 0
    c31a:	82 e1       	ldi	r24, 0x12	; 18
    c31c:	91 e0       	ldi	r25, 0x01	; 1
    c31e:	0e 94 8f 16 	call	0x2d1e	; 0x2d1e <CountNoPumpSatus>
    c322:	00 d0       	rcall	.+0      	; 0xc324 <FCloseShift+0x28a>
    c324:	00 d0       	rcall	.+0      	; 0xc326 <FCloseShift+0x28c>
    c326:	00 d0       	rcall	.+0      	; 0xc328 <FCloseShift+0x28e>
    c328:	ed b7       	in	r30, 0x3d	; 61
    c32a:	fe b7       	in	r31, 0x3e	; 62
    c32c:	31 96       	adiw	r30, 0x01	; 1
    c32e:	7e 01       	movw	r14, r28
    c330:	08 94       	sec
    c332:	e1 1c       	adc	r14, r1
    c334:	f1 1c       	adc	r15, r1
    c336:	ad b7       	in	r26, 0x3d	; 61
    c338:	be b7       	in	r27, 0x3e	; 62
    c33a:	12 96       	adiw	r26, 0x02	; 2
    c33c:	fc 92       	st	X, r15
    c33e:	ee 92       	st	-X, r14
    c340:	11 97       	sbiw	r26, 0x01	; 1
    c342:	2f e6       	ldi	r18, 0x6F	; 111
    c344:	35 e1       	ldi	r19, 0x15	; 21
    c346:	33 83       	std	Z+3, r19	; 0x03
    c348:	22 83       	std	Z+2, r18	; 0x02
    c34a:	08 1b       	sub	r16, r24
    c34c:	11 09       	sbc	r17, r1
    c34e:	15 83       	std	Z+5, r17	; 0x05
    c350:	04 83       	std	Z+4, r16	; 0x04
    c352:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
			  lcd_print(3,1,lcdteks);
    c356:	ed b7       	in	r30, 0x3d	; 61
    c358:	fe b7       	in	r31, 0x3e	; 62
    c35a:	36 96       	adiw	r30, 0x06	; 6
    c35c:	0f b6       	in	r0, 0x3f	; 63
    c35e:	f8 94       	cli
    c360:	fe bf       	out	0x3e, r31	; 62
    c362:	0f be       	out	0x3f, r0	; 63
    c364:	ed bf       	out	0x3d, r30	; 61
    c366:	83 e0       	ldi	r24, 0x03	; 3
    c368:	61 e0       	ldi	r22, 0x01	; 1
    c36a:	a7 01       	movw	r20, r14
    c36c:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
    c370:	10 e0       	ldi	r17, 0x00	; 0
    c372:	11 c0       	rjmp	.+34     	; 0xc396 <FCloseShift+0x2fc>
			  
			  for (FIPAddr=0;FIPAddr<ActivePump;FIPAddr++){
		           if (strPumpStatus[FIPAddr]==GetPumpStatusLabel(PS_TOTALIZER))
    c374:	84 e1       	ldi	r24, 0x14	; 20
    c376:	0e 94 93 13 	call	0x2726	; 0x2726 <GetPumpStatusLabel>
    c37a:	e1 2f       	mov	r30, r17
    c37c:	f0 e0       	ldi	r31, 0x00	; 0
    c37e:	ee 5e       	subi	r30, 0xEE	; 238
    c380:	fe 4f       	sbci	r31, 0xFE	; 254
    c382:	90 81       	ld	r25, Z
    c384:	98 17       	cp	r25, r24
    c386:	31 f4       	brne	.+12     	; 0xc394 <FCloseShift+0x2fa>
			           UpdateStandaloneStatus(GetPumpID(FIPAddr),PUMP_OFF);
    c388:	81 2f       	mov	r24, r17
    c38a:	0e 94 76 1e 	call	0x3cec	; 0x3cec <GetPumpID>
    c38e:	66 e0       	ldi	r22, 0x06	; 6
    c390:	0e 94 18 1e 	call	0x3c30	; 0x3c30 <UpdateStandaloneStatus>
			  //lcd_printf(2,1,PSTR("NoPumpFound  ")); 
			  //sprintf_P(lcdteks,PSTR("NoPumpFound:%d"),CountNoPumpSatus(strPumpStatus));
			  sprintf_P(lcdteks,PSTR("Error - No Pump:%d "),ActivePump-CountNoPumpSatus(strPumpStatus));
			  lcd_print(3,1,lcdteks);
			  
			  for (FIPAddr=0;FIPAddr<ActivePump;FIPAddr++){
    c394:	1f 5f       	subi	r17, 0xFF	; 255
    c396:	80 91 60 01 	lds	r24, 0x0160
    c39a:	18 17       	cp	r17, r24
    c39c:	58 f3       	brcs	.-42     	; 0xc374 <FCloseShift+0x2da>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    c39e:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    c3a0:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    c3a2:	81 e0       	ldi	r24, 0x01	; 1
    c3a4:	90 e0       	ldi	r25, 0x00	; 0
    c3a6:	90 93 d7 01 	sts	0x01D7, r25
    c3aa:	80 93 d6 01 	sts	0x01D6, r24
		           if (strPumpStatus[FIPAddr]==GetPumpStatusLabel(PS_TOTALIZER))
			           UpdateStandaloneStatus(GetPumpID(FIPAddr),PUMP_OFF);
			  }

			  system_beep(1);
			  TimDisplay=0;
    c3ae:	10 92 a7 01 	sts	0x01A7, r1
			  stCloseShift=csNoPumpFound;		     
    c3b2:	87 e0       	ldi	r24, 0x07	; 7
    c3b4:	80 93 20 03 	sts	0x0320, r24
			  }			  
		  }
		  if (KeyPressed==_KEY_CANCEL){
    c3b8:	f7 ee       	ldi	r31, 0xE7	; 231
    c3ba:	df 16       	cp	r13, r31
    c3bc:	09 f0       	breq	.+2      	; 0xc3c0 <FCloseShift+0x326>
    c3be:	ae c0       	rjmp	.+348    	; 0xc51c <FCloseShift+0x482>
			  sprintf_P(lcdteks,PSTR("Cancel"));
    c3c0:	00 d0       	rcall	.+0      	; 0xc3c2 <FCloseShift+0x328>
    c3c2:	00 d0       	rcall	.+0      	; 0xc3c4 <FCloseShift+0x32a>
    c3c4:	8e 01       	movw	r16, r28
    c3c6:	0f 5f       	subi	r16, 0xFF	; 255
    c3c8:	1f 4f       	sbci	r17, 0xFF	; 255
    c3ca:	ad b7       	in	r26, 0x3d	; 61
    c3cc:	be b7       	in	r27, 0x3e	; 62
    c3ce:	12 96       	adiw	r26, 0x02	; 2
    c3d0:	1c 93       	st	X, r17
    c3d2:	0e 93       	st	-X, r16
    c3d4:	11 97       	sbiw	r26, 0x01	; 1
    c3d6:	88 e6       	ldi	r24, 0x68	; 104
    c3d8:	95 e1       	ldi	r25, 0x15	; 21
    c3da:	14 96       	adiw	r26, 0x04	; 4
    c3dc:	9c 93       	st	X, r25
    c3de:	8e 93       	st	-X, r24
    c3e0:	13 97       	sbiw	r26, 0x03	; 3
    c3e2:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
			  lcd_print(3,1,lcdteks);
    c3e6:	0f 90       	pop	r0
    c3e8:	0f 90       	pop	r0
    c3ea:	0f 90       	pop	r0
    c3ec:	0f 90       	pop	r0
    c3ee:	83 e0       	ldi	r24, 0x03	; 3
    c3f0:	61 e0       	ldi	r22, 0x01	; 1
    c3f2:	a8 01       	movw	r20, r16
    c3f4:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    c3f8:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    c3fa:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    c3fc:	81 e0       	ldi	r24, 0x01	; 1
    c3fe:	90 e0       	ldi	r25, 0x00	; 0
    c400:	90 93 d7 01 	sts	0x01D7, r25
    c404:	80 93 d6 01 	sts	0x01D6, r24
		  }
		  if (KeyPressed==_KEY_CANCEL){
			  sprintf_P(lcdteks,PSTR("Cancel"));
			  lcd_print(3,1,lcdteks);
			  system_beep(1);
			  TimDisplay=0;
    c408:	10 92 a7 01 	sts	0x01A7, r1
			  stCloseShift=csNoPumpFound;		     		  
    c40c:	87 e0       	ldi	r24, 0x07	; 7
    c40e:	7f c0       	rjmp	.+254    	; 0xc50e <FCloseShift+0x474>
		  }
	      break;
     case csNoPumpFound:
	      if (TimDisplay>TIM_DISPLAY){
    c410:	80 91 a7 01 	lds	r24, 0x01A7
    c414:	8b 30       	cpi	r24, 0x0B	; 11
    c416:	08 f4       	brcc	.+2      	; 0xc41a <FCloseShift+0x380>
    c418:	81 c0       	rjmp	.+258    	; 0xc51c <FCloseShift+0x482>
    c41a:	78 c0       	rjmp	.+240    	; 0xc50c <FCloseShift+0x472>
		      stCloseShift=csFinishCloseShift;
		  }	      
	      break;
     case csGenerateReport:
		  lcd_printf(1,1,PSTR("Printing Totalizer"));
    c41c:	81 e0       	ldi	r24, 0x01	; 1
    c41e:	61 e0       	ldi	r22, 0x01	; 1
    c420:	45 e5       	ldi	r20, 0x55	; 85
    c422:	55 e1       	ldi	r21, 0x15	; 21
    c424:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
          _datetime(0, strSystemDate, strSystemTime);
    c428:	0a e9       	ldi	r16, 0x9A	; 154
    c42a:	15 e0       	ldi	r17, 0x05	; 5
    c42c:	79 e7       	ldi	r23, 0x79	; 121
    c42e:	e7 2e       	mov	r14, r23
    c430:	7a e0       	ldi	r23, 0x0A	; 10
    c432:	f7 2e       	mov	r15, r23
    c434:	80 e0       	ldi	r24, 0x00	; 0
    c436:	b8 01       	movw	r22, r16
    c438:	a7 01       	movw	r20, r14
    c43a:	0e 94 d1 b2 	call	0x165a2	; 0x165a2 <_datetime>
		  sprintf_P(CurrentShiftDateTime,PSTR("%s %s"),strSystemDate,strSystemTime);
    c43e:	ed b7       	in	r30, 0x3d	; 61
    c440:	fe b7       	in	r31, 0x3e	; 62
    c442:	38 97       	sbiw	r30, 0x08	; 8
    c444:	0f b6       	in	r0, 0x3f	; 63
    c446:	f8 94       	cli
    c448:	fe bf       	out	0x3e, r31	; 62
    c44a:	0f be       	out	0x3f, r0	; 63
    c44c:	ed bf       	out	0x3d, r30	; 61
    c44e:	31 96       	adiw	r30, 0x01	; 1
    c450:	81 e7       	ldi	r24, 0x71	; 113
    c452:	99 e0       	ldi	r25, 0x09	; 9
    c454:	ad b7       	in	r26, 0x3d	; 61
    c456:	be b7       	in	r27, 0x3e	; 62
    c458:	12 96       	adiw	r26, 0x02	; 2
    c45a:	9c 93       	st	X, r25
    c45c:	8e 93       	st	-X, r24
    c45e:	11 97       	sbiw	r26, 0x01	; 1
    c460:	8f e4       	ldi	r24, 0x4F	; 79
    c462:	95 e1       	ldi	r25, 0x15	; 21
    c464:	93 83       	std	Z+3, r25	; 0x03
    c466:	82 83       	std	Z+2, r24	; 0x02
    c468:	15 83       	std	Z+5, r17	; 0x05
    c46a:	04 83       	std	Z+4, r16	; 0x04
    c46c:	f7 82       	std	Z+7, r15	; 0x07
    c46e:	e6 82       	std	Z+6, r14	; 0x06
    c470:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
		  IsGenerateReport=True;
    c474:	81 e0       	ldi	r24, 0x01	; 1
    c476:	80 93 99 01 	sts	0x0199, r24
		  IsFinishPrintingTotalizer=False;
    c47a:	10 92 9a 01 	sts	0x019A, r1
		  stCloseShift=csWaitPrintTotalizerComplete;
    c47e:	8a e0       	ldi	r24, 0x0A	; 10
    c480:	80 93 20 03 	sts	0x0320, r24
    c484:	80 e0       	ldi	r24, 0x00	; 0
    c486:	ed b7       	in	r30, 0x3d	; 61
    c488:	fe b7       	in	r31, 0x3e	; 62
    c48a:	38 96       	adiw	r30, 0x08	; 8
    c48c:	0f b6       	in	r0, 0x3f	; 63
    c48e:	f8 94       	cli
    c490:	fe bf       	out	0x3e, r31	; 62
    c492:	0f be       	out	0x3f, r0	; 63
    c494:	ed bf       	out	0x3d, r30	; 61
    c496:	43 c0       	rjmp	.+134    	; 0xc51e <FCloseShift+0x484>
	      break;
     case csWaitTotalizerALL:
	      break;
     case csWaitPrintTotalizerComplete:
	      if (IsFinishPrintingTotalizer==True){
    c498:	80 91 9a 01 	lds	r24, 0x019A
    c49c:	81 30       	cpi	r24, 0x01	; 1
    c49e:	09 f0       	breq	.+2      	; 0xc4a2 <FCloseShift+0x408>
    c4a0:	3d c0       	rjmp	.+122    	; 0xc51c <FCloseShift+0x482>
		      IsFinishPrintingTotalizer=False;
    c4a2:	10 92 9a 01 	sts	0x019A, r1
		      stCloseShift=csDumpShift;
    c4a6:	8c e0       	ldi	r24, 0x0C	; 12
    c4a8:	32 c0       	rjmp	.+100    	; 0xc50e <FCloseShift+0x474>
		  }
	      break;
     case csDumpShift://Increment CurrentShift save Current to Last
		  lcd_printf(1,1,PSTR("Saving ShiftData.. "));
    c4aa:	81 e0       	ldi	r24, 0x01	; 1
    c4ac:	61 e0       	ldi	r22, 0x01	; 1
    c4ae:	4b e3       	ldi	r20, 0x3B	; 59
    c4b0:	55 e1       	ldi	r21, 0x15	; 21
    c4b2:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
	      if (ShiftType==CONTINUE_SHIFT)//Shift=Shift+1
    c4b6:	12 30       	cpi	r17, 0x02	; 2
    c4b8:	71 f4       	brne	.+28     	; 0xc4d6 <FCloseShift+0x43c>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    c4ba:	e1 99       	sbic	0x1c, 1	; 28
    c4bc:	fe cf       	rjmp	.-4      	; 0xc4ba <FCloseShift+0x420>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    c4be:	2f e3       	ldi	r18, 0x3F	; 63
    c4c0:	31 e0       	ldi	r19, 0x01	; 1
    c4c2:	3f bb       	out	0x1f, r19	; 31
    c4c4:	2e bb       	out	0x1e, r18	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    c4c6:	e0 9a       	sbi	0x1c, 0	; 28
    c4c8:	8d b3       	in	r24, 0x1d	; 29
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    c4ca:	e1 99       	sbic	0x1c, 1	; 28
    c4cc:	fe cf       	rjmp	.-4      	; 0xc4ca <FCloseShift+0x430>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    c4ce:	3f bb       	out	0x1f, r19	; 31
    c4d0:	2e bb       	out	0x1e, r18	; 30
		      eeprom_write_byte(&DefShift,eeprom_read_byte(&DefShift)+1);	 
    c4d2:	8f 5f       	subi	r24, 0xFF	; 255
    c4d4:	09 c0       	rjmp	.+18     	; 0xc4e8 <FCloseShift+0x44e>
          else if (ShiftType==NEW_SHIFT)//Shift=1
    c4d6:	11 30       	cpi	r17, 0x01	; 1
    c4d8:	69 f4       	brne	.+26     	; 0xc4f4 <FCloseShift+0x45a>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    c4da:	e1 99       	sbic	0x1c, 1	; 28
    c4dc:	fe cf       	rjmp	.-4      	; 0xc4da <FCloseShift+0x440>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    c4de:	8f e3       	ldi	r24, 0x3F	; 63
    c4e0:	91 e0       	ldi	r25, 0x01	; 1
    c4e2:	9f bb       	out	0x1f, r25	; 31
    c4e4:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    c4e6:	81 e0       	ldi	r24, 0x01	; 1
    c4e8:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    c4ea:	0f b6       	in	r0, 0x3f	; 63
    c4ec:	f8 94       	cli
    c4ee:	e2 9a       	sbi	0x1c, 2	; 28
    c4f0:	e1 9a       	sbi	0x1c, 1	; 28
    c4f2:	0f be       	out	0x3f, r0	; 63
		      eeprom_write_byte(&DefShift,1);	 

          SaveTotalizerCurrentToLast();
    c4f4:	0e 94 0d 29 	call	0x521a	; 0x521a <SaveTotalizerCurrentToLast>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    c4f8:	83 e4       	ldi	r24, 0x43	; 67
    c4fa:	98 e0       	ldi	r25, 0x08	; 8
    c4fc:	61 e7       	ldi	r22, 0x71	; 113
    c4fe:	79 e0       	ldi	r23, 0x09	; 9
    c500:	44 e1       	ldi	r20, 0x14	; 20
    c502:	50 e0       	ldi	r21, 0x00	; 0
    c504:	2e ef       	ldi	r18, 0xFE	; 254
    c506:	32 e1       	ldi	r19, 0x12	; 18
    c508:	0e 94 96 b5 	call	0x16b2c	; 0x16b2c <__eewr_block>
          eeprom_write_block((const void*) &CurrentShiftDateTime, (void*) &DefLastShiftDateTime,sizeof(DefLastShiftDateTime));
		  stCloseShift=csFinishCloseShift;
    c50c:	8b e0       	ldi	r24, 0x0B	; 11
    c50e:	80 93 20 03 	sts	0x0320, r24
    c512:	04 c0       	rjmp	.+8      	; 0xc51c <FCloseShift+0x482>
	      break;
     case csFinishCloseShift:
          stCloseShift=csInitCloseShift;
    c514:	10 92 20 03 	sts	0x0320, r1
    c518:	81 e0       	ldi	r24, 0x01	; 1
    c51a:	01 c0       	rjmp	.+2      	; 0xc51e <FCloseShift+0x484>
    c51c:	80 e0       	ldi	r24, 0x00	; 0
		  Result=MENU_DONE;
	      break;
	 }
	 //_uart_printf(0,1,PSTR("Close Shift"));	
   return Result;
}
    c51e:	64 96       	adiw	r28, 0x14	; 20
    c520:	0f b6       	in	r0, 0x3f	; 63
    c522:	f8 94       	cli
    c524:	de bf       	out	0x3e, r29	; 62
    c526:	0f be       	out	0x3f, r0	; 63
    c528:	cd bf       	out	0x3d, r28	; 61
    c52a:	cf 91       	pop	r28
    c52c:	df 91       	pop	r29
    c52e:	1f 91       	pop	r17
    c530:	0f 91       	pop	r16
    c532:	ff 90       	pop	r15
    c534:	ef 90       	pop	r14
    c536:	df 90       	pop	r13
    c538:	08 95       	ret

0000c53a <FMenuShift>:
     char SubMenu,KeyChar,KeyPressed;

     char Result;

Result=MENU_NONE;
     switch(stMenuShift){
    c53a:	80 91 21 03 	lds	r24, 0x0321
    c53e:	82 30       	cpi	r24, 0x02	; 2
    c540:	09 f4       	brne	.+2      	; 0xc544 <FMenuShift+0xa>
    c542:	48 c0       	rjmp	.+144    	; 0xc5d4 <FMenuShift+0x9a>
    c544:	83 30       	cpi	r24, 0x03	; 3
    c546:	30 f4       	brcc	.+12     	; 0xc554 <FMenuShift+0x1a>
    c548:	88 23       	and	r24, r24
    c54a:	69 f0       	breq	.+26     	; 0xc566 <FMenuShift+0x2c>
    c54c:	81 30       	cpi	r24, 0x01	; 1
    c54e:	09 f0       	breq	.+2      	; 0xc552 <FMenuShift+0x18>
    c550:	50 c0       	rjmp	.+160    	; 0xc5f2 <FMenuShift+0xb8>
    c552:	25 c0       	rjmp	.+74     	; 0xc59e <FMenuShift+0x64>
    c554:	84 30       	cpi	r24, 0x04	; 4
    c556:	09 f4       	brne	.+2      	; 0xc55a <FMenuShift+0x20>
    c558:	4c c0       	rjmp	.+152    	; 0xc5f2 <FMenuShift+0xb8>
    c55a:	84 30       	cpi	r24, 0x04	; 4
    c55c:	e8 f1       	brcs	.+122    	; 0xc5d8 <FMenuShift+0x9e>
    c55e:	85 30       	cpi	r24, 0x05	; 5
    c560:	09 f0       	breq	.+2      	; 0xc564 <FMenuShift+0x2a>
    c562:	47 c0       	rjmp	.+142    	; 0xc5f2 <FMenuShift+0xb8>
    c564:	42 c0       	rjmp	.+132    	; 0xc5ea <FMenuShift+0xb0>
	 case msInitMenuShift:
	      lcd_clear();
    c566:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
		  lcd_printf(1,1,PSTR("1.Close Shift"));
    c56a:	81 e0       	ldi	r24, 0x01	; 1
    c56c:	61 e0       	ldi	r22, 0x01	; 1
    c56e:	4e ec       	ldi	r20, 0xCE	; 206
    c570:	55 e1       	ldi	r21, 0x15	; 21
    c572:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		  lcd_printf(2,1,PSTR("2.Close Day  "));
    c576:	82 e0       	ldi	r24, 0x02	; 2
    c578:	61 e0       	ldi	r22, 0x01	; 1
    c57a:	40 ec       	ldi	r20, 0xC0	; 192
    c57c:	55 e1       	ldi	r21, 0x15	; 21
    c57e:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		  lcd_printf(3,1,PSTR("3.Lock Pump  "));
    c582:	83 e0       	ldi	r24, 0x03	; 3
    c584:	61 e0       	ldi	r22, 0x01	; 1
    c586:	42 eb       	ldi	r20, 0xB2	; 178
    c588:	55 e1       	ldi	r21, 0x15	; 21
    c58a:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		  lcd_printf(4,1,PSTR("*)Exit"));
    c58e:	84 e0       	ldi	r24, 0x04	; 4
    c590:	61 e0       	ldi	r22, 0x01	; 1
    c592:	4b ea       	ldi	r20, 0xAB	; 171
    c594:	55 e1       	ldi	r21, 0x15	; 21
    c596:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		  stMenuShift=msSelectShift;
    c59a:	81 e0       	ldi	r24, 0x01	; 1
    c59c:	18 c0       	rjmp	.+48     	; 0xc5ce <FMenuShift+0x94>
	      break;
     case msSelectShift:
          KeyPressed=_key_scan(1);
    c59e:	81 e0       	ldi	r24, 0x01	; 1
    c5a0:	0e 94 06 b0 	call	0x1600c	; 0x1600c <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
    c5a4:	0e 94 67 af 	call	0x15ece	; 0x15ece <_key_btn>
          switch(KeyChar){
    c5a8:	82 33       	cpi	r24, 0x32	; 50
    c5aa:	61 f0       	breq	.+24     	; 0xc5c4 <FMenuShift+0x8a>
    c5ac:	83 33       	cpi	r24, 0x33	; 51
    c5ae:	28 f4       	brcc	.+10     	; 0xc5ba <FMenuShift+0x80>
    c5b0:	8a 32       	cpi	r24, 0x2A	; 42
    c5b2:	61 f0       	breq	.+24     	; 0xc5cc <FMenuShift+0x92>
    c5b4:	81 33       	cpi	r24, 0x31	; 49
    c5b6:	e9 f4       	brne	.+58     	; 0xc5f2 <FMenuShift+0xb8>
    c5b8:	03 c0       	rjmp	.+6      	; 0xc5c0 <FMenuShift+0x86>
    c5ba:	83 33       	cpi	r24, 0x33	; 51
    c5bc:	d1 f4       	brne	.+52     	; 0xc5f2 <FMenuShift+0xb8>
    c5be:	04 c0       	rjmp	.+8      	; 0xc5c8 <FMenuShift+0x8e>
		  case '1':
		       SubMenu=MENU_NONE;
		       stMenuShift=msCloseShift;
    c5c0:	82 e0       	ldi	r24, 0x02	; 2
    c5c2:	05 c0       	rjmp	.+10     	; 0xc5ce <FMenuShift+0x94>
		       break; 
		  case '2':
		       SubMenu=MENU_NONE;
		       stMenuShift=msCloseDay;
    c5c4:	83 e0       	ldi	r24, 0x03	; 3
    c5c6:	03 c0       	rjmp	.+6      	; 0xc5ce <FMenuShift+0x94>
		       break; 
		  case '3':
		       SubMenu=MENU_NONE;
		       stMenuShift=msLockPump;
    c5c8:	84 e0       	ldi	r24, 0x04	; 4
    c5ca:	01 c0       	rjmp	.+2      	; 0xc5ce <FMenuShift+0x94>
		       break; 
		  case '*':
		       stMenuShift=msExitShift;
    c5cc:	85 e0       	ldi	r24, 0x05	; 5
    c5ce:	80 93 21 03 	sts	0x0321, r24
    c5d2:	09 c0       	rjmp	.+18     	; 0xc5e6 <FMenuShift+0xac>
		       break; 			   		  
		  }
		  break;
     case msCloseShift:
	      SubMenu=FCloseShift(CONTINUE_SHIFT);
    c5d4:	82 e0       	ldi	r24, 0x02	; 2
    c5d6:	01 c0       	rjmp	.+2      	; 0xc5da <FMenuShift+0xa0>
		  if (SubMenu==MENU_DONE)stMenuShift=msInitMenuShift;
		  //IsGenerateReport=True;		  
	      break;
     case msCloseDay:
	      SubMenu=FCloseShift(NEW_SHIFT);
    c5d8:	81 e0       	ldi	r24, 0x01	; 1
    c5da:	0e 94 4d 60 	call	0xc09a	; 0xc09a <FCloseShift>
		  if (SubMenu==MENU_DONE)stMenuShift=msInitMenuShift;
    c5de:	81 30       	cpi	r24, 0x01	; 1
    c5e0:	41 f4       	brne	.+16     	; 0xc5f2 <FMenuShift+0xb8>
    c5e2:	10 92 21 03 	sts	0x0321, r1
    c5e6:	80 e0       	ldi	r24, 0x00	; 0
    c5e8:	08 95       	ret
     case msLockPump:
	      SubMenu=FLockPump();
		  if (SubMenu==MENU_DONE)stMenuShift=msInitMenuShift;
	      break;
     case msExitShift:
          stMenuShift=msInitMenuShift;
    c5ea:	10 92 21 03 	sts	0x0321, r1
    c5ee:	81 e0       	ldi	r24, 0x01	; 1
    c5f0:	08 95       	ret
    c5f2:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;	 
	 } 
   return Result;
}
    c5f4:	08 95       	ret

0000c5f6 <DisplayDateTime>:

void DisplayQueueFIP(){// FIP:#1#2#3#4#5

}

void DisplayDateTime(){
    c5f6:	cf 92       	push	r12
    c5f8:	df 92       	push	r13
    c5fa:	ef 92       	push	r14
    c5fc:	ff 92       	push	r15
    c5fe:	0f 93       	push	r16
    c600:	1f 93       	push	r17
    c602:	df 93       	push	r29
    c604:	cf 93       	push	r28
    c606:	cd b7       	in	r28, 0x3d	; 61
    c608:	de b7       	in	r29, 0x3e	; 62
    c60a:	64 97       	sbiw	r28, 0x14	; 20
    c60c:	0f b6       	in	r0, 0x3f	; 63
    c60e:	f8 94       	cli
    c610:	de bf       	out	0x3e, r29	; 62
    c612:	0f be       	out	0x3f, r0	; 63
    c614:	cd bf       	out	0x3d, r28	; 61
char lcdteks[20];
	 _datetime(0, strSystemDate, strSystemTime);
    c616:	fa e9       	ldi	r31, 0x9A	; 154
    c618:	ef 2e       	mov	r14, r31
    c61a:	f5 e0       	ldi	r31, 0x05	; 5
    c61c:	ff 2e       	mov	r15, r31
    c61e:	e9 e7       	ldi	r30, 0x79	; 121
    c620:	ce 2e       	mov	r12, r30
    c622:	ea e0       	ldi	r30, 0x0A	; 10
    c624:	de 2e       	mov	r13, r30
    c626:	80 e0       	ldi	r24, 0x00	; 0
    c628:	b7 01       	movw	r22, r14
    c62a:	a6 01       	movw	r20, r12
    c62c:	0e 94 d1 b2 	call	0x165a2	; 0x165a2 <_datetime>
	 sprintf_P(lcdteks,PSTR("%s %s"),strSystemDate,strSystemTime);
    c630:	8d b7       	in	r24, 0x3d	; 61
    c632:	9e b7       	in	r25, 0x3e	; 62
    c634:	08 97       	sbiw	r24, 0x08	; 8
    c636:	0f b6       	in	r0, 0x3f	; 63
    c638:	f8 94       	cli
    c63a:	9e bf       	out	0x3e, r25	; 62
    c63c:	0f be       	out	0x3f, r0	; 63
    c63e:	8d bf       	out	0x3d, r24	; 61
    c640:	ed b7       	in	r30, 0x3d	; 61
    c642:	fe b7       	in	r31, 0x3e	; 62
    c644:	31 96       	adiw	r30, 0x01	; 1
    c646:	8e 01       	movw	r16, r28
    c648:	0f 5f       	subi	r16, 0xFF	; 255
    c64a:	1f 4f       	sbci	r17, 0xFF	; 255
    c64c:	ad b7       	in	r26, 0x3d	; 61
    c64e:	be b7       	in	r27, 0x3e	; 62
    c650:	12 96       	adiw	r26, 0x02	; 2
    c652:	1c 93       	st	X, r17
    c654:	0e 93       	st	-X, r16
    c656:	11 97       	sbiw	r26, 0x01	; 1
    c658:	87 e1       	ldi	r24, 0x17	; 23
    c65a:	9c e1       	ldi	r25, 0x1C	; 28
    c65c:	93 83       	std	Z+3, r25	; 0x03
    c65e:	82 83       	std	Z+2, r24	; 0x02
    c660:	f5 82       	std	Z+5, r15	; 0x05
    c662:	e4 82       	std	Z+4, r14	; 0x04
    c664:	d7 82       	std	Z+7, r13	; 0x07
    c666:	c6 82       	std	Z+6, r12	; 0x06
    c668:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
	 lcd_print(2, 1, lcdteks);
    c66c:	8d b7       	in	r24, 0x3d	; 61
    c66e:	9e b7       	in	r25, 0x3e	; 62
    c670:	08 96       	adiw	r24, 0x08	; 8
    c672:	0f b6       	in	r0, 0x3f	; 63
    c674:	f8 94       	cli
    c676:	9e bf       	out	0x3e, r25	; 62
    c678:	0f be       	out	0x3f, r0	; 63
    c67a:	8d bf       	out	0x3d, r24	; 61
    c67c:	82 e0       	ldi	r24, 0x02	; 2
    c67e:	61 e0       	ldi	r22, 0x01	; 1
    c680:	a8 01       	movw	r20, r16
    c682:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
}
    c686:	64 96       	adiw	r28, 0x14	; 20
    c688:	0f b6       	in	r0, 0x3f	; 63
    c68a:	f8 94       	cli
    c68c:	de bf       	out	0x3e, r29	; 62
    c68e:	0f be       	out	0x3f, r0	; 63
    c690:	cd bf       	out	0x3d, r28	; 61
    c692:	cf 91       	pop	r28
    c694:	df 91       	pop	r29
    c696:	1f 91       	pop	r17
    c698:	0f 91       	pop	r16
    c69a:	ff 90       	pop	r15
    c69c:	ef 90       	pop	r14
    c69e:	df 90       	pop	r13
    c6a0:	cf 90       	pop	r12
    c6a2:	08 95       	ret

0000c6a4 <_menu_datetime>:
		}
	}
}


void _menu_datetime(void){
    c6a4:	8f 92       	push	r8
    c6a6:	9f 92       	push	r9
    c6a8:	af 92       	push	r10
    c6aa:	bf 92       	push	r11
    c6ac:	cf 92       	push	r12
    c6ae:	df 92       	push	r13
    c6b0:	ef 92       	push	r14
    c6b2:	ff 92       	push	r15
    c6b4:	0f 93       	push	r16
    c6b6:	1f 93       	push	r17
    c6b8:	df 93       	push	r29
    c6ba:	cf 93       	push	r28
    c6bc:	cd b7       	in	r28, 0x3d	; 61
    c6be:	de b7       	in	r29, 0x3e	; 62
    c6c0:	c2 54       	subi	r28, 0x42	; 66
    c6c2:	d0 40       	sbci	r29, 0x00	; 0
    c6c4:	0f b6       	in	r0, 0x3f	; 63
    c6c6:	f8 94       	cli
    c6c8:	de bf       	out	0x3e, r29	; 62
    c6ca:	0f be       	out	0x3f, r0	; 63
    c6cc:	cd bf       	out	0x3d, r28	; 61
	char	__key, __chr;
	char	__date[9];
	char	__time[9];
	char	__map[12][4] = {	{1,  8, 0, 3}, {1,  9, 0, 9}, {1, 11, 0, 1}, {1, 12, 0, 9},
								{1, 14, 0, 9}, {1, 15, 0, 9}, {2,  8, 0, 2}, {2,  9, 0, 9},
								{2, 11, 0, 5}, {2, 12, 0, 9}, {2, 14, 0, 5}, {2, 15, 0, 9}};
    c6ce:	de 01       	movw	r26, r28
    c6d0:	53 96       	adiw	r26, 0x13	; 19
    c6d2:	e6 e2       	ldi	r30, 0x26	; 38
    c6d4:	f1 e0       	ldi	r31, 0x01	; 1
    c6d6:	80 e3       	ldi	r24, 0x30	; 48
    c6d8:	01 90       	ld	r0, Z+
    c6da:	0d 92       	st	X+, r0
    c6dc:	81 50       	subi	r24, 0x01	; 1
    c6de:	e1 f7       	brne	.-8      	; 0xc6d8 <_menu_datetime+0x34>

	_datetime(_DATETIME_READ, __date, __time);
    c6e0:	8e 01       	movw	r16, r28
    c6e2:	0f 5f       	subi	r16, 0xFF	; 255
    c6e4:	1f 4f       	sbci	r17, 0xFF	; 255
    c6e6:	b8 01       	movw	r22, r16
    c6e8:	ae 01       	movw	r20, r28
    c6ea:	46 5f       	subi	r20, 0xF6	; 246
    c6ec:	5f 4f       	sbci	r21, 0xFF	; 255
    c6ee:	0e 94 d1 b2 	call	0x165a2	; 0x165a2 <_datetime>
    c6f2:	e5 e1       	ldi	r30, 0x15	; 21
    c6f4:	8e 2e       	mov	r8, r30
    c6f6:	91 2c       	mov	r9, r1
    c6f8:	8c 0e       	add	r8, r28
    c6fa:	9d 1e       	adc	r9, r29
    c6fc:	d4 01       	movw	r26, r8
    c6fe:	20 e0       	ldi	r18, 0x00	; 0
    c700:	30 e0       	ldi	r19, 0x00	; 0
    c702:	40 e0       	ldi	r20, 0x00	; 0
    c704:	50 e0       	ldi	r21, 0x00	; 0
	for(__i = 0, __ii = 0; __i < 6; __i++, __ii++){
		if(__i == 2 || __i == 4)
    c706:	22 30       	cpi	r18, 0x02	; 2
    c708:	31 05       	cpc	r19, r1
    c70a:	19 f0       	breq	.+6      	; 0xc712 <_menu_datetime+0x6e>
    c70c:	24 30       	cpi	r18, 0x04	; 4
    c70e:	31 05       	cpc	r19, r1
    c710:	11 f4       	brne	.+4      	; 0xc716 <_menu_datetime+0x72>
			__ii++;
    c712:	4f 5f       	subi	r20, 0xFF	; 255
    c714:	5f 4f       	sbci	r21, 0xFF	; 255
		__map[__i][2] = __date[__ii];
    c716:	f8 01       	movw	r30, r16
    c718:	e4 0f       	add	r30, r20
    c71a:	f5 1f       	adc	r31, r21
    c71c:	80 81       	ld	r24, Z
    c71e:	8c 93       	st	X, r24
	char	__map[12][4] = {	{1,  8, 0, 3}, {1,  9, 0, 9}, {1, 11, 0, 1}, {1, 12, 0, 9},
								{1, 14, 0, 9}, {1, 15, 0, 9}, {2,  8, 0, 2}, {2,  9, 0, 9},
								{2, 11, 0, 5}, {2, 12, 0, 9}, {2, 14, 0, 5}, {2, 15, 0, 9}};

	_datetime(_DATETIME_READ, __date, __time);
	for(__i = 0, __ii = 0; __i < 6; __i++, __ii++){
    c720:	2f 5f       	subi	r18, 0xFF	; 255
    c722:	3f 4f       	sbci	r19, 0xFF	; 255
    c724:	14 96       	adiw	r26, 0x04	; 4
    c726:	26 30       	cpi	r18, 0x06	; 6
    c728:	31 05       	cpc	r19, r1
    c72a:	19 f0       	breq	.+6      	; 0xc732 <_menu_datetime+0x8e>
    c72c:	4f 5f       	subi	r20, 0xFF	; 255
    c72e:	5f 4f       	sbci	r21, 0xFF	; 255
    c730:	ea cf       	rjmp	.-44     	; 0xc706 <_menu_datetime+0x62>
    c732:	7d e2       	ldi	r23, 0x2D	; 45
    c734:	a7 2e       	mov	r10, r23
    c736:	b1 2c       	mov	r11, r1
    c738:	ac 0e       	add	r10, r28
    c73a:	bd 1e       	adc	r11, r29
    c73c:	d5 01       	movw	r26, r10
    c73e:	40 e0       	ldi	r20, 0x00	; 0
    c740:	50 e0       	ldi	r21, 0x00	; 0
		__map[__i][2] = __date[__ii];
	}
	for(__i = 6, __ii = 0; __i < 12; __i++, __ii++){
		if(__i == 8 || __i == 10)
			__ii++;
		__map[__i][2] = __time[__ii];
    c742:	6a e0       	ldi	r22, 0x0A	; 10
    c744:	e6 2e       	mov	r14, r22
    c746:	f1 2c       	mov	r15, r1
    c748:	ec 0e       	add	r14, r28
    c74a:	fd 1e       	adc	r15, r29
		if(__i == 2 || __i == 4)
			__ii++;
		__map[__i][2] = __date[__ii];
	}
	for(__i = 6, __ii = 0; __i < 12; __i++, __ii++){
		if(__i == 8 || __i == 10)
    c74c:	28 30       	cpi	r18, 0x08	; 8
    c74e:	31 05       	cpc	r19, r1
    c750:	19 f0       	breq	.+6      	; 0xc758 <_menu_datetime+0xb4>
    c752:	2a 30       	cpi	r18, 0x0A	; 10
    c754:	31 05       	cpc	r19, r1
    c756:	11 f4       	brne	.+4      	; 0xc75c <_menu_datetime+0xb8>
			__ii++;
    c758:	4f 5f       	subi	r20, 0xFF	; 255
    c75a:	5f 4f       	sbci	r21, 0xFF	; 255
		__map[__i][2] = __time[__ii];
    c75c:	f7 01       	movw	r30, r14
    c75e:	e4 0f       	add	r30, r20
    c760:	f5 1f       	adc	r31, r21
    c762:	80 81       	ld	r24, Z
    c764:	8c 93       	st	X, r24
	for(__i = 0, __ii = 0; __i < 6; __i++, __ii++){
		if(__i == 2 || __i == 4)
			__ii++;
		__map[__i][2] = __date[__ii];
	}
	for(__i = 6, __ii = 0; __i < 12; __i++, __ii++){
    c766:	2f 5f       	subi	r18, 0xFF	; 255
    c768:	3f 4f       	sbci	r19, 0xFF	; 255
    c76a:	14 96       	adiw	r26, 0x04	; 4
    c76c:	2c 30       	cpi	r18, 0x0C	; 12
    c76e:	31 05       	cpc	r19, r1
    c770:	19 f0       	breq	.+6      	; 0xc778 <_menu_datetime+0xd4>
    c772:	4f 5f       	subi	r20, 0xFF	; 255
    c774:	5f 4f       	sbci	r21, 0xFF	; 255
    c776:	ea cf       	rjmp	.-44     	; 0xc74c <_menu_datetime+0xa8>
		if(__i == 8 || __i == 10)
			__ii++;
		__map[__i][2] = __time[__ii];
	}

	lcd_clear();_delay_ms(10);
    c778:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
    c77c:	84 ec       	ldi	r24, 0xC4	; 196
    c77e:	99 e0       	ldi	r25, 0x09	; 9
    c780:	01 97       	sbiw	r24, 0x01	; 1
    c782:	f1 f7       	brne	.-4      	; 0xc780 <_menu_datetime+0xdc>
	lcd_printf(1, 1, PSTR("DATE : "));
    c784:	81 e0       	ldi	r24, 0x01	; 1
    c786:	61 e0       	ldi	r22, 0x01	; 1
    c788:	43 eb       	ldi	r20, 0xB3	; 179
    c78a:	5b e0       	ldi	r21, 0x0B	; 11
    c78c:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
	lcd_printf(2, 1, PSTR("TIME : "));
    c790:	82 e0       	ldi	r24, 0x02	; 2
    c792:	61 e0       	ldi	r22, 0x01	; 1
    c794:	4b ea       	ldi	r20, 0xAB	; 171
    c796:	5b e0       	ldi	r21, 0x0B	; 11
    c798:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
	lcd_print(1, 8, __date);
    c79c:	81 e0       	ldi	r24, 0x01	; 1
    c79e:	68 e0       	ldi	r22, 0x08	; 8
    c7a0:	8e 01       	movw	r16, r28
    c7a2:	0f 5f       	subi	r16, 0xFF	; 255
    c7a4:	1f 4f       	sbci	r17, 0xFF	; 255
    c7a6:	a8 01       	movw	r20, r16
    c7a8:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
	lcd_print(2, 8, __time);
    c7ac:	82 e0       	ldi	r24, 0x02	; 2
    c7ae:	68 e0       	ldi	r22, 0x08	; 8
    c7b0:	a7 01       	movw	r20, r14
    c7b2:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
	lcd_printf(4, 1, PSTR("*)Cancel      #)Save"));
    c7b6:	84 e0       	ldi	r24, 0x04	; 4
    c7b8:	61 e0       	ldi	r22, 0x01	; 1
    c7ba:	46 e9       	ldi	r20, 0x96	; 150
    c7bc:	5b e0       	ldi	r21, 0x0B	; 11
    c7be:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>

	__i = 0;
	lcd_xy(__map[__i][0], __map[__i][1]);
    c7c2:	8b 89       	ldd	r24, Y+19	; 0x13
    c7c4:	6c 89       	ldd	r22, Y+20	; 0x14
    c7c6:	0e 94 4c ae 	call	0x15c98	; 0x15c98 <lcd_xy>
	CURSOR_SHOW;
    c7ca:	8f e0       	ldi	r24, 0x0F	; 15
    c7cc:	0e 94 b9 ad 	call	0x15b72	; 0x15b72 <lcd_command>
    c7d0:	ee 24       	eor	r14, r14
    c7d2:	ff 24       	eor	r15, r15
					else
						goto LEWAT;
				}
			}
CETAK:
			__map[__i][2] = __chr;
    c7d4:	68 01       	movw	r12, r16
	lcd_xy(__map[__i][0], __map[__i][1]);
	CURSOR_SHOW;

	while(1){
		
		__key = _key_scan(1);
    c7d6:	81 e0       	ldi	r24, 0x01	; 1
    c7d8:	0e 94 06 b0 	call	0x1600c	; 0x1600c <_key_scan>
    c7dc:	18 2f       	mov	r17, r24
		__chr = _key_btn(__key);
    c7de:	0e 94 67 af 	call	0x15ece	; 0x15ece <_key_btn>
    c7e2:	48 2f       	mov	r20, r24
		if(__chr >= 0x30 && __chr <= 0x39){
    c7e4:	80 53       	subi	r24, 0x30	; 48
    c7e6:	8a 30       	cpi	r24, 0x0A	; 10
    c7e8:	08 f0       	brcs	.+2      	; 0xc7ec <_menu_datetime+0x148>
    c7ea:	72 c0       	rjmp	.+228    	; 0xc8d0 <_menu_datetime+0x22c>
			if(__i == 0 || __i == 2 || __i == 6 || __i == 8 || __i == 10){
    c7ec:	e1 14       	cp	r14, r1
    c7ee:	f1 04       	cpc	r15, r1
    c7f0:	81 f0       	breq	.+32     	; 0xc812 <_menu_datetime+0x16e>
    c7f2:	82 e0       	ldi	r24, 0x02	; 2
    c7f4:	e8 16       	cp	r14, r24
    c7f6:	f1 04       	cpc	r15, r1
    c7f8:	61 f0       	breq	.+24     	; 0xc812 <_menu_datetime+0x16e>
    c7fa:	96 e0       	ldi	r25, 0x06	; 6
    c7fc:	e9 16       	cp	r14, r25
    c7fe:	f1 04       	cpc	r15, r1
    c800:	41 f0       	breq	.+16     	; 0xc812 <_menu_datetime+0x16e>
    c802:	a8 e0       	ldi	r26, 0x08	; 8
    c804:	ea 16       	cp	r14, r26
    c806:	f1 04       	cpc	r15, r1
    c808:	21 f0       	breq	.+8      	; 0xc812 <_menu_datetime+0x16e>
    c80a:	ba e0       	ldi	r27, 0x0A	; 10
    c80c:	eb 16       	cp	r14, r27
    c80e:	f1 04       	cpc	r15, r1
    c810:	81 f4       	brne	.+32     	; 0xc832 <_menu_datetime+0x18e>
				if((__chr - 0x30) <= __map[__i][3])
    c812:	84 2f       	mov	r24, r20
    c814:	90 e0       	ldi	r25, 0x00	; 0
    c816:	c0 97       	sbiw	r24, 0x30	; 48
    c818:	f7 01       	movw	r30, r14
    c81a:	ee 0f       	add	r30, r30
    c81c:	ff 1f       	adc	r31, r31
    c81e:	ee 0f       	add	r30, r30
    c820:	ff 1f       	adc	r31, r31
    c822:	ec 0d       	add	r30, r12
    c824:	fd 1d       	adc	r31, r13
    c826:	25 89       	ldd	r18, Z+21	; 0x15
    c828:	30 e0       	ldi	r19, 0x00	; 0
    c82a:	28 17       	cp	r18, r24
    c82c:	39 07       	cpc	r19, r25
    c82e:	84 f5       	brge	.+96     	; 0xc890 <_menu_datetime+0x1ec>
    c830:	4f c0       	rjmp	.+158    	; 0xc8d0 <_menu_datetime+0x22c>
					goto CETAK;
				else
					goto LEWAT;
			}
			if(__i == 1){
    c832:	81 e0       	ldi	r24, 0x01	; 1
    c834:	e8 16       	cp	r14, r24
    c836:	f1 04       	cpc	r15, r1
    c838:	61 f4       	brne	.+24     	; 0xc852 <_menu_datetime+0x1ae>
				if((__map[0][2] - 0x30) < __map[0][3])
    c83a:	2d 89       	ldd	r18, Y+21	; 0x15
    c83c:	30 e0       	ldi	r19, 0x00	; 0
    c83e:	2f 52       	subi	r18, 0x2F	; 47
    c840:	30 40       	sbci	r19, 0x00	; 0
    c842:	8e 89       	ldd	r24, Y+22	; 0x16
    c844:	90 e0       	ldi	r25, 0x00	; 0
    c846:	82 17       	cp	r24, r18
    c848:	93 07       	cpc	r25, r19
    c84a:	14 f5       	brge	.+68     	; 0xc890 <_menu_datetime+0x1ec>
					goto CETAK;
				if((__map[0][2] - 0x30) >= __map[0][3]){
					if(__chr < 0x32)
    c84c:	42 33       	cpi	r20, 0x32	; 50
    c84e:	00 f1       	brcs	.+64     	; 0xc890 <_menu_datetime+0x1ec>
    c850:	3f c0       	rjmp	.+126    	; 0xc8d0 <_menu_datetime+0x22c>
						goto CETAK;
					else
						goto LEWAT;
				}
			}
			if(__i == 3){
    c852:	93 e0       	ldi	r25, 0x03	; 3
    c854:	e9 16       	cp	r14, r25
    c856:	f1 04       	cpc	r15, r1
    c858:	61 f4       	brne	.+24     	; 0xc872 <_menu_datetime+0x1ce>
				if((__map[2][2] - 0x30) < __map[2][3])
    c85a:	2d 8d       	ldd	r18, Y+29	; 0x1d
    c85c:	30 e0       	ldi	r19, 0x00	; 0
    c85e:	2f 52       	subi	r18, 0x2F	; 47
    c860:	30 40       	sbci	r19, 0x00	; 0
    c862:	8e 8d       	ldd	r24, Y+30	; 0x1e
    c864:	90 e0       	ldi	r25, 0x00	; 0
    c866:	82 17       	cp	r24, r18
    c868:	93 07       	cpc	r25, r19
    c86a:	94 f4       	brge	.+36     	; 0xc890 <_menu_datetime+0x1ec>
					goto CETAK;
				if((__map[2][2] - 0x30) >= __map[2][3]){
					if(__chr < 0x33)
    c86c:	43 33       	cpi	r20, 0x33	; 51
    c86e:	80 f0       	brcs	.+32     	; 0xc890 <_menu_datetime+0x1ec>
    c870:	2f c0       	rjmp	.+94     	; 0xc8d0 <_menu_datetime+0x22c>
						goto CETAK;
					else
						goto LEWAT;
				}
			}
			if(__i == 7){
    c872:	a7 e0       	ldi	r26, 0x07	; 7
    c874:	ea 16       	cp	r14, r26
    c876:	f1 04       	cpc	r15, r1
    c878:	59 f4       	brne	.+22     	; 0xc890 <_menu_datetime+0x1ec>
				if((__map[6][2] - 0x30) < __map[6][3])
    c87a:	2d a5       	ldd	r18, Y+45	; 0x2d
    c87c:	30 e0       	ldi	r19, 0x00	; 0
    c87e:	2f 52       	subi	r18, 0x2F	; 47
    c880:	30 40       	sbci	r19, 0x00	; 0
    c882:	8e a5       	ldd	r24, Y+46	; 0x2e
    c884:	90 e0       	ldi	r25, 0x00	; 0
    c886:	82 17       	cp	r24, r18
    c888:	93 07       	cpc	r25, r19
    c88a:	14 f4       	brge	.+4      	; 0xc890 <_menu_datetime+0x1ec>
					goto CETAK;
				if((__map[6][2] - 0x30) >= __map[6][3]){
					if(__chr < 0x34)
    c88c:	44 33       	cpi	r20, 0x34	; 52
    c88e:	00 f5       	brcc	.+64     	; 0xc8d0 <_menu_datetime+0x22c>
					else
						goto LEWAT;
				}
			}
CETAK:
			__map[__i][2] = __chr;
    c890:	f7 01       	movw	r30, r14
    c892:	ee 0f       	add	r30, r30
    c894:	ff 1f       	adc	r31, r31
    c896:	ee 0f       	add	r30, r30
    c898:	ff 1f       	adc	r31, r31
    c89a:	ec 0d       	add	r30, r12
    c89c:	fd 1d       	adc	r31, r13
    c89e:	44 8b       	std	Z+20, r20	; 0x14
			_lcd(__chr);
    c8a0:	84 2f       	mov	r24, r20
    c8a2:	0e 94 26 ae 	call	0x15c4c	; 0x15c4c <_lcd>
			__i++;
    c8a6:	08 94       	sec
    c8a8:	e1 1c       	adc	r14, r1
    c8aa:	f1 1c       	adc	r15, r1
    c8ac:	bc e0       	ldi	r27, 0x0C	; 12
    c8ae:	eb 16       	cp	r14, r27
    c8b0:	f1 04       	cpc	r15, r1
    c8b2:	1c f0       	brlt	.+6      	; 0xc8ba <_menu_datetime+0x216>
    c8b4:	8b e0       	ldi	r24, 0x0B	; 11
    c8b6:	e8 2e       	mov	r14, r24
    c8b8:	f1 2c       	mov	r15, r1
			if(__i > 11)
				__i = 11;
			lcd_xy(__map[__i][0], __map[__i][1]);
    c8ba:	f7 01       	movw	r30, r14
    c8bc:	ee 0f       	add	r30, r30
    c8be:	ff 1f       	adc	r31, r31
    c8c0:	ee 0f       	add	r30, r30
    c8c2:	ff 1f       	adc	r31, r31
    c8c4:	ec 0d       	add	r30, r12
    c8c6:	fd 1d       	adc	r31, r13
    c8c8:	82 89       	ldd	r24, Z+18	; 0x12
    c8ca:	63 89       	ldd	r22, Z+19	; 0x13
    c8cc:	0e 94 4c ae 	call	0x15c98	; 0x15c98 <lcd_xy>
LEWAT:		;
		}
		if(__key == _KEY_SHIFT){
    c8d0:	1b 37       	cpi	r17, 0x7B	; 123
    c8d2:	59 f4       	brne	.+22     	; 0xc8ea <_menu_datetime+0x246>
			__i++;
    c8d4:	08 94       	sec
    c8d6:	e1 1c       	adc	r14, r1
    c8d8:	f1 1c       	adc	r15, r1
    c8da:	8c e0       	ldi	r24, 0x0C	; 12
    c8dc:	e8 16       	cp	r14, r24
    c8de:	f1 04       	cpc	r15, r1
    c8e0:	6c f0       	brlt	.+26     	; 0xc8fc <_menu_datetime+0x258>
    c8e2:	bb e0       	ldi	r27, 0x0B	; 11
    c8e4:	eb 2e       	mov	r14, r27
    c8e6:	f1 2c       	mov	r15, r1
    c8e8:	09 c0       	rjmp	.+18     	; 0xc8fc <_menu_datetime+0x258>
			if(__i > 11)
				__i = 11;
			lcd_xy(__map[__i][0], __map[__i][1]);
		}
		if(__key == _KEY_CLEAR){
    c8ea:	17 37       	cpi	r17, 0x77	; 119
    c8ec:	99 f4       	brne	.+38     	; 0xc914 <_menu_datetime+0x270>
			__i--;
    c8ee:	08 94       	sec
    c8f0:	e1 08       	sbc	r14, r1
    c8f2:	f1 08       	sbc	r15, r1
    c8f4:	f7 fe       	sbrs	r15, 7
    c8f6:	02 c0       	rjmp	.+4      	; 0xc8fc <_menu_datetime+0x258>
    c8f8:	ee 24       	eor	r14, r14
    c8fa:	ff 24       	eor	r15, r15
			if(__i <= 0)
				__i = 0;
			lcd_xy(__map[__i][0], __map[__i][1]);
    c8fc:	f7 01       	movw	r30, r14
    c8fe:	ee 0f       	add	r30, r30
    c900:	ff 1f       	adc	r31, r31
    c902:	ee 0f       	add	r30, r30
    c904:	ff 1f       	adc	r31, r31
    c906:	ec 0d       	add	r30, r12
    c908:	fd 1d       	adc	r31, r13
    c90a:	82 89       	ldd	r24, Z+18	; 0x12
    c90c:	63 89       	ldd	r22, Z+19	; 0x13
    c90e:	0e 94 4c ae 	call	0x15c98	; 0x15c98 <lcd_xy>
    c912:	61 cf       	rjmp	.-318    	; 0xc7d6 <_menu_datetime+0x132>
		}
		if(__key == _KEY_CANCEL)
    c914:	17 3e       	cpi	r17, 0xE7	; 231
    c916:	09 f4       	brne	.+2      	; 0xc91a <_menu_datetime+0x276>
    c918:	49 c0       	rjmp	.+146    	; 0xc9ac <_menu_datetime+0x308>
			break;
		if(__key == _KEY_ENTER){
    c91a:	17 3b       	cpi	r17, 0xB7	; 183
    c91c:	09 f0       	breq	.+2      	; 0xc920 <_menu_datetime+0x27c>
    c91e:	5b cf       	rjmp	.-330    	; 0xc7d6 <_menu_datetime+0x132>
    c920:	20 e0       	ldi	r18, 0x00	; 0
    c922:	30 e0       	ldi	r19, 0x00	; 0
    c924:	40 e0       	ldi	r20, 0x00	; 0
    c926:	50 e0       	ldi	r21, 0x00	; 0
			for(__i = 0, __ii = 0; __i < 6; __i++, __ii++){
				if(__i == 2 || __i == 4)
					__ii++;
				__date[__ii] = __map[__i][2];
    c928:	be 01       	movw	r22, r28
    c92a:	6f 5f       	subi	r22, 0xFF	; 255
    c92c:	7f 4f       	sbci	r23, 0xFF	; 255
		}
		if(__key == _KEY_CANCEL)
			break;
		if(__key == _KEY_ENTER){
			for(__i = 0, __ii = 0; __i < 6; __i++, __ii++){
				if(__i == 2 || __i == 4)
    c92e:	22 30       	cpi	r18, 0x02	; 2
    c930:	31 05       	cpc	r19, r1
    c932:	19 f0       	breq	.+6      	; 0xc93a <_menu_datetime+0x296>
    c934:	24 30       	cpi	r18, 0x04	; 4
    c936:	31 05       	cpc	r19, r1
    c938:	11 f4       	brne	.+4      	; 0xc93e <_menu_datetime+0x29a>
					__ii++;
    c93a:	4f 5f       	subi	r20, 0xFF	; 255
    c93c:	5f 4f       	sbci	r21, 0xFF	; 255
				__date[__ii] = __map[__i][2];
    c93e:	fb 01       	movw	r30, r22
    c940:	e4 0f       	add	r30, r20
    c942:	f5 1f       	adc	r31, r21
    c944:	d4 01       	movw	r26, r8
    c946:	8c 91       	ld	r24, X
    c948:	80 83       	st	Z, r24
			lcd_xy(__map[__i][0], __map[__i][1]);
		}
		if(__key == _KEY_CANCEL)
			break;
		if(__key == _KEY_ENTER){
			for(__i = 0, __ii = 0; __i < 6; __i++, __ii++){
    c94a:	2f 5f       	subi	r18, 0xFF	; 255
    c94c:	3f 4f       	sbci	r19, 0xFF	; 255
    c94e:	84 e0       	ldi	r24, 0x04	; 4
    c950:	90 e0       	ldi	r25, 0x00	; 0
    c952:	88 0e       	add	r8, r24
    c954:	99 1e       	adc	r9, r25
    c956:	26 30       	cpi	r18, 0x06	; 6
    c958:	31 05       	cpc	r19, r1
    c95a:	19 f0       	breq	.+6      	; 0xc962 <_menu_datetime+0x2be>
    c95c:	4f 5f       	subi	r20, 0xFF	; 255
    c95e:	5f 4f       	sbci	r21, 0xFF	; 255
    c960:	e6 cf       	rjmp	.-52     	; 0xc92e <_menu_datetime+0x28a>
    c962:	60 e0       	ldi	r22, 0x00	; 0
    c964:	70 e0       	ldi	r23, 0x00	; 0
				__date[__ii] = __map[__i][2];
			}
			for(__i = 6, __ii = 0; __i < 12; __i++, __ii++){
				if(__i == 8 || __i == 10)
					__ii++;
				__time[__ii] = __map[__i][2];
    c966:	ae 01       	movw	r20, r28
    c968:	46 5f       	subi	r20, 0xF6	; 246
    c96a:	5f 4f       	sbci	r21, 0xFF	; 255
				if(__i == 2 || __i == 4)
					__ii++;
				__date[__ii] = __map[__i][2];
			}
			for(__i = 6, __ii = 0; __i < 12; __i++, __ii++){
				if(__i == 8 || __i == 10)
    c96c:	28 30       	cpi	r18, 0x08	; 8
    c96e:	31 05       	cpc	r19, r1
    c970:	19 f0       	breq	.+6      	; 0xc978 <_menu_datetime+0x2d4>
    c972:	2a 30       	cpi	r18, 0x0A	; 10
    c974:	31 05       	cpc	r19, r1
    c976:	11 f4       	brne	.+4      	; 0xc97c <_menu_datetime+0x2d8>
					__ii++;
    c978:	6f 5f       	subi	r22, 0xFF	; 255
    c97a:	7f 4f       	sbci	r23, 0xFF	; 255
				__time[__ii] = __map[__i][2];
    c97c:	fa 01       	movw	r30, r20
    c97e:	e6 0f       	add	r30, r22
    c980:	f7 1f       	adc	r31, r23
    c982:	d5 01       	movw	r26, r10
    c984:	8c 91       	ld	r24, X
    c986:	80 83       	st	Z, r24
			for(__i = 0, __ii = 0; __i < 6; __i++, __ii++){
				if(__i == 2 || __i == 4)
					__ii++;
				__date[__ii] = __map[__i][2];
			}
			for(__i = 6, __ii = 0; __i < 12; __i++, __ii++){
    c988:	2f 5f       	subi	r18, 0xFF	; 255
    c98a:	3f 4f       	sbci	r19, 0xFF	; 255
    c98c:	84 e0       	ldi	r24, 0x04	; 4
    c98e:	90 e0       	ldi	r25, 0x00	; 0
    c990:	a8 0e       	add	r10, r24
    c992:	b9 1e       	adc	r11, r25
    c994:	2c 30       	cpi	r18, 0x0C	; 12
    c996:	31 05       	cpc	r19, r1
    c998:	19 f0       	breq	.+6      	; 0xc9a0 <_menu_datetime+0x2fc>
    c99a:	6f 5f       	subi	r22, 0xFF	; 255
    c99c:	7f 4f       	sbci	r23, 0xFF	; 255
    c99e:	e6 cf       	rjmp	.-52     	; 0xc96c <_menu_datetime+0x2c8>
				if(__i == 8 || __i == 10)
					__ii++;
				__time[__ii] = __map[__i][2];
			}
			_datetime(_DATETIME_WRITE, __date, __time);
    c9a0:	81 e0       	ldi	r24, 0x01	; 1
    c9a2:	be 01       	movw	r22, r28
    c9a4:	6f 5f       	subi	r22, 0xFF	; 255
    c9a6:	7f 4f       	sbci	r23, 0xFF	; 255
    c9a8:	0e 94 d1 b2 	call	0x165a2	; 0x165a2 <_datetime>
			break;
		}
	}
	CURSOR_HIDE;
    c9ac:	8c e0       	ldi	r24, 0x0C	; 12
    c9ae:	0e 94 b9 ad 	call	0x15b72	; 0x15b72 <lcd_command>
}
    c9b2:	ce 5b       	subi	r28, 0xBE	; 190
    c9b4:	df 4f       	sbci	r29, 0xFF	; 255
    c9b6:	0f b6       	in	r0, 0x3f	; 63
    c9b8:	f8 94       	cli
    c9ba:	de bf       	out	0x3e, r29	; 62
    c9bc:	0f be       	out	0x3f, r0	; 63
    c9be:	cd bf       	out	0x3d, r28	; 61
    c9c0:	cf 91       	pop	r28
    c9c2:	df 91       	pop	r29
    c9c4:	1f 91       	pop	r17
    c9c6:	0f 91       	pop	r16
    c9c8:	ff 90       	pop	r15
    c9ca:	ef 90       	pop	r14
    c9cc:	df 90       	pop	r13
    c9ce:	cf 90       	pop	r12
    c9d0:	bf 90       	pop	r11
    c9d2:	af 90       	pop	r10
    c9d4:	9f 90       	pop	r9
    c9d6:	8f 90       	pop	r8
    c9d8:	08 95       	ret

0000c9da <FSettingDatetime>:
	 }
     return Result;
}

char FSettingDatetime(){
     _menu_datetime();
    c9da:	0e 94 52 63 	call	0xc6a4	; 0xc6a4 <_menu_datetime>
     return MENU_DONE;
}
    c9de:	81 e0       	ldi	r24, 0x01	; 1
    c9e0:	08 95       	ret

0000c9e2 <menu_FIP>:
	 }
  return Result;
}


char menu_FIP(char *xFIP,char *sFIPUsed){
    c9e2:	4f 92       	push	r4
    c9e4:	5f 92       	push	r5
    c9e6:	6f 92       	push	r6
    c9e8:	7f 92       	push	r7
    c9ea:	8f 92       	push	r8
    c9ec:	9f 92       	push	r9
    c9ee:	af 92       	push	r10
    c9f0:	bf 92       	push	r11
    c9f2:	cf 92       	push	r12
    c9f4:	df 92       	push	r13
    c9f6:	ef 92       	push	r14
    c9f8:	ff 92       	push	r15
    c9fa:	0f 93       	push	r16
    c9fc:	1f 93       	push	r17
    c9fe:	df 93       	push	r29
    ca00:	cf 93       	push	r28
    ca02:	cd b7       	in	r28, 0x3d	; 61
    ca04:	de b7       	in	r29, 0x3e	; 62
    ca06:	a2 97       	sbiw	r28, 0x22	; 34
    ca08:	0f b6       	in	r0, 0x3f	; 63
    ca0a:	f8 94       	cli
    ca0c:	de bf       	out	0x3e, r29	; 62
    ca0e:	0f be       	out	0x3f, r0	; 63
    ca10:	cd bf       	out	0x3d, r28	; 61
    ca12:	7c 01       	movw	r14, r24
    ca14:	8b 01       	movw	r16, r22
       char Result=FIP_NONE;
       char FIP[8],strPumpL[3],strPumpR[3],lcdteks[20];
static char KeyPressed=0,KeyChar,KeyCharLast=' ',FIP_Used=0;
static unsigned int iLoop;

       switch(stEnterFIP){
    ca16:	80 91 58 03 	lds	r24, 0x0358
    ca1a:	81 30       	cpi	r24, 0x01	; 1
    ca1c:	09 f4       	brne	.+2      	; 0xca20 <menu_FIP+0x3e>
    ca1e:	cf c0       	rjmp	.+414    	; 0xcbbe <menu_FIP+0x1dc>
    ca20:	81 30       	cpi	r24, 0x01	; 1
    ca22:	20 f0       	brcs	.+8      	; 0xca2c <menu_FIP+0x4a>
    ca24:	82 30       	cpi	r24, 0x02	; 2
    ca26:	09 f0       	breq	.+2      	; 0xca2a <menu_FIP+0x48>
    ca28:	55 c1       	rjmp	.+682    	; 0xccd4 <menu_FIP+0x2f2>
    ca2a:	52 c1       	rjmp	.+676    	; 0xccd0 <menu_FIP+0x2ee>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    ca2c:	8e 01       	movw	r16, r28
    ca2e:	09 5f       	subi	r16, 0xF9	; 249
    ca30:	1f 4f       	sbci	r17, 0xFF	; 255
    ca32:	c8 01       	movw	r24, r16
    ca34:	65 e4       	ldi	r22, 0x45	; 69
    ca36:	70 e0       	ldi	r23, 0x00	; 0
    ca38:	48 e0       	ldi	r20, 0x08	; 8
    ca3a:	50 e0       	ldi	r21, 0x00	; 0
    ca3c:	26 ef       	ldi	r18, 0xF6	; 246
    ca3e:	32 e1       	ldi	r19, 0x12	; 18
    ca40:	0e 94 7a b5 	call	0x16af4	; 0x16af4 <__eerd_block>
 	   case efInit:
	 	    eeprom_read_block((void*) &FIP, (const void*) &DefPumpMap, 8);
		    lcd_clear(); 
    ca44:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
    ca48:	f8 01       	movw	r30, r16
    ca4a:	20 e0       	ldi	r18, 0x00	; 0
    ca4c:	30 e0       	ldi	r19, 0x00	; 0
    ca4e:	07 c0       	rjmp	.+14     	; 0xca5e <menu_FIP+0x7c>
		    for (iLoop=0;iLoop<8;iLoop++){
			     if (FIP[iLoop]>99) FIP[iLoop]=0;
    ca50:	80 81       	ld	r24, Z
    ca52:	84 36       	cpi	r24, 0x64	; 100
    ca54:	08 f0       	brcs	.+2      	; 0xca58 <menu_FIP+0x76>
    ca56:	10 82       	st	Z, r1
    ca58:	2f 5f       	subi	r18, 0xFF	; 255
    ca5a:	3f 4f       	sbci	r19, 0xFF	; 255
    ca5c:	31 96       	adiw	r30, 0x01	; 1

       switch(stEnterFIP){
 	   case efInit:
	 	    eeprom_read_block((void*) &FIP, (const void*) &DefPumpMap, 8);
		    lcd_clear(); 
		    for (iLoop=0;iLoop<8;iLoop++){
    ca5e:	28 30       	cpi	r18, 0x08	; 8
    ca60:	31 05       	cpc	r19, r1
    ca62:	b0 f3       	brcs	.-20     	; 0xca50 <menu_FIP+0x6e>
			     if (FIP[iLoop]>99) FIP[iLoop]=0;
		    }
		    for(iLoop=0;iLoop<4;iLoop++){
    ca64:	10 92 54 03 	sts	0x0354, r1
    ca68:	10 92 53 03 	sts	0x0353, r1
		}
     else {
	    sprintf_P(StrResult,PSTR("%d"),Val);
	 }
	 */
     sprintf_P(StrResult,PSTR("%.2d"),Val);
    ca6c:	5e 01       	movw	r10, r28
    ca6e:	08 94       	sec
    ca70:	a1 1c       	adc	r10, r1
    ca72:	b1 1c       	adc	r11, r1
    ca74:	0d e5       	ldi	r16, 0x5D	; 93
    ca76:	c0 2e       	mov	r12, r16
    ca78:	0d e0       	ldi	r16, 0x0D	; 13
    ca7a:	d0 2e       	mov	r13, r16
    ca7c:	17 e0       	ldi	r17, 0x07	; 7
    ca7e:	41 2e       	mov	r4, r17
    ca80:	51 2c       	mov	r5, r1
    ca82:	4c 0e       	add	r4, r28
    ca84:	5d 1e       	adc	r5, r29
		    for (iLoop=0;iLoop<8;iLoop++){
			     if (FIP[iLoop]>99) FIP[iLoop]=0;
		    }
		    for(iLoop=0;iLoop<4;iLoop++){
		        leadingZero(FIP[iLoop],strPumpL);leadingZero(FIP[iLoop+4],strPumpR);
                sprintf_P(lcdteks,PSTR("%d.P%s | %d.P%s"),(iLoop+1),strPumpL,(iLoop+5),strPumpR);
    ca86:	b4 e0       	ldi	r27, 0x04	; 4
    ca88:	eb 2e       	mov	r14, r27
    ca8a:	f1 2c       	mov	r15, r1
    ca8c:	ec 0e       	add	r14, r28
    ca8e:	fd 1e       	adc	r15, r29
    ca90:	ab e0       	ldi	r26, 0x0B	; 11
    ca92:	6a 2e       	mov	r6, r26
    ca94:	71 2c       	mov	r7, r1
    ca96:	6c 0e       	add	r6, r28
    ca98:	7d 1e       	adc	r7, r29
    ca9a:	8e 01       	movw	r16, r28
    ca9c:	01 5f       	subi	r16, 0xF1	; 241
    ca9e:	1f 4f       	sbci	r17, 0xFF	; 255
    caa0:	ff e9       	ldi	r31, 0x9F	; 159
    caa2:	8f 2e       	mov	r8, r31
    caa4:	fb e1       	ldi	r31, 0x1B	; 27
    caa6:	9f 2e       	mov	r9, r31
    caa8:	64 c0       	rjmp	.+200    	; 0xcb72 <menu_FIP+0x190>
		}
     else {
	    sprintf_P(StrResult,PSTR("%d"),Val);
	 }
	 */
     sprintf_P(StrResult,PSTR("%.2d"),Val);
    caaa:	00 d0       	rcall	.+0      	; 0xcaac <menu_FIP+0xca>
    caac:	00 d0       	rcall	.+0      	; 0xcaae <menu_FIP+0xcc>
    caae:	00 d0       	rcall	.+0      	; 0xcab0 <menu_FIP+0xce>
    cab0:	2d b7       	in	r18, 0x3d	; 61
    cab2:	3e b7       	in	r19, 0x3e	; 62
    cab4:	2f 5f       	subi	r18, 0xFF	; 255
    cab6:	3f 4f       	sbci	r19, 0xFF	; 255
    cab8:	ed b7       	in	r30, 0x3d	; 61
    caba:	fe b7       	in	r31, 0x3e	; 62
    cabc:	b2 82       	std	Z+2, r11	; 0x02
    cabe:	a1 82       	std	Z+1, r10	; 0x01
    cac0:	f9 01       	movw	r30, r18
    cac2:	d3 82       	std	Z+3, r13	; 0x03
    cac4:	c2 82       	std	Z+2, r12	; 0x02
    cac6:	a4 0d       	add	r26, r4
    cac8:	b5 1d       	adc	r27, r5
    caca:	8c 91       	ld	r24, X
    cacc:	84 83       	std	Z+4, r24	; 0x04
    cace:	15 82       	std	Z+5, r1	; 0x05
    cad0:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    cad4:	ad b7       	in	r26, 0x3d	; 61
    cad6:	be b7       	in	r27, 0x3e	; 62
    cad8:	11 96       	adiw	r26, 0x01	; 1
    cada:	ed b7       	in	r30, 0x3d	; 61
    cadc:	fe b7       	in	r31, 0x3e	; 62
    cade:	f2 82       	std	Z+2, r15	; 0x02
    cae0:	e1 82       	std	Z+1, r14	; 0x01
    cae2:	13 96       	adiw	r26, 0x03	; 3
    cae4:	dc 92       	st	X, r13
    cae6:	ce 92       	st	-X, r12
    cae8:	12 97       	sbiw	r26, 0x02	; 2
    caea:	e0 91 53 03 	lds	r30, 0x0353
    caee:	f0 91 54 03 	lds	r31, 0x0354
    caf2:	e6 0d       	add	r30, r6
    caf4:	f7 1d       	adc	r31, r7
    caf6:	80 81       	ld	r24, Z
    caf8:	14 96       	adiw	r26, 0x04	; 4
    cafa:	8c 93       	st	X, r24
    cafc:	14 97       	sbiw	r26, 0x04	; 4
    cafe:	15 96       	adiw	r26, 0x05	; 5
    cb00:	1c 92       	st	X, r1
    cb02:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
		    for (iLoop=0;iLoop<8;iLoop++){
			     if (FIP[iLoop]>99) FIP[iLoop]=0;
		    }
		    for(iLoop=0;iLoop<4;iLoop++){
		        leadingZero(FIP[iLoop],strPumpL);leadingZero(FIP[iLoop+4],strPumpR);
                sprintf_P(lcdteks,PSTR("%d.P%s | %d.P%s"),(iLoop+1),strPumpL,(iLoop+5),strPumpR);
    cb06:	80 91 53 03 	lds	r24, 0x0353
    cb0a:	90 91 54 03 	lds	r25, 0x0354
    cb0e:	00 d0       	rcall	.+0      	; 0xcb10 <menu_FIP+0x12e>
    cb10:	00 d0       	rcall	.+0      	; 0xcb12 <menu_FIP+0x130>
    cb12:	00 d0       	rcall	.+0      	; 0xcb14 <menu_FIP+0x132>
    cb14:	ed b7       	in	r30, 0x3d	; 61
    cb16:	fe b7       	in	r31, 0x3e	; 62
    cb18:	31 96       	adiw	r30, 0x01	; 1
    cb1a:	ad b7       	in	r26, 0x3d	; 61
    cb1c:	be b7       	in	r27, 0x3e	; 62
    cb1e:	12 96       	adiw	r26, 0x02	; 2
    cb20:	1c 93       	st	X, r17
    cb22:	0e 93       	st	-X, r16
    cb24:	11 97       	sbiw	r26, 0x01	; 1
    cb26:	93 82       	std	Z+3, r9	; 0x03
    cb28:	82 82       	std	Z+2, r8	; 0x02
    cb2a:	01 96       	adiw	r24, 0x01	; 1
    cb2c:	95 83       	std	Z+5, r25	; 0x05
    cb2e:	84 83       	std	Z+4, r24	; 0x04
    cb30:	b7 82       	std	Z+7, r11	; 0x07
    cb32:	a6 82       	std	Z+6, r10	; 0x06
    cb34:	04 96       	adiw	r24, 0x04	; 4
    cb36:	91 87       	std	Z+9, r25	; 0x09
    cb38:	80 87       	std	Z+8, r24	; 0x08
    cb3a:	f3 86       	std	Z+11, r15	; 0x0b
    cb3c:	e2 86       	std	Z+10, r14	; 0x0a
    cb3e:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
                //sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d"),(iLoop+1),FIP[iLoop],(iLoop+5),FIP[iLoop+4]);
			    lcd_print((iLoop+1),1,lcdteks);
    cb42:	ed b7       	in	r30, 0x3d	; 61
    cb44:	fe b7       	in	r31, 0x3e	; 62
    cb46:	3c 96       	adiw	r30, 0x0c	; 12
    cb48:	0f b6       	in	r0, 0x3f	; 63
    cb4a:	f8 94       	cli
    cb4c:	fe bf       	out	0x3e, r31	; 62
    cb4e:	0f be       	out	0x3f, r0	; 63
    cb50:	ed bf       	out	0x3d, r30	; 61
    cb52:	80 91 53 03 	lds	r24, 0x0353
    cb56:	8f 5f       	subi	r24, 0xFF	; 255
    cb58:	61 e0       	ldi	r22, 0x01	; 1
    cb5a:	a8 01       	movw	r20, r16
    cb5c:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
	 	    eeprom_read_block((void*) &FIP, (const void*) &DefPumpMap, 8);
		    lcd_clear(); 
		    for (iLoop=0;iLoop<8;iLoop++){
			     if (FIP[iLoop]>99) FIP[iLoop]=0;
		    }
		    for(iLoop=0;iLoop<4;iLoop++){
    cb60:	80 91 53 03 	lds	r24, 0x0353
    cb64:	90 91 54 03 	lds	r25, 0x0354
    cb68:	01 96       	adiw	r24, 0x01	; 1
    cb6a:	90 93 54 03 	sts	0x0354, r25
    cb6e:	80 93 53 03 	sts	0x0353, r24
    cb72:	a0 91 53 03 	lds	r26, 0x0353
    cb76:	b0 91 54 03 	lds	r27, 0x0354
    cb7a:	a4 30       	cpi	r26, 0x04	; 4
    cb7c:	b1 05       	cpc	r27, r1
    cb7e:	08 f4       	brcc	.+2      	; 0xcb82 <menu_FIP+0x1a0>
    cb80:	94 cf       	rjmp	.-216    	; 0xcaaa <menu_FIP+0xc8>
		        leadingZero(FIP[iLoop],strPumpL);leadingZero(FIP[iLoop+4],strPumpR);
                sprintf_P(lcdteks,PSTR("%d.P%s | %d.P%s"),(iLoop+1),strPumpL,(iLoop+5),strPumpR);
                //sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d"),(iLoop+1),FIP[iLoop],(iLoop+5),FIP[iLoop+4]);
			    lcd_print((iLoop+1),1,lcdteks);
			}
		    lcd_printf(1,15,PSTR("FIP:_"));    //"1.P01 | 5.P05 FIP:_ "                                                                      
    cb82:	81 e0       	ldi	r24, 0x01	; 1
    cb84:	6f e0       	ldi	r22, 0x0F	; 15
    cb86:	49 e9       	ldi	r20, 0x99	; 153
    cb88:	5b e1       	ldi	r21, 0x1B	; 27
    cb8a:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		    lcd_printf(2,15,PSTR("     "));    //"2.P02 | 6.P05       "
    cb8e:	82 e0       	ldi	r24, 0x02	; 2
    cb90:	6f e0       	ldi	r22, 0x0F	; 15
    cb92:	43 e9       	ldi	r20, 0x93	; 147
    cb94:	5b e1       	ldi	r21, 0x1B	; 27
    cb96:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		    lcd_printf(3,15,PSTR("#)OK "));    //"3.P03 | 7.P07 #)OK  "
    cb9a:	83 e0       	ldi	r24, 0x03	; 3
    cb9c:	6f e0       	ldi	r22, 0x0F	; 15
    cb9e:	4d e8       	ldi	r20, 0x8D	; 141
    cba0:	5b e1       	ldi	r21, 0x1B	; 27
    cba2:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
	        lcd_printf(4,15,PSTR("*)Exit"));   //"4.P04 | 8.P08 *)Exit"				
    cba6:	84 e0       	ldi	r24, 0x04	; 4
    cba8:	6f e0       	ldi	r22, 0x0F	; 15
    cbaa:	46 e8       	ldi	r20, 0x86	; 134
    cbac:	5b e1       	ldi	r21, 0x1B	; 27
    cbae:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		    iLoop=0;
    cbb2:	10 92 54 03 	sts	0x0354, r1
    cbb6:	10 92 53 03 	sts	0x0353, r1
		    stEnterFIP=efFIPInput;
    cbba:	81 e0       	ldi	r24, 0x01	; 1
    cbbc:	86 c0       	rjmp	.+268    	; 0xccca <menu_FIP+0x2e8>
	        break;
	   case efFIPInput:
		    iLoop++;
    cbbe:	80 91 53 03 	lds	r24, 0x0353
    cbc2:	90 91 54 03 	lds	r25, 0x0354
    cbc6:	01 96       	adiw	r24, 0x01	; 1
    cbc8:	90 93 54 03 	sts	0x0354, r25
    cbcc:	80 93 53 03 	sts	0x0353, r24
		    KeyPressed=_key_scan(1);
    cbd0:	81 e0       	ldi	r24, 0x01	; 1
    cbd2:	0e 94 06 b0 	call	0x1600c	; 0x1600c <_key_scan>
    cbd6:	80 93 57 03 	sts	0x0357, r24
		    KeyChar=_key_btn(KeyPressed);
    cbda:	0e 94 67 af 	call	0x15ece	; 0x15ece <_key_btn>
    cbde:	98 2f       	mov	r25, r24
    cbe0:	80 93 56 03 	sts	0x0356, r24
		    if ((KeyChar>='1')&&(KeyChar<='8')){
    cbe4:	81 53       	subi	r24, 0x31	; 49
    cbe6:	88 30       	cpi	r24, 0x08	; 8
    cbe8:	60 f4       	brcc	.+24     	; 0xcc02 <menu_FIP+0x220>
		 	     if (KeyCharLast!=KeyChar){
    cbea:	80 91 5a 01 	lds	r24, 0x015A
    cbee:	89 17       	cp	r24, r25
    cbf0:	41 f0       	breq	.+16     	; 0xcc02 <menu_FIP+0x220>
				     KeyCharLast=KeyChar;
    cbf2:	90 93 5a 01 	sts	0x015A, r25
				     iLoop=1000;
    cbf6:	88 ee       	ldi	r24, 0xE8	; 232
    cbf8:	93 e0       	ldi	r25, 0x03	; 3
    cbfa:	90 93 54 03 	sts	0x0354, r25
    cbfe:	80 93 53 03 	sts	0x0353, r24
                 }
		    }
 		    if ((iLoop%2000)==0){
    cc02:	80 91 53 03 	lds	r24, 0x0353
    cc06:	90 91 54 03 	lds	r25, 0x0354
    cc0a:	60 ed       	ldi	r22, 0xD0	; 208
    cc0c:	77 e0       	ldi	r23, 0x07	; 7
    cc0e:	0e 94 93 b8 	call	0x17126	; 0x17126 <__udivmodhi4>
    cc12:	89 2b       	or	r24, r25
    cc14:	39 f4       	brne	.+14     	; 0xcc24 <menu_FIP+0x242>
		        lcd_xy(1,19);_lcd('_'); 
    cc16:	81 e0       	ldi	r24, 0x01	; 1
    cc18:	63 e1       	ldi	r22, 0x13	; 19
    cc1a:	0e 94 4c ae 	call	0x15c98	; 0x15c98 <lcd_xy>
    cc1e:	8f e5       	ldi	r24, 0x5F	; 95
    cc20:	0e 94 26 ae 	call	0x15c4c	; 0x15c4c <_lcd>
			   }
           if ((iLoop%2000)==1000){
    cc24:	80 91 53 03 	lds	r24, 0x0353
    cc28:	90 91 54 03 	lds	r25, 0x0354
    cc2c:	60 ed       	ldi	r22, 0xD0	; 208
    cc2e:	77 e0       	ldi	r23, 0x07	; 7
    cc30:	0e 94 93 b8 	call	0x17126	; 0x17126 <__udivmodhi4>
    cc34:	88 5e       	subi	r24, 0xE8	; 232
    cc36:	93 40       	sbci	r25, 0x03	; 3
    cc38:	41 f4       	brne	.+16     	; 0xcc4a <menu_FIP+0x268>
			    lcd_xy(1,19);_lcd(KeyCharLast); 
    cc3a:	81 e0       	ldi	r24, 0x01	; 1
    cc3c:	63 e1       	ldi	r22, 0x13	; 19
    cc3e:	0e 94 4c ae 	call	0x15c98	; 0x15c98 <lcd_xy>
    cc42:	80 91 5a 01 	lds	r24, 0x015A
    cc46:	0e 94 26 ae 	call	0x15c4c	; 0x15c4c <_lcd>
			   }

		   if (((KeyChar>='1')&&(KeyChar<='8'))||(KeyPressed==_KEY_ENTER)&&(KeyCharLast!=' ')){ 
    cc4a:	80 91 56 03 	lds	r24, 0x0356
    cc4e:	81 53       	subi	r24, 0x31	; 49
    cc50:	88 30       	cpi	r24, 0x08	; 8
    cc52:	40 f0       	brcs	.+16     	; 0xcc64 <menu_FIP+0x282>
    cc54:	80 91 57 03 	lds	r24, 0x0357
    cc58:	87 3b       	cpi	r24, 0xB7	; 183
    cc5a:	a1 f5       	brne	.+104    	; 0xccc4 <menu_FIP+0x2e2>
    cc5c:	80 91 5a 01 	lds	r24, 0x015A
    cc60:	80 32       	cpi	r24, 0x20	; 32
    cc62:	c1 f1       	breq	.+112    	; 0xccd4 <menu_FIP+0x2f2>
		         FIP_Used=FIP[KeyCharLast-'1'];
    cc64:	80 91 5a 01 	lds	r24, 0x015A
    cc68:	fe 01       	movw	r30, r28
    cc6a:	ba 97       	sbiw	r30, 0x2a	; 42
    cc6c:	e8 0f       	add	r30, r24
    cc6e:	f1 1d       	adc	r31, r1
    cc70:	20 81       	ld	r18, Z
    cc72:	20 93 55 03 	sts	0x0355, r18
				 if (FIP_Used<=99){
    cc76:	24 36       	cpi	r18, 0x64	; 100
    cc78:	00 f5       	brcc	.+64     	; 0xccba <menu_FIP+0x2d8>
		}
     else {
	    sprintf_P(StrResult,PSTR("%d"),Val);
	 }
	 */
     sprintf_P(StrResult,PSTR("%.2d"),Val);
    cc7a:	00 d0       	rcall	.+0      	; 0xcc7c <menu_FIP+0x29a>
    cc7c:	00 d0       	rcall	.+0      	; 0xcc7e <menu_FIP+0x29c>
    cc7e:	00 d0       	rcall	.+0      	; 0xcc80 <menu_FIP+0x29e>
    cc80:	ed b7       	in	r30, 0x3d	; 61
    cc82:	fe b7       	in	r31, 0x3e	; 62
    cc84:	31 96       	adiw	r30, 0x01	; 1
    cc86:	ad b7       	in	r26, 0x3d	; 61
    cc88:	be b7       	in	r27, 0x3e	; 62
    cc8a:	12 96       	adiw	r26, 0x02	; 2
    cc8c:	1c 93       	st	X, r17
    cc8e:	0e 93       	st	-X, r16
    cc90:	11 97       	sbiw	r26, 0x01	; 1
    cc92:	8d e5       	ldi	r24, 0x5D	; 93
    cc94:	9d e0       	ldi	r25, 0x0D	; 13
    cc96:	93 83       	std	Z+3, r25	; 0x03
    cc98:	82 83       	std	Z+2, r24	; 0x02
    cc9a:	24 83       	std	Z+4, r18	; 0x04
    cc9c:	15 82       	std	Z+5, r1	; 0x05
    cc9e:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
		   if (((KeyChar>='1')&&(KeyChar<='8'))||(KeyPressed==_KEY_ENTER)&&(KeyCharLast!=' ')){ 
		         FIP_Used=FIP[KeyCharLast-'1'];
				 if (FIP_Used<=99){
                    leadingZero(FIP_Used,sFIPUsed);
					 //sprintf_P(sFIPUsed,PSTR("%.2d"),FIP_Used);
					 xFIP[0]=FIP_Used;
    cca2:	80 91 55 03 	lds	r24, 0x0355
    cca6:	f7 01       	movw	r30, r14
    cca8:	80 83       	st	Z, r24
    ccaa:	8d b7       	in	r24, 0x3d	; 61
    ccac:	9e b7       	in	r25, 0x3e	; 62
    ccae:	06 96       	adiw	r24, 0x06	; 6
    ccb0:	0f b6       	in	r0, 0x3f	; 63
    ccb2:	f8 94       	cli
    ccb4:	9e bf       	out	0x3e, r25	; 62
    ccb6:	0f be       	out	0x3f, r0	; 63
    ccb8:	8d bf       	out	0x3d, r24	; 61
					 }
				 Result=FIP_DONE;
                 stEnterFIP=efExitFIPInput;
    ccba:	82 e0       	ldi	r24, 0x02	; 2
    ccbc:	80 93 58 03 	sts	0x0358, r24
    ccc0:	80 e0       	ldi	r24, 0x00	; 0
    ccc2:	09 c0       	rjmp	.+18     	; 0xccd6 <menu_FIP+0x2f4>
		   }
		   else
		   if (KeyPressed==_KEY_CANCEL){
    ccc4:	87 3e       	cpi	r24, 0xE7	; 231
    ccc6:	31 f4       	brne	.+12     	; 0xccd4 <menu_FIP+0x2f2>
               Result=FIP_CANCEL;
			   stEnterFIP=efExitFIPInput;
    ccc8:	82 e0       	ldi	r24, 0x02	; 2
    ccca:	80 93 58 03 	sts	0x0358, r24
    ccce:	03 c0       	rjmp	.+6      	; 0xccd6 <menu_FIP+0x2f4>
		   }
	       break;
      case efExitFIPInput:
           stEnterFIP=efInit;
    ccd0:	10 92 58 03 	sts	0x0358, r1
    ccd4:	81 e0       	ldi	r24, 0x01	; 1
	       break;
	 }
return Result;
}
    ccd6:	a2 96       	adiw	r28, 0x22	; 34
    ccd8:	0f b6       	in	r0, 0x3f	; 63
    ccda:	f8 94       	cli
    ccdc:	de bf       	out	0x3e, r29	; 62
    ccde:	0f be       	out	0x3f, r0	; 63
    cce0:	cd bf       	out	0x3d, r28	; 61
    cce2:	cf 91       	pop	r28
    cce4:	df 91       	pop	r29
    cce6:	1f 91       	pop	r17
    cce8:	0f 91       	pop	r16
    ccea:	ff 90       	pop	r15
    ccec:	ef 90       	pop	r14
    ccee:	df 90       	pop	r13
    ccf0:	cf 90       	pop	r12
    ccf2:	bf 90       	pop	r11
    ccf4:	af 90       	pop	r10
    ccf6:	9f 90       	pop	r9
    ccf8:	8f 90       	pop	r8
    ccfa:	7f 90       	pop	r7
    ccfc:	6f 90       	pop	r6
    ccfe:	5f 90       	pop	r5
    cd00:	4f 90       	pop	r4
    cd02:	08 95       	ret

0000cd04 <FMenuEDCTransaction>:
	      break;
	 }
	 return Result;
}

char FMenuEDCTransaction(){
    cd04:	0f 93       	push	r16
    cd06:	1f 93       	push	r17
static char KeyPressed=0,FIP_Used=0,FIPResult;
       char lcdteks[20],Result=MENU_NONE;
//static unsigned int iLoop=0;

Result=MENU_NONE;
	 switch(stEtransaction){
    cd08:	80 91 4b 03 	lds	r24, 0x034B
    cd0c:	85 30       	cpi	r24, 0x05	; 5
    cd0e:	09 f4       	brne	.+2      	; 0xcd12 <FMenuEDCTransaction+0xe>
    cd10:	9f c0       	rjmp	.+318    	; 0xce50 <FMenuEDCTransaction+0x14c>
    cd12:	86 30       	cpi	r24, 0x06	; 6
    cd14:	90 f4       	brcc	.+36     	; 0xcd3a <FMenuEDCTransaction+0x36>
    cd16:	82 30       	cpi	r24, 0x02	; 2
    cd18:	09 f4       	brne	.+2      	; 0xcd1c <FMenuEDCTransaction+0x18>
    cd1a:	57 c0       	rjmp	.+174    	; 0xcdca <FMenuEDCTransaction+0xc6>
    cd1c:	83 30       	cpi	r24, 0x03	; 3
    cd1e:	30 f4       	brcc	.+12     	; 0xcd2c <FMenuEDCTransaction+0x28>
    cd20:	88 23       	and	r24, r24
    cd22:	f1 f0       	breq	.+60     	; 0xcd60 <FMenuEDCTransaction+0x5c>
    cd24:	81 30       	cpi	r24, 0x01	; 1
    cd26:	09 f0       	breq	.+2      	; 0xcd2a <FMenuEDCTransaction+0x26>
    cd28:	dd c0       	rjmp	.+442    	; 0xcee4 <FMenuEDCTransaction+0x1e0>
    cd2a:	36 c0       	rjmp	.+108    	; 0xcd98 <FMenuEDCTransaction+0x94>
    cd2c:	83 30       	cpi	r24, 0x03	; 3
    cd2e:	09 f4       	brne	.+2      	; 0xcd32 <FMenuEDCTransaction+0x2e>
    cd30:	5e c0       	rjmp	.+188    	; 0xcdee <FMenuEDCTransaction+0xea>
    cd32:	84 30       	cpi	r24, 0x04	; 4
    cd34:	09 f0       	breq	.+2      	; 0xcd38 <FMenuEDCTransaction+0x34>
    cd36:	d6 c0       	rjmp	.+428    	; 0xcee4 <FMenuEDCTransaction+0x1e0>
    cd38:	83 c0       	rjmp	.+262    	; 0xce40 <FMenuEDCTransaction+0x13c>
    cd3a:	88 30       	cpi	r24, 0x08	; 8
    cd3c:	09 f4       	brne	.+2      	; 0xcd40 <FMenuEDCTransaction+0x3c>
    cd3e:	c2 c0       	rjmp	.+388    	; 0xcec4 <FMenuEDCTransaction+0x1c0>
    cd40:	89 30       	cpi	r24, 0x09	; 9
    cd42:	38 f4       	brcc	.+14     	; 0xcd52 <FMenuEDCTransaction+0x4e>
    cd44:	86 30       	cpi	r24, 0x06	; 6
    cd46:	09 f4       	brne	.+2      	; 0xcd4a <FMenuEDCTransaction+0x46>
    cd48:	98 c0       	rjmp	.+304    	; 0xce7a <FMenuEDCTransaction+0x176>
    cd4a:	87 30       	cpi	r24, 0x07	; 7
    cd4c:	09 f0       	breq	.+2      	; 0xcd50 <FMenuEDCTransaction+0x4c>
    cd4e:	ca c0       	rjmp	.+404    	; 0xcee4 <FMenuEDCTransaction+0x1e0>
    cd50:	96 c0       	rjmp	.+300    	; 0xce7e <FMenuEDCTransaction+0x17a>
    cd52:	89 30       	cpi	r24, 0x09	; 9
    cd54:	09 f4       	brne	.+2      	; 0xcd58 <FMenuEDCTransaction+0x54>
    cd56:	bc c0       	rjmp	.+376    	; 0xced0 <FMenuEDCTransaction+0x1cc>
    cd58:	8a 30       	cpi	r24, 0x0A	; 10
    cd5a:	09 f0       	breq	.+2      	; 0xcd5e <FMenuEDCTransaction+0x5a>
    cd5c:	c3 c0       	rjmp	.+390    	; 0xcee4 <FMenuEDCTransaction+0x1e0>
    cd5e:	be c0       	rjmp	.+380    	; 0xcedc <FMenuEDCTransaction+0x1d8>
	 case etInit:
	      lcd_clear();
    cd60:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
		  lcd_printf(1,1,PSTR("Select Card Type"));
    cd64:	81 e0       	ldi	r24, 0x01	; 1
    cd66:	61 e0       	ldi	r22, 0x01	; 1
    cd68:	41 e1       	ldi	r20, 0x11	; 17
    cd6a:	5a e1       	ldi	r21, 0x1A	; 26
    cd6c:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
          lcd_printf(1,1,PSTR("1.Debit/Flash Card  "));
    cd70:	81 e0       	ldi	r24, 0x01	; 1
    cd72:	61 e0       	ldi	r22, 0x01	; 1
    cd74:	4c ef       	ldi	r20, 0xFC	; 252
    cd76:	59 e1       	ldi	r21, 0x19	; 25
    cd78:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		  lcd_printf(2,1,PSTR("2.Credit Card       "));
    cd7c:	82 e0       	ldi	r24, 0x02	; 2
    cd7e:	61 e0       	ldi	r22, 0x01	; 1
    cd80:	47 ee       	ldi	r20, 0xE7	; 231
    cd82:	59 e1       	ldi	r21, 0x19	; 25
    cd84:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
	      lcd_printf(4,1,PSTR("[*]Back             "));
    cd88:	84 e0       	ldi	r24, 0x04	; 4
    cd8a:	61 e0       	ldi	r22, 0x01	; 1
    cd8c:	42 ed       	ldi	r20, 0xD2	; 210
    cd8e:	59 e1       	ldi	r21, 0x19	; 25
    cd90:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		  stEtransaction=etInputEDC;
    cd94:	81 e0       	ldi	r24, 0x01	; 1
    cd96:	6e c0       	rjmp	.+220    	; 0xce74 <FMenuEDCTransaction+0x170>
	      break;
     case etInputEDC:
	 	  KeyPressed=_key_scan(1);
    cd98:	81 e0       	ldi	r24, 0x01	; 1
    cd9a:	0e 94 06 b0 	call	0x1600c	; 0x1600c <_key_scan>
    cd9e:	80 93 49 03 	sts	0x0349, r24
		  KeyChar=_key_btn(KeyPressed);
    cda2:	0e 94 67 af 	call	0x15ece	; 0x15ece <_key_btn>
    cda6:	98 2f       	mov	r25, r24
    cda8:	80 93 4a 03 	sts	0x034A, r24
		  if ((KeyChar>='1')&&(KeyChar<='2')){
    cdac:	81 53       	subi	r24, 0x31	; 49
    cdae:	82 30       	cpi	r24, 0x02	; 2
    cdb0:	30 f4       	brcc	.+12     	; 0xcdbe <FMenuEDCTransaction+0xba>
		       EDCType=KeyChar-'0';
    cdb2:	90 53       	subi	r25, 0x30	; 48
    cdb4:	90 93 10 0a 	sts	0x0A10, r25
		       stEtransaction=etSelectFIP;
    cdb8:	82 e0       	ldi	r24, 0x02	; 2
    cdba:	80 93 4b 03 	sts	0x034B, r24
		     }
		  if (KeyPressed==_KEY_CANCEL)stEtransaction=etExitEDCTransaction;
    cdbe:	80 91 49 03 	lds	r24, 0x0349
    cdc2:	87 3e       	cpi	r24, 0xE7	; 231
    cdc4:	09 f0       	breq	.+2      	; 0xcdc8 <FMenuEDCTransaction+0xc4>
    cdc6:	8e c0       	rjmp	.+284    	; 0xcee4 <FMenuEDCTransaction+0x1e0>
    cdc8:	87 c0       	rjmp	.+270    	; 0xced8 <FMenuEDCTransaction+0x1d4>
	      break;
	 case etSelectFIP:
	      FIPResult=menu_FIP(FIP_Used,strFIP_ID);
    cdca:	80 e0       	ldi	r24, 0x00	; 0
    cdcc:	90 e0       	ldi	r25, 0x00	; 0
    cdce:	6c e9       	ldi	r22, 0x9C	; 156
    cdd0:	79 e0       	ldi	r23, 0x09	; 9
    cdd2:	0e 94 f1 64 	call	0xc9e2	; 0xc9e2 <menu_FIP>
    cdd6:	80 93 48 03 	sts	0x0348, r24
		  if (FIPResult==FIP_DONE)stEtransaction=etInitMessage90;
    cdda:	88 23       	and	r24, r24
    cddc:	11 f4       	brne	.+4      	; 0xcde2 <FMenuEDCTransaction+0xde>
    cdde:	83 e0       	ldi	r24, 0x03	; 3
    cde0:	49 c0       	rjmp	.+146    	; 0xce74 <FMenuEDCTransaction+0x170>
		  else
		  if (FIPResult==FIP_CANCEL)stEtransaction=etInit;
    cde2:	82 30       	cpi	r24, 0x02	; 2
    cde4:	09 f0       	breq	.+2      	; 0xcde8 <FMenuEDCTransaction+0xe4>
    cde6:	7e c0       	rjmp	.+252    	; 0xcee4 <FMenuEDCTransaction+0x1e0>
    cde8:	10 92 4b 03 	sts	0x034B, r1
    cdec:	7b c0       	rjmp	.+246    	; 0xcee4 <FMenuEDCTransaction+0x1e0>
    cdee:	e8 e6       	ldi	r30, 0x68	; 104
    cdf0:	fe e0       	ldi	r31, 0x0E	; 14
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    cdf2:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    cdf4:	8e e0       	ldi	r24, 0x0E	; 14
    cdf6:	ed 37       	cpi	r30, 0x7D	; 125
    cdf8:	f8 07       	cpc	r31, r24
    cdfa:	d9 f7       	brne	.-10     	; 0xcdf2 <FMenuEDCTransaction+0xee>
		  else
		  if (FIPResult==FIP_CANCEL)stEtransaction=etInit;
	      break;
     case etInitMessage90:
	      FillChar(strRef1,sizeof(strRef1),0);
	      if (EDCType==1){
    cdfc:	80 91 10 0a 	lds	r24, 0x0A10
    ce00:	81 30       	cpi	r24, 0x01	; 1
    ce02:	19 f4       	brne	.+6      	; 0xce0a <FMenuEDCTransaction+0x106>
		      AddSpaceLag(strRef1,20);
    ce04:	cf 01       	movw	r24, r30
    ce06:	45 97       	sbiw	r24, 0x15	; 21
    ce08:	16 c0       	rjmp	.+44     	; 0xce36 <FMenuEDCTransaction+0x132>
          }
		  else
	      if (EDCType==2){
    ce0a:	82 30       	cpi	r24, 0x02	; 2
    ce0c:	b9 f4       	brne	.+46     	; 0xce3c <FMenuEDCTransaction+0x138>
		      sprintf_P(strRef1,PSTR("CREDITCARD"));
    ce0e:	00 d0       	rcall	.+0      	; 0xce10 <FMenuEDCTransaction+0x10c>
    ce10:	00 d0       	rcall	.+0      	; 0xce12 <FMenuEDCTransaction+0x10e>
    ce12:	8f 01       	movw	r16, r30
    ce14:	05 51       	subi	r16, 0x15	; 21
    ce16:	10 40       	sbci	r17, 0x00	; 0
    ce18:	ed b7       	in	r30, 0x3d	; 61
    ce1a:	fe b7       	in	r31, 0x3e	; 62
    ce1c:	12 83       	std	Z+2, r17	; 0x02
    ce1e:	01 83       	std	Z+1, r16	; 0x01
    ce20:	87 ec       	ldi	r24, 0xC7	; 199
    ce22:	99 e1       	ldi	r25, 0x19	; 25
    ce24:	94 83       	std	Z+4, r25	; 0x04
    ce26:	83 83       	std	Z+3, r24	; 0x03
    ce28:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
			  AddSpaceLag(strRef1,20);
    ce2c:	0f 90       	pop	r0
    ce2e:	0f 90       	pop	r0
    ce30:	0f 90       	pop	r0
    ce32:	0f 90       	pop	r0
    ce34:	c8 01       	movw	r24, r16
    ce36:	64 e1       	ldi	r22, 0x14	; 20
    ce38:	0e 94 40 2e 	call	0x5c80	; 0x5c80 <AddSpaceLag>
		  }	 
	      stEtransaction=etSendingMessage90;
    ce3c:	84 e0       	ldi	r24, 0x04	; 4
    ce3e:	1a c0       	rjmp	.+52     	; 0xce74 <FMenuEDCTransaction+0x170>
	      break;
     case etSendingMessage90:
          sendMessage90();
    ce40:	0e 94 e6 4f 	call	0x9fcc	; 0x9fcc <sendMessage90>
		  TimSend=0;
    ce44:	10 92 a9 01 	sts	0x01A9, r1
    ce48:	10 92 a8 01 	sts	0x01A8, r1
          stEtransaction=etWaitReply;
    ce4c:	85 e0       	ldi	r24, 0x05	; 5
    ce4e:	12 c0       	rjmp	.+36     	; 0xce74 <FMenuEDCTransaction+0x170>
	      break;
     case etWaitReply:
	      if (TimSend>TIM_SEND*2)stEtransaction=etNoConnection;
    ce50:	80 91 a8 01 	lds	r24, 0x01A8
    ce54:	90 91 a9 01 	lds	r25, 0x01A9
    ce58:	45 97       	sbiw	r24, 0x15	; 21
    ce5a:	18 f0       	brcs	.+6      	; 0xce62 <FMenuEDCTransaction+0x15e>
    ce5c:	88 e0       	ldi	r24, 0x08	; 8
    ce5e:	80 93 4b 03 	sts	0x034B, r24
		  if ((IsMessage91==True)||(IsMessage09==True))
    ce62:	80 91 be 01 	lds	r24, 0x01BE
    ce66:	81 30       	cpi	r24, 0x01	; 1
    ce68:	21 f0       	breq	.+8      	; 0xce72 <FMenuEDCTransaction+0x16e>
    ce6a:	80 91 ba 01 	lds	r24, 0x01BA
    ce6e:	81 30       	cpi	r24, 0x01	; 1
    ce70:	c9 f5       	brne	.+114    	; 0xcee4 <FMenuEDCTransaction+0x1e0>
		       stEtransaction=etSuccesEDC;
    ce72:	86 e0       	ldi	r24, 0x06	; 6
    ce74:	80 93 4b 03 	sts	0x034B, r24
    ce78:	35 c0       	rjmp	.+106    	; 0xcee4 <FMenuEDCTransaction+0x1e0>
	      break;
     case etSuccesEDC:
	      stEtransaction=etDisplayFreeMessage;
    ce7a:	87 e0       	ldi	r24, 0x07	; 7
    ce7c:	fb cf       	rjmp	.-10     	; 0xce74 <FMenuEDCTransaction+0x170>
	      break;
     case etDisplayFreeMessage:
	      if (IsMessage09==True){
    ce7e:	80 91 ba 01 	lds	r24, 0x01BA
    ce82:	81 30       	cpi	r24, 0x01	; 1
    ce84:	19 f5       	brne	.+70     	; 0xcecc <FMenuEDCTransaction+0x1c8>
		      IsMessage09=False;
    ce86:	10 92 ba 01 	sts	0x01BA, r1
	          procMessage09();
    ce8a:	0e 94 59 17 	call	0x2eb2	; 0x2eb2 <procMessage09>
		      lcd_clear();
    ce8e:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
		      lcd_print(1,1,strFreeMessageLine1);
    ce92:	81 e0       	ldi	r24, 0x01	; 1
    ce94:	61 e0       	ldi	r22, 0x01	; 1
    ce96:	47 e9       	ldi	r20, 0x97	; 151
    ce98:	5a e0       	ldi	r21, 0x0A	; 10
    ce9a:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
		      lcd_print(2,1,strFreeMessageLine2);
    ce9e:	82 e0       	ldi	r24, 0x02	; 2
    cea0:	61 e0       	ldi	r22, 0x01	; 1
    cea2:	46 e8       	ldi	r20, 0x86	; 134
    cea4:	59 e0       	ldi	r21, 0x09	; 9
    cea6:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
		      lcd_print(3,1,strFreeMessageLine3);
    ceaa:	83 e0       	ldi	r24, 0x03	; 3
    ceac:	61 e0       	ldi	r22, 0x01	; 1
    ceae:	41 e2       	ldi	r20, 0x21	; 33
    ceb0:	5a e0       	ldi	r21, 0x0A	; 10
    ceb2:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
			  lcd_print(4,1,strFreeMessageLine4);
    ceb6:	84 e0       	ldi	r24, 0x04	; 4
    ceb8:	61 e0       	ldi	r22, 0x01	; 1
    ceba:	41 eb       	ldi	r20, 0xB1	; 177
    cebc:	5d e0       	ldi	r21, 0x0D	; 13
    cebe:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
    cec2:	02 c0       	rjmp	.+4      	; 0xcec8 <FMenuEDCTransaction+0x1c4>
			  TimDisplay=0;
			  }
		  stEtransaction=etDelayExit;
	      break;
     case etNoConnection:
	      lcd_clear();
    cec4:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
		  TimDisplay=0;
    cec8:	10 92 a7 01 	sts	0x01A7, r1
		  stEtransaction=etDelayExit;
    cecc:	89 e0       	ldi	r24, 0x09	; 9
    cece:	d2 cf       	rjmp	.-92     	; 0xce74 <FMenuEDCTransaction+0x170>
	      break;
     case etDelayExit:
	      if (TimDisplay>8)stEtransaction=etExitEDCTransaction;
    ced0:	80 91 a7 01 	lds	r24, 0x01A7
    ced4:	89 30       	cpi	r24, 0x09	; 9
    ced6:	30 f0       	brcs	.+12     	; 0xcee4 <FMenuEDCTransaction+0x1e0>
    ced8:	8a e0       	ldi	r24, 0x0A	; 10
    ceda:	cc cf       	rjmp	.-104    	; 0xce74 <FMenuEDCTransaction+0x170>
	      break;
     case etExitEDCTransaction:
	      stEtransaction=etInit;
    cedc:	10 92 4b 03 	sts	0x034B, r1
    cee0:	81 e0       	ldi	r24, 0x01	; 1
    cee2:	01 c0       	rjmp	.+2      	; 0xcee6 <FMenuEDCTransaction+0x1e2>
    cee4:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
   return Result;
}
    cee6:	1f 91       	pop	r17
    cee8:	0f 91       	pop	r16
    ceea:	08 95       	ret

0000ceec <FMenuLoyalty>:
	      break;
	 }
  return Result;
}

char FMenuLoyalty(){
    ceec:	cf 92       	push	r12
    ceee:	df 92       	push	r13
    cef0:	ef 92       	push	r14
    cef2:	ff 92       	push	r15
    cef4:	0f 93       	push	r16
    cef6:	1f 93       	push	r17
    cef8:	df 93       	push	r29
    cefa:	cf 93       	push	r28
    cefc:	cd b7       	in	r28, 0x3d	; 61
    cefe:	de b7       	in	r29, 0x3e	; 62
    cf00:	64 97       	sbiw	r28, 0x14	; 20
    cf02:	0f b6       	in	r0, 0x3f	; 63
    cf04:	f8 94       	cli
    cf06:	de bf       	out	0x3e, r29	; 62
    cf08:	0f be       	out	0x3f, r0	; 63
    cf0a:	cd bf       	out	0x3d, r28	; 61
       char FIPResult,FIP_USED;
	   char Result=MENU_NONE;
	   char KeyChar;

     Result=MENU_NONE;
	 switch(stLoyalty){
    cf0c:	00 91 4f 03 	lds	r16, 0x034F
    cf10:	07 30       	cpi	r16, 0x07	; 7
    cf12:	09 f4       	brne	.+2      	; 0xcf16 <FMenuLoyalty+0x2a>
    cf14:	08 c1       	rjmp	.+528    	; 0xd126 <FMenuLoyalty+0x23a>
    cf16:	08 30       	cpi	r16, 0x08	; 8
    cf18:	98 f4       	brcc	.+38     	; 0xcf40 <FMenuLoyalty+0x54>
    cf1a:	03 30       	cpi	r16, 0x03	; 3
    cf1c:	09 f4       	brne	.+2      	; 0xcf20 <FMenuLoyalty+0x34>
    cf1e:	5d c0       	rjmp	.+186    	; 0xcfda <FMenuLoyalty+0xee>
    cf20:	04 30       	cpi	r16, 0x04	; 4
    cf22:	38 f4       	brcc	.+14     	; 0xcf32 <FMenuLoyalty+0x46>
    cf24:	01 30       	cpi	r16, 0x01	; 1
    cf26:	09 f4       	brne	.+2      	; 0xcf2a <FMenuLoyalty+0x3e>
    cf28:	42 c0       	rjmp	.+132    	; 0xcfae <FMenuLoyalty+0xc2>
    cf2a:	02 30       	cpi	r16, 0x02	; 2
    cf2c:	08 f0       	brcs	.+2      	; 0xcf30 <FMenuLoyalty+0x44>
    cf2e:	63 c0       	rjmp	.+198    	; 0xcff6 <FMenuLoyalty+0x10a>
    cf30:	20 c0       	rjmp	.+64     	; 0xcf72 <FMenuLoyalty+0x86>
    cf32:	05 30       	cpi	r16, 0x05	; 5
    cf34:	09 f4       	brne	.+2      	; 0xcf38 <FMenuLoyalty+0x4c>
    cf36:	a4 c0       	rjmp	.+328    	; 0xd080 <FMenuLoyalty+0x194>
    cf38:	06 30       	cpi	r16, 0x06	; 6
    cf3a:	08 f0       	brcs	.+2      	; 0xcf3e <FMenuLoyalty+0x52>
    cf3c:	be c0       	rjmp	.+380    	; 0xd0ba <FMenuLoyalty+0x1ce>
    cf3e:	8e c0       	rjmp	.+284    	; 0xd05c <FMenuLoyalty+0x170>
    cf40:	0b 30       	cpi	r16, 0x0B	; 11
    cf42:	09 f4       	brne	.+2      	; 0xcf46 <FMenuLoyalty+0x5a>
    cf44:	3e c1       	rjmp	.+636    	; 0xd1c2 <FMenuLoyalty+0x2d6>
    cf46:	0c 30       	cpi	r16, 0x0C	; 12
    cf48:	38 f4       	brcc	.+14     	; 0xcf58 <FMenuLoyalty+0x6c>
    cf4a:	09 30       	cpi	r16, 0x09	; 9
    cf4c:	09 f4       	brne	.+2      	; 0xcf50 <FMenuLoyalty+0x64>
    cf4e:	f6 c0       	rjmp	.+492    	; 0xd13c <FMenuLoyalty+0x250>
    cf50:	0a 30       	cpi	r16, 0x0A	; 10
    cf52:	08 f0       	brcs	.+2      	; 0xcf56 <FMenuLoyalty+0x6a>
    cf54:	18 c1       	rjmp	.+560    	; 0xd186 <FMenuLoyalty+0x29a>
    cf56:	ea c0       	rjmp	.+468    	; 0xd12c <FMenuLoyalty+0x240>
    cf58:	0d 30       	cpi	r16, 0x0D	; 13
    cf5a:	09 f4       	brne	.+2      	; 0xcf5e <FMenuLoyalty+0x72>
    cf5c:	f6 c1       	rjmp	.+1004   	; 0xd34a <FMenuLoyalty+0x45e>
    cf5e:	0d 30       	cpi	r16, 0x0D	; 13
    cf60:	08 f4       	brcc	.+2      	; 0xcf64 <FMenuLoyalty+0x78>
    cf62:	ff c1       	rjmp	.+1022   	; 0xd362 <FMenuLoyalty+0x476>
    cf64:	0e 30       	cpi	r16, 0x0E	; 14
    cf66:	09 f4       	brne	.+2      	; 0xcf6a <FMenuLoyalty+0x7e>
    cf68:	0e c2       	rjmp	.+1052   	; 0xd386 <FMenuLoyalty+0x49a>
    cf6a:	0f 30       	cpi	r16, 0x0F	; 15
    cf6c:	09 f0       	breq	.+2      	; 0xcf70 <FMenuLoyalty+0x84>
    cf6e:	17 c2       	rjmp	.+1070   	; 0xd39e <FMenuLoyalty+0x4b2>
    cf70:	10 c2       	rjmp	.+1056   	; 0xd392 <FMenuLoyalty+0x4a6>
	 case mlInit:
	      lcd_clear();
    cf72:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
		  lcd_printf(1,1,PSTR("  Menu Loyalty   "));
    cf76:	81 e0       	ldi	r24, 0x01	; 1
    cf78:	61 e0       	ldi	r22, 0x01	; 1
    cf7a:	4e ef       	ldi	r20, 0xFE	; 254
    cf7c:	5a e1       	ldi	r21, 0x1A	; 26
    cf7e:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
          lcd_printf(1,1,PSTR("1.Enquiry        "));
    cf82:	81 e0       	ldi	r24, 0x01	; 1
    cf84:	61 e0       	ldi	r22, 0x01	; 1
    cf86:	4c ee       	ldi	r20, 0xEC	; 236
    cf88:	5a e1       	ldi	r21, 0x1A	; 26
    cf8a:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		  lcd_printf(2,1,PSTR("2.Loyalty Update "));
    cf8e:	82 e0       	ldi	r24, 0x02	; 2
    cf90:	61 e0       	ldi	r22, 0x01	; 1
    cf92:	4a ed       	ldi	r20, 0xDA	; 218
    cf94:	5a e1       	ldi	r21, 0x1A	; 26
    cf96:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
	      lcd_printf(4,1,PSTR("[*]Back          "));
    cf9a:	84 e0       	ldi	r24, 0x04	; 4
    cf9c:	61 e0       	ldi	r22, 0x01	; 1
    cf9e:	48 ec       	ldi	r20, 0xC8	; 200
    cfa0:	5a e1       	ldi	r21, 0x1A	; 26
    cfa2:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		  IsLoyaltyUpdate=False;
    cfa6:	10 92 4c 03 	sts	0x034C, r1
		  stLoyalty=mlLoyaltySelect;
    cfaa:	81 e0       	ldi	r24, 0x01	; 1
    cfac:	0a c0       	rjmp	.+20     	; 0xcfc2 <FMenuLoyalty+0xd6>
	      break;
	 case mlLoyaltySelect:
	 	  KeyPressed=_key_scan(1);
    cfae:	81 e0       	ldi	r24, 0x01	; 1
    cfb0:	0e 94 06 b0 	call	0x1600c	; 0x1600c <_key_scan>
    cfb4:	80 93 4e 03 	sts	0x034E, r24
		  if (KeyPressed==_KEY_1){
    cfb8:	8e 3e       	cpi	r24, 0xEE	; 238
    cfba:	31 f4       	brne	.+12     	; 0xcfc8 <FMenuLoyalty+0xdc>
		      IsLoyaltyUpdate=False;
    cfbc:	10 92 4c 03 	sts	0x034C, r1
		      stLoyalty=mlShowEnquiry;
    cfc0:	84 e0       	ldi	r24, 0x04	; 4
    cfc2:	80 93 4f 03 	sts	0x034F, r24
    cfc6:	eb c1       	rjmp	.+982    	; 0xd39e <FMenuLoyalty+0x4b2>
			  }
		  else
		  if (KeyPressed==_KEY_2){
    cfc8:	8e 3d       	cpi	r24, 0xDE	; 222
    cfca:	19 f4       	brne	.+6      	; 0xcfd2 <FMenuLoyalty+0xe6>
		      IsLoyaltyUpdate=True;
    cfcc:	00 93 4c 03 	sts	0x034C, r16
    cfd0:	6b c0       	rjmp	.+214    	; 0xd0a8 <FMenuLoyalty+0x1bc>
			  stLoyalty=mlSelectFIP;
			  }
		  if (KeyPressed==_KEY_CANCEL)stLoyalty=mlExitLoyalty;
    cfd2:	87 3e       	cpi	r24, 0xE7	; 231
    cfd4:	09 f4       	brne	.+2      	; 0xcfd8 <FMenuLoyalty+0xec>
    cfd6:	db c1       	rjmp	.+950    	; 0xd38e <FMenuLoyalty+0x4a2>
    cfd8:	e2 c1       	rjmp	.+964    	; 0xd39e <FMenuLoyalty+0x4b2>
	      break;
     case mlSelectFIP:
	      FIPResult=menu_FIP(&FIP_Used,strFIP_ID);
    cfda:	8d e4       	ldi	r24, 0x4D	; 77
    cfdc:	93 e0       	ldi	r25, 0x03	; 3
    cfde:	6c e9       	ldi	r22, 0x9C	; 156
    cfe0:	79 e0       	ldi	r23, 0x09	; 9
    cfe2:	0e 94 f1 64 	call	0xc9e2	; 0xc9e2 <menu_FIP>
		  if (FIPResult==FIP_DONE)stLoyalty=mlUpdateLoyalty;
    cfe6:	88 23       	and	r24, r24
    cfe8:	11 f4       	brne	.+4      	; 0xcfee <FMenuLoyalty+0x102>
    cfea:	82 e0       	ldi	r24, 0x02	; 2
    cfec:	ea cf       	rjmp	.-44     	; 0xcfc2 <FMenuLoyalty+0xd6>
		  else
		  if (FIPResult==FIP_CANCEL)stLoyalty=mlInit;
    cfee:	82 30       	cpi	r24, 0x02	; 2
    cff0:	09 f0       	breq	.+2      	; 0xcff4 <FMenuLoyalty+0x108>
    cff2:	d5 c1       	rjmp	.+938    	; 0xd39e <FMenuLoyalty+0x4b2>
    cff4:	5b c0       	rjmp	.+182    	; 0xd0ac <FMenuLoyalty+0x1c0>
	      break;
     case mlUpdateLoyalty: 
	      lcd_clear();
    cff6:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
		  sprintf_P(lcdteks,PSTR("FIP:%s"),strFIP_ID);
    cffa:	00 d0       	rcall	.+0      	; 0xcffc <FMenuLoyalty+0x110>
    cffc:	00 d0       	rcall	.+0      	; 0xcffe <FMenuLoyalty+0x112>
    cffe:	00 d0       	rcall	.+0      	; 0xd000 <FMenuLoyalty+0x114>
    d000:	ed b7       	in	r30, 0x3d	; 61
    d002:	fe b7       	in	r31, 0x3e	; 62
    d004:	31 96       	adiw	r30, 0x01	; 1
    d006:	8e 01       	movw	r16, r28
    d008:	0f 5f       	subi	r16, 0xFF	; 255
    d00a:	1f 4f       	sbci	r17, 0xFF	; 255
    d00c:	ad b7       	in	r26, 0x3d	; 61
    d00e:	be b7       	in	r27, 0x3e	; 62
    d010:	12 96       	adiw	r26, 0x02	; 2
    d012:	1c 93       	st	X, r17
    d014:	0e 93       	st	-X, r16
    d016:	11 97       	sbiw	r26, 0x01	; 1
    d018:	81 ec       	ldi	r24, 0xC1	; 193
    d01a:	9a e1       	ldi	r25, 0x1A	; 26
    d01c:	93 83       	std	Z+3, r25	; 0x03
    d01e:	82 83       	std	Z+2, r24	; 0x02
    d020:	8c e9       	ldi	r24, 0x9C	; 156
    d022:	99 e0       	ldi	r25, 0x09	; 9
    d024:	95 83       	std	Z+5, r25	; 0x05
    d026:	84 83       	std	Z+4, r24	; 0x04
    d028:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
		  lcd_printf(1,1,PSTR("Tap Kartu RFID"));
    d02c:	8d b7       	in	r24, 0x3d	; 61
    d02e:	9e b7       	in	r25, 0x3e	; 62
    d030:	06 96       	adiw	r24, 0x06	; 6
    d032:	0f b6       	in	r0, 0x3f	; 63
    d034:	f8 94       	cli
    d036:	9e bf       	out	0x3e, r25	; 62
    d038:	0f be       	out	0x3f, r0	; 63
    d03a:	8d bf       	out	0x3d, r24	; 61
    d03c:	81 e0       	ldi	r24, 0x01	; 1
    d03e:	61 e0       	ldi	r22, 0x01	; 1
    d040:	42 eb       	ldi	r20, 0xB2	; 178
    d042:	5a e1       	ldi	r21, 0x1A	; 26
    d044:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		  lcd_print(2,1,lcdteks);
    d048:	82 e0       	ldi	r24, 0x02	; 2
    d04a:	61 e0       	ldi	r22, 0x01	; 1
    d04c:	a8 01       	movw	r20, r16
    d04e:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
          lcd_printf(4,1,PSTR("[*]Back    [#]Exit"));
    d052:	84 e0       	ldi	r24, 0x04	; 4
    d054:	61 e0       	ldi	r22, 0x01	; 1
    d056:	4f e9       	ldi	r20, 0x9F	; 159
    d058:	5a e1       	ldi	r21, 0x1A	; 26
    d05a:	0c c0       	rjmp	.+24     	; 0xd074 <FMenuLoyalty+0x188>
		  IsRFIDDetected=False;
	      stLoyalty=mlInputRFID;
	      break;
	 case mlShowEnquiry:
	      lcd_clear();
    d05c:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
		  lcd_printf(1,1,PSTR("Tap Kartu RFID"));
    d060:	81 e0       	ldi	r24, 0x01	; 1
    d062:	61 e0       	ldi	r22, 0x01	; 1
    d064:	40 e9       	ldi	r20, 0x90	; 144
    d066:	5a e1       	ldi	r21, 0x1A	; 26
    d068:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
          lcd_printf(4,1,PSTR("[*]Back    [#]Exit"));
    d06c:	84 e0       	ldi	r24, 0x04	; 4
    d06e:	61 e0       	ldi	r22, 0x01	; 1
    d070:	4d e7       	ldi	r20, 0x7D	; 125
    d072:	5a e1       	ldi	r21, 0x1A	; 26
    d074:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		  IsRFIDDetected=False;
    d078:	10 92 af 01 	sts	0x01AF, r1
		  stLoyalty=mlInputRFID;
    d07c:	85 e0       	ldi	r24, 0x05	; 5
    d07e:	a1 cf       	rjmp	.-190    	; 0xcfc2 <FMenuLoyalty+0xd6>
	      break;
     case mlInputRFID:
	      if (IsRFIDDetected==True){
    d080:	80 91 af 01 	lds	r24, 0x01AF
    d084:	81 30       	cpi	r24, 0x01	; 1
    d086:	29 f4       	brne	.+10     	; 0xd092 <FMenuLoyalty+0x1a6>
		      IsRFIDDetected=False;
    d088:	10 92 af 01 	sts	0x01AF, r1
		      stLoyalty=mlShowProsesRFID;
    d08c:	86 e0       	ldi	r24, 0x06	; 6
    d08e:	80 93 4f 03 	sts	0x034F, r24
		  }
	 	  KeyPressed=_key_scan(1);
    d092:	81 e0       	ldi	r24, 0x01	; 1
    d094:	0e 94 06 b0 	call	0x1600c	; 0x1600c <_key_scan>
    d098:	80 93 4e 03 	sts	0x034E, r24
		  if (KeyPressed==_KEY_CANCEL){
    d09c:	87 3e       	cpi	r24, 0xE7	; 231
    d09e:	49 f4       	brne	.+18     	; 0xd0b2 <FMenuLoyalty+0x1c6>
		      if (IsLoyaltyUpdate==True)
    d0a0:	80 91 4c 03 	lds	r24, 0x034C
    d0a4:	81 30       	cpi	r24, 0x01	; 1
    d0a6:	11 f4       	brne	.+4      	; 0xd0ac <FMenuLoyalty+0x1c0>
			       stLoyalty=mlSelectFIP;
    d0a8:	83 e0       	ldi	r24, 0x03	; 3
    d0aa:	8b cf       	rjmp	.-234    	; 0xcfc2 <FMenuLoyalty+0xd6>
			  else stLoyalty=mlInit;
    d0ac:	10 92 4f 03 	sts	0x034F, r1
    d0b0:	76 c1       	rjmp	.+748    	; 0xd39e <FMenuLoyalty+0x4b2>
			  }
		  else
		  if (KeyPressed==_KEY_ENTER)stLoyalty=mlExitLoyalty;
    d0b2:	87 3b       	cpi	r24, 0xB7	; 183
    d0b4:	09 f0       	breq	.+2      	; 0xd0b8 <FMenuLoyalty+0x1cc>
    d0b6:	73 c1       	rjmp	.+742    	; 0xd39e <FMenuLoyalty+0x4b2>
    d0b8:	6a c1       	rjmp	.+724    	; 0xd38e <FMenuLoyalty+0x4a2>
	      break;
     case mlShowProsesRFID:
	      lcd_clear();
    d0ba:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
		  sprintf_P(lcdteks,PSTR("ID:%s"),strRFID);
    d0be:	00 d0       	rcall	.+0      	; 0xd0c0 <FMenuLoyalty+0x1d4>
    d0c0:	00 d0       	rcall	.+0      	; 0xd0c2 <FMenuLoyalty+0x1d6>
    d0c2:	00 d0       	rcall	.+0      	; 0xd0c4 <FMenuLoyalty+0x1d8>
    d0c4:	ed b7       	in	r30, 0x3d	; 61
    d0c6:	fe b7       	in	r31, 0x3e	; 62
    d0c8:	31 96       	adiw	r30, 0x01	; 1
    d0ca:	8e 01       	movw	r16, r28
    d0cc:	0f 5f       	subi	r16, 0xFF	; 255
    d0ce:	1f 4f       	sbci	r17, 0xFF	; 255
    d0d0:	ad b7       	in	r26, 0x3d	; 61
    d0d2:	be b7       	in	r27, 0x3e	; 62
    d0d4:	12 96       	adiw	r26, 0x02	; 2
    d0d6:	1c 93       	st	X, r17
    d0d8:	0e 93       	st	-X, r16
    d0da:	11 97       	sbiw	r26, 0x01	; 1
    d0dc:	87 e7       	ldi	r24, 0x77	; 119
    d0de:	9a e1       	ldi	r25, 0x1A	; 26
    d0e0:	93 83       	std	Z+3, r25	; 0x03
    d0e2:	82 83       	std	Z+2, r24	; 0x02
    d0e4:	8c e2       	ldi	r24, 0x2C	; 44
    d0e6:	9e e0       	ldi	r25, 0x0E	; 14
    d0e8:	95 83       	std	Z+5, r25	; 0x05
    d0ea:	84 83       	std	Z+4, r24	; 0x04
    d0ec:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
		  lcd_print (1,1,lcdteks);	      
    d0f0:	8d b7       	in	r24, 0x3d	; 61
    d0f2:	9e b7       	in	r25, 0x3e	; 62
    d0f4:	06 96       	adiw	r24, 0x06	; 6
    d0f6:	0f b6       	in	r0, 0x3f	; 63
    d0f8:	f8 94       	cli
    d0fa:	9e bf       	out	0x3e, r25	; 62
    d0fc:	0f be       	out	0x3f, r0	; 63
    d0fe:	8d bf       	out	0x3d, r24	; 61
    d100:	81 e0       	ldi	r24, 0x01	; 1
    d102:	61 e0       	ldi	r22, 0x01	; 1
    d104:	a8 01       	movw	r20, r16
    d106:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
		  lcd_printf(2,1,PSTR("Proses"));	      
    d10a:	82 e0       	ldi	r24, 0x02	; 2
    d10c:	61 e0       	ldi	r22, 0x01	; 1
    d10e:	40 e7       	ldi	r20, 0x70	; 112
    d110:	5a e1       	ldi	r21, 0x1A	; 26
    d112:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		  if (IsLoyaltyUpdate==True)stLoyalty=mlSendMessage24;
    d116:	80 91 4c 03 	lds	r24, 0x034C
    d11a:	81 30       	cpi	r24, 0x01	; 1
    d11c:	11 f4       	brne	.+4      	; 0xd122 <FMenuLoyalty+0x236>
    d11e:	88 e0       	ldi	r24, 0x08	; 8
    d120:	50 cf       	rjmp	.-352    	; 0xcfc2 <FMenuLoyalty+0xd6>
		  else stLoyalty=mlSendMessage22;
    d122:	87 e0       	ldi	r24, 0x07	; 7
    d124:	4e cf       	rjmp	.-356    	; 0xcfc2 <FMenuLoyalty+0xd6>
	      break;
     case mlSendMessage22:
	      sendMessage22();
    d126:	0e 94 58 53 	call	0xa6b0	; 0xa6b0 <sendMessage22>
    d12a:	02 c0       	rjmp	.+4      	; 0xd130 <FMenuLoyalty+0x244>
		  TimSend=0;		  
          stLoyalty=mlWaitReply;
	      break;
     case mlSendMessage24:
	      sendMessage24();
    d12c:	0e 94 cc 52 	call	0xa598	; 0xa598 <sendMessage24>
		  TimSend=0;		  
    d130:	10 92 a9 01 	sts	0x01A9, r1
    d134:	10 92 a8 01 	sts	0x01A8, r1
          stLoyalty=mlWaitReply;
    d138:	89 e0       	ldi	r24, 0x09	; 9
    d13a:	43 cf       	rjmp	.-378    	; 0xcfc2 <FMenuLoyalty+0xd6>
	      break;
     case mlWaitReply:
	      if (TimSend>(TIM_SEND*3))
    d13c:	80 91 a8 01 	lds	r24, 0x01A8
    d140:	90 91 a9 01 	lds	r25, 0x01A9
    d144:	4f 97       	sbiw	r24, 0x1f	; 31
    d146:	18 f0       	brcs	.+6      	; 0xd14e <FMenuLoyalty+0x262>
		      stLoyalty=mlNoConnection;
    d148:	8c e0       	ldi	r24, 0x0C	; 12
    d14a:	80 93 4f 03 	sts	0x034F, r24
	      if (IsMessage23==True){
    d14e:	80 91 b9 01 	lds	r24, 0x01B9
    d152:	81 30       	cpi	r24, 0x01	; 1
    d154:	39 f4       	brne	.+14     	; 0xd164 <FMenuLoyalty+0x278>
		      IsMessage23=False;
    d156:	10 92 b9 01 	sts	0x01B9, r1
			  procMessage23();
    d15a:	0e 94 a4 17 	call	0x2f48	; 0x2f48 <procMessage23>
			  stLoyalty=mlDispEnquiry;
    d15e:	8b e0       	ldi	r24, 0x0B	; 11
    d160:	80 93 4f 03 	sts	0x034F, r24
		  }
	      if (IsMessage09==True){
    d164:	80 91 ba 01 	lds	r24, 0x01BA
    d168:	81 30       	cpi	r24, 0x01	; 1
    d16a:	39 f4       	brne	.+14     	; 0xd17a <FMenuLoyalty+0x28e>
		      IsMessage09=False;
    d16c:	10 92 ba 01 	sts	0x01BA, r1
	          procMessage09();
    d170:	0e 94 59 17 	call	0x2eb2	; 0x2eb2 <procMessage09>
              stLoyalty=mlDisplayFreeMessage;
    d174:	8a e0       	ldi	r24, 0x0A	; 10
    d176:	80 93 4f 03 	sts	0x034F, r24
		  }
	      if (IsMessage99==True){
    d17a:	80 91 b6 01 	lds	r24, 0x01B6
    d17e:	81 30       	cpi	r24, 0x01	; 1
    d180:	09 f0       	breq	.+2      	; 0xd184 <FMenuLoyalty+0x298>
    d182:	0d c1       	rjmp	.+538    	; 0xd39e <FMenuLoyalty+0x4b2>
    d184:	1c c0       	rjmp	.+56     	; 0xd1be <FMenuLoyalty+0x2d2>
              stLoyalty=mlDelayExitLoyalty;
		  }
	      break;
     case mlDisplayFreeMessage:
		  lcd_clear();
    d186:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
		  lcd_print(1,1,strFreeMessageLine1);
    d18a:	81 e0       	ldi	r24, 0x01	; 1
    d18c:	61 e0       	ldi	r22, 0x01	; 1
    d18e:	47 e9       	ldi	r20, 0x97	; 151
    d190:	5a e0       	ldi	r21, 0x0A	; 10
    d192:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
		  lcd_print(2,1,strFreeMessageLine2);
    d196:	82 e0       	ldi	r24, 0x02	; 2
    d198:	61 e0       	ldi	r22, 0x01	; 1
    d19a:	46 e8       	ldi	r20, 0x86	; 134
    d19c:	59 e0       	ldi	r21, 0x09	; 9
    d19e:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
		  lcd_print(3,1,strFreeMessageLine3);
    d1a2:	83 e0       	ldi	r24, 0x03	; 3
    d1a4:	61 e0       	ldi	r22, 0x01	; 1
    d1a6:	41 e2       	ldi	r20, 0x21	; 33
    d1a8:	5a e0       	ldi	r21, 0x0A	; 10
    d1aa:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
		  lcd_print(4,1,strFreeMessageLine4);
    d1ae:	84 e0       	ldi	r24, 0x04	; 4
    d1b0:	61 e0       	ldi	r22, 0x01	; 1
    d1b2:	41 eb       	ldi	r20, 0xB1	; 177
    d1b4:	5d e0       	ldi	r21, 0x0D	; 13
    d1b6:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
		  TimDisplay=0;
    d1ba:	10 92 a7 01 	sts	0x01A7, r1
		  stLoyalty=mlDelayExitLoyalty;
    d1be:	8e e0       	ldi	r24, 0x0E	; 14
    d1c0:	00 cf       	rjmp	.-512    	; 0xcfc2 <FMenuLoyalty+0xd6>
	      break;
     case mlDispEnquiry:	      
	      lcd_clear();
    d1c2:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
		  RemSpaceLag(strCardID);RemSpaceLag(strCardHolder);
    d1c6:	21 e6       	ldi	r18, 0x61	; 97
    d1c8:	c2 2e       	mov	r12, r18
    d1ca:	2d e0       	ldi	r18, 0x0D	; 13
    d1cc:	d2 2e       	mov	r13, r18
    d1ce:	c6 01       	movw	r24, r12
    d1d0:	0e 94 4c 26 	call	0x4c98	; 0x4c98 <RemSpaceLag>
    d1d4:	94 e0       	ldi	r25, 0x04	; 4
    d1d6:	e9 2e       	mov	r14, r25
    d1d8:	95 e0       	ldi	r25, 0x05	; 5
    d1da:	f9 2e       	mov	r15, r25
    d1dc:	c7 01       	movw	r24, r14
    d1de:	0e 94 4c 26 	call	0x4c98	; 0x4c98 <RemSpaceLag>
		  sprintf_P(lcdteks,PSTR("%s:%s"),strCardID,strCardHolder);
    d1e2:	ad b7       	in	r26, 0x3d	; 61
    d1e4:	be b7       	in	r27, 0x3e	; 62
    d1e6:	18 97       	sbiw	r26, 0x08	; 8
    d1e8:	0f b6       	in	r0, 0x3f	; 63
    d1ea:	f8 94       	cli
    d1ec:	be bf       	out	0x3e, r27	; 62
    d1ee:	0f be       	out	0x3f, r0	; 63
    d1f0:	ad bf       	out	0x3d, r26	; 61
    d1f2:	ed b7       	in	r30, 0x3d	; 61
    d1f4:	fe b7       	in	r31, 0x3e	; 62
    d1f6:	31 96       	adiw	r30, 0x01	; 1
    d1f8:	8e 01       	movw	r16, r28
    d1fa:	0f 5f       	subi	r16, 0xFF	; 255
    d1fc:	1f 4f       	sbci	r17, 0xFF	; 255
    d1fe:	12 96       	adiw	r26, 0x02	; 2
    d200:	1c 93       	st	X, r17
    d202:	0e 93       	st	-X, r16
    d204:	11 97       	sbiw	r26, 0x01	; 1
    d206:	8a e6       	ldi	r24, 0x6A	; 106
    d208:	9a e1       	ldi	r25, 0x1A	; 26
    d20a:	93 83       	std	Z+3, r25	; 0x03
    d20c:	82 83       	std	Z+2, r24	; 0x02
    d20e:	d5 82       	std	Z+5, r13	; 0x05
    d210:	c4 82       	std	Z+4, r12	; 0x04
    d212:	f7 82       	std	Z+7, r15	; 0x07
    d214:	e6 82       	std	Z+6, r14	; 0x06
    d216:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
		  lcd_print(1,1,lcdteks);RemSpaceLag(strLoyCurrentPoints);
    d21a:	8d b7       	in	r24, 0x3d	; 61
    d21c:	9e b7       	in	r25, 0x3e	; 62
    d21e:	08 96       	adiw	r24, 0x08	; 8
    d220:	0f b6       	in	r0, 0x3f	; 63
    d222:	f8 94       	cli
    d224:	9e bf       	out	0x3e, r25	; 62
    d226:	0f be       	out	0x3f, r0	; 63
    d228:	8d bf       	out	0x3d, r24	; 61
    d22a:	81 e0       	ldi	r24, 0x01	; 1
    d22c:	61 e0       	ldi	r22, 0x01	; 1
    d22e:	a8 01       	movw	r20, r16
    d230:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
    d234:	8a e3       	ldi	r24, 0x3A	; 58
    d236:	e8 2e       	mov	r14, r24
    d238:	8a e0       	ldi	r24, 0x0A	; 10
    d23a:	f8 2e       	mov	r15, r24
    d23c:	c7 01       	movw	r24, r14
    d23e:	0e 94 4c 26 	call	0x4c98	; 0x4c98 <RemSpaceLag>
		  sprintf_P(lcdteks,PSTR("Points:%s"),strLoyCurrentPoints);
    d242:	00 d0       	rcall	.+0      	; 0xd244 <FMenuLoyalty+0x358>
    d244:	00 d0       	rcall	.+0      	; 0xd246 <FMenuLoyalty+0x35a>
    d246:	00 d0       	rcall	.+0      	; 0xd248 <FMenuLoyalty+0x35c>
    d248:	ed b7       	in	r30, 0x3d	; 61
    d24a:	fe b7       	in	r31, 0x3e	; 62
    d24c:	31 96       	adiw	r30, 0x01	; 1
    d24e:	ad b7       	in	r26, 0x3d	; 61
    d250:	be b7       	in	r27, 0x3e	; 62
    d252:	12 96       	adiw	r26, 0x02	; 2
    d254:	1c 93       	st	X, r17
    d256:	0e 93       	st	-X, r16
    d258:	11 97       	sbiw	r26, 0x01	; 1
    d25a:	80 e6       	ldi	r24, 0x60	; 96
    d25c:	9a e1       	ldi	r25, 0x1A	; 26
    d25e:	93 83       	std	Z+3, r25	; 0x03
    d260:	82 83       	std	Z+2, r24	; 0x02
    d262:	f5 82       	std	Z+5, r15	; 0x05
    d264:	e4 82       	std	Z+4, r14	; 0x04
    d266:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
		  lcd_print(2,1,lcdteks);RemSpaceLag(strLoyCurrentPoints);
    d26a:	8d b7       	in	r24, 0x3d	; 61
    d26c:	9e b7       	in	r25, 0x3e	; 62
    d26e:	06 96       	adiw	r24, 0x06	; 6
    d270:	0f b6       	in	r0, 0x3f	; 63
    d272:	f8 94       	cli
    d274:	9e bf       	out	0x3e, r25	; 62
    d276:	0f be       	out	0x3f, r0	; 63
    d278:	8d bf       	out	0x3d, r24	; 61
    d27a:	82 e0       	ldi	r24, 0x02	; 2
    d27c:	61 e0       	ldi	r22, 0x01	; 1
    d27e:	a8 01       	movw	r20, r16
    d280:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
    d284:	c7 01       	movw	r24, r14
    d286:	0e 94 4c 26 	call	0x4c98	; 0x4c98 <RemSpaceLag>
		  sprintf_P(lcdteks,PSTR("CM Amt:%s"),strLoyCurrMonConsumeA);
    d28a:	00 d0       	rcall	.+0      	; 0xd28c <FMenuLoyalty+0x3a0>
    d28c:	00 d0       	rcall	.+0      	; 0xd28e <FMenuLoyalty+0x3a2>
    d28e:	00 d0       	rcall	.+0      	; 0xd290 <FMenuLoyalty+0x3a4>
    d290:	ed b7       	in	r30, 0x3d	; 61
    d292:	fe b7       	in	r31, 0x3e	; 62
    d294:	31 96       	adiw	r30, 0x01	; 1
    d296:	ad b7       	in	r26, 0x3d	; 61
    d298:	be b7       	in	r27, 0x3e	; 62
    d29a:	12 96       	adiw	r26, 0x02	; 2
    d29c:	1c 93       	st	X, r17
    d29e:	0e 93       	st	-X, r16
    d2a0:	11 97       	sbiw	r26, 0x01	; 1
    d2a2:	86 e5       	ldi	r24, 0x56	; 86
    d2a4:	9a e1       	ldi	r25, 0x1A	; 26
    d2a6:	93 83       	std	Z+3, r25	; 0x03
    d2a8:	82 83       	std	Z+2, r24	; 0x02
    d2aa:	8e e5       	ldi	r24, 0x5E	; 94
    d2ac:	95 e0       	ldi	r25, 0x05	; 5
    d2ae:	95 83       	std	Z+5, r25	; 0x05
    d2b0:	84 83       	std	Z+4, r24	; 0x04
    d2b2:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
		  lcd_print(3,1,lcdteks);RemSpaceLag(strLoyCurrentPoints);
    d2b6:	8d b7       	in	r24, 0x3d	; 61
    d2b8:	9e b7       	in	r25, 0x3e	; 62
    d2ba:	06 96       	adiw	r24, 0x06	; 6
    d2bc:	0f b6       	in	r0, 0x3f	; 63
    d2be:	f8 94       	cli
    d2c0:	9e bf       	out	0x3e, r25	; 62
    d2c2:	0f be       	out	0x3f, r0	; 63
    d2c4:	8d bf       	out	0x3d, r24	; 61
    d2c6:	83 e0       	ldi	r24, 0x03	; 3
    d2c8:	61 e0       	ldi	r22, 0x01	; 1
    d2ca:	a8 01       	movw	r20, r16
    d2cc:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
    d2d0:	c7 01       	movw	r24, r14
    d2d2:	0e 94 4c 26 	call	0x4c98	; 0x4c98 <RemSpaceLag>
		  sprintf_P(lcdteks,PSTR("Cm Vol:%s"),strLoyCurrMonConsumeV);
    d2d6:	00 d0       	rcall	.+0      	; 0xd2d8 <FMenuLoyalty+0x3ec>
    d2d8:	00 d0       	rcall	.+0      	; 0xd2da <FMenuLoyalty+0x3ee>
    d2da:	00 d0       	rcall	.+0      	; 0xd2dc <FMenuLoyalty+0x3f0>
    d2dc:	ed b7       	in	r30, 0x3d	; 61
    d2de:	fe b7       	in	r31, 0x3e	; 62
    d2e0:	31 96       	adiw	r30, 0x01	; 1
    d2e2:	ad b7       	in	r26, 0x3d	; 61
    d2e4:	be b7       	in	r27, 0x3e	; 62
    d2e6:	12 96       	adiw	r26, 0x02	; 2
    d2e8:	1c 93       	st	X, r17
    d2ea:	0e 93       	st	-X, r16
    d2ec:	11 97       	sbiw	r26, 0x01	; 1
    d2ee:	8c e4       	ldi	r24, 0x4C	; 76
    d2f0:	9a e1       	ldi	r25, 0x1A	; 26
    d2f2:	93 83       	std	Z+3, r25	; 0x03
    d2f4:	82 83       	std	Z+2, r24	; 0x02
    d2f6:	88 ec       	ldi	r24, 0xC8	; 200
    d2f8:	9d e0       	ldi	r25, 0x0D	; 13
    d2fa:	95 83       	std	Z+5, r25	; 0x05
    d2fc:	84 83       	std	Z+4, r24	; 0x04
    d2fe:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
		  lcd_print(4,1,lcdteks);
    d302:	8d b7       	in	r24, 0x3d	; 61
    d304:	9e b7       	in	r25, 0x3e	; 62
    d306:	06 96       	adiw	r24, 0x06	; 6
    d308:	0f b6       	in	r0, 0x3f	; 63
    d30a:	f8 94       	cli
    d30c:	9e bf       	out	0x3e, r25	; 62
    d30e:	0f be       	out	0x3f, r0	; 63
    d310:	8d bf       	out	0x3d, r24	; 61
    d312:	84 e0       	ldi	r24, 0x04	; 4
    d314:	61 e0       	ldi	r22, 0x01	; 1
    d316:	a8 01       	movw	r20, r16
    d318:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
		  TimDisplay=0;
    d31c:	10 92 a7 01 	sts	0x01A7, r1
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    d320:	e1 99       	sbic	0x1c, 1	; 28
    d322:	fe cf       	rjmp	.-4      	; 0xd320 <FMenuLoyalty+0x434>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    d324:	88 e3       	ldi	r24, 0x38	; 56
    d326:	90 e0       	ldi	r25, 0x00	; 0
    d328:	9f bb       	out	0x1f, r25	; 31
    d32a:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    d32c:	e0 9a       	sbi	0x1c, 0	; 28
    d32e:	8d b3       	in	r24, 0x1d	; 29

		  if (eeprom_read_byte(&DefNotifScreen)==1) {
    d330:	81 30       	cpi	r24, 0x01	; 1
    d332:	09 f0       	breq	.+2      	; 0xd336 <FMenuLoyalty+0x44a>
    d334:	44 cf       	rjmp	.-376    	; 0xd1be <FMenuLoyalty+0x2d2>
		      stLoyalty=mlPressAnyKey;
    d336:	8d e0       	ldi	r24, 0x0D	; 13
    d338:	80 93 4f 03 	sts	0x034F, r24
			  lcd_printf(2,1,PSTR("Press Any Key"));
    d33c:	82 e0       	ldi	r24, 0x02	; 2
    d33e:	61 e0       	ldi	r22, 0x01	; 1
    d340:	4e e3       	ldi	r20, 0x3E	; 62
    d342:	5a e1       	ldi	r21, 0x1A	; 26
    d344:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
    d348:	2a c0       	rjmp	.+84     	; 0xd39e <FMenuLoyalty+0x4b2>
          } else stLoyalty=mlDelayExitLoyalty;
		  break;
     case mlPressAnyKey:
	      KeyPressed=_key_scan(1);
    d34a:	81 e0       	ldi	r24, 0x01	; 1
    d34c:	0e 94 06 b0 	call	0x1600c	; 0x1600c <_key_scan>
    d350:	80 93 4e 03 	sts	0x034E, r24
	      KeyChar=_key_btn(KeyPressed);
    d354:	0e 94 67 af 	call	0x15ece	; 0x15ece <_key_btn>
	      switch(KeyChar){		  
    d358:	83 32       	cpi	r24, 0x23	; 35
    d35a:	c9 f0       	breq	.+50     	; 0xd38e <FMenuLoyalty+0x4a2>
    d35c:	8a 32       	cpi	r24, 0x2A	; 42
    d35e:	f9 f4       	brne	.+62     	; 0xd39e <FMenuLoyalty+0x4b2>
    d360:	16 c0       	rjmp	.+44     	; 0xd38e <FMenuLoyalty+0x4a2>
               stLoyalty=mlExitLoyalty;
		       break;		  
		  }
	      break;
     case mlNoConnection:
	      lcd_clear();
    d362:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
		  lcd_printf(2,1,PSTR("TCP/IP ERROR "));
    d366:	82 e0       	ldi	r24, 0x02	; 2
    d368:	61 e0       	ldi	r22, 0x01	; 1
    d36a:	40 e3       	ldi	r20, 0x30	; 48
    d36c:	5a e1       	ldi	r21, 0x1A	; 26
    d36e:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		  lcd_printf(3,1,PSTR("No Connection"));
    d372:	83 e0       	ldi	r24, 0x03	; 3
    d374:	61 e0       	ldi	r22, 0x01	; 1
    d376:	42 e2       	ldi	r20, 0x22	; 34
    d378:	5a e1       	ldi	r21, 0x1A	; 26
    d37a:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		  TimDisplay=5;
    d37e:	85 e0       	ldi	r24, 0x05	; 5
    d380:	80 93 a7 01 	sts	0x01A7, r24
    d384:	1c cf       	rjmp	.-456    	; 0xd1be <FMenuLoyalty+0x2d2>
		  stLoyalty=mlDelayExitLoyalty;
	      break;
     case mlDelayExitLoyalty:
          if(TimDisplay>=10)stLoyalty=mlExitLoyalty;
    d386:	80 91 a7 01 	lds	r24, 0x01A7
    d38a:	8a 30       	cpi	r24, 0x0A	; 10
    d38c:	40 f0       	brcs	.+16     	; 0xd39e <FMenuLoyalty+0x4b2>
    d38e:	8f e0       	ldi	r24, 0x0F	; 15
    d390:	18 ce       	rjmp	.-976    	; 0xcfc2 <FMenuLoyalty+0xd6>
	      break;
	 case mlExitLoyalty:
	      lcd_clear();
    d392:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
	      stLoyalty=mlInit;
    d396:	10 92 4f 03 	sts	0x034F, r1
    d39a:	81 e0       	ldi	r24, 0x01	; 1
    d39c:	01 c0       	rjmp	.+2      	; 0xd3a0 <FMenuLoyalty+0x4b4>
    d39e:	80 e0       	ldi	r24, 0x00	; 0
		  Result=MENU_DONE;
	      break;
	 }
	 return Result;
}
    d3a0:	64 96       	adiw	r28, 0x14	; 20
    d3a2:	0f b6       	in	r0, 0x3f	; 63
    d3a4:	f8 94       	cli
    d3a6:	de bf       	out	0x3e, r29	; 62
    d3a8:	0f be       	out	0x3f, r0	; 63
    d3aa:	cd bf       	out	0x3d, r28	; 61
    d3ac:	cf 91       	pop	r28
    d3ae:	df 91       	pop	r29
    d3b0:	1f 91       	pop	r17
    d3b2:	0f 91       	pop	r16
    d3b4:	ff 90       	pop	r15
    d3b6:	ef 90       	pop	r14
    d3b8:	df 90       	pop	r13
    d3ba:	cf 90       	pop	r12
    d3bc:	08 95       	ret

0000d3be <ValidateRestoreCode>:
	     strKeyStamp[i]='0'+GeniusCalc(G_MULTY,(sSeed[i]-'0'),(sGCode[i]-'0'));		 
	 }strKeyStamp[strlen(sGCode)]=0;
     WrapCode(strKeyStamp);
}

char ValidateRestoreCode(char *sKeyStamp, char *sRestoreCode){//==RC_VALID
    d3be:	ef 92       	push	r14
    d3c0:	ff 92       	push	r15
    d3c2:	0f 93       	push	r16
    d3c4:	1f 93       	push	r17
    d3c6:	cf 93       	push	r28
    d3c8:	df 93       	push	r29
    d3ca:	ec 01       	movw	r28, r24
    d3cc:	7b 01       	movw	r14, r22

	 //  KeyStamp: [6]5585577 WrapCode6x
	 //sprintf_P(strSend,PSTR("KeyStamp:%s"),sKeyStamp);
	 //_uart_print(1,1,strSend);

	 nSum=sKeyStamp[0]-'0';
    d3ce:	08 81       	ld	r16, Y
    d3d0:	00 53       	subi	r16, 0x30	; 48
    d3d2:	10 e0       	ldi	r17, 0x00	; 0
    d3d4:	04 c0       	rjmp	.+8      	; 0xd3de <ValidateRestoreCode+0x20>
	 for (i=0;i<nSum;i++){
         WrapCode(sKeyStamp);
    d3d6:	ce 01       	movw	r24, r28
    d3d8:	0e 94 79 31 	call	0x62f2	; 0x62f2 <WrapCode>
	 //  KeyStamp: [6]5585577 WrapCode6x
	 //sprintf_P(strSend,PSTR("KeyStamp:%s"),sKeyStamp);
	 //_uart_print(1,1,strSend);

	 nSum=sKeyStamp[0]-'0';
	 for (i=0;i<nSum;i++){
    d3dc:	1f 5f       	subi	r17, 0xFF	; 255
    d3de:	10 17       	cp	r17, r16
    d3e0:	d0 f3       	brcs	.-12     	; 0xd3d6 <ValidateRestoreCode+0x18>
	 //_uart_print(1,1,strSend);
     
	 //sprintf_P(strSend,PSTR("WrapStamp:%s"),sRestoreCode);
	 //_uart_print(1,1,strSend);

	 if (strcmp(sKeyStamp,sRestoreCode)==0)
    d3e2:	ce 01       	movw	r24, r28
    d3e4:	b7 01       	movw	r22, r14
    d3e6:	0e 94 6a b5 	call	0x16ad4	; 0x16ad4 <strcmp>
    d3ea:	00 97       	sbiw	r24, 0x00	; 0
    d3ec:	11 f0       	breq	.+4      	; 0xd3f2 <ValidateRestoreCode+0x34>
    d3ee:	82 e0       	ldi	r24, 0x02	; 2
    d3f0:	01 c0       	rjmp	.+2      	; 0xd3f4 <ValidateRestoreCode+0x36>
    d3f2:	81 e0       	ldi	r24, 0x01	; 1
	     Result=RC_VALID;	 
     else Result=RC_INVALID;

   return Result;
}
    d3f4:	df 91       	pop	r29
    d3f6:	cf 91       	pop	r28
    d3f8:	1f 91       	pop	r17
    d3fa:	0f 91       	pop	r16
    d3fc:	ff 90       	pop	r15
    d3fe:	ef 90       	pop	r14
    d400:	08 95       	ret

0000d402 <ValidateGeniusCode>:
          }
	 }sTemp[iAdd]=0;
	 sprintf_P(strSource,PSTR("%s"),sTemp);
}

char ValidateGeniusCode(char *sDate, char *sGenCode){//==GC_VALID
    d402:	ef 92       	push	r14
    d404:	ff 92       	push	r15
    d406:	0f 93       	push	r16
    d408:	1f 93       	push	r17
    d40a:	df 93       	push	r29
    d40c:	cf 93       	push	r28
    d40e:	cd b7       	in	r28, 0x3d	; 61
    d410:	de b7       	in	r29, 0x3e	; 62
    d412:	2a 97       	sbiw	r28, 0x0a	; 10
    d414:	0f b6       	in	r0, 0x3f	; 63
    d416:	f8 94       	cli
    d418:	de bf       	out	0x3e, r29	; 62
    d41a:	0f be       	out	0x3f, r0	; 63
    d41c:	cd bf       	out	0x3d, r28	; 61
    d41e:	7b 01       	movw	r14, r22

         #ifdef DEBUG_GENIUS_CODE
		 sprintf_P(strSend,PSTR("[%s]"),sGenCode); 
         _uart_print(1,1,strSend);
		 #endif
	 if (strlen(sGenCode)==8){//Length musti  8
    d420:	fb 01       	movw	r30, r22
    d422:	01 90       	ld	r0, Z+
    d424:	00 20       	and	r0, r0
    d426:	e9 f7       	brne	.-6      	; 0xd422 <ValidateGeniusCode+0x20>
    d428:	39 97       	sbiw	r30, 0x09	; 9
    d42a:	e6 17       	cp	r30, r22
    d42c:	f7 07       	cpc	r31, r23
    d42e:	11 f0       	breq	.+4      	; 0xd434 <ValidateGeniusCode+0x32>
    d430:	80 e0       	ldi	r24, 0x00	; 0
    d432:	11 c0       	rjmp	.+34     	; 0xd456 <ValidateGeniusCode+0x54>
	     //sDate: 05012001		 
		 GenerateGeniusCode(sDate,sGenCode[0],sAutoGen);
    d434:	fb 01       	movw	r30, r22
    d436:	60 81       	ld	r22, Z
    d438:	8e 01       	movw	r16, r28
    d43a:	0f 5f       	subi	r16, 0xFF	; 255
    d43c:	1f 4f       	sbci	r17, 0xFF	; 255
    d43e:	a8 01       	movw	r20, r16
    d440:	0e 94 77 32 	call	0x64ee	; 0x64ee <GenerateGeniusCode>
         #ifdef DEBUG_GENIUS_CODE
		 sprintf_P(strSend,PSTR("%s|%s"),sAutoGen,sGenCode); 
         _uart_print(1,1,strSend);
		 #endif

         if (strcmp(sAutoGen,sGenCode)==0)
    d444:	c8 01       	movw	r24, r16
    d446:	b7 01       	movw	r22, r14
    d448:	0e 94 6a b5 	call	0x16ad4	; 0x16ad4 <strcmp>
    d44c:	00 97       	sbiw	r24, 0x00	; 0
    d44e:	11 f0       	breq	.+4      	; 0xd454 <ValidateGeniusCode+0x52>
    d450:	82 e0       	ldi	r24, 0x02	; 2
    d452:	01 c0       	rjmp	.+2      	; 0xd456 <ValidateGeniusCode+0x54>
    d454:	81 e0       	ldi	r24, 0x01	; 1
         else Result=GC_INVALID;
	 }


   return Result;
}
    d456:	2a 96       	adiw	r28, 0x0a	; 10
    d458:	0f b6       	in	r0, 0x3f	; 63
    d45a:	f8 94       	cli
    d45c:	de bf       	out	0x3e, r29	; 62
    d45e:	0f be       	out	0x3f, r0	; 63
    d460:	cd bf       	out	0x3d, r28	; 61
    d462:	cf 91       	pop	r28
    d464:	df 91       	pop	r29
    d466:	1f 91       	pop	r17
    d468:	0f 91       	pop	r16
    d46a:	ff 90       	pop	r15
    d46c:	ef 90       	pop	r14
    d46e:	08 95       	ret

0000d470 <FMenuSettingServerIP>:
		       break;     
		  }//EndSwitch	 
    return Result;
}

char FMenuSettingServerIP(){
    d470:	0f 93       	push	r16
    d472:	1f 93       	push	r17
    d474:	df 93       	push	r29
    d476:	cf 93       	push	r28
    d478:	cd b7       	in	r28, 0x3d	; 61
    d47a:	de b7       	in	r29, 0x3e	; 62
    d47c:	64 97       	sbiw	r28, 0x14	; 20
    d47e:	0f b6       	in	r0, 0x3f	; 63
    d480:	f8 94       	cli
    d482:	de bf       	out	0x3e, r29	; 62
    d484:	0f be       	out	0x3f, r0	; 63
    d486:	cd bf       	out	0x3d, r28	; 61
     //Server IP
     //Old: 192.168.123.000
	 //New:   _.   .   .
	 //--------------------
	 //*)cancel    #)next
	 Result=MENU_NONE;
    d488:	10 92 01 03 	sts	0x0301, r1
     switch(stClientIP){
    d48c:	80 91 58 01 	lds	r24, 0x0158
    d490:	82 30       	cpi	r24, 0x02	; 2
    d492:	09 f4       	brne	.+2      	; 0xd496 <FMenuSettingServerIP+0x26>
    d494:	7b c0       	rjmp	.+246    	; 0xd58c <FMenuSettingServerIP+0x11c>
    d496:	83 30       	cpi	r24, 0x03	; 3
    d498:	20 f4       	brcc	.+8      	; 0xd4a2 <FMenuSettingServerIP+0x32>
    d49a:	81 30       	cpi	r24, 0x01	; 1
    d49c:	09 f0       	breq	.+2      	; 0xd4a0 <FMenuSettingServerIP+0x30>
    d49e:	65 c2       	rjmp	.+1226   	; 0xd96a <FMenuSettingServerIP+0x4fa>
    d4a0:	07 c0       	rjmp	.+14     	; 0xd4b0 <FMenuSettingServerIP+0x40>
    d4a2:	83 30       	cpi	r24, 0x03	; 3
    d4a4:	09 f4       	brne	.+2      	; 0xd4a8 <FMenuSettingServerIP+0x38>
    d4a6:	5c c2       	rjmp	.+1208   	; 0xd960 <FMenuSettingServerIP+0x4f0>
    d4a8:	84 30       	cpi	r24, 0x04	; 4
    d4aa:	09 f0       	breq	.+2      	; 0xd4ae <FMenuSettingServerIP+0x3e>
    d4ac:	5e c2       	rjmp	.+1212   	; 0xd96a <FMenuSettingServerIP+0x4fa>
    d4ae:	4a c2       	rjmp	.+1172   	; 0xd944 <FMenuSettingServerIP+0x4d4>
		  case cipInit:
			   lcd_clear();
    d4b0:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
	           lcd_printf(1,1,PSTR("Server IP"));
    d4b4:	81 e0       	ldi	r24, 0x01	; 1
    d4b6:	61 e0       	ldi	r22, 0x01	; 1
    d4b8:	4a e0       	ldi	r20, 0x0A	; 10
    d4ba:	53 e1       	ldi	r21, 0x13	; 19
    d4bc:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    d4c0:	88 ef       	ldi	r24, 0xF8	; 248
    d4c2:	92 e0       	ldi	r25, 0x02	; 2
    d4c4:	6c e2       	ldi	r22, 0x2C	; 44
    d4c6:	70 e0       	ldi	r23, 0x00	; 0
    d4c8:	44 e0       	ldi	r20, 0x04	; 4
    d4ca:	50 e0       	ldi	r21, 0x00	; 0
    d4cc:	26 ef       	ldi	r18, 0xF6	; 246
    d4ce:	32 e1       	ldi	r19, 0x12	; 18
    d4d0:	0e 94 7a b5 	call	0x16af4	; 0x16af4 <__eerd_block>
			   eeprom_read_block((void*)&IP_blok,(const void*)&DefServerIP,4);
	           sprintf_P(lcdteks,PSTR("Old: %d.%d.%d.%d"),IP_blok[0],IP_blok[1],IP_blok[2],IP_blok[3]);
    d4d4:	8d b7       	in	r24, 0x3d	; 61
    d4d6:	9e b7       	in	r25, 0x3e	; 62
    d4d8:	0c 97       	sbiw	r24, 0x0c	; 12
    d4da:	0f b6       	in	r0, 0x3f	; 63
    d4dc:	f8 94       	cli
    d4de:	9e bf       	out	0x3e, r25	; 62
    d4e0:	0f be       	out	0x3f, r0	; 63
    d4e2:	8d bf       	out	0x3d, r24	; 61
    d4e4:	ed b7       	in	r30, 0x3d	; 61
    d4e6:	fe b7       	in	r31, 0x3e	; 62
    d4e8:	31 96       	adiw	r30, 0x01	; 1
    d4ea:	8e 01       	movw	r16, r28
    d4ec:	0f 5f       	subi	r16, 0xFF	; 255
    d4ee:	1f 4f       	sbci	r17, 0xFF	; 255
    d4f0:	ad b7       	in	r26, 0x3d	; 61
    d4f2:	be b7       	in	r27, 0x3e	; 62
    d4f4:	12 96       	adiw	r26, 0x02	; 2
    d4f6:	1c 93       	st	X, r17
    d4f8:	0e 93       	st	-X, r16
    d4fa:	11 97       	sbiw	r26, 0x01	; 1
    d4fc:	89 ef       	ldi	r24, 0xF9	; 249
    d4fe:	92 e1       	ldi	r25, 0x12	; 18
    d500:	93 83       	std	Z+3, r25	; 0x03
    d502:	82 83       	std	Z+2, r24	; 0x02
    d504:	80 91 f8 02 	lds	r24, 0x02F8
    d508:	84 83       	std	Z+4, r24	; 0x04
    d50a:	15 82       	std	Z+5, r1	; 0x05
    d50c:	80 91 f9 02 	lds	r24, 0x02F9
    d510:	86 83       	std	Z+6, r24	; 0x06
    d512:	17 82       	std	Z+7, r1	; 0x07
    d514:	80 91 fa 02 	lds	r24, 0x02FA
    d518:	80 87       	std	Z+8, r24	; 0x08
    d51a:	11 86       	std	Z+9, r1	; 0x09
    d51c:	80 91 fb 02 	lds	r24, 0x02FB
    d520:	82 87       	std	Z+10, r24	; 0x0a
    d522:	13 86       	std	Z+11, r1	; 0x0b
    d524:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
	           lcd_print(2,1,lcdteks);
    d528:	ed b7       	in	r30, 0x3d	; 61
    d52a:	fe b7       	in	r31, 0x3e	; 62
    d52c:	3c 96       	adiw	r30, 0x0c	; 12
    d52e:	0f b6       	in	r0, 0x3f	; 63
    d530:	f8 94       	cli
    d532:	fe bf       	out	0x3e, r31	; 62
    d534:	0f be       	out	0x3f, r0	; 63
    d536:	ed bf       	out	0x3d, r30	; 61
    d538:	82 e0       	ldi	r24, 0x02	; 2
    d53a:	61 e0       	ldi	r22, 0x01	; 1
    d53c:	a8 01       	movw	r20, r16
    d53e:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
			   lcd_printf(3,1,PSTR("New:   _.   .   .   "));
    d542:	83 e0       	ldi	r24, 0x03	; 3
    d544:	61 e0       	ldi	r22, 0x01	; 1
    d546:	44 ee       	ldi	r20, 0xE4	; 228
    d548:	52 e1       	ldi	r21, 0x12	; 18
    d54a:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
			   lcd_printf(4,1,PSTR("[*]cancel  [#]next  "));
    d54e:	84 e0       	ldi	r24, 0x04	; 4
    d550:	61 e0       	ldi	r22, 0x01	; 1
    d552:	4f ec       	ldi	r20, 0xCF	; 207
    d554:	52 e1       	ldi	r21, 0x12	; 18
    d556:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
               iLoop=0;
    d55a:	10 92 f7 02 	sts	0x02F7, r1
    d55e:	10 92 f6 02 	sts	0x02F6, r1
			   y=3,x=8;
    d562:	83 e0       	ldi	r24, 0x03	; 3
    d564:	80 93 fe 02 	sts	0x02FE, r24
    d568:	88 e0       	ldi	r24, 0x08	; 8
    d56a:	80 93 ff 02 	sts	0x02FF, r24
			   iInput=0; iBlok=0;
    d56e:	10 92 fd 02 	sts	0x02FD, r1
    d572:	10 92 f5 02 	sts	0x02F5, r1
    d576:	10 92 f4 02 	sts	0x02F4, r1
			   IPchar[0]='0';IPchar[1]='0';IPchar[2]='0';
    d57a:	80 e3       	ldi	r24, 0x30	; 48
    d57c:	80 93 03 03 	sts	0x0303, r24
    d580:	80 93 04 03 	sts	0x0304, r24
    d584:	80 93 05 03 	sts	0x0305, r24
			   stClientIP=cipInputIP; 
    d588:	82 e0       	ldi	r24, 0x02	; 2
    d58a:	e7 c1       	rjmp	.+974    	; 0xd95a <FMenuSettingServerIP+0x4ea>
		       break;
          case cipInputIP:
			   //Blinking 60% _ 
			   iLoop++;
    d58c:	80 91 f6 02 	lds	r24, 0x02F6
    d590:	90 91 f7 02 	lds	r25, 0x02F7
    d594:	01 96       	adiw	r24, 0x01	; 1
    d596:	90 93 f7 02 	sts	0x02F7, r25
    d59a:	80 93 f6 02 	sts	0x02F6, r24
			   if ((iLoop%2000)==0){
    d59e:	60 ed       	ldi	r22, 0xD0	; 208
    d5a0:	77 e0       	ldi	r23, 0x07	; 7
    d5a2:	0e 94 93 b8 	call	0x17126	; 0x17126 <__udivmodhi4>
    d5a6:	89 2b       	or	r24, r25
    d5a8:	81 f4       	brne	.+32     	; 0xd5ca <FMenuSettingServerIP+0x15a>
			      lcd_put(y,(x+(iBlok*4)),'_'); 
    d5aa:	80 91 f4 02 	lds	r24, 0x02F4
    d5ae:	90 91 f5 02 	lds	r25, 0x02F5
    d5b2:	88 0f       	add	r24, r24
    d5b4:	99 1f       	adc	r25, r25
    d5b6:	88 0f       	add	r24, r24
    d5b8:	99 1f       	adc	r25, r25
    d5ba:	60 91 ff 02 	lds	r22, 0x02FF
    d5be:	68 0f       	add	r22, r24
    d5c0:	80 91 fe 02 	lds	r24, 0x02FE
    d5c4:	4f e5       	ldi	r20, 0x5F	; 95
    d5c6:	0e 94 da ae 	call	0x15db4	; 0x15db4 <lcd_put>
			   }
			   if ((iLoop%2000)==1000){
    d5ca:	80 91 f6 02 	lds	r24, 0x02F6
    d5ce:	90 91 f7 02 	lds	r25, 0x02F7
    d5d2:	60 ed       	ldi	r22, 0xD0	; 208
    d5d4:	77 e0       	ldi	r23, 0x07	; 7
    d5d6:	0e 94 93 b8 	call	0x17126	; 0x17126 <__udivmodhi4>
    d5da:	88 5e       	subi	r24, 0xE8	; 232
    d5dc:	93 40       	sbci	r25, 0x03	; 3
    d5de:	81 f4       	brne	.+32     	; 0xd600 <FMenuSettingServerIP+0x190>
			      lcd_put(y,(x+(iBlok*4)),' '); 
    d5e0:	80 91 f4 02 	lds	r24, 0x02F4
    d5e4:	90 91 f5 02 	lds	r25, 0x02F5
    d5e8:	88 0f       	add	r24, r24
    d5ea:	99 1f       	adc	r25, r25
    d5ec:	88 0f       	add	r24, r24
    d5ee:	99 1f       	adc	r25, r25
    d5f0:	60 91 ff 02 	lds	r22, 0x02FF
    d5f4:	68 0f       	add	r22, r24
    d5f6:	80 91 fe 02 	lds	r24, 0x02FE
    d5fa:	40 e2       	ldi	r20, 0x20	; 32
    d5fc:	0e 94 da ae 	call	0x15db4	; 0x15db4 <lcd_put>
			   }
			   //GetKeyPressed
			   keyPressed=_key_scan(1);
    d600:	81 e0       	ldi	r24, 0x01	; 1
    d602:	0e 94 06 b0 	call	0x1600c	; 0x1600c <_key_scan>
    d606:	80 93 fc 02 	sts	0x02FC, r24
			   keyChar=_key_btn(keyPressed);
    d60a:	0e 94 67 af 	call	0x15ece	; 0x15ece <_key_btn>
    d60e:	28 2f       	mov	r18, r24
    d610:	80 93 00 03 	sts	0x0300, r24
               if ((keyChar>='0')&&(keyChar<='9')){
    d614:	80 53       	subi	r24, 0x30	; 48
    d616:	8a 30       	cpi	r24, 0x0A	; 10
    d618:	08 f0       	brcs	.+2      	; 0xd61c <FMenuSettingServerIP+0x1ac>
    d61a:	d6 c0       	rjmp	.+428    	; 0xd7c8 <FMenuSettingServerIP+0x358>
    d61c:	80 e5       	ldi	r24, 0x50	; 80
    d61e:	93 ec       	ldi	r25, 0xC3	; 195
    d620:	01 97       	sbiw	r24, 0x01	; 1
    d622:	f1 f7       	brne	.-4      	; 0xd620 <FMenuSettingServerIP+0x1b0>
			       _delay_ms(200);
			       IPchar[iInput]=keyChar;
    d624:	80 91 fd 02 	lds	r24, 0x02FD
    d628:	e8 2f       	mov	r30, r24
    d62a:	f0 e0       	ldi	r31, 0x00	; 0
    d62c:	ed 5f       	subi	r30, 0xFD	; 253
    d62e:	fc 4f       	sbci	r31, 0xFC	; 252
    d630:	20 83       	st	Z, r18
				   iInput++;                    
    d632:	8f 5f       	subi	r24, 0xFF	; 255
    d634:	80 93 fd 02 	sts	0x02FD, r24
				   for (i=1;i<(iInput+1);i++){
    d638:	81 e0       	ldi	r24, 0x01	; 1
    d63a:	1c c0       	rjmp	.+56     	; 0xd674 <FMenuSettingServerIP+0x204>
				       lcd_xy(y,((x+(iBlok*4))-(3-i)));_lcd(IPchar[i-1]);
    d63c:	80 91 ff 02 	lds	r24, 0x02FF
    d640:	68 0f       	add	r22, r24
    d642:	63 50       	subi	r22, 0x03	; 3
    d644:	80 91 f4 02 	lds	r24, 0x02F4
    d648:	90 91 f5 02 	lds	r25, 0x02F5
    d64c:	88 0f       	add	r24, r24
    d64e:	99 1f       	adc	r25, r25
    d650:	88 0f       	add	r24, r24
    d652:	99 1f       	adc	r25, r25
    d654:	68 0f       	add	r22, r24
    d656:	80 91 fe 02 	lds	r24, 0x02FE
    d65a:	0e 94 4c ae 	call	0x15c98	; 0x15c98 <lcd_xy>
    d65e:	e0 91 02 03 	lds	r30, 0x0302
    d662:	f0 e0       	ldi	r31, 0x00	; 0
    d664:	ee 5f       	subi	r30, 0xFE	; 254
    d666:	fc 4f       	sbci	r31, 0xFC	; 252
    d668:	80 81       	ld	r24, Z
    d66a:	0e 94 26 ae 	call	0x15c4c	; 0x15c4c <_lcd>
			   keyChar=_key_btn(keyPressed);
               if ((keyChar>='0')&&(keyChar<='9')){
			       _delay_ms(200);
			       IPchar[iInput]=keyChar;
				   iInput++;                    
				   for (i=1;i<(iInput+1);i++){
    d66e:	80 91 02 03 	lds	r24, 0x0302
    d672:	8f 5f       	subi	r24, 0xFF	; 255
    d674:	80 93 02 03 	sts	0x0302, r24
    d678:	70 91 fd 02 	lds	r23, 0x02FD
    d67c:	60 91 02 03 	lds	r22, 0x0302
    d680:	27 2f       	mov	r18, r23
    d682:	30 e0       	ldi	r19, 0x00	; 0
    d684:	86 2f       	mov	r24, r22
    d686:	90 e0       	ldi	r25, 0x00	; 0
    d688:	28 17       	cp	r18, r24
    d68a:	39 07       	cpc	r19, r25
    d68c:	bc f6       	brge	.-82     	; 0xd63c <FMenuSettingServerIP+0x1cc>
				       lcd_xy(y,((x+(iBlok*4))-(3-i)));_lcd(IPchar[i-1]);
				   }
                   //NextInput
				   if (iInput>=3){
    d68e:	73 30       	cpi	r23, 0x03	; 3
    d690:	08 f4       	brcc	.+2      	; 0xd694 <FMenuSettingServerIP+0x224>
    d692:	91 c0       	rjmp	.+290    	; 0xd7b6 <FMenuSettingServerIP+0x346>
				       IP_blok[iBlok]=((IPchar[0]-'0')*100)+((IPchar[1]-'0')*10)+((IPchar[2]-'0'));
    d694:	40 91 f4 02 	lds	r20, 0x02F4
    d698:	50 91 f5 02 	lds	r21, 0x02F5
    d69c:	fa 01       	movw	r30, r20
    d69e:	e8 50       	subi	r30, 0x08	; 8
    d6a0:	fd 4f       	sbci	r31, 0xFD	; 253
    d6a2:	20 91 05 03 	lds	r18, 0x0305
    d6a6:	20 5d       	subi	r18, 0xD0	; 208
    d6a8:	80 91 03 03 	lds	r24, 0x0303
    d6ac:	34 e6       	ldi	r19, 0x64	; 100
    d6ae:	83 9f       	mul	r24, r19
    d6b0:	c0 01       	movw	r24, r0
    d6b2:	11 24       	eor	r1, r1
    d6b4:	28 0f       	add	r18, r24
    d6b6:	80 91 04 03 	lds	r24, 0x0304
    d6ba:	3a e0       	ldi	r19, 0x0A	; 10
    d6bc:	83 9f       	mul	r24, r19
    d6be:	c0 01       	movw	r24, r0
    d6c0:	11 24       	eor	r1, r1
    d6c2:	28 0f       	add	r18, r24
    d6c4:	20 83       	st	Z, r18
					   IPchar[0]='0';IPchar[1]='0';IPchar[2]='0';
    d6c6:	80 e3       	ldi	r24, 0x30	; 48
    d6c8:	80 93 03 03 	sts	0x0303, r24
    d6cc:	80 93 04 03 	sts	0x0304, r24
    d6d0:	80 93 05 03 	sts	0x0305, r24
					   //Reposition Value
					   lcd_printf(y,((x+(iBlok*4))-iInput),PSTR("   "));
    d6d4:	44 0f       	add	r20, r20
    d6d6:	55 1f       	adc	r21, r21
    d6d8:	44 0f       	add	r20, r20
    d6da:	55 1f       	adc	r21, r21
    d6dc:	60 91 ff 02 	lds	r22, 0x02FF
    d6e0:	64 0f       	add	r22, r20
    d6e2:	67 1b       	sub	r22, r23
    d6e4:	80 91 fe 02 	lds	r24, 0x02FE
    d6e8:	4b ec       	ldi	r20, 0xCB	; 203
    d6ea:	52 e1       	ldi	r21, 0x12	; 18
    d6ec:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
					   sprintf_P(lcdteks,PSTR("%d"),IP_blok[iBlok]);
    d6f0:	00 d0       	rcall	.+0      	; 0xd6f2 <FMenuSettingServerIP+0x282>
    d6f2:	00 d0       	rcall	.+0      	; 0xd6f4 <FMenuSettingServerIP+0x284>
    d6f4:	00 d0       	rcall	.+0      	; 0xd6f6 <FMenuSettingServerIP+0x286>
    d6f6:	ad b7       	in	r26, 0x3d	; 61
    d6f8:	be b7       	in	r27, 0x3e	; 62
    d6fa:	11 96       	adiw	r26, 0x01	; 1
    d6fc:	8e 01       	movw	r16, r28
    d6fe:	0f 5f       	subi	r16, 0xFF	; 255
    d700:	1f 4f       	sbci	r17, 0xFF	; 255
    d702:	ed b7       	in	r30, 0x3d	; 61
    d704:	fe b7       	in	r31, 0x3e	; 62
    d706:	12 83       	std	Z+2, r17	; 0x02
    d708:	01 83       	std	Z+1, r16	; 0x01
    d70a:	88 ec       	ldi	r24, 0xC8	; 200
    d70c:	92 e1       	ldi	r25, 0x12	; 18
    d70e:	13 96       	adiw	r26, 0x03	; 3
    d710:	9c 93       	st	X, r25
    d712:	8e 93       	st	-X, r24
    d714:	12 97       	sbiw	r26, 0x02	; 2
    d716:	e0 91 f4 02 	lds	r30, 0x02F4
    d71a:	f0 91 f5 02 	lds	r31, 0x02F5
    d71e:	e8 50       	subi	r30, 0x08	; 8
    d720:	fd 4f       	sbci	r31, 0xFD	; 253
    d722:	80 81       	ld	r24, Z
    d724:	14 96       	adiw	r26, 0x04	; 4
    d726:	8c 93       	st	X, r24
    d728:	14 97       	sbiw	r26, 0x04	; 4
    d72a:	15 96       	adiw	r26, 0x05	; 5
    d72c:	1c 92       	st	X, r1
    d72e:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
                       lcd_print(y,1+((x+(iBlok*4))-strlen(lcdteks)),lcdteks);
    d732:	f8 01       	movw	r30, r16
    d734:	01 90       	ld	r0, Z+
    d736:	00 20       	and	r0, r0
    d738:	e9 f7       	brne	.-6      	; 0xd734 <FMenuSettingServerIP+0x2c4>
    d73a:	31 97       	sbiw	r30, 0x01	; 1
    d73c:	e0 1b       	sub	r30, r16
    d73e:	f1 0b       	sbc	r31, r17
    d740:	8d b7       	in	r24, 0x3d	; 61
    d742:	9e b7       	in	r25, 0x3e	; 62
    d744:	06 96       	adiw	r24, 0x06	; 6
    d746:	0f b6       	in	r0, 0x3f	; 63
    d748:	f8 94       	cli
    d74a:	9e bf       	out	0x3e, r25	; 62
    d74c:	0f be       	out	0x3f, r0	; 63
    d74e:	8d bf       	out	0x3d, r24	; 61
    d750:	60 91 ff 02 	lds	r22, 0x02FF
    d754:	6f 5f       	subi	r22, 0xFF	; 255
    d756:	80 91 f4 02 	lds	r24, 0x02F4
    d75a:	90 91 f5 02 	lds	r25, 0x02F5
    d75e:	88 0f       	add	r24, r24
    d760:	99 1f       	adc	r25, r25
    d762:	88 0f       	add	r24, r24
    d764:	99 1f       	adc	r25, r25
    d766:	68 0f       	add	r22, r24
    d768:	6e 1b       	sub	r22, r30
    d76a:	80 91 fe 02 	lds	r24, 0x02FE
    d76e:	a8 01       	movw	r20, r16
    d770:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
					   if (iBlok>0)lcd_printf(y,1+((x+((iBlok-1)*4))),PSTR("."));
    d774:	80 91 f4 02 	lds	r24, 0x02F4
    d778:	90 91 f5 02 	lds	r25, 0x02F5
    d77c:	00 97       	sbiw	r24, 0x00	; 0
    d77e:	81 f0       	breq	.+32     	; 0xd7a0 <FMenuSettingServerIP+0x330>
    d780:	60 91 ff 02 	lds	r22, 0x02FF
    d784:	6f 5f       	subi	r22, 0xFF	; 255
    d786:	81 50       	subi	r24, 0x01	; 1
    d788:	90 4c       	sbci	r25, 0xC0	; 192
    d78a:	88 0f       	add	r24, r24
    d78c:	99 1f       	adc	r25, r25
    d78e:	88 0f       	add	r24, r24
    d790:	99 1f       	adc	r25, r25
    d792:	68 0f       	add	r22, r24
    d794:	80 91 fe 02 	lds	r24, 0x02FE
    d798:	46 ec       	ldi	r20, 0xC6	; 198
    d79a:	52 e1       	ldi	r21, 0x12	; 18
    d79c:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
					   iInput=0;
    d7a0:	10 92 fd 02 	sts	0x02FD, r1
					   iBlok++;
    d7a4:	80 91 f4 02 	lds	r24, 0x02F4
    d7a8:	90 91 f5 02 	lds	r25, 0x02F5
    d7ac:	01 96       	adiw	r24, 0x01	; 1
    d7ae:	90 93 f5 02 	sts	0x02F5, r25
    d7b2:	80 93 f4 02 	sts	0x02F4, r24

				   }
				   if (iBlok>=4)stClientIP=cipStoreIPblok;
    d7b6:	80 91 f4 02 	lds	r24, 0x02F4
    d7ba:	90 91 f5 02 	lds	r25, 0x02F5
    d7be:	04 97       	sbiw	r24, 0x04	; 4
    d7c0:	18 f0       	brcs	.+6      	; 0xd7c8 <FMenuSettingServerIP+0x358>
    d7c2:	84 e0       	ldi	r24, 0x04	; 4
    d7c4:	80 93 58 01 	sts	0x0158, r24
			   }

			   if (keyPressed==_KEY_CANCEL){
    d7c8:	80 91 fc 02 	lds	r24, 0x02FC
    d7cc:	87 3e       	cpi	r24, 0xE7	; 231
    d7ce:	09 f4       	brne	.+2      	; 0xd7d2 <FMenuSettingServerIP+0x362>
    d7d0:	c3 c0       	rjmp	.+390    	; 0xd958 <FMenuSettingServerIP+0x4e8>
			       stClientIP=cipExit; 
			   }
			   else
			   if (keyPressed==_KEY_ENTER){
    d7d2:	87 3b       	cpi	r24, 0xB7	; 183
    d7d4:	09 f0       	breq	.+2      	; 0xd7d8 <FMenuSettingServerIP+0x368>
    d7d6:	c9 c0       	rjmp	.+402    	; 0xd96a <FMenuSettingServerIP+0x4fa>
			       //NextInput
			       if (iBlok<4){
    d7d8:	40 91 f4 02 	lds	r20, 0x02F4
    d7dc:	50 91 f5 02 	lds	r21, 0x02F5
    d7e0:	44 30       	cpi	r20, 0x04	; 4
    d7e2:	51 05       	cpc	r21, r1
    d7e4:	08 f0       	brcs	.+2      	; 0xd7e8 <FMenuSettingServerIP+0x378>
    d7e6:	a6 c0       	rjmp	.+332    	; 0xd934 <FMenuSettingServerIP+0x4c4>
				       if (iInput==1)IP_blok[iBlok]=((IPchar[0]-'0'));
    d7e8:	80 91 fd 02 	lds	r24, 0x02FD
    d7ec:	81 30       	cpi	r24, 0x01	; 1
    d7ee:	41 f4       	brne	.+16     	; 0xd800 <FMenuSettingServerIP+0x390>
    d7f0:	fa 01       	movw	r30, r20
    d7f2:	e8 50       	subi	r30, 0x08	; 8
    d7f4:	fd 4f       	sbci	r31, 0xFD	; 253
    d7f6:	80 91 03 03 	lds	r24, 0x0303
    d7fa:	80 53       	subi	r24, 0x30	; 48
    d7fc:	80 83       	st	Z, r24
    d7fe:	22 c0       	rjmp	.+68     	; 0xd844 <FMenuSettingServerIP+0x3d4>
					   if (iInput==2)IP_blok[iBlok]=((IPchar[0]-'0')*10)+(IPchar[1]-'0');
    d800:	82 30       	cpi	r24, 0x02	; 2
    d802:	49 f4       	brne	.+18     	; 0xd816 <FMenuSettingServerIP+0x3a6>
    d804:	fa 01       	movw	r30, r20
    d806:	e8 50       	subi	r30, 0x08	; 8
    d808:	fd 4f       	sbci	r31, 0xFD	; 253
    d80a:	20 91 04 03 	lds	r18, 0x0304
    d80e:	20 51       	subi	r18, 0x10	; 16
    d810:	80 91 03 03 	lds	r24, 0x0303
    d814:	11 c0       	rjmp	.+34     	; 0xd838 <FMenuSettingServerIP+0x3c8>
					   if (iInput==3)IP_blok[iBlok]=((IPchar[0]-'0')*100)+((IPchar[1]-'0')*10)+((IPchar[2]-'0'));
    d816:	83 30       	cpi	r24, 0x03	; 3
    d818:	a9 f4       	brne	.+42     	; 0xd844 <FMenuSettingServerIP+0x3d4>
    d81a:	fa 01       	movw	r30, r20
    d81c:	e8 50       	subi	r30, 0x08	; 8
    d81e:	fd 4f       	sbci	r31, 0xFD	; 253
    d820:	20 91 05 03 	lds	r18, 0x0305
    d824:	20 5d       	subi	r18, 0xD0	; 208
    d826:	80 91 03 03 	lds	r24, 0x0303
    d82a:	34 e6       	ldi	r19, 0x64	; 100
    d82c:	83 9f       	mul	r24, r19
    d82e:	c0 01       	movw	r24, r0
    d830:	11 24       	eor	r1, r1
    d832:	28 0f       	add	r18, r24
    d834:	80 91 04 03 	lds	r24, 0x0304
    d838:	3a e0       	ldi	r19, 0x0A	; 10
    d83a:	83 9f       	mul	r24, r19
    d83c:	c0 01       	movw	r24, r0
    d83e:	11 24       	eor	r1, r1
    d840:	28 0f       	add	r18, r24
    d842:	20 83       	st	Z, r18
				       
					   IPchar[0]='0';IPchar[1]='0';IPchar[2]='0';
    d844:	80 e3       	ldi	r24, 0x30	; 48
    d846:	80 93 03 03 	sts	0x0303, r24
    d84a:	80 93 04 03 	sts	0x0304, r24
    d84e:	80 93 05 03 	sts	0x0305, r24
					   //Reposition Value
					   lcd_printf(y,((x+(iBlok*4))-3),PSTR("   "));
    d852:	60 91 ff 02 	lds	r22, 0x02FF
    d856:	63 50       	subi	r22, 0x03	; 3
    d858:	44 0f       	add	r20, r20
    d85a:	55 1f       	adc	r21, r21
    d85c:	44 0f       	add	r20, r20
    d85e:	55 1f       	adc	r21, r21
    d860:	64 0f       	add	r22, r20
    d862:	80 91 fe 02 	lds	r24, 0x02FE
    d866:	42 ec       	ldi	r20, 0xC2	; 194
    d868:	52 e1       	ldi	r21, 0x12	; 18
    d86a:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
					   sprintf_P(lcdteks,PSTR("%d"),IP_blok[iBlok]);
    d86e:	00 d0       	rcall	.+0      	; 0xd870 <FMenuSettingServerIP+0x400>
    d870:	00 d0       	rcall	.+0      	; 0xd872 <FMenuSettingServerIP+0x402>
    d872:	00 d0       	rcall	.+0      	; 0xd874 <FMenuSettingServerIP+0x404>
    d874:	ad b7       	in	r26, 0x3d	; 61
    d876:	be b7       	in	r27, 0x3e	; 62
    d878:	11 96       	adiw	r26, 0x01	; 1
    d87a:	8e 01       	movw	r16, r28
    d87c:	0f 5f       	subi	r16, 0xFF	; 255
    d87e:	1f 4f       	sbci	r17, 0xFF	; 255
    d880:	ed b7       	in	r30, 0x3d	; 61
    d882:	fe b7       	in	r31, 0x3e	; 62
    d884:	12 83       	std	Z+2, r17	; 0x02
    d886:	01 83       	std	Z+1, r16	; 0x01
    d888:	8f eb       	ldi	r24, 0xBF	; 191
    d88a:	92 e1       	ldi	r25, 0x12	; 18
    d88c:	13 96       	adiw	r26, 0x03	; 3
    d88e:	9c 93       	st	X, r25
    d890:	8e 93       	st	-X, r24
    d892:	12 97       	sbiw	r26, 0x02	; 2
    d894:	e0 91 f4 02 	lds	r30, 0x02F4
    d898:	f0 91 f5 02 	lds	r31, 0x02F5
    d89c:	e8 50       	subi	r30, 0x08	; 8
    d89e:	fd 4f       	sbci	r31, 0xFD	; 253
    d8a0:	80 81       	ld	r24, Z
    d8a2:	14 96       	adiw	r26, 0x04	; 4
    d8a4:	8c 93       	st	X, r24
    d8a6:	14 97       	sbiw	r26, 0x04	; 4
    d8a8:	15 96       	adiw	r26, 0x05	; 5
    d8aa:	1c 92       	st	X, r1
    d8ac:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
                       lcd_print(y,1+((x+(iBlok*4))-strlen(lcdteks)),lcdteks);
    d8b0:	f8 01       	movw	r30, r16
    d8b2:	01 90       	ld	r0, Z+
    d8b4:	00 20       	and	r0, r0
    d8b6:	e9 f7       	brne	.-6      	; 0xd8b2 <FMenuSettingServerIP+0x442>
    d8b8:	31 97       	sbiw	r30, 0x01	; 1
    d8ba:	e0 1b       	sub	r30, r16
    d8bc:	f1 0b       	sbc	r31, r17
    d8be:	8d b7       	in	r24, 0x3d	; 61
    d8c0:	9e b7       	in	r25, 0x3e	; 62
    d8c2:	06 96       	adiw	r24, 0x06	; 6
    d8c4:	0f b6       	in	r0, 0x3f	; 63
    d8c6:	f8 94       	cli
    d8c8:	9e bf       	out	0x3e, r25	; 62
    d8ca:	0f be       	out	0x3f, r0	; 63
    d8cc:	8d bf       	out	0x3d, r24	; 61
    d8ce:	60 91 ff 02 	lds	r22, 0x02FF
    d8d2:	6f 5f       	subi	r22, 0xFF	; 255
    d8d4:	80 91 f4 02 	lds	r24, 0x02F4
    d8d8:	90 91 f5 02 	lds	r25, 0x02F5
    d8dc:	88 0f       	add	r24, r24
    d8de:	99 1f       	adc	r25, r25
    d8e0:	88 0f       	add	r24, r24
    d8e2:	99 1f       	adc	r25, r25
    d8e4:	68 0f       	add	r22, r24
    d8e6:	6e 1b       	sub	r22, r30
    d8e8:	80 91 fe 02 	lds	r24, 0x02FE
    d8ec:	a8 01       	movw	r20, r16
    d8ee:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>

					   if (iBlok>0)lcd_printf(y,1+((x+((iBlok-1)*4))),PSTR("."));
    d8f2:	80 91 f4 02 	lds	r24, 0x02F4
    d8f6:	90 91 f5 02 	lds	r25, 0x02F5
    d8fa:	00 97       	sbiw	r24, 0x00	; 0
    d8fc:	81 f0       	breq	.+32     	; 0xd91e <FMenuSettingServerIP+0x4ae>
    d8fe:	60 91 ff 02 	lds	r22, 0x02FF
    d902:	6f 5f       	subi	r22, 0xFF	; 255
    d904:	81 50       	subi	r24, 0x01	; 1
    d906:	90 4c       	sbci	r25, 0xC0	; 192
    d908:	88 0f       	add	r24, r24
    d90a:	99 1f       	adc	r25, r25
    d90c:	88 0f       	add	r24, r24
    d90e:	99 1f       	adc	r25, r25
    d910:	68 0f       	add	r22, r24
    d912:	80 91 fe 02 	lds	r24, 0x02FE
    d916:	4d eb       	ldi	r20, 0xBD	; 189
    d918:	52 e1       	ldi	r21, 0x12	; 18
    d91a:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
				       iInput=0;
    d91e:	10 92 fd 02 	sts	0x02FD, r1
					   iBlok++;	   
    d922:	80 91 f4 02 	lds	r24, 0x02F4
    d926:	90 91 f5 02 	lds	r25, 0x02F5
    d92a:	01 96       	adiw	r24, 0x01	; 1
    d92c:	90 93 f5 02 	sts	0x02F5, r25
    d930:	80 93 f4 02 	sts	0x02F4, r24
				   }
				   if (iBlok>=4)stClientIP=cipStoreIPblok;
    d934:	80 91 f4 02 	lds	r24, 0x02F4
    d938:	90 91 f5 02 	lds	r25, 0x02F5
    d93c:	04 97       	sbiw	r24, 0x04	; 4
    d93e:	a8 f0       	brcs	.+42     	; 0xd96a <FMenuSettingServerIP+0x4fa>
    d940:	84 e0       	ldi	r24, 0x04	; 4
    d942:	0b c0       	rjmp	.+22     	; 0xd95a <FMenuSettingServerIP+0x4ea>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    d944:	8c e2       	ldi	r24, 0x2C	; 44
    d946:	90 e0       	ldi	r25, 0x00	; 0
    d948:	68 ef       	ldi	r22, 0xF8	; 248
    d94a:	72 e0       	ldi	r23, 0x02	; 2
    d94c:	44 e0       	ldi	r20, 0x04	; 4
    d94e:	50 e0       	ldi	r21, 0x00	; 0
    d950:	2e ef       	ldi	r18, 0xFE	; 254
    d952:	32 e1       	ldi	r19, 0x12	; 18
    d954:	0e 94 96 b5 	call	0x16b2c	; 0x16b2c <__eewr_block>
			   }
		       break;
          case cipStoreIPblok:
		       //UpdateIPblok
			   eeprom_write_block((const void*) &IP_blok,(const void*) &DefServerIP,4);
			   stClientIP=cipExit;
    d958:	83 e0       	ldi	r24, 0x03	; 3
    d95a:	80 93 58 01 	sts	0x0158, r24
    d95e:	05 c0       	rjmp	.+10     	; 0xd96a <FMenuSettingServerIP+0x4fa>
		       break; 
          case cipExit://Cancel IPConfig
			   stClientIP=cipInit;
    d960:	81 e0       	ldi	r24, 0x01	; 1
    d962:	80 93 58 01 	sts	0x0158, r24
			   Result=MENU_DONE;
    d966:	80 93 01 03 	sts	0x0301, r24
		       break;     
		  }//EndSwitch	 
	return Result;
}
    d96a:	80 91 01 03 	lds	r24, 0x0301
    d96e:	64 96       	adiw	r28, 0x14	; 20
    d970:	0f b6       	in	r0, 0x3f	; 63
    d972:	f8 94       	cli
    d974:	de bf       	out	0x3e, r29	; 62
    d976:	0f be       	out	0x3f, r0	; 63
    d978:	cd bf       	out	0x3d, r28	; 61
    d97a:	cf 91       	pop	r28
    d97c:	df 91       	pop	r29
    d97e:	1f 91       	pop	r17
    d980:	0f 91       	pop	r16
    d982:	08 95       	ret

0000d984 <FMenuSettingClientIP>:





char FMenuSettingClientIP(){
    d984:	0f 93       	push	r16
    d986:	1f 93       	push	r17
    d988:	df 93       	push	r29
    d98a:	cf 93       	push	r28
    d98c:	cd b7       	in	r28, 0x3d	; 61
    d98e:	de b7       	in	r29, 0x3e	; 62
    d990:	64 97       	sbiw	r28, 0x14	; 20
    d992:	0f b6       	in	r0, 0x3f	; 63
    d994:	f8 94       	cli
    d996:	de bf       	out	0x3e, r29	; 62
    d998:	0f be       	out	0x3f, r0	; 63
    d99a:	cd bf       	out	0x3d, r28	; 61
     //Client IP
     //Old: 192.168.123.000
	 //New:   _.   .   .
	 //--------------------
	 //*)cancel    #)next
     Result=MENU_NONE;
    d99c:	10 92 13 03 	sts	0x0313, r1
	 switch(stClientIP){
    d9a0:	80 91 59 01 	lds	r24, 0x0159
    d9a4:	82 30       	cpi	r24, 0x02	; 2
    d9a6:	09 f4       	brne	.+2      	; 0xd9aa <FMenuSettingClientIP+0x26>
    d9a8:	7b c0       	rjmp	.+246    	; 0xdaa0 <FMenuSettingClientIP+0x11c>
    d9aa:	83 30       	cpi	r24, 0x03	; 3
    d9ac:	20 f4       	brcc	.+8      	; 0xd9b6 <FMenuSettingClientIP+0x32>
    d9ae:	81 30       	cpi	r24, 0x01	; 1
    d9b0:	09 f0       	breq	.+2      	; 0xd9b4 <FMenuSettingClientIP+0x30>
    d9b2:	65 c2       	rjmp	.+1226   	; 0xde7e <FMenuSettingClientIP+0x4fa>
    d9b4:	07 c0       	rjmp	.+14     	; 0xd9c4 <FMenuSettingClientIP+0x40>
    d9b6:	83 30       	cpi	r24, 0x03	; 3
    d9b8:	09 f4       	brne	.+2      	; 0xd9bc <FMenuSettingClientIP+0x38>
    d9ba:	5c c2       	rjmp	.+1208   	; 0xde74 <FMenuSettingClientIP+0x4f0>
    d9bc:	84 30       	cpi	r24, 0x04	; 4
    d9be:	09 f0       	breq	.+2      	; 0xd9c2 <FMenuSettingClientIP+0x3e>
    d9c0:	5e c2       	rjmp	.+1212   	; 0xde7e <FMenuSettingClientIP+0x4fa>
    d9c2:	4a c2       	rjmp	.+1172   	; 0xde58 <FMenuSettingClientIP+0x4d4>
		  case cipInit:
			   lcd_clear();
    d9c4:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
	           lcd_printf(1,1,PSTR("Client IP"));
    d9c8:	81 e0       	ldi	r24, 0x01	; 1
    d9ca:	61 e0       	ldi	r22, 0x01	; 1
    d9cc:	41 e6       	ldi	r20, 0x61	; 97
    d9ce:	53 e1       	ldi	r21, 0x13	; 19
    d9d0:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    d9d4:	8a e0       	ldi	r24, 0x0A	; 10
    d9d6:	93 e0       	ldi	r25, 0x03	; 3
    d9d8:	68 e2       	ldi	r22, 0x28	; 40
    d9da:	70 e0       	ldi	r23, 0x00	; 0
    d9dc:	44 e0       	ldi	r20, 0x04	; 4
    d9de:	50 e0       	ldi	r21, 0x00	; 0
    d9e0:	26 ef       	ldi	r18, 0xF6	; 246
    d9e2:	32 e1       	ldi	r19, 0x12	; 18
    d9e4:	0e 94 7a b5 	call	0x16af4	; 0x16af4 <__eerd_block>
			   eeprom_read_block((void*)&IP_blok,(const void*)&DefClientIP,4);
	           sprintf_P(lcdteks,PSTR("Old: %d.%d.%d.%d"),IP_blok[0],IP_blok[1],IP_blok[2],IP_blok[3]);
    d9e8:	8d b7       	in	r24, 0x3d	; 61
    d9ea:	9e b7       	in	r25, 0x3e	; 62
    d9ec:	0c 97       	sbiw	r24, 0x0c	; 12
    d9ee:	0f b6       	in	r0, 0x3f	; 63
    d9f0:	f8 94       	cli
    d9f2:	9e bf       	out	0x3e, r25	; 62
    d9f4:	0f be       	out	0x3f, r0	; 63
    d9f6:	8d bf       	out	0x3d, r24	; 61
    d9f8:	ed b7       	in	r30, 0x3d	; 61
    d9fa:	fe b7       	in	r31, 0x3e	; 62
    d9fc:	31 96       	adiw	r30, 0x01	; 1
    d9fe:	8e 01       	movw	r16, r28
    da00:	0f 5f       	subi	r16, 0xFF	; 255
    da02:	1f 4f       	sbci	r17, 0xFF	; 255
    da04:	ad b7       	in	r26, 0x3d	; 61
    da06:	be b7       	in	r27, 0x3e	; 62
    da08:	12 96       	adiw	r26, 0x02	; 2
    da0a:	1c 93       	st	X, r17
    da0c:	0e 93       	st	-X, r16
    da0e:	11 97       	sbiw	r26, 0x01	; 1
    da10:	80 e5       	ldi	r24, 0x50	; 80
    da12:	93 e1       	ldi	r25, 0x13	; 19
    da14:	93 83       	std	Z+3, r25	; 0x03
    da16:	82 83       	std	Z+2, r24	; 0x02
    da18:	80 91 0a 03 	lds	r24, 0x030A
    da1c:	84 83       	std	Z+4, r24	; 0x04
    da1e:	15 82       	std	Z+5, r1	; 0x05
    da20:	80 91 0b 03 	lds	r24, 0x030B
    da24:	86 83       	std	Z+6, r24	; 0x06
    da26:	17 82       	std	Z+7, r1	; 0x07
    da28:	80 91 0c 03 	lds	r24, 0x030C
    da2c:	80 87       	std	Z+8, r24	; 0x08
    da2e:	11 86       	std	Z+9, r1	; 0x09
    da30:	80 91 0d 03 	lds	r24, 0x030D
    da34:	82 87       	std	Z+10, r24	; 0x0a
    da36:	13 86       	std	Z+11, r1	; 0x0b
    da38:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
	           lcd_print(2,1,lcdteks);
    da3c:	ed b7       	in	r30, 0x3d	; 61
    da3e:	fe b7       	in	r31, 0x3e	; 62
    da40:	3c 96       	adiw	r30, 0x0c	; 12
    da42:	0f b6       	in	r0, 0x3f	; 63
    da44:	f8 94       	cli
    da46:	fe bf       	out	0x3e, r31	; 62
    da48:	0f be       	out	0x3f, r0	; 63
    da4a:	ed bf       	out	0x3d, r30	; 61
    da4c:	82 e0       	ldi	r24, 0x02	; 2
    da4e:	61 e0       	ldi	r22, 0x01	; 1
    da50:	a8 01       	movw	r20, r16
    da52:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
			   lcd_printf(3,1,PSTR("New:   _.   .   .   "));
    da56:	83 e0       	ldi	r24, 0x03	; 3
    da58:	61 e0       	ldi	r22, 0x01	; 1
    da5a:	4b e3       	ldi	r20, 0x3B	; 59
    da5c:	53 e1       	ldi	r21, 0x13	; 19
    da5e:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
			   lcd_printf(4,1,PSTR("[*]cancel  [#]next  "));
    da62:	84 e0       	ldi	r24, 0x04	; 4
    da64:	61 e0       	ldi	r22, 0x01	; 1
    da66:	46 e2       	ldi	r20, 0x26	; 38
    da68:	53 e1       	ldi	r21, 0x13	; 19
    da6a:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
               iLoop=0;
    da6e:	10 92 09 03 	sts	0x0309, r1
    da72:	10 92 08 03 	sts	0x0308, r1
			   y=3,x=8;
    da76:	83 e0       	ldi	r24, 0x03	; 3
    da78:	80 93 10 03 	sts	0x0310, r24
    da7c:	88 e0       	ldi	r24, 0x08	; 8
    da7e:	80 93 11 03 	sts	0x0311, r24
			   iInput=0; iBlok=0;
    da82:	10 92 0f 03 	sts	0x030F, r1
    da86:	10 92 07 03 	sts	0x0307, r1
    da8a:	10 92 06 03 	sts	0x0306, r1
			   IPchar[0]='0';IPchar[1]='0';IPchar[2]='0';
    da8e:	80 e3       	ldi	r24, 0x30	; 48
    da90:	80 93 15 03 	sts	0x0315, r24
    da94:	80 93 16 03 	sts	0x0316, r24
    da98:	80 93 17 03 	sts	0x0317, r24
			   stClientIP=cipInputIP; 
    da9c:	82 e0       	ldi	r24, 0x02	; 2
    da9e:	e7 c1       	rjmp	.+974    	; 0xde6e <FMenuSettingClientIP+0x4ea>
		       break;
          case cipInputIP:
			   //Blinking 60% _ 
			   iLoop++;
    daa0:	80 91 08 03 	lds	r24, 0x0308
    daa4:	90 91 09 03 	lds	r25, 0x0309
    daa8:	01 96       	adiw	r24, 0x01	; 1
    daaa:	90 93 09 03 	sts	0x0309, r25
    daae:	80 93 08 03 	sts	0x0308, r24
			   if ((iLoop%2000)==0){
    dab2:	60 ed       	ldi	r22, 0xD0	; 208
    dab4:	77 e0       	ldi	r23, 0x07	; 7
    dab6:	0e 94 93 b8 	call	0x17126	; 0x17126 <__udivmodhi4>
    daba:	89 2b       	or	r24, r25
    dabc:	81 f4       	brne	.+32     	; 0xdade <FMenuSettingClientIP+0x15a>
			      lcd_put(y,(x+(iBlok*4)),'_'); 
    dabe:	80 91 06 03 	lds	r24, 0x0306
    dac2:	90 91 07 03 	lds	r25, 0x0307
    dac6:	88 0f       	add	r24, r24
    dac8:	99 1f       	adc	r25, r25
    daca:	88 0f       	add	r24, r24
    dacc:	99 1f       	adc	r25, r25
    dace:	60 91 11 03 	lds	r22, 0x0311
    dad2:	68 0f       	add	r22, r24
    dad4:	80 91 10 03 	lds	r24, 0x0310
    dad8:	4f e5       	ldi	r20, 0x5F	; 95
    dada:	0e 94 da ae 	call	0x15db4	; 0x15db4 <lcd_put>
			   }
			   if ((iLoop%2000)==1000){
    dade:	80 91 08 03 	lds	r24, 0x0308
    dae2:	90 91 09 03 	lds	r25, 0x0309
    dae6:	60 ed       	ldi	r22, 0xD0	; 208
    dae8:	77 e0       	ldi	r23, 0x07	; 7
    daea:	0e 94 93 b8 	call	0x17126	; 0x17126 <__udivmodhi4>
    daee:	88 5e       	subi	r24, 0xE8	; 232
    daf0:	93 40       	sbci	r25, 0x03	; 3
    daf2:	81 f4       	brne	.+32     	; 0xdb14 <FMenuSettingClientIP+0x190>
			      lcd_put(y,(x+(iBlok*4)),' '); 
    daf4:	80 91 06 03 	lds	r24, 0x0306
    daf8:	90 91 07 03 	lds	r25, 0x0307
    dafc:	88 0f       	add	r24, r24
    dafe:	99 1f       	adc	r25, r25
    db00:	88 0f       	add	r24, r24
    db02:	99 1f       	adc	r25, r25
    db04:	60 91 11 03 	lds	r22, 0x0311
    db08:	68 0f       	add	r22, r24
    db0a:	80 91 10 03 	lds	r24, 0x0310
    db0e:	40 e2       	ldi	r20, 0x20	; 32
    db10:	0e 94 da ae 	call	0x15db4	; 0x15db4 <lcd_put>
			   }
			   //GetKeyPressed
			   keyPressed=_key_scan(1);
    db14:	81 e0       	ldi	r24, 0x01	; 1
    db16:	0e 94 06 b0 	call	0x1600c	; 0x1600c <_key_scan>
    db1a:	80 93 0e 03 	sts	0x030E, r24
			   keyChar=_key_btn(keyPressed);
    db1e:	0e 94 67 af 	call	0x15ece	; 0x15ece <_key_btn>
    db22:	28 2f       	mov	r18, r24
    db24:	80 93 12 03 	sts	0x0312, r24
               if ((keyChar>='0')&&(keyChar<='9')){
    db28:	80 53       	subi	r24, 0x30	; 48
    db2a:	8a 30       	cpi	r24, 0x0A	; 10
    db2c:	08 f0       	brcs	.+2      	; 0xdb30 <FMenuSettingClientIP+0x1ac>
    db2e:	d6 c0       	rjmp	.+428    	; 0xdcdc <FMenuSettingClientIP+0x358>
    db30:	80 e5       	ldi	r24, 0x50	; 80
    db32:	93 ec       	ldi	r25, 0xC3	; 195
    db34:	01 97       	sbiw	r24, 0x01	; 1
    db36:	f1 f7       	brne	.-4      	; 0xdb34 <FMenuSettingClientIP+0x1b0>
			       _delay_ms(200);
			       IPchar[iInput]=keyChar;
    db38:	80 91 0f 03 	lds	r24, 0x030F
    db3c:	e8 2f       	mov	r30, r24
    db3e:	f0 e0       	ldi	r31, 0x00	; 0
    db40:	eb 5e       	subi	r30, 0xEB	; 235
    db42:	fc 4f       	sbci	r31, 0xFC	; 252
    db44:	20 83       	st	Z, r18
				   iInput++;                    
    db46:	8f 5f       	subi	r24, 0xFF	; 255
    db48:	80 93 0f 03 	sts	0x030F, r24
				   for (i=1;i<(iInput+1);i++){
    db4c:	81 e0       	ldi	r24, 0x01	; 1
    db4e:	1c c0       	rjmp	.+56     	; 0xdb88 <FMenuSettingClientIP+0x204>
				       lcd_xy(y,((x+(iBlok*4))-(3-i)));_lcd(IPchar[i-1]);
    db50:	80 91 11 03 	lds	r24, 0x0311
    db54:	68 0f       	add	r22, r24
    db56:	63 50       	subi	r22, 0x03	; 3
    db58:	80 91 06 03 	lds	r24, 0x0306
    db5c:	90 91 07 03 	lds	r25, 0x0307
    db60:	88 0f       	add	r24, r24
    db62:	99 1f       	adc	r25, r25
    db64:	88 0f       	add	r24, r24
    db66:	99 1f       	adc	r25, r25
    db68:	68 0f       	add	r22, r24
    db6a:	80 91 10 03 	lds	r24, 0x0310
    db6e:	0e 94 4c ae 	call	0x15c98	; 0x15c98 <lcd_xy>
    db72:	e0 91 14 03 	lds	r30, 0x0314
    db76:	f0 e0       	ldi	r31, 0x00	; 0
    db78:	ec 5e       	subi	r30, 0xEC	; 236
    db7a:	fc 4f       	sbci	r31, 0xFC	; 252
    db7c:	80 81       	ld	r24, Z
    db7e:	0e 94 26 ae 	call	0x15c4c	; 0x15c4c <_lcd>
			   keyChar=_key_btn(keyPressed);
               if ((keyChar>='0')&&(keyChar<='9')){
			       _delay_ms(200);
			       IPchar[iInput]=keyChar;
				   iInput++;                    
				   for (i=1;i<(iInput+1);i++){
    db82:	80 91 14 03 	lds	r24, 0x0314
    db86:	8f 5f       	subi	r24, 0xFF	; 255
    db88:	80 93 14 03 	sts	0x0314, r24
    db8c:	70 91 0f 03 	lds	r23, 0x030F
    db90:	60 91 14 03 	lds	r22, 0x0314
    db94:	27 2f       	mov	r18, r23
    db96:	30 e0       	ldi	r19, 0x00	; 0
    db98:	86 2f       	mov	r24, r22
    db9a:	90 e0       	ldi	r25, 0x00	; 0
    db9c:	28 17       	cp	r18, r24
    db9e:	39 07       	cpc	r19, r25
    dba0:	bc f6       	brge	.-82     	; 0xdb50 <FMenuSettingClientIP+0x1cc>
				       lcd_xy(y,((x+(iBlok*4))-(3-i)));_lcd(IPchar[i-1]);
				   }
                   //NextInput
				   if (iInput>=3){
    dba2:	73 30       	cpi	r23, 0x03	; 3
    dba4:	08 f4       	brcc	.+2      	; 0xdba8 <FMenuSettingClientIP+0x224>
    dba6:	91 c0       	rjmp	.+290    	; 0xdcca <FMenuSettingClientIP+0x346>
				       IP_blok[iBlok]=((IPchar[0]-'0')*100)+((IPchar[1]-'0')*10)+((IPchar[2]-'0'));
    dba8:	40 91 06 03 	lds	r20, 0x0306
    dbac:	50 91 07 03 	lds	r21, 0x0307
    dbb0:	fa 01       	movw	r30, r20
    dbb2:	e6 5f       	subi	r30, 0xF6	; 246
    dbb4:	fc 4f       	sbci	r31, 0xFC	; 252
    dbb6:	20 91 17 03 	lds	r18, 0x0317
    dbba:	20 5d       	subi	r18, 0xD0	; 208
    dbbc:	80 91 15 03 	lds	r24, 0x0315
    dbc0:	34 e6       	ldi	r19, 0x64	; 100
    dbc2:	83 9f       	mul	r24, r19
    dbc4:	c0 01       	movw	r24, r0
    dbc6:	11 24       	eor	r1, r1
    dbc8:	28 0f       	add	r18, r24
    dbca:	80 91 16 03 	lds	r24, 0x0316
    dbce:	3a e0       	ldi	r19, 0x0A	; 10
    dbd0:	83 9f       	mul	r24, r19
    dbd2:	c0 01       	movw	r24, r0
    dbd4:	11 24       	eor	r1, r1
    dbd6:	28 0f       	add	r18, r24
    dbd8:	20 83       	st	Z, r18
					   IPchar[0]='0';IPchar[1]='0';IPchar[2]='0';
    dbda:	80 e3       	ldi	r24, 0x30	; 48
    dbdc:	80 93 15 03 	sts	0x0315, r24
    dbe0:	80 93 16 03 	sts	0x0316, r24
    dbe4:	80 93 17 03 	sts	0x0317, r24
					   //Reposition Value
					   lcd_printf(y,((x+(iBlok*4))-iInput),PSTR("   "));
    dbe8:	44 0f       	add	r20, r20
    dbea:	55 1f       	adc	r21, r21
    dbec:	44 0f       	add	r20, r20
    dbee:	55 1f       	adc	r21, r21
    dbf0:	60 91 11 03 	lds	r22, 0x0311
    dbf4:	64 0f       	add	r22, r20
    dbf6:	67 1b       	sub	r22, r23
    dbf8:	80 91 10 03 	lds	r24, 0x0310
    dbfc:	42 e2       	ldi	r20, 0x22	; 34
    dbfe:	53 e1       	ldi	r21, 0x13	; 19
    dc00:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
					   sprintf_P(lcdteks,PSTR("%d"),IP_blok[iBlok]);
    dc04:	00 d0       	rcall	.+0      	; 0xdc06 <FMenuSettingClientIP+0x282>
    dc06:	00 d0       	rcall	.+0      	; 0xdc08 <FMenuSettingClientIP+0x284>
    dc08:	00 d0       	rcall	.+0      	; 0xdc0a <FMenuSettingClientIP+0x286>
    dc0a:	ad b7       	in	r26, 0x3d	; 61
    dc0c:	be b7       	in	r27, 0x3e	; 62
    dc0e:	11 96       	adiw	r26, 0x01	; 1
    dc10:	8e 01       	movw	r16, r28
    dc12:	0f 5f       	subi	r16, 0xFF	; 255
    dc14:	1f 4f       	sbci	r17, 0xFF	; 255
    dc16:	ed b7       	in	r30, 0x3d	; 61
    dc18:	fe b7       	in	r31, 0x3e	; 62
    dc1a:	12 83       	std	Z+2, r17	; 0x02
    dc1c:	01 83       	std	Z+1, r16	; 0x01
    dc1e:	8f e1       	ldi	r24, 0x1F	; 31
    dc20:	93 e1       	ldi	r25, 0x13	; 19
    dc22:	13 96       	adiw	r26, 0x03	; 3
    dc24:	9c 93       	st	X, r25
    dc26:	8e 93       	st	-X, r24
    dc28:	12 97       	sbiw	r26, 0x02	; 2
    dc2a:	e0 91 06 03 	lds	r30, 0x0306
    dc2e:	f0 91 07 03 	lds	r31, 0x0307
    dc32:	e6 5f       	subi	r30, 0xF6	; 246
    dc34:	fc 4f       	sbci	r31, 0xFC	; 252
    dc36:	80 81       	ld	r24, Z
    dc38:	14 96       	adiw	r26, 0x04	; 4
    dc3a:	8c 93       	st	X, r24
    dc3c:	14 97       	sbiw	r26, 0x04	; 4
    dc3e:	15 96       	adiw	r26, 0x05	; 5
    dc40:	1c 92       	st	X, r1
    dc42:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
                       lcd_print(y,1+((x+(iBlok*4))-strlen(lcdteks)),lcdteks);
    dc46:	f8 01       	movw	r30, r16
    dc48:	01 90       	ld	r0, Z+
    dc4a:	00 20       	and	r0, r0
    dc4c:	e9 f7       	brne	.-6      	; 0xdc48 <FMenuSettingClientIP+0x2c4>
    dc4e:	31 97       	sbiw	r30, 0x01	; 1
    dc50:	e0 1b       	sub	r30, r16
    dc52:	f1 0b       	sbc	r31, r17
    dc54:	8d b7       	in	r24, 0x3d	; 61
    dc56:	9e b7       	in	r25, 0x3e	; 62
    dc58:	06 96       	adiw	r24, 0x06	; 6
    dc5a:	0f b6       	in	r0, 0x3f	; 63
    dc5c:	f8 94       	cli
    dc5e:	9e bf       	out	0x3e, r25	; 62
    dc60:	0f be       	out	0x3f, r0	; 63
    dc62:	8d bf       	out	0x3d, r24	; 61
    dc64:	60 91 11 03 	lds	r22, 0x0311
    dc68:	6f 5f       	subi	r22, 0xFF	; 255
    dc6a:	80 91 06 03 	lds	r24, 0x0306
    dc6e:	90 91 07 03 	lds	r25, 0x0307
    dc72:	88 0f       	add	r24, r24
    dc74:	99 1f       	adc	r25, r25
    dc76:	88 0f       	add	r24, r24
    dc78:	99 1f       	adc	r25, r25
    dc7a:	68 0f       	add	r22, r24
    dc7c:	6e 1b       	sub	r22, r30
    dc7e:	80 91 10 03 	lds	r24, 0x0310
    dc82:	a8 01       	movw	r20, r16
    dc84:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
					   if (iBlok>0)lcd_printf(y,1+((x+((iBlok-1)*4))),PSTR("."));
    dc88:	80 91 06 03 	lds	r24, 0x0306
    dc8c:	90 91 07 03 	lds	r25, 0x0307
    dc90:	00 97       	sbiw	r24, 0x00	; 0
    dc92:	81 f0       	breq	.+32     	; 0xdcb4 <FMenuSettingClientIP+0x330>
    dc94:	60 91 11 03 	lds	r22, 0x0311
    dc98:	6f 5f       	subi	r22, 0xFF	; 255
    dc9a:	81 50       	subi	r24, 0x01	; 1
    dc9c:	90 4c       	sbci	r25, 0xC0	; 192
    dc9e:	88 0f       	add	r24, r24
    dca0:	99 1f       	adc	r25, r25
    dca2:	88 0f       	add	r24, r24
    dca4:	99 1f       	adc	r25, r25
    dca6:	68 0f       	add	r22, r24
    dca8:	80 91 10 03 	lds	r24, 0x0310
    dcac:	4d e1       	ldi	r20, 0x1D	; 29
    dcae:	53 e1       	ldi	r21, 0x13	; 19
    dcb0:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
					   iInput=0;
    dcb4:	10 92 0f 03 	sts	0x030F, r1
					   iBlok++;
    dcb8:	80 91 06 03 	lds	r24, 0x0306
    dcbc:	90 91 07 03 	lds	r25, 0x0307
    dcc0:	01 96       	adiw	r24, 0x01	; 1
    dcc2:	90 93 07 03 	sts	0x0307, r25
    dcc6:	80 93 06 03 	sts	0x0306, r24

				   }
				   if (iBlok>=4)stClientIP=cipStoreIPblok;
    dcca:	80 91 06 03 	lds	r24, 0x0306
    dcce:	90 91 07 03 	lds	r25, 0x0307
    dcd2:	04 97       	sbiw	r24, 0x04	; 4
    dcd4:	18 f0       	brcs	.+6      	; 0xdcdc <FMenuSettingClientIP+0x358>
    dcd6:	84 e0       	ldi	r24, 0x04	; 4
    dcd8:	80 93 59 01 	sts	0x0159, r24
			   }

			   if (keyPressed==_KEY_CANCEL){
    dcdc:	80 91 0e 03 	lds	r24, 0x030E
    dce0:	87 3e       	cpi	r24, 0xE7	; 231
    dce2:	09 f4       	brne	.+2      	; 0xdce6 <FMenuSettingClientIP+0x362>
    dce4:	c3 c0       	rjmp	.+390    	; 0xde6c <FMenuSettingClientIP+0x4e8>
			       stClientIP=cipExit; 
			   }
			   else
			   if (keyPressed==_KEY_ENTER){
    dce6:	87 3b       	cpi	r24, 0xB7	; 183
    dce8:	09 f0       	breq	.+2      	; 0xdcec <FMenuSettingClientIP+0x368>
    dcea:	c9 c0       	rjmp	.+402    	; 0xde7e <FMenuSettingClientIP+0x4fa>
			       //NextInput
			       if (iBlok<4){
    dcec:	40 91 06 03 	lds	r20, 0x0306
    dcf0:	50 91 07 03 	lds	r21, 0x0307
    dcf4:	44 30       	cpi	r20, 0x04	; 4
    dcf6:	51 05       	cpc	r21, r1
    dcf8:	08 f0       	brcs	.+2      	; 0xdcfc <FMenuSettingClientIP+0x378>
    dcfa:	a6 c0       	rjmp	.+332    	; 0xde48 <FMenuSettingClientIP+0x4c4>
				       if (iInput==1)IP_blok[iBlok]=((IPchar[0]-'0'));
    dcfc:	80 91 0f 03 	lds	r24, 0x030F
    dd00:	81 30       	cpi	r24, 0x01	; 1
    dd02:	41 f4       	brne	.+16     	; 0xdd14 <FMenuSettingClientIP+0x390>
    dd04:	fa 01       	movw	r30, r20
    dd06:	e6 5f       	subi	r30, 0xF6	; 246
    dd08:	fc 4f       	sbci	r31, 0xFC	; 252
    dd0a:	80 91 15 03 	lds	r24, 0x0315
    dd0e:	80 53       	subi	r24, 0x30	; 48
    dd10:	80 83       	st	Z, r24
    dd12:	22 c0       	rjmp	.+68     	; 0xdd58 <FMenuSettingClientIP+0x3d4>
					   if (iInput==2)IP_blok[iBlok]=((IPchar[0]-'0')*10)+(IPchar[1]-'0');
    dd14:	82 30       	cpi	r24, 0x02	; 2
    dd16:	49 f4       	brne	.+18     	; 0xdd2a <FMenuSettingClientIP+0x3a6>
    dd18:	fa 01       	movw	r30, r20
    dd1a:	e6 5f       	subi	r30, 0xF6	; 246
    dd1c:	fc 4f       	sbci	r31, 0xFC	; 252
    dd1e:	20 91 16 03 	lds	r18, 0x0316
    dd22:	20 51       	subi	r18, 0x10	; 16
    dd24:	80 91 15 03 	lds	r24, 0x0315
    dd28:	11 c0       	rjmp	.+34     	; 0xdd4c <FMenuSettingClientIP+0x3c8>
					   if (iInput==3)IP_blok[iBlok]=((IPchar[0]-'0')*100)+((IPchar[1]-'0')*10)+((IPchar[2]-'0'));
    dd2a:	83 30       	cpi	r24, 0x03	; 3
    dd2c:	a9 f4       	brne	.+42     	; 0xdd58 <FMenuSettingClientIP+0x3d4>
    dd2e:	fa 01       	movw	r30, r20
    dd30:	e6 5f       	subi	r30, 0xF6	; 246
    dd32:	fc 4f       	sbci	r31, 0xFC	; 252
    dd34:	20 91 17 03 	lds	r18, 0x0317
    dd38:	20 5d       	subi	r18, 0xD0	; 208
    dd3a:	80 91 15 03 	lds	r24, 0x0315
    dd3e:	34 e6       	ldi	r19, 0x64	; 100
    dd40:	83 9f       	mul	r24, r19
    dd42:	c0 01       	movw	r24, r0
    dd44:	11 24       	eor	r1, r1
    dd46:	28 0f       	add	r18, r24
    dd48:	80 91 16 03 	lds	r24, 0x0316
    dd4c:	3a e0       	ldi	r19, 0x0A	; 10
    dd4e:	83 9f       	mul	r24, r19
    dd50:	c0 01       	movw	r24, r0
    dd52:	11 24       	eor	r1, r1
    dd54:	28 0f       	add	r18, r24
    dd56:	20 83       	st	Z, r18
				       
					   IPchar[0]='0';IPchar[1]='0';IPchar[2]='0';
    dd58:	80 e3       	ldi	r24, 0x30	; 48
    dd5a:	80 93 15 03 	sts	0x0315, r24
    dd5e:	80 93 16 03 	sts	0x0316, r24
    dd62:	80 93 17 03 	sts	0x0317, r24
					   //Reposition Value
					   lcd_printf(y,((x+(iBlok*4))-3),PSTR("   "));
    dd66:	60 91 11 03 	lds	r22, 0x0311
    dd6a:	63 50       	subi	r22, 0x03	; 3
    dd6c:	44 0f       	add	r20, r20
    dd6e:	55 1f       	adc	r21, r21
    dd70:	44 0f       	add	r20, r20
    dd72:	55 1f       	adc	r21, r21
    dd74:	64 0f       	add	r22, r20
    dd76:	80 91 10 03 	lds	r24, 0x0310
    dd7a:	49 e1       	ldi	r20, 0x19	; 25
    dd7c:	53 e1       	ldi	r21, 0x13	; 19
    dd7e:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
					   sprintf_P(lcdteks,PSTR("%d"),IP_blok[iBlok]);
    dd82:	00 d0       	rcall	.+0      	; 0xdd84 <FMenuSettingClientIP+0x400>
    dd84:	00 d0       	rcall	.+0      	; 0xdd86 <FMenuSettingClientIP+0x402>
    dd86:	00 d0       	rcall	.+0      	; 0xdd88 <FMenuSettingClientIP+0x404>
    dd88:	ad b7       	in	r26, 0x3d	; 61
    dd8a:	be b7       	in	r27, 0x3e	; 62
    dd8c:	11 96       	adiw	r26, 0x01	; 1
    dd8e:	8e 01       	movw	r16, r28
    dd90:	0f 5f       	subi	r16, 0xFF	; 255
    dd92:	1f 4f       	sbci	r17, 0xFF	; 255
    dd94:	ed b7       	in	r30, 0x3d	; 61
    dd96:	fe b7       	in	r31, 0x3e	; 62
    dd98:	12 83       	std	Z+2, r17	; 0x02
    dd9a:	01 83       	std	Z+1, r16	; 0x01
    dd9c:	86 e1       	ldi	r24, 0x16	; 22
    dd9e:	93 e1       	ldi	r25, 0x13	; 19
    dda0:	13 96       	adiw	r26, 0x03	; 3
    dda2:	9c 93       	st	X, r25
    dda4:	8e 93       	st	-X, r24
    dda6:	12 97       	sbiw	r26, 0x02	; 2
    dda8:	e0 91 06 03 	lds	r30, 0x0306
    ddac:	f0 91 07 03 	lds	r31, 0x0307
    ddb0:	e6 5f       	subi	r30, 0xF6	; 246
    ddb2:	fc 4f       	sbci	r31, 0xFC	; 252
    ddb4:	80 81       	ld	r24, Z
    ddb6:	14 96       	adiw	r26, 0x04	; 4
    ddb8:	8c 93       	st	X, r24
    ddba:	14 97       	sbiw	r26, 0x04	; 4
    ddbc:	15 96       	adiw	r26, 0x05	; 5
    ddbe:	1c 92       	st	X, r1
    ddc0:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
                       lcd_print(y,1+((x+(iBlok*4))-strlen(lcdteks)),lcdteks);
    ddc4:	f8 01       	movw	r30, r16
    ddc6:	01 90       	ld	r0, Z+
    ddc8:	00 20       	and	r0, r0
    ddca:	e9 f7       	brne	.-6      	; 0xddc6 <FMenuSettingClientIP+0x442>
    ddcc:	31 97       	sbiw	r30, 0x01	; 1
    ddce:	e0 1b       	sub	r30, r16
    ddd0:	f1 0b       	sbc	r31, r17
    ddd2:	8d b7       	in	r24, 0x3d	; 61
    ddd4:	9e b7       	in	r25, 0x3e	; 62
    ddd6:	06 96       	adiw	r24, 0x06	; 6
    ddd8:	0f b6       	in	r0, 0x3f	; 63
    ddda:	f8 94       	cli
    dddc:	9e bf       	out	0x3e, r25	; 62
    ddde:	0f be       	out	0x3f, r0	; 63
    dde0:	8d bf       	out	0x3d, r24	; 61
    dde2:	60 91 11 03 	lds	r22, 0x0311
    dde6:	6f 5f       	subi	r22, 0xFF	; 255
    dde8:	80 91 06 03 	lds	r24, 0x0306
    ddec:	90 91 07 03 	lds	r25, 0x0307
    ddf0:	88 0f       	add	r24, r24
    ddf2:	99 1f       	adc	r25, r25
    ddf4:	88 0f       	add	r24, r24
    ddf6:	99 1f       	adc	r25, r25
    ddf8:	68 0f       	add	r22, r24
    ddfa:	6e 1b       	sub	r22, r30
    ddfc:	80 91 10 03 	lds	r24, 0x0310
    de00:	a8 01       	movw	r20, r16
    de02:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>

					   if (iBlok>0)lcd_printf(y,1+((x+((iBlok-1)*4))),PSTR("."));
    de06:	80 91 06 03 	lds	r24, 0x0306
    de0a:	90 91 07 03 	lds	r25, 0x0307
    de0e:	00 97       	sbiw	r24, 0x00	; 0
    de10:	81 f0       	breq	.+32     	; 0xde32 <FMenuSettingClientIP+0x4ae>
    de12:	60 91 11 03 	lds	r22, 0x0311
    de16:	6f 5f       	subi	r22, 0xFF	; 255
    de18:	81 50       	subi	r24, 0x01	; 1
    de1a:	90 4c       	sbci	r25, 0xC0	; 192
    de1c:	88 0f       	add	r24, r24
    de1e:	99 1f       	adc	r25, r25
    de20:	88 0f       	add	r24, r24
    de22:	99 1f       	adc	r25, r25
    de24:	68 0f       	add	r22, r24
    de26:	80 91 10 03 	lds	r24, 0x0310
    de2a:	44 e1       	ldi	r20, 0x14	; 20
    de2c:	53 e1       	ldi	r21, 0x13	; 19
    de2e:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
				       iInput=0;
    de32:	10 92 0f 03 	sts	0x030F, r1
					   iBlok++;	   
    de36:	80 91 06 03 	lds	r24, 0x0306
    de3a:	90 91 07 03 	lds	r25, 0x0307
    de3e:	01 96       	adiw	r24, 0x01	; 1
    de40:	90 93 07 03 	sts	0x0307, r25
    de44:	80 93 06 03 	sts	0x0306, r24
				   }
				   if (iBlok>=4)stClientIP=cipStoreIPblok;
    de48:	80 91 06 03 	lds	r24, 0x0306
    de4c:	90 91 07 03 	lds	r25, 0x0307
    de50:	04 97       	sbiw	r24, 0x04	; 4
    de52:	a8 f0       	brcs	.+42     	; 0xde7e <FMenuSettingClientIP+0x4fa>
    de54:	84 e0       	ldi	r24, 0x04	; 4
    de56:	0b c0       	rjmp	.+22     	; 0xde6e <FMenuSettingClientIP+0x4ea>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    de58:	88 e2       	ldi	r24, 0x28	; 40
    de5a:	90 e0       	ldi	r25, 0x00	; 0
    de5c:	6a e0       	ldi	r22, 0x0A	; 10
    de5e:	73 e0       	ldi	r23, 0x03	; 3
    de60:	44 e0       	ldi	r20, 0x04	; 4
    de62:	50 e0       	ldi	r21, 0x00	; 0
    de64:	2e ef       	ldi	r18, 0xFE	; 254
    de66:	32 e1       	ldi	r19, 0x12	; 18
    de68:	0e 94 96 b5 	call	0x16b2c	; 0x16b2c <__eewr_block>
			   }
		       break;
          case cipStoreIPblok://UpdateIPblok
			   eeprom_write_block((const void*) &IP_blok,(const void*) &DefClientIP,4);
			   stClientIP=cipExit;
    de6c:	83 e0       	ldi	r24, 0x03	; 3
    de6e:	80 93 59 01 	sts	0x0159, r24
    de72:	05 c0       	rjmp	.+10     	; 0xde7e <FMenuSettingClientIP+0x4fa>
		       break; 
          case cipExit://Cancel IPConfig
		       stClientIP=cipInit;
    de74:	81 e0       	ldi	r24, 0x01	; 1
    de76:	80 93 59 01 	sts	0x0159, r24
		       Result=MENU_DONE;
    de7a:	80 93 13 03 	sts	0x0313, r24
		       break;     
		  }//EndSwitch	 
    return Result;
}
    de7e:	80 91 13 03 	lds	r24, 0x0313
    de82:	64 96       	adiw	r28, 0x14	; 20
    de84:	0f b6       	in	r0, 0x3f	; 63
    de86:	f8 94       	cli
    de88:	de bf       	out	0x3e, r29	; 62
    de8a:	0f be       	out	0x3f, r0	; 63
    de8c:	cd bf       	out	0x3d, r28	; 61
    de8e:	cf 91       	pop	r28
    de90:	df 91       	pop	r29
    de92:	1f 91       	pop	r17
    de94:	0f 91       	pop	r16
    de96:	08 95       	ret

0000de98 <DisplayStandaloneSequence>:
	 i++;
     _delay_ms(6500);
  return Result;
}

void DisplayStandaloneSequence(char x,char y, char PoolingSequence){
    de98:	df 93       	push	r29
    de9a:	cf 93       	push	r28
    de9c:	cd b7       	in	r28, 0x3d	; 61
    de9e:	de b7       	in	r29, 0x3e	; 62
    dea0:	28 97       	sbiw	r28, 0x08	; 8
    dea2:	0f b6       	in	r0, 0x3f	; 63
    dea4:	f8 94       	cli
    dea6:	de bf       	out	0x3e, r29	; 62
    dea8:	0f be       	out	0x3f, r0	; 63
    deaa:	cd bf       	out	0x3d, r28	; 61
    deac:	58 2f       	mov	r21, r24
	 MapSequence[3]='/';
	 MapSequence[4]='-';
	 MapSequence[5]=164;//0x5C;
	 MapSequence[6]='|';
	 MapSequence[7]='/';
	 if (IsPoolingRestarted==False)lcd_put(x,y,MapSequence[(PoolingSequence%8)]);     
    deae:	80 91 96 01 	lds	r24, 0x0196
    deb2:	88 23       	and	r24, r24
    deb4:	a1 f4       	brne	.+40     	; 0xdede <DisplayStandaloneSequence+0x46>

void DisplayStandaloneSequence(char x,char y, char PoolingSequence){
     char MapSequence[8];

     //sprintf_P(MapSequence,PSTR("-\|/-|/"));
	 MapSequence[0]='-';
    deb6:	3d e2       	ldi	r19, 0x2D	; 45
    deb8:	39 83       	std	Y+1, r19	; 0x01
	 MapSequence[1]='`';//0x5C;
    deba:	80 e6       	ldi	r24, 0x60	; 96
    debc:	8a 83       	std	Y+2, r24	; 0x02
	 MapSequence[2]='|';
    debe:	2c e7       	ldi	r18, 0x7C	; 124
    dec0:	2b 83       	std	Y+3, r18	; 0x03
	 MapSequence[3]='/';
    dec2:	9f e2       	ldi	r25, 0x2F	; 47
    dec4:	9c 83       	std	Y+4, r25	; 0x04
	 MapSequence[4]='-';
    dec6:	3d 83       	std	Y+5, r19	; 0x05
	 MapSequence[5]=164;//0x5C;
    dec8:	84 ea       	ldi	r24, 0xA4	; 164
    deca:	8e 83       	std	Y+6, r24	; 0x06
	 MapSequence[6]='|';
    decc:	2f 83       	std	Y+7, r18	; 0x07
	 MapSequence[7]='/';
    dece:	98 87       	std	Y+8, r25	; 0x08
	 if (IsPoolingRestarted==False)lcd_put(x,y,MapSequence[(PoolingSequence%8)]);     
    ded0:	47 70       	andi	r20, 0x07	; 7
    ded2:	fe 01       	movw	r30, r28
    ded4:	e4 0f       	add	r30, r20
    ded6:	f1 1d       	adc	r31, r1
    ded8:	85 2f       	mov	r24, r21
    deda:	41 81       	ldd	r20, Z+1	; 0x01
    dedc:	08 c0       	rjmp	.+16     	; 0xdeee <DisplayStandaloneSequence+0x56>
	 else if (IsPoolingRestarted==True){
    dede:	80 91 96 01 	lds	r24, 0x0196
    dee2:	81 30       	cpi	r24, 0x01	; 1
    dee4:	31 f4       	brne	.+12     	; 0xdef2 <DisplayStandaloneSequence+0x5a>
	          IsPoolingRestarted=False;
    dee6:	10 92 96 01 	sts	0x0196, r1
	          lcd_put(x,y,'X');     
    deea:	85 2f       	mov	r24, r21
    deec:	48 e5       	ldi	r20, 0x58	; 88
    deee:	0e 94 da ae 	call	0x15db4	; 0x15db4 <lcd_put>
			  }

}
    def2:	28 96       	adiw	r28, 0x08	; 8
    def4:	0f b6       	in	r0, 0x3f	; 63
    def6:	f8 94       	cli
    def8:	de bf       	out	0x3e, r29	; 62
    defa:	0f be       	out	0x3f, r0	; 63
    defc:	cd bf       	out	0x3d, r28	; 61
    defe:	cf 91       	pop	r28
    df00:	df 91       	pop	r29
    df02:	08 95       	ret

0000df04 <FSettingPumpPooling>:
	      break;
	 }
     return Result;
}

char FSettingPumpPooling(){//Parameter: PumpCount,
    df04:	0f 93       	push	r16
    df06:	1f 93       	push	r17
    df08:	df 93       	push	r29
    df0a:	cf 93       	push	r28
    df0c:	cd b7       	in	r28, 0x3d	; 61
    df0e:	de b7       	in	r29, 0x3e	; 62
    df10:	6a 97       	sbiw	r28, 0x1a	; 26
    df12:	0f b6       	in	r0, 0x3f	; 63
    df14:	f8 94       	cli
    df16:	de bf       	out	0x3e, r29	; 62
    df18:	0f be       	out	0x3f, r0	; 63
    df1a:	cd bf       	out	0x3d, r28	; 61
static char stPumpPooling=ppInitMenu;
char i,lcdteks[20];
char KeyChar,Addr=0,PPoolingSetting[6];
     Result=MENU_NONE;

     switch(stPumpPooling){
    df1c:	80 91 df 02 	lds	r24, 0x02DF
    df20:	82 30       	cpi	r24, 0x02	; 2
    df22:	09 f4       	brne	.+2      	; 0xdf26 <FSettingPumpPooling+0x22>
    df24:	1b c1       	rjmp	.+566    	; 0xe15c <FSettingPumpPooling+0x258>
    df26:	83 30       	cpi	r24, 0x03	; 3
    df28:	30 f4       	brcc	.+12     	; 0xdf36 <FSettingPumpPooling+0x32>
    df2a:	88 23       	and	r24, r24
    df2c:	59 f0       	breq	.+22     	; 0xdf44 <FSettingPumpPooling+0x40>
    df2e:	81 30       	cpi	r24, 0x01	; 1
    df30:	09 f0       	breq	.+2      	; 0xdf34 <FSettingPumpPooling+0x30>
    df32:	1b c2       	rjmp	.+1078   	; 0xe36a <FSettingPumpPooling+0x466>
    df34:	09 c1       	rjmp	.+530    	; 0xe148 <FSettingPumpPooling+0x244>
    df36:	83 30       	cpi	r24, 0x03	; 3
    df38:	09 f4       	brne	.+2      	; 0xdf3c <FSettingPumpPooling+0x38>
    df3a:	06 c2       	rjmp	.+1036   	; 0xe348 <FSettingPumpPooling+0x444>
    df3c:	84 30       	cpi	r24, 0x04	; 4
    df3e:	09 f0       	breq	.+2      	; 0xdf42 <FSettingPumpPooling+0x3e>
    df40:	14 c2       	rjmp	.+1064   	; 0xe36a <FSettingPumpPooling+0x466>
    df42:	0f c2       	rjmp	.+1054   	; 0xe362 <FSettingPumpPooling+0x45e>
	 case ppInitMenu:
          lcd_clear();
    df44:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
    df48:	20 e0       	ldi	r18, 0x00	; 0
    df4a:	30 e0       	ldi	r19, 0x00	; 0
		  for (i=0;i<6;i++){
		      PPoolingSetting[i]=eeprom_read_byte(&DefPoolingPumpMax+i);
    df4c:	ae 01       	movw	r20, r28
    df4e:	4f 5f       	subi	r20, 0xFF	; 255
    df50:	5f 4f       	sbci	r21, 0xFF	; 255
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    df52:	e1 99       	sbic	0x1c, 1	; 28
    df54:	fe cf       	rjmp	.-4      	; 0xdf52 <FSettingPumpPooling+0x4e>
    df56:	c9 01       	movw	r24, r18
    df58:	8c 5b       	subi	r24, 0xBC	; 188
    df5a:	9e 4f       	sbci	r25, 0xFE	; 254
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    df5c:	9f bb       	out	0x1f, r25	; 31
    df5e:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    df60:	e0 9a       	sbi	0x1c, 0	; 28
    df62:	8d b3       	in	r24, 0x1d	; 29
    df64:	fa 01       	movw	r30, r20
    df66:	e2 0f       	add	r30, r18
    df68:	f3 1f       	adc	r31, r19
    df6a:	80 83       	st	Z, r24
    df6c:	2f 5f       	subi	r18, 0xFF	; 255
    df6e:	3f 4f       	sbci	r19, 0xFF	; 255
     Result=MENU_NONE;

     switch(stPumpPooling){
	 case ppInitMenu:
          lcd_clear();
		  for (i=0;i<6;i++){
    df70:	26 30       	cpi	r18, 0x06	; 6
    df72:	31 05       	cpc	r19, r1
    df74:	71 f7       	brne	.-36     	; 0xdf52 <FSettingPumpPooling+0x4e>
		      PPoolingSetting[i]=eeprom_read_byte(&DefPoolingPumpMax+i);
		  }

		  sprintf_P(lcdteks,PSTR("1.MaxPump:%d"),PPoolingSetting[0]);lcd_print(1,1,lcdteks);
    df76:	00 d0       	rcall	.+0      	; 0xdf78 <FSettingPumpPooling+0x74>
    df78:	00 d0       	rcall	.+0      	; 0xdf7a <FSettingPumpPooling+0x76>
    df7a:	00 d0       	rcall	.+0      	; 0xdf7c <FSettingPumpPooling+0x78>
    df7c:	ed b7       	in	r30, 0x3d	; 61
    df7e:	fe b7       	in	r31, 0x3e	; 62
    df80:	31 96       	adiw	r30, 0x01	; 1
    df82:	8e 01       	movw	r16, r28
    df84:	09 5f       	subi	r16, 0xF9	; 249
    df86:	1f 4f       	sbci	r17, 0xFF	; 255
    df88:	ad b7       	in	r26, 0x3d	; 61
    df8a:	be b7       	in	r27, 0x3e	; 62
    df8c:	12 96       	adiw	r26, 0x02	; 2
    df8e:	1c 93       	st	X, r17
    df90:	0e 93       	st	-X, r16
    df92:	11 97       	sbiw	r26, 0x01	; 1
    df94:	83 ea       	ldi	r24, 0xA3	; 163
    df96:	9d e0       	ldi	r25, 0x0D	; 13
    df98:	93 83       	std	Z+3, r25	; 0x03
    df9a:	82 83       	std	Z+2, r24	; 0x02
    df9c:	89 81       	ldd	r24, Y+1	; 0x01
    df9e:	84 83       	std	Z+4, r24	; 0x04
    dfa0:	15 82       	std	Z+5, r1	; 0x05
    dfa2:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    dfa6:	ed b7       	in	r30, 0x3d	; 61
    dfa8:	fe b7       	in	r31, 0x3e	; 62
    dfaa:	36 96       	adiw	r30, 0x06	; 6
    dfac:	0f b6       	in	r0, 0x3f	; 63
    dfae:	f8 94       	cli
    dfb0:	fe bf       	out	0x3e, r31	; 62
    dfb2:	0f be       	out	0x3f, r0	; 63
    dfb4:	ed bf       	out	0x3d, r30	; 61
    dfb6:	81 e0       	ldi	r24, 0x01	; 1
    dfb8:	61 e0       	ldi	r22, 0x01	; 1
    dfba:	a8 01       	movw	r20, r16
    dfbc:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
          sprintf_P(lcdteks,PSTR("2.nNoPump:%d"),PPoolingSetting[1]);lcd_print(2,1,lcdteks);
    dfc0:	00 d0       	rcall	.+0      	; 0xdfc2 <FSettingPumpPooling+0xbe>
    dfc2:	00 d0       	rcall	.+0      	; 0xdfc4 <FSettingPumpPooling+0xc0>
    dfc4:	00 d0       	rcall	.+0      	; 0xdfc6 <FSettingPumpPooling+0xc2>
    dfc6:	ed b7       	in	r30, 0x3d	; 61
    dfc8:	fe b7       	in	r31, 0x3e	; 62
    dfca:	31 96       	adiw	r30, 0x01	; 1
    dfcc:	ad b7       	in	r26, 0x3d	; 61
    dfce:	be b7       	in	r27, 0x3e	; 62
    dfd0:	12 96       	adiw	r26, 0x02	; 2
    dfd2:	1c 93       	st	X, r17
    dfd4:	0e 93       	st	-X, r16
    dfd6:	11 97       	sbiw	r26, 0x01	; 1
    dfd8:	86 e9       	ldi	r24, 0x96	; 150
    dfda:	9d e0       	ldi	r25, 0x0D	; 13
    dfdc:	93 83       	std	Z+3, r25	; 0x03
    dfde:	82 83       	std	Z+2, r24	; 0x02
    dfe0:	8a 81       	ldd	r24, Y+2	; 0x02
    dfe2:	84 83       	std	Z+4, r24	; 0x04
    dfe4:	15 82       	std	Z+5, r1	; 0x05
    dfe6:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    dfea:	ed b7       	in	r30, 0x3d	; 61
    dfec:	fe b7       	in	r31, 0x3e	; 62
    dfee:	36 96       	adiw	r30, 0x06	; 6
    dff0:	0f b6       	in	r0, 0x3f	; 63
    dff2:	f8 94       	cli
    dff4:	fe bf       	out	0x3e, r31	; 62
    dff6:	0f be       	out	0x3f, r0	; 63
    dff8:	ed bf       	out	0x3d, r30	; 61
    dffa:	82 e0       	ldi	r24, 0x02	; 2
    dffc:	61 e0       	ldi	r22, 0x01	; 1
    dffe:	a8 01       	movw	r20, r16
    e000:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
          sprintf_P(lcdteks,PSTR("3.TrySend:%d"),PPoolingSetting[2]);lcd_print(3,1,lcdteks);
    e004:	00 d0       	rcall	.+0      	; 0xe006 <FSettingPumpPooling+0x102>
    e006:	00 d0       	rcall	.+0      	; 0xe008 <FSettingPumpPooling+0x104>
    e008:	00 d0       	rcall	.+0      	; 0xe00a <FSettingPumpPooling+0x106>
    e00a:	ed b7       	in	r30, 0x3d	; 61
    e00c:	fe b7       	in	r31, 0x3e	; 62
    e00e:	31 96       	adiw	r30, 0x01	; 1
    e010:	ad b7       	in	r26, 0x3d	; 61
    e012:	be b7       	in	r27, 0x3e	; 62
    e014:	12 96       	adiw	r26, 0x02	; 2
    e016:	1c 93       	st	X, r17
    e018:	0e 93       	st	-X, r16
    e01a:	11 97       	sbiw	r26, 0x01	; 1
    e01c:	89 e8       	ldi	r24, 0x89	; 137
    e01e:	9d e0       	ldi	r25, 0x0D	; 13
    e020:	93 83       	std	Z+3, r25	; 0x03
    e022:	82 83       	std	Z+2, r24	; 0x02
    e024:	8b 81       	ldd	r24, Y+3	; 0x03
    e026:	84 83       	std	Z+4, r24	; 0x04
    e028:	15 82       	std	Z+5, r1	; 0x05
    e02a:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    e02e:	ed b7       	in	r30, 0x3d	; 61
    e030:	fe b7       	in	r31, 0x3e	; 62
    e032:	36 96       	adiw	r30, 0x06	; 6
    e034:	0f b6       	in	r0, 0x3f	; 63
    e036:	f8 94       	cli
    e038:	fe bf       	out	0x3e, r31	; 62
    e03a:	0f be       	out	0x3f, r0	; 63
    e03c:	ed bf       	out	0x3d, r30	; 61
    e03e:	83 e0       	ldi	r24, 0x03	; 3
    e040:	61 e0       	ldi	r22, 0x01	; 1
    e042:	a8 01       	movw	r20, r16
    e044:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
          sprintf_P(lcdteks,PSTR("4.TimPool:%d"),PPoolingSetting[3]);lcd_print(4,1,lcdteks);
    e048:	00 d0       	rcall	.+0      	; 0xe04a <FSettingPumpPooling+0x146>
    e04a:	00 d0       	rcall	.+0      	; 0xe04c <FSettingPumpPooling+0x148>
    e04c:	00 d0       	rcall	.+0      	; 0xe04e <FSettingPumpPooling+0x14a>
    e04e:	ed b7       	in	r30, 0x3d	; 61
    e050:	fe b7       	in	r31, 0x3e	; 62
    e052:	31 96       	adiw	r30, 0x01	; 1
    e054:	ad b7       	in	r26, 0x3d	; 61
    e056:	be b7       	in	r27, 0x3e	; 62
    e058:	12 96       	adiw	r26, 0x02	; 2
    e05a:	1c 93       	st	X, r17
    e05c:	0e 93       	st	-X, r16
    e05e:	11 97       	sbiw	r26, 0x01	; 1
    e060:	8c e7       	ldi	r24, 0x7C	; 124
    e062:	9d e0       	ldi	r25, 0x0D	; 13
    e064:	93 83       	std	Z+3, r25	; 0x03
    e066:	82 83       	std	Z+2, r24	; 0x02
    e068:	8c 81       	ldd	r24, Y+4	; 0x04
    e06a:	84 83       	std	Z+4, r24	; 0x04
    e06c:	15 82       	std	Z+5, r1	; 0x05
    e06e:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    e072:	ed b7       	in	r30, 0x3d	; 61
    e074:	fe b7       	in	r31, 0x3e	; 62
    e076:	36 96       	adiw	r30, 0x06	; 6
    e078:	0f b6       	in	r0, 0x3f	; 63
    e07a:	f8 94       	cli
    e07c:	fe bf       	out	0x3e, r31	; 62
    e07e:	0f be       	out	0x3f, r0	; 63
    e080:	ed bf       	out	0x3d, r30	; 61
    e082:	84 e0       	ldi	r24, 0x04	; 4
    e084:	61 e0       	ldi	r22, 0x01	; 1
    e086:	a8 01       	movw	r20, r16
    e088:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
          sprintf_P(lcdteks,PSTR("5.Dly:%d"),PPoolingSetting[4]);lcd_print(1,13,lcdteks);
    e08c:	00 d0       	rcall	.+0      	; 0xe08e <FSettingPumpPooling+0x18a>
    e08e:	00 d0       	rcall	.+0      	; 0xe090 <FSettingPumpPooling+0x18c>
    e090:	00 d0       	rcall	.+0      	; 0xe092 <FSettingPumpPooling+0x18e>
    e092:	ed b7       	in	r30, 0x3d	; 61
    e094:	fe b7       	in	r31, 0x3e	; 62
    e096:	31 96       	adiw	r30, 0x01	; 1
    e098:	ad b7       	in	r26, 0x3d	; 61
    e09a:	be b7       	in	r27, 0x3e	; 62
    e09c:	12 96       	adiw	r26, 0x02	; 2
    e09e:	1c 93       	st	X, r17
    e0a0:	0e 93       	st	-X, r16
    e0a2:	11 97       	sbiw	r26, 0x01	; 1
    e0a4:	83 e7       	ldi	r24, 0x73	; 115
    e0a6:	9d e0       	ldi	r25, 0x0D	; 13
    e0a8:	93 83       	std	Z+3, r25	; 0x03
    e0aa:	82 83       	std	Z+2, r24	; 0x02
    e0ac:	8d 81       	ldd	r24, Y+5	; 0x05
    e0ae:	84 83       	std	Z+4, r24	; 0x04
    e0b0:	15 82       	std	Z+5, r1	; 0x05
    e0b2:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    e0b6:	ed b7       	in	r30, 0x3d	; 61
    e0b8:	fe b7       	in	r31, 0x3e	; 62
    e0ba:	36 96       	adiw	r30, 0x06	; 6
    e0bc:	0f b6       	in	r0, 0x3f	; 63
    e0be:	f8 94       	cli
    e0c0:	fe bf       	out	0x3e, r31	; 62
    e0c2:	0f be       	out	0x3f, r0	; 63
    e0c4:	ed bf       	out	0x3d, r30	; 61
    e0c6:	81 e0       	ldi	r24, 0x01	; 1
    e0c8:	6d e0       	ldi	r22, 0x0D	; 13
    e0ca:	a8 01       	movw	r20, r16
    e0cc:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
          sprintf_P(lcdteks,PSTR("6.Act:%d"),PPoolingSetting[5]);lcd_print(2,13,lcdteks);
    e0d0:	00 d0       	rcall	.+0      	; 0xe0d2 <FSettingPumpPooling+0x1ce>
    e0d2:	00 d0       	rcall	.+0      	; 0xe0d4 <FSettingPumpPooling+0x1d0>
    e0d4:	00 d0       	rcall	.+0      	; 0xe0d6 <FSettingPumpPooling+0x1d2>
    e0d6:	ed b7       	in	r30, 0x3d	; 61
    e0d8:	fe b7       	in	r31, 0x3e	; 62
    e0da:	31 96       	adiw	r30, 0x01	; 1
    e0dc:	ad b7       	in	r26, 0x3d	; 61
    e0de:	be b7       	in	r27, 0x3e	; 62
    e0e0:	12 96       	adiw	r26, 0x02	; 2
    e0e2:	1c 93       	st	X, r17
    e0e4:	0e 93       	st	-X, r16
    e0e6:	11 97       	sbiw	r26, 0x01	; 1
    e0e8:	8a e6       	ldi	r24, 0x6A	; 106
    e0ea:	9d e0       	ldi	r25, 0x0D	; 13
    e0ec:	93 83       	std	Z+3, r25	; 0x03
    e0ee:	82 83       	std	Z+2, r24	; 0x02
    e0f0:	8e 81       	ldd	r24, Y+6	; 0x06
    e0f2:	84 83       	std	Z+4, r24	; 0x04
    e0f4:	15 82       	std	Z+5, r1	; 0x05
    e0f6:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    e0fa:	ed b7       	in	r30, 0x3d	; 61
    e0fc:	fe b7       	in	r31, 0x3e	; 62
    e0fe:	36 96       	adiw	r30, 0x06	; 6
    e100:	0f b6       	in	r0, 0x3f	; 63
    e102:	f8 94       	cli
    e104:	fe bf       	out	0x3e, r31	; 62
    e106:	0f be       	out	0x3f, r0	; 63
    e108:	ed bf       	out	0x3d, r30	; 61
    e10a:	82 e0       	ldi	r24, 0x02	; 2
    e10c:	6d e0       	ldi	r22, 0x0D	; 13
    e10e:	a8 01       	movw	r20, r16
    e110:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
          sprintf_P(lcdteks,PSTR("[*]Exit"));lcd_print(4,13,lcdteks);
    e114:	00 d0       	rcall	.+0      	; 0xe116 <FSettingPumpPooling+0x212>
    e116:	00 d0       	rcall	.+0      	; 0xe118 <FSettingPumpPooling+0x214>
    e118:	ad b7       	in	r26, 0x3d	; 61
    e11a:	be b7       	in	r27, 0x3e	; 62
    e11c:	12 96       	adiw	r26, 0x02	; 2
    e11e:	1c 93       	st	X, r17
    e120:	0e 93       	st	-X, r16
    e122:	11 97       	sbiw	r26, 0x01	; 1
    e124:	82 e6       	ldi	r24, 0x62	; 98
    e126:	9d e0       	ldi	r25, 0x0D	; 13
    e128:	14 96       	adiw	r26, 0x04	; 4
    e12a:	9c 93       	st	X, r25
    e12c:	8e 93       	st	-X, r24
    e12e:	13 97       	sbiw	r26, 0x03	; 3
    e130:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    e134:	0f 90       	pop	r0
    e136:	0f 90       	pop	r0
    e138:	0f 90       	pop	r0
    e13a:	0f 90       	pop	r0
    e13c:	84 e0       	ldi	r24, 0x04	; 4
    e13e:	6d e0       	ldi	r22, 0x0D	; 13
    e140:	a8 01       	movw	r20, r16
    e142:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
    e146:	08 c0       	rjmp	.+16     	; 0xe158 <FSettingPumpPooling+0x254>

          stPumpPooling=ppPoolingSettingInput;
	      break;
     case ppDisplaySequence:
          IsNewPoolingSequence=False;
    e148:	10 92 94 01 	sts	0x0194, r1
		  DisplayStandaloneSequence(3,14,iSequencePooling);
    e14c:	83 e0       	ldi	r24, 0x03	; 3
    e14e:	6e e0       	ldi	r22, 0x0E	; 14
    e150:	40 91 93 01 	lds	r20, 0x0193
    e154:	0e 94 4c 6f 	call	0xde98	; 0xde98 <DisplayStandaloneSequence>
          stPumpPooling=ppPoolingSettingInput;
    e158:	82 e0       	ldi	r24, 0x02	; 2
    e15a:	f3 c0       	rjmp	.+486    	; 0xe342 <FSettingPumpPooling+0x43e>
	      break;
     case ppPoolingSettingInput:
	      if(IsNewPoolingSequence==True)stPumpPooling=ppDisplaySequence;
    e15c:	80 91 94 01 	lds	r24, 0x0194
    e160:	81 30       	cpi	r24, 0x01	; 1
    e162:	11 f4       	brne	.+4      	; 0xe168 <FSettingPumpPooling+0x264>
    e164:	80 93 df 02 	sts	0x02DF, r24

          KeyChar=_key_btn(_key_scan(1));
    e168:	81 e0       	ldi	r24, 0x01	; 1
    e16a:	0e 94 06 b0 	call	0x1600c	; 0x1600c <_key_scan>
    e16e:	0e 94 67 af 	call	0x15ece	; 0x15ece <_key_btn>
		  if ((KeyChar>='1')&&(KeyChar<='6')){
    e172:	48 2f       	mov	r20, r24
    e174:	41 53       	subi	r20, 0x31	; 49
    e176:	46 30       	cpi	r20, 0x06	; 6
    e178:	10 f0       	brcs	.+4      	; 0xe17e <FSettingPumpPooling+0x27a>
    e17a:	40 e0       	ldi	r20, 0x00	; 0
    e17c:	06 c0       	rjmp	.+12     	; 0xe18a <FSettingPumpPooling+0x286>
		      Addr=KeyChar-'1';
			  TimSend=0;
    e17e:	10 92 a9 01 	sts	0x01A9, r1
    e182:	10 92 a8 01 	sts	0x01A8, r1
			  IsStandaloneAcknoledge=False;
    e186:	10 92 95 01 	sts	0x0195, r1
          }
		  switch(KeyChar){
    e18a:	83 33       	cpi	r24, 0x33	; 51
    e18c:	09 f4       	brne	.+2      	; 0xe190 <FSettingPumpPooling+0x28c>
    e18e:	67 c0       	rjmp	.+206    	; 0xe25e <FSettingPumpPooling+0x35a>
    e190:	84 33       	cpi	r24, 0x34	; 52
    e192:	48 f4       	brcc	.+18     	; 0xe1a6 <FSettingPumpPooling+0x2a2>
    e194:	81 33       	cpi	r24, 0x31	; 49
    e196:	89 f0       	breq	.+34     	; 0xe1ba <FSettingPumpPooling+0x2b6>
    e198:	82 33       	cpi	r24, 0x32	; 50
    e19a:	08 f0       	brcs	.+2      	; 0xe19e <FSettingPumpPooling+0x29a>
    e19c:	3d c0       	rjmp	.+122    	; 0xe218 <FSettingPumpPooling+0x314>
    e19e:	8a 32       	cpi	r24, 0x2A	; 42
    e1a0:	09 f0       	breq	.+2      	; 0xe1a4 <FSettingPumpPooling+0x2a0>
    e1a2:	e3 c0       	rjmp	.+454    	; 0xe36a <FSettingPumpPooling+0x466>
    e1a4:	cd c0       	rjmp	.+410    	; 0xe340 <FSettingPumpPooling+0x43c>
    e1a6:	85 33       	cpi	r24, 0x35	; 53
    e1a8:	09 f4       	brne	.+2      	; 0xe1ac <FSettingPumpPooling+0x2a8>
    e1aa:	91 c0       	rjmp	.+290    	; 0xe2ce <FSettingPumpPooling+0x3ca>
    e1ac:	85 33       	cpi	r24, 0x35	; 53
    e1ae:	08 f4       	brcc	.+2      	; 0xe1b2 <FSettingPumpPooling+0x2ae>
    e1b0:	78 c0       	rjmp	.+240    	; 0xe2a2 <FSettingPumpPooling+0x39e>
    e1b2:	86 33       	cpi	r24, 0x36	; 54
    e1b4:	09 f0       	breq	.+2      	; 0xe1b8 <FSettingPumpPooling+0x2b4>
    e1b6:	d9 c0       	rjmp	.+434    	; 0xe36a <FSettingPumpPooling+0x466>
    e1b8:	a0 c0       	rjmp	.+320    	; 0xe2fa <FSettingPumpPooling+0x3f6>
		  case '1'://MaxPump
		       PPoolingSetting[Addr]=((PPoolingSetting[Addr]+1)%17);
    e1ba:	24 2f       	mov	r18, r20
    e1bc:	30 e0       	ldi	r19, 0x00	; 0
    e1be:	fe 01       	movw	r30, r28
    e1c0:	31 96       	adiw	r30, 0x01	; 1
    e1c2:	e2 0f       	add	r30, r18
    e1c4:	f3 1f       	adc	r31, r19
    e1c6:	80 81       	ld	r24, Z
    e1c8:	90 e0       	ldi	r25, 0x00	; 0
    e1ca:	01 96       	adiw	r24, 0x01	; 1
    e1cc:	61 e1       	ldi	r22, 0x11	; 17
    e1ce:	70 e0       	ldi	r23, 0x00	; 0
    e1d0:	0e 94 a7 b8 	call	0x1714e	; 0x1714e <__divmodhi4>
    e1d4:	80 83       	st	Z, r24
			   if (PPoolingSetting[Addr]==0)PPoolingSetting[Addr]=1;
    e1d6:	88 23       	and	r24, r24
    e1d8:	11 f4       	brne	.+4      	; 0xe1de <FSettingPumpPooling+0x2da>
    e1da:	81 e0       	ldi	r24, 0x01	; 1
    e1dc:	80 83       	st	Z, r24
			   //SendSlaveCommand(SC_SET_POOLING_MAX_PUMP,PPoolingSetting[Addr]);
			   SendPoolingCommand(SC_SET_POOLING_MAX_PUMP,PPoolingSetting[Addr]);
    e1de:	2c 0f       	add	r18, r28
    e1e0:	3d 1f       	adc	r19, r29
    e1e2:	f9 01       	movw	r30, r18
    e1e4:	21 81       	ldd	r18, Z+1	; 0x01
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    e1e6:	85 e1       	ldi	r24, 0x15	; 21
    e1e8:	80 93 8a 07 	sts	0x078A, r24
	 PoolMsg=plMsg;
    e1ec:	20 93 ae 0d 	sts	0x0DAE, r18
     IsControlPooling=True;
    e1f0:	81 e0       	ldi	r24, 0x01	; 1
    e1f2:	80 93 97 01 	sts	0x0197, r24
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    e1f6:	e1 99       	sbic	0x1c, 1	; 28
    e1f8:	fe cf       	rjmp	.-4      	; 0xe1f6 <FSettingPumpPooling+0x2f2>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    e1fa:	84 2f       	mov	r24, r20
    e1fc:	90 e0       	ldi	r25, 0x00	; 0
    e1fe:	8c 5b       	subi	r24, 0xBC	; 188
    e200:	9e 4f       	sbci	r25, 0xFE	; 254
    e202:	9f bb       	out	0x1f, r25	; 31
    e204:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    e206:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
    e208:	0f b6       	in	r0, 0x3f	; 63
    e20a:	f8 94       	cli
    e20c:	e2 9a       	sbi	0x1c, 2	; 28
    e20e:	e1 9a       	sbi	0x1c, 1	; 28
    e210:	0f be       	out	0x3f, r0	; 63
			   if (PPoolingSetting[Addr]==0)PPoolingSetting[Addr]=1;
			   //SendSlaveCommand(SC_SET_POOLING_MAX_PUMP,PPoolingSetting[Addr]);
			   SendPoolingCommand(SC_SET_POOLING_MAX_PUMP,PPoolingSetting[Addr]);

			   eeprom_write_byte(&DefPoolingPumpMax+Addr,PPoolingSetting[Addr]);
			   PumpCountMax=PPoolingSetting[Addr];
    e212:	20 93 5f 01 	sts	0x015F, r18
    e216:	21 c0       	rjmp	.+66     	; 0xe25a <FSettingPumpPooling+0x356>
			   //stPumpPooling=ppInitMenu;
			   stPumpPooling=ppWaitPoolingRespond;
		       break;
		  case '2'://NoPump
		       PPoolingSetting[Addr]=((PPoolingSetting[Addr]+1)%21);
    e218:	fe 01       	movw	r30, r28
    e21a:	e4 0f       	add	r30, r20
    e21c:	f1 1d       	adc	r31, r1
    e21e:	81 81       	ldd	r24, Z+1	; 0x01
    e220:	90 e0       	ldi	r25, 0x00	; 0
    e222:	01 96       	adiw	r24, 0x01	; 1
    e224:	65 e1       	ldi	r22, 0x15	; 21
    e226:	70 e0       	ldi	r23, 0x00	; 0
    e228:	0e 94 a7 b8 	call	0x1714e	; 0x1714e <__divmodhi4>
    e22c:	28 2f       	mov	r18, r24
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    e22e:	84 e1       	ldi	r24, 0x14	; 20
    e230:	80 93 8a 07 	sts	0x078A, r24
	 PoolMsg=plMsg;
    e234:	20 93 ae 0d 	sts	0x0DAE, r18
     IsControlPooling=True;
    e238:	81 e0       	ldi	r24, 0x01	; 1
    e23a:	80 93 97 01 	sts	0x0197, r24
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    e23e:	e1 99       	sbic	0x1c, 1	; 28
    e240:	fe cf       	rjmp	.-4      	; 0xe23e <FSettingPumpPooling+0x33a>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    e242:	84 2f       	mov	r24, r20
    e244:	90 e0       	ldi	r25, 0x00	; 0
    e246:	8c 5b       	subi	r24, 0xBC	; 188
    e248:	9e 4f       	sbci	r25, 0xFE	; 254
    e24a:	9f bb       	out	0x1f, r25	; 31
    e24c:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    e24e:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
    e250:	0f b6       	in	r0, 0x3f	; 63
    e252:	f8 94       	cli
    e254:	e2 9a       	sbi	0x1c, 2	; 28
    e256:	e1 9a       	sbi	0x1c, 1	; 28
    e258:	0f be       	out	0x3f, r0	; 63
			   //SendSlaveCommand(SC_SET_POOLING_NO_PUMP_COUNT,PPoolingSetting[Addr]);
			   SendPoolingCommand(SC_SET_POOLING_NO_PUMP_COUNT,PPoolingSetting[Addr]);

			   eeprom_write_byte(&DefPoolingPumpMax+Addr,PPoolingSetting[Addr]);
			   //stPumpPooling=ppInitMenu;
			   stPumpPooling=ppWaitPoolingRespond;
    e25a:	83 e0       	ldi	r24, 0x03	; 3
    e25c:	72 c0       	rjmp	.+228    	; 0xe342 <FSettingPumpPooling+0x43e>
		       break;
		  case '3'://TrySend
		       PPoolingSetting[Addr]=((PPoolingSetting[Addr]+1)%21);
    e25e:	24 2f       	mov	r18, r20
    e260:	30 e0       	ldi	r19, 0x00	; 0
    e262:	fe 01       	movw	r30, r28
    e264:	31 96       	adiw	r30, 0x01	; 1
    e266:	e2 0f       	add	r30, r18
    e268:	f3 1f       	adc	r31, r19
    e26a:	80 81       	ld	r24, Z
    e26c:	90 e0       	ldi	r25, 0x00	; 0
    e26e:	01 96       	adiw	r24, 0x01	; 1
    e270:	65 e1       	ldi	r22, 0x15	; 21
    e272:	70 e0       	ldi	r23, 0x00	; 0
    e274:	0e 94 a7 b8 	call	0x1714e	; 0x1714e <__divmodhi4>
    e278:	80 83       	st	Z, r24
			   if (PPoolingSetting[Addr]==0)PPoolingSetting[Addr]=1;
    e27a:	88 23       	and	r24, r24
    e27c:	11 f4       	brne	.+4      	; 0xe282 <FSettingPumpPooling+0x37e>
    e27e:	81 e0       	ldi	r24, 0x01	; 1
    e280:	80 83       	st	Z, r24
			   //SendSlaveCommand(SC_SET_POOLING_SEND,PPoolingSetting[Addr]);
			   SendPoolingCommand(SC_SET_POOLING_SEND,PPoolingSetting[Addr]);
    e282:	2c 0f       	add	r18, r28
    e284:	3d 1f       	adc	r19, r29
    e286:	d9 01       	movw	r26, r18
    e288:	11 96       	adiw	r26, 0x01	; 1
    e28a:	2c 91       	ld	r18, X
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    e28c:	86 e1       	ldi	r24, 0x16	; 22
    e28e:	80 93 8a 07 	sts	0x078A, r24
	 PoolMsg=plMsg;
    e292:	20 93 ae 0d 	sts	0x0DAE, r18
     IsControlPooling=True;
    e296:	81 e0       	ldi	r24, 0x01	; 1
    e298:	80 93 97 01 	sts	0x0197, r24
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    e29c:	e1 99       	sbic	0x1c, 1	; 28
    e29e:	fe cf       	rjmp	.-4      	; 0xe29c <FSettingPumpPooling+0x398>
    e2a0:	d0 cf       	rjmp	.-96     	; 0xe242 <FSettingPumpPooling+0x33e>
			   eeprom_write_byte(&DefPoolingPumpMax+Addr,PPoolingSetting[Addr]);
			   //stPumpPooling=ppInitMenu;
			   stPumpPooling=ppWaitPoolingRespond;
		       break;
		  case '4'://TimPool
		       PPoolingSetting[Addr]=((PPoolingSetting[Addr]+1)%21);
    e2a2:	fe 01       	movw	r30, r28
    e2a4:	e4 0f       	add	r30, r20
    e2a6:	f1 1d       	adc	r31, r1
    e2a8:	81 81       	ldd	r24, Z+1	; 0x01
    e2aa:	90 e0       	ldi	r25, 0x00	; 0
    e2ac:	01 96       	adiw	r24, 0x01	; 1
    e2ae:	65 e1       	ldi	r22, 0x15	; 21
    e2b0:	70 e0       	ldi	r23, 0x00	; 0
    e2b2:	0e 94 a7 b8 	call	0x1714e	; 0x1714e <__divmodhi4>
    e2b6:	28 2f       	mov	r18, r24
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    e2b8:	87 e1       	ldi	r24, 0x17	; 23
    e2ba:	80 93 8a 07 	sts	0x078A, r24
	 PoolMsg=plMsg;
    e2be:	20 93 ae 0d 	sts	0x0DAE, r18
     IsControlPooling=True;
    e2c2:	81 e0       	ldi	r24, 0x01	; 1
    e2c4:	80 93 97 01 	sts	0x0197, r24
    e2c8:	e1 99       	sbic	0x1c, 1	; 28
    e2ca:	fe cf       	rjmp	.-4      	; 0xe2c8 <FSettingPumpPooling+0x3c4>
    e2cc:	ba cf       	rjmp	.-140    	; 0xe242 <FSettingPumpPooling+0x33e>
			   eeprom_write_byte(&DefPoolingPumpMax+Addr,PPoolingSetting[Addr]);
			   //stPumpPooling=ppInitMenu;
			   stPumpPooling=ppWaitPoolingRespond;
		       break;
		  case '5'://DelayNextPump
		       PPoolingSetting[Addr]=((PPoolingSetting[Addr]+1)%41); 
    e2ce:	fe 01       	movw	r30, r28
    e2d0:	e4 0f       	add	r30, r20
    e2d2:	f1 1d       	adc	r31, r1
    e2d4:	81 81       	ldd	r24, Z+1	; 0x01
    e2d6:	90 e0       	ldi	r25, 0x00	; 0
    e2d8:	01 96       	adiw	r24, 0x01	; 1
    e2da:	69 e2       	ldi	r22, 0x29	; 41
    e2dc:	70 e0       	ldi	r23, 0x00	; 0
    e2de:	0e 94 a7 b8 	call	0x1714e	; 0x1714e <__divmodhi4>
    e2e2:	28 2f       	mov	r18, r24
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    e2e4:	88 e1       	ldi	r24, 0x18	; 24
    e2e6:	80 93 8a 07 	sts	0x078A, r24
	 PoolMsg=plMsg;
    e2ea:	20 93 ae 0d 	sts	0x0DAE, r18
     IsControlPooling=True;
    e2ee:	81 e0       	ldi	r24, 0x01	; 1
    e2f0:	80 93 97 01 	sts	0x0197, r24
    e2f4:	e1 99       	sbic	0x1c, 1	; 28
    e2f6:	fe cf       	rjmp	.-4      	; 0xe2f4 <FSettingPumpPooling+0x3f0>
    e2f8:	a4 cf       	rjmp	.-184    	; 0xe242 <FSettingPumpPooling+0x33e>
			   eeprom_write_byte(&DefPoolingPumpMax+Addr,PPoolingSetting[Addr]);
			   //stPumpPooling=ppInitMenu;
               stPumpPooling=ppWaitPoolingRespond;
		       break;
		  case '6'://ActivePump
		       PPoolingSetting[Addr]=((PPoolingSetting[Addr]+1)%(1+eeprom_read_byte(&DefPoolingPumpMax))); 			       
    e2fa:	fe 01       	movw	r30, r28
    e2fc:	e4 0f       	add	r30, r20
    e2fe:	f1 1d       	adc	r31, r1
    e300:	21 81       	ldd	r18, Z+1	; 0x01
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    e302:	e1 99       	sbic	0x1c, 1	; 28
    e304:	fe cf       	rjmp	.-4      	; 0xe302 <FSettingPumpPooling+0x3fe>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    e306:	84 e4       	ldi	r24, 0x44	; 68
    e308:	91 e0       	ldi	r25, 0x01	; 1
    e30a:	9f bb       	out	0x1f, r25	; 31
    e30c:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    e30e:	e0 9a       	sbi	0x1c, 0	; 28
    e310:	6d b3       	in	r22, 0x1d	; 29
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    e312:	e1 99       	sbic	0x1c, 1	; 28
    e314:	fe cf       	rjmp	.-4      	; 0xe312 <FSettingPumpPooling+0x40e>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    e316:	84 2f       	mov	r24, r20
    e318:	90 e0       	ldi	r25, 0x00	; 0
    e31a:	8c 5b       	subi	r24, 0xBC	; 188
    e31c:	9e 4f       	sbci	r25, 0xFE	; 254
    e31e:	9f bb       	out	0x1f, r25	; 31
    e320:	8e bb       	out	0x1e, r24	; 30
    e322:	82 2f       	mov	r24, r18
    e324:	90 e0       	ldi	r25, 0x00	; 0
    e326:	70 e0       	ldi	r23, 0x00	; 0
    e328:	6f 5f       	subi	r22, 0xFF	; 255
    e32a:	7f 4f       	sbci	r23, 0xFF	; 255
    e32c:	01 96       	adiw	r24, 0x01	; 1
    e32e:	0e 94 a7 b8 	call	0x1714e	; 0x1714e <__divmodhi4>
#endif
    EEDR = __value;
    e332:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    e334:	0f b6       	in	r0, 0x3f	; 63
    e336:	f8 94       	cli
    e338:	e2 9a       	sbi	0x1c, 2	; 28
    e33a:	e1 9a       	sbi	0x1c, 1	; 28
    e33c:	0f be       	out	0x3f, r0	; 63
    e33e:	0e c0       	rjmp	.+28     	; 0xe35c <FSettingPumpPooling+0x458>
			   eeprom_write_byte(&DefPoolingPumpMax+Addr,PPoolingSetting[Addr]);
			   stPumpPooling=ppInitMenu;
		       break;
		  case '*'://Exit
		       stPumpPooling=ppExitSettingPooling;		            
    e340:	84 e0       	ldi	r24, 0x04	; 4
    e342:	80 93 df 02 	sts	0x02DF, r24
    e346:	11 c0       	rjmp	.+34     	; 0xe36a <FSettingPumpPooling+0x466>
		       break;
		  }  
	      break;
     case ppWaitPoolingRespond:	    
	      if ((IsStandaloneAcknoledge==True)||(TimSend>5))stPumpPooling=ppInitMenu;
    e348:	80 91 95 01 	lds	r24, 0x0195
    e34c:	81 30       	cpi	r24, 0x01	; 1
    e34e:	31 f0       	breq	.+12     	; 0xe35c <FSettingPumpPooling+0x458>
    e350:	80 91 a8 01 	lds	r24, 0x01A8
    e354:	90 91 a9 01 	lds	r25, 0x01A9
    e358:	06 97       	sbiw	r24, 0x06	; 6
    e35a:	38 f0       	brcs	.+14     	; 0xe36a <FSettingPumpPooling+0x466>
    e35c:	10 92 df 02 	sts	0x02DF, r1
    e360:	04 c0       	rjmp	.+8      	; 0xe36a <FSettingPumpPooling+0x466>
	      break;
     case ppExitSettingPooling:
          stPumpPooling=ppInitMenu;
    e362:	10 92 df 02 	sts	0x02DF, r1
    e366:	81 e0       	ldi	r24, 0x01	; 1
    e368:	01 c0       	rjmp	.+2      	; 0xe36c <FSettingPumpPooling+0x468>
    e36a:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
    }
return Result;
}
    e36c:	6a 96       	adiw	r28, 0x1a	; 26
    e36e:	0f b6       	in	r0, 0x3f	; 63
    e370:	f8 94       	cli
    e372:	de bf       	out	0x3e, r29	; 62
    e374:	0f be       	out	0x3f, r0	; 63
    e376:	cd bf       	out	0x3d, r28	; 61
    e378:	cf 91       	pop	r28
    e37a:	df 91       	pop	r29
    e37c:	1f 91       	pop	r17
    e37e:	0f 91       	pop	r16
    e380:	08 95       	ret

0000e382 <DisplayTicker>:
	 lcd_print(2, 1, lcdteks);
}

void DisplayTicker(){
static char stDisplayTicker=tiRight;
	switch(stDisplayTicker){
    e382:	80 91 71 03 	lds	r24, 0x0371
    e386:	81 30       	cpi	r24, 0x01	; 1
    e388:	81 f0       	breq	.+32     	; 0xe3aa <DisplayTicker+0x28>
    e38a:	81 30       	cpi	r24, 0x01	; 1
    e38c:	28 f0       	brcs	.+10     	; 0xe398 <DisplayTicker+0x16>
    e38e:	82 30       	cpi	r24, 0x02	; 2
    e390:	91 f0       	breq	.+36     	; 0xe3b6 <DisplayTicker+0x34>
    e392:	83 30       	cpi	r24, 0x03	; 3
    e394:	09 f5       	brne	.+66     	; 0xe3d8 <DisplayTicker+0x56>
    e396:	1a c0       	rjmp	.+52     	; 0xe3cc <DisplayTicker+0x4a>
	case tiRight:
	     lcd_put(4, 1, '>');
    e398:	84 e0       	ldi	r24, 0x04	; 4
    e39a:	61 e0       	ldi	r22, 0x01	; 1
    e39c:	4e e3       	ldi	r20, 0x3E	; 62
    e39e:	0e 94 da ae 	call	0x15db4	; 0x15db4 <lcd_put>
		 TimTicker=0;
    e3a2:	10 92 a5 01 	sts	0x01A5, r1
         stDisplayTicker=tiDelayRight;
    e3a6:	81 e0       	ldi	r24, 0x01	; 1
    e3a8:	0e c0       	rjmp	.+28     	; 0xe3c6 <DisplayTicker+0x44>
	break;
	case tiDelayRight:
         if (TimTicker>TICKER_DELAY)stDisplayTicker=tiLeft;	     
    e3aa:	80 91 a5 01 	lds	r24, 0x01A5
    e3ae:	8b 30       	cpi	r24, 0x0B	; 11
    e3b0:	98 f0       	brcs	.+38     	; 0xe3d8 <DisplayTicker+0x56>
    e3b2:	82 e0       	ldi	r24, 0x02	; 2
    e3b4:	08 c0       	rjmp	.+16     	; 0xe3c6 <DisplayTicker+0x44>
	     break;
	case tiLeft:
	     lcd_put(4, 1, '<');
    e3b6:	84 e0       	ldi	r24, 0x04	; 4
    e3b8:	61 e0       	ldi	r22, 0x01	; 1
    e3ba:	4c e3       	ldi	r20, 0x3C	; 60
    e3bc:	0e 94 da ae 	call	0x15db4	; 0x15db4 <lcd_put>
         TimTicker=0;
    e3c0:	10 92 a5 01 	sts	0x01A5, r1
         stDisplayTicker=tiDelayLeft;
    e3c4:	83 e0       	ldi	r24, 0x03	; 3
    e3c6:	80 93 71 03 	sts	0x0371, r24
    e3ca:	08 95       	ret
	break;
	case tiDelayLeft:
         if (TimTicker>TICKER_DELAY)stDisplayTicker=tiRight;	     
    e3cc:	80 91 a5 01 	lds	r24, 0x01A5
    e3d0:	8b 30       	cpi	r24, 0x0B	; 11
    e3d2:	10 f0       	brcs	.+4      	; 0xe3d8 <DisplayTicker+0x56>
    e3d4:	10 92 71 03 	sts	0x0371, r1
    e3d8:	08 95       	ret

0000e3da <DisplayIdle>:
	          lcd_put(x,y,'X');     
			  }

}

void DisplayIdle(){
    e3da:	6f 92       	push	r6
    e3dc:	7f 92       	push	r7
    e3de:	8f 92       	push	r8
    e3e0:	9f 92       	push	r9
    e3e2:	af 92       	push	r10
    e3e4:	bf 92       	push	r11
    e3e6:	cf 92       	push	r12
    e3e8:	df 92       	push	r13
    e3ea:	ff 92       	push	r15
    e3ec:	0f 93       	push	r16
    e3ee:	1f 93       	push	r17
    e3f0:	df 93       	push	r29
    e3f2:	cf 93       	push	r28
    e3f4:	cd b7       	in	r28, 0x3d	; 61
    e3f6:	de b7       	in	r29, 0x3e	; 62
    e3f8:	67 97       	sbiw	r28, 0x17	; 23
    e3fa:	0f b6       	in	r0, 0x3f	; 63
    e3fc:	f8 94       	cli
    e3fe:	de bf       	out	0x3e, r29	; 62
    e400:	0f be       	out	0x3f, r0	; 63
    e402:	cd bf       	out	0x3d, r28	; 61
static unsigned int iLoopDisplayIdle=0;
static char stDispIdle=diScan;
     char i,iDisp;
     char lcdteks[20],sFIP[3];

     iLoopDisplayIdle++;
    e404:	80 91 6e 03 	lds	r24, 0x036E
    e408:	90 91 6f 03 	lds	r25, 0x036F
    e40c:	01 96       	adiw	r24, 0x01	; 1
    e40e:	90 93 6f 03 	sts	0x036F, r25
    e412:	80 93 6e 03 	sts	0x036E, r24
     //Setting DateTime ON

	if ((iLoopDisplayIdle%50)==0){
    e416:	62 e3       	ldi	r22, 0x32	; 50
    e418:	70 e0       	ldi	r23, 0x00	; 0
    e41a:	0e 94 93 b8 	call	0x17126	; 0x17126 <__udivmodhi4>
    e41e:	89 2b       	or	r24, r25
    e420:	29 f5       	brne	.+74     	; 0xe46c <DisplayIdle+0x92>
	   if (IFType==IT_STANDALONE)DisplayPumpStatus();
    e422:	80 91 10 01 	lds	r24, 0x0110
    e426:	82 30       	cpi	r24, 0x02	; 2
    e428:	11 f4       	brne	.+4      	; 0xe42e <DisplayIdle+0x54>
    e42a:	0e 94 4a 45 	call	0x8a94	; 0x8a94 <DisplayPumpStatus>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    e42e:	e1 99       	sbic	0x1c, 1	; 28
    e430:	fe cf       	rjmp	.-4      	; 0xe42e <DisplayIdle+0x54>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    e432:	87 e3       	ldi	r24, 0x37	; 55
    e434:	90 e0       	ldi	r25, 0x00	; 0
    e436:	9f bb       	out	0x1f, r25	; 31
    e438:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    e43a:	e0 9a       	sbi	0x1c, 0	; 28
    e43c:	8d b3       	in	r24, 0x1d	; 29
	   if(eeprom_read_byte(&DefShowDateTime)) DisplayDateTime();
    e43e:	88 23       	and	r24, r24
    e440:	19 f0       	breq	.+6      	; 0xe448 <DisplayIdle+0x6e>
    e442:	0e 94 fb 62 	call	0xc5f6	; 0xc5f6 <DisplayDateTime>
    e446:	02 c0       	rjmp	.+4      	; 0xe44c <DisplayIdle+0x72>
       else DisplayTicker();
    e448:	0e 94 c1 71 	call	0xe382	; 0xe382 <DisplayTicker>
	   //Display Standalone Sequnece
	   
	   if((IFType==IT_STANDALONE)&&(IsNewPoolingSequence==True)){
    e44c:	80 91 10 01 	lds	r24, 0x0110
    e450:	82 30       	cpi	r24, 0x02	; 2
    e452:	61 f4       	brne	.+24     	; 0xe46c <DisplayIdle+0x92>
    e454:	80 91 94 01 	lds	r24, 0x0194
    e458:	81 30       	cpi	r24, 0x01	; 1
    e45a:	41 f4       	brne	.+16     	; 0xe46c <DisplayIdle+0x92>
	       IsNewPoolingSequence=False;
    e45c:	10 92 94 01 	sts	0x0194, r1
		   DisplayStandaloneSequence(4,18,iSequencePooling);
    e460:	84 e0       	ldi	r24, 0x04	; 4
    e462:	62 e1       	ldi	r22, 0x12	; 18
    e464:	40 91 93 01 	lds	r20, 0x0193
    e468:	0e 94 4c 6f 	call	0xde98	; 0xde98 <DisplayStandaloneSequence>

	 }
     //DisplayPumpStatus Standalone Mode

	 //Display Printing FIP
	 switch (stDispIdle){
    e46c:	f0 90 6d 03 	lds	r15, 0x036D
    e470:	ff 20       	and	r15, r15
    e472:	29 f0       	breq	.+10     	; 0xe47e <DisplayIdle+0xa4>
    e474:	81 e0       	ldi	r24, 0x01	; 1
    e476:	f8 16       	cp	r15, r24
    e478:	09 f0       	breq	.+2      	; 0xe47c <DisplayIdle+0xa2>
    e47a:	58 c0       	rjmp	.+176    	; 0xe52c <DisplayIdle+0x152>
    e47c:	2f c0       	rjmp	.+94     	; 0xe4dc <DisplayIdle+0x102>
	 case diScan:
	      if (IsBusyIdlePrinting==True){
    e47e:	f0 90 c8 01 	lds	r15, 0x01C8
    e482:	91 e0       	ldi	r25, 0x01	; 1
    e484:	f9 16       	cp	r15, r25
    e486:	09 f0       	breq	.+2      	; 0xe48a <DisplayIdle+0xb0>
    e488:	51 c0       	rjmp	.+162    	; 0xe52c <DisplayIdle+0x152>
		       sprintf_P(lcdteks,PSTR("Printing FIP%s "),strFIP_ID);
    e48a:	00 d0       	rcall	.+0      	; 0xe48c <DisplayIdle+0xb2>
    e48c:	00 d0       	rcall	.+0      	; 0xe48e <DisplayIdle+0xb4>
    e48e:	00 d0       	rcall	.+0      	; 0xe490 <DisplayIdle+0xb6>
    e490:	ed b7       	in	r30, 0x3d	; 61
    e492:	fe b7       	in	r31, 0x3e	; 62
    e494:	31 96       	adiw	r30, 0x01	; 1
    e496:	8e 01       	movw	r16, r28
    e498:	0c 5f       	subi	r16, 0xFC	; 252
    e49a:	1f 4f       	sbci	r17, 0xFF	; 255
    e49c:	ad b7       	in	r26, 0x3d	; 61
    e49e:	be b7       	in	r27, 0x3e	; 62
    e4a0:	12 96       	adiw	r26, 0x02	; 2
    e4a2:	1c 93       	st	X, r17
    e4a4:	0e 93       	st	-X, r16
    e4a6:	11 97       	sbiw	r26, 0x01	; 1
    e4a8:	8b ef       	ldi	r24, 0xFB	; 251
    e4aa:	9b e1       	ldi	r25, 0x1B	; 27
    e4ac:	93 83       	std	Z+3, r25	; 0x03
    e4ae:	82 83       	std	Z+2, r24	; 0x02
    e4b0:	8c e9       	ldi	r24, 0x9C	; 156
    e4b2:	99 e0       	ldi	r25, 0x09	; 9
    e4b4:	95 83       	std	Z+5, r25	; 0x05
    e4b6:	84 83       	std	Z+4, r24	; 0x04
    e4b8:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
			   lcd_print(3,1,lcdteks);
    e4bc:	ed b7       	in	r30, 0x3d	; 61
    e4be:	fe b7       	in	r31, 0x3e	; 62
    e4c0:	36 96       	adiw	r30, 0x06	; 6
    e4c2:	0f b6       	in	r0, 0x3f	; 63
    e4c4:	f8 94       	cli
    e4c6:	fe bf       	out	0x3e, r31	; 62
    e4c8:	0f be       	out	0x3f, r0	; 63
    e4ca:	ed bf       	out	0x3d, r30	; 61
    e4cc:	83 e0       	ldi	r24, 0x03	; 3
    e4ce:	61 e0       	ldi	r22, 0x01	; 1
    e4d0:	a8 01       	movw	r20, r16
    e4d2:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
			   stDispIdle=diWaitNoBusy;
    e4d6:	f0 92 6d 03 	sts	0x036D, r15
    e4da:	28 c0       	rjmp	.+80     	; 0xe52c <DisplayIdle+0x152>
		  }         
	      break;
     case diWaitNoBusy:
	      if (IsBusyIdlePrinting==False){
    e4dc:	80 91 c8 01 	lds	r24, 0x01C8
    e4e0:	88 23       	and	r24, r24
    e4e2:	21 f5       	brne	.+72     	; 0xe52c <DisplayIdle+0x152>
		       sprintf_P(lcdteks,PSTR("                    "));
    e4e4:	00 d0       	rcall	.+0      	; 0xe4e6 <DisplayIdle+0x10c>
    e4e6:	00 d0       	rcall	.+0      	; 0xe4e8 <DisplayIdle+0x10e>
    e4e8:	8e 01       	movw	r16, r28
    e4ea:	0c 5f       	subi	r16, 0xFC	; 252
    e4ec:	1f 4f       	sbci	r17, 0xFF	; 255
    e4ee:	ad b7       	in	r26, 0x3d	; 61
    e4f0:	be b7       	in	r27, 0x3e	; 62
    e4f2:	12 96       	adiw	r26, 0x02	; 2
    e4f4:	1c 93       	st	X, r17
    e4f6:	0e 93       	st	-X, r16
    e4f8:	11 97       	sbiw	r26, 0x01	; 1
    e4fa:	86 ee       	ldi	r24, 0xE6	; 230
    e4fc:	9b e1       	ldi	r25, 0x1B	; 27
    e4fe:	14 96       	adiw	r26, 0x04	; 4
    e500:	9c 93       	st	X, r25
    e502:	8e 93       	st	-X, r24
    e504:	13 97       	sbiw	r26, 0x03	; 3
    e506:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
			   lcd_print(3,1,lcdteks);
    e50a:	0f 90       	pop	r0
    e50c:	0f 90       	pop	r0
    e50e:	0f 90       	pop	r0
    e510:	0f 90       	pop	r0
    e512:	83 e0       	ldi	r24, 0x03	; 3
    e514:	61 e0       	ldi	r22, 0x01	; 1
    e516:	a8 01       	movw	r20, r16
    e518:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
			   stDispIdle=diScan;
    e51c:	10 92 6d 03 	sts	0x036D, r1
			   if (nLocalAccount>0)IsViewFillingFIP=True;
    e520:	80 91 a4 01 	lds	r24, 0x01A4
    e524:	88 23       	and	r24, r24
    e526:	11 f0       	breq	.+4      	; 0xe52c <DisplayIdle+0x152>
    e528:	f0 92 ad 01 	sts	0x01AD, r15
		  }
	      break;     
	 }
	 //Display Filling FIP
	 if (IsViewFillingFIP==True){
    e52c:	80 91 ad 01 	lds	r24, 0x01AD
    e530:	81 30       	cpi	r24, 0x01	; 1
    e532:	09 f0       	breq	.+2      	; 0xe536 <DisplayIdle+0x15c>
    e534:	69 c0       	rjmp	.+210    	; 0xe608 <DisplayIdle+0x22e>
	     IsViewFillingFIP=False;
    e536:	10 92 ad 01 	sts	0x01AD, r1
		 if (nLocalAccount>0){
    e53a:	80 91 a4 01 	lds	r24, 0x01A4
    e53e:	88 23       	and	r24, r24
    e540:	09 f4       	brne	.+2      	; 0xe544 <DisplayIdle+0x16a>
    e542:	5c c0       	rjmp	.+184    	; 0xe5fc <DisplayIdle+0x222>
		     lcd_printf(3,1,PSTR("@FIP:"));
    e544:	83 e0       	ldi	r24, 0x03	; 3
    e546:	61 e0       	ldi	r22, 0x01	; 1
    e548:	40 ee       	ldi	r20, 0xE0	; 224
    e54a:	5b e1       	ldi	r21, 0x1B	; 27
    e54c:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
    e550:	ff 24       	eor	r15, r15
		     for (iDisp=0;iDisp<nLocalAccount;iDisp++){
			      //leadingZero(LocalAccountFIP[iDisp],sFIP);
				  sprintf_P(sFIP,PSTR("%.2d"),LocalAccountFIP[iDisp]);
    e552:	5e 01       	movw	r10, r28
    e554:	08 94       	sec
    e556:	a1 1c       	adc	r10, r1
    e558:	b1 1c       	adc	r11, r1
    e55a:	3b ed       	ldi	r19, 0xDB	; 219
    e55c:	63 2e       	mov	r6, r19
    e55e:	3b e1       	ldi	r19, 0x1B	; 27
    e560:	73 2e       	mov	r7, r19
			      sprintf_P(lcdteks,PSTR("#%s"),sFIP);
    e562:	24 e0       	ldi	r18, 0x04	; 4
    e564:	c2 2e       	mov	r12, r18
    e566:	d1 2c       	mov	r13, r1
    e568:	cc 0e       	add	r12, r28
    e56a:	dd 1e       	adc	r13, r29
    e56c:	97 ed       	ldi	r25, 0xD7	; 215
    e56e:	89 2e       	mov	r8, r25
    e570:	9b e1       	ldi	r25, 0x1B	; 27
    e572:	99 2e       	mov	r9, r25
    e574:	3d c0       	rjmp	.+122    	; 0xe5f0 <DisplayIdle+0x216>
	     IsViewFillingFIP=False;
		 if (nLocalAccount>0){
		     lcd_printf(3,1,PSTR("@FIP:"));
		     for (iDisp=0;iDisp<nLocalAccount;iDisp++){
			      //leadingZero(LocalAccountFIP[iDisp],sFIP);
				  sprintf_P(sFIP,PSTR("%.2d"),LocalAccountFIP[iDisp]);
    e576:	0f 2d       	mov	r16, r15
    e578:	10 e0       	ldi	r17, 0x00	; 0
    e57a:	00 d0       	rcall	.+0      	; 0xe57c <DisplayIdle+0x1a2>
    e57c:	00 d0       	rcall	.+0      	; 0xe57e <DisplayIdle+0x1a4>
    e57e:	00 d0       	rcall	.+0      	; 0xe580 <DisplayIdle+0x1a6>
    e580:	ad b7       	in	r26, 0x3d	; 61
    e582:	be b7       	in	r27, 0x3e	; 62
    e584:	11 96       	adiw	r26, 0x01	; 1
    e586:	ed b7       	in	r30, 0x3d	; 61
    e588:	fe b7       	in	r31, 0x3e	; 62
    e58a:	b2 82       	std	Z+2, r11	; 0x02
    e58c:	a1 82       	std	Z+1, r10	; 0x01
    e58e:	13 96       	adiw	r26, 0x03	; 3
    e590:	7c 92       	st	X, r7
    e592:	6e 92       	st	-X, r6
    e594:	12 97       	sbiw	r26, 0x02	; 2
    e596:	f8 01       	movw	r30, r16
    e598:	ea 5c       	subi	r30, 0xCA	; 202
    e59a:	fa 4f       	sbci	r31, 0xFA	; 250
    e59c:	80 81       	ld	r24, Z
    e59e:	14 96       	adiw	r26, 0x04	; 4
    e5a0:	8c 93       	st	X, r24
    e5a2:	14 97       	sbiw	r26, 0x04	; 4
    e5a4:	15 96       	adiw	r26, 0x05	; 5
    e5a6:	1c 92       	st	X, r1
    e5a8:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
			      sprintf_P(lcdteks,PSTR("#%s"),sFIP);
    e5ac:	ed b7       	in	r30, 0x3d	; 61
    e5ae:	fe b7       	in	r31, 0x3e	; 62
    e5b0:	31 96       	adiw	r30, 0x01	; 1
    e5b2:	ad b7       	in	r26, 0x3d	; 61
    e5b4:	be b7       	in	r27, 0x3e	; 62
    e5b6:	12 96       	adiw	r26, 0x02	; 2
    e5b8:	dc 92       	st	X, r13
    e5ba:	ce 92       	st	-X, r12
    e5bc:	11 97       	sbiw	r26, 0x01	; 1
    e5be:	93 82       	std	Z+3, r9	; 0x03
    e5c0:	82 82       	std	Z+2, r8	; 0x02
    e5c2:	b5 82       	std	Z+5, r11	; 0x05
    e5c4:	a4 82       	std	Z+4, r10	; 0x04
    e5c6:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
			      lcd_print(3,6+(iDisp*3),lcdteks);
    e5ca:	ed b7       	in	r30, 0x3d	; 61
    e5cc:	fe b7       	in	r31, 0x3e	; 62
    e5ce:	36 96       	adiw	r30, 0x06	; 6
    e5d0:	0f b6       	in	r0, 0x3f	; 63
    e5d2:	f8 94       	cli
    e5d4:	fe bf       	out	0x3e, r31	; 62
    e5d6:	0f be       	out	0x3f, r0	; 63
    e5d8:	ed bf       	out	0x3d, r30	; 61
    e5da:	b8 01       	movw	r22, r16
    e5dc:	66 0f       	add	r22, r22
    e5de:	77 1f       	adc	r23, r23
    e5e0:	60 0f       	add	r22, r16
    e5e2:	71 1f       	adc	r23, r17
    e5e4:	6a 5f       	subi	r22, 0xFA	; 250
    e5e6:	83 e0       	ldi	r24, 0x03	; 3
    e5e8:	a6 01       	movw	r20, r12
    e5ea:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
	 //Display Filling FIP
	 if (IsViewFillingFIP==True){
	     IsViewFillingFIP=False;
		 if (nLocalAccount>0){
		     lcd_printf(3,1,PSTR("@FIP:"));
		     for (iDisp=0;iDisp<nLocalAccount;iDisp++){
    e5ee:	f3 94       	inc	r15
    e5f0:	80 91 a4 01 	lds	r24, 0x01A4
    e5f4:	f8 16       	cp	r15, r24
    e5f6:	08 f4       	brcc	.+2      	; 0xe5fa <DisplayIdle+0x220>
    e5f8:	be cf       	rjmp	.-132    	; 0xe576 <DisplayIdle+0x19c>
    e5fa:	06 c0       	rjmp	.+12     	; 0xe608 <DisplayIdle+0x22e>
				  sprintf_P(sFIP,PSTR("%.2d"),LocalAccountFIP[iDisp]);
			      sprintf_P(lcdteks,PSTR("#%s"),sFIP);
			      lcd_print(3,6+(iDisp*3),lcdteks);
		     }
		 }else{
		 lcd_printf(3,1,PSTR("                    "));
    e5fc:	83 e0       	ldi	r24, 0x03	; 3
    e5fe:	61 e0       	ldi	r22, 0x01	; 1
    e600:	42 ec       	ldi	r20, 0xC2	; 194
    e602:	5b e1       	ldi	r21, 0x1B	; 27
    e604:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		 }    
	 }
	 //Filling @FIP 
     if (IsCompleteFilling==True){
    e608:	80 91 c0 01 	lds	r24, 0x01C0
    e60c:	81 30       	cpi	r24, 0x01	; 1
    e60e:	c1 f4       	brne	.+48     	; 0xe640 <DisplayIdle+0x266>
	     IsCompleteFilling=False;
    e610:	10 92 c0 01 	sts	0x01C0, r1
	     if (nLocalAccount>0){
    e614:	90 91 a4 01 	lds	r25, 0x01A4
    e618:	99 23       	and	r25, r25
    e61a:	91 f0       	breq	.+36     	; 0xe640 <DisplayIdle+0x266>
    e61c:	e6 e3       	ldi	r30, 0x36	; 54
    e61e:	f5 e0       	ldi	r31, 0x05	; 5
			 for(i=0;i<nLocalAccount;i++){//Shift data
    e620:	29 2f       	mov	r18, r25
    e622:	30 e0       	ldi	r19, 0x00	; 0
    e624:	2e 0f       	add	r18, r30
    e626:	3f 1f       	adc	r19, r31
    e628:	02 c0       	rjmp	.+4      	; 0xe62e <DisplayIdle+0x254>
			     LocalAccountFIP[i]=LocalAccountFIP[i+1];
    e62a:	81 81       	ldd	r24, Z+1	; 0x01
    e62c:	81 93       	st	Z+, r24
	 }
	 //Filling @FIP 
     if (IsCompleteFilling==True){
	     IsCompleteFilling=False;
	     if (nLocalAccount>0){
			 for(i=0;i<nLocalAccount;i++){//Shift data
    e62e:	e2 17       	cp	r30, r18
    e630:	f3 07       	cpc	r31, r19
    e632:	d9 f7       	brne	.-10     	; 0xe62a <DisplayIdle+0x250>
			     LocalAccountFIP[i]=LocalAccountFIP[i+1];
			 }
			 nLocalAccount--;
    e634:	91 50       	subi	r25, 0x01	; 1
    e636:	90 93 a4 01 	sts	0x01A4, r25
             IsViewFillingFIP=True; 
    e63a:	81 e0       	ldi	r24, 0x01	; 1
    e63c:	80 93 ad 01 	sts	0x01AD, r24
		 }
	 }
}
    e640:	67 96       	adiw	r28, 0x17	; 23
    e642:	0f b6       	in	r0, 0x3f	; 63
    e644:	f8 94       	cli
    e646:	de bf       	out	0x3e, r29	; 62
    e648:	0f be       	out	0x3f, r0	; 63
    e64a:	cd bf       	out	0x3d, r28	; 61
    e64c:	cf 91       	pop	r28
    e64e:	df 91       	pop	r29
    e650:	1f 91       	pop	r17
    e652:	0f 91       	pop	r16
    e654:	ff 90       	pop	r15
    e656:	df 90       	pop	r13
    e658:	cf 90       	pop	r12
    e65a:	bf 90       	pop	r11
    e65c:	af 90       	pop	r10
    e65e:	9f 90       	pop	r9
    e660:	8f 90       	pop	r8
    e662:	7f 90       	pop	r7
    e664:	6f 90       	pop	r6
    e666:	08 95       	ret

0000e668 <systemMaster>:
	cbi(DDRB,2);sbi(PORTB,2);//MOSI Input
	cbi(DDRB,1);sbi(PORTB,1);//SCK  Input
}

void systemMaster(){
  	_spi_init(1, 0);         //Master
    e668:	81 e0       	ldi	r24, 0x01	; 1
    e66a:	60 e0       	ldi	r22, 0x00	; 0
    e66c:	0e 94 da b0 	call	0x161b4	; 0x161b4 <_spi_init>
    _spi_enable(_SPI_SLAVE); //Enable SS 
    e670:	81 e0       	ldi	r24, 0x01	; 1
    e672:	0e 94 ed b0 	call	0x161da	; 0x161da <_spi_enable>
	cbi(DDRB,3);sbi(PORTB,3);//MISO Input
    e676:	bb 98       	cbi	0x17, 3	; 23
    e678:	c3 9a       	sbi	0x18, 3	; 24
	sbi(DDRB,2);             //MOSI Output
    e67a:	ba 9a       	sbi	0x17, 2	; 23
}
    e67c:	08 95       	ret

0000e67e <systemSlave>:




void systemSlave(){
    _spi_enable(_SPI_NONE);	
    e67e:	80 e0       	ldi	r24, 0x00	; 0
    e680:	0e 94 ed b0 	call	0x161da	; 0x161da <_spi_enable>
  	_spi_init(0, 1);         //Slave
    e684:	80 e0       	ldi	r24, 0x00	; 0
    e686:	61 e0       	ldi	r22, 0x01	; 1
    e688:	0e 94 da b0 	call	0x161b4	; 0x161b4 <_spi_init>
	sbi(DDRB,3);             //MISO Output
    e68c:	bb 9a       	sbi	0x17, 3	; 23
	sbi(DDRB,3);sbi(PORTB,3);//MISO Output
    e68e:	bb 9a       	sbi	0x17, 3	; 23
    e690:	c3 9a       	sbi	0x18, 3	; 24
	cbi(DDRB,2);sbi(PORTB,2);//MOSI Input
    e692:	ba 98       	cbi	0x17, 2	; 23
    e694:	c2 9a       	sbi	0x18, 2	; 24
	cbi(DDRB,1);sbi(PORTB,1);//SCK  Input
    e696:	b9 98       	cbi	0x17, 1	; 23
    e698:	c1 9a       	sbi	0x18, 1	; 24
}
    e69a:	08 95       	ret

0000e69c <EDCSendByte>:
    _spi_enable(_SPI_SLAVE); //Enable SS 
	cbi(DDRB,3);sbi(PORTB,3);//MISO Input
	sbi(DDRB,2);             //MOSI Output
}

void EDCSendByte(char EDCData){
    e69c:	1f 93       	push	r17
    e69e:	18 2f       	mov	r17, r24
     systemMaster();	 
    e6a0:	0e 94 34 73 	call	0xe668	; 0xe668 <systemMaster>
     _spi(EDCData);
    e6a4:	81 2f       	mov	r24, r17
    e6a6:	0e 94 04 b1 	call	0x16208	; 0x16208 <_spi>
     systemSlave();
    e6aa:	0e 94 3f 73 	call	0xe67e	; 0xe67e <systemSlave>
}
    e6ae:	1f 91       	pop	r17
    e6b0:	08 95       	ret

0000e6b2 <SendEDCMessage>:
     char Result;
	 Result=xLRC^DataIn;
     return(Result);
}

void SendEDCMessage(){
    e6b2:	cf 92       	push	r12
    e6b4:	df 92       	push	r13
    e6b6:	ef 92       	push	r14
    e6b8:	ff 92       	push	r15
    e6ba:	0f 93       	push	r16
    e6bc:	1f 93       	push	r17
    e6be:	df 93       	push	r29
    e6c0:	cf 93       	push	r28
    e6c2:	cd b7       	in	r28, 0x3d	; 61
    e6c4:	de b7       	in	r29, 0x3e	; 62
    e6c6:	ec 97       	sbiw	r28, 0x3c	; 60
    e6c8:	0f b6       	in	r0, 0x3f	; 63
    e6ca:	f8 94       	cli
    e6cc:	de bf       	out	0x3e, r29	; 62
    e6ce:	0f be       	out	0x3f, r0	; 63
    e6d0:	cd bf       	out	0x3d, r28	; 61

     //GenerateData
	 //sprintf_P(strAmount,PSTR("%d"),100);//Testing Only
	 //AddZeroLead(strAmount,8);
	 //_uart_printf(0,0,PSTR("StrStatus:"));_uart_print(0,1,strStatus);
     sprintf_P(SerialEDC,PSTR("02%s%s%s%s%s%s%s"),strTranNo,strFIP_ID,strDescription,strPrice,strVolume,strAmount,strStatus);     
    e6d2:	8d b7       	in	r24, 0x3d	; 61
    e6d4:	9e b7       	in	r25, 0x3e	; 62
    e6d6:	42 97       	sbiw	r24, 0x12	; 18
    e6d8:	0f b6       	in	r0, 0x3f	; 63
    e6da:	f8 94       	cli
    e6dc:	9e bf       	out	0x3e, r25	; 62
    e6de:	0f be       	out	0x3f, r0	; 63
    e6e0:	8d bf       	out	0x3d, r24	; 61
    e6e2:	ed b7       	in	r30, 0x3d	; 61
    e6e4:	fe b7       	in	r31, 0x3e	; 62
    e6e6:	31 96       	adiw	r30, 0x01	; 1
    e6e8:	8e 01       	movw	r16, r28
    e6ea:	0f 5f       	subi	r16, 0xFF	; 255
    e6ec:	1f 4f       	sbci	r17, 0xFF	; 255
    e6ee:	ad b7       	in	r26, 0x3d	; 61
    e6f0:	be b7       	in	r27, 0x3e	; 62
    e6f2:	12 96       	adiw	r26, 0x02	; 2
    e6f4:	1c 93       	st	X, r17
    e6f6:	0e 93       	st	-X, r16
    e6f8:	11 97       	sbiw	r26, 0x01	; 1
    e6fa:	8f ea       	ldi	r24, 0xAF	; 175
    e6fc:	9b e1       	ldi	r25, 0x1B	; 27
    e6fe:	93 83       	std	Z+3, r25	; 0x03
    e700:	82 83       	std	Z+2, r24	; 0x02
    e702:	81 e6       	ldi	r24, 0x61	; 97
    e704:	9e e0       	ldi	r25, 0x0E	; 14
    e706:	95 83       	std	Z+5, r25	; 0x05
    e708:	84 83       	std	Z+4, r24	; 0x04
    e70a:	8c e9       	ldi	r24, 0x9C	; 156
    e70c:	99 e0       	ldi	r25, 0x09	; 9
    e70e:	97 83       	std	Z+7, r25	; 0x07
    e710:	86 83       	std	Z+6, r24	; 0x06
    e712:	81 e1       	ldi	r24, 0x11	; 17
    e714:	9a e0       	ldi	r25, 0x0A	; 10
    e716:	91 87       	std	Z+9, r25	; 0x09
    e718:	80 87       	std	Z+8, r24	; 0x08
    e71a:	81 e8       	ldi	r24, 0x81	; 129
    e71c:	97 e0       	ldi	r25, 0x07	; 7
    e71e:	93 87       	std	Z+11, r25	; 0x0b
    e720:	82 87       	std	Z+10, r24	; 0x0a
    e722:	85 e5       	ldi	r24, 0x55	; 85
    e724:	95 e0       	ldi	r25, 0x05	; 5
    e726:	95 87       	std	Z+13, r25	; 0x0d
    e728:	84 87       	std	Z+12, r24	; 0x0c
    e72a:	8b e8       	ldi	r24, 0x8B	; 139
    e72c:	9d e0       	ldi	r25, 0x0D	; 13
    e72e:	97 87       	std	Z+15, r25	; 0x0f
    e730:	86 87       	std	Z+14, r24	; 0x0e
    e732:	8a e6       	ldi	r24, 0x6A	; 106
    e734:	95 e0       	ldi	r25, 0x05	; 5
    e736:	91 8b       	std	Z+17, r25	; 0x11
    e738:	80 8b       	std	Z+16, r24	; 0x10
    e73a:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>

	 //SendingData
	 xCRC=0;EDCSendByte(0x02);
    e73e:	8d b7       	in	r24, 0x3d	; 61
    e740:	9e b7       	in	r25, 0x3e	; 62
    e742:	42 96       	adiw	r24, 0x12	; 18
    e744:	0f b6       	in	r0, 0x3f	; 63
    e746:	f8 94       	cli
    e748:	9e bf       	out	0x3e, r25	; 62
    e74a:	0f be       	out	0x3f, r0	; 63
    e74c:	8d bf       	out	0x3d, r24	; 61
    e74e:	82 e0       	ldi	r24, 0x02	; 2
    e750:	0e 94 4e 73 	call	0xe69c	; 0xe69c <EDCSendByte>
    e754:	ff 24       	eor	r15, r15
    e756:	52 e0       	ldi	r21, 0x02	; 2
    e758:	e5 2e       	mov	r14, r21
    e75a:	44 ed       	ldi	r20, 0xD4	; 212
    e75c:	c4 2e       	mov	r12, r20
    e75e:	40 e3       	ldi	r20, 0x30	; 48
    e760:	d4 2e       	mov	r13, r20
    e762:	0a c0       	rjmp	.+20     	; 0xe778 <SendEDCMessage+0xc6>
	 xCRC=CalcLRC(xCRC,0x02);	      
	 for (i=0;i<strlen(SerialEDC);i++){
          xCRC=CalcLRC(xCRC,SerialEDC[i]);
    e764:	a0 0f       	add	r26, r16
    e766:	b1 1f       	adc	r27, r17
    e768:	8c 91       	ld	r24, X
     systemSlave();
}

char CalcLRC(char xLRC,char DataIn){
     char Result;
	 Result=xLRC^DataIn;
    e76a:	e8 26       	eor	r14, r24
	 //SendingData
	 xCRC=0;EDCSendByte(0x02);
	 xCRC=CalcLRC(xCRC,0x02);	      
	 for (i=0;i<strlen(SerialEDC);i++){
          xCRC=CalcLRC(xCRC,SerialEDC[i]);
          EDCSendByte(SerialEDC[i]);
    e76c:	0e 94 4e 73 	call	0xe69c	; 0xe69c <EDCSendByte>
    e770:	c6 01       	movw	r24, r12
    e772:	01 97       	sbiw	r24, 0x01	; 1
    e774:	f1 f7       	brne	.-4      	; 0xe772 <SendEDCMessage+0xc0>
     sprintf_P(SerialEDC,PSTR("02%s%s%s%s%s%s%s"),strTranNo,strFIP_ID,strDescription,strPrice,strVolume,strAmount,strStatus);     

	 //SendingData
	 xCRC=0;EDCSendByte(0x02);
	 xCRC=CalcLRC(xCRC,0x02);	      
	 for (i=0;i<strlen(SerialEDC);i++){
    e776:	f3 94       	inc	r15
    e778:	f8 01       	movw	r30, r16
    e77a:	01 90       	ld	r0, Z+
    e77c:	00 20       	and	r0, r0
    e77e:	e9 f7       	brne	.-6      	; 0xe77a <SendEDCMessage+0xc8>
    e780:	31 97       	sbiw	r30, 0x01	; 1
    e782:	e0 1b       	sub	r30, r16
    e784:	f1 0b       	sbc	r31, r17
    e786:	af 2d       	mov	r26, r15
    e788:	b0 e0       	ldi	r27, 0x00	; 0
    e78a:	ae 17       	cp	r26, r30
    e78c:	bf 07       	cpc	r27, r31
    e78e:	50 f3       	brcs	.-44     	; 0xe764 <SendEDCMessage+0xb2>
          xCRC=CalcLRC(xCRC,SerialEDC[i]);
          EDCSendByte(SerialEDC[i]);
		  //_uart(0,1,SerialEDC[i]);
		  _delay_ms(SPI_EDC_DELAY);//min:8
	 }
     EDCSendByte(0x03);
    e790:	83 e0       	ldi	r24, 0x03	; 3
    e792:	0e 94 4e 73 	call	0xe69c	; 0xe69c <EDCSendByte>
	 xCRC=CalcLRC(xCRC,0x03);	      
	 EDCSendByte(xCRC);
    e796:	83 e0       	ldi	r24, 0x03	; 3
    e798:	8e 25       	eor	r24, r14
    e79a:	0e 94 4e 73 	call	0xe69c	; 0xe69c <EDCSendByte>
}
    e79e:	ec 96       	adiw	r28, 0x3c	; 60
    e7a0:	0f b6       	in	r0, 0x3f	; 63
    e7a2:	f8 94       	cli
    e7a4:	de bf       	out	0x3e, r29	; 62
    e7a6:	0f be       	out	0x3f, r0	; 63
    e7a8:	cd bf       	out	0x3d, r28	; 61
    e7aa:	cf 91       	pop	r28
    e7ac:	df 91       	pop	r29
    e7ae:	1f 91       	pop	r17
    e7b0:	0f 91       	pop	r16
    e7b2:	ff 90       	pop	r15
    e7b4:	ef 90       	pop	r14
    e7b6:	df 90       	pop	r13
    e7b8:	cf 90       	pop	r12
    e7ba:	08 95       	ret

0000e7bc <SendSlaveCommand>:
void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
	 PoolMsg=plMsg;
     IsControlPooling=True;
}
void SendSlaveCommand(char SlaveCommand,char SlaveMessage){     
    e7bc:	0f 93       	push	r16
    e7be:	1f 93       	push	r17
    e7c0:	18 2f       	mov	r17, r24
    e7c2:	06 2f       	mov	r16, r22
	 systemMaster();
    e7c4:	0e 94 34 73 	call	0xe668	; 0xe668 <systemMaster>
	 _spi(0x05);
    e7c8:	85 e0       	ldi	r24, 0x05	; 5
    e7ca:	0e 94 04 b1 	call	0x16208	; 0x16208 <_spi>
	 _spi(SlaveCommand);
    e7ce:	81 2f       	mov	r24, r17
    e7d0:	0e 94 04 b1 	call	0x16208	; 0x16208 <_spi>
	 _spi(SlaveMessage);
    e7d4:	80 2f       	mov	r24, r16
    e7d6:	0e 94 04 b1 	call	0x16208	; 0x16208 <_spi>
	 _spi(0x06);
    e7da:	86 e0       	ldi	r24, 0x06	; 6
    e7dc:	0e 94 04 b1 	call	0x16208	; 0x16208 <_spi>
	 systemSlave();
    e7e0:	0e 94 3f 73 	call	0xe67e	; 0xe67e <systemSlave>
}
    e7e4:	1f 91       	pop	r17
    e7e6:	0f 91       	pop	r16
    e7e8:	08 95       	ret

0000e7ea <FSettingPumpID>:
     if ((*Value)>MinValue){
	     (*Value)--;
	 }else *Value=MaxValue;
}

char FSettingPumpID(){
    e7ea:	9f 92       	push	r9
    e7ec:	af 92       	push	r10
    e7ee:	bf 92       	push	r11
    e7f0:	cf 92       	push	r12
    e7f2:	df 92       	push	r13
    e7f4:	ef 92       	push	r14
    e7f6:	ff 92       	push	r15
    e7f8:	0f 93       	push	r16
    e7fa:	1f 93       	push	r17
    e7fc:	df 93       	push	r29
    e7fe:	cf 93       	push	r28
    e800:	cd b7       	in	r28, 0x3d	; 61
    e802:	de b7       	in	r29, 0x3e	; 62
    e804:	64 97       	sbiw	r28, 0x14	; 20
    e806:	0f b6       	in	r0, 0x3f	; 63
    e808:	f8 94       	cli
    e80a:	de bf       	out	0x3e, r29	; 62
    e80c:	0f be       	out	0x3f, r0	; 63
    e80e:	cd bf       	out	0x3d, r28	; 61
	 char iLoop,Result,KeyChar,KeyPressed,i,j,CheckPump;
	 char lcdteks[20];
	 static char Idx,PPumpId[8],MsgPumpId,PumpCount;
     
	 Result=MENU_NONE;
	 switch (stMenuPumpID){
    e810:	80 91 de 02 	lds	r24, 0x02DE
    e814:	85 30       	cpi	r24, 0x05	; 5
    e816:	09 f4       	brne	.+2      	; 0xe81a <FSettingPumpID+0x30>
    e818:	88 c1       	rjmp	.+784    	; 0xeb2a <FSettingPumpID+0x340>
    e81a:	86 30       	cpi	r24, 0x06	; 6
    e81c:	90 f4       	brcc	.+36     	; 0xe842 <FSettingPumpID+0x58>
    e81e:	82 30       	cpi	r24, 0x02	; 2
    e820:	09 f4       	brne	.+2      	; 0xe824 <FSettingPumpID+0x3a>
    e822:	8f c0       	rjmp	.+286    	; 0xe942 <FSettingPumpID+0x158>
    e824:	83 30       	cpi	r24, 0x03	; 3
    e826:	30 f4       	brcc	.+12     	; 0xe834 <FSettingPumpID+0x4a>
    e828:	88 23       	and	r24, r24
    e82a:	f1 f0       	breq	.+60     	; 0xe868 <FSettingPumpID+0x7e>
    e82c:	81 30       	cpi	r24, 0x01	; 1
    e82e:	09 f0       	breq	.+2      	; 0xe832 <FSettingPumpID+0x48>
    e830:	73 c2       	rjmp	.+1254   	; 0xed18 <FSettingPumpID+0x52e>
    e832:	2d c0       	rjmp	.+90     	; 0xe88e <FSettingPumpID+0xa4>
    e834:	83 30       	cpi	r24, 0x03	; 3
    e836:	09 f4       	brne	.+2      	; 0xe83a <FSettingPumpID+0x50>
    e838:	51 c1       	rjmp	.+674    	; 0xeadc <FSettingPumpID+0x2f2>
    e83a:	84 30       	cpi	r24, 0x04	; 4
    e83c:	09 f0       	breq	.+2      	; 0xe840 <FSettingPumpID+0x56>
    e83e:	6c c2       	rjmp	.+1240   	; 0xed18 <FSettingPumpID+0x52e>
    e840:	6d c1       	rjmp	.+730    	; 0xeb1c <FSettingPumpID+0x332>
    e842:	88 30       	cpi	r24, 0x08	; 8
    e844:	09 f4       	brne	.+2      	; 0xe848 <FSettingPumpID+0x5e>
    e846:	fc c1       	rjmp	.+1016   	; 0xec40 <FSettingPumpID+0x456>
    e848:	89 30       	cpi	r24, 0x09	; 9
    e84a:	38 f4       	brcc	.+14     	; 0xe85a <FSettingPumpID+0x70>
    e84c:	86 30       	cpi	r24, 0x06	; 6
    e84e:	09 f4       	brne	.+2      	; 0xe852 <FSettingPumpID+0x68>
    e850:	9b c1       	rjmp	.+822    	; 0xeb88 <FSettingPumpID+0x39e>
    e852:	87 30       	cpi	r24, 0x07	; 7
    e854:	09 f0       	breq	.+2      	; 0xe858 <FSettingPumpID+0x6e>
    e856:	60 c2       	rjmp	.+1216   	; 0xed18 <FSettingPumpID+0x52e>
    e858:	45 c2       	rjmp	.+1162   	; 0xece4 <FSettingPumpID+0x4fa>
    e85a:	89 30       	cpi	r24, 0x09	; 9
    e85c:	09 f4       	brne	.+2      	; 0xe860 <FSettingPumpID+0x76>
    e85e:	4a c2       	rjmp	.+1172   	; 0xecf4 <FSettingPumpID+0x50a>
    e860:	8a 30       	cpi	r24, 0x0A	; 10
    e862:	09 f0       	breq	.+2      	; 0xe866 <FSettingPumpID+0x7c>
    e864:	59 c2       	rjmp	.+1202   	; 0xed18 <FSettingPumpID+0x52e>
    e866:	4c c2       	rjmp	.+1176   	; 0xed00 <FSettingPumpID+0x516>
	 case mpInitPumpId:	      
	      //Disable PumpPooling
		  if (IFType==IT_STANDALONE)SendSlaveCommand(SC_STOP_POOL_SEQUENCE,0);
    e868:	80 91 10 01 	lds	r24, 0x0110
    e86c:	82 30       	cpi	r24, 0x02	; 2
    e86e:	21 f4       	brne	.+8      	; 0xe878 <FSettingPumpID+0x8e>
    e870:	8f e1       	ldi	r24, 0x1F	; 31
    e872:	60 e0       	ldi	r22, 0x00	; 0
    e874:	0e 94 de 73 	call	0xe7bc	; 0xe7bc <SendSlaveCommand>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    e878:	84 ed       	ldi	r24, 0xD4	; 212
    e87a:	92 e0       	ldi	r25, 0x02	; 2
    e87c:	65 e4       	ldi	r22, 0x45	; 69
    e87e:	70 e0       	ldi	r23, 0x00	; 0
    e880:	48 e0       	ldi	r20, 0x08	; 8
    e882:	50 e0       	ldi	r21, 0x00	; 0
    e884:	26 ef       	ldi	r18, 0xF6	; 246
    e886:	32 e1       	ldi	r19, 0x12	; 18
    e888:	0e 94 7a b5 	call	0x16af4	; 0x16af4 <__eerd_block>
    e88c:	4c c1       	rjmp	.+664    	; 0xeb26 <FSettingPumpID+0x33c>
		  eeprom_read_block((void*) &PPumpId, (const void*) &DefPumpMap,8);
          stMenuPumpID=mpDisplayPumpId;
	      break;
	 case mpDisplayPumpId:
	      lcd_clear();		  
    e88e:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
    e892:	b4 ed       	ldi	r27, 0xD4	; 212
    e894:	eb 2e       	mov	r14, r27
    e896:	b2 e0       	ldi	r27, 0x02	; 2
    e898:	fb 2e       	mov	r15, r27
    e89a:	01 e0       	ldi	r16, 0x01	; 1
    e89c:	10 e0       	ldi	r17, 0x00	; 0
		  for (iLoop=0;iLoop<4;iLoop++){
			  sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d"),(iLoop+1),PPumpId[iLoop],(iLoop+5),PPumpId[iLoop+4]);
    e89e:	6e 01       	movw	r12, r28
    e8a0:	08 94       	sec
    e8a2:	c1 1c       	adc	r12, r1
    e8a4:	d1 1c       	adc	r13, r1
    e8a6:	af e9       	ldi	r26, 0x9F	; 159
    e8a8:	aa 2e       	mov	r10, r26
    e8aa:	ac e0       	ldi	r26, 0x0C	; 12
    e8ac:	ba 2e       	mov	r11, r26
    e8ae:	8d b7       	in	r24, 0x3d	; 61
    e8b0:	9e b7       	in	r25, 0x3e	; 62
    e8b2:	0c 97       	sbiw	r24, 0x0c	; 12
    e8b4:	0f b6       	in	r0, 0x3f	; 63
    e8b6:	f8 94       	cli
    e8b8:	9e bf       	out	0x3e, r25	; 62
    e8ba:	0f be       	out	0x3f, r0	; 63
    e8bc:	8d bf       	out	0x3d, r24	; 61
    e8be:	ed b7       	in	r30, 0x3d	; 61
    e8c0:	fe b7       	in	r31, 0x3e	; 62
    e8c2:	31 96       	adiw	r30, 0x01	; 1
    e8c4:	ad b7       	in	r26, 0x3d	; 61
    e8c6:	be b7       	in	r27, 0x3e	; 62
    e8c8:	12 96       	adiw	r26, 0x02	; 2
    e8ca:	dc 92       	st	X, r13
    e8cc:	ce 92       	st	-X, r12
    e8ce:	11 97       	sbiw	r26, 0x01	; 1
    e8d0:	b3 82       	std	Z+3, r11	; 0x03
    e8d2:	a2 82       	std	Z+2, r10	; 0x02
    e8d4:	15 83       	std	Z+5, r17	; 0x05
    e8d6:	04 83       	std	Z+4, r16	; 0x04
    e8d8:	d7 01       	movw	r26, r14
    e8da:	8c 91       	ld	r24, X
    e8dc:	86 83       	std	Z+6, r24	; 0x06
    e8de:	17 82       	std	Z+7, r1	; 0x07
    e8e0:	0c 5f       	subi	r16, 0xFC	; 252
    e8e2:	1f 4f       	sbci	r17, 0xFF	; 255
    e8e4:	11 87       	std	Z+9, r17	; 0x09
    e8e6:	00 87       	std	Z+8, r16	; 0x08
    e8e8:	04 50       	subi	r16, 0x04	; 4
    e8ea:	10 40       	sbci	r17, 0x00	; 0
    e8ec:	14 96       	adiw	r26, 0x04	; 4
    e8ee:	8c 91       	ld	r24, X
    e8f0:	82 87       	std	Z+10, r24	; 0x0a
    e8f2:	13 86       	std	Z+11, r1	; 0x0b
    e8f4:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
			  lcd_print((iLoop+1),1,lcdteks);
    e8f8:	ed b7       	in	r30, 0x3d	; 61
    e8fa:	fe b7       	in	r31, 0x3e	; 62
    e8fc:	3c 96       	adiw	r30, 0x0c	; 12
    e8fe:	0f b6       	in	r0, 0x3f	; 63
    e900:	f8 94       	cli
    e902:	fe bf       	out	0x3e, r31	; 62
    e904:	0f be       	out	0x3f, r0	; 63
    e906:	ed bf       	out	0x3d, r30	; 61
    e908:	80 2f       	mov	r24, r16
    e90a:	61 e0       	ldi	r22, 0x01	; 1
    e90c:	a6 01       	movw	r20, r12
    e90e:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
    e912:	08 94       	sec
    e914:	e1 1c       	adc	r14, r1
    e916:	f1 1c       	adc	r15, r1
    e918:	0f 5f       	subi	r16, 0xFF	; 255
    e91a:	1f 4f       	sbci	r17, 0xFF	; 255
		  eeprom_read_block((void*) &PPumpId, (const void*) &DefPumpMap,8);
          stMenuPumpID=mpDisplayPumpId;
	      break;
	 case mpDisplayPumpId:
	      lcd_clear();		  
		  for (iLoop=0;iLoop<4;iLoop++){
    e91c:	f8 ed       	ldi	r31, 0xD8	; 216
    e91e:	ef 16       	cp	r14, r31
    e920:	f2 e0       	ldi	r31, 0x02	; 2
    e922:	ff 06       	cpc	r15, r31
    e924:	21 f6       	brne	.-120    	; 0xe8ae <FSettingPumpID+0xc4>
			  sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d"),(iLoop+1),PPumpId[iLoop],(iLoop+5),PPumpId[iLoop+4]);
			  lcd_print((iLoop+1),1,lcdteks);
          }
          lcd_printf(3,15,PSTR("*)Back"));
    e926:	83 e0       	ldi	r24, 0x03	; 3
    e928:	6f e0       	ldi	r22, 0x0F	; 15
    e92a:	48 e9       	ldi	r20, 0x98	; 152
    e92c:	5c e0       	ldi	r21, 0x0C	; 12
    e92e:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
	      lcd_printf(4,15,PSTR("#)Save"));
    e932:	84 e0       	ldi	r24, 0x04	; 4
    e934:	6f e0       	ldi	r22, 0x0F	; 15
    e936:	41 e9       	ldi	r20, 0x91	; 145
    e938:	5c e0       	ldi	r21, 0x0C	; 12
    e93a:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
          stMenuPumpID=mpSelectInput;
    e93e:	82 e0       	ldi	r24, 0x02	; 2
    e940:	d6 c1       	rjmp	.+940    	; 0xecee <FSettingPumpID+0x504>
	      break;
     case mpSelectInput:
	      KeyPressed=_key_scan(1);
    e942:	81 e0       	ldi	r24, 0x01	; 1
    e944:	0e 94 06 b0 	call	0x1600c	; 0x1600c <_key_scan>
    e948:	98 2e       	mov	r9, r24
	      KeyChar=_key_btn(KeyPressed);
    e94a:	0e 94 67 af 	call	0x15ece	; 0x15ece <_key_btn>
    e94e:	98 2f       	mov	r25, r24
          if ((KeyChar>='1') && (KeyChar<='8')){
    e950:	81 53       	subi	r24, 0x31	; 49
    e952:	88 30       	cpi	r24, 0x08	; 8
    e954:	08 f0       	brcs	.+2      	; 0xe958 <FSettingPumpID+0x16e>
    e956:	85 c0       	rjmp	.+266    	; 0xea62 <FSettingPumpID+0x278>
		      //eeprom_read_block((void*) &PPumpId, (const void*) &DefPumpMap,8);
			  switch(IFType){
    e958:	80 91 10 01 	lds	r24, 0x0110
    e95c:	81 30       	cpi	r24, 0x01	; 1
    e95e:	19 f0       	breq	.+6      	; 0xe966 <FSettingPumpID+0x17c>
    e960:	82 30       	cpi	r24, 0x02	; 2
    e962:	a1 f5       	brne	.+104    	; 0xe9cc <FSettingPumpID+0x1e2>
    e964:	17 c0       	rjmp	.+46     	; 0xe994 <FSettingPumpID+0x1aa>
			  case IT_SLAVE:
			       if (IsShift==False)IncValue(&PPumpId[KeyChar-'1'],0,99);//PPumpId[KeyChar-'1']=((PPumpId[KeyChar-'1']+1)%100);
    e966:	80 91 dd 02 	lds	r24, 0x02DD
    e96a:	88 23       	and	r24, r24
    e96c:	41 f4       	brne	.+16     	; 0xe97e <FSettingPumpID+0x194>
    e96e:	e9 2f       	mov	r30, r25
    e970:	f0 e0       	ldi	r31, 0x00	; 0
    e972:	ed 55       	subi	r30, 0x5D	; 93
    e974:	fd 4f       	sbci	r31, 0xFD	; 253
		}
	}
}

void IncValue(char *Value,char MinValue,char MaxValue){
     if ((*Value)<MaxValue){
    e976:	80 81       	ld	r24, Z
    e978:	83 36       	cpi	r24, 0x63	; 99
    e97a:	c8 f4       	brcc	.+50     	; 0xe9ae <FSettingPumpID+0x1c4>
    e97c:	16 c0       	rjmp	.+44     	; 0xe9aa <FSettingPumpID+0x1c0>
		      //eeprom_read_block((void*) &PPumpId, (const void*) &DefPumpMap,8);
			  switch(IFType){
			  case IT_SLAVE:
			       if (IsShift==False)IncValue(&PPumpId[KeyChar-'1'],0,99);//PPumpId[KeyChar-'1']=((PPumpId[KeyChar-'1']+1)%100);
				   else
				   if (IsShift==True)DecValue(&PPumpId[KeyChar-'1'],0,99);//PPumpId[KeyChar-'1']=100-(100-((PPumpId[KeyChar-'1']+1)%100));
    e97e:	81 30       	cpi	r24, 0x01	; 1
    e980:	29 f5       	brne	.+74     	; 0xe9cc <FSettingPumpID+0x1e2>
    e982:	e9 2f       	mov	r30, r25
    e984:	f0 e0       	ldi	r31, 0x00	; 0
    e986:	ed 55       	subi	r30, 0x5D	; 93
    e988:	fd 4f       	sbci	r31, 0xFD	; 253
	     (*Value)++;
	 }else *Value=MinValue;
}

void DecValue(char *Value,char MinValue,char MaxValue){
     if ((*Value)>MinValue){
    e98a:	80 81       	ld	r24, Z
    e98c:	88 23       	and	r24, r24
    e98e:	d1 f4       	brne	.+52     	; 0xe9c4 <FSettingPumpID+0x1da>
	     (*Value)--;
	 }else *Value=MaxValue;
    e990:	83 e6       	ldi	r24, 0x63	; 99
    e992:	1b c0       	rjmp	.+54     	; 0xe9ca <FSettingPumpID+0x1e0>
			       if (IsShift==False)IncValue(&PPumpId[KeyChar-'1'],0,99);//PPumpId[KeyChar-'1']=((PPumpId[KeyChar-'1']+1)%100);
				   else
				   if (IsShift==True)DecValue(&PPumpId[KeyChar-'1'],0,99);//PPumpId[KeyChar-'1']=100-(100-((PPumpId[KeyChar-'1']+1)%100));
			       break;
              case IT_STANDALONE:
			       if (IsShift==False)IncValue(&PPumpId[KeyChar-'1'],0,16);//PPumpId[KeyChar-'1']=((PPumpId[KeyChar-'1']+1)%16);
    e994:	80 91 dd 02 	lds	r24, 0x02DD
    e998:	88 23       	and	r24, r24
    e99a:	59 f4       	brne	.+22     	; 0xe9b2 <FSettingPumpID+0x1c8>
    e99c:	e9 2f       	mov	r30, r25
    e99e:	f0 e0       	ldi	r31, 0x00	; 0
    e9a0:	ed 55       	subi	r30, 0x5D	; 93
    e9a2:	fd 4f       	sbci	r31, 0xFD	; 253
		}
	}
}

void IncValue(char *Value,char MinValue,char MaxValue){
     if ((*Value)<MaxValue){
    e9a4:	80 81       	ld	r24, Z
    e9a6:	80 31       	cpi	r24, 0x10	; 16
    e9a8:	10 f4       	brcc	.+4      	; 0xe9ae <FSettingPumpID+0x1c4>
	     (*Value)++;
    e9aa:	8f 5f       	subi	r24, 0xFF	; 255
    e9ac:	0e c0       	rjmp	.+28     	; 0xe9ca <FSettingPumpID+0x1e0>
	 }else *Value=MinValue;
    e9ae:	10 82       	st	Z, r1
    e9b0:	0d c0       	rjmp	.+26     	; 0xe9cc <FSettingPumpID+0x1e2>
				   if (IsShift==True)DecValue(&PPumpId[KeyChar-'1'],0,99);//PPumpId[KeyChar-'1']=100-(100-((PPumpId[KeyChar-'1']+1)%100));
			       break;
              case IT_STANDALONE:
			       if (IsShift==False)IncValue(&PPumpId[KeyChar-'1'],0,16);//PPumpId[KeyChar-'1']=((PPumpId[KeyChar-'1']+1)%16);
				   else
				   if (IsShift==True)DecValue(&PPumpId[KeyChar-'1'],0,16);//PPumpId[KeyChar-'1']=17-(17-((PPumpId[KeyChar-'1']+1)%17));
    e9b2:	81 30       	cpi	r24, 0x01	; 1
    e9b4:	59 f4       	brne	.+22     	; 0xe9cc <FSettingPumpID+0x1e2>
    e9b6:	e9 2f       	mov	r30, r25
    e9b8:	f0 e0       	ldi	r31, 0x00	; 0
    e9ba:	ed 55       	subi	r30, 0x5D	; 93
    e9bc:	fd 4f       	sbci	r31, 0xFD	; 253
	     (*Value)++;
	 }else *Value=MinValue;
}

void DecValue(char *Value,char MinValue,char MaxValue){
     if ((*Value)>MinValue){
    e9be:	80 81       	ld	r24, Z
    e9c0:	88 23       	and	r24, r24
    e9c2:	11 f0       	breq	.+4      	; 0xe9c8 <FSettingPumpID+0x1de>
	     (*Value)--;
    e9c4:	81 50       	subi	r24, 0x01	; 1
    e9c6:	01 c0       	rjmp	.+2      	; 0xe9ca <FSettingPumpID+0x1e0>
	 }else *Value=MaxValue;
    e9c8:	80 e1       	ldi	r24, 0x10	; 16
    e9ca:	80 83       	st	Z, r24
    e9cc:	f4 ed       	ldi	r31, 0xD4	; 212
    e9ce:	ef 2e       	mov	r14, r31
    e9d0:	f2 e0       	ldi	r31, 0x02	; 2
    e9d2:	ff 2e       	mov	r15, r31
    e9d4:	01 e0       	ldi	r16, 0x01	; 1
    e9d6:	10 e0       	ldi	r17, 0x00	; 0
				   if (IsShift==True)DecValue(&PPumpId[KeyChar-'1'],0,16);//PPumpId[KeyChar-'1']=17-(17-((PPumpId[KeyChar-'1']+1)%17));
			       break;			  
			  }
			  //Redraw
			  for (iLoop=0;iLoop<4;iLoop++){
				  sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d"),(iLoop+1),PPumpId[iLoop],(iLoop+5),PPumpId[iLoop+4]);
    e9d8:	6e 01       	movw	r12, r28
    e9da:	08 94       	sec
    e9dc:	c1 1c       	adc	r12, r1
    e9de:	d1 1c       	adc	r13, r1
    e9e0:	ed e7       	ldi	r30, 0x7D	; 125
    e9e2:	ae 2e       	mov	r10, r30
    e9e4:	ec e0       	ldi	r30, 0x0C	; 12
    e9e6:	be 2e       	mov	r11, r30
    e9e8:	8d b7       	in	r24, 0x3d	; 61
    e9ea:	9e b7       	in	r25, 0x3e	; 62
    e9ec:	0c 97       	sbiw	r24, 0x0c	; 12
    e9ee:	0f b6       	in	r0, 0x3f	; 63
    e9f0:	f8 94       	cli
    e9f2:	9e bf       	out	0x3e, r25	; 62
    e9f4:	0f be       	out	0x3f, r0	; 63
    e9f6:	8d bf       	out	0x3d, r24	; 61
    e9f8:	ed b7       	in	r30, 0x3d	; 61
    e9fa:	fe b7       	in	r31, 0x3e	; 62
    e9fc:	31 96       	adiw	r30, 0x01	; 1
    e9fe:	ad b7       	in	r26, 0x3d	; 61
    ea00:	be b7       	in	r27, 0x3e	; 62
    ea02:	12 96       	adiw	r26, 0x02	; 2
    ea04:	dc 92       	st	X, r13
    ea06:	ce 92       	st	-X, r12
    ea08:	11 97       	sbiw	r26, 0x01	; 1
    ea0a:	b3 82       	std	Z+3, r11	; 0x03
    ea0c:	a2 82       	std	Z+2, r10	; 0x02
    ea0e:	15 83       	std	Z+5, r17	; 0x05
    ea10:	04 83       	std	Z+4, r16	; 0x04
    ea12:	d7 01       	movw	r26, r14
    ea14:	8c 91       	ld	r24, X
    ea16:	86 83       	std	Z+6, r24	; 0x06
    ea18:	17 82       	std	Z+7, r1	; 0x07
    ea1a:	0c 5f       	subi	r16, 0xFC	; 252
    ea1c:	1f 4f       	sbci	r17, 0xFF	; 255
    ea1e:	11 87       	std	Z+9, r17	; 0x09
    ea20:	00 87       	std	Z+8, r16	; 0x08
    ea22:	04 50       	subi	r16, 0x04	; 4
    ea24:	10 40       	sbci	r17, 0x00	; 0
    ea26:	14 96       	adiw	r26, 0x04	; 4
    ea28:	8c 91       	ld	r24, X
    ea2a:	82 87       	std	Z+10, r24	; 0x0a
    ea2c:	13 86       	std	Z+11, r1	; 0x0b
    ea2e:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
				  lcd_print((iLoop+1),1,lcdteks);
    ea32:	ed b7       	in	r30, 0x3d	; 61
    ea34:	fe b7       	in	r31, 0x3e	; 62
    ea36:	3c 96       	adiw	r30, 0x0c	; 12
    ea38:	0f b6       	in	r0, 0x3f	; 63
    ea3a:	f8 94       	cli
    ea3c:	fe bf       	out	0x3e, r31	; 62
    ea3e:	0f be       	out	0x3f, r0	; 63
    ea40:	ed bf       	out	0x3d, r30	; 61
    ea42:	80 2f       	mov	r24, r16
    ea44:	61 e0       	ldi	r22, 0x01	; 1
    ea46:	a6 01       	movw	r20, r12
    ea48:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
    ea4c:	08 94       	sec
    ea4e:	e1 1c       	adc	r14, r1
    ea50:	f1 1c       	adc	r15, r1
    ea52:	0f 5f       	subi	r16, 0xFF	; 255
    ea54:	1f 4f       	sbci	r17, 0xFF	; 255
				   else
				   if (IsShift==True)DecValue(&PPumpId[KeyChar-'1'],0,16);//PPumpId[KeyChar-'1']=17-(17-((PPumpId[KeyChar-'1']+1)%17));
			       break;			  
			  }
			  //Redraw
			  for (iLoop=0;iLoop<4;iLoop++){
    ea56:	f8 ed       	ldi	r31, 0xD8	; 216
    ea58:	ef 16       	cp	r14, r31
    ea5a:	f2 e0       	ldi	r31, 0x02	; 2
    ea5c:	ff 06       	cpc	r15, r31
    ea5e:	21 f6       	brne	.-120    	; 0xe9e8 <FSettingPumpID+0x1fe>
    ea60:	2b c0       	rjmp	.+86     	; 0xeab8 <FSettingPumpID+0x2ce>
				  sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d"),(iLoop+1),PPumpId[iLoop],(iLoop+5),PPumpId[iLoop+4]);
				  lcd_print((iLoop+1),1,lcdteks);
	          }
		  }else if (KeyChar=='#'){
    ea62:	93 32       	cpi	r25, 0x23	; 35
    ea64:	21 f5       	brne	.+72     	; 0xeaae <FSettingPumpID+0x2c4>
    ea66:	40 e0       	ldi	r20, 0x00	; 0
    ea68:	20 e0       	ldi	r18, 0x00	; 0
    ea6a:	30 e0       	ldi	r19, 0x00	; 0
    ea6c:	52 2f       	mov	r21, r18
		      //Evaluate same PumpID
			  PumpCount=0;
			  for (i=0;i<8;i++){
			       CheckPump=PPumpId[i];
    ea6e:	f9 01       	movw	r30, r18
    ea70:	ec 52       	subi	r30, 0x2C	; 44
    ea72:	fd 4f       	sbci	r31, 0xFD	; 253
    ea74:	e0 81       	ld	r30, Z
				   if (CheckPump>0){
    ea76:	ee 23       	and	r30, r30
    ea78:	69 f0       	breq	.+26     	; 0xea94 <FSettingPumpID+0x2aa>
    ea7a:	a4 ed       	ldi	r26, 0xD4	; 212
    ea7c:	b2 e0       	ldi	r27, 0x02	; 2
    ea7e:	90 e0       	ldi	r25, 0x00	; 0
				      for(j=0;j<8;j++){					      
					      if ((i!=j)&&(CheckPump==PPumpId[j]))
    ea80:	59 17       	cp	r21, r25
    ea82:	21 f0       	breq	.+8      	; 0xea8c <FSettingPumpID+0x2a2>
    ea84:	8c 91       	ld	r24, X
    ea86:	e8 17       	cp	r30, r24
    ea88:	09 f4       	brne	.+2      	; 0xea8c <FSettingPumpID+0x2a2>
						       PumpCount++;
    ea8a:	4f 5f       	subi	r20, 0xFF	; 255
		      //Evaluate same PumpID
			  PumpCount=0;
			  for (i=0;i<8;i++){
			       CheckPump=PPumpId[i];
				   if (CheckPump>0){
				      for(j=0;j<8;j++){					      
    ea8c:	9f 5f       	subi	r25, 0xFF	; 255
    ea8e:	11 96       	adiw	r26, 0x01	; 1
    ea90:	98 30       	cpi	r25, 0x08	; 8
    ea92:	b1 f7       	brne	.-20     	; 0xea80 <FSettingPumpID+0x296>
    ea94:	2f 5f       	subi	r18, 0xFF	; 255
    ea96:	3f 4f       	sbci	r19, 0xFF	; 255
				  lcd_print((iLoop+1),1,lcdteks);
	          }
		  }else if (KeyChar=='#'){
		      //Evaluate same PumpID
			  PumpCount=0;
			  for (i=0;i<8;i++){
    ea98:	28 30       	cpi	r18, 0x08	; 8
    ea9a:	31 05       	cpc	r19, r1
    ea9c:	39 f7       	brne	.-50     	; 0xea6c <FSettingPumpID+0x282>
    ea9e:	40 93 d2 02 	sts	0x02D2, r20
					      if ((i!=j)&&(CheckPump==PPumpId[j]))
						       PumpCount++;
					  }
				    }				     
				  }			       			  			  
			  if (PumpCount>0) stMenuPumpID=mpSaveFailed;
    eaa2:	44 23       	and	r20, r20
    eaa4:	11 f0       	breq	.+4      	; 0xeaaa <FSettingPumpID+0x2c0>
    eaa6:	83 e0       	ldi	r24, 0x03	; 3
    eaa8:	05 c0       	rjmp	.+10     	; 0xeab4 <FSettingPumpID+0x2ca>
			  else stMenuPumpID=mpSavingPumpId;
    eaaa:	85 e0       	ldi	r24, 0x05	; 5
    eaac:	03 c0       	rjmp	.+6      	; 0xeab4 <FSettingPumpID+0x2ca>
		  }	
		  else if (KeyChar=='*'){
    eaae:	9a 32       	cpi	r25, 0x2A	; 42
    eab0:	19 f4       	brne	.+6      	; 0xeab8 <FSettingPumpID+0x2ce>
		      stMenuPumpID=mpExitPumpId;
    eab2:	8a e0       	ldi	r24, 0x0A	; 10
    eab4:	80 93 de 02 	sts	0x02DE, r24
		  }
		  if (KeyPressed==_KEY_SHIFT){
    eab8:	8b e7       	ldi	r24, 0x7B	; 123
    eaba:	98 16       	cp	r9, r24
    eabc:	09 f0       	breq	.+2      	; 0xeac0 <FSettingPumpID+0x2d6>
    eabe:	2c c1       	rjmp	.+600    	; 0xed18 <FSettingPumpID+0x52e>
		      if (IsShift==False)IsShift=True;
    eac0:	80 91 dd 02 	lds	r24, 0x02DD
    eac4:	88 23       	and	r24, r24
    eac6:	21 f4       	brne	.+8      	; 0xead0 <FSettingPumpID+0x2e6>
    eac8:	81 e0       	ldi	r24, 0x01	; 1
    eaca:	80 93 dd 02 	sts	0x02DD, r24
    eace:	24 c1       	rjmp	.+584    	; 0xed18 <FSettingPumpID+0x52e>
			  else
			  if (IsShift==True)IsShift=False;
    ead0:	81 30       	cpi	r24, 0x01	; 1
    ead2:	09 f0       	breq	.+2      	; 0xead6 <FSettingPumpID+0x2ec>
    ead4:	21 c1       	rjmp	.+578    	; 0xed18 <FSettingPumpID+0x52e>
    ead6:	10 92 dd 02 	sts	0x02DD, r1
    eada:	1e c1       	rjmp	.+572    	; 0xed18 <FSettingPumpID+0x52e>
		  }
	      break;
     case mpSaveFailed:
	      lcd_clear();
    eadc:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
		  lcd_printf(1,1,PSTR("      Warning!      "));
    eae0:	81 e0       	ldi	r24, 0x01	; 1
    eae2:	61 e0       	ldi	r22, 0x01	; 1
    eae4:	48 e6       	ldi	r20, 0x68	; 104
    eae6:	5c e0       	ldi	r21, 0x0C	; 12
    eae8:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		  lcd_printf(2,1,PSTR("  Duplicate PumpID  "));
    eaec:	82 e0       	ldi	r24, 0x02	; 2
    eaee:	61 e0       	ldi	r22, 0x01	; 1
    eaf0:	43 e5       	ldi	r20, 0x53	; 83
    eaf2:	5c e0       	ldi	r21, 0x0C	; 12
    eaf4:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		  lcd_printf(3,1,PSTR("    Not Allowed     "));		  
    eaf8:	83 e0       	ldi	r24, 0x03	; 3
    eafa:	61 e0       	ldi	r22, 0x01	; 1
    eafc:	4e e3       	ldi	r20, 0x3E	; 62
    eafe:	5c e0       	ldi	r21, 0x0C	; 12
    eb00:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    eb04:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    eb06:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    eb08:	82 e0       	ldi	r24, 0x02	; 2
    eb0a:	90 e0       	ldi	r25, 0x00	; 0
    eb0c:	90 93 d7 01 	sts	0x01D7, r25
    eb10:	80 93 d6 01 	sts	0x01D6, r24
	      lcd_clear();
		  lcd_printf(1,1,PSTR("      Warning!      "));
		  lcd_printf(2,1,PSTR("  Duplicate PumpID  "));
		  lcd_printf(3,1,PSTR("    Not Allowed     "));		  
		  system_beep(2);
	      TimDisplay=0;
    eb14:	10 92 a7 01 	sts	0x01A7, r1
	      stMenuPumpID=mpDisplayFailed;
    eb18:	84 e0       	ldi	r24, 0x04	; 4
    eb1a:	e9 c0       	rjmp	.+466    	; 0xecee <FSettingPumpID+0x504>
          break;	 
     case mpDisplayFailed:
	      if (TimDisplay>6) stMenuPumpID=mpDisplayPumpId;
    eb1c:	80 91 a7 01 	lds	r24, 0x01A7
    eb20:	87 30       	cpi	r24, 0x07	; 7
    eb22:	08 f4       	brcc	.+2      	; 0xeb26 <FSettingPumpID+0x33c>
    eb24:	f9 c0       	rjmp	.+498    	; 0xed18 <FSettingPumpID+0x52e>
    eb26:	81 e0       	ldi	r24, 0x01	; 1
    eb28:	e2 c0       	rjmp	.+452    	; 0xecee <FSettingPumpID+0x504>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    eb2a:	85 e4       	ldi	r24, 0x45	; 69
    eb2c:	90 e0       	ldi	r25, 0x00	; 0
    eb2e:	64 ed       	ldi	r22, 0xD4	; 212
    eb30:	72 e0       	ldi	r23, 0x02	; 2
    eb32:	48 e0       	ldi	r20, 0x08	; 8
    eb34:	50 e0       	ldi	r21, 0x00	; 0
    eb36:	2e ef       	ldi	r18, 0xFE	; 254
    eb38:	32 e1       	ldi	r19, 0x12	; 18
    eb3a:	0e 94 96 b5 	call	0x16b2c	; 0x16b2c <__eewr_block>
	      break;
     case mpSavingPumpId:
	      eeprom_write_block((const void*) &PPumpId, (void*) &DefPumpMap, 8);
		  if (IFType==IT_STANDALONE){
    eb3e:	80 91 10 01 	lds	r24, 0x0110
    eb42:	82 30       	cpi	r24, 0x02	; 2
    eb44:	e9 f4       	brne	.+58     	; 0xeb80 <FSettingPumpID+0x396>
		      //SendConfig to Slave
			  lcd_clear();
    eb46:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
              lcd_printf(1,1,PSTR("-PumpID-"));
    eb4a:	81 e0       	ldi	r24, 0x01	; 1
    eb4c:	61 e0       	ldi	r22, 0x01	; 1
    eb4e:	45 e3       	ldi	r20, 0x35	; 53
    eb50:	5c e0       	ldi	r21, 0x0C	; 12
    eb52:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
              lcd_printf(2,1,PSTR("Saving.."));
    eb56:	82 e0       	ldi	r24, 0x02	; 2
    eb58:	61 e0       	ldi	r22, 0x01	; 1
    eb5a:	4c e2       	ldi	r20, 0x2C	; 44
    eb5c:	5c e0       	ldi	r21, 0x0C	; 12
    eb5e:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
			  Idx=0;
    eb62:	10 92 dc 02 	sts	0x02DC, r1
			  PumpCount=0;
    eb66:	10 92 d2 02 	sts	0x02D2, r1
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    eb6a:	84 ed       	ldi	r24, 0xD4	; 212
    eb6c:	92 e0       	ldi	r25, 0x02	; 2
    eb6e:	65 e4       	ldi	r22, 0x45	; 69
    eb70:	70 e0       	ldi	r23, 0x00	; 0
    eb72:	48 e0       	ldi	r20, 0x08	; 8
    eb74:	50 e0       	ldi	r21, 0x00	; 0
    eb76:	26 ef       	ldi	r18, 0xF6	; 246
    eb78:	32 e1       	ldi	r19, 0x12	; 18
    eb7a:	0e 94 7a b5 	call	0x16af4	; 0x16af4 <__eerd_block>
    eb7e:	b6 c0       	rjmp	.+364    	; 0xecec <FSettingPumpID+0x502>
              eeprom_read_block((void*) &PPumpId, (const void*) &DefPumpMap,8);
              stMenuPumpID=mpSendConfigToSlave;
		  }else if (IFType==IT_SLAVE){
    eb80:	81 30       	cpi	r24, 0x01	; 1
    eb82:	09 f0       	breq	.+2      	; 0xeb86 <FSettingPumpID+0x39c>
    eb84:	c9 c0       	rjmp	.+402    	; 0xed18 <FSettingPumpID+0x52e>
    eb86:	ba c0       	rjmp	.+372    	; 0xecfc <FSettingPumpID+0x512>
		      //SendConfig to Slave              
              stMenuPumpID=mpExitPumpId;
		  }
	      break;
     case mpSendConfigToSlave:
	      IsStandaloneAcknoledge=False;
    eb88:	10 92 95 01 	sts	0x0195, r1
	      if (PPumpId[Idx]!=0){
    eb8c:	90 91 dc 02 	lds	r25, 0x02DC
    eb90:	29 2f       	mov	r18, r25
    eb92:	30 e0       	ldi	r19, 0x00	; 0
    eb94:	f9 01       	movw	r30, r18
    eb96:	ec 52       	subi	r30, 0x2C	; 44
    eb98:	fd 4f       	sbci	r31, 0xFD	; 253
    eb9a:	60 81       	ld	r22, Z
    eb9c:	66 23       	and	r22, r22
    eb9e:	81 f0       	breq	.+32     	; 0xebc0 <FSettingPumpID+0x3d6>
		      PumpCount++;
    eba0:	80 91 d2 02 	lds	r24, 0x02D2
    eba4:	8f 5f       	subi	r24, 0xFF	; 255
    eba6:	80 93 d2 02 	sts	0x02D2, r24
		      MsgPumpId=((Idx<<4)|(0x0F&PPumpId[Idx]));//[Idx][PumpId]
    ebaa:	6f 70       	andi	r22, 0x0F	; 15
    ebac:	74 e0       	ldi	r23, 0x04	; 4
    ebae:	22 0f       	add	r18, r18
    ebb0:	33 1f       	adc	r19, r19
    ebb2:	7a 95       	dec	r23
    ebb4:	e1 f7       	brne	.-8      	; 0xebae <FSettingPumpID+0x3c4>
    ebb6:	62 2b       	or	r22, r18
    ebb8:	60 93 d3 02 	sts	0x02D3, r22
	         //SendPoolingCommand(SC_SET_PUMPID,MsgPumpId);
			  SendSlaveCommand(SC_SET_PUMPID,MsgPumpId);
    ebbc:	8d e1       	ldi	r24, 0x1D	; 29
    ebbe:	02 c0       	rjmp	.+4      	; 0xebc4 <FSettingPumpID+0x3da>
		  }else SendSlaveCommand(SC_CLEAR_PUMPID,Idx);//SendPoolingCommand(SC_CLEAR_PUMPID,Idx);
    ebc0:	8e e1       	ldi	r24, 0x1E	; 30
    ebc2:	69 2f       	mov	r22, r25
    ebc4:	0e 94 de 73 	call	0xe7bc	; 0xe7bc <SendSlaveCommand>
		  sprintf_P(lcdteks,PSTR("Id[%d]=%.2d  "),Idx+1,PPumpId[Idx]);
    ebc8:	e0 91 dc 02 	lds	r30, 0x02DC
    ebcc:	f0 e0       	ldi	r31, 0x00	; 0
    ebce:	ad b7       	in	r26, 0x3d	; 61
    ebd0:	be b7       	in	r27, 0x3e	; 62
    ebd2:	18 97       	sbiw	r26, 0x08	; 8
    ebd4:	0f b6       	in	r0, 0x3f	; 63
    ebd6:	f8 94       	cli
    ebd8:	be bf       	out	0x3e, r27	; 62
    ebda:	0f be       	out	0x3f, r0	; 63
    ebdc:	ad bf       	out	0x3d, r26	; 61
    ebde:	2d b7       	in	r18, 0x3d	; 61
    ebe0:	3e b7       	in	r19, 0x3e	; 62
    ebe2:	2f 5f       	subi	r18, 0xFF	; 255
    ebe4:	3f 4f       	sbci	r19, 0xFF	; 255
    ebe6:	8e 01       	movw	r16, r28
    ebe8:	0f 5f       	subi	r16, 0xFF	; 255
    ebea:	1f 4f       	sbci	r17, 0xFF	; 255
    ebec:	12 96       	adiw	r26, 0x02	; 2
    ebee:	1c 93       	st	X, r17
    ebf0:	0e 93       	st	-X, r16
    ebf2:	11 97       	sbiw	r26, 0x01	; 1
    ebf4:	8e e1       	ldi	r24, 0x1E	; 30
    ebf6:	9c e0       	ldi	r25, 0x0C	; 12
    ebf8:	d9 01       	movw	r26, r18
    ebfa:	13 96       	adiw	r26, 0x03	; 3
    ebfc:	9c 93       	st	X, r25
    ebfe:	8e 93       	st	-X, r24
    ec00:	12 97       	sbiw	r26, 0x02	; 2
    ec02:	31 96       	adiw	r30, 0x01	; 1
    ec04:	15 96       	adiw	r26, 0x05	; 5
    ec06:	fc 93       	st	X, r31
    ec08:	ee 93       	st	-X, r30
    ec0a:	14 97       	sbiw	r26, 0x04	; 4
    ec0c:	31 97       	sbiw	r30, 0x01	; 1
    ec0e:	ec 52       	subi	r30, 0x2C	; 44
    ec10:	fd 4f       	sbci	r31, 0xFD	; 253
    ec12:	80 81       	ld	r24, Z
    ec14:	16 96       	adiw	r26, 0x06	; 6
    ec16:	8c 93       	st	X, r24
    ec18:	16 97       	sbiw	r26, 0x06	; 6
    ec1a:	17 96       	adiw	r26, 0x07	; 7
    ec1c:	1c 92       	st	X, r1
    ec1e:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
		  lcd_print(3,1,lcdteks);
    ec22:	ed b7       	in	r30, 0x3d	; 61
    ec24:	fe b7       	in	r31, 0x3e	; 62
    ec26:	38 96       	adiw	r30, 0x08	; 8
    ec28:	0f b6       	in	r0, 0x3f	; 63
    ec2a:	f8 94       	cli
    ec2c:	fe bf       	out	0x3e, r31	; 62
    ec2e:	0f be       	out	0x3f, r0	; 63
    ec30:	ed bf       	out	0x3d, r30	; 61
    ec32:	83 e0       	ldi	r24, 0x03	; 3
    ec34:	61 e0       	ldi	r22, 0x01	; 1
    ec36:	a8 01       	movw	r20, r16
    ec38:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
          stMenuPumpID=mpWaitSlaveReply;
    ec3c:	88 e0       	ldi	r24, 0x08	; 8
    ec3e:	57 c0       	rjmp	.+174    	; 0xecee <FSettingPumpID+0x504>
	      break;
     case mpWaitSlaveReply:
	      KeyPressed=_key_scan(1);
    ec40:	81 e0       	ldi	r24, 0x01	; 1
    ec42:	0e 94 06 b0 	call	0x1600c	; 0x1600c <_key_scan>
	      KeyChar=_key_btn(KeyPressed);
    ec46:	0e 94 67 af 	call	0x15ece	; 0x15ece <_key_btn>
		  if (KeyChar=='*'){
    ec4a:	8a 32       	cpi	r24, 0x2A	; 42
    ec4c:	99 f4       	brne	.+38     	; 0xec74 <FSettingPumpID+0x48a>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    ec4e:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    ec50:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    ec52:	82 e0       	ldi	r24, 0x02	; 2
    ec54:	90 e0       	ldi	r25, 0x00	; 0
    ec56:	90 93 d7 01 	sts	0x01D7, r25
    ec5a:	80 93 d6 01 	sts	0x01D6, r24
     case mpWaitSlaveReply:
	      KeyPressed=_key_scan(1);
	      KeyChar=_key_btn(KeyPressed);
		  if (KeyChar=='*'){
		      system_beep(2);
		      lcd_printf(2,1,PSTR("Cancel     "));
    ec5e:	82 e0       	ldi	r24, 0x02	; 2
    ec60:	61 e0       	ldi	r22, 0x01	; 1
    ec62:	42 e1       	ldi	r20, 0x12	; 18
    ec64:	5c e0       	ldi	r21, 0x0C	; 12
    ec66:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
			  TimDisplay=0;
    ec6a:	10 92 a7 01 	sts	0x01A7, r1
		      stMenuPumpID=mpDelayExitPumpId;
    ec6e:	89 e0       	ldi	r24, 0x09	; 9
    ec70:	80 93 de 02 	sts	0x02DE, r24
			  }
          if (IsStandaloneAcknoledge==True){
    ec74:	80 91 95 01 	lds	r24, 0x0195
    ec78:	81 30       	cpi	r24, 0x01	; 1
    ec7a:	09 f0       	breq	.+2      	; 0xec7e <FSettingPumpID+0x494>
    ec7c:	4d c0       	rjmp	.+154    	; 0xed18 <FSettingPumpID+0x52e>
		      Idx++;
    ec7e:	80 91 dc 02 	lds	r24, 0x02DC
    ec82:	8f 5f       	subi	r24, 0xFF	; 255
    ec84:	80 93 dc 02 	sts	0x02DC, r24
		      if (Idx<8){//Finish, Send MaxPumpCount
    ec88:	88 30       	cpi	r24, 0x08	; 8
    ec8a:	10 f5       	brcc	.+68     	; 0xecd0 <FSettingPumpID+0x4e6>
			      eeprom_write_byte(&DefPoolingPumpMax,PumpCount);
    ec8c:	20 91 d2 02 	lds	r18, 0x02D2
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    ec90:	e1 99       	sbic	0x1c, 1	; 28
    ec92:	fe cf       	rjmp	.-4      	; 0xec90 <FSettingPumpID+0x4a6>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    ec94:	84 e4       	ldi	r24, 0x44	; 68
    ec96:	91 e0       	ldi	r25, 0x01	; 1
    ec98:	9f bb       	out	0x1f, r25	; 31
    ec9a:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    ec9c:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
    ec9e:	0f b6       	in	r0, 0x3f	; 63
    eca0:	f8 94       	cli
    eca2:	e2 9a       	sbi	0x1c, 2	; 28
    eca4:	e1 9a       	sbi	0x1c, 1	; 28
    eca6:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    eca8:	e1 99       	sbic	0x1c, 1	; 28
    ecaa:	fe cf       	rjmp	.-4      	; 0xeca8 <FSettingPumpID+0x4be>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    ecac:	9f bb       	out	0x1f, r25	; 31
    ecae:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    ecb0:	e0 9a       	sbi	0x1c, 0	; 28
    ecb2:	9d b3       	in	r25, 0x1d	; 29
				  PumpCountMax=eeprom_read_byte(&DefPoolingPumpMax);
    ecb4:	90 93 5f 01 	sts	0x015F, r25
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    ecb8:	85 e1       	ldi	r24, 0x15	; 21
    ecba:	80 93 8a 07 	sts	0x078A, r24
	 PoolMsg=plMsg;
    ecbe:	90 93 ae 0d 	sts	0x0DAE, r25
     IsControlPooling=True;
    ecc2:	81 e0       	ldi	r24, 0x01	; 1
    ecc4:	80 93 97 01 	sts	0x0197, r24
		      Idx++;
		      if (Idx<8){//Finish, Send MaxPumpCount
			      eeprom_write_byte(&DefPoolingPumpMax,PumpCount);
				  PumpCountMax=eeprom_read_byte(&DefPoolingPumpMax);
                  SendPoolingCommand(SC_SET_POOLING_MAX_PUMP,PumpCountMax);
			      TimDisplay=0;		 
    ecc8:	10 92 a7 01 	sts	0x01A7, r1
				  stMenuPumpID=mpDelaySaveConfig;
    eccc:	87 e0       	ldi	r24, 0x07	; 7
    ecce:	0f c0       	rjmp	.+30     	; 0xecee <FSettingPumpID+0x504>
			  }else{lcd_printf(2,1,PSTR("Completed"));
    ecd0:	82 e0       	ldi	r24, 0x02	; 2
    ecd2:	61 e0       	ldi	r22, 0x01	; 1
    ecd4:	48 e0       	ldi	r20, 0x08	; 8
    ecd6:	5c e0       	ldi	r21, 0x0C	; 12
    ecd8:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
					TimDisplay=0;
    ecdc:	10 92 a7 01 	sts	0x01A7, r1
				    stMenuPumpID=mpDelayExitPumpId;
    ece0:	89 e0       	ldi	r24, 0x09	; 9
    ece2:	05 c0       	rjmp	.+10     	; 0xecee <FSettingPumpID+0x504>
				   }
			  }		  
	      break;
     case mpDelaySaveConfig:
	      if (TimDisplay>2)stMenuPumpID=mpSendConfigToSlave;
    ece4:	80 91 a7 01 	lds	r24, 0x01A7
    ece8:	83 30       	cpi	r24, 0x03	; 3
    ecea:	b0 f0       	brcs	.+44     	; 0xed18 <FSettingPumpID+0x52e>
    ecec:	86 e0       	ldi	r24, 0x06	; 6
    ecee:	80 93 de 02 	sts	0x02DE, r24
    ecf2:	12 c0       	rjmp	.+36     	; 0xed18 <FSettingPumpID+0x52e>
	      break;
     case mpDelayExitPumpId:
	      if (TimDisplay>8)stMenuPumpID=mpExitPumpId;
    ecf4:	80 91 a7 01 	lds	r24, 0x01A7
    ecf8:	89 30       	cpi	r24, 0x09	; 9
    ecfa:	70 f0       	brcs	.+28     	; 0xed18 <FSettingPumpID+0x52e>
    ecfc:	8a e0       	ldi	r24, 0x0A	; 10
    ecfe:	f7 cf       	rjmp	.-18     	; 0xecee <FSettingPumpID+0x504>
	      break;
     case mpExitPumpId:
	      if (IFType==IT_STANDALONE)
    ed00:	80 91 10 01 	lds	r24, 0x0110
    ed04:	82 30       	cpi	r24, 0x02	; 2
    ed06:	21 f4       	brne	.+8      	; 0xed10 <FSettingPumpID+0x526>
		      SendSlaveCommand(SC_START_POOL_SEQUENCE,0);
    ed08:	80 e2       	ldi	r24, 0x20	; 32
    ed0a:	60 e0       	ldi	r22, 0x00	; 0
    ed0c:	0e 94 de 73 	call	0xe7bc	; 0xe7bc <SendSlaveCommand>
	      Result=MENU_DONE;
          stMenuPumpID=mpInitPumpId;
    ed10:	10 92 de 02 	sts	0x02DE, r1
    ed14:	81 e0       	ldi	r24, 0x01	; 1
    ed16:	01 c0       	rjmp	.+2      	; 0xed1a <FSettingPumpID+0x530>
    ed18:	80 e0       	ldi	r24, 0x00	; 0
	      break;
	 }
   return Result;
}
    ed1a:	64 96       	adiw	r28, 0x14	; 20
    ed1c:	0f b6       	in	r0, 0x3f	; 63
    ed1e:	f8 94       	cli
    ed20:	de bf       	out	0x3e, r29	; 62
    ed22:	0f be       	out	0x3f, r0	; 63
    ed24:	cd bf       	out	0x3d, r28	; 61
    ed26:	cf 91       	pop	r28
    ed28:	df 91       	pop	r29
    ed2a:	1f 91       	pop	r17
    ed2c:	0f 91       	pop	r16
    ed2e:	ff 90       	pop	r15
    ed30:	ef 90       	pop	r14
    ed32:	df 90       	pop	r13
    ed34:	cf 90       	pop	r12
    ed36:	bf 90       	pop	r11
    ed38:	af 90       	pop	r10
    ed3a:	9f 90       	pop	r9
    ed3c:	08 95       	ret

0000ed3e <_menu_pumpid>:

void _menu_pumpid(void){
	while(1){
	   if (FSettingPumpID()==MENU_DONE){
    ed3e:	0e 94 f5 73 	call	0xe7ea	; 0xe7ea <FSettingPumpID>
    ed42:	81 30       	cpi	r24, 0x01	; 1
    ed44:	e1 f7       	brne	.-8      	; 0xed3e <_menu_pumpid>
	       break;
	   }	   
	}
}
    ed46:	08 95       	ret

0000ed48 <_menu_pump>:
        lcd_printf(4,15,PSTR("*)Exit"));
}



void _menu_pump(void){
    ed48:	cf 93       	push	r28
    ed4a:	df 93       	push	r29
    ed4c:	c4 ec       	ldi	r28, 0xC4	; 196
    ed4e:	d9 e0       	ldi	r29, 0x09	; 9
	char __key;

	while(1){
		lcd_clear();_delay_ms(10);
    ed50:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
    ed54:	ce 01       	movw	r24, r28
    ed56:	01 97       	sbiw	r24, 0x01	; 1
    ed58:	f1 f7       	brne	.-4      	; 0xed56 <_menu_pump+0xe>
		lcd_printf(1, 1, PSTR("1)ID"));
    ed5a:	81 e0       	ldi	r24, 0x01	; 1
    ed5c:	61 e0       	ldi	r22, 0x01	; 1
    ed5e:	4c e3       	ldi	r20, 0x3C	; 60
    ed60:	5d e0       	ldi	r21, 0x0D	; 13
    ed62:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		lcd_printf(2, 1, PSTR("2)Product"));
    ed66:	82 e0       	ldi	r24, 0x02	; 2
    ed68:	61 e0       	ldi	r22, 0x01	; 1
    ed6a:	42 e3       	ldi	r20, 0x32	; 50
    ed6c:	5d e0       	ldi	r21, 0x0D	; 13
    ed6e:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		lcd_printf(4, 1, PSTR("*)Exit"));
    ed72:	84 e0       	ldi	r24, 0x04	; 4
    ed74:	61 e0       	ldi	r22, 0x01	; 1
    ed76:	4b e2       	ldi	r20, 0x2B	; 43
    ed78:	5d e0       	ldi	r21, 0x0D	; 13
    ed7a:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>

		while(1){
			__key = _key_scan(1);
    ed7e:	81 e0       	ldi	r24, 0x01	; 1
    ed80:	0e 94 06 b0 	call	0x1600c	; 0x1600c <_key_scan>
			if(__key == _KEY_CANCEL)
    ed84:	87 3e       	cpi	r24, 0xE7	; 231
    ed86:	51 f0       	breq	.+20     	; 0xed9c <_menu_pump+0x54>
				return;
			if(__key == _KEY_1){
    ed88:	8e 3e       	cpi	r24, 0xEE	; 238
    ed8a:	19 f4       	brne	.+6      	; 0xed92 <_menu_pump+0x4a>
				_menu_pumpid();
    ed8c:	0e 94 9f 76 	call	0xed3e	; 0xed3e <_menu_pumpid>
    ed90:	df cf       	rjmp	.-66     	; 0xed50 <_menu_pump+0x8>
				break;
			}
			if(__key == _KEY_2){
    ed92:	8e 3d       	cpi	r24, 0xDE	; 222
    ed94:	a1 f7       	brne	.-24     	; 0xed7e <_menu_pump+0x36>
				_menu_pumpprod();
    ed96:	0e 94 5e 49 	call	0x92bc	; 0x92bc <_menu_pumpprod>
    ed9a:	da cf       	rjmp	.-76     	; 0xed50 <_menu_pump+0x8>
				break;
			}
		}
	}
}
    ed9c:	df 91       	pop	r29
    ed9e:	cf 91       	pop	r28
    eda0:	08 95       	ret

0000eda2 <FMenuPumpType>:





void FMenuPumpType(){
    eda2:	cf 92       	push	r12
    eda4:	df 92       	push	r13
    eda6:	ef 92       	push	r14
    eda8:	ff 92       	push	r15
    edaa:	0f 93       	push	r16
    edac:	1f 93       	push	r17
    edae:	df 93       	push	r29
    edb0:	cf 93       	push	r28
    edb2:	cd b7       	in	r28, 0x3d	; 61
    edb4:	de b7       	in	r29, 0x3e	; 62
    edb6:	a8 97       	sbiw	r28, 0x28	; 40
    edb8:	0f b6       	in	r0, 0x3f	; 63
    edba:	f8 94       	cli
    edbc:	de bf       	out	0x3e, r29	; 62
    edbe:	0f be       	out	0x3f, r0	; 63
    edc0:	cd bf       	out	0x3d, r28	; 61
     stPumpType=ptInitMenu;
	 IsRunPumpType=True;
	 while(IsRunPumpType==True){
		  switch(stPumpType){
		  case ptInitMenu:
		       lcd_clear();
    edc2:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
			   lcd_printf(1,1,PSTR("-Dispenser Brand-"));
    edc6:	81 e0       	ldi	r24, 0x01	; 1
    edc8:	61 e0       	ldi	r22, 0x01	; 1
    edca:	49 e1       	ldi	r20, 0x19	; 25
    edcc:	5d e0       	ldi	r21, 0x0D	; 13
    edce:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    edd2:	e1 99       	sbic	0x1c, 1	; 28
    edd4:	fe cf       	rjmp	.-4      	; 0xedd2 <FMenuPumpType+0x30>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    edd6:	87 e3       	ldi	r24, 0x37	; 55
    edd8:	91 e0       	ldi	r25, 0x01	; 1
    edda:	9f bb       	out	0x1f, r25	; 31
    eddc:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    edde:	e0 9a       	sbi	0x1c, 0	; 28
    ede0:	0d b3       	in	r16, 0x1d	; 29
			   IdxType=eeprom_read_byte(&DefDispenserBrand);
			   //Brand Selection
			   if (IdxType>=3) IdxType=0;
    ede2:	03 30       	cpi	r16, 0x03	; 3
    ede4:	08 f0       	brcs	.+2      	; 0xede8 <FMenuPumpType+0x46>
    ede6:	00 e0       	ldi	r16, 0x00	; 0
               strcpy_P(DispenserBrandName,(PGM_P)pgm_read_word(&(DefListDispenserName[IdxType])));
    ede8:	10 e0       	ldi	r17, 0x00	; 0
    edea:	f8 01       	movw	r30, r16
    edec:	ee 0f       	add	r30, r30
    edee:	ff 1f       	adc	r31, r31
    edf0:	e5 5d       	subi	r30, 0xD5	; 213
    edf2:	fc 4f       	sbci	r31, 0xFC	; 252
    edf4:	65 91       	lpm	r22, Z+
    edf6:	74 91       	lpm	r23, Z+
    edf8:	85 e1       	ldi	r24, 0x15	; 21
    edfa:	c8 2e       	mov	r12, r24
    edfc:	d1 2c       	mov	r13, r1
    edfe:	cc 0e       	add	r12, r28
    ee00:	dd 1e       	adc	r13, r29
    ee02:	c6 01       	movw	r24, r12
    ee04:	0e 94 63 b5 	call	0x16ac6	; 0x16ac6 <strcpy_P>
			   sprintf_P(lcdteks,PSTR("%d.%s"),IdxType+1,DispenserBrandName);
    ee08:	8d b7       	in	r24, 0x3d	; 61
    ee0a:	9e b7       	in	r25, 0x3e	; 62
    ee0c:	08 97       	sbiw	r24, 0x08	; 8
    ee0e:	0f b6       	in	r0, 0x3f	; 63
    ee10:	f8 94       	cli
    ee12:	9e bf       	out	0x3e, r25	; 62
    ee14:	0f be       	out	0x3f, r0	; 63
    ee16:	8d bf       	out	0x3d, r24	; 61
    ee18:	ed b7       	in	r30, 0x3d	; 61
    ee1a:	fe b7       	in	r31, 0x3e	; 62
    ee1c:	31 96       	adiw	r30, 0x01	; 1
    ee1e:	7e 01       	movw	r14, r28
    ee20:	08 94       	sec
    ee22:	e1 1c       	adc	r14, r1
    ee24:	f1 1c       	adc	r15, r1
    ee26:	ad b7       	in	r26, 0x3d	; 61
    ee28:	be b7       	in	r27, 0x3e	; 62
    ee2a:	12 96       	adiw	r26, 0x02	; 2
    ee2c:	fc 92       	st	X, r15
    ee2e:	ee 92       	st	-X, r14
    ee30:	11 97       	sbiw	r26, 0x01	; 1
    ee32:	83 e1       	ldi	r24, 0x13	; 19
    ee34:	9d e0       	ldi	r25, 0x0D	; 13
    ee36:	93 83       	std	Z+3, r25	; 0x03
    ee38:	82 83       	std	Z+2, r24	; 0x02
    ee3a:	0f 5f       	subi	r16, 0xFF	; 255
    ee3c:	1f 4f       	sbci	r17, 0xFF	; 255
    ee3e:	15 83       	std	Z+5, r17	; 0x05
    ee40:	04 83       	std	Z+4, r16	; 0x04
    ee42:	d7 82       	std	Z+7, r13	; 0x07
    ee44:	c6 82       	std	Z+6, r12	; 0x06
    ee46:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
			   lcd_print(2,1,lcdteks);
    ee4a:	8d b7       	in	r24, 0x3d	; 61
    ee4c:	9e b7       	in	r25, 0x3e	; 62
    ee4e:	08 96       	adiw	r24, 0x08	; 8
    ee50:	0f b6       	in	r0, 0x3f	; 63
    ee52:	f8 94       	cli
    ee54:	9e bf       	out	0x3e, r25	; 62
    ee56:	0f be       	out	0x3f, r0	; 63
    ee58:	8d bf       	out	0x3d, r24	; 61
    ee5a:	82 e0       	ldi	r24, 0x02	; 2
    ee5c:	61 e0       	ldi	r22, 0x01	; 1
    ee5e:	a7 01       	movw	r20, r14
    ee60:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
			   lcd_printf(4,1,PSTR("[*]Exit  [#]Change "));
    ee64:	84 e0       	ldi	r24, 0x04	; 4
    ee66:	61 e0       	ldi	r22, 0x01	; 1
    ee68:	4f ef       	ldi	r20, 0xFF	; 255
    ee6a:	5c e0       	ldi	r21, 0x0C	; 12
    ee6c:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
			   if (IFType==IT_STANDALONE)
    ee70:	80 91 10 01 	lds	r24, 0x0110
    ee74:	82 30       	cpi	r24, 0x02	; 2
    ee76:	21 f4       	brne	.+8      	; 0xee80 <FMenuPumpType+0xde>
			       SendSlaveCommand(SC_STOP_POOL_SEQUENCE,0);
    ee78:	8f e1       	ldi	r24, 0x1F	; 31
    ee7a:	60 e0       	ldi	r22, 0x00	; 0
    ee7c:	0e 94 de 73 	call	0xe7bc	; 0xe7bc <SendSlaveCommand>
			   stPumpType=ptSelectBrand;
	 		   break;
          case ptSelectBrand:
		       KeyPressed = _key_scan(1);
    ee80:	81 e0       	ldi	r24, 0x01	; 1
    ee82:	0e 94 06 b0 	call	0x1600c	; 0x1600c <_key_scan>
		       KeyChar    = _key_btn(KeyPressed);
    ee86:	0e 94 67 af 	call	0x15ece	; 0x15ece <_key_btn>

			   if (KeyChar=='#'){
    ee8a:	83 32       	cpi	r24, 0x23	; 35
    ee8c:	09 f0       	breq	.+2      	; 0xee90 <FMenuPumpType+0xee>
    ee8e:	2d c0       	rjmp	.+90     	; 0xeeea <FMenuPumpType+0x148>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    ee90:	e1 99       	sbic	0x1c, 1	; 28
    ee92:	fe cf       	rjmp	.-4      	; 0xee90 <FMenuPumpType+0xee>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    ee94:	07 e3       	ldi	r16, 0x37	; 55
    ee96:	11 e0       	ldi	r17, 0x01	; 1
    ee98:	1f bb       	out	0x1f, r17	; 31
    ee9a:	0e bb       	out	0x1e, r16	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    ee9c:	e0 9a       	sbi	0x1c, 0	; 28
    ee9e:	8d b3       	in	r24, 0x1d	; 29
			       DispenserBrand=eeprom_read_byte(&DefDispenserBrand);
				   if (DispenserBrand<ST_WAYNE_DART)
    eea0:	82 30       	cpi	r24, 0x02	; 2
    eea2:	20 f4       	brcc	.+8      	; 0xeeac <FMenuPumpType+0x10a>
				        DispenserBrand++;
    eea4:	8f 5f       	subi	r24, 0xFF	; 255
    eea6:	80 93 61 01 	sts	0x0161, r24
    eeaa:	02 c0       	rjmp	.+4      	; 0xeeb0 <FMenuPumpType+0x10e>
				   else DispenserBrand=ST_NONE;
    eeac:	10 92 61 01 	sts	0x0161, r1
                   //Apply DecimalSetting  
				   SetDispenser(DispenserBrand);
    eeb0:	80 91 61 01 	lds	r24, 0x0161
    eeb4:	0e 94 ff 1a 	call	0x35fe	; 0x35fe <SetDispenser>

			       eeprom_write_byte(&DefDispenserBrand,DispenserBrand);
    eeb8:	80 91 61 01 	lds	r24, 0x0161
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    eebc:	e1 99       	sbic	0x1c, 1	; 28
    eebe:	fe cf       	rjmp	.-4      	; 0xeebc <FMenuPumpType+0x11a>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    eec0:	1f bb       	out	0x1f, r17	; 31
    eec2:	0e bb       	out	0x1e, r16	; 30
#endif
    EEDR = __value;
    eec4:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    eec6:	0f b6       	in	r0, 0x3f	; 63
    eec8:	f8 94       	cli
    eeca:	e2 9a       	sbi	0x1c, 2	; 28
    eecc:	e1 9a       	sbi	0x1c, 1	; 28
    eece:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    eed0:	e1 99       	sbic	0x1c, 1	; 28
    eed2:	fe cf       	rjmp	.-4      	; 0xeed0 <FMenuPumpType+0x12e>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    eed4:	1f bb       	out	0x1f, r17	; 31
    eed6:	0e bb       	out	0x1e, r16	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    eed8:	e0 9a       	sbi	0x1c, 0	; 28
    eeda:	6d b3       	in	r22, 0x1d	; 29
				   //SendPoolingCommand(SC_SET_PUMP_TYPE,eeprom_read_byte(&DefDispenserBrand));
				   SendSlaveCommand(SC_SET_PUMP_TYPE,eeprom_read_byte(&DefDispenserBrand));
    eedc:	8c e1       	ldi	r24, 0x1C	; 28
    eede:	0e 94 de 73 	call	0xe7bc	; 0xe7bc <SendSlaveCommand>
				   IsSetPumpType=True;//False;
    eee2:	81 e0       	ldi	r24, 0x01	; 1
    eee4:	80 93 23 01 	sts	0x0123, r24
    eee8:	0c c0       	rjmp	.+24     	; 0xef02 <FMenuPumpType+0x160>
			       stPumpType=ptUpdated;			   
			   }else
			   if (KeyChar=='*'){
    eeea:	8a 32       	cpi	r24, 0x2A	; 42
    eeec:	09 f0       	breq	.+2      	; 0xeef0 <FMenuPumpType+0x14e>
    eeee:	c8 cf       	rjmp	.-112    	; 0xee80 <FMenuPumpType+0xde>
			       IsRunPumpType=False;
				   if (IFType==IT_STANDALONE)SendSlaveCommand(SC_START_POOL_SEQUENCE,0);
    eef0:	80 91 10 01 	lds	r24, 0x0110
    eef4:	82 30       	cpi	r24, 0x02	; 2
    eef6:	51 f4       	brne	.+20     	; 0xef0c <FMenuPumpType+0x16a>
    eef8:	80 e2       	ldi	r24, 0x20	; 32
    eefa:	60 e0       	ldi	r22, 0x00	; 0
    eefc:	0e 94 de 73 	call	0xe7bc	; 0xe7bc <SendSlaveCommand>
    ef00:	05 c0       	rjmp	.+10     	; 0xef0c <FMenuPumpType+0x16a>
			   }
		       break;
          case ptUpdated:
		       if (IsSetPumpType==True){
    ef02:	80 91 23 01 	lds	r24, 0x0123
    ef06:	81 30       	cpi	r24, 0x01	; 1
    ef08:	e1 f7       	brne	.-8      	; 0xef02 <FMenuPumpType+0x160>
    ef0a:	5b cf       	rjmp	.-330    	; 0xedc2 <FMenuPumpType+0x20>
			       stPumpType=ptInitMenu;
			   }
		       break;		         
	      }
	 }     
}
    ef0c:	a8 96       	adiw	r28, 0x28	; 40
    ef0e:	0f b6       	in	r0, 0x3f	; 63
    ef10:	f8 94       	cli
    ef12:	de bf       	out	0x3e, r29	; 62
    ef14:	0f be       	out	0x3f, r0	; 63
    ef16:	cd bf       	out	0x3d, r28	; 61
    ef18:	cf 91       	pop	r28
    ef1a:	df 91       	pop	r29
    ef1c:	1f 91       	pop	r17
    ef1e:	0f 91       	pop	r16
    ef20:	ff 90       	pop	r15
    ef22:	ef 90       	pop	r14
    ef24:	df 90       	pop	r13
    ef26:	cf 90       	pop	r12
    ef28:	08 95       	ret

0000ef2a <FSettingPump>:
   return Result;
}

char FSettingPump(){
	 char __key,Result;
		lcd_clear();_delay_ms(10);
    ef2a:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
    ef2e:	84 ec       	ldi	r24, 0xC4	; 196
    ef30:	99 e0       	ldi	r25, 0x09	; 9
    ef32:	01 97       	sbiw	r24, 0x01	; 1
    ef34:	f1 f7       	brne	.-4      	; 0xef32 <FSettingPump+0x8>
		lcd_printf(1,1, PSTR("1)ID     "));
    ef36:	81 e0       	ldi	r24, 0x01	; 1
    ef38:	61 e0       	ldi	r22, 0x01	; 1
    ef3a:	4d e8       	ldi	r20, 0x8D	; 141
    ef3c:	51 e1       	ldi	r21, 0x11	; 17
    ef3e:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		lcd_printf(2,1, PSTR("2)Product"));
    ef42:	82 e0       	ldi	r24, 0x02	; 2
    ef44:	61 e0       	ldi	r22, 0x01	; 1
    ef46:	43 e8       	ldi	r20, 0x83	; 131
    ef48:	51 e1       	ldi	r21, 0x11	; 17
    ef4a:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		if (IFType==IT_STANDALONE){
    ef4e:	80 91 10 01 	lds	r24, 0x0110
    ef52:	82 30       	cpi	r24, 0x02	; 2
    ef54:	61 f4       	brne	.+24     	; 0xef6e <FSettingPump+0x44>
		    lcd_printf(3,1, PSTR("3)Label  "));
    ef56:	83 e0       	ldi	r24, 0x03	; 3
    ef58:	61 e0       	ldi	r22, 0x01	; 1
    ef5a:	49 e7       	ldi	r20, 0x79	; 121
    ef5c:	51 e1       	ldi	r21, 0x11	; 17
    ef5e:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		    lcd_printf(4,1, PSTR("4)Brand  *)Exit"));
    ef62:	84 e0       	ldi	r24, 0x04	; 4
    ef64:	61 e0       	ldi	r22, 0x01	; 1
    ef66:	49 e6       	ldi	r20, 0x69	; 105
    ef68:	51 e1       	ldi	r21, 0x11	; 17
    ef6a:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		}

		while(1){
			__key = _key_scan(1);
    ef6e:	81 e0       	ldi	r24, 0x01	; 1
    ef70:	0e 94 06 b0 	call	0x1600c	; 0x1600c <_key_scan>
			if(__key == _KEY_CANCEL)
    ef74:	87 3e       	cpi	r24, 0xE7	; 231
    ef76:	d9 f0       	breq	.+54     	; 0xefae <FSettingPump+0x84>
				break;
			if(__key == _KEY_1){
    ef78:	8e 3e       	cpi	r24, 0xEE	; 238
    ef7a:	19 f4       	brne	.+6      	; 0xef82 <FSettingPump+0x58>
				_menu_pumpid();
    ef7c:	0e 94 9f 76 	call	0xed3e	; 0xed3e <_menu_pumpid>
    ef80:	16 c0       	rjmp	.+44     	; 0xefae <FSettingPump+0x84>
				break;
			}
			if(__key == _KEY_2){
    ef82:	8e 3d       	cpi	r24, 0xDE	; 222
    ef84:	19 f4       	brne	.+6      	; 0xef8c <FSettingPump+0x62>
				_menu_pumpprod();
    ef86:	0e 94 5e 49 	call	0x92bc	; 0x92bc <_menu_pumpprod>
    ef8a:	11 c0       	rjmp	.+34     	; 0xefae <FSettingPump+0x84>
				break;
			}

			if((__key == _KEY_3)&&(IFType==IT_STANDALONE)){
    ef8c:	8e 3b       	cpi	r24, 0xBE	; 190
    ef8e:	39 f4       	brne	.+14     	; 0xef9e <FSettingPump+0x74>
    ef90:	80 91 10 01 	lds	r24, 0x0110
    ef94:	82 30       	cpi	r24, 0x02	; 2
    ef96:	59 f7       	brne	.-42     	; 0xef6e <FSettingPump+0x44>
			    FMenuPumpLabel();
    ef98:	0e 94 87 49 	call	0x930e	; 0x930e <FMenuPumpLabel>
    ef9c:	08 c0       	rjmp	.+16     	; 0xefae <FSettingPump+0x84>
				break;
			}
			if((__key == _KEY_4)&&(IFType==IT_STANDALONE)){
    ef9e:	8d 3e       	cpi	r24, 0xED	; 237
    efa0:	31 f7       	brne	.-52     	; 0xef6e <FSettingPump+0x44>
    efa2:	80 91 10 01 	lds	r24, 0x0110
    efa6:	82 30       	cpi	r24, 0x02	; 2
    efa8:	11 f7       	brne	.-60     	; 0xef6e <FSettingPump+0x44>
			    FMenuPumpType();
    efaa:	0e 94 d1 76 	call	0xeda2	; 0xeda2 <FMenuPumpType>

		}

	Result=MENU_DONE;
	return Result;
}
    efae:	81 e0       	ldi	r24, 0x01	; 1
    efb0:	08 95       	ret

0000efb2 <InitializeConnection>:
void InitMemory(){
     PumpCountMax=eeprom_read_byte(&DefPoolingPumpMax);
	 ActivePump=eeprom_read_byte(&DefActivePump);
}

void InitializeConnection(){
    efb2:	af 92       	push	r10
    efb4:	bf 92       	push	r11
    efb6:	cf 92       	push	r12
    efb8:	df 92       	push	r13
    efba:	ef 92       	push	r14
    efbc:	ff 92       	push	r15
    efbe:	0f 93       	push	r16
    efc0:	1f 93       	push	r17
    efc2:	df 93       	push	r29
    efc4:	cf 93       	push	r28
    efc6:	cd b7       	in	r28, 0x3d	; 61
    efc8:	de b7       	in	r29, 0x3e	; 62
    efca:	64 97       	sbiw	r28, 0x14	; 20
    efcc:	0f b6       	in	r0, 0x3f	; 63
    efce:	f8 94       	cli
    efd0:	de bf       	out	0x3e, r29	; 62
    efd2:	0f be       	out	0x3f, r0	; 63
    efd4:	cd bf       	out	0x3d, r28	; 61
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    efd6:	e1 99       	sbic	0x1c, 1	; 28
    efd8:	fe cf       	rjmp	.-4      	; 0xefd6 <InitializeConnection+0x24>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    efda:	46 e3       	ldi	r20, 0x36	; 54
    efdc:	a4 2e       	mov	r10, r20
    efde:	41 e0       	ldi	r20, 0x01	; 1
    efe0:	b4 2e       	mov	r11, r20
    efe2:	bf ba       	out	0x1f, r11	; 31
    efe4:	ae ba       	out	0x1e, r10	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    efe6:	e0 9a       	sbi	0x1c, 0	; 28
    efe8:	9d b3       	in	r25, 0x1d	; 29
	unsigned int tConnect=0;
	char ForceType=IT_NONE,iCon=0,iTry=0;
	char lcdteks[20];
	IFType=eeprom_read_byte(&DefInitIFT);
    efea:	90 93 10 01 	sts	0x0110, r25
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    efee:	e1 99       	sbic	0x1c, 1	; 28
    eff0:	fe cf       	rjmp	.-4      	; 0xefee <InitializeConnection+0x3c>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    eff2:	37 e3       	ldi	r19, 0x37	; 55
    eff4:	c3 2e       	mov	r12, r19
    eff6:	31 e0       	ldi	r19, 0x01	; 1
    eff8:	d3 2e       	mov	r13, r19
    effa:	df ba       	out	0x1f, r13	; 31
    effc:	ce ba       	out	0x1e, r12	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    effe:	e0 9a       	sbi	0x1c, 0	; 28
    f000:	8d b3       	in	r24, 0x1d	; 29
	DispenserBrand=eeprom_read_byte(&DefDispenserBrand);
    f002:	80 93 61 01 	sts	0x0161, r24

	//SendSlaveCommand(SC_STOP_POOL_SEQUENCE,0);

    //Send Msg10
	if  (IFType==IT_SLAVE){
    f006:	91 30       	cpi	r25, 0x01	; 1
    f008:	09 f0       	breq	.+2      	; 0xf00c <InitializeConnection+0x5a>
    f00a:	59 c0       	rjmp	.+178    	; 0xf0be <InitializeConnection+0x10c>
	     SendSlaveCommand(SC_SLAVE,ST_NONE);
    f00c:	81 e0       	ldi	r24, 0x01	; 1
    f00e:	60 e0       	ldi	r22, 0x00	; 0
    f010:	0e 94 de 73 	call	0xe7bc	; 0xe7bc <SendSlaveCommand>
		 char_count=0;
    f014:	10 92 9d 01 	sts	0x019D, r1
    f018:	10 92 9c 01 	sts	0x019C, r1
		 if (IsPowerOn==True){
    f01c:	80 91 9a 04 	lds	r24, 0x049A
    f020:	81 30       	cpi	r24, 0x01	; 1
    f022:	59 f4       	brne	.+22     	; 0xf03a <InitializeConnection+0x88>
		     IsPowerOn=False;
    f024:	10 92 9a 04 	sts	0x049A, r1
    f028:	80 e5       	ldi	r24, 0x50	; 80
    f02a:	93 ec       	ldi	r25, 0xC3	; 195
    f02c:	29 e1       	ldi	r18, 0x19	; 25
    f02e:	30 e0       	ldi	r19, 0x00	; 0
    f030:	f9 01       	movw	r30, r18
    f032:	31 97       	sbiw	r30, 0x01	; 1
    f034:	f1 f7       	brne	.-4      	; 0xf032 <InitializeConnection+0x80>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    f036:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    f038:	d9 f7       	brne	.-10     	; 0xf030 <InitializeConnection+0x7e>
		     _delay_ms(5000);
			 }
         sendMessage10();
    f03a:	0e 94 dd 53 	call	0xa7ba	; 0xa7ba <sendMessage10>
         lcd_printf(4,1,PSTR("Connect         "));
    f03e:	84 e0       	ldi	r24, 0x04	; 4
    f040:	61 e0       	ldi	r22, 0x01	; 1
    f042:	46 e8       	ldi	r20, 0x86	; 134
    f044:	5c e1       	ldi	r21, 0x1C	; 28
    f046:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		 lcd_printf(4,1,PSTR("Connect"));
    f04a:	84 e0       	ldi	r24, 0x04	; 4
    f04c:	61 e0       	ldi	r22, 0x01	; 1
    f04e:	4e e7       	ldi	r20, 0x7E	; 126
    f050:	5c e1       	ldi	r21, 0x1C	; 28
    f052:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		 //EstablishConnection TCP/IP
		 IsMessage11=False;
    f056:	10 92 b7 01 	sts	0x01B7, r1
    f05a:	ee 24       	eor	r14, r14
    f05c:	ff 24       	eor	r15, r15
    f05e:	10 e0       	ldi	r17, 0x00	; 0
    f060:	00 e0       	ldi	r16, 0x00	; 0
    f062:	29 c0       	rjmp	.+82     	; 0xf0b6 <InitializeConnection+0x104>
		  //SlaveIdentification		  
		 while (IsMessage11==False){
		        lcd_put(4,(8+iCon),'.');
    f064:	61 2f       	mov	r22, r17
    f066:	68 5f       	subi	r22, 0xF8	; 248
    f068:	84 e0       	ldi	r24, 0x04	; 4
    f06a:	4e e2       	ldi	r20, 0x2E	; 46
    f06c:	0e 94 da ae 	call	0x15db4	; 0x15db4 <lcd_put>
                tConnect++;
    f070:	08 94       	sec
    f072:	e1 1c       	adc	r14, r1
    f074:	f1 1c       	adc	r15, r1
			    if ((tConnect%800)==0)iCon++;
    f076:	c7 01       	movw	r24, r14
    f078:	60 e2       	ldi	r22, 0x20	; 32
    f07a:	73 e0       	ldi	r23, 0x03	; 3
    f07c:	0e 94 93 b8 	call	0x17126	; 0x17126 <__udivmodhi4>
    f080:	89 2b       	or	r24, r25
    f082:	09 f4       	brne	.+2      	; 0xf086 <InitializeConnection+0xd4>
    f084:	1f 5f       	subi	r17, 0xFF	; 255
			    if (iCon>8){
    f086:	19 30       	cpi	r17, 0x09	; 9
    f088:	70 f0       	brcs	.+28     	; 0xf0a6 <InitializeConnection+0xf4>
			        lcd_printf(4,1,PSTR("Connect         "));
    f08a:	84 e0       	ldi	r24, 0x04	; 4
    f08c:	61 e0       	ldi	r22, 0x01	; 1
    f08e:	4d e6       	ldi	r20, 0x6D	; 109
    f090:	5c e1       	ldi	r21, 0x1C	; 28
    f092:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
				    sendMessage10();
    f096:	0e 94 dd 53 	call	0xa7ba	; 0xa7ba <sendMessage10>
				    SendSlaveCommand(SC_SLAVE,ST_NONE);
    f09a:	81 e0       	ldi	r24, 0x01	; 1
    f09c:	60 e0       	ldi	r22, 0x00	; 0
    f09e:	0e 94 de 73 	call	0xe7bc	; 0xe7bc <SendSlaveCommand>
			        iCon=0;
				    iTry++;}
    f0a2:	0f 5f       	subi	r16, 0xFF	; 255
    f0a4:	10 e0       	ldi	r17, 0x00	; 0
			    if (iTry>3){
    f0a6:	04 30       	cpi	r16, 0x04	; 4
    f0a8:	30 f0       	brcs	.+12     	; 0xf0b6 <InitializeConnection+0x104>
			        //IsErrorTCPIP=True;
				    IsAdvanzStartupInfo=False;		
    f0aa:	10 92 c1 01 	sts	0x01C1, r1
					IFType=IT_STANDALONE;
    f0ae:	82 e0       	ldi	r24, 0x02	; 2
    f0b0:	80 93 10 01 	sts	0x0110, r24
    f0b4:	04 c0       	rjmp	.+8      	; 0xf0be <InitializeConnection+0x10c>
         lcd_printf(4,1,PSTR("Connect         "));
		 lcd_printf(4,1,PSTR("Connect"));
		 //EstablishConnection TCP/IP
		 IsMessage11=False;
		  //SlaveIdentification		  
		 while (IsMessage11==False){
    f0b6:	80 91 b7 01 	lds	r24, 0x01B7
    f0ba:	88 23       	and	r24, r24
    f0bc:	99 f2       	breq	.-90     	; 0xf064 <InitializeConnection+0xb2>
				    break;
			    }
            }//EndWhile
		}

	if (IFType==IT_STANDALONE){
    f0be:	80 91 10 01 	lds	r24, 0x0110
    f0c2:	82 30       	cpi	r24, 0x02	; 2
    f0c4:	09 f0       	breq	.+2      	; 0xf0c8 <InitializeConnection+0x116>
    f0c6:	72 c0       	rjmp	.+228    	; 0xf1ac <InitializeConnection+0x1fa>
        IsStandAloneDetected=False;		
    f0c8:	10 92 b3 01 	sts	0x01B3, r1
		SendSlaveCommand(SC_STANDALONE,DispenserBrand);
    f0cc:	60 91 61 01 	lds	r22, 0x0161
    f0d0:	0e 94 de 73 	call	0xe7bc	; 0xe7bc <SendSlaveCommand>
		tConnect=0,iCon=0,iTry=0;
	    lcd_clear();
    f0d4:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
	    lcd_printf(1,1,PSTR("Scan Pump"));
    f0d8:	81 e0       	ldi	r24, 0x01	; 1
    f0da:	61 e0       	ldi	r22, 0x01	; 1
    f0dc:	43 e6       	ldi	r20, 0x63	; 99
    f0de:	5c e1       	ldi	r21, 0x1C	; 28
    f0e0:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    f0e4:	e1 99       	sbic	0x1c, 1	; 28
    f0e6:	fe cf       	rjmp	.-4      	; 0xf0e4 <InitializeConnection+0x132>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    f0e8:	df ba       	out	0x1f, r13	; 31
    f0ea:	ce ba       	out	0x1e, r12	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    f0ec:	e0 9a       	sbi	0x1c, 0	; 28
    f0ee:	8d b3       	in	r24, 0x1d	; 29
		strcpy_P(lcdteks,(PGM_P)pgm_read_word(&(DefListDispenserName[eeprom_read_byte(&DefDispenserBrand)])));
    f0f0:	e8 2f       	mov	r30, r24
    f0f2:	f0 e0       	ldi	r31, 0x00	; 0
    f0f4:	ee 0f       	add	r30, r30
    f0f6:	ff 1f       	adc	r31, r31
    f0f8:	e5 5d       	subi	r30, 0xD5	; 213
    f0fa:	fc 4f       	sbci	r31, 0xFC	; 252
    f0fc:	65 91       	lpm	r22, Z+
    f0fe:	74 91       	lpm	r23, Z+
    f100:	8e 01       	movw	r16, r28
    f102:	0f 5f       	subi	r16, 0xFF	; 255
    f104:	1f 4f       	sbci	r17, 0xFF	; 255
    f106:	c8 01       	movw	r24, r16
    f108:	0e 94 63 b5 	call	0x16ac6	; 0x16ac6 <strcpy_P>
		sprintf_P(lcdteks,PSTR("%s"),lcdteks);
    f10c:	00 d0       	rcall	.+0      	; 0xf10e <InitializeConnection+0x15c>
    f10e:	00 d0       	rcall	.+0      	; 0xf110 <InitializeConnection+0x15e>
    f110:	00 d0       	rcall	.+0      	; 0xf112 <InitializeConnection+0x160>
    f112:	ed b7       	in	r30, 0x3d	; 61
    f114:	fe b7       	in	r31, 0x3e	; 62
    f116:	31 96       	adiw	r30, 0x01	; 1
    f118:	ad b7       	in	r26, 0x3d	; 61
    f11a:	be b7       	in	r27, 0x3e	; 62
    f11c:	12 96       	adiw	r26, 0x02	; 2
    f11e:	1c 93       	st	X, r17
    f120:	0e 93       	st	-X, r16
    f122:	11 97       	sbiw	r26, 0x01	; 1
    f124:	80 e6       	ldi	r24, 0x60	; 96
    f126:	9c e1       	ldi	r25, 0x1C	; 28
    f128:	93 83       	std	Z+3, r25	; 0x03
    f12a:	82 83       	std	Z+2, r24	; 0x02
    f12c:	15 83       	std	Z+5, r17	; 0x05
    f12e:	04 83       	std	Z+4, r16	; 0x04
    f130:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
	    lcd_print(2,1,lcdteks);
    f134:	8d b7       	in	r24, 0x3d	; 61
    f136:	9e b7       	in	r25, 0x3e	; 62
    f138:	06 96       	adiw	r24, 0x06	; 6
    f13a:	0f b6       	in	r0, 0x3f	; 63
    f13c:	f8 94       	cli
    f13e:	9e bf       	out	0x3e, r25	; 62
    f140:	0f be       	out	0x3f, r0	; 63
    f142:	8d bf       	out	0x3d, r24	; 61
    f144:	82 e0       	ldi	r24, 0x02	; 2
    f146:	61 e0       	ldi	r22, 0x01	; 1
    f148:	a8 01       	movw	r20, r16
    f14a:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
    f14e:	00 e0       	ldi	r16, 0x00	; 0
    f150:	10 e0       	ldi	r17, 0x00	; 0
    f152:	ff 24       	eor	r15, r15
    f154:	dd 24       	eor	r13, r13
    f156:	26 c0       	rjmp	.+76     	; 0xf1a4 <InitializeConnection+0x1f2>

	    while (IsStandAloneDetected==False){
		       lcd_put(4,(1+iCon),'.');
    f158:	ef 2c       	mov	r14, r15
    f15a:	e3 94       	inc	r14
    f15c:	84 e0       	ldi	r24, 0x04	; 4
    f15e:	6e 2d       	mov	r22, r14
    f160:	4e e2       	ldi	r20, 0x2E	; 46
    f162:	0e 94 da ae 	call	0x15db4	; 0x15db4 <lcd_put>
		       tConnect++;
    f166:	0f 5f       	subi	r16, 0xFF	; 255
    f168:	1f 4f       	sbci	r17, 0xFF	; 255
		       if ((tConnect%100)==0)iCon++;
    f16a:	c8 01       	movw	r24, r16
    f16c:	64 e6       	ldi	r22, 0x64	; 100
    f16e:	70 e0       	ldi	r23, 0x00	; 0
    f170:	0e 94 93 b8 	call	0x17126	; 0x17126 <__udivmodhi4>
    f174:	89 2b       	or	r24, r25
    f176:	09 f4       	brne	.+2      	; 0xf17a <InitializeConnection+0x1c8>
    f178:	fe 2c       	mov	r15, r14
		       if (iCon>16){
    f17a:	90 e1       	ldi	r25, 0x10	; 16
    f17c:	9f 15       	cp	r25, r15
    f17e:	78 f4       	brcc	.+30     	; 0xf19e <InitializeConnection+0x1ec>
			       lcd_printf(4,1,PSTR("                   "));
    f180:	84 e0       	ldi	r24, 0x04	; 4
    f182:	61 e0       	ldi	r22, 0x01	; 1
    f184:	4c e4       	ldi	r20, 0x4C	; 76
    f186:	5c e1       	ldi	r21, 0x1C	; 28
    f188:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
				   //IsStandaloneAcknoledge=False;
		           SendSlaveCommand(SC_STANDALONE,DispenserBrand);
    f18c:	82 e0       	ldi	r24, 0x02	; 2
    f18e:	60 91 61 01 	lds	r22, 0x0161
    f192:	0e 94 de 73 	call	0xe7bc	; 0xe7bc <SendSlaveCommand>
                   //InitStandalone();

			       DisplayPumpStatus();
    f196:	0e 94 4a 45 	call	0x8a94	; 0x8a94 <DisplayPumpStatus>
			       iCon=0;
			       iTry++;}
    f19a:	d3 94       	inc	r13
    f19c:	ff 24       	eor	r15, r15
		           if (iTry>3) break; 
    f19e:	a3 e0       	ldi	r26, 0x03	; 3
    f1a0:	ad 15       	cp	r26, r13
    f1a2:	20 f0       	brcs	.+8      	; 0xf1ac <InitializeConnection+0x1fa>
	    lcd_printf(1,1,PSTR("Scan Pump"));
		strcpy_P(lcdteks,(PGM_P)pgm_read_word(&(DefListDispenserName[eeprom_read_byte(&DefDispenserBrand)])));
		sprintf_P(lcdteks,PSTR("%s"),lcdteks);
	    lcd_print(2,1,lcdteks);

	    while (IsStandAloneDetected==False){
    f1a4:	80 91 b3 01 	lds	r24, 0x01B3
    f1a8:	88 23       	and	r24, r24
    f1aa:	b1 f2       	breq	.-84     	; 0xf158 <InitializeConnection+0x1a6>
			       iCon=0;
			       iTry++;}
		           if (iTry>3) break; 
	    }
	}//EndIf
	if(IsMessage11==True){
    f1ac:	80 91 b7 01 	lds	r24, 0x01B7
    f1b0:	81 30       	cpi	r24, 0x01	; 1
    f1b2:	b9 f4       	brne	.+46     	; 0xf1e2 <InitializeConnection+0x230>
	   lcd_printf(4,1,PSTR("Connected"));
    f1b4:	84 e0       	ldi	r24, 0x04	; 4
    f1b6:	61 e0       	ldi	r22, 0x01	; 1
    f1b8:	42 e4       	ldi	r20, 0x42	; 66
    f1ba:	5c e1       	ldi	r21, 0x1C	; 28
    f1bc:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    f1c0:	e1 99       	sbic	0x1c, 1	; 28
    f1c2:	fe cf       	rjmp	.-4      	; 0xf1c0 <InitializeConnection+0x20e>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    f1c4:	bf ba       	out	0x1f, r11	; 31
    f1c6:	ae ba       	out	0x1e, r10	; 30
#endif
    EEDR = __value;
    f1c8:	11 e0       	ldi	r17, 0x01	; 1
    f1ca:	1d bb       	out	0x1d, r17	; 29

    __asm__ __volatile__ (
    f1cc:	0f b6       	in	r0, 0x3f	; 63
    f1ce:	f8 94       	cli
    f1d0:	e2 9a       	sbi	0x1c, 2	; 28
    f1d2:	e1 9a       	sbi	0x1c, 1	; 28
    f1d4:	0f be       	out	0x3f, r0	; 63
	   eeprom_write_byte(&DefInitIFT,IT_SLAVE);
	   IFType=IT_SLAVE;
    f1d6:	10 93 10 01 	sts	0x0110, r17
	   //IsErrorTCPIP=False;
	   procMessage11();
    f1da:	0e 94 65 5e 	call	0xbcca	; 0xbcca <procMessage11>
	   IsAdvanzStartupInfo=True;
    f1de:	10 93 c1 01 	sts	0x01C1, r17
	}
	if(IsStandAloneDetected==True){
    f1e2:	80 91 b3 01 	lds	r24, 0x01B3
    f1e6:	81 30       	cpi	r24, 0x01	; 1
    f1e8:	99 f4       	brne	.+38     	; 0xf210 <InitializeConnection+0x25e>
	   lcd_printf(4,1,PSTR("PumpFound"));
    f1ea:	84 e0       	ldi	r24, 0x04	; 4
    f1ec:	61 e0       	ldi	r22, 0x01	; 1
    f1ee:	48 e3       	ldi	r20, 0x38	; 56
    f1f0:	5c e1       	ldi	r21, 0x1C	; 28
    f1f2:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    f1f6:	e1 99       	sbic	0x1c, 1	; 28
    f1f8:	fe cf       	rjmp	.-4      	; 0xf1f6 <InitializeConnection+0x244>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    f1fa:	bf ba       	out	0x1f, r11	; 31
    f1fc:	ae ba       	out	0x1e, r10	; 30
#endif
    EEDR = __value;
    f1fe:	82 e0       	ldi	r24, 0x02	; 2
    f200:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    f202:	0f b6       	in	r0, 0x3f	; 63
    f204:	f8 94       	cli
    f206:	e2 9a       	sbi	0x1c, 2	; 28
    f208:	e1 9a       	sbi	0x1c, 1	; 28
    f20a:	0f be       	out	0x3f, r0	; 63
	   eeprom_write_byte(&DefInitIFT,IT_STANDALONE);
	   IFType=IT_STANDALONE;
    f20c:	80 93 10 01 	sts	0x0110, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    f210:	e1 99       	sbic	0x1c, 1	; 28
    f212:	fe cf       	rjmp	.-4      	; 0xf210 <InitializeConnection+0x25e>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    f214:	85 e3       	ldi	r24, 0x35	; 53
    f216:	91 e0       	ldi	r25, 0x01	; 1
    f218:	9f bb       	out	0x1f, r25	; 31
    f21a:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    f21c:	e0 9a       	sbi	0x1c, 0	; 28
    f21e:	8d b3       	in	r24, 0x1d	; 29
	}
	//PrintStatus
	if (eeprom_read_byte(&DefPrintInitialize)==True)GeneratePrintInit();
    f220:	81 30       	cpi	r24, 0x01	; 1
    f222:	11 f4       	brne	.+4      	; 0xf228 <InitializeConnection+0x276>
    f224:	0e 94 3a 33 	call	0x6674	; 0x6674 <GeneratePrintInit>
	if ((IsStandAloneDetected==False)&&(IsMessage11==False)){		
    f228:	80 91 b3 01 	lds	r24, 0x01B3
    f22c:	88 23       	and	r24, r24
    f22e:	09 f0       	breq	.+2      	; 0xf232 <InitializeConnection+0x280>
    f230:	38 c0       	rjmp	.+112    	; 0xf2a2 <InitializeConnection+0x2f0>
    f232:	80 91 b7 01 	lds	r24, 0x01B7
    f236:	88 23       	and	r24, r24
    f238:	09 f0       	breq	.+2      	; 0xf23c <InitializeConnection+0x28a>
    f23a:	33 c0       	rjmp	.+102    	; 0xf2a2 <InitializeConnection+0x2f0>
		 lcd_printf(2,1,PSTR("TCP/IP Error"));
    f23c:	82 e0       	ldi	r24, 0x02	; 2
    f23e:	61 e0       	ldi	r22, 0x01	; 1
    f240:	4b e2       	ldi	r20, 0x2B	; 43
    f242:	5c e1       	ldi	r21, 0x1C	; 28
    f244:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		 lcd_printf(3,1,PSTR("No Pump Found"));
    f248:	83 e0       	ldi	r24, 0x03	; 3
    f24a:	61 e0       	ldi	r22, 0x01	; 1
    f24c:	4d e1       	ldi	r20, 0x1D	; 29
    f24e:	5c e1       	ldi	r21, 0x1C	; 28
    f250:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
    f254:	80 e2       	ldi	r24, 0x20	; 32
    f256:	9e e4       	ldi	r25, 0x4E	; 78
    f258:	29 e1       	ldi	r18, 0x19	; 25
    f25a:	30 e0       	ldi	r19, 0x00	; 0
    f25c:	f9 01       	movw	r30, r18
    f25e:	31 97       	sbiw	r30, 0x01	; 1
    f260:	f1 f7       	brne	.-4      	; 0xf25e <InitializeConnection+0x2ac>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    f262:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    f264:	d9 f7       	brne	.-10     	; 0xf25c <InitializeConnection+0x2aa>
		 _delay_ms(2000);
		 ForceType=systemForceType();
    f266:	0e 94 98 4a 	call	0x9530	; 0x9530 <systemForceType>
		 if (ForceType=='1'){
    f26a:	81 33       	cpi	r24, 0x31	; 49
    f26c:	29 f4       	brne	.+10     	; 0xf278 <InitializeConnection+0x2c6>
		     IFType=IT_SLAVE;
    f26e:	81 e0       	ldi	r24, 0x01	; 1
    f270:	80 93 10 01 	sts	0x0110, r24
			 SendSlaveCommand(SC_SLAVE,ST_NONE);
    f274:	60 e0       	ldi	r22, 0x00	; 0
    f276:	07 c0       	rjmp	.+14     	; 0xf286 <InitializeConnection+0x2d4>
         }
		 else
		 if (ForceType=='2'){
    f278:	82 33       	cpi	r24, 0x32	; 50
    f27a:	39 f4       	brne	.+14     	; 0xf28a <InitializeConnection+0x2d8>
		     IFType=IT_STANDALONE;
    f27c:	82 e0       	ldi	r24, 0x02	; 2
    f27e:	80 93 10 01 	sts	0x0110, r24
			 SendSlaveCommand(SC_STANDALONE,DispenserBrand);
    f282:	60 91 61 01 	lds	r22, 0x0161
    f286:	0e 94 de 73 	call	0xe7bc	; 0xe7bc <SendSlaveCommand>

			 //SendPoolingCommand(SC_SET_POOLING_MAX_PUMP,eeprom_read_byte(&DefPoolingPumpMax));

			 //InitStandalone();
         }
		 eeprom_write_byte(&DefInitIFT,IFType);
    f28a:	80 91 10 01 	lds	r24, 0x0110
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    f28e:	e1 99       	sbic	0x1c, 1	; 28
    f290:	fe cf       	rjmp	.-4      	; 0xf28e <InitializeConnection+0x2dc>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    f292:	bf ba       	out	0x1f, r11	; 31
    f294:	ae ba       	out	0x1e, r10	; 30
#endif
    EEDR = __value;
    f296:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    f298:	0f b6       	in	r0, 0x3f	; 63
    f29a:	f8 94       	cli
    f29c:	e2 9a       	sbi	0x1c, 2	; 28
    f29e:	e1 9a       	sbi	0x1c, 1	; 28
    f2a0:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    f2a2:	e1 99       	sbic	0x1c, 1	; 28
    f2a4:	fe cf       	rjmp	.-4      	; 0xf2a2 <InitializeConnection+0x2f0>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    f2a6:	84 e4       	ldi	r24, 0x44	; 68
    f2a8:	91 e0       	ldi	r25, 0x01	; 1
    f2aa:	9f bb       	out	0x1f, r25	; 31
    f2ac:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    f2ae:	e0 9a       	sbi	0x1c, 0	; 28
    f2b0:	8d b3       	in	r24, 0x1d	; 29

	 }
}

void InitMemory(){
     PumpCountMax=eeprom_read_byte(&DefPoolingPumpMax);
    f2b2:	80 93 5f 01 	sts	0x015F, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    f2b6:	e1 99       	sbic	0x1c, 1	; 28
    f2b8:	fe cf       	rjmp	.-4      	; 0xf2b6 <InitializeConnection+0x304>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    f2ba:	89 e4       	ldi	r24, 0x49	; 73
    f2bc:	91 e0       	ldi	r25, 0x01	; 1
    f2be:	9f bb       	out	0x1f, r25	; 31
    f2c0:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    f2c2:	e0 9a       	sbi	0x1c, 0	; 28
    f2c4:	8d b3       	in	r24, 0x1d	; 29
	 ActivePump=eeprom_read_byte(&DefActivePump);
    f2c6:	80 93 60 01 	sts	0x0160, r24
         }
		 eeprom_write_byte(&DefInitIFT,IFType);
	}
	InitMemory();
	//SendSlaveCommand(SC_START_POOL_SEQUENCE,0);
}
    f2ca:	64 96       	adiw	r28, 0x14	; 20
    f2cc:	0f b6       	in	r0, 0x3f	; 63
    f2ce:	f8 94       	cli
    f2d0:	de bf       	out	0x3e, r29	; 62
    f2d2:	0f be       	out	0x3f, r0	; 63
    f2d4:	cd bf       	out	0x3d, r28	; 61
    f2d6:	cf 91       	pop	r28
    f2d8:	df 91       	pop	r29
    f2da:	1f 91       	pop	r17
    f2dc:	0f 91       	pop	r16
    f2de:	ff 90       	pop	r15
    f2e0:	ef 90       	pop	r14
    f2e2:	df 90       	pop	r13
    f2e4:	cf 90       	pop	r12
    f2e6:	bf 90       	pop	r11
    f2e8:	af 90       	pop	r10
    f2ea:	08 95       	ret

0000f2ec <StoreStandaloneTransData>:
     SendSlaveCommand(SC_TOTALIZER_ACK,iPumpID);
	 UpdateStandaloneStatus((iPumpID&0x0F),PS_TOTALIZER);	 
}
         
			                                         //      STX     MSGID  PumpID              6        8        8
void StoreStandaloneTransData(char *strRawTransData){//  [0x50,0x05]  01      01      1       004500   00000200  00000012 [0x06,0x60] = 24
    f2ec:	2f 92       	push	r2
    f2ee:	3f 92       	push	r3
    f2f0:	4f 92       	push	r4
    f2f2:	5f 92       	push	r5
    f2f4:	6f 92       	push	r6
    f2f6:	7f 92       	push	r7
    f2f8:	8f 92       	push	r8
    f2fa:	9f 92       	push	r9
    f2fc:	af 92       	push	r10
    f2fe:	bf 92       	push	r11
    f300:	cf 92       	push	r12
    f302:	df 92       	push	r13
    f304:	ef 92       	push	r14
    f306:	ff 92       	push	r15
    f308:	0f 93       	push	r16
    f30a:	1f 93       	push	r17
    f30c:	df 93       	push	r29
    f30e:	cf 93       	push	r28
    f310:	cd b7       	in	r28, 0x3d	; 61
    f312:	de b7       	in	r29, 0x3e	; 62
    f314:	e1 97       	sbiw	r28, 0x31	; 49
    f316:	0f b6       	in	r0, 0x3f	; 63
    f318:	f8 94       	cli
    f31a:	de bf       	out	0x3e, r29	; 62
    f31c:	0f be       	out	0x3f, r0	; 63
    f31e:	cd bf       	out	0x3d, r28	; 61
    f320:	7c 01       	movw	r14, r24
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    f322:	dc 01       	movw	r26, r24
    f324:	12 96       	adiw	r26, 0x02	; 2
    f326:	8c 91       	ld	r24, X
    f328:	12 97       	sbiw	r26, 0x02	; 2
    f32a:	89 83       	std	Y+1, r24	; 0x01
    f32c:	13 96       	adiw	r26, 0x03	; 3
    f32e:	8c 91       	ld	r24, X
    f330:	8a 83       	std	Y+2, r24	; 0x02
	 }Dest[Length]=0;
    f332:	1b 82       	std	Y+3, r1	; 0x03
	 char strSend[30];
	 char TransDigit;
	 char FIPAddr;
      
	 StrPosCopy(strRawTransData,strPumpID,2,2);
	 RemZeroLead(strPumpID);
    f334:	8e 01       	movw	r16, r28
    f336:	0f 5f       	subi	r16, 0xFF	; 255
    f338:	1f 4f       	sbci	r17, 0xFF	; 255
    f33a:	c8 01       	movw	r24, r16
    f33c:	0e 94 b9 25 	call	0x4b72	; 0x4b72 <RemZeroLead>
	 iPumpID=atoi(strPumpID); 
    f340:	c8 01       	movw	r24, r16
    f342:	0e 94 45 b5 	call	0x16a8a	; 0x16a8a <atoi>
    f346:	38 2e       	mov	r3, r24
	 
	 FIPAddr=GetFIPAddr(iPumpID);
    f348:	0e 94 e1 1d 	call	0x3bc2	; 0x3bc2 <GetFIPAddr>
    f34c:	d8 2e       	mov	r13, r24
	 if (FIPAddr>0){
    f34e:	88 23       	and	r24, r24
    f350:	09 f4       	brne	.+2      	; 0xf354 <StoreStandaloneTransData+0x68>
    f352:	1a c2       	rjmp	.+1076   	; 0xf788 <StoreStandaloneTransData+0x49c>
	    Dest[IdxSource+i]=Source[i];
	 }Dest[IdxSource+Length]=0;
}
char CharPosCopy(char *Source, unsigned int IdxSource){
     char Result;
     Result=Source[IdxSource];
    f354:	f7 01       	movw	r30, r14
    f356:	f4 81       	ldd	r31, Z+4	; 0x04
    f358:	f9 ab       	std	Y+49, r31	; 0x31

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    f35a:	d7 01       	movw	r26, r14
    f35c:	15 96       	adiw	r26, 0x05	; 5
    f35e:	2c 90       	ld	r2, X
    f360:	e4 e0       	ldi	r30, 0x04	; 4
    f362:	8e 2e       	mov	r8, r30
    f364:	91 2c       	mov	r9, r1
    f366:	8c 0e       	add	r8, r28
    f368:	9d 1e       	adc	r9, r29
    f36a:	f4 01       	movw	r30, r8
    f36c:	ce 01       	movw	r24, r28
    f36e:	0b 96       	adiw	r24, 0x0b	; 11
	     strMemory[i]=data;
    f370:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    f372:	e8 17       	cp	r30, r24
    f374:	f9 07       	cpc	r31, r25
    f376:	e1 f7       	brne	.-8      	; 0xf370 <StoreStandaloneTransData+0x84>
    f378:	7d e1       	ldi	r23, 0x1D	; 29
    f37a:	67 2e       	mov	r6, r23
    f37c:	71 2c       	mov	r7, r1
    f37e:	6c 0e       	add	r6, r28
    f380:	7d 1e       	adc	r7, r29
    f382:	93 01       	movw	r18, r6
	     strMemory[i]=data;
    f384:	ce 01       	movw	r24, r28
    f386:	87 96       	adiw	r24, 0x27	; 39
    f388:	f9 01       	movw	r30, r18
    f38a:	11 92       	st	Z+, r1
    f38c:	9f 01       	movw	r18, r30

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    f38e:	e8 17       	cp	r30, r24
    f390:	f9 07       	cpc	r31, r25
    f392:	d1 f7       	brne	.-12     	; 0xf388 <StoreStandaloneTransData+0x9c>
    f394:	2f 01       	movw	r4, r30
	     strMemory[i]=data;
    f396:	ce 01       	movw	r24, r28
    f398:	c1 96       	adiw	r24, 0x31	; 49
    f39a:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    f39c:	e8 17       	cp	r30, r24
    f39e:	f9 07       	cpc	r31, r25
    f3a0:	e1 f7       	brne	.-8      	; 0xf39a <StoreStandaloneTransData+0xae>
    f3a2:	a7 01       	movw	r20, r14
    f3a4:	d7 01       	movw	r26, r14
    f3a6:	f4 01       	movw	r30, r8
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f3a8:	be 01       	movw	r22, r28
    f3aa:	66 5f       	subi	r22, 0xF6	; 246
    f3ac:	7f 4f       	sbci	r23, 0xFF	; 255
	    Dest[i]=Source[IdxSource+i];
    f3ae:	16 96       	adiw	r26, 0x06	; 6
    f3b0:	8c 91       	ld	r24, X
    f3b2:	16 97       	sbiw	r26, 0x06	; 6
    f3b4:	81 93       	st	Z+, r24
    f3b6:	11 96       	adiw	r26, 0x01	; 1
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f3b8:	e6 17       	cp	r30, r22
    f3ba:	f7 07       	cpc	r31, r23
    f3bc:	c1 f7       	brne	.-16     	; 0xf3ae <StoreStandaloneTransData+0xc2>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f3be:	1a 86       	std	Y+10, r1	; 0x0a
    f3c0:	d7 01       	movw	r26, r14
    f3c2:	f3 01       	movw	r30, r6
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f3c4:	be 01       	movw	r22, r28
    f3c6:	6b 5d       	subi	r22, 0xDB	; 219
    f3c8:	7f 4f       	sbci	r23, 0xFF	; 255
	    Dest[i]=Source[IdxSource+i];
    f3ca:	1c 96       	adiw	r26, 0x0c	; 12
    f3cc:	8c 91       	ld	r24, X
    f3ce:	1c 97       	sbiw	r26, 0x0c	; 12
    f3d0:	81 93       	st	Z+, r24
    f3d2:	11 96       	adiw	r26, 0x01	; 1
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f3d4:	e6 17       	cp	r30, r22
    f3d6:	f7 07       	cpc	r31, r23
    f3d8:	c1 f7       	brne	.-16     	; 0xf3ca <StoreStandaloneTransData+0xde>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f3da:	1d a2       	std	Y+37, r1	; 0x25
    f3dc:	f9 01       	movw	r30, r18
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f3de:	be 01       	movw	r22, r28
    f3e0:	69 5d       	subi	r22, 0xD9	; 217
    f3e2:	7f 4f       	sbci	r23, 0xFF	; 255
    f3e4:	9e 01       	movw	r18, r28
    f3e6:	21 5d       	subi	r18, 0xD1	; 209
    f3e8:	3f 4f       	sbci	r19, 0xFF	; 255
	    Dest[i]=Source[IdxSource+i];
    f3ea:	da 01       	movw	r26, r20
    f3ec:	54 96       	adiw	r26, 0x14	; 20
    f3ee:	8c 91       	ld	r24, X
    f3f0:	81 93       	st	Z+, r24
    f3f2:	4f 5f       	subi	r20, 0xFF	; 255
    f3f4:	5f 4f       	sbci	r21, 0xFF	; 255
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f3f6:	e2 17       	cp	r30, r18
    f3f8:	f3 07       	cpc	r31, r19
    f3fa:	b9 f7       	brne	.-18     	; 0xf3ea <StoreStandaloneTransData+0xfe>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f3fc:	1f a6       	std	Y+47, r1	; 0x2f
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    f3fe:	f7 01       	movw	r30, r14
    f400:	84 8d       	ldd	r24, Z+28	; 0x1c
    f402:	80 53       	subi	r24, 0x30	; 48
    f404:	8a 30       	cpi	r24, 0x0A	; 10
    f406:	98 f4       	brcc	.+38     	; 0xf42e <StoreStandaloneTransData+0x142>

		 TransDigit=Ord(CharPosCopy(strRawTransData,28));
		 //Normalize7Digit
		 //sprintf_P(strSend,PSTR("Digit: %d"),TransDigit);
		 //_uart_print(1,1,strSend);
		 if  (TransDigit==8){
    f408:	88 30       	cpi	r24, 0x08	; 8
    f40a:	89 f4       	brne	.+34     	; 0xf42e <StoreStandaloneTransData+0x142>
			  StrPosCopy(strPMoney,strPMoney,0,strlen(strPMoney)-1);	 
    f40c:	fb 01       	movw	r30, r22
    f40e:	01 90       	ld	r0, Z+
    f410:	00 20       	and	r0, r0
    f412:	e9 f7       	brne	.-6      	; 0xf40e <StoreStandaloneTransData+0x122>
    f414:	e6 1b       	sub	r30, r22
    f416:	f7 0b       	sbc	r31, r23
    f418:	32 97       	sbiw	r30, 0x02	; 2
    f41a:	80 e0       	ldi	r24, 0x00	; 0
    f41c:	90 e0       	ldi	r25, 0x00	; 0
    f41e:	01 c0       	rjmp	.+2      	; 0xf422 <StoreStandaloneTransData+0x136>
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f420:	01 96       	adiw	r24, 0x01	; 1
    f422:	8e 17       	cp	r24, r30
    f424:	9f 07       	cpc	r25, r31
    f426:	e0 f3       	brcs	.-8      	; 0xf420 <StoreStandaloneTransData+0x134>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f428:	ec 0f       	add	r30, r28
    f42a:	fd 1f       	adc	r31, r29
    f42c:	17 a2       	std	Z+39, r1	; 0x27
		 //sprintf_P(strSend,PSTR("Digit: %d"),TransDigit);
		 //_uart_print(1,1,strSend);
		 if  (TransDigit==8){
			  StrPosCopy(strPMoney,strPMoney,0,strlen(strPMoney)-1);	 
		 }
		 RemZeroLead(strPPU);
    f42e:	64 e0       	ldi	r22, 0x04	; 4
    f430:	e6 2e       	mov	r14, r22
    f432:	f1 2c       	mov	r15, r1
    f434:	ec 0e       	add	r14, r28
    f436:	fd 1e       	adc	r15, r29
    f438:	c7 01       	movw	r24, r14
    f43a:	0e 94 b9 25 	call	0x4b72	; 0x4b72 <RemZeroLead>
		 RemZeroLead(strPVolume);
    f43e:	5d e1       	ldi	r21, 0x1D	; 29
    f440:	a5 2e       	mov	r10, r21
    f442:	b1 2c       	mov	r11, r1
    f444:	ac 0e       	add	r10, r28
    f446:	bd 1e       	adc	r11, r29
    f448:	c5 01       	movw	r24, r10
    f44a:	0e 94 b9 25 	call	0x4b72	; 0x4b72 <RemZeroLead>
		 RemZeroLead(strPMoney);
    f44e:	8e 01       	movw	r16, r28
    f450:	09 5d       	subi	r16, 0xD9	; 217
    f452:	1f 4f       	sbci	r17, 0xFF	; 255
    f454:	c8 01       	movw	r24, r16
    f456:	0e 94 b9 25 	call	0x4b72	; 0x4b72 <RemZeroLead>
		 //sprintf_P(strSend,PSTR("Money: %s"),strPMoney);
		 //_uart_print(1,1,strSend);


		 //Void Detection
		 if (atoi(strPMoney)==0)TransactionStatus=TS_VOID;
    f45a:	c8 01       	movw	r24, r16
    f45c:	0e 94 45 b5 	call	0x16a8a	; 0x16a8a <atoi>
    f460:	89 2b       	or	r24, r25
    f462:	09 f0       	breq	.+2      	; 0xf466 <StoreStandaloneTransData+0x17a>
    f464:	46 c1       	rjmp	.+652    	; 0xf6f2 <StoreStandaloneTransData+0x406>
		 else TransactionStatus=TS_NEW;
		 
		 if (TransactionStatus==TS_VOID){//RejectData
			 UpdateStandaloneStatus((iPumpID&0x0F),PS_VOID);
    f466:	83 2d       	mov	r24, r3
    f468:	8f 70       	andi	r24, 0x0F	; 15
    f46a:	63 e1       	ldi	r22, 0x13	; 19
    f46c:	0e 94 18 1e 	call	0x3c30	; 0x3c30 <UpdateStandaloneStatus>
    f470:	8b c1       	rjmp	.+790    	; 0xf788 <StoreStandaloneTransData+0x49c>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    f472:	e1 99       	sbic	0x1c, 1	; 28
    f474:	fe cf       	rjmp	.-4      	; 0xf472 <StoreStandaloneTransData+0x186>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    f476:	8f e3       	ldi	r24, 0x3F	; 63
    f478:	91 e0       	ldi	r25, 0x01	; 1
    f47a:	9f bb       	out	0x1f, r25	; 31
    f47c:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    f47e:	e0 9a       	sbi	0x1c, 0	; 28
    f480:	2d b3       	in	r18, 0x1d	; 29
			 //_uart_print(1,1,strPVolume);
			 
			 GenerateTransactionNum(strTranNo);		 
			 sprintf_P(strTransDate,PSTR("%s"),strSystemDate);
			 sprintf_P(strTransTime,PSTR("%s"),strSystemTime);
			 sprintf_P(strShift,PSTR("%d"),eeprom_read_byte(&DefShift));
    f482:	00 d0       	rcall	.+0      	; 0xf484 <StoreStandaloneTransData+0x198>
    f484:	00 d0       	rcall	.+0      	; 0xf486 <StoreStandaloneTransData+0x19a>
    f486:	00 d0       	rcall	.+0      	; 0xf488 <StoreStandaloneTransData+0x19c>
    f488:	ed b7       	in	r30, 0x3d	; 61
    f48a:	fe b7       	in	r31, 0x3e	; 62
    f48c:	31 96       	adiw	r30, 0x01	; 1
    f48e:	83 e4       	ldi	r24, 0x43	; 67
    f490:	9e e0       	ldi	r25, 0x0E	; 14
    f492:	ad b7       	in	r26, 0x3d	; 61
    f494:	be b7       	in	r27, 0x3e	; 62
    f496:	12 96       	adiw	r26, 0x02	; 2
    f498:	9c 93       	st	X, r25
    f49a:	8e 93       	st	-X, r24
    f49c:	11 97       	sbiw	r26, 0x01	; 1
    f49e:	82 ec       	ldi	r24, 0xC2	; 194
    f4a0:	92 e2       	ldi	r25, 0x22	; 34
    f4a2:	93 83       	std	Z+3, r25	; 0x03
    f4a4:	82 83       	std	Z+2, r24	; 0x02
    f4a6:	24 83       	std	Z+4, r18	; 0x04
    f4a8:	15 82       	std	Z+5, r1	; 0x05
    f4aa:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
					 
			 //TransNum,Date,Time
			 StrPosCopy(strTranNo,RecPumpData[FIPAddr].strTransNum,0,strlen(strTranNo));
    f4ae:	e1 e6       	ldi	r30, 0x61	; 97
    f4b0:	fe e0       	ldi	r31, 0x0E	; 14
    f4b2:	df 01       	movw	r26, r30
    f4b4:	0d 90       	ld	r0, X+
    f4b6:	00 20       	and	r0, r0
    f4b8:	e9 f7       	brne	.-6      	; 0xf4b4 <StoreStandaloneTransData+0x1c8>
    f4ba:	9d 01       	movw	r18, r26
    f4bc:	21 50       	subi	r18, 0x01	; 1
    f4be:	30 40       	sbci	r19, 0x00	; 0
    f4c0:	2e 1b       	sub	r18, r30
    f4c2:	3f 0b       	sbc	r19, r31
    f4c4:	85 e3       	ldi	r24, 0x35	; 53
    f4c6:	90 e0       	ldi	r25, 0x00	; 0
    f4c8:	c8 9e       	mul	r12, r24
    f4ca:	d0 01       	movw	r26, r0
    f4cc:	c9 9e       	mul	r12, r25
    f4ce:	b0 0d       	add	r27, r0
    f4d0:	d8 9e       	mul	r13, r24
    f4d2:	b0 0d       	add	r27, r0
    f4d4:	11 24       	eor	r1, r1
    f4d6:	a2 57       	subi	r26, 0x72	; 114
    f4d8:	b8 4f       	sbci	r27, 0xF8	; 248
    f4da:	4d b7       	in	r20, 0x3d	; 61
    f4dc:	5e b7       	in	r21, 0x3e	; 62
    f4de:	4a 5f       	subi	r20, 0xFA	; 250
    f4e0:	5f 4f       	sbci	r21, 0xFF	; 255
    f4e2:	0f b6       	in	r0, 0x3f	; 63
    f4e4:	f8 94       	cli
    f4e6:	5e bf       	out	0x3e, r21	; 62
    f4e8:	0f be       	out	0x3f, r0	; 63
    f4ea:	4d bf       	out	0x3d, r20	; 61
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f4ec:	a9 01       	movw	r20, r18
    f4ee:	4e 0f       	add	r20, r30
    f4f0:	5f 1f       	adc	r21, r31
    f4f2:	02 c0       	rjmp	.+4      	; 0xf4f8 <StoreStandaloneTransData+0x20c>
	    Dest[i]=Source[IdxSource+i];
    f4f4:	81 91       	ld	r24, Z+
    f4f6:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f4f8:	e4 17       	cp	r30, r20
    f4fa:	f5 07       	cpc	r31, r21
    f4fc:	d9 f7       	brne	.-10     	; 0xf4f4 <StoreStandaloneTransData+0x208>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f4fe:	85 e3       	ldi	r24, 0x35	; 53
    f500:	90 e0       	ldi	r25, 0x00	; 0
    f502:	dc 01       	movw	r26, r24
    f504:	ca 9e       	mul	r12, r26
    f506:	c0 01       	movw	r24, r0
    f508:	cb 9e       	mul	r12, r27
    f50a:	90 0d       	add	r25, r0
    f50c:	da 9e       	mul	r13, r26
    f50e:	90 0d       	add	r25, r0
    f510:	11 24       	eor	r1, r1
    f512:	fc 01       	movw	r30, r24
    f514:	e5 57       	subi	r30, 0x75	; 117
    f516:	f8 4f       	sbci	r31, 0xF8	; 248
    f518:	e2 0f       	add	r30, r18
    f51a:	f3 1f       	adc	r31, r19
    f51c:	13 82       	std	Z+3, r1	; 0x03
			 sprintf_P(strTransTime,PSTR("%s"),strSystemTime);
			 sprintf_P(strShift,PSTR("%d"),eeprom_read_byte(&DefShift));
					 
			 //TransNum,Date,Time
			 StrPosCopy(strTranNo,RecPumpData[FIPAddr].strTransNum,0,strlen(strTranNo));
			 StrPosCopy(strTransDate,RecPumpData[FIPAddr].strTransDate,0,strlen(strTransDate));
    f51e:	fe 01       	movw	r30, r28
    f520:	3b 96       	adiw	r30, 0x0b	; 11
    f522:	df 01       	movw	r26, r30
    f524:	0d 90       	ld	r0, X+
    f526:	00 20       	and	r0, r0
    f528:	e9 f7       	brne	.-6      	; 0xf524 <StoreStandaloneTransData+0x238>
    f52a:	11 97       	sbiw	r26, 0x01	; 1
    f52c:	ae 1b       	sub	r26, r30
    f52e:	bf 0b       	sbc	r27, r31
    f530:	bf 01       	movw	r22, r30
    f532:	9c 01       	movw	r18, r24
    f534:	2b 56       	subi	r18, 0x6B	; 107
    f536:	38 4f       	sbci	r19, 0xF8	; 248
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f538:	af 01       	movw	r20, r30
    f53a:	4a 0f       	add	r20, r26
    f53c:	5b 1f       	adc	r21, r27
    f53e:	06 c0       	rjmp	.+12     	; 0xf54c <StoreStandaloneTransData+0x260>
	    Dest[i]=Source[IdxSource+i];
    f540:	fb 01       	movw	r30, r22
    f542:	81 91       	ld	r24, Z+
    f544:	bf 01       	movw	r22, r30
    f546:	f9 01       	movw	r30, r18
    f548:	81 93       	st	Z+, r24
    f54a:	9f 01       	movw	r18, r30
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f54c:	64 17       	cp	r22, r20
    f54e:	75 07       	cpc	r23, r21
    f550:	b9 f7       	brne	.-18     	; 0xf540 <StoreStandaloneTransData+0x254>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f552:	85 e3       	ldi	r24, 0x35	; 53
    f554:	90 e0       	ldi	r25, 0x00	; 0
    f556:	9c 01       	movw	r18, r24
    f558:	c2 9e       	mul	r12, r18
    f55a:	c0 01       	movw	r24, r0
    f55c:	c3 9e       	mul	r12, r19
    f55e:	90 0d       	add	r25, r0
    f560:	d2 9e       	mul	r13, r18
    f562:	90 0d       	add	r25, r0
    f564:	11 24       	eor	r1, r1
    f566:	fc 01       	movw	r30, r24
    f568:	e5 57       	subi	r30, 0x75	; 117
    f56a:	f8 4f       	sbci	r31, 0xF8	; 248
    f56c:	ea 0f       	add	r30, r26
    f56e:	fb 1f       	adc	r31, r27
    f570:	12 86       	std	Z+10, r1	; 0x0a
			 sprintf_P(strShift,PSTR("%d"),eeprom_read_byte(&DefShift));
					 
			 //TransNum,Date,Time
			 StrPosCopy(strTranNo,RecPumpData[FIPAddr].strTransNum,0,strlen(strTranNo));
			 StrPosCopy(strTransDate,RecPumpData[FIPAddr].strTransDate,0,strlen(strTransDate));
			 StrPosCopy(strTransTime,RecPumpData[FIPAddr].strTransTime,0,strlen(strTransTime));
    f572:	fe 01       	movw	r30, r28
    f574:	74 96       	adiw	r30, 0x14	; 20
    f576:	df 01       	movw	r26, r30
    f578:	0d 90       	ld	r0, X+
    f57a:	00 20       	and	r0, r0
    f57c:	e9 f7       	brne	.-6      	; 0xf578 <StoreStandaloneTransData+0x28c>
    f57e:	11 97       	sbiw	r26, 0x01	; 1
    f580:	ae 1b       	sub	r26, r30
    f582:	bf 0b       	sbc	r27, r31
    f584:	bf 01       	movw	r22, r30
    f586:	9c 01       	movw	r18, r24
    f588:	22 56       	subi	r18, 0x62	; 98
    f58a:	38 4f       	sbci	r19, 0xF8	; 248
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f58c:	af 01       	movw	r20, r30
    f58e:	4a 0f       	add	r20, r26
    f590:	5b 1f       	adc	r21, r27
    f592:	06 c0       	rjmp	.+12     	; 0xf5a0 <StoreStandaloneTransData+0x2b4>
	    Dest[i]=Source[IdxSource+i];
    f594:	fb 01       	movw	r30, r22
    f596:	81 91       	ld	r24, Z+
    f598:	bf 01       	movw	r22, r30
    f59a:	f9 01       	movw	r30, r18
    f59c:	81 93       	st	Z+, r24
    f59e:	9f 01       	movw	r18, r30
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f5a0:	64 17       	cp	r22, r20
    f5a2:	75 07       	cpc	r23, r21
    f5a4:	b9 f7       	brne	.-18     	; 0xf594 <StoreStandaloneTransData+0x2a8>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f5a6:	85 e3       	ldi	r24, 0x35	; 53
    f5a8:	90 e0       	ldi	r25, 0x00	; 0
    f5aa:	c8 9e       	mul	r12, r24
    f5ac:	70 01       	movw	r14, r0
    f5ae:	c9 9e       	mul	r12, r25
    f5b0:	f0 0c       	add	r15, r0
    f5b2:	d8 9e       	mul	r13, r24
    f5b4:	f0 0c       	add	r15, r0
    f5b6:	11 24       	eor	r1, r1
    f5b8:	87 01       	movw	r16, r14
    f5ba:	05 57       	subi	r16, 0x75	; 117
    f5bc:	18 4f       	sbci	r17, 0xF8	; 248
    f5be:	a0 0f       	add	r26, r16
    f5c0:	b1 1f       	adc	r27, r17
    f5c2:	53 96       	adiw	r26, 0x13	; 19
    f5c4:	1c 92       	st	X, r1
			 //TransNum,Date,Time
			 StrPosCopy(strTranNo,RecPumpData[FIPAddr].strTransNum,0,strlen(strTranNo));
			 StrPosCopy(strTransDate,RecPumpData[FIPAddr].strTransDate,0,strlen(strTransDate));
			 StrPosCopy(strTransTime,RecPumpData[FIPAddr].strTransTime,0,strlen(strTransTime));
			 //Grade Nozzle Shift
			 RecPumpData[FIPAddr].Grade=PGrade;
    f5c6:	f0 ed       	ldi	r31, 0xD0	; 208
    f5c8:	2f 0e       	add	r2, r31
    f5ca:	d8 01       	movw	r26, r16
    f5cc:	2c 92       	st	X, r2
			 RecPumpData[FIPAddr].Nozzle=PNozzle;
    f5ce:	b9 a9       	ldd	r27, Y+49	; 0x31
    f5d0:	b0 53       	subi	r27, 0x30	; 48
    f5d2:	f8 01       	movw	r30, r16
    f5d4:	b1 83       	std	Z+1, r27	; 0x01
			 RecPumpData[FIPAddr].Shift=atoi(strShift);
    f5d6:	83 e4       	ldi	r24, 0x43	; 67
    f5d8:	9e e0       	ldi	r25, 0x0E	; 14
    f5da:	0e 94 45 b5 	call	0x16a8a	; 0x16a8a <atoi>
    f5de:	d8 01       	movw	r26, r16
    f5e0:	12 96       	adiw	r26, 0x02	; 2
    f5e2:	8c 93       	st	X, r24
			 //Price Volume Money
			 StrPosCopy(strPPU,RecPumpData[FIPAddr].Price,0,strlen(strPPU));
    f5e4:	fe 01       	movw	r30, r28
    f5e6:	34 96       	adiw	r30, 0x04	; 4
    f5e8:	df 01       	movw	r26, r30
    f5ea:	0d 90       	ld	r0, X+
    f5ec:	00 20       	and	r0, r0
    f5ee:	e9 f7       	brne	.-6      	; 0xf5ea <StoreStandaloneTransData+0x2fe>
    f5f0:	11 97       	sbiw	r26, 0x01	; 1
    f5f2:	ae 1b       	sub	r26, r30
    f5f4:	bf 0b       	sbc	r27, r31
    f5f6:	97 01       	movw	r18, r14
    f5f8:	29 55       	subi	r18, 0x59	; 89
    f5fa:	38 4f       	sbci	r19, 0xF8	; 248
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f5fc:	af 01       	movw	r20, r30
    f5fe:	4a 0f       	add	r20, r26
    f600:	5b 1f       	adc	r21, r27
    f602:	06 c0       	rjmp	.+12     	; 0xf610 <StoreStandaloneTransData+0x324>
	    Dest[i]=Source[IdxSource+i];
    f604:	f4 01       	movw	r30, r8
    f606:	81 91       	ld	r24, Z+
    f608:	4f 01       	movw	r8, r30
    f60a:	f9 01       	movw	r30, r18
    f60c:	81 93       	st	Z+, r24
    f60e:	9f 01       	movw	r18, r30
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f610:	84 16       	cp	r8, r20
    f612:	95 06       	cpc	r9, r21
    f614:	b9 f7       	brne	.-18     	; 0xf604 <StoreStandaloneTransData+0x318>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f616:	85 e3       	ldi	r24, 0x35	; 53
    f618:	90 e0       	ldi	r25, 0x00	; 0
    f61a:	9c 01       	movw	r18, r24
    f61c:	c2 9e       	mul	r12, r18
    f61e:	c0 01       	movw	r24, r0
    f620:	c3 9e       	mul	r12, r19
    f622:	90 0d       	add	r25, r0
    f624:	d2 9e       	mul	r13, r18
    f626:	90 0d       	add	r25, r0
    f628:	11 24       	eor	r1, r1
    f62a:	fc 01       	movw	r30, r24
    f62c:	e5 57       	subi	r30, 0x75	; 117
    f62e:	f8 4f       	sbci	r31, 0xF8	; 248
    f630:	ea 0f       	add	r30, r26
    f632:	fb 1f       	adc	r31, r27
    f634:	14 8e       	std	Z+28, r1	; 0x1c
			 RecPumpData[FIPAddr].Grade=PGrade;
			 RecPumpData[FIPAddr].Nozzle=PNozzle;
			 RecPumpData[FIPAddr].Shift=atoi(strShift);
			 //Price Volume Money
			 StrPosCopy(strPPU,RecPumpData[FIPAddr].Price,0,strlen(strPPU));
			 StrPosCopy(strPVolume,RecPumpData[FIPAddr].Volume,0,strlen(strPVolume));
    f636:	fe 01       	movw	r30, r28
    f638:	7d 96       	adiw	r30, 0x1d	; 29
    f63a:	df 01       	movw	r26, r30
    f63c:	0d 90       	ld	r0, X+
    f63e:	00 20       	and	r0, r0
    f640:	e9 f7       	brne	.-6      	; 0xf63c <StoreStandaloneTransData+0x350>
    f642:	11 97       	sbiw	r26, 0x01	; 1
    f644:	ae 1b       	sub	r26, r30
    f646:	bf 0b       	sbc	r27, r31
    f648:	9c 01       	movw	r18, r24
    f64a:	22 55       	subi	r18, 0x52	; 82
    f64c:	38 4f       	sbci	r19, 0xF8	; 248
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f64e:	af 01       	movw	r20, r30
    f650:	4a 0f       	add	r20, r26
    f652:	5b 1f       	adc	r21, r27
    f654:	06 c0       	rjmp	.+12     	; 0xf662 <StoreStandaloneTransData+0x376>
	    Dest[i]=Source[IdxSource+i];
    f656:	f3 01       	movw	r30, r6
    f658:	81 91       	ld	r24, Z+
    f65a:	3f 01       	movw	r6, r30
    f65c:	f9 01       	movw	r30, r18
    f65e:	81 93       	st	Z+, r24
    f660:	9f 01       	movw	r18, r30
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f662:	64 16       	cp	r6, r20
    f664:	75 06       	cpc	r7, r21
    f666:	b9 f7       	brne	.-18     	; 0xf656 <StoreStandaloneTransData+0x36a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f668:	85 e3       	ldi	r24, 0x35	; 53
    f66a:	90 e0       	ldi	r25, 0x00	; 0
    f66c:	9c 01       	movw	r18, r24
    f66e:	c2 9e       	mul	r12, r18
    f670:	c0 01       	movw	r24, r0
    f672:	c3 9e       	mul	r12, r19
    f674:	90 0d       	add	r25, r0
    f676:	d2 9e       	mul	r13, r18
    f678:	90 0d       	add	r25, r0
    f67a:	11 24       	eor	r1, r1
    f67c:	fc 01       	movw	r30, r24
    f67e:	e5 57       	subi	r30, 0x75	; 117
    f680:	f8 4f       	sbci	r31, 0xF8	; 248
    f682:	ea 0f       	add	r30, r26
    f684:	fb 1f       	adc	r31, r27
    f686:	13 a2       	std	Z+35, r1	; 0x23
			 RecPumpData[FIPAddr].Nozzle=PNozzle;
			 RecPumpData[FIPAddr].Shift=atoi(strShift);
			 //Price Volume Money
			 StrPosCopy(strPPU,RecPumpData[FIPAddr].Price,0,strlen(strPPU));
			 StrPosCopy(strPVolume,RecPumpData[FIPAddr].Volume,0,strlen(strPVolume));
			 StrPosCopy(strPMoney,RecPumpData[FIPAddr].Money,0,strlen(strPMoney));
    f688:	fe 01       	movw	r30, r28
    f68a:	b7 96       	adiw	r30, 0x27	; 39
    f68c:	df 01       	movw	r26, r30
    f68e:	0d 90       	ld	r0, X+
    f690:	00 20       	and	r0, r0
    f692:	e9 f7       	brne	.-6      	; 0xf68e <StoreStandaloneTransData+0x3a2>
    f694:	11 97       	sbiw	r26, 0x01	; 1
    f696:	ae 1b       	sub	r26, r30
    f698:	bf 0b       	sbc	r27, r31
    f69a:	9c 01       	movw	r18, r24
    f69c:	29 54       	subi	r18, 0x49	; 73
    f69e:	38 4f       	sbci	r19, 0xF8	; 248
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f6a0:	af 01       	movw	r20, r30
    f6a2:	4a 0f       	add	r20, r26
    f6a4:	5b 1f       	adc	r21, r27
    f6a6:	06 c0       	rjmp	.+12     	; 0xf6b4 <StoreStandaloneTransData+0x3c8>
	    Dest[i]=Source[IdxSource+i];
    f6a8:	f2 01       	movw	r30, r4
    f6aa:	81 91       	ld	r24, Z+
    f6ac:	2f 01       	movw	r4, r30
    f6ae:	f9 01       	movw	r30, r18
    f6b0:	81 93       	st	Z+, r24
    f6b2:	9f 01       	movw	r18, r30
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f6b4:	44 16       	cp	r4, r20
    f6b6:	55 06       	cpc	r5, r21
    f6b8:	b9 f7       	brne	.-18     	; 0xf6a8 <StoreStandaloneTransData+0x3bc>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f6ba:	85 e3       	ldi	r24, 0x35	; 53
    f6bc:	90 e0       	ldi	r25, 0x00	; 0
    f6be:	c8 9e       	mul	r12, r24
    f6c0:	f0 01       	movw	r30, r0
    f6c2:	c9 9e       	mul	r12, r25
    f6c4:	f0 0d       	add	r31, r0
    f6c6:	d8 9e       	mul	r13, r24
    f6c8:	f0 0d       	add	r31, r0
    f6ca:	11 24       	eor	r1, r1
    f6cc:	e5 57       	subi	r30, 0x75	; 117
    f6ce:	f8 4f       	sbci	r31, 0xF8	; 248
    f6d0:	ea 0f       	add	r30, r26
    f6d2:	fb 1f       	adc	r31, r27
    f6d4:	14 a6       	std	Z+44, r1	; 0x2c
			 //Price Volume Money
			 StrPosCopy(strPPU,RecPumpData[FIPAddr].Price,0,strlen(strPPU));
			 StrPosCopy(strPVolume,RecPumpData[FIPAddr].Volume,0,strlen(strPVolume));
			 StrPosCopy(strPMoney,RecPumpData[FIPAddr].Money,0,strlen(strPMoney));

			 UpdateStandaloneStatus((iPumpID&0x0F),PS_PRINT_READY);
    f6d6:	83 2d       	mov	r24, r3
    f6d8:	8f 70       	andi	r24, 0x0F	; 15
    f6da:	60 e1       	ldi	r22, 0x10	; 16
    f6dc:	0e 94 18 1e 	call	0x3c30	; 0x3c30 <UpdateStandaloneStatus>
			 
			 SetIncomingTransStatus(iPumpID,TS_NEW);		 
    f6e0:	83 2d       	mov	r24, r3
    f6e2:	62 e0       	ldi	r22, 0x02	; 2
    f6e4:	0e 94 b1 1a 	call	0x3562	; 0x3562 <SetIncomingTransStatus>

			 SendSlaveCommand(SC_TRANSACTION_ACK,iPumpID);
    f6e8:	8b e0       	ldi	r24, 0x0B	; 11
    f6ea:	63 2d       	mov	r22, r3
    f6ec:	0e 94 de 73 	call	0xe7bc	; 0xe7bc <SendSlaveCommand>
    f6f0:	4b c0       	rjmp	.+150    	; 0xf788 <StoreStandaloneTransData+0x49c>
			 UpdateStandaloneStatus((iPumpID&0x0F),PS_VOID);
		 }
		 else 
		 if (TransactionStatus=TS_NEW){ 
			 //Update ReprintReady
			 ReprintReady[FIPAddr]=True;//Ready for Printing
    f6f2:	da 94       	dec	r13
    f6f4:	cd 2c       	mov	r12, r13
    f6f6:	dd 24       	eor	r13, r13
    f6f8:	f6 01       	movw	r30, r12
    f6fa:	ee 57       	subi	r30, 0x7E	; 126
    f6fc:	fe 4f       	sbci	r31, 0xFE	; 254
    f6fe:	81 e0       	ldi	r24, 0x01	; 1
    f700:	80 83       	st	Z, r24
			  
			 FormatPrice(strPPU);
    f702:	c7 01       	movw	r24, r14
    f704:	0e 94 15 35 	call	0x6a2a	; 0x6a2a <FormatPrice>
			 FormatMoney(strPMoney);
    f708:	c8 01       	movw	r24, r16
    f70a:	0e 94 08 35 	call	0x6a10	; 0x6a10 <FormatMoney>
			 FormatVolume(strPVolume);
    f70e:	c5 01       	movw	r24, r10
    f710:	0e 94 fb 34 	call	0x69f6	; 0x69f6 <FormatVolume>

			 //_uart_print(1,1,strPVolume);
			 
			 GenerateTransactionNum(strTranNo);		 
    f714:	81 e6       	ldi	r24, 0x61	; 97
    f716:	9e e0       	ldi	r25, 0x0E	; 14
    f718:	0e 94 7f 40 	call	0x80fe	; 0x80fe <GenerateTransactionNum>
			 sprintf_P(strTransDate,PSTR("%s"),strSystemDate);
    f71c:	00 d0       	rcall	.+0      	; 0xf71e <StoreStandaloneTransData+0x432>
    f71e:	00 d0       	rcall	.+0      	; 0xf720 <StoreStandaloneTransData+0x434>
    f720:	00 d0       	rcall	.+0      	; 0xf722 <StoreStandaloneTransData+0x436>
    f722:	ed b7       	in	r30, 0x3d	; 61
    f724:	fe b7       	in	r31, 0x3e	; 62
    f726:	31 96       	adiw	r30, 0x01	; 1
    f728:	ce 01       	movw	r24, r28
    f72a:	0b 96       	adiw	r24, 0x0b	; 11
    f72c:	ad b7       	in	r26, 0x3d	; 61
    f72e:	be b7       	in	r27, 0x3e	; 62
    f730:	12 96       	adiw	r26, 0x02	; 2
    f732:	9c 93       	st	X, r25
    f734:	8e 93       	st	-X, r24
    f736:	11 97       	sbiw	r26, 0x01	; 1
    f738:	88 ec       	ldi	r24, 0xC8	; 200
    f73a:	92 e2       	ldi	r25, 0x22	; 34
    f73c:	93 83       	std	Z+3, r25	; 0x03
    f73e:	82 83       	std	Z+2, r24	; 0x02
    f740:	8a e9       	ldi	r24, 0x9A	; 154
    f742:	95 e0       	ldi	r25, 0x05	; 5
    f744:	95 83       	std	Z+5, r25	; 0x05
    f746:	84 83       	std	Z+4, r24	; 0x04
    f748:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
			 sprintf_P(strTransTime,PSTR("%s"),strSystemTime);
    f74c:	ed b7       	in	r30, 0x3d	; 61
    f74e:	fe b7       	in	r31, 0x3e	; 62
    f750:	31 96       	adiw	r30, 0x01	; 1
    f752:	ce 01       	movw	r24, r28
    f754:	44 96       	adiw	r24, 0x14	; 20
    f756:	ad b7       	in	r26, 0x3d	; 61
    f758:	be b7       	in	r27, 0x3e	; 62
    f75a:	12 96       	adiw	r26, 0x02	; 2
    f75c:	9c 93       	st	X, r25
    f75e:	8e 93       	st	-X, r24
    f760:	11 97       	sbiw	r26, 0x01	; 1
    f762:	85 ec       	ldi	r24, 0xC5	; 197
    f764:	92 e2       	ldi	r25, 0x22	; 34
    f766:	93 83       	std	Z+3, r25	; 0x03
    f768:	82 83       	std	Z+2, r24	; 0x02
    f76a:	89 e7       	ldi	r24, 0x79	; 121
    f76c:	9a e0       	ldi	r25, 0x0A	; 10
    f76e:	95 83       	std	Z+5, r25	; 0x05
    f770:	84 83       	std	Z+4, r24	; 0x04
    f772:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    f776:	ed b7       	in	r30, 0x3d	; 61
    f778:	fe b7       	in	r31, 0x3e	; 62
    f77a:	36 96       	adiw	r30, 0x06	; 6
    f77c:	0f b6       	in	r0, 0x3f	; 63
    f77e:	f8 94       	cli
    f780:	fe bf       	out	0x3e, r31	; 62
    f782:	0f be       	out	0x3f, r0	; 63
    f784:	ed bf       	out	0x3d, r30	; 61
    f786:	75 ce       	rjmp	.-790    	; 0xf472 <StoreStandaloneTransData+0x186>

			 SendSlaveCommand(SC_TRANSACTION_ACK,iPumpID);
		 }		 
	 }    
     //_uart_print(0,1,strRawTransData);
}
    f788:	e1 96       	adiw	r28, 0x31	; 49
    f78a:	0f b6       	in	r0, 0x3f	; 63
    f78c:	f8 94       	cli
    f78e:	de bf       	out	0x3e, r29	; 62
    f790:	0f be       	out	0x3f, r0	; 63
    f792:	cd bf       	out	0x3d, r28	; 61
    f794:	cf 91       	pop	r28
    f796:	df 91       	pop	r29
    f798:	1f 91       	pop	r17
    f79a:	0f 91       	pop	r16
    f79c:	ff 90       	pop	r15
    f79e:	ef 90       	pop	r14
    f7a0:	df 90       	pop	r13
    f7a2:	cf 90       	pop	r12
    f7a4:	bf 90       	pop	r11
    f7a6:	af 90       	pop	r10
    f7a8:	9f 90       	pop	r9
    f7aa:	8f 90       	pop	r8
    f7ac:	7f 90       	pop	r7
    f7ae:	6f 90       	pop	r6
    f7b0:	5f 90       	pop	r5
    f7b2:	4f 90       	pop	r4
    f7b4:	3f 90       	pop	r3
    f7b6:	2f 90       	pop	r2
    f7b8:	08 95       	ret

0000f7ba <StoreStandaloneTotalizerData>:
	  systemEDC();
	  systemConfigProtocol();
	  //systemGeniusProtocol(); //AKR-->Protocol disabled
}

void StoreStandaloneTotalizerData(char *strRawTransData){//Sending FlowSPI_Protocol <STX>   [MsgID][PumpID][Volume1][Amount1][Volume2][Amount2][Volume3][Amount3][Volume4][Amount4][Volume5][Amount5][Volume6][Amount6]<ETX>
    f7ba:	2f 92       	push	r2
    f7bc:	3f 92       	push	r3
    f7be:	4f 92       	push	r4
    f7c0:	5f 92       	push	r5
    f7c2:	7f 92       	push	r7
    f7c4:	8f 92       	push	r8
    f7c6:	9f 92       	push	r9
    f7c8:	af 92       	push	r10
    f7ca:	bf 92       	push	r11
    f7cc:	cf 92       	push	r12
    f7ce:	df 92       	push	r13
    f7d0:	ef 92       	push	r14
    f7d2:	ff 92       	push	r15
    f7d4:	0f 93       	push	r16
    f7d6:	1f 93       	push	r17
    f7d8:	df 93       	push	r29
    f7da:	cf 93       	push	r28
    f7dc:	cd b7       	in	r28, 0x3d	; 61
    f7de:	de b7       	in	r29, 0x3e	; 62
    f7e0:	a1 97       	sbiw	r28, 0x21	; 33
    f7e2:	0f b6       	in	r0, 0x3f	; 63
    f7e4:	f8 94       	cli
    f7e6:	de bf       	out	0x3e, r29	; 62
    f7e8:	0f be       	out	0x3f, r0	; 63
    f7ea:	cd bf       	out	0x3d, r28	; 61
    f7ec:	8c 01       	movw	r16, r24
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    f7ee:	fc 01       	movw	r30, r24
    f7f0:	82 81       	ldd	r24, Z+2	; 0x02
    f7f2:	89 83       	std	Y+1, r24	; 0x01
    f7f4:	83 81       	ldd	r24, Z+3	; 0x03
    f7f6:	8a 83       	std	Y+2, r24	; 0x02
	 }Dest[Length]=0;
    f7f8:	1b 82       	std	Y+3, r1	; 0x03
	 //    _uart(1,1,strRawTransData[i]); 
	 // }

     StrPosCopy(strRawTransData,strPumpID,2,2);
	 //IdIFT(strPumpID);
	 iPumpID=atoi(strPumpID);  
    f7fa:	ce 01       	movw	r24, r28
    f7fc:	01 96       	adiw	r24, 0x01	; 1
    f7fe:	0e 94 45 b5 	call	0x16a8a	; 0x16a8a <atoi>
    f802:	c8 2e       	mov	r12, r24
	 
	 FIPAddr=GetFIPAddr(iPumpID);
    f804:	0e 94 e1 1d 	call	0x3bc2	; 0x3bc2 <GetFIPAddr>
	 if (FIPAddr>0){
    f808:	88 23       	and	r24, r24
    f80a:	09 f4       	brne	.+2      	; 0xf80e <StoreStandaloneTotalizerData+0x54>
    f80c:	44 c0       	rjmp	.+136    	; 0xf896 <StoreStandaloneTotalizerData+0xdc>
	     FIPAddr=FIPAddr-1;
    f80e:	78 2e       	mov	r7, r24
    f810:	7a 94       	dec	r7
    f812:	80 e1       	ldi	r24, 0x10	; 16
    f814:	e8 2e       	mov	r14, r24
    f816:	f1 2c       	mov	r15, r1
    f818:	e0 0e       	add	r14, r16
    f81a:	f1 1e       	adc	r15, r17
    f81c:	dd 24       	eor	r13, r13
    f81e:	d3 94       	inc	r13
    f820:	14 e0       	ldi	r17, 0x04	; 4
    f822:	81 2e       	mov	r8, r17
    f824:	91 2c       	mov	r9, r1
    f826:	8c 0e       	add	r8, r28
    f828:	9d 1e       	adc	r9, r29
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f82a:	b0 e1       	ldi	r27, 0x10	; 16
    f82c:	2b 2e       	mov	r2, r27
    f82e:	31 2c       	mov	r3, r1
    f830:	2c 0e       	add	r2, r28
    f832:	3d 1e       	adc	r3, r29
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f834:	a3 e1       	ldi	r26, 0x13	; 19
    f836:	aa 2e       	mov	r10, r26
    f838:	b1 2c       	mov	r11, r1
    f83a:	ac 0e       	add	r10, r28
    f83c:	bd 1e       	adc	r11, r29
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f83e:	ff e1       	ldi	r31, 0x1F	; 31
    f840:	4f 2e       	mov	r4, r31
    f842:	51 2c       	mov	r5, r1
    f844:	4c 0e       	add	r4, r28
    f846:	5d 1e       	adc	r5, r29
	 //IdIFT(strPumpID);
	 iPumpID=atoi(strPumpID);  
	 
	 FIPAddr=GetFIPAddr(iPumpID);
	 if (FIPAddr>0){
	     FIPAddr=FIPAddr-1;
    f848:	d7 01       	movw	r26, r14
    f84a:	1c 97       	sbiw	r26, 0x0c	; 12
    f84c:	f4 01       	movw	r30, r8
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    f84e:	8d 91       	ld	r24, X+
    f850:	81 93       	st	Z+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f852:	e2 15       	cp	r30, r2
    f854:	f3 05       	cpc	r31, r3
    f856:	d9 f7       	brne	.-10     	; 0xf84e <StoreStandaloneTotalizerData+0x94>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f858:	18 8a       	std	Y+16, r1	; 0x10
    f85a:	f5 01       	movw	r30, r10
    f85c:	d7 01       	movw	r26, r14
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    f85e:	8d 91       	ld	r24, X+
    f860:	81 93       	st	Z+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f862:	e4 15       	cp	r30, r4
    f864:	f5 05       	cpc	r31, r5
    f866:	d9 f7       	brne	.-10     	; 0xf85e <StoreStandaloneTotalizerData+0xa4>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f868:	1f 8e       	std	Y+31, r1	; 0x1f

		 for (iGrade=1;iGrade<=6;iGrade++){          
			  StrPosCopy(strRawTransData,strGVolume,(4+((iGrade-1)*24)),12);
			  StrPosCopy(strRawTransData,strGMoney,(16+((iGrade-1)*24)),12);
			  
			  SetTotalizerData(TVOLUME,TOTALIZER_NOW,FIPAddr,iGrade,strGVolume);
    f86a:	80 e0       	ldi	r24, 0x00	; 0
    f86c:	61 e0       	ldi	r22, 0x01	; 1
    f86e:	47 2d       	mov	r20, r7
    f870:	2d 2d       	mov	r18, r13
    f872:	84 01       	movw	r16, r8
    f874:	0e 94 4c 28 	call	0x5098	; 0x5098 <SetTotalizerData>
			  SetTotalizerData(TMONEY,TOTALIZER_NOW,FIPAddr,iGrade,strGMoney);
    f878:	81 e0       	ldi	r24, 0x01	; 1
    f87a:	61 e0       	ldi	r22, 0x01	; 1
    f87c:	47 2d       	mov	r20, r7
    f87e:	2d 2d       	mov	r18, r13
    f880:	85 01       	movw	r16, r10
    f882:	0e 94 4c 28 	call	0x5098	; 0x5098 <SetTotalizerData>
	 FIPAddr=GetFIPAddr(iPumpID);
	 if (FIPAddr>0){
	     FIPAddr=FIPAddr-1;
		 //_uart_printf(1,1,PSTR("Totalizer:"));

		 for (iGrade=1;iGrade<=6;iGrade++){          
    f886:	d3 94       	inc	r13
    f888:	88 e1       	ldi	r24, 0x18	; 24
    f88a:	90 e0       	ldi	r25, 0x00	; 0
    f88c:	e8 0e       	add	r14, r24
    f88e:	f9 1e       	adc	r15, r25
    f890:	97 e0       	ldi	r25, 0x07	; 7
    f892:	d9 16       	cp	r13, r25
    f894:	c9 f6       	brne	.-78     	; 0xf848 <StoreStandaloneTotalizerData+0x8e>
			  SetTotalizerData(TMONEY,TOTALIZER_NOW,FIPAddr,iGrade,strGMoney);
			  //sprintf_P(strSend,PSTR("Nozzle:%d Volume:%s Money:%s"),iGrade,strGVolume,strGMoney);
			  //_uart_print(0,1,strSend);
		 }	
	}
     SendSlaveCommand(SC_TOTALIZER_ACK,iPumpID);
    f896:	8d e0       	ldi	r24, 0x0D	; 13
    f898:	6c 2d       	mov	r22, r12
    f89a:	0e 94 de 73 	call	0xe7bc	; 0xe7bc <SendSlaveCommand>
	 UpdateStandaloneStatus((iPumpID&0x0F),PS_TOTALIZER);	 
    f89e:	8c 2d       	mov	r24, r12
    f8a0:	8f 70       	andi	r24, 0x0F	; 15
    f8a2:	64 e1       	ldi	r22, 0x14	; 20
    f8a4:	0e 94 18 1e 	call	0x3c30	; 0x3c30 <UpdateStandaloneStatus>
}
    f8a8:	a1 96       	adiw	r28, 0x21	; 33
    f8aa:	0f b6       	in	r0, 0x3f	; 63
    f8ac:	f8 94       	cli
    f8ae:	de bf       	out	0x3e, r29	; 62
    f8b0:	0f be       	out	0x3f, r0	; 63
    f8b2:	cd bf       	out	0x3d, r28	; 61
    f8b4:	cf 91       	pop	r28
    f8b6:	df 91       	pop	r29
    f8b8:	1f 91       	pop	r17
    f8ba:	0f 91       	pop	r16
    f8bc:	ff 90       	pop	r15
    f8be:	ef 90       	pop	r14
    f8c0:	df 90       	pop	r13
    f8c2:	cf 90       	pop	r12
    f8c4:	bf 90       	pop	r11
    f8c6:	af 90       	pop	r10
    f8c8:	9f 90       	pop	r9
    f8ca:	8f 90       	pop	r8
    f8cc:	7f 90       	pop	r7
    f8ce:	5f 90       	pop	r5
    f8d0:	4f 90       	pop	r4
    f8d2:	3f 90       	pop	r3
    f8d4:	2f 90       	pop	r2
    f8d6:	08 95       	ret

0000f8d8 <ScanStandaloneFlow>:
	 _spi(SlaveMessage);
	 _spi(0x06);
	 systemSlave();
}

void ScanStandaloneFlow(char data){  //<STX>[PumpID][STA]<ETX> --> 0x07 0xF1 0xF2 0x08
    f8d8:	0f 93       	push	r16
    f8da:	1f 93       	push	r17
    f8dc:	08 2f       	mov	r16, r24

      DataPumpID=0;
      DataPumpStatus=0;
	  MixData=0;
      //Shift data
      zDataFlow[4]=zDataFlow[3];
    f8de:	80 91 b7 03 	lds	r24, 0x03B7
    f8e2:	80 93 b8 03 	sts	0x03B8, r24
	  zDataFlow[3]=zDataFlow[2];
    f8e6:	80 91 b6 03 	lds	r24, 0x03B6
    f8ea:	80 93 b7 03 	sts	0x03B7, r24
	  zDataFlow[2]=zDataFlow[1];
    f8ee:	80 91 b5 03 	lds	r24, 0x03B5
    f8f2:	80 93 b6 03 	sts	0x03B6, r24
      zDataFlow[1]=zDataFlow[0];
    f8f6:	90 91 b4 03 	lds	r25, 0x03B4
    f8fa:	90 93 b5 03 	sts	0x03B5, r25
      zDataFlow[0]=data;
    f8fe:	00 93 b4 03 	sts	0x03B4, r16

      //Scan UpdatedPumpStatus Flow
	  //<STX>[ID][STA]<ETX>: 0x07[ID STA]0x08
	  if((zDataFlow[2]==0x07)&&(zDataFlow[0]==0x08)){
    f902:	87 30       	cpi	r24, 0x07	; 7
    f904:	79 f4       	brne	.+30     	; 0xf924 <ScanStandaloneFlow+0x4c>
    f906:	08 30       	cpi	r16, 0x08	; 8
    f908:	69 f4       	brne	.+26     	; 0xf924 <ScanStandaloneFlow+0x4c>
          MixData=zDataFlow[1];
	      DataPumpID=((MixData&0xF0)>>4);
		  DataPumpStatus=(MixData&0x0F);
    f90a:	19 2f       	mov	r17, r25
    f90c:	1f 70       	andi	r17, 0x0F	; 15
		  UpdateStandaloneStatus(DataPumpID,DataPumpStatus);
    f90e:	89 2f       	mov	r24, r25
    f910:	82 95       	swap	r24
    f912:	8f 70       	andi	r24, 0x0F	; 15
    f914:	61 2f       	mov	r22, r17
    f916:	0e 94 18 1e 	call	0x3c30	; 0x3c30 <UpdateStandaloneStatus>
		  if (DataPumpStatus!=PUMP_NONE)IsStandAloneDetected=True;
    f91a:	1e 30       	cpi	r17, 0x0E	; 14
    f91c:	19 f0       	breq	.+6      	; 0xf924 <ScanStandaloneFlow+0x4c>
    f91e:	81 e0       	ldi	r24, 0x01	; 1
    f920:	80 93 b3 01 	sts	0x01B3, r24
		  //sprintf_P(strSend,PSTR("PS:%d Id:%d"),MixData,DataPumpID);
		  //_uart_print(0,1,strSend);
	  }

	  //Scan Transaction Completion FEOT
	  if (IsStandaloneTrans==True){
    f924:	80 91 b4 01 	lds	r24, 0x01B4
    f928:	81 30       	cpi	r24, 0x01	; 1
    f92a:	69 f4       	brne	.+26     	; 0xf946 <ScanStandaloneFlow+0x6e>
	      strStandReceived[iFlow]=data;
    f92c:	80 91 b2 03 	lds	r24, 0x03B2
    f930:	90 91 b3 03 	lds	r25, 0x03B3
    f934:	fc 01       	movw	r30, r24
    f936:	ea 51       	subi	r30, 0x1A	; 26
    f938:	fb 4f       	sbci	r31, 0xFB	; 251
    f93a:	00 83       	st	Z, r16
		  iFlow++;
    f93c:	01 96       	adiw	r24, 0x01	; 1
    f93e:	90 93 b3 03 	sts	0x03B3, r25
    f942:	80 93 b2 03 	sts	0x03B2, r24
	  }
	  if((zDataFlow[1]==0x05)&&(zDataFlow[0]==0x50)){
    f946:	80 91 b5 03 	lds	r24, 0x03B5
    f94a:	85 30       	cpi	r24, 0x05	; 5
    f94c:	61 f4       	brne	.+24     	; 0xf966 <ScanStandaloneFlow+0x8e>
    f94e:	80 91 b4 03 	lds	r24, 0x03B4
    f952:	80 35       	cpi	r24, 0x50	; 80
    f954:	41 f5       	brne	.+80     	; 0xf9a6 <ScanStandaloneFlow+0xce>
	      IsStandaloneTrans=True;
    f956:	81 e0       	ldi	r24, 0x01	; 1
    f958:	80 93 b4 01 	sts	0x01B4, r24
		  iFlow=0;
    f95c:	10 92 b3 03 	sts	0x03B3, r1
    f960:	10 92 b2 03 	sts	0x03B2, r1
    f964:	20 c0       	rjmp	.+64     	; 0xf9a6 <ScanStandaloneFlow+0xce>
	  }
	  if((zDataFlow[1]==0x06)&&(zDataFlow[0]==0x60)){
    f966:	86 30       	cpi	r24, 0x06	; 6
    f968:	f1 f4       	brne	.+60     	; 0xf9a6 <ScanStandaloneFlow+0xce>
    f96a:	80 91 b4 03 	lds	r24, 0x03B4
    f96e:	80 36       	cpi	r24, 0x60	; 96
    f970:	d1 f4       	brne	.+52     	; 0xf9a6 <ScanStandaloneFlow+0xce>
	      IsStandaloneTrans=False;
    f972:	10 92 b4 01 	sts	0x01B4, r1
	      strStandReceived[iFlow]=0;
    f976:	e0 91 b2 03 	lds	r30, 0x03B2
    f97a:	f0 91 b3 03 	lds	r31, 0x03B3
    f97e:	ea 51       	subi	r30, 0x1A	; 26
    f980:	fb 4f       	sbci	r31, 0xFB	; 251
    f982:	10 82       	st	Z, r1

		  //_uart_print(1,1,strStandReceived);

		  MsgIDx=GetMessageID(strStandReceived);
    f984:	86 ee       	ldi	r24, 0xE6	; 230
    f986:	94 e0       	ldi	r25, 0x04	; 4
    f988:	0e 94 d4 44 	call	0x89a8	; 0x89a8 <GetMessageID>
          if (MsgIDx==0x01)StoreStandaloneTransData(strStandReceived);
    f98c:	81 30       	cpi	r24, 0x01	; 1
    f98e:	29 f4       	brne	.+10     	; 0xf99a <ScanStandaloneFlow+0xc2>
    f990:	86 ee       	ldi	r24, 0xE6	; 230
    f992:	94 e0       	ldi	r25, 0x04	; 4
    f994:	0e 94 76 79 	call	0xf2ec	; 0xf2ec <StoreStandaloneTransData>
    f998:	06 c0       	rjmp	.+12     	; 0xf9a6 <ScanStandaloneFlow+0xce>
		  else
          if (MsgIDx==0x02)StoreStandaloneTotalizerData(strStandReceived);
    f99a:	82 30       	cpi	r24, 0x02	; 2
    f99c:	21 f4       	brne	.+8      	; 0xf9a6 <ScanStandaloneFlow+0xce>
    f99e:	86 ee       	ldi	r24, 0xE6	; 230
    f9a0:	94 e0       	ldi	r25, 0x04	; 4
    f9a2:	0e 94 dd 7b 	call	0xf7ba	; 0xf7ba <StoreStandaloneTotalizerData>
	  }
	  //AcknoledgeCommand
	  if ((zDataFlow[3]==0x09)&&(zDataFlow[0]==0x0A)){
    f9a6:	80 91 b7 03 	lds	r24, 0x03B7
    f9aa:	89 30       	cpi	r24, 0x09	; 9
    f9ac:	c1 f5       	brne	.+112    	; 0xfa1e <ScanStandaloneFlow+0x146>
    f9ae:	80 91 b4 03 	lds	r24, 0x03B4
    f9b2:	8a 30       	cpi	r24, 0x0A	; 10
    f9b4:	a1 f5       	brne	.+104    	; 0xfa1e <ScanStandaloneFlow+0x146>
	      
	      AcknoledgePump=zDataFlow[1];
    f9b6:	90 91 b5 03 	lds	r25, 0x03B5
    f9ba:	90 93 c7 0d 	sts	0x0DC7, r25
	      AcknoledgeCommand=zDataFlow[2];	  
    f9be:	80 91 b6 03 	lds	r24, 0x03B6
    f9c2:	80 93 80 07 	sts	0x0780, r24
		  switch(AcknoledgeCommand){
    f9c6:	89 31       	cpi	r24, 0x19	; 25
    f9c8:	51 f0       	breq	.+20     	; 0xf9de <ScanStandaloneFlow+0x106>
    f9ca:	8a 31       	cpi	r24, 0x1A	; 26
    f9cc:	18 f4       	brcc	.+6      	; 0xf9d4 <ScanStandaloneFlow+0xfc>
    f9ce:	85 30       	cpi	r24, 0x05	; 5
    f9d0:	19 f5       	brne	.+70     	; 0xfa18 <ScanStandaloneFlow+0x140>
    f9d2:	17 c0       	rjmp	.+46     	; 0xfa02 <ScanStandaloneFlow+0x12a>
    f9d4:	8a 31       	cpi	r24, 0x1A	; 26
    f9d6:	c9 f0       	breq	.+50     	; 0xfa0a <ScanStandaloneFlow+0x132>
    f9d8:	8c 31       	cpi	r24, 0x1C	; 28
    f9da:	f1 f4       	brne	.+60     	; 0xfa18 <ScanStandaloneFlow+0x140>
    f9dc:	1a c0       	rjmp	.+52     	; 0xfa12 <ScanStandaloneFlow+0x13a>
		  case SC_LIVE_SEQUENCE:
		       iSequencePooling=AcknoledgePump;
    f9de:	90 93 93 01 	sts	0x0193, r25
			   IsNewPoolingSequence=True;
    f9e2:	81 e0       	ldi	r24, 0x01	; 1
    f9e4:	80 93 94 01 	sts	0x0194, r24
			   //SendPoolingCommand()
			   if (IsControlPooling==True){
    f9e8:	80 91 97 01 	lds	r24, 0x0197
    f9ec:	81 30       	cpi	r24, 0x01	; 1
    f9ee:	a1 f4       	brne	.+40     	; 0xfa18 <ScanStandaloneFlow+0x140>
			       IsControlPooling=False;
    f9f0:	10 92 97 01 	sts	0x0197, r1
				   SendSlaveCommand(PoolCmd,PoolMsg);
    f9f4:	80 91 8a 07 	lds	r24, 0x078A
    f9f8:	60 91 ae 0d 	lds	r22, 0x0DAE
    f9fc:	0e 94 de 73 	call	0xe7bc	; 0xe7bc <SendSlaveCommand>
    fa00:	0b c0       	rjmp	.+22     	; 0xfa18 <ScanStandaloneFlow+0x140>
                }
		       break;
          case SC_TOTALIZER:
		       IsTotalizerReceived=True;
    fa02:	81 e0       	ldi	r24, 0x01	; 1
    fa04:	80 93 c5 01 	sts	0x01C5, r24
    fa08:	07 c0       	rjmp	.+14     	; 0xfa18 <ScanStandaloneFlow+0x140>
		       break;
		  case SC_POOL_RESTARTED:
		       IsPoolingRestarted=True;
    fa0a:	81 e0       	ldi	r24, 0x01	; 1
    fa0c:	80 93 96 01 	sts	0x0196, r24
    fa10:	03 c0       	rjmp	.+6      	; 0xfa18 <ScanStandaloneFlow+0x140>
		       break;
          case SC_SET_PUMP_TYPE:
		       IsSetPumpType=True;
    fa12:	81 e0       	ldi	r24, 0x01	; 1
    fa14:	80 93 23 01 	sts	0x0123, r24
		       break;
		  }
       IsStandaloneAcknoledge=True;
    fa18:	81 e0       	ldi	r24, 0x01	; 1
    fa1a:	80 93 95 01 	sts	0x0195, r24
	  }
}
    fa1e:	1f 91       	pop	r17
    fa20:	0f 91       	pop	r16
    fa22:	08 95       	ret

0000fa24 <__vector_17>:
//	  sprintf(SerialSend,"Length:%i",Length);	 
//	  _uart_print(1,0,SerialSend);
	 }
}

ISR(SPI_STC_vect){
    fa24:	1f 92       	push	r1
    fa26:	0f 92       	push	r0
    fa28:	0f b6       	in	r0, 0x3f	; 63
    fa2a:	0f 92       	push	r0
    fa2c:	0b b6       	in	r0, 0x3b	; 59
    fa2e:	0f 92       	push	r0
    fa30:	11 24       	eor	r1, r1
    fa32:	1f 93       	push	r17
    fa34:	2f 93       	push	r18
    fa36:	3f 93       	push	r19
    fa38:	4f 93       	push	r20
    fa3a:	5f 93       	push	r21
    fa3c:	6f 93       	push	r22
    fa3e:	7f 93       	push	r23
    fa40:	8f 93       	push	r24
    fa42:	9f 93       	push	r25
    fa44:	af 93       	push	r26
    fa46:	bf 93       	push	r27
    fa48:	ef 93       	push	r30
    fa4a:	ff 93       	push	r31
char dataSPI;
//char Reply=0;
    //_uart(0,1,SPDR);
	dataSPI=SPDR;
    fa4c:	1f b1       	in	r17, 0x0f	; 15
	ScanRFIDFlow(dataSPI);
    fa4e:	81 2f       	mov	r24, r17
    fa50:	0e 94 92 14 	call	0x2924	; 0x2924 <ScanRFIDFlow>
	if (IFType==IT_SLAVE)ScanEDCFlow(dataSPI);
    fa54:	80 91 10 01 	lds	r24, 0x0110
    fa58:	81 30       	cpi	r24, 0x01	; 1
    fa5a:	21 f4       	brne	.+8      	; 0xfa64 <__vector_17+0x40>
    fa5c:	81 2f       	mov	r24, r17
    fa5e:	0e 94 d0 13 	call	0x27a0	; 0x27a0 <ScanEDCFlow>
    fa62:	05 c0       	rjmp	.+10     	; 0xfa6e <__vector_17+0x4a>
	else
	if (IFType==IT_STANDALONE)ScanStandaloneFlow(dataSPI);
    fa64:	82 30       	cpi	r24, 0x02	; 2
    fa66:	19 f4       	brne	.+6      	; 0xfa6e <__vector_17+0x4a>
    fa68:	81 2f       	mov	r24, r17
    fa6a:	0e 94 6c 7c 	call	0xf8d8	; 0xf8d8 <ScanStandaloneFlow>
}
    fa6e:	ff 91       	pop	r31
    fa70:	ef 91       	pop	r30
    fa72:	bf 91       	pop	r27
    fa74:	af 91       	pop	r26
    fa76:	9f 91       	pop	r25
    fa78:	8f 91       	pop	r24
    fa7a:	7f 91       	pop	r23
    fa7c:	6f 91       	pop	r22
    fa7e:	5f 91       	pop	r21
    fa80:	4f 91       	pop	r20
    fa82:	3f 91       	pop	r19
    fa84:	2f 91       	pop	r18
    fa86:	1f 91       	pop	r17
    fa88:	0f 90       	pop	r0
    fa8a:	0b be       	out	0x3b, r0	; 59
    fa8c:	0f 90       	pop	r0
    fa8e:	0f be       	out	0x3f, r0	; 63
    fa90:	0f 90       	pop	r0
    fa92:	1f 90       	pop	r1
    fa94:	18 95       	reti

0000fa96 <UserInput>:
void ShowMessage(char *Message){//Display Message on Line3
     char i;
}


char UserInput(char TypeUI,char xPos, char yPos,char *strResult, unsigned int MaxValue, char MaxLength){
    fa96:	8f 92       	push	r8
    fa98:	9f 92       	push	r9
    fa9a:	af 92       	push	r10
    fa9c:	bf 92       	push	r11
    fa9e:	cf 92       	push	r12
    faa0:	df 92       	push	r13
    faa2:	ef 92       	push	r14
    faa4:	ff 92       	push	r15
    faa6:	0f 93       	push	r16
    faa8:	1f 93       	push	r17
    faaa:	cf 93       	push	r28
    faac:	df 93       	push	r29
    faae:	f8 2e       	mov	r15, r24
    fab0:	96 2e       	mov	r9, r22
    fab2:	d4 2e       	mov	r13, r20
    fab4:	e9 01       	movw	r28, r18
    fab6:	58 01       	movw	r10, r16
    fab8:	8e 2c       	mov	r8, r14
	 static char iHit=0,IsShifted=False,IsSameKey=False,IsNextKey=False,IsNewKey=False,IsFirst=False;//,KeyByte=0;
	 static unsigned int iLoop=0,KeyTimeout;//,TimerPressed=0,NewKeyTimeout;
	        unsigned int NumbValue=0;
	 char KeyPressed=0,KeyChar=0,iDisp=0;
     Result=USER_NONE;
	 switch(stUserInput){// 100 ->199 500 90
    faba:	10 91 6b 03 	lds	r17, 0x036B
    fabe:	12 30       	cpi	r17, 0x02	; 2
    fac0:	09 f4       	brne	.+2      	; 0xfac4 <UserInput+0x2e>
    fac2:	2c c2       	rjmp	.+1112   	; 0xff1c <UserInput+0x486>
    fac4:	13 30       	cpi	r17, 0x03	; 3
    fac6:	30 f4       	brcc	.+12     	; 0xfad4 <UserInput+0x3e>
    fac8:	11 23       	and	r17, r17
    faca:	59 f0       	breq	.+22     	; 0xfae2 <UserInput+0x4c>
    facc:	11 30       	cpi	r17, 0x01	; 1
    face:	09 f0       	breq	.+2      	; 0xfad2 <UserInput+0x3c>
    fad0:	f5 c2       	rjmp	.+1514   	; 0x100bc <UserInput+0x626>
    fad2:	2c c0       	rjmp	.+88     	; 0xfb2c <UserInput+0x96>
    fad4:	13 30       	cpi	r17, 0x03	; 3
    fad6:	09 f4       	brne	.+2      	; 0xfada <UserInput+0x44>
    fad8:	76 c2       	rjmp	.+1260   	; 0xffc6 <UserInput+0x530>
    fada:	14 30       	cpi	r17, 0x04	; 4
    fadc:	09 f0       	breq	.+2      	; 0xfae0 <UserInput+0x4a>
    fade:	ee c2       	rjmp	.+1500   	; 0x100bc <UserInput+0x626>
    fae0:	ef c2       	rjmp	.+1502   	; 0x100c0 <UserInput+0x62a>
	 case uiInit:
	      iLoop=0;
    fae2:	10 92 5d 03 	sts	0x035D, r1
    fae6:	10 92 5c 03 	sts	0x035C, r1
		  stUserInput=uiInput;
		  xChar=xPos;yChar=yPos;
    faea:	60 93 6a 03 	sts	0x036A, r22
    faee:	40 93 69 03 	sts	0x0369, r20
          iValuePos=0;
    faf2:	10 92 68 03 	sts	0x0368, r1
		  KeyTimeout=0;
    faf6:	10 92 5b 03 	sts	0x035B, r1
    fafa:	10 92 5a 03 	sts	0x035A, r1
		  IsSameKey=False;
    fafe:	10 92 61 03 	sts	0x0361, r1
		  IsNextKey=False;
    fb02:	10 92 60 03 	sts	0x0360, r1
		  IsNewKey=False;
    fb06:	10 92 5f 03 	sts	0x035F, r1
		  IsShifted=True;
    fb0a:	91 e0       	ldi	r25, 0x01	; 1
    fb0c:	90 93 62 03 	sts	0x0362, r25
		  zKeyChar=' ';
    fb10:	80 e2       	ldi	r24, 0x20	; 32
    fb12:	80 93 67 03 	sts	0x0367, r24
		  iHit=0;
    fb16:	10 92 63 03 	sts	0x0363, r1
		  IsFirst=False;
    fb1a:	10 92 5e 03 	sts	0x035E, r1
		  IsDelete=False;
    fb1e:	10 92 64 03 	sts	0x0364, r1
		  Result=USER_NO_DATA;
		  stUserInput=uiInput;
    fb22:	90 93 6b 03 	sts	0x036B, r25
    fb26:	35 e0       	ldi	r19, 0x05	; 5
    fb28:	e3 2e       	mov	r14, r19
    fb2a:	ce c2       	rjmp	.+1436   	; 0x100c8 <UserInput+0x632>
	      break;
	 case uiInput:
	      KeyPressed=_key_scan(1);                  //  _  ABC DEF GHI JKL MNO PQRS TUV WXYZ
    fb2c:	81 e0       	ldi	r24, 0x01	; 1
    fb2e:	0e 94 06 b0 	call	0x1600c	; 0x1600c <_key_scan>
    fb32:	c8 2e       	mov	r12, r24
		  KeyChar= _key_btn(KeyPressed);            //  1   2   3   4   5   6   7    8   9
    fb34:	0e 94 67 af 	call	0x15ece	; 0x15ece <_key_btn>
    fb38:	e8 2e       	mov	r14, r24
		  if (KeyPressed==_KEY_SHIFT){
    fb3a:	2b e7       	ldi	r18, 0x7B	; 123
    fb3c:	c2 16       	cp	r12, r18
    fb3e:	59 f4       	brne	.+22     	; 0xfb56 <UserInput+0xc0>
		      if (IsShifted==False)IsShifted=True;
    fb40:	80 91 62 03 	lds	r24, 0x0362
    fb44:	88 23       	and	r24, r24
    fb46:	19 f4       	brne	.+6      	; 0xfb4e <UserInput+0xb8>
    fb48:	10 93 62 03 	sts	0x0362, r17
    fb4c:	04 c0       	rjmp	.+8      	; 0xfb56 <UserInput+0xc0>
			  else
		      if (IsShifted==True)IsShifted=False;
    fb4e:	81 30       	cpi	r24, 0x01	; 1
    fb50:	11 f4       	brne	.+4      	; 0xfb56 <UserInput+0xc0>
    fb52:	10 92 62 03 	sts	0x0362, r1
			  }
          
		  if (IsSameKey==True){
    fb56:	80 91 61 03 	lds	r24, 0x0361
    fb5a:	81 30       	cpi	r24, 0x01	; 1
    fb5c:	e9 f4       	brne	.+58     	; 0xfb98 <UserInput+0x102>
		      KeyTimeout++;
    fb5e:	80 91 5a 03 	lds	r24, 0x035A
    fb62:	90 91 5b 03 	lds	r25, 0x035B
    fb66:	01 96       	adiw	r24, 0x01	; 1
    fb68:	90 93 5b 03 	sts	0x035B, r25
    fb6c:	80 93 5a 03 	sts	0x035A, r24
              if (KeyTimeout>1000){
    fb70:	89 5e       	subi	r24, 0xE9	; 233
    fb72:	93 40       	sbci	r25, 0x03	; 3
    fb74:	88 f0       	brcs	.+34     	; 0xfb98 <UserInput+0x102>
			      if (TypeUI==UI_ALPHANUM_PASSWORD)lcd_put(xChar,yChar,'*');
    fb76:	f5 e0       	ldi	r31, 0x05	; 5
    fb78:	ff 16       	cp	r15, r31
    fb7a:	39 f4       	brne	.+14     	; 0xfb8a <UserInput+0xf4>
    fb7c:	80 91 6a 03 	lds	r24, 0x036A
    fb80:	60 91 69 03 	lds	r22, 0x0369
    fb84:	4a e2       	ldi	r20, 0x2A	; 42
    fb86:	0e 94 da ae 	call	0x15db4	; 0x15db4 <lcd_put>

		          IsNextKey=True;
    fb8a:	81 e0       	ldi	r24, 0x01	; 1
    fb8c:	80 93 60 03 	sts	0x0360, r24
				  iLoop=0;
    fb90:	10 92 5d 03 	sts	0x035D, r1
    fb94:	10 92 5c 03 	sts	0x035C, r1
			     }
              }
 
 		  //if (((KeyChar>='0')&&(KeyChar<='9')&&(iValuePos<=MaxLength))||(IsNextKey==True)){
		  if (((KeyChar>='0')&&(KeyChar<='9')&&(iValuePos<MaxLength))||(IsNextKey==True)){
    fb98:	8e 2d       	mov	r24, r14
    fb9a:	80 53       	subi	r24, 0x30	; 48
    fb9c:	8a 30       	cpi	r24, 0x0A	; 10
    fb9e:	20 f4       	brcc	.+8      	; 0xfba8 <UserInput+0x112>
    fba0:	80 91 68 03 	lds	r24, 0x0368
    fba4:	88 15       	cp	r24, r8
    fba6:	40 f0       	brcs	.+16     	; 0xfbb8 <UserInput+0x122>
    fba8:	80 91 60 03 	lds	r24, 0x0360
    fbac:	81 30       	cpi	r24, 0x01	; 1
    fbae:	21 f0       	breq	.+8      	; 0xfbb8 <UserInput+0x122>
    fbb0:	ee 24       	eor	r14, r14
    fbb2:	00 e0       	ldi	r16, 0x00	; 0
    fbb4:	10 e0       	ldi	r17, 0x00	; 0
    fbb6:	be c0       	rjmp	.+380    	; 0xfd34 <UserInput+0x29e>
    fbb8:	84 e2       	ldi	r24, 0x24	; 36
    fbba:	94 ef       	ldi	r25, 0xF4	; 244
    fbbc:	01 97       	sbiw	r24, 0x01	; 1
    fbbe:	f1 f7       	brne	.-4      	; 0xfbbc <UserInput+0x126>
		       _delay_ms(250);
		       strResult[iValuePos]=KeyChar;
    fbc0:	80 91 68 03 	lds	r24, 0x0368
    fbc4:	fe 01       	movw	r30, r28
    fbc6:	e8 0f       	add	r30, r24
    fbc8:	f1 1d       	adc	r31, r1
    fbca:	e0 82       	st	Z, r14
		       strResult[iValuePos+1]=0;
    fbcc:	11 82       	std	Z+1, r1	; 0x01

			   if ((TypeUI==UI_NUMBER_R)||(TypeUI==UI_NUMBER_L)||(TypeUI==UI_NUM_PASSWORD)) 
    fbce:	8f 2d       	mov	r24, r15
    fbd0:	81 50       	subi	r24, 0x01	; 1
    fbd2:	82 30       	cpi	r24, 0x02	; 2
    fbd4:	30 f0       	brcs	.+12     	; 0xfbe2 <UserInput+0x14c>
    fbd6:	24 e0       	ldi	r18, 0x04	; 4
    fbd8:	f2 16       	cp	r15, r18
    fbda:	19 f0       	breq	.+6      	; 0xfbe2 <UserInput+0x14c>
    fbdc:	00 e0       	ldi	r16, 0x00	; 0
    fbde:	10 e0       	ldi	r17, 0x00	; 0
    fbe0:	04 c0       	rjmp	.+8      	; 0xfbea <UserInput+0x154>
			        NumbValue=atoi(strResult);
    fbe2:	ce 01       	movw	r24, r28
    fbe4:	0e 94 45 b5 	call	0x16a8a	; 0x16a8a <atoi>
    fbe8:	8c 01       	movw	r16, r24
			   else NumbValue=0;
				
			   if ((TypeUI==UI_ALPHANUM_R)||(TypeUI==UI_ALPHANUM_PASSWORD)){
    fbea:	83 e0       	ldi	r24, 0x03	; 3
    fbec:	f8 16       	cp	r15, r24
    fbee:	21 f0       	breq	.+8      	; 0xfbf8 <UserInput+0x162>
    fbf0:	e5 e0       	ldi	r30, 0x05	; 5
    fbf2:	fe 16       	cp	r15, r30
    fbf4:	09 f0       	breq	.+2      	; 0xfbf8 <UserInput+0x162>
    fbf6:	63 c0       	rjmp	.+198    	; 0xfcbe <UserInput+0x228>
			       if (KeyChar!=zKeyChar){
    fbf8:	80 91 67 03 	lds	r24, 0x0367
    fbfc:	e8 16       	cp	r14, r24
    fbfe:	71 f0       	breq	.+28     	; 0xfc1c <UserInput+0x186>
					   IsSameKey=False;
    fc00:	10 92 61 03 	sts	0x0361, r1
					   IsNewKey=True;
    fc04:	81 e0       	ldi	r24, 0x01	; 1
    fc06:	80 93 5f 03 	sts	0x035F, r24
				       iHit=0;
    fc0a:	10 92 63 03 	sts	0x0363, r1
					   iLoop=1000;
    fc0e:	88 ee       	ldi	r24, 0xE8	; 232
    fc10:	93 e0       	ldi	r25, 0x03	; 3
    fc12:	90 93 5d 03 	sts	0x035D, r25
    fc16:	80 93 5c 03 	sts	0x035C, r24
    fc1a:	51 c0       	rjmp	.+162    	; 0xfcbe <UserInput+0x228>
				   }
                   else{
				   if (IsNewKey==True){
    fc1c:	80 91 5f 03 	lds	r24, 0x035F
    fc20:	81 30       	cpi	r24, 0x01	; 1
    fc22:	71 f4       	brne	.+28     	; 0xfc40 <UserInput+0x1aa>
					   IsNewKey=False;
    fc24:	10 92 5f 03 	sts	0x035F, r1
					   yChar--;
    fc28:	80 91 69 03 	lds	r24, 0x0369
    fc2c:	81 50       	subi	r24, 0x01	; 1
    fc2e:	80 93 69 03 	sts	0x0369, r24
					   if (iValuePos>0) iValuePos--;
    fc32:	80 91 68 03 	lds	r24, 0x0368
    fc36:	88 23       	and	r24, r24
    fc38:	19 f0       	breq	.+6      	; 0xfc40 <UserInput+0x1aa>
    fc3a:	81 50       	subi	r24, 0x01	; 1
    fc3c:	80 93 68 03 	sts	0x0368, r24
					   }
				   KeyTimeout=0;
    fc40:	10 92 5b 03 	sts	0x035B, r1
    fc44:	10 92 5a 03 	sts	0x035A, r1
				   IsSameKey=True;
    fc48:	81 e0       	ldi	r24, 0x01	; 1
    fc4a:	80 93 61 03 	sts	0x0361, r24
				   if (iHit<pgm_read_byte(&MaxKeyHit[(zKeyChar-'0')])) iHit++;
    fc4e:	80 91 63 03 	lds	r24, 0x0363
    fc52:	e0 91 67 03 	lds	r30, 0x0367
    fc56:	f0 e0       	ldi	r31, 0x00	; 0
    fc58:	e2 53       	subi	r30, 0x32	; 50
    fc5a:	fd 4f       	sbci	r31, 0xFD	; 253
    fc5c:	e4 91       	lpm	r30, Z+
    fc5e:	8e 17       	cp	r24, r30
    fc60:	20 f4       	brcc	.+8      	; 0xfc6a <UserInput+0x1d4>
    fc62:	8f 5f       	subi	r24, 0xFF	; 255
    fc64:	80 93 63 03 	sts	0x0363, r24
    fc68:	02 c0       	rjmp	.+4      	; 0xfc6e <UserInput+0x1d8>
                   else iHit=0;
    fc6a:	10 92 63 03 	sts	0x0363, r1
				   iLoop=1000;
    fc6e:	88 ee       	ldi	r24, 0xE8	; 232
    fc70:	93 e0       	ldi	r25, 0x03	; 3
    fc72:	90 93 5d 03 	sts	0x035D, r25
    fc76:	80 93 5c 03 	sts	0x035C, r24

                   zAlphaChar=AlphaChar;
    fc7a:	80 91 65 03 	lds	r24, 0x0365
    fc7e:	80 93 66 03 	sts	0x0366, r24
			       AlphaChar=_table_alphanum(IsShifted,KeyPressed,iHit);			   
    fc82:	80 91 62 03 	lds	r24, 0x0362
    fc86:	6c 2d       	mov	r22, r12
    fc88:	40 91 63 03 	lds	r20, 0x0363
    fc8c:	0e 94 b9 af 	call	0x15f72	; 0x15f72 <_table_alphanum>
    fc90:	80 93 65 03 	sts	0x0365, r24
                   
				   if (IsNextKey==True){
    fc94:	80 91 60 03 	lds	r24, 0x0360
    fc98:	81 30       	cpi	r24, 0x01	; 1
    fc9a:	41 f4       	brne	.+16     	; 0xfcac <UserInput+0x216>
                       AlphaChar=zAlphaChar;       
    fc9c:	80 91 66 03 	lds	r24, 0x0366
    fca0:	80 93 65 03 	sts	0x0365, r24
					   IsNextKey=False;
    fca4:	10 92 60 03 	sts	0x0360, r1
					   IsSameKey=False;
    fca8:	10 92 61 03 	sts	0x0361, r1
				   }   
				   strResult[iValuePos]=AlphaChar;
    fcac:	80 91 68 03 	lds	r24, 0x0368
    fcb0:	fe 01       	movw	r30, r28
    fcb2:	e8 0f       	add	r30, r24
    fcb4:	f1 1d       	adc	r31, r1
    fcb6:	80 91 65 03 	lds	r24, 0x0365
    fcba:	80 83       	st	Z, r24
		           strResult[iValuePos+1]=0;
    fcbc:	11 82       	std	Z+1, r1	; 0x01
				 }//endElse 
				 
			   }//EndAlphaNum

			 if (TypeUI==UI_NUMBER_L){
    fcbe:	f2 e0       	ldi	r31, 0x02	; 2
    fcc0:	ff 16       	cp	r15, r31
    fcc2:	71 f4       	brne	.+28     	; 0xfce0 <UserInput+0x24a>
			    if ((NumbValue<=MaxValue)||(MaxValue==0)){
    fcc4:	a0 16       	cp	r10, r16
    fcc6:	b1 06       	cpc	r11, r17
    fcc8:	18 f4       	brcc	.+6      	; 0xfcd0 <UserInput+0x23a>
    fcca:	a1 14       	cp	r10, r1
    fccc:	b1 04       	cpc	r11, r1
    fcce:	71 f5       	brne	.+92     	; 0xfd2c <UserInput+0x296>
				     iValuePos++;
    fcd0:	80 91 68 03 	lds	r24, 0x0368
    fcd4:	8f 5f       	subi	r24, 0xFF	; 255
    fcd6:	80 93 68 03 	sts	0x0368, r24
					 stUserInput=uiInputDisp;
    fcda:	83 e0       	ldi	r24, 0x03	; 3
    fcdc:	80 93 6b 03 	sts	0x036B, r24
				} 
			 }
  
			   if ((NumbValue<=MaxValue)||(MaxValue==0)){
    fce0:	a0 16       	cp	r10, r16
    fce2:	b1 06       	cpc	r11, r17
    fce4:	18 f4       	brcc	.+6      	; 0xfcec <UserInput+0x256>
    fce6:	a1 14       	cp	r10, r1
    fce8:	b1 04       	cpc	r11, r1
    fcea:	01 f5       	brne	.+64     	; 0xfd2c <UserInput+0x296>
			       if ((TypeUI==UI_NUMBER_R)||(TypeUI==UI_ALPHANUM_R)||
    fcec:	21 e0       	ldi	r18, 0x01	; 1
    fcee:	f2 16       	cp	r15, r18
    fcf0:	49 f0       	breq	.+18     	; 0xfd04 <UserInput+0x26e>
    fcf2:	83 e0       	ldi	r24, 0x03	; 3
    fcf4:	f8 16       	cp	r15, r24
    fcf6:	31 f0       	breq	.+12     	; 0xfd04 <UserInput+0x26e>
    fcf8:	e4 e0       	ldi	r30, 0x04	; 4
    fcfa:	fe 16       	cp	r15, r30
    fcfc:	19 f0       	breq	.+6      	; 0xfd04 <UserInput+0x26e>
    fcfe:	f5 e0       	ldi	r31, 0x05	; 5
    fd00:	ff 16       	cp	r15, r31
    fd02:	a1 f4       	brne	.+40     	; 0xfd2c <UserInput+0x296>
				       (TypeUI==UI_NUM_PASSWORD)||(TypeUI==UI_ALPHANUM_PASSWORD)){
				      if (IsSameKey==False){
    fd04:	80 91 61 03 	lds	r24, 0x0361
    fd08:	88 23       	and	r24, r24
    fd0a:	69 f4       	brne	.+26     	; 0xfd26 <UserInput+0x290>
					      IsFirst=True;
    fd0c:	81 e0       	ldi	r24, 0x01	; 1
    fd0e:	80 93 5e 03 	sts	0x035E, r24
					      iValuePos++;
    fd12:	80 91 68 03 	lds	r24, 0x0368
    fd16:	8f 5f       	subi	r24, 0xFF	; 255
    fd18:	80 93 68 03 	sts	0x0368, r24
						  //FullEntry
						  if (iValuePos==MaxLength)Result=USER_FULL_ENTRY;
					      yChar++;
    fd1c:	80 91 69 03 	lds	r24, 0x0369
    fd20:	8f 5f       	subi	r24, 0xFF	; 255
    fd22:	80 93 69 03 	sts	0x0369, r24
						  //yChar=(yChar+1;//Max Display

						  }
                  stUserInput=uiInputDisp;
    fd26:	83 e0       	ldi	r24, 0x03	; 3
    fd28:	80 93 6b 03 	sts	0x036B, r24
				  }
			   }
              zKeyChar=KeyChar;
    fd2c:	e0 92 67 03 	sts	0x0367, r14
    fd30:	24 e0       	ldi	r18, 0x04	; 4
    fd32:	e2 2e       	mov	r14, r18
             Result=USER_ENTRY;
             }//EndKeyChar
			 
                 
              if ((TypeUI==UI_NUMBER_R)||(TypeUI==UI_NUMBER_L)||(TypeUI==UI_NUM_PASSWORD)){
    fd34:	2f 2d       	mov	r18, r15
    fd36:	21 50       	subi	r18, 0x01	; 1
    fd38:	22 30       	cpi	r18, 0x02	; 2
    fd3a:	18 f0       	brcs	.+6      	; 0xfd42 <UserInput+0x2ac>
    fd3c:	84 e0       	ldi	r24, 0x04	; 4
    fd3e:	f8 16       	cp	r15, r24
    fd40:	89 f4       	brne	.+34     	; 0xfd64 <UserInput+0x2ce>
                   if((NumbValue>MaxValue)||(iValuePos==MaxLength)){
    fd42:	a0 16       	cp	r10, r16
    fd44:	b1 06       	cpc	r11, r17
    fd46:	20 f0       	brcs	.+8      	; 0xfd50 <UserInput+0x2ba>
    fd48:	80 91 68 03 	lds	r24, 0x0368
    fd4c:	88 15       	cp	r24, r8
    fd4e:	51 f4       	brne	.+20     	; 0xfd64 <UserInput+0x2ce>
			           if (MaxValue>0)system_beep(1);
    fd50:	ab 28       	or	r10, r11
    fd52:	41 f0       	breq	.+16     	; 0xfd64 <UserInput+0x2ce>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    fd54:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    fd56:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    fd58:	81 e0       	ldi	r24, 0x01	; 1
    fd5a:	90 e0       	ldi	r25, 0x00	; 0
    fd5c:	90 93 d7 01 	sts	0x01D7, r25
    fd60:	80 93 d6 01 	sts	0x01D6, r24
			           if (MaxValue>0)system_beep(1);
				   }
                 }
		  
		  //CANCEL OK
		  if (KeyPressed==_KEY_CANCEL){
    fd64:	e7 ee       	ldi	r30, 0xE7	; 231
    fd66:	ce 16       	cp	r12, r30
    fd68:	71 f4       	brne	.+28     	; 0xfd86 <UserInput+0x2f0>
		      if (iValuePos>0){
    fd6a:	80 91 68 03 	lds	r24, 0x0368
    fd6e:	88 23       	and	r24, r24
    fd70:	41 f0       	breq	.+16     	; 0xfd82 <UserInput+0x2ec>
			      iLoop=1999;
    fd72:	8f ec       	ldi	r24, 0xCF	; 207
    fd74:	97 e0       	ldi	r25, 0x07	; 7
    fd76:	90 93 5d 03 	sts	0x035D, r25
    fd7a:	80 93 5c 03 	sts	0x035C, r24
				  stUserInput=uiClearDisplay;
    fd7e:	82 e0       	ldi	r24, 0x02	; 2
    fd80:	26 c0       	rjmp	.+76     	; 0xfdce <UserInput+0x338>
				  }
			  else{
			      UserInputResult=USER_CANCEL;
    fd82:	81 e0       	ldi	r24, 0x01	; 1
    fd84:	21 c0       	rjmp	.+66     	; 0xfdc8 <UserInput+0x332>
			      stUserInput=uiFinished;
				  }
		  }
		  else {
		  if (KeyPressed==_KEY_ENTER){
    fd86:	f7 eb       	ldi	r31, 0xB7	; 183
    fd88:	cf 16       	cp	r12, r31
    fd8a:	19 f5       	brne	.+70     	; 0xfdd2 <UserInput+0x33c>
		      strResult[iValuePos]=0;
    fd8c:	80 91 68 03 	lds	r24, 0x0368
    fd90:	fe 01       	movw	r30, r28
    fd92:	e8 0f       	add	r30, r24
    fd94:	f1 1d       	adc	r31, r1
    fd96:	10 82       	st	Z, r1
			  if ((TypeUI==UI_NUMBER_R)||(TypeUI==UI_NUMBER_L)){
    fd98:	22 30       	cpi	r18, 0x02	; 2
    fd9a:	a8 f4       	brcc	.+42     	; 0xfdc6 <UserInput+0x330>
			       if (iValuePos==0)sprintf_P(strResult,PSTR("0"));
    fd9c:	88 23       	and	r24, r24
    fd9e:	81 f4       	brne	.+32     	; 0xfdc0 <UserInput+0x32a>
    fda0:	00 d0       	rcall	.+0      	; 0xfda2 <UserInput+0x30c>
    fda2:	00 d0       	rcall	.+0      	; 0xfda4 <UserInput+0x30e>
    fda4:	ed b7       	in	r30, 0x3d	; 61
    fda6:	fe b7       	in	r31, 0x3e	; 62
    fda8:	d2 83       	std	Z+2, r29	; 0x02
    fdaa:	c1 83       	std	Z+1, r28	; 0x01
    fdac:	80 ec       	ldi	r24, 0xC0	; 192
    fdae:	9b e1       	ldi	r25, 0x1B	; 27
    fdb0:	94 83       	std	Z+4, r25	; 0x04
    fdb2:	83 83       	std	Z+3, r24	; 0x03
    fdb4:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    fdb8:	0f 90       	pop	r0
    fdba:	0f 90       	pop	r0
    fdbc:	0f 90       	pop	r0
    fdbe:	0f 90       	pop	r0
			       RemZeroLead(strResult);
    fdc0:	ce 01       	movw	r24, r28
    fdc2:	0e 94 b9 25 	call	0x4b72	; 0x4b72 <RemZeroLead>
				  }
		      UserInputResult=USER_OK;
    fdc6:	83 e0       	ldi	r24, 0x03	; 3
    fdc8:	80 93 6c 03 	sts	0x036C, r24
		      stUserInput=uiFinished;
    fdcc:	84 e0       	ldi	r24, 0x04	; 4
    fdce:	80 93 6b 03 	sts	0x036B, r24
			  }
		  }//EndElse

		  if ((iLoop%2000)==0){
    fdd2:	80 91 5c 03 	lds	r24, 0x035C
    fdd6:	90 91 5d 03 	lds	r25, 0x035D
    fdda:	60 ed       	ldi	r22, 0xD0	; 208
    fddc:	77 e0       	ldi	r23, 0x07	; 7
    fdde:	0e 94 93 b8 	call	0x17126	; 0x17126 <__udivmodhi4>
    fde2:	89 2b       	or	r24, r25
    fde4:	09 f0       	breq	.+2      	; 0xfde8 <UserInput+0x352>
    fde6:	4b c0       	rjmp	.+150    	; 0xfe7e <UserInput+0x3e8>
		      if (IsSameKey==True)
    fde8:	80 91 61 03 	lds	r24, 0x0361
    fdec:	81 30       	cpi	r24, 0x01	; 1
    fdee:	c9 f4       	brne	.+50     	; 0xfe22 <UserInput+0x38c>
			      //lcd_put(xChar,yChar,AlphaChar); 
				  lcd_put(xPos+((yPos+iValuePos-1)/20),yPos+(iValuePos%20),AlphaChar); 
    fdf0:	20 91 68 03 	lds	r18, 0x0368
    fdf4:	82 2f       	mov	r24, r18
    fdf6:	90 e0       	ldi	r25, 0x00	; 0
    fdf8:	01 97       	sbiw	r24, 0x01	; 1
    fdfa:	8d 0d       	add	r24, r13
    fdfc:	91 1d       	adc	r25, r1
    fdfe:	64 e1       	ldi	r22, 0x14	; 20
    fe00:	70 e0       	ldi	r23, 0x00	; 0
    fe02:	0e 94 a7 b8 	call	0x1714e	; 0x1714e <__divmodhi4>
    fe06:	36 2f       	mov	r19, r22
    fe08:	82 2f       	mov	r24, r18
    fe0a:	64 e1       	ldi	r22, 0x14	; 20
    fe0c:	0e 94 7a b8 	call	0x170f4	; 0x170f4 <__udivmodqi4>
    fe10:	6d 2d       	mov	r22, r13
    fe12:	69 0f       	add	r22, r25
    fe14:	89 2d       	mov	r24, r9
    fe16:	83 0f       	add	r24, r19
    fe18:	40 91 65 03 	lds	r20, 0x0365
    fe1c:	0e 94 da ae 	call	0x15db4	; 0x15db4 <lcd_put>
    fe20:	2e c0       	rjmp	.+92     	; 0xfe7e <UserInput+0x3e8>
			  else {
			      if((TypeUI==UI_ALPHANUM_PASSWORD)&&(iValuePos>0))lcd_put(xChar,yChar-1,'*'); 
    fe22:	f5 e0       	ldi	r31, 0x05	; 5
    fe24:	ff 16       	cp	r15, r31
    fe26:	61 f4       	brne	.+24     	; 0xfe40 <UserInput+0x3aa>
    fe28:	80 91 68 03 	lds	r24, 0x0368
    fe2c:	88 23       	and	r24, r24
    fe2e:	41 f0       	breq	.+16     	; 0xfe40 <UserInput+0x3aa>
    fe30:	60 91 69 03 	lds	r22, 0x0369
    fe34:	61 50       	subi	r22, 0x01	; 1
    fe36:	80 91 6a 03 	lds	r24, 0x036A
    fe3a:	4a e2       	ldi	r20, 0x2A	; 42
    fe3c:	0e 94 da ae 	call	0x15db4	; 0x15db4 <lcd_put>
			      //lcd_put(xChar,yChar,'_'); 
				  lcd_put(xPos+((yPos+iValuePos-1)/20),yPos+(iValuePos%20),'_'); 
    fe40:	20 91 68 03 	lds	r18, 0x0368
    fe44:	82 2f       	mov	r24, r18
    fe46:	90 e0       	ldi	r25, 0x00	; 0
    fe48:	01 97       	sbiw	r24, 0x01	; 1
    fe4a:	8d 0d       	add	r24, r13
    fe4c:	91 1d       	adc	r25, r1
    fe4e:	64 e1       	ldi	r22, 0x14	; 20
    fe50:	70 e0       	ldi	r23, 0x00	; 0
    fe52:	0e 94 a7 b8 	call	0x1714e	; 0x1714e <__divmodhi4>
    fe56:	36 2f       	mov	r19, r22
    fe58:	82 2f       	mov	r24, r18
    fe5a:	64 e1       	ldi	r22, 0x14	; 20
    fe5c:	0e 94 7a b8 	call	0x170f4	; 0x170f4 <__udivmodqi4>
    fe60:	6d 2d       	mov	r22, r13
    fe62:	69 0f       	add	r22, r25
    fe64:	89 2d       	mov	r24, r9
    fe66:	83 0f       	add	r24, r19
    fe68:	4f e5       	ldi	r20, 0x5F	; 95
    fe6a:	0e 94 da ae 	call	0x15db4	; 0x15db4 <lcd_put>

				  if (IsFirst==True){
    fe6e:	80 91 5e 03 	lds	r24, 0x035E
    fe72:	81 30       	cpi	r24, 0x01	; 1
    fe74:	21 f4       	brne	.+8      	; 0xfe7e <UserInput+0x3e8>
				      IsFirst=False;
    fe76:	10 92 5e 03 	sts	0x035E, r1
				      zKeyChar=0;
    fe7a:	10 92 67 03 	sts	0x0367, r1
					  }
				  }
			  }
          if ((iLoop%2000)==1000){
    fe7e:	80 91 5c 03 	lds	r24, 0x035C
    fe82:	90 91 5d 03 	lds	r25, 0x035D
    fe86:	60 ed       	ldi	r22, 0xD0	; 208
    fe88:	77 e0       	ldi	r23, 0x07	; 7
    fe8a:	0e 94 93 b8 	call	0x17126	; 0x17126 <__udivmodhi4>
    fe8e:	88 5e       	subi	r24, 0xE8	; 232
    fe90:	93 40       	sbci	r25, 0x03	; 3
    fe92:	d1 f5       	brne	.+116    	; 0xff08 <UserInput+0x472>
		      if (IsSameKey==True){
    fe94:	80 91 61 03 	lds	r24, 0x0361
    fe98:	81 30       	cpi	r24, 0x01	; 1
    fe9a:	f9 f4       	brne	.+62     	; 0xfeda <UserInput+0x444>
			      if (TypeUI!=UI_NUM_PASSWORD)
    fe9c:	84 e0       	ldi	r24, 0x04	; 4
    fe9e:	f8 16       	cp	r15, r24
    fea0:	b1 f0       	breq	.+44     	; 0xfece <UserInput+0x438>
				       //lcd_put(xChar,yChar,AlphaChar); 
					   lcd_put(xPos+((yPos+iValuePos-1)/20),yChar%21,AlphaChar); 
    fea2:	80 91 68 03 	lds	r24, 0x0368
    fea6:	90 e0       	ldi	r25, 0x00	; 0
    fea8:	01 97       	sbiw	r24, 0x01	; 1
    feaa:	8d 0d       	add	r24, r13
    feac:	91 1d       	adc	r25, r1
    feae:	64 e1       	ldi	r22, 0x14	; 20
    feb0:	70 e0       	ldi	r23, 0x00	; 0
    feb2:	0e 94 a7 b8 	call	0x1714e	; 0x1714e <__divmodhi4>
    feb6:	26 2f       	mov	r18, r22
    feb8:	80 91 69 03 	lds	r24, 0x0369
    febc:	65 e1       	ldi	r22, 0x15	; 21
    febe:	0e 94 7a b8 	call	0x170f4	; 0x170f4 <__udivmodqi4>
    fec2:	89 2d       	mov	r24, r9
    fec4:	82 0f       	add	r24, r18
    fec6:	69 2f       	mov	r22, r25
    fec8:	40 91 65 03 	lds	r20, 0x0365
    fecc:	1b c0       	rjmp	.+54     	; 0xff04 <UserInput+0x46e>
					   
				  else lcd_put(xChar,yChar,'*'); 
    fece:	80 91 6a 03 	lds	r24, 0x036A
    fed2:	60 91 69 03 	lds	r22, 0x0369
    fed6:	4a e2       	ldi	r20, 0x2A	; 42
    fed8:	15 c0       	rjmp	.+42     	; 0xff04 <UserInput+0x46e>
			  }
			  //else lcd_put(xChar,yChar,' '); 
			  else lcd_put(xPos+((yPos+iValuePos-1)/20),yPos+(iValuePos%20),' '); 			  
    feda:	20 91 68 03 	lds	r18, 0x0368
    fede:	82 2f       	mov	r24, r18
    fee0:	90 e0       	ldi	r25, 0x00	; 0
    fee2:	01 97       	sbiw	r24, 0x01	; 1
    fee4:	8d 0d       	add	r24, r13
    fee6:	91 1d       	adc	r25, r1
    fee8:	64 e1       	ldi	r22, 0x14	; 20
    feea:	70 e0       	ldi	r23, 0x00	; 0
    feec:	0e 94 a7 b8 	call	0x1714e	; 0x1714e <__divmodhi4>
    fef0:	36 2f       	mov	r19, r22
    fef2:	82 2f       	mov	r24, r18
    fef4:	64 e1       	ldi	r22, 0x14	; 20
    fef6:	0e 94 7a b8 	call	0x170f4	; 0x170f4 <__udivmodqi4>
    fefa:	d9 0e       	add	r13, r25
    fefc:	89 2d       	mov	r24, r9
    fefe:	83 0f       	add	r24, r19
    ff00:	6d 2d       	mov	r22, r13
    ff02:	40 e2       	ldi	r20, 0x20	; 32
    ff04:	0e 94 da ae 	call	0x15db4	; 0x15db4 <lcd_put>
			  }
          iLoop++;
    ff08:	80 91 5c 03 	lds	r24, 0x035C
    ff0c:	90 91 5d 03 	lds	r25, 0x035D
    ff10:	01 96       	adiw	r24, 0x01	; 1
    ff12:	90 93 5d 03 	sts	0x035D, r25
    ff16:	80 93 5c 03 	sts	0x035C, r24
    ff1a:	d6 c0       	rjmp	.+428    	; 0x100c8 <UserInput+0x632>
          break;
     case uiClearDisplay:
          if (TypeUI==UI_NUMBER_L){
    ff1c:	e2 e0       	ldi	r30, 0x02	; 2
    ff1e:	8e 17       	cp	r24, r30
    ff20:	99 f4       	brne	.+38     	; 0xff48 <UserInput+0x4b2>
		      lcd_put(xChar,(yChar-iValuePos),' '); // 123_ 1_
    ff22:	60 91 69 03 	lds	r22, 0x0369
    ff26:	80 91 68 03 	lds	r24, 0x0368
    ff2a:	68 1b       	sub	r22, r24
    ff2c:	80 91 6a 03 	lds	r24, 0x036A
    ff30:	40 e2       	ldi	r20, 0x20	; 32
    ff32:	0e 94 da ae 	call	0x15db4	; 0x15db4 <lcd_put>
		      strResult[iValuePos]=0;
    ff36:	80 91 68 03 	lds	r24, 0x0368
    ff3a:	c8 0f       	add	r28, r24
    ff3c:	d1 1d       	adc	r29, r1
    ff3e:	18 82       	st	Y, r1
		      iValuePos--;
    ff40:	81 50       	subi	r24, 0x01	; 1
    ff42:	80 93 68 03 	sts	0x0368, r24
    ff46:	33 c0       	rjmp	.+102    	; 0xffae <UserInput+0x518>
			  }
          else
		  if ((TypeUI==UI_NUMBER_R)||(TypeUI==UI_ALPHANUM_R)||
    ff48:	f1 e0       	ldi	r31, 0x01	; 1
    ff4a:	8f 17       	cp	r24, r31
    ff4c:	49 f0       	breq	.+18     	; 0xff60 <UserInput+0x4ca>
    ff4e:	23 e0       	ldi	r18, 0x03	; 3
    ff50:	82 17       	cp	r24, r18
    ff52:	31 f0       	breq	.+12     	; 0xff60 <UserInput+0x4ca>
    ff54:	84 e0       	ldi	r24, 0x04	; 4
    ff56:	f8 16       	cp	r15, r24
    ff58:	19 f0       	breq	.+6      	; 0xff60 <UserInput+0x4ca>
    ff5a:	e5 e0       	ldi	r30, 0x05	; 5
    ff5c:	fe 16       	cp	r15, r30
    ff5e:	39 f5       	brne	.+78     	; 0xffae <UserInput+0x518>
		      (TypeUI==UI_NUM_PASSWORD)||(TypeUI==UI_ALPHANUM_PASSWORD)){
		      //lcd_put(xChar,yChar,' '); // 123_ 1_
			  lcd_put(xPos+((yPos+iValuePos-1)/20),yPos+(iValuePos%20),' '); // 123_ 1_
    ff60:	20 91 68 03 	lds	r18, 0x0368
    ff64:	82 2f       	mov	r24, r18
    ff66:	90 e0       	ldi	r25, 0x00	; 0
    ff68:	01 97       	sbiw	r24, 0x01	; 1
    ff6a:	8d 0d       	add	r24, r13
    ff6c:	91 1d       	adc	r25, r1
    ff6e:	64 e1       	ldi	r22, 0x14	; 20
    ff70:	70 e0       	ldi	r23, 0x00	; 0
    ff72:	0e 94 a7 b8 	call	0x1714e	; 0x1714e <__divmodhi4>
    ff76:	36 2f       	mov	r19, r22
    ff78:	82 2f       	mov	r24, r18
    ff7a:	64 e1       	ldi	r22, 0x14	; 20
    ff7c:	0e 94 7a b8 	call	0x170f4	; 0x170f4 <__udivmodqi4>
    ff80:	d9 0e       	add	r13, r25
    ff82:	89 2d       	mov	r24, r9
    ff84:	83 0f       	add	r24, r19
    ff86:	6d 2d       	mov	r22, r13
    ff88:	40 e2       	ldi	r20, 0x20	; 32
    ff8a:	0e 94 da ae 	call	0x15db4	; 0x15db4 <lcd_put>
			  
		      strResult[iValuePos]=0;
    ff8e:	80 91 68 03 	lds	r24, 0x0368
    ff92:	c8 0f       	add	r28, r24
    ff94:	d1 1d       	adc	r29, r1
    ff96:	18 82       	st	Y, r1
		      iValuePos--;
    ff98:	81 50       	subi	r24, 0x01	; 1
    ff9a:	80 93 68 03 	sts	0x0368, r24
			  yChar--;
    ff9e:	80 91 69 03 	lds	r24, 0x0369
    ffa2:	81 50       	subi	r24, 0x01	; 1
    ffa4:	80 93 69 03 	sts	0x0369, r24
			  IsDelete=True;
    ffa8:	81 e0       	ldi	r24, 0x01	; 1
    ffaa:	80 93 64 03 	sts	0x0364, r24
		  }
		  if (iValuePos==0)Result=USER_NO_DATA;		  
    ffae:	80 91 68 03 	lds	r24, 0x0368
    ffb2:	88 23       	and	r24, r24
    ffb4:	19 f4       	brne	.+6      	; 0xffbc <UserInput+0x526>
    ffb6:	95 e0       	ldi	r25, 0x05	; 5
    ffb8:	e9 2e       	mov	r14, r25
    ffba:	01 c0       	rjmp	.+2      	; 0xffbe <UserInput+0x528>
    ffbc:	ee 24       	eor	r14, r14
		  stUserInput=uiInputDisp;//Redraw
    ffbe:	83 e0       	ldi	r24, 0x03	; 3
    ffc0:	80 93 6b 03 	sts	0x036B, r24
    ffc4:	81 c0       	rjmp	.+258    	; 0x100c8 <UserInput+0x632>
	      break;      
     case uiInputDisp:
	      if(TypeUI==UI_ALPHANUM_PASSWORD){
    ffc6:	f5 e0       	ldi	r31, 0x05	; 5
    ffc8:	8f 17       	cp	r24, r31
    ffca:	19 f5       	brne	.+70     	; 0x10012 <UserInput+0x57c>
			  if (iValuePos>0){
    ffcc:	80 91 68 03 	lds	r24, 0x0368
    ffd0:	88 23       	and	r24, r24
    ffd2:	a9 f0       	breq	.+42     	; 0xfffe <UserInput+0x568>
                  lcd_put(xChar,(yChar-2),'*');
    ffd4:	60 91 69 03 	lds	r22, 0x0369
    ffd8:	62 50       	subi	r22, 0x02	; 2
    ffda:	80 91 6a 03 	lds	r24, 0x036A
    ffde:	4a e2       	ldi	r20, 0x2A	; 42
    ffe0:	0e 94 da ae 	call	0x15db4	; 0x15db4 <lcd_put>
			      if (IsDelete==True){
    ffe4:	80 91 64 03 	lds	r24, 0x0364
    ffe8:	60 91 69 03 	lds	r22, 0x0369
    ffec:	81 30       	cpi	r24, 0x01	; 1
    ffee:	71 f0       	breq	.+28     	; 0x1000c <UserInput+0x576>
				      IsDelete=False;
			          lcd_put(xChar,(yChar-1),'*');
			          }
				  else lcd_put(xChar,(yChar-1),strResult[iValuePos-1]);
    fff0:	61 50       	subi	r22, 0x01	; 1
    fff2:	80 91 68 03 	lds	r24, 0x0368
    fff6:	c8 0f       	add	r28, r24
    fff8:	d1 1d       	adc	r29, r1
    fffa:	21 97       	sbiw	r28, 0x01	; 1
    fffc:	4d c0       	rjmp	.+154    	; 0x10098 <UserInput+0x602>
			      }
			  else{ if(IsDelete==True){
    fffe:	80 91 64 03 	lds	r24, 0x0364
   10002:	60 91 69 03 	lds	r22, 0x0369
   10006:	81 30       	cpi	r24, 0x01	; 1
   10008:	09 f0       	breq	.+2      	; 0x1000c <UserInput+0x576>
   1000a:	45 c0       	rjmp	.+138    	; 0x10096 <UserInput+0x600>
			           IsDelete=False;
   1000c:	10 92 64 03 	sts	0x0364, r1
   10010:	4c c0       	rjmp	.+152    	; 0x100aa <UserInput+0x614>
					   lcd_put(xChar,(yChar-1),'*');
			           }
			        else lcd_put(xChar,(yChar-1),strResult[iValuePos]);
			  }
		  }else
	      if (TypeUI==UI_NUMBER_L){
   10012:	22 e0       	ldi	r18, 0x02	; 2
   10014:	82 17       	cp	r24, r18
   10016:	a1 f4       	brne	.+40     	; 0x10040 <UserInput+0x5aa>
   10018:	10 e0       	ldi	r17, 0x00	; 0
   1001a:	0d c0       	rjmp	.+26     	; 0x10036 <UserInput+0x5a0>
	          for(iDisp=0;iDisp<iValuePos;iDisp++){
				  lcd_put(xChar,(yChar-(iValuePos-iDisp)),strResult[iDisp]);
   1001c:	60 91 69 03 	lds	r22, 0x0369
   10020:	68 1b       	sub	r22, r24
   10022:	61 0f       	add	r22, r17
   10024:	fe 01       	movw	r30, r28
   10026:	e1 0f       	add	r30, r17
   10028:	f1 1d       	adc	r31, r1
   1002a:	80 91 6a 03 	lds	r24, 0x036A
   1002e:	40 81       	ld	r20, Z
   10030:	0e 94 da ae 	call	0x15db4	; 0x15db4 <lcd_put>
			           }
			        else lcd_put(xChar,(yChar-1),strResult[iValuePos]);
			  }
		  }else
	      if (TypeUI==UI_NUMBER_L){
	          for(iDisp=0;iDisp<iValuePos;iDisp++){
   10034:	1f 5f       	subi	r17, 0xFF	; 255
   10036:	80 91 68 03 	lds	r24, 0x0368
   1003a:	18 17       	cp	r17, r24
   1003c:	78 f3       	brcs	.-34     	; 0x1001c <UserInput+0x586>
   1003e:	3b c0       	rjmp	.+118    	; 0x100b6 <UserInput+0x620>
				  lcd_put(xChar,(yChar-(iValuePos-iDisp)),strResult[iDisp]);
		      }
		  }else
	      if ((TypeUI==UI_NUMBER_R)||(TypeUI==UI_ALPHANUM_R)){
   10040:	81 e0       	ldi	r24, 0x01	; 1
   10042:	f8 16       	cp	r15, r24
   10044:	19 f0       	breq	.+6      	; 0x1004c <UserInput+0x5b6>
   10046:	e3 e0       	ldi	r30, 0x03	; 3
   10048:	fe 16       	cp	r15, r30
   1004a:	51 f5       	brne	.+84     	; 0x100a0 <UserInput+0x60a>
		      
			  //if (iValuePos>0) lcd_put(xChar,(yChar-1),strResult[iValuePos-1]);
			  if (iValuePos>0) lcd_put(xPos+((yPos+iValuePos-1)/21),yPos+((iValuePos-1)%20),strResult[iValuePos-1]);			  
   1004c:	20 91 68 03 	lds	r18, 0x0368
   10050:	4d 2d       	mov	r20, r13
   10052:	50 e0       	ldi	r21, 0x00	; 0
   10054:	22 23       	and	r18, r18
   10056:	c1 f0       	breq	.+48     	; 0x10088 <UserInput+0x5f2>
   10058:	30 e0       	ldi	r19, 0x00	; 0
   1005a:	f9 01       	movw	r30, r18
   1005c:	31 97       	sbiw	r30, 0x01	; 1
   1005e:	cf 01       	movw	r24, r30
   10060:	84 0f       	add	r24, r20
   10062:	95 1f       	adc	r25, r21
   10064:	65 e1       	ldi	r22, 0x15	; 21
   10066:	70 e0       	ldi	r23, 0x00	; 0
   10068:	0e 94 a7 b8 	call	0x1714e	; 0x1714e <__divmodhi4>
   1006c:	46 2f       	mov	r20, r22
   1006e:	cf 01       	movw	r24, r30
   10070:	64 e1       	ldi	r22, 0x14	; 20
   10072:	70 e0       	ldi	r23, 0x00	; 0
   10074:	0e 94 a7 b8 	call	0x1714e	; 0x1714e <__divmodhi4>
   10078:	d8 0e       	add	r13, r24
   1007a:	c2 0f       	add	r28, r18
   1007c:	d3 1f       	adc	r29, r19
   1007e:	21 97       	sbiw	r28, 0x01	; 1
   10080:	89 2d       	mov	r24, r9
   10082:	84 0f       	add	r24, r20
   10084:	6d 2d       	mov	r22, r13
   10086:	0a c0       	rjmp	.+20     	; 0x1009c <UserInput+0x606>
			  else{ if ((yChar-1)>=yPos)lcd_put(xChar,(yChar-1),strResult[iValuePos]);
   10088:	60 91 69 03 	lds	r22, 0x0369
   1008c:	86 2f       	mov	r24, r22
   1008e:	90 e0       	ldi	r25, 0x00	; 0
   10090:	48 17       	cp	r20, r24
   10092:	59 07       	cpc	r21, r25
   10094:	84 f4       	brge	.+32     	; 0x100b6 <UserInput+0x620>
   10096:	61 50       	subi	r22, 0x01	; 1
   10098:	80 91 6a 03 	lds	r24, 0x036A
   1009c:	48 81       	ld	r20, Y
   1009e:	09 c0       	rjmp	.+18     	; 0x100b2 <UserInput+0x61c>
			  }
		  }else
		  //DisplayAsterik *
		  if (TypeUI==UI_NUM_PASSWORD){
   100a0:	f4 e0       	ldi	r31, 0x04	; 4
   100a2:	ff 16       	cp	r15, r31
   100a4:	41 f4       	brne	.+16     	; 0x100b6 <UserInput+0x620>
		      lcd_put(xChar,(yChar-1),'*');
   100a6:	60 91 69 03 	lds	r22, 0x0369
   100aa:	61 50       	subi	r22, 0x01	; 1
   100ac:	80 91 6a 03 	lds	r24, 0x036A
   100b0:	4a e2       	ldi	r20, 0x2A	; 42
   100b2:	0e 94 da ae 	call	0x15db4	; 0x15db4 <lcd_put>
		  }

          stUserInput=uiInput;
   100b6:	81 e0       	ldi	r24, 0x01	; 1
   100b8:	80 93 6b 03 	sts	0x036B, r24
   100bc:	ee 24       	eor	r14, r14
   100be:	04 c0       	rjmp	.+8      	; 0x100c8 <UserInput+0x632>
	      break;	 
     case uiFinished:
	      Result=UserInputResult;
   100c0:	e0 90 6c 03 	lds	r14, 0x036C
	      stUserInput=uiInit;
   100c4:	10 92 6b 03 	sts	0x036B, r1
	      break;
	 }
	 return Result;
}
   100c8:	8e 2d       	mov	r24, r14
   100ca:	df 91       	pop	r29
   100cc:	cf 91       	pop	r28
   100ce:	1f 91       	pop	r17
   100d0:	0f 91       	pop	r16
   100d2:	ff 90       	pop	r15
   100d4:	ef 90       	pop	r14
   100d6:	df 90       	pop	r13
   100d8:	cf 90       	pop	r12
   100da:	bf 90       	pop	r11
   100dc:	af 90       	pop	r10
   100de:	9f 90       	pop	r9
   100e0:	8f 90       	pop	r8
   100e2:	08 95       	ret

000100e4 <TestUserInput>:
    //sprintf_P(strSend,PSTR("Pos:%d"),*Pos);
	//_uart_print(0,1,strSend);
}


char TestUserInput(){
   100e4:	6f 92       	push	r6
   100e6:	7f 92       	push	r7
   100e8:	8f 92       	push	r8
   100ea:	9f 92       	push	r9
   100ec:	af 92       	push	r10
   100ee:	bf 92       	push	r11
   100f0:	cf 92       	push	r12
   100f2:	df 92       	push	r13
   100f4:	ef 92       	push	r14
   100f6:	ff 92       	push	r15
   100f8:	0f 93       	push	r16
   100fa:	1f 93       	push	r17
   100fc:	df 93       	push	r29
   100fe:	cf 93       	push	r28
   10100:	cd b7       	in	r28, 0x3d	; 61
   10102:	de b7       	in	r29, 0x3e	; 62
   10104:	ce 56       	subi	r28, 0x6E	; 110
   10106:	d0 40       	sbci	r29, 0x00	; 0
   10108:	0f b6       	in	r0, 0x3f	; 63
   1010a:	f8 94       	cli
   1010c:	de bf       	out	0x3e, r29	; 62
   1010e:	0f be       	out	0x3f, r0	; 63
   10110:	cd bf       	out	0x3d, r28	; 61
char lcdteks[20],strSend[30];
char SVolume[15],SMoney[15],STotalVolume[15],STotalMoney[15];
char Result;

char uiResult;
	uiResult=UserInput(UI_ALPHANUM_R,2,1,strNumber,0,10);
   10112:	e3 ef       	ldi	r30, 0xF3	; 243
   10114:	6e 2e       	mov	r6, r30
   10116:	e1 e0       	ldi	r30, 0x01	; 1
   10118:	7e 2e       	mov	r7, r30
   1011a:	83 e0       	ldi	r24, 0x03	; 3
   1011c:	62 e0       	ldi	r22, 0x02	; 2
   1011e:	41 e0       	ldi	r20, 0x01	; 1
   10120:	93 01       	movw	r18, r6
   10122:	00 e0       	ldi	r16, 0x00	; 0
   10124:	10 e0       	ldi	r17, 0x00	; 0
   10126:	7a e0       	ldi	r23, 0x0A	; 10
   10128:	e7 2e       	mov	r14, r23
   1012a:	0e 94 4b 7d 	call	0xfa96	; 0xfa96 <UserInput>
	Result=MENU_NONE;
    if (uiResult==USER_OK){
   1012e:	83 30       	cpi	r24, 0x03	; 3
   10130:	09 f0       	breq	.+2      	; 0x10134 <TestUserInput+0x50>
   10132:	ed c1       	rjmp	.+986    	; 0x1050e <TestUserInput+0x42a>
	    sprintf_P(lcdteks,PSTR("Data:%s"),strNumber);
   10134:	00 d0       	rcall	.+0      	; 0x10136 <TestUserInput+0x52>
   10136:	00 d0       	rcall	.+0      	; 0x10138 <TestUserInput+0x54>
   10138:	00 d0       	rcall	.+0      	; 0x1013a <TestUserInput+0x56>
   1013a:	ed b7       	in	r30, 0x3d	; 61
   1013c:	fe b7       	in	r31, 0x3e	; 62
   1013e:	31 96       	adiw	r30, 0x01	; 1
   10140:	8e 01       	movw	r16, r28
   10142:	03 5c       	subi	r16, 0xC3	; 195
   10144:	1f 4f       	sbci	r17, 0xFF	; 255
   10146:	ad b7       	in	r26, 0x3d	; 61
   10148:	be b7       	in	r27, 0x3e	; 62
   1014a:	12 96       	adiw	r26, 0x02	; 2
   1014c:	1c 93       	st	X, r17
   1014e:	0e 93       	st	-X, r16
   10150:	11 97       	sbiw	r26, 0x01	; 1
   10152:	84 ef       	ldi	r24, 0xF4	; 244
   10154:	93 e0       	ldi	r25, 0x03	; 3
   10156:	93 83       	std	Z+3, r25	; 0x03
   10158:	82 83       	std	Z+2, r24	; 0x02
   1015a:	75 82       	std	Z+5, r7	; 0x05
   1015c:	64 82       	std	Z+4, r6	; 0x04
   1015e:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
	   lcd_print(3,1,lcdteks);
   10162:	8d b7       	in	r24, 0x3d	; 61
   10164:	9e b7       	in	r25, 0x3e	; 62
   10166:	06 96       	adiw	r24, 0x06	; 6
   10168:	0f b6       	in	r0, 0x3f	; 63
   1016a:	f8 94       	cli
   1016c:	9e bf       	out	0x3e, r25	; 62
   1016e:	0f be       	out	0x3f, r0	; 63
   10170:	8d bf       	out	0x3d, r24	; 61
   10172:	83 e0       	ldi	r24, 0x03	; 3
   10174:	61 e0       	ldi	r22, 0x01	; 1
   10176:	a8 01       	movw	r20, r16
   10178:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
	   //FormatCurrency(strNumber);
	   //FormatMoney(strNumber);
	   //RemZeroLead(strNumber);
	   sprintf_P(SVolume,PSTR("%s"),strNumber);
   1017c:	00 d0       	rcall	.+0      	; 0x1017e <TestUserInput+0x9a>
   1017e:	00 d0       	rcall	.+0      	; 0x10180 <TestUserInput+0x9c>
   10180:	00 d0       	rcall	.+0      	; 0x10182 <TestUserInput+0x9e>
   10182:	ed b7       	in	r30, 0x3d	; 61
   10184:	fe b7       	in	r31, 0x3e	; 62
   10186:	31 96       	adiw	r30, 0x01	; 1
   10188:	7e 01       	movw	r14, r28
   1018a:	08 94       	sec
   1018c:	e1 1c       	adc	r14, r1
   1018e:	f1 1c       	adc	r15, r1
   10190:	ad b7       	in	r26, 0x3d	; 61
   10192:	be b7       	in	r27, 0x3e	; 62
   10194:	12 96       	adiw	r26, 0x02	; 2
   10196:	fc 92       	st	X, r15
   10198:	ee 92       	st	-X, r14
   1019a:	11 97       	sbiw	r26, 0x01	; 1
   1019c:	81 ef       	ldi	r24, 0xF1	; 241
   1019e:	93 e0       	ldi	r25, 0x03	; 3
   101a0:	93 83       	std	Z+3, r25	; 0x03
   101a2:	82 83       	std	Z+2, r24	; 0x02
   101a4:	75 82       	std	Z+5, r7	; 0x05
   101a6:	64 82       	std	Z+4, r6	; 0x04
   101a8:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
	   sprintf_P(SMoney,PSTR("%s"),strNumber);
   101ac:	ed b7       	in	r30, 0x3d	; 61
   101ae:	fe b7       	in	r31, 0x3e	; 62
   101b0:	31 96       	adiw	r30, 0x01	; 1
   101b2:	60 e1       	ldi	r22, 0x10	; 16
   101b4:	a6 2e       	mov	r10, r22
   101b6:	b1 2c       	mov	r11, r1
   101b8:	ac 0e       	add	r10, r28
   101ba:	bd 1e       	adc	r11, r29
   101bc:	ad b7       	in	r26, 0x3d	; 61
   101be:	be b7       	in	r27, 0x3e	; 62
   101c0:	12 96       	adiw	r26, 0x02	; 2
   101c2:	bc 92       	st	X, r11
   101c4:	ae 92       	st	-X, r10
   101c6:	11 97       	sbiw	r26, 0x01	; 1
   101c8:	8e ee       	ldi	r24, 0xEE	; 238
   101ca:	93 e0       	ldi	r25, 0x03	; 3
   101cc:	93 83       	std	Z+3, r25	; 0x03
   101ce:	82 83       	std	Z+2, r24	; 0x02
   101d0:	75 82       	std	Z+5, r7	; 0x05
   101d2:	64 82       	std	Z+4, r6	; 0x04
   101d4:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
	   sprintf_P(STotalVolume,PSTR("%s"),strNumber);
   101d8:	ed b7       	in	r30, 0x3d	; 61
   101da:	fe b7       	in	r31, 0x3e	; 62
   101dc:	31 96       	adiw	r30, 0x01	; 1
   101de:	5f e1       	ldi	r21, 0x1F	; 31
   101e0:	85 2e       	mov	r8, r21
   101e2:	91 2c       	mov	r9, r1
   101e4:	8c 0e       	add	r8, r28
   101e6:	9d 1e       	adc	r9, r29
   101e8:	ad b7       	in	r26, 0x3d	; 61
   101ea:	be b7       	in	r27, 0x3e	; 62
   101ec:	12 96       	adiw	r26, 0x02	; 2
   101ee:	9c 92       	st	X, r9
   101f0:	8e 92       	st	-X, r8
   101f2:	11 97       	sbiw	r26, 0x01	; 1
   101f4:	8b ee       	ldi	r24, 0xEB	; 235
   101f6:	93 e0       	ldi	r25, 0x03	; 3
   101f8:	93 83       	std	Z+3, r25	; 0x03
   101fa:	82 83       	std	Z+2, r24	; 0x02
   101fc:	75 82       	std	Z+5, r7	; 0x05
   101fe:	64 82       	std	Z+4, r6	; 0x04
   10200:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
	   sprintf_P(STotalMoney,PSTR("%s"),strNumber);
   10204:	ed b7       	in	r30, 0x3d	; 61
   10206:	fe b7       	in	r31, 0x3e	; 62
   10208:	31 96       	adiw	r30, 0x01	; 1
   1020a:	4e e2       	ldi	r20, 0x2E	; 46
   1020c:	c4 2e       	mov	r12, r20
   1020e:	d1 2c       	mov	r13, r1
   10210:	cc 0e       	add	r12, r28
   10212:	dd 1e       	adc	r13, r29
   10214:	ad b7       	in	r26, 0x3d	; 61
   10216:	be b7       	in	r27, 0x3e	; 62
   10218:	12 96       	adiw	r26, 0x02	; 2
   1021a:	dc 92       	st	X, r13
   1021c:	ce 92       	st	-X, r12
   1021e:	11 97       	sbiw	r26, 0x01	; 1
   10220:	88 ee       	ldi	r24, 0xE8	; 232
   10222:	93 e0       	ldi	r25, 0x03	; 3
   10224:	93 83       	std	Z+3, r25	; 0x03
   10226:	82 83       	std	Z+2, r24	; 0x02
   10228:	75 82       	std	Z+5, r7	; 0x05
   1022a:	64 82       	std	Z+4, r6	; 0x04
   1022c:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>

	   sprintf_P(lcdteks,PSTR("Formated:%s"),strNumber);
   10230:	ed b7       	in	r30, 0x3d	; 61
   10232:	fe b7       	in	r31, 0x3e	; 62
   10234:	31 96       	adiw	r30, 0x01	; 1
   10236:	ad b7       	in	r26, 0x3d	; 61
   10238:	be b7       	in	r27, 0x3e	; 62
   1023a:	12 96       	adiw	r26, 0x02	; 2
   1023c:	1c 93       	st	X, r17
   1023e:	0e 93       	st	-X, r16
   10240:	11 97       	sbiw	r26, 0x01	; 1
   10242:	8c ed       	ldi	r24, 0xDC	; 220
   10244:	93 e0       	ldi	r25, 0x03	; 3
   10246:	93 83       	std	Z+3, r25	; 0x03
   10248:	82 83       	std	Z+2, r24	; 0x02
   1024a:	75 82       	std	Z+5, r7	; 0x05
   1024c:	64 82       	std	Z+4, r6	; 0x04
   1024e:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
       lcd_print(4,1,lcdteks);
   10252:	8d b7       	in	r24, 0x3d	; 61
   10254:	9e b7       	in	r25, 0x3e	; 62
   10256:	06 96       	adiw	r24, 0x06	; 6
   10258:	0f b6       	in	r0, 0x3f	; 63
   1025a:	f8 94       	cli
   1025c:	9e bf       	out	0x3e, r25	; 62
   1025e:	0f be       	out	0x3f, r0	; 63
   10260:	8d bf       	out	0x3d, r24	; 61
   10262:	84 e0       	ldi	r24, 0x04	; 4
   10264:	61 e0       	ldi	r22, 0x01	; 1
   10266:	a8 01       	movw	r20, r16
   10268:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
	   sprintf_P(strSend,PSTR("Raw:%s"),strNumber);
   1026c:	00 d0       	rcall	.+0      	; 0x1026e <TestUserInput+0x18a>
   1026e:	00 d0       	rcall	.+0      	; 0x10270 <TestUserInput+0x18c>
   10270:	00 d0       	rcall	.+0      	; 0x10272 <TestUserInput+0x18e>
   10272:	ed b7       	in	r30, 0x3d	; 61
   10274:	fe b7       	in	r31, 0x3e	; 62
   10276:	31 96       	adiw	r30, 0x01	; 1
   10278:	8e 01       	movw	r16, r28
   1027a:	0f 5a       	subi	r16, 0xAF	; 175
   1027c:	1f 4f       	sbci	r17, 0xFF	; 255
   1027e:	ad b7       	in	r26, 0x3d	; 61
   10280:	be b7       	in	r27, 0x3e	; 62
   10282:	12 96       	adiw	r26, 0x02	; 2
   10284:	1c 93       	st	X, r17
   10286:	0e 93       	st	-X, r16
   10288:	11 97       	sbiw	r26, 0x01	; 1
   1028a:	85 ed       	ldi	r24, 0xD5	; 213
   1028c:	93 e0       	ldi	r25, 0x03	; 3
   1028e:	93 83       	std	Z+3, r25	; 0x03
   10290:	82 83       	std	Z+2, r24	; 0x02
   10292:	75 82       	std	Z+5, r7	; 0x05
   10294:	64 82       	std	Z+4, r6	; 0x04
   10296:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
	   _uart_print(0,1,strSend);
   1029a:	8d b7       	in	r24, 0x3d	; 61
   1029c:	9e b7       	in	r25, 0x3e	; 62
   1029e:	06 96       	adiw	r24, 0x06	; 6
   102a0:	0f b6       	in	r0, 0x3f	; 63
   102a2:	f8 94       	cli
   102a4:	9e bf       	out	0x3e, r25	; 62
   102a6:	0f be       	out	0x3f, r0	; 63
   102a8:	8d bf       	out	0x3d, r24	; 61
   102aa:	80 e0       	ldi	r24, 0x00	; 0
   102ac:	61 e0       	ldi	r22, 0x01	; 1
   102ae:	a8 01       	movw	r20, r16
   102b0:	0e 94 f2 b3 	call	0x167e4	; 0x167e4 <_uart_print>

	   RemoveMinus(strNumber);
   102b4:	c3 01       	movw	r24, r6
   102b6:	0e 94 f3 23 	call	0x47e6	; 0x47e6 <RemoveMinus>

	   sprintf_P(strSend,PSTR("Minus:%s"),strNumber);
   102ba:	00 d0       	rcall	.+0      	; 0x102bc <TestUserInput+0x1d8>
   102bc:	00 d0       	rcall	.+0      	; 0x102be <TestUserInput+0x1da>
   102be:	00 d0       	rcall	.+0      	; 0x102c0 <TestUserInput+0x1dc>
   102c0:	ed b7       	in	r30, 0x3d	; 61
   102c2:	fe b7       	in	r31, 0x3e	; 62
   102c4:	31 96       	adiw	r30, 0x01	; 1
   102c6:	ad b7       	in	r26, 0x3d	; 61
   102c8:	be b7       	in	r27, 0x3e	; 62
   102ca:	12 96       	adiw	r26, 0x02	; 2
   102cc:	1c 93       	st	X, r17
   102ce:	0e 93       	st	-X, r16
   102d0:	11 97       	sbiw	r26, 0x01	; 1
   102d2:	8c ec       	ldi	r24, 0xCC	; 204
   102d4:	93 e0       	ldi	r25, 0x03	; 3
   102d6:	93 83       	std	Z+3, r25	; 0x03
   102d8:	82 83       	std	Z+2, r24	; 0x02
   102da:	75 82       	std	Z+5, r7	; 0x05
   102dc:	64 82       	std	Z+4, r6	; 0x04
   102de:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
	   _uart_print(0,1,strSend);
   102e2:	8d b7       	in	r24, 0x3d	; 61
   102e4:	9e b7       	in	r25, 0x3e	; 62
   102e6:	06 96       	adiw	r24, 0x06	; 6
   102e8:	0f b6       	in	r0, 0x3f	; 63
   102ea:	f8 94       	cli
   102ec:	9e bf       	out	0x3e, r25	; 62
   102ee:	0f be       	out	0x3f, r0	; 63
   102f0:	8d bf       	out	0x3d, r24	; 61
   102f2:	80 e0       	ldi	r24, 0x00	; 0
   102f4:	61 e0       	ldi	r22, 0x01	; 1
   102f6:	a8 01       	movw	r20, r16
   102f8:	0e 94 f2 b3 	call	0x167e4	; 0x167e4 <_uart_print>

       
	   RemZeroLead(strNumber);
   102fc:	c3 01       	movw	r24, r6
   102fe:	0e 94 b9 25 	call	0x4b72	; 0x4b72 <RemZeroLead>
	   sprintf_P(strSend,PSTR("Removed:%s"),strNumber);
   10302:	00 d0       	rcall	.+0      	; 0x10304 <TestUserInput+0x220>
   10304:	00 d0       	rcall	.+0      	; 0x10306 <TestUserInput+0x222>
   10306:	00 d0       	rcall	.+0      	; 0x10308 <TestUserInput+0x224>
   10308:	ed b7       	in	r30, 0x3d	; 61
   1030a:	fe b7       	in	r31, 0x3e	; 62
   1030c:	31 96       	adiw	r30, 0x01	; 1
   1030e:	ad b7       	in	r26, 0x3d	; 61
   10310:	be b7       	in	r27, 0x3e	; 62
   10312:	12 96       	adiw	r26, 0x02	; 2
   10314:	1c 93       	st	X, r17
   10316:	0e 93       	st	-X, r16
   10318:	11 97       	sbiw	r26, 0x01	; 1
   1031a:	81 ec       	ldi	r24, 0xC1	; 193
   1031c:	93 e0       	ldi	r25, 0x03	; 3
   1031e:	93 83       	std	Z+3, r25	; 0x03
   10320:	82 83       	std	Z+2, r24	; 0x02
   10322:	75 82       	std	Z+5, r7	; 0x05
   10324:	64 82       	std	Z+4, r6	; 0x04
   10326:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
	   _uart_print(0,1,strSend);
   1032a:	8d b7       	in	r24, 0x3d	; 61
   1032c:	9e b7       	in	r25, 0x3e	; 62
   1032e:	06 96       	adiw	r24, 0x06	; 6
   10330:	0f b6       	in	r0, 0x3f	; 63
   10332:	f8 94       	cli
   10334:	9e bf       	out	0x3e, r25	; 62
   10336:	0f be       	out	0x3f, r0	; 63
   10338:	8d bf       	out	0x3d, r24	; 61
   1033a:	80 e0       	ldi	r24, 0x00	; 0
   1033c:	61 e0       	ldi	r22, 0x01	; 1
   1033e:	a8 01       	movw	r20, r16
   10340:	0e 94 f2 b3 	call	0x167e4	; 0x167e4 <_uart_print>

RemZeroLead(SVolume);
   10344:	c7 01       	movw	r24, r14
   10346:	0e 94 b9 25 	call	0x4b72	; 0x4b72 <RemZeroLead>
RemZeroLead(SMoney);
   1034a:	c5 01       	movw	r24, r10
   1034c:	0e 94 b9 25 	call	0x4b72	; 0x4b72 <RemZeroLead>
RemZeroLead(STotalVolume);
   10350:	c4 01       	movw	r24, r8
   10352:	0e 94 b9 25 	call	0x4b72	; 0x4b72 <RemZeroLead>
RemZeroLead(STotalMoney);
   10356:	c6 01       	movw	r24, r12
   10358:	0e 94 b9 25 	call	0x4b72	; 0x4b72 <RemZeroLead>
       
	   
	   FormatVolume(SVolume); 
   1035c:	c7 01       	movw	r24, r14
   1035e:	0e 94 fb 34 	call	0x69f6	; 0x69f6 <FormatVolume>
	   FormatMoney(SMoney);
   10362:	c5 01       	movw	r24, r10
   10364:	0e 94 08 35 	call	0x6a10	; 0x6a10 <FormatMoney>
	   FormatTotalizerMoney(STotalVolume);
   10368:	c4 01       	movw	r24, r8
   1036a:	0e 94 ee 34 	call	0x69dc	; 0x69dc <FormatTotalizerMoney>
	   FormatTotalizerVolume(STotalMoney);
   1036e:	c6 01       	movw	r24, r12
   10370:	0e 94 e1 34 	call	0x69c2	; 0x69c2 <FormatTotalizerVolume>

	   sprintf_P(strSend,PSTR("Volume:%s"),SVolume);
   10374:	00 d0       	rcall	.+0      	; 0x10376 <TestUserInput+0x292>
   10376:	00 d0       	rcall	.+0      	; 0x10378 <TestUserInput+0x294>
   10378:	00 d0       	rcall	.+0      	; 0x1037a <TestUserInput+0x296>
   1037a:	ed b7       	in	r30, 0x3d	; 61
   1037c:	fe b7       	in	r31, 0x3e	; 62
   1037e:	31 96       	adiw	r30, 0x01	; 1
   10380:	ad b7       	in	r26, 0x3d	; 61
   10382:	be b7       	in	r27, 0x3e	; 62
   10384:	12 96       	adiw	r26, 0x02	; 2
   10386:	1c 93       	st	X, r17
   10388:	0e 93       	st	-X, r16
   1038a:	11 97       	sbiw	r26, 0x01	; 1
   1038c:	87 eb       	ldi	r24, 0xB7	; 183
   1038e:	93 e0       	ldi	r25, 0x03	; 3
   10390:	93 83       	std	Z+3, r25	; 0x03
   10392:	82 83       	std	Z+2, r24	; 0x02
   10394:	f5 82       	std	Z+5, r15	; 0x05
   10396:	e4 82       	std	Z+4, r14	; 0x04
   10398:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
	   _uart_print(0,1,strSend);
   1039c:	8d b7       	in	r24, 0x3d	; 61
   1039e:	9e b7       	in	r25, 0x3e	; 62
   103a0:	06 96       	adiw	r24, 0x06	; 6
   103a2:	0f b6       	in	r0, 0x3f	; 63
   103a4:	f8 94       	cli
   103a6:	9e bf       	out	0x3e, r25	; 62
   103a8:	0f be       	out	0x3f, r0	; 63
   103aa:	8d bf       	out	0x3d, r24	; 61
   103ac:	80 e0       	ldi	r24, 0x00	; 0
   103ae:	61 e0       	ldi	r22, 0x01	; 1
   103b0:	a8 01       	movw	r20, r16
   103b2:	0e 94 f2 b3 	call	0x167e4	; 0x167e4 <_uart_print>
	   sprintf_P(strSend,PSTR("Money:%s"),SMoney);
   103b6:	00 d0       	rcall	.+0      	; 0x103b8 <TestUserInput+0x2d4>
   103b8:	00 d0       	rcall	.+0      	; 0x103ba <TestUserInput+0x2d6>
   103ba:	00 d0       	rcall	.+0      	; 0x103bc <TestUserInput+0x2d8>
   103bc:	ed b7       	in	r30, 0x3d	; 61
   103be:	fe b7       	in	r31, 0x3e	; 62
   103c0:	31 96       	adiw	r30, 0x01	; 1
   103c2:	ad b7       	in	r26, 0x3d	; 61
   103c4:	be b7       	in	r27, 0x3e	; 62
   103c6:	12 96       	adiw	r26, 0x02	; 2
   103c8:	1c 93       	st	X, r17
   103ca:	0e 93       	st	-X, r16
   103cc:	11 97       	sbiw	r26, 0x01	; 1
   103ce:	8e ea       	ldi	r24, 0xAE	; 174
   103d0:	93 e0       	ldi	r25, 0x03	; 3
   103d2:	93 83       	std	Z+3, r25	; 0x03
   103d4:	82 83       	std	Z+2, r24	; 0x02
   103d6:	b5 82       	std	Z+5, r11	; 0x05
   103d8:	a4 82       	std	Z+4, r10	; 0x04
   103da:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
	   _uart_print(0,1,strSend);
   103de:	8d b7       	in	r24, 0x3d	; 61
   103e0:	9e b7       	in	r25, 0x3e	; 62
   103e2:	06 96       	adiw	r24, 0x06	; 6
   103e4:	0f b6       	in	r0, 0x3f	; 63
   103e6:	f8 94       	cli
   103e8:	9e bf       	out	0x3e, r25	; 62
   103ea:	0f be       	out	0x3f, r0	; 63
   103ec:	8d bf       	out	0x3d, r24	; 61
   103ee:	80 e0       	ldi	r24, 0x00	; 0
   103f0:	61 e0       	ldi	r22, 0x01	; 1
   103f2:	a8 01       	movw	r20, r16
   103f4:	0e 94 f2 b3 	call	0x167e4	; 0x167e4 <_uart_print>
	   sprintf_P(strSend,PSTR("TVolume:%s"),STotalVolume);
   103f8:	00 d0       	rcall	.+0      	; 0x103fa <TestUserInput+0x316>
   103fa:	00 d0       	rcall	.+0      	; 0x103fc <TestUserInput+0x318>
   103fc:	00 d0       	rcall	.+0      	; 0x103fe <TestUserInput+0x31a>
   103fe:	ed b7       	in	r30, 0x3d	; 61
   10400:	fe b7       	in	r31, 0x3e	; 62
   10402:	31 96       	adiw	r30, 0x01	; 1
   10404:	ad b7       	in	r26, 0x3d	; 61
   10406:	be b7       	in	r27, 0x3e	; 62
   10408:	12 96       	adiw	r26, 0x02	; 2
   1040a:	1c 93       	st	X, r17
   1040c:	0e 93       	st	-X, r16
   1040e:	11 97       	sbiw	r26, 0x01	; 1
   10410:	83 ea       	ldi	r24, 0xA3	; 163
   10412:	93 e0       	ldi	r25, 0x03	; 3
   10414:	93 83       	std	Z+3, r25	; 0x03
   10416:	82 83       	std	Z+2, r24	; 0x02
   10418:	95 82       	std	Z+5, r9	; 0x05
   1041a:	84 82       	std	Z+4, r8	; 0x04
   1041c:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
	   _uart_print(0,1,strSend);
   10420:	8d b7       	in	r24, 0x3d	; 61
   10422:	9e b7       	in	r25, 0x3e	; 62
   10424:	06 96       	adiw	r24, 0x06	; 6
   10426:	0f b6       	in	r0, 0x3f	; 63
   10428:	f8 94       	cli
   1042a:	9e bf       	out	0x3e, r25	; 62
   1042c:	0f be       	out	0x3f, r0	; 63
   1042e:	8d bf       	out	0x3d, r24	; 61
   10430:	80 e0       	ldi	r24, 0x00	; 0
   10432:	61 e0       	ldi	r22, 0x01	; 1
   10434:	a8 01       	movw	r20, r16
   10436:	0e 94 f2 b3 	call	0x167e4	; 0x167e4 <_uart_print>
	   sprintf_P(strSend,PSTR("TMoney:%s"),STotalMoney);
   1043a:	00 d0       	rcall	.+0      	; 0x1043c <TestUserInput+0x358>
   1043c:	00 d0       	rcall	.+0      	; 0x1043e <TestUserInput+0x35a>
   1043e:	00 d0       	rcall	.+0      	; 0x10440 <TestUserInput+0x35c>
   10440:	ed b7       	in	r30, 0x3d	; 61
   10442:	fe b7       	in	r31, 0x3e	; 62
   10444:	31 96       	adiw	r30, 0x01	; 1
   10446:	ad b7       	in	r26, 0x3d	; 61
   10448:	be b7       	in	r27, 0x3e	; 62
   1044a:	12 96       	adiw	r26, 0x02	; 2
   1044c:	1c 93       	st	X, r17
   1044e:	0e 93       	st	-X, r16
   10450:	11 97       	sbiw	r26, 0x01	; 1
   10452:	89 e9       	ldi	r24, 0x99	; 153
   10454:	93 e0       	ldi	r25, 0x03	; 3
   10456:	93 83       	std	Z+3, r25	; 0x03
   10458:	82 83       	std	Z+2, r24	; 0x02
   1045a:	d5 82       	std	Z+5, r13	; 0x05
   1045c:	c4 82       	std	Z+4, r12	; 0x04
   1045e:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
	   _uart_print(0,1,strSend);
   10462:	8d b7       	in	r24, 0x3d	; 61
   10464:	9e b7       	in	r25, 0x3e	; 62
   10466:	06 96       	adiw	r24, 0x06	; 6
   10468:	0f b6       	in	r0, 0x3f	; 63
   1046a:	f8 94       	cli
   1046c:	9e bf       	out	0x3e, r25	; 62
   1046e:	0f be       	out	0x3f, r0	; 63
   10470:	8d bf       	out	0x3d, r24	; 61
   10472:	80 e0       	ldi	r24, 0x00	; 0
   10474:	61 e0       	ldi	r22, 0x01	; 1
   10476:	a8 01       	movw	r20, r16
   10478:	0e 94 f2 b3 	call	0x167e4	; 0x167e4 <_uart_print>

	   FormatCurrency(SMoney);
   1047c:	c5 01       	movw	r24, r10
   1047e:	0e 94 b1 33 	call	0x6762	; 0x6762 <FormatCurrency>
	   FormatCurrency(STotalMoney);
   10482:	c6 01       	movw	r24, r12
   10484:	0e 94 b1 33 	call	0x6762	; 0x6762 <FormatCurrency>
    
	   sprintf_P(strSend,PSTR("FmtMoney:%s"),SMoney);
   10488:	00 d0       	rcall	.+0      	; 0x1048a <TestUserInput+0x3a6>
   1048a:	00 d0       	rcall	.+0      	; 0x1048c <TestUserInput+0x3a8>
   1048c:	00 d0       	rcall	.+0      	; 0x1048e <TestUserInput+0x3aa>
   1048e:	ed b7       	in	r30, 0x3d	; 61
   10490:	fe b7       	in	r31, 0x3e	; 62
   10492:	31 96       	adiw	r30, 0x01	; 1
   10494:	ad b7       	in	r26, 0x3d	; 61
   10496:	be b7       	in	r27, 0x3e	; 62
   10498:	12 96       	adiw	r26, 0x02	; 2
   1049a:	1c 93       	st	X, r17
   1049c:	0e 93       	st	-X, r16
   1049e:	11 97       	sbiw	r26, 0x01	; 1
   104a0:	8d e8       	ldi	r24, 0x8D	; 141
   104a2:	93 e0       	ldi	r25, 0x03	; 3
   104a4:	93 83       	std	Z+3, r25	; 0x03
   104a6:	82 83       	std	Z+2, r24	; 0x02
   104a8:	b5 82       	std	Z+5, r11	; 0x05
   104aa:	a4 82       	std	Z+4, r10	; 0x04
   104ac:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
	   _uart_print(0,1,strSend);
   104b0:	8d b7       	in	r24, 0x3d	; 61
   104b2:	9e b7       	in	r25, 0x3e	; 62
   104b4:	06 96       	adiw	r24, 0x06	; 6
   104b6:	0f b6       	in	r0, 0x3f	; 63
   104b8:	f8 94       	cli
   104ba:	9e bf       	out	0x3e, r25	; 62
   104bc:	0f be       	out	0x3f, r0	; 63
   104be:	8d bf       	out	0x3d, r24	; 61
   104c0:	80 e0       	ldi	r24, 0x00	; 0
   104c2:	61 e0       	ldi	r22, 0x01	; 1
   104c4:	a8 01       	movw	r20, r16
   104c6:	0e 94 f2 b3 	call	0x167e4	; 0x167e4 <_uart_print>
	   sprintf_P(strSend,PSTR("FmtTMoney:%s"),STotalMoney);
   104ca:	00 d0       	rcall	.+0      	; 0x104cc <TestUserInput+0x3e8>
   104cc:	00 d0       	rcall	.+0      	; 0x104ce <TestUserInput+0x3ea>
   104ce:	00 d0       	rcall	.+0      	; 0x104d0 <TestUserInput+0x3ec>
   104d0:	ed b7       	in	r30, 0x3d	; 61
   104d2:	fe b7       	in	r31, 0x3e	; 62
   104d4:	31 96       	adiw	r30, 0x01	; 1
   104d6:	ad b7       	in	r26, 0x3d	; 61
   104d8:	be b7       	in	r27, 0x3e	; 62
   104da:	12 96       	adiw	r26, 0x02	; 2
   104dc:	1c 93       	st	X, r17
   104de:	0e 93       	st	-X, r16
   104e0:	11 97       	sbiw	r26, 0x01	; 1
   104e2:	80 e8       	ldi	r24, 0x80	; 128
   104e4:	93 e0       	ldi	r25, 0x03	; 3
   104e6:	93 83       	std	Z+3, r25	; 0x03
   104e8:	82 83       	std	Z+2, r24	; 0x02
   104ea:	d5 82       	std	Z+5, r13	; 0x05
   104ec:	c4 82       	std	Z+4, r12	; 0x04
   104ee:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
	   _uart_print(0,1,strSend);
   104f2:	8d b7       	in	r24, 0x3d	; 61
   104f4:	9e b7       	in	r25, 0x3e	; 62
   104f6:	06 96       	adiw	r24, 0x06	; 6
   104f8:	0f b6       	in	r0, 0x3f	; 63
   104fa:	f8 94       	cli
   104fc:	9e bf       	out	0x3e, r25	; 62
   104fe:	0f be       	out	0x3f, r0	; 63
   10500:	8d bf       	out	0x3d, r24	; 61
   10502:	80 e0       	ldi	r24, 0x00	; 0
   10504:	61 e0       	ldi	r22, 0x01	; 1
   10506:	a8 01       	movw	r20, r16
   10508:	0e 94 f2 b3 	call	0x167e4	; 0x167e4 <_uart_print>
   1050c:	02 c0       	rjmp	.+4      	; 0x10512 <TestUserInput+0x42e>


   	
	}else    
	if (uiResult==USER_CANCEL){
   1050e:	81 30       	cpi	r24, 0x01	; 1
   10510:	11 f0       	breq	.+4      	; 0x10516 <TestUserInput+0x432>
   10512:	80 e0       	ldi	r24, 0x00	; 0
   10514:	0b c0       	rjmp	.+22     	; 0x1052c <TestUserInput+0x448>
	   lcd_clear();
   10516:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
   1051a:	fe 01       	movw	r30, r28
   1051c:	fd 96       	adiw	r30, 0x3d	; 61

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   1051e:	cf 01       	movw	r24, r30
   10520:	0f 96       	adiw	r24, 0x0f	; 15
	     strMemory[i]=data;
   10522:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   10524:	e8 17       	cp	r30, r24
   10526:	f9 07       	cpc	r31, r25
   10528:	e1 f7       	brne	.-8      	; 0x10522 <TestUserInput+0x43e>
   1052a:	81 e0       	ldi	r24, 0x01	; 1
       Result=MENU_DONE;   
	   //lcd_printf(1,1,PSTR("InputNumber:"));
       //lcd_printf(2,1,PSTR("_         "));
	}
  return Result;
}
   1052c:	c2 59       	subi	r28, 0x92	; 146
   1052e:	df 4f       	sbci	r29, 0xFF	; 255
   10530:	0f b6       	in	r0, 0x3f	; 63
   10532:	f8 94       	cli
   10534:	de bf       	out	0x3e, r29	; 62
   10536:	0f be       	out	0x3f, r0	; 63
   10538:	cd bf       	out	0x3d, r28	; 61
   1053a:	cf 91       	pop	r28
   1053c:	df 91       	pop	r29
   1053e:	1f 91       	pop	r17
   10540:	0f 91       	pop	r16
   10542:	ff 90       	pop	r15
   10544:	ef 90       	pop	r14
   10546:	df 90       	pop	r13
   10548:	cf 90       	pop	r12
   1054a:	bf 90       	pop	r11
   1054c:	af 90       	pop	r10
   1054e:	9f 90       	pop	r9
   10550:	8f 90       	pop	r8
   10552:	7f 90       	pop	r7
   10554:	6f 90       	pop	r6
   10556:	08 95       	ret

00010558 <FSettingDec>:

	Result=MENU_DONE;
	return Result;
}

char FSettingDec(){
   10558:	df 92       	push	r13
   1055a:	ef 92       	push	r14
   1055c:	ff 92       	push	r15
   1055e:	0f 93       	push	r16
   10560:	1f 93       	push	r17
   10562:	df 93       	push	r29
   10564:	cf 93       	push	r28
   10566:	cd b7       	in	r28, 0x3d	; 61
   10568:	de b7       	in	r29, 0x3e	; 62
   1056a:	64 97       	sbiw	r28, 0x14	; 20
   1056c:	0f b6       	in	r0, 0x3f	; 63
   1056e:	f8 94       	cli
   10570:	de bf       	out	0x3e, r29	; 62
   10572:	0f be       	out	0x3f, r0	; 63
   10574:	cd bf       	out	0x3d, r28	; 61
static char stSettingDecimal=sdInitDisplay;
     char PDecimalConfig[4],Addr,KeyChar,Result;
	 char lcdteks[20];

     Result=MENU_NONE;
	 switch(stSettingDecimal){
   10576:	80 91 e3 02 	lds	r24, 0x02E3
   1057a:	82 30       	cpi	r24, 0x02	; 2
   1057c:	09 f4       	brne	.+2      	; 0x10580 <FSettingDec+0x28>
   1057e:	c7 c0       	rjmp	.+398    	; 0x1070e <FSettingDec+0x1b6>
   10580:	83 30       	cpi	r24, 0x03	; 3
   10582:	30 f4       	brcc	.+12     	; 0x10590 <FSettingDec+0x38>
   10584:	88 23       	and	r24, r24
   10586:	71 f0       	breq	.+28     	; 0x105a4 <FSettingDec+0x4c>
   10588:	81 30       	cpi	r24, 0x01	; 1
   1058a:	09 f0       	breq	.+2      	; 0x1058e <FSettingDec+0x36>
   1058c:	c3 c1       	rjmp	.+902    	; 0x10914 <FSettingDec+0x3bc>
   1058e:	92 c0       	rjmp	.+292    	; 0x106b4 <FSettingDec+0x15c>
   10590:	84 30       	cpi	r24, 0x04	; 4
   10592:	09 f4       	brne	.+2      	; 0x10596 <FSettingDec+0x3e>
   10594:	b3 c1       	rjmp	.+870    	; 0x108fc <FSettingDec+0x3a4>
   10596:	84 30       	cpi	r24, 0x04	; 4
   10598:	08 f4       	brcc	.+2      	; 0x1059c <FSettingDec+0x44>
   1059a:	68 c1       	rjmp	.+720    	; 0x1086c <FSettingDec+0x314>
   1059c:	85 30       	cpi	r24, 0x05	; 5
   1059e:	09 f0       	breq	.+2      	; 0x105a2 <FSettingDec+0x4a>
   105a0:	b9 c1       	rjmp	.+882    	; 0x10914 <FSettingDec+0x3bc>
   105a2:	b4 c1       	rjmp	.+872    	; 0x1090c <FSettingDec+0x3b4>
	 case sdInitDisplay:
	      lcd_clear();         //"12345678901234567890
   105a4:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   105a8:	e1 99       	sbic	0x1c, 1	; 28
   105aa:	fe cf       	rjmp	.-4      	; 0x105a8 <FSettingDec+0x50>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   105ac:	89 e3       	ldi	r24, 0x39	; 57
   105ae:	90 e0       	ldi	r25, 0x00	; 0
   105b0:	9f bb       	out	0x1f, r25	; 31
   105b2:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   105b4:	e0 9a       	sbi	0x1c, 0	; 28
   105b6:	2d b3       	in	r18, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   105b8:	e1 99       	sbic	0x1c, 1	; 28
   105ba:	fe cf       	rjmp	.-4      	; 0x105b8 <FSettingDec+0x60>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   105bc:	8a e3       	ldi	r24, 0x3A	; 58
   105be:	90 e0       	ldi	r25, 0x00	; 0
   105c0:	9f bb       	out	0x1f, r25	; 31
   105c2:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   105c4:	e0 9a       	sbi	0x1c, 0	; 28
   105c6:	ed b2       	in	r14, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   105c8:	e1 99       	sbic	0x1c, 1	; 28
   105ca:	fe cf       	rjmp	.-4      	; 0x105c8 <FSettingDec+0x70>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   105cc:	8b e3       	ldi	r24, 0x3B	; 59
   105ce:	90 e0       	ldi	r25, 0x00	; 0
   105d0:	9f bb       	out	0x1f, r25	; 31
   105d2:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   105d4:	e0 9a       	sbi	0x1c, 0	; 28
   105d6:	fd b2       	in	r15, 0x1d	; 29
		  PDecimalConfig[0]=eeprom_read_byte(&DefDecimalPrice);
		  PDecimalConfig[1]=eeprom_read_byte(&DefDecimalVolume);
		  PDecimalConfig[2]=eeprom_read_byte(&DefDecimalMoney);

		  sprintf_P(lcdteks,PSTR("1.Price :%d"),PDecimalConfig[0]);
   105d8:	00 d0       	rcall	.+0      	; 0x105da <FSettingDec+0x82>
   105da:	00 d0       	rcall	.+0      	; 0x105dc <FSettingDec+0x84>
   105dc:	00 d0       	rcall	.+0      	; 0x105de <FSettingDec+0x86>
   105de:	ed b7       	in	r30, 0x3d	; 61
   105e0:	fe b7       	in	r31, 0x3e	; 62
   105e2:	31 96       	adiw	r30, 0x01	; 1
   105e4:	8e 01       	movw	r16, r28
   105e6:	0f 5f       	subi	r16, 0xFF	; 255
   105e8:	1f 4f       	sbci	r17, 0xFF	; 255
   105ea:	ad b7       	in	r26, 0x3d	; 61
   105ec:	be b7       	in	r27, 0x3e	; 62
   105ee:	12 96       	adiw	r26, 0x02	; 2
   105f0:	1c 93       	st	X, r17
   105f2:	0e 93       	st	-X, r16
   105f4:	11 97       	sbiw	r26, 0x01	; 1
   105f6:	8d e5       	ldi	r24, 0x5D	; 93
   105f8:	91 e1       	ldi	r25, 0x11	; 17
   105fa:	93 83       	std	Z+3, r25	; 0x03
   105fc:	82 83       	std	Z+2, r24	; 0x02
   105fe:	24 83       	std	Z+4, r18	; 0x04
   10600:	15 82       	std	Z+5, r1	; 0x05
   10602:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
		  lcd_print(1,1,lcdteks);
   10606:	8d b7       	in	r24, 0x3d	; 61
   10608:	9e b7       	in	r25, 0x3e	; 62
   1060a:	06 96       	adiw	r24, 0x06	; 6
   1060c:	0f b6       	in	r0, 0x3f	; 63
   1060e:	f8 94       	cli
   10610:	9e bf       	out	0x3e, r25	; 62
   10612:	0f be       	out	0x3f, r0	; 63
   10614:	8d bf       	out	0x3d, r24	; 61
   10616:	81 e0       	ldi	r24, 0x01	; 1
   10618:	61 e0       	ldi	r22, 0x01	; 1
   1061a:	a8 01       	movw	r20, r16
   1061c:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
		  sprintf_P(lcdteks,PSTR("2.Volume:%d"),PDecimalConfig[1]);
   10620:	00 d0       	rcall	.+0      	; 0x10622 <FSettingDec+0xca>
   10622:	00 d0       	rcall	.+0      	; 0x10624 <FSettingDec+0xcc>
   10624:	00 d0       	rcall	.+0      	; 0x10626 <FSettingDec+0xce>
   10626:	ed b7       	in	r30, 0x3d	; 61
   10628:	fe b7       	in	r31, 0x3e	; 62
   1062a:	31 96       	adiw	r30, 0x01	; 1
   1062c:	ad b7       	in	r26, 0x3d	; 61
   1062e:	be b7       	in	r27, 0x3e	; 62
   10630:	12 96       	adiw	r26, 0x02	; 2
   10632:	1c 93       	st	X, r17
   10634:	0e 93       	st	-X, r16
   10636:	11 97       	sbiw	r26, 0x01	; 1
   10638:	81 e5       	ldi	r24, 0x51	; 81
   1063a:	91 e1       	ldi	r25, 0x11	; 17
   1063c:	93 83       	std	Z+3, r25	; 0x03
   1063e:	82 83       	std	Z+2, r24	; 0x02
   10640:	e4 82       	std	Z+4, r14	; 0x04
   10642:	15 82       	std	Z+5, r1	; 0x05
   10644:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
		  lcd_print(2,1,lcdteks);
   10648:	8d b7       	in	r24, 0x3d	; 61
   1064a:	9e b7       	in	r25, 0x3e	; 62
   1064c:	06 96       	adiw	r24, 0x06	; 6
   1064e:	0f b6       	in	r0, 0x3f	; 63
   10650:	f8 94       	cli
   10652:	9e bf       	out	0x3e, r25	; 62
   10654:	0f be       	out	0x3f, r0	; 63
   10656:	8d bf       	out	0x3d, r24	; 61
   10658:	82 e0       	ldi	r24, 0x02	; 2
   1065a:	61 e0       	ldi	r22, 0x01	; 1
   1065c:	a8 01       	movw	r20, r16
   1065e:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
		  sprintf_P(lcdteks,PSTR("3.Money :%d"),PDecimalConfig[2]);
   10662:	00 d0       	rcall	.+0      	; 0x10664 <FSettingDec+0x10c>
   10664:	00 d0       	rcall	.+0      	; 0x10666 <FSettingDec+0x10e>
   10666:	00 d0       	rcall	.+0      	; 0x10668 <FSettingDec+0x110>
   10668:	ed b7       	in	r30, 0x3d	; 61
   1066a:	fe b7       	in	r31, 0x3e	; 62
   1066c:	31 96       	adiw	r30, 0x01	; 1
   1066e:	ad b7       	in	r26, 0x3d	; 61
   10670:	be b7       	in	r27, 0x3e	; 62
   10672:	12 96       	adiw	r26, 0x02	; 2
   10674:	1c 93       	st	X, r17
   10676:	0e 93       	st	-X, r16
   10678:	11 97       	sbiw	r26, 0x01	; 1
   1067a:	85 e4       	ldi	r24, 0x45	; 69
   1067c:	91 e1       	ldi	r25, 0x11	; 17
   1067e:	93 83       	std	Z+3, r25	; 0x03
   10680:	82 83       	std	Z+2, r24	; 0x02
   10682:	f4 82       	std	Z+4, r15	; 0x04
   10684:	15 82       	std	Z+5, r1	; 0x05
   10686:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
		  lcd_print(3,1,lcdteks);
   1068a:	8d b7       	in	r24, 0x3d	; 61
   1068c:	9e b7       	in	r25, 0x3e	; 62
   1068e:	06 96       	adiw	r24, 0x06	; 6
   10690:	0f b6       	in	r0, 0x3f	; 63
   10692:	f8 94       	cli
   10694:	9e bf       	out	0x3e, r25	; 62
   10696:	0f be       	out	0x3f, r0	; 63
   10698:	8d bf       	out	0x3d, r24	; 61
   1069a:	83 e0       	ldi	r24, 0x03	; 3
   1069c:	61 e0       	ldi	r22, 0x01	; 1
   1069e:	a8 01       	movw	r20, r16
   106a0:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
		  lcd_printf(4,1,PSTR("[*]Back  [#]Next"));
   106a4:	84 e0       	ldi	r24, 0x04	; 4
   106a6:	61 e0       	ldi	r22, 0x01	; 1
   106a8:	44 e3       	ldi	r20, 0x34	; 52
   106aa:	51 e1       	ldi	r21, 0x11	; 17
   106ac:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		  stSettingDecimal=sdSelectKey1;
   106b0:	81 e0       	ldi	r24, 0x01	; 1
   106b2:	29 c1       	rjmp	.+594    	; 0x10906 <FSettingDec+0x3ae>
		  break;
     case sdSelectKey1:
          KeyChar=_key_btn(_key_scan(1));
   106b4:	81 e0       	ldi	r24, 0x01	; 1
   106b6:	0e 94 06 b0 	call	0x1600c	; 0x1600c <_key_scan>
   106ba:	0e 94 67 af 	call	0x15ece	; 0x15ece <_key_btn>
		  if ((KeyChar>='1')&&(KeyChar<='3')){
   106be:	98 2f       	mov	r25, r24
   106c0:	91 53       	subi	r25, 0x31	; 49
   106c2:	93 30       	cpi	r25, 0x03	; 3
   106c4:	e0 f4       	brcc	.+56     	; 0x106fe <FSettingDec+0x1a6>
		      Addr=KeyChar-'1';
		  	  PDecimalConfig[Addr]=eeprom_read_byte(&DefDecimalPrice+Addr);
   106c6:	29 2f       	mov	r18, r25
   106c8:	30 e0       	ldi	r19, 0x00	; 0
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   106ca:	e1 99       	sbic	0x1c, 1	; 28
   106cc:	fe cf       	rjmp	.-4      	; 0x106ca <FSettingDec+0x172>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   106ce:	c9 01       	movw	r24, r18
   106d0:	87 5c       	subi	r24, 0xC7	; 199
   106d2:	9f 4f       	sbci	r25, 0xFF	; 255
   106d4:	9f bb       	out	0x1f, r25	; 31
   106d6:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   106d8:	e0 9a       	sbi	0x1c, 0	; 28
   106da:	8d b3       	in	r24, 0x1d	; 29
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   106dc:	e1 99       	sbic	0x1c, 1	; 28
   106de:	fe cf       	rjmp	.-4      	; 0x106dc <FSettingDec+0x184>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   106e0:	27 5c       	subi	r18, 0xC7	; 199
   106e2:	3f 4f       	sbci	r19, 0xFF	; 255
   106e4:	3f bb       	out	0x1f, r19	; 31
   106e6:	2e bb       	out	0x1e, r18	; 30
			  PDecimalConfig[Addr]=(PDecimalConfig[Addr]+1)%4;
   106e8:	90 e0       	ldi	r25, 0x00	; 0
   106ea:	01 96       	adiw	r24, 0x01	; 1
   106ec:	83 70       	andi	r24, 0x03	; 3
   106ee:	90 70       	andi	r25, 0x00	; 0
#endif
    EEDR = __value;
   106f0:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
   106f2:	0f b6       	in	r0, 0x3f	; 63
   106f4:	f8 94       	cli
   106f6:	e2 9a       	sbi	0x1c, 2	; 28
   106f8:	e1 9a       	sbi	0x1c, 1	; 28
   106fa:	0f be       	out	0x3f, r0	; 63
   106fc:	f6 c0       	rjmp	.+492    	; 0x108ea <FSettingDec+0x392>

			  eeprom_write_byte(&DefDecimalPrice+Addr,PDecimalConfig[Addr]);
              stSettingDecimal=sdInitDisplay;
		  }else if (KeyChar=='*') stSettingDecimal=sdExitSettingDecimal;
   106fe:	8a 32       	cpi	r24, 0x2A	; 42
   10700:	11 f4       	brne	.+4      	; 0x10706 <FSettingDec+0x1ae>
   10702:	85 e0       	ldi	r24, 0x05	; 5
   10704:	00 c1       	rjmp	.+512    	; 0x10906 <FSettingDec+0x3ae>
		  else if (KeyChar=='#') stSettingDecimal=sdInitDisplay2;
   10706:	83 32       	cpi	r24, 0x23	; 35
   10708:	09 f0       	breq	.+2      	; 0x1070c <FSettingDec+0x1b4>
   1070a:	04 c1       	rjmp	.+520    	; 0x10914 <FSettingDec+0x3bc>
   1070c:	fb c0       	rjmp	.+502    	; 0x10904 <FSettingDec+0x3ac>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   1070e:	e1 99       	sbic	0x1c, 1	; 28
   10710:	fe cf       	rjmp	.-4      	; 0x1070e <FSettingDec+0x1b6>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   10712:	8c e3       	ldi	r24, 0x3C	; 60
   10714:	90 e0       	ldi	r25, 0x00	; 0
   10716:	9f bb       	out	0x1f, r25	; 31
   10718:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   1071a:	e0 9a       	sbi	0x1c, 0	; 28
   1071c:	2d b3       	in	r18, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   1071e:	e1 99       	sbic	0x1c, 1	; 28
   10720:	fe cf       	rjmp	.-4      	; 0x1071e <FSettingDec+0x1c6>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   10722:	8d e3       	ldi	r24, 0x3D	; 61
   10724:	90 e0       	ldi	r25, 0x00	; 0
   10726:	9f bb       	out	0x1f, r25	; 31
   10728:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   1072a:	e0 9a       	sbi	0x1c, 0	; 28
   1072c:	ed b2       	in	r14, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   1072e:	e1 99       	sbic	0x1c, 1	; 28
   10730:	fe cf       	rjmp	.-4      	; 0x1072e <FSettingDec+0x1d6>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   10732:	8e e3       	ldi	r24, 0x3E	; 62
   10734:	90 e0       	ldi	r25, 0x00	; 0
   10736:	9f bb       	out	0x1f, r25	; 31
   10738:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   1073a:	e0 9a       	sbi	0x1c, 0	; 28
   1073c:	dd b2       	in	r13, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   1073e:	e1 99       	sbic	0x1c, 1	; 28
   10740:	fe cf       	rjmp	.-4      	; 0x1073e <FSettingDec+0x1e6>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   10742:	8f e3       	ldi	r24, 0x3F	; 63
   10744:	90 e0       	ldi	r25, 0x00	; 0
   10746:	9f bb       	out	0x1f, r25	; 31
   10748:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   1074a:	e0 9a       	sbi	0x1c, 0	; 28
   1074c:	fd b2       	in	r15, 0x1d	; 29
     case sdInitDisplay2:
		  PDecimalConfig[0]=eeprom_read_byte(&DefDecimalTotalVolume);
		  PDecimalConfig[1]=eeprom_read_byte(&DefDecimalTotalMoney);
		  PDecimalConfig[2]=eeprom_read_byte(&DefDecimalMark);
		  PDecimalConfig[3]=eeprom_read_byte(&DefCurrencyMark);
		  sprintf_P(lcdteks,PSTR("1.T.Volume:%d  5.Test"),PDecimalConfig[0]);
   1074e:	00 d0       	rcall	.+0      	; 0x10750 <FSettingDec+0x1f8>
   10750:	00 d0       	rcall	.+0      	; 0x10752 <FSettingDec+0x1fa>
   10752:	00 d0       	rcall	.+0      	; 0x10754 <FSettingDec+0x1fc>
   10754:	ed b7       	in	r30, 0x3d	; 61
   10756:	fe b7       	in	r31, 0x3e	; 62
   10758:	31 96       	adiw	r30, 0x01	; 1
   1075a:	8e 01       	movw	r16, r28
   1075c:	0f 5f       	subi	r16, 0xFF	; 255
   1075e:	1f 4f       	sbci	r17, 0xFF	; 255
   10760:	ad b7       	in	r26, 0x3d	; 61
   10762:	be b7       	in	r27, 0x3e	; 62
   10764:	12 96       	adiw	r26, 0x02	; 2
   10766:	1c 93       	st	X, r17
   10768:	0e 93       	st	-X, r16
   1076a:	11 97       	sbiw	r26, 0x01	; 1
   1076c:	8e e1       	ldi	r24, 0x1E	; 30
   1076e:	91 e1       	ldi	r25, 0x11	; 17
   10770:	93 83       	std	Z+3, r25	; 0x03
   10772:	82 83       	std	Z+2, r24	; 0x02
   10774:	24 83       	std	Z+4, r18	; 0x04
   10776:	15 82       	std	Z+5, r1	; 0x05
   10778:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
		  lcd_print(1,1,lcdteks);
   1077c:	8d b7       	in	r24, 0x3d	; 61
   1077e:	9e b7       	in	r25, 0x3e	; 62
   10780:	06 96       	adiw	r24, 0x06	; 6
   10782:	0f b6       	in	r0, 0x3f	; 63
   10784:	f8 94       	cli
   10786:	9e bf       	out	0x3e, r25	; 62
   10788:	0f be       	out	0x3f, r0	; 63
   1078a:	8d bf       	out	0x3d, r24	; 61
   1078c:	81 e0       	ldi	r24, 0x01	; 1
   1078e:	61 e0       	ldi	r22, 0x01	; 1
   10790:	a8 01       	movw	r20, r16
   10792:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
		  sprintf_P(lcdteks,PSTR("2.T.Money :%d "),PDecimalConfig[1]);
   10796:	00 d0       	rcall	.+0      	; 0x10798 <FSettingDec+0x240>
   10798:	00 d0       	rcall	.+0      	; 0x1079a <FSettingDec+0x242>
   1079a:	00 d0       	rcall	.+0      	; 0x1079c <FSettingDec+0x244>
   1079c:	ed b7       	in	r30, 0x3d	; 61
   1079e:	fe b7       	in	r31, 0x3e	; 62
   107a0:	31 96       	adiw	r30, 0x01	; 1
   107a2:	ad b7       	in	r26, 0x3d	; 61
   107a4:	be b7       	in	r27, 0x3e	; 62
   107a6:	12 96       	adiw	r26, 0x02	; 2
   107a8:	1c 93       	st	X, r17
   107aa:	0e 93       	st	-X, r16
   107ac:	11 97       	sbiw	r26, 0x01	; 1
   107ae:	8f e0       	ldi	r24, 0x0F	; 15
   107b0:	91 e1       	ldi	r25, 0x11	; 17
   107b2:	93 83       	std	Z+3, r25	; 0x03
   107b4:	82 83       	std	Z+2, r24	; 0x02
   107b6:	e4 82       	std	Z+4, r14	; 0x04
   107b8:	15 82       	std	Z+5, r1	; 0x05
   107ba:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
		  lcd_print(2,1,lcdteks);
   107be:	8d b7       	in	r24, 0x3d	; 61
   107c0:	9e b7       	in	r25, 0x3e	; 62
   107c2:	06 96       	adiw	r24, 0x06	; 6
   107c4:	0f b6       	in	r0, 0x3f	; 63
   107c6:	f8 94       	cli
   107c8:	9e bf       	out	0x3e, r25	; 62
   107ca:	0f be       	out	0x3f, r0	; 63
   107cc:	8d bf       	out	0x3d, r24	; 61
   107ce:	82 e0       	ldi	r24, 0x02	; 2
   107d0:	61 e0       	ldi	r22, 0x01	; 1
   107d2:	a8 01       	movw	r20, r16
   107d4:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
		  sprintf_P(lcdteks,PSTR("3.Decimal :%c "),PDecimalConfig[2]);
   107d8:	00 d0       	rcall	.+0      	; 0x107da <FSettingDec+0x282>
   107da:	00 d0       	rcall	.+0      	; 0x107dc <FSettingDec+0x284>
   107dc:	00 d0       	rcall	.+0      	; 0x107de <FSettingDec+0x286>
   107de:	ed b7       	in	r30, 0x3d	; 61
   107e0:	fe b7       	in	r31, 0x3e	; 62
   107e2:	31 96       	adiw	r30, 0x01	; 1
   107e4:	ad b7       	in	r26, 0x3d	; 61
   107e6:	be b7       	in	r27, 0x3e	; 62
   107e8:	12 96       	adiw	r26, 0x02	; 2
   107ea:	1c 93       	st	X, r17
   107ec:	0e 93       	st	-X, r16
   107ee:	11 97       	sbiw	r26, 0x01	; 1
   107f0:	80 e0       	ldi	r24, 0x00	; 0
   107f2:	91 e1       	ldi	r25, 0x11	; 17
   107f4:	93 83       	std	Z+3, r25	; 0x03
   107f6:	82 83       	std	Z+2, r24	; 0x02
   107f8:	d4 82       	std	Z+4, r13	; 0x04
   107fa:	15 82       	std	Z+5, r1	; 0x05
   107fc:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
		  lcd_print(3,1,lcdteks);
   10800:	8d b7       	in	r24, 0x3d	; 61
   10802:	9e b7       	in	r25, 0x3e	; 62
   10804:	06 96       	adiw	r24, 0x06	; 6
   10806:	0f b6       	in	r0, 0x3f	; 63
   10808:	f8 94       	cli
   1080a:	9e bf       	out	0x3e, r25	; 62
   1080c:	0f be       	out	0x3f, r0	; 63
   1080e:	8d bf       	out	0x3d, r24	; 61
   10810:	83 e0       	ldi	r24, 0x03	; 3
   10812:	61 e0       	ldi	r22, 0x01	; 1
   10814:	a8 01       	movw	r20, r16
   10816:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
		  sprintf_P(lcdteks,PSTR("4.Sparator:%c "),PDecimalConfig[3]);
   1081a:	00 d0       	rcall	.+0      	; 0x1081c <FSettingDec+0x2c4>
   1081c:	00 d0       	rcall	.+0      	; 0x1081e <FSettingDec+0x2c6>
   1081e:	00 d0       	rcall	.+0      	; 0x10820 <FSettingDec+0x2c8>
   10820:	ed b7       	in	r30, 0x3d	; 61
   10822:	fe b7       	in	r31, 0x3e	; 62
   10824:	31 96       	adiw	r30, 0x01	; 1
   10826:	ad b7       	in	r26, 0x3d	; 61
   10828:	be b7       	in	r27, 0x3e	; 62
   1082a:	12 96       	adiw	r26, 0x02	; 2
   1082c:	1c 93       	st	X, r17
   1082e:	0e 93       	st	-X, r16
   10830:	11 97       	sbiw	r26, 0x01	; 1
   10832:	81 ef       	ldi	r24, 0xF1	; 241
   10834:	90 e1       	ldi	r25, 0x10	; 16
   10836:	93 83       	std	Z+3, r25	; 0x03
   10838:	82 83       	std	Z+2, r24	; 0x02
   1083a:	f4 82       	std	Z+4, r15	; 0x04
   1083c:	15 82       	std	Z+5, r1	; 0x05
   1083e:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
		  lcd_print(4,1,lcdteks);
   10842:	8d b7       	in	r24, 0x3d	; 61
   10844:	9e b7       	in	r25, 0x3e	; 62
   10846:	06 96       	adiw	r24, 0x06	; 6
   10848:	0f b6       	in	r0, 0x3f	; 63
   1084a:	f8 94       	cli
   1084c:	9e bf       	out	0x3e, r25	; 62
   1084e:	0f be       	out	0x3f, r0	; 63
   10850:	8d bf       	out	0x3d, r24	; 61
   10852:	84 e0       	ldi	r24, 0x04	; 4
   10854:	61 e0       	ldi	r22, 0x01	; 1
   10856:	a8 01       	movw	r20, r16
   10858:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
		  lcd_printf(4,14,PSTR("*)Back"));
   1085c:	84 e0       	ldi	r24, 0x04	; 4
   1085e:	6e e0       	ldi	r22, 0x0E	; 14
   10860:	4a ee       	ldi	r20, 0xEA	; 234
   10862:	50 e1       	ldi	r21, 0x10	; 16
   10864:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
	      stSettingDecimal=sdSelectKey2;
   10868:	83 e0       	ldi	r24, 0x03	; 3
   1086a:	4d c0       	rjmp	.+154    	; 0x10906 <FSettingDec+0x3ae>
	      break;
     case sdSelectKey2:
          KeyChar=_key_btn(_key_scan(1));
   1086c:	81 e0       	ldi	r24, 0x01	; 1
   1086e:	0e 94 06 b0 	call	0x1600c	; 0x1600c <_key_scan>
   10872:	0e 94 67 af 	call	0x15ece	; 0x15ece <_key_btn>
   10876:	28 2f       	mov	r18, r24
		  if ((KeyChar>='1')&&(KeyChar<='2')){
   10878:	98 2f       	mov	r25, r24
   1087a:	91 53       	subi	r25, 0x31	; 49
   1087c:	92 30       	cpi	r25, 0x02	; 2
   1087e:	b0 f4       	brcc	.+44     	; 0x108ac <FSettingDec+0x354>
		      Addr=KeyChar-'1';
		  	  PDecimalConfig[Addr]=eeprom_read_byte(&DefDecimalTotalVolume+Addr);
   10880:	29 2f       	mov	r18, r25
   10882:	30 e0       	ldi	r19, 0x00	; 0
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   10884:	e1 99       	sbic	0x1c, 1	; 28
   10886:	fe cf       	rjmp	.-4      	; 0x10884 <FSettingDec+0x32c>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   10888:	c9 01       	movw	r24, r18
   1088a:	84 5c       	subi	r24, 0xC4	; 196
   1088c:	9f 4f       	sbci	r25, 0xFF	; 255
   1088e:	9f bb       	out	0x1f, r25	; 31
   10890:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   10892:	e0 9a       	sbi	0x1c, 0	; 28
   10894:	8d b3       	in	r24, 0x1d	; 29
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   10896:	e1 99       	sbic	0x1c, 1	; 28
   10898:	fe cf       	rjmp	.-4      	; 0x10896 <FSettingDec+0x33e>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   1089a:	24 5c       	subi	r18, 0xC4	; 196
   1089c:	3f 4f       	sbci	r19, 0xFF	; 255
   1089e:	3f bb       	out	0x1f, r19	; 31
   108a0:	2e bb       	out	0x1e, r18	; 30
		      PDecimalConfig[Addr]=(PDecimalConfig[Addr]+1)%4;
   108a2:	90 e0       	ldi	r25, 0x00	; 0
   108a4:	01 96       	adiw	r24, 0x01	; 1
   108a6:	83 70       	andi	r24, 0x03	; 3
   108a8:	90 70       	andi	r25, 0x00	; 0
   108aa:	16 c0       	rjmp	.+44     	; 0x108d8 <FSettingDec+0x380>

			  eeprom_write_byte(&DefDecimalTotalVolume+Addr,PDecimalConfig[Addr]);
              stSettingDecimal=sdInitDisplay2;
		  }else if ((KeyChar>='3')&&(KeyChar<='4')){
   108ac:	83 53       	subi	r24, 0x33	; 51
   108ae:	82 30       	cpi	r24, 0x02	; 2
   108b0:	d0 f4       	brcc	.+52     	; 0x108e6 <FSettingDec+0x38e>
		      Addr=KeyChar-'1';
		  	  PDecimalConfig[Addr]=eeprom_read_byte(&DefDecimalTotalVolume+Addr);
   108b2:	09 2f       	mov	r16, r25
   108b4:	10 e0       	ldi	r17, 0x00	; 0
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   108b6:	e1 99       	sbic	0x1c, 1	; 28
   108b8:	fe cf       	rjmp	.-4      	; 0x108b6 <FSettingDec+0x35e>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   108ba:	c8 01       	movw	r24, r16
   108bc:	84 5c       	subi	r24, 0xC4	; 196
   108be:	9f 4f       	sbci	r25, 0xFF	; 255
   108c0:	9f bb       	out	0x1f, r25	; 31
   108c2:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   108c4:	e0 9a       	sbi	0x1c, 0	; 28
   108c6:	8d b3       	in	r24, 0x1d	; 29
			  PDecimalConfig[Addr]=SelectMark(PDecimalConfig[Addr]);
   108c8:	0e 94 34 1f 	call	0x3e68	; 0x3e68 <SelectMark>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   108cc:	e1 99       	sbic	0x1c, 1	; 28
   108ce:	fe cf       	rjmp	.-4      	; 0x108cc <FSettingDec+0x374>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   108d0:	04 5c       	subi	r16, 0xC4	; 196
   108d2:	1f 4f       	sbci	r17, 0xFF	; 255
   108d4:	1f bb       	out	0x1f, r17	; 31
   108d6:	0e bb       	out	0x1e, r16	; 30
#endif
    EEDR = __value;
   108d8:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
   108da:	0f b6       	in	r0, 0x3f	; 63
   108dc:	f8 94       	cli
   108de:	e2 9a       	sbi	0x1c, 2	; 28
   108e0:	e1 9a       	sbi	0x1c, 1	; 28
   108e2:	0f be       	out	0x3f, r0	; 63
   108e4:	0f c0       	rjmp	.+30     	; 0x10904 <FSettingDec+0x3ac>
			  eeprom_write_byte(&DefDecimalTotalVolume+Addr,PDecimalConfig[Addr]);
              stSettingDecimal=sdInitDisplay2;
		  }else if (KeyChar=='*') stSettingDecimal=sdInitDisplay;
   108e6:	2a 32       	cpi	r18, 0x2A	; 42
   108e8:	19 f4       	brne	.+6      	; 0x108f0 <FSettingDec+0x398>
   108ea:	10 92 e3 02 	sts	0x02E3, r1
   108ee:	12 c0       	rjmp	.+36     	; 0x10914 <FSettingDec+0x3bc>
		  else if (KeyChar=='5'){
   108f0:	25 33       	cpi	r18, 0x35	; 53
   108f2:	81 f4       	brne	.+32     	; 0x10914 <FSettingDec+0x3bc>
		          lcd_clear();
   108f4:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
		          stSettingDecimal=sdTestInput;
   108f8:	84 e0       	ldi	r24, 0x04	; 4
   108fa:	05 c0       	rjmp	.+10     	; 0x10906 <FSettingDec+0x3ae>
				  }
          break;
     case sdTestInput:
	      if (TestUserInput()==MENU_DONE)stSettingDecimal=sdInitDisplay2;
   108fc:	0e 94 72 80 	call	0x100e4	; 0x100e4 <TestUserInput>
   10900:	81 30       	cpi	r24, 0x01	; 1
   10902:	41 f4       	brne	.+16     	; 0x10914 <FSettingDec+0x3bc>
   10904:	82 e0       	ldi	r24, 0x02	; 2
   10906:	80 93 e3 02 	sts	0x02E3, r24
   1090a:	04 c0       	rjmp	.+8      	; 0x10914 <FSettingDec+0x3bc>
	      break;
	 case sdExitSettingDecimal:
          stSettingDecimal=sdInitDisplay;
   1090c:	10 92 e3 02 	sts	0x02E3, r1
   10910:	81 e0       	ldi	r24, 0x01	; 1
   10912:	01 c0       	rjmp	.+2      	; 0x10916 <FSettingDec+0x3be>
   10914:	80 e0       	ldi	r24, 0x00	; 0
		  Result=MENU_DONE;
	      break;
	 }
    return Result;
}
   10916:	64 96       	adiw	r28, 0x14	; 20
   10918:	0f b6       	in	r0, 0x3f	; 63
   1091a:	f8 94       	cli
   1091c:	de bf       	out	0x3e, r29	; 62
   1091e:	0f be       	out	0x3f, r0	; 63
   10920:	cd bf       	out	0x3d, r28	; 61
   10922:	cf 91       	pop	r28
   10924:	df 91       	pop	r29
   10926:	1f 91       	pop	r17
   10928:	0f 91       	pop	r16
   1092a:	ff 90       	pop	r15
   1092c:	ef 90       	pop	r14
   1092e:	df 90       	pop	r13
   10930:	08 95       	ret

00010932 <FTestCalculation>:
	 }
  return Result;
}


void FTestCalculation(){
   10932:	cf 92       	push	r12
   10934:	df 92       	push	r13
   10936:	ef 92       	push	r14
   10938:	ff 92       	push	r15
   1093a:	0f 93       	push	r16
   1093c:	1f 93       	push	r17
   1093e:	df 93       	push	r29
   10940:	cf 93       	push	r28
   10942:	cd b7       	in	r28, 0x3d	; 61
   10944:	de b7       	in	r29, 0x3e	; 62
   10946:	64 97       	sbiw	r28, 0x14	; 20
   10948:	0f b6       	in	r0, 0x3f	; 63
   1094a:	f8 94       	cli
   1094c:	de bf       	out	0x3e, r29	; 62
   1094e:	0f be       	out	0x3f, r0	; 63
   10950:	cd bf       	out	0x3d, r28	; 61
static char stTestCalc=tcInitData,uiResult=USER_NONE;
static char InputA[20],InputB[20],OutputC[20];
     char lcdteks[20],KeyChar;
     
	 switch(stTestCalc){
   10952:	80 91 52 02 	lds	r24, 0x0252
   10956:	82 30       	cpi	r24, 0x02	; 2
   10958:	09 f4       	brne	.+2      	; 0x1095c <FTestCalculation+0x2a>
   1095a:	4b c0       	rjmp	.+150    	; 0x109f2 <FTestCalculation+0xc0>
   1095c:	83 30       	cpi	r24, 0x03	; 3
   1095e:	30 f4       	brcc	.+12     	; 0x1096c <FTestCalculation+0x3a>
   10960:	88 23       	and	r24, r24
   10962:	71 f0       	breq	.+28     	; 0x10980 <FTestCalculation+0x4e>
   10964:	81 30       	cpi	r24, 0x01	; 1
   10966:	09 f0       	breq	.+2      	; 0x1096a <FTestCalculation+0x38>
   10968:	e7 c0       	rjmp	.+462    	; 0x10b38 <FTestCalculation+0x206>
   1096a:	2f c0       	rjmp	.+94     	; 0x109ca <FTestCalculation+0x98>
   1096c:	84 30       	cpi	r24, 0x04	; 4
   1096e:	09 f4       	brne	.+2      	; 0x10972 <FTestCalculation+0x40>
   10970:	82 c0       	rjmp	.+260    	; 0x10a76 <FTestCalculation+0x144>
   10972:	84 30       	cpi	r24, 0x04	; 4
   10974:	08 f4       	brcc	.+2      	; 0x10978 <FTestCalculation+0x46>
   10976:	6d c0       	rjmp	.+218    	; 0x10a52 <FTestCalculation+0x120>
   10978:	85 30       	cpi	r24, 0x05	; 5
   1097a:	09 f0       	breq	.+2      	; 0x1097e <FTestCalculation+0x4c>
   1097c:	dd c0       	rjmp	.+442    	; 0x10b38 <FTestCalculation+0x206>
   1097e:	d1 c0       	rjmp	.+418    	; 0x10b22 <FTestCalculation+0x1f0>
	 case tcInitData:
	      lcd_clear();
   10980:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
		  lcd_printf(1,1,PSTR("Operation Multiply"));
   10984:	81 e0       	ldi	r24, 0x01	; 1
   10986:	61 e0       	ldi	r22, 0x01	; 1
   10988:	4c ed       	ldi	r20, 0xDC	; 220
   1098a:	55 e0       	ldi	r21, 0x05	; 5
   1098c:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		  lcd_printf(2,1,PSTR("InA:_"));
   10990:	82 e0       	ldi	r24, 0x02	; 2
   10992:	61 e0       	ldi	r22, 0x01	; 1
   10994:	46 ed       	ldi	r20, 0xD6	; 214
   10996:	55 e0       	ldi	r21, 0x05	; 5
   10998:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
   1099c:	ad e3       	ldi	r26, 0x3D	; 61
   1099e:	b2 e0       	ldi	r27, 0x02	; 2
   109a0:	fd 01       	movw	r30, r26
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
   109a2:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   109a4:	82 e0       	ldi	r24, 0x02	; 2
   109a6:	e1 35       	cpi	r30, 0x51	; 81
   109a8:	f8 07       	cpc	r31, r24
   109aa:	d9 f7       	brne	.-10     	; 0x109a2 <FTestCalculation+0x70>
   109ac:	74 97       	sbiw	r30, 0x14	; 20
	     strMemory[i]=data;
   109ae:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   109b0:	92 e0       	ldi	r25, 0x02	; 2
   109b2:	e1 35       	cpi	r30, 0x51	; 81
   109b4:	f9 07       	cpc	r31, r25
   109b6:	d9 f7       	brne	.-10     	; 0x109ae <FTestCalculation+0x7c>
	     strMemory[i]=data;
   109b8:	1d 92       	st	X+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   109ba:	82 e0       	ldi	r24, 0x02	; 2
   109bc:	a1 35       	cpi	r26, 0x51	; 81
   109be:	b8 07       	cpc	r27, r24
   109c0:	d9 f7       	brne	.-10     	; 0x109b8 <FTestCalculation+0x86>
		  lcd_printf(2,1,PSTR("InA:_"));
		  FillChar(InputA,sizeof(InputA),0);
		  FillChar(InputA,sizeof(InputB),0);
		  FillChar(InputA,sizeof(OutputC),0);

		  uiResult=USER_NONE;
   109c2:	10 92 51 02 	sts	0x0251, r1
          stTestCalc=tcInputA;
   109c6:	81 e0       	ldi	r24, 0x01	; 1
   109c8:	11 c0       	rjmp	.+34     	; 0x109ec <FTestCalculation+0xba>
	      break;
     case tcInputA:
	      uiResult=UserInput(UI_ALPHANUM_R,2,5,InputA,0,15);
   109ca:	83 e0       	ldi	r24, 0x03	; 3
   109cc:	62 e0       	ldi	r22, 0x02	; 2
   109ce:	45 e0       	ldi	r20, 0x05	; 5
   109d0:	2d e3       	ldi	r18, 0x3D	; 61
   109d2:	32 e0       	ldi	r19, 0x02	; 2
   109d4:	00 e0       	ldi	r16, 0x00	; 0
   109d6:	10 e0       	ldi	r17, 0x00	; 0
   109d8:	9f e0       	ldi	r25, 0x0F	; 15
   109da:	e9 2e       	mov	r14, r25
   109dc:	0e 94 4b 7d 	call	0xfa96	; 0xfa96 <UserInput>
   109e0:	80 93 51 02 	sts	0x0251, r24
	      if (uiResult==USER_OK)stTestCalc=tcDispInputA;
   109e4:	83 30       	cpi	r24, 0x03	; 3
   109e6:	09 f0       	breq	.+2      	; 0x109ea <FTestCalculation+0xb8>
   109e8:	a7 c0       	rjmp	.+334    	; 0x10b38 <FTestCalculation+0x206>
   109ea:	82 e0       	ldi	r24, 0x02	; 2
   109ec:	80 93 52 02 	sts	0x0252, r24
   109f0:	a3 c0       	rjmp	.+326    	; 0x10b38 <FTestCalculation+0x206>
	      break;
     case tcDispInputA:
	      sprintf_P(lcdteks,PSTR("InA:%s"),InputA);
   109f2:	00 d0       	rcall	.+0      	; 0x109f4 <FTestCalculation+0xc2>
   109f4:	00 d0       	rcall	.+0      	; 0x109f6 <FTestCalculation+0xc4>
   109f6:	00 d0       	rcall	.+0      	; 0x109f8 <FTestCalculation+0xc6>
   109f8:	ed b7       	in	r30, 0x3d	; 61
   109fa:	fe b7       	in	r31, 0x3e	; 62
   109fc:	31 96       	adiw	r30, 0x01	; 1
   109fe:	8e 01       	movw	r16, r28
   10a00:	0f 5f       	subi	r16, 0xFF	; 255
   10a02:	1f 4f       	sbci	r17, 0xFF	; 255
   10a04:	ad b7       	in	r26, 0x3d	; 61
   10a06:	be b7       	in	r27, 0x3e	; 62
   10a08:	12 96       	adiw	r26, 0x02	; 2
   10a0a:	1c 93       	st	X, r17
   10a0c:	0e 93       	st	-X, r16
   10a0e:	11 97       	sbiw	r26, 0x01	; 1
   10a10:	8f ec       	ldi	r24, 0xCF	; 207
   10a12:	95 e0       	ldi	r25, 0x05	; 5
   10a14:	93 83       	std	Z+3, r25	; 0x03
   10a16:	82 83       	std	Z+2, r24	; 0x02
   10a18:	8d e3       	ldi	r24, 0x3D	; 61
   10a1a:	92 e0       	ldi	r25, 0x02	; 2
   10a1c:	95 83       	std	Z+5, r25	; 0x05
   10a1e:	84 83       	std	Z+4, r24	; 0x04
   10a20:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
		  lcd_print(2,1,lcdteks);
   10a24:	8d b7       	in	r24, 0x3d	; 61
   10a26:	9e b7       	in	r25, 0x3e	; 62
   10a28:	06 96       	adiw	r24, 0x06	; 6
   10a2a:	0f b6       	in	r0, 0x3f	; 63
   10a2c:	f8 94       	cli
   10a2e:	9e bf       	out	0x3e, r25	; 62
   10a30:	0f be       	out	0x3f, r0	; 63
   10a32:	8d bf       	out	0x3d, r24	; 61
   10a34:	82 e0       	ldi	r24, 0x02	; 2
   10a36:	61 e0       	ldi	r22, 0x01	; 1
   10a38:	a8 01       	movw	r20, r16
   10a3a:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
		  lcd_printf(3,1,PSTR("InB:_"));
   10a3e:	83 e0       	ldi	r24, 0x03	; 3
   10a40:	61 e0       	ldi	r22, 0x01	; 1
   10a42:	49 ec       	ldi	r20, 0xC9	; 201
   10a44:	55 e0       	ldi	r21, 0x05	; 5
   10a46:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		  uiResult=USER_NONE;
   10a4a:	10 92 51 02 	sts	0x0251, r1
          stTestCalc=tcInputB;
   10a4e:	83 e0       	ldi	r24, 0x03	; 3
   10a50:	cd cf       	rjmp	.-102    	; 0x109ec <FTestCalculation+0xba>
	      break;
     case tcInputB:
	 	  uiResult=UserInput(UI_ALPHANUM_R,3,5,InputB,0,15);
   10a52:	83 e0       	ldi	r24, 0x03	; 3
   10a54:	63 e0       	ldi	r22, 0x03	; 3
   10a56:	45 e0       	ldi	r20, 0x05	; 5
   10a58:	29 e2       	ldi	r18, 0x29	; 41
   10a5a:	32 e0       	ldi	r19, 0x02	; 2
   10a5c:	00 e0       	ldi	r16, 0x00	; 0
   10a5e:	10 e0       	ldi	r17, 0x00	; 0
   10a60:	bf e0       	ldi	r27, 0x0F	; 15
   10a62:	eb 2e       	mov	r14, r27
   10a64:	0e 94 4b 7d 	call	0xfa96	; 0xfa96 <UserInput>
   10a68:	80 93 51 02 	sts	0x0251, r24
	      if (uiResult==USER_OK)stTestCalc=tcCalcualte;
   10a6c:	83 30       	cpi	r24, 0x03	; 3
   10a6e:	09 f0       	breq	.+2      	; 0x10a72 <FTestCalculation+0x140>
   10a70:	63 c0       	rjmp	.+198    	; 0x10b38 <FTestCalculation+0x206>
   10a72:	84 e0       	ldi	r24, 0x04	; 4
   10a74:	bb cf       	rjmp	.-138    	; 0x109ec <FTestCalculation+0xba>
	      break;
     case tcCalcualte:
	      sprintf_P(lcdteks,PSTR("InB:%s"),InputB);
   10a76:	00 d0       	rcall	.+0      	; 0x10a78 <FTestCalculation+0x146>
   10a78:	00 d0       	rcall	.+0      	; 0x10a7a <FTestCalculation+0x148>
   10a7a:	00 d0       	rcall	.+0      	; 0x10a7c <FTestCalculation+0x14a>
   10a7c:	ed b7       	in	r30, 0x3d	; 61
   10a7e:	fe b7       	in	r31, 0x3e	; 62
   10a80:	31 96       	adiw	r30, 0x01	; 1
   10a82:	8e 01       	movw	r16, r28
   10a84:	0f 5f       	subi	r16, 0xFF	; 255
   10a86:	1f 4f       	sbci	r17, 0xFF	; 255
   10a88:	ad b7       	in	r26, 0x3d	; 61
   10a8a:	be b7       	in	r27, 0x3e	; 62
   10a8c:	12 96       	adiw	r26, 0x02	; 2
   10a8e:	1c 93       	st	X, r17
   10a90:	0e 93       	st	-X, r16
   10a92:	11 97       	sbiw	r26, 0x01	; 1
   10a94:	82 ec       	ldi	r24, 0xC2	; 194
   10a96:	95 e0       	ldi	r25, 0x05	; 5
   10a98:	93 83       	std	Z+3, r25	; 0x03
   10a9a:	82 83       	std	Z+2, r24	; 0x02
   10a9c:	a9 e2       	ldi	r26, 0x29	; 41
   10a9e:	ea 2e       	mov	r14, r26
   10aa0:	a2 e0       	ldi	r26, 0x02	; 2
   10aa2:	fa 2e       	mov	r15, r26
   10aa4:	f5 82       	std	Z+5, r15	; 0x05
   10aa6:	e4 82       	std	Z+4, r14	; 0x04
   10aa8:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
		  lcd_print(3,1,lcdteks);
   10aac:	8d b7       	in	r24, 0x3d	; 61
   10aae:	9e b7       	in	r25, 0x3e	; 62
   10ab0:	06 96       	adiw	r24, 0x06	; 6
   10ab2:	0f b6       	in	r0, 0x3f	; 63
   10ab4:	f8 94       	cli
   10ab6:	9e bf       	out	0x3e, r25	; 62
   10ab8:	0f be       	out	0x3f, r0	; 63
   10aba:	8d bf       	out	0x3d, r24	; 61
   10abc:	83 e0       	ldi	r24, 0x03	; 3
   10abe:	61 e0       	ldi	r22, 0x01	; 1
   10ac0:	a8 01       	movw	r20, r16
   10ac2:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
		  //StrCalc(TMINUS,InputA,InputB,OutputC);
		  //StrCalc(TPLUS,InputA,InputB,OutputC);
		  StrCalc(TMULTIPLY,InputA,InputB,OutputC);
   10ac6:	f5 e1       	ldi	r31, 0x15	; 21
   10ac8:	cf 2e       	mov	r12, r31
   10aca:	f2 e0       	ldi	r31, 0x02	; 2
   10acc:	df 2e       	mov	r13, r31
   10ace:	82 e0       	ldi	r24, 0x02	; 2
   10ad0:	6d e3       	ldi	r22, 0x3D	; 61
   10ad2:	72 e0       	ldi	r23, 0x02	; 2
   10ad4:	a7 01       	movw	r20, r14
   10ad6:	96 01       	movw	r18, r12
   10ad8:	0e 94 f3 29 	call	0x53e6	; 0x53e6 <StrCalc>
	      sprintf_P(lcdteks,PSTR("A+B:%s"),OutputC);
   10adc:	00 d0       	rcall	.+0      	; 0x10ade <FTestCalculation+0x1ac>
   10ade:	00 d0       	rcall	.+0      	; 0x10ae0 <FTestCalculation+0x1ae>
   10ae0:	00 d0       	rcall	.+0      	; 0x10ae2 <FTestCalculation+0x1b0>
   10ae2:	ed b7       	in	r30, 0x3d	; 61
   10ae4:	fe b7       	in	r31, 0x3e	; 62
   10ae6:	31 96       	adiw	r30, 0x01	; 1
   10ae8:	ad b7       	in	r26, 0x3d	; 61
   10aea:	be b7       	in	r27, 0x3e	; 62
   10aec:	12 96       	adiw	r26, 0x02	; 2
   10aee:	1c 93       	st	X, r17
   10af0:	0e 93       	st	-X, r16
   10af2:	11 97       	sbiw	r26, 0x01	; 1
   10af4:	8b eb       	ldi	r24, 0xBB	; 187
   10af6:	95 e0       	ldi	r25, 0x05	; 5
   10af8:	93 83       	std	Z+3, r25	; 0x03
   10afa:	82 83       	std	Z+2, r24	; 0x02
   10afc:	d5 82       	std	Z+5, r13	; 0x05
   10afe:	c4 82       	std	Z+4, r12	; 0x04
   10b00:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
		  lcd_print(4,1,lcdteks);
   10b04:	8d b7       	in	r24, 0x3d	; 61
   10b06:	9e b7       	in	r25, 0x3e	; 62
   10b08:	06 96       	adiw	r24, 0x06	; 6
   10b0a:	0f b6       	in	r0, 0x3f	; 63
   10b0c:	f8 94       	cli
   10b0e:	9e bf       	out	0x3e, r25	; 62
   10b10:	0f be       	out	0x3f, r0	; 63
   10b12:	8d bf       	out	0x3d, r24	; 61
   10b14:	84 e0       	ldi	r24, 0x04	; 4
   10b16:	61 e0       	ldi	r22, 0x01	; 1
   10b18:	a8 01       	movw	r20, r16
   10b1a:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
          stTestCalc=tcWaitEnter;
   10b1e:	85 e0       	ldi	r24, 0x05	; 5
   10b20:	65 cf       	rjmp	.-310    	; 0x109ec <FTestCalculation+0xba>
	      break;
     case tcWaitEnter:
	      KeyChar= _key_btn(_key_scan(1));       
   10b22:	81 e0       	ldi	r24, 0x01	; 1
   10b24:	0e 94 06 b0 	call	0x1600c	; 0x1600c <_key_scan>
   10b28:	0e 94 67 af 	call	0x15ece	; 0x15ece <_key_btn>
		  if (KeyChar=='#')stTestCalc=tcInitData;
   10b2c:	83 32       	cpi	r24, 0x23	; 35
   10b2e:	11 f0       	breq	.+4      	; 0x10b34 <FTestCalculation+0x202>
		  else
		  if (KeyChar=='*')stTestCalc=tcInitData;
   10b30:	8a 32       	cpi	r24, 0x2A	; 42
   10b32:	11 f4       	brne	.+4      	; 0x10b38 <FTestCalculation+0x206>
   10b34:	10 92 52 02 	sts	0x0252, r1
	      break;	 
	 }
}
   10b38:	64 96       	adiw	r28, 0x14	; 20
   10b3a:	0f b6       	in	r0, 0x3f	; 63
   10b3c:	f8 94       	cli
   10b3e:	de bf       	out	0x3e, r29	; 62
   10b40:	0f be       	out	0x3f, r0	; 63
   10b42:	cd bf       	out	0x3d, r28	; 61
   10b44:	cf 91       	pop	r28
   10b46:	df 91       	pop	r29
   10b48:	1f 91       	pop	r17
   10b4a:	0f 91       	pop	r16
   10b4c:	ff 90       	pop	r15
   10b4e:	ef 90       	pop	r14
   10b50:	df 90       	pop	r13
   10b52:	cf 90       	pop	r12
   10b54:	08 95       	ret

00010b56 <FMenuTicket>:
	    StrResult[2]='0'+Val;
	    StrResult[3]=0;
		}   
}

char FMenuTicket(){
   10b56:	ef 92       	push	r14
   10b58:	0f 93       	push	r16
   10b5a:	1f 93       	push	r17
   10b5c:	df 93       	push	r29
   10b5e:	cf 93       	push	r28
   10b60:	cd b7       	in	r28, 0x3d	; 61
   10b62:	de b7       	in	r29, 0x3e	; 62
   10b64:	64 97       	sbiw	r28, 0x14	; 20
   10b66:	0f b6       	in	r0, 0x3f	; 63
   10b68:	f8 94       	cli
   10b6a:	de bf       	out	0x3e, r29	; 62
   10b6c:	0f be       	out	0x3f, r0	; 63
   10b6e:	cd bf       	out	0x3d, r28	; 61
static char uiResult=USER_NONE,iPos,iSend,KeyPressed,KeyChar,FIP_Used,zFIP_Used;
static unsigned int iLoop=0;
     char Result=MENU_NONE,lcdteks[20];

    Result=MENU_NONE;   
    switch(stMenuTicket){
   10b70:	80 91 d0 02 	lds	r24, 0x02D0
   10b74:	86 30       	cpi	r24, 0x06	; 6
   10b76:	09 f4       	brne	.+2      	; 0x10b7a <FMenuTicket+0x24>
   10b78:	c8 c0       	rjmp	.+400    	; 0x10d0a <FMenuTicket+0x1b4>
   10b7a:	87 30       	cpi	r24, 0x07	; 7
   10b7c:	90 f4       	brcc	.+36     	; 0x10ba2 <FMenuTicket+0x4c>
   10b7e:	82 30       	cpi	r24, 0x02	; 2
   10b80:	09 f4       	brne	.+2      	; 0x10b84 <FMenuTicket+0x2e>
   10b82:	3f c0       	rjmp	.+126    	; 0x10c02 <FMenuTicket+0xac>
   10b84:	83 30       	cpi	r24, 0x03	; 3
   10b86:	30 f4       	brcc	.+12     	; 0x10b94 <FMenuTicket+0x3e>
   10b88:	88 23       	and	r24, r24
   10b8a:	09 f1       	breq	.+66     	; 0x10bce <FMenuTicket+0x78>
   10b8c:	81 30       	cpi	r24, 0x01	; 1
   10b8e:	09 f0       	breq	.+2      	; 0x10b92 <FMenuTicket+0x3c>
   10b90:	33 c1       	rjmp	.+614    	; 0x10df8 <FMenuTicket+0x2a2>
   10b92:	1f c0       	rjmp	.+62     	; 0x10bd2 <FMenuTicket+0x7c>
   10b94:	84 30       	cpi	r24, 0x04	; 4
   10b96:	09 f4       	brne	.+2      	; 0x10b9a <FMenuTicket+0x44>
   10b98:	8d c0       	rjmp	.+282    	; 0x10cb4 <FMenuTicket+0x15e>
   10b9a:	85 30       	cpi	r24, 0x05	; 5
   10b9c:	08 f0       	brcs	.+2      	; 0x10ba0 <FMenuTicket+0x4a>
   10b9e:	af c0       	rjmp	.+350    	; 0x10cfe <FMenuTicket+0x1a8>
   10ba0:	51 c0       	rjmp	.+162    	; 0x10c44 <FMenuTicket+0xee>
   10ba2:	89 30       	cpi	r24, 0x09	; 9
   10ba4:	09 f4       	brne	.+2      	; 0x10ba8 <FMenuTicket+0x52>
   10ba6:	03 c1       	rjmp	.+518    	; 0x10dae <FMenuTicket+0x258>
   10ba8:	8a 30       	cpi	r24, 0x0A	; 10
   10baa:	38 f4       	brcc	.+14     	; 0x10bba <FMenuTicket+0x64>
   10bac:	87 30       	cpi	r24, 0x07	; 7
   10bae:	09 f4       	brne	.+2      	; 0x10bb2 <FMenuTicket+0x5c>
   10bb0:	df c0       	rjmp	.+446    	; 0x10d70 <FMenuTicket+0x21a>
   10bb2:	88 30       	cpi	r24, 0x08	; 8
   10bb4:	09 f0       	breq	.+2      	; 0x10bb8 <FMenuTicket+0x62>
   10bb6:	20 c1       	rjmp	.+576    	; 0x10df8 <FMenuTicket+0x2a2>
   10bb8:	cb c0       	rjmp	.+406    	; 0x10d50 <FMenuTicket+0x1fa>
   10bba:	8b 30       	cpi	r24, 0x0B	; 11
   10bbc:	09 f4       	brne	.+2      	; 0x10bc0 <FMenuTicket+0x6a>
   10bbe:	fd c0       	rjmp	.+506    	; 0x10dba <FMenuTicket+0x264>
   10bc0:	8b 30       	cpi	r24, 0x0B	; 11
   10bc2:	08 f4       	brcc	.+2      	; 0x10bc6 <FMenuTicket+0x70>
   10bc4:	13 c1       	rjmp	.+550    	; 0x10dec <FMenuTicket+0x296>
   10bc6:	8c 30       	cpi	r24, 0x0C	; 12
   10bc8:	09 f0       	breq	.+2      	; 0x10bcc <FMenuTicket+0x76>
   10bca:	16 c1       	rjmp	.+556    	; 0x10df8 <FMenuTicket+0x2a2>
   10bcc:	11 c1       	rjmp	.+546    	; 0x10df0 <FMenuTicket+0x29a>
	case mtInit:
		 stMenuTicket=mtPlatNo;
   10bce:	81 e0       	ldi	r24, 0x01	; 1
   10bd0:	81 c0       	rjmp	.+258    	; 0x10cd4 <FMenuTicket+0x17e>
	     break;
    case mtPlatNo:
	     lcd_clear();
   10bd2:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
	     lcd_printf(1,1,PSTR("Input Plat No: "));
   10bd6:	81 e0       	ldi	r24, 0x01	; 1
   10bd8:	61 e0       	ldi	r22, 0x01	; 1
   10bda:	4f ee       	ldi	r20, 0xEF	; 239
   10bdc:	5a e0       	ldi	r21, 0x0A	; 10
   10bde:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
	     lcd_printf(2,1,PSTR("_"));
   10be2:	82 e0       	ldi	r24, 0x02	; 2
   10be4:	61 e0       	ldi	r22, 0x01	; 1
   10be6:	4d ee       	ldi	r20, 0xED	; 237
   10be8:	5a e0       	ldi	r21, 0x0A	; 10
   10bea:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
	     lcd_printf(4,1,PSTR("[*]Cancel  [#]Enter "));
   10bee:	84 e0       	ldi	r24, 0x04	; 4
   10bf0:	61 e0       	ldi	r22, 0x01	; 1
   10bf2:	48 ed       	ldi	r20, 0xD8	; 216
   10bf4:	5a e0       	ldi	r21, 0x0A	; 10
   10bf6:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		 uiResult=USER_NONE;
   10bfa:	10 92 cf 02 	sts	0x02CF, r1
		 stMenuTicket=mtInputPlatNo;
   10bfe:	82 e0       	ldi	r24, 0x02	; 2
   10c00:	69 c0       	rjmp	.+210    	; 0x10cd4 <FMenuTicket+0x17e>
	     break;
    case mtInputPlatNo:
	     uiResult=UserInput(UI_ALPHANUM_R,2,1,strLicPlate,0,10);
   10c02:	83 e0       	ldi	r24, 0x03	; 3
   10c04:	62 e0       	ldi	r22, 0x02	; 2
   10c06:	41 e0       	ldi	r20, 0x01	; 1
   10c08:	22 ed       	ldi	r18, 0xD2	; 210
   10c0a:	3a e0       	ldi	r19, 0x0A	; 10
   10c0c:	00 e0       	ldi	r16, 0x00	; 0
   10c0e:	10 e0       	ldi	r17, 0x00	; 0
   10c10:	7a e0       	ldi	r23, 0x0A	; 10
   10c12:	e7 2e       	mov	r14, r23
   10c14:	0e 94 4b 7d 	call	0xfa96	; 0xfa96 <UserInput>
   10c18:	80 93 cf 02 	sts	0x02CF, r24
		 if (uiResult==USER_OK)stMenuTicket=mtOdometer;
   10c1c:	83 30       	cpi	r24, 0x03	; 3
   10c1e:	09 f4       	brne	.+2      	; 0x10c22 <FMenuTicket+0xcc>
   10c20:	59 c0       	rjmp	.+178    	; 0x10cd4 <FMenuTicket+0x17e>
		 else
		 if (uiResult==USER_CANCEL)stMenuTicket=mtExitMenuTicket;
   10c22:	81 30       	cpi	r24, 0x01	; 1
   10c24:	09 f4       	brne	.+2      	; 0x10c28 <FMenuTicket+0xd2>
   10c26:	e2 c0       	rjmp	.+452    	; 0x10dec <FMenuTicket+0x296>
         else
		 if (uiResult==USER_ENTRY)lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   10c28:	84 30       	cpi	r24, 0x04	; 4
   10c2a:	21 f4       	brne	.+8      	; 0x10c34 <FMenuTicket+0xde>
   10c2c:	61 e0       	ldi	r22, 0x01	; 1
   10c2e:	43 ec       	ldi	r20, 0xC3	; 195
   10c30:	5a e0       	ldi	r21, 0x0A	; 10
   10c32:	62 c0       	rjmp	.+196    	; 0x10cf8 <FMenuTicket+0x1a2>
		 else
		 if (uiResult==USER_NO_DATA)lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   10c34:	85 30       	cpi	r24, 0x05	; 5
   10c36:	09 f0       	breq	.+2      	; 0x10c3a <FMenuTicket+0xe4>
   10c38:	df c0       	rjmp	.+446    	; 0x10df8 <FMenuTicket+0x2a2>
   10c3a:	84 e0       	ldi	r24, 0x04	; 4
   10c3c:	61 e0       	ldi	r22, 0x01	; 1
   10c3e:	4e ea       	ldi	r20, 0xAE	; 174
   10c40:	5a e0       	ldi	r21, 0x0A	; 10
   10c42:	5a c0       	rjmp	.+180    	; 0x10cf8 <FMenuTicket+0x1a2>
	     break;
    case mtOdometer:
	     lcd_clear();
   10c44:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
		 sprintf_P(lcdteks,PSTR("Plat No: %s "),strLicPlate);
   10c48:	00 d0       	rcall	.+0      	; 0x10c4a <FMenuTicket+0xf4>
   10c4a:	00 d0       	rcall	.+0      	; 0x10c4c <FMenuTicket+0xf6>
   10c4c:	00 d0       	rcall	.+0      	; 0x10c4e <FMenuTicket+0xf8>
   10c4e:	ed b7       	in	r30, 0x3d	; 61
   10c50:	fe b7       	in	r31, 0x3e	; 62
   10c52:	31 96       	adiw	r30, 0x01	; 1
   10c54:	8e 01       	movw	r16, r28
   10c56:	0f 5f       	subi	r16, 0xFF	; 255
   10c58:	1f 4f       	sbci	r17, 0xFF	; 255
   10c5a:	ad b7       	in	r26, 0x3d	; 61
   10c5c:	be b7       	in	r27, 0x3e	; 62
   10c5e:	12 96       	adiw	r26, 0x02	; 2
   10c60:	1c 93       	st	X, r17
   10c62:	0e 93       	st	-X, r16
   10c64:	11 97       	sbiw	r26, 0x01	; 1
   10c66:	81 ea       	ldi	r24, 0xA1	; 161
   10c68:	9a e0       	ldi	r25, 0x0A	; 10
   10c6a:	93 83       	std	Z+3, r25	; 0x03
   10c6c:	82 83       	std	Z+2, r24	; 0x02
   10c6e:	82 ed       	ldi	r24, 0xD2	; 210
   10c70:	9a e0       	ldi	r25, 0x0A	; 10
   10c72:	95 83       	std	Z+5, r25	; 0x05
   10c74:	84 83       	std	Z+4, r24	; 0x04
   10c76:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
	     lcd_print(1,1,lcdteks);
   10c7a:	8d b7       	in	r24, 0x3d	; 61
   10c7c:	9e b7       	in	r25, 0x3e	; 62
   10c7e:	06 96       	adiw	r24, 0x06	; 6
   10c80:	0f b6       	in	r0, 0x3f	; 63
   10c82:	f8 94       	cli
   10c84:	9e bf       	out	0x3e, r25	; 62
   10c86:	0f be       	out	0x3f, r0	; 63
   10c88:	8d bf       	out	0x3d, r24	; 61
   10c8a:	81 e0       	ldi	r24, 0x01	; 1
   10c8c:	61 e0       	ldi	r22, 0x01	; 1
   10c8e:	a8 01       	movw	r20, r16
   10c90:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
	     lcd_printf(2,1,PSTR("Odometer:_ "));
   10c94:	82 e0       	ldi	r24, 0x02	; 2
   10c96:	61 e0       	ldi	r22, 0x01	; 1
   10c98:	45 e9       	ldi	r20, 0x95	; 149
   10c9a:	5a e0       	ldi	r21, 0x0A	; 10
   10c9c:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
	     lcd_printf(4,1,PSTR("[*]Cancel  [#]Enter "));
   10ca0:	84 e0       	ldi	r24, 0x04	; 4
   10ca2:	61 e0       	ldi	r22, 0x01	; 1
   10ca4:	40 e8       	ldi	r20, 0x80	; 128
   10ca6:	5a e0       	ldi	r21, 0x0A	; 10
   10ca8:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		 uiResult=USER_NONE;
   10cac:	10 92 cf 02 	sts	0x02CF, r1
		 stMenuTicket=mtInputOdometer;
   10cb0:	84 e0       	ldi	r24, 0x04	; 4
   10cb2:	10 c0       	rjmp	.+32     	; 0x10cd4 <FMenuTicket+0x17e>
	     break;
    case mtInputOdometer:
	     uiResult=UserInput(UI_NUMBER_R,2,10,strOdometer,0,10);
   10cb4:	81 e0       	ldi	r24, 0x01	; 1
   10cb6:	62 e0       	ldi	r22, 0x02	; 2
   10cb8:	4a e0       	ldi	r20, 0x0A	; 10
   10cba:	23 ea       	ldi	r18, 0xA3	; 163
   10cbc:	35 e0       	ldi	r19, 0x05	; 5
   10cbe:	00 e0       	ldi	r16, 0x00	; 0
   10cc0:	10 e0       	ldi	r17, 0x00	; 0
   10cc2:	5a e0       	ldi	r21, 0x0A	; 10
   10cc4:	e5 2e       	mov	r14, r21
   10cc6:	0e 94 4b 7d 	call	0xfa96	; 0xfa96 <UserInput>
   10cca:	80 93 cf 02 	sts	0x02CF, r24
		 if (uiResult==USER_OK)stMenuTicket=mtFIP;
   10cce:	83 30       	cpi	r24, 0x03	; 3
   10cd0:	21 f4       	brne	.+8      	; 0x10cda <FMenuTicket+0x184>
   10cd2:	85 e0       	ldi	r24, 0x05	; 5
   10cd4:	80 93 d0 02 	sts	0x02D0, r24
   10cd8:	8f c0       	rjmp	.+286    	; 0x10df8 <FMenuTicket+0x2a2>
		 else
		 if (uiResult==USER_CANCEL)stMenuTicket=mtPlatNo;
   10cda:	81 30       	cpi	r24, 0x01	; 1
   10cdc:	d9 f3       	breq	.-10     	; 0x10cd4 <FMenuTicket+0x17e>
		 else
		 if (uiResult==USER_ENTRY)lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   10cde:	84 30       	cpi	r24, 0x04	; 4
   10ce0:	21 f4       	brne	.+8      	; 0x10cea <FMenuTicket+0x194>
   10ce2:	61 e0       	ldi	r22, 0x01	; 1
   10ce4:	4b e6       	ldi	r20, 0x6B	; 107
   10ce6:	5a e0       	ldi	r21, 0x0A	; 10
   10ce8:	07 c0       	rjmp	.+14     	; 0x10cf8 <FMenuTicket+0x1a2>
		 else
		 if (uiResult==USER_NO_DATA)lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   10cea:	85 30       	cpi	r24, 0x05	; 5
   10cec:	09 f0       	breq	.+2      	; 0x10cf0 <FMenuTicket+0x19a>
   10cee:	84 c0       	rjmp	.+264    	; 0x10df8 <FMenuTicket+0x2a2>
   10cf0:	84 e0       	ldi	r24, 0x04	; 4
   10cf2:	61 e0       	ldi	r22, 0x01	; 1
   10cf4:	46 e5       	ldi	r20, 0x56	; 86
   10cf6:	5a e0       	ldi	r21, 0x0A	; 10
   10cf8:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
   10cfc:	7d c0       	rjmp	.+250    	; 0x10df8 <FMenuTicket+0x2a2>
	     break;
    case mtFIP:
	     lcd_clear();
   10cfe:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
		 _scr_pump();
   10d02:	0e 94 53 46 	call	0x8ca6	; 0x8ca6 <_scr_pump>
		 stMenuTicket=mtInputFIP;
   10d06:	86 e0       	ldi	r24, 0x06	; 6
   10d08:	e5 cf       	rjmp	.-54     	; 0x10cd4 <FMenuTicket+0x17e>
	     break;
    case mtInputFIP:
	     KeyPressed=_key_scan(1);
   10d0a:	81 e0       	ldi	r24, 0x01	; 1
   10d0c:	0e 94 06 b0 	call	0x1600c	; 0x1600c <_key_scan>
   10d10:	80 93 cc 02 	sts	0x02CC, r24
		 KeyChar=_key_btn(KeyPressed);
   10d14:	0e 94 67 af 	call	0x15ece	; 0x15ece <_key_btn>
   10d18:	80 93 cb 02 	sts	0x02CB, r24
		 if ((KeyChar>='1')&&(KeyChar<='8')){
   10d1c:	81 53       	subi	r24, 0x31	; 49
   10d1e:	88 30       	cpi	r24, 0x08	; 8
   10d20:	40 f4       	brcc	.+16     	; 0x10d32 <FMenuTicket+0x1dc>
		     FIP_Used=KeyChar-'0';
   10d22:	8f 5f       	subi	r24, 0xFF	; 255
   10d24:	80 93 ca 02 	sts	0x02CA, r24
			 zFIP_Used=FIP_Used;
   10d28:	80 93 c9 02 	sts	0x02C9, r24
		     stMenuTicket=mtSendMsg98;
   10d2c:	87 e0       	ldi	r24, 0x07	; 7
   10d2e:	80 93 d0 02 	sts	0x02D0, r24
		 }
		 if (KeyPressed==_KEY_CANCEL){
   10d32:	80 91 cc 02 	lds	r24, 0x02CC
   10d36:	87 3e       	cpi	r24, 0xE7	; 231
   10d38:	11 f4       	brne	.+4      	; 0x10d3e <FMenuTicket+0x1e8>
             stMenuTicket=mtOdometer;
   10d3a:	83 e0       	ldi	r24, 0x03	; 3
   10d3c:	cb cf       	rjmp	.-106    	; 0x10cd4 <FMenuTicket+0x17e>
		 }else
		 if (KeyPressed==_KEY_ENTER){
   10d3e:	87 3b       	cpi	r24, 0xB7	; 183
   10d40:	09 f0       	breq	.+2      	; 0x10d44 <FMenuTicket+0x1ee>
   10d42:	5a c0       	rjmp	.+180    	; 0x10df8 <FMenuTicket+0x2a2>
		     FIP_Used=zFIP_Used;
   10d44:	80 91 c9 02 	lds	r24, 0x02C9
   10d48:	80 93 ca 02 	sts	0x02CA, r24
             stMenuTicket=mtInitWaitMessage99;
   10d4c:	88 e0       	ldi	r24, 0x08	; 8
   10d4e:	c2 cf       	rjmp	.-124    	; 0x10cd4 <FMenuTicket+0x17e>
		 }
	     break;	
    case mtInitWaitMessage99:
	     lcd_clear();
   10d50:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
		 lcd_printf(2,1,PSTR("Send Request"));
   10d54:	82 e0       	ldi	r24, 0x02	; 2
   10d56:	61 e0       	ldi	r22, 0x01	; 1
   10d58:	49 e4       	ldi	r20, 0x49	; 73
   10d5a:	5a e0       	ldi	r21, 0x0A	; 10
   10d5c:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		 lcd_printf(3,1,PSTR("Proses"));
   10d60:	83 e0       	ldi	r24, 0x03	; 3
   10d62:	61 e0       	ldi	r22, 0x01	; 1
   10d64:	42 e4       	ldi	r20, 0x42	; 66
   10d66:	5a e0       	ldi	r21, 0x0A	; 10
   10d68:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
         stMenuTicket=mtSendMsg98;
   10d6c:	87 e0       	ldi	r24, 0x07	; 7
   10d6e:	b2 cf       	rjmp	.-156    	; 0x10cd4 <FMenuTicket+0x17e>
	     break;
    case mtSendMsg98:
	     iPos=0;
   10d70:	10 92 ce 02 	sts	0x02CE, r1
		 iSend=0;
   10d74:	10 92 cd 02 	sts	0x02CD, r1
		 IsMessage99=False;
   10d78:	10 92 b6 01 	sts	0x01B6, r1
		 TimSend=0;
   10d7c:	10 92 a9 01 	sts	0x01A9, r1
   10d80:	10 92 a8 01 	sts	0x01A8, r1
		 iLoop=0;
   10d84:	10 92 c8 02 	sts	0x02C8, r1
   10d88:	10 92 c7 02 	sts	0x02C7, r1
		 if (IFType==IT_SLAVE)sendMessage98(FIP_Used);
   10d8c:	80 91 10 01 	lds	r24, 0x0110
   10d90:	81 30       	cpi	r24, 0x01	; 1
   10d92:	29 f4       	brne	.+10     	; 0x10d9e <FMenuTicket+0x248>
   10d94:	80 91 ca 02 	lds	r24, 0x02CA
   10d98:	0e 94 df 4d 	call	0x9bbe	; 0x9bbe <sendMessage98>
   10d9c:	27 c0       	rjmp	.+78     	; 0x10dec <FMenuTicket+0x296>
		 else 
		 if (IFType==IT_STANDALONE)PrintStandalone(FIP_Used,False);
   10d9e:	82 30       	cpi	r24, 0x02	; 2
   10da0:	29 f5       	brne	.+74     	; 0x10dec <FMenuTicket+0x296>
   10da2:	80 91 ca 02 	lds	r24, 0x02CA
   10da6:	60 e0       	ldi	r22, 0x00	; 0
   10da8:	0e 94 97 21 	call	0x432e	; 0x432e <PrintStandalone>
   10dac:	1f c0       	rjmp	.+62     	; 0x10dec <FMenuTicket+0x296>
	                     stMenuTicket=mtSendMsg98;
				  }
			 }
		 }
		 */
		 if (IsMessage99==True){ 
   10dae:	80 91 b6 01 	lds	r24, 0x01B6
   10db2:	81 30       	cpi	r24, 0x01	; 1
   10db4:	09 f5       	brne	.+66     	; 0x10df8 <FMenuTicket+0x2a2>
		    stMenuTicket=mtMessage99Received;
   10db6:	8a e0       	ldi	r24, 0x0A	; 10
   10db8:	8d cf       	rjmp	.-230    	; 0x10cd4 <FMenuTicket+0x17e>
	     break;
    case mtMessage99Received:
	     stMenuTicket=mtExitMenuTicket;
		 break;
    case mtNoConnection:
	     lcd_clear();
   10dba:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
		 lcd_printf(2,1,PSTR("Error No Connection"));
   10dbe:	82 e0       	ldi	r24, 0x02	; 2
   10dc0:	61 e0       	ldi	r22, 0x01	; 1
   10dc2:	4e e2       	ldi	r20, 0x2E	; 46
   10dc4:	5a e0       	ldi	r21, 0x0A	; 10
   10dc6:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   10dca:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   10dcc:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   10dce:	82 e0       	ldi	r24, 0x02	; 2
   10dd0:	90 e0       	ldi	r25, 0x00	; 0
   10dd2:	90 93 d7 01 	sts	0x01D7, r25
   10dd6:	80 93 d6 01 	sts	0x01D6, r24
   10dda:	80 e2       	ldi	r24, 0x20	; 32
   10ddc:	9e e4       	ldi	r25, 0x4E	; 78
   10dde:	29 e1       	ldi	r18, 0x19	; 25
   10de0:	30 e0       	ldi	r19, 0x00	; 0
   10de2:	f9 01       	movw	r30, r18
   10de4:	31 97       	sbiw	r30, 0x01	; 1
   10de6:	f1 f7       	brne	.-4      	; 0x10de4 <FMenuTicket+0x28e>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
   10de8:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
   10dea:	d9 f7       	brne	.-10     	; 0x10de2 <FMenuTicket+0x28c>
    case mtNoConnection:
	     lcd_clear();
		 lcd_printf(2,1,PSTR("Error No Connection"));
		 system_beep(2);
		 _delay_ms(2000);
         stMenuTicket=mtExitMenuTicket;
   10dec:	8c e0       	ldi	r24, 0x0C	; 12
   10dee:	72 cf       	rjmp	.-284    	; 0x10cd4 <FMenuTicket+0x17e>
	     break;
    case mtExitMenuTicket:
	     Result=MENU_DONE;
	     stMenuTicket=mtInit;
   10df0:	10 92 d0 02 	sts	0x02D0, r1
   10df4:	81 e0       	ldi	r24, 0x01	; 1
   10df6:	01 c0       	rjmp	.+2      	; 0x10dfa <FMenuTicket+0x2a4>
   10df8:	80 e0       	ldi	r24, 0x00	; 0
	     break;
	}
  return Result;
}
   10dfa:	64 96       	adiw	r28, 0x14	; 20
   10dfc:	0f b6       	in	r0, 0x3f	; 63
   10dfe:	f8 94       	cli
   10e00:	de bf       	out	0x3e, r29	; 62
   10e02:	0f be       	out	0x3f, r0	; 63
   10e04:	cd bf       	out	0x3d, r28	; 61
   10e06:	cf 91       	pop	r28
   10e08:	df 91       	pop	r29
   10e0a:	1f 91       	pop	r17
   10e0c:	0f 91       	pop	r16
   10e0e:	ef 90       	pop	r14
   10e10:	08 95       	ret

00010e12 <FSettingOperator>:
char FSettingHost(){
     _menu_host();
	 return MENU_DONE;
}

char FSettingOperator(){//Change Active Operator, Change Password
   10e12:	ef 92       	push	r14
   10e14:	0f 93       	push	r16
   10e16:	1f 93       	push	r17
   10e18:	df 93       	push	r29
   10e1a:	cf 93       	push	r28
   10e1c:	cd b7       	in	r28, 0x3d	; 61
   10e1e:	de b7       	in	r29, 0x3e	; 62
   10e20:	e5 97       	sbiw	r28, 0x35	; 53
   10e22:	0f b6       	in	r0, 0x3f	; 63
   10e24:	f8 94       	cli
   10e26:	de bf       	out	0x3e, r29	; 62
   10e28:	0f be       	out	0x3f, r0	; 63
   10e2a:	cd bf       	out	0x3d, r28	; 61
	        char KeyPressed,KeyChar,lcdteks[20],strPassword[15];
			char strOperatorName[18];
			char uiResult=USER_NONE,Result=MENU_NONE;
     //_menu_user();
	 Result=MENU_NONE;
	 switch(stSettingOperator){
   10e2c:	80 91 e2 02 	lds	r24, 0x02E2
   10e30:	87 30       	cpi	r24, 0x07	; 7
   10e32:	09 f4       	brne	.+2      	; 0x10e36 <FSettingOperator+0x24>
   10e34:	75 c1       	rjmp	.+746    	; 0x11120 <FSettingOperator+0x30e>
   10e36:	88 30       	cpi	r24, 0x08	; 8
   10e38:	90 f4       	brcc	.+36     	; 0x10e5e <FSettingOperator+0x4c>
   10e3a:	83 30       	cpi	r24, 0x03	; 3
   10e3c:	09 f4       	brne	.+2      	; 0x10e40 <FSettingOperator+0x2e>
   10e3e:	9a c0       	rjmp	.+308    	; 0x10f74 <FSettingOperator+0x162>
   10e40:	84 30       	cpi	r24, 0x04	; 4
   10e42:	30 f4       	brcc	.+12     	; 0x10e50 <FSettingOperator+0x3e>
   10e44:	81 30       	cpi	r24, 0x01	; 1
   10e46:	a1 f1       	breq	.+104    	; 0x10eb0 <FSettingOperator+0x9e>
   10e48:	82 30       	cpi	r24, 0x02	; 2
   10e4a:	08 f0       	brcs	.+2      	; 0x10e4e <FSettingOperator+0x3c>
   10e4c:	44 c0       	rjmp	.+136    	; 0x10ed6 <FSettingOperator+0xc4>
   10e4e:	20 c0       	rjmp	.+64     	; 0x10e90 <FSettingOperator+0x7e>
   10e50:	85 30       	cpi	r24, 0x05	; 5
   10e52:	09 f4       	brne	.+2      	; 0x10e56 <FSettingOperator+0x44>
   10e54:	36 c1       	rjmp	.+620    	; 0x110c2 <FSettingOperator+0x2b0>
   10e56:	86 30       	cpi	r24, 0x06	; 6
   10e58:	08 f0       	brcs	.+2      	; 0x10e5c <FSettingOperator+0x4a>
   10e5a:	4f c1       	rjmp	.+670    	; 0x110fa <FSettingOperator+0x2e8>
   10e5c:	f9 c0       	rjmp	.+498    	; 0x11050 <FSettingOperator+0x23e>
   10e5e:	8b 30       	cpi	r24, 0x0B	; 11
   10e60:	09 f4       	brne	.+2      	; 0x10e64 <FSettingOperator+0x52>
   10e62:	20 c2       	rjmp	.+1088   	; 0x112a4 <FSettingOperator+0x492>
   10e64:	8c 30       	cpi	r24, 0x0C	; 12
   10e66:	38 f4       	brcc	.+14     	; 0x10e76 <FSettingOperator+0x64>
   10e68:	89 30       	cpi	r24, 0x09	; 9
   10e6a:	09 f4       	brne	.+2      	; 0x10e6e <FSettingOperator+0x5c>
   10e6c:	a7 c1       	rjmp	.+846    	; 0x111bc <FSettingOperator+0x3aa>
   10e6e:	8a 30       	cpi	r24, 0x0A	; 10
   10e70:	08 f0       	brcs	.+2      	; 0x10e74 <FSettingOperator+0x62>
   10e72:	d7 c1       	rjmp	.+942    	; 0x11222 <FSettingOperator+0x410>
   10e74:	75 c1       	rjmp	.+746    	; 0x11160 <FSettingOperator+0x34e>
   10e76:	8d 30       	cpi	r24, 0x0D	; 13
   10e78:	09 f4       	brne	.+2      	; 0x10e7c <FSettingOperator+0x6a>
   10e7a:	a1 c2       	rjmp	.+1346   	; 0x113be <FSettingOperator+0x5ac>
   10e7c:	8d 30       	cpi	r24, 0x0D	; 13
   10e7e:	08 f4       	brcc	.+2      	; 0x10e82 <FSettingOperator+0x70>
   10e80:	18 c2       	rjmp	.+1072   	; 0x112b2 <FSettingOperator+0x4a0>
   10e82:	8e 30       	cpi	r24, 0x0E	; 14
   10e84:	09 f4       	brne	.+2      	; 0x10e88 <FSettingOperator+0x76>
   10e86:	a0 c2       	rjmp	.+1344   	; 0x113c8 <FSettingOperator+0x5b6>
   10e88:	8f 30       	cpi	r24, 0x0F	; 15
   10e8a:	09 f0       	breq	.+2      	; 0x10e8e <FSettingOperator+0x7c>
   10e8c:	a8 c2       	rjmp	.+1360   	; 0x113de <FSettingOperator+0x5cc>
   10e8e:	a3 c2       	rjmp	.+1350   	; 0x113d6 <FSettingOperator+0x5c4>
	 case soMenuOption:
	      lcd_clear();
   10e90:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
		  lcd_printf(1,1,PSTR("1.Change Operator"));
   10e94:	81 e0       	ldi	r24, 0x01	; 1
   10e96:	61 e0       	ldi	r22, 0x01	; 1
   10e98:	48 ed       	ldi	r20, 0xD8	; 216
   10e9a:	50 e1       	ldi	r21, 0x10	; 16
   10e9c:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		  lcd_printf(2,1,PSTR("2.Change Password"));
   10ea0:	82 e0       	ldi	r24, 0x02	; 2
   10ea2:	61 e0       	ldi	r22, 0x01	; 1
   10ea4:	46 ec       	ldi	r20, 0xC6	; 198
   10ea6:	50 e1       	ldi	r21, 0x10	; 16
   10ea8:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
          stSettingOperator=soMenuOptionInput;
   10eac:	81 e0       	ldi	r24, 0x01	; 1
   10eae:	6d c2       	rjmp	.+1242   	; 0x1138a <FSettingOperator+0x578>
	      break;
     case soMenuOptionInput:
	      KeyPressed=_key_scan(1);
   10eb0:	81 e0       	ldi	r24, 0x01	; 1
   10eb2:	0e 94 06 b0 	call	0x1600c	; 0x1600c <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
   10eb6:	0e 94 67 af 	call	0x15ece	; 0x15ece <_key_btn>
		  switch(KeyChar){
   10eba:	81 33       	cpi	r24, 0x31	; 49
   10ebc:	31 f0       	breq	.+12     	; 0x10eca <FSettingOperator+0xb8>
   10ebe:	82 33       	cpi	r24, 0x32	; 50
   10ec0:	31 f0       	breq	.+12     	; 0x10ece <FSettingOperator+0xbc>
   10ec2:	8a 32       	cpi	r24, 0x2A	; 42
   10ec4:	09 f0       	breq	.+2      	; 0x10ec8 <FSettingOperator+0xb6>
   10ec6:	8b c2       	rjmp	.+1302   	; 0x113de <FSettingOperator+0x5cc>
   10ec8:	04 c0       	rjmp	.+8      	; 0x10ed2 <FSettingOperator+0xc0>
		  case '1':
		       stSettingOperator=soChangeOperatorInit;
   10eca:	82 e0       	ldi	r24, 0x02	; 2
   10ecc:	5e c2       	rjmp	.+1212   	; 0x1138a <FSettingOperator+0x578>
		       break;
          case '2':
		       stSettingOperator=soChangePasswordInit;
   10ece:	85 e0       	ldi	r24, 0x05	; 5
   10ed0:	5c c2       	rjmp	.+1208   	; 0x1138a <FSettingOperator+0x578>
		       break;
          case '*':
		       stSettingOperator=soExitSettingOperator;
   10ed2:	8f e0       	ldi	r24, 0x0F	; 15
   10ed4:	5a c2       	rjmp	.+1204   	; 0x1138a <FSettingOperator+0x578>
		       break;
		  }
	      break;
     case soChangeOperatorInit:
	      lcd_clear();		  
   10ed6:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
   10eda:	8e 01       	movw	r16, r28
   10edc:	00 5f       	subi	r16, 0xF0	; 240
   10ede:	1f 4f       	sbci	r17, 0xFF	; 255
   10ee0:	c8 01       	movw	r24, r16
   10ee2:	65 e1       	ldi	r22, 0x15	; 21
   10ee4:	70 e0       	ldi	r23, 0x00	; 0
   10ee6:	42 e1       	ldi	r20, 0x12	; 18
   10ee8:	50 e0       	ldi	r21, 0x00	; 0
   10eea:	26 ef       	ldi	r18, 0xF6	; 246
   10eec:	32 e1       	ldi	r19, 0x12	; 18
   10eee:	0e 94 7a b5 	call	0x16af4	; 0x16af4 <__eerd_block>
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   10ef2:	98 01       	movw	r18, r16
   10ef4:	ce 01       	movw	r24, r28
   10ef6:	4f 96       	adiw	r24, 0x1f	; 31
	    Dest[i]=Source[IdxSource+i];
   10ef8:	0f 5f       	subi	r16, 0xFF	; 255
   10efa:	1f 4f       	sbci	r17, 0xFF	; 255
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   10efc:	08 17       	cp	r16, r24
   10efe:	19 07       	cpc	r17, r25
   10f00:	d9 f7       	brne	.-10     	; 0x10ef8 <FSettingOperator+0xe6>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   10f02:	1f 8e       	std	Y+31, r1	; 0x1f
     case soChangeOperatorInit:
	      lcd_clear();		  
		  eeprom_read_block((void*) &strOperatorName, (const void*) &DefOperatorName,18);
		  StrPosCopy(strOperatorName,strOperatorName,0,15);

		  sprintf_P(lcdteks,PSTR("%s"),strOperatorName);
   10f04:	00 d0       	rcall	.+0      	; 0x10f06 <FSettingOperator+0xf4>
   10f06:	00 d0       	rcall	.+0      	; 0x10f08 <FSettingOperator+0xf6>
   10f08:	00 d0       	rcall	.+0      	; 0x10f0a <FSettingOperator+0xf8>
   10f0a:	ed b7       	in	r30, 0x3d	; 61
   10f0c:	fe b7       	in	r31, 0x3e	; 62
   10f0e:	31 96       	adiw	r30, 0x01	; 1
   10f10:	8e 01       	movw	r16, r28
   10f12:	0e 5d       	subi	r16, 0xDE	; 222
   10f14:	1f 4f       	sbci	r17, 0xFF	; 255
   10f16:	ad b7       	in	r26, 0x3d	; 61
   10f18:	be b7       	in	r27, 0x3e	; 62
   10f1a:	12 96       	adiw	r26, 0x02	; 2
   10f1c:	1c 93       	st	X, r17
   10f1e:	0e 93       	st	-X, r16
   10f20:	11 97       	sbiw	r26, 0x01	; 1
   10f22:	83 ec       	ldi	r24, 0xC3	; 195
   10f24:	90 e1       	ldi	r25, 0x10	; 16
   10f26:	93 83       	std	Z+3, r25	; 0x03
   10f28:	82 83       	std	Z+2, r24	; 0x02
   10f2a:	24 83       	std	Z+4, r18	; 0x04
   10f2c:	35 83       	std	Z+5, r19	; 0x05
   10f2e:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
		  lcd_printf(1,1,PSTR("Name:"));
   10f32:	8d b7       	in	r24, 0x3d	; 61
   10f34:	9e b7       	in	r25, 0x3e	; 62
   10f36:	06 96       	adiw	r24, 0x06	; 6
   10f38:	0f b6       	in	r0, 0x3f	; 63
   10f3a:	f8 94       	cli
   10f3c:	9e bf       	out	0x3e, r25	; 62
   10f3e:	0f be       	out	0x3f, r0	; 63
   10f40:	8d bf       	out	0x3d, r24	; 61
   10f42:	81 e0       	ldi	r24, 0x01	; 1
   10f44:	61 e0       	ldi	r22, 0x01	; 1
   10f46:	4d eb       	ldi	r20, 0xBD	; 189
   10f48:	50 e1       	ldi	r21, 0x10	; 16
   10f4a:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		  lcd_print (1,6,lcdteks);
   10f4e:	81 e0       	ldi	r24, 0x01	; 1
   10f50:	66 e0       	ldi	r22, 0x06	; 6
   10f52:	a8 01       	movw	r20, r16
   10f54:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
		  lcd_printf(2,1,PSTR("New :_              "));
   10f58:	82 e0       	ldi	r24, 0x02	; 2
   10f5a:	61 e0       	ldi	r22, 0x01	; 1
   10f5c:	48 ea       	ldi	r20, 0xA8	; 168
   10f5e:	50 e1       	ldi	r21, 0x10	; 16
   10f60:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		  lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   10f64:	84 e0       	ldi	r24, 0x04	; 4
   10f66:	61 e0       	ldi	r22, 0x01	; 1
   10f68:	43 e9       	ldi	r20, 0x93	; 147
   10f6a:	50 e1       	ldi	r21, 0x10	; 16
   10f6c:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
          stSettingOperator=soOperatorNameInput;
   10f70:	83 e0       	ldi	r24, 0x03	; 3
   10f72:	0b c2       	rjmp	.+1046   	; 0x1138a <FSettingOperator+0x578>
	      break;
     case soOperatorNameInput:
          uiResult=USER_NONE;
	      uiResult=UserInput(UI_ALPHANUM_R,2,6,strFreeMessageLine1,0,16);
   10f74:	83 e0       	ldi	r24, 0x03	; 3
   10f76:	62 e0       	ldi	r22, 0x02	; 2
   10f78:	46 e0       	ldi	r20, 0x06	; 6
   10f7a:	27 e9       	ldi	r18, 0x97	; 151
   10f7c:	3a e0       	ldi	r19, 0x0A	; 10
   10f7e:	00 e0       	ldi	r16, 0x00	; 0
   10f80:	10 e0       	ldi	r17, 0x00	; 0
   10f82:	b0 e1       	ldi	r27, 0x10	; 16
   10f84:	eb 2e       	mov	r14, r27
   10f86:	0e 94 4b 7d 	call	0xfa96	; 0xfa96 <UserInput>
		  switch(uiResult){
   10f8a:	83 30       	cpi	r24, 0x03	; 3
   10f8c:	51 f0       	breq	.+20     	; 0x10fa2 <FSettingOperator+0x190>
   10f8e:	84 30       	cpi	r24, 0x04	; 4
   10f90:	08 f4       	brcc	.+2      	; 0x10f94 <FSettingOperator+0x182>
   10f92:	f5 c0       	rjmp	.+490    	; 0x1117e <FSettingOperator+0x36c>
   10f94:	84 30       	cpi	r24, 0x04	; 4
   10f96:	09 f4       	brne	.+2      	; 0x10f9a <FSettingOperator+0x188>
   10f98:	51 c0       	rjmp	.+162    	; 0x1103c <FSettingOperator+0x22a>
   10f9a:	85 30       	cpi	r24, 0x05	; 5
   10f9c:	09 f0       	breq	.+2      	; 0x10fa0 <FSettingOperator+0x18e>
   10f9e:	1f c2       	rjmp	.+1086   	; 0x113de <FSettingOperator+0x5cc>
   10fa0:	52 c0       	rjmp	.+164    	; 0x11046 <FSettingOperator+0x234>
		  case USER_OK:
		       lcd_clear();
   10fa2:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
   10fa6:	20 e0       	ldi	r18, 0x00	; 0
   10fa8:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   10faa:	ae 01       	movw	r20, r28
   10fac:	40 5f       	subi	r20, 0xF0	; 240
   10fae:	5f 4f       	sbci	r21, 0xFF	; 255
   10fb0:	fa 01       	movw	r30, r20
   10fb2:	e2 0f       	add	r30, r18
   10fb4:	f3 1f       	adc	r31, r19
   10fb6:	d9 01       	movw	r26, r18
   10fb8:	a9 56       	subi	r26, 0x69	; 105
   10fba:	b5 4f       	sbci	r27, 0xF5	; 245
   10fbc:	8c 91       	ld	r24, X
   10fbe:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   10fc0:	2f 5f       	subi	r18, 0xFF	; 255
   10fc2:	3f 4f       	sbci	r19, 0xFF	; 255
   10fc4:	2f 30       	cpi	r18, 0x0F	; 15
   10fc6:	31 05       	cpc	r19, r1
   10fc8:	99 f7       	brne	.-26     	; 0x10fb0 <FSettingOperator+0x19e>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   10fca:	1f 8e       	std	Y+31, r1	; 0x1f
	      uiResult=UserInput(UI_ALPHANUM_R,2,6,strFreeMessageLine1,0,16);
		  switch(uiResult){
		  case USER_OK:
		       lcd_clear();
			   StrPosCopy(strFreeMessageLine1,strOperatorName,0,15);
		       sprintf_P(lcdteks,PSTR("%s"),strOperatorName);
   10fcc:	00 d0       	rcall	.+0      	; 0x10fce <FSettingOperator+0x1bc>
   10fce:	00 d0       	rcall	.+0      	; 0x10fd0 <FSettingOperator+0x1be>
   10fd0:	00 d0       	rcall	.+0      	; 0x10fd2 <FSettingOperator+0x1c0>
   10fd2:	ed b7       	in	r30, 0x3d	; 61
   10fd4:	fe b7       	in	r31, 0x3e	; 62
   10fd6:	31 96       	adiw	r30, 0x01	; 1
   10fd8:	8e 01       	movw	r16, r28
   10fda:	0e 5d       	subi	r16, 0xDE	; 222
   10fdc:	1f 4f       	sbci	r17, 0xFF	; 255
   10fde:	ad b7       	in	r26, 0x3d	; 61
   10fe0:	be b7       	in	r27, 0x3e	; 62
   10fe2:	12 96       	adiw	r26, 0x02	; 2
   10fe4:	1c 93       	st	X, r17
   10fe6:	0e 93       	st	-X, r16
   10fe8:	11 97       	sbiw	r26, 0x01	; 1
   10fea:	80 e9       	ldi	r24, 0x90	; 144
   10fec:	90 e1       	ldi	r25, 0x10	; 16
   10fee:	93 83       	std	Z+3, r25	; 0x03
   10ff0:	82 83       	std	Z+2, r24	; 0x02
   10ff2:	55 83       	std	Z+5, r21	; 0x05
   10ff4:	44 83       	std	Z+4, r20	; 0x04
   10ff6:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
			   lcd_printf(1,1,PSTR("New Operator:"));
   10ffa:	8d b7       	in	r24, 0x3d	; 61
   10ffc:	9e b7       	in	r25, 0x3e	; 62
   10ffe:	06 96       	adiw	r24, 0x06	; 6
   11000:	0f b6       	in	r0, 0x3f	; 63
   11002:	f8 94       	cli
   11004:	9e bf       	out	0x3e, r25	; 62
   11006:	0f be       	out	0x3f, r0	; 63
   11008:	8d bf       	out	0x3d, r24	; 61
   1100a:	81 e0       	ldi	r24, 0x01	; 1
   1100c:	61 e0       	ldi	r22, 0x01	; 1
   1100e:	42 e8       	ldi	r20, 0x82	; 130
   11010:	50 e1       	ldi	r21, 0x10	; 16
   11012:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
			   lcd_print (2,1,lcdteks);
   11016:	82 e0       	ldi	r24, 0x02	; 2
   11018:	61 e0       	ldi	r22, 0x01	; 1
   1101a:	a8 01       	movw	r20, r16
   1101c:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
			   lcd_printf(3,1,PSTR("Save?"));
   11020:	83 e0       	ldi	r24, 0x03	; 3
   11022:	61 e0       	ldi	r22, 0x01	; 1
   11024:	4c e7       	ldi	r20, 0x7C	; 124
   11026:	50 e1       	ldi	r21, 0x10	; 16
   11028:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
			   lcd_printf(4,1,PSTR("[*]No    [#]Yes"));
   1102c:	84 e0       	ldi	r24, 0x04	; 4
   1102e:	61 e0       	ldi	r22, 0x01	; 1
   11030:	4c e6       	ldi	r20, 0x6C	; 108
   11032:	50 e1       	ldi	r21, 0x10	; 16
   11034:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
               stSettingOperator=soIsSaveOperatorName;
   11038:	84 e0       	ldi	r24, 0x04	; 4
   1103a:	a7 c1       	rjmp	.+846    	; 0x1138a <FSettingOperator+0x578>
		       break;
		  case USER_CANCEL:
               stSettingOperator=soMenuOption; 
		       break;
          case USER_ENTRY:
		       lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   1103c:	84 e0       	ldi	r24, 0x04	; 4
   1103e:	61 e0       	ldi	r22, 0x01	; 1
   11040:	47 e5       	ldi	r20, 0x57	; 87
   11042:	50 e1       	ldi	r21, 0x10	; 16
   11044:	2c c1       	rjmp	.+600    	; 0x1129e <FSettingOperator+0x48c>
		       break;
          case USER_NO_DATA:
		       lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   11046:	84 e0       	ldi	r24, 0x04	; 4
   11048:	61 e0       	ldi	r22, 0x01	; 1
   1104a:	42 e4       	ldi	r20, 0x42	; 66
   1104c:	50 e1       	ldi	r21, 0x10	; 16
   1104e:	27 c1       	rjmp	.+590    	; 0x1129e <FSettingOperator+0x48c>
		       break;
		  }
	      break;
     case soIsSaveOperatorName:
          KeyPressed=_key_scan(1);
   11050:	81 e0       	ldi	r24, 0x01	; 1
   11052:	0e 94 06 b0 	call	0x1600c	; 0x1600c <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
   11056:	0e 94 67 af 	call	0x15ece	; 0x15ece <_key_btn>
		  switch(KeyChar){
   1105a:	83 32       	cpi	r24, 0x23	; 35
   1105c:	09 f0       	breq	.+2      	; 0x11060 <FSettingOperator+0x24e>
   1105e:	56 c0       	rjmp	.+172    	; 0x1110c <FSettingOperator+0x2fa>
          case '*':
		       stSettingOperator=soMenuOption;
		       break;
   11060:	20 e0       	ldi	r18, 0x00	; 0
   11062:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   11064:	8e 01       	movw	r16, r28
   11066:	00 5f       	subi	r16, 0xF0	; 240
   11068:	1f 4f       	sbci	r17, 0xFF	; 255
   1106a:	f8 01       	movw	r30, r16
   1106c:	e2 0f       	add	r30, r18
   1106e:	f3 1f       	adc	r31, r19
   11070:	d9 01       	movw	r26, r18
   11072:	a9 56       	subi	r26, 0x69	; 105
   11074:	b5 4f       	sbci	r27, 0xF5	; 245
   11076:	8c 91       	ld	r24, X
   11078:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   1107a:	2f 5f       	subi	r18, 0xFF	; 255
   1107c:	3f 4f       	sbci	r19, 0xFF	; 255
   1107e:	2f 30       	cpi	r18, 0x0F	; 15
   11080:	31 05       	cpc	r19, r1
   11082:	99 f7       	brne	.-26     	; 0x1106a <FSettingOperator+0x258>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   11084:	1f 8e       	std	Y+31, r1	; 0x1f
          case '*':
		       stSettingOperator=soMenuOption;
		       break;
          case '#':
		       StrPosCopy(strFreeMessageLine1,strOperatorName,0,15);
               AddSpaceLag(strOperatorName,18); 
   11086:	c8 01       	movw	r24, r16
   11088:	62 e1       	ldi	r22, 0x12	; 18
   1108a:	0e 94 40 2e 	call	0x5c80	; 0x5c80 <AddSpaceLag>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
   1108e:	85 e1       	ldi	r24, 0x15	; 21
   11090:	90 e0       	ldi	r25, 0x00	; 0
   11092:	b8 01       	movw	r22, r16
   11094:	42 e1       	ldi	r20, 0x12	; 18
   11096:	50 e0       	ldi	r21, 0x00	; 0
   11098:	2e ef       	ldi	r18, 0xFE	; 254
   1109a:	32 e1       	ldi	r19, 0x12	; 18
   1109c:	0e 94 96 b5 	call	0x16b2c	; 0x16b2c <__eewr_block>
		       eeprom_write_block((const void*) &strOperatorName, (void*) &DefOperatorName,18);
		       lcd_printf(3,1,PSTR("Saved "));
   110a0:	83 e0       	ldi	r24, 0x03	; 3
   110a2:	61 e0       	ldi	r22, 0x01	; 1
   110a4:	4b e3       	ldi	r20, 0x3B	; 59
   110a6:	50 e1       	ldi	r21, 0x10	; 16
   110a8:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
			   TimDisplay=0;
   110ac:	10 92 a7 01 	sts	0x01A7, r1
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   110b0:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   110b2:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   110b4:	81 e0       	ldi	r24, 0x01	; 1
   110b6:	90 e0       	ldi	r25, 0x00	; 0
   110b8:	90 93 d7 01 	sts	0x01D7, r25
   110bc:	80 93 d6 01 	sts	0x01D6, r24
   110c0:	49 c1       	rjmp	.+658    	; 0x11354 <FSettingOperator+0x542>
		       stSettingOperator=soDelayDisplaySaved;
		       break;
		  }	      
		  break;
     case soChangePasswordInit:
	      lcd_clear();
   110c2:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
		  lcd_printf(1,1,PSTR("-Change Password-"));
   110c6:	81 e0       	ldi	r24, 0x01	; 1
   110c8:	61 e0       	ldi	r22, 0x01	; 1
   110ca:	49 e2       	ldi	r20, 0x29	; 41
   110cc:	50 e1       	ldi	r21, 0x10	; 16
   110ce:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		  lcd_printf(2,1,PSTR("1.Supervisor"));
   110d2:	82 e0       	ldi	r24, 0x02	; 2
   110d4:	61 e0       	ldi	r22, 0x01	; 1
   110d6:	4c e1       	ldi	r20, 0x1C	; 28
   110d8:	50 e1       	ldi	r21, 0x10	; 16
   110da:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		  lcd_printf(3,1,PSTR("2.Administrator"));
   110de:	83 e0       	ldi	r24, 0x03	; 3
   110e0:	61 e0       	ldi	r22, 0x01	; 1
   110e2:	4c e0       	ldi	r20, 0x0C	; 12
   110e4:	50 e1       	ldi	r21, 0x10	; 16
   110e6:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		  lcd_printf(4,1,PSTR("[*]Back     "));
   110ea:	84 e0       	ldi	r24, 0x04	; 4
   110ec:	61 e0       	ldi	r22, 0x01	; 1
   110ee:	4f ef       	ldi	r20, 0xFF	; 255
   110f0:	5f e0       	ldi	r21, 0x0F	; 15
   110f2:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
          stSettingOperator=soChangePasswordInput; 
   110f6:	86 e0       	ldi	r24, 0x06	; 6
   110f8:	48 c1       	rjmp	.+656    	; 0x1138a <FSettingOperator+0x578>
	      break;
     case soChangePasswordInput:
          KeyPressed=_key_scan(1);
   110fa:	81 e0       	ldi	r24, 0x01	; 1
   110fc:	0e 94 06 b0 	call	0x1600c	; 0x1600c <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
   11100:	0e 94 67 af 	call	0x15ece	; 0x15ece <_key_btn>
		  switch(KeyChar){
   11104:	81 33       	cpi	r24, 0x31	; 49
   11106:	31 f0       	breq	.+12     	; 0x11114 <FSettingOperator+0x302>
   11108:	82 33       	cpi	r24, 0x32	; 50
   1110a:	31 f0       	breq	.+12     	; 0x11118 <FSettingOperator+0x306>
   1110c:	8a 32       	cpi	r24, 0x2A	; 42
   1110e:	09 f0       	breq	.+2      	; 0x11112 <FSettingOperator+0x300>
   11110:	66 c1       	rjmp	.+716    	; 0x113de <FSettingOperator+0x5cc>
   11112:	5e c1       	rjmp	.+700    	; 0x113d0 <FSettingOperator+0x5be>
		  case '1':		 
		       PassType=PT_SUPERVISOR;
   11114:	81 e0       	ldi	r24, 0x01	; 1
   11116:	01 c0       	rjmp	.+2      	; 0x1111a <FSettingOperator+0x308>
		       stSettingOperator=soOldPasswordDisplay;
		       break;
          case '2':		       
		       PassType=PT_ADMINISTRATOR;
   11118:	82 e0       	ldi	r24, 0x02	; 2
   1111a:	80 93 e1 02 	sts	0x02E1, r24
   1111e:	75 c0       	rjmp	.+234    	; 0x1120a <FSettingOperator+0x3f8>
		       stSettingOperator=soMenuOption;
		       break;
		  }	      
	      break;
     case soOldPasswordDisplay:
	 	  lcd_clear();
   11120:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
	      if (PassType==PT_SUPERVISOR){
   11124:	80 91 e1 02 	lds	r24, 0x02E1
   11128:	81 30       	cpi	r24, 0x01	; 1
   1112a:	21 f4       	brne	.+8      	; 0x11134 <FSettingOperator+0x322>
		      lcd_printf(1,1,PSTR("-Supervisor-"));              
   1112c:	61 e0       	ldi	r22, 0x01	; 1
   1112e:	42 ef       	ldi	r20, 0xF2	; 242
   11130:	5f e0       	ldi	r21, 0x0F	; 15
   11132:	06 c0       	rjmp	.+12     	; 0x11140 <FSettingOperator+0x32e>
		  }else if (PassType==PT_ADMINISTRATOR){		       
   11134:	82 30       	cpi	r24, 0x02	; 2
   11136:	31 f4       	brne	.+12     	; 0x11144 <FSettingOperator+0x332>
		       lcd_printf(1,1,PSTR("-Administrator-"));			   
   11138:	81 e0       	ldi	r24, 0x01	; 1
   1113a:	61 e0       	ldi	r22, 0x01	; 1
   1113c:	42 ee       	ldi	r20, 0xE2	; 226
   1113e:	5f e0       	ldi	r21, 0x0F	; 15
   11140:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		  }
		      lcd_printf(2,1,PSTR("Old:_"));
   11144:	82 e0       	ldi	r24, 0x02	; 2
   11146:	61 e0       	ldi	r22, 0x01	; 1
   11148:	4c ed       	ldi	r20, 0xDC	; 220
   1114a:	5f e0       	ldi	r21, 0x0F	; 15
   1114c:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
			  lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   11150:	84 e0       	ldi	r24, 0x04	; 4
   11152:	61 e0       	ldi	r22, 0x01	; 1
   11154:	47 ec       	ldi	r20, 0xC7	; 199
   11156:	5f e0       	ldi	r21, 0x0F	; 15
   11158:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>

          stSettingOperator=soOldPasswordEntry;
   1115c:	88 e0       	ldi	r24, 0x08	; 8
   1115e:	15 c1       	rjmp	.+554    	; 0x1138a <FSettingOperator+0x578>
	      break;
     case soOldPasswordEntry:
          uiResult=USER_NONE;
          uiResult=UserInput(UI_NUM_PASSWORD,2,5,strFreeMessageLine1,0,8);           
   11160:	84 e0       	ldi	r24, 0x04	; 4
   11162:	62 e0       	ldi	r22, 0x02	; 2
   11164:	45 e0       	ldi	r20, 0x05	; 5
   11166:	27 e9       	ldi	r18, 0x97	; 151
   11168:	3a e0       	ldi	r19, 0x0A	; 10
   1116a:	00 e0       	ldi	r16, 0x00	; 0
   1116c:	10 e0       	ldi	r17, 0x00	; 0
   1116e:	a8 e0       	ldi	r26, 0x08	; 8
   11170:	ea 2e       	mov	r14, r26
   11172:	0e 94 4b 7d 	call	0xfa96	; 0xfa96 <UserInput>
		  switch(uiResult){
   11176:	83 30       	cpi	r24, 0x03	; 3
   11178:	61 f0       	breq	.+24     	; 0x11192 <FSettingOperator+0x380>
   1117a:	84 30       	cpi	r24, 0x04	; 4
   1117c:	20 f4       	brcc	.+8      	; 0x11186 <FSettingOperator+0x374>
   1117e:	81 30       	cpi	r24, 0x01	; 1
   11180:	09 f0       	breq	.+2      	; 0x11184 <FSettingOperator+0x372>
   11182:	2d c1       	rjmp	.+602    	; 0x113de <FSettingOperator+0x5cc>
   11184:	25 c1       	rjmp	.+586    	; 0x113d0 <FSettingOperator+0x5be>
   11186:	84 30       	cpi	r24, 0x04	; 4
   11188:	79 f0       	breq	.+30     	; 0x111a8 <FSettingOperator+0x396>
   1118a:	85 30       	cpi	r24, 0x05	; 5
   1118c:	09 f0       	breq	.+2      	; 0x11190 <FSettingOperator+0x37e>
   1118e:	27 c1       	rjmp	.+590    	; 0x113de <FSettingOperator+0x5cc>
   11190:	10 c0       	rjmp	.+32     	; 0x111b2 <FSettingOperator+0x3a0>
		  case USER_OK:
		       lcd_printf(2,1,PSTR("New:_               "));
   11192:	82 e0       	ldi	r24, 0x02	; 2
   11194:	61 e0       	ldi	r22, 0x01	; 1
   11196:	42 eb       	ldi	r20, 0xB2	; 178
   11198:	5f e0       	ldi	r21, 0x0F	; 15
   1119a:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
			   lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   1119e:	84 e0       	ldi	r24, 0x04	; 4
   111a0:	61 e0       	ldi	r22, 0x01	; 1
   111a2:	4d e9       	ldi	r20, 0x9D	; 157
   111a4:	5f e0       	ldi	r21, 0x0F	; 15
   111a6:	6e c0       	rjmp	.+220    	; 0x11284 <FSettingOperator+0x472>
		       break;
		  case USER_CANCEL:
               stSettingOperator=soMenuOption; 
		       break;
          case USER_ENTRY:
		       lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   111a8:	84 e0       	ldi	r24, 0x04	; 4
   111aa:	61 e0       	ldi	r22, 0x01	; 1
   111ac:	48 e8       	ldi	r20, 0x88	; 136
   111ae:	5f e0       	ldi	r21, 0x0F	; 15
   111b0:	76 c0       	rjmp	.+236    	; 0x1129e <FSettingOperator+0x48c>
		       break;
          case USER_NO_DATA:
		       lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   111b2:	84 e0       	ldi	r24, 0x04	; 4
   111b4:	61 e0       	ldi	r22, 0x01	; 1
   111b6:	43 e7       	ldi	r20, 0x73	; 115
   111b8:	5f e0       	ldi	r21, 0x0F	; 15
   111ba:	71 c0       	rjmp	.+226    	; 0x1129e <FSettingOperator+0x48c>
		       break;
		  }
	      break;
     case soNewPasswordEntry1:
          uiResult=USER_NONE;
          uiResult=UserInput(UI_NUM_PASSWORD,2,5,strFreeMessageLine2,0,8);           
   111bc:	84 e0       	ldi	r24, 0x04	; 4
   111be:	62 e0       	ldi	r22, 0x02	; 2
   111c0:	45 e0       	ldi	r20, 0x05	; 5
   111c2:	26 e8       	ldi	r18, 0x86	; 134
   111c4:	39 e0       	ldi	r19, 0x09	; 9
   111c6:	00 e0       	ldi	r16, 0x00	; 0
   111c8:	10 e0       	ldi	r17, 0x00	; 0
   111ca:	f8 e0       	ldi	r31, 0x08	; 8
   111cc:	ef 2e       	mov	r14, r31
   111ce:	0e 94 4b 7d 	call	0xfa96	; 0xfa96 <UserInput>
		  switch(uiResult){
   111d2:	83 30       	cpi	r24, 0x03	; 3
   111d4:	61 f0       	breq	.+24     	; 0x111ee <FSettingOperator+0x3dc>
   111d6:	84 30       	cpi	r24, 0x04	; 4
   111d8:	20 f4       	brcc	.+8      	; 0x111e2 <FSettingOperator+0x3d0>
   111da:	81 30       	cpi	r24, 0x01	; 1
   111dc:	09 f0       	breq	.+2      	; 0x111e0 <FSettingOperator+0x3ce>
   111de:	ff c0       	rjmp	.+510    	; 0x113de <FSettingOperator+0x5cc>
   111e0:	14 c0       	rjmp	.+40     	; 0x1120a <FSettingOperator+0x3f8>
   111e2:	84 30       	cpi	r24, 0x04	; 4
   111e4:	a1 f0       	breq	.+40     	; 0x1120e <FSettingOperator+0x3fc>
   111e6:	85 30       	cpi	r24, 0x05	; 5
   111e8:	09 f0       	breq	.+2      	; 0x111ec <FSettingOperator+0x3da>
   111ea:	f9 c0       	rjmp	.+498    	; 0x113de <FSettingOperator+0x5cc>
   111ec:	15 c0       	rjmp	.+42     	; 0x11218 <FSettingOperator+0x406>
		  case USER_OK:
		       lcd_printf(3,1,PSTR("New:_               "));
   111ee:	83 e0       	ldi	r24, 0x03	; 3
   111f0:	61 e0       	ldi	r22, 0x01	; 1
   111f2:	4e e5       	ldi	r20, 0x5E	; 94
   111f4:	5f e0       	ldi	r21, 0x0F	; 15
   111f6:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
			   lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   111fa:	84 e0       	ldi	r24, 0x04	; 4
   111fc:	61 e0       	ldi	r22, 0x01	; 1
   111fe:	49 e4       	ldi	r20, 0x49	; 73
   11200:	5f e0       	ldi	r21, 0x0F	; 15
   11202:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		       stSettingOperator=soNewPasswordEntry2;
   11206:	8a e0       	ldi	r24, 0x0A	; 10
   11208:	c0 c0       	rjmp	.+384    	; 0x1138a <FSettingOperator+0x578>
		       break;
		  case USER_CANCEL:		       
			   stSettingOperator=soOldPasswordDisplay;
   1120a:	87 e0       	ldi	r24, 0x07	; 7
   1120c:	be c0       	rjmp	.+380    	; 0x1138a <FSettingOperator+0x578>
		       break;
          case USER_ENTRY:
		       lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   1120e:	84 e0       	ldi	r24, 0x04	; 4
   11210:	61 e0       	ldi	r22, 0x01	; 1
   11212:	44 e3       	ldi	r20, 0x34	; 52
   11214:	5f e0       	ldi	r21, 0x0F	; 15
   11216:	43 c0       	rjmp	.+134    	; 0x1129e <FSettingOperator+0x48c>
		       break;
          case USER_NO_DATA:
		       lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   11218:	84 e0       	ldi	r24, 0x04	; 4
   1121a:	61 e0       	ldi	r22, 0x01	; 1
   1121c:	4f e1       	ldi	r20, 0x1F	; 31
   1121e:	5f e0       	ldi	r21, 0x0F	; 15
   11220:	3e c0       	rjmp	.+124    	; 0x1129e <FSettingOperator+0x48c>
		       break;
		  }	      
	      break;
     case soNewPasswordEntry2:
          uiResult=USER_NONE;
          uiResult=UserInput(UI_NUM_PASSWORD,3,5,strFreeMessageLine3,0,8);           
   11222:	84 e0       	ldi	r24, 0x04	; 4
   11224:	63 e0       	ldi	r22, 0x03	; 3
   11226:	45 e0       	ldi	r20, 0x05	; 5
   11228:	21 e2       	ldi	r18, 0x21	; 33
   1122a:	3a e0       	ldi	r19, 0x0A	; 10
   1122c:	00 e0       	ldi	r16, 0x00	; 0
   1122e:	10 e0       	ldi	r17, 0x00	; 0
   11230:	e8 e0       	ldi	r30, 0x08	; 8
   11232:	ee 2e       	mov	r14, r30
   11234:	0e 94 4b 7d 	call	0xfa96	; 0xfa96 <UserInput>
		  switch(uiResult){
   11238:	83 30       	cpi	r24, 0x03	; 3
   1123a:	61 f0       	breq	.+24     	; 0x11254 <FSettingOperator+0x442>
   1123c:	84 30       	cpi	r24, 0x04	; 4
   1123e:	20 f4       	brcc	.+8      	; 0x11248 <FSettingOperator+0x436>
   11240:	81 30       	cpi	r24, 0x01	; 1
   11242:	09 f0       	breq	.+2      	; 0x11246 <FSettingOperator+0x434>
   11244:	cc c0       	rjmp	.+408    	; 0x113de <FSettingOperator+0x5cc>
   11246:	12 c0       	rjmp	.+36     	; 0x1126c <FSettingOperator+0x45a>
   11248:	84 30       	cpi	r24, 0x04	; 4
   1124a:	01 f1       	breq	.+64     	; 0x1128c <FSettingOperator+0x47a>
   1124c:	85 30       	cpi	r24, 0x05	; 5
   1124e:	09 f0       	breq	.+2      	; 0x11252 <FSettingOperator+0x440>
   11250:	c6 c0       	rjmp	.+396    	; 0x113de <FSettingOperator+0x5cc>
   11252:	21 c0       	rjmp	.+66     	; 0x11296 <FSettingOperator+0x484>
		  case USER_OK:
		       lcd_clear();
   11254:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
               lcd_printf(1,1,PSTR("Validating.."));
   11258:	81 e0       	ldi	r24, 0x01	; 1
   1125a:	61 e0       	ldi	r22, 0x01	; 1
   1125c:	42 e1       	ldi	r20, 0x12	; 18
   1125e:	5f e0       	ldi	r21, 0x0F	; 15
   11260:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
			   TimDisplay=0;
   11264:	10 92 a7 01 	sts	0x01A7, r1
		       stSettingOperator=soDispValidatePassword;
   11268:	8b e0       	ldi	r24, 0x0B	; 11
   1126a:	8f c0       	rjmp	.+286    	; 0x1138a <FSettingOperator+0x578>
		       break;
		  case USER_CANCEL:
               lcd_clear();
   1126c:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
               lcd_printf(2,1,PSTR("New:_               "));
   11270:	82 e0       	ldi	r24, 0x02	; 2
   11272:	61 e0       	ldi	r22, 0x01	; 1
   11274:	4d ef       	ldi	r20, 0xFD	; 253
   11276:	5e e0       	ldi	r21, 0x0E	; 14
   11278:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
			   lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   1127c:	84 e0       	ldi	r24, 0x04	; 4
   1127e:	61 e0       	ldi	r22, 0x01	; 1
   11280:	48 ee       	ldi	r20, 0xE8	; 232
   11282:	5e e0       	ldi	r21, 0x0E	; 14
   11284:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		       stSettingOperator=soNewPasswordEntry1;
   11288:	89 e0       	ldi	r24, 0x09	; 9
   1128a:	7f c0       	rjmp	.+254    	; 0x1138a <FSettingOperator+0x578>
		       break;
          case USER_ENTRY:
		       lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   1128c:	84 e0       	ldi	r24, 0x04	; 4
   1128e:	61 e0       	ldi	r22, 0x01	; 1
   11290:	43 ed       	ldi	r20, 0xD3	; 211
   11292:	5e e0       	ldi	r21, 0x0E	; 14
   11294:	04 c0       	rjmp	.+8      	; 0x1129e <FSettingOperator+0x48c>
		       break;
          case USER_NO_DATA:
		       lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   11296:	84 e0       	ldi	r24, 0x04	; 4
   11298:	61 e0       	ldi	r22, 0x01	; 1
   1129a:	4e eb       	ldi	r20, 0xBE	; 190
   1129c:	5e e0       	ldi	r21, 0x0E	; 14
   1129e:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
   112a2:	9d c0       	rjmp	.+314    	; 0x113de <FSettingOperator+0x5cc>
		       break;
		  }	      
	      break;
     case soDispValidatePassword:
	      if (TimDisplay>3)stSettingOperator=soValidatePassword;
   112a4:	80 91 a7 01 	lds	r24, 0x01A7
   112a8:	84 30       	cpi	r24, 0x04	; 4
   112aa:	08 f4       	brcc	.+2      	; 0x112ae <FSettingOperator+0x49c>
   112ac:	98 c0       	rjmp	.+304    	; 0x113de <FSettingOperator+0x5cc>
   112ae:	8c e0       	ldi	r24, 0x0C	; 12
   112b0:	6c c0       	rjmp	.+216    	; 0x1138a <FSettingOperator+0x578>
	      break;
     case soValidatePassword:
          if (PassType==PT_SUPERVISOR) eeprom_read_block((void*) &strPassword, (const void*) &DefSysPassword, 10);		      			   
   112b2:	80 91 e1 02 	lds	r24, 0x02E1
   112b6:	81 30       	cpi	r24, 0x01	; 1
   112b8:	29 f4       	brne	.+10     	; 0x112c4 <FSettingOperator+0x4b2>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
   112ba:	ce 01       	movw	r24, r28
   112bc:	01 96       	adiw	r24, 0x01	; 1
   112be:	6b e0       	ldi	r22, 0x0B	; 11
   112c0:	70 e0       	ldi	r23, 0x00	; 0
   112c2:	06 c0       	rjmp	.+12     	; 0x112d0 <FSettingOperator+0x4be>
		  else 
		  if (PassType==PT_ADMINISTRATOR) eeprom_read_block((void*) &strPassword, (const void*) &DefSpvPassword, 10);    
   112c4:	82 30       	cpi	r24, 0x02	; 2
   112c6:	51 f4       	brne	.+20     	; 0x112dc <FSettingOperator+0x4ca>
   112c8:	ce 01       	movw	r24, r28
   112ca:	01 96       	adiw	r24, 0x01	; 1
   112cc:	61 e0       	ldi	r22, 0x01	; 1
   112ce:	70 e0       	ldi	r23, 0x00	; 0
   112d0:	4a e0       	ldi	r20, 0x0A	; 10
   112d2:	50 e0       	ldi	r21, 0x00	; 0
   112d4:	26 ef       	ldi	r18, 0xF6	; 246
   112d6:	32 e1       	ldi	r19, 0x12	; 18
   112d8:	0e 94 7a b5 	call	0x16af4	; 0x16af4 <__eerd_block>
		  
		  //Check Old Validity
		  if (strcmp(strPassword,strFreeMessageLine1)==0){//OldMessage Valid
   112dc:	ce 01       	movw	r24, r28
   112de:	01 96       	adiw	r24, 0x01	; 1
   112e0:	67 e9       	ldi	r22, 0x97	; 151
   112e2:	7a e0       	ldi	r23, 0x0A	; 10
   112e4:	0e 94 6a b5 	call	0x16ad4	; 0x16ad4 <strcmp>
   112e8:	00 97       	sbiw	r24, 0x00	; 0
   112ea:	09 f0       	breq	.+2      	; 0x112ee <FSettingOperator+0x4dc>
   112ec:	51 c0       	rjmp	.+162    	; 0x11390 <FSettingOperator+0x57e>
              if (strcmp(strFreeMessageLine2,strFreeMessageLine3)==0){
   112ee:	86 e8       	ldi	r24, 0x86	; 134
   112f0:	99 e0       	ldi	r25, 0x09	; 9
   112f2:	61 e2       	ldi	r22, 0x21	; 33
   112f4:	7a e0       	ldi	r23, 0x0A	; 10
   112f6:	0e 94 6a b5 	call	0x16ad4	; 0x16ad4 <strcmp>
   112fa:	00 97       	sbiw	r24, 0x00	; 0
   112fc:	69 f5       	brne	.+90     	; 0x11358 <FSettingOperator+0x546>
                  
			      if (PassType==PT_SUPERVISOR) eeprom_write_block((const void*) &strFreeMessageLine2, (void*) &DefSysPassword, 10);		      			   
   112fe:	80 91 e1 02 	lds	r24, 0x02E1
   11302:	81 30       	cpi	r24, 0x01	; 1
   11304:	19 f4       	brne	.+6      	; 0x1130c <FSettingOperator+0x4fa>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
   11306:	8b e0       	ldi	r24, 0x0B	; 11
   11308:	90 e0       	ldi	r25, 0x00	; 0
   1130a:	04 c0       	rjmp	.+8      	; 0x11314 <FSettingOperator+0x502>
		          else 
		          if (PassType==PT_ADMINISTRATOR) eeprom_write_block((const void*) &strFreeMessageLine2, (void*) &DefSpvPassword, 10);    
   1130c:	82 30       	cpi	r24, 0x02	; 2
   1130e:	51 f4       	brne	.+20     	; 0x11324 <FSettingOperator+0x512>
   11310:	81 e0       	ldi	r24, 0x01	; 1
   11312:	90 e0       	ldi	r25, 0x00	; 0
   11314:	66 e8       	ldi	r22, 0x86	; 134
   11316:	79 e0       	ldi	r23, 0x09	; 9
   11318:	4a e0       	ldi	r20, 0x0A	; 10
   1131a:	50 e0       	ldi	r21, 0x00	; 0
   1131c:	2e ef       	ldi	r18, 0xFE	; 254
   1131e:	32 e1       	ldi	r19, 0x12	; 18
   11320:	0e 94 96 b5 	call	0x16b2c	; 0x16b2c <__eewr_block>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   11324:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   11326:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   11328:	81 e0       	ldi	r24, 0x01	; 1
   1132a:	90 e0       	ldi	r25, 0x00	; 0
   1132c:	90 93 d7 01 	sts	0x01D7, r25
   11330:	80 93 d6 01 	sts	0x01D6, r24
			      if (PassType==PT_SUPERVISOR) eeprom_write_block((const void*) &strFreeMessageLine2, (void*) &DefSysPassword, 10);		      			   
		          else 
		          if (PassType==PT_ADMINISTRATOR) eeprom_write_block((const void*) &strFreeMessageLine2, (void*) &DefSpvPassword, 10);    

			      system_beep(1);
				  lcd_clear();
   11334:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
			      lcd_printf(2,1,PSTR("     Completed      "));
   11338:	82 e0       	ldi	r24, 0x02	; 2
   1133a:	61 e0       	ldi	r22, 0x01	; 1
   1133c:	49 ea       	ldi	r20, 0xA9	; 169
   1133e:	5e e0       	ldi	r21, 0x0E	; 14
   11340:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
			      lcd_printf(3,1,PSTR("   Password Saved   "));    
   11344:	83 e0       	ldi	r24, 0x03	; 3
   11346:	61 e0       	ldi	r22, 0x01	; 1
   11348:	44 e9       	ldi	r20, 0x94	; 148
   1134a:	5e e0       	ldi	r21, 0x0E	; 14
   1134c:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
				  TimDisplay=0;
   11350:	10 92 a7 01 	sts	0x01A7, r1
				  stSettingOperator=soDelayDisplaySaved;
   11354:	8e e0       	ldi	r24, 0x0E	; 14
   11356:	19 c0       	rjmp	.+50     	; 0x1138a <FSettingOperator+0x578>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   11358:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   1135a:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   1135c:	82 e0       	ldi	r24, 0x02	; 2
   1135e:	90 e0       	ldi	r25, 0x00	; 0
   11360:	90 93 d7 01 	sts	0x01D7, r25
   11364:	80 93 d6 01 	sts	0x01D6, r24
			      lcd_printf(3,1,PSTR("   Password Saved   "));    
				  TimDisplay=0;
				  stSettingOperator=soDelayDisplaySaved;
			  }else {
			  system_beep(2);
		      TimDisplay=0;
   11368:	10 92 a7 01 	sts	0x01A7, r1
		      lcd_clear();
   1136c:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
		      lcd_printf(2,1,PSTR("      ERROR         "));
   11370:	82 e0       	ldi	r24, 0x02	; 2
   11372:	61 e0       	ldi	r22, 0x01	; 1
   11374:	4f e7       	ldi	r20, 0x7F	; 127
   11376:	5e e0       	ldi	r21, 0x0E	; 14
   11378:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		      lcd_printf(3,1,PSTR("Invalid New Password"));
   1137c:	83 e0       	ldi	r24, 0x03	; 3
   1137e:	61 e0       	ldi	r22, 0x01	; 1
   11380:	4a e6       	ldi	r20, 0x6A	; 106
   11382:	5e e0       	ldi	r21, 0x0E	; 14
   11384:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		      stSettingOperator=soDisplayInvalidPassword;
   11388:	8d e0       	ldi	r24, 0x0D	; 13
   1138a:	80 93 e2 02 	sts	0x02E2, r24
   1138e:	27 c0       	rjmp	.+78     	; 0x113de <FSettingOperator+0x5cc>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   11390:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   11392:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   11394:	82 e0       	ldi	r24, 0x02	; 2
   11396:	90 e0       	ldi	r25, 0x00	; 0
   11398:	90 93 d7 01 	sts	0x01D7, r25
   1139c:	80 93 d6 01 	sts	0x01D6, r24
		      stSettingOperator=soDisplayInvalidPassword;
			  }
		  }else {
		   //InvalidOld Password
		   system_beep(2);
		   TimDisplay=0;
   113a0:	10 92 a7 01 	sts	0x01A7, r1
		   lcd_clear();
   113a4:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
		   lcd_printf(2,1,PSTR("      ERROR         "));
   113a8:	82 e0       	ldi	r24, 0x02	; 2
   113aa:	61 e0       	ldi	r22, 0x01	; 1
   113ac:	45 e5       	ldi	r20, 0x55	; 85
   113ae:	5e e0       	ldi	r21, 0x0E	; 14
   113b0:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		   lcd_printf(3,1,PSTR("Invalid Old Password"));
   113b4:	83 e0       	ldi	r24, 0x03	; 3
   113b6:	61 e0       	ldi	r22, 0x01	; 1
   113b8:	40 e4       	ldi	r20, 0x40	; 64
   113ba:	5e e0       	ldi	r21, 0x0E	; 14
   113bc:	e3 cf       	rjmp	.-58     	; 0x11384 <FSettingOperator+0x572>
		   stSettingOperator=soDisplayInvalidPassword;
		   }
	      break;
     case soDisplayInvalidPassword:
	      if (TimDisplay>6)stSettingOperator=soMenuOption;
   113be:	80 91 a7 01 	lds	r24, 0x01A7
   113c2:	87 30       	cpi	r24, 0x07	; 7
   113c4:	60 f0       	brcs	.+24     	; 0x113de <FSettingOperator+0x5cc>
   113c6:	04 c0       	rjmp	.+8      	; 0x113d0 <FSettingOperator+0x5be>
	      break;
     case soDelayDisplaySaved:
	      if (TimDisplay>4)stSettingOperator=soMenuOption;
   113c8:	80 91 a7 01 	lds	r24, 0x01A7
   113cc:	85 30       	cpi	r24, 0x05	; 5
   113ce:	38 f0       	brcs	.+14     	; 0x113de <FSettingOperator+0x5cc>
   113d0:	10 92 e2 02 	sts	0x02E2, r1
   113d4:	04 c0       	rjmp	.+8      	; 0x113de <FSettingOperator+0x5cc>
	      break;
	 case soExitSettingOperator:
	      stSettingOperator=soMenuOption;
   113d6:	10 92 e2 02 	sts	0x02E2, r1
   113da:	81 e0       	ldi	r24, 0x01	; 1
   113dc:	01 c0       	rjmp	.+2      	; 0x113e0 <FSettingOperator+0x5ce>
   113de:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
     return Result;
}
   113e0:	e5 96       	adiw	r28, 0x35	; 53
   113e2:	0f b6       	in	r0, 0x3f	; 63
   113e4:	f8 94       	cli
   113e6:	de bf       	out	0x3e, r29	; 62
   113e8:	0f be       	out	0x3f, r0	; 63
   113ea:	cd bf       	out	0x3d, r28	; 61
   113ec:	cf 91       	pop	r28
   113ee:	df 91       	pop	r29
   113f0:	1f 91       	pop	r17
   113f2:	0f 91       	pop	r16
   113f4:	ef 90       	pop	r14
   113f6:	08 95       	ret

000113f8 <FSettingProduct>:

void menu_product(){

}

char FSettingProduct(){//Using strDescription
   113f8:	6f 92       	push	r6
   113fa:	7f 92       	push	r7
   113fc:	8f 92       	push	r8
   113fe:	9f 92       	push	r9
   11400:	af 92       	push	r10
   11402:	bf 92       	push	r11
   11404:	cf 92       	push	r12
   11406:	df 92       	push	r13
   11408:	ef 92       	push	r14
   1140a:	ff 92       	push	r15
   1140c:	0f 93       	push	r16
   1140e:	1f 93       	push	r17
   11410:	df 93       	push	r29
   11412:	cf 93       	push	r28
   11414:	cd b7       	in	r28, 0x3d	; 61
   11416:	de b7       	in	r29, 0x3e	; 62
   11418:	a1 97       	sbiw	r28, 0x21	; 33
   1141a:	0f b6       	in	r0, 0x3f	; 63
   1141c:	f8 94       	cli
   1141e:	de bf       	out	0x3e, r29	; 62
   11420:	0f be       	out	0x3f, r0	; 63
   11422:	cd bf       	out	0x3d, r28	; 61
     char i;//,x,y;
	 char strProductName[13],lcdteks[20];
	 char Result=MENU_NONE;
	 
     Result=MENU_NONE;
     switch(stMenuProduct){
   11424:	80 91 ef 02 	lds	r24, 0x02EF
   11428:	83 30       	cpi	r24, 0x03	; 3
   1142a:	09 f4       	brne	.+2      	; 0x1142e <FSettingProduct+0x36>
   1142c:	ff c0       	rjmp	.+510    	; 0x1162c <FSettingProduct+0x234>
   1142e:	84 30       	cpi	r24, 0x04	; 4
   11430:	38 f4       	brcc	.+14     	; 0x11440 <FSettingProduct+0x48>
   11432:	81 30       	cpi	r24, 0x01	; 1
   11434:	09 f4       	brne	.+2      	; 0x11438 <FSettingProduct+0x40>
   11436:	72 c0       	rjmp	.+228    	; 0x1151c <FSettingProduct+0x124>
   11438:	82 30       	cpi	r24, 0x02	; 2
   1143a:	08 f0       	brcs	.+2      	; 0x1143e <FSettingProduct+0x46>
   1143c:	82 c0       	rjmp	.+260    	; 0x11542 <FSettingProduct+0x14a>
   1143e:	0a c0       	rjmp	.+20     	; 0x11454 <FSettingProduct+0x5c>
   11440:	85 30       	cpi	r24, 0x05	; 5
   11442:	09 f4       	brne	.+2      	; 0x11446 <FSettingProduct+0x4e>
   11444:	83 c1       	rjmp	.+774    	; 0x1174c <FSettingProduct+0x354>
   11446:	85 30       	cpi	r24, 0x05	; 5
   11448:	08 f4       	brcc	.+2      	; 0x1144c <FSettingProduct+0x54>
   1144a:	a2 c1       	rjmp	.+836    	; 0x11790 <FSettingProduct+0x398>
   1144c:	86 30       	cpi	r24, 0x06	; 6
   1144e:	09 f0       	breq	.+2      	; 0x11452 <FSettingProduct+0x5a>
   11450:	c9 c1       	rjmp	.+914    	; 0x117e4 <FSettingProduct+0x3ec>
   11452:	c4 c1       	rjmp	.+904    	; 0x117dc <FSettingProduct+0x3e4>
	 case mpInitProduct:
	      //DisplayProductName
		  lcd_clear();
   11454:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
   11458:	bb eb       	ldi	r27, 0xBB	; 187
   1145a:	cb 2e       	mov	r12, r27
   1145c:	b0 e0       	ldi	r27, 0x00	; 0
   1145e:	db 2e       	mov	r13, r27
   11460:	a1 e0       	ldi	r26, 0x01	; 1
   11462:	ea 2e       	mov	r14, r26
   11464:	f1 2c       	mov	r15, r1
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
   11466:	4e 01       	movw	r8, r28
   11468:	08 94       	sec
   1146a:	81 1c       	adc	r8, r1
   1146c:	91 1c       	adc	r9, r1
		  //lcd_printf(1,1,PSTR("Product:"));
	      for(i=0;i<6;i++){//234 
	          eeprom_read_block((void*) &strProductName, (const void*) &DefProductName[i], 13);
	          sprintf_P(lcdteks,PSTR("%d)%s"),(i+1),strProductName);
   1146e:	fe e0       	ldi	r31, 0x0E	; 14
   11470:	af 2e       	mov	r10, r31
   11472:	b1 2c       	mov	r11, r1
   11474:	ac 0e       	add	r10, r28
   11476:	bd 1e       	adc	r11, r29
   11478:	ef e0       	ldi	r30, 0x0F	; 15
   1147a:	6e 2e       	mov	r6, r30
   1147c:	e2 e1       	ldi	r30, 0x12	; 18
   1147e:	7e 2e       	mov	r7, r30
			  lcd_print((((i)%4)+1),(((i)/4)*10)+1,lcdteks);
   11480:	0a e0       	ldi	r16, 0x0A	; 10
	 
     Result=MENU_NONE;
     switch(stMenuProduct){
	 case mpInitProduct:
	      //DisplayProductName
		  lcd_clear();
   11482:	1e 2d       	mov	r17, r14
   11484:	11 50       	subi	r17, 0x01	; 1
   11486:	c4 01       	movw	r24, r8
   11488:	b6 01       	movw	r22, r12
   1148a:	4d e0       	ldi	r20, 0x0D	; 13
   1148c:	50 e0       	ldi	r21, 0x00	; 0
   1148e:	26 ef       	ldi	r18, 0xF6	; 246
   11490:	32 e1       	ldi	r19, 0x12	; 18
   11492:	0e 94 7a b5 	call	0x16af4	; 0x16af4 <__eerd_block>
		  //lcd_printf(1,1,PSTR("Product:"));
	      for(i=0;i<6;i++){//234 
	          eeprom_read_block((void*) &strProductName, (const void*) &DefProductName[i], 13);
	          sprintf_P(lcdteks,PSTR("%d)%s"),(i+1),strProductName);
   11496:	8d b7       	in	r24, 0x3d	; 61
   11498:	9e b7       	in	r25, 0x3e	; 62
   1149a:	08 97       	sbiw	r24, 0x08	; 8
   1149c:	0f b6       	in	r0, 0x3f	; 63
   1149e:	f8 94       	cli
   114a0:	9e bf       	out	0x3e, r25	; 62
   114a2:	0f be       	out	0x3f, r0	; 63
   114a4:	8d bf       	out	0x3d, r24	; 61
   114a6:	ed b7       	in	r30, 0x3d	; 61
   114a8:	fe b7       	in	r31, 0x3e	; 62
   114aa:	31 96       	adiw	r30, 0x01	; 1
   114ac:	ad b7       	in	r26, 0x3d	; 61
   114ae:	be b7       	in	r27, 0x3e	; 62
   114b0:	12 96       	adiw	r26, 0x02	; 2
   114b2:	bc 92       	st	X, r11
   114b4:	ae 92       	st	-X, r10
   114b6:	11 97       	sbiw	r26, 0x01	; 1
   114b8:	73 82       	std	Z+3, r7	; 0x03
   114ba:	62 82       	std	Z+2, r6	; 0x02
   114bc:	f5 82       	std	Z+5, r15	; 0x05
   114be:	e4 82       	std	Z+4, r14	; 0x04
   114c0:	97 82       	std	Z+7, r9	; 0x07
   114c2:	86 82       	std	Z+6, r8	; 0x06
   114c4:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
			  lcd_print((((i)%4)+1),(((i)/4)*10)+1,lcdteks);
   114c8:	8d b7       	in	r24, 0x3d	; 61
   114ca:	9e b7       	in	r25, 0x3e	; 62
   114cc:	08 96       	adiw	r24, 0x08	; 8
   114ce:	0f b6       	in	r0, 0x3f	; 63
   114d0:	f8 94       	cli
   114d2:	9e bf       	out	0x3e, r25	; 62
   114d4:	0f be       	out	0x3f, r0	; 63
   114d6:	8d bf       	out	0x3d, r24	; 61
   114d8:	61 2f       	mov	r22, r17
   114da:	66 95       	lsr	r22
   114dc:	66 95       	lsr	r22
   114de:	60 9f       	mul	r22, r16
   114e0:	b0 01       	movw	r22, r0
   114e2:	11 24       	eor	r1, r1
   114e4:	6f 5f       	subi	r22, 0xFF	; 255
   114e6:	13 70       	andi	r17, 0x03	; 3
   114e8:	81 2f       	mov	r24, r17
   114ea:	8f 5f       	subi	r24, 0xFF	; 255
   114ec:	a5 01       	movw	r20, r10
   114ee:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
   114f2:	ad e0       	ldi	r26, 0x0D	; 13
   114f4:	b0 e0       	ldi	r27, 0x00	; 0
   114f6:	ca 0e       	add	r12, r26
   114f8:	db 1e       	adc	r13, r27
   114fa:	08 94       	sec
   114fc:	e1 1c       	adc	r14, r1
   114fe:	f1 1c       	adc	r15, r1
     switch(stMenuProduct){
	 case mpInitProduct:
	      //DisplayProductName
		  lcd_clear();
		  //lcd_printf(1,1,PSTR("Product:"));
	      for(i=0;i<6;i++){//234 
   11500:	b9 e0       	ldi	r27, 0x09	; 9
   11502:	cb 16       	cp	r12, r27
   11504:	b1 e0       	ldi	r27, 0x01	; 1
   11506:	db 06       	cpc	r13, r27
   11508:	09 f0       	breq	.+2      	; 0x1150c <FSettingProduct+0x114>
   1150a:	bb cf       	rjmp	.-138    	; 0x11482 <FSettingProduct+0x8a>
	          eeprom_read_block((void*) &strProductName, (const void*) &DefProductName[i], 13);
	          sprintf_P(lcdteks,PSTR("%d)%s"),(i+1),strProductName);
			  lcd_print((((i)%4)+1),(((i)/4)*10)+1,lcdteks);
		  }
		  lcd_printf(4,11,PSTR("*)Back"));
   1150c:	84 e0       	ldi	r24, 0x04	; 4
   1150e:	6b e0       	ldi	r22, 0x0B	; 11
   11510:	48 e0       	ldi	r20, 0x08	; 8
   11512:	52 e1       	ldi	r21, 0x12	; 18
   11514:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
          stMenuProduct=mpChangeProduct;
   11518:	81 e0       	ldi	r24, 0x01	; 1
   1151a:	5a c1       	rjmp	.+692    	; 0x117d0 <FSettingProduct+0x3d8>
	      break;
     case mpChangeProduct:
		  KeyPressed=_key_scan(1);
   1151c:	81 e0       	ldi	r24, 0x01	; 1
   1151e:	0e 94 06 b0 	call	0x1600c	; 0x1600c <_key_scan>
   11522:	18 2f       	mov	r17, r24
		  KeyChar=_key_btn(KeyPressed);
   11524:	0e 94 67 af 	call	0x15ece	; 0x15ece <_key_btn>
		  if ((KeyChar>='1')&&(KeyChar<='6')){
   11528:	81 53       	subi	r24, 0x31	; 49
   1152a:	86 30       	cpi	r24, 0x06	; 6
   1152c:	28 f4       	brcc	.+10     	; 0x11538 <FSettingProduct+0x140>
		      ProdID=KeyChar-'1';
   1152e:	80 93 ee 02 	sts	0x02EE, r24
			  stMenuProduct=mpDispPrice;
   11532:	82 e0       	ldi	r24, 0x02	; 2
   11534:	80 93 ef 02 	sts	0x02EF, r24
		  }
		  if (KeyPressed==_KEY_CANCEL){
   11538:	17 3e       	cpi	r17, 0xE7	; 231
   1153a:	09 f0       	breq	.+2      	; 0x1153e <FSettingProduct+0x146>
   1153c:	53 c1       	rjmp	.+678    	; 0x117e4 <FSettingProduct+0x3ec>
		      stMenuProduct=mpExitMenuProduct;
   1153e:	86 e0       	ldi	r24, 0x06	; 6
   11540:	47 c1       	rjmp	.+654    	; 0x117d0 <FSettingProduct+0x3d8>
   11542:	60 91 ee 02 	lds	r22, 0x02EE
   11546:	8d e0       	ldi	r24, 0x0D	; 13
   11548:	68 9f       	mul	r22, r24
   1154a:	b0 01       	movw	r22, r0
   1154c:	11 24       	eor	r1, r1
   1154e:	65 54       	subi	r22, 0x45	; 69
   11550:	7f 4f       	sbci	r23, 0xFF	; 255
   11552:	7e 01       	movw	r14, r28
   11554:	08 94       	sec
   11556:	e1 1c       	adc	r14, r1
   11558:	f1 1c       	adc	r15, r1
   1155a:	c7 01       	movw	r24, r14
   1155c:	4d e0       	ldi	r20, 0x0D	; 13
   1155e:	50 e0       	ldi	r21, 0x00	; 0
   11560:	26 ef       	ldi	r18, 0xF6	; 246
   11562:	32 e1       	ldi	r19, 0x12	; 18
   11564:	0e 94 7a b5 	call	0x16af4	; 0x16af4 <__eerd_block>
		  }
	      break;
     case mpDispPrice:
	 	  eeprom_read_block((void*) &strProductName, (const void*) &DefProductName[ProdID], 13);
		  eeprom_read_block((void*) &strPrice, (const void*) &DefProductPrice[ProdID], 9);
		  sprintf_P(lcdteks,PSTR("1)%s"),strProductName);
   11568:	74 ee       	ldi	r23, 0xE4	; 228
   1156a:	c7 2e       	mov	r12, r23
   1156c:	72 e0       	ldi	r23, 0x02	; 2
   1156e:	d7 2e       	mov	r13, r23
   11570:	60 91 ee 02 	lds	r22, 0x02EE
   11574:	89 e0       	ldi	r24, 0x09	; 9
   11576:	68 9f       	mul	r22, r24
   11578:	b0 01       	movw	r22, r0
   1157a:	11 24       	eor	r1, r1
   1157c:	6b 57       	subi	r22, 0x7B	; 123
   1157e:	7f 4f       	sbci	r23, 0xFF	; 255
   11580:	c6 01       	movw	r24, r12
   11582:	49 e0       	ldi	r20, 0x09	; 9
   11584:	50 e0       	ldi	r21, 0x00	; 0
   11586:	26 ef       	ldi	r18, 0xF6	; 246
   11588:	32 e1       	ldi	r19, 0x12	; 18
   1158a:	0e 94 7a b5 	call	0x16af4	; 0x16af4 <__eerd_block>
   1158e:	00 d0       	rcall	.+0      	; 0x11590 <FSettingProduct+0x198>
   11590:	00 d0       	rcall	.+0      	; 0x11592 <FSettingProduct+0x19a>
   11592:	00 d0       	rcall	.+0      	; 0x11594 <FSettingProduct+0x19c>
   11594:	ed b7       	in	r30, 0x3d	; 61
   11596:	fe b7       	in	r31, 0x3e	; 62
   11598:	31 96       	adiw	r30, 0x01	; 1
   1159a:	8e 01       	movw	r16, r28
   1159c:	02 5f       	subi	r16, 0xF2	; 242
   1159e:	1f 4f       	sbci	r17, 0xFF	; 255
   115a0:	ad b7       	in	r26, 0x3d	; 61
   115a2:	be b7       	in	r27, 0x3e	; 62
   115a4:	12 96       	adiw	r26, 0x02	; 2
   115a6:	1c 93       	st	X, r17
   115a8:	0e 93       	st	-X, r16
   115aa:	11 97       	sbiw	r26, 0x01	; 1
   115ac:	83 e0       	ldi	r24, 0x03	; 3
   115ae:	92 e1       	ldi	r25, 0x12	; 18
   115b0:	93 83       	std	Z+3, r25	; 0x03
   115b2:	82 83       	std	Z+2, r24	; 0x02
   115b4:	f5 82       	std	Z+5, r15	; 0x05
   115b6:	e4 82       	std	Z+4, r14	; 0x04
   115b8:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
		  lcd_clear();lcd_print(1,1,lcdteks);
   115bc:	8d b7       	in	r24, 0x3d	; 61
   115be:	9e b7       	in	r25, 0x3e	; 62
   115c0:	06 96       	adiw	r24, 0x06	; 6
   115c2:	0f b6       	in	r0, 0x3f	; 63
   115c4:	f8 94       	cli
   115c6:	9e bf       	out	0x3e, r25	; 62
   115c8:	0f be       	out	0x3f, r0	; 63
   115ca:	8d bf       	out	0x3d, r24	; 61
   115cc:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
   115d0:	81 e0       	ldi	r24, 0x01	; 1
   115d2:	61 e0       	ldi	r22, 0x01	; 1
   115d4:	a8 01       	movw	r20, r16
   115d6:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
		  sprintf_P(lcdteks,PSTR("2)%s"),strPrice);
   115da:	00 d0       	rcall	.+0      	; 0x115dc <FSettingProduct+0x1e4>
   115dc:	00 d0       	rcall	.+0      	; 0x115de <FSettingProduct+0x1e6>
   115de:	00 d0       	rcall	.+0      	; 0x115e0 <FSettingProduct+0x1e8>
   115e0:	ed b7       	in	r30, 0x3d	; 61
   115e2:	fe b7       	in	r31, 0x3e	; 62
   115e4:	31 96       	adiw	r30, 0x01	; 1
   115e6:	ad b7       	in	r26, 0x3d	; 61
   115e8:	be b7       	in	r27, 0x3e	; 62
   115ea:	12 96       	adiw	r26, 0x02	; 2
   115ec:	1c 93       	st	X, r17
   115ee:	0e 93       	st	-X, r16
   115f0:	11 97       	sbiw	r26, 0x01	; 1
   115f2:	8e ef       	ldi	r24, 0xFE	; 254
   115f4:	91 e1       	ldi	r25, 0x11	; 17
   115f6:	93 83       	std	Z+3, r25	; 0x03
   115f8:	82 83       	std	Z+2, r24	; 0x02
   115fa:	d5 82       	std	Z+5, r13	; 0x05
   115fc:	c4 82       	std	Z+4, r12	; 0x04
   115fe:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
		  lcd_print(2,1,lcdteks);
   11602:	8d b7       	in	r24, 0x3d	; 61
   11604:	9e b7       	in	r25, 0x3e	; 62
   11606:	06 96       	adiw	r24, 0x06	; 6
   11608:	0f b6       	in	r0, 0x3f	; 63
   1160a:	f8 94       	cli
   1160c:	9e bf       	out	0x3e, r25	; 62
   1160e:	0f be       	out	0x3f, r0	; 63
   11610:	8d bf       	out	0x3d, r24	; 61
   11612:	82 e0       	ldi	r24, 0x02	; 2
   11614:	61 e0       	ldi	r22, 0x01	; 1
   11616:	a8 01       	movw	r20, r16
   11618:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
		  lcd_printf(4,1,PSTR("*)Back       "));
   1161c:	84 e0       	ldi	r24, 0x04	; 4
   1161e:	61 e0       	ldi	r22, 0x01	; 1
   11620:	40 ef       	ldi	r20, 0xF0	; 240
   11622:	51 e1       	ldi	r21, 0x11	; 17
   11624:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		  stMenuProduct=mpIsEdit;
   11628:	83 e0       	ldi	r24, 0x03	; 3
   1162a:	d2 c0       	rjmp	.+420    	; 0x117d0 <FSettingProduct+0x3d8>
	      break;
     case mpIsEdit:
		  KeyPressed=_key_scan(1);
   1162c:	81 e0       	ldi	r24, 0x01	; 1
   1162e:	0e 94 06 b0 	call	0x1600c	; 0x1600c <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
   11632:	0e 94 67 af 	call	0x15ece	; 0x15ece <_key_btn>
		  if (KeyChar=='*'){
   11636:	8a 32       	cpi	r24, 0x2A	; 42
   11638:	09 f4       	brne	.+2      	; 0x1163c <FSettingProduct+0x244>
   1163a:	a7 c0       	rjmp	.+334    	; 0x1178a <FSettingProduct+0x392>
		      stMenuProduct=mpInitProduct;
		  }else
		  if (KeyChar=='1'){
   1163c:	81 33       	cpi	r24, 0x31	; 49
   1163e:	09 f0       	breq	.+2      	; 0x11642 <FSettingProduct+0x24a>
   11640:	4c c0       	rjmp	.+152    	; 0x116da <FSettingProduct+0x2e2>
   11642:	60 91 ee 02 	lds	r22, 0x02EE
   11646:	8d e0       	ldi	r24, 0x0D	; 13
   11648:	68 9f       	mul	r22, r24
   1164a:	b0 01       	movw	r22, r0
   1164c:	11 24       	eor	r1, r1
   1164e:	65 54       	subi	r22, 0x45	; 69
   11650:	7f 4f       	sbci	r23, 0xFF	; 255
   11652:	8e 01       	movw	r16, r28
   11654:	0f 5f       	subi	r16, 0xFF	; 255
   11656:	1f 4f       	sbci	r17, 0xFF	; 255
   11658:	c8 01       	movw	r24, r16
   1165a:	4d e0       	ldi	r20, 0x0D	; 13
   1165c:	50 e0       	ldi	r21, 0x00	; 0
   1165e:	26 ef       	ldi	r18, 0xF6	; 246
   11660:	32 e1       	ldi	r19, 0x12	; 18
   11662:	0e 94 7a b5 	call	0x16af4	; 0x16af4 <__eerd_block>
		      eeprom_read_block((void*) &strProductName, (const void*) &DefProductName[ProdID], 13);
		      sprintf_P(lcdteks,PSTR("Old:%s"),strProductName);
   11666:	00 d0       	rcall	.+0      	; 0x11668 <FSettingProduct+0x270>
   11668:	00 d0       	rcall	.+0      	; 0x1166a <FSettingProduct+0x272>
   1166a:	00 d0       	rcall	.+0      	; 0x1166c <FSettingProduct+0x274>
   1166c:	ed b7       	in	r30, 0x3d	; 61
   1166e:	fe b7       	in	r31, 0x3e	; 62
   11670:	31 96       	adiw	r30, 0x01	; 1
   11672:	6e e0       	ldi	r22, 0x0E	; 14
   11674:	e6 2e       	mov	r14, r22
   11676:	f1 2c       	mov	r15, r1
   11678:	ec 0e       	add	r14, r28
   1167a:	fd 1e       	adc	r15, r29
   1167c:	ad b7       	in	r26, 0x3d	; 61
   1167e:	be b7       	in	r27, 0x3e	; 62
   11680:	12 96       	adiw	r26, 0x02	; 2
   11682:	fc 92       	st	X, r15
   11684:	ee 92       	st	-X, r14
   11686:	11 97       	sbiw	r26, 0x01	; 1
   11688:	89 ee       	ldi	r24, 0xE9	; 233
   1168a:	91 e1       	ldi	r25, 0x11	; 17
   1168c:	93 83       	std	Z+3, r25	; 0x03
   1168e:	82 83       	std	Z+2, r24	; 0x02
   11690:	15 83       	std	Z+5, r17	; 0x05
   11692:	04 83       	std	Z+4, r16	; 0x04
   11694:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
			  lcd_printf(1,1,PSTR("Edit Product Name   "));
   11698:	8d b7       	in	r24, 0x3d	; 61
   1169a:	9e b7       	in	r25, 0x3e	; 62
   1169c:	06 96       	adiw	r24, 0x06	; 6
   1169e:	0f b6       	in	r0, 0x3f	; 63
   116a0:	f8 94       	cli
   116a2:	9e bf       	out	0x3e, r25	; 62
   116a4:	0f be       	out	0x3f, r0	; 63
   116a6:	8d bf       	out	0x3d, r24	; 61
   116a8:	81 e0       	ldi	r24, 0x01	; 1
   116aa:	61 e0       	ldi	r22, 0x01	; 1
   116ac:	44 ed       	ldi	r20, 0xD4	; 212
   116ae:	51 e1       	ldi	r21, 0x11	; 17
   116b0:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		       lcd_print(2,1,lcdteks);
   116b4:	82 e0       	ldi	r24, 0x02	; 2
   116b6:	61 e0       	ldi	r22, 0x01	; 1
   116b8:	a7 01       	movw	r20, r14
   116ba:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
			  lcd_printf(3,1,PSTR("New:_"));
   116be:	83 e0       	ldi	r24, 0x03	; 3
   116c0:	61 e0       	ldi	r22, 0x01	; 1
   116c2:	4e ec       	ldi	r20, 0xCE	; 206
   116c4:	51 e1       	ldi	r21, 0x11	; 17
   116c6:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		      lcd_printf(4,1,PSTR("*)Back    #)OK      "));
   116ca:	84 e0       	ldi	r24, 0x04	; 4
   116cc:	61 e0       	ldi	r22, 0x01	; 1
   116ce:	49 eb       	ldi	r20, 0xB9	; 185
   116d0:	51 e1       	ldi	r21, 0x11	; 17
   116d2:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		      stMenuProduct=mpEditProductName;
   116d6:	85 e0       	ldi	r24, 0x05	; 5
   116d8:	7b c0       	rjmp	.+246    	; 0x117d0 <FSettingProduct+0x3d8>
		  }else
		  if (KeyChar=='2'){
   116da:	82 33       	cpi	r24, 0x32	; 50
   116dc:	09 f0       	breq	.+2      	; 0x116e0 <FSettingProduct+0x2e8>
   116de:	82 c0       	rjmp	.+260    	; 0x117e4 <FSettingProduct+0x3ec>
		      uiResult=USER_NONE;
   116e0:	10 92 ed 02 	sts	0x02ED, r1
		      sprintf_P(lcdteks,PSTR("Old:%s"),strPrice);
   116e4:	00 d0       	rcall	.+0      	; 0x116e6 <FSettingProduct+0x2ee>
   116e6:	00 d0       	rcall	.+0      	; 0x116e8 <FSettingProduct+0x2f0>
   116e8:	00 d0       	rcall	.+0      	; 0x116ea <FSettingProduct+0x2f2>
   116ea:	ed b7       	in	r30, 0x3d	; 61
   116ec:	fe b7       	in	r31, 0x3e	; 62
   116ee:	31 96       	adiw	r30, 0x01	; 1
   116f0:	8e 01       	movw	r16, r28
   116f2:	02 5f       	subi	r16, 0xF2	; 242
   116f4:	1f 4f       	sbci	r17, 0xFF	; 255
   116f6:	ad b7       	in	r26, 0x3d	; 61
   116f8:	be b7       	in	r27, 0x3e	; 62
   116fa:	12 96       	adiw	r26, 0x02	; 2
   116fc:	1c 93       	st	X, r17
   116fe:	0e 93       	st	-X, r16
   11700:	11 97       	sbiw	r26, 0x01	; 1
   11702:	82 eb       	ldi	r24, 0xB2	; 178
   11704:	91 e1       	ldi	r25, 0x11	; 17
   11706:	93 83       	std	Z+3, r25	; 0x03
   11708:	82 83       	std	Z+2, r24	; 0x02
   1170a:	84 ee       	ldi	r24, 0xE4	; 228
   1170c:	92 e0       	ldi	r25, 0x02	; 2
   1170e:	95 83       	std	Z+5, r25	; 0x05
   11710:	84 83       	std	Z+4, r24	; 0x04
   11712:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
		       lcd_print(2,1,lcdteks);
   11716:	8d b7       	in	r24, 0x3d	; 61
   11718:	9e b7       	in	r25, 0x3e	; 62
   1171a:	06 96       	adiw	r24, 0x06	; 6
   1171c:	0f b6       	in	r0, 0x3f	; 63
   1171e:	f8 94       	cli
   11720:	9e bf       	out	0x3e, r25	; 62
   11722:	0f be       	out	0x3f, r0	; 63
   11724:	8d bf       	out	0x3d, r24	; 61
   11726:	82 e0       	ldi	r24, 0x02	; 2
   11728:	61 e0       	ldi	r22, 0x01	; 1
   1172a:	a8 01       	movw	r20, r16
   1172c:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
			  lcd_printf(3,1,PSTR("New:_"));
   11730:	83 e0       	ldi	r24, 0x03	; 3
   11732:	61 e0       	ldi	r22, 0x01	; 1
   11734:	4c ea       	ldi	r20, 0xAC	; 172
   11736:	51 e1       	ldi	r21, 0x11	; 17
   11738:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		      lcd_printf(4,1,PSTR("*)Back    #)OK      "));
   1173c:	84 e0       	ldi	r24, 0x04	; 4
   1173e:	61 e0       	ldi	r22, 0x01	; 1
   11740:	47 e9       	ldi	r20, 0x97	; 151
   11742:	51 e1       	ldi	r21, 0x11	; 17
   11744:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		      stMenuProduct=mpEditPrice;
   11748:	84 e0       	ldi	r24, 0x04	; 4
   1174a:	42 c0       	rjmp	.+132    	; 0x117d0 <FSettingProduct+0x3d8>
		  }
	      break;
     case mpEditProductName:
	      uiResult=UserInput(UI_ALPHANUM_R,3,5,strDescription,0,10);
   1174c:	83 e0       	ldi	r24, 0x03	; 3
   1174e:	63 e0       	ldi	r22, 0x03	; 3
   11750:	45 e0       	ldi	r20, 0x05	; 5
   11752:	21 e1       	ldi	r18, 0x11	; 17
   11754:	3a e0       	ldi	r19, 0x0A	; 10
   11756:	00 e0       	ldi	r16, 0x00	; 0
   11758:	10 e0       	ldi	r17, 0x00	; 0
   1175a:	5a e0       	ldi	r21, 0x0A	; 10
   1175c:	e5 2e       	mov	r14, r21
   1175e:	0e 94 4b 7d 	call	0xfa96	; 0xfa96 <UserInput>
   11762:	80 93 ed 02 	sts	0x02ED, r24
		  if (uiResult==USER_OK){
   11766:	83 30       	cpi	r24, 0x03	; 3
   11768:	b1 f5       	brne	.+108    	; 0x117d6 <FSettingProduct+0x3de>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
   1176a:	80 91 ee 02 	lds	r24, 0x02EE
   1176e:	2d e0       	ldi	r18, 0x0D	; 13
   11770:	82 9f       	mul	r24, r18
   11772:	c0 01       	movw	r24, r0
   11774:	11 24       	eor	r1, r1
   11776:	85 54       	subi	r24, 0x45	; 69
   11778:	9f 4f       	sbci	r25, 0xFF	; 255
   1177a:	61 e1       	ldi	r22, 0x11	; 17
   1177c:	7a e0       	ldi	r23, 0x0A	; 10
   1177e:	4d e0       	ldi	r20, 0x0D	; 13
   11780:	50 e0       	ldi	r21, 0x00	; 0
   11782:	2e ef       	ldi	r18, 0xFE	; 254
   11784:	32 e1       	ldi	r19, 0x12	; 18
   11786:	0e 94 96 b5 	call	0x16b2c	; 0x16b2c <__eewr_block>
		      eeprom_write_block((const void*)&strDescription,(void*)&DefProductName[ProdID], 13);
		      stMenuProduct=mpInitProduct;
   1178a:	10 92 ef 02 	sts	0x02EF, r1
   1178e:	2a c0       	rjmp	.+84     	; 0x117e4 <FSettingProduct+0x3ec>
			  }
		  else
		  if (uiResult==USER_CANCEL)stMenuProduct=mpDispPrice;
	      break;
     case mpEditPrice:
	      uiResult=UserInput(UI_NUMBER_R,3,5,strPrice,0,7);
   11790:	81 e0       	ldi	r24, 0x01	; 1
   11792:	63 e0       	ldi	r22, 0x03	; 3
   11794:	45 e0       	ldi	r20, 0x05	; 5
   11796:	24 ee       	ldi	r18, 0xE4	; 228
   11798:	32 e0       	ldi	r19, 0x02	; 2
   1179a:	00 e0       	ldi	r16, 0x00	; 0
   1179c:	10 e0       	ldi	r17, 0x00	; 0
   1179e:	97 e0       	ldi	r25, 0x07	; 7
   117a0:	e9 2e       	mov	r14, r25
   117a2:	0e 94 4b 7d 	call	0xfa96	; 0xfa96 <UserInput>
   117a6:	80 93 ed 02 	sts	0x02ED, r24
		  if (uiResult==USER_OK){
   117aa:	83 30       	cpi	r24, 0x03	; 3
   117ac:	a1 f4       	brne	.+40     	; 0x117d6 <FSettingProduct+0x3de>
   117ae:	80 91 ee 02 	lds	r24, 0x02EE
   117b2:	29 e0       	ldi	r18, 0x09	; 9
   117b4:	82 9f       	mul	r24, r18
   117b6:	c0 01       	movw	r24, r0
   117b8:	11 24       	eor	r1, r1
   117ba:	8b 57       	subi	r24, 0x7B	; 123
   117bc:	9f 4f       	sbci	r25, 0xFF	; 255
   117be:	64 ee       	ldi	r22, 0xE4	; 228
   117c0:	72 e0       	ldi	r23, 0x02	; 2
   117c2:	49 e0       	ldi	r20, 0x09	; 9
   117c4:	50 e0       	ldi	r21, 0x00	; 0
   117c6:	2e ef       	ldi	r18, 0xFE	; 254
   117c8:	32 e1       	ldi	r19, 0x12	; 18
   117ca:	0e 94 96 b5 	call	0x16b2c	; 0x16b2c <__eewr_block>
		      eeprom_write_block((const void*)&strPrice,(void*)&DefProductPrice[ProdID], 9);
		      stMenuProduct=mpDispPrice;//stMenuProduct=mpInit;
   117ce:	82 e0       	ldi	r24, 0x02	; 2
   117d0:	80 93 ef 02 	sts	0x02EF, r24
   117d4:	07 c0       	rjmp	.+14     	; 0x117e4 <FSettingProduct+0x3ec>
			  }
		  else
		  if (uiResult==USER_CANCEL)stMenuProduct=mpDispPrice;
   117d6:	81 30       	cpi	r24, 0x01	; 1
   117d8:	29 f4       	brne	.+10     	; 0x117e4 <FSettingProduct+0x3ec>
   117da:	f9 cf       	rjmp	.-14     	; 0x117ce <FSettingProduct+0x3d6>
	      break;
     case mpExitMenuProduct:
	      stMenuProduct=mpInitProduct;
   117dc:	10 92 ef 02 	sts	0x02EF, r1
   117e0:	81 e0       	ldi	r24, 0x01	; 1
   117e2:	01 c0       	rjmp	.+2      	; 0x117e6 <FSettingProduct+0x3ee>
   117e4:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
   return Result;
}
   117e6:	a1 96       	adiw	r28, 0x21	; 33
   117e8:	0f b6       	in	r0, 0x3f	; 63
   117ea:	f8 94       	cli
   117ec:	de bf       	out	0x3e, r29	; 62
   117ee:	0f be       	out	0x3f, r0	; 63
   117f0:	cd bf       	out	0x3d, r28	; 61
   117f2:	cf 91       	pop	r28
   117f4:	df 91       	pop	r29
   117f6:	1f 91       	pop	r17
   117f8:	0f 91       	pop	r16
   117fa:	ff 90       	pop	r15
   117fc:	ef 90       	pop	r14
   117fe:	df 90       	pop	r13
   11800:	cf 90       	pop	r12
   11802:	bf 90       	pop	r11
   11804:	af 90       	pop	r10
   11806:	9f 90       	pop	r9
   11808:	8f 90       	pop	r8
   1180a:	7f 90       	pop	r7
   1180c:	6f 90       	pop	r6
   1180e:	08 95       	ret

00011810 <FMenuSettingFooter>:
	 }
   //_menu_header();   
   return Result;
}

char FMenuSettingFooter(){
   11810:	ef 92       	push	r14
   11812:	0f 93       	push	r16
   11814:	1f 93       	push	r17
   11816:	df 93       	push	r29
   11818:	cf 93       	push	r28
   1181a:	cd b7       	in	r28, 0x3d	; 61
   1181c:	de b7       	in	r29, 0x3e	; 62
   1181e:	c6 54       	subi	r28, 0x46	; 70
   11820:	d0 40       	sbci	r29, 0x00	; 0
   11822:	0f b6       	in	r0, 0x3f	; 63
   11824:	f8 94       	cli
   11826:	de bf       	out	0x3e, r29	; 62
   11828:	0f be       	out	0x3f, r0	; 63
   1182a:	cd bf       	out	0x3d, r28	; 61
	 char lcdteks[20];
	 char strHeaderFooter[50];
	 
	 Result=MENU_NONE;
     
	 switch (stSettingHeader){
   1182c:	80 91 1a 03 	lds	r24, 0x031A
   11830:	84 30       	cpi	r24, 0x04	; 4
   11832:	09 f4       	brne	.+2      	; 0x11836 <FMenuSettingFooter+0x26>
   11834:	3f c1       	rjmp	.+638    	; 0x11ab4 <FMenuSettingFooter+0x2a4>
   11836:	85 30       	cpi	r24, 0x05	; 5
   11838:	40 f4       	brcc	.+16     	; 0x1184a <FMenuSettingFooter+0x3a>
   1183a:	81 30       	cpi	r24, 0x01	; 1
   1183c:	79 f1       	breq	.+94     	; 0x1189c <FMenuSettingFooter+0x8c>
   1183e:	81 30       	cpi	r24, 0x01	; 1
   11840:	88 f0       	brcs	.+34     	; 0x11864 <FMenuSettingFooter+0x54>
   11842:	82 30       	cpi	r24, 0x02	; 2
   11844:	09 f0       	breq	.+2      	; 0x11848 <FMenuSettingFooter+0x38>
   11846:	85 c1       	rjmp	.+778    	; 0x11b52 <FMenuSettingFooter+0x342>
   11848:	76 c0       	rjmp	.+236    	; 0x11936 <FMenuSettingFooter+0x126>
   1184a:	86 30       	cpi	r24, 0x06	; 6
   1184c:	09 f4       	brne	.+2      	; 0x11850 <FMenuSettingFooter+0x40>
   1184e:	d7 c0       	rjmp	.+430    	; 0x119fe <FMenuSettingFooter+0x1ee>
   11850:	86 30       	cpi	r24, 0x06	; 6
   11852:	08 f4       	brcc	.+2      	; 0x11856 <FMenuSettingFooter+0x46>
   11854:	bf c0       	rjmp	.+382    	; 0x119d4 <FMenuSettingFooter+0x1c4>
   11856:	87 30       	cpi	r24, 0x07	; 7
   11858:	09 f4       	brne	.+2      	; 0x1185c <FMenuSettingFooter+0x4c>
   1185a:	3d c1       	rjmp	.+634    	; 0x11ad6 <FMenuSettingFooter+0x2c6>
   1185c:	88 30       	cpi	r24, 0x08	; 8
   1185e:	09 f0       	breq	.+2      	; 0x11862 <FMenuSettingFooter+0x52>
   11860:	78 c1       	rjmp	.+752    	; 0x11b52 <FMenuSettingFooter+0x342>
   11862:	73 c1       	rjmp	.+742    	; 0x11b4a <FMenuSettingFooter+0x33a>
	 case shInitHeader:
	      lcd_clear();
   11864:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
		  lcd_printf(1,1,PSTR("1)Footer1  3)Footer3"));
   11868:	81 e0       	ldi	r24, 0x01	; 1
   1186a:	61 e0       	ldi	r22, 0x01	; 1
   1186c:	46 e0       	ldi	r20, 0x06	; 6
   1186e:	54 e1       	ldi	r21, 0x14	; 20
   11870:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		  lcd_printf(2,1,PSTR("2)Footer2  4)Footer4"));
   11874:	82 e0       	ldi	r24, 0x02	; 2
   11876:	61 e0       	ldi	r22, 0x01	; 1
   11878:	41 ef       	ldi	r20, 0xF1	; 241
   1187a:	53 e1       	ldi	r21, 0x13	; 19
   1187c:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		  lcd_printf(3,1,PSTR("                    "));
   11880:	83 e0       	ldi	r24, 0x03	; 3
   11882:	61 e0       	ldi	r22, 0x01	; 1
   11884:	4c ed       	ldi	r20, 0xDC	; 220
   11886:	53 e1       	ldi	r21, 0x13	; 19
   11888:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		  lcd_printf(4,1,PSTR("*)Exit              "));
   1188c:	84 e0       	ldi	r24, 0x04	; 4
   1188e:	61 e0       	ldi	r22, 0x01	; 1
   11890:	47 ec       	ldi	r20, 0xC7	; 199
   11892:	53 e1       	ldi	r21, 0x13	; 19
   11894:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		  stSettingHeader=shHeaderSelect;
   11898:	81 e0       	ldi	r24, 0x01	; 1
   1189a:	16 c1       	rjmp	.+556    	; 0x11ac8 <FMenuSettingFooter+0x2b8>
	      break;
      case shHeaderSelect:
	      KeyChar=_key_btn(_key_scan(1));
   1189c:	81 e0       	ldi	r24, 0x01	; 1
   1189e:	0e 94 06 b0 	call	0x1600c	; 0x1600c <_key_scan>
   118a2:	0e 94 67 af 	call	0x15ece	; 0x15ece <_key_btn>
   118a6:	80 93 18 03 	sts	0x0318, r24
		  if ((KeyChar>='1')&&(KeyChar<='6')){
   118aa:	81 53       	subi	r24, 0x31	; 49
   118ac:	86 30       	cpi	r24, 0x06	; 6
   118ae:	e0 f5       	brcc	.+120    	; 0x11928 <FMenuSettingFooter+0x118>
		       HeaderIdx=KeyChar-'1';//
   118b0:	80 93 19 03 	sts	0x0319, r24
			   lcd_clear();
   118b4:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
			   sprintf_P(lcdteks,PSTR("Edit Footer%d "),HeaderIdx+1);
   118b8:	00 d0       	rcall	.+0      	; 0x118ba <FMenuSettingFooter+0xaa>
   118ba:	00 d0       	rcall	.+0      	; 0x118bc <FMenuSettingFooter+0xac>
   118bc:	00 d0       	rcall	.+0      	; 0x118be <FMenuSettingFooter+0xae>
   118be:	ed b7       	in	r30, 0x3d	; 61
   118c0:	fe b7       	in	r31, 0x3e	; 62
   118c2:	31 96       	adiw	r30, 0x01	; 1
   118c4:	8e 01       	movw	r16, r28
   118c6:	0f 5f       	subi	r16, 0xFF	; 255
   118c8:	1f 4f       	sbci	r17, 0xFF	; 255
   118ca:	ad b7       	in	r26, 0x3d	; 61
   118cc:	be b7       	in	r27, 0x3e	; 62
   118ce:	12 96       	adiw	r26, 0x02	; 2
   118d0:	1c 93       	st	X, r17
   118d2:	0e 93       	st	-X, r16
   118d4:	11 97       	sbiw	r26, 0x01	; 1
   118d6:	88 eb       	ldi	r24, 0xB8	; 184
   118d8:	93 e1       	ldi	r25, 0x13	; 19
   118da:	93 83       	std	Z+3, r25	; 0x03
   118dc:	82 83       	std	Z+2, r24	; 0x02
   118de:	80 91 19 03 	lds	r24, 0x0319
   118e2:	90 e0       	ldi	r25, 0x00	; 0
   118e4:	01 96       	adiw	r24, 0x01	; 1
   118e6:	95 83       	std	Z+5, r25	; 0x05
   118e8:	84 83       	std	Z+4, r24	; 0x04
   118ea:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
			   lcd_print(1,1,lcdteks);
   118ee:	8d b7       	in	r24, 0x3d	; 61
   118f0:	9e b7       	in	r25, 0x3e	; 62
   118f2:	06 96       	adiw	r24, 0x06	; 6
   118f4:	0f b6       	in	r0, 0x3f	; 63
   118f6:	f8 94       	cli
   118f8:	9e bf       	out	0x3e, r25	; 62
   118fa:	0f be       	out	0x3f, r0	; 63
   118fc:	8d bf       	out	0x3d, r24	; 61
   118fe:	81 e0       	ldi	r24, 0x01	; 1
   11900:	61 e0       	ldi	r22, 0x01	; 1
   11902:	a8 01       	movw	r20, r16
   11904:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
			   lcd_printf(4,1,PSTR("[*]Back  [#]OK"));
   11908:	84 e0       	ldi	r24, 0x04	; 4
   1190a:	61 e0       	ldi	r22, 0x01	; 1
   1190c:	49 ea       	ldi	r20, 0xA9	; 169
   1190e:	53 e1       	ldi	r21, 0x13	; 19
   11910:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
   11914:	ef ec       	ldi	r30, 0xCF	; 207
   11916:	f5 e0       	ldi	r31, 0x05	; 5
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
   11918:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   1191a:	97 e0       	ldi	r25, 0x07	; 7
   1191c:	e0 36       	cpi	r30, 0x60	; 96
   1191e:	f9 07       	cpc	r31, r25
   11920:	d9 f7       	brne	.-10     	; 0x11918 <FMenuSettingFooter+0x108>
			   lcd_clear();
			   sprintf_P(lcdteks,PSTR("Edit Footer%d "),HeaderIdx+1);
			   lcd_print(1,1,lcdteks);
			   lcd_printf(4,1,PSTR("[*]Back  [#]OK"));
			   FillChar(PrintBuffer,sizeof(PrintBuffer),0);
			   stSettingHeader=shEditHeader1;
   11922:	82 e0       	ldi	r24, 0x02	; 2
   11924:	80 93 1a 03 	sts	0x031A, r24
		  }
		  if(KeyChar=='*')stSettingHeader=shExitSettingHeader;
   11928:	80 91 18 03 	lds	r24, 0x0318
   1192c:	8a 32       	cpi	r24, 0x2A	; 42
   1192e:	09 f0       	breq	.+2      	; 0x11932 <FMenuSettingFooter+0x122>
   11930:	10 c1       	rjmp	.+544    	; 0x11b52 <FMenuSettingFooter+0x342>
   11932:	88 e0       	ldi	r24, 0x08	; 8
   11934:	c9 c0       	rjmp	.+402    	; 0x11ac8 <FMenuSettingFooter+0x2b8>
	      break;
     case shEditHeader1:
          //uiResult=UserInput(UI_ALPHANUM_R,2,1,strFreeMessageLine1,0,20);
		  uiResult=UserInput(UI_ALPHANUM_R,2,1,PrintBuffer,0,40);
   11936:	83 e0       	ldi	r24, 0x03	; 3
   11938:	62 e0       	ldi	r22, 0x02	; 2
   1193a:	41 e0       	ldi	r20, 0x01	; 1
   1193c:	2f ec       	ldi	r18, 0xCF	; 207
   1193e:	35 e0       	ldi	r19, 0x05	; 5
   11940:	00 e0       	ldi	r16, 0x00	; 0
   11942:	10 e0       	ldi	r17, 0x00	; 0
   11944:	98 e2       	ldi	r25, 0x28	; 40
   11946:	e9 2e       	mov	r14, r25
   11948:	0e 94 4b 7d 	call	0xfa96	; 0xfa96 <UserInput>
		  if (uiResult==USER_OK){
   1194c:	83 30       	cpi	r24, 0x03	; 3
   1194e:	f1 f5       	brne	.+124    	; 0x119cc <FMenuSettingFooter+0x1bc>
			  lcd_clear();
   11950:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
			  AddSpaceLag(PrintBuffer,40);
   11954:	8f ec       	ldi	r24, 0xCF	; 207
   11956:	95 e0       	ldi	r25, 0x05	; 5
   11958:	68 e2       	ldi	r22, 0x28	; 40
   1195a:	0e 94 40 2e 	call	0x5c80	; 0x5c80 <AddSpaceLag>
   1195e:	20 e0       	ldi	r18, 0x00	; 0
   11960:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   11962:	f9 01       	movw	r30, r18
   11964:	e9 56       	subi	r30, 0x69	; 105
   11966:	f5 4f       	sbci	r31, 0xF5	; 245
   11968:	d9 01       	movw	r26, r18
   1196a:	a1 53       	subi	r26, 0x31	; 49
   1196c:	ba 4f       	sbci	r27, 0xFA	; 250
   1196e:	8c 91       	ld	r24, X
   11970:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   11972:	2f 5f       	subi	r18, 0xFF	; 255
   11974:	3f 4f       	sbci	r19, 0xFF	; 255
   11976:	24 31       	cpi	r18, 0x14	; 20
   11978:	31 05       	cpc	r19, r1
   1197a:	99 f7       	brne	.-26     	; 0x11962 <FMenuSettingFooter+0x152>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   1197c:	10 92 ab 0a 	sts	0x0AAB, r1
   11980:	e3 ee       	ldi	r30, 0xE3	; 227
   11982:	f5 e0       	ldi	r31, 0x05	; 5
   11984:	a6 e8       	ldi	r26, 0x86	; 134
   11986:	b9 e0       	ldi	r27, 0x09	; 9
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   11988:	81 91       	ld	r24, Z+
   1198a:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   1198c:	85 e0       	ldi	r24, 0x05	; 5
   1198e:	e7 3f       	cpi	r30, 0xF7	; 247
   11990:	f8 07       	cpc	r31, r24
   11992:	d1 f7       	brne	.-12     	; 0x11988 <FMenuSettingFooter+0x178>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   11994:	10 92 9a 09 	sts	0x099A, r1
			  lcd_clear();
			  AddSpaceLag(PrintBuffer,40);
			  StrPosCopy(PrintBuffer,strFreeMessageLine1,0,20);
			  StrPosCopy(PrintBuffer,strFreeMessageLine2,20,20);

			  lcd_print(1,1,strFreeMessageLine1);			  
   11998:	81 e0       	ldi	r24, 0x01	; 1
   1199a:	61 e0       	ldi	r22, 0x01	; 1
   1199c:	47 e9       	ldi	r20, 0x97	; 151
   1199e:	5a e0       	ldi	r21, 0x0A	; 10
   119a0:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
			  lcd_print(2,1,strFreeMessageLine2);			  
   119a4:	82 e0       	ldi	r24, 0x02	; 2
   119a6:	61 e0       	ldi	r22, 0x01	; 1
   119a8:	46 e8       	ldi	r20, 0x86	; 134
   119aa:	59 e0       	ldi	r21, 0x09	; 9
   119ac:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
			  
			  lcd_printf(3,1,PSTR("Align Center?"));
   119b0:	83 e0       	ldi	r24, 0x03	; 3
   119b2:	61 e0       	ldi	r22, 0x01	; 1
   119b4:	4b e9       	ldi	r20, 0x9B	; 155
   119b6:	53 e1       	ldi	r21, 0x13	; 19
   119b8:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
			  lcd_printf(4,1,PSTR("[*]No  [#]Yes"));
   119bc:	84 e0       	ldi	r24, 0x04	; 4
   119be:	61 e0       	ldi	r22, 0x01	; 1
   119c0:	4d e8       	ldi	r20, 0x8D	; 141
   119c2:	53 e1       	ldi	r21, 0x13	; 19
   119c4:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		      stSettingHeader=shIsAlignCenter;
   119c8:	85 e0       	ldi	r24, 0x05	; 5
   119ca:	7e c0       	rjmp	.+252    	; 0x11ac8 <FMenuSettingFooter+0x2b8>
		  }
		  else
		  if (uiResult==USER_CANCEL)stSettingHeader=shInitHeader;
   119cc:	81 30       	cpi	r24, 0x01	; 1
   119ce:	09 f0       	breq	.+2      	; 0x119d2 <FMenuSettingFooter+0x1c2>
   119d0:	c0 c0       	rjmp	.+384    	; 0x11b52 <FMenuSettingFooter+0x342>
   119d2:	b8 c0       	rjmp	.+368    	; 0x11b44 <FMenuSettingFooter+0x334>
	      break;
     case shIsAlignCenter:
	      KeyChar=_key_btn(_key_scan(1));
   119d4:	81 e0       	ldi	r24, 0x01	; 1
   119d6:	0e 94 06 b0 	call	0x1600c	; 0x1600c <_key_scan>
   119da:	0e 94 67 af 	call	0x15ece	; 0x15ece <_key_btn>
   119de:	80 93 18 03 	sts	0x0318, r24
          if(KeyChar=='#'){
   119e2:	83 32       	cpi	r24, 0x23	; 35
   119e4:	39 f4       	brne	.+14     	; 0x119f4 <FMenuSettingFooter+0x1e4>
		      //AlignCenter			  
			  StrAlignCenter(PrintBuffer,40);
   119e6:	8f ec       	ldi	r24, 0xCF	; 207
   119e8:	95 e0       	ldi	r25, 0x05	; 5
   119ea:	68 e2       	ldi	r22, 0x28	; 40
   119ec:	70 e0       	ldi	r23, 0x00	; 0
   119ee:	0e 94 4a 30 	call	0x6094	; 0x6094 <StrAlignCenter>
   119f2:	03 c0       	rjmp	.+6      	; 0x119fa <FMenuSettingFooter+0x1ea>
			  stSettingHeader=shIsSaveHeader;
		  } else if(KeyChar=='*')stSettingHeader=shIsSaveHeader;		 
   119f4:	8a 32       	cpi	r24, 0x2A	; 42
   119f6:	09 f0       	breq	.+2      	; 0x119fa <FMenuSettingFooter+0x1ea>
   119f8:	ac c0       	rjmp	.+344    	; 0x11b52 <FMenuSettingFooter+0x342>
   119fa:	86 e0       	ldi	r24, 0x06	; 6
   119fc:	65 c0       	rjmp	.+202    	; 0x11ac8 <FMenuSettingFooter+0x2b8>
	      break;
     case shIsSaveHeader:
	      lcd_clear(); 
   119fe:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
   11a02:	20 e0       	ldi	r18, 0x00	; 0
   11a04:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   11a06:	f9 01       	movw	r30, r18
   11a08:	e9 56       	subi	r30, 0x69	; 105
   11a0a:	f5 4f       	sbci	r31, 0xF5	; 245
   11a0c:	d9 01       	movw	r26, r18
   11a0e:	a1 53       	subi	r26, 0x31	; 49
   11a10:	ba 4f       	sbci	r27, 0xFA	; 250
   11a12:	8c 91       	ld	r24, X
   11a14:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   11a16:	2f 5f       	subi	r18, 0xFF	; 255
   11a18:	3f 4f       	sbci	r19, 0xFF	; 255
   11a1a:	24 31       	cpi	r18, 0x14	; 20
   11a1c:	31 05       	cpc	r19, r1
   11a1e:	99 f7       	brne	.-26     	; 0x11a06 <FMenuSettingFooter+0x1f6>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   11a20:	10 92 ab 0a 	sts	0x0AAB, r1
   11a24:	e3 ee       	ldi	r30, 0xE3	; 227
   11a26:	f5 e0       	ldi	r31, 0x05	; 5
   11a28:	a6 e8       	ldi	r26, 0x86	; 134
   11a2a:	b9 e0       	ldi	r27, 0x09	; 9
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   11a2c:	81 91       	ld	r24, Z+
   11a2e:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   11a30:	95 e0       	ldi	r25, 0x05	; 5
   11a32:	e7 3f       	cpi	r30, 0xF7	; 247
   11a34:	f9 07       	cpc	r31, r25
   11a36:	d1 f7       	brne	.-12     	; 0x11a2c <FMenuSettingFooter+0x21c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   11a38:	10 92 9a 09 	sts	0x099A, r1
	      break;
     case shIsSaveHeader:
	      lcd_clear(); 
		  StrPosCopy(PrintBuffer,strFreeMessageLine1,0,20);
		  StrPosCopy(PrintBuffer,strFreeMessageLine2,20,20);
          lcd_print(1,1,strFreeMessageLine1);
   11a3c:	81 e0       	ldi	r24, 0x01	; 1
   11a3e:	61 e0       	ldi	r22, 0x01	; 1
   11a40:	47 e9       	ldi	r20, 0x97	; 151
   11a42:	5a e0       	ldi	r21, 0x0A	; 10
   11a44:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
		  lcd_print(2,1,strFreeMessageLine2);
   11a48:	82 e0       	ldi	r24, 0x02	; 2
   11a4a:	61 e0       	ldi	r22, 0x01	; 1
   11a4c:	46 e8       	ldi	r20, 0x86	; 134
   11a4e:	59 e0       	ldi	r21, 0x09	; 9
   11a50:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
		  sprintf_P(lcdteks,PSTR("Save Footer%d ?"),HeaderIdx+1);
   11a54:	00 d0       	rcall	.+0      	; 0x11a56 <FMenuSettingFooter+0x246>
   11a56:	00 d0       	rcall	.+0      	; 0x11a58 <FMenuSettingFooter+0x248>
   11a58:	00 d0       	rcall	.+0      	; 0x11a5a <FMenuSettingFooter+0x24a>
   11a5a:	ed b7       	in	r30, 0x3d	; 61
   11a5c:	fe b7       	in	r31, 0x3e	; 62
   11a5e:	31 96       	adiw	r30, 0x01	; 1
   11a60:	8e 01       	movw	r16, r28
   11a62:	0f 5f       	subi	r16, 0xFF	; 255
   11a64:	1f 4f       	sbci	r17, 0xFF	; 255
   11a66:	ad b7       	in	r26, 0x3d	; 61
   11a68:	be b7       	in	r27, 0x3e	; 62
   11a6a:	12 96       	adiw	r26, 0x02	; 2
   11a6c:	1c 93       	st	X, r17
   11a6e:	0e 93       	st	-X, r16
   11a70:	11 97       	sbiw	r26, 0x01	; 1
   11a72:	8d e7       	ldi	r24, 0x7D	; 125
   11a74:	93 e1       	ldi	r25, 0x13	; 19
   11a76:	93 83       	std	Z+3, r25	; 0x03
   11a78:	82 83       	std	Z+2, r24	; 0x02
   11a7a:	80 91 19 03 	lds	r24, 0x0319
   11a7e:	90 e0       	ldi	r25, 0x00	; 0
   11a80:	01 96       	adiw	r24, 0x01	; 1
   11a82:	95 83       	std	Z+5, r25	; 0x05
   11a84:	84 83       	std	Z+4, r24	; 0x04
   11a86:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
		  lcd_print(3,1,lcdteks);
   11a8a:	8d b7       	in	r24, 0x3d	; 61
   11a8c:	9e b7       	in	r25, 0x3e	; 62
   11a8e:	06 96       	adiw	r24, 0x06	; 6
   11a90:	0f b6       	in	r0, 0x3f	; 63
   11a92:	f8 94       	cli
   11a94:	9e bf       	out	0x3e, r25	; 62
   11a96:	0f be       	out	0x3f, r0	; 63
   11a98:	8d bf       	out	0x3d, r24	; 61
   11a9a:	83 e0       	ldi	r24, 0x03	; 3
   11a9c:	61 e0       	ldi	r22, 0x01	; 1
   11a9e:	a8 01       	movw	r20, r16
   11aa0:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
		  lcd_printf(4,1,PSTR("[*]No [#]Yes"));		      
   11aa4:	84 e0       	ldi	r24, 0x04	; 4
   11aa6:	61 e0       	ldi	r22, 0x01	; 1
   11aa8:	40 e7       	ldi	r20, 0x70	; 112
   11aaa:	53 e1       	ldi	r21, 0x13	; 19
   11aac:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
	      stSettingHeader=shSaveHeaderQuestions;      
   11ab0:	84 e0       	ldi	r24, 0x04	; 4
   11ab2:	0a c0       	rjmp	.+20     	; 0x11ac8 <FMenuSettingFooter+0x2b8>
	      break;       
     case shSaveHeaderQuestions:
          KeyChar=_key_btn(_key_scan(1));
   11ab4:	81 e0       	ldi	r24, 0x01	; 1
   11ab6:	0e 94 06 b0 	call	0x1600c	; 0x1600c <_key_scan>
   11aba:	0e 94 67 af 	call	0x15ece	; 0x15ece <_key_btn>
   11abe:	80 93 18 03 	sts	0x0318, r24
	      if(KeyChar=='#')stSettingHeader=shSaveHeader;
   11ac2:	83 32       	cpi	r24, 0x23	; 35
   11ac4:	21 f4       	brne	.+8      	; 0x11ace <FMenuSettingFooter+0x2be>
   11ac6:	87 e0       	ldi	r24, 0x07	; 7
   11ac8:	80 93 1a 03 	sts	0x031A, r24
   11acc:	42 c0       	rjmp	.+132    	; 0x11b52 <FMenuSettingFooter+0x342>
		  else
          if(KeyChar=='*')stSettingHeader=shInitHeader;
   11ace:	8a 32       	cpi	r24, 0x2A	; 42
   11ad0:	09 f0       	breq	.+2      	; 0x11ad4 <FMenuSettingFooter+0x2c4>
   11ad2:	3f c0       	rjmp	.+126    	; 0x11b52 <FMenuSettingFooter+0x342>
   11ad4:	37 c0       	rjmp	.+110    	; 0x11b44 <FMenuSettingFooter+0x334>
	      break;
     case shSaveHeader:
	      sprintf_P(strHeaderFooter,PSTR("%s%s"),strFreeMessageLine1,strFreeMessageLine2);
   11ad6:	ad b7       	in	r26, 0x3d	; 61
   11ad8:	be b7       	in	r27, 0x3e	; 62
   11ada:	18 97       	sbiw	r26, 0x08	; 8
   11adc:	0f b6       	in	r0, 0x3f	; 63
   11ade:	f8 94       	cli
   11ae0:	be bf       	out	0x3e, r27	; 62
   11ae2:	0f be       	out	0x3f, r0	; 63
   11ae4:	ad bf       	out	0x3d, r26	; 61
   11ae6:	ed b7       	in	r30, 0x3d	; 61
   11ae8:	fe b7       	in	r31, 0x3e	; 62
   11aea:	31 96       	adiw	r30, 0x01	; 1
   11aec:	8e 01       	movw	r16, r28
   11aee:	0b 5e       	subi	r16, 0xEB	; 235
   11af0:	1f 4f       	sbci	r17, 0xFF	; 255
   11af2:	12 96       	adiw	r26, 0x02	; 2
   11af4:	1c 93       	st	X, r17
   11af6:	0e 93       	st	-X, r16
   11af8:	11 97       	sbiw	r26, 0x01	; 1
   11afa:	8b e6       	ldi	r24, 0x6B	; 107
   11afc:	93 e1       	ldi	r25, 0x13	; 19
   11afe:	93 83       	std	Z+3, r25	; 0x03
   11b00:	82 83       	std	Z+2, r24	; 0x02
   11b02:	87 e9       	ldi	r24, 0x97	; 151
   11b04:	9a e0       	ldi	r25, 0x0A	; 10
   11b06:	95 83       	std	Z+5, r25	; 0x05
   11b08:	84 83       	std	Z+4, r24	; 0x04
   11b0a:	86 e8       	ldi	r24, 0x86	; 134
   11b0c:	99 e0       	ldi	r25, 0x09	; 9
   11b0e:	97 83       	std	Z+7, r25	; 0x07
   11b10:	86 83       	std	Z+6, r24	; 0x06
   11b12:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
   11b16:	8d b7       	in	r24, 0x3d	; 61
   11b18:	9e b7       	in	r25, 0x3e	; 62
   11b1a:	08 96       	adiw	r24, 0x08	; 8
   11b1c:	0f b6       	in	r0, 0x3f	; 63
   11b1e:	f8 94       	cli
   11b20:	9e bf       	out	0x3e, r25	; 62
   11b22:	0f be       	out	0x3f, r0	; 63
   11b24:	8d bf       	out	0x3d, r24	; 61
   11b26:	80 91 19 03 	lds	r24, 0x0319
   11b2a:	29 e2       	ldi	r18, 0x29	; 41
   11b2c:	82 9f       	mul	r24, r18
   11b2e:	c0 01       	movw	r24, r0
   11b30:	11 24       	eor	r1, r1
   11b32:	83 5e       	subi	r24, 0xE3	; 227
   11b34:	9c 4f       	sbci	r25, 0xFC	; 252
   11b36:	b8 01       	movw	r22, r16
   11b38:	48 e2       	ldi	r20, 0x28	; 40
   11b3a:	50 e0       	ldi	r21, 0x00	; 0
   11b3c:	2e ef       	ldi	r18, 0xFE	; 254
   11b3e:	32 e1       	ldi	r19, 0x12	; 18
   11b40:	0e 94 96 b5 	call	0x16b2c	; 0x16b2c <__eewr_block>
	      eeprom_write_block((const void*) &strHeaderFooter, (void*) &DefHeaderFooter[HeaderIdx+6],40);
		  //eeprom_write_block((const void*) &PrintBuffer, (void*) &DefHeaderFooter[HeaderIdx+6],40);

          stSettingHeader=shInitHeader;
   11b44:	10 92 1a 03 	sts	0x031A, r1
   11b48:	04 c0       	rjmp	.+8      	; 0x11b52 <FMenuSettingFooter+0x342>
	      break;
     case shExitSettingHeader:
          stSettingHeader=shInitHeader;
   11b4a:	10 92 1a 03 	sts	0x031A, r1
   11b4e:	81 e0       	ldi	r24, 0x01	; 1
   11b50:	01 c0       	rjmp	.+2      	; 0x11b54 <FMenuSettingFooter+0x344>
   11b52:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;	 
	 }
   return Result;
}
   11b54:	ca 5b       	subi	r28, 0xBA	; 186
   11b56:	df 4f       	sbci	r29, 0xFF	; 255
   11b58:	0f b6       	in	r0, 0x3f	; 63
   11b5a:	f8 94       	cli
   11b5c:	de bf       	out	0x3e, r29	; 62
   11b5e:	0f be       	out	0x3f, r0	; 63
   11b60:	cd bf       	out	0x3d, r28	; 61
   11b62:	cf 91       	pop	r28
   11b64:	df 91       	pop	r29
   11b66:	1f 91       	pop	r17
   11b68:	0f 91       	pop	r16
   11b6a:	ef 90       	pop	r14
   11b6c:	08 95       	ret

00011b6e <FMenuSettingHeader>:
	      break;
	 }
   return Result;
}

char FMenuSettingHeader(){
   11b6e:	ef 92       	push	r14
   11b70:	0f 93       	push	r16
   11b72:	1f 93       	push	r17
   11b74:	df 93       	push	r29
   11b76:	cf 93       	push	r28
   11b78:	cd b7       	in	r28, 0x3d	; 61
   11b7a:	de b7       	in	r29, 0x3e	; 62
   11b7c:	c6 54       	subi	r28, 0x46	; 70
   11b7e:	d0 40       	sbci	r29, 0x00	; 0
   11b80:	0f b6       	in	r0, 0x3f	; 63
   11b82:	f8 94       	cli
   11b84:	de bf       	out	0x3e, r29	; 62
   11b86:	0f be       	out	0x3f, r0	; 63
   11b88:	cd bf       	out	0x3d, r28	; 61
	 char lcdteks[20];
	 char strHeaderFooter[50];
	 
	 Result=MENU_NONE;
     
	 switch (stSettingHeader){
   11b8a:	80 91 1d 03 	lds	r24, 0x031D
   11b8e:	84 30       	cpi	r24, 0x04	; 4
   11b90:	09 f4       	brne	.+2      	; 0x11b94 <FMenuSettingHeader+0x26>
   11b92:	3f c1       	rjmp	.+638    	; 0x11e12 <FMenuSettingHeader+0x2a4>
   11b94:	85 30       	cpi	r24, 0x05	; 5
   11b96:	40 f4       	brcc	.+16     	; 0x11ba8 <FMenuSettingHeader+0x3a>
   11b98:	81 30       	cpi	r24, 0x01	; 1
   11b9a:	79 f1       	breq	.+94     	; 0x11bfa <FMenuSettingHeader+0x8c>
   11b9c:	81 30       	cpi	r24, 0x01	; 1
   11b9e:	88 f0       	brcs	.+34     	; 0x11bc2 <FMenuSettingHeader+0x54>
   11ba0:	82 30       	cpi	r24, 0x02	; 2
   11ba2:	09 f0       	breq	.+2      	; 0x11ba6 <FMenuSettingHeader+0x38>
   11ba4:	85 c1       	rjmp	.+778    	; 0x11eb0 <FMenuSettingHeader+0x342>
   11ba6:	76 c0       	rjmp	.+236    	; 0x11c94 <FMenuSettingHeader+0x126>
   11ba8:	86 30       	cpi	r24, 0x06	; 6
   11baa:	09 f4       	brne	.+2      	; 0x11bae <FMenuSettingHeader+0x40>
   11bac:	d7 c0       	rjmp	.+430    	; 0x11d5c <FMenuSettingHeader+0x1ee>
   11bae:	86 30       	cpi	r24, 0x06	; 6
   11bb0:	08 f4       	brcc	.+2      	; 0x11bb4 <FMenuSettingHeader+0x46>
   11bb2:	bf c0       	rjmp	.+382    	; 0x11d32 <FMenuSettingHeader+0x1c4>
   11bb4:	87 30       	cpi	r24, 0x07	; 7
   11bb6:	09 f4       	brne	.+2      	; 0x11bba <FMenuSettingHeader+0x4c>
   11bb8:	3d c1       	rjmp	.+634    	; 0x11e34 <FMenuSettingHeader+0x2c6>
   11bba:	88 30       	cpi	r24, 0x08	; 8
   11bbc:	09 f0       	breq	.+2      	; 0x11bc0 <FMenuSettingHeader+0x52>
   11bbe:	78 c1       	rjmp	.+752    	; 0x11eb0 <FMenuSettingHeader+0x342>
   11bc0:	73 c1       	rjmp	.+742    	; 0x11ea8 <FMenuSettingHeader+0x33a>
	 case shInitHeader:
	      lcd_clear();
   11bc2:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
		  lcd_printf(1,1,PSTR("1)Header1  4)Header4"));
   11bc6:	81 e0       	ldi	r24, 0x01	; 1
   11bc8:	61 e0       	ldi	r22, 0x01	; 1
   11bca:	46 eb       	ldi	r20, 0xB6	; 182
   11bcc:	54 e1       	ldi	r21, 0x14	; 20
   11bce:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		  lcd_printf(2,1,PSTR("2)Header2  5)Header5"));
   11bd2:	82 e0       	ldi	r24, 0x02	; 2
   11bd4:	61 e0       	ldi	r22, 0x01	; 1
   11bd6:	41 ea       	ldi	r20, 0xA1	; 161
   11bd8:	54 e1       	ldi	r21, 0x14	; 20
   11bda:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		  lcd_printf(3,1,PSTR("3)Header3  6)Header6"));
   11bde:	83 e0       	ldi	r24, 0x03	; 3
   11be0:	61 e0       	ldi	r22, 0x01	; 1
   11be2:	4c e8       	ldi	r20, 0x8C	; 140
   11be4:	54 e1       	ldi	r21, 0x14	; 20
   11be6:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		  lcd_printf(4,1,PSTR("*)Exit              "));
   11bea:	84 e0       	ldi	r24, 0x04	; 4
   11bec:	61 e0       	ldi	r22, 0x01	; 1
   11bee:	47 e7       	ldi	r20, 0x77	; 119
   11bf0:	54 e1       	ldi	r21, 0x14	; 20
   11bf2:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		  stSettingHeader=shHeaderSelect;
   11bf6:	81 e0       	ldi	r24, 0x01	; 1
   11bf8:	16 c1       	rjmp	.+556    	; 0x11e26 <FMenuSettingHeader+0x2b8>
	      break;
     case shHeaderSelect:
	      KeyChar=_key_btn(_key_scan(1));
   11bfa:	81 e0       	ldi	r24, 0x01	; 1
   11bfc:	0e 94 06 b0 	call	0x1600c	; 0x1600c <_key_scan>
   11c00:	0e 94 67 af 	call	0x15ece	; 0x15ece <_key_btn>
   11c04:	80 93 1b 03 	sts	0x031B, r24
		  if ((KeyChar>='1')&&(KeyChar<='6')){
   11c08:	81 53       	subi	r24, 0x31	; 49
   11c0a:	86 30       	cpi	r24, 0x06	; 6
   11c0c:	e0 f5       	brcc	.+120    	; 0x11c86 <FMenuSettingHeader+0x118>
		       HeaderIdx=KeyChar-'1';//
   11c0e:	80 93 1c 03 	sts	0x031C, r24
			   lcd_clear();
   11c12:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
			   sprintf_P(lcdteks,PSTR("Edit Header%d "),HeaderIdx+1);
   11c16:	00 d0       	rcall	.+0      	; 0x11c18 <FMenuSettingHeader+0xaa>
   11c18:	00 d0       	rcall	.+0      	; 0x11c1a <FMenuSettingHeader+0xac>
   11c1a:	00 d0       	rcall	.+0      	; 0x11c1c <FMenuSettingHeader+0xae>
   11c1c:	ed b7       	in	r30, 0x3d	; 61
   11c1e:	fe b7       	in	r31, 0x3e	; 62
   11c20:	31 96       	adiw	r30, 0x01	; 1
   11c22:	8e 01       	movw	r16, r28
   11c24:	0f 5f       	subi	r16, 0xFF	; 255
   11c26:	1f 4f       	sbci	r17, 0xFF	; 255
   11c28:	ad b7       	in	r26, 0x3d	; 61
   11c2a:	be b7       	in	r27, 0x3e	; 62
   11c2c:	12 96       	adiw	r26, 0x02	; 2
   11c2e:	1c 93       	st	X, r17
   11c30:	0e 93       	st	-X, r16
   11c32:	11 97       	sbiw	r26, 0x01	; 1
   11c34:	88 e6       	ldi	r24, 0x68	; 104
   11c36:	94 e1       	ldi	r25, 0x14	; 20
   11c38:	93 83       	std	Z+3, r25	; 0x03
   11c3a:	82 83       	std	Z+2, r24	; 0x02
   11c3c:	80 91 1c 03 	lds	r24, 0x031C
   11c40:	90 e0       	ldi	r25, 0x00	; 0
   11c42:	01 96       	adiw	r24, 0x01	; 1
   11c44:	95 83       	std	Z+5, r25	; 0x05
   11c46:	84 83       	std	Z+4, r24	; 0x04
   11c48:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
			   lcd_print(1,1,lcdteks);
   11c4c:	8d b7       	in	r24, 0x3d	; 61
   11c4e:	9e b7       	in	r25, 0x3e	; 62
   11c50:	06 96       	adiw	r24, 0x06	; 6
   11c52:	0f b6       	in	r0, 0x3f	; 63
   11c54:	f8 94       	cli
   11c56:	9e bf       	out	0x3e, r25	; 62
   11c58:	0f be       	out	0x3f, r0	; 63
   11c5a:	8d bf       	out	0x3d, r24	; 61
   11c5c:	81 e0       	ldi	r24, 0x01	; 1
   11c5e:	61 e0       	ldi	r22, 0x01	; 1
   11c60:	a8 01       	movw	r20, r16
   11c62:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
			   lcd_printf(4,1,PSTR("[*]Back  [#]OK"));
   11c66:	84 e0       	ldi	r24, 0x04	; 4
   11c68:	61 e0       	ldi	r22, 0x01	; 1
   11c6a:	49 e5       	ldi	r20, 0x59	; 89
   11c6c:	54 e1       	ldi	r21, 0x14	; 20
   11c6e:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
   11c72:	ef ec       	ldi	r30, 0xCF	; 207
   11c74:	f5 e0       	ldi	r31, 0x05	; 5
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
   11c76:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   11c78:	97 e0       	ldi	r25, 0x07	; 7
   11c7a:	e0 36       	cpi	r30, 0x60	; 96
   11c7c:	f9 07       	cpc	r31, r25
   11c7e:	d9 f7       	brne	.-10     	; 0x11c76 <FMenuSettingHeader+0x108>
			   lcd_clear();
			   sprintf_P(lcdteks,PSTR("Edit Header%d "),HeaderIdx+1);
			   lcd_print(1,1,lcdteks);
			   lcd_printf(4,1,PSTR("[*]Back  [#]OK"));
			   FillChar(PrintBuffer,sizeof(PrintBuffer),0);
			   stSettingHeader=shEditHeader1;
   11c80:	82 e0       	ldi	r24, 0x02	; 2
   11c82:	80 93 1d 03 	sts	0x031D, r24
		  }
		  if(KeyChar=='*')stSettingHeader=shExitSettingHeader;
   11c86:	80 91 1b 03 	lds	r24, 0x031B
   11c8a:	8a 32       	cpi	r24, 0x2A	; 42
   11c8c:	09 f0       	breq	.+2      	; 0x11c90 <FMenuSettingHeader+0x122>
   11c8e:	10 c1       	rjmp	.+544    	; 0x11eb0 <FMenuSettingHeader+0x342>
   11c90:	88 e0       	ldi	r24, 0x08	; 8
   11c92:	c9 c0       	rjmp	.+402    	; 0x11e26 <FMenuSettingHeader+0x2b8>
	      break;
     case shEditHeader1:
          //uiResult=UserInput(UI_ALPHANUM_R,2,1,strFreeMessageLine1,0,20);
		  uiResult=UserInput(UI_ALPHANUM_R,2,1,PrintBuffer,0,40);
   11c94:	83 e0       	ldi	r24, 0x03	; 3
   11c96:	62 e0       	ldi	r22, 0x02	; 2
   11c98:	41 e0       	ldi	r20, 0x01	; 1
   11c9a:	2f ec       	ldi	r18, 0xCF	; 207
   11c9c:	35 e0       	ldi	r19, 0x05	; 5
   11c9e:	00 e0       	ldi	r16, 0x00	; 0
   11ca0:	10 e0       	ldi	r17, 0x00	; 0
   11ca2:	58 e2       	ldi	r21, 0x28	; 40
   11ca4:	e5 2e       	mov	r14, r21
   11ca6:	0e 94 4b 7d 	call	0xfa96	; 0xfa96 <UserInput>
		  if (uiResult==USER_OK){
   11caa:	83 30       	cpi	r24, 0x03	; 3
   11cac:	f1 f5       	brne	.+124    	; 0x11d2a <FMenuSettingHeader+0x1bc>
			  lcd_clear();
   11cae:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
			  AddSpaceLag(PrintBuffer,40);
   11cb2:	8f ec       	ldi	r24, 0xCF	; 207
   11cb4:	95 e0       	ldi	r25, 0x05	; 5
   11cb6:	68 e2       	ldi	r22, 0x28	; 40
   11cb8:	0e 94 40 2e 	call	0x5c80	; 0x5c80 <AddSpaceLag>
   11cbc:	20 e0       	ldi	r18, 0x00	; 0
   11cbe:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   11cc0:	f9 01       	movw	r30, r18
   11cc2:	e9 56       	subi	r30, 0x69	; 105
   11cc4:	f5 4f       	sbci	r31, 0xF5	; 245
   11cc6:	d9 01       	movw	r26, r18
   11cc8:	a1 53       	subi	r26, 0x31	; 49
   11cca:	ba 4f       	sbci	r27, 0xFA	; 250
   11ccc:	8c 91       	ld	r24, X
   11cce:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   11cd0:	2f 5f       	subi	r18, 0xFF	; 255
   11cd2:	3f 4f       	sbci	r19, 0xFF	; 255
   11cd4:	24 31       	cpi	r18, 0x14	; 20
   11cd6:	31 05       	cpc	r19, r1
   11cd8:	99 f7       	brne	.-26     	; 0x11cc0 <FMenuSettingHeader+0x152>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   11cda:	10 92 ab 0a 	sts	0x0AAB, r1
   11cde:	e3 ee       	ldi	r30, 0xE3	; 227
   11ce0:	f5 e0       	ldi	r31, 0x05	; 5
   11ce2:	a6 e8       	ldi	r26, 0x86	; 134
   11ce4:	b9 e0       	ldi	r27, 0x09	; 9
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   11ce6:	81 91       	ld	r24, Z+
   11ce8:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   11cea:	85 e0       	ldi	r24, 0x05	; 5
   11cec:	e7 3f       	cpi	r30, 0xF7	; 247
   11cee:	f8 07       	cpc	r31, r24
   11cf0:	d1 f7       	brne	.-12     	; 0x11ce6 <FMenuSettingHeader+0x178>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   11cf2:	10 92 9a 09 	sts	0x099A, r1
			  lcd_clear();
			  AddSpaceLag(PrintBuffer,40);
			  StrPosCopy(PrintBuffer,strFreeMessageLine1,0,20);
			  StrPosCopy(PrintBuffer,strFreeMessageLine2,20,20);

			  lcd_print(1,1,strFreeMessageLine1);			  
   11cf6:	81 e0       	ldi	r24, 0x01	; 1
   11cf8:	61 e0       	ldi	r22, 0x01	; 1
   11cfa:	47 e9       	ldi	r20, 0x97	; 151
   11cfc:	5a e0       	ldi	r21, 0x0A	; 10
   11cfe:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
			  lcd_print(2,1,strFreeMessageLine2);			  
   11d02:	82 e0       	ldi	r24, 0x02	; 2
   11d04:	61 e0       	ldi	r22, 0x01	; 1
   11d06:	46 e8       	ldi	r20, 0x86	; 134
   11d08:	59 e0       	ldi	r21, 0x09	; 9
   11d0a:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
			  
			  lcd_printf(3,1,PSTR("Align Center?"));
   11d0e:	83 e0       	ldi	r24, 0x03	; 3
   11d10:	61 e0       	ldi	r22, 0x01	; 1
   11d12:	4b e4       	ldi	r20, 0x4B	; 75
   11d14:	54 e1       	ldi	r21, 0x14	; 20
   11d16:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
			  lcd_printf(4,1,PSTR("[*]No  [#]Yes"));
   11d1a:	84 e0       	ldi	r24, 0x04	; 4
   11d1c:	61 e0       	ldi	r22, 0x01	; 1
   11d1e:	4d e3       	ldi	r20, 0x3D	; 61
   11d20:	54 e1       	ldi	r21, 0x14	; 20
   11d22:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		      stSettingHeader=shIsAlignCenter;
   11d26:	85 e0       	ldi	r24, 0x05	; 5
   11d28:	7e c0       	rjmp	.+252    	; 0x11e26 <FMenuSettingHeader+0x2b8>
		  }
		  else
		  if (uiResult==USER_CANCEL)stSettingHeader=shInitHeader;
   11d2a:	81 30       	cpi	r24, 0x01	; 1
   11d2c:	09 f0       	breq	.+2      	; 0x11d30 <FMenuSettingHeader+0x1c2>
   11d2e:	c0 c0       	rjmp	.+384    	; 0x11eb0 <FMenuSettingHeader+0x342>
   11d30:	b8 c0       	rjmp	.+368    	; 0x11ea2 <FMenuSettingHeader+0x334>
	      break;
     case shIsAlignCenter:
	      KeyChar=_key_btn(_key_scan(1));
   11d32:	81 e0       	ldi	r24, 0x01	; 1
   11d34:	0e 94 06 b0 	call	0x1600c	; 0x1600c <_key_scan>
   11d38:	0e 94 67 af 	call	0x15ece	; 0x15ece <_key_btn>
   11d3c:	80 93 1b 03 	sts	0x031B, r24
          if(KeyChar=='#'){
   11d40:	83 32       	cpi	r24, 0x23	; 35
   11d42:	39 f4       	brne	.+14     	; 0x11d52 <FMenuSettingHeader+0x1e4>
		      //AlignCenter			  
			  StrAlignCenter(PrintBuffer,40);
   11d44:	8f ec       	ldi	r24, 0xCF	; 207
   11d46:	95 e0       	ldi	r25, 0x05	; 5
   11d48:	68 e2       	ldi	r22, 0x28	; 40
   11d4a:	70 e0       	ldi	r23, 0x00	; 0
   11d4c:	0e 94 4a 30 	call	0x6094	; 0x6094 <StrAlignCenter>
   11d50:	03 c0       	rjmp	.+6      	; 0x11d58 <FMenuSettingHeader+0x1ea>
			  stSettingHeader=shIsSaveHeader;
		  } else if(KeyChar=='*')stSettingHeader=shIsSaveHeader;		 
   11d52:	8a 32       	cpi	r24, 0x2A	; 42
   11d54:	09 f0       	breq	.+2      	; 0x11d58 <FMenuSettingHeader+0x1ea>
   11d56:	ac c0       	rjmp	.+344    	; 0x11eb0 <FMenuSettingHeader+0x342>
   11d58:	86 e0       	ldi	r24, 0x06	; 6
   11d5a:	65 c0       	rjmp	.+202    	; 0x11e26 <FMenuSettingHeader+0x2b8>
	      break;
     case shIsSaveHeader:
	      lcd_clear(); 
   11d5c:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
   11d60:	20 e0       	ldi	r18, 0x00	; 0
   11d62:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   11d64:	f9 01       	movw	r30, r18
   11d66:	e9 56       	subi	r30, 0x69	; 105
   11d68:	f5 4f       	sbci	r31, 0xF5	; 245
   11d6a:	d9 01       	movw	r26, r18
   11d6c:	a1 53       	subi	r26, 0x31	; 49
   11d6e:	ba 4f       	sbci	r27, 0xFA	; 250
   11d70:	8c 91       	ld	r24, X
   11d72:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   11d74:	2f 5f       	subi	r18, 0xFF	; 255
   11d76:	3f 4f       	sbci	r19, 0xFF	; 255
   11d78:	24 31       	cpi	r18, 0x14	; 20
   11d7a:	31 05       	cpc	r19, r1
   11d7c:	99 f7       	brne	.-26     	; 0x11d64 <FMenuSettingHeader+0x1f6>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   11d7e:	10 92 ab 0a 	sts	0x0AAB, r1
   11d82:	e3 ee       	ldi	r30, 0xE3	; 227
   11d84:	f5 e0       	ldi	r31, 0x05	; 5
   11d86:	a6 e8       	ldi	r26, 0x86	; 134
   11d88:	b9 e0       	ldi	r27, 0x09	; 9
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   11d8a:	81 91       	ld	r24, Z+
   11d8c:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   11d8e:	95 e0       	ldi	r25, 0x05	; 5
   11d90:	e7 3f       	cpi	r30, 0xF7	; 247
   11d92:	f9 07       	cpc	r31, r25
   11d94:	d1 f7       	brne	.-12     	; 0x11d8a <FMenuSettingHeader+0x21c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   11d96:	10 92 9a 09 	sts	0x099A, r1
	      break;
     case shIsSaveHeader:
	      lcd_clear(); 
		  StrPosCopy(PrintBuffer,strFreeMessageLine1,0,20);
		  StrPosCopy(PrintBuffer,strFreeMessageLine2,20,20);
          lcd_print(1,1,strFreeMessageLine1);
   11d9a:	81 e0       	ldi	r24, 0x01	; 1
   11d9c:	61 e0       	ldi	r22, 0x01	; 1
   11d9e:	47 e9       	ldi	r20, 0x97	; 151
   11da0:	5a e0       	ldi	r21, 0x0A	; 10
   11da2:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
		  lcd_print(2,1,strFreeMessageLine2);
   11da6:	82 e0       	ldi	r24, 0x02	; 2
   11da8:	61 e0       	ldi	r22, 0x01	; 1
   11daa:	46 e8       	ldi	r20, 0x86	; 134
   11dac:	59 e0       	ldi	r21, 0x09	; 9
   11dae:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
		  sprintf_P(lcdteks,PSTR("Save Header%d ?"),HeaderIdx+1);
   11db2:	00 d0       	rcall	.+0      	; 0x11db4 <FMenuSettingHeader+0x246>
   11db4:	00 d0       	rcall	.+0      	; 0x11db6 <FMenuSettingHeader+0x248>
   11db6:	00 d0       	rcall	.+0      	; 0x11db8 <FMenuSettingHeader+0x24a>
   11db8:	ed b7       	in	r30, 0x3d	; 61
   11dba:	fe b7       	in	r31, 0x3e	; 62
   11dbc:	31 96       	adiw	r30, 0x01	; 1
   11dbe:	8e 01       	movw	r16, r28
   11dc0:	0f 5f       	subi	r16, 0xFF	; 255
   11dc2:	1f 4f       	sbci	r17, 0xFF	; 255
   11dc4:	ad b7       	in	r26, 0x3d	; 61
   11dc6:	be b7       	in	r27, 0x3e	; 62
   11dc8:	12 96       	adiw	r26, 0x02	; 2
   11dca:	1c 93       	st	X, r17
   11dcc:	0e 93       	st	-X, r16
   11dce:	11 97       	sbiw	r26, 0x01	; 1
   11dd0:	8d e2       	ldi	r24, 0x2D	; 45
   11dd2:	94 e1       	ldi	r25, 0x14	; 20
   11dd4:	93 83       	std	Z+3, r25	; 0x03
   11dd6:	82 83       	std	Z+2, r24	; 0x02
   11dd8:	80 91 1c 03 	lds	r24, 0x031C
   11ddc:	90 e0       	ldi	r25, 0x00	; 0
   11dde:	01 96       	adiw	r24, 0x01	; 1
   11de0:	95 83       	std	Z+5, r25	; 0x05
   11de2:	84 83       	std	Z+4, r24	; 0x04
   11de4:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
		  lcd_print(3,1,lcdteks);
   11de8:	8d b7       	in	r24, 0x3d	; 61
   11dea:	9e b7       	in	r25, 0x3e	; 62
   11dec:	06 96       	adiw	r24, 0x06	; 6
   11dee:	0f b6       	in	r0, 0x3f	; 63
   11df0:	f8 94       	cli
   11df2:	9e bf       	out	0x3e, r25	; 62
   11df4:	0f be       	out	0x3f, r0	; 63
   11df6:	8d bf       	out	0x3d, r24	; 61
   11df8:	83 e0       	ldi	r24, 0x03	; 3
   11dfa:	61 e0       	ldi	r22, 0x01	; 1
   11dfc:	a8 01       	movw	r20, r16
   11dfe:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
		  lcd_printf(4,1,PSTR("[*]No [#]Yes"));		      
   11e02:	84 e0       	ldi	r24, 0x04	; 4
   11e04:	61 e0       	ldi	r22, 0x01	; 1
   11e06:	40 e2       	ldi	r20, 0x20	; 32
   11e08:	54 e1       	ldi	r21, 0x14	; 20
   11e0a:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
	      stSettingHeader=shSaveHeaderQuestions;      
   11e0e:	84 e0       	ldi	r24, 0x04	; 4
   11e10:	0a c0       	rjmp	.+20     	; 0x11e26 <FMenuSettingHeader+0x2b8>
	      break;    
     case shSaveHeaderQuestions:
	      KeyChar=_key_btn(_key_scan(1));
   11e12:	81 e0       	ldi	r24, 0x01	; 1
   11e14:	0e 94 06 b0 	call	0x1600c	; 0x1600c <_key_scan>
   11e18:	0e 94 67 af 	call	0x15ece	; 0x15ece <_key_btn>
   11e1c:	80 93 1b 03 	sts	0x031B, r24
	      if(KeyChar=='#')stSettingHeader=shSaveHeader;
   11e20:	83 32       	cpi	r24, 0x23	; 35
   11e22:	21 f4       	brne	.+8      	; 0x11e2c <FMenuSettingHeader+0x2be>
   11e24:	87 e0       	ldi	r24, 0x07	; 7
   11e26:	80 93 1d 03 	sts	0x031D, r24
   11e2a:	42 c0       	rjmp	.+132    	; 0x11eb0 <FMenuSettingHeader+0x342>
		  else
          if(KeyChar=='*')stSettingHeader=shInitHeader;
   11e2c:	8a 32       	cpi	r24, 0x2A	; 42
   11e2e:	09 f0       	breq	.+2      	; 0x11e32 <FMenuSettingHeader+0x2c4>
   11e30:	3f c0       	rjmp	.+126    	; 0x11eb0 <FMenuSettingHeader+0x342>
   11e32:	37 c0       	rjmp	.+110    	; 0x11ea2 <FMenuSettingHeader+0x334>
	      break;
     case shSaveHeader:
	      sprintf_P(strHeaderFooter,PSTR("%s%s"),strFreeMessageLine1,strFreeMessageLine2);
   11e34:	ad b7       	in	r26, 0x3d	; 61
   11e36:	be b7       	in	r27, 0x3e	; 62
   11e38:	18 97       	sbiw	r26, 0x08	; 8
   11e3a:	0f b6       	in	r0, 0x3f	; 63
   11e3c:	f8 94       	cli
   11e3e:	be bf       	out	0x3e, r27	; 62
   11e40:	0f be       	out	0x3f, r0	; 63
   11e42:	ad bf       	out	0x3d, r26	; 61
   11e44:	ed b7       	in	r30, 0x3d	; 61
   11e46:	fe b7       	in	r31, 0x3e	; 62
   11e48:	31 96       	adiw	r30, 0x01	; 1
   11e4a:	8e 01       	movw	r16, r28
   11e4c:	0b 5e       	subi	r16, 0xEB	; 235
   11e4e:	1f 4f       	sbci	r17, 0xFF	; 255
   11e50:	12 96       	adiw	r26, 0x02	; 2
   11e52:	1c 93       	st	X, r17
   11e54:	0e 93       	st	-X, r16
   11e56:	11 97       	sbiw	r26, 0x01	; 1
   11e58:	8b e1       	ldi	r24, 0x1B	; 27
   11e5a:	94 e1       	ldi	r25, 0x14	; 20
   11e5c:	93 83       	std	Z+3, r25	; 0x03
   11e5e:	82 83       	std	Z+2, r24	; 0x02
   11e60:	87 e9       	ldi	r24, 0x97	; 151
   11e62:	9a e0       	ldi	r25, 0x0A	; 10
   11e64:	95 83       	std	Z+5, r25	; 0x05
   11e66:	84 83       	std	Z+4, r24	; 0x04
   11e68:	86 e8       	ldi	r24, 0x86	; 134
   11e6a:	99 e0       	ldi	r25, 0x09	; 9
   11e6c:	97 83       	std	Z+7, r25	; 0x07
   11e6e:	86 83       	std	Z+6, r24	; 0x06
   11e70:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
   11e74:	8d b7       	in	r24, 0x3d	; 61
   11e76:	9e b7       	in	r25, 0x3e	; 62
   11e78:	08 96       	adiw	r24, 0x08	; 8
   11e7a:	0f b6       	in	r0, 0x3f	; 63
   11e7c:	f8 94       	cli
   11e7e:	9e bf       	out	0x3e, r25	; 62
   11e80:	0f be       	out	0x3f, r0	; 63
   11e82:	8d bf       	out	0x3d, r24	; 61
   11e84:	80 91 1c 03 	lds	r24, 0x031C
   11e88:	29 e2       	ldi	r18, 0x29	; 41
   11e8a:	82 9f       	mul	r24, r18
   11e8c:	c0 01       	movw	r24, r0
   11e8e:	11 24       	eor	r1, r1
   11e90:	89 5d       	subi	r24, 0xD9	; 217
   11e92:	9d 4f       	sbci	r25, 0xFD	; 253
   11e94:	b8 01       	movw	r22, r16
   11e96:	48 e2       	ldi	r20, 0x28	; 40
   11e98:	50 e0       	ldi	r21, 0x00	; 0
   11e9a:	2e ef       	ldi	r18, 0xFE	; 254
   11e9c:	32 e1       	ldi	r19, 0x12	; 18
   11e9e:	0e 94 96 b5 	call	0x16b2c	; 0x16b2c <__eewr_block>
	      eeprom_write_block((const void*) &strHeaderFooter, (void*) &DefHeaderFooter[HeaderIdx],40);
		  //eeprom_write_block((const void*) &PrintBuffer, (void*) &DefHeaderFooter[HeaderIdx],40);
          stSettingHeader=shInitHeader;
   11ea2:	10 92 1d 03 	sts	0x031D, r1
   11ea6:	04 c0       	rjmp	.+8      	; 0x11eb0 <FMenuSettingHeader+0x342>
	      break;
     case shExitSettingHeader:
          stSettingHeader=shInitHeader;
   11ea8:	10 92 1d 03 	sts	0x031D, r1
   11eac:	81 e0       	ldi	r24, 0x01	; 1
   11eae:	01 c0       	rjmp	.+2      	; 0x11eb2 <FMenuSettingHeader+0x344>
   11eb0:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;	 
	 }
   //_menu_header();   
   return Result;
}
   11eb2:	ca 5b       	subi	r28, 0xBA	; 186
   11eb4:	df 4f       	sbci	r29, 0xFF	; 255
   11eb6:	0f b6       	in	r0, 0x3f	; 63
   11eb8:	f8 94       	cli
   11eba:	de bf       	out	0x3e, r29	; 62
   11ebc:	0f be       	out	0x3f, r0	; 63
   11ebe:	cd bf       	out	0x3d, r28	; 61
   11ec0:	cf 91       	pop	r28
   11ec2:	df 91       	pop	r29
   11ec4:	1f 91       	pop	r17
   11ec6:	0f 91       	pop	r16
   11ec8:	ef 90       	pop	r14
   11eca:	08 95       	ret

00011ecc <FMenuAdminSettings>:

char FMenuAdminSettings(){
     static char stAdminSettings=asInitMenu;
	 char SubMenu,Result,KeyChar;
	 Result=MENU_NONE;
	 switch(stAdminSettings){
   11ecc:	80 91 1e 03 	lds	r24, 0x031E
   11ed0:	83 30       	cpi	r24, 0x03	; 3
   11ed2:	09 f4       	brne	.+2      	; 0x11ed6 <FMenuAdminSettings+0xa>
   11ed4:	6e c0       	rjmp	.+220    	; 0x11fb2 <FMenuAdminSettings+0xe6>
   11ed6:	84 30       	cpi	r24, 0x04	; 4
   11ed8:	30 f4       	brcc	.+12     	; 0x11ee6 <FMenuAdminSettings+0x1a>
   11eda:	81 30       	cpi	r24, 0x01	; 1
   11edc:	e9 f1       	breq	.+122    	; 0x11f58 <FMenuAdminSettings+0x8c>
   11ede:	82 30       	cpi	r24, 0x02	; 2
   11ee0:	08 f0       	brcs	.+2      	; 0x11ee4 <FMenuAdminSettings+0x18>
   11ee2:	64 c0       	rjmp	.+200    	; 0x11fac <FMenuAdminSettings+0xe0>
   11ee4:	0d c0       	rjmp	.+26     	; 0x11f00 <FMenuAdminSettings+0x34>
   11ee6:	85 30       	cpi	r24, 0x05	; 5
   11ee8:	09 f4       	brne	.+2      	; 0x11eec <FMenuAdminSettings+0x20>
   11eea:	66 c0       	rjmp	.+204    	; 0x11fb8 <FMenuAdminSettings+0xec>
   11eec:	85 30       	cpi	r24, 0x05	; 5
   11eee:	08 f4       	brcc	.+2      	; 0x11ef2 <FMenuAdminSettings+0x26>
   11ef0:	6a c0       	rjmp	.+212    	; 0x11fc6 <FMenuAdminSettings+0xfa>
   11ef2:	86 30       	cpi	r24, 0x06	; 6
   11ef4:	09 f4       	brne	.+2      	; 0x11ef8 <FMenuAdminSettings+0x2c>
   11ef6:	63 c0       	rjmp	.+198    	; 0x11fbe <FMenuAdminSettings+0xf2>
   11ef8:	87 30       	cpi	r24, 0x07	; 7
   11efa:	09 f0       	breq	.+2      	; 0x11efe <FMenuAdminSettings+0x32>
   11efc:	6c c0       	rjmp	.+216    	; 0x11fd6 <FMenuAdminSettings+0x10a>
   11efe:	67 c0       	rjmp	.+206    	; 0x11fce <FMenuAdminSettings+0x102>
	 case asInitMenu:
          lcd_clear();
   11f00:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
		  if (IFType==IT_SLAVE){
   11f04:	80 91 10 01 	lds	r24, 0x0110
   11f08:	81 30       	cpi	r24, 0x01	; 1
   11f0a:	51 f4       	brne	.+20     	; 0x11f20 <FMenuAdminSettings+0x54>
		      lcd_printf(1,1, PSTR("1)Header    4)Client"));
   11f0c:	61 e0       	ldi	r22, 0x01	; 1
   11f0e:	46 e2       	ldi	r20, 0x26	; 38
   11f10:	55 e1       	ldi	r21, 0x15	; 21
   11f12:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		      lcd_printf(2,1, PSTR("2)Footer    5)Server"));
   11f16:	82 e0       	ldi	r24, 0x02	; 2
   11f18:	61 e0       	ldi	r22, 0x01	; 1
   11f1a:	41 e1       	ldi	r20, 0x11	; 17
   11f1c:	55 e1       	ldi	r21, 0x15	; 21
   11f1e:	0c c0       	rjmp	.+24     	; 0x11f38 <FMenuAdminSettings+0x6c>
		  }else
		  if (IFType==IT_STANDALONE){
   11f20:	82 30       	cpi	r24, 0x02	; 2
   11f22:	61 f4       	brne	.+24     	; 0x11f3c <FMenuAdminSettings+0x70>
		      lcd_printf(1,1, PSTR("1)Header            "));
   11f24:	81 e0       	ldi	r24, 0x01	; 1
   11f26:	61 e0       	ldi	r22, 0x01	; 1
   11f28:	4c ef       	ldi	r20, 0xFC	; 252
   11f2a:	54 e1       	ldi	r21, 0x14	; 20
   11f2c:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		      lcd_printf(2,1, PSTR("2)Footer            "));
   11f30:	82 e0       	ldi	r24, 0x02	; 2
   11f32:	61 e0       	ldi	r22, 0x01	; 1
   11f34:	47 ee       	ldi	r20, 0xE7	; 231
   11f36:	54 e1       	ldi	r21, 0x14	; 20
   11f38:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		  }
		  lcd_printf(3,1, PSTR("3)Password          "));
   11f3c:	83 e0       	ldi	r24, 0x03	; 3
   11f3e:	61 e0       	ldi	r22, 0x01	; 1
   11f40:	42 ed       	ldi	r20, 0xD2	; 210
   11f42:	54 e1       	ldi	r21, 0x14	; 20
   11f44:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		  lcd_printf(4,1, PSTR("*)Exit"));
   11f48:	84 e0       	ldi	r24, 0x04	; 4
   11f4a:	61 e0       	ldi	r22, 0x01	; 1
   11f4c:	4b ec       	ldi	r20, 0xCB	; 203
   11f4e:	54 e1       	ldi	r21, 0x14	; 20
   11f50:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		  stAdminSettings=asAdminSettingsOption;
   11f54:	81 e0       	ldi	r24, 0x01	; 1
   11f56:	27 c0       	rjmp	.+78     	; 0x11fa6 <FMenuAdminSettings+0xda>
		  break;
     case asAdminSettingsOption:
	      KeyChar=_key_btn(_key_scan(1));
   11f58:	81 e0       	ldi	r24, 0x01	; 1
   11f5a:	0e 94 06 b0 	call	0x1600c	; 0x1600c <_key_scan>
   11f5e:	0e 94 67 af 	call	0x15ece	; 0x15ece <_key_btn>
   11f62:	98 2f       	mov	r25, r24
		  switch(KeyChar){
   11f64:	82 33       	cpi	r24, 0x32	; 50
   11f66:	61 f0       	breq	.+24     	; 0x11f80 <FMenuAdminSettings+0xb4>
   11f68:	83 33       	cpi	r24, 0x33	; 51
   11f6a:	28 f4       	brcc	.+10     	; 0x11f76 <FMenuAdminSettings+0xaa>
   11f6c:	8a 32       	cpi	r24, 0x2A	; 42
   11f6e:	61 f0       	breq	.+24     	; 0x11f88 <FMenuAdminSettings+0xbc>
   11f70:	81 33       	cpi	r24, 0x31	; 49
   11f72:	69 f4       	brne	.+26     	; 0x11f8e <FMenuAdminSettings+0xc2>
   11f74:	03 c0       	rjmp	.+6      	; 0x11f7c <FMenuAdminSettings+0xb0>
   11f76:	83 33       	cpi	r24, 0x33	; 51
   11f78:	51 f4       	brne	.+20     	; 0x11f8e <FMenuAdminSettings+0xc2>
   11f7a:	04 c0       	rjmp	.+8      	; 0x11f84 <FMenuAdminSettings+0xb8>
		  case '1':stAdminSettings=asAdminSettingHeader;
   11f7c:	82 e0       	ldi	r24, 0x02	; 2
   11f7e:	05 c0       	rjmp	.+10     	; 0x11f8a <FMenuAdminSettings+0xbe>
		       break;
		  case '2':stAdminSettings=asAdminSettingFooter;
   11f80:	83 e0       	ldi	r24, 0x03	; 3
   11f82:	03 c0       	rjmp	.+6      	; 0x11f8a <FMenuAdminSettings+0xbe>
		       break;
		  case '3':stAdminSettings=asAdminSettingPassword;
   11f84:	84 e0       	ldi	r24, 0x04	; 4
   11f86:	01 c0       	rjmp	.+2      	; 0x11f8a <FMenuAdminSettings+0xbe>
		       break;
		  case '*':stAdminSettings=asExitAdminSetting;
   11f88:	87 e0       	ldi	r24, 0x07	; 7
   11f8a:	80 93 1e 03 	sts	0x031E, r24
		       break;			   
		  }
		  if (IFType==IT_SLAVE){
   11f8e:	80 91 10 01 	lds	r24, 0x0110
   11f92:	81 30       	cpi	r24, 0x01	; 1
   11f94:	01 f5       	brne	.+64     	; 0x11fd6 <FMenuAdminSettings+0x10a>
			  switch(KeyChar){
   11f96:	94 33       	cpi	r25, 0x34	; 52
   11f98:	19 f0       	breq	.+6      	; 0x11fa0 <FMenuAdminSettings+0xd4>
   11f9a:	95 33       	cpi	r25, 0x35	; 53
   11f9c:	e1 f4       	brne	.+56     	; 0x11fd6 <FMenuAdminSettings+0x10a>
   11f9e:	02 c0       	rjmp	.+4      	; 0x11fa4 <FMenuAdminSettings+0xd8>
			  case '4':stAdminSettings=asAdminSettingClientIP;
   11fa0:	85 e0       	ldi	r24, 0x05	; 5
   11fa2:	01 c0       	rjmp	.+2      	; 0x11fa6 <FMenuAdminSettings+0xda>
				   break;
			  case '5':stAdminSettings=asAdminSettingServerIP;
   11fa4:	86 e0       	ldi	r24, 0x06	; 6
   11fa6:	80 93 1e 03 	sts	0x031E, r24
   11faa:	0f c0       	rjmp	.+30     	; 0x11fca <FMenuAdminSettings+0xfe>
				   break;
			  }
		  }
	      break;
	 case asAdminSettingHeader:
	      SubMenu=FMenuSettingHeader();
   11fac:	0e 94 b7 8d 	call	0x11b6e	; 0x11b6e <FMenuSettingHeader>
   11fb0:	08 c0       	rjmp	.+16     	; 0x11fc2 <FMenuAdminSettings+0xf6>
	      if (SubMenu==MENU_DONE)stAdminSettings=asInitMenu;
	      break;
	 case asAdminSettingFooter:
	      SubMenu=FMenuSettingFooter();
   11fb2:	0e 94 08 8c 	call	0x11810	; 0x11810 <FMenuSettingFooter>
   11fb6:	05 c0       	rjmp	.+10     	; 0x11fc2 <FMenuAdminSettings+0xf6>
	 case asAdminSettingPassword:
	      SubMenu=FMenuSettingPassword();
	      if (SubMenu==MENU_DONE)stAdminSettings=asInitMenu;	 
	      break;
     case asAdminSettingClientIP:
	      SubMenu=FMenuSettingClientIP();
   11fb8:	0e 94 c2 6c 	call	0xd984	; 0xd984 <FMenuSettingClientIP>
   11fbc:	02 c0       	rjmp	.+4      	; 0x11fc2 <FMenuAdminSettings+0xf6>
	      if (SubMenu==MENU_DONE)stAdminSettings=asInitMenu;	 
	      break;
	 case asAdminSettingServerIP:
	      SubMenu=FMenuSettingServerIP();
   11fbe:	0e 94 38 6a 	call	0xd470	; 0xd470 <FMenuSettingServerIP>
	      if (SubMenu==MENU_DONE)stAdminSettings=asInitMenu;	 
   11fc2:	81 30       	cpi	r24, 0x01	; 1
   11fc4:	41 f4       	brne	.+16     	; 0x11fd6 <FMenuAdminSettings+0x10a>
   11fc6:	10 92 1e 03 	sts	0x031E, r1
   11fca:	80 e0       	ldi	r24, 0x00	; 0
   11fcc:	08 95       	ret
	      break;
     case asExitAdminSetting:
	      stAdminSettings=asInitMenu;
   11fce:	10 92 1e 03 	sts	0x031E, r1
   11fd2:	81 e0       	ldi	r24, 0x01	; 1
   11fd4:	08 95       	ret
   11fd6:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
   return Result;
}
   11fd8:	08 95       	ret

00011fda <FMenuMaster>:
     else Result=RC_INVALID;

   return Result;
}

char FMenuMaster(){ 
   11fda:	ef 92       	push	r14
   11fdc:	ff 92       	push	r15
   11fde:	0f 93       	push	r16
   11fe0:	1f 93       	push	r17
   11fe2:	df 93       	push	r29
   11fe4:	cf 93       	push	r28
   11fe6:	cd b7       	in	r28, 0x3d	; 61
   11fe8:	de b7       	in	r29, 0x3e	; 62
   11fea:	e2 97       	sbiw	r28, 0x32	; 50
   11fec:	0f b6       	in	r0, 0x3f	; 63
   11fee:	f8 94       	cli
   11ff0:	de bf       	out	0x3e, r29	; 62
   11ff2:	0f be       	out	0x3f, r0	; 63
   11ff4:	cd bf       	out	0x3d, r28	; 61
static char stMenuMaster=mmInitMaster;
     char KeyPressed,KeyChar,Result=MENU_NONE;
	 char uiResult,lcdteks[20],PTime[10],PDate[10],strNewPassword[10];
	 char strSend[20];

	 switch(stMenuMaster){
   11ff6:	80 91 23 03 	lds	r24, 0x0323
   11ffa:	e8 2f       	mov	r30, r24
   11ffc:	f0 e0       	ldi	r31, 0x00	; 0
   11ffe:	e1 31       	cpi	r30, 0x11	; 17
   12000:	f1 05       	cpc	r31, r1
   12002:	08 f0       	brcs	.+2      	; 0x12006 <FMenuMaster+0x2c>
   12004:	f3 c1       	rjmp	.+998    	; 0x123ec <FMenuMaster+0x412>
   12006:	ed 54       	subi	r30, 0x4D	; 77
   12008:	ff 4f       	sbci	r31, 0xFF	; 255
   1200a:	ee 0f       	add	r30, r30
   1200c:	ff 1f       	adc	r31, r31
   1200e:	05 90       	lpm	r0, Z+
   12010:	f4 91       	lpm	r31, Z+
   12012:	e0 2d       	mov	r30, r0
   12014:	09 94       	ijmp
	 case mmInitMaster:
	      lcd_clear();
   12016:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
		  lcd_printf(1,1,PSTR("-System Admin Level-"));
   1201a:	81 e0       	ldi	r24, 0x01	; 1
   1201c:	61 e0       	ldi	r22, 0x01	; 1
   1201e:	4c e9       	ldi	r20, 0x9C	; 156
   12020:	57 e1       	ldi	r21, 0x17	; 23
   12022:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		  lcd_printf(2,1,PSTR("1.Restore Password  "));
   12026:	82 e0       	ldi	r24, 0x02	; 2
   12028:	61 e0       	ldi	r22, 0x01	; 1
   1202a:	47 e8       	ldi	r20, 0x87	; 135
   1202c:	57 e1       	ldi	r21, 0x17	; 23
   1202e:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		  lcd_printf(3,1,PSTR("2.Change Password   "));
   12032:	83 e0       	ldi	r24, 0x03	; 3
   12034:	61 e0       	ldi	r22, 0x01	; 1
   12036:	42 e7       	ldi	r20, 0x72	; 114
   12038:	57 e1       	ldi	r21, 0x17	; 23
   1203a:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		  lcd_printf(4,1,PSTR("[*]Exit             "));
   1203e:	84 e0       	ldi	r24, 0x04	; 4
   12040:	61 e0       	ldi	r22, 0x01	; 1
   12042:	4d e5       	ldi	r20, 0x5D	; 93
   12044:	57 e1       	ldi	r21, 0x17	; 23
   12046:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>

		  //_uart_printf(1,1,PSTR("-System Admin Level-"));

		  stMenuMaster=mmMasterSelect;
   1204a:	81 e0       	ldi	r24, 0x01	; 1
   1204c:	f6 c0       	rjmp	.+492    	; 0x1223a <FMenuMaster+0x260>
	      break;
     case mmMasterSelect:
	 	  KeyPressed=_key_scan(1);
   1204e:	81 e0       	ldi	r24, 0x01	; 1
   12050:	0e 94 06 b0 	call	0x1600c	; 0x1600c <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
   12054:	0e 94 67 af 	call	0x15ece	; 0x15ece <_key_btn>
          switch(KeyChar){
   12058:	81 33       	cpi	r24, 0x31	; 49
   1205a:	09 f4       	brne	.+2      	; 0x1205e <FMenuMaster+0x84>
   1205c:	ed c0       	rjmp	.+474    	; 0x12238 <FMenuMaster+0x25e>
   1205e:	82 33       	cpi	r24, 0x32	; 50
   12060:	21 f0       	breq	.+8      	; 0x1206a <FMenuMaster+0x90>
   12062:	8a 32       	cpi	r24, 0x2A	; 42
   12064:	09 f0       	breq	.+2      	; 0x12068 <FMenuMaster+0x8e>
   12066:	c2 c1       	rjmp	.+900    	; 0x123ec <FMenuMaster+0x412>
   12068:	bb c1       	rjmp	.+886    	; 0x123e0 <FMenuMaster+0x406>
		  case '1':
               stMenuMaster=mmRestorePasswordMenu;
		       break;
		  case '2':
		       stMenuMaster=mmChangePassword;
   1206a:	8e e0       	ldi	r24, 0x0E	; 14
   1206c:	e6 c0       	rjmp	.+460    	; 0x1223a <FMenuMaster+0x260>
		       stMenuMaster=mmExitMaster;
		       break;
		  }
	      break;
     case mmChangePassword:
	      stMenuMaster=mmInitMaster;
   1206e:	10 92 23 03 	sts	0x0323, r1
   12072:	bc c1       	rjmp	.+888    	; 0x123ec <FMenuMaster+0x412>
	      break;
     case mmRestorePasswordMenu:	      
	      lcd_clear();
   12074:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
		  lcd_printf(1,1,PSTR("Enter GeNiUs Code   "));
   12078:	81 e0       	ldi	r24, 0x01	; 1
   1207a:	61 e0       	ldi	r22, 0x01	; 1
   1207c:	48 e4       	ldi	r20, 0x48	; 72
   1207e:	57 e1       	ldi	r21, 0x17	; 23
   12080:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		  lcd_printf(2,1,PSTR("_                   "));
   12084:	82 e0       	ldi	r24, 0x02	; 2
   12086:	61 e0       	ldi	r22, 0x01	; 1
   12088:	43 e3       	ldi	r20, 0x33	; 51
   1208a:	57 e1       	ldi	r21, 0x17	; 23
   1208c:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		  lcd_printf(4,4,PSTR("[*]Cancel   [#]Enter"));
   12090:	84 e0       	ldi	r24, 0x04	; 4
   12092:	64 e0       	ldi	r22, 0x04	; 4
   12094:	4e e1       	ldi	r20, 0x1E	; 30
   12096:	57 e1       	ldi	r21, 0x17	; 23
   12098:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		  sprintf_P(strGeniusCode,PSTR(""));
   1209c:	00 d0       	rcall	.+0      	; 0x1209e <FMenuMaster+0xc4>
   1209e:	00 d0       	rcall	.+0      	; 0x120a0 <FMenuMaster+0xc6>
   120a0:	85 e7       	ldi	r24, 0x75	; 117
   120a2:	97 e0       	ldi	r25, 0x07	; 7
   120a4:	ad b7       	in	r26, 0x3d	; 61
   120a6:	be b7       	in	r27, 0x3e	; 62
   120a8:	12 96       	adiw	r26, 0x02	; 2
   120aa:	9c 93       	st	X, r25
   120ac:	8e 93       	st	-X, r24
   120ae:	11 97       	sbiw	r26, 0x01	; 1
   120b0:	8d e1       	ldi	r24, 0x1D	; 29
   120b2:	97 e1       	ldi	r25, 0x17	; 23
   120b4:	14 96       	adiw	r26, 0x04	; 4
   120b6:	9c 93       	st	X, r25
   120b8:	8e 93       	st	-X, r24
   120ba:	13 97       	sbiw	r26, 0x03	; 3
   120bc:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
          stMenuMaster=mmGeniusCodeEntry;
   120c0:	83 e0       	ldi	r24, 0x03	; 3
   120c2:	80 93 23 03 	sts	0x0323, r24
   120c6:	80 e0       	ldi	r24, 0x00	; 0
   120c8:	0f 90       	pop	r0
   120ca:	0f 90       	pop	r0
   120cc:	0f 90       	pop	r0
   120ce:	0f 90       	pop	r0
   120d0:	8e c1       	rjmp	.+796    	; 0x123ee <FMenuMaster+0x414>
	      break;
     case mmGeniusCodeEntry:
	 	  uiResult=UserInput(UI_NUMBER_R,2,1,strGeniusCode,0,10);
   120d2:	81 e0       	ldi	r24, 0x01	; 1
   120d4:	62 e0       	ldi	r22, 0x02	; 2
   120d6:	41 e0       	ldi	r20, 0x01	; 1
   120d8:	25 e7       	ldi	r18, 0x75	; 117
   120da:	37 e0       	ldi	r19, 0x07	; 7
   120dc:	00 e0       	ldi	r16, 0x00	; 0
   120de:	10 e0       	ldi	r17, 0x00	; 0
   120e0:	fa e0       	ldi	r31, 0x0A	; 10
   120e2:	ef 2e       	mov	r14, r31
   120e4:	0e 94 4b 7d 	call	0xfa96	; 0xfa96 <UserInput>
		  switch(uiResult){
   120e8:	83 30       	cpi	r24, 0x03	; 3
   120ea:	49 f0       	breq	.+18     	; 0x120fe <FMenuMaster+0x124>
   120ec:	84 30       	cpi	r24, 0x04	; 4
   120ee:	08 f4       	brcc	.+2      	; 0x120f2 <FMenuMaster+0x118>
   120f0:	f2 c0       	rjmp	.+484    	; 0x122d6 <FMenuMaster+0x2fc>
   120f2:	84 30       	cpi	r24, 0x04	; 4
   120f4:	69 f0       	breq	.+26     	; 0x12110 <FMenuMaster+0x136>
   120f6:	85 30       	cpi	r24, 0x05	; 5
   120f8:	09 f0       	breq	.+2      	; 0x120fc <FMenuMaster+0x122>
   120fa:	78 c1       	rjmp	.+752    	; 0x123ec <FMenuMaster+0x412>
   120fc:	0e c0       	rjmp	.+28     	; 0x1211a <FMenuMaster+0x140>
		  case USER_OK:
               
			   //_uart_printf(1,0,PSTR("GeniusCode: "));
			   //_uart_print(1,1,strGeniusCode);

		       _datetime(0, strSystemDate, strSystemTime);
   120fe:	80 e0       	ldi	r24, 0x00	; 0
   12100:	6a e9       	ldi	r22, 0x9A	; 154
   12102:	75 e0       	ldi	r23, 0x05	; 5
   12104:	49 e7       	ldi	r20, 0x79	; 121
   12106:	5a e0       	ldi	r21, 0x0A	; 10
   12108:	0e 94 d1 b2 	call	0x165a2	; 0x165a2 <_datetime>
               stMenuMaster=mmIsValidGeniusCode;
   1210c:	84 e0       	ldi	r24, 0x04	; 4
   1210e:	95 c0       	rjmp	.+298    	; 0x1223a <FMenuMaster+0x260>
		       break;
          case USER_CANCEL:
		       stMenuMaster=mmExitMaster;
		       break;
		  case USER_ENTRY:
		       lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   12110:	84 e0       	ldi	r24, 0x04	; 4
   12112:	61 e0       	ldi	r22, 0x01	; 1
   12114:	48 e0       	ldi	r20, 0x08	; 8
   12116:	57 e1       	ldi	r21, 0x17	; 23
   12118:	f3 c0       	rjmp	.+486    	; 0x12300 <FMenuMaster+0x326>
		       break;
          case USER_NO_DATA:
		       lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   1211a:	84 e0       	ldi	r24, 0x04	; 4
   1211c:	61 e0       	ldi	r22, 0x01	; 1
   1211e:	43 ef       	ldi	r20, 0xF3	; 243
   12120:	56 e1       	ldi	r21, 0x16	; 22
   12122:	ee c0       	rjmp	.+476    	; 0x12300 <FMenuMaster+0x326>
		       break;
		  }
	      break;
     case mmIsValidGeniusCode:
	      //GetDate
		      sprintf_P(PDate,PSTR("%s"),strSystemDate);
   12124:	00 d0       	rcall	.+0      	; 0x12126 <FMenuMaster+0x14c>
   12126:	00 d0       	rcall	.+0      	; 0x12128 <FMenuMaster+0x14e>
   12128:	00 d0       	rcall	.+0      	; 0x1212a <FMenuMaster+0x150>
   1212a:	ed b7       	in	r30, 0x3d	; 61
   1212c:	fe b7       	in	r31, 0x3e	; 62
   1212e:	31 96       	adiw	r30, 0x01	; 1
   12130:	8e 01       	movw	r16, r28
   12132:	05 5f       	subi	r16, 0xF5	; 245
   12134:	1f 4f       	sbci	r17, 0xFF	; 255
   12136:	ad b7       	in	r26, 0x3d	; 61
   12138:	be b7       	in	r27, 0x3e	; 62
   1213a:	12 96       	adiw	r26, 0x02	; 2
   1213c:	1c 93       	st	X, r17
   1213e:	0e 93       	st	-X, r16
   12140:	11 97       	sbiw	r26, 0x01	; 1
   12142:	80 ef       	ldi	r24, 0xF0	; 240
   12144:	96 e1       	ldi	r25, 0x16	; 22
   12146:	93 83       	std	Z+3, r25	; 0x03
   12148:	82 83       	std	Z+2, r24	; 0x02
   1214a:	8a e9       	ldi	r24, 0x9A	; 154
   1214c:	95 e0       	ldi	r25, 0x05	; 5
   1214e:	95 83       	std	Z+5, r25	; 0x05
   12150:	84 83       	std	Z+4, r24	; 0x04
   12152:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
			  RemoveChar(PDate,'/');
   12156:	ed b7       	in	r30, 0x3d	; 61
   12158:	fe b7       	in	r31, 0x3e	; 62
   1215a:	36 96       	adiw	r30, 0x06	; 6
   1215c:	0f b6       	in	r0, 0x3f	; 63
   1215e:	f8 94       	cli
   12160:	fe bf       	out	0x3e, r31	; 62
   12162:	0f be       	out	0x3f, r0	; 63
   12164:	ed bf       	out	0x3d, r30	; 61
   12166:	c8 01       	movw	r24, r16
   12168:	6f e2       	ldi	r22, 0x2F	; 47
   1216a:	0e 94 22 31 	call	0x6244	; 0x6244 <RemoveChar>
		  if (ValidateGeniusCode(PDate,strGeniusCode)==GC_VALID){
   1216e:	c8 01       	movw	r24, r16
   12170:	65 e7       	ldi	r22, 0x75	; 117
   12172:	77 e0       	ldi	r23, 0x07	; 7
   12174:	0e 94 01 6a 	call	0xd402	; 0xd402 <ValidateGeniusCode>
   12178:	81 30       	cpi	r24, 0x01	; 1
   1217a:	09 f0       	breq	.+2      	; 0x1217e <FMenuMaster+0x1a4>
   1217c:	44 c0       	rjmp	.+136    	; 0x12206 <FMenuMaster+0x22c>

		  	  sprintf_P(PTime,PSTR("%s"),strSystemTime);
   1217e:	00 d0       	rcall	.+0      	; 0x12180 <FMenuMaster+0x1a6>
   12180:	00 d0       	rcall	.+0      	; 0x12182 <FMenuMaster+0x1a8>
   12182:	00 d0       	rcall	.+0      	; 0x12184 <FMenuMaster+0x1aa>
   12184:	ed b7       	in	r30, 0x3d	; 61
   12186:	fe b7       	in	r31, 0x3e	; 62
   12188:	31 96       	adiw	r30, 0x01	; 1
   1218a:	8e 01       	movw	r16, r28
   1218c:	0f 5f       	subi	r16, 0xFF	; 255
   1218e:	1f 4f       	sbci	r17, 0xFF	; 255
   12190:	ad b7       	in	r26, 0x3d	; 61
   12192:	be b7       	in	r27, 0x3e	; 62
   12194:	12 96       	adiw	r26, 0x02	; 2
   12196:	1c 93       	st	X, r17
   12198:	0e 93       	st	-X, r16
   1219a:	11 97       	sbiw	r26, 0x01	; 1
   1219c:	8d ee       	ldi	r24, 0xED	; 237
   1219e:	96 e1       	ldi	r25, 0x16	; 22
   121a0:	93 83       	std	Z+3, r25	; 0x03
   121a2:	82 83       	std	Z+2, r24	; 0x02
   121a4:	89 e7       	ldi	r24, 0x79	; 121
   121a6:	9a e0       	ldi	r25, 0x0A	; 10
   121a8:	95 83       	std	Z+5, r25	; 0x05
   121aa:	84 83       	std	Z+4, r24	; 0x04
   121ac:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
			  RemoveChar(PTime,':');sprintf_P(strKeyStamp,PSTR(""));
   121b0:	ed b7       	in	r30, 0x3d	; 61
   121b2:	fe b7       	in	r31, 0x3e	; 62
   121b4:	36 96       	adiw	r30, 0x06	; 6
   121b6:	0f b6       	in	r0, 0x3f	; 63
   121b8:	f8 94       	cli
   121ba:	fe bf       	out	0x3e, r31	; 62
   121bc:	0f be       	out	0x3f, r0	; 63
   121be:	ed bf       	out	0x3d, r30	; 61
   121c0:	c8 01       	movw	r24, r16
   121c2:	6a e3       	ldi	r22, 0x3A	; 58
   121c4:	0e 94 22 31 	call	0x6244	; 0x6244 <RemoveChar>
   121c8:	00 d0       	rcall	.+0      	; 0x121ca <FMenuMaster+0x1f0>
   121ca:	00 d0       	rcall	.+0      	; 0x121cc <FMenuMaster+0x1f2>
   121cc:	e3 eb       	ldi	r30, 0xB3	; 179
   121ce:	ee 2e       	mov	r14, r30
   121d0:	e9 e0       	ldi	r30, 0x09	; 9
   121d2:	fe 2e       	mov	r15, r30
   121d4:	ad b7       	in	r26, 0x3d	; 61
   121d6:	be b7       	in	r27, 0x3e	; 62
   121d8:	12 96       	adiw	r26, 0x02	; 2
   121da:	fc 92       	st	X, r15
   121dc:	ee 92       	st	-X, r14
   121de:	11 97       	sbiw	r26, 0x01	; 1
   121e0:	8c ee       	ldi	r24, 0xEC	; 236
   121e2:	96 e1       	ldi	r25, 0x16	; 22
   121e4:	14 96       	adiw	r26, 0x04	; 4
   121e6:	9c 93       	st	X, r25
   121e8:	8e 93       	st	-X, r24
   121ea:	13 97       	sbiw	r26, 0x03	; 3
   121ec:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>

              //sprintf_P(strSend,PSTR("Time:%s"),PTime);
			  // _uart_print(1,1,strSend);

		      GenerateKeyStamp(PTime,strGeniusCode,strKeyStamp);			  
   121f0:	0f 90       	pop	r0
   121f2:	0f 90       	pop	r0
   121f4:	0f 90       	pop	r0
   121f6:	0f 90       	pop	r0
   121f8:	c8 01       	movw	r24, r16
   121fa:	65 e7       	ldi	r22, 0x75	; 117
   121fc:	77 e0       	ldi	r23, 0x07	; 7
   121fe:	a7 01       	movw	r20, r14
   12200:	0e 94 e3 31 	call	0x63c6	; 0x63c6 <GenerateKeyStamp>
   12204:	d5 c0       	rjmp	.+426    	; 0x123b0 <FMenuMaster+0x3d6>
			  stMenuMaster=mmDisplayKeyStamp;
		  }else stMenuMaster=mmDisplayInvalidCode;
   12206:	85 e0       	ldi	r24, 0x05	; 5
   12208:	18 c0       	rjmp	.+48     	; 0x1223a <FMenuMaster+0x260>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   1220a:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   1220c:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   1220e:	81 e0       	ldi	r24, 0x01	; 1
   12210:	90 e0       	ldi	r25, 0x00	; 0
   12212:	90 93 d7 01 	sts	0x01D7, r25
   12216:	80 93 d6 01 	sts	0x01D6, r24
			  stMenuMaster=mmDisplayKeyStamp;
		  }else stMenuMaster=mmDisplayInvalidCode;
	      break;
     case mmDisplayInvalidCode:
	      system_beep(1);
          lcd_printf(3,1,PSTR("Invalid Code        "));
   1221a:	83 e0       	ldi	r24, 0x03	; 3
   1221c:	61 e0       	ldi	r22, 0x01	; 1
   1221e:	47 ed       	ldi	r20, 0xD7	; 215
   12220:	56 e1       	ldi	r21, 0x16	; 22
   12222:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
          TimDisplay=0; 
   12226:	10 92 a7 01 	sts	0x01A7, r1
		  stMenuMaster=mmDelayDisplayInvalidCode;
   1222a:	86 e0       	ldi	r24, 0x06	; 6
   1222c:	06 c0       	rjmp	.+12     	; 0x1223a <FMenuMaster+0x260>
	      break;
     case mmDelayDisplayInvalidCode:
	      if (TimDisplay>5)stMenuMaster=mmRestorePasswordMenu;
   1222e:	80 91 a7 01 	lds	r24, 0x01A7
   12232:	86 30       	cpi	r24, 0x06	; 6
   12234:	08 f4       	brcc	.+2      	; 0x12238 <FMenuMaster+0x25e>
   12236:	da c0       	rjmp	.+436    	; 0x123ec <FMenuMaster+0x412>
   12238:	82 e0       	ldi	r24, 0x02	; 2
   1223a:	80 93 23 03 	sts	0x0323, r24
   1223e:	d6 c0       	rjmp	.+428    	; 0x123ec <FMenuMaster+0x412>
	      break;
     case mmDisplayKeyStamp:
	      lcd_clear();
   12240:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
		  sprintf_P(lcdteks,PSTR("Key Stamp:%s "),strKeyStamp);
   12244:	00 d0       	rcall	.+0      	; 0x12246 <FMenuMaster+0x26c>
   12246:	00 d0       	rcall	.+0      	; 0x12248 <FMenuMaster+0x26e>
   12248:	00 d0       	rcall	.+0      	; 0x1224a <FMenuMaster+0x270>
   1224a:	ed b7       	in	r30, 0x3d	; 61
   1224c:	fe b7       	in	r31, 0x3e	; 62
   1224e:	31 96       	adiw	r30, 0x01	; 1
   12250:	8e 01       	movw	r16, r28
   12252:	01 5e       	subi	r16, 0xE1	; 225
   12254:	1f 4f       	sbci	r17, 0xFF	; 255
   12256:	ad b7       	in	r26, 0x3d	; 61
   12258:	be b7       	in	r27, 0x3e	; 62
   1225a:	12 96       	adiw	r26, 0x02	; 2
   1225c:	1c 93       	st	X, r17
   1225e:	0e 93       	st	-X, r16
   12260:	11 97       	sbiw	r26, 0x01	; 1
   12262:	89 ec       	ldi	r24, 0xC9	; 201
   12264:	96 e1       	ldi	r25, 0x16	; 22
   12266:	93 83       	std	Z+3, r25	; 0x03
   12268:	82 83       	std	Z+2, r24	; 0x02
   1226a:	83 eb       	ldi	r24, 0xB3	; 179
   1226c:	99 e0       	ldi	r25, 0x09	; 9
   1226e:	95 83       	std	Z+5, r25	; 0x05
   12270:	84 83       	std	Z+4, r24	; 0x04
   12272:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
		  lcd_print(1,1,lcdteks);
   12276:	ed b7       	in	r30, 0x3d	; 61
   12278:	fe b7       	in	r31, 0x3e	; 62
   1227a:	36 96       	adiw	r30, 0x06	; 6
   1227c:	0f b6       	in	r0, 0x3f	; 63
   1227e:	f8 94       	cli
   12280:	fe bf       	out	0x3e, r31	; 62
   12282:	0f be       	out	0x3f, r0	; 63
   12284:	ed bf       	out	0x3d, r30	; 61
   12286:	81 e0       	ldi	r24, 0x01	; 1
   12288:	61 e0       	ldi	r22, 0x01	; 1
   1228a:	a8 01       	movw	r20, r16
   1228c:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
		  lcd_printf(2,1,PSTR("Enter Restore Code  "));
   12290:	82 e0       	ldi	r24, 0x02	; 2
   12292:	61 e0       	ldi	r22, 0x01	; 1
   12294:	44 eb       	ldi	r20, 0xB4	; 180
   12296:	56 e1       	ldi	r21, 0x16	; 22
   12298:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		  lcd_printf(3,1,PSTR("_                   "));
   1229c:	83 e0       	ldi	r24, 0x03	; 3
   1229e:	61 e0       	ldi	r22, 0x01	; 1
   122a0:	4f e9       	ldi	r20, 0x9F	; 159
   122a2:	56 e1       	ldi	r21, 0x16	; 22
   122a4:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		  lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   122a8:	84 e0       	ldi	r24, 0x04	; 4
   122aa:	61 e0       	ldi	r22, 0x01	; 1
   122ac:	4a e8       	ldi	r20, 0x8A	; 138
   122ae:	56 e1       	ldi	r21, 0x16	; 22
   122b0:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
          stMenuMaster=mmRestoreCodeEntry;
   122b4:	88 e0       	ldi	r24, 0x08	; 8
   122b6:	c1 cf       	rjmp	.-126    	; 0x1223a <FMenuMaster+0x260>
	      break;
     case mmRestoreCodeEntry:
	 	  uiResult=UserInput(UI_NUMBER_R,3,1,strRestoreCode,0,10);
   122b8:	81 e0       	ldi	r24, 0x01	; 1
   122ba:	63 e0       	ldi	r22, 0x03	; 3
   122bc:	41 e0       	ldi	r20, 0x01	; 1
   122be:	26 e3       	ldi	r18, 0x36	; 54
   122c0:	3e e0       	ldi	r19, 0x0E	; 14
   122c2:	00 e0       	ldi	r16, 0x00	; 0
   122c4:	10 e0       	ldi	r17, 0x00	; 0
   122c6:	7a e0       	ldi	r23, 0x0A	; 10
   122c8:	e7 2e       	mov	r14, r23
   122ca:	0e 94 4b 7d 	call	0xfa96	; 0xfa96 <UserInput>
		  switch(uiResult){
   122ce:	83 30       	cpi	r24, 0x03	; 3
   122d0:	61 f0       	breq	.+24     	; 0x122ea <FMenuMaster+0x310>
   122d2:	84 30       	cpi	r24, 0x04	; 4
   122d4:	20 f4       	brcc	.+8      	; 0x122de <FMenuMaster+0x304>
   122d6:	81 30       	cpi	r24, 0x01	; 1
   122d8:	09 f0       	breq	.+2      	; 0x122dc <FMenuMaster+0x302>
   122da:	88 c0       	rjmp	.+272    	; 0x123ec <FMenuMaster+0x412>
   122dc:	81 c0       	rjmp	.+258    	; 0x123e0 <FMenuMaster+0x406>
   122de:	84 30       	cpi	r24, 0x04	; 4
   122e0:	31 f0       	breq	.+12     	; 0x122ee <FMenuMaster+0x314>
   122e2:	85 30       	cpi	r24, 0x05	; 5
   122e4:	09 f0       	breq	.+2      	; 0x122e8 <FMenuMaster+0x30e>
   122e6:	82 c0       	rjmp	.+260    	; 0x123ec <FMenuMaster+0x412>
   122e8:	07 c0       	rjmp	.+14     	; 0x122f8 <FMenuMaster+0x31e>
		  case USER_OK:
               stMenuMaster=mmIsValidRestoreCode;
   122ea:	89 e0       	ldi	r24, 0x09	; 9
   122ec:	a6 cf       	rjmp	.-180    	; 0x1223a <FMenuMaster+0x260>
		       break;
          case USER_CANCEL:
		       stMenuMaster=mmExitMaster;
		       break;
		  case USER_ENTRY:
		       lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   122ee:	84 e0       	ldi	r24, 0x04	; 4
   122f0:	61 e0       	ldi	r22, 0x01	; 1
   122f2:	45 e7       	ldi	r20, 0x75	; 117
   122f4:	56 e1       	ldi	r21, 0x16	; 22
   122f6:	04 c0       	rjmp	.+8      	; 0x12300 <FMenuMaster+0x326>
		       break;
          case USER_NO_DATA:
		       lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   122f8:	84 e0       	ldi	r24, 0x04	; 4
   122fa:	61 e0       	ldi	r22, 0x01	; 1
   122fc:	40 e6       	ldi	r20, 0x60	; 96
   122fe:	56 e1       	ldi	r21, 0x16	; 22
   12300:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
   12304:	73 c0       	rjmp	.+230    	; 0x123ec <FMenuMaster+0x412>
		       break;
		  }
	      break;
     case mmIsValidRestoreCode:
	      if (ValidateRestoreCode(strKeyStamp,strRestoreCode)==RC_VALID){
   12306:	83 eb       	ldi	r24, 0xB3	; 179
   12308:	99 e0       	ldi	r25, 0x09	; 9
   1230a:	66 e3       	ldi	r22, 0x36	; 54
   1230c:	7e e0       	ldi	r23, 0x0E	; 14
   1230e:	0e 94 df 69 	call	0xd3be	; 0xd3be <ValidateRestoreCode>
   12312:	81 30       	cpi	r24, 0x01	; 1
   12314:	11 f4       	brne	.+4      	; 0x1231a <FMenuMaster+0x340>
		      stMenuMaster=mmRestorePassword;
   12316:	8c e0       	ldi	r24, 0x0C	; 12
   12318:	90 cf       	rjmp	.-224    	; 0x1223a <FMenuMaster+0x260>
		  }else stMenuMaster=mmDisplayInvalidRestoreCode;
   1231a:	8a e0       	ldi	r24, 0x0A	; 10
   1231c:	8e cf       	rjmp	.-228    	; 0x1223a <FMenuMaster+0x260>
	      break;
     case mmRestorePassword:
	      sprintf_P(strNewPassword,PSTR(SPV_DEFAULT_PASS));
   1231e:	00 d0       	rcall	.+0      	; 0x12320 <FMenuMaster+0x346>
   12320:	00 d0       	rcall	.+0      	; 0x12322 <FMenuMaster+0x348>
   12322:	8e 01       	movw	r16, r28
   12324:	0b 5e       	subi	r16, 0xEB	; 235
   12326:	1f 4f       	sbci	r17, 0xFF	; 255
   12328:	ad b7       	in	r26, 0x3d	; 61
   1232a:	be b7       	in	r27, 0x3e	; 62
   1232c:	12 96       	adiw	r26, 0x02	; 2
   1232e:	1c 93       	st	X, r17
   12330:	0e 93       	st	-X, r16
   12332:	11 97       	sbiw	r26, 0x01	; 1
   12334:	8a e5       	ldi	r24, 0x5A	; 90
   12336:	96 e1       	ldi	r25, 0x16	; 22
   12338:	14 96       	adiw	r26, 0x04	; 4
   1233a:	9c 93       	st	X, r25
   1233c:	8e 93       	st	-X, r24
   1233e:	13 97       	sbiw	r26, 0x03	; 3
   12340:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
   12344:	0f 90       	pop	r0
   12346:	0f 90       	pop	r0
   12348:	0f 90       	pop	r0
   1234a:	0f 90       	pop	r0
   1234c:	81 e0       	ldi	r24, 0x01	; 1
   1234e:	90 e0       	ldi	r25, 0x00	; 0
   12350:	b8 01       	movw	r22, r16
   12352:	4a e0       	ldi	r20, 0x0A	; 10
   12354:	50 e0       	ldi	r21, 0x00	; 0
   12356:	2e ef       	ldi	r18, 0xFE	; 254
   12358:	32 e1       	ldi	r19, 0x12	; 18
   1235a:	0e 94 96 b5 	call	0x16b2c	; 0x16b2c <__eewr_block>
		  eeprom_write_block((const void*) &strNewPassword,(void*) &DefSpvPassword,sizeof(DefSpvPassword));
		  sprintf_P(strNewPassword,PSTR(SYS_DEFAULT_PASS));
   1235e:	00 d0       	rcall	.+0      	; 0x12360 <FMenuMaster+0x386>
   12360:	00 d0       	rcall	.+0      	; 0x12362 <FMenuMaster+0x388>
   12362:	ed b7       	in	r30, 0x3d	; 61
   12364:	fe b7       	in	r31, 0x3e	; 62
   12366:	12 83       	std	Z+2, r17	; 0x02
   12368:	01 83       	std	Z+1, r16	; 0x01
   1236a:	84 e5       	ldi	r24, 0x54	; 84
   1236c:	96 e1       	ldi	r25, 0x16	; 22
   1236e:	94 83       	std	Z+4, r25	; 0x04
   12370:	83 83       	std	Z+3, r24	; 0x03
   12372:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
   12376:	0f 90       	pop	r0
   12378:	0f 90       	pop	r0
   1237a:	0f 90       	pop	r0
   1237c:	0f 90       	pop	r0
   1237e:	8b e0       	ldi	r24, 0x0B	; 11
   12380:	90 e0       	ldi	r25, 0x00	; 0
   12382:	b8 01       	movw	r22, r16
   12384:	4a e0       	ldi	r20, 0x0A	; 10
   12386:	50 e0       	ldi	r21, 0x00	; 0
   12388:	2e ef       	ldi	r18, 0xFE	; 254
   1238a:	32 e1       	ldi	r19, 0x12	; 18
   1238c:	0e 94 96 b5 	call	0x16b2c	; 0x16b2c <__eewr_block>
		  eeprom_write_block((const void*) &strNewPassword,(void*) &DefSysPassword,sizeof(DefSysPassword));	      		  
	      stMenuMaster=mmDisplaySuccess;
   12390:	8d e0       	ldi	r24, 0x0D	; 13
   12392:	53 cf       	rjmp	.-346    	; 0x1223a <FMenuMaster+0x260>
	      break;
     case mmDisplayInvalidRestoreCode:
	      lcd_printf(3,1,PSTR("Invalid Restore  "));
   12394:	83 e0       	ldi	r24, 0x03	; 3
   12396:	61 e0       	ldi	r22, 0x01	; 1
   12398:	42 e4       	ldi	r20, 0x42	; 66
   1239a:	56 e1       	ldi	r21, 0x16	; 22
   1239c:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		  TimDisplay=0;
   123a0:	10 92 a7 01 	sts	0x01A7, r1
          stMenuMaster=mmDelayInvalidRestoreCode;
   123a4:	8b e0       	ldi	r24, 0x0B	; 11
   123a6:	49 cf       	rjmp	.-366    	; 0x1223a <FMenuMaster+0x260>
	      break;
     case mmDelayInvalidRestoreCode:
	      if (TimDisplay>5)stMenuMaster=mmDisplayKeyStamp;
   123a8:	80 91 a7 01 	lds	r24, 0x01A7
   123ac:	86 30       	cpi	r24, 0x06	; 6
   123ae:	f0 f0       	brcs	.+60     	; 0x123ec <FMenuMaster+0x412>
   123b0:	87 e0       	ldi	r24, 0x07	; 7
   123b2:	43 cf       	rjmp	.-378    	; 0x1223a <FMenuMaster+0x260>
	      break;
     case mmDisplaySuccess:
	      //lcd_clear();
		  lcd_printf(3,1,PSTR("Password Restored"));
   123b4:	83 e0       	ldi	r24, 0x03	; 3
   123b6:	61 e0       	ldi	r22, 0x01	; 1
   123b8:	40 e3       	ldi	r20, 0x30	; 48
   123ba:	56 e1       	ldi	r21, 0x16	; 22
   123bc:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   123c0:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   123c2:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   123c4:	81 e0       	ldi	r24, 0x01	; 1
   123c6:	90 e0       	ldi	r25, 0x00	; 0
   123c8:	90 93 d7 01 	sts	0x01D7, r25
   123cc:	80 93 d6 01 	sts	0x01D6, r24
	      break;
     case mmDisplaySuccess:
	      //lcd_clear();
		  lcd_printf(3,1,PSTR("Password Restored"));
		  system_beep(1);
		  TimDisplay=0;
   123d0:	10 92 a7 01 	sts	0x01A7, r1
          stMenuMaster=mmDelayExit;
   123d4:	8f e0       	ldi	r24, 0x0F	; 15
   123d6:	31 cf       	rjmp	.-414    	; 0x1223a <FMenuMaster+0x260>
	      break;
     case mmDelayExit:
	      if (TimDisplay>=5)stMenuMaster=mmExitMaster;
   123d8:	80 91 a7 01 	lds	r24, 0x01A7
   123dc:	85 30       	cpi	r24, 0x05	; 5
   123de:	30 f0       	brcs	.+12     	; 0x123ec <FMenuMaster+0x412>
   123e0:	80 e1       	ldi	r24, 0x10	; 16
   123e2:	2b cf       	rjmp	.-426    	; 0x1223a <FMenuMaster+0x260>
	      break;
     case mmExitMaster:
	      stMenuMaster=mmInitMaster;
   123e4:	10 92 23 03 	sts	0x0323, r1
   123e8:	81 e0       	ldi	r24, 0x01	; 1
   123ea:	01 c0       	rjmp	.+2      	; 0x123ee <FMenuMaster+0x414>
   123ec:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
  return Result;

}
   123ee:	e2 96       	adiw	r28, 0x32	; 50
   123f0:	0f b6       	in	r0, 0x3f	; 63
   123f2:	f8 94       	cli
   123f4:	de bf       	out	0x3e, r29	; 62
   123f6:	0f be       	out	0x3f, r0	; 63
   123f8:	cd bf       	out	0x3d, r28	; 61
   123fa:	cf 91       	pop	r28
   123fc:	df 91       	pop	r29
   123fe:	1f 91       	pop	r17
   12400:	0f 91       	pop	r16
   12402:	ff 90       	pop	r15
   12404:	ef 90       	pop	r14
   12406:	08 95       	ret

00012408 <FMenuPassword>:
   return Result;	 
}



char FMenuPassword(){
   12408:	af 92       	push	r10
   1240a:	bf 92       	push	r11
   1240c:	cf 92       	push	r12
   1240e:	df 92       	push	r13
   12410:	ef 92       	push	r14
   12412:	0f 93       	push	r16
   12414:	1f 93       	push	r17
   12416:	df 93       	push	r29
   12418:	cf 93       	push	r28
   1241a:	cd b7       	in	r28, 0x3d	; 61
   1241c:	de b7       	in	r29, 0x3e	; 62
   1241e:	6e 97       	sbiw	r28, 0x1e	; 30
   12420:	0f b6       	in	r0, 0x3f	; 63
   12422:	f8 94       	cli
   12424:	de bf       	out	0x3e, r29	; 62
   12426:	0f be       	out	0x3f, r0	; 63
   12428:	cd bf       	out	0x3d, r28	; 61
static char stMenuPasword=mpInitPassword,uiResult,strPassword[10],PassStatus=MP_NONE;;
char Result=MP_NONE,strMasterPass[10],strSystemPass[10],strAdminPass[10];

     Result=MP_NONE;
     switch(stMenuPasword){
   1242a:	e0 90 30 03 	lds	r14, 0x0330
   1242e:	81 e0       	ldi	r24, 0x01	; 1
   12430:	e8 16       	cp	r14, r24
   12432:	09 f1       	breq	.+66     	; 0x12476 <FMenuPassword+0x6e>
   12434:	e8 16       	cp	r14, r24
   12436:	48 f0       	brcs	.+18     	; 0x1244a <FMenuPassword+0x42>
   12438:	e2 e0       	ldi	r30, 0x02	; 2
   1243a:	ee 16       	cp	r14, r30
   1243c:	09 f4       	brne	.+2      	; 0x12440 <FMenuPassword+0x38>
   1243e:	3f c0       	rjmp	.+126    	; 0x124be <FMenuPassword+0xb6>
   12440:	f3 e0       	ldi	r31, 0x03	; 3
   12442:	ef 16       	cp	r14, r31
   12444:	09 f0       	breq	.+2      	; 0x12448 <FMenuPassword+0x40>
   12446:	92 c0       	rjmp	.+292    	; 0x1256c <FMenuPassword+0x164>
   12448:	8c c0       	rjmp	.+280    	; 0x12562 <FMenuPassword+0x15a>
	 case mpInitPassword:
	      lcd_clear();
   1244a:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
		  lcd_printf(1,1,PSTR("PASSWORD:"));
   1244e:	81 e0       	ldi	r24, 0x01	; 1
   12450:	61 e0       	ldi	r22, 0x01	; 1
   12452:	4d e0       	ldi	r20, 0x0D	; 13
   12454:	58 e1       	ldi	r21, 0x18	; 24
   12456:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		  lcd_printf(2,1,PSTR("_"));
   1245a:	82 e0       	ldi	r24, 0x02	; 2
   1245c:	61 e0       	ldi	r22, 0x01	; 1
   1245e:	4b e0       	ldi	r20, 0x0B	; 11
   12460:	58 e1       	ldi	r21, 0x18	; 24
   12462:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		  lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   12466:	84 e0       	ldi	r24, 0x04	; 4
   12468:	61 e0       	ldi	r22, 0x01	; 1
   1246a:	46 ef       	ldi	r20, 0xF6	; 246
   1246c:	57 e1       	ldi	r21, 0x17	; 23
   1246e:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		  FillChar(strPassword,0,sizeof(strPassword));
		  stMenuPasword=mpInputPasword;
   12472:	81 e0       	ldi	r24, 0x01	; 1
   12474:	73 c0       	rjmp	.+230    	; 0x1255c <FMenuPassword+0x154>
	      break;
     case mpInputPasword:
	 	      uiResult=UserInput(UI_NUM_PASSWORD,2,1,strPassword,0,8);
   12476:	84 e0       	ldi	r24, 0x04	; 4
   12478:	62 e0       	ldi	r22, 0x02	; 2
   1247a:	41 e0       	ldi	r20, 0x01	; 1
   1247c:	25 e2       	ldi	r18, 0x25	; 37
   1247e:	33 e0       	ldi	r19, 0x03	; 3
   12480:	00 e0       	ldi	r16, 0x00	; 0
   12482:	10 e0       	ldi	r17, 0x00	; 0
   12484:	98 e0       	ldi	r25, 0x08	; 8
   12486:	e9 2e       	mov	r14, r25
   12488:	0e 94 4b 7d 	call	0xfa96	; 0xfa96 <UserInput>
   1248c:	80 93 2f 03 	sts	0x032F, r24
		  if (uiResult==USER_OK){
   12490:	83 30       	cpi	r24, 0x03	; 3
   12492:	11 f4       	brne	.+4      	; 0x12498 <FMenuPassword+0x90>
		      stMenuPasword=mpProcessPassword;
   12494:	82 e0       	ldi	r24, 0x02	; 2
   12496:	62 c0       	rjmp	.+196    	; 0x1255c <FMenuPassword+0x154>
			  }
		  else
		  if (uiResult==USER_CANCEL){
   12498:	81 30       	cpi	r24, 0x01	; 1
   1249a:	09 f4       	brne	.+2      	; 0x1249e <FMenuPassword+0x96>
   1249c:	50 c0       	rjmp	.+160    	; 0x1253e <FMenuPassword+0x136>
		      PassStatus=MP_CANCEL;
		      stMenuPasword=mpExit;
			  }
		  else
		  if (uiResult==USER_ENTRY)lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   1249e:	84 30       	cpi	r24, 0x04	; 4
   124a0:	21 f4       	brne	.+8      	; 0x124aa <FMenuPassword+0xa2>
   124a2:	61 e0       	ldi	r22, 0x01	; 1
   124a4:	41 ee       	ldi	r20, 0xE1	; 225
   124a6:	57 e1       	ldi	r21, 0x17	; 23
   124a8:	07 c0       	rjmp	.+14     	; 0x124b8 <FMenuPassword+0xb0>
		  else
		  if (uiResult==USER_NO_DATA)lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   124aa:	85 30       	cpi	r24, 0x05	; 5
   124ac:	09 f0       	breq	.+2      	; 0x124b0 <FMenuPassword+0xa8>
   124ae:	5e c0       	rjmp	.+188    	; 0x1256c <FMenuPassword+0x164>
   124b0:	84 e0       	ldi	r24, 0x04	; 4
   124b2:	61 e0       	ldi	r22, 0x01	; 1
   124b4:	4c ec       	ldi	r20, 0xCC	; 204
   124b6:	57 e1       	ldi	r21, 0x17	; 23
   124b8:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
   124bc:	57 c0       	rjmp	.+174    	; 0x1256c <FMenuPassword+0x164>
          break;	 
	 case mpProcessPassword:
		      
	      sprintf_P(strMasterPass,PSTR(MASTER_PASSWORD)); 
   124be:	00 d0       	rcall	.+0      	; 0x124c0 <FMenuPassword+0xb8>
   124c0:	00 d0       	rcall	.+0      	; 0x124c2 <FMenuPassword+0xba>
   124c2:	8e 01       	movw	r16, r28
   124c4:	0f 5f       	subi	r16, 0xFF	; 255
   124c6:	1f 4f       	sbci	r17, 0xFF	; 255
   124c8:	ed b7       	in	r30, 0x3d	; 61
   124ca:	fe b7       	in	r31, 0x3e	; 62
   124cc:	12 83       	std	Z+2, r17	; 0x02
   124ce:	01 83       	std	Z+1, r16	; 0x01
   124d0:	84 ec       	ldi	r24, 0xC4	; 196
   124d2:	97 e1       	ldi	r25, 0x17	; 23
   124d4:	94 83       	std	Z+4, r25	; 0x04
   124d6:	83 83       	std	Z+3, r24	; 0x03
   124d8:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
   124dc:	0f 90       	pop	r0
   124de:	0f 90       	pop	r0
   124e0:	0f 90       	pop	r0
   124e2:	0f 90       	pop	r0
   124e4:	b5 e1       	ldi	r27, 0x15	; 21
   124e6:	cb 2e       	mov	r12, r27
   124e8:	d1 2c       	mov	r13, r1
   124ea:	cc 0e       	add	r12, r28
   124ec:	dd 1e       	adc	r13, r29
   124ee:	c6 01       	movw	r24, r12
   124f0:	61 e0       	ldi	r22, 0x01	; 1
   124f2:	70 e0       	ldi	r23, 0x00	; 0
   124f4:	4a e0       	ldi	r20, 0x0A	; 10
   124f6:	50 e0       	ldi	r21, 0x00	; 0
   124f8:	26 ef       	ldi	r18, 0xF6	; 246
   124fa:	32 e1       	ldi	r19, 0x12	; 18
   124fc:	0e 94 7a b5 	call	0x16af4	; 0x16af4 <__eerd_block>
	      eeprom_read_block((void*) &strAdminPass, (const void*) &DefSpvPassword, 10);
	      eeprom_read_block((void*) &strSystemPass, (const void*) &DefSysPassword, 10);
		  
		  if (strcmp(strMasterPass,strPassword)==0)
   12500:	ab e0       	ldi	r26, 0x0B	; 11
   12502:	aa 2e       	mov	r10, r26
   12504:	b1 2c       	mov	r11, r1
   12506:	ac 0e       	add	r10, r28
   12508:	bd 1e       	adc	r11, r29
   1250a:	c5 01       	movw	r24, r10
   1250c:	6b e0       	ldi	r22, 0x0B	; 11
   1250e:	70 e0       	ldi	r23, 0x00	; 0
   12510:	4a e0       	ldi	r20, 0x0A	; 10
   12512:	50 e0       	ldi	r21, 0x00	; 0
   12514:	26 ef       	ldi	r18, 0xF6	; 246
   12516:	32 e1       	ldi	r19, 0x12	; 18
   12518:	0e 94 7a b5 	call	0x16af4	; 0x16af4 <__eerd_block>
   1251c:	c8 01       	movw	r24, r16
   1251e:	65 e2       	ldi	r22, 0x25	; 37
   12520:	73 e0       	ldi	r23, 0x03	; 3
   12522:	0e 94 6a b5 	call	0x16ad4	; 0x16ad4 <strcmp>
   12526:	00 97       	sbiw	r24, 0x00	; 0
   12528:	11 f4       	brne	.+4      	; 0x1252e <FMenuPassword+0x126>
		       PassStatus=MP_VALID_MASTER;
   1252a:	83 e0       	ldi	r24, 0x03	; 3
   1252c:	08 c0       	rjmp	.+16     	; 0x1253e <FMenuPassword+0x136>
		  else
	      if (strcmp(strAdminPass,strPassword)==0){
   1252e:	c6 01       	movw	r24, r12
   12530:	65 e2       	ldi	r22, 0x25	; 37
   12532:	73 e0       	ldi	r23, 0x03	; 3
   12534:	0e 94 6a b5 	call	0x16ad4	; 0x16ad4 <strcmp>
   12538:	00 97       	sbiw	r24, 0x00	; 0
   1253a:	21 f4       	brne	.+8      	; 0x12544 <FMenuPassword+0x13c>
		       PassStatus=MP_VALID_ADMIN;
   1253c:	84 e0       	ldi	r24, 0x04	; 4
   1253e:	80 93 24 03 	sts	0x0324, r24
   12542:	0b c0       	rjmp	.+22     	; 0x1255a <FMenuPassword+0x152>
               //lcd_printf(3,1,PSTR("Admin"));
               //_delay_ms(5000);
			   }
		  else if (strcmp(strSystemPass,strPassword)==0){
   12544:	c5 01       	movw	r24, r10
   12546:	65 e2       	ldi	r22, 0x25	; 37
   12548:	73 e0       	ldi	r23, 0x03	; 3
   1254a:	0e 94 6a b5 	call	0x16ad4	; 0x16ad4 <strcmp>
   1254e:	00 97       	sbiw	r24, 0x00	; 0
   12550:	11 f4       	brne	.+4      	; 0x12556 <FMenuPassword+0x14e>
		       PassStatus=MP_VALID_SYSTEM;
   12552:	85 e0       	ldi	r24, 0x05	; 5
   12554:	f4 cf       	rjmp	.-24     	; 0x1253e <FMenuPassword+0x136>
			   //lcd_printf(3,1,PSTR("System"));
               //_delay_ms(5000);
			   }
		  else PassStatus=MP_INVALID;
   12556:	e0 92 24 03 	sts	0x0324, r14
		  stMenuPasword=mpExit;
   1255a:	83 e0       	ldi	r24, 0x03	; 3
   1255c:	80 93 30 03 	sts	0x0330, r24
   12560:	05 c0       	rjmp	.+10     	; 0x1256c <FMenuPassword+0x164>
	      break;
	 case mpExit:
	      //lcd_print(3,1,strPassword);
		  //_delay_ms(5000);
	      stMenuPasword=mpInitPassword;
   12562:	10 92 30 03 	sts	0x0330, r1
	      Result=PassStatus;
   12566:	80 91 24 03 	lds	r24, 0x0324
   1256a:	01 c0       	rjmp	.+2      	; 0x1256e <FMenuPassword+0x166>
   1256c:	80 e0       	ldi	r24, 0x00	; 0
	      break;
	 }
   return Result;
}
   1256e:	6e 96       	adiw	r28, 0x1e	; 30
   12570:	0f b6       	in	r0, 0x3f	; 63
   12572:	f8 94       	cli
   12574:	de bf       	out	0x3e, r29	; 62
   12576:	0f be       	out	0x3f, r0	; 63
   12578:	cd bf       	out	0x3d, r28	; 61
   1257a:	cf 91       	pop	r28
   1257c:	df 91       	pop	r29
   1257e:	1f 91       	pop	r17
   12580:	0f 91       	pop	r16
   12582:	ef 90       	pop	r14
   12584:	df 90       	pop	r13
   12586:	cf 90       	pop	r12
   12588:	bf 90       	pop	r11
   1258a:	af 90       	pop	r10
   1258c:	08 95       	ret

0001258e <FMenuReprint>:
	       break;
	 }
return Result;
}

char FMenuReprint(){
   1258e:	0f 93       	push	r16
   12590:	1f 93       	push	r17
   12592:	df 93       	push	r29
   12594:	cf 93       	push	r28
   12596:	cd b7       	in	r28, 0x3d	; 61
   12598:	de b7       	in	r29, 0x3e	; 62
   1259a:	64 97       	sbiw	r28, 0x14	; 20
   1259c:	0f b6       	in	r0, 0x3f	; 63
   1259e:	f8 94       	cli
   125a0:	de bf       	out	0x3e, r29	; 62
   125a2:	0f be       	out	0x3f, r0	; 63
   125a4:	cd bf       	out	0x3d, r28	; 61
static char KeyPressed=0,FIP_Used=0;
       char lcdteks[20],FIPResult,KeyChar;//,FIP_USED;
	   char PassResult,Result=MENU_NONE,ReprintResult;

     Result=MENU_NONE;
	 switch(stReprint){
   125a6:	80 91 52 03 	lds	r24, 0x0352
   125aa:	87 30       	cpi	r24, 0x07	; 7
   125ac:	09 f4       	brne	.+2      	; 0x125b0 <FMenuReprint+0x22>
   125ae:	8e c0       	rjmp	.+284    	; 0x126cc <FMenuReprint+0x13e>
   125b0:	88 30       	cpi	r24, 0x08	; 8
   125b2:	90 f4       	brcc	.+36     	; 0x125d8 <FMenuReprint+0x4a>
   125b4:	83 30       	cpi	r24, 0x03	; 3
   125b6:	09 f4       	brne	.+2      	; 0x125ba <FMenuReprint+0x2c>
   125b8:	43 c0       	rjmp	.+134    	; 0x12640 <FMenuReprint+0xb2>
   125ba:	84 30       	cpi	r24, 0x04	; 4
   125bc:	30 f4       	brcc	.+12     	; 0x125ca <FMenuReprint+0x3c>
   125be:	81 30       	cpi	r24, 0x01	; 1
   125c0:	09 f4       	brne	.+2      	; 0x125c4 <FMenuReprint+0x36>
   125c2:	55 c0       	rjmp	.+170    	; 0x1266e <FMenuReprint+0xe0>
   125c4:	82 30       	cpi	r24, 0x02	; 2
   125c6:	48 f5       	brcc	.+82     	; 0x1261a <FMenuReprint+0x8c>
   125c8:	1d c0       	rjmp	.+58     	; 0x12604 <FMenuReprint+0x76>
   125ca:	85 30       	cpi	r24, 0x05	; 5
   125cc:	09 f4       	brne	.+2      	; 0x125d0 <FMenuReprint+0x42>
   125ce:	6c c0       	rjmp	.+216    	; 0x126a8 <FMenuReprint+0x11a>
   125d0:	86 30       	cpi	r24, 0x06	; 6
   125d2:	08 f0       	brcs	.+2      	; 0x125d6 <FMenuReprint+0x48>
   125d4:	50 c0       	rjmp	.+160    	; 0x12676 <FMenuReprint+0xe8>
   125d6:	45 c0       	rjmp	.+138    	; 0x12662 <FMenuReprint+0xd4>
   125d8:	8b 30       	cpi	r24, 0x0B	; 11
   125da:	09 f4       	brne	.+2      	; 0x125de <FMenuReprint+0x50>
   125dc:	da c0       	rjmp	.+436    	; 0x12792 <FMenuReprint+0x204>
   125de:	8c 30       	cpi	r24, 0x0C	; 12
   125e0:	38 f4       	brcc	.+14     	; 0x125f0 <FMenuReprint+0x62>
   125e2:	89 30       	cpi	r24, 0x09	; 9
   125e4:	09 f4       	brne	.+2      	; 0x125e8 <FMenuReprint+0x5a>
   125e6:	b8 c0       	rjmp	.+368    	; 0x12758 <FMenuReprint+0x1ca>
   125e8:	8a 30       	cpi	r24, 0x0A	; 10
   125ea:	08 f0       	brcs	.+2      	; 0x125ee <FMenuReprint+0x60>
   125ec:	ca c0       	rjmp	.+404    	; 0x12782 <FMenuReprint+0x1f4>
   125ee:	7c c0       	rjmp	.+248    	; 0x126e8 <FMenuReprint+0x15a>
   125f0:	8d 30       	cpi	r24, 0x0D	; 13
   125f2:	09 f4       	brne	.+2      	; 0x125f6 <FMenuReprint+0x68>
   125f4:	ed c0       	rjmp	.+474    	; 0x127d0 <FMenuReprint+0x242>
   125f6:	8d 30       	cpi	r24, 0x0D	; 13
   125f8:	08 f4       	brcc	.+2      	; 0x125fc <FMenuReprint+0x6e>
   125fa:	d7 c0       	rjmp	.+430    	; 0x127aa <FMenuReprint+0x21c>
   125fc:	8e 30       	cpi	r24, 0x0E	; 14
   125fe:	09 f0       	breq	.+2      	; 0x12602 <FMenuReprint+0x74>
   12600:	f0 c0       	rjmp	.+480    	; 0x127e2 <FMenuReprint+0x254>
   12602:	eb c0       	rjmp	.+470    	; 0x127da <FMenuReprint+0x24c>
	 case rtInit:
	      lcd_clear();
   12604:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
          if (IFType==IT_SLAVE)stReprint=rtFIP;
   12608:	80 91 10 01 	lds	r24, 0x0110
   1260c:	81 30       	cpi	r24, 0x01	; 1
   1260e:	09 f4       	brne	.+2      	; 0x12612 <FMenuReprint+0x84>
   12610:	b3 c0       	rjmp	.+358    	; 0x12778 <FMenuReprint+0x1ea>
		  else
		  if (IFType==IT_STANDALONE)stReprint=rtStandaloneFIP;//rtValidPassword;//rtStandaloneFIP;
   12612:	82 30       	cpi	r24, 0x02	; 2
   12614:	09 f0       	breq	.+2      	; 0x12618 <FMenuReprint+0x8a>
   12616:	e5 c0       	rjmp	.+458    	; 0x127e2 <FMenuReprint+0x254>
   12618:	04 c0       	rjmp	.+8      	; 0x12622 <FMenuReprint+0x94>
	      break;
     case rtValidPassword:
	      PassResult=FMenuPassword();
   1261a:	0e 94 04 92 	call	0x12408	; 0x12408 <FMenuPassword>
	      if (PassResult==MP_VALID_ADMIN)stReprint=rtStandaloneFIP;
   1261e:	84 30       	cpi	r24, 0x04	; 4
   12620:	11 f4       	brne	.+4      	; 0x12626 <FMenuReprint+0x98>
   12622:	81 e0       	ldi	r24, 0x01	; 1
   12624:	0a c0       	rjmp	.+20     	; 0x1263a <FMenuReprint+0xac>
		  else
	      if (PassResult==MP_VALID_SYSTEM)stReprint=rtInvalidPassword;
   12626:	85 30       	cpi	r24, 0x05	; 5
   12628:	11 f0       	breq	.+4      	; 0x1262e <FMenuReprint+0xa0>
          else
	      if (PassResult==MP_INVALID)stReprint=rtInvalidPassword;
   1262a:	82 30       	cpi	r24, 0x02	; 2
   1262c:	11 f4       	brne	.+4      	; 0x12632 <FMenuReprint+0xa4>
   1262e:	83 e0       	ldi	r24, 0x03	; 3
   12630:	04 c0       	rjmp	.+8      	; 0x1263a <FMenuReprint+0xac>
		  else
	      if (PassResult==MP_CANCEL)stReprint=rtExitReprint;
   12632:	81 30       	cpi	r24, 0x01	; 1
   12634:	09 f0       	breq	.+2      	; 0x12638 <FMenuReprint+0xaa>
   12636:	d5 c0       	rjmp	.+426    	; 0x127e2 <FMenuReprint+0x254>
   12638:	8e e0       	ldi	r24, 0x0E	; 14
   1263a:	80 93 52 03 	sts	0x0352, r24
   1263e:	d1 c0       	rjmp	.+418    	; 0x127e2 <FMenuReprint+0x254>
	      break;
     case rtInvalidPassword:
          TimDisplay=0;
   12640:	10 92 a7 01 	sts	0x01A7, r1
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   12644:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   12646:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   12648:	81 e0       	ldi	r24, 0x01	; 1
   1264a:	90 e0       	ldi	r25, 0x00	; 0
   1264c:	90 93 d7 01 	sts	0x01D7, r25
   12650:	80 93 d6 01 	sts	0x01D6, r24
	      if (PassResult==MP_CANCEL)stReprint=rtExitReprint;
	      break;
     case rtInvalidPassword:
          TimDisplay=0;
		  system_beep(1);
		  lcd_printf(3,1,PSTR("Access Denied"));
   12654:	83 e0       	ldi	r24, 0x03	; 3
   12656:	61 e0       	ldi	r22, 0x01	; 1
   12658:	48 e7       	ldi	r20, 0x78	; 120
   1265a:	5b e1       	ldi	r21, 0x1B	; 27
   1265c:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
   12660:	33 c0       	rjmp	.+102    	; 0x126c8 <FMenuReprint+0x13a>
          stReprint=rtTimDisplayInvalid;
	      break;
     case rtTimDisplayInvalid:
	      if (TimDisplay>2)stReprint=rtExitReprint;
   12662:	80 91 a7 01 	lds	r24, 0x01A7
   12666:	83 30       	cpi	r24, 0x03	; 3
   12668:	08 f4       	brcc	.+2      	; 0x1266c <FMenuReprint+0xde>
   1266a:	bb c0       	rjmp	.+374    	; 0x127e2 <FMenuReprint+0x254>
   1266c:	e5 cf       	rjmp	.-54     	; 0x12638 <FMenuReprint+0xaa>
	      break;
     case rtStandaloneFIP:
	      _scr_pump();
   1266e:	0e 94 53 46 	call	0x8ca6	; 0x8ca6 <_scr_pump>
		  stReprint=rtStandaloneInputFIP;
   12672:	86 e0       	ldi	r24, 0x06	; 6
   12674:	e2 cf       	rjmp	.-60     	; 0x1263a <FMenuReprint+0xac>
	      break;
     case rtStandaloneInputFIP:
		  KeyChar=_key_btn(_key_scan(1));
   12676:	81 e0       	ldi	r24, 0x01	; 1
   12678:	0e 94 06 b0 	call	0x1600c	; 0x1600c <_key_scan>
   1267c:	0e 94 67 af 	call	0x15ece	; 0x15ece <_key_btn>
   12680:	98 2f       	mov	r25, r24
		  if ((KeyChar>='1')&&(KeyChar<='8')){
   12682:	81 53       	subi	r24, 0x31	; 49
   12684:	88 30       	cpi	r24, 0x08	; 8
   12686:	60 f4       	brcc	.+24     	; 0x126a0 <FMenuReprint+0x112>
		       ReprintResult=PrintStandalone(KeyChar-'0',True);
   12688:	8f 5f       	subi	r24, 0xFF	; 255
   1268a:	61 e0       	ldi	r22, 0x01	; 1
   1268c:	0e 94 97 21 	call	0x432e	; 0x432e <PrintStandalone>
			   if (ReprintResult==PS_NO_DATA)stReprint=rtDisplayNoTransaction;
   12690:	82 31       	cpi	r24, 0x12	; 18
   12692:	11 f4       	brne	.+4      	; 0x12698 <FMenuReprint+0x10a>
   12694:	85 e0       	ldi	r24, 0x05	; 5
   12696:	d1 cf       	rjmp	.-94     	; 0x1263a <FMenuReprint+0xac>
			   else if (ReprintResult==PS_PRINTED)stReprint=rtExitReprint;
   12698:	81 31       	cpi	r24, 0x11	; 17
   1269a:	09 f0       	breq	.+2      	; 0x1269e <FMenuReprint+0x110>
   1269c:	a2 c0       	rjmp	.+324    	; 0x127e2 <FMenuReprint+0x254>
   1269e:	cc cf       	rjmp	.-104    	; 0x12638 <FMenuReprint+0xaa>

		  }else if (KeyChar=='*')stReprint=rtExitReprint;
   126a0:	9a 32       	cpi	r25, 0x2A	; 42
   126a2:	09 f0       	breq	.+2      	; 0x126a6 <FMenuReprint+0x118>
   126a4:	9e c0       	rjmp	.+316    	; 0x127e2 <FMenuReprint+0x254>
   126a6:	c8 cf       	rjmp	.-112    	; 0x12638 <FMenuReprint+0xaa>

	      break;
     case rtDisplayNoTransaction:
	      lcd_printf(3, 1,PSTR("Tidak Ada Transaksi "));
   126a8:	83 e0       	ldi	r24, 0x03	; 3
   126aa:	61 e0       	ldi	r22, 0x01	; 1
   126ac:	43 e6       	ldi	r20, 0x63	; 99
   126ae:	5b e1       	ldi	r21, 0x1B	; 27
   126b0:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   126b4:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   126b6:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   126b8:	81 e0       	ldi	r24, 0x01	; 1
   126ba:	90 e0       	ldi	r25, 0x00	; 0
   126bc:	90 93 d7 01 	sts	0x01D7, r25
   126c0:	80 93 d6 01 	sts	0x01D6, r24

	      break;
     case rtDisplayNoTransaction:
	      lcd_printf(3, 1,PSTR("Tidak Ada Transaksi "));
		  system_beep(1);
          TimDisplay=0;
   126c4:	10 92 a7 01 	sts	0x01A7, r1
		  stReprint=rtTimDisplayInvalid;
   126c8:	84 e0       	ldi	r24, 0x04	; 4
   126ca:	b7 cf       	rjmp	.-146    	; 0x1263a <FMenuReprint+0xac>
	      break;
	 case rtFIP:
	      FIPResult=menu_FIP(&FIP_Used,strFIP_ID);
   126cc:	80 e5       	ldi	r24, 0x50	; 80
   126ce:	93 e0       	ldi	r25, 0x03	; 3
   126d0:	6c e9       	ldi	r22, 0x9C	; 156
   126d2:	79 e0       	ldi	r23, 0x09	; 9
   126d4:	0e 94 f1 64 	call	0xc9e2	; 0xc9e2 <menu_FIP>
		  if (FIPResult==FIP_DONE){
   126d8:	88 23       	and	r24, r24
   126da:	11 f4       	brne	.+4      	; 0x126e0 <FMenuReprint+0x152>
		      stReprint=rtRFID;
   126dc:	88 e0       	ldi	r24, 0x08	; 8
   126de:	ad cf       	rjmp	.-166    	; 0x1263a <FMenuReprint+0xac>
			  }
		  else
		  if (FIPResult==FIP_CANCEL)stReprint=rtExitReprint;
   126e0:	82 30       	cpi	r24, 0x02	; 2
   126e2:	09 f0       	breq	.+2      	; 0x126e6 <FMenuReprint+0x158>
   126e4:	7e c0       	rjmp	.+252    	; 0x127e2 <FMenuReprint+0x254>
   126e6:	a8 cf       	rjmp	.-176    	; 0x12638 <FMenuReprint+0xaa>
	      break;
	 case rtRFID:
	      lcd_clear();
   126e8:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
		  sprintf_P(lcdteks,PSTR("RePrint FIP:%s "),strFIP_ID);lcd_print(1,1,lcdteks);
   126ec:	00 d0       	rcall	.+0      	; 0x126ee <FMenuReprint+0x160>
   126ee:	00 d0       	rcall	.+0      	; 0x126f0 <FMenuReprint+0x162>
   126f0:	00 d0       	rcall	.+0      	; 0x126f2 <FMenuReprint+0x164>
   126f2:	ed b7       	in	r30, 0x3d	; 61
   126f4:	fe b7       	in	r31, 0x3e	; 62
   126f6:	31 96       	adiw	r30, 0x01	; 1
   126f8:	8e 01       	movw	r16, r28
   126fa:	0f 5f       	subi	r16, 0xFF	; 255
   126fc:	1f 4f       	sbci	r17, 0xFF	; 255
   126fe:	ad b7       	in	r26, 0x3d	; 61
   12700:	be b7       	in	r27, 0x3e	; 62
   12702:	12 96       	adiw	r26, 0x02	; 2
   12704:	1c 93       	st	X, r17
   12706:	0e 93       	st	-X, r16
   12708:	11 97       	sbiw	r26, 0x01	; 1
   1270a:	83 e5       	ldi	r24, 0x53	; 83
   1270c:	9b e1       	ldi	r25, 0x1B	; 27
   1270e:	93 83       	std	Z+3, r25	; 0x03
   12710:	82 83       	std	Z+2, r24	; 0x02
   12712:	8c e9       	ldi	r24, 0x9C	; 156
   12714:	99 e0       	ldi	r25, 0x09	; 9
   12716:	95 83       	std	Z+5, r25	; 0x05
   12718:	84 83       	std	Z+4, r24	; 0x04
   1271a:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
   1271e:	8d b7       	in	r24, 0x3d	; 61
   12720:	9e b7       	in	r25, 0x3e	; 62
   12722:	06 96       	adiw	r24, 0x06	; 6
   12724:	0f b6       	in	r0, 0x3f	; 63
   12726:	f8 94       	cli
   12728:	9e bf       	out	0x3e, r25	; 62
   1272a:	0f be       	out	0x3f, r0	; 63
   1272c:	8d bf       	out	0x3d, r24	; 61
   1272e:	81 e0       	ldi	r24, 0x01	; 1
   12730:	61 e0       	ldi	r22, 0x01	; 1
   12732:	a8 01       	movw	r20, r16
   12734:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
		  lcd_printf(2,1,PSTR(  "Tap Supervisor Card"));
   12738:	82 e0       	ldi	r24, 0x02	; 2
   1273a:	61 e0       	ldi	r22, 0x01	; 1
   1273c:	4f e3       	ldi	r20, 0x3F	; 63
   1273e:	5b e1       	ldi	r21, 0x1B	; 27
   12740:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
          lcd_printf(4,1,PSTR(  "[*]Back    [#]Exit"));
   12744:	84 e0       	ldi	r24, 0x04	; 4
   12746:	61 e0       	ldi	r22, 0x01	; 1
   12748:	4c e2       	ldi	r20, 0x2C	; 44
   1274a:	5b e1       	ldi	r21, 0x1B	; 27
   1274c:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		  IsRFIDDetected=False;
   12750:	10 92 af 01 	sts	0x01AF, r1
		  stReprint=rtInputRFID;
   12754:	89 e0       	ldi	r24, 0x09	; 9
   12756:	71 cf       	rjmp	.-286    	; 0x1263a <FMenuReprint+0xac>
	      break;
	 case rtInputRFID:
	      if (IsRFIDDetected==True){
   12758:	80 91 af 01 	lds	r24, 0x01AF
   1275c:	81 30       	cpi	r24, 0x01	; 1
   1275e:	29 f4       	brne	.+10     	; 0x1276a <FMenuReprint+0x1dc>
		      IsRFIDDetected=False;
   12760:	10 92 af 01 	sts	0x01AF, r1
		      stReprint=rtSendMessage28;
   12764:	8a e0       	ldi	r24, 0x0A	; 10
   12766:	80 93 52 03 	sts	0x0352, r24
		  }
	 	  KeyPressed=_key_scan(1);
   1276a:	81 e0       	ldi	r24, 0x01	; 1
   1276c:	0e 94 06 b0 	call	0x1600c	; 0x1600c <_key_scan>
   12770:	80 93 51 03 	sts	0x0351, r24
		  if (KeyPressed==_KEY_CANCEL){
   12774:	87 3e       	cpi	r24, 0xE7	; 231
   12776:	11 f4       	brne	.+4      	; 0x1277c <FMenuReprint+0x1ee>
		      stReprint=rtFIP;
   12778:	87 e0       	ldi	r24, 0x07	; 7
   1277a:	5f cf       	rjmp	.-322    	; 0x1263a <FMenuReprint+0xac>
			  }
		  else
		  if (KeyPressed==_KEY_ENTER)stReprint=rtExitReprint;
   1277c:	87 3b       	cpi	r24, 0xB7	; 183
   1277e:	89 f5       	brne	.+98     	; 0x127e2 <FMenuReprint+0x254>
   12780:	5b cf       	rjmp	.-330    	; 0x12638 <FMenuReprint+0xaa>
	      break;
     case rtSendMessage28:
		  sendMessage28();
   12782:	0e 94 40 52 	call	0xa480	; 0xa480 <sendMessage28>
		  TimSend=0;
   12786:	10 92 a9 01 	sts	0x01A9, r1
   1278a:	10 92 a8 01 	sts	0x01A8, r1
		  stReprint=rtWaitReply;
   1278e:	8b e0       	ldi	r24, 0x0B	; 11
   12790:	54 cf       	rjmp	.-344    	; 0x1263a <FMenuReprint+0xac>
		  break;
     case rtWaitReply:
	      if (TimSend>TIM_SEND*3)stReprint=rtNoConnection;
   12792:	80 91 a8 01 	lds	r24, 0x01A8
   12796:	90 91 a9 01 	lds	r25, 0x01A9
   1279a:	4f 97       	sbiw	r24, 0x1f	; 31
   1279c:	18 f0       	brcs	.+6      	; 0x127a4 <FMenuReprint+0x216>
   1279e:	8c e0       	ldi	r24, 0x0C	; 12
   127a0:	80 93 52 03 	sts	0x0352, r24
	      if (IsMessage99==True){
   127a4:	80 91 b6 01 	lds	r24, 0x01B6
   127a8:	44 cf       	rjmp	.-376    	; 0x12632 <FMenuReprint+0xa4>
		      stReprint=rtExitReprint;
		  }
	      break;
     case rtNoConnection:
	      lcd_clear();
   127aa:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
		  lcd_printf(2,1,PSTR("TCP/IP ERROR "));
   127ae:	82 e0       	ldi	r24, 0x02	; 2
   127b0:	61 e0       	ldi	r22, 0x01	; 1
   127b2:	4e e1       	ldi	r20, 0x1E	; 30
   127b4:	5b e1       	ldi	r21, 0x1B	; 27
   127b6:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		  lcd_printf(3,1,PSTR("No Connection"));
   127ba:	83 e0       	ldi	r24, 0x03	; 3
   127bc:	61 e0       	ldi	r22, 0x01	; 1
   127be:	40 e1       	ldi	r20, 0x10	; 16
   127c0:	5b e1       	ldi	r21, 0x1B	; 27
   127c2:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		  TimDisplay=5;
   127c6:	85 e0       	ldi	r24, 0x05	; 5
   127c8:	80 93 a7 01 	sts	0x01A7, r24
		  stReprint=rtDelayExitReprint;
   127cc:	8d e0       	ldi	r24, 0x0D	; 13
   127ce:	35 cf       	rjmp	.-406    	; 0x1263a <FMenuReprint+0xac>
	      break;
     case rtDelayExitReprint:
	      if(TimDisplay>=10)stReprint=rtExitReprint;
   127d0:	80 91 a7 01 	lds	r24, 0x01A7
   127d4:	8a 30       	cpi	r24, 0x0A	; 10
   127d6:	28 f0       	brcs	.+10     	; 0x127e2 <FMenuReprint+0x254>
   127d8:	2f cf       	rjmp	.-418    	; 0x12638 <FMenuReprint+0xaa>
	      break;
	 case rtExitReprint:
	      stReprint=rtInit;
   127da:	10 92 52 03 	sts	0x0352, r1
   127de:	81 e0       	ldi	r24, 0x01	; 1
   127e0:	01 c0       	rjmp	.+2      	; 0x127e4 <FMenuReprint+0x256>
   127e2:	80 e0       	ldi	r24, 0x00	; 0
		  Result=MENU_DONE;
	      break;
	 }
  return Result;
}
   127e4:	64 96       	adiw	r28, 0x14	; 20
   127e6:	0f b6       	in	r0, 0x3f	; 63
   127e8:	f8 94       	cli
   127ea:	de bf       	out	0x3e, r29	; 62
   127ec:	0f be       	out	0x3f, r0	; 63
   127ee:	cd bf       	out	0x3d, r28	; 61
   127f0:	cf 91       	pop	r28
   127f2:	df 91       	pop	r29
   127f4:	1f 91       	pop	r17
   127f6:	0f 91       	pop	r16
   127f8:	08 95       	ret

000127fa <FMenuAdmin>:

char FMenuAdmin(){
static char stMenuAdmin=maInitAdmin;
	 char SubMenu,KeyPressed,KeyChar,Result=MENU_NONE;
     
	 switch(stMenuAdmin){
   127fa:	80 91 22 03 	lds	r24, 0x0322
   127fe:	83 30       	cpi	r24, 0x03	; 3
   12800:	09 f4       	brne	.+2      	; 0x12804 <FMenuAdmin+0xa>
   12802:	66 c0       	rjmp	.+204    	; 0x128d0 <FMenuAdmin+0xd6>
   12804:	84 30       	cpi	r24, 0x04	; 4
   12806:	30 f4       	brcc	.+12     	; 0x12814 <FMenuAdmin+0x1a>
   12808:	81 30       	cpi	r24, 0x01	; 1
   1280a:	69 f1       	breq	.+90     	; 0x12866 <FMenuAdmin+0x6c>
   1280c:	82 30       	cpi	r24, 0x02	; 2
   1280e:	08 f0       	brcs	.+2      	; 0x12812 <FMenuAdmin+0x18>
   12810:	4d c0       	rjmp	.+154    	; 0x128ac <FMenuAdmin+0xb2>
   12812:	0d c0       	rjmp	.+26     	; 0x1282e <FMenuAdmin+0x34>
   12814:	85 30       	cpi	r24, 0x05	; 5
   12816:	09 f4       	brne	.+2      	; 0x1281a <FMenuAdmin+0x20>
   12818:	4e c0       	rjmp	.+156    	; 0x128b6 <FMenuAdmin+0xbc>
   1281a:	85 30       	cpi	r24, 0x05	; 5
   1281c:	08 f4       	brcc	.+2      	; 0x12820 <FMenuAdmin+0x26>
   1281e:	49 c0       	rjmp	.+146    	; 0x128b2 <FMenuAdmin+0xb8>
   12820:	86 30       	cpi	r24, 0x06	; 6
   12822:	09 f4       	brne	.+2      	; 0x12826 <FMenuAdmin+0x2c>
   12824:	51 c0       	rjmp	.+162    	; 0x128c8 <FMenuAdmin+0xce>
   12826:	87 30       	cpi	r24, 0x07	; 7
   12828:	09 f0       	breq	.+2      	; 0x1282c <FMenuAdmin+0x32>
   1282a:	5a c0       	rjmp	.+180    	; 0x128e0 <FMenuAdmin+0xe6>
   1282c:	55 c0       	rjmp	.+170    	; 0x128d8 <FMenuAdmin+0xde>
	 case maInitAdmin:
		  lcd_clear();
   1282e:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
		  lcd_printf(1,1,PSTR("1)RePrint           "));
   12832:	81 e0       	ldi	r24, 0x01	; 1
   12834:	61 e0       	ldi	r22, 0x01	; 1
   12836:	4b e1       	ldi	r20, 0x1B	; 27
   12838:	56 e1       	ldi	r21, 0x16	; 22
   1283a:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		  lcd_printf(2,1,PSTR("2)CloseShift        "));
   1283e:	82 e0       	ldi	r24, 0x02	; 2
   12840:	61 e0       	ldi	r22, 0x01	; 1
   12842:	46 e0       	ldi	r20, 0x06	; 6
   12844:	56 e1       	ldi	r21, 0x16	; 22
   12846:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		  lcd_printf(3,1,PSTR("3)CloseDay          "));		  
   1284a:	83 e0       	ldi	r24, 0x03	; 3
   1284c:	61 e0       	ldi	r22, 0x01	; 1
   1284e:	41 ef       	ldi	r20, 0xF1	; 241
   12850:	55 e1       	ldi	r21, 0x15	; 21
   12852:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		  lcd_printf(4,1,PSTR("4)Settings   *)Exit "));
   12856:	84 e0       	ldi	r24, 0x04	; 4
   12858:	61 e0       	ldi	r22, 0x01	; 1
   1285a:	4c ed       	ldi	r20, 0xDC	; 220
   1285c:	55 e1       	ldi	r21, 0x15	; 21
   1285e:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
	      stMenuAdmin=maSelectOptions;
   12862:	81 e0       	ldi	r24, 0x01	; 1
   12864:	2e c0       	rjmp	.+92     	; 0x128c2 <FMenuAdmin+0xc8>
	      break;
	 case maSelectOptions:
          KeyPressed=_key_scan(1);
   12866:	81 e0       	ldi	r24, 0x01	; 1
   12868:	0e 94 06 b0 	call	0x1600c	; 0x1600c <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
   1286c:	0e 94 67 af 	call	0x15ece	; 0x15ece <_key_btn>
		  switch (KeyChar){
   12870:	82 33       	cpi	r24, 0x32	; 50
   12872:	71 f0       	breq	.+28     	; 0x12890 <FMenuAdmin+0x96>
   12874:	83 33       	cpi	r24, 0x33	; 51
   12876:	28 f4       	brcc	.+10     	; 0x12882 <FMenuAdmin+0x88>
   12878:	8a 32       	cpi	r24, 0x2A	; 42
   1287a:	11 f1       	breq	.+68     	; 0x128c0 <FMenuAdmin+0xc6>
   1287c:	81 33       	cpi	r24, 0x31	; 49
   1287e:	81 f5       	brne	.+96     	; 0x128e0 <FMenuAdmin+0xe6>
   12880:	05 c0       	rjmp	.+10     	; 0x1288c <FMenuAdmin+0x92>
   12882:	83 33       	cpi	r24, 0x33	; 51
   12884:	59 f0       	breq	.+22     	; 0x1289c <FMenuAdmin+0xa2>
   12886:	84 33       	cpi	r24, 0x34	; 52
   12888:	59 f5       	brne	.+86     	; 0x128e0 <FMenuAdmin+0xe6>
   1288a:	0e c0       	rjmp	.+28     	; 0x128a8 <FMenuAdmin+0xae>
		  case '1':
		       stMenuAdmin=maMenuReprint;//maMenuAdminConfig;
   1288c:	82 e0       	ldi	r24, 0x02	; 2
   1288e:	19 c0       	rjmp	.+50     	; 0x128c2 <FMenuAdmin+0xc8>
		       break;  
		  case '2':
		       if (IFType==IT_STANDALONE)
   12890:	80 91 10 01 	lds	r24, 0x0110
   12894:	82 30       	cpi	r24, 0x02	; 2
   12896:	e1 f4       	brne	.+56     	; 0x128d0 <FMenuAdmin+0xd6>
			       stMenuAdmin=maMenuCloseShift;
   12898:	84 e0       	ldi	r24, 0x04	; 4
   1289a:	13 c0       	rjmp	.+38     	; 0x128c2 <FMenuAdmin+0xc8>
               else stMenuAdmin=maInitAdmin;
		       break;  
		  case '3':
		       if (IFType==IT_STANDALONE)stMenuAdmin=maMenuCloseDay;
   1289c:	80 91 10 01 	lds	r24, 0x0110
   128a0:	82 30       	cpi	r24, 0x02	; 2
   128a2:	b1 f4       	brne	.+44     	; 0x128d0 <FMenuAdmin+0xd6>
   128a4:	85 e0       	ldi	r24, 0x05	; 5
   128a6:	0d c0       	rjmp	.+26     	; 0x128c2 <FMenuAdmin+0xc8>
               else stMenuAdmin=maInitAdmin;
		       break;  
		  case '4':
		  	   stMenuAdmin=maMenuAdminSettings;
   128a8:	86 e0       	ldi	r24, 0x06	; 6
   128aa:	0b c0       	rjmp	.+22     	; 0x128c2 <FMenuAdmin+0xc8>
    		   stMenuAdmin=maExitMenuAdmin;
		       break;  		  
		  }		  
	      break;
     case maMenuReprint:
	      SubMenu=FMenuReprint();
   128ac:	0e 94 c7 92 	call	0x1258e	; 0x1258e <FMenuReprint>
   128b0:	05 c0       	rjmp	.+10     	; 0x128bc <FMenuAdmin+0xc2>
	 case maMenuAdminConfig://ChangePassword[],RePrint,PumpTest
	      SubMenu=FSubMenuAdmin();
		  if (SubMenu==MENU_DONE)stMenuAdmin=maInitAdmin;
          break;	 
	 case maMenuCloseShift:
	 	  SubMenu=FCloseShift(CONTINUE_SHIFT);
   128b2:	82 e0       	ldi	r24, 0x02	; 2
   128b4:	01 c0       	rjmp	.+2      	; 0x128b8 <FMenuAdmin+0xbe>
		  if (SubMenu==MENU_DONE)stMenuAdmin=maExitMenuAdmin;
	      break;
     case maMenuCloseDay://maMenuCloseShift,maMenuCloseDay
	 	  SubMenu=FCloseShift(NEW_SHIFT);
   128b6:	81 e0       	ldi	r24, 0x01	; 1
   128b8:	0e 94 4d 60 	call	0xc09a	; 0xc09a <FCloseShift>
		  if (SubMenu==MENU_DONE)stMenuAdmin=maExitMenuAdmin;
   128bc:	81 30       	cpi	r24, 0x01	; 1
   128be:	81 f4       	brne	.+32     	; 0x128e0 <FMenuAdmin+0xe6>
   128c0:	87 e0       	ldi	r24, 0x07	; 7
   128c2:	80 93 22 03 	sts	0x0322, r24
   128c6:	06 c0       	rjmp	.+12     	; 0x128d4 <FMenuAdmin+0xda>
	      break;
     case maMenuAdminSettings:
	      SubMenu=FMenuAdminSettings();
   128c8:	0e 94 66 8f 	call	0x11ecc	; 0x11ecc <FMenuAdminSettings>
		  if (SubMenu==MENU_DONE)stMenuAdmin=maInitAdmin;	      
   128cc:	81 30       	cpi	r24, 0x01	; 1
   128ce:	41 f4       	brne	.+16     	; 0x128e0 <FMenuAdmin+0xe6>
   128d0:	10 92 22 03 	sts	0x0322, r1
   128d4:	80 e0       	ldi	r24, 0x00	; 0
   128d6:	08 95       	ret
	      break;
     case maExitMenuAdmin:
	      stMenuAdmin=maInitAdmin;	      
   128d8:	10 92 22 03 	sts	0x0322, r1
   128dc:	81 e0       	ldi	r24, 0x01	; 1
   128de:	08 95       	ret
   128e0:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
          break;	 
	 }
   return Result;
}
   128e2:	08 95       	ret

000128e4 <FMenuChangeMOP>:
	      break;
	 }
   return Result;
}

char FMenuChangeMOP(){
   128e4:	af 92       	push	r10
   128e6:	bf 92       	push	r11
   128e8:	cf 92       	push	r12
   128ea:	df 92       	push	r13
   128ec:	ef 92       	push	r14
   128ee:	ff 92       	push	r15
   128f0:	0f 93       	push	r16
   128f2:	1f 93       	push	r17
   128f4:	df 93       	push	r29
   128f6:	cf 93       	push	r28
   128f8:	cd b7       	in	r28, 0x3d	; 61
   128fa:	de b7       	in	r29, 0x3e	; 62
   128fc:	a3 97       	sbiw	r28, 0x23	; 35
   128fe:	0f b6       	in	r0, 0x3f	; 63
   12900:	f8 94       	cli
   12902:	de bf       	out	0x3e, r29	; 62
   12904:	0f be       	out	0x3f, r0	; 63
   12906:	cd bf       	out	0x3d, r28	; 61
	   char strBankName[11],strSurcharge[4],Result;
static char BankIdx=0,uiResult;//,Surcharge=0;
     
Result=MENU_NONE; 

	 switch(stChangeMOP){
   12908:	80 91 47 03 	lds	r24, 0x0347
   1290c:	e8 2f       	mov	r30, r24
   1290e:	f0 e0       	ldi	r31, 0x00	; 0
   12910:	ee 31       	cpi	r30, 0x1E	; 30
   12912:	f1 05       	cpc	r31, r1
   12914:	08 f0       	brcs	.+2      	; 0x12918 <FMenuChangeMOP+0x34>
   12916:	24 c4       	rjmp	.+2120   	; 0x13160 <FMenuChangeMOP+0x87c>
   12918:	ec 53       	subi	r30, 0x3C	; 60
   1291a:	ff 4f       	sbci	r31, 0xFF	; 255
   1291c:	ee 0f       	add	r30, r30
   1291e:	ff 1f       	adc	r31, r31
   12920:	05 90       	lpm	r0, Z+
   12922:	f4 91       	lpm	r31, Z+
   12924:	e0 2d       	mov	r30, r0
   12926:	09 94       	ijmp
	 case cmInit:
	      MOPType=PAY_NONE;
   12928:	85 e0       	ldi	r24, 0x05	; 5
   1292a:	80 93 cf 01 	sts	0x01CF, r24
   1292e:	4e c1       	rjmp	.+668    	; 0x12bcc <FMenuChangeMOP+0x2e8>
		  stChangeMOP=cmDisplayMOPOption;
	      break;
	 case cmDisplayMOPOption: //12345678901234567890
	      lcd_clear();
   12930:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
	      lcd_printf(1,1,PSTR("   Select Payment   "));
   12934:	81 e0       	ldi	r24, 0x01	; 1
   12936:	61 e0       	ldi	r22, 0x01	; 1
   12938:	42 eb       	ldi	r20, 0xB2	; 178
   1293a:	59 e1       	ldi	r21, 0x19	; 25
   1293c:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
	      lcd_printf(2,1,PSTR("1.Account 3.Voucher "));
   12940:	82 e0       	ldi	r24, 0x02	; 2
   12942:	61 e0       	ldi	r22, 0x01	; 1
   12944:	4d e9       	ldi	r20, 0x9D	; 157
   12946:	59 e1       	ldi	r21, 0x19	; 25
   12948:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
	      lcd_printf(3,1,PSTR("2.Bank    4.PumpTest"));
   1294c:	83 e0       	ldi	r24, 0x03	; 3
   1294e:	61 e0       	ldi	r22, 0x01	; 1
   12950:	48 e8       	ldi	r20, 0x88	; 136
   12952:	59 e1       	ldi	r21, 0x19	; 25
   12954:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
	      lcd_printf(4,1,PSTR("[*]Back             "));
   12958:	84 e0       	ldi	r24, 0x04	; 4
   1295a:	61 e0       	ldi	r22, 0x01	; 1
   1295c:	43 e7       	ldi	r20, 0x73	; 115
   1295e:	59 e1       	ldi	r21, 0x19	; 25
   12960:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
          stChangeMOP=cmInputMOP;		 
   12964:	82 e0       	ldi	r24, 0x02	; 2
   12966:	b5 c1       	rjmp	.+874    	; 0x12cd2 <FMenuChangeMOP+0x3ee>
		  break;
	 case cmInputMOP:
	      KeyPressed=_key_scan(1);
   12968:	81 e0       	ldi	r24, 0x01	; 1
   1296a:	0e 94 06 b0 	call	0x1600c	; 0x1600c <_key_scan>
   1296e:	80 93 42 03 	sts	0x0342, r24
		  KeyChar=_key_btn(KeyPressed);
   12972:	0e 94 67 af 	call	0x15ece	; 0x15ece <_key_btn>
   12976:	98 2f       	mov	r25, r24
   12978:	80 93 43 03 	sts	0x0343, r24
		  if ((KeyChar>='1')&&(KeyChar<='4')){
   1297c:	81 53       	subi	r24, 0x31	; 49
   1297e:	84 30       	cpi	r24, 0x04	; 4
   12980:	f0 f4       	brcc	.+60     	; 0x129be <FMenuChangeMOP+0xda>
              switch(KeyChar){
   12982:	92 33       	cpi	r25, 0x32	; 50
   12984:	61 f0       	breq	.+24     	; 0x1299e <FMenuChangeMOP+0xba>
   12986:	93 33       	cpi	r25, 0x33	; 51
   12988:	18 f4       	brcc	.+6      	; 0x12990 <FMenuChangeMOP+0xac>
   1298a:	91 33       	cpi	r25, 0x31	; 49
   1298c:	c1 f4       	brne	.+48     	; 0x129be <FMenuChangeMOP+0xda>
   1298e:	05 c0       	rjmp	.+10     	; 0x1299a <FMenuChangeMOP+0xb6>
   12990:	93 33       	cpi	r25, 0x33	; 51
   12992:	51 f0       	breq	.+20     	; 0x129a8 <FMenuChangeMOP+0xc4>
   12994:	94 33       	cpi	r25, 0x34	; 52
   12996:	99 f4       	brne	.+38     	; 0x129be <FMenuChangeMOP+0xda>
   12998:	0c c0       	rjmp	.+24     	; 0x129b2 <FMenuChangeMOP+0xce>
		        case '1':MOPType=PAY_ACCOUNT; stChangeMOP=cmSelectFIP;         break;
   1299a:	81 e0       	ldi	r24, 0x01	; 1
   1299c:	0b c0       	rjmp	.+22     	; 0x129b4 <FMenuChangeMOP+0xd0>
		        case '2':MOPType=PAY_BANK;    stChangeMOP=cmSelectBankName;    break;
   1299e:	82 e0       	ldi	r24, 0x02	; 2
   129a0:	80 93 cf 01 	sts	0x01CF, r24
   129a4:	8b e0       	ldi	r24, 0x0B	; 11
   129a6:	09 c0       	rjmp	.+18     	; 0x129ba <FMenuChangeMOP+0xd6>
		        case '3':MOPType=PAY_VOUCHER; stChangeMOP=cmDispInputVoucher;  break;
   129a8:	83 e0       	ldi	r24, 0x03	; 3
   129aa:	80 93 cf 01 	sts	0x01CF, r24
   129ae:	8f e0       	ldi	r24, 0x0F	; 15
   129b0:	04 c0       	rjmp	.+8      	; 0x129ba <FMenuChangeMOP+0xd6>
		        case '4':MOPType=PAY_PUMPTEST;stChangeMOP=cmSelectFIP;         break;
   129b2:	84 e0       	ldi	r24, 0x04	; 4
   129b4:	80 93 cf 01 	sts	0x01CF, r24
   129b8:	89 e0       	ldi	r24, 0x09	; 9
   129ba:	80 93 47 03 	sts	0x0347, r24
		     }
		  }
		  if (KeyPressed==_KEY_CANCEL) stChangeMOP=cmExitChangeMOP;
   129be:	80 91 42 03 	lds	r24, 0x0342
   129c2:	87 3e       	cpi	r24, 0xE7	; 231
   129c4:	09 f0       	breq	.+2      	; 0x129c8 <FMenuChangeMOP+0xe4>
   129c6:	cc c3       	rjmp	.+1944   	; 0x13160 <FMenuChangeMOP+0x87c>
   129c8:	c3 c3       	rjmp	.+1926   	; 0x13150 <FMenuChangeMOP+0x86c>
	      break;
	 case cmDispInputVoucher://Enter Voucher number
          lcd_clear();
   129ca:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
		  lcd_printf(1,1,PSTR("Kode Voucher"));
   129ce:	81 e0       	ldi	r24, 0x01	; 1
   129d0:	61 e0       	ldi	r22, 0x01	; 1
   129d2:	46 e6       	ldi	r20, 0x66	; 102
   129d4:	59 e1       	ldi	r21, 0x19	; 25
   129d6:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		  lcd_printf(2,1,PSTR("_"));
   129da:	82 e0       	ldi	r24, 0x02	; 2
   129dc:	61 e0       	ldi	r22, 0x01	; 1
   129de:	44 e6       	ldi	r20, 0x64	; 100
   129e0:	59 e1       	ldi	r21, 0x19	; 25
   129e2:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		  lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   129e6:	84 e0       	ldi	r24, 0x04	; 4
   129e8:	61 e0       	ldi	r22, 0x01	; 1
   129ea:	4f e4       	ldi	r20, 0x4F	; 79
   129ec:	59 e1       	ldi	r21, 0x19	; 25
   129ee:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
   129f2:	e7 e1       	ldi	r30, 0x17	; 23
   129f4:	fe e0       	ldi	r31, 0x0E	; 14
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
   129f6:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   129f8:	8e e0       	ldi	r24, 0x0E	; 14
   129fa:	ec 32       	cpi	r30, 0x2C	; 44
   129fc:	f8 07       	cpc	r31, r24
   129fe:	d9 f7       	brne	.-10     	; 0x129f6 <FMenuChangeMOP+0x112>
          lcd_clear();
		  lcd_printf(1,1,PSTR("Kode Voucher"));
		  lcd_printf(2,1,PSTR("_"));
		  lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
		  FillChar(strVoucherNum,sizeof(strVoucherNum),0);
          stChangeMOP=cmInputVoucher;
   12a00:	87 e0       	ldi	r24, 0x07	; 7
   12a02:	80 93 47 03 	sts	0x0347, r24
		  uiResult=USER_NONE;
   12a06:	10 92 33 03 	sts	0x0333, r1
   12a0a:	aa c3       	rjmp	.+1876   	; 0x13160 <FMenuChangeMOP+0x87c>
	      break;
     case cmInputVoucher:
          uiResult=UserInput(UI_NUMBER_R,2,1,strVoucherNum,0,13);
   12a0c:	81 e0       	ldi	r24, 0x01	; 1
   12a0e:	62 e0       	ldi	r22, 0x02	; 2
   12a10:	41 e0       	ldi	r20, 0x01	; 1
   12a12:	27 e1       	ldi	r18, 0x17	; 23
   12a14:	3e e0       	ldi	r19, 0x0E	; 14
   12a16:	00 e0       	ldi	r16, 0x00	; 0
   12a18:	10 e0       	ldi	r17, 0x00	; 0
   12a1a:	5d e0       	ldi	r21, 0x0D	; 13
   12a1c:	e5 2e       	mov	r14, r21
   12a1e:	0e 94 4b 7d 	call	0xfa96	; 0xfa96 <UserInput>
   12a22:	80 93 33 03 	sts	0x0333, r24
	      if (uiResult==USER_OK){
   12a26:	83 30       	cpi	r24, 0x03	; 3
   12a28:	11 f4       	brne	.+4      	; 0x12a2e <FMenuChangeMOP+0x14a>
		     stChangeMOP=cmSelectFIP;
   12a2a:	89 e0       	ldi	r24, 0x09	; 9
   12a2c:	52 c1       	rjmp	.+676    	; 0x12cd2 <FMenuChangeMOP+0x3ee>
			 }
		  else
	      if (uiResult==USER_CANCEL)stChangeMOP=cmDisplayMOPOption;
   12a2e:	81 30       	cpi	r24, 0x01	; 1
   12a30:	09 f4       	brne	.+2      	; 0x12a34 <FMenuChangeMOP+0x150>
   12a32:	4f c1       	rjmp	.+670    	; 0x12cd2 <FMenuChangeMOP+0x3ee>
		  else
		  if (uiResult==USER_ENTRY)lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   12a34:	84 30       	cpi	r24, 0x04	; 4
   12a36:	21 f4       	brne	.+8      	; 0x12a40 <FMenuChangeMOP+0x15c>
   12a38:	61 e0       	ldi	r22, 0x01	; 1
   12a3a:	4a e3       	ldi	r20, 0x3A	; 58
   12a3c:	59 e1       	ldi	r21, 0x19	; 25
   12a3e:	31 c1       	rjmp	.+610    	; 0x12ca2 <FMenuChangeMOP+0x3be>
		  else
		  if (uiResult==USER_NO_DATA)lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   12a40:	85 30       	cpi	r24, 0x05	; 5
   12a42:	09 f0       	breq	.+2      	; 0x12a46 <FMenuChangeMOP+0x162>
   12a44:	8d c3       	rjmp	.+1818   	; 0x13160 <FMenuChangeMOP+0x87c>
   12a46:	84 e0       	ldi	r24, 0x04	; 4
   12a48:	61 e0       	ldi	r22, 0x01	; 1
   12a4a:	45 e2       	ldi	r20, 0x25	; 37
   12a4c:	59 e1       	ldi	r21, 0x19	; 25
   12a4e:	29 c1       	rjmp	.+594    	; 0x12ca2 <FMenuChangeMOP+0x3be>
	      break;
	 case cmSelectFIP:
	      FIPResult=menu_FIP(&FIP_Used,strFIP_ID);
   12a50:	81 e4       	ldi	r24, 0x41	; 65
   12a52:	93 e0       	ldi	r25, 0x03	; 3
   12a54:	6c e9       	ldi	r22, 0x9C	; 156
   12a56:	79 e0       	ldi	r23, 0x09	; 9
   12a58:	0e 94 f1 64 	call	0xc9e2	; 0xc9e2 <menu_FIP>
   12a5c:	80 93 46 03 	sts	0x0346, r24
		  if (FIPResult==FIP_DONE){
   12a60:	88 23       	and	r24, r24
   12a62:	11 f4       	brne	.+4      	; 0x12a68 <FMenuChangeMOP+0x184>
		      //sprintf_P(strFIP_ID,PSTR("%.2d"),FIP_Used);
		      stChangeMOP=cmFlowFIP;
   12a64:	8e e0       	ldi	r24, 0x0E	; 14
   12a66:	35 c1       	rjmp	.+618    	; 0x12cd2 <FMenuChangeMOP+0x3ee>
		  }
		  else
		  if (FIPResult==FIP_CANCEL){
   12a68:	82 30       	cpi	r24, 0x02	; 2
   12a6a:	09 f0       	breq	.+2      	; 0x12a6e <FMenuChangeMOP+0x18a>
   12a6c:	79 c3       	rjmp	.+1778   	; 0x13160 <FMenuChangeMOP+0x87c>
		      if (MOPType==PAY_ACCOUNT)stChangeMOP=cmDisplayMOPOption;
   12a6e:	80 91 cf 01 	lds	r24, 0x01CF
   12a72:	81 30       	cpi	r24, 0x01	; 1
   12a74:	09 f4       	brne	.+2      	; 0x12a78 <FMenuChangeMOP+0x194>
   12a76:	2d c1       	rjmp	.+602    	; 0x12cd2 <FMenuChangeMOP+0x3ee>
		      if (MOPType==PAY_BANK)stChangeMOP=cmSelectBankName;
   12a78:	82 30       	cpi	r24, 0x02	; 2
   12a7a:	09 f4       	brne	.+2      	; 0x12a7e <FMenuChangeMOP+0x19a>
   12a7c:	03 c1       	rjmp	.+518    	; 0x12c84 <FMenuChangeMOP+0x3a0>
		      if (MOPType==PAY_VOUCHER)stChangeMOP=cmDispInputVoucher;
   12a7e:	83 30       	cpi	r24, 0x03	; 3
   12a80:	11 f4       	brne	.+4      	; 0x12a86 <FMenuChangeMOP+0x1a2>
   12a82:	8f e0       	ldi	r24, 0x0F	; 15
   12a84:	26 c1       	rjmp	.+588    	; 0x12cd2 <FMenuChangeMOP+0x3ee>
		      if (MOPType==PAY_PUMPTEST)stChangeMOP=cmDisplayMOPOption;		  
   12a86:	84 30       	cpi	r24, 0x04	; 4
   12a88:	09 f4       	brne	.+2      	; 0x12a8c <FMenuChangeMOP+0x1a8>
   12a8a:	a0 c0       	rjmp	.+320    	; 0x12bcc <FMenuChangeMOP+0x2e8>
   12a8c:	69 c3       	rjmp	.+1746   	; 0x13160 <FMenuChangeMOP+0x87c>
     case cmSelectFIPInput:
		
	      break;
		  //Load Bank Information
	 case cmSelectBankName:
	      lcd_clear();
   12a8e:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
		  lcd_printf(1,1,PSTR("Select Bank"));
   12a92:	81 e0       	ldi	r24, 0x01	; 1
   12a94:	61 e0       	ldi	r22, 0x01	; 1
   12a96:	49 e1       	ldi	r20, 0x19	; 25
   12a98:	59 e1       	ldi	r21, 0x19	; 25
   12a9a:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		  iLoop=0;
	      for(iLoop=0;iLoop<4;iLoop++){
   12a9e:	10 92 36 03 	sts	0x0336, r1
   12aa2:	10 92 35 03 	sts	0x0335, r1
   12aa6:	8e 01       	movw	r16, r28
   12aa8:	0b 5f       	subi	r16, 0xFB	; 251
   12aaa:	1f 4f       	sbci	r17, 0xFF	; 255
   12aac:	9b e0       	ldi	r25, 0x0B	; 11
   12aae:	a9 2e       	mov	r10, r25
   12ab0:	b1 2c       	mov	r11, r1
			  eeprom_read_block((void*) &strBankName, (const void*) &DefBankName[iLoop], 11);
			  if (strlen(strBankName<=10)){
			     sprintf_P(lcdteks,PSTR("%d.%s"),(iLoop+1),strBankName);
   12ab2:	80 e1       	ldi	r24, 0x10	; 16
   12ab4:	e8 2e       	mov	r14, r24
   12ab6:	f1 2c       	mov	r15, r1
   12ab8:	ec 0e       	add	r14, r28
   12aba:	fd 1e       	adc	r15, r29
   12abc:	b3 e1       	ldi	r27, 0x13	; 19
   12abe:	cb 2e       	mov	r12, r27
   12ac0:	b9 e1       	ldi	r27, 0x19	; 25
   12ac2:	db 2e       	mov	r13, r27
   12ac4:	5d c0       	rjmp	.+186    	; 0x12b80 <FMenuChangeMOP+0x29c>
   12ac6:	8a 9d       	mul	r24, r10
   12ac8:	b0 01       	movw	r22, r0
   12aca:	8b 9d       	mul	r24, r11
   12acc:	70 0d       	add	r23, r0
   12ace:	9a 9d       	mul	r25, r10
   12ad0:	70 0d       	add	r23, r0
   12ad2:	11 24       	eor	r1, r1
   12ad4:	67 5f       	subi	r22, 0xF7	; 247
   12ad6:	7e 4f       	sbci	r23, 0xFE	; 254
   12ad8:	c8 01       	movw	r24, r16
   12ada:	4b e0       	ldi	r20, 0x0B	; 11
   12adc:	50 e0       	ldi	r21, 0x00	; 0
   12ade:	26 ef       	ldi	r18, 0xF6	; 246
   12ae0:	32 e1       	ldi	r19, 0x12	; 18
   12ae2:	0e 94 7a b5 	call	0x16af4	; 0x16af4 <__eerd_block>
	      lcd_clear();
		  lcd_printf(1,1,PSTR("Select Bank"));
		  iLoop=0;
	      for(iLoop=0;iLoop<4;iLoop++){
			  eeprom_read_block((void*) &strBankName, (const void*) &DefBankName[iLoop], 11);
			  if (strlen(strBankName<=10)){
   12ae6:	e0 e0       	ldi	r30, 0x00	; 0
   12ae8:	f0 e0       	ldi	r31, 0x00	; 0
   12aea:	0b 30       	cpi	r16, 0x0B	; 11
   12aec:	11 05       	cpc	r17, r1
   12aee:	10 f4       	brcc	.+4      	; 0x12af4 <FMenuChangeMOP+0x210>
   12af0:	e1 e0       	ldi	r30, 0x01	; 1
   12af2:	f0 e0       	ldi	r31, 0x00	; 0
   12af4:	80 81       	ld	r24, Z
   12af6:	88 23       	and	r24, r24
   12af8:	d1 f1       	breq	.+116    	; 0x12b6e <FMenuChangeMOP+0x28a>
			     sprintf_P(lcdteks,PSTR("%d.%s"),(iLoop+1),strBankName);
   12afa:	ad b7       	in	r26, 0x3d	; 61
   12afc:	be b7       	in	r27, 0x3e	; 62
   12afe:	18 97       	sbiw	r26, 0x08	; 8
   12b00:	0f b6       	in	r0, 0x3f	; 63
   12b02:	f8 94       	cli
   12b04:	be bf       	out	0x3e, r27	; 62
   12b06:	0f be       	out	0x3f, r0	; 63
   12b08:	ad bf       	out	0x3d, r26	; 61
   12b0a:	ed b7       	in	r30, 0x3d	; 61
   12b0c:	fe b7       	in	r31, 0x3e	; 62
   12b0e:	31 96       	adiw	r30, 0x01	; 1
   12b10:	12 96       	adiw	r26, 0x02	; 2
   12b12:	fc 92       	st	X, r15
   12b14:	ee 92       	st	-X, r14
   12b16:	11 97       	sbiw	r26, 0x01	; 1
   12b18:	d3 82       	std	Z+3, r13	; 0x03
   12b1a:	c2 82       	std	Z+2, r12	; 0x02
   12b1c:	80 91 35 03 	lds	r24, 0x0335
   12b20:	90 91 36 03 	lds	r25, 0x0336
   12b24:	01 96       	adiw	r24, 0x01	; 1
   12b26:	95 83       	std	Z+5, r25	; 0x05
   12b28:	84 83       	std	Z+4, r24	; 0x04
   12b2a:	17 83       	std	Z+7, r17	; 0x07
   12b2c:	06 83       	std	Z+6, r16	; 0x06
   12b2e:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
			     lcd_print((2+(iLoop%2)),(1+((iLoop/2)*12)),lcdteks);
   12b32:	20 91 35 03 	lds	r18, 0x0335
   12b36:	30 91 36 03 	lds	r19, 0x0336
   12b3a:	ed b7       	in	r30, 0x3d	; 61
   12b3c:	fe b7       	in	r31, 0x3e	; 62
   12b3e:	38 96       	adiw	r30, 0x08	; 8
   12b40:	0f b6       	in	r0, 0x3f	; 63
   12b42:	f8 94       	cli
   12b44:	fe bf       	out	0x3e, r31	; 62
   12b46:	0f be       	out	0x3f, r0	; 63
   12b48:	ed bf       	out	0x3d, r30	; 61
   12b4a:	82 2f       	mov	r24, r18
   12b4c:	81 70       	andi	r24, 0x01	; 1
   12b4e:	36 95       	lsr	r19
   12b50:	27 95       	ror	r18
   12b52:	b9 01       	movw	r22, r18
   12b54:	66 0f       	add	r22, r22
   12b56:	77 1f       	adc	r23, r23
   12b58:	62 0f       	add	r22, r18
   12b5a:	73 1f       	adc	r23, r19
   12b5c:	66 0f       	add	r22, r22
   12b5e:	77 1f       	adc	r23, r23
   12b60:	66 0f       	add	r22, r22
   12b62:	77 1f       	adc	r23, r23
   12b64:	6f 5f       	subi	r22, 0xFF	; 255
   12b66:	8e 5f       	subi	r24, 0xFE	; 254
   12b68:	a7 01       	movw	r20, r14
   12b6a:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
		  //Load Bank Information
	 case cmSelectBankName:
	      lcd_clear();
		  lcd_printf(1,1,PSTR("Select Bank"));
		  iLoop=0;
	      for(iLoop=0;iLoop<4;iLoop++){
   12b6e:	80 91 35 03 	lds	r24, 0x0335
   12b72:	90 91 36 03 	lds	r25, 0x0336
   12b76:	01 96       	adiw	r24, 0x01	; 1
   12b78:	90 93 36 03 	sts	0x0336, r25
   12b7c:	80 93 35 03 	sts	0x0335, r24
   12b80:	80 91 35 03 	lds	r24, 0x0335
   12b84:	90 91 36 03 	lds	r25, 0x0336
   12b88:	84 30       	cpi	r24, 0x04	; 4
   12b8a:	91 05       	cpc	r25, r1
   12b8c:	08 f4       	brcc	.+2      	; 0x12b90 <FMenuChangeMOP+0x2ac>
   12b8e:	9b cf       	rjmp	.-202    	; 0x12ac6 <FMenuChangeMOP+0x1e2>
			  if (strlen(strBankName<=10)){
			     sprintf_P(lcdteks,PSTR("%d.%s"),(iLoop+1),strBankName);
			     lcd_print((2+(iLoop%2)),(1+((iLoop/2)*12)),lcdteks);
				 }
		  }
	      lcd_printf(4,1,PSTR("[*]Back"));
   12b90:	84 e0       	ldi	r24, 0x04	; 4
   12b92:	61 e0       	ldi	r22, 0x01	; 1
   12b94:	4b e0       	ldi	r20, 0x0B	; 11
   12b96:	59 e1       	ldi	r21, 0x19	; 25
   12b98:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		  stChangeMOP=cmSelectBankNameInput;
   12b9c:	8c e0       	ldi	r24, 0x0C	; 12
   12b9e:	99 c0       	rjmp	.+306    	; 0x12cd2 <FMenuChangeMOP+0x3ee>
	      break;
     case cmSelectBankNameInput:
		  KeyPressed=_key_scan(1);
   12ba0:	81 e0       	ldi	r24, 0x01	; 1
   12ba2:	0e 94 06 b0 	call	0x1600c	; 0x1600c <_key_scan>
   12ba6:	80 93 42 03 	sts	0x0342, r24
		  KeyChar=_key_btn(KeyPressed);
   12baa:	0e 94 67 af 	call	0x15ece	; 0x15ece <_key_btn>
   12bae:	80 93 43 03 	sts	0x0343, r24
          if ((KeyChar>='1')&&(KeyChar<='4')){
   12bb2:	81 53       	subi	r24, 0x31	; 49
   12bb4:	84 30       	cpi	r24, 0x04	; 4
   12bb6:	28 f4       	brcc	.+10     	; 0x12bc2 <FMenuChangeMOP+0x2de>
		      BankIdx=KeyChar-'1';
   12bb8:	80 93 34 03 	sts	0x0334, r24
			  stChangeMOP=cmSelectFIP;
   12bbc:	89 e0       	ldi	r24, 0x09	; 9
   12bbe:	80 93 47 03 	sts	0x0347, r24
		  }
		  if (KeyPressed==_KEY_CANCEL) stChangeMOP=cmDisplayMOPOption;
   12bc2:	80 91 42 03 	lds	r24, 0x0342
   12bc6:	87 3e       	cpi	r24, 0xE7	; 231
   12bc8:	09 f0       	breq	.+2      	; 0x12bcc <FMenuChangeMOP+0x2e8>
   12bca:	ca c2       	rjmp	.+1428   	; 0x13160 <FMenuChangeMOP+0x87c>
   12bcc:	81 e0       	ldi	r24, 0x01	; 1
   12bce:	81 c0       	rjmp	.+258    	; 0x12cd2 <FMenuChangeMOP+0x3ee>

	      break;
     case cmDispBankSurcharge:
	      lcd_clear();
   12bd0:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
   12bd4:	65 e0       	ldi	r22, 0x05	; 5
   12bd6:	e6 2e       	mov	r14, r22
   12bd8:	f1 2c       	mov	r15, r1
   12bda:	ec 0e       	add	r14, r28
   12bdc:	fd 1e       	adc	r15, r29
   12bde:	60 91 34 03 	lds	r22, 0x0334
   12be2:	8b e0       	ldi	r24, 0x0B	; 11
   12be4:	68 9f       	mul	r22, r24
   12be6:	b0 01       	movw	r22, r0
   12be8:	11 24       	eor	r1, r1
   12bea:	67 5f       	subi	r22, 0xF7	; 247
   12bec:	7e 4f       	sbci	r23, 0xFE	; 254
   12bee:	c7 01       	movw	r24, r14
   12bf0:	4b e0       	ldi	r20, 0x0B	; 11
   12bf2:	50 e0       	ldi	r21, 0x00	; 0
   12bf4:	26 ef       	ldi	r18, 0xF6	; 246
   12bf6:	32 e1       	ldi	r19, 0x12	; 18
   12bf8:	0e 94 7a b5 	call	0x16af4	; 0x16af4 <__eerd_block>
		  eeprom_read_block((void*) &strBankName, (const void*) &DefBankName[BankIdx], 11);
		  sprintf_P(lcdteks,PSTR("%s"),strBankName);
   12bfc:	00 d0       	rcall	.+0      	; 0x12bfe <FMenuChangeMOP+0x31a>
   12bfe:	00 d0       	rcall	.+0      	; 0x12c00 <FMenuChangeMOP+0x31c>
   12c00:	00 d0       	rcall	.+0      	; 0x12c02 <FMenuChangeMOP+0x31e>
   12c02:	ed b7       	in	r30, 0x3d	; 61
   12c04:	fe b7       	in	r31, 0x3e	; 62
   12c06:	31 96       	adiw	r30, 0x01	; 1
   12c08:	8e 01       	movw	r16, r28
   12c0a:	00 5f       	subi	r16, 0xF0	; 240
   12c0c:	1f 4f       	sbci	r17, 0xFF	; 255
   12c0e:	ad b7       	in	r26, 0x3d	; 61
   12c10:	be b7       	in	r27, 0x3e	; 62
   12c12:	12 96       	adiw	r26, 0x02	; 2
   12c14:	1c 93       	st	X, r17
   12c16:	0e 93       	st	-X, r16
   12c18:	11 97       	sbiw	r26, 0x01	; 1
   12c1a:	88 e0       	ldi	r24, 0x08	; 8
   12c1c:	99 e1       	ldi	r25, 0x19	; 25
   12c1e:	93 83       	std	Z+3, r25	; 0x03
   12c20:	82 83       	std	Z+2, r24	; 0x02
   12c22:	f5 82       	std	Z+5, r15	; 0x05
   12c24:	e4 82       	std	Z+4, r14	; 0x04
   12c26:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
		  lcd_print(1,1,lcdteks);
   12c2a:	ed b7       	in	r30, 0x3d	; 61
   12c2c:	fe b7       	in	r31, 0x3e	; 62
   12c2e:	36 96       	adiw	r30, 0x06	; 6
   12c30:	0f b6       	in	r0, 0x3f	; 63
   12c32:	f8 94       	cli
   12c34:	fe bf       	out	0x3e, r31	; 62
   12c36:	0f be       	out	0x3f, r0	; 63
   12c38:	ed bf       	out	0x3d, r30	; 61
   12c3a:	81 e0       	ldi	r24, 0x01	; 1
   12c3c:	61 e0       	ldi	r22, 0x01	; 1
   12c3e:	a8 01       	movw	r20, r16
   12c40:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
		  lcd_printf(2,1,PSTR("Surcharge:   _%"));
   12c44:	82 e0       	ldi	r24, 0x02	; 2
   12c46:	61 e0       	ldi	r22, 0x01	; 1
   12c48:	48 ef       	ldi	r20, 0xF8	; 248
   12c4a:	58 e1       	ldi	r21, 0x18	; 24
   12c4c:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
	      lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   12c50:	84 e0       	ldi	r24, 0x04	; 4
   12c52:	61 e0       	ldi	r22, 0x01	; 1
   12c54:	43 ee       	ldi	r20, 0xE3	; 227
   12c56:	58 e1       	ldi	r21, 0x18	; 24
   12c58:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
          stChangeMOP=cmInputBankSurcharge;
   12c5c:	8d e0       	ldi	r24, 0x0D	; 13
   12c5e:	39 c0       	rjmp	.+114    	; 0x12cd2 <FMenuChangeMOP+0x3ee>
	      break;
	 case cmInputBankSurcharge:
	      uiResult=UserInput(UI_NUMBER_L,2,14,ValueChar,100,3);
   12c60:	82 e0       	ldi	r24, 0x02	; 2
   12c62:	62 e0       	ldi	r22, 0x02	; 2
   12c64:	4e e0       	ldi	r20, 0x0E	; 14
   12c66:	27 e3       	ldi	r18, 0x37	; 55
   12c68:	33 e0       	ldi	r19, 0x03	; 3
   12c6a:	04 e6       	ldi	r16, 0x64	; 100
   12c6c:	10 e0       	ldi	r17, 0x00	; 0
   12c6e:	53 e0       	ldi	r21, 0x03	; 3
   12c70:	e5 2e       	mov	r14, r21
   12c72:	0e 94 4b 7d 	call	0xfa96	; 0xfa96 <UserInput>
   12c76:	80 93 33 03 	sts	0x0333, r24
	      if (uiResult==USER_OK)stChangeMOP=cmGenerateData;
   12c7a:	83 30       	cpi	r24, 0x03	; 3
   12c7c:	09 f4       	brne	.+2      	; 0x12c80 <FMenuChangeMOP+0x39c>
   12c7e:	cb c0       	rjmp	.+406    	; 0x12e16 <FMenuChangeMOP+0x532>
		  else
	      if (uiResult==USER_CANCEL)stChangeMOP=cmSelectBankName;
   12c80:	81 30       	cpi	r24, 0x01	; 1
   12c82:	11 f4       	brne	.+4      	; 0x12c88 <FMenuChangeMOP+0x3a4>
   12c84:	8b e0       	ldi	r24, 0x0B	; 11
   12c86:	25 c0       	rjmp	.+74     	; 0x12cd2 <FMenuChangeMOP+0x3ee>
		  else
		  if (uiResult==USER_ENTRY)lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   12c88:	84 30       	cpi	r24, 0x04	; 4
   12c8a:	21 f4       	brne	.+8      	; 0x12c94 <FMenuChangeMOP+0x3b0>
   12c8c:	61 e0       	ldi	r22, 0x01	; 1
   12c8e:	4e ec       	ldi	r20, 0xCE	; 206
   12c90:	58 e1       	ldi	r21, 0x18	; 24
   12c92:	07 c0       	rjmp	.+14     	; 0x12ca2 <FMenuChangeMOP+0x3be>
		  else
		  if (uiResult==USER_NO_DATA)lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   12c94:	85 30       	cpi	r24, 0x05	; 5
   12c96:	09 f0       	breq	.+2      	; 0x12c9a <FMenuChangeMOP+0x3b6>
   12c98:	63 c2       	rjmp	.+1222   	; 0x13160 <FMenuChangeMOP+0x87c>
   12c9a:	84 e0       	ldi	r24, 0x04	; 4
   12c9c:	61 e0       	ldi	r22, 0x01	; 1
   12c9e:	49 eb       	ldi	r20, 0xB9	; 185
   12ca0:	58 e1       	ldi	r21, 0x18	; 24
   12ca2:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
   12ca6:	5c c2       	rjmp	.+1208   	; 0x13160 <FMenuChangeMOP+0x87c>
	      break;
     case cmFlowFIP:
          switch(MOPType){
   12ca8:	80 91 cf 01 	lds	r24, 0x01CF
   12cac:	82 30       	cpi	r24, 0x02	; 2
   12cae:	61 f0       	breq	.+24     	; 0x12cc8 <FMenuChangeMOP+0x3e4>
   12cb0:	83 30       	cpi	r24, 0x03	; 3
   12cb2:	20 f4       	brcc	.+8      	; 0x12cbc <FMenuChangeMOP+0x3d8>
   12cb4:	81 30       	cpi	r24, 0x01	; 1
   12cb6:	09 f0       	breq	.+2      	; 0x12cba <FMenuChangeMOP+0x3d6>
   12cb8:	53 c2       	rjmp	.+1190   	; 0x13160 <FMenuChangeMOP+0x87c>
   12cba:	0a c0       	rjmp	.+20     	; 0x12cd0 <FMenuChangeMOP+0x3ec>
   12cbc:	83 30       	cpi	r24, 0x03	; 3
   12cbe:	31 f0       	breq	.+12     	; 0x12ccc <FMenuChangeMOP+0x3e8>
   12cc0:	84 30       	cpi	r24, 0x04	; 4
   12cc2:	09 f0       	breq	.+2      	; 0x12cc6 <FMenuChangeMOP+0x3e2>
   12cc4:	4d c2       	rjmp	.+1178   	; 0x13160 <FMenuChangeMOP+0x87c>
   12cc6:	04 c0       	rjmp	.+8      	; 0x12cd0 <FMenuChangeMOP+0x3ec>
		  case PAY_ACCOUNT: stChangeMOP=cmDispCardTap;       break;
		  case PAY_BANK:    stChangeMOP=cmDispBankSurcharge; break;
   12cc8:	81 e1       	ldi	r24, 0x11	; 17
   12cca:	03 c0       	rjmp	.+6      	; 0x12cd2 <FMenuChangeMOP+0x3ee>
		  case PAY_VOUCHER: stChangeMOP=cmProsesVoucher;      break;
   12ccc:	85 e1       	ldi	r24, 0x15	; 21
   12cce:	01 c0       	rjmp	.+2      	; 0x12cd2 <FMenuChangeMOP+0x3ee>
		  case PAY_PUMPTEST:stChangeMOP=cmDispCardTap;       break;
   12cd0:	82 e1       	ldi	r24, 0x12	; 18
   12cd2:	80 93 47 03 	sts	0x0347, r24
   12cd6:	44 c2       	rjmp	.+1160   	; 0x13160 <FMenuChangeMOP+0x87c>
		  }
	      break;
     case cmDispCardTap:
	      lcd_clear();
   12cd8:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
	      lcd_printf(1,1,PSTR("Tap Kartu RFID"));
   12cdc:	81 e0       	ldi	r24, 0x01	; 1
   12cde:	61 e0       	ldi	r22, 0x01	; 1
   12ce0:	4a ea       	ldi	r20, 0xAA	; 170
   12ce2:	58 e1       	ldi	r21, 0x18	; 24
   12ce4:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		  sprintf_P(lcdteks,PSTR("FIP%s"),strFIP_ID);
   12ce8:	00 d0       	rcall	.+0      	; 0x12cea <FMenuChangeMOP+0x406>
   12cea:	00 d0       	rcall	.+0      	; 0x12cec <FMenuChangeMOP+0x408>
   12cec:	00 d0       	rcall	.+0      	; 0x12cee <FMenuChangeMOP+0x40a>
   12cee:	ed b7       	in	r30, 0x3d	; 61
   12cf0:	fe b7       	in	r31, 0x3e	; 62
   12cf2:	31 96       	adiw	r30, 0x01	; 1
   12cf4:	8e 01       	movw	r16, r28
   12cf6:	00 5f       	subi	r16, 0xF0	; 240
   12cf8:	1f 4f       	sbci	r17, 0xFF	; 255
   12cfa:	ad b7       	in	r26, 0x3d	; 61
   12cfc:	be b7       	in	r27, 0x3e	; 62
   12cfe:	12 96       	adiw	r26, 0x02	; 2
   12d00:	1c 93       	st	X, r17
   12d02:	0e 93       	st	-X, r16
   12d04:	11 97       	sbiw	r26, 0x01	; 1
   12d06:	84 ea       	ldi	r24, 0xA4	; 164
   12d08:	98 e1       	ldi	r25, 0x18	; 24
   12d0a:	93 83       	std	Z+3, r25	; 0x03
   12d0c:	82 83       	std	Z+2, r24	; 0x02
   12d0e:	8c e9       	ldi	r24, 0x9C	; 156
   12d10:	99 e0       	ldi	r25, 0x09	; 9
   12d12:	95 83       	std	Z+5, r25	; 0x05
   12d14:	84 83       	std	Z+4, r24	; 0x04
   12d16:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
		  lcd_print(2,1,lcdteks);
   12d1a:	ed b7       	in	r30, 0x3d	; 61
   12d1c:	fe b7       	in	r31, 0x3e	; 62
   12d1e:	36 96       	adiw	r30, 0x06	; 6
   12d20:	0f b6       	in	r0, 0x3f	; 63
   12d22:	f8 94       	cli
   12d24:	fe bf       	out	0x3e, r31	; 62
   12d26:	0f be       	out	0x3f, r0	; 63
   12d28:	ed bf       	out	0x3d, r30	; 61
   12d2a:	82 e0       	ldi	r24, 0x02	; 2
   12d2c:	61 e0       	ldi	r22, 0x01	; 1
   12d2e:	a8 01       	movw	r20, r16
   12d30:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
          lcd_printf(4,1,PSTR("[*]Back    [#]Exit"));
   12d34:	84 e0       	ldi	r24, 0x04	; 4
   12d36:	61 e0       	ldi	r22, 0x01	; 1
   12d38:	41 e9       	ldi	r20, 0x91	; 145
   12d3a:	58 e1       	ldi	r21, 0x18	; 24
   12d3c:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		  IsRFIDDetected=False;
   12d40:	10 92 af 01 	sts	0x01AF, r1
          stChangeMOP=cmRFIDCardInput;
   12d44:	83 e1       	ldi	r24, 0x13	; 19
   12d46:	c5 cf       	rjmp	.-118    	; 0x12cd2 <FMenuChangeMOP+0x3ee>
	      break;
	 case cmRFIDCardInput:
		  KeyPressed=_key_scan(1);
   12d48:	81 e0       	ldi	r24, 0x01	; 1
   12d4a:	0e 94 06 b0 	call	0x1600c	; 0x1600c <_key_scan>
   12d4e:	80 93 42 03 	sts	0x0342, r24
		  KeyChar=_key_btn(KeyPressed);
   12d52:	0e 94 67 af 	call	0x15ece	; 0x15ece <_key_btn>
   12d56:	80 93 43 03 	sts	0x0343, r24
		  if (KeyPressed==_KEY_ENTER){
   12d5a:	80 91 42 03 	lds	r24, 0x0342
   12d5e:	87 3b       	cpi	r24, 0xB7	; 183
   12d60:	11 f4       	brne	.+4      	; 0x12d66 <FMenuChangeMOP+0x482>
		      stChangeMOP=cmExitChangeMOP;
   12d62:	8c e1       	ldi	r24, 0x1C	; 28
   12d64:	03 c0       	rjmp	.+6      	; 0x12d6c <FMenuChangeMOP+0x488>
		  }
		  else
		  if (KeyPressed==_KEY_CANCEL){
   12d66:	87 3e       	cpi	r24, 0xE7	; 231
   12d68:	19 f4       	brne	.+6      	; 0x12d70 <FMenuChangeMOP+0x48c>
   		      stChangeMOP=cmSelectFIP;
   12d6a:	89 e0       	ldi	r24, 0x09	; 9
   12d6c:	80 93 47 03 	sts	0x0347, r24
			 }
          if (IsRFIDDetected==True){
   12d70:	80 91 af 01 	lds	r24, 0x01AF
   12d74:	81 30       	cpi	r24, 0x01	; 1
   12d76:	09 f0       	breq	.+2      	; 0x12d7a <FMenuChangeMOP+0x496>
   12d78:	f3 c1       	rjmp	.+998    	; 0x13160 <FMenuChangeMOP+0x87c>
		      IsRFIDDetected=False;
   12d7a:	10 92 af 01 	sts	0x01AF, r1
			   stChangeMOP=cmProsesRFID;
   12d7e:	84 e1       	ldi	r24, 0x14	; 20
   12d80:	a8 cf       	rjmp	.-176    	; 0x12cd2 <FMenuChangeMOP+0x3ee>
   12d82:	20 e0       	ldi	r18, 0x00	; 0
   12d84:	30 e0       	ldi	r19, 0x00	; 0
}

void ViewCardID(){//+12345678 -->12345678
     char i;
	 for(i=0;i<8;i++){         //00000000000012345678
		strCardID[i]=strRFID[i];
   12d86:	f9 01       	movw	r30, r18
   12d88:	ef 59       	subi	r30, 0x9F	; 159
   12d8a:	f2 4f       	sbci	r31, 0xF2	; 242
   12d8c:	d9 01       	movw	r26, r18
   12d8e:	a4 5d       	subi	r26, 0xD4	; 212
   12d90:	b1 4f       	sbci	r27, 0xF1	; 241
   12d92:	8c 91       	ld	r24, X
   12d94:	80 83       	st	Z, r24
   12d96:	2f 5f       	subi	r18, 0xFF	; 255
   12d98:	3f 4f       	sbci	r19, 0xFF	; 255

}

void ViewCardID(){//+12345678 -->12345678
     char i;
	 for(i=0;i<8;i++){         //00000000000012345678
   12d9a:	28 30       	cpi	r18, 0x08	; 8
   12d9c:	31 05       	cpc	r19, r1
   12d9e:	99 f7       	brne	.-26     	; 0x12d86 <FMenuChangeMOP+0x4a2>
		strCardID[i]=strRFID[i];
	 }strCardID[8]=0;     
   12da0:	10 92 69 0d 	sts	0x0D69, r1
			   stChangeMOP=cmProsesRFID;
			 }
	      break;
     case cmProsesRFID:
	      ViewCardID();
          sprintf_P(lcdteks,PSTR("ID:%s"),strCardID);lcd_print(2,1,lcdteks);
   12da4:	00 d0       	rcall	.+0      	; 0x12da6 <FMenuChangeMOP+0x4c2>
   12da6:	00 d0       	rcall	.+0      	; 0x12da8 <FMenuChangeMOP+0x4c4>
   12da8:	00 d0       	rcall	.+0      	; 0x12daa <FMenuChangeMOP+0x4c6>
   12daa:	ed b7       	in	r30, 0x3d	; 61
   12dac:	fe b7       	in	r31, 0x3e	; 62
   12dae:	31 96       	adiw	r30, 0x01	; 1
   12db0:	8e 01       	movw	r16, r28
   12db2:	00 5f       	subi	r16, 0xF0	; 240
   12db4:	1f 4f       	sbci	r17, 0xFF	; 255
   12db6:	ad b7       	in	r26, 0x3d	; 61
   12db8:	be b7       	in	r27, 0x3e	; 62
   12dba:	12 96       	adiw	r26, 0x02	; 2
   12dbc:	1c 93       	st	X, r17
   12dbe:	0e 93       	st	-X, r16
   12dc0:	11 97       	sbiw	r26, 0x01	; 1
   12dc2:	8b e8       	ldi	r24, 0x8B	; 139
   12dc4:	98 e1       	ldi	r25, 0x18	; 24
   12dc6:	93 83       	std	Z+3, r25	; 0x03
   12dc8:	82 83       	std	Z+2, r24	; 0x02
   12dca:	81 e6       	ldi	r24, 0x61	; 97
   12dcc:	9d e0       	ldi	r25, 0x0D	; 13
   12dce:	95 83       	std	Z+5, r25	; 0x05
   12dd0:	84 83       	std	Z+4, r24	; 0x04
   12dd2:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
   12dd6:	ed b7       	in	r30, 0x3d	; 61
   12dd8:	fe b7       	in	r31, 0x3e	; 62
   12dda:	36 96       	adiw	r30, 0x06	; 6
   12ddc:	0f b6       	in	r0, 0x3f	; 63
   12dde:	f8 94       	cli
   12de0:	fe bf       	out	0x3e, r31	; 62
   12de2:	0f be       	out	0x3f, r0	; 63
   12de4:	ed bf       	out	0x3d, r30	; 61
   12de6:	82 e0       	ldi	r24, 0x02	; 2
   12de8:	61 e0       	ldi	r22, 0x01	; 1
   12dea:	a8 01       	movw	r20, r16
   12dec:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
          lcd_printf(3,1,PSTR("Proses"));
   12df0:	83 e0       	ldi	r24, 0x03	; 3
   12df2:	61 e0       	ldi	r22, 0x01	; 1
   12df4:	44 e8       	ldi	r20, 0x84	; 132
   12df6:	58 e1       	ldi	r21, 0x18	; 24
   12df8:	0c c0       	rjmp	.+24     	; 0x12e12 <FMenuChangeMOP+0x52e>
		  stChangeMOP=cmGenerateData;
	      break;
     case cmProsesVoucher:
          lcd_clear();
   12dfa:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
          lcd_printf(1,1,PSTR("-MOP Voucher-")); 
   12dfe:	81 e0       	ldi	r24, 0x01	; 1
   12e00:	61 e0       	ldi	r22, 0x01	; 1
   12e02:	46 e7       	ldi	r20, 0x76	; 118
   12e04:	58 e1       	ldi	r21, 0x18	; 24
   12e06:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
          lcd_printf(3,1,PSTR("Proses"));
   12e0a:	83 e0       	ldi	r24, 0x03	; 3
   12e0c:	61 e0       	ldi	r22, 0x01	; 1
   12e0e:	4f e6       	ldi	r20, 0x6F	; 111
   12e10:	58 e1       	ldi	r21, 0x18	; 24
   12e12:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		  stChangeMOP=cmGenerateData;
   12e16:	86 e1       	ldi	r24, 0x16	; 22
   12e18:	5c cf       	rjmp	.-328    	; 0x12cd2 <FMenuChangeMOP+0x3ee>
	      break;
   12e1a:	e8 e6       	ldi	r30, 0x68	; 104
   12e1c:	fe e0       	ldi	r31, 0x0E	; 14
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
   12e1e:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   12e20:	8e e0       	ldi	r24, 0x0E	; 14
   12e22:	ed 37       	cpi	r30, 0x7D	; 125
   12e24:	f8 07       	cpc	r31, r24
   12e26:	d9 f7       	brne	.-10     	; 0x12e1e <FMenuChangeMOP+0x53a>
   12e28:	e6 e7       	ldi	r30, 0x76	; 118
   12e2a:	fd e0       	ldi	r31, 0x0D	; 13
	     strMemory[i]=data;
   12e2c:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   12e2e:	9d e0       	ldi	r25, 0x0D	; 13
   12e30:	eb 38       	cpi	r30, 0x8B	; 139
   12e32:	f9 07       	cpc	r31, r25
   12e34:	d9 f7       	brne	.-10     	; 0x12e2c <FMenuChangeMOP+0x548>
   12e36:	e2 e8       	ldi	r30, 0x82	; 130
   12e38:	fa e0       	ldi	r31, 0x0A	; 10
	     strMemory[i]=data;
   12e3a:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   12e3c:	aa e0       	ldi	r26, 0x0A	; 10
   12e3e:	e7 39       	cpi	r30, 0x97	; 151
   12e40:	fa 07       	cpc	r31, r26
   12e42:	d9 f7       	brne	.-10     	; 0x12e3a <FMenuChangeMOP+0x556>
   12e44:	25 e8       	ldi	r18, 0x85	; 133
   12e46:	e2 2e       	mov	r14, r18
   12e48:	25 e0       	ldi	r18, 0x05	; 5
   12e4a:	f2 2e       	mov	r15, r18
	     strMemory[i]=data;
   12e4c:	f7 01       	movw	r30, r14
   12e4e:	11 92       	st	Z+, r1
   12e50:	7f 01       	movw	r14, r30

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   12e52:	fa e9       	ldi	r31, 0x9A	; 154
   12e54:	ef 16       	cp	r14, r31
   12e56:	f5 e0       	ldi	r31, 0x05	; 5
   12e58:	ff 06       	cpc	r15, r31
   12e5a:	c1 f7       	brne	.-16     	; 0x12e4c <FMenuChangeMOP+0x568>
     case cmGenerateData:
	      FillChar(strRef1,sizeof(strRef1),0);
	      FillChar(strRef2,sizeof(strRef2),0);
	      FillChar(strRef3,sizeof(strRef3),0);
	      FillChar(strRef4,sizeof(strRef4),0);
          switch(MOPType){
   12e5c:	80 91 cf 01 	lds	r24, 0x01CF
   12e60:	82 30       	cpi	r24, 0x02	; 2
   12e62:	f1 f0       	breq	.+60     	; 0x12ea0 <FMenuChangeMOP+0x5bc>
   12e64:	83 30       	cpi	r24, 0x03	; 3
   12e66:	20 f4       	brcc	.+8      	; 0x12e70 <FMenuChangeMOP+0x58c>
   12e68:	81 30       	cpi	r24, 0x01	; 1
   12e6a:	09 f0       	breq	.+2      	; 0x12e6e <FMenuChangeMOP+0x58a>
   12e6c:	ad c0       	rjmp	.+346    	; 0x12fc8 <FMenuChangeMOP+0x6e4>
   12e6e:	07 c0       	rjmp	.+14     	; 0x12e7e <FMenuChangeMOP+0x59a>
   12e70:	83 30       	cpi	r24, 0x03	; 3
   12e72:	09 f4       	brne	.+2      	; 0x12e76 <FMenuChangeMOP+0x592>
   12e74:	64 c0       	rjmp	.+200    	; 0x12f3e <FMenuChangeMOP+0x65a>
   12e76:	84 30       	cpi	r24, 0x04	; 4
   12e78:	09 f0       	breq	.+2      	; 0x12e7c <FMenuChangeMOP+0x598>
   12e7a:	a6 c0       	rjmp	.+332    	; 0x12fc8 <FMenuChangeMOP+0x6e4>
   12e7c:	75 c0       	rjmp	.+234    	; 0x12f68 <FMenuChangeMOP+0x684>
		  case PAY_ACCOUNT:
		       sprintf_P(strRef1,PSTR("%s"),strCardID); 
   12e7e:	00 d0       	rcall	.+0      	; 0x12e80 <FMenuChangeMOP+0x59c>
   12e80:	00 d0       	rcall	.+0      	; 0x12e82 <FMenuChangeMOP+0x59e>
   12e82:	00 d0       	rcall	.+0      	; 0x12e84 <FMenuChangeMOP+0x5a0>
   12e84:	ed b7       	in	r30, 0x3d	; 61
   12e86:	fe b7       	in	r31, 0x3e	; 62
   12e88:	31 96       	adiw	r30, 0x01	; 1
   12e8a:	88 e6       	ldi	r24, 0x68	; 104
   12e8c:	9e e0       	ldi	r25, 0x0E	; 14
   12e8e:	ad b7       	in	r26, 0x3d	; 61
   12e90:	be b7       	in	r27, 0x3e	; 62
   12e92:	12 96       	adiw	r26, 0x02	; 2
   12e94:	9c 93       	st	X, r25
   12e96:	8e 93       	st	-X, r24
   12e98:	11 97       	sbiw	r26, 0x01	; 1
   12e9a:	8c e6       	ldi	r24, 0x6C	; 108
   12e9c:	98 e1       	ldi	r25, 0x18	; 24
   12e9e:	84 c0       	rjmp	.+264    	; 0x12fa8 <FMenuChangeMOP+0x6c4>
   12ea0:	8e 01       	movw	r16, r28
   12ea2:	0b 5f       	subi	r16, 0xFB	; 251
   12ea4:	1f 4f       	sbci	r17, 0xFF	; 255
   12ea6:	60 91 34 03 	lds	r22, 0x0334
   12eaa:	8b e0       	ldi	r24, 0x0B	; 11
   12eac:	68 9f       	mul	r22, r24
   12eae:	b0 01       	movw	r22, r0
   12eb0:	11 24       	eor	r1, r1
   12eb2:	67 5f       	subi	r22, 0xF7	; 247
   12eb4:	7e 4f       	sbci	r23, 0xFE	; 254
   12eb6:	c8 01       	movw	r24, r16
   12eb8:	4b e0       	ldi	r20, 0x0B	; 11
   12eba:	50 e0       	ldi	r21, 0x00	; 0
   12ebc:	26 ef       	ldi	r18, 0xF6	; 246
   12ebe:	32 e1       	ldi	r19, 0x12	; 18
   12ec0:	0e 94 7a b5 	call	0x16af4	; 0x16af4 <__eerd_block>
		       break;
		  case PAY_BANK:
		  	   eeprom_read_block((void*) &strBankName, (const void*) &DefBankName[BankIdx], 11);
		       sprintf_P(lcdteks,PSTR("%s"),strBankName);
   12ec4:	00 d0       	rcall	.+0      	; 0x12ec6 <FMenuChangeMOP+0x5e2>
   12ec6:	00 d0       	rcall	.+0      	; 0x12ec8 <FMenuChangeMOP+0x5e4>
   12ec8:	00 d0       	rcall	.+0      	; 0x12eca <FMenuChangeMOP+0x5e6>
   12eca:	ed b7       	in	r30, 0x3d	; 61
   12ecc:	fe b7       	in	r31, 0x3e	; 62
   12ece:	31 96       	adiw	r30, 0x01	; 1
   12ed0:	ce 01       	movw	r24, r28
   12ed2:	40 96       	adiw	r24, 0x10	; 16
   12ed4:	ad b7       	in	r26, 0x3d	; 61
   12ed6:	be b7       	in	r27, 0x3e	; 62
   12ed8:	12 96       	adiw	r26, 0x02	; 2
   12eda:	9c 93       	st	X, r25
   12edc:	8e 93       	st	-X, r24
   12ede:	11 97       	sbiw	r26, 0x01	; 1
   12ee0:	89 e6       	ldi	r24, 0x69	; 105
   12ee2:	98 e1       	ldi	r25, 0x18	; 24
   12ee4:	93 83       	std	Z+3, r25	; 0x03
   12ee6:	82 83       	std	Z+2, r24	; 0x02
   12ee8:	15 83       	std	Z+5, r17	; 0x05
   12eea:	04 83       	std	Z+4, r16	; 0x04
   12eec:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
		       sprintf_P(strRef1,PSTR("%s"),strBankName); 
   12ef0:	ed b7       	in	r30, 0x3d	; 61
   12ef2:	fe b7       	in	r31, 0x3e	; 62
   12ef4:	31 96       	adiw	r30, 0x01	; 1
   12ef6:	88 e6       	ldi	r24, 0x68	; 104
   12ef8:	9e e0       	ldi	r25, 0x0E	; 14
   12efa:	ad b7       	in	r26, 0x3d	; 61
   12efc:	be b7       	in	r27, 0x3e	; 62
   12efe:	12 96       	adiw	r26, 0x02	; 2
   12f00:	9c 93       	st	X, r25
   12f02:	8e 93       	st	-X, r24
   12f04:	11 97       	sbiw	r26, 0x01	; 1
   12f06:	86 e6       	ldi	r24, 0x66	; 102
   12f08:	98 e1       	ldi	r25, 0x18	; 24
   12f0a:	93 83       	std	Z+3, r25	; 0x03
   12f0c:	82 83       	std	Z+2, r24	; 0x02
   12f0e:	15 83       	std	Z+5, r17	; 0x05
   12f10:	04 83       	std	Z+4, r16	; 0x04
   12f12:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
		       sprintf_P(strRef4,PSTR("%s"),strSurcharge); 
   12f16:	ed b7       	in	r30, 0x3d	; 61
   12f18:	fe b7       	in	r31, 0x3e	; 62
   12f1a:	31 96       	adiw	r30, 0x01	; 1
   12f1c:	8b ee       	ldi	r24, 0xEB	; 235
   12f1e:	9f ef       	ldi	r25, 0xFF	; 255
   12f20:	e8 0e       	add	r14, r24
   12f22:	f9 1e       	adc	r15, r25
   12f24:	ad b7       	in	r26, 0x3d	; 61
   12f26:	be b7       	in	r27, 0x3e	; 62
   12f28:	12 96       	adiw	r26, 0x02	; 2
   12f2a:	fc 92       	st	X, r15
   12f2c:	ee 92       	st	-X, r14
   12f2e:	11 97       	sbiw	r26, 0x01	; 1
   12f30:	83 e6       	ldi	r24, 0x63	; 99
   12f32:	98 e1       	ldi	r25, 0x18	; 24
   12f34:	93 83       	std	Z+3, r25	; 0x03
   12f36:	82 83       	std	Z+2, r24	; 0x02
   12f38:	ce 01       	movw	r24, r28
   12f3a:	01 96       	adiw	r24, 0x01	; 1
   12f3c:	39 c0       	rjmp	.+114    	; 0x12fb0 <FMenuChangeMOP+0x6cc>
		       break;
		  case PAY_VOUCHER://Load data Ref1=Voucher on cmVoucherInput
		  	   sprintf_P(strRef1,PSTR("%s"),strVoucherNum); 
   12f3e:	00 d0       	rcall	.+0      	; 0x12f40 <FMenuChangeMOP+0x65c>
   12f40:	00 d0       	rcall	.+0      	; 0x12f42 <FMenuChangeMOP+0x65e>
   12f42:	00 d0       	rcall	.+0      	; 0x12f44 <FMenuChangeMOP+0x660>
   12f44:	ed b7       	in	r30, 0x3d	; 61
   12f46:	fe b7       	in	r31, 0x3e	; 62
   12f48:	31 96       	adiw	r30, 0x01	; 1
   12f4a:	88 e6       	ldi	r24, 0x68	; 104
   12f4c:	9e e0       	ldi	r25, 0x0E	; 14
   12f4e:	ad b7       	in	r26, 0x3d	; 61
   12f50:	be b7       	in	r27, 0x3e	; 62
   12f52:	12 96       	adiw	r26, 0x02	; 2
   12f54:	9c 93       	st	X, r25
   12f56:	8e 93       	st	-X, r24
   12f58:	11 97       	sbiw	r26, 0x01	; 1
   12f5a:	80 e6       	ldi	r24, 0x60	; 96
   12f5c:	98 e1       	ldi	r25, 0x18	; 24
   12f5e:	93 83       	std	Z+3, r25	; 0x03
   12f60:	82 83       	std	Z+2, r24	; 0x02
   12f62:	87 e1       	ldi	r24, 0x17	; 23
   12f64:	9e e0       	ldi	r25, 0x0E	; 14
   12f66:	24 c0       	rjmp	.+72     	; 0x12fb0 <FMenuChangeMOP+0x6cc>
		       break;
		  case PAY_PUMPTEST:
		  	   sprintf_P(strRef1,PSTR("PUMP TEST")); 
   12f68:	00 d0       	rcall	.+0      	; 0x12f6a <FMenuChangeMOP+0x686>
   12f6a:	00 d0       	rcall	.+0      	; 0x12f6c <FMenuChangeMOP+0x688>
   12f6c:	88 e6       	ldi	r24, 0x68	; 104
   12f6e:	9e e0       	ldi	r25, 0x0E	; 14
   12f70:	ad b7       	in	r26, 0x3d	; 61
   12f72:	be b7       	in	r27, 0x3e	; 62
   12f74:	12 96       	adiw	r26, 0x02	; 2
   12f76:	9c 93       	st	X, r25
   12f78:	8e 93       	st	-X, r24
   12f7a:	11 97       	sbiw	r26, 0x01	; 1
   12f7c:	86 e5       	ldi	r24, 0x56	; 86
   12f7e:	98 e1       	ldi	r25, 0x18	; 24
   12f80:	14 96       	adiw	r26, 0x04	; 4
   12f82:	9c 93       	st	X, r25
   12f84:	8e 93       	st	-X, r24
   12f86:	13 97       	sbiw	r26, 0x03	; 3
   12f88:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
		  	   sprintf_P(strRef2,PSTR("%s"),strCardID); 	       
   12f8c:	00 d0       	rcall	.+0      	; 0x12f8e <FMenuChangeMOP+0x6aa>
   12f8e:	ed b7       	in	r30, 0x3d	; 61
   12f90:	fe b7       	in	r31, 0x3e	; 62
   12f92:	31 96       	adiw	r30, 0x01	; 1
   12f94:	86 e7       	ldi	r24, 0x76	; 118
   12f96:	9d e0       	ldi	r25, 0x0D	; 13
   12f98:	ad b7       	in	r26, 0x3d	; 61
   12f9a:	be b7       	in	r27, 0x3e	; 62
   12f9c:	12 96       	adiw	r26, 0x02	; 2
   12f9e:	9c 93       	st	X, r25
   12fa0:	8e 93       	st	-X, r24
   12fa2:	11 97       	sbiw	r26, 0x01	; 1
   12fa4:	83 e5       	ldi	r24, 0x53	; 83
   12fa6:	98 e1       	ldi	r25, 0x18	; 24
   12fa8:	93 83       	std	Z+3, r25	; 0x03
   12faa:	82 83       	std	Z+2, r24	; 0x02
   12fac:	81 e6       	ldi	r24, 0x61	; 97
   12fae:	9d e0       	ldi	r25, 0x0D	; 13
   12fb0:	95 83       	std	Z+5, r25	; 0x05
   12fb2:	84 83       	std	Z+4, r24	; 0x04
   12fb4:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
   12fb8:	ed b7       	in	r30, 0x3d	; 61
   12fba:	fe b7       	in	r31, 0x3e	; 62
   12fbc:	36 96       	adiw	r30, 0x06	; 6
   12fbe:	0f b6       	in	r0, 0x3f	; 63
   12fc0:	f8 94       	cli
   12fc2:	fe bf       	out	0x3e, r31	; 62
   12fc4:	0f be       	out	0x3f, r0	; 63
   12fc6:	ed bf       	out	0x3d, r30	; 61
		}
     else {
	    sprintf_P(StrResult,PSTR("%d"),Val);
	 }
	 */
     sprintf_P(StrResult,PSTR("%.2d"),Val);
   12fc8:	00 d0       	rcall	.+0      	; 0x12fca <FMenuChangeMOP+0x6e6>
   12fca:	00 d0       	rcall	.+0      	; 0x12fcc <FMenuChangeMOP+0x6e8>
   12fcc:	00 d0       	rcall	.+0      	; 0x12fce <FMenuChangeMOP+0x6ea>
   12fce:	ed b7       	in	r30, 0x3d	; 61
   12fd0:	fe b7       	in	r31, 0x3e	; 62
   12fd2:	31 96       	adiw	r30, 0x01	; 1
   12fd4:	83 e3       	ldi	r24, 0x33	; 51
   12fd6:	99 e0       	ldi	r25, 0x09	; 9
   12fd8:	ad b7       	in	r26, 0x3d	; 61
   12fda:	be b7       	in	r27, 0x3e	; 62
   12fdc:	12 96       	adiw	r26, 0x02	; 2
   12fde:	9c 93       	st	X, r25
   12fe0:	8e 93       	st	-X, r24
   12fe2:	11 97       	sbiw	r26, 0x01	; 1
   12fe4:	8d e5       	ldi	r24, 0x5D	; 93
   12fe6:	9d e0       	ldi	r25, 0x0D	; 13
   12fe8:	93 83       	std	Z+3, r25	; 0x03
   12fea:	82 83       	std	Z+2, r24	; 0x02
   12fec:	80 91 cf 01 	lds	r24, 0x01CF
   12ff0:	84 83       	std	Z+4, r24	; 0x04
   12ff2:	15 82       	std	Z+5, r1	; 0x05
   12ff4:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
		  	   sprintf_P(strRef1,PSTR("PUMP TEST")); 
		  	   sprintf_P(strRef2,PSTR("%s"),strCardID); 	       
		       break;
		  }
		  leadingZero(MOPType,strPaymentType);
		  AddSpaceLead(strRef1,20);
   12ff8:	ed b7       	in	r30, 0x3d	; 61
   12ffa:	fe b7       	in	r31, 0x3e	; 62
   12ffc:	36 96       	adiw	r30, 0x06	; 6
   12ffe:	0f b6       	in	r0, 0x3f	; 63
   13000:	f8 94       	cli
   13002:	fe bf       	out	0x3e, r31	; 62
   13004:	0f be       	out	0x3f, r0	; 63
   13006:	ed bf       	out	0x3d, r30	; 61
   13008:	88 e6       	ldi	r24, 0x68	; 104
   1300a:	9e e0       	ldi	r25, 0x0E	; 14
   1300c:	64 e1       	ldi	r22, 0x14	; 20
   1300e:	0e 94 d9 2d 	call	0x5bb2	; 0x5bb2 <AddSpaceLead>
		  AddSpaceLead(strRef2,20);
   13012:	86 e7       	ldi	r24, 0x76	; 118
   13014:	9d e0       	ldi	r25, 0x0D	; 13
   13016:	64 e1       	ldi	r22, 0x14	; 20
   13018:	0e 94 d9 2d 	call	0x5bb2	; 0x5bb2 <AddSpaceLead>
		  AddSpaceLead(strRef3,20);
   1301c:	82 e8       	ldi	r24, 0x82	; 130
   1301e:	9a e0       	ldi	r25, 0x0A	; 10
   13020:	64 e1       	ldi	r22, 0x14	; 20
   13022:	0e 94 d9 2d 	call	0x5bb2	; 0x5bb2 <AddSpaceLead>
		  AddSpaceLead(strRef4,20);
   13026:	85 e8       	ldi	r24, 0x85	; 133
   13028:	95 e0       	ldi	r25, 0x05	; 5
   1302a:	64 e1       	ldi	r22, 0x14	; 20
   1302c:	0e 94 d9 2d 	call	0x5bb2	; 0x5bb2 <AddSpaceLead>
		  iWait=0;
   13030:	10 92 44 03 	sts	0x0344, r1
		  IsMessage09=False;
   13034:	10 92 ba 01 	sts	0x01BA, r1
		  stChangeMOP=cmSendMessage32;	      
   13038:	87 e1       	ldi	r24, 0x17	; 23
   1303a:	4b ce       	rjmp	.-874    	; 0x12cd2 <FMenuChangeMOP+0x3ee>
	      break;
     case cmSendMessage32://SendMessage32
	      sendMessage32();
   1303c:	0e 94 65 51 	call	0xa2ca	; 0xa2ca <sendMessage32>
		  iLoop=0;
   13040:	10 92 36 03 	sts	0x0336, r1
   13044:	10 92 35 03 	sts	0x0335, r1
		  iPos=0;
   13048:	10 92 45 03 	sts	0x0345, r1
		  lcd_printf(3,1,PSTR("Please Wait"));
   1304c:	83 e0       	ldi	r24, 0x03	; 3
   1304e:	61 e0       	ldi	r22, 0x01	; 1
   13050:	47 e4       	ldi	r20, 0x47	; 71
   13052:	58 e1       	ldi	r21, 0x18	; 24
   13054:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		  stChangeMOP=cmWaitReplyMessage;	      
   13058:	88 e1       	ldi	r24, 0x18	; 24
   1305a:	3b ce       	rjmp	.-906    	; 0x12cd2 <FMenuChangeMOP+0x3ee>
	      break;
     case cmWaitReplyMessage:
          iLoop++;
   1305c:	80 91 35 03 	lds	r24, 0x0335
   13060:	90 91 36 03 	lds	r25, 0x0336
   13064:	01 96       	adiw	r24, 0x01	; 1
   13066:	90 93 36 03 	sts	0x0336, r25
   1306a:	80 93 35 03 	sts	0x0335, r24
		  if ((iLoop%MSG_WAIT_TIMOUT)==0){
   1306e:	68 e9       	ldi	r22, 0x98	; 152
   13070:	7a e3       	ldi	r23, 0x3A	; 58
   13072:	0e 94 93 b8 	call	0x17126	; 0x17126 <__udivmodhi4>
   13076:	89 2b       	or	r24, r25
   13078:	19 f5       	brne	.+70     	; 0x130c0 <FMenuChangeMOP+0x7dc>
			 if (iPos<5){
   1307a:	60 91 45 03 	lds	r22, 0x0345
   1307e:	65 30       	cpi	r22, 0x05	; 5
   13080:	68 f4       	brcc	.+26     	; 0x1309c <FMenuChangeMOP+0x7b8>
				 lcd_xy(3,(13+iPos));_lcd('.');
   13082:	63 5f       	subi	r22, 0xF3	; 243
   13084:	83 e0       	ldi	r24, 0x03	; 3
   13086:	0e 94 4c ae 	call	0x15c98	; 0x15c98 <lcd_xy>
   1308a:	8e e2       	ldi	r24, 0x2E	; 46
   1308c:	0e 94 26 ae 	call	0x15c4c	; 0x15c4c <_lcd>
				 iPos++;
   13090:	80 91 45 03 	lds	r24, 0x0345
   13094:	8f 5f       	subi	r24, 0xFF	; 255
   13096:	80 93 45 03 	sts	0x0345, r24
   1309a:	12 c0       	rjmp	.+36     	; 0x130c0 <FMenuChangeMOP+0x7dc>
				}
			 else{
				 iPos=0;
   1309c:	10 92 45 03 	sts	0x0345, r1
				 lcd_printf(3,(13+iPos),PSTR("       "));
   130a0:	83 e0       	ldi	r24, 0x03	; 3
   130a2:	6d e0       	ldi	r22, 0x0D	; 13
   130a4:	4f e3       	ldi	r20, 0x3F	; 63
   130a6:	58 e1       	ldi	r21, 0x18	; 24
   130a8:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
				 //Resend Message32
				 if (iWait<5)stChangeMOP=cmSendMessage32;
   130ac:	90 91 44 03 	lds	r25, 0x0344
   130b0:	95 30       	cpi	r25, 0x05	; 5
   130b2:	18 f4       	brcc	.+6      	; 0x130ba <FMenuChangeMOP+0x7d6>
   130b4:	87 e1       	ldi	r24, 0x17	; 23
   130b6:	80 93 47 03 	sts	0x0347, r24
				iWait++;
   130ba:	9f 5f       	subi	r25, 0xFF	; 255
   130bc:	90 93 44 03 	sts	0x0344, r25
				}
		  }
		  if (iWait>5)stChangeMOP=cmNoReply;
   130c0:	80 91 44 03 	lds	r24, 0x0344
   130c4:	86 30       	cpi	r24, 0x06	; 6
   130c6:	18 f0       	brcs	.+6      	; 0x130ce <FMenuChangeMOP+0x7ea>
   130c8:	8a e1       	ldi	r24, 0x1A	; 26
   130ca:	80 93 47 03 	sts	0x0347, r24
		  if (IsMessage09==True)stChangeMOP=cmDisplayFreeMessage;
   130ce:	80 91 ba 01 	lds	r24, 0x01BA
   130d2:	81 30       	cpi	r24, 0x01	; 1
   130d4:	19 f4       	brne	.+6      	; 0x130dc <FMenuChangeMOP+0x7f8>
   130d6:	89 e1       	ldi	r24, 0x19	; 25
   130d8:	80 93 47 03 	sts	0x0347, r24
		  if (IsMessage99==True)stChangeMOP=cmFinishChangeMOP;
   130dc:	80 91 b6 01 	lds	r24, 0x01B6
   130e0:	81 30       	cpi	r24, 0x01	; 1
   130e2:	f1 f5       	brne	.+124    	; 0x13160 <FMenuChangeMOP+0x87c>
   130e4:	37 c0       	rjmp	.+110    	; 0x13154 <FMenuChangeMOP+0x870>
		  break;
     case cmDisplayFreeMessage:
	      IsMessage09=False;
   130e6:	10 92 ba 01 	sts	0x01BA, r1
	      msgResult=procMessage09();
   130ea:	0e 94 59 17 	call	0x2eb2	; 0x2eb2 <procMessage09>
		  lcd_clear();
   130ee:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
		  lcd_print(1,1,strFreeMessageLine1);
   130f2:	81 e0       	ldi	r24, 0x01	; 1
   130f4:	61 e0       	ldi	r22, 0x01	; 1
   130f6:	47 e9       	ldi	r20, 0x97	; 151
   130f8:	5a e0       	ldi	r21, 0x0A	; 10
   130fa:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
		  lcd_print(2,1,strFreeMessageLine2);
   130fe:	82 e0       	ldi	r24, 0x02	; 2
   13100:	61 e0       	ldi	r22, 0x01	; 1
   13102:	46 e8       	ldi	r20, 0x86	; 134
   13104:	59 e0       	ldi	r21, 0x09	; 9
   13106:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
		  lcd_print(3,1,strFreeMessageLine3);
   1310a:	83 e0       	ldi	r24, 0x03	; 3
   1310c:	61 e0       	ldi	r22, 0x01	; 1
   1310e:	41 e2       	ldi	r20, 0x21	; 33
   13110:	5a e0       	ldi	r21, 0x0A	; 10
   13112:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
		  lcd_print(4,1,strFreeMessageLine4);
   13116:	84 e0       	ldi	r24, 0x04	; 4
   13118:	61 e0       	ldi	r22, 0x01	; 1
   1311a:	41 eb       	ldi	r20, 0xB1	; 177
   1311c:	5d e0       	ldi	r21, 0x0D	; 13
   1311e:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
   13122:	0e c0       	rjmp	.+28     	; 0x13140 <FMenuChangeMOP+0x85c>
		  TimDisplay=0;
          stChangeMOP=cmDelayMOP;
	      break;
     case cmNoReply:
	      lcd_clear();
   13124:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
		  lcd_printf(2,1,PSTR("No Reply    "));
   13128:	82 e0       	ldi	r24, 0x02	; 2
   1312a:	61 e0       	ldi	r22, 0x01	; 1
   1312c:	42 e3       	ldi	r20, 0x32	; 50
   1312e:	58 e1       	ldi	r21, 0x18	; 24
   13130:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
	      lcd_printf(3,1,PSTR("TCP/IP Error"));
   13134:	83 e0       	ldi	r24, 0x03	; 3
   13136:	61 e0       	ldi	r22, 0x01	; 1
   13138:	45 e2       	ldi	r20, 0x25	; 37
   1313a:	58 e1       	ldi	r21, 0x18	; 24
   1313c:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		  TimDisplay=0;
   13140:	10 92 a7 01 	sts	0x01A7, r1
          stChangeMOP=cmDelayMOP;
   13144:	8b e1       	ldi	r24, 0x1B	; 27
   13146:	c5 cd       	rjmp	.-1142   	; 0x12cd2 <FMenuChangeMOP+0x3ee>
	      break;
     case cmDelayMOP:
	      if (TimDisplay>9)stChangeMOP=cmExitChangeMOP;
   13148:	80 91 a7 01 	lds	r24, 0x01A7
   1314c:	8a 30       	cpi	r24, 0x0A	; 10
   1314e:	40 f0       	brcs	.+16     	; 0x13160 <FMenuChangeMOP+0x87c>
   13150:	8c e1       	ldi	r24, 0x1C	; 28
   13152:	bf cd       	rjmp	.-1154   	; 0x12cd2 <FMenuChangeMOP+0x3ee>
	      break;
     case cmExitChangeMOP:
	      stChangeMOP=cmFinishChangeMOP;
   13154:	8d e1       	ldi	r24, 0x1D	; 29
   13156:	bd cd       	rjmp	.-1158   	; 0x12cd2 <FMenuChangeMOP+0x3ee>
	      break;
     case cmFinishChangeMOP:
	      stChangeMOP=cmInit;
   13158:	10 92 47 03 	sts	0x0347, r1
   1315c:	81 e0       	ldi	r24, 0x01	; 1
   1315e:	01 c0       	rjmp	.+2      	; 0x13162 <FMenuChangeMOP+0x87e>
   13160:	80 e0       	ldi	r24, 0x00	; 0
		  Result=MENU_DONE;
	      break;
	 }
  return Result;
}
   13162:	a3 96       	adiw	r28, 0x23	; 35
   13164:	0f b6       	in	r0, 0x3f	; 63
   13166:	f8 94       	cli
   13168:	de bf       	out	0x3e, r29	; 62
   1316a:	0f be       	out	0x3f, r0	; 63
   1316c:	cd bf       	out	0x3d, r28	; 61
   1316e:	cf 91       	pop	r28
   13170:	df 91       	pop	r29
   13172:	1f 91       	pop	r17
   13174:	0f 91       	pop	r16
   13176:	ff 90       	pop	r15
   13178:	ef 90       	pop	r14
   1317a:	df 90       	pop	r13
   1317c:	cf 90       	pop	r12
   1317e:	bf 90       	pop	r11
   13180:	af 90       	pop	r10
   13182:	08 95       	ret

00013184 <SetBaudRate>:
	 //Spooling HFCx 0000
	 cmdPrint=0b00010000|(1<<PRN_PAPER_CUT);
	 IsFreePrinting=True;
}

void SetBaudRate(char ComAddr,char brMap){//Com1..Com4
   13184:	28 2f       	mov	r18, r24
   13186:	96 2f       	mov	r25, r22
unsigned int brValue=9600;
char brMessage=0;

     if ((ComAddr>=1)&&(ComAddr<=2)){
   13188:	81 50       	subi	r24, 0x01	; 1
   1318a:	82 30       	cpi	r24, 0x02	; 2
   1318c:	b8 f4       	brcc	.+46     	; 0x131bc <SetBaudRate+0x38>
	 }
}

int GetBaudrate(char brSetting){
int Result=0;
     switch(brSetting){
   1318e:	62 30       	cpi	r22, 0x02	; 2
   13190:	59 f0       	breq	.+22     	; 0x131a8 <SetBaudRate+0x24>
   13192:	62 30       	cpi	r22, 0x02	; 2
   13194:	18 f0       	brcs	.+6      	; 0x1319c <SetBaudRate+0x18>
   13196:	63 30       	cpi	r22, 0x03	; 3
   13198:	21 f4       	brne	.+8      	; 0x131a2 <SetBaudRate+0x1e>
   1319a:	09 c0       	rjmp	.+18     	; 0x131ae <SetBaudRate+0x2a>
   1319c:	40 e8       	ldi	r20, 0x80	; 128
   1319e:	55 e2       	ldi	r21, 0x25	; 37
   131a0:	08 c0       	rjmp	.+16     	; 0x131b2 <SetBaudRate+0x2e>
   131a2:	40 e0       	ldi	r20, 0x00	; 0
   131a4:	50 e0       	ldi	r21, 0x00	; 0
   131a6:	05 c0       	rjmp	.+10     	; 0x131b2 <SetBaudRate+0x2e>
   131a8:	40 e0       	ldi	r20, 0x00	; 0
   131aa:	5b e4       	ldi	r21, 0x4B	; 75
   131ac:	02 c0       	rjmp	.+4      	; 0x131b2 <SetBaudRate+0x2e>
   131ae:	4b e9       	ldi	r20, 0x9B	; 155
   131b0:	56 e1       	ldi	r21, 0x16	; 22
unsigned int brValue=9600;
char brMessage=0;

     if ((ComAddr>=1)&&(ComAddr<=2)){
	     brValue=GetBaudrate(brMap);
	      _uart_init((ComAddr-1),brValue);
   131b2:	60 e0       	ldi	r22, 0x00	; 0
   131b4:	70 e0       	ldi	r23, 0x00	; 0
   131b6:	0e 94 c2 b3 	call	0x16784	; 0x16784 <_uart_init>
   131ba:	08 95       	ret
	 }else
     if ((ComAddr>=3)&&(ComAddr<=4)){
   131bc:	82 2f       	mov	r24, r18
   131be:	83 50       	subi	r24, 0x03	; 3
   131c0:	82 30       	cpi	r24, 0x02	; 2
   131c2:	a8 f4       	brcc	.+42     	; 0x131ee <SetBaudRate+0x6a>
	     //[COM][Baud]
		 brMessage=((ComAddr<<4)|(0x0F&brMap));
   131c4:	9f 70       	andi	r25, 0x0F	; 15
   131c6:	62 2f       	mov	r22, r18
   131c8:	62 95       	swap	r22
   131ca:	60 7f       	andi	r22, 0xF0	; 240
   131cc:	69 2b       	or	r22, r25
		 if (iSequencePooling>0)SendPoolingCommand(SC_BAUDRATE,brMessage);
   131ce:	80 91 93 01 	lds	r24, 0x0193
   131d2:	88 23       	and	r24, r24
   131d4:	49 f0       	breq	.+18     	; 0x131e8 <SetBaudRate+0x64>
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
   131d6:	86 e0       	ldi	r24, 0x06	; 6
   131d8:	80 93 8a 07 	sts	0x078A, r24
	 PoolMsg=plMsg;
   131dc:	60 93 ae 0d 	sts	0x0DAE, r22
     IsControlPooling=True;
   131e0:	81 e0       	ldi	r24, 0x01	; 1
   131e2:	80 93 97 01 	sts	0x0197, r24
   131e6:	08 95       	ret
	 }else
     if ((ComAddr>=3)&&(ComAddr<=4)){
	     //[COM][Baud]
		 brMessage=((ComAddr<<4)|(0x0F&brMap));
		 if (iSequencePooling>0)SendPoolingCommand(SC_BAUDRATE,brMessage);
		 else SendSlaveCommand(SC_BAUDRATE,brMessage);
   131e8:	86 e0       	ldi	r24, 0x06	; 6
   131ea:	0e 94 de 73 	call	0xe7bc	; 0xe7bc <SendSlaveCommand>
   131ee:	08 95       	ret

000131f0 <FSettingSystem>:
	      break;
	 }
     return Result;
}

char FSettingSystem(){
   131f0:	af 92       	push	r10
   131f2:	bf 92       	push	r11
   131f4:	cf 92       	push	r12
   131f6:	df 92       	push	r13
   131f8:	ef 92       	push	r14
   131fa:	ff 92       	push	r15
   131fc:	0f 93       	push	r16
   131fe:	1f 93       	push	r17
   13200:	df 93       	push	r29
   13202:	cf 93       	push	r28
   13204:	cd b7       	in	r28, 0x3d	; 61
   13206:	de b7       	in	r29, 0x3e	; 62
   13208:	64 97       	sbiw	r28, 0x14	; 20
   1320a:	0f b6       	in	r0, 0x3f	; 63
   1320c:	f8 94       	cli
   1320e:	de bf       	out	0x3e, r29	; 62
   13210:	0f be       	out	0x3f, r0	; 63
   13212:	cd bf       	out	0x3d, r28	; 61
       char SubMenu,Result=MENU_NONE;
	   char HGMode;
       char lcdteks[20];
	   int bValue;

     switch(stSettingSytem){
   13214:	80 91 e0 02 	lds	r24, 0x02E0
   13218:	82 30       	cpi	r24, 0x02	; 2
   1321a:	09 f4       	brne	.+2      	; 0x1321e <FSettingSystem+0x2e>
   1321c:	cf c0       	rjmp	.+414    	; 0x133bc <FSettingSystem+0x1cc>
   1321e:	83 30       	cpi	r24, 0x03	; 3
   13220:	30 f4       	brcc	.+12     	; 0x1322e <FSettingSystem+0x3e>
   13222:	88 23       	and	r24, r24
   13224:	71 f0       	breq	.+28     	; 0x13242 <FSettingSystem+0x52>
   13226:	81 30       	cpi	r24, 0x01	; 1
   13228:	09 f0       	breq	.+2      	; 0x1322c <FSettingSystem+0x3c>
   1322a:	6f c1       	rjmp	.+734    	; 0x1350a <FSettingSystem+0x31a>
   1322c:	7f c0       	rjmp	.+254    	; 0x1332c <FSettingSystem+0x13c>
   1322e:	84 30       	cpi	r24, 0x04	; 4
   13230:	09 f4       	brne	.+2      	; 0x13234 <FSettingSystem+0x44>
   13232:	60 c1       	rjmp	.+704    	; 0x134f4 <FSettingSystem+0x304>
   13234:	84 30       	cpi	r24, 0x04	; 4
   13236:	08 f4       	brcc	.+2      	; 0x1323a <FSettingSystem+0x4a>
   13238:	2b c1       	rjmp	.+598    	; 0x13490 <FSettingSystem+0x2a0>
   1323a:	85 30       	cpi	r24, 0x05	; 5
   1323c:	09 f0       	breq	.+2      	; 0x13240 <FSettingSystem+0x50>
   1323e:	65 c1       	rjmp	.+714    	; 0x1350a <FSettingSystem+0x31a>
   13240:	60 c1       	rjmp	.+704    	; 0x13502 <FSettingSystem+0x312>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   13242:	e1 99       	sbic	0x1c, 1	; 28
   13244:	fe cf       	rjmp	.-4      	; 0x13242 <FSettingSystem+0x52>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   13246:	86 e3       	ldi	r24, 0x36	; 54
   13248:	91 e0       	ldi	r25, 0x01	; 1
   1324a:	9f bb       	out	0x1f, r25	; 31
   1324c:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   1324e:	e0 9a       	sbi	0x1c, 0	; 28
   13250:	2d b3       	in	r18, 0x1d	; 29
	 case ssInitSettingSystem:
	      IFType=eeprom_read_byte(&DefInitIFT);
   13252:	20 93 10 01 	sts	0x0110, r18
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   13256:	e1 99       	sbic	0x1c, 1	; 28
   13258:	fe cf       	rjmp	.-4      	; 0x13256 <FSettingSystem+0x66>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   1325a:	82 ec       	ldi	r24, 0xC2	; 194
   1325c:	93 e0       	ldi	r25, 0x03	; 3
   1325e:	9f bb       	out	0x1f, r25	; 31
   13260:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   13262:	e0 9a       	sbi	0x1c, 0	; 28
   13264:	1d b3       	in	r17, 0x1d	; 29
		  HGMode=eeprom_read_byte(&DefHGMode);

	      if (IFType==IT_NONE)sprintf_P(lcdteks,PSTR("1.Mode:None"));
   13266:	22 23       	and	r18, r18
   13268:	69 f4       	brne	.+26     	; 0x13284 <FSettingSystem+0x94>
   1326a:	00 d0       	rcall	.+0      	; 0x1326c <FSettingSystem+0x7c>
   1326c:	00 d0       	rcall	.+0      	; 0x1326e <FSettingSystem+0x7e>
   1326e:	ce 01       	movw	r24, r28
   13270:	01 96       	adiw	r24, 0x01	; 1
   13272:	ad b7       	in	r26, 0x3d	; 61
   13274:	be b7       	in	r27, 0x3e	; 62
   13276:	12 96       	adiw	r26, 0x02	; 2
   13278:	9c 93       	st	X, r25
   1327a:	8e 93       	st	-X, r24
   1327c:	11 97       	sbiw	r26, 0x01	; 1
   1327e:	84 e3       	ldi	r24, 0x34	; 52
   13280:	9e e0       	ldi	r25, 0x0E	; 14
   13282:	1d c0       	rjmp	.+58     	; 0x132be <FSettingSystem+0xce>
		  else
	      if (IFType==IT_SLAVE)sprintf_P(lcdteks,PSTR("1.Mode:Slave"));
   13284:	21 30       	cpi	r18, 0x01	; 1
   13286:	69 f4       	brne	.+26     	; 0x132a2 <FSettingSystem+0xb2>
   13288:	00 d0       	rcall	.+0      	; 0x1328a <FSettingSystem+0x9a>
   1328a:	00 d0       	rcall	.+0      	; 0x1328c <FSettingSystem+0x9c>
   1328c:	ce 01       	movw	r24, r28
   1328e:	01 96       	adiw	r24, 0x01	; 1
   13290:	ed b7       	in	r30, 0x3d	; 61
   13292:	fe b7       	in	r31, 0x3e	; 62
   13294:	92 83       	std	Z+2, r25	; 0x02
   13296:	81 83       	std	Z+1, r24	; 0x01
   13298:	87 e2       	ldi	r24, 0x27	; 39
   1329a:	9e e0       	ldi	r25, 0x0E	; 14
   1329c:	94 83       	std	Z+4, r25	; 0x04
   1329e:	83 83       	std	Z+3, r24	; 0x03
   132a0:	12 c0       	rjmp	.+36     	; 0x132c6 <FSettingSystem+0xd6>
		  else
	      if (IFType==IT_STANDALONE)sprintf_P(lcdteks,PSTR("1.Mode:Standalone"));
   132a2:	22 30       	cpi	r18, 0x02	; 2
   132a4:	b1 f4       	brne	.+44     	; 0x132d2 <FSettingSystem+0xe2>
   132a6:	00 d0       	rcall	.+0      	; 0x132a8 <FSettingSystem+0xb8>
   132a8:	00 d0       	rcall	.+0      	; 0x132aa <FSettingSystem+0xba>
   132aa:	ce 01       	movw	r24, r28
   132ac:	01 96       	adiw	r24, 0x01	; 1
   132ae:	ad b7       	in	r26, 0x3d	; 61
   132b0:	be b7       	in	r27, 0x3e	; 62
   132b2:	12 96       	adiw	r26, 0x02	; 2
   132b4:	9c 93       	st	X, r25
   132b6:	8e 93       	st	-X, r24
   132b8:	11 97       	sbiw	r26, 0x01	; 1
   132ba:	85 e1       	ldi	r24, 0x15	; 21
   132bc:	9e e0       	ldi	r25, 0x0E	; 14
   132be:	14 96       	adiw	r26, 0x04	; 4
   132c0:	9c 93       	st	X, r25
   132c2:	8e 93       	st	-X, r24
   132c4:	13 97       	sbiw	r26, 0x03	; 3
   132c6:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
   132ca:	0f 90       	pop	r0
   132cc:	0f 90       	pop	r0
   132ce:	0f 90       	pop	r0
   132d0:	0f 90       	pop	r0

	      lcd_clear();
   132d2:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
		  lcd_print(1,1,lcdteks);
   132d6:	81 e0       	ldi	r24, 0x01	; 1
   132d8:	61 e0       	ldi	r22, 0x01	; 1
   132da:	ae 01       	movw	r20, r28
   132dc:	4f 5f       	subi	r20, 0xFF	; 255
   132de:	5f 4f       	sbci	r21, 0xFF	; 255
   132e0:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
		  lcd_printf(2,1,PSTR("2.Baudrate"));
   132e4:	82 e0       	ldi	r24, 0x02	; 2
   132e6:	61 e0       	ldi	r22, 0x01	; 1
   132e8:	4a e0       	ldi	r20, 0x0A	; 10
   132ea:	5e e0       	ldi	r21, 0x0E	; 14
   132ec:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>

		  if (HGMode==HM_TTL)lcd_printf(3,1,PSTR("3.COM3:TTL"));
   132f0:	11 23       	and	r17, r17
   132f2:	29 f4       	brne	.+10     	; 0x132fe <FSettingSystem+0x10e>
   132f4:	83 e0       	ldi	r24, 0x03	; 3
   132f6:	61 e0       	ldi	r22, 0x01	; 1
   132f8:	4f ef       	ldi	r20, 0xFF	; 255
   132fa:	5d e0       	ldi	r21, 0x0D	; 13
   132fc:	0d c0       	rjmp	.+26     	; 0x13318 <FSettingSystem+0x128>
		  else
		  if (HGMode==HM_232)lcd_printf(3,1,PSTR("3.COM3:232"));
   132fe:	11 30       	cpi	r17, 0x01	; 1
   13300:	29 f4       	brne	.+10     	; 0x1330c <FSettingSystem+0x11c>
   13302:	83 e0       	ldi	r24, 0x03	; 3
   13304:	61 e0       	ldi	r22, 0x01	; 1
   13306:	44 ef       	ldi	r20, 0xF4	; 244
   13308:	5d e0       	ldi	r21, 0x0D	; 13
   1330a:	06 c0       	rjmp	.+12     	; 0x13318 <FSettingSystem+0x128>
		  else
		  if (HGMode==HM_485)lcd_printf(3,1,PSTR("3.COM3:485"));		  
   1330c:	12 30       	cpi	r17, 0x02	; 2
   1330e:	31 f4       	brne	.+12     	; 0x1331c <FSettingSystem+0x12c>
   13310:	83 e0       	ldi	r24, 0x03	; 3
   13312:	61 e0       	ldi	r22, 0x01	; 1
   13314:	49 ee       	ldi	r20, 0xE9	; 233
   13316:	5d e0       	ldi	r21, 0x0D	; 13
   13318:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		  lcd_printf(4,1,PSTR("[*]Back      "));
   1331c:	84 e0       	ldi	r24, 0x04	; 4
   1331e:	61 e0       	ldi	r22, 0x01	; 1
   13320:	4b ed       	ldi	r20, 0xDB	; 219
   13322:	5d e0       	ldi	r21, 0x0D	; 13
   13324:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		  stSettingSytem=ssMenuSelect;
   13328:	81 e0       	ldi	r24, 0x01	; 1
   1332a:	e1 c0       	rjmp	.+450    	; 0x134ee <FSettingSystem+0x2fe>
	      break;
     case ssMenuSelect:
          KeyPressed=_key_scan(1);
   1332c:	81 e0       	ldi	r24, 0x01	; 1
   1332e:	0e 94 06 b0 	call	0x1600c	; 0x1600c <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
   13332:	0e 94 67 af 	call	0x15ece	; 0x15ece <_key_btn>
		  if (KeyChar=='1'){
   13336:	81 33       	cpi	r24, 0x31	; 49
   13338:	c1 f4       	brne	.+48     	; 0x1336a <FSettingSystem+0x17a>
		      IFType=((IFType+1)%3);
   1333a:	80 91 10 01 	lds	r24, 0x0110
   1333e:	90 e0       	ldi	r25, 0x00	; 0
   13340:	01 96       	adiw	r24, 0x01	; 1
   13342:	63 e0       	ldi	r22, 0x03	; 3
   13344:	70 e0       	ldi	r23, 0x00	; 0
   13346:	0e 94 a7 b8 	call	0x1714e	; 0x1714e <__divmodhi4>
   1334a:	80 93 10 01 	sts	0x0110, r24
			  SendSlaveCommand(IFType,DispenserBrand);
   1334e:	60 91 61 01 	lds	r22, 0x0161
   13352:	0e 94 de 73 	call	0xe7bc	; 0xe7bc <SendSlaveCommand>
			  eeprom_write_byte(&DefInitIFT,IFType);
   13356:	20 91 10 01 	lds	r18, 0x0110
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   1335a:	e1 99       	sbic	0x1c, 1	; 28
   1335c:	fe cf       	rjmp	.-4      	; 0x1335a <FSettingSystem+0x16a>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   1335e:	86 e3       	ldi	r24, 0x36	; 54
   13360:	91 e0       	ldi	r25, 0x01	; 1
   13362:	9f bb       	out	0x1f, r25	; 31
   13364:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
   13366:	2d bb       	out	0x1d, r18	; 29
   13368:	1f c0       	rjmp	.+62     	; 0x133a8 <FSettingSystem+0x1b8>
			  stSettingSytem=ssInitSettingSystem;
		  }
		  else
		  if (KeyChar=='2'){
   1336a:	82 33       	cpi	r24, 0x32	; 50
   1336c:	09 f4       	brne	.+2      	; 0x13370 <FSettingSystem+0x180>
   1336e:	ba c0       	rjmp	.+372    	; 0x134e4 <FSettingSystem+0x2f4>
		      stSettingSytem=ssComSettings;
		  }
		  else
		  if (KeyChar=='3'){
   13370:	83 33       	cpi	r24, 0x33	; 51
   13372:	01 f5       	brne	.+64     	; 0x133b4 <FSettingSystem+0x1c4>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   13374:	e1 99       	sbic	0x1c, 1	; 28
   13376:	fe cf       	rjmp	.-4      	; 0x13374 <FSettingSystem+0x184>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   13378:	e2 ec       	ldi	r30, 0xC2	; 194
   1337a:	ee 2e       	mov	r14, r30
   1337c:	e3 e0       	ldi	r30, 0x03	; 3
   1337e:	fe 2e       	mov	r15, r30
   13380:	ff ba       	out	0x1f, r15	; 31
   13382:	ee ba       	out	0x1e, r14	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   13384:	e0 9a       	sbi	0x1c, 0	; 28
   13386:	8d b3       	in	r24, 0x1d	; 29
		      HGMode=eeprom_read_byte(&DefHGMode);
		      HGMode=((HGMode+1)%3);
   13388:	90 e0       	ldi	r25, 0x00	; 0
   1338a:	01 96       	adiw	r24, 0x01	; 1
   1338c:	63 e0       	ldi	r22, 0x03	; 3
   1338e:	70 e0       	ldi	r23, 0x00	; 0
   13390:	0e 94 a7 b8 	call	0x1714e	; 0x1714e <__divmodhi4>
   13394:	18 2f       	mov	r17, r24
			  SendSlaveCommand(SC_HGM_MODE,HGMode);
   13396:	81 e2       	ldi	r24, 0x21	; 33
   13398:	61 2f       	mov	r22, r17
   1339a:	0e 94 de 73 	call	0xe7bc	; 0xe7bc <SendSlaveCommand>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   1339e:	e1 99       	sbic	0x1c, 1	; 28
   133a0:	fe cf       	rjmp	.-4      	; 0x1339e <FSettingSystem+0x1ae>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   133a2:	ff ba       	out	0x1f, r15	; 31
   133a4:	ee ba       	out	0x1e, r14	; 30
#endif
    EEDR = __value;
   133a6:	1d bb       	out	0x1d, r17	; 29

    __asm__ __volatile__ (
   133a8:	0f b6       	in	r0, 0x3f	; 63
   133aa:	f8 94       	cli
   133ac:	e2 9a       	sbi	0x1c, 2	; 28
   133ae:	e1 9a       	sbi	0x1c, 1	; 28
   133b0:	0f be       	out	0x3f, r0	; 63
   133b2:	a4 c0       	rjmp	.+328    	; 0x134fc <FSettingSystem+0x30c>
			  eeprom_write_byte(&DefHGMode,HGMode);
			  stSettingSytem=ssInitSettingSystem;
		  }
		  //else
		  if (KeyChar=='*'){
   133b4:	8a 32       	cpi	r24, 0x2A	; 42
   133b6:	09 f4       	brne	.+2      	; 0x133ba <FSettingSystem+0x1ca>
   133b8:	99 c0       	rjmp	.+306    	; 0x134ec <FSettingSystem+0x2fc>
   133ba:	a7 c0       	rjmp	.+334    	; 0x1350a <FSettingSystem+0x31a>
		      stSettingSytem=ssExitSystemSettings;
		  }		  
		  break;
	 case ssComSettings:
	      lcd_clear();
   133bc:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
		  lcd_printf(1,1,PSTR("     -Baudrate-     "));
   133c0:	81 e0       	ldi	r24, 0x01	; 1
   133c2:	61 e0       	ldi	r22, 0x01	; 1
   133c4:	46 ec       	ldi	r20, 0xC6	; 198
   133c6:	5d e0       	ldi	r21, 0x0D	; 13
   133c8:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
   133cc:	01 e0       	ldi	r16, 0x01	; 1
   133ce:	10 e0       	ldi	r17, 0x00	; 0

		  for (i=0;i<4;i++){
		       bValue=GetBaudrate(eeprom_read_byte(&DefBaudrate[i]));
			   if (bValue==5787)bValue=12213;
		       sprintf_P(lcdteks,PSTR("COM%d:%d"),i+1,bValue);
   133d0:	6e 01       	movw	r12, r28
   133d2:	08 94       	sec
   133d4:	c1 1c       	adc	r12, r1
   133d6:	d1 1c       	adc	r13, r1
   133d8:	7d eb       	ldi	r23, 0xBD	; 189
   133da:	a7 2e       	mov	r10, r23
   133dc:	7d e0       	ldi	r23, 0x0D	; 13
   133de:	b7 2e       	mov	r11, r23
			   lcd_print((2+(i%2)),1+(i/2*11),lcdteks);
   133e0:	6b e0       	ldi	r22, 0x0B	; 11
   133e2:	e6 2e       	mov	r14, r22
		      stSettingSytem=ssExitSystemSettings;
		  }		  
		  break;
	 case ssComSettings:
	      lcd_clear();
		  lcd_printf(1,1,PSTR("     -Baudrate-     "));
   133e4:	f0 2e       	mov	r15, r16
   133e6:	fa 94       	dec	r15
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   133e8:	e1 99       	sbic	0x1c, 1	; 28
   133ea:	fe cf       	rjmp	.-4      	; 0x133e8 <FSettingSystem+0x1f8>
   133ec:	c8 01       	movw	r24, r16
   133ee:	81 5c       	subi	r24, 0xC1	; 193
   133f0:	9e 4f       	sbci	r25, 0xFE	; 254
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   133f2:	9f bb       	out	0x1f, r25	; 31
   133f4:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   133f6:	e0 9a       	sbi	0x1c, 0	; 28
   133f8:	8d b3       	in	r24, 0x1d	; 29
	 }
}

int GetBaudrate(char brSetting){
int Result=0;
     switch(brSetting){
   133fa:	82 30       	cpi	r24, 0x02	; 2
   133fc:	69 f0       	breq	.+26     	; 0x13418 <FSettingSystem+0x228>
   133fe:	82 30       	cpi	r24, 0x02	; 2
   13400:	28 f0       	brcs	.+10     	; 0x1340c <FSettingSystem+0x21c>
   13402:	83 30       	cpi	r24, 0x03	; 3
   13404:	31 f4       	brne	.+12     	; 0x13412 <FSettingSystem+0x222>
   13406:	85 eb       	ldi	r24, 0xB5	; 181
   13408:	9f e2       	ldi	r25, 0x2F	; 47
   1340a:	08 c0       	rjmp	.+16     	; 0x1341c <FSettingSystem+0x22c>
   1340c:	80 e8       	ldi	r24, 0x80	; 128
   1340e:	95 e2       	ldi	r25, 0x25	; 37
   13410:	05 c0       	rjmp	.+10     	; 0x1341c <FSettingSystem+0x22c>
   13412:	80 e0       	ldi	r24, 0x00	; 0
   13414:	90 e0       	ldi	r25, 0x00	; 0
   13416:	02 c0       	rjmp	.+4      	; 0x1341c <FSettingSystem+0x22c>
   13418:	80 e0       	ldi	r24, 0x00	; 0
   1341a:	9b e4       	ldi	r25, 0x4B	; 75
		  lcd_printf(1,1,PSTR("     -Baudrate-     "));

		  for (i=0;i<4;i++){
		       bValue=GetBaudrate(eeprom_read_byte(&DefBaudrate[i]));
			   if (bValue==5787)bValue=12213;
		       sprintf_P(lcdteks,PSTR("COM%d:%d"),i+1,bValue);
   1341c:	ed b7       	in	r30, 0x3d	; 61
   1341e:	fe b7       	in	r31, 0x3e	; 62
   13420:	38 97       	sbiw	r30, 0x08	; 8
   13422:	0f b6       	in	r0, 0x3f	; 63
   13424:	f8 94       	cli
   13426:	fe bf       	out	0x3e, r31	; 62
   13428:	0f be       	out	0x3f, r0	; 63
   1342a:	ed bf       	out	0x3d, r30	; 61
   1342c:	31 96       	adiw	r30, 0x01	; 1
   1342e:	ad b7       	in	r26, 0x3d	; 61
   13430:	be b7       	in	r27, 0x3e	; 62
   13432:	12 96       	adiw	r26, 0x02	; 2
   13434:	dc 92       	st	X, r13
   13436:	ce 92       	st	-X, r12
   13438:	11 97       	sbiw	r26, 0x01	; 1
   1343a:	b3 82       	std	Z+3, r11	; 0x03
   1343c:	a2 82       	std	Z+2, r10	; 0x02
   1343e:	15 83       	std	Z+5, r17	; 0x05
   13440:	04 83       	std	Z+4, r16	; 0x04
   13442:	97 83       	std	Z+7, r25	; 0x07
   13444:	86 83       	std	Z+6, r24	; 0x06
   13446:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
			   lcd_print((2+(i%2)),1+(i/2*11),lcdteks);
   1344a:	ed b7       	in	r30, 0x3d	; 61
   1344c:	fe b7       	in	r31, 0x3e	; 62
   1344e:	38 96       	adiw	r30, 0x08	; 8
   13450:	0f b6       	in	r0, 0x3f	; 63
   13452:	f8 94       	cli
   13454:	fe bf       	out	0x3e, r31	; 62
   13456:	0f be       	out	0x3f, r0	; 63
   13458:	ed bf       	out	0x3d, r30	; 61
   1345a:	6f 2d       	mov	r22, r15
   1345c:	66 95       	lsr	r22
   1345e:	6e 9d       	mul	r22, r14
   13460:	b0 01       	movw	r22, r0
   13462:	11 24       	eor	r1, r1
   13464:	6f 5f       	subi	r22, 0xFF	; 255
   13466:	f1 e0       	ldi	r31, 0x01	; 1
   13468:	ff 22       	and	r15, r31
   1346a:	8f 2d       	mov	r24, r15
   1346c:	8e 5f       	subi	r24, 0xFE	; 254
   1346e:	a6 01       	movw	r20, r12
   13470:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
   13474:	0f 5f       	subi	r16, 0xFF	; 255
   13476:	1f 4f       	sbci	r17, 0xFF	; 255
		  break;
	 case ssComSettings:
	      lcd_clear();
		  lcd_printf(1,1,PSTR("     -Baudrate-     "));

		  for (i=0;i<4;i++){
   13478:	05 30       	cpi	r16, 0x05	; 5
   1347a:	11 05       	cpc	r17, r1
   1347c:	09 f0       	breq	.+2      	; 0x13480 <FSettingSystem+0x290>
   1347e:	b2 cf       	rjmp	.-156    	; 0x133e4 <FSettingSystem+0x1f4>
		       bValue=GetBaudrate(eeprom_read_byte(&DefBaudrate[i]));
			   if (bValue==5787)bValue=12213;
		       sprintf_P(lcdteks,PSTR("COM%d:%d"),i+1,bValue);
			   lcd_print((2+(i%2)),1+(i/2*11),lcdteks);
		  }
		  lcd_printf(4,1,PSTR("[*]Back     "));
   13480:	84 e0       	ldi	r24, 0x04	; 4
   13482:	61 e0       	ldi	r22, 0x01	; 1
   13484:	40 eb       	ldi	r20, 0xB0	; 176
   13486:	5d e0       	ldi	r21, 0x0D	; 13
   13488:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		  stSettingSytem=ssBaudrateInput;
   1348c:	83 e0       	ldi	r24, 0x03	; 3
   1348e:	2f c0       	rjmp	.+94     	; 0x134ee <FSettingSystem+0x2fe>
	      break;
     case ssBaudrateInput:
	      KeyPressed=_key_scan(1);
   13490:	81 e0       	ldi	r24, 0x01	; 1
   13492:	0e 94 06 b0 	call	0x1600c	; 0x1600c <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
   13496:	0e 94 67 af 	call	0x15ece	; 0x15ece <_key_btn>
   1349a:	28 2f       	mov	r18, r24
		  if ((KeyChar>='1')&&(KeyChar<='4')){
   1349c:	81 53       	subi	r24, 0x31	; 49
   1349e:	84 30       	cpi	r24, 0x04	; 4
   134a0:	18 f5       	brcc	.+70     	; 0x134e8 <FSettingSystem+0x2f8>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   134a2:	e1 99       	sbic	0x1c, 1	; 28
   134a4:	fe cf       	rjmp	.-4      	; 0x134a2 <FSettingSystem+0x2b2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   134a6:	02 2f       	mov	r16, r18
   134a8:	10 e0       	ldi	r17, 0x00	; 0
   134aa:	01 5f       	subi	r16, 0xF1	; 241
   134ac:	1e 4f       	sbci	r17, 0xFE	; 254
   134ae:	1f bb       	out	0x1f, r17	; 31
   134b0:	0e bb       	out	0x1e, r16	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   134b2:	e0 9a       	sbi	0x1c, 0	; 28
   134b4:	8d b3       	in	r24, 0x1d	; 29
		       brVal=eeprom_read_byte(&DefBaudrate[KeyChar-'1']);
			   brVal=((brVal+1)%3)+1;
   134b6:	90 e0       	ldi	r25, 0x00	; 0
   134b8:	01 96       	adiw	r24, 0x01	; 1
   134ba:	63 e0       	ldi	r22, 0x03	; 3
   134bc:	70 e0       	ldi	r23, 0x00	; 0
   134be:	0e 94 a7 b8 	call	0x1714e	; 0x1714e <__divmodhi4>
   134c2:	f8 2e       	mov	r15, r24
   134c4:	f3 94       	inc	r15
			   SetBaudRate(KeyChar-'0',brVal);
   134c6:	82 2f       	mov	r24, r18
   134c8:	80 53       	subi	r24, 0x30	; 48
   134ca:	6f 2d       	mov	r22, r15
   134cc:	0e 94 c2 98 	call	0x13184	; 0x13184 <SetBaudRate>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   134d0:	e1 99       	sbic	0x1c, 1	; 28
   134d2:	fe cf       	rjmp	.-4      	; 0x134d0 <FSettingSystem+0x2e0>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   134d4:	1f bb       	out	0x1f, r17	; 31
   134d6:	0e bb       	out	0x1e, r16	; 30
#endif
    EEDR = __value;
   134d8:	fd ba       	out	0x1d, r15	; 29

    __asm__ __volatile__ (
   134da:	0f b6       	in	r0, 0x3f	; 63
   134dc:	f8 94       	cli
   134de:	e2 9a       	sbi	0x1c, 2	; 28
   134e0:	e1 9a       	sbi	0x1c, 1	; 28
   134e2:	0f be       	out	0x3f, r0	; 63
			   eeprom_write_byte(&DefBaudrate[KeyChar-'1'],brVal);
               stSettingSytem=ssComSettings;
   134e4:	82 e0       	ldi	r24, 0x02	; 2
   134e6:	03 c0       	rjmp	.+6      	; 0x134ee <FSettingSystem+0x2fe>
		  }else if (KeyChar=='*')
   134e8:	2a 32       	cpi	r18, 0x2A	; 42
   134ea:	79 f4       	brne	.+30     	; 0x1350a <FSettingSystem+0x31a>
		      stSettingSytem=ssExitSystemSettings;		  	
   134ec:	85 e0       	ldi	r24, 0x05	; 5
   134ee:	80 93 e0 02 	sts	0x02E0, r24
   134f2:	0b c0       	rjmp	.+22     	; 0x1350a <FSettingSystem+0x31a>
	      break;
	 case ssPumpPoolingSettings:
          SubMenu=FSettingPumpPooling();
   134f4:	0e 94 82 6f 	call	0xdf04	; 0xdf04 <FSettingPumpPooling>
		  if (SubMenu==MENU_DONE)stSettingSytem=ssInitSettingSystem;
   134f8:	81 30       	cpi	r24, 0x01	; 1
   134fa:	39 f4       	brne	.+14     	; 0x1350a <FSettingSystem+0x31a>
   134fc:	10 92 e0 02 	sts	0x02E0, r1
   13500:	04 c0       	rjmp	.+8      	; 0x1350a <FSettingSystem+0x31a>
	      break;
     case ssExitSystemSettings:
	      stSettingSytem=ssInitSettingSystem;
   13502:	10 92 e0 02 	sts	0x02E0, r1
   13506:	81 e0       	ldi	r24, 0x01	; 1
   13508:	01 c0       	rjmp	.+2      	; 0x1350c <FSettingSystem+0x31c>
   1350a:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
     return Result;
}
   1350c:	64 96       	adiw	r28, 0x14	; 20
   1350e:	0f b6       	in	r0, 0x3f	; 63
   13510:	f8 94       	cli
   13512:	de bf       	out	0x3e, r29	; 62
   13514:	0f be       	out	0x3f, r0	; 63
   13516:	cd bf       	out	0x3d, r28	; 61
   13518:	cf 91       	pop	r28
   1351a:	df 91       	pop	r29
   1351c:	1f 91       	pop	r17
   1351e:	0f 91       	pop	r16
   13520:	ff 90       	pop	r15
   13522:	ef 90       	pop	r14
   13524:	df 90       	pop	r13
   13526:	cf 90       	pop	r12
   13528:	bf 90       	pop	r11
   1352a:	af 90       	pop	r10
   1352c:	08 95       	ret

0001352e <FMenuSettings>:


char FMenuSettings(){
char Result=MENU_NONE;
static char stMenuSettings=msInit,PageSetting=1,KeyPressed,KeyChar,SubMenu;
     switch(stMenuSettings){
   1352e:	80 91 f3 02 	lds	r24, 0x02F3
   13532:	e8 2f       	mov	r30, r24
   13534:	f0 e0       	ldi	r31, 0x00	; 0
   13536:	e3 31       	cpi	r30, 0x13	; 19
   13538:	f1 05       	cpc	r31, r1
   1353a:	08 f0       	brcs	.+2      	; 0x1353e <FMenuSettings+0x10>
   1353c:	cd c0       	rjmp	.+410    	; 0x136d8 <FMenuSettings+0x1aa>
   1353e:	ee 51       	subi	r30, 0x1E	; 30
   13540:	ff 4f       	sbci	r31, 0xFF	; 255
   13542:	ee 0f       	add	r30, r30
   13544:	ff 1f       	adc	r31, r31
   13546:	05 90       	lpm	r0, Z+
   13548:	f4 91       	lpm	r31, Z+
   1354a:	e0 2d       	mov	r30, r0
   1354c:	09 94       	ijmp
	 case msInit:
		  lcd_clear();
   1354e:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
		  PageSetting=1;
   13552:	81 e0       	ldi	r24, 0x01	; 1
   13554:	80 93 57 01 	sts	0x0157, r24
   13558:	b7 c0       	rjmp	.+366    	; 0x136c8 <FMenuSettings+0x19a>
		  stMenuSettings=msDisplayPage;
		  break;
	 case msDisplayPage:
	      stMenuSettings=msDisplayPage+PageSetting;
   1355a:	80 91 57 01 	lds	r24, 0x0157
   1355e:	8f 5f       	subi	r24, 0xFF	; 255
   13560:	b3 c0       	rjmp	.+358    	; 0x136c8 <FMenuSettings+0x19a>
          break; 	 
	 case msDisplayPage1:
		  lcd_printf(1, 1, PSTR("1)Product  5)Printer"));
   13562:	81 e0       	ldi	r24, 0x01	; 1
   13564:	61 e0       	ldi	r22, 0x01	; 1
   13566:	48 ea       	ldi	r20, 0xA8	; 168
   13568:	52 e1       	ldi	r21, 0x12	; 18
   1356a:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		  lcd_printf(2, 1, PSTR("2)Pump     6)Host   "));
   1356e:	82 e0       	ldi	r24, 0x02	; 2
   13570:	61 e0       	ldi	r22, 0x01	; 1
   13572:	43 e9       	ldi	r20, 0x93	; 147
   13574:	52 e1       	ldi	r21, 0x12	; 18
   13576:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		  lcd_printf(3, 1, PSTR("3)Decimal  7)Next   "));
   1357a:	83 e0       	ldi	r24, 0x03	; 3
   1357c:	61 e0       	ldi	r22, 0x01	; 1
   1357e:	4e e7       	ldi	r20, 0x7E	; 126
   13580:	52 e1       	ldi	r21, 0x12	; 18
   13582:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		  lcd_printf(4, 1, PSTR("4)Datetime *)Exit   "));
   13586:	84 e0       	ldi	r24, 0x04	; 4
   13588:	61 e0       	ldi	r22, 0x01	; 1
   1358a:	49 e6       	ldi	r20, 0x69	; 105
   1358c:	52 e1       	ldi	r21, 0x12	; 18
   1358e:	16 c0       	rjmp	.+44     	; 0x135bc <FMenuSettings+0x8e>
		  stMenuSettings=msSelection;
	      break;
	 case msDisplayPage2:
		  lcd_printf(1, 1, PSTR("1)Operator          "));
   13590:	81 e0       	ldi	r24, 0x01	; 1
   13592:	61 e0       	ldi	r22, 0x01	; 1
   13594:	44 e5       	ldi	r20, 0x54	; 84
   13596:	52 e1       	ldi	r21, 0x12	; 18
   13598:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		  lcd_printf(2, 1, PSTR("2)System            "));
   1359c:	82 e0       	ldi	r24, 0x02	; 2
   1359e:	61 e0       	ldi	r22, 0x01	; 1
   135a0:	4f e3       	ldi	r20, 0x3F	; 63
   135a2:	52 e1       	ldi	r21, 0x12	; 18
   135a4:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		  lcd_printf(3, 1, PSTR("3)PumpPooling       "));
   135a8:	83 e0       	ldi	r24, 0x03	; 3
   135aa:	61 e0       	ldi	r22, 0x01	; 1
   135ac:	4a e2       	ldi	r20, 0x2A	; 42
   135ae:	52 e1       	ldi	r21, 0x12	; 18
   135b0:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		  lcd_printf(4, 1, PSTR("*)Back              "));
   135b4:	84 e0       	ldi	r24, 0x04	; 4
   135b6:	61 e0       	ldi	r22, 0x01	; 1
   135b8:	45 e1       	ldi	r20, 0x15	; 21
   135ba:	52 e1       	ldi	r21, 0x12	; 18
   135bc:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		  stMenuSettings=msSelection;
   135c0:	84 e0       	ldi	r24, 0x04	; 4
   135c2:	82 c0       	rjmp	.+260    	; 0x136c8 <FMenuSettings+0x19a>
	      break;
	 case msSelection:
	      stMenuSettings=msSelection+PageSetting;
   135c4:	80 91 57 01 	lds	r24, 0x0157
   135c8:	8c 5f       	subi	r24, 0xFC	; 252
   135ca:	7e c0       	rjmp	.+252    	; 0x136c8 <FMenuSettings+0x19a>
          break;	 
	 case msSelectionPage1:
		  KeyPressed=_key_scan(1);
   135cc:	81 e0       	ldi	r24, 0x01	; 1
   135ce:	0e 94 06 b0 	call	0x1600c	; 0x1600c <_key_scan>
   135d2:	80 93 f2 02 	sts	0x02F2, r24
		  KeyChar=_key_btn(KeyPressed);
   135d6:	0e 94 67 af 	call	0x15ece	; 0x15ece <_key_btn>
   135da:	80 93 f1 02 	sts	0x02F1, r24
		  switch(KeyChar){
   135de:	84 33       	cpi	r24, 0x34	; 52
   135e0:	d1 f0       	breq	.+52     	; 0x13616 <FMenuSettings+0xe8>
   135e2:	85 33       	cpi	r24, 0x35	; 53
   135e4:	50 f4       	brcc	.+20     	; 0x135fa <FMenuSettings+0xcc>
   135e6:	82 33       	cpi	r24, 0x32	; 50
   135e8:	91 f0       	breq	.+36     	; 0x1360e <FMenuSettings+0xe0>
   135ea:	83 33       	cpi	r24, 0x33	; 51
   135ec:	90 f4       	brcc	.+36     	; 0x13612 <FMenuSettings+0xe4>
   135ee:	8a 32       	cpi	r24, 0x2A	; 42
   135f0:	d1 f0       	breq	.+52     	; 0x13626 <FMenuSettings+0xf8>
   135f2:	81 33       	cpi	r24, 0x31	; 49
   135f4:	09 f0       	breq	.+2      	; 0x135f8 <FMenuSettings+0xca>
   135f6:	70 c0       	rjmp	.+224    	; 0x136d8 <FMenuSettings+0x1aa>
   135f8:	08 c0       	rjmp	.+16     	; 0x1360a <FMenuSettings+0xdc>
   135fa:	86 33       	cpi	r24, 0x36	; 54
   135fc:	81 f0       	breq	.+32     	; 0x1361e <FMenuSettings+0xf0>
   135fe:	86 33       	cpi	r24, 0x36	; 54
   13600:	60 f0       	brcs	.+24     	; 0x1361a <FMenuSettings+0xec>
   13602:	87 33       	cpi	r24, 0x37	; 55
   13604:	09 f0       	breq	.+2      	; 0x13608 <FMenuSettings+0xda>
   13606:	68 c0       	rjmp	.+208    	; 0x136d8 <FMenuSettings+0x1aa>
   13608:	0c c0       	rjmp	.+24     	; 0x13622 <FMenuSettings+0xf4>
		  case '1':
		       stMenuSettings=msMenuSettingProduct;
   1360a:	89 e0       	ldi	r24, 0x09	; 9
   1360c:	5d c0       	rjmp	.+186    	; 0x136c8 <FMenuSettings+0x19a>
		       break;
		  case '2': 
		       stMenuSettings=msMenuSettingPump;
   1360e:	8a e0       	ldi	r24, 0x0A	; 10
   13610:	5b c0       	rjmp	.+182    	; 0x136c8 <FMenuSettings+0x19a>
		       break;
		  case '3':
		       stMenuSettings=msMenuSettingDec;
   13612:	8b e0       	ldi	r24, 0x0B	; 11
   13614:	59 c0       	rjmp	.+178    	; 0x136c8 <FMenuSettings+0x19a>
		       break;
		  case '4':
		       stMenuSettings=msMenuSettingDatetime;
   13616:	8c e0       	ldi	r24, 0x0C	; 12
   13618:	57 c0       	rjmp	.+174    	; 0x136c8 <FMenuSettings+0x19a>
		       break;
		  case '5':
		       stMenuSettings=msMenuSettingPrinter;
   1361a:	8d e0       	ldi	r24, 0x0D	; 13
   1361c:	55 c0       	rjmp	.+170    	; 0x136c8 <FMenuSettings+0x19a>
		       break;
		  case '6':
		       stMenuSettings=msMenuSettingHost;
   1361e:	8e e0       	ldi	r24, 0x0E	; 14
   13620:	53 c0       	rjmp	.+166    	; 0x136c8 <FMenuSettings+0x19a>
		       break;
		  case '7':
		       stMenuSettings=msMenuSettingNextPage;
   13622:	87 e0       	ldi	r24, 0x07	; 7
   13624:	51 c0       	rjmp	.+162    	; 0x136c8 <FMenuSettings+0x19a>
		       break;
		  case '*':
		       stMenuSettings=msMenuSettingExit;
   13626:	82 e1       	ldi	r24, 0x12	; 18
   13628:	4f c0       	rjmp	.+158    	; 0x136c8 <FMenuSettings+0x19a>
		       break;			   
		  }
	      break;
	 case msSelectionPage2:
	 	  KeyPressed=_key_scan(1);
   1362a:	81 e0       	ldi	r24, 0x01	; 1
   1362c:	0e 94 06 b0 	call	0x1600c	; 0x1600c <_key_scan>
   13630:	80 93 f2 02 	sts	0x02F2, r24
		  KeyChar=_key_btn(KeyPressed);
   13634:	0e 94 67 af 	call	0x15ece	; 0x15ece <_key_btn>
   13638:	80 93 f1 02 	sts	0x02F1, r24
		  switch(KeyChar){
   1363c:	82 33       	cpi	r24, 0x32	; 50
   1363e:	71 f0       	breq	.+28     	; 0x1365c <FMenuSettings+0x12e>
   13640:	83 33       	cpi	r24, 0x33	; 51
   13642:	30 f4       	brcc	.+12     	; 0x13650 <FMenuSettings+0x122>
   13644:	8a 32       	cpi	r24, 0x2A	; 42
   13646:	71 f0       	breq	.+28     	; 0x13664 <FMenuSettings+0x136>
   13648:	81 33       	cpi	r24, 0x31	; 49
   1364a:	09 f0       	breq	.+2      	; 0x1364e <FMenuSettings+0x120>
   1364c:	45 c0       	rjmp	.+138    	; 0x136d8 <FMenuSettings+0x1aa>
   1364e:	04 c0       	rjmp	.+8      	; 0x13658 <FMenuSettings+0x12a>
   13650:	83 33       	cpi	r24, 0x33	; 51
   13652:	09 f0       	breq	.+2      	; 0x13656 <FMenuSettings+0x128>
   13654:	41 c0       	rjmp	.+130    	; 0x136d8 <FMenuSettings+0x1aa>
   13656:	04 c0       	rjmp	.+8      	; 0x13660 <FMenuSettings+0x132>
		  case '1':
		       stMenuSettings=msMenuSettingOperator;
   13658:	8f e0       	ldi	r24, 0x0F	; 15
   1365a:	36 c0       	rjmp	.+108    	; 0x136c8 <FMenuSettings+0x19a>
		       break;
		  case '2':
		       stMenuSettings=msMenuSettingSystem;
   1365c:	80 e1       	ldi	r24, 0x10	; 16
   1365e:	34 c0       	rjmp	.+104    	; 0x136c8 <FMenuSettings+0x19a>
		       break;
		  case '3':
		       stMenuSettings=msMenuSettingPumpPooling;
   13660:	81 e1       	ldi	r24, 0x11	; 17
   13662:	32 c0       	rjmp	.+100    	; 0x136c8 <FMenuSettings+0x19a>
		       break;
		  case '*':
		       stMenuSettings=msMenuSettingBackPage;
   13664:	88 e0       	ldi	r24, 0x08	; 8
   13666:	30 c0       	rjmp	.+96     	; 0x136c8 <FMenuSettings+0x19a>
		       break;		  
		  }
	      break;
		  
	 case msMenuSettingNextPage:
	      if (PageSetting<2)PageSetting++;
   13668:	80 91 57 01 	lds	r24, 0x0157
   1366c:	82 30       	cpi	r24, 0x02	; 2
   1366e:	48 f4       	brcc	.+18     	; 0x13682 <FMenuSettings+0x154>
   13670:	8f 5f       	subi	r24, 0xFF	; 255
   13672:	05 c0       	rjmp	.+10     	; 0x1367e <FMenuSettings+0x150>
		  stMenuSettings=msDisplayPage;
	      break;
	 case msMenuSettingBackPage:
	      if (PageSetting>1)PageSetting--;
   13674:	80 91 57 01 	lds	r24, 0x0157
   13678:	82 30       	cpi	r24, 0x02	; 2
   1367a:	18 f0       	brcs	.+6      	; 0x13682 <FMenuSettings+0x154>
   1367c:	81 50       	subi	r24, 0x01	; 1
   1367e:	80 93 57 01 	sts	0x0157, r24
		  stMenuSettings=msDisplayPage;
   13682:	81 e0       	ldi	r24, 0x01	; 1
   13684:	21 c0       	rjmp	.+66     	; 0x136c8 <FMenuSettings+0x19a>
	      break;
//---Sub Menu Operations--------------------------------------------		  
     case msMenuSettingProduct:
	      SubMenu=FSettingProduct();
   13686:	0e 94 fc 89 	call	0x113f8	; 0x113f8 <FSettingProduct>
   1368a:	1a c0       	rjmp	.+52     	; 0x136c0 <FMenuSettings+0x192>
		  if (SubMenu==MENU_DONE)stMenuSettings=msDisplayPage;
	      break;
	 case msMenuSettingPump:
	      SubMenu=FSettingPump();
   1368c:	0e 94 95 77 	call	0xef2a	; 0xef2a <FSettingPump>
   13690:	17 c0       	rjmp	.+46     	; 0x136c0 <FMenuSettings+0x192>
		  if (SubMenu==MENU_DONE)stMenuSettings=msDisplayPage;
	      break;
	 case msMenuSettingDec:
	      SubMenu=FSettingDec();
   13692:	0e 94 ac 82 	call	0x10558	; 0x10558 <FSettingDec>
   13696:	14 c0       	rjmp	.+40     	; 0x136c0 <FMenuSettings+0x192>
	 }
     return Result;
}

char FSettingDatetime(){
     _menu_datetime();
   13698:	0e 94 52 63 	call	0xc6a4	; 0xc6a4 <_menu_datetime>
   1369c:	05 c0       	rjmp	.+10     	; 0x136a8 <FMenuSettings+0x17a>
     return MENU_DONE;
}
char FSettingPrinter(){
     _menu_printer();
   1369e:	0e 94 a6 4b 	call	0x974c	; 0x974c <_menu_printer>
   136a2:	02 c0       	rjmp	.+4      	; 0x136a8 <FMenuSettings+0x17a>
	 return MENU_DONE;
}
char FSettingHost(){
     _menu_host();
   136a4:	0e 94 dd 46 	call	0x8dba	; 0x8dba <_menu_host>
	 case msMenuSettingPrinter: 
	      SubMenu=FSettingPrinter();
		  if (SubMenu==MENU_DONE)stMenuSettings=msDisplayPage;
	      break;
	 case msMenuSettingHost:
	      SubMenu=FSettingHost();
   136a8:	81 e0       	ldi	r24, 0x01	; 1
   136aa:	80 93 f0 02 	sts	0x02F0, r24
   136ae:	0c c0       	rjmp	.+24     	; 0x136c8 <FMenuSettings+0x19a>
		  if (SubMenu==MENU_DONE)stMenuSettings=msDisplayPage;
	      break;
     case msMenuSettingOperator:
          SubMenu=FSettingOperator();
   136b0:	0e 94 09 87 	call	0x10e12	; 0x10e12 <FSettingOperator>
   136b4:	05 c0       	rjmp	.+10     	; 0x136c0 <FMenuSettings+0x192>
		  if (SubMenu==MENU_DONE)stMenuSettings=msDisplayPage;
	      break;
	 case msMenuSettingSystem:
	      SubMenu=FSettingSystem();
   136b6:	0e 94 f8 98 	call	0x131f0	; 0x131f0 <FSettingSystem>
   136ba:	02 c0       	rjmp	.+4      	; 0x136c0 <FMenuSettings+0x192>
		  if (SubMenu==MENU_DONE)stMenuSettings=msDisplayPage;
	      break;	 
     case msMenuSettingPumpPooling:
	      SubMenu=FSettingPumpPooling();
   136bc:	0e 94 82 6f 	call	0xdf04	; 0xdf04 <FSettingPumpPooling>
   136c0:	80 93 f0 02 	sts	0x02F0, r24
		  if (SubMenu==MENU_DONE)stMenuSettings=msDisplayPage;
   136c4:	81 30       	cpi	r24, 0x01	; 1
   136c6:	41 f4       	brne	.+16     	; 0x136d8 <FMenuSettings+0x1aa>
   136c8:	80 93 f3 02 	sts	0x02F3, r24
   136cc:	80 e0       	ldi	r24, 0x00	; 0
   136ce:	08 95       	ret
	      break;
//------------------------------------------------------------------
     case msMenuSettingExit:
	      stMenuSettings=msInit;
   136d0:	10 92 f3 02 	sts	0x02F3, r1
   136d4:	81 e0       	ldi	r24, 0x01	; 1
   136d6:	08 95       	ret
   136d8:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
   return Result;
}
   136da:	08 95       	ret

000136dc <FMenuAuthorization>:


char FMenuAuthorization(){
char Result=MENU_NONE,PassResult=MP_NONE,SubMenu=MENU_NONE;
static char stMenuAuthorization=maInit,PassTry=0;
     switch(stMenuAuthorization){
   136dc:	80 91 32 03 	lds	r24, 0x0332
   136e0:	83 30       	cpi	r24, 0x03	; 3
   136e2:	69 f1       	breq	.+90     	; 0x1373e <FMenuAuthorization+0x62>
   136e4:	84 30       	cpi	r24, 0x04	; 4
   136e6:	28 f4       	brcc	.+10     	; 0x136f2 <FMenuAuthorization+0x16>
   136e8:	81 30       	cpi	r24, 0x01	; 1
   136ea:	89 f0       	breq	.+34     	; 0x1370e <FMenuAuthorization+0x32>
   136ec:	82 30       	cpi	r24, 0x02	; 2
   136ee:	50 f5       	brcc	.+84     	; 0x13744 <FMenuAuthorization+0x68>
   136f0:	0b c0       	rjmp	.+22     	; 0x13708 <FMenuAuthorization+0x2c>
   136f2:	85 30       	cpi	r24, 0x05	; 5
   136f4:	79 f1       	breq	.+94     	; 0x13754 <FMenuAuthorization+0x78>
   136f6:	85 30       	cpi	r24, 0x05	; 5
   136f8:	40 f1       	brcs	.+80     	; 0x1374a <FMenuAuthorization+0x6e>
   136fa:	86 30       	cpi	r24, 0x06	; 6
   136fc:	09 f4       	brne	.+2      	; 0x13700 <FMenuAuthorization+0x24>
   136fe:	41 c0       	rjmp	.+130    	; 0x13782 <FMenuAuthorization+0xa6>
   13700:	87 30       	cpi	r24, 0x07	; 7
   13702:	09 f0       	breq	.+2      	; 0x13706 <FMenuAuthorization+0x2a>
   13704:	51 c0       	rjmp	.+162    	; 0x137a8 <FMenuAuthorization+0xcc>
   13706:	4c c0       	rjmp	.+152    	; 0x137a0 <FMenuAuthorization+0xc4>
	 case maInit:
	      PassTry=0;
   13708:	10 92 31 03 	sts	0x0331, r1
   1370c:	42 c0       	rjmp	.+132    	; 0x13792 <FMenuAuthorization+0xb6>
		  stMenuAuthorization=maInputPassword;
	      break;
	 case maInputPassword:
	      PassResult=FMenuPassword();
   1370e:	0e 94 04 92 	call	0x12408	; 0x12408 <FMenuPassword>
		  switch(PassResult){
   13712:	83 30       	cpi	r24, 0x03	; 3
   13714:	09 f4       	brne	.+2      	; 0x13718 <FMenuAuthorization+0x3c>
   13716:	40 c0       	rjmp	.+128    	; 0x13798 <FMenuAuthorization+0xbc>
   13718:	84 30       	cpi	r24, 0x04	; 4
   1371a:	30 f4       	brcc	.+12     	; 0x13728 <FMenuAuthorization+0x4c>
   1371c:	81 30       	cpi	r24, 0x01	; 1
   1371e:	d9 f1       	breq	.+118    	; 0x13796 <FMenuAuthorization+0xba>
   13720:	82 30       	cpi	r24, 0x02	; 2
   13722:	09 f0       	breq	.+2      	; 0x13726 <FMenuAuthorization+0x4a>
   13724:	41 c0       	rjmp	.+130    	; 0x137a8 <FMenuAuthorization+0xcc>
   13726:	09 c0       	rjmp	.+18     	; 0x1373a <FMenuAuthorization+0x5e>
   13728:	84 30       	cpi	r24, 0x04	; 4
   1372a:	19 f0       	breq	.+6      	; 0x13732 <FMenuAuthorization+0x56>
   1372c:	85 30       	cpi	r24, 0x05	; 5
   1372e:	e1 f5       	brne	.+120    	; 0x137a8 <FMenuAuthorization+0xcc>
   13730:	02 c0       	rjmp	.+4      	; 0x13736 <FMenuAuthorization+0x5a>
		  case MP_VALID_ADMIN:
		       stMenuAuthorization=maMenuAdmin;
   13732:	82 e0       	ldi	r24, 0x02	; 2
   13734:	31 c0       	rjmp	.+98     	; 0x13798 <FMenuAuthorization+0xbc>
		       break;
		  case MP_VALID_SYSTEM:
		       stMenuAuthorization=maMenuSettings;
   13736:	84 e0       	ldi	r24, 0x04	; 4
   13738:	2f c0       	rjmp	.+94     	; 0x13798 <FMenuAuthorization+0xbc>
		       break;
		  case MP_INVALID:
		       stMenuAuthorization=maInvalidAuthorization;
   1373a:	85 e0       	ldi	r24, 0x05	; 5
   1373c:	2d c0       	rjmp	.+90     	; 0x13798 <FMenuAuthorization+0xbc>
		  else
	      if (PassResult==MP_CANCEL)stMenuAuthorization=maExitAuthorization;
		  */
	      break;
	 case maMenuMaster:
	      SubMenu=FMenuMaster();
   1373e:	0e 94 ed 8f 	call	0x11fda	; 0x11fda <FMenuMaster>
   13742:	05 c0       	rjmp	.+10     	; 0x1374e <FMenuAuthorization+0x72>
		  if (SubMenu==MENU_DONE)stMenuAuthorization=maExitAuthorization;
	      break;
	 case maMenuAdmin:
          SubMenu=FMenuAdmin();
   13744:	0e 94 fd 93 	call	0x127fa	; 0x127fa <FMenuAdmin>
   13748:	02 c0       	rjmp	.+4      	; 0x1374e <FMenuAuthorization+0x72>
		  if (SubMenu==MENU_DONE)stMenuAuthorization=maExitAuthorization;          
		  break;
	 case maMenuSettings:
	      SubMenu=FMenuSettings();
   1374a:	0e 94 97 9a 	call	0x1352e	; 0x1352e <FMenuSettings>
		  if (SubMenu==MENU_DONE)stMenuAuthorization=maExitAuthorization;
   1374e:	81 30       	cpi	r24, 0x01	; 1
   13750:	59 f5       	brne	.+86     	; 0x137a8 <FMenuAuthorization+0xcc>
   13752:	21 c0       	rjmp	.+66     	; 0x13796 <FMenuAuthorization+0xba>
          break;	 
	 case maInvalidAuthorization:
	      PassTry++;
   13754:	80 91 31 03 	lds	r24, 0x0331
   13758:	8f 5f       	subi	r24, 0xFF	; 255
   1375a:	80 93 31 03 	sts	0x0331, r24
	      TimDisplay=0;
   1375e:	10 92 a7 01 	sts	0x01A7, r1
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   13762:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   13764:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   13766:	81 e0       	ldi	r24, 0x01	; 1
   13768:	90 e0       	ldi	r25, 0x00	; 0
   1376a:	90 93 d7 01 	sts	0x01D7, r25
   1376e:	80 93 d6 01 	sts	0x01D6, r24
          break;	 
	 case maInvalidAuthorization:
	      PassTry++;
	      TimDisplay=0;
		  system_beep(1);
		  lcd_printf(3,1,PSTR("Access Denied"));
   13772:	83 e0       	ldi	r24, 0x03	; 3
   13774:	61 e0       	ldi	r22, 0x01	; 1
   13776:	47 e1       	ldi	r20, 0x17	; 23
   13778:	58 e1       	ldi	r21, 0x18	; 24
   1377a:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		  stMenuAuthorization=maDelayExitAuthorization;
   1377e:	86 e0       	ldi	r24, 0x06	; 6
   13780:	0b c0       	rjmp	.+22     	; 0x13798 <FMenuAuthorization+0xbc>
          break;	 
	 case maDelayExitAuthorization:
	      if (TimDisplay>2){
   13782:	80 91 a7 01 	lds	r24, 0x01A7
   13786:	83 30       	cpi	r24, 0x03	; 3
   13788:	78 f0       	brcs	.+30     	; 0x137a8 <FMenuAuthorization+0xcc>
		      if (PassTry<3)stMenuAuthorization=maInputPassword;
   1378a:	80 91 31 03 	lds	r24, 0x0331
   1378e:	83 30       	cpi	r24, 0x03	; 3
   13790:	10 f4       	brcc	.+4      	; 0x13796 <FMenuAuthorization+0xba>
   13792:	81 e0       	ldi	r24, 0x01	; 1
   13794:	01 c0       	rjmp	.+2      	; 0x13798 <FMenuAuthorization+0xbc>
			  else stMenuAuthorization=maExitAuthorization;
   13796:	87 e0       	ldi	r24, 0x07	; 7
   13798:	80 93 32 03 	sts	0x0332, r24
   1379c:	80 e0       	ldi	r24, 0x00	; 0
   1379e:	08 95       	ret
		  }
	      break;
	 case maExitAuthorization:
	      stMenuAuthorization=maInit;
   137a0:	10 92 32 03 	sts	0x0332, r1
   137a4:	81 e0       	ldi	r24, 0x01	; 1
   137a6:	08 95       	ret
   137a8:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
   return Result;	 
}
   137aa:	08 95       	ret

000137ac <InitComport>:
     	  break;	 
	 }
   return Result;
}

void InitComport(){
   137ac:	af 92       	push	r10
   137ae:	bf 92       	push	r11
   137b0:	cf 92       	push	r12
   137b2:	df 92       	push	r13
   137b4:	ff 92       	push	r15
   137b6:	0f 93       	push	r16
   137b8:	1f 93       	push	r17
   137ba:	df 93       	push	r29
   137bc:	cf 93       	push	r28
   137be:	cd b7       	in	r28, 0x3d	; 61
   137c0:	de b7       	in	r29, 0x3e	; 62
   137c2:	64 97       	sbiw	r28, 0x14	; 20
   137c4:	0f b6       	in	r0, 0x3f	; 63
   137c6:	f8 94       	cli
   137c8:	de bf       	out	0x3e, r29	; 62
   137ca:	0f be       	out	0x3f, r0	; 63
   137cc:	cd bf       	out	0x3d, r28	; 61
     char brMap,i=0,lcdteks[20];	 
	 int bValue;
	 lcd_printf(3, 1, PSTR("Initialize COM ..."));
   137ce:	83 e0       	ldi	r24, 0x03	; 3
   137d0:	61 e0       	ldi	r22, 0x01	; 1
   137d2:	4b ea       	ldi	r20, 0xAB	; 171
   137d4:	5c e1       	ldi	r21, 0x1C	; 28
   137d6:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
   137da:	01 e0       	ldi	r16, 0x01	; 1
   137dc:	10 e0       	ldi	r17, 0x00	; 0
     for(i=0;i<4;i++){
	     brMap=eeprom_read_byte(&DefBaudrate[i]);
		 bValue=GetBaudrate(brMap);
		 if (bValue==5787)bValue=12213;
		 sprintf_P(lcdteks,PSTR("COM%d:%i           "),i+1,bValue);
   137de:	6e 01       	movw	r12, r28
   137e0:	08 94       	sec
   137e2:	c1 1c       	adc	r12, r1
   137e4:	d1 1c       	adc	r13, r1
   137e6:	f7 e9       	ldi	r31, 0x97	; 151
   137e8:	af 2e       	mov	r10, r31
   137ea:	fc e1       	ldi	r31, 0x1C	; 28
   137ec:	bf 2e       	mov	r11, r31
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   137ee:	e1 99       	sbic	0x1c, 1	; 28
   137f0:	fe cf       	rjmp	.-4      	; 0x137ee <InitComport+0x42>
   137f2:	c8 01       	movw	r24, r16
   137f4:	81 5c       	subi	r24, 0xC1	; 193
   137f6:	9e 4f       	sbci	r25, 0xFE	; 254
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   137f8:	9f bb       	out	0x1f, r25	; 31
   137fa:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   137fc:	e0 9a       	sbi	0x1c, 0	; 28
   137fe:	fd b2       	in	r15, 0x1d	; 29
	 }
}

int GetBaudrate(char brSetting){
int Result=0;
     switch(brSetting){
   13800:	22 e0       	ldi	r18, 0x02	; 2
   13802:	f2 16       	cp	r15, r18
   13804:	71 f0       	breq	.+28     	; 0x13822 <InitComport+0x76>
   13806:	f2 16       	cp	r15, r18
   13808:	30 f0       	brcs	.+12     	; 0x13816 <InitComport+0x6a>
   1380a:	33 e0       	ldi	r19, 0x03	; 3
   1380c:	f3 16       	cp	r15, r19
   1380e:	31 f4       	brne	.+12     	; 0x1381c <InitComport+0x70>
   13810:	85 eb       	ldi	r24, 0xB5	; 181
   13812:	9f e2       	ldi	r25, 0x2F	; 47
   13814:	08 c0       	rjmp	.+16     	; 0x13826 <InitComport+0x7a>
   13816:	80 e8       	ldi	r24, 0x80	; 128
   13818:	95 e2       	ldi	r25, 0x25	; 37
   1381a:	05 c0       	rjmp	.+10     	; 0x13826 <InitComport+0x7a>
   1381c:	80 e0       	ldi	r24, 0x00	; 0
   1381e:	90 e0       	ldi	r25, 0x00	; 0
   13820:	02 c0       	rjmp	.+4      	; 0x13826 <InitComport+0x7a>
   13822:	80 e0       	ldi	r24, 0x00	; 0
   13824:	9b e4       	ldi	r25, 0x4B	; 75
	 lcd_printf(3, 1, PSTR("Initialize COM ..."));
     for(i=0;i<4;i++){
	     brMap=eeprom_read_byte(&DefBaudrate[i]);
		 bValue=GetBaudrate(brMap);
		 if (bValue==5787)bValue=12213;
		 sprintf_P(lcdteks,PSTR("COM%d:%i           "),i+1,bValue);
   13826:	ad b7       	in	r26, 0x3d	; 61
   13828:	be b7       	in	r27, 0x3e	; 62
   1382a:	18 97       	sbiw	r26, 0x08	; 8
   1382c:	0f b6       	in	r0, 0x3f	; 63
   1382e:	f8 94       	cli
   13830:	be bf       	out	0x3e, r27	; 62
   13832:	0f be       	out	0x3f, r0	; 63
   13834:	ad bf       	out	0x3d, r26	; 61
   13836:	ed b7       	in	r30, 0x3d	; 61
   13838:	fe b7       	in	r31, 0x3e	; 62
   1383a:	31 96       	adiw	r30, 0x01	; 1
   1383c:	12 96       	adiw	r26, 0x02	; 2
   1383e:	dc 92       	st	X, r13
   13840:	ce 92       	st	-X, r12
   13842:	11 97       	sbiw	r26, 0x01	; 1
   13844:	b3 82       	std	Z+3, r11	; 0x03
   13846:	a2 82       	std	Z+2, r10	; 0x02
   13848:	15 83       	std	Z+5, r17	; 0x05
   1384a:	04 83       	std	Z+4, r16	; 0x04
   1384c:	97 83       	std	Z+7, r25	; 0x07
   1384e:	86 83       	std	Z+6, r24	; 0x06
   13850:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
		 lcd_print(4,1,lcdteks);
   13854:	2d b7       	in	r18, 0x3d	; 61
   13856:	3e b7       	in	r19, 0x3e	; 62
   13858:	28 5f       	subi	r18, 0xF8	; 248
   1385a:	3f 4f       	sbci	r19, 0xFF	; 255
   1385c:	0f b6       	in	r0, 0x3f	; 63
   1385e:	f8 94       	cli
   13860:	3e bf       	out	0x3e, r19	; 62
   13862:	0f be       	out	0x3f, r0	; 63
   13864:	2d bf       	out	0x3d, r18	; 61
   13866:	84 e0       	ldi	r24, 0x04	; 4
   13868:	61 e0       	ldi	r22, 0x01	; 1
   1386a:	a6 01       	movw	r20, r12
   1386c:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
		 SetBaudRate(i+1,brMap);
   13870:	80 2f       	mov	r24, r16
   13872:	6f 2d       	mov	r22, r15
   13874:	0e 94 c2 98 	call	0x13184	; 0x13184 <SetBaudRate>
 	     TimDisplay=0;
   13878:	10 92 a7 01 	sts	0x01A7, r1
   1387c:	04 c0       	rjmp	.+8      	; 0x13886 <InitComport+0xda>
	     while(TimDisplay<2){
		     if (TimDisplay>2)break;
   1387e:	80 91 a7 01 	lds	r24, 0x01A7
   13882:	83 30       	cpi	r24, 0x03	; 3
   13884:	20 f4       	brcc	.+8      	; 0x1388e <InitComport+0xe2>
		 if (bValue==5787)bValue=12213;
		 sprintf_P(lcdteks,PSTR("COM%d:%i           "),i+1,bValue);
		 lcd_print(4,1,lcdteks);
		 SetBaudRate(i+1,brMap);
 	     TimDisplay=0;
	     while(TimDisplay<2){
   13886:	80 91 a7 01 	lds	r24, 0x01A7
   1388a:	82 30       	cpi	r24, 0x02	; 2
   1388c:	c0 f3       	brcs	.-16     	; 0x1387e <InitComport+0xd2>
   1388e:	0f 5f       	subi	r16, 0xFF	; 255
   13890:	1f 4f       	sbci	r17, 0xFF	; 255

void InitComport(){
     char brMap,i=0,lcdteks[20];	 
	 int bValue;
	 lcd_printf(3, 1, PSTR("Initialize COM ..."));
     for(i=0;i<4;i++){
   13892:	05 30       	cpi	r16, 0x05	; 5
   13894:	11 05       	cpc	r17, r1
   13896:	09 f0       	breq	.+2      	; 0x1389a <InitComport+0xee>
   13898:	aa cf       	rjmp	.-172    	; 0x137ee <InitComport+0x42>
	     while(TimDisplay<2){
		     if (TimDisplay>2)break;
		 };

	 }
}
   1389a:	64 96       	adiw	r28, 0x14	; 20
   1389c:	0f b6       	in	r0, 0x3f	; 63
   1389e:	f8 94       	cli
   138a0:	de bf       	out	0x3e, r29	; 62
   138a2:	0f be       	out	0x3f, r0	; 63
   138a4:	cd bf       	out	0x3d, r28	; 61
   138a6:	cf 91       	pop	r28
   138a8:	df 91       	pop	r29
   138aa:	1f 91       	pop	r17
   138ac:	0f 91       	pop	r16
   138ae:	ff 90       	pop	r15
   138b0:	df 90       	pop	r13
   138b2:	cf 90       	pop	r12
   138b4:	bf 90       	pop	r11
   138b6:	af 90       	pop	r10
   138b8:	08 95       	ret

000138ba <sendMessage56>:
    _uart_print(1, 0,strSend);
	_uart(1, 1,0x02);

}

void sendMessage56(){
   138ba:	0f 93       	push	r16
   138bc:	1f 93       	push	r17
   138be:	df 93       	push	r29
   138c0:	cf 93       	push	r28
   138c2:	cd b7       	in	r28, 0x3d	; 61
   138c4:	de b7       	in	r29, 0x3e	; 62
   138c6:	ec 97       	sbiw	r28, 0x3c	; 60
   138c8:	0f b6       	in	r0, 0x3f	; 63
   138ca:	f8 94       	cli
   138cc:	de bf       	out	0x3e, r29	; 62
   138ce:	0f be       	out	0x3f, r0	; 63
   138d0:	cd bf       	out	0x3d, r28	; 61
	char strSend[60];
	_uart(1, 1,0x01);
   138d2:	81 e0       	ldi	r24, 0x01	; 1
   138d4:	61 e0       	ldi	r22, 0x01	; 1
   138d6:	41 e0       	ldi	r20, 0x01	; 1
   138d8:	0e 94 d5 b3 	call	0x167aa	; 0x167aa <_uart>
	UpdateIFT_ID(); //ReadIFT_ID
   138dc:	0e 94 11 1c 	call	0x3822	; 0x3822 <UpdateIFT_ID>
	UpdateSeqNum(); //UpdateSeqNum SeqNum++
   138e0:	0e 94 e6 1b 	call	0x37cc	; 0x37cc <UpdateSeqNum>
	UpdateClientIP();//ReadSourceIP
   138e4:	0e 94 db 1f 	call	0x3fb6	; 0x3fb6 <UpdateClientIP>
	UpdateServerIP();//ReadDestIP
   138e8:	0e 94 73 1f 	call	0x3ee6	; 0x3ee6 <UpdateServerIP>
	UpdateCardID();  //ReadCardID
   138ec:	0e 94 55 40 	call	0x80aa	; 0x80aa <UpdateCardID>

	sprintf_P(strSend,PSTR("%s%s%s"),strIFT_ID,strSeqNum,strClientIP);
   138f0:	8d b7       	in	r24, 0x3d	; 61
   138f2:	9e b7       	in	r25, 0x3e	; 62
   138f4:	0a 97       	sbiw	r24, 0x0a	; 10
   138f6:	0f b6       	in	r0, 0x3f	; 63
   138f8:	f8 94       	cli
   138fa:	9e bf       	out	0x3e, r25	; 62
   138fc:	0f be       	out	0x3f, r0	; 63
   138fe:	8d bf       	out	0x3d, r24	; 61
   13900:	ed b7       	in	r30, 0x3d	; 61
   13902:	fe b7       	in	r31, 0x3e	; 62
   13904:	31 96       	adiw	r30, 0x01	; 1
   13906:	8e 01       	movw	r16, r28
   13908:	0f 5f       	subi	r16, 0xFF	; 255
   1390a:	1f 4f       	sbci	r17, 0xFF	; 255
   1390c:	ad b7       	in	r26, 0x3d	; 61
   1390e:	be b7       	in	r27, 0x3e	; 62
   13910:	12 96       	adiw	r26, 0x02	; 2
   13912:	1c 93       	st	X, r17
   13914:	0e 93       	st	-X, r16
   13916:	11 97       	sbiw	r26, 0x01	; 1
   13918:	89 e6       	ldi	r24, 0x69	; 105
   1391a:	91 e2       	ldi	r25, 0x21	; 33
   1391c:	93 83       	std	Z+3, r25	; 0x03
   1391e:	82 83       	std	Z+2, r24	; 0x02
   13920:	8c ec       	ldi	r24, 0xCC	; 204
   13922:	95 e0       	ldi	r25, 0x05	; 5
   13924:	95 83       	std	Z+5, r25	; 0x05
   13926:	84 83       	std	Z+4, r24	; 0x04
   13928:	8b ea       	ldi	r24, 0xAB	; 171
   1392a:	9d e0       	ldi	r25, 0x0D	; 13
   1392c:	97 83       	std	Z+7, r25	; 0x07
   1392e:	86 83       	std	Z+6, r24	; 0x06
   13930:	8e eb       	ldi	r24, 0xBE	; 190
   13932:	99 e0       	ldi	r25, 0x09	; 9
   13934:	91 87       	std	Z+9, r25	; 0x09
   13936:	80 87       	std	Z+8, r24	; 0x08
   13938:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    _uart_print(1, 0,strSend);
   1393c:	8d b7       	in	r24, 0x3d	; 61
   1393e:	9e b7       	in	r25, 0x3e	; 62
   13940:	0a 96       	adiw	r24, 0x0a	; 10
   13942:	0f b6       	in	r0, 0x3f	; 63
   13944:	f8 94       	cli
   13946:	9e bf       	out	0x3e, r25	; 62
   13948:	0f be       	out	0x3f, r0	; 63
   1394a:	8d bf       	out	0x3d, r24	; 61
   1394c:	81 e0       	ldi	r24, 0x01	; 1
   1394e:	60 e0       	ldi	r22, 0x00	; 0
   13950:	a8 01       	movw	r20, r16
   13952:	0e 94 f2 b3 	call	0x167e4	; 0x167e4 <_uart_print>
	sprintf_P(strSend,PSTR("%s56"),strServerIP);
   13956:	00 d0       	rcall	.+0      	; 0x13958 <sendMessage56+0x9e>
   13958:	00 d0       	rcall	.+0      	; 0x1395a <sendMessage56+0xa0>
   1395a:	00 d0       	rcall	.+0      	; 0x1395c <sendMessage56+0xa2>
   1395c:	ed b7       	in	r30, 0x3d	; 61
   1395e:	fe b7       	in	r31, 0x3e	; 62
   13960:	31 96       	adiw	r30, 0x01	; 1
   13962:	ad b7       	in	r26, 0x3d	; 61
   13964:	be b7       	in	r27, 0x3e	; 62
   13966:	12 96       	adiw	r26, 0x02	; 2
   13968:	1c 93       	st	X, r17
   1396a:	0e 93       	st	-X, r16
   1396c:	11 97       	sbiw	r26, 0x01	; 1
   1396e:	84 e6       	ldi	r24, 0x64	; 100
   13970:	91 e2       	ldi	r25, 0x21	; 33
   13972:	93 83       	std	Z+3, r25	; 0x03
   13974:	82 83       	std	Z+2, r24	; 0x02
   13976:	8b ee       	ldi	r24, 0xEB	; 235
   13978:	99 e0       	ldi	r25, 0x09	; 9
   1397a:	95 83       	std	Z+5, r25	; 0x05
   1397c:	84 83       	std	Z+4, r24	; 0x04
   1397e:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    _uart_print(1, 0,strSend);
   13982:	8d b7       	in	r24, 0x3d	; 61
   13984:	9e b7       	in	r25, 0x3e	; 62
   13986:	06 96       	adiw	r24, 0x06	; 6
   13988:	0f b6       	in	r0, 0x3f	; 63
   1398a:	f8 94       	cli
   1398c:	9e bf       	out	0x3e, r25	; 62
   1398e:	0f be       	out	0x3f, r0	; 63
   13990:	8d bf       	out	0x3d, r24	; 61
   13992:	81 e0       	ldi	r24, 0x01	; 1
   13994:	60 e0       	ldi	r22, 0x00	; 0
   13996:	a8 01       	movw	r20, r16
   13998:	0e 94 f2 b3 	call	0x167e4	; 0x167e4 <_uart_print>
    sprintf_P(strSend,PSTR("%s"),strCardID);
   1399c:	00 d0       	rcall	.+0      	; 0x1399e <sendMessage56+0xe4>
   1399e:	00 d0       	rcall	.+0      	; 0x139a0 <sendMessage56+0xe6>
   139a0:	00 d0       	rcall	.+0      	; 0x139a2 <sendMessage56+0xe8>
   139a2:	ed b7       	in	r30, 0x3d	; 61
   139a4:	fe b7       	in	r31, 0x3e	; 62
   139a6:	31 96       	adiw	r30, 0x01	; 1
   139a8:	ad b7       	in	r26, 0x3d	; 61
   139aa:	be b7       	in	r27, 0x3e	; 62
   139ac:	12 96       	adiw	r26, 0x02	; 2
   139ae:	1c 93       	st	X, r17
   139b0:	0e 93       	st	-X, r16
   139b2:	11 97       	sbiw	r26, 0x01	; 1
   139b4:	81 e6       	ldi	r24, 0x61	; 97
   139b6:	91 e2       	ldi	r25, 0x21	; 33
   139b8:	93 83       	std	Z+3, r25	; 0x03
   139ba:	82 83       	std	Z+2, r24	; 0x02
   139bc:	81 e6       	ldi	r24, 0x61	; 97
   139be:	9d e0       	ldi	r25, 0x0D	; 13
   139c0:	95 83       	std	Z+5, r25	; 0x05
   139c2:	84 83       	std	Z+4, r24	; 0x04
   139c4:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
    _uart_print(1, 0,strSend);	
   139c8:	8d b7       	in	r24, 0x3d	; 61
   139ca:	9e b7       	in	r25, 0x3e	; 62
   139cc:	06 96       	adiw	r24, 0x06	; 6
   139ce:	0f b6       	in	r0, 0x3f	; 63
   139d0:	f8 94       	cli
   139d2:	9e bf       	out	0x3e, r25	; 62
   139d4:	0f be       	out	0x3f, r0	; 63
   139d6:	8d bf       	out	0x3d, r24	; 61
   139d8:	81 e0       	ldi	r24, 0x01	; 1
   139da:	60 e0       	ldi	r22, 0x00	; 0
   139dc:	a8 01       	movw	r20, r16
   139de:	0e 94 f2 b3 	call	0x167e4	; 0x167e4 <_uart_print>

	_uart_printf(1,0,PSTR("AF968CFFB"));
   139e2:	81 e0       	ldi	r24, 0x01	; 1
   139e4:	60 e0       	ldi	r22, 0x00	; 0
   139e6:	47 e5       	ldi	r20, 0x57	; 87
   139e8:	51 e2       	ldi	r21, 0x21	; 33
   139ea:	0e 94 1a b4 	call	0x16834	; 0x16834 <_uart_printf>
	_uart(1, 1,0x02);
   139ee:	81 e0       	ldi	r24, 0x01	; 1
   139f0:	61 e0       	ldi	r22, 0x01	; 1
   139f2:	42 e0       	ldi	r20, 0x02	; 2
   139f4:	0e 94 d5 b3 	call	0x167aa	; 0x167aa <_uart>
}
   139f8:	ec 96       	adiw	r28, 0x3c	; 60
   139fa:	0f b6       	in	r0, 0x3f	; 63
   139fc:	f8 94       	cli
   139fe:	de bf       	out	0x3e, r29	; 62
   13a00:	0f be       	out	0x3f, r0	; 63
   13a02:	cd bf       	out	0x3d, r28	; 61
   13a04:	cf 91       	pop	r28
   13a06:	df 91       	pop	r29
   13a08:	1f 91       	pop	r17
   13a0a:	0f 91       	pop	r16
   13a0c:	08 95       	ret

00013a0e <FMenuLocalAccount>:
		 }
	 else PORTG=PORTG|0x02;
}


char FMenuLocalAccount(){
   13a0e:	af 92       	push	r10
   13a10:	bf 92       	push	r11
   13a12:	cf 92       	push	r12
   13a14:	df 92       	push	r13
   13a16:	ef 92       	push	r14
   13a18:	ff 92       	push	r15
   13a1a:	0f 93       	push	r16
   13a1c:	1f 93       	push	r17
   13a1e:	df 93       	push	r29
   13a20:	cf 93       	push	r28
   13a22:	cd b7       	in	r28, 0x3d	; 61
   13a24:	de b7       	in	r29, 0x3e	; 62
   13a26:	a9 97       	sbiw	r28, 0x29	; 41
   13a28:	0f b6       	in	r0, 0x3f	; 63
   13a2a:	f8 94       	cli
   13a2c:	de bf       	out	0x3e, r29	; 62
   13a2e:	0f be       	out	0x3f, r0	; 63
   13a30:	cd bf       	out	0x3d, r28	; 61
       char strName[21];//,strPumpL[3],strPumpR[3];
       char Result;

	   Result=MENU_NONE;
	                                 //|   Local Account   |          
	       switch(stLocalAccount){   //|ID: ACD12345       |
   13a32:	80 91 5c 01 	lds	r24, 0x015C
   13a36:	90 e0       	ldi	r25, 0x00	; 0
   13a38:	fc 01       	movw	r30, r24
   13a3a:	31 97       	sbiw	r30, 0x01	; 1
   13a3c:	ef 31       	cpi	r30, 0x1F	; 31
   13a3e:	f1 05       	cpc	r31, r1
   13a40:	10 f0       	brcs	.+4      	; 0x13a46 <FMenuLocalAccount+0x38>
   13a42:	0c 94 33 a7 	jmp	0x14e66	; 0x14e66 <FMenuLocalAccount+0x1458>
   13a46:	eb 50       	subi	r30, 0x0B	; 11
   13a48:	ff 4f       	sbci	r31, 0xFF	; 255
   13a4a:	ee 0f       	add	r30, r30
   13a4c:	ff 1f       	adc	r31, r31
   13a4e:	05 90       	lpm	r0, Z+
   13a50:	f4 91       	lpm	r31, Z+
   13a52:	e0 2d       	mov	r30, r0
   13a54:	09 94       	ijmp
     }      
}

void BackLightTrig(){
     //TimBackLight=0;
__key_light = 1; __key_lgtcnt = 0; PORTG=PORTG&0b11111101;
   13a56:	81 e0       	ldi	r24, 0x01	; 1
   13a58:	80 93 bf 03 	sts	0x03BF, r24
   13a5c:	10 92 c0 03 	sts	0x03C0, r1
   13a60:	80 91 65 00 	lds	r24, 0x0065
   13a64:	8d 7f       	andi	r24, 0xFD	; 253
   13a66:	80 93 65 00 	sts	0x0065, r24
   13a6a:	20 e0       	ldi	r18, 0x00	; 0
   13a6c:	30 e0       	ldi	r19, 0x00	; 0
}

void ViewCardID(){//+12345678 -->12345678
     char i;
	 for(i=0;i<8;i++){         //00000000000012345678
		strCardID[i]=strRFID[i];
   13a6e:	f9 01       	movw	r30, r18
   13a70:	ef 59       	subi	r30, 0x9F	; 159
   13a72:	f2 4f       	sbci	r31, 0xF2	; 242
   13a74:	d9 01       	movw	r26, r18
   13a76:	a4 5d       	subi	r26, 0xD4	; 212
   13a78:	b1 4f       	sbci	r27, 0xF1	; 241
   13a7a:	8c 91       	ld	r24, X
   13a7c:	80 83       	st	Z, r24
   13a7e:	2f 5f       	subi	r18, 0xFF	; 255
   13a80:	3f 4f       	sbci	r19, 0xFF	; 255

}

void ViewCardID(){//+12345678 -->12345678
     char i;
	 for(i=0;i<8;i++){         //00000000000012345678
   13a82:	28 30       	cpi	r18, 0x08	; 8
   13a84:	31 05       	cpc	r19, r1
   13a86:	99 f7       	brne	.-26     	; 0x13a6e <FMenuLocalAccount+0x60>
		strCardID[i]=strRFID[i];
	 }strCardID[8]=0;     
   13a88:	10 92 69 0d 	sts	0x0D69, r1
	       switch(stLocalAccount){   //|ID: ACD12345       |
	       case laInit:              //|Process ...        |
		        //Process RFID Data  //|                   |
				//UpdateCardID();
                BackLightTrig();ViewCardID();
	            lcd_clear();
   13a8c:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
	            lcd_printf(1,1,PSTR("   Local Account   "));
   13a90:	81 e0       	ldi	r24, 0x01	; 1
   13a92:	61 e0       	ldi	r22, 0x01	; 1
   13a94:	41 eb       	ldi	r20, 0xB1	; 177
   13a96:	50 e2       	ldi	r21, 0x20	; 32
   13a98:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
	            sprintf_P(lcdteks,PSTR("ID:%s"),strCardID);lcd_print(2,1,lcdteks);
   13a9c:	00 d0       	rcall	.+0      	; 0x13a9e <FMenuLocalAccount+0x90>
   13a9e:	00 d0       	rcall	.+0      	; 0x13aa0 <FMenuLocalAccount+0x92>
   13aa0:	00 d0       	rcall	.+0      	; 0x13aa2 <FMenuLocalAccount+0x94>
   13aa2:	ed b7       	in	r30, 0x3d	; 61
   13aa4:	fe b7       	in	r31, 0x3e	; 62
   13aa6:	31 96       	adiw	r30, 0x01	; 1
   13aa8:	8e 01       	movw	r16, r28
   13aaa:	0f 5f       	subi	r16, 0xFF	; 255
   13aac:	1f 4f       	sbci	r17, 0xFF	; 255
   13aae:	ad b7       	in	r26, 0x3d	; 61
   13ab0:	be b7       	in	r27, 0x3e	; 62
   13ab2:	12 96       	adiw	r26, 0x02	; 2
   13ab4:	1c 93       	st	X, r17
   13ab6:	0e 93       	st	-X, r16
   13ab8:	11 97       	sbiw	r26, 0x01	; 1
   13aba:	8b ea       	ldi	r24, 0xAB	; 171
   13abc:	90 e2       	ldi	r25, 0x20	; 32
   13abe:	93 83       	std	Z+3, r25	; 0x03
   13ac0:	82 83       	std	Z+2, r24	; 0x02
   13ac2:	81 e6       	ldi	r24, 0x61	; 97
   13ac4:	9d e0       	ldi	r25, 0x0D	; 13
   13ac6:	95 83       	std	Z+5, r25	; 0x05
   13ac8:	84 83       	std	Z+4, r24	; 0x04
   13aca:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
   13ace:	ed b7       	in	r30, 0x3d	; 61
   13ad0:	fe b7       	in	r31, 0x3e	; 62
   13ad2:	36 96       	adiw	r30, 0x06	; 6
   13ad4:	0f b6       	in	r0, 0x3f	; 63
   13ad6:	f8 94       	cli
   13ad8:	fe bf       	out	0x3e, r31	; 62
   13ada:	0f be       	out	0x3f, r0	; 63
   13adc:	ed bf       	out	0x3d, r30	; 61
   13ade:	82 e0       	ldi	r24, 0x02	; 2
   13ae0:	61 e0       	ldi	r22, 0x01	; 1
   13ae2:	a8 01       	movw	r20, r16
   13ae4:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
                lcd_printf(3,1,PSTR("Proses"));
   13ae8:	83 e0       	ldi	r24, 0x03	; 3
   13aea:	61 e0       	ldi	r22, 0x01	; 1
   13aec:	44 ea       	ldi	r20, 0xA4	; 164
   13aee:	50 e2       	ldi	r21, 0x20	; 32
   13af0:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
				iPos=0;iLoop=0;
   13af4:	10 92 a3 03 	sts	0x03A3, r1
   13af8:	10 92 73 03 	sts	0x0373, r1
   13afc:	10 92 72 03 	sts	0x0372, r1
				IsFullAuthorized=False;
   13b00:	10 92 74 03 	sts	0x0374, r1
		        stLocalAccount=laSendID;
   13b04:	82 e0       	ldi	r24, 0x02	; 2
   13b06:	dc c6       	rjmp	.+3512   	; 0x148c0 <FMenuLocalAccount+0xeb2>
				break;         
           case laSendID://sendMessage56 
				IsMessage57=False;
   13b08:	10 92 bc 01 	sts	0x01BC, r1
                sendMessage56();
   13b0c:	0e 94 5d 9c 	call	0x138ba	; 0x138ba <sendMessage56>
				iWait=0;iLoop=0;iPos=0;
   13b10:	10 92 a2 03 	sts	0x03A2, r1
   13b14:	10 92 73 03 	sts	0x0373, r1
   13b18:	10 92 72 03 	sts	0x0372, r1
   13b1c:	10 92 a3 03 	sts	0x03A3, r1
				stLocalAccount=laWaitMessage57;
   13b20:	83 e0       	ldi	r24, 0x03	; 3
   13b22:	ce c6       	rjmp	.+3484   	; 0x148c0 <FMenuLocalAccount+0xeb2>
		        break;
           case laWaitMessage57:
		        iLoop++;
   13b24:	80 91 72 03 	lds	r24, 0x0372
   13b28:	90 91 73 03 	lds	r25, 0x0373
   13b2c:	01 96       	adiw	r24, 0x01	; 1
   13b2e:	90 93 73 03 	sts	0x0373, r25
   13b32:	80 93 72 03 	sts	0x0372, r24
				if ((iLoop%MSG_WAIT_TIMOUT)==0){
   13b36:	68 e9       	ldi	r22, 0x98	; 152
   13b38:	7a e3       	ldi	r23, 0x3A	; 58
   13b3a:	0e 94 93 b8 	call	0x17126	; 0x17126 <__udivmodhi4>
   13b3e:	89 2b       	or	r24, r25
   13b40:	e1 f4       	brne	.+56     	; 0x13b7a <FMenuLocalAccount+0x16c>
				   if (iPos<5){
   13b42:	60 91 a3 03 	lds	r22, 0x03A3
   13b46:	65 30       	cpi	r22, 0x05	; 5
   13b48:	58 f4       	brcc	.+22     	; 0x13b60 <FMenuLocalAccount+0x152>
					   lcd_put(3,(8+iPos),'.');
   13b4a:	68 5f       	subi	r22, 0xF8	; 248
   13b4c:	83 e0       	ldi	r24, 0x03	; 3
   13b4e:	4e e2       	ldi	r20, 0x2E	; 46
   13b50:	0e 94 da ae 	call	0x15db4	; 0x15db4 <lcd_put>
				       iPos++;
   13b54:	80 91 a3 03 	lds	r24, 0x03A3
   13b58:	8f 5f       	subi	r24, 0xFF	; 255
   13b5a:	80 93 a3 03 	sts	0x03A3, r24
   13b5e:	0d c0       	rjmp	.+26     	; 0x13b7a <FMenuLocalAccount+0x16c>
					   }
				   else{
				       iPos=0;
   13b60:	10 92 a3 03 	sts	0x03A3, r1
					   lcd_printf(3,(9+iPos),PSTR("       "));
   13b64:	83 e0       	ldi	r24, 0x03	; 3
   13b66:	69 e0       	ldi	r22, 0x09	; 9
   13b68:	4c e9       	ldi	r20, 0x9C	; 156
   13b6a:	50 e2       	ldi	r21, 0x20	; 32
   13b6c:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
					   iWait++;
   13b70:	80 91 a2 03 	lds	r24, 0x03A2
   13b74:	8f 5f       	subi	r24, 0xFF	; 255
   13b76:	80 93 a2 03 	sts	0x03A2, r24
					   }
				}
				if (iWait>3){
   13b7a:	80 91 a2 03 	lds	r24, 0x03A2
   13b7e:	84 30       	cpi	r24, 0x04	; 4
   13b80:	78 f0       	brcs	.+30     	; 0x13ba0 <FMenuLocalAccount+0x192>
				    stLocalAccount=laConTimout;
   13b82:	84 e0       	ldi	r24, 0x04	; 4
   13b84:	80 93 5c 01 	sts	0x015C, r24
					TimLocAcc=0;
   13b88:	10 92 d3 01 	sts	0x01D3, r1
   13b8c:	10 92 d2 01 	sts	0x01D2, r1
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   13b90:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   13b92:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   13b94:	82 e0       	ldi	r24, 0x02	; 2
   13b96:	90 e0       	ldi	r25, 0x00	; 0
   13b98:	90 93 d7 01 	sts	0x01D7, r25
   13b9c:	80 93 d6 01 	sts	0x01D6, r24
				if (iWait>3){
				    stLocalAccount=laConTimout;
					TimLocAcc=0;
					system_beep(2);
				    }
				if (IsMessage57==True){
   13ba0:	80 91 bc 01 	lds	r24, 0x01BC
   13ba4:	81 30       	cpi	r24, 0x01	; 1
   13ba6:	11 f0       	breq	.+4      	; 0x13bac <FMenuLocalAccount+0x19e>
   13ba8:	0c 94 33 a7 	jmp	0x14e66	; 0x14e66 <FMenuLocalAccount+0x1458>
				    IsMessage57=False;
   13bac:	10 92 bc 01 	sts	0x01BC, r1
				    stLocalAccount=laProcMessage57;
   13bb0:	85 e0       	ldi	r24, 0x05	; 5
   13bb2:	86 c6       	rjmp	.+3340   	; 0x148c0 <FMenuLocalAccount+0xeb2>
					}
		        break;
           case laConTimout:
		        //IsErrorTCPIP=True;
				lcd_printf(3,1,PSTR("Sending Failed      "));
   13bb4:	83 e0       	ldi	r24, 0x03	; 3
   13bb6:	61 e0       	ldi	r22, 0x01	; 1
   13bb8:	47 e8       	ldi	r20, 0x87	; 135
   13bba:	50 e2       	ldi	r21, 0x20	; 32
   13bbc:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
				lcd_printf(4,1,PSTR("TCP/IP Error        "));
   13bc0:	84 e0       	ldi	r24, 0x04	; 4
   13bc2:	61 e0       	ldi	r22, 0x01	; 1
   13bc4:	42 e7       	ldi	r20, 0x72	; 114
   13bc6:	50 e2       	ldi	r21, 0x20	; 32
   13bc8:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
                if (TimLocAcc>2)  stLocalAccount=laExitLocAcc;
   13bcc:	80 91 d2 01 	lds	r24, 0x01D2
   13bd0:	90 91 d3 01 	lds	r25, 0x01D3
   13bd4:	03 97       	sbiw	r24, 0x03	; 3
   13bd6:	10 f4       	brcc	.+4      	; 0x13bdc <FMenuLocalAccount+0x1ce>
   13bd8:	0c 94 33 a7 	jmp	0x14e66	; 0x14e66 <FMenuLocalAccount+0x1458>
   13bdc:	0c 94 2a a7 	jmp	0x14e54	; 0x14e54 <FMenuLocalAccount+0x1446>
		        break;
           case laProcMessage57://Process Message
				lcd_printf(3,1,PSTR("Data Received       "));
   13be0:	83 e0       	ldi	r24, 0x03	; 3
   13be2:	61 e0       	ldi	r22, 0x01	; 1
   13be4:	4d e5       	ldi	r20, 0x5D	; 93
   13be6:	50 e2       	ldi	r21, 0x20	; 32
   13be8:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
				LocAccStatus=GetLocAccStatus(procMessage57());
   13bec:	0e 94 96 26 	call	0x4d2c	; 0x4d2c <procMessage57>


char GetLocAccStatus(char paramMessage57){
     char Result;
	 Result=LA_NONE;
     if (paramMessage57==MSG57_INVALID)Result=LA_INVALID;
   13bf0:	81 30       	cpi	r24, 0x01	; 1
   13bf2:	29 f0       	breq	.+10     	; 0x13bfe <FMenuLocalAccount+0x1f0>
	 else
     if (paramMessage57==MSG57_VALID)Result=LA_VALID;
   13bf4:	82 30       	cpi	r24, 0x02	; 2
   13bf6:	19 f0       	breq	.+6      	; 0x13bfe <FMenuLocalAccount+0x1f0>
	 else
     if (paramMessage57==MSG57_LIMITED)Result=LA_LIMITED;
   13bf8:	83 30       	cpi	r24, 0x03	; 3
   13bfa:	09 f0       	breq	.+2      	; 0x13bfe <FMenuLocalAccount+0x1f0>
   13bfc:	80 e0       	ldi	r24, 0x00	; 0
				lcd_printf(4,1,PSTR("TCP/IP Error        "));
                if (TimLocAcc>2)  stLocalAccount=laExitLocAcc;
		        break;
           case laProcMessage57://Process Message
				lcd_printf(3,1,PSTR("Data Received       "));
				LocAccStatus=GetLocAccStatus(procMessage57());
   13bfe:	80 93 a4 03 	sts	0x03A4, r24
				TimLocAcc=0;
   13c02:	10 92 d3 01 	sts	0x01D3, r1
   13c06:	10 92 d2 01 	sts	0x01D2, r1
				stLocalAccount=laDispStatus;
   13c0a:	86 e0       	ldi	r24, 0x06	; 6
   13c0c:	59 c6       	rjmp	.+3250   	; 0x148c0 <FMenuLocalAccount+0xeb2>
		        break;
           case laDispStatus://Display Status
		        if (LocAccStatus==LA_INVALID){
   13c0e:	80 91 a4 03 	lds	r24, 0x03A4
   13c12:	81 30       	cpi	r24, 0x01	; 1
   13c14:	29 f4       	brne	.+10     	; 0x13c20 <FMenuLocalAccount+0x212>
					lcd_printf(3,1,PSTR("Tidak Terdaftar     "));    
   13c16:	83 e0       	ldi	r24, 0x03	; 3
   13c18:	61 e0       	ldi	r22, 0x01	; 1
   13c1a:	48 e4       	ldi	r20, 0x48	; 72
   13c1c:	50 e2       	ldi	r21, 0x20	; 32
   13c1e:	0d c0       	rjmp	.+26     	; 0x13c3a <FMenuLocalAccount+0x22c>
					TimLocAcc=0;
				    stLocalAccount=laDelayExit;
				}
				else
                if (LocAccStatus==LA_VALID) {
   13c20:	82 30       	cpi	r24, 0x02	; 2
   13c22:	31 f4       	brne	.+12     	; 0x13c30 <FMenuLocalAccount+0x222>
				    stLocalAccount=laDispValid; 
   13c24:	87 e0       	ldi	r24, 0x07	; 7
   13c26:	80 93 5c 01 	sts	0x015C, r24
					lcd_clear();
   13c2a:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
   13c2e:	0e c0       	rjmp	.+28     	; 0x13c4c <FMenuLocalAccount+0x23e>
					}
				else
                if (LocAccStatus==LA_LIMITED){
   13c30:	83 30       	cpi	r24, 0x03	; 3
   13c32:	61 f4       	brne	.+24     	; 0x13c4c <FMenuLocalAccount+0x23e>
					lcd_printf(3,1,PSTR("Kartu Terbatas      "));    
   13c34:	61 e0       	ldi	r22, 0x01	; 1
   13c36:	43 e3       	ldi	r20, 0x33	; 51
   13c38:	50 e2       	ldi	r21, 0x20	; 32
   13c3a:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
					TimLocAcc=0;
   13c3e:	10 92 d3 01 	sts	0x01D3, r1
   13c42:	10 92 d2 01 	sts	0x01D2, r1
				    stLocalAccount=laDelayExit;
   13c46:	8e e1       	ldi	r24, 0x1E	; 30
   13c48:	80 93 5c 01 	sts	0x015C, r24
				}
                if (TimLocAcc>5)stLocalAccount=laExitLocAcc;
   13c4c:	80 91 d2 01 	lds	r24, 0x01D2
   13c50:	90 91 d3 01 	lds	r25, 0x01D3
   13c54:	06 97       	sbiw	r24, 0x06	; 6
   13c56:	10 f4       	brcc	.+4      	; 0x13c5c <FMenuLocalAccount+0x24e>
   13c58:	0c 94 33 a7 	jmp	0x14e66	; 0x14e66 <FMenuLocalAccount+0x1458>
   13c5c:	0c 94 2a a7 	jmp	0x14e54	; 0x14e54 <FMenuLocalAccount+0x1446>
		        break;
           case laDispValid://Display VALID ID
		        lcd_clear();
   13c60:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
				sprintf_P(strBalanceValue,PSTR("%s"),strBalance);
   13c64:	00 d0       	rcall	.+0      	; 0x13c66 <FMenuLocalAccount+0x258>
   13c66:	00 d0       	rcall	.+0      	; 0x13c68 <FMenuLocalAccount+0x25a>
   13c68:	00 d0       	rcall	.+0      	; 0x13c6a <FMenuLocalAccount+0x25c>
   13c6a:	ed b7       	in	r30, 0x3d	; 61
   13c6c:	fe b7       	in	r31, 0x3e	; 62
   13c6e:	31 96       	adiw	r30, 0x01	; 1
   13c70:	8a ef       	ldi	r24, 0xFA	; 250
   13c72:	9d e0       	ldi	r25, 0x0D	; 13
   13c74:	ad b7       	in	r26, 0x3d	; 61
   13c76:	be b7       	in	r27, 0x3e	; 62
   13c78:	12 96       	adiw	r26, 0x02	; 2
   13c7a:	9c 93       	st	X, r25
   13c7c:	8e 93       	st	-X, r24
   13c7e:	11 97       	sbiw	r26, 0x01	; 1
   13c80:	80 e3       	ldi	r24, 0x30	; 48
   13c82:	90 e2       	ldi	r25, 0x20	; 32
   13c84:	93 83       	std	Z+3, r25	; 0x03
   13c86:	82 83       	std	Z+2, r24	; 0x02
   13c88:	03 ed       	ldi	r16, 0xD3	; 211
   13c8a:	1d e0       	ldi	r17, 0x0D	; 13
   13c8c:	15 83       	std	Z+5, r17	; 0x05
   13c8e:	04 83       	std	Z+4, r16	; 0x04
   13c90:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
				FormatCurrency(strBalance);
   13c94:	ed b7       	in	r30, 0x3d	; 61
   13c96:	fe b7       	in	r31, 0x3e	; 62
   13c98:	36 96       	adiw	r30, 0x06	; 6
   13c9a:	0f b6       	in	r0, 0x3f	; 63
   13c9c:	f8 94       	cli
   13c9e:	fe bf       	out	0x3e, r31	; 62
   13ca0:	0f be       	out	0x3f, r0	; 63
   13ca2:	ed bf       	out	0x3d, r30	; 61
   13ca4:	c8 01       	movw	r24, r16
   13ca6:	0e 94 b1 33 	call	0x6762	; 0x6762 <FormatCurrency>
   13caa:	20 e0       	ldi	r18, 0x00	; 0
   13cac:	30 e0       	ldi	r19, 0x00	; 0


void StringCopy(char *Source,char *Dest,char Length){
     char i;
	 for (i=0;i<Length;i++){
	     Dest[i]=Source[i];
   13cae:	65 e1       	ldi	r22, 0x15	; 21
   13cb0:	e6 2e       	mov	r14, r22
   13cb2:	f1 2c       	mov	r15, r1
   13cb4:	ec 0e       	add	r14, r28
   13cb6:	fd 1e       	adc	r15, r29
   13cb8:	f7 01       	movw	r30, r14
   13cba:	e2 0f       	add	r30, r18
   13cbc:	f3 1f       	adc	r31, r19
   13cbe:	d9 01       	movw	r26, r18
   13cc0:	ac 5f       	subi	r26, 0xFC	; 252
   13cc2:	ba 4f       	sbci	r27, 0xFA	; 250
   13cc4:	8c 91       	ld	r24, X
   13cc6:	80 83       	st	Z, r24
   13cc8:	2f 5f       	subi	r18, 0xFF	; 255
   13cca:	3f 4f       	sbci	r19, 0xFF	; 255
//Message 56


void StringCopy(char *Source,char *Dest,char Length){
     char i;
	 for (i=0;i<Length;i++){
   13ccc:	24 31       	cpi	r18, 0x14	; 20
   13cce:	31 05       	cpc	r19, r1
   13cd0:	99 f7       	brne	.-26     	; 0x13cb8 <FMenuLocalAccount+0x2aa>
	     Dest[i]=Source[i];
	 }Dest[Length]=0;
   13cd2:	19 a6       	std	Y+41, r1	; 0x29
		        lcd_clear();
				sprintf_P(strBalanceValue,PSTR("%s"),strBalance);
				FormatCurrency(strBalance);

		        StringCopy(strCardHolder,strName,20);  				                                                        
		        sprintf_P(lcdteks,PSTR("%s"),strCompName);               lcd_print(1,1,lcdteks);   //[CompName]
   13cd4:	00 d0       	rcall	.+0      	; 0x13cd6 <FMenuLocalAccount+0x2c8>
   13cd6:	00 d0       	rcall	.+0      	; 0x13cd8 <FMenuLocalAccount+0x2ca>
   13cd8:	00 d0       	rcall	.+0      	; 0x13cda <FMenuLocalAccount+0x2cc>
   13cda:	ed b7       	in	r30, 0x3d	; 61
   13cdc:	fe b7       	in	r31, 0x3e	; 62
   13cde:	31 96       	adiw	r30, 0x01	; 1
   13ce0:	8e 01       	movw	r16, r28
   13ce2:	0f 5f       	subi	r16, 0xFF	; 255
   13ce4:	1f 4f       	sbci	r17, 0xFF	; 255
   13ce6:	ad b7       	in	r26, 0x3d	; 61
   13ce8:	be b7       	in	r27, 0x3e	; 62
   13cea:	12 96       	adiw	r26, 0x02	; 2
   13cec:	1c 93       	st	X, r17
   13cee:	0e 93       	st	-X, r16
   13cf0:	11 97       	sbiw	r26, 0x01	; 1
   13cf2:	8d e2       	ldi	r24, 0x2D	; 45
   13cf4:	90 e2       	ldi	r25, 0x20	; 32
   13cf6:	93 83       	std	Z+3, r25	; 0x03
   13cf8:	82 83       	std	Z+2, r24	; 0x02
   13cfa:	8c e5       	ldi	r24, 0x5C	; 92
   13cfc:	99 e0       	ldi	r25, 0x09	; 9
   13cfe:	95 83       	std	Z+5, r25	; 0x05
   13d00:	84 83       	std	Z+4, r24	; 0x04
   13d02:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
   13d06:	ed b7       	in	r30, 0x3d	; 61
   13d08:	fe b7       	in	r31, 0x3e	; 62
   13d0a:	36 96       	adiw	r30, 0x06	; 6
   13d0c:	0f b6       	in	r0, 0x3f	; 63
   13d0e:	f8 94       	cli
   13d10:	fe bf       	out	0x3e, r31	; 62
   13d12:	0f be       	out	0x3f, r0	; 63
   13d14:	ed bf       	out	0x3d, r30	; 61
   13d16:	81 e0       	ldi	r24, 0x01	; 1
   13d18:	61 e0       	ldi	r22, 0x01	; 1
   13d1a:	a8 01       	movw	r20, r16
   13d1c:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
                //sprintf(lcdteks,"%s %s",strCardID,strName);    lcd_print(2,1,lcdteks);   //[Card ID][Card Holder]
				sprintf_P(lcdteks,PSTR("%s"),strName);                   lcd_print(2,1,lcdteks);   //[Card ID][Card Holder]
   13d20:	00 d0       	rcall	.+0      	; 0x13d22 <FMenuLocalAccount+0x314>
   13d22:	00 d0       	rcall	.+0      	; 0x13d24 <FMenuLocalAccount+0x316>
   13d24:	00 d0       	rcall	.+0      	; 0x13d26 <FMenuLocalAccount+0x318>
   13d26:	ed b7       	in	r30, 0x3d	; 61
   13d28:	fe b7       	in	r31, 0x3e	; 62
   13d2a:	31 96       	adiw	r30, 0x01	; 1
   13d2c:	ad b7       	in	r26, 0x3d	; 61
   13d2e:	be b7       	in	r27, 0x3e	; 62
   13d30:	12 96       	adiw	r26, 0x02	; 2
   13d32:	1c 93       	st	X, r17
   13d34:	0e 93       	st	-X, r16
   13d36:	11 97       	sbiw	r26, 0x01	; 1
   13d38:	8a e2       	ldi	r24, 0x2A	; 42
   13d3a:	90 e2       	ldi	r25, 0x20	; 32
   13d3c:	93 83       	std	Z+3, r25	; 0x03
   13d3e:	82 83       	std	Z+2, r24	; 0x02
   13d40:	f5 82       	std	Z+5, r15	; 0x05
   13d42:	e4 82       	std	Z+4, r14	; 0x04
   13d44:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
   13d48:	ed b7       	in	r30, 0x3d	; 61
   13d4a:	fe b7       	in	r31, 0x3e	; 62
   13d4c:	36 96       	adiw	r30, 0x06	; 6
   13d4e:	0f b6       	in	r0, 0x3f	; 63
   13d50:	f8 94       	cli
   13d52:	fe bf       	out	0x3e, r31	; 62
   13d54:	0f be       	out	0x3f, r0	; 63
   13d56:	ed bf       	out	0x3d, r30	; 61
   13d58:	82 e0       	ldi	r24, 0x02	; 2
   13d5a:	61 e0       	ldi	r22, 0x01	; 1
   13d5c:	a8 01       	movw	r20, r16
   13d5e:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
				sprintf_P(lcdteks,PSTR("%s %s"),strLicPlate,strBalance); lcd_print(3,1,lcdteks);   //[LicPlate][Balance] 
   13d62:	2d b7       	in	r18, 0x3d	; 61
   13d64:	3e b7       	in	r19, 0x3e	; 62
   13d66:	28 50       	subi	r18, 0x08	; 8
   13d68:	30 40       	sbci	r19, 0x00	; 0
   13d6a:	0f b6       	in	r0, 0x3f	; 63
   13d6c:	f8 94       	cli
   13d6e:	3e bf       	out	0x3e, r19	; 62
   13d70:	0f be       	out	0x3f, r0	; 63
   13d72:	2d bf       	out	0x3d, r18	; 61
   13d74:	ed b7       	in	r30, 0x3d	; 61
   13d76:	fe b7       	in	r31, 0x3e	; 62
   13d78:	31 96       	adiw	r30, 0x01	; 1
   13d7a:	ad b7       	in	r26, 0x3d	; 61
   13d7c:	be b7       	in	r27, 0x3e	; 62
   13d7e:	12 96       	adiw	r26, 0x02	; 2
   13d80:	1c 93       	st	X, r17
   13d82:	0e 93       	st	-X, r16
   13d84:	11 97       	sbiw	r26, 0x01	; 1
   13d86:	84 e2       	ldi	r24, 0x24	; 36
   13d88:	90 e2       	ldi	r25, 0x20	; 32
   13d8a:	93 83       	std	Z+3, r25	; 0x03
   13d8c:	82 83       	std	Z+2, r24	; 0x02
   13d8e:	82 ed       	ldi	r24, 0xD2	; 210
   13d90:	9a e0       	ldi	r25, 0x0A	; 10
   13d92:	95 83       	std	Z+5, r25	; 0x05
   13d94:	84 83       	std	Z+4, r24	; 0x04
   13d96:	83 ed       	ldi	r24, 0xD3	; 211
   13d98:	9d e0       	ldi	r25, 0x0D	; 13
   13d9a:	97 83       	std	Z+7, r25	; 0x07
   13d9c:	86 83       	std	Z+6, r24	; 0x06
   13d9e:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
   13da2:	ed b7       	in	r30, 0x3d	; 61
   13da4:	fe b7       	in	r31, 0x3e	; 62
   13da6:	38 96       	adiw	r30, 0x08	; 8
   13da8:	0f b6       	in	r0, 0x3f	; 63
   13daa:	f8 94       	cli
   13dac:	fe bf       	out	0x3e, r31	; 62
   13dae:	0f be       	out	0x3f, r0	; 63
   13db0:	ed bf       	out	0x3d, r30	; 61
   13db2:	83 e0       	ldi	r24, 0x03	; 3
   13db4:	61 e0       	ldi	r22, 0x01	; 1
   13db6:	a8 01       	movw	r20, r16
   13db8:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
	            lcd_printf(4,1,PSTR("[*]Batal       [#]OK"));   //[*]Batal       [#]OK
   13dbc:	84 e0       	ldi	r24, 0x04	; 4
   13dbe:	61 e0       	ldi	r22, 0x01	; 1
   13dc0:	4f e0       	ldi	r20, 0x0F	; 15
   13dc2:	50 e2       	ldi	r21, 0x20	; 32
   13dc4:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
				stLocalAccount=laDispValidInput;
   13dc8:	88 e0       	ldi	r24, 0x08	; 8
   13dca:	7a c5       	rjmp	.+2804   	; 0x148c0 <FMenuLocalAccount+0xeb2>
		        break;
           case laDispValidInput:
                KeyPressed=_key_scan(1);
   13dcc:	81 e0       	ldi	r24, 0x01	; 1
   13dce:	0e 94 06 b0 	call	0x1600c	; 0x1600c <_key_scan>
   13dd2:	80 93 9c 03 	sts	0x039C, r24
				if (KeyPressed==_KEY_ENTER) stLocalAccount=laSelectFIP;
   13dd6:	87 3b       	cpi	r24, 0xB7	; 183
   13dd8:	09 f4       	brne	.+2      	; 0x13ddc <FMenuLocalAccount+0x3ce>
   13dda:	84 c2       	rjmp	.+1288   	; 0x142e4 <FMenuLocalAccount+0x8d6>
				else
				if (KeyPressed==_KEY_CANCEL)stLocalAccount=laExitLocAcc;
   13ddc:	87 3e       	cpi	r24, 0xE7	; 231
   13dde:	11 f0       	breq	.+4      	; 0x13de4 <FMenuLocalAccount+0x3d6>
   13de0:	0c 94 33 a7 	jmp	0x14e66	; 0x14e66 <FMenuLocalAccount+0x1458>
   13de4:	0c 94 2a a7 	jmp	0x14e54	; 0x14e54 <FMenuLocalAccount+0x1446>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
   13de8:	82 e8       	ldi	r24, 0x82	; 130
   13dea:	93 e0       	ldi	r25, 0x03	; 3
   13dec:	65 e4       	ldi	r22, 0x45	; 69
   13dee:	70 e0       	ldi	r23, 0x00	; 0
   13df0:	48 e0       	ldi	r20, 0x08	; 8
   13df2:	50 e0       	ldi	r21, 0x00	; 0
   13df4:	26 ef       	ldi	r18, 0xF6	; 246
   13df6:	32 e1       	ldi	r19, 0x12	; 18
   13df8:	0e 94 7a b5 	call	0x16af4	; 0x16af4 <__eerd_block>
		        break;
           case laSelectFIP:       
		  		eeprom_read_block((void*) &FIP, (const void*) &DefPumpMap, 8);
				lcd_clear(); 
   13dfc:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
				//for (iLoop=0;iLoop<8;iLoop++){
				//     if (FIP[iLoop]>16) FIP[iLoop]=0;
				//	 }
				for (iLoop=0;iLoop<4;iLoop++){
   13e00:	10 92 73 03 	sts	0x0373, r1
   13e04:	10 92 72 03 	sts	0x0372, r1
                     //leadingZero(FIP[iLoop],strPumpL);leadingZero(FIP[iLoop+4],strPumpR);
                     //sprintf_P(lcdteks,PSTR("%d.P%s | %d.P%s"),(iLoop+1),strPumpL,(iLoop+5),strPumpR);
					 sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d"),(iLoop+1),FIP[iLoop],(iLoop+5),FIP[iLoop+4]);
   13e08:	8e 01       	movw	r16, r28
   13e0a:	0f 5f       	subi	r16, 0xFF	; 255
   13e0c:	1f 4f       	sbci	r17, 0xFF	; 255
   13e0e:	5b ef       	ldi	r21, 0xFB	; 251
   13e10:	e5 2e       	mov	r14, r21
   13e12:	5f e1       	ldi	r21, 0x1F	; 31
   13e14:	f5 2e       	mov	r15, r21
   13e16:	41 c0       	rjmp	.+130    	; 0x13e9a <FMenuLocalAccount+0x48c>
   13e18:	8d b7       	in	r24, 0x3d	; 61
   13e1a:	9e b7       	in	r25, 0x3e	; 62
   13e1c:	0c 97       	sbiw	r24, 0x0c	; 12
   13e1e:	0f b6       	in	r0, 0x3f	; 63
   13e20:	f8 94       	cli
   13e22:	9e bf       	out	0x3e, r25	; 62
   13e24:	0f be       	out	0x3f, r0	; 63
   13e26:	8d bf       	out	0x3d, r24	; 61
   13e28:	ed b7       	in	r30, 0x3d	; 61
   13e2a:	fe b7       	in	r31, 0x3e	; 62
   13e2c:	31 96       	adiw	r30, 0x01	; 1
   13e2e:	ad b7       	in	r26, 0x3d	; 61
   13e30:	be b7       	in	r27, 0x3e	; 62
   13e32:	12 96       	adiw	r26, 0x02	; 2
   13e34:	1c 93       	st	X, r17
   13e36:	0e 93       	st	-X, r16
   13e38:	11 97       	sbiw	r26, 0x01	; 1
   13e3a:	f3 82       	std	Z+3, r15	; 0x03
   13e3c:	e2 82       	std	Z+2, r14	; 0x02
   13e3e:	2f 5f       	subi	r18, 0xFF	; 255
   13e40:	3f 4f       	sbci	r19, 0xFF	; 255
   13e42:	35 83       	std	Z+5, r19	; 0x05
   13e44:	24 83       	std	Z+4, r18	; 0x04
   13e46:	21 50       	subi	r18, 0x01	; 1
   13e48:	30 40       	sbci	r19, 0x00	; 0
   13e4a:	d9 01       	movw	r26, r18
   13e4c:	ae 57       	subi	r26, 0x7E	; 126
   13e4e:	bc 4f       	sbci	r27, 0xFC	; 252
   13e50:	8c 91       	ld	r24, X
   13e52:	86 83       	std	Z+6, r24	; 0x06
   13e54:	17 82       	std	Z+7, r1	; 0x07
   13e56:	2b 5f       	subi	r18, 0xFB	; 251
   13e58:	3f 4f       	sbci	r19, 0xFF	; 255
   13e5a:	31 87       	std	Z+9, r19	; 0x09
   13e5c:	20 87       	std	Z+8, r18	; 0x08
   13e5e:	14 96       	adiw	r26, 0x04	; 4
   13e60:	8c 91       	ld	r24, X
   13e62:	82 87       	std	Z+10, r24	; 0x0a
   13e64:	13 86       	std	Z+11, r1	; 0x0b
   13e66:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
					 lcd_print((iLoop+1),1,lcdteks);
   13e6a:	ed b7       	in	r30, 0x3d	; 61
   13e6c:	fe b7       	in	r31, 0x3e	; 62
   13e6e:	3c 96       	adiw	r30, 0x0c	; 12
   13e70:	0f b6       	in	r0, 0x3f	; 63
   13e72:	f8 94       	cli
   13e74:	fe bf       	out	0x3e, r31	; 62
   13e76:	0f be       	out	0x3f, r0	; 63
   13e78:	ed bf       	out	0x3d, r30	; 61
   13e7a:	80 91 72 03 	lds	r24, 0x0372
   13e7e:	8f 5f       	subi	r24, 0xFF	; 255
   13e80:	61 e0       	ldi	r22, 0x01	; 1
   13e82:	a8 01       	movw	r20, r16
   13e84:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
		  		eeprom_read_block((void*) &FIP, (const void*) &DefPumpMap, 8);
				lcd_clear(); 
				//for (iLoop=0;iLoop<8;iLoop++){
				//     if (FIP[iLoop]>16) FIP[iLoop]=0;
				//	 }
				for (iLoop=0;iLoop<4;iLoop++){
   13e88:	80 91 72 03 	lds	r24, 0x0372
   13e8c:	90 91 73 03 	lds	r25, 0x0373
   13e90:	01 96       	adiw	r24, 0x01	; 1
   13e92:	90 93 73 03 	sts	0x0373, r25
   13e96:	80 93 72 03 	sts	0x0372, r24
   13e9a:	20 91 72 03 	lds	r18, 0x0372
   13e9e:	30 91 73 03 	lds	r19, 0x0373
   13ea2:	24 30       	cpi	r18, 0x04	; 4
   13ea4:	31 05       	cpc	r19, r1
   13ea6:	08 f4       	brcc	.+2      	; 0x13eaa <FMenuLocalAccount+0x49c>
   13ea8:	b7 cf       	rjmp	.-146    	; 0x13e18 <FMenuLocalAccount+0x40a>
                     //leadingZero(FIP[iLoop],strPumpL);leadingZero(FIP[iLoop+4],strPumpR);
                     //sprintf_P(lcdteks,PSTR("%d.P%s | %d.P%s"),(iLoop+1),strPumpL,(iLoop+5),strPumpR);
					 sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d"),(iLoop+1),FIP[iLoop],(iLoop+5),FIP[iLoop+4]);
					 lcd_print((iLoop+1),1,lcdteks);
					 }
		        lcd_printf(1,15,PSTR("FIP:_"));    //"1.P01 | 5.P05 FIP:_ "                                                                      
   13eaa:	81 e0       	ldi	r24, 0x01	; 1
   13eac:	6f e0       	ldi	r22, 0x0F	; 15
   13eae:	45 ef       	ldi	r20, 0xF5	; 245
   13eb0:	5f e1       	ldi	r21, 0x1F	; 31
   13eb2:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
				lcd_printf(2,15,PSTR("     "));    //"2.P02 | 6.P05       "
   13eb6:	82 e0       	ldi	r24, 0x02	; 2
   13eb8:	6f e0       	ldi	r22, 0x0F	; 15
   13eba:	4f ee       	ldi	r20, 0xEF	; 239
   13ebc:	5f e1       	ldi	r21, 0x1F	; 31
   13ebe:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
				lcd_printf(3,15,PSTR("#)OK "));    //"3.P03 | 7.P07 #)OK  "
   13ec2:	83 e0       	ldi	r24, 0x03	; 3
   13ec4:	6f e0       	ldi	r22, 0x0F	; 15
   13ec6:	49 ee       	ldi	r20, 0xE9	; 233
   13ec8:	5f e1       	ldi	r21, 0x1F	; 31
   13eca:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
	            lcd_printf(4,15,PSTR("*)Exit"));   //"4.P04 | 8.P08 *)Exit"				
   13ece:	84 e0       	ldi	r24, 0x04	; 4
   13ed0:	6f e0       	ldi	r22, 0x0F	; 15
   13ed2:	42 ee       	ldi	r20, 0xE2	; 226
   13ed4:	5f e1       	ldi	r21, 0x1F	; 31
   13ed6:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
				//eeprom_read_block((void*) &FIP, (const void*) &DefPumpMap, 8);
				iLoop=0;
   13eda:	10 92 73 03 	sts	0x0373, r1
   13ede:	10 92 72 03 	sts	0x0372, r1
				stLocalAccount=laSelectFIPInput;
   13ee2:	8a e0       	ldi	r24, 0x0A	; 10
   13ee4:	ed c4       	rjmp	.+2522   	; 0x148c0 <FMenuLocalAccount+0xeb2>
		        break; 
           case laSelectFIPInput:
			    //Blinking 50% _ 
			    iLoop++;
   13ee6:	80 91 72 03 	lds	r24, 0x0372
   13eea:	90 91 73 03 	lds	r25, 0x0373
   13eee:	01 96       	adiw	r24, 0x01	; 1
   13ef0:	90 93 73 03 	sts	0x0373, r25
   13ef4:	80 93 72 03 	sts	0x0372, r24
			    //GetKeyPressed
			    KeyPressed=_key_scan(1);
   13ef8:	81 e0       	ldi	r24, 0x01	; 1
   13efa:	0e 94 06 b0 	call	0x1600c	; 0x1600c <_key_scan>
   13efe:	80 93 9c 03 	sts	0x039C, r24
			    KeyChar=_key_btn(KeyPressed);
   13f02:	0e 94 67 af 	call	0x15ece	; 0x15ece <_key_btn>
   13f06:	98 2f       	mov	r25, r24
   13f08:	80 93 a1 03 	sts	0x03A1, r24
				if ((KeyChar>='1')&&(KeyChar<='8')){
   13f0c:	81 53       	subi	r24, 0x31	; 49
   13f0e:	88 30       	cpi	r24, 0x08	; 8
   13f10:	60 f4       	brcc	.+24     	; 0x13f2a <FMenuLocalAccount+0x51c>
				    if (KeyCharLast!=KeyChar){
   13f12:	80 91 5b 01 	lds	r24, 0x015B
   13f16:	89 17       	cp	r24, r25
   13f18:	41 f0       	breq	.+16     	; 0x13f2a <FMenuLocalAccount+0x51c>
					    KeyCharLast=KeyChar;
   13f1a:	90 93 5b 01 	sts	0x015B, r25
						iLoop=1000;
   13f1e:	88 ee       	ldi	r24, 0xE8	; 232
   13f20:	93 e0       	ldi	r25, 0x03	; 3
   13f22:	90 93 73 03 	sts	0x0373, r25
   13f26:	80 93 72 03 	sts	0x0372, r24
                    }
				}

			    if ((iLoop%2000)==0){
   13f2a:	80 91 72 03 	lds	r24, 0x0372
   13f2e:	90 91 73 03 	lds	r25, 0x0373
   13f32:	60 ed       	ldi	r22, 0xD0	; 208
   13f34:	77 e0       	ldi	r23, 0x07	; 7
   13f36:	0e 94 93 b8 	call	0x17126	; 0x17126 <__udivmodhi4>
   13f3a:	89 2b       	or	r24, r25
   13f3c:	39 f4       	brne	.+14     	; 0x13f4c <FMenuLocalAccount+0x53e>
			       lcd_xy(1,19);_lcd('_'); 
   13f3e:	81 e0       	ldi	r24, 0x01	; 1
   13f40:	63 e1       	ldi	r22, 0x13	; 19
   13f42:	0e 94 4c ae 	call	0x15c98	; 0x15c98 <lcd_xy>
   13f46:	8f e5       	ldi	r24, 0x5F	; 95
   13f48:	0e 94 26 ae 	call	0x15c4c	; 0x15c4c <_lcd>
			    }
			    if ((iLoop%2000)==1000){
   13f4c:	80 91 72 03 	lds	r24, 0x0372
   13f50:	90 91 73 03 	lds	r25, 0x0373
   13f54:	60 ed       	ldi	r22, 0xD0	; 208
   13f56:	77 e0       	ldi	r23, 0x07	; 7
   13f58:	0e 94 93 b8 	call	0x17126	; 0x17126 <__udivmodhi4>
   13f5c:	88 5e       	subi	r24, 0xE8	; 232
   13f5e:	93 40       	sbci	r25, 0x03	; 3
   13f60:	41 f4       	brne	.+16     	; 0x13f72 <FMenuLocalAccount+0x564>
			       lcd_xy(1,19);_lcd(KeyCharLast); 
   13f62:	81 e0       	ldi	r24, 0x01	; 1
   13f64:	63 e1       	ldi	r22, 0x13	; 19
   13f66:	0e 94 4c ae 	call	0x15c98	; 0x15c98 <lcd_xy>
   13f6a:	80 91 5b 01 	lds	r24, 0x015B
   13f6e:	0e 94 26 ae 	call	0x15c4c	; 0x15c4c <_lcd>
			    }
				if (((KeyChar>='1')&&(KeyChar<='8'))||
   13f72:	80 91 a1 03 	lds	r24, 0x03A1
   13f76:	81 53       	subi	r24, 0x31	; 49
   13f78:	88 30       	cpi	r24, 0x08	; 8
   13f7a:	50 f0       	brcs	.+20     	; 0x13f90 <FMenuLocalAccount+0x582>
   13f7c:	80 91 9c 03 	lds	r24, 0x039C
   13f80:	87 3b       	cpi	r24, 0xB7	; 183
   13f82:	09 f0       	breq	.+2      	; 0x13f86 <FMenuLocalAccount+0x578>
   13f84:	57 c0       	rjmp	.+174    	; 0x14034 <FMenuLocalAccount+0x626>
   13f86:	80 91 5b 01 	lds	r24, 0x015B
   13f8a:	80 32       	cpi	r24, 0x20	; 32
   13f8c:	09 f4       	brne	.+2      	; 0x13f90 <FMenuLocalAccount+0x582>
   13f8e:	6b c7       	rjmp	.+3798   	; 0x14e66 <FMenuLocalAccount+0x1458>
				    (KeyPressed==_KEY_ENTER)&&(KeyCharLast!=' ')
					){
				    stLocalAccount=laSelectProduct;
   13f90:	8b e0       	ldi	r24, 0x0B	; 11
   13f92:	80 93 5c 01 	sts	0x015C, r24
					FIP_Used=FIP[KeyCharLast-'1'];
   13f96:	e0 91 5b 01 	lds	r30, 0x015B
   13f9a:	f0 e0       	ldi	r31, 0x00	; 0
   13f9c:	ef 5a       	subi	r30, 0xAF	; 175
   13f9e:	fc 4f       	sbci	r31, 0xFC	; 252
   13fa0:	20 81       	ld	r18, Z
   13fa2:	20 93 76 03 	sts	0x0376, r18
					if (FIP_Used<=99){
   13fa6:	24 36       	cpi	r18, 0x64	; 100
   13fa8:	08 f0       	brcs	.+2      	; 0x13fac <FMenuLocalAccount+0x59e>
   13faa:	5d c7       	rjmp	.+3770   	; 0x14e66 <FMenuLocalAccount+0x1458>
					    //leadingZero(FIP_Used,strFIP);
						//leadingZero(FIP_Used,strFIP_ID);
						sprintf_P(strFIP,PSTR("%.2d"),FIP_Used);
   13fac:	00 d0       	rcall	.+0      	; 0x13fae <FMenuLocalAccount+0x5a0>
   13fae:	00 d0       	rcall	.+0      	; 0x13fb0 <FMenuLocalAccount+0x5a2>
   13fb0:	00 d0       	rcall	.+0      	; 0x13fb2 <FMenuLocalAccount+0x5a4>
   13fb2:	ed b7       	in	r30, 0x3d	; 61
   13fb4:	fe b7       	in	r31, 0x3e	; 62
   13fb6:	31 96       	adiw	r30, 0x01	; 1
   13fb8:	8d e9       	ldi	r24, 0x9D	; 157
   13fba:	93 e0       	ldi	r25, 0x03	; 3
   13fbc:	ad b7       	in	r26, 0x3d	; 61
   13fbe:	be b7       	in	r27, 0x3e	; 62
   13fc0:	12 96       	adiw	r26, 0x02	; 2
   13fc2:	9c 93       	st	X, r25
   13fc4:	8e 93       	st	-X, r24
   13fc6:	11 97       	sbiw	r26, 0x01	; 1
   13fc8:	8d ed       	ldi	r24, 0xDD	; 221
   13fca:	9f e1       	ldi	r25, 0x1F	; 31
   13fcc:	93 83       	std	Z+3, r25	; 0x03
   13fce:	82 83       	std	Z+2, r24	; 0x02
   13fd0:	24 83       	std	Z+4, r18	; 0x04
   13fd2:	15 82       	std	Z+5, r1	; 0x05
   13fd4:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
						sprintf_P(strFIP_ID,PSTR("%.2d"),FIP_Used);
   13fd8:	ed b7       	in	r30, 0x3d	; 61
   13fda:	fe b7       	in	r31, 0x3e	; 62
   13fdc:	31 96       	adiw	r30, 0x01	; 1
   13fde:	8c e9       	ldi	r24, 0x9C	; 156
   13fe0:	99 e0       	ldi	r25, 0x09	; 9
   13fe2:	ad b7       	in	r26, 0x3d	; 61
   13fe4:	be b7       	in	r27, 0x3e	; 62
   13fe6:	12 96       	adiw	r26, 0x02	; 2
   13fe8:	9c 93       	st	X, r25
   13fea:	8e 93       	st	-X, r24
   13fec:	11 97       	sbiw	r26, 0x01	; 1
   13fee:	88 ed       	ldi	r24, 0xD8	; 216
   13ff0:	9f e1       	ldi	r25, 0x1F	; 31
   13ff2:	93 83       	std	Z+3, r25	; 0x03
   13ff4:	82 83       	std	Z+2, r24	; 0x02
   13ff6:	80 91 76 03 	lds	r24, 0x0376
   13ffa:	84 83       	std	Z+4, r24	; 0x04
   13ffc:	15 82       	std	Z+5, r1	; 0x05
   13ffe:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
   14002:	ed b7       	in	r30, 0x3d	; 61
   14004:	fe b7       	in	r31, 0x3e	; 62
   14006:	36 96       	adiw	r30, 0x06	; 6
   14008:	0f b6       	in	r0, 0x3f	; 63
   1400a:	f8 94       	cli
   1400c:	fe bf       	out	0x3e, r31	; 62
   1400e:	0f be       	out	0x3f, r0	; 63
   14010:	ed bf       	out	0x3d, r30	; 61
   14012:	60 91 5b 01 	lds	r22, 0x015B
   14016:	86 e0       	ldi	r24, 0x06	; 6
   14018:	68 9f       	mul	r22, r24
   1401a:	b0 01       	movw	r22, r0
   1401c:	11 24       	eor	r1, r1
   1401e:	61 5d       	subi	r22, 0xD1	; 209
   14020:	70 40       	sbci	r23, 0x00	; 0
   14022:	8a e8       	ldi	r24, 0x8A	; 138
   14024:	93 e0       	ldi	r25, 0x03	; 3
   14026:	46 e0       	ldi	r20, 0x06	; 6
   14028:	50 e0       	ldi	r21, 0x00	; 0
   1402a:	26 ef       	ldi	r18, 0xF6	; 246
   1402c:	32 e1       	ldi	r19, 0x12	; 18
   1402e:	0e 94 7a b5 	call	0x16af4	; 0x16af4 <__eerd_block>
   14032:	19 c7       	rjmp	.+3634   	; 0x14e66 <FMenuLocalAccount+0x1458>

						eeprom_read_block((void*) &ProductID, (const void*) &DefNozzleMap[(KeyCharLast-'1')], 6);
						}
					}
				else
				if (KeyPressed==_KEY_CANCEL){
   14034:	87 3e       	cpi	r24, 0xE7	; 231
   14036:	09 f0       	breq	.+2      	; 0x1403a <FMenuLocalAccount+0x62c>
   14038:	16 c7       	rjmp	.+3628   	; 0x14e66 <FMenuLocalAccount+0x1458>
				    stLocalAccount=laDispValid;
   1403a:	87 e0       	ldi	r24, 0x07	; 7
   1403c:	41 c4       	rjmp	.+2178   	; 0x148c0 <FMenuLocalAccount+0xeb2>
					}
		        break;
           case laSelectProduct://NozzleID
				lcd_clear();
   1403e:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
		        sprintf_P(lcdteks,PSTR("Pompa-%s"),strFIP);lcd_print(1,1,lcdteks);
   14042:	00 d0       	rcall	.+0      	; 0x14044 <FMenuLocalAccount+0x636>
   14044:	00 d0       	rcall	.+0      	; 0x14046 <FMenuLocalAccount+0x638>
   14046:	00 d0       	rcall	.+0      	; 0x14048 <FMenuLocalAccount+0x63a>
   14048:	ed b7       	in	r30, 0x3d	; 61
   1404a:	fe b7       	in	r31, 0x3e	; 62
   1404c:	31 96       	adiw	r30, 0x01	; 1
   1404e:	8e 01       	movw	r16, r28
   14050:	0f 5f       	subi	r16, 0xFF	; 255
   14052:	1f 4f       	sbci	r17, 0xFF	; 255
   14054:	ad b7       	in	r26, 0x3d	; 61
   14056:	be b7       	in	r27, 0x3e	; 62
   14058:	12 96       	adiw	r26, 0x02	; 2
   1405a:	1c 93       	st	X, r17
   1405c:	0e 93       	st	-X, r16
   1405e:	11 97       	sbiw	r26, 0x01	; 1
   14060:	8f ec       	ldi	r24, 0xCF	; 207
   14062:	9f e1       	ldi	r25, 0x1F	; 31
   14064:	93 83       	std	Z+3, r25	; 0x03
   14066:	82 83       	std	Z+2, r24	; 0x02
   14068:	8d e9       	ldi	r24, 0x9D	; 157
   1406a:	93 e0       	ldi	r25, 0x03	; 3
   1406c:	95 83       	std	Z+5, r25	; 0x05
   1406e:	84 83       	std	Z+4, r24	; 0x04
   14070:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
   14074:	ed b7       	in	r30, 0x3d	; 61
   14076:	fe b7       	in	r31, 0x3e	; 62
   14078:	36 96       	adiw	r30, 0x06	; 6
   1407a:	0f b6       	in	r0, 0x3f	; 63
   1407c:	f8 94       	cli
   1407e:	fe bf       	out	0x3e, r31	; 62
   14080:	0f be       	out	0x3f, r0	; 63
   14082:	ed bf       	out	0x3d, r30	; 61
   14084:	81 e0       	ldi	r24, 0x01	; 1
   14086:	61 e0       	ldi	r22, 0x01	; 1
   14088:	a8 01       	movw	r20, r16
   1408a:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
				//Not MPD->Single Product
				if ((ProductID[0]>=1)&&(ProductID[0]<=6)&&
   1408e:	90 91 8a 03 	lds	r25, 0x038A
   14092:	89 2f       	mov	r24, r25
   14094:	81 50       	subi	r24, 0x01	; 1
   14096:	86 30       	cpi	r24, 0x06	; 6
   14098:	08 f0       	brcs	.+2      	; 0x1409c <FMenuLocalAccount+0x68e>
   1409a:	4b c0       	rjmp	.+150    	; 0x14132 <FMenuLocalAccount+0x724>
   1409c:	80 91 8b 03 	lds	r24, 0x038B
   140a0:	88 23       	and	r24, r24
   140a2:	09 f0       	breq	.+2      	; 0x140a6 <FMenuLocalAccount+0x698>
   140a4:	46 c0       	rjmp	.+140    	; 0x14132 <FMenuLocalAccount+0x724>
   140a6:	80 91 8c 03 	lds	r24, 0x038C
   140aa:	88 23       	and	r24, r24
   140ac:	09 f0       	breq	.+2      	; 0x140b0 <FMenuLocalAccount+0x6a2>
   140ae:	41 c0       	rjmp	.+130    	; 0x14132 <FMenuLocalAccount+0x724>
   140b0:	80 91 8d 03 	lds	r24, 0x038D
   140b4:	88 23       	and	r24, r24
   140b6:	e9 f5       	brne	.+122    	; 0x14132 <FMenuLocalAccount+0x724>
				    (ProductID[1]==0)&&(ProductID[2]==0)&&(ProductID[3]==0)){
                     //Load 1st Product      					 
					 ProdId=ProductID[0];
   140b8:	90 93 75 03 	sts	0x0375, r25
   140bc:	6d e0       	ldi	r22, 0x0D	; 13
   140be:	96 9f       	mul	r25, r22
   140c0:	b0 01       	movw	r22, r0
   140c2:	11 24       	eor	r1, r1
   140c4:	62 55       	subi	r22, 0x52	; 82
   140c6:	7f 4f       	sbci	r23, 0xFF	; 255
   140c8:	87 e7       	ldi	r24, 0x77	; 119
   140ca:	93 e0       	ldi	r25, 0x03	; 3
   140cc:	4a e0       	ldi	r20, 0x0A	; 10
   140ce:	50 e0       	ldi	r21, 0x00	; 0
   140d0:	26 ef       	ldi	r18, 0xF6	; 246
   140d2:	32 e1       	ldi	r19, 0x12	; 18
   140d4:	0e 94 7a b5 	call	0x16af4	; 0x16af4 <__eerd_block>
   140d8:	a7 e7       	ldi	r26, 0x77	; 119
   140da:	b3 e0       	ldi	r27, 0x03	; 3
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   140dc:	11 96       	adiw	r26, 0x01	; 1
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   140de:	f3 e0       	ldi	r31, 0x03	; 3
   140e0:	af 37       	cpi	r26, 0x7F	; 127
   140e2:	bf 07       	cpc	r27, r31
   140e4:	d9 f7       	brne	.-10     	; 0x140dc <FMenuLocalAccount+0x6ce>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   140e6:	1c 92       	st	X, r1
				    (ProductID[1]==0)&&(ProductID[2]==0)&&(ProductID[3]==0)){
                     //Load 1st Product      					 
					 ProdId=ProductID[0];
					 eeprom_read_block((void*) &ProductName, (const void*) &DefProductName[ProdId-1],10);
					 StrPosCopy(ProductName,ProductName,0,8);
					 sprintf_P(strProduct,PSTR("%s"),ProductName);
   140e8:	00 d0       	rcall	.+0      	; 0x140ea <FMenuLocalAccount+0x6dc>
   140ea:	00 d0       	rcall	.+0      	; 0x140ec <FMenuLocalAccount+0x6de>
   140ec:	00 d0       	rcall	.+0      	; 0x140ee <FMenuLocalAccount+0x6e0>
   140ee:	2d b7       	in	r18, 0x3d	; 61
   140f0:	3e b7       	in	r19, 0x3e	; 62
   140f2:	2f 5f       	subi	r18, 0xFF	; 255
   140f4:	3f 4f       	sbci	r19, 0xFF	; 255
   140f6:	81 e4       	ldi	r24, 0x41	; 65
   140f8:	99 e0       	ldi	r25, 0x09	; 9
   140fa:	ed b7       	in	r30, 0x3d	; 61
   140fc:	fe b7       	in	r31, 0x3e	; 62
   140fe:	92 83       	std	Z+2, r25	; 0x02
   14100:	81 83       	std	Z+1, r24	; 0x01
   14102:	8c ec       	ldi	r24, 0xCC	; 204
   14104:	9f e1       	ldi	r25, 0x1F	; 31
   14106:	f9 01       	movw	r30, r18
   14108:	93 83       	std	Z+3, r25	; 0x03
   1410a:	82 83       	std	Z+2, r24	; 0x02
   1410c:	18 97       	sbiw	r26, 0x08	; 8
   1410e:	b5 83       	std	Z+5, r27	; 0x05
   14110:	a4 83       	std	Z+4, r26	; 0x04
   14112:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
                     stLocalAccount=laSelectBalanceType;
   14116:	8d e0       	ldi	r24, 0x0D	; 13
   14118:	80 93 5c 01 	sts	0x015C, r24
   1411c:	80 e0       	ldi	r24, 0x00	; 0
   1411e:	2d b7       	in	r18, 0x3d	; 61
   14120:	3e b7       	in	r19, 0x3e	; 62
   14122:	2a 5f       	subi	r18, 0xFA	; 250
   14124:	3f 4f       	sbci	r19, 0xFF	; 255
   14126:	0f b6       	in	r0, 0x3f	; 63
   14128:	f8 94       	cli
   1412a:	3e bf       	out	0x3e, r19	; 62
   1412c:	0f be       	out	0x3f, r0	; 63
   1412e:	2d bf       	out	0x3d, r18	; 61
   14130:	9b c6       	rjmp	.+3382   	; 0x14e68 <FMenuLocalAccount+0x145a>
					}else
                {
				//MultiProductDisplay Select:
				//Load Nozzle Configuration
				for(iNozzle=0;iNozzle<4;iNozzle++){
   14132:	10 92 9a 03 	sts	0x039A, r1
				        eeprom_read_block((void*) &ProductName, (const void*) &DefProductName[ProdId-1],10);
						StrPosCopy(ProductName,ProductName,0,8);
					    sprintf_P(lcdteks,PSTR("%d.%s"),(iNozzle+1),ProductName);
                    }
					else{
					       sprintf_P(lcdteks,PSTR("     "));					
   14136:	8e 01       	movw	r16, r28
   14138:	0f 5f       	subi	r16, 0xFF	; 255
   1413a:	1f 4f       	sbci	r17, 0xFF	; 255
   1413c:	40 ec       	ldi	r20, 0xC0	; 192
   1413e:	c4 2e       	mov	r12, r20
   14140:	4f e1       	ldi	r20, 0x1F	; 31
   14142:	d4 2e       	mov	r13, r20
   14144:	3d e0       	ldi	r19, 0x0D	; 13
   14146:	a3 2e       	mov	r10, r19
                    //Masalah 0-->void
				    ProdId=ProductID[iNozzle];
					if ((ProdId>=1)&&(ProdId<=6)){
				        eeprom_read_block((void*) &ProductName, (const void*) &DefProductName[ProdId-1],10);
						StrPosCopy(ProductName,ProductName,0,8);
					    sprintf_P(lcdteks,PSTR("%d.%s"),(iNozzle+1),ProductName);
   14148:	26 ec       	ldi	r18, 0xC6	; 198
   1414a:	e2 2e       	mov	r14, r18
   1414c:	2f e1       	ldi	r18, 0x1F	; 31
   1414e:	f2 2e       	mov	r15, r18
                    }
					else{
					       sprintf_P(lcdteks,PSTR("     "));					
					}
				    lcd_print(2+(iNozzle%2),1+(iNozzle/2)*11,lcdteks);
   14150:	9b e0       	ldi	r25, 0x0B	; 11
   14152:	b9 2e       	mov	r11, r25
   14154:	6b c0       	rjmp	.+214    	; 0x1422c <FMenuLocalAccount+0x81e>
                {
				//MultiProductDisplay Select:
				//Load Nozzle Configuration
				for(iNozzle=0;iNozzle<4;iNozzle++){
                    //Masalah 0-->void
				    ProdId=ProductID[iNozzle];
   14156:	f0 e0       	ldi	r31, 0x00	; 0
   14158:	e6 57       	subi	r30, 0x76	; 118
   1415a:	fc 4f       	sbci	r31, 0xFC	; 252
   1415c:	e0 81       	ld	r30, Z
   1415e:	e0 93 75 03 	sts	0x0375, r30
					if ((ProdId>=1)&&(ProdId<=6)){
   14162:	8e 2f       	mov	r24, r30
   14164:	81 50       	subi	r24, 0x01	; 1
   14166:	86 30       	cpi	r24, 0x06	; 6
   14168:	e8 f5       	brcc	.+122    	; 0x141e4 <FMenuLocalAccount+0x7d6>
   1416a:	ea 9d       	mul	r30, r10
   1416c:	b0 01       	movw	r22, r0
   1416e:	11 24       	eor	r1, r1
   14170:	62 55       	subi	r22, 0x52	; 82
   14172:	7f 4f       	sbci	r23, 0xFF	; 255
   14174:	87 e7       	ldi	r24, 0x77	; 119
   14176:	93 e0       	ldi	r25, 0x03	; 3
   14178:	4a e0       	ldi	r20, 0x0A	; 10
   1417a:	50 e0       	ldi	r21, 0x00	; 0
   1417c:	26 ef       	ldi	r18, 0xF6	; 246
   1417e:	32 e1       	ldi	r19, 0x12	; 18
   14180:	0e 94 7a b5 	call	0x16af4	; 0x16af4 <__eerd_block>
   14184:	a7 e7       	ldi	r26, 0x77	; 119
   14186:	b3 e0       	ldi	r27, 0x03	; 3
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   14188:	11 96       	adiw	r26, 0x01	; 1
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   1418a:	33 e0       	ldi	r19, 0x03	; 3
   1418c:	af 37       	cpi	r26, 0x7F	; 127
   1418e:	b3 07       	cpc	r27, r19
   14190:	d9 f7       	brne	.-10     	; 0x14188 <FMenuLocalAccount+0x77a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   14192:	1c 92       	st	X, r1
                    //Masalah 0-->void
				    ProdId=ProductID[iNozzle];
					if ((ProdId>=1)&&(ProdId<=6)){
				        eeprom_read_block((void*) &ProductName, (const void*) &DefProductName[ProdId-1],10);
						StrPosCopy(ProductName,ProductName,0,8);
					    sprintf_P(lcdteks,PSTR("%d.%s"),(iNozzle+1),ProductName);
   14194:	8d b7       	in	r24, 0x3d	; 61
   14196:	9e b7       	in	r25, 0x3e	; 62
   14198:	08 97       	sbiw	r24, 0x08	; 8
   1419a:	0f b6       	in	r0, 0x3f	; 63
   1419c:	f8 94       	cli
   1419e:	9e bf       	out	0x3e, r25	; 62
   141a0:	0f be       	out	0x3f, r0	; 63
   141a2:	8d bf       	out	0x3d, r24	; 61
   141a4:	2d b7       	in	r18, 0x3d	; 61
   141a6:	3e b7       	in	r19, 0x3e	; 62
   141a8:	2f 5f       	subi	r18, 0xFF	; 255
   141aa:	3f 4f       	sbci	r19, 0xFF	; 255
   141ac:	ed b7       	in	r30, 0x3d	; 61
   141ae:	fe b7       	in	r31, 0x3e	; 62
   141b0:	12 83       	std	Z+2, r17	; 0x02
   141b2:	01 83       	std	Z+1, r16	; 0x01
   141b4:	f9 01       	movw	r30, r18
   141b6:	f3 82       	std	Z+3, r15	; 0x03
   141b8:	e2 82       	std	Z+2, r14	; 0x02
   141ba:	80 91 9a 03 	lds	r24, 0x039A
   141be:	90 e0       	ldi	r25, 0x00	; 0
   141c0:	01 96       	adiw	r24, 0x01	; 1
   141c2:	95 83       	std	Z+5, r25	; 0x05
   141c4:	84 83       	std	Z+4, r24	; 0x04
   141c6:	18 97       	sbiw	r26, 0x08	; 8
   141c8:	b7 83       	std	Z+7, r27	; 0x07
   141ca:	a6 83       	std	Z+6, r26	; 0x06
   141cc:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
   141d0:	2d b7       	in	r18, 0x3d	; 61
   141d2:	3e b7       	in	r19, 0x3e	; 62
   141d4:	28 5f       	subi	r18, 0xF8	; 248
   141d6:	3f 4f       	sbci	r19, 0xFF	; 255
   141d8:	0f b6       	in	r0, 0x3f	; 63
   141da:	f8 94       	cli
   141dc:	3e bf       	out	0x3e, r19	; 62
   141de:	0f be       	out	0x3f, r0	; 63
   141e0:	2d bf       	out	0x3d, r18	; 61
   141e2:	12 c0       	rjmp	.+36     	; 0x14208 <FMenuLocalAccount+0x7fa>
                    }
					else{
					       sprintf_P(lcdteks,PSTR("     "));					
   141e4:	00 d0       	rcall	.+0      	; 0x141e6 <FMenuLocalAccount+0x7d8>
   141e6:	00 d0       	rcall	.+0      	; 0x141e8 <FMenuLocalAccount+0x7da>
   141e8:	ad b7       	in	r26, 0x3d	; 61
   141ea:	be b7       	in	r27, 0x3e	; 62
   141ec:	12 96       	adiw	r26, 0x02	; 2
   141ee:	1c 93       	st	X, r17
   141f0:	0e 93       	st	-X, r16
   141f2:	11 97       	sbiw	r26, 0x01	; 1
   141f4:	14 96       	adiw	r26, 0x04	; 4
   141f6:	dc 92       	st	X, r13
   141f8:	ce 92       	st	-X, r12
   141fa:	13 97       	sbiw	r26, 0x03	; 3
   141fc:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
   14200:	0f 90       	pop	r0
   14202:	0f 90       	pop	r0
   14204:	0f 90       	pop	r0
   14206:	0f 90       	pop	r0
					}
				    lcd_print(2+(iNozzle%2),1+(iNozzle/2)*11,lcdteks);
   14208:	80 91 9a 03 	lds	r24, 0x039A
   1420c:	68 2f       	mov	r22, r24
   1420e:	66 95       	lsr	r22
   14210:	6b 9d       	mul	r22, r11
   14212:	b0 01       	movw	r22, r0
   14214:	11 24       	eor	r1, r1
   14216:	6f 5f       	subi	r22, 0xFF	; 255
   14218:	81 70       	andi	r24, 0x01	; 1
   1421a:	8e 5f       	subi	r24, 0xFE	; 254
   1421c:	a8 01       	movw	r20, r16
   1421e:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
                     stLocalAccount=laSelectBalanceType;
					}else
                {
				//MultiProductDisplay Select:
				//Load Nozzle Configuration
				for(iNozzle=0;iNozzle<4;iNozzle++){
   14222:	80 91 9a 03 	lds	r24, 0x039A
   14226:	8f 5f       	subi	r24, 0xFF	; 255
   14228:	80 93 9a 03 	sts	0x039A, r24
   1422c:	e0 91 9a 03 	lds	r30, 0x039A
   14230:	e4 30       	cpi	r30, 0x04	; 4
   14232:	08 f4       	brcc	.+2      	; 0x14236 <FMenuLocalAccount+0x828>
   14234:	90 cf       	rjmp	.-224    	; 0x14156 <FMenuLocalAccount+0x748>
					else{
					       sprintf_P(lcdteks,PSTR("     "));					
					}
				    lcd_print(2+(iNozzle%2),1+(iNozzle/2)*11,lcdteks);
				}
	            lcd_printf(4,1,PSTR("[*]Back             "));   //"[*]Back             "				
   14236:	84 e0       	ldi	r24, 0x04	; 4
   14238:	61 e0       	ldi	r22, 0x01	; 1
   1423a:	4b ea       	ldi	r20, 0xAB	; 171
   1423c:	5f e1       	ldi	r21, 0x1F	; 31
   1423e:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
				stLocalAccount=laSelectProductInput;
   14242:	8c e0       	ldi	r24, 0x0C	; 12
   14244:	3d c3       	rjmp	.+1658   	; 0x148c0 <FMenuLocalAccount+0xeb2>
				}
		        break; 
           case laSelectProductInput:
				KeyPressed=_key_scan(1);
   14246:	81 e0       	ldi	r24, 0x01	; 1
   14248:	0e 94 06 b0 	call	0x1600c	; 0x1600c <_key_scan>
   1424c:	80 93 9c 03 	sts	0x039C, r24
			    KeyChar=_key_btn(KeyPressed);
   14250:	0e 94 67 af 	call	0x15ece	; 0x15ece <_key_btn>
   14254:	80 93 a1 03 	sts	0x03A1, r24
				if ((KeyChar>='1')&&(KeyChar<='4')){
   14258:	81 53       	subi	r24, 0x31	; 49
   1425a:	84 30       	cpi	r24, 0x04	; 4
   1425c:	f0 f5       	brcc	.+124    	; 0x142da <FMenuLocalAccount+0x8cc>
				    iNozzle=KeyChar-'1';
   1425e:	80 93 9a 03 	sts	0x039A, r24
   14262:	07 e7       	ldi	r16, 0x77	; 119
   14264:	13 e0       	ldi	r17, 0x03	; 3
   14266:	e8 2f       	mov	r30, r24
   14268:	f0 e0       	ldi	r31, 0x00	; 0
   1426a:	e6 57       	subi	r30, 0x76	; 118
   1426c:	fc 4f       	sbci	r31, 0xFC	; 252
   1426e:	60 81       	ld	r22, Z
   14270:	8d e0       	ldi	r24, 0x0D	; 13
   14272:	f8 2e       	mov	r15, r24
   14274:	6f 9d       	mul	r22, r15
   14276:	b0 01       	movw	r22, r0
   14278:	11 24       	eor	r1, r1
   1427a:	62 55       	subi	r22, 0x52	; 82
   1427c:	7f 4f       	sbci	r23, 0xFF	; 255
   1427e:	c8 01       	movw	r24, r16
   14280:	4a e0       	ldi	r20, 0x0A	; 10
   14282:	50 e0       	ldi	r21, 0x00	; 0
   14284:	26 ef       	ldi	r18, 0xF6	; 246
   14286:	32 e1       	ldi	r19, 0x12	; 18
   14288:	0e 94 7a b5 	call	0x16af4	; 0x16af4 <__eerd_block>
				    eeprom_read_block((void*) &ProductName, (const void*) &DefProductName[ProductID[iNozzle]-1],10);
					sprintf_P(strProduct,PSTR("%s"),ProductName);
   1428c:	00 d0       	rcall	.+0      	; 0x1428e <FMenuLocalAccount+0x880>
   1428e:	00 d0       	rcall	.+0      	; 0x14290 <FMenuLocalAccount+0x882>
   14290:	00 d0       	rcall	.+0      	; 0x14292 <FMenuLocalAccount+0x884>
   14292:	ed b7       	in	r30, 0x3d	; 61
   14294:	fe b7       	in	r31, 0x3e	; 62
   14296:	31 96       	adiw	r30, 0x01	; 1
   14298:	81 e4       	ldi	r24, 0x41	; 65
   1429a:	99 e0       	ldi	r25, 0x09	; 9
   1429c:	ad b7       	in	r26, 0x3d	; 61
   1429e:	be b7       	in	r27, 0x3e	; 62
   142a0:	12 96       	adiw	r26, 0x02	; 2
   142a2:	9c 93       	st	X, r25
   142a4:	8e 93       	st	-X, r24
   142a6:	11 97       	sbiw	r26, 0x01	; 1
   142a8:	88 ea       	ldi	r24, 0xA8	; 168
   142aa:	9f e1       	ldi	r25, 0x1F	; 31
   142ac:	93 83       	std	Z+3, r25	; 0x03
   142ae:	82 83       	std	Z+2, r24	; 0x02
   142b0:	15 83       	std	Z+5, r17	; 0x05
   142b2:	04 83       	std	Z+4, r16	; 0x04
   142b4:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
					NozzleID=iNozzle+1;
   142b8:	80 91 9a 03 	lds	r24, 0x039A
   142bc:	8f 5f       	subi	r24, 0xFF	; 255
   142be:	80 93 50 09 	sts	0x0950, r24
                    stLocalAccount=laSelectBalanceType;
   142c2:	f0 92 5c 01 	sts	0x015C, r15
					lcd_clear();
   142c6:	ed b7       	in	r30, 0x3d	; 61
   142c8:	fe b7       	in	r31, 0x3e	; 62
   142ca:	36 96       	adiw	r30, 0x06	; 6
   142cc:	0f b6       	in	r0, 0x3f	; 63
   142ce:	f8 94       	cli
   142d0:	fe bf       	out	0x3e, r31	; 62
   142d2:	0f be       	out	0x3f, r0	; 63
   142d4:	ed bf       	out	0x3d, r30	; 61
   142d6:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
					}                
				if (KeyPressed==_KEY_CANCEL)stLocalAccount=laSelectFIP;//Back To Pump Selection
   142da:	80 91 9c 03 	lds	r24, 0x039C
   142de:	87 3e       	cpi	r24, 0xE7	; 231
   142e0:	09 f0       	breq	.+2      	; 0x142e4 <FMenuLocalAccount+0x8d6>
   142e2:	c1 c5       	rjmp	.+2946   	; 0x14e66 <FMenuLocalAccount+0x1458>
   142e4:	89 e0       	ldi	r24, 0x09	; 9
   142e6:	ec c2       	rjmp	.+1496   	; 0x148c0 <FMenuLocalAccount+0xeb2>
		        break;
           case laSelectBalanceType:
		        lcd_clear();
   142e8:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
		        sprintf_P(lcdteks,PSTR("P%s-%s "),strFIP,strProduct);      
   142ec:	2d b7       	in	r18, 0x3d	; 61
   142ee:	3e b7       	in	r19, 0x3e	; 62
   142f0:	28 50       	subi	r18, 0x08	; 8
   142f2:	30 40       	sbci	r19, 0x00	; 0
   142f4:	0f b6       	in	r0, 0x3f	; 63
   142f6:	f8 94       	cli
   142f8:	3e bf       	out	0x3e, r19	; 62
   142fa:	0f be       	out	0x3f, r0	; 63
   142fc:	2d bf       	out	0x3d, r18	; 61
   142fe:	ed b7       	in	r30, 0x3d	; 61
   14300:	fe b7       	in	r31, 0x3e	; 62
   14302:	31 96       	adiw	r30, 0x01	; 1
   14304:	8e 01       	movw	r16, r28
   14306:	0f 5f       	subi	r16, 0xFF	; 255
   14308:	1f 4f       	sbci	r17, 0xFF	; 255
   1430a:	ad b7       	in	r26, 0x3d	; 61
   1430c:	be b7       	in	r27, 0x3e	; 62
   1430e:	12 96       	adiw	r26, 0x02	; 2
   14310:	1c 93       	st	X, r17
   14312:	0e 93       	st	-X, r16
   14314:	11 97       	sbiw	r26, 0x01	; 1
   14316:	80 ea       	ldi	r24, 0xA0	; 160
   14318:	9f e1       	ldi	r25, 0x1F	; 31
   1431a:	93 83       	std	Z+3, r25	; 0x03
   1431c:	82 83       	std	Z+2, r24	; 0x02
   1431e:	8d e9       	ldi	r24, 0x9D	; 157
   14320:	93 e0       	ldi	r25, 0x03	; 3
   14322:	95 83       	std	Z+5, r25	; 0x05
   14324:	84 83       	std	Z+4, r24	; 0x04
   14326:	81 e4       	ldi	r24, 0x41	; 65
   14328:	99 e0       	ldi	r25, 0x09	; 9
   1432a:	97 83       	std	Z+7, r25	; 0x07
   1432c:	86 83       	std	Z+6, r24	; 0x06
   1432e:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
				 lcd_print(1,1,lcdteks);                        //"P01-Pertamax        "                                                                      
   14332:	ed b7       	in	r30, 0x3d	; 61
   14334:	fe b7       	in	r31, 0x3e	; 62
   14336:	38 96       	adiw	r30, 0x08	; 8
   14338:	0f b6       	in	r0, 0x3f	; 63
   1433a:	f8 94       	cli
   1433c:	fe bf       	out	0x3e, r31	; 62
   1433e:	0f be       	out	0x3f, r0	; 63
   14340:	ed bf       	out	0x3d, r30	; 61
   14342:	81 e0       	ldi	r24, 0x01	; 1
   14344:	61 e0       	ldi	r22, 0x01	; 1
   14346:	a8 01       	movw	r20, r16
   14348:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
		        lcd_printf(2,1,PSTR("[1]Volume           "));   //"[1]Premium          "                                                                      
   1434c:	82 e0       	ldi	r24, 0x02	; 2
   1434e:	61 e0       	ldi	r22, 0x01	; 1
   14350:	4b e8       	ldi	r20, 0x8B	; 139
   14352:	5f e1       	ldi	r21, 0x1F	; 31
   14354:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
				lcd_printf(3,1,PSTR("[2]Amount           "));   //"[2]Pertamax         "
   14358:	83 e0       	ldi	r24, 0x03	; 3
   1435a:	61 e0       	ldi	r22, 0x01	; 1
   1435c:	46 e7       	ldi	r20, 0x76	; 118
   1435e:	5f e1       	ldi	r21, 0x1F	; 31
   14360:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
				lcd_printf(4,1,PSTR("[*]Back    [#]Next  "));   //"[*]Back             "						        
   14364:	84 e0       	ldi	r24, 0x04	; 4
   14366:	61 e0       	ldi	r22, 0x01	; 1
   14368:	41 e6       	ldi	r20, 0x61	; 97
   1436a:	5f e1       	ldi	r21, 0x1F	; 31
   1436c:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
	            //lcd_printf(4,1,PSTR("[*]Back    [#]Next  "));   //"[*]Back             "						        
                stLocalAccount=laSelectBalanceTypeInput;   
   14370:	8e e0       	ldi	r24, 0x0E	; 14
   14372:	a6 c2       	rjmp	.+1356   	; 0x148c0 <FMenuLocalAccount+0xeb2>
		        break;
           case laSelectBalanceTypeInput:
				KeyPressed=_key_scan(1);
   14374:	81 e0       	ldi	r24, 0x01	; 1
   14376:	0e 94 06 b0 	call	0x1600c	; 0x1600c <_key_scan>
   1437a:	80 93 9c 03 	sts	0x039C, r24
			    KeyChar=_key_btn(KeyPressed);
   1437e:	0e 94 67 af 	call	0x15ece	; 0x15ece <_key_btn>
   14382:	98 2f       	mov	r25, r24
   14384:	80 93 a1 03 	sts	0x03A1, r24
				if ((KeyChar>='1')&&(KeyChar<='2')){
   14388:	81 53       	subi	r24, 0x31	; 49
   1438a:	82 30       	cpi	r24, 0x02	; 2
   1438c:	80 f5       	brcc	.+96     	; 0x143ee <FMenuLocalAccount+0x9e0>
                    if(KeyChar=='1'){
   1438e:	91 33       	cpi	r25, 0x31	; 49
   14390:	a1 f4       	brne	.+40     	; 0x143ba <FMenuLocalAccount+0x9ac>
					   BalanceType=1;
   14392:	81 e0       	ldi	r24, 0x01	; 1
   14394:	80 93 a0 03 	sts	0x03A0, r24
					   sprintf_P(strBalanceType,PSTR("V"));
   14398:	00 d0       	rcall	.+0      	; 0x1439a <FMenuLocalAccount+0x98c>
   1439a:	00 d0       	rcall	.+0      	; 0x1439c <FMenuLocalAccount+0x98e>
   1439c:	83 e8       	ldi	r24, 0x83	; 131
   1439e:	95 e0       	ldi	r25, 0x05	; 5
   143a0:	ad b7       	in	r26, 0x3d	; 61
   143a2:	be b7       	in	r27, 0x3e	; 62
   143a4:	12 96       	adiw	r26, 0x02	; 2
   143a6:	9c 93       	st	X, r25
   143a8:	8e 93       	st	-X, r24
   143aa:	11 97       	sbiw	r26, 0x01	; 1
   143ac:	8f e5       	ldi	r24, 0x5F	; 95
   143ae:	9f e1       	ldi	r25, 0x1F	; 31
   143b0:	14 96       	adiw	r26, 0x04	; 4
   143b2:	9c 93       	st	X, r25
   143b4:	8e 93       	st	-X, r24
   143b6:	13 97       	sbiw	r26, 0x03	; 3
   143b8:	11 c0       	rjmp	.+34     	; 0x143dc <FMenuLocalAccount+0x9ce>
					   }
					else
                    if(KeyChar=='2'){
   143ba:	92 33       	cpi	r25, 0x32	; 50
   143bc:	a9 f4       	brne	.+42     	; 0x143e8 <FMenuLocalAccount+0x9da>
					   BalanceType=2;
   143be:	82 e0       	ldi	r24, 0x02	; 2
   143c0:	80 93 a0 03 	sts	0x03A0, r24
                       sprintf_P(strBalanceType,PSTR("A"));
   143c4:	00 d0       	rcall	.+0      	; 0x143c6 <FMenuLocalAccount+0x9b8>
   143c6:	00 d0       	rcall	.+0      	; 0x143c8 <FMenuLocalAccount+0x9ba>
   143c8:	83 e8       	ldi	r24, 0x83	; 131
   143ca:	95 e0       	ldi	r25, 0x05	; 5
   143cc:	ed b7       	in	r30, 0x3d	; 61
   143ce:	fe b7       	in	r31, 0x3e	; 62
   143d0:	92 83       	std	Z+2, r25	; 0x02
   143d2:	81 83       	std	Z+1, r24	; 0x01
   143d4:	8d e5       	ldi	r24, 0x5D	; 93
   143d6:	9f e1       	ldi	r25, 0x1F	; 31
   143d8:	94 83       	std	Z+4, r25	; 0x04
   143da:	83 83       	std	Z+3, r24	; 0x03
   143dc:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
   143e0:	0f 90       	pop	r0
   143e2:	0f 90       	pop	r0
   143e4:	0f 90       	pop	r0
   143e6:	0f 90       	pop	r0
					   }
				    stLocalAccount=laBalanceValue;  
   143e8:	8f e0       	ldi	r24, 0x0F	; 15
   143ea:	80 93 5c 01 	sts	0x015C, r24
					}              
				if (KeyPressed==_KEY_CANCEL){
   143ee:	80 91 9c 03 	lds	r24, 0x039C
   143f2:	87 3e       	cpi	r24, 0xE7	; 231
   143f4:	c9 f4       	brne	.+50     	; 0x14428 <FMenuLocalAccount+0xa1a>
				    if ((ProductID[0]>=1)&&(ProductID[0]<=6)&&(ProductID[1]==0)&&(ProductID[2]==0)&&(ProductID[3]==0))
   143f6:	80 91 8a 03 	lds	r24, 0x038A
   143fa:	81 50       	subi	r24, 0x01	; 1
   143fc:	86 30       	cpi	r24, 0x06	; 6
   143fe:	70 f4       	brcc	.+28     	; 0x1441c <FMenuLocalAccount+0xa0e>
   14400:	80 91 8b 03 	lds	r24, 0x038B
   14404:	88 23       	and	r24, r24
   14406:	51 f4       	brne	.+20     	; 0x1441c <FMenuLocalAccount+0xa0e>
   14408:	80 91 8c 03 	lds	r24, 0x038C
   1440c:	88 23       	and	r24, r24
   1440e:	31 f4       	brne	.+12     	; 0x1441c <FMenuLocalAccount+0xa0e>
   14410:	80 91 8d 03 	lds	r24, 0x038D
   14414:	88 23       	and	r24, r24
   14416:	11 f4       	brne	.+4      	; 0x1441c <FMenuLocalAccount+0xa0e>
					     stLocalAccount=laSelectFIP;//Back To FIP Select Non MPD
   14418:	89 e0       	ldi	r24, 0x09	; 9
   1441a:	01 c0       	rjmp	.+2      	; 0x1441e <FMenuLocalAccount+0xa10>
                    else stLocalAccount=laSelectProduct;//Back To Product Selection MPD
   1441c:	8b e0       	ldi	r24, 0x0B	; 11
   1441e:	80 93 5c 01 	sts	0x015C, r24
					lcd_clear();
   14422:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
   14426:	1f c5       	rjmp	.+2622   	; 0x14e66 <FMenuLocalAccount+0x1458>
					}
                else
				if (KeyPressed==_KEY_ENTER){
   14428:	87 3b       	cpi	r24, 0xB7	; 183
   1442a:	09 f0       	breq	.+2      	; 0x1442e <FMenuLocalAccount+0xa20>
   1442c:	1c c5       	rjmp	.+2616   	; 0x14e66 <FMenuLocalAccount+0x1458>
				    BalanceType=1;
   1442e:	11 e0       	ldi	r17, 0x01	; 1
   14430:	10 93 a0 03 	sts	0x03A0, r17
					sprintf_P(strBalanceType,PSTR("A"));
   14434:	00 d0       	rcall	.+0      	; 0x14436 <FMenuLocalAccount+0xa28>
   14436:	00 d0       	rcall	.+0      	; 0x14438 <FMenuLocalAccount+0xa2a>
   14438:	83 e8       	ldi	r24, 0x83	; 131
   1443a:	95 e0       	ldi	r25, 0x05	; 5
   1443c:	ad b7       	in	r26, 0x3d	; 61
   1443e:	be b7       	in	r27, 0x3e	; 62
   14440:	12 96       	adiw	r26, 0x02	; 2
   14442:	9c 93       	st	X, r25
   14444:	8e 93       	st	-X, r24
   14446:	11 97       	sbiw	r26, 0x01	; 1
   14448:	8b e5       	ldi	r24, 0x5B	; 91
   1444a:	9f e1       	ldi	r25, 0x1F	; 31
   1444c:	14 96       	adiw	r26, 0x04	; 4
   1444e:	9c 93       	st	X, r25
   14450:	8e 93       	st	-X, r24
   14452:	13 97       	sbiw	r26, 0x03	; 3
   14454:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
					//sprintf_P(strBalanceValue,PSTR("999"));
					IsFullAuthorized=True;
   14458:	10 93 74 03 	sts	0x0374, r17
                    stLocalAccount=laOdometer;//FullAuthorized
   1445c:	81 e1       	ldi	r24, 0x11	; 17
   1445e:	80 93 5c 01 	sts	0x015C, r24
   14462:	80 e0       	ldi	r24, 0x00	; 0
   14464:	0f 90       	pop	r0
   14466:	0f 90       	pop	r0
   14468:	0f 90       	pop	r0
   1446a:	0f 90       	pop	r0
   1446c:	fd c4       	rjmp	.+2554   	; 0x14e68 <FMenuLocalAccount+0x145a>
					}

		        break;
           case laBalanceValue:
		        lcd_clear();
   1446e:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
		        if(BalanceType==1){
   14472:	80 91 a0 03 	lds	r24, 0x03A0
   14476:	81 30       	cpi	r24, 0x01	; 1
   14478:	f1 f5       	brne	.+124    	; 0x144f6 <FMenuLocalAccount+0xae8>
		           sprintf_P(lcdteks,PSTR("P%s-%s "),strFIP,strProduct);      
   1447a:	ed b7       	in	r30, 0x3d	; 61
   1447c:	fe b7       	in	r31, 0x3e	; 62
   1447e:	38 97       	sbiw	r30, 0x08	; 8
   14480:	0f b6       	in	r0, 0x3f	; 63
   14482:	f8 94       	cli
   14484:	fe bf       	out	0x3e, r31	; 62
   14486:	0f be       	out	0x3f, r0	; 63
   14488:	ed bf       	out	0x3d, r30	; 61
   1448a:	31 96       	adiw	r30, 0x01	; 1
   1448c:	8e 01       	movw	r16, r28
   1448e:	0f 5f       	subi	r16, 0xFF	; 255
   14490:	1f 4f       	sbci	r17, 0xFF	; 255
   14492:	ad b7       	in	r26, 0x3d	; 61
   14494:	be b7       	in	r27, 0x3e	; 62
   14496:	12 96       	adiw	r26, 0x02	; 2
   14498:	1c 93       	st	X, r17
   1449a:	0e 93       	st	-X, r16
   1449c:	11 97       	sbiw	r26, 0x01	; 1
   1449e:	83 e5       	ldi	r24, 0x53	; 83
   144a0:	9f e1       	ldi	r25, 0x1F	; 31
   144a2:	93 83       	std	Z+3, r25	; 0x03
   144a4:	82 83       	std	Z+2, r24	; 0x02
   144a6:	8d e9       	ldi	r24, 0x9D	; 157
   144a8:	93 e0       	ldi	r25, 0x03	; 3
   144aa:	95 83       	std	Z+5, r25	; 0x05
   144ac:	84 83       	std	Z+4, r24	; 0x04
   144ae:	81 e4       	ldi	r24, 0x41	; 65
   144b0:	99 e0       	ldi	r25, 0x09	; 9
   144b2:	97 83       	std	Z+7, r25	; 0x07
   144b4:	86 83       	std	Z+6, r24	; 0x06
   144b6:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
				    lcd_print(1,1,lcdteks);                        //"P01-Pertamax        "                                                                      
   144ba:	ed b7       	in	r30, 0x3d	; 61
   144bc:	fe b7       	in	r31, 0x3e	; 62
   144be:	38 96       	adiw	r30, 0x08	; 8
   144c0:	0f b6       	in	r0, 0x3f	; 63
   144c2:	f8 94       	cli
   144c4:	fe bf       	out	0x3e, r31	; 62
   144c6:	0f be       	out	0x3f, r0	; 63
   144c8:	ed bf       	out	0x3d, r30	; 61
   144ca:	81 e0       	ldi	r24, 0x01	; 1
   144cc:	61 e0       	ldi	r22, 0x01	; 1
   144ce:	a8 01       	movw	r20, r16
   144d0:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
		           lcd_printf(2,1,PSTR("[1]Volume:_         "));   //"[1]Volume:_         "                                                                      
   144d4:	82 e0       	ldi	r24, 0x02	; 2
   144d6:	61 e0       	ldi	r22, 0x01	; 1
   144d8:	4e e3       	ldi	r20, 0x3E	; 62
   144da:	5f e1       	ldi	r21, 0x1F	; 31
   144dc:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
				   lcd_printf(3,1,PSTR("                    "));   //"                    "
   144e0:	83 e0       	ldi	r24, 0x03	; 3
   144e2:	61 e0       	ldi	r22, 0x01	; 1
   144e4:	49 e2       	ldi	r20, 0x29	; 41
   144e6:	5f e1       	ldi	r21, 0x1F	; 31
   144e8:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
	               lcd_printf(4,1,PSTR("[*]Back  [#]OK      "));   //"[*]Back  [#]OK     "						        
   144ec:	84 e0       	ldi	r24, 0x04	; 4
   144ee:	61 e0       	ldi	r22, 0x01	; 1
   144f0:	44 e1       	ldi	r20, 0x14	; 20
   144f2:	5f e1       	ldi	r21, 0x1F	; 31
   144f4:	43 c0       	rjmp	.+134    	; 0x1457c <FMenuLocalAccount+0xb6e>
				   }
                else
		        if(BalanceType==2){
   144f6:	82 30       	cpi	r24, 0x02	; 2
   144f8:	09 f0       	breq	.+2      	; 0x144fc <FMenuLocalAccount+0xaee>
   144fa:	42 c0       	rjmp	.+132    	; 0x14580 <FMenuLocalAccount+0xb72>
		           sprintf_P(lcdteks,PSTR("P%s-%s "),strFIP,strProduct);      
   144fc:	2d b7       	in	r18, 0x3d	; 61
   144fe:	3e b7       	in	r19, 0x3e	; 62
   14500:	28 50       	subi	r18, 0x08	; 8
   14502:	30 40       	sbci	r19, 0x00	; 0
   14504:	0f b6       	in	r0, 0x3f	; 63
   14506:	f8 94       	cli
   14508:	3e bf       	out	0x3e, r19	; 62
   1450a:	0f be       	out	0x3f, r0	; 63
   1450c:	2d bf       	out	0x3d, r18	; 61
   1450e:	ed b7       	in	r30, 0x3d	; 61
   14510:	fe b7       	in	r31, 0x3e	; 62
   14512:	31 96       	adiw	r30, 0x01	; 1
   14514:	8e 01       	movw	r16, r28
   14516:	0f 5f       	subi	r16, 0xFF	; 255
   14518:	1f 4f       	sbci	r17, 0xFF	; 255
   1451a:	ad b7       	in	r26, 0x3d	; 61
   1451c:	be b7       	in	r27, 0x3e	; 62
   1451e:	12 96       	adiw	r26, 0x02	; 2
   14520:	1c 93       	st	X, r17
   14522:	0e 93       	st	-X, r16
   14524:	11 97       	sbiw	r26, 0x01	; 1
   14526:	8c e0       	ldi	r24, 0x0C	; 12
   14528:	9f e1       	ldi	r25, 0x1F	; 31
   1452a:	93 83       	std	Z+3, r25	; 0x03
   1452c:	82 83       	std	Z+2, r24	; 0x02
   1452e:	8d e9       	ldi	r24, 0x9D	; 157
   14530:	93 e0       	ldi	r25, 0x03	; 3
   14532:	95 83       	std	Z+5, r25	; 0x05
   14534:	84 83       	std	Z+4, r24	; 0x04
   14536:	81 e4       	ldi	r24, 0x41	; 65
   14538:	99 e0       	ldi	r25, 0x09	; 9
   1453a:	97 83       	std	Z+7, r25	; 0x07
   1453c:	86 83       	std	Z+6, r24	; 0x06
   1453e:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
				   lcd_print(1,1,lcdteks);                         //"P01-Pertamax        "                                                                      
   14542:	ed b7       	in	r30, 0x3d	; 61
   14544:	fe b7       	in	r31, 0x3e	; 62
   14546:	38 96       	adiw	r30, 0x08	; 8
   14548:	0f b6       	in	r0, 0x3f	; 63
   1454a:	f8 94       	cli
   1454c:	fe bf       	out	0x3e, r31	; 62
   1454e:	0f be       	out	0x3f, r0	; 63
   14550:	ed bf       	out	0x3d, r30	; 61
   14552:	81 e0       	ldi	r24, 0x01	; 1
   14554:	61 e0       	ldi	r22, 0x01	; 1
   14556:	a8 01       	movw	r20, r16
   14558:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
		           lcd_printf(2,1,PSTR("                    "));   //"                    "                                                                      
   1455c:	82 e0       	ldi	r24, 0x02	; 2
   1455e:	61 e0       	ldi	r22, 0x01	; 1
   14560:	47 ef       	ldi	r20, 0xF7	; 247
   14562:	5e e1       	ldi	r21, 0x1E	; 30
   14564:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
				   lcd_printf(3,1,PSTR("[2]Amount:_         "));   //"[2]Amount:_         "
   14568:	83 e0       	ldi	r24, 0x03	; 3
   1456a:	61 e0       	ldi	r22, 0x01	; 1
   1456c:	42 ee       	ldi	r20, 0xE2	; 226
   1456e:	5e e1       	ldi	r21, 0x1E	; 30
   14570:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
	               lcd_printf(4,1,PSTR("[*]Back  [#]OK      "));   //"[*]Back  [#]OK      "			        
   14574:	84 e0       	ldi	r24, 0x04	; 4
   14576:	61 e0       	ldi	r22, 0x01	; 1
   14578:	4d ec       	ldi	r20, 0xCD	; 205
   1457a:	5e e1       	ldi	r21, 0x1E	; 30
   1457c:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
				   }
                iLoop=0;
   14580:	10 92 73 03 	sts	0x0373, r1
   14584:	10 92 72 03 	sts	0x0372, r1
				iValuePos=0;
   14588:	10 92 9b 03 	sts	0x039B, r1
				ValueChar[iValuePos]=' ';
   1458c:	80 e2       	ldi	r24, 0x20	; 32
   1458e:	80 93 90 03 	sts	0x0390, r24
		        stLocalAccount=laBalanceValueInput;  
   14592:	80 e1       	ldi	r24, 0x10	; 16
   14594:	95 c1       	rjmp	.+810    	; 0x148c0 <FMenuLocalAccount+0xeb2>
		        break; 
           case laBalanceValueInput:
			    //Blinking 50% _      BalanceValue Volume=999  Amount=65536
			    iLoop++;
   14596:	80 91 72 03 	lds	r24, 0x0372
   1459a:	90 91 73 03 	lds	r25, 0x0373
   1459e:	01 96       	adiw	r24, 0x01	; 1
   145a0:	90 93 73 03 	sts	0x0373, r25
   145a4:	80 93 72 03 	sts	0x0372, r24
			    //GetKeyPressed
			    KeyPressed=_key_scan(1);
   145a8:	81 e0       	ldi	r24, 0x01	; 1
   145aa:	0e 94 06 b0 	call	0x1600c	; 0x1600c <_key_scan>
   145ae:	80 93 9c 03 	sts	0x039C, r24
			    KeyChar=_key_btn(KeyPressed);
   145b2:	0e 94 67 af 	call	0x15ece	; 0x15ece <_key_btn>
   145b6:	98 2f       	mov	r25, r24
   145b8:	80 93 a1 03 	sts	0x03A1, r24
				if (((KeyChar>='0')&&(KeyChar<='9')&&(iValuePos<6)&&(BalanceType==2))||//Max Rp.999999
   145bc:	80 53       	subi	r24, 0x30	; 48
   145be:	8a 30       	cpi	r24, 0x0A	; 10
   145c0:	38 f5       	brcc	.+78     	; 0x14610 <FMenuLocalAccount+0xc02>
   145c2:	e0 91 9b 03 	lds	r30, 0x039B
   145c6:	e6 30       	cpi	r30, 0x06	; 6
   145c8:	18 f5       	brcc	.+70     	; 0x14610 <FMenuLocalAccount+0xc02>
   145ca:	80 91 a0 03 	lds	r24, 0x03A0
   145ce:	82 30       	cpi	r24, 0x02	; 2
   145d0:	21 f0       	breq	.+8      	; 0x145da <FMenuLocalAccount+0xbcc>
   145d2:	e3 30       	cpi	r30, 0x03	; 3
   145d4:	e8 f4       	brcc	.+58     	; 0x14610 <FMenuLocalAccount+0xc02>
   145d6:	81 30       	cpi	r24, 0x01	; 1
   145d8:	d9 f4       	brne	.+54     	; 0x14610 <FMenuLocalAccount+0xc02>
				   ((KeyChar>='0')&&(KeyChar<='9')&&(iValuePos<3)&&(BalanceType==1))){ //Max       999L
				    ValueChar[iValuePos]=KeyChar;
   145da:	f0 e0       	ldi	r31, 0x00	; 0
   145dc:	e0 57       	subi	r30, 0x70	; 112
   145de:	fc 4f       	sbci	r31, 0xFC	; 252
   145e0:	90 83       	st	Z, r25
					iValuePos++;
   145e2:	60 91 9b 03 	lds	r22, 0x039B
   145e6:	6f 5f       	subi	r22, 0xFF	; 255
   145e8:	60 93 9b 03 	sts	0x039B, r22
					lcd_xy(1+BalanceType,(10+iValuePos));_lcd(ValueChar[iValuePos-1]); 
   145ec:	80 91 a0 03 	lds	r24, 0x03A0
   145f0:	66 5f       	subi	r22, 0xF6	; 246
   145f2:	8f 5f       	subi	r24, 0xFF	; 255
   145f4:	0e 94 4c ae 	call	0x15c98	; 0x15c98 <lcd_xy>
   145f8:	e0 91 9b 03 	lds	r30, 0x039B
   145fc:	f0 e0       	ldi	r31, 0x00	; 0
   145fe:	e1 57       	subi	r30, 0x71	; 113
   14600:	fc 4f       	sbci	r31, 0xFC	; 252
   14602:	80 81       	ld	r24, Z
   14604:	0e 94 26 ae 	call	0x15c4c	; 0x15c4c <_lcd>
   14608:	80 e5       	ldi	r24, 0x50	; 80
   1460a:	93 ec       	ldi	r25, 0xC3	; 195
   1460c:	01 97       	sbiw	r24, 0x01	; 1
   1460e:	f1 f7       	brne	.-4      	; 0x1460c <FMenuLocalAccount+0xbfe>
					_delay_ms(200);
					}
			    if ((iLoop%2000)==0){
   14610:	80 91 72 03 	lds	r24, 0x0372
   14614:	90 91 73 03 	lds	r25, 0x0373
   14618:	60 ed       	ldi	r22, 0xD0	; 208
   1461a:	77 e0       	ldi	r23, 0x07	; 7
   1461c:	0e 94 93 b8 	call	0x17126	; 0x17126 <__udivmodhi4>
   14620:	89 2b       	or	r24, r25
   14622:	59 f4       	brne	.+22     	; 0x1463a <FMenuLocalAccount+0xc2c>
				     lcd_xy((1+BalanceType),(11+iValuePos));_lcd('_'); 
   14624:	80 91 a0 03 	lds	r24, 0x03A0
   14628:	60 91 9b 03 	lds	r22, 0x039B
   1462c:	65 5f       	subi	r22, 0xF5	; 245
   1462e:	8f 5f       	subi	r24, 0xFF	; 255
   14630:	0e 94 4c ae 	call	0x15c98	; 0x15c98 <lcd_xy>
   14634:	8f e5       	ldi	r24, 0x5F	; 95
   14636:	0e 94 26 ae 	call	0x15c4c	; 0x15c4c <_lcd>
			    }
			    if ((iLoop%2000)==1000){
   1463a:	80 91 72 03 	lds	r24, 0x0372
   1463e:	90 91 73 03 	lds	r25, 0x0373
   14642:	60 ed       	ldi	r22, 0xD0	; 208
   14644:	77 e0       	ldi	r23, 0x07	; 7
   14646:	0e 94 93 b8 	call	0x17126	; 0x17126 <__udivmodhi4>
   1464a:	88 5e       	subi	r24, 0xE8	; 232
   1464c:	93 40       	sbci	r25, 0x03	; 3
   1464e:	59 f4       	brne	.+22     	; 0x14666 <FMenuLocalAccount+0xc58>
				     lcd_xy((1+BalanceType),(11+iValuePos));_lcd(' '); 
   14650:	80 91 a0 03 	lds	r24, 0x03A0
   14654:	60 91 9b 03 	lds	r22, 0x039B
   14658:	65 5f       	subi	r22, 0xF5	; 245
   1465a:	8f 5f       	subi	r24, 0xFF	; 255
   1465c:	0e 94 4c ae 	call	0x15c98	; 0x15c98 <lcd_xy>
   14660:	80 e2       	ldi	r24, 0x20	; 32
   14662:	0e 94 26 ae 	call	0x15c4c	; 0x15c4c <_lcd>
			    }
				if (KeyPressed==_KEY_CANCEL){
   14666:	80 91 9c 03 	lds	r24, 0x039C
   1466a:	87 3e       	cpi	r24, 0xE7	; 231
   1466c:	39 f4       	brne	.+14     	; 0x1467c <FMenuLocalAccount+0xc6e>
				    lcd_clear();
   1466e:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
   14672:	88 ea       	ldi	r24, 0xA8	; 168
   14674:	91 e6       	ldi	r25, 0x61	; 97
   14676:	01 97       	sbiw	r24, 0x01	; 1
   14678:	f1 f7       	brne	.-4      	; 0x14676 <FMenuLocalAccount+0xc68>
   1467a:	1f c1       	rjmp	.+574    	; 0x148ba <FMenuLocalAccount+0xeac>
					_delay_ms(100);		        
				    stLocalAccount=laSelectBalanceType;		        
					}
				else
				if (KeyPressed==_KEY_ENTER){				    
   1467c:	87 3b       	cpi	r24, 0xB7	; 183
   1467e:	09 f0       	breq	.+2      	; 0x14682 <FMenuLocalAccount+0xc74>
   14680:	f2 c3       	rjmp	.+2020   	; 0x14e66 <FMenuLocalAccount+0x1458>
                    ValueChar[iValuePos]=0;
   14682:	e0 91 9b 03 	lds	r30, 0x039B
   14686:	f0 e0       	ldi	r31, 0x00	; 0
   14688:	e0 57       	subi	r30, 0x70	; 112
   1468a:	fc 4f       	sbci	r31, 0xFC	; 252
   1468c:	10 82       	st	Z, r1
					sprintf_P(strBalanceValue,PSTR("%s"),ValueChar);
   1468e:	00 d0       	rcall	.+0      	; 0x14690 <FMenuLocalAccount+0xc82>
   14690:	00 d0       	rcall	.+0      	; 0x14692 <FMenuLocalAccount+0xc84>
   14692:	00 d0       	rcall	.+0      	; 0x14694 <FMenuLocalAccount+0xc86>
   14694:	ed b7       	in	r30, 0x3d	; 61
   14696:	fe b7       	in	r31, 0x3e	; 62
   14698:	31 96       	adiw	r30, 0x01	; 1
   1469a:	8a ef       	ldi	r24, 0xFA	; 250
   1469c:	9d e0       	ldi	r25, 0x0D	; 13
   1469e:	ad b7       	in	r26, 0x3d	; 61
   146a0:	be b7       	in	r27, 0x3e	; 62
   146a2:	12 96       	adiw	r26, 0x02	; 2
   146a4:	9c 93       	st	X, r25
   146a6:	8e 93       	st	-X, r24
   146a8:	11 97       	sbiw	r26, 0x01	; 1
   146aa:	8a ec       	ldi	r24, 0xCA	; 202
   146ac:	9e e1       	ldi	r25, 0x1E	; 30
   146ae:	93 83       	std	Z+3, r25	; 0x03
   146b0:	82 83       	std	Z+2, r24	; 0x02
   146b2:	80 e9       	ldi	r24, 0x90	; 144
   146b4:	93 e0       	ldi	r25, 0x03	; 3
   146b6:	95 83       	std	Z+5, r25	; 0x05
   146b8:	84 83       	std	Z+4, r24	; 0x04
   146ba:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
				    stLocalAccount=laOdometer;
   146be:	81 e1       	ldi	r24, 0x11	; 17
   146c0:	80 93 5c 01 	sts	0x015C, r24
					lcd_clear();
   146c4:	ed b7       	in	r30, 0x3d	; 61
   146c6:	fe b7       	in	r31, 0x3e	; 62
   146c8:	36 96       	adiw	r30, 0x06	; 6
   146ca:	0f b6       	in	r0, 0x3f	; 63
   146cc:	f8 94       	cli
   146ce:	fe bf       	out	0x3e, r31	; 62
   146d0:	0f be       	out	0x3f, r0	; 63
   146d2:	ed bf       	out	0x3d, r30	; 61
   146d4:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
   146d8:	88 ea       	ldi	r24, 0xA8	; 168
   146da:	91 e6       	ldi	r25, 0x61	; 97
   146dc:	01 97       	sbiw	r24, 0x01	; 1
   146de:	f1 f7       	brne	.-4      	; 0x146dc <FMenuLocalAccount+0xcce>
   146e0:	c2 c3       	rjmp	.+1924   	; 0x14e66 <FMenuLocalAccount+0x1458>
					_delay_ms(100);		        
					}
		        break;
           case laOdometer://GetOdometer			
		        lcd_clear();
   146e2:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
				if (IsFullAuthorized==True){
   146e6:	80 91 74 03 	lds	r24, 0x0374
   146ea:	81 30       	cpi	r24, 0x01	; 1
   146ec:	09 f0       	breq	.+2      	; 0x146f0 <FMenuLocalAccount+0xce2>
   146ee:	4a c0       	rjmp	.+148    	; 0x14784 <FMenuLocalAccount+0xd76>
				    lcd_printf(1,1,PSTR("Pump Product   Full"));
   146f0:	61 e0       	ldi	r22, 0x01	; 1
   146f2:	46 eb       	ldi	r20, 0xB6	; 182
   146f4:	5e e1       	ldi	r21, 0x1E	; 30
   146f6:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
					sprintf_P(lcdteks,PSTR("  %s %s "),strFIP,strProduct);    lcd_print(2,1,lcdteks);    //"P01  Pertamax       "
   146fa:	2d b7       	in	r18, 0x3d	; 61
   146fc:	3e b7       	in	r19, 0x3e	; 62
   146fe:	28 50       	subi	r18, 0x08	; 8
   14700:	30 40       	sbci	r19, 0x00	; 0
   14702:	0f b6       	in	r0, 0x3f	; 63
   14704:	f8 94       	cli
   14706:	3e bf       	out	0x3e, r19	; 62
   14708:	0f be       	out	0x3f, r0	; 63
   1470a:	2d bf       	out	0x3d, r18	; 61
   1470c:	ed b7       	in	r30, 0x3d	; 61
   1470e:	fe b7       	in	r31, 0x3e	; 62
   14710:	31 96       	adiw	r30, 0x01	; 1
   14712:	8e 01       	movw	r16, r28
   14714:	0f 5f       	subi	r16, 0xFF	; 255
   14716:	1f 4f       	sbci	r17, 0xFF	; 255
   14718:	ad b7       	in	r26, 0x3d	; 61
   1471a:	be b7       	in	r27, 0x3e	; 62
   1471c:	12 96       	adiw	r26, 0x02	; 2
   1471e:	1c 93       	st	X, r17
   14720:	0e 93       	st	-X, r16
   14722:	11 97       	sbiw	r26, 0x01	; 1
   14724:	8d ea       	ldi	r24, 0xAD	; 173
   14726:	9e e1       	ldi	r25, 0x1E	; 30
   14728:	93 83       	std	Z+3, r25	; 0x03
   1472a:	82 83       	std	Z+2, r24	; 0x02
   1472c:	8d e9       	ldi	r24, 0x9D	; 157
   1472e:	93 e0       	ldi	r25, 0x03	; 3
   14730:	95 83       	std	Z+5, r25	; 0x05
   14732:	84 83       	std	Z+4, r24	; 0x04
   14734:	81 e4       	ldi	r24, 0x41	; 65
   14736:	99 e0       	ldi	r25, 0x09	; 9
   14738:	97 83       	std	Z+7, r25	; 0x07
   1473a:	86 83       	std	Z+6, r24	; 0x06
   1473c:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
   14740:	ed b7       	in	r30, 0x3d	; 61
   14742:	fe b7       	in	r31, 0x3e	; 62
   14744:	38 96       	adiw	r30, 0x08	; 8
   14746:	0f b6       	in	r0, 0x3f	; 63
   14748:	f8 94       	cli
   1474a:	fe bf       	out	0x3e, r31	; 62
   1474c:	0f be       	out	0x3f, r0	; 63
   1474e:	ed bf       	out	0x3d, r30	; 61
   14750:	82 e0       	ldi	r24, 0x02	; 2
   14752:	61 e0       	ldi	r22, 0x01	; 1
   14754:	a8 01       	movw	r20, r16
   14756:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
		            sprintf_P(lcdteks,PSTR("  Tank"));            lcd_print(2,14,lcdteks);   //"P01  Pertamax 500000"
   1475a:	00 d0       	rcall	.+0      	; 0x1475c <FMenuLocalAccount+0xd4e>
   1475c:	00 d0       	rcall	.+0      	; 0x1475e <FMenuLocalAccount+0xd50>
   1475e:	ad b7       	in	r26, 0x3d	; 61
   14760:	be b7       	in	r27, 0x3e	; 62
   14762:	12 96       	adiw	r26, 0x02	; 2
   14764:	1c 93       	st	X, r17
   14766:	0e 93       	st	-X, r16
   14768:	11 97       	sbiw	r26, 0x01	; 1
   1476a:	86 ea       	ldi	r24, 0xA6	; 166
   1476c:	9e e1       	ldi	r25, 0x1E	; 30
   1476e:	14 96       	adiw	r26, 0x04	; 4
   14770:	9c 93       	st	X, r25
   14772:	8e 93       	st	-X, r24
   14774:	13 97       	sbiw	r26, 0x03	; 3
   14776:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
   1477a:	0f 90       	pop	r0
   1477c:	0f 90       	pop	r0
   1477e:	0f 90       	pop	r0
   14780:	0f 90       	pop	r0
   14782:	5e c0       	rjmp	.+188    	; 0x14840 <FMenuLocalAccount+0xe32>
				}
                else{
		            if (BalanceType==1) lcd_printf(1,1,PSTR("Pump Product Volume"));
   14784:	80 91 a0 03 	lds	r24, 0x03A0
   14788:	81 30       	cpi	r24, 0x01	; 1
   1478a:	29 f4       	brne	.+10     	; 0x14796 <FMenuLocalAccount+0xd88>
   1478c:	61 e0       	ldi	r22, 0x01	; 1
   1478e:	42 e9       	ldi	r20, 0x92	; 146
   14790:	5e e1       	ldi	r21, 0x1E	; 30
   14792:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
                    if (BalanceType==2) lcd_printf(1,1,PSTR("Pump Product Amount"));//"Pump Product  Amount" 
   14796:	80 91 a0 03 	lds	r24, 0x03A0
   1479a:	82 30       	cpi	r24, 0x02	; 2
   1479c:	31 f4       	brne	.+12     	; 0x147aa <FMenuLocalAccount+0xd9c>
   1479e:	81 e0       	ldi	r24, 0x01	; 1
   147a0:	61 e0       	ldi	r22, 0x01	; 1
   147a2:	4e e7       	ldi	r20, 0x7E	; 126
   147a4:	5e e1       	ldi	r21, 0x1E	; 30
   147a6:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
					sprintf_P(lcdteks,PSTR("  %s %s "),strFIP,strProduct);    lcd_print(2,1,lcdteks);    //"P01  Pertamax       "
   147aa:	ed b7       	in	r30, 0x3d	; 61
   147ac:	fe b7       	in	r31, 0x3e	; 62
   147ae:	38 97       	sbiw	r30, 0x08	; 8
   147b0:	0f b6       	in	r0, 0x3f	; 63
   147b2:	f8 94       	cli
   147b4:	fe bf       	out	0x3e, r31	; 62
   147b6:	0f be       	out	0x3f, r0	; 63
   147b8:	ed bf       	out	0x3d, r30	; 61
   147ba:	31 96       	adiw	r30, 0x01	; 1
   147bc:	8e 01       	movw	r16, r28
   147be:	0f 5f       	subi	r16, 0xFF	; 255
   147c0:	1f 4f       	sbci	r17, 0xFF	; 255
   147c2:	ad b7       	in	r26, 0x3d	; 61
   147c4:	be b7       	in	r27, 0x3e	; 62
   147c6:	12 96       	adiw	r26, 0x02	; 2
   147c8:	1c 93       	st	X, r17
   147ca:	0e 93       	st	-X, r16
   147cc:	11 97       	sbiw	r26, 0x01	; 1
   147ce:	85 e7       	ldi	r24, 0x75	; 117
   147d0:	9e e1       	ldi	r25, 0x1E	; 30
   147d2:	93 83       	std	Z+3, r25	; 0x03
   147d4:	82 83       	std	Z+2, r24	; 0x02
   147d6:	8d e9       	ldi	r24, 0x9D	; 157
   147d8:	93 e0       	ldi	r25, 0x03	; 3
   147da:	95 83       	std	Z+5, r25	; 0x05
   147dc:	84 83       	std	Z+4, r24	; 0x04
   147de:	81 e4       	ldi	r24, 0x41	; 65
   147e0:	99 e0       	ldi	r25, 0x09	; 9
   147e2:	97 83       	std	Z+7, r25	; 0x07
   147e4:	86 83       	std	Z+6, r24	; 0x06
   147e6:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
   147ea:	ed b7       	in	r30, 0x3d	; 61
   147ec:	fe b7       	in	r31, 0x3e	; 62
   147ee:	38 96       	adiw	r30, 0x08	; 8
   147f0:	0f b6       	in	r0, 0x3f	; 63
   147f2:	f8 94       	cli
   147f4:	fe bf       	out	0x3e, r31	; 62
   147f6:	0f be       	out	0x3f, r0	; 63
   147f8:	ed bf       	out	0x3d, r30	; 61
   147fa:	82 e0       	ldi	r24, 0x02	; 2
   147fc:	61 e0       	ldi	r22, 0x01	; 1
   147fe:	a8 01       	movw	r20, r16
   14800:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
		            sprintf_P(lcdteks,PSTR("%s "),strBalanceValue);            lcd_print(2,14,lcdteks);   //"P01  Pertamax 500000"
   14804:	00 d0       	rcall	.+0      	; 0x14806 <FMenuLocalAccount+0xdf8>
   14806:	00 d0       	rcall	.+0      	; 0x14808 <FMenuLocalAccount+0xdfa>
   14808:	00 d0       	rcall	.+0      	; 0x1480a <FMenuLocalAccount+0xdfc>
   1480a:	ed b7       	in	r30, 0x3d	; 61
   1480c:	fe b7       	in	r31, 0x3e	; 62
   1480e:	31 96       	adiw	r30, 0x01	; 1
   14810:	ad b7       	in	r26, 0x3d	; 61
   14812:	be b7       	in	r27, 0x3e	; 62
   14814:	12 96       	adiw	r26, 0x02	; 2
   14816:	1c 93       	st	X, r17
   14818:	0e 93       	st	-X, r16
   1481a:	11 97       	sbiw	r26, 0x01	; 1
   1481c:	81 e7       	ldi	r24, 0x71	; 113
   1481e:	9e e1       	ldi	r25, 0x1E	; 30
   14820:	93 83       	std	Z+3, r25	; 0x03
   14822:	82 83       	std	Z+2, r24	; 0x02
   14824:	8a ef       	ldi	r24, 0xFA	; 250
   14826:	9d e0       	ldi	r25, 0x0D	; 13
   14828:	95 83       	std	Z+5, r25	; 0x05
   1482a:	84 83       	std	Z+4, r24	; 0x04
   1482c:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
   14830:	ed b7       	in	r30, 0x3d	; 61
   14832:	fe b7       	in	r31, 0x3e	; 62
   14834:	36 96       	adiw	r30, 0x06	; 6
   14836:	0f b6       	in	r0, 0x3f	; 63
   14838:	f8 94       	cli
   1483a:	fe bf       	out	0x3e, r31	; 62
   1483c:	0f be       	out	0x3f, r0	; 63
   1483e:	ed bf       	out	0x3d, r30	; 61
   14840:	82 e0       	ldi	r24, 0x02	; 2
   14842:	6e e0       	ldi	r22, 0x0E	; 14
   14844:	a8 01       	movw	r20, r16
   14846:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>

				}
				lcd_printf(3,1,PSTR("Odometer:_       "));                                //"Odometer:_          "
   1484a:	83 e0       	ldi	r24, 0x03	; 3
   1484c:	61 e0       	ldi	r22, 0x01	; 1
   1484e:	4f e5       	ldi	r20, 0x5F	; 95
   14850:	5e e1       	ldi	r21, 0x1E	; 30
   14852:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
	            lcd_printf(4,1,PSTR("[*]Back  [#]OK   "));                                //"[*]Back  [#]OK      "						        
   14856:	84 e0       	ldi	r24, 0x04	; 4
   14858:	61 e0       	ldi	r22, 0x01	; 1
   1485a:	4d e4       	ldi	r20, 0x4D	; 77
   1485c:	5e e1       	ldi	r21, 0x1E	; 30
   1485e:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
                //iLoop=0;
				//iValuePos=0;
				//ValueChar[iValuePos]=' ';        
				ClearMem(strOdometer);
   14862:	83 ea       	ldi	r24, 0xA3	; 163
   14864:	95 e0       	ldi	r25, 0x05	; 5
   14866:	0e 94 01 af 	call	0x15e02	; 0x15e02 <ClearMem>
		        stLocalAccount=laOdometerInput;
   1486a:	82 e1       	ldi	r24, 0x12	; 18
   1486c:	29 c0       	rjmp	.+82     	; 0x148c0 <FMenuLocalAccount+0xeb2>
		        break;
           case laOdometerInput:
		        //Blinking 50% _      BalanceValue Volume=999  Amount=65536
			    //iLoop++;
				uiResult=UserInput(UI_NUMBER_R,3,10,strOdometer,0,10);
   1486e:	13 ea       	ldi	r17, 0xA3	; 163
   14870:	c1 2e       	mov	r12, r17
   14872:	15 e0       	ldi	r17, 0x05	; 5
   14874:	d1 2e       	mov	r13, r17
   14876:	81 e0       	ldi	r24, 0x01	; 1
   14878:	63 e0       	ldi	r22, 0x03	; 3
   1487a:	4a e0       	ldi	r20, 0x0A	; 10
   1487c:	96 01       	movw	r18, r12
   1487e:	00 e0       	ldi	r16, 0x00	; 0
   14880:	10 e0       	ldi	r17, 0x00	; 0
   14882:	ba e0       	ldi	r27, 0x0A	; 10
   14884:	eb 2e       	mov	r14, r27
   14886:	0e 94 4b 7d 	call	0xfa96	; 0xfa96 <UserInput>
				if (uiResult==USER_OK){
   1488a:	83 30       	cpi	r24, 0x03	; 3
   1488c:	79 f4       	brne	.+30     	; 0x148ac <FMenuLocalAccount+0xe9e>
				    if ((strlen(strOdometer)==1)&&(strOdometer[0]=='0'))
   1488e:	f6 01       	movw	r30, r12
   14890:	01 90       	ld	r0, Z+
   14892:	00 20       	and	r0, r0
   14894:	e9 f7       	brne	.-6      	; 0x14890 <FMenuLocalAccount+0xe82>
   14896:	e5 5a       	subi	r30, 0xA5	; 165
   14898:	f5 40       	sbci	r31, 0x05	; 5
   1489a:	31 f4       	brne	.+12     	; 0x148a8 <FMenuLocalAccount+0xe9a>
   1489c:	80 91 a3 05 	lds	r24, 0x05A3
   148a0:	80 33       	cpi	r24, 0x30	; 48
   148a2:	11 f4       	brne	.+4      	; 0x148a8 <FMenuLocalAccount+0xe9a>
					    strOdometer[0]=0;
   148a4:	10 92 a3 05 	sts	0x05A3, r1

				    stLocalAccount=laDataConfirm;
   148a8:	83 e1       	ldi	r24, 0x13	; 19
   148aa:	0a c0       	rjmp	.+20     	; 0x148c0 <FMenuLocalAccount+0xeb2>
					}
			    else
			    if (uiResult==USER_CANCEL){
   148ac:	81 30       	cpi	r24, 0x01	; 1
   148ae:	09 f0       	breq	.+2      	; 0x148b2 <FMenuLocalAccount+0xea4>
   148b0:	da c2       	rjmp	.+1460   	; 0x14e66 <FMenuLocalAccount+0x1458>
				    if (IsFullAuthorized==True)
   148b2:	80 91 74 03 	lds	r24, 0x0374
   148b6:	81 30       	cpi	r24, 0x01	; 1
   148b8:	11 f4       	brne	.+4      	; 0x148be <FMenuLocalAccount+0xeb0>
					     stLocalAccount=laSelectBalanceType;
   148ba:	8d e0       	ldi	r24, 0x0D	; 13
   148bc:	01 c0       	rjmp	.+2      	; 0x148c0 <FMenuLocalAccount+0xeb2>
					else stLocalAccount=laBalanceValue;		        
   148be:	8f e0       	ldi	r24, 0x0F	; 15
   148c0:	80 93 5c 01 	sts	0x015C, r24
   148c4:	d0 c2       	rjmp	.+1440   	; 0x14e66 <FMenuLocalAccount+0x1458>
					}
                */

		        break;
           case laDataConfirm: 
		        lcd_clear();
   148c6:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
   148ca:	ed e0       	ldi	r30, 0x0D	; 13
   148cc:	f5 e0       	ldi	r31, 0x05	; 5
   148ce:	de 01       	movw	r26, r28
   148d0:	55 96       	adiw	r26, 0x15	; 21
	 }Dest[Length]=0;
}
void StringCopyPos(char *Source,char *Dest,char SrcPos,char Length){
     char i;
	 for (i=0;i<Length;i++){
	     Dest[i]=Source[SrcPos+i];
   148d2:	81 91       	ld	r24, Z+
   148d4:	8d 93       	st	X+, r24
	     Dest[i]=Source[i];
	 }Dest[Length]=0;
}
void StringCopyPos(char *Source,char *Dest,char SrcPos,char Length){
     char i;
	 for (i=0;i<Length;i++){
   148d6:	35 e0       	ldi	r19, 0x05	; 5
   148d8:	e7 31       	cpi	r30, 0x17	; 23
   148da:	f3 07       	cpc	r31, r19
   148dc:	d1 f7       	brne	.-12     	; 0x148d2 <FMenuLocalAccount+0xec4>
	     Dest[i]=Source[SrcPos+i];
	 }Dest[Length]=0;
   148de:	1f 8e       	std	Y+31, r1	; 0x1f

		        break;
           case laDataConfirm: 
		        lcd_clear();
		        StringCopyPos(strCardHolder,strName,9,10);                                          //Data Confirmation   
                sprintf_P(lcdteks,PSTR("%s "),strName);                  lcd_print(1,1,lcdteks);    //"Iyan The Man        "
   148e0:	00 d0       	rcall	.+0      	; 0x148e2 <FMenuLocalAccount+0xed4>
   148e2:	00 d0       	rcall	.+0      	; 0x148e4 <FMenuLocalAccount+0xed6>
   148e4:	00 d0       	rcall	.+0      	; 0x148e6 <FMenuLocalAccount+0xed8>
   148e6:	ed b7       	in	r30, 0x3d	; 61
   148e8:	fe b7       	in	r31, 0x3e	; 62
   148ea:	31 96       	adiw	r30, 0x01	; 1
   148ec:	8e 01       	movw	r16, r28
   148ee:	0f 5f       	subi	r16, 0xFF	; 255
   148f0:	1f 4f       	sbci	r17, 0xFF	; 255
   148f2:	ad b7       	in	r26, 0x3d	; 61
   148f4:	be b7       	in	r27, 0x3e	; 62
   148f6:	12 96       	adiw	r26, 0x02	; 2
   148f8:	1c 93       	st	X, r17
   148fa:	0e 93       	st	-X, r16
   148fc:	11 97       	sbiw	r26, 0x01	; 1
   148fe:	89 e4       	ldi	r24, 0x49	; 73
   14900:	9e e1       	ldi	r25, 0x1E	; 30
   14902:	93 83       	std	Z+3, r25	; 0x03
   14904:	82 83       	std	Z+2, r24	; 0x02
   14906:	ce 01       	movw	r24, r28
   14908:	45 96       	adiw	r24, 0x15	; 21
   1490a:	95 83       	std	Z+5, r25	; 0x05
   1490c:	84 83       	std	Z+4, r24	; 0x04
   1490e:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
   14912:	ed b7       	in	r30, 0x3d	; 61
   14914:	fe b7       	in	r31, 0x3e	; 62
   14916:	36 96       	adiw	r30, 0x06	; 6
   14918:	0f b6       	in	r0, 0x3f	; 63
   1491a:	f8 94       	cli
   1491c:	fe bf       	out	0x3e, r31	; 62
   1491e:	0f be       	out	0x3f, r0	; 63
   14920:	ed bf       	out	0x3d, r30	; 61
   14922:	81 e0       	ldi	r24, 0x01	; 1
   14924:	61 e0       	ldi	r22, 0x01	; 1
   14926:	a8 01       	movw	r20, r16
   14928:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
		        sprintf_P(lcdteks,PSTR("ID: %s"),strCardID);             lcd_print(2,1,lcdteks);    //"ID1CCDA565 OD:123456"
   1492c:	00 d0       	rcall	.+0      	; 0x1492e <FMenuLocalAccount+0xf20>
   1492e:	00 d0       	rcall	.+0      	; 0x14930 <FMenuLocalAccount+0xf22>
   14930:	00 d0       	rcall	.+0      	; 0x14932 <FMenuLocalAccount+0xf24>
   14932:	ed b7       	in	r30, 0x3d	; 61
   14934:	fe b7       	in	r31, 0x3e	; 62
   14936:	31 96       	adiw	r30, 0x01	; 1
   14938:	ad b7       	in	r26, 0x3d	; 61
   1493a:	be b7       	in	r27, 0x3e	; 62
   1493c:	12 96       	adiw	r26, 0x02	; 2
   1493e:	1c 93       	st	X, r17
   14940:	0e 93       	st	-X, r16
   14942:	11 97       	sbiw	r26, 0x01	; 1
   14944:	82 e4       	ldi	r24, 0x42	; 66
   14946:	9e e1       	ldi	r25, 0x1E	; 30
   14948:	93 83       	std	Z+3, r25	; 0x03
   1494a:	82 83       	std	Z+2, r24	; 0x02
   1494c:	81 e6       	ldi	r24, 0x61	; 97
   1494e:	9d e0       	ldi	r25, 0x0D	; 13
   14950:	95 83       	std	Z+5, r25	; 0x05
   14952:	84 83       	std	Z+4, r24	; 0x04
   14954:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
   14958:	ed b7       	in	r30, 0x3d	; 61
   1495a:	fe b7       	in	r31, 0x3e	; 62
   1495c:	36 96       	adiw	r30, 0x06	; 6
   1495e:	0f b6       	in	r0, 0x3f	; 63
   14960:	f8 94       	cli
   14962:	fe bf       	out	0x3e, r31	; 62
   14964:	0f be       	out	0x3f, r0	; 63
   14966:	ed bf       	out	0x3d, r30	; 61
   14968:	82 e0       	ldi	r24, 0x02	; 2
   1496a:	61 e0       	ldi	r22, 0x01	; 1
   1496c:	a8 01       	movw	r20, r16
   1496e:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
				sprintf_P(lcdteks,PSTR("%s  %s "),strFIP,strProduct);    lcd_print(3,1,lcdteks);    //"P01  Pertamax 500000"
   14972:	2d b7       	in	r18, 0x3d	; 61
   14974:	3e b7       	in	r19, 0x3e	; 62
   14976:	28 50       	subi	r18, 0x08	; 8
   14978:	30 40       	sbci	r19, 0x00	; 0
   1497a:	0f b6       	in	r0, 0x3f	; 63
   1497c:	f8 94       	cli
   1497e:	3e bf       	out	0x3e, r19	; 62
   14980:	0f be       	out	0x3f, r0	; 63
   14982:	2d bf       	out	0x3d, r18	; 61
   14984:	ed b7       	in	r30, 0x3d	; 61
   14986:	fe b7       	in	r31, 0x3e	; 62
   14988:	31 96       	adiw	r30, 0x01	; 1
   1498a:	ad b7       	in	r26, 0x3d	; 61
   1498c:	be b7       	in	r27, 0x3e	; 62
   1498e:	12 96       	adiw	r26, 0x02	; 2
   14990:	1c 93       	st	X, r17
   14992:	0e 93       	st	-X, r16
   14994:	11 97       	sbiw	r26, 0x01	; 1
   14996:	8a e3       	ldi	r24, 0x3A	; 58
   14998:	9e e1       	ldi	r25, 0x1E	; 30
   1499a:	93 83       	std	Z+3, r25	; 0x03
   1499c:	82 83       	std	Z+2, r24	; 0x02
   1499e:	8d e9       	ldi	r24, 0x9D	; 157
   149a0:	93 e0       	ldi	r25, 0x03	; 3
   149a2:	95 83       	std	Z+5, r25	; 0x05
   149a4:	84 83       	std	Z+4, r24	; 0x04
   149a6:	81 e4       	ldi	r24, 0x41	; 65
   149a8:	99 e0       	ldi	r25, 0x09	; 9
   149aa:	97 83       	std	Z+7, r25	; 0x07
   149ac:	86 83       	std	Z+6, r24	; 0x06
   149ae:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
   149b2:	ed b7       	in	r30, 0x3d	; 61
   149b4:	fe b7       	in	r31, 0x3e	; 62
   149b6:	38 96       	adiw	r30, 0x08	; 8
   149b8:	0f b6       	in	r0, 0x3f	; 63
   149ba:	f8 94       	cli
   149bc:	fe bf       	out	0x3e, r31	; 62
   149be:	0f be       	out	0x3f, r0	; 63
   149c0:	ed bf       	out	0x3d, r30	; 61
   149c2:	83 e0       	ldi	r24, 0x03	; 3
   149c4:	61 e0       	ldi	r22, 0x01	; 1
   149c6:	a8 01       	movw	r20, r16
   149c8:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
		        if (IsFullAuthorized==True){
   149cc:	80 91 74 03 	lds	r24, 0x0374
   149d0:	81 30       	cpi	r24, 0x01	; 1
   149d2:	39 f4       	brne	.+14     	; 0x149e2 <FMenuLocalAccount+0xfd4>
                    lcd_printf(3,15,PSTR(" Full"));
   149d4:	83 e0       	ldi	r24, 0x03	; 3
   149d6:	6f e0       	ldi	r22, 0x0F	; 15
   149d8:	44 e3       	ldi	r20, 0x34	; 52
   149da:	5e e1       	ldi	r21, 0x1E	; 30
   149dc:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
   149e0:	23 c0       	rjmp	.+70     	; 0x14a28 <FMenuLocalAccount+0x101a>
				}
				else {
				    sprintf_P(lcdteks,PSTR("%s "),strBalanceValue);          lcd_print(3,15,lcdteks);   //"[*]Back [0]ESC [#]OK " 
   149e2:	00 d0       	rcall	.+0      	; 0x149e4 <FMenuLocalAccount+0xfd6>
   149e4:	00 d0       	rcall	.+0      	; 0x149e6 <FMenuLocalAccount+0xfd8>
   149e6:	00 d0       	rcall	.+0      	; 0x149e8 <FMenuLocalAccount+0xfda>
   149e8:	ed b7       	in	r30, 0x3d	; 61
   149ea:	fe b7       	in	r31, 0x3e	; 62
   149ec:	31 96       	adiw	r30, 0x01	; 1
   149ee:	ad b7       	in	r26, 0x3d	; 61
   149f0:	be b7       	in	r27, 0x3e	; 62
   149f2:	12 96       	adiw	r26, 0x02	; 2
   149f4:	1c 93       	st	X, r17
   149f6:	0e 93       	st	-X, r16
   149f8:	11 97       	sbiw	r26, 0x01	; 1
   149fa:	80 e3       	ldi	r24, 0x30	; 48
   149fc:	9e e1       	ldi	r25, 0x1E	; 30
   149fe:	93 83       	std	Z+3, r25	; 0x03
   14a00:	82 83       	std	Z+2, r24	; 0x02
   14a02:	8a ef       	ldi	r24, 0xFA	; 250
   14a04:	9d e0       	ldi	r25, 0x0D	; 13
   14a06:	95 83       	std	Z+5, r25	; 0x05
   14a08:	84 83       	std	Z+4, r24	; 0x04
   14a0a:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
   14a0e:	ed b7       	in	r30, 0x3d	; 61
   14a10:	fe b7       	in	r31, 0x3e	; 62
   14a12:	36 96       	adiw	r30, 0x06	; 6
   14a14:	0f b6       	in	r0, 0x3f	; 63
   14a16:	f8 94       	cli
   14a18:	fe bf       	out	0x3e, r31	; 62
   14a1a:	0f be       	out	0x3f, r0	; 63
   14a1c:	ed bf       	out	0x3d, r30	; 61
   14a1e:	83 e0       	ldi	r24, 0x03	; 3
   14a20:	6f e0       	ldi	r22, 0x0F	; 15
   14a22:	a8 01       	movw	r20, r16
   14a24:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
					}
	            lcd_printf(4,1,PSTR("[*]Back [0]ESC [#]OK"));    
   14a28:	84 e0       	ldi	r24, 0x04	; 4
   14a2a:	61 e0       	ldi	r22, 0x01	; 1
   14a2c:	4b e1       	ldi	r20, 0x1B	; 27
   14a2e:	5e e1       	ldi	r21, 0x1E	; 30
   14a30:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
                stLocalAccount=laDataConfirmInput;
   14a34:	84 e1       	ldi	r24, 0x14	; 20
   14a36:	44 cf       	rjmp	.-376    	; 0x148c0 <FMenuLocalAccount+0xeb2>
                //while(1){};   
		        break;
           case laDataConfirmInput:
                KeyPressed=_key_scan(1);
   14a38:	81 e0       	ldi	r24, 0x01	; 1
   14a3a:	0e 94 06 b0 	call	0x1600c	; 0x1600c <_key_scan>
   14a3e:	80 93 9c 03 	sts	0x039C, r24
                if (KeyPressed==_KEY_CANCEL)stLocalAccount=laOdometer;		        
   14a42:	87 3e       	cpi	r24, 0xE7	; 231
   14a44:	11 f4       	brne	.+4      	; 0x14a4a <FMenuLocalAccount+0x103c>
   14a46:	81 e1       	ldi	r24, 0x11	; 17
   14a48:	3b cf       	rjmp	.-394    	; 0x148c0 <FMenuLocalAccount+0xeb2>
				else
				if (KeyPressed==_KEY_ENTER)stLocalAccount=laProceedTransaction;
   14a4a:	87 3b       	cpi	r24, 0xB7	; 183
   14a4c:	11 f4       	brne	.+4      	; 0x14a52 <FMenuLocalAccount+0x1044>
   14a4e:	85 e1       	ldi	r24, 0x15	; 21
   14a50:	37 cf       	rjmp	.-402    	; 0x148c0 <FMenuLocalAccount+0xeb2>
				else
				if (KeyPressed==_KEY_0){
   14a52:	87 3d       	cpi	r24, 0xD7	; 215
   14a54:	09 f0       	breq	.+2      	; 0x14a58 <FMenuLocalAccount+0x104a>
   14a56:	07 c2       	rjmp	.+1038   	; 0x14e66 <FMenuLocalAccount+0x1458>
				   //ShowCancel
				   TimLocAcc=0;
   14a58:	10 92 d3 01 	sts	0x01D3, r1
   14a5c:	10 92 d2 01 	sts	0x01D2, r1
                   lcd_clear();
   14a60:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
				   lcd_printf(1,1,PSTR("Cancel Transaction  "));    //"Cancel Transaction"
   14a64:	81 e0       	ldi	r24, 0x01	; 1
   14a66:	61 e0       	ldi	r22, 0x01	; 1
   14a68:	46 e0       	ldi	r20, 0x06	; 6
   14a6a:	5e e1       	ldi	r21, 0x1E	; 30
   14a6c:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
   14a70:	e9 c1       	rjmp	.+978    	; 0x14e44 <FMenuLocalAccount+0x1436>
				   stLocalAccount=laDelayExit;
				   }
		        break;
           case laProceedTransaction:
		        sendMessage58();
   14a72:	0e 94 8d 50 	call	0xa11a	; 0xa11a <sendMessage58>
                RemZeroLead(strCardID);
   14a76:	81 e6       	ldi	r24, 0x61	; 97
   14a78:	9d e0       	ldi	r25, 0x0D	; 13
   14a7a:	0e 94 b9 25 	call	0x4b72	; 0x4b72 <RemZeroLead>
                RemZeroLead(strBalanceValue);
   14a7e:	aa ef       	ldi	r26, 0xFA	; 250
   14a80:	ea 2e       	mov	r14, r26
   14a82:	ad e0       	ldi	r26, 0x0D	; 13
   14a84:	fa 2e       	mov	r15, r26
   14a86:	c7 01       	movw	r24, r14
   14a88:	0e 94 b9 25 	call	0x4b72	; 0x4b72 <RemZeroLead>
				sprintf_P(lcdteks,PSTR("P%s %s "),strFIP,strProduct);       lcd_print(1,1,lcdteks);    //"P01  Pertamax 500000"
   14a8c:	2d b7       	in	r18, 0x3d	; 61
   14a8e:	3e b7       	in	r19, 0x3e	; 62
   14a90:	28 50       	subi	r18, 0x08	; 8
   14a92:	30 40       	sbci	r19, 0x00	; 0
   14a94:	0f b6       	in	r0, 0x3f	; 63
   14a96:	f8 94       	cli
   14a98:	3e bf       	out	0x3e, r19	; 62
   14a9a:	0f be       	out	0x3f, r0	; 63
   14a9c:	2d bf       	out	0x3d, r18	; 61
   14a9e:	ed b7       	in	r30, 0x3d	; 61
   14aa0:	fe b7       	in	r31, 0x3e	; 62
   14aa2:	31 96       	adiw	r30, 0x01	; 1
   14aa4:	8e 01       	movw	r16, r28
   14aa6:	0f 5f       	subi	r16, 0xFF	; 255
   14aa8:	1f 4f       	sbci	r17, 0xFF	; 255
   14aaa:	ad b7       	in	r26, 0x3d	; 61
   14aac:	be b7       	in	r27, 0x3e	; 62
   14aae:	12 96       	adiw	r26, 0x02	; 2
   14ab0:	1c 93       	st	X, r17
   14ab2:	0e 93       	st	-X, r16
   14ab4:	11 97       	sbiw	r26, 0x01	; 1
   14ab6:	8e ef       	ldi	r24, 0xFE	; 254
   14ab8:	9d e1       	ldi	r25, 0x1D	; 29
   14aba:	93 83       	std	Z+3, r25	; 0x03
   14abc:	82 83       	std	Z+2, r24	; 0x02
   14abe:	8d e9       	ldi	r24, 0x9D	; 157
   14ac0:	93 e0       	ldi	r25, 0x03	; 3
   14ac2:	95 83       	std	Z+5, r25	; 0x05
   14ac4:	84 83       	std	Z+4, r24	; 0x04
   14ac6:	81 e4       	ldi	r24, 0x41	; 65
   14ac8:	99 e0       	ldi	r25, 0x09	; 9
   14aca:	97 83       	std	Z+7, r25	; 0x07
   14acc:	86 83       	std	Z+6, r24	; 0x06
   14ace:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
   14ad2:	ed b7       	in	r30, 0x3d	; 61
   14ad4:	fe b7       	in	r31, 0x3e	; 62
   14ad6:	38 96       	adiw	r30, 0x08	; 8
   14ad8:	0f b6       	in	r0, 0x3f	; 63
   14ada:	f8 94       	cli
   14adc:	fe bf       	out	0x3e, r31	; 62
   14ade:	0f be       	out	0x3f, r0	; 63
   14ae0:	ed bf       	out	0x3d, r30	; 61
   14ae2:	81 e0       	ldi	r24, 0x01	; 1
   14ae4:	61 e0       	ldi	r22, 0x01	; 1
   14ae6:	a8 01       	movw	r20, r16
   14ae8:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
		        sprintf_P(lcdteks,PSTR("%s"),strBalanceValue);              lcd_print(1,15,lcdteks);   //"ID1CCDA565          " 
   14aec:	00 d0       	rcall	.+0      	; 0x14aee <FMenuLocalAccount+0x10e0>
   14aee:	00 d0       	rcall	.+0      	; 0x14af0 <FMenuLocalAccount+0x10e2>
   14af0:	00 d0       	rcall	.+0      	; 0x14af2 <FMenuLocalAccount+0x10e4>
   14af2:	ed b7       	in	r30, 0x3d	; 61
   14af4:	fe b7       	in	r31, 0x3e	; 62
   14af6:	31 96       	adiw	r30, 0x01	; 1
   14af8:	ad b7       	in	r26, 0x3d	; 61
   14afa:	be b7       	in	r27, 0x3e	; 62
   14afc:	12 96       	adiw	r26, 0x02	; 2
   14afe:	1c 93       	st	X, r17
   14b00:	0e 93       	st	-X, r16
   14b02:	11 97       	sbiw	r26, 0x01	; 1
   14b04:	8b ef       	ldi	r24, 0xFB	; 251
   14b06:	9d e1       	ldi	r25, 0x1D	; 29
   14b08:	93 83       	std	Z+3, r25	; 0x03
   14b0a:	82 83       	std	Z+2, r24	; 0x02
   14b0c:	f5 82       	std	Z+5, r15	; 0x05
   14b0e:	e4 82       	std	Z+4, r14	; 0x04
   14b10:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
   14b14:	ed b7       	in	r30, 0x3d	; 61
   14b16:	fe b7       	in	r31, 0x3e	; 62
   14b18:	36 96       	adiw	r30, 0x06	; 6
   14b1a:	0f b6       	in	r0, 0x3f	; 63
   14b1c:	f8 94       	cli
   14b1e:	fe bf       	out	0x3e, r31	; 62
   14b20:	0f be       	out	0x3f, r0	; 63
   14b22:	ed bf       	out	0x3d, r30	; 61
   14b24:	81 e0       	ldi	r24, 0x01	; 1
   14b26:	6f e0       	ldi	r22, 0x0F	; 15
   14b28:	a8 01       	movw	r20, r16
   14b2a:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
                lcd_printf(3,1,PSTR("Mohon Tunggu        "));                                         //"Mohon Tunggu ...    "
   14b2e:	83 e0       	ldi	r24, 0x03	; 3
   14b30:	61 e0       	ldi	r22, 0x01	; 1
   14b32:	46 ee       	ldi	r20, 0xE6	; 230
   14b34:	5d e1       	ldi	r21, 0x1D	; 29
   14b36:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		        lcd_printf(4,1,PSTR("                    "));                                  //"                    "
   14b3a:	84 e0       	ldi	r24, 0x04	; 4
   14b3c:	61 e0       	ldi	r22, 0x01	; 1
   14b3e:	41 ed       	ldi	r20, 0xD1	; 209
   14b40:	5d e1       	ldi	r21, 0x1D	; 29
   14b42:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
				IsMessage00=False;
   14b46:	10 92 b5 01 	sts	0x01B5, r1
				TimLocAcc=0;
   14b4a:	10 92 d3 01 	sts	0x01D3, r1
   14b4e:	10 92 d2 01 	sts	0x01D2, r1
				iLoop=0;iPos=0;iWait=0;
   14b52:	10 92 73 03 	sts	0x0373, r1
   14b56:	10 92 72 03 	sts	0x0372, r1
   14b5a:	10 92 a3 03 	sts	0x03A3, r1
   14b5e:	10 92 a2 03 	sts	0x03A2, r1
				stLocalAccount=laWaitMessage00;
   14b62:	87 e1       	ldi	r24, 0x17	; 23
   14b64:	ad ce       	rjmp	.-678    	; 0x148c0 <FMenuLocalAccount+0xeb2>
		        break;
           case laWaitMessage00:
                iLoop++;
   14b66:	80 91 72 03 	lds	r24, 0x0372
   14b6a:	90 91 73 03 	lds	r25, 0x0373
   14b6e:	01 96       	adiw	r24, 0x01	; 1
   14b70:	90 93 73 03 	sts	0x0373, r25
   14b74:	80 93 72 03 	sts	0x0372, r24
				if ((iLoop%MSG_WAIT_TIMOUT)==0){
   14b78:	68 e9       	ldi	r22, 0x98	; 152
   14b7a:	7a e3       	ldi	r23, 0x3A	; 58
   14b7c:	0e 94 93 b8 	call	0x17126	; 0x17126 <__udivmodhi4>
   14b80:	89 2b       	or	r24, r25
   14b82:	e1 f4       	brne	.+56     	; 0x14bbc <FMenuLocalAccount+0x11ae>
				   if (iPos<5){
   14b84:	60 91 a3 03 	lds	r22, 0x03A3
   14b88:	65 30       	cpi	r22, 0x05	; 5
   14b8a:	58 f4       	brcc	.+22     	; 0x14ba2 <FMenuLocalAccount+0x1194>
				       iPos++;
   14b8c:	6f 5f       	subi	r22, 0xFF	; 255
   14b8e:	60 93 a3 03 	sts	0x03A3, r22
					   lcd_xy(3,(14+iPos));_lcd('.');
   14b92:	62 5f       	subi	r22, 0xF2	; 242
   14b94:	83 e0       	ldi	r24, 0x03	; 3
   14b96:	0e 94 4c ae 	call	0x15c98	; 0x15c98 <lcd_xy>
   14b9a:	8e e2       	ldi	r24, 0x2E	; 46
   14b9c:	0e 94 26 ae 	call	0x15c4c	; 0x15c4c <_lcd>
   14ba0:	0d c0       	rjmp	.+26     	; 0x14bbc <FMenuLocalAccount+0x11ae>
					   }
				   else{
				       iPos=0;
   14ba2:	10 92 a3 03 	sts	0x03A3, r1
					   lcd_printf(3,(14+iPos),PSTR("       "));
   14ba6:	83 e0       	ldi	r24, 0x03	; 3
   14ba8:	6e e0       	ldi	r22, 0x0E	; 14
   14baa:	49 ec       	ldi	r20, 0xC9	; 201
   14bac:	5d e1       	ldi	r21, 0x1D	; 29
   14bae:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
					   iWait++;
   14bb2:	80 91 a2 03 	lds	r24, 0x03A2
   14bb6:	8f 5f       	subi	r24, 0xFF	; 255
   14bb8:	80 93 a2 03 	sts	0x03A2, r24
					   }
				}
				if (iWait>5){
   14bbc:	80 91 a2 03 	lds	r24, 0x03A2
   14bc0:	86 30       	cpi	r24, 0x06	; 6
   14bc2:	78 f0       	brcs	.+30     	; 0x14be2 <FMenuLocalAccount+0x11d4>
				    stLocalAccount=laConTimout;
   14bc4:	84 e0       	ldi	r24, 0x04	; 4
   14bc6:	80 93 5c 01 	sts	0x015C, r24
					TimLocAcc=0;
   14bca:	10 92 d3 01 	sts	0x01D3, r1
   14bce:	10 92 d2 01 	sts	0x01D2, r1
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   14bd2:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   14bd4:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   14bd6:	82 e0       	ldi	r24, 0x02	; 2
   14bd8:	90 e0       	ldi	r25, 0x00	; 0
   14bda:	90 93 d7 01 	sts	0x01D7, r25
   14bde:	80 93 d6 01 	sts	0x01D6, r24
				if (iWait>5){
				    stLocalAccount=laConTimout;
					TimLocAcc=0;
					system_beep(2);
				    }
				if (IsMessage00==True){
   14be2:	80 91 b5 01 	lds	r24, 0x01B5
   14be6:	81 30       	cpi	r24, 0x01	; 1
   14be8:	09 f0       	breq	.+2      	; 0x14bec <FMenuLocalAccount+0x11de>
   14bea:	3d c1       	rjmp	.+634    	; 0x14e66 <FMenuLocalAccount+0x1458>
                    IsMessage00=False;
   14bec:	10 92 b5 01 	sts	0x01B5, r1
				    stLocalAccount=laProcMessage00;
   14bf0:	88 e1       	ldi	r24, 0x18	; 24
   14bf2:	66 ce       	rjmp	.-820    	; 0x148c0 <FMenuLocalAccount+0xeb2>
*/
char procMessage00(){
     char Result,strSend[10];
	 Result=MSG00_NACK;
	 //Message57
	 if((rcv_trans[0]==0x01)&&(transLength==MSG00_LENGTH)){
   14bf4:	80 91 f5 0a 	lds	r24, 0x0AF5
   14bf8:	81 30       	cpi	r24, 0x01	; 1
   14bfa:	51 f4       	brne	.+20     	; 0x14c10 <FMenuLocalAccount+0x1202>
   14bfc:	80 91 9e 01 	lds	r24, 0x019E
   14c00:	90 91 9f 01 	lds	r25, 0x019F
   14c04:	8f 97       	sbiw	r24, 0x2f	; 47
   14c06:	21 f4       	brne	.+8      	; 0x14c10 <FMenuLocalAccount+0x1202>
	     //Reply
		 Result=(CharPosCopy(rcv_trans,37)-'0');
   14c08:	80 91 1a 0b 	lds	r24, 0x0B1A
   14c0c:	80 53       	subi	r24, 0x30	; 48
   14c0e:	01 c0       	rjmp	.+2      	; 0x14c12 <FMenuLocalAccount+0x1204>
   14c10:	80 e0       	ldi	r24, 0x00	; 0
                    IsMessage00=False;
				    stLocalAccount=laProcMessage00;
					}
		        break;
           case laProcMessage00:
		        LocAccStatus=procMessage00();
   14c12:	80 93 a4 03 	sts	0x03A4, r24
                lcd_clear();
   14c16:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
		        switch(LocAccStatus){
   14c1a:	10 91 a4 03 	lds	r17, 0x03A4
   14c1e:	11 30       	cpi	r17, 0x01	; 1
   14c20:	51 f0       	breq	.+20     	; 0x14c36 <FMenuLocalAccount+0x1228>
   14c22:	11 30       	cpi	r17, 0x01	; 1
   14c24:	18 f0       	brcs	.+6      	; 0x14c2c <FMenuLocalAccount+0x121e>
   14c26:	13 30       	cpi	r17, 0x03	; 3
   14c28:	69 f5       	brne	.+90     	; 0x14c84 <FMenuLocalAccount+0x1276>
   14c2a:	1b c0       	rjmp	.+54     	; 0x14c62 <FMenuLocalAccount+0x1254>
				case MSG00_NACK:
                     lcd_printf(2,1,PSTR("Authorisasi Gagal   "));
   14c2c:	82 e0       	ldi	r24, 0x02	; 2
   14c2e:	61 e0       	ldi	r22, 0x01	; 1
   14c30:	44 eb       	ldi	r20, 0xB4	; 180
   14c32:	5d e1       	ldi	r21, 0x1D	; 29
   14c34:	1a c0       	rjmp	.+52     	; 0x14c6a <FMenuLocalAccount+0x125c>
					 system_beep(2); 
					 stLocalAccount=laDelayExit;
				     break;
                case MSG00_ACK:
				     lcd_printf(2,1,PSTR("Authorisasi Berhasil"));
   14c36:	82 e0       	ldi	r24, 0x02	; 2
   14c38:	61 e0       	ldi	r22, 0x01	; 1
   14c3a:	4f e9       	ldi	r20, 0x9F	; 159
   14c3c:	5d e1       	ldi	r21, 0x1D	; 29
   14c3e:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
				     LocalAccountFIP[nLocalAccount]=FIP_Used;
   14c42:	90 91 a4 01 	lds	r25, 0x01A4
   14c46:	e9 2f       	mov	r30, r25
   14c48:	f0 e0       	ldi	r31, 0x00	; 0
   14c4a:	ea 5c       	subi	r30, 0xCA	; 202
   14c4c:	fa 4f       	sbci	r31, 0xFA	; 250
   14c4e:	80 91 76 03 	lds	r24, 0x0376
   14c52:	80 83       	st	Z, r24
					 nLocalAccount++;
   14c54:	9f 5f       	subi	r25, 0xFF	; 255
   14c56:	90 93 a4 01 	sts	0x01A4, r25
					 IsViewFillingFIP=True;
   14c5a:	10 93 ad 01 	sts	0x01AD, r17
					 stLocalAccount=laViewStatus;
   14c5e:	86 e1       	ldi	r24, 0x16	; 22
   14c60:	0f c0       	rjmp	.+30     	; 0x14c80 <FMenuLocalAccount+0x1272>
				     break;
                case MSG00_NO_FIP:
                     lcd_printf(2,1,PSTR("FIP Tidak Siap    "));
   14c62:	82 e0       	ldi	r24, 0x02	; 2
   14c64:	61 e0       	ldi	r22, 0x01	; 1
   14c66:	4c e8       	ldi	r20, 0x8C	; 140
   14c68:	5d e1       	ldi	r21, 0x1D	; 29
   14c6a:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   14c6e:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   14c70:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   14c72:	82 e0       	ldi	r24, 0x02	; 2
   14c74:	90 e0       	ldi	r25, 0x00	; 0
   14c76:	90 93 d7 01 	sts	0x01D7, r25
   14c7a:	80 93 d6 01 	sts	0x01D6, r24
					 stLocalAccount=laViewStatus;
				     break;
                case MSG00_NO_FIP:
                     lcd_printf(2,1,PSTR("FIP Tidak Siap    "));
					 system_beep(2);
					 stLocalAccount=laDelayExit;
   14c7e:	8e e1       	ldi	r24, 0x1E	; 30
   14c80:	80 93 5c 01 	sts	0x015C, r24
				     break;
				}
				TimLocAcc=0;
   14c84:	10 92 d3 01 	sts	0x01D3, r1
   14c88:	10 92 d2 01 	sts	0x01D2, r1
				ClearMem(strOdometer);
   14c8c:	83 ea       	ldi	r24, 0xA3	; 163
   14c8e:	95 e0       	ldi	r25, 0x05	; 5
   14c90:	0e 94 01 af 	call	0x15e02	; 0x15e02 <ClearMem>
	            ClearMem(strLicPlate);
   14c94:	82 ed       	ldi	r24, 0xD2	; 210
   14c96:	9a e0       	ldi	r25, 0x0A	; 10
   14c98:	0e 94 01 af 	call	0x15e02	; 0x15e02 <ClearMem>
   14c9c:	e4 c0       	rjmp	.+456    	; 0x14e66 <FMenuLocalAccount+0x1458>
		        break;
           case laViewStatus:
                if (TimLocAcc>20)stLocalAccount=laExitLocAcc;//laDisplayTransaction;
   14c9e:	80 91 d2 01 	lds	r24, 0x01D2
   14ca2:	90 91 d3 01 	lds	r25, 0x01D3
   14ca6:	45 97       	sbiw	r24, 0x15	; 21
   14ca8:	08 f4       	brcc	.+2      	; 0x14cac <FMenuLocalAccount+0x129e>
   14caa:	dd c0       	rjmp	.+442    	; 0x14e66 <FMenuLocalAccount+0x1458>
   14cac:	d3 c0       	rjmp	.+422    	; 0x14e54 <FMenuLocalAccount+0x1446>
		        break; 
           case laDisplayTransaction:
		        lcd_clear();
   14cae:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
                sprintf_P(lcdteks,PSTR("P%s %s "),strFIP,strProduct); lcd_print(1,1,lcdteks);    //"P01  Pertamax 500000"
   14cb2:	2d b7       	in	r18, 0x3d	; 61
   14cb4:	3e b7       	in	r19, 0x3e	; 62
   14cb6:	28 50       	subi	r18, 0x08	; 8
   14cb8:	30 40       	sbci	r19, 0x00	; 0
   14cba:	0f b6       	in	r0, 0x3f	; 63
   14cbc:	f8 94       	cli
   14cbe:	3e bf       	out	0x3e, r19	; 62
   14cc0:	0f be       	out	0x3f, r0	; 63
   14cc2:	2d bf       	out	0x3d, r18	; 61
   14cc4:	ed b7       	in	r30, 0x3d	; 61
   14cc6:	fe b7       	in	r31, 0x3e	; 62
   14cc8:	31 96       	adiw	r30, 0x01	; 1
   14cca:	7e 01       	movw	r14, r28
   14ccc:	08 94       	sec
   14cce:	e1 1c       	adc	r14, r1
   14cd0:	f1 1c       	adc	r15, r1
   14cd2:	ad b7       	in	r26, 0x3d	; 61
   14cd4:	be b7       	in	r27, 0x3e	; 62
   14cd6:	12 96       	adiw	r26, 0x02	; 2
   14cd8:	fc 92       	st	X, r15
   14cda:	ee 92       	st	-X, r14
   14cdc:	11 97       	sbiw	r26, 0x01	; 1
   14cde:	84 e8       	ldi	r24, 0x84	; 132
   14ce0:	9d e1       	ldi	r25, 0x1D	; 29
   14ce2:	93 83       	std	Z+3, r25	; 0x03
   14ce4:	82 83       	std	Z+2, r24	; 0x02
   14ce6:	8d e9       	ldi	r24, 0x9D	; 157
   14ce8:	93 e0       	ldi	r25, 0x03	; 3
   14cea:	95 83       	std	Z+5, r25	; 0x05
   14cec:	84 83       	std	Z+4, r24	; 0x04
   14cee:	81 e4       	ldi	r24, 0x41	; 65
   14cf0:	99 e0       	ldi	r25, 0x09	; 9
   14cf2:	97 83       	std	Z+7, r25	; 0x07
   14cf4:	86 83       	std	Z+6, r24	; 0x06
   14cf6:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
   14cfa:	ed b7       	in	r30, 0x3d	; 61
   14cfc:	fe b7       	in	r31, 0x3e	; 62
   14cfe:	38 96       	adiw	r30, 0x08	; 8
   14d00:	0f b6       	in	r0, 0x3f	; 63
   14d02:	f8 94       	cli
   14d04:	fe bf       	out	0x3e, r31	; 62
   14d06:	0f be       	out	0x3f, r0	; 63
   14d08:	ed bf       	out	0x3d, r30	; 61
   14d0a:	81 e0       	ldi	r24, 0x01	; 1
   14d0c:	61 e0       	ldi	r22, 0x01	; 1
   14d0e:	a7 01       	movw	r20, r14
   14d10:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
		        sprintf_P(lcdteks,PSTR("%s"),strBalanceValue);        lcd_print(1,15,lcdteks);   //"ID1CCDA565          " 
   14d14:	00 d0       	rcall	.+0      	; 0x14d16 <FMenuLocalAccount+0x1308>
   14d16:	00 d0       	rcall	.+0      	; 0x14d18 <FMenuLocalAccount+0x130a>
   14d18:	00 d0       	rcall	.+0      	; 0x14d1a <FMenuLocalAccount+0x130c>
   14d1a:	ed b7       	in	r30, 0x3d	; 61
   14d1c:	fe b7       	in	r31, 0x3e	; 62
   14d1e:	31 96       	adiw	r30, 0x01	; 1
   14d20:	ad b7       	in	r26, 0x3d	; 61
   14d22:	be b7       	in	r27, 0x3e	; 62
   14d24:	12 96       	adiw	r26, 0x02	; 2
   14d26:	fc 92       	st	X, r15
   14d28:	ee 92       	st	-X, r14
   14d2a:	11 97       	sbiw	r26, 0x01	; 1
   14d2c:	81 e8       	ldi	r24, 0x81	; 129
   14d2e:	9d e1       	ldi	r25, 0x1D	; 29
   14d30:	93 83       	std	Z+3, r25	; 0x03
   14d32:	82 83       	std	Z+2, r24	; 0x02
   14d34:	8a ef       	ldi	r24, 0xFA	; 250
   14d36:	9d e0       	ldi	r25, 0x0D	; 13
   14d38:	95 83       	std	Z+5, r25	; 0x05
   14d3a:	84 83       	std	Z+4, r24	; 0x04
   14d3c:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
   14d40:	ed b7       	in	r30, 0x3d	; 61
   14d42:	fe b7       	in	r31, 0x3e	; 62
   14d44:	36 96       	adiw	r30, 0x06	; 6
   14d46:	0f b6       	in	r0, 0x3f	; 63
   14d48:	f8 94       	cli
   14d4a:	fe bf       	out	0x3e, r31	; 62
   14d4c:	0f be       	out	0x3f, r0	; 63
   14d4e:	ed bf       	out	0x3d, r30	; 61
   14d50:	81 e0       	ldi	r24, 0x01	; 1
   14d52:	6f e0       	ldi	r22, 0x0F	; 15
   14d54:	a7 01       	movw	r20, r14
   14d56:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
                RemSpaceLead(strCardID);
   14d5a:	01 e6       	ldi	r16, 0x61	; 97
   14d5c:	1d e0       	ldi	r17, 0x0D	; 13
   14d5e:	c8 01       	movw	r24, r16
   14d60:	0e 94 01 26 	call	0x4c02	; 0x4c02 <RemSpaceLead>
				sprintf_P(lcdteks,PSTR("ID: %s"),strCardID);          lcd_print(2,1,lcdteks);
   14d64:	00 d0       	rcall	.+0      	; 0x14d66 <FMenuLocalAccount+0x1358>
   14d66:	00 d0       	rcall	.+0      	; 0x14d68 <FMenuLocalAccount+0x135a>
   14d68:	00 d0       	rcall	.+0      	; 0x14d6a <FMenuLocalAccount+0x135c>
   14d6a:	ed b7       	in	r30, 0x3d	; 61
   14d6c:	fe b7       	in	r31, 0x3e	; 62
   14d6e:	31 96       	adiw	r30, 0x01	; 1
   14d70:	ad b7       	in	r26, 0x3d	; 61
   14d72:	be b7       	in	r27, 0x3e	; 62
   14d74:	12 96       	adiw	r26, 0x02	; 2
   14d76:	fc 92       	st	X, r15
   14d78:	ee 92       	st	-X, r14
   14d7a:	11 97       	sbiw	r26, 0x01	; 1
   14d7c:	8a e7       	ldi	r24, 0x7A	; 122
   14d7e:	9d e1       	ldi	r25, 0x1D	; 29
   14d80:	93 83       	std	Z+3, r25	; 0x03
   14d82:	82 83       	std	Z+2, r24	; 0x02
   14d84:	15 83       	std	Z+5, r17	; 0x05
   14d86:	04 83       	std	Z+4, r16	; 0x04
   14d88:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
   14d8c:	ed b7       	in	r30, 0x3d	; 61
   14d8e:	fe b7       	in	r31, 0x3e	; 62
   14d90:	36 96       	adiw	r30, 0x06	; 6
   14d92:	0f b6       	in	r0, 0x3f	; 63
   14d94:	f8 94       	cli
   14d96:	fe bf       	out	0x3e, r31	; 62
   14d98:	0f be       	out	0x3f, r0	; 63
   14d9a:	ed bf       	out	0x3d, r30	; 61
   14d9c:	82 e0       	ldi	r24, 0x02	; 2
   14d9e:	61 e0       	ldi	r22, 0x01	; 1
   14da0:	a7 01       	movw	r20, r14
   14da2:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>
				TimLocAcc=0;
   14da6:	10 92 d3 01 	sts	0x01D3, r1
   14daa:	10 92 d2 01 	sts	0x01D2, r1
		        IsCompleteFilling=False;
   14dae:	10 92 c0 01 	sts	0x01C0, r1
				stLocalAccount=laWaitFilling;
   14db2:	8d e1       	ldi	r24, 0x1D	; 29
   14db4:	85 cd       	rjmp	.-1270   	; 0x148c0 <FMenuLocalAccount+0xeb2>
		        break; 
           case laWaitFilling:
				if ((IsCompleteFilling==True)||(TimLocAcc>FILLING_TIMOUT)){
   14db6:	80 91 c0 01 	lds	r24, 0x01C0
   14dba:	81 30       	cpi	r24, 0x01	; 1
   14dbc:	39 f0       	breq	.+14     	; 0x14dcc <FMenuLocalAccount+0x13be>
   14dbe:	80 91 d2 01 	lds	r24, 0x01D2
   14dc2:	90 91 d3 01 	lds	r25, 0x01D3
   14dc6:	0b 97       	sbiw	r24, 0x0b	; 11
   14dc8:	08 f4       	brcc	.+2      	; 0x14dcc <FMenuLocalAccount+0x13be>
   14dca:	4d c0       	rjmp	.+154    	; 0x14e66 <FMenuLocalAccount+0x1458>
				    IsCompleteFilling=False;
   14dcc:	10 92 c0 01 	sts	0x01C0, r1
				    stLocalAccount=laSuccessTransaction;
   14dd0:	89 e1       	ldi	r24, 0x19	; 25
   14dd2:	80 93 5c 01 	sts	0x015C, r24
					TimLocAcc=0;
   14dd6:	10 92 d3 01 	sts	0x01D3, r1
   14dda:	10 92 d2 01 	sts	0x01D2, r1
   14dde:	43 c0       	rjmp	.+134    	; 0x14e66 <FMenuLocalAccount+0x1458>
					}
		        break;
           case laSuccessTransaction:
				lcd_clear();lcd_printf(2,1,PSTR("Transaksi Selesai"));
   14de0:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
   14de4:	82 e0       	ldi	r24, 0x02	; 2
   14de6:	61 e0       	ldi	r22, 0x01	; 1
   14de8:	48 e6       	ldi	r20, 0x68	; 104
   14dea:	5d e1       	ldi	r21, 0x1D	; 29
   14dec:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
				//Show Status FIP
				sprintf_P(lcdteks,PSTR("Fueling @FIP:#%d"),FIP_Used);
   14df0:	00 d0       	rcall	.+0      	; 0x14df2 <FMenuLocalAccount+0x13e4>
   14df2:	00 d0       	rcall	.+0      	; 0x14df4 <FMenuLocalAccount+0x13e6>
   14df4:	00 d0       	rcall	.+0      	; 0x14df6 <FMenuLocalAccount+0x13e8>
   14df6:	ed b7       	in	r30, 0x3d	; 61
   14df8:	fe b7       	in	r31, 0x3e	; 62
   14dfa:	31 96       	adiw	r30, 0x01	; 1
   14dfc:	8e 01       	movw	r16, r28
   14dfe:	0f 5f       	subi	r16, 0xFF	; 255
   14e00:	1f 4f       	sbci	r17, 0xFF	; 255
   14e02:	ad b7       	in	r26, 0x3d	; 61
   14e04:	be b7       	in	r27, 0x3e	; 62
   14e06:	12 96       	adiw	r26, 0x02	; 2
   14e08:	1c 93       	st	X, r17
   14e0a:	0e 93       	st	-X, r16
   14e0c:	11 97       	sbiw	r26, 0x01	; 1
   14e0e:	87 e5       	ldi	r24, 0x57	; 87
   14e10:	9d e1       	ldi	r25, 0x1D	; 29
   14e12:	93 83       	std	Z+3, r25	; 0x03
   14e14:	82 83       	std	Z+2, r24	; 0x02
   14e16:	80 91 76 03 	lds	r24, 0x0376
   14e1a:	84 83       	std	Z+4, r24	; 0x04
   14e1c:	15 82       	std	Z+5, r1	; 0x05
   14e1e:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
				lcd_print(3,1,lcdteks);
   14e22:	ed b7       	in	r30, 0x3d	; 61
   14e24:	fe b7       	in	r31, 0x3e	; 62
   14e26:	36 96       	adiw	r30, 0x06	; 6
   14e28:	0f b6       	in	r0, 0x3f	; 63
   14e2a:	f8 94       	cli
   14e2c:	fe bf       	out	0x3e, r31	; 62
   14e2e:	0f be       	out	0x3f, r0	; 63
   14e30:	ed bf       	out	0x3d, r30	; 61
   14e32:	83 e0       	ldi	r24, 0x03	; 3
   14e34:	61 e0       	ldi	r22, 0x01	; 1
   14e36:	a8 01       	movw	r20, r16
   14e38:	0e 94 68 ae 	call	0x15cd0	; 0x15cd0 <lcd_print>

				TimLocAcc=0;
				stLocalAccount=laDelayExit;
		        break;
           case laFailedTransaction:
		        TimLocAcc=0;
   14e3c:	10 92 d3 01 	sts	0x01D3, r1
   14e40:	10 92 d2 01 	sts	0x01D2, r1
		        //Show Failed Report
				stLocalAccount=laDelayExit;
   14e44:	8e e1       	ldi	r24, 0x1E	; 30
   14e46:	3c cd       	rjmp	.-1416   	; 0x148c0 <FMenuLocalAccount+0xeb2>
		        break;
           case laDelayExit:
		        if (TimLocAcc>15)stLocalAccount=laExitLocAcc;
   14e48:	80 91 d2 01 	lds	r24, 0x01D2
   14e4c:	90 91 d3 01 	lds	r25, 0x01D3
   14e50:	40 97       	sbiw	r24, 0x10	; 16
   14e52:	48 f0       	brcs	.+18     	; 0x14e66 <FMenuLocalAccount+0x1458>
   14e54:	8f e1       	ldi	r24, 0x1F	; 31
   14e56:	34 cd       	rjmp	.-1432   	; 0x148c0 <FMenuLocalAccount+0xeb2>
		        break;
           case laExitLocAcc:
		        Result=MENU_DONE;
				stLocalAccount=laInit;
   14e58:	81 e0       	ldi	r24, 0x01	; 1
   14e5a:	80 93 5c 01 	sts	0x015C, r24
				lcd_clear();
   14e5e:	0e 94 c1 ae 	call	0x15d82	; 0x15d82 <lcd_clear>
   14e62:	81 e0       	ldi	r24, 0x01	; 1
   14e64:	01 c0       	rjmp	.+2      	; 0x14e68 <FMenuLocalAccount+0x145a>
   14e66:	80 e0       	ldi	r24, 0x00	; 0
		        break;
	       }//EndSwitch
return Result;
}
   14e68:	a9 96       	adiw	r28, 0x29	; 41
   14e6a:	0f b6       	in	r0, 0x3f	; 63
   14e6c:	f8 94       	cli
   14e6e:	de bf       	out	0x3e, r29	; 62
   14e70:	0f be       	out	0x3f, r0	; 63
   14e72:	cd bf       	out	0x3d, r28	; 61
   14e74:	cf 91       	pop	r28
   14e76:	df 91       	pop	r29
   14e78:	1f 91       	pop	r17
   14e7a:	0f 91       	pop	r16
   14e7c:	ff 90       	pop	r15
   14e7e:	ef 90       	pop	r14
   14e80:	df 90       	pop	r13
   14e82:	cf 90       	pop	r12
   14e84:	bf 90       	pop	r11
   14e86:	af 90       	pop	r10
   14e88:	08 95       	ret

00014e8a <SendConfigParamater>:
          stConfigProtocol=cpWaitSend;
	      break;
	 }
}

void SendConfigParamater(){
   14e8a:	8f 92       	push	r8
   14e8c:	9f 92       	push	r9
   14e8e:	af 92       	push	r10
   14e90:	bf 92       	push	r11
   14e92:	cf 92       	push	r12
   14e94:	df 92       	push	r13
   14e96:	ef 92       	push	r14
   14e98:	ff 92       	push	r15
   14e9a:	0f 93       	push	r16
   14e9c:	1f 93       	push	r17
   14e9e:	df 93       	push	r29
   14ea0:	cf 93       	push	r28
   14ea2:	cd b7       	in	r28, 0x3d	; 61
   14ea4:	de b7       	in	r29, 0x3e	; 62
   14ea6:	c5 56       	subi	r28, 0x65	; 101
   14ea8:	d0 40       	sbci	r29, 0x00	; 0
   14eaa:	0f b6       	in	r0, 0x3f	; 63
   14eac:	f8 94       	cli
   14eae:	de bf       	out	0x3e, r29	; 62
   14eb0:	0f be       	out	0x3f, r0	; 63
   14eb2:	cd bf       	out	0x3d, r28	; 61
char i,j,strSend[60];
char strEEPROM[41],xEEPROM;

     //Start
	 _uart_printf(1,0,PSTR("<"));
   14eb4:	81 e0       	ldi	r24, 0x01	; 1
   14eb6:	60 e0       	ldi	r22, 0x00	; 0
   14eb8:	48 e7       	ldi	r20, 0x78	; 120
   14eba:	52 e2       	ldi	r21, 0x22	; 34
   14ebc:	0e 94 1a b4 	call	0x16834	; 0x16834 <_uart_printf>
   14ec0:	07 e2       	ldi	r16, 0x27	; 39
   14ec2:	12 e0       	ldi	r17, 0x02	; 2
   14ec4:	6e 01       	movw	r12, r28
   14ec6:	08 94       	sec
   14ec8:	c1 1c       	adc	r12, r1
   14eca:	d1 1c       	adc	r13, r1
     //Header Footer 400
	 for (i=0;i<10;i++){
	      eeprom_read_block((void*) &strEEPROM, (const void*) &DefHeaderFooter[i],sizeof(DefHeaderFooter[i]));
		  FillChar(strSend,0,sizeof(strSend));
	      sprintf_P(strSend,PSTR("%s"),strEEPROM);
   14ecc:	7a e2       	ldi	r23, 0x2A	; 42
   14ece:	e7 2e       	mov	r14, r23
   14ed0:	f1 2c       	mov	r15, r1
   14ed2:	ec 0e       	add	r14, r28
   14ed4:	fd 1e       	adc	r15, r29
   14ed6:	65 e7       	ldi	r22, 0x75	; 117
   14ed8:	a6 2e       	mov	r10, r22
   14eda:	62 e2       	ldi	r22, 0x22	; 34
   14edc:	b6 2e       	mov	r11, r22
   14ede:	c6 01       	movw	r24, r12
   14ee0:	b8 01       	movw	r22, r16
   14ee2:	49 e2       	ldi	r20, 0x29	; 41
   14ee4:	50 e0       	ldi	r21, 0x00	; 0
   14ee6:	26 ef       	ldi	r18, 0xF6	; 246
   14ee8:	32 e1       	ldi	r19, 0x12	; 18
   14eea:	0e 94 7a b5 	call	0x16af4	; 0x16af4 <__eerd_block>
   14eee:	00 d0       	rcall	.+0      	; 0x14ef0 <SendConfigParamater+0x66>
   14ef0:	00 d0       	rcall	.+0      	; 0x14ef2 <SendConfigParamater+0x68>
   14ef2:	00 d0       	rcall	.+0      	; 0x14ef4 <SendConfigParamater+0x6a>
   14ef4:	ed b7       	in	r30, 0x3d	; 61
   14ef6:	fe b7       	in	r31, 0x3e	; 62
   14ef8:	31 96       	adiw	r30, 0x01	; 1
   14efa:	ad b7       	in	r26, 0x3d	; 61
   14efc:	be b7       	in	r27, 0x3e	; 62
   14efe:	12 96       	adiw	r26, 0x02	; 2
   14f00:	fc 92       	st	X, r15
   14f02:	ee 92       	st	-X, r14
   14f04:	11 97       	sbiw	r26, 0x01	; 1
   14f06:	b3 82       	std	Z+3, r11	; 0x03
   14f08:	a2 82       	std	Z+2, r10	; 0x02
   14f0a:	d5 82       	std	Z+5, r13	; 0x05
   14f0c:	c4 82       	std	Z+4, r12	; 0x04
   14f0e:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
		  AddSpaceLag(strSend,40);
   14f12:	ed b7       	in	r30, 0x3d	; 61
   14f14:	fe b7       	in	r31, 0x3e	; 62
   14f16:	36 96       	adiw	r30, 0x06	; 6
   14f18:	0f b6       	in	r0, 0x3f	; 63
   14f1a:	f8 94       	cli
   14f1c:	fe bf       	out	0x3e, r31	; 62
   14f1e:	0f be       	out	0x3f, r0	; 63
   14f20:	ed bf       	out	0x3d, r30	; 61
   14f22:	c7 01       	movw	r24, r14
   14f24:	68 e2       	ldi	r22, 0x28	; 40
   14f26:	0e 94 40 2e 	call	0x5c80	; 0x5c80 <AddSpaceLag>
		  _uart_print(1,0,strSend);
   14f2a:	81 e0       	ldi	r24, 0x01	; 1
   14f2c:	60 e0       	ldi	r22, 0x00	; 0
   14f2e:	a7 01       	movw	r20, r14
   14f30:	0e 94 f2 b3 	call	0x167e4	; 0x167e4 <_uart_print>
   14f34:	07 5d       	subi	r16, 0xD7	; 215
   14f36:	1f 4f       	sbci	r17, 0xFF	; 255
char strEEPROM[41],xEEPROM;

     //Start
	 _uart_printf(1,0,PSTR("<"));
     //Header Footer 400
	 for (i=0;i<10;i++){
   14f38:	f3 e0       	ldi	r31, 0x03	; 3
   14f3a:	01 3c       	cpi	r16, 0xC1	; 193
   14f3c:	1f 07       	cpc	r17, r31
   14f3e:	79 f6       	brne	.-98     	; 0x14ede <SendConfigParamater+0x54>
   14f40:	0b eb       	ldi	r16, 0xBB	; 187
   14f42:	10 e0       	ldi	r17, 0x00	; 0
   14f44:	6e 01       	movw	r12, r28
   14f46:	08 94       	sec
   14f48:	c1 1c       	adc	r12, r1
   14f4a:	d1 1c       	adc	r13, r1
	 }
	 //ProductName 72 
	 for (i=0;i<6;i++){
		 eeprom_read_block((void*) &strEEPROM, (const void*) &DefProductName[i],sizeof(DefProductName[i]));
		 FillChar(strSend,0,sizeof(strSend));
	     sprintf_P(strSend,PSTR("%s"),strEEPROM);
   14f4c:	5a e2       	ldi	r21, 0x2A	; 42
   14f4e:	e5 2e       	mov	r14, r21
   14f50:	f1 2c       	mov	r15, r1
   14f52:	ec 0e       	add	r14, r28
   14f54:	fd 1e       	adc	r15, r29
   14f56:	42 e7       	ldi	r20, 0x72	; 114
   14f58:	a4 2e       	mov	r10, r20
   14f5a:	42 e2       	ldi	r20, 0x22	; 34
   14f5c:	b4 2e       	mov	r11, r20
   14f5e:	c6 01       	movw	r24, r12
   14f60:	b8 01       	movw	r22, r16
   14f62:	4d e0       	ldi	r20, 0x0D	; 13
   14f64:	50 e0       	ldi	r21, 0x00	; 0
   14f66:	26 ef       	ldi	r18, 0xF6	; 246
   14f68:	32 e1       	ldi	r19, 0x12	; 18
   14f6a:	0e 94 7a b5 	call	0x16af4	; 0x16af4 <__eerd_block>
   14f6e:	00 d0       	rcall	.+0      	; 0x14f70 <SendConfigParamater+0xe6>
   14f70:	00 d0       	rcall	.+0      	; 0x14f72 <SendConfigParamater+0xe8>
   14f72:	00 d0       	rcall	.+0      	; 0x14f74 <SendConfigParamater+0xea>
   14f74:	ed b7       	in	r30, 0x3d	; 61
   14f76:	fe b7       	in	r31, 0x3e	; 62
   14f78:	31 96       	adiw	r30, 0x01	; 1
   14f7a:	ad b7       	in	r26, 0x3d	; 61
   14f7c:	be b7       	in	r27, 0x3e	; 62
   14f7e:	12 96       	adiw	r26, 0x02	; 2
   14f80:	fc 92       	st	X, r15
   14f82:	ee 92       	st	-X, r14
   14f84:	11 97       	sbiw	r26, 0x01	; 1
   14f86:	b3 82       	std	Z+3, r11	; 0x03
   14f88:	a2 82       	std	Z+2, r10	; 0x02
   14f8a:	d5 82       	std	Z+5, r13	; 0x05
   14f8c:	c4 82       	std	Z+4, r12	; 0x04
   14f8e:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
		 AddSpaceLag(strSend,12);
   14f92:	ed b7       	in	r30, 0x3d	; 61
   14f94:	fe b7       	in	r31, 0x3e	; 62
   14f96:	36 96       	adiw	r30, 0x06	; 6
   14f98:	0f b6       	in	r0, 0x3f	; 63
   14f9a:	f8 94       	cli
   14f9c:	fe bf       	out	0x3e, r31	; 62
   14f9e:	0f be       	out	0x3f, r0	; 63
   14fa0:	ed bf       	out	0x3d, r30	; 61
   14fa2:	c7 01       	movw	r24, r14
   14fa4:	6c e0       	ldi	r22, 0x0C	; 12
   14fa6:	0e 94 40 2e 	call	0x5c80	; 0x5c80 <AddSpaceLag>
		 _uart_print(1,0,strSend);
   14faa:	81 e0       	ldi	r24, 0x01	; 1
   14fac:	60 e0       	ldi	r22, 0x00	; 0
   14fae:	a7 01       	movw	r20, r14
   14fb0:	0e 94 f2 b3 	call	0x167e4	; 0x167e4 <_uart_print>
   14fb4:	03 5f       	subi	r16, 0xF3	; 243
   14fb6:	1f 4f       	sbci	r17, 0xFF	; 255
	      sprintf_P(strSend,PSTR("%s"),strEEPROM);
		  AddSpaceLag(strSend,40);
		  _uart_print(1,0,strSend);
	 }
	 //ProductName 72 
	 for (i=0;i<6;i++){
   14fb8:	f1 e0       	ldi	r31, 0x01	; 1
   14fba:	09 30       	cpi	r16, 0x09	; 9
   14fbc:	1f 07       	cpc	r17, r31
   14fbe:	79 f6       	brne	.-98     	; 0x14f5e <SendConfigParamater+0xd4>
   14fc0:	05 e8       	ldi	r16, 0x85	; 133
   14fc2:	10 e0       	ldi	r17, 0x00	; 0
   14fc4:	6e 01       	movw	r12, r28
   14fc6:	08 94       	sec
   14fc8:	c1 1c       	adc	r12, r1
   14fca:	d1 1c       	adc	r13, r1
	 }
	 //ProductPrice 30
	 for (i=0;i<6;i++){
		 eeprom_read_block((void*) &strEEPROM, (const void*) &DefProductPrice[i],sizeof(DefProductPrice[i]));
		 FillChar(strSend,0,sizeof(strSend));
	     sprintf_P(strSend,PSTR("%s"),strEEPROM);
   14fcc:	3a e2       	ldi	r19, 0x2A	; 42
   14fce:	e3 2e       	mov	r14, r19
   14fd0:	f1 2c       	mov	r15, r1
   14fd2:	ec 0e       	add	r14, r28
   14fd4:	fd 1e       	adc	r15, r29
   14fd6:	2f e6       	ldi	r18, 0x6F	; 111
   14fd8:	a2 2e       	mov	r10, r18
   14fda:	22 e2       	ldi	r18, 0x22	; 34
   14fdc:	b2 2e       	mov	r11, r18
   14fde:	c6 01       	movw	r24, r12
   14fe0:	b8 01       	movw	r22, r16
   14fe2:	49 e0       	ldi	r20, 0x09	; 9
   14fe4:	50 e0       	ldi	r21, 0x00	; 0
   14fe6:	26 ef       	ldi	r18, 0xF6	; 246
   14fe8:	32 e1       	ldi	r19, 0x12	; 18
   14fea:	0e 94 7a b5 	call	0x16af4	; 0x16af4 <__eerd_block>
   14fee:	00 d0       	rcall	.+0      	; 0x14ff0 <SendConfigParamater+0x166>
   14ff0:	00 d0       	rcall	.+0      	; 0x14ff2 <SendConfigParamater+0x168>
   14ff2:	00 d0       	rcall	.+0      	; 0x14ff4 <SendConfigParamater+0x16a>
   14ff4:	ed b7       	in	r30, 0x3d	; 61
   14ff6:	fe b7       	in	r31, 0x3e	; 62
   14ff8:	31 96       	adiw	r30, 0x01	; 1
   14ffa:	ad b7       	in	r26, 0x3d	; 61
   14ffc:	be b7       	in	r27, 0x3e	; 62
   14ffe:	12 96       	adiw	r26, 0x02	; 2
   15000:	fc 92       	st	X, r15
   15002:	ee 92       	st	-X, r14
   15004:	11 97       	sbiw	r26, 0x01	; 1
   15006:	b3 82       	std	Z+3, r11	; 0x03
   15008:	a2 82       	std	Z+2, r10	; 0x02
   1500a:	d5 82       	std	Z+5, r13	; 0x05
   1500c:	c4 82       	std	Z+4, r12	; 0x04
   1500e:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
		 AddSpaceLag(strSend,5);
   15012:	ed b7       	in	r30, 0x3d	; 61
   15014:	fe b7       	in	r31, 0x3e	; 62
   15016:	36 96       	adiw	r30, 0x06	; 6
   15018:	0f b6       	in	r0, 0x3f	; 63
   1501a:	f8 94       	cli
   1501c:	fe bf       	out	0x3e, r31	; 62
   1501e:	0f be       	out	0x3f, r0	; 63
   15020:	ed bf       	out	0x3d, r30	; 61
   15022:	c7 01       	movw	r24, r14
   15024:	65 e0       	ldi	r22, 0x05	; 5
   15026:	0e 94 40 2e 	call	0x5c80	; 0x5c80 <AddSpaceLag>
		 _uart_print(1,0,strSend);
   1502a:	81 e0       	ldi	r24, 0x01	; 1
   1502c:	60 e0       	ldi	r22, 0x00	; 0
   1502e:	a7 01       	movw	r20, r14
   15030:	0e 94 f2 b3 	call	0x167e4	; 0x167e4 <_uart_print>
   15034:	07 5f       	subi	r16, 0xF7	; 247
   15036:	1f 4f       	sbci	r17, 0xFF	; 255
	     sprintf_P(strSend,PSTR("%s"),strEEPROM);
		 AddSpaceLag(strSend,12);
		 _uart_print(1,0,strSend);
	 }
	 //ProductPrice 30
	 for (i=0;i<6;i++){
   15038:	f0 e0       	ldi	r31, 0x00	; 0
   1503a:	0b 3b       	cpi	r16, 0xBB	; 187
   1503c:	1f 07       	cpc	r17, r31
   1503e:	79 f6       	brne	.-98     	; 0x14fde <SendConfigParamater+0x154>
   15040:	05 e4       	ldi	r16, 0x45	; 69
   15042:	10 e0       	ldi	r17, 0x00	; 0
	 //PumpID Config 8
	 for (i=0;i<8;i++){
	      xEEPROM=eeprom_read_byte(&DefPumpMap[i]);
		  if (xEEPROM>=100)xEEPROM=0;
		  FillChar(strSend,0,sizeof(strSend));
	      sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
   15044:	9a e2       	ldi	r25, 0x2A	; 42
   15046:	e9 2e       	mov	r14, r25
   15048:	f1 2c       	mov	r15, r1
   1504a:	ec 0e       	add	r14, r28
   1504c:	fd 1e       	adc	r15, r29
   1504e:	8a e6       	ldi	r24, 0x6A	; 106
   15050:	c8 2e       	mov	r12, r24
   15052:	82 e2       	ldi	r24, 0x22	; 34
   15054:	d8 2e       	mov	r13, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   15056:	e1 99       	sbic	0x1c, 1	; 28
   15058:	fe cf       	rjmp	.-4      	; 0x15056 <SendConfigParamater+0x1cc>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   1505a:	1f bb       	out	0x1f, r17	; 31
   1505c:	0e bb       	out	0x1e, r16	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   1505e:	e0 9a       	sbi	0x1c, 0	; 28
   15060:	8d b3       	in	r24, 0x1d	; 29
		 _uart_print(1,0,strSend);
	 }
	 //PumpID Config 8
	 for (i=0;i<8;i++){
	      xEEPROM=eeprom_read_byte(&DefPumpMap[i]);
		  if (xEEPROM>=100)xEEPROM=0;
   15062:	84 36       	cpi	r24, 0x64	; 100
   15064:	08 f0       	brcs	.+2      	; 0x15068 <SendConfigParamater+0x1de>
   15066:	80 e0       	ldi	r24, 0x00	; 0
		  FillChar(strSend,0,sizeof(strSend));
	      sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
   15068:	00 d0       	rcall	.+0      	; 0x1506a <SendConfigParamater+0x1e0>
   1506a:	00 d0       	rcall	.+0      	; 0x1506c <SendConfigParamater+0x1e2>
   1506c:	00 d0       	rcall	.+0      	; 0x1506e <SendConfigParamater+0x1e4>
   1506e:	ed b7       	in	r30, 0x3d	; 61
   15070:	fe b7       	in	r31, 0x3e	; 62
   15072:	31 96       	adiw	r30, 0x01	; 1
   15074:	ad b7       	in	r26, 0x3d	; 61
   15076:	be b7       	in	r27, 0x3e	; 62
   15078:	12 96       	adiw	r26, 0x02	; 2
   1507a:	fc 92       	st	X, r15
   1507c:	ee 92       	st	-X, r14
   1507e:	11 97       	sbiw	r26, 0x01	; 1
   15080:	d3 82       	std	Z+3, r13	; 0x03
   15082:	c2 82       	std	Z+2, r12	; 0x02
   15084:	84 83       	std	Z+4, r24	; 0x04
   15086:	15 82       	std	Z+5, r1	; 0x05
   15088:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
		  AddSpaceLag(strSend,2);
   1508c:	ed b7       	in	r30, 0x3d	; 61
   1508e:	fe b7       	in	r31, 0x3e	; 62
   15090:	36 96       	adiw	r30, 0x06	; 6
   15092:	0f b6       	in	r0, 0x3f	; 63
   15094:	f8 94       	cli
   15096:	fe bf       	out	0x3e, r31	; 62
   15098:	0f be       	out	0x3f, r0	; 63
   1509a:	ed bf       	out	0x3d, r30	; 61
   1509c:	c7 01       	movw	r24, r14
   1509e:	62 e0       	ldi	r22, 0x02	; 2
   150a0:	0e 94 40 2e 	call	0x5c80	; 0x5c80 <AddSpaceLag>
		 _uart_print(1,0,strSend);
   150a4:	81 e0       	ldi	r24, 0x01	; 1
   150a6:	60 e0       	ldi	r22, 0x00	; 0
   150a8:	a7 01       	movw	r20, r14
   150aa:	0e 94 f2 b3 	call	0x167e4	; 0x167e4 <_uart_print>
   150ae:	0f 5f       	subi	r16, 0xFF	; 255
   150b0:	1f 4f       	sbci	r17, 0xFF	; 255
	     sprintf_P(strSend,PSTR("%s"),strEEPROM);
		 AddSpaceLag(strSend,5);
		 _uart_print(1,0,strSend);
	 }
	 //PumpID Config 8
	 for (i=0;i<8;i++){
   150b2:	f0 e0       	ldi	r31, 0x00	; 0
   150b4:	0d 34       	cpi	r16, 0x4D	; 77
   150b6:	1f 07       	cpc	r17, r31
   150b8:	71 f6       	brne	.-100    	; 0x15056 <SendConfigParamater+0x1cc>
   150ba:	b5 e5       	ldi	r27, 0x55	; 85
   150bc:	eb 2e       	mov	r14, r27
   150be:	b0 e0       	ldi	r27, 0x00	; 0
   150c0:	fb 2e       	mov	r15, r27
	 //PumpID NozzleConfig 48
	 for (i=0;i<8;i++){
	      for (j=0;j<6;j++){
		       xEEPROM=eeprom_read_byte(&DefNozzleMap[i][j]);     
			   if (xEEPROM>=10)xEEPROM=0;
			   sprintf_P(strSend,PSTR("%d"),xEEPROM);
   150c2:	aa e2       	ldi	r26, 0x2A	; 42
   150c4:	aa 2e       	mov	r10, r26
   150c6:	b1 2c       	mov	r11, r1
   150c8:	ac 0e       	add	r10, r28
   150ca:	bd 1e       	adc	r11, r29
   150cc:	f7 e6       	ldi	r31, 0x67	; 103
   150ce:	8f 2e       	mov	r8, r31
   150d0:	f2 e2       	ldi	r31, 0x22	; 34
   150d2:	9f 2e       	mov	r9, r31
   150d4:	37 c0       	rjmp	.+110    	; 0x15144 <SendConfigParamater+0x2ba>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   150d6:	e1 99       	sbic	0x1c, 1	; 28
   150d8:	fe cf       	rjmp	.-4      	; 0x150d6 <SendConfigParamater+0x24c>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   150da:	1f bb       	out	0x1f, r17	; 31
   150dc:	0e bb       	out	0x1e, r16	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   150de:	e0 9a       	sbi	0x1c, 0	; 28
   150e0:	8d b3       	in	r24, 0x1d	; 29
	 }
	 //PumpID NozzleConfig 48
	 for (i=0;i<8;i++){
	      for (j=0;j<6;j++){
		       xEEPROM=eeprom_read_byte(&DefNozzleMap[i][j]);     
			   if (xEEPROM>=10)xEEPROM=0;
   150e2:	8a 30       	cpi	r24, 0x0A	; 10
   150e4:	08 f0       	brcs	.+2      	; 0x150e8 <SendConfigParamater+0x25e>
   150e6:	80 e0       	ldi	r24, 0x00	; 0
			   sprintf_P(strSend,PSTR("%d"),xEEPROM);
   150e8:	00 d0       	rcall	.+0      	; 0x150ea <SendConfigParamater+0x260>
   150ea:	00 d0       	rcall	.+0      	; 0x150ec <SendConfigParamater+0x262>
   150ec:	00 d0       	rcall	.+0      	; 0x150ee <SendConfigParamater+0x264>
   150ee:	ed b7       	in	r30, 0x3d	; 61
   150f0:	fe b7       	in	r31, 0x3e	; 62
   150f2:	31 96       	adiw	r30, 0x01	; 1
   150f4:	ad b7       	in	r26, 0x3d	; 61
   150f6:	be b7       	in	r27, 0x3e	; 62
   150f8:	12 96       	adiw	r26, 0x02	; 2
   150fa:	bc 92       	st	X, r11
   150fc:	ae 92       	st	-X, r10
   150fe:	11 97       	sbiw	r26, 0x01	; 1
   15100:	93 82       	std	Z+3, r9	; 0x03
   15102:	82 82       	std	Z+2, r8	; 0x02
   15104:	84 83       	std	Z+4, r24	; 0x04
   15106:	15 82       	std	Z+5, r1	; 0x05
   15108:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
			   _uart_print(1,0,strSend);
   1510c:	ed b7       	in	r30, 0x3d	; 61
   1510e:	fe b7       	in	r31, 0x3e	; 62
   15110:	36 96       	adiw	r30, 0x06	; 6
   15112:	0f b6       	in	r0, 0x3f	; 63
   15114:	f8 94       	cli
   15116:	fe bf       	out	0x3e, r31	; 62
   15118:	0f be       	out	0x3f, r0	; 63
   1511a:	ed bf       	out	0x3d, r30	; 61
   1511c:	81 e0       	ldi	r24, 0x01	; 1
   1511e:	60 e0       	ldi	r22, 0x00	; 0
   15120:	a5 01       	movw	r20, r10
   15122:	0e 94 f2 b3 	call	0x167e4	; 0x167e4 <_uart_print>
		  AddSpaceLag(strSend,2);
		 _uart_print(1,0,strSend);
	 }
	 //PumpID NozzleConfig 48
	 for (i=0;i<8;i++){
	      for (j=0;j<6;j++){
   15126:	d3 94       	inc	r13
   15128:	0f 5f       	subi	r16, 0xFF	; 255
   1512a:	1f 4f       	sbci	r17, 0xFF	; 255
   1512c:	f6 e0       	ldi	r31, 0x06	; 6
   1512e:	df 16       	cp	r13, r31
   15130:	91 f6       	brne	.-92     	; 0x150d6 <SendConfigParamater+0x24c>
   15132:	86 e0       	ldi	r24, 0x06	; 6
   15134:	90 e0       	ldi	r25, 0x00	; 0
   15136:	e8 0e       	add	r14, r24
   15138:	f9 1e       	adc	r15, r25
	      sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
		  AddSpaceLag(strSend,2);
		 _uart_print(1,0,strSend);
	 }
	 //PumpID NozzleConfig 48
	 for (i=0;i<8;i++){
   1513a:	95 e8       	ldi	r25, 0x85	; 133
   1513c:	e9 16       	cp	r14, r25
   1513e:	90 e0       	ldi	r25, 0x00	; 0
   15140:	f9 06       	cpc	r15, r25
   15142:	19 f0       	breq	.+6      	; 0x1514a <SendConfigParamater+0x2c0>
   15144:	87 01       	movw	r16, r14
   15146:	dd 24       	eor	r13, r13
   15148:	c6 cf       	rjmp	.-116    	; 0x150d6 <SendConfigParamater+0x24c>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   1514a:	e1 99       	sbic	0x1c, 1	; 28
   1514c:	fe cf       	rjmp	.-4      	; 0x1514a <SendConfigParamater+0x2c0>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   1514e:	81 ec       	ldi	r24, 0xC1	; 193
   15150:	93 e0       	ldi	r25, 0x03	; 3
   15152:	9f bb       	out	0x1f, r25	; 31
   15154:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   15156:	e0 9a       	sbi	0x1c, 0	; 28
   15158:	8d b3       	in	r24, 0x1d	; 29
   1515a:	9e 01       	movw	r18, r28
   1515c:	26 5d       	subi	r18, 0xD6	; 214
   1515e:	3f 4f       	sbci	r19, 0xFF	; 255
			   _uart_print(1,0,strSend);
		  }
	 }
	 //PrintNoMoney
	 xEEPROM=eeprom_read_byte(&DefPrintMoney);
	 if (xEEPROM==True){
   15160:	81 30       	cpi	r24, 0x01	; 1
   15162:	79 f4       	brne	.+30     	; 0x15182 <SendConfigParamater+0x2f8>
		 sprintf_P(strSend,PSTR("1"));
   15164:	00 d0       	rcall	.+0      	; 0x15166 <SendConfigParamater+0x2dc>
   15166:	00 d0       	rcall	.+0      	; 0x15168 <SendConfigParamater+0x2de>
   15168:	ad b7       	in	r26, 0x3d	; 61
   1516a:	be b7       	in	r27, 0x3e	; 62
   1516c:	12 96       	adiw	r26, 0x02	; 2
   1516e:	3c 93       	st	X, r19
   15170:	2e 93       	st	-X, r18
   15172:	11 97       	sbiw	r26, 0x01	; 1
   15174:	85 e6       	ldi	r24, 0x65	; 101
   15176:	92 e2       	ldi	r25, 0x22	; 34
   15178:	14 96       	adiw	r26, 0x04	; 4
   1517a:	9c 93       	st	X, r25
   1517c:	8e 93       	st	-X, r24
   1517e:	13 97       	sbiw	r26, 0x03	; 3
   15180:	0a c0       	rjmp	.+20     	; 0x15196 <SendConfigParamater+0x30c>
	 }else{
	     sprintf_P(strSend,PSTR("0"));
   15182:	00 d0       	rcall	.+0      	; 0x15184 <SendConfigParamater+0x2fa>
   15184:	00 d0       	rcall	.+0      	; 0x15186 <SendConfigParamater+0x2fc>
   15186:	ed b7       	in	r30, 0x3d	; 61
   15188:	fe b7       	in	r31, 0x3e	; 62
   1518a:	32 83       	std	Z+2, r19	; 0x02
   1518c:	21 83       	std	Z+1, r18	; 0x01
   1518e:	83 e6       	ldi	r24, 0x63	; 99
   15190:	92 e2       	ldi	r25, 0x22	; 34
   15192:	94 83       	std	Z+4, r25	; 0x04
   15194:	83 83       	std	Z+3, r24	; 0x03
   15196:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
   1519a:	0f 90       	pop	r0
   1519c:	0f 90       	pop	r0
   1519e:	0f 90       	pop	r0
   151a0:	0f 90       	pop	r0
	 }_uart_print(1,0,strSend);
   151a2:	81 e0       	ldi	r24, 0x01	; 1
   151a4:	60 e0       	ldi	r22, 0x00	; 0
   151a6:	ae 01       	movw	r20, r28
   151a8:	46 5d       	subi	r20, 0xD6	; 214
   151aa:	5f 4f       	sbci	r21, 0xFF	; 255
   151ac:	0e 94 f2 b3 	call	0x167e4	; 0x167e4 <_uart_print>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   151b0:	e1 99       	sbic	0x1c, 1	; 28
   151b2:	fe cf       	rjmp	.-4      	; 0x151b0 <SendConfigParamater+0x326>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   151b4:	80 e0       	ldi	r24, 0x00	; 0
   151b6:	90 e0       	ldi	r25, 0x00	; 0
   151b8:	9f bb       	out	0x1f, r25	; 31
   151ba:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   151bc:	e0 9a       	sbi	0x1c, 0	; 28
   151be:	2d b3       	in	r18, 0x1d	; 29
	 //TermId
     xEEPROM=eeprom_read_byte(&DefIFT_ID);     
     sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
   151c0:	00 d0       	rcall	.+0      	; 0x151c2 <SendConfigParamater+0x338>
   151c2:	00 d0       	rcall	.+0      	; 0x151c4 <SendConfigParamater+0x33a>
   151c4:	00 d0       	rcall	.+0      	; 0x151c6 <SendConfigParamater+0x33c>
   151c6:	ed b7       	in	r30, 0x3d	; 61
   151c8:	fe b7       	in	r31, 0x3e	; 62
   151ca:	31 96       	adiw	r30, 0x01	; 1
   151cc:	8e 01       	movw	r16, r28
   151ce:	06 5d       	subi	r16, 0xD6	; 214
   151d0:	1f 4f       	sbci	r17, 0xFF	; 255
   151d2:	ad b7       	in	r26, 0x3d	; 61
   151d4:	be b7       	in	r27, 0x3e	; 62
   151d6:	12 96       	adiw	r26, 0x02	; 2
   151d8:	1c 93       	st	X, r17
   151da:	0e 93       	st	-X, r16
   151dc:	11 97       	sbiw	r26, 0x01	; 1
   151de:	8e e5       	ldi	r24, 0x5E	; 94
   151e0:	92 e2       	ldi	r25, 0x22	; 34
   151e2:	93 83       	std	Z+3, r25	; 0x03
   151e4:	82 83       	std	Z+2, r24	; 0x02
   151e6:	24 83       	std	Z+4, r18	; 0x04
   151e8:	15 82       	std	Z+5, r1	; 0x05
   151ea:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
     _uart_print(1,0,strSend);
   151ee:	ed b7       	in	r30, 0x3d	; 61
   151f0:	fe b7       	in	r31, 0x3e	; 62
   151f2:	36 96       	adiw	r30, 0x06	; 6
   151f4:	0f b6       	in	r0, 0x3f	; 63
   151f6:	f8 94       	cli
   151f8:	fe bf       	out	0x3e, r31	; 62
   151fa:	0f be       	out	0x3f, r0	; 63
   151fc:	ed bf       	out	0x3d, r30	; 61
   151fe:	81 e0       	ldi	r24, 0x01	; 1
   15200:	60 e0       	ldi	r22, 0x00	; 0
   15202:	a8 01       	movw	r20, r16
   15204:	0e 94 f2 b3 	call	0x167e4	; 0x167e4 <_uart_print>
   15208:	ed e4       	ldi	r30, 0x4D	; 77
   1520a:	ee 2e       	mov	r14, r30
   1520c:	e0 e0       	ldi	r30, 0x00	; 0
   1520e:	fe 2e       	mov	r15, r30
	 //PumpLabel
     for (i=0;i<8;i++){
	      xEEPROM=eeprom_read_byte(&DefPumpLabel[i]);
		  if (xEEPROM>=100)xEEPROM=0;
		  FillChar(strSend,0,sizeof(strSend));
	      sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
   15210:	d0 2e       	mov	r13, r16
   15212:	01 2f       	mov	r16, r17
   15214:	79 e5       	ldi	r23, 0x59	; 89
   15216:	a7 2e       	mov	r10, r23
   15218:	72 e2       	ldi	r23, 0x22	; 34
   1521a:	b7 2e       	mov	r11, r23
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   1521c:	e1 99       	sbic	0x1c, 1	; 28
   1521e:	fe cf       	rjmp	.-4      	; 0x1521c <SendConfigParamater+0x392>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   15220:	ff ba       	out	0x1f, r15	; 31
   15222:	ee ba       	out	0x1e, r14	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   15224:	e0 9a       	sbi	0x1c, 0	; 28
   15226:	8d b3       	in	r24, 0x1d	; 29
     sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
     _uart_print(1,0,strSend);
	 //PumpLabel
     for (i=0;i<8;i++){
	      xEEPROM=eeprom_read_byte(&DefPumpLabel[i]);
		  if (xEEPROM>=100)xEEPROM=0;
   15228:	84 36       	cpi	r24, 0x64	; 100
   1522a:	08 f0       	brcs	.+2      	; 0x1522e <SendConfigParamater+0x3a4>
   1522c:	80 e0       	ldi	r24, 0x00	; 0
		  FillChar(strSend,0,sizeof(strSend));
	      sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
   1522e:	00 d0       	rcall	.+0      	; 0x15230 <SendConfigParamater+0x3a6>
   15230:	00 d0       	rcall	.+0      	; 0x15232 <SendConfigParamater+0x3a8>
   15232:	00 d0       	rcall	.+0      	; 0x15234 <SendConfigParamater+0x3aa>
   15234:	ed b7       	in	r30, 0x3d	; 61
   15236:	fe b7       	in	r31, 0x3e	; 62
   15238:	31 96       	adiw	r30, 0x01	; 1
   1523a:	ad b7       	in	r26, 0x3d	; 61
   1523c:	be b7       	in	r27, 0x3e	; 62
   1523e:	11 96       	adiw	r26, 0x01	; 1
   15240:	dc 92       	st	X, r13
   15242:	11 97       	sbiw	r26, 0x01	; 1
   15244:	12 96       	adiw	r26, 0x02	; 2
   15246:	0c 93       	st	X, r16
   15248:	b3 82       	std	Z+3, r11	; 0x03
   1524a:	a2 82       	std	Z+2, r10	; 0x02
   1524c:	84 83       	std	Z+4, r24	; 0x04
   1524e:	15 82       	std	Z+5, r1	; 0x05
   15250:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
		  AddSpaceLag(strSend,2);
   15254:	ed b7       	in	r30, 0x3d	; 61
   15256:	fe b7       	in	r31, 0x3e	; 62
   15258:	36 96       	adiw	r30, 0x06	; 6
   1525a:	0f b6       	in	r0, 0x3f	; 63
   1525c:	f8 94       	cli
   1525e:	fe bf       	out	0x3e, r31	; 62
   15260:	0f be       	out	0x3f, r0	; 63
   15262:	ed bf       	out	0x3d, r30	; 61
   15264:	8d 2d       	mov	r24, r13
   15266:	90 2f       	mov	r25, r16
   15268:	62 e0       	ldi	r22, 0x02	; 2
   1526a:	0e 94 40 2e 	call	0x5c80	; 0x5c80 <AddSpaceLag>
		 _uart_print(1,0,strSend);
   1526e:	81 e0       	ldi	r24, 0x01	; 1
   15270:	60 e0       	ldi	r22, 0x00	; 0
   15272:	4d 2d       	mov	r20, r13
   15274:	50 2f       	mov	r21, r16
   15276:	0e 94 f2 b3 	call	0x167e4	; 0x167e4 <_uart_print>
   1527a:	08 94       	sec
   1527c:	e1 1c       	adc	r14, r1
   1527e:	f1 1c       	adc	r15, r1
	 //TermId
     xEEPROM=eeprom_read_byte(&DefIFT_ID);     
     sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
     _uart_print(1,0,strSend);
	 //PumpLabel
     for (i=0;i<8;i++){
   15280:	f5 e5       	ldi	r31, 0x55	; 85
   15282:	ef 16       	cp	r14, r31
   15284:	f0 e0       	ldi	r31, 0x00	; 0
   15286:	ff 06       	cpc	r15, r31
   15288:	49 f6       	brne	.-110    	; 0x1521c <SendConfigParamater+0x392>
		  FillChar(strSend,0,sizeof(strSend));
	      sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
		  AddSpaceLag(strSend,2);
		 _uart_print(1,0,strSend);
	 }
	 _uart_printf(1,1,PSTR(">"));
   1528a:	81 e0       	ldi	r24, 0x01	; 1
   1528c:	61 e0       	ldi	r22, 0x01	; 1
   1528e:	47 e5       	ldi	r20, 0x57	; 87
   15290:	52 e2       	ldi	r21, 0x22	; 34
   15292:	0e 94 1a b4 	call	0x16834	; 0x16834 <_uart_printf>
	 //End
}
   15296:	cb 59       	subi	r28, 0x9B	; 155
   15298:	df 4f       	sbci	r29, 0xFF	; 255
   1529a:	0f b6       	in	r0, 0x3f	; 63
   1529c:	f8 94       	cli
   1529e:	de bf       	out	0x3e, r29	; 62
   152a0:	0f be       	out	0x3f, r0	; 63
   152a2:	cd bf       	out	0x3d, r28	; 61
   152a4:	cf 91       	pop	r28
   152a6:	df 91       	pop	r29
   152a8:	1f 91       	pop	r17
   152aa:	0f 91       	pop	r16
   152ac:	ff 90       	pop	r15
   152ae:	ef 90       	pop	r14
   152b0:	df 90       	pop	r13
   152b2:	cf 90       	pop	r12
   152b4:	bf 90       	pop	r11
   152b6:	af 90       	pop	r10
   152b8:	9f 90       	pop	r9
   152ba:	8f 90       	pop	r8
   152bc:	08 95       	ret

000152be <SaveConfigParameter>:
     char Result;
	 Result=False;
   return Result;
}

void SaveConfigParameter(){
   152be:	8f 92       	push	r8
   152c0:	9f 92       	push	r9
   152c2:	af 92       	push	r10
   152c4:	bf 92       	push	r11
   152c6:	cf 92       	push	r12
   152c8:	df 92       	push	r13
   152ca:	ef 92       	push	r14
   152cc:	ff 92       	push	r15
   152ce:	0f 93       	push	r16
   152d0:	1f 93       	push	r17
   152d2:	df 93       	push	r29
   152d4:	cf 93       	push	r28
   152d6:	cd b7       	in	r28, 0x3d	; 61
   152d8:	de b7       	in	r29, 0x3e	; 62
   152da:	c6 54       	subi	r28, 0x46	; 70
   152dc:	d0 40       	sbci	r29, 0x00	; 0
   152de:	0f b6       	in	r0, 0x3f	; 63
   152e0:	f8 94       	cli
   152e2:	de bf       	out	0x3e, r29	; 62
   152e4:	0f be       	out	0x3f, r0	; 63
   152e6:	cd bf       	out	0x3d, r28	; 61
char i,j;
char strEEPROM[50],xEEPROM;
unsigned int StrPos;
char strSend[20];
     
	 sprintf_P(strSend,PSTR("Length:%d"),transLength);
   152e8:	00 d0       	rcall	.+0      	; 0x152ea <SaveConfigParameter+0x2c>
   152ea:	00 d0       	rcall	.+0      	; 0x152ec <SaveConfigParameter+0x2e>
   152ec:	00 d0       	rcall	.+0      	; 0x152ee <SaveConfigParameter+0x30>
   152ee:	ed b7       	in	r30, 0x3d	; 61
   152f0:	fe b7       	in	r31, 0x3e	; 62
   152f2:	31 96       	adiw	r30, 0x01	; 1
   152f4:	8e 01       	movw	r16, r28
   152f6:	0f 5f       	subi	r16, 0xFF	; 255
   152f8:	1f 4f       	sbci	r17, 0xFF	; 255
   152fa:	ad b7       	in	r26, 0x3d	; 61
   152fc:	be b7       	in	r27, 0x3e	; 62
   152fe:	12 96       	adiw	r26, 0x02	; 2
   15300:	1c 93       	st	X, r17
   15302:	0e 93       	st	-X, r16
   15304:	11 97       	sbiw	r26, 0x01	; 1
   15306:	81 e9       	ldi	r24, 0x91	; 145
   15308:	92 e2       	ldi	r25, 0x22	; 34
   1530a:	93 83       	std	Z+3, r25	; 0x03
   1530c:	82 83       	std	Z+2, r24	; 0x02
   1530e:	80 91 9e 01 	lds	r24, 0x019E
   15312:	90 91 9f 01 	lds	r25, 0x019F
   15316:	95 83       	std	Z+5, r25	; 0x05
   15318:	84 83       	std	Z+4, r24	; 0x04
   1531a:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
	 _uart_print(1,1,strSend);
   1531e:	ed b7       	in	r30, 0x3d	; 61
   15320:	fe b7       	in	r31, 0x3e	; 62
   15322:	36 96       	adiw	r30, 0x06	; 6
   15324:	0f b6       	in	r0, 0x3f	; 63
   15326:	f8 94       	cli
   15328:	fe bf       	out	0x3e, r31	; 62
   1532a:	0f be       	out	0x3f, r0	; 63
   1532c:	ed bf       	out	0x3d, r30	; 61
   1532e:	81 e0       	ldi	r24, 0x01	; 1
   15330:	61 e0       	ldi	r22, 0x01	; 1
   15332:	a8 01       	movw	r20, r16
   15334:	0e 94 f2 b3 	call	0x167e4	; 0x167e4 <_uart_print>

     StrPos=0;
	 _uart_printf(1,1,PSTR("<Saving>")); 
   15338:	81 e0       	ldi	r24, 0x01	; 1
   1533a:	61 e0       	ldi	r22, 0x01	; 1
   1533c:	48 e8       	ldi	r20, 0x88	; 136
   1533e:	52 e2       	ldi	r21, 0x22	; 34
   15340:	0e 94 1a b4 	call	0x16834	; 0x16834 <_uart_printf>
   15344:	07 e2       	ldi	r16, 0x27	; 39
   15346:	12 e0       	ldi	r17, 0x02	; 2
   15348:	a5 ef       	ldi	r26, 0xF5	; 245
   1534a:	ea 2e       	mov	r14, r26
   1534c:	aa e0       	ldi	r26, 0x0A	; 10
   1534e:	fa 2e       	mov	r15, r26
   15350:	f5 e1       	ldi	r31, 0x15	; 21
   15352:	af 2e       	mov	r10, r31
   15354:	b1 2c       	mov	r11, r1
   15356:	ac 0e       	add	r10, r28
   15358:	bd 1e       	adc	r11, r29
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   1535a:	ed e3       	ldi	r30, 0x3D	; 61
   1535c:	ce 2e       	mov	r12, r30
   1535e:	d1 2c       	mov	r13, r1
   15360:	cc 0e       	add	r12, r28
   15362:	dd 1e       	adc	r13, r29
     
	 sprintf_P(strSend,PSTR("Length:%d"),transLength);
	 _uart_print(1,1,strSend);

     StrPos=0;
	 _uart_printf(1,1,PSTR("<Saving>")); 
   15364:	d7 01       	movw	r26, r14
   15366:	f5 01       	movw	r30, r10
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   15368:	8d 91       	ld	r24, X+
   1536a:	81 93       	st	Z+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   1536c:	ec 15       	cp	r30, r12
   1536e:	fd 05       	cpc	r31, r13
   15370:	d9 f7       	brne	.-10     	; 0x15368 <SaveConfigParameter+0xaa>
	 _uart_printf(1,1,PSTR("<Saving>")); 
     //HeaderFooter
	 for(i=0;i<10;i++){
         FillChar(strEEPROM,0,sizeof(strEEPROM));   
		 StrPosCopy(rcv_trans,strEEPROM,(StrPos+(40*i)),40);
		 strEEPROM[40]=0;
   15372:	1d ae       	std	Y+61, r1	; 0x3d
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
   15374:	c8 01       	movw	r24, r16
   15376:	b5 01       	movw	r22, r10
   15378:	49 e2       	ldi	r20, 0x29	; 41
   1537a:	50 e0       	ldi	r21, 0x00	; 0
   1537c:	2e ef       	ldi	r18, 0xFE	; 254
   1537e:	32 e1       	ldi	r19, 0x12	; 18
   15380:	0e 94 96 b5 	call	0x16b2c	; 0x16b2c <__eewr_block>
   15384:	07 5d       	subi	r16, 0xD7	; 215
   15386:	1f 4f       	sbci	r17, 0xFF	; 255
   15388:	88 e2       	ldi	r24, 0x28	; 40
   1538a:	90 e0       	ldi	r25, 0x00	; 0
   1538c:	e8 0e       	add	r14, r24
   1538e:	f9 1e       	adc	r15, r25
	 _uart_print(1,1,strSend);

     StrPos=0;
	 _uart_printf(1,1,PSTR("<Saving>")); 
     //HeaderFooter
	 for(i=0;i<10;i++){
   15390:	93 e0       	ldi	r25, 0x03	; 3
   15392:	01 3c       	cpi	r16, 0xC1	; 193
   15394:	19 07       	cpc	r17, r25
   15396:	31 f7       	brne	.-52     	; 0x15364 <SaveConfigParameter+0xa6>
   15398:	0b eb       	ldi	r16, 0xBB	; 187
   1539a:	10 e0       	ldi	r17, 0x00	; 0
   1539c:	75 e8       	ldi	r23, 0x85	; 133
   1539e:	e7 2e       	mov	r14, r23
   153a0:	7c e0       	ldi	r23, 0x0C	; 12
   153a2:	f7 2e       	mov	r15, r23
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   153a4:	65 e1       	ldi	r22, 0x15	; 21
   153a6:	c6 2e       	mov	r12, r22
   153a8:	d1 2c       	mov	r13, r1
   153aa:	cc 0e       	add	r12, r28
   153ac:	dd 1e       	adc	r13, r29
   153ae:	51 e2       	ldi	r21, 0x21	; 33
   153b0:	85 2e       	mov	r8, r21
   153b2:	91 2c       	mov	r9, r1
   153b4:	8c 0e       	add	r8, r28
   153b6:	9d 1e       	adc	r9, r29
	 _uart_print(1,1,strSend);

     StrPos=0;
	 _uart_printf(1,1,PSTR("<Saving>")); 
     //HeaderFooter
	 for(i=0;i<10;i++){
   153b8:	d7 01       	movw	r26, r14
   153ba:	f5 01       	movw	r30, r10
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   153bc:	8d 91       	ld	r24, X+
   153be:	81 93       	st	Z+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   153c0:	e8 15       	cp	r30, r8
   153c2:	f9 05       	cpc	r31, r9
   153c4:	d9 f7       	brne	.-10     	; 0x153bc <SaveConfigParameter+0xfe>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   153c6:	19 a2       	std	Y+33, r1	; 0x21
	 //ProductName
	 StrPos=(40*10);
	 for(i=0;i<6;i++){
         FillChar(strEEPROM,0,sizeof(strEEPROM));   
		 StrPosCopy(rcv_trans,strEEPROM,(StrPos+(12*i)),12);
		 RemSpaceLag(strEEPROM);
   153c8:	c6 01       	movw	r24, r12
   153ca:	0e 94 4c 26 	call	0x4c98	; 0x4c98 <RemSpaceLag>
		 strEEPROM[strlen(strEEPROM)]=0;
   153ce:	f6 01       	movw	r30, r12
   153d0:	01 90       	ld	r0, Z+
   153d2:	00 20       	and	r0, r0
   153d4:	e9 f7       	brne	.-6      	; 0x153d0 <SaveConfigParameter+0x112>
   153d6:	31 97       	sbiw	r30, 0x01	; 1
   153d8:	10 82       	st	Z, r1
   153da:	c8 01       	movw	r24, r16
   153dc:	b6 01       	movw	r22, r12
   153de:	4d e0       	ldi	r20, 0x0D	; 13
   153e0:	50 e0       	ldi	r21, 0x00	; 0
   153e2:	2e ef       	ldi	r18, 0xFE	; 254
   153e4:	32 e1       	ldi	r19, 0x12	; 18
   153e6:	0e 94 96 b5 	call	0x16b2c	; 0x16b2c <__eewr_block>
   153ea:	03 5f       	subi	r16, 0xF3	; 243
   153ec:	1f 4f       	sbci	r17, 0xFF	; 255
   153ee:	ac e0       	ldi	r26, 0x0C	; 12
   153f0:	b0 e0       	ldi	r27, 0x00	; 0
   153f2:	ea 0e       	add	r14, r26
   153f4:	fb 1e       	adc	r15, r27
		 eeprom_write_block((const void*) &strEEPROM, (void*) &DefHeaderFooter[i],41);
		 //_uart_print(1,1,strEEPROM);
	 }
	 //ProductName
	 StrPos=(40*10);
	 for(i=0;i<6;i++){
   153f6:	b1 e0       	ldi	r27, 0x01	; 1
   153f8:	09 30       	cpi	r16, 0x09	; 9
   153fa:	1b 07       	cpc	r17, r27
   153fc:	e9 f6       	brne	.-70     	; 0x153b8 <SaveConfigParameter+0xfa>
   153fe:	05 e8       	ldi	r16, 0x85	; 133
   15400:	10 e0       	ldi	r17, 0x00	; 0
   15402:	4d ec       	ldi	r20, 0xCD	; 205
   15404:	e4 2e       	mov	r14, r20
   15406:	4c e0       	ldi	r20, 0x0C	; 12
   15408:	f4 2e       	mov	r15, r20
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   1540a:	35 e1       	ldi	r19, 0x15	; 21
   1540c:	c3 2e       	mov	r12, r19
   1540e:	d1 2c       	mov	r13, r1
   15410:	cc 0e       	add	r12, r28
   15412:	dd 1e       	adc	r13, r29
   15414:	2a e1       	ldi	r18, 0x1A	; 26
   15416:	82 2e       	mov	r8, r18
   15418:	91 2c       	mov	r9, r1
   1541a:	8c 0e       	add	r8, r28
   1541c:	9d 1e       	adc	r9, r29
		 eeprom_write_block((const void*) &strEEPROM, (void*) &DefHeaderFooter[i],41);
		 //_uart_print(1,1,strEEPROM);
	 }
	 //ProductName
	 StrPos=(40*10);
	 for(i=0;i<6;i++){
   1541e:	d7 01       	movw	r26, r14
   15420:	f5 01       	movw	r30, r10
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   15422:	8d 91       	ld	r24, X+
   15424:	81 93       	st	Z+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   15426:	e8 15       	cp	r30, r8
   15428:	f9 05       	cpc	r31, r9
   1542a:	d9 f7       	brne	.-10     	; 0x15422 <SaveConfigParameter+0x164>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   1542c:	1a 8e       	std	Y+26, r1	; 0x1a
	 //ProductPrice
	 StrPos=(40*10)+(12*6);
	 for(i=0;i<6;i++){
         FillChar(strEEPROM,0,sizeof(strEEPROM));   
		 StrPosCopy(rcv_trans,strEEPROM,(StrPos+(5*i)),5);
		 RemSpaceLag(strEEPROM);
   1542e:	c6 01       	movw	r24, r12
   15430:	0e 94 4c 26 	call	0x4c98	; 0x4c98 <RemSpaceLag>
   15434:	c8 01       	movw	r24, r16
   15436:	b6 01       	movw	r22, r12
   15438:	49 e0       	ldi	r20, 0x09	; 9
   1543a:	50 e0       	ldi	r21, 0x00	; 0
   1543c:	2e ef       	ldi	r18, 0xFE	; 254
   1543e:	32 e1       	ldi	r19, 0x12	; 18
   15440:	0e 94 96 b5 	call	0x16b2c	; 0x16b2c <__eewr_block>
   15444:	07 5f       	subi	r16, 0xF7	; 247
   15446:	1f 4f       	sbci	r17, 0xFF	; 255
   15448:	e5 e0       	ldi	r30, 0x05	; 5
   1544a:	f0 e0       	ldi	r31, 0x00	; 0
   1544c:	ee 0e       	add	r14, r30
   1544e:	ff 1e       	adc	r15, r31
		// _uart_print(1,1,strEEPROM);

	 }    
	 //ProductPrice
	 StrPos=(40*10)+(12*6);
	 for(i=0;i<6;i++){
   15450:	f0 e0       	ldi	r31, 0x00	; 0
   15452:	0b 3b       	cpi	r16, 0xBB	; 187
   15454:	1f 07       	cpc	r17, r31
   15456:	19 f7       	brne	.-58     	; 0x1541e <SaveConfigParameter+0x160>
   15458:	0b ee       	ldi	r16, 0xEB	; 235
   1545a:	1c e0       	ldi	r17, 0x0C	; 12
   1545c:	95 e4       	ldi	r25, 0x45	; 69
   1545e:	e9 2e       	mov	r14, r25
   15460:	90 e0       	ldi	r25, 0x00	; 0
   15462:	f9 2e       	mov	r15, r25
	 //PumpID Config
	 StrPos=(40*10)+(12*6)+(5*6);
	 for(i=0;i<8;i++){
         FillChar(strEEPROM,0,sizeof(strEEPROM));   
		 StrPosCopy(rcv_trans,strEEPROM,(StrPos+(2*i)),2);
		 RemZeroLead(strEEPROM);
   15464:	85 e1       	ldi	r24, 0x15	; 21
   15466:	c8 2e       	mov	r12, r24
   15468:	d1 2c       	mov	r13, r1
   1546a:	cc 0e       	add	r12, r28
   1546c:	dd 1e       	adc	r13, r29
		 xEEPROM=atoi(strEEPROM);
         eeprom_write_byte(&DefPumpMap[i],xEEPROM);
		 sprintf_P(strSend,PSTR("%d"),xEEPROM);
   1546e:	4e 01       	movw	r8, r28
   15470:	08 94       	sec
   15472:	81 1c       	adc	r8, r1
   15474:	91 1c       	adc	r9, r1
   15476:	b5 e8       	ldi	r27, 0x85	; 133
   15478:	ab 2e       	mov	r10, r27
   1547a:	b2 e2       	ldi	r27, 0x22	; 34
   1547c:	bb 2e       	mov	r11, r27
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   1547e:	d8 01       	movw	r26, r16
   15480:	8c 91       	ld	r24, X
   15482:	8d 8b       	std	Y+21, r24	; 0x15
   15484:	11 96       	adiw	r26, 0x01	; 1
   15486:	8c 91       	ld	r24, X
   15488:	8e 8b       	std	Y+22, r24	; 0x16
	 }Dest[Length]=0;
   1548a:	1f 8a       	std	Y+23, r1	; 0x17
	 //PumpID Config
	 StrPos=(40*10)+(12*6)+(5*6);
	 for(i=0;i<8;i++){
         FillChar(strEEPROM,0,sizeof(strEEPROM));   
		 StrPosCopy(rcv_trans,strEEPROM,(StrPos+(2*i)),2);
		 RemZeroLead(strEEPROM);
   1548c:	c6 01       	movw	r24, r12
   1548e:	0e 94 b9 25 	call	0x4b72	; 0x4b72 <RemZeroLead>
		 xEEPROM=atoi(strEEPROM);
   15492:	c6 01       	movw	r24, r12
   15494:	0e 94 45 b5 	call	0x16a8a	; 0x16a8a <atoi>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   15498:	e1 99       	sbic	0x1c, 1	; 28
   1549a:	fe cf       	rjmp	.-4      	; 0x15498 <SaveConfigParameter+0x1da>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   1549c:	ff ba       	out	0x1f, r15	; 31
   1549e:	ee ba       	out	0x1e, r14	; 30
#endif
    EEDR = __value;
   154a0:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
   154a2:	0f b6       	in	r0, 0x3f	; 63
   154a4:	f8 94       	cli
   154a6:	e2 9a       	sbi	0x1c, 2	; 28
   154a8:	e1 9a       	sbi	0x1c, 1	; 28
   154aa:	0f be       	out	0x3f, r0	; 63
         eeprom_write_byte(&DefPumpMap[i],xEEPROM);
		 sprintf_P(strSend,PSTR("%d"),xEEPROM);
   154ac:	00 d0       	rcall	.+0      	; 0x154ae <SaveConfigParameter+0x1f0>
   154ae:	00 d0       	rcall	.+0      	; 0x154b0 <SaveConfigParameter+0x1f2>
   154b0:	00 d0       	rcall	.+0      	; 0x154b2 <SaveConfigParameter+0x1f4>
   154b2:	ed b7       	in	r30, 0x3d	; 61
   154b4:	fe b7       	in	r31, 0x3e	; 62
   154b6:	31 96       	adiw	r30, 0x01	; 1
   154b8:	ad b7       	in	r26, 0x3d	; 61
   154ba:	be b7       	in	r27, 0x3e	; 62
   154bc:	12 96       	adiw	r26, 0x02	; 2
   154be:	9c 92       	st	X, r9
   154c0:	8e 92       	st	-X, r8
   154c2:	11 97       	sbiw	r26, 0x01	; 1
   154c4:	b3 82       	std	Z+3, r11	; 0x03
   154c6:	a2 82       	std	Z+2, r10	; 0x02
   154c8:	84 83       	std	Z+4, r24	; 0x04
   154ca:	15 82       	std	Z+5, r1	; 0x05
   154cc:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
   154d0:	0e 5f       	subi	r16, 0xFE	; 254
   154d2:	1f 4f       	sbci	r17, 0xFF	; 255
   154d4:	08 94       	sec
   154d6:	e1 1c       	adc	r14, r1
   154d8:	f1 1c       	adc	r15, r1
		// _uart_print(1,1,strEEPROM);

	 }    
	 //PumpID Config
	 StrPos=(40*10)+(12*6)+(5*6);
	 for(i=0;i<8;i++){
   154da:	ed b7       	in	r30, 0x3d	; 61
   154dc:	fe b7       	in	r31, 0x3e	; 62
   154de:	36 96       	adiw	r30, 0x06	; 6
   154e0:	0f b6       	in	r0, 0x3f	; 63
   154e2:	f8 94       	cli
   154e4:	fe bf       	out	0x3e, r31	; 62
   154e6:	0f be       	out	0x3f, r0	; 63
   154e8:	ed bf       	out	0x3d, r30	; 61
   154ea:	fc e0       	ldi	r31, 0x0C	; 12
   154ec:	0b 3f       	cpi	r16, 0xFB	; 251
   154ee:	1f 07       	cpc	r17, r31
   154f0:	09 f0       	breq	.+2      	; 0x154f4 <SaveConfigParameter+0x236>
   154f2:	c5 cf       	rjmp	.-118    	; 0x1547e <SaveConfigParameter+0x1c0>
   154f4:	45 e5       	ldi	r20, 0x55	; 85
   154f6:	50 e0       	ldi	r21, 0x00	; 0
   154f8:	b8 01       	movw	r22, r16
   154fa:	1d c0       	rjmp	.+58     	; 0x15536 <SaveConfigParameter+0x278>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
   154fc:	90 81       	ld	r25, Z
   154fe:	90 53       	subi	r25, 0x30	; 48
   15500:	9a 30       	cpi	r25, 0x0A	; 10
   15502:	08 f0       	brcs	.+2      	; 0x15506 <SaveConfigParameter+0x248>
   15504:	90 e0       	ldi	r25, 0x00	; 0
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   15506:	e1 99       	sbic	0x1c, 1	; 28
   15508:	fe cf       	rjmp	.-4      	; 0x15506 <SaveConfigParameter+0x248>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   1550a:	3f bb       	out	0x1f, r19	; 31
   1550c:	2e bb       	out	0x1e, r18	; 30
#endif
    EEDR = __value;
   1550e:	9d bb       	out	0x1d, r25	; 29

    __asm__ __volatile__ (
   15510:	0f b6       	in	r0, 0x3f	; 63
   15512:	f8 94       	cli
   15514:	e2 9a       	sbi	0x1c, 2	; 28
   15516:	e1 9a       	sbi	0x1c, 1	; 28
   15518:	0f be       	out	0x3f, r0	; 63

	 }    
	 //PumpNozzle
	 StrPos=(40*10)+(12*6)+(5*6)+(2*8);
	 for (i=0;i<8;i++){
	     for (j=0;j<6;j++){
   1551a:	8f 5f       	subi	r24, 0xFF	; 255
   1551c:	31 96       	adiw	r30, 0x01	; 1
   1551e:	2f 5f       	subi	r18, 0xFF	; 255
   15520:	3f 4f       	sbci	r19, 0xFF	; 255
   15522:	86 30       	cpi	r24, 0x06	; 6
   15524:	59 f7       	brne	.-42     	; 0x154fc <SaveConfigParameter+0x23e>
   15526:	4a 5f       	subi	r20, 0xFA	; 250
   15528:	5f 4f       	sbci	r21, 0xFF	; 255
   1552a:	6a 5f       	subi	r22, 0xFA	; 250
   1552c:	7f 4f       	sbci	r23, 0xFF	; 255
		// _uart_print(1,1,strSend); 

	 }    
	 //PumpNozzle
	 StrPos=(40*10)+(12*6)+(5*6)+(2*8);
	 for (i=0;i<8;i++){
   1552e:	80 e0       	ldi	r24, 0x00	; 0
   15530:	45 38       	cpi	r20, 0x85	; 133
   15532:	58 07       	cpc	r21, r24
   15534:	21 f0       	breq	.+8      	; 0x1553e <SaveConfigParameter+0x280>
   15536:	fb 01       	movw	r30, r22
   15538:	9a 01       	movw	r18, r20
   1553a:	80 e0       	ldi	r24, 0x00	; 0
   1553c:	df cf       	rjmp	.-66     	; 0x154fc <SaveConfigParameter+0x23e>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
   1553e:	80 91 2b 0d 	lds	r24, 0x0D2B
   15542:	80 53       	subi	r24, 0x30	; 48
   15544:	8a 30       	cpi	r24, 0x0A	; 10
   15546:	10 f0       	brcs	.+4      	; 0x1554c <SaveConfigParameter+0x28e>
   15548:	20 e0       	ldi	r18, 0x00	; 0
   1554a:	03 c0       	rjmp	.+6      	; 0x15552 <SaveConfigParameter+0x294>
   1554c:	81 11       	cpse	r24, r1
   1554e:	81 e0       	ldi	r24, 0x01	; 1
   15550:	28 2f       	mov	r18, r24
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   15552:	e1 99       	sbic	0x1c, 1	; 28
   15554:	fe cf       	rjmp	.-4      	; 0x15552 <SaveConfigParameter+0x294>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   15556:	81 ec       	ldi	r24, 0xC1	; 193
   15558:	93 e0       	ldi	r25, 0x03	; 3
   1555a:	9f bb       	out	0x1f, r25	; 31
   1555c:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
   1555e:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
   15560:	0f b6       	in	r0, 0x3f	; 63
   15562:	f8 94       	cli
   15564:	e2 9a       	sbi	0x1c, 2	; 28
   15566:	e1 9a       	sbi	0x1c, 1	; 28
   15568:	0f be       	out	0x3f, r0	; 63
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   1556a:	80 91 2c 0d 	lds	r24, 0x0D2C
   1556e:	8d 8b       	std	Y+21, r24	; 0x15
   15570:	80 91 2d 0d 	lds	r24, 0x0D2D
   15574:	8e 8b       	std	Y+22, r24	; 0x16
	 }Dest[Length]=0;
   15576:	1f 8a       	std	Y+23, r1	; 0x17

	 //TermID
	 StrPos=(40*10)+(12*6)+(5*6)+(2*8)+(6*8)+1;
     FillChar(strEEPROM,0,sizeof(strEEPROM));   
	 StrPosCopy(rcv_trans,strEEPROM,StrPos,2);
	 RemZeroLead(strEEPROM);
   15578:	8e 01       	movw	r16, r28
   1557a:	0b 5e       	subi	r16, 0xEB	; 235
   1557c:	1f 4f       	sbci	r17, 0xFF	; 255
   1557e:	c8 01       	movw	r24, r16
   15580:	0e 94 b9 25 	call	0x4b72	; 0x4b72 <RemZeroLead>
	 xEEPROM=atoi(strEEPROM);
   15584:	c8 01       	movw	r24, r16
   15586:	0e 94 45 b5 	call	0x16a8a	; 0x16a8a <atoi>
   1558a:	28 2f       	mov	r18, r24
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   1558c:	e1 99       	sbic	0x1c, 1	; 28
   1558e:	fe cf       	rjmp	.-4      	; 0x1558c <SaveConfigParameter+0x2ce>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   15590:	80 e0       	ldi	r24, 0x00	; 0
   15592:	90 e0       	ldi	r25, 0x00	; 0
   15594:	9f bb       	out	0x1f, r25	; 31
   15596:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
   15598:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
   1559a:	0f b6       	in	r0, 0x3f	; 63
   1559c:	f8 94       	cli
   1559e:	e2 9a       	sbi	0x1c, 2	; 28
   155a0:	e1 9a       	sbi	0x1c, 1	; 28
   155a2:	0f be       	out	0x3f, r0	; 63
	 eeprom_write_byte(&DefIFT_ID,xEEPROM);
	 sprintf_P(strSend,PSTR("%d"),xEEPROM);
   155a4:	00 d0       	rcall	.+0      	; 0x155a6 <SaveConfigParameter+0x2e8>
   155a6:	00 d0       	rcall	.+0      	; 0x155a8 <SaveConfigParameter+0x2ea>
   155a8:	00 d0       	rcall	.+0      	; 0x155aa <SaveConfigParameter+0x2ec>
   155aa:	ed b7       	in	r30, 0x3d	; 61
   155ac:	fe b7       	in	r31, 0x3e	; 62
   155ae:	31 96       	adiw	r30, 0x01	; 1
   155b0:	8e 01       	movw	r16, r28
   155b2:	0f 5f       	subi	r16, 0xFF	; 255
   155b4:	1f 4f       	sbci	r17, 0xFF	; 255
   155b6:	ad b7       	in	r26, 0x3d	; 61
   155b8:	be b7       	in	r27, 0x3e	; 62
   155ba:	12 96       	adiw	r26, 0x02	; 2
   155bc:	1c 93       	st	X, r17
   155be:	0e 93       	st	-X, r16
   155c0:	11 97       	sbiw	r26, 0x01	; 1
   155c2:	82 e8       	ldi	r24, 0x82	; 130
   155c4:	92 e2       	ldi	r25, 0x22	; 34
   155c6:	93 83       	std	Z+3, r25	; 0x03
   155c8:	82 83       	std	Z+2, r24	; 0x02
   155ca:	24 83       	std	Z+4, r18	; 0x04
   155cc:	15 82       	std	Z+5, r1	; 0x05
   155ce:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
   155d2:	ae e2       	ldi	r26, 0x2E	; 46
   155d4:	ea 2e       	mov	r14, r26
   155d6:	ad e0       	ldi	r26, 0x0D	; 13
   155d8:	fa 2e       	mov	r15, r26
   155da:	fd e4       	ldi	r31, 0x4D	; 77
   155dc:	cf 2e       	mov	r12, r31
   155de:	f0 e0       	ldi	r31, 0x00	; 0
   155e0:	df 2e       	mov	r13, r31
   155e2:	ed b7       	in	r30, 0x3d	; 61
   155e4:	fe b7       	in	r31, 0x3e	; 62
   155e6:	36 96       	adiw	r30, 0x06	; 6
   155e8:	0f b6       	in	r0, 0x3f	; 63
   155ea:	f8 94       	cli
   155ec:	fe bf       	out	0x3e, r31	; 62
   155ee:	0f be       	out	0x3f, r0	; 63
   155f0:	ed bf       	out	0x3d, r30	; 61
	 //PumpLabel
	 StrPos=(40*10)+(12*6)+(5*6)+(2*8)+(6*8)+1+2;
	 for(i=0;i<8;i++){
         FillChar(strEEPROM,0,sizeof(strEEPROM));   
		 StrPosCopy(rcv_trans,strEEPROM,(StrPos+(2*i)),2);
		 RemZeroLead(strEEPROM);
   155f2:	e5 e1       	ldi	r30, 0x15	; 21
   155f4:	ae 2e       	mov	r10, r30
   155f6:	b1 2c       	mov	r11, r1
   155f8:	ac 0e       	add	r10, r28
   155fa:	bd 1e       	adc	r11, r29
		 xEEPROM=atoi(strEEPROM);
         eeprom_write_byte(&DefPumpLabel[i],xEEPROM);
		 sprintf_P(strSend,PSTR("%d"),xEEPROM);
   155fc:	48 01       	movw	r8, r16
   155fe:	0f e7       	ldi	r16, 0x7F	; 127
   15600:	12 e2       	ldi	r17, 0x22	; 34
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   15602:	d7 01       	movw	r26, r14
   15604:	8c 91       	ld	r24, X
   15606:	8d 8b       	std	Y+21, r24	; 0x15
   15608:	11 96       	adiw	r26, 0x01	; 1
   1560a:	8c 91       	ld	r24, X
   1560c:	8e 8b       	std	Y+22, r24	; 0x16
	 }Dest[Length]=0;
   1560e:	1f 8a       	std	Y+23, r1	; 0x17
	 //PumpLabel
	 StrPos=(40*10)+(12*6)+(5*6)+(2*8)+(6*8)+1+2;
	 for(i=0;i<8;i++){
         FillChar(strEEPROM,0,sizeof(strEEPROM));   
		 StrPosCopy(rcv_trans,strEEPROM,(StrPos+(2*i)),2);
		 RemZeroLead(strEEPROM);
   15610:	c5 01       	movw	r24, r10
   15612:	0e 94 b9 25 	call	0x4b72	; 0x4b72 <RemZeroLead>
		 xEEPROM=atoi(strEEPROM);
   15616:	c5 01       	movw	r24, r10
   15618:	0e 94 45 b5 	call	0x16a8a	; 0x16a8a <atoi>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   1561c:	e1 99       	sbic	0x1c, 1	; 28
   1561e:	fe cf       	rjmp	.-4      	; 0x1561c <SaveConfigParameter+0x35e>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   15620:	df ba       	out	0x1f, r13	; 31
   15622:	ce ba       	out	0x1e, r12	; 30
#endif
    EEDR = __value;
   15624:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
   15626:	0f b6       	in	r0, 0x3f	; 63
   15628:	f8 94       	cli
   1562a:	e2 9a       	sbi	0x1c, 2	; 28
   1562c:	e1 9a       	sbi	0x1c, 1	; 28
   1562e:	0f be       	out	0x3f, r0	; 63
         eeprom_write_byte(&DefPumpLabel[i],xEEPROM);
		 sprintf_P(strSend,PSTR("%d"),xEEPROM);
   15630:	00 d0       	rcall	.+0      	; 0x15632 <SaveConfigParameter+0x374>
   15632:	00 d0       	rcall	.+0      	; 0x15634 <SaveConfigParameter+0x376>
   15634:	00 d0       	rcall	.+0      	; 0x15636 <SaveConfigParameter+0x378>
   15636:	ed b7       	in	r30, 0x3d	; 61
   15638:	fe b7       	in	r31, 0x3e	; 62
   1563a:	31 96       	adiw	r30, 0x01	; 1
   1563c:	ad b7       	in	r26, 0x3d	; 61
   1563e:	be b7       	in	r27, 0x3e	; 62
   15640:	11 96       	adiw	r26, 0x01	; 1
   15642:	8c 92       	st	X, r8
   15644:	11 97       	sbiw	r26, 0x01	; 1
   15646:	12 96       	adiw	r26, 0x02	; 2
   15648:	9c 92       	st	X, r9
   1564a:	13 83       	std	Z+3, r17	; 0x03
   1564c:	02 83       	std	Z+2, r16	; 0x02
   1564e:	84 83       	std	Z+4, r24	; 0x04
   15650:	15 82       	std	Z+5, r1	; 0x05
   15652:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
   15656:	e2 e0       	ldi	r30, 0x02	; 2
   15658:	f0 e0       	ldi	r31, 0x00	; 0
   1565a:	ee 0e       	add	r14, r30
   1565c:	ff 1e       	adc	r15, r31
   1565e:	08 94       	sec
   15660:	c1 1c       	adc	r12, r1
   15662:	d1 1c       	adc	r13, r1
	 sprintf_P(strSend,PSTR("%d"),xEEPROM);
//	 _uart_print(1,1,strSend); 

	 //PumpLabel
	 StrPos=(40*10)+(12*6)+(5*6)+(2*8)+(6*8)+1+2;
	 for(i=0;i<8;i++){
   15664:	8d b7       	in	r24, 0x3d	; 61
   15666:	9e b7       	in	r25, 0x3e	; 62
   15668:	06 96       	adiw	r24, 0x06	; 6
   1566a:	0f b6       	in	r0, 0x3f	; 63
   1566c:	f8 94       	cli
   1566e:	9e bf       	out	0x3e, r25	; 62
   15670:	0f be       	out	0x3f, r0	; 63
   15672:	8d bf       	out	0x3d, r24	; 61
   15674:	9e e3       	ldi	r25, 0x3E	; 62
   15676:	e9 16       	cp	r14, r25
   15678:	9d e0       	ldi	r25, 0x0D	; 13
   1567a:	f9 06       	cpc	r15, r25
   1567c:	09 f0       	breq	.+2      	; 0x15680 <SaveConfigParameter+0x3c2>
   1567e:	c1 cf       	rjmp	.-126    	; 0x15602 <SaveConfigParameter+0x344>
		 xEEPROM=atoi(strEEPROM);
         eeprom_write_byte(&DefPumpLabel[i],xEEPROM);
		 sprintf_P(strSend,PSTR("%d"),xEEPROM);
//		 _uart_print(1,1,strSend); 
	 }    
	 _uart_printf(1,1,PSTR("<OK>")); 
   15680:	81 e0       	ldi	r24, 0x01	; 1
   15682:	61 e0       	ldi	r22, 0x01	; 1
   15684:	4a e7       	ldi	r20, 0x7A	; 122
   15686:	52 e2       	ldi	r21, 0x22	; 34
   15688:	0e 94 1a b4 	call	0x16834	; 0x16834 <_uart_printf>
}
   1568c:	ca 5b       	subi	r28, 0xBA	; 186
   1568e:	df 4f       	sbci	r29, 0xFF	; 255
   15690:	0f b6       	in	r0, 0x3f	; 63
   15692:	f8 94       	cli
   15694:	de bf       	out	0x3e, r29	; 62
   15696:	0f be       	out	0x3f, r0	; 63
   15698:	cd bf       	out	0x3d, r28	; 61
   1569a:	cf 91       	pop	r28
   1569c:	df 91       	pop	r29
   1569e:	1f 91       	pop	r17
   156a0:	0f 91       	pop	r16
   156a2:	ff 90       	pop	r15
   156a4:	ef 90       	pop	r14
   156a6:	df 90       	pop	r13
   156a8:	cf 90       	pop	r12
   156aa:	bf 90       	pop	r11
   156ac:	af 90       	pop	r10
   156ae:	9f 90       	pop	r9
   156b0:	8f 90       	pop	r8
   156b2:	08 95       	ret

000156b4 <systemConfigProtocol>:



void systemConfigProtocol(){
     static char stConfigProtocol=cpWaitSend;
	 switch(stConfigProtocol){
   156b4:	80 91 ad 03 	lds	r24, 0x03AD
   156b8:	81 30       	cpi	r24, 0x01	; 1
   156ba:	c1 f0       	breq	.+48     	; 0x156ec <systemConfigProtocol+0x38>
   156bc:	81 30       	cpi	r24, 0x01	; 1
   156be:	18 f0       	brcs	.+6      	; 0x156c6 <systemConfigProtocol+0x12>
   156c0:	82 30       	cpi	r24, 0x02	; 2
   156c2:	e9 f4       	brne	.+58     	; 0x156fe <systemConfigProtocol+0x4a>
   156c4:	18 c0       	rjmp	.+48     	; 0x156f6 <systemConfigProtocol+0x42>
	 case cpWaitSend:
	      switch(ConfigCommand){
   156c6:	80 91 c6 01 	lds	r24, 0x01C6
   156ca:	81 30       	cpi	r24, 0x01	; 1
   156cc:	31 f0       	breq	.+12     	; 0x156da <systemConfigProtocol+0x26>
   156ce:	82 30       	cpi	r24, 0x02	; 2
   156d0:	51 f4       	brne	.+20     	; 0x156e6 <systemConfigProtocol+0x32>
		  case CC_SEND_CONFIG:
		       ConfigCommand=CC_NONE;
   156d2:	10 92 c6 01 	sts	0x01C6, r1
			   stConfigProtocol=cpSendingParameter;
   156d6:	81 e0       	ldi	r24, 0x01	; 1
   156d8:	03 c0       	rjmp	.+6      	; 0x156e0 <systemConfigProtocol+0x2c>
		       break;
		  case CC_SAVE_CONFIG:
		       ConfigCommand=CC_NONE;
   156da:	10 92 c6 01 	sts	0x01C6, r1
			   stConfigProtocol=cpSavingParameter;
   156de:	82 e0       	ldi	r24, 0x02	; 2
   156e0:	80 93 ad 03 	sts	0x03AD, r24
   156e4:	08 95       	ret
		       break;
          default:
		       ConfigCommand=CC_NONE;
   156e6:	10 92 c6 01 	sts	0x01C6, r1
   156ea:	08 95       	ret
		       break;
		  }
	      break;
     case cpSendingParameter:
	      SendConfigParamater();
   156ec:	0e 94 45 a7 	call	0x14e8a	; 0x14e8a <SendConfigParamater>
          stConfigProtocol=cpWaitSend;
   156f0:	10 92 ad 03 	sts	0x03AD, r1
   156f4:	08 95       	ret
	      break;
     case cpSavingParameter:
          SaveConfigParameter();
   156f6:	0e 94 5f a9 	call	0x152be	; 0x152be <SaveConfigParameter>
          stConfigProtocol=cpWaitSend;
   156fa:	10 92 ad 03 	sts	0x03AD, r1
   156fe:	08 95       	ret

00015700 <FMenuIdle>:
	     ProcTimeOut++;
	}
	TimSend++;
}

void FMenuIdle(){
   15700:	1f 93       	push	r17
	static char stMenuIdle=miInit,KeyPressed=0,KeyChar=0,ButtonID=0,PrintStandaloneResult=PS_NONE;
    //static unsigned int iLoopIdle=0;
	char lcdteks[20];
   

	switch(stMenuIdle){
   15702:	80 91 bc 03 	lds	r24, 0x03BC
   15706:	e8 2f       	mov	r30, r24
   15708:	f0 e0       	ldi	r31, 0x00	; 0
   1570a:	e9 31       	cpi	r30, 0x19	; 25
   1570c:	f1 05       	cpc	r31, r1
   1570e:	08 f0       	brcs	.+2      	; 0x15712 <FMenuIdle+0x12>
   15710:	a6 c1       	rjmp	.+844    	; 0x15a5e <FMenuIdle+0x35e>
   15712:	ec 5e       	subi	r30, 0xEC	; 236
   15714:	fe 4f       	sbci	r31, 0xFE	; 254
   15716:	ee 0f       	add	r30, r30
   15718:	ff 1f       	adc	r31, r31
   1571a:	05 90       	lpm	r0, Z+
   1571c:	f4 91       	lpm	r31, Z+
   1571e:	e0 2d       	mov	r30, r0
   15720:	09 94       	ijmp
	case miInit:
         _scr_idle();
   15722:	0e 94 ea 45 	call	0x8bd4	; 0x8bd4 <_scr_idle>
   15726:	62 c1       	rjmp	.+708    	; 0x159ec <FMenuIdle+0x2ec>
		 stMenuIdle=miScan;		
	     break;
	case miScan:
         //Scan Key Pressed 
		 KeyPressed=_key_scan(1);
   15728:	81 e0       	ldi	r24, 0x01	; 1
   1572a:	0e 94 06 b0 	call	0x1600c	; 0x1600c <_key_scan>
   1572e:	80 93 bb 03 	sts	0x03BB, r24
		 KeyChar= _key_btn(KeyPressed);       
   15732:	0e 94 67 af 	call	0x15ece	; 0x15ece <_key_btn>
   15736:	80 93 ba 03 	sts	0x03BA, r24

		 switch(KeyPressed){
   1573a:	80 91 bb 03 	lds	r24, 0x03BB
   1573e:	8b 3b       	cpi	r24, 0xBB	; 187
   15740:	09 f4       	brne	.+2      	; 0x15744 <FMenuIdle+0x44>
   15742:	94 c0       	rjmp	.+296    	; 0x1586c <FMenuIdle+0x16c>
   15744:	8c 3b       	cpi	r24, 0xBC	; 188
   15746:	70 f4       	brcc	.+28     	; 0x15764 <FMenuIdle+0x64>
   15748:	8b 37       	cpi	r24, 0x7B	; 123
   1574a:	a1 f1       	breq	.+104    	; 0x157b4 <FMenuIdle+0xb4>
   1574c:	8c 37       	cpi	r24, 0x7C	; 124
   1574e:	20 f4       	brcc	.+8      	; 0x15758 <FMenuIdle+0x58>
   15750:	87 37       	cpi	r24, 0x77	; 119
   15752:	09 f0       	breq	.+2      	; 0x15756 <FMenuIdle+0x56>
   15754:	84 c1       	rjmp	.+776    	; 0x15a5e <FMenuIdle+0x35e>
   15756:	38 c0       	rjmp	.+112    	; 0x157c8 <FMenuIdle+0xc8>
   15758:	8d 37       	cpi	r24, 0x7D	; 125
   1575a:	01 f1       	breq	.+64     	; 0x1579c <FMenuIdle+0x9c>
   1575c:	8e 37       	cpi	r24, 0x7E	; 126
   1575e:	09 f0       	breq	.+2      	; 0x15762 <FMenuIdle+0x62>
   15760:	7e c1       	rjmp	.+764    	; 0x15a5e <FMenuIdle+0x35e>
   15762:	12 c0       	rjmp	.+36     	; 0x15788 <FMenuIdle+0x88>
   15764:	8d 3d       	cpi	r24, 0xDD	; 221
   15766:	09 f4       	brne	.+2      	; 0x1576a <FMenuIdle+0x6a>
   15768:	63 c0       	rjmp	.+198    	; 0x15830 <FMenuIdle+0x130>
   1576a:	8e 3d       	cpi	r24, 0xDE	; 222
   1576c:	38 f4       	brcc	.+14     	; 0x1577c <FMenuIdle+0x7c>
   1576e:	8d 3b       	cpi	r24, 0xBD	; 189
   15770:	09 f4       	brne	.+2      	; 0x15774 <FMenuIdle+0x74>
   15772:	6d c0       	rjmp	.+218    	; 0x1584e <FMenuIdle+0x14e>
   15774:	87 3d       	cpi	r24, 0xD7	; 215
   15776:	09 f0       	breq	.+2      	; 0x1577a <FMenuIdle+0x7a>
   15778:	72 c1       	rjmp	.+740    	; 0x15a5e <FMenuIdle+0x35e>
   1577a:	32 c0       	rjmp	.+100    	; 0x157e0 <FMenuIdle+0xe0>
   1577c:	8e 3d       	cpi	r24, 0xDE	; 222
   1577e:	d1 f1       	breq	.+116    	; 0x157f4 <FMenuIdle+0xf4>
   15780:	8d 3e       	cpi	r24, 0xED	; 237
   15782:	09 f0       	breq	.+2      	; 0x15786 <FMenuIdle+0x86>
   15784:	6c c1       	rjmp	.+728    	; 0x15a5e <FMenuIdle+0x35e>
   15786:	45 c0       	rjmp	.+138    	; 0x15812 <FMenuIdle+0x112>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   15788:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   1578a:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   1578c:	82 e0       	ldi	r24, 0x02	; 2
   1578e:	90 e0       	ldi	r25, 0x00	; 0
   15790:	90 93 d7 01 	sts	0x01D7, r25
   15794:	80 93 d6 01 	sts	0x01D6, r24
         //Scan Key Pressed 
		 KeyPressed=_key_scan(1);
		 KeyChar= _key_btn(KeyPressed);       

		 switch(KeyPressed){
		 case _KEY_TIKET:system_beep(2);ButtonID=1;stMenuIdle=miDisplayProses;break;
   15798:	81 e0       	ldi	r24, 0x01	; 1
   1579a:	1f c0       	rjmp	.+62     	; 0x157da <FMenuIdle+0xda>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   1579c:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   1579e:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   157a0:	82 e0       	ldi	r24, 0x02	; 2
   157a2:	90 e0       	ldi	r25, 0x00	; 0
   157a4:	90 93 d7 01 	sts	0x01D7, r25
   157a8:	80 93 d6 01 	sts	0x01D6, r24
		 KeyPressed=_key_scan(1);
		 KeyChar= _key_btn(KeyPressed);       

		 switch(KeyPressed){
		 case _KEY_TIKET:system_beep(2);ButtonID=1;stMenuIdle=miDisplayProses;break;
		 case _KEY_MENU: system_beep(2);ButtonID=2;stMenuIdle=miDisplayProses;break;
   157ac:	82 e0       	ldi	r24, 0x02	; 2
   157ae:	80 93 b9 03 	sts	0x03B9, r24
   157b2:	53 c1       	rjmp	.+678    	; 0x15a5a <FMenuIdle+0x35a>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   157b4:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   157b6:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   157b8:	82 e0       	ldi	r24, 0x02	; 2
   157ba:	90 e0       	ldi	r25, 0x00	; 0
   157bc:	90 93 d7 01 	sts	0x01D7, r25
   157c0:	80 93 d6 01 	sts	0x01D6, r24
		 KeyChar= _key_btn(KeyPressed);       

		 switch(KeyPressed){
		 case _KEY_TIKET:system_beep(2);ButtonID=1;stMenuIdle=miDisplayProses;break;
		 case _KEY_MENU: system_beep(2);ButtonID=2;stMenuIdle=miDisplayProses;break;
		 case _KEY_SHIFT:system_beep(2);ButtonID=3;stMenuIdle=miDisplayProses;break;
   157c4:	83 e0       	ldi	r24, 0x03	; 3
   157c6:	09 c0       	rjmp	.+18     	; 0x157da <FMenuIdle+0xda>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   157c8:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   157ca:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   157cc:	82 e0       	ldi	r24, 0x02	; 2
   157ce:	90 e0       	ldi	r25, 0x00	; 0
   157d0:	90 93 d7 01 	sts	0x01D7, r25
   157d4:	80 93 d6 01 	sts	0x01D6, r24

		 switch(KeyPressed){
		 case _KEY_TIKET:system_beep(2);ButtonID=1;stMenuIdle=miDisplayProses;break;
		 case _KEY_MENU: system_beep(2);ButtonID=2;stMenuIdle=miDisplayProses;break;
		 case _KEY_SHIFT:system_beep(2);ButtonID=3;stMenuIdle=miDisplayProses;break;
		 case _KEY_CLEAR:system_beep(2);ButtonID=4;stMenuIdle=miDisplayProses;break;//stMenuIdle=miTestMsg56;break;//miDisplayProses;break;
   157d8:	84 e0       	ldi	r24, 0x04	; 4
   157da:	80 93 b9 03 	sts	0x03B9, r24
   157de:	64 c0       	rjmp	.+200    	; 0x158a8 <FMenuIdle+0x1a8>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   157e0:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   157e2:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   157e4:	82 e0       	ldi	r24, 0x02	; 2
   157e6:	90 e0       	ldi	r25, 0x00	; 0
   157e8:	90 93 d7 01 	sts	0x01D7, r25
   157ec:	80 93 d6 01 	sts	0x01D6, r24
		 switch(KeyPressed){
		 case _KEY_TIKET:system_beep(2);ButtonID=1;stMenuIdle=miDisplayProses;break;
		 case _KEY_MENU: system_beep(2);ButtonID=2;stMenuIdle=miDisplayProses;break;
		 case _KEY_SHIFT:system_beep(2);ButtonID=3;stMenuIdle=miDisplayProses;break;
		 case _KEY_CLEAR:system_beep(2);ButtonID=4;stMenuIdle=miDisplayProses;break;//stMenuIdle=miTestMsg56;break;//miDisplayProses;break;
		 case _KEY_0:    system_beep(2);           stMenuIdle=miRunTicket;    break;
   157f0:	8c e0       	ldi	r24, 0x0C	; 12
   157f2:	33 c1       	rjmp	.+614    	; 0x15a5a <FMenuIdle+0x35a>
	   //case _KEY_1:    system_beep(2);           stMenuIdle=miRunTotalizer; break;
		 case _KEY_2: if(IFType==IT_SLAVE) {system_beep(2); stMenuIdle=miRunEDC;}       break;
   157f4:	80 91 10 01 	lds	r24, 0x0110
   157f8:	81 30       	cpi	r24, 0x01	; 1
   157fa:	09 f0       	breq	.+2      	; 0x157fe <FMenuIdle+0xfe>
   157fc:	30 c1       	rjmp	.+608    	; 0x15a5e <FMenuIdle+0x35e>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   157fe:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   15800:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   15802:	82 e0       	ldi	r24, 0x02	; 2
   15804:	90 e0       	ldi	r25, 0x00	; 0
   15806:	90 93 d7 01 	sts	0x01D7, r25
   1580a:	80 93 d6 01 	sts	0x01D6, r24
		 case _KEY_MENU: system_beep(2);ButtonID=2;stMenuIdle=miDisplayProses;break;
		 case _KEY_SHIFT:system_beep(2);ButtonID=3;stMenuIdle=miDisplayProses;break;
		 case _KEY_CLEAR:system_beep(2);ButtonID=4;stMenuIdle=miDisplayProses;break;//stMenuIdle=miTestMsg56;break;//miDisplayProses;break;
		 case _KEY_0:    system_beep(2);           stMenuIdle=miRunTicket;    break;
	   //case _KEY_1:    system_beep(2);           stMenuIdle=miRunTotalizer; break;
		 case _KEY_2: if(IFType==IT_SLAVE) {system_beep(2); stMenuIdle=miRunEDC;}       break;
   1580e:	80 e1       	ldi	r24, 0x10	; 16
   15810:	24 c1       	rjmp	.+584    	; 0x15a5a <FMenuIdle+0x35a>
	   //case _KEY_3:    system_beep(2);           stMenuIdle=miClearTotalizer;break;
		 case _KEY_4: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunReprint;}   break;
   15812:	80 91 10 01 	lds	r24, 0x0110
   15816:	81 30       	cpi	r24, 0x01	; 1
   15818:	09 f0       	breq	.+2      	; 0x1581c <FMenuIdle+0x11c>
   1581a:	21 c1       	rjmp	.+578    	; 0x15a5e <FMenuIdle+0x35e>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   1581c:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   1581e:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   15820:	82 e0       	ldi	r24, 0x02	; 2
   15822:	90 e0       	ldi	r25, 0x00	; 0
   15824:	90 93 d7 01 	sts	0x01D7, r25
   15828:	80 93 d6 01 	sts	0x01D6, r24
		 case _KEY_CLEAR:system_beep(2);ButtonID=4;stMenuIdle=miDisplayProses;break;//stMenuIdle=miTestMsg56;break;//miDisplayProses;break;
		 case _KEY_0:    system_beep(2);           stMenuIdle=miRunTicket;    break;
	   //case _KEY_1:    system_beep(2);           stMenuIdle=miRunTotalizer; break;
		 case _KEY_2: if(IFType==IT_SLAVE) {system_beep(2); stMenuIdle=miRunEDC;}       break;
	   //case _KEY_3:    system_beep(2);           stMenuIdle=miClearTotalizer;break;
		 case _KEY_4: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunReprint;}   break;
   1582c:	82 e1       	ldi	r24, 0x12	; 18
   1582e:	15 c1       	rjmp	.+554    	; 0x15a5a <FMenuIdle+0x35a>
		 case _KEY_5: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunLoyalty;}   break;
   15830:	80 91 10 01 	lds	r24, 0x0110
   15834:	81 30       	cpi	r24, 0x01	; 1
   15836:	09 f0       	breq	.+2      	; 0x1583a <FMenuIdle+0x13a>
   15838:	12 c1       	rjmp	.+548    	; 0x15a5e <FMenuIdle+0x35e>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   1583a:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   1583c:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   1583e:	82 e0       	ldi	r24, 0x02	; 2
   15840:	90 e0       	ldi	r25, 0x00	; 0
   15842:	90 93 d7 01 	sts	0x01D7, r25
   15846:	80 93 d6 01 	sts	0x01D6, r24
		 case _KEY_0:    system_beep(2);           stMenuIdle=miRunTicket;    break;
	   //case _KEY_1:    system_beep(2);           stMenuIdle=miRunTotalizer; break;
		 case _KEY_2: if(IFType==IT_SLAVE) {system_beep(2); stMenuIdle=miRunEDC;}       break;
	   //case _KEY_3:    system_beep(2);           stMenuIdle=miClearTotalizer;break;
		 case _KEY_4: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunReprint;}   break;
		 case _KEY_5: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunLoyalty;}   break;
   1584a:	81 e1       	ldi	r24, 0x11	; 17
   1584c:	06 c1       	rjmp	.+524    	; 0x15a5a <FMenuIdle+0x35a>
		 case _KEY_6: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunChangeMOP;} break;
   1584e:	80 91 10 01 	lds	r24, 0x0110
   15852:	81 30       	cpi	r24, 0x01	; 1
   15854:	09 f0       	breq	.+2      	; 0x15858 <FMenuIdle+0x158>
   15856:	03 c1       	rjmp	.+518    	; 0x15a5e <FMenuIdle+0x35e>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   15858:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   1585a:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   1585c:	82 e0       	ldi	r24, 0x02	; 2
   1585e:	90 e0       	ldi	r25, 0x00	; 0
   15860:	90 93 d7 01 	sts	0x01D7, r25
   15864:	80 93 d6 01 	sts	0x01D6, r24
	   //case _KEY_1:    system_beep(2);           stMenuIdle=miRunTotalizer; break;
		 case _KEY_2: if(IFType==IT_SLAVE) {system_beep(2); stMenuIdle=miRunEDC;}       break;
	   //case _KEY_3:    system_beep(2);           stMenuIdle=miClearTotalizer;break;
		 case _KEY_4: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunReprint;}   break;
		 case _KEY_5: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunLoyalty;}   break;
		 case _KEY_6: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunChangeMOP;} break;
   15868:	8f e0       	ldi	r24, 0x0F	; 15
   1586a:	f7 c0       	rjmp	.+494    	; 0x15a5a <FMenuIdle+0x35a>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   1586c:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   1586e:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   15870:	82 e0       	ldi	r24, 0x02	; 2
   15872:	90 e0       	ldi	r25, 0x00	; 0
   15874:	90 93 d7 01 	sts	0x01D7, r25
   15878:	80 93 d6 01 	sts	0x01D6, r24
	   //case _KEY_3:    system_beep(2);           stMenuIdle=miClearTotalizer;break;
		 case _KEY_4: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunReprint;}   break;
		 case _KEY_5: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunLoyalty;}   break;
		 case _KEY_6: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunChangeMOP;} break;
		 //case _KEY_8:    system_beep(2);           stMenuIdle=miRunTestChar;   break;
		 case _KEY_9:    system_beep(2);stMenuIdle=miRunAuth;      break;
   1587c:	8d e0       	ldi	r24, 0x0D	; 13
   1587e:	ed c0       	rjmp	.+474    	; 0x15a5a <FMenuIdle+0x35a>
		 }
	     break;
    case miTestMsg56:
	     sprintf_P(strCardID,PSTR("4356A31A"));
   15880:	00 d0       	rcall	.+0      	; 0x15882 <FMenuIdle+0x182>
   15882:	00 d0       	rcall	.+0      	; 0x15884 <FMenuIdle+0x184>
   15884:	81 e6       	ldi	r24, 0x61	; 97
   15886:	9d e0       	ldi	r25, 0x0D	; 13
   15888:	ed b7       	in	r30, 0x3d	; 61
   1588a:	fe b7       	in	r31, 0x3e	; 62
   1588c:	92 83       	std	Z+2, r25	; 0x02
   1588e:	81 83       	std	Z+1, r24	; 0x01
   15890:	83 ea       	ldi	r24, 0xA3	; 163
   15892:	93 e2       	ldi	r25, 0x23	; 35
   15894:	94 83       	std	Z+4, r25	; 0x04
   15896:	83 83       	std	Z+3, r24	; 0x03
   15898:	0e 94 ba b5 	call	0x16b74	; 0x16b74 <sprintf_P>
	     sendMessage56();
   1589c:	0f 90       	pop	r0
   1589e:	0f 90       	pop	r0
   158a0:	0f 90       	pop	r0
   158a2:	0f 90       	pop	r0
   158a4:	0e 94 5d 9c 	call	0x138ba	; 0x138ba <sendMessage56>
         stMenuIdle=miDisplayProses;
   158a8:	82 e0       	ldi	r24, 0x02	; 2
   158aa:	d7 c0       	rjmp	.+430    	; 0x15a5a <FMenuIdle+0x35a>
	     break;
	case miDisplayProses:
	     if (IsBusyIdlePrinting==False){
   158ac:	80 91 c8 01 	lds	r24, 0x01C8
   158b0:	88 23       	and	r24, r24
   158b2:	09 f0       	breq	.+2      	; 0x158b6 <FMenuIdle+0x1b6>
   158b4:	9b c0       	rjmp	.+310    	; 0x159ec <FMenuIdle+0x2ec>
		     lcd_printf(3,1,PSTR("SedangProses"));
   158b6:	83 e0       	ldi	r24, 0x03	; 3
   158b8:	61 e0       	ldi	r22, 0x01	; 1
   158ba:	46 e9       	ldi	r20, 0x96	; 150
   158bc:	53 e2       	ldi	r21, 0x23	; 35
   158be:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
	         TimDisplay=0;
   158c2:	10 92 a7 01 	sts	0x01A7, r1
			 stMenuIdle=miWaitProses;
   158c6:	83 e0       	ldi	r24, 0x03	; 3
   158c8:	c8 c0       	rjmp	.+400    	; 0x15a5a <FMenuIdle+0x35a>
         }else stMenuIdle=miScan;
	     break;
    case miWaitProses:
	     if (TimDisplay>1){
   158ca:	80 91 a7 01 	lds	r24, 0x01A7
   158ce:	82 30       	cpi	r24, 0x02	; 2
   158d0:	08 f4       	brcc	.+2      	; 0x158d4 <FMenuIdle+0x1d4>
   158d2:	c5 c0       	rjmp	.+394    	; 0x15a5e <FMenuIdle+0x35e>
		     if (IFType==IT_SLAVE)stMenuIdle=miSendMessage98;
   158d4:	80 91 10 01 	lds	r24, 0x0110
   158d8:	81 30       	cpi	r24, 0x01	; 1
   158da:	11 f4       	brne	.+4      	; 0x158e0 <FMenuIdle+0x1e0>
   158dc:	84 e0       	ldi	r24, 0x04	; 4
   158de:	bd c0       	rjmp	.+378    	; 0x15a5a <FMenuIdle+0x35a>
			 else
		     if (IFType==IT_STANDALONE)stMenuIdle=miPrintStandalone;
   158e0:	82 30       	cpi	r24, 0x02	; 2
   158e2:	09 f0       	breq	.+2      	; 0x158e6 <FMenuIdle+0x1e6>
   158e4:	bc c0       	rjmp	.+376    	; 0x15a5e <FMenuIdle+0x35e>
   158e6:	87 e0       	ldi	r24, 0x07	; 7
   158e8:	b8 c0       	rjmp	.+368    	; 0x15a5a <FMenuIdle+0x35a>
		 }
	     break;
    case miPrintStandalone:
	     PrintStandaloneResult=PrintStandalone(ButtonID,False);
   158ea:	80 91 b9 03 	lds	r24, 0x03B9
   158ee:	60 e0       	ldi	r22, 0x00	; 0
   158f0:	0e 94 97 21 	call	0x432e	; 0x432e <PrintStandalone>
   158f4:	80 93 5d 01 	sts	0x015D, r24
	     if (PrintStandaloneResult==PS_PRINTED)stMenuIdle=miReady;
   158f8:	81 31       	cpi	r24, 0x11	; 17
   158fa:	09 f4       	brne	.+2      	; 0x158fe <FMenuIdle+0x1fe>
   158fc:	ad c0       	rjmp	.+346    	; 0x15a58 <FMenuIdle+0x358>
		 else
		 if (PrintStandaloneResult==PS_NO_DATA)stMenuIdle=miDisplayNoTransaction;
   158fe:	82 31       	cpi	r24, 0x12	; 18
   15900:	09 f0       	breq	.+2      	; 0x15904 <FMenuIdle+0x204>
   15902:	ad c0       	rjmp	.+346    	; 0x15a5e <FMenuIdle+0x35e>
   15904:	88 e0       	ldi	r24, 0x08	; 8
   15906:	a9 c0       	rjmp	.+338    	; 0x15a5a <FMenuIdle+0x35a>
	     break;
    case miDisplayNoTransaction:
	     lcd_printf(3, 1,PSTR("Tidak Ada Transaksi "));
   15908:	83 e0       	ldi	r24, 0x03	; 3
   1590a:	61 e0       	ldi	r22, 0x01	; 1
   1590c:	41 e8       	ldi	r20, 0x81	; 129
   1590e:	53 e2       	ldi	r21, 0x23	; 35
   15910:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
         TimDisplay=0;
   15914:	10 92 a7 01 	sts	0x01A7, r1
		 stMenuIdle=miWaitDisplayNoTransaction;
   15918:	89 e0       	ldi	r24, 0x09	; 9
   1591a:	9f c0       	rjmp	.+318    	; 0x15a5a <FMenuIdle+0x35a>
	     break;
    case miWaitDisplayNoTransaction:
	     if (TimDisplay>1){
   1591c:	80 91 a7 01 	lds	r24, 0x01A7
   15920:	82 30       	cpi	r24, 0x02	; 2
   15922:	08 f4       	brcc	.+2      	; 0x15926 <FMenuIdle+0x226>
   15924:	9c c0       	rjmp	.+312    	; 0x15a5e <FMenuIdle+0x35e>
	         lcd_printf(3,1,PSTR("Ready...            "));
   15926:	83 e0       	ldi	r24, 0x03	; 3
   15928:	61 e0       	ldi	r22, 0x01	; 1
   1592a:	4c e6       	ldi	r20, 0x6C	; 108
   1592c:	53 e2       	ldi	r21, 0x23	; 35
   1592e:	36 c0       	rjmp	.+108    	; 0x1599c <FMenuIdle+0x29c>
		     stMenuIdle=miWaitReady;
			 TimDisplay=0;
		 }
	     break;
    case miSendMessage98:
	     lcd_printf(3,1,PSTR("Please Wait..       "));
   15930:	83 e0       	ldi	r24, 0x03	; 3
   15932:	61 e0       	ldi	r22, 0x01	; 1
   15934:	47 e5       	ldi	r20, 0x57	; 87
   15936:	53 e2       	ldi	r21, 0x23	; 35
   15938:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
	     sendMessage98(ButtonID);
   1593c:	80 91 b9 03 	lds	r24, 0x03B9
   15940:	0e 94 df 4d 	call	0x9bbe	; 0x9bbe <sendMessage98>
		 ProcTimeOut=0;
   15944:	10 92 d9 01 	sts	0x01D9, r1
   15948:	10 92 d8 01 	sts	0x01D8, r1
		 stMenuIdle=miWaitPlease;
   1594c:	85 e0       	ldi	r24, 0x05	; 5
   1594e:	85 c0       	rjmp	.+266    	; 0x15a5a <FMenuIdle+0x35a>
	     break;
    case miWaitPlease:
         if (ProcTimeOut>TIM_NO_RESPONSE){
   15950:	80 91 d8 01 	lds	r24, 0x01D8
   15954:	90 91 d9 01 	lds	r25, 0x01D9
   15958:	0f 97       	sbiw	r24, 0x0f	; 15
   1595a:	58 f0       	brcs	.+22     	; 0x15972 <FMenuIdle+0x272>
	         lcd_printf(3,1,PSTR("No Response..       "));
   1595c:	83 e0       	ldi	r24, 0x03	; 3
   1595e:	61 e0       	ldi	r22, 0x01	; 1
   15960:	42 e4       	ldi	r20, 0x42	; 66
   15962:	53 e2       	ldi	r21, 0x23	; 35
   15964:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		     stMenuIdle=miNoResponse;
   15968:	86 e0       	ldi	r24, 0x06	; 6
   1596a:	80 93 bc 03 	sts	0x03BC, r24
			 TimDisplay=0;		 
   1596e:	10 92 a7 01 	sts	0x01A7, r1
		 }
		 if ((IsMessage99==True)||(IsMessage00==True)){
   15972:	80 91 b6 01 	lds	r24, 0x01B6
   15976:	81 30       	cpi	r24, 0x01	; 1
   15978:	29 f0       	breq	.+10     	; 0x15984 <FMenuIdle+0x284>
   1597a:	80 91 b5 01 	lds	r24, 0x01B5
   1597e:	81 30       	cpi	r24, 0x01	; 1
   15980:	09 f0       	breq	.+2      	; 0x15984 <FMenuIdle+0x284>
   15982:	6d c0       	rjmp	.+218    	; 0x15a5e <FMenuIdle+0x35e>
		     ClearMem(strOdometer);
   15984:	83 ea       	ldi	r24, 0xA3	; 163
   15986:	95 e0       	ldi	r25, 0x05	; 5
   15988:	0e 94 01 af 	call	0x15e02	; 0x15e02 <ClearMem>
		     ClearMem(strLicPlate);
   1598c:	82 ed       	ldi	r24, 0xD2	; 210
   1598e:	9a e0       	ldi	r25, 0x0A	; 10
   15990:	0e 94 01 af 	call	0x15e02	; 0x15e02 <ClearMem>
	         lcd_printf(3,1,PSTR("Ready...            "));
   15994:	83 e0       	ldi	r24, 0x03	; 3
   15996:	61 e0       	ldi	r22, 0x01	; 1
   15998:	4d e2       	ldi	r20, 0x2D	; 45
   1599a:	53 e2       	ldi	r21, 0x23	; 35
   1599c:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		     stMenuIdle=miWaitReady;
   159a0:	8a e0       	ldi	r24, 0x0A	; 10
   159a2:	80 93 bc 03 	sts	0x03BC, r24
			 TimDisplay=0;
   159a6:	10 92 a7 01 	sts	0x01A7, r1
   159aa:	59 c0       	rjmp	.+178    	; 0x15a5e <FMenuIdle+0x35e>
			 }
	     break;
    case miNoResponse:
         if (TimDisplay>1){
   159ac:	80 91 a7 01 	lds	r24, 0x01A7
   159b0:	82 30       	cpi	r24, 0x02	; 2
   159b2:	08 f4       	brcc	.+2      	; 0x159b6 <FMenuIdle+0x2b6>
   159b4:	54 c0       	rjmp	.+168    	; 0x15a5e <FMenuIdle+0x35e>
	         lcd_printf(3,1,PSTR("Ready...            "));
   159b6:	83 e0       	ldi	r24, 0x03	; 3
   159b8:	61 e0       	ldi	r22, 0x01	; 1
   159ba:	48 e1       	ldi	r20, 0x18	; 24
   159bc:	53 e2       	ldi	r21, 0x23	; 35
   159be:	ee cf       	rjmp	.-36     	; 0x1599c <FMenuIdle+0x29c>
		     stMenuIdle=miWaitReady;
			 TimDisplay=0;
			 }	     
	     break;
    case miWaitReady:
         if (TimDisplay>1){
   159c0:	80 91 a7 01 	lds	r24, 0x01A7
   159c4:	82 30       	cpi	r24, 0x02	; 2
   159c6:	08 f4       	brcc	.+2      	; 0x159ca <FMenuIdle+0x2ca>
   159c8:	4a c0       	rjmp	.+148    	; 0x15a5e <FMenuIdle+0x35e>
	         lcd_printf(3,1,PSTR("                "));
   159ca:	83 e0       	ldi	r24, 0x03	; 3
   159cc:	61 e0       	ldi	r22, 0x01	; 1
   159ce:	47 e0       	ldi	r20, 0x07	; 7
   159d0:	53 e2       	ldi	r21, 0x23	; 35
   159d2:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		     stMenuIdle=miReady;
   159d6:	8b e0       	ldi	r24, 0x0B	; 11
   159d8:	e4 cf       	rjmp	.-56     	; 0x159a2 <FMenuIdle+0x2a2>
			 TimDisplay=0;
			 }	     
	     break;
    case miReady:
	     _scr_idle();
   159da:	0e 94 ea 45 	call	0x8bd4	; 0x8bd4 <_scr_idle>
		 if (IFType==IT_STANDALONE)IsNewPumpStatus=True;
   159de:	80 91 10 01 	lds	r24, 0x0110
   159e2:	82 30       	cpi	r24, 0x02	; 2
   159e4:	19 f4       	brne	.+6      	; 0x159ec <FMenuIdle+0x2ec>
   159e6:	81 e0       	ldi	r24, 0x01	; 1
   159e8:	80 93 11 01 	sts	0x0111, r24
		 stMenuIdle=miScan;
   159ec:	81 e0       	ldi	r24, 0x01	; 1
   159ee:	35 c0       	rjmp	.+106    	; 0x15a5a <FMenuIdle+0x35a>
	     break;
	case miRunTicket://Slave,Standalone
		 if (FMenuTicket()==MENU_DONE)
   159f0:	0e 94 ab 85 	call	0x10b56	; 0x10b56 <FMenuTicket>
   159f4:	2f c0       	rjmp	.+94     	; 0x15a54 <FMenuIdle+0x354>
		     stMenuIdle=miReady;
	     break;
	case miRunAuth://Slave,Standalone
		 if (FMenuAuthorization()==MENU_DONE)
   159f6:	0e 94 6e 9b 	call	0x136dc	; 0x136dc <FMenuAuthorization>
   159fa:	2c c0       	rjmp	.+88     	; 0x15a54 <FMenuIdle+0x354>
		     stMenuIdle=miReady;
	     break;
		 
    case miRunLocalAccount://Slave
		 if (FMenuLocalAccount()==MENU_DONE)
   159fc:	0e 94 07 9d 	call	0x13a0e	; 0x13a0e <FMenuLocalAccount>
   15a00:	29 c0       	rjmp	.+82     	; 0x15a54 <FMenuIdle+0x354>
		     stMenuIdle=miReady;
	     break;  
    case miRunChangeMOP://Slave
	     if (FMenuChangeMOP()==MENU_DONE)
   15a02:	0e 94 72 94 	call	0x128e4	; 0x128e4 <FMenuChangeMOP>
   15a06:	26 c0       	rjmp	.+76     	; 0x15a54 <FMenuIdle+0x354>
		     stMenuIdle=miReady;
	     break;
    case miRunEDC://Slave
	     if (FMenuEDCTransaction()==MENU_DONE)
   15a08:	0e 94 82 66 	call	0xcd04	; 0xcd04 <FMenuEDCTransaction>
   15a0c:	23 c0       	rjmp	.+70     	; 0x15a54 <FMenuIdle+0x354>
		     stMenuIdle=miReady;
         break;
    case miRunLoyalty://Slave
	     if (FMenuLoyalty()==MENU_DONE)
   15a0e:	0e 94 76 67 	call	0xceec	; 0xceec <FMenuLoyalty>
   15a12:	20 c0       	rjmp	.+64     	; 0x15a54 <FMenuIdle+0x354>
		     stMenuIdle=miReady;
	     break;
    case miRunReprint://Slave,Standalone
	     if (FMenuReprint()==MENU_DONE)
   15a14:	0e 94 c7 92 	call	0x1258e	; 0x1258e <FMenuReprint>
   15a18:	1d c0       	rjmp	.+58     	; 0x15a54 <FMenuIdle+0x354>
		     stMenuIdle=miReady;
	     break;
    case miRunViewFreeMessage://Slave
	     if (FViewFreeMessage()==MENU_DONE)
   15a1a:	0e 94 b0 45 	call	0x8b60	; 0x8b60 <FViewFreeMessage>
   15a1e:	1a c0       	rjmp	.+52     	; 0x15a54 <FMenuIdle+0x354>
		     stMenuIdle=miReady;
	     break;
    case miClearTotalizer://Standalone
	     lcd_printf(3,1,PSTR("Clear Data Totalizer"));
   15a20:	83 e0       	ldi	r24, 0x03	; 3
   15a22:	61 e0       	ldi	r22, 0x01	; 1
   15a24:	42 ef       	ldi	r20, 0xF2	; 242
   15a26:	52 e2       	ldi	r21, 0x22	; 34
   15a28:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
	     ResetTotalizer(TOTALIZER_LAST);
   15a2c:	80 e0       	ldi	r24, 0x00	; 0
   15a2e:	0e 94 80 29 	call	0x5300	; 0x5300 <ResetTotalizer>
         ResetTotalizer(TOTALIZER_NOW);
   15a32:	81 e0       	ldi	r24, 0x01	; 1
   15a34:	0e 94 80 29 	call	0x5300	; 0x5300 <ResetTotalizer>
   15a38:	0f c0       	rjmp	.+30     	; 0x15a58 <FMenuIdle+0x358>
         stMenuIdle=miReady;	      
	     break;
    case miRunTotalizer://Standalone
	     lcd_printf(3,1,PSTR("TotalizerAll     "));
   15a3a:	83 e0       	ldi	r24, 0x03	; 3
   15a3c:	61 e0       	ldi	r22, 0x01	; 1
   15a3e:	40 ee       	ldi	r20, 0xE0	; 224
   15a40:	52 e2       	ldi	r21, 0x22	; 34
   15a42:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
	     SendSlaveCommand(SC_TOTALIZER,PUMP_ALL);
   15a46:	85 e0       	ldi	r24, 0x05	; 5
   15a48:	62 e1       	ldi	r22, 0x12	; 18
   15a4a:	0e 94 de 73 	call	0xe7bc	; 0xe7bc <SendSlaveCommand>
   15a4e:	04 c0       	rjmp	.+8      	; 0x15a58 <FMenuIdle+0x358>
		 stMenuIdle=miReady;	      
	     break;
    case miRunTestChar:	     
 	     if (FTestChar()==MENU_DONE)
   15a50:	0e 94 f3 44 	call	0x89e6	; 0x89e6 <FTestChar>
   15a54:	81 30       	cpi	r24, 0x01	; 1
   15a56:	19 f4       	brne	.+6      	; 0x15a5e <FMenuIdle+0x35e>
         stMenuIdle=miReady;
   15a58:	8b e0       	ldi	r24, 0x0B	; 11
   15a5a:	80 93 bc 03 	sts	0x03BC, r24
	     break;
	}
//----------SYSTEM_PROC--------------------------------

        //Bank InfoUpdated
        if (IsMessage21==True){
   15a5e:	80 91 b8 01 	lds	r24, 0x01B8
   15a62:	81 30       	cpi	r24, 0x01	; 1
   15a64:	21 f4       	brne	.+8      	; 0x15a6e <FMenuIdle+0x36e>
		    IsMessage21=False;
   15a66:	10 92 b8 01 	sts	0x01B8, r1
			procMessage21();
   15a6a:	0e 94 94 1d 	call	0x3b28	; 0x3b28 <procMessage21>

        }
        //Transaction Status
        if (IsMessage00==True){
   15a6e:	80 91 b5 01 	lds	r24, 0x01B5
   15a72:	81 30       	cpi	r24, 0x01	; 1
   15a74:	91 f4       	brne	.+36     	; 0x15a9a <FMenuIdle+0x39a>
		    IsMessage00=False;
   15a76:	10 92 b5 01 	sts	0x01B5, r1
*/
char procMessage00(){
     char Result,strSend[10];
	 Result=MSG00_NACK;
	 //Message57
	 if((rcv_trans[0]==0x01)&&(transLength==MSG00_LENGTH)){
   15a7a:	20 91 f5 0a 	lds	r18, 0x0AF5
   15a7e:	21 30       	cpi	r18, 0x01	; 1
   15a80:	61 f4       	brne	.+24     	; 0x15a9a <FMenuIdle+0x39a>
   15a82:	80 91 9e 01 	lds	r24, 0x019E
   15a86:	90 91 9f 01 	lds	r25, 0x019F
   15a8a:	8f 97       	sbiw	r24, 0x2f	; 47
   15a8c:	31 f4       	brne	.+12     	; 0x15a9a <FMenuIdle+0x39a>

        }
        //Transaction Status
        if (IsMessage00==True){
		    IsMessage00=False;
			if (procMessage00()==MSG00_NO_PRINT){
   15a8e:	80 91 1a 0b 	lds	r24, 0x0B1A
   15a92:	84 33       	cpi	r24, 0x34	; 52
   15a94:	11 f4       	brne	.+4      	; 0x15a9a <FMenuIdle+0x39a>
			    IsNoTransaction=True;
   15a96:	20 93 c2 01 	sts	0x01C2, r18
				}
		}
  
		//Send EDC Message Information;
		if (IsSendMessageEDC==True){
   15a9a:	80 91 ae 01 	lds	r24, 0x01AE
   15a9e:	81 30       	cpi	r24, 0x01	; 1
   15aa0:	21 f4       	brne	.+8      	; 0x15aaa <FMenuIdle+0x3aa>
		    IsSendMessageEDC=False;
   15aa2:	10 92 ae 01 	sts	0x01AE, r1
			SendEDCMessage();
   15aa6:	0e 94 59 73 	call	0xe6b2	; 0xe6b2 <SendEDCMessage>
		}
		if (IsEDCApproved==True){
   15aaa:	80 91 b0 01 	lds	r24, 0x01B0
   15aae:	81 30       	cpi	r24, 0x01	; 1
   15ab0:	21 f4       	brne	.+8      	; 0x15aba <FMenuIdle+0x3ba>
		    IsEDCApproved=False;
   15ab2:	10 92 b0 01 	sts	0x01B0, r1
            sendMessage92();
   15ab6:	0e 94 07 4f 	call	0x9e0e	; 0x9e0e <sendMessage92>
		}
		if (IsVoidTransaction==True){
   15aba:	80 91 b2 01 	lds	r24, 0x01B2
   15abe:	81 30       	cpi	r24, 0x01	; 1
   15ac0:	21 f4       	brne	.+8      	; 0x15aca <FMenuIdle+0x3ca>
		    IsVoidTransaction=False;
   15ac2:	10 92 b2 01 	sts	0x01B2, r1
            sendMessage94();
   15ac6:	0e 94 60 4e 	call	0x9cc0	; 0x9cc0 <sendMessage94>
		}


        //Message99 Detection 
        if (IsMessage99==True){
   15aca:	10 91 b6 01 	lds	r17, 0x01B6
   15ace:	11 30       	cpi	r17, 0x01	; 1
   15ad0:	31 f4       	brne	.+12     	; 0x15ade <FMenuIdle+0x3de>
	        IsMessage99=False;
   15ad2:	10 92 b6 01 	sts	0x01B6, r1
		    procMessage99();
   15ad6:	0e 94 9b 42 	call	0x8536	; 0x8536 <procMessage99>
		    IsPrinting=True;
   15ada:	10 93 c3 01 	sts	0x01C3, r17
		}
		//No Transaction
		if (IsNoTransaction==True){
   15ade:	80 91 c2 01 	lds	r24, 0x01C2
   15ae2:	81 30       	cpi	r24, 0x01	; 1
   15ae4:	41 f4       	brne	.+16     	; 0x15af6 <FMenuIdle+0x3f6>
			IsNoTransaction=False;
   15ae6:	10 92 c2 01 	sts	0x01C2, r1
			lcd_printf(3, 1,PSTR("Tidak Ada Transaksi "));
   15aea:	83 e0       	ldi	r24, 0x03	; 3
   15aec:	61 e0       	ldi	r22, 0x01	; 1
   15aee:	4b ec       	ldi	r20, 0xCB	; 203
   15af0:	52 e2       	ldi	r21, 0x22	; 34
   15af2:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
		}
        
		//Display Idle
		if (stMenuIdle==miScan){//||(stMenuIdle=miWaitPlease)){ 
   15af6:	80 91 bc 03 	lds	r24, 0x03BC
   15afa:	81 30       	cpi	r24, 0x01	; 1
   15afc:	11 f4       	brne	.+4      	; 0x15b02 <FMenuIdle+0x402>
		    DisplayIdle();			
   15afe:	0e 94 ed 71 	call	0xe3da	; 0xe3da <DisplayIdle>
			}        

        //Display FreeMessage
		if (stMenuIdle==miScan){ 
   15b02:	80 91 bc 03 	lds	r24, 0x03BC
   15b06:	81 30       	cpi	r24, 0x01	; 1
   15b08:	59 f4       	brne	.+22     	; 0x15b20 <FMenuIdle+0x420>
		    if (IsMessage09==True){
   15b0a:	80 91 ba 01 	lds	r24, 0x01BA
   15b0e:	81 30       	cpi	r24, 0x01	; 1
   15b10:	39 f4       	brne	.+14     	; 0x15b20 <FMenuIdle+0x420>
			    IsMessage09=False;
   15b12:	10 92 ba 01 	sts	0x01BA, r1
				procMessage09();
   15b16:	0e 94 59 17 	call	0x2eb2	; 0x2eb2 <procMessage09>
				stMenuIdle=miRunViewFreeMessage;
   15b1a:	83 e1       	ldi	r24, 0x13	; 19
   15b1c:	80 93 bc 03 	sts	0x03BC, r24
			   }
			}

        //LocalAccount Scanning
		if ((stMenuIdle==miScan)&&(IsRFIDDetected==True)){
   15b20:	80 91 bc 03 	lds	r24, 0x03BC
   15b24:	81 30       	cpi	r24, 0x01	; 1
   15b26:	89 f4       	brne	.+34     	; 0x15b4a <FMenuIdle+0x44a>
   15b28:	80 91 af 01 	lds	r24, 0x01AF
   15b2c:	81 30       	cpi	r24, 0x01	; 1
   15b2e:	69 f4       	brne	.+26     	; 0x15b4a <FMenuIdle+0x44a>
		    IsRFIDDetected=False;
   15b30:	10 92 af 01 	sts	0x01AF, r1
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   15b34:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   15b36:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   15b38:	82 e0       	ldi	r24, 0x02	; 2
   15b3a:	90 e0       	ldi	r25, 0x00	; 0
   15b3c:	90 93 d7 01 	sts	0x01D7, r25
   15b40:	80 93 d6 01 	sts	0x01D6, r24

        //LocalAccount Scanning
		if ((stMenuIdle==miScan)&&(IsRFIDDetected==True)){
		    IsRFIDDetected=False;
		    system_beep(2);           
			stMenuIdle=miRunLocalAccount;
   15b44:	8e e0       	ldi	r24, 0x0E	; 14
   15b46:	80 93 bc 03 	sts	0x03BC, r24
		}
        //Print Spooling
		if (IsMessage81==True){
   15b4a:	10 91 bd 01 	lds	r17, 0x01BD
   15b4e:	11 30       	cpi	r17, 0x01	; 1
   15b50:	41 f4       	brne	.+16     	; 0x15b62 <FMenuIdle+0x462>
		    IsMessage81=False;
   15b52:	10 92 bd 01 	sts	0x01BD, r1
			//Spooling HFCS 0000 : Header, Footer, Copy , Scrool [Copy:16x max]
			cmdPrint=procMessage81();
   15b56:	0e 94 36 18 	call	0x306c	; 0x306c <procMessage81>
   15b5a:	80 93 cb 01 	sts	0x01CB, r24
			IsFreePrinting=True;
   15b5e:	10 93 bf 01 	sts	0x01BF, r17
         }

    //SystemService
      systemGenerateReport();
   15b62:	0e 94 22 35 	call	0x6a44	; 0x6a44 <systemGenerateReport>
      systemPrinting();
   15b66:	0e 94 60 5e 	call	0xbcc0	; 0xbcc0 <systemPrinting>
	  systemEDC();
	  systemConfigProtocol();
   15b6a:	0e 94 5a ab 	call	0x156b4	; 0x156b4 <systemConfigProtocol>
	  //systemGeniusProtocol(); //AKR-->Protocol disabled
}
   15b6e:	1f 91       	pop	r17
   15b70:	08 95       	ret

00015b72 <lcd_command>:
	lcd_command(0x0c);
	lcd_command(0x06);
}

void lcd_command(unsigned char __chr){
	_LCD_PORT = __chr & 0xF0;
   15b72:	98 2f       	mov	r25, r24
   15b74:	90 7f       	andi	r25, 0xF0	; 240
   15b76:	95 bb       	out	0x15, r25	; 21
	cbi(_LCD_PORT, _LCD_RS);
   15b78:	ab 98       	cbi	0x15, 3	; 21
	sbi(_LCD_PORT, _LCD_E);
   15b7a:	a9 9a       	sbi	0x15, 1	; 21
   15b7c:	48 ee       	ldi	r20, 0xE8	; 232
   15b7e:	53 e0       	ldi	r21, 0x03	; 3
   15b80:	fa 01       	movw	r30, r20
   15b82:	31 97       	sbiw	r30, 0x01	; 1
   15b84:	f1 f7       	brne	.-4      	; 0x15b82 <lcd_command+0x10>
	_LCD_BUSY;
	cbi(_LCD_PORT, _LCD_E);
   15b86:	a9 98       	cbi	0x15, 1	; 21
   15b88:	fa 01       	movw	r30, r20
   15b8a:	31 97       	sbiw	r30, 0x01	; 1
   15b8c:	f1 f7       	brne	.-4      	; 0x15b8a <lcd_command+0x18>
	_LCD_BUSY;

	_LCD_PORT = (__chr & 0x0F) << 4;
   15b8e:	28 2f       	mov	r18, r24
   15b90:	30 e0       	ldi	r19, 0x00	; 0
   15b92:	94 e0       	ldi	r25, 0x04	; 4
   15b94:	22 0f       	add	r18, r18
   15b96:	33 1f       	adc	r19, r19
   15b98:	9a 95       	dec	r25
   15b9a:	e1 f7       	brne	.-8      	; 0x15b94 <lcd_command+0x22>
   15b9c:	25 bb       	out	0x15, r18	; 21
	cbi(_LCD_PORT, _LCD_RS);
   15b9e:	ab 98       	cbi	0x15, 3	; 21
	sbi(_LCD_PORT, _LCD_E);
   15ba0:	a9 9a       	sbi	0x15, 1	; 21
   15ba2:	fa 01       	movw	r30, r20
   15ba4:	31 97       	sbiw	r30, 0x01	; 1
   15ba6:	f1 f7       	brne	.-4      	; 0x15ba4 <lcd_command+0x32>
	_LCD_BUSY;
	cbi(_LCD_PORT, _LCD_E);
   15ba8:	a9 98       	cbi	0x15, 1	; 21
   15baa:	fa 01       	movw	r30, r20
   15bac:	31 97       	sbiw	r30, 0x01	; 1
   15bae:	f1 f7       	brne	.-4      	; 0x15bac <lcd_command+0x3a>
	_LCD_BUSY;
	_LCD_BUSY;
	if (__chr==0x01) _delay_ms(50);
   15bb0:	fa 01       	movw	r30, r20
   15bb2:	31 97       	sbiw	r30, 0x01	; 1
   15bb4:	f1 f7       	brne	.-4      	; 0x15bb2 <lcd_command+0x40>
   15bb6:	81 30       	cpi	r24, 0x01	; 1
   15bb8:	21 f4       	brne	.+8      	; 0x15bc2 <lcd_command+0x50>
   15bba:	84 ed       	ldi	r24, 0xD4	; 212
   15bbc:	90 e3       	ldi	r25, 0x30	; 48
   15bbe:	01 97       	sbiw	r24, 0x01	; 1
   15bc0:	f1 f7       	brne	.-4      	; 0x15bbe <lcd_command+0x4c>
   15bc2:	08 95       	ret

00015bc4 <lcd_init>:
   15bc4:	86 ea       	ldi	r24, 0xA6	; 166
   15bc6:	9e e0       	ldi	r25, 0x0E	; 14
   15bc8:	01 97       	sbiw	r24, 0x01	; 1
   15bca:	f1 f7       	brne	.-4      	; 0x15bc8 <lcd_init+0x4>

#define _LCD_BUSY	_delay_ms(4);

void lcd_init(void){
	_delay_ms(15);
	_LCD_PORT = 0x00;
   15bcc:	15 ba       	out	0x15, r1	; 21
	_LCD_DDR |= (1 << _LCD_D7) | (1 << _LCD_D6) | (1 << _LCD_D5) | (1 << _LCD_D4);
   15bce:	84 b3       	in	r24, 0x14	; 20
   15bd0:	80 6f       	ori	r24, 0xF0	; 240
   15bd2:	84 bb       	out	0x14, r24	; 20
	_LCD_DDR |= (1 << _LCD_E) | (1 << _LCD_RW) | (1 << _LCD_RS);
   15bd4:	84 b3       	in	r24, 0x14	; 20
   15bd6:	8e 60       	ori	r24, 0x0E	; 14
   15bd8:	84 bb       	out	0x14, r24	; 20

	_LCD_PORT = 0x30;
   15bda:	20 e3       	ldi	r18, 0x30	; 48
   15bdc:	25 bb       	out	0x15, r18	; 21
	sbi(_LCD_PORT, _LCD_E);
   15bde:	a9 9a       	sbi	0x15, 1	; 21
   15be0:	88 ee       	ldi	r24, 0xE8	; 232
   15be2:	93 e0       	ldi	r25, 0x03	; 3
   15be4:	fc 01       	movw	r30, r24
   15be6:	31 97       	sbiw	r30, 0x01	; 1
   15be8:	f1 f7       	brne	.-4      	; 0x15be6 <lcd_init+0x22>
	_LCD_BUSY;
	cbi(_LCD_PORT, _LCD_E);
   15bea:	a9 98       	cbi	0x15, 1	; 21
   15bec:	fc 01       	movw	r30, r24
   15bee:	31 97       	sbiw	r30, 0x01	; 1
   15bf0:	f1 f7       	brne	.-4      	; 0x15bee <lcd_init+0x2a>
	_LCD_BUSY;

	_LCD_PORT = 0x30;
   15bf2:	25 bb       	out	0x15, r18	; 21
	sbi(_LCD_PORT, _LCD_E);
   15bf4:	a9 9a       	sbi	0x15, 1	; 21
   15bf6:	fc 01       	movw	r30, r24
   15bf8:	31 97       	sbiw	r30, 0x01	; 1
   15bfa:	f1 f7       	brne	.-4      	; 0x15bf8 <lcd_init+0x34>
	_LCD_BUSY;
	cbi(_LCD_PORT, _LCD_E);
   15bfc:	a9 98       	cbi	0x15, 1	; 21
   15bfe:	fc 01       	movw	r30, r24
   15c00:	31 97       	sbiw	r30, 0x01	; 1
   15c02:	f1 f7       	brne	.-4      	; 0x15c00 <lcd_init+0x3c>
	_LCD_BUSY;

	_LCD_PORT = 0x30;
   15c04:	25 bb       	out	0x15, r18	; 21
	sbi(_LCD_PORT, _LCD_E);
   15c06:	a9 9a       	sbi	0x15, 1	; 21
   15c08:	fc 01       	movw	r30, r24
   15c0a:	31 97       	sbiw	r30, 0x01	; 1
   15c0c:	f1 f7       	brne	.-4      	; 0x15c0a <lcd_init+0x46>
	_LCD_BUSY;
	cbi(_LCD_PORT, _LCD_E);
   15c0e:	a9 98       	cbi	0x15, 1	; 21
   15c10:	fc 01       	movw	r30, r24
   15c12:	31 97       	sbiw	r30, 0x01	; 1
   15c14:	f1 f7       	brne	.-4      	; 0x15c12 <lcd_init+0x4e>
	_LCD_BUSY;

	_LCD_PORT = 0x20;
   15c16:	20 e2       	ldi	r18, 0x20	; 32
   15c18:	25 bb       	out	0x15, r18	; 21
	sbi(_LCD_PORT, _LCD_E);
   15c1a:	a9 9a       	sbi	0x15, 1	; 21
   15c1c:	fc 01       	movw	r30, r24
   15c1e:	31 97       	sbiw	r30, 0x01	; 1
   15c20:	f1 f7       	brne	.-4      	; 0x15c1e <lcd_init+0x5a>
	_LCD_BUSY;
	cbi(_LCD_PORT, _LCD_E);
   15c22:	a9 98       	cbi	0x15, 1	; 21
   15c24:	01 97       	sbiw	r24, 0x01	; 1
   15c26:	f1 f7       	brne	.-4      	; 0x15c24 <lcd_init+0x60>
	_LCD_BUSY;

	_LIGHT_PORT = 0x01;
   15c28:	81 e0       	ldi	r24, 0x01	; 1
   15c2a:	80 93 65 00 	sts	0x0065, r24
	_LIGHT_DDR |= (1 << _LIGHT_PIN);
   15c2e:	e4 e6       	ldi	r30, 0x64	; 100
   15c30:	f0 e0       	ldi	r31, 0x00	; 0
   15c32:	80 81       	ld	r24, Z
   15c34:	82 60       	ori	r24, 0x02	; 2
   15c36:	80 83       	st	Z, r24

	lcd_command(0x28);
   15c38:	88 e2       	ldi	r24, 0x28	; 40
   15c3a:	0e 94 b9 ad 	call	0x15b72	; 0x15b72 <lcd_command>
	lcd_command(0x0c);
   15c3e:	8c e0       	ldi	r24, 0x0C	; 12
   15c40:	0e 94 b9 ad 	call	0x15b72	; 0x15b72 <lcd_command>
	lcd_command(0x06);
   15c44:	86 e0       	ldi	r24, 0x06	; 6
   15c46:	0e 94 b9 ad 	call	0x15b72	; 0x15b72 <lcd_command>
}
   15c4a:	08 95       	ret

00015c4c <_lcd>:
	if (__chr==0x01) _delay_ms(50);

}

void _lcd(unsigned char __chr){
	_LCD_PORT =((__chr & 0xF0));
   15c4c:	28 2f       	mov	r18, r24
   15c4e:	20 7f       	andi	r18, 0xF0	; 240
   15c50:	25 bb       	out	0x15, r18	; 21
	sbi(_LCD_PORT, _LCD_RS);
   15c52:	ab 9a       	sbi	0x15, 3	; 21
	sbi(_LCD_PORT, _LCD_E);
   15c54:	a9 9a       	sbi	0x15, 1	; 21
	cbi(_LCD_PORT, _LCD_E);
   15c56:	a9 98       	cbi	0x15, 1	; 21

	_LCD_PORT = (((__chr & 0x0F) << 4));
   15c58:	90 e0       	ldi	r25, 0x00	; 0
   15c5a:	24 e0       	ldi	r18, 0x04	; 4
   15c5c:	88 0f       	add	r24, r24
   15c5e:	99 1f       	adc	r25, r25
   15c60:	2a 95       	dec	r18
   15c62:	e1 f7       	brne	.-8      	; 0x15c5c <_lcd+0x10>
   15c64:	85 bb       	out	0x15, r24	; 21
	sbi(_LCD_PORT, _LCD_RS);
   15c66:	ab 9a       	sbi	0x15, 3	; 21
	sbi(_LCD_PORT, _LCD_E);
   15c68:	a9 9a       	sbi	0x15, 1	; 21
	cbi(_LCD_PORT, _LCD_E);
   15c6a:	a9 98       	cbi	0x15, 1	; 21
   15c6c:	88 ee       	ldi	r24, 0xE8	; 232
   15c6e:	93 e0       	ldi	r25, 0x03	; 3
   15c70:	01 97       	sbiw	r24, 0x01	; 1
   15c72:	f1 f7       	brne	.-4      	; 0x15c70 <_lcd+0x24>
	_LCD_BUSY;
	_delay_ms(1);
}
   15c74:	8a ef       	ldi	r24, 0xFA	; 250
   15c76:	90 e0       	ldi	r25, 0x00	; 0
   15c78:	01 97       	sbiw	r24, 0x01	; 1
   15c7a:	f1 f7       	brne	.-4      	; 0x15c78 <_lcd+0x2c>
   15c7c:	08 95       	ret

00015c7e <lcd_string>:
     lcd_printf(2,1,PSTR("                    "));
     lcd_printf(3,1,PSTR("                    "));
     lcd_printf(4,1,PSTR("                    "));
}

void lcd_string(char *__string){
   15c7e:	cf 93       	push	r28
   15c80:	df 93       	push	r29
   15c82:	ec 01       	movw	r28, r24
   15c84:	03 c0       	rjmp	.+6      	; 0x15c8c <lcd_string+0xe>
	while(*__string)
		_lcd(*__string++);
   15c86:	21 96       	adiw	r28, 0x01	; 1
   15c88:	0e 94 26 ae 	call	0x15c4c	; 0x15c4c <_lcd>
     lcd_printf(3,1,PSTR("                    "));
     lcd_printf(4,1,PSTR("                    "));
}

void lcd_string(char *__string){
	while(*__string)
   15c8c:	88 81       	ld	r24, Y
   15c8e:	88 23       	and	r24, r24
   15c90:	d1 f7       	brne	.-12     	; 0x15c86 <lcd_string+0x8>
		_lcd(*__string++);
}
   15c92:	df 91       	pop	r29
   15c94:	cf 91       	pop	r28
   15c96:	08 95       	ret

00015c98 <lcd_xy>:

void lcd_xy(unsigned char __x, unsigned char __y){
	switch(__x){
   15c98:	82 30       	cpi	r24, 0x02	; 2
   15c9a:	69 f0       	breq	.+26     	; 0x15cb6 <lcd_xy+0x1e>
   15c9c:	83 30       	cpi	r24, 0x03	; 3
   15c9e:	18 f4       	brcc	.+6      	; 0x15ca6 <lcd_xy+0xe>
   15ca0:	81 30       	cpi	r24, 0x01	; 1
   15ca2:	a9 f4       	brne	.+42     	; 0x15cce <lcd_xy+0x36>
   15ca4:	05 c0       	rjmp	.+10     	; 0x15cb0 <lcd_xy+0x18>
   15ca6:	83 30       	cpi	r24, 0x03	; 3
   15ca8:	49 f0       	breq	.+18     	; 0x15cbc <lcd_xy+0x24>
   15caa:	84 30       	cpi	r24, 0x04	; 4
   15cac:	81 f4       	brne	.+32     	; 0x15cce <lcd_xy+0x36>
   15cae:	0b c0       	rjmp	.+22     	; 0x15cc6 <lcd_xy+0x2e>
		case 1:
			lcd_command(0x80 + __y - 1);
   15cb0:	86 2f       	mov	r24, r22
   15cb2:	81 58       	subi	r24, 0x81	; 129
   15cb4:	05 c0       	rjmp	.+10     	; 0x15cc0 <lcd_xy+0x28>
			break;
		case 2:
			lcd_command(0xC0 + __y - 1);
   15cb6:	86 2f       	mov	r24, r22
   15cb8:	81 54       	subi	r24, 0x41	; 65
   15cba:	02 c0       	rjmp	.+4      	; 0x15cc0 <lcd_xy+0x28>
			break;
		case 3:
			lcd_command(0x94 + __y - 1);
   15cbc:	86 2f       	mov	r24, r22
   15cbe:	8d 56       	subi	r24, 0x6D	; 109
   15cc0:	0e 94 b9 ad 	call	0x15b72	; 0x15b72 <lcd_command>
   15cc4:	08 95       	ret
			break;
		case 4:
			lcd_command(0xD4 + __y - 1);
   15cc6:	86 2f       	mov	r24, r22
   15cc8:	8d 52       	subi	r24, 0x2D	; 45
   15cca:	0e 94 b9 ad 	call	0x15b72	; 0x15b72 <lcd_command>
   15cce:	08 95       	ret

00015cd0 <lcd_print>:
	 for (i=0;i<strlen(string);i++){
          string[i]=0;
	 }     
}

void lcd_print(unsigned char __x, unsigned char __y, char *__string){
   15cd0:	df 92       	push	r13
   15cd2:	ef 92       	push	r14
   15cd4:	ff 92       	push	r15
   15cd6:	0f 93       	push	r16
   15cd8:	1f 93       	push	r17
   15cda:	cf 93       	push	r28
   15cdc:	df 93       	push	r29
   15cde:	06 2f       	mov	r16, r22
   15ce0:	d4 2e       	mov	r13, r20
   15ce2:	15 2f       	mov	r17, r21
    char yPos,iPos=0;//Modified by Iyan string [20] maks
	lcd_xy(__x, __y);
   15ce4:	0e 94 4c ae 	call	0x15c98	; 0x15c98 <lcd_xy>
   15ce8:	2d 2d       	mov	r18, r13
   15cea:	31 2f       	mov	r19, r17
   15cec:	c9 01       	movw	r24, r18
   15cee:	ec 01       	movw	r28, r24
	iPos=0;
	while((*__string)&&(iPos<=(20-__y))){
   15cf0:	34 e1       	ldi	r19, 0x14	; 20
   15cf2:	e3 2e       	mov	r14, r19
   15cf4:	f1 2c       	mov	r15, r1
   15cf6:	e0 1a       	sub	r14, r16
   15cf8:	f1 08       	sbc	r15, r1
   15cfa:	04 c0       	rjmp	.+8      	; 0x15d04 <lcd_print+0x34>
		_lcd(*__string);__string++;
   15cfc:	82 2f       	mov	r24, r18
   15cfe:	0e 94 26 ae 	call	0x15c4c	; 0x15c4c <_lcd>
   15d02:	21 96       	adiw	r28, 0x01	; 1
   15d04:	9e 01       	movw	r18, r28
   15d06:	2d 19       	sub	r18, r13
   15d08:	82 2f       	mov	r24, r18

void lcd_print(unsigned char __x, unsigned char __y, char *__string){
    char yPos,iPos=0;//Modified by Iyan string [20] maks
	lcd_xy(__x, __y);
	iPos=0;
	while((*__string)&&(iPos<=(20-__y))){
   15d0a:	28 81       	ld	r18, Y
   15d0c:	22 23       	and	r18, r18
   15d0e:	21 f0       	breq	.+8      	; 0x15d18 <lcd_print+0x48>
   15d10:	90 e0       	ldi	r25, 0x00	; 0
   15d12:	e8 16       	cp	r14, r24
   15d14:	f9 06       	cpc	r15, r25
   15d16:	94 f7       	brge	.-28     	; 0x15cfc <lcd_print+0x2c>
		_lcd(*__string);__string++;
		iPos++;
		}    
}
   15d18:	df 91       	pop	r29
   15d1a:	cf 91       	pop	r28
   15d1c:	1f 91       	pop	r17
   15d1e:	0f 91       	pop	r16
   15d20:	ff 90       	pop	r15
   15d22:	ef 90       	pop	r14
   15d24:	df 90       	pop	r13
   15d26:	08 95       	ret

00015d28 <lcd_printf>:

void lcd_printf(unsigned char __x, unsigned char __y, char *__string){
   15d28:	df 92       	push	r13
   15d2a:	ef 92       	push	r14
   15d2c:	ff 92       	push	r15
   15d2e:	0f 93       	push	r16
   15d30:	1f 93       	push	r17
   15d32:	cf 93       	push	r28
   15d34:	df 93       	push	r29
   15d36:	06 2f       	mov	r16, r22
   15d38:	d4 2e       	mov	r13, r20
   15d3a:	15 2f       	mov	r17, r21
    char iPos=0;
	lcd_xy(__x, __y);
   15d3c:	0e 94 4c ae 	call	0x15c98	; 0x15c98 <lcd_xy>
   15d40:	8d 2d       	mov	r24, r13
   15d42:	91 2f       	mov	r25, r17
   15d44:	fc 01       	movw	r30, r24
   15d46:	ef 01       	movw	r28, r30
	iPos=0;
	while((pgm_read_byte(&(*__string)))&&(iPos<=(20-__y))){
   15d48:	44 e1       	ldi	r20, 0x14	; 20
   15d4a:	e4 2e       	mov	r14, r20
   15d4c:	f1 2c       	mov	r15, r1
   15d4e:	e0 1a       	sub	r14, r16
   15d50:	f1 08       	sbc	r15, r1
   15d52:	04 c0       	rjmp	.+8      	; 0x15d5c <lcd_printf+0x34>
		_lcd(pgm_read_byte(&(*__string)));
   15d54:	82 2f       	mov	r24, r18
   15d56:	0e 94 26 ae 	call	0x15c4c	; 0x15c4c <_lcd>
		__string++;
   15d5a:	21 96       	adiw	r28, 0x01	; 1
   15d5c:	9e 01       	movw	r18, r28
   15d5e:	2d 19       	sub	r18, r13
   15d60:	82 2f       	mov	r24, r18

void lcd_printf(unsigned char __x, unsigned char __y, char *__string){
    char iPos=0;
	lcd_xy(__x, __y);
	iPos=0;
	while((pgm_read_byte(&(*__string)))&&(iPos<=(20-__y))){
   15d62:	fe 01       	movw	r30, r28
   15d64:	24 91       	lpm	r18, Z+
   15d66:	22 23       	and	r18, r18
   15d68:	21 f0       	breq	.+8      	; 0x15d72 <lcd_printf+0x4a>
   15d6a:	90 e0       	ldi	r25, 0x00	; 0
   15d6c:	e8 16       	cp	r14, r24
   15d6e:	f9 06       	cpc	r15, r25
   15d70:	8c f7       	brge	.-30     	; 0x15d54 <lcd_printf+0x2c>
		_lcd(pgm_read_byte(&(*__string)));
		__string++;
		iPos++;
		}
}
   15d72:	df 91       	pop	r29
   15d74:	cf 91       	pop	r28
   15d76:	1f 91       	pop	r17
   15d78:	0f 91       	pop	r16
   15d7a:	ff 90       	pop	r15
   15d7c:	ef 90       	pop	r14
   15d7e:	df 90       	pop	r13
   15d80:	08 95       	ret

00015d82 <lcd_clear>:
	_LCD_BUSY;
	_delay_ms(1);
}

void lcd_clear(){
     lcd_printf(1,1,PSTR("                    "));
   15d82:	81 e0       	ldi	r24, 0x01	; 1
   15d84:	61 e0       	ldi	r22, 0x01	; 1
   15d86:	4b ee       	ldi	r20, 0xEB	; 235
   15d88:	53 e2       	ldi	r21, 0x23	; 35
   15d8a:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
     lcd_printf(2,1,PSTR("                    "));
   15d8e:	82 e0       	ldi	r24, 0x02	; 2
   15d90:	61 e0       	ldi	r22, 0x01	; 1
   15d92:	46 ed       	ldi	r20, 0xD6	; 214
   15d94:	53 e2       	ldi	r21, 0x23	; 35
   15d96:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
     lcd_printf(3,1,PSTR("                    "));
   15d9a:	83 e0       	ldi	r24, 0x03	; 3
   15d9c:	61 e0       	ldi	r22, 0x01	; 1
   15d9e:	41 ec       	ldi	r20, 0xC1	; 193
   15da0:	53 e2       	ldi	r21, 0x23	; 35
   15da2:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
     lcd_printf(4,1,PSTR("                    "));
   15da6:	84 e0       	ldi	r24, 0x04	; 4
   15da8:	61 e0       	ldi	r22, 0x01	; 1
   15daa:	4c ea       	ldi	r20, 0xAC	; 172
   15dac:	53 e2       	ldi	r21, 0x23	; 35
   15dae:	0e 94 94 ae 	call	0x15d28	; 0x15d28 <lcd_printf>
}
   15db2:	08 95       	ret

00015db4 <lcd_put>:
		__string++;
		iPos++;
		}
}

void lcd_put(unsigned char __x, unsigned char __y, unsigned char __chr){
   15db4:	1f 93       	push	r17
   15db6:	14 2f       	mov	r17, r20
	lcd_xy(__x, __y);
   15db8:	0e 94 4c ae 	call	0x15c98	; 0x15c98 <lcd_xy>
	_lcd(__chr);
   15dbc:	81 2f       	mov	r24, r17
   15dbe:	0e 94 26 ae 	call	0x15c4c	; 0x15c4c <_lcd>
}
   15dc2:	1f 91       	pop	r17
   15dc4:	08 95       	ret

00015dc6 <lcd_cgram>:

void lcd_cgram(unsigned char location, char *ptr){
   15dc6:	0f 93       	push	r16
   15dc8:	1f 93       	push	r17
   15dca:	cf 93       	push	r28
   15dcc:	df 93       	push	r29
   15dce:	8b 01       	movw	r16, r22
	unsigned char i;
    if(location < 8){
   15dd0:	88 30       	cpi	r24, 0x08	; 8
   15dd2:	90 f4       	brcc	.+36     	; 0x15df8 <lcd_cgram+0x32>
		lcd_command(0x40 + (location * 8));
   15dd4:	88 0f       	add	r24, r24
   15dd6:	88 0f       	add	r24, r24
   15dd8:	88 0f       	add	r24, r24
   15dda:	80 5c       	subi	r24, 0xC0	; 192
   15ddc:	0e 94 b9 ad 	call	0x15b72	; 0x15b72 <lcd_command>
   15de0:	c0 e0       	ldi	r28, 0x00	; 0
   15de2:	d0 e0       	ldi	r29, 0x00	; 0
		for(i = 0; i < 8; i++)
			_lcd(ptr[i]);
   15de4:	f8 01       	movw	r30, r16
   15de6:	ec 0f       	add	r30, r28
   15de8:	fd 1f       	adc	r31, r29
   15dea:	80 81       	ld	r24, Z
   15dec:	0e 94 26 ae 	call	0x15c4c	; 0x15c4c <_lcd>
   15df0:	21 96       	adiw	r28, 0x01	; 1

void lcd_cgram(unsigned char location, char *ptr){
	unsigned char i;
    if(location < 8){
		lcd_command(0x40 + (location * 8));
		for(i = 0; i < 8; i++)
   15df2:	c8 30       	cpi	r28, 0x08	; 8
   15df4:	d1 05       	cpc	r29, r1
   15df6:	b1 f7       	brne	.-20     	; 0x15de4 <lcd_cgram+0x1e>
			_lcd(ptr[i]);
	}
}
   15df8:	df 91       	pop	r29
   15dfa:	cf 91       	pop	r28
   15dfc:	1f 91       	pop	r17
   15dfe:	0f 91       	pop	r16
   15e00:	08 95       	ret

00015e02 <ClearMem>:
			lcd_command(0xD4 + __y - 1);
			break;
	}
}

void ClearMem(char *string){
   15e02:	cf 93       	push	r28
   15e04:	df 93       	push	r29
   15e06:	20 e0       	ldi	r18, 0x00	; 0
   15e08:	04 c0       	rjmp	.+8      	; 0x15e12 <ClearMem+0x10>
     char i;
	 for (i=0;i<strlen(string);i++){
          string[i]=0;
   15e0a:	c8 0f       	add	r28, r24
   15e0c:	d9 1f       	adc	r29, r25
   15e0e:	18 82       	st	Y, r1
	}
}

void ClearMem(char *string){
     char i;
	 for (i=0;i<strlen(string);i++){
   15e10:	2f 5f       	subi	r18, 0xFF	; 255
   15e12:	c2 2f       	mov	r28, r18
   15e14:	d0 e0       	ldi	r29, 0x00	; 0
   15e16:	fc 01       	movw	r30, r24
   15e18:	01 90       	ld	r0, Z+
   15e1a:	00 20       	and	r0, r0
   15e1c:	e9 f7       	brne	.-6      	; 0x15e18 <ClearMem+0x16>
   15e1e:	31 97       	sbiw	r30, 0x01	; 1
   15e20:	e8 1b       	sub	r30, r24
   15e22:	f9 0b       	sbc	r31, r25
   15e24:	ce 17       	cp	r28, r30
   15e26:	df 07       	cpc	r29, r31
   15e28:	80 f3       	brcs	.-32     	; 0x15e0a <ClearMem+0x8>
          string[i]=0;
	 }     
}
   15e2a:	df 91       	pop	r29
   15e2c:	cf 91       	pop	r28
   15e2e:	08 95       	ret

00015e30 <_key_hit>:
													 {'7', 'P', 'Q', 'R', 'S', '\0'},
											         {'8', 'T', 'U', 'V', '\0'}, 
													 {'9', 'W', 'X', 'Y', 'Z', '\0'}}};
const unsigned char __maxchar[10] PROGMEM = {2, 4, 3, 3, 3, 3, 3, 4, 3, 4};

char _key_hit(void){
   15e30:	df 93       	push	r29
   15e32:	cf 93       	push	r28
   15e34:	00 d0       	rcall	.+0      	; 0x15e36 <_key_hit+0x6>
   15e36:	00 d0       	rcall	.+0      	; 0x15e38 <_key_hit+0x8>
   15e38:	cd b7       	in	r28, 0x3d	; 61
   15e3a:	de b7       	in	r29, 0x3e	; 62
	unsigned char	i, keyhit=0x00;
	unsigned char	outmap[4] = {0xef, 0xdf, 0xbf, 0x7f};
   15e3c:	8f ee       	ldi	r24, 0xEF	; 239
   15e3e:	89 83       	std	Y+1, r24	; 0x01
   15e40:	8f ed       	ldi	r24, 0xDF	; 223
   15e42:	8a 83       	std	Y+2, r24	; 0x02
   15e44:	8f eb       	ldi	r24, 0xBF	; 191
   15e46:	8b 83       	std	Y+3, r24	; 0x03
   15e48:	8f e7       	ldi	r24, 0x7F	; 127
   15e4a:	8c 83       	std	Y+4, r24	; 0x04
   15e4c:	de 01       	movw	r26, r28
   15e4e:	11 96       	adiw	r26, 0x01	; 1
   15e50:	2a ef       	ldi	r18, 0xFA	; 250
   15e52:	30 e0       	ldi	r19, 0x00	; 0

	for(i=0; i<4; i++){
   15e54:	ae 01       	movw	r20, r28
   15e56:	4b 5f       	subi	r20, 0xFB	; 251
   15e58:	5f 4f       	sbci	r21, 0xFF	; 255
   15e5a:	c9 01       	movw	r24, r18
   15e5c:	01 97       	sbiw	r24, 0x01	; 1
   15e5e:	f1 f7       	brne	.-4      	; 0x15e5c <_key_hit+0x2c>
		_delay_ms(1);
		_KEY_PORT = outmap[i];
   15e60:	8c 91       	ld	r24, X
   15e62:	80 93 62 00 	sts	0x0062, r24
   15e66:	f9 01       	movw	r30, r18
   15e68:	31 97       	sbiw	r30, 0x01	; 1
   15e6a:	f1 f7       	brne	.-4      	; 0x15e68 <_key_hit+0x38>
		_delay_ms(1);
		keyhit = _KEY_MATRIX;
   15e6c:	90 b1       	in	r25, 0x00	; 0
		if (keyhit!=outmap[i]) 
   15e6e:	98 17       	cp	r25, r24
   15e70:	21 f4       	brne	.+8      	; 0x15e7a <_key_hit+0x4a>
		    break;
   15e72:	11 96       	adiw	r26, 0x01	; 1

char _key_hit(void){
	unsigned char	i, keyhit=0x00;
	unsigned char	outmap[4] = {0xef, 0xdf, 0xbf, 0x7f};

	for(i=0; i<4; i++){
   15e74:	a4 17       	cp	r26, r20
   15e76:	b5 07       	cpc	r27, r21
   15e78:	81 f7       	brne	.-32     	; 0x15e5a <_key_hit+0x2a>
		keyhit = _KEY_MATRIX;
		if (keyhit!=outmap[i]) 
		    break;
	}
	return keyhit;
}
   15e7a:	89 2f       	mov	r24, r25
   15e7c:	0f 90       	pop	r0
   15e7e:	0f 90       	pop	r0
   15e80:	0f 90       	pop	r0
   15e82:	0f 90       	pop	r0
   15e84:	cf 91       	pop	r28
   15e86:	df 91       	pop	r29
   15e88:	08 95       	ret

00015e8a <_key_crr>:

char _key_crr(char __key){
	if(	__key != _KEY_1 && __key != _KEY_2 &&
   15e8a:	8e 3e       	cpi	r24, 0xEE	; 238
   15e8c:	f9 f0       	breq	.+62     	; 0x15ecc <_key_crr+0x42>
   15e8e:	8e 3d       	cpi	r24, 0xDE	; 222
   15e90:	e9 f0       	breq	.+58     	; 0x15ecc <_key_crr+0x42>
   15e92:	8e 3b       	cpi	r24, 0xBE	; 190
   15e94:	d9 f0       	breq	.+54     	; 0x15ecc <_key_crr+0x42>
   15e96:	8d 3e       	cpi	r24, 0xED	; 237
   15e98:	c9 f0       	breq	.+50     	; 0x15ecc <_key_crr+0x42>
   15e9a:	8d 3d       	cpi	r24, 0xDD	; 221
   15e9c:	b9 f0       	breq	.+46     	; 0x15ecc <_key_crr+0x42>
   15e9e:	8d 3b       	cpi	r24, 0xBD	; 189
   15ea0:	a9 f0       	breq	.+42     	; 0x15ecc <_key_crr+0x42>
   15ea2:	8b 3e       	cpi	r24, 0xEB	; 235
   15ea4:	99 f0       	breq	.+38     	; 0x15ecc <_key_crr+0x42>
   15ea6:	8b 3d       	cpi	r24, 0xDB	; 219
   15ea8:	89 f0       	breq	.+34     	; 0x15ecc <_key_crr+0x42>
   15eaa:	8b 3b       	cpi	r24, 0xBB	; 187
   15eac:	79 f0       	breq	.+30     	; 0x15ecc <_key_crr+0x42>
   15eae:	87 3d       	cpi	r24, 0xD7	; 215
   15eb0:	69 f0       	breq	.+26     	; 0x15ecc <_key_crr+0x42>
   15eb2:	87 3e       	cpi	r24, 0xE7	; 231
   15eb4:	59 f0       	breq	.+22     	; 0x15ecc <_key_crr+0x42>
   15eb6:	87 3b       	cpi	r24, 0xB7	; 183
   15eb8:	49 f0       	breq	.+18     	; 0x15ecc <_key_crr+0x42>
   15eba:	8e 37       	cpi	r24, 0x7E	; 126
   15ebc:	39 f0       	breq	.+14     	; 0x15ecc <_key_crr+0x42>
   15ebe:	8d 37       	cpi	r24, 0x7D	; 125
   15ec0:	29 f0       	breq	.+10     	; 0x15ecc <_key_crr+0x42>
   15ec2:	8b 37       	cpi	r24, 0x7B	; 123
   15ec4:	19 f0       	breq	.+6      	; 0x15ecc <_key_crr+0x42>
   15ec6:	87 37       	cpi	r24, 0x77	; 119
   15ec8:	09 f0       	breq	.+2      	; 0x15ecc <_key_crr+0x42>
   15eca:	80 e0       	ldi	r24, 0x00	; 0
		__key != _KEY_CANCEL && __key != _KEY_ENTER &&
		__key != _KEY_TIKET && __key != _KEY_MENU &&
		__key != _KEY_SHIFT && __key != _KEY_CLEAR)
		return _KEY_NULL;
	return __key;
}
   15ecc:	08 95       	ret

00015ece <_key_btn>:

char _key_btn(char __key){
	char __keychar = 0;
	
	switch (__key){
   15ece:	8e 3b       	cpi	r24, 0xBE	; 190
   15ed0:	91 f1       	breq	.+100    	; 0x15f36 <_key_btn+0x68>
   15ed2:	8f 3b       	cpi	r24, 0xBF	; 191
   15ed4:	a8 f4       	brcc	.+42     	; 0x15f00 <_key_btn+0x32>
   15ed6:	8e 37       	cpi	r24, 0x7E	; 126
   15ed8:	09 f4       	brne	.+2      	; 0x15edc <_key_btn+0xe>
   15eda:	41 c0       	rjmp	.+130    	; 0x15f5e <_key_btn+0x90>
   15edc:	8f 37       	cpi	r24, 0x7F	; 127
   15ede:	48 f4       	brcc	.+18     	; 0x15ef2 <_key_btn+0x24>
   15ee0:	8b 37       	cpi	r24, 0x7B	; 123
   15ee2:	09 f4       	brne	.+2      	; 0x15ee6 <_key_btn+0x18>
   15ee4:	40 c0       	rjmp	.+128    	; 0x15f66 <_key_btn+0x98>
   15ee6:	8d 37       	cpi	r24, 0x7D	; 125
   15ee8:	e1 f1       	breq	.+120    	; 0x15f62 <_key_btn+0x94>
   15eea:	87 37       	cpi	r24, 0x77	; 119
   15eec:	09 f0       	breq	.+2      	; 0x15ef0 <_key_btn+0x22>
   15eee:	3f c0       	rjmp	.+126    	; 0x15f6e <_key_btn+0xa0>
   15ef0:	3c c0       	rjmp	.+120    	; 0x15f6a <_key_btn+0x9c>
   15ef2:	8b 3b       	cpi	r24, 0xBB	; 187
   15ef4:	61 f1       	breq	.+88     	; 0x15f4e <_key_btn+0x80>
   15ef6:	8d 3b       	cpi	r24, 0xBD	; 189
   15ef8:	21 f1       	breq	.+72     	; 0x15f42 <_key_btn+0x74>
   15efa:	87 3b       	cpi	r24, 0xB7	; 183
   15efc:	c1 f5       	brne	.+112    	; 0x15f6e <_key_btn+0xa0>
   15efe:	2d c0       	rjmp	.+90     	; 0x15f5a <_key_btn+0x8c>
   15f00:	8e 3d       	cpi	r24, 0xDE	; 222
   15f02:	a9 f0       	breq	.+42     	; 0x15f2e <_key_btn+0x60>
   15f04:	8f 3d       	cpi	r24, 0xDF	; 223
   15f06:	38 f4       	brcc	.+14     	; 0x15f16 <_key_btn+0x48>
   15f08:	8b 3d       	cpi	r24, 0xDB	; 219
   15f0a:	f9 f0       	breq	.+62     	; 0x15f4a <_key_btn+0x7c>
   15f0c:	8d 3d       	cpi	r24, 0xDD	; 221
   15f0e:	b9 f0       	breq	.+46     	; 0x15f3e <_key_btn+0x70>
   15f10:	87 3d       	cpi	r24, 0xD7	; 215
   15f12:	69 f5       	brne	.+90     	; 0x15f6e <_key_btn+0xa0>
   15f14:	1e c0       	rjmp	.+60     	; 0x15f52 <_key_btn+0x84>
   15f16:	8b 3e       	cpi	r24, 0xEB	; 235
   15f18:	b1 f0       	breq	.+44     	; 0x15f46 <_key_btn+0x78>
   15f1a:	8c 3e       	cpi	r24, 0xEC	; 236
   15f1c:	18 f4       	brcc	.+6      	; 0x15f24 <_key_btn+0x56>
   15f1e:	87 3e       	cpi	r24, 0xE7	; 231
   15f20:	31 f5       	brne	.+76     	; 0x15f6e <_key_btn+0xa0>
   15f22:	19 c0       	rjmp	.+50     	; 0x15f56 <_key_btn+0x88>
   15f24:	8d 3e       	cpi	r24, 0xED	; 237
   15f26:	49 f0       	breq	.+18     	; 0x15f3a <_key_btn+0x6c>
   15f28:	8e 3e       	cpi	r24, 0xEE	; 238
   15f2a:	09 f5       	brne	.+66     	; 0x15f6e <_key_btn+0xa0>
   15f2c:	02 c0       	rjmp	.+4      	; 0x15f32 <_key_btn+0x64>
   15f2e:	82 e3       	ldi	r24, 0x32	; 50
   15f30:	08 95       	ret
   15f32:	81 e3       	ldi	r24, 0x31	; 49
   15f34:	08 95       	ret
   15f36:	83 e3       	ldi	r24, 0x33	; 51
   15f38:	08 95       	ret
		case 0xDE:
			__keychar = 0x32; //2
			break;
		case 0xBE:
			__keychar = 0x33; //3
			break;
   15f3a:	84 e3       	ldi	r24, 0x34	; 52
   15f3c:	08 95       	ret
		case 0xED:
			__keychar = 0x34; //4
			break;
   15f3e:	85 e3       	ldi	r24, 0x35	; 53
   15f40:	08 95       	ret
		case 0xDD:
			__keychar = 0x35; //5
			break;
   15f42:	86 e3       	ldi	r24, 0x36	; 54
   15f44:	08 95       	ret
		case 0xBD:
			__keychar = 0x36; //6
			break;
   15f46:	87 e3       	ldi	r24, 0x37	; 55
   15f48:	08 95       	ret
		case 0xEB:
			__keychar = 0x37; //7
			break;
   15f4a:	88 e3       	ldi	r24, 0x38	; 56
   15f4c:	08 95       	ret
		case 0xDB:
			__keychar = 0x38; //8
			break;
   15f4e:	89 e3       	ldi	r24, 0x39	; 57
   15f50:	08 95       	ret
		case 0xBB:
			__keychar = 0x39; //9
			break;
   15f52:	80 e3       	ldi	r24, 0x30	; 48
   15f54:	08 95       	ret
		case 0xD7:
			__keychar = 0x30; //0
			break;
   15f56:	8a e2       	ldi	r24, 0x2A	; 42
   15f58:	08 95       	ret
		case 0xE7:
			__keychar = 0x2a; //*
			break;
   15f5a:	83 e2       	ldi	r24, 0x23	; 35
   15f5c:	08 95       	ret
		case 0xB7:
			__keychar = 0x23; //#
			break;
   15f5e:	81 ef       	ldi	r24, 0xF1	; 241
   15f60:	08 95       	ret
		case 0x7E:
			__keychar = 0xF1; //Menu 1
			break;
   15f62:	82 ef       	ldi	r24, 0xF2	; 242
   15f64:	08 95       	ret
		case 0x7D:
			__keychar = 0xF2; //Menu 2
			break;
   15f66:	83 ef       	ldi	r24, 0xF3	; 243
   15f68:	08 95       	ret
		case 0x7B:
			__keychar = 0xF3; //Menu 3
			break;
   15f6a:	84 ef       	ldi	r24, 0xF4	; 244
   15f6c:	08 95       	ret
		case 0x77:
			__keychar = 0xF4; //Menu 4
			break;
   15f6e:	80 e0       	ldi	r24, 0x00	; 0
			__keychar = 0x00;
			break;

	}
	return __keychar;
}
   15f70:	08 95       	ret

00015f72 <_table_alphanum>:
	}
	_PAD_1st;
	return __key;
}

char _table_alphanum(char __caps, char __key, char __hit){
   15f72:	98 2f       	mov	r25, r24
unsigned char __retchar = 0;

	switch(__key){
   15f74:	6d 3d       	cpi	r22, 0xDD	; 221
   15f76:	11 f1       	breq	.+68     	; 0x15fbc <_table_alphanum+0x4a>
   15f78:	6e 3d       	cpi	r22, 0xDE	; 222
   15f7a:	60 f4       	brcc	.+24     	; 0x15f94 <_table_alphanum+0x22>
   15f7c:	6d 3b       	cpi	r22, 0xBD	; 189
   15f7e:	01 f1       	breq	.+64     	; 0x15fc0 <_table_alphanum+0x4e>
   15f80:	6e 3b       	cpi	r22, 0xBE	; 190
   15f82:	18 f4       	brcc	.+6      	; 0x15f8a <_table_alphanum+0x18>
   15f84:	6b 3b       	cpi	r22, 0xBB	; 187
   15f86:	21 f5       	brne	.+72     	; 0x15fd0 <_table_alphanum+0x5e>
   15f88:	21 c0       	rjmp	.+66     	; 0x15fcc <_table_alphanum+0x5a>
   15f8a:	6e 3b       	cpi	r22, 0xBE	; 190
   15f8c:	99 f0       	breq	.+38     	; 0x15fb4 <_table_alphanum+0x42>
   15f8e:	6b 3d       	cpi	r22, 0xDB	; 219
   15f90:	f9 f4       	brne	.+62     	; 0x15fd0 <_table_alphanum+0x5e>
   15f92:	1a c0       	rjmp	.+52     	; 0x15fc8 <_table_alphanum+0x56>
   15f94:	6b 3e       	cpi	r22, 0xEB	; 235
   15f96:	b1 f0       	breq	.+44     	; 0x15fc4 <_table_alphanum+0x52>
   15f98:	6c 3e       	cpi	r22, 0xEC	; 236
   15f9a:	18 f4       	brcc	.+6      	; 0x15fa2 <_table_alphanum+0x30>
   15f9c:	6e 3d       	cpi	r22, 0xDE	; 222
   15f9e:	c1 f4       	brne	.+48     	; 0x15fd0 <_table_alphanum+0x5e>
   15fa0:	05 c0       	rjmp	.+10     	; 0x15fac <_table_alphanum+0x3a>
   15fa2:	6d 3e       	cpi	r22, 0xED	; 237
   15fa4:	49 f0       	breq	.+18     	; 0x15fb8 <_table_alphanum+0x46>
   15fa6:	6e 3e       	cpi	r22, 0xEE	; 238
   15fa8:	99 f4       	brne	.+38     	; 0x15fd0 <_table_alphanum+0x5e>
   15faa:	02 c0       	rjmp	.+4      	; 0x15fb0 <_table_alphanum+0x3e>
   15fac:	82 e0       	ldi	r24, 0x02	; 2
   15fae:	11 c0       	rjmp	.+34     	; 0x15fd2 <_table_alphanum+0x60>
   15fb0:	81 e0       	ldi	r24, 0x01	; 1
   15fb2:	0f c0       	rjmp	.+30     	; 0x15fd2 <_table_alphanum+0x60>
   15fb4:	83 e0       	ldi	r24, 0x03	; 3
   15fb6:	0d c0       	rjmp	.+26     	; 0x15fd2 <_table_alphanum+0x60>
		case 0xDE:
			__key = 2; //2
			break;
		case 0xBE:
			__key = 3; //3
			break;
   15fb8:	84 e0       	ldi	r24, 0x04	; 4
   15fba:	0b c0       	rjmp	.+22     	; 0x15fd2 <_table_alphanum+0x60>
		case 0xED:
			__key = 4; //4
			break;
   15fbc:	85 e0       	ldi	r24, 0x05	; 5
   15fbe:	09 c0       	rjmp	.+18     	; 0x15fd2 <_table_alphanum+0x60>
		case 0xDD:
			__key = 5; //5
			break;
   15fc0:	86 e0       	ldi	r24, 0x06	; 6
   15fc2:	07 c0       	rjmp	.+14     	; 0x15fd2 <_table_alphanum+0x60>
		case 0xBD:
			__key = 6; //6
			break;
   15fc4:	87 e0       	ldi	r24, 0x07	; 7
   15fc6:	05 c0       	rjmp	.+10     	; 0x15fd2 <_table_alphanum+0x60>
		case 0xEB:
			__key = 7; //7
			break;
   15fc8:	88 e0       	ldi	r24, 0x08	; 8
   15fca:	03 c0       	rjmp	.+6      	; 0x15fd2 <_table_alphanum+0x60>
		case 0xDB:
			__key = 8; //8
			break;
   15fcc:	89 e0       	ldi	r24, 0x09	; 9
   15fce:	01 c0       	rjmp	.+2      	; 0x15fd2 <_table_alphanum+0x60>
		case 0xBB:
			__key = 9; //9
			break;
   15fd0:	80 e0       	ldi	r24, 0x00	; 0
		default:
			__key = 0;
			break;	
	}

	if(__hit <= pgm_read_byte(&__maxchar[__key]))
   15fd2:	28 2f       	mov	r18, r24
   15fd4:	30 e0       	ldi	r19, 0x00	; 0
   15fd6:	f9 01       	movw	r30, r18
   15fd8:	e8 58       	subi	r30, 0x88	; 136
   15fda:	fb 4d       	sbci	r31, 0xDB	; 219
   15fdc:	e4 91       	lpm	r30, Z+
   15fde:	e4 17       	cp	r30, r20
   15fe0:	10 f4       	brcc	.+4      	; 0x15fe6 <_table_alphanum+0x74>
   15fe2:	80 e0       	ldi	r24, 0x00	; 0
   15fe4:	08 95       	ret
		__retchar = pgm_read_byte(&__alphanum[__caps][__key][__hit]);
   15fe6:	ec e3       	ldi	r30, 0x3C	; 60
   15fe8:	9e 9f       	mul	r25, r30
   15fea:	f0 01       	movw	r30, r0
   15fec:	11 24       	eor	r1, r1
   15fee:	e4 0f       	add	r30, r20
   15ff0:	f1 1d       	adc	r31, r1
   15ff2:	c9 01       	movw	r24, r18
   15ff4:	88 0f       	add	r24, r24
   15ff6:	99 1f       	adc	r25, r25
   15ff8:	82 0f       	add	r24, r18
   15ffa:	93 1f       	adc	r25, r19
   15ffc:	88 0f       	add	r24, r24
   15ffe:	99 1f       	adc	r25, r25
   16000:	e8 0f       	add	r30, r24
   16002:	f9 1f       	adc	r31, r25
   16004:	e0 50       	subi	r30, 0x00	; 0
   16006:	fc 4d       	sbci	r31, 0xDC	; 220
   16008:	84 91       	lpm	r24, Z+
	else __retchar = '\0';

	return __retchar;
}
   1600a:	08 95       	ret

0001600c <_key_scan>:





char _key_scan(char __select){
   1600c:	8f 92       	push	r8
   1600e:	9f 92       	push	r9
   16010:	af 92       	push	r10
   16012:	bf 92       	push	r11
   16014:	cf 92       	push	r12
   16016:	df 92       	push	r13
   16018:	ef 92       	push	r14
   1601a:	ff 92       	push	r15
   1601c:	0f 93       	push	r16
   1601e:	1f 93       	push	r17
   16020:	df 93       	push	r29
   16022:	cf 93       	push	r28
   16024:	00 d0       	rcall	.+0      	; 0x16026 <_key_scan+0x1a>
   16026:	00 d0       	rcall	.+0      	; 0x16028 <_key_scan+0x1c>
   16028:	cd b7       	in	r28, 0x3d	; 61
   1602a:	de b7       	in	r29, 0x3e	; 62
   1602c:	18 2f       	mov	r17, r24
	char	__key = 0;

	if(__select==_PAD_SINGLE || __select==_PAD_MULTI){
   1602e:	81 50       	subi	r24, 0x01	; 1
   16030:	82 30       	cpi	r24, 0x02	; 2
   16032:	08 f0       	brcs	.+2      	; 0x16036 <_key_scan+0x2a>
   16034:	aa c0       	rjmp	.+340    	; 0x1618a <_key_scan+0x17e>
													 {'9', 'W', 'X', 'Y', 'Z', '\0'}}};
const unsigned char __maxchar[10] PROGMEM = {2, 4, 3, 3, 3, 3, 3, 4, 3, 4};

char _key_hit(void){
	unsigned char	i, keyhit=0x00;
	unsigned char	outmap[4] = {0xef, 0xdf, 0xbf, 0x7f};
   16036:	8f ee       	ldi	r24, 0xEF	; 239
   16038:	89 83       	std	Y+1, r24	; 0x01
   1603a:	8f ed       	ldi	r24, 0xDF	; 223
   1603c:	8a 83       	std	Y+2, r24	; 0x02
   1603e:	8f eb       	ldi	r24, 0xBF	; 191
   16040:	8b 83       	std	Y+3, r24	; 0x03
   16042:	8f e7       	ldi	r24, 0x7F	; 127
   16044:	8c 83       	std	Y+4, r24	; 0x04
   16046:	de 01       	movw	r26, r28
   16048:	11 96       	adiw	r26, 0x01	; 1
   1604a:	2a ef       	ldi	r18, 0xFA	; 250
   1604c:	30 e0       	ldi	r19, 0x00	; 0

	for(i=0; i<4; i++){
   1604e:	ae 01       	movw	r20, r28
   16050:	4b 5f       	subi	r20, 0xFB	; 251
   16052:	5f 4f       	sbci	r21, 0xFF	; 255
   16054:	c9 01       	movw	r24, r18
   16056:	01 97       	sbiw	r24, 0x01	; 1
   16058:	f1 f7       	brne	.-4      	; 0x16056 <_key_scan+0x4a>
		_delay_ms(1);
		_KEY_PORT = outmap[i];
   1605a:	8c 91       	ld	r24, X
   1605c:	80 93 62 00 	sts	0x0062, r24
   16060:	f9 01       	movw	r30, r18
   16062:	31 97       	sbiw	r30, 0x01	; 1
   16064:	f1 f7       	brne	.-4      	; 0x16062 <_key_scan+0x56>
		_delay_ms(1);
		keyhit = _KEY_MATRIX;
   16066:	90 b1       	in	r25, 0x00	; 0
		if (keyhit!=outmap[i]) 
   16068:	98 17       	cp	r25, r24
   1606a:	21 f4       	brne	.+8      	; 0x16074 <_key_scan+0x68>
   1606c:	11 96       	adiw	r26, 0x01	; 1

char _key_hit(void){
	unsigned char	i, keyhit=0x00;
	unsigned char	outmap[4] = {0xef, 0xdf, 0xbf, 0x7f};

	for(i=0; i<4; i++){
   1606e:	a4 17       	cp	r26, r20
   16070:	b5 07       	cpc	r27, r21
   16072:	81 f7       	brne	.-32     	; 0x16054 <_key_scan+0x48>
char _key_scan(char __select){
	char	__key = 0;

	if(__select==_PAD_SINGLE || __select==_PAD_MULTI){
		__key = _key_hit();
		__key = _key_crr(__key);
   16074:	89 2f       	mov	r24, r25
   16076:	0e 94 45 af 	call	0x15e8a	; 0x15e8a <_key_crr>
   1607a:	28 2f       	mov	r18, r24

		if(__key!=_KEY_NULL){
   1607c:	88 23       	and	r24, r24
   1607e:	09 f4       	brne	.+2      	; 0x16082 <_key_scan+0x76>
   16080:	85 c0       	rjmp	.+266    	; 0x1618c <_key_scan+0x180>
			_LIGHT_SET;
   16082:	91 e0       	ldi	r25, 0x01	; 1
   16084:	90 93 bf 03 	sts	0x03BF, r25
   16088:	10 92 c0 03 	sts	0x03C0, r1
   1608c:	80 91 65 00 	lds	r24, 0x0065
   16090:	8d 7f       	andi	r24, 0xFD	; 253
   16092:	80 93 65 00 	sts	0x0065, r24
			if(__sec_par)
   16096:	80 91 99 04 	lds	r24, 0x0499
   1609a:	88 23       	and	r24, r24
   1609c:	31 f0       	breq	.+12     	; 0x160aa <_key_scan+0x9e>
				_SEC_ON;
   1609e:	90 93 c7 03 	sts	0x03C7, r25
   160a2:	10 92 ff 03 	sts	0x03FF, r1
   160a6:	10 92 c8 03 	sts	0x03C8, r1

			if(_IS1st){
   160aa:	80 91 c1 03 	lds	r24, 0x03C1
   160ae:	88 23       	and	r24, r24
   160b0:	71 f4       	brne	.+28     	; 0x160ce <_key_scan+0xc2>
				if(	__key == _KEY_CANCEL || __key == _KEY_ENTER)
   160b2:	27 3e       	cpi	r18, 0xE7	; 231
   160b4:	11 f0       	breq	.+4      	; 0x160ba <_key_scan+0xae>
   160b6:	27 3b       	cpi	r18, 0xB7	; 183
   160b8:	31 f4       	brne	.+12     	; 0x160c6 <_key_scan+0xba>
					if(__lock_num)
   160ba:	80 91 be 03 	lds	r24, 0x03BE
   160be:	88 23       	and	r24, r24
   160c0:	11 f0       	breq	.+4      	; 0x160c6 <_key_scan+0xba>
						__lock_num = 0;
   160c2:	10 92 be 03 	sts	0x03BE, r1
				_PAD_2nd;
   160c6:	81 e0       	ldi	r24, 0x01	; 1
   160c8:	80 93 c1 03 	sts	0x03C1, r24
   160cc:	59 c0       	rjmp	.+178    	; 0x16180 <_key_scan+0x174>
				//_spi_tx(0x24, _SPI_SLAVE, "~");
				_delay_ms(5);
				return __key;
			}
			if(_IS2nd){
   160ce:	81 30       	cpi	r24, 0x01	; 1
   160d0:	09 f0       	breq	.+2      	; 0x160d4 <_key_scan+0xc8>
   160d2:	5c c0       	rjmp	.+184    	; 0x1618c <_key_scan+0x180>
				if(__select==_PAD_MULTI){
   160d4:	12 30       	cpi	r17, 0x02	; 2
   160d6:	21 f5       	brne	.+72     	; 0x16120 <_key_scan+0x114>
					if(	__key==_KEY_0 || __key==_KEY_1 || __key==_KEY_2 || __key==_KEY_3||
   160d8:	27 3d       	cpi	r18, 0xD7	; 215
   160da:	91 f0       	breq	.+36     	; 0x16100 <_key_scan+0xf4>
   160dc:	2e 3e       	cpi	r18, 0xEE	; 238
   160de:	81 f0       	breq	.+32     	; 0x16100 <_key_scan+0xf4>
   160e0:	2e 3d       	cpi	r18, 0xDE	; 222
   160e2:	71 f0       	breq	.+28     	; 0x16100 <_key_scan+0xf4>
   160e4:	2e 3b       	cpi	r18, 0xBE	; 190
   160e6:	61 f0       	breq	.+24     	; 0x16100 <_key_scan+0xf4>
   160e8:	2d 3e       	cpi	r18, 0xED	; 237
   160ea:	51 f0       	breq	.+20     	; 0x16100 <_key_scan+0xf4>
   160ec:	2d 3d       	cpi	r18, 0xDD	; 221
   160ee:	41 f0       	breq	.+16     	; 0x16100 <_key_scan+0xf4>
   160f0:	2d 3b       	cpi	r18, 0xBD	; 189
   160f2:	31 f0       	breq	.+12     	; 0x16100 <_key_scan+0xf4>
   160f4:	2b 3e       	cpi	r18, 0xEB	; 235
   160f6:	21 f0       	breq	.+8      	; 0x16100 <_key_scan+0xf4>
   160f8:	2b 3d       	cpi	r18, 0xDB	; 219
   160fa:	11 f0       	breq	.+4      	; 0x16100 <_key_scan+0xf4>
   160fc:	2b 3b       	cpi	r18, 0xBB	; 187
   160fe:	81 f4       	brne	.+32     	; 0x16120 <_key_scan+0x114>
						__key==_KEY_4 || __key==_KEY_5 || __key==_KEY_6 ||
						__key==_KEY_7 || __key==_KEY_8 || __key==_KEY_9){
						if(__lock_num){
   16100:	80 91 be 03 	lds	r24, 0x03BE
   16104:	88 23       	and	r24, r24
   16106:	49 f0       	breq	.+18     	; 0x1611a <_key_scan+0x10e>
							_SHIFT_SET;
   16108:	81 e0       	ldi	r24, 0x01	; 1
   1610a:	80 93 c2 03 	sts	0x03C2, r24
   1610e:	10 92 c3 03 	sts	0x03C3, r1
							CURSOR_HIDE;
   16112:	8c e0       	ldi	r24, 0x0C	; 12
   16114:	0e 94 b9 ad 	call	0x15b72	; 0x15b72 <lcd_command>
   16118:	03 c0       	rjmp	.+6      	; 0x16120 <_key_scan+0x114>
						}
						else
							__lock_num = 1;
   1611a:	81 e0       	ldi	r24, 0x01	; 1
   1611c:	80 93 be 03 	sts	0x03BE, r24
													 {'9', 'W', 'X', 'Y', 'Z', '\0'}}};
const unsigned char __maxchar[10] PROGMEM = {2, 4, 3, 3, 3, 3, 3, 4, 3, 4};

char _key_hit(void){
	unsigned char	i, keyhit=0x00;
	unsigned char	outmap[4] = {0xef, 0xdf, 0xbf, 0x7f};
   16120:	ff ee       	ldi	r31, 0xEF	; 239
   16122:	8f 2e       	mov	r8, r31
   16124:	ef ed       	ldi	r30, 0xDF	; 223
   16126:	9e 2e       	mov	r9, r30
   16128:	7f eb       	ldi	r23, 0xBF	; 191
   1612a:	a7 2e       	mov	r10, r23
   1612c:	6f e7       	ldi	r22, 0x7F	; 127
   1612e:	b6 2e       	mov	r11, r22
   16130:	6e 01       	movw	r12, r28
   16132:	08 94       	sec
   16134:	c1 1c       	adc	r12, r1
   16136:	d1 1c       	adc	r13, r1
   16138:	0a ef       	ldi	r16, 0xFA	; 250
   1613a:	10 e0       	ldi	r17, 0x00	; 0

	for(i=0; i<4; i++){
   1613c:	55 e0       	ldi	r21, 0x05	; 5
   1613e:	e5 2e       	mov	r14, r21
   16140:	f1 2c       	mov	r15, r1
   16142:	ec 0e       	add	r14, r28
   16144:	fd 1e       	adc	r15, r29
													 {'9', 'W', 'X', 'Y', 'Z', '\0'}}};
const unsigned char __maxchar[10] PROGMEM = {2, 4, 3, 3, 3, 3, 3, 4, 3, 4};

char _key_hit(void){
	unsigned char	i, keyhit=0x00;
	unsigned char	outmap[4] = {0xef, 0xdf, 0xbf, 0x7f};
   16146:	89 82       	std	Y+1, r8	; 0x01
   16148:	9a 82       	std	Y+2, r9	; 0x02
   1614a:	ab 82       	std	Y+3, r10	; 0x03
   1614c:	bc 82       	std	Y+4, r11	; 0x04
   1614e:	d6 01       	movw	r26, r12
   16150:	c8 01       	movw	r24, r16
   16152:	01 97       	sbiw	r24, 0x01	; 1
   16154:	f1 f7       	brne	.-4      	; 0x16152 <_key_scan+0x146>

	for(i=0; i<4; i++){
		_delay_ms(1);
		_KEY_PORT = outmap[i];
   16156:	8c 91       	ld	r24, X
   16158:	80 93 62 00 	sts	0x0062, r24
   1615c:	f8 01       	movw	r30, r16
   1615e:	31 97       	sbiw	r30, 0x01	; 1
   16160:	f1 f7       	brne	.-4      	; 0x1615e <_key_scan+0x152>
		_delay_ms(1);
		keyhit = _KEY_MATRIX;
   16162:	90 b1       	in	r25, 0x00	; 0
		if (keyhit!=outmap[i]) 
   16164:	98 17       	cp	r25, r24
   16166:	21 f4       	brne	.+8      	; 0x16170 <_key_scan+0x164>
   16168:	11 96       	adiw	r26, 0x01	; 1

char _key_hit(void){
	unsigned char	i, keyhit=0x00;
	unsigned char	outmap[4] = {0xef, 0xdf, 0xbf, 0x7f};

	for(i=0; i<4; i++){
   1616a:	ae 15       	cp	r26, r14
   1616c:	bf 05       	cpc	r27, r15
   1616e:	81 f7       	brne	.-32     	; 0x16150 <_key_scan+0x144>
							__lock_num = 1;
					}
				}
				do{
					__key = _key_hit();
					__key = _key_crr(__key);
   16170:	89 2f       	mov	r24, r25
   16172:	0e 94 45 af 	call	0x15e8a	; 0x15e8a <_key_crr>
   16176:	28 2f       	mov	r18, r24
				}while(__key!=_KEY_NULL);
   16178:	88 23       	and	r24, r24
   1617a:	29 f7       	brne	.-54     	; 0x16146 <_key_scan+0x13a>
				_PAD_1st;
   1617c:	10 92 c1 03 	sts	0x03C1, r1
   16180:	82 ee       	ldi	r24, 0xE2	; 226
   16182:	94 e0       	ldi	r25, 0x04	; 4
   16184:	01 97       	sbiw	r24, 0x01	; 1
   16186:	f1 f7       	brne	.-4      	; 0x16184 <_key_scan+0x178>
   16188:	03 c0       	rjmp	.+6      	; 0x16190 <_key_scan+0x184>
				_delay_ms(5);
				return _KEY_NULL;
   1618a:	20 e0       	ldi	r18, 0x00	; 0
			}
		}
	}
	_PAD_1st;
   1618c:	10 92 c1 03 	sts	0x03C1, r1
	return __key;
}
   16190:	82 2f       	mov	r24, r18
   16192:	0f 90       	pop	r0
   16194:	0f 90       	pop	r0
   16196:	0f 90       	pop	r0
   16198:	0f 90       	pop	r0
   1619a:	cf 91       	pop	r28
   1619c:	df 91       	pop	r29
   1619e:	1f 91       	pop	r17
   161a0:	0f 91       	pop	r16
   161a2:	ff 90       	pop	r15
   161a4:	ef 90       	pop	r14
   161a6:	df 90       	pop	r13
   161a8:	cf 90       	pop	r12
   161aa:	bf 90       	pop	r11
   161ac:	af 90       	pop	r10
   161ae:	9f 90       	pop	r9
   161b0:	8f 90       	pop	r8
   161b2:	08 95       	ret

000161b4 <_spi_init>:
unsigned char	__spi_i;
unsigned char	__spi_isstart = 0;
unsigned char	__spi_ismessage = 0;

void _spi_init(unsigned char __mode, unsigned char __interrupt){
	if(__mode){
   161b4:	88 23       	and	r24, r24
   161b6:	41 f0       	breq	.+16     	; 0x161c8 <_spi_init+0x14>
		_SPI_DDR = (1 << _SPI_MOSI) | (1 << _SPI_SCK);
   161b8:	86 e0       	ldi	r24, 0x06	; 6
   161ba:	87 bb       	out	0x17, r24	; 23
		if(__interrupt)
   161bc:	66 23       	and	r22, r22
   161be:	11 f0       	breq	.+4      	; 0x161c4 <_spi_init+0x10>
			SPCR = (1 << SPIE) | (1 << SPE) | (1 << MSTR) | (1 << SPR1);
   161c0:	82 ed       	ldi	r24, 0xD2	; 210
   161c2:	09 c0       	rjmp	.+18     	; 0x161d6 <_spi_init+0x22>
		else
			SPCR = (1 << SPE) | (1 << MSTR) | (1 << SPR1);
   161c4:	82 e5       	ldi	r24, 0x52	; 82
   161c6:	07 c0       	rjmp	.+14     	; 0x161d6 <_spi_init+0x22>
	}
	else{
		_SPI_DDR = (1 << _SPI_MISO);
   161c8:	88 e0       	ldi	r24, 0x08	; 8
   161ca:	87 bb       	out	0x17, r24	; 23
		if(__interrupt)
   161cc:	66 23       	and	r22, r22
   161ce:	11 f0       	breq	.+4      	; 0x161d4 <_spi_init+0x20>
			SPCR = (1 << SPIE) | (1 << SPE);
   161d0:	80 ec       	ldi	r24, 0xC0	; 192
   161d2:	01 c0       	rjmp	.+2      	; 0x161d6 <_spi_init+0x22>
		else
			SPCR = (1 << SPE);
   161d4:	80 e4       	ldi	r24, 0x40	; 64
   161d6:	8d b9       	out	0x0d, r24	; 13
   161d8:	08 95       	ret

000161da <_spi_enable>:
	}
}

void _spi_enable(unsigned char __select){
	if(__select == 0){
   161da:	88 23       	and	r24, r24
   161dc:	19 f4       	brne	.+6      	; 0x161e4 <_spi_enable+0xa>
		sbi(_SLAVE_PORT, _SLAVE_PIN);
   161de:	db 9a       	sbi	0x1b, 3	; 27
		sbi(_MMC_PORT, _MMC_PIN);
   161e0:	1b 9a       	sbi	0x03, 3	; 3
   161e2:	08 95       	ret
	}
	if(__select == 1){
   161e4:	81 30       	cpi	r24, 0x01	; 1
   161e6:	39 f4       	brne	.+14     	; 0x161f6 <_spi_enable+0x1c>
		sbi(_MMC_PORT, _MMC_PIN);
   161e8:	1b 9a       	sbi	0x03, 3	; 3
   161ea:	82 ee       	ldi	r24, 0xE2	; 226
   161ec:	94 e0       	ldi	r25, 0x04	; 4
   161ee:	01 97       	sbiw	r24, 0x01	; 1
   161f0:	f1 f7       	brne	.-4      	; 0x161ee <_spi_enable+0x14>
		_delay_ms(5);
		cbi(_SLAVE_PORT, _SLAVE_PIN);
   161f2:	db 98       	cbi	0x1b, 3	; 27
   161f4:	08 95       	ret
	}
	if(__select == 2){
   161f6:	82 30       	cpi	r24, 0x02	; 2
   161f8:	31 f4       	brne	.+12     	; 0x16206 <_spi_enable+0x2c>
		sbi(_SLAVE_PORT, _SLAVE_PIN);
   161fa:	db 9a       	sbi	0x1b, 3	; 27
   161fc:	82 ee       	ldi	r24, 0xE2	; 226
   161fe:	94 e0       	ldi	r25, 0x04	; 4
   16200:	01 97       	sbiw	r24, 0x01	; 1
   16202:	f1 f7       	brne	.-4      	; 0x16200 <_spi_enable+0x26>
		_delay_ms(5);
		cbi(_MMC_PORT, _MMC_PIN);
   16204:	1b 98       	cbi	0x03, 3	; 3
   16206:	08 95       	ret

00016208 <_spi>:
	}
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
   16208:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1 << SPIF)));
   1620a:	77 9b       	sbis	0x0e, 7	; 14
   1620c:	fe cf       	rjmp	.-4      	; 0x1620a <_spi+0x2>
	return SPDR;
   1620e:	8f b1       	in	r24, 0x0f	; 15
}
   16210:	08 95       	ret

00016212 <_spi_rx>:


unsigned char _spi_rx(unsigned char __select){
	unsigned char __i = 0;

	_spi_enable(__select);
   16212:	0e 94 ed b0 	call	0x161da	; 0x161da <_spi_enable>
		cbi(_MMC_PORT, _MMC_PIN);
	}
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
   16216:	81 e4       	ldi	r24, 0x41	; 65
   16218:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1 << SPIF)));
   1621a:	77 9b       	sbis	0x0e, 7	; 14
   1621c:	fe cf       	rjmp	.-4      	; 0x1621a <_spi_rx+0x8>
	return SPDR;
   1621e:	8f b1       	in	r24, 0x0f	; 15
unsigned char _spi_rx(unsigned char __select){
	unsigned char __i = 0;

	_spi_enable(__select);

		__spi_char = _spi(0x41);
   16220:	80 93 8e 0e 	sts	0x0E8E, r24
		if(__spi_char==0xff) return 0;
   16224:	8f 3f       	cpi	r24, 0xFF	; 255
   16226:	11 f4       	brne	.+4      	; 0x1622c <_spi_rx+0x1a>
   16228:	80 e0       	ldi	r24, 0x00	; 0
   1622a:	08 95       	ret
		if(__spi_char==0x55) return 1;
   1622c:	85 35       	cpi	r24, 0x55	; 85
   1622e:	11 f4       	brne	.+4      	; 0x16234 <_spi_rx+0x22>
   16230:	81 e0       	ldi	r24, 0x01	; 1
   16232:	08 95       	ret
		if(__spi_char==0x02) return 2;
   16234:	82 30       	cpi	r24, 0x02	; 2
   16236:	21 f0       	breq	.+8      	; 0x16240 <_spi_rx+0x2e>
	_spi_enable(_SPI_NONE);
   16238:	80 e0       	ldi	r24, 0x00	; 0
   1623a:	0e 94 ed b0 	call	0x161da	; 0x161da <_spi_enable>
   1623e:	85 e1       	ldi	r24, 0x15	; 21
	return 21;
}
   16240:	08 95       	ret

00016242 <_spi_tx>:

unsigned char _spi_tx(unsigned char __command, unsigned char __select, char* __message){
   16242:	1f 93       	push	r17
   16244:	cf 93       	push	r28
   16246:	df 93       	push	r29
   16248:	18 2f       	mov	r17, r24
   1624a:	86 2f       	mov	r24, r22
   1624c:	ea 01       	movw	r28, r20
	_spi_enable(__select);
   1624e:	0e 94 ed b0 	call	0x161da	; 0x161da <_spi_enable>
		cbi(_MMC_PORT, _MMC_PIN);
	}
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
   16252:	8b e7       	ldi	r24, 0x7B	; 123
   16254:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1 << SPIF)));
   16256:	77 9b       	sbis	0x0e, 7	; 14
   16258:	fe cf       	rjmp	.-4      	; 0x16256 <_spi_tx+0x14>
	return SPDR;
   1625a:	8f b1       	in	r24, 0x0f	; 15
		cbi(_MMC_PORT, _MMC_PIN);
	}
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
   1625c:	1f b9       	out	0x0f, r17	; 15
	while(!(SPSR & (1 << SPIF)));
   1625e:	77 9b       	sbis	0x0e, 7	; 14
   16260:	fe cf       	rjmp	.-4      	; 0x1625e <_spi_tx+0x1c>
	return SPDR;
   16262:	8f b1       	in	r24, 0x0f	; 15
unsigned char _spi_tx(unsigned char __command, unsigned char __select, char* __message){
	_spi_enable(__select);
	_spi(0x7B);
	_spi(__command);

	if(strlen(__message) > 0){
   16264:	88 81       	ld	r24, Y
   16266:	88 23       	and	r24, r24
   16268:	91 f0       	breq	.+36     	; 0x1628e <_spi_tx+0x4c>
		cbi(_MMC_PORT, _MMC_PIN);
	}
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
   1626a:	88 e2       	ldi	r24, 0x28	; 40
   1626c:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1 << SPIF)));
   1626e:	77 9b       	sbis	0x0e, 7	; 14
   16270:	fe cf       	rjmp	.-4      	; 0x1626e <_spi_tx+0x2c>
   16272:	04 c0       	rjmp	.+8      	; 0x1627c <_spi_tx+0x3a>
		cbi(_MMC_PORT, _MMC_PIN);
	}
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
   16274:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1 << SPIF)));
   16276:	77 9b       	sbis	0x0e, 7	; 14
   16278:	fe cf       	rjmp	.-4      	; 0x16276 <_spi_tx+0x34>
	_spi(__command);

	if(strlen(__message) > 0){
		_spi(0x28);
		while(*__message)
			_spi(*__message++);
   1627a:	21 96       	adiw	r28, 0x01	; 1
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
	while(!(SPSR & (1 << SPIF)));
	return SPDR;
   1627c:	8f b1       	in	r24, 0x0f	; 15
	_spi(0x7B);
	_spi(__command);

	if(strlen(__message) > 0){
		_spi(0x28);
		while(*__message)
   1627e:	88 81       	ld	r24, Y
   16280:	88 23       	and	r24, r24
   16282:	c1 f7       	brne	.-16     	; 0x16274 <_spi_tx+0x32>
		cbi(_MMC_PORT, _MMC_PIN);
	}
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
   16284:	89 e2       	ldi	r24, 0x29	; 41
   16286:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1 << SPIF)));
   16288:	77 9b       	sbis	0x0e, 7	; 14
   1628a:	fe cf       	rjmp	.-4      	; 0x16288 <_spi_tx+0x46>
	return SPDR;
   1628c:	8f b1       	in	r24, 0x0f	; 15
		cbi(_MMC_PORT, _MMC_PIN);
	}
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
   1628e:	8d e7       	ldi	r24, 0x7D	; 125
   16290:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1 << SPIF)));
   16292:	77 9b       	sbis	0x0e, 7	; 14
   16294:	fe cf       	rjmp	.-4      	; 0x16292 <_spi_tx+0x50>
	return SPDR;
   16296:	8f b1       	in	r24, 0x0f	; 15
			_spi(*__message++);
		_spi(0x29);
	}

	_spi(0x7D);
	_spi_enable(_SPI_NONE);
   16298:	80 e0       	ldi	r24, 0x00	; 0
   1629a:	0e 94 ed b0 	call	0x161da	; 0x161da <_spi_enable>
	return 0;
}
   1629e:	80 e0       	ldi	r24, 0x00	; 0
   162a0:	df 91       	pop	r29
   162a2:	cf 91       	pop	r28
   162a4:	1f 91       	pop	r17
   162a6:	08 95       	ret

000162a8 <_spi_txnum>:

unsigned char _spi_txnum(unsigned char __command, unsigned char __select, char* __message, unsigned char __num){
   162a8:	ff 92       	push	r15
   162aa:	0f 93       	push	r16
   162ac:	1f 93       	push	r17
   162ae:	86 2f       	mov	r24, r22
   162b0:	14 2f       	mov	r17, r20
   162b2:	05 2f       	mov	r16, r21
   162b4:	f2 2e       	mov	r15, r18
	unsigned char	__i;

	_spi_enable(__select);
   162b6:	0e 94 ed b0 	call	0x161da	; 0x161da <_spi_enable>
		cbi(_MMC_PORT, _MMC_PIN);
	}
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
   162ba:	82 e0       	ldi	r24, 0x02	; 2
   162bc:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1 << SPIF)));
   162be:	77 9b       	sbis	0x0e, 7	; 14
   162c0:	fe cf       	rjmp	.-4      	; 0x162be <_spi_txnum+0x16>
	return SPDR;
   162c2:	8f b1       	in	r24, 0x0f	; 15
	unsigned char	__i;

	_spi_enable(__select);
	_spi(0x02);

	if(__num > 0){
   162c4:	ff 20       	and	r15, r15
   162c6:	79 f0       	breq	.+30     	; 0x162e6 <_spi_txnum+0x3e>
   162c8:	81 2f       	mov	r24, r17
   162ca:	90 2f       	mov	r25, r16
   162cc:	9c 01       	movw	r18, r24
   162ce:	f9 01       	movw	r30, r18
   162d0:	90 e0       	ldi	r25, 0x00	; 0
   162d2:	07 c0       	rjmp	.+14     	; 0x162e2 <_spi_txnum+0x3a>
		for(__i = 0; __i < __num; __i++) _spi(__message[__i]);
   162d4:	80 81       	ld	r24, Z
		cbi(_MMC_PORT, _MMC_PIN);
	}
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
   162d6:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1 << SPIF)));
   162d8:	77 9b       	sbis	0x0e, 7	; 14
   162da:	fe cf       	rjmp	.-4      	; 0x162d8 <_spi_txnum+0x30>
	return SPDR;
   162dc:	8f b1       	in	r24, 0x0f	; 15

	_spi_enable(__select);
	_spi(0x02);

	if(__num > 0){
		for(__i = 0; __i < __num; __i++) _spi(__message[__i]);
   162de:	9f 5f       	subi	r25, 0xFF	; 255
   162e0:	31 96       	adiw	r30, 0x01	; 1
   162e2:	9f 15       	cp	r25, r15
   162e4:	b8 f3       	brcs	.-18     	; 0x162d4 <_spi_txnum+0x2c>
		cbi(_MMC_PORT, _MMC_PIN);
	}
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
   162e6:	83 e0       	ldi	r24, 0x03	; 3
   162e8:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1 << SPIF)));
   162ea:	77 9b       	sbis	0x0e, 7	; 14
   162ec:	fe cf       	rjmp	.-4      	; 0x162ea <_spi_txnum+0x42>
	return SPDR;
   162ee:	8f b1       	in	r24, 0x0f	; 15
	if(__num > 0){
		for(__i = 0; __i < __num; __i++) _spi(__message[__i]);
				}// for

	_spi(0x03);
	_spi_enable(_SPI_NONE);
   162f0:	80 e0       	ldi	r24, 0x00	; 0
   162f2:	0e 94 ed b0 	call	0x161da	; 0x161da <_spi_enable>
	return 0;
}
   162f6:	80 e0       	ldi	r24, 0x00	; 0
   162f8:	1f 91       	pop	r17
   162fa:	0f 91       	pop	r16
   162fc:	ff 90       	pop	r15
   162fe:	08 95       	ret

00016300 <_spi_interrupt>:

unsigned char _spi_interrupt(void){
	__spi_char = SPDR;
   16300:	9f b1       	in	r25, 0x0f	; 15
   16302:	90 93 8e 0e 	sts	0x0E8E, r25

	if(__spi_char == 0xFF){
   16306:	9f 3f       	cpi	r25, 0xFF	; 255
   16308:	e9 f4       	brne	.+58     	; 0x16344 <_spi_interrupt+0x44>
		if(__spi_istransmit){
   1630a:	80 91 fb 03 	lds	r24, 0x03FB
   1630e:	88 23       	and	r24, r24
   16310:	b9 f0       	breq	.+46     	; 0x16340 <_spi_interrupt+0x40>
			SPDR = __command[__spi_i];
   16312:	90 91 8d 0e 	lds	r25, 0x0E8D
   16316:	e9 2f       	mov	r30, r25
   16318:	f0 e0       	ldi	r31, 0x00	; 0
   1631a:	e7 53       	subi	r30, 0x37	; 55
   1631c:	fc 4f       	sbci	r31, 0xFC	; 252
   1631e:	80 81       	ld	r24, Z
   16320:	8f b9       	out	0x0f, r24	; 15
			if(__command[__spi_i] == 0x7D){
   16322:	8d 37       	cpi	r24, 0x7D	; 125
   16324:	19 f4       	brne	.+6      	; 0x1632c <_spi_interrupt+0x2c>
				__spi_i = 0;
   16326:	10 92 8d 0e 	sts	0x0E8D, r1
   1632a:	07 c0       	rjmp	.+14     	; 0x1633a <_spi_interrupt+0x3a>
				__spi_istransmit = 0;
			}
			else{
				__spi_i++;
   1632c:	89 2f       	mov	r24, r25
   1632e:	8f 5f       	subi	r24, 0xFF	; 255
   16330:	80 93 8d 0e 	sts	0x0E8D, r24
				if(__spi_i == _MAX_COMMAND)
   16334:	82 33       	cpi	r24, 0x32	; 50
   16336:	09 f0       	breq	.+2      	; 0x1633a <_spi_interrupt+0x3a>
   16338:	3f c0       	rjmp	.+126    	; 0x163b8 <_spi_interrupt+0xb8>
					__spi_istransmit = 0;
   1633a:	10 92 fb 03 	sts	0x03FB, r1
   1633e:	3c c0       	rjmp	.+120    	; 0x163b8 <_spi_interrupt+0xb8>
			}
		}
		else
			SPDR = 0xFF;
   16340:	9f b9       	out	0x0f, r25	; 15
   16342:	3a c0       	rjmp	.+116    	; 0x163b8 <_spi_interrupt+0xb8>
	}
	else{
		if(__spi_char == 0x7D && __spi_isstart){
   16344:	9d 37       	cpi	r25, 0x7D	; 125
   16346:	69 f4       	brne	.+26     	; 0x16362 <_spi_interrupt+0x62>
   16348:	80 91 c4 03 	lds	r24, 0x03C4
   1634c:	88 23       	and	r24, r24
   1634e:	49 f0       	breq	.+18     	; 0x16362 <_spi_interrupt+0x62>
			__spi_isstart = 0;
   16350:	10 92 c4 03 	sts	0x03C4, r1
			__spi_ismessage = 0;
   16354:	10 92 c5 03 	sts	0x03C5, r1
			__spi_i = 0;
   16358:	10 92 8d 0e 	sts	0x0E8D, r1
			__command_flag = 1;
   1635c:	81 e0       	ldi	r24, 0x01	; 1
   1635e:	80 93 fe 03 	sts	0x03FE, r24
		}
		if(__spi_isstart && __spi_ismessage){
   16362:	20 91 c4 03 	lds	r18, 0x03C4
   16366:	22 23       	and	r18, r18
   16368:	f1 f0       	breq	.+60     	; 0x163a6 <_spi_interrupt+0xa6>
   1636a:	80 91 c5 03 	lds	r24, 0x03C5
   1636e:	88 23       	and	r24, r24
   16370:	29 f1       	breq	.+74     	; 0x163bc <_spi_interrupt+0xbc>
			if(__spi_char != 0x29){
   16372:	99 32       	cpi	r25, 0x29	; 41
   16374:	c1 f0       	breq	.+48     	; 0x163a6 <_spi_interrupt+0xa6>
				__package[__spi_i] = __spi_char;
   16376:	80 91 8d 0e 	lds	r24, 0x0E8D
   1637a:	e8 2f       	mov	r30, r24
   1637c:	f0 e0       	ldi	r31, 0x00	; 0
   1637e:	ed 5f       	subi	r30, 0xFD	; 253
   16380:	fb 4f       	sbci	r31, 0xFB	; 251
   16382:	90 83       	st	Z, r25
				__package[__spi_i + 1] = '\0';
   16384:	11 82       	std	Z+1, r1	; 0x01
				__spi_i++;
   16386:	8f 5f       	subi	r24, 0xFF	; 255
   16388:	80 93 8d 0e 	sts	0x0E8D, r24
				if(__spi_i == _MAX_PACKAGE)
   1638c:	82 38       	cpi	r24, 0x82	; 130
   1638e:	59 f4       	brne	.+22     	; 0x163a6 <_spi_interrupt+0xa6>
					__spi_i = 0;
   16390:	10 92 8d 0e 	sts	0x0E8D, r1
   16394:	08 c0       	rjmp	.+16     	; 0x163a6 <_spi_interrupt+0xa6>
			}
		}
		if(__spi_isstart && !__spi_ismessage){
			if(__spi_char == 0x28){
				__spi_ismessage = 1;
   16396:	81 e0       	ldi	r24, 0x01	; 1
   16398:	80 93 c5 03 	sts	0x03C5, r24
				__spi_i = 0;
   1639c:	10 92 8d 0e 	sts	0x0E8D, r1
   163a0:	0b c0       	rjmp	.+22     	; 0x163b8 <_spi_interrupt+0xb8>
			}
			else
				__command_set = __spi_char;
   163a2:	90 93 00 04 	sts	0x0400, r25
		}
		if(__spi_char == 0x7B && !__spi_isstart){
   163a6:	9b 37       	cpi	r25, 0x7B	; 123
   163a8:	39 f4       	brne	.+14     	; 0x163b8 <_spi_interrupt+0xb8>
   163aa:	22 23       	and	r18, r18
   163ac:	29 f4       	brne	.+10     	; 0x163b8 <_spi_interrupt+0xb8>
			__spi_isstart = 1;
   163ae:	81 e0       	ldi	r24, 0x01	; 1
   163b0:	80 93 c4 03 	sts	0x03C4, r24
			__spi_ismessage = 0;
   163b4:	10 92 c5 03 	sts	0x03C5, r1
		}
	}

	return 0;
}
   163b8:	80 e0       	ldi	r24, 0x00	; 0
   163ba:	08 95       	ret
				if(__spi_i == _MAX_PACKAGE)
					__spi_i = 0;
			}
		}
		if(__spi_isstart && !__spi_ismessage){
			if(__spi_char == 0x28){
   163bc:	98 32       	cpi	r25, 0x28	; 40
   163be:	89 f7       	brne	.-30     	; 0x163a2 <_spi_interrupt+0xa2>
   163c0:	ea cf       	rjmp	.-44     	; 0x16396 <_spi_interrupt+0x96>

000163c2 <_spi_command>:
	}

	return 0;
}

void _spi_command(unsigned char __cmd, char* __cell){
   163c2:	fb 01       	movw	r30, r22
	unsigned char __i = 0;

	__command[__i++] = 0x7B;
   163c4:	9b e7       	ldi	r25, 0x7B	; 123
   163c6:	90 93 c9 03 	sts	0x03C9, r25
	__command[__i++] = __cmd;
   163ca:	80 93 ca 03 	sts	0x03CA, r24

	if(strlen(__cell) > 0){
   163ce:	80 81       	ld	r24, Z
   163d0:	88 23       	and	r24, r24
   163d2:	11 f4       	brne	.+4      	; 0x163d8 <_spi_command+0x16>
   163d4:	92 e0       	ldi	r25, 0x02	; 2
   163d6:	16 c0       	rjmp	.+44     	; 0x16404 <_spi_command+0x42>
		__command[__i++] = 0x28;
   163d8:	88 e2       	ldi	r24, 0x28	; 40
   163da:	80 93 cb 03 	sts	0x03CB, r24
   163de:	83 e0       	ldi	r24, 0x03	; 3
   163e0:	05 c0       	rjmp	.+10     	; 0x163ec <_spi_command+0x2a>

		while(*__cell)
			__command[__i++] = *__cell++;
   163e2:	a7 53       	subi	r26, 0x37	; 55
   163e4:	bc 4f       	sbci	r27, 0xFC	; 252
   163e6:	9c 93       	st	X, r25
   163e8:	82 2f       	mov	r24, r18
   163ea:	31 96       	adiw	r30, 0x01	; 1
	__command[__i++] = __cmd;

	if(strlen(__cell) > 0){
		__command[__i++] = 0x28;

		while(*__cell)
   163ec:	90 81       	ld	r25, Z
   163ee:	a8 2f       	mov	r26, r24
   163f0:	b0 e0       	ldi	r27, 0x00	; 0
   163f2:	28 2f       	mov	r18, r24
   163f4:	2f 5f       	subi	r18, 0xFF	; 255
   163f6:	99 23       	and	r25, r25
   163f8:	a1 f7       	brne	.-24     	; 0x163e2 <_spi_command+0x20>
			__command[__i++] = *__cell++;

		__command[__i++] = 0x29;
   163fa:	a7 53       	subi	r26, 0x37	; 55
   163fc:	bc 4f       	sbci	r27, 0xFC	; 252
   163fe:	89 e2       	ldi	r24, 0x29	; 41
   16400:	8c 93       	st	X, r24
   16402:	92 2f       	mov	r25, r18
	}

	__command[__i++] = 0x7D;
   16404:	e9 2f       	mov	r30, r25
   16406:	f0 e0       	ldi	r31, 0x00	; 0
   16408:	e7 53       	subi	r30, 0x37	; 55
   1640a:	fc 4f       	sbci	r31, 0xFC	; 252
   1640c:	8d e7       	ldi	r24, 0x7D	; 125
   1640e:	80 83       	st	Z, r24
	__command[__i++] = '\0';
   16410:	9f 5f       	subi	r25, 0xFF	; 255
   16412:	e9 2f       	mov	r30, r25
   16414:	f0 e0       	ldi	r31, 0x00	; 0
   16416:	e7 53       	subi	r30, 0x37	; 55
   16418:	fc 4f       	sbci	r31, 0xFC	; 252
   1641a:	10 82       	st	Z, r1
}
   1641c:	08 95       	ret

0001641e <_rtc>:

#include <compat/twi.h>

#include "RTC.h"

unsigned char _rtc(int __addr, int __len, char* __datetime, unsigned char __dir){
   1641e:	98 2f       	mov	r25, r24
	int				__twcr;
	unsigned char	__i = 0;
	
	if(__dir){
   16420:	22 23       	and	r18, r18
   16422:	09 f4       	brne	.+2      	; 0x16426 <_rtc+0x8>
   16424:	49 c0       	rjmp	.+146    	; 0x164b8 <_rtc+0x9a>
		TWCR = _BV(TWINT) | _BV(TWSTA) | _BV(TWEN);
   16426:	84 ea       	ldi	r24, 0xA4	; 164
   16428:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   1642c:	80 91 74 00 	lds	r24, 0x0074
   16430:	87 ff       	sbrs	r24, 7
   16432:	fc cf       	rjmp	.-8      	; 0x1642c <_rtc+0xe>
		if(TW_STATUS != TW_START)
   16434:	80 91 71 00 	lds	r24, 0x0071
   16438:	88 7f       	andi	r24, 0xF8	; 248
   1643a:	88 30       	cpi	r24, 0x08	; 8
   1643c:	09 f0       	breq	.+2      	; 0x16440 <_rtc+0x22>
   1643e:	af c0       	rjmp	.+350    	; 0x1659e <_rtc+0x180>
			return 1;

		TWDR = _DS1307W;
   16440:	80 ed       	ldi	r24, 0xD0	; 208
   16442:	80 93 73 00 	sts	0x0073, r24
		TWCR = _BV(TWINT) | _BV(TWEN);
   16446:	84 e8       	ldi	r24, 0x84	; 132
   16448:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   1644c:	80 91 74 00 	lds	r24, 0x0074
   16450:	87 ff       	sbrs	r24, 7
   16452:	fc cf       	rjmp	.-8      	; 0x1644c <_rtc+0x2e>
		if(TW_STATUS != TW_MT_SLA_ACK)
   16454:	80 91 71 00 	lds	r24, 0x0071
   16458:	88 7f       	andi	r24, 0xF8	; 248
   1645a:	88 31       	cpi	r24, 0x18	; 24
   1645c:	09 f0       	breq	.+2      	; 0x16460 <_rtc+0x42>
   1645e:	9f c0       	rjmp	.+318    	; 0x1659e <_rtc+0x180>
			return 1;

		TWDR = __addr;
   16460:	90 93 73 00 	sts	0x0073, r25
		TWCR = _BV(TWINT) | _BV(TWEN);
   16464:	84 e8       	ldi	r24, 0x84	; 132
   16466:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   1646a:	80 91 74 00 	lds	r24, 0x0074
   1646e:	87 ff       	sbrs	r24, 7
   16470:	fc cf       	rjmp	.-8      	; 0x1646a <_rtc+0x4c>
		if(TW_STATUS != TW_MT_DATA_ACK)
   16472:	80 91 71 00 	lds	r24, 0x0071
   16476:	88 7f       	andi	r24, 0xF8	; 248
   16478:	88 32       	cpi	r24, 0x28	; 40
   1647a:	09 f0       	breq	.+2      	; 0x1647e <_rtc+0x60>
   1647c:	90 c0       	rjmp	.+288    	; 0x1659e <_rtc+0x180>
   1647e:	9b 01       	movw	r18, r22
			return 1;

		for(; __len > 0; __len--){
			TWDR = __datetime[__i++];
			TWCR = _BV(TWINT) | _BV(TWEN);
   16480:	94 e8       	ldi	r25, 0x84	; 132
   16482:	14 c0       	rjmp	.+40     	; 0x164ac <_rtc+0x8e>
		_rtc_response;
		if(TW_STATUS != TW_MT_DATA_ACK)
			return 1;

		for(; __len > 0; __len--){
			TWDR = __datetime[__i++];
   16484:	fa 01       	movw	r30, r20
   16486:	e8 0f       	add	r30, r24
   16488:	f1 1d       	adc	r31, r1
   1648a:	80 81       	ld	r24, Z
   1648c:	80 93 73 00 	sts	0x0073, r24
			TWCR = _BV(TWINT) | _BV(TWEN);
   16490:	90 93 74 00 	sts	0x0074, r25
			_rtc_response;
   16494:	80 91 74 00 	lds	r24, 0x0074
   16498:	87 ff       	sbrs	r24, 7
   1649a:	fc cf       	rjmp	.-8      	; 0x16494 <_rtc+0x76>
			if(TW_STATUS == TW_MT_DATA_NACK)
   1649c:	80 91 71 00 	lds	r24, 0x0071
   164a0:	88 7f       	andi	r24, 0xF8	; 248
   164a2:	80 33       	cpi	r24, 0x30	; 48
   164a4:	09 f4       	brne	.+2      	; 0x164a8 <_rtc+0x8a>
   164a6:	7b c0       	rjmp	.+246    	; 0x1659e <_rtc+0x180>
		TWCR = _BV(TWINT) | _BV(TWEN);
		_rtc_response;
		if(TW_STATUS != TW_MT_DATA_ACK)
			return 1;

		for(; __len > 0; __len--){
   164a8:	21 50       	subi	r18, 0x01	; 1
   164aa:	30 40       	sbci	r19, 0x00	; 0
   164ac:	86 2f       	mov	r24, r22
   164ae:	82 1b       	sub	r24, r18
   164b0:	12 16       	cp	r1, r18
   164b2:	13 06       	cpc	r1, r19
   164b4:	3c f3       	brlt	.-50     	; 0x16484 <_rtc+0x66>
   164b6:	6e c0       	rjmp	.+220    	; 0x16594 <_rtc+0x176>
		}

		TWCR = _BV(TWINT) | _BV(TWSTO) | _BV(TWEN);
	}
	else{
		TWCR =_BV(TWINT) | _BV(TWSTA) | _BV(TWEN);
   164b8:	84 ea       	ldi	r24, 0xA4	; 164
   164ba:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   164be:	80 91 74 00 	lds	r24, 0x0074
   164c2:	87 ff       	sbrs	r24, 7
   164c4:	fc cf       	rjmp	.-8      	; 0x164be <_rtc+0xa0>
		if(TW_STATUS != TW_START)
   164c6:	80 91 71 00 	lds	r24, 0x0071
   164ca:	88 7f       	andi	r24, 0xF8	; 248
   164cc:	88 30       	cpi	r24, 0x08	; 8
   164ce:	09 f0       	breq	.+2      	; 0x164d2 <_rtc+0xb4>
   164d0:	66 c0       	rjmp	.+204    	; 0x1659e <_rtc+0x180>
			return 1;

		TWDR = _DS1307W;
   164d2:	80 ed       	ldi	r24, 0xD0	; 208
   164d4:	80 93 73 00 	sts	0x0073, r24
		TWCR = _BV(TWINT) | _BV(TWEN);
   164d8:	84 e8       	ldi	r24, 0x84	; 132
   164da:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   164de:	80 91 74 00 	lds	r24, 0x0074
   164e2:	87 ff       	sbrs	r24, 7
   164e4:	fc cf       	rjmp	.-8      	; 0x164de <_rtc+0xc0>
		if(TW_STATUS != TW_MT_SLA_ACK)
   164e6:	80 91 71 00 	lds	r24, 0x0071
   164ea:	88 7f       	andi	r24, 0xF8	; 248
   164ec:	88 31       	cpi	r24, 0x18	; 24
   164ee:	09 f0       	breq	.+2      	; 0x164f2 <_rtc+0xd4>
   164f0:	56 c0       	rjmp	.+172    	; 0x1659e <_rtc+0x180>
			return 1;

		TWDR = __addr;
   164f2:	90 93 73 00 	sts	0x0073, r25
		TWCR = _BV(TWINT) | _BV(TWEN);
   164f6:	84 e8       	ldi	r24, 0x84	; 132
   164f8:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   164fc:	80 91 74 00 	lds	r24, 0x0074
   16500:	87 ff       	sbrs	r24, 7
   16502:	fc cf       	rjmp	.-8      	; 0x164fc <_rtc+0xde>
		if(TW_STATUS != TW_MT_DATA_ACK)
   16504:	80 91 71 00 	lds	r24, 0x0071
   16508:	88 7f       	andi	r24, 0xF8	; 248
   1650a:	88 32       	cpi	r24, 0x28	; 40
   1650c:	09 f0       	breq	.+2      	; 0x16510 <_rtc+0xf2>
   1650e:	47 c0       	rjmp	.+142    	; 0x1659e <_rtc+0x180>
			return 1;

		TWCR =_BV(TWINT) | _BV(TWSTA) | _BV(TWEN);
   16510:	84 ea       	ldi	r24, 0xA4	; 164
   16512:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   16516:	80 91 74 00 	lds	r24, 0x0074
   1651a:	87 ff       	sbrs	r24, 7
   1651c:	fc cf       	rjmp	.-8      	; 0x16516 <_rtc+0xf8>
		if(TW_STATUS != TW_REP_START)
   1651e:	80 91 71 00 	lds	r24, 0x0071
   16522:	88 7f       	andi	r24, 0xF8	; 248
   16524:	80 31       	cpi	r24, 0x10	; 16
   16526:	d9 f5       	brne	.+118    	; 0x1659e <_rtc+0x180>
			return 1;

		TWDR = _DS1307R;
   16528:	81 ed       	ldi	r24, 0xD1	; 209
   1652a:	80 93 73 00 	sts	0x0073, r24
		TWCR =_BV(TWINT) | _BV(TWEN);
   1652e:	84 e8       	ldi	r24, 0x84	; 132
   16530:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   16534:	80 91 74 00 	lds	r24, 0x0074
   16538:	87 ff       	sbrs	r24, 7
   1653a:	fc cf       	rjmp	.-8      	; 0x16534 <_rtc+0x116>
		if(TW_STATUS != TW_MR_SLA_ACK)
   1653c:	80 91 71 00 	lds	r24, 0x0071
   16540:	88 7f       	andi	r24, 0xF8	; 248
   16542:	80 34       	cpi	r24, 0x40	; 64
   16544:	61 f5       	brne	.+88     	; 0x1659e <_rtc+0x180>
   16546:	24 ec       	ldi	r18, 0xC4	; 196
   16548:	30 e0       	ldi	r19, 0x00	; 0
   1654a:	90 e0       	ldi	r25, 0x00	; 0
   1654c:	20 c0       	rjmp	.+64     	; 0x1658e <_rtc+0x170>
			return 1;

		for(__twcr = _BV(TWINT) | _BV(TWEN) | _BV(TWEA); __len > 0; __len--){
			if(__len == 1)
   1654e:	61 30       	cpi	r22, 0x01	; 1
   16550:	71 05       	cpc	r23, r1
   16552:	11 f4       	brne	.+4      	; 0x16558 <_rtc+0x13a>
   16554:	24 e8       	ldi	r18, 0x84	; 132
   16556:	30 e0       	ldi	r19, 0x00	; 0
				__twcr = _BV(TWINT) | _BV(TWEN);
			TWCR = __twcr;
   16558:	20 93 74 00 	sts	0x0074, r18
			_rtc_response;
   1655c:	80 91 74 00 	lds	r24, 0x0074
   16560:	87 ff       	sbrs	r24, 7
   16562:	fc cf       	rjmp	.-8      	; 0x1655c <_rtc+0x13e>
			if(TW_STATUS == TW_MR_DATA_NACK)
   16564:	80 91 71 00 	lds	r24, 0x0071
   16568:	88 7f       	andi	r24, 0xF8	; 248
   1656a:	88 35       	cpi	r24, 0x58	; 88
   1656c:	11 f4       	brne	.+4      	; 0x16572 <_rtc+0x154>
   1656e:	60 e0       	ldi	r22, 0x00	; 0
   16570:	70 e0       	ldi	r23, 0x00	; 0
				__len = 0;
			if(TW_STATUS == TW_MR_DATA_ACK)
   16572:	80 91 71 00 	lds	r24, 0x0071
   16576:	88 7f       	andi	r24, 0xF8	; 248
   16578:	80 35       	cpi	r24, 0x50	; 80
   1657a:	39 f4       	brne	.+14     	; 0x1658a <_rtc+0x16c>
				__datetime[__i++] = TWDR;
   1657c:	80 91 73 00 	lds	r24, 0x0073
   16580:	fa 01       	movw	r30, r20
   16582:	e9 0f       	add	r30, r25
   16584:	f1 1d       	adc	r31, r1
   16586:	80 83       	st	Z, r24
   16588:	9f 5f       	subi	r25, 0xFF	; 255
		TWCR =_BV(TWINT) | _BV(TWEN);
		_rtc_response;
		if(TW_STATUS != TW_MR_SLA_ACK)
			return 1;

		for(__twcr = _BV(TWINT) | _BV(TWEN) | _BV(TWEA); __len > 0; __len--){
   1658a:	61 50       	subi	r22, 0x01	; 1
   1658c:	70 40       	sbci	r23, 0x00	; 0
   1658e:	16 16       	cp	r1, r22
   16590:	17 06       	cpc	r1, r23
   16592:	ec f2       	brlt	.-70     	; 0x1654e <_rtc+0x130>
			if(TW_STATUS == TW_MR_DATA_NACK)
				__len = 0;
			if(TW_STATUS == TW_MR_DATA_ACK)
				__datetime[__i++] = TWDR;
		}
		TWCR = _BV(TWINT) | _BV(TWSTO) | _BV(TWEN);
   16594:	84 e9       	ldi	r24, 0x94	; 148
   16596:	80 93 74 00 	sts	0x0074, r24
   1659a:	80 e0       	ldi	r24, 0x00	; 0
   1659c:	08 95       	ret
   1659e:	81 e0       	ldi	r24, 0x01	; 1
	}

    return 0;
}
   165a0:	08 95       	ret

000165a2 <_datetime>:

void _datetime(unsigned char __mode, char* __date, char* __time){
   165a2:	ef 92       	push	r14
   165a4:	ff 92       	push	r15
   165a6:	0f 93       	push	r16
   165a8:	1f 93       	push	r17
   165aa:	df 93       	push	r29
   165ac:	cf 93       	push	r28
   165ae:	cd b7       	in	r28, 0x3d	; 61
   165b0:	de b7       	in	r29, 0x3e	; 62
   165b2:	64 97       	sbiw	r28, 0x14	; 20
   165b4:	0f b6       	in	r0, 0x3f	; 63
   165b6:	f8 94       	cli
   165b8:	de bf       	out	0x3e, r29	; 62
   165ba:	0f be       	out	0x3f, r0	; 63
   165bc:	cd bf       	out	0x3d, r28	; 61
   165be:	28 2f       	mov	r18, r24
   165c0:	8b 01       	movw	r16, r22
   165c2:	7a 01       	movw	r14, r20
   165c4:	ae 01       	movw	r20, r28
   165c6:	4f 5f       	subi	r20, 0xFF	; 255
   165c8:	5f 4f       	sbci	r21, 0xFF	; 255
	char	__datetime[20];

	if(__mode){
   165ca:	88 23       	and	r24, r24
   165cc:	99 f1       	breq	.+102    	; 0x16634 <_datetime+0x92>
		__datetime[4] = (((__date[0] - 0x30) & 0x0F) << 4) + ((__date[1] - 0x30) & 0x0F);
   165ce:	fb 01       	movw	r30, r22
   165d0:	90 81       	ld	r25, Z
   165d2:	92 95       	swap	r25
   165d4:	90 7f       	andi	r25, 0xF0	; 240
   165d6:	81 81       	ldd	r24, Z+1	; 0x01
   165d8:	8f 70       	andi	r24, 0x0F	; 15
   165da:	98 0f       	add	r25, r24
   165dc:	9d 83       	std	Y+5, r25	; 0x05
		__datetime[5] = (((__date[3] - 0x30) & 0x0F) << 4) + ((__date[4] - 0x30) & 0x0F);
   165de:	93 81       	ldd	r25, Z+3	; 0x03
   165e0:	92 95       	swap	r25
   165e2:	90 7f       	andi	r25, 0xF0	; 240
   165e4:	84 81       	ldd	r24, Z+4	; 0x04
   165e6:	8f 70       	andi	r24, 0x0F	; 15
   165e8:	98 0f       	add	r25, r24
   165ea:	9e 83       	std	Y+6, r25	; 0x06
		__datetime[6] = (((__date[6] - 0x30) & 0x0F) << 4) + ((__date[7] - 0x30) & 0x0F);
   165ec:	96 81       	ldd	r25, Z+6	; 0x06
   165ee:	92 95       	swap	r25
   165f0:	90 7f       	andi	r25, 0xF0	; 240
   165f2:	87 81       	ldd	r24, Z+7	; 0x07
   165f4:	8f 70       	andi	r24, 0x0F	; 15
   165f6:	98 0f       	add	r25, r24
   165f8:	9f 83       	std	Y+7, r25	; 0x07

		__datetime[2] = (((__time[0] - 0x30) & 0x0F) << 4) + ((__time[1] - 0x30) & 0x0F);
   165fa:	f7 01       	movw	r30, r14
   165fc:	90 81       	ld	r25, Z
   165fe:	92 95       	swap	r25
   16600:	90 7f       	andi	r25, 0xF0	; 240
   16602:	81 81       	ldd	r24, Z+1	; 0x01
   16604:	8f 70       	andi	r24, 0x0F	; 15
   16606:	98 0f       	add	r25, r24
   16608:	9b 83       	std	Y+3, r25	; 0x03
		__datetime[1] = (((__time[3] - 0x30) & 0x0F) << 4) + ((__time[4] - 0x30) & 0x0F);
   1660a:	93 81       	ldd	r25, Z+3	; 0x03
   1660c:	92 95       	swap	r25
   1660e:	90 7f       	andi	r25, 0xF0	; 240
   16610:	84 81       	ldd	r24, Z+4	; 0x04
   16612:	8f 70       	andi	r24, 0x0F	; 15
   16614:	98 0f       	add	r25, r24
   16616:	9a 83       	std	Y+2, r25	; 0x02
		__datetime[0] = (((__time[6] - 0x30) & 0x0F) << 4) + ((__time[7] - 0x30) & 0x0F);
   16618:	96 81       	ldd	r25, Z+6	; 0x06
   1661a:	92 95       	swap	r25
   1661c:	90 7f       	andi	r25, 0xF0	; 240
   1661e:	87 81       	ldd	r24, Z+7	; 0x07
   16620:	8f 70       	andi	r24, 0x0F	; 15
   16622:	98 0f       	add	r25, r24
   16624:	99 83       	std	Y+1, r25	; 0x01
		_rtc(0, 8, __datetime, __mode);
   16626:	80 e0       	ldi	r24, 0x00	; 0
   16628:	90 e0       	ldi	r25, 0x00	; 0
   1662a:	68 e0       	ldi	r22, 0x08	; 8
   1662c:	70 e0       	ldi	r23, 0x00	; 0
   1662e:	0e 94 0f b2 	call	0x1641e	; 0x1641e <_rtc>
   16632:	4a c0       	rjmp	.+148    	; 0x166c8 <_datetime+0x126>
	}
	else
		if(_rtc(0, 8, __datetime, __mode) != 1){
   16634:	80 e0       	ldi	r24, 0x00	; 0
   16636:	90 e0       	ldi	r25, 0x00	; 0
   16638:	68 e0       	ldi	r22, 0x08	; 8
   1663a:	70 e0       	ldi	r23, 0x00	; 0
   1663c:	20 e0       	ldi	r18, 0x00	; 0
   1663e:	0e 94 0f b2 	call	0x1641e	; 0x1641e <_rtc>
   16642:	81 30       	cpi	r24, 0x01	; 1
   16644:	09 f4       	brne	.+2      	; 0x16648 <_datetime+0xa6>
   16646:	40 c0       	rjmp	.+128    	; 0x166c8 <_datetime+0x126>
			__date[0] = (__datetime[4] >> 4) + 0x30;
   16648:	9d 81       	ldd	r25, Y+5	; 0x05
   1664a:	89 2f       	mov	r24, r25
   1664c:	82 95       	swap	r24
   1664e:	8f 70       	andi	r24, 0x0F	; 15
   16650:	80 5d       	subi	r24, 0xD0	; 208
   16652:	f8 01       	movw	r30, r16
   16654:	80 83       	st	Z, r24
			__date[1] = (__datetime[4] & 0x0F) + 0x30;
   16656:	9f 70       	andi	r25, 0x0F	; 15
   16658:	90 5d       	subi	r25, 0xD0	; 208
   1665a:	91 83       	std	Z+1, r25	; 0x01
			__date[2] = '/';
   1665c:	2f e2       	ldi	r18, 0x2F	; 47
   1665e:	22 83       	std	Z+2, r18	; 0x02
			__date[3] = (__datetime[5] >> 4) + 0x30;
   16660:	9e 81       	ldd	r25, Y+6	; 0x06
   16662:	89 2f       	mov	r24, r25
   16664:	82 95       	swap	r24
   16666:	8f 70       	andi	r24, 0x0F	; 15
   16668:	80 5d       	subi	r24, 0xD0	; 208
   1666a:	83 83       	std	Z+3, r24	; 0x03
			__date[4] = (__datetime[5] & 0x0F) + 0x30;
   1666c:	9f 70       	andi	r25, 0x0F	; 15
   1666e:	90 5d       	subi	r25, 0xD0	; 208
   16670:	94 83       	std	Z+4, r25	; 0x04
			__date[5] = '/';
   16672:	25 83       	std	Z+5, r18	; 0x05
			__date[6] = (__datetime[6] >> 4) + 0x30;
   16674:	9f 81       	ldd	r25, Y+7	; 0x07
   16676:	89 2f       	mov	r24, r25
   16678:	82 95       	swap	r24
   1667a:	8f 70       	andi	r24, 0x0F	; 15
   1667c:	80 5d       	subi	r24, 0xD0	; 208
   1667e:	86 83       	std	Z+6, r24	; 0x06
			__date[7] = (__datetime[6] & 0x0F) + 0x30;
   16680:	9f 70       	andi	r25, 0x0F	; 15
   16682:	90 5d       	subi	r25, 0xD0	; 208
   16684:	97 83       	std	Z+7, r25	; 0x07
			__date[8] = '\0';
   16686:	10 86       	std	Z+8, r1	; 0x08

			__time[0] = (__datetime[2] >> 4) + 0x30;
   16688:	9b 81       	ldd	r25, Y+3	; 0x03
   1668a:	89 2f       	mov	r24, r25
   1668c:	82 95       	swap	r24
   1668e:	8f 70       	andi	r24, 0x0F	; 15
   16690:	80 5d       	subi	r24, 0xD0	; 208
   16692:	f7 01       	movw	r30, r14
   16694:	80 83       	st	Z, r24
			__time[1] = (__datetime[2] & 0x0F) + 0x30;
   16696:	9f 70       	andi	r25, 0x0F	; 15
   16698:	90 5d       	subi	r25, 0xD0	; 208
   1669a:	91 83       	std	Z+1, r25	; 0x01
			__time[2] = ':';
   1669c:	2a e3       	ldi	r18, 0x3A	; 58
   1669e:	22 83       	std	Z+2, r18	; 0x02
			__time[3] = (__datetime[1] >> 4) + 0x30;
   166a0:	9a 81       	ldd	r25, Y+2	; 0x02
   166a2:	89 2f       	mov	r24, r25
   166a4:	82 95       	swap	r24
   166a6:	8f 70       	andi	r24, 0x0F	; 15
   166a8:	80 5d       	subi	r24, 0xD0	; 208
   166aa:	83 83       	std	Z+3, r24	; 0x03
			__time[4] = (__datetime[1] & 0x0F) + 0x30;
   166ac:	9f 70       	andi	r25, 0x0F	; 15
   166ae:	90 5d       	subi	r25, 0xD0	; 208
   166b0:	94 83       	std	Z+4, r25	; 0x04
			__time[5] = ':';
   166b2:	25 83       	std	Z+5, r18	; 0x05
			__time[6] = (__datetime[0] >> 4) + 0x30;
   166b4:	99 81       	ldd	r25, Y+1	; 0x01
   166b6:	89 2f       	mov	r24, r25
   166b8:	82 95       	swap	r24
   166ba:	8f 70       	andi	r24, 0x0F	; 15
   166bc:	80 5d       	subi	r24, 0xD0	; 208
   166be:	86 83       	std	Z+6, r24	; 0x06
			__time[7] = (__datetime[0] & 0x0F) + 0x30;
   166c0:	9f 70       	andi	r25, 0x0F	; 15
   166c2:	90 5d       	subi	r25, 0xD0	; 208
   166c4:	97 83       	std	Z+7, r25	; 0x07
			__time[8] = '\0';
   166c6:	10 86       	std	Z+8, r1	; 0x08
		}
}
   166c8:	64 96       	adiw	r28, 0x14	; 20
   166ca:	0f b6       	in	r0, 0x3f	; 63
   166cc:	f8 94       	cli
   166ce:	de bf       	out	0x3e, r29	; 62
   166d0:	0f be       	out	0x3f, r0	; 63
   166d2:	cd bf       	out	0x3d, r28	; 61
   166d4:	cf 91       	pop	r28
   166d6:	df 91       	pop	r29
   166d8:	1f 91       	pop	r17
   166da:	0f 91       	pop	r16
   166dc:	ff 90       	pop	r15
   166de:	ef 90       	pop	r14
   166e0:	08 95       	ret

000166e2 <_day>:

unsigned char _day(void){
   166e2:	df 93       	push	r29
   166e4:	cf 93       	push	r28
   166e6:	cd b7       	in	r28, 0x3d	; 61
   166e8:	de b7       	in	r29, 0x3e	; 62
   166ea:	64 97       	sbiw	r28, 0x14	; 20
   166ec:	0f b6       	in	r0, 0x3f	; 63
   166ee:	f8 94       	cli
   166f0:	de bf       	out	0x3e, r29	; 62
   166f2:	0f be       	out	0x3f, r0	; 63
   166f4:	cd bf       	out	0x3d, r28	; 61
	char	__datetime[20];

	if(_rtc(0, 8, __datetime, 0) != 1)
   166f6:	80 e0       	ldi	r24, 0x00	; 0
   166f8:	90 e0       	ldi	r25, 0x00	; 0
   166fa:	68 e0       	ldi	r22, 0x08	; 8
   166fc:	70 e0       	ldi	r23, 0x00	; 0
   166fe:	ae 01       	movw	r20, r28
   16700:	4f 5f       	subi	r20, 0xFF	; 255
   16702:	5f 4f       	sbci	r21, 0xFF	; 255
   16704:	20 e0       	ldi	r18, 0x00	; 0
   16706:	0e 94 0f b2 	call	0x1641e	; 0x1641e <_rtc>
   1670a:	81 30       	cpi	r24, 0x01	; 1
   1670c:	11 f4       	brne	.+4      	; 0x16712 <_day+0x30>
   1670e:	80 e0       	ldi	r24, 0x00	; 0
   16710:	02 c0       	rjmp	.+4      	; 0x16716 <_day+0x34>
		return __datetime[3] & 0x0F;
   16712:	8c 81       	ldd	r24, Y+4	; 0x04
   16714:	8f 70       	andi	r24, 0x0F	; 15
	return 0;
   16716:	64 96       	adiw	r28, 0x14	; 20
   16718:	0f b6       	in	r0, 0x3f	; 63
   1671a:	f8 94       	cli
   1671c:	de bf       	out	0x3e, r29	; 62
   1671e:	0f be       	out	0x3f, r0	; 63
   16720:	cd bf       	out	0x3d, r28	; 61
   16722:	cf 91       	pop	r28
   16724:	df 91       	pop	r29
   16726:	08 95       	ret

00016728 <_uart_baudrate>:
	}

	_uart_baudrate(__com, __baudrate);
}

void _uart_baudrate(unsigned char __com, unsigned long __baudrate){
   16728:	1f 93       	push	r17
   1672a:	18 2f       	mov	r17, r24
   1672c:	9a 01       	movw	r18, r20
   1672e:	ab 01       	movw	r20, r22
	unsigned long __br;

	__br = (unsigned long)((_CPU_DEFAULT + (__baudrate * 8)) / (__baudrate * 16) - 1);
   16730:	ca 01       	movw	r24, r20
   16732:	b9 01       	movw	r22, r18
   16734:	60 50       	subi	r22, 0x00	; 0
   16736:	70 4e       	sbci	r23, 0xE0	; 224
   16738:	83 4e       	sbci	r24, 0xE3	; 227
   1673a:	9f 4f       	sbci	r25, 0xFF	; 255
   1673c:	f3 e0       	ldi	r31, 0x03	; 3
   1673e:	66 0f       	add	r22, r22
   16740:	77 1f       	adc	r23, r23
   16742:	88 1f       	adc	r24, r24
   16744:	99 1f       	adc	r25, r25
   16746:	fa 95       	dec	r31
   16748:	d1 f7       	brne	.-12     	; 0x1673e <_uart_baudrate+0x16>
   1674a:	e4 e0       	ldi	r30, 0x04	; 4
   1674c:	22 0f       	add	r18, r18
   1674e:	33 1f       	adc	r19, r19
   16750:	44 1f       	adc	r20, r20
   16752:	55 1f       	adc	r21, r21
   16754:	ea 95       	dec	r30
   16756:	d1 f7       	brne	.-12     	; 0x1674c <_uart_baudrate+0x24>
   16758:	0e 94 ba b8 	call	0x17174	; 0x17174 <__udivmodsi4>
   1675c:	21 50       	subi	r18, 0x01	; 1
   1675e:	30 40       	sbci	r19, 0x00	; 0
   16760:	40 40       	sbci	r20, 0x00	; 0
   16762:	50 40       	sbci	r21, 0x00	; 0
   16764:	bb 27       	eor	r27, r27
   16766:	a5 2f       	mov	r26, r21
   16768:	94 2f       	mov	r25, r20
   1676a:	83 2f       	mov	r24, r19

	if(__com){
   1676c:	11 23       	and	r17, r17
   1676e:	29 f0       	breq	.+10     	; 0x1677a <_uart_baudrate+0x52>
		UBRR1L = __br;
   16770:	20 93 99 00 	sts	0x0099, r18
		UBRR1H = __br >> 8;
   16774:	80 93 98 00 	sts	0x0098, r24
   16778:	03 c0       	rjmp	.+6      	; 0x16780 <_uart_baudrate+0x58>
	}
	else{
		UBRR0L = __br;
   1677a:	29 b9       	out	0x09, r18	; 9
		UBRR0H = __br >> 8;
   1677c:	80 93 90 00 	sts	0x0090, r24
	}
}
   16780:	1f 91       	pop	r17
   16782:	08 95       	ret

00016784 <_uart_init>:
#include <util/delay.h>
#include <string.h>

#include "UART.h"

void _uart_init(unsigned char __com, unsigned long __baudrate){
   16784:	98 2f       	mov	r25, r24
	if(__com){
   16786:	88 23       	and	r24, r24
   16788:	39 f0       	breq	.+14     	; 0x16798 <_uart_init+0x14>
		UCSR1B = _BV(RXCIE1) | _BV(RXEN1) | _BV(TXEN1);
   1678a:	88 e9       	ldi	r24, 0x98	; 152
   1678c:	80 93 9a 00 	sts	0x009A, r24
		UCSR1C = _BV(UCSZ11) | _BV(UCSZ10);
   16790:	86 e0       	ldi	r24, 0x06	; 6
   16792:	80 93 9d 00 	sts	0x009D, r24
   16796:	05 c0       	rjmp	.+10     	; 0x167a2 <_uart_init+0x1e>
	}
	else{
		UCSR0B = _BV(RXCIE0) | _BV(RXEN0) | _BV(TXEN0);
   16798:	88 e9       	ldi	r24, 0x98	; 152
   1679a:	8a b9       	out	0x0a, r24	; 10
		UCSR0C = _BV(UCSZ01) | _BV(UCSZ00);
   1679c:	86 e0       	ldi	r24, 0x06	; 6
   1679e:	80 93 95 00 	sts	0x0095, r24
	}

	_uart_baudrate(__com, __baudrate);
   167a2:	89 2f       	mov	r24, r25
   167a4:	0e 94 94 b3 	call	0x16728	; 0x16728 <_uart_baudrate>
}
   167a8:	08 95       	ret

000167aa <_uart>:
		UBRR0H = __br >> 8;
	}
}

unsigned char _uart(unsigned char __com, unsigned char __dir, unsigned char __chr){
	if(__com){
   167aa:	88 23       	and	r24, r24
   167ac:	81 f0       	breq	.+32     	; 0x167ce <_uart+0x24>
		if(__dir){
   167ae:	66 23       	and	r22, r22
   167b0:	39 f0       	breq	.+14     	; 0x167c0 <_uart+0x16>
			loop_until_bit_is_set(UCSR1A, UDRE1);
   167b2:	80 91 9b 00 	lds	r24, 0x009B
   167b6:	85 ff       	sbrs	r24, 5
   167b8:	fc cf       	rjmp	.-8      	; 0x167b2 <_uart+0x8>
			UDR1 = __chr;
   167ba:	40 93 9c 00 	sts	0x009C, r20
   167be:	0c c0       	rjmp	.+24     	; 0x167d8 <_uart+0x2e>
		}
		else{
			loop_until_bit_is_set(UCSR1A, RXC);
   167c0:	80 91 9b 00 	lds	r24, 0x009B
   167c4:	87 ff       	sbrs	r24, 7
   167c6:	fc cf       	rjmp	.-8      	; 0x167c0 <_uart+0x16>
			return UDR1;
   167c8:	80 91 9c 00 	lds	r24, 0x009C
   167cc:	08 95       	ret
		}
	}
	else{
		if(__dir){
   167ce:	66 23       	and	r22, r22
   167d0:	29 f0       	breq	.+10     	; 0x167dc <_uart+0x32>
			loop_until_bit_is_set(UCSR0A, UDRE0);
   167d2:	5d 9b       	sbis	0x0b, 5	; 11
   167d4:	fe cf       	rjmp	.-4      	; 0x167d2 <_uart+0x28>
			UDR0 = __chr;
   167d6:	4c b9       	out	0x0c, r20	; 12
   167d8:	81 e0       	ldi	r24, 0x01	; 1
   167da:	08 95       	ret
		}
		else{
			loop_until_bit_is_set(UCSR0A,  RXC);
   167dc:	5f 9b       	sbis	0x0b, 7	; 11
   167de:	fe cf       	rjmp	.-4      	; 0x167dc <_uart+0x32>
			return UDR0;
   167e0:	8c b1       	in	r24, 0x0c	; 12
		}

	}

	return 1;
}
   167e2:	08 95       	ret

000167e4 <_uart_print>:

void _uart_print(unsigned char __com, unsigned char __ret, char *__str){
   167e4:	0f 93       	push	r16
   167e6:	1f 93       	push	r17
   167e8:	cf 93       	push	r28
   167ea:	df 93       	push	r29
   167ec:	18 2f       	mov	r17, r24
   167ee:	06 2f       	mov	r16, r22
   167f0:	ea 01       	movw	r28, r20
	if(strlen(__str)>0)
   167f2:	88 81       	ld	r24, Y
   167f4:	88 23       	and	r24, r24
   167f6:	31 f4       	brne	.+12     	; 0x16804 <_uart_print+0x20>
   167f8:	08 c0       	rjmp	.+16     	; 0x1680a <_uart_print+0x26>
		while(*__str)
		     _uart(__com, 1, *__str++);
   167fa:	21 96       	adiw	r28, 0x01	; 1
   167fc:	81 2f       	mov	r24, r17
   167fe:	61 e0       	ldi	r22, 0x01	; 1
   16800:	0e 94 d5 b3 	call	0x167aa	; 0x167aa <_uart>
	return 1;
}

void _uart_print(unsigned char __com, unsigned char __ret, char *__str){
	if(strlen(__str)>0)
		while(*__str)
   16804:	48 81       	ld	r20, Y
   16806:	44 23       	and	r20, r20
   16808:	c1 f7       	brne	.-16     	; 0x167fa <_uart_print+0x16>
		     _uart(__com, 1, *__str++);

	if(__ret){
   1680a:	00 23       	and	r16, r16
   1680c:	51 f0       	breq	.+20     	; 0x16822 <_uart_print+0x3e>
		_uart(__com, 1, 0x0D);
   1680e:	81 2f       	mov	r24, r17
   16810:	61 e0       	ldi	r22, 0x01	; 1
   16812:	4d e0       	ldi	r20, 0x0D	; 13
   16814:	0e 94 d5 b3 	call	0x167aa	; 0x167aa <_uart>
		_uart(__com, 1, 0x0A);
   16818:	81 2f       	mov	r24, r17
   1681a:	61 e0       	ldi	r22, 0x01	; 1
   1681c:	4a e0       	ldi	r20, 0x0A	; 10
   1681e:	0e 94 d5 b3 	call	0x167aa	; 0x167aa <_uart>
   16822:	82 ee       	ldi	r24, 0xE2	; 226
   16824:	94 e0       	ldi	r25, 0x04	; 4
   16826:	01 97       	sbiw	r24, 0x01	; 1
   16828:	f1 f7       	brne	.-4      	; 0x16826 <_uart_print+0x42>
	}
	_delay_ms(5);
}
   1682a:	df 91       	pop	r29
   1682c:	cf 91       	pop	r28
   1682e:	1f 91       	pop	r17
   16830:	0f 91       	pop	r16
   16832:	08 95       	ret

00016834 <_uart_printf>:

void _uart_printf(unsigned char __com, unsigned char __ret, char *__str){
   16834:	0f 93       	push	r16
   16836:	1f 93       	push	r17
   16838:	cf 93       	push	r28
   1683a:	df 93       	push	r29
   1683c:	18 2f       	mov	r17, r24
   1683e:	06 2f       	mov	r16, r22
   16840:	ea 01       	movw	r28, r20
   16842:	07 c0       	rjmp	.+14     	; 0x16852 <_uart_printf+0x1e>
	while(pgm_read_byte(&(*__str)))
		_uart(__com, 1, pgm_read_byte(&(*__str++)));
   16844:	21 96       	adiw	r28, 0x01	; 1
   16846:	f9 01       	movw	r30, r18
   16848:	44 91       	lpm	r20, Z+
   1684a:	81 2f       	mov	r24, r17
   1684c:	61 e0       	ldi	r22, 0x01	; 1
   1684e:	0e 94 d5 b3 	call	0x167aa	; 0x167aa <_uart>
   16852:	9e 01       	movw	r18, r28
	}
	_delay_ms(5);
}

void _uart_printf(unsigned char __com, unsigned char __ret, char *__str){
	while(pgm_read_byte(&(*__str)))
   16854:	fe 01       	movw	r30, r28
   16856:	84 91       	lpm	r24, Z+
   16858:	88 23       	and	r24, r24
   1685a:	a1 f7       	brne	.-24     	; 0x16844 <_uart_printf+0x10>
		_uart(__com, 1, pgm_read_byte(&(*__str++)));

	if(__ret){
   1685c:	00 23       	and	r16, r16
   1685e:	51 f0       	breq	.+20     	; 0x16874 <_uart_printf+0x40>
		_uart(__com, 1, 0x0D);
   16860:	81 2f       	mov	r24, r17
   16862:	61 e0       	ldi	r22, 0x01	; 1
   16864:	4d e0       	ldi	r20, 0x0D	; 13
   16866:	0e 94 d5 b3 	call	0x167aa	; 0x167aa <_uart>
		_uart(__com, 1, 0x0A);
   1686a:	81 2f       	mov	r24, r17
   1686c:	61 e0       	ldi	r22, 0x01	; 1
   1686e:	4a e0       	ldi	r20, 0x0A	; 10
   16870:	0e 94 d5 b3 	call	0x167aa	; 0x167aa <_uart>
   16874:	86 ea       	ldi	r24, 0xA6	; 166
   16876:	9e e0       	ldi	r25, 0x0E	; 14
   16878:	01 97       	sbiw	r24, 0x01	; 1
   1687a:	f1 f7       	brne	.-4      	; 0x16878 <_uart_printf+0x44>
	}
	_delay_ms(15);
}
   1687c:	df 91       	pop	r29
   1687e:	cf 91       	pop	r28
   16880:	1f 91       	pop	r17
   16882:	0f 91       	pop	r16
   16884:	08 95       	ret

00016886 <Int2Str>:

void Int2Str(char* __string, unsigned long __value){
   16886:	6f 92       	push	r6
   16888:	7f 92       	push	r7
   1688a:	8f 92       	push	r8
   1688c:	9f 92       	push	r9
   1688e:	af 92       	push	r10
   16890:	bf 92       	push	r11
   16892:	cf 92       	push	r12
   16894:	df 92       	push	r13
   16896:	ef 92       	push	r14
   16898:	ff 92       	push	r15
   1689a:	0f 93       	push	r16
   1689c:	1f 93       	push	r17
   1689e:	cf 93       	push	r28
   168a0:	df 93       	push	r29
   168a2:	ec 01       	movw	r28, r24
	char			__flag = 0, __i = 0, __count;
	unsigned long	__num, __devider = 1000000000;
	int				__tmp;

	if(__value == 0){
   168a4:	41 15       	cp	r20, r1
   168a6:	51 05       	cpc	r21, r1
   168a8:	61 05       	cpc	r22, r1
   168aa:	71 05       	cpc	r23, r1
   168ac:	21 f4       	brne	.+8      	; 0x168b6 <Int2Str+0x30>
		__string[0] = '0';
   168ae:	80 e3       	ldi	r24, 0x30	; 48
   168b0:	88 83       	st	Y, r24
		__string[1] = '\0';
   168b2:	19 82       	std	Y+1, r1	; 0x01
   168b4:	48 c0       	rjmp	.+144    	; 0x16946 <Int2Str+0xc0>
		return;
   168b6:	4a 01       	movw	r8, r20
   168b8:	5b 01       	movw	r10, r22
   168ba:	10 e0       	ldi	r17, 0x00	; 0
   168bc:	00 e0       	ldi	r16, 0x00	; 0
   168be:	77 24       	eor	r7, r7
   168c0:	c1 2c       	mov	r12, r1
   168c2:	ba ec       	ldi	r27, 0xCA	; 202
   168c4:	db 2e       	mov	r13, r27
   168c6:	ba e9       	ldi	r27, 0x9A	; 154
   168c8:	eb 2e       	mov	r14, r27
   168ca:	bb e3       	ldi	r27, 0x3B	; 59
   168cc:	fb 2e       	mov	r15, r27
			if(!__flag)
				__flag = 1;
		}
		else
			if(__flag)
				__string[__i++] = 0x30;
   168ce:	a0 e3       	ldi	r26, 0x30	; 48
   168d0:	6a 2e       	mov	r6, r26
		return;
	}

	__num = __value;
	for(__count = 0; __count < 10; __count++){
		if(__num >= __devider){
   168d2:	8c 14       	cp	r8, r12
   168d4:	9d 04       	cpc	r9, r13
   168d6:	ae 04       	cpc	r10, r14
   168d8:	bf 04       	cpc	r11, r15
   168da:	d0 f0       	brcs	.+52     	; 0x16910 <Int2Str+0x8a>
			__tmp = (int)(__num / __devider);
   168dc:	c5 01       	movw	r24, r10
   168de:	b4 01       	movw	r22, r8
   168e0:	a7 01       	movw	r20, r14
   168e2:	96 01       	movw	r18, r12
   168e4:	0e 94 ba b8 	call	0x17174	; 0x17174 <__udivmodsi4>
   168e8:	12 2f       	mov	r17, r18
			__num = __num % __devider;
   168ea:	c5 01       	movw	r24, r10
   168ec:	b4 01       	movw	r22, r8
   168ee:	a7 01       	movw	r20, r14
   168f0:	96 01       	movw	r18, r12
   168f2:	0e 94 ba b8 	call	0x17174	; 0x17174 <__udivmodsi4>
   168f6:	ac 01       	movw	r20, r24
   168f8:	cb 01       	movw	r24, r22
   168fa:	da 01       	movw	r26, r20
   168fc:	4c 01       	movw	r8, r24
   168fe:	5d 01       	movw	r10, r26
			__string[__i++] = __tmp + 0x30;
   16900:	fe 01       	movw	r30, r28
   16902:	e0 0f       	add	r30, r16
   16904:	f1 1d       	adc	r31, r1
   16906:	10 5d       	subi	r17, 0xD0	; 208
   16908:	10 83       	st	Z, r17
   1690a:	0f 5f       	subi	r16, 0xFF	; 255
   1690c:	11 e0       	ldi	r17, 0x01	; 1
   1690e:	07 c0       	rjmp	.+14     	; 0x1691e <Int2Str+0x98>
			if(!__flag)
				__flag = 1;
		}
		else
			if(__flag)
   16910:	11 23       	and	r17, r17
   16912:	29 f0       	breq	.+10     	; 0x1691e <Int2Str+0x98>
				__string[__i++] = 0x30;
   16914:	fe 01       	movw	r30, r28
   16916:	e0 0f       	add	r30, r16
   16918:	f1 1d       	adc	r31, r1
   1691a:	60 82       	st	Z, r6
   1691c:	0f 5f       	subi	r16, 0xFF	; 255
		__string[1] = '\0';
		return;
	}

	__num = __value;
	for(__count = 0; __count < 10; __count++){
   1691e:	73 94       	inc	r7
   16920:	8a e0       	ldi	r24, 0x0A	; 10
   16922:	78 16       	cp	r7, r24
   16924:	69 f0       	breq	.+26     	; 0x16940 <Int2Str+0xba>
				__flag = 1;
		}
		else
			if(__flag)
				__string[__i++] = 0x30;
		__devider = __devider / 10;
   16926:	c7 01       	movw	r24, r14
   16928:	b6 01       	movw	r22, r12
   1692a:	2a e0       	ldi	r18, 0x0A	; 10
   1692c:	30 e0       	ldi	r19, 0x00	; 0
   1692e:	40 e0       	ldi	r20, 0x00	; 0
   16930:	50 e0       	ldi	r21, 0x00	; 0
   16932:	0e 94 ba b8 	call	0x17174	; 0x17174 <__udivmodsi4>
   16936:	c9 01       	movw	r24, r18
   16938:	da 01       	movw	r26, r20
   1693a:	6c 01       	movw	r12, r24
   1693c:	7d 01       	movw	r14, r26
   1693e:	c9 cf       	rjmp	.-110    	; 0x168d2 <Int2Str+0x4c>
	}
	__string[__i] = '\0';
   16940:	c0 0f       	add	r28, r16
   16942:	d1 1d       	adc	r29, r1
   16944:	18 82       	st	Y, r1
}
   16946:	df 91       	pop	r29
   16948:	cf 91       	pop	r28
   1694a:	1f 91       	pop	r17
   1694c:	0f 91       	pop	r16
   1694e:	ff 90       	pop	r15
   16950:	ef 90       	pop	r14
   16952:	df 90       	pop	r13
   16954:	cf 90       	pop	r12
   16956:	bf 90       	pop	r11
   16958:	af 90       	pop	r10
   1695a:	9f 90       	pop	r9
   1695c:	8f 90       	pop	r8
   1695e:	7f 90       	pop	r7
   16960:	6f 90       	pop	r6
   16962:	08 95       	ret

00016964 <Str2Int>:

unsigned long Str2Int(char* __string){
   16964:	6f 92       	push	r6
   16966:	7f 92       	push	r7
   16968:	8f 92       	push	r8
   1696a:	9f 92       	push	r9
   1696c:	af 92       	push	r10
   1696e:	bf 92       	push	r11
   16970:	cf 92       	push	r12
   16972:	df 92       	push	r13
   16974:	ef 92       	push	r14
   16976:	ff 92       	push	r15
   16978:	0f 93       	push	r16
   1697a:	1f 93       	push	r17
   1697c:	cf 93       	push	r28
   1697e:	df 93       	push	r29
   16980:	ec 01       	movw	r28, r24
	unsigned char	__i, __len;
	unsigned long	__multiplier = 1, __retval = 0;

	__len = strlen(__string);
   16982:	dc 01       	movw	r26, r24
   16984:	0d 90       	ld	r0, X+
   16986:	00 20       	and	r0, r0
   16988:	e9 f7       	brne	.-6      	; 0x16984 <Str2Int+0x20>
   1698a:	11 97       	sbiw	r26, 0x01	; 1
   1698c:	7a 2e       	mov	r7, r26
   1698e:	78 1a       	sub	r7, r24

	if(__len > 0 && __len < 11){
   16990:	87 2d       	mov	r24, r7
   16992:	81 50       	subi	r24, 0x01	; 1
   16994:	8a 30       	cpi	r24, 0x0A	; 10
   16996:	08 f0       	brcs	.+2      	; 0x1699a <Str2Int+0x36>
   16998:	64 c0       	rjmp	.+200    	; 0x16a62 <Str2Int+0xfe>
   1699a:	4e 01       	movw	r8, r28
   1699c:	fe 01       	movw	r30, r28
		__devider = __devider / 10;
	}
	__string[__i] = '\0';
}

unsigned long Str2Int(char* __string){
   1699e:	6c 2e       	mov	r6, r28
   169a0:	05 c0       	rjmp	.+10     	; 0x169ac <Str2Int+0x48>

	__len = strlen(__string);

	if(__len > 0 && __len < 11){
		for(__i = 0; __i < __len; __i++)
			if(__string[__i] < 0x30 || __string[__i] > 0x39)
   169a2:	81 91       	ld	r24, Z+
   169a4:	80 53       	subi	r24, 0x30	; 48
   169a6:	8a 30       	cpi	r24, 0x0A	; 10
   169a8:	08 f0       	brcs	.+2      	; 0x169ac <Str2Int+0x48>
   169aa:	5b c0       	rjmp	.+182    	; 0x16a62 <Str2Int+0xfe>
	unsigned long	__multiplier = 1, __retval = 0;

	__len = strlen(__string);

	if(__len > 0 && __len < 11){
		for(__i = 0; __i < __len; __i++)
   169ac:	8e 2f       	mov	r24, r30
   169ae:	86 19       	sub	r24, r6
   169b0:	87 15       	cp	r24, r7
   169b2:	b8 f3       	brcs	.-18     	; 0x169a2 <Str2Int+0x3e>
			if(__string[__i] < 0x30 || __string[__i] > 0x39)
				return 0;
		if(__len == 10){
   169b4:	8a e0       	ldi	r24, 0x0A	; 10
   169b6:	78 16       	cp	r7, r24
   169b8:	f9 f4       	brne	.+62     	; 0x169f8 <Str2Int+0x94>
			if(__string[0] < 0x30 || __string[0] > 0x32)
   169ba:	98 81       	ld	r25, Y
   169bc:	89 2f       	mov	r24, r25
   169be:	80 53       	subi	r24, 0x30	; 48
   169c0:	83 30       	cpi	r24, 0x03	; 3
   169c2:	08 f0       	brcs	.+2      	; 0x169c6 <Str2Int+0x62>
   169c4:	4e c0       	rjmp	.+156    	; 0x16a62 <Str2Int+0xfe>
				return 0;
			if(__string[0] == 0x32){
   169c6:	92 33       	cpi	r25, 0x32	; 50
   169c8:	b9 f4       	brne	.+46     	; 0x169f8 <Str2Int+0x94>
   169ca:	fe 01       	movw	r30, r28
   169cc:	91 e0       	ldi	r25, 0x01	; 1
				for(__i = 1; __i < __len; __i++)
					if(__string[__i] < 0x30 || __string[__i] > 0x30)
   169ce:	81 81       	ldd	r24, Z+1	; 0x01
   169d0:	80 33       	cpi	r24, 0x30	; 48
   169d2:	09 f0       	breq	.+2      	; 0x169d6 <Str2Int+0x72>
   169d4:	46 c0       	rjmp	.+140    	; 0x16a62 <Str2Int+0xfe>
				return 0;
		if(__len == 10){
			if(__string[0] < 0x30 || __string[0] > 0x32)
				return 0;
			if(__string[0] == 0x32){
				for(__i = 1; __i < __len; __i++)
   169d6:	9f 5f       	subi	r25, 0xFF	; 255
   169d8:	31 96       	adiw	r30, 0x01	; 1
   169da:	9a 30       	cpi	r25, 0x0A	; 10
   169dc:	c1 f7       	brne	.-16     	; 0x169ce <Str2Int+0x6a>
   169de:	0c c0       	rjmp	.+24     	; 0x169f8 <Str2Int+0x94>
					if(__string[__i] < 0x30 || __string[__i] > 0x30)
						return 0;
			}
		}
		for(__i = 0; __i < __len - 1; __i++)
			__multiplier *= 10;
   169e0:	c6 01       	movw	r24, r12
   169e2:	b5 01       	movw	r22, r10
   169e4:	2a e0       	ldi	r18, 0x0A	; 10
   169e6:	30 e0       	ldi	r19, 0x00	; 0
   169e8:	40 e0       	ldi	r20, 0x00	; 0
   169ea:	50 e0       	ldi	r21, 0x00	; 0
   169ec:	0e 94 5b b8 	call	0x170b6	; 0x170b6 <__mulsi3>
   169f0:	5b 01       	movw	r10, r22
   169f2:	6c 01       	movw	r12, r24
				for(__i = 1; __i < __len; __i++)
					if(__string[__i] < 0x30 || __string[__i] > 0x30)
						return 0;
			}
		}
		for(__i = 0; __i < __len - 1; __i++)
   169f4:	1f 5f       	subi	r17, 0xFF	; 255
   169f6:	09 c0       	rjmp	.+18     	; 0x16a0a <Str2Int+0xa6>
   169f8:	10 e0       	ldi	r17, 0x00	; 0
   169fa:	01 e0       	ldi	r16, 0x01	; 1
   169fc:	a0 2e       	mov	r10, r16
   169fe:	b1 2c       	mov	r11, r1
   16a00:	c1 2c       	mov	r12, r1
   16a02:	d1 2c       	mov	r13, r1
   16a04:	c7 2d       	mov	r28, r7
   16a06:	d0 e0       	ldi	r29, 0x00	; 0
   16a08:	21 97       	sbiw	r28, 0x01	; 1
   16a0a:	81 2f       	mov	r24, r17
   16a0c:	90 e0       	ldi	r25, 0x00	; 0
   16a0e:	8c 17       	cp	r24, r28
   16a10:	9d 07       	cpc	r25, r29
   16a12:	34 f3       	brlt	.-52     	; 0x169e0 <Str2Int+0x7c>
   16a14:	ee 24       	eor	r14, r14
   16a16:	ff 24       	eor	r15, r15
   16a18:	87 01       	movw	r16, r14
   16a1a:	1e c0       	rjmp	.+60     	; 0x16a58 <Str2Int+0xf4>
			__multiplier *= 10;
		for(__i = 0; __i < __len; __i++, __multiplier /= 10)
			__retval += ((unsigned long)(__string[__i] - 0x30) * __multiplier);
   16a1c:	f4 01       	movw	r30, r8
   16a1e:	21 91       	ld	r18, Z+
   16a20:	4f 01       	movw	r8, r30
   16a22:	30 e0       	ldi	r19, 0x00	; 0
   16a24:	20 53       	subi	r18, 0x30	; 48
   16a26:	30 40       	sbci	r19, 0x00	; 0
   16a28:	44 27       	eor	r20, r20
   16a2a:	37 fd       	sbrc	r19, 7
   16a2c:	40 95       	com	r20
   16a2e:	54 2f       	mov	r21, r20
   16a30:	c6 01       	movw	r24, r12
   16a32:	b5 01       	movw	r22, r10
   16a34:	0e 94 5b b8 	call	0x170b6	; 0x170b6 <__mulsi3>
   16a38:	e6 0e       	add	r14, r22
   16a3a:	f7 1e       	adc	r15, r23
   16a3c:	08 1f       	adc	r16, r24
   16a3e:	19 1f       	adc	r17, r25
						return 0;
			}
		}
		for(__i = 0; __i < __len - 1; __i++)
			__multiplier *= 10;
		for(__i = 0; __i < __len; __i++, __multiplier /= 10)
   16a40:	c6 01       	movw	r24, r12
   16a42:	b5 01       	movw	r22, r10
   16a44:	2a e0       	ldi	r18, 0x0A	; 10
   16a46:	30 e0       	ldi	r19, 0x00	; 0
   16a48:	40 e0       	ldi	r20, 0x00	; 0
   16a4a:	50 e0       	ldi	r21, 0x00	; 0
   16a4c:	0e 94 ba b8 	call	0x17174	; 0x17174 <__udivmodsi4>
   16a50:	c9 01       	movw	r24, r18
   16a52:	da 01       	movw	r26, r20
   16a54:	5c 01       	movw	r10, r24
   16a56:	6d 01       	movw	r12, r26
   16a58:	88 2d       	mov	r24, r8
   16a5a:	86 19       	sub	r24, r6
   16a5c:	87 15       	cp	r24, r7
   16a5e:	f0 f2       	brcs	.-68     	; 0x16a1c <Str2Int+0xb8>
   16a60:	03 c0       	rjmp	.+6      	; 0x16a68 <Str2Int+0x104>
   16a62:	ee 24       	eor	r14, r14
   16a64:	ff 24       	eor	r15, r15
   16a66:	87 01       	movw	r16, r14
			__retval += ((unsigned long)(__string[__i] - 0x30) * __multiplier);
	}
	return __retval;
}
   16a68:	b7 01       	movw	r22, r14
   16a6a:	c8 01       	movw	r24, r16
   16a6c:	df 91       	pop	r29
   16a6e:	cf 91       	pop	r28
   16a70:	1f 91       	pop	r17
   16a72:	0f 91       	pop	r16
   16a74:	ff 90       	pop	r15
   16a76:	ef 90       	pop	r14
   16a78:	df 90       	pop	r13
   16a7a:	cf 90       	pop	r12
   16a7c:	bf 90       	pop	r11
   16a7e:	af 90       	pop	r10
   16a80:	9f 90       	pop	r9
   16a82:	8f 90       	pop	r8
   16a84:	7f 90       	pop	r7
   16a86:	6f 90       	pop	r6
   16a88:	08 95       	ret

00016a8a <atoi>:
   16a8a:	fc 01       	movw	r30, r24
   16a8c:	88 27       	eor	r24, r24
   16a8e:	99 27       	eor	r25, r25
   16a90:	e8 94       	clt
   16a92:	21 91       	ld	r18, Z+
   16a94:	20 32       	cpi	r18, 0x20	; 32
   16a96:	e9 f3       	breq	.-6      	; 0x16a92 <atoi+0x8>
   16a98:	29 30       	cpi	r18, 0x09	; 9
   16a9a:	10 f0       	brcs	.+4      	; 0x16aa0 <atoi+0x16>
   16a9c:	2e 30       	cpi	r18, 0x0E	; 14
   16a9e:	c8 f3       	brcs	.-14     	; 0x16a92 <atoi+0x8>
   16aa0:	2b 32       	cpi	r18, 0x2B	; 43
   16aa2:	41 f0       	breq	.+16     	; 0x16ab4 <atoi+0x2a>
   16aa4:	2d 32       	cpi	r18, 0x2D	; 45
   16aa6:	39 f4       	brne	.+14     	; 0x16ab6 <atoi+0x2c>
   16aa8:	68 94       	set
   16aaa:	04 c0       	rjmp	.+8      	; 0x16ab4 <atoi+0x2a>
   16aac:	0e 94 b2 b5 	call	0x16b64	; 0x16b64 <__mulhi_const_10>
   16ab0:	82 0f       	add	r24, r18
   16ab2:	91 1d       	adc	r25, r1
   16ab4:	21 91       	ld	r18, Z+
   16ab6:	20 53       	subi	r18, 0x30	; 48
   16ab8:	2a 30       	cpi	r18, 0x0A	; 10
   16aba:	c0 f3       	brcs	.-16     	; 0x16aac <atoi+0x22>
   16abc:	1e f4       	brtc	.+6      	; 0x16ac4 <atoi+0x3a>
   16abe:	90 95       	com	r25
   16ac0:	81 95       	neg	r24
   16ac2:	9f 4f       	sbci	r25, 0xFF	; 255
   16ac4:	08 95       	ret

00016ac6 <strcpy_P>:
   16ac6:	fb 01       	movw	r30, r22
   16ac8:	dc 01       	movw	r26, r24
   16aca:	05 90       	lpm	r0, Z+
   16acc:	0d 92       	st	X+, r0
   16ace:	00 20       	and	r0, r0
   16ad0:	e1 f7       	brne	.-8      	; 0x16aca <strcpy_P+0x4>
   16ad2:	08 95       	ret

00016ad4 <strcmp>:
   16ad4:	fb 01       	movw	r30, r22
   16ad6:	dc 01       	movw	r26, r24
   16ad8:	8d 91       	ld	r24, X+
   16ada:	01 90       	ld	r0, Z+
   16adc:	80 19       	sub	r24, r0
   16ade:	01 10       	cpse	r0, r1
   16ae0:	d9 f3       	breq	.-10     	; 0x16ad8 <strcmp+0x4>
   16ae2:	99 0b       	sbc	r25, r25
   16ae4:	08 95       	ret

00016ae6 <strcpy>:
   16ae6:	fb 01       	movw	r30, r22
   16ae8:	dc 01       	movw	r26, r24
   16aea:	01 90       	ld	r0, Z+
   16aec:	0d 92       	st	X+, r0
   16aee:	00 20       	and	r0, r0
   16af0:	e1 f7       	brne	.-8      	; 0x16aea <strcpy+0x4>
   16af2:	08 95       	ret

00016af4 <__eerd_block>:
   16af4:	a0 e0       	ldi	r26, 0x00	; 0
   16af6:	b0 e0       	ldi	r27, 0x00	; 0
   16af8:	e0 e8       	ldi	r30, 0x80	; 128
   16afa:	f5 eb       	ldi	r31, 0xB5	; 181
   16afc:	0c 94 e6 b8 	jmp	0x171cc	; 0x171cc <__prologue_saves__+0x14>
   16b00:	7c 01       	movw	r14, r24
   16b02:	eb 01       	movw	r28, r22
   16b04:	8a 01       	movw	r16, r20
   16b06:	69 01       	movw	r12, r18
   16b08:	09 c0       	rjmp	.+18     	; 0x16b1c <__eerd_block+0x28>
   16b0a:	ce 01       	movw	r24, r28
   16b0c:	21 96       	adiw	r28, 0x01	; 1
   16b0e:	f6 01       	movw	r30, r12
   16b10:	09 95       	icall
   16b12:	f7 01       	movw	r30, r14
   16b14:	81 93       	st	Z+, r24
   16b16:	7f 01       	movw	r14, r30
   16b18:	01 50       	subi	r16, 0x01	; 1
   16b1a:	10 40       	sbci	r17, 0x00	; 0
   16b1c:	01 15       	cp	r16, r1
   16b1e:	11 05       	cpc	r17, r1
   16b20:	a1 f7       	brne	.-24     	; 0x16b0a <__eerd_block+0x16>
   16b22:	cd b7       	in	r28, 0x3d	; 61
   16b24:	de b7       	in	r29, 0x3e	; 62
   16b26:	e8 e0       	ldi	r30, 0x08	; 8
   16b28:	0c 94 02 b9 	jmp	0x17204	; 0x17204 <__epilogue_restores__+0x14>

00016b2c <__eewr_block>:
   16b2c:	a0 e0       	ldi	r26, 0x00	; 0
   16b2e:	b0 e0       	ldi	r27, 0x00	; 0
   16b30:	ec e9       	ldi	r30, 0x9C	; 156
   16b32:	f5 eb       	ldi	r31, 0xB5	; 181
   16b34:	0c 94 e6 b8 	jmp	0x171cc	; 0x171cc <__prologue_saves__+0x14>
   16b38:	ec 01       	movw	r28, r24
   16b3a:	7b 01       	movw	r14, r22
   16b3c:	8a 01       	movw	r16, r20
   16b3e:	69 01       	movw	r12, r18
   16b40:	09 c0       	rjmp	.+18     	; 0x16b54 <__eewr_block+0x28>
   16b42:	ce 01       	movw	r24, r28
   16b44:	21 96       	adiw	r28, 0x01	; 1
   16b46:	f7 01       	movw	r30, r14
   16b48:	61 91       	ld	r22, Z+
   16b4a:	7f 01       	movw	r14, r30
   16b4c:	f6 01       	movw	r30, r12
   16b4e:	09 95       	icall
   16b50:	01 50       	subi	r16, 0x01	; 1
   16b52:	10 40       	sbci	r17, 0x00	; 0
   16b54:	01 15       	cp	r16, r1
   16b56:	11 05       	cpc	r17, r1
   16b58:	a1 f7       	brne	.-24     	; 0x16b42 <__eewr_block+0x16>
   16b5a:	cd b7       	in	r28, 0x3d	; 61
   16b5c:	de b7       	in	r29, 0x3e	; 62
   16b5e:	e8 e0       	ldi	r30, 0x08	; 8
   16b60:	0c 94 02 b9 	jmp	0x17204	; 0x17204 <__epilogue_restores__+0x14>

00016b64 <__mulhi_const_10>:
   16b64:	7a e0       	ldi	r23, 0x0A	; 10
   16b66:	97 9f       	mul	r25, r23
   16b68:	90 2d       	mov	r25, r0
   16b6a:	87 9f       	mul	r24, r23
   16b6c:	80 2d       	mov	r24, r0
   16b6e:	91 0d       	add	r25, r1
   16b70:	11 24       	eor	r1, r1
   16b72:	08 95       	ret

00016b74 <sprintf_P>:
   16b74:	ae e0       	ldi	r26, 0x0E	; 14
   16b76:	b0 e0       	ldi	r27, 0x00	; 0
   16b78:	e0 ec       	ldi	r30, 0xC0	; 192
   16b7a:	f5 eb       	ldi	r31, 0xB5	; 181
   16b7c:	0c 94 ea b8 	jmp	0x171d4	; 0x171d4 <__prologue_saves__+0x1c>
   16b80:	0d 89       	ldd	r16, Y+21	; 0x15
   16b82:	1e 89       	ldd	r17, Y+22	; 0x16
   16b84:	8e e0       	ldi	r24, 0x0E	; 14
   16b86:	8c 83       	std	Y+4, r24	; 0x04
   16b88:	1a 83       	std	Y+2, r17	; 0x02
   16b8a:	09 83       	std	Y+1, r16	; 0x01
   16b8c:	8f ef       	ldi	r24, 0xFF	; 255
   16b8e:	9f e7       	ldi	r25, 0x7F	; 127
   16b90:	9e 83       	std	Y+6, r25	; 0x06
   16b92:	8d 83       	std	Y+5, r24	; 0x05
   16b94:	9e 01       	movw	r18, r28
   16b96:	27 5e       	subi	r18, 0xE7	; 231
   16b98:	3f 4f       	sbci	r19, 0xFF	; 255
   16b9a:	ce 01       	movw	r24, r28
   16b9c:	01 96       	adiw	r24, 0x01	; 1
   16b9e:	6f 89       	ldd	r22, Y+23	; 0x17
   16ba0:	78 8d       	ldd	r23, Y+24	; 0x18
   16ba2:	a9 01       	movw	r20, r18
   16ba4:	0e 94 de b5 	call	0x16bbc	; 0x16bbc <vfprintf>
   16ba8:	2f 81       	ldd	r18, Y+7	; 0x07
   16baa:	38 85       	ldd	r19, Y+8	; 0x08
   16bac:	02 0f       	add	r16, r18
   16bae:	13 1f       	adc	r17, r19
   16bb0:	f8 01       	movw	r30, r16
   16bb2:	10 82       	st	Z, r1
   16bb4:	2e 96       	adiw	r28, 0x0e	; 14
   16bb6:	e4 e0       	ldi	r30, 0x04	; 4
   16bb8:	0c 94 06 b9 	jmp	0x1720c	; 0x1720c <__epilogue_restores__+0x1c>

00016bbc <vfprintf>:
   16bbc:	ab e0       	ldi	r26, 0x0B	; 11
   16bbe:	b0 e0       	ldi	r27, 0x00	; 0
   16bc0:	e4 ee       	ldi	r30, 0xE4	; 228
   16bc2:	f5 eb       	ldi	r31, 0xB5	; 181
   16bc4:	0c 94 dc b8 	jmp	0x171b8	; 0x171b8 <__prologue_saves__>
   16bc8:	3c 01       	movw	r6, r24
   16bca:	2b 01       	movw	r4, r22
   16bcc:	5a 01       	movw	r10, r20
   16bce:	fc 01       	movw	r30, r24
   16bd0:	17 82       	std	Z+7, r1	; 0x07
   16bd2:	16 82       	std	Z+6, r1	; 0x06
   16bd4:	83 81       	ldd	r24, Z+3	; 0x03
   16bd6:	81 fd       	sbrc	r24, 1
   16bd8:	03 c0       	rjmp	.+6      	; 0x16be0 <vfprintf+0x24>
   16bda:	6f ef       	ldi	r22, 0xFF	; 255
   16bdc:	7f ef       	ldi	r23, 0xFF	; 255
   16bde:	c6 c1       	rjmp	.+908    	; 0x16f6c <vfprintf+0x3b0>
   16be0:	9a e0       	ldi	r25, 0x0A	; 10
   16be2:	89 2e       	mov	r8, r25
   16be4:	1e 01       	movw	r2, r28
   16be6:	08 94       	sec
   16be8:	21 1c       	adc	r2, r1
   16bea:	31 1c       	adc	r3, r1
   16bec:	f3 01       	movw	r30, r6
   16bee:	23 81       	ldd	r18, Z+3	; 0x03
   16bf0:	f2 01       	movw	r30, r4
   16bf2:	23 fd       	sbrc	r18, 3
   16bf4:	85 91       	lpm	r24, Z+
   16bf6:	23 ff       	sbrs	r18, 3
   16bf8:	81 91       	ld	r24, Z+
   16bfa:	2f 01       	movw	r4, r30
   16bfc:	88 23       	and	r24, r24
   16bfe:	09 f4       	brne	.+2      	; 0x16c02 <vfprintf+0x46>
   16c00:	b2 c1       	rjmp	.+868    	; 0x16f66 <vfprintf+0x3aa>
   16c02:	85 32       	cpi	r24, 0x25	; 37
   16c04:	39 f4       	brne	.+14     	; 0x16c14 <vfprintf+0x58>
   16c06:	23 fd       	sbrc	r18, 3
   16c08:	85 91       	lpm	r24, Z+
   16c0a:	23 ff       	sbrs	r18, 3
   16c0c:	81 91       	ld	r24, Z+
   16c0e:	2f 01       	movw	r4, r30
   16c10:	85 32       	cpi	r24, 0x25	; 37
   16c12:	29 f4       	brne	.+10     	; 0x16c1e <vfprintf+0x62>
   16c14:	90 e0       	ldi	r25, 0x00	; 0
   16c16:	b3 01       	movw	r22, r6
   16c18:	0e 94 d1 b7 	call	0x16fa2	; 0x16fa2 <fputc>
   16c1c:	e7 cf       	rjmp	.-50     	; 0x16bec <vfprintf+0x30>
   16c1e:	98 2f       	mov	r25, r24
   16c20:	ff 24       	eor	r15, r15
   16c22:	ee 24       	eor	r14, r14
   16c24:	99 24       	eor	r9, r9
   16c26:	ff e1       	ldi	r31, 0x1F	; 31
   16c28:	ff 15       	cp	r31, r15
   16c2a:	d0 f0       	brcs	.+52     	; 0x16c60 <vfprintf+0xa4>
   16c2c:	9b 32       	cpi	r25, 0x2B	; 43
   16c2e:	69 f0       	breq	.+26     	; 0x16c4a <vfprintf+0x8e>
   16c30:	9c 32       	cpi	r25, 0x2C	; 44
   16c32:	28 f4       	brcc	.+10     	; 0x16c3e <vfprintf+0x82>
   16c34:	90 32       	cpi	r25, 0x20	; 32
   16c36:	59 f0       	breq	.+22     	; 0x16c4e <vfprintf+0x92>
   16c38:	93 32       	cpi	r25, 0x23	; 35
   16c3a:	91 f4       	brne	.+36     	; 0x16c60 <vfprintf+0xa4>
   16c3c:	0e c0       	rjmp	.+28     	; 0x16c5a <vfprintf+0x9e>
   16c3e:	9d 32       	cpi	r25, 0x2D	; 45
   16c40:	49 f0       	breq	.+18     	; 0x16c54 <vfprintf+0x98>
   16c42:	90 33       	cpi	r25, 0x30	; 48
   16c44:	69 f4       	brne	.+26     	; 0x16c60 <vfprintf+0xa4>
   16c46:	41 e0       	ldi	r20, 0x01	; 1
   16c48:	24 c0       	rjmp	.+72     	; 0x16c92 <vfprintf+0xd6>
   16c4a:	52 e0       	ldi	r21, 0x02	; 2
   16c4c:	f5 2a       	or	r15, r21
   16c4e:	84 e0       	ldi	r24, 0x04	; 4
   16c50:	f8 2a       	or	r15, r24
   16c52:	28 c0       	rjmp	.+80     	; 0x16ca4 <vfprintf+0xe8>
   16c54:	98 e0       	ldi	r25, 0x08	; 8
   16c56:	f9 2a       	or	r15, r25
   16c58:	25 c0       	rjmp	.+74     	; 0x16ca4 <vfprintf+0xe8>
   16c5a:	e0 e1       	ldi	r30, 0x10	; 16
   16c5c:	fe 2a       	or	r15, r30
   16c5e:	22 c0       	rjmp	.+68     	; 0x16ca4 <vfprintf+0xe8>
   16c60:	f7 fc       	sbrc	r15, 7
   16c62:	29 c0       	rjmp	.+82     	; 0x16cb6 <vfprintf+0xfa>
   16c64:	89 2f       	mov	r24, r25
   16c66:	80 53       	subi	r24, 0x30	; 48
   16c68:	8a 30       	cpi	r24, 0x0A	; 10
   16c6a:	70 f4       	brcc	.+28     	; 0x16c88 <vfprintf+0xcc>
   16c6c:	f6 fe       	sbrs	r15, 6
   16c6e:	05 c0       	rjmp	.+10     	; 0x16c7a <vfprintf+0xbe>
   16c70:	98 9c       	mul	r9, r8
   16c72:	90 2c       	mov	r9, r0
   16c74:	11 24       	eor	r1, r1
   16c76:	98 0e       	add	r9, r24
   16c78:	15 c0       	rjmp	.+42     	; 0x16ca4 <vfprintf+0xe8>
   16c7a:	e8 9c       	mul	r14, r8
   16c7c:	e0 2c       	mov	r14, r0
   16c7e:	11 24       	eor	r1, r1
   16c80:	e8 0e       	add	r14, r24
   16c82:	f0 e2       	ldi	r31, 0x20	; 32
   16c84:	ff 2a       	or	r15, r31
   16c86:	0e c0       	rjmp	.+28     	; 0x16ca4 <vfprintf+0xe8>
   16c88:	9e 32       	cpi	r25, 0x2E	; 46
   16c8a:	29 f4       	brne	.+10     	; 0x16c96 <vfprintf+0xda>
   16c8c:	f6 fc       	sbrc	r15, 6
   16c8e:	6b c1       	rjmp	.+726    	; 0x16f66 <vfprintf+0x3aa>
   16c90:	40 e4       	ldi	r20, 0x40	; 64
   16c92:	f4 2a       	or	r15, r20
   16c94:	07 c0       	rjmp	.+14     	; 0x16ca4 <vfprintf+0xe8>
   16c96:	9c 36       	cpi	r25, 0x6C	; 108
   16c98:	19 f4       	brne	.+6      	; 0x16ca0 <vfprintf+0xe4>
   16c9a:	50 e8       	ldi	r21, 0x80	; 128
   16c9c:	f5 2a       	or	r15, r21
   16c9e:	02 c0       	rjmp	.+4      	; 0x16ca4 <vfprintf+0xe8>
   16ca0:	98 36       	cpi	r25, 0x68	; 104
   16ca2:	49 f4       	brne	.+18     	; 0x16cb6 <vfprintf+0xfa>
   16ca4:	f2 01       	movw	r30, r4
   16ca6:	23 fd       	sbrc	r18, 3
   16ca8:	95 91       	lpm	r25, Z+
   16caa:	23 ff       	sbrs	r18, 3
   16cac:	91 91       	ld	r25, Z+
   16cae:	2f 01       	movw	r4, r30
   16cb0:	99 23       	and	r25, r25
   16cb2:	09 f0       	breq	.+2      	; 0x16cb6 <vfprintf+0xfa>
   16cb4:	b8 cf       	rjmp	.-144    	; 0x16c26 <vfprintf+0x6a>
   16cb6:	89 2f       	mov	r24, r25
   16cb8:	85 54       	subi	r24, 0x45	; 69
   16cba:	83 30       	cpi	r24, 0x03	; 3
   16cbc:	18 f0       	brcs	.+6      	; 0x16cc4 <vfprintf+0x108>
   16cbe:	80 52       	subi	r24, 0x20	; 32
   16cc0:	83 30       	cpi	r24, 0x03	; 3
   16cc2:	38 f4       	brcc	.+14     	; 0x16cd2 <vfprintf+0x116>
   16cc4:	44 e0       	ldi	r20, 0x04	; 4
   16cc6:	50 e0       	ldi	r21, 0x00	; 0
   16cc8:	a4 0e       	add	r10, r20
   16cca:	b5 1e       	adc	r11, r21
   16ccc:	5f e3       	ldi	r21, 0x3F	; 63
   16cce:	59 83       	std	Y+1, r21	; 0x01
   16cd0:	0f c0       	rjmp	.+30     	; 0x16cf0 <vfprintf+0x134>
   16cd2:	93 36       	cpi	r25, 0x63	; 99
   16cd4:	31 f0       	breq	.+12     	; 0x16ce2 <vfprintf+0x126>
   16cd6:	93 37       	cpi	r25, 0x73	; 115
   16cd8:	79 f0       	breq	.+30     	; 0x16cf8 <vfprintf+0x13c>
   16cda:	93 35       	cpi	r25, 0x53	; 83
   16cdc:	09 f0       	breq	.+2      	; 0x16ce0 <vfprintf+0x124>
   16cde:	56 c0       	rjmp	.+172    	; 0x16d8c <vfprintf+0x1d0>
   16ce0:	20 c0       	rjmp	.+64     	; 0x16d22 <vfprintf+0x166>
   16ce2:	f5 01       	movw	r30, r10
   16ce4:	80 81       	ld	r24, Z
   16ce6:	89 83       	std	Y+1, r24	; 0x01
   16ce8:	42 e0       	ldi	r20, 0x02	; 2
   16cea:	50 e0       	ldi	r21, 0x00	; 0
   16cec:	a4 0e       	add	r10, r20
   16cee:	b5 1e       	adc	r11, r21
   16cf0:	61 01       	movw	r12, r2
   16cf2:	01 e0       	ldi	r16, 0x01	; 1
   16cf4:	10 e0       	ldi	r17, 0x00	; 0
   16cf6:	12 c0       	rjmp	.+36     	; 0x16d1c <vfprintf+0x160>
   16cf8:	f5 01       	movw	r30, r10
   16cfa:	c0 80       	ld	r12, Z
   16cfc:	d1 80       	ldd	r13, Z+1	; 0x01
   16cfe:	f6 fc       	sbrc	r15, 6
   16d00:	03 c0       	rjmp	.+6      	; 0x16d08 <vfprintf+0x14c>
   16d02:	6f ef       	ldi	r22, 0xFF	; 255
   16d04:	7f ef       	ldi	r23, 0xFF	; 255
   16d06:	02 c0       	rjmp	.+4      	; 0x16d0c <vfprintf+0x150>
   16d08:	69 2d       	mov	r22, r9
   16d0a:	70 e0       	ldi	r23, 0x00	; 0
   16d0c:	42 e0       	ldi	r20, 0x02	; 2
   16d0e:	50 e0       	ldi	r21, 0x00	; 0
   16d10:	a4 0e       	add	r10, r20
   16d12:	b5 1e       	adc	r11, r21
   16d14:	c6 01       	movw	r24, r12
   16d16:	0e 94 c6 b7 	call	0x16f8c	; 0x16f8c <strnlen>
   16d1a:	8c 01       	movw	r16, r24
   16d1c:	5f e7       	ldi	r21, 0x7F	; 127
   16d1e:	f5 22       	and	r15, r21
   16d20:	14 c0       	rjmp	.+40     	; 0x16d4a <vfprintf+0x18e>
   16d22:	f5 01       	movw	r30, r10
   16d24:	c0 80       	ld	r12, Z
   16d26:	d1 80       	ldd	r13, Z+1	; 0x01
   16d28:	f6 fc       	sbrc	r15, 6
   16d2a:	03 c0       	rjmp	.+6      	; 0x16d32 <vfprintf+0x176>
   16d2c:	6f ef       	ldi	r22, 0xFF	; 255
   16d2e:	7f ef       	ldi	r23, 0xFF	; 255
   16d30:	02 c0       	rjmp	.+4      	; 0x16d36 <vfprintf+0x17a>
   16d32:	69 2d       	mov	r22, r9
   16d34:	70 e0       	ldi	r23, 0x00	; 0
   16d36:	42 e0       	ldi	r20, 0x02	; 2
   16d38:	50 e0       	ldi	r21, 0x00	; 0
   16d3a:	a4 0e       	add	r10, r20
   16d3c:	b5 1e       	adc	r11, r21
   16d3e:	c6 01       	movw	r24, r12
   16d40:	0e 94 bb b7 	call	0x16f76	; 0x16f76 <strnlen_P>
   16d44:	8c 01       	movw	r16, r24
   16d46:	50 e8       	ldi	r21, 0x80	; 128
   16d48:	f5 2a       	or	r15, r21
   16d4a:	f3 fe       	sbrs	r15, 3
   16d4c:	07 c0       	rjmp	.+14     	; 0x16d5c <vfprintf+0x1a0>
   16d4e:	1a c0       	rjmp	.+52     	; 0x16d84 <vfprintf+0x1c8>
   16d50:	80 e2       	ldi	r24, 0x20	; 32
   16d52:	90 e0       	ldi	r25, 0x00	; 0
   16d54:	b3 01       	movw	r22, r6
   16d56:	0e 94 d1 b7 	call	0x16fa2	; 0x16fa2 <fputc>
   16d5a:	ea 94       	dec	r14
   16d5c:	8e 2d       	mov	r24, r14
   16d5e:	90 e0       	ldi	r25, 0x00	; 0
   16d60:	08 17       	cp	r16, r24
   16d62:	19 07       	cpc	r17, r25
   16d64:	a8 f3       	brcs	.-22     	; 0x16d50 <vfprintf+0x194>
   16d66:	0e c0       	rjmp	.+28     	; 0x16d84 <vfprintf+0x1c8>
   16d68:	f6 01       	movw	r30, r12
   16d6a:	f7 fc       	sbrc	r15, 7
   16d6c:	85 91       	lpm	r24, Z+
   16d6e:	f7 fe       	sbrs	r15, 7
   16d70:	81 91       	ld	r24, Z+
   16d72:	6f 01       	movw	r12, r30
   16d74:	90 e0       	ldi	r25, 0x00	; 0
   16d76:	b3 01       	movw	r22, r6
   16d78:	0e 94 d1 b7 	call	0x16fa2	; 0x16fa2 <fputc>
   16d7c:	e1 10       	cpse	r14, r1
   16d7e:	ea 94       	dec	r14
   16d80:	01 50       	subi	r16, 0x01	; 1
   16d82:	10 40       	sbci	r17, 0x00	; 0
   16d84:	01 15       	cp	r16, r1
   16d86:	11 05       	cpc	r17, r1
   16d88:	79 f7       	brne	.-34     	; 0x16d68 <vfprintf+0x1ac>
   16d8a:	ea c0       	rjmp	.+468    	; 0x16f60 <vfprintf+0x3a4>
   16d8c:	94 36       	cpi	r25, 0x64	; 100
   16d8e:	11 f0       	breq	.+4      	; 0x16d94 <vfprintf+0x1d8>
   16d90:	99 36       	cpi	r25, 0x69	; 105
   16d92:	69 f5       	brne	.+90     	; 0x16dee <vfprintf+0x232>
   16d94:	f7 fe       	sbrs	r15, 7
   16d96:	08 c0       	rjmp	.+16     	; 0x16da8 <vfprintf+0x1ec>
   16d98:	f5 01       	movw	r30, r10
   16d9a:	20 81       	ld	r18, Z
   16d9c:	31 81       	ldd	r19, Z+1	; 0x01
   16d9e:	42 81       	ldd	r20, Z+2	; 0x02
   16da0:	53 81       	ldd	r21, Z+3	; 0x03
   16da2:	84 e0       	ldi	r24, 0x04	; 4
   16da4:	90 e0       	ldi	r25, 0x00	; 0
   16da6:	0a c0       	rjmp	.+20     	; 0x16dbc <vfprintf+0x200>
   16da8:	f5 01       	movw	r30, r10
   16daa:	80 81       	ld	r24, Z
   16dac:	91 81       	ldd	r25, Z+1	; 0x01
   16dae:	9c 01       	movw	r18, r24
   16db0:	44 27       	eor	r20, r20
   16db2:	37 fd       	sbrc	r19, 7
   16db4:	40 95       	com	r20
   16db6:	54 2f       	mov	r21, r20
   16db8:	82 e0       	ldi	r24, 0x02	; 2
   16dba:	90 e0       	ldi	r25, 0x00	; 0
   16dbc:	a8 0e       	add	r10, r24
   16dbe:	b9 1e       	adc	r11, r25
   16dc0:	9f e6       	ldi	r25, 0x6F	; 111
   16dc2:	f9 22       	and	r15, r25
   16dc4:	57 ff       	sbrs	r21, 7
   16dc6:	09 c0       	rjmp	.+18     	; 0x16dda <vfprintf+0x21e>
   16dc8:	50 95       	com	r21
   16dca:	40 95       	com	r20
   16dcc:	30 95       	com	r19
   16dce:	21 95       	neg	r18
   16dd0:	3f 4f       	sbci	r19, 0xFF	; 255
   16dd2:	4f 4f       	sbci	r20, 0xFF	; 255
   16dd4:	5f 4f       	sbci	r21, 0xFF	; 255
   16dd6:	e0 e8       	ldi	r30, 0x80	; 128
   16dd8:	fe 2a       	or	r15, r30
   16dda:	ca 01       	movw	r24, r20
   16ddc:	b9 01       	movw	r22, r18
   16dde:	a1 01       	movw	r20, r2
   16de0:	2a e0       	ldi	r18, 0x0A	; 10
   16de2:	30 e0       	ldi	r19, 0x00	; 0
   16de4:	0e 94 fd b7 	call	0x16ffa	; 0x16ffa <__ultoa_invert>
   16de8:	d8 2e       	mov	r13, r24
   16dea:	d2 18       	sub	r13, r2
   16dec:	40 c0       	rjmp	.+128    	; 0x16e6e <vfprintf+0x2b2>
   16dee:	95 37       	cpi	r25, 0x75	; 117
   16df0:	29 f4       	brne	.+10     	; 0x16dfc <vfprintf+0x240>
   16df2:	1f 2d       	mov	r17, r15
   16df4:	1f 7e       	andi	r17, 0xEF	; 239
   16df6:	2a e0       	ldi	r18, 0x0A	; 10
   16df8:	30 e0       	ldi	r19, 0x00	; 0
   16dfa:	1d c0       	rjmp	.+58     	; 0x16e36 <vfprintf+0x27a>
   16dfc:	1f 2d       	mov	r17, r15
   16dfe:	19 7f       	andi	r17, 0xF9	; 249
   16e00:	9f 36       	cpi	r25, 0x6F	; 111
   16e02:	61 f0       	breq	.+24     	; 0x16e1c <vfprintf+0x260>
   16e04:	90 37       	cpi	r25, 0x70	; 112
   16e06:	20 f4       	brcc	.+8      	; 0x16e10 <vfprintf+0x254>
   16e08:	98 35       	cpi	r25, 0x58	; 88
   16e0a:	09 f0       	breq	.+2      	; 0x16e0e <vfprintf+0x252>
   16e0c:	ac c0       	rjmp	.+344    	; 0x16f66 <vfprintf+0x3aa>
   16e0e:	0f c0       	rjmp	.+30     	; 0x16e2e <vfprintf+0x272>
   16e10:	90 37       	cpi	r25, 0x70	; 112
   16e12:	39 f0       	breq	.+14     	; 0x16e22 <vfprintf+0x266>
   16e14:	98 37       	cpi	r25, 0x78	; 120
   16e16:	09 f0       	breq	.+2      	; 0x16e1a <vfprintf+0x25e>
   16e18:	a6 c0       	rjmp	.+332    	; 0x16f66 <vfprintf+0x3aa>
   16e1a:	04 c0       	rjmp	.+8      	; 0x16e24 <vfprintf+0x268>
   16e1c:	28 e0       	ldi	r18, 0x08	; 8
   16e1e:	30 e0       	ldi	r19, 0x00	; 0
   16e20:	0a c0       	rjmp	.+20     	; 0x16e36 <vfprintf+0x27a>
   16e22:	10 61       	ori	r17, 0x10	; 16
   16e24:	14 fd       	sbrc	r17, 4
   16e26:	14 60       	ori	r17, 0x04	; 4
   16e28:	20 e1       	ldi	r18, 0x10	; 16
   16e2a:	30 e0       	ldi	r19, 0x00	; 0
   16e2c:	04 c0       	rjmp	.+8      	; 0x16e36 <vfprintf+0x27a>
   16e2e:	14 fd       	sbrc	r17, 4
   16e30:	16 60       	ori	r17, 0x06	; 6
   16e32:	20 e1       	ldi	r18, 0x10	; 16
   16e34:	32 e0       	ldi	r19, 0x02	; 2
   16e36:	17 ff       	sbrs	r17, 7
   16e38:	08 c0       	rjmp	.+16     	; 0x16e4a <vfprintf+0x28e>
   16e3a:	f5 01       	movw	r30, r10
   16e3c:	60 81       	ld	r22, Z
   16e3e:	71 81       	ldd	r23, Z+1	; 0x01
   16e40:	82 81       	ldd	r24, Z+2	; 0x02
   16e42:	93 81       	ldd	r25, Z+3	; 0x03
   16e44:	44 e0       	ldi	r20, 0x04	; 4
   16e46:	50 e0       	ldi	r21, 0x00	; 0
   16e48:	08 c0       	rjmp	.+16     	; 0x16e5a <vfprintf+0x29e>
   16e4a:	f5 01       	movw	r30, r10
   16e4c:	80 81       	ld	r24, Z
   16e4e:	91 81       	ldd	r25, Z+1	; 0x01
   16e50:	bc 01       	movw	r22, r24
   16e52:	80 e0       	ldi	r24, 0x00	; 0
   16e54:	90 e0       	ldi	r25, 0x00	; 0
   16e56:	42 e0       	ldi	r20, 0x02	; 2
   16e58:	50 e0       	ldi	r21, 0x00	; 0
   16e5a:	a4 0e       	add	r10, r20
   16e5c:	b5 1e       	adc	r11, r21
   16e5e:	a1 01       	movw	r20, r2
   16e60:	0e 94 fd b7 	call	0x16ffa	; 0x16ffa <__ultoa_invert>
   16e64:	d8 2e       	mov	r13, r24
   16e66:	d2 18       	sub	r13, r2
   16e68:	8f e7       	ldi	r24, 0x7F	; 127
   16e6a:	f8 2e       	mov	r15, r24
   16e6c:	f1 22       	and	r15, r17
   16e6e:	f6 fe       	sbrs	r15, 6
   16e70:	0b c0       	rjmp	.+22     	; 0x16e88 <vfprintf+0x2cc>
   16e72:	5e ef       	ldi	r21, 0xFE	; 254
   16e74:	f5 22       	and	r15, r21
   16e76:	d9 14       	cp	r13, r9
   16e78:	38 f4       	brcc	.+14     	; 0x16e88 <vfprintf+0x2cc>
   16e7a:	f4 fe       	sbrs	r15, 4
   16e7c:	07 c0       	rjmp	.+14     	; 0x16e8c <vfprintf+0x2d0>
   16e7e:	f2 fc       	sbrc	r15, 2
   16e80:	05 c0       	rjmp	.+10     	; 0x16e8c <vfprintf+0x2d0>
   16e82:	8f ee       	ldi	r24, 0xEF	; 239
   16e84:	f8 22       	and	r15, r24
   16e86:	02 c0       	rjmp	.+4      	; 0x16e8c <vfprintf+0x2d0>
   16e88:	1d 2d       	mov	r17, r13
   16e8a:	01 c0       	rjmp	.+2      	; 0x16e8e <vfprintf+0x2d2>
   16e8c:	19 2d       	mov	r17, r9
   16e8e:	f4 fe       	sbrs	r15, 4
   16e90:	0d c0       	rjmp	.+26     	; 0x16eac <vfprintf+0x2f0>
   16e92:	fe 01       	movw	r30, r28
   16e94:	ed 0d       	add	r30, r13
   16e96:	f1 1d       	adc	r31, r1
   16e98:	80 81       	ld	r24, Z
   16e9a:	80 33       	cpi	r24, 0x30	; 48
   16e9c:	19 f4       	brne	.+6      	; 0x16ea4 <vfprintf+0x2e8>
   16e9e:	99 ee       	ldi	r25, 0xE9	; 233
   16ea0:	f9 22       	and	r15, r25
   16ea2:	08 c0       	rjmp	.+16     	; 0x16eb4 <vfprintf+0x2f8>
   16ea4:	1f 5f       	subi	r17, 0xFF	; 255
   16ea6:	f2 fe       	sbrs	r15, 2
   16ea8:	05 c0       	rjmp	.+10     	; 0x16eb4 <vfprintf+0x2f8>
   16eaa:	03 c0       	rjmp	.+6      	; 0x16eb2 <vfprintf+0x2f6>
   16eac:	8f 2d       	mov	r24, r15
   16eae:	86 78       	andi	r24, 0x86	; 134
   16eb0:	09 f0       	breq	.+2      	; 0x16eb4 <vfprintf+0x2f8>
   16eb2:	1f 5f       	subi	r17, 0xFF	; 255
   16eb4:	0f 2d       	mov	r16, r15
   16eb6:	f3 fc       	sbrc	r15, 3
   16eb8:	14 c0       	rjmp	.+40     	; 0x16ee2 <vfprintf+0x326>
   16eba:	f0 fe       	sbrs	r15, 0
   16ebc:	0f c0       	rjmp	.+30     	; 0x16edc <vfprintf+0x320>
   16ebe:	1e 15       	cp	r17, r14
   16ec0:	10 f0       	brcs	.+4      	; 0x16ec6 <vfprintf+0x30a>
   16ec2:	9d 2c       	mov	r9, r13
   16ec4:	0b c0       	rjmp	.+22     	; 0x16edc <vfprintf+0x320>
   16ec6:	9d 2c       	mov	r9, r13
   16ec8:	9e 0c       	add	r9, r14
   16eca:	91 1a       	sub	r9, r17
   16ecc:	1e 2d       	mov	r17, r14
   16ece:	06 c0       	rjmp	.+12     	; 0x16edc <vfprintf+0x320>
   16ed0:	80 e2       	ldi	r24, 0x20	; 32
   16ed2:	90 e0       	ldi	r25, 0x00	; 0
   16ed4:	b3 01       	movw	r22, r6
   16ed6:	0e 94 d1 b7 	call	0x16fa2	; 0x16fa2 <fputc>
   16eda:	1f 5f       	subi	r17, 0xFF	; 255
   16edc:	1e 15       	cp	r17, r14
   16ede:	c0 f3       	brcs	.-16     	; 0x16ed0 <vfprintf+0x314>
   16ee0:	04 c0       	rjmp	.+8      	; 0x16eea <vfprintf+0x32e>
   16ee2:	1e 15       	cp	r17, r14
   16ee4:	10 f4       	brcc	.+4      	; 0x16eea <vfprintf+0x32e>
   16ee6:	e1 1a       	sub	r14, r17
   16ee8:	01 c0       	rjmp	.+2      	; 0x16eec <vfprintf+0x330>
   16eea:	ee 24       	eor	r14, r14
   16eec:	04 ff       	sbrs	r16, 4
   16eee:	0f c0       	rjmp	.+30     	; 0x16f0e <vfprintf+0x352>
   16ef0:	80 e3       	ldi	r24, 0x30	; 48
   16ef2:	90 e0       	ldi	r25, 0x00	; 0
   16ef4:	b3 01       	movw	r22, r6
   16ef6:	0e 94 d1 b7 	call	0x16fa2	; 0x16fa2 <fputc>
   16efa:	02 ff       	sbrs	r16, 2
   16efc:	1d c0       	rjmp	.+58     	; 0x16f38 <vfprintf+0x37c>
   16efe:	01 fd       	sbrc	r16, 1
   16f00:	03 c0       	rjmp	.+6      	; 0x16f08 <vfprintf+0x34c>
   16f02:	88 e7       	ldi	r24, 0x78	; 120
   16f04:	90 e0       	ldi	r25, 0x00	; 0
   16f06:	0e c0       	rjmp	.+28     	; 0x16f24 <vfprintf+0x368>
   16f08:	88 e5       	ldi	r24, 0x58	; 88
   16f0a:	90 e0       	ldi	r25, 0x00	; 0
   16f0c:	0b c0       	rjmp	.+22     	; 0x16f24 <vfprintf+0x368>
   16f0e:	80 2f       	mov	r24, r16
   16f10:	86 78       	andi	r24, 0x86	; 134
   16f12:	91 f0       	breq	.+36     	; 0x16f38 <vfprintf+0x37c>
   16f14:	01 ff       	sbrs	r16, 1
   16f16:	02 c0       	rjmp	.+4      	; 0x16f1c <vfprintf+0x360>
   16f18:	8b e2       	ldi	r24, 0x2B	; 43
   16f1a:	01 c0       	rjmp	.+2      	; 0x16f1e <vfprintf+0x362>
   16f1c:	80 e2       	ldi	r24, 0x20	; 32
   16f1e:	f7 fc       	sbrc	r15, 7
   16f20:	8d e2       	ldi	r24, 0x2D	; 45
   16f22:	90 e0       	ldi	r25, 0x00	; 0
   16f24:	b3 01       	movw	r22, r6
   16f26:	0e 94 d1 b7 	call	0x16fa2	; 0x16fa2 <fputc>
   16f2a:	06 c0       	rjmp	.+12     	; 0x16f38 <vfprintf+0x37c>
   16f2c:	80 e3       	ldi	r24, 0x30	; 48
   16f2e:	90 e0       	ldi	r25, 0x00	; 0
   16f30:	b3 01       	movw	r22, r6
   16f32:	0e 94 d1 b7 	call	0x16fa2	; 0x16fa2 <fputc>
   16f36:	9a 94       	dec	r9
   16f38:	d9 14       	cp	r13, r9
   16f3a:	c0 f3       	brcs	.-16     	; 0x16f2c <vfprintf+0x370>
   16f3c:	da 94       	dec	r13
   16f3e:	f1 01       	movw	r30, r2
   16f40:	ed 0d       	add	r30, r13
   16f42:	f1 1d       	adc	r31, r1
   16f44:	80 81       	ld	r24, Z
   16f46:	90 e0       	ldi	r25, 0x00	; 0
   16f48:	b3 01       	movw	r22, r6
   16f4a:	0e 94 d1 b7 	call	0x16fa2	; 0x16fa2 <fputc>
   16f4e:	dd 20       	and	r13, r13
   16f50:	a9 f7       	brne	.-22     	; 0x16f3c <vfprintf+0x380>
   16f52:	06 c0       	rjmp	.+12     	; 0x16f60 <vfprintf+0x3a4>
   16f54:	80 e2       	ldi	r24, 0x20	; 32
   16f56:	90 e0       	ldi	r25, 0x00	; 0
   16f58:	b3 01       	movw	r22, r6
   16f5a:	0e 94 d1 b7 	call	0x16fa2	; 0x16fa2 <fputc>
   16f5e:	ea 94       	dec	r14
   16f60:	ee 20       	and	r14, r14
   16f62:	c1 f7       	brne	.-16     	; 0x16f54 <vfprintf+0x398>
   16f64:	43 ce       	rjmp	.-890    	; 0x16bec <vfprintf+0x30>
   16f66:	f3 01       	movw	r30, r6
   16f68:	66 81       	ldd	r22, Z+6	; 0x06
   16f6a:	77 81       	ldd	r23, Z+7	; 0x07
   16f6c:	cb 01       	movw	r24, r22
   16f6e:	2b 96       	adiw	r28, 0x0b	; 11
   16f70:	e2 e1       	ldi	r30, 0x12	; 18
   16f72:	0c 94 f8 b8 	jmp	0x171f0	; 0x171f0 <__epilogue_restores__>

00016f76 <strnlen_P>:
   16f76:	fc 01       	movw	r30, r24
   16f78:	05 90       	lpm	r0, Z+
   16f7a:	61 50       	subi	r22, 0x01	; 1
   16f7c:	70 40       	sbci	r23, 0x00	; 0
   16f7e:	01 10       	cpse	r0, r1
   16f80:	d8 f7       	brcc	.-10     	; 0x16f78 <strnlen_P+0x2>
   16f82:	80 95       	com	r24
   16f84:	90 95       	com	r25
   16f86:	8e 0f       	add	r24, r30
   16f88:	9f 1f       	adc	r25, r31
   16f8a:	08 95       	ret

00016f8c <strnlen>:
   16f8c:	fc 01       	movw	r30, r24
   16f8e:	61 50       	subi	r22, 0x01	; 1
   16f90:	70 40       	sbci	r23, 0x00	; 0
   16f92:	01 90       	ld	r0, Z+
   16f94:	01 10       	cpse	r0, r1
   16f96:	d8 f7       	brcc	.-10     	; 0x16f8e <strnlen+0x2>
   16f98:	80 95       	com	r24
   16f9a:	90 95       	com	r25
   16f9c:	8e 0f       	add	r24, r30
   16f9e:	9f 1f       	adc	r25, r31
   16fa0:	08 95       	ret

00016fa2 <fputc>:
   16fa2:	0f 93       	push	r16
   16fa4:	1f 93       	push	r17
   16fa6:	cf 93       	push	r28
   16fa8:	df 93       	push	r29
   16faa:	8c 01       	movw	r16, r24
   16fac:	eb 01       	movw	r28, r22
   16fae:	8b 81       	ldd	r24, Y+3	; 0x03
   16fb0:	81 ff       	sbrs	r24, 1
   16fb2:	1b c0       	rjmp	.+54     	; 0x16fea <fputc+0x48>
   16fb4:	82 ff       	sbrs	r24, 2
   16fb6:	0d c0       	rjmp	.+26     	; 0x16fd2 <fputc+0x30>
   16fb8:	2e 81       	ldd	r18, Y+6	; 0x06
   16fba:	3f 81       	ldd	r19, Y+7	; 0x07
   16fbc:	8c 81       	ldd	r24, Y+4	; 0x04
   16fbe:	9d 81       	ldd	r25, Y+5	; 0x05
   16fc0:	28 17       	cp	r18, r24
   16fc2:	39 07       	cpc	r19, r25
   16fc4:	64 f4       	brge	.+24     	; 0x16fde <fputc+0x3c>
   16fc6:	e8 81       	ld	r30, Y
   16fc8:	f9 81       	ldd	r31, Y+1	; 0x01
   16fca:	01 93       	st	Z+, r16
   16fcc:	f9 83       	std	Y+1, r31	; 0x01
   16fce:	e8 83       	st	Y, r30
   16fd0:	06 c0       	rjmp	.+12     	; 0x16fde <fputc+0x3c>
   16fd2:	e8 85       	ldd	r30, Y+8	; 0x08
   16fd4:	f9 85       	ldd	r31, Y+9	; 0x09
   16fd6:	80 2f       	mov	r24, r16
   16fd8:	09 95       	icall
   16fda:	89 2b       	or	r24, r25
   16fdc:	31 f4       	brne	.+12     	; 0x16fea <fputc+0x48>
   16fde:	8e 81       	ldd	r24, Y+6	; 0x06
   16fe0:	9f 81       	ldd	r25, Y+7	; 0x07
   16fe2:	01 96       	adiw	r24, 0x01	; 1
   16fe4:	9f 83       	std	Y+7, r25	; 0x07
   16fe6:	8e 83       	std	Y+6, r24	; 0x06
   16fe8:	02 c0       	rjmp	.+4      	; 0x16fee <fputc+0x4c>
   16fea:	0f ef       	ldi	r16, 0xFF	; 255
   16fec:	1f ef       	ldi	r17, 0xFF	; 255
   16fee:	c8 01       	movw	r24, r16
   16ff0:	df 91       	pop	r29
   16ff2:	cf 91       	pop	r28
   16ff4:	1f 91       	pop	r17
   16ff6:	0f 91       	pop	r16
   16ff8:	08 95       	ret

00016ffa <__ultoa_invert>:
   16ffa:	fa 01       	movw	r30, r20
   16ffc:	aa 27       	eor	r26, r26
   16ffe:	28 30       	cpi	r18, 0x08	; 8
   17000:	51 f1       	breq	.+84     	; 0x17056 <__ultoa_invert+0x5c>
   17002:	20 31       	cpi	r18, 0x10	; 16
   17004:	81 f1       	breq	.+96     	; 0x17066 <__ultoa_invert+0x6c>
   17006:	e8 94       	clt
   17008:	6f 93       	push	r22
   1700a:	6e 7f       	andi	r22, 0xFE	; 254
   1700c:	6e 5f       	subi	r22, 0xFE	; 254
   1700e:	7f 4f       	sbci	r23, 0xFF	; 255
   17010:	8f 4f       	sbci	r24, 0xFF	; 255
   17012:	9f 4f       	sbci	r25, 0xFF	; 255
   17014:	af 4f       	sbci	r26, 0xFF	; 255
   17016:	b1 e0       	ldi	r27, 0x01	; 1
   17018:	3e d0       	rcall	.+124    	; 0x17096 <__ultoa_invert+0x9c>
   1701a:	b4 e0       	ldi	r27, 0x04	; 4
   1701c:	3c d0       	rcall	.+120    	; 0x17096 <__ultoa_invert+0x9c>
   1701e:	67 0f       	add	r22, r23
   17020:	78 1f       	adc	r23, r24
   17022:	89 1f       	adc	r24, r25
   17024:	9a 1f       	adc	r25, r26
   17026:	a1 1d       	adc	r26, r1
   17028:	68 0f       	add	r22, r24
   1702a:	79 1f       	adc	r23, r25
   1702c:	8a 1f       	adc	r24, r26
   1702e:	91 1d       	adc	r25, r1
   17030:	a1 1d       	adc	r26, r1
   17032:	6a 0f       	add	r22, r26
   17034:	71 1d       	adc	r23, r1
   17036:	81 1d       	adc	r24, r1
   17038:	91 1d       	adc	r25, r1
   1703a:	a1 1d       	adc	r26, r1
   1703c:	20 d0       	rcall	.+64     	; 0x1707e <__ultoa_invert+0x84>
   1703e:	09 f4       	brne	.+2      	; 0x17042 <__ultoa_invert+0x48>
   17040:	68 94       	set
   17042:	3f 91       	pop	r19
   17044:	2a e0       	ldi	r18, 0x0A	; 10
   17046:	26 9f       	mul	r18, r22
   17048:	11 24       	eor	r1, r1
   1704a:	30 19       	sub	r19, r0
   1704c:	30 5d       	subi	r19, 0xD0	; 208
   1704e:	31 93       	st	Z+, r19
   17050:	de f6       	brtc	.-74     	; 0x17008 <__ultoa_invert+0xe>
   17052:	cf 01       	movw	r24, r30
   17054:	08 95       	ret
   17056:	46 2f       	mov	r20, r22
   17058:	47 70       	andi	r20, 0x07	; 7
   1705a:	40 5d       	subi	r20, 0xD0	; 208
   1705c:	41 93       	st	Z+, r20
   1705e:	b3 e0       	ldi	r27, 0x03	; 3
   17060:	0f d0       	rcall	.+30     	; 0x17080 <__ultoa_invert+0x86>
   17062:	c9 f7       	brne	.-14     	; 0x17056 <__ultoa_invert+0x5c>
   17064:	f6 cf       	rjmp	.-20     	; 0x17052 <__ultoa_invert+0x58>
   17066:	46 2f       	mov	r20, r22
   17068:	4f 70       	andi	r20, 0x0F	; 15
   1706a:	40 5d       	subi	r20, 0xD0	; 208
   1706c:	4a 33       	cpi	r20, 0x3A	; 58
   1706e:	18 f0       	brcs	.+6      	; 0x17076 <__ultoa_invert+0x7c>
   17070:	49 5d       	subi	r20, 0xD9	; 217
   17072:	31 fd       	sbrc	r19, 1
   17074:	40 52       	subi	r20, 0x20	; 32
   17076:	41 93       	st	Z+, r20
   17078:	02 d0       	rcall	.+4      	; 0x1707e <__ultoa_invert+0x84>
   1707a:	a9 f7       	brne	.-22     	; 0x17066 <__ultoa_invert+0x6c>
   1707c:	ea cf       	rjmp	.-44     	; 0x17052 <__ultoa_invert+0x58>
   1707e:	b4 e0       	ldi	r27, 0x04	; 4
   17080:	a6 95       	lsr	r26
   17082:	97 95       	ror	r25
   17084:	87 95       	ror	r24
   17086:	77 95       	ror	r23
   17088:	67 95       	ror	r22
   1708a:	ba 95       	dec	r27
   1708c:	c9 f7       	brne	.-14     	; 0x17080 <__ultoa_invert+0x86>
   1708e:	00 97       	sbiw	r24, 0x00	; 0
   17090:	61 05       	cpc	r22, r1
   17092:	71 05       	cpc	r23, r1
   17094:	08 95       	ret
   17096:	9b 01       	movw	r18, r22
   17098:	ac 01       	movw	r20, r24
   1709a:	0a 2e       	mov	r0, r26
   1709c:	06 94       	lsr	r0
   1709e:	57 95       	ror	r21
   170a0:	47 95       	ror	r20
   170a2:	37 95       	ror	r19
   170a4:	27 95       	ror	r18
   170a6:	ba 95       	dec	r27
   170a8:	c9 f7       	brne	.-14     	; 0x1709c <__ultoa_invert+0xa2>
   170aa:	62 0f       	add	r22, r18
   170ac:	73 1f       	adc	r23, r19
   170ae:	84 1f       	adc	r24, r20
   170b0:	95 1f       	adc	r25, r21
   170b2:	a0 1d       	adc	r26, r0
   170b4:	08 95       	ret

000170b6 <__mulsi3>:
   170b6:	62 9f       	mul	r22, r18
   170b8:	d0 01       	movw	r26, r0
   170ba:	73 9f       	mul	r23, r19
   170bc:	f0 01       	movw	r30, r0
   170be:	82 9f       	mul	r24, r18
   170c0:	e0 0d       	add	r30, r0
   170c2:	f1 1d       	adc	r31, r1
   170c4:	64 9f       	mul	r22, r20
   170c6:	e0 0d       	add	r30, r0
   170c8:	f1 1d       	adc	r31, r1
   170ca:	92 9f       	mul	r25, r18
   170cc:	f0 0d       	add	r31, r0
   170ce:	83 9f       	mul	r24, r19
   170d0:	f0 0d       	add	r31, r0
   170d2:	74 9f       	mul	r23, r20
   170d4:	f0 0d       	add	r31, r0
   170d6:	65 9f       	mul	r22, r21
   170d8:	f0 0d       	add	r31, r0
   170da:	99 27       	eor	r25, r25
   170dc:	72 9f       	mul	r23, r18
   170de:	b0 0d       	add	r27, r0
   170e0:	e1 1d       	adc	r30, r1
   170e2:	f9 1f       	adc	r31, r25
   170e4:	63 9f       	mul	r22, r19
   170e6:	b0 0d       	add	r27, r0
   170e8:	e1 1d       	adc	r30, r1
   170ea:	f9 1f       	adc	r31, r25
   170ec:	bd 01       	movw	r22, r26
   170ee:	cf 01       	movw	r24, r30
   170f0:	11 24       	eor	r1, r1
   170f2:	08 95       	ret

000170f4 <__udivmodqi4>:
   170f4:	99 1b       	sub	r25, r25
   170f6:	79 e0       	ldi	r23, 0x09	; 9
   170f8:	04 c0       	rjmp	.+8      	; 0x17102 <__udivmodqi4_ep>

000170fa <__udivmodqi4_loop>:
   170fa:	99 1f       	adc	r25, r25
   170fc:	96 17       	cp	r25, r22
   170fe:	08 f0       	brcs	.+2      	; 0x17102 <__udivmodqi4_ep>
   17100:	96 1b       	sub	r25, r22

00017102 <__udivmodqi4_ep>:
   17102:	88 1f       	adc	r24, r24
   17104:	7a 95       	dec	r23
   17106:	c9 f7       	brne	.-14     	; 0x170fa <__udivmodqi4_loop>
   17108:	80 95       	com	r24
   1710a:	08 95       	ret

0001710c <__divmodqi4>:
   1710c:	87 fb       	bst	r24, 7
   1710e:	08 2e       	mov	r0, r24
   17110:	06 26       	eor	r0, r22
   17112:	87 fd       	sbrc	r24, 7
   17114:	81 95       	neg	r24
   17116:	67 fd       	sbrc	r22, 7
   17118:	61 95       	neg	r22
   1711a:	ec df       	rcall	.-40     	; 0x170f4 <__udivmodqi4>
   1711c:	0e f4       	brtc	.+2      	; 0x17120 <__divmodqi4_1>
   1711e:	91 95       	neg	r25

00017120 <__divmodqi4_1>:
   17120:	07 fc       	sbrc	r0, 7
   17122:	81 95       	neg	r24

00017124 <__divmodqi4_exit>:
   17124:	08 95       	ret

00017126 <__udivmodhi4>:
   17126:	aa 1b       	sub	r26, r26
   17128:	bb 1b       	sub	r27, r27
   1712a:	51 e1       	ldi	r21, 0x11	; 17
   1712c:	07 c0       	rjmp	.+14     	; 0x1713c <__udivmodhi4_ep>

0001712e <__udivmodhi4_loop>:
   1712e:	aa 1f       	adc	r26, r26
   17130:	bb 1f       	adc	r27, r27
   17132:	a6 17       	cp	r26, r22
   17134:	b7 07       	cpc	r27, r23
   17136:	10 f0       	brcs	.+4      	; 0x1713c <__udivmodhi4_ep>
   17138:	a6 1b       	sub	r26, r22
   1713a:	b7 0b       	sbc	r27, r23

0001713c <__udivmodhi4_ep>:
   1713c:	88 1f       	adc	r24, r24
   1713e:	99 1f       	adc	r25, r25
   17140:	5a 95       	dec	r21
   17142:	a9 f7       	brne	.-22     	; 0x1712e <__udivmodhi4_loop>
   17144:	80 95       	com	r24
   17146:	90 95       	com	r25
   17148:	bc 01       	movw	r22, r24
   1714a:	cd 01       	movw	r24, r26
   1714c:	08 95       	ret

0001714e <__divmodhi4>:
   1714e:	97 fb       	bst	r25, 7
   17150:	09 2e       	mov	r0, r25
   17152:	07 26       	eor	r0, r23
   17154:	0a d0       	rcall	.+20     	; 0x1716a <__divmodhi4_neg1>
   17156:	77 fd       	sbrc	r23, 7
   17158:	04 d0       	rcall	.+8      	; 0x17162 <__divmodhi4_neg2>
   1715a:	e5 df       	rcall	.-54     	; 0x17126 <__udivmodhi4>
   1715c:	06 d0       	rcall	.+12     	; 0x1716a <__divmodhi4_neg1>
   1715e:	00 20       	and	r0, r0
   17160:	1a f4       	brpl	.+6      	; 0x17168 <__divmodhi4_exit>

00017162 <__divmodhi4_neg2>:
   17162:	70 95       	com	r23
   17164:	61 95       	neg	r22
   17166:	7f 4f       	sbci	r23, 0xFF	; 255

00017168 <__divmodhi4_exit>:
   17168:	08 95       	ret

0001716a <__divmodhi4_neg1>:
   1716a:	f6 f7       	brtc	.-4      	; 0x17168 <__divmodhi4_exit>
   1716c:	90 95       	com	r25
   1716e:	81 95       	neg	r24
   17170:	9f 4f       	sbci	r25, 0xFF	; 255
   17172:	08 95       	ret

00017174 <__udivmodsi4>:
   17174:	a1 e2       	ldi	r26, 0x21	; 33
   17176:	1a 2e       	mov	r1, r26
   17178:	aa 1b       	sub	r26, r26
   1717a:	bb 1b       	sub	r27, r27
   1717c:	fd 01       	movw	r30, r26
   1717e:	0d c0       	rjmp	.+26     	; 0x1719a <__udivmodsi4_ep>

00017180 <__udivmodsi4_loop>:
   17180:	aa 1f       	adc	r26, r26
   17182:	bb 1f       	adc	r27, r27
   17184:	ee 1f       	adc	r30, r30
   17186:	ff 1f       	adc	r31, r31
   17188:	a2 17       	cp	r26, r18
   1718a:	b3 07       	cpc	r27, r19
   1718c:	e4 07       	cpc	r30, r20
   1718e:	f5 07       	cpc	r31, r21
   17190:	20 f0       	brcs	.+8      	; 0x1719a <__udivmodsi4_ep>
   17192:	a2 1b       	sub	r26, r18
   17194:	b3 0b       	sbc	r27, r19
   17196:	e4 0b       	sbc	r30, r20
   17198:	f5 0b       	sbc	r31, r21

0001719a <__udivmodsi4_ep>:
   1719a:	66 1f       	adc	r22, r22
   1719c:	77 1f       	adc	r23, r23
   1719e:	88 1f       	adc	r24, r24
   171a0:	99 1f       	adc	r25, r25
   171a2:	1a 94       	dec	r1
   171a4:	69 f7       	brne	.-38     	; 0x17180 <__udivmodsi4_loop>
   171a6:	60 95       	com	r22
   171a8:	70 95       	com	r23
   171aa:	80 95       	com	r24
   171ac:	90 95       	com	r25
   171ae:	9b 01       	movw	r18, r22
   171b0:	ac 01       	movw	r20, r24
   171b2:	bd 01       	movw	r22, r26
   171b4:	cf 01       	movw	r24, r30
   171b6:	08 95       	ret

000171b8 <__prologue_saves__>:
   171b8:	2f 92       	push	r2
   171ba:	3f 92       	push	r3
   171bc:	4f 92       	push	r4
   171be:	5f 92       	push	r5
   171c0:	6f 92       	push	r6
   171c2:	7f 92       	push	r7
   171c4:	8f 92       	push	r8
   171c6:	9f 92       	push	r9
   171c8:	af 92       	push	r10
   171ca:	bf 92       	push	r11
   171cc:	cf 92       	push	r12
   171ce:	df 92       	push	r13
   171d0:	ef 92       	push	r14
   171d2:	ff 92       	push	r15
   171d4:	0f 93       	push	r16
   171d6:	1f 93       	push	r17
   171d8:	cf 93       	push	r28
   171da:	df 93       	push	r29
   171dc:	cd b7       	in	r28, 0x3d	; 61
   171de:	de b7       	in	r29, 0x3e	; 62
   171e0:	ca 1b       	sub	r28, r26
   171e2:	db 0b       	sbc	r29, r27
   171e4:	0f b6       	in	r0, 0x3f	; 63
   171e6:	f8 94       	cli
   171e8:	de bf       	out	0x3e, r29	; 62
   171ea:	0f be       	out	0x3f, r0	; 63
   171ec:	cd bf       	out	0x3d, r28	; 61
   171ee:	09 94       	ijmp

000171f0 <__epilogue_restores__>:
   171f0:	2a 88       	ldd	r2, Y+18	; 0x12
   171f2:	39 88       	ldd	r3, Y+17	; 0x11
   171f4:	48 88       	ldd	r4, Y+16	; 0x10
   171f6:	5f 84       	ldd	r5, Y+15	; 0x0f
   171f8:	6e 84       	ldd	r6, Y+14	; 0x0e
   171fa:	7d 84       	ldd	r7, Y+13	; 0x0d
   171fc:	8c 84       	ldd	r8, Y+12	; 0x0c
   171fe:	9b 84       	ldd	r9, Y+11	; 0x0b
   17200:	aa 84       	ldd	r10, Y+10	; 0x0a
   17202:	b9 84       	ldd	r11, Y+9	; 0x09
   17204:	c8 84       	ldd	r12, Y+8	; 0x08
   17206:	df 80       	ldd	r13, Y+7	; 0x07
   17208:	ee 80       	ldd	r14, Y+6	; 0x06
   1720a:	fd 80       	ldd	r15, Y+5	; 0x05
   1720c:	0c 81       	ldd	r16, Y+4	; 0x04
   1720e:	1b 81       	ldd	r17, Y+3	; 0x03
   17210:	aa 81       	ldd	r26, Y+2	; 0x02
   17212:	b9 81       	ldd	r27, Y+1	; 0x01
   17214:	ce 0f       	add	r28, r30
   17216:	d1 1d       	adc	r29, r1
   17218:	0f b6       	in	r0, 0x3f	; 63
   1721a:	f8 94       	cli
   1721c:	de bf       	out	0x3e, r29	; 62
   1721e:	0f be       	out	0x3f, r0	; 63
   17220:	cd bf       	out	0x3d, r28	; 61
   17222:	ed 01       	movw	r28, r26
   17224:	08 95       	ret

00017226 <_exit>:
   17226:	f8 94       	cli

00017228 <__stop_program>:
   17228:	ff cf       	rjmp	.-2      	; 0x17228 <__stop_program>
