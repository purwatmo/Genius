
no6.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000000e  00800100  000037b8  0000386c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000037b8  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000329  0080010e  0080010e  0000387a  2**0
                  ALLOC
  3 .eeprom       0000001f  00810000  00810000  0000387a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .debug_aranges 00000060  00000000  00000000  00003899  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_pubnames 00000bf9  00000000  00000000  000038f9  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00003ffb  00000000  00000000  000044f2  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000005af  00000000  00000000  000084ed  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00003069  00000000  00000000  00008a9c  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000510  00000000  00000000  0000bb08  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000019b9  00000000  00000000  0000c018  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00002369  00000000  00000000  0000d9d1  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000420  00000000  00000000  0000fd3a  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 cc 00 	jmp	0x198	; 0x198 <__ctors_end>
       4:	0c 94 e9 00 	jmp	0x1d2	; 0x1d2 <__bad_interrupt>
       8:	0c 94 e9 00 	jmp	0x1d2	; 0x1d2 <__bad_interrupt>
       c:	0c 94 e9 00 	jmp	0x1d2	; 0x1d2 <__bad_interrupt>
      10:	0c 94 e9 00 	jmp	0x1d2	; 0x1d2 <__bad_interrupt>
      14:	0c 94 e9 00 	jmp	0x1d2	; 0x1d2 <__bad_interrupt>
      18:	0c 94 e9 00 	jmp	0x1d2	; 0x1d2 <__bad_interrupt>
      1c:	0c 94 e9 00 	jmp	0x1d2	; 0x1d2 <__bad_interrupt>
      20:	0c 94 e9 00 	jmp	0x1d2	; 0x1d2 <__bad_interrupt>
      24:	0c 94 e9 00 	jmp	0x1d2	; 0x1d2 <__bad_interrupt>
      28:	0c 94 e9 00 	jmp	0x1d2	; 0x1d2 <__bad_interrupt>
      2c:	0c 94 e9 00 	jmp	0x1d2	; 0x1d2 <__bad_interrupt>
      30:	0c 94 e9 00 	jmp	0x1d2	; 0x1d2 <__bad_interrupt>
      34:	0c 94 e9 00 	jmp	0x1d2	; 0x1d2 <__bad_interrupt>
      38:	0c 94 e9 00 	jmp	0x1d2	; 0x1d2 <__bad_interrupt>
      3c:	0c 94 e9 00 	jmp	0x1d2	; 0x1d2 <__bad_interrupt>
      40:	0c 94 e9 00 	jmp	0x1d2	; 0x1d2 <__bad_interrupt>
      44:	0c 94 eb 00 	jmp	0x1d6	; 0x1d6 <__vector_17>
      48:	0c 94 3b 17 	jmp	0x2e76	; 0x2e76 <__vector_18>
      4c:	0c 94 27 07 	jmp	0xe4e	; 0xe4e <__vector_19>
      50:	0c 94 f7 06 	jmp	0xdee	; 0xdee <__vector_20>
      54:	0c 94 e9 00 	jmp	0x1d2	; 0x1d2 <__bad_interrupt>
      58:	0c 94 e9 00 	jmp	0x1d2	; 0x1d2 <__bad_interrupt>
      5c:	0c 94 e9 00 	jmp	0x1d2	; 0x1d2 <__bad_interrupt>
      60:	0c 94 e9 00 	jmp	0x1d2	; 0x1d2 <__bad_interrupt>
      64:	0c 94 e9 00 	jmp	0x1d2	; 0x1d2 <__bad_interrupt>
      68:	0c 94 e9 00 	jmp	0x1d2	; 0x1d2 <__bad_interrupt>
      6c:	0c 94 e9 00 	jmp	0x1d2	; 0x1d2 <__bad_interrupt>
      70:	a1 0d       	add	r26, r1
      72:	f4 0d       	add	r31, r4
      74:	17 0e       	add	r1, r23
      76:	1e 0e       	add	r1, r30
      78:	24 0e       	add	r2, r20
      7a:	2f 0e       	add	r2, r31
      7c:	44 0e       	add	r4, r20
      7e:	84 0e       	add	r8, r20
      80:	06 0f       	add	r16, r22
      82:	81 0f       	add	r24, r17
      84:	aa 0f       	add	r26, r26
      86:	4f 0f       	add	r20, r31
      88:	0d 0f       	add	r16, r29
      8a:	1a 0f       	add	r17, r26
      8c:	57 0f       	add	r21, r23
      8e:	64 0f       	add	r22, r20
      90:	66 10       	cpse	r6, r6
      92:	b0 0f       	add	r27, r16
      94:	bd 0f       	add	r27, r29
      96:	e2 0f       	add	r30, r18
      98:	66 10       	cpse	r6, r6
      9a:	8f 0f       	add	r24, r31
      9c:	e4 0f       	add	r30, r20
      9e:	ab 0e       	add	r10, r27
      a0:	b9 0e       	add	r11, r25
      a2:	9b 0f       	add	r25, r27
      a4:	04 10       	cpse	r0, r4
      a6:	17 10       	cpse	r1, r7
      a8:	1d 10       	cpse	r1, r13
      aa:	2a 10       	cpse	r2, r10
      ac:	4e 10       	cpse	r4, r14
      ae:	50 10       	cpse	r5, r0
      b0:	5c 10       	cpse	r5, r12
      b2:	d5 10       	cpse	r13, r5
      b4:	25 11       	cpse	r18, r5
      b6:	3b 11       	cpse	r19, r11
      b8:	4a 11       	cpse	r20, r10
      ba:	81 11       	cpse	r24, r1
      bc:	98 11       	cpse	r25, r8
      be:	aa 11       	cpse	r26, r10
      c0:	b8 11       	cpse	r27, r8
      c2:	c7 13       	cpse	r28, r23
      c4:	ab 12       	cpse	r10, r27
      c6:	bd 12       	cpse	r11, r29
      c8:	e5 12       	cpse	r14, r21
      ca:	f1 12       	cpse	r15, r17
      cc:	fd 12       	cpse	r15, r29
      ce:	4a 12       	cpse	r4, r26
      d0:	5c 12       	cpse	r5, r28
      d2:	7a 12       	cpse	r7, r26
      d4:	86 12       	cpse	r8, r22
      d6:	0e 13       	cpse	r16, r30
      d8:	22 13       	cpse	r18, r18
      da:	61 13       	cpse	r22, r17
      dc:	6e 13       	cpse	r22, r30
      de:	70 13       	cpse	r23, r16
      e0:	77 13       	cpse	r23, r23
      e2:	81 13       	cpse	r24, r17
      e4:	8e 13       	cpse	r24, r30
      e6:	94 13       	cpse	r25, r20
      e8:	9f 13       	cpse	r25, r31
      ea:	a0 15       	cp	r26, r0
      ec:	b7 15       	cp	r27, r7
      ee:	2c 17       	cp	r18, r28
      f0:	57 16       	cp	r5, r23
      f2:	16 16       	cp	r1, r22
      f4:	2c 16       	cp	r2, r28
      f6:	2c 17       	cp	r18, r28
      f8:	2c 17       	cp	r18, r28
      fa:	71 16       	cp	r7, r17
      fc:	8d 16       	cp	r8, r29
      fe:	2c 17       	cp	r18, r28
     100:	2c 17       	cp	r18, r28
     102:	a7 16       	cp	r10, r23
     104:	2c 17       	cp	r18, r28
     106:	d1 16       	cp	r13, r17
     108:	d6 16       	cp	r13, r22
     10a:	df 16       	cp	r13, r31
     10c:	2c 17       	cp	r18, r28
     10e:	2c 17       	cp	r18, r28
     110:	ad 16       	cp	r10, r29
     112:	bd 16       	cp	r11, r29
     114:	c2 16       	cp	r12, r18
     116:	c7 16       	cp	r12, r23
     118:	cc 16       	cp	r12, r28
     11a:	2c 17       	cp	r18, r28
     11c:	2c 17       	cp	r18, r28
     11e:	e4 16       	cp	r14, r20
     120:	da 15       	cp	r29, r10
     122:	f9 16       	cp	r15, r25
     124:	07 17       	cp	r16, r23
     126:	11 17       	cp	r17, r17
     128:	15 17       	cp	r17, r21
     12a:	18 17       	cp	r17, r24

0000012c <__c.3487>:
     12c:	49 6e 69 74 69 61 6c 69 7a 65 64 00                 Initialized.

00000138 <__c.3124>:
     138:	25 64 00                                            %d.

0000013b <__c.3119>:
     13b:	25 73 25 73 00                                      %s%s.

00000140 <__c.3117>:
     140:	30 32 25 2e 32 64 00                                02%.2d.

00000147 <__c.3087>:
     147:	25 64 00                                            %d.

0000014a <__c.3082>:
     14a:	30 31 25 2e 32 64 25 2e 31 64 25 2e 31 64 25 73     01%.2d%.1d%.1d%s
     15a:	25 73 25 73 00                                      %s%s.

0000015f <__c.2954>:
     15f:	41 75 74 68 6f 72 69 7a 65 64 00                    Authorized.

0000016a <__c.2930>:
     16a:	50 6f 6f 6c 52 65 73 74 61 72 74 65 64 00           PoolRestarted.

00000178 <__c.2784>:
     178:	50 6f 6f 6c 52 65 73 74 61 72 74 65 64 00           PoolRestarted.

00000186 <__c.2782>:
     186:	57 50 6f 6f 6c 3a 25 64 00                          WPool:%d.

0000018f <__c.2379>:
     18f:	50 75 6d 70 3a 25 64 00 00                          Pump:%d..

00000198 <__ctors_end>:
     198:	11 24       	eor	r1, r1
     19a:	1f be       	out	0x3f, r1	; 63
     19c:	cf ef       	ldi	r28, 0xFF	; 255
     19e:	d4 e0       	ldi	r29, 0x04	; 4
     1a0:	de bf       	out	0x3e, r29	; 62
     1a2:	cd bf       	out	0x3d, r28	; 61

000001a4 <__do_copy_data>:
     1a4:	11 e0       	ldi	r17, 0x01	; 1
     1a6:	a0 e0       	ldi	r26, 0x00	; 0
     1a8:	b1 e0       	ldi	r27, 0x01	; 1
     1aa:	e8 eb       	ldi	r30, 0xB8	; 184
     1ac:	f7 e3       	ldi	r31, 0x37	; 55
     1ae:	02 c0       	rjmp	.+4      	; 0x1b4 <.do_copy_data_start>

000001b0 <.do_copy_data_loop>:
     1b0:	05 90       	lpm	r0, Z+
     1b2:	0d 92       	st	X+, r0

000001b4 <.do_copy_data_start>:
     1b4:	ae 30       	cpi	r26, 0x0E	; 14
     1b6:	b1 07       	cpc	r27, r17
     1b8:	d9 f7       	brne	.-10     	; 0x1b0 <.do_copy_data_loop>

000001ba <__do_clear_bss>:
     1ba:	14 e0       	ldi	r17, 0x04	; 4
     1bc:	ae e0       	ldi	r26, 0x0E	; 14
     1be:	b1 e0       	ldi	r27, 0x01	; 1
     1c0:	01 c0       	rjmp	.+2      	; 0x1c4 <.do_clear_bss_start>

000001c2 <.do_clear_bss_loop>:
     1c2:	1d 92       	st	X+, r1

000001c4 <.do_clear_bss_start>:
     1c4:	a7 33       	cpi	r26, 0x37	; 55
     1c6:	b1 07       	cpc	r27, r17
     1c8:	e1 f7       	brne	.-8      	; 0x1c2 <.do_clear_bss_loop>
     1ca:	0e 94 3f 15 	call	0x2a7e	; 0x2a7e <main>
     1ce:	0c 94 da 1b 	jmp	0x37b4	; 0x37b4 <_exit>

000001d2 <__bad_interrupt>:
     1d2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000001d6 <__vector_17>:

char SequencePool=0;//LivePooling Detection
char TimWatchSequence,SequenceTimeout;
char PumpTransDigit=6,PumpTotalDigit=8;

ISR(TIMER0_OVF_vect) {
     1d6:	1f 92       	push	r1
     1d8:	0f 92       	push	r0
     1da:	0f b6       	in	r0, 0x3f	; 63
     1dc:	0f 92       	push	r0
     1de:	11 24       	eor	r1, r1
     1e0:	2f 93       	push	r18
     1e2:	3f 93       	push	r19
     1e4:	5f 93       	push	r21
     1e6:	6f 93       	push	r22
     1e8:	7f 93       	push	r23
     1ea:	8f 93       	push	r24
     1ec:	9f 93       	push	r25
     1ee:	af 93       	push	r26
     1f0:	bf 93       	push	r27
    //TCNT1H=0xFD;//Ov:10ms
	//TCNT1L=0xC0;
    static char TimerExp=0;	     
    TimerExp++;
     1f2:	80 91 3a 01 	lds	r24, 0x013A
     1f6:	8f 5f       	subi	r24, 0xFF	; 255
     1f8:	80 93 3a 01 	sts	0x013A, r24
	if ((TimerExp%BlinkRate)==0){
     1fc:	60 91 11 04 	lds	r22, 0x0411
     200:	0e 94 61 1b 	call	0x36c2	; 0x36c2 <__udivmodqi4>
     204:	99 23       	and	r25, r25
     206:	21 f4       	brne	.+8      	; 0x210 <__vector_17+0x3a>
		PORTE ^= 0x04;
     208:	87 b1       	in	r24, 0x07	; 7
     20a:	94 e0       	ldi	r25, 0x04	; 4
     20c:	89 27       	eor	r24, r25
     20e:	87 b9       	out	0x07, r24	; 7
	}
	TimExp++;
     210:	20 91 1f 01 	lds	r18, 0x011F
     214:	30 91 20 01 	lds	r19, 0x0120
     218:	2f 5f       	subi	r18, 0xFF	; 255
     21a:	3f 4f       	sbci	r19, 0xFF	; 255
     21c:	30 93 20 01 	sts	0x0120, r19
     220:	20 93 1f 01 	sts	0x011F, r18
	if ((TimExp%2)==0) TimSend++;
     224:	20 fd       	sbrc	r18, 0
     226:	09 c0       	rjmp	.+18     	; 0x23a <__vector_17+0x64>
     228:	80 91 23 04 	lds	r24, 0x0423
     22c:	90 91 24 04 	lds	r25, 0x0424
     230:	01 96       	adiw	r24, 0x01	; 1
     232:	90 93 24 04 	sts	0x0424, r25
     236:	80 93 23 04 	sts	0x0423, r24
	if ((TimExp%100)==0) TimWatchSequence++;
     23a:	c9 01       	movw	r24, r18
     23c:	64 e6       	ldi	r22, 0x64	; 100
     23e:	70 e0       	ldi	r23, 0x00	; 0
     240:	0e 94 6d 1b 	call	0x36da	; 0x36da <__udivmodhi4>
     244:	89 2b       	or	r24, r25
     246:	29 f4       	brne	.+10     	; 0x252 <__vector_17+0x7c>
     248:	80 91 de 02 	lds	r24, 0x02DE
     24c:	8f 5f       	subi	r24, 0xFF	; 255
     24e:	80 93 de 02 	sts	0x02DE, r24
	TimReceive++;
     252:	80 91 0f 04 	lds	r24, 0x040F
     256:	90 91 10 04 	lds	r25, 0x0410
     25a:	01 96       	adiw	r24, 0x01	; 1
     25c:	90 93 10 04 	sts	0x0410, r25
     260:	80 93 0f 04 	sts	0x040F, r24
	TimDelayNextPump++;
     264:	80 91 21 01 	lds	r24, 0x0121
     268:	90 91 22 01 	lds	r25, 0x0122
     26c:	01 96       	adiw	r24, 0x01	; 1
     26e:	90 93 22 01 	sts	0x0122, r25
     272:	80 93 21 01 	sts	0x0121, r24
}
     276:	bf 91       	pop	r27
     278:	af 91       	pop	r26
     27a:	9f 91       	pop	r25
     27c:	8f 91       	pop	r24
     27e:	7f 91       	pop	r23
     280:	6f 91       	pop	r22
     282:	5f 91       	pop	r21
     284:	3f 91       	pop	r19
     286:	2f 91       	pop	r18
     288:	0f 90       	pop	r0
     28a:	0f be       	out	0x3f, r0	; 63
     28c:	0f 90       	pop	r0
     28e:	1f 90       	pop	r1
     290:	18 95       	reti

00000292 <DoNothing>:
	}
}

void DoNothing(){

}
     292:	08 95       	ret

00000294 <InitMem>:

void InitMem(){
     //IFType=IT_SLAVE;
}
     294:	08 95       	ret

00000296 <GetBaudrate>:

int GetBaudrate(char brSetting){
int Result=0;
     switch(brSetting){
     296:	82 30       	cpi	r24, 0x02	; 2
     298:	59 f0       	breq	.+22     	; 0x2b0 <GetBaudrate+0x1a>
     29a:	82 30       	cpi	r24, 0x02	; 2
     29c:	18 f0       	brcs	.+6      	; 0x2a4 <GetBaudrate+0xe>
     29e:	83 30       	cpi	r24, 0x03	; 3
     2a0:	21 f4       	brne	.+8      	; 0x2aa <GetBaudrate+0x14>
     2a2:	09 c0       	rjmp	.+18     	; 0x2b6 <GetBaudrate+0x20>
     2a4:	20 e8       	ldi	r18, 0x80	; 128
     2a6:	35 e2       	ldi	r19, 0x25	; 37
     2a8:	08 c0       	rjmp	.+16     	; 0x2ba <GetBaudrate+0x24>
     2aa:	20 e0       	ldi	r18, 0x00	; 0
     2ac:	30 e0       	ldi	r19, 0x00	; 0
     2ae:	05 c0       	rjmp	.+10     	; 0x2ba <GetBaudrate+0x24>
     2b0:	20 e0       	ldi	r18, 0x00	; 0
     2b2:	3b e4       	ldi	r19, 0x4B	; 75
     2b4:	02 c0       	rjmp	.+4      	; 0x2ba <GetBaudrate+0x24>
	 case br9600: 
	      Result=9600;
	      break;
	 case br19200:
	      Result=19200;
	      break;
     2b6:	2b e9       	ldi	r18, 0x9B	; 155
     2b8:	36 e1       	ldi	r19, 0x16	; 22
	 case br5787:
	      Result=5787;
     	  break;	 
	 }
   return Result;
}
     2ba:	c9 01       	movw	r24, r18
     2bc:	08 95       	ret

000002be <GetIFType>:
char GetIFType(){
char Result=IT_NONE;
     

return Result;
}
     2be:	80 e0       	ldi	r24, 0x00	; 0
     2c0:	08 95       	ret

000002c2 <SystemComLevel>:
}



void SystemComLevel(char ComLevel){
	 sbi(PORTA,0);  // rs232 off
     2c2:	d8 9a       	sbi	0x1b, 0	; 27
	 sbi(PORTA,3);  // rs485 off
     2c4:	db 9a       	sbi	0x1b, 3	; 27
	 switch(ComLevel){
     2c6:	81 30       	cpi	r24, 0x01	; 1
     2c8:	21 f0       	breq	.+8      	; 0x2d2 <SystemComLevel+0x10>
     2ca:	82 30       	cpi	r24, 0x02	; 2
     2cc:	19 f4       	brne	.+6      	; 0x2d4 <SystemComLevel+0x12>
	 case CL_485:
		  //sbi(PORTA,0);  // rs232 off
		  cbi(PORTA,3);  // rs485 on	 
     2ce:	db 98       	cbi	0x1b, 3	; 27
     2d0:	08 95       	ret
	      break;
     case CL_232:
		  cbi(PORTA,0);  // rs232 on
     2d2:	d8 98       	cbi	0x1b, 0	; 27
     2d4:	08 95       	ret

000002d6 <StatePrintf>:
	System485(DIR_RX);//ReceiveMode
}

void StatePrintf(char *strState){
     //TerminalSendf(1,strState);
}
     2d6:	08 95       	ret

000002d8 <systemAntiFreeze>:
//15694 95.8% -> 14746 90.0%

void systemAntiFreeze(){
static char zSequence=0;

	if (IFType==IT_STANDALONE){
     2d8:	80 91 00 01 	lds	r24, 0x0100
     2dc:	82 30       	cpi	r24, 0x02	; 2
     2de:	a9 f4       	brne	.+42     	; 0x30a <systemAntiFreeze+0x32>
	    if (SequencePool>zSequence){
     2e0:	20 91 26 01 	lds	r18, 0x0126
     2e4:	80 91 35 01 	lds	r24, 0x0135
     2e8:	82 17       	cp	r24, r18
     2ea:	10 f4       	brcc	.+4      	; 0x2f0 <systemAntiFreeze+0x18>
		    TimWatchSequence=0;
     2ec:	10 92 de 02 	sts	0x02DE, r1
		}
        if (TimWatchSequence>SequenceTimeout){
     2f0:	90 91 de 02 	lds	r25, 0x02DE
     2f4:	80 91 36 04 	lds	r24, 0x0436
     2f8:	89 17       	cp	r24, r25
     2fa:	28 f4       	brcc	.+10     	; 0x306 <systemAntiFreeze+0x2e>
		    TimWatchSequence=0; 
     2fc:	10 92 de 02 	sts	0x02DE, r1
		    //SendAcknoledge(SC_FREEZE,SequenceTimeout);
		    IsRestartPooling=True;
     300:	81 e0       	ldi	r24, 0x01	; 1
     302:	80 93 03 01 	sts	0x0103, r24
		}
		zSequence=SequencePool;
     306:	20 93 35 01 	sts	0x0135, r18
     30a:	08 95       	ret

0000030c <CRC_Wayne>:

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
     30c:	70 e0       	ldi	r23, 0x00	; 0
     30e:	68 27       	eor	r22, r24
     310:	79 27       	eor	r23, r25
     312:	20 e0       	ldi	r18, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
     314:	41 e0       	ldi	r20, 0x01	; 1
     316:	50 ea       	ldi	r21, 0xA0	; 160
     318:	cb 01       	movw	r24, r22
     31a:	96 95       	lsr	r25
     31c:	87 95       	ror	r24
     31e:	60 ff       	sbrs	r22, 0
     320:	04 c0       	rjmp	.+8      	; 0x32a <CRC_Wayne+0x1e>
     322:	bc 01       	movw	r22, r24
     324:	64 27       	eor	r22, r20
     326:	75 27       	eor	r23, r21
     328:	01 c0       	rjmp	.+2      	; 0x32c <CRC_Wayne+0x20>
        else xCRC= (xCRC>> 1);
     32a:	bc 01       	movw	r22, r24
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
     32c:	2f 5f       	subi	r18, 0xFF	; 255
     32e:	28 30       	cpi	r18, 0x08	; 8
     330:	99 f7       	brne	.-26     	; 0x318 <CRC_Wayne+0xc>
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
        else xCRC= (xCRC>> 1);
    }
    return xCRC;
}
     332:	cb 01       	movw	r24, r22
     334:	08 95       	ret

00000336 <sys_delay>:

void sys_delay(unsigned int dV){
}
     336:	08 95       	ret

00000338 <System485>:

void System485(char Dir){//DIR_TX, DIR_RX	 
     switch(Dir){
     338:	81 30       	cpi	r24, 0x01	; 1
     33a:	19 f0       	breq	.+6      	; 0x342 <System485+0xa>
     33c:	82 30       	cpi	r24, 0x02	; 2
     33e:	71 f4       	brne	.+28     	; 0x35c <System485+0x24>
     340:	07 c0       	rjmp	.+14     	; 0x350 <System485+0x18>
	 case DIR_TX:
	      sbi(PORTB,1);
     342:	c1 9a       	sbi	0x18, 1	; 24
		  sbi(DDRB,1);
     344:	b9 9a       	sbi	0x17, 1	; 23
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     346:	84 ec       	ldi	r24, 0xC4	; 196
     348:	99 e0       	ldi	r25, 0x09	; 9
     34a:	01 97       	sbiw	r24, 0x01	; 1
     34c:	f1 f7       	brne	.-4      	; 0x34a <System485+0x12>
     34e:	08 95       	ret
		  _delay_ms(10);
	      break;
	 case DIR_RX:
          _delay_ms(7);
		  sbi(DDRB,1);
     350:	86 ed       	ldi	r24, 0xD6	; 214
     352:	96 e0       	ldi	r25, 0x06	; 6
     354:	01 97       	sbiw	r24, 0x01	; 1
     356:	f1 f7       	brne	.-4      	; 0x354 <System485+0x1c>
     358:	b9 9a       	sbi	0x17, 1	; 23
		  cbi(PORTB,1);		  
     35a:	c1 98       	cbi	0x18, 1	; 24
     35c:	08 95       	ret

0000035e <WayneTestSend>:
	 _uart(0,1,xData);
	 System485(DIR_RX);//ReceiveMode
}

void WayneTestSend(){
}
     35e:	08 95       	ret

00000360 <ExtractValue>:
     case CMD_REQ_GLOBAL_STATUS_2:
  	      break;
	 }	 
}

void ExtractValue(char *Source,char FirstPos,char nCount,char*Dest){//WayneRxBuffer,13,16-13,strVolume);
     360:	fc 01       	movw	r30, r24
     362:	e6 0f       	add	r30, r22
     364:	f1 1d       	adc	r31, r1
     366:	d9 01       	movw	r26, r18
     368:	90 e0       	ldi	r25, 0x00	; 0
     36a:	0d c0       	rjmp	.+26     	; 0x386 <ExtractValue+0x26>
     char i;
	 for(i=0;i<nCount;i++){
	     Dest[2*i]=(Source[FirstPos+i]>>4)+'0';
     36c:	80 81       	ld	r24, Z
     36e:	82 95       	swap	r24
     370:	8f 70       	andi	r24, 0x0F	; 15
     372:	80 5d       	subi	r24, 0xD0	; 208
     374:	8c 93       	st	X, r24
	     Dest[(2*i)+1]=(Source[FirstPos+i]&0x0F)+'0';	 
     376:	81 91       	ld	r24, Z+
     378:	8f 70       	andi	r24, 0x0F	; 15
     37a:	80 5d       	subi	r24, 0xD0	; 208
     37c:	11 96       	adiw	r26, 0x01	; 1
     37e:	8c 93       	st	X, r24
     380:	11 97       	sbiw	r26, 0x01	; 1
	 }	 
}

void ExtractValue(char *Source,char FirstPos,char nCount,char*Dest){//WayneRxBuffer,13,16-13,strVolume);
     char i;
	 for(i=0;i<nCount;i++){
     382:	9f 5f       	subi	r25, 0xFF	; 255
     384:	12 96       	adiw	r26, 0x02	; 2
     386:	94 17       	cp	r25, r20
     388:	88 f3       	brcs	.-30     	; 0x36c <ExtractValue+0xc>
	     Dest[2*i]=(Source[FirstPos+i]>>4)+'0';
	     Dest[(2*i)+1]=(Source[FirstPos+i]&0x0F)+'0';	 
	 }Dest[2*nCount]=0;
     38a:	e4 2f       	mov	r30, r20
     38c:	f0 e0       	ldi	r31, 0x00	; 0
     38e:	ee 0f       	add	r30, r30
     390:	ff 1f       	adc	r31, r31
     392:	e2 0f       	add	r30, r18
     394:	f3 1f       	adc	r31, r19
     396:	10 82       	st	Z, r1
}
     398:	08 95       	ret

0000039a <InitPumpData>:
}

void InitPumpData(){
char i;
char strSerial[20];
     if (StandaloneType==ST_GILBARCO){
     39a:	80 91 01 01 	lds	r24, 0x0101
     39e:	81 30       	cpi	r24, 0x01	; 1
     3a0:	01 f5       	brne	.+64     	; 0x3e2 <InitPumpData+0x48>
     3a2:	80 e0       	ldi	r24, 0x00	; 0
     3a4:	90 e0       	ldi	r25, 0x00	; 0
	     for(i=0;i<16;i++){
		     IsRequestTransInfo[i]=False;
			 IsRequestTotalizerInfo[i]=False;
			 zPumpStatus[i]=PUMP_NONE;
     3a6:	2e e0       	ldi	r18, 0x0E	; 14
void InitPumpData(){
char i;
char strSerial[20];
     if (StandaloneType==ST_GILBARCO){
	     for(i=0;i<16;i++){
		     IsRequestTransInfo[i]=False;
     3a8:	fc 01       	movw	r30, r24
     3aa:	e6 57       	subi	r30, 0x76	; 118
     3ac:	fd 4f       	sbci	r31, 0xFD	; 253
     3ae:	10 82       	st	Z, r1
			 IsRequestTotalizerInfo[i]=False;
     3b0:	fc 01       	movw	r30, r24
     3b2:	ed 5e       	subi	r30, 0xED	; 237
     3b4:	fb 4f       	sbci	r31, 0xFB	; 251
     3b6:	10 82       	st	Z, r1
			 zPumpStatus[i]=PUMP_NONE;
     3b8:	fc 01       	movw	r30, r24
     3ba:	e5 56       	subi	r30, 0x65	; 101
     3bc:	fd 4f       	sbci	r31, 0xFD	; 253
     3be:	20 83       	st	Z, r18
			 PumpStatus[i]=PUMP_NONE;
     3c0:	fc 01       	movw	r30, r24
     3c2:	eb 54       	subi	r30, 0x4B	; 75
     3c4:	fc 4f       	sbci	r31, 0xFC	; 252
     3c6:	20 83       	st	Z, r18
			 NoPumpCount[i]=0;
     3c8:	fc 01       	movw	r30, r24
     3ca:	eb 5d       	subi	r30, 0xDB	; 219
     3cc:	fb 4f       	sbci	r31, 0xFB	; 251
     3ce:	10 82       	st	Z, r1
			 PumpLock[i]=False;
     3d0:	fc 01       	movw	r30, r24
     3d2:	e4 53       	subi	r30, 0x34	; 52
     3d4:	fd 4f       	sbci	r31, 0xFD	; 253
     3d6:	10 82       	st	Z, r1
     3d8:	01 96       	adiw	r24, 0x01	; 1

void InitPumpData(){
char i;
char strSerial[20];
     if (StandaloneType==ST_GILBARCO){
	     for(i=0;i<16;i++){
     3da:	80 31       	cpi	r24, 0x10	; 16
     3dc:	91 05       	cpc	r25, r1
     3de:	21 f7       	brne	.-56     	; 0x3a8 <InitPumpData+0xe>
     3e0:	08 95       	ret
			 zPumpStatus[i]=PUMP_NONE;
			 PumpStatus[i]=PUMP_NONE;
			 NoPumpCount[i]=0;
			 PumpLock[i]=False;
		 }
     }else if (StandaloneType==ST_WAYNE_DART){
     3e2:	80 91 01 01 	lds	r24, 0x0101
     3e6:	82 30       	cpi	r24, 0x02	; 2
     3e8:	f1 f4       	brne	.+60     	; 0x426 <InitPumpData+0x8c>
     3ea:	80 e0       	ldi	r24, 0x00	; 0
     3ec:	90 e0       	ldi	r25, 0x00	; 0
	     for(i=0;i<16;i++){
		     IsRequestTransInfo[i]=False;
     3ee:	fc 01       	movw	r30, r24
     3f0:	e6 57       	subi	r30, 0x76	; 118
     3f2:	fd 4f       	sbci	r31, 0xFD	; 253
     3f4:	10 82       	st	Z, r1
			 IsRequestTotalizerInfo[i]=False;
     3f6:	fc 01       	movw	r30, r24
     3f8:	ed 5e       	subi	r30, 0xED	; 237
     3fa:	fb 4f       	sbci	r31, 0xFB	; 251
     3fc:	10 82       	st	Z, r1
			 zPumpStatus[i]=PW_NONE;
     3fe:	fc 01       	movw	r30, r24
     400:	e5 56       	subi	r30, 0x65	; 101
     402:	fd 4f       	sbci	r31, 0xFD	; 253
     404:	10 82       	st	Z, r1
			 PumpStatus[i]=PW_NONE;
     406:	fc 01       	movw	r30, r24
     408:	eb 54       	subi	r30, 0x4B	; 75
     40a:	fc 4f       	sbci	r31, 0xFC	; 252
     40c:	10 82       	st	Z, r1
			 NoPumpCount[i]=0;
     40e:	fc 01       	movw	r30, r24
     410:	eb 5d       	subi	r30, 0xDB	; 219
     412:	fb 4f       	sbci	r31, 0xFB	; 251
     414:	10 82       	st	Z, r1
			 PumpLock[i]=False;
     416:	fc 01       	movw	r30, r24
     418:	e4 53       	subi	r30, 0x34	; 52
     41a:	fd 4f       	sbci	r31, 0xFD	; 253
     41c:	10 82       	st	Z, r1
     41e:	01 96       	adiw	r24, 0x01	; 1
			 PumpStatus[i]=PUMP_NONE;
			 NoPumpCount[i]=0;
			 PumpLock[i]=False;
		 }
     }else if (StandaloneType==ST_WAYNE_DART){
	     for(i=0;i<16;i++){
     420:	80 31       	cpi	r24, 0x10	; 16
     422:	91 05       	cpc	r25, r1
     424:	21 f7       	brne	.-56     	; 0x3ee <InitPumpData+0x54>
     426:	08 95       	ret

00000428 <uart_init>:
     UBRR0H=0;
     UBRR0L=158;// baud 5787
     UCSR0C=(1<<URSEL0) | (1<<UPM01) | (1<<UCSZ01) | (1<<UCSZ00); // UPM01 untuk set even parity
     sei();
	 */
}
     428:	08 95       	ret

0000042a <InitSystemTimer>:

void InitSystemTimer(){
	TCCR0 |= (1 << CS02) | (1 << CS00);
     42a:	83 b7       	in	r24, 0x33	; 51
     42c:	85 60       	ori	r24, 0x05	; 5
     42e:	83 bf       	out	0x33, r24	; 51
	TIMSK |= _BV(TOIE0);
     430:	89 b7       	in	r24, 0x39	; 57
     432:	82 60       	ori	r24, 0x02	; 2
     434:	89 bf       	out	0x39, r24	; 57
}
     436:	08 95       	ret

00000438 <GetPumpID>:

char GetPumpID(char data){
     char xPumpID=0;
	 xPumpID=(data&0x0F);
	 return xPumpID;
}
     438:	8f 70       	andi	r24, 0x0F	; 15
     43a:	08 95       	ret

0000043c <GetResponse>:

char GetResponse(char data){
     char Response=0;
	 Response=((data&0xF0)>>4);
	 return Response;
}
     43c:	82 95       	swap	r24
     43e:	8f 70       	andi	r24, 0x0F	; 15
     440:	08 95       	ret

00000442 <ShiftArray>:
	 //_delay_ms(10);
}

void ShiftArray(char *strShifted, unsigned int nCount){

}
     442:	08 95       	ret

00000444 <systemServiceSPI>:

void systemServiceSPI(){
}
     444:	08 95       	ret

00000446 <SaveTransactionData>:
	    strSource[i]=strResult[i];
	    strSource[i+1]=0;
	 }
}

void SaveTransactionData(char data){
     446:	28 2f       	mov	r18, r24
     static char SavePipeline=spNone;
	 static char IdxData=0;
	 switch(SavePipeline){
     448:	80 91 2b 01 	lds	r24, 0x012B
     44c:	86 30       	cpi	r24, 0x06	; 6
     44e:	41 f1       	breq	.+80     	; 0x4a0 <SaveTransactionData+0x5a>
     450:	87 30       	cpi	r24, 0x07	; 7
     452:	30 f4       	brcc	.+12     	; 0x460 <SaveTransactionData+0x1a>
     454:	84 30       	cpi	r24, 0x04	; 4
     456:	51 f0       	breq	.+20     	; 0x46c <SaveTransactionData+0x26>
     458:	85 30       	cpi	r24, 0x05	; 5
     45a:	09 f0       	breq	.+2      	; 0x45e <SaveTransactionData+0x18>
     45c:	56 c0       	rjmp	.+172    	; 0x50a <__stack+0xb>
     45e:	17 c0       	rjmp	.+46     	; 0x48e <SaveTransactionData+0x48>
     460:	87 30       	cpi	r24, 0x07	; 7
     462:	79 f1       	breq	.+94     	; 0x4c2 <SaveTransactionData+0x7c>
     464:	8a 30       	cpi	r24, 0x0A	; 10
     466:	09 f0       	breq	.+2      	; 0x46a <SaveTransactionData+0x24>
     468:	50 c0       	rjmp	.+160    	; 0x50a <__stack+0xb>
     46a:	3b c0       	rjmp	.+118    	; 0x4e2 <SaveTransactionData+0x9c>
     case spPumpIdentifier:
	      if (IdxData==1)rxPumpId=FilterBCD(data);
     46c:	90 91 2a 01 	lds	r25, 0x012A
     470:	91 30       	cpi	r25, 0x01	; 1
     472:	29 f4       	brne	.+10     	; 0x47e <SaveTransactionData+0x38>
     474:	82 2f       	mov	r24, r18
     476:	8f 70       	andi	r24, 0x0F	; 15
     478:	80 93 3b 01 	sts	0x013B, r24
     47c:	43 c0       	rjmp	.+134    	; 0x504 <__stack+0x5>
		  else
	      if (IdxData==2)NozzleId=FilterBCD(data);
     47e:	92 30       	cpi	r25, 0x02	; 2
     480:	09 f0       	breq	.+2      	; 0x484 <SaveTransactionData+0x3e>
     482:	40 c0       	rjmp	.+128    	; 0x504 <__stack+0x5>
     484:	82 2f       	mov	r24, r18
     486:	8f 70       	andi	r24, 0x0F	; 15
     488:	80 93 e0 02 	sts	0x02E0, r24
     48c:	3b c0       	rjmp	.+118    	; 0x504 <__stack+0x5>
          IdxData++;
      	  break;
     case spProductGrade:
	      if (IdxData==0)GradeId=FilterBCD(data);
     48e:	90 91 2a 01 	lds	r25, 0x012A
     492:	99 23       	and	r25, r25
     494:	b9 f5       	brne	.+110    	; 0x504 <__stack+0x5>
     496:	82 2f       	mov	r24, r18
     498:	8f 70       	andi	r24, 0x0F	; 15
     49a:	80 93 f6 02 	sts	0x02F6, r24
     49e:	32 c0       	rjmp	.+100    	; 0x504 <__stack+0x5>
		  IdxData++;
      	  break;
     case spProductPrice:	       
          if (data!=0xF9){		      
     4a0:	29 3f       	cpi	r18, 0xF9	; 249
     4a2:	09 f4       	brne	.+2      	; 0x4a6 <SaveTransactionData+0x60>
     4a4:	40 c0       	rjmp	.+128    	; 0x526 <__stack+0x27>
		      strUnitPrice[IdxData]=BCD2Char(FilterBCD(data));
     4a6:	90 91 2a 01 	lds	r25, 0x012A
     4aa:	e9 2f       	mov	r30, r25
     4ac:	f0 e0       	ldi	r31, 0x00	; 0
	 Dest[Length]=0;
}

char FilterBCD(char data){
     char Result;
	 Result=(data&0x0F);
     4ae:	82 2f       	mov	r24, r18
     4b0:	8f 70       	andi	r24, 0x0F	; 15
}

char BCD2Char(char data){
     char Result;
	 Result=0;
	 if ((data>=0)&&(data<=9)) 
     4b2:	8a 30       	cpi	r24, 0x0A	; 10
     4b4:	10 f0       	brcs	.+4      	; 0x4ba <SaveTransactionData+0x74>
     4b6:	80 e3       	ldi	r24, 0x30	; 48
     4b8:	01 c0       	rjmp	.+2      	; 0x4bc <SaveTransactionData+0x76>
	     Result='0'+data;
     4ba:	80 5d       	subi	r24, 0xD0	; 208
	      if (IdxData==0)GradeId=FilterBCD(data);
		  IdxData++;
      	  break;
     case spProductPrice:	       
          if (data!=0xF9){		      
		      strUnitPrice[IdxData]=BCD2Char(FilterBCD(data));
     4bc:	e4 55       	subi	r30, 0x54	; 84
     4be:	fd 4f       	sbci	r31, 0xFD	; 253
     4c0:	1f c0       	rjmp	.+62     	; 0x500 <__stack+0x1>
              strUnitPrice[IdxData+1]=0;
	          IdxData++;
			  }
	  	  break;
     case spProductVolume:
          if (data!=0xFA){//Maks 7 Digit 0000123
     4c2:	2a 3f       	cpi	r18, 0xFA	; 250
     4c4:	91 f1       	breq	.+100    	; 0x52a <__stack+0x2b>
              strVolume[IdxData]=BCD2Char(FilterBCD(data));
     4c6:	90 91 2a 01 	lds	r25, 0x012A
     4ca:	e9 2f       	mov	r30, r25
     4cc:	f0 e0       	ldi	r31, 0x00	; 0
	 Dest[Length]=0;
}

char FilterBCD(char data){
     char Result;
	 Result=(data&0x0F);
     4ce:	82 2f       	mov	r24, r18
     4d0:	8f 70       	andi	r24, 0x0F	; 15
}

char BCD2Char(char data){
     char Result;
	 Result=0;
	 if ((data>=0)&&(data<=9)) 
     4d2:	8a 30       	cpi	r24, 0x0A	; 10
     4d4:	10 f0       	brcs	.+4      	; 0x4da <SaveTransactionData+0x94>
     4d6:	80 e3       	ldi	r24, 0x30	; 48
     4d8:	01 c0       	rjmp	.+2      	; 0x4dc <SaveTransactionData+0x96>
	     Result='0'+data;
     4da:	80 5d       	subi	r24, 0xD0	; 208
	          IdxData++;
			  }
	  	  break;
     case spProductVolume:
          if (data!=0xFA){//Maks 7 Digit 0000123
              strVolume[IdxData]=BCD2Char(FilterBCD(data));
     4dc:	e9 5a       	subi	r30, 0xA9	; 169
     4de:	fd 4f       	sbci	r31, 0xFD	; 253
     4e0:	0f c0       	rjmp	.+30     	; 0x500 <__stack+0x1>
              strVolume[IdxData+1]=0;
	          IdxData++;
		      }
	  	  break;
     case spProductMoney:
          if (data!=0xFB){
     4e2:	2b 3f       	cpi	r18, 0xFB	; 251
     4e4:	f1 f0       	breq	.+60     	; 0x522 <__stack+0x23>
              strAmount[IdxData]=BCD2Char(FilterBCD(data));
     4e6:	90 91 2a 01 	lds	r25, 0x012A
     4ea:	e9 2f       	mov	r30, r25
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
	 Dest[Length]=0;
}

char FilterBCD(char data){
     char Result;
	 Result=(data&0x0F);
     4ee:	82 2f       	mov	r24, r18
     4f0:	8f 70       	andi	r24, 0x0F	; 15
}

char BCD2Char(char data){
     char Result;
	 Result=0;
	 if ((data>=0)&&(data<=9)) 
     4f2:	8a 30       	cpi	r24, 0x0A	; 10
     4f4:	10 f0       	brcs	.+4      	; 0x4fa <SaveTransactionData+0xb4>
     4f6:	80 e3       	ldi	r24, 0x30	; 48
     4f8:	01 c0       	rjmp	.+2      	; 0x4fc <SaveTransactionData+0xb6>
	     Result='0'+data;
     4fa:	80 5d       	subi	r24, 0xD0	; 208
	          IdxData++;
		      }
	  	  break;
     case spProductMoney:
          if (data!=0xFB){
              strAmount[IdxData]=BCD2Char(FilterBCD(data));
     4fc:	e5 55       	subi	r30, 0x55	; 85
     4fe:	fc 4f       	sbci	r31, 0xFC	; 252
     500:	80 83       	st	Z, r24
              strAmount[IdxData+1]=0;
     502:	11 82       	std	Z+1, r1	; 0x01
              IdxData++;
     504:	9f 5f       	subi	r25, 0xFF	; 255
     506:	90 93 2a 01 	sts	0x012A, r25
     case spLRC:
	  	  break;	 
	 }

	 //Pipeline detection
	 if (data==0xF8){
     50a:	28 3f       	cpi	r18, 0xF8	; 248
     50c:	11 f4       	brne	.+4      	; 0x512 <__stack+0x13>
	     SavePipeline=spPumpIdentifier;
     50e:	84 e0       	ldi	r24, 0x04	; 4
     510:	0f c0       	rjmp	.+30     	; 0x530 <__stack+0x31>
		 IdxData=0;
	 }else if (data==0xF6){
     512:	26 3f       	cpi	r18, 0xF6	; 246
     514:	11 f4       	brne	.+4      	; 0x51a <__stack+0x1b>
	     SavePipeline=spProductGrade;
     516:	85 e0       	ldi	r24, 0x05	; 5
     518:	0b c0       	rjmp	.+22     	; 0x530 <__stack+0x31>
		 IdxData=0;
	 }else if (data==0xF7){
     51a:	27 3f       	cpi	r18, 0xF7	; 247
     51c:	11 f4       	brne	.+4      	; 0x522 <__stack+0x23>
	     SavePipeline=spProductPrice;
     51e:	86 e0       	ldi	r24, 0x06	; 6
     520:	07 c0       	rjmp	.+14     	; 0x530 <__stack+0x31>
		 IdxData=0;
	 }else if (data==0xF9){
     522:	29 3f       	cpi	r18, 0xF9	; 249
     524:	11 f4       	brne	.+4      	; 0x52a <__stack+0x2b>
	     SavePipeline=spProductVolume;
     526:	87 e0       	ldi	r24, 0x07	; 7
     528:	03 c0       	rjmp	.+6      	; 0x530 <__stack+0x31>
		 IdxData=0;
	 }else if (data==0xFA){
     52a:	2a 3f       	cpi	r18, 0xFA	; 250
     52c:	31 f4       	brne	.+12     	; 0x53a <__stack+0x3b>
	     SavePipeline=spProductMoney;
     52e:	8a e0       	ldi	r24, 0x0A	; 10
     530:	80 93 2b 01 	sts	0x012B, r24
		 IdxData=0;
     534:	10 92 2a 01 	sts	0x012A, r1
     538:	08 95       	ret
	 }else if (data==0xFB){
     53a:	2b 3f       	cpi	r18, 0xFB	; 251
     53c:	49 f4       	brne	.+18     	; 0x550 <__stack+0x51>
	     PumpTransDigit=IdxData;
     53e:	80 91 2a 01 	lds	r24, 0x012A
     542:	80 93 0b 01 	sts	0x010B, r24
	     SavePipeline=spLRC;
     546:	8b e0       	ldi	r24, 0x0B	; 11
     548:	80 93 2b 01 	sts	0x012B, r24
		 IdxData=0;
     54c:	10 92 2a 01 	sts	0x012A, r1
     550:	08 95       	ret

00000552 <SaveTotalizerData>:
	 }
}

void SaveTotalizerData(char data){
     552:	28 2f       	mov	r18, r24
     static char SavePipeline=spNone;
	 static char IdxData=0;

	 switch(SavePipeline){
     554:	80 91 29 01 	lds	r24, 0x0129
     558:	82 30       	cpi	r24, 0x02	; 2
     55a:	b9 f0       	breq	.+46     	; 0x58a <SaveTotalizerData+0x38>
     55c:	83 30       	cpi	r24, 0x03	; 3
     55e:	09 f4       	brne	.+2      	; 0x562 <SaveTotalizerData+0x10>
     560:	4a c0       	rjmp	.+148    	; 0x5f6 <SaveTotalizerData+0xa4>
     562:	81 30       	cpi	r24, 0x01	; 1
     564:	09 f0       	breq	.+2      	; 0x568 <SaveTotalizerData+0x16>
     566:	7e c0       	rjmp	.+252    	; 0x664 <SaveTotalizerData+0x112>
	 case spTotalizerGrade:
	      if (IdxData==0){
     568:	90 91 28 01 	lds	r25, 0x0128
     56c:	99 23       	and	r25, r25
     56e:	49 f4       	brne	.+18     	; 0x582 <SaveTotalizerData+0x30>
	 Dest[Length]=0;
}

char FilterBCD(char data){
     char Result;
	 Result=(data&0x0F);
     570:	82 2f       	mov	r24, r18
     572:	8f 70       	andi	r24, 0x0F	; 15
	 static char IdxData=0;

	 switch(SavePipeline){
	 case spTotalizerGrade:
	      if (IdxData==0){
		      TGradeId=FilterBCD(data);
     574:	80 93 dc 02 	sts	0x02DC, r24
			  //_uart(1,1,BCD2Char(TGradeId));
			  if (TGradeId>=5)TGradeId=5;
     578:	85 30       	cpi	r24, 0x05	; 5
     57a:	18 f0       	brcs	.+6      	; 0x582 <SaveTotalizerData+0x30>
     57c:	85 e0       	ldi	r24, 0x05	; 5
     57e:	80 93 dc 02 	sts	0x02DC, r24
			  }
          IdxData++; 
     582:	9f 5f       	subi	r25, 0xFF	; 255
     584:	90 93 28 01 	sts	0x0128, r25
     588:	6d c0       	rjmp	.+218    	; 0x664 <SaveTotalizerData+0x112>
	      break;
	 case spTotalizerVolume:
          if ((data&0xF0)==0xE0){
     58a:	82 2f       	mov	r24, r18
     58c:	80 7f       	andi	r24, 0xF0	; 240
     58e:	80 3e       	cpi	r24, 0xE0	; 224
     590:	09 f0       	breq	.+2      	; 0x594 <SaveTotalizerData+0x42>
     592:	68 c0       	rjmp	.+208    	; 0x664 <SaveTotalizerData+0x112>
		      PumpTotalizer.TotalGrade[TGradeId].strVolume[IdxData]=BCD2Char(FilterBCD(data));
     594:	50 91 dc 02 	lds	r21, 0x02DC
     598:	30 91 28 01 	lds	r19, 0x0128
     59c:	63 2f       	mov	r22, r19
     59e:	70 e0       	ldi	r23, 0x00	; 0
	 Dest[Length]=0;
}

char FilterBCD(char data){
     char Result;
	 Result=(data&0x0F);
     5a0:	82 2f       	mov	r24, r18
     5a2:	8f 70       	andi	r24, 0x0F	; 15
}

char BCD2Char(char data){
     char Result;
	 Result=0;
	 if ((data>=0)&&(data<=9)) 
     5a4:	8a 30       	cpi	r24, 0x0A	; 10
     5a6:	10 f0       	brcs	.+4      	; 0x5ac <SaveTotalizerData+0x5a>
     5a8:	40 e3       	ldi	r20, 0x30	; 48
     5aa:	02 c0       	rjmp	.+4      	; 0x5b0 <SaveTotalizerData+0x5e>
	     Result='0'+data;
     5ac:	48 2f       	mov	r20, r24
     5ae:	40 5d       	subi	r20, 0xD0	; 208
			  }
          IdxData++; 
	      break;
	 case spTotalizerVolume:
          if ((data&0xF0)==0xE0){
		      PumpTotalizer.TotalGrade[TGradeId].strVolume[IdxData]=BCD2Char(FilterBCD(data));
     5b0:	85 2f       	mov	r24, r21
     5b2:	90 e0       	ldi	r25, 0x00	; 0
     5b4:	fc 01       	movw	r30, r24
     5b6:	b5 e0       	ldi	r27, 0x05	; 5
     5b8:	ee 0f       	add	r30, r30
     5ba:	ff 1f       	adc	r31, r31
     5bc:	ba 95       	dec	r27
     5be:	e1 f7       	brne	.-8      	; 0x5b8 <SaveTotalizerData+0x66>
     5c0:	88 0f       	add	r24, r24
     5c2:	99 1f       	adc	r25, r25
     5c4:	e8 1b       	sub	r30, r24
     5c6:	f9 0b       	sbc	r31, r25
     5c8:	e6 0f       	add	r30, r22
     5ca:	f7 1f       	adc	r31, r23
     5cc:	e9 50       	subi	r30, 0x09	; 9
     5ce:	fd 4f       	sbci	r31, 0xFD	; 253
     5d0:	40 83       	st	Z, r20
			  //_uart(1,1,PumpTotalizer.TotalGrade[TGradeId].strVolume[IdxData]);

		      PumpTotalizer.TotalGrade[TGradeId].strVolume[IdxData+1]=0;
     5d2:	85 2f       	mov	r24, r21
     5d4:	90 e0       	ldi	r25, 0x00	; 0
     5d6:	fc 01       	movw	r30, r24
     5d8:	55 e0       	ldi	r21, 0x05	; 5
     5da:	ee 0f       	add	r30, r30
     5dc:	ff 1f       	adc	r31, r31
     5de:	5a 95       	dec	r21
     5e0:	e1 f7       	brne	.-8      	; 0x5da <SaveTotalizerData+0x88>
     5e2:	88 0f       	add	r24, r24
     5e4:	99 1f       	adc	r25, r25
     5e6:	e8 1b       	sub	r30, r24
     5e8:	f9 0b       	sbc	r31, r25
     5ea:	e9 50       	subi	r30, 0x09	; 9
     5ec:	fd 4f       	sbci	r31, 0xFD	; 253
     5ee:	e6 0f       	add	r30, r22
     5f0:	f7 1f       	adc	r31, r23
     5f2:	11 82       	std	Z+1, r1	; 0x01
     5f4:	34 c0       	rjmp	.+104    	; 0x65e <SaveTotalizerData+0x10c>
		      //TVolume[TGradeId][IdxData+1]=0;
		      IdxData++;
		  }
	      break;
	 case spTotalizerMoney:
          if ((data&0xF0)==0xE0){
     5f6:	82 2f       	mov	r24, r18
     5f8:	80 7f       	andi	r24, 0xF0	; 240
     5fa:	80 3e       	cpi	r24, 0xE0	; 224
     5fc:	99 f5       	brne	.+102    	; 0x664 <SaveTotalizerData+0x112>
	          //TMoney[TGradeId][IdxData]=BCD2Char(FilterBCD(data));
		      //TMoney[TGradeId][IdxData+1]=0;
		      PumpTotalizer.TotalGrade[TGradeId].strMoney[IdxData]=BCD2Char(FilterBCD(data));
     5fe:	70 91 dc 02 	lds	r23, 0x02DC
     602:	30 91 28 01 	lds	r19, 0x0128
     606:	43 2f       	mov	r20, r19
     608:	50 e0       	ldi	r21, 0x00	; 0
	 Dest[Length]=0;
}

char FilterBCD(char data){
     char Result;
	 Result=(data&0x0F);
     60a:	82 2f       	mov	r24, r18
     60c:	8f 70       	andi	r24, 0x0F	; 15
}

char BCD2Char(char data){
     char Result;
	 Result=0;
	 if ((data>=0)&&(data<=9)) 
     60e:	8a 30       	cpi	r24, 0x0A	; 10
     610:	10 f0       	brcs	.+4      	; 0x616 <SaveTotalizerData+0xc4>
     612:	60 e3       	ldi	r22, 0x30	; 48
     614:	02 c0       	rjmp	.+4      	; 0x61a <SaveTotalizerData+0xc8>
	     Result='0'+data;
     616:	68 2f       	mov	r22, r24
     618:	60 5d       	subi	r22, 0xD0	; 208
	      break;
	 case spTotalizerMoney:
          if ((data&0xF0)==0xE0){
	          //TMoney[TGradeId][IdxData]=BCD2Char(FilterBCD(data));
		      //TMoney[TGradeId][IdxData+1]=0;
		      PumpTotalizer.TotalGrade[TGradeId].strMoney[IdxData]=BCD2Char(FilterBCD(data));
     61a:	87 2f       	mov	r24, r23
     61c:	90 e0       	ldi	r25, 0x00	; 0
     61e:	fc 01       	movw	r30, r24
     620:	b5 e0       	ldi	r27, 0x05	; 5
     622:	ee 0f       	add	r30, r30
     624:	ff 1f       	adc	r31, r31
     626:	ba 95       	dec	r27
     628:	e1 f7       	brne	.-8      	; 0x622 <SaveTotalizerData+0xd0>
     62a:	88 0f       	add	r24, r24
     62c:	99 1f       	adc	r25, r25
     62e:	e8 1b       	sub	r30, r24
     630:	f9 0b       	sbc	r31, r25
     632:	e9 50       	subi	r30, 0x09	; 9
     634:	fd 4f       	sbci	r31, 0xFD	; 253
     636:	e4 0f       	add	r30, r20
     638:	f5 1f       	adc	r31, r21
     63a:	67 87       	std	Z+15, r22	; 0x0f
			  //_uart(1,1,PumpTotalizer.TotalGrade[TGradeId].strMoney[IdxData]);
		      PumpTotalizer.TotalGrade[TGradeId].strMoney[IdxData+1]=0;
     63c:	87 2f       	mov	r24, r23
     63e:	90 e0       	ldi	r25, 0x00	; 0
     640:	fc 01       	movw	r30, r24
     642:	75 e0       	ldi	r23, 0x05	; 5
     644:	ee 0f       	add	r30, r30
     646:	ff 1f       	adc	r31, r31
     648:	7a 95       	dec	r23
     64a:	e1 f7       	brne	.-8      	; 0x644 <SaveTotalizerData+0xf2>
     64c:	88 0f       	add	r24, r24
     64e:	99 1f       	adc	r25, r25
     650:	e8 1b       	sub	r30, r24
     652:	f9 0b       	sbc	r31, r25
     654:	e9 50       	subi	r30, 0x09	; 9
     656:	fd 4f       	sbci	r31, 0xFD	; 253
     658:	e4 0f       	add	r30, r20
     65a:	f5 1f       	adc	r31, r21
     65c:	10 8a       	std	Z+16, r1	; 0x10
  		      IdxData++;
     65e:	3f 5f       	subi	r19, 0xFF	; 255
     660:	30 93 28 01 	sts	0x0128, r19
          }
	      break;		  
	 }	 
	//Grade Data Next Select 
	if (data==0xF6){
     664:	26 3f       	cpi	r18, 0xF6	; 246
     666:	21 f4       	brne	.+8      	; 0x670 <SaveTotalizerData+0x11e>
	    IdxData=0;
     668:	10 92 28 01 	sts	0x0128, r1
	    SavePipeline=spTotalizerGrade;
     66c:	81 e0       	ldi	r24, 0x01	; 1
     66e:	13 c0       	rjmp	.+38     	; 0x696 <SaveTotalizerData+0x144>
		//_uart(1,1,0x0D);
		}
    else
	if (data==0xF9){
     670:	29 3f       	cpi	r18, 0xF9	; 249
     672:	11 f4       	brne	.+4      	; 0x678 <SaveTotalizerData+0x126>
	    SavePipeline=spTotalizerVolume;
     674:	82 e0       	ldi	r24, 0x02	; 2
     676:	07 c0       	rjmp	.+14     	; 0x686 <SaveTotalizerData+0x134>
		IdxData=0;
		//_uart(1,1,0x0D);
		//_uart(1,1,'V');
		}
	else
	if (data==0xFA){
     678:	2a 3f       	cpi	r18, 0xFA	; 250
     67a:	51 f4       	brne	.+20     	; 0x690 <SaveTotalizerData+0x13e>
	    PumpTotalDigit=IdxData;
     67c:	80 91 28 01 	lds	r24, 0x0128
     680:	80 93 0c 01 	sts	0x010C, r24
	    SavePipeline=spTotalizerMoney;
     684:	83 e0       	ldi	r24, 0x03	; 3
     686:	80 93 29 01 	sts	0x0129, r24
		IdxData=0;
     68a:	10 92 28 01 	sts	0x0128, r1
     68e:	08 95       	ret
		//_uart(1,1,0x0D);
		//_uart(1,1,'M');
		}
    else
	if (data==0xF4)SavePipeline=spTotalizerPPU1;
     690:	24 3f       	cpi	r18, 0xF4	; 244
     692:	21 f4       	brne	.+8      	; 0x69c <SaveTotalizerData+0x14a>
     694:	88 e0       	ldi	r24, 0x08	; 8
     696:	80 93 29 01 	sts	0x0129, r24
     69a:	08 95       	ret
	else
	if (data==0xF5)SavePipeline=spTotalizerPPU2;
     69c:	25 3f       	cpi	r18, 0xF5	; 245
     69e:	19 f4       	brne	.+6      	; 0x6a6 <SaveTotalizerData+0x154>
     6a0:	89 e0       	ldi	r24, 0x09	; 9
     6a2:	80 93 29 01 	sts	0x0129, r24
     6a6:	08 95       	ret

000006a8 <OnReceive1>:
            strRFID[8]=0;
     sprintf_P(strSerial,PSTR("RFID:%s"),strRFID);
     _uart_print(1,0,strSerial);
	 }
	 */
}
     6a8:	08 95       	ret

000006aa <UpdateMoney>:

void UpdateMoney(char *Dest, char *Src , unsigned int Length){
     6aa:	cf 93       	push	r28
     6ac:	df 93       	push	r29
     6ae:	ec 01       	movw	r28, r24
     6b0:	20 e0       	ldi	r18, 0x00	; 0
     6b2:	0b c0       	rjmp	.+22     	; 0x6ca <UpdateMoney+0x20>
     unsigned char i;
	 for(i=0;i<Length;i++){
	     Dest[i]=Src[Length-i];
     6b4:	fe 01       	movw	r30, r28
     6b6:	e8 0f       	add	r30, r24
     6b8:	f9 1f       	adc	r31, r25
     6ba:	da 01       	movw	r26, r20
     6bc:	a8 1b       	sub	r26, r24
     6be:	b9 0b       	sbc	r27, r25
     6c0:	a6 0f       	add	r26, r22
     6c2:	b7 1f       	adc	r27, r23
     6c4:	8c 91       	ld	r24, X
     6c6:	80 83       	st	Z, r24
	 */
}

void UpdateMoney(char *Dest, char *Src , unsigned int Length){
     unsigned char i;
	 for(i=0;i<Length;i++){
     6c8:	2f 5f       	subi	r18, 0xFF	; 255
     6ca:	82 2f       	mov	r24, r18
     6cc:	90 e0       	ldi	r25, 0x00	; 0
     6ce:	84 17       	cp	r24, r20
     6d0:	95 07       	cpc	r25, r21
     6d2:	80 f3       	brcs	.-32     	; 0x6b4 <UpdateMoney+0xa>
	     Dest[i]=Src[Length-i];
	 }
	 Dest[Length]=0;
     6d4:	c4 0f       	add	r28, r20
     6d6:	d5 1f       	adc	r29, r21
     6d8:	18 82       	st	Y, r1
}
     6da:	df 91       	pop	r29
     6dc:	cf 91       	pop	r28
     6de:	08 95       	ret

000006e0 <FilterBCD>:

char FilterBCD(char data){
     char Result;
	 Result=(data&0x0F);
	 return Result;
}
     6e0:	8f 70       	andi	r24, 0x0F	; 15
     6e2:	08 95       	ret

000006e4 <BCD2Char>:

char BCD2Char(char data){
     char Result;
	 Result=0;
	 if ((data>=0)&&(data<=9)) 
     6e4:	8a 30       	cpi	r24, 0x0A	; 10
     6e6:	10 f0       	brcs	.+4      	; 0x6ec <BCD2Char+0x8>
     6e8:	80 e3       	ldi	r24, 0x30	; 48
     6ea:	08 95       	ret
	     Result='0'+data;
     6ec:	80 5d       	subi	r24, 0xD0	; 208
     else Result='0';
	 return Result;
}
     6ee:	08 95       	ret

000006f0 <ShiftData>:

void ShiftData(char data){//data [0]..[10]
     6f0:	98 2f       	mov	r25, r24
     6f2:	ed e0       	ldi	r30, 0x0D	; 13
     6f4:	f4 e0       	ldi	r31, 0x04	; 4
     char i;
	 for(i=11;i>0;i--){//0..10
	    zDataBuffer[i]=zDataBuffer[i-1];
     6f6:	80 81       	ld	r24, Z
     6f8:	81 83       	std	Z+1, r24	; 0x01
     6fa:	31 97       	sbiw	r30, 0x01	; 1
	 return Result;
}

void ShiftData(char data){//data [0]..[10]
     char i;
	 for(i=11;i>0;i--){//0..10
     6fc:	84 e0       	ldi	r24, 0x04	; 4
     6fe:	e2 30       	cpi	r30, 0x02	; 2
     700:	f8 07       	cpc	r31, r24
     702:	c9 f7       	brne	.-14     	; 0x6f6 <ShiftData+0x6>
	    zDataBuffer[i]=zDataBuffer[i-1];
	 }
	 zDataBuffer[0]=data;
     704:	91 83       	std	Z+1, r25	; 0x01
}
     706:	08 95       	ret

00000708 <SetReceiveLine>:

void SetReceiveLine(char RecLine){
     stReceiveCom0=RecLine;
     708:	80 93 04 01 	sts	0x0104, r24
}
     70c:	08 95       	ret

0000070e <GetReceiveLine>:

char GetReceiveLine(){
     return stReceiveCom0;
}
     70e:	80 91 04 01 	lds	r24, 0x0104
     712:	08 95       	ret

00000714 <StrPosCopy>:



void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
     714:	cf 93       	push	r28
     716:	df 93       	push	r29
     718:	eb 01       	movw	r28, r22
     71a:	da 01       	movw	r26, r20
     71c:	a8 0f       	add	r26, r24
     71e:	b9 1f       	adc	r27, r25
     720:	40 e0       	ldi	r20, 0x00	; 0
     722:	50 e0       	ldi	r21, 0x00	; 0
     724:	07 c0       	rjmp	.+14     	; 0x734 <StrPosCopy+0x20>
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
     726:	fe 01       	movw	r30, r28
     728:	e4 0f       	add	r30, r20
     72a:	f5 1f       	adc	r31, r21
     72c:	8d 91       	ld	r24, X+
     72e:	80 83       	st	Z, r24



void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
     730:	4f 5f       	subi	r20, 0xFF	; 255
     732:	5f 4f       	sbci	r21, 0xFF	; 255
     734:	42 17       	cp	r20, r18
     736:	53 07       	cpc	r21, r19
     738:	b0 f3       	brcs	.-20     	; 0x726 <StrPosCopy+0x12>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
     73a:	c2 0f       	add	r28, r18
     73c:	d3 1f       	adc	r29, r19
     73e:	18 82       	st	Y, r1
}
     740:	df 91       	pop	r29
     742:	cf 91       	pop	r28
     744:	08 95       	ret

00000746 <CharPosCopy>:

char CharPosCopy(char *Source, unsigned int IdxSource){
     746:	fb 01       	movw	r30, r22
     748:	e8 0f       	add	r30, r24
     74a:	f9 1f       	adc	r31, r25
     char Result;
          Result=Source[IdxSource];
	 return Result;
}
     74c:	80 81       	ld	r24, Z
     74e:	08 95       	ret

00000750 <HexToChar>:
	 }
}

char HexToChar(char xHex){
char Result='0';
     if (xHex<10) Result='0'+xHex;
     750:	8a 30       	cpi	r24, 0x0A	; 10
     752:	10 f4       	brcc	.+4      	; 0x758 <HexToChar+0x8>
     754:	80 5d       	subi	r24, 0xD0	; 208
     756:	08 95       	ret
	 else 
	 if (xHex<16) Result='A'+(xHex-10); 
     758:	80 31       	cpi	r24, 0x10	; 16
     75a:	10 f0       	brcs	.+4      	; 0x760 <HexToChar+0x10>
     75c:	80 e3       	ldi	r24, 0x30	; 48
     75e:	08 95       	ret
     760:	89 5c       	subi	r24, 0xC9	; 201
	 else Result='0';
     return Result;
}
     762:	08 95       	ret

00000764 <StrPosCopyReverse>:

//Copy Reverse Filtered BCD String
void StrPosCopyReverse(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
     764:	cf 93       	push	r28
     766:	df 93       	push	r29
     768:	eb 01       	movw	r28, r22
     76a:	da 01       	movw	r26, r20
     76c:	a8 0f       	add	r26, r24
     76e:	b9 1f       	adc	r27, r25
     770:	40 e0       	ldi	r20, 0x00	; 0
     772:	50 e0       	ldi	r21, 0x00	; 0
     774:	0e c0       	rjmp	.+28     	; 0x792 <StrPosCopyReverse+0x2e>
	 Dest[Length]=0;
}

char FilterBCD(char data){
     char Result;
	 Result=(data&0x0F);
     776:	8c 91       	ld	r24, X
     778:	8f 70       	andi	r24, 0x0F	; 15
}

char BCD2Char(char data){
     char Result;
	 Result=0;
	 if ((data>=0)&&(data<=9)) 
     77a:	8a 30       	cpi	r24, 0x0A	; 10
     77c:	10 f0       	brcs	.+4      	; 0x782 <StrPosCopyReverse+0x1e>
     77e:	80 e3       	ldi	r24, 0x30	; 48
     780:	01 c0       	rjmp	.+2      	; 0x784 <StrPosCopyReverse+0x20>
	     Result='0'+data;
     782:	80 5d       	subi	r24, 0xD0	; 208

//Copy Reverse Filtered BCD String
void StrPosCopyReverse(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
     unsigned int i;
	 for (i=0;i<Length;i++){
	      Dest[i]=BCD2Char(FilterBCD(Source[IdxSource-i]));
     784:	fe 01       	movw	r30, r28
     786:	e4 0f       	add	r30, r20
     788:	f5 1f       	adc	r31, r21
     78a:	80 83       	st	Z, r24
}

//Copy Reverse Filtered BCD String
void StrPosCopyReverse(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
     unsigned int i;
	 for (i=0;i<Length;i++){
     78c:	4f 5f       	subi	r20, 0xFF	; 255
     78e:	5f 4f       	sbci	r21, 0xFF	; 255
     790:	11 97       	sbiw	r26, 0x01	; 1
     792:	42 17       	cp	r20, r18
     794:	53 07       	cpc	r21, r19
     796:	78 f3       	brcs	.-34     	; 0x776 <StrPosCopyReverse+0x12>
	      Dest[i]=BCD2Char(FilterBCD(Source[IdxSource-i]));
	 }Dest[Length]=0;
     798:	c2 0f       	add	r28, r18
     79a:	d3 1f       	adc	r29, r19
     79c:	18 82       	st	Y, r1
}
     79e:	df 91       	pop	r29
     7a0:	cf 91       	pop	r28
     7a2:	08 95       	ret

000007a4 <uartGilbarco>:
void StartupInfo(){
    _uart_printf(1,1,PSTR("Initialized"));
}

void uartGilbarco(){
}
     7a4:	08 95       	ret

000007a6 <FillChar>:

void FillChar(char *strMemory, unsigned int Length,char data){
     7a6:	20 e0       	ldi	r18, 0x00	; 0
     7a8:	30 e0       	ldi	r19, 0x00	; 0
     7aa:	06 c0       	rjmp	.+12     	; 0x7b8 <FillChar+0x12>
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
     7ac:	fc 01       	movw	r30, r24
     7ae:	e2 0f       	add	r30, r18
     7b0:	f3 1f       	adc	r31, r19
     7b2:	40 83       	st	Z, r20
void uartGilbarco(){
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
     7b4:	2f 5f       	subi	r18, 0xFF	; 255
     7b6:	3f 4f       	sbci	r19, 0xFF	; 255
     7b8:	26 17       	cp	r18, r22
     7ba:	37 07       	cpc	r19, r23
     7bc:	b8 f3       	brcs	.-18     	; 0x7ac <FillChar+0x6>
	     strMemory[i]=data;
	 }
}
     7be:	08 95       	ret

000007c0 <StartupInfo>:
	 }Dest[Length]=0;
}


void StartupInfo(){
    _uart_printf(1,1,PSTR("Initialized"));
     7c0:	81 e0       	ldi	r24, 0x01	; 1
     7c2:	61 e0       	ldi	r22, 0x01	; 1
     7c4:	4c e2       	ldi	r20, 0x2C	; 44
     7c6:	51 e0       	ldi	r21, 0x01	; 1
     7c8:	0e 94 97 18 	call	0x312e	; 0x312e <_uart_printf>
}
     7cc:	08 95       	ret

000007ce <AddZeroLead>:
	   }//Zeroed[Length-ZeroPos]=0;
	 }     
   }
}

void AddZeroLead(char *String,unsigned char Size){// 1234 ->0000001234
     7ce:	bf 92       	push	r11
     7d0:	cf 92       	push	r12
     7d2:	df 92       	push	r13
     7d4:	ef 92       	push	r14
     7d6:	ff 92       	push	r15
     7d8:	0f 93       	push	r16
     7da:	1f 93       	push	r17
     7dc:	df 93       	push	r29
     7de:	cf 93       	push	r28
     7e0:	cd b7       	in	r28, 0x3d	; 61
     7e2:	de b7       	in	r29, 0x3e	; 62
     7e4:	64 97       	sbiw	r28, 0x14	; 20
     7e6:	0f b6       	in	r0, 0x3f	; 63
     7e8:	f8 94       	cli
     7ea:	de bf       	out	0x3e, r29	; 62
     7ec:	0f be       	out	0x3f, r0	; 63
     7ee:	cd bf       	out	0x3d, r28	; 61
     7f0:	8c 01       	movw	r16, r24
     char i,Length,strAdded[20];
     Length=strlen(String);
     7f2:	fc 01       	movw	r30, r24
     7f4:	01 90       	ld	r0, Z+
     7f6:	00 20       	and	r0, r0
     7f8:	e9 f7       	brne	.-6      	; 0x7f4 <AddZeroLead+0x26>
     7fa:	31 97       	sbiw	r30, 0x01	; 1
     7fc:	2e 2f       	mov	r18, r30
     7fe:	28 1b       	sub	r18, r24

	 if (Size>Length){
     800:	26 17       	cp	r18, r22
     802:	e0 f5       	brcc	.+120    	; 0x87c <AddZeroLead+0xae>
     804:	7e 01       	movw	r14, r28
     806:	08 94       	sec
     808:	e1 1c       	adc	r14, r1
     80a:	f1 1c       	adc	r15, r1
     80c:	f7 01       	movw	r30, r14
	   }//Zeroed[Length-ZeroPos]=0;
	 }     
   }
}

void AddZeroLead(char *String,unsigned char Size){// 1234 ->0000001234
     80e:	be 2c       	mov	r11, r14
     char i,Length,strAdded[20];
     Length=strlen(String);

	 if (Size>Length){
         for(i=0;i<Size;i++){
	         strAdded[i]='0';
     810:	90 e3       	ldi	r25, 0x30	; 48
     812:	01 c0       	rjmp	.+2      	; 0x816 <AddZeroLead+0x48>
     814:	91 93       	st	Z+, r25
void AddZeroLead(char *String,unsigned char Size){// 1234 ->0000001234
     char i,Length,strAdded[20];
     Length=strlen(String);

	 if (Size>Length){
         for(i=0;i<Size;i++){
     816:	8e 2f       	mov	r24, r30
     818:	8b 19       	sub	r24, r11
     81a:	86 17       	cp	r24, r22
     81c:	d8 f3       	brcs	.-10     	; 0x814 <AddZeroLead+0x46>
	         strAdded[i]='0';
	     }strAdded[Size]=0;
     81e:	46 2f       	mov	r20, r22
     820:	50 e0       	ldi	r21, 0x00	; 0
     822:	ce 01       	movw	r24, r28
     824:	01 96       	adiw	r24, 0x01	; 1
     826:	fc 01       	movw	r30, r24
     828:	e4 0f       	add	r30, r20
     82a:	f5 1f       	adc	r31, r21
     82c:	10 82       	st	Z, r1
	     //Copy
         for(i=(Size-Length);i<Size;i++){
     82e:	76 2f       	mov	r23, r22
     830:	72 1b       	sub	r23, r18
     832:	6c 01       	movw	r12, r24
	         strAdded[i]=String[i-(Size-Length)];
     834:	30 e0       	ldi	r19, 0x00	; 0
     836:	24 1b       	sub	r18, r20
     838:	35 0b       	sbc	r19, r21
     83a:	0c c0       	rjmp	.+24     	; 0x854 <AddZeroLead+0x86>
     83c:	e7 2f       	mov	r30, r23
     83e:	f0 e0       	ldi	r31, 0x00	; 0
     840:	d6 01       	movw	r26, r12
     842:	ae 0f       	add	r26, r30
     844:	bf 1f       	adc	r27, r31
     846:	e0 0f       	add	r30, r16
     848:	f1 1f       	adc	r31, r17
     84a:	e2 0f       	add	r30, r18
     84c:	f3 1f       	adc	r31, r19
     84e:	80 81       	ld	r24, Z
     850:	8c 93       	st	X, r24
	 if (Size>Length){
         for(i=0;i<Size;i++){
	         strAdded[i]='0';
	     }strAdded[Size]=0;
	     //Copy
         for(i=(Size-Length);i<Size;i++){
     852:	7f 5f       	subi	r23, 0xFF	; 255
     854:	76 17       	cp	r23, r22
     856:	90 f3       	brcs	.-28     	; 0x83c <AddZeroLead+0x6e>
	         strAdded[i]=String[i-(Size-Length)];
	     }strAdded[Size]=0;
     858:	4c 0d       	add	r20, r12
     85a:	5d 1d       	adc	r21, r13
     85c:	da 01       	movw	r26, r20
     85e:	1c 92       	st	X, r1
     860:	f8 01       	movw	r30, r16
     862:	04 c0       	rjmp	.+8      	; 0x86c <AddZeroLead+0x9e>
	     //Zeroed
         for(i=0;i<Size;i++){
	         String[i]=strAdded[i];
     864:	d7 01       	movw	r26, r14
     866:	8d 91       	ld	r24, X+
     868:	7d 01       	movw	r14, r26
     86a:	81 93       	st	Z+, r24
	     //Copy
         for(i=(Size-Length);i<Size;i++){
	         strAdded[i]=String[i-(Size-Length)];
	     }strAdded[Size]=0;
	     //Zeroed
         for(i=0;i<Size;i++){
     86c:	8e 2d       	mov	r24, r14
     86e:	8b 19       	sub	r24, r11
     870:	86 17       	cp	r24, r22
     872:	c0 f3       	brcs	.-16     	; 0x864 <AddZeroLead+0x96>
	         String[i]=strAdded[i];
	     }String[Size]=0;
     874:	06 0f       	add	r16, r22
     876:	11 1d       	adc	r17, r1
     878:	f8 01       	movw	r30, r16
     87a:	10 82       	st	Z, r1
	 }
}
     87c:	64 96       	adiw	r28, 0x14	; 20
     87e:	0f b6       	in	r0, 0x3f	; 63
     880:	f8 94       	cli
     882:	de bf       	out	0x3e, r29	; 62
     884:	0f be       	out	0x3f, r0	; 63
     886:	cd bf       	out	0x3d, r28	; 61
     888:	cf 91       	pop	r28
     88a:	df 91       	pop	r29
     88c:	1f 91       	pop	r17
     88e:	0f 91       	pop	r16
     890:	ff 90       	pop	r15
     892:	ef 90       	pop	r14
     894:	df 90       	pop	r13
     896:	cf 90       	pop	r12
     898:	bf 90       	pop	r11
     89a:	08 95       	ret

0000089c <RemZeroLead>:
     char Result;
          Result=Source[IdxSource];
	 return Result;
}

void RemZeroLead(char *Zeroed){//Remove Zero Character 00001004 000050000 0 
     89c:	cf 93       	push	r28
     89e:	df 93       	push	r29
     8a0:	ec 01       	movw	r28, r24
unsigned char i=0,Length=0,ZeroPos=0,IsFound=False;;
     IsFound=False;
     ZeroPos=0;Length=strlen(Zeroed);
     8a2:	fc 01       	movw	r30, r24
     8a4:	01 90       	ld	r0, Z+
     8a6:	00 20       	and	r0, r0
     8a8:	e9 f7       	brne	.-6      	; 0x8a4 <RemZeroLead+0x8>
     8aa:	31 97       	sbiw	r30, 0x01	; 1
     8ac:	e8 1b       	sub	r30, r24
  if ((Length>1)&&(Zeroed[0]=='0')){
     8ae:	e2 30       	cpi	r30, 0x02	; 2
     8b0:	d0 f1       	brcs	.+116    	; 0x926 <RemZeroLead+0x8a>
     8b2:	88 81       	ld	r24, Y
     8b4:	80 33       	cpi	r24, 0x30	; 48
     8b6:	b9 f5       	brne	.+110    	; 0x926 <RemZeroLead+0x8a>
     8b8:	4c 2f       	mov	r20, r28
     8ba:	de 01       	movw	r26, r28
     8bc:	90 e0       	ldi	r25, 0x00	; 0
	 if (Zeroed[0]=='0'){
         for(i=0;i<Length;i++){//00000000->0
	         if ((Zeroed[i]=='0')&&(Zeroed[i+1]=='0')&&(IsFound==False)) ZeroPos++;
     8be:	8c 91       	ld	r24, X
     8c0:	80 33       	cpi	r24, 0x30	; 48
     8c2:	69 f4       	brne	.+26     	; 0x8de <RemZeroLead+0x42>
     8c4:	11 96       	adiw	r26, 0x01	; 1
     8c6:	8c 91       	ld	r24, X
     8c8:	11 97       	sbiw	r26, 0x01	; 1
     8ca:	80 33       	cpi	r24, 0x30	; 48
     8cc:	11 f4       	brne	.+4      	; 0x8d2 <RemZeroLead+0x36>
     8ce:	9f 5f       	subi	r25, 0xFF	; 255
     8d0:	06 c0       	rjmp	.+12     	; 0x8de <RemZeroLead+0x42>
             if ((Zeroed[i]=='0')&&(Zeroed[i+1]!='0')){
			     if ((Zeroed[i+1]=='.')||(Zeroed[i+1]==','))ZeroPos--;
     8d2:	8e 32       	cpi	r24, 0x2E	; 46
     8d4:	11 f0       	breq	.+4      	; 0x8da <RemZeroLead+0x3e>
     8d6:	8c 32       	cpi	r24, 0x2C	; 44
     8d8:	41 f4       	brne	.+16     	; 0x8ea <RemZeroLead+0x4e>
     8da:	91 50       	subi	r25, 0x01	; 1
     8dc:	06 c0       	rjmp	.+12     	; 0x8ea <RemZeroLead+0x4e>
     8de:	11 96       	adiw	r26, 0x01	; 1
unsigned char i=0,Length=0,ZeroPos=0,IsFound=False;;
     IsFound=False;
     ZeroPos=0;Length=strlen(Zeroed);
  if ((Length>1)&&(Zeroed[0]=='0')){
	 if (Zeroed[0]=='0'){
         for(i=0;i<Length;i++){//00000000->0
     8e0:	8a 2f       	mov	r24, r26
     8e2:	84 1b       	sub	r24, r20
     8e4:	8e 17       	cp	r24, r30
     8e6:	58 f3       	brcs	.-42     	; 0x8be <RemZeroLead+0x22>
     8e8:	01 c0       	rjmp	.+2      	; 0x8ec <RemZeroLead+0x50>
		         IsFound=True;
			     break;			  
			     }
	      }

		  if (IsFound==True)ZeroPos++;
     8ea:	9f 5f       	subi	r25, 0xFF	; 255
		  if (ZeroPos>=Length)ZeroPos=Length-1;
     8ec:	9e 17       	cp	r25, r30
     8ee:	10 f0       	brcs	.+4      	; 0x8f4 <RemZeroLead+0x58>
     8f0:	9e 2f       	mov	r25, r30
     8f2:	91 50       	subi	r25, 0x01	; 1
     8f4:	40 e0       	ldi	r20, 0x00	; 0
          for(i=0;i<(Length-ZeroPos);i++){
     8f6:	89 2f       	mov	r24, r25
     8f8:	90 e0       	ldi	r25, 0x00	; 0
     8fa:	2e 2f       	mov	r18, r30
     8fc:	30 e0       	ldi	r19, 0x00	; 0
     8fe:	28 1b       	sub	r18, r24
     900:	39 0b       	sbc	r19, r25
	          Zeroed[i]=Zeroed[i+ZeroPos];
     902:	be 01       	movw	r22, r28
     904:	68 0f       	add	r22, r24
     906:	79 1f       	adc	r23, r25
     908:	09 c0       	rjmp	.+18     	; 0x91c <RemZeroLead+0x80>
     90a:	fe 01       	movw	r30, r28
     90c:	ea 0f       	add	r30, r26
     90e:	fb 1f       	adc	r31, r27
     910:	a6 0f       	add	r26, r22
     912:	b7 1f       	adc	r27, r23
     914:	8c 91       	ld	r24, X
     916:	80 83       	st	Z, r24
		      Zeroed[i+1]=0;
     918:	11 82       	std	Z+1, r1	; 0x01
			     }
	      }

		  if (IsFound==True)ZeroPos++;
		  if (ZeroPos>=Length)ZeroPos=Length-1;
          for(i=0;i<(Length-ZeroPos);i++){
     91a:	4f 5f       	subi	r20, 0xFF	; 255
     91c:	a4 2f       	mov	r26, r20
     91e:	b0 e0       	ldi	r27, 0x00	; 0
     920:	a2 17       	cp	r26, r18
     922:	b3 07       	cpc	r27, r19
     924:	94 f3       	brlt	.-28     	; 0x90a <RemZeroLead+0x6e>
	          Zeroed[i]=Zeroed[i+ZeroPos];
		      Zeroed[i+1]=0;
	   }//Zeroed[Length-ZeroPos]=0;
	 }     
   }
}
     926:	df 91       	pop	r29
     928:	cf 91       	pop	r28
     92a:	08 95       	ret

0000092c <WayneOnReceive>:
	     Dest[2*i]=(Source[FirstPos+i]>>4)+'0';
	     Dest[(2*i)+1]=(Source[FirstPos+i]&0x0F)+'0';	 
	 }Dest[2*nCount]=0;
}

void WayneOnReceive(char WayneDataIn){
     92c:	0f 93       	push	r16
     92e:	1f 93       	push	r17
     static unsigned int tCRC=0xFFFF;
     char i,strSend[40],rxNozzleID=0;
     static char zReceive=wrWaitSTX;
     static rcvBuffer[11];

		WayneRxBuffer[rxBufferLength]=WayneDataIn;// 03 FA
     930:	90 91 15 01 	lds	r25, 0x0115
     934:	e9 2f       	mov	r30, r25
     936:	f0 e0       	ldi	r31, 0x00	; 0
     938:	e3 5c       	subi	r30, 0xC3	; 195
     93a:	fe 4f       	sbci	r31, 0xFE	; 254
     93c:	80 83       	st	Z, r24
		if (rxBufferLength<70)
     93e:	96 34       	cpi	r25, 0x46	; 70
     940:	18 f4       	brcc	.+6      	; 0x948 <WayneOnReceive+0x1c>
		    rxBufferLength++;
     942:	9f 5f       	subi	r25, 0xFF	; 255
     944:	90 93 15 01 	sts	0x0115, r25
        
		if ((WayneRxBuffer[rxBufferLength-2]==0x03)&&(WayneDataIn==0xFA)){
     948:	20 91 15 01 	lds	r18, 0x0115
     94c:	e2 2f       	mov	r30, r18
     94e:	f0 e0       	ldi	r31, 0x00	; 0
     950:	e3 5c       	subi	r30, 0xC3	; 195
     952:	fe 4f       	sbci	r31, 0xFE	; 254
     954:	32 97       	sbiw	r30, 0x02	; 2
     956:	90 81       	ld	r25, Z
     958:	32 96       	adiw	r30, 0x02	; 2
     95a:	93 30       	cpi	r25, 0x03	; 3
     95c:	09 f0       	breq	.+2      	; 0x960 <WayneOnReceive+0x34>
     95e:	a3 c0       	rjmp	.+326    	; 0xaa6 <WayneOnReceive+0x17a>
     960:	8a 3f       	cpi	r24, 0xFA	; 250
     962:	09 f0       	breq	.+2      	; 0x966 <WayneOnReceive+0x3a>
     964:	ab c0       	rjmp	.+342    	; 0xabc <WayneOnReceive+0x190>
			WayneRxSequence=WayneRxBuffer[1]&0x0F;
     966:	80 91 3e 01 	lds	r24, 0x013E
     96a:	8f 70       	andi	r24, 0x0F	; 15
     96c:	80 93 18 01 	sts	0x0118, r24
			//Message Identification
			MsgID[0]=WayneRxBuffer[2];
     970:	00 91 3f 01 	lds	r16, 0x013F
     974:	00 93 33 01 	sts	0x0133, r16
			MsgID[1]=WayneRxBuffer[3];
     978:	90 91 40 01 	lds	r25, 0x0140
     97c:	90 93 34 01 	sts	0x0134, r25
			  0 51 3E 01 01 00 03 04 00 46 00 
			  1 02 02 08 00 00 01 54 00 00 70 
			  2 84 03 04 00 46 00 02 09 05 00 
			  3 00 02 00 00 53 66 03 FA 
			*/
            MsgInfo=MI_UNKNOWN;
     980:	87 e0       	ldi	r24, 0x07	; 7
     982:	80 93 19 01 	sts	0x0119, r24
            if ((MsgID[0]==0x06)&&(MsgID[1]==0x1F)&&(rxBufferLength>=57)){
     986:	06 30       	cpi	r16, 0x06	; 6
     988:	71 f5       	brne	.+92     	; 0x9e6 <WayneOnReceive+0xba>
     98a:	9f 31       	cpi	r25, 0x1F	; 31
     98c:	09 f0       	breq	.+2      	; 0x990 <WayneOnReceive+0x64>
     98e:	89 c0       	rjmp	.+274    	; 0xaa2 <WayneOnReceive+0x176>
     990:	29 33       	cpi	r18, 0x39	; 57
     992:	08 f4       	brcc	.+2      	; 0x996 <WayneOnReceive+0x6a>
     994:	86 c0       	rjmp	.+268    	; 0xaa2 <WayneOnReceive+0x176>
			     MsgInfo=MI_TOTALIZER;
     996:	88 e0       	ldi	r24, 0x08	; 8
     998:	80 93 19 01 	sts	0x0119, r24
			     rxNozzleID=(WayneRxBuffer[37]&0x0F);
				 ExtractValue(WayneRxBuffer,38,5,PumpTotalizer.TotalGrade[rxNozzleID-1].strVolume);		
     99c:	00 91 62 01 	lds	r16, 0x0162
     9a0:	0f 70       	andi	r16, 0x0F	; 15
     9a2:	10 e0       	ldi	r17, 0x00	; 0
     9a4:	c8 01       	movw	r24, r16
     9a6:	01 97       	sbiw	r24, 0x01	; 1
     9a8:	9c 01       	movw	r18, r24
     9aa:	55 e0       	ldi	r21, 0x05	; 5
     9ac:	22 0f       	add	r18, r18
     9ae:	33 1f       	adc	r19, r19
     9b0:	5a 95       	dec	r21
     9b2:	e1 f7       	brne	.-8      	; 0x9ac <WayneOnReceive+0x80>
     9b4:	88 0f       	add	r24, r24
     9b6:	99 1f       	adc	r25, r25
     9b8:	28 1b       	sub	r18, r24
     9ba:	39 0b       	sbc	r19, r25
     9bc:	29 50       	subi	r18, 0x09	; 9
     9be:	3d 4f       	sbci	r19, 0xFD	; 253
     9c0:	8d e3       	ldi	r24, 0x3D	; 61
     9c2:	91 e0       	ldi	r25, 0x01	; 1
     9c4:	66 e2       	ldi	r22, 0x26	; 38
     9c6:	45 e0       	ldi	r20, 0x05	; 5
     9c8:	0e 94 b0 01 	call	0x360	; 0x360 <ExtractValue>
				 RemZeroLead(PumpTotalizer.TotalGrade[rxNozzleID].strVolume);
     9cc:	c8 01       	movw	r24, r16
     9ce:	35 e0       	ldi	r19, 0x05	; 5
     9d0:	88 0f       	add	r24, r24
     9d2:	99 1f       	adc	r25, r25
     9d4:	3a 95       	dec	r19
     9d6:	e1 f7       	brne	.-8      	; 0x9d0 <WayneOnReceive+0xa4>
     9d8:	00 0f       	add	r16, r16
     9da:	11 1f       	adc	r17, r17
     9dc:	80 1b       	sub	r24, r16
     9de:	91 0b       	sbc	r25, r17
     9e0:	89 50       	subi	r24, 0x09	; 9
     9e2:	9d 4f       	sbci	r25, 0xFD	; 253
     9e4:	38 c0       	rjmp	.+112    	; 0xa56 <WayneOnReceive+0x12a>
			     sprintf_P(strSend,PSTR("Totalizer%d:[V:%s]"),rxNozzleID,PumpTotalizer.TotalGrade[rxNozzleID].strVolume);
			     _uart_print(1,1,strSend);
				 #endif

			}
            if ((MsgID[0]==0x01)&&(MsgID[1]==0x01)&&(rxBufferLength>=38)){//Last Transaction
     9e6:	01 30       	cpi	r16, 0x01	; 1
     9e8:	a9 f4       	brne	.+42     	; 0xa14 <WayneOnReceive+0xe8>
     9ea:	91 30       	cpi	r25, 0x01	; 1
     9ec:	09 f0       	breq	.+2      	; 0x9f0 <WayneOnReceive+0xc4>
     9ee:	59 c0       	rjmp	.+178    	; 0xaa2 <WayneOnReceive+0x176>
     9f0:	26 32       	cpi	r18, 0x26	; 38
     9f2:	08 f4       	brcc	.+2      	; 0x9f6 <WayneOnReceive+0xca>
     9f4:	56 c0       	rjmp	.+172    	; 0xaa2 <WayneOnReceive+0x176>
			     //Vol:13-16 Amount:17-20
				 MsgInfo=MI_LAST_TRANSACTION;
     9f6:	86 e0       	ldi	r24, 0x06	; 6
     9f8:	80 93 19 01 	sts	0x0119, r24
				 ExtractValue(WayneRxBuffer,13,4,strVolume);
     9fc:	8d e3       	ldi	r24, 0x3D	; 61
     9fe:	91 e0       	ldi	r25, 0x01	; 1
     a00:	6d e0       	ldi	r22, 0x0D	; 13
     a02:	44 e0       	ldi	r20, 0x04	; 4
     a04:	27 e5       	ldi	r18, 0x57	; 87
     a06:	32 e0       	ldi	r19, 0x02	; 2
     a08:	0e 94 b0 01 	call	0x360	; 0x360 <ExtractValue>
				 ExtractValue(WayneRxBuffer,17,4,strAmount);
     a0c:	8d e3       	ldi	r24, 0x3D	; 61
     a0e:	91 e0       	ldi	r25, 0x01	; 1
     a10:	61 e1       	ldi	r22, 0x11	; 17
     a12:	16 c0       	rjmp	.+44     	; 0xa40 <WayneOnReceive+0x114>
			     _uart_print(1,1,strSend);
				 #endif

			}   // 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18
			    //51 34 02 08 00 00 01 88 00 00 84 60 01 01 05 38 4E 03 FA 
			if ((MsgID[0]==0x02)&&(MsgID[1]==0x08)&&(rxBufferLength>=19)){//Last Transaction
     a14:	02 30       	cpi	r16, 0x02	; 2
     a16:	11 f5       	brne	.+68     	; 0xa5c <WayneOnReceive+0x130>
     a18:	98 30       	cpi	r25, 0x08	; 8
     a1a:	09 f0       	breq	.+2      	; 0xa1e <WayneOnReceive+0xf2>
     a1c:	42 c0       	rjmp	.+132    	; 0xaa2 <WayneOnReceive+0x176>
     a1e:	23 31       	cpi	r18, 0x13	; 19
     a20:	08 f4       	brcc	.+2      	; 0xa24 <WayneOnReceive+0xf8>
     a22:	3f c0       	rjmp	.+126    	; 0xaa2 <WayneOnReceive+0x176>
			     //Vol:13-16 Amount:17-20
				 MsgInfo=MI_LAST_TRANSACTION;
     a24:	86 e0       	ldi	r24, 0x06	; 6
     a26:	80 93 19 01 	sts	0x0119, r24
				 ExtractValue(WayneRxBuffer,4,4,strVolume);
     a2a:	8d e3       	ldi	r24, 0x3D	; 61
     a2c:	91 e0       	ldi	r25, 0x01	; 1
     a2e:	64 e0       	ldi	r22, 0x04	; 4
     a30:	44 e0       	ldi	r20, 0x04	; 4
     a32:	27 e5       	ldi	r18, 0x57	; 87
     a34:	32 e0       	ldi	r19, 0x02	; 2
     a36:	0e 94 b0 01 	call	0x360	; 0x360 <ExtractValue>
				 ExtractValue(WayneRxBuffer,8,4,strAmount);
     a3a:	8d e3       	ldi	r24, 0x3D	; 61
     a3c:	91 e0       	ldi	r25, 0x01	; 1
     a3e:	68 e0       	ldi	r22, 0x08	; 8
     a40:	44 e0       	ldi	r20, 0x04	; 4
     a42:	2b ea       	ldi	r18, 0xAB	; 171
     a44:	33 e0       	ldi	r19, 0x03	; 3
     a46:	0e 94 b0 01 	call	0x360	; 0x360 <ExtractValue>
				 RemZeroLead(strVolume);
     a4a:	87 e5       	ldi	r24, 0x57	; 87
     a4c:	92 e0       	ldi	r25, 0x02	; 2
     a4e:	0e 94 4e 04 	call	0x89c	; 0x89c <RemZeroLead>
				 RemZeroLead(strAmount);
     a52:	8b ea       	ldi	r24, 0xAB	; 171
     a54:	93 e0       	ldi	r25, 0x03	; 3
     a56:	0e 94 4e 04 	call	0x89c	; 0x89c <RemZeroLead>
     a5a:	23 c0       	rjmp	.+70     	; 0xaa2 <WayneOnReceive+0x176>
			     sprintf_P(strSend,PSTR("Trans:[V:%s][A:%s]"),strVolume,strAmount);
			     _uart_print(1,1,strSend);
				 #endif
			}			

            if ((MsgID[0]==0x03)&&(MsgID[1]==0x04)){//PriceNozzleInfo
     a5c:	03 30       	cpi	r16, 0x03	; 3
     a5e:	09 f5       	brne	.+66     	; 0xaa2 <WayneOnReceive+0x176>
     a60:	94 30       	cpi	r25, 0x04	; 4
     a62:	f9 f4       	brne	.+62     	; 0xaa2 <WayneOnReceive+0x176>
			     if ((WayneRxBuffer[7]>>4)==0x01){
     a64:	80 91 44 01 	lds	r24, 0x0144
     a68:	82 95       	swap	r24
     a6a:	8f 70       	andi	r24, 0x0F	; 15
     a6c:	81 30       	cpi	r24, 0x01	; 1
     a6e:	21 f4       	brne	.+8      	; 0xa78 <WayneOnReceive+0x14c>
				      MsgInfo=MI_NOZZLE_UP;
     a70:	82 e0       	ldi	r24, 0x02	; 2
     a72:	80 93 19 01 	sts	0x0119, r24
     a76:	10 c0       	rjmp	.+32     	; 0xa98 <WayneOnReceive+0x16c>
					  #ifdef DEBUG_WAYNE_RECEIVE 
					  _uart_printf(1,1,PSTR("-WR_MESSAGE Nozzle Up-"));
					  #endif
					  }
                 else
			     if ((WayneRxBuffer[7]>>4)==0x00){
     a78:	88 23       	and	r24, r24
     a7a:	71 f4       	brne	.+28     	; 0xa98 <WayneOnReceive+0x16c>
				      //Price
					  ExtractValue(WayneRxBuffer,4,3,strUnitPrice);
     a7c:	8d e3       	ldi	r24, 0x3D	; 61
     a7e:	91 e0       	ldi	r25, 0x01	; 1
     a80:	64 e0       	ldi	r22, 0x04	; 4
     a82:	43 e0       	ldi	r20, 0x03	; 3
     a84:	2c ea       	ldi	r18, 0xAC	; 172
     a86:	32 e0       	ldi	r19, 0x02	; 2
     a88:	0e 94 b0 01 	call	0x360	; 0x360 <ExtractValue>
					  RemZeroLead(strUnitPrice);
     a8c:	8c ea       	ldi	r24, 0xAC	; 172
     a8e:	92 e0       	ldi	r25, 0x02	; 2
     a90:	0e 94 4e 04 	call	0x89c	; 0x89c <RemZeroLead>
					  #ifdef DEBUG_WAYNE_RECEIVE
			          sprintf_P(strSend,PSTR("Price%s"),strUnitPrice);
			          _uart_print(1,1,strSend);
					  #endif
				      MsgInfo=MI_NOZZLE_DOWN;
     a94:	00 93 19 01 	sts	0x0119, r16
					  #ifdef DEBUG_WAYNE_RECEIVE 
					  _uart_printf(1,1,PSTR("-WR_MESSAGE Nozzle Down-"));
					  #endif
					  }
            ActiveNozzle=WayneRxBuffer[7]&0x0F;
     a98:	80 91 44 01 	lds	r24, 0x0144
     a9c:	8f 70       	andi	r24, 0x0F	; 15
     a9e:	80 93 1c 01 	sts	0x011C, r24
            }
        WayneReply=WR_MESSAGE;
     aa2:	84 e0       	ldi	r24, 0x04	; 4
     aa4:	07 c0       	rjmp	.+14     	; 0xab4 <WayneOnReceive+0x188>
		rxBufferLength=0;	
		}else
		if ((WayneRxBuffer[rxBufferLength-2]==0x70)&&(WayneRxBuffer[rxBufferLength-1]==0xFA)){
     aa6:	90 37       	cpi	r25, 0x70	; 112
     aa8:	49 f4       	brne	.+18     	; 0xabc <WayneOnReceive+0x190>
     aaa:	31 97       	sbiw	r30, 0x01	; 1
     aac:	80 81       	ld	r24, Z
     aae:	8a 3f       	cpi	r24, 0xFA	; 250
     ab0:	29 f4       	brne	.+10     	; 0xabc <WayneOnReceive+0x190>
		
		    #ifdef DEBUG_WAYNE_RECEIVE 
			_uart_printf(1,1,PSTR("-WR_READY-"));
			#endif
		    WayneReply=WR_READY;
     ab2:	81 e0       	ldi	r24, 0x01	; 1
     ab4:	80 93 1a 01 	sts	0x011A, r24
		    rxBufferLength=0;
     ab8:	10 92 15 01 	sts	0x0115, r1
		}
		if (((WayneRxBuffer[rxBufferLength-3]&0xF0)==0x50)&&(WayneRxBuffer[rxBufferLength-1]==0xFA)){
     abc:	80 91 15 01 	lds	r24, 0x0115
     ac0:	a8 2f       	mov	r26, r24
     ac2:	b0 e0       	ldi	r27, 0x00	; 0
     ac4:	a3 5c       	subi	r26, 0xC3	; 195
     ac6:	be 4f       	sbci	r27, 0xFE	; 254
     ac8:	13 97       	sbiw	r26, 0x03	; 3
     aca:	8c 91       	ld	r24, X
     acc:	13 96       	adiw	r26, 0x03	; 3
     ace:	80 7f       	andi	r24, 0xF0	; 240
     ad0:	80 35       	cpi	r24, 0x50	; 80
     ad2:	c1 f4       	brne	.+48     	; 0xb04 <WayneOnReceive+0x1d8>
     ad4:	fd 01       	movw	r30, r26
     ad6:	31 97       	sbiw	r30, 0x01	; 1
     ad8:	80 81       	ld	r24, Z
     ada:	8a 3f       	cpi	r24, 0xFA	; 250
     adc:	99 f4       	brne	.+38     	; 0xb04 <WayneOnReceive+0x1d8>
              if ((WayneRxBuffer[rxBufferLength-2]&0xF0)==0xC0){
     ade:	fd 01       	movw	r30, r26
     ae0:	32 97       	sbiw	r30, 0x02	; 2
     ae2:	80 81       	ld	r24, Z
     ae4:	90 e0       	ldi	r25, 0x00	; 0
     ae6:	80 7f       	andi	r24, 0xF0	; 240
     ae8:	90 70       	andi	r25, 0x00	; 0
     aea:	80 3c       	cpi	r24, 0xC0	; 192
     aec:	91 05       	cpc	r25, r1
     aee:	11 f4       	brne	.+4      	; 0xaf4 <WayneOnReceive+0x1c8>
		         #ifdef DEBUG_WAYNE_RECEIVE 
				 _uart_printf(1,1,PSTR("-WR_ACK-"));
				 #endif
		         WayneReply=WR_ACK;
     af0:	82 e0       	ldi	r24, 0x02	; 2
     af2:	04 c0       	rjmp	.+8      	; 0xafc <WayneOnReceive+0x1d0>
			 }else if ((WayneRxBuffer[rxBufferLength-2]&0xF0)==0x50){
     af4:	80 35       	cpi	r24, 0x50	; 80
     af6:	91 05       	cpc	r25, r1
     af8:	19 f4       	brne	.+6      	; 0xb00 <WayneOnReceive+0x1d4>
		         #ifdef DEBUG_WAYNE_RECEIVE 
				 _uart_printf(1,1,PSTR("-WR_NACK-"));
				 #endif
		         WayneReply=WR_NACK;
     afa:	83 e0       	ldi	r24, 0x03	; 3
     afc:	80 93 1a 01 	sts	0x011A, r24
			 }
             rxBufferLength=0;
     b00:	10 92 15 01 	sts	0x0115, r1
		}
}
     b04:	1f 91       	pop	r17
     b06:	0f 91       	pop	r16
     b08:	08 95       	ret

00000b0a <StrReverse>:
}

void systemServiceSPI(){
}

void StrReverse(char *strSource){// 0054->4500
     b0a:	df 93       	push	r29
     b0c:	cf 93       	push	r28
     b0e:	cd b7       	in	r28, 0x3d	; 61
     b10:	de b7       	in	r29, 0x3e	; 62
     b12:	64 97       	sbiw	r28, 0x14	; 20
     b14:	0f b6       	in	r0, 0x3f	; 63
     b16:	f8 94       	cli
     b18:	de bf       	out	0x3e, r29	; 62
     b1a:	0f be       	out	0x3f, r0	; 63
     b1c:	cd bf       	out	0x3d, r28	; 61
     b1e:	ac 01       	movw	r20, r24
     char i,Length,strResult[20];
	 Length=strlen(strSource);
     b20:	fc 01       	movw	r30, r24
     b22:	01 90       	ld	r0, Z+
     b24:	00 20       	and	r0, r0
     b26:	e9 f7       	brne	.-6      	; 0xb22 <StrReverse+0x18>
     b28:	31 97       	sbiw	r30, 0x01	; 1
     b2a:	2e 2f       	mov	r18, r30
     b2c:	28 1b       	sub	r18, r24
     b2e:	a2 2f       	mov	r26, r18
     b30:	b0 e0       	ldi	r27, 0x00	; 0
     b32:	11 97       	sbiw	r26, 0x01	; 1
     b34:	a8 0f       	add	r26, r24
     b36:	b9 1f       	adc	r27, r25
     b38:	be 01       	movw	r22, r28
     b3a:	6f 5f       	subi	r22, 0xFF	; 255
     b3c:	7f 4f       	sbci	r23, 0xFF	; 255
     b3e:	fb 01       	movw	r30, r22
     b40:	03 c0       	rjmp	.+6      	; 0xb48 <StrReverse+0x3e>
	 for(i=0;i<Length;i++){
	    strResult[i]=strSource[Length-i-1];
     b42:	8c 91       	ld	r24, X
     b44:	81 93       	st	Z+, r24
     b46:	11 97       	sbiw	r26, 0x01	; 1
}

void StrReverse(char *strSource){// 0054->4500
     char i,Length,strResult[20];
	 Length=strlen(strSource);
	 for(i=0;i<Length;i++){
     b48:	8e 2f       	mov	r24, r30
     b4a:	86 1b       	sub	r24, r22
     b4c:	82 17       	cp	r24, r18
     b4e:	c8 f3       	brcs	.-14     	; 0xb42 <StrReverse+0x38>
	    strResult[i]=strSource[Length-i-1];
	 }strResult[Length]=0;
     b50:	ce 01       	movw	r24, r28
     b52:	01 96       	adiw	r24, 0x01	; 1
     b54:	fc 01       	movw	r30, r24
     b56:	e2 0f       	add	r30, r18
     b58:	f1 1d       	adc	r31, r1
     b5a:	10 82       	st	Z, r1
     b5c:	60 e0       	ldi	r22, 0x00	; 0
	 //CopyResult
	 for(i=0;i<strlen(strResult);i++){
     b5e:	9c 01       	movw	r18, r24
     b60:	09 c0       	rjmp	.+18     	; 0xb74 <StrReverse+0x6a>
	    strSource[i]=strResult[i];
     b62:	fa 01       	movw	r30, r20
     b64:	ea 0f       	add	r30, r26
     b66:	fb 1f       	adc	r31, r27
     b68:	a2 0f       	add	r26, r18
     b6a:	b3 1f       	adc	r27, r19
     b6c:	8c 91       	ld	r24, X
     b6e:	80 83       	st	Z, r24
	    strSource[i+1]=0;
     b70:	11 82       	std	Z+1, r1	; 0x01
	 Length=strlen(strSource);
	 for(i=0;i<Length;i++){
	    strResult[i]=strSource[Length-i-1];
	 }strResult[Length]=0;
	 //CopyResult
	 for(i=0;i<strlen(strResult);i++){
     b72:	6f 5f       	subi	r22, 0xFF	; 255
     b74:	a6 2f       	mov	r26, r22
     b76:	b0 e0       	ldi	r27, 0x00	; 0
     b78:	f9 01       	movw	r30, r18
     b7a:	01 90       	ld	r0, Z+
     b7c:	00 20       	and	r0, r0
     b7e:	e9 f7       	brne	.-6      	; 0xb7a <StrReverse+0x70>
     b80:	31 97       	sbiw	r30, 0x01	; 1
     b82:	e2 1b       	sub	r30, r18
     b84:	f3 0b       	sbc	r31, r19
     b86:	ae 17       	cp	r26, r30
     b88:	bf 07       	cpc	r27, r31
     b8a:	58 f3       	brcs	.-42     	; 0xb62 <StrReverse+0x58>
	    strSource[i]=strResult[i];
	    strSource[i+1]=0;
	 }
}
     b8c:	64 96       	adiw	r28, 0x14	; 20
     b8e:	0f b6       	in	r0, 0x3f	; 63
     b90:	f8 94       	cli
     b92:	de bf       	out	0x3e, r29	; 62
     b94:	0f be       	out	0x3f, r0	; 63
     b96:	cd bf       	out	0x3d, r28	; 61
     b98:	cf 91       	pop	r28
     b9a:	df 91       	pop	r29
     b9c:	08 95       	ret

00000b9e <GilbarcoOnReceive>:
	else
	if (data==0xF5)SavePipeline=spTotalizerPPU2;
	
}

void GilbarcoOnReceive(char data){
     b9e:	1f 93       	push	r17
     ba0:	cf 93       	push	r28
     ba2:	df 93       	push	r29
     ba4:	18 2f       	mov	r17, r24
     ba6:	ed e0       	ldi	r30, 0x0D	; 13
     ba8:	f4 e0       	ldi	r31, 0x04	; 4
}

void ShiftData(char data){//data [0]..[10]
     char i;
	 for(i=11;i>0;i--){//0..10
	    zDataBuffer[i]=zDataBuffer[i-1];
     baa:	80 81       	ld	r24, Z
     bac:	81 83       	std	Z+1, r24	; 0x01
     bae:	31 97       	sbiw	r30, 0x01	; 1
	 return Result;
}

void ShiftData(char data){//data [0]..[10]
     char i;
	 for(i=11;i>0;i--){//0..10
     bb0:	84 e0       	ldi	r24, 0x04	; 4
     bb2:	e2 30       	cpi	r30, 0x02	; 2
     bb4:	f8 07       	cpc	r31, r24
     bb6:	c9 f7       	brne	.-14     	; 0xbaa <GilbarcoOnReceive+0xc>
	    zDataBuffer[i]=zDataBuffer[i-1];
	 }
	 zDataBuffer[0]=data;
     bb8:	11 83       	std	Z+1, r17	; 0x01
void GilbarcoOnReceive(char data){
char strSend[30],chrData,i;
static char iReceive=0;
    ShiftData(data);
	 
    switch(stReceiveCom0){
     bba:	90 91 04 01 	lds	r25, 0x0104
     bbe:	93 30       	cpi	r25, 0x03	; 3
     bc0:	d1 f1       	breq	.+116    	; 0xc36 <GilbarcoOnReceive+0x98>
     bc2:	94 30       	cpi	r25, 0x04	; 4
     bc4:	30 f4       	brcc	.+12     	; 0xbd2 <GilbarcoOnReceive+0x34>
     bc6:	91 30       	cpi	r25, 0x01	; 1
     bc8:	69 f0       	breq	.+26     	; 0xbe4 <GilbarcoOnReceive+0x46>
     bca:	92 30       	cpi	r25, 0x02	; 2
     bcc:	09 f0       	breq	.+2      	; 0xbd0 <GilbarcoOnReceive+0x32>
     bce:	9f c0       	rjmp	.+318    	; 0xd0e <GilbarcoOnReceive+0x170>
     bd0:	14 c0       	rjmp	.+40     	; 0xbfa <GilbarcoOnReceive+0x5c>
     bd2:	95 30       	cpi	r25, 0x05	; 5
     bd4:	09 f4       	brne	.+2      	; 0xbd8 <GilbarcoOnReceive+0x3a>
     bd6:	47 c0       	rjmp	.+142    	; 0xc66 <GilbarcoOnReceive+0xc8>
     bd8:	95 30       	cpi	r25, 0x05	; 5
     bda:	c0 f1       	brcs	.+112    	; 0xc4c <GilbarcoOnReceive+0xae>
     bdc:	96 30       	cpi	r25, 0x06	; 6
     bde:	09 f0       	breq	.+2      	; 0xbe2 <GilbarcoOnReceive+0x44>
     be0:	96 c0       	rjmp	.+300    	; 0xd0e <GilbarcoOnReceive+0x170>
     be2:	78 c0       	rjmp	.+240    	; 0xcd4 <GilbarcoOnReceive+0x136>
	case rcIdle:
	     CMDResponse=GetResponse(data);
     be4:	81 2f       	mov	r24, r17
     be6:	82 95       	swap	r24
     be8:	8f 70       	andi	r24, 0x0F	; 15
     bea:	80 93 8d 01 	sts	0x018D, r24
		 PumpID=GetPumpID(data);
     bee:	1f 70       	andi	r17, 0x0F	; 15
     bf0:	10 93 0e 01 	sts	0x010E, r17
		 #ifdef DEBUG_GILBARCO_RESPONSE
		 sprintf_P(strSend,PSTR("Response:%.2X"),data);
		 _uart_print(1,1,strSend);
		 #endif
		 IsStatusReceived=True;
     bf4:	90 93 0f 01 	sts	0x010F, r25
     bf8:	8a c0       	rjmp	.+276    	; 0xd0e <GilbarcoOnReceive+0x170>

	     break;	
	case rcRealTimeMoney:	     
	     strCurrentMoney[Com0ReceiveCount]=BCD2Char(FilterBCD(data));
     bfa:	90 91 23 01 	lds	r25, 0x0123
     bfe:	e9 2f       	mov	r30, r25
     c00:	f0 e0       	ldi	r31, 0x00	; 0
	 Dest[Length]=0;
}

char FilterBCD(char data){
     char Result;
	 Result=(data&0x0F);
     c02:	81 2f       	mov	r24, r17
     c04:	8f 70       	andi	r24, 0x0F	; 15
}

char BCD2Char(char data){
     char Result;
	 Result=0;
	 if ((data>=0)&&(data<=9)) 
     c06:	8a 30       	cpi	r24, 0x0A	; 10
     c08:	10 f0       	brcs	.+4      	; 0xc0e <GilbarcoOnReceive+0x70>
     c0a:	80 e3       	ldi	r24, 0x30	; 48
     c0c:	01 c0       	rjmp	.+2      	; 0xc10 <GilbarcoOnReceive+0x72>
	     Result='0'+data;
     c0e:	80 5d       	subi	r24, 0xD0	; 208
		 #endif
		 IsStatusReceived=True;

	     break;	
	case rcRealTimeMoney:	     
	     strCurrentMoney[Com0ReceiveCount]=BCD2Char(FilterBCD(data));
     c10:	e8 58       	subi	r30, 0x88	; 136
     c12:	fd 4f       	sbci	r31, 0xFD	; 253
     c14:	80 83       	st	Z, r24
	     strCurrentMoney[Com0ReceiveCount+1]=0;
     c16:	11 82       	std	Z+1, r1	; 0x01
		 TimReceive=0;
     c18:	10 92 10 04 	sts	0x0410, r1
     c1c:	10 92 0f 04 	sts	0x040F, r1
		 Com0ReceiveCount++;
     c20:	89 2f       	mov	r24, r25
     c22:	8f 5f       	subi	r24, 0xFF	; 255
     c24:	80 93 23 01 	sts	0x0123, r24
	     if ((Com0ReceiveCount>6)||(TimReceive>MSG_TRANSACTION_TIMEOUT))
     c28:	87 30       	cpi	r24, 0x07	; 7
     c2a:	08 f4       	brcc	.+2      	; 0xc2e <GilbarcoOnReceive+0x90>
     c2c:	70 c0       	rjmp	.+224    	; 0xd0e <GilbarcoOnReceive+0x170>
		     IsMoneyReceived=True;
     c2e:	81 e0       	ldi	r24, 0x01	; 1
     c30:	80 93 10 01 	sts	0x0110, r24
     c34:	6c c0       	rjmp	.+216    	; 0xd0e <GilbarcoOnReceive+0x170>
	     break;	
    case rcInitTransaction://<STX>
	     if (data==0xFF){
     c36:	1f 3f       	cpi	r17, 0xFF	; 255
     c38:	09 f0       	breq	.+2      	; 0xc3c <GilbarcoOnReceive+0x9e>
     c3a:	69 c0       	rjmp	.+210    	; 0xd0e <GilbarcoOnReceive+0x170>
		    iReceive=0;
     c3c:	10 92 27 01 	sts	0x0127, r1
			TimReceive=0;
     c40:	10 92 10 04 	sts	0x0410, r1
     c44:	10 92 0f 04 	sts	0x040F, r1
		    stReceiveCom0=rcSaveTransactionMessage;
     c48:	86 e0       	ldi	r24, 0x06	; 6
     c4a:	0a c0       	rjmp	.+20     	; 0xc60 <GilbarcoOnReceive+0xc2>
		 }
	     break;
    case rcInitTotalizer://<STX>
	     if (data==0xFF){
     c4c:	1f 3f       	cpi	r17, 0xFF	; 255
     c4e:	09 f0       	breq	.+2      	; 0xc52 <GilbarcoOnReceive+0xb4>
     c50:	5e c0       	rjmp	.+188    	; 0xd0e <GilbarcoOnReceive+0x170>
		    iReceive=0;
     c52:	10 92 27 01 	sts	0x0127, r1
			TimReceive=0;
     c56:	10 92 10 04 	sts	0x0410, r1
     c5a:	10 92 0f 04 	sts	0x040F, r1
		    stReceiveCom0=rcSaveTotalizerMessage;
     c5e:	85 e0       	ldi	r24, 0x05	; 5
     c60:	80 93 04 01 	sts	0x0104, r24
     c64:	54 c0       	rjmp	.+168    	; 0xd0e <GilbarcoOnReceive+0x170>
		 }
	     break;
    case rcSaveTotalizerMessage:
	     //_uart(1,1,data);
	     SaveTotalizerData(data);
     c66:	81 2f       	mov	r24, r17
     c68:	0e 94 a9 02 	call	0x552	; 0x552 <SaveTotalizerData>
	     if ((data==0xF0)||(TimReceive>MSG_TRANSACTION_TIMEOUT)){//Proses
     c6c:	10 3f       	cpi	r17, 0xF0	; 240
     c6e:	41 f0       	breq	.+16     	; 0xc80 <GilbarcoOnReceive+0xe2>
     c70:	80 91 0f 04 	lds	r24, 0x040F
     c74:	90 91 10 04 	lds	r25, 0x0410
     c78:	89 3c       	cpi	r24, 0xC9	; 201
     c7a:	91 05       	cpc	r25, r1
     c7c:	08 f4       	brcc	.+2      	; 0xc80 <GilbarcoOnReceive+0xe2>
     c7e:	47 c0       	rjmp	.+142    	; 0xd0e <GilbarcoOnReceive+0x170>
     c80:	c0 e0       	ldi	r28, 0x00	; 0
     c82:	d0 e0       	ldi	r29, 0x00	; 0
             //ReverseData
			 //_uart_printf(1,1,PSTR("Totalizer: "));
			 for (i=0;i<6;i++){
			 	  StrReverse(PumpTotalizer.TotalGrade[i].strMoney);
     c84:	9e 01       	movw	r18, r28
     c86:	ce 01       	movw	r24, r28
     c88:	f5 e0       	ldi	r31, 0x05	; 5
     c8a:	88 0f       	add	r24, r24
     c8c:	99 1f       	adc	r25, r25
     c8e:	fa 95       	dec	r31
     c90:	e1 f7       	brne	.-8      	; 0xc8a <GilbarcoOnReceive+0xec>
     c92:	22 0f       	add	r18, r18
     c94:	33 1f       	adc	r19, r19
     c96:	82 1b       	sub	r24, r18
     c98:	93 0b       	sbc	r25, r19
     c9a:	8a 5f       	subi	r24, 0xFA	; 250
     c9c:	9c 4f       	sbci	r25, 0xFC	; 252
     c9e:	0e 94 85 05 	call	0xb0a	; 0xb0a <StrReverse>
				  StrReverse(PumpTotalizer.TotalGrade[i].strVolume);
     ca2:	9e 01       	movw	r18, r28
     ca4:	ce 01       	movw	r24, r28
     ca6:	75 e0       	ldi	r23, 0x05	; 5
     ca8:	88 0f       	add	r24, r24
     caa:	99 1f       	adc	r25, r25
     cac:	7a 95       	dec	r23
     cae:	e1 f7       	brne	.-8      	; 0xca8 <GilbarcoOnReceive+0x10a>
     cb0:	22 0f       	add	r18, r18
     cb2:	33 1f       	adc	r19, r19
     cb4:	82 1b       	sub	r24, r18
     cb6:	93 0b       	sbc	r25, r19
     cb8:	89 50       	subi	r24, 0x09	; 9
     cba:	9d 4f       	sbci	r25, 0xFD	; 253
     cbc:	0e 94 85 05 	call	0xb0a	; 0xb0a <StrReverse>
     cc0:	21 96       	adiw	r28, 0x01	; 1
	     //_uart(1,1,data);
	     SaveTotalizerData(data);
	     if ((data==0xF0)||(TimReceive>MSG_TRANSACTION_TIMEOUT)){//Proses
             //ReverseData
			 //_uart_printf(1,1,PSTR("Totalizer: "));
			 for (i=0;i<6;i++){
     cc2:	c6 30       	cpi	r28, 0x06	; 6
     cc4:	d1 05       	cpc	r29, r1
     cc6:	f1 f6       	brne	.-68     	; 0xc84 <GilbarcoOnReceive+0xe6>
			 	  StrReverse(PumpTotalizer.TotalGrade[i].strMoney);
				  StrReverse(PumpTotalizer.TotalGrade[i].strVolume);
				  //_uart_print(1,1,PumpTotalizer.TotalGrade[i].strMoney);
				  //_uart_print(1,1,PumpTotalizer.TotalGrade[i].strVolume);
             }
		     stReceiveCom0=rcIdle;
     cc8:	81 e0       	ldi	r24, 0x01	; 1
     cca:	80 93 04 01 	sts	0x0104, r24
			 IsTotalizer=True;
     cce:	80 93 12 01 	sts	0x0112, r24
     cd2:	1d c0       	rjmp	.+58     	; 0xd0e <GilbarcoOnReceive+0x170>
			 }		 
         break;	
    case rcSaveTransactionMessage:
	     //_uart(1,1,data);
	     SaveTransactionData(data);
     cd4:	81 2f       	mov	r24, r17
     cd6:	0e 94 23 02 	call	0x446	; 0x446 <SaveTransactionData>
	     if ((data==0xF0)||(TimReceive>MSG_TRANSACTION_TIMEOUT)){//Proses
     cda:	10 3f       	cpi	r17, 0xF0	; 240
     cdc:	39 f0       	breq	.+14     	; 0xcec <GilbarcoOnReceive+0x14e>
     cde:	80 91 0f 04 	lds	r24, 0x040F
     ce2:	90 91 10 04 	lds	r25, 0x0410
     ce6:	89 3c       	cpi	r24, 0xC9	; 201
     ce8:	91 05       	cpc	r25, r1
     cea:	88 f0       	brcs	.+34     	; 0xd0e <GilbarcoOnReceive+0x170>
			  StrReverse(strUnitPrice);
     cec:	8c ea       	ldi	r24, 0xAC	; 172
     cee:	92 e0       	ldi	r25, 0x02	; 2
     cf0:	0e 94 85 05 	call	0xb0a	; 0xb0a <StrReverse>
			  StrReverse(strVolume);
     cf4:	87 e5       	ldi	r24, 0x57	; 87
     cf6:	92 e0       	ldi	r25, 0x02	; 2
     cf8:	0e 94 85 05 	call	0xb0a	; 0xb0a <StrReverse>
			  StrReverse(strAmount);
     cfc:	8b ea       	ldi	r24, 0xAB	; 171
     cfe:	93 e0       	ldi	r25, 0x03	; 3
     d00:	0e 94 85 05 	call	0xb0a	; 0xb0a <StrReverse>

			  //sprintf_P(strSend,PSTR("%s"),strAmount);
			  //_uart_print(1,1,strSend);

              stReceiveCom0=rcIdle;
     d04:	81 e0       	ldi	r24, 0x01	; 1
     d06:	80 93 04 01 	sts	0x0104, r24
			  IsTransaction=True;
     d0a:	80 93 11 01 	sts	0x0111, r24
			 }
	     break;
	}
}
     d0e:	df 91       	pop	r29
     d10:	cf 91       	pop	r28
     d12:	1f 91       	pop	r17
     d14:	08 95       	ret

00000d16 <SendSPI>:
	sbi(DDRD,2);sbi(PORTD,2);//128-SS HIGH
	//_delay_ms(10);
}

void SendSPI(char xSPI){
     _spi(xSPI);
     d16:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_spi>
	 //_delay_ms(10);
}
     d1a:	08 95       	ret

00000d1c <SendStrSPI>:
	 SendSPI(0x06);//ETX
	 SendSPI(0x60);//ETX
	 systemSlave();
}

void SendStrSPI(char *strSendSPI){
     d1c:	ff 92       	push	r15
     d1e:	0f 93       	push	r16
     d20:	1f 93       	push	r17
     d22:	cf 93       	push	r28
     d24:	df 93       	push	r29
     d26:	8c 01       	movw	r16, r24
     d28:	ff 24       	eor	r15, r15
     d2a:	06 c0       	rjmp	.+12     	; 0xd38 <SendStrSPI+0x1c>
	sbi(DDRD,2);sbi(PORTD,2);//128-SS HIGH
	//_delay_ms(10);
}

void SendSPI(char xSPI){
     _spi(xSPI);
     d2c:	c0 0f       	add	r28, r16
     d2e:	d1 1f       	adc	r29, r17
     d30:	88 81       	ld	r24, Y
     d32:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_spi>
	 systemSlave();
}

void SendStrSPI(char *strSendSPI){
char i;
     for(i=0;i<strlen(strSendSPI);i++){
     d36:	f3 94       	inc	r15
     d38:	cf 2d       	mov	r28, r15
     d3a:	d0 e0       	ldi	r29, 0x00	; 0
     d3c:	f8 01       	movw	r30, r16
     d3e:	01 90       	ld	r0, Z+
     d40:	00 20       	and	r0, r0
     d42:	e9 f7       	brne	.-6      	; 0xd3e <SendStrSPI+0x22>
     d44:	31 97       	sbiw	r30, 0x01	; 1
     d46:	e0 1b       	sub	r30, r16
     d48:	f1 0b       	sbc	r31, r17
     d4a:	ce 17       	cp	r28, r30
     d4c:	df 07       	cpc	r29, r31
     d4e:	70 f3       	brcs	.-36     	; 0xd2c <SendStrSPI+0x10>
	    SendSPI(strSendSPI[i]);
        //_uart(1,1,strSendSPI[i]);
	 } 
}
     d50:	df 91       	pop	r29
     d52:	cf 91       	pop	r28
     d54:	1f 91       	pop	r17
     d56:	0f 91       	pop	r16
     d58:	ff 90       	pop	r15
     d5a:	08 95       	ret

00000d5c <systemSlave>:
	//_delay_ms(10);
}


void systemSlave(){
	_spi_init(0, 1);         //SPI Slave
     d5c:	80 e0       	ldi	r24, 0x00	; 0
     d5e:	61 e0       	ldi	r22, 0x01	; 1
     d60:	0e 94 6c 17 	call	0x2ed8	; 0x2ed8 <_spi_init>
	sbi(DDRB,6);sbi(PORTB,6);//MISO Output
     d64:	be 9a       	sbi	0x17, 6	; 23
     d66:	c6 9a       	sbi	0x18, 6	; 24
    cbi(DDRB,5);sbi(PORTB,5);//MOSI Input
     d68:	bd 98       	cbi	0x17, 5	; 23
     d6a:	c5 9a       	sbi	0x18, 5	; 24
	cbi(DDRB,7);sbi(PORTB,7);//SCK  Input
     d6c:	bf 98       	cbi	0x17, 7	; 23
     d6e:	c7 9a       	sbi	0x18, 7	; 24
	sbi(DDRD,2);sbi(PORTD,2);//128-SS HIGH
     d70:	8a 9a       	sbi	0x11, 2	; 17
     d72:	92 9a       	sbi	0x12, 2	; 18
	//_delay_ms(10);
}
     d74:	08 95       	ret

00000d76 <systemMaster>:
     _uart(0,1,DataSend);	 
     //_uart(1,1,DataSend);
}

void systemMaster(){
    _spi_init(1, 0);         //SPI Master
     d76:	81 e0       	ldi	r24, 0x01	; 1
     d78:	60 e0       	ldi	r22, 0x00	; 0
     d7a:	0e 94 6c 17 	call	0x2ed8	; 0x2ed8 <_spi_init>
	cbi(DDRB,6);sbi(PORTB,6);//MISO Input
     d7e:	be 98       	cbi	0x17, 6	; 23
     d80:	c6 9a       	sbi	0x18, 6	; 24
    sbi(DDRB,4);sbi(DDRB,5); //MOSI Output
     d82:	bc 9a       	sbi	0x17, 4	; 23
     d84:	bd 9a       	sbi	0x17, 5	; 23
	sbi(DDRB,7);sbi(PORTB,7);//SCK  Output    
     d86:	bf 9a       	sbi	0x17, 7	; 23
     d88:	c7 9a       	sbi	0x18, 7	; 24
	sbi(DDRD,2);cbi(PORTD,2);//128-SS LOW
     d8a:	8a 9a       	sbi	0x11, 2	; 17
     d8c:	92 98       	cbi	0x12, 2	; 18
	//_delay_ms(10);
}
     d8e:	08 95       	ret

00000d90 <SendPumpStatusFlow>:
			 PumpLock[i]=False;
		 }
     }    	 
}

void SendPumpStatusFlow(char xPumpID,char xPumpStatus){//
     d90:	0f 93       	push	r16
     d92:	1f 93       	push	r17
     d94:	08 2f       	mov	r16, r24
     d96:	16 2f       	mov	r17, r22
	 #ifdef DEBUG_PUMP_STATUS_FLOW 
	  sprintf_P(strSend,PSTR("P:%d,S:%d"),xPumpID,xPumpStatus);
	 _uart_print(1,1,strSend);
	 #endif

	 systemMaster();
     d98:	0e 94 bb 06 	call	0xd76	; 0xd76 <systemMaster>
	sbi(DDRD,2);sbi(PORTD,2);//128-SS HIGH
	//_delay_ms(10);
}

void SendSPI(char xSPI){
     _spi(xSPI);
     d9c:	87 e0       	ldi	r24, 0x07	; 7
     d9e:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_spi>
	 systemMaster();
     SendSPI(0x07);//STX
     SendSPI(tmpStatus);//xIDPump
	 SendSPI(0x08);//ETX

	 systemSlave();
     da2:	1f 70       	andi	r17, 0x0F	; 15
     da4:	02 95       	swap	r16
     da6:	00 7f       	andi	r16, 0xF0	; 240
     da8:	80 2f       	mov	r24, r16
     daa:	81 2b       	or	r24, r17
     dac:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_spi>
     db0:	88 e0       	ldi	r24, 0x08	; 8
     db2:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_spi>
     db6:	0e 94 ae 06 	call	0xd5c	; 0xd5c <systemSlave>
}
     dba:	1f 91       	pop	r17
     dbc:	0f 91       	pop	r16
     dbe:	08 95       	ret

00000dc0 <SendCommandAcknoledge>:
       //AcknoledgeCommand
       SendCommandAcknoledge(slaveCmd,slaveMsg);
	 }//EndIf	 
}

void SendCommandAcknoledge(char AckCommand,char AckData){
     dc0:	0f 93       	push	r16
     dc2:	1f 93       	push	r17
     dc4:	18 2f       	mov	r17, r24
     dc6:	06 2f       	mov	r16, r22
	 systemMaster();
     dc8:	0e 94 bb 06 	call	0xd76	; 0xd76 <systemMaster>
	sbi(DDRD,2);sbi(PORTD,2);//128-SS HIGH
	//_delay_ms(10);
}

void SendSPI(char xSPI){
     _spi(xSPI);
     dcc:	89 e0       	ldi	r24, 0x09	; 9
     dce:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_spi>
	 systemMaster();
	 SendSPI(0x09);
	 SendSPI(AckCommand);
	 SendSPI(AckData);
	 SendSPI(0x0A);
	 systemSlave();
     dd2:	81 2f       	mov	r24, r17
     dd4:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_spi>
     dd8:	80 2f       	mov	r24, r16
     dda:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_spi>
     dde:	8a e0       	ldi	r24, 0x0A	; 10
     de0:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_spi>
     de4:	0e 94 ae 06 	call	0xd5c	; 0xd5c <systemSlave>
}
     de8:	1f 91       	pop	r17
     dea:	0f 91       	pop	r16
     dec:	08 95       	ret

00000dee <__vector_20>:
		 }
     }
	 */		 
}

ISR(USART1_RXC_vect){
     dee:	1f 92       	push	r1
     df0:	0f 92       	push	r0
     df2:	0f b6       	in	r0, 0x3f	; 63
     df4:	0f 92       	push	r0
     df6:	11 24       	eor	r1, r1
     df8:	1f 93       	push	r17
     dfa:	2f 93       	push	r18
     dfc:	3f 93       	push	r19
     dfe:	4f 93       	push	r20
     e00:	5f 93       	push	r21
     e02:	6f 93       	push	r22
     e04:	7f 93       	push	r23
     e06:	8f 93       	push	r24
     e08:	9f 93       	push	r25
     e0a:	af 93       	push	r26
     e0c:	bf 93       	push	r27
     e0e:	ef 93       	push	r30
     e10:	ff 93       	push	r31
	char dataRX1;
    dataRX1=UDR1;
     e12:	13 b1       	in	r17, 0x03	; 3


   if (IFType==IT_SLAVE){
     e14:	80 91 00 01 	lds	r24, 0x0100
     e18:	81 30       	cpi	r24, 0x01	; 1
     e1a:	39 f4       	brne	.+14     	; 0xe2a <__vector_20+0x3c>
	   systemMaster();
     e1c:	0e 94 bb 06 	call	0xd76	; 0xd76 <systemMaster>
	   _spi(dataRX1);
     e20:	81 2f       	mov	r24, r17
     e22:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_spi>
	   systemSlave();
     e26:	0e 94 ae 06 	call	0xd5c	; 0xd5c <systemSlave>
	   }
	   
	//_uart(1,1,dataRX1);
	//OnReceive1(dataRX1);
}
     e2a:	ff 91       	pop	r31
     e2c:	ef 91       	pop	r30
     e2e:	bf 91       	pop	r27
     e30:	af 91       	pop	r26
     e32:	9f 91       	pop	r25
     e34:	8f 91       	pop	r24
     e36:	7f 91       	pop	r23
     e38:	6f 91       	pop	r22
     e3a:	5f 91       	pop	r21
     e3c:	4f 91       	pop	r20
     e3e:	3f 91       	pop	r19
     e40:	2f 91       	pop	r18
     e42:	1f 91       	pop	r17
     e44:	0f 90       	pop	r0
     e46:	0f be       	out	0x3f, r0	; 63
     e48:	0f 90       	pop	r0
     e4a:	1f 90       	pop	r1
     e4c:	18 95       	reti

00000e4e <__vector_19>:
	if ((TimExp%100)==0) TimWatchSequence++;
	TimReceive++;
	TimDelayNextPump++;
}

ISR(USART0_RXC_vect){
     e4e:	1f 92       	push	r1
     e50:	0f 92       	push	r0
     e52:	0f b6       	in	r0, 0x3f	; 63
     e54:	0f 92       	push	r0
     e56:	11 24       	eor	r1, r1
     e58:	1f 93       	push	r17
     e5a:	2f 93       	push	r18
     e5c:	3f 93       	push	r19
     e5e:	4f 93       	push	r20
     e60:	5f 93       	push	r21
     e62:	6f 93       	push	r22
     e64:	7f 93       	push	r23
     e66:	8f 93       	push	r24
     e68:	9f 93       	push	r25
     e6a:	af 93       	push	r26
     e6c:	bf 93       	push	r27
     e6e:	ef 93       	push	r30
     e70:	ff 93       	push	r31
    char dataRX0;
	char strSend[20];
	dataRX0=UDR0;
     e72:	1c b1       	in	r17, 0x0c	; 12
    //_uart(1,1,dataRX0);
    //15702 15588 15694
	switch(IFType){
     e74:	80 91 00 01 	lds	r24, 0x0100
     e78:	81 30       	cpi	r24, 0x01	; 1
     e7a:	19 f0       	breq	.+6      	; 0xe82 <__vector_19+0x34>
     e7c:	82 30       	cpi	r24, 0x02	; 2
     e7e:	b9 f4       	brne	.+46     	; 0xeae <__vector_19+0x60>
     e80:	08 c0       	rjmp	.+16     	; 0xe92 <__vector_19+0x44>
	case IT_SLAVE:
	     systemMaster();
     e82:	0e 94 bb 06 	call	0xd76	; 0xd76 <systemMaster>
	     _spi(dataRX0);
     e86:	81 2f       	mov	r24, r17
     e88:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_spi>
	     systemSlave();
     e8c:	0e 94 ae 06 	call	0xd5c	; 0xd5c <systemSlave>
     e90:	0e c0       	rjmp	.+28     	; 0xeae <__vector_19+0x60>
	     break;
    case IT_STANDALONE:
	     switch(StandaloneType){
     e92:	80 91 01 01 	lds	r24, 0x0101
     e96:	81 30       	cpi	r24, 0x01	; 1
     e98:	19 f0       	breq	.+6      	; 0xea0 <__vector_19+0x52>
     e9a:	82 30       	cpi	r24, 0x02	; 2
     e9c:	41 f4       	brne	.+16     	; 0xeae <__vector_19+0x60>
     e9e:	04 c0       	rjmp	.+8      	; 0xea8 <__vector_19+0x5a>
		 case ST_GILBARCO:
		      GilbarcoOnReceive(dataRX0);	
     ea0:	81 2f       	mov	r24, r17
     ea2:	0e 94 cf 05 	call	0xb9e	; 0xb9e <GilbarcoOnReceive>
     ea6:	03 c0       	rjmp	.+6      	; 0xeae <__vector_19+0x60>
			  break;
		 case ST_WAYNE_DART:
		      WayneOnReceive(dataRX0);	              
     ea8:	81 2f       	mov	r24, r17
     eaa:	0e 94 96 04 	call	0x92c	; 0x92c <WayneOnReceive>
			  //_uart_print(1,1,strSend);
			  break;
		 }
     }
	 */		 
}
     eae:	ff 91       	pop	r31
     eb0:	ef 91       	pop	r30
     eb2:	bf 91       	pop	r27
     eb4:	af 91       	pop	r26
     eb6:	9f 91       	pop	r25
     eb8:	8f 91       	pop	r24
     eba:	7f 91       	pop	r23
     ebc:	6f 91       	pop	r22
     ebe:	5f 91       	pop	r21
     ec0:	4f 91       	pop	r20
     ec2:	3f 91       	pop	r19
     ec4:	2f 91       	pop	r18
     ec6:	1f 91       	pop	r17
     ec8:	0f 90       	pop	r0
     eca:	0f be       	out	0x3f, r0	; 63
     ecc:	0f 90       	pop	r0
     ece:	1f 90       	pop	r1
     ed0:	18 95       	reti

00000ed2 <PumpCommand>:
	 sprintf_P(strSend,PSTR("PumpCmd:%.2X"),DataSend);
	 _uart_print(1,1,strSend);
	 #endif


     _uart(0,1,DataSend);	 
     ed2:	62 95       	swap	r22
     ed4:	60 7f       	andi	r22, 0xF0	; 240
     ed6:	48 2f       	mov	r20, r24
     ed8:	4f 70       	andi	r20, 0x0F	; 15
     eda:	46 2b       	or	r20, r22
     edc:	80 e0       	ldi	r24, 0x00	; 0
     ede:	61 e0       	ldi	r22, 0x01	; 1
     ee0:	0e 94 58 18 	call	0x30b0	; 0x30b0 <_uart>
     //_uart(1,1,DataSend);
}
     ee4:	08 95       	ret

00000ee6 <WayneSendChar>:
	      break;	 
	 }
}

//enum eLineStatus{LS_NONE,LS_RX,LS_TX};
void WayneSendChar(char xData){
     ee6:	1f 93       	push	r17
     ee8:	18 2f       	mov	r17, r24
     System485(DIR_TX);//TransmitMode
     eea:	81 e0       	ldi	r24, 0x01	; 1
     eec:	0e 94 9c 01 	call	0x338	; 0x338 <System485>
	 _uart(0,1,xData);
     ef0:	80 e0       	ldi	r24, 0x00	; 0
     ef2:	61 e0       	ldi	r22, 0x01	; 1
     ef4:	41 2f       	mov	r20, r17
     ef6:	0e 94 58 18 	call	0x30b0	; 0x30b0 <_uart>
	 System485(DIR_RX);//ReceiveMode
     efa:	82 e0       	ldi	r24, 0x02	; 2
     efc:	0e 94 9c 01 	call	0x338	; 0x338 <System485>
}
     f00:	1f 91       	pop	r17
     f02:	08 95       	ret

00000f04 <FWayneSendBuffer>:

void WayneTestSend(){
}

void FWayneSendBuffer(char *Buffer, char nLength){
     f04:	0f 93       	push	r16
     f06:	1f 93       	push	r17
     f08:	cf 93       	push	r28
     f0a:	df 93       	push	r29
     f0c:	06 2f       	mov	r16, r22
     f0e:	ec 01       	movw	r28, r24
     f10:	10 e0       	ldi	r17, 0x00	; 0
     f12:	04 c0       	rjmp	.+8      	; 0xf1c <FWayneSendBuffer+0x18>
char i;
     for(i=0;i<nLength;i++){
	     WayneSendChar(Buffer[i]);
     f14:	89 91       	ld	r24, Y+
     f16:	0e 94 73 07 	call	0xee6	; 0xee6 <WayneSendChar>
void WayneTestSend(){
}

void FWayneSendBuffer(char *Buffer, char nLength){
char i;
     for(i=0;i<nLength;i++){
     f1a:	1f 5f       	subi	r17, 0xFF	; 255
     f1c:	10 17       	cp	r17, r16
     f1e:	d0 f3       	brcs	.-12     	; 0xf14 <FWayneSendBuffer+0x10>
	     WayneSendChar(Buffer[i]);
	 }
}
     f20:	df 91       	pop	r29
     f22:	cf 91       	pop	r28
     f24:	1f 91       	pop	r17
     f26:	0f 91       	pop	r16
     f28:	08 95       	ret

00000f2a <FWayneSendCommand>:

void FWayneSendCommand(char Command, char SequenceCmd, char xPumpID, char NozzleID){
     f2a:	0f 93       	push	r16
     f2c:	1f 93       	push	r17
     f2e:	df 93       	push	r29
     f30:	cf 93       	push	r28
     f32:	cd b7       	in	r28, 0x3d	; 61
     f34:	de b7       	in	r29, 0x3e	; 62
     f36:	6e 97       	sbiw	r28, 0x1e	; 30
     f38:	0f b6       	in	r0, 0x3f	; 63
     f3a:	f8 94       	cli
     f3c:	de bf       	out	0x3e, r29	; 62
     f3e:	0f be       	out	0x3f, r0	; 63
     f40:	cd bf       	out	0x3d, r28	; 61
char STX_ID,SEQ,MSG_ID[2],NOZZLE_ID,VALUE[6];
int tCRC16;
char strSend[30];
char CmdBuffer[30];
     
	 rxBufferLength=0;
     f42:	10 92 15 01 	sts	0x0115, r1
     switch(Command){
     f46:	8a 30       	cpi	r24, 0x0A	; 10
     f48:	49 f1       	breq	.+82     	; 0xf9c <FWayneSendCommand+0x72>
     f4a:	8b 30       	cpi	r24, 0x0B	; 11
     f4c:	40 f4       	brcc	.+16     	; 0xf5e <FWayneSendCommand+0x34>
     f4e:	85 30       	cpi	r24, 0x05	; 5
     f50:	09 f4       	brne	.+2      	; 0xf54 <FWayneSendCommand+0x2a>
     f52:	75 c2       	rjmp	.+1258   	; 0x143e <FWayneSendCommand+0x514>
     f54:	87 30       	cpi	r24, 0x07	; 7
     f56:	b1 f0       	breq	.+44     	; 0xf84 <FWayneSendCommand+0x5a>
     f58:	88 23       	and	r24, r24
     f5a:	71 f0       	breq	.+28     	; 0xf78 <FWayneSendCommand+0x4e>
     f5c:	e1 c3       	rjmp	.+1986   	; 0x1720 <FWayneSendCommand+0x7f6>
     f5e:	8c 30       	cpi	r24, 0x0C	; 12
     f60:	09 f4       	brne	.+2      	; 0xf64 <FWayneSendCommand+0x3a>
     f62:	f8 c0       	rjmp	.+496    	; 0x1154 <FWayneSendCommand+0x22a>
     f64:	8c 30       	cpi	r24, 0x0C	; 12
     f66:	08 f4       	brcc	.+2      	; 0xf6a <FWayneSendCommand+0x40>
     f68:	87 c0       	rjmp	.+270    	; 0x1078 <FWayneSendCommand+0x14e>
     f6a:	8d 30       	cpi	r24, 0x0D	; 13
     f6c:	09 f4       	brne	.+2      	; 0xf70 <FWayneSendCommand+0x46>
     f6e:	ab c1       	rjmp	.+854    	; 0x12c6 <FWayneSendCommand+0x39c>
     f70:	8e 30       	cpi	r24, 0x0E	; 14
     f72:	09 f0       	breq	.+2      	; 0xf76 <FWayneSendCommand+0x4c>
     f74:	d5 c3       	rjmp	.+1962   	; 0x1720 <FWayneSendCommand+0x7f6>
     f76:	de c2       	rjmp	.+1468   	; 0x1534 <FWayneSendCommand+0x60a>
	      STX_ID=0x50|(0x0F&(xPumpID));
		  WayneSendChar(STX_ID);
	      WayneSendChar(0x20);
	      WayneSendChar(0xFA);
		  */
		  CmdBuffer[0]=0x50|(0x0F&(xPumpID));
     f78:	4f 70       	andi	r20, 0x0F	; 15
     f7a:	40 65       	ori	r20, 0x50	; 80
     f7c:	49 83       	std	Y+1, r20	; 0x01
		  CmdBuffer[1]=0x20;
     f7e:	80 e2       	ldi	r24, 0x20	; 32
     f80:	8a 83       	std	Y+2, r24	; 0x02
     f82:	06 c0       	rjmp	.+12     	; 0xf90 <FWayneSendCommand+0x66>
	      WayneSendChar(SEQ);
	      WayneSendChar(0xFA);
		  */
		  //sprintf_P(strSend,PSTR("[%.2X %.2X %.2X ]"),STX_ID,SEQ,0xFA);
          //_uart_print(1,1,strSend);
		  CmdBuffer[0]=0x50|(0x0F&(xPumpID));
     f84:	4f 70       	andi	r20, 0x0F	; 15
     f86:	40 65       	ori	r20, 0x50	; 80
     f88:	49 83       	std	Y+1, r20	; 0x01
		  CmdBuffer[1]=0xC0|(0x0F&SequenceCmd);
     f8a:	6f 70       	andi	r22, 0x0F	; 15
     f8c:	60 6c       	ori	r22, 0xC0	; 192
     f8e:	6a 83       	std	Y+2, r22	; 0x02
		  CmdBuffer[2]=0xFA;
     f90:	8a ef       	ldi	r24, 0xFA	; 250
     f92:	8b 83       	std	Y+3, r24	; 0x03
		  FWayneSendBuffer(CmdBuffer,3);
     f94:	ce 01       	movw	r24, r28
     f96:	01 96       	adiw	r24, 0x01	; 1
     f98:	63 e0       	ldi	r22, 0x03	; 3
     f9a:	c0 c3       	rjmp	.+1920   	; 0x171c <FWayneSendCommand+0x7f2>
	      break;
     case CMD_AUTH_1://[51 31 01 01 05 63 63 03 FA]//Auth1 ->9
          tCRC16=0;
		  CmdBuffer[0]=0x50|(0x0F&xPumpID);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[0]);
     f9c:	4f 70       	andi	r20, 0x0F	; 15
     f9e:	40 65       	ori	r20, 0x50	; 80

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
     fa0:	84 2f       	mov	r24, r20
     fa2:	90 e0       	ldi	r25, 0x00	; 0
     fa4:	50 e0       	ldi	r21, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
     fa6:	e1 e0       	ldi	r30, 0x01	; 1
     fa8:	f0 ea       	ldi	r31, 0xA0	; 160
     faa:	9c 01       	movw	r18, r24
     fac:	36 95       	lsr	r19
     fae:	27 95       	ror	r18
     fb0:	80 ff       	sbrs	r24, 0
     fb2:	04 c0       	rjmp	.+8      	; 0xfbc <FWayneSendCommand+0x92>
     fb4:	c9 01       	movw	r24, r18
     fb6:	8e 27       	eor	r24, r30
     fb8:	9f 27       	eor	r25, r31
     fba:	01 c0       	rjmp	.+2      	; 0xfbe <FWayneSendCommand+0x94>
        else xCRC= (xCRC>> 1);
     fbc:	c9 01       	movw	r24, r18
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
     fbe:	5f 5f       	subi	r21, 0xFF	; 255
     fc0:	58 30       	cpi	r21, 0x08	; 8
     fc2:	99 f7       	brne	.-26     	; 0xfaa <FWayneSendCommand+0x80>
		  FWayneSendBuffer(CmdBuffer,3);
	      break;
     case CMD_AUTH_1://[51 31 01 01 05 63 63 03 FA]//Auth1 ->9
          tCRC16=0;
		  CmdBuffer[0]=0x50|(0x0F&xPumpID);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[0]);
		  CmdBuffer[1]=0x30|(0x0F&SequenceCmd);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[1]);
     fc4:	6f 70       	andi	r22, 0x0F	; 15
     fc6:	60 63       	ori	r22, 0x30	; 48

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
     fc8:	26 2f       	mov	r18, r22
     fca:	30 e0       	ldi	r19, 0x00	; 0
     fcc:	28 27       	eor	r18, r24
     fce:	39 27       	eor	r19, r25
     fd0:	50 e0       	ldi	r21, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
     fd2:	e1 e0       	ldi	r30, 0x01	; 1
     fd4:	f0 ea       	ldi	r31, 0xA0	; 160
     fd6:	c9 01       	movw	r24, r18
     fd8:	96 95       	lsr	r25
     fda:	87 95       	ror	r24
     fdc:	20 ff       	sbrs	r18, 0
     fde:	04 c0       	rjmp	.+8      	; 0xfe8 <FWayneSendCommand+0xbe>
     fe0:	9c 01       	movw	r18, r24
     fe2:	2e 27       	eor	r18, r30
     fe4:	3f 27       	eor	r19, r31
     fe6:	01 c0       	rjmp	.+2      	; 0xfea <FWayneSendCommand+0xc0>
        else xCRC= (xCRC>> 1);
     fe8:	9c 01       	movw	r18, r24
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
     fea:	5f 5f       	subi	r21, 0xFF	; 255
     fec:	58 30       	cpi	r21, 0x08	; 8
     fee:	99 f7       	brne	.-26     	; 0xfd6 <FWayneSendCommand+0xac>

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
     ff0:	81 e0       	ldi	r24, 0x01	; 1
     ff2:	90 e0       	ldi	r25, 0x00	; 0
     ff4:	82 27       	eor	r24, r18
     ff6:	93 27       	eor	r25, r19
     ff8:	50 e0       	ldi	r21, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
     ffa:	e1 e0       	ldi	r30, 0x01	; 1
     ffc:	f0 ea       	ldi	r31, 0xA0	; 160
     ffe:	9c 01       	movw	r18, r24
    1000:	36 95       	lsr	r19
    1002:	27 95       	ror	r18
    1004:	80 ff       	sbrs	r24, 0
    1006:	04 c0       	rjmp	.+8      	; 0x1010 <FWayneSendCommand+0xe6>
    1008:	c9 01       	movw	r24, r18
    100a:	8e 27       	eor	r24, r30
    100c:	9f 27       	eor	r25, r31
    100e:	01 c0       	rjmp	.+2      	; 0x1012 <FWayneSendCommand+0xe8>
        else xCRC= (xCRC>> 1);
    1010:	c9 01       	movw	r24, r18
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    1012:	5f 5f       	subi	r21, 0xFF	; 255
    1014:	58 30       	cpi	r21, 0x08	; 8
    1016:	99 f7       	brne	.-26     	; 0xffe <FWayneSendCommand+0xd4>

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    1018:	21 e0       	ldi	r18, 0x01	; 1
    101a:	30 e0       	ldi	r19, 0x00	; 0
    101c:	28 27       	eor	r18, r24
    101e:	39 27       	eor	r19, r25
    1020:	50 e0       	ldi	r21, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    1022:	e1 e0       	ldi	r30, 0x01	; 1
    1024:	f0 ea       	ldi	r31, 0xA0	; 160
    1026:	c9 01       	movw	r24, r18
    1028:	96 95       	lsr	r25
    102a:	87 95       	ror	r24
    102c:	20 ff       	sbrs	r18, 0
    102e:	04 c0       	rjmp	.+8      	; 0x1038 <FWayneSendCommand+0x10e>
    1030:	9c 01       	movw	r18, r24
    1032:	2e 27       	eor	r18, r30
    1034:	3f 27       	eor	r19, r31
    1036:	01 c0       	rjmp	.+2      	; 0x103a <FWayneSendCommand+0x110>
        else xCRC= (xCRC>> 1);
    1038:	9c 01       	movw	r18, r24
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    103a:	5f 5f       	subi	r21, 0xFF	; 255
    103c:	58 30       	cpi	r21, 0x08	; 8
    103e:	99 f7       	brne	.-26     	; 0x1026 <FWayneSendCommand+0xfc>

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    1040:	e5 e0       	ldi	r30, 0x05	; 5
    1042:	f0 e0       	ldi	r31, 0x00	; 0
    1044:	e2 27       	eor	r30, r18
    1046:	f3 27       	eor	r31, r19
    1048:	20 e0       	ldi	r18, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    104a:	a1 e0       	ldi	r26, 0x01	; 1
    104c:	b0 ea       	ldi	r27, 0xA0	; 160
    104e:	cf 01       	movw	r24, r30
    1050:	96 95       	lsr	r25
    1052:	87 95       	ror	r24
    1054:	e0 ff       	sbrs	r30, 0
    1056:	04 c0       	rjmp	.+8      	; 0x1060 <FWayneSendCommand+0x136>
    1058:	fc 01       	movw	r30, r24
    105a:	ea 27       	eor	r30, r26
    105c:	fb 27       	eor	r31, r27
    105e:	01 c0       	rjmp	.+2      	; 0x1062 <FWayneSendCommand+0x138>
        else xCRC= (xCRC>> 1);
    1060:	fc 01       	movw	r30, r24
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    1062:	2f 5f       	subi	r18, 0xFF	; 255
    1064:	28 30       	cpi	r18, 0x08	; 8
    1066:	99 f7       	brne	.-26     	; 0x104e <FWayneSendCommand+0x124>
		  CmdBuffer[2]=0xFA;
		  FWayneSendBuffer(CmdBuffer,3);
	      break;
     case CMD_AUTH_1://[51 31 01 01 05 63 63 03 FA]//Auth1 ->9
          tCRC16=0;
		  CmdBuffer[0]=0x50|(0x0F&xPumpID);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[0]);
    1068:	49 83       	std	Y+1, r20	; 0x01
		  CmdBuffer[1]=0x30|(0x0F&SequenceCmd);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[1]);
    106a:	6a 83       	std	Y+2, r22	; 0x02
		  CmdBuffer[2]=0x01;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[2]);
    106c:	81 e0       	ldi	r24, 0x01	; 1
    106e:	8b 83       	std	Y+3, r24	; 0x03
		  CmdBuffer[3]=0x01;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[3]);
    1070:	8c 83       	std	Y+4, r24	; 0x04
		  CmdBuffer[4]=0x05;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[4]);
    1072:	85 e0       	ldi	r24, 0x05	; 5
    1074:	8d 83       	std	Y+5, r24	; 0x05
    1076:	68 c0       	rjmp	.+208    	; 0x1148 <FWayneSendCommand+0x21e>
		  CmdBuffer[8]=0xFA;
          FWayneSendBuffer(CmdBuffer,9);
	      break;
     case CMD_AUTH_2://[51 32 01 01 00 A3 24 03 FA]//Auth2 ->9
          tCRC16=0;
		  CmdBuffer[0]=0x50|(0x0F&xPumpID);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[0]);
    1078:	4f 70       	andi	r20, 0x0F	; 15
    107a:	40 65       	ori	r20, 0x50	; 80

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    107c:	24 2f       	mov	r18, r20
    107e:	30 e0       	ldi	r19, 0x00	; 0
    1080:	50 e0       	ldi	r21, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    1082:	e1 e0       	ldi	r30, 0x01	; 1
    1084:	f0 ea       	ldi	r31, 0xA0	; 160
    1086:	c9 01       	movw	r24, r18
    1088:	96 95       	lsr	r25
    108a:	87 95       	ror	r24
    108c:	20 ff       	sbrs	r18, 0
    108e:	04 c0       	rjmp	.+8      	; 0x1098 <FWayneSendCommand+0x16e>
    1090:	9c 01       	movw	r18, r24
    1092:	2e 27       	eor	r18, r30
    1094:	3f 27       	eor	r19, r31
    1096:	01 c0       	rjmp	.+2      	; 0x109a <FWayneSendCommand+0x170>
        else xCRC= (xCRC>> 1);
    1098:	9c 01       	movw	r18, r24
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    109a:	5f 5f       	subi	r21, 0xFF	; 255
    109c:	58 30       	cpi	r21, 0x08	; 8
    109e:	99 f7       	brne	.-26     	; 0x1086 <FWayneSendCommand+0x15c>
          FWayneSendBuffer(CmdBuffer,9);
	      break;
     case CMD_AUTH_2://[51 32 01 01 00 A3 24 03 FA]//Auth2 ->9
          tCRC16=0;
		  CmdBuffer[0]=0x50|(0x0F&xPumpID);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[0]);
		  CmdBuffer[1]=0x30|(0x0F&SequenceCmd);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[1]);
    10a0:	6f 70       	andi	r22, 0x0F	; 15
    10a2:	60 63       	ori	r22, 0x30	; 48

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    10a4:	86 2f       	mov	r24, r22
    10a6:	90 e0       	ldi	r25, 0x00	; 0
    10a8:	82 27       	eor	r24, r18
    10aa:	93 27       	eor	r25, r19
    10ac:	50 e0       	ldi	r21, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    10ae:	e1 e0       	ldi	r30, 0x01	; 1
    10b0:	f0 ea       	ldi	r31, 0xA0	; 160
    10b2:	9c 01       	movw	r18, r24
    10b4:	36 95       	lsr	r19
    10b6:	27 95       	ror	r18
    10b8:	80 ff       	sbrs	r24, 0
    10ba:	04 c0       	rjmp	.+8      	; 0x10c4 <FWayneSendCommand+0x19a>
    10bc:	c9 01       	movw	r24, r18
    10be:	8e 27       	eor	r24, r30
    10c0:	9f 27       	eor	r25, r31
    10c2:	01 c0       	rjmp	.+2      	; 0x10c6 <FWayneSendCommand+0x19c>
        else xCRC= (xCRC>> 1);
    10c4:	c9 01       	movw	r24, r18
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    10c6:	5f 5f       	subi	r21, 0xFF	; 255
    10c8:	58 30       	cpi	r21, 0x08	; 8
    10ca:	99 f7       	brne	.-26     	; 0x10b2 <FWayneSendCommand+0x188>

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    10cc:	21 e0       	ldi	r18, 0x01	; 1
    10ce:	30 e0       	ldi	r19, 0x00	; 0
    10d0:	28 27       	eor	r18, r24
    10d2:	39 27       	eor	r19, r25
    10d4:	50 e0       	ldi	r21, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    10d6:	e1 e0       	ldi	r30, 0x01	; 1
    10d8:	f0 ea       	ldi	r31, 0xA0	; 160
    10da:	c9 01       	movw	r24, r18
    10dc:	96 95       	lsr	r25
    10de:	87 95       	ror	r24
    10e0:	20 ff       	sbrs	r18, 0
    10e2:	04 c0       	rjmp	.+8      	; 0x10ec <FWayneSendCommand+0x1c2>
    10e4:	9c 01       	movw	r18, r24
    10e6:	2e 27       	eor	r18, r30
    10e8:	3f 27       	eor	r19, r31
    10ea:	01 c0       	rjmp	.+2      	; 0x10ee <FWayneSendCommand+0x1c4>
        else xCRC= (xCRC>> 1);
    10ec:	9c 01       	movw	r18, r24
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    10ee:	5f 5f       	subi	r21, 0xFF	; 255
    10f0:	58 30       	cpi	r21, 0x08	; 8
    10f2:	99 f7       	brne	.-26     	; 0x10da <FWayneSendCommand+0x1b0>

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    10f4:	e1 e0       	ldi	r30, 0x01	; 1
    10f6:	f0 e0       	ldi	r31, 0x00	; 0
    10f8:	e2 27       	eor	r30, r18
    10fa:	f3 27       	eor	r31, r19
    10fc:	80 e0       	ldi	r24, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    10fe:	a1 e0       	ldi	r26, 0x01	; 1
    1100:	b0 ea       	ldi	r27, 0xA0	; 160
    1102:	9f 01       	movw	r18, r30
    1104:	36 95       	lsr	r19
    1106:	27 95       	ror	r18
    1108:	e0 ff       	sbrs	r30, 0
    110a:	04 c0       	rjmp	.+8      	; 0x1114 <FWayneSendCommand+0x1ea>
    110c:	f9 01       	movw	r30, r18
    110e:	ea 27       	eor	r30, r26
    1110:	fb 27       	eor	r31, r27
    1112:	01 c0       	rjmp	.+2      	; 0x1116 <FWayneSendCommand+0x1ec>
        else xCRC= (xCRC>> 1);
    1114:	f9 01       	movw	r30, r18
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    1116:	8f 5f       	subi	r24, 0xFF	; 255
    1118:	88 30       	cpi	r24, 0x08	; 8
    111a:	99 f7       	brne	.-26     	; 0x1102 <FWayneSendCommand+0x1d8>
    111c:	80 e0       	ldi	r24, 0x00	; 0
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    111e:	a1 e0       	ldi	r26, 0x01	; 1
    1120:	b0 ea       	ldi	r27, 0xA0	; 160
    1122:	9f 01       	movw	r18, r30
    1124:	36 95       	lsr	r19
    1126:	27 95       	ror	r18
    1128:	e0 ff       	sbrs	r30, 0
    112a:	04 c0       	rjmp	.+8      	; 0x1134 <FWayneSendCommand+0x20a>
    112c:	f9 01       	movw	r30, r18
    112e:	ea 27       	eor	r30, r26
    1130:	fb 27       	eor	r31, r27
    1132:	01 c0       	rjmp	.+2      	; 0x1136 <FWayneSendCommand+0x20c>
        else xCRC= (xCRC>> 1);
    1134:	f9 01       	movw	r30, r18
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    1136:	8f 5f       	subi	r24, 0xFF	; 255
    1138:	88 30       	cpi	r24, 0x08	; 8
    113a:	99 f7       	brne	.-26     	; 0x1122 <FWayneSendCommand+0x1f8>
		  CmdBuffer[8]=0xFA;
          FWayneSendBuffer(CmdBuffer,9);
	      break;
     case CMD_AUTH_2://[51 32 01 01 00 A3 24 03 FA]//Auth2 ->9
          tCRC16=0;
		  CmdBuffer[0]=0x50|(0x0F&xPumpID);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[0]);
    113c:	49 83       	std	Y+1, r20	; 0x01
		  CmdBuffer[1]=0x30|(0x0F&SequenceCmd);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[1]);
    113e:	6a 83       	std	Y+2, r22	; 0x02
		  CmdBuffer[2]=0x01;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[2]);
    1140:	81 e0       	ldi	r24, 0x01	; 1
    1142:	8b 83       	std	Y+3, r24	; 0x03
		  CmdBuffer[3]=0x01;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[3]);
    1144:	8c 83       	std	Y+4, r24	; 0x04
		  CmdBuffer[4]=0x00;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[4]);
    1146:	1d 82       	std	Y+5, r1	; 0x05
		  CmdBuffer[5]=tCRC16;
    1148:	ee 83       	std	Y+6, r30	; 0x06
		  CmdBuffer[6]=tCRC16>>8;
    114a:	8f 2f       	mov	r24, r31
    114c:	99 27       	eor	r25, r25
    114e:	87 fd       	sbrc	r24, 7
    1150:	9a 95       	dec	r25
    1152:	e7 c1       	rjmp	.+974    	; 0x1522 <FWayneSendCommand+0x5f8>
		  CmdBuffer[8]=0xFA;
          FWayneSendBuffer(CmdBuffer,9);
	      break;
     case CMD_AUTH_3://Preset Auth Max Volume
          tCRC16=0;//[51 33 04 04 99 99 99 99 63 3E 03 FA]//Auth3 ->12
		  CmdBuffer[0]=0x50|(0x0F&xPumpID);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[0]);
    1154:	4f 70       	andi	r20, 0x0F	; 15
    1156:	40 65       	ori	r20, 0x50	; 80

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    1158:	84 2f       	mov	r24, r20
    115a:	90 e0       	ldi	r25, 0x00	; 0
    115c:	50 e0       	ldi	r21, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    115e:	e1 e0       	ldi	r30, 0x01	; 1
    1160:	f0 ea       	ldi	r31, 0xA0	; 160
    1162:	9c 01       	movw	r18, r24
    1164:	36 95       	lsr	r19
    1166:	27 95       	ror	r18
    1168:	80 ff       	sbrs	r24, 0
    116a:	04 c0       	rjmp	.+8      	; 0x1174 <FWayneSendCommand+0x24a>
    116c:	c9 01       	movw	r24, r18
    116e:	8e 27       	eor	r24, r30
    1170:	9f 27       	eor	r25, r31
    1172:	01 c0       	rjmp	.+2      	; 0x1176 <FWayneSendCommand+0x24c>
        else xCRC= (xCRC>> 1);
    1174:	c9 01       	movw	r24, r18
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    1176:	5f 5f       	subi	r21, 0xFF	; 255
    1178:	58 30       	cpi	r21, 0x08	; 8
    117a:	99 f7       	brne	.-26     	; 0x1162 <FWayneSendCommand+0x238>
          FWayneSendBuffer(CmdBuffer,9);
	      break;
     case CMD_AUTH_3://Preset Auth Max Volume
          tCRC16=0;//[51 33 04 04 99 99 99 99 63 3E 03 FA]//Auth3 ->12
		  CmdBuffer[0]=0x50|(0x0F&xPumpID);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[0]);
		  CmdBuffer[1]=0x30|(0x0F&SequenceCmd);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[1]);
    117c:	6f 70       	andi	r22, 0x0F	; 15
    117e:	60 63       	ori	r22, 0x30	; 48

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    1180:	26 2f       	mov	r18, r22
    1182:	30 e0       	ldi	r19, 0x00	; 0
    1184:	28 27       	eor	r18, r24
    1186:	39 27       	eor	r19, r25
    1188:	50 e0       	ldi	r21, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    118a:	e1 e0       	ldi	r30, 0x01	; 1
    118c:	f0 ea       	ldi	r31, 0xA0	; 160
    118e:	c9 01       	movw	r24, r18
    1190:	96 95       	lsr	r25
    1192:	87 95       	ror	r24
    1194:	20 ff       	sbrs	r18, 0
    1196:	04 c0       	rjmp	.+8      	; 0x11a0 <FWayneSendCommand+0x276>
    1198:	9c 01       	movw	r18, r24
    119a:	2e 27       	eor	r18, r30
    119c:	3f 27       	eor	r19, r31
    119e:	01 c0       	rjmp	.+2      	; 0x11a2 <FWayneSendCommand+0x278>
        else xCRC= (xCRC>> 1);
    11a0:	9c 01       	movw	r18, r24
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    11a2:	5f 5f       	subi	r21, 0xFF	; 255
    11a4:	58 30       	cpi	r21, 0x08	; 8
    11a6:	99 f7       	brne	.-26     	; 0x118e <FWayneSendCommand+0x264>

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    11a8:	84 e0       	ldi	r24, 0x04	; 4
    11aa:	90 e0       	ldi	r25, 0x00	; 0
    11ac:	82 27       	eor	r24, r18
    11ae:	93 27       	eor	r25, r19
    11b0:	50 e0       	ldi	r21, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    11b2:	e1 e0       	ldi	r30, 0x01	; 1
    11b4:	f0 ea       	ldi	r31, 0xA0	; 160
    11b6:	9c 01       	movw	r18, r24
    11b8:	36 95       	lsr	r19
    11ba:	27 95       	ror	r18
    11bc:	80 ff       	sbrs	r24, 0
    11be:	04 c0       	rjmp	.+8      	; 0x11c8 <FWayneSendCommand+0x29e>
    11c0:	c9 01       	movw	r24, r18
    11c2:	8e 27       	eor	r24, r30
    11c4:	9f 27       	eor	r25, r31
    11c6:	01 c0       	rjmp	.+2      	; 0x11ca <FWayneSendCommand+0x2a0>
        else xCRC= (xCRC>> 1);
    11c8:	c9 01       	movw	r24, r18
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    11ca:	5f 5f       	subi	r21, 0xFF	; 255
    11cc:	58 30       	cpi	r21, 0x08	; 8
    11ce:	99 f7       	brne	.-26     	; 0x11b6 <FWayneSendCommand+0x28c>

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    11d0:	e4 e0       	ldi	r30, 0x04	; 4
    11d2:	f0 e0       	ldi	r31, 0x00	; 0
    11d4:	e8 27       	eor	r30, r24
    11d6:	f9 27       	eor	r31, r25
    11d8:	20 e0       	ldi	r18, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    11da:	a1 e0       	ldi	r26, 0x01	; 1
    11dc:	b0 ea       	ldi	r27, 0xA0	; 160
    11de:	cf 01       	movw	r24, r30
    11e0:	96 95       	lsr	r25
    11e2:	87 95       	ror	r24
    11e4:	e0 ff       	sbrs	r30, 0
    11e6:	04 c0       	rjmp	.+8      	; 0x11f0 <FWayneSendCommand+0x2c6>
    11e8:	fc 01       	movw	r30, r24
    11ea:	ea 27       	eor	r30, r26
    11ec:	fb 27       	eor	r31, r27
    11ee:	01 c0       	rjmp	.+2      	; 0x11f2 <FWayneSendCommand+0x2c8>
        else xCRC= (xCRC>> 1);
    11f0:	fc 01       	movw	r30, r24
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    11f2:	2f 5f       	subi	r18, 0xFF	; 255
    11f4:	28 30       	cpi	r18, 0x08	; 8
    11f6:	99 f7       	brne	.-26     	; 0x11de <FWayneSendCommand+0x2b4>
          tCRC16=0;//[51 33 04 04 99 99 99 99 63 3E 03 FA]//Auth3 ->12
		  CmdBuffer[0]=0x50|(0x0F&xPumpID);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[0]);
		  CmdBuffer[1]=0x30|(0x0F&SequenceCmd);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[1]);
		  CmdBuffer[2]=0x04;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[2]);
		  CmdBuffer[3]=0x04;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[3]);
		  CmdBuffer[4]=MaxAuthVolume[0];tCRC16=CRC_Wayne(tCRC16,CmdBuffer[4]);
    11f8:	00 91 07 01 	lds	r16, 0x0107

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    11fc:	20 2f       	mov	r18, r16
    11fe:	30 e0       	ldi	r19, 0x00	; 0
    1200:	2e 27       	eor	r18, r30
    1202:	3f 27       	eor	r19, r31
    1204:	50 e0       	ldi	r21, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    1206:	e1 e0       	ldi	r30, 0x01	; 1
    1208:	f0 ea       	ldi	r31, 0xA0	; 160
    120a:	c9 01       	movw	r24, r18
    120c:	96 95       	lsr	r25
    120e:	87 95       	ror	r24
    1210:	20 ff       	sbrs	r18, 0
    1212:	04 c0       	rjmp	.+8      	; 0x121c <FWayneSendCommand+0x2f2>
    1214:	9c 01       	movw	r18, r24
    1216:	2e 27       	eor	r18, r30
    1218:	3f 27       	eor	r19, r31
    121a:	01 c0       	rjmp	.+2      	; 0x121e <FWayneSendCommand+0x2f4>
        else xCRC= (xCRC>> 1);
    121c:	9c 01       	movw	r18, r24
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    121e:	5f 5f       	subi	r21, 0xFF	; 255
    1220:	58 30       	cpi	r21, 0x08	; 8
    1222:	99 f7       	brne	.-26     	; 0x120a <FWayneSendCommand+0x2e0>
		  CmdBuffer[0]=0x50|(0x0F&xPumpID);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[0]);
		  CmdBuffer[1]=0x30|(0x0F&SequenceCmd);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[1]);
		  CmdBuffer[2]=0x04;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[2]);
		  CmdBuffer[3]=0x04;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[3]);
		  CmdBuffer[4]=MaxAuthVolume[0];tCRC16=CRC_Wayne(tCRC16,CmdBuffer[4]);
		  CmdBuffer[5]=MaxAuthVolume[1];tCRC16=CRC_Wayne(tCRC16,CmdBuffer[5]);
    1224:	10 91 08 01 	lds	r17, 0x0108

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    1228:	81 2f       	mov	r24, r17
    122a:	90 e0       	ldi	r25, 0x00	; 0
    122c:	82 27       	eor	r24, r18
    122e:	93 27       	eor	r25, r19
    1230:	50 e0       	ldi	r21, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    1232:	e1 e0       	ldi	r30, 0x01	; 1
    1234:	f0 ea       	ldi	r31, 0xA0	; 160
    1236:	9c 01       	movw	r18, r24
    1238:	36 95       	lsr	r19
    123a:	27 95       	ror	r18
    123c:	80 ff       	sbrs	r24, 0
    123e:	04 c0       	rjmp	.+8      	; 0x1248 <FWayneSendCommand+0x31e>
    1240:	c9 01       	movw	r24, r18
    1242:	8e 27       	eor	r24, r30
    1244:	9f 27       	eor	r25, r31
    1246:	01 c0       	rjmp	.+2      	; 0x124a <FWayneSendCommand+0x320>
        else xCRC= (xCRC>> 1);
    1248:	c9 01       	movw	r24, r18
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    124a:	5f 5f       	subi	r21, 0xFF	; 255
    124c:	58 30       	cpi	r21, 0x08	; 8
    124e:	99 f7       	brne	.-26     	; 0x1236 <FWayneSendCommand+0x30c>
		  CmdBuffer[1]=0x30|(0x0F&SequenceCmd);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[1]);
		  CmdBuffer[2]=0x04;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[2]);
		  CmdBuffer[3]=0x04;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[3]);
		  CmdBuffer[4]=MaxAuthVolume[0];tCRC16=CRC_Wayne(tCRC16,CmdBuffer[4]);
		  CmdBuffer[5]=MaxAuthVolume[1];tCRC16=CRC_Wayne(tCRC16,CmdBuffer[5]);
		  CmdBuffer[6]=MaxAuthVolume[2];tCRC16=CRC_Wayne(tCRC16,CmdBuffer[6]);
    1250:	70 91 09 01 	lds	r23, 0x0109

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    1254:	27 2f       	mov	r18, r23
    1256:	30 e0       	ldi	r19, 0x00	; 0
    1258:	28 27       	eor	r18, r24
    125a:	39 27       	eor	r19, r25
    125c:	50 e0       	ldi	r21, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    125e:	e1 e0       	ldi	r30, 0x01	; 1
    1260:	f0 ea       	ldi	r31, 0xA0	; 160
    1262:	c9 01       	movw	r24, r18
    1264:	96 95       	lsr	r25
    1266:	87 95       	ror	r24
    1268:	20 ff       	sbrs	r18, 0
    126a:	04 c0       	rjmp	.+8      	; 0x1274 <FWayneSendCommand+0x34a>
    126c:	9c 01       	movw	r18, r24
    126e:	2e 27       	eor	r18, r30
    1270:	3f 27       	eor	r19, r31
    1272:	01 c0       	rjmp	.+2      	; 0x1276 <FWayneSendCommand+0x34c>
        else xCRC= (xCRC>> 1);
    1274:	9c 01       	movw	r18, r24
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    1276:	5f 5f       	subi	r21, 0xFF	; 255
    1278:	58 30       	cpi	r21, 0x08	; 8
    127a:	99 f7       	brne	.-26     	; 0x1262 <FWayneSendCommand+0x338>
		  CmdBuffer[2]=0x04;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[2]);
		  CmdBuffer[3]=0x04;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[3]);
		  CmdBuffer[4]=MaxAuthVolume[0];tCRC16=CRC_Wayne(tCRC16,CmdBuffer[4]);
		  CmdBuffer[5]=MaxAuthVolume[1];tCRC16=CRC_Wayne(tCRC16,CmdBuffer[5]);
		  CmdBuffer[6]=MaxAuthVolume[2];tCRC16=CRC_Wayne(tCRC16,CmdBuffer[6]);
		  CmdBuffer[7]=MaxAuthVolume[3];tCRC16=CRC_Wayne(tCRC16,CmdBuffer[7]);
    127c:	50 91 0a 01 	lds	r21, 0x010A

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    1280:	e5 2f       	mov	r30, r21
    1282:	f0 e0       	ldi	r31, 0x00	; 0
    1284:	e2 27       	eor	r30, r18
    1286:	f3 27       	eor	r31, r19
    1288:	20 e0       	ldi	r18, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    128a:	a1 e0       	ldi	r26, 0x01	; 1
    128c:	b0 ea       	ldi	r27, 0xA0	; 160
    128e:	cf 01       	movw	r24, r30
    1290:	96 95       	lsr	r25
    1292:	87 95       	ror	r24
    1294:	e0 ff       	sbrs	r30, 0
    1296:	04 c0       	rjmp	.+8      	; 0x12a0 <FWayneSendCommand+0x376>
    1298:	fc 01       	movw	r30, r24
    129a:	ea 27       	eor	r30, r26
    129c:	fb 27       	eor	r31, r27
    129e:	01 c0       	rjmp	.+2      	; 0x12a2 <FWayneSendCommand+0x378>
        else xCRC= (xCRC>> 1);
    12a0:	fc 01       	movw	r30, r24
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    12a2:	2f 5f       	subi	r18, 0xFF	; 255
    12a4:	28 30       	cpi	r18, 0x08	; 8
    12a6:	99 f7       	brne	.-26     	; 0x128e <FWayneSendCommand+0x364>
		  CmdBuffer[8]=0xFA;
          FWayneSendBuffer(CmdBuffer,9);
	      break;
     case CMD_AUTH_3://Preset Auth Max Volume
          tCRC16=0;//[51 33 04 04 99 99 99 99 63 3E 03 FA]//Auth3 ->12
		  CmdBuffer[0]=0x50|(0x0F&xPumpID);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[0]);
    12a8:	49 83       	std	Y+1, r20	; 0x01
		  CmdBuffer[1]=0x30|(0x0F&SequenceCmd);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[1]);
    12aa:	6a 83       	std	Y+2, r22	; 0x02
		  CmdBuffer[2]=0x04;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[2]);
    12ac:	84 e0       	ldi	r24, 0x04	; 4
    12ae:	8b 83       	std	Y+3, r24	; 0x03
		  CmdBuffer[3]=0x04;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[3]);
    12b0:	8c 83       	std	Y+4, r24	; 0x04
		  CmdBuffer[4]=MaxAuthVolume[0];tCRC16=CRC_Wayne(tCRC16,CmdBuffer[4]);
    12b2:	0d 83       	std	Y+5, r16	; 0x05
		  CmdBuffer[5]=MaxAuthVolume[1];tCRC16=CRC_Wayne(tCRC16,CmdBuffer[5]);
    12b4:	1e 83       	std	Y+6, r17	; 0x06
		  CmdBuffer[6]=MaxAuthVolume[2];tCRC16=CRC_Wayne(tCRC16,CmdBuffer[6]);
    12b6:	7f 83       	std	Y+7, r23	; 0x07
		  CmdBuffer[7]=MaxAuthVolume[3];tCRC16=CRC_Wayne(tCRC16,CmdBuffer[7]);
    12b8:	58 87       	std	Y+8, r21	; 0x08
		  CmdBuffer[8]=tCRC16;
    12ba:	e9 87       	std	Y+9, r30	; 0x09
		  CmdBuffer[9]=tCRC16>>8;
    12bc:	8f 2f       	mov	r24, r31
    12be:	99 27       	eor	r25, r25
    12c0:	87 fd       	sbrc	r24, 7
    12c2:	9a 95       	dec	r25
    12c4:	b3 c0       	rjmp	.+358    	; 0x142c <FWayneSendCommand+0x502>
	 [51 34 02 01 01 01 01 06 5C BF 03 FA]//Auth4 Nozzle1
     [51 34 02 01 02 01 01 06 5C FB 03 FA]//Auth4 Nozzle2

	 */
          tCRC16=0;
		  CmdBuffer[0]=0x50|(0x0F&xPumpID);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[0]);
    12c6:	4f 70       	andi	r20, 0x0F	; 15
    12c8:	40 65       	ori	r20, 0x50	; 80

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    12ca:	84 2f       	mov	r24, r20
    12cc:	90 e0       	ldi	r25, 0x00	; 0
    12ce:	30 e0       	ldi	r19, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    12d0:	a1 e0       	ldi	r26, 0x01	; 1
    12d2:	b0 ea       	ldi	r27, 0xA0	; 160
    12d4:	fc 01       	movw	r30, r24
    12d6:	f6 95       	lsr	r31
    12d8:	e7 95       	ror	r30
    12da:	80 ff       	sbrs	r24, 0
    12dc:	04 c0       	rjmp	.+8      	; 0x12e6 <FWayneSendCommand+0x3bc>
    12de:	cf 01       	movw	r24, r30
    12e0:	8a 27       	eor	r24, r26
    12e2:	9b 27       	eor	r25, r27
    12e4:	01 c0       	rjmp	.+2      	; 0x12e8 <FWayneSendCommand+0x3be>
        else xCRC= (xCRC>> 1);
    12e6:	cf 01       	movw	r24, r30
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    12e8:	3f 5f       	subi	r19, 0xFF	; 255
    12ea:	38 30       	cpi	r19, 0x08	; 8
    12ec:	99 f7       	brne	.-26     	; 0x12d4 <FWayneSendCommand+0x3aa>
     [51 34 02 01 02 01 01 06 5C FB 03 FA]//Auth4 Nozzle2

	 */
          tCRC16=0;
		  CmdBuffer[0]=0x50|(0x0F&xPumpID);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[0]);
		  CmdBuffer[1]=0x30|(0x0F&SequenceCmd);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[1]);
    12ee:	6f 70       	andi	r22, 0x0F	; 15
    12f0:	60 63       	ori	r22, 0x30	; 48

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    12f2:	e6 2f       	mov	r30, r22
    12f4:	f0 e0       	ldi	r31, 0x00	; 0
    12f6:	e8 27       	eor	r30, r24
    12f8:	f9 27       	eor	r31, r25
    12fa:	30 e0       	ldi	r19, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    12fc:	a1 e0       	ldi	r26, 0x01	; 1
    12fe:	b0 ea       	ldi	r27, 0xA0	; 160
    1300:	cf 01       	movw	r24, r30
    1302:	96 95       	lsr	r25
    1304:	87 95       	ror	r24
    1306:	e0 ff       	sbrs	r30, 0
    1308:	04 c0       	rjmp	.+8      	; 0x1312 <FWayneSendCommand+0x3e8>
    130a:	fc 01       	movw	r30, r24
    130c:	ea 27       	eor	r30, r26
    130e:	fb 27       	eor	r31, r27
    1310:	01 c0       	rjmp	.+2      	; 0x1314 <FWayneSendCommand+0x3ea>
        else xCRC= (xCRC>> 1);
    1312:	fc 01       	movw	r30, r24
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    1314:	3f 5f       	subi	r19, 0xFF	; 255
    1316:	38 30       	cpi	r19, 0x08	; 8
    1318:	99 f7       	brne	.-26     	; 0x1300 <FWayneSendCommand+0x3d6>

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    131a:	82 e0       	ldi	r24, 0x02	; 2
    131c:	90 e0       	ldi	r25, 0x00	; 0
    131e:	8e 27       	eor	r24, r30
    1320:	9f 27       	eor	r25, r31
    1322:	30 e0       	ldi	r19, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    1324:	a1 e0       	ldi	r26, 0x01	; 1
    1326:	b0 ea       	ldi	r27, 0xA0	; 160
    1328:	fc 01       	movw	r30, r24
    132a:	f6 95       	lsr	r31
    132c:	e7 95       	ror	r30
    132e:	80 ff       	sbrs	r24, 0
    1330:	04 c0       	rjmp	.+8      	; 0x133a <FWayneSendCommand+0x410>
    1332:	cf 01       	movw	r24, r30
    1334:	8a 27       	eor	r24, r26
    1336:	9b 27       	eor	r25, r27
    1338:	01 c0       	rjmp	.+2      	; 0x133c <FWayneSendCommand+0x412>
        else xCRC= (xCRC>> 1);
    133a:	cf 01       	movw	r24, r30
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    133c:	3f 5f       	subi	r19, 0xFF	; 255
    133e:	38 30       	cpi	r19, 0x08	; 8
    1340:	99 f7       	brne	.-26     	; 0x1328 <FWayneSendCommand+0x3fe>

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    1342:	a1 e0       	ldi	r26, 0x01	; 1
    1344:	b0 e0       	ldi	r27, 0x00	; 0
    1346:	a8 27       	eor	r26, r24
    1348:	b9 27       	eor	r27, r25
    134a:	30 e0       	ldi	r19, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    134c:	e1 e0       	ldi	r30, 0x01	; 1
    134e:	f0 ea       	ldi	r31, 0xA0	; 160
    1350:	cd 01       	movw	r24, r26
    1352:	96 95       	lsr	r25
    1354:	87 95       	ror	r24
    1356:	a0 ff       	sbrs	r26, 0
    1358:	04 c0       	rjmp	.+8      	; 0x1362 <FWayneSendCommand+0x438>
    135a:	dc 01       	movw	r26, r24
    135c:	ae 27       	eor	r26, r30
    135e:	bf 27       	eor	r27, r31
    1360:	01 c0       	rjmp	.+2      	; 0x1364 <FWayneSendCommand+0x43a>
        else xCRC= (xCRC>> 1);
    1362:	dc 01       	movw	r26, r24
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    1364:	3f 5f       	subi	r19, 0xFF	; 255
    1366:	38 30       	cpi	r19, 0x08	; 8
    1368:	99 f7       	brne	.-26     	; 0x1350 <FWayneSendCommand+0x426>
          tCRC16=0;
		  CmdBuffer[0]=0x50|(0x0F&xPumpID);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[0]);
		  CmdBuffer[1]=0x30|(0x0F&SequenceCmd);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[1]);
		  CmdBuffer[2]=0x02;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[2]);
		  CmdBuffer[3]=0x01;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[3]);
		  CmdBuffer[4]=(NozzleID&0x0F);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[4]);
    136a:	2f 70       	andi	r18, 0x0F	; 15

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    136c:	e2 2f       	mov	r30, r18
    136e:	f0 e0       	ldi	r31, 0x00	; 0
    1370:	ea 27       	eor	r30, r26
    1372:	fb 27       	eor	r31, r27
    1374:	30 e0       	ldi	r19, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    1376:	a1 e0       	ldi	r26, 0x01	; 1
    1378:	b0 ea       	ldi	r27, 0xA0	; 160
    137a:	cf 01       	movw	r24, r30
    137c:	96 95       	lsr	r25
    137e:	87 95       	ror	r24
    1380:	e0 ff       	sbrs	r30, 0
    1382:	04 c0       	rjmp	.+8      	; 0x138c <FWayneSendCommand+0x462>
    1384:	fc 01       	movw	r30, r24
    1386:	ea 27       	eor	r30, r26
    1388:	fb 27       	eor	r31, r27
    138a:	01 c0       	rjmp	.+2      	; 0x138e <FWayneSendCommand+0x464>
        else xCRC= (xCRC>> 1);
    138c:	fc 01       	movw	r30, r24
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    138e:	3f 5f       	subi	r19, 0xFF	; 255
    1390:	38 30       	cpi	r19, 0x08	; 8
    1392:	99 f7       	brne	.-26     	; 0x137a <FWayneSendCommand+0x450>

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    1394:	81 e0       	ldi	r24, 0x01	; 1
    1396:	90 e0       	ldi	r25, 0x00	; 0
    1398:	8e 27       	eor	r24, r30
    139a:	9f 27       	eor	r25, r31
    139c:	30 e0       	ldi	r19, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    139e:	a1 e0       	ldi	r26, 0x01	; 1
    13a0:	b0 ea       	ldi	r27, 0xA0	; 160
    13a2:	fc 01       	movw	r30, r24
    13a4:	f6 95       	lsr	r31
    13a6:	e7 95       	ror	r30
    13a8:	80 ff       	sbrs	r24, 0
    13aa:	04 c0       	rjmp	.+8      	; 0x13b4 <FWayneSendCommand+0x48a>
    13ac:	cf 01       	movw	r24, r30
    13ae:	8a 27       	eor	r24, r26
    13b0:	9b 27       	eor	r25, r27
    13b2:	01 c0       	rjmp	.+2      	; 0x13b6 <FWayneSendCommand+0x48c>
        else xCRC= (xCRC>> 1);
    13b4:	cf 01       	movw	r24, r30
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    13b6:	3f 5f       	subi	r19, 0xFF	; 255
    13b8:	38 30       	cpi	r19, 0x08	; 8
    13ba:	99 f7       	brne	.-26     	; 0x13a2 <FWayneSendCommand+0x478>

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    13bc:	e1 e0       	ldi	r30, 0x01	; 1
    13be:	f0 e0       	ldi	r31, 0x00	; 0
    13c0:	e8 27       	eor	r30, r24
    13c2:	f9 27       	eor	r31, r25
    13c4:	30 e0       	ldi	r19, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    13c6:	a1 e0       	ldi	r26, 0x01	; 1
    13c8:	b0 ea       	ldi	r27, 0xA0	; 160
    13ca:	cf 01       	movw	r24, r30
    13cc:	96 95       	lsr	r25
    13ce:	87 95       	ror	r24
    13d0:	e0 ff       	sbrs	r30, 0
    13d2:	04 c0       	rjmp	.+8      	; 0x13dc <FWayneSendCommand+0x4b2>
    13d4:	fc 01       	movw	r30, r24
    13d6:	ea 27       	eor	r30, r26
    13d8:	fb 27       	eor	r31, r27
    13da:	01 c0       	rjmp	.+2      	; 0x13de <FWayneSendCommand+0x4b4>
        else xCRC= (xCRC>> 1);
    13dc:	fc 01       	movw	r30, r24
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    13de:	3f 5f       	subi	r19, 0xFF	; 255
    13e0:	38 30       	cpi	r19, 0x08	; 8
    13e2:	99 f7       	brne	.-26     	; 0x13ca <FWayneSendCommand+0x4a0>

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    13e4:	a6 e0       	ldi	r26, 0x06	; 6
    13e6:	b0 e0       	ldi	r27, 0x00	; 0
    13e8:	ae 27       	eor	r26, r30
    13ea:	bf 27       	eor	r27, r31
    13ec:	30 e0       	ldi	r19, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    13ee:	e1 e0       	ldi	r30, 0x01	; 1
    13f0:	f0 ea       	ldi	r31, 0xA0	; 160
    13f2:	cd 01       	movw	r24, r26
    13f4:	96 95       	lsr	r25
    13f6:	87 95       	ror	r24
    13f8:	a0 ff       	sbrs	r26, 0
    13fa:	04 c0       	rjmp	.+8      	; 0x1404 <FWayneSendCommand+0x4da>
    13fc:	dc 01       	movw	r26, r24
    13fe:	ae 27       	eor	r26, r30
    1400:	bf 27       	eor	r27, r31
    1402:	01 c0       	rjmp	.+2      	; 0x1406 <FWayneSendCommand+0x4dc>
        else xCRC= (xCRC>> 1);
    1404:	dc 01       	movw	r26, r24
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    1406:	3f 5f       	subi	r19, 0xFF	; 255
    1408:	38 30       	cpi	r19, 0x08	; 8
    140a:	99 f7       	brne	.-26     	; 0x13f2 <FWayneSendCommand+0x4c8>
	 [51 34 02 01 01 01 01 06 5C BF 03 FA]//Auth4 Nozzle1
     [51 34 02 01 02 01 01 06 5C FB 03 FA]//Auth4 Nozzle2

	 */
          tCRC16=0;
		  CmdBuffer[0]=0x50|(0x0F&xPumpID);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[0]);
    140c:	49 83       	std	Y+1, r20	; 0x01
		  CmdBuffer[1]=0x30|(0x0F&SequenceCmd);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[1]);
    140e:	6a 83       	std	Y+2, r22	; 0x02
		  CmdBuffer[2]=0x02;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[2]);
    1410:	82 e0       	ldi	r24, 0x02	; 2
    1412:	8b 83       	std	Y+3, r24	; 0x03
		  CmdBuffer[3]=0x01;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[3]);
    1414:	81 e0       	ldi	r24, 0x01	; 1
    1416:	8c 83       	std	Y+4, r24	; 0x04
		  CmdBuffer[4]=(NozzleID&0x0F);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[4]);
    1418:	2d 83       	std	Y+5, r18	; 0x05
		  CmdBuffer[5]=0x01;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[5]);
    141a:	8e 83       	std	Y+6, r24	; 0x06
		  CmdBuffer[6]=0x01;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[6]);
    141c:	8f 83       	std	Y+7, r24	; 0x07
		  CmdBuffer[7]=0x06;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[7]);
    141e:	86 e0       	ldi	r24, 0x06	; 6
    1420:	88 87       	std	Y+8, r24	; 0x08
		  CmdBuffer[8]=tCRC16;
    1422:	a9 87       	std	Y+9, r26	; 0x09
		  CmdBuffer[9]=tCRC16>>8;
    1424:	8b 2f       	mov	r24, r27
    1426:	99 27       	eor	r25, r25
    1428:	87 fd       	sbrc	r24, 7
    142a:	9a 95       	dec	r25
    142c:	8a 87       	std	Y+10, r24	; 0x0a
		  CmdBuffer[10]=0x03;
    142e:	83 e0       	ldi	r24, 0x03	; 3
    1430:	8b 87       	std	Y+11, r24	; 0x0b
		  CmdBuffer[11]=0xFA;
    1432:	8a ef       	ldi	r24, 0xFA	; 250
    1434:	8c 87       	std	Y+12, r24	; 0x0c
          FWayneSendBuffer(CmdBuffer,12);
    1436:	ce 01       	movw	r24, r28
    1438:	01 96       	adiw	r24, 0x01	; 1
    143a:	6c e0       	ldi	r22, 0x0C	; 12
    143c:	6f c1       	rjmp	.+734    	; 0x171c <FWayneSendCommand+0x7f2>
	      break;     
     case CMD_TOTALIZER://[51] [37] [08 01] [02] [F2 2B] [03 FA] 
          tCRC16=0;     //[51   30   08 01   01   B3 5E   03 FA] //Total N1
		  CmdBuffer[0]=0x50|(0x0F&xPumpID);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[0]);
    143e:	4f 70       	andi	r20, 0x0F	; 15
    1440:	40 65       	ori	r20, 0x50	; 80

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    1442:	84 2f       	mov	r24, r20
    1444:	90 e0       	ldi	r25, 0x00	; 0
    1446:	30 e0       	ldi	r19, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    1448:	a1 e0       	ldi	r26, 0x01	; 1
    144a:	b0 ea       	ldi	r27, 0xA0	; 160
    144c:	fc 01       	movw	r30, r24
    144e:	f6 95       	lsr	r31
    1450:	e7 95       	ror	r30
    1452:	80 ff       	sbrs	r24, 0
    1454:	04 c0       	rjmp	.+8      	; 0x145e <FWayneSendCommand+0x534>
    1456:	cf 01       	movw	r24, r30
    1458:	8a 27       	eor	r24, r26
    145a:	9b 27       	eor	r25, r27
    145c:	01 c0       	rjmp	.+2      	; 0x1460 <FWayneSendCommand+0x536>
        else xCRC= (xCRC>> 1);
    145e:	cf 01       	movw	r24, r30
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    1460:	3f 5f       	subi	r19, 0xFF	; 255
    1462:	38 30       	cpi	r19, 0x08	; 8
    1464:	99 f7       	brne	.-26     	; 0x144c <FWayneSendCommand+0x522>
          FWayneSendBuffer(CmdBuffer,12);
	      break;     
     case CMD_TOTALIZER://[51] [37] [08 01] [02] [F2 2B] [03 FA] 
          tCRC16=0;     //[51   30   08 01   01   B3 5E   03 FA] //Total N1
		  CmdBuffer[0]=0x50|(0x0F&xPumpID);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[0]);
		  CmdBuffer[1]=0x30|(0x0F&SequenceCmd);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[1]);
    1466:	6f 70       	andi	r22, 0x0F	; 15
    1468:	60 63       	ori	r22, 0x30	; 48

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    146a:	e6 2f       	mov	r30, r22
    146c:	f0 e0       	ldi	r31, 0x00	; 0
    146e:	e8 27       	eor	r30, r24
    1470:	f9 27       	eor	r31, r25
    1472:	30 e0       	ldi	r19, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    1474:	a1 e0       	ldi	r26, 0x01	; 1
    1476:	b0 ea       	ldi	r27, 0xA0	; 160
    1478:	cf 01       	movw	r24, r30
    147a:	96 95       	lsr	r25
    147c:	87 95       	ror	r24
    147e:	e0 ff       	sbrs	r30, 0
    1480:	04 c0       	rjmp	.+8      	; 0x148a <FWayneSendCommand+0x560>
    1482:	fc 01       	movw	r30, r24
    1484:	ea 27       	eor	r30, r26
    1486:	fb 27       	eor	r31, r27
    1488:	01 c0       	rjmp	.+2      	; 0x148c <FWayneSendCommand+0x562>
        else xCRC= (xCRC>> 1);
    148a:	fc 01       	movw	r30, r24
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    148c:	3f 5f       	subi	r19, 0xFF	; 255
    148e:	38 30       	cpi	r19, 0x08	; 8
    1490:	99 f7       	brne	.-26     	; 0x1478 <FWayneSendCommand+0x54e>

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    1492:	88 e0       	ldi	r24, 0x08	; 8
    1494:	90 e0       	ldi	r25, 0x00	; 0
    1496:	8e 27       	eor	r24, r30
    1498:	9f 27       	eor	r25, r31
    149a:	30 e0       	ldi	r19, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    149c:	a1 e0       	ldi	r26, 0x01	; 1
    149e:	b0 ea       	ldi	r27, 0xA0	; 160
    14a0:	fc 01       	movw	r30, r24
    14a2:	f6 95       	lsr	r31
    14a4:	e7 95       	ror	r30
    14a6:	80 ff       	sbrs	r24, 0
    14a8:	04 c0       	rjmp	.+8      	; 0x14b2 <FWayneSendCommand+0x588>
    14aa:	cf 01       	movw	r24, r30
    14ac:	8a 27       	eor	r24, r26
    14ae:	9b 27       	eor	r25, r27
    14b0:	01 c0       	rjmp	.+2      	; 0x14b4 <FWayneSendCommand+0x58a>
        else xCRC= (xCRC>> 1);
    14b2:	cf 01       	movw	r24, r30
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    14b4:	3f 5f       	subi	r19, 0xFF	; 255
    14b6:	38 30       	cpi	r19, 0x08	; 8
    14b8:	99 f7       	brne	.-26     	; 0x14a0 <FWayneSendCommand+0x576>

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    14ba:	e1 e0       	ldi	r30, 0x01	; 1
    14bc:	f0 e0       	ldi	r31, 0x00	; 0
    14be:	e8 27       	eor	r30, r24
    14c0:	f9 27       	eor	r31, r25
    14c2:	30 e0       	ldi	r19, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    14c4:	a1 e0       	ldi	r26, 0x01	; 1
    14c6:	b0 ea       	ldi	r27, 0xA0	; 160
    14c8:	cf 01       	movw	r24, r30
    14ca:	96 95       	lsr	r25
    14cc:	87 95       	ror	r24
    14ce:	e0 ff       	sbrs	r30, 0
    14d0:	04 c0       	rjmp	.+8      	; 0x14da <FWayneSendCommand+0x5b0>
    14d2:	fc 01       	movw	r30, r24
    14d4:	ea 27       	eor	r30, r26
    14d6:	fb 27       	eor	r31, r27
    14d8:	01 c0       	rjmp	.+2      	; 0x14dc <FWayneSendCommand+0x5b2>
        else xCRC= (xCRC>> 1);
    14da:	fc 01       	movw	r30, r24
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    14dc:	3f 5f       	subi	r19, 0xFF	; 255
    14de:	38 30       	cpi	r19, 0x08	; 8
    14e0:	99 f7       	brne	.-26     	; 0x14c8 <FWayneSendCommand+0x59e>
          tCRC16=0;     //[51   30   08 01   01   B3 5E   03 FA] //Total N1
		  CmdBuffer[0]=0x50|(0x0F&xPumpID);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[0]);
		  CmdBuffer[1]=0x30|(0x0F&SequenceCmd);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[1]);
		  CmdBuffer[2]=0x08;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[2]);
		  CmdBuffer[3]=0x01;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[3]);
		  CmdBuffer[4]=(NozzleID&0x0F);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[4]);
    14e2:	2f 70       	andi	r18, 0x0F	; 15

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    14e4:	a2 2f       	mov	r26, r18
    14e6:	b0 e0       	ldi	r27, 0x00	; 0
    14e8:	ae 27       	eor	r26, r30
    14ea:	bf 27       	eor	r27, r31
    14ec:	30 e0       	ldi	r19, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    14ee:	e1 e0       	ldi	r30, 0x01	; 1
    14f0:	f0 ea       	ldi	r31, 0xA0	; 160
    14f2:	cd 01       	movw	r24, r26
    14f4:	96 95       	lsr	r25
    14f6:	87 95       	ror	r24
    14f8:	a0 ff       	sbrs	r26, 0
    14fa:	04 c0       	rjmp	.+8      	; 0x1504 <FWayneSendCommand+0x5da>
    14fc:	dc 01       	movw	r26, r24
    14fe:	ae 27       	eor	r26, r30
    1500:	bf 27       	eor	r27, r31
    1502:	01 c0       	rjmp	.+2      	; 0x1506 <FWayneSendCommand+0x5dc>
        else xCRC= (xCRC>> 1);
    1504:	dc 01       	movw	r26, r24
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    1506:	3f 5f       	subi	r19, 0xFF	; 255
    1508:	38 30       	cpi	r19, 0x08	; 8
    150a:	99 f7       	brne	.-26     	; 0x14f2 <FWayneSendCommand+0x5c8>
		  CmdBuffer[11]=0xFA;
          FWayneSendBuffer(CmdBuffer,12);
	      break;     
     case CMD_TOTALIZER://[51] [37] [08 01] [02] [F2 2B] [03 FA] 
          tCRC16=0;     //[51   30   08 01   01   B3 5E   03 FA] //Total N1
		  CmdBuffer[0]=0x50|(0x0F&xPumpID);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[0]);
    150c:	49 83       	std	Y+1, r20	; 0x01
		  CmdBuffer[1]=0x30|(0x0F&SequenceCmd);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[1]);
    150e:	6a 83       	std	Y+2, r22	; 0x02
		  CmdBuffer[2]=0x08;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[2]);
    1510:	3b 83       	std	Y+3, r19	; 0x03
		  CmdBuffer[3]=0x01;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[3]);
    1512:	81 e0       	ldi	r24, 0x01	; 1
    1514:	8c 83       	std	Y+4, r24	; 0x04
		  CmdBuffer[4]=(NozzleID&0x0F);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[4]);
    1516:	2d 83       	std	Y+5, r18	; 0x05
		  CmdBuffer[5]=tCRC16;
    1518:	ae 83       	std	Y+6, r26	; 0x06
		  CmdBuffer[6]=tCRC16>>8;
    151a:	8b 2f       	mov	r24, r27
    151c:	99 27       	eor	r25, r25
    151e:	87 fd       	sbrc	r24, 7
    1520:	9a 95       	dec	r25
    1522:	8f 83       	std	Y+7, r24	; 0x07
		  CmdBuffer[7]=0x03;
    1524:	83 e0       	ldi	r24, 0x03	; 3
    1526:	88 87       	std	Y+8, r24	; 0x08
		  CmdBuffer[8]=0xFA;
    1528:	8a ef       	ldi	r24, 0xFA	; 250
    152a:	89 87       	std	Y+9, r24	; 0x09
          FWayneSendBuffer(CmdBuffer,9);
    152c:	ce 01       	movw	r24, r28
    152e:	01 96       	adiw	r24, 0x01	; 1
    1530:	69 e0       	ldi	r22, 0x09	; 9
    1532:	f4 c0       	rjmp	.+488    	; 0x171c <FWayneSendCommand+0x7f2>
	 /*
  	   [51 30 [01 01] 00 01 01 04 01 01 03 E4 2E [03 FA] //Get Last Status

	 */
          tCRC16=0;
		  CmdBuffer[0]=0x50|(0x0F&xPumpID);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[0]);
    1534:	4f 70       	andi	r20, 0x0F	; 15
    1536:	40 65       	ori	r20, 0x50	; 80

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    1538:	84 2f       	mov	r24, r20
    153a:	90 e0       	ldi	r25, 0x00	; 0
    153c:	50 e0       	ldi	r21, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    153e:	e1 e0       	ldi	r30, 0x01	; 1
    1540:	f0 ea       	ldi	r31, 0xA0	; 160
    1542:	9c 01       	movw	r18, r24
    1544:	36 95       	lsr	r19
    1546:	27 95       	ror	r18
    1548:	80 ff       	sbrs	r24, 0
    154a:	04 c0       	rjmp	.+8      	; 0x1554 <FWayneSendCommand+0x62a>
    154c:	c9 01       	movw	r24, r18
    154e:	8e 27       	eor	r24, r30
    1550:	9f 27       	eor	r25, r31
    1552:	01 c0       	rjmp	.+2      	; 0x1556 <FWayneSendCommand+0x62c>
        else xCRC= (xCRC>> 1);
    1554:	c9 01       	movw	r24, r18
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    1556:	5f 5f       	subi	r21, 0xFF	; 255
    1558:	58 30       	cpi	r21, 0x08	; 8
    155a:	99 f7       	brne	.-26     	; 0x1542 <FWayneSendCommand+0x618>
  	   [51 30 [01 01] 00 01 01 04 01 01 03 E4 2E [03 FA] //Get Last Status

	 */
          tCRC16=0;
		  CmdBuffer[0]=0x50|(0x0F&xPumpID);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[0]);
		  CmdBuffer[1]=0x30|(0x0F&SequenceCmd);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[1]);
    155c:	6f 70       	andi	r22, 0x0F	; 15
    155e:	60 63       	ori	r22, 0x30	; 48

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    1560:	26 2f       	mov	r18, r22
    1562:	30 e0       	ldi	r19, 0x00	; 0
    1564:	28 27       	eor	r18, r24
    1566:	39 27       	eor	r19, r25
    1568:	50 e0       	ldi	r21, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    156a:	e1 e0       	ldi	r30, 0x01	; 1
    156c:	f0 ea       	ldi	r31, 0xA0	; 160
    156e:	c9 01       	movw	r24, r18
    1570:	96 95       	lsr	r25
    1572:	87 95       	ror	r24
    1574:	20 ff       	sbrs	r18, 0
    1576:	04 c0       	rjmp	.+8      	; 0x1580 <FWayneSendCommand+0x656>
    1578:	9c 01       	movw	r18, r24
    157a:	2e 27       	eor	r18, r30
    157c:	3f 27       	eor	r19, r31
    157e:	01 c0       	rjmp	.+2      	; 0x1582 <FWayneSendCommand+0x658>
        else xCRC= (xCRC>> 1);
    1580:	9c 01       	movw	r18, r24
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    1582:	5f 5f       	subi	r21, 0xFF	; 255
    1584:	58 30       	cpi	r21, 0x08	; 8
    1586:	99 f7       	brne	.-26     	; 0x156e <FWayneSendCommand+0x644>

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    1588:	81 e0       	ldi	r24, 0x01	; 1
    158a:	90 e0       	ldi	r25, 0x00	; 0
    158c:	82 27       	eor	r24, r18
    158e:	93 27       	eor	r25, r19
    1590:	50 e0       	ldi	r21, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    1592:	e1 e0       	ldi	r30, 0x01	; 1
    1594:	f0 ea       	ldi	r31, 0xA0	; 160
    1596:	9c 01       	movw	r18, r24
    1598:	36 95       	lsr	r19
    159a:	27 95       	ror	r18
    159c:	80 ff       	sbrs	r24, 0
    159e:	04 c0       	rjmp	.+8      	; 0x15a8 <FWayneSendCommand+0x67e>
    15a0:	c9 01       	movw	r24, r18
    15a2:	8e 27       	eor	r24, r30
    15a4:	9f 27       	eor	r25, r31
    15a6:	01 c0       	rjmp	.+2      	; 0x15aa <FWayneSendCommand+0x680>
        else xCRC= (xCRC>> 1);
    15a8:	c9 01       	movw	r24, r18
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    15aa:	5f 5f       	subi	r21, 0xFF	; 255
    15ac:	58 30       	cpi	r21, 0x08	; 8
    15ae:	99 f7       	brne	.-26     	; 0x1596 <FWayneSendCommand+0x66c>

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    15b0:	21 e0       	ldi	r18, 0x01	; 1
    15b2:	30 e0       	ldi	r19, 0x00	; 0
    15b4:	28 27       	eor	r18, r24
    15b6:	39 27       	eor	r19, r25
    15b8:	50 e0       	ldi	r21, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    15ba:	e1 e0       	ldi	r30, 0x01	; 1
    15bc:	f0 ea       	ldi	r31, 0xA0	; 160
    15be:	c9 01       	movw	r24, r18
    15c0:	96 95       	lsr	r25
    15c2:	87 95       	ror	r24
    15c4:	20 ff       	sbrs	r18, 0
    15c6:	04 c0       	rjmp	.+8      	; 0x15d0 <FWayneSendCommand+0x6a6>
    15c8:	9c 01       	movw	r18, r24
    15ca:	2e 27       	eor	r18, r30
    15cc:	3f 27       	eor	r19, r31
    15ce:	01 c0       	rjmp	.+2      	; 0x15d2 <FWayneSendCommand+0x6a8>
        else xCRC= (xCRC>> 1);
    15d0:	9c 01       	movw	r18, r24
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    15d2:	5f 5f       	subi	r21, 0xFF	; 255
    15d4:	58 30       	cpi	r21, 0x08	; 8
    15d6:	99 f7       	brne	.-26     	; 0x15be <FWayneSendCommand+0x694>
    15d8:	50 e0       	ldi	r21, 0x00	; 0
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    15da:	e1 e0       	ldi	r30, 0x01	; 1
    15dc:	f0 ea       	ldi	r31, 0xA0	; 160
    15de:	c9 01       	movw	r24, r18
    15e0:	96 95       	lsr	r25
    15e2:	87 95       	ror	r24
    15e4:	20 ff       	sbrs	r18, 0
    15e6:	04 c0       	rjmp	.+8      	; 0x15f0 <FWayneSendCommand+0x6c6>
    15e8:	9c 01       	movw	r18, r24
    15ea:	2e 27       	eor	r18, r30
    15ec:	3f 27       	eor	r19, r31
    15ee:	01 c0       	rjmp	.+2      	; 0x15f2 <FWayneSendCommand+0x6c8>
        else xCRC= (xCRC>> 1);
    15f0:	9c 01       	movw	r18, r24
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    15f2:	5f 5f       	subi	r21, 0xFF	; 255
    15f4:	58 30       	cpi	r21, 0x08	; 8
    15f6:	99 f7       	brne	.-26     	; 0x15de <FWayneSendCommand+0x6b4>

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    15f8:	81 e0       	ldi	r24, 0x01	; 1
    15fa:	90 e0       	ldi	r25, 0x00	; 0
    15fc:	82 27       	eor	r24, r18
    15fe:	93 27       	eor	r25, r19
    1600:	50 e0       	ldi	r21, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    1602:	e1 e0       	ldi	r30, 0x01	; 1
    1604:	f0 ea       	ldi	r31, 0xA0	; 160
    1606:	9c 01       	movw	r18, r24
    1608:	36 95       	lsr	r19
    160a:	27 95       	ror	r18
    160c:	80 ff       	sbrs	r24, 0
    160e:	04 c0       	rjmp	.+8      	; 0x1618 <FWayneSendCommand+0x6ee>
    1610:	c9 01       	movw	r24, r18
    1612:	8e 27       	eor	r24, r30
    1614:	9f 27       	eor	r25, r31
    1616:	01 c0       	rjmp	.+2      	; 0x161a <FWayneSendCommand+0x6f0>
        else xCRC= (xCRC>> 1);
    1618:	c9 01       	movw	r24, r18
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    161a:	5f 5f       	subi	r21, 0xFF	; 255
    161c:	58 30       	cpi	r21, 0x08	; 8
    161e:	99 f7       	brne	.-26     	; 0x1606 <FWayneSendCommand+0x6dc>

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    1620:	21 e0       	ldi	r18, 0x01	; 1
    1622:	30 e0       	ldi	r19, 0x00	; 0
    1624:	28 27       	eor	r18, r24
    1626:	39 27       	eor	r19, r25
    1628:	50 e0       	ldi	r21, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    162a:	e1 e0       	ldi	r30, 0x01	; 1
    162c:	f0 ea       	ldi	r31, 0xA0	; 160
    162e:	c9 01       	movw	r24, r18
    1630:	96 95       	lsr	r25
    1632:	87 95       	ror	r24
    1634:	20 ff       	sbrs	r18, 0
    1636:	04 c0       	rjmp	.+8      	; 0x1640 <FWayneSendCommand+0x716>
    1638:	9c 01       	movw	r18, r24
    163a:	2e 27       	eor	r18, r30
    163c:	3f 27       	eor	r19, r31
    163e:	01 c0       	rjmp	.+2      	; 0x1642 <FWayneSendCommand+0x718>
        else xCRC= (xCRC>> 1);
    1640:	9c 01       	movw	r18, r24
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    1642:	5f 5f       	subi	r21, 0xFF	; 255
    1644:	58 30       	cpi	r21, 0x08	; 8
    1646:	99 f7       	brne	.-26     	; 0x162e <FWayneSendCommand+0x704>

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    1648:	84 e0       	ldi	r24, 0x04	; 4
    164a:	90 e0       	ldi	r25, 0x00	; 0
    164c:	82 27       	eor	r24, r18
    164e:	93 27       	eor	r25, r19
    1650:	50 e0       	ldi	r21, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    1652:	e1 e0       	ldi	r30, 0x01	; 1
    1654:	f0 ea       	ldi	r31, 0xA0	; 160
    1656:	9c 01       	movw	r18, r24
    1658:	36 95       	lsr	r19
    165a:	27 95       	ror	r18
    165c:	80 ff       	sbrs	r24, 0
    165e:	04 c0       	rjmp	.+8      	; 0x1668 <FWayneSendCommand+0x73e>
    1660:	c9 01       	movw	r24, r18
    1662:	8e 27       	eor	r24, r30
    1664:	9f 27       	eor	r25, r31
    1666:	01 c0       	rjmp	.+2      	; 0x166a <FWayneSendCommand+0x740>
        else xCRC= (xCRC>> 1);
    1668:	c9 01       	movw	r24, r18
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    166a:	5f 5f       	subi	r21, 0xFF	; 255
    166c:	58 30       	cpi	r21, 0x08	; 8
    166e:	99 f7       	brne	.-26     	; 0x1656 <FWayneSendCommand+0x72c>

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    1670:	21 e0       	ldi	r18, 0x01	; 1
    1672:	30 e0       	ldi	r19, 0x00	; 0
    1674:	28 27       	eor	r18, r24
    1676:	39 27       	eor	r19, r25
    1678:	50 e0       	ldi	r21, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    167a:	e1 e0       	ldi	r30, 0x01	; 1
    167c:	f0 ea       	ldi	r31, 0xA0	; 160
    167e:	c9 01       	movw	r24, r18
    1680:	96 95       	lsr	r25
    1682:	87 95       	ror	r24
    1684:	20 ff       	sbrs	r18, 0
    1686:	04 c0       	rjmp	.+8      	; 0x1690 <FWayneSendCommand+0x766>
    1688:	9c 01       	movw	r18, r24
    168a:	2e 27       	eor	r18, r30
    168c:	3f 27       	eor	r19, r31
    168e:	01 c0       	rjmp	.+2      	; 0x1692 <FWayneSendCommand+0x768>
        else xCRC= (xCRC>> 1);
    1690:	9c 01       	movw	r18, r24
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    1692:	5f 5f       	subi	r21, 0xFF	; 255
    1694:	58 30       	cpi	r21, 0x08	; 8
    1696:	99 f7       	brne	.-26     	; 0x167e <FWayneSendCommand+0x754>

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    1698:	81 e0       	ldi	r24, 0x01	; 1
    169a:	90 e0       	ldi	r25, 0x00	; 0
    169c:	82 27       	eor	r24, r18
    169e:	93 27       	eor	r25, r19
    16a0:	50 e0       	ldi	r21, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    16a2:	e1 e0       	ldi	r30, 0x01	; 1
    16a4:	f0 ea       	ldi	r31, 0xA0	; 160
    16a6:	9c 01       	movw	r18, r24
    16a8:	36 95       	lsr	r19
    16aa:	27 95       	ror	r18
    16ac:	80 ff       	sbrs	r24, 0
    16ae:	04 c0       	rjmp	.+8      	; 0x16b8 <FWayneSendCommand+0x78e>
    16b0:	c9 01       	movw	r24, r18
    16b2:	8e 27       	eor	r24, r30
    16b4:	9f 27       	eor	r25, r31
    16b6:	01 c0       	rjmp	.+2      	; 0x16ba <FWayneSendCommand+0x790>
        else xCRC= (xCRC>> 1);
    16b8:	c9 01       	movw	r24, r18
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    16ba:	5f 5f       	subi	r21, 0xFF	; 255
    16bc:	58 30       	cpi	r21, 0x08	; 8
    16be:	99 f7       	brne	.-26     	; 0x16a6 <FWayneSendCommand+0x77c>

unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    16c0:	e3 e0       	ldi	r30, 0x03	; 3
    16c2:	f0 e0       	ldi	r31, 0x00	; 0
    16c4:	e8 27       	eor	r30, r24
    16c6:	f9 27       	eor	r31, r25
    16c8:	20 e0       	ldi	r18, 0x00	; 0
    for (i = 0; i < 8; i++){//++i){
        if (xCRC& 1) xCRC= (xCRC >> 1) ^ 0xA001;//1010 0000 0000 0001
    16ca:	a1 e0       	ldi	r26, 0x01	; 1
    16cc:	b0 ea       	ldi	r27, 0xA0	; 160
    16ce:	cf 01       	movw	r24, r30
    16d0:	96 95       	lsr	r25
    16d2:	87 95       	ror	r24
    16d4:	e0 ff       	sbrs	r30, 0
    16d6:	04 c0       	rjmp	.+8      	; 0x16e0 <FWayneSendCommand+0x7b6>
    16d8:	fc 01       	movw	r30, r24
    16da:	ea 27       	eor	r30, r26
    16dc:	fb 27       	eor	r31, r27
    16de:	01 c0       	rjmp	.+2      	; 0x16e2 <FWayneSendCommand+0x7b8>
        else xCRC= (xCRC>> 1);
    16e0:	fc 01       	movw	r30, r24
unsigned int CRC_Wayne(unsigned int crc, char a){
    char i;
unsigned int xCRC;
    xCRC=crc;
    xCRC ^= a;
    for (i = 0; i < 8; i++){//++i){
    16e2:	2f 5f       	subi	r18, 0xFF	; 255
    16e4:	28 30       	cpi	r18, 0x08	; 8
    16e6:	99 f7       	brne	.-26     	; 0x16ce <FWayneSendCommand+0x7a4>
	 /*
  	   [51 30 [01 01] 00 01 01 04 01 01 03 E4 2E [03 FA] //Get Last Status

	 */
          tCRC16=0;
		  CmdBuffer[0]=0x50|(0x0F&xPumpID);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[0]);
    16e8:	49 83       	std	Y+1, r20	; 0x01
		  CmdBuffer[1]=0x30|(0x0F&SequenceCmd);tCRC16=CRC_Wayne(tCRC16,CmdBuffer[1]);
    16ea:	6a 83       	std	Y+2, r22	; 0x02
		  CmdBuffer[2]=0x01;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[2]);
    16ec:	91 e0       	ldi	r25, 0x01	; 1
    16ee:	9b 83       	std	Y+3, r25	; 0x03
		  CmdBuffer[3]=0x01;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[3]);
    16f0:	9c 83       	std	Y+4, r25	; 0x04
		  CmdBuffer[4]=0x00;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[4]);
    16f2:	1d 82       	std	Y+5, r1	; 0x05
		  CmdBuffer[5]=0x01;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[5]);
    16f4:	9e 83       	std	Y+6, r25	; 0x06
		  CmdBuffer[6]=0x01;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[6]);
    16f6:	9f 83       	std	Y+7, r25	; 0x07
		  CmdBuffer[7]=0x04;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[7]);
    16f8:	84 e0       	ldi	r24, 0x04	; 4
    16fa:	88 87       	std	Y+8, r24	; 0x08
		  CmdBuffer[8]=0x01;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[8]);
    16fc:	99 87       	std	Y+9, r25	; 0x09
		  CmdBuffer[9]=0x01;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[9]);
    16fe:	9a 87       	std	Y+10, r25	; 0x0a
		  CmdBuffer[10]=0x03;tCRC16=CRC_Wayne(tCRC16,CmdBuffer[10]);
    1700:	23 e0       	ldi	r18, 0x03	; 3
    1702:	2b 87       	std	Y+11, r18	; 0x0b
		  CmdBuffer[11]=tCRC16;
    1704:	ec 87       	std	Y+12, r30	; 0x0c
		  CmdBuffer[12]=tCRC16>>8;
    1706:	8f 2f       	mov	r24, r31
    1708:	99 27       	eor	r25, r25
    170a:	87 fd       	sbrc	r24, 7
    170c:	9a 95       	dec	r25
    170e:	8d 87       	std	Y+13, r24	; 0x0d
		  CmdBuffer[13]=0x03;
    1710:	2e 87       	std	Y+14, r18	; 0x0e
		  CmdBuffer[14]=0xFA;
    1712:	8a ef       	ldi	r24, 0xFA	; 250
    1714:	8f 87       	std	Y+15, r24	; 0x0f
          FWayneSendBuffer(CmdBuffer,15);
    1716:	ce 01       	movw	r24, r28
    1718:	01 96       	adiw	r24, 0x01	; 1
    171a:	6f e0       	ldi	r22, 0x0F	; 15
    171c:	0e 94 82 07 	call	0xf04	; 0xf04 <FWayneSendBuffer>
	      break;
     case CMD_REQ_GLOBAL_STATUS_2:
  	      break;
	 }	 
}
    1720:	6e 96       	adiw	r28, 0x1e	; 30
    1722:	0f b6       	in	r0, 0x3f	; 63
    1724:	f8 94       	cli
    1726:	de bf       	out	0x3e, r29	; 62
    1728:	0f be       	out	0x3f, r0	; 63
    172a:	cd bf       	out	0x3d, r28	; 61
    172c:	cf 91       	pop	r28
    172e:	df 91       	pop	r29
    1730:	1f 91       	pop	r17
    1732:	0f 91       	pop	r16
    1734:	08 95       	ret

00001736 <TerminalSendf>:
	 SendSPI(AckData);
	 SendSPI(0x0A);
	 systemSlave();
}

void TerminalSendf(char Com,char *strSendf){
    1736:	1f 93       	push	r17
    1738:	cf 93       	push	r28
    173a:	df 93       	push	r29
    173c:	18 2f       	mov	r17, r24
    173e:	eb 01       	movw	r28, r22
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    1740:	e1 99       	sbic	0x1c, 1	; 28
    1742:	fe cf       	rjmp	.-4      	; 0x1740 <TerminalSendf+0xa>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    1744:	84 e0       	ldi	r24, 0x04	; 4
    1746:	90 e0       	ldi	r25, 0x00	; 0
    1748:	9f bb       	out	0x1f, r25	; 31
    174a:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    174c:	e0 9a       	sbi	0x1c, 0	; 28
    174e:	8d b3       	in	r24, 0x1d	; 29
   if (eeprom_read_byte(&DefTerminalDebug)){
    1750:	88 23       	and	r24, r24
    1752:	41 f4       	brne	.+16     	; 0x1764 <TerminalSendf+0x2e>
    1754:	0c c0       	rjmp	.+24     	; 0x176e <TerminalSendf+0x38>
       while(pgm_read_byte(&(*strSendf)))
	         _uart(Com, 1, pgm_read_byte(&(*strSendf++)));
    1756:	21 96       	adiw	r28, 0x01	; 1
    1758:	f9 01       	movw	r30, r18
    175a:	44 91       	lpm	r20, Z+
    175c:	81 2f       	mov	r24, r17
    175e:	61 e0       	ldi	r22, 0x01	; 1
    1760:	0e 94 58 18 	call	0x30b0	; 0x30b0 <_uart>
    1764:	9e 01       	movw	r18, r28
	 systemSlave();
}

void TerminalSendf(char Com,char *strSendf){
   if (eeprom_read_byte(&DefTerminalDebug)){
       while(pgm_read_byte(&(*strSendf)))
    1766:	fe 01       	movw	r30, r28
    1768:	84 91       	lpm	r24, Z+
    176a:	88 23       	and	r24, r24
    176c:	a1 f7       	brne	.-24     	; 0x1756 <TerminalSendf+0x20>
	         _uart(Com, 1, pgm_read_byte(&(*strSendf++)));
	}
}
    176e:	df 91       	pop	r29
    1770:	cf 91       	pop	r28
    1772:	1f 91       	pop	r17
    1774:	08 95       	ret

00001776 <SendTotalizerFlow>:
	    SendSPI(strSendSPI[i]);
        //_uart(1,1,strSendSPI[i]);
	 } 
}

void SendTotalizerFlow(char xPumpID){
    1776:	4f 92       	push	r4
    1778:	5f 92       	push	r5
    177a:	6f 92       	push	r6
    177c:	7f 92       	push	r7
    177e:	8f 92       	push	r8
    1780:	9f 92       	push	r9
    1782:	af 92       	push	r10
    1784:	bf 92       	push	r11
    1786:	cf 92       	push	r12
    1788:	df 92       	push	r13
    178a:	ef 92       	push	r14
    178c:	ff 92       	push	r15
    178e:	0f 93       	push	r16
    1790:	1f 93       	push	r17
    1792:	df 93       	push	r29
    1794:	cf 93       	push	r28
    1796:	cd b7       	in	r28, 0x3d	; 61
    1798:	de b7       	in	r29, 0x3e	; 62
    179a:	a8 97       	sbiw	r28, 0x28	; 40
    179c:	0f b6       	in	r0, 0x3f	; 63
    179e:	f8 94       	cli
    17a0:	de bf       	out	0x3e, r29	; 62
    17a2:	0f be       	out	0x3f, r0	; 63
    17a4:	cd bf       	out	0x3d, r28	; 61
char i,xPump,strSend[40];
char strVol[10],strMon[10];
	 //                           [0x50,0x05]  02     01    0000000  0000000  0000000  0000000  0000200  0000000  0000200  0000000  0000000  0000000 [0x06,0x60] = 4+8*2*6=76
	 //Sending FlowSPI_Protocol     <STX>   [MsgID][PumpID][Volume1][Amount1][Volume2][Amount2][Volume3][Amount3][Volume4][Amount4][Volume5][Amount5][Volume6][Amount6]<ETX>
	 if (xPumpID>=16)xPump=16;
    17a6:	80 31       	cpi	r24, 0x10	; 16
    17a8:	10 f4       	brcc	.+4      	; 0x17ae <SendTotalizerFlow+0x38>
    17aa:	f8 2e       	mov	r15, r24
    17ac:	02 c0       	rjmp	.+4      	; 0x17b2 <SendTotalizerFlow+0x3c>
    17ae:	00 e1       	ldi	r16, 0x10	; 16
    17b0:	f0 2e       	mov	r15, r16
	 else xPump=xPumpID;
                                                
	 systemMaster();
    17b2:	0e 94 bb 06 	call	0xd76	; 0xd76 <systemMaster>
	sbi(DDRD,2);sbi(PORTD,2);//128-SS HIGH
	//_delay_ms(10);
}

void SendSPI(char xSPI){
     _spi(xSPI);
    17b6:	85 e0       	ldi	r24, 0x05	; 5
    17b8:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_spi>
void uartGilbarco(){
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    17bc:	80 e5       	ldi	r24, 0x50	; 80
    17be:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_spi>
    17c2:	2e 01       	movw	r4, r28
    17c4:	08 94       	sec
    17c6:	41 1c       	adc	r4, r1
    17c8:	51 1c       	adc	r5, r1
    17ca:	52 01       	movw	r10, r4
    17cc:	ce 01       	movw	r24, r28
    17ce:	89 96       	adiw	r24, 0x29	; 41
	     strMemory[i]=data;
    17d0:	d5 01       	movw	r26, r10
    17d2:	1d 92       	st	X+, r1
    17d4:	5d 01       	movw	r10, r26
void uartGilbarco(){
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    17d6:	a8 17       	cp	r26, r24
    17d8:	b9 07       	cpc	r27, r25
    17da:	d1 f7       	brne	.-12     	; 0x17d0 <SendTotalizerFlow+0x5a>
	 systemMaster();
	 SendSPI(0x05);//STX
	 SendSPI(0x50);//STX
	 FillChar(strSend,sizeof(strSend),0);
	
	 sprintf_P(strSend,PSTR("02%.2d"),xPump);
    17dc:	00 d0       	rcall	.+0      	; 0x17de <SendTotalizerFlow+0x68>
    17de:	00 d0       	rcall	.+0      	; 0x17e0 <SendTotalizerFlow+0x6a>
    17e0:	00 d0       	rcall	.+0      	; 0x17e2 <SendTotalizerFlow+0x6c>
    17e2:	ed b7       	in	r30, 0x3d	; 61
    17e4:	fe b7       	in	r31, 0x3e	; 62
    17e6:	31 96       	adiw	r30, 0x01	; 1
    17e8:	8e 01       	movw	r16, r28
    17ea:	0f 5f       	subi	r16, 0xFF	; 255
    17ec:	1f 4f       	sbci	r17, 0xFF	; 255
    17ee:	ad b7       	in	r26, 0x3d	; 61
    17f0:	be b7       	in	r27, 0x3e	; 62
    17f2:	12 96       	adiw	r26, 0x02	; 2
    17f4:	1c 93       	st	X, r17
    17f6:	0e 93       	st	-X, r16
    17f8:	11 97       	sbiw	r26, 0x01	; 1
    17fa:	80 e4       	ldi	r24, 0x40	; 64
    17fc:	91 e0       	ldi	r25, 0x01	; 1
    17fe:	93 83       	std	Z+3, r25	; 0x03
    1800:	82 83       	std	Z+2, r24	; 0x02
    1802:	f4 82       	std	Z+4, r15	; 0x04
    1804:	15 82       	std	Z+5, r1	; 0x05
    1806:	0e 94 c0 18 	call	0x3180	; 0x3180 <sprintf_P>
     SendStrSPI(strSend);
    180a:	ed b7       	in	r30, 0x3d	; 61
    180c:	fe b7       	in	r31, 0x3e	; 62
    180e:	36 96       	adiw	r30, 0x06	; 6
    1810:	0f b6       	in	r0, 0x3f	; 63
    1812:	f8 94       	cli
    1814:	fe bf       	out	0x3e, r31	; 62
    1816:	0f be       	out	0x3f, r0	; 63
    1818:	ed bf       	out	0x3d, r30	; 61
    181a:	c8 01       	movw	r24, r16
    181c:	0e 94 8e 06 	call	0xd1c	; 0xd1c <SendStrSPI>
    1820:	ee 24       	eor	r14, r14
    1822:	ff 24       	eor	r15, r15
     for (i=0;i<6;i++){
	      //FixingData V:[00000000] M:[00000000]
		  AddZeroLead(PumpTotalizer.TotalGrade[i].strMoney,12);
		  AddZeroLead(PumpTotalizer.TotalGrade[i].strVolume,12);
		  FillChar(strSend,sizeof(strSend),0);
		  sprintf_P(strSend,PSTR("%s%s"),PumpTotalizer.TotalGrade[i].strVolume,PumpTotalizer.TotalGrade[i].strMoney);
    1824:	90 2e       	mov	r9, r16
    1826:	81 2e       	mov	r8, r17
    1828:	1b e3       	ldi	r17, 0x3B	; 59
    182a:	61 2e       	mov	r6, r17
    182c:	11 e0       	ldi	r17, 0x01	; 1
    182e:	71 2e       	mov	r7, r17
	 sprintf_P(strSend,PSTR("02%.2d"),xPump);
     SendStrSPI(strSend);

     for (i=0;i<6;i++){
	      //FixingData V:[00000000] M:[00000000]
		  AddZeroLead(PumpTotalizer.TotalGrade[i].strMoney,12);
    1830:	c7 01       	movw	r24, r14
    1832:	67 01       	movw	r12, r14
    1834:	b5 e0       	ldi	r27, 0x05	; 5
    1836:	cc 0c       	add	r12, r12
    1838:	dd 1c       	adc	r13, r13
    183a:	ba 95       	dec	r27
    183c:	e1 f7       	brne	.-8      	; 0x1836 <SendTotalizerFlow+0xc0>
    183e:	88 0f       	add	r24, r24
    1840:	99 1f       	adc	r25, r25
    1842:	c8 1a       	sub	r12, r24
    1844:	d9 0a       	sbc	r13, r25
    1846:	86 e0       	ldi	r24, 0x06	; 6
    1848:	93 e0       	ldi	r25, 0x03	; 3
    184a:	c8 0e       	add	r12, r24
    184c:	d9 1e       	adc	r13, r25
    184e:	c6 01       	movw	r24, r12
    1850:	6c e0       	ldi	r22, 0x0C	; 12
    1852:	0e 94 e7 03 	call	0x7ce	; 0x7ce <AddZeroLead>
		  AddZeroLead(PumpTotalizer.TotalGrade[i].strVolume,12);
    1856:	c7 01       	movw	r24, r14
    1858:	87 01       	movw	r16, r14
    185a:	f5 e0       	ldi	r31, 0x05	; 5
    185c:	00 0f       	add	r16, r16
    185e:	11 1f       	adc	r17, r17
    1860:	fa 95       	dec	r31
    1862:	e1 f7       	brne	.-8      	; 0x185c <SendTotalizerFlow+0xe6>
    1864:	88 0f       	add	r24, r24
    1866:	99 1f       	adc	r25, r25
    1868:	08 1b       	sub	r16, r24
    186a:	19 0b       	sbc	r17, r25
    186c:	09 50       	subi	r16, 0x09	; 9
    186e:	1d 4f       	sbci	r17, 0xFD	; 253
    1870:	c8 01       	movw	r24, r16
    1872:	6c e0       	ldi	r22, 0x0C	; 12
    1874:	0e 94 e7 03 	call	0x7ce	; 0x7ce <AddZeroLead>
    1878:	f2 01       	movw	r30, r4
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    187a:	11 92       	st	Z+, r1
void uartGilbarco(){
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    187c:	ea 15       	cp	r30, r10
    187e:	fb 05       	cpc	r31, r11
    1880:	e1 f7       	brne	.-8      	; 0x187a <SendTotalizerFlow+0x104>
     for (i=0;i<6;i++){
	      //FixingData V:[00000000] M:[00000000]
		  AddZeroLead(PumpTotalizer.TotalGrade[i].strMoney,12);
		  AddZeroLead(PumpTotalizer.TotalGrade[i].strVolume,12);
		  FillChar(strSend,sizeof(strSend),0);
		  sprintf_P(strSend,PSTR("%s%s"),PumpTotalizer.TotalGrade[i].strVolume,PumpTotalizer.TotalGrade[i].strMoney);
    1882:	ad b7       	in	r26, 0x3d	; 61
    1884:	be b7       	in	r27, 0x3e	; 62
    1886:	18 97       	sbiw	r26, 0x08	; 8
    1888:	0f b6       	in	r0, 0x3f	; 63
    188a:	f8 94       	cli
    188c:	be bf       	out	0x3e, r27	; 62
    188e:	0f be       	out	0x3f, r0	; 63
    1890:	ad bf       	out	0x3d, r26	; 61
    1892:	ed b7       	in	r30, 0x3d	; 61
    1894:	fe b7       	in	r31, 0x3e	; 62
    1896:	31 96       	adiw	r30, 0x01	; 1
    1898:	11 96       	adiw	r26, 0x01	; 1
    189a:	9c 92       	st	X, r9
    189c:	11 97       	sbiw	r26, 0x01	; 1
    189e:	12 96       	adiw	r26, 0x02	; 2
    18a0:	8c 92       	st	X, r8
    18a2:	73 82       	std	Z+3, r7	; 0x03
    18a4:	62 82       	std	Z+2, r6	; 0x02
    18a6:	15 83       	std	Z+5, r17	; 0x05
    18a8:	04 83       	std	Z+4, r16	; 0x04
    18aa:	d7 82       	std	Z+7, r13	; 0x07
    18ac:	c6 82       	std	Z+6, r12	; 0x06
    18ae:	0e 94 c0 18 	call	0x3180	; 0x3180 <sprintf_P>
          SendStrSPI(strSend);
    18b2:	ed b7       	in	r30, 0x3d	; 61
    18b4:	fe b7       	in	r31, 0x3e	; 62
    18b6:	38 96       	adiw	r30, 0x08	; 8
    18b8:	0f b6       	in	r0, 0x3f	; 63
    18ba:	f8 94       	cli
    18bc:	fe bf       	out	0x3e, r31	; 62
    18be:	0f be       	out	0x3f, r0	; 63
    18c0:	ed bf       	out	0x3d, r30	; 61
    18c2:	89 2d       	mov	r24, r9
    18c4:	98 2d       	mov	r25, r8
    18c6:	0e 94 8e 06 	call	0xd1c	; 0xd1c <SendStrSPI>
    18ca:	08 94       	sec
    18cc:	e1 1c       	adc	r14, r1
    18ce:	f1 1c       	adc	r15, r1
	 FillChar(strSend,sizeof(strSend),0);
	
	 sprintf_P(strSend,PSTR("02%.2d"),xPump);
     SendStrSPI(strSend);

     for (i=0;i<6;i++){
    18d0:	f6 e0       	ldi	r31, 0x06	; 6
    18d2:	ef 16       	cp	r14, r31
    18d4:	f1 04       	cpc	r15, r1
    18d6:	09 f0       	breq	.+2      	; 0x18da <SendTotalizerFlow+0x164>
    18d8:	ab cf       	rjmp	.-170    	; 0x1830 <SendTotalizerFlow+0xba>
		  #ifdef DEBUG_TOTAL_FLOW 
		  _uart_print(1,1,strSend);
		  #endif
	 }
	 //TotalizerDigit
	 sprintf_P(strSend,PSTR("%d"),PumpTotalDigit);
    18da:	00 d0       	rcall	.+0      	; 0x18dc <SendTotalizerFlow+0x166>
    18dc:	00 d0       	rcall	.+0      	; 0x18de <SendTotalizerFlow+0x168>
    18de:	00 d0       	rcall	.+0      	; 0x18e0 <SendTotalizerFlow+0x16a>
    18e0:	ed b7       	in	r30, 0x3d	; 61
    18e2:	fe b7       	in	r31, 0x3e	; 62
    18e4:	31 96       	adiw	r30, 0x01	; 1
    18e6:	ad b7       	in	r26, 0x3d	; 61
    18e8:	be b7       	in	r27, 0x3e	; 62
    18ea:	11 96       	adiw	r26, 0x01	; 1
    18ec:	9c 92       	st	X, r9
    18ee:	11 97       	sbiw	r26, 0x01	; 1
    18f0:	12 96       	adiw	r26, 0x02	; 2
    18f2:	8c 92       	st	X, r8
    18f4:	88 e3       	ldi	r24, 0x38	; 56
    18f6:	91 e0       	ldi	r25, 0x01	; 1
    18f8:	93 83       	std	Z+3, r25	; 0x03
    18fa:	82 83       	std	Z+2, r24	; 0x02
    18fc:	80 91 0c 01 	lds	r24, 0x010C
    1900:	84 83       	std	Z+4, r24	; 0x04
    1902:	15 82       	std	Z+5, r1	; 0x05
    1904:	0e 94 c0 18 	call	0x3180	; 0x3180 <sprintf_P>
     SendStrSPI(strSend);
    1908:	ed b7       	in	r30, 0x3d	; 61
    190a:	fe b7       	in	r31, 0x3e	; 62
    190c:	36 96       	adiw	r30, 0x06	; 6
    190e:	0f b6       	in	r0, 0x3f	; 63
    1910:	f8 94       	cli
    1912:	fe bf       	out	0x3e, r31	; 62
    1914:	0f be       	out	0x3f, r0	; 63
    1916:	ed bf       	out	0x3d, r30	; 61
    1918:	89 2d       	mov	r24, r9
    191a:	98 2d       	mov	r25, r8
    191c:	0e 94 8e 06 	call	0xd1c	; 0xd1c <SendStrSPI>
	sbi(DDRD,2);sbi(PORTD,2);//128-SS HIGH
	//_delay_ms(10);
}

void SendSPI(char xSPI){
     _spi(xSPI);
    1920:	86 e0       	ldi	r24, 0x06	; 6
    1922:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_spi>
	 sprintf_P(strSend,PSTR("%d"),PumpTotalDigit);
     SendStrSPI(strSend);

	 SendSPI(0x06);//ETX
	 SendSPI(0x60);//ETX
	 systemSlave();
    1926:	80 e6       	ldi	r24, 0x60	; 96
    1928:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_spi>
    192c:	0e 94 ae 06 	call	0xd5c	; 0xd5c <systemSlave>
    1930:	8a ef       	ldi	r24, 0xFA	; 250
    1932:	90 e0       	ldi	r25, 0x00	; 0
    1934:	01 97       	sbiw	r24, 0x01	; 1
    1936:	f1 f7       	brne	.-4      	; 0x1934 <SendTotalizerFlow+0x1be>
	 _delay_ms(1);//DelayProses
}
    1938:	a8 96       	adiw	r28, 0x28	; 40
    193a:	0f b6       	in	r0, 0x3f	; 63
    193c:	f8 94       	cli
    193e:	de bf       	out	0x3e, r29	; 62
    1940:	0f be       	out	0x3f, r0	; 63
    1942:	cd bf       	out	0x3d, r28	; 61
    1944:	cf 91       	pop	r28
    1946:	df 91       	pop	r29
    1948:	1f 91       	pop	r17
    194a:	0f 91       	pop	r16
    194c:	ff 90       	pop	r15
    194e:	ef 90       	pop	r14
    1950:	df 90       	pop	r13
    1952:	cf 90       	pop	r12
    1954:	bf 90       	pop	r11
    1956:	af 90       	pop	r10
    1958:	9f 90       	pop	r9
    195a:	8f 90       	pop	r8
    195c:	7f 90       	pop	r7
    195e:	6f 90       	pop	r6
    1960:	5f 90       	pop	r5
    1962:	4f 90       	pop	r4
    1964:	08 95       	ret

00001966 <SendTransFlow>:
	 SendSPI(0x08);//ETX

	 systemSlave();
}

void SendTransFlow(char xPumpID, char rxPumpId,char xNozzleID,char xProductID, char *sUnitPrice, char *sVolume,char * sAmount,char TransDigit){
    1966:	6f 92       	push	r6
    1968:	7f 92       	push	r7
    196a:	8f 92       	push	r8
    196c:	9f 92       	push	r9
    196e:	af 92       	push	r10
    1970:	bf 92       	push	r11
    1972:	cf 92       	push	r12
    1974:	df 92       	push	r13
    1976:	ef 92       	push	r14
    1978:	ff 92       	push	r15
    197a:	0f 93       	push	r16
    197c:	1f 93       	push	r17
    197e:	df 93       	push	r29
    1980:	cf 93       	push	r28
    1982:	cd b7       	in	r28, 0x3d	; 61
    1984:	de b7       	in	r29, 0x3e	; 62
    1986:	6e 97       	sbiw	r28, 0x1e	; 30
    1988:	0f b6       	in	r0, 0x3f	; 63
    198a:	f8 94       	cli
    198c:	de bf       	out	0x3e, r29	; 62
    198e:	0f be       	out	0x3f, r0	; 63
    1990:	cd bf       	out	0x3d, r28	; 61
    1992:	68 2e       	mov	r6, r24
    1994:	b4 2e       	mov	r11, r20
    1996:	72 2e       	mov	r7, r18
    1998:	48 01       	movw	r8, r16
     char i,xNozzle,xPrd,xPump,strSend[30];

	                         //  [0x50,0x05]  01       01       1        3       004500   00000200  00000000 [0x06,0x60] = 24
	 //Sending FlowSPI_Protocol     <STX>   [MsgID][PumpID][Nozzle][ProductID][UnitPrice][Volume][Amount] <ETX>
	 AddZeroLead(sUnitPrice,6);//         Wyne    01 02 2 0 004600 00000254 00011684
    199a:	c8 01       	movw	r24, r16
    199c:	66 e0       	ldi	r22, 0x06	; 6
    199e:	0e 94 e7 03 	call	0x7ce	; 0x7ce <AddZeroLead>
     AddZeroLead(sVolume,8);
    19a2:	c7 01       	movw	r24, r14
    19a4:	68 e0       	ldi	r22, 0x08	; 8
    19a6:	0e 94 e7 03 	call	0x7ce	; 0x7ce <AddZeroLead>
     AddZeroLead(sAmount,8);
    19aa:	c6 01       	movw	r24, r12
    19ac:	68 e0       	ldi	r22, 0x08	; 8
    19ae:	0e 94 e7 03 	call	0x7ce	; 0x7ce <AddZeroLead>
	 
	 if (xNozzleID>=4)xNozzle=4;
    19b2:	83 e0       	ldi	r24, 0x03	; 3
    19b4:	8b 15       	cp	r24, r11
    19b6:	10 f0       	brcs	.+4      	; 0x19bc <SendTransFlow+0x56>
    19b8:	4b 2d       	mov	r20, r11
    19ba:	01 c0       	rjmp	.+2      	; 0x19be <SendTransFlow+0x58>
    19bc:	44 e0       	ldi	r20, 0x04	; 4
	 else xNozzle=xNozzleID;
	 
	 if (xProductID>=4)xPrd=4;
    19be:	93 e0       	ldi	r25, 0x03	; 3
    19c0:	97 15       	cp	r25, r7
    19c2:	10 f0       	brcs	.+4      	; 0x19c8 <SendTransFlow+0x62>
    19c4:	27 2d       	mov	r18, r7
    19c6:	01 c0       	rjmp	.+2      	; 0x19ca <SendTransFlow+0x64>
    19c8:	24 e0       	ldi	r18, 0x04	; 4
	 else xPrd=xProductID;

	 if (xPumpID>=16)xPump=16;
    19ca:	af e0       	ldi	r26, 0x0F	; 15
    19cc:	a6 15       	cp	r26, r6
    19ce:	10 f0       	brcs	.+4      	; 0x19d4 <SendTransFlow+0x6e>
    19d0:	36 2d       	mov	r19, r6
    19d2:	01 c0       	rjmp	.+2      	; 0x19d6 <SendTransFlow+0x70>
    19d4:	30 e1       	ldi	r19, 0x10	; 16
	 else xPump=xPumpID;

	 sprintf_P(strSend,PSTR("01%.2d%.1d%.1d%s%s%s"),xPump,xNozzle,xPrd,sUnitPrice,sVolume,sAmount);
    19d6:	8d b7       	in	r24, 0x3d	; 61
    19d8:	9e b7       	in	r25, 0x3e	; 62
    19da:	40 97       	sbiw	r24, 0x10	; 16
    19dc:	0f b6       	in	r0, 0x3f	; 63
    19de:	f8 94       	cli
    19e0:	9e bf       	out	0x3e, r25	; 62
    19e2:	0f be       	out	0x3f, r0	; 63
    19e4:	8d bf       	out	0x3d, r24	; 61
    19e6:	ed b7       	in	r30, 0x3d	; 61
    19e8:	fe b7       	in	r31, 0x3e	; 62
    19ea:	31 96       	adiw	r30, 0x01	; 1
    19ec:	8e 01       	movw	r16, r28
    19ee:	0f 5f       	subi	r16, 0xFF	; 255
    19f0:	1f 4f       	sbci	r17, 0xFF	; 255
    19f2:	ad b7       	in	r26, 0x3d	; 61
    19f4:	be b7       	in	r27, 0x3e	; 62
    19f6:	12 96       	adiw	r26, 0x02	; 2
    19f8:	1c 93       	st	X, r17
    19fa:	0e 93       	st	-X, r16
    19fc:	11 97       	sbiw	r26, 0x01	; 1
    19fe:	8a e4       	ldi	r24, 0x4A	; 74
    1a00:	91 e0       	ldi	r25, 0x01	; 1
    1a02:	93 83       	std	Z+3, r25	; 0x03
    1a04:	82 83       	std	Z+2, r24	; 0x02
    1a06:	34 83       	std	Z+4, r19	; 0x04
    1a08:	15 82       	std	Z+5, r1	; 0x05
    1a0a:	46 83       	std	Z+6, r20	; 0x06
    1a0c:	17 82       	std	Z+7, r1	; 0x07
    1a0e:	20 87       	std	Z+8, r18	; 0x08
    1a10:	11 86       	std	Z+9, r1	; 0x09
    1a12:	93 86       	std	Z+11, r9	; 0x0b
    1a14:	82 86       	std	Z+10, r8	; 0x0a
    1a16:	f5 86       	std	Z+13, r15	; 0x0d
    1a18:	e4 86       	std	Z+12, r14	; 0x0c
    1a1a:	d7 86       	std	Z+15, r13	; 0x0f
    1a1c:	c6 86       	std	Z+14, r12	; 0x0e
    1a1e:	0e 94 c0 18 	call	0x3180	; 0x3180 <sprintf_P>
	 systemMaster();
    1a22:	8d b7       	in	r24, 0x3d	; 61
    1a24:	9e b7       	in	r25, 0x3e	; 62
    1a26:	40 96       	adiw	r24, 0x10	; 16
    1a28:	0f b6       	in	r0, 0x3f	; 63
    1a2a:	f8 94       	cli
    1a2c:	9e bf       	out	0x3e, r25	; 62
    1a2e:	0f be       	out	0x3f, r0	; 63
    1a30:	8d bf       	out	0x3d, r24	; 61
    1a32:	0e 94 bb 06 	call	0xd76	; 0xd76 <systemMaster>
	sbi(DDRD,2);sbi(PORTD,2);//128-SS HIGH
	//_delay_ms(10);
}

void SendSPI(char xSPI){
     _spi(xSPI);
    1a36:	85 e0       	ldi	r24, 0x05	; 5
    1a38:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_spi>

	 sprintf_P(strSend,PSTR("01%.2d%.1d%.1d%s%s%s"),xPump,xNozzle,xPrd,sUnitPrice,sVolume,sAmount);
	 systemMaster();
	 SendSPI(0x05);//STX
	 SendSPI(0x50);//STX
	 for(i=0;i<strlen(strSend);i++){
    1a3c:	80 e5       	ldi	r24, 0x50	; 80
    1a3e:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_spi>
    1a42:	ff 24       	eor	r15, r15
    1a44:	06 c0       	rjmp	.+12     	; 0x1a52 <SendTransFlow+0xec>
    1a46:	a0 0f       	add	r26, r16
    1a48:	b1 1f       	adc	r27, r17
    1a4a:	8c 91       	ld	r24, X
    1a4c:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_spi>
    1a50:	f3 94       	inc	r15
    1a52:	f8 01       	movw	r30, r16
    1a54:	01 90       	ld	r0, Z+
    1a56:	00 20       	and	r0, r0
    1a58:	e9 f7       	brne	.-6      	; 0x1a54 <SendTransFlow+0xee>
    1a5a:	31 97       	sbiw	r30, 0x01	; 1
    1a5c:	e0 1b       	sub	r30, r16
    1a5e:	f1 0b       	sbc	r31, r17
    1a60:	af 2d       	mov	r26, r15
    1a62:	b0 e0       	ldi	r27, 0x00	; 0
    1a64:	ae 17       	cp	r26, r30
    1a66:	bf 07       	cpc	r27, r31
    1a68:	70 f3       	brcs	.-36     	; 0x1a46 <SendTransFlow+0xe0>
		 #ifdef DEBUG_TRANS_FLOW 
		 _uart(1,1,strSend[i]);
		 #endif
	 }
	 //TransDigit
	 sprintf_P(strSend,PSTR("%d"),TransDigit);
    1a6a:	00 d0       	rcall	.+0      	; 0x1a6c <SendTransFlow+0x106>
    1a6c:	00 d0       	rcall	.+0      	; 0x1a6e <SendTransFlow+0x108>
    1a6e:	00 d0       	rcall	.+0      	; 0x1a70 <SendTransFlow+0x10a>
    1a70:	ed b7       	in	r30, 0x3d	; 61
    1a72:	fe b7       	in	r31, 0x3e	; 62
    1a74:	31 96       	adiw	r30, 0x01	; 1
    1a76:	ad b7       	in	r26, 0x3d	; 61
    1a78:	be b7       	in	r27, 0x3e	; 62
    1a7a:	12 96       	adiw	r26, 0x02	; 2
    1a7c:	1c 93       	st	X, r17
    1a7e:	0e 93       	st	-X, r16
    1a80:	11 97       	sbiw	r26, 0x01	; 1
    1a82:	87 e4       	ldi	r24, 0x47	; 71
    1a84:	91 e0       	ldi	r25, 0x01	; 1
    1a86:	93 83       	std	Z+3, r25	; 0x03
    1a88:	82 83       	std	Z+2, r24	; 0x02
    1a8a:	a4 82       	std	Z+4, r10	; 0x04
    1a8c:	15 82       	std	Z+5, r1	; 0x05
    1a8e:	0e 94 c0 18 	call	0x3180	; 0x3180 <sprintf_P>
     SendStrSPI(strSend);
    1a92:	8d b7       	in	r24, 0x3d	; 61
    1a94:	9e b7       	in	r25, 0x3e	; 62
    1a96:	06 96       	adiw	r24, 0x06	; 6
    1a98:	0f b6       	in	r0, 0x3f	; 63
    1a9a:	f8 94       	cli
    1a9c:	9e bf       	out	0x3e, r25	; 62
    1a9e:	0f be       	out	0x3f, r0	; 63
    1aa0:	8d bf       	out	0x3d, r24	; 61
    1aa2:	c8 01       	movw	r24, r16
    1aa4:	0e 94 8e 06 	call	0xd1c	; 0xd1c <SendStrSPI>
	sbi(DDRD,2);sbi(PORTD,2);//128-SS HIGH
	//_delay_ms(10);
}

void SendSPI(char xSPI){
     _spi(xSPI);
    1aa8:	86 e0       	ldi	r24, 0x06	; 6
    1aaa:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_spi>
	 sprintf_P(strSend,PSTR("%d"),TransDigit);
     SendStrSPI(strSend);

	 SendSPI(0x06);//ETX
	 SendSPI(0x60);//ETX
	 systemSlave();
    1aae:	80 e6       	ldi	r24, 0x60	; 96
    1ab0:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_spi>
    1ab4:	0e 94 ae 06 	call	0xd5c	; 0xd5c <systemSlave>
}
    1ab8:	6e 96       	adiw	r28, 0x1e	; 30
    1aba:	0f b6       	in	r0, 0x3f	; 63
    1abc:	f8 94       	cli
    1abe:	de bf       	out	0x3e, r29	; 62
    1ac0:	0f be       	out	0x3f, r0	; 63
    1ac2:	cd bf       	out	0x3d, r28	; 61
    1ac4:	cf 91       	pop	r28
    1ac6:	df 91       	pop	r29
    1ac8:	1f 91       	pop	r17
    1aca:	0f 91       	pop	r16
    1acc:	ff 90       	pop	r15
    1ace:	ef 90       	pop	r14
    1ad0:	df 90       	pop	r13
    1ad2:	cf 90       	pop	r12
    1ad4:	bf 90       	pop	r11
    1ad6:	af 90       	pop	r10
    1ad8:	9f 90       	pop	r9
    1ada:	8f 90       	pop	r8
    1adc:	7f 90       	pop	r7
    1ade:	6f 90       	pop	r6
    1ae0:	08 95       	ret

00001ae2 <FPoolingPump>:
		  //stPoolingPump=pwInitPumpAddr;
	      break;
	 }
}

void FPoolingPump(){//DefPoolTimeout,DefDelayNextPump
    1ae2:	af 92       	push	r10
    1ae4:	cf 92       	push	r12
    1ae6:	df 92       	push	r13
    1ae8:	ef 92       	push	r14
    1aea:	ff 92       	push	r15
    1aec:	0f 93       	push	r16
    1aee:	1f 93       	push	r17
//static char txPumpID=0,StatusPump,iSend,nSend,PumpAddr=1,nNoPump,ScanPumpMax,IsNoPump=True,TPoolTimeout,TDelayNextPump;
       char CurrentAmount[15];
	   char strSend[20];

     //Monitoring
	 if (zPooling!=stPoolingPump){
    1af0:	60 91 2c 01 	lds	r22, 0x012C
    1af4:	80 91 2d 01 	lds	r24, 0x012D
    1af8:	86 17       	cp	r24, r22
    1afa:	11 f0       	breq	.+4      	; 0x1b00 <FPoolingPump+0x1e>
	     zPooling=stPoolingPump;
    1afc:	60 93 2d 01 	sts	0x012D, r22
         sprintf_P(strSend,PSTR("GPool:%d"),stPoolingPump);
	 	 _uart_print(1,1,strSend);
		 #endif
	 }
     
	 if (IsRestartPooling==True){
    1b00:	80 91 03 01 	lds	r24, 0x0103
    1b04:	81 30       	cpi	r24, 0x01	; 1
    1b06:	69 f4       	brne	.+26     	; 0x1b22 <FPoolingPump+0x40>
	     IsRestartPooling=False;
    1b08:	10 92 03 01 	sts	0x0103, r1
		 SendCommandAcknoledge(SC_POOL_RESTARTED,stPoolingPump);
    1b0c:	8a e1       	ldi	r24, 0x1A	; 26
    1b0e:	0e 94 e0 06 	call	0xdc0	; 0xdc0 <SendCommandAcknoledge>
		 _uart_printf(1,1,PSTR("PoolRestarted"));
    1b12:	81 e0       	ldi	r24, 0x01	; 1
    1b14:	61 e0       	ldi	r22, 0x01	; 1
    1b16:	4a e6       	ldi	r20, 0x6A	; 106
    1b18:	51 e0       	ldi	r21, 0x01	; 1
    1b1a:	0e 94 97 18 	call	0x312e	; 0x312e <_uart_printf>
	     stPoolingPump=ppInit;
    1b1e:	10 92 2c 01 	sts	0x012C, r1
	 }
	 switch(stPoolingPump){
    1b22:	80 91 2c 01 	lds	r24, 0x012C
    1b26:	e8 2f       	mov	r30, r24
    1b28:	f0 e0       	ldi	r31, 0x00	; 0
    1b2a:	e1 32       	cpi	r30, 0x21	; 33
    1b2c:	f1 05       	cpc	r31, r1
    1b2e:	08 f0       	brcs	.+2      	; 0x1b32 <FPoolingPump+0x50>
    1b30:	d4 c2       	rjmp	.+1448   	; 0x20da <FPoolingPump+0x5f8>
    1b32:	e8 5c       	subi	r30, 0xC8	; 200
    1b34:	ff 4f       	sbci	r31, 0xFF	; 255
    1b36:	ee 0f       	add	r30, r30
    1b38:	ff 1f       	adc	r31, r31
    1b3a:	05 90       	lpm	r0, Z+
    1b3c:	f4 91       	lpm	r31, Z+
    1b3e:	e0 2d       	mov	r30, r0
    1b40:	09 94       	ijmp
	 case ppInit:
	      //StatePrintf(PSTR("1"));
	      //txPumpID=1;
		  iPoolingID=0;
    1b42:	10 92 16 01 	sts	0x0116, r1
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    1b46:	e1 99       	sbic	0x1c, 1	; 28
    1b48:	fe cf       	rjmp	.-4      	; 0x1b46 <FPoolingPump+0x64>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    1b4a:	8d e0       	ldi	r24, 0x0D	; 13
    1b4c:	90 e0       	ldi	r25, 0x00	; 0
    1b4e:	9f bb       	out	0x1f, r25	; 31
    1b50:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    1b52:	e0 9a       	sbi	0x1c, 0	; 28
    1b54:	8d b3       	in	r24, 0x1d	; 29
		  txPumpID=eeprom_read_byte(&DefPumpID[iPoolingID]);
    1b56:	80 93 17 01 	sts	0x0117, r24

		  iSend=0;
    1b5a:	10 92 f9 03 	sts	0x03F9, r1
		  TimSend=0;          
    1b5e:	10 92 24 04 	sts	0x0424, r1
    1b62:	10 92 23 04 	sts	0x0423, r1
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    1b66:	e1 99       	sbic	0x1c, 1	; 28
    1b68:	fe cf       	rjmp	.-4      	; 0x1b66 <FPoolingPump+0x84>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    1b6a:	88 e0       	ldi	r24, 0x08	; 8
    1b6c:	90 e0       	ldi	r25, 0x00	; 0
    1b6e:	9f bb       	out	0x1f, r25	; 31
    1b70:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    1b72:	e0 9a       	sbi	0x1c, 0	; 28
    1b74:	8d b3       	in	r24, 0x1d	; 29
		  nNoPump=eeprom_read_byte(&DefNoPumpCountMax);
    1b76:	80 93 35 04 	sts	0x0435, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    1b7a:	e1 99       	sbic	0x1c, 1	; 28
    1b7c:	fe cf       	rjmp	.-4      	; 0x1b7a <FPoolingPump+0x98>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    1b7e:	87 e0       	ldi	r24, 0x07	; 7
    1b80:	90 e0       	ldi	r25, 0x00	; 0
    1b82:	9f bb       	out	0x1f, r25	; 31
    1b84:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    1b86:	e0 9a       	sbi	0x1c, 0	; 28
    1b88:	8d b3       	in	r24, 0x1d	; 29
		  ScanPumpMax=eeprom_read_byte(&DefMaxPumpPooling);
    1b8a:	80 93 61 02 	sts	0x0261, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    1b8e:	e1 99       	sbic	0x1c, 1	; 28
    1b90:	fe cf       	rjmp	.-4      	; 0x1b8e <FPoolingPump+0xac>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    1b92:	89 e0       	ldi	r24, 0x09	; 9
    1b94:	90 e0       	ldi	r25, 0x00	; 0
    1b96:	9f bb       	out	0x1f, r25	; 31
    1b98:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    1b9a:	e0 9a       	sbi	0x1c, 0	; 28
    1b9c:	8d b3       	in	r24, 0x1d	; 29
		  nSend=eeprom_read_byte(&DefSendCount);
    1b9e:	80 93 77 02 	sts	0x0277, r24
		  if (IsStopPoolSequence!=True)
    1ba2:	80 91 13 01 	lds	r24, 0x0113
    1ba6:	81 30       	cpi	r24, 0x01	; 1
    1ba8:	29 f0       	breq	.+10     	; 0x1bb4 <FPoolingPump+0xd2>
              SendCommandAcknoledge(SC_LIVE_SEQUENCE,SequencePool);
    1baa:	89 e1       	ldi	r24, 0x19	; 25
    1bac:	60 91 26 01 	lds	r22, 0x0126
    1bb0:	0e 94 e0 06 	call	0xdc0	; 0xdc0 <SendCommandAcknoledge>
          SequencePool++;
    1bb4:	80 91 26 01 	lds	r24, 0x0126
    1bb8:	8f 5f       	subi	r24, 0xFF	; 255
    1bba:	80 93 26 01 	sts	0x0126, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    1bbe:	e1 99       	sbic	0x1c, 1	; 28
    1bc0:	fe cf       	rjmp	.-4      	; 0x1bbe <FPoolingPump+0xdc>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    1bc2:	8a e0       	ldi	r24, 0x0A	; 10
    1bc4:	90 e0       	ldi	r25, 0x00	; 0
    1bc6:	9f bb       	out	0x1f, r25	; 31
    1bc8:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    1bca:	e0 9a       	sbi	0x1c, 0	; 28
    1bcc:	8d b3       	in	r24, 0x1d	; 29
		  TPoolTimeout=eeprom_read_byte(&DefPoolTimeout);
    1bce:	80 93 b6 02 	sts	0x02B6, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    1bd2:	e1 99       	sbic	0x1c, 1	; 28
    1bd4:	fe cf       	rjmp	.-4      	; 0x1bd2 <FPoolingPump+0xf0>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    1bd6:	8b e0       	ldi	r24, 0x0B	; 11
    1bd8:	90 e0       	ldi	r25, 0x00	; 0
    1bda:	9f bb       	out	0x1f, r25	; 31
    1bdc:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    1bde:	e0 9a       	sbi	0x1c, 0	; 28
    1be0:	8d b3       	in	r24, 0x1d	; 29
		  TDelayNextPump=eeprom_read_byte(&DefDelayNextPump);		  
    1be2:	80 93 3c 01 	sts	0x013C, r24
    1be6:	1e c0       	rjmp	.+60     	; 0x1c24 <FPoolingPump+0x142>
		  stPoolingPump=ppGetStatus;
	      break;
     case ppNextPump:
          iPoolingID++;
    1be8:	90 91 16 01 	lds	r25, 0x0116
    1bec:	9f 5f       	subi	r25, 0xFF	; 255
    1bee:	90 93 16 01 	sts	0x0116, r25
	      if (iPoolingID<ScanPumpMax){
    1bf2:	80 91 61 02 	lds	r24, 0x0261
    1bf6:	98 17       	cp	r25, r24
    1bf8:	b8 f4       	brcc	.+46     	; 0x1c28 <FPoolingPump+0x146>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    1bfa:	e1 99       	sbic	0x1c, 1	; 28
    1bfc:	fe cf       	rjmp	.-4      	; 0x1bfa <FPoolingPump+0x118>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    1bfe:	89 2f       	mov	r24, r25
    1c00:	90 e0       	ldi	r25, 0x00	; 0
    1c02:	83 5f       	subi	r24, 0xF3	; 243
    1c04:	9f 4f       	sbci	r25, 0xFF	; 255
    1c06:	9f bb       	out	0x1f, r25	; 31
    1c08:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    1c0a:	e0 9a       	sbi	0x1c, 0	; 28
    1c0c:	8d b3       	in	r24, 0x1d	; 29
			  txPumpID=eeprom_read_byte(&DefPumpID[iPoolingID]);
    1c0e:	80 93 17 01 	sts	0x0117, r24
			  if (txPumpID>0){			      
    1c12:	88 23       	and	r24, r24
    1c14:	09 f4       	brne	.+2      	; 0x1c18 <FPoolingPump+0x136>
    1c16:	09 c2       	rjmp	.+1042   	; 0x202a <FPoolingPump+0x548>
			      iSend=0;TimSend=0;
    1c18:	10 92 f9 03 	sts	0x03F9, r1
    1c1c:	10 92 24 04 	sts	0x0424, r1
    1c20:	10 92 23 04 	sts	0x0423, r1
			      stPoolingPump=ppGetStatus;
    1c24:	82 e0       	ldi	r24, 0x02	; 2
    1c26:	57 c2       	rjmp	.+1198   	; 0x20d6 <FPoolingPump+0x5f4>
			   }else stPoolingPump=ppNextPump;
		  }else stPoolingPump=ppInit;
    1c28:	10 92 2c 01 	sts	0x012C, r1
    1c2c:	56 c2       	rjmp	.+1196   	; 0x20da <FPoolingPump+0x5f8>
           sprintf_P(strSend,PSTR("TxPumpID:%d"),txPumpID);
	 	   _uart_print(1,1,strSend);
		  #endif

          //StatePrintf(PSTR("3"));
	      IsStatusReceived=False;
    1c2e:	10 92 0f 01 	sts	0x010F, r1
		  IsNoPump=False;
    1c32:	10 92 06 01 	sts	0x0106, r1
	 }
	 zDataBuffer[0]=data;
}

void SetReceiveLine(char RecLine){
     stReceiveCom0=RecLine;
    1c36:	81 e0       	ldi	r24, 0x01	; 1
    1c38:	80 93 04 01 	sts	0x0104, r24
		  IsNoPump=False;
		  SetReceiveLine(rcIdle);
		  stPoolingPump=ppWaitIdle;
     case ppWaitIdle:
          //StatePrintf(PSTR("4"));
	      if (GetReceiveLine()==rcIdle)
    1c3c:	80 91 04 01 	lds	r24, 0x0104
    1c40:	81 30       	cpi	r24, 0x01	; 1
    1c42:	81 f7       	brne	.-32     	; 0x1c24 <FPoolingPump+0x142>
		      stPoolingPump=ppSendStatusRequest;
    1c44:	84 e0       	ldi	r24, 0x04	; 4
    1c46:	47 c2       	rjmp	.+1166   	; 0x20d6 <FPoolingPump+0x5f4>
          else stPoolingPump=ppGetStatus;
	      break;
     case ppSendStatusRequest:
          //StatePrintf(PSTR("5"));
	      PumpCommand(txPumpID,CMD_STATUS);
    1c48:	80 91 17 01 	lds	r24, 0x0117
    1c4c:	60 e0       	ldi	r22, 0x00	; 0
    1c4e:	0e 94 69 07 	call	0xed2	; 0xed2 <PumpCommand>
		  TimSend=0;
    1c52:	10 92 24 04 	sts	0x0424, r1
    1c56:	10 92 23 04 	sts	0x0423, r1
          stPoolingPump=ppWaitReplyStatus;
    1c5a:	86 e0       	ldi	r24, 0x06	; 6
    1c5c:	3c c2       	rjmp	.+1144   	; 0x20d6 <FPoolingPump+0x5f4>
	      break;
     case ppNoPump:
          NoPumpCount[txPumpID&0x0F]++;
    1c5e:	80 91 17 01 	lds	r24, 0x0117
    1c62:	e8 2f       	mov	r30, r24
    1c64:	f0 e0       	ldi	r31, 0x00	; 0
    1c66:	ef 70       	andi	r30, 0x0F	; 15
    1c68:	f0 70       	andi	r31, 0x00	; 0
    1c6a:	eb 5d       	subi	r30, 0xDB	; 219
    1c6c:	fb 4f       	sbci	r31, 0xFB	; 251
    1c6e:	80 81       	ld	r24, Z
    1c70:	8f 5f       	subi	r24, 0xFF	; 255
    1c72:	80 83       	st	Z, r24
		  if (NoPumpCount[txPumpID&0x0F]>nNoPump){
    1c74:	90 91 35 04 	lds	r25, 0x0435
    1c78:	98 17       	cp	r25, r24
    1c7a:	08 f0       	brcs	.+2      	; 0x1c7e <FPoolingPump+0x19c>
    1c7c:	c5 c0       	rjmp	.+394    	; 0x1e08 <FPoolingPump+0x326>
		      NoPumpCount[txPumpID&0x0F]=0;
    1c7e:	10 82       	st	Z, r1
	          IsNoPump=True;
    1c80:	81 e0       	ldi	r24, 0x01	; 1
    1c82:	80 93 06 01 	sts	0x0106, r24
    1c86:	07 c1       	rjmp	.+526    	; 0x1e96 <FPoolingPump+0x3b4>
			  }
          else stPoolingPump=ppInitDelayNextPump;
	      break;
     case ppWaitReplyStatus:	      
          //StatePrintf(PSTR("7"));
          if (TimSend>TPoolTimeout){//TPoolTimeout
    1c88:	80 91 b6 02 	lds	r24, 0x02B6
    1c8c:	90 e0       	ldi	r25, 0x00	; 0
    1c8e:	20 91 23 04 	lds	r18, 0x0423
    1c92:	30 91 24 04 	lds	r19, 0x0424
    1c96:	82 17       	cp	r24, r18
    1c98:	93 07       	cpc	r25, r19
    1c9a:	80 f4       	brcc	.+32     	; 0x1cbc <FPoolingPump+0x1da>
		      iSend++;
    1c9c:	80 91 f9 03 	lds	r24, 0x03F9
    1ca0:	8f 5f       	subi	r24, 0xFF	; 255
    1ca2:	80 93 f9 03 	sts	0x03F9, r24
		      if (iSend<nSend)stPoolingPump=ppGetStatus;
    1ca6:	90 91 77 02 	lds	r25, 0x0277
    1caa:	89 17       	cp	r24, r25
    1cac:	10 f4       	brcc	.+4      	; 0x1cb2 <FPoolingPump+0x1d0>
    1cae:	82 e0       	ldi	r24, 0x02	; 2
    1cb0:	03 c0       	rjmp	.+6      	; 0x1cb8 <FPoolingPump+0x1d6>
			  else
		      if (iSend>nSend)stPoolingPump=ppNoPump;//Pump Not Available
    1cb2:	98 17       	cp	r25, r24
    1cb4:	18 f4       	brcc	.+6      	; 0x1cbc <FPoolingPump+0x1da>
    1cb6:	85 e0       	ldi	r24, 0x05	; 5
    1cb8:	80 93 2c 01 	sts	0x012C, r24
		  }
          if (IsStatusReceived==True){
    1cbc:	80 91 0f 01 	lds	r24, 0x010F
    1cc0:	81 30       	cpi	r24, 0x01	; 1
    1cc2:	09 f0       	breq	.+2      	; 0x1cc6 <FPoolingPump+0x1e4>
    1cc4:	0a c2       	rjmp	.+1044   	; 0x20da <FPoolingPump+0x5f8>
		      if ((txPumpID&0x0F)==PumpID){
    1cc6:	40 91 0e 01 	lds	r20, 0x010E
    1cca:	80 91 17 01 	lds	r24, 0x0117
    1cce:	90 e0       	ldi	r25, 0x00	; 0
    1cd0:	8f 70       	andi	r24, 0x0F	; 15
    1cd2:	90 70       	andi	r25, 0x00	; 0
    1cd4:	24 2f       	mov	r18, r20
    1cd6:	30 e0       	ldi	r19, 0x00	; 0
    1cd8:	82 17       	cp	r24, r18
    1cda:	93 07       	cpc	r25, r19
    1cdc:	11 f4       	brne	.+4      	; 0x1ce2 <FPoolingPump+0x200>
			      stPoolingPump=ppUpdatePumpStatus;
    1cde:	87 e0       	ldi	r24, 0x07	; 7
    1ce0:	01 c0       	rjmp	.+2      	; 0x1ce4 <FPoolingPump+0x202>
			  }else stPoolingPump=ppDifferentPumpID;
    1ce2:	89 e0       	ldi	r24, 0x09	; 9
    1ce4:	80 93 2c 01 	sts	0x012C, r24

			  if ((CMDResponse==0x0F)&&(PumpID==0x0F)&&(iSend<nSend)){
    1ce8:	80 91 8d 01 	lds	r24, 0x018D
    1cec:	8f 30       	cpi	r24, 0x0F	; 15
    1cee:	09 f0       	breq	.+2      	; 0x1cf2 <FPoolingPump+0x210>
    1cf0:	f4 c1       	rjmp	.+1000   	; 0x20da <FPoolingPump+0x5f8>
    1cf2:	4f 30       	cpi	r20, 0x0F	; 15
    1cf4:	09 f0       	breq	.+2      	; 0x1cf8 <FPoolingPump+0x216>
    1cf6:	f1 c1       	rjmp	.+994    	; 0x20da <FPoolingPump+0x5f8>
    1cf8:	90 91 f9 03 	lds	r25, 0x03F9
    1cfc:	80 91 77 02 	lds	r24, 0x0277
    1d00:	98 17       	cp	r25, r24
    1d02:	08 f0       	brcs	.+2      	; 0x1d06 <FPoolingPump+0x224>
    1d04:	ea c1       	rjmp	.+980    	; 0x20da <FPoolingPump+0x5f8>
    1d06:	8e cf       	rjmp	.-228    	; 0x1c24 <FPoolingPump+0x142>
          stPoolingPump=ppNoPump;
	      break;
		                     //PumpStatus[1..0]= FEDCBA98 76543210
     case ppUpdatePumpStatus://                = 
          //StatePrintf(PSTR("9"));
	      PumpAddr=(txPumpID&0x0F);
    1d08:	90 91 17 01 	lds	r25, 0x0117
    1d0c:	9f 70       	andi	r25, 0x0F	; 15
    1d0e:	90 93 05 01 	sts	0x0105, r25
		  if (IsNoPump==False)PumpStatus[PumpAddr]=CMDResponse;
    1d12:	80 91 06 01 	lds	r24, 0x0106
    1d16:	88 23       	and	r24, r24
    1d18:	39 f4       	brne	.+14     	; 0x1d28 <FPoolingPump+0x246>
    1d1a:	e9 2f       	mov	r30, r25
    1d1c:	f0 e0       	ldi	r31, 0x00	; 0
    1d1e:	eb 54       	subi	r30, 0x4B	; 75
    1d20:	fc 4f       	sbci	r31, 0xFC	; 252
    1d22:	80 91 8d 01 	lds	r24, 0x018D
    1d26:	07 c0       	rjmp	.+14     	; 0x1d36 <FPoolingPump+0x254>
		  else 
		  if (IsNoPump==True)PumpStatus[PumpAddr]=PUMP_NONE;
    1d28:	81 30       	cpi	r24, 0x01	; 1
    1d2a:	31 f4       	brne	.+12     	; 0x1d38 <FPoolingPump+0x256>
    1d2c:	e9 2f       	mov	r30, r25
    1d2e:	f0 e0       	ldi	r31, 0x00	; 0
    1d30:	eb 54       	subi	r30, 0x4B	; 75
    1d32:	fc 4f       	sbci	r31, 0xFC	; 252
    1d34:	8e e0       	ldi	r24, 0x0E	; 14
    1d36:	80 83       	st	Z, r24
          
		  //SendIfUpdated
		  if (PumpStatus[PumpAddr]!=zPumpStatus[PumpAddr]){
    1d38:	89 2f       	mov	r24, r25
    1d3a:	90 e0       	ldi	r25, 0x00	; 0
    1d3c:	fc 01       	movw	r30, r24
    1d3e:	eb 54       	subi	r30, 0x4B	; 75
    1d40:	fc 4f       	sbci	r31, 0xFC	; 252
    1d42:	20 81       	ld	r18, Z
    1d44:	fc 01       	movw	r30, r24
    1d46:	e5 56       	subi	r30, 0x65	; 101
    1d48:	fd 4f       	sbci	r31, 0xFD	; 253
    1d4a:	80 81       	ld	r24, Z
    1d4c:	28 17       	cp	r18, r24
    1d4e:	79 f0       	breq	.+30     	; 0x1d6e <FPoolingPump+0x28c>
		      zPumpStatus[PumpAddr]=PumpStatus[PumpAddr];
    1d50:	20 83       	st	Z, r18
		      stPoolingPump=ppSendPumpStatus;
    1d52:	87 e1       	ldi	r24, 0x17	; 23
    1d54:	c0 c1       	rjmp	.+896    	; 0x20d6 <FPoolingPump+0x5f4>
		  }else stPoolingPump=ppScanResponse;
          break;
     case ppSendPumpStatus://UpdatePumpStatusToMaster;
          //StatePrintf(PSTR("10"));
	      PumpAddr=(txPumpID&0x0F);
    1d56:	80 91 17 01 	lds	r24, 0x0117
    1d5a:	e8 2f       	mov	r30, r24
    1d5c:	ef 70       	andi	r30, 0x0F	; 15
    1d5e:	e0 93 05 01 	sts	0x0105, r30
	      SendPumpStatusFlow(txPumpID,PumpStatus[PumpAddr]);
    1d62:	f0 e0       	ldi	r31, 0x00	; 0
    1d64:	eb 54       	subi	r30, 0x4B	; 75
    1d66:	fc 4f       	sbci	r31, 0xFC	; 252
    1d68:	60 81       	ld	r22, Z
    1d6a:	0e 94 c8 06 	call	0xd90	; 0xd90 <SendPumpStatusFlow>
	      stPoolingPump=ppScanResponse;
    1d6e:	88 e1       	ldi	r24, 0x18	; 24
    1d70:	b2 c1       	rjmp	.+868    	; 0x20d6 <FPoolingPump+0x5f4>
	      break;
     case ppScanResponse:
          //StatePrintf(PSTR("11"));
		  PumpAddr=(txPumpID&0x0F);
    1d72:	80 91 17 01 	lds	r24, 0x0117
    1d76:	8f 70       	andi	r24, 0x0F	; 15
    1d78:	80 93 05 01 	sts	0x0105, r24
		  switch(CMDResponse){
    1d7c:	90 91 8d 01 	lds	r25, 0x018D
    1d80:	98 30       	cpi	r25, 0x08	; 8
    1d82:	c1 f1       	breq	.+112    	; 0x1df4 <FPoolingPump+0x312>
    1d84:	99 30       	cpi	r25, 0x09	; 9
    1d86:	28 f4       	brcc	.+10     	; 0x1d92 <FPoolingPump+0x2b0>
    1d88:	96 30       	cpi	r25, 0x06	; 6
    1d8a:	41 f0       	breq	.+16     	; 0x1d9c <FPoolingPump+0x2ba>
    1d8c:	97 30       	cpi	r25, 0x07	; 7
    1d8e:	91 f5       	brne	.+100    	; 0x1df4 <FPoolingPump+0x312>
    1d90:	16 c0       	rjmp	.+44     	; 0x1dbe <FPoolingPump+0x2dc>
    1d92:	99 30       	cpi	r25, 0x09	; 9
    1d94:	31 f1       	breq	.+76     	; 0x1de2 <FPoolingPump+0x300>
    1d96:	9b 30       	cpi	r25, 0x0B	; 11
    1d98:	69 f5       	brne	.+90     	; 0x1df4 <FPoolingPump+0x312>
    1d9a:	1a c0       	rjmp	.+52     	; 0x1dd0 <FPoolingPump+0x2ee>
		  case PUMP_OFF:               
		       if (IsRequestTransInfo[PumpAddr]==True)
    1d9c:	a8 2f       	mov	r26, r24
    1d9e:	b0 e0       	ldi	r27, 0x00	; 0
    1da0:	fd 01       	movw	r30, r26
    1da2:	e6 57       	subi	r30, 0x76	; 118
    1da4:	fd 4f       	sbci	r31, 0xFD	; 253
    1da6:	80 81       	ld	r24, Z
    1da8:	81 30       	cpi	r24, 0x01	; 1
    1daa:	c9 f0       	breq	.+50     	; 0x1dde <FPoolingPump+0x2fc>
			       stPoolingPump=ppRequestTransData;
               else 
		       if (IsRequestTotalizerInfo[PumpAddr]==True){
    1dac:	ad 5e       	subi	r26, 0xED	; 237
    1dae:	bb 4f       	sbci	r27, 0xFB	; 251
    1db0:	8c 91       	ld	r24, X
    1db2:	81 30       	cpi	r24, 0x01	; 1
    1db4:	11 f4       	brne	.+4      	; 0x1dba <FPoolingPump+0x2d8>
			        stPoolingPump=ppRequestTotalizerData;
    1db6:	8b e1       	ldi	r24, 0x1B	; 27
    1db8:	1e c0       	rjmp	.+60     	; 0x1df6 <FPoolingPump+0x314>
				}	
               else stPoolingPump=ppNextPump;
    1dba:	81 e0       	ldi	r24, 0x01	; 1
    1dbc:	1c c0       	rjmp	.+56     	; 0x1df6 <FPoolingPump+0x314>
		       break;
          case PUMP_CALL:
 			   if (PumpLock[PumpAddr]==False){
    1dbe:	e8 2f       	mov	r30, r24
    1dc0:	f0 e0       	ldi	r31, 0x00	; 0
    1dc2:	e4 53       	subi	r30, 0x34	; 52
    1dc4:	fd 4f       	sbci	r31, 0xFD	; 253
    1dc6:	80 81       	ld	r24, Z
    1dc8:	88 23       	and	r24, r24
    1dca:	b9 f4       	brne	.+46     	; 0x1dfa <FPoolingPump+0x318>
			   	 //  if (IsRequestTransInfo[PumpAddr]==False) 
				 //      IsRequestTransInfo[PumpAddr]=True;
			       stPoolingPump=ppReplyAuth;               
    1dcc:	88 e0       	ldi	r24, 0x08	; 8
    1dce:	13 c0       	rjmp	.+38     	; 0x1df6 <FPoolingPump+0x314>
			   } 
		       break;
		  case PUMP_FEOT:
		       if (IsRequestTransInfo[PumpAddr]==True)
    1dd0:	e8 2f       	mov	r30, r24
    1dd2:	f0 e0       	ldi	r31, 0x00	; 0
    1dd4:	e6 57       	subi	r30, 0x76	; 118
    1dd6:	fd 4f       	sbci	r31, 0xFD	; 253
    1dd8:	80 81       	ld	r24, Z
    1dda:	81 30       	cpi	r24, 0x01	; 1
    1ddc:	59 f4       	brne	.+22     	; 0x1df4 <FPoolingPump+0x312>
			       stPoolingPump=ppRequestTransData;
    1dde:	8a e0       	ldi	r24, 0x0A	; 10
    1de0:	0a c0       	rjmp	.+20     	; 0x1df6 <FPoolingPump+0x314>
               else stPoolingPump=ppInitDelayNextPump;
		       break;
		  case PUMP_BUSY:
               if (IsRequestTransInfo[PumpAddr]==False)
    1de2:	e8 2f       	mov	r30, r24
    1de4:	f0 e0       	ldi	r31, 0x00	; 0
    1de6:	e6 57       	subi	r30, 0x76	; 118
    1de8:	fd 4f       	sbci	r31, 0xFD	; 253
    1dea:	80 81       	ld	r24, Z
    1dec:	88 23       	and	r24, r24
    1dee:	11 f4       	brne	.+4      	; 0x1df4 <FPoolingPump+0x312>
			       IsRequestTransInfo[PumpAddr]=True;
    1df0:	81 e0       	ldi	r24, 0x01	; 1
    1df2:	80 83       	st	Z, r24
		       break;
		  case PUMP_AUTH:
               stPoolingPump=ppInitDelayNextPump;
		       break;		  
          default:
               stPoolingPump=ppInitDelayNextPump;
    1df4:	84 e1       	ldi	r24, 0x14	; 20
    1df6:	80 93 2c 01 	sts	0x012C, r24
		       break;
		  }
		  //Existing Pump
		  if (IsNoPump==True){
    1dfa:	80 91 06 01 	lds	r24, 0x0106
    1dfe:	81 30       	cpi	r24, 0x01	; 1
    1e00:	09 f0       	breq	.+2      	; 0x1e04 <FPoolingPump+0x322>
    1e02:	6b c1       	rjmp	.+726    	; 0x20da <FPoolingPump+0x5f8>
		      IsNoPump=False;
    1e04:	10 92 06 01 	sts	0x0106, r1
			  stPoolingPump=ppInitDelayNextPump;
    1e08:	84 e1       	ldi	r24, 0x14	; 20
    1e0a:	65 c1       	rjmp	.+714    	; 0x20d6 <FPoolingPump+0x5f4>
	 }
	 zDataBuffer[0]=data;
}

void SetReceiveLine(char RecLine){
     stReceiveCom0=RecLine;
    1e0c:	81 e0       	ldi	r24, 0x01	; 1
    1e0e:	80 93 04 01 	sts	0x0104, r24
	      break;
     case ppReplyAuth:
          //StatePrintf(PSTR("11"));
	      SetReceiveLine(rcIdle);
	      if (GetReceiveLine()==rcIdle){
			  iSend=0;
    1e12:	10 92 f9 03 	sts	0x03F9, r1
		      stPoolingPump=ppSendAuthorize;
    1e16:	8c e0       	ldi	r24, 0x0C	; 12
    1e18:	5e c1       	rjmp	.+700    	; 0x20d6 <FPoolingPump+0x5f4>
			  }
		  else stPoolingPump=ppReplyAuth;
	      break;
     case ppSendAuthorize:
          //StatePrintf(PSTR("12"));
	      TimSend=0;
    1e1a:	10 92 24 04 	sts	0x0424, r1
    1e1e:	10 92 23 04 	sts	0x0423, r1
		  IsStatusReceived=False;
    1e22:	10 92 0f 01 	sts	0x010F, r1
	      PumpCommand(txPumpID,CMD_AUTHORIZE);
    1e26:	80 91 17 01 	lds	r24, 0x0117
    1e2a:	61 e0       	ldi	r22, 0x01	; 1
    1e2c:	0e 94 69 07 	call	0xed2	; 0xed2 <PumpCommand>
		  stPoolingPump=ppWaitAuthorized;
    1e30:	8d e0       	ldi	r24, 0x0D	; 13
    1e32:	51 c1       	rjmp	.+674    	; 0x20d6 <FPoolingPump+0x5f4>
	      break;
     case ppWaitAuthorized:
          //StatePrintf(PSTR("13"));
	      if (TimSend>TPoolTimeout){
    1e34:	80 91 b6 02 	lds	r24, 0x02B6
    1e38:	90 e0       	ldi	r25, 0x00	; 0
    1e3a:	20 91 23 04 	lds	r18, 0x0423
    1e3e:	30 91 24 04 	lds	r19, 0x0424
    1e42:	82 17       	cp	r24, r18
    1e44:	93 07       	cpc	r25, r19
    1e46:	80 f4       	brcc	.+32     	; 0x1e68 <FPoolingPump+0x386>
		  	  iSend++;
    1e48:	80 91 f9 03 	lds	r24, 0x03F9
    1e4c:	8f 5f       	subi	r24, 0xFF	; 255
    1e4e:	80 93 f9 03 	sts	0x03F9, r24
		      if (iSend<nSend)stPoolingPump=ppSendAuthorize;
    1e52:	90 91 77 02 	lds	r25, 0x0277
    1e56:	89 17       	cp	r24, r25
    1e58:	10 f4       	brcc	.+4      	; 0x1e5e <FPoolingPump+0x37c>
    1e5a:	8c e0       	ldi	r24, 0x0C	; 12
    1e5c:	03 c0       	rjmp	.+6      	; 0x1e64 <FPoolingPump+0x382>
			  else
		      if (iSend>nSend)stPoolingPump=ppNoPump;//Pump Not Available
    1e5e:	98 17       	cp	r25, r24
    1e60:	18 f4       	brcc	.+6      	; 0x1e68 <FPoolingPump+0x386>
    1e62:	85 e0       	ldi	r24, 0x05	; 5
    1e64:	80 93 2c 01 	sts	0x012C, r24
		  }
	      if (IsStatusReceived==True){
    1e68:	80 91 0f 01 	lds	r24, 0x010F
    1e6c:	81 30       	cpi	r24, 0x01	; 1
    1e6e:	09 f0       	breq	.+2      	; 0x1e72 <FPoolingPump+0x390>
    1e70:	34 c1       	rjmp	.+616    	; 0x20da <FPoolingPump+0x5f8>
		      IsStatusReceived=False;
    1e72:	10 92 0f 01 	sts	0x010F, r1
			  //Authorized
			  _uart_printf(1,1,PSTR("Authorized"));
    1e76:	61 e0       	ldi	r22, 0x01	; 1
    1e78:	4f e5       	ldi	r20, 0x5F	; 95
    1e7a:	51 e0       	ldi	r21, 0x01	; 1
    1e7c:	0e 94 97 18 	call	0x312e	; 0x312e <_uart_printf>

		      if ((txPumpID&0x0F)==PumpID)stPoolingPump=ppUpdatePumpStatus;
    1e80:	20 91 17 01 	lds	r18, 0x0117
    1e84:	30 e0       	ldi	r19, 0x00	; 0
    1e86:	2f 70       	andi	r18, 0x0F	; 15
    1e88:	30 70       	andi	r19, 0x00	; 0
    1e8a:	80 91 0e 01 	lds	r24, 0x010E
    1e8e:	90 e0       	ldi	r25, 0x00	; 0
    1e90:	28 17       	cp	r18, r24
    1e92:	39 07       	cpc	r19, r25
    1e94:	11 f4       	brne	.+4      	; 0x1e9a <FPoolingPump+0x3b8>
    1e96:	87 e0       	ldi	r24, 0x07	; 7
    1e98:	1e c1       	rjmp	.+572    	; 0x20d6 <FPoolingPump+0x5f4>
			  else stPoolingPump=ppDifferentPumpID;
    1e9a:	89 e0       	ldi	r24, 0x09	; 9
    1e9c:	1c c1       	rjmp	.+568    	; 0x20d6 <FPoolingPump+0x5f4>
		  }
	      break;
     case ppRequestRealTimeMoney:
          //StatePrintf(PSTR("14"));
		  Com0ReceiveCount=0;
    1e9e:	10 92 23 01 	sts	0x0123, r1
	 }
	 zDataBuffer[0]=data;
}

void SetReceiveLine(char RecLine){
     stReceiveCom0=RecLine;
    1ea2:	82 e0       	ldi	r24, 0x02	; 2
    1ea4:	80 93 04 01 	sts	0x0104, r24
     case ppRequestRealTimeMoney:
          //StatePrintf(PSTR("14"));
		  Com0ReceiveCount=0;
	      SetReceiveLine(rcRealTimeMoney);
	      if (GetReceiveLine()==rcRealTimeMoney){
			  iSend=0;
    1ea8:	10 92 f9 03 	sts	0x03F9, r1
    1eac:	25 c0       	rjmp	.+74     	; 0x1ef8 <FPoolingPump+0x416>
			  }
		  else stPoolingPump=ppRequestRealTimeMoney;
	      break;
     case ppSendMoneyReq:
          //StatePrintf(PSTR("15"));
	 	  TimSend=0;
    1eae:	10 92 24 04 	sts	0x0424, r1
    1eb2:	10 92 23 04 	sts	0x0423, r1
	      IsMoneyReceived=False;
    1eb6:	10 92 10 01 	sts	0x0110, r1
	      PumpCommand(txPumpID,CMD_REALTIME_MONEY);
    1eba:	80 91 17 01 	lds	r24, 0x0117
    1ebe:	66 e0       	ldi	r22, 0x06	; 6
    1ec0:	0e 94 69 07 	call	0xed2	; 0xed2 <PumpCommand>
		  stPoolingPump=ppWaitMoneyReq;
    1ec4:	8f e0       	ldi	r24, 0x0F	; 15
    1ec6:	07 c1       	rjmp	.+526    	; 0x20d6 <FPoolingPump+0x5f4>
	      break;
     case ppWaitMoneyReq:
          //StatePrintf(PSTR("16"));
	      if (IsMoneyReceived==False){
    1ec8:	80 91 10 01 	lds	r24, 0x0110
    1ecc:	88 23       	and	r24, r24
    1ece:	d9 f4       	brne	.+54     	; 0x1f06 <FPoolingPump+0x424>
		  	  if (TimSend>TPoolTimeout){
    1ed0:	80 91 b6 02 	lds	r24, 0x02B6
    1ed4:	90 e0       	ldi	r25, 0x00	; 0
    1ed6:	20 91 23 04 	lds	r18, 0x0423
    1eda:	30 91 24 04 	lds	r19, 0x0424
    1ede:	82 17       	cp	r24, r18
    1ee0:	93 07       	cpc	r25, r19
    1ee2:	08 f0       	brcs	.+2      	; 0x1ee6 <FPoolingPump+0x404>
    1ee4:	fa c0       	rjmp	.+500    	; 0x20da <FPoolingPump+0x5f8>
			      iSend++;
    1ee6:	80 91 f9 03 	lds	r24, 0x03F9
    1eea:	8f 5f       	subi	r24, 0xFF	; 255
    1eec:	80 93 f9 03 	sts	0x03F9, r24
		          if (iSend<nSend)stPoolingPump=ppSendMoneyReq;
    1ef0:	90 91 77 02 	lds	r25, 0x0277
    1ef4:	89 17       	cp	r24, r25
    1ef6:	10 f4       	brcc	.+4      	; 0x1efc <FPoolingPump+0x41a>
    1ef8:	8e e0       	ldi	r24, 0x0E	; 14
    1efa:	ed c0       	rjmp	.+474    	; 0x20d6 <FPoolingPump+0x5f4>
			      else
		          if (iSend>nSend)stPoolingPump=ppNoPump;//Pump Not Available
    1efc:	98 17       	cp	r25, r24
    1efe:	08 f0       	brcs	.+2      	; 0x1f02 <FPoolingPump+0x420>
    1f00:	ec c0       	rjmp	.+472    	; 0x20da <FPoolingPump+0x5f8>
    1f02:	85 e0       	ldi	r24, 0x05	; 5
    1f04:	e8 c0       	rjmp	.+464    	; 0x20d6 <FPoolingPump+0x5f4>
			  }
		  }else
	      if (IsMoneyReceived==True){
    1f06:	81 30       	cpi	r24, 0x01	; 1
    1f08:	09 f0       	breq	.+2      	; 0x1f0c <FPoolingPump+0x42a>
    1f0a:	e7 c0       	rjmp	.+462    	; 0x20da <FPoolingPump+0x5f8>
		      IsMoneyReceived=False;
    1f0c:	10 92 10 01 	sts	0x0110, r1
			  PumpAddr=(txPumpID&0x0F);
    1f10:	80 91 17 01 	lds	r24, 0x0117
    1f14:	8f 70       	andi	r24, 0x0F	; 15
    1f16:	80 93 05 01 	sts	0x0105, r24
			  //SendCurrentMoney(txPumpID,strCurrentMoney);
			  stPoolingPump=ppMoneyRequestCompleted;
    1f1a:	80 e1       	ldi	r24, 0x10	; 16
    1f1c:	dc c0       	rjmp	.+440    	; 0x20d6 <FPoolingPump+0x5f4>
	      TimDelayNextPump=0;
		  stPoolingPump=ppDelayNextPump;
	      break;
     case ppDelayNextPump:
          //StatePrintf(PSTR("18"));
	      if (TimDelayNextPump>=TDelayNextPump)
    1f1e:	80 91 3c 01 	lds	r24, 0x013C
    1f22:	90 e0       	ldi	r25, 0x00	; 0
    1f24:	20 91 21 01 	lds	r18, 0x0121
    1f28:	30 91 22 01 	lds	r19, 0x0122
    1f2c:	28 17       	cp	r18, r24
    1f2e:	39 07       	cpc	r19, r25
    1f30:	08 f4       	brcc	.+2      	; 0x1f34 <FPoolingPump+0x452>
    1f32:	d3 c0       	rjmp	.+422    	; 0x20da <FPoolingPump+0x5f8>
    1f34:	7a c0       	rjmp	.+244    	; 0x202a <FPoolingPump+0x548>
		      stPoolingPump=ppNextPump;	      
	      break;
     case ppIsRequestTransInfo:
          PumpAddr=(txPumpID&0x0F);
    1f36:	e0 91 17 01 	lds	r30, 0x0117
    1f3a:	ef 70       	andi	r30, 0x0F	; 15
    1f3c:	e0 93 05 01 	sts	0x0105, r30
	      if (IsRequestTransInfo[PumpAddr]!=False){
    1f40:	f0 e0       	ldi	r31, 0x00	; 0
    1f42:	e6 57       	subi	r30, 0x76	; 118
    1f44:	fd 4f       	sbci	r31, 0xFD	; 253
    1f46:	80 81       	ld	r24, Z
    1f48:	88 23       	and	r24, r24
    1f4a:	11 f0       	breq	.+4      	; 0x1f50 <FPoolingPump+0x46e>
		      stPoolingPump=ppRequestTransData;		  
    1f4c:	8a e0       	ldi	r24, 0x0A	; 10
    1f4e:	c3 c0       	rjmp	.+390    	; 0x20d6 <FPoolingPump+0x5f4>
		  }else{
		  stPoolingPump=ppIsRequestTotalizerInfo;
    1f50:	8a e1       	ldi	r24, 0x1A	; 26
    1f52:	c1 c0       	rjmp	.+386    	; 0x20d6 <FPoolingPump+0x5f4>
	 }
	 zDataBuffer[0]=data;
}

void SetReceiveLine(char RecLine){
     stReceiveCom0=RecLine;
    1f54:	83 e0       	ldi	r24, 0x03	; 3
    1f56:	80 93 04 01 	sts	0x0104, r24
	      break;
     case ppRequestTransData:
          //StatePrintf(PSTR("19"));
	      SetReceiveLine(rcInitTransaction);
	      if (GetReceiveLine()==rcInitTransaction){
			  iSend=0;
    1f5a:	10 92 f9 03 	sts	0x03F9, r1
    1f5e:	30 c0       	rjmp	.+96     	; 0x1fc0 <FPoolingPump+0x4de>
			  }
		  else stPoolingPump=ppRequestTransData;
	      break;
     case ppSendTransReq:
          //StatePrintf(PSTR("20"));
	 	  TimSend=0;
    1f60:	10 92 24 04 	sts	0x0424, r1
    1f64:	10 92 23 04 	sts	0x0423, r1
	      IsTransaction=False;
    1f68:	10 92 11 01 	sts	0x0111, r1
	      PumpCommand(txPumpID,CMD_TRANSACTION_DATA);		  
    1f6c:	80 91 17 01 	lds	r24, 0x0117
    1f70:	64 e0       	ldi	r22, 0x04	; 4
    1f72:	0e 94 69 07 	call	0xed2	; 0xed2 <PumpCommand>
		  stPoolingPump=ppWaitTransReq;
    1f76:	82 e1       	ldi	r24, 0x12	; 18
    1f78:	ae c0       	rjmp	.+348    	; 0x20d6 <FPoolingPump+0x5f4>
	      break;
	 case ppWaitTransReq:
          //StatePrintf(PSTR("21"));
		  if (IsTransaction==True){
    1f7a:	80 91 11 01 	lds	r24, 0x0111
    1f7e:	81 30       	cpi	r24, 0x01	; 1
    1f80:	41 f4       	brne	.+16     	; 0x1f92 <FPoolingPump+0x4b0>
		      PumpAddr=(txPumpID&0x0F);
    1f82:	80 91 17 01 	lds	r24, 0x0117
    1f86:	8f 70       	andi	r24, 0x0F	; 15
    1f88:	80 93 05 01 	sts	0x0105, r24
		      stPoolingPump=ppTransRequestCompleted;
    1f8c:	83 e1       	ldi	r24, 0x13	; 19
    1f8e:	80 93 2c 01 	sts	0x012C, r24
			  }
		  if (TimSend>(TPoolTimeout*2)){
    1f92:	80 91 b6 02 	lds	r24, 0x02B6
    1f96:	90 e0       	ldi	r25, 0x00	; 0
    1f98:	88 0f       	add	r24, r24
    1f9a:	99 1f       	adc	r25, r25
    1f9c:	20 91 23 04 	lds	r18, 0x0423
    1fa0:	30 91 24 04 	lds	r19, 0x0424
    1fa4:	82 17       	cp	r24, r18
    1fa6:	93 07       	cpc	r25, r19
    1fa8:	08 f0       	brcs	.+2      	; 0x1fac <FPoolingPump+0x4ca>
    1faa:	97 c0       	rjmp	.+302    	; 0x20da <FPoolingPump+0x5f8>
		  	  iSend++;
    1fac:	80 91 f9 03 	lds	r24, 0x03F9
    1fb0:	8f 5f       	subi	r24, 0xFF	; 255
    1fb2:	80 93 f9 03 	sts	0x03F9, r24
		      if (iSend<nSend)stPoolingPump=ppSendTransReq;
    1fb6:	90 91 77 02 	lds	r25, 0x0277
    1fba:	89 17       	cp	r24, r25
    1fbc:	08 f0       	brcs	.+2      	; 0x1fc0 <FPoolingPump+0x4de>
    1fbe:	6b c0       	rjmp	.+214    	; 0x2096 <FPoolingPump+0x5b4>
    1fc0:	81 e1       	ldi	r24, 0x11	; 17
    1fc2:	89 c0       	rjmp	.+274    	; 0x20d6 <FPoolingPump+0x5f4>
		      if (iSend>nSend)stPoolingPump=ppDelayNextPump;	      
		  }
	      break;
	 case ppTransRequestCompleted:
          //StatePrintf(PSTR("21"));
		  stPoolingPump=ppSendTransInfo;
    1fc4:	86 e1       	ldi	r24, 0x16	; 22
    1fc6:	87 c0       	rjmp	.+270    	; 0x20d6 <FPoolingPump+0x5f4>
	      break;
     case ppSendTransInfo:
	      PumpAddr=(txPumpID&0x0F);	      
    1fc8:	80 91 17 01 	lds	r24, 0x0117
    1fcc:	98 2f       	mov	r25, r24
    1fce:	9f 70       	andi	r25, 0x0F	; 15
    1fd0:	90 93 05 01 	sts	0x0105, r25
		  SendTransFlow(txPumpID,rxPumpId,NozzleId,GradeId,strUnitPrice,strVolume,strAmount,PumpTransDigit);
    1fd4:	60 91 3b 01 	lds	r22, 0x013B
    1fd8:	40 91 e0 02 	lds	r20, 0x02E0
    1fdc:	20 91 f6 02 	lds	r18, 0x02F6
    1fe0:	0c ea       	ldi	r16, 0xAC	; 172
    1fe2:	12 e0       	ldi	r17, 0x02	; 2
    1fe4:	37 e5       	ldi	r19, 0x57	; 87
    1fe6:	e3 2e       	mov	r14, r19
    1fe8:	32 e0       	ldi	r19, 0x02	; 2
    1fea:	f3 2e       	mov	r15, r19
    1fec:	9b ea       	ldi	r25, 0xAB	; 171
    1fee:	c9 2e       	mov	r12, r25
    1ff0:	93 e0       	ldi	r25, 0x03	; 3
    1ff2:	d9 2e       	mov	r13, r25
    1ff4:	a0 90 0b 01 	lds	r10, 0x010B
    1ff8:	0e 94 b3 0c 	call	0x1966	; 0x1966 <SendTransFlow>
		  IsRequestTransInfo[PumpAddr]=False;
    1ffc:	e0 91 05 01 	lds	r30, 0x0105
    2000:	f0 e0       	ldi	r31, 0x00	; 0
    2002:	e6 57       	subi	r30, 0x76	; 118
    2004:	fd 4f       	sbci	r31, 0xFD	; 253
    2006:	61 c0       	rjmp	.+194    	; 0x20ca <FPoolingPump+0x5e8>
	      TimDelayNextPump=0;		  
		  stPoolingPump=ppDelayNextPump;
	      break;     
     case ppIsRequestTotalizerInfo:
          //StatePrintf(PSTR("23"));
	      PumpAddr=(txPumpID&0x0F);
    2008:	e0 91 17 01 	lds	r30, 0x0117
    200c:	ef 70       	andi	r30, 0x0F	; 15
    200e:	e0 93 05 01 	sts	0x0105, r30
	      if (IsRequestTotalizerInfo[PumpAddr]==True){
    2012:	f0 e0       	ldi	r31, 0x00	; 0
    2014:	ed 5e       	subi	r30, 0xED	; 237
    2016:	fb 4f       	sbci	r31, 0xFB	; 251
    2018:	80 81       	ld	r24, Z
    201a:	81 30       	cpi	r24, 0x01	; 1
    201c:	11 f4       	brne	.+4      	; 0x2022 <FPoolingPump+0x540>
		      stPoolingPump=ppRequestTotalizerData;		  
    201e:	8b e1       	ldi	r24, 0x1B	; 27
    2020:	5a c0       	rjmp	.+180    	; 0x20d6 <FPoolingPump+0x5f4>
		  }else{
		  TimDelayNextPump=0; 
    2022:	10 92 22 01 	sts	0x0122, r1
    2026:	10 92 21 01 	sts	0x0121, r1
		  stPoolingPump=ppNextPump;
    202a:	81 e0       	ldi	r24, 0x01	; 1
    202c:	54 c0       	rjmp	.+168    	; 0x20d6 <FPoolingPump+0x5f4>
	 }
	 zDataBuffer[0]=data;
}

void SetReceiveLine(char RecLine){
     stReceiveCom0=RecLine;
    202e:	84 e0       	ldi	r24, 0x04	; 4
    2030:	80 93 04 01 	sts	0x0104, r24

     case ppRequestTotalizerData:
          //StatePrintf(PSTR("24"));
	      SetReceiveLine(rcInitTotalizer);
	      if (GetReceiveLine()==rcInitTotalizer){
			  iSend=0;
    2034:	10 92 f9 03 	sts	0x03F9, r1
    2038:	2c c0       	rjmp	.+88     	; 0x2092 <FPoolingPump+0x5b0>
			  }
		  else stPoolingPump=ppRequestTotalizerData;
	      break;
     case ppSendTotalizerReq:
          //StatePrintf(PSTR("25"));
	 	  TimSend=0;
    203a:	10 92 24 04 	sts	0x0424, r1
    203e:	10 92 23 04 	sts	0x0423, r1
	      IsTotalizer=False;
    2042:	10 92 12 01 	sts	0x0112, r1
	      PumpCommand(txPumpID,CMD_TOTALIZER);
    2046:	80 91 17 01 	lds	r24, 0x0117
    204a:	65 e0       	ldi	r22, 0x05	; 5
    204c:	0e 94 69 07 	call	0xed2	; 0xed2 <PumpCommand>
		  stPoolingPump=ppWaitTotalizerReq;
    2050:	8d e1       	ldi	r24, 0x1D	; 29
    2052:	41 c0       	rjmp	.+130    	; 0x20d6 <FPoolingPump+0x5f4>
	      break;
	 case ppWaitTotalizerReq:
          //StatePrintf(PSTR("26"));
		  if (IsTotalizer==True){
    2054:	80 91 12 01 	lds	r24, 0x0112
    2058:	81 30       	cpi	r24, 0x01	; 1
    205a:	29 f4       	brne	.+10     	; 0x2066 <FPoolingPump+0x584>
		  	  IsTotalizer=False;
    205c:	10 92 12 01 	sts	0x0112, r1
			  stPoolingPump=ppTotalizerRequestCompleted;
    2060:	8e e1       	ldi	r24, 0x1E	; 30
    2062:	80 93 2c 01 	sts	0x012C, r24
		  }
          //if (TimSend>WAIT_TOTALIZER_TIMEOUT){
		  //    stPoolingPump=ppDelayNextPump;
		  //}
		  if (TimSend>(TPoolTimeout*5)){
    2066:	80 91 b6 02 	lds	r24, 0x02B6
    206a:	25 e0       	ldi	r18, 0x05	; 5
    206c:	82 9f       	mul	r24, r18
    206e:	c0 01       	movw	r24, r0
    2070:	11 24       	eor	r1, r1
    2072:	20 91 23 04 	lds	r18, 0x0423
    2076:	30 91 24 04 	lds	r19, 0x0424
    207a:	82 17       	cp	r24, r18
    207c:	93 07       	cpc	r25, r19
    207e:	68 f5       	brcc	.+90     	; 0x20da <FPoolingPump+0x5f8>
		  	  iSend++;
    2080:	80 91 f9 03 	lds	r24, 0x03F9
    2084:	8f 5f       	subi	r24, 0xFF	; 255
    2086:	80 93 f9 03 	sts	0x03F9, r24
		      if (iSend<nSend)stPoolingPump=ppSendTotalizerReq;
    208a:	90 91 77 02 	lds	r25, 0x0277
    208e:	89 17       	cp	r24, r25
    2090:	10 f4       	brcc	.+4      	; 0x2096 <FPoolingPump+0x5b4>
    2092:	8c e1       	ldi	r24, 0x1C	; 28
    2094:	20 c0       	rjmp	.+64     	; 0x20d6 <FPoolingPump+0x5f4>
			  else
		      if (iSend>nSend)stPoolingPump=ppDelayNextPump;	      
    2096:	98 17       	cp	r25, r24
    2098:	00 f5       	brcc	.+64     	; 0x20da <FPoolingPump+0x5f8>
    209a:	1c c0       	rjmp	.+56     	; 0x20d4 <FPoolingPump+0x5f2>
		  }
	      break;
	 case ppTotalizerRequestCompleted:
          //StatePrintf(PSTR("27"));																																																																																																																																		
		  stPoolingPump=ppSendTotalizerInfo;
    209c:	8f e1       	ldi	r24, 0x1F	; 31
    209e:	1b c0       	rjmp	.+54     	; 0x20d6 <FPoolingPump+0x5f4>
	      break;
     case ppSendTotalizerInfo:
          //StatePrintf(PSTR("28"));
	      PumpAddr=(txPumpID&0x0F);
    20a0:	80 91 17 01 	lds	r24, 0x0117
    20a4:	98 2f       	mov	r25, r24
    20a6:	9f 70       	andi	r25, 0x0F	; 15
    20a8:	90 93 05 01 	sts	0x0105, r25
		  SendTotalizerFlow(txPumpID);
    20ac:	0e 94 bb 0b 	call	0x1776	; 0x1776 <SendTotalizerFlow>
		  IsTotalizerACK=False;
    20b0:	10 92 14 01 	sts	0x0114, r1
		  //IsRequestTotalizerInfo[PumpAddr]=False;
	      //TimDelayNextPump=0;
		  stPoolingPump=ppWaitTotalizerACK;
    20b4:	80 e2       	ldi	r24, 0x20	; 32
    20b6:	0f c0       	rjmp	.+30     	; 0x20d6 <FPoolingPump+0x5f4>
	      break;
     case ppWaitTotalizerACK:
	      if (IsTotalizerACK==True){//SC_TOTALIZER_ACK
    20b8:	80 91 14 01 	lds	r24, 0x0114
    20bc:	81 30       	cpi	r24, 0x01	; 1
    20be:	69 f4       	brne	.+26     	; 0x20da <FPoolingPump+0x5f8>
              IsRequestTotalizerInfo[PumpAddr]=False;
    20c0:	e0 91 05 01 	lds	r30, 0x0105
    20c4:	f0 e0       	ldi	r31, 0x00	; 0
    20c6:	ed 5e       	subi	r30, 0xED	; 237
    20c8:	fb 4f       	sbci	r31, 0xFB	; 251
    20ca:	10 82       	st	Z, r1
	          TimDelayNextPump=0;
    20cc:	10 92 22 01 	sts	0x0122, r1
    20d0:	10 92 21 01 	sts	0x0121, r1
		      stPoolingPump=ppDelayNextPump;               
    20d4:	85 e1       	ldi	r24, 0x15	; 21
    20d6:	80 93 2c 01 	sts	0x012C, r24
		  }
	      break;
	 }
}
    20da:	1f 91       	pop	r17
    20dc:	0f 91       	pop	r16
    20de:	ff 90       	pop	r15
    20e0:	ef 90       	pop	r14
    20e2:	df 90       	pop	r13
    20e4:	cf 90       	pop	r12
    20e6:	af 90       	pop	r10
    20e8:	08 95       	ret

000020ea <FPoolingPump2>:
			 }
             rxBufferLength=0;
		}
}

void FPoolingPump2(){
    20ea:	af 92       	push	r10
    20ec:	cf 92       	push	r12
    20ee:	df 92       	push	r13
    20f0:	ef 92       	push	r14
    20f2:	ff 92       	push	r15
    20f4:	0f 93       	push	r16
    20f6:	1f 93       	push	r17
    20f8:	df 93       	push	r29
    20fa:	cf 93       	push	r28
    20fc:	cd b7       	in	r28, 0x3d	; 61
    20fe:	de b7       	in	r29, 0x3e	; 62
    2100:	6e 97       	sbiw	r28, 0x1e	; 30
    2102:	0f b6       	in	r0, 0x3f	; 63
    2104:	f8 94       	cli
    2106:	de bf       	out	0x3e, r29	; 62
    2108:	0f be       	out	0x3f, r0	; 63
    210a:	cd bf       	out	0x3d, r28	; 61
     static char zPooling,stPoolingPump=pwInit,nPoolTotalizer=0,IsTotalizerBusy=False,iAuthCmd=0;
	 char strSend[30];

	 //Monitoring
	 if (zPooling!=stPoolingPump){
    210c:	20 91 31 01 	lds	r18, 0x0131
    2110:	80 91 32 01 	lds	r24, 0x0132
    2114:	82 17       	cp	r24, r18
    2116:	31 f1       	breq	.+76     	; 0x2164 <FPoolingPump2+0x7a>
	     zPooling=stPoolingPump;
    2118:	20 93 32 01 	sts	0x0132, r18
		 #ifdef DEBUG_WAYNE_POOLING
         sprintf_P(strSend,PSTR("WPool:%d"),stPoolingPump);
    211c:	00 d0       	rcall	.+0      	; 0x211e <FPoolingPump2+0x34>
    211e:	00 d0       	rcall	.+0      	; 0x2120 <FPoolingPump2+0x36>
    2120:	00 d0       	rcall	.+0      	; 0x2122 <FPoolingPump2+0x38>
    2122:	ed b7       	in	r30, 0x3d	; 61
    2124:	fe b7       	in	r31, 0x3e	; 62
    2126:	31 96       	adiw	r30, 0x01	; 1
    2128:	8e 01       	movw	r16, r28
    212a:	0f 5f       	subi	r16, 0xFF	; 255
    212c:	1f 4f       	sbci	r17, 0xFF	; 255
    212e:	ad b7       	in	r26, 0x3d	; 61
    2130:	be b7       	in	r27, 0x3e	; 62
    2132:	12 96       	adiw	r26, 0x02	; 2
    2134:	1c 93       	st	X, r17
    2136:	0e 93       	st	-X, r16
    2138:	11 97       	sbiw	r26, 0x01	; 1
    213a:	86 e8       	ldi	r24, 0x86	; 134
    213c:	91 e0       	ldi	r25, 0x01	; 1
    213e:	93 83       	std	Z+3, r25	; 0x03
    2140:	82 83       	std	Z+2, r24	; 0x02
    2142:	24 83       	std	Z+4, r18	; 0x04
    2144:	15 82       	std	Z+5, r1	; 0x05
    2146:	0e 94 c0 18 	call	0x3180	; 0x3180 <sprintf_P>
	 	 _uart_print(1,1,strSend);
    214a:	8d b7       	in	r24, 0x3d	; 61
    214c:	9e b7       	in	r25, 0x3e	; 62
    214e:	06 96       	adiw	r24, 0x06	; 6
    2150:	0f b6       	in	r0, 0x3f	; 63
    2152:	f8 94       	cli
    2154:	9e bf       	out	0x3e, r25	; 62
    2156:	0f be       	out	0x3f, r0	; 63
    2158:	8d bf       	out	0x3d, r24	; 61
    215a:	81 e0       	ldi	r24, 0x01	; 1
    215c:	61 e0       	ldi	r22, 0x01	; 1
    215e:	a8 01       	movw	r20, r16
    2160:	0e 94 6f 18 	call	0x30de	; 0x30de <_uart_print>
		 #endif
	 }
     //Restarting
	 if (IsRestartPooling==True){
    2164:	80 91 03 01 	lds	r24, 0x0103
    2168:	81 30       	cpi	r24, 0x01	; 1
    216a:	79 f4       	brne	.+30     	; 0x218a <FPoolingPump2+0xa0>
	     IsRestartPooling=False;
    216c:	10 92 03 01 	sts	0x0103, r1
		 SendCommandAcknoledge(SC_POOL_RESTARTED,stPoolingPump);
    2170:	8a e1       	ldi	r24, 0x1A	; 26
    2172:	60 91 31 01 	lds	r22, 0x0131
    2176:	0e 94 e0 06 	call	0xdc0	; 0xdc0 <SendCommandAcknoledge>
		 _uart_printf(1,1,PSTR("PoolRestarted"));
    217a:	81 e0       	ldi	r24, 0x01	; 1
    217c:	61 e0       	ldi	r22, 0x01	; 1
    217e:	48 e7       	ldi	r20, 0x78	; 120
    2180:	51 e0       	ldi	r21, 0x01	; 1
    2182:	0e 94 97 18 	call	0x312e	; 0x312e <_uart_printf>
	     stPoolingPump=pwInit;
    2186:	10 92 31 01 	sts	0x0131, r1
	 }
	 switch(stPoolingPump){
    218a:	80 91 31 01 	lds	r24, 0x0131
    218e:	e8 2f       	mov	r30, r24
    2190:	f0 e0       	ldi	r31, 0x00	; 0
    2192:	ec 31       	cpi	r30, 0x1C	; 28
    2194:	f1 05       	cpc	r31, r1
    2196:	08 f0       	brcs	.+2      	; 0x219a <FPoolingPump2+0xb0>
    2198:	fa c2       	rjmp	.+1524   	; 0x278e <FPoolingPump2+0x6a4>
    219a:	e7 5a       	subi	r30, 0xA7	; 167
    219c:	ff 4f       	sbci	r31, 0xFF	; 255
    219e:	ee 0f       	add	r30, r30
    21a0:	ff 1f       	adc	r31, r31
    21a2:	05 90       	lpm	r0, Z+
    21a4:	f4 91       	lpm	r31, Z+
    21a6:	e0 2d       	mov	r30, r0
    21a8:	09 94       	ijmp
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    21aa:	e1 99       	sbic	0x1c, 1	; 28
    21ac:	fe cf       	rjmp	.-4      	; 0x21aa <FPoolingPump2+0xc0>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    21ae:	88 e0       	ldi	r24, 0x08	; 8
    21b0:	90 e0       	ldi	r25, 0x00	; 0
    21b2:	9f bb       	out	0x1f, r25	; 31
    21b4:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    21b6:	e0 9a       	sbi	0x1c, 0	; 28
    21b8:	8d b3       	in	r24, 0x1d	; 29
	 case pwInit:
		  nNoPump=eeprom_read_byte(&DefNoPumpCountMax);
    21ba:	80 93 35 04 	sts	0x0435, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    21be:	e1 99       	sbic	0x1c, 1	; 28
    21c0:	fe cf       	rjmp	.-4      	; 0x21be <FPoolingPump2+0xd4>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    21c2:	87 e0       	ldi	r24, 0x07	; 7
    21c4:	90 e0       	ldi	r25, 0x00	; 0
    21c6:	9f bb       	out	0x1f, r25	; 31
    21c8:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    21ca:	e0 9a       	sbi	0x1c, 0	; 28
    21cc:	8d b3       	in	r24, 0x1d	; 29
		  ScanPumpMax=eeprom_read_byte(&DefMaxPumpPooling);
    21ce:	80 93 61 02 	sts	0x0261, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    21d2:	e1 99       	sbic	0x1c, 1	; 28
    21d4:	fe cf       	rjmp	.-4      	; 0x21d2 <FPoolingPump2+0xe8>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    21d6:	89 e0       	ldi	r24, 0x09	; 9
    21d8:	90 e0       	ldi	r25, 0x00	; 0
    21da:	9f bb       	out	0x1f, r25	; 31
    21dc:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    21de:	e0 9a       	sbi	0x1c, 0	; 28
    21e0:	8d b3       	in	r24, 0x1d	; 29
		  nSend=eeprom_read_byte(&DefSendCount);
    21e2:	80 93 77 02 	sts	0x0277, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    21e6:	e1 99       	sbic	0x1c, 1	; 28
    21e8:	fe cf       	rjmp	.-4      	; 0x21e6 <FPoolingPump2+0xfc>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    21ea:	8d e1       	ldi	r24, 0x1D	; 29
    21ec:	90 e0       	ldi	r25, 0x00	; 0
    21ee:	9f bb       	out	0x1f, r25	; 31
    21f0:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    21f2:	e0 9a       	sbi	0x1c, 0	; 28
    21f4:	8d b3       	in	r24, 0x1d	; 29
		  nPoolTotalizer=eeprom_read_byte(&DefNozzleCount);
    21f6:	80 93 30 01 	sts	0x0130, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    21fa:	e1 99       	sbic	0x1c, 1	; 28
    21fc:	fe cf       	rjmp	.-4      	; 0x21fa <FPoolingPump2+0x110>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    21fe:	8a e0       	ldi	r24, 0x0A	; 10
    2200:	90 e0       	ldi	r25, 0x00	; 0
    2202:	9f bb       	out	0x1f, r25	; 31
    2204:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2206:	e0 9a       	sbi	0x1c, 0	; 28
    2208:	8d b3       	in	r24, 0x1d	; 29
		  TPoolTimeout=eeprom_read_byte(&DefPoolTimeout);
    220a:	80 93 b6 02 	sts	0x02B6, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    220e:	e1 99       	sbic	0x1c, 1	; 28
    2210:	fe cf       	rjmp	.-4      	; 0x220e <FPoolingPump2+0x124>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2212:	8b e0       	ldi	r24, 0x0B	; 11
    2214:	90 e0       	ldi	r25, 0x00	; 0
    2216:	9f bb       	out	0x1f, r25	; 31
    2218:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    221a:	e0 9a       	sbi	0x1c, 0	; 28
    221c:	8d b3       	in	r24, 0x1d	; 29
		  TDelayNextPump=eeprom_read_byte(&DefDelayNextPump);
    221e:	80 93 3c 01 	sts	0x013C, r24
		  
		  if (IsStopPoolSequence!=True)
    2222:	80 91 13 01 	lds	r24, 0x0113
    2226:	81 30       	cpi	r24, 0x01	; 1
    2228:	29 f0       	breq	.+10     	; 0x2234 <FPoolingPump2+0x14a>
		      SendCommandAcknoledge(SC_LIVE_SEQUENCE,SequencePool);
    222a:	89 e1       	ldi	r24, 0x19	; 25
    222c:	60 91 26 01 	lds	r22, 0x0126
    2230:	0e 94 e0 06 	call	0xdc0	; 0xdc0 <SendCommandAcknoledge>
		  SequencePool++;
    2234:	80 91 26 01 	lds	r24, 0x0126
    2238:	8f 5f       	subi	r24, 0xFF	; 255
    223a:	80 93 26 01 	sts	0x0126, r24
		  iPoolingID=0;		  
    223e:	10 92 16 01 	sts	0x0116, r1
		  IsTotalizerBusy=False;
    2242:	10 92 2f 01 	sts	0x012F, r1
		  stPoolingPump=pwInitPumpAddr;
    2246:	81 e0       	ldi	r24, 0x01	; 1
    2248:	9d c2       	rjmp	.+1338   	; 0x2784 <FPoolingPump2+0x69a>
		  break;
     case pwInitPumpAddr:
		  txPumpID=eeprom_read_byte(&DefPumpID[iPoolingID]);
    224a:	80 91 16 01 	lds	r24, 0x0116
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    224e:	e1 99       	sbic	0x1c, 1	; 28
    2250:	fe cf       	rjmp	.-4      	; 0x224e <FPoolingPump2+0x164>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2252:	90 e0       	ldi	r25, 0x00	; 0
    2254:	83 5f       	subi	r24, 0xF3	; 243
    2256:	9f 4f       	sbci	r25, 0xFF	; 255
    2258:	9f bb       	out	0x1f, r25	; 31
    225a:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    225c:	e0 9a       	sbi	0x1c, 0	; 28
    225e:	8d b3       	in	r24, 0x1d	; 29
          txPumpID=txPumpID-1; 
    2260:	81 50       	subi	r24, 0x01	; 1
    2262:	80 93 17 01 	sts	0x0117, r24
		   _uart_print(1,1,strSend);
		  #endif

		  //txPumpID=2-1; 
		  //SendCommandAcknoledge(SC_LIVE_SEQUENCE,SequencePool);
		  SequencePool++;
    2266:	80 91 26 01 	lds	r24, 0x0126
    226a:	8f 5f       	subi	r24, 0xFF	; 255
    226c:	80 93 26 01 	sts	0x0126, r24
          iSend=0;		  
    2270:	10 92 f9 03 	sts	0x03F9, r1
    2274:	84 c2       	rjmp	.+1288   	; 0x277e <FPoolingPump2+0x694>
	      stPoolingPump=pwScanStatus;
          break;	 
     case pwScanStatus:
	      WayneReply=WR_NONE;
    2276:	10 92 1a 01 	sts	0x011A, r1
	      FWayneSendCommand(CMD_STATUS,0,txPumpID,0);
    227a:	80 e0       	ldi	r24, 0x00	; 0
    227c:	60 e0       	ldi	r22, 0x00	; 0
    227e:	40 91 17 01 	lds	r20, 0x0117
    2282:	20 e0       	ldi	r18, 0x00	; 0
    2284:	0e 94 95 07 	call	0xf2a	; 0xf2a <FWayneSendCommand>
		  TimSend=0;
    2288:	10 92 24 04 	sts	0x0424, r1
    228c:	10 92 23 04 	sts	0x0423, r1
		  stPoolingPump=pwWaitScanReply;
    2290:	83 e0       	ldi	r24, 0x03	; 3
    2292:	78 c2       	rjmp	.+1264   	; 0x2784 <FPoolingPump2+0x69a>
	      break;
     case pwWaitScanReply:
	      //Timeout->NoPump		  
          if (TimSend>TPoolTimeout){
    2294:	80 91 b6 02 	lds	r24, 0x02B6
    2298:	90 e0       	ldi	r25, 0x00	; 0
    229a:	20 91 23 04 	lds	r18, 0x0423
    229e:	30 91 24 04 	lds	r19, 0x0424
    22a2:	82 17       	cp	r24, r18
    22a4:	93 07       	cpc	r25, r19
    22a6:	70 f4       	brcc	.+28     	; 0x22c4 <FPoolingPump2+0x1da>
		      iSend++;
    22a8:	80 91 f9 03 	lds	r24, 0x03F9
    22ac:	8f 5f       	subi	r24, 0xFF	; 255
    22ae:	80 93 f9 03 	sts	0x03F9, r24
			  if (iSend<nSend)stPoolingPump=pwScanStatus;//Retry
    22b2:	90 91 77 02 	lds	r25, 0x0277
    22b6:	89 17       	cp	r24, r25
    22b8:	10 f4       	brcc	.+4      	; 0x22be <FPoolingPump2+0x1d4>
    22ba:	82 e0       	ldi	r24, 0x02	; 2
    22bc:	01 c0       	rjmp	.+2      	; 0x22c0 <FPoolingPump2+0x1d6>
			  else
			  if (iSend>=nSend)stPoolingPump=pwNoPump;//Pump Not Available
    22be:	84 e0       	ldi	r24, 0x04	; 4
    22c0:	80 93 31 01 	sts	0x0131, r24
		  }		  
	      
		  switch(WayneReply){
    22c4:	80 91 1a 01 	lds	r24, 0x011A
    22c8:	81 30       	cpi	r24, 0x01	; 1
    22ca:	21 f0       	breq	.+8      	; 0x22d4 <FPoolingPump2+0x1ea>
    22cc:	84 30       	cpi	r24, 0x04	; 4
    22ce:	09 f0       	breq	.+2      	; 0x22d2 <FPoolingPump2+0x1e8>
    22d0:	5e c2       	rjmp	.+1212   	; 0x278e <FPoolingPump2+0x6a4>
    22d2:	15 c0       	rjmp	.+42     	; 0x22fe <FPoolingPump2+0x214>
		  case WR_READY:
			   if ((PumpStatus[txPumpID]==PW_NONE)||(PumpStatus[txPumpID]==PW_DISCONNECT)){
    22d4:	80 91 17 01 	lds	r24, 0x0117
    22d8:	a8 2f       	mov	r26, r24
    22da:	b0 e0       	ldi	r27, 0x00	; 0
    22dc:	fd 01       	movw	r30, r26
    22de:	eb 54       	subi	r30, 0x4B	; 75
    22e0:	fc 4f       	sbci	r31, 0xFC	; 252
    22e2:	e0 81       	ld	r30, Z
    22e4:	ee 23       	and	r30, r30
    22e6:	19 f0       	breq	.+6      	; 0x22ee <FPoolingPump2+0x204>
    22e8:	ee 30       	cpi	r30, 0x0E	; 14
    22ea:	09 f0       	breq	.+2      	; 0x22ee <FPoolingPump2+0x204>
    22ec:	15 c2       	rjmp	.+1066   	; 0x2718 <FPoolingPump2+0x62e>
			        IsRequestTransInfo[txPumpID]=False;
    22ee:	fd 01       	movw	r30, r26
    22f0:	e6 57       	subi	r30, 0x76	; 118
    22f2:	fd 4f       	sbci	r31, 0xFD	; 253
    22f4:	10 82       	st	Z, r1
			        PumpStatus[txPumpID]=PW_ONLINE;
    22f6:	ab 54       	subi	r26, 0x4B	; 75
    22f8:	bc 4f       	sbci	r27, 0xFC	; 252
    22fa:	86 e0       	ldi	r24, 0x06	; 6
    22fc:	17 c0       	rjmp	.+46     	; 0x232c <FPoolingPump2+0x242>
				  }
               //_uart_printf(1,1,PSTR("WR_READY"));
               stPoolingPump=pwUpdatePumpStatus;
		       break;
          case WR_MESSAGE:
		       stPoolingPump=pwReplyACK;
    22fe:	87 e1       	ldi	r24, 0x17	; 23
    2300:	41 c2       	rjmp	.+1154   	; 0x2784 <FPoolingPump2+0x69a>
		       break;
		  }
	      break;
	 case pwNoPump:
	      NoPumpCount[txPumpID&0x0F]++;
    2302:	80 91 17 01 	lds	r24, 0x0117
    2306:	a8 2f       	mov	r26, r24
    2308:	b0 e0       	ldi	r27, 0x00	; 0
    230a:	fd 01       	movw	r30, r26
    230c:	ef 70       	andi	r30, 0x0F	; 15
    230e:	f0 70       	andi	r31, 0x00	; 0
    2310:	eb 5d       	subi	r30, 0xDB	; 219
    2312:	fb 4f       	sbci	r31, 0xFB	; 251
    2314:	80 81       	ld	r24, Z
    2316:	8f 5f       	subi	r24, 0xFF	; 255
    2318:	80 83       	st	Z, r24
		  if (NoPumpCount[txPumpID&0x0F]>nNoPump){
    231a:	90 91 35 04 	lds	r25, 0x0435
    231e:	98 17       	cp	r25, r24
    2320:	08 f0       	brcs	.+2      	; 0x2324 <FPoolingPump2+0x23a>
    2322:	7a c1       	rjmp	.+756    	; 0x2618 <FPoolingPump2+0x52e>
		      NoPumpCount[txPumpID&0x0F]=0;
    2324:	10 82       	st	Z, r1
	          PumpStatus[txPumpID]=PW_DISCONNECT;
    2326:	ab 54       	subi	r26, 0x4B	; 75
    2328:	bc 4f       	sbci	r27, 0xFC	; 252
    232a:	8e e0       	ldi	r24, 0x0E	; 14
    232c:	8c 93       	st	X, r24
    232e:	f4 c1       	rjmp	.+1000   	; 0x2718 <FPoolingPump2+0x62e>
              stPoolingPump=pwUpdatePumpStatus;
			  }
          else stPoolingPump=pwInitDelayNextPump;
	      break;
     case pwUpdatePumpStatus:
	      PumpAddr=txPumpID;
    2330:	80 91 17 01 	lds	r24, 0x0117
    2334:	80 93 05 01 	sts	0x0105, r24
	 	  if (PumpStatus[PumpAddr]!=zPumpStatus[PumpAddr]){
    2338:	90 e0       	ldi	r25, 0x00	; 0
    233a:	fc 01       	movw	r30, r24
    233c:	eb 54       	subi	r30, 0x4B	; 75
    233e:	fc 4f       	sbci	r31, 0xFC	; 252
    2340:	e0 81       	ld	r30, Z
    2342:	dc 01       	movw	r26, r24
    2344:	a5 56       	subi	r26, 0x65	; 101
    2346:	bd 4f       	sbci	r27, 0xFD	; 253
    2348:	8c 91       	ld	r24, X
    234a:	e8 17       	cp	r30, r24
    234c:	79 f0       	breq	.+30     	; 0x236c <FPoolingPump2+0x282>
		      zPumpStatus[PumpAddr]=PumpStatus[PumpAddr];
    234e:	ec 93       	st	X, r30
		      stPoolingPump=pwSendPumpStatus;
    2350:	86 e0       	ldi	r24, 0x06	; 6
    2352:	18 c2       	rjmp	.+1072   	; 0x2784 <FPoolingPump2+0x69a>
		  }else stPoolingPump=pwNextAction;
	      break;
     case pwSendPumpStatus:
          PumpAddr=txPumpID;
    2354:	80 91 17 01 	lds	r24, 0x0117
    2358:	80 93 05 01 	sts	0x0105, r24
	      SendPumpStatusFlow(txPumpID+1,PumpStatus[PumpAddr]);
    235c:	e8 2f       	mov	r30, r24
    235e:	f0 e0       	ldi	r31, 0x00	; 0
    2360:	eb 54       	subi	r30, 0x4B	; 75
    2362:	fc 4f       	sbci	r31, 0xFC	; 252
    2364:	8f 5f       	subi	r24, 0xFF	; 255
    2366:	60 81       	ld	r22, Z
    2368:	0e 94 c8 06 	call	0xd90	; 0xd90 <SendPumpStatusFlow>
		  //sprintf_P(strSend,PSTR("WR:%d MI:%d"),WayneReply,MsgInfo);
		  //_uart_print(1,1,strSend);
	      stPoolingPump=pwNextAction;
    236c:	87 e0       	ldi	r24, 0x07	; 7
    236e:	0a c2       	rjmp	.+1044   	; 0x2784 <FPoolingPump2+0x69a>
	      break;
     case pwNextAction:
	      //Switch Action Based Pump State
		  PumpAddr=txPumpID;
    2370:	80 91 17 01 	lds	r24, 0x0117
    2374:	80 93 05 01 	sts	0x0105, r24
		  switch(PumpStatus[PumpAddr]){
    2378:	a8 2f       	mov	r26, r24
    237a:	b0 e0       	ldi	r27, 0x00	; 0
    237c:	fd 01       	movw	r30, r26
    237e:	eb 54       	subi	r30, 0x4B	; 75
    2380:	fc 4f       	sbci	r31, 0xFC	; 252
    2382:	80 81       	ld	r24, Z
    2384:	87 30       	cpi	r24, 0x07	; 7
    2386:	09 f4       	brne	.+2      	; 0x238a <FPoolingPump2+0x2a0>
    2388:	6e c0       	rjmp	.+220    	; 0x2466 <FPoolingPump2+0x37c>
    238a:	88 30       	cpi	r24, 0x08	; 8
    238c:	20 f4       	brcc	.+8      	; 0x2396 <FPoolingPump2+0x2ac>
    238e:	86 30       	cpi	r24, 0x06	; 6
    2390:	09 f0       	breq	.+2      	; 0x2394 <FPoolingPump2+0x2aa>
    2392:	fd c1       	rjmp	.+1018   	; 0x278e <FPoolingPump2+0x6a4>
    2394:	1e c0       	rjmp	.+60     	; 0x23d2 <FPoolingPump2+0x2e8>
    2396:	89 30       	cpi	r24, 0x09	; 9
    2398:	09 f4       	brne	.+2      	; 0x239c <FPoolingPump2+0x2b2>
    239a:	68 c0       	rjmp	.+208    	; 0x246c <FPoolingPump2+0x382>
    239c:	8e 30       	cpi	r24, 0x0E	; 14
    239e:	09 f0       	breq	.+2      	; 0x23a2 <FPoolingPump2+0x2b8>
    23a0:	f6 c1       	rjmp	.+1004   	; 0x278e <FPoolingPump2+0x6a4>
		  case PW_DISCONNECT:
		       switch(WayneReply){
    23a2:	80 91 1a 01 	lds	r24, 0x011A
    23a6:	88 23       	and	r24, r24
    23a8:	09 f4       	brne	.+2      	; 0x23ac <FPoolingPump2+0x2c2>
    23aa:	36 c1       	rjmp	.+620    	; 0x2618 <FPoolingPump2+0x52e>
    23ac:	84 30       	cpi	r24, 0x04	; 4
    23ae:	09 f0       	breq	.+2      	; 0x23b2 <FPoolingPump2+0x2c8>
    23b0:	ee c1       	rjmp	.+988    	; 0x278e <FPoolingPump2+0x6a4>
			   case WR_MESSAGE:
			        switch(MsgInfo){
    23b2:	80 91 19 01 	lds	r24, 0x0119
    23b6:	83 30       	cpi	r24, 0x03	; 3
    23b8:	39 f0       	breq	.+14     	; 0x23c8 <FPoolingPump2+0x2de>
    23ba:	88 30       	cpi	r24, 0x08	; 8
    23bc:	09 f4       	brne	.+2      	; 0x23c0 <FPoolingPump2+0x2d6>
    23be:	aa c1       	rjmp	.+852    	; 0x2714 <FPoolingPump2+0x62a>
    23c0:	82 30       	cpi	r24, 0x02	; 2
    23c2:	09 f0       	breq	.+2      	; 0x23c6 <FPoolingPump2+0x2dc>
    23c4:	a7 c1       	rjmp	.+846    	; 0x2714 <FPoolingPump2+0x62a>
    23c6:	31 c0       	rjmp	.+98     	; 0x242a <FPoolingPump2+0x340>
					case MI_NOZZLE_DOWN:
						 IsRequestTransInfo[txPumpID]=True;
    23c8:	a6 57       	subi	r26, 0x76	; 118
    23ca:	bd 4f       	sbci	r27, 0xFD	; 253
    23cc:	81 e0       	ldi	r24, 0x01	; 1
    23ce:	8c 93       	st	X, r24
    23d0:	a1 c1       	rjmp	.+834    	; 0x2714 <FPoolingPump2+0x62a>
			   }
		       break;
          case PW_ONLINE:
		       //sprintf_P(strSend,PSTR("ONLine:%d"),WayneReply);
			   //_uart_print(1,1,strSend);
		       switch(WayneReply){
    23d2:	80 91 1a 01 	lds	r24, 0x011A
    23d6:	81 30       	cpi	r24, 0x01	; 1
    23d8:	21 f0       	breq	.+8      	; 0x23e2 <FPoolingPump2+0x2f8>
    23da:	84 30       	cpi	r24, 0x04	; 4
    23dc:	09 f0       	breq	.+2      	; 0x23e0 <FPoolingPump2+0x2f6>
    23de:	d7 c1       	rjmp	.+942    	; 0x278e <FPoolingPump2+0x6a4>
    23e0:	14 c0       	rjmp	.+40     	; 0x240a <FPoolingPump2+0x320>
			   case WR_READY:
			        if (IsRequestTransInfo[txPumpID]==True){
    23e2:	fd 01       	movw	r30, r26
    23e4:	e6 57       	subi	r30, 0x76	; 118
    23e6:	fd 4f       	sbci	r31, 0xFD	; 253
    23e8:	80 81       	ld	r24, Z
    23ea:	81 30       	cpi	r24, 0x01	; 1
    23ec:	29 f4       	brne	.+10     	; 0x23f8 <FPoolingPump2+0x30e>
					    iSend=0;
    23ee:	10 92 f9 03 	sts	0x03F9, r1
					    stPoolingPump=pwSendTransactionRequest;
    23f2:	8e e0       	ldi	r24, 0x0E	; 14
    23f4:	80 93 31 01 	sts	0x0131, r24
					}if (IsRequestTotalizerInfo[txPumpID]==True){
    23f8:	ad 5e       	subi	r26, 0xED	; 237
    23fa:	bb 4f       	sbci	r27, 0xFB	; 251
    23fc:	8c 91       	ld	r24, X
    23fe:	81 30       	cpi	r24, 0x01	; 1
    2400:	09 f0       	breq	.+2      	; 0x2404 <FPoolingPump2+0x31a>
    2402:	0a c1       	rjmp	.+532    	; 0x2618 <FPoolingPump2+0x52e>
					    iSend=0;
    2404:	10 92 f9 03 	sts	0x03F9, r1
    2408:	29 c0       	rjmp	.+82     	; 0x245c <FPoolingPump2+0x372>
						stPoolingPump=pwSendTotalizerRequest;
					}else stPoolingPump=pwInitDelayNextPump;

			        break;
			   case WR_MESSAGE:
			        switch(MsgInfo){
    240a:	80 91 19 01 	lds	r24, 0x0119
    240e:	83 30       	cpi	r24, 0x03	; 3
    2410:	c9 f0       	breq	.+50     	; 0x2444 <FPoolingPump2+0x35a>
    2412:	84 30       	cpi	r24, 0x04	; 4
    2414:	20 f4       	brcc	.+8      	; 0x241e <FPoolingPump2+0x334>
    2416:	82 30       	cpi	r24, 0x02	; 2
    2418:	09 f0       	breq	.+2      	; 0x241c <FPoolingPump2+0x332>
    241a:	b9 c1       	rjmp	.+882    	; 0x278e <FPoolingPump2+0x6a4>
    241c:	06 c0       	rjmp	.+12     	; 0x242a <FPoolingPump2+0x340>
    241e:	86 30       	cpi	r24, 0x06	; 6
    2420:	49 f0       	breq	.+18     	; 0x2434 <FPoolingPump2+0x34a>
    2422:	88 30       	cpi	r24, 0x08	; 8
    2424:	09 f0       	breq	.+2      	; 0x2428 <FPoolingPump2+0x33e>
    2426:	b3 c1       	rjmp	.+870    	; 0x278e <FPoolingPump2+0x6a4>
    2428:	12 c0       	rjmp	.+36     	; 0x244e <FPoolingPump2+0x364>
					case MI_NOZZLE_UP:
					     PumpStatus[PumpAddr]=PW_CALL;
    242a:	87 e0       	ldi	r24, 0x07	; 7
    242c:	80 83       	st	Z, r24
						 iAuthCmd=0;
    242e:	10 92 2e 01 	sts	0x012E, r1
    2432:	72 c1       	rjmp	.+740    	; 0x2718 <FPoolingPump2+0x62e>
						 stPoolingPump=pwUpdatePumpStatus;
					     break;
					case MI_LAST_TRANSACTION:
                         if (IsRequestTransInfo[txPumpID]==True)
    2434:	a6 57       	subi	r26, 0x76	; 118
    2436:	bd 4f       	sbci	r27, 0xFD	; 253
    2438:	8c 91       	ld	r24, X
    243a:	81 30       	cpi	r24, 0x01	; 1
    243c:	09 f0       	breq	.+2      	; 0x2440 <FPoolingPump2+0x356>
    243e:	ec c0       	rjmp	.+472    	; 0x2618 <FPoolingPump2+0x52e>
						     stPoolingPump=pwSendTransMessage;
    2440:	81 e1       	ldi	r24, 0x11	; 17
    2442:	a0 c1       	rjmp	.+832    	; 0x2784 <FPoolingPump2+0x69a>
                         else stPoolingPump=pwInitDelayNextPump;
					     break;
					case MI_NOZZLE_DOWN:
                         IsRequestTransInfo[txPumpID]=True;
    2444:	a6 57       	subi	r26, 0x76	; 118
    2446:	bd 4f       	sbci	r27, 0xFD	; 253
    2448:	81 e0       	ldi	r24, 0x01	; 1
    244a:	8c 93       	st	X, r24
    244c:	e5 c0       	rjmp	.+458    	; 0x2618 <FPoolingPump2+0x52e>
						 stPoolingPump=pwInitDelayNextPump;
					     break;
                    case MI_TOTALIZER:
					     if (ActiveNozzle<4){
    244e:	80 91 1c 01 	lds	r24, 0x011C
    2452:	84 30       	cpi	r24, 0x04	; 4
    2454:	30 f4       	brcc	.+12     	; 0x2462 <FPoolingPump2+0x378>
						     iSend=0;
    2456:	10 92 f9 03 	sts	0x03F9, r1
						     ActiveNozzle++;
    245a:	8f 5f       	subi	r24, 0xFF	; 255
    245c:	80 93 1c 01 	sts	0x011C, r24
    2460:	be c0       	rjmp	.+380    	; 0x25de <FPoolingPump2+0x4f4>
						     stPoolingPump=pwSendTotalizerRequest;
						 }else stPoolingPump=pwSendTotalizerInfo;
    2462:	8c e0       	ldi	r24, 0x0C	; 12
    2464:	8f c1       	rjmp	.+798    	; 0x2784 <FPoolingPump2+0x69a>
			   case WR_NACK:
			        break;
			   }
		       break;
          case PW_CALL:
		       iSend=0; 
    2466:	10 92 f9 03 	sts	0x03F9, r1
    246a:	34 c1       	rjmp	.+616    	; 0x26d4 <FPoolingPump2+0x5ea>
			   stPoolingPump=pwSendAuthorizeCommand;               			   
		       break;
           
          case PW_AUTHORIZED:
               if (WayneReply==WR_READY){
    246c:	80 91 1a 01 	lds	r24, 0x011A
    2470:	81 30       	cpi	r24, 0x01	; 1
    2472:	09 f4       	brne	.+2      	; 0x2476 <FPoolingPump2+0x38c>
    2474:	d1 c0       	rjmp	.+418    	; 0x2618 <FPoolingPump2+0x52e>
			           stPoolingPump=pwInitDelayNextPump;
			   }else if (WayneReply==WR_MESSAGE){
    2476:	80 91 1a 01 	lds	r24, 0x011A
    247a:	84 30       	cpi	r24, 0x04	; 4
    247c:	09 f0       	breq	.+2      	; 0x2480 <FPoolingPump2+0x396>
    247e:	87 c1       	rjmp	.+782    	; 0x278e <FPoolingPump2+0x6a4>
			       if (MsgInfo==MI_NOZZLE_DOWN){
    2480:	80 91 19 01 	lds	r24, 0x0119
    2484:	83 30       	cpi	r24, 0x03	; 3
    2486:	09 f0       	breq	.+2      	; 0x248a <FPoolingPump2+0x3a0>
    2488:	7a c1       	rjmp	.+756    	; 0x277e <FPoolingPump2+0x694>
				       PumpStatus[PumpAddr]=PW_ONLINE;
    248a:	86 e0       	ldi	r24, 0x06	; 6
    248c:	80 83       	st	Z, r24
					   iSend=0;
    248e:	10 92 f9 03 	sts	0x03F9, r1
    2492:	3a c0       	rjmp	.+116    	; 0x2508 <FPoolingPump2+0x41e>
	      break;
     //Request last Transaction
	 case pwSendTransactionRequest:	 
	      //sprintf_P(strSend,PSTR("Last Transcation"));
		  //_uart_print(1,1,strSend);
		  FWayneSendCommand(CMD_TRANSACTION,CommandSeqID[txPumpID],txPumpID,ActiveNozzle);          
    2494:	40 91 17 01 	lds	r20, 0x0117
    2498:	e4 2f       	mov	r30, r20
    249a:	f0 e0       	ldi	r31, 0x00	; 0
    249c:	ee 57       	subi	r30, 0x7E	; 126
    249e:	fd 4f       	sbci	r31, 0xFD	; 253
    24a0:	8e e0       	ldi	r24, 0x0E	; 14
    24a2:	60 81       	ld	r22, Z
    24a4:	20 91 1c 01 	lds	r18, 0x011C
    24a8:	0e 94 95 07 	call	0xf2a	; 0xf2a <FWayneSendCommand>
		  TimSend=0;
    24ac:	10 92 24 04 	sts	0x0424, r1
    24b0:	10 92 23 04 	sts	0x0423, r1
          stPoolingPump=pwWaitTransACK;
    24b4:	8f e0       	ldi	r24, 0x0F	; 15
    24b6:	66 c1       	rjmp	.+716    	; 0x2784 <FPoolingPump2+0x69a>
	      break;
     case pwWaitTransACK:
	 	  //Timeout->NoPump		  
          if (TimSend>TPoolTimeout){
    24b8:	80 91 b6 02 	lds	r24, 0x02B6
    24bc:	90 e0       	ldi	r25, 0x00	; 0
    24be:	20 91 23 04 	lds	r18, 0x0423
    24c2:	30 91 24 04 	lds	r19, 0x0424
    24c6:	82 17       	cp	r24, r18
    24c8:	93 07       	cpc	r25, r19
    24ca:	18 f4       	brcc	.+6      	; 0x24d2 <FPoolingPump2+0x3e8>
		      stPoolingPump=pwRetrySendTransRequest;
    24cc:	80 e1       	ldi	r24, 0x10	; 16
    24ce:	80 93 31 01 	sts	0x0131, r24
		  }
          //Acknowledge
	      if (WayneReply==WR_ACK){
    24d2:	90 91 1a 01 	lds	r25, 0x011A
    24d6:	92 30       	cpi	r25, 0x02	; 2
    24d8:	09 f4       	brne	.+2      	; 0x24dc <FPoolingPump2+0x3f2>
    24da:	60 c0       	rjmp	.+192    	; 0x259c <FPoolingPump2+0x4b2>
		      CommandSeqID[txPumpID]++;
			  //stPoolingPump=pwSendTransMessage;
			  stPoolingPump=pwScanStatus;
		  }else if (WayneReply==WR_NACK){
    24dc:	80 91 1a 01 	lds	r24, 0x011A
    24e0:	83 30       	cpi	r24, 0x03	; 3
    24e2:	09 f0       	breq	.+2      	; 0x24e6 <FPoolingPump2+0x3fc>
    24e4:	54 c1       	rjmp	.+680    	; 0x278e <FPoolingPump2+0x6a4>
		      CommandSeqID[txPumpID]=0;
    24e6:	e0 91 17 01 	lds	r30, 0x0117
    24ea:	f0 e0       	ldi	r31, 0x00	; 0
    24ec:	ee 57       	subi	r30, 0x7E	; 126
    24ee:	fd 4f       	sbci	r31, 0xFD	; 253
    24f0:	10 82       	st	Z, r1
    24f2:	0a c0       	rjmp	.+20     	; 0x2508 <FPoolingPump2+0x41e>
              stPoolingPump=pwSendTransactionRequest;
		  }
	      break;
     case pwRetrySendTransRequest:
	      iSend++;
    24f4:	80 91 f9 03 	lds	r24, 0x03F9
    24f8:	8f 5f       	subi	r24, 0xFF	; 255
    24fa:	80 93 f9 03 	sts	0x03F9, r24
		  if (iSend<nSend)stPoolingPump=pwSendTransactionRequest;
    24fe:	90 91 77 02 	lds	r25, 0x0277
    2502:	89 17       	cp	r24, r25
    2504:	08 f0       	brcs	.+2      	; 0x2508 <FPoolingPump2+0x41e>
    2506:	e8 c0       	rjmp	.+464    	; 0x26d8 <FPoolingPump2+0x5ee>
    2508:	8e e0       	ldi	r24, 0x0E	; 14
    250a:	3c c1       	rjmp	.+632    	; 0x2784 <FPoolingPump2+0x69a>
		  else
		  if (iSend>=nSend)stPoolingPump=pwNoPump;
	      break;

     case pwSendTransMessage:
          rxPumpId=txPumpID;
    250c:	60 91 17 01 	lds	r22, 0x0117
    2510:	60 93 3b 01 	sts	0x013B, r22
		  NozzleId=ActiveNozzle;
    2514:	20 91 1c 01 	lds	r18, 0x011C
    2518:	20 93 e0 02 	sts	0x02E0, r18
		  GradeId=ActiveNozzle;
    251c:	20 93 f6 02 	sts	0x02F6, r18
		  PumpTransDigit=6;
    2520:	86 e0       	ldi	r24, 0x06	; 6
    2522:	80 93 0b 01 	sts	0x010B, r24
	      SendTransFlow(txPumpID+1,rxPumpId+1,NozzleId,GradeId,strUnitPrice,strVolume,strAmount,PumpTransDigit);
    2526:	6f 5f       	subi	r22, 0xFF	; 255
    2528:	86 2f       	mov	r24, r22
    252a:	42 2f       	mov	r20, r18
    252c:	0c ea       	ldi	r16, 0xAC	; 172
    252e:	12 e0       	ldi	r17, 0x02	; 2
    2530:	e7 e5       	ldi	r30, 0x57	; 87
    2532:	ee 2e       	mov	r14, r30
    2534:	e2 e0       	ldi	r30, 0x02	; 2
    2536:	fe 2e       	mov	r15, r30
    2538:	7b ea       	ldi	r23, 0xAB	; 171
    253a:	c7 2e       	mov	r12, r23
    253c:	73 e0       	ldi	r23, 0x03	; 3
    253e:	d7 2e       	mov	r13, r23
    2540:	56 e0       	ldi	r21, 0x06	; 6
    2542:	a5 2e       	mov	r10, r21
    2544:	0e 94 b3 0c 	call	0x1966	; 0x1966 <SendTransFlow>
		  IsRequestTransInfo[txPumpID]=False;
    2548:	e0 91 17 01 	lds	r30, 0x0117
    254c:	f0 e0       	ldi	r31, 0x00	; 0
    254e:	e6 57       	subi	r30, 0x76	; 118
    2550:	fd 4f       	sbci	r31, 0xFD	; 253
    2552:	10 82       	st	Z, r1
    2554:	61 c0       	rjmp	.+194    	; 0x2618 <FPoolingPump2+0x52e>
		  //IsRequestTotalizerInfo[txPumpID]=True;
          stPoolingPump=pwInitDelayNextPump;
	      break; 
	 //Totalizer
	 case pwSendTotalizerRequest:
	      FWayneSendCommand(CMD_TOTALIZER,CommandSeqID[txPumpID],txPumpID,ActiveNozzle);          
    2556:	40 91 17 01 	lds	r20, 0x0117
    255a:	e4 2f       	mov	r30, r20
    255c:	f0 e0       	ldi	r31, 0x00	; 0
    255e:	ee 57       	subi	r30, 0x7E	; 126
    2560:	fd 4f       	sbci	r31, 0xFD	; 253
    2562:	85 e0       	ldi	r24, 0x05	; 5
    2564:	60 81       	ld	r22, Z
    2566:	20 91 1c 01 	lds	r18, 0x011C
    256a:	0e 94 95 07 	call	0xf2a	; 0xf2a <FWayneSendCommand>
		  TimSend=0;
    256e:	10 92 24 04 	sts	0x0424, r1
    2572:	10 92 23 04 	sts	0x0423, r1
          stPoolingPump=pwWaitTotalizerACK;
    2576:	8a e0       	ldi	r24, 0x0A	; 10
    2578:	05 c1       	rjmp	.+522    	; 0x2784 <FPoolingPump2+0x69a>
	      break;
     case pwWaitTotalizerACK:
	       //Timeout->NoPump		  
          if (TimSend>TPoolTimeout){
    257a:	80 91 b6 02 	lds	r24, 0x02B6
    257e:	90 e0       	ldi	r25, 0x00	; 0
    2580:	20 91 23 04 	lds	r18, 0x0423
    2584:	30 91 24 04 	lds	r19, 0x0424
    2588:	82 17       	cp	r24, r18
    258a:	93 07       	cpc	r25, r19
    258c:	18 f4       	brcc	.+6      	; 0x2594 <FPoolingPump2+0x4aa>
		      stPoolingPump=pwRetrySendTotalizerRequest;
    258e:	8b e0       	ldi	r24, 0x0B	; 11
    2590:	80 93 31 01 	sts	0x0131, r24
		  }
          //Acknowledge
	      if (WayneReply==WR_ACK){
    2594:	90 91 1a 01 	lds	r25, 0x011A
    2598:	92 30       	cpi	r25, 0x02	; 2
    259a:	59 f4       	brne	.+22     	; 0x25b2 <FPoolingPump2+0x4c8>
		      CommandSeqID[txPumpID]++;
    259c:	e0 91 17 01 	lds	r30, 0x0117
    25a0:	f0 e0       	ldi	r31, 0x00	; 0
    25a2:	ee 57       	subi	r30, 0x7E	; 126
    25a4:	fd 4f       	sbci	r31, 0xFD	; 253
    25a6:	80 81       	ld	r24, Z
    25a8:	8f 5f       	subi	r24, 0xFF	; 255
    25aa:	80 83       	st	Z, r24
			  stPoolingPump=pwScanStatus;
    25ac:	90 93 31 01 	sts	0x0131, r25
    25b0:	ee c0       	rjmp	.+476    	; 0x278e <FPoolingPump2+0x6a4>
		  }else if (WayneReply==WR_NACK){
    25b2:	80 91 1a 01 	lds	r24, 0x011A
    25b6:	83 30       	cpi	r24, 0x03	; 3
    25b8:	09 f0       	breq	.+2      	; 0x25bc <FPoolingPump2+0x4d2>
    25ba:	e9 c0       	rjmp	.+466    	; 0x278e <FPoolingPump2+0x6a4>
		      CommandSeqID[txPumpID]=0;
    25bc:	e0 91 17 01 	lds	r30, 0x0117
    25c0:	f0 e0       	ldi	r31, 0x00	; 0
    25c2:	ee 57       	subi	r30, 0x7E	; 126
    25c4:	fd 4f       	sbci	r31, 0xFD	; 253
    25c6:	10 82       	st	Z, r1
    25c8:	0a c0       	rjmp	.+20     	; 0x25de <FPoolingPump2+0x4f4>
              stPoolingPump=pwSendTotalizerRequest;
		  }
	      break;
     case pwRetrySendTotalizerRequest:
	      iSend++;
    25ca:	80 91 f9 03 	lds	r24, 0x03F9
    25ce:	8f 5f       	subi	r24, 0xFF	; 255
    25d0:	80 93 f9 03 	sts	0x03F9, r24
		  if (iSend<nSend)stPoolingPump=pwSendTotalizerRequest;
    25d4:	90 91 77 02 	lds	r25, 0x0277
    25d8:	89 17       	cp	r24, r25
    25da:	08 f0       	brcs	.+2      	; 0x25de <FPoolingPump2+0x4f4>
    25dc:	7d c0       	rjmp	.+250    	; 0x26d8 <FPoolingPump2+0x5ee>
    25de:	89 e0       	ldi	r24, 0x09	; 9
    25e0:	d1 c0       	rjmp	.+418    	; 0x2784 <FPoolingPump2+0x69a>
		  else
		  if (iSend>=nSend)stPoolingPump=pwNoPump;
	      break;
     case pwSendTotalizerInfo:
	      PumpTotalDigit=10;
    25e2:	8a e0       	ldi	r24, 0x0A	; 10
    25e4:	80 93 0c 01 	sts	0x010C, r24
	      SendTotalizerFlow(txPumpID+1);
    25e8:	80 91 17 01 	lds	r24, 0x0117
    25ec:	8f 5f       	subi	r24, 0xFF	; 255
    25ee:	0e 94 bb 0b 	call	0x1776	; 0x1776 <SendTotalizerFlow>
		  IsTotalizerACK=False;//True;//
    25f2:	10 92 14 01 	sts	0x0114, r1
		  stPoolingPump=pwWaitTotalizerInfoACK;
    25f6:	8d e0       	ldi	r24, 0x0D	; 13
    25f8:	c5 c0       	rjmp	.+394    	; 0x2784 <FPoolingPump2+0x69a>
	      break;
     case pwWaitTotalizerInfoACK:
	      if (IsTotalizerACK==True){//SC_TOTALIZER_ACK
    25fa:	80 91 14 01 	lds	r24, 0x0114
    25fe:	81 30       	cpi	r24, 0x01	; 1
    2600:	09 f0       	breq	.+2      	; 0x2604 <FPoolingPump2+0x51a>
    2602:	c5 c0       	rjmp	.+394    	; 0x278e <FPoolingPump2+0x6a4>
              IsRequestTotalizerInfo[PumpAddr]=False;
    2604:	e0 91 05 01 	lds	r30, 0x0105
    2608:	f0 e0       	ldi	r31, 0x00	; 0
    260a:	ed 5e       	subi	r30, 0xED	; 237
    260c:	fb 4f       	sbci	r31, 0xFB	; 251
    260e:	10 82       	st	Z, r1
	          TimDelayNextPump=0;
    2610:	10 92 22 01 	sts	0x0122, r1
    2614:	10 92 21 01 	sts	0x0121, r1
		      stPoolingPump=pwInitDelayNextPump;
    2618:	89 e1       	ldi	r24, 0x19	; 25
    261a:	b4 c0       	rjmp	.+360    	; 0x2784 <FPoolingPump2+0x69a>
     case pwSendAuthorizeCommand:
	      #ifdef DEBUG_WAYNE_STATE 
		  sprintf_P(strSend,PSTR("Authorize%d"),iAuthCmd+1);
		  _uart_print(1,1,strSend);
		  #endif
		  FWayneSendCommand((CMD_AUTH_1+iAuthCmd),CommandSeqID[txPumpID],txPumpID,ActiveNozzle);          
    261c:	40 91 17 01 	lds	r20, 0x0117
    2620:	80 91 2e 01 	lds	r24, 0x012E
    2624:	e4 2f       	mov	r30, r20
    2626:	f0 e0       	ldi	r31, 0x00	; 0
    2628:	ee 57       	subi	r30, 0x7E	; 126
    262a:	fd 4f       	sbci	r31, 0xFD	; 253
    262c:	86 5f       	subi	r24, 0xF6	; 246
    262e:	60 81       	ld	r22, Z
    2630:	20 91 1c 01 	lds	r18, 0x011C
    2634:	0e 94 95 07 	call	0xf2a	; 0xf2a <FWayneSendCommand>
		  TimSend=0;
    2638:	10 92 24 04 	sts	0x0424, r1
    263c:	10 92 23 04 	sts	0x0423, r1
          stPoolingPump=pwWaitAuthACK;
    2640:	83 e1       	ldi	r24, 0x13	; 19
    2642:	a0 c0       	rjmp	.+320    	; 0x2784 <FPoolingPump2+0x69a>
	      break;
     case pwWaitAuthACK:
	 	  //Timeout->NoPump		  
          if (TimSend>TPoolTimeout){
    2644:	80 91 b6 02 	lds	r24, 0x02B6
    2648:	90 e0       	ldi	r25, 0x00	; 0
    264a:	20 91 23 04 	lds	r18, 0x0423
    264e:	30 91 24 04 	lds	r19, 0x0424
    2652:	82 17       	cp	r24, r18
    2654:	93 07       	cpc	r25, r19
    2656:	18 f4       	brcc	.+6      	; 0x265e <FPoolingPump2+0x574>
		      stPoolingPump=pwRetrySendAuthorizeCommand;
    2658:	84 e1       	ldi	r24, 0x14	; 20
    265a:	80 93 31 01 	sts	0x0131, r24
		  }		  
	      //Acknowledge
	      if (WayneReply==WR_ACK){
    265e:	20 91 1a 01 	lds	r18, 0x011A
    2662:	22 30       	cpi	r18, 0x02	; 2
    2664:	09 f5       	brne	.+66     	; 0x26a8 <FPoolingPump2+0x5be>
		      iAuthCmd++;
    2666:	80 91 2e 01 	lds	r24, 0x012E
    266a:	8f 5f       	subi	r24, 0xFF	; 255
    266c:	80 93 2e 01 	sts	0x012E, r24
    2670:	90 91 17 01 	lds	r25, 0x0117
			  if (iAuthCmd>=4){//Complete ACK
    2674:	84 30       	cpi	r24, 0x04	; 4
    2676:	80 f0       	brcs	.+32     	; 0x2698 <FPoolingPump2+0x5ae>
			      PumpStatus[PumpAddr]=PW_AUTHORIZED;
    2678:	e0 91 05 01 	lds	r30, 0x0105
    267c:	f0 e0       	ldi	r31, 0x00	; 0
    267e:	eb 54       	subi	r30, 0x4B	; 75
    2680:	fc 4f       	sbci	r31, 0xFC	; 252
    2682:	89 e0       	ldi	r24, 0x09	; 9
    2684:	80 83       	st	Z, r24
				  IsRequestTransInfo[txPumpID]=True;
    2686:	e9 2f       	mov	r30, r25
    2688:	f0 e0       	ldi	r31, 0x00	; 0
    268a:	e6 57       	subi	r30, 0x76	; 118
    268c:	fd 4f       	sbci	r31, 0xFD	; 253
    268e:	81 e0       	ldi	r24, 0x01	; 1
    2690:	80 83       	st	Z, r24
			      stPoolingPump=pwScanStatus;
    2692:	20 93 31 01 	sts	0x0131, r18
    2696:	7b c0       	rjmp	.+246    	; 0x278e <FPoolingPump2+0x6a4>
			  }else {
			   CommandSeqID[txPumpID]++;
    2698:	e9 2f       	mov	r30, r25
    269a:	f0 e0       	ldi	r31, 0x00	; 0
    269c:	ee 57       	subi	r30, 0x7E	; 126
    269e:	fd 4f       	sbci	r31, 0xFD	; 253
    26a0:	80 81       	ld	r24, Z
    26a2:	8f 5f       	subi	r24, 0xFF	; 255
    26a4:	80 83       	st	Z, r24
    26a6:	16 c0       	rjmp	.+44     	; 0x26d4 <FPoolingPump2+0x5ea>
			   stPoolingPump=pwSendAuthorizeCommand;
			   }
		  }else if (WayneReply==WR_NACK){
    26a8:	80 91 1a 01 	lds	r24, 0x011A
    26ac:	83 30       	cpi	r24, 0x03	; 3
    26ae:	09 f0       	breq	.+2      	; 0x26b2 <FPoolingPump2+0x5c8>
    26b0:	6e c0       	rjmp	.+220    	; 0x278e <FPoolingPump2+0x6a4>
		      CommandSeqID[txPumpID]=0;
    26b2:	e0 91 17 01 	lds	r30, 0x0117
    26b6:	f0 e0       	ldi	r31, 0x00	; 0
    26b8:	ee 57       	subi	r30, 0x7E	; 126
    26ba:	fd 4f       	sbci	r31, 0xFD	; 253
    26bc:	10 82       	st	Z, r1
              stPoolingPump=pwRetrySendAuthorizeCommand;
    26be:	84 e1       	ldi	r24, 0x14	; 20
    26c0:	61 c0       	rjmp	.+194    	; 0x2784 <FPoolingPump2+0x69a>
		  }
	      break;
     case pwRetrySendAuthorizeCommand:
	      iSend++;
    26c2:	80 91 f9 03 	lds	r24, 0x03F9
    26c6:	8f 5f       	subi	r24, 0xFF	; 255
    26c8:	80 93 f9 03 	sts	0x03F9, r24
		  if (iSend<nSend)stPoolingPump=pwSendAuthorizeCommand;
    26cc:	90 91 77 02 	lds	r25, 0x0277
    26d0:	89 17       	cp	r24, r25
    26d2:	10 f4       	brcc	.+4      	; 0x26d8 <FPoolingPump2+0x5ee>
    26d4:	82 e1       	ldi	r24, 0x12	; 18
    26d6:	56 c0       	rjmp	.+172    	; 0x2784 <FPoolingPump2+0x69a>
		  else
		  if (iSend>=nSend)stPoolingPump=pwNoPump;
    26d8:	84 e0       	ldi	r24, 0x04	; 4
    26da:	54 c0       	rjmp	.+168    	; 0x2784 <FPoolingPump2+0x69a>
	 case pwSendGeneralStatus:
	      
	      break;
	 //Price Config	  
	 case pwSendPriceConfig:
	      stPoolingPump=pwWaitACK; 
    26dc:	86 e1       	ldi	r24, 0x16	; 22
    26de:	52 c0       	rjmp	.+164    	; 0x2784 <FPoolingPump2+0x69a>
	      break;
	 case pwWaitACK:
	      PumpStatus[PumpAddr]=PW_PRICE_UPDATED;
    26e0:	e0 91 05 01 	lds	r30, 0x0105
    26e4:	f0 e0       	ldi	r31, 0x00	; 0
    26e6:	eb 54       	subi	r30, 0x4B	; 75
    26e8:	fc 4f       	sbci	r31, 0xFC	; 252
    26ea:	8f e0       	ldi	r24, 0x0F	; 15
    26ec:	14 c0       	rjmp	.+40     	; 0x2716 <FPoolingPump2+0x62c>
		  stPoolingPump=pwUpdatePumpStatus;
          break;	 
	 //Acknowledge--------------
	 case pwReplyACK:
	      FWayneSendCommand(CMD_ACK,WayneRxSequence,txPumpID,0);
    26ee:	87 e0       	ldi	r24, 0x07	; 7
    26f0:	60 91 18 01 	lds	r22, 0x0118
    26f4:	40 91 17 01 	lds	r20, 0x0117
    26f8:	20 e0       	ldi	r18, 0x00	; 0
    26fa:	0e 94 95 07 	call	0xf2a	; 0xf2a <FWayneSendCommand>
		  stPoolingPump=pwScanMessage;
    26fe:	88 e1       	ldi	r24, 0x18	; 24
    2700:	41 c0       	rjmp	.+130    	; 0x2784 <FPoolingPump2+0x69a>
	      break;	 
	 case pwScanMessage:
	      if (PumpStatus[txPumpID]==PW_NONE){
    2702:	80 91 17 01 	lds	r24, 0x0117
    2706:	e8 2f       	mov	r30, r24
    2708:	f0 e0       	ldi	r31, 0x00	; 0
    270a:	eb 54       	subi	r30, 0x4B	; 75
    270c:	fc 4f       	sbci	r31, 0xFC	; 252
    270e:	80 81       	ld	r24, Z
    2710:	88 23       	and	r24, r24
    2712:	11 f4       	brne	.+4      	; 0x2718 <FPoolingPump2+0x62e>
			  PumpStatus[txPumpID]=PW_ONLINE;
    2714:	86 e0       	ldi	r24, 0x06	; 6
    2716:	80 83       	st	Z, r24
		  }		  
	      stPoolingPump=pwUpdatePumpStatus;
    2718:	85 e0       	ldi	r24, 0x05	; 5
    271a:	34 c0       	rjmp	.+104    	; 0x2784 <FPoolingPump2+0x69a>
	      break;		  
		  		 		  
     //Next Pump----------------
     case pwInitDelayNextPump:
	      TimDelayNextPump=0;
    271c:	10 92 22 01 	sts	0x0122, r1
    2720:	10 92 21 01 	sts	0x0121, r1
          stPoolingPump=pwDelayNextPump;
    2724:	8a e1       	ldi	r24, 0x1A	; 26
    2726:	2e c0       	rjmp	.+92     	; 0x2784 <FPoolingPump2+0x69a>
	      break;
     case pwDelayNextPump:
	      if (TimDelayNextPump>=TDelayNextPump)//20
    2728:	80 91 3c 01 	lds	r24, 0x013C
    272c:	90 e0       	ldi	r25, 0x00	; 0
    272e:	20 91 21 01 	lds	r18, 0x0121
    2732:	30 91 22 01 	lds	r19, 0x0122
    2736:	28 17       	cp	r18, r24
    2738:	39 07       	cpc	r19, r25
    273a:	48 f1       	brcs	.+82     	; 0x278e <FPoolingPump2+0x6a4>
    273c:	22 c0       	rjmp	.+68     	; 0x2782 <FPoolingPump2+0x698>
		      stPoolingPump=pwNextPump;
	      break;
     case pwNextPump:	      
          iPoolingID++;
    273e:	90 91 16 01 	lds	r25, 0x0116
    2742:	9f 5f       	subi	r25, 0xFF	; 255
    2744:	90 93 16 01 	sts	0x0116, r25
	      if (iPoolingID<ScanPumpMax){
    2748:	80 91 61 02 	lds	r24, 0x0261
    274c:	98 17       	cp	r25, r24
    274e:	e8 f4       	brcc	.+58     	; 0x278a <FPoolingPump2+0x6a0>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2750:	e1 99       	sbic	0x1c, 1	; 28
    2752:	fe cf       	rjmp	.-4      	; 0x2750 <FPoolingPump2+0x666>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2754:	89 2f       	mov	r24, r25
    2756:	90 e0       	ldi	r25, 0x00	; 0
    2758:	83 5f       	subi	r24, 0xF3	; 243
    275a:	9f 4f       	sbci	r25, 0xFF	; 255
    275c:	9f bb       	out	0x1f, r25	; 31
    275e:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2760:	e0 9a       	sbi	0x1c, 0	; 28
    2762:	8d b3       	in	r24, 0x1d	; 29
			  txPumpID=eeprom_read_byte(&DefPumpID[iPoolingID]);
    2764:	80 93 17 01 	sts	0x0117, r24
			  if (txPumpID>0){
    2768:	88 23       	and	r24, r24
    276a:	59 f0       	breq	.+22     	; 0x2782 <FPoolingPump2+0x698>
			      txPumpID=txPumpID-1;
    276c:	81 50       	subi	r24, 0x01	; 1
    276e:	80 93 17 01 	sts	0x0117, r24
			      iSend=0;TimSend=0;
    2772:	10 92 f9 03 	sts	0x03F9, r1
    2776:	10 92 24 04 	sts	0x0424, r1
    277a:	10 92 23 04 	sts	0x0423, r1
			      stPoolingPump=pwScanStatus;
    277e:	82 e0       	ldi	r24, 0x02	; 2
    2780:	01 c0       	rjmp	.+2      	; 0x2784 <FPoolingPump2+0x69a>
			   }else stPoolingPump=pwNextPump;
    2782:	8b e1       	ldi	r24, 0x1B	; 27
    2784:	80 93 31 01 	sts	0x0131, r24
    2788:	02 c0       	rjmp	.+4      	; 0x278e <FPoolingPump2+0x6a4>
		  } else stPoolingPump=pwInit;//pwInitPumpAddr;
    278a:	10 92 31 01 	sts	0x0131, r1
		  #endif
		  
		  //stPoolingPump=pwInitPumpAddr;
	      break;
	 }
}
    278e:	6e 96       	adiw	r28, 0x1e	; 30
    2790:	0f b6       	in	r0, 0x3f	; 63
    2792:	f8 94       	cli
    2794:	de bf       	out	0x3e, r29	; 62
    2796:	0f be       	out	0x3f, r0	; 63
    2798:	cd bf       	out	0x3d, r28	; 61
    279a:	cf 91       	pop	r28
    279c:	df 91       	pop	r29
    279e:	1f 91       	pop	r17
    27a0:	0f 91       	pop	r16
    27a2:	ff 90       	pop	r15
    27a4:	ef 90       	pop	r14
    27a6:	df 90       	pop	r13
    27a8:	cf 90       	pop	r12
    27aa:	af 90       	pop	r10
    27ac:	08 95       	ret

000027ae <TerminalSend>:
       while(pgm_read_byte(&(*strSendf)))
	         _uart(Com, 1, pgm_read_byte(&(*strSendf++)));
	}
}

void TerminalSend(char Com,char *strSend){
    27ae:	28 2f       	mov	r18, r24
    27b0:	ab 01       	movw	r20, r22
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    27b2:	e1 99       	sbic	0x1c, 1	; 28
    27b4:	fe cf       	rjmp	.-4      	; 0x27b2 <TerminalSend+0x4>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    27b6:	84 e0       	ldi	r24, 0x04	; 4
    27b8:	90 e0       	ldi	r25, 0x00	; 0
    27ba:	9f bb       	out	0x1f, r25	; 31
    27bc:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    27be:	e0 9a       	sbi	0x1c, 0	; 28
    27c0:	8d b3       	in	r24, 0x1d	; 29
   if (eeprom_read_byte(&DefTerminalDebug)){
    27c2:	88 23       	and	r24, r24
    27c4:	21 f0       	breq	.+8      	; 0x27ce <TerminalSend+0x20>
       _uart_print(Com,1,strSend);
    27c6:	82 2f       	mov	r24, r18
    27c8:	61 e0       	ldi	r22, 0x01	; 1
    27ca:	0e 94 6f 18 	call	0x30de	; 0x30de <_uart_print>
    27ce:	08 95       	ret

000027d0 <SystemSetSlave>:

return Result;
}

void SystemSetSlave(){
     SystemComLevel(CL_232);
    27d0:	81 e0       	ldi	r24, 0x01	; 1
    27d2:	0e 94 61 01 	call	0x2c2	; 0x2c2 <SystemComLevel>
     //_uart_setting(1,GetBaudrate(eeprom_read_byte(&DefBaudrate[1])),8,P_NONE,1);
	 _uart_init(0,9600);	
    27d6:	80 e0       	ldi	r24, 0x00	; 0
    27d8:	40 e8       	ldi	r20, 0x80	; 128
    27da:	55 e2       	ldi	r21, 0x25	; 37
    27dc:	60 e0       	ldi	r22, 0x00	; 0
    27de:	70 e0       	ldi	r23, 0x00	; 0
    27e0:	0e 94 2c 18 	call	0x3058	; 0x3058 <_uart_init>
	 _uart_init(1,9600);	
    27e4:	81 e0       	ldi	r24, 0x01	; 1
    27e6:	40 e8       	ldi	r20, 0x80	; 128
    27e8:	55 e2       	ldi	r21, 0x25	; 37
    27ea:	60 e0       	ldi	r22, 0x00	; 0
    27ec:	70 e0       	ldi	r23, 0x00	; 0
    27ee:	0e 94 2c 18 	call	0x3058	; 0x3058 <_uart_init>
}
    27f2:	08 95       	ret

000027f4 <SystemSetDispenser>:

//enum eBaudRateValue{brNone,br9600,br19200,br5787};

void SystemSetDispenser(char TDispenserBrand){
    27f4:	ef 92       	push	r14
    27f6:	0f 93       	push	r16
     unsigned int brValue;

	 switch(TDispenserBrand){
    27f8:	81 30       	cpi	r24, 0x01	; 1
    27fa:	99 f1       	breq	.+102    	; 0x2862 <SystemSetDispenser+0x6e>
    27fc:	81 30       	cpi	r24, 0x01	; 1
    27fe:	38 f0       	brcs	.+14     	; 0x280e <SystemSetDispenser+0x1a>
    2800:	82 30       	cpi	r24, 0x02	; 2
    2802:	09 f4       	brne	.+2      	; 0x2806 <SystemSetDispenser+0x12>
    2804:	55 c0       	rjmp	.+170    	; 0x28b0 <SystemSetDispenser+0xbc>
    2806:	83 30       	cpi	r24, 0x03	; 3
    2808:	09 f0       	breq	.+2      	; 0x280c <SystemSetDispenser+0x18>
    280a:	b1 c0       	rjmp	.+354    	; 0x296e <SystemSetDispenser+0x17a>
    280c:	7f c0       	rjmp	.+254    	; 0x290c <SystemSetDispenser+0x118>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    280e:	e1 99       	sbic	0x1c, 1	; 28
    2810:	fe cf       	rjmp	.-4      	; 0x280e <SystemSetDispenser+0x1a>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2812:	85 e0       	ldi	r24, 0x05	; 5
    2814:	90 e0       	ldi	r25, 0x00	; 0
    2816:	9f bb       	out	0x1f, r25	; 31
    2818:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    281a:	e0 9a       	sbi	0x1c, 0	; 28
    281c:	8d b3       	in	r24, 0x1d	; 29
     //IFType=IT_SLAVE;
}

int GetBaudrate(char brSetting){
int Result=0;
     switch(brSetting){
    281e:	82 30       	cpi	r24, 0x02	; 2
    2820:	59 f0       	breq	.+22     	; 0x2838 <SystemSetDispenser+0x44>
    2822:	82 30       	cpi	r24, 0x02	; 2
    2824:	18 f0       	brcs	.+6      	; 0x282c <SystemSetDispenser+0x38>
    2826:	83 30       	cpi	r24, 0x03	; 3
    2828:	21 f4       	brne	.+8      	; 0x2832 <SystemSetDispenser+0x3e>
    282a:	09 c0       	rjmp	.+18     	; 0x283e <SystemSetDispenser+0x4a>
    282c:	80 e8       	ldi	r24, 0x80	; 128
    282e:	95 e2       	ldi	r25, 0x25	; 37
    2830:	08 c0       	rjmp	.+16     	; 0x2842 <SystemSetDispenser+0x4e>
    2832:	80 e0       	ldi	r24, 0x00	; 0
    2834:	90 e0       	ldi	r25, 0x00	; 0
    2836:	05 c0       	rjmp	.+10     	; 0x2842 <SystemSetDispenser+0x4e>
    2838:	80 e0       	ldi	r24, 0x00	; 0
    283a:	9b e4       	ldi	r25, 0x4B	; 75
    283c:	02 c0       	rjmp	.+4      	; 0x2842 <SystemSetDispenser+0x4e>
    283e:	8b e9       	ldi	r24, 0x9B	; 155
    2840:	96 e1       	ldi	r25, 0x16	; 22
void SystemSetDispenser(char TDispenserBrand){
     unsigned int brValue;

	 switch(TDispenserBrand){
	 case ST_NONE:
	      _uart_setting(0,GetBaudrate(eeprom_read_byte(&DefBaudrate[0])),8,P_NONE,1);
    2842:	ac 01       	movw	r20, r24
    2844:	66 27       	eor	r22, r22
    2846:	57 fd       	sbrc	r21, 7
    2848:	60 95       	com	r22
    284a:	76 2f       	mov	r23, r22
    284c:	80 e0       	ldi	r24, 0x00	; 0
    284e:	28 e0       	ldi	r18, 0x08	; 8
    2850:	00 e0       	ldi	r16, 0x00	; 0
    2852:	ee 24       	eor	r14, r14
    2854:	e3 94       	inc	r14
    2856:	0e 94 97 17 	call	0x2f2e	; 0x2f2e <_uart_setting>
          SystemComLevel(CL_232);
    285a:	81 e0       	ldi	r24, 0x01	; 1
    285c:	0e 94 61 01 	call	0x2c2	; 0x2c2 <SystemComLevel>
    2860:	86 c0       	rjmp	.+268    	; 0x296e <SystemSetDispenser+0x17a>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2862:	e1 99       	sbic	0x1c, 1	; 28
    2864:	fe cf       	rjmp	.-4      	; 0x2862 <SystemSetDispenser+0x6e>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2866:	8e e1       	ldi	r24, 0x1E	; 30
    2868:	90 e0       	ldi	r25, 0x00	; 0
    286a:	9f bb       	out	0x1f, r25	; 31
    286c:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    286e:	e0 9a       	sbi	0x1c, 0	; 28
    2870:	8d b3       	in	r24, 0x1d	; 29
	      break;
	 case ST_GILBARCO:
	      if (eeprom_read_byte(&DefHGMode)==HM_TTL)
    2872:	81 11       	cpse	r24, r1
		       SystemComLevel(CL_TTL);
		  else SystemComLevel(CL_232);
    2874:	81 e0       	ldi	r24, 0x01	; 1
    2876:	0e 94 61 01 	call	0x2c2	; 0x2c2 <SystemComLevel>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    287a:	e1 99       	sbic	0x1c, 1	; 28
    287c:	fe cf       	rjmp	.-4      	; 0x287a <SystemSetDispenser+0x86>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    287e:	25 e0       	ldi	r18, 0x05	; 5
    2880:	30 e0       	ldi	r19, 0x00	; 0
    2882:	3f bb       	out	0x1f, r19	; 31
    2884:	2e bb       	out	0x1e, r18	; 30
#endif
    EEDR = __value;
    2886:	83 e0       	ldi	r24, 0x03	; 3
    2888:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    288a:	0f b6       	in	r0, 0x3f	; 63
    288c:	f8 94       	cli
    288e:	e2 9a       	sbi	0x1c, 2	; 28
    2890:	e1 9a       	sbi	0x1c, 1	; 28
    2892:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2894:	e1 99       	sbic	0x1c, 1	; 28
    2896:	fe cf       	rjmp	.-4      	; 0x2894 <SystemSetDispenser+0xa0>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2898:	3f bb       	out	0x1f, r19	; 31
    289a:	2e bb       	out	0x1e, r18	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    289c:	e0 9a       	sbi	0x1c, 0	; 28
    289e:	8d b3       	in	r24, 0x1d	; 29
	      
		  eeprom_write_byte(&DefBaudrate[0],br5787);
		  brValue=GetBaudrate(eeprom_read_byte(&DefBaudrate[0]));
	      //_uart_setting(0,brValue,8,P_NONE,1);
		  
          _uart_init(0,5787);
    28a0:	80 e0       	ldi	r24, 0x00	; 0
    28a2:	4b e9       	ldi	r20, 0x9B	; 155
    28a4:	56 e1       	ldi	r21, 0x16	; 22
    28a6:	60 e0       	ldi	r22, 0x00	; 0
    28a8:	70 e0       	ldi	r23, 0x00	; 0
    28aa:	0e 94 2c 18 	call	0x3058	; 0x3058 <_uart_init>
    28ae:	5f c0       	rjmp	.+190    	; 0x296e <SystemSetDispenser+0x17a>
	      break;
	 case ST_WAYNE_DART:		       
	 	  SystemComLevel(CL_485);
    28b0:	82 e0       	ldi	r24, 0x02	; 2
    28b2:	0e 94 61 01 	call	0x2c2	; 0x2c2 <SystemComLevel>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    28b6:	e1 99       	sbic	0x1c, 1	; 28
    28b8:	fe cf       	rjmp	.-4      	; 0x28b6 <SystemSetDispenser+0xc2>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    28ba:	25 e0       	ldi	r18, 0x05	; 5
    28bc:	30 e0       	ldi	r19, 0x00	; 0
    28be:	3f bb       	out	0x1f, r19	; 31
    28c0:	2e bb       	out	0x1e, r18	; 30
#endif
    EEDR = __value;
    28c2:	81 e0       	ldi	r24, 0x01	; 1
    28c4:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    28c6:	0f b6       	in	r0, 0x3f	; 63
    28c8:	f8 94       	cli
    28ca:	e2 9a       	sbi	0x1c, 2	; 28
    28cc:	e1 9a       	sbi	0x1c, 1	; 28
    28ce:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    28d0:	e1 99       	sbic	0x1c, 1	; 28
    28d2:	fe cf       	rjmp	.-4      	; 0x28d0 <SystemSetDispenser+0xdc>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    28d4:	3f bb       	out	0x1f, r19	; 31
    28d6:	2e bb       	out	0x1e, r18	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    28d8:	e0 9a       	sbi	0x1c, 0	; 28
    28da:	8d b3       	in	r24, 0x1d	; 29
     //IFType=IT_SLAVE;
}

int GetBaudrate(char brSetting){
int Result=0;
     switch(brSetting){
    28dc:	82 30       	cpi	r24, 0x02	; 2
    28de:	59 f0       	breq	.+22     	; 0x28f6 <SystemSetDispenser+0x102>
    28e0:	82 30       	cpi	r24, 0x02	; 2
    28e2:	18 f0       	brcs	.+6      	; 0x28ea <SystemSetDispenser+0xf6>
    28e4:	83 30       	cpi	r24, 0x03	; 3
    28e6:	21 f4       	brne	.+8      	; 0x28f0 <SystemSetDispenser+0xfc>
    28e8:	09 c0       	rjmp	.+18     	; 0x28fc <SystemSetDispenser+0x108>
    28ea:	40 e8       	ldi	r20, 0x80	; 128
    28ec:	55 e2       	ldi	r21, 0x25	; 37
    28ee:	08 c0       	rjmp	.+16     	; 0x2900 <SystemSetDispenser+0x10c>
    28f0:	40 e0       	ldi	r20, 0x00	; 0
    28f2:	50 e0       	ldi	r21, 0x00	; 0
    28f4:	05 c0       	rjmp	.+10     	; 0x2900 <SystemSetDispenser+0x10c>
    28f6:	40 e0       	ldi	r20, 0x00	; 0
    28f8:	5b e4       	ldi	r21, 0x4B	; 75
    28fa:	02 c0       	rjmp	.+4      	; 0x2900 <SystemSetDispenser+0x10c>
    28fc:	4b e9       	ldi	r20, 0x9B	; 155
    28fe:	56 e1       	ldi	r21, 0x16	; 22
	      break;
	 case ST_WAYNE_DART:		       
	 	  SystemComLevel(CL_485);
          eeprom_write_byte(&DefBaudrate[0],br9600);
		  brValue=GetBaudrate(eeprom_read_byte(&DefBaudrate[0]));
	      _uart_setting(0,brValue,8,P_ODD,1);
    2900:	60 e0       	ldi	r22, 0x00	; 0
    2902:	70 e0       	ldi	r23, 0x00	; 0
    2904:	80 e0       	ldi	r24, 0x00	; 0
    2906:	28 e0       	ldi	r18, 0x08	; 8
    2908:	01 e0       	ldi	r16, 0x01	; 1
    290a:	2d c0       	rjmp	.+90     	; 0x2966 <SystemSetDispenser+0x172>
	      break;
	 case ST_TATSUNO:
	 	  SystemComLevel(CL_485);
    290c:	82 e0       	ldi	r24, 0x02	; 2
    290e:	0e 94 61 01 	call	0x2c2	; 0x2c2 <SystemComLevel>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    2912:	e1 99       	sbic	0x1c, 1	; 28
    2914:	fe cf       	rjmp	.-4      	; 0x2912 <SystemSetDispenser+0x11e>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2916:	25 e0       	ldi	r18, 0x05	; 5
    2918:	30 e0       	ldi	r19, 0x00	; 0
    291a:	3f bb       	out	0x1f, r19	; 31
    291c:	2e bb       	out	0x1e, r18	; 30
#endif
    EEDR = __value;
    291e:	81 e0       	ldi	r24, 0x01	; 1
    2920:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    2922:	0f b6       	in	r0, 0x3f	; 63
    2924:	f8 94       	cli
    2926:	e2 9a       	sbi	0x1c, 2	; 28
    2928:	e1 9a       	sbi	0x1c, 1	; 28
    292a:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    292c:	e1 99       	sbic	0x1c, 1	; 28
    292e:	fe cf       	rjmp	.-4      	; 0x292c <SystemSetDispenser+0x138>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2930:	3f bb       	out	0x1f, r19	; 31
    2932:	2e bb       	out	0x1e, r18	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2934:	e0 9a       	sbi	0x1c, 0	; 28
    2936:	8d b3       	in	r24, 0x1d	; 29
     //IFType=IT_SLAVE;
}

int GetBaudrate(char brSetting){
int Result=0;
     switch(brSetting){
    2938:	82 30       	cpi	r24, 0x02	; 2
    293a:	59 f0       	breq	.+22     	; 0x2952 <SystemSetDispenser+0x15e>
    293c:	82 30       	cpi	r24, 0x02	; 2
    293e:	18 f0       	brcs	.+6      	; 0x2946 <SystemSetDispenser+0x152>
    2940:	83 30       	cpi	r24, 0x03	; 3
    2942:	21 f4       	brne	.+8      	; 0x294c <SystemSetDispenser+0x158>
    2944:	09 c0       	rjmp	.+18     	; 0x2958 <SystemSetDispenser+0x164>
    2946:	40 e8       	ldi	r20, 0x80	; 128
    2948:	55 e2       	ldi	r21, 0x25	; 37
    294a:	08 c0       	rjmp	.+16     	; 0x295c <SystemSetDispenser+0x168>
    294c:	40 e0       	ldi	r20, 0x00	; 0
    294e:	50 e0       	ldi	r21, 0x00	; 0
    2950:	05 c0       	rjmp	.+10     	; 0x295c <SystemSetDispenser+0x168>
    2952:	40 e0       	ldi	r20, 0x00	; 0
    2954:	5b e4       	ldi	r21, 0x4B	; 75
    2956:	02 c0       	rjmp	.+4      	; 0x295c <SystemSetDispenser+0x168>
    2958:	4b e9       	ldi	r20, 0x9B	; 155
    295a:	56 e1       	ldi	r21, 0x16	; 22
	      break;
	 case ST_TATSUNO:
	 	  SystemComLevel(CL_485);
          eeprom_write_byte(&DefBaudrate[0],br9600);
		  brValue=GetBaudrate(eeprom_read_byte(&DefBaudrate[0]));
	      _uart_setting(0,brValue,8,P_EVEN,1);
    295c:	60 e0       	ldi	r22, 0x00	; 0
    295e:	70 e0       	ldi	r23, 0x00	; 0
    2960:	80 e0       	ldi	r24, 0x00	; 0
    2962:	28 e0       	ldi	r18, 0x08	; 8
    2964:	02 e0       	ldi	r16, 0x02	; 2
    2966:	ee 24       	eor	r14, r14
    2968:	e3 94       	inc	r14
    296a:	0e 94 97 17 	call	0x2f2e	; 0x2f2e <_uart_setting>
	      break;
	 case ST_LG:
	      break;			  
	 }
	 InitPumpData();
    296e:	0e 94 cd 01 	call	0x39a	; 0x39a <InitPumpData>
}
    2972:	0f 91       	pop	r16
    2974:	ef 90       	pop	r14
    2976:	08 95       	ret

00002978 <SystemInit>:
	      break;	 
	 }
}

void SystemInit(){
	PORTA=0xFF;	DDRA=0xFF;
    2978:	9f ef       	ldi	r25, 0xFF	; 255
    297a:	9b bb       	out	0x1b, r25	; 27
    297c:	9a bb       	out	0x1a, r25	; 26
	PORTE=0xFF;	DDRE=0xFF;
    297e:	97 b9       	out	0x07, r25	; 7
    2980:	96 b9       	out	0x06, r25	; 6
	DDRB= 0b01001111;//SPI Slave Input Pin-->SCK,MOSI
    2982:	8f e4       	ldi	r24, 0x4F	; 79
    2984:	87 bb       	out	0x17, r24	; 23
	PORTB=0b11111111;
    2986:	98 bb       	out	0x18, r25	; 24
	DDRD=0x00;PORTD=0b11111111;
    2988:	11 ba       	out	0x11, r1	; 17
    298a:	92 bb       	out	0x12, r25	; 18
	//Slave 128_SS_High
    sbi(DDRD,2);sbi(PORTD,2);
    298c:	8a 9a       	sbi	0x11, 2	; 17
    298e:	92 9a       	sbi	0x12, 2	; 18
	_spi_init(0,1);
    2990:	80 e0       	ldi	r24, 0x00	; 0
    2992:	61 e0       	ldi	r22, 0x01	; 1
    2994:	0e 94 6c 17 	call	0x2ed8	; 0x2ed8 <_spi_init>
     sei();
	 */
}

void InitSystemTimer(){
	TCCR0 |= (1 << CS02) | (1 << CS00);
    2998:	83 b7       	in	r24, 0x33	; 51
    299a:	85 60       	ori	r24, 0x05	; 5
    299c:	83 bf       	out	0x33, r24	; 51
	TIMSK |= _BV(TOIE0);
    299e:	89 b7       	in	r24, 0x39	; 57
    29a0:	82 60       	ori	r24, 0x02	; 2
    29a2:	89 bf       	out	0x39, r24	; 57
	DDRD=0x00;PORTD=0b11111111;
	//Slave 128_SS_High
    sbi(DDRD,2);sbi(PORTD,2);
	_spi_init(0,1);
	InitSystemTimer();
	sei();
    29a4:	78 94       	sei
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    29a6:	e1 99       	sbic	0x1c, 1	; 28
    29a8:	fe cf       	rjmp	.-4      	; 0x29a6 <SystemInit+0x2e>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    29aa:	86 e0       	ldi	r24, 0x06	; 6
    29ac:	90 e0       	ldi	r25, 0x00	; 0
    29ae:	9f bb       	out	0x1f, r25	; 31
    29b0:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    29b2:	e0 9a       	sbi	0x1c, 0	; 28
    29b4:	8d b3       	in	r24, 0x1d	; 29
     //IFType=IT_SLAVE;
}

int GetBaudrate(char brSetting){
int Result=0;
     switch(brSetting){
    29b6:	82 30       	cpi	r24, 0x02	; 2
    29b8:	59 f0       	breq	.+22     	; 0x29d0 <SystemInit+0x58>
    29ba:	82 30       	cpi	r24, 0x02	; 2
    29bc:	18 f0       	brcs	.+6      	; 0x29c4 <SystemInit+0x4c>
    29be:	83 30       	cpi	r24, 0x03	; 3
    29c0:	21 f4       	brne	.+8      	; 0x29ca <SystemInit+0x52>
    29c2:	09 c0       	rjmp	.+18     	; 0x29d6 <SystemInit+0x5e>
    29c4:	80 e8       	ldi	r24, 0x80	; 128
    29c6:	95 e2       	ldi	r25, 0x25	; 37
    29c8:	08 c0       	rjmp	.+16     	; 0x29da <SystemInit+0x62>
    29ca:	80 e0       	ldi	r24, 0x00	; 0
    29cc:	90 e0       	ldi	r25, 0x00	; 0
    29ce:	05 c0       	rjmp	.+10     	; 0x29da <SystemInit+0x62>
    29d0:	80 e0       	ldi	r24, 0x00	; 0
    29d2:	9b e4       	ldi	r25, 0x4B	; 75
    29d4:	02 c0       	rjmp	.+4      	; 0x29da <SystemInit+0x62>
    29d6:	8b e9       	ldi	r24, 0x9B	; 155
    29d8:	96 e1       	ldi	r25, 0x16	; 22
	//Slave 128_SS_High
    sbi(DDRD,2);sbi(PORTD,2);
	_spi_init(0,1);
	InitSystemTimer();
	sei();
	_uart_init(1,GetBaudrate(eeprom_read_byte(&DefBaudrate[1])));
    29da:	ac 01       	movw	r20, r24
    29dc:	66 27       	eor	r22, r22
    29de:	57 fd       	sbrc	r21, 7
    29e0:	60 95       	com	r22
    29e2:	76 2f       	mov	r23, r22
    29e4:	81 e0       	ldi	r24, 0x01	; 1
    29e6:	0e 94 2c 18 	call	0x3058	; 0x3058 <_uart_init>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    29ea:	e1 99       	sbic	0x1c, 1	; 28
    29ec:	fe cf       	rjmp	.-4      	; 0x29ea <SystemInit+0x72>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    29ee:	80 e0       	ldi	r24, 0x00	; 0
    29f0:	90 e0       	ldi	r25, 0x00	; 0
    29f2:	9f bb       	out	0x1f, r25	; 31
    29f4:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    29f6:	e0 9a       	sbi	0x1c, 0	; 28
    29f8:	8d b3       	in	r24, 0x1d	; 29
    IFType=eeprom_read_byte(&DefIFType);
    29fa:	80 93 00 01 	sts	0x0100, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    29fe:	e1 99       	sbic	0x1c, 1	; 28
    2a00:	fe cf       	rjmp	.-4      	; 0x29fe <SystemInit+0x86>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2a02:	8c e0       	ldi	r24, 0x0C	; 12
    2a04:	90 e0       	ldi	r25, 0x00	; 0
    2a06:	9f bb       	out	0x1f, r25	; 31
    2a08:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2a0a:	e0 9a       	sbi	0x1c, 0	; 28
    2a0c:	8d b3       	in	r24, 0x1d	; 29
    SequenceTimeout=eeprom_read_byte(&DefSequenceTimeout);
    2a0e:	80 93 36 04 	sts	0x0436, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2a12:	e1 99       	sbic	0x1c, 1	; 28
    2a14:	fe cf       	rjmp	.-4      	; 0x2a12 <SystemInit+0x9a>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2a16:	83 e0       	ldi	r24, 0x03	; 3
    2a18:	90 e0       	ldi	r25, 0x00	; 0
    2a1a:	9f bb       	out	0x1f, r25	; 31
    2a1c:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2a1e:	e0 9a       	sbi	0x1c, 0	; 28
    2a20:	8d b3       	in	r24, 0x1d	; 29
	MaxPumpScanned=eeprom_read_byte(&DefPumpMaxCount);		
    2a22:	80 93 25 01 	sts	0x0125, r24

	switch(IFType){
    2a26:	80 91 00 01 	lds	r24, 0x0100
    2a2a:	81 30       	cpi	r24, 0x01	; 1
    2a2c:	19 f0       	breq	.+6      	; 0x2a34 <SystemInit+0xbc>
    2a2e:	82 30       	cpi	r24, 0x02	; 2
    2a30:	c1 f4       	brne	.+48     	; 0x2a62 <SystemInit+0xea>
    2a32:	06 c0       	rjmp	.+12     	; 0x2a40 <SystemInit+0xc8>
	case IT_SLAVE:
	     BlinkRate=20;
    2a34:	84 e1       	ldi	r24, 0x14	; 20
    2a36:	80 93 11 04 	sts	0x0411, r24
	     SystemSetSlave();
    2a3a:	0e 94 e8 13 	call	0x27d0	; 0x27d0 <SystemSetSlave>
    2a3e:	11 c0       	rjmp	.+34     	; 0x2a62 <SystemInit+0xea>
	     break;
	case IT_STANDALONE:
	     BlinkRate=5;
    2a40:	85 e0       	ldi	r24, 0x05	; 5
    2a42:	80 93 11 04 	sts	0x0411, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2a46:	e1 99       	sbic	0x1c, 1	; 28
    2a48:	fe cf       	rjmp	.-4      	; 0x2a46 <SystemInit+0xce>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2a4a:	81 e0       	ldi	r24, 0x01	; 1
    2a4c:	90 e0       	ldi	r25, 0x00	; 0
    2a4e:	9f bb       	out	0x1f, r25	; 31
    2a50:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2a52:	e0 9a       	sbi	0x1c, 0	; 28
    2a54:	8d b3       	in	r24, 0x1d	; 29
		 StandaloneType=eeprom_read_byte(&DefStandaloneType);
    2a56:	80 93 01 01 	sts	0x0101, r24
         SystemSetDispenser(StandaloneType);
    2a5a:	80 91 01 01 	lds	r24, 0x0101
    2a5e:	0e 94 fa 13 	call	0x27f4	; 0x27f4 <SystemSetDispenser>
	     break;	
	}
	InitPumpData();
    2a62:	0e 94 cd 01 	call	0x39a	; 0x39a <InitPumpData>
	IsStopPoolSequence=False;
    2a66:	10 92 13 01 	sts	0x0113, r1
	 }Dest[Length]=0;
}


void StartupInfo(){
    _uart_printf(1,1,PSTR("Initialized"));
    2a6a:	81 e0       	ldi	r24, 0x01	; 1
    2a6c:	61 e0       	ldi	r22, 0x01	; 1
    2a6e:	4c e2       	ldi	r20, 0x2C	; 44
    2a70:	51 e0       	ldi	r21, 0x01	; 1
    2a72:	0e 94 97 18 	call	0x312e	; 0x312e <_uart_printf>
	     break;	
	}
	InitPumpData();
	IsStopPoolSequence=False;
	StartupInfo();
	System485(DIR_RX);//ReceiveMode
    2a76:	82 e0       	ldi	r24, 0x02	; 2
    2a78:	0e 94 9c 01 	call	0x338	; 0x338 <System485>
}
    2a7c:	08 95       	ret

00002a7e <main>:
	 if (IFType==IT_SLAVE)//EDC Line Protocol
	    _uart(0,1,dataSPI);
	 ScanStandaloneFlow(dataSPI);	 
}

void main (){
    2a7e:	1f 93       	push	r17
	SystemInit();
    2a80:	0e 94 bc 14 	call	0x2978	; 0x2978 <SystemInit>
		    TimWatchSequence=0;
		}
        if (TimWatchSequence>SequenceTimeout){
		    TimWatchSequence=0; 
		    //SendAcknoledge(SC_FREEZE,SequenceTimeout);
		    IsRestartPooling=True;
    2a84:	11 e0       	ldi	r17, 0x01	; 1

void systemAntiFreeze(){
static char zSequence=0;

	if (IFType==IT_STANDALONE){
	    if (SequencePool>zSequence){
    2a86:	30 91 26 01 	lds	r19, 0x0126
		    TimWatchSequence=0;
		}
        if (TimWatchSequence>SequenceTimeout){
    2a8a:	40 91 36 04 	lds	r20, 0x0436
    2a8e:	20 91 de 02 	lds	r18, 0x02DE
    2a92:	90 91 35 01 	lds	r25, 0x0135
	SystemInit();

   // SystemComLevel(CL_232);
	//_uart_init(0,5787);
	while(1){	   
	   switch(IFType){
    2a96:	80 91 00 01 	lds	r24, 0x0100
    2a9a:	82 30       	cpi	r24, 0x02	; 2
    2a9c:	e1 f7       	brne	.-8      	; 0x2a96 <main+0x18>
//15694 95.8% -> 14746 90.0%

void systemAntiFreeze(){
static char zSequence=0;

	if (IFType==IT_STANDALONE){
    2a9e:	80 91 00 01 	lds	r24, 0x0100
    2aa2:	82 30       	cpi	r24, 0x02	; 2
    2aa4:	41 f4       	brne	.+16     	; 0x2ab6 <main+0x38>
	    if (SequencePool>zSequence){
    2aa6:	93 17       	cp	r25, r19
    2aa8:	20 f0       	brcs	.+8      	; 0x2ab2 <main+0x34>
		    TimWatchSequence=0;
		}
        if (TimWatchSequence>SequenceTimeout){
    2aaa:	42 17       	cp	r20, r18
    2aac:	18 f4       	brcc	.+6      	; 0x2ab4 <main+0x36>
		    TimWatchSequence=0; 
		    //SendAcknoledge(SC_FREEZE,SequenceTimeout);
		    IsRestartPooling=True;
    2aae:	10 93 03 01 	sts	0x0103, r17
    2ab2:	20 e0       	ldi	r18, 0x00	; 0
    2ab4:	93 2f       	mov	r25, r19
	   switch(IFType){
	   case IT_SLAVE:
	        break;
	   case IT_STANDALONE:
	        systemAntiFreeze();//15714 15724			
			switch(StandaloneType){
    2ab6:	80 91 01 01 	lds	r24, 0x0101
    2aba:	81 30       	cpi	r24, 0x01	; 1
    2abc:	19 f0       	breq	.+6      	; 0x2ac4 <main+0x46>
    2abe:	82 30       	cpi	r24, 0x02	; 2
    2ac0:	51 f7       	brne	.-44     	; 0x2a96 <main+0x18>
    2ac2:	07 c0       	rjmp	.+14     	; 0x2ad2 <main+0x54>
    2ac4:	20 93 de 02 	sts	0x02DE, r18
    2ac8:	90 93 35 01 	sts	0x0135, r25
			case ST_GILBARCO:
			     FPoolingPump();
    2acc:	0e 94 71 0d 	call	0x1ae2	; 0x1ae2 <FPoolingPump>
    2ad0:	da cf       	rjmp	.-76     	; 0x2a86 <main+0x8>
			     break;
    2ad2:	20 93 de 02 	sts	0x02DE, r18
    2ad6:	90 93 35 01 	sts	0x0135, r25
            case ST_WAYNE_DART:
                 FPoolingPump2(); 
    2ada:	0e 94 75 10 	call	0x20ea	; 0x20ea <FPoolingPump2>
    2ade:	d3 cf       	rjmp	.-90     	; 0x2a86 <main+0x8>

00002ae0 <ScanStandaloneFlow>:
     	  break;	 
	 }
   return Result;
}

void ScanStandaloneFlow(char xData){//<STX>[CMD][MSG]<ETX>: 0x05 0x06
    2ae0:	0f 93       	push	r16
    2ae2:	1f 93       	push	r17
    2ae4:	df 93       	push	r29
    2ae6:	cf 93       	push	r28
    2ae8:	cd b7       	in	r28, 0x3d	; 61
    2aea:	de b7       	in	r29, 0x3e	; 62
    2aec:	64 97       	sbiw	r28, 0x14	; 20
    2aee:	0f b6       	in	r0, 0x3f	; 63
    2af0:	f8 94       	cli
    2af2:	de bf       	out	0x3e, r29	; 62
    2af4:	0f be       	out	0x3f, r0	; 63
    2af6:	cd bf       	out	0x3d, r28	; 61
     char slaveCmd,slaveMsg;        //            0x02:STANDALONE  		 0x00:NONE 0x01:GILBARCO 0x02:TATSUNO 0x03:LG 0x04:WYNE
     char ComPort,ComBaud,i;          //          0x03:DIAGNOSTIC
	 unsigned int brValue;
	 char strSend[20];
     slaveCmd=0;slaveMsg=0;         //            0x04:Totalizer
	 zFlowData[3]=zFlowData[2];     //            0x05:Baudrate
    2af8:	90 91 38 01 	lds	r25, 0x0138
    2afc:	90 93 39 01 	sts	0x0139, r25
	 zFlowData[2]=zFlowData[1];     //            0x06:DebugTerminal:-->dtOn/dtOff
    2b00:	00 91 37 01 	lds	r16, 0x0137
    2b04:	00 93 38 01 	sts	0x0138, r16
	 zFlowData[1]=zFlowData[0];
    2b08:	10 91 36 01 	lds	r17, 0x0136
    2b0c:	10 93 37 01 	sts	0x0137, r17
	 zFlowData[0]=xData;
    2b10:	80 93 36 01 	sts	0x0136, r24
	 //Scan SatndaloneMode Switch Command
	 if((zFlowData[0]==0x06)&(zFlowData[3]==0x05)){
    2b14:	86 30       	cpi	r24, 0x06	; 6
    2b16:	09 f0       	breq	.+2      	; 0x2b1a <ScanStandaloneFlow+0x3a>
    2b18:	a3 c1       	rjmp	.+838    	; 0x2e60 <ScanStandaloneFlow+0x380>
    2b1a:	95 30       	cpi	r25, 0x05	; 5
    2b1c:	09 f0       	breq	.+2      	; 0x2b20 <ScanStandaloneFlow+0x40>
    2b1e:	a0 c1       	rjmp	.+832    	; 0x2e60 <ScanStandaloneFlow+0x380>
         slaveCmd=zFlowData[2];
         slaveMsg=zFlowData[1];

		 switch(slaveCmd){
    2b20:	80 2f       	mov	r24, r16
    2b22:	90 e0       	ldi	r25, 0x00	; 0
    2b24:	fc 01       	movw	r30, r24
    2b26:	31 97       	sbiw	r30, 0x01	; 1
    2b28:	e1 32       	cpi	r30, 0x21	; 33
    2b2a:	f1 05       	cpc	r31, r1
    2b2c:	08 f0       	brcs	.+2      	; 0x2b30 <ScanStandaloneFlow+0x50>
    2b2e:	94 c1       	rjmp	.+808    	; 0x2e58 <ScanStandaloneFlow+0x378>
    2b30:	eb 58       	subi	r30, 0x8B	; 139
    2b32:	ff 4f       	sbci	r31, 0xFF	; 255
    2b34:	ee 0f       	add	r30, r30
    2b36:	ff 1f       	adc	r31, r31
    2b38:	05 90       	lpm	r0, Z+
    2b3a:	f4 91       	lpm	r31, Z+
    2b3c:	e0 2d       	mov	r30, r0
    2b3e:	09 94       	ijmp
		 case SC_SLAVE:		      
		      IFType=IT_SLAVE;
    2b40:	81 e0       	ldi	r24, 0x01	; 1
    2b42:	80 93 00 01 	sts	0x0100, r24
			  BlinkRate=20;
    2b46:	84 e1       	ldi	r24, 0x14	; 20
    2b48:	80 93 11 04 	sts	0x0411, r24
			  eeprom_write_byte(&DefIFType,IFType);
    2b4c:	20 91 00 01 	lds	r18, 0x0100
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    2b50:	e1 99       	sbic	0x1c, 1	; 28
    2b52:	fe cf       	rjmp	.-4      	; 0x2b50 <ScanStandaloneFlow+0x70>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2b54:	80 e0       	ldi	r24, 0x00	; 0
    2b56:	90 e0       	ldi	r25, 0x00	; 0
    2b58:	9f bb       	out	0x1f, r25	; 31
    2b5a:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    2b5c:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
    2b5e:	0f b6       	in	r0, 0x3f	; 63
    2b60:	f8 94       	cli
    2b62:	e2 9a       	sbi	0x1c, 2	; 28
    2b64:	e1 9a       	sbi	0x1c, 1	; 28
    2b66:	0f be       	out	0x3f, r0	; 63
			  #ifdef DEBUG_CMD_TERM 
			  TerminalSendf(1,PSTR("Slave"));		
			  #endif
			  SystemSetSlave();			  		 
    2b68:	0e 94 e8 13 	call	0x27d0	; 0x27d0 <SystemSetSlave>
    2b6c:	75 c1       	rjmp	.+746    	; 0x2e58 <ScanStandaloneFlow+0x378>
		      break;
         case SC_STANDALONE:
		      InitPumpData();		      
    2b6e:	0e 94 cd 01 	call	0x39a	; 0x39a <InitPumpData>
		      IFType=IT_STANDALONE;
    2b72:	82 e0       	ldi	r24, 0x02	; 2
    2b74:	80 93 00 01 	sts	0x0100, r24
			  BlinkRate=5;
    2b78:	85 e0       	ldi	r24, 0x05	; 5
    2b7a:	80 93 11 04 	sts	0x0411, r24
			  eeprom_write_byte(&DefIFType,IFType);
    2b7e:	20 91 00 01 	lds	r18, 0x0100
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    2b82:	e1 99       	sbic	0x1c, 1	; 28
    2b84:	fe cf       	rjmp	.-4      	; 0x2b82 <ScanStandaloneFlow+0xa2>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2b86:	80 e0       	ldi	r24, 0x00	; 0
    2b88:	90 e0       	ldi	r25, 0x00	; 0
    2b8a:	9f bb       	out	0x1f, r25	; 31
    2b8c:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    2b8e:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
    2b90:	0f b6       	in	r0, 0x3f	; 63
    2b92:	f8 94       	cli
    2b94:	e2 9a       	sbi	0x1c, 2	; 28
    2b96:	e1 9a       	sbi	0x1c, 1	; 28
    2b98:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2b9a:	e1 99       	sbic	0x1c, 1	; 28
    2b9c:	fe cf       	rjmp	.-4      	; 0x2b9a <ScanStandaloneFlow+0xba>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2b9e:	81 e0       	ldi	r24, 0x01	; 1
    2ba0:	90 e0       	ldi	r25, 0x00	; 0
    2ba2:	9f bb       	out	0x1f, r25	; 31
    2ba4:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2ba6:	e0 9a       	sbi	0x1c, 0	; 28
    2ba8:	8d b3       	in	r24, 0x1d	; 29
			  #ifdef DEBUG_CMD_TERM 
			  TerminalSendf(1,PSTR("Standalone"));
			  #endif
			  StandaloneType=eeprom_read_byte(&DefStandaloneType);
    2baa:	80 93 01 01 	sts	0x0101, r24
              //StandaloneType=ST_WAYNE_DART;
              SystemSetDispenser(StandaloneType);
    2bae:	80 91 01 01 	lds	r24, 0x0101
    2bb2:	39 c0       	rjmp	.+114    	; 0x2c26 <ScanStandaloneFlow+0x146>
			  //_uart_init(0,GetBaudrate(eeprom_read_byte(&DefBaudrate[0])));
			  //if (slaveMsg<=0x04)StandaloneType=slaveMsg;

		      break;
         case SC_SET_PUMP_TYPE:
		      IFType=IT_STANDALONE;
    2bb4:	82 e0       	ldi	r24, 0x02	; 2
    2bb6:	80 93 00 01 	sts	0x0100, r24
			  BlinkRate=5;
    2bba:	85 e0       	ldi	r24, 0x05	; 5
    2bbc:	80 93 11 04 	sts	0x0411, r24
              StandaloneType=slaveMsg;
    2bc0:	10 93 01 01 	sts	0x0101, r17
		      eeprom_write_byte(&DefStandaloneType,StandaloneType);			  		      
    2bc4:	20 91 01 01 	lds	r18, 0x0101
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    2bc8:	e1 99       	sbic	0x1c, 1	; 28
    2bca:	fe cf       	rjmp	.-4      	; 0x2bc8 <ScanStandaloneFlow+0xe8>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2bcc:	81 e0       	ldi	r24, 0x01	; 1
    2bce:	90 e0       	ldi	r25, 0x00	; 0
    2bd0:	9f bb       	out	0x1f, r25	; 31
    2bd2:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    2bd4:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
    2bd6:	0f b6       	in	r0, 0x3f	; 63
    2bd8:	f8 94       	cli
    2bda:	e2 9a       	sbi	0x1c, 2	; 28
    2bdc:	e1 9a       	sbi	0x1c, 1	; 28
    2bde:	0f be       	out	0x3f, r0	; 63
			  sprintf_P(strSend,PSTR("Pump:%d"),StandaloneType);
    2be0:	20 91 01 01 	lds	r18, 0x0101
    2be4:	00 d0       	rcall	.+0      	; 0x2be6 <ScanStandaloneFlow+0x106>
    2be6:	00 d0       	rcall	.+0      	; 0x2be8 <ScanStandaloneFlow+0x108>
    2be8:	00 d0       	rcall	.+0      	; 0x2bea <ScanStandaloneFlow+0x10a>
    2bea:	ed b7       	in	r30, 0x3d	; 61
    2bec:	fe b7       	in	r31, 0x3e	; 62
    2bee:	31 96       	adiw	r30, 0x01	; 1
    2bf0:	ce 01       	movw	r24, r28
    2bf2:	01 96       	adiw	r24, 0x01	; 1
    2bf4:	ad b7       	in	r26, 0x3d	; 61
    2bf6:	be b7       	in	r27, 0x3e	; 62
    2bf8:	12 96       	adiw	r26, 0x02	; 2
    2bfa:	9c 93       	st	X, r25
    2bfc:	8e 93       	st	-X, r24
    2bfe:	11 97       	sbiw	r26, 0x01	; 1
    2c00:	8f e8       	ldi	r24, 0x8F	; 143
    2c02:	91 e0       	ldi	r25, 0x01	; 1
    2c04:	93 83       	std	Z+3, r25	; 0x03
    2c06:	82 83       	std	Z+2, r24	; 0x02
    2c08:	24 83       	std	Z+4, r18	; 0x04
    2c0a:	15 82       	std	Z+5, r1	; 0x05
    2c0c:	0e 94 c0 18 	call	0x3180	; 0x3180 <sprintf_P>
              SystemSetDispenser(StandaloneType);
    2c10:	80 91 01 01 	lds	r24, 0x0101
    2c14:	2d b7       	in	r18, 0x3d	; 61
    2c16:	3e b7       	in	r19, 0x3e	; 62
    2c18:	2a 5f       	subi	r18, 0xFA	; 250
    2c1a:	3f 4f       	sbci	r19, 0xFF	; 255
    2c1c:	0f b6       	in	r0, 0x3f	; 63
    2c1e:	f8 94       	cli
    2c20:	3e bf       	out	0x3e, r19	; 62
    2c22:	0f be       	out	0x3f, r0	; 63
    2c24:	2d bf       	out	0x3d, r18	; 61
    2c26:	0e 94 fa 13 	call	0x27f4	; 0x27f4 <SystemSetDispenser>
    2c2a:	a3 c0       	rjmp	.+326    	; 0x2d72 <ScanStandaloneFlow+0x292>
		      break;
         case SC_TOTALIZER:
		      #ifdef DEBUG_CMD_TERM 
		      _uart_printf(1,1,PSTR("SC_TOTALIZER"));
			  #endif
		      if ((slaveMsg>=1)&&(slaveMsg<=16)){
    2c2c:	81 2f       	mov	r24, r17
    2c2e:	81 50       	subi	r24, 0x01	; 1
    2c30:	80 31       	cpi	r24, 0x10	; 16
    2c32:	08 f4       	brcc	.+2      	; 0x2c36 <ScanStandaloneFlow+0x156>
    2c34:	3e c0       	rjmp	.+124    	; 0x2cb2 <ScanStandaloneFlow+0x1d2>
		           IsRequestTotalizerInfo[(slaveMsg&0x0F)]=True;
				  }
			  else if (slaveMsg==PUMP_ALL){
    2c36:	12 31       	cpi	r17, 0x12	; 18
    2c38:	09 f0       	breq	.+2      	; 0x2c3c <ScanStandaloneFlow+0x15c>
    2c3a:	0e c1       	rjmp	.+540    	; 0x2e58 <ScanStandaloneFlow+0x378>
    2c3c:	81 e0       	ldi	r24, 0x01	; 1
    2c3e:	90 e0       	ldi	r25, 0x00	; 0
		           #ifdef DEBUG_CMD_TERM 
				   _uart_printf(1,1,PSTR("PUMPALL"));
				   #endif
				   for (i=1;i<=16;i++)IsRequestTotalizerInfo[(i&0x0F)]=True;
    2c40:	21 e0       	ldi	r18, 0x01	; 1
    2c42:	fc 01       	movw	r30, r24
    2c44:	ef 70       	andi	r30, 0x0F	; 15
    2c46:	f0 70       	andi	r31, 0x00	; 0
    2c48:	ed 5e       	subi	r30, 0xED	; 237
    2c4a:	fb 4f       	sbci	r31, 0xFB	; 251
    2c4c:	20 83       	st	Z, r18
    2c4e:	01 96       	adiw	r24, 0x01	; 1
    2c50:	81 31       	cpi	r24, 0x11	; 17
    2c52:	91 05       	cpc	r25, r1
    2c54:	b1 f7       	brne	.-20     	; 0x2c42 <ScanStandaloneFlow+0x162>
    2c56:	00 c1       	rjmp	.+512    	; 0x2e58 <ScanStandaloneFlow+0x378>
				  }				  	     
		      break; 
         case SC_BAUDRATE:
		      ComPort=(slaveMsg>>4)-3;//3..4
    2c58:	31 2f       	mov	r19, r17
    2c5a:	32 95       	swap	r19
    2c5c:	3f 70       	andi	r19, 0x0F	; 15
    2c5e:	33 50       	subi	r19, 0x03	; 3
			  ComBaud=(slaveMsg&0x0F);//0,1,2,3
    2c60:	21 2f       	mov	r18, r17
    2c62:	2f 70       	andi	r18, 0x0F	; 15
     //IFType=IT_SLAVE;
}

int GetBaudrate(char brSetting){
int Result=0;
     switch(brSetting){
    2c64:	22 30       	cpi	r18, 0x02	; 2
    2c66:	51 f0       	breq	.+20     	; 0x2c7c <ScanStandaloneFlow+0x19c>
    2c68:	22 30       	cpi	r18, 0x02	; 2
    2c6a:	28 f0       	brcs	.+10     	; 0x2c76 <ScanStandaloneFlow+0x196>
    2c6c:	23 30       	cpi	r18, 0x03	; 3
    2c6e:	49 f0       	breq	.+18     	; 0x2c82 <ScanStandaloneFlow+0x1a2>
    2c70:	40 e0       	ldi	r20, 0x00	; 0
    2c72:	50 e0       	ldi	r21, 0x00	; 0
    2c74:	08 c0       	rjmp	.+16     	; 0x2c86 <ScanStandaloneFlow+0x1a6>
    2c76:	40 e8       	ldi	r20, 0x80	; 128
    2c78:	55 e2       	ldi	r21, 0x25	; 37
    2c7a:	05 c0       	rjmp	.+10     	; 0x2c86 <ScanStandaloneFlow+0x1a6>
    2c7c:	40 e0       	ldi	r20, 0x00	; 0
    2c7e:	5b e4       	ldi	r21, 0x4B	; 75
    2c80:	02 c0       	rjmp	.+4      	; 0x2c86 <ScanStandaloneFlow+0x1a6>
    2c82:	4b e9       	ldi	r20, 0x9B	; 155
    2c84:	56 e1       	ldi	r21, 0x16	; 22
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    2c86:	e1 99       	sbic	0x1c, 1	; 28
    2c88:	fe cf       	rjmp	.-4      	; 0x2c86 <ScanStandaloneFlow+0x1a6>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2c8a:	83 2f       	mov	r24, r19
    2c8c:	90 e0       	ldi	r25, 0x00	; 0
    2c8e:	8b 5f       	subi	r24, 0xFB	; 251
    2c90:	9f 4f       	sbci	r25, 0xFF	; 255
    2c92:	9f bb       	out	0x1f, r25	; 31
    2c94:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    2c96:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
    2c98:	0f b6       	in	r0, 0x3f	; 63
    2c9a:	f8 94       	cli
    2c9c:	e2 9a       	sbi	0x1c, 2	; 28
    2c9e:	e1 9a       	sbi	0x1c, 1	; 28
    2ca0:	0f be       	out	0x3f, r0	; 63
			  eeprom_write_byte(&DefBaudrate[ComPort],ComBaud);
			  #ifdef DEBUG_CMD_TERM 
 			  sprintf_P(strSend,PSTR("COM:%d,%i"),ComPort,brValue);
			  TerminalSend(1,strSend);
			  #endif
			  _uart_init(ComPort,brValue);
    2ca2:	60 e0       	ldi	r22, 0x00	; 0
    2ca4:	70 e0       	ldi	r23, 0x00	; 0
    2ca6:	83 2f       	mov	r24, r19
    2ca8:	0e 94 2c 18 	call	0x3058	; 0x3058 <_uart_init>
    2cac:	d5 c0       	rjmp	.+426    	; 0x2e58 <ScanStandaloneFlow+0x378>
		      break;
		 case SC_TRANSACTION:
		          if (slaveMsg<=16)IsRequestTotalizerInfo[slaveMsg&0x0F]=True;
    2cae:	11 31       	cpi	r17, 0x11	; 17
    2cb0:	38 f4       	brcc	.+14     	; 0x2cc0 <ScanStandaloneFlow+0x1e0>
    2cb2:	e1 2f       	mov	r30, r17
    2cb4:	f0 e0       	ldi	r31, 0x00	; 0
    2cb6:	ef 70       	andi	r30, 0x0F	; 15
    2cb8:	f0 70       	andi	r31, 0x00	; 0
    2cba:	ed 5e       	subi	r30, 0xED	; 237
    2cbc:	fb 4f       	sbci	r31, 0xFB	; 251
    2cbe:	19 c0       	rjmp	.+50     	; 0x2cf2 <ScanStandaloneFlow+0x212>
				  else 
				  if (slaveMsg==PUMP_ALL){
    2cc0:	12 31       	cpi	r17, 0x12	; 18
    2cc2:	09 f0       	breq	.+2      	; 0x2cc6 <ScanStandaloneFlow+0x1e6>
    2cc4:	c9 c0       	rjmp	.+402    	; 0x2e58 <ScanStandaloneFlow+0x378>
    2cc6:	81 e0       	ldi	r24, 0x01	; 1
    2cc8:	90 e0       	ldi	r25, 0x00	; 0
				      for(i=1;i<=16;i++){
					      IsRequestTotalizerInfo[i&0x0F]=True;
    2cca:	21 e0       	ldi	r18, 0x01	; 1
    2ccc:	fc 01       	movw	r30, r24
    2cce:	ef 70       	andi	r30, 0x0F	; 15
    2cd0:	f0 70       	andi	r31, 0x00	; 0
    2cd2:	ed 5e       	subi	r30, 0xED	; 237
    2cd4:	fb 4f       	sbci	r31, 0xFB	; 251
    2cd6:	20 83       	st	Z, r18
    2cd8:	01 96       	adiw	r24, 0x01	; 1
		      break;
		 case SC_TRANSACTION:
		          if (slaveMsg<=16)IsRequestTotalizerInfo[slaveMsg&0x0F]=True;
				  else 
				  if (slaveMsg==PUMP_ALL){
				      for(i=1;i<=16;i++){
    2cda:	81 31       	cpi	r24, 0x11	; 17
    2cdc:	91 05       	cpc	r25, r1
    2cde:	b1 f7       	brne	.-20     	; 0x2ccc <ScanStandaloneFlow+0x1ec>
    2ce0:	bb c0       	rjmp	.+374    	; 0x2e58 <ScanStandaloneFlow+0x378>
				 sprintf_P(strSend,PSTR("ReqTrans:%d"),slaveMsg);
				 TerminalSend(1,strSend);
              #endif
		      break;     
         case SC_PUMP_LOCK:
		          if (slaveMsg<=16)PumpLock[slaveMsg&0x0F]=True;
    2ce2:	11 31       	cpi	r17, 0x11	; 17
    2ce4:	48 f4       	brcc	.+18     	; 0x2cf8 <ScanStandaloneFlow+0x218>
    2ce6:	e1 2f       	mov	r30, r17
    2ce8:	f0 e0       	ldi	r31, 0x00	; 0
    2cea:	ef 70       	andi	r30, 0x0F	; 15
    2cec:	f0 70       	andi	r31, 0x00	; 0
    2cee:	e4 53       	subi	r30, 0x34	; 52
    2cf0:	fd 4f       	sbci	r31, 0xFD	; 253
    2cf2:	81 e0       	ldi	r24, 0x01	; 1
    2cf4:	80 83       	st	Z, r24
    2cf6:	b0 c0       	rjmp	.+352    	; 0x2e58 <ScanStandaloneFlow+0x378>
				  else 
				  if (slaveMsg==PUMP_ALL){
    2cf8:	12 31       	cpi	r17, 0x12	; 18
    2cfa:	09 f0       	breq	.+2      	; 0x2cfe <ScanStandaloneFlow+0x21e>
    2cfc:	ad c0       	rjmp	.+346    	; 0x2e58 <ScanStandaloneFlow+0x378>
    2cfe:	81 e0       	ldi	r24, 0x01	; 1
    2d00:	90 e0       	ldi	r25, 0x00	; 0
				      for(i=1;i<=16;i++){
					      PumpLock[i&0x0F]=True;
    2d02:	21 e0       	ldi	r18, 0x01	; 1
    2d04:	fc 01       	movw	r30, r24
    2d06:	ef 70       	andi	r30, 0x0F	; 15
    2d08:	f0 70       	andi	r31, 0x00	; 0
    2d0a:	e4 53       	subi	r30, 0x34	; 52
    2d0c:	fd 4f       	sbci	r31, 0xFD	; 253
    2d0e:	20 83       	st	Z, r18
    2d10:	01 96       	adiw	r24, 0x01	; 1
		      break;     
         case SC_PUMP_LOCK:
		          if (slaveMsg<=16)PumpLock[slaveMsg&0x0F]=True;
				  else 
				  if (slaveMsg==PUMP_ALL){
				      for(i=1;i<=16;i++){
    2d12:	81 31       	cpi	r24, 0x11	; 17
    2d14:	91 05       	cpc	r25, r1
    2d16:	b1 f7       	brne	.-20     	; 0x2d04 <ScanStandaloneFlow+0x224>
    2d18:	9f c0       	rjmp	.+318    	; 0x2e58 <ScanStandaloneFlow+0x378>
				 sprintf_P(strSend,PSTR("PumpLock:%d"),slaveMsg);
				 TerminalSend(1,strSend);
              #endif
		      break;
         case SC_PUMP_UNLOCK:
		          if (slaveMsg<=16)PumpLock[slaveMsg&0x0F]=False;
    2d1a:	11 31       	cpi	r17, 0x11	; 17
    2d1c:	40 f4       	brcc	.+16     	; 0x2d2e <ScanStandaloneFlow+0x24e>
    2d1e:	e1 2f       	mov	r30, r17
    2d20:	f0 e0       	ldi	r31, 0x00	; 0
    2d22:	ef 70       	andi	r30, 0x0F	; 15
    2d24:	f0 70       	andi	r31, 0x00	; 0
    2d26:	e4 53       	subi	r30, 0x34	; 52
    2d28:	fd 4f       	sbci	r31, 0xFD	; 253
    2d2a:	10 82       	st	Z, r1
    2d2c:	95 c0       	rjmp	.+298    	; 0x2e58 <ScanStandaloneFlow+0x378>
			   	  else 
			   	  if (slaveMsg==PUMP_ALL){
    2d2e:	12 31       	cpi	r17, 0x12	; 18
    2d30:	09 f0       	breq	.+2      	; 0x2d34 <ScanStandaloneFlow+0x254>
    2d32:	92 c0       	rjmp	.+292    	; 0x2e58 <ScanStandaloneFlow+0x378>
    2d34:	81 e0       	ldi	r24, 0x01	; 1
    2d36:	90 e0       	ldi	r25, 0x00	; 0
			   	      for(i=1;i<=16;i++){
			   		      PumpLock[i&0x0F]=False;
    2d38:	fc 01       	movw	r30, r24
    2d3a:	ef 70       	andi	r30, 0x0F	; 15
    2d3c:	f0 70       	andi	r31, 0x00	; 0
    2d3e:	e4 53       	subi	r30, 0x34	; 52
    2d40:	fd 4f       	sbci	r31, 0xFD	; 253
    2d42:	10 82       	st	Z, r1
    2d44:	01 96       	adiw	r24, 0x01	; 1
		      break;
         case SC_PUMP_UNLOCK:
		          if (slaveMsg<=16)PumpLock[slaveMsg&0x0F]=False;
			   	  else 
			   	  if (slaveMsg==PUMP_ALL){
			   	      for(i=1;i<=16;i++){
    2d46:	81 31       	cpi	r24, 0x11	; 17
    2d48:	91 05       	cpc	r25, r1
    2d4a:	b1 f7       	brne	.-20     	; 0x2d38 <ScanStandaloneFlow+0x258>
    2d4c:	85 c0       	rjmp	.+266    	; 0x2e58 <ScanStandaloneFlow+0x378>
			   	 sprintf_P(strSend,PSTR("PumpUnLock:%d"),slaveMsg);
				 TerminalSend(1,strSend);			 
               #endif
		       break;
          case SC_TOTALIZER_ACK:
		       IsTotalizerACK=True;
    2d4e:	81 e0       	ldi	r24, 0x01	; 1
    2d50:	80 93 14 01 	sts	0x0114, r24
			   PumpAck=slaveMsg;
    2d54:	10 93 df 02 	sts	0x02DF, r17
    2d58:	7f c0       	rjmp	.+254    	; 0x2e58 <ScanStandaloneFlow+0x378>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    2d5a:	e1 99       	sbic	0x1c, 1	; 28
    2d5c:	fe cf       	rjmp	.-4      	; 0x2d5a <ScanStandaloneFlow+0x27a>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2d5e:	88 e0       	ldi	r24, 0x08	; 8
    2d60:	90 e0       	ldi	r25, 0x00	; 0
    2d62:	9f bb       	out	0x1f, r25	; 31
    2d64:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    2d66:	1d bb       	out	0x1d, r17	; 29

    __asm__ __volatile__ (
    2d68:	0f b6       	in	r0, 0x3f	; 63
    2d6a:	f8 94       	cli
    2d6c:	e2 9a       	sbi	0x1c, 2	; 28
    2d6e:	e1 9a       	sbi	0x1c, 1	; 28
    2d70:	0f be       	out	0x3f, r0	; 63
		       #ifdef DEBUG_CMD_TERM 
			   sprintf_P(strSend,PSTR("NoPumpCount:%d"),slaveMsg);
			   TerminalSend(1,strSend);			 
			   #endif
		       eeprom_write_byte(&DefNoPumpCountMax,slaveMsg);
			   IsRestartPooling=True;
    2d72:	81 e0       	ldi	r24, 0x01	; 1
    2d74:	80 93 03 01 	sts	0x0103, r24
    2d78:	6f c0       	rjmp	.+222    	; 0x2e58 <ScanStandaloneFlow+0x378>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    2d7a:	e1 99       	sbic	0x1c, 1	; 28
    2d7c:	fe cf       	rjmp	.-4      	; 0x2d7a <ScanStandaloneFlow+0x29a>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2d7e:	87 e0       	ldi	r24, 0x07	; 7
    2d80:	90 e0       	ldi	r25, 0x00	; 0
    2d82:	ef cf       	rjmp	.-34     	; 0x2d62 <ScanStandaloneFlow+0x282>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    2d84:	e1 99       	sbic	0x1c, 1	; 28
    2d86:	fe cf       	rjmp	.-4      	; 0x2d84 <ScanStandaloneFlow+0x2a4>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2d88:	89 e0       	ldi	r24, 0x09	; 9
    2d8a:	90 e0       	ldi	r25, 0x00	; 0
    2d8c:	ea cf       	rjmp	.-44     	; 0x2d62 <ScanStandaloneFlow+0x282>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    2d8e:	e1 99       	sbic	0x1c, 1	; 28
    2d90:	fe cf       	rjmp	.-4      	; 0x2d8e <ScanStandaloneFlow+0x2ae>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2d92:	8a e0       	ldi	r24, 0x0A	; 10
    2d94:	90 e0       	ldi	r25, 0x00	; 0
    2d96:	e5 cf       	rjmp	.-54     	; 0x2d62 <ScanStandaloneFlow+0x282>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    2d98:	e1 99       	sbic	0x1c, 1	; 28
    2d9a:	fe cf       	rjmp	.-4      	; 0x2d98 <ScanStandaloneFlow+0x2b8>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2d9c:	8b e0       	ldi	r24, 0x0B	; 11
    2d9e:	90 e0       	ldi	r25, 0x00	; 0
    2da0:	e0 cf       	rjmp	.-64     	; 0x2d62 <ScanStandaloneFlow+0x282>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2da2:	e1 99       	sbic	0x1c, 1	; 28
    2da4:	fe cf       	rjmp	.-4      	; 0x2da2 <ScanStandaloneFlow+0x2c2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2da6:	88 e0       	ldi	r24, 0x08	; 8
    2da8:	90 e0       	ldi	r25, 0x00	; 0
    2daa:	04 c0       	rjmp	.+8      	; 0x2db4 <ScanStandaloneFlow+0x2d4>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2dac:	e1 99       	sbic	0x1c, 1	; 28
    2dae:	fe cf       	rjmp	.-4      	; 0x2dac <ScanStandaloneFlow+0x2cc>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2db0:	87 e0       	ldi	r24, 0x07	; 7
    2db2:	90 e0       	ldi	r25, 0x00	; 0
    2db4:	9f bb       	out	0x1f, r25	; 31
    2db6:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2db8:	e0 9a       	sbi	0x1c, 0	; 28
    2dba:	1d b3       	in	r17, 0x1d	; 29
    2dbc:	4d c0       	rjmp	.+154    	; 0x2e58 <ScanStandaloneFlow+0x378>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2dbe:	e1 99       	sbic	0x1c, 1	; 28
    2dc0:	fe cf       	rjmp	.-4      	; 0x2dbe <ScanStandaloneFlow+0x2de>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2dc2:	89 e0       	ldi	r24, 0x09	; 9
    2dc4:	90 e0       	ldi	r25, 0x00	; 0
    2dc6:	f6 cf       	rjmp	.-20     	; 0x2db4 <ScanStandaloneFlow+0x2d4>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    2dc8:	e1 99       	sbic	0x1c, 1	; 28
    2dca:	fe cf       	rjmp	.-4      	; 0x2dc8 <ScanStandaloneFlow+0x2e8>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2dcc:	8c e0       	ldi	r24, 0x0C	; 12
    2dce:	90 e0       	ldi	r25, 0x00	; 0
    2dd0:	9f bb       	out	0x1f, r25	; 31
    2dd2:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    2dd4:	1d bb       	out	0x1d, r17	; 29

    __asm__ __volatile__ (
    2dd6:	0f b6       	in	r0, 0x3f	; 63
    2dd8:	f8 94       	cli
    2dda:	e2 9a       	sbi	0x1c, 2	; 28
    2ddc:	e1 9a       	sbi	0x1c, 1	; 28
    2dde:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2de0:	e1 99       	sbic	0x1c, 1	; 28
    2de2:	fe cf       	rjmp	.-4      	; 0x2de0 <ScanStandaloneFlow+0x300>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2de4:	9f bb       	out	0x1f, r25	; 31
    2de6:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2de8:	e0 9a       	sbi	0x1c, 0	; 28
    2dea:	8d b3       	in	r24, 0x1d	; 29
		       #ifdef DEBUG_CMD_TERM 
			   sprintf_P(strSend,PSTR("PoolTrySend:%d"),slaveMsg);
			   TerminalSend(1,strSend);			 		        
			   #endif 
		       eeprom_write_byte(&DefSequenceTimeout,slaveMsg);
			   SequenceTimeout=eeprom_read_byte(&DefSequenceTimeout);
    2dec:	80 93 36 04 	sts	0x0436, r24
    2df0:	c0 cf       	rjmp	.-128    	; 0x2d72 <ScanStandaloneFlow+0x292>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    2df2:	e1 99       	sbic	0x1c, 1	; 28
    2df4:	fe cf       	rjmp	.-4      	; 0x2df2 <ScanStandaloneFlow+0x312>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2df6:	81 2f       	mov	r24, r17
    2df8:	82 95       	swap	r24
    2dfa:	8f 70       	andi	r24, 0x0F	; 15
    2dfc:	90 e0       	ldi	r25, 0x00	; 0
    2dfe:	83 5f       	subi	r24, 0xF3	; 243
    2e00:	9f 4f       	sbci	r25, 0xFF	; 255
    2e02:	9f bb       	out	0x1f, r25	; 31
    2e04:	8e bb       	out	0x1e, r24	; 30
			   IsRestartPooling=True;		       
		       break;
          case SC_SET_PUMPID:
		       eeprom_write_byte(&DefPumpID[slaveMsg>>4],(slaveMsg&0x0F));		       
    2e06:	81 2f       	mov	r24, r17
    2e08:	8f 70       	andi	r24, 0x0F	; 15
#endif
    EEDR = __value;
    2e0a:	8d bb       	out	0x1d, r24	; 29
    2e0c:	ad cf       	rjmp	.-166    	; 0x2d68 <ScanStandaloneFlow+0x288>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    2e0e:	e1 99       	sbic	0x1c, 1	; 28
    2e10:	fe cf       	rjmp	.-4      	; 0x2e0e <ScanStandaloneFlow+0x32e>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2e12:	81 2f       	mov	r24, r17
    2e14:	90 e0       	ldi	r25, 0x00	; 0
    2e16:	83 5f       	subi	r24, 0xF3	; 243
    2e18:	9f 4f       	sbci	r25, 0xFF	; 255
    2e1a:	9f bb       	out	0x1f, r25	; 31
    2e1c:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    2e1e:	1d ba       	out	0x1d, r1	; 29
    2e20:	a3 cf       	rjmp	.-186    	; 0x2d68 <ScanStandaloneFlow+0x288>
			   TerminalSend(1,strSend);			 		        
			   #endif
               IsRestartPooling=True;
		       break;
          case SC_STOP_POOL_SEQUENCE:
		       IsStopPoolSequence=True;
    2e22:	81 e0       	ldi	r24, 0x01	; 1
    2e24:	80 93 13 01 	sts	0x0113, r24
    2e28:	17 c0       	rjmp	.+46     	; 0x2e58 <ScanStandaloneFlow+0x378>
		       break; 
          case SC_START_POOL_SEQUENCE:
		       IsStopPoolSequence=False;
    2e2a:	10 92 13 01 	sts	0x0113, r1
    2e2e:	14 c0       	rjmp	.+40     	; 0x2e58 <ScanStandaloneFlow+0x378>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    2e30:	e1 99       	sbic	0x1c, 1	; 28
    2e32:	fe cf       	rjmp	.-4      	; 0x2e30 <ScanStandaloneFlow+0x350>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2e34:	8e e1       	ldi	r24, 0x1E	; 30
    2e36:	90 e0       	ldi	r25, 0x00	; 0
    2e38:	9f bb       	out	0x1f, r25	; 31
    2e3a:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    2e3c:	1d bb       	out	0x1d, r17	; 29

    __asm__ __volatile__ (
    2e3e:	0f b6       	in	r0, 0x3f	; 63
    2e40:	f8 94       	cli
    2e42:	e2 9a       	sbi	0x1c, 2	; 28
    2e44:	e1 9a       	sbi	0x1c, 1	; 28
    2e46:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2e48:	e1 99       	sbic	0x1c, 1	; 28
    2e4a:	fe cf       	rjmp	.-4      	; 0x2e48 <ScanStandaloneFlow+0x368>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2e4c:	9f bb       	out	0x1f, r25	; 31
    2e4e:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2e50:	e0 9a       	sbi	0x1c, 0	; 28
    2e52:	8d b3       	in	r24, 0x1d	; 29
		       break; 
          case SC_HGM_MODE:
		       eeprom_write_byte(&DefHGMode,slaveMsg);
			   SystemComLevel(eeprom_read_byte(&DefHGMode));
    2e54:	0e 94 61 01 	call	0x2c2	; 0x2c2 <SystemComLevel>
			   
		       break;
		 }
       //AcknoledgeCommand
       SendCommandAcknoledge(slaveCmd,slaveMsg);
    2e58:	80 2f       	mov	r24, r16
    2e5a:	61 2f       	mov	r22, r17
    2e5c:	0e 94 e0 06 	call	0xdc0	; 0xdc0 <SendCommandAcknoledge>
	 }//EndIf	 
}
    2e60:	64 96       	adiw	r28, 0x14	; 20
    2e62:	0f b6       	in	r0, 0x3f	; 63
    2e64:	f8 94       	cli
    2e66:	de bf       	out	0x3e, r29	; 62
    2e68:	0f be       	out	0x3f, r0	; 63
    2e6a:	cd bf       	out	0x3d, r28	; 61
    2e6c:	cf 91       	pop	r28
    2e6e:	df 91       	pop	r29
    2e70:	1f 91       	pop	r17
    2e72:	0f 91       	pop	r16
    2e74:	08 95       	ret

00002e76 <__vector_18>:
	   
	//_uart(1,1,dataRX1);
	//OnReceive1(dataRX1);
}

ISR(SPI_STC_vect){
    2e76:	1f 92       	push	r1
    2e78:	0f 92       	push	r0
    2e7a:	0f b6       	in	r0, 0x3f	; 63
    2e7c:	0f 92       	push	r0
    2e7e:	11 24       	eor	r1, r1
    2e80:	1f 93       	push	r17
    2e82:	2f 93       	push	r18
    2e84:	3f 93       	push	r19
    2e86:	4f 93       	push	r20
    2e88:	5f 93       	push	r21
    2e8a:	6f 93       	push	r22
    2e8c:	7f 93       	push	r23
    2e8e:	8f 93       	push	r24
    2e90:	9f 93       	push	r25
    2e92:	af 93       	push	r26
    2e94:	bf 93       	push	r27
    2e96:	ef 93       	push	r30
    2e98:	ff 93       	push	r31
char dataSPI;
     dataSPI=SPDR;
    2e9a:	1f b1       	in	r17, 0x0f	; 15
          ScanStandaloneFlow(dataSPI);
	      break;
	 }
	 */
	 
	 if (IFType==IT_SLAVE)//EDC Line Protocol
    2e9c:	80 91 00 01 	lds	r24, 0x0100
    2ea0:	81 30       	cpi	r24, 0x01	; 1
    2ea2:	29 f4       	brne	.+10     	; 0x2eae <__vector_18+0x38>
	    _uart(0,1,dataSPI);
    2ea4:	80 e0       	ldi	r24, 0x00	; 0
    2ea6:	61 e0       	ldi	r22, 0x01	; 1
    2ea8:	41 2f       	mov	r20, r17
    2eaa:	0e 94 58 18 	call	0x30b0	; 0x30b0 <_uart>
	 ScanStandaloneFlow(dataSPI);	 
    2eae:	81 2f       	mov	r24, r17
    2eb0:	0e 94 70 15 	call	0x2ae0	; 0x2ae0 <ScanStandaloneFlow>
}
    2eb4:	ff 91       	pop	r31
    2eb6:	ef 91       	pop	r30
    2eb8:	bf 91       	pop	r27
    2eba:	af 91       	pop	r26
    2ebc:	9f 91       	pop	r25
    2ebe:	8f 91       	pop	r24
    2ec0:	7f 91       	pop	r23
    2ec2:	6f 91       	pop	r22
    2ec4:	5f 91       	pop	r21
    2ec6:	4f 91       	pop	r20
    2ec8:	3f 91       	pop	r19
    2eca:	2f 91       	pop	r18
    2ecc:	1f 91       	pop	r17
    2ece:	0f 90       	pop	r0
    2ed0:	0f be       	out	0x3f, r0	; 63
    2ed2:	0f 90       	pop	r0
    2ed4:	1f 90       	pop	r1
    2ed6:	18 95       	reti

00002ed8 <_spi_init>:
enum SPI_TYPE{SLAVE,MASTER};
enum SPI_MODE{POOLING,INTERUPT};


void _spi_init(unsigned char __mode, unsigned char __interrupt){
	if(__mode){
    2ed8:	88 23       	and	r24, r24
    2eda:	41 f0       	breq	.+16     	; 0x2eec <_spi_init+0x14>
		_SPI_DDR = (1 << _SPI_MOSI) | (1 << _SPI_SCK);
    2edc:	80 ea       	ldi	r24, 0xA0	; 160
    2ede:	87 bb       	out	0x17, r24	; 23
		if(__interrupt)
    2ee0:	66 23       	and	r22, r22
    2ee2:	11 f0       	breq	.+4      	; 0x2ee8 <_spi_init+0x10>
			SPCR = (1 << SPIE) | (1 << SPE) | (1 << MSTR) | (1 << SPR1);
    2ee4:	82 ed       	ldi	r24, 0xD2	; 210
    2ee6:	0a c0       	rjmp	.+20     	; 0x2efc <_spi_init+0x24>
		else
			SPCR = (1 << SPE) | (1 << MSTR) | (1 << SPR1);
    2ee8:	82 e5       	ldi	r24, 0x52	; 82
    2eea:	08 c0       	rjmp	.+16     	; 0x2efc <_spi_init+0x24>
	}
	else{

		_SPI_DDR = (1 << _SPI_MISO);
    2eec:	80 e4       	ldi	r24, 0x40	; 64
    2eee:	87 bb       	out	0x17, r24	; 23
		if(__interrupt)
    2ef0:	66 23       	and	r22, r22
    2ef2:	21 f0       	breq	.+8      	; 0x2efc <_spi_init+0x24>
			{SPCR = (1 << SPIE) | (1 << SPE);sei();}
    2ef4:	80 ec       	ldi	r24, 0xC0	; 192
    2ef6:	8d b9       	out	0x0d, r24	; 13
    2ef8:	78 94       	sei
    2efa:	08 95       	ret
		else
			SPCR = (1 << SPE);
    2efc:	8d b9       	out	0x0d, r24	; 13
    2efe:	08 95       	ret

00002f00 <_spi_enable>:
			
	}
}

void _spi_enable(unsigned char __status, unsigned char __select){
	if(__status){
    2f00:	88 23       	and	r24, r24
    2f02:	31 f0       	breq	.+12     	; 0x2f10 <_spi_enable+0x10>
		if(__select)
    2f04:	66 23       	and	r22, r22
    2f06:	11 f0       	breq	.+4      	; 0x2f0c <_spi_enable+0xc>
			cbi(_MMC_PORT, _MMC_PIN);
    2f08:	3b 98       	cbi	0x07, 3	; 7
    2f0a:	08 95       	ret
		else
			cbi(_SLAVE_PORT, _SLAVE_PIN);
    2f0c:	92 98       	cbi	0x12, 2	; 18
    2f0e:	08 95       	ret
	}
	else{
		if(__select)
    2f10:	66 23       	and	r22, r22
    2f12:	11 f0       	breq	.+4      	; 0x2f18 <_spi_enable+0x18>
			sbi(_MMC_PORT, _MMC_PIN);
    2f14:	3b 9a       	sbi	0x07, 3	; 7
    2f16:	08 95       	ret
		else
			sbi(_SLAVE_PORT, _SLAVE_PIN);
    2f18:	92 9a       	sbi	0x12, 2	; 18
    2f1a:	08 95       	ret

00002f1c <_spi>:
	}
}

unsigned char _spi(unsigned char __data){   
	SPDR = __data;
    2f1c:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1 << SPIF)));
    2f1e:	77 9b       	sbis	0x0e, 7	; 14
    2f20:	fe cf       	rjmp	.-4      	; 0x2f1e <_spi+0x2>
	return SPDR;
    2f22:	8f b1       	in	r24, 0x0f	; 15
}
    2f24:	08 95       	ret

00002f26 <_spi_rx>:

unsigned char _spi_rx(unsigned char __select){
//	return 1;
}
    2f26:	08 95       	ret

00002f28 <_spi_tx>:

unsigned char _spi_tx(unsigned char __command, unsigned char __select, char *__message){
//	_spi_enable(_SPI_ENABLE, __select);
//	_spi_enable(_SPI_DISABLE, __select);
//	return 0;
}
    2f28:	08 95       	ret

00002f2a <_spi_interrupt>:

unsigned char _spi_interrupt(void){
	//return 0;
}
    2f2a:	08 95       	ret

00002f2c <_spi_command>:
	}

	__command[__i++] = 0x7D;
	__command[__i++] = '\0';
	*/
}
    2f2c:	08 95       	ret

00002f2e <_uart_setting>:

#include "UART.h"

//_uart_setting(0,GetBaudrate(eeprom_read_byte(&DefBaudrate[0])),8,P_EVEN,1);

void _uart_setting(char Port,unsigned long Baudrate,char DataSet,char ParitySet, char StopBitSet){
    2f2e:	af 92       	push	r10
    2f30:	bf 92       	push	r11
    2f32:	cf 92       	push	r12
    2f34:	df 92       	push	r13
    2f36:	ef 92       	push	r14
    2f38:	ff 92       	push	r15
    2f3a:	0f 93       	push	r16
    2f3c:	1f 93       	push	r17
    2f3e:	f8 2e       	mov	r15, r24
    2f40:	5a 01       	movw	r10, r20
    2f42:	6b 01       	movw	r12, r22
    2f44:	12 2f       	mov	r17, r18
unsigned long BaudrateValue;
     char RegB,RegC;
	 BaudrateValue= (unsigned long)((_CPU_DEFAULT + (Baudrate* 8)) / (Baudrate* 16) - 1);
    2f46:	cb 01       	movw	r24, r22
    2f48:	ba 01       	movw	r22, r20
    2f4a:	60 50       	subi	r22, 0x00	; 0
    2f4c:	70 4e       	sbci	r23, 0xE0	; 224
    2f4e:	83 4e       	sbci	r24, 0xE3	; 227
    2f50:	9f 4f       	sbci	r25, 0xFF	; 255
    2f52:	33 e0       	ldi	r19, 0x03	; 3
    2f54:	66 0f       	add	r22, r22
    2f56:	77 1f       	adc	r23, r23
    2f58:	88 1f       	adc	r24, r24
    2f5a:	99 1f       	adc	r25, r25
    2f5c:	3a 95       	dec	r19
    2f5e:	d1 f7       	brne	.-12     	; 0x2f54 <_uart_setting+0x26>
    2f60:	24 e0       	ldi	r18, 0x04	; 4
    2f62:	aa 0c       	add	r10, r10
    2f64:	bb 1c       	adc	r11, r11
    2f66:	cc 1c       	adc	r12, r12
    2f68:	dd 1c       	adc	r13, r13
    2f6a:	2a 95       	dec	r18
    2f6c:	d1 f7       	brne	.-12     	; 0x2f62 <_uart_setting+0x34>
    2f6e:	a6 01       	movw	r20, r12
    2f70:	95 01       	movw	r18, r10
    2f72:	0e 94 81 1b 	call	0x3702	; 0x3702 <__udivmodsi4>
    2f76:	21 50       	subi	r18, 0x01	; 1
    2f78:	30 40       	sbci	r19, 0x00	; 0
    2f7a:	40 40       	sbci	r20, 0x00	; 0
    2f7c:	50 40       	sbci	r21, 0x00	; 0
     RegB=0;RegC=0;
	 RegB = (1<<RXCIE0) | (1<<RXEN0) | (1<<TXEN0);
     RegC = (1<<URSEL0);
   
     //ParitySet
	 switch(ParitySet){
    2f7e:	01 30       	cpi	r16, 0x01	; 1
    2f80:	31 f0       	breq	.+12     	; 0x2f8e <_uart_setting+0x60>
    2f82:	02 30       	cpi	r16, 0x02	; 2
    2f84:	11 f4       	brne	.+4      	; 0x2f8a <_uart_setting+0x5c>
    2f86:	60 ea       	ldi	r22, 0xA0	; 160
    2f88:	03 c0       	rjmp	.+6      	; 0x2f90 <_uart_setting+0x62>
    2f8a:	60 e8       	ldi	r22, 0x80	; 128
    2f8c:	01 c0       	rjmp	.+2      	; 0x2f90 <_uart_setting+0x62>
    2f8e:	60 eb       	ldi	r22, 0xB0	; 176
     case P_ODD:
	      RegC=RegC|(1<<UPM00)|(1<<UPM01);
	      break;	 
	 }
     //StopBit
      if (StopBitSet==2)
    2f90:	82 e0       	ldi	r24, 0x02	; 2
    2f92:	e8 16       	cp	r14, r24
    2f94:	09 f4       	brne	.+2      	; 0x2f98 <_uart_setting+0x6a>
	      RegC=RegC|(1<<USBS0);
    2f96:	68 60       	ori	r22, 0x08	; 8

		  //DataSet
		  switch (DataSet){
    2f98:	17 30       	cpi	r17, 0x07	; 7
    2f9a:	61 f0       	breq	.+24     	; 0x2fb4 <_uart_setting+0x86>
    2f9c:	18 30       	cpi	r17, 0x08	; 8
    2f9e:	18 f4       	brcc	.+6      	; 0x2fa6 <_uart_setting+0x78>
    2fa0:	16 30       	cpi	r17, 0x06	; 6
    2fa2:	59 f4       	brne	.+22     	; 0x2fba <_uart_setting+0x8c>
    2fa4:	05 c0       	rjmp	.+10     	; 0x2fb0 <_uart_setting+0x82>
    2fa6:	18 30       	cpi	r17, 0x08	; 8
    2fa8:	39 f0       	breq	.+14     	; 0x2fb8 <_uart_setting+0x8a>
    2faa:	19 30       	cpi	r17, 0x09	; 9
    2fac:	31 f4       	brne	.+12     	; 0x2fba <_uart_setting+0x8c>
    2fae:	07 c0       	rjmp	.+14     	; 0x2fbe <_uart_setting+0x90>
		  case 5:
		       break;
		  case 6:
		       RegC=RegC|(1<<UCSZ00);
    2fb0:	62 60       	ori	r22, 0x02	; 2
    2fb2:	03 c0       	rjmp	.+6      	; 0x2fba <_uart_setting+0x8c>
		       break;
		  case 7:
		       RegC=RegC|(1<<UCSZ01);
    2fb4:	64 60       	ori	r22, 0x04	; 4
    2fb6:	01 c0       	rjmp	.+2      	; 0x2fba <_uart_setting+0x8c>
		       break;
		  case 8:
		       RegC=RegC|(1<<UCSZ00)|(1<<UCSZ01);
    2fb8:	66 60       	ori	r22, 0x06	; 6
    2fba:	78 e9       	ldi	r23, 0x98	; 152
    2fbc:	02 c0       	rjmp	.+4      	; 0x2fc2 <_uart_setting+0x94>
		       break;
		  case 9:
               RegB=RegB| (1<<UCSZ02);
		       RegC=RegC| (1<<UCSZ00)|(1<<UCSZ01);
    2fbe:	66 60       	ori	r22, 0x06	; 6
    2fc0:	7c e9       	ldi	r23, 0x9C	; 156
		       break;
		  }

	 switch (Port){
    2fc2:	ff 20       	and	r15, r15
    2fc4:	21 f0       	breq	.+8      	; 0x2fce <_uart_setting+0xa0>
    2fc6:	81 e0       	ldi	r24, 0x01	; 1
    2fc8:	f8 16       	cp	r15, r24
    2fca:	91 f4       	brne	.+36     	; 0x2ff0 <_uart_setting+0xc2>
    2fcc:	09 c0       	rjmp	.+18     	; 0x2fe0 <_uart_setting+0xb2>
	 case 0:		  
		  //Write
		  //Register

	      //BaudrateSetting
          UBRR0H=BaudrateValue>>8;
    2fce:	bb 27       	eor	r27, r27
    2fd0:	a5 2f       	mov	r26, r21
    2fd2:	94 2f       	mov	r25, r20
    2fd4:	83 2f       	mov	r24, r19
    2fd6:	80 bd       	out	0x20, r24	; 32
		  UBRR0L=BaudrateValue;		
    2fd8:	29 b9       	out	0x09, r18	; 9
		  //Register
		  UCSR0B=RegB; 
    2fda:	7a b9       	out	0x0a, r23	; 10
		  UCSR0C=RegC; 
    2fdc:	60 bd       	out	0x20, r22	; 32
    2fde:	08 c0       	rjmp	.+16     	; 0x2ff0 <_uart_setting+0xc2>
	      break;
     case 1:
		  //Write
		  //BaudrateSetting
          UBRR1H=BaudrateValue>>8;
    2fe0:	bb 27       	eor	r27, r27
    2fe2:	a5 2f       	mov	r26, r21
    2fe4:	94 2f       	mov	r25, r20
    2fe6:	83 2f       	mov	r24, r19
    2fe8:	8c bf       	out	0x3c, r24	; 60
		  UBRR1L=BaudrateValue;		
    2fea:	20 b9       	out	0x00, r18	; 0

		  //Register
		  UCSR1B=RegB; 
    2fec:	71 b9       	out	0x01, r23	; 1
		  UCSR1C=RegC;
    2fee:	6c bf       	out	0x3c, r22	; 60
	      break;
	 }  
}
    2ff0:	1f 91       	pop	r17
    2ff2:	0f 91       	pop	r16
    2ff4:	ff 90       	pop	r15
    2ff6:	ef 90       	pop	r14
    2ff8:	df 90       	pop	r13
    2ffa:	cf 90       	pop	r12
    2ffc:	bf 90       	pop	r11
    2ffe:	af 90       	pop	r10
    3000:	08 95       	ret

00003002 <_uart_baudrate>:
	    UCSR0C=(1<<URSEL0) | (1<<UPM01) | (1<<UCSZ01) | (1<<UCSZ00); // UPM01 untuk set even parity
	    UBRR0H=0;UBRR0L=158;// baud 5787       
	}
}

void _uart_baudrate(unsigned char __com, unsigned long __baudrate){
    3002:	1f 93       	push	r17
    3004:	18 2f       	mov	r17, r24
    3006:	9a 01       	movw	r18, r20
    3008:	ab 01       	movw	r20, r22
	unsigned long __br;

	__br = (unsigned long)((_CPU_DEFAULT + (__baudrate * 8)) / (__baudrate * 16) - 1);
    300a:	ca 01       	movw	r24, r20
    300c:	b9 01       	movw	r22, r18
    300e:	60 50       	subi	r22, 0x00	; 0
    3010:	70 4e       	sbci	r23, 0xE0	; 224
    3012:	83 4e       	sbci	r24, 0xE3	; 227
    3014:	9f 4f       	sbci	r25, 0xFF	; 255
    3016:	f3 e0       	ldi	r31, 0x03	; 3
    3018:	66 0f       	add	r22, r22
    301a:	77 1f       	adc	r23, r23
    301c:	88 1f       	adc	r24, r24
    301e:	99 1f       	adc	r25, r25
    3020:	fa 95       	dec	r31
    3022:	d1 f7       	brne	.-12     	; 0x3018 <_uart_baudrate+0x16>
    3024:	e4 e0       	ldi	r30, 0x04	; 4
    3026:	22 0f       	add	r18, r18
    3028:	33 1f       	adc	r19, r19
    302a:	44 1f       	adc	r20, r20
    302c:	55 1f       	adc	r21, r21
    302e:	ea 95       	dec	r30
    3030:	d1 f7       	brne	.-12     	; 0x3026 <_uart_baudrate+0x24>
    3032:	0e 94 81 1b 	call	0x3702	; 0x3702 <__udivmodsi4>
    3036:	21 50       	subi	r18, 0x01	; 1
    3038:	30 40       	sbci	r19, 0x00	; 0
    303a:	40 40       	sbci	r20, 0x00	; 0
    303c:	50 40       	sbci	r21, 0x00	; 0
    303e:	bb 27       	eor	r27, r27
    3040:	a5 2f       	mov	r26, r21
    3042:	94 2f       	mov	r25, r20
    3044:	83 2f       	mov	r24, r19

	if(__com){
    3046:	11 23       	and	r17, r17
    3048:	19 f0       	breq	.+6      	; 0x3050 <_uart_baudrate+0x4e>
		UBRR1L = __br;
    304a:	20 b9       	out	0x00, r18	; 0
		UBRR1H = __br >> 8;
    304c:	8c bf       	out	0x3c, r24	; 60
    304e:	02 c0       	rjmp	.+4      	; 0x3054 <_uart_baudrate+0x52>
	}
	else{
		UBRR0L = __br;
    3050:	29 b9       	out	0x09, r18	; 9
		UBRR0H = __br >> 8;
    3052:	80 bd       	out	0x20, r24	; 32
	}
}
    3054:	1f 91       	pop	r17
    3056:	08 95       	ret

00003058 <_uart_init>:
		  UCSR1C=RegC;
	      break;
	 }  
}

void _uart_init(unsigned char __com, unsigned long __baudrate){
    3058:	ef 92       	push	r14
    305a:	ff 92       	push	r15
    305c:	0f 93       	push	r16
    305e:	1f 93       	push	r17
    3060:	98 2f       	mov	r25, r24
    3062:	7a 01       	movw	r14, r20
    3064:	8b 01       	movw	r16, r22
	if(__com){
    3066:	88 23       	and	r24, r24
    3068:	29 f0       	breq	.+10     	; 0x3074 <_uart_init+0x1c>
		UCSR1B = _BV(RXCIE1) | _BV(RXEN1) | _BV(TXEN1);
    306a:	88 e9       	ldi	r24, 0x98	; 152
    306c:	81 b9       	out	0x01, r24	; 1
		UCSR1C = _BV(UCSZ11) | _BV(UCSZ10);
    306e:	86 e0       	ldi	r24, 0x06	; 6
    3070:	8c bf       	out	0x3c, r24	; 60
    3072:	04 c0       	rjmp	.+8      	; 0x307c <_uart_init+0x24>
	}
	else{
		UCSR0B = _BV(RXCIE0) | _BV(RXEN0) | _BV(TXEN0);
    3074:	88 e9       	ldi	r24, 0x98	; 152
    3076:	8a b9       	out	0x0a, r24	; 10
		UCSR0C = _BV(UCSZ01) | _BV(UCSZ00);
    3078:	86 e0       	ldi	r24, 0x06	; 6
    307a:	80 bd       	out	0x20, r24	; 32
	}
    

	_uart_baudrate(__com, __baudrate);
    307c:	89 2f       	mov	r24, r25
    307e:	b8 01       	movw	r22, r16
    3080:	a7 01       	movw	r20, r14
    3082:	0e 94 01 18 	call	0x3002	; 0x3002 <_uart_baudrate>

	if (__baudrate==5787){
    3086:	8b e9       	ldi	r24, 0x9B	; 155
    3088:	e8 16       	cp	r14, r24
    308a:	86 e1       	ldi	r24, 0x16	; 22
    308c:	f8 06       	cpc	r15, r24
    308e:	80 e0       	ldi	r24, 0x00	; 0
    3090:	08 07       	cpc	r16, r24
    3092:	80 e0       	ldi	r24, 0x00	; 0
    3094:	18 07       	cpc	r17, r24
    3096:	39 f4       	brne	.+14     	; 0x30a6 <_uart_init+0x4e>
	    UCSR0B=_BV(RXCIE0) | _BV(RXEN0) | _BV(TXEN0);
    3098:	88 e9       	ldi	r24, 0x98	; 152
    309a:	8a b9       	out	0x0a, r24	; 10
	    UCSR0C=(1<<URSEL0) | (1<<UPM01) | (1<<UCSZ01) | (1<<UCSZ00); // UPM01 untuk set even parity
    309c:	86 ea       	ldi	r24, 0xA6	; 166
    309e:	80 bd       	out	0x20, r24	; 32
	    UBRR0H=0;UBRR0L=158;// baud 5787       
    30a0:	10 bc       	out	0x20, r1	; 32
    30a2:	8e e9       	ldi	r24, 0x9E	; 158
    30a4:	89 b9       	out	0x09, r24	; 9
	}
}
    30a6:	1f 91       	pop	r17
    30a8:	0f 91       	pop	r16
    30aa:	ff 90       	pop	r15
    30ac:	ef 90       	pop	r14
    30ae:	08 95       	ret

000030b0 <_uart>:
		UBRR0H = __br >> 8;
	}
}

unsigned char _uart(unsigned char __com, unsigned char __dir, unsigned char __chr){
	if(__com){
    30b0:	88 23       	and	r24, r24
    30b2:	51 f0       	breq	.+20     	; 0x30c8 <_uart+0x18>
		if(__dir){
    30b4:	66 23       	and	r22, r22
    30b6:	21 f0       	breq	.+8      	; 0x30c0 <_uart+0x10>
			loop_until_bit_is_set(UCSR1A, UDRE1);
    30b8:	15 9b       	sbis	0x02, 5	; 2
    30ba:	fe cf       	rjmp	.-4      	; 0x30b8 <_uart+0x8>
			UDR1 = __chr;
    30bc:	43 b9       	out	0x03, r20	; 3
    30be:	09 c0       	rjmp	.+18     	; 0x30d2 <_uart+0x22>
		}
		else{
			loop_until_bit_is_set(UCSR1A, RXC1);
    30c0:	17 9b       	sbis	0x02, 7	; 2
    30c2:	fe cf       	rjmp	.-4      	; 0x30c0 <_uart+0x10>
			return UDR1;
    30c4:	83 b1       	in	r24, 0x03	; 3
    30c6:	08 95       	ret
		}
	}
	else{
		if(__dir){
    30c8:	66 23       	and	r22, r22
    30ca:	29 f0       	breq	.+10     	; 0x30d6 <_uart+0x26>
			loop_until_bit_is_set(UCSR0A, UDRE0);
    30cc:	5d 9b       	sbis	0x0b, 5	; 11
    30ce:	fe cf       	rjmp	.-4      	; 0x30cc <_uart+0x1c>
			UDR0 = __chr;
    30d0:	4c b9       	out	0x0c, r20	; 12
    30d2:	81 e0       	ldi	r24, 0x01	; 1
    30d4:	08 95       	ret
		}
		else{
			loop_until_bit_is_set(UCSR0A,  RXC0);
    30d6:	5f 9b       	sbis	0x0b, 7	; 11
    30d8:	fe cf       	rjmp	.-4      	; 0x30d6 <_uart+0x26>
			return UDR0;
    30da:	8c b1       	in	r24, 0x0c	; 12
		}

	}

	return 1;
}
    30dc:	08 95       	ret

000030de <_uart_print>:

void _uart_print(unsigned char __com, unsigned char __ret, char *__str){
    30de:	0f 93       	push	r16
    30e0:	1f 93       	push	r17
    30e2:	cf 93       	push	r28
    30e4:	df 93       	push	r29
    30e6:	18 2f       	mov	r17, r24
    30e8:	06 2f       	mov	r16, r22
    30ea:	ea 01       	movw	r28, r20
	if(strlen(__str)>0)
    30ec:	88 81       	ld	r24, Y
    30ee:	88 23       	and	r24, r24
    30f0:	31 f4       	brne	.+12     	; 0x30fe <_uart_print+0x20>
    30f2:	08 c0       	rjmp	.+16     	; 0x3104 <_uart_print+0x26>
		while(*__str) _uart(__com, 1, *__str++);
    30f4:	21 96       	adiw	r28, 0x01	; 1
    30f6:	81 2f       	mov	r24, r17
    30f8:	61 e0       	ldi	r22, 0x01	; 1
    30fa:	0e 94 58 18 	call	0x30b0	; 0x30b0 <_uart>
    30fe:	48 81       	ld	r20, Y
    3100:	44 23       	and	r20, r20
    3102:	c1 f7       	brne	.-16     	; 0x30f4 <_uart_print+0x16>

	if(__ret){
    3104:	00 23       	and	r16, r16
    3106:	51 f0       	breq	.+20     	; 0x311c <_uart_print+0x3e>
		_uart(__com, 1, 0x0D);
    3108:	81 2f       	mov	r24, r17
    310a:	61 e0       	ldi	r22, 0x01	; 1
    310c:	4d e0       	ldi	r20, 0x0D	; 13
    310e:	0e 94 58 18 	call	0x30b0	; 0x30b0 <_uart>
		_uart(__com, 1, 0x0A);
    3112:	81 2f       	mov	r24, r17
    3114:	61 e0       	ldi	r22, 0x01	; 1
    3116:	4a e0       	ldi	r20, 0x0A	; 10
    3118:	0e 94 58 18 	call	0x30b0	; 0x30b0 <_uart>
    311c:	82 ee       	ldi	r24, 0xE2	; 226
    311e:	94 e0       	ldi	r25, 0x04	; 4
    3120:	01 97       	sbiw	r24, 0x01	; 1
    3122:	f1 f7       	brne	.-4      	; 0x3120 <_uart_print+0x42>
	}
	_delay_ms(5);
}
    3124:	df 91       	pop	r29
    3126:	cf 91       	pop	r28
    3128:	1f 91       	pop	r17
    312a:	0f 91       	pop	r16
    312c:	08 95       	ret

0000312e <_uart_printf>:

void _uart_printf(unsigned char __com, unsigned char __ret, char *__str){
    312e:	0f 93       	push	r16
    3130:	1f 93       	push	r17
    3132:	cf 93       	push	r28
    3134:	df 93       	push	r29
    3136:	18 2f       	mov	r17, r24
    3138:	06 2f       	mov	r16, r22
    313a:	ea 01       	movw	r28, r20
    313c:	07 c0       	rjmp	.+14     	; 0x314c <_uart_printf+0x1e>
	while(pgm_read_byte(&(*__str)))
		_uart(__com, 1, pgm_read_byte(&(*__str++)));
    313e:	21 96       	adiw	r28, 0x01	; 1
    3140:	f9 01       	movw	r30, r18
    3142:	44 91       	lpm	r20, Z+
    3144:	81 2f       	mov	r24, r17
    3146:	61 e0       	ldi	r22, 0x01	; 1
    3148:	0e 94 58 18 	call	0x30b0	; 0x30b0 <_uart>
    314c:	9e 01       	movw	r18, r28
	}
	_delay_ms(5);
}

void _uart_printf(unsigned char __com, unsigned char __ret, char *__str){
	while(pgm_read_byte(&(*__str)))
    314e:	fe 01       	movw	r30, r28
    3150:	84 91       	lpm	r24, Z+
    3152:	88 23       	and	r24, r24
    3154:	a1 f7       	brne	.-24     	; 0x313e <_uart_printf+0x10>
		_uart(__com, 1, pgm_read_byte(&(*__str++)));

	if(__ret){
    3156:	00 23       	and	r16, r16
    3158:	51 f0       	breq	.+20     	; 0x316e <_uart_printf+0x40>
		_uart(__com, 1, 0x0D);
    315a:	81 2f       	mov	r24, r17
    315c:	61 e0       	ldi	r22, 0x01	; 1
    315e:	4d e0       	ldi	r20, 0x0D	; 13
    3160:	0e 94 58 18 	call	0x30b0	; 0x30b0 <_uart>
		_uart(__com, 1, 0x0A);
    3164:	81 2f       	mov	r24, r17
    3166:	61 e0       	ldi	r22, 0x01	; 1
    3168:	4a e0       	ldi	r20, 0x0A	; 10
    316a:	0e 94 58 18 	call	0x30b0	; 0x30b0 <_uart>
    316e:	86 ea       	ldi	r24, 0xA6	; 166
    3170:	9e e0       	ldi	r25, 0x0E	; 14
    3172:	01 97       	sbiw	r24, 0x01	; 1
    3174:	f1 f7       	brne	.-4      	; 0x3172 <_uart_printf+0x44>
	}
	_delay_ms(15);
}
    3176:	df 91       	pop	r29
    3178:	cf 91       	pop	r28
    317a:	1f 91       	pop	r17
    317c:	0f 91       	pop	r16
    317e:	08 95       	ret

00003180 <sprintf_P>:
    3180:	ae e0       	ldi	r26, 0x0E	; 14
    3182:	b0 e0       	ldi	r27, 0x00	; 0
    3184:	e6 ec       	ldi	r30, 0xC6	; 198
    3186:	f8 e1       	ldi	r31, 0x18	; 24
    3188:	0c 94 b1 1b 	jmp	0x3762	; 0x3762 <__prologue_saves__+0x1c>
    318c:	0d 89       	ldd	r16, Y+21	; 0x15
    318e:	1e 89       	ldd	r17, Y+22	; 0x16
    3190:	8e e0       	ldi	r24, 0x0E	; 14
    3192:	8c 83       	std	Y+4, r24	; 0x04
    3194:	1a 83       	std	Y+2, r17	; 0x02
    3196:	09 83       	std	Y+1, r16	; 0x01
    3198:	8f ef       	ldi	r24, 0xFF	; 255
    319a:	9f e7       	ldi	r25, 0x7F	; 127
    319c:	9e 83       	std	Y+6, r25	; 0x06
    319e:	8d 83       	std	Y+5, r24	; 0x05
    31a0:	9e 01       	movw	r18, r28
    31a2:	27 5e       	subi	r18, 0xE7	; 231
    31a4:	3f 4f       	sbci	r19, 0xFF	; 255
    31a6:	ce 01       	movw	r24, r28
    31a8:	01 96       	adiw	r24, 0x01	; 1
    31aa:	6f 89       	ldd	r22, Y+23	; 0x17
    31ac:	78 8d       	ldd	r23, Y+24	; 0x18
    31ae:	a9 01       	movw	r20, r18
    31b0:	0e 94 e4 18 	call	0x31c8	; 0x31c8 <vfprintf>
    31b4:	2f 81       	ldd	r18, Y+7	; 0x07
    31b6:	38 85       	ldd	r19, Y+8	; 0x08
    31b8:	02 0f       	add	r16, r18
    31ba:	13 1f       	adc	r17, r19
    31bc:	f8 01       	movw	r30, r16
    31be:	10 82       	st	Z, r1
    31c0:	2e 96       	adiw	r28, 0x0e	; 14
    31c2:	e4 e0       	ldi	r30, 0x04	; 4
    31c4:	0c 94 cd 1b 	jmp	0x379a	; 0x379a <__epilogue_restores__+0x1c>

000031c8 <vfprintf>:
    31c8:	ab e0       	ldi	r26, 0x0B	; 11
    31ca:	b0 e0       	ldi	r27, 0x00	; 0
    31cc:	ea ee       	ldi	r30, 0xEA	; 234
    31ce:	f8 e1       	ldi	r31, 0x18	; 24
    31d0:	0c 94 a3 1b 	jmp	0x3746	; 0x3746 <__prologue_saves__>
    31d4:	3c 01       	movw	r6, r24
    31d6:	2b 01       	movw	r4, r22
    31d8:	5a 01       	movw	r10, r20
    31da:	fc 01       	movw	r30, r24
    31dc:	17 82       	std	Z+7, r1	; 0x07
    31de:	16 82       	std	Z+6, r1	; 0x06
    31e0:	83 81       	ldd	r24, Z+3	; 0x03
    31e2:	81 fd       	sbrc	r24, 1
    31e4:	03 c0       	rjmp	.+6      	; 0x31ec <vfprintf+0x24>
    31e6:	6f ef       	ldi	r22, 0xFF	; 255
    31e8:	7f ef       	ldi	r23, 0xFF	; 255
    31ea:	c6 c1       	rjmp	.+908    	; 0x3578 <vfprintf+0x3b0>
    31ec:	9a e0       	ldi	r25, 0x0A	; 10
    31ee:	89 2e       	mov	r8, r25
    31f0:	1e 01       	movw	r2, r28
    31f2:	08 94       	sec
    31f4:	21 1c       	adc	r2, r1
    31f6:	31 1c       	adc	r3, r1
    31f8:	f3 01       	movw	r30, r6
    31fa:	23 81       	ldd	r18, Z+3	; 0x03
    31fc:	f2 01       	movw	r30, r4
    31fe:	23 fd       	sbrc	r18, 3
    3200:	85 91       	lpm	r24, Z+
    3202:	23 ff       	sbrs	r18, 3
    3204:	81 91       	ld	r24, Z+
    3206:	2f 01       	movw	r4, r30
    3208:	88 23       	and	r24, r24
    320a:	09 f4       	brne	.+2      	; 0x320e <vfprintf+0x46>
    320c:	b2 c1       	rjmp	.+868    	; 0x3572 <vfprintf+0x3aa>
    320e:	85 32       	cpi	r24, 0x25	; 37
    3210:	39 f4       	brne	.+14     	; 0x3220 <vfprintf+0x58>
    3212:	23 fd       	sbrc	r18, 3
    3214:	85 91       	lpm	r24, Z+
    3216:	23 ff       	sbrs	r18, 3
    3218:	81 91       	ld	r24, Z+
    321a:	2f 01       	movw	r4, r30
    321c:	85 32       	cpi	r24, 0x25	; 37
    321e:	29 f4       	brne	.+10     	; 0x322a <vfprintf+0x62>
    3220:	90 e0       	ldi	r25, 0x00	; 0
    3222:	b3 01       	movw	r22, r6
    3224:	0e 94 d7 1a 	call	0x35ae	; 0x35ae <fputc>
    3228:	e7 cf       	rjmp	.-50     	; 0x31f8 <vfprintf+0x30>
    322a:	98 2f       	mov	r25, r24
    322c:	ff 24       	eor	r15, r15
    322e:	ee 24       	eor	r14, r14
    3230:	99 24       	eor	r9, r9
    3232:	ff e1       	ldi	r31, 0x1F	; 31
    3234:	ff 15       	cp	r31, r15
    3236:	d0 f0       	brcs	.+52     	; 0x326c <vfprintf+0xa4>
    3238:	9b 32       	cpi	r25, 0x2B	; 43
    323a:	69 f0       	breq	.+26     	; 0x3256 <vfprintf+0x8e>
    323c:	9c 32       	cpi	r25, 0x2C	; 44
    323e:	28 f4       	brcc	.+10     	; 0x324a <vfprintf+0x82>
    3240:	90 32       	cpi	r25, 0x20	; 32
    3242:	59 f0       	breq	.+22     	; 0x325a <vfprintf+0x92>
    3244:	93 32       	cpi	r25, 0x23	; 35
    3246:	91 f4       	brne	.+36     	; 0x326c <vfprintf+0xa4>
    3248:	0e c0       	rjmp	.+28     	; 0x3266 <vfprintf+0x9e>
    324a:	9d 32       	cpi	r25, 0x2D	; 45
    324c:	49 f0       	breq	.+18     	; 0x3260 <vfprintf+0x98>
    324e:	90 33       	cpi	r25, 0x30	; 48
    3250:	69 f4       	brne	.+26     	; 0x326c <vfprintf+0xa4>
    3252:	41 e0       	ldi	r20, 0x01	; 1
    3254:	24 c0       	rjmp	.+72     	; 0x329e <vfprintf+0xd6>
    3256:	52 e0       	ldi	r21, 0x02	; 2
    3258:	f5 2a       	or	r15, r21
    325a:	84 e0       	ldi	r24, 0x04	; 4
    325c:	f8 2a       	or	r15, r24
    325e:	28 c0       	rjmp	.+80     	; 0x32b0 <vfprintf+0xe8>
    3260:	98 e0       	ldi	r25, 0x08	; 8
    3262:	f9 2a       	or	r15, r25
    3264:	25 c0       	rjmp	.+74     	; 0x32b0 <vfprintf+0xe8>
    3266:	e0 e1       	ldi	r30, 0x10	; 16
    3268:	fe 2a       	or	r15, r30
    326a:	22 c0       	rjmp	.+68     	; 0x32b0 <vfprintf+0xe8>
    326c:	f7 fc       	sbrc	r15, 7
    326e:	29 c0       	rjmp	.+82     	; 0x32c2 <vfprintf+0xfa>
    3270:	89 2f       	mov	r24, r25
    3272:	80 53       	subi	r24, 0x30	; 48
    3274:	8a 30       	cpi	r24, 0x0A	; 10
    3276:	70 f4       	brcc	.+28     	; 0x3294 <vfprintf+0xcc>
    3278:	f6 fe       	sbrs	r15, 6
    327a:	05 c0       	rjmp	.+10     	; 0x3286 <vfprintf+0xbe>
    327c:	98 9c       	mul	r9, r8
    327e:	90 2c       	mov	r9, r0
    3280:	11 24       	eor	r1, r1
    3282:	98 0e       	add	r9, r24
    3284:	15 c0       	rjmp	.+42     	; 0x32b0 <vfprintf+0xe8>
    3286:	e8 9c       	mul	r14, r8
    3288:	e0 2c       	mov	r14, r0
    328a:	11 24       	eor	r1, r1
    328c:	e8 0e       	add	r14, r24
    328e:	f0 e2       	ldi	r31, 0x20	; 32
    3290:	ff 2a       	or	r15, r31
    3292:	0e c0       	rjmp	.+28     	; 0x32b0 <vfprintf+0xe8>
    3294:	9e 32       	cpi	r25, 0x2E	; 46
    3296:	29 f4       	brne	.+10     	; 0x32a2 <vfprintf+0xda>
    3298:	f6 fc       	sbrc	r15, 6
    329a:	6b c1       	rjmp	.+726    	; 0x3572 <vfprintf+0x3aa>
    329c:	40 e4       	ldi	r20, 0x40	; 64
    329e:	f4 2a       	or	r15, r20
    32a0:	07 c0       	rjmp	.+14     	; 0x32b0 <vfprintf+0xe8>
    32a2:	9c 36       	cpi	r25, 0x6C	; 108
    32a4:	19 f4       	brne	.+6      	; 0x32ac <vfprintf+0xe4>
    32a6:	50 e8       	ldi	r21, 0x80	; 128
    32a8:	f5 2a       	or	r15, r21
    32aa:	02 c0       	rjmp	.+4      	; 0x32b0 <vfprintf+0xe8>
    32ac:	98 36       	cpi	r25, 0x68	; 104
    32ae:	49 f4       	brne	.+18     	; 0x32c2 <vfprintf+0xfa>
    32b0:	f2 01       	movw	r30, r4
    32b2:	23 fd       	sbrc	r18, 3
    32b4:	95 91       	lpm	r25, Z+
    32b6:	23 ff       	sbrs	r18, 3
    32b8:	91 91       	ld	r25, Z+
    32ba:	2f 01       	movw	r4, r30
    32bc:	99 23       	and	r25, r25
    32be:	09 f0       	breq	.+2      	; 0x32c2 <vfprintf+0xfa>
    32c0:	b8 cf       	rjmp	.-144    	; 0x3232 <vfprintf+0x6a>
    32c2:	89 2f       	mov	r24, r25
    32c4:	85 54       	subi	r24, 0x45	; 69
    32c6:	83 30       	cpi	r24, 0x03	; 3
    32c8:	18 f0       	brcs	.+6      	; 0x32d0 <vfprintf+0x108>
    32ca:	80 52       	subi	r24, 0x20	; 32
    32cc:	83 30       	cpi	r24, 0x03	; 3
    32ce:	38 f4       	brcc	.+14     	; 0x32de <vfprintf+0x116>
    32d0:	44 e0       	ldi	r20, 0x04	; 4
    32d2:	50 e0       	ldi	r21, 0x00	; 0
    32d4:	a4 0e       	add	r10, r20
    32d6:	b5 1e       	adc	r11, r21
    32d8:	5f e3       	ldi	r21, 0x3F	; 63
    32da:	59 83       	std	Y+1, r21	; 0x01
    32dc:	0f c0       	rjmp	.+30     	; 0x32fc <vfprintf+0x134>
    32de:	93 36       	cpi	r25, 0x63	; 99
    32e0:	31 f0       	breq	.+12     	; 0x32ee <vfprintf+0x126>
    32e2:	93 37       	cpi	r25, 0x73	; 115
    32e4:	79 f0       	breq	.+30     	; 0x3304 <vfprintf+0x13c>
    32e6:	93 35       	cpi	r25, 0x53	; 83
    32e8:	09 f0       	breq	.+2      	; 0x32ec <vfprintf+0x124>
    32ea:	56 c0       	rjmp	.+172    	; 0x3398 <vfprintf+0x1d0>
    32ec:	20 c0       	rjmp	.+64     	; 0x332e <vfprintf+0x166>
    32ee:	f5 01       	movw	r30, r10
    32f0:	80 81       	ld	r24, Z
    32f2:	89 83       	std	Y+1, r24	; 0x01
    32f4:	42 e0       	ldi	r20, 0x02	; 2
    32f6:	50 e0       	ldi	r21, 0x00	; 0
    32f8:	a4 0e       	add	r10, r20
    32fa:	b5 1e       	adc	r11, r21
    32fc:	61 01       	movw	r12, r2
    32fe:	01 e0       	ldi	r16, 0x01	; 1
    3300:	10 e0       	ldi	r17, 0x00	; 0
    3302:	12 c0       	rjmp	.+36     	; 0x3328 <vfprintf+0x160>
    3304:	f5 01       	movw	r30, r10
    3306:	c0 80       	ld	r12, Z
    3308:	d1 80       	ldd	r13, Z+1	; 0x01
    330a:	f6 fc       	sbrc	r15, 6
    330c:	03 c0       	rjmp	.+6      	; 0x3314 <vfprintf+0x14c>
    330e:	6f ef       	ldi	r22, 0xFF	; 255
    3310:	7f ef       	ldi	r23, 0xFF	; 255
    3312:	02 c0       	rjmp	.+4      	; 0x3318 <vfprintf+0x150>
    3314:	69 2d       	mov	r22, r9
    3316:	70 e0       	ldi	r23, 0x00	; 0
    3318:	42 e0       	ldi	r20, 0x02	; 2
    331a:	50 e0       	ldi	r21, 0x00	; 0
    331c:	a4 0e       	add	r10, r20
    331e:	b5 1e       	adc	r11, r21
    3320:	c6 01       	movw	r24, r12
    3322:	0e 94 cc 1a 	call	0x3598	; 0x3598 <strnlen>
    3326:	8c 01       	movw	r16, r24
    3328:	5f e7       	ldi	r21, 0x7F	; 127
    332a:	f5 22       	and	r15, r21
    332c:	14 c0       	rjmp	.+40     	; 0x3356 <vfprintf+0x18e>
    332e:	f5 01       	movw	r30, r10
    3330:	c0 80       	ld	r12, Z
    3332:	d1 80       	ldd	r13, Z+1	; 0x01
    3334:	f6 fc       	sbrc	r15, 6
    3336:	03 c0       	rjmp	.+6      	; 0x333e <vfprintf+0x176>
    3338:	6f ef       	ldi	r22, 0xFF	; 255
    333a:	7f ef       	ldi	r23, 0xFF	; 255
    333c:	02 c0       	rjmp	.+4      	; 0x3342 <vfprintf+0x17a>
    333e:	69 2d       	mov	r22, r9
    3340:	70 e0       	ldi	r23, 0x00	; 0
    3342:	42 e0       	ldi	r20, 0x02	; 2
    3344:	50 e0       	ldi	r21, 0x00	; 0
    3346:	a4 0e       	add	r10, r20
    3348:	b5 1e       	adc	r11, r21
    334a:	c6 01       	movw	r24, r12
    334c:	0e 94 c1 1a 	call	0x3582	; 0x3582 <strnlen_P>
    3350:	8c 01       	movw	r16, r24
    3352:	50 e8       	ldi	r21, 0x80	; 128
    3354:	f5 2a       	or	r15, r21
    3356:	f3 fe       	sbrs	r15, 3
    3358:	07 c0       	rjmp	.+14     	; 0x3368 <vfprintf+0x1a0>
    335a:	1a c0       	rjmp	.+52     	; 0x3390 <vfprintf+0x1c8>
    335c:	80 e2       	ldi	r24, 0x20	; 32
    335e:	90 e0       	ldi	r25, 0x00	; 0
    3360:	b3 01       	movw	r22, r6
    3362:	0e 94 d7 1a 	call	0x35ae	; 0x35ae <fputc>
    3366:	ea 94       	dec	r14
    3368:	8e 2d       	mov	r24, r14
    336a:	90 e0       	ldi	r25, 0x00	; 0
    336c:	08 17       	cp	r16, r24
    336e:	19 07       	cpc	r17, r25
    3370:	a8 f3       	brcs	.-22     	; 0x335c <vfprintf+0x194>
    3372:	0e c0       	rjmp	.+28     	; 0x3390 <vfprintf+0x1c8>
    3374:	f6 01       	movw	r30, r12
    3376:	f7 fc       	sbrc	r15, 7
    3378:	85 91       	lpm	r24, Z+
    337a:	f7 fe       	sbrs	r15, 7
    337c:	81 91       	ld	r24, Z+
    337e:	6f 01       	movw	r12, r30
    3380:	90 e0       	ldi	r25, 0x00	; 0
    3382:	b3 01       	movw	r22, r6
    3384:	0e 94 d7 1a 	call	0x35ae	; 0x35ae <fputc>
    3388:	e1 10       	cpse	r14, r1
    338a:	ea 94       	dec	r14
    338c:	01 50       	subi	r16, 0x01	; 1
    338e:	10 40       	sbci	r17, 0x00	; 0
    3390:	01 15       	cp	r16, r1
    3392:	11 05       	cpc	r17, r1
    3394:	79 f7       	brne	.-34     	; 0x3374 <vfprintf+0x1ac>
    3396:	ea c0       	rjmp	.+468    	; 0x356c <vfprintf+0x3a4>
    3398:	94 36       	cpi	r25, 0x64	; 100
    339a:	11 f0       	breq	.+4      	; 0x33a0 <vfprintf+0x1d8>
    339c:	99 36       	cpi	r25, 0x69	; 105
    339e:	69 f5       	brne	.+90     	; 0x33fa <vfprintf+0x232>
    33a0:	f7 fe       	sbrs	r15, 7
    33a2:	08 c0       	rjmp	.+16     	; 0x33b4 <vfprintf+0x1ec>
    33a4:	f5 01       	movw	r30, r10
    33a6:	20 81       	ld	r18, Z
    33a8:	31 81       	ldd	r19, Z+1	; 0x01
    33aa:	42 81       	ldd	r20, Z+2	; 0x02
    33ac:	53 81       	ldd	r21, Z+3	; 0x03
    33ae:	84 e0       	ldi	r24, 0x04	; 4
    33b0:	90 e0       	ldi	r25, 0x00	; 0
    33b2:	0a c0       	rjmp	.+20     	; 0x33c8 <vfprintf+0x200>
    33b4:	f5 01       	movw	r30, r10
    33b6:	80 81       	ld	r24, Z
    33b8:	91 81       	ldd	r25, Z+1	; 0x01
    33ba:	9c 01       	movw	r18, r24
    33bc:	44 27       	eor	r20, r20
    33be:	37 fd       	sbrc	r19, 7
    33c0:	40 95       	com	r20
    33c2:	54 2f       	mov	r21, r20
    33c4:	82 e0       	ldi	r24, 0x02	; 2
    33c6:	90 e0       	ldi	r25, 0x00	; 0
    33c8:	a8 0e       	add	r10, r24
    33ca:	b9 1e       	adc	r11, r25
    33cc:	9f e6       	ldi	r25, 0x6F	; 111
    33ce:	f9 22       	and	r15, r25
    33d0:	57 ff       	sbrs	r21, 7
    33d2:	09 c0       	rjmp	.+18     	; 0x33e6 <vfprintf+0x21e>
    33d4:	50 95       	com	r21
    33d6:	40 95       	com	r20
    33d8:	30 95       	com	r19
    33da:	21 95       	neg	r18
    33dc:	3f 4f       	sbci	r19, 0xFF	; 255
    33de:	4f 4f       	sbci	r20, 0xFF	; 255
    33e0:	5f 4f       	sbci	r21, 0xFF	; 255
    33e2:	e0 e8       	ldi	r30, 0x80	; 128
    33e4:	fe 2a       	or	r15, r30
    33e6:	ca 01       	movw	r24, r20
    33e8:	b9 01       	movw	r22, r18
    33ea:	a1 01       	movw	r20, r2
    33ec:	2a e0       	ldi	r18, 0x0A	; 10
    33ee:	30 e0       	ldi	r19, 0x00	; 0
    33f0:	0e 94 03 1b 	call	0x3606	; 0x3606 <__ultoa_invert>
    33f4:	d8 2e       	mov	r13, r24
    33f6:	d2 18       	sub	r13, r2
    33f8:	40 c0       	rjmp	.+128    	; 0x347a <vfprintf+0x2b2>
    33fa:	95 37       	cpi	r25, 0x75	; 117
    33fc:	29 f4       	brne	.+10     	; 0x3408 <vfprintf+0x240>
    33fe:	1f 2d       	mov	r17, r15
    3400:	1f 7e       	andi	r17, 0xEF	; 239
    3402:	2a e0       	ldi	r18, 0x0A	; 10
    3404:	30 e0       	ldi	r19, 0x00	; 0
    3406:	1d c0       	rjmp	.+58     	; 0x3442 <vfprintf+0x27a>
    3408:	1f 2d       	mov	r17, r15
    340a:	19 7f       	andi	r17, 0xF9	; 249
    340c:	9f 36       	cpi	r25, 0x6F	; 111
    340e:	61 f0       	breq	.+24     	; 0x3428 <vfprintf+0x260>
    3410:	90 37       	cpi	r25, 0x70	; 112
    3412:	20 f4       	brcc	.+8      	; 0x341c <vfprintf+0x254>
    3414:	98 35       	cpi	r25, 0x58	; 88
    3416:	09 f0       	breq	.+2      	; 0x341a <vfprintf+0x252>
    3418:	ac c0       	rjmp	.+344    	; 0x3572 <vfprintf+0x3aa>
    341a:	0f c0       	rjmp	.+30     	; 0x343a <vfprintf+0x272>
    341c:	90 37       	cpi	r25, 0x70	; 112
    341e:	39 f0       	breq	.+14     	; 0x342e <vfprintf+0x266>
    3420:	98 37       	cpi	r25, 0x78	; 120
    3422:	09 f0       	breq	.+2      	; 0x3426 <vfprintf+0x25e>
    3424:	a6 c0       	rjmp	.+332    	; 0x3572 <vfprintf+0x3aa>
    3426:	04 c0       	rjmp	.+8      	; 0x3430 <vfprintf+0x268>
    3428:	28 e0       	ldi	r18, 0x08	; 8
    342a:	30 e0       	ldi	r19, 0x00	; 0
    342c:	0a c0       	rjmp	.+20     	; 0x3442 <vfprintf+0x27a>
    342e:	10 61       	ori	r17, 0x10	; 16
    3430:	14 fd       	sbrc	r17, 4
    3432:	14 60       	ori	r17, 0x04	; 4
    3434:	20 e1       	ldi	r18, 0x10	; 16
    3436:	30 e0       	ldi	r19, 0x00	; 0
    3438:	04 c0       	rjmp	.+8      	; 0x3442 <vfprintf+0x27a>
    343a:	14 fd       	sbrc	r17, 4
    343c:	16 60       	ori	r17, 0x06	; 6
    343e:	20 e1       	ldi	r18, 0x10	; 16
    3440:	32 e0       	ldi	r19, 0x02	; 2
    3442:	17 ff       	sbrs	r17, 7
    3444:	08 c0       	rjmp	.+16     	; 0x3456 <vfprintf+0x28e>
    3446:	f5 01       	movw	r30, r10
    3448:	60 81       	ld	r22, Z
    344a:	71 81       	ldd	r23, Z+1	; 0x01
    344c:	82 81       	ldd	r24, Z+2	; 0x02
    344e:	93 81       	ldd	r25, Z+3	; 0x03
    3450:	44 e0       	ldi	r20, 0x04	; 4
    3452:	50 e0       	ldi	r21, 0x00	; 0
    3454:	08 c0       	rjmp	.+16     	; 0x3466 <vfprintf+0x29e>
    3456:	f5 01       	movw	r30, r10
    3458:	80 81       	ld	r24, Z
    345a:	91 81       	ldd	r25, Z+1	; 0x01
    345c:	bc 01       	movw	r22, r24
    345e:	80 e0       	ldi	r24, 0x00	; 0
    3460:	90 e0       	ldi	r25, 0x00	; 0
    3462:	42 e0       	ldi	r20, 0x02	; 2
    3464:	50 e0       	ldi	r21, 0x00	; 0
    3466:	a4 0e       	add	r10, r20
    3468:	b5 1e       	adc	r11, r21
    346a:	a1 01       	movw	r20, r2
    346c:	0e 94 03 1b 	call	0x3606	; 0x3606 <__ultoa_invert>
    3470:	d8 2e       	mov	r13, r24
    3472:	d2 18       	sub	r13, r2
    3474:	8f e7       	ldi	r24, 0x7F	; 127
    3476:	f8 2e       	mov	r15, r24
    3478:	f1 22       	and	r15, r17
    347a:	f6 fe       	sbrs	r15, 6
    347c:	0b c0       	rjmp	.+22     	; 0x3494 <vfprintf+0x2cc>
    347e:	5e ef       	ldi	r21, 0xFE	; 254
    3480:	f5 22       	and	r15, r21
    3482:	d9 14       	cp	r13, r9
    3484:	38 f4       	brcc	.+14     	; 0x3494 <vfprintf+0x2cc>
    3486:	f4 fe       	sbrs	r15, 4
    3488:	07 c0       	rjmp	.+14     	; 0x3498 <vfprintf+0x2d0>
    348a:	f2 fc       	sbrc	r15, 2
    348c:	05 c0       	rjmp	.+10     	; 0x3498 <vfprintf+0x2d0>
    348e:	8f ee       	ldi	r24, 0xEF	; 239
    3490:	f8 22       	and	r15, r24
    3492:	02 c0       	rjmp	.+4      	; 0x3498 <vfprintf+0x2d0>
    3494:	1d 2d       	mov	r17, r13
    3496:	01 c0       	rjmp	.+2      	; 0x349a <vfprintf+0x2d2>
    3498:	19 2d       	mov	r17, r9
    349a:	f4 fe       	sbrs	r15, 4
    349c:	0d c0       	rjmp	.+26     	; 0x34b8 <vfprintf+0x2f0>
    349e:	fe 01       	movw	r30, r28
    34a0:	ed 0d       	add	r30, r13
    34a2:	f1 1d       	adc	r31, r1
    34a4:	80 81       	ld	r24, Z
    34a6:	80 33       	cpi	r24, 0x30	; 48
    34a8:	19 f4       	brne	.+6      	; 0x34b0 <vfprintf+0x2e8>
    34aa:	99 ee       	ldi	r25, 0xE9	; 233
    34ac:	f9 22       	and	r15, r25
    34ae:	08 c0       	rjmp	.+16     	; 0x34c0 <vfprintf+0x2f8>
    34b0:	1f 5f       	subi	r17, 0xFF	; 255
    34b2:	f2 fe       	sbrs	r15, 2
    34b4:	05 c0       	rjmp	.+10     	; 0x34c0 <vfprintf+0x2f8>
    34b6:	03 c0       	rjmp	.+6      	; 0x34be <vfprintf+0x2f6>
    34b8:	8f 2d       	mov	r24, r15
    34ba:	86 78       	andi	r24, 0x86	; 134
    34bc:	09 f0       	breq	.+2      	; 0x34c0 <vfprintf+0x2f8>
    34be:	1f 5f       	subi	r17, 0xFF	; 255
    34c0:	0f 2d       	mov	r16, r15
    34c2:	f3 fc       	sbrc	r15, 3
    34c4:	14 c0       	rjmp	.+40     	; 0x34ee <vfprintf+0x326>
    34c6:	f0 fe       	sbrs	r15, 0
    34c8:	0f c0       	rjmp	.+30     	; 0x34e8 <vfprintf+0x320>
    34ca:	1e 15       	cp	r17, r14
    34cc:	10 f0       	brcs	.+4      	; 0x34d2 <vfprintf+0x30a>
    34ce:	9d 2c       	mov	r9, r13
    34d0:	0b c0       	rjmp	.+22     	; 0x34e8 <vfprintf+0x320>
    34d2:	9d 2c       	mov	r9, r13
    34d4:	9e 0c       	add	r9, r14
    34d6:	91 1a       	sub	r9, r17
    34d8:	1e 2d       	mov	r17, r14
    34da:	06 c0       	rjmp	.+12     	; 0x34e8 <vfprintf+0x320>
    34dc:	80 e2       	ldi	r24, 0x20	; 32
    34de:	90 e0       	ldi	r25, 0x00	; 0
    34e0:	b3 01       	movw	r22, r6
    34e2:	0e 94 d7 1a 	call	0x35ae	; 0x35ae <fputc>
    34e6:	1f 5f       	subi	r17, 0xFF	; 255
    34e8:	1e 15       	cp	r17, r14
    34ea:	c0 f3       	brcs	.-16     	; 0x34dc <vfprintf+0x314>
    34ec:	04 c0       	rjmp	.+8      	; 0x34f6 <vfprintf+0x32e>
    34ee:	1e 15       	cp	r17, r14
    34f0:	10 f4       	brcc	.+4      	; 0x34f6 <vfprintf+0x32e>
    34f2:	e1 1a       	sub	r14, r17
    34f4:	01 c0       	rjmp	.+2      	; 0x34f8 <vfprintf+0x330>
    34f6:	ee 24       	eor	r14, r14
    34f8:	04 ff       	sbrs	r16, 4
    34fa:	0f c0       	rjmp	.+30     	; 0x351a <vfprintf+0x352>
    34fc:	80 e3       	ldi	r24, 0x30	; 48
    34fe:	90 e0       	ldi	r25, 0x00	; 0
    3500:	b3 01       	movw	r22, r6
    3502:	0e 94 d7 1a 	call	0x35ae	; 0x35ae <fputc>
    3506:	02 ff       	sbrs	r16, 2
    3508:	1d c0       	rjmp	.+58     	; 0x3544 <vfprintf+0x37c>
    350a:	01 fd       	sbrc	r16, 1
    350c:	03 c0       	rjmp	.+6      	; 0x3514 <vfprintf+0x34c>
    350e:	88 e7       	ldi	r24, 0x78	; 120
    3510:	90 e0       	ldi	r25, 0x00	; 0
    3512:	0e c0       	rjmp	.+28     	; 0x3530 <vfprintf+0x368>
    3514:	88 e5       	ldi	r24, 0x58	; 88
    3516:	90 e0       	ldi	r25, 0x00	; 0
    3518:	0b c0       	rjmp	.+22     	; 0x3530 <vfprintf+0x368>
    351a:	80 2f       	mov	r24, r16
    351c:	86 78       	andi	r24, 0x86	; 134
    351e:	91 f0       	breq	.+36     	; 0x3544 <vfprintf+0x37c>
    3520:	01 ff       	sbrs	r16, 1
    3522:	02 c0       	rjmp	.+4      	; 0x3528 <vfprintf+0x360>
    3524:	8b e2       	ldi	r24, 0x2B	; 43
    3526:	01 c0       	rjmp	.+2      	; 0x352a <vfprintf+0x362>
    3528:	80 e2       	ldi	r24, 0x20	; 32
    352a:	f7 fc       	sbrc	r15, 7
    352c:	8d e2       	ldi	r24, 0x2D	; 45
    352e:	90 e0       	ldi	r25, 0x00	; 0
    3530:	b3 01       	movw	r22, r6
    3532:	0e 94 d7 1a 	call	0x35ae	; 0x35ae <fputc>
    3536:	06 c0       	rjmp	.+12     	; 0x3544 <vfprintf+0x37c>
    3538:	80 e3       	ldi	r24, 0x30	; 48
    353a:	90 e0       	ldi	r25, 0x00	; 0
    353c:	b3 01       	movw	r22, r6
    353e:	0e 94 d7 1a 	call	0x35ae	; 0x35ae <fputc>
    3542:	9a 94       	dec	r9
    3544:	d9 14       	cp	r13, r9
    3546:	c0 f3       	brcs	.-16     	; 0x3538 <vfprintf+0x370>
    3548:	da 94       	dec	r13
    354a:	f1 01       	movw	r30, r2
    354c:	ed 0d       	add	r30, r13
    354e:	f1 1d       	adc	r31, r1
    3550:	80 81       	ld	r24, Z
    3552:	90 e0       	ldi	r25, 0x00	; 0
    3554:	b3 01       	movw	r22, r6
    3556:	0e 94 d7 1a 	call	0x35ae	; 0x35ae <fputc>
    355a:	dd 20       	and	r13, r13
    355c:	a9 f7       	brne	.-22     	; 0x3548 <vfprintf+0x380>
    355e:	06 c0       	rjmp	.+12     	; 0x356c <vfprintf+0x3a4>
    3560:	80 e2       	ldi	r24, 0x20	; 32
    3562:	90 e0       	ldi	r25, 0x00	; 0
    3564:	b3 01       	movw	r22, r6
    3566:	0e 94 d7 1a 	call	0x35ae	; 0x35ae <fputc>
    356a:	ea 94       	dec	r14
    356c:	ee 20       	and	r14, r14
    356e:	c1 f7       	brne	.-16     	; 0x3560 <vfprintf+0x398>
    3570:	43 ce       	rjmp	.-890    	; 0x31f8 <vfprintf+0x30>
    3572:	f3 01       	movw	r30, r6
    3574:	66 81       	ldd	r22, Z+6	; 0x06
    3576:	77 81       	ldd	r23, Z+7	; 0x07
    3578:	cb 01       	movw	r24, r22
    357a:	2b 96       	adiw	r28, 0x0b	; 11
    357c:	e2 e1       	ldi	r30, 0x12	; 18
    357e:	0c 94 bf 1b 	jmp	0x377e	; 0x377e <__epilogue_restores__>

00003582 <strnlen_P>:
    3582:	fc 01       	movw	r30, r24
    3584:	05 90       	lpm	r0, Z+
    3586:	61 50       	subi	r22, 0x01	; 1
    3588:	70 40       	sbci	r23, 0x00	; 0
    358a:	01 10       	cpse	r0, r1
    358c:	d8 f7       	brcc	.-10     	; 0x3584 <strnlen_P+0x2>
    358e:	80 95       	com	r24
    3590:	90 95       	com	r25
    3592:	8e 0f       	add	r24, r30
    3594:	9f 1f       	adc	r25, r31
    3596:	08 95       	ret

00003598 <strnlen>:
    3598:	fc 01       	movw	r30, r24
    359a:	61 50       	subi	r22, 0x01	; 1
    359c:	70 40       	sbci	r23, 0x00	; 0
    359e:	01 90       	ld	r0, Z+
    35a0:	01 10       	cpse	r0, r1
    35a2:	d8 f7       	brcc	.-10     	; 0x359a <strnlen+0x2>
    35a4:	80 95       	com	r24
    35a6:	90 95       	com	r25
    35a8:	8e 0f       	add	r24, r30
    35aa:	9f 1f       	adc	r25, r31
    35ac:	08 95       	ret

000035ae <fputc>:
    35ae:	0f 93       	push	r16
    35b0:	1f 93       	push	r17
    35b2:	cf 93       	push	r28
    35b4:	df 93       	push	r29
    35b6:	8c 01       	movw	r16, r24
    35b8:	eb 01       	movw	r28, r22
    35ba:	8b 81       	ldd	r24, Y+3	; 0x03
    35bc:	81 ff       	sbrs	r24, 1
    35be:	1b c0       	rjmp	.+54     	; 0x35f6 <fputc+0x48>
    35c0:	82 ff       	sbrs	r24, 2
    35c2:	0d c0       	rjmp	.+26     	; 0x35de <fputc+0x30>
    35c4:	2e 81       	ldd	r18, Y+6	; 0x06
    35c6:	3f 81       	ldd	r19, Y+7	; 0x07
    35c8:	8c 81       	ldd	r24, Y+4	; 0x04
    35ca:	9d 81       	ldd	r25, Y+5	; 0x05
    35cc:	28 17       	cp	r18, r24
    35ce:	39 07       	cpc	r19, r25
    35d0:	64 f4       	brge	.+24     	; 0x35ea <fputc+0x3c>
    35d2:	e8 81       	ld	r30, Y
    35d4:	f9 81       	ldd	r31, Y+1	; 0x01
    35d6:	01 93       	st	Z+, r16
    35d8:	f9 83       	std	Y+1, r31	; 0x01
    35da:	e8 83       	st	Y, r30
    35dc:	06 c0       	rjmp	.+12     	; 0x35ea <fputc+0x3c>
    35de:	e8 85       	ldd	r30, Y+8	; 0x08
    35e0:	f9 85       	ldd	r31, Y+9	; 0x09
    35e2:	80 2f       	mov	r24, r16
    35e4:	09 95       	icall
    35e6:	89 2b       	or	r24, r25
    35e8:	31 f4       	brne	.+12     	; 0x35f6 <fputc+0x48>
    35ea:	8e 81       	ldd	r24, Y+6	; 0x06
    35ec:	9f 81       	ldd	r25, Y+7	; 0x07
    35ee:	01 96       	adiw	r24, 0x01	; 1
    35f0:	9f 83       	std	Y+7, r25	; 0x07
    35f2:	8e 83       	std	Y+6, r24	; 0x06
    35f4:	02 c0       	rjmp	.+4      	; 0x35fa <fputc+0x4c>
    35f6:	0f ef       	ldi	r16, 0xFF	; 255
    35f8:	1f ef       	ldi	r17, 0xFF	; 255
    35fa:	c8 01       	movw	r24, r16
    35fc:	df 91       	pop	r29
    35fe:	cf 91       	pop	r28
    3600:	1f 91       	pop	r17
    3602:	0f 91       	pop	r16
    3604:	08 95       	ret

00003606 <__ultoa_invert>:
    3606:	fa 01       	movw	r30, r20
    3608:	aa 27       	eor	r26, r26
    360a:	28 30       	cpi	r18, 0x08	; 8
    360c:	51 f1       	breq	.+84     	; 0x3662 <__ultoa_invert+0x5c>
    360e:	20 31       	cpi	r18, 0x10	; 16
    3610:	81 f1       	breq	.+96     	; 0x3672 <__ultoa_invert+0x6c>
    3612:	e8 94       	clt
    3614:	6f 93       	push	r22
    3616:	6e 7f       	andi	r22, 0xFE	; 254
    3618:	6e 5f       	subi	r22, 0xFE	; 254
    361a:	7f 4f       	sbci	r23, 0xFF	; 255
    361c:	8f 4f       	sbci	r24, 0xFF	; 255
    361e:	9f 4f       	sbci	r25, 0xFF	; 255
    3620:	af 4f       	sbci	r26, 0xFF	; 255
    3622:	b1 e0       	ldi	r27, 0x01	; 1
    3624:	3e d0       	rcall	.+124    	; 0x36a2 <__ultoa_invert+0x9c>
    3626:	b4 e0       	ldi	r27, 0x04	; 4
    3628:	3c d0       	rcall	.+120    	; 0x36a2 <__ultoa_invert+0x9c>
    362a:	67 0f       	add	r22, r23
    362c:	78 1f       	adc	r23, r24
    362e:	89 1f       	adc	r24, r25
    3630:	9a 1f       	adc	r25, r26
    3632:	a1 1d       	adc	r26, r1
    3634:	68 0f       	add	r22, r24
    3636:	79 1f       	adc	r23, r25
    3638:	8a 1f       	adc	r24, r26
    363a:	91 1d       	adc	r25, r1
    363c:	a1 1d       	adc	r26, r1
    363e:	6a 0f       	add	r22, r26
    3640:	71 1d       	adc	r23, r1
    3642:	81 1d       	adc	r24, r1
    3644:	91 1d       	adc	r25, r1
    3646:	a1 1d       	adc	r26, r1
    3648:	20 d0       	rcall	.+64     	; 0x368a <__ultoa_invert+0x84>
    364a:	09 f4       	brne	.+2      	; 0x364e <__ultoa_invert+0x48>
    364c:	68 94       	set
    364e:	3f 91       	pop	r19
    3650:	2a e0       	ldi	r18, 0x0A	; 10
    3652:	26 9f       	mul	r18, r22
    3654:	11 24       	eor	r1, r1
    3656:	30 19       	sub	r19, r0
    3658:	30 5d       	subi	r19, 0xD0	; 208
    365a:	31 93       	st	Z+, r19
    365c:	de f6       	brtc	.-74     	; 0x3614 <__ultoa_invert+0xe>
    365e:	cf 01       	movw	r24, r30
    3660:	08 95       	ret
    3662:	46 2f       	mov	r20, r22
    3664:	47 70       	andi	r20, 0x07	; 7
    3666:	40 5d       	subi	r20, 0xD0	; 208
    3668:	41 93       	st	Z+, r20
    366a:	b3 e0       	ldi	r27, 0x03	; 3
    366c:	0f d0       	rcall	.+30     	; 0x368c <__ultoa_invert+0x86>
    366e:	c9 f7       	brne	.-14     	; 0x3662 <__ultoa_invert+0x5c>
    3670:	f6 cf       	rjmp	.-20     	; 0x365e <__ultoa_invert+0x58>
    3672:	46 2f       	mov	r20, r22
    3674:	4f 70       	andi	r20, 0x0F	; 15
    3676:	40 5d       	subi	r20, 0xD0	; 208
    3678:	4a 33       	cpi	r20, 0x3A	; 58
    367a:	18 f0       	brcs	.+6      	; 0x3682 <__ultoa_invert+0x7c>
    367c:	49 5d       	subi	r20, 0xD9	; 217
    367e:	31 fd       	sbrc	r19, 1
    3680:	40 52       	subi	r20, 0x20	; 32
    3682:	41 93       	st	Z+, r20
    3684:	02 d0       	rcall	.+4      	; 0x368a <__ultoa_invert+0x84>
    3686:	a9 f7       	brne	.-22     	; 0x3672 <__ultoa_invert+0x6c>
    3688:	ea cf       	rjmp	.-44     	; 0x365e <__ultoa_invert+0x58>
    368a:	b4 e0       	ldi	r27, 0x04	; 4
    368c:	a6 95       	lsr	r26
    368e:	97 95       	ror	r25
    3690:	87 95       	ror	r24
    3692:	77 95       	ror	r23
    3694:	67 95       	ror	r22
    3696:	ba 95       	dec	r27
    3698:	c9 f7       	brne	.-14     	; 0x368c <__ultoa_invert+0x86>
    369a:	00 97       	sbiw	r24, 0x00	; 0
    369c:	61 05       	cpc	r22, r1
    369e:	71 05       	cpc	r23, r1
    36a0:	08 95       	ret
    36a2:	9b 01       	movw	r18, r22
    36a4:	ac 01       	movw	r20, r24
    36a6:	0a 2e       	mov	r0, r26
    36a8:	06 94       	lsr	r0
    36aa:	57 95       	ror	r21
    36ac:	47 95       	ror	r20
    36ae:	37 95       	ror	r19
    36b0:	27 95       	ror	r18
    36b2:	ba 95       	dec	r27
    36b4:	c9 f7       	brne	.-14     	; 0x36a8 <__ultoa_invert+0xa2>
    36b6:	62 0f       	add	r22, r18
    36b8:	73 1f       	adc	r23, r19
    36ba:	84 1f       	adc	r24, r20
    36bc:	95 1f       	adc	r25, r21
    36be:	a0 1d       	adc	r26, r0
    36c0:	08 95       	ret

000036c2 <__udivmodqi4>:
    36c2:	99 1b       	sub	r25, r25
    36c4:	79 e0       	ldi	r23, 0x09	; 9
    36c6:	04 c0       	rjmp	.+8      	; 0x36d0 <__udivmodqi4_ep>

000036c8 <__udivmodqi4_loop>:
    36c8:	99 1f       	adc	r25, r25
    36ca:	96 17       	cp	r25, r22
    36cc:	08 f0       	brcs	.+2      	; 0x36d0 <__udivmodqi4_ep>
    36ce:	96 1b       	sub	r25, r22

000036d0 <__udivmodqi4_ep>:
    36d0:	88 1f       	adc	r24, r24
    36d2:	7a 95       	dec	r23
    36d4:	c9 f7       	brne	.-14     	; 0x36c8 <__udivmodqi4_loop>
    36d6:	80 95       	com	r24
    36d8:	08 95       	ret

000036da <__udivmodhi4>:
    36da:	aa 1b       	sub	r26, r26
    36dc:	bb 1b       	sub	r27, r27
    36de:	51 e1       	ldi	r21, 0x11	; 17
    36e0:	07 c0       	rjmp	.+14     	; 0x36f0 <__udivmodhi4_ep>

000036e2 <__udivmodhi4_loop>:
    36e2:	aa 1f       	adc	r26, r26
    36e4:	bb 1f       	adc	r27, r27
    36e6:	a6 17       	cp	r26, r22
    36e8:	b7 07       	cpc	r27, r23
    36ea:	10 f0       	brcs	.+4      	; 0x36f0 <__udivmodhi4_ep>
    36ec:	a6 1b       	sub	r26, r22
    36ee:	b7 0b       	sbc	r27, r23

000036f0 <__udivmodhi4_ep>:
    36f0:	88 1f       	adc	r24, r24
    36f2:	99 1f       	adc	r25, r25
    36f4:	5a 95       	dec	r21
    36f6:	a9 f7       	brne	.-22     	; 0x36e2 <__udivmodhi4_loop>
    36f8:	80 95       	com	r24
    36fa:	90 95       	com	r25
    36fc:	bc 01       	movw	r22, r24
    36fe:	cd 01       	movw	r24, r26
    3700:	08 95       	ret

00003702 <__udivmodsi4>:
    3702:	a1 e2       	ldi	r26, 0x21	; 33
    3704:	1a 2e       	mov	r1, r26
    3706:	aa 1b       	sub	r26, r26
    3708:	bb 1b       	sub	r27, r27
    370a:	fd 01       	movw	r30, r26
    370c:	0d c0       	rjmp	.+26     	; 0x3728 <__udivmodsi4_ep>

0000370e <__udivmodsi4_loop>:
    370e:	aa 1f       	adc	r26, r26
    3710:	bb 1f       	adc	r27, r27
    3712:	ee 1f       	adc	r30, r30
    3714:	ff 1f       	adc	r31, r31
    3716:	a2 17       	cp	r26, r18
    3718:	b3 07       	cpc	r27, r19
    371a:	e4 07       	cpc	r30, r20
    371c:	f5 07       	cpc	r31, r21
    371e:	20 f0       	brcs	.+8      	; 0x3728 <__udivmodsi4_ep>
    3720:	a2 1b       	sub	r26, r18
    3722:	b3 0b       	sbc	r27, r19
    3724:	e4 0b       	sbc	r30, r20
    3726:	f5 0b       	sbc	r31, r21

00003728 <__udivmodsi4_ep>:
    3728:	66 1f       	adc	r22, r22
    372a:	77 1f       	adc	r23, r23
    372c:	88 1f       	adc	r24, r24
    372e:	99 1f       	adc	r25, r25
    3730:	1a 94       	dec	r1
    3732:	69 f7       	brne	.-38     	; 0x370e <__udivmodsi4_loop>
    3734:	60 95       	com	r22
    3736:	70 95       	com	r23
    3738:	80 95       	com	r24
    373a:	90 95       	com	r25
    373c:	9b 01       	movw	r18, r22
    373e:	ac 01       	movw	r20, r24
    3740:	bd 01       	movw	r22, r26
    3742:	cf 01       	movw	r24, r30
    3744:	08 95       	ret

00003746 <__prologue_saves__>:
    3746:	2f 92       	push	r2
    3748:	3f 92       	push	r3
    374a:	4f 92       	push	r4
    374c:	5f 92       	push	r5
    374e:	6f 92       	push	r6
    3750:	7f 92       	push	r7
    3752:	8f 92       	push	r8
    3754:	9f 92       	push	r9
    3756:	af 92       	push	r10
    3758:	bf 92       	push	r11
    375a:	cf 92       	push	r12
    375c:	df 92       	push	r13
    375e:	ef 92       	push	r14
    3760:	ff 92       	push	r15
    3762:	0f 93       	push	r16
    3764:	1f 93       	push	r17
    3766:	cf 93       	push	r28
    3768:	df 93       	push	r29
    376a:	cd b7       	in	r28, 0x3d	; 61
    376c:	de b7       	in	r29, 0x3e	; 62
    376e:	ca 1b       	sub	r28, r26
    3770:	db 0b       	sbc	r29, r27
    3772:	0f b6       	in	r0, 0x3f	; 63
    3774:	f8 94       	cli
    3776:	de bf       	out	0x3e, r29	; 62
    3778:	0f be       	out	0x3f, r0	; 63
    377a:	cd bf       	out	0x3d, r28	; 61
    377c:	09 94       	ijmp

0000377e <__epilogue_restores__>:
    377e:	2a 88       	ldd	r2, Y+18	; 0x12
    3780:	39 88       	ldd	r3, Y+17	; 0x11
    3782:	48 88       	ldd	r4, Y+16	; 0x10
    3784:	5f 84       	ldd	r5, Y+15	; 0x0f
    3786:	6e 84       	ldd	r6, Y+14	; 0x0e
    3788:	7d 84       	ldd	r7, Y+13	; 0x0d
    378a:	8c 84       	ldd	r8, Y+12	; 0x0c
    378c:	9b 84       	ldd	r9, Y+11	; 0x0b
    378e:	aa 84       	ldd	r10, Y+10	; 0x0a
    3790:	b9 84       	ldd	r11, Y+9	; 0x09
    3792:	c8 84       	ldd	r12, Y+8	; 0x08
    3794:	df 80       	ldd	r13, Y+7	; 0x07
    3796:	ee 80       	ldd	r14, Y+6	; 0x06
    3798:	fd 80       	ldd	r15, Y+5	; 0x05
    379a:	0c 81       	ldd	r16, Y+4	; 0x04
    379c:	1b 81       	ldd	r17, Y+3	; 0x03
    379e:	aa 81       	ldd	r26, Y+2	; 0x02
    37a0:	b9 81       	ldd	r27, Y+1	; 0x01
    37a2:	ce 0f       	add	r28, r30
    37a4:	d1 1d       	adc	r29, r1
    37a6:	0f b6       	in	r0, 0x3f	; 63
    37a8:	f8 94       	cli
    37aa:	de bf       	out	0x3e, r29	; 62
    37ac:	0f be       	out	0x3f, r0	; 63
    37ae:	cd bf       	out	0x3d, r28	; 61
    37b0:	ed 01       	movw	r28, r26
    37b2:	08 95       	ret

000037b4 <_exit>:
    37b4:	f8 94       	cli

000037b6 <__stop_program>:
    37b6:	ff cf       	rjmp	.-2      	; 0x37b6 <__stop_program>
