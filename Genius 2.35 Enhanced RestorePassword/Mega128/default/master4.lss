
master4.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000005e  00800100  00016f74  00017028  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00016f74  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000d31  0080015e  0080015e  00017086  2**0
                  ALLOC
  3 .eeprom       00000857  00810000  00810000  00017086  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .debug_aranges 000000e0  00000000  00000000  000178dd  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_pubnames 00002750  00000000  00000000  000179bd  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00013425  00000000  00000000  0001a10d  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000c3b  00000000  00000000  0002d532  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000df28  00000000  00000000  0002e16d  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001220  00000000  00000000  0003c098  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00005335  00000000  00000000  0003d2b8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00007652  00000000  00000000  000425ed  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000006f0  00000000  00000000  00049c3f  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 3e 12 	jmp	0x247c	; 0x247c <__ctors_end>
       4:	0c 94 5d 12 	jmp	0x24ba	; 0x24ba <__bad_interrupt>
       8:	0c 94 5d 12 	jmp	0x24ba	; 0x24ba <__bad_interrupt>
       c:	0c 94 5d 12 	jmp	0x24ba	; 0x24ba <__bad_interrupt>
      10:	0c 94 5d 12 	jmp	0x24ba	; 0x24ba <__bad_interrupt>
      14:	0c 94 5d 12 	jmp	0x24ba	; 0x24ba <__bad_interrupt>
      18:	0c 94 5d 12 	jmp	0x24ba	; 0x24ba <__bad_interrupt>
      1c:	0c 94 5d 12 	jmp	0x24ba	; 0x24ba <__bad_interrupt>
      20:	0c 94 5d 12 	jmp	0x24ba	; 0x24ba <__bad_interrupt>
      24:	0c 94 5d 12 	jmp	0x24ba	; 0x24ba <__bad_interrupt>
      28:	0c 94 5d 12 	jmp	0x24ba	; 0x24ba <__bad_interrupt>
      2c:	0c 94 5d 12 	jmp	0x24ba	; 0x24ba <__bad_interrupt>
      30:	0c 94 07 13 	jmp	0x260e	; 0x260e <__vector_12>
      34:	0c 94 5d 12 	jmp	0x24ba	; 0x24ba <__bad_interrupt>
      38:	0c 94 5d 12 	jmp	0x24ba	; 0x24ba <__bad_interrupt>
      3c:	0c 94 5d 12 	jmp	0x24ba	; 0x24ba <__bad_interrupt>
      40:	0c 94 5d 12 	jmp	0x24ba	; 0x24ba <__bad_interrupt>
      44:	0c 94 b7 7b 	jmp	0xf76e	; 0xf76e <__vector_17>
      48:	0c 94 c0 14 	jmp	0x2980	; 0x2980 <__vector_18>
      4c:	0c 94 5d 12 	jmp	0x24ba	; 0x24ba <__bad_interrupt>
      50:	0c 94 5d 12 	jmp	0x24ba	; 0x24ba <__bad_interrupt>
      54:	0c 94 5d 12 	jmp	0x24ba	; 0x24ba <__bad_interrupt>
      58:	0c 94 5d 12 	jmp	0x24ba	; 0x24ba <__bad_interrupt>
      5c:	0c 94 5d 12 	jmp	0x24ba	; 0x24ba <__bad_interrupt>
      60:	0c 94 5d 12 	jmp	0x24ba	; 0x24ba <__bad_interrupt>
      64:	0c 94 5d 12 	jmp	0x24ba	; 0x24ba <__bad_interrupt>
      68:	0c 94 5d 12 	jmp	0x24ba	; 0x24ba <__bad_interrupt>
      6c:	0c 94 5d 12 	jmp	0x24ba	; 0x24ba <__bad_interrupt>
      70:	0c 94 5d 12 	jmp	0x24ba	; 0x24ba <__bad_interrupt>
      74:	0c 94 5d 12 	jmp	0x24ba	; 0x24ba <__bad_interrupt>
      78:	0c 94 2c 3e 	jmp	0x7c58	; 0x7c58 <__vector_30>
      7c:	0c 94 5d 12 	jmp	0x24ba	; 0x24ba <__bad_interrupt>
      80:	0c 94 5d 12 	jmp	0x24ba	; 0x24ba <__bad_interrupt>
      84:	0c 94 5d 12 	jmp	0x24ba	; 0x24ba <__bad_interrupt>
      88:	0c 94 5d 12 	jmp	0x24ba	; 0x24ba <__bad_interrupt>
      8c:	9f 13       	cpse	r25, r31
      8e:	9d 13       	cpse	r25, r29
      90:	a1 13       	cpse	r26, r17
      92:	a3 13       	cpse	r26, r19
      94:	a5 13       	cpse	r26, r21
      96:	a7 13       	cpse	r26, r23
      98:	a9 13       	cpse	r26, r25
      9a:	ab 13       	cpse	r26, r27
      9c:	ad 13       	cpse	r26, r29
      9e:	af 13       	cpse	r26, r31
      a0:	b1 13       	cpse	r27, r17
      a2:	b3 13       	cpse	r27, r19
      a4:	b5 13       	cpse	r27, r21
      a6:	c3 13       	cpse	r28, r19
      a8:	b7 13       	cpse	r27, r23
      aa:	c3 13       	cpse	r28, r19
      ac:	b9 13       	cpse	r27, r25
      ae:	bb 13       	cpse	r27, r27
      b0:	c3 13       	cpse	r28, r19
      b2:	bd 13       	cpse	r27, r29
      b4:	bf 13       	cpse	r27, r31
      b6:	c1 13       	cpse	r28, r17
      b8:	c3 13       	cpse	r28, r19
      ba:	c3 13       	cpse	r28, r19
      bc:	b7 13       	cpse	r27, r23
      be:	a9 13       	cpse	r26, r25
      c0:	c3 13       	cpse	r28, r19
      c2:	ab 13       	cpse	r26, r27
      c4:	af 13       	cpse	r26, r31
      c6:	b3 13       	cpse	r27, r19
      c8:	66 53       	subi	r22, 0x36	; 54
      ca:	7e 53       	subi	r23, 0x3E	; 62
      cc:	90 53       	subi	r25, 0x30	; 48
      ce:	c5 53       	subi	r28, 0x35	; 53
      d0:	f6 53       	subi	r31, 0x36	; 54
      d2:	0c 54       	subi	r16, 0x4C	; 76
      d4:	41 54       	subi	r20, 0x41	; 65
      d6:	7b 54       	subi	r23, 0x4B	; 75
      d8:	bf 54       	subi	r27, 0x4F	; 79
      da:	c7 54       	subi	r28, 0x47	; 71
      dc:	df 54       	subi	r29, 0x4F	; 79
      de:	eb 54       	subi	r30, 0x4B	; 75
      e0:	1d 55       	subi	r17, 0x5D	; 93
      e2:	5e 55       	subi	r21, 0x5E	; 94
      e4:	7b 55       	subi	r23, 0x5B	; 91
      e6:	95 55       	subi	r25, 0x55	; 85
      e8:	d5 55       	subi	r29, 0x55	; 85
      ea:	dc 53       	subi	r29, 0x3C	; 60
      ec:	97 54       	subi	r25, 0x47	; 71
      ee:	38 55       	subi	r19, 0x58	; 88
      f0:	61 54       	subi	r22, 0x41	; 65
      f2:	fb 55       	subi	r31, 0x5B	; 91
      f4:	11 56       	subi	r17, 0x61	; 97
      f6:	16 56       	subi	r17, 0x66	; 102
      f8:	4f 56       	subi	r20, 0x6F	; 111
      fa:	80 56       	subi	r24, 0x60	; 96
      fc:	c5 56       	subi	r28, 0x65	; 101
      fe:	e5 56       	subi	r30, 0x65	; 101
     100:	03 57       	subi	r16, 0x73	; 115
     102:	3d 57       	subi	r19, 0x7D	; 125
     104:	a0 57       	subi	r26, 0x70	; 112
     106:	e4 5b       	subi	r30, 0xB4	; 180
     108:	66 56       	subi	r22, 0x66	; 102
     10a:	0c 5c       	subi	r16, 0xCC	; 204
     10c:	6c 5c       	subi	r22, 0xCC	; 204
     10e:	26 5c       	subi	r18, 0xC6	; 198
     110:	51 5c       	subi	r21, 0xC1	; 193
     112:	a6 5c       	subi	r26, 0xC6	; 198
     114:	86 5c       	subi	r24, 0xC6	; 198
     116:	bf 5c       	subi	r27, 0xCF	; 207
     118:	da 5c       	subi	r29, 0xCA	; 202
     11a:	ec 5c       	subi	r30, 0xCC	; 204
     11c:	b0 57       	subi	r27, 0x70	; 112
     11e:	d0 57       	subi	r29, 0x70	; 112
     120:	f7 57       	subi	r31, 0x77	; 119
     122:	06 58       	subi	r16, 0x86	; 134
     124:	24 58       	subi	r18, 0x84	; 132
     126:	3b 58       	subi	r19, 0x8B	; 139
     128:	67 58       	subi	r22, 0x87	; 135
     12a:	7e 58       	subi	r23, 0x8E	; 142
     12c:	aa 58       	subi	r26, 0x8A	; 138
     12e:	ca 58       	subi	r28, 0x8A	; 138
     130:	fb 58       	subi	r31, 0x8B	; 139
     132:	0a 59       	subi	r16, 0x9A	; 154
     134:	63 59       	subi	r22, 0x93	; 147
     136:	da 59       	subi	r29, 0x9A	; 154
     138:	ee 59       	subi	r30, 0x9E	; 158
     13a:	c9 5a       	subi	r28, 0xA9	; 169
     13c:	c9 5a       	subi	r28, 0xA9	; 169
     13e:	02 5a       	subi	r16, 0xA2	; 162
     140:	16 5a       	subi	r17, 0xA6	; 166
     142:	1e 5a       	subi	r17, 0xAE	; 174
     144:	3a 5a       	subi	r19, 0xAA	; 170
     146:	4e 5a       	subi	r20, 0xAE	; 174
     148:	5b 5a       	subi	r21, 0xAB	; 171
     14a:	72 5a       	subi	r23, 0xA2	; 162
     14c:	89 5a       	subi	r24, 0xA9	; 169
     14e:	a7 5a       	subi	r26, 0xA7	; 167
     150:	cc 5a       	subi	r28, 0xAC	; 172
     152:	e3 5a       	subi	r30, 0xA3	; 163
     154:	fa 5a       	subi	r31, 0xAA	; 170
     156:	11 5b       	subi	r17, 0xB1	; 177
     158:	28 5b       	subi	r18, 0xB8	; 184
     15a:	3f 5b       	subi	r19, 0xBF	; 191
     15c:	56 5b       	subi	r21, 0xB6	; 182
     15e:	6d 5b       	subi	r22, 0xBD	; 189
     160:	7c 5b       	subi	r23, 0xBC	; 188
     162:	93 5b       	subi	r25, 0xB3	; 179
     164:	b6 5b       	subi	r27, 0xB6	; 182
     166:	b0 8e       	std	Z+24, r11	; 0x18
     168:	cc 8e       	std	Y+28, r12	; 0x1c
     16a:	df 8e       	std	Y+31, r13	; 0x1f
     16c:	0e 8f       	std	Y+30, r16	; 0x1e
     16e:	37 8f       	std	Z+31, r19	; 0x1f
     170:	aa 8f       	std	Y+26, r26	; 0x1a
     172:	bc 8f       	std	Y+28, r27	; 0x1c
     174:	c5 8f       	std	Z+29, r28	; 0x1d
     176:	01 90       	ld	r0, Z+
     178:	28 90       	.word	0x9028	; ????
     17a:	6f 90       	pop	r6
     17c:	79 90       	ld	r7, Y+
     17e:	34 90       	lpm	r3, Z+
     180:	7f 90       	pop	r7
     182:	dc 8e       	std	Y+28, r13	; 0x1c
     184:	91 90       	ld	r9, Z+
     186:	97 90       	elpm	r9, Z+
     188:	39 93       	st	Y+, r19
     18a:	3d 93       	st	X+, r19
     18c:	59 93       	st	Y+, r21
     18e:	55 97       	sbiw	r26, 0x15	; 21
     190:	55 97       	sbiw	r26, 0x15	; 21
     192:	55 97       	sbiw	r26, 0x15	; 21
     194:	55 97       	sbiw	r26, 0x15	; 21
     196:	ab 93       	.word	0x93ab	; ????
     198:	55 97       	sbiw	r26, 0x15	; 21
     19a:	cd 93       	st	X+, r28
     19c:	55 97       	sbiw	r26, 0x15	; 21
     19e:	ec 93       	st	X, r30
     1a0:	75 94       	asr	r7
     1a2:	d5 94       	asr	r13
     1a4:	f9 94       	.word	0x94f9	; ????
     1a6:	8a 93       	st	-Y, r24
     1a8:	55 97       	sbiw	r26, 0x15	; 21
     1aa:	8d 94 11 95 	jmp	0x232a22	; 0x232a22 <__data_load_end+0x21ba50>
     1ae:	49 95       	.word	0x9549	; ????
     1b0:	66 95       	lsr	r22
     1b2:	a2 95       	swap	r26
     1b4:	b2 95       	swap	r27
     1b6:	c3 96       	adiw	r24, 0x33	; 51
     1b8:	d3 96       	adiw	r26, 0x33	; 51
     1ba:	18 97       	sbiw	r26, 0x08	; 8
     1bc:	37 97       	sbiw	r30, 0x07	; 7
     1be:	49 97       	sbiw	r24, 0x19	; 25
     1c0:	4f 97       	sbiw	r24, 0x1f	; 31
     1c2:	51 97       	sbiw	r26, 0x11	; 17
     1c4:	4c 99       	sbic	0x09, 4	; 9
     1c6:	52 99       	sbic	0x0a, 2	; 10
     1c8:	56 99       	sbic	0x0a, 6	; 10
     1ca:	6d 99       	sbic	0x0d, 5	; 13
     1cc:	87 99       	sbic	0x10, 7	; 16
     1ce:	8b 99       	sbic	0x11, 3	; 17
     1d0:	ba 99       	sbic	0x17, 2	; 23
     1d2:	d9 99       	sbic	0x1b, 1	; 27
     1d4:	df 99       	sbic	0x1b, 7	; 27
     1d6:	e8 99       	sbic	0x1d, 0	; 29
     1d8:	eb 99       	sbic	0x1d, 3	; 29
     1da:	ee 99       	sbic	0x1d, 6	; 29
     1dc:	f1 99       	sbic	0x1e, 1	; 30
     1de:	f4 99       	sbic	0x1e, 4	; 30
     1e0:	f7 99       	sbic	0x1e, 7	; 30
     1e2:	fd 99       	sbic	0x1f, 5	; 31
     1e4:	00 9a       	sbi	0x00, 0	; 0
     1e6:	03 9a       	sbi	0x00, 3	; 0
     1e8:	0d 9a       	sbi	0x01, 5	; 1
     1ea:	d0 9b       	sbis	0x1a, 0	; 26
     1ec:	29 9c       	mul	r2, r9
     1ee:	37 9c       	mul	r3, r7
     1f0:	7f 9c       	mul	r7, r15
     1f2:	95 9c       	mul	r9, r5
     1f4:	ac 9c       	mul	r10, r12
     1f6:	d5 9c       	mul	r13, r5
     1f8:	8b 9d       	mul	r24, r11
     1fa:	99 9d       	mul	r25, r9
     1fc:	18 9e       	mul	r1, r24
     1fe:	c4 9e       	mul	r12, r20
     200:	c8 9f       	mul	r28, r24
     202:	19 a0       	ldd	r1, Y+33	; 0x21
     204:	5f a0       	ldd	r5, Y+39	; 0x27
     206:	dc a0       	ldd	r13, Y+36	; 0x24
     208:	70 a1       	ldd	r23, Z+32	; 0x20
     20a:	16 a2       	std	Z+38, r1	; 0x26
     20c:	dc a2       	std	Y+36, r13	; 0x24
     20e:	08 a3       	std	Y+32, r16	; 0x20
     210:	c1 a3       	std	Z+33, r28	; 0x21
     212:	de a3       	std	Y+38, r29	; 0x26
     214:	f4 a4       	ldd	r15, Z+44	; 0x2c
     216:	58 a4       	ldd	r5, Y+40	; 0x28
     218:	9f a4       	ldd	r9, Y+47	; 0x2f
     21a:	95 a5       	ldd	r25, Z+45	; 0x2d
     21c:	c3 a5       	ldd	r28, Z+43	; 0x2b
     21e:	d8 a5       	ldd	r29, Y+40	; 0x28
     220:	fc a4       	ldd	r15, Y+44	; 0x2c
     222:	80 a5       	ldd	r24, Z+40	; 0x28
     224:	c9 a5       	ldd	r28, Y+41	; 0x29
     226:	d1 a5       	ldd	r29, Z+41	; 0x29
     228:	36 aa       	std	Z+54, r3	; 0x36
     22a:	39 aa       	std	Y+49, r3	; 0x31
     22c:	fb aa       	std	Y+51, r15	; 0x33
     22e:	0a ab       	std	Y+50, r16	; 0x32
     230:	3d ab       	std	Y+53, r19	; 0x35
     232:	4d ab       	std	Y+53, r20	; 0x35
     234:	7b ab       	std	Y+51, r23	; 0x33
     236:	1a ab       	std	Y+50, r17	; 0x32
     238:	29 ab       	std	Y+49, r18	; 0x31
     23a:	33 ab       	std	Z+51, r19	; 0x33
     23c:	85 ab       	std	Z+53, r24	; 0x35
     23e:	92 ab       	std	Z+50, r25	; 0x32
     240:	9d ab       	std	Y+53, r25	; 0x35
     242:	a0 ab       	std	Z+48, r26	; 0x30
     244:	a3 ab       	std	Z+51, r26	; 0x33
     246:	a6 ab       	std	Z+54, r26	; 0x36
     248:	a9 ab       	std	Y+49, r26	; 0x31
     24a:	ac ab       	std	Y+52, r26	; 0x34
     24c:	af ab       	std	Y+55, r26	; 0x37
     24e:	b2 ab       	std	Z+50, r27	; 0x32
     250:	d4 ab       	std	Z+52, r29	; 0x34
     252:	c2 ab       	std	Z+50, r28	; 0x32
     254:	b5 ab       	std	Z+53, r27	; 0x35
     256:	cd ab       	std	Y+53, r28	; 0x35
     258:	e5 aa       	std	Z+53, r14	; 0x35

0000025a <__logo>:
     25a:	00 00 00 01 01 01 05 09 00 00 00 11 11 11 15 15     ................
     26a:	11 00 00 00 00 10 10 10 14 12 00 0f 07 03 01 01     ................
     27a:	01 01 00 00 11 11 11 11 11 11 00 00 00 1e 1c 18     ................
     28a:	10 10 10 10 00 00 1f 1b 15 17 17 15 1b 1f 00 14     ................
     29a:	14 08 08 07 04 06 04 00                             ........

000002a2 <__c.3008>:
     2a2:	49 6e 69 74 69 61 6c 69 7a 65 2e 2e 2e 20 00        Initialize... .

000002b1 <__c.2992>:
     2b1:	57 61 74 63 68 44 6f 67 00                          WatchDog.

000002ba <__c.2990>:
     2ba:	42 72 6f 77 6e 4f 75 74 00                          BrownOut.

000002c3 <__c.2988>:
     2c3:	45 78 74 65 72 6e 61 6c 00                          External.

000002cc <__c.2986>:
     2cc:	50 6f 77 65 72 4f 6e 00                             PowerOn.

000002d4 <__prodloc>:
     2d4:	01 06 02 06 01 0d 02 0d 01 14 02 14                 ............

000002e0 <__prntloc>:
     2e0:	01 08 02 08 03 08 04 08 01 13 02 13                 ............

000002ec <__prntlmt>:
     2ec:	02 03 04 02 0f 0f                                   ......

000002f2 <__prntstr>:
     2f2:	01 01 00 00 00 00                                   ......

000002f8 <__hostloc>:
     2f8:	01 0a 02 0a 03 0a                                   ......

000002fe <MaxKeyHit>:
     2fe:	02 04 03 03 03 03 03 04 03 04                       ..........

00000308 <strDispenserName1>:
     308:	4e 2f 41 00                                         N/A.

0000030c <strDispenserName2>:
     30c:	47 69 6c 62 61 72 63 6f 00                          Gilbarco.

00000315 <strDispenserName3>:
     315:	57 61 79 6e 65 20 44 41 52 54 00                    Wayne DART.

00000320 <strDispenserName4>:
     320:	54 61 74 73 75 6e 6f 00                             Tatsuno.

00000328 <strDispenserName5>:
     328:	4c 47 00                                            LG.

0000032b <DefListDispenserName>:
     32b:	08 03 0c 03 15 03 20 03 28 03                       ...... .(.

00000335 <__c.9981>:
     335:	25 64 00                                            %d.

00000338 <__c.9979>:
     338:	54 25 2e 32 64 25 2e 32 64 25 73 25 73 25 73 25     T%.2d%.2d%s%s%s%
     348:	73 25 73 25 73 3a 00                                s%s%s:.

0000034f <__c.9930>:
     34f:	32 30 25 73 2f 25 73 2f 25 73 20 25 73 3a 25 73     20%s/%s/%s %s:%s
     35f:	3a 25 73 00                                         :%s.

00000363 <__c.9902>:
     363:	25 73 00                                            %s.

00000366 <__c.9893>:
     366:	25 73 00                                            %s.

00000369 <__c.9842>:
     369:	25 63 25 2e 32 64 3a 00                             %c%.2d:.

00000371 <__c.9821>:
     371:	43 54 53 52 50 00                                   CTSRP.

00000377 <__c.9797>:
     377:	3a 00                                               :.

00000379 <__c.9741>:
     379:	46 6d 74 54 4d 6f 6e 65 79 3a 25 73 00              FmtTMoney:%s.

00000386 <__c.9739>:
     386:	46 6d 74 4d 6f 6e 65 79 3a 25 73 00                 FmtMoney:%s.

00000392 <__c.9737>:
     392:	54 4d 6f 6e 65 79 3a 25 73 00                       TMoney:%s.

0000039c <__c.9735>:
     39c:	54 56 6f 6c 75 6d 65 3a 25 73 00                    TVolume:%s.

000003a7 <__c.9733>:
     3a7:	4d 6f 6e 65 79 3a 25 73 00                          Money:%s.

000003b0 <__c.9731>:
     3b0:	56 6f 6c 75 6d 65 3a 25 73 00                       Volume:%s.

000003ba <__c.9729>:
     3ba:	52 65 6d 6f 76 65 64 3a 25 73 00                    Removed:%s.

000003c5 <__c.9727>:
     3c5:	4d 69 6e 75 73 3a 25 73 00                          Minus:%s.

000003ce <__c.9725>:
     3ce:	52 61 77 3a 25 73 00                                Raw:%s.

000003d5 <__c.9723>:
     3d5:	46 6f 72 6d 61 74 65 64 3a 25 73 00                 Formated:%s.

000003e1 <__c.9721>:
     3e1:	25 73 00                                            %s.

000003e4 <__c.9719>:
     3e4:	25 73 00                                            %s.

000003e7 <__c.9717>:
     3e7:	25 73 00                                            %s.

000003ea <__c.9715>:
     3ea:	25 73 00                                            %s.

000003ed <__c.9713>:
     3ed:	44 61 74 61 3a 25 73 00                             Data:%s.

000003f5 <__c.9602>:
     3f5:	4e 2f 41 00                                         N/A.

000003f9 <__c.9582>:
     3f9:	25 73 00                                            %s.

000003fc <__c.9577>:
	...

000003fd <__c.9450>:
     3fd:	25 64 2e 25 73 25 73 25 73 00                       %d.%s%s%s.

00000407 <__c.9448>:
     407:	25 64 2e 25 73 25 73 25 73 25 73 25 73 00           %d.%s%s%s%s%s.

00000415 <__c.9440>:
     415:	54 4f 54 41 4c 20 25 73 25 73 00                    TOTAL %s%s.

00000420 <__c.9438>:
     420:	54 4f 54 41 4c 20 25 73 25 73 25 73 25 73 00        TOTAL %s%s%s%s.

0000042f <__c.9434>:
     42f:	25 73 25 73 00                                      %s%s.

00000434 <__c.9432>:
     434:	25 73 25 73 25 73 25 73 00                          %s%s%s%s.

0000043d <__c.9430>:
     43d:	25 73 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 20 20 20     %s-----------   
     44d:	20 20 20 20 20 20 20 20 20 20 20 20 20 00                        .

0000045b <__c.9428>:
     45b:	25 73 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 20 20 20     %s-----------   
     46b:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 00           -------------.

00000479 <__c.9426>:
     479:	41 77 61 6c 20 3a 25 73 25 73 00                    Awal :%s%s.

00000484 <__c.9424>:
     484:	41 77 61 6c 20 3a 25 73 25 73 25 73 25 73 00        Awal :%s%s%s%s.

00000493 <__c.9422>:
     493:	41 6b 68 69 72 3a 25 73 25 73 00                    Akhir:%s%s.

0000049e <__c.9420>:
     49e:	41 6b 68 69 72 3a 25 73 25 73 25 73 25 73 00        Akhir:%s%s%s%s.

000004ad <__c.9418>:
     4ad:	50 25 64 2e 25 64 20 2d 20 25 73 20 00              P%d.%d - %s .

000004ba <__c.9416>:
     4ba:	50 25 64 2e 25 64 20 2d 20 25 73 20 25 73 20 25     P%d.%d - %s %s %
     4ca:	73 00                                               s.

000004cc <__c.9414>:
     4cc:	48 61 72 67 61 3a 20 52 70 2e 25 73 00              Harga: Rp.%s.

000004d9 <__c.9410>:
     4d9:	4e 2f 41 00                                         N/A.

000004dd <__c.9406>:
     4dd:	50 55 4d 50 2d 50 52 4f 44 55 43 54 20 20 20 56     PUMP-PRODUCT   V
     4ed:	4f 4c 55 4d 45 28 4c 29 20 20 20 20 20 20 20 20     OLUME(L)        
     4fd:	20 20 20 20 20 20 00                                      .

00000504 <__c.9404>:
     504:	50 55 4d 50 2d 50 52 4f 44 55 43 54 20 20 20 56     PUMP-PRODUCT   V
     514:	4f 4c 55 4d 45 28 4c 29 20 20 20 20 52 55 50 49     OLUME(L)    RUPI
     524:	41 48 28 52 50 29 00                                AH(RP).

0000052b <__c.9400>:
     52b:	41 6b 68 69 72 20 53 68 69 66 74 20 3a 20 25 73     Akhir Shift : %s
     53b:	20 00                                                .

0000053d <__c.9398>:
     53d:	41 77 61 6c 20 20 53 68 69 66 74 20 3a 20 25 73     Awal  Shift : %s
     54d:	20 00                                                .

0000054f <__c.9396>:
     54f:	54 65 72 6d 69 6e 61 6c 20 49 44 20 3a 20 25 2e     Terminal ID : %.
     55f:	32 64 20 20 20 20 20 20 20 20 20 20 20 20 20 20     2d              
     56f:	20 20 20 20 20 00                                        .

00000575 <__c.9394>:
     575:	20 20 20 20 20 20 20 20 4c 61 70 6f 72 61 6e 20             Laporan 
     585:	54 75 74 75 70 20 53 68 69 66 74 3a 20 25 73 20     Tutup Shift: %s 
     595:	20 20 20 20 20 00                                        .

0000059b <__c.9391>:
     59b:	25 64 00                                            %d.

0000059e <__c.9333>:
     59e:	25 73 00                                            %s.

000005a1 <__c.9328>:
     5a1:	30 00                                               0.

000005a3 <__c.9326>:
     5a3:	30 00                                               0.

000005a5 <__c.9162>:
     5a5:	25 73 00                                            %s.

000005a8 <__c.9160>:
     5a8:	25 73 00                                            %s.

000005ab <__c.9158>:
     5ab:	25 73 00                                            %s.

000005ae <__c.9156>:
     5ae:	25 73 00                                            %s.

000005b1 <__c.9154>:
     5b1:	25 73 00                                            %s.

000005b4 <__c.9068>:
     5b4:	41 2b 42 3a 25 73 00                                A+B:%s.

000005bb <__c.9066>:
     5bb:	49 6e 42 3a 25 73 00                                InB:%s.

000005c2 <__c.9062>:
     5c2:	49 6e 42 3a 5f 00                                   InB:_.

000005c8 <__c.9060>:
     5c8:	49 6e 41 3a 25 73 00                                InA:%s.

000005cf <__c.9055>:
     5cf:	49 6e 41 3a 5f 00                                   InA:_.

000005d5 <__c.9053>:
     5d5:	4f 70 65 72 61 74 69 6f 6e 20 4d 75 6c 74 69 70     Operation Multip
     5e5:	6c 79 00                                            ly.

000005e8 <__c.8924>:
     5e8:	25 73 00                                            %s.

000005eb <__c.8836>:
     5eb:	30 30 30 30 30 30 30 30 00                          00000000.

000005f4 <__c.8679>:
     5f4:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
     604:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
     614:	20 20 20 00                                            .

00000618 <__c.8677>:
     618:	20 20 20 20 20 20 20 20 20 20 20 20 20 44 55 50                  DUP
     628:	4c 49 43 41 54 45 20 43 4f 50 59 20 20 20 20 20     LICATE COPY     
     638:	20 20 20 00                                            .

0000063c <__c.8530>:
     63c:	20 20 20 20 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d         ------------
     64c:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     65c:	2d 2d 00                                            --.

0000065f <__c.8527>:
     65f:	20 20 20 20 20 53 75 72 63 68 61 72 67 65 20 41          Surcharge A
     66f:	6d 74 3a 20 25 73 00                                mt: %s.

00000676 <__c.8524>:
     676:	20 20 20 20 20 53 75 72 63 68 61 72 67 65 20 44          Surcharge D
     686:	73 63 3a 20 25 73 00                                sc: %s.

0000068d <__c.8521>:
     68d:	20 20 20 20 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d         ------------
     69d:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     6ad:	2d 2d 00                                            --.

000006b0 <__c.8518>:
     6b0:	20 20 20 20 20 4d 6f 6e 74 68 20 43 6f 6e 73 20          Month Cons 
     6c0:	41 20 3a 20 52 70 2e 25 73 00                       A : Rp.%s.

000006ca <__c.8515>:
     6ca:	20 20 20 20 20 4d 6f 6e 74 68 20 43 6f 6e 73 20          Month Cons 
     6da:	56 20 3a 20 25 73 20 4c 00                          V : %s L.

000006e3 <__c.8512>:
     6e3:	20 20 20 20 20 54 6f 74 61 6c 20 52 65 64 65 65          Total Redee
     6f3:	6d 20 3a 20 25 73 00                                m : %s.

000006fa <__c.8509>:
     6fa:	20 20 20 20 20 45 78 70 69 72 79 20 20 20 20 20          Expiry     
     70a:	20 20 3a 20 25 73 00                                  : %s.

00000711 <__c.8506>:
     711:	20 20 20 20 20 43 75 72 72 20 50 6f 69 6e 74 73          Curr Points
     721:	20 20 3a 20 25 73 00                                  : %s.

00000728 <__c.8503>:
     728:	20 20 20 20 20 50 72 65 76 20 50 6f 69 6e 74 73          Prev Points
     738:	20 20 3a 20 25 73 00                                  : %s.

0000073f <__c.8500>:
     73f:	20 20 20 20 20 47 61 69 6e 20 50 6f 69 6e 74 73          Gain Points
     74f:	20 20 3a 20 25 73 00                                  : %s.

00000756 <__c.8497>:
     756:	20 20 20 20 20 43 6f 72 70 20 4e 61 6d 65 20 20          Corp Name  
     766:	20 20 3a 20 25 73 00                                  : %s.

0000076d <__c.8494>:
     76d:	20 20 20 20 20 43 6f 72 70 20 49 44 20 20 20 20          Corp ID    
     77d:	20 20 3a 20 25 73 00                                  : %s.

00000784 <__c.8491>:
     784:	20 20 20 20 20 43 61 72 64 20 48 6f 6c 64 65 72          Card Holder
     794:	20 20 3a 20 25 73 20 00                               : %s .

0000079c <__c.8488>:
     79c:	20 20 20 20 20 43 61 72 64 20 49 44 20 20 20 20          Card ID    
     7ac:	20 20 3a 20 25 73 00                                  : %s.

000007b3 <__c.8485>:
     7b3:	20 20 20 20 20 20 20 20 20 4c 4f 59 41 4c 54 59              LOYALTY
     7c3:	20 49 4e 46 4f 52 4d 41 54 49 4f 4e 20 20 20 20      INFORMATION    
     7d3:	20 20 00                                              .

000007d6 <__c.8482>:
     7d6:	20 20 20 20 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d         ------------
     7e6:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     7f6:	2d 2d 00                                            --.

000007f9 <__c.8479>:
     7f9:	20 20 20 20 2e 25 73 00                                 .%s.

00000801 <__c.8475>:
     801:	20 20 20 20 54 61 6e 64 61 20 54 61 6e 67 61 6e         Tanda Tangan
     811:	20 20 28 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f       (_____________
     821:	5f 29 00                                            _).

00000824 <__c.8470>:
     824:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
     834:	20 20 20 20 20 20 00                                      .

0000083b <__c.8467>:
     83b:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
     84b:	20 20 20 20 20 20 00                                      .

00000852 <__c.8464>:
     852:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
     862:	20 00                                                .

00000864 <__c.8462>:
     864:	20 20 00                                              .

00000867 <__c.8460>:
     867:	20 20 20 20 41 70 70 72 20 43 6f 64 65 3a 20 25         Appr Code: %
     877:	73 00                                               s.

00000879 <__c.8458>:
     879:	25 73 20 20 00                                      %s  .

0000087e <__c.8456>:
     87e:	20 20 20 20 4e 61 6d 61 20 20 20 20 20 3a 20 25         Nama     : %
     88e:	73 00                                               s.

00000890 <__c.8453>:
     890:	20 20 20 20 20 20 20 20 20 20 2a 2a 2a 20 50 55               *** PU
     8a0:	4d 50 20 54 45 53 54 20 2a 2a 2a 20 20 20 20 20     MP TEST ***     
     8b0:	20 20 00                                              .

000008b3 <__c.8451>:
     8b3:	20 20 20 20 56 6f 75 63 68 65 72 20 4e 6f 3a 20         Voucher No: 
     8c3:	25 73 00                                            %s.

000008c6 <__c.8449>:
     8c6:	20 20 20 20 4b 61 72 74 75 20 49 44 20 3a 20 25         Kartu ID : %
     8d6:	73 00                                               s.

000008d8 <__c.8446>:
     8d8:	20 20 20 20 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d         ------------
     8e8:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     8f8:	2d 2d 00                                            --.

000008fb <__c.8443>:
     8fb:	20 20 20 20 20 20 4f 64 6f 6d 65 74 65 72 20 20           Odometer  
     90b:	20 20 3a 20 25 73 00                                  : %s.

00000912 <__c.8440>:
     912:	20 20 20 20 20 20 4e 6f 2e 50 6f 6c 69 73 69 20           No.Polisi 
     922:	20 20 3a 20 25 73 00                                  : %s.

00000929 <__c.8437>:
	...

0000092a <__c.8435>:
     92a:	20 20 20 20 20 20 4a 6d 6c 20 52 75 70 69 61 68           Jml Rupiah
     93a:	20 20 3a 20 52 70 2e 25 73 00                         : Rp.%s.

00000944 <__c.8432>:
     944:	20 20 20 20 20 20 4a 6d 6c 20 4c 69 74 65 72 20           Jml Liter 
     954:	20 20 3a 20 25 73 20 4c 00                            : %s L.

0000095d <__c.8429>:
	...

0000095e <__c.8427>:
     95e:	20 20 20 20 20 20 48 61 72 67 61 2f 4c 20 20 20           Harga/L   
     96e:	20 20 3a 20 52 70 2e 25 73 00                         : Rp.%s.

00000978 <__c.8424>:
     978:	20 20 20 20 20 20 50 72 6f 64 75 6b 20 20 20 20           Produk    
     988:	20 20 3a 20 25 73 00                                  : %s.

0000098f <__c.8421>:
     98f:	20 20 20 20 20 20 50 75 6c 61 75 2f 50 6f 6d 70           Pulau/Pomp
     99f:	61 20 3a 20 5b 25 73 5d 2d 25 73 00                 a : [%s]-%s.

000009ab <__c.8418>:
     9ab:	20 20 20 20 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d         ------------
     9bb:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     9cb:	2d 2d 00                                            --.

000009ce <__c.8415>:
     9ce:	20 20 20 20 20 20 57 61 6b 74 75 3a 20 25 73 20           Waktu: %s 
     9de:	25 73 20 00                                         %s .

000009e2 <__c.8411>:
     9e2:	20 20 20 20 20 20 53 68 69 66 74 3a 20 25 73 20           Shift: %s 
     9f2:	20 4e 6f 2e 54 72 61 6e 73 3a 20 25 73 20 00         No.Trans: %s .

00000a01 <__c.8394>:
     a01:	20 00                                                .

00000a03 <__c.8392>:
     a03:	20 20 20 20 20 20 20 20 20 20 20 20 20 44 55 50                  DUP
     a13:	4c 49 43 41 54 45 20 43 4f 50 59 20 20 20 20 20     LICATE COPY     
     a23:	20 20 20 00                                            .

00000a27 <__c.7990>:
     a27:	45 72 72 6f 72 20 4e 6f 20 43 6f 6e 6e 65 63 74     Error No Connect
     a37:	69 6f 6e 00                                         ion.

00000a3b <__c.7984>:
     a3b:	50 72 6f 73 65 73 00                                Proses.

00000a42 <__c.7982>:
     a42:	53 65 6e 64 20 52 65 71 75 65 73 74 00              Send Request.

00000a4f <__c.7977>:
     a4f:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
     a5f:	6e 74 65 72 00                                      nter.

00000a64 <__c.7975>:
     a64:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
     a74:	6e 74 65 72 00                                      nter.

00000a79 <__c.7972>:
     a79:	5b 2a 5d 43 61 6e 63 65 6c 20 20 5b 23 5d 45 6e     [*]Cancel  [#]En
     a89:	74 65 72 20 00                                      ter .

00000a8e <__c.7970>:
     a8e:	4f 64 6f 6d 65 74 65 72 3a 5f 20 00                 Odometer:_ .

00000a9a <__c.7968>:
     a9a:	50 6c 61 74 20 4e 6f 3a 20 25 73 20 00              Plat No: %s .

00000aa7 <__c.7965>:
     aa7:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
     ab7:	6e 74 65 72 00                                      nter.

00000abc <__c.7963>:
     abc:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
     acc:	6e 74 65 72 00                                      nter.

00000ad1 <__c.7960>:
     ad1:	5b 2a 5d 43 61 6e 63 65 6c 20 20 5b 23 5d 45 6e     [*]Cancel  [#]En
     ae1:	74 65 72 20 00                                      ter .

00000ae6 <__c.7958>:
     ae6:	5f 00                                               _.

00000ae8 <__c.7956>:
     ae8:	49 6e 70 75 74 20 50 6c 61 74 20 4e 6f 3a 20 00     Input Plat No: .

00000af8 <__c.7877>:
     af8:	23 29 53 61 76 65 00                                #)Save.

00000aff <__c.7875>:
     aff:	34 29 54 65 72 6d 49 44 3a 25 64 20 00              4)TermID:%d .

00000b0c <__c.7857>:
     b0c:	23 29 53 61 76 65 00                                #)Save.

00000b13 <__c.7855>:
     b13:	34 29 54 65 72 6d 49 44 3a 25 64 20 00              4)TermID:%d .

00000b20 <__c.7853>:
     b20:	33 29 4e 6f 74 69 66 20 3a 20 20 20 20 20 2a 29     3)Notif :     *)
     b30:	45 78 69 74 00                                      Exit.

00000b35 <__c.7851>:
     b35:	32 29 44 2f 54 20 20 20 3a 00                       2)D/T   :.

00000b3f <__c.7849>:
     b3f:	31 29 4d 6f 6e 65 79 20 3a 00                       1)Money :.

00000b49 <__c.7775>:
     b49:	34 29 43 75 74 20 3a 20 20 2a 29 45 78 69 74 00     4)Cut :  *)Exit.

00000b59 <__c.7773>:
     b59:	33 29 4c 6f 67 6f 3a 20 20 23 29 53 61 76 65 00     3)Logo:  #)Save.

00000b69 <__c.7771>:
     b69:	32 29 53 69 7a 65 3a 20 20 36 29 53 70 61 63 65     2)Size:  6)Space
     b79:	20 3a 00                                             :.

00000b7c <__c.7769>:
     b7c:	31 29 54 79 70 65 3a 20 20 35 29 53 63 72 6f 6c     1)Type:  5)Scrol
     b8c:	6c 3a 00                                            l:.

00000b8f <__c.7705>:
     b8f:	2a 29 43 61 6e 63 65 6c 20 20 20 20 20 20 23 29     *)Cancel      #)
     b9f:	53 61 76 65 00                                      Save.

00000ba4 <__c.7703>:
     ba4:	54 49 4d 45 20 3a 20 00                             TIME : .

00000bac <__c.7701>:
     bac:	44 41 54 45 20 3a 20 00                             DATE : .

00000bb4 <__c.7636>:
     bb4:	2a 29 45 78 69 74 20 20 20 20 20 20 20 20 23 29     *)Exit        #)
     bc4:	53 61 76 65 00                                      Save.

00000bc9 <__c.7634>:
     bc9:	32 29 4e 32 3a 20 20 34 29 4e 34 3a 20 20 36 29     2)N2:  4)N4:  6)
     bd9:	4e 36 3a 00                                         N6:.

00000bdd <__c.7632>:
     bdd:	31 29 4e 31 3a 20 20 33 29 4e 33 3a 20 20 35 29     1)N1:  3)N3:  5)
     bed:	4e 35 3a 00                                         N5:.

00000bf1 <__c.7630>:
     bf1:	50 72 6f 64 75 63 74 20 46 49 50 25 2e 32 64 00     Product FIP%.2d.

00000c01 <__c.7546>:
     c01:	43 6f 6d 70 6c 65 74 65 64 00                       Completed.

00000c0b <__c.7544>:
     c0b:	43 61 6e 63 65 6c 20 20 20 20 20 00                 Cancel     .

00000c17 <__c.7541>:
     c17:	49 64 5b 25 64 5d 3d 25 2e 32 64 20 20 00           Id[%d]=%.2d  .

00000c25 <__c.7538>:
     c25:	53 61 76 69 6e 67 2e 2e 00                          Saving...

00000c2e <__c.7536>:
     c2e:	2d 50 75 6d 70 49 44 2d 00                          -PumpID-.

00000c37 <__c.7532>:
     c37:	20 20 20 20 4e 6f 74 20 41 6c 6c 6f 77 65 64 20         Not Allowed 
     c47:	20 20 20 20 00                                          .

00000c4c <__c.7530>:
     c4c:	20 20 44 75 70 6c 69 63 61 74 65 20 50 75 6d 70       Duplicate Pump
     c5c:	49 44 20 20 00                                      ID  .

00000c61 <__c.7528>:
     c61:	20 20 20 20 20 20 57 61 72 6e 69 6e 67 21 20 20           Warning!  
     c71:	20 20 20 20 00                                          .

00000c76 <__c.7516>:
     c76:	25 64 2e 50 25 2e 32 64 20 7c 20 25 64 2e 50 25     %d.P%.2d | %d.P%
     c86:	2e 32 64 00                                         .2d.

00000c8a <__c.7510>:
     c8a:	23 29 53 61 76 65 00                                #)Save.

00000c91 <__c.7508>:
     c91:	2a 29 42 61 63 6b 00                                *)Back.

00000c98 <__c.7503>:
     c98:	25 64 2e 50 25 2e 32 64 20 7c 20 25 64 2e 50 25     %d.P%.2d | %d.P%
     ca8:	2e 32 64 00                                         .2d.

00000cac <__c.7454>:
     cac:	25 2e 32 64 00                                      %.2d.

00000cb1 <__c.7448>:
     cb1:	25 2e 32 64 00                                      %.2d.

00000cb6 <__c.7446>:
     cb6:	34 29 34 3a 20 20 20 38 29 38 3a 20 20 20 2a 29     4)4:   8)8:   *)
     cc6:	45 78 69 74 00                                      Exit.

00000ccb <__c.7444>:
     ccb:	33 29 33 3a 20 20 20 37 29 37 3a 20 20 20 23 29     3)3:   7)7:   #)
     cdb:	53 61 76 65 00                                      Save.

00000ce0 <__c.7442>:
     ce0:	32 29 32 3a 20 20 20 36 29 36 3a 00                 2)2:   6)6:.

00000cec <__c.7440>:
     cec:	31 29 31 3a 20 20 20 35 29 35 3a 00                 1)1:   5)5:.

00000cf8 <__c.7406>:
     cf8:	5b 2a 5d 45 78 69 74 20 20 5b 23 5d 43 68 61 6e     [*]Exit  [#]Chan
     d08:	67 65 20 00                                         ge .

00000d0c <__c.7404>:
     d0c:	25 64 2e 25 73 00                                   %d.%s.

00000d12 <__c.7399>:
     d12:	2d 44 69 73 70 65 6e 73 65 72 20 42 72 61 6e 64     -Dispenser Brand
     d22:	2d 00                                               -.

00000d24 <__c.7383>:
     d24:	2a 29 45 78 69 74 00                                *)Exit.

00000d2b <__c.7381>:
     d2b:	32 29 50 72 6f 64 75 63 74 00                       2)Product.

00000d35 <__c.7379>:
     d35:	31 29 49 44 00                                      1)ID.

00000d3a <__c.7364>:
     d3a:	2a 29 45 78 69 74 00                                *)Exit.

00000d41 <__c.7359>:
     d41:	25 64 2e 50 25 2e 32 64 20 7c 20 25 64 2e 50 25     %d.P%.2d | %d.P%
     d51:	2e 32 64 20 00                                      .2d .

00000d56 <__c.7350>:
     d56:	25 2e 32 64 00                                      %.2d.

00000d5b <__c.7149>:
     d5b:	5b 2a 5d 45 78 69 74 00                             [*]Exit.

00000d63 <__c.7147>:
     d63:	36 2e 41 63 74 3a 25 64 00                          6.Act:%d.

00000d6c <__c.7145>:
     d6c:	35 2e 44 6c 79 3a 25 64 00                          5.Dly:%d.

00000d75 <__c.7143>:
     d75:	34 2e 54 69 6d 50 6f 6f 6c 3a 25 64 00              4.TimPool:%d.

00000d82 <__c.7141>:
     d82:	33 2e 54 72 79 53 65 6e 64 3a 25 64 00              3.TrySend:%d.

00000d8f <__c.7139>:
     d8f:	32 2e 6e 4e 6f 50 75 6d 70 3a 25 64 00              2.nNoPump:%d.

00000d9c <__c.7137>:
     d9c:	31 2e 4d 61 78 50 75 6d 70 3a 25 64 00              1.MaxPump:%d.

00000da9 <__c.7078>:
     da9:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 00              [*]Back     .

00000db6 <__c.7073>:
     db6:	43 4f 4d 25 64 3a 25 64 00                          COM%d:%d.

00000dbf <__c.7071>:
     dbf:	20 20 20 20 20 2d 42 61 75 64 72 61 74 65 2d 20          -Baudrate- 
     dcf:	20 20 20 20 00                                          .

00000dd4 <__c.7066>:
     dd4:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 20 00           [*]Back      .

00000de2 <__c.7064>:
     de2:	33 2e 43 4f 4d 33 3a 34 38 35 00                    3.COM3:485.

00000ded <__c.7062>:
     ded:	33 2e 43 4f 4d 33 3a 32 33 32 00                    3.COM3:232.

00000df8 <__c.7060>:
     df8:	33 2e 43 4f 4d 33 3a 54 54 4c 00                    3.COM3:TTL.

00000e03 <__c.7058>:
     e03:	32 2e 42 61 75 64 72 61 74 65 00                    2.Baudrate.

00000e0e <__c.7056>:
     e0e:	31 2e 4d 6f 64 65 3a 53 74 61 6e 64 61 6c 6f 6e     1.Mode:Standalon
     e1e:	65 00                                               e.

00000e20 <__c.7054>:
     e20:	31 2e 4d 6f 64 65 3a 53 6c 61 76 65 00              1.Mode:Slave.

00000e2d <__c.7052>:
     e2d:	31 2e 4d 6f 64 65 3a 4e 6f 6e 65 00                 1.Mode:None.

00000e39 <__c.7005>:
     e39:	49 6e 76 61 6c 69 64 20 4f 6c 64 20 50 61 73 73     Invalid Old Pass
     e49:	77 6f 72 64 00                                      word.

00000e4e <__c.7003>:
     e4e:	20 20 20 20 20 20 45 52 52 4f 52 20 20 20 20 20           ERROR     
     e5e:	20 20 20 20 00                                          .

00000e63 <__c.7001>:
     e63:	49 6e 76 61 6c 69 64 20 4e 65 77 20 50 61 73 73     Invalid New Pass
     e73:	77 6f 72 64 00                                      word.

00000e78 <__c.6999>:
     e78:	20 20 20 20 20 20 45 52 52 4f 52 20 20 20 20 20           ERROR     
     e88:	20 20 20 20 00                                          .

00000e8d <__c.6997>:
     e8d:	20 20 20 50 61 73 73 77 6f 72 64 20 53 61 76 65        Password Save
     e9d:	64 20 20 20 00                                      d   .

00000ea2 <__c.6995>:
     ea2:	20 20 20 20 20 43 6f 6d 70 6c 65 74 65 64 20 20          Completed  
     eb2:	20 20 20 20 00                                          .

00000eb7 <__c.6991>:
     eb7:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
     ec7:	6e 74 65 72 00                                      nter.

00000ecc <__c.6988>:
     ecc:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
     edc:	6e 74 65 72 00                                      nter.

00000ee1 <__c.6985>:
     ee1:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
     ef1:	6e 74 65 72 00                                      nter.

00000ef6 <__c.6983>:
     ef6:	4e 65 77 3a 5f 20 20 20 20 20 20 20 20 20 20 20     New:_           
     f06:	20 20 20 20 00                                          .

00000f0b <__c.6979>:
     f0b:	56 61 6c 69 64 61 74 69 6e 67 2e 2e 00              Validating...

00000f18 <__c.6975>:
     f18:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
     f28:	6e 74 65 72 00                                      nter.

00000f2d <__c.6972>:
     f2d:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
     f3d:	6e 74 65 72 00                                      nter.

00000f42 <__c.6967>:
     f42:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
     f52:	6e 74 65 72 00                                      nter.

00000f57 <__c.6965>:
     f57:	4e 65 77 3a 5f 20 20 20 20 20 20 20 20 20 20 20     New:_           
     f67:	20 20 20 20 00                                          .

00000f6c <__c.6961>:
     f6c:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
     f7c:	6e 74 65 72 00                                      nter.

00000f81 <__c.6958>:
     f81:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
     f91:	6e 74 65 72 00                                      nter.

00000f96 <__c.6953>:
     f96:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
     fa6:	6e 74 65 72 00                                      nter.

00000fab <__c.6951>:
     fab:	4e 65 77 3a 5f 20 20 20 20 20 20 20 20 20 20 20     New:_           
     fbb:	20 20 20 20 00                                          .

00000fc0 <__c.6947>:
     fc0:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
     fd0:	6e 74 65 72 00                                      nter.

00000fd5 <__c.6945>:
     fd5:	4f 6c 64 3a 5f 00                                   Old:_.

00000fdb <__c.6943>:
     fdb:	2d 41 64 6d 69 6e 69 73 74 72 61 74 6f 72 2d 00     -Administrator-.

00000feb <__c.6941>:
     feb:	2d 53 75 70 65 72 76 69 73 6f 72 2d 00              -Supervisor-.

00000ff8 <__c.6933>:
     ff8:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 00              [*]Back     .

00001005 <__c.6931>:
    1005:	32 2e 41 64 6d 69 6e 69 73 74 72 61 74 6f 72 00     2.Administrator.

00001015 <__c.6929>:
    1015:	31 2e 53 75 70 65 72 76 69 73 6f 72 00              1.Supervisor.

00001022 <__c.6927>:
    1022:	2d 43 68 61 6e 67 65 20 50 61 73 73 77 6f 72 64     -Change Password
    1032:	2d 00                                               -.

00001034 <__c.6924>:
    1034:	53 61 76 65 64 20 00                                Saved .

0000103b <__c.6918>:
    103b:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    104b:	6e 74 65 72 00                                      nter.

00001050 <__c.6915>:
    1050:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
    1060:	6e 74 65 72 00                                      nter.

00001065 <__c.6910>:
    1065:	5b 2a 5d 4e 6f 20 20 20 20 5b 23 5d 59 65 73 00     [*]No    [#]Yes.

00001075 <__c.6908>:
    1075:	53 61 76 65 3f 00                                   Save?.

0000107b <__c.6906>:
    107b:	4e 65 77 20 4f 70 65 72 61 74 6f 72 3a 00           New Operator:.

00001089 <__c.6904>:
    1089:	25 73 00                                            %s.

0000108c <__c.6900>:
    108c:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    109c:	6e 74 65 72 00                                      nter.

000010a1 <__c.6898>:
    10a1:	4e 65 77 20 3a 5f 20 20 20 20 20 20 20 20 20 20     New :_          
    10b1:	20 20 20 20 00                                          .

000010b6 <__c.6896>:
    10b6:	4e 61 6d 65 3a 00                                   Name:.

000010bc <__c.6894>:
    10bc:	25 73 00                                            %s.

000010bf <__c.6885>:
    10bf:	32 2e 43 68 61 6e 67 65 20 50 61 73 73 77 6f 72     2.Change Passwor
    10cf:	64 00                                               d.

000010d1 <__c.6883>:
    10d1:	31 2e 43 68 61 6e 67 65 20 4f 70 65 72 61 74 6f     1.Change Operato
    10e1:	72 00                                               r.

000010e3 <__c.6800>:
    10e3:	2a 29 42 61 63 6b 00                                *)Back.

000010ea <__c.6798>:
    10ea:	34 2e 53 70 61 72 61 74 6f 72 3a 25 63 20 00        4.Sparator:%c .

000010f9 <__c.6796>:
    10f9:	33 2e 44 65 63 69 6d 61 6c 20 3a 25 63 20 00        3.Decimal :%c .

00001108 <__c.6794>:
    1108:	32 2e 54 2e 4d 6f 6e 65 79 20 3a 25 64 20 00        2.T.Money :%d .

00001117 <__c.6792>:
    1117:	31 2e 54 2e 56 6f 6c 75 6d 65 3a 25 64 20 20 35     1.T.Volume:%d  5
    1127:	2e 54 65 73 74 00                                   .Test.

0000112d <__c.6787>:
    112d:	5b 2a 5d 42 61 63 6b 20 20 5b 23 5d 4e 65 78 74     [*]Back  [#]Next
	...

0000113e <__c.6785>:
    113e:	33 2e 4d 6f 6e 65 79 20 3a 25 64 00                 3.Money :%d.

0000114a <__c.6783>:
    114a:	32 2e 56 6f 6c 75 6d 65 3a 25 64 00                 2.Volume:%d.

00001156 <__c.6781>:
    1156:	31 2e 50 72 69 63 65 20 3a 25 64 00                 1.Price :%d.

00001162 <__c.6764>:
    1162:	34 29 42 72 61 6e 64 20 20 2a 29 45 78 69 74 00     4)Brand  *)Exit.

00001172 <__c.6762>:
    1172:	33 29 4c 61 62 65 6c 20 20 00                       3)Label  .

0000117c <__c.6760>:
    117c:	32 29 50 72 6f 64 75 63 74 00                       2)Product.

00001186 <__c.6758>:
    1186:	31 29 49 44 20 20 20 20 20 00                       1)ID     .

00001190 <__c.6717>:
    1190:	2a 29 42 61 63 6b 20 20 20 20 23 29 4f 4b 20 20     *)Back    #)OK  
    11a0:	20 20 20 20 00                                          .

000011a5 <__c.6715>:
    11a5:	4e 65 77 3a 5f 00                                   New:_.

000011ab <__c.6713>:
    11ab:	4f 6c 64 3a 25 73 00                                Old:%s.

000011b2 <__c.6711>:
    11b2:	2a 29 42 61 63 6b 20 20 20 20 23 29 4f 4b 20 20     *)Back    #)OK  
    11c2:	20 20 20 20 00                                          .

000011c7 <__c.6709>:
    11c7:	4e 65 77 3a 5f 00                                   New:_.

000011cd <__c.6707>:
    11cd:	45 64 69 74 20 50 72 6f 64 75 63 74 20 4e 61 6d     Edit Product Nam
    11dd:	65 20 20 20 00                                      e   .

000011e2 <__c.6705>:
    11e2:	4f 6c 64 3a 25 73 00                                Old:%s.

000011e9 <__c.6702>:
    11e9:	2a 29 42 61 63 6b 20 20 20 20 20 20 20 00           *)Back       .

000011f7 <__c.6700>:
    11f7:	32 29 25 73 00                                      2)%s.

000011fc <__c.6698>:
    11fc:	31 29 25 73 00                                      1)%s.

00001201 <__c.6693>:
    1201:	2a 29 42 61 63 6b 00                                *)Back.

00001208 <__c.6688>:
    1208:	25 64 29 25 73 00                                   %d)%s.

0000120e <__c.6615>:
    120e:	2a 29 42 61 63 6b 20 20 20 20 20 20 20 20 20 20     *)Back          
    121e:	20 20 20 20 00                                          .

00001223 <__c.6613>:
    1223:	33 29 50 75 6d 70 50 6f 6f 6c 69 6e 67 20 20 20     3)PumpPooling   
    1233:	20 20 20 20 00                                          .

00001238 <__c.6611>:
    1238:	32 29 53 79 73 74 65 6d 20 20 20 20 20 20 20 20     2)System        
    1248:	20 20 20 20 00                                          .

0000124d <__c.6609>:
    124d:	31 29 4f 70 65 72 61 74 6f 72 20 20 20 20 20 20     1)Operator      
    125d:	20 20 20 20 00                                          .

00001262 <__c.6606>:
    1262:	34 29 44 61 74 65 74 69 6d 65 20 2a 29 45 78 69     4)Datetime *)Exi
    1272:	74 20 20 20 00                                      t   .

00001277 <__c.6604>:
    1277:	33 29 44 65 63 69 6d 61 6c 20 20 37 29 4e 65 78     3)Decimal  7)Nex
    1287:	74 20 20 20 00                                      t   .

0000128c <__c.6602>:
    128c:	32 29 50 75 6d 70 20 20 20 20 20 36 29 48 6f 73     2)Pump     6)Hos
    129c:	74 20 20 20 00                                      t   .

000012a1 <__c.6600>:
    12a1:	31 29 50 72 6f 64 75 63 74 20 20 35 29 50 72 69     1)Product  5)Pri
    12b1:	6e 74 65 72 00                                      nter.

000012b6 <__c.6513>:
    12b6:	2e 00                                               ..

000012b8 <__c.6511>:
    12b8:	25 64 00                                            %d.

000012bb <__c.6509>:
    12bb:	20 20 20 00                                            .

000012bf <__c.6507>:
    12bf:	2e 00                                               ..

000012c1 <__c.6505>:
    12c1:	25 64 00                                            %d.

000012c4 <__c.6503>:
    12c4:	20 20 20 00                                            .

000012c8 <__c.6496>:
    12c8:	5b 2a 5d 63 61 6e 63 65 6c 20 20 5b 23 5d 6e 65     [*]cancel  [#]ne
    12d8:	78 74 20 20 00                                      xt  .

000012dd <__c.6494>:
    12dd:	4e 65 77 3a 20 20 20 5f 2e 20 20 20 2e 20 20 20     New:   _.   .   
    12ed:	2e 20 20 20 00                                      .   .

000012f2 <__c.6492>:
    12f2:	4f 6c 64 3a 20 25 64 2e 25 64 2e 25 64 2e 25 64     Old: %d.%d.%d.%d
	...

00001303 <__c.6490>:
    1303:	53 65 72 76 65 72 20 49 50 00                       Server IP.

0000130d <__c.6399>:
    130d:	2e 00                                               ..

0000130f <__c.6397>:
    130f:	25 64 00                                            %d.

00001312 <__c.6395>:
    1312:	20 20 20 00                                            .

00001316 <__c.6393>:
    1316:	2e 00                                               ..

00001318 <__c.6391>:
    1318:	25 64 00                                            %d.

0000131b <__c.6389>:
    131b:	20 20 20 00                                            .

0000131f <__c.6382>:
    131f:	5b 2a 5d 63 61 6e 63 65 6c 20 20 5b 23 5d 6e 65     [*]cancel  [#]ne
    132f:	78 74 20 20 00                                      xt  .

00001334 <__c.6380>:
    1334:	4e 65 77 3a 20 20 20 5f 2e 20 20 20 2e 20 20 20     New:   _.   .   
    1344:	2e 20 20 20 00                                      .   .

00001349 <__c.6378>:
    1349:	4f 6c 64 3a 20 25 64 2e 25 64 2e 25 64 2e 25 64     Old: %d.%d.%d.%d
	...

0000135a <__c.6376>:
    135a:	43 6c 69 65 6e 74 20 49 50 00                       Client IP.

00001364 <__c.6333>:
    1364:	25 73 25 73 00                                      %s%s.

00001369 <__c.6329>:
    1369:	5b 2a 5d 4e 6f 20 5b 23 5d 59 65 73 00              [*]No [#]Yes.

00001376 <__c.6327>:
    1376:	53 61 76 65 20 46 6f 6f 74 65 72 25 64 20 3f 00     Save Footer%d ?.

00001386 <__c.6323>:
    1386:	5b 2a 5d 4e 6f 20 20 5b 23 5d 59 65 73 00           [*]No  [#]Yes.

00001394 <__c.6321>:
    1394:	41 6c 69 67 6e 20 43 65 6e 74 65 72 3f 00           Align Center?.

000013a2 <__c.6318>:
    13a2:	5b 2a 5d 42 61 63 6b 20 20 5b 23 5d 4f 4b 00        [*]Back  [#]OK.

000013b1 <__c.6316>:
    13b1:	45 64 69 74 20 46 6f 6f 74 65 72 25 64 20 00        Edit Footer%d .

000013c0 <__c.6312>:
    13c0:	2a 29 45 78 69 74 20 20 20 20 20 20 20 20 20 20     *)Exit          
    13d0:	20 20 20 20 00                                          .

000013d5 <__c.6310>:
    13d5:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    13e5:	20 20 20 20 00                                          .

000013ea <__c.6308>:
    13ea:	32 29 46 6f 6f 74 65 72 32 20 20 34 29 46 6f 6f     2)Footer2  4)Foo
    13fa:	74 65 72 34 00                                      ter4.

000013ff <__c.6306>:
    13ff:	31 29 46 6f 6f 74 65 72 31 20 20 33 29 46 6f 6f     1)Footer1  3)Foo
    140f:	74 65 72 33 00                                      ter3.

00001414 <__c.6274>:
    1414:	25 73 25 73 00                                      %s%s.

00001419 <__c.6270>:
    1419:	5b 2a 5d 4e 6f 20 5b 23 5d 59 65 73 00              [*]No [#]Yes.

00001426 <__c.6268>:
    1426:	53 61 76 65 20 48 65 61 64 65 72 25 64 20 3f 00     Save Header%d ?.

00001436 <__c.6264>:
    1436:	5b 2a 5d 4e 6f 20 20 5b 23 5d 59 65 73 00           [*]No  [#]Yes.

00001444 <__c.6262>:
    1444:	41 6c 69 67 6e 20 43 65 6e 74 65 72 3f 00           Align Center?.

00001452 <__c.6259>:
    1452:	5b 2a 5d 42 61 63 6b 20 20 5b 23 5d 4f 4b 00        [*]Back  [#]OK.

00001461 <__c.6257>:
    1461:	45 64 69 74 20 48 65 61 64 65 72 25 64 20 00        Edit Header%d .

00001470 <__c.6253>:
    1470:	2a 29 45 78 69 74 20 20 20 20 20 20 20 20 20 20     *)Exit          
    1480:	20 20 20 20 00                                          .

00001485 <__c.6251>:
    1485:	33 29 48 65 61 64 65 72 33 20 20 36 29 48 65 61     3)Header3  6)Hea
    1495:	64 65 72 36 00                                      der6.

0000149a <__c.6249>:
    149a:	32 29 48 65 61 64 65 72 32 20 20 35 29 48 65 61     2)Header2  5)Hea
    14aa:	64 65 72 35 00                                      der5.

000014af <__c.6247>:
    14af:	31 29 48 65 61 64 65 72 31 20 20 34 29 48 65 61     1)Header1  4)Hea
    14bf:	64 65 72 34 00                                      der4.

000014c4 <__c.6204>:
    14c4:	2a 29 45 78 69 74 00                                *)Exit.

000014cb <__c.6202>:
    14cb:	33 29 50 61 73 73 77 6f 72 64 20 20 20 20 20 20     3)Password      
    14db:	20 20 20 20 00                                          .

000014e0 <__c.6200>:
    14e0:	32 29 46 6f 6f 74 65 72 20 20 20 20 20 20 20 20     2)Footer        
    14f0:	20 20 20 20 00                                          .

000014f5 <__c.6198>:
    14f5:	31 29 48 65 61 64 65 72 20 20 20 20 20 20 20 20     1)Header        
    1505:	20 20 20 20 00                                          .

0000150a <__c.6196>:
    150a:	32 29 46 6f 6f 74 65 72 20 20 20 20 35 29 53 65     2)Footer    5)Se
    151a:	72 76 65 72 00                                      rver.

0000151f <__c.6194>:
    151f:	31 29 48 65 61 64 65 72 20 20 20 20 34 29 43 6c     1)Header    4)Cl
    152f:	69 65 6e 74 00                                      ient.

00001534 <__c.6140>:
    1534:	53 61 76 69 6e 67 20 53 68 69 66 74 44 61 74 61     Saving ShiftData
    1544:	2e 2e 20 00                                         .. .

00001548 <__c.6135>:
    1548:	25 73 20 25 73 00                                   %s %s.

0000154e <__c.6133>:
    154e:	50 72 69 6e 74 69 6e 67 20 54 6f 74 61 6c 69 7a     Printing Totaliz
    155e:	65 72 00                                            er.

00001561 <__c.6129>:
    1561:	43 61 6e 63 65 6c 00                                Cancel.

00001568 <__c.6124>:
    1568:	45 72 72 6f 72 20 2d 20 4e 6f 20 50 75 6d 70 3a     Error - No Pump:
    1578:	25 64 20 00                                         %d .

0000157c <__c.6119>:
    157c:	57 61 69 74 20 50 75 6d 70 3a 25 64 20 00           Wait Pump:%d .

0000158a <__c.6115>:
    158a:	57 61 69 74 20 50 75 6d 70 3a 25 64 20 00           Wait Pump:%d .

00001598 <__c.6113>:
    1598:	54 6f 74 61 6c 69 7a 65 72 2e 2e 00                 Totalizer...

000015a4 <__c.6041>:
    15a4:	2a 29 45 78 69 74 00                                *)Exit.

000015ab <__c.6039>:
    15ab:	33 2e 4c 6f 63 6b 20 50 75 6d 70 20 20 00           3.Lock Pump  .

000015b9 <__c.6037>:
    15b9:	32 2e 43 6c 6f 73 65 20 44 61 79 20 20 00           2.Close Day  .

000015c7 <__c.6035>:
    15c7:	31 2e 43 6c 6f 73 65 20 53 68 69 66 74 00           1.Close Shift.

000015d5 <__c.5993>:
    15d5:	34 29 53 65 74 74 69 6e 67 73 20 20 20 2a 29 45     4)Settings   *)E
    15e5:	78 69 74 20 00                                      xit .

000015ea <__c.5991>:
    15ea:	33 29 43 6c 6f 73 65 44 61 79 20 20 20 20 20 20     3)CloseDay      
    15fa:	20 20 20 20 00                                          .

000015ff <__c.5989>:
    15ff:	32 29 43 6c 6f 73 65 53 68 69 66 74 20 20 20 20     2)CloseShift    
    160f:	20 20 20 20 00                                          .

00001614 <__c.5987>:
    1614:	31 29 52 65 50 72 69 6e 74 20 20 20 20 20 20 20     1)RePrint       
    1624:	20 20 20 20 00                                          .

00001629 <__c.5957>:
    1629:	50 61 73 73 77 6f 72 64 20 52 65 73 74 6f 72 65     Password Restore
    1639:	64 00                                               d.

0000163b <__c.5953>:
    163b:	49 6e 76 61 6c 69 64 20 52 65 73 74 6f 72 65 20     Invalid Restore 
    164b:	20 00                                                .

0000164d <__c.5950>:
    164d:	30 30 30 30 30 00                                   00000.

00001653 <__c.5948>:
    1653:	31 31 31 31 31 00                                   11111.

00001659 <__c.5944>:
    1659:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    1669:	6e 74 65 72 00                                      nter.

0000166e <__c.5941>:
    166e:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
    167e:	6e 74 65 72 00                                      nter.

00001683 <__c.5934>:
    1683:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    1693:	6e 74 65 72 00                                      nter.

00001698 <__c.5932>:
    1698:	5f 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20     _               
    16a8:	20 20 20 20 00                                          .

000016ad <__c.5930>:
    16ad:	45 6e 74 65 72 20 52 65 73 74 6f 72 65 20 43 6f     Enter Restore Co
    16bd:	64 65 20 20 00                                      de  .

000016c2 <__c.5928>:
    16c2:	4b 65 79 20 53 74 61 6d 70 3a 25 73 20 00           Key Stamp:%s .

000016d0 <__c.5924>:
    16d0:	49 6e 76 61 6c 69 64 20 43 6f 64 65 20 20 20 20     Invalid Code    
    16e0:	20 20 20 20 00                                          .

000016e5 <__c.5921>:
	...

000016e6 <__c.5919>:
    16e6:	25 73 00                                            %s.

000016e9 <__c.5917>:
    16e9:	25 73 00                                            %s.

000016ec <__c.5914>:
    16ec:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    16fc:	6e 74 65 72 00                                      nter.

00001701 <__c.5911>:
    1701:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
    1711:	6e 74 65 72 00                                      nter.

00001716 <__c.5904>:
	...

00001717 <__c.5902>:
    1717:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    1727:	6e 74 65 72 00                                      nter.

0000172c <__c.5900>:
    172c:	5f 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20     _               
    173c:	20 20 20 20 00                                          .

00001741 <__c.5898>:
    1741:	45 6e 74 65 72 20 47 65 4e 69 55 73 20 43 6f 64     Enter GeNiUs Cod
    1751:	65 20 20 20 00                                      e   .

00001756 <__c.5888>:
    1756:	5b 2a 5d 45 78 69 74 20 20 20 20 20 20 20 20 20     [*]Exit         
    1766:	20 20 20 20 00                                          .

0000176b <__c.5886>:
    176b:	32 2e 43 68 61 6e 67 65 20 50 61 73 73 77 6f 72     2.Change Passwor
    177b:	64 20 20 20 00                                      d   .

00001780 <__c.5884>:
    1780:	31 2e 52 65 73 74 6f 72 65 20 50 61 73 73 77 6f     1.Restore Passwo
    1790:	72 64 20 20 00                                      rd  .

00001795 <__c.5882>:
    1795:	2d 53 79 73 74 65 6d 20 41 64 6d 69 6e 20 4c 65     -System Admin Le
    17a5:	76 65 6c 2d 00                                      vel-.

000017aa <__c.5823>:
    17aa:	25 73 25 73 00                                      %s%s.

000017af <__c.5795>:
    17af:	25 73 00                                            %s.

000017b2 <__c.5762>:
    17b2:	25 63 00                                            %c.

000017b5 <__c.5760>:
    17b5:	32 30 25 73 00                                      20%s.

000017ba <__c.5738>:
    17ba:	25 73 00                                            %s.

000017bd <__c.5689>:
    17bd:	34 32 36 34 36 33 36 00                             4264636.

000017c5 <__c.5686>:
    17c5:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    17d5:	6e 74 65 72 00                                      nter.

000017da <__c.5684>:
    17da:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
    17ea:	6e 74 65 72 00                                      nter.

000017ef <__c.5680>:
    17ef:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    17ff:	6e 74 65 72 00                                      nter.

00001804 <__c.5678>:
    1804:	5f 00                                               _.

00001806 <__c.5676>:
    1806:	50 41 53 53 57 4f 52 44 3a 00                       PASSWORD:.

00001810 <__c.5648>:
    1810:	41 63 63 65 73 73 20 44 65 6e 69 65 64 00           Access Denied.

0000181e <__c.5571>:
    181e:	54 43 50 2f 49 50 20 45 72 72 6f 72 00              TCP/IP Error.

0000182b <__c.5569>:
    182b:	4e 6f 20 52 65 70 6c 79 20 20 20 20 00              No Reply    .

00001838 <__c.5565>:
    1838:	20 20 20 20 20 20 20 00                                    .

00001840 <__c.5562>:
    1840:	50 6c 65 61 73 65 20 57 61 69 74 00                 Please Wait.

0000184c <__c.5559>:
    184c:	25 73 00                                            %s.

0000184f <__c.5557>:
    184f:	50 55 4d 50 20 54 45 53 54 00                       PUMP TEST.

00001859 <__c.5554>:
    1859:	25 73 00                                            %s.

0000185c <__c.5551>:
    185c:	25 73 00                                            %s.

0000185f <__c.5549>:
    185f:	25 73 00                                            %s.

00001862 <__c.5547>:
    1862:	25 73 00                                            %s.

00001865 <__c.5543>:
    1865:	25 73 00                                            %s.

00001868 <__c.5539>:
    1868:	50 72 6f 73 65 73 00                                Proses.

0000186f <__c.5537>:
    186f:	2d 4d 4f 50 20 56 6f 75 63 68 65 72 2d 00           -MOP Voucher-.

0000187d <__c.5534>:
    187d:	50 72 6f 73 65 73 00                                Proses.

00001884 <__c.5532>:
    1884:	49 44 3a 25 73 00                                   ID:%s.

0000188a <__c.5528>:
    188a:	5b 2a 5d 42 61 63 6b 20 20 20 20 5b 23 5d 45 78     [*]Back    [#]Ex
    189a:	69 74 00                                            it.

0000189d <__c.5526>:
    189d:	46 49 50 25 73 00                                   FIP%s.

000018a3 <__c.5524>:
    18a3:	54 61 70 20 4b 61 72 74 75 20 52 46 49 44 00        Tap Kartu RFID.

000018b2 <__c.5515>:
    18b2:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    18c2:	6e 74 65 72 00                                      nter.

000018c7 <__c.5513>:
    18c7:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
    18d7:	6e 74 65 72 00                                      nter.

000018dc <__c.5510>:
    18dc:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    18ec:	6e 74 65 72 00                                      nter.

000018f1 <__c.5508>:
    18f1:	53 75 72 63 68 61 72 67 65 3a 20 20 20 5f 25 00     Surcharge:   _%.

00001901 <__c.5506>:
    1901:	25 73 00                                            %s.

00001904 <__c.5502>:
    1904:	5b 2a 5d 42 61 63 6b 00                             [*]Back.

0000190c <__c.5497>:
    190c:	25 64 2e 25 73 00                                   %d.%s.

00001912 <__c.5495>:
    1912:	53 65 6c 65 63 74 20 42 61 6e 6b 00                 Select Bank.

0000191e <__c.5490>:
    191e:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    192e:	6e 74 65 72 00                                      nter.

00001933 <__c.5488>:
    1933:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 5b 23 5d 45     [*]Back     [#]E
    1943:	6e 74 65 72 00                                      nter.

00001948 <__c.5485>:
    1948:	5b 2a 5d 43 61 6e 63 65 6c 20 20 20 5b 23 5d 45     [*]Cancel   [#]E
    1958:	6e 74 65 72 00                                      nter.

0000195d <__c.5483>:
    195d:	5f 00                                               _.

0000195f <__c.5481>:
    195f:	4b 6f 64 65 20 56 6f 75 63 68 65 72 00              Kode Voucher.

0000196c <__c.5472>:
    196c:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 20 20 20 20     [*]Back         
    197c:	20 20 20 20 00                                          .

00001981 <__c.5470>:
    1981:	32 2e 42 61 6e 6b 20 20 20 20 34 2e 50 75 6d 70     2.Bank    4.Pump
    1991:	54 65 73 74 00                                      Test.

00001996 <__c.5468>:
    1996:	31 2e 41 63 63 6f 75 6e 74 20 33 2e 56 6f 75 63     1.Account 3.Vouc
    19a6:	68 65 72 20 00                                      her .

000019ab <__c.5466>:
    19ab:	20 20 20 53 65 6c 65 63 74 20 50 61 79 6d 65 6e        Select Paymen
    19bb:	74 20 20 20 00                                      t   .

000019c0 <__c.5413>:
    19c0:	43 52 45 44 49 54 43 41 52 44 00                    CREDITCARD.

000019cb <__c.5407>:
    19cb:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 20 20 20 20     [*]Back         
    19db:	20 20 20 20 00                                          .

000019e0 <__c.5405>:
    19e0:	32 2e 43 72 65 64 69 74 20 43 61 72 64 20 20 20     2.Credit Card   
    19f0:	20 20 20 20 00                                          .

000019f5 <__c.5403>:
    19f5:	31 2e 44 65 62 69 74 2f 46 6c 61 73 68 20 43 61     1.Debit/Flash Ca
    1a05:	72 64 20 20 00                                      rd  .

00001a0a <__c.5401>:
    1a0a:	53 65 6c 65 63 74 20 43 61 72 64 20 54 79 70 65     Select Card Type
	...

00001a1b <__c.5367>:
    1a1b:	4e 6f 20 43 6f 6e 6e 65 63 74 69 6f 6e 00           No Connection.

00001a29 <__c.5365>:
    1a29:	54 43 50 2f 49 50 20 45 52 52 4f 52 20 00           TCP/IP ERROR .

00001a37 <__c.5358>:
    1a37:	50 72 65 73 73 20 41 6e 79 20 4b 65 79 00           Press Any Key.

00001a45 <__c.5356>:
    1a45:	43 6d 20 56 6f 6c 3a 25 73 00                       Cm Vol:%s.

00001a4f <__c.5354>:
    1a4f:	43 4d 20 41 6d 74 3a 25 73 00                       CM Amt:%s.

00001a59 <__c.5352>:
    1a59:	50 6f 69 6e 74 73 3a 25 73 00                       Points:%s.

00001a63 <__c.5350>:
    1a63:	25 73 3a 25 73 00                                   %s:%s.

00001a69 <__c.5343>:
    1a69:	50 72 6f 73 65 73 00                                Proses.

00001a70 <__c.5341>:
    1a70:	49 44 3a 25 73 00                                   ID:%s.

00001a76 <__c.5337>:
    1a76:	5b 2a 5d 42 61 63 6b 20 20 20 20 5b 23 5d 45 78     [*]Back    [#]Ex
    1a86:	69 74 00                                            it.

00001a89 <__c.5335>:
    1a89:	54 61 70 20 4b 61 72 74 75 20 52 46 49 44 00        Tap Kartu RFID.

00001a98 <__c.5332>:
    1a98:	5b 2a 5d 42 61 63 6b 20 20 20 20 5b 23 5d 45 78     [*]Back    [#]Ex
    1aa8:	69 74 00                                            it.

00001aab <__c.5330>:
    1aab:	54 61 70 20 4b 61 72 74 75 20 52 46 49 44 00        Tap Kartu RFID.

00001aba <__c.5328>:
    1aba:	46 49 50 3a 25 73 00                                FIP:%s.

00001ac1 <__c.5322>:
    1ac1:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 20 20 20 20     [*]Back         
    1ad1:	20 00                                                .

00001ad3 <__c.5320>:
    1ad3:	32 2e 4c 6f 79 61 6c 74 79 20 55 70 64 61 74 65     2.Loyalty Update
    1ae3:	20 00                                                .

00001ae5 <__c.5318>:
    1ae5:	31 2e 45 6e 71 75 69 72 79 20 20 20 20 20 20 20     1.Enquiry       
    1af5:	20 00                                                .

00001af7 <__c.5316>:
    1af7:	20 20 4d 65 6e 75 20 4c 6f 79 61 6c 74 79 20 20       Menu Loyalty  
    1b07:	20 00                                                .

00001b09 <__c.5281>:
    1b09:	4e 6f 20 43 6f 6e 6e 65 63 74 69 6f 6e 00           No Connection.

00001b17 <__c.5279>:
    1b17:	54 43 50 2f 49 50 20 45 52 52 4f 52 20 00           TCP/IP ERROR .

00001b25 <__c.5273>:
    1b25:	5b 2a 5d 42 61 63 6b 20 20 20 20 5b 23 5d 45 78     [*]Back    [#]Ex
    1b35:	69 74 00                                            it.

00001b38 <__c.5271>:
    1b38:	54 61 70 20 53 75 70 65 72 76 69 73 6f 72 20 43     Tap Supervisor C
    1b48:	61 72 64 00                                         ard.

00001b4c <__c.5269>:
    1b4c:	52 65 50 72 69 6e 74 20 46 49 50 3a 25 73 20 00     RePrint FIP:%s .

00001b5c <__c.5265>:
    1b5c:	54 69 64 61 6b 20 41 64 61 20 54 72 61 6e 73 61     Tidak Ada Transa
    1b6c:	6b 73 69 20 00                                      ksi .

00001b71 <__c.5259>:
    1b71:	41 63 63 65 73 73 20 44 65 6e 69 65 64 00           Access Denied.

00001b7f <__c.5213>:
    1b7f:	2a 29 45 78 69 74 00                                *)Exit.

00001b86 <__c.5211>:
    1b86:	23 29 4f 4b 20 00                                   #)OK .

00001b8c <__c.5209>:
    1b8c:	20 20 20 20 20 00                                        .

00001b92 <__c.5207>:
    1b92:	46 49 50 3a 5f 00                                   FIP:_.

00001b98 <__c.5202>:
    1b98:	25 64 2e 50 25 73 20 7c 20 25 64 2e 50 25 73 00     %d.P%s | %d.P%s.

00001ba8 <__c.5153>:
    1ba8:	30 32 25 73 25 73 25 73 25 73 25 73 25 73 25 73     02%s%s%s%s%s%s%s
	...

00001bb9 <__c.5010>:
    1bb9:	30 00                                               0.

00001bbb <__c.4941>:
    1bbb:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    1bcb:	20 20 20 20 00                                          .

00001bd0 <__c.4936>:
    1bd0:	23 25 73 00                                         #%s.

00001bd4 <__c.4934>:
    1bd4:	25 2e 32 64 00                                      %.2d.

00001bd9 <__c.4932>:
    1bd9:	40 46 49 50 3a 00                                   @FIP:.

00001bdf <__c.4930>:
    1bdf:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    1bef:	20 20 20 20 00                                          .

00001bf4 <__c.4926>:
    1bf4:	50 72 69 6e 74 69 6e 67 20 46 49 50 25 73 20 00     Printing FIP%s .

00001c04 <__c.4900>:
    1c04:	44 3a 25 64 20 43 3a 25 63 20 20 00                 D:%d C:%c  .

00001c10 <__c.4881>:
    1c10:	25 73 20 25 73 00                                   %s %s.

00001c16 <__c.4854>:
    1c16:	4e 6f 20 50 75 6d 70 20 46 6f 75 6e 64 00           No Pump Found.

00001c24 <__c.4852>:
    1c24:	54 43 50 2f 49 50 20 45 72 72 6f 72 00              TCP/IP Error.

00001c31 <__c.4850>:
    1c31:	50 75 6d 70 46 6f 75 6e 64 00                       PumpFound.

00001c3b <__c.4848>:
    1c3b:	43 6f 6e 6e 65 63 74 65 64 00                       Connected.

00001c45 <__c.4843>:
    1c45:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    1c55:	20 20 20 00                                            .

00001c59 <__c.4841>:
    1c59:	25 73 00                                            %s.

00001c5c <__c.4836>:
    1c5c:	53 63 61 6e 20 50 75 6d 70 00                       Scan Pump.

00001c66 <__c.4831>:
    1c66:	43 6f 6e 6e 65 63 74 20 20 20 20 20 20 20 20 20     Connect         
	...

00001c77 <__c.4829>:
    1c77:	43 6f 6e 6e 65 63 74 00                             Connect.

00001c7f <__c.4827>:
    1c7f:	43 6f 6e 6e 65 63 74 20 20 20 20 20 20 20 20 20     Connect         
	...

00001c90 <__c.4800>:
    1c90:	43 4f 4d 25 64 3a 25 69 20 20 20 20 20 20 20 20     COM%d:%i        
    1ca0:	20 20 20 00                                            .

00001ca4 <__c.4798>:
    1ca4:	49 6e 69 74 69 61 6c 69 7a 65 20 43 4f 4d 20 2e     Initialize COM .
    1cb4:	2e 2e 00                                            ...

00001cb7 <__c.4759>:
    1cb7:	0a 47 65 4e 69 55 73 20 54 69 63 6b 65 74 20 50     .GeNiUs Ticket P
    1cc7:	72 69 6e 74 65 72 20 0a 20 56 65 72 73 69 6f 6e     rinter . Version
    1cd7:	3a 25 73 0a 20 4c 61 73 74 20 55 70 64 61 74 65     :%s. Last Update
    1ce7:	20 25 73 20 0a 20 48 61 6e 69 6e 64 6f 20 41 75      %s . Hanindo Au
    1cf7:	74 6f 6d 61 74 69 6f 6e 20 53 6f 6c 75 74 69 6f     tomation Solutio
    1d07:	6e 73 20 0a 20 77 77 77 2e 68 61 6e 69 6e 64 6f     ns . www.hanindo
    1d17:	67 72 6f 75 70 2e 63 6f 6d 0a 0a 0a 0a 0a 0a 0a     group.com.......
    1d27:	0a 00                                               ..

00001d29 <__c.4757>:
    1d29:	31 34 2f 30 32 2f 32 30 31 31 00                    14/02/2011.

00001d34 <__c.4755>:
    1d34:	32 2e 33 35 00                                      2.35.

00001d39 <__c.4746>:
    1d39:	25 73 25 73 25 73 25 73 39 38 25 2e 32 64 46 39     %s%s%s%s98%.2dF9
    1d49:	36 38 43 46 46 42 00                                68CFFB.

00001d50 <__c.4623>:
    1d50:	46 75 65 6c 69 6e 67 20 40 46 49 50 3a 23 25 64     Fueling @FIP:#%d
	...

00001d61 <__c.4621>:
    1d61:	54 72 61 6e 73 61 6b 73 69 20 53 65 6c 65 73 61     Transaksi Selesa
    1d71:	69 00                                               i.

00001d73 <__c.4617>:
    1d73:	49 44 3a 20 25 73 00                                ID: %s.

00001d7a <__c.4615>:
    1d7a:	25 73 00                                            %s.

00001d7d <__c.4613>:
    1d7d:	50 25 73 20 25 73 20 00                             P%s %s .

00001d85 <__c.4609>:
    1d85:	46 49 50 20 54 69 64 61 6b 20 53 69 61 70 20 20     FIP Tidak Siap  
    1d95:	20 20 00                                              .

00001d98 <__c.4606>:
    1d98:	41 75 74 68 6f 72 69 73 61 73 69 20 42 65 72 68     Authorisasi Berh
    1da8:	61 73 69 6c 00                                      asil.

00001dad <__c.4602>:
    1dad:	41 75 74 68 6f 72 69 73 61 73 69 20 47 61 67 61     Authorisasi Gaga
    1dbd:	6c 20 20 20 00                                      l   .

00001dc2 <__c.4598>:
    1dc2:	20 20 20 20 20 20 20 00                                    .

00001dca <__c.4595>:
    1dca:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    1dda:	20 20 20 20 00                                          .

00001ddf <__c.4593>:
    1ddf:	4d 6f 68 6f 6e 20 54 75 6e 67 67 75 20 20 20 20     Mohon Tunggu    
    1def:	20 20 20 20 00                                          .

00001df4 <__c.4591>:
    1df4:	25 73 00                                            %s.

00001df7 <__c.4589>:
    1df7:	50 25 73 20 25 73 20 00                             P%s %s .

00001dff <__c.4586>:
    1dff:	43 61 6e 63 65 6c 20 54 72 61 6e 73 61 63 74 69     Cancel Transacti
    1e0f:	6f 6e 20 20 00                                      on  .

00001e14 <__c.4583>:
    1e14:	5b 2a 5d 42 61 63 6b 20 5b 30 5d 45 53 43 20 5b     [*]Back [0]ESC [
    1e24:	23 5d 4f 4b 00                                      #]OK.

00001e29 <__c.4581>:
    1e29:	25 73 20 00                                         %s .

00001e2d <__c.4579>:
    1e2d:	20 46 75 6c 6c 00                                    Full.

00001e33 <__c.4577>:
    1e33:	25 73 20 20 25 73 20 00                             %s  %s .

00001e3b <__c.4575>:
    1e3b:	49 44 3a 20 25 73 00                                ID: %s.

00001e42 <__c.4573>:
    1e42:	25 73 20 00                                         %s .

00001e46 <__c.4569>:
    1e46:	5b 2a 5d 42 61 63 6b 20 20 5b 23 5d 4f 4b 20 20     [*]Back  [#]OK  
    1e56:	20 00                                                .

00001e58 <__c.4567>:
    1e58:	4f 64 6f 6d 65 74 65 72 3a 5f 20 20 20 20 20 20     Odometer:_      
    1e68:	20 00                                                .

00001e6a <__c.4565>:
    1e6a:	25 73 20 00                                         %s .

00001e6e <__c.4563>:
    1e6e:	20 20 25 73 20 25 73 20 00                            %s %s .

00001e77 <__c.4561>:
    1e77:	50 75 6d 70 20 50 72 6f 64 75 63 74 20 41 6d 6f     Pump Product Amo
    1e87:	75 6e 74 00                                         unt.

00001e8b <__c.4559>:
    1e8b:	50 75 6d 70 20 50 72 6f 64 75 63 74 20 56 6f 6c     Pump Product Vol
    1e9b:	75 6d 65 00                                         ume.

00001e9f <__c.4557>:
    1e9f:	20 20 54 61 6e 6b 00                                  Tank.

00001ea6 <__c.4555>:
    1ea6:	20 20 25 73 20 25 73 20 00                            %s %s .

00001eaf <__c.4553>:
    1eaf:	50 75 6d 70 20 50 72 6f 64 75 63 74 20 20 20 46     Pump Product   F
    1ebf:	75 6c 6c 00                                         ull.

00001ec3 <__c.4550>:
    1ec3:	25 73 00                                            %s.

00001ec6 <__c.4547>:
    1ec6:	5b 2a 5d 42 61 63 6b 20 20 5b 23 5d 4f 4b 20 20     [*]Back  [#]OK  
    1ed6:	20 20 20 20 00                                          .

00001edb <__c.4545>:
    1edb:	5b 32 5d 41 6d 6f 75 6e 74 3a 5f 20 20 20 20 20     [2]Amount:_     
    1eeb:	20 20 20 20 00                                          .

00001ef0 <__c.4543>:
    1ef0:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    1f00:	20 20 20 20 00                                          .

00001f05 <__c.4541>:
    1f05:	50 25 73 2d 25 73 20 00                             P%s-%s .

00001f0d <__c.4539>:
    1f0d:	5b 2a 5d 42 61 63 6b 20 20 5b 23 5d 4f 4b 20 20     [*]Back  [#]OK  
    1f1d:	20 20 20 20 00                                          .

00001f22 <__c.4537>:
    1f22:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    1f32:	20 20 20 20 00                                          .

00001f37 <__c.4535>:
    1f37:	5b 31 5d 56 6f 6c 75 6d 65 3a 5f 20 20 20 20 20     [1]Volume:_     
    1f47:	20 20 20 20 00                                          .

00001f4c <__c.4533>:
    1f4c:	50 25 73 2d 25 73 20 00                             P%s-%s .

00001f54 <__c.4530>:
    1f54:	41 00                                               A.

00001f56 <__c.4528>:
    1f56:	41 00                                               A.

00001f58 <__c.4526>:
    1f58:	56 00                                               V.

00001f5a <__c.4523>:
    1f5a:	5b 2a 5d 42 61 63 6b 20 20 20 20 5b 23 5d 4e 65     [*]Back    [#]Ne
    1f6a:	78 74 20 20 00                                      xt  .

00001f6f <__c.4521>:
    1f6f:	5b 32 5d 41 6d 6f 75 6e 74 20 20 20 20 20 20 20     [2]Amount       
    1f7f:	20 20 20 20 00                                          .

00001f84 <__c.4519>:
    1f84:	5b 31 5d 56 6f 6c 75 6d 65 20 20 20 20 20 20 20     [1]Volume       
    1f94:	20 20 20 20 00                                          .

00001f99 <__c.4517>:
    1f99:	50 25 73 2d 25 73 20 00                             P%s-%s .

00001fa1 <__c.4514>:
    1fa1:	25 73 00                                            %s.

00001fa4 <__c.4511>:
    1fa4:	5b 2a 5d 42 61 63 6b 20 20 20 20 20 20 20 20 20     [*]Back         
    1fb4:	20 20 20 20 00                                          .

00001fb9 <__c.4506>:
    1fb9:	20 20 20 20 20 00                                        .

00001fbf <__c.4504>:
    1fbf:	25 64 2e 25 73 00                                   %d.%s.

00001fc5 <__c.4502>:
    1fc5:	25 73 00                                            %s.

00001fc8 <__c.4500>:
    1fc8:	50 6f 6d 70 61 2d 25 73 00                          Pompa-%s.

00001fd1 <__c.4497>:
    1fd1:	25 2e 32 64 00                                      %.2d.

00001fd6 <__c.4495>:
    1fd6:	25 2e 32 64 00                                      %.2d.

00001fdb <__c.4492>:
    1fdb:	2a 29 45 78 69 74 00                                *)Exit.

00001fe2 <__c.4490>:
    1fe2:	23 29 4f 4b 20 00                                   #)OK .

00001fe8 <__c.4488>:
    1fe8:	20 20 20 20 20 00                                        .

00001fee <__c.4486>:
    1fee:	46 49 50 3a 5f 00                                   FIP:_.

00001ff4 <__c.4481>:
    1ff4:	25 64 2e 50 25 2e 32 64 20 7c 20 25 64 2e 50 25     %d.P%.2d | %d.P%
    2004:	2e 32 64 00                                         .2d.

00002008 <__c.4477>:
    2008:	5b 2a 5d 42 61 74 61 6c 20 20 20 20 20 20 20 5b     [*]Batal       [
    2018:	23 5d 4f 4b 00                                      #]OK.

0000201d <__c.4475>:
    201d:	25 73 20 25 73 00                                   %s %s.

00002023 <__c.4473>:
    2023:	25 73 00                                            %s.

00002026 <__c.4471>:
    2026:	25 73 00                                            %s.

00002029 <__c.4469>:
    2029:	25 73 00                                            %s.

0000202c <__c.4466>:
    202c:	4b 61 72 74 75 20 54 65 72 62 61 74 61 73 20 20     Kartu Terbatas  
    203c:	20 20 20 20 00                                          .

00002041 <__c.4464>:
    2041:	54 69 64 61 6b 20 54 65 72 64 61 66 74 61 72 20     Tidak Terdaftar 
    2051:	20 20 20 20 00                                          .

00002056 <__c.4461>:
    2056:	44 61 74 61 20 52 65 63 65 69 76 65 64 20 20 20     Data Received   
    2066:	20 20 20 20 00                                          .

0000206b <__c.4458>:
    206b:	54 43 50 2f 49 50 20 45 72 72 6f 72 20 20 20 20     TCP/IP Error    
    207b:	20 20 20 20 00                                          .

00002080 <__c.4456>:
    2080:	53 65 6e 64 69 6e 67 20 46 61 69 6c 65 64 20 20     Sending Failed  
    2090:	20 20 20 20 00                                          .

00002095 <__c.4453>:
    2095:	20 20 20 20 20 20 20 00                                    .

0000209d <__c.4448>:
    209d:	50 72 6f 73 65 73 00                                Proses.

000020a4 <__c.4446>:
    20a4:	49 44 3a 25 73 00                                   ID:%s.

000020aa <__c.4444>:
    20aa:	20 20 20 4c 6f 63 61 6c 20 41 63 63 6f 75 6e 74        Local Account
    20ba:	20 20 20 00                                            .

000020be <__c.4252>:
    20be:	25 2e 32 64 00                                      %.2d.

000020c3 <__c.4247>:
    20c3:	45 39 34 34 35 35 31 32 00                          E9445512.

000020cc <__c.4245>:
    20cc:	25 73 25 73 00                                      %s%s.

000020d1 <__c.4243>:
    20d1:	25 73 25 73 25 73 25 73 39 34 00                    %s%s%s%s94.

000020dc <__c.4238>:
    20dc:	45 39 34 34 35 35 31 32 00                          E9445512.

000020e5 <__c.4236>:
    20e5:	25 73 25 73 25 73 00                                %s%s%s.

000020ec <__c.4234>:
    20ec:	25 73 25 73 25 73 25 73 00                          %s%s%s%s.

000020f5 <__c.4232>:
    20f5:	25 73 25 73 25 73 25 73 39 32 00                    %s%s%s%s92.

00002100 <__c.4227>:
    2100:	45 39 34 34 35 35 31 32 00                          E9445512.

00002109 <__c.4225>:
    2109:	25 73 25 73 00                                      %s%s.

0000210e <__c.4223>:
    210e:	25 73 25 73 25 73 25 73 39 30 00                    %s%s%s%s90.

00002119 <__c.4214>:
    2119:	25 64 46 30 30 30 30 30 30 30 45 31 32 33 34 35     %dF0000000E12345
    2129:	36 46 46 46 46 46 25 73 45 39 34 34 35 35 31 32     6FFFFF%sE9445512
	...

0000213a <__c.4212>:
    213a:	25 73 25 73 25 64 25 73 25 73 00                    %s%s%d%s%s.

00002145 <__c.4210>:
    2145:	25 73 25 73 25 73 25 73 35 38 00                    %s%s%s%s58.

00002150 <__c.4205>:
    2150:	41 46 39 36 38 43 46 46 42 00                       AF968CFFB.

0000215a <__c.4203>:
    215a:	25 73 00                                            %s.

0000215d <__c.4201>:
    215d:	25 73 35 36 00                                      %s56.

00002162 <__c.4199>:
    2162:	25 73 25 73 25 73 00                                %s%s%s.

00002169 <__c.4194>:
    2169:	46 39 36 38 43 46 46 42 00                          F968CFFB.

00002172 <__c.4192>:
    2172:	25 73 25 73 00                                      %s%s.

00002177 <__c.4190>:
    2177:	25 73 25 73 25 73 25 73 00                          %s%s%s%s.

00002180 <__c.4188>:
    2180:	25 73 25 73 25 73 25 73 33 32 00                    %s%s%s%s32.

0000218b <__c.4183>:
    218b:	25 73 25 73 46 39 36 38 43 46 46 42 00              %s%sF968CFFB.

00002198 <__c.4181>:
    2198:	25 73 25 73 25 73 25 73 32 38 00                    %s%s%s%s28.

000021a3 <__c.4176>:
    21a3:	25 73 25 73 46 39 36 38 43 46 46 42 00              %s%sF968CFFB.

000021b0 <__c.4174>:
    21b0:	25 73 25 73 25 73 25 73 32 34 00                    %s%s%s%s24.

000021bb <__c.4169>:
    21bb:	25 73 46 39 36 38 43 46 46 42 00                    %sF968CFFB.

000021c6 <__c.4167>:
    21c6:	25 73 25 73 25 73 25 73 32 32 00                    %s%s%s%s22.

000021d1 <__c.4162>:
    21d1:	25 73 25 73 25 73 25 73 31 30 46 39 36 38 43 46     %s%s%s%s10F968CF
    21e1:	46 42 00                                            FB.

000021e4 <__c.4157>:
    21e4:	25 73 25 73 25 73 25 73 30 34 25 73 31 46 39 36     %s%s%s%s04%s1F96
    21f4:	38 43 46 46 42 00                                   8CFFB.

000021fa <__c.4143>:
    21fa:	25 73 2e 25 73 2e 25 73 2e 25 73 00                 %s.%s.%s.%s.

00002206 <__c.4124>:
    2206:	25 73 2e 25 73 2e 25 73 2e 25 73 00                 %s.%s.%s.%s.

00002212 <__c.4057>:
    2212:	25 73 20 25 73 00                                   %s %s.

00002218 <__c.4055>:
    2218:	32 2e 33 35 00                                      2.35.

0000221d <__c.4053>:
    221d:	47 65 4e 69 55 73 00                                GeNiUs.

00002224 <__c.4039>:
    2224:	50 72 65 73 73 20 61 6e 79 20 6b 65 79 2e 2e 20     Press any key.. 
    2234:	20 20 20 20 00                                          .

00002239 <__c.4027>:
    2239:	5b 31 5d 53 6c 61 76 65 20 5b 32 5d 53 74 61 6e     [1]Slave [2]Stan
    2249:	64 61 6c 6f 6e 65 00                                dalone.

00002250 <__c.3948>:
    2250:	3e 00                                               >.

00002252 <__c.3943>:
    2252:	25 2e 32 64 00                                      %.2d.

00002257 <__c.3941>:
    2257:	25 2e 32 64 00                                      %.2d.

0000225c <__c.3939>:
    225c:	30 00                                               0.

0000225e <__c.3937>:
    225e:	31 00                                               1.

00002260 <__c.3929>:
    2260:	25 64 00                                            %d.

00002263 <__c.3924>:
    2263:	25 2e 32 64 00                                      %.2d.

00002268 <__c.3919>:
    2268:	25 73 00                                            %s.

0000226b <__c.3914>:
    226b:	25 73 00                                            %s.

0000226e <__c.3909>:
    226e:	25 73 00                                            %s.

00002271 <__c.3907>:
    2271:	3c 00                                               <.

00002273 <__c.3839>:
    2273:	3c 4f 4b 3e 00                                      <OK>.

00002278 <__c.3834>:
    2278:	25 64 00                                            %d.

0000227b <__c.3832>:
    227b:	25 64 00                                            %d.

0000227e <__c.3821>:
    227e:	25 64 00                                            %d.

00002281 <__c.3810>:
    2281:	3c 53 61 76 69 6e 67 3e 00                          <Saving>.

0000228a <__c.3808>:
    228a:	4c 65 6e 67 74 68 3a 25 64 00                       Length:%d.

00002294 <__c.3622>:
    2294:	25 73 00                                            %s.

00002297 <__c.3564>:
    2297:	25 73 00                                            %s.

0000229a <__c.3562>:
    229a:	25 73 00                                            %s.

0000229d <__c.3560>:
    229d:	25 73 00                                            %s.

000022a0 <__c.3558>:
    22a0:	25 73 00                                            %s.

000022a3 <__c.3556>:
    22a3:	25 2e 32 64 00                                      %.2d.

000022a8 <__c.3554>:
    22a8:	25 64 00                                            %d.

000022ab <__c.3552>:
    22ab:	25 73 00                                            %s.

000022ae <__c.3550>:
    22ae:	25 73 00                                            %s.

000022b1 <__c.3548>:
    22b1:	25 73 00                                            %s.

000022b4 <__c.3546>:
    22b4:	25 64 00                                            %d.

000022b7 <__c.3544>:
    22b7:	4e 2f 41 00                                         N/A.

000022bb <__c.3445>:
    22bb:	25 64 00                                            %d.

000022be <__c.3443>:
    22be:	25 73 00                                            %s.

000022c1 <__c.3441>:
    22c1:	25 73 00                                            %s.

000022c4 <__c.3356>:
    22c4:	54 69 64 61 6b 20 41 64 61 20 54 72 61 6e 73 61     Tidak Ada Transa
    22d4:	6b 73 69 20 00                                      ksi .

000022d9 <__c.3353>:
    22d9:	54 6f 74 61 6c 69 7a 65 72 41 6c 6c 20 20 20 20     TotalizerAll    
    22e9:	20 00                                                .

000022eb <__c.3350>:
    22eb:	43 6c 65 61 72 20 44 61 74 61 20 54 6f 74 61 6c     Clear Data Total
    22fb:	69 7a 65 72 00                                      izer.

00002300 <__c.3338>:
    2300:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
	...

00002311 <__c.3335>:
    2311:	52 65 61 64 79 2e 2e 2e 20 20 20 20 20 20 20 20     Ready...        
    2321:	20 20 20 20 00                                          .

00002326 <__c.3332>:
    2326:	52 65 61 64 79 2e 2e 2e 20 20 20 20 20 20 20 20     Ready...        
    2336:	20 20 20 20 00                                          .

0000233b <__c.3330>:
    233b:	4e 6f 20 52 65 73 70 6f 6e 73 65 2e 2e 20 20 20     No Response..   
    234b:	20 20 20 20 00                                          .

00002350 <__c.3327>:
    2350:	50 6c 65 61 73 65 20 57 61 69 74 2e 2e 20 20 20     Please Wait..   
    2360:	20 20 20 20 00                                          .

00002365 <__c.3324>:
    2365:	52 65 61 64 79 2e 2e 2e 20 20 20 20 20 20 20 20     Ready...        
    2375:	20 20 20 20 00                                          .

0000237a <__c.3321>:
    237a:	54 69 64 61 6b 20 41 64 61 20 54 72 61 6e 73 61     Tidak Ada Transa
    238a:	6b 73 69 20 00                                      ksi .

0000238f <__c.3316>:
    238f:	53 65 64 61 6e 67 50 72 6f 73 65 73 00              SedangProses.

0000239c <__c.3313>:
    239c:	34 33 35 36 41 33 31 41 00                          4356A31A.

000023a5 <__c.1750>:
    23a5:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    23b5:	20 20 20 20 00                                          .

000023ba <__c.1748>:
    23ba:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    23ca:	20 20 20 20 00                                          .

000023cf <__c.1746>:
    23cf:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    23df:	20 20 20 20 00                                          .

000023e4 <__c.1744>:
    23e4:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    23f4:	20 20 20 20 00                                          .

000023f9 <__alphanum>:
    23f9:	30 20 2e 00 00 00 31 2e 2c 3f 21 00 32 61 62 63     0 ....1.,?!.2abc
    2409:	00 00 33 64 65 66 00 00 34 67 68 69 00 00 35 6a     ..3def..4ghi..5j
    2419:	6b 6c 00 00 36 6d 6e 6f 00 00 37 70 71 72 73 00     kl..6mno..7pqrs.
    2429:	38 74 75 76 00 00 39 77 78 79 7a 00 30 20 2e 00     8tuv..9wxyz.0 ..
    2439:	00 00 31 26 40 2b 2d 00 32 41 42 43 00 00 33 44     ..1&@+-.2ABC..3D
    2449:	45 46 00 00 34 47 48 49 00 00 35 4a 4b 4c 00 00     EF..4GHI..5JKL..
    2459:	36 4d 4e 4f 00 00 37 50 51 52 53 00 38 54 55 56     6MNO..7PQRS.8TUV
    2469:	00 00 39 57 58 59 5a 00                             ..9WXYZ.

00002471 <__maxchar>:
    2471:	02 04 03 03 03 03 03 04 03 04 00                    ...........

0000247c <__ctors_end>:
    247c:	11 24       	eor	r1, r1
    247e:	1f be       	out	0x3f, r1	; 63
    2480:	cf ef       	ldi	r28, 0xFF	; 255
    2482:	d0 e1       	ldi	r29, 0x10	; 16
    2484:	de bf       	out	0x3e, r29	; 62
    2486:	cd bf       	out	0x3d, r28	; 61

00002488 <__do_copy_data>:
    2488:	11 e0       	ldi	r17, 0x01	; 1
    248a:	a0 e0       	ldi	r26, 0x00	; 0
    248c:	b1 e0       	ldi	r27, 0x01	; 1
    248e:	e4 e7       	ldi	r30, 0x74	; 116
    2490:	ff e6       	ldi	r31, 0x6F	; 111
    2492:	01 e0       	ldi	r16, 0x01	; 1
    2494:	0b bf       	out	0x3b, r16	; 59
    2496:	02 c0       	rjmp	.+4      	; 0x249c <__do_copy_data+0x14>
    2498:	07 90       	elpm	r0, Z+
    249a:	0d 92       	st	X+, r0
    249c:	ae 35       	cpi	r26, 0x5E	; 94
    249e:	b1 07       	cpc	r27, r17
    24a0:	d9 f7       	brne	.-10     	; 0x2498 <__do_copy_data+0x10>

000024a2 <__do_clear_bss>:
    24a2:	1e e0       	ldi	r17, 0x0E	; 14
    24a4:	ae e5       	ldi	r26, 0x5E	; 94
    24a6:	b1 e0       	ldi	r27, 0x01	; 1
    24a8:	01 c0       	rjmp	.+2      	; 0x24ac <.do_clear_bss_start>

000024aa <.do_clear_bss_loop>:
    24aa:	1d 92       	st	X+, r1

000024ac <.do_clear_bss_start>:
    24ac:	af 38       	cpi	r26, 0x8F	; 143
    24ae:	b1 07       	cpc	r27, r17
    24b0:	e1 f7       	brne	.-8      	; 0x24aa <.do_clear_bss_loop>
    24b2:	0e 94 ee 12 	call	0x25dc	; 0x25dc <main>
    24b6:	0c 94 b8 b7 	jmp	0x16f70	; 0x16f70 <_exit>

000024ba <__bad_interrupt>:
    24ba:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000024be <systemOnReset>:
	};
}


void systemOnReset(){
     IsPowerOn=False;
    24be:	10 92 9a 04 	sts	0x049A, r1
     if (MCUCSR & 1){   // Power-on Reset
    24c2:	04 b6       	in	r0, 0x34	; 52
    24c4:	00 fe       	sbrs	r0, 0
    24c6:	0b c0       	rjmp	.+22     	; 0x24de <systemOnReset+0x20>
         MCUCSR=0;lcd_printf(1,1,PSTR("PowerOn"));//Wiznet Blm Ready
    24c8:	14 be       	out	0x34, r1	; 52
    24ca:	81 e0       	ldi	r24, 0x01	; 1
    24cc:	61 e0       	ldi	r22, 0x01	; 1
    24ce:	4c ec       	ldi	r20, 0xCC	; 204
    24d0:	52 e0       	ldi	r21, 0x02	; 2
    24d2:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		 IsPowerOn=True;
    24d6:	81 e0       	ldi	r24, 0x01	; 1
    24d8:	80 93 9a 04 	sts	0x049A, r24
    24dc:	18 c0       	rjmp	.+48     	; 0x250e <systemOnReset+0x50>
         }
     else 
     if (MCUCSR & 2){   // External Reset
    24de:	04 b6       	in	r0, 0x34	; 52
    24e0:	01 fe       	sbrs	r0, 1
    24e2:	06 c0       	rjmp	.+12     	; 0x24f0 <systemOnReset+0x32>
         MCUCSR=0;lcd_printf(1,1,PSTR("External"));
    24e4:	14 be       	out	0x34, r1	; 52
    24e6:	81 e0       	ldi	r24, 0x01	; 1
    24e8:	61 e0       	ldi	r22, 0x01	; 1
    24ea:	43 ec       	ldi	r20, 0xC3	; 195
    24ec:	52 e0       	ldi	r21, 0x02	; 2
    24ee:	0d c0       	rjmp	.+26     	; 0x250a <systemOnReset+0x4c>
        }
     else 
     if (MCUCSR & 4){   // Brown-Out Reset
    24f0:	04 b6       	in	r0, 0x34	; 52
    24f2:	02 fe       	sbrs	r0, 2
    24f4:	06 c0       	rjmp	.+12     	; 0x2502 <systemOnReset+0x44>
         MCUCSR=0;lcd_printf(1,1,PSTR("BrownOut"));
    24f6:	14 be       	out	0x34, r1	; 52
    24f8:	81 e0       	ldi	r24, 0x01	; 1
    24fa:	61 e0       	ldi	r22, 0x01	; 1
    24fc:	4a eb       	ldi	r20, 0xBA	; 186
    24fe:	52 e0       	ldi	r21, 0x02	; 2
    2500:	04 c0       	rjmp	.+8      	; 0x250a <systemOnReset+0x4c>
         }
     else		  // Watchdog Reset
        {
         lcd_printf(1,1,PSTR("WatchDog"));
    2502:	81 e0       	ldi	r24, 0x01	; 1
    2504:	61 e0       	ldi	r22, 0x01	; 1
    2506:	41 eb       	ldi	r20, 0xB1	; 177
    2508:	52 e0       	ldi	r21, 0x02	; 2
    250a:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
        };
     MCUCSR=0;		  
    250e:	14 be       	out	0x34, r1	; 52
    2510:	80 ee       	ldi	r24, 0xE0	; 224
    2512:	9e e2       	ldi	r25, 0x2E	; 46
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    2514:	20 e7       	ldi	r18, 0x70	; 112
    2516:	31 e0       	ldi	r19, 0x01	; 1
    2518:	f9 01       	movw	r30, r18
    251a:	31 97       	sbiw	r30, 0x01	; 1
    251c:	f1 f7       	brne	.-4      	; 0x251a <systemOnReset+0x5c>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    251e:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2520:	d9 f7       	brne	.-10     	; 0x2518 <systemOnReset+0x5a>
	 _delay_ms(1200);
}
    2522:	08 95       	ret

00002524 <SystemInit>:


void SystemInit(){
	unsigned int __delay =300;
	lcd_init();
    2524:	0e 94 87 ac 	call	0x1590e	; 0x1590e <lcd_init>
	lcd_clear();
    2528:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
	BackLightTrig();
    252c:	0e 94 07 16 	call	0x2c0e	; 0x2c0e <BackLightTrig>
	systemOnReset();
    2530:	0e 94 5f 12 	call	0x24be	; 0x24be <systemOnReset>

	lcd_printf(4, 1, PSTR("Initialize... "));
    2534:	84 e0       	ldi	r24, 0x04	; 4
    2536:	61 e0       	ldi	r22, 0x01	; 1
    2538:	42 ea       	ldi	r20, 0xA2	; 162
    253a:	52 e0       	ldi	r21, 0x02	; 2
    253c:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
    2540:	88 eb       	ldi	r24, 0xB8	; 184
    2542:	9b e0       	ldi	r25, 0x0B	; 11
    2544:	20 e7       	ldi	r18, 0x70	; 112
    2546:	31 e0       	ldi	r19, 0x01	; 1
    2548:	f9 01       	movw	r30, r18
    254a:	31 97       	sbiw	r30, 0x01	; 1
    254c:	f1 f7       	brne	.-4      	; 0x254a <SystemInit+0x26>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    254e:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2550:	d9 f7       	brne	.-10     	; 0x2548 <SystemInit+0x24>
	_delay_ms(__delay);
	PORTA = 0XFF;		// Buffer for PORTA
    2552:	9f ef       	ldi	r25, 0xFF	; 255
    2554:	9b bb       	out	0x1b, r25	; 27
	DDRA = 0xFF;		// Pin 3 out (SS _SPI_SLAVE)
    2556:	9a bb       	out	0x1a, r25	; 26
	sbi(PORTA, 3);		// Disable SS _SPI_SLAVE
    2558:	db 9a       	sbi	0x1b, 3	; 27

	//Buzzer PORTB.5
	PORTB = 0xFF;DDRB = 0xFF;
    255a:	98 bb       	out	0x18, r25	; 24
    255c:	97 bb       	out	0x17, r25	; 23
	PORTD = 0b00001101;
    255e:	8d e0       	ldi	r24, 0x0D	; 13
    2560:	82 bb       	out	0x12, r24	; 18
    DDRD =  0b00001001;
    2562:	89 e0       	ldi	r24, 0x09	; 9
    2564:	81 bb       	out	0x11, r24	; 17

	TWBR = 0xFF;
    2566:	90 93 70 00 	sts	0x0070, r25
    //MMC
	PORTE = 0x0E;		// Buffer for PORTE
    256a:	8e e0       	ldi	r24, 0x0E	; 14
    256c:	83 b9       	out	0x03, r24	; 3
	DDRE = 0x0E;		// Pin 3 out (SS _SPI_MMC), pin 2 out (HB)
    256e:	82 b9       	out	0x02, r24	; 2
	sbi(PORTE, 3);		// Disable SS _SPI_MMC
    2570:	1b 9a       	sbi	0x03, 3	; 3
	cbi(PORTE, 2);		// HB on
    2572:	1a 98       	cbi	0x03, 2	; 3

	//Keypad
	PORTF = 0xFF;		// Buffer for PORTF
    2574:	90 93 62 00 	sts	0x0062, r25
	DDRF = 0xF0;		// 4 bit row, 4 bit column
    2578:	80 ef       	ldi	r24, 0xF0	; 240
    257a:	80 93 61 00 	sts	0x0061, r24

  	_spi_init(0,1);//Slave
    257e:	80 e0       	ldi	r24, 0x00	; 0
    2580:	61 e0       	ldi	r22, 0x01	; 1
    2582:	0e 94 7f af 	call	0x15efe	; 0x15efe <_spi_init>
	sbi(DDRB,3);sbi(PORTB,3);//MISO Output
    2586:	bb 9a       	sbi	0x17, 3	; 23
    2588:	c3 9a       	sbi	0x18, 3	; 24
	cbi(DDRB,2);sbi(PORTB,2);//MOSI Input
    258a:	ba 98       	cbi	0x17, 2	; 23
    258c:	c2 9a       	sbi	0x18, 2	; 24
	cbi(DDRB,1);sbi(PORTB,1);//SCK  Input
    258e:	b9 98       	cbi	0x17, 1	; 23
    2590:	c1 9a       	sbi	0x18, 1	; 24

	TCCR1B |= (1 << WGM12);
    2592:	8e b5       	in	r24, 0x2e	; 46
    2594:	88 60       	ori	r24, 0x08	; 8
    2596:	8e bd       	out	0x2e, r24	; 46
	TIMSK |= (1 << OCIE1A);
    2598:	87 b7       	in	r24, 0x37	; 55
    259a:	80 61       	ori	r24, 0x10	; 16
    259c:	87 bf       	out	0x37, r24	; 55
	sei();          //1/14745600=0,06781684028uS *1400 = 100uS 65535-1400+1=64136
    259e:	78 94       	sei
	OCR1A   = 15624;//49911 -->0,33847384982639 ms
    25a0:	88 e0       	ldi	r24, 0x08	; 8
    25a2:	9d e3       	ldi	r25, 0x3D	; 61
    25a4:	9b bd       	out	0x2b, r25	; 43
    25a6:	8a bd       	out	0x2a, r24	; 42
	TCCR1B |= ((1 << CS10) | (1 << CS11));
    25a8:	8e b5       	in	r24, 0x2e	; 46
    25aa:	83 60       	ori	r24, 0x03	; 3
    25ac:	8e bd       	out	0x2e, r24	; 46

	SendSlaveCommand(SC_SLAVE,ST_NONE);
    25ae:	81 e0       	ldi	r24, 0x01	; 1
    25b0:	60 e0       	ldi	r22, 0x00	; 0
    25b2:	0e 94 83 72 	call	0xe506	; 0xe506 <SendSlaveCommand>
	
	InitComport();
    25b6:	0e 94 7b 9a 	call	0x134f6	; 0x134f6 <InitComport>
	_LIGHT_SET;
    25ba:	81 e0       	ldi	r24, 0x01	; 1
    25bc:	80 93 bf 03 	sts	0x03BF, r24
    25c0:	10 92 c0 03 	sts	0x03C0, r1
    25c4:	80 91 65 00 	lds	r24, 0x0065
    25c8:	8d 7f       	andi	r24, 0xFD	; 253
    25ca:	80 93 65 00 	sts	0x0065, r24
	InitPrinter();
    25ce:	0e 94 cb 4b 	call	0x9796	; 0x9796 <InitPrinter>
    InitializeConnection();
    25d2:	0e 94 7e 76 	call	0xecfc	; 0xecfc <InitializeConnection>
	lcd_clear(); 
    25d6:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
}
    25da:	08 95       	ret

000025dc <main>:
void SystemInit();
//void TestUserInput();

//Program Utama
int main(){
	SystemInit();
    25dc:	0e 94 92 12 	call	0x2524	; 0x2524 <SystemInit>
	while(1){
	//FTestChar();
	//TestUserInput();
    FMenuIdle();
    25e0:	0e 94 25 aa 	call	0x1544a	; 0x1544a <FMenuIdle>
    25e4:	fd cf       	rjmp	.-6      	; 0x25e0 <main+0x4>

000025e6 <eeprom_read_byte>:

/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    25e6:	9c 01       	movw	r18, r24
    do {} while (!eeprom_is_ready ());
    25e8:	e1 99       	sbic	0x1c, 1	; 28
    25ea:	fe cf       	rjmp	.-4      	; 0x25e8 <eeprom_read_byte+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    25ec:	3f bb       	out	0x1f, r19	; 31
    25ee:	2e bb       	out	0x1e, r18	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    25f0:	e0 9a       	sbi	0x1c, 0	; 28
    25f2:	8d b3       	in	r24, 0x1d	; 29
        : "i" (_SFR_IO_ADDR(EECR)),
          "i" (EERE),
          "i" (_SFR_IO_ADDR(EEDR))
    );
    return __result;
}
    25f4:	08 95       	ret

000025f6 <eeprom_write_byte>:

/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    25f6:	9c 01       	movw	r18, r24
    do {} while (!eeprom_is_ready ());
    25f8:	e1 99       	sbic	0x1c, 1	; 28
    25fa:	fe cf       	rjmp	.-4      	; 0x25f8 <eeprom_write_byte+0x2>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    25fc:	3f bb       	out	0x1f, r19	; 31
    25fe:	2e bb       	out	0x1e, r18	; 30
#endif
    EEDR = __value;
    2600:	6d bb       	out	0x1d, r22	; 29

    __asm__ __volatile__ (
    2602:	0f b6       	in	r0, 0x3f	; 63
    2604:	f8 94       	cli
    2606:	e2 9a       	sbi	0x1c, 2	; 28
    2608:	e1 9a       	sbi	0x1c, 1	; 28
    260a:	0f be       	out	0x3f, r0	; 63
          [__sreg]  "i" (_SFR_IO_ADDR(SREG)),
          [__eemwe] "i" (EEMWE),
          [__eewe]  "i" (EEWE)
        : "r0"
    );
}
    260c:	08 95       	ret

0000260e <__vector_12>:
	  strDispenserName3,
	  strDispenserName4,
	  strDispenserName5,
};

ISR(TIMER1_COMPA_vect){//Timer Overflow 1ms
    260e:	1f 92       	push	r1
    2610:	0f 92       	push	r0
    2612:	0f b6       	in	r0, 0x3f	; 63
    2614:	0f 92       	push	r0
    2616:	11 24       	eor	r1, r1
    2618:	2f 93       	push	r18
    261a:	6f 93       	push	r22
    261c:	7f 93       	push	r23
    261e:	8f 93       	push	r24
    2620:	9f 93       	push	r25
		   __sec_sign = 1;
		 }
	}
*/
	//_light_ticker();
	if(__key_light == 1){
    2622:	80 91 bf 03 	lds	r24, 0x03BF
    2626:	81 30       	cpi	r24, 0x01	; 1
    2628:	81 f4       	brne	.+32     	; 0x264a <__vector_12+0x3c>
		__key_lgtcnt++;
    262a:	80 91 c0 03 	lds	r24, 0x03C0
    262e:	8f 5f       	subi	r24, 0xFF	; 255
    2630:	80 93 c0 03 	sts	0x03C0, r24
		if(__key_lgtcnt == 150){
    2634:	86 39       	cpi	r24, 0x96	; 150
    2636:	49 f4       	brne	.+18     	; 0x264a <__vector_12+0x3c>
		   __key_light = 0; 
    2638:	10 92 bf 03 	sts	0x03BF, r1
		   __key_lgtcnt = 0; 
    263c:	10 92 c0 03 	sts	0x03C0, r1
		   sbi(PORTG, 1);
    2640:	80 91 65 00 	lds	r24, 0x0065
    2644:	82 60       	ori	r24, 0x02	; 2
    2646:	80 93 65 00 	sts	0x0065, r24
		   }
	}
	

	__i_timer++;
    264a:	80 91 bd 03 	lds	r24, 0x03BD
    264e:	8f 5f       	subi	r24, 0xFF	; 255
    2650:	80 93 bd 03 	sts	0x03BD, r24
	if (__i_timer > 5){
    2654:	86 30       	cpi	r24, 0x06	; 6
    2656:	30 f0       	brcs	.+12     	; 0x2664 <__vector_12+0x56>
		__i_timer = 0;
    2658:	10 92 bd 03 	sts	0x03BD, r1
		PORTE = PORTE^0x04;
    265c:	83 b1       	in	r24, 0x03	; 3
    265e:	94 e0       	ldi	r25, 0x04	; 4
    2660:	89 27       	eor	r24, r25
    2662:	83 b9       	out	0x03, r24	; 3
	}
	//Beep
	if (TimBeep>0){
    2664:	80 91 d6 01 	lds	r24, 0x01D6
    2668:	90 91 d7 01 	lds	r25, 0x01D7
    266c:	00 97       	sbiw	r24, 0x00	; 0
    266e:	41 f0       	breq	.+16     	; 0x2680 <__vector_12+0x72>
	    TimBeep--;
    2670:	01 97       	sbiw	r24, 0x01	; 1
    2672:	90 93 d7 01 	sts	0x01D7, r25
    2676:	80 93 d6 01 	sts	0x01D6, r24
		DDRB=(DDRB|0b00100000);
    267a:	bd 9a       	sbi	0x17, 5	; 23
	    PORTB=(PORTB&0b11011111);
    267c:	c5 98       	cbi	0x18, 5	; 24
    267e:	05 c0       	rjmp	.+10     	; 0x268a <__vector_12+0x7c>
	    }
	else{PORTB=(PORTB|~PORTB);
    2680:	98 b3       	in	r25, 0x18	; 24
    2682:	88 b3       	in	r24, 0x18	; 24
    2684:	80 95       	com	r24
    2686:	89 2b       	or	r24, r25
    2688:	88 bb       	out	0x18, r24	; 24
		}
    //LocalAccount
	TimLocAcc++;
    268a:	80 91 d2 01 	lds	r24, 0x01D2
    268e:	90 91 d3 01 	lds	r25, 0x01D3
    2692:	01 96       	adiw	r24, 0x01	; 1
    2694:	90 93 d3 01 	sts	0x01D3, r25
    2698:	80 93 d2 01 	sts	0x01D2, r24
	//DisplaTicker
    TimTicker++;
    269c:	80 91 a5 01 	lds	r24, 0x01A5
    26a0:	8f 5f       	subi	r24, 0xFF	; 255
    26a2:	80 93 a5 01 	sts	0x01A5, r24
	TimPressed++;
    26a6:	20 91 a6 01 	lds	r18, 0x01A6
    26aa:	2f 5f       	subi	r18, 0xFF	; 255
    26ac:	20 93 a6 01 	sts	0x01A6, r18
	if ((TimPressed%5)==0){
    26b0:	82 2f       	mov	r24, r18
    26b2:	65 e0       	ldi	r22, 0x05	; 5
    26b4:	0e 94 1f b7 	call	0x16e3e	; 0x16e3e <__udivmodqi4>
    26b8:	99 23       	and	r25, r25
    26ba:	71 f4       	brne	.+28     	; 0x26d8 <__vector_12+0xca>
	    TimDisplay++;
    26bc:	80 91 a7 01 	lds	r24, 0x01A7
    26c0:	8f 5f       	subi	r24, 0xFF	; 255
    26c2:	80 93 a7 01 	sts	0x01A7, r24
		TimPrintBusy++;
    26c6:	80 91 cc 01 	lds	r24, 0x01CC
    26ca:	90 91 cd 01 	lds	r25, 0x01CD
    26ce:	01 96       	adiw	r24, 0x01	; 1
    26d0:	90 93 cd 01 	sts	0x01CD, r25
    26d4:	80 93 cc 01 	sts	0x01CC, r24
		//FBackLight();
	}
	if ((TimPressed%PRESSED_DELAY)==0){
    26d8:	82 2f       	mov	r24, r18
    26da:	6a e0       	ldi	r22, 0x0A	; 10
    26dc:	0e 94 1f b7 	call	0x16e3e	; 0x16e3e <__udivmodqi4>
    26e0:	99 23       	and	r25, r25
    26e2:	49 f4       	brne	.+18     	; 0x26f6 <__vector_12+0xe8>
	     ProcTimeOut++;
    26e4:	80 91 d8 01 	lds	r24, 0x01D8
    26e8:	90 91 d9 01 	lds	r25, 0x01D9
    26ec:	01 96       	adiw	r24, 0x01	; 1
    26ee:	90 93 d9 01 	sts	0x01D9, r25
    26f2:	80 93 d8 01 	sts	0x01D8, r24
	}
	TimSend++;
    26f6:	80 91 a8 01 	lds	r24, 0x01A8
    26fa:	90 91 a9 01 	lds	r25, 0x01A9
    26fe:	01 96       	adiw	r24, 0x01	; 1
    2700:	90 93 a9 01 	sts	0x01A9, r25
    2704:	80 93 a8 01 	sts	0x01A8, r24
}
    2708:	9f 91       	pop	r25
    270a:	8f 91       	pop	r24
    270c:	7f 91       	pop	r23
    270e:	6f 91       	pop	r22
    2710:	2f 91       	pop	r18
    2712:	0f 90       	pop	r0
    2714:	0f be       	out	0x3f, r0	; 63
    2716:	0f 90       	pop	r0
    2718:	1f 90       	pop	r1
    271a:	18 95       	reti

0000271c <RePrintStandalone>:

char RePrintStandalone(char FIPAddr){
     char Result=PS_NONE;

   return Result;
}
    271c:	86 e1       	ldi	r24, 0x16	; 22
    271e:	08 95       	ret

00002720 <GetPumpStatusLabel>:


char GetPumpStatusLabel(char xPumpStatus){
     char Result;

	 switch(xPumpStatus){
    2720:	e8 2f       	mov	r30, r24
    2722:	f0 e0       	ldi	r31, 0x00	; 0
    2724:	ee 31       	cpi	r30, 0x1E	; 30
    2726:	f1 05       	cpc	r31, r1
    2728:	70 f5       	brcc	.+92     	; 0x2786 <GetPumpStatusLabel+0x66>
    272a:	ea 5b       	subi	r30, 0xBA	; 186
    272c:	ff 4f       	sbci	r31, 0xFF	; 255
    272e:	ee 0f       	add	r30, r30
    2730:	ff 1f       	adc	r31, r31
    2732:	05 90       	lpm	r0, Z+
    2734:	f4 91       	lpm	r31, Z+
    2736:	e0 2d       	mov	r30, r0
    2738:	09 94       	ijmp
    273a:	81 e3       	ldi	r24, 0x31	; 49
    273c:	08 95       	ret
    273e:	85 e4       	ldi	r24, 0x45	; 69
    2740:	08 95       	ret
    2742:	82 e3       	ldi	r24, 0x32	; 50
    2744:	08 95       	ret
	 case PUMP_ST1: 
	      Result='1';
		  break;
	 case PUMP_ST2: 
	 	  Result='2';
		  break;
    2746:	83 e3       	ldi	r24, 0x33	; 51
    2748:	08 95       	ret
     case PUMP_ST3:
	 	  Result='3';
		  break;	
    274a:	84 e3       	ldi	r24, 0x34	; 52
    274c:	08 95       	ret
	 case PUMP_ST4: 
          Result='4';
		  break;
    274e:	85 e3       	ldi	r24, 0x35	; 53
    2750:	08 95       	ret
	 case PUMP_ST5: 
	 	  Result='5';
		  break;
    2752:	89 e6       	ldi	r24, 0x69	; 105
    2754:	08 95       	ret
	 case PUMP_OFF: 
	 case PW_ONLINE:
	 	  Result='i';
		  break;
    2756:	8e e6       	ldi	r24, 0x6E	; 110
    2758:	08 95       	ret
     case PW_CALL:
	 case PUMP_CALL: 
	 	  Result='n';
		  break;     
    275a:	81 e6       	ldi	r24, 0x61	; 97
    275c:	08 95       	ret
	 case PUMP_AUTH: 
	 	  Result='a';
		  break;
    275e:	84 e6       	ldi	r24, 0x64	; 100
    2760:	08 95       	ret
     case PW_AUTHORIZED:
	 case PUMP_BUSY: 
	 	  Result='d';
		  break;
    2762:	8f e4       	ldi	r24, 0x4F	; 79
    2764:	08 95       	ret
	 case PUMP_PEOT: 
	 	  Result='O';
		  break;
    2766:	86 e4       	ldi	r24, 0x46	; 70
    2768:	08 95       	ret
     case PW_END_DELIVERY:
	 case PUMP_FEOT: 
	 	  Result='F';
		  break;
    276a:	83 e5       	ldi	r24, 0x53	; 83
    276c:	08 95       	ret
	 case PUMP_STOP: 
	 	  Result='S';
		  break;
    276e:	8d e2       	ldi	r24, 0x2D	; 45
    2770:	08 95       	ret
	 case PUMP_NONE:
	 case PW_DISCONNECT:
	 	  Result='-';
		  break;
    2772:	80 e5       	ldi	r24, 0x50	; 80
    2774:	08 95       	ret
     case PS_PRINT_READY:
	      Result='P';
 	      break;
    2776:	89 e4       	ldi	r24, 0x49	; 73
    2778:	08 95       	ret
     case PS_PRINTED:
	      Result='I';
 	      break;
    277a:	86 e5       	ldi	r24, 0x56	; 86
    277c:	08 95       	ret
     case PS_VOID:
	      Result='V';
	      break;
    277e:	84 e5       	ldi	r24, 0x54	; 84
    2780:	08 95       	ret
     case PS_TOTALIZER:
	      Result='T';
	      break;
    2782:	84 e7       	ldi	r24, 0x74	; 116
    2784:	08 95       	ret
     case PS_FINISH_TOTALIZER:
	      Result='t';
	      break;
    2786:	88 e7       	ldi	r24, 0x78	; 120
	 default:
          Result='x';
		  break;         	 
	 }
  return Result;	 
}
    2788:	08 95       	ret

0000278a <SendPoolingCommand>:
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    278a:	80 93 8a 07 	sts	0x078A, r24
	 PoolMsg=plMsg;
    278e:	60 93 ae 0d 	sts	0x0DAE, r22
     IsControlPooling=True;
    2792:	81 e0       	ldi	r24, 0x01	; 1
    2794:	80 93 97 01 	sts	0x0197, r24
}
    2798:	08 95       	ret

0000279a <ScanEDCFlow>:
	 RemZeroLead(strMsgID);
	 Result=atoi(strMsgID);
  return Result;
}

void ScanEDCFlow(char data){
    279a:	28 2f       	mov	r18, r24
static char IsEDCFlow=False,EDCMsgCode=0;
static unsigned int nFlow=0;
     char i;
     //EDC-MSG
     if (data==0x02){
    279c:	82 30       	cpi	r24, 0x02	; 2
    279e:	39 f4       	brne	.+14     	; 0x27ae <ScanEDCFlow+0x14>
	     IsEDCFlow=True;
    27a0:	81 e0       	ldi	r24, 0x01	; 1
    27a2:	80 93 b1 03 	sts	0x03B1, r24
		 nFlow=0;
    27a6:	10 92 af 03 	sts	0x03AF, r1
    27aa:	10 92 ae 03 	sts	0x03AE, r1
	 }//FillMessage
     if (IsEDCFlow==True){
    27ae:	80 91 b1 03 	lds	r24, 0x03B1
    27b2:	81 30       	cpi	r24, 0x01	; 1
    27b4:	69 f4       	brne	.+26     	; 0x27d0 <ScanEDCFlow+0x36>
	     rcv_trans[nFlow]=data;
    27b6:	80 91 ae 03 	lds	r24, 0x03AE
    27ba:	90 91 af 03 	lds	r25, 0x03AF
    27be:	fc 01       	movw	r30, r24
    27c0:	eb 50       	subi	r30, 0x0B	; 11
    27c2:	f5 4f       	sbci	r31, 0xF5	; 245
    27c4:	20 83       	st	Z, r18
		 nFlow++;
    27c6:	01 96       	adiw	r24, 0x01	; 1
    27c8:	90 93 af 03 	sts	0x03AF, r25
    27cc:	80 93 ae 03 	sts	0x03AE, r24
	 }//CloseMessage
	 if ((data==0x03)||(nFlow>=MSG03_LENGTH)){
    27d0:	23 30       	cpi	r18, 0x03	; 3
    27d2:	41 f0       	breq	.+16     	; 0x27e4 <ScanEDCFlow+0x4a>
    27d4:	80 91 ae 03 	lds	r24, 0x03AE
    27d8:	90 91 af 03 	lds	r25, 0x03AF
    27dc:	8d 34       	cpi	r24, 0x4D	; 77
    27de:	91 05       	cpc	r25, r1
    27e0:	08 f4       	brcc	.+2      	; 0x27e4 <ScanEDCFlow+0x4a>
    27e2:	9b c0       	rjmp	.+310    	; 0x291a <ScanEDCFlow+0x180>
	     //for(i=0;i<nFlow;i++){_uart(0,1,rcv_trans[i]);}
	     IsEDCFlow=False;
    27e4:	10 92 b1 03 	sts	0x03B1, r1
		 EDCMsgCode=((rcv_trans[1]-'0')*10)+(rcv_trans[2]-'0');
    27e8:	30 91 f7 0a 	lds	r19, 0x0AF7
    27ec:	30 51       	subi	r19, 0x10	; 16
    27ee:	80 91 f6 0a 	lds	r24, 0x0AF6
    27f2:	2a e0       	ldi	r18, 0x0A	; 10
    27f4:	82 9f       	mul	r24, r18
    27f6:	c0 01       	movw	r24, r0
    27f8:	11 24       	eor	r1, r1
    27fa:	38 0f       	add	r19, r24
    27fc:	30 93 b0 03 	sts	0x03B0, r19

		 if (EDCMsgCode==0x03){
    2800:	33 30       	cpi	r19, 0x03	; 3
    2802:	09 f0       	breq	.+2      	; 0x2806 <ScanEDCFlow+0x6c>
    2804:	65 c0       	rjmp	.+202    	; 0x28d0 <ScanEDCFlow+0x136>
    2806:	e8 ef       	ldi	r30, 0xF8	; 248
    2808:	fa e0       	ldi	r31, 0x0A	; 10
    280a:	a1 e6       	ldi	r26, 0x61	; 97
    280c:	be e0       	ldi	r27, 0x0E	; 14
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    280e:	81 91       	ld	r24, Z+
    2810:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2812:	8a e0       	ldi	r24, 0x0A	; 10
    2814:	ee 3f       	cpi	r30, 0xFE	; 254
    2816:	f8 07       	cpc	r31, r24
    2818:	d1 f7       	brne	.-12     	; 0x280e <ScanEDCFlow+0x74>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    281a:	10 92 67 0e 	sts	0x0E67, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    281e:	80 81       	ld	r24, Z
    2820:	80 93 9c 09 	sts	0x099C, r24
    2824:	81 81       	ldd	r24, Z+1	; 0x01
    2826:	80 93 9d 09 	sts	0x099D, r24
	 }Dest[Length]=0;
    282a:	10 92 9e 09 	sts	0x099E, r1
    282e:	32 96       	adiw	r30, 0x02	; 2
    2830:	ad e7       	ldi	r26, 0x7D	; 125
    2832:	be e0       	ldi	r27, 0x0E	; 14
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2834:	81 91       	ld	r24, Z+
    2836:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2838:	8b e0       	ldi	r24, 0x0B	; 11
    283a:	ef 30       	cpi	r30, 0x0F	; 15
    283c:	f8 07       	cpc	r31, r24
    283e:	d1 f7       	brne	.-12     	; 0x2834 <ScanEDCFlow+0x9a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2840:	10 92 8c 0e 	sts	0x0E8C, r1
    2844:	a1 e6       	ldi	r26, 0x61	; 97
    2846:	bd e0       	ldi	r27, 0x0D	; 13
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2848:	81 91       	ld	r24, Z+
    284a:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    284c:	8b e0       	ldi	r24, 0x0B	; 11
    284e:	e2 32       	cpi	r30, 0x22	; 34
    2850:	f8 07       	cpc	r31, r24
    2852:	d1 f7       	brne	.-12     	; 0x2848 <ScanEDCFlow+0xae>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2854:	10 92 74 0d 	sts	0x0D74, r1
    2858:	20 e0       	ldi	r18, 0x00	; 0
    285a:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    285c:	f9 01       	movw	r30, r18
    285e:	ec 51       	subi	r30, 0x1C	; 28
    2860:	f6 4f       	sbci	r31, 0xF6	; 246
    2862:	d9 01       	movw	r26, r18
    2864:	ab 50       	subi	r26, 0x0B	; 11
    2866:	b5 4f       	sbci	r27, 0xF5	; 245
    2868:	9d 96       	adiw	r26, 0x2d	; 45
    286a:	8c 91       	ld	r24, X
    286c:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    286e:	2f 5f       	subi	r18, 0xFF	; 255
    2870:	3f 4f       	sbci	r19, 0xFF	; 255
    2872:	26 30       	cpi	r18, 0x06	; 6
    2874:	31 05       	cpc	r19, r1
    2876:	91 f7       	brne	.-28     	; 0x285c <ScanEDCFlow+0xc2>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2878:	10 92 ea 09 	sts	0x09EA, r1
    287c:	20 e0       	ldi	r18, 0x00	; 0
    287e:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2880:	f9 01       	movw	r30, r18
    2882:	ea 5c       	subi	r30, 0xCA	; 202
    2884:	f6 4f       	sbci	r31, 0xF6	; 246
    2886:	d9 01       	movw	r26, r18
    2888:	ab 50       	subi	r26, 0x0B	; 11
    288a:	b5 4f       	sbci	r27, 0xF5	; 245
    288c:	d3 96       	adiw	r26, 0x33	; 51
    288e:	8c 91       	ld	r24, X
    2890:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2892:	2f 5f       	subi	r18, 0xFF	; 255
    2894:	3f 4f       	sbci	r19, 0xFF	; 255
    2896:	2a 30       	cpi	r18, 0x0A	; 10
    2898:	31 05       	cpc	r19, r1
    289a:	91 f7       	brne	.-28     	; 0x2880 <ScanEDCFlow+0xe6>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    289c:	10 92 40 09 	sts	0x0940, r1
    28a0:	20 e0       	ldi	r18, 0x00	; 0
    28a2:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    28a4:	f9 01       	movw	r30, r18
    28a6:	e9 56       	subi	r30, 0x69	; 105
    28a8:	f2 4f       	sbci	r31, 0xF2	; 242
    28aa:	d9 01       	movw	r26, r18
    28ac:	ab 50       	subi	r26, 0x0B	; 11
    28ae:	b5 4f       	sbci	r27, 0xF5	; 245
    28b0:	dd 96       	adiw	r26, 0x3d	; 61
    28b2:	8c 91       	ld	r24, X
    28b4:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    28b6:	2f 5f       	subi	r18, 0xFF	; 255
    28b8:	3f 4f       	sbci	r19, 0xFF	; 255
    28ba:	2e 30       	cpi	r18, 0x0E	; 14
    28bc:	31 05       	cpc	r19, r1
    28be:	91 f7       	brne	.-28     	; 0x28a4 <ScanEDCFlow+0x10a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    28c0:	10 92 a5 0d 	sts	0x0DA5, r1
             StrPosCopy(rcv_trans,strCardType,11,15);
             StrPosCopy(rcv_trans,strCardID,26,19);
             StrPosCopy(rcv_trans,strApprovalCode,45,6);
             StrPosCopy(rcv_trans,strInvoiceNumber,51,10);
             StrPosCopy(rcv_trans,strDateTime,61,14);
		     IsEDCApproved=True;//Sending Message 92
    28c4:	81 e0       	ldi	r24, 0x01	; 1
    28c6:	80 93 b0 01 	sts	0x01B0, r24
			 IsPrintApprovalCode=True;
    28ca:	80 93 b1 01 	sts	0x01B1, r24
    28ce:	08 95       	ret
	    }else
		 if (EDCMsgCode==0x04){
    28d0:	34 30       	cpi	r19, 0x04	; 4
    28d2:	19 f5       	brne	.+70     	; 0x291a <ScanEDCFlow+0x180>
    28d4:	e8 ef       	ldi	r30, 0xF8	; 248
    28d6:	fa e0       	ldi	r31, 0x0A	; 10
    28d8:	a4 ee       	ldi	r26, 0xE4	; 228
    28da:	b9 e0       	ldi	r27, 0x09	; 9
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    28dc:	81 91       	ld	r24, Z+
    28de:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    28e0:	8a e0       	ldi	r24, 0x0A	; 10
    28e2:	ee 3f       	cpi	r30, 0xFE	; 254
    28e4:	f8 07       	cpc	r31, r24
    28e6:	d1 f7       	brne	.-12     	; 0x28dc <ScanEDCFlow+0x142>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    28e8:	10 92 ea 09 	sts	0x09EA, r1
    28ec:	a6 e3       	ldi	r26, 0x36	; 54
    28ee:	b9 e0       	ldi	r27, 0x09	; 9
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    28f0:	81 91       	ld	r24, Z+
    28f2:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    28f4:	8b e0       	ldi	r24, 0x0B	; 11
    28f6:	e8 30       	cpi	r30, 0x08	; 8
    28f8:	f8 07       	cpc	r31, r24
    28fa:	d1 f7       	brne	.-12     	; 0x28f0 <ScanEDCFlow+0x156>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    28fc:	10 92 40 09 	sts	0x0940, r1
    2900:	a7 e9       	ldi	r26, 0x97	; 151
    2902:	bd e0       	ldi	r27, 0x0D	; 13
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2904:	81 91       	ld	r24, Z+
    2906:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2908:	8b e0       	ldi	r24, 0x0B	; 11
    290a:	e6 31       	cpi	r30, 0x16	; 22
    290c:	f8 07       	cpc	r31, r24
    290e:	d1 f7       	brne	.-12     	; 0x2904 <ScanEDCFlow+0x16a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2910:	10 92 a5 0d 	sts	0x0DA5, r1
	    }else
		 if (EDCMsgCode==0x04){
             StrPosCopy(rcv_trans,strApprovalCode,3,6);
             StrPosCopy(rcv_trans,strInvoiceNumber,9,10);
             StrPosCopy(rcv_trans,strDateTime,19,14);
			 IsVoidTransaction=True;
    2914:	81 e0       	ldi	r24, 0x01	; 1
    2916:	80 93 b2 01 	sts	0x01B2, r24
    291a:	08 95       	ret

0000291c <ScanHiddenKeyFlow>:
	    }
    }//MSGDetection
}

void ScanHiddenKeyFlow(char KeyIn){
}
    291c:	08 95       	ret

0000291e <ScanRFIDFlow>:


void ScanRFIDFlow(char data){//                   12 11 10 9  8  7  6  5  4  3  2  1  0
    291e:	98 2f       	mov	r25, r24
    2920:	e4 e7       	ldi	r30, 0x74	; 116
    2922:	fa e0       	ldi	r31, 0x0A	; 10
     char i=0,strSerial[20]; //Shift Data Serial; 02 32 33 44 31 30 41 36 43 0D 0A 0A 03 
	                                                //2 50 51 65 68 68 68 54 67 13 10 3

	 for(i=0;i<19;i++){
        strSerialFlow[19-i]=strSerialFlow[18-i];   
    2924:	80 81       	ld	r24, Z
    2926:	81 83       	std	Z+1, r24	; 0x01
    2928:	31 97       	sbiw	r30, 0x01	; 1

void ScanRFIDFlow(char data){//                   12 11 10 9  8  7  6  5  4  3  2  1  0
     char i=0,strSerial[20]; //Shift Data Serial; 02 32 33 44 31 30 41 36 43 0D 0A 0A 03 
	                                                //2 50 51 65 68 68 68 54 67 13 10 3

	 for(i=0;i<19;i++){
    292a:	8a e0       	ldi	r24, 0x0A	; 10
    292c:	e1 36       	cpi	r30, 0x61	; 97
    292e:	f8 07       	cpc	r31, r24
    2930:	c9 f7       	brne	.-14     	; 0x2924 <ScanRFIDFlow+0x6>
        strSerialFlow[19-i]=strSerialFlow[18-i];   
	 }  strSerialFlow[0]=data;
    2932:	9f 01       	movw	r18, r30
    2934:	2f 5f       	subi	r18, 0xFF	; 255
    2936:	3f 4f       	sbci	r19, 0xFF	; 255
    2938:	91 83       	std	Z+1, r25	; 0x01
	 //Detection
	 if ((strSerialFlow[11]==0x02)&&(strSerialFlow[1]==0x0A)&&(strSerialFlow[0]==0x03)){
    293a:	84 85       	ldd	r24, Z+12	; 0x0c
    293c:	82 30       	cpi	r24, 0x02	; 2
    293e:	f9 f4       	brne	.+62     	; 0x297e <ScanRFIDFlow+0x60>
    2940:	80 91 63 0a 	lds	r24, 0x0A63
    2944:	8a 30       	cpi	r24, 0x0A	; 10
    2946:	d9 f4       	brne	.+54     	; 0x297e <ScanRFIDFlow+0x60>
    2948:	93 30       	cpi	r25, 0x03	; 3
    294a:	c9 f4       	brne	.+50     	; 0x297e <ScanRFIDFlow+0x60>
    294c:	f9 01       	movw	r30, r18
    294e:	3a 96       	adiw	r30, 0x0a	; 10
    2950:	ac e2       	ldi	r26, 0x2C	; 44
    2952:	be e0       	ldi	r27, 0x0E	; 14
		for(i=0;i<8;i++) strRFID[i]=strSerialFlow[10-i];
    2954:	80 81       	ld	r24, Z
    2956:	8d 93       	st	X+, r24
    2958:	31 97       	sbiw	r30, 0x01	; 1
    295a:	8a e0       	ldi	r24, 0x0A	; 10
    295c:	e4 36       	cpi	r30, 0x64	; 100
    295e:	f8 07       	cpc	r31, r24
    2960:	c9 f7       	brne	.-14     	; 0x2954 <ScanRFIDFlow+0x36>
        strRFID[8]=0;
    2962:	10 92 34 0e 	sts	0x0E34, r1
	    IsRFIDDetected=True;
    2966:	81 e0       	ldi	r24, 0x01	; 1
    2968:	80 93 af 01 	sts	0x01AF, r24
     }      
}

void BackLightTrig(){
     //TimBackLight=0;
__key_light = 1; __key_lgtcnt = 0; PORTG=PORTG&0b11111101;
    296c:	80 93 bf 03 	sts	0x03BF, r24
    2970:	10 92 c0 03 	sts	0x03C0, r1
    2974:	80 91 65 00 	lds	r24, 0x0065
    2978:	8d 7f       	andi	r24, 0xFD	; 253
    297a:	80 93 65 00 	sts	0x0065, r24
    297e:	08 95       	ret

00002980 <__vector_18>:
	if (IFType==IT_SLAVE)ScanEDCFlow(dataSPI);
	else
	if (IFType==IT_STANDALONE)ScanStandaloneFlow(dataSPI);
}

ISR(USART0_RX_vect){
    2980:	1f 92       	push	r1
    2982:	0f 92       	push	r0
    2984:	0f b6       	in	r0, 0x3f	; 63
    2986:	0f 92       	push	r0
    2988:	11 24       	eor	r1, r1
    298a:	8f 93       	push	r24
    298c:	9f 93       	push	r25
	char dataRX0,IsSPI=False;
	dataRX0= UDR0;
    298e:	9c b1       	in	r25, 0x0c	; 12
	//PrintBusyDetection
	if ((IsBusyIdlePrinting==True)||(IsBusyFreePrinting==True)){
    2990:	80 91 c8 01 	lds	r24, 0x01C8
    2994:	81 30       	cpi	r24, 0x01	; 1
    2996:	21 f0       	breq	.+8      	; 0x29a0 <__vector_18+0x20>
    2998:	80 91 ca 01 	lds	r24, 0x01CA
    299c:	81 30       	cpi	r24, 0x01	; 1
    299e:	51 f4       	brne	.+20     	; 0x29b4 <__vector_18+0x34>
	    if (dataRX0==19)IsBusyPrint=True;
    29a0:	93 31       	cpi	r25, 0x13	; 19
    29a2:	21 f4       	brne	.+8      	; 0x29ac <__vector_18+0x2c>
    29a4:	81 e0       	ldi	r24, 0x01	; 1
    29a6:	80 93 c9 01 	sts	0x01C9, r24
    29aa:	04 c0       	rjmp	.+8      	; 0x29b4 <__vector_18+0x34>
		else 
	    if (dataRX0==17)IsBusyPrint=False;	
    29ac:	91 31       	cpi	r25, 0x11	; 17
    29ae:	11 f4       	brne	.+4      	; 0x29b4 <__vector_18+0x34>
    29b0:	10 92 c9 01 	sts	0x01C9, r1
	}
}
    29b4:	9f 91       	pop	r25
    29b6:	8f 91       	pop	r24
    29b8:	0f 90       	pop	r0
    29ba:	0f be       	out	0x3f, r0	; 63
    29bc:	0f 90       	pop	r0
    29be:	1f 90       	pop	r1
    29c0:	18 95       	reti

000029c2 <ScanCommand>:

char ScanCommand(char *strFlow,char *fCommand){
     char Result;
	 Result=False;
   return Result;
}
    29c2:	80 e0       	ldi	r24, 0x00	; 0
    29c4:	08 95       	ret

000029c6 <ConfigProtocol>:
	 }
	 _uart_printf(1,1,PSTR(">"));
	 //End
}

void ConfigProtocol(char dataIn){
    29c6:	28 2f       	mov	r18, r24
     static char Conflow[7];
    //Configuration Data Request 
	if ((Conflow[6]=='i')&&(Conflow[5]=='C')&&(Conflow[4]=='o')&&(Conflow[3]=='n')&&(Conflow[2]=='f')&&(Conflow[1]=='?')&&(Conflow[0]==0x0D)&&(dataIn==0x0A)){
    29c8:	80 91 ac 03 	lds	r24, 0x03AC
    29cc:	89 36       	cpi	r24, 0x69	; 105
    29ce:	e9 f4       	brne	.+58     	; 0x2a0a <ConfigProtocol+0x44>
    29d0:	80 91 ab 03 	lds	r24, 0x03AB
    29d4:	83 34       	cpi	r24, 0x43	; 67
    29d6:	c9 f4       	brne	.+50     	; 0x2a0a <ConfigProtocol+0x44>
    29d8:	80 91 aa 03 	lds	r24, 0x03AA
    29dc:	8f 36       	cpi	r24, 0x6F	; 111
    29de:	a9 f4       	brne	.+42     	; 0x2a0a <ConfigProtocol+0x44>
    29e0:	80 91 a9 03 	lds	r24, 0x03A9
    29e4:	8e 36       	cpi	r24, 0x6E	; 110
    29e6:	89 f4       	brne	.+34     	; 0x2a0a <ConfigProtocol+0x44>
    29e8:	80 91 a8 03 	lds	r24, 0x03A8
    29ec:	86 36       	cpi	r24, 0x66	; 102
    29ee:	69 f4       	brne	.+26     	; 0x2a0a <ConfigProtocol+0x44>
    29f0:	80 91 a7 03 	lds	r24, 0x03A7
    29f4:	8f 33       	cpi	r24, 0x3F	; 63
    29f6:	49 f4       	brne	.+18     	; 0x2a0a <ConfigProtocol+0x44>
    29f8:	80 91 a6 03 	lds	r24, 0x03A6
    29fc:	8d 30       	cpi	r24, 0x0D	; 13
    29fe:	29 f4       	brne	.+10     	; 0x2a0a <ConfigProtocol+0x44>
    2a00:	2a 30       	cpi	r18, 0x0A	; 10
    2a02:	19 f4       	brne	.+6      	; 0x2a0a <ConfigProtocol+0x44>
	     //SendConfigParamater();        
		 ConfigCommand=CC_SEND_CONFIG;
    2a04:	82 e0       	ldi	r24, 0x02	; 2
    2a06:	80 93 c6 01 	sts	0x01C6, r24
	}

	if (IsConfigFlow==True){        
    2a0a:	80 91 98 01 	lds	r24, 0x0198
    2a0e:	81 30       	cpi	r24, 0x01	; 1
    2a10:	69 f4       	brne	.+26     	; 0x2a2c <ConfigProtocol+0x66>
	    rcv_trans[char_count]=dataIn;
    2a12:	80 91 9c 01 	lds	r24, 0x019C
    2a16:	90 91 9d 01 	lds	r25, 0x019D
    2a1a:	fc 01       	movw	r30, r24
    2a1c:	eb 50       	subi	r30, 0x0B	; 11
    2a1e:	f5 4f       	sbci	r31, 0xF5	; 245
    2a20:	20 83       	st	Z, r18
	    char_count++; 
    2a22:	01 96       	adiw	r24, 0x01	; 1
    2a24:	90 93 9d 01 	sts	0x019D, r25
    2a28:	80 93 9c 01 	sts	0x019C, r24
	}
	if ((Conflow[0]==0x04)&&(dataIn==0x40)){
    2a2c:	80 91 a6 03 	lds	r24, 0x03A6
    2a30:	84 30       	cpi	r24, 0x04	; 4
    2a32:	51 f4       	brne	.+20     	; 0x2a48 <ConfigProtocol+0x82>
    2a34:	20 34       	cpi	r18, 0x40	; 64
    2a36:	e9 f4       	brne	.+58     	; 0x2a72 <ConfigProtocol+0xac>
	     IsConfigFlow=True;
    2a38:	81 e0       	ldi	r24, 0x01	; 1
    2a3a:	80 93 98 01 	sts	0x0198, r24
		 char_count=0;
    2a3e:	10 92 9d 01 	sts	0x019D, r1
    2a42:	10 92 9c 01 	sts	0x019C, r1
    2a46:	15 c0       	rjmp	.+42     	; 0x2a72 <ConfigProtocol+0xac>
	}
	//SavingData
	if ((Conflow[0]==0x05)&&(dataIn==0x50)){
    2a48:	85 30       	cpi	r24, 0x05	; 5
    2a4a:	99 f4       	brne	.+38     	; 0x2a72 <ConfigProtocol+0xac>
    2a4c:	20 35       	cpi	r18, 0x50	; 80
    2a4e:	89 f4       	brne	.+34     	; 0x2a72 <ConfigProtocol+0xac>
	     transLength=char_count;
    2a50:	80 91 9c 01 	lds	r24, 0x019C
    2a54:	90 91 9d 01 	lds	r25, 0x019D
    2a58:	90 93 9f 01 	sts	0x019F, r25
    2a5c:	80 93 9e 01 	sts	0x019E, r24
		 char_count=0;
    2a60:	10 92 9d 01 	sts	0x019D, r1
    2a64:	10 92 9c 01 	sts	0x019C, r1
	     IsConfigFlow=False;
    2a68:	10 92 98 01 	sts	0x0198, r1
		 ConfigCommand=CC_SAVE_CONFIG;
    2a6c:	81 e0       	ldi	r24, 0x01	; 1
    2a6e:	80 93 c6 01 	sts	0x01C6, r24
		 //SaveConfigParameter();
	}

	//Shifting
	Conflow[6]=Conflow[5];
    2a72:	80 91 ab 03 	lds	r24, 0x03AB
    2a76:	80 93 ac 03 	sts	0x03AC, r24
	Conflow[5]=Conflow[4];
    2a7a:	80 91 aa 03 	lds	r24, 0x03AA
    2a7e:	80 93 ab 03 	sts	0x03AB, r24
	Conflow[4]=Conflow[3];
    2a82:	80 91 a9 03 	lds	r24, 0x03A9
    2a86:	80 93 aa 03 	sts	0x03AA, r24
	Conflow[3]=Conflow[2];
    2a8a:	80 91 a8 03 	lds	r24, 0x03A8
    2a8e:	80 93 a9 03 	sts	0x03A9, r24
	Conflow[2]=Conflow[1];
    2a92:	80 91 a7 03 	lds	r24, 0x03A7
    2a96:	80 93 a8 03 	sts	0x03A8, r24
	Conflow[1]=Conflow[0];
    2a9a:	80 91 a6 03 	lds	r24, 0x03A6
    2a9e:	80 93 a7 03 	sts	0x03A7, r24
	Conflow[0]=dataIn;
    2aa2:	20 93 a6 03 	sts	0x03A6, r18

}
    2aa6:	08 95       	ret

00002aa8 <system_beep>:
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    2aa8:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    2aaa:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    2aac:	90 93 d7 01 	sts	0x01D7, r25
    2ab0:	80 93 d6 01 	sts	0x01D6, r24
}
    2ab4:	08 95       	ret

00002ab6 <systemRestart>:
	 iRestart=0;
	 while(iRestart<100){
	       strRestart[iRestart]=iRestart;
	       iRestart++;	 
	 }
}
    2ab6:	08 95       	ret

00002ab8 <Low>:

char Low(char X){
     char Result;
	 Result=(0x0F&X);
	 return Result;
}
    2ab8:	8f 70       	andi	r24, 0x0F	; 15
    2aba:	08 95       	ret

00002abc <High>:
char High(char X){
     char Result;
	 Result=((X>>4)&(0x0F));
	 return Result;
}
    2abc:	82 95       	swap	r24
    2abe:	8f 70       	andi	r24, 0x0F	; 15
    2ac0:	08 95       	ret

00002ac2 <Str>:
char Str(char H){
    2ac2:	98 2f       	mov	r25, r24
unsigned char Conv=0;
        if ((H>=0)&&(H<=9)) Conv='0'+H;
    2ac4:	8a 30       	cpi	r24, 0x0A	; 10
    2ac6:	10 f4       	brcc	.+4      	; 0x2acc <Str+0xa>
    2ac8:	80 5d       	subi	r24, 0xD0	; 208
    2aca:	08 95       	ret
        else
        if ((H>=0x0A)&&(H<=0x0F)) Conv='A'+(H-10);    
    2acc:	8a 50       	subi	r24, 0x0A	; 10
    2ace:	86 30       	cpi	r24, 0x06	; 6
    2ad0:	10 f0       	brcs	.+4      	; 0x2ad6 <Str+0x14>
    2ad2:	80 e0       	ldi	r24, 0x00	; 0
    2ad4:	08 95       	ret
    2ad6:	89 2f       	mov	r24, r25
    2ad8:	89 5c       	subi	r24, 0xC9	; 201
        return (Conv);
}
    2ada:	08 95       	ret

00002adc <charToHex>:

void charToHex(char X, char *Result){
    2adc:	28 2f       	mov	r18, r24
    2ade:	fb 01       	movw	r30, r22
	 Result=(0x0F&X);
	 return Result;
}
char High(char X){
     char Result;
	 Result=((X>>4)&(0x0F));
    2ae0:	98 2f       	mov	r25, r24
    2ae2:	92 95       	swap	r25
    2ae4:	9f 70       	andi	r25, 0x0F	; 15
	 return Result;
}
char Str(char H){
unsigned char Conv=0;
        if ((H>=0)&&(H<=9)) Conv='0'+H;
    2ae6:	9a 30       	cpi	r25, 0x0A	; 10
    2ae8:	18 f4       	brcc	.+6      	; 0x2af0 <charToHex+0x14>
    2aea:	89 2f       	mov	r24, r25
    2aec:	80 5d       	subi	r24, 0xD0	; 208
    2aee:	08 c0       	rjmp	.+16     	; 0x2b00 <charToHex+0x24>
        else
        if ((H>=0x0A)&&(H<=0x0F)) Conv='A'+(H-10);    
    2af0:	89 2f       	mov	r24, r25
    2af2:	8a 50       	subi	r24, 0x0A	; 10
    2af4:	86 30       	cpi	r24, 0x06	; 6
    2af6:	10 f0       	brcs	.+4      	; 0x2afc <charToHex+0x20>
    2af8:	80 e0       	ldi	r24, 0x00	; 0
    2afa:	02 c0       	rjmp	.+4      	; 0x2b00 <charToHex+0x24>
    2afc:	89 2f       	mov	r24, r25
    2afe:	89 5c       	subi	r24, 0xC9	; 201
        return (Conv);
}

void charToHex(char X, char *Result){
     Result[0]=Str(High(X));
    2b00:	80 83       	st	Z, r24
	lcd_print(1,1,lcdteks);
}

char Low(char X){
     char Result;
	 Result=(0x0F&X);
    2b02:	92 2f       	mov	r25, r18
    2b04:	9f 70       	andi	r25, 0x0F	; 15
	 Result=((X>>4)&(0x0F));
	 return Result;
}
char Str(char H){
unsigned char Conv=0;
        if ((H>=0)&&(H<=9)) Conv='0'+H;
    2b06:	9a 30       	cpi	r25, 0x0A	; 10
    2b08:	18 f4       	brcc	.+6      	; 0x2b10 <charToHex+0x34>
    2b0a:	89 2f       	mov	r24, r25
    2b0c:	80 5d       	subi	r24, 0xD0	; 208
    2b0e:	08 c0       	rjmp	.+16     	; 0x2b20 <charToHex+0x44>
        else
        if ((H>=0x0A)&&(H<=0x0F)) Conv='A'+(H-10);    
    2b10:	89 2f       	mov	r24, r25
    2b12:	8a 50       	subi	r24, 0x0A	; 10
    2b14:	86 30       	cpi	r24, 0x06	; 6
    2b16:	10 f0       	brcs	.+4      	; 0x2b1c <charToHex+0x40>
    2b18:	80 e0       	ldi	r24, 0x00	; 0
    2b1a:	02 c0       	rjmp	.+4      	; 0x2b20 <charToHex+0x44>
    2b1c:	89 2f       	mov	r24, r25
    2b1e:	89 5c       	subi	r24, 0xC9	; 201
        return (Conv);
}

void charToHex(char X, char *Result){
     Result[0]=Str(High(X));
	 Result[1]=Str(Low(X));
    2b20:	81 83       	std	Z+1, r24	; 0x01
	 Result[2]=0;
    2b22:	12 82       	std	Z+2, r1	; 0x02
	 
}
    2b24:	08 95       	ret

00002b26 <strToInt>:

char strToInt(char *str){
    2b26:	fc 01       	movw	r30, r24
     char Result;
     Result=(((str[0]-'0')*10) +(str[0]-'0'));
    2b28:	80 81       	ld	r24, Z
    2b2a:	2a e0       	ldi	r18, 0x0A	; 10
    2b2c:	82 9f       	mul	r24, r18
    2b2e:	90 01       	movw	r18, r0
    2b30:	11 24       	eor	r1, r1
    2b32:	80 51       	subi	r24, 0x10	; 16
	 return Result;
}
    2b34:	82 0f       	add	r24, r18
    2b36:	08 95       	ret

00002b38 <intToStr>:

void intToStr(char X, char *str){
    2b38:	58 2f       	mov	r21, r24
    2b3a:	fb 01       	movw	r30, r22
     char R,P,S;
	 R=X/100;
    2b3c:	64 e6       	ldi	r22, 0x64	; 100
    2b3e:	0e 94 1f b7 	call	0x16e3e	; 0x16e3e <__udivmodqi4>
    2b42:	a8 2f       	mov	r26, r24
	 P=(X%100)/10;
    2b44:	85 2f       	mov	r24, r21
    2b46:	0e 94 1f b7 	call	0x16e3e	; 0x16e3e <__udivmodqi4>
    2b4a:	89 2f       	mov	r24, r25
    2b4c:	6a e0       	ldi	r22, 0x0A	; 10
    2b4e:	0e 94 1f b7 	call	0x16e3e	; 0x16e3e <__udivmodqi4>
    2b52:	48 2f       	mov	r20, r24
	 S=X-(R*100)-(P*10);
    2b54:	8c e9       	ldi	r24, 0x9C	; 156
    2b56:	9f ef       	ldi	r25, 0xFF	; 255
    2b58:	a8 9f       	mul	r26, r24
    2b5a:	80 2d       	mov	r24, r0
    2b5c:	11 24       	eor	r1, r1
    2b5e:	85 0f       	add	r24, r21
    2b60:	26 ef       	ldi	r18, 0xF6	; 246
    2b62:	3f ef       	ldi	r19, 0xFF	; 255
    2b64:	42 9f       	mul	r20, r18
    2b66:	90 2d       	mov	r25, r0
    2b68:	11 24       	eor	r1, r1
    2b6a:	98 0f       	add	r25, r24
	 if (X>=100){
    2b6c:	54 36       	cpi	r21, 0x64	; 100
    2b6e:	40 f0       	brcs	.+16     	; 0x2b80 <intToStr+0x48>
	     str[0]=('0'+R);
    2b70:	a0 5d       	subi	r26, 0xD0	; 208
    2b72:	a0 83       	st	Z, r26
	     str[1]=('0'+P);
    2b74:	40 5d       	subi	r20, 0xD0	; 208
    2b76:	41 83       	std	Z+1, r20	; 0x01
	     str[2]=('0'+S);
    2b78:	90 5d       	subi	r25, 0xD0	; 208
    2b7a:	92 83       	std	Z+2, r25	; 0x02
	     str[3]=0;
    2b7c:	13 82       	std	Z+3, r1	; 0x03
    2b7e:	08 95       	ret
	 if ((X>=10)&&(X>100)){
	     str[0]=('0'+P);
	     str[1]=('0'+S);
	     str[2]=0;
	 }else 
	 if (X<=10){
    2b80:	5b 30       	cpi	r21, 0x0B	; 11
    2b82:	18 f4       	brcc	.+6      	; 0x2b8a <intToStr+0x52>
	     str[0]=('0'+S);
    2b84:	90 5d       	subi	r25, 0xD0	; 208
    2b86:	90 83       	st	Z, r25
	     str[1]=0;
    2b88:	11 82       	std	Z+1, r1	; 0x01
    2b8a:	08 95       	ret

00002b8c <ViewCardID>:
		else strCardID[i]=strRFID[i-(20-LengthID)];
	 }strCardID[20]=0;

}

void ViewCardID(){//+12345678 -->12345678
    2b8c:	20 e0       	ldi	r18, 0x00	; 0
    2b8e:	30 e0       	ldi	r19, 0x00	; 0
     char i;
	 for(i=0;i<8;i++){         //00000000000012345678
		strCardID[i]=strRFID[i];
    2b90:	f9 01       	movw	r30, r18
    2b92:	ef 59       	subi	r30, 0x9F	; 159
    2b94:	f2 4f       	sbci	r31, 0xF2	; 242
    2b96:	d9 01       	movw	r26, r18
    2b98:	a4 5d       	subi	r26, 0xD4	; 212
    2b9a:	b1 4f       	sbci	r27, 0xF1	; 241
    2b9c:	8c 91       	ld	r24, X
    2b9e:	80 83       	st	Z, r24
    2ba0:	2f 5f       	subi	r18, 0xFF	; 255
    2ba2:	3f 4f       	sbci	r19, 0xFF	; 255

}

void ViewCardID(){//+12345678 -->12345678
     char i;
	 for(i=0;i<8;i++){         //00000000000012345678
    2ba4:	28 30       	cpi	r18, 0x08	; 8
    2ba6:	31 05       	cpc	r19, r1
    2ba8:	99 f7       	brne	.-26     	; 0x2b90 <ViewCardID+0x4>
		strCardID[i]=strRFID[i];
	 }strCardID[8]=0;     
    2baa:	10 92 69 0d 	sts	0x0D69, r1
}
    2bae:	08 95       	ret

00002bb0 <StringCopy>:
//Message 56


void StringCopy(char *Source,char *Dest,char Length){
    2bb0:	cf 93       	push	r28
    2bb2:	df 93       	push	r29
    2bb4:	db 01       	movw	r26, r22
    2bb6:	ec 01       	movw	r28, r24
    2bb8:	20 e0       	ldi	r18, 0x00	; 0
    2bba:	30 e0       	ldi	r19, 0x00	; 0
    2bbc:	07 c0       	rjmp	.+14     	; 0x2bcc <StringCopy+0x1c>
     char i;
	 for (i=0;i<Length;i++){
	     Dest[i]=Source[i];
    2bbe:	fd 01       	movw	r30, r26
    2bc0:	e2 0f       	add	r30, r18
    2bc2:	f3 1f       	adc	r31, r19
    2bc4:	89 91       	ld	r24, Y+
    2bc6:	80 83       	st	Z, r24
    2bc8:	2f 5f       	subi	r18, 0xFF	; 255
    2bca:	3f 4f       	sbci	r19, 0xFF	; 255
//Message 56


void StringCopy(char *Source,char *Dest,char Length){
     char i;
	 for (i=0;i<Length;i++){
    2bcc:	24 17       	cp	r18, r20
    2bce:	b8 f3       	brcs	.-18     	; 0x2bbe <StringCopy+0xe>
	     Dest[i]=Source[i];
	 }Dest[Length]=0;
    2bd0:	a4 0f       	add	r26, r20
    2bd2:	b1 1d       	adc	r27, r1
    2bd4:	1c 92       	st	X, r1
}
    2bd6:	df 91       	pop	r29
    2bd8:	cf 91       	pop	r28
    2bda:	08 95       	ret

00002bdc <StringCopyPos>:
void StringCopyPos(char *Source,char *Dest,char SrcPos,char Length){
    2bdc:	cf 93       	push	r28
    2bde:	df 93       	push	r29
    2be0:	db 01       	movw	r26, r22
    2be2:	ec 01       	movw	r28, r24
    2be4:	c4 0f       	add	r28, r20
    2be6:	d1 1d       	adc	r29, r1
    2be8:	40 e0       	ldi	r20, 0x00	; 0
    2bea:	50 e0       	ldi	r21, 0x00	; 0
    2bec:	07 c0       	rjmp	.+14     	; 0x2bfc <StringCopyPos+0x20>
     char i;
	 for (i=0;i<Length;i++){
	     Dest[i]=Source[SrcPos+i];
    2bee:	fd 01       	movw	r30, r26
    2bf0:	e4 0f       	add	r30, r20
    2bf2:	f5 1f       	adc	r31, r21
    2bf4:	89 91       	ld	r24, Y+
    2bf6:	80 83       	st	Z, r24
    2bf8:	4f 5f       	subi	r20, 0xFF	; 255
    2bfa:	5f 4f       	sbci	r21, 0xFF	; 255
	     Dest[i]=Source[i];
	 }Dest[Length]=0;
}
void StringCopyPos(char *Source,char *Dest,char SrcPos,char Length){
     char i;
	 for (i=0;i<Length;i++){
    2bfc:	42 17       	cp	r20, r18
    2bfe:	b8 f3       	brcs	.-18     	; 0x2bee <StringCopyPos+0x12>
	     Dest[i]=Source[SrcPos+i];
	 }Dest[Length]=0;
    2c00:	a2 0f       	add	r26, r18
    2c02:	b1 1d       	adc	r27, r1
    2c04:	1c 92       	st	X, r1
}
    2c06:	df 91       	pop	r29
    2c08:	cf 91       	pop	r28
    2c0a:	08 95       	ret

00002c0c <TestLocalAccount>:

void TestLocalAccount(){

}
    2c0c:	08 95       	ret

00002c0e <BackLightTrig>:
     }      
}

void BackLightTrig(){
     //TimBackLight=0;
__key_light = 1; __key_lgtcnt = 0; PORTG=PORTG&0b11111101;
    2c0e:	81 e0       	ldi	r24, 0x01	; 1
    2c10:	80 93 bf 03 	sts	0x03BF, r24
    2c14:	10 92 c0 03 	sts	0x03C0, r1
    2c18:	e5 e6       	ldi	r30, 0x65	; 101
    2c1a:	f0 e0       	ldi	r31, 0x00	; 0
    2c1c:	80 81       	ld	r24, Z
    2c1e:	8d 7f       	andi	r24, 0xFD	; 253
    2c20:	80 83       	st	Z, r24
}
    2c22:	08 95       	ret

00002c24 <FBackLight>:

void FBackLight(){
     if (TimBackLight>0){
    2c24:	20 91 a2 01 	lds	r18, 0x01A2
    2c28:	30 91 a3 01 	lds	r19, 0x01A3
    2c2c:	21 15       	cp	r18, r1
    2c2e:	31 05       	cpc	r19, r1
    2c30:	61 f0       	breq	.+24     	; 0x2c4a <FBackLight+0x26>
	     PORTG=PORTG&0xFD;
    2c32:	80 91 65 00 	lds	r24, 0x0065
    2c36:	8d 7f       	andi	r24, 0xFD	; 253
    2c38:	80 93 65 00 	sts	0x0065, r24
	     TimBackLight--;
    2c3c:	21 50       	subi	r18, 0x01	; 1
    2c3e:	30 40       	sbci	r19, 0x00	; 0
    2c40:	30 93 a3 01 	sts	0x01A3, r19
    2c44:	20 93 a2 01 	sts	0x01A2, r18
    2c48:	08 95       	ret
		 }
	 else PORTG=PORTG|0x02;
    2c4a:	80 91 65 00 	lds	r24, 0x0065
    2c4e:	82 60       	ori	r24, 0x02	; 2
    2c50:	80 93 65 00 	sts	0x0065, r24
    2c54:	08 95       	ret

00002c56 <GetBaudrate>:
	 }
}

int GetBaudrate(char brSetting){
int Result=0;
     switch(brSetting){
    2c56:	82 30       	cpi	r24, 0x02	; 2
    2c58:	59 f0       	breq	.+22     	; 0x2c70 <GetBaudrate+0x1a>
    2c5a:	82 30       	cpi	r24, 0x02	; 2
    2c5c:	18 f0       	brcs	.+6      	; 0x2c64 <GetBaudrate+0xe>
    2c5e:	83 30       	cpi	r24, 0x03	; 3
    2c60:	21 f4       	brne	.+8      	; 0x2c6a <GetBaudrate+0x14>
    2c62:	09 c0       	rjmp	.+18     	; 0x2c76 <GetBaudrate+0x20>
    2c64:	20 e8       	ldi	r18, 0x80	; 128
    2c66:	35 e2       	ldi	r19, 0x25	; 37
    2c68:	08 c0       	rjmp	.+16     	; 0x2c7a <GetBaudrate+0x24>
    2c6a:	20 e0       	ldi	r18, 0x00	; 0
    2c6c:	30 e0       	ldi	r19, 0x00	; 0
    2c6e:	05 c0       	rjmp	.+10     	; 0x2c7a <GetBaudrate+0x24>
    2c70:	20 e0       	ldi	r18, 0x00	; 0
    2c72:	3b e4       	ldi	r19, 0x4B	; 75
    2c74:	02 c0       	rjmp	.+4      	; 0x2c7a <GetBaudrate+0x24>
	 case br9600: 
	      Result=9600;
	      break;
	 case br19200:
	      Result=19200;
	      break;
    2c76:	2b e9       	ldi	r18, 0x9B	; 155
    2c78:	36 e1       	ldi	r19, 0x16	; 22
	 case br5787:
	      Result=5787;
     	  break;	 
	 }
   return Result;
}
    2c7a:	c9 01       	movw	r24, r18
    2c7c:	08 95       	ret

00002c7e <InitMemory>:
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2c7e:	e1 99       	sbic	0x1c, 1	; 28
    2c80:	fe cf       	rjmp	.-4      	; 0x2c7e <InitMemory>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2c82:	84 e4       	ldi	r24, 0x44	; 68
    2c84:	91 e0       	ldi	r25, 0x01	; 1
    2c86:	9f bb       	out	0x1f, r25	; 31
    2c88:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2c8a:	e0 9a       	sbi	0x1c, 0	; 28
    2c8c:	8d b3       	in	r24, 0x1d	; 29

	 }
}

void InitMemory(){
     PumpCountMax=eeprom_read_byte(&DefPoolingPumpMax);
    2c8e:	80 93 5f 01 	sts	0x015F, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2c92:	e1 99       	sbic	0x1c, 1	; 28
    2c94:	fe cf       	rjmp	.-4      	; 0x2c92 <InitMemory+0x14>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2c96:	89 e4       	ldi	r24, 0x49	; 73
    2c98:	91 e0       	ldi	r25, 0x01	; 1
    2c9a:	9f bb       	out	0x1f, r25	; 31
    2c9c:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2c9e:	e0 9a       	sbi	0x1c, 0	; 28
    2ca0:	8d b3       	in	r24, 0x1d	; 29
	 ActivePump=eeprom_read_byte(&DefActivePump);
    2ca2:	80 93 60 01 	sts	0x0160, r24
}
    2ca6:	08 95       	ret

00002ca8 <InitStandalone>:
	      RunInitStandalone=False;
	      break;
	 }
  }
  */
}
    2ca8:	08 95       	ret

00002caa <DisplayQueueFIP>:


void DisplayQueueFIP(){// FIP:#1#2#3#4#5

}
    2caa:	08 95       	ret

00002cac <ShowMessage>:
	 }
}

void ShowMessage(char *Message){//Display Message on Line3
     char i;
}
    2cac:	08 95       	ret

00002cae <CalcLRC>:

char CalcLRC(char xLRC,char DataIn){
     char Result;
	 Result=xLRC^DataIn;
     return(Result);
}
    2cae:	86 27       	eor	r24, r22
    2cb0:	08 95       	ret

00002cb2 <systemEDC>:
}

void systemEDC(){//EDC Handler
     

}
    2cb2:	08 95       	ret

00002cb4 <GeniusCalc>:


char GeniusCalc(char cOption, char valA, char valB){
     char valC_H,valC_L,xValA,xValB,Result;
	 Result=0;
     switch(cOption){
    2cb4:	88 23       	and	r24, r24
    2cb6:	19 f0       	breq	.+6      	; 0x2cbe <GeniusCalc+0xa>
    2cb8:	81 30       	cpi	r24, 0x01	; 1
    2cba:	49 f5       	brne	.+82     	; 0x2d0e <GeniusCalc+0x5a>
    2cbc:	11 c0       	rjmp	.+34     	; 0x2ce0 <GeniusCalc+0x2c>
	 case G_PLUS:                  // 5 + 8 = 1 + 3 = 4
	      valC_H=(valA+valB)/10;   //  
    2cbe:	26 2f       	mov	r18, r22
    2cc0:	30 e0       	ldi	r19, 0x00	; 0
    2cc2:	24 0f       	add	r18, r20
    2cc4:	31 1d       	adc	r19, r1
		  valC_L=(valA+valB)%10;   //
	      Result=valC_H+valC_L;
    2cc6:	c9 01       	movw	r24, r18
    2cc8:	6a e0       	ldi	r22, 0x0A	; 10
    2cca:	70 e0       	ldi	r23, 0x00	; 0
    2ccc:	0e 94 4c b7 	call	0x16e98	; 0x16e98 <__divmodhi4>
    2cd0:	48 2f       	mov	r20, r24
    2cd2:	c9 01       	movw	r24, r18
    2cd4:	6a e0       	ldi	r22, 0x0A	; 10
    2cd6:	70 e0       	ldi	r23, 0x00	; 0
    2cd8:	0e 94 4c b7 	call	0x16e98	; 0x16e98 <__divmodhi4>
    2cdc:	46 0f       	add	r20, r22
    2cde:	18 c0       	rjmp	.+48     	; 0x2d10 <GeniusCalc+0x5c>
	      break;
	 case G_MULTY:                 
	      if (valA>0)xValA=valA;
    2ce0:	66 23       	and	r22, r22
    2ce2:	09 f4       	brne	.+2      	; 0x2ce6 <GeniusCalc+0x32>
    2ce4:	61 e0       	ldi	r22, 0x01	; 1
		  else xValA=1;
	      if (valB>0)xValB=valB;
    2ce6:	44 23       	and	r20, r20
    2ce8:	09 f4       	brne	.+2      	; 0x2cec <GeniusCalc+0x38>
    2cea:	41 e0       	ldi	r20, 0x01	; 1
		  else xValB=1;
	      valC_H=(xValA*xValB)/10;   //  
    2cec:	46 9f       	mul	r20, r22
    2cee:	90 01       	movw	r18, r0
    2cf0:	11 24       	eor	r1, r1
    2cf2:	c9 01       	movw	r24, r18
    2cf4:	6a e0       	ldi	r22, 0x0A	; 10
    2cf6:	70 e0       	ldi	r23, 0x00	; 0
    2cf8:	0e 94 4c b7 	call	0x16e98	; 0x16e98 <__divmodhi4>
    2cfc:	46 2f       	mov	r20, r22
		  valC_L=(xValA*xValB)%10;   //
    2cfe:	c9 01       	movw	r24, r18
    2d00:	6a e0       	ldi	r22, 0x0A	; 10
    2d02:	70 e0       	ldi	r23, 0x00	; 0
    2d04:	0e 94 4c b7 	call	0x16e98	; 0x16e98 <__divmodhi4>
    2d08:	64 2f       	mov	r22, r20
    2d0a:	48 2f       	mov	r20, r24
    2d0c:	d8 cf       	rjmp	.-80     	; 0x2cbe <GeniusCalc+0xa>
    2d0e:	40 e0       	ldi	r20, 0x00	; 0
	 case G_MINUS:
	      
	      break;
	 }
   return Result;
}
    2d10:	84 2f       	mov	r24, r20
    2d12:	08 95       	ret

00002d14 <FSubMenuAdmin>:

char FSubMenuAdmin(){
     char Result;
	 Result=MENU_DONE;
   return Result;
}
    2d14:	81 e0       	ldi	r24, 0x01	; 1
    2d16:	08 95       	ret

00002d18 <CountNoPumpSatus>:
	      break;	 
	 } 
   return Result;
}

char CountNoPumpSatus(char *strPumpStatusTotalizer){
    2d18:	ff 92       	push	r15
    2d1a:	0f 93       	push	r16
    2d1c:	1f 93       	push	r17
    2d1e:	cf 93       	push	r28
    2d20:	df 93       	push	r29
char i,Result;
     Result=0;
	 for (i=0;i<PumpCountMax;i++){
    2d22:	f0 90 5f 01 	lds	r15, 0x015F
    2d26:	ec 01       	movw	r28, r24
    2d28:	00 e0       	ldi	r16, 0x00	; 0
    2d2a:	10 e0       	ldi	r17, 0x00	; 0
    2d2c:	09 c0       	rjmp	.+18     	; 0x2d40 <CountNoPumpSatus+0x28>
	      if (strPumpStatusTotalizer[i]==GetPumpStatusLabel(PUMP_NONE)){
    2d2e:	8e e0       	ldi	r24, 0x0E	; 14
    2d30:	0e 94 90 13 	call	0x2720	; 0x2720 <GetPumpStatusLabel>
    2d34:	98 81       	ld	r25, Y
    2d36:	98 17       	cp	r25, r24
    2d38:	09 f4       	brne	.+2      	; 0x2d3c <CountNoPumpSatus+0x24>
		      Result++;		  
    2d3a:	1f 5f       	subi	r17, 0xFF	; 255
}

char CountNoPumpSatus(char *strPumpStatusTotalizer){
char i,Result;
     Result=0;
	 for (i=0;i<PumpCountMax;i++){
    2d3c:	0f 5f       	subi	r16, 0xFF	; 255
    2d3e:	21 96       	adiw	r28, 0x01	; 1
    2d40:	0f 15       	cp	r16, r15
    2d42:	a8 f3       	brcs	.-22     	; 0x2d2e <CountNoPumpSatus+0x16>
	      if (strPumpStatusTotalizer[i]==GetPumpStatusLabel(PUMP_NONE)){
		      Result++;		  
		  }	 
	 }
  return Result;
}
    2d44:	81 2f       	mov	r24, r17
    2d46:	df 91       	pop	r29
    2d48:	cf 91       	pop	r28
    2d4a:	1f 91       	pop	r17
    2d4c:	0f 91       	pop	r16
    2d4e:	ff 90       	pop	r15
    2d50:	08 95       	ret

00002d52 <FCloseDay>:
   return Result;
}

char FCloseDay(){

}
    2d52:	08 95       	ret

00002d54 <FLockPump>:
char FLockPump(){

}
    2d54:	08 95       	ret

00002d56 <FMenuSettingPassword>:
char FMenuSettingPassword(){
     char Result;
   //_menu_password();
   Result=MENU_DONE;
   return Result;
}
    2d56:	81 e0       	ldi	r24, 0x01	; 1
    2d58:	08 95       	ret

00002d5a <menu_product>:
   return Result;
}

void menu_product(){

}
    2d5a:	08 95       	ret

00002d5c <IncValue>:
            lcd_print(xPos,yPos,strLabel);
		}
	}
}

void IncValue(char *Value,char MinValue,char MaxValue){
    2d5c:	fc 01       	movw	r30, r24
     if ((*Value)<MaxValue){
    2d5e:	80 81       	ld	r24, Z
    2d60:	84 17       	cp	r24, r20
    2d62:	18 f4       	brcc	.+6      	; 0x2d6a <IncValue+0xe>
	     (*Value)++;
    2d64:	8f 5f       	subi	r24, 0xFF	; 255
    2d66:	80 83       	st	Z, r24
    2d68:	08 95       	ret
	 }else *Value=MinValue;
    2d6a:	60 83       	st	Z, r22
    2d6c:	08 95       	ret

00002d6e <DecValue>:
}

void DecValue(char *Value,char MinValue,char MaxValue){
    2d6e:	fc 01       	movw	r30, r24
     if ((*Value)>MinValue){
    2d70:	80 81       	ld	r24, Z
    2d72:	68 17       	cp	r22, r24
    2d74:	18 f4       	brcc	.+6      	; 0x2d7c <DecValue+0xe>
	     (*Value)--;
    2d76:	81 50       	subi	r24, 0x01	; 1
    2d78:	80 83       	st	Z, r24
    2d7a:	08 95       	ret
	 }else *Value=MaxValue;
    2d7c:	40 83       	st	Z, r20
    2d7e:	08 95       	ret

00002d80 <zeroIP>:
		 
		}

	}
}
void zeroIP(unsigned char Val,char *StrResult){
    2d80:	58 2f       	mov	r21, r24
    2d82:	fb 01       	movw	r30, r22
     unsigned char R,P,S;
	 if (Val>=100){
    2d84:	84 36       	cpi	r24, 0x64	; 100
    2d86:	00 f1       	brcs	.+64     	; 0x2dc8 <zeroIP+0x48>
	    R=(Val/100);
    2d88:	64 e6       	ldi	r22, 0x64	; 100
    2d8a:	0e 94 1f b7 	call	0x16e3e	; 0x16e3e <__udivmodqi4>
    2d8e:	48 2f       	mov	r20, r24
        P=((Val%100)/10);
    2d90:	85 2f       	mov	r24, r21
    2d92:	0e 94 1f b7 	call	0x16e3e	; 0x16e3e <__udivmodqi4>
    2d96:	89 2f       	mov	r24, r25
    2d98:	6a e0       	ldi	r22, 0x0A	; 10
    2d9a:	0e 94 1f b7 	call	0x16e3e	; 0x16e3e <__udivmodqi4>
		S=Val-((R*100)+(P*10)); 
        StrResult[0]='0'+R;//+(Val/100);
    2d9e:	40 5d       	subi	r20, 0xD0	; 208
    2da0:	40 83       	st	Z, r20
    2da2:	40 53       	subi	r20, 0x30	; 48
	    StrResult[1]='0'+P;//+((Val%100)/10);
    2da4:	80 5d       	subi	r24, 0xD0	; 208
    2da6:	81 83       	std	Z+1, r24	; 0x01
    2da8:	80 53       	subi	r24, 0x30	; 48
		StrResult[2]='0'+S;//+(Val-((Val/100)*100)-((Val%100)/10));
    2daa:	50 5d       	subi	r21, 0xD0	; 208
    2dac:	2c e9       	ldi	r18, 0x9C	; 156
    2dae:	3f ef       	ldi	r19, 0xFF	; 255
    2db0:	42 9f       	mul	r20, r18
    2db2:	40 2d       	mov	r20, r0
    2db4:	11 24       	eor	r1, r1
    2db6:	45 0f       	add	r20, r21
    2db8:	26 ef       	ldi	r18, 0xF6	; 246
    2dba:	3f ef       	ldi	r19, 0xFF	; 255
    2dbc:	82 9f       	mul	r24, r18
    2dbe:	80 2d       	mov	r24, r0
    2dc0:	11 24       	eor	r1, r1
    2dc2:	84 0f       	add	r24, r20
    2dc4:	82 83       	std	Z+2, r24	; 0x02
    2dc6:	10 c0       	rjmp	.+32     	; 0x2de8 <zeroIP+0x68>
		StrResult[3]=0;
		}else     
	 if ((Val>=10)&&(Val<100)){
    2dc8:	8a 50       	subi	r24, 0x0A	; 10
    2dca:	8a 35       	cpi	r24, 0x5A	; 90
    2dcc:	78 f4       	brcc	.+30     	; 0x2dec <zeroIP+0x6c>
        StrResult[0]='0';
    2dce:	80 e3       	ldi	r24, 0x30	; 48
    2dd0:	80 83       	st	Z, r24
	    StrResult[1]=('0'+(Val/10));
    2dd2:	85 2f       	mov	r24, r21
    2dd4:	6a e0       	ldi	r22, 0x0A	; 10
    2dd6:	0e 94 1f b7 	call	0x16e3e	; 0x16e3e <__udivmodqi4>
    2dda:	80 5d       	subi	r24, 0xD0	; 208
    2ddc:	81 83       	std	Z+1, r24	; 0x01
		StrResult[2]=('0'+(Val%10));
    2dde:	85 2f       	mov	r24, r21
    2de0:	0e 94 1f b7 	call	0x16e3e	; 0x16e3e <__udivmodqi4>
    2de4:	90 5d       	subi	r25, 0xD0	; 208
    2de6:	92 83       	std	Z+2, r25	; 0x02
		StrResult[3]=0;
    2de8:	13 82       	std	Z+3, r1	; 0x03
    2dea:	08 95       	ret
		}
     else
	 if (Val<10){
    2dec:	5a 30       	cpi	r21, 0x0A	; 10
    2dee:	30 f4       	brcc	.+12     	; 0x2dfc <zeroIP+0x7c>
	    StrResult[0]='0';
    2df0:	80 e3       	ldi	r24, 0x30	; 48
    2df2:	80 83       	st	Z, r24
		StrResult[1]='0';
    2df4:	81 83       	std	Z+1, r24	; 0x01
	    StrResult[2]='0'+Val;
    2df6:	50 5d       	subi	r21, 0xD0	; 208
    2df8:	52 83       	std	Z+2, r21	; 0x02
	    StrResult[3]=0;
    2dfa:	13 82       	std	Z+3, r1	; 0x03
    2dfc:	08 95       	ret

00002dfe <GetLocAccStatus>:


char GetLocAccStatus(char paramMessage57){
     char Result;
	 Result=LA_NONE;
     if (paramMessage57==MSG57_INVALID)Result=LA_INVALID;
    2dfe:	81 30       	cpi	r24, 0x01	; 1
    2e00:	29 f0       	breq	.+10     	; 0x2e0c <GetLocAccStatus+0xe>
	 else
     if (paramMessage57==MSG57_VALID)Result=LA_VALID;
    2e02:	82 30       	cpi	r24, 0x02	; 2
    2e04:	19 f0       	breq	.+6      	; 0x2e0c <GetLocAccStatus+0xe>
	 else
     if (paramMessage57==MSG57_LIMITED)Result=LA_LIMITED;
    2e06:	83 30       	cpi	r24, 0x03	; 3
    2e08:	09 f0       	breq	.+2      	; 0x2e0c <GetLocAccStatus+0xe>
    2e0a:	80 e0       	ldi	r24, 0x00	; 0
	 return Result;
}
    2e0c:	08 95       	ret

00002e0e <FTestRemZero>:
	     RemZeroLead(strTest);  
		 _uart_print(0,1,strTest);

	while (1){};
  #endif
}
    2e0e:	08 95       	ret

00002e10 <StrPosCopy>:
     nAddedSpace=(Length-srcLength)/2;
     AddSpaceLead(Source,srcLength+nAddedSpace);
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
    2e10:	cf 93       	push	r28
    2e12:	df 93       	push	r29
    2e14:	eb 01       	movw	r28, r22
    2e16:	da 01       	movw	r26, r20
    2e18:	a8 0f       	add	r26, r24
    2e1a:	b9 1f       	adc	r27, r25
    2e1c:	40 e0       	ldi	r20, 0x00	; 0
    2e1e:	50 e0       	ldi	r21, 0x00	; 0
    2e20:	07 c0       	rjmp	.+14     	; 0x2e30 <StrPosCopy+0x20>
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2e22:	fe 01       	movw	r30, r28
    2e24:	e4 0f       	add	r30, r20
    2e26:	f5 1f       	adc	r31, r21
    2e28:	8d 91       	ld	r24, X+
    2e2a:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2e2c:	4f 5f       	subi	r20, 0xFF	; 255
    2e2e:	5f 4f       	sbci	r21, 0xFF	; 255
    2e30:	42 17       	cp	r20, r18
    2e32:	53 07       	cpc	r21, r19
    2e34:	b0 f3       	brcs	.-20     	; 0x2e22 <StrPosCopy+0x12>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2e36:	c2 0f       	add	r28, r18
    2e38:	d3 1f       	adc	r29, r19
    2e3a:	18 82       	st	Y, r1
}
    2e3c:	df 91       	pop	r29
    2e3e:	cf 91       	pop	r28
    2e40:	08 95       	ret

00002e42 <StrPosPaste>:
void StrPosPaste(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
    2e42:	0f 93       	push	r16
    2e44:	1f 93       	push	r17
    2e46:	cf 93       	push	r28
    2e48:	df 93       	push	r29
    2e4a:	8c 01       	movw	r16, r24
    2e4c:	db 01       	movw	r26, r22
    2e4e:	eb 01       	movw	r28, r22
    2e50:	c4 0f       	add	r28, r20
    2e52:	d5 1f       	adc	r29, r21
    2e54:	60 e0       	ldi	r22, 0x00	; 0
    2e56:	70 e0       	ldi	r23, 0x00	; 0
    2e58:	07 c0       	rjmp	.+14     	; 0x2e68 <StrPosPaste+0x26>
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[IdxSource+i]=Source[i];
    2e5a:	f8 01       	movw	r30, r16
    2e5c:	e6 0f       	add	r30, r22
    2e5e:	f7 1f       	adc	r31, r23
    2e60:	80 81       	ld	r24, Z
    2e62:	89 93       	st	Y+, r24
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
}
void StrPosPaste(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2e64:	6f 5f       	subi	r22, 0xFF	; 255
    2e66:	7f 4f       	sbci	r23, 0xFF	; 255
    2e68:	62 17       	cp	r22, r18
    2e6a:	73 07       	cpc	r23, r19
    2e6c:	b0 f3       	brcs	.-20     	; 0x2e5a <StrPosPaste+0x18>
	    Dest[IdxSource+i]=Source[i];
	 }Dest[IdxSource+Length]=0;
    2e6e:	a4 0f       	add	r26, r20
    2e70:	b5 1f       	adc	r27, r21
    2e72:	a2 0f       	add	r26, r18
    2e74:	b3 1f       	adc	r27, r19
    2e76:	1c 92       	st	X, r1
}
    2e78:	df 91       	pop	r29
    2e7a:	cf 91       	pop	r28
    2e7c:	1f 91       	pop	r17
    2e7e:	0f 91       	pop	r16
    2e80:	08 95       	ret

00002e82 <CharPosCopy>:
char CharPosCopy(char *Source, unsigned int IdxSource){
    2e82:	fb 01       	movw	r30, r22
    2e84:	e8 0f       	add	r30, r24
    2e86:	f9 1f       	adc	r31, r25
     char Result;
     Result=Source[IdxSource];
	 return Result;
}
    2e88:	80 81       	ld	r24, Z
    2e8a:	08 95       	ret

00002e8c <procMessage00>:
*/
char procMessage00(){
     char Result,strSend[10];
	 Result=MSG00_NACK;
	 //Message57
	 if((rcv_trans[0]==0x01)&&(transLength==MSG00_LENGTH)){
    2e8c:	80 91 f5 0a 	lds	r24, 0x0AF5
    2e90:	81 30       	cpi	r24, 0x01	; 1
    2e92:	51 f4       	brne	.+20     	; 0x2ea8 <procMessage00+0x1c>
    2e94:	80 91 9e 01 	lds	r24, 0x019E
    2e98:	90 91 9f 01 	lds	r25, 0x019F
    2e9c:	8f 97       	sbiw	r24, 0x2f	; 47
    2e9e:	21 f4       	brne	.+8      	; 0x2ea8 <procMessage00+0x1c>
	     //Reply
		 Result=(CharPosCopy(rcv_trans,37)-'0');
    2ea0:	80 91 1a 0b 	lds	r24, 0x0B1A
    2ea4:	80 53       	subi	r24, 0x30	; 48
    2ea6:	08 95       	ret
    2ea8:	80 e0       	ldi	r24, 0x00	; 0
		 //sprintf(strSend,"R=%d",Result);
		 //_uart_print(0,1,strSend);
		 //*/
		 }
     return Result;
}
    2eaa:	08 95       	ret

00002eac <procMessage09>:
	    Dest[IdxSource+i]=Source[i];
	 }Dest[IdxSource+Length]=0;
}
char CharPosCopy(char *Source, unsigned int IdxSource){
     char Result;
     Result=Source[IdxSource];
    2eac:	90 91 1c 0b 	lds	r25, 0x0B1C
    2eb0:	20 e0       	ldi	r18, 0x00	; 0
    2eb2:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2eb4:	f9 01       	movw	r30, r18
    2eb6:	e9 56       	subi	r30, 0x69	; 105
    2eb8:	f5 4f       	sbci	r31, 0xF5	; 245
    2eba:	d9 01       	movw	r26, r18
    2ebc:	ab 50       	subi	r26, 0x0B	; 11
    2ebe:	b5 4f       	sbci	r27, 0xF5	; 245
    2ec0:	97 96       	adiw	r26, 0x27	; 39
    2ec2:	8c 91       	ld	r24, X
    2ec4:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2ec6:	2f 5f       	subi	r18, 0xFF	; 255
    2ec8:	3f 4f       	sbci	r19, 0xFF	; 255
    2eca:	24 31       	cpi	r18, 0x14	; 20
    2ecc:	31 05       	cpc	r19, r1
    2ece:	91 f7       	brne	.-28     	; 0x2eb4 <procMessage09+0x8>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2ed0:	10 92 ab 0a 	sts	0x0AAB, r1
    2ed4:	20 e0       	ldi	r18, 0x00	; 0
    2ed6:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2ed8:	f9 01       	movw	r30, r18
    2eda:	ea 57       	subi	r30, 0x7A	; 122
    2edc:	f6 4f       	sbci	r31, 0xF6	; 246
    2ede:	d9 01       	movw	r26, r18
    2ee0:	ab 50       	subi	r26, 0x0B	; 11
    2ee2:	b5 4f       	sbci	r27, 0xF5	; 245
    2ee4:	db 96       	adiw	r26, 0x3b	; 59
    2ee6:	8c 91       	ld	r24, X
    2ee8:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2eea:	2f 5f       	subi	r18, 0xFF	; 255
    2eec:	3f 4f       	sbci	r19, 0xFF	; 255
    2eee:	24 31       	cpi	r18, 0x14	; 20
    2ef0:	31 05       	cpc	r19, r1
    2ef2:	91 f7       	brne	.-28     	; 0x2ed8 <procMessage09+0x2c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2ef4:	10 92 9a 09 	sts	0x099A, r1
    2ef8:	20 e0       	ldi	r18, 0x00	; 0
    2efa:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2efc:	f9 01       	movw	r30, r18
    2efe:	ef 5d       	subi	r30, 0xDF	; 223
    2f00:	f5 4f       	sbci	r31, 0xF5	; 245
    2f02:	d9 01       	movw	r26, r18
    2f04:	ac 5b       	subi	r26, 0xBC	; 188
    2f06:	b4 4f       	sbci	r27, 0xF4	; 244
    2f08:	8c 91       	ld	r24, X
    2f0a:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2f0c:	2f 5f       	subi	r18, 0xFF	; 255
    2f0e:	3f 4f       	sbci	r19, 0xFF	; 255
    2f10:	24 31       	cpi	r18, 0x14	; 20
    2f12:	31 05       	cpc	r19, r1
    2f14:	99 f7       	brne	.-26     	; 0x2efc <procMessage09+0x50>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2f16:	10 92 35 0a 	sts	0x0A35, r1
    2f1a:	20 e0       	ldi	r18, 0x00	; 0
    2f1c:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2f1e:	f9 01       	movw	r30, r18
    2f20:	ef 54       	subi	r30, 0x4F	; 79
    2f22:	f2 4f       	sbci	r31, 0xF2	; 242
    2f24:	d9 01       	movw	r26, r18
    2f26:	a8 5a       	subi	r26, 0xA8	; 168
    2f28:	b4 4f       	sbci	r27, 0xF4	; 244
    2f2a:	8c 91       	ld	r24, X
    2f2c:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2f2e:	2f 5f       	subi	r18, 0xFF	; 255
    2f30:	3f 4f       	sbci	r19, 0xFF	; 255
    2f32:	24 31       	cpi	r18, 0x14	; 20
    2f34:	31 05       	cpc	r19, r1
    2f36:	99 f7       	brne	.-26     	; 0x2f1e <procMessage09+0x72>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2f38:	10 92 c5 0d 	sts	0x0DC5, r1
       StrPosCopy(rcv_trans,strFreeMessageLine1,39,20);
       StrPosCopy(rcv_trans,strFreeMessageLine2,59,20);
       StrPosCopy(rcv_trans,strFreeMessageLine3,79,20);
       StrPosCopy(rcv_trans,strFreeMessageLine4,99,20);
	 return Result;
}
    2f3c:	89 2f       	mov	r24, r25
    2f3e:	80 53       	subi	r24, 0x30	; 48
    2f40:	08 95       	ret

00002f42 <procMessage23>:
		 eeprom_write_block((const void*)&strBankName, (void*)&DefBankName[i], 11);
	 }
	 return Result;
}

char procMessage23(){
    2f42:	20 e0       	ldi	r18, 0x00	; 0
    2f44:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2f46:	f9 01       	movw	r30, r18
    2f48:	ef 59       	subi	r30, 0x9F	; 159
    2f4a:	f2 4f       	sbci	r31, 0xF2	; 242
    2f4c:	d9 01       	movw	r26, r18
    2f4e:	ab 50       	subi	r26, 0x0B	; 11
    2f50:	b5 4f       	sbci	r27, 0xF5	; 245
    2f52:	95 96       	adiw	r26, 0x25	; 37
    2f54:	8c 91       	ld	r24, X
    2f56:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2f58:	2f 5f       	subi	r18, 0xFF	; 255
    2f5a:	3f 4f       	sbci	r19, 0xFF	; 255
    2f5c:	24 31       	cpi	r18, 0x14	; 20
    2f5e:	31 05       	cpc	r19, r1
    2f60:	91 f7       	brne	.-28     	; 0x2f46 <procMessage23+0x4>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2f62:	10 92 75 0d 	sts	0x0D75, r1
    2f66:	20 e0       	ldi	r18, 0x00	; 0
    2f68:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2f6a:	f9 01       	movw	r30, r18
    2f6c:	ec 5f       	subi	r30, 0xFC	; 252
    2f6e:	fa 4f       	sbci	r31, 0xFA	; 250
    2f70:	d9 01       	movw	r26, r18
    2f72:	ab 50       	subi	r26, 0x0B	; 11
    2f74:	b5 4f       	sbci	r27, 0xF5	; 245
    2f76:	d9 96       	adiw	r26, 0x39	; 57
    2f78:	8c 91       	ld	r24, X
    2f7a:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2f7c:	2f 5f       	subi	r18, 0xFF	; 255
    2f7e:	3f 4f       	sbci	r19, 0xFF	; 255
    2f80:	2e 31       	cpi	r18, 0x1E	; 30
    2f82:	31 05       	cpc	r19, r1
    2f84:	91 f7       	brne	.-28     	; 0x2f6a <procMessage23+0x28>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2f86:	10 92 22 05 	sts	0x0522, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2f8a:	80 91 4c 0b 	lds	r24, 0x0B4C
    2f8e:	80 93 6a 05 	sts	0x056A, r24
	 }Dest[Length]=0;
    2f92:	10 92 6b 05 	sts	0x056B, r1
    2f96:	20 e0       	ldi	r18, 0x00	; 0
    2f98:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2f9a:	f9 01       	movw	r30, r18
    2f9c:	e6 5c       	subi	r30, 0xC6	; 198
    2f9e:	f5 4f       	sbci	r31, 0xF5	; 245
    2fa0:	d9 01       	movw	r26, r18
    2fa2:	a3 5b       	subi	r26, 0xB3	; 179
    2fa4:	b4 4f       	sbci	r27, 0xF4	; 244
    2fa6:	8c 91       	ld	r24, X
    2fa8:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2faa:	2f 5f       	subi	r18, 0xFF	; 255
    2fac:	3f 4f       	sbci	r19, 0xFF	; 255
    2fae:	28 30       	cpi	r18, 0x08	; 8
    2fb0:	31 05       	cpc	r19, r1
    2fb2:	99 f7       	brne	.-26     	; 0x2f9a <procMessage23+0x58>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2fb4:	10 92 42 0a 	sts	0x0A42, r1
    2fb8:	20 e0       	ldi	r18, 0x00	; 0
    2fba:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2fbc:	f9 01       	movw	r30, r18
    2fbe:	e2 5a       	subi	r30, 0xA2	; 162
    2fc0:	fa 4f       	sbci	r31, 0xFA	; 250
    2fc2:	d9 01       	movw	r26, r18
    2fc4:	ab 5a       	subi	r26, 0xAB	; 171
    2fc6:	b4 4f       	sbci	r27, 0xF4	; 244
    2fc8:	8c 91       	ld	r24, X
    2fca:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2fcc:	2f 5f       	subi	r18, 0xFF	; 255
    2fce:	3f 4f       	sbci	r19, 0xFF	; 255
    2fd0:	2a 30       	cpi	r18, 0x0A	; 10
    2fd2:	31 05       	cpc	r19, r1
    2fd4:	99 f7       	brne	.-26     	; 0x2fbc <procMessage23+0x7a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2fd6:	10 92 68 05 	sts	0x0568, r1
    2fda:	20 e0       	ldi	r18, 0x00	; 0
    2fdc:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    2fde:	f9 01       	movw	r30, r18
    2fe0:	e8 53       	subi	r30, 0x38	; 56
    2fe2:	f2 4f       	sbci	r31, 0xF2	; 242
    2fe4:	d9 01       	movw	r26, r18
    2fe6:	a1 5a       	subi	r26, 0xA1	; 161
    2fe8:	b4 4f       	sbci	r27, 0xF4	; 244
    2fea:	8c 91       	ld	r24, X
    2fec:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    2fee:	2f 5f       	subi	r18, 0xFF	; 255
    2ff0:	3f 4f       	sbci	r19, 0xFF	; 255
    2ff2:	2a 30       	cpi	r18, 0x0A	; 10
    2ff4:	31 05       	cpc	r19, r1
    2ff6:	99 f7       	brne	.-26     	; 0x2fde <procMessage23+0x9c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    2ff8:	10 92 d2 0d 	sts	0x0DD2, r1
    2ffc:	20 e0       	ldi	r18, 0x00	; 0
    2ffe:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    3000:	f9 01       	movw	r30, r18
    3002:	e9 56       	subi	r30, 0x69	; 105
    3004:	f2 4f       	sbci	r31, 0xF2	; 242
    3006:	d9 01       	movw	r26, r18
    3008:	a7 59       	subi	r26, 0x97	; 151
    300a:	b4 4f       	sbci	r27, 0xF4	; 244
    300c:	8c 91       	ld	r24, X
    300e:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    3010:	2f 5f       	subi	r18, 0xFF	; 255
    3012:	3f 4f       	sbci	r19, 0xFF	; 255
    3014:	23 31       	cpi	r18, 0x13	; 19
    3016:	31 05       	cpc	r19, r1
    3018:	99 f7       	brne	.-26     	; 0x3000 <procMessage23+0xbe>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    301a:	10 92 aa 0d 	sts	0x0DAA, r1
    301e:	20 e0       	ldi	r18, 0x00	; 0
    3020:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    3022:	f9 01       	movw	r30, r18
    3024:	e5 57       	subi	r30, 0x75	; 117
    3026:	f2 4f       	sbci	r31, 0xF2	; 242
    3028:	d9 01       	movw	r26, r18
    302a:	a4 58       	subi	r26, 0x84	; 132
    302c:	b4 4f       	sbci	r27, 0xF4	; 244
    302e:	8c 91       	ld	r24, X
    3030:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    3032:	2f 5f       	subi	r18, 0xFF	; 255
    3034:	3f 4f       	sbci	r19, 0xFF	; 255
    3036:	27 30       	cpi	r18, 0x07	; 7
    3038:	31 05       	cpc	r19, r1
    303a:	99 f7       	brne	.-26     	; 0x3022 <procMessage23+0xe0>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    303c:	10 92 92 0d 	sts	0x0D92, r1
    3040:	20 e0       	ldi	r18, 0x00	; 0
    3042:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    3044:	f9 01       	movw	r30, r18
    3046:	e5 56       	subi	r30, 0x65	; 101
    3048:	fb 4f       	sbci	r31, 0xFB	; 251
    304a:	d9 01       	movw	r26, r18
    304c:	ad 57       	subi	r26, 0x7D	; 125
    304e:	b4 4f       	sbci	r27, 0xF4	; 244
    3050:	8c 91       	ld	r24, X
    3052:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    3054:	2f 5f       	subi	r18, 0xFF	; 255
    3056:	3f 4f       	sbci	r19, 0xFF	; 255
    3058:	24 30       	cpi	r18, 0x04	; 4
    305a:	31 05       	cpc	r19, r1
    305c:	99 f7       	brne	.-26     	; 0x3044 <procMessage23+0x102>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    305e:	10 92 9f 04 	sts	0x049F, r1
     StrPosCopy(rcv_trans,strLoyCurrMonConsumeV,106,10);
     StrPosCopy(rcv_trans,strDateTime,116,19);
     StrPosCopy(rcv_trans,strAmount,135,7);
     StrPosCopy(rcv_trans,strGainPoints,142,4);
     return Result;
}
    3062:	80 e0       	ldi	r24, 0x00	; 0
    3064:	08 95       	ret

00003066 <procMessage81>:
_uart_print(0,1,strCardID);
*/	
     return Result;
}

char procMessage81(){// Result: HFCS0000
    3066:	cf 93       	push	r28
    3068:	df 93       	push	r29
     char Result=0,PrintCopy=0;//
	 char lcdteks[20];
	 //PrintHeader
     if ((CharPosCopy(rcv_trans,37))=='Y') Result=(Result|(1<<7));
    306a:	80 91 1a 0b 	lds	r24, 0x0B1A
    306e:	89 35       	cpi	r24, 0x59	; 89
    3070:	11 f4       	brne	.+4      	; 0x3076 <procMessage81+0x10>
    3072:	90 e8       	ldi	r25, 0x80	; 128
    3074:	01 c0       	rjmp	.+2      	; 0x3078 <procMessage81+0x12>
    3076:	90 e0       	ldi	r25, 0x00	; 0
     //PrintFooter
	 if ((CharPosCopy(rcv_trans,38))=='Y') Result=(Result|(1<<6));
    3078:	80 91 1b 0b 	lds	r24, 0x0B1B
    307c:	89 35       	cpi	r24, 0x59	; 89
    307e:	09 f4       	brne	.+2      	; 0x3082 <procMessage81+0x1c>
    3080:	90 64       	ori	r25, 0x40	; 64
	 //PaperCut
     if ((CharPosCopy(rcv_trans,39))=='Y') Result=(Result|(1<<5));
    3082:	80 91 1c 0b 	lds	r24, 0x0B1C
    3086:	89 35       	cpi	r24, 0x59	; 89
    3088:	09 f4       	brne	.+2      	; 0x308c <procMessage81+0x26>
    308a:	90 62       	ori	r25, 0x20	; 32
	 //Scrool
	 Result=(Result|(1<<4));
    308c:	90 61       	ori	r25, 0x10	; 16

	 //Copies
	 PrintCopy=(CharPosCopy(rcv_trans,40)-'0');
    308e:	80 91 1d 0b 	lds	r24, 0x0B1D
    3092:	80 53       	subi	r24, 0x30	; 48
     if (PrintCopy<=16) Result=Result|PrintCopy;
    3094:	81 31       	cpi	r24, 0x11	; 17
    3096:	08 f4       	brcc	.+2      	; 0x309a <procMessage81+0x34>
    3098:	98 2b       	or	r25, r24
	 //Spooling
     StrPosCopy(rcv_trans,PrintBuffer,44,LengthMessage81);
    309a:	c0 91 a0 01 	lds	r28, 0x01A0
    309e:	d0 91 a1 01 	lds	r29, 0x01A1
    30a2:	20 e0       	ldi	r18, 0x00	; 0
    30a4:	30 e0       	ldi	r19, 0x00	; 0
    30a6:	0b c0       	rjmp	.+22     	; 0x30be <procMessage81+0x58>
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    30a8:	f9 01       	movw	r30, r18
    30aa:	e1 53       	subi	r30, 0x31	; 49
    30ac:	fa 4f       	sbci	r31, 0xFA	; 250
    30ae:	d9 01       	movw	r26, r18
    30b0:	ab 50       	subi	r26, 0x0B	; 11
    30b2:	b5 4f       	sbci	r27, 0xF5	; 245
    30b4:	9c 96       	adiw	r26, 0x2c	; 44
    30b6:	8c 91       	ld	r24, X
    30b8:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    30ba:	2f 5f       	subi	r18, 0xFF	; 255
    30bc:	3f 4f       	sbci	r19, 0xFF	; 255
    30be:	2c 17       	cp	r18, r28
    30c0:	3d 07       	cpc	r19, r29
    30c2:	90 f3       	brcs	.-28     	; 0x30a8 <procMessage81+0x42>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    30c4:	c1 53       	subi	r28, 0x31	; 49
    30c6:	da 4f       	sbci	r29, 0xFA	; 250
    30c8:	18 82       	st	Y, r1
	 //sprintf(lcdteks,"cmdPrint:%d ",Result);
     //_uart_print(0,1,lcdteks);

	 //while(1){};
	 return Result;
}
    30ca:	89 2f       	mov	r24, r25
    30cc:	df 91       	pop	r29
    30ce:	cf 91       	pop	r28
    30d0:	08 95       	ret

000030d2 <FillChar>:
	 if(CutType== 1) { _uart(_COM_PRINTER, 1, 0x6D);}
	 if(CutType== 2) {_uart(_COM_PRINTER, 1, 0x69);}

}

void FillChar(char *strMemory, unsigned int Length,char data){
    30d2:	20 e0       	ldi	r18, 0x00	; 0
    30d4:	30 e0       	ldi	r19, 0x00	; 0
    30d6:	06 c0       	rjmp	.+12     	; 0x30e4 <FillChar+0x12>
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    30d8:	fc 01       	movw	r30, r24
    30da:	e2 0f       	add	r30, r18
    30dc:	f3 1f       	adc	r31, r19
    30de:	40 83       	st	Z, r20

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    30e0:	2f 5f       	subi	r18, 0xFF	; 255
    30e2:	3f 4f       	sbci	r19, 0xFF	; 255
    30e4:	26 17       	cp	r18, r22
    30e6:	37 07       	cpc	r19, r23
    30e8:	b8 f3       	brcs	.-18     	; 0x30d8 <FillChar+0x6>
	     strMemory[i]=data;
	 }
}
    30ea:	08 95       	ret

000030ec <ProcMessage91>:

void ProcMessage91(){
    30ec:	20 e0       	ldi	r18, 0x00	; 0
    30ee:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    30f0:	f9 01       	movw	r30, r18
    30f2:	ef 59       	subi	r30, 0x9F	; 159
    30f4:	f1 4f       	sbci	r31, 0xF1	; 241
    30f6:	d9 01       	movw	r26, r18
    30f8:	ab 50       	subi	r26, 0x0B	; 11
    30fa:	b5 4f       	sbci	r27, 0xF5	; 245
    30fc:	95 96       	adiw	r26, 0x25	; 37
    30fe:	8c 91       	ld	r24, X
    3100:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    3102:	2f 5f       	subi	r18, 0xFF	; 255
    3104:	3f 4f       	sbci	r19, 0xFF	; 255
    3106:	26 30       	cpi	r18, 0x06	; 6
    3108:	31 05       	cpc	r19, r1
    310a:	91 f7       	brne	.-28     	; 0x30f0 <ProcMessage91+0x4>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    310c:	10 92 67 0e 	sts	0x0E67, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    3110:	80 91 20 0b 	lds	r24, 0x0B20
    3114:	80 93 9c 09 	sts	0x099C, r24
    3118:	80 91 21 0b 	lds	r24, 0x0B21
    311c:	80 93 9d 09 	sts	0x099D, r24
	 }Dest[Length]=0;
    3120:	10 92 9e 09 	sts	0x099E, r1
    3124:	20 e0       	ldi	r18, 0x00	; 0
    3126:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    3128:	f9 01       	movw	r30, r18
    312a:	ef 5e       	subi	r30, 0xEF	; 239
    312c:	f5 4f       	sbci	r31, 0xF5	; 245
    312e:	d9 01       	movw	r26, r18
    3130:	ab 50       	subi	r26, 0x0B	; 11
    3132:	b5 4f       	sbci	r27, 0xF5	; 245
    3134:	9d 96       	adiw	r26, 0x2d	; 45
    3136:	8c 91       	ld	r24, X
    3138:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    313a:	2f 5f       	subi	r18, 0xFF	; 255
    313c:	3f 4f       	sbci	r19, 0xFF	; 255
    313e:	2f 30       	cpi	r18, 0x0F	; 15
    3140:	31 05       	cpc	r19, r1
    3142:	91 f7       	brne	.-28     	; 0x3128 <ProcMessage91+0x3c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    3144:	10 92 20 0a 	sts	0x0A20, r1
    3148:	20 e0       	ldi	r18, 0x00	; 0
    314a:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    314c:	f9 01       	movw	r30, r18
    314e:	ef 57       	subi	r30, 0x7F	; 127
    3150:	f8 4f       	sbci	r31, 0xF8	; 248
    3152:	d9 01       	movw	r26, r18
    3154:	ab 50       	subi	r26, 0x0B	; 11
    3156:	b5 4f       	sbci	r27, 0xF5	; 245
    3158:	dc 96       	adiw	r26, 0x3c	; 60
    315a:	8c 91       	ld	r24, X
    315c:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    315e:	2f 5f       	subi	r18, 0xFF	; 255
    3160:	3f 4f       	sbci	r19, 0xFF	; 255
    3162:	26 30       	cpi	r18, 0x06	; 6
    3164:	31 05       	cpc	r19, r1
    3166:	91 f7       	brne	.-28     	; 0x314c <ProcMessage91+0x60>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    3168:	10 92 87 07 	sts	0x0787, r1
    316c:	20 e0       	ldi	r18, 0x00	; 0
    316e:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    3170:	f9 01       	movw	r30, r18
    3172:	eb 5a       	subi	r30, 0xAB	; 171
    3174:	fa 4f       	sbci	r31, 0xFA	; 250
    3176:	d9 01       	movw	r26, r18
    3178:	a9 5c       	subi	r26, 0xC9	; 201
    317a:	b4 4f       	sbci	r27, 0xF4	; 244
    317c:	8c 91       	ld	r24, X
    317e:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    3180:	2f 5f       	subi	r18, 0xFF	; 255
    3182:	3f 4f       	sbci	r19, 0xFF	; 255
    3184:	28 30       	cpi	r18, 0x08	; 8
    3186:	31 05       	cpc	r19, r1
    3188:	99 f7       	brne	.-26     	; 0x3170 <ProcMessage91+0x84>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    318a:	10 92 5d 05 	sts	0x055D, r1
    318e:	20 e0       	ldi	r18, 0x00	; 0
    3190:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    3192:	f9 01       	movw	r30, r18
    3194:	e5 57       	subi	r30, 0x75	; 117
    3196:	f2 4f       	sbci	r31, 0xF2	; 242
    3198:	d9 01       	movw	r26, r18
    319a:	a1 5c       	subi	r26, 0xC1	; 193
    319c:	b4 4f       	sbci	r27, 0xF4	; 244
    319e:	8c 91       	ld	r24, X
    31a0:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    31a2:	2f 5f       	subi	r18, 0xFF	; 255
    31a4:	3f 4f       	sbci	r19, 0xFF	; 255
    31a6:	28 30       	cpi	r18, 0x08	; 8
    31a8:	31 05       	cpc	r19, r1
    31aa:	99 f7       	brne	.-26     	; 0x3192 <ProcMessage91+0xa6>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    31ac:	10 92 93 0d 	sts	0x0D93, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    31b0:	80 91 47 0b 	lds	r24, 0x0B47
    31b4:	80 93 6a 05 	sts	0x056A, r24
	 }Dest[Length]=0;
    31b8:	10 92 6b 05 	sts	0x056B, r1
    31bc:	20 e0       	ldi	r18, 0x00	; 0
    31be:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    31c0:	f9 01       	movw	r30, r18
    31c2:	e4 52       	subi	r30, 0x24	; 36
    31c4:	fb 4f       	sbci	r31, 0xFB	; 251
    31c6:	d9 01       	movw	r26, r18
    31c8:	a8 5b       	subi	r26, 0xB8	; 184
    31ca:	b4 4f       	sbci	r27, 0xF4	; 244
    31cc:	8c 91       	ld	r24, X
    31ce:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    31d0:	2f 5f       	subi	r18, 0xFF	; 255
    31d2:	3f 4f       	sbci	r19, 0xFF	; 255
    31d4:	29 30       	cpi	r18, 0x09	; 9
    31d6:	31 05       	cpc	r19, r1
    31d8:	99 f7       	brne	.-26     	; 0x31c0 <ProcMessage91+0xd4>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    31da:	10 92 e5 04 	sts	0x04E5, r1
     StrPosCopy(rcv_trans,strPrice,60,6);
     StrPosCopy(rcv_trans,strVolume,66,8);
     StrPosCopy(rcv_trans,strAmount,74,8); 
	 StrPosCopy(rcv_trans,strStatus,82,1);
     StrPosCopy(rcv_trans,strSurcharge,83,9);    
}
    31de:	08 95       	ret

000031e0 <IdentifyMessage>:
        //sprintf_P(strSerial,PSTR("RFID:%s"),strRFID);
        //_uart_print(0,1,strSerial);
	 }
}

void IdentifyMessage(char STX,unsigned int Length){
    31e0:	1f 93       	push	r17
   if (STX==0x01){
    31e2:	81 30       	cpi	r24, 0x01	; 1
    31e4:	09 f0       	breq	.+2      	; 0x31e8 <IdentifyMessage+0x8>
    31e6:	5f c0       	rjmp	.+190    	; 0x32a6 <IdentifyMessage+0xc6>
	    if ((Length==MSG00_LENGTH)||(MsgCode==0)) IsMessage00=True;//47
    31e8:	6f 32       	cpi	r22, 0x2F	; 47
    31ea:	71 05       	cpc	r23, r1
    31ec:	21 f0       	breq	.+8      	; 0x31f6 <IdentifyMessage+0x16>
    31ee:	80 91 24 01 	lds	r24, 0x0124
    31f2:	88 23       	and	r24, r24
    31f4:	21 f4       	brne	.+8      	; 0x31fe <IdentifyMessage+0x1e>
    31f6:	81 e0       	ldi	r24, 0x01	; 1
    31f8:	80 93 b5 01 	sts	0x01B5, r24
    31fc:	4a c0       	rjmp	.+148    	; 0x3292 <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG09_LENGTH)||(MsgCode==9)) IsMessage09=True;//615
    31fe:	6c 36       	cpi	r22, 0x6C	; 108
    3200:	71 05       	cpc	r23, r1
    3202:	11 f0       	breq	.+4      	; 0x3208 <IdentifyMessage+0x28>
    3204:	89 30       	cpi	r24, 0x09	; 9
    3206:	21 f4       	brne	.+8      	; 0x3210 <IdentifyMessage+0x30>
    3208:	81 e0       	ldi	r24, 0x01	; 1
    320a:	80 93 ba 01 	sts	0x01BA, r24
    320e:	41 c0       	rjmp	.+130    	; 0x3292 <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG11_LENGTH)||(MsgCode==11)) IsMessage11=True;//615
    3210:	92 e0       	ldi	r25, 0x02	; 2
    3212:	67 36       	cpi	r22, 0x67	; 103
    3214:	79 07       	cpc	r23, r25
    3216:	11 f0       	breq	.+4      	; 0x321c <IdentifyMessage+0x3c>
    3218:	8b 30       	cpi	r24, 0x0B	; 11
    321a:	21 f4       	brne	.+8      	; 0x3224 <IdentifyMessage+0x44>
    321c:	81 e0       	ldi	r24, 0x01	; 1
    321e:	80 93 b7 01 	sts	0x01B7, r24
    3222:	37 c0       	rjmp	.+110    	; 0x3292 <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG23_LENGTH)||(MsgCode==23)) IsMessage23=True;//145
    3224:	61 39       	cpi	r22, 0x91	; 145
    3226:	71 05       	cpc	r23, r1
    3228:	11 f0       	breq	.+4      	; 0x322e <IdentifyMessage+0x4e>
    322a:	87 31       	cpi	r24, 0x17	; 23
    322c:	21 f4       	brne	.+8      	; 0x3236 <IdentifyMessage+0x56>
    322e:	81 e0       	ldi	r24, 0x01	; 1
    3230:	80 93 b9 01 	sts	0x01B9, r24
    3234:	2e c0       	rjmp	.+92     	; 0x3292 <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG57_LENGTH)||(MsgCode==57)) IsMessage57=True;//230
    3236:	66 3e       	cpi	r22, 0xE6	; 230
    3238:	71 05       	cpc	r23, r1
    323a:	11 f0       	breq	.+4      	; 0x3240 <IdentifyMessage+0x60>
    323c:	89 33       	cpi	r24, 0x39	; 57
    323e:	21 f4       	brne	.+8      	; 0x3248 <IdentifyMessage+0x68>
    3240:	81 e0       	ldi	r24, 0x01	; 1
    3242:	80 93 bc 01 	sts	0x01BC, r24
    3246:	25 c0       	rjmp	.+74     	; 0x3292 <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG99_LENGTH)||(MsgCode==99)) IsMessage99=True;//378
    3248:	91 e0       	ldi	r25, 0x01	; 1
    324a:	68 39       	cpi	r22, 0x98	; 152
    324c:	79 07       	cpc	r23, r25
    324e:	11 f0       	breq	.+4      	; 0x3254 <IdentifyMessage+0x74>
    3250:	83 36       	cpi	r24, 0x63	; 99
    3252:	21 f4       	brne	.+8      	; 0x325c <IdentifyMessage+0x7c>
    3254:	81 e0       	ldi	r24, 0x01	; 1
    3256:	80 93 b6 01 	sts	0x01B6, r24
    325a:	1b c0       	rjmp	.+54     	; 0x3292 <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG81_LENGTH)||(MsgCode==81)) IsMessage81=True;//426
    325c:	91 e0       	ldi	r25, 0x01	; 1
    325e:	66 3b       	cpi	r22, 0xB6	; 182
    3260:	79 07       	cpc	r23, r25
    3262:	11 f0       	breq	.+4      	; 0x3268 <IdentifyMessage+0x88>
    3264:	81 35       	cpi	r24, 0x51	; 81
    3266:	21 f4       	brne	.+8      	; 0x3270 <IdentifyMessage+0x90>
    3268:	81 e0       	ldi	r24, 0x01	; 1
    326a:	80 93 bd 01 	sts	0x01BD, r24
    326e:	11 c0       	rjmp	.+34     	; 0x3292 <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG91_LENGTH)||(MsgCode==91)) IsMessage91=True;//426
    3270:	6c 35       	cpi	r22, 0x5C	; 92
    3272:	71 05       	cpc	r23, r1
    3274:	11 f0       	breq	.+4      	; 0x327a <IdentifyMessage+0x9a>
    3276:	8b 35       	cpi	r24, 0x5B	; 91
    3278:	21 f4       	brne	.+8      	; 0x3282 <IdentifyMessage+0xa2>
    327a:	81 e0       	ldi	r24, 0x01	; 1
    327c:	80 93 be 01 	sts	0x01BE, r24
    3280:	08 c0       	rjmp	.+16     	; 0x3292 <IdentifyMessage+0xb2>
		else
	    if ((Length==MSG21_LENGTH)||(MsgCode==21)) IsMessage21=True;//426
    3282:	66 35       	cpi	r22, 0x56	; 86
    3284:	71 05       	cpc	r23, r1
    3286:	11 f0       	breq	.+4      	; 0x328c <IdentifyMessage+0xac>
    3288:	85 31       	cpi	r24, 0x15	; 21
    328a:	19 f4       	brne	.+6      	; 0x3292 <IdentifyMessage+0xb2>
    328c:	81 e0       	ldi	r24, 0x01	; 1
    328e:	80 93 b8 01 	sts	0x01B8, r24

        //EDC AdvanZ Respond
		if (IsMessage91==True){
    3292:	10 91 be 01 	lds	r17, 0x01BE
    3296:	11 30       	cpi	r17, 0x01	; 1
    3298:	31 f4       	brne	.+12     	; 0x32a6 <IdentifyMessage+0xc6>
		    IsMessage91=False;
    329a:	10 92 be 01 	sts	0x01BE, r1
		    ProcMessage91();
    329e:	0e 94 76 18 	call	0x30ec	; 0x30ec <ProcMessage91>
			IsSendMessageEDC=True;
    32a2:	10 93 ae 01 	sts	0x01AE, r17
		  }

//	  sprintf(SerialSend,"Length:%i",Length);	 
//	  _uart_print(1,0,SerialSend);
	 }
}
    32a6:	1f 91       	pop	r17
    32a8:	08 95       	ret

000032aa <Tab>:

	  }
     return Result;     
}

void Tab(char *sTab, char nTab){
    32aa:	fc 01       	movw	r30, r24
    32ac:	dc 01       	movw	r26, r24
    32ae:	80 e0       	ldi	r24, 0x00	; 0
     char i;
	 for(i=0;i<nTab;i++){
	     sTab[i]=' ';
    32b0:	90 e2       	ldi	r25, 0x20	; 32
    32b2:	02 c0       	rjmp	.+4      	; 0x32b8 <Tab+0xe>
    32b4:	9d 93       	st	X+, r25
     return Result;     
}

void Tab(char *sTab, char nTab){
     char i;
	 for(i=0;i<nTab;i++){
    32b6:	8f 5f       	subi	r24, 0xFF	; 255
    32b8:	86 17       	cp	r24, r22
    32ba:	e0 f3       	brcs	.-8      	; 0x32b4 <Tab+0xa>
	     sTab[i]=' ';
	 }sTab[nTab]=0;
    32bc:	e6 0f       	add	r30, r22
    32be:	f1 1d       	adc	r31, r1
    32c0:	10 82       	st	Z, r1
}
    32c2:	08 95       	ret

000032c4 <_f_inttostr>:
}



//Old Function
void _f_inttostr(char* __string, unsigned long __value){
    32c4:	6f 92       	push	r6
    32c6:	7f 92       	push	r7
    32c8:	8f 92       	push	r8
    32ca:	9f 92       	push	r9
    32cc:	af 92       	push	r10
    32ce:	bf 92       	push	r11
    32d0:	cf 92       	push	r12
    32d2:	df 92       	push	r13
    32d4:	ef 92       	push	r14
    32d6:	ff 92       	push	r15
    32d8:	0f 93       	push	r16
    32da:	1f 93       	push	r17
    32dc:	cf 93       	push	r28
    32de:	df 93       	push	r29
    32e0:	ec 01       	movw	r28, r24
	char			__flag = 0, __i = 0, __count;
	unsigned long	__num, __devider = 1000000000;
	int				__tmp;

	if(__value == 0){
    32e2:	41 15       	cp	r20, r1
    32e4:	51 05       	cpc	r21, r1
    32e6:	61 05       	cpc	r22, r1
    32e8:	71 05       	cpc	r23, r1
    32ea:	21 f4       	brne	.+8      	; 0x32f4 <_f_inttostr+0x30>
		__string[0] = '0';
    32ec:	80 e3       	ldi	r24, 0x30	; 48
    32ee:	88 83       	st	Y, r24
		__string[1] = '\0';
    32f0:	19 82       	std	Y+1, r1	; 0x01
    32f2:	48 c0       	rjmp	.+144    	; 0x3384 <_f_inttostr+0xc0>
		return;
    32f4:	4a 01       	movw	r8, r20
    32f6:	5b 01       	movw	r10, r22
    32f8:	10 e0       	ldi	r17, 0x00	; 0
    32fa:	00 e0       	ldi	r16, 0x00	; 0
    32fc:	77 24       	eor	r7, r7
    32fe:	c1 2c       	mov	r12, r1
    3300:	9a ec       	ldi	r25, 0xCA	; 202
    3302:	d9 2e       	mov	r13, r25
    3304:	9a e9       	ldi	r25, 0x9A	; 154
    3306:	e9 2e       	mov	r14, r25
    3308:	9b e3       	ldi	r25, 0x3B	; 59
    330a:	f9 2e       	mov	r15, r25
			if(!__flag)
				__flag = 1;
		}
		else
			if(__flag)
				__string[__i++] = 0x30;
    330c:	80 e3       	ldi	r24, 0x30	; 48
    330e:	68 2e       	mov	r6, r24
		return;
	}

	__num = __value;
	for(__count = 0; __count < 10; __count++){
		if(__num >= __devider){
    3310:	8c 14       	cp	r8, r12
    3312:	9d 04       	cpc	r9, r13
    3314:	ae 04       	cpc	r10, r14
    3316:	bf 04       	cpc	r11, r15
    3318:	d0 f0       	brcs	.+52     	; 0x334e <_f_inttostr+0x8a>
			__tmp = (int)(__num / __devider);
    331a:	c5 01       	movw	r24, r10
    331c:	b4 01       	movw	r22, r8
    331e:	a7 01       	movw	r20, r14
    3320:	96 01       	movw	r18, r12
    3322:	0e 94 5f b7 	call	0x16ebe	; 0x16ebe <__udivmodsi4>
    3326:	12 2f       	mov	r17, r18
			__num = __num % __devider;
    3328:	c5 01       	movw	r24, r10
    332a:	b4 01       	movw	r22, r8
    332c:	a7 01       	movw	r20, r14
    332e:	96 01       	movw	r18, r12
    3330:	0e 94 5f b7 	call	0x16ebe	; 0x16ebe <__udivmodsi4>
    3334:	ac 01       	movw	r20, r24
    3336:	cb 01       	movw	r24, r22
    3338:	da 01       	movw	r26, r20
    333a:	4c 01       	movw	r8, r24
    333c:	5d 01       	movw	r10, r26
			__string[__i++] = __tmp + 0x30;
    333e:	fe 01       	movw	r30, r28
    3340:	e0 0f       	add	r30, r16
    3342:	f1 1d       	adc	r31, r1
    3344:	10 5d       	subi	r17, 0xD0	; 208
    3346:	10 83       	st	Z, r17
    3348:	0f 5f       	subi	r16, 0xFF	; 255
    334a:	11 e0       	ldi	r17, 0x01	; 1
    334c:	07 c0       	rjmp	.+14     	; 0x335c <_f_inttostr+0x98>
			if(!__flag)
				__flag = 1;
		}
		else
			if(__flag)
    334e:	11 23       	and	r17, r17
    3350:	29 f0       	breq	.+10     	; 0x335c <_f_inttostr+0x98>
				__string[__i++] = 0x30;
    3352:	fe 01       	movw	r30, r28
    3354:	e0 0f       	add	r30, r16
    3356:	f1 1d       	adc	r31, r1
    3358:	60 82       	st	Z, r6
    335a:	0f 5f       	subi	r16, 0xFF	; 255
		__string[1] = '\0';
		return;
	}

	__num = __value;
	for(__count = 0; __count < 10; __count++){
    335c:	73 94       	inc	r7
    335e:	8a e0       	ldi	r24, 0x0A	; 10
    3360:	78 16       	cp	r7, r24
    3362:	69 f0       	breq	.+26     	; 0x337e <_f_inttostr+0xba>
				__flag = 1;
		}
		else
			if(__flag)
				__string[__i++] = 0x30;
		__devider = __devider / 10;
    3364:	c7 01       	movw	r24, r14
    3366:	b6 01       	movw	r22, r12
    3368:	2a e0       	ldi	r18, 0x0A	; 10
    336a:	30 e0       	ldi	r19, 0x00	; 0
    336c:	40 e0       	ldi	r20, 0x00	; 0
    336e:	50 e0       	ldi	r21, 0x00	; 0
    3370:	0e 94 5f b7 	call	0x16ebe	; 0x16ebe <__udivmodsi4>
    3374:	c9 01       	movw	r24, r18
    3376:	da 01       	movw	r26, r20
    3378:	6c 01       	movw	r12, r24
    337a:	7d 01       	movw	r14, r26
    337c:	c9 cf       	rjmp	.-110    	; 0x3310 <_f_inttostr+0x4c>
	}
	__string[__i] = '\0';
    337e:	c0 0f       	add	r28, r16
    3380:	d1 1d       	adc	r29, r1
    3382:	18 82       	st	Y, r1
}
    3384:	df 91       	pop	r29
    3386:	cf 91       	pop	r28
    3388:	1f 91       	pop	r17
    338a:	0f 91       	pop	r16
    338c:	ff 90       	pop	r15
    338e:	ef 90       	pop	r14
    3390:	df 90       	pop	r13
    3392:	cf 90       	pop	r12
    3394:	bf 90       	pop	r11
    3396:	af 90       	pop	r10
    3398:	9f 90       	pop	r9
    339a:	8f 90       	pop	r8
    339c:	7f 90       	pop	r7
    339e:	6f 90       	pop	r6
    33a0:	08 95       	ret

000033a2 <StrToRaw>:
			  }
		  }
	 }
}
                                       //12byte->6Byte         0 1 2 3  
void StrToRaw(char *Source,char *Dest){//Source: "1234567890AB"
    33a2:	dc 01       	movw	r26, r24
    33a4:	20 e0       	ldi	r18, 0x00	; 0
    33a6:	30 e0       	ldi	r19, 0x00	; 0
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    33a8:	9c 91       	ld	r25, X
    33aa:	90 53       	subi	r25, 0x30	; 48
    33ac:	9a 30       	cpi	r25, 0x0A	; 10
    33ae:	08 f0       	brcs	.+2      	; 0x33b2 <StrToRaw+0x10>
    33b0:	90 e0       	ldi	r25, 0x00	; 0
	 char xRaw=0;
	 for (i=0;i<6;i++){
	      xA=Ord(Source[(2*i)]);
		  xB=(0x0F&Ord(Source[(2*i)+1]));
	      xRaw=((xA<<4) | xB);
	      Dest[i]=xRaw;
    33b2:	11 96       	adiw	r26, 0x01	; 1
    33b4:	8c 91       	ld	r24, X
    33b6:	11 97       	sbiw	r26, 0x01	; 1
    33b8:	80 53       	subi	r24, 0x30	; 48
    33ba:	8a 30       	cpi	r24, 0x0A	; 10
    33bc:	08 f0       	brcs	.+2      	; 0x33c0 <StrToRaw+0x1e>
    33be:	80 e0       	ldi	r24, 0x00	; 0
    33c0:	fb 01       	movw	r30, r22
    33c2:	e2 0f       	add	r30, r18
    33c4:	f3 1f       	adc	r31, r19
    33c6:	8f 70       	andi	r24, 0x0F	; 15
    33c8:	92 95       	swap	r25
    33ca:	90 7f       	andi	r25, 0xF0	; 240
    33cc:	98 2b       	or	r25, r24
    33ce:	90 83       	st	Z, r25
    33d0:	2f 5f       	subi	r18, 0xFF	; 255
    33d2:	3f 4f       	sbci	r19, 0xFF	; 255
    33d4:	12 96       	adiw	r26, 0x02	; 2
}
                                       //12byte->6Byte         0 1 2 3  
void StrToRaw(char *Source,char *Dest){//Source: "1234567890AB"
     char i,xA,xB;                //Dest  :  12345678 
	 char xRaw=0;
	 for (i=0;i<6;i++){
    33d6:	26 30       	cpi	r18, 0x06	; 6
    33d8:	31 05       	cpc	r19, r1
    33da:	31 f7       	brne	.-52     	; 0x33a8 <StrToRaw+0x6>
	      xA=Ord(Source[(2*i)]);
		  xB=(0x0F&Ord(Source[(2*i)+1]));
	      xRaw=((xA<<4) | xB);
	      Dest[i]=xRaw;
	 }	      
}
    33dc:	08 95       	ret

000033de <RawToStr>:
void RawToStr(char *Source,char *Dest){//Source:   1234567890AB
    33de:	cf 93       	push	r28
    33e0:	df 93       	push	r29
    33e2:	eb 01       	movw	r28, r22
    33e4:	db 01       	movw	r26, r22
    33e6:	20 e0       	ldi	r18, 0x00	; 0
    33e8:	30 e0       	ldi	r19, 0x00	; 0
     unsigned char i,xRaw,cA,cB;               //Dest  :  "12345678" 
	 for (i=0;i<6;i++){
	      cA=Chr(Source[i]>>4);
    33ea:	fc 01       	movw	r30, r24
    33ec:	e2 0f       	add	r30, r18
    33ee:	f3 1f       	adc	r31, r19
    33f0:	e0 81       	ld	r30, Z
    33f2:	4e 2f       	mov	r20, r30
    33f4:	42 95       	swap	r20
    33f6:	4f 70       	andi	r20, 0x0F	; 15
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    33f8:	4a 30       	cpi	r20, 0x0A	; 10
    33fa:	10 f0       	brcs	.+4      	; 0x3400 <RawToStr+0x22>
    33fc:	40 e3       	ldi	r20, 0x30	; 48
    33fe:	01 c0       	rjmp	.+2      	; 0x3402 <RawToStr+0x24>
	    Result='0'+X;
    3400:	40 5d       	subi	r20, 0xD0	; 208
}
void RawToStr(char *Source,char *Dest){//Source:   1234567890AB
     unsigned char i,xRaw,cA,cB;               //Dest  :  "12345678" 
	 for (i=0;i<6;i++){
	      cA=Chr(Source[i]>>4);
	      cB=Chr(Source[i]&0x0F);
    3402:	ef 70       	andi	r30, 0x0F	; 15
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    3404:	ea 30       	cpi	r30, 0x0A	; 10
    3406:	10 f0       	brcs	.+4      	; 0x340c <RawToStr+0x2e>
    3408:	e0 e3       	ldi	r30, 0x30	; 48
    340a:	01 c0       	rjmp	.+2      	; 0x340e <RawToStr+0x30>
	    Result='0'+X;
    340c:	e0 5d       	subi	r30, 0xD0	; 208
void RawToStr(char *Source,char *Dest){//Source:   1234567890AB
     unsigned char i,xRaw,cA,cB;               //Dest  :  "12345678" 
	 for (i=0;i<6;i++){
	      cA=Chr(Source[i]>>4);
	      cB=Chr(Source[i]&0x0F);
          Dest[2*i]=cA;
    340e:	4c 93       	st	X, r20
          Dest[(2*i)+1]=cB;
    3410:	11 96       	adiw	r26, 0x01	; 1
    3412:	ec 93       	st	X, r30
    3414:	11 97       	sbiw	r26, 0x01	; 1
    3416:	2f 5f       	subi	r18, 0xFF	; 255
    3418:	3f 4f       	sbci	r19, 0xFF	; 255
    341a:	12 96       	adiw	r26, 0x02	; 2
	      Dest[i]=xRaw;
	 }	      
}
void RawToStr(char *Source,char *Dest){//Source:   1234567890AB
     unsigned char i,xRaw,cA,cB;               //Dest  :  "12345678" 
	 for (i=0;i<6;i++){
    341c:	26 30       	cpi	r18, 0x06	; 6
    341e:	31 05       	cpc	r19, r1
    3420:	21 f7       	brne	.-56     	; 0x33ea <RawToStr+0xc>
	      cA=Chr(Source[i]>>4);
	      cB=Chr(Source[i]&0x0F);
          Dest[2*i]=cA;
          Dest[(2*i)+1]=cB;
	 }Dest[12]=0;
    3422:	1c 86       	std	Y+12, r1	; 0x0c
}
    3424:	df 91       	pop	r29
    3426:	cf 91       	pop	r28
    3428:	08 95       	ret

0000342a <CalcMinus>:
}

char CalcMinus(char A, char B){
     signed char xC;//,xA,xB;
	 char Result;
	 if (A>=B) xC=((A-'0')-(B-'0'));
    342a:	86 17       	cp	r24, r22
    342c:	08 f4       	brcc	.+2      	; 0x3430 <CalcMinus+0x6>
	 else xC=10+((A-'0')-(B-'0'));//
    342e:	86 5f       	subi	r24, 0xF6	; 246
    3430:	86 1b       	sub	r24, r22
	 Result='0'+xC;
  return Result;
}
    3432:	80 5d       	subi	r24, 0xD0	; 208
    3434:	08 95       	ret

00003436 <CalcPlus>:

char CalcPlus(char A, char B){
    3436:	80 56       	subi	r24, 0x60	; 96
    3438:	86 0f       	add	r24, r22
    343a:	6a e0       	ldi	r22, 0x0A	; 10
    343c:	0e 94 2b b7 	call	0x16e56	; 0x16e56 <__divmodqi4>
     signed char xA,xB,xC;
	 char Result;
	 xC=((A-'0')+(B-'0'));
     Result='0'+(xC%10);  
   return Result;
}
    3440:	89 2f       	mov	r24, r25
    3442:	80 5d       	subi	r24, 0xD0	; 208
    3444:	08 95       	ret

00003446 <Chr>:
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    3446:	8a 30       	cpi	r24, 0x0A	; 10
    3448:	10 f0       	brcs	.+4      	; 0x344e <Chr+0x8>
    344a:	80 e3       	ldi	r24, 0x30	; 48
    344c:	08 95       	ret
	    Result='0'+X;
    344e:	80 5d       	subi	r24, 0xD0	; 208
	 }
	return Result;
}
    3450:	08 95       	ret

00003452 <Ord>:
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    3452:	80 53       	subi	r24, 0x30	; 48
    3454:	8a 30       	cpi	r24, 0x0A	; 10
    3456:	08 f0       	brcs	.+2      	; 0x345a <Ord+0x8>
    3458:	80 e0       	ldi	r24, 0x00	; 0
	    Result=c-'0';
	 }
	return Result;
}
    345a:	08 95       	ret

0000345c <GetTabSpace>:
	     StrCalc(TPLUS,prevSeg,currSeg,prevSeg);
	 }
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
    345c:	48 2f       	mov	r20, r24
    345e:	fb 01       	movw	r30, r22
     char i,nTab;
	 if (TabLength>0){
    3460:	18 16       	cp	r1, r24
    3462:	64 f4       	brge	.+24     	; 0x347c <GetTabSpace+0x20>
		 nTab=TabLength;//%40;
    3464:	56 2f       	mov	r21, r22
    3466:	db 01       	movw	r26, r22
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    3468:	90 e2       	ldi	r25, 0x20	; 32
    346a:	9d 93       	st	X+, r25

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    346c:	8a 2f       	mov	r24, r26
    346e:	85 1b       	sub	r24, r21
    3470:	84 17       	cp	r24, r20
    3472:	d8 f3       	brcs	.-10     	; 0x346a <GetTabSpace+0xe>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    3474:	e4 0f       	add	r30, r20
    3476:	f1 1d       	adc	r31, r1
    3478:	10 82       	st	Z, r1
    347a:	08 95       	ret
     }else{
	 strTab[0]=' ';
    347c:	80 e2       	ldi	r24, 0x20	; 32
    347e:	80 83       	st	Z, r24
	 strTab[1]=0;
    3480:	11 82       	std	Z+1, r1	; 0x01
    3482:	08 95       	ret

00003484 <GetBorderValue>:

}

char GetBorderValue(char BoderType){
     char Result=0;
	 switch (BoderType){
    3484:	86 30       	cpi	r24, 0x06	; 6
    3486:	51 f1       	breq	.+84     	; 0x34dc <GetBorderValue+0x58>
    3488:	87 30       	cpi	r24, 0x07	; 7
    348a:	70 f4       	brcc	.+28     	; 0x34a8 <GetBorderValue+0x24>
    348c:	83 30       	cpi	r24, 0x03	; 3
    348e:	11 f1       	breq	.+68     	; 0x34d4 <GetBorderValue+0x50>
    3490:	84 30       	cpi	r24, 0x04	; 4
    3492:	28 f4       	brcc	.+10     	; 0x349e <GetBorderValue+0x1a>
    3494:	81 30       	cpi	r24, 0x01	; 1
    3496:	c1 f0       	breq	.+48     	; 0x34c8 <GetBorderValue+0x44>
    3498:	82 30       	cpi	r24, 0x02	; 2
    349a:	c1 f4       	brne	.+48     	; 0x34cc <GetBorderValue+0x48>
    349c:	19 c0       	rjmp	.+50     	; 0x34d0 <GetBorderValue+0x4c>
    349e:	84 30       	cpi	r24, 0x04	; 4
    34a0:	d9 f0       	breq	.+54     	; 0x34d8 <GetBorderValue+0x54>
    34a2:	85 30       	cpi	r24, 0x05	; 5
    34a4:	99 f4       	brne	.+38     	; 0x34cc <GetBorderValue+0x48>
    34a6:	22 c0       	rjmp	.+68     	; 0x34ec <GetBorderValue+0x68>
    34a8:	89 30       	cpi	r24, 0x09	; 9
    34aa:	f1 f0       	breq	.+60     	; 0x34e8 <GetBorderValue+0x64>
    34ac:	8a 30       	cpi	r24, 0x0A	; 10
    34ae:	28 f4       	brcc	.+10     	; 0x34ba <GetBorderValue+0x36>
    34b0:	87 30       	cpi	r24, 0x07	; 7
    34b2:	b1 f0       	breq	.+44     	; 0x34e0 <GetBorderValue+0x5c>
    34b4:	88 30       	cpi	r24, 0x08	; 8
    34b6:	51 f4       	brne	.+20     	; 0x34cc <GetBorderValue+0x48>
    34b8:	15 c0       	rjmp	.+42     	; 0x34e4 <GetBorderValue+0x60>
    34ba:	8b 30       	cpi	r24, 0x0B	; 11
    34bc:	d9 f0       	breq	.+54     	; 0x34f4 <GetBorderValue+0x70>
    34be:	8b 30       	cpi	r24, 0x0B	; 11
    34c0:	b8 f0       	brcs	.+46     	; 0x34f0 <GetBorderValue+0x6c>
    34c2:	8c 30       	cpi	r24, 0x0C	; 12
    34c4:	19 f4       	brne	.+6      	; 0x34cc <GetBorderValue+0x48>
    34c6:	18 c0       	rjmp	.+48     	; 0x34f8 <GetBorderValue+0x74>
    34c8:	8a ed       	ldi	r24, 0xDA	; 218
    34ca:	08 95       	ret
    34cc:	80 e0       	ldi	r24, 0x00	; 0
    34ce:	08 95       	ret
    34d0:	82 ec       	ldi	r24, 0xC2	; 194
    34d2:	08 95       	ret
		case btTopLeft: 
		     Result=0xDA;
			 break;
		case btTopCenter: 
		     Result=0xC2;
			 break;
    34d4:	8f eb       	ldi	r24, 0xBF	; 191
    34d6:	08 95       	ret
		case btTopRight:
		     Result=0xBF;		 
			 break;
    34d8:	83 ec       	ldi	r24, 0xC3	; 195
    34da:	08 95       	ret
		case btMiddleLeft: 
			 Result=0xC3;
			 break;
    34dc:	84 eb       	ldi	r24, 0xB4	; 180
    34de:	08 95       	ret
		case btMiddleRight: 
			 Result=0xB4;
			 break;
    34e0:	80 ec       	ldi	r24, 0xC0	; 192
    34e2:	08 95       	ret
		case btBottomLeft: 
		     Result=0xC0;
			 break;
    34e4:	81 ec       	ldi	r24, 0xC1	; 193
    34e6:	08 95       	ret
		case btBottomCenter: 
			 Result=0xC1;
			 break;
    34e8:	89 ed       	ldi	r24, 0xD9	; 217
    34ea:	08 95       	ret
		case btBottomRight: 
			 Result=0xD9;
			 break;
    34ec:	85 ec       	ldi	r24, 0xC5	; 197
    34ee:	08 95       	ret
        case btMiddleCenter:
		     Result=0xC5;
		     break;
    34f0:	83 eb       	ldi	r24, 0xB3	; 179
    34f2:	08 95       	ret
		case btVertical: 
			 Result=0xB3;
			 break;
    34f4:	84 ec       	ldi	r24, 0xC4	; 196
    34f6:	08 95       	ret
		case btHorizontal:
			 Result=0xC4;
			 break;	 
    34f8:	8d e0       	ldi	r24, 0x0D	; 13
        case btNewLine:
		     Result=0x0D;
			 break;	 
	 }
   return Result;
}
    34fa:	08 95       	ret

000034fc <InserBorder>:

void InserBorder(char BorderType, char *strPrnBuffer,char nLength,unsigned int *Pos){
    34fc:	bf 92       	push	r11
    34fe:	cf 92       	push	r12
    3500:	df 92       	push	r13
    3502:	ef 92       	push	r14
    3504:	ff 92       	push	r15
    3506:	0f 93       	push	r16
    3508:	1f 93       	push	r17
    350a:	cf 93       	push	r28
    350c:	df 93       	push	r29
    350e:	b8 2e       	mov	r11, r24
    3510:	8b 01       	movw	r16, r22
    3512:	e4 2e       	mov	r14, r20
    3514:	69 01       	movw	r12, r18
     char i;//,BorderValue=0;
	 unsigned int StartPos,iPos=0;
	 
	 iPos=*Pos;
    3516:	f9 01       	movw	r30, r18
    3518:	c0 81       	ld	r28, Z
    351a:	d1 81       	ldd	r29, Z+1	; 0x01
    351c:	0c 0f       	add	r16, r28
    351e:	1d 1f       	adc	r17, r29
    3520:	ff 24       	eor	r15, r15
    3522:	07 c0       	rjmp	.+14     	; 0x3532 <InserBorder+0x36>
	 StartPos=iPos;
	 for (i=0;i<nLength;i++){
	      strPrnBuffer[iPos]=GetBorderValue(BorderType);
    3524:	8b 2d       	mov	r24, r11
    3526:	0e 94 42 1a 	call	0x3484	; 0x3484 <GetBorderValue>
    352a:	f8 01       	movw	r30, r16
    352c:	81 93       	st	Z+, r24
    352e:	8f 01       	movw	r16, r30
     char i;//,BorderValue=0;
	 unsigned int StartPos,iPos=0;
	 
	 iPos=*Pos;
	 StartPos=iPos;
	 for (i=0;i<nLength;i++){
    3530:	f3 94       	inc	r15
    3532:	fe 14       	cp	r15, r14
    3534:	b8 f3       	brcs	.-18     	; 0x3524 <InserBorder+0x28>
	 //for (i=0;i<nLength;i++){
	 //     if (strPrnBuffer[i+StartPos]!=GetBorderValue(BorderType)){
//		      strPrnBuffer[i+StartPos]=GetBorderValue(BorderType);
//		  }
//	 }
     *Pos=iPos;
    3536:	ce 0d       	add	r28, r14
    3538:	d1 1d       	adc	r29, r1
    353a:	f6 01       	movw	r30, r12
    353c:	d1 83       	std	Z+1, r29	; 0x01
    353e:	c0 83       	st	Z, r28
}
    3540:	df 91       	pop	r29
    3542:	cf 91       	pop	r28
    3544:	1f 91       	pop	r17
    3546:	0f 91       	pop	r16
    3548:	ff 90       	pop	r15
    354a:	ef 90       	pop	r14
    354c:	df 90       	pop	r13
    354e:	cf 90       	pop	r12
    3550:	bf 90       	pop	r11
    3552:	08 95       	ret

00003554 <GeniusSendPumpStatus>:
   return Result;
}

void GeniusSendPumpStatus(char iPumpID){
     
}
    3554:	08 95       	ret

00003556 <GeniusSendStopPump>:
void GeniusSendStopPump(char iPumpID){
}
    3556:	08 95       	ret

00003558 <GeniusSendResumePump>:
void GeniusSendResumePump(char iPumpID){
}
    3558:	08 95       	ret

0000355a <GeniusSendPumpPreset>:
void GeniusSendPumpPreset(char iPumpID){
}
    355a:	08 95       	ret

0000355c <SetIncomingTransStatus>:
	 sprintf_P(strSend,PSTR("%d"),cSum);
	 _uart_print(1,1,strSend);	 
}


void SetIncomingTransStatus(char iPumpID,char xTransStatus){
    355c:	e8 2f       	mov	r30, r24
char iStatus,xMaskA,xMaskB,xMaskC,xPumpID;
	 xPumpID=(iPumpID&0x0F);
    355e:	28 2f       	mov	r18, r24
    3560:	2f 70       	andi	r18, 0x0F	; 15
     iStatus=IncomingTransaction[xPumpID/8];
    3562:	82 2f       	mov	r24, r18
    3564:	86 95       	lsr	r24
    3566:	86 95       	lsr	r24
    3568:	86 95       	lsr	r24
    356a:	a8 2f       	mov	r26, r24
    356c:	b0 e0       	ldi	r27, 0x00	; 0
    356e:	a1 55       	subi	r26, 0x51	; 81
    3570:	b2 4f       	sbci	r27, 0xF2	; 242
    3572:	4c 91       	ld	r20, X
	 if (xTransStatus==TS_NEW){
    3574:	62 30       	cpi	r22, 0x02	; 2
    3576:	59 f4       	brne	.+22     	; 0x358e <SetIncomingTransStatus+0x32>
	     iStatus=(iStatus|(1<<(xPumpID%8)));	 
    3578:	27 70       	andi	r18, 0x07	; 7
    357a:	81 e0       	ldi	r24, 0x01	; 1
    357c:	90 e0       	ldi	r25, 0x00	; 0
    357e:	02 c0       	rjmp	.+4      	; 0x3584 <SetIncomingTransStatus+0x28>
    3580:	88 0f       	add	r24, r24
    3582:	99 1f       	adc	r25, r25
    3584:	2a 95       	dec	r18
    3586:	e2 f7       	brpl	.-8      	; 0x3580 <SetIncomingTransStatus+0x24>
    3588:	48 2b       	or	r20, r24
		 IncomingTransaction[xPumpID/8]=iStatus;
    358a:	4c 93       	st	X, r20
    358c:	08 95       	ret
	 }else if (xTransStatus==TS_OLD){
    358e:	63 30       	cpi	r22, 0x03	; 3
    3590:	b1 f4       	brne	.+44     	; 0x35be <SetIncomingTransStatus+0x62>
		 xMaskA=(0xFE<<(xPumpID%8));
    3592:	27 70       	andi	r18, 0x07	; 7
    3594:	8e ef       	ldi	r24, 0xFE	; 254
    3596:	90 e0       	ldi	r25, 0x00	; 0
    3598:	01 c0       	rjmp	.+2      	; 0x359c <SetIncomingTransStatus+0x40>
    359a:	88 0f       	add	r24, r24
    359c:	2a 95       	dec	r18
    359e:	ea f7       	brpl	.-6      	; 0x359a <SetIncomingTransStatus+0x3e>
		 xMaskB=(~xMaskA)>>1;
		 xMaskC=xMaskA|xMaskB;
		 iStatus=iStatus&xMaskC;
		 IncomingTransaction[iPumpID/8]=iStatus;
    35a0:	e6 95       	lsr	r30
    35a2:	e6 95       	lsr	r30
    35a4:	e6 95       	lsr	r30
    35a6:	f0 e0       	ldi	r31, 0x00	; 0
    35a8:	e1 55       	subi	r30, 0x51	; 81
    35aa:	f2 4f       	sbci	r31, 0xF2	; 242
    35ac:	28 2f       	mov	r18, r24
    35ae:	30 e0       	ldi	r19, 0x00	; 0
    35b0:	20 95       	com	r18
    35b2:	30 95       	com	r19
    35b4:	35 95       	asr	r19
    35b6:	27 95       	ror	r18
    35b8:	82 2b       	or	r24, r18
    35ba:	84 23       	and	r24, r20
    35bc:	80 83       	st	Z, r24
    35be:	08 95       	ret

000035c0 <GetIncomingTransStatus>:
	 }
}
char GetIncomingTransStatus(char iPumpID){
     char xPumpID,Result;
	 xPumpID=(iPumpID&0x0F);
    35c0:	8f 70       	andi	r24, 0x0F	; 15
	 Result=TS_NONE;
     if((IncomingTransaction[xPumpID/8]>>(xPumpID%8))==1){
    35c2:	e8 2f       	mov	r30, r24
    35c4:	e6 95       	lsr	r30
    35c6:	e6 95       	lsr	r30
    35c8:	e6 95       	lsr	r30
    35ca:	f0 e0       	ldi	r31, 0x00	; 0
    35cc:	e1 55       	subi	r30, 0x51	; 81
    35ce:	f2 4f       	sbci	r31, 0xF2	; 242
    35d0:	90 81       	ld	r25, Z
    35d2:	29 2f       	mov	r18, r25
    35d4:	30 e0       	ldi	r19, 0x00	; 0
    35d6:	87 70       	andi	r24, 0x07	; 7
    35d8:	02 c0       	rjmp	.+4      	; 0x35de <GetIncomingTransStatus+0x1e>
    35da:	35 95       	asr	r19
    35dc:	27 95       	ror	r18
    35de:	8a 95       	dec	r24
    35e0:	e2 f7       	brpl	.-8      	; 0x35da <GetIncomingTransStatus+0x1a>
    35e2:	21 30       	cpi	r18, 0x01	; 1
    35e4:	31 05       	cpc	r19, r1
    35e6:	11 f4       	brne	.+4      	; 0x35ec <GetIncomingTransStatus+0x2c>
    35e8:	82 e0       	ldi	r24, 0x02	; 2
    35ea:	08 95       	ret
	     Result=TS_NEW;
	 }else
     if((IncomingTransaction[xPumpID/8]>>(xPumpID%8))==0){
    35ec:	23 2b       	or	r18, r19
    35ee:	11 f4       	brne	.+4      	; 0x35f4 <GetIncomingTransStatus+0x34>
    35f0:	83 e0       	ldi	r24, 0x03	; 3
    35f2:	08 95       	ret
    35f4:	80 e0       	ldi	r24, 0x00	; 0
	     Result=TS_OLD;
	 }
   return Result;
}
    35f6:	08 95       	ret

000035f8 <SetDispenser>:
		  }
	      break;
	 }
}

void SetDispenser(char DispType){
    35f8:	df 93       	push	r29
    35fa:	cf 93       	push	r28
    35fc:	00 d0       	rcall	.+0      	; 0x35fe <SetDispenser+0x6>
    35fe:	00 d0       	rcall	.+0      	; 0x3600 <SetDispenser+0x8>
    3600:	0f 92       	push	r0
    3602:	cd b7       	in	r28, 0x3d	; 61
    3604:	de b7       	in	r29, 0x3e	; 62
    3606:	98 2f       	mov	r25, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    3608:	e1 99       	sbic	0x1c, 1	; 28
    360a:	fe cf       	rjmp	.-4      	; 0x3608 <SetDispenser+0x10>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    360c:	27 e3       	ldi	r18, 0x37	; 55
    360e:	31 e0       	ldi	r19, 0x01	; 1
    3610:	3f bb       	out	0x1f, r19	; 31
    3612:	2e bb       	out	0x1e, r18	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    3614:	e0 9a       	sbi	0x1c, 0	; 28
    3616:	8d b3       	in	r24, 0x1d	; 29
     char CurrentDispenser;
	 char i,DecimalSetting[5];
     CurrentDispenser=eeprom_read_byte(&DefDispenserBrand);
	 if (CurrentDispenser!=DispType){
    3618:	89 17       	cp	r24, r25
    361a:	51 f0       	breq	.+20     	; 0x3630 <SetDispenser+0x38>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    361c:	e1 99       	sbic	0x1c, 1	; 28
    361e:	fe cf       	rjmp	.-4      	; 0x361c <SetDispenser+0x24>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3620:	3f bb       	out	0x1f, r19	; 31
    3622:	2e bb       	out	0x1e, r18	; 30
#endif
    EEDR = __value;
    3624:	9d bb       	out	0x1d, r25	; 29

    __asm__ __volatile__ (
    3626:	0f b6       	in	r0, 0x3f	; 63
    3628:	f8 94       	cli
    362a:	e2 9a       	sbi	0x1c, 2	; 28
    362c:	e1 9a       	sbi	0x1c, 1	; 28
    362e:	0f be       	out	0x3f, r0	; 63
	     eeprom_write_byte(&DefDispenserBrand,DispType);
	 }
     //Apply Setting for Pump respectively
	 switch(DispType){
    3630:	91 30       	cpi	r25, 0x01	; 1
    3632:	19 f0       	breq	.+6      	; 0x363a <SetDispenser+0x42>
    3634:	92 30       	cpi	r25, 0x02	; 2
    3636:	71 f4       	brne	.+28     	; 0x3654 <SetDispenser+0x5c>
    3638:	08 c0       	rjmp	.+16     	; 0x364a <SetDispenser+0x52>
	 case ST_GILBARCO:
          DecimalSetting[0]=0;//Price
    363a:	19 82       	std	Y+1, r1	; 0x01
		  DecimalSetting[1]=3;//Volume
    363c:	83 e0       	ldi	r24, 0x03	; 3
    363e:	8a 83       	std	Y+2, r24	; 0x02
		  DecimalSetting[2]=0;//Money
    3640:	1b 82       	std	Y+3, r1	; 0x03
		  DecimalSetting[3]=2;//TotalVolume
    3642:	82 e0       	ldi	r24, 0x02	; 2
    3644:	8c 83       	std	Y+4, r24	; 0x04
		  DecimalSetting[4]=0;//TotalMoney 
    3646:	1d 82       	std	Y+5, r1	; 0x05
    3648:	05 c0       	rjmp	.+10     	; 0x3654 <SetDispenser+0x5c>
	      break;
	 case ST_WAYNE_DART:
          DecimalSetting[0]=0;//Price
    364a:	19 82       	std	Y+1, r1	; 0x01
		  DecimalSetting[1]=2;//Volume
    364c:	9a 83       	std	Y+2, r25	; 0x02
		  DecimalSetting[2]=0;//Money
    364e:	1b 82       	std	Y+3, r1	; 0x03
		  DecimalSetting[3]=2;//TotalVolume
    3650:	9c 83       	std	Y+4, r25	; 0x04
		  DecimalSetting[4]=2;//TotalMoney 
    3652:	9d 83       	std	Y+5, r25	; 0x05
    3654:	29 e3       	ldi	r18, 0x39	; 57
    3656:	30 e0       	ldi	r19, 0x00	; 0
    3658:	fe 01       	movw	r30, r28
    365a:	31 96       	adiw	r30, 0x01	; 1
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    365c:	e1 99       	sbic	0x1c, 1	; 28
    365e:	fe cf       	rjmp	.-4      	; 0x365c <SetDispenser+0x64>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3660:	3f bb       	out	0x1f, r19	; 31
    3662:	2e bb       	out	0x1e, r18	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    3664:	e0 9a       	sbi	0x1c, 0	; 28
    3666:	8d b3       	in	r24, 0x1d	; 29
	      break;	 
	 }
	 //ApplyChanges
     for (i=0;i<5;i++){
	     if (eeprom_read_byte(&DefDecimalPrice+i)!=DecimalSetting[i]){
    3668:	90 81       	ld	r25, Z
    366a:	89 17       	cp	r24, r25
    366c:	51 f0       	breq	.+20     	; 0x3682 <SetDispenser+0x8a>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    366e:	e1 99       	sbic	0x1c, 1	; 28
    3670:	fe cf       	rjmp	.-4      	; 0x366e <SetDispenser+0x76>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3672:	3f bb       	out	0x1f, r19	; 31
    3674:	2e bb       	out	0x1e, r18	; 30
#endif
    EEDR = __value;
    3676:	9d bb       	out	0x1d, r25	; 29

    __asm__ __volatile__ (
    3678:	0f b6       	in	r0, 0x3f	; 63
    367a:	f8 94       	cli
    367c:	e2 9a       	sbi	0x1c, 2	; 28
    367e:	e1 9a       	sbi	0x1c, 1	; 28
    3680:	0f be       	out	0x3f, r0	; 63
    3682:	2f 5f       	subi	r18, 0xFF	; 255
    3684:	3f 4f       	sbci	r19, 0xFF	; 255
    3686:	31 96       	adiw	r30, 0x01	; 1
		  DecimalSetting[3]=2;//TotalVolume
		  DecimalSetting[4]=2;//TotalMoney 
	      break;	 
	 }
	 //ApplyChanges
     for (i=0;i<5;i++){
    3688:	80 e0       	ldi	r24, 0x00	; 0
    368a:	2e 33       	cpi	r18, 0x3E	; 62
    368c:	38 07       	cpc	r19, r24
    368e:	31 f7       	brne	.-52     	; 0x365c <SetDispenser+0x64>
	     if (eeprom_read_byte(&DefDecimalPrice+i)!=DecimalSetting[i]){
		     eeprom_write_byte(&DefDecimalPrice+i,DecimalSetting[i]);
		 }
	 }
}
    3690:	0f 90       	pop	r0
    3692:	0f 90       	pop	r0
    3694:	0f 90       	pop	r0
    3696:	0f 90       	pop	r0
    3698:	0f 90       	pop	r0
    369a:	cf 91       	pop	r28
    369c:	df 91       	pop	r29
    369e:	08 95       	ret

000036a0 <MasterReset>:

void MasterReset(){
     //Restore All Stored EEPROM data to the Default
     

}
    36a0:	08 95       	ret

000036a2 <ComposeDatetime>:
	}
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalTotalMoney),2,Result);
}


void ComposeDatetime(char *Result){// 2010/10/01 16:27:44
    36a2:	df 93       	push	r29
    36a4:	cf 93       	push	r28
    36a6:	cd b7       	in	r28, 0x3d	; 61
    36a8:	de b7       	in	r29, 0x3e	; 62
    36aa:	62 97       	sbiw	r28, 0x12	; 18
    36ac:	0f b6       	in	r0, 0x3f	; 63
    36ae:	f8 94       	cli
    36b0:	de bf       	out	0x3e, r29	; 62
    36b2:	0f be       	out	0x3f, r0	; 63
    36b4:	cd bf       	out	0x3d, r28	; 61
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    36b6:	20 91 9a 05 	lds	r18, 0x059A
    36ba:	2f 83       	std	Y+7, r18	; 0x07
    36bc:	20 91 9b 05 	lds	r18, 0x059B
    36c0:	28 87       	std	Y+8, r18	; 0x08
	 }Dest[Length]=0;
    36c2:	20 91 9d 05 	lds	r18, 0x059D
    36c6:	2c 83       	std	Y+4, r18	; 0x04
    36c8:	20 91 9e 05 	lds	r18, 0x059E
    36cc:	2d 83       	std	Y+5, r18	; 0x05
    36ce:	20 91 a0 05 	lds	r18, 0x05A0
    36d2:	29 83       	std	Y+1, r18	; 0x01
    36d4:	20 91 a1 05 	lds	r18, 0x05A1
    36d8:	2a 83       	std	Y+2, r18	; 0x02
    36da:	20 91 79 0a 	lds	r18, 0x0A79
    36de:	2a 87       	std	Y+10, r18	; 0x0a
    36e0:	20 91 7a 0a 	lds	r18, 0x0A7A
    36e4:	2b 87       	std	Y+11, r18	; 0x0b
    36e6:	20 91 7c 0a 	lds	r18, 0x0A7C
    36ea:	2d 87       	std	Y+13, r18	; 0x0d
    36ec:	20 91 7d 0a 	lds	r18, 0x0A7D
    36f0:	2e 87       	std	Y+14, r18	; 0x0e
    36f2:	20 91 7f 0a 	lds	r18, 0x0A7F
    36f6:	28 8b       	std	Y+16, r18	; 0x10
    36f8:	20 91 80 0a 	lds	r18, 0x0A80
    36fc:	29 8b       	std	Y+17, r18	; 0x11
    36fe:	1a 8a       	std	Y+18, r1	; 0x12
    3700:	1f 86       	std	Y+15, r1	; 0x0f
    3702:	1c 86       	std	Y+12, r1	; 0x0c
    3704:	1b 82       	std	Y+3, r1	; 0x03
    3706:	1e 82       	std	Y+6, r1	; 0x06
    3708:	19 86       	std	Y+9, r1	; 0x09
     StrPosCopy(strSystemDate,sYear,6,2);

     StrPosCopy(strSystemTime,sHour,0,2);
     StrPosCopy(strSystemTime,sMinute,3,2);
     StrPosCopy(strSystemTime,sSecond,6,2);
	 sprintf_P(Result,PSTR("20%s/%s/%s %s:%s:%s"),sYear,sMonth,sDay,sHour,sMinute,sSecond);
    370a:	2d b7       	in	r18, 0x3d	; 61
    370c:	3e b7       	in	r19, 0x3e	; 62
    370e:	20 51       	subi	r18, 0x10	; 16
    3710:	30 40       	sbci	r19, 0x00	; 0
    3712:	0f b6       	in	r0, 0x3f	; 63
    3714:	f8 94       	cli
    3716:	3e bf       	out	0x3e, r19	; 62
    3718:	0f be       	out	0x3f, r0	; 63
    371a:	2d bf       	out	0x3d, r18	; 61
    371c:	ed b7       	in	r30, 0x3d	; 61
    371e:	fe b7       	in	r31, 0x3e	; 62
    3720:	31 96       	adiw	r30, 0x01	; 1
    3722:	ad b7       	in	r26, 0x3d	; 61
    3724:	be b7       	in	r27, 0x3e	; 62
    3726:	12 96       	adiw	r26, 0x02	; 2
    3728:	9c 93       	st	X, r25
    372a:	8e 93       	st	-X, r24
    372c:	11 97       	sbiw	r26, 0x01	; 1
    372e:	8f e4       	ldi	r24, 0x4F	; 79
    3730:	93 e0       	ldi	r25, 0x03	; 3
    3732:	93 83       	std	Z+3, r25	; 0x03
    3734:	82 83       	std	Z+2, r24	; 0x02
    3736:	ce 01       	movw	r24, r28
    3738:	01 96       	adiw	r24, 0x01	; 1
    373a:	95 83       	std	Z+5, r25	; 0x05
    373c:	84 83       	std	Z+4, r24	; 0x04
    373e:	ce 01       	movw	r24, r28
    3740:	04 96       	adiw	r24, 0x04	; 4
    3742:	97 83       	std	Z+7, r25	; 0x07
    3744:	86 83       	std	Z+6, r24	; 0x06
    3746:	ce 01       	movw	r24, r28
    3748:	07 96       	adiw	r24, 0x07	; 7
    374a:	91 87       	std	Z+9, r25	; 0x09
    374c:	80 87       	std	Z+8, r24	; 0x08
    374e:	ce 01       	movw	r24, r28
    3750:	0a 96       	adiw	r24, 0x0a	; 10
    3752:	93 87       	std	Z+11, r25	; 0x0b
    3754:	82 87       	std	Z+10, r24	; 0x0a
    3756:	ce 01       	movw	r24, r28
    3758:	0d 96       	adiw	r24, 0x0d	; 13
    375a:	95 87       	std	Z+13, r25	; 0x0d
    375c:	84 87       	std	Z+12, r24	; 0x0c
    375e:	ce 01       	movw	r24, r28
    3760:	40 96       	adiw	r24, 0x10	; 16
    3762:	97 87       	std	Z+15, r25	; 0x0f
    3764:	86 87       	std	Z+14, r24	; 0x0e
    3766:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    376a:	2d b7       	in	r18, 0x3d	; 61
    376c:	3e b7       	in	r19, 0x3e	; 62
    376e:	20 5f       	subi	r18, 0xF0	; 240
    3770:	3f 4f       	sbci	r19, 0xFF	; 255
    3772:	0f b6       	in	r0, 0x3f	; 63
    3774:	f8 94       	cli
    3776:	3e bf       	out	0x3e, r19	; 62
    3778:	0f be       	out	0x3f, r0	; 63
    377a:	2d bf       	out	0x3d, r18	; 61
}
    377c:	62 96       	adiw	r28, 0x12	; 18
    377e:	0f b6       	in	r0, 0x3f	; 63
    3780:	f8 94       	cli
    3782:	de bf       	out	0x3e, r29	; 62
    3784:	0f be       	out	0x3f, r0	; 63
    3786:	cd bf       	out	0x3d, r28	; 61
    3788:	cf 91       	pop	r28
    378a:	df 91       	pop	r29
    378c:	08 95       	ret

0000378e <leadingZero>:
		}
     else {
	    sprintf_P(StrResult,PSTR("%d"),Val);
	 }
	 */
     sprintf_P(StrResult,PSTR("%.2d"),Val);
    378e:	00 d0       	rcall	.+0      	; 0x3790 <leadingZero+0x2>
    3790:	00 d0       	rcall	.+0      	; 0x3792 <leadingZero+0x4>
    3792:	00 d0       	rcall	.+0      	; 0x3794 <leadingZero+0x6>
    3794:	ed b7       	in	r30, 0x3d	; 61
    3796:	fe b7       	in	r31, 0x3e	; 62
    3798:	31 96       	adiw	r30, 0x01	; 1
    379a:	ad b7       	in	r26, 0x3d	; 61
    379c:	be b7       	in	r27, 0x3e	; 62
    379e:	12 96       	adiw	r26, 0x02	; 2
    37a0:	7c 93       	st	X, r23
    37a2:	6e 93       	st	-X, r22
    37a4:	11 97       	sbiw	r26, 0x01	; 1
    37a6:	26 e5       	ldi	r18, 0x56	; 86
    37a8:	3d e0       	ldi	r19, 0x0D	; 13
    37aa:	33 83       	std	Z+3, r19	; 0x03
    37ac:	22 83       	std	Z+2, r18	; 0x02
    37ae:	84 83       	std	Z+4, r24	; 0x04
    37b0:	15 82       	std	Z+5, r1	; 0x05
    37b2:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    37b6:	8d b7       	in	r24, 0x3d	; 61
    37b8:	9e b7       	in	r25, 0x3e	; 62
    37ba:	06 96       	adiw	r24, 0x06	; 6
    37bc:	0f b6       	in	r0, 0x3f	; 63
    37be:	f8 94       	cli
    37c0:	9e bf       	out	0x3e, r25	; 62
    37c2:	0f be       	out	0x3f, r0	; 63
    37c4:	8d bf       	out	0x3d, r24	; 61

}
    37c6:	08 95       	ret

000037c8 <UpdateSeqNum>:
	 sprintf_P(strIFT_ID,PSTR("%.2d"),IdIFT);
	 //leadingZero(IdIFT,strIFT_ID);
}

void UpdateSeqNum(){
     if (SeqNum<100)SeqNum++;
    37c8:	80 91 d1 01 	lds	r24, 0x01D1
    37cc:	84 36       	cpi	r24, 0x64	; 100
    37ce:	20 f4       	brcc	.+8      	; 0x37d8 <UpdateSeqNum+0x10>
    37d0:	8f 5f       	subi	r24, 0xFF	; 255
    37d2:	80 93 d1 01 	sts	0x01D1, r24
    37d6:	02 c0       	rjmp	.+4      	; 0x37dc <UpdateSeqNum+0x14>
	 else SeqNum=0;
    37d8:	10 92 d1 01 	sts	0x01D1, r1
		}
     else {
	    sprintf_P(StrResult,PSTR("%d"),Val);
	 }
	 */
     sprintf_P(StrResult,PSTR("%.2d"),Val);
    37dc:	00 d0       	rcall	.+0      	; 0x37de <UpdateSeqNum+0x16>
    37de:	00 d0       	rcall	.+0      	; 0x37e0 <UpdateSeqNum+0x18>
    37e0:	00 d0       	rcall	.+0      	; 0x37e2 <UpdateSeqNum+0x1a>
    37e2:	ed b7       	in	r30, 0x3d	; 61
    37e4:	fe b7       	in	r31, 0x3e	; 62
    37e6:	31 96       	adiw	r30, 0x01	; 1
    37e8:	8b ea       	ldi	r24, 0xAB	; 171
    37ea:	9d e0       	ldi	r25, 0x0D	; 13
    37ec:	ad b7       	in	r26, 0x3d	; 61
    37ee:	be b7       	in	r27, 0x3e	; 62
    37f0:	12 96       	adiw	r26, 0x02	; 2
    37f2:	9c 93       	st	X, r25
    37f4:	8e 93       	st	-X, r24
    37f6:	11 97       	sbiw	r26, 0x01	; 1
    37f8:	86 e5       	ldi	r24, 0x56	; 86
    37fa:	9d e0       	ldi	r25, 0x0D	; 13
    37fc:	93 83       	std	Z+3, r25	; 0x03
    37fe:	82 83       	std	Z+2, r24	; 0x02
    3800:	80 91 d1 01 	lds	r24, 0x01D1
    3804:	84 83       	std	Z+4, r24	; 0x04
    3806:	15 82       	std	Z+5, r1	; 0x05
    3808:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    380c:	8d b7       	in	r24, 0x3d	; 61
    380e:	9e b7       	in	r25, 0x3e	; 62
    3810:	06 96       	adiw	r24, 0x06	; 6
    3812:	0f b6       	in	r0, 0x3f	; 63
    3814:	f8 94       	cli
    3816:	9e bf       	out	0x3e, r25	; 62
    3818:	0f be       	out	0x3f, r0	; 63
    381a:	8d bf       	out	0x3d, r24	; 61

void UpdateSeqNum(){
     if (SeqNum<100)SeqNum++;
	 else SeqNum=0;
	 leadingZero(SeqNum,strSeqNum);
} 
    381c:	08 95       	ret

0000381e <UpdateIFT_ID>:
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    381e:	e1 99       	sbic	0x1c, 1	; 28
    3820:	fe cf       	rjmp	.-4      	; 0x381e <UpdateIFT_ID>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3822:	80 e0       	ldi	r24, 0x00	; 0
    3824:	90 e0       	ldi	r25, 0x00	; 0
    3826:	9f bb       	out	0x1f, r25	; 31
    3828:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    382a:	e0 9a       	sbi	0x1c, 0	; 28
    382c:	8d b3       	in	r24, 0x1d	; 29

void UpdateIFT_ID(){
     char IdIFT;
     //sprintf_P(strIFT_ID,PSTR("%.2d"),eeprom_read_byte(&DefIFT_ID));
	 IdIFT=(eeprom_read_byte(&DefIFT_ID)%100);
	 sprintf_P(strIFT_ID,PSTR("%.2d"),IdIFT);
    382e:	00 d0       	rcall	.+0      	; 0x3830 <UpdateIFT_ID+0x12>
    3830:	00 d0       	rcall	.+0      	; 0x3832 <UpdateIFT_ID+0x14>
    3832:	00 d0       	rcall	.+0      	; 0x3834 <UpdateIFT_ID+0x16>
    3834:	ed b7       	in	r30, 0x3d	; 61
    3836:	fe b7       	in	r31, 0x3e	; 62
    3838:	31 96       	adiw	r30, 0x01	; 1
    383a:	2c ec       	ldi	r18, 0xCC	; 204
    383c:	35 e0       	ldi	r19, 0x05	; 5
    383e:	ad b7       	in	r26, 0x3d	; 61
    3840:	be b7       	in	r27, 0x3e	; 62
    3842:	12 96       	adiw	r26, 0x02	; 2
    3844:	3c 93       	st	X, r19
    3846:	2e 93       	st	-X, r18
    3848:	11 97       	sbiw	r26, 0x01	; 1
    384a:	2e eb       	ldi	r18, 0xBE	; 190
    384c:	30 e2       	ldi	r19, 0x20	; 32
    384e:	33 83       	std	Z+3, r19	; 0x03
    3850:	22 83       	std	Z+2, r18	; 0x02
    3852:	64 e6       	ldi	r22, 0x64	; 100
    3854:	0e 94 1f b7 	call	0x16e3e	; 0x16e3e <__udivmodqi4>
    3858:	94 83       	std	Z+4, r25	; 0x04
    385a:	15 82       	std	Z+5, r1	; 0x05
    385c:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    3860:	8d b7       	in	r24, 0x3d	; 61
    3862:	9e b7       	in	r25, 0x3e	; 62
    3864:	06 96       	adiw	r24, 0x06	; 6
    3866:	0f b6       	in	r0, 0x3f	; 63
    3868:	f8 94       	cli
    386a:	9e bf       	out	0x3e, r25	; 62
    386c:	0f be       	out	0x3f, r0	; 63
    386e:	8d bf       	out	0x3d, r24	; 61
	 //leadingZero(IdIFT,strIFT_ID);
}
    3870:	08 95       	ret

00003872 <GetFIPAddr>:
	    Result=PPumpID[FIPAddr-1];
	 }
   return Result;
}

char GetFIPAddr(char iPumpID){
    3872:	ff 92       	push	r15
    3874:	0f 93       	push	r16
    3876:	1f 93       	push	r17
    3878:	df 93       	push	r29
    387a:	cf 93       	push	r28
    387c:	cd b7       	in	r28, 0x3d	; 61
    387e:	de b7       	in	r29, 0x3e	; 62
    3880:	28 97       	sbiw	r28, 0x08	; 8
    3882:	0f b6       	in	r0, 0x3f	; 63
    3884:	f8 94       	cli
    3886:	de bf       	out	0x3e, r29	; 62
    3888:	0f be       	out	0x3f, r0	; 63
    388a:	cd bf       	out	0x3d, r28	; 61
    388c:	f8 2e       	mov	r15, r24
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    388e:	8e 01       	movw	r16, r28
    3890:	0f 5f       	subi	r16, 0xFF	; 255
    3892:	1f 4f       	sbci	r17, 0xFF	; 255
    3894:	c8 01       	movw	r24, r16
    3896:	65 e4       	ldi	r22, 0x45	; 69
    3898:	70 e0       	ldi	r23, 0x00	; 0
    389a:	48 e0       	ldi	r20, 0x08	; 8
    389c:	50 e0       	ldi	r21, 0x00	; 0
    389e:	23 ef       	ldi	r18, 0xF3	; 243
    38a0:	32 e1       	ldi	r19, 0x12	; 18
    38a2:	0e 94 1f b4 	call	0x1683e	; 0x1683e <__eerd_block>
    38a6:	f8 01       	movw	r30, r16
char i,PPumpID[8],Result;     
	 Result=0; 
	 eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap,8);
     for(i=0;i<8;i++){
    38a8:	9e 01       	movw	r18, r28
    38aa:	27 5f       	subi	r18, 0xF7	; 247
    38ac:	3f 4f       	sbci	r19, 0xFF	; 255
    38ae:	9e 2f       	mov	r25, r30
    38b0:	90 1b       	sub	r25, r16
	     if (PPumpID[i]==iPumpID){
    38b2:	80 81       	ld	r24, Z
    38b4:	8f 15       	cp	r24, r15
    38b6:	19 f4       	brne	.+6      	; 0x38be <GetFIPAddr+0x4c>
		     Result=i+1;
    38b8:	89 2f       	mov	r24, r25
    38ba:	8f 5f       	subi	r24, 0xFF	; 255
    38bc:	05 c0       	rjmp	.+10     	; 0x38c8 <GetFIPAddr+0x56>
			 break;
    38be:	31 96       	adiw	r30, 0x01	; 1

char GetFIPAddr(char iPumpID){
char i,PPumpID[8],Result;     
	 Result=0; 
	 eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap,8);
     for(i=0;i<8;i++){
    38c0:	e2 17       	cp	r30, r18
    38c2:	f3 07       	cpc	r31, r19
    38c4:	a1 f7       	brne	.-24     	; 0x38ae <GetFIPAddr+0x3c>
    38c6:	80 e0       	ldi	r24, 0x00	; 0
		     Result=i+1;
			 break;
		 }
	 }
   return Result;
}
    38c8:	28 96       	adiw	r28, 0x08	; 8
    38ca:	0f b6       	in	r0, 0x3f	; 63
    38cc:	f8 94       	cli
    38ce:	de bf       	out	0x3e, r29	; 62
    38d0:	0f be       	out	0x3f, r0	; 63
    38d2:	cd bf       	out	0x3d, r28	; 61
    38d4:	cf 91       	pop	r28
    38d6:	df 91       	pop	r29
    38d8:	1f 91       	pop	r17
    38da:	0f 91       	pop	r16
    38dc:	ff 90       	pop	r15
    38de:	08 95       	ret

000038e0 <UpdateStandaloneStatus>:
		 sprintf_P(lcdteks,PSTR("%s"),SPump);
         lcd_print(4,1,lcdteks);
     	 }
}

void UpdateStandaloneStatus(char xPumpID,char xPumpStatus){//xPumpID: (1-16)&0x0F
    38e0:	ff 92       	push	r15
    38e2:	0f 93       	push	r16
    38e4:	1f 93       	push	r17
    38e6:	cf 93       	push	r28
    38e8:	df 93       	push	r29
    38ea:	28 2f       	mov	r18, r24
    38ec:	f6 2e       	mov	r15, r22
char strSend[20],iPumpID; //[xxxxxxxxxPx]
char iAddr;

	 if (xPumpID<16){
    38ee:	80 31       	cpi	r24, 0x10	; 16
    38f0:	08 f0       	brcs	.+2      	; 0x38f4 <UpdateStandaloneStatus+0x14>
    38f2:	4e c0       	rjmp	.+156    	; 0x3990 <UpdateStandaloneStatus+0xb0>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    38f4:	e1 99       	sbic	0x1c, 1	; 28
    38f6:	fe cf       	rjmp	.-4      	; 0x38f4 <UpdateStandaloneStatus+0x14>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    38f8:	87 e3       	ldi	r24, 0x37	; 55
    38fa:	91 e0       	ldi	r25, 0x01	; 1
    38fc:	9f bb       	out	0x1f, r25	; 31
    38fe:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    3900:	e0 9a       	sbi	0x1c, 0	; 28
    3902:	8d b3       	in	r24, 0x1d	; 29
	     DispenserBrand=eeprom_read_byte(&DefDispenserBrand);
    3904:	80 93 61 01 	sts	0x0161, r24
	     switch(DispenserBrand){
    3908:	81 50       	subi	r24, 0x01	; 1
    390a:	82 30       	cpi	r24, 0x02	; 2
    390c:	08 f4       	brcc	.+2      	; 0x3910 <UpdateStandaloneStatus+0x30>
    390e:	82 2f       	mov	r24, r18
	     case ST_WAYNE_DART:
              iPumpID=xPumpID;
	          break;				   
	     }

		 iAddr=GetFIPAddr(iPumpID);
    3910:	0e 94 39 1c 	call	0x3872	; 0x3872 <GetFIPAddr>
		 if (iAddr>0){
    3914:	88 23       	and	r24, r24
    3916:	e1 f1       	breq	.+120    	; 0x3990 <UpdateStandaloneStatus+0xb0>
		     iAddr=iAddr-1;
			 if (strPumpStatus[iAddr]!=GetPumpStatusLabel(PS_PRINT_READY)){//iFdiiiiiiiiiiiii
    3918:	81 50       	subi	r24, 0x01	; 1
    391a:	c8 2f       	mov	r28, r24
    391c:	d0 e0       	ldi	r29, 0x00	; 0
    391e:	80 e1       	ldi	r24, 0x10	; 16
    3920:	0e 94 90 13 	call	0x2720	; 0x2720 <GetPumpStatusLabel>
    3924:	8e 01       	movw	r16, r28
    3926:	0e 5e       	subi	r16, 0xEE	; 238
    3928:	1e 4f       	sbci	r17, 0xFE	; 254
    392a:	f8 01       	movw	r30, r16
    392c:	90 81       	ld	r25, Z
    392e:	98 17       	cp	r25, r24
    3930:	b1 f0       	breq	.+44     	; 0x395e <UpdateStandaloneStatus+0x7e>
		         if (xPumpStatus!=PS_PRINT_READY)
    3932:	f0 e1       	ldi	r31, 0x10	; 16
    3934:	ff 16       	cp	r15, r31
    3936:	21 f0       	breq	.+8      	; 0x3940 <UpdateStandaloneStatus+0x60>
				     CurrentPumpStatus[iAddr]=xPumpStatus;
    3938:	fe 01       	movw	r30, r28
    393a:	ee 59       	subi	r30, 0x9E	; 158
    393c:	fe 4f       	sbci	r31, 0xFE	; 254
    393e:	f0 82       	st	Z, r15
			     strPumpStatus[iAddr]=GetPumpStatusLabel(xPumpStatus);
    3940:	8f 2d       	mov	r24, r15
    3942:	0e 94 90 13 	call	0x2720	; 0x2720 <GetPumpStatusLabel>
    3946:	8e 01       	movw	r16, r28
    3948:	0e 5e       	subi	r16, 0xEE	; 238
    394a:	1e 4f       	sbci	r17, 0xFE	; 254
    394c:	f8 01       	movw	r30, r16
    394e:	80 83       	st	Z, r24
                 if (xPumpStatus==PS_FINISH_TOTALIZER)
    3950:	f5 e1       	ldi	r31, 0x15	; 21
    3952:	ff 16       	cp	r15, r31
    3954:	c1 f4       	brne	.+48     	; 0x3986 <UpdateStandaloneStatus+0xa6>
				     strPumpStatus[iAddr]=GetPumpStatusLabel(CurrentPumpStatus[iAddr]);
    3956:	ce 59       	subi	r28, 0x9E	; 158
    3958:	de 4f       	sbci	r29, 0xFE	; 254
    395a:	88 81       	ld	r24, Y
    395c:	10 c0       	rjmp	.+32     	; 0x397e <UpdateStandaloneStatus+0x9e>
    395e:	fe 01       	movw	r30, r28
    3960:	ee 59       	subi	r30, 0x9E	; 158
    3962:	fe 4f       	sbci	r31, 0xFE	; 254
		     }else if ((strPumpStatus[iAddr]==GetPumpStatusLabel(PS_PRINT_READY))||(xPumpStatus==PUMP_FEOT)||(xPumpStatus==PS_PRINTED)||(xPumpStatus==PS_TOTALIZER)){//P
			     if (xPumpStatus==PS_PRINTED){
    3964:	81 e1       	ldi	r24, 0x11	; 17
    3966:	f8 16       	cp	r15, r24
    3968:	11 f4       	brne	.+4      	; 0x396e <UpdateStandaloneStatus+0x8e>
				 //New

				     //if (CurrentPumpStatus[iAddr]!=GetPumpStatusLabel(PS_PRINT_READY))
			             strPumpStatus[iAddr]=GetPumpStatusLabel(CurrentPumpStatus[iAddr]);
    396a:	80 81       	ld	r24, Z
    396c:	08 c0       	rjmp	.+16     	; 0x397e <UpdateStandaloneStatus+0x9e>
					 //    CurrentPumpStatus[iAddr]=PUMP_OFF;
					 //    strPumpStatus[iAddr]=GetPumpStatusLabel(PUMP_OFF);
					 //}

				  }
			     else CurrentPumpStatus[iAddr]=xPumpStatus;			 
    396e:	f0 82       	st	Z, r15
			 if (xPumpStatus==PUMP_FEOT){
    3970:	8b e0       	ldi	r24, 0x0B	; 11
    3972:	f8 16       	cp	r15, r24
    3974:	21 f0       	breq	.+8      	; 0x397e <UpdateStandaloneStatus+0x9e>
			     CurrentPumpStatus[iAddr]=xPumpStatus;
			     strPumpStatus[iAddr]=GetPumpStatusLabel(CurrentPumpStatus[iAddr]);
				 }
             else if (xPumpStatus==PS_TOTALIZER){
    3976:	f4 e1       	ldi	r31, 0x14	; 20
    3978:	ff 16       	cp	r15, r31
    397a:	29 f4       	brne	.+10     	; 0x3986 <UpdateStandaloneStatus+0xa6>
			      strPumpStatus[iAddr]=GetPumpStatusLabel(xPumpStatus);
    397c:	84 e1       	ldi	r24, 0x14	; 20
    397e:	0e 94 90 13 	call	0x2720	; 0x2720 <GetPumpStatusLabel>
    3982:	f8 01       	movw	r30, r16
    3984:	80 83       	st	Z, r24
				 }
		 }		 	     
         strPumpStatus[16]=0;
    3986:	10 92 22 01 	sts	0x0122, r1
	     IsNewPumpStatus=True;		 
    398a:	81 e0       	ldi	r24, 0x01	; 1
    398c:	80 93 11 01 	sts	0x0111, r24
		 }		 
	 }
}
    3990:	df 91       	pop	r29
    3992:	cf 91       	pop	r28
    3994:	1f 91       	pop	r17
    3996:	0f 91       	pop	r16
    3998:	ff 90       	pop	r15
    399a:	08 95       	ret

0000399c <GetPumpID>:
     StrPosCopy(strSystemTime,sSecond,6,2);
	 sprintf_P(Result,PSTR("20%s/%s/%s %s:%s:%s"),sYear,sMonth,sDay,sHour,sMinute,sSecond);
}


char GetPumpID(char FIPAddr){//Find Stored PumpID in PumpMap
    399c:	1f 93       	push	r17
    399e:	df 93       	push	r29
    39a0:	cf 93       	push	r28
    39a2:	cd b7       	in	r28, 0x3d	; 61
    39a4:	de b7       	in	r29, 0x3e	; 62
    39a6:	28 97       	sbiw	r28, 0x08	; 8
    39a8:	0f b6       	in	r0, 0x3f	; 63
    39aa:	f8 94       	cli
    39ac:	de bf       	out	0x3e, r29	; 62
    39ae:	0f be       	out	0x3f, r0	; 63
    39b0:	cd bf       	out	0x3d, r28	; 61
    39b2:	18 2f       	mov	r17, r24
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    39b4:	ce 01       	movw	r24, r28
    39b6:	01 96       	adiw	r24, 0x01	; 1
    39b8:	65 e4       	ldi	r22, 0x45	; 69
    39ba:	70 e0       	ldi	r23, 0x00	; 0
    39bc:	48 e0       	ldi	r20, 0x08	; 8
    39be:	50 e0       	ldi	r21, 0x00	; 0
    39c0:	23 ef       	ldi	r18, 0xF3	; 243
    39c2:	32 e1       	ldi	r19, 0x12	; 18
    39c4:	0e 94 1f b4 	call	0x1683e	; 0x1683e <__eerd_block>
     char PPumpID[8],Result;     
     eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap,8);
	 Result=0;
	 if ((FIPAddr>0) && (FIPAddr<8)){
    39c8:	81 2f       	mov	r24, r17
    39ca:	81 50       	subi	r24, 0x01	; 1
    39cc:	87 30       	cpi	r24, 0x07	; 7
    39ce:	10 f0       	brcs	.+4      	; 0x39d4 <GetPumpID+0x38>
    39d0:	80 e0       	ldi	r24, 0x00	; 0
    39d2:	04 c0       	rjmp	.+8      	; 0x39dc <GetPumpID+0x40>
	    Result=PPumpID[FIPAddr-1];
    39d4:	fe 01       	movw	r30, r28
    39d6:	e1 0f       	add	r30, r17
    39d8:	f1 1d       	adc	r31, r1
    39da:	80 81       	ld	r24, Z
	 }
   return Result;
}
    39dc:	28 96       	adiw	r28, 0x08	; 8
    39de:	0f b6       	in	r0, 0x3f	; 63
    39e0:	f8 94       	cli
    39e2:	de bf       	out	0x3e, r29	; 62
    39e4:	0f be       	out	0x3f, r0	; 63
    39e6:	cd bf       	out	0x3d, r28	; 61
    39e8:	cf 91       	pop	r28
    39ea:	df 91       	pop	r29
    39ec:	1f 91       	pop	r17
    39ee:	08 95       	ret

000039f0 <GetTotalizerData>:
	 if (TType==TMONEY)eeprom_write_block((const void*)&rawValue,(void*)&(TotalMoney[TAddr][iPumpAddr][iGrade]), sizeof(rawValue));
}



void GetTotalizerData(char TType, char TAddr, char xPumpAddr, char xGradeAddr, char *strValue){// 0 1 1 "0000000"
    39f0:	0f 93       	push	r16
    39f2:	1f 93       	push	r17
    39f4:	df 93       	push	r29
    39f6:	cf 93       	push	r28
    39f8:	00 d0       	rcall	.+0      	; 0x39fa <GetTotalizerData+0xa>
    39fa:	00 d0       	rcall	.+0      	; 0x39fc <GetTotalizerData+0xc>
    39fc:	00 d0       	rcall	.+0      	; 0x39fe <GetTotalizerData+0xe>
    39fe:	cd b7       	in	r28, 0x3d	; 61
    3a00:	de b7       	in	r29, 0x3e	; 62
    3a02:	96 2f       	mov	r25, r22
     char rawValue[6],iPumpAddr,iGrade;

	 iPumpAddr=(xPumpAddr&0x0F);
    3a04:	4f 70       	andi	r20, 0x0F	; 15
	 if ((xGradeAddr>=1)&&(xGradeAddr<=6))
    3a06:	21 50       	subi	r18, 0x01	; 1
    3a08:	26 30       	cpi	r18, 0x06	; 6
    3a0a:	08 f4       	brcc	.+2      	; 0x3a0e <GetTotalizerData+0x1e>
    3a0c:	52 2f       	mov	r21, r18
	     iGrade=xGradeAddr-1;
     
//TotalVolume[2][16][6][6];
//GetTotalizerData(TVOLUME,TOTALIZER_LAST,PumpNum,xGrade,strLastVolume);
	 if (TType==TVOLUME)eeprom_read_block((void*) &rawValue, (const void*) &(TotalVolume[TAddr][iPumpAddr][iGrade]), sizeof(rawValue));
    3a0e:	88 23       	and	r24, r24
    3a10:	d9 f4       	brne	.+54     	; 0x3a48 <GetTotalizerData+0x58>
    3a12:	64 e2       	ldi	r22, 0x24	; 36
    3a14:	46 9f       	mul	r20, r22
    3a16:	b0 01       	movw	r22, r0
    3a18:	11 24       	eor	r1, r1
    3a1a:	29 2f       	mov	r18, r25
    3a1c:	30 e0       	ldi	r19, 0x00	; 0
    3a1e:	80 e2       	ldi	r24, 0x20	; 32
    3a20:	91 e0       	ldi	r25, 0x01	; 1
    3a22:	fc 01       	movw	r30, r24
    3a24:	2e 9f       	mul	r18, r30
    3a26:	c0 01       	movw	r24, r0
    3a28:	2f 9f       	mul	r18, r31
    3a2a:	90 0d       	add	r25, r0
    3a2c:	3e 9f       	mul	r19, r30
    3a2e:	90 0d       	add	r25, r0
    3a30:	11 24       	eor	r1, r1
    3a32:	68 0f       	add	r22, r24
    3a34:	79 1f       	adc	r23, r25
    3a36:	86 e0       	ldi	r24, 0x06	; 6
    3a38:	58 9f       	mul	r21, r24
    3a3a:	c0 01       	movw	r24, r0
    3a3c:	11 24       	eor	r1, r1
    3a3e:	68 0f       	add	r22, r24
    3a40:	79 1f       	adc	r23, r25
    3a42:	6d 53       	subi	r22, 0x3D	; 61
    3a44:	7c 4f       	sbci	r23, 0xFC	; 252
    3a46:	1c c0       	rjmp	.+56     	; 0x3a80 <GetTotalizerData+0x90>
	 else 
	 if (TType==TMONEY)eeprom_read_block((void*) &rawValue, (const void*) &(TotalMoney[TAddr][iPumpAddr][iGrade]), sizeof(rawValue));
    3a48:	81 30       	cpi	r24, 0x01	; 1
    3a4a:	11 f5       	brne	.+68     	; 0x3a90 <GetTotalizerData+0xa0>
    3a4c:	64 e2       	ldi	r22, 0x24	; 36
    3a4e:	46 9f       	mul	r20, r22
    3a50:	b0 01       	movw	r22, r0
    3a52:	11 24       	eor	r1, r1
    3a54:	29 2f       	mov	r18, r25
    3a56:	30 e0       	ldi	r19, 0x00	; 0
    3a58:	80 e2       	ldi	r24, 0x20	; 32
    3a5a:	91 e0       	ldi	r25, 0x01	; 1
    3a5c:	fc 01       	movw	r30, r24
    3a5e:	2e 9f       	mul	r18, r30
    3a60:	c0 01       	movw	r24, r0
    3a62:	2f 9f       	mul	r18, r31
    3a64:	90 0d       	add	r25, r0
    3a66:	3e 9f       	mul	r19, r30
    3a68:	90 0d       	add	r25, r0
    3a6a:	11 24       	eor	r1, r1
    3a6c:	68 0f       	add	r22, r24
    3a6e:	79 1f       	adc	r23, r25
    3a70:	86 e0       	ldi	r24, 0x06	; 6
    3a72:	58 9f       	mul	r21, r24
    3a74:	c0 01       	movw	r24, r0
    3a76:	11 24       	eor	r1, r1
    3a78:	68 0f       	add	r22, r24
    3a7a:	79 1f       	adc	r23, r25
    3a7c:	6d 5f       	subi	r22, 0xFD	; 253
    3a7e:	79 4f       	sbci	r23, 0xF9	; 249
    3a80:	ce 01       	movw	r24, r28
    3a82:	01 96       	adiw	r24, 0x01	; 1
    3a84:	46 e0       	ldi	r20, 0x06	; 6
    3a86:	50 e0       	ldi	r21, 0x00	; 0
    3a88:	23 ef       	ldi	r18, 0xF3	; 243
    3a8a:	32 e1       	ldi	r19, 0x12	; 18
    3a8c:	0e 94 1f b4 	call	0x1683e	; 0x1683e <__eerd_block>
	 //Convert RawData to String 
	 RawToStr(rawValue,strValue);
    3a90:	ce 01       	movw	r24, r28
    3a92:	01 96       	adiw	r24, 0x01	; 1
    3a94:	b8 01       	movw	r22, r16
    3a96:	0e 94 ef 19 	call	0x33de	; 0x33de <RawToStr>
}
    3a9a:	26 96       	adiw	r28, 0x06	; 6
    3a9c:	0f b6       	in	r0, 0x3f	; 63
    3a9e:	f8 94       	cli
    3aa0:	de bf       	out	0x3e, r29	; 62
    3aa2:	0f be       	out	0x3f, r0	; 63
    3aa4:	cd bf       	out	0x3d, r28	; 61
    3aa6:	cf 91       	pop	r28
    3aa8:	df 91       	pop	r29
    3aaa:	1f 91       	pop	r17
    3aac:	0f 91       	pop	r16
    3aae:	08 95       	ret

00003ab0 <SelectMark>:
	      break;
	 }
    return Result;
}

char SelectMark(char InMark){
    3ab0:	df 92       	push	r13
    3ab2:	ef 92       	push	r14
    3ab4:	ff 92       	push	r15
    3ab6:	0f 93       	push	r16
    3ab8:	1f 93       	push	r17
    3aba:	df 93       	push	r29
    3abc:	cf 93       	push	r28
    3abe:	00 d0       	rcall	.+0      	; 0x3ac0 <SelectMark+0x10>
    3ac0:	00 d0       	rcall	.+0      	; 0x3ac2 <SelectMark+0x12>
    3ac2:	0f 92       	push	r0
    3ac4:	cd b7       	in	r28, 0x3d	; 61
    3ac6:	de b7       	in	r29, 0x3e	; 62
    3ac8:	d8 2e       	mov	r13, r24
    3aca:	8e 01       	movw	r16, r28
    3acc:	0f 5f       	subi	r16, 0xFF	; 255
    3ace:	1f 4f       	sbci	r17, 0xFF	; 255
    3ad0:	c8 01       	movw	r24, r16
    3ad2:	60 e4       	ldi	r22, 0x40	; 64
    3ad4:	70 e0       	ldi	r23, 0x00	; 0
    3ad6:	45 e0       	ldi	r20, 0x05	; 5
    3ad8:	50 e0       	ldi	r21, 0x00	; 0
    3ada:	23 ef       	ldi	r18, 0xF3	; 243
    3adc:	32 e1       	ldi	r19, 0x12	; 18
    3ade:	0e 94 1f b4 	call	0x1683e	; 0x1683e <__eerd_block>
    3ae2:	ed 2d       	mov	r30, r13
    3ae4:	21 e0       	ldi	r18, 0x01	; 1
    3ae6:	30 e0       	ldi	r19, 0x00	; 0
     eeprom_read_block((void*)&PMark,(const void*)&DefMarkMap, sizeof(DefMarkMap));
	 Length=sizeof(DefMarkMap);
	 Result=InMark;
     for(i=0;i<Length;i++){
	     if (InMark==PMark[i])
		     Result=PMark[(i+1)%Length];
    3ae8:	78 01       	movw	r14, r16
char i,Result,PMark[5],Length;
     eeprom_read_block((void*)&PMark,(const void*)&DefMarkMap, sizeof(DefMarkMap));
	 Length=sizeof(DefMarkMap);
	 Result=InMark;
     for(i=0;i<Length;i++){
	     if (InMark==PMark[i])
    3aea:	d8 01       	movw	r26, r16
    3aec:	8c 91       	ld	r24, X
    3aee:	d8 16       	cp	r13, r24
    3af0:	49 f4       	brne	.+18     	; 0x3b04 <SelectMark+0x54>
		     Result=PMark[(i+1)%Length];
    3af2:	c9 01       	movw	r24, r18
    3af4:	65 e0       	ldi	r22, 0x05	; 5
    3af6:	70 e0       	ldi	r23, 0x00	; 0
    3af8:	0e 94 4c b7 	call	0x16e98	; 0x16e98 <__divmodhi4>
    3afc:	f7 01       	movw	r30, r14
    3afe:	e8 0f       	add	r30, r24
    3b00:	f9 1f       	adc	r31, r25
    3b02:	e0 81       	ld	r30, Z
    3b04:	0f 5f       	subi	r16, 0xFF	; 255
    3b06:	1f 4f       	sbci	r17, 0xFF	; 255
    3b08:	2f 5f       	subi	r18, 0xFF	; 255
    3b0a:	3f 4f       	sbci	r19, 0xFF	; 255
char SelectMark(char InMark){
char i,Result,PMark[5],Length;
     eeprom_read_block((void*)&PMark,(const void*)&DefMarkMap, sizeof(DefMarkMap));
	 Length=sizeof(DefMarkMap);
	 Result=InMark;
     for(i=0;i<Length;i++){
    3b0c:	26 30       	cpi	r18, 0x06	; 6
    3b0e:	31 05       	cpc	r19, r1
    3b10:	61 f7       	brne	.-40     	; 0x3aea <SelectMark+0x3a>
	     if (InMark==PMark[i])
		     Result=PMark[(i+1)%Length];
	 }
     return Result;
}
    3b12:	8e 2f       	mov	r24, r30
    3b14:	0f 90       	pop	r0
    3b16:	0f 90       	pop	r0
    3b18:	0f 90       	pop	r0
    3b1a:	0f 90       	pop	r0
    3b1c:	0f 90       	pop	r0
    3b1e:	cf 91       	pop	r28
    3b20:	df 91       	pop	r29
    3b22:	1f 91       	pop	r17
    3b24:	0f 91       	pop	r16
    3b26:	ff 90       	pop	r15
    3b28:	ef 90       	pop	r14
    3b2a:	df 90       	pop	r13
    3b2c:	08 95       	ret

00003b2e <UpdateServerIP>:
	 for(i=0;i<4;i++){
	     zeroIP(IP_blok[i],strIP[i]);
	 }
     sprintf_P(strClientIP,PSTR("%s.%s.%s.%s"),strIP[0],strIP[1],strIP[2],strIP[3]);
}
void UpdateServerIP(){     
    3b2e:	cf 92       	push	r12
    3b30:	df 92       	push	r13
    3b32:	ef 92       	push	r14
    3b34:	ff 92       	push	r15
    3b36:	0f 93       	push	r16
    3b38:	1f 93       	push	r17
    3b3a:	df 93       	push	r29
    3b3c:	cf 93       	push	r28
    3b3e:	cd b7       	in	r28, 0x3d	; 61
    3b40:	de b7       	in	r29, 0x3e	; 62
    3b42:	64 97       	sbiw	r28, 0x14	; 20
    3b44:	0f b6       	in	r0, 0x3f	; 63
    3b46:	f8 94       	cli
    3b48:	de bf       	out	0x3e, r29	; 62
    3b4a:	0f be       	out	0x3f, r0	; 63
    3b4c:	cd bf       	out	0x3d, r28	; 61
    3b4e:	8e 01       	movw	r16, r28
    3b50:	0f 5f       	subi	r16, 0xFF	; 255
    3b52:	1f 4f       	sbci	r17, 0xFF	; 255
    3b54:	c8 01       	movw	r24, r16
    3b56:	6c e2       	ldi	r22, 0x2C	; 44
    3b58:	70 e0       	ldi	r23, 0x00	; 0
    3b5a:	44 e0       	ldi	r20, 0x04	; 4
    3b5c:	50 e0       	ldi	r21, 0x00	; 0
    3b5e:	23 ef       	ldi	r18, 0xF3	; 243
    3b60:	32 e1       	ldi	r19, 0x12	; 18
    3b62:	0e 94 1f b4 	call	0x1683e	; 0x1683e <__eerd_block>
    3b66:	78 01       	movw	r14, r16
    3b68:	8e 01       	movw	r16, r28
    3b6a:	0b 5f       	subi	r16, 0xFB	; 251
    3b6c:	1f 4f       	sbci	r17, 0xFF	; 255
	 char strIP[4][4];
	 //192.168.016.180
     eeprom_read_block((void*)&IP_blok,(const void*)&DefServerIP,4);

	 for(i=0;i<4;i++){
	     zeroIP(IP_blok[i],strIP[i]);
    3b6e:	68 01       	movw	r12, r16
    3b70:	d7 01       	movw	r26, r14
    3b72:	8d 91       	ld	r24, X+
    3b74:	7d 01       	movw	r14, r26
    3b76:	b8 01       	movw	r22, r16
    3b78:	0e 94 c0 16 	call	0x2d80	; 0x2d80 <zeroIP>
    3b7c:	0c 5f       	subi	r16, 0xFC	; 252
    3b7e:	1f 4f       	sbci	r17, 0xFF	; 255
     char i,IP_blok[4];
	 char strIP[4][4];
	 //192.168.016.180
     eeprom_read_block((void*)&IP_blok,(const void*)&DefServerIP,4);

	 for(i=0;i<4;i++){
    3b80:	ec 14       	cp	r14, r12
    3b82:	fd 04       	cpc	r15, r13
    3b84:	a9 f7       	brne	.-22     	; 0x3b70 <UpdateServerIP+0x42>
	     zeroIP(IP_blok[i],strIP[i]);
	 }
		 sprintf_P(strServerIP,PSTR("%s.%s.%s.%s"),strIP[0],strIP[1],strIP[2],strIP[3]);
    3b86:	ed b7       	in	r30, 0x3d	; 61
    3b88:	fe b7       	in	r31, 0x3e	; 62
    3b8a:	3c 97       	sbiw	r30, 0x0c	; 12
    3b8c:	0f b6       	in	r0, 0x3f	; 63
    3b8e:	f8 94       	cli
    3b90:	fe bf       	out	0x3e, r31	; 62
    3b92:	0f be       	out	0x3f, r0	; 63
    3b94:	ed bf       	out	0x3d, r30	; 61
    3b96:	31 96       	adiw	r30, 0x01	; 1
    3b98:	8b ee       	ldi	r24, 0xEB	; 235
    3b9a:	99 e0       	ldi	r25, 0x09	; 9
    3b9c:	ad b7       	in	r26, 0x3d	; 61
    3b9e:	be b7       	in	r27, 0x3e	; 62
    3ba0:	12 96       	adiw	r26, 0x02	; 2
    3ba2:	9c 93       	st	X, r25
    3ba4:	8e 93       	st	-X, r24
    3ba6:	11 97       	sbiw	r26, 0x01	; 1
    3ba8:	8a ef       	ldi	r24, 0xFA	; 250
    3baa:	91 e2       	ldi	r25, 0x21	; 33
    3bac:	93 83       	std	Z+3, r25	; 0x03
    3bae:	82 83       	std	Z+2, r24	; 0x02
    3bb0:	f5 82       	std	Z+5, r15	; 0x05
    3bb2:	e4 82       	std	Z+4, r14	; 0x04
    3bb4:	ce 01       	movw	r24, r28
    3bb6:	09 96       	adiw	r24, 0x09	; 9
    3bb8:	97 83       	std	Z+7, r25	; 0x07
    3bba:	86 83       	std	Z+6, r24	; 0x06
    3bbc:	ce 01       	movw	r24, r28
    3bbe:	0d 96       	adiw	r24, 0x0d	; 13
    3bc0:	91 87       	std	Z+9, r25	; 0x09
    3bc2:	80 87       	std	Z+8, r24	; 0x08
    3bc4:	ce 01       	movw	r24, r28
    3bc6:	41 96       	adiw	r24, 0x11	; 17
    3bc8:	93 87       	std	Z+11, r25	; 0x0b
    3bca:	82 87       	std	Z+10, r24	; 0x0a
    3bcc:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    3bd0:	ed b7       	in	r30, 0x3d	; 61
    3bd2:	fe b7       	in	r31, 0x3e	; 62
    3bd4:	3c 96       	adiw	r30, 0x0c	; 12
    3bd6:	0f b6       	in	r0, 0x3f	; 63
    3bd8:	f8 94       	cli
    3bda:	fe bf       	out	0x3e, r31	; 62
    3bdc:	0f be       	out	0x3f, r0	; 63
    3bde:	ed bf       	out	0x3d, r30	; 61
}
    3be0:	64 96       	adiw	r28, 0x14	; 20
    3be2:	0f b6       	in	r0, 0x3f	; 63
    3be4:	f8 94       	cli
    3be6:	de bf       	out	0x3e, r29	; 62
    3be8:	0f be       	out	0x3f, r0	; 63
    3bea:	cd bf       	out	0x3d, r28	; 61
    3bec:	cf 91       	pop	r28
    3bee:	df 91       	pop	r29
    3bf0:	1f 91       	pop	r17
    3bf2:	0f 91       	pop	r16
    3bf4:	ff 90       	pop	r15
    3bf6:	ef 90       	pop	r14
    3bf8:	df 90       	pop	r13
    3bfa:	cf 90       	pop	r12
    3bfc:	08 95       	ret

00003bfe <UpdateClientIP>:
	     str[0]=('0'+S);
	     str[1]=0;
	 }
}

void UpdateClientIP(){     
    3bfe:	cf 92       	push	r12
    3c00:	df 92       	push	r13
    3c02:	ef 92       	push	r14
    3c04:	ff 92       	push	r15
    3c06:	0f 93       	push	r16
    3c08:	1f 93       	push	r17
    3c0a:	df 93       	push	r29
    3c0c:	cf 93       	push	r28
    3c0e:	cd b7       	in	r28, 0x3d	; 61
    3c10:	de b7       	in	r29, 0x3e	; 62
    3c12:	68 97       	sbiw	r28, 0x18	; 24
    3c14:	0f b6       	in	r0, 0x3f	; 63
    3c16:	f8 94       	cli
    3c18:	de bf       	out	0x3e, r29	; 62
    3c1a:	0f be       	out	0x3f, r0	; 63
    3c1c:	cd bf       	out	0x3d, r28	; 61
    3c1e:	8e 01       	movw	r16, r28
    3c20:	0f 5f       	subi	r16, 0xFF	; 255
    3c22:	1f 4f       	sbci	r17, 0xFF	; 255
    3c24:	c8 01       	movw	r24, r16
    3c26:	68 e2       	ldi	r22, 0x28	; 40
    3c28:	70 e0       	ldi	r23, 0x00	; 0
    3c2a:	44 e0       	ldi	r20, 0x04	; 4
    3c2c:	50 e0       	ldi	r21, 0x00	; 0
    3c2e:	23 ef       	ldi	r18, 0xF3	; 243
    3c30:	32 e1       	ldi	r19, 0x12	; 18
    3c32:	0e 94 1f b4 	call	0x1683e	; 0x1683e <__eerd_block>
    3c36:	78 01       	movw	r14, r16
    3c38:	8e 01       	movw	r16, r28
    3c3a:	0b 5f       	subi	r16, 0xFB	; 251
    3c3c:	1f 4f       	sbci	r17, 0xFF	; 255
	 char strIP[4][5];
	 //192.168.010.002
     eeprom_read_block((void*)&IP_blok,(const void*)&DefClientIP,4);

	 for(i=0;i<4;i++){
	     zeroIP(IP_blok[i],strIP[i]);
    3c3e:	68 01       	movw	r12, r16
    3c40:	d7 01       	movw	r26, r14
    3c42:	8d 91       	ld	r24, X+
    3c44:	7d 01       	movw	r14, r26
    3c46:	b8 01       	movw	r22, r16
    3c48:	0e 94 c0 16 	call	0x2d80	; 0x2d80 <zeroIP>
    3c4c:	0b 5f       	subi	r16, 0xFB	; 251
    3c4e:	1f 4f       	sbci	r17, 0xFF	; 255
     char i,IP_blok[4];
	 char strIP[4][5];
	 //192.168.010.002
     eeprom_read_block((void*)&IP_blok,(const void*)&DefClientIP,4);

	 for(i=0;i<4;i++){
    3c50:	ec 14       	cp	r14, r12
    3c52:	fd 04       	cpc	r15, r13
    3c54:	a9 f7       	brne	.-22     	; 0x3c40 <UpdateClientIP+0x42>
	     zeroIP(IP_blok[i],strIP[i]);
	 }
     sprintf_P(strClientIP,PSTR("%s.%s.%s.%s"),strIP[0],strIP[1],strIP[2],strIP[3]);
    3c56:	ed b7       	in	r30, 0x3d	; 61
    3c58:	fe b7       	in	r31, 0x3e	; 62
    3c5a:	3c 97       	sbiw	r30, 0x0c	; 12
    3c5c:	0f b6       	in	r0, 0x3f	; 63
    3c5e:	f8 94       	cli
    3c60:	fe bf       	out	0x3e, r31	; 62
    3c62:	0f be       	out	0x3f, r0	; 63
    3c64:	ed bf       	out	0x3d, r30	; 61
    3c66:	31 96       	adiw	r30, 0x01	; 1
    3c68:	8e eb       	ldi	r24, 0xBE	; 190
    3c6a:	99 e0       	ldi	r25, 0x09	; 9
    3c6c:	ad b7       	in	r26, 0x3d	; 61
    3c6e:	be b7       	in	r27, 0x3e	; 62
    3c70:	12 96       	adiw	r26, 0x02	; 2
    3c72:	9c 93       	st	X, r25
    3c74:	8e 93       	st	-X, r24
    3c76:	11 97       	sbiw	r26, 0x01	; 1
    3c78:	86 e0       	ldi	r24, 0x06	; 6
    3c7a:	92 e2       	ldi	r25, 0x22	; 34
    3c7c:	93 83       	std	Z+3, r25	; 0x03
    3c7e:	82 83       	std	Z+2, r24	; 0x02
    3c80:	f5 82       	std	Z+5, r15	; 0x05
    3c82:	e4 82       	std	Z+4, r14	; 0x04
    3c84:	ce 01       	movw	r24, r28
    3c86:	0a 96       	adiw	r24, 0x0a	; 10
    3c88:	97 83       	std	Z+7, r25	; 0x07
    3c8a:	86 83       	std	Z+6, r24	; 0x06
    3c8c:	ce 01       	movw	r24, r28
    3c8e:	0f 96       	adiw	r24, 0x0f	; 15
    3c90:	91 87       	std	Z+9, r25	; 0x09
    3c92:	80 87       	std	Z+8, r24	; 0x08
    3c94:	ce 01       	movw	r24, r28
    3c96:	44 96       	adiw	r24, 0x14	; 20
    3c98:	93 87       	std	Z+11, r25	; 0x0b
    3c9a:	82 87       	std	Z+10, r24	; 0x0a
    3c9c:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    3ca0:	ed b7       	in	r30, 0x3d	; 61
    3ca2:	fe b7       	in	r31, 0x3e	; 62
    3ca4:	3c 96       	adiw	r30, 0x0c	; 12
    3ca6:	0f b6       	in	r0, 0x3f	; 63
    3ca8:	f8 94       	cli
    3caa:	fe bf       	out	0x3e, r31	; 62
    3cac:	0f be       	out	0x3f, r0	; 63
    3cae:	ed bf       	out	0x3d, r30	; 61
}
    3cb0:	68 96       	adiw	r28, 0x18	; 24
    3cb2:	0f b6       	in	r0, 0x3f	; 63
    3cb4:	f8 94       	cli
    3cb6:	de bf       	out	0x3e, r29	; 62
    3cb8:	0f be       	out	0x3f, r0	; 63
    3cba:	cd bf       	out	0x3d, r28	; 61
    3cbc:	cf 91       	pop	r28
    3cbe:	df 91       	pop	r29
    3cc0:	1f 91       	pop	r17
    3cc2:	0f 91       	pop	r16
    3cc4:	ff 90       	pop	r15
    3cc6:	ef 90       	pop	r14
    3cc8:	df 90       	pop	r13
    3cca:	cf 90       	pop	r12
    3ccc:	08 95       	ret

00003cce <GenerateStandaloneTransData>:

     eeprom_write_block((const void*)&PTransNum,(void*)&DefTransactionNumber,sizeof(DefTransactionNumber));
}


char GenerateStandaloneTransData(char xPumpID, char *PNozzle){//[1,2,3..16]->[1,2,3..0]
    3cce:	cf 92       	push	r12
    3cd0:	df 92       	push	r13
    3cd2:	ef 92       	push	r14
    3cd4:	ff 92       	push	r15
    3cd6:	0f 93       	push	r16
    3cd8:	1f 93       	push	r17
    3cda:	df 93       	push	r29
    3cdc:	cf 93       	push	r28
    3cde:	cd b7       	in	r28, 0x3d	; 61
    3ce0:	de b7       	in	r29, 0x3e	; 62
    3ce2:	2f 97       	sbiw	r28, 0x0f	; 15
    3ce4:	0f b6       	in	r0, 0x3f	; 63
    3ce6:	f8 94       	cli
    3ce8:	de bf       	out	0x3e, r29	; 62
    3cea:	0f be       	out	0x3f, r0	; 63
    3cec:	cd bf       	out	0x3d, r28	; 61
    3cee:	e8 2e       	mov	r14, r24
    3cf0:	8b 01       	movw	r16, r22
     char Result=GS_NONE;
	 char strSend[30];
	 char FIPAddr;

	 iPumpID=(xPumpID&0x0F);
	 FIPAddr=GetFIPAddr(iPumpID);
    3cf2:	8f 70       	andi	r24, 0x0F	; 15
    3cf4:	0e 94 39 1c 	call	0x3872	; 0x3872 <GetFIPAddr>
     if (FIPAddr>0){
    3cf8:	88 23       	and	r24, r24
    3cfa:	09 f4       	brne	.+2      	; 0x3cfe <GenerateStandaloneTransData+0x30>
    3cfc:	2d c1       	rjmp	.+602    	; 0x3f58 <GenerateStandaloneTransData+0x28a>
	     FIPAddr=FIPAddr-1;
		 iProdID=PNozzle[RecPumpData[FIPAddr].Grade];
    3cfe:	81 50       	subi	r24, 0x01	; 1
    3d00:	c8 2e       	mov	r12, r24
    3d02:	dd 24       	eor	r13, r13
    3d04:	85 e3       	ldi	r24, 0x35	; 53
    3d06:	90 e0       	ldi	r25, 0x00	; 0
    3d08:	c8 9e       	mul	r12, r24
    3d0a:	f0 01       	movw	r30, r0
    3d0c:	c9 9e       	mul	r12, r25
    3d0e:	f0 0d       	add	r31, r0
    3d10:	d8 9e       	mul	r13, r24
    3d12:	f0 0d       	add	r31, r0
    3d14:	11 24       	eor	r1, r1
    3d16:	e5 57       	subi	r30, 0x75	; 117
    3d18:	f8 4f       	sbci	r31, 0xF8	; 248
    3d1a:	80 81       	ld	r24, Z
    3d1c:	08 0f       	add	r16, r24
    3d1e:	11 1d       	adc	r17, r1
    3d20:	d8 01       	movw	r26, r16
    3d22:	2c 91       	ld	r18, X
    3d24:	ce 01       	movw	r24, r28
    3d26:	01 96       	adiw	r24, 0x01	; 1

		 if (iProdID>0) eeprom_read_block((void*) &ProductName, (const void*) &DefProductName[iProdID-1],sizeof(DefProductName[iProdID-1]));
    3d28:	22 23       	and	r18, r18
    3d2a:	69 f0       	breq	.+26     	; 0x3d46 <GenerateStandaloneTransData+0x78>
    3d2c:	6d e0       	ldi	r22, 0x0D	; 13
    3d2e:	26 9f       	mul	r18, r22
    3d30:	b0 01       	movw	r22, r0
    3d32:	11 24       	eor	r1, r1
    3d34:	62 55       	subi	r22, 0x52	; 82
    3d36:	7f 4f       	sbci	r23, 0xFF	; 255
    3d38:	4d e0       	ldi	r20, 0x0D	; 13
    3d3a:	50 e0       	ldi	r21, 0x00	; 0
    3d3c:	23 ef       	ldi	r18, 0xF3	; 243
    3d3e:	32 e1       	ldi	r19, 0x12	; 18
    3d40:	0e 94 1f b4 	call	0x1683e	; 0x1683e <__eerd_block>
    3d44:	10 c0       	rjmp	.+32     	; 0x3d66 <GenerateStandaloneTransData+0x98>
		 else sprintf_P(ProductName,PSTR("N/A"));
    3d46:	00 d0       	rcall	.+0      	; 0x3d48 <GenerateStandaloneTransData+0x7a>
    3d48:	00 d0       	rcall	.+0      	; 0x3d4a <GenerateStandaloneTransData+0x7c>
    3d4a:	ed b7       	in	r30, 0x3d	; 61
    3d4c:	fe b7       	in	r31, 0x3e	; 62
    3d4e:	92 83       	std	Z+2, r25	; 0x02
    3d50:	81 83       	std	Z+1, r24	; 0x01
    3d52:	87 eb       	ldi	r24, 0xB7	; 183
    3d54:	92 e2       	ldi	r25, 0x22	; 34
    3d56:	94 83       	std	Z+4, r25	; 0x04
    3d58:	83 83       	std	Z+3, r24	; 0x03
    3d5a:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    3d5e:	0f 90       	pop	r0
    3d60:	0f 90       	pop	r0
    3d62:	0f 90       	pop	r0
    3d64:	0f 90       	pop	r0
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    3d66:	e1 99       	sbic	0x1c, 1	; 28
    3d68:	fe cf       	rjmp	.-4      	; 0x3d66 <GenerateStandaloneTransData+0x98>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    3d6a:	80 e0       	ldi	r24, 0x00	; 0
    3d6c:	90 e0       	ldi	r25, 0x00	; 0
    3d6e:	9f bb       	out	0x1f, r25	; 31
    3d70:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    3d72:	e0 9a       	sbi	0x1c, 0	; 28
    3d74:	fd b2       	in	r15, 0x1d	; 29

		 TermID=eeprom_read_byte(&DefIFT_ID);

		 //Shift,TransNum,Date,Time
		 sprintf_P(strShift,PSTR("%d"),RecPumpData[FIPAddr].Shift);
    3d76:	00 d0       	rcall	.+0      	; 0x3d78 <GenerateStandaloneTransData+0xaa>
    3d78:	00 d0       	rcall	.+0      	; 0x3d7a <GenerateStandaloneTransData+0xac>
    3d7a:	00 d0       	rcall	.+0      	; 0x3d7c <GenerateStandaloneTransData+0xae>
    3d7c:	ad b7       	in	r26, 0x3d	; 61
    3d7e:	be b7       	in	r27, 0x3e	; 62
    3d80:	11 96       	adiw	r26, 0x01	; 1
    3d82:	83 e4       	ldi	r24, 0x43	; 67
    3d84:	9e e0       	ldi	r25, 0x0E	; 14
    3d86:	ed b7       	in	r30, 0x3d	; 61
    3d88:	fe b7       	in	r31, 0x3e	; 62
    3d8a:	92 83       	std	Z+2, r25	; 0x02
    3d8c:	81 83       	std	Z+1, r24	; 0x01
    3d8e:	84 eb       	ldi	r24, 0xB4	; 180
    3d90:	92 e2       	ldi	r25, 0x22	; 34
    3d92:	13 96       	adiw	r26, 0x03	; 3
    3d94:	9c 93       	st	X, r25
    3d96:	8e 93       	st	-X, r24
    3d98:	12 97       	sbiw	r26, 0x02	; 2
    3d9a:	85 e3       	ldi	r24, 0x35	; 53
    3d9c:	90 e0       	ldi	r25, 0x00	; 0
    3d9e:	c8 9e       	mul	r12, r24
    3da0:	80 01       	movw	r16, r0
    3da2:	c9 9e       	mul	r12, r25
    3da4:	10 0d       	add	r17, r0
    3da6:	d8 9e       	mul	r13, r24
    3da8:	10 0d       	add	r17, r0
    3daa:	11 24       	eor	r1, r1
    3dac:	f8 01       	movw	r30, r16
    3dae:	e5 57       	subi	r30, 0x75	; 117
    3db0:	f8 4f       	sbci	r31, 0xF8	; 248
    3db2:	82 81       	ldd	r24, Z+2	; 0x02
    3db4:	14 96       	adiw	r26, 0x04	; 4
    3db6:	8c 93       	st	X, r24
    3db8:	14 97       	sbiw	r26, 0x04	; 4
    3dba:	15 96       	adiw	r26, 0x05	; 5
    3dbc:	1c 92       	st	X, r1
    3dbe:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
		 sprintf_P(strTranNo,PSTR("%s"),RecPumpData[FIPAddr].strTransNum);
    3dc2:	ed b7       	in	r30, 0x3d	; 61
    3dc4:	fe b7       	in	r31, 0x3e	; 62
    3dc6:	31 96       	adiw	r30, 0x01	; 1
    3dc8:	81 e6       	ldi	r24, 0x61	; 97
    3dca:	9e e0       	ldi	r25, 0x0E	; 14
    3dcc:	ad b7       	in	r26, 0x3d	; 61
    3dce:	be b7       	in	r27, 0x3e	; 62
    3dd0:	12 96       	adiw	r26, 0x02	; 2
    3dd2:	9c 93       	st	X, r25
    3dd4:	8e 93       	st	-X, r24
    3dd6:	11 97       	sbiw	r26, 0x01	; 1
    3dd8:	81 eb       	ldi	r24, 0xB1	; 177
    3dda:	92 e2       	ldi	r25, 0x22	; 34
    3ddc:	93 83       	std	Z+3, r25	; 0x03
    3dde:	82 83       	std	Z+2, r24	; 0x02
    3de0:	c8 01       	movw	r24, r16
    3de2:	82 57       	subi	r24, 0x72	; 114
    3de4:	98 4f       	sbci	r25, 0xF8	; 248
    3de6:	95 83       	std	Z+5, r25	; 0x05
    3de8:	84 83       	std	Z+4, r24	; 0x04
    3dea:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
	     sprintf_P(strDate,PSTR("%s"),RecPumpData[FIPAddr].strTransDate);
    3dee:	ed b7       	in	r30, 0x3d	; 61
    3df0:	fe b7       	in	r31, 0x3e	; 62
    3df2:	31 96       	adiw	r30, 0x01	; 1
    3df4:	81 e5       	ldi	r24, 0x51	; 81
    3df6:	99 e0       	ldi	r25, 0x09	; 9
    3df8:	ad b7       	in	r26, 0x3d	; 61
    3dfa:	be b7       	in	r27, 0x3e	; 62
    3dfc:	12 96       	adiw	r26, 0x02	; 2
    3dfe:	9c 93       	st	X, r25
    3e00:	8e 93       	st	-X, r24
    3e02:	11 97       	sbiw	r26, 0x01	; 1
    3e04:	8e ea       	ldi	r24, 0xAE	; 174
    3e06:	92 e2       	ldi	r25, 0x22	; 34
    3e08:	93 83       	std	Z+3, r25	; 0x03
    3e0a:	82 83       	std	Z+2, r24	; 0x02
    3e0c:	c8 01       	movw	r24, r16
    3e0e:	8b 56       	subi	r24, 0x6B	; 107
    3e10:	98 4f       	sbci	r25, 0xF8	; 248
    3e12:	95 83       	std	Z+5, r25	; 0x05
    3e14:	84 83       	std	Z+4, r24	; 0x04
    3e16:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
		 sprintf_P(strTime,PSTR("%s"),RecPumpData[FIPAddr].strTransTime);	 
    3e1a:	ed b7       	in	r30, 0x3d	; 61
    3e1c:	fe b7       	in	r31, 0x3e	; 62
    3e1e:	31 96       	adiw	r30, 0x01	; 1
    3e20:	8d e2       	ldi	r24, 0x2D	; 45
    3e22:	95 e0       	ldi	r25, 0x05	; 5
    3e24:	ad b7       	in	r26, 0x3d	; 61
    3e26:	be b7       	in	r27, 0x3e	; 62
    3e28:	12 96       	adiw	r26, 0x02	; 2
    3e2a:	9c 93       	st	X, r25
    3e2c:	8e 93       	st	-X, r24
    3e2e:	11 97       	sbiw	r26, 0x01	; 1
    3e30:	8b ea       	ldi	r24, 0xAB	; 171
    3e32:	92 e2       	ldi	r25, 0x22	; 34
    3e34:	93 83       	std	Z+3, r25	; 0x03
    3e36:	82 83       	std	Z+2, r24	; 0x02
    3e38:	c8 01       	movw	r24, r16
    3e3a:	82 56       	subi	r24, 0x62	; 98
    3e3c:	98 4f       	sbci	r25, 0xF8	; 248
    3e3e:	95 83       	std	Z+5, r25	; 0x05
    3e40:	84 83       	std	Z+4, r24	; 0x04
    3e42:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>

	     //TermID,FIP_ID,Product
		 sprintf_P(strIslandID,PSTR("%d"),TermID);
    3e46:	ed b7       	in	r30, 0x3d	; 61
    3e48:	fe b7       	in	r31, 0x3e	; 62
    3e4a:	31 96       	adiw	r30, 0x01	; 1
    3e4c:	8f ec       	ldi	r24, 0xCF	; 207
    3e4e:	9a e0       	ldi	r25, 0x0A	; 10
    3e50:	ad b7       	in	r26, 0x3d	; 61
    3e52:	be b7       	in	r27, 0x3e	; 62
    3e54:	12 96       	adiw	r26, 0x02	; 2
    3e56:	9c 93       	st	X, r25
    3e58:	8e 93       	st	-X, r24
    3e5a:	11 97       	sbiw	r26, 0x01	; 1
    3e5c:	88 ea       	ldi	r24, 0xA8	; 168
    3e5e:	92 e2       	ldi	r25, 0x22	; 34
    3e60:	93 83       	std	Z+3, r25	; 0x03
    3e62:	82 83       	std	Z+2, r24	; 0x02
    3e64:	f4 82       	std	Z+4, r15	; 0x04
    3e66:	15 82       	std	Z+5, r1	; 0x05
    3e68:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
		 sprintf_P(strFIP_ID,PSTR("%.2d"),xPumpID);
    3e6c:	ed b7       	in	r30, 0x3d	; 61
    3e6e:	fe b7       	in	r31, 0x3e	; 62
    3e70:	31 96       	adiw	r30, 0x01	; 1
    3e72:	8c e9       	ldi	r24, 0x9C	; 156
    3e74:	99 e0       	ldi	r25, 0x09	; 9
    3e76:	ad b7       	in	r26, 0x3d	; 61
    3e78:	be b7       	in	r27, 0x3e	; 62
    3e7a:	12 96       	adiw	r26, 0x02	; 2
    3e7c:	9c 93       	st	X, r25
    3e7e:	8e 93       	st	-X, r24
    3e80:	11 97       	sbiw	r26, 0x01	; 1
    3e82:	83 ea       	ldi	r24, 0xA3	; 163
    3e84:	92 e2       	ldi	r25, 0x22	; 34
    3e86:	93 83       	std	Z+3, r25	; 0x03
    3e88:	82 83       	std	Z+2, r24	; 0x02
    3e8a:	e4 82       	std	Z+4, r14	; 0x04
    3e8c:	15 82       	std	Z+5, r1	; 0x05
    3e8e:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
	     sprintf_P(strDescription,PSTR("%s"),ProductName);
    3e92:	ed b7       	in	r30, 0x3d	; 61
    3e94:	fe b7       	in	r31, 0x3e	; 62
    3e96:	31 96       	adiw	r30, 0x01	; 1
    3e98:	81 e1       	ldi	r24, 0x11	; 17
    3e9a:	9a e0       	ldi	r25, 0x0A	; 10
    3e9c:	ad b7       	in	r26, 0x3d	; 61
    3e9e:	be b7       	in	r27, 0x3e	; 62
    3ea0:	12 96       	adiw	r26, 0x02	; 2
    3ea2:	9c 93       	st	X, r25
    3ea4:	8e 93       	st	-X, r24
    3ea6:	11 97       	sbiw	r26, 0x01	; 1
    3ea8:	80 ea       	ldi	r24, 0xA0	; 160
    3eaa:	92 e2       	ldi	r25, 0x22	; 34
    3eac:	93 83       	std	Z+3, r25	; 0x03
    3eae:	82 83       	std	Z+2, r24	; 0x02
    3eb0:	ce 01       	movw	r24, r28
    3eb2:	01 96       	adiw	r24, 0x01	; 1
    3eb4:	95 83       	std	Z+5, r25	; 0x05
    3eb6:	84 83       	std	Z+4, r24	; 0x04
    3eb8:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>

		 //Price Volume Money
		 sprintf_P(strPrice,PSTR("%s"),RecPumpData[FIPAddr].Price);
    3ebc:	ed b7       	in	r30, 0x3d	; 61
    3ebe:	fe b7       	in	r31, 0x3e	; 62
    3ec0:	31 96       	adiw	r30, 0x01	; 1
    3ec2:	81 e8       	ldi	r24, 0x81	; 129
    3ec4:	97 e0       	ldi	r25, 0x07	; 7
    3ec6:	ad b7       	in	r26, 0x3d	; 61
    3ec8:	be b7       	in	r27, 0x3e	; 62
    3eca:	12 96       	adiw	r26, 0x02	; 2
    3ecc:	9c 93       	st	X, r25
    3ece:	8e 93       	st	-X, r24
    3ed0:	11 97       	sbiw	r26, 0x01	; 1
    3ed2:	8d e9       	ldi	r24, 0x9D	; 157
    3ed4:	92 e2       	ldi	r25, 0x22	; 34
    3ed6:	93 83       	std	Z+3, r25	; 0x03
    3ed8:	82 83       	std	Z+2, r24	; 0x02
    3eda:	c8 01       	movw	r24, r16
    3edc:	89 55       	subi	r24, 0x59	; 89
    3ede:	98 4f       	sbci	r25, 0xF8	; 248
    3ee0:	95 83       	std	Z+5, r25	; 0x05
    3ee2:	84 83       	std	Z+4, r24	; 0x04
    3ee4:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
	     sprintf_P(strVolume,PSTR("%s"),RecPumpData[FIPAddr].Volume);
    3ee8:	ed b7       	in	r30, 0x3d	; 61
    3eea:	fe b7       	in	r31, 0x3e	; 62
    3eec:	31 96       	adiw	r30, 0x01	; 1
    3eee:	85 e5       	ldi	r24, 0x55	; 85
    3ef0:	95 e0       	ldi	r25, 0x05	; 5
    3ef2:	ad b7       	in	r26, 0x3d	; 61
    3ef4:	be b7       	in	r27, 0x3e	; 62
    3ef6:	12 96       	adiw	r26, 0x02	; 2
    3ef8:	9c 93       	st	X, r25
    3efa:	8e 93       	st	-X, r24
    3efc:	11 97       	sbiw	r26, 0x01	; 1
    3efe:	8a e9       	ldi	r24, 0x9A	; 154
    3f00:	92 e2       	ldi	r25, 0x22	; 34
    3f02:	93 83       	std	Z+3, r25	; 0x03
    3f04:	82 83       	std	Z+2, r24	; 0x02
    3f06:	c8 01       	movw	r24, r16
    3f08:	82 55       	subi	r24, 0x52	; 82
    3f0a:	98 4f       	sbci	r25, 0xF8	; 248
    3f0c:	95 83       	std	Z+5, r25	; 0x05
    3f0e:	84 83       	std	Z+4, r24	; 0x04
    3f10:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
		 sprintf_P(strAmount,PSTR("%s"),RecPumpData[FIPAddr].Money);
    3f14:	ed b7       	in	r30, 0x3d	; 61
    3f16:	fe b7       	in	r31, 0x3e	; 62
    3f18:	31 96       	adiw	r30, 0x01	; 1
    3f1a:	8b e8       	ldi	r24, 0x8B	; 139
    3f1c:	9d e0       	ldi	r25, 0x0D	; 13
    3f1e:	ad b7       	in	r26, 0x3d	; 61
    3f20:	be b7       	in	r27, 0x3e	; 62
    3f22:	12 96       	adiw	r26, 0x02	; 2
    3f24:	9c 93       	st	X, r25
    3f26:	8e 93       	st	-X, r24
    3f28:	11 97       	sbiw	r26, 0x01	; 1
    3f2a:	87 e9       	ldi	r24, 0x97	; 151
    3f2c:	92 e2       	ldi	r25, 0x22	; 34
    3f2e:	93 83       	std	Z+3, r25	; 0x03
    3f30:	82 83       	std	Z+2, r24	; 0x02
    3f32:	09 54       	subi	r16, 0x49	; 73
    3f34:	18 4f       	sbci	r17, 0xF8	; 248
    3f36:	15 83       	std	Z+5, r17	; 0x05
    3f38:	04 83       	std	Z+4, r16	; 0x04
    3f3a:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>

		 MOPType=MOP_CASH;
    3f3e:	10 92 cf 01 	sts	0x01CF, r1
	     IsPrinting=True;	 
    3f42:	81 e0       	ldi	r24, 0x01	; 1
    3f44:	80 93 c3 01 	sts	0x01C3, r24
    3f48:	ed b7       	in	r30, 0x3d	; 61
    3f4a:	fe b7       	in	r31, 0x3e	; 62
    3f4c:	36 96       	adiw	r30, 0x06	; 6
    3f4e:	0f b6       	in	r0, 0x3f	; 63
    3f50:	f8 94       	cli
    3f52:	fe bf       	out	0x3e, r31	; 62
    3f54:	0f be       	out	0x3f, r0	; 63
    3f56:	ed bf       	out	0x3d, r30	; 61
	 }
	 //ProductName	 
	 //iProdID=PNozzle[RecPumpData[iPumpID].Nozzle];
	 //BAsedOnGrade
   return Result;
}
    3f58:	2f 96       	adiw	r28, 0x0f	; 15
    3f5a:	0f b6       	in	r0, 0x3f	; 63
    3f5c:	f8 94       	cli
    3f5e:	de bf       	out	0x3e, r29	; 62
    3f60:	0f be       	out	0x3f, r0	; 63
    3f62:	cd bf       	out	0x3d, r28	; 61
    3f64:	cf 91       	pop	r28
    3f66:	df 91       	pop	r29
    3f68:	1f 91       	pop	r17
    3f6a:	0f 91       	pop	r16
    3f6c:	ff 90       	pop	r15
    3f6e:	ef 90       	pop	r14
    3f70:	df 90       	pop	r13
    3f72:	cf 90       	pop	r12
    3f74:	08 95       	ret

00003f76 <PrintStandalone>:
     char Result=PS_NONE;

   return Result;
}

char PrintStandalone(char FIPAddr,char IsReprint){
    3f76:	ef 92       	push	r14
    3f78:	ff 92       	push	r15
    3f7a:	0f 93       	push	r16
    3f7c:	1f 93       	push	r17
    3f7e:	df 93       	push	r29
    3f80:	cf 93       	push	r28
    3f82:	00 d0       	rcall	.+0      	; 0x3f84 <PrintStandalone+0xe>
    3f84:	00 d0       	rcall	.+0      	; 0x3f86 <PrintStandalone+0x10>
    3f86:	00 d0       	rcall	.+0      	; 0x3f88 <PrintStandalone+0x12>
    3f88:	cd b7       	in	r28, 0x3d	; 61
    3f8a:	de b7       	in	r29, 0x3e	; 62
    3f8c:	f8 2e       	mov	r15, r24
    3f8e:	06 2f       	mov	r16, r22
	 char LFIPAddr;
	      
	 Result=PS_NO_DATA;

//	 eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap, 8);
	 iPumpID=GetPumpID(FIPAddr);//PPumpID[FIPAddr-1];
    3f90:	0e 94 ce 1c 	call	0x399c	; 0x399c <GetPumpID>
    3f94:	e8 2e       	mov	r14, r24
     LFIPAddr=GetFIPAddr(iPumpID);
    3f96:	0e 94 39 1c 	call	0x3872	; 0x3872 <GetFIPAddr>
    3f9a:	18 2f       	mov	r17, r24

     if (LFIPAddr>0){
    3f9c:	88 23       	and	r24, r24
    3f9e:	99 f1       	breq	.+102    	; 0x4006 <PrintStandalone+0x90>
	     LFIPAddr=LFIPAddr-1;
	     if ((IsReprint==True)||(iPumpID>0)&&(strPumpStatus[LFIPAddr]==GetPumpStatusLabel(PS_PRINT_READY))){    	 
    3fa0:	01 30       	cpi	r16, 0x01	; 1
    3fa2:	69 f0       	breq	.+26     	; 0x3fbe <PrintStandalone+0x48>
    3fa4:	ee 20       	and	r14, r14
    3fa6:	79 f1       	breq	.+94     	; 0x4006 <PrintStandalone+0x90>
    3fa8:	80 e1       	ldi	r24, 0x10	; 16
    3faa:	0e 94 90 13 	call	0x2720	; 0x2720 <GetPumpStatusLabel>
    3fae:	11 50       	subi	r17, 0x01	; 1
    3fb0:	e1 2f       	mov	r30, r17
    3fb2:	f0 e0       	ldi	r31, 0x00	; 0
    3fb4:	ee 5e       	subi	r30, 0xEE	; 238
    3fb6:	fe 4f       	sbci	r31, 0xFE	; 254
    3fb8:	90 81       	ld	r25, Z
    3fba:	98 17       	cp	r25, r24
    3fbc:	21 f5       	brne	.+72     	; 0x4006 <PrintStandalone+0x90>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    3fbe:	66 e0       	ldi	r22, 0x06	; 6
    3fc0:	f6 9e       	mul	r15, r22
    3fc2:	b0 01       	movw	r22, r0
    3fc4:	11 24       	eor	r1, r1
    3fc6:	61 5b       	subi	r22, 0xB1	; 177
    3fc8:	7f 4f       	sbci	r23, 0xFF	; 255
    3fca:	ce 01       	movw	r24, r28
    3fcc:	01 96       	adiw	r24, 0x01	; 1
    3fce:	46 e0       	ldi	r20, 0x06	; 6
    3fd0:	50 e0       	ldi	r21, 0x00	; 0
    3fd2:	23 ef       	ldi	r18, 0xF3	; 243
    3fd4:	32 e1       	ldi	r19, 0x12	; 18
    3fd6:	0e 94 1f b4 	call	0x1683e	; 0x1683e <__eerd_block>
		     eeprom_read_block((void*) &PProductID, (const void*) &DefNozzleMap[FIPAddr-1], 6);		 
		     if (((ReprintReady[FIPAddr-1]==True))||(IsReprint==False)){
    3fda:	ef 2d       	mov	r30, r15
    3fdc:	f0 e0       	ldi	r31, 0x00	; 0
    3fde:	ef 57       	subi	r30, 0x7F	; 127
    3fe0:	fe 4f       	sbci	r31, 0xFE	; 254
    3fe2:	80 81       	ld	r24, Z
    3fe4:	81 30       	cpi	r24, 0x01	; 1
    3fe6:	19 f0       	breq	.+6      	; 0x3fee <PrintStandalone+0x78>
    3fe8:	00 23       	and	r16, r16
    3fea:	29 f0       	breq	.+10     	; 0x3ff6 <PrintStandalone+0x80>
    3fec:	0c c0       	rjmp	.+24     	; 0x4006 <PrintStandalone+0x90>
			       if (IsReprint==True)IsReprintTicket=True;
    3fee:	01 30       	cpi	r16, 0x01	; 1
    3ff0:	11 f4       	brne	.+4      	; 0x3ff6 <PrintStandalone+0x80>
    3ff2:	00 93 92 01 	sts	0x0192, r16
			       GenerateStandaloneTransData(iPumpID,PProductID);		 			   
    3ff6:	8e 2d       	mov	r24, r14
    3ff8:	be 01       	movw	r22, r28
    3ffa:	6f 5f       	subi	r22, 0xFF	; 255
    3ffc:	7f 4f       	sbci	r23, 0xFF	; 255
    3ffe:	0e 94 67 1e 	call	0x3cce	; 0x3cce <GenerateStandaloneTransData>
    4002:	81 e1       	ldi	r24, 0x11	; 17
    4004:	01 c0       	rjmp	.+2      	; 0x4008 <PrintStandalone+0x92>
    4006:	82 e1       	ldi	r24, 0x12	; 18
			 }//else Result=PS_NO_DATA;
		 }
		 //else Result=PS_NO_DATA;    		    
	 }	
   return Result;
}
    4008:	26 96       	adiw	r28, 0x06	; 6
    400a:	0f b6       	in	r0, 0x3f	; 63
    400c:	f8 94       	cli
    400e:	de bf       	out	0x3e, r29	; 62
    4010:	0f be       	out	0x3f, r0	; 63
    4012:	cd bf       	out	0x3d, r28	; 61
    4014:	cf 91       	pop	r28
    4016:	df 91       	pop	r29
    4018:	1f 91       	pop	r17
    401a:	0f 91       	pop	r16
    401c:	ff 90       	pop	r15
    401e:	ef 90       	pop	r14
    4020:	08 95       	ret

00004022 <SumChecksum>:
	Geniflow[1]=Geniflow[0];
	Geniflow[0]=dataIn;
*/
}

char SumChecksum(char *strChecked){
    4022:	ac 01       	movw	r20, r24
     unsigned int SigmaSum=0;
	 char i,Result;
	 for(i=0;i<strlen(strChecked);i++){
    4024:	dc 01       	movw	r26, r24
    4026:	0d 90       	ld	r0, X+
    4028:	00 20       	and	r0, r0
    402a:	e9 f7       	brne	.-6      	; 0x4026 <SumChecksum+0x4>
    402c:	11 97       	sbiw	r26, 0x01	; 1
    402e:	a8 1b       	sub	r26, r24
    4030:	b9 0b       	sbc	r27, r25
    4032:	20 e0       	ldi	r18, 0x00	; 0
    4034:	30 e0       	ldi	r19, 0x00	; 0
    4036:	90 e0       	ldi	r25, 0x00	; 0
    4038:	06 c0       	rjmp	.+12     	; 0x4046 <SumChecksum+0x24>
	     SigmaSum=SigmaSum+strChecked[i];
    403a:	e4 0f       	add	r30, r20
    403c:	f5 1f       	adc	r31, r21
    403e:	80 81       	ld	r24, Z
    4040:	28 0f       	add	r18, r24
    4042:	31 1d       	adc	r19, r1
}

char SumChecksum(char *strChecked){
     unsigned int SigmaSum=0;
	 char i,Result;
	 for(i=0;i<strlen(strChecked);i++){
    4044:	9f 5f       	subi	r25, 0xFF	; 255
    4046:	e9 2f       	mov	r30, r25
    4048:	f0 e0       	ldi	r31, 0x00	; 0
    404a:	ea 17       	cp	r30, r26
    404c:	fb 07       	cpc	r31, r27
    404e:	a8 f3       	brcs	.-22     	; 0x403a <SumChecksum+0x18>
	     SigmaSum=SigmaSum+strChecked[i];
	 }
	 Result=(SigmaSum%255);
    4050:	c9 01       	movw	r24, r18
    4052:	6f ef       	ldi	r22, 0xFF	; 255
    4054:	70 e0       	ldi	r23, 0x00	; 0
    4056:	0e 94 38 b7 	call	0x16e70	; 0x16e70 <__udivmodhi4>
	 if (Result==0)Result=255;
    405a:	88 23       	and	r24, r24
    405c:	09 f4       	brne	.+2      	; 0x4060 <SumChecksum+0x3e>
    405e:	8f ef       	ldi	r24, 0xFF	; 255
   return Result;
}
    4060:	08 95       	ret

00004062 <IsGeniusCommand>:
	 sprintf_P(strSend,PSTR("%s"),sCSum);
	 _uart_print(1,1,strSend);
*/
}

char IsGeniusCommand(char GCommand){
    4062:	ff 92       	push	r15
    4064:	0f 93       	push	r16
    4066:	1f 93       	push	r17
    4068:	df 93       	push	r29
    406a:	cf 93       	push	r28
    406c:	cd b7       	in	r28, 0x3d	; 61
    406e:	de b7       	in	r29, 0x3e	; 62
    4070:	2a 97       	sbiw	r28, 0x0a	; 10
    4072:	0f b6       	in	r0, 0x3f	; 63
    4074:	f8 94       	cli
    4076:	de bf       	out	0x3e, r29	; 62
    4078:	0f be       	out	0x3f, r0	; 63
    407a:	cd bf       	out	0x3d, r28	; 61
    407c:	f8 2e       	mov	r15, r24
     char i,Result,CommandList[10];
     Result=False;
	 sprintf_P(CommandList,PSTR("CTSRP"));
    407e:	00 d0       	rcall	.+0      	; 0x4080 <IsGeniusCommand+0x1e>
    4080:	00 d0       	rcall	.+0      	; 0x4082 <IsGeniusCommand+0x20>
    4082:	8e 01       	movw	r16, r28
    4084:	0f 5f       	subi	r16, 0xFF	; 255
    4086:	1f 4f       	sbci	r17, 0xFF	; 255
    4088:	ed b7       	in	r30, 0x3d	; 61
    408a:	fe b7       	in	r31, 0x3e	; 62
    408c:	12 83       	std	Z+2, r17	; 0x02
    408e:	01 83       	std	Z+1, r16	; 0x01
    4090:	81 e7       	ldi	r24, 0x71	; 113
    4092:	93 e0       	ldi	r25, 0x03	; 3
    4094:	94 83       	std	Z+4, r25	; 0x04
    4096:	83 83       	std	Z+3, r24	; 0x03
    4098:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
	 for(i=0;i<strlen(CommandList);i++){
    409c:	d8 01       	movw	r26, r16
    409e:	0d 90       	ld	r0, X+
    40a0:	00 20       	and	r0, r0
    40a2:	e9 f7       	brne	.-6      	; 0x409e <IsGeniusCommand+0x3c>
    40a4:	11 97       	sbiw	r26, 0x01	; 1
    40a6:	a0 1b       	sub	r26, r16
    40a8:	b1 0b       	sbc	r27, r17
    40aa:	90 e0       	ldi	r25, 0x00	; 0
    40ac:	0f 90       	pop	r0
    40ae:	0f 90       	pop	r0
    40b0:	0f 90       	pop	r0
    40b2:	0f 90       	pop	r0
	    if (CommandList[i]==GCommand){
    40b4:	98 01       	movw	r18, r16
    40b6:	08 c0       	rjmp	.+16     	; 0x40c8 <IsGeniusCommand+0x66>
    40b8:	e2 0f       	add	r30, r18
    40ba:	f3 1f       	adc	r31, r19
    40bc:	80 81       	ld	r24, Z
    40be:	8f 15       	cp	r24, r15
    40c0:	11 f4       	brne	.+4      	; 0x40c6 <IsGeniusCommand+0x64>
    40c2:	81 e0       	ldi	r24, 0x01	; 1
    40c4:	07 c0       	rjmp	.+14     	; 0x40d4 <IsGeniusCommand+0x72>

char IsGeniusCommand(char GCommand){
     char i,Result,CommandList[10];
     Result=False;
	 sprintf_P(CommandList,PSTR("CTSRP"));
	 for(i=0;i<strlen(CommandList);i++){
    40c6:	9f 5f       	subi	r25, 0xFF	; 255
    40c8:	e9 2f       	mov	r30, r25
    40ca:	f0 e0       	ldi	r31, 0x00	; 0
    40cc:	ea 17       	cp	r30, r26
    40ce:	fb 07       	cpc	r31, r27
    40d0:	98 f3       	brcs	.-26     	; 0x40b8 <IsGeniusCommand+0x56>
    40d2:	80 e0       	ldi	r24, 0x00	; 0
		    Result=True;
			break;
			}
	 }
   return Result;	 
}
    40d4:	2a 96       	adiw	r28, 0x0a	; 10
    40d6:	0f b6       	in	r0, 0x3f	; 63
    40d8:	f8 94       	cli
    40da:	de bf       	out	0x3e, r29	; 62
    40dc:	0f be       	out	0x3f, r0	; 63
    40de:	cd bf       	out	0x3d, r28	; 61
    40e0:	cf 91       	pop	r28
    40e2:	df 91       	pop	r29
    40e4:	1f 91       	pop	r17
    40e6:	0f 91       	pop	r16
    40e8:	ff 90       	pop	r15
    40ea:	08 95       	ret

000040ec <Pos>:
  return Result;
}
		

//Genius Protocol Version:1.0 AKR
int Pos(char *Substr, char *String){//1245:4645
    40ec:	0f 93       	push	r16
    40ee:	1f 93       	push	r17
    40f0:	cf 93       	push	r28
    40f2:	df 93       	push	r29
    40f4:	ac 01       	movw	r20, r24
    char i,j,CountMatch;
	char Length,subLen,PosFound;

	Length=strlen(String);
    40f6:	fb 01       	movw	r30, r22
    40f8:	01 90       	ld	r0, Z+
    40fa:	00 20       	and	r0, r0
    40fc:	e9 f7       	brne	.-6      	; 0x40f8 <Pos+0xc>
    40fe:	31 97       	sbiw	r30, 0x01	; 1
    4100:	1e 2f       	mov	r17, r30
    4102:	16 1b       	sub	r17, r22
	subLen=strlen(Substr);
    4104:	fc 01       	movw	r30, r24
    4106:	01 90       	ld	r0, Z+
    4108:	00 20       	and	r0, r0
    410a:	e9 f7       	brne	.-6      	; 0x4106 <Pos+0x1a>
    410c:	31 97       	sbiw	r30, 0x01	; 1
    410e:	0e 2f       	mov	r16, r30
    4110:	08 1b       	sub	r16, r24
    4112:	db 01       	movw	r26, r22
    4114:	60 e0       	ldi	r22, 0x00	; 0
    4116:	18 c0       	rjmp	.+48     	; 0x4148 <Pos+0x5c>
	PosFound=Length;
	for(i=0;i<Length;i++){
	    if (String[i]==Substr[0]){
    4118:	9c 91       	ld	r25, X
    411a:	fa 01       	movw	r30, r20
    411c:	80 81       	ld	r24, Z
    411e:	98 17       	cp	r25, r24
    4120:	89 f4       	brne	.+34     	; 0x4144 <Pos+0x58>
    4122:	ed 01       	movw	r28, r26
    4124:	20 e0       	ldi	r18, 0x00	; 0
    4126:	30 e0       	ldi	r19, 0x00	; 0
    4128:	09 c0       	rjmp	.+18     	; 0x413c <Pos+0x50>
		    CountMatch=0;
			for(j=0;j<subLen;j++){
			    //notFound
			    if (Substr[j]==String[i+j]){
    412a:	fa 01       	movw	r30, r20
    412c:	e2 0f       	add	r30, r18
    412e:	f3 1f       	adc	r31, r19
    4130:	90 81       	ld	r25, Z
    4132:	89 91       	ld	r24, Y+
    4134:	2f 5f       	subi	r18, 0xFF	; 255
    4136:	3f 4f       	sbci	r19, 0xFF	; 255
    4138:	98 17       	cp	r25, r24
    413a:	21 f4       	brne	.+8      	; 0x4144 <Pos+0x58>
	subLen=strlen(Substr);
	PosFound=Length;
	for(i=0;i<Length;i++){
	    if (String[i]==Substr[0]){
		    CountMatch=0;
			for(j=0;j<subLen;j++){
    413c:	20 17       	cp	r18, r16
    413e:	a8 f3       	brcs	.-22     	; 0x412a <Pos+0x3e>
    4140:	86 2f       	mov	r24, r22
    4142:	05 c0       	rjmp	.+10     	; 0x414e <Pos+0x62>
	char Length,subLen,PosFound;

	Length=strlen(String);
	subLen=strlen(Substr);
	PosFound=Length;
	for(i=0;i<Length;i++){
    4144:	6f 5f       	subi	r22, 0xFF	; 255
    4146:	11 96       	adiw	r26, 0x01	; 1
    4148:	61 17       	cp	r22, r17
    414a:	30 f3       	brcs	.-52     	; 0x4118 <Pos+0x2c>
    414c:	81 2f       	mov	r24, r17
			    break;  
			}
		}
	}
  return  PosFound;
}
    414e:	90 e0       	ldi	r25, 0x00	; 0
    4150:	df 91       	pop	r29
    4152:	cf 91       	pop	r28
    4154:	1f 91       	pop	r17
    4156:	0f 91       	pop	r16
    4158:	08 95       	ret

0000415a <CreateReport>:
//		  }
//	 }
     *Pos=iPos;
}

void CreateReport(char *strData, char *strPrnBuffer, unsigned int *Pos){
    415a:	7f 92       	push	r7
    415c:	8f 92       	push	r8
    415e:	9f 92       	push	r9
    4160:	af 92       	push	r10
    4162:	bf 92       	push	r11
    4164:	cf 92       	push	r12
    4166:	df 92       	push	r13
    4168:	ef 92       	push	r14
    416a:	ff 92       	push	r15
    416c:	0f 93       	push	r16
    416e:	1f 93       	push	r17
    4170:	cf 93       	push	r28
    4172:	df 93       	push	r29
    4174:	5c 01       	movw	r10, r24
    4176:	6b 01       	movw	r12, r22
    4178:	4a 01       	movw	r8, r20
     unsigned int iPos,PosResult,Length;
	 char i,strSend[20];
	 Length=strlen(strData);
    417a:	ec 01       	movw	r28, r24
    417c:	09 90       	ld	r0, Y+
    417e:	00 20       	and	r0, r0
    4180:	e9 f7       	brne	.-6      	; 0x417c <CreateReport+0x22>
    4182:	21 97       	sbiw	r28, 0x01	; 1
    4184:	c8 1b       	sub	r28, r24
    4186:	d9 0b       	sbc	r29, r25
    4188:	cb 32       	cpi	r28, 0x2B	; 43
    418a:	d1 05       	cpc	r29, r1
    418c:	10 f0       	brcs	.+4      	; 0x4192 <CreateReport+0x38>
    418e:	ca e2       	ldi	r28, 0x2A	; 42
    4190:	d0 e0       	ldi	r29, 0x00	; 0
	 if (Length>BORDER_LENGTH)Length=BORDER_LENGTH;
     
	 iPos=*Pos;
    4192:	f4 01       	movw	r30, r8
    4194:	00 81       	ld	r16, Z
    4196:	11 81       	ldd	r17, Z+1	; 0x01
	 strPrnBuffer[iPos]=GetBorderValue(btVertical);
    4198:	76 01       	movw	r14, r12
    419a:	e0 0e       	add	r14, r16
    419c:	f1 1e       	adc	r15, r17
    419e:	8a e0       	ldi	r24, 0x0A	; 10
    41a0:	0e 94 42 1a 	call	0x3484	; 0x3484 <GetBorderValue>
    41a4:	78 2e       	mov	r7, r24
    41a6:	f7 01       	movw	r30, r14
    41a8:	80 83       	st	Z, r24
     iPos++;
    41aa:	98 01       	movw	r18, r16
    41ac:	2f 5f       	subi	r18, 0xFF	; 255
    41ae:	3f 4f       	sbci	r19, 0xFF	; 255
    41b0:	d7 01       	movw	r26, r14
    41b2:	90 e0       	ldi	r25, 0x00	; 0
    41b4:	07 c0       	rjmp	.+14     	; 0x41c4 <CreateReport+0x6a>

	 for (i=0;i<Length;i++){	      
	      strPrnBuffer[iPos]=strData[i];	      	 
    41b6:	ea 0d       	add	r30, r10
    41b8:	fb 1d       	adc	r31, r11
    41ba:	80 81       	ld	r24, Z
    41bc:	8c 93       	st	X, r24
		  iPos++;
    41be:	2f 5f       	subi	r18, 0xFF	; 255
    41c0:	3f 4f       	sbci	r19, 0xFF	; 255
     
	 iPos=*Pos;
	 strPrnBuffer[iPos]=GetBorderValue(btVertical);
     iPos++;

	 for (i=0;i<Length;i++){	      
    41c2:	9f 5f       	subi	r25, 0xFF	; 255
    41c4:	e9 2f       	mov	r30, r25
    41c6:	f0 e0       	ldi	r31, 0x00	; 0
    41c8:	11 96       	adiw	r26, 0x01	; 1
    41ca:	ec 17       	cp	r30, r28
    41cc:	fd 07       	cpc	r31, r29
    41ce:	98 f3       	brcs	.-26     	; 0x41b6 <CreateReport+0x5c>
    41d0:	62 2f       	mov	r22, r18
	      strPrnBuffer[iPos]=strData[i];	      	 
		  iPos++;
	 }
	 if (Length<BORDER_LENGTH){
    41d2:	ca 32       	cpi	r28, 0x2A	; 42
    41d4:	d1 05       	cpc	r29, r1
    41d6:	91 f0       	breq	.+36     	; 0x41fc <CreateReport+0xa2>
    41d8:	f6 01       	movw	r30, r12
    41da:	e2 0f       	add	r30, r18
    41dc:	f3 1f       	adc	r31, r19
	     for (i=0;i<(BORDER_LENGTH-Length);i++){	      
    41de:	4a e2       	ldi	r20, 0x2A	; 42
    41e0:	50 e0       	ldi	r21, 0x00	; 0
    41e2:	4c 1b       	sub	r20, r28
    41e4:	5d 0b       	sbc	r21, r29
	          strPrnBuffer[iPos]=' ';
    41e6:	70 e2       	ldi	r23, 0x20	; 32
    41e8:	03 c0       	rjmp	.+6      	; 0x41f0 <CreateReport+0x96>
    41ea:	71 93       	st	Z+, r23
		      iPos++;
    41ec:	2f 5f       	subi	r18, 0xFF	; 255
    41ee:	3f 4f       	sbci	r19, 0xFF	; 255
	 for (i=0;i<Length;i++){	      
	      strPrnBuffer[iPos]=strData[i];	      	 
		  iPos++;
	 }
	 if (Length<BORDER_LENGTH){
	     for (i=0;i<(BORDER_LENGTH-Length);i++){	      
    41f0:	82 2f       	mov	r24, r18
    41f2:	86 1b       	sub	r24, r22
    41f4:	90 e0       	ldi	r25, 0x00	; 0
    41f6:	84 17       	cp	r24, r20
    41f8:	95 07       	cpc	r25, r21
    41fa:	b8 f3       	brcs	.-18     	; 0x41ea <CreateReport+0x90>
	          strPrnBuffer[iPos]=' ';
		      iPos++;
	     }	    
	 }
	 strPrnBuffer[iPos]=GetBorderValue(btVertical);
    41fc:	f6 01       	movw	r30, r12
    41fe:	e2 0f       	add	r30, r18
    4200:	f3 1f       	adc	r31, r19
    4202:	70 82       	st	Z, r7
     iPos++;
    4204:	c9 01       	movw	r24, r18
    4206:	01 96       	adiw	r24, 0x01	; 1
     //PosResult=*Pos+Length;
	 strPrnBuffer[iPos]=0x0D; 
    4208:	c8 0e       	add	r12, r24
    420a:	d9 1e       	adc	r13, r25
    420c:	2d e0       	ldi	r18, 0x0D	; 13
    420e:	f6 01       	movw	r30, r12
    4210:	20 83       	st	Z, r18
	 iPos++;

   //*Pos=PosResult+1;
   *Pos=iPos;
    4212:	01 96       	adiw	r24, 0x01	; 1
    4214:	f4 01       	movw	r30, r8
    4216:	91 83       	std	Z+1, r25	; 0x01
    4218:	80 83       	st	Z, r24
    //sprintf_P(strSend,PSTR("Pos:%d"),*Pos);
	//_uart_print(0,1,strSend);
}
    421a:	df 91       	pop	r29
    421c:	cf 91       	pop	r28
    421e:	1f 91       	pop	r17
    4220:	0f 91       	pop	r16
    4222:	ff 90       	pop	r15
    4224:	ef 90       	pop	r14
    4226:	df 90       	pop	r13
    4228:	cf 90       	pop	r12
    422a:	bf 90       	pop	r11
    422c:	af 90       	pop	r10
    422e:	9f 90       	pop	r9
    4230:	8f 90       	pop	r8
    4232:	7f 90       	pop	r7
    4234:	08 95       	ret

00004236 <AddList>:

//AddListTotal(xGrade,strRef1);
void ClearList(char *strList){
     FillChar(strList,strlen(strList),0);
}
void AddList(char GradeId, char *strList){
    4236:	38 2f       	mov	r19, r24
    4238:	ab 01       	movw	r20, r22
     char i,iPos,Length,IsFound=False;	 
	 if ((GradeId>=1)&&((GradeId<=6))){
    423a:	81 50       	subi	r24, 0x01	; 1
    423c:	86 30       	cpi	r24, 0x06	; 6
    423e:	68 f5       	brcc	.+90     	; 0x429a <AddList+0x64>
		 iPos=0;
		 IsFound=False;	
		 Length=strlen(strList);
    4240:	fb 01       	movw	r30, r22
    4242:	01 90       	ld	r0, Z+
    4244:	00 20       	and	r0, r0
    4246:	e9 f7       	brne	.-6      	; 0x4242 <AddList+0xc>
    4248:	31 97       	sbiw	r30, 0x01	; 1
    424a:	e6 1b       	sub	r30, r22
    424c:	f7 0b       	sbc	r31, r23
    424e:	7e 2f       	mov	r23, r30
	     if (Length>0){
    4250:	ee 23       	and	r30, r30
    4252:	11 f4       	brne	.+4      	; 0x4258 <AddList+0x22>
    4254:	20 e0       	ldi	r18, 0x00	; 0
    4256:	14 c0       	rjmp	.+40     	; 0x4280 <AddList+0x4a>
    4258:	80 e0       	ldi	r24, 0x00	; 0
    425a:	90 e0       	ldi	r25, 0x00	; 0
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
	    Result='0'+X;
    425c:	63 2f       	mov	r22, r19
    425e:	60 5d       	subi	r22, 0xD0	; 208
		 Length=strlen(strList);
	     if (Length>0){
			 for (i=0;i<Length;i++){//"123"
			      //_uart(1,1,strList[i]);
			      iPos++;
			      if (strList[i]==Chr(GradeId)){
    4260:	fa 01       	movw	r30, r20
    4262:	e8 0f       	add	r30, r24
    4264:	f9 1f       	adc	r31, r25
    4266:	e0 81       	ld	r30, Z
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    4268:	3a 30       	cpi	r19, 0x0A	; 10
    426a:	10 f0       	brcs	.+4      	; 0x4270 <AddList+0x3a>
    426c:	20 e3       	ldi	r18, 0x30	; 48
    426e:	01 c0       	rjmp	.+2      	; 0x4272 <AddList+0x3c>
	    Result='0'+X;
    4270:	26 2f       	mov	r18, r22
		 Length=strlen(strList);
	     if (Length>0){
			 for (i=0;i<Length;i++){//"123"
			      //_uart(1,1,strList[i]);
			      iPos++;
			      if (strList[i]==Chr(GradeId)){
    4272:	e2 17       	cp	r30, r18
    4274:	91 f0       	breq	.+36     	; 0x429a <AddList+0x64>
    4276:	28 2f       	mov	r18, r24
    4278:	2f 5f       	subi	r18, 0xFF	; 255
    427a:	01 96       	adiw	r24, 0x01	; 1
	 if ((GradeId>=1)&&((GradeId<=6))){
		 iPos=0;
		 IsFound=False;	
		 Length=strlen(strList);
	     if (Length>0){
			 for (i=0;i<Length;i++){//"123"
    427c:	87 17       	cp	r24, r23
    427e:	80 f3       	brcs	.-32     	; 0x4260 <AddList+0x2a>
					  break;
				  }
			 }
	     }
		 if (IsFound==False){
		     strList[iPos]=Chr(GradeId);
    4280:	62 2f       	mov	r22, r18
    4282:	70 e0       	ldi	r23, 0x00	; 0
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    4284:	3a 30       	cpi	r19, 0x0A	; 10
    4286:	10 f0       	brcs	.+4      	; 0x428c <AddList+0x56>
    4288:	80 e3       	ldi	r24, 0x30	; 48
    428a:	02 c0       	rjmp	.+4      	; 0x4290 <AddList+0x5a>
	    Result='0'+X;
    428c:	83 2f       	mov	r24, r19
    428e:	80 5d       	subi	r24, 0xD0	; 208
					  break;
				  }
			 }
	     }
		 if (IsFound==False){
		     strList[iPos]=Chr(GradeId);
    4290:	fa 01       	movw	r30, r20
    4292:	e6 0f       	add	r30, r22
    4294:	f7 1f       	adc	r31, r23
    4296:	80 83       	st	Z, r24
		     strList[iPos+1]=0;
    4298:	11 82       	std	Z+1, r1	; 0x01
    429a:	08 95       	ret

0000429c <ClearList>:
	 AddSpaceLag(strProductName,10);
}

//AddListTotal(xGrade,strRef1);
void ClearList(char *strList){
     FillChar(strList,strlen(strList),0);
    429c:	dc 01       	movw	r26, r24
    429e:	0d 90       	ld	r0, X+
    42a0:	00 20       	and	r0, r0
    42a2:	e9 f7       	brne	.-6      	; 0x429e <ClearList+0x2>
    42a4:	11 97       	sbiw	r26, 0x01	; 1
    42a6:	a8 1b       	sub	r26, r24
    42a8:	b9 0b       	sbc	r27, r25
    42aa:	20 e0       	ldi	r18, 0x00	; 0
    42ac:	30 e0       	ldi	r19, 0x00	; 0
    42ae:	06 c0       	rjmp	.+12     	; 0x42bc <ClearList+0x20>
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    42b0:	fc 01       	movw	r30, r24
    42b2:	e2 0f       	add	r30, r18
    42b4:	f3 1f       	adc	r31, r19
    42b6:	10 82       	st	Z, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    42b8:	2f 5f       	subi	r18, 0xFF	; 255
    42ba:	3f 4f       	sbci	r19, 0xFF	; 255
    42bc:	2a 17       	cp	r18, r26
    42be:	3b 07       	cpc	r19, r27
    42c0:	b8 f3       	brcs	.-18     	; 0x42b0 <ClearList+0x14>
}

//AddListTotal(xGrade,strRef1);
void ClearList(char *strList){
     FillChar(strList,strlen(strList),0);
}
    42c2:	08 95       	ret

000042c4 <CalcSegmen>:
		 */
		 CalcMultiply(strA,strB,strC);
	 }
}

void CalcSegmen(char *strMain, char cNum, char *strResult){
    42c4:	6f 92       	push	r6
    42c6:	7f 92       	push	r7
    42c8:	8f 92       	push	r8
    42ca:	9f 92       	push	r9
    42cc:	bf 92       	push	r11
    42ce:	cf 92       	push	r12
    42d0:	df 92       	push	r13
    42d2:	ef 92       	push	r14
    42d4:	ff 92       	push	r15
    42d6:	0f 93       	push	r16
    42d8:	1f 93       	push	r17
    42da:	df 93       	push	r29
    42dc:	cf 93       	push	r28
    42de:	cd b7       	in	r28, 0x3d	; 61
    42e0:	de b7       	in	r29, 0x3e	; 62
    42e2:	64 97       	sbiw	r28, 0x14	; 20
    42e4:	0f b6       	in	r0, 0x3f	; 63
    42e6:	f8 94       	cli
    42e8:	de bf       	out	0x3e, r29	; 62
    42ea:	0f be       	out	0x3f, r0	; 63
    42ec:	cd bf       	out	0x3d, r28	; 61
    42ee:	7c 01       	movw	r14, r24
    42f0:	6a 01       	movw	r12, r20
    42f2:	bb 24       	eor	r11, r11
    42f4:	30 e0       	ldi	r19, 0x00	; 0

	 xResNext=0;
     xRes=0;

	 for(i=0;i<strlen(strMain);i++){           
         xCalc=(strMain[strlen(strMain)-1-i]-'0')*(cNum-'0')+xResNext;//Hasil
    42f6:	06 2f       	mov	r16, r22
    42f8:	10 e0       	ldi	r17, 0x00	; 0
    42fa:	00 53       	subi	r16, 0x30	; 48
    42fc:	10 40       	sbci	r17, 0x00	; 0
		 xRes=xCalc%10;
		 xResNext=xCalc/10;
	     tmpResult[i]='0'+xRes;	 
    42fe:	3e 01       	movw	r6, r28
    4300:	08 94       	sec
    4302:	61 1c       	adc	r6, r1
    4304:	71 1c       	adc	r7, r1
		 tmpResult[i+1]=0;
    4306:	62 e0       	ldi	r22, 0x02	; 2
    4308:	86 2e       	mov	r8, r22
    430a:	91 2c       	mov	r9, r1
    430c:	8c 0e       	add	r8, r28
    430e:	9d 1e       	adc	r9, r29
    4310:	24 c0       	rjmp	.+72     	; 0x435a <CalcSegmen+0x96>

	 xResNext=0;
     xRes=0;

	 for(i=0;i<strlen(strMain);i++){           
         xCalc=(strMain[strlen(strMain)-1-i]-'0')*(cNum-'0')+xResNext;//Hasil
    4312:	11 97       	sbiw	r26, 0x01	; 1
    4314:	a4 1b       	sub	r26, r20
    4316:	b5 0b       	sbc	r27, r21
    4318:	ae 0d       	add	r26, r14
    431a:	bf 1d       	adc	r27, r15
    431c:	8c 91       	ld	r24, X
    431e:	90 e0       	ldi	r25, 0x00	; 0
    4320:	c0 97       	sbiw	r24, 0x30	; 48
    4322:	bc 01       	movw	r22, r24
    4324:	60 9f       	mul	r22, r16
    4326:	c0 01       	movw	r24, r0
    4328:	61 9f       	mul	r22, r17
    432a:	90 0d       	add	r25, r0
    432c:	70 9f       	mul	r23, r16
    432e:	90 0d       	add	r25, r0
    4330:	11 24       	eor	r1, r1
    4332:	23 2f       	mov	r18, r19
    4334:	28 0f       	add	r18, r24
		 xRes=xCalc%10;
		 xResNext=xCalc/10;
    4336:	82 2f       	mov	r24, r18
    4338:	6a e0       	ldi	r22, 0x0A	; 10
    433a:	0e 94 1f b7 	call	0x16e3e	; 0x16e3e <__udivmodqi4>
    433e:	38 2f       	mov	r19, r24
	     tmpResult[i]='0'+xRes;	 
    4340:	f3 01       	movw	r30, r6
    4342:	e4 0f       	add	r30, r20
    4344:	f5 1f       	adc	r31, r21
    4346:	82 2f       	mov	r24, r18
    4348:	0e 94 1f b7 	call	0x16e3e	; 0x16e3e <__udivmodqi4>
    434c:	90 5d       	subi	r25, 0xD0	; 208
    434e:	90 83       	st	Z, r25
		 tmpResult[i+1]=0;
    4350:	48 0d       	add	r20, r8
    4352:	59 1d       	adc	r21, r9
    4354:	fa 01       	movw	r30, r20
    4356:	10 82       	st	Z, r1
	 char i,lenR,xCalc,xRes,xResNext,tmpResult[20];

	 xResNext=0;
     xRes=0;

	 for(i=0;i<strlen(strMain);i++){           
    4358:	b3 94       	inc	r11
    435a:	4b 2d       	mov	r20, r11
    435c:	50 e0       	ldi	r21, 0x00	; 0
    435e:	d7 01       	movw	r26, r14
    4360:	0d 90       	ld	r0, X+
    4362:	00 20       	and	r0, r0
    4364:	e9 f7       	brne	.-6      	; 0x4360 <CalcSegmen+0x9c>
    4366:	11 97       	sbiw	r26, 0x01	; 1
    4368:	ae 19       	sub	r26, r14
    436a:	bf 09       	sbc	r27, r15
    436c:	4a 17       	cp	r20, r26
    436e:	5b 07       	cpc	r21, r27
    4370:	80 f2       	brcs	.-96     	; 0x4312 <CalcSegmen+0x4e>
		 xRes=xCalc%10;
		 xResNext=xCalc/10;
	     tmpResult[i]='0'+xRes;	 
		 tmpResult[i+1]=0;
	 }
	 if (xResNext>0){
    4372:	33 23       	and	r19, r19
    4374:	89 f0       	breq	.+34     	; 0x4398 <CalcSegmen+0xd4>
	     lenR=strlen(tmpResult);
    4376:	fe 01       	movw	r30, r28
    4378:	31 96       	adiw	r30, 0x01	; 1
    437a:	df 01       	movw	r26, r30
    437c:	0d 90       	ld	r0, X+
    437e:	00 20       	and	r0, r0
    4380:	e9 f7       	brne	.-6      	; 0x437c <CalcSegmen+0xb8>
    4382:	11 97       	sbiw	r26, 0x01	; 1
	     tmpResult[lenR]='0'+xResNext;
    4384:	ae 1b       	sub	r26, r30
    4386:	b0 e0       	ldi	r27, 0x00	; 0
    4388:	ea 0f       	add	r30, r26
    438a:	fb 1f       	adc	r31, r27
    438c:	30 5d       	subi	r19, 0xD0	; 208
    438e:	30 83       	st	Z, r19
		 tmpResult[lenR+1]=0;	 
    4390:	ac 0f       	add	r26, r28
    4392:	bd 1f       	adc	r27, r29
    4394:	12 96       	adiw	r26, 0x02	; 2
    4396:	1c 92       	st	X, r1
	 }
	 lenR=strlen(tmpResult);
    4398:	de 01       	movw	r26, r28
    439a:	11 96       	adiw	r26, 0x01	; 1
    439c:	fd 01       	movw	r30, r26
    439e:	01 90       	ld	r0, Z+
    43a0:	00 20       	and	r0, r0
    43a2:	e9 f7       	brne	.-6      	; 0x439e <CalcSegmen+0xda>
    43a4:	31 97       	sbiw	r30, 0x01	; 1
    43a6:	9e 2f       	mov	r25, r30
    43a8:	9a 1b       	sub	r25, r26
    43aa:	a9 0f       	add	r26, r25
    43ac:	b1 1d       	adc	r27, r1
    43ae:	f6 01       	movw	r30, r12
    43b0:	02 c0       	rjmp	.+4      	; 0x43b6 <CalcSegmen+0xf2>
	 for (i=0;i<lenR;i++){
	     strResult[i]=tmpResult[lenR-1-i];
    43b2:	8c 91       	ld	r24, X
    43b4:	81 93       	st	Z+, r24
    43b6:	11 97       	sbiw	r26, 0x01	; 1
	     lenR=strlen(tmpResult);
	     tmpResult[lenR]='0'+xResNext;
		 tmpResult[lenR+1]=0;	 
	 }
	 lenR=strlen(tmpResult);
	 for (i=0;i<lenR;i++){
    43b8:	ac 17       	cp	r26, r28
    43ba:	bd 07       	cpc	r27, r29
    43bc:	d1 f7       	brne	.-12     	; 0x43b2 <CalcSegmen+0xee>
	     strResult[i]=tmpResult[lenR-1-i];
	 }
	 strResult[lenR]=0;
    43be:	c9 0e       	add	r12, r25
    43c0:	d1 1c       	adc	r13, r1
    43c2:	f6 01       	movw	r30, r12
    43c4:	10 82       	st	Z, r1
}
    43c6:	64 96       	adiw	r28, 0x14	; 20
    43c8:	0f b6       	in	r0, 0x3f	; 63
    43ca:	f8 94       	cli
    43cc:	de bf       	out	0x3e, r29	; 62
    43ce:	0f be       	out	0x3f, r0	; 63
    43d0:	cd bf       	out	0x3d, r28	; 61
    43d2:	cf 91       	pop	r28
    43d4:	df 91       	pop	r29
    43d6:	1f 91       	pop	r17
    43d8:	0f 91       	pop	r16
    43da:	ff 90       	pop	r15
    43dc:	ef 90       	pop	r14
    43de:	df 90       	pop	r13
    43e0:	cf 90       	pop	r12
    43e2:	bf 90       	pop	r11
    43e4:	9f 90       	pop	r9
    43e6:	8f 90       	pop	r8
    43e8:	7f 90       	pop	r7
    43ea:	6f 90       	pop	r6
    43ec:	08 95       	ret

000043ee <GetMinusPos>:
		  if (KeyChar=='*')stTestCalc=tcInitData;
	      break;	 
	 }
}

char GetMinusPos(char *strNumber){
    43ee:	ac 01       	movw	r20, r24
char i,Result;
     Result=0;
     for(i=0;i<strlen(strNumber);i++){
    43f0:	dc 01       	movw	r26, r24
    43f2:	0d 90       	ld	r0, X+
    43f4:	00 20       	and	r0, r0
    43f6:	e9 f7       	brne	.-6      	; 0x43f2 <GetMinusPos+0x4>
    43f8:	11 97       	sbiw	r26, 0x01	; 1
    43fa:	a8 1b       	sub	r26, r24
    43fc:	b9 0b       	sbc	r27, r25
    43fe:	20 e0       	ldi	r18, 0x00	; 0
    4400:	0a c0       	rjmp	.+20     	; 0x4416 <GetMinusPos+0x28>
	     if (strNumber[i]=='-'){
    4402:	e4 0f       	add	r30, r20
    4404:	f5 1f       	adc	r31, r21
    4406:	80 81       	ld	r24, Z
    4408:	92 2f       	mov	r25, r18
    440a:	9f 5f       	subi	r25, 0xFF	; 255
    440c:	8d 32       	cpi	r24, 0x2D	; 45
    440e:	11 f4       	brne	.+4      	; 0x4414 <GetMinusPos+0x26>
		     Result=i+1;
    4410:	89 2f       	mov	r24, r25
    4412:	08 95       	ret
}

char GetMinusPos(char *strNumber){
char i,Result;
     Result=0;
     for(i=0;i<strlen(strNumber);i++){
    4414:	29 2f       	mov	r18, r25
    4416:	e2 2f       	mov	r30, r18
    4418:	f0 e0       	ldi	r31, 0x00	; 0
    441a:	ea 17       	cp	r30, r26
    441c:	fb 07       	cpc	r31, r27
    441e:	88 f3       	brcs	.-30     	; 0x4402 <GetMinusPos+0x14>
    4420:	80 e0       	ldi	r24, 0x00	; 0
		     Result=i+1;
			 break;
		 }
	 }
  return Result;     
}
    4422:	08 95       	ret

00004424 <IsMinus>:

char IsMinus(char *strNumber){
char i,Result=False;
     Result=False;
	 if (GetMinusPos(strNumber)>0){
    4424:	0e 94 f7 21 	call	0x43ee	; 0x43ee <GetMinusPos>
    4428:	81 11       	cpse	r24, r1
    442a:	81 e0       	ldi	r24, 0x01	; 1
	     Result=True;
	 }     
  return Result;
}
    442c:	08 95       	ret

0000442e <RemoveMinus>:

void RemoveMinus(char *strNumber){
    442e:	cf 93       	push	r28
    4430:	df 93       	push	r29
    4432:	ec 01       	movw	r28, r24
     char MinPos,Length;

     if (IsMinus(strNumber)==True){
    4434:	0e 94 12 22 	call	0x4424	; 0x4424 <IsMinus>
    4438:	81 30       	cpi	r24, 0x01	; 1
    443a:	19 f5       	brne	.+70     	; 0x4482 <RemoveMinus+0x54>
	     MinPos=GetMinusPos(strNumber);
    443c:	ce 01       	movw	r24, r28
    443e:	0e 94 f7 21 	call	0x43ee	; 0x43ee <GetMinusPos>
		 Length=strlen(strNumber);
    4442:	de 01       	movw	r26, r28
    4444:	0d 90       	ld	r0, X+
    4446:	00 20       	and	r0, r0
    4448:	e9 f7       	brne	.-6      	; 0x4444 <RemoveMinus+0x16>
    444a:	11 97       	sbiw	r26, 0x01	; 1
		 StrPosCopy(strNumber,strNumber,MinPos,(Length-MinPos));	      
    444c:	ac 1b       	sub	r26, r28
    444e:	b0 e0       	ldi	r27, 0x00	; 0
    4450:	90 e0       	ldi	r25, 0x00	; 0
    4452:	a8 1b       	sub	r26, r24
    4454:	b9 0b       	sbc	r27, r25
    4456:	ae 01       	movw	r20, r28
    4458:	48 0f       	add	r20, r24
    445a:	59 1f       	adc	r21, r25
    445c:	20 e0       	ldi	r18, 0x00	; 0
    445e:	30 e0       	ldi	r19, 0x00	; 0
    4460:	0a c0       	rjmp	.+20     	; 0x4476 <RemoveMinus+0x48>
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    4462:	be 01       	movw	r22, r28
    4464:	62 0f       	add	r22, r18
    4466:	73 1f       	adc	r23, r19
    4468:	fa 01       	movw	r30, r20
    446a:	81 91       	ld	r24, Z+
    446c:	af 01       	movw	r20, r30
    446e:	fb 01       	movw	r30, r22
    4470:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    4472:	2f 5f       	subi	r18, 0xFF	; 255
    4474:	3f 4f       	sbci	r19, 0xFF	; 255
    4476:	2a 17       	cp	r18, r26
    4478:	3b 07       	cpc	r19, r27
    447a:	98 f3       	brcs	.-26     	; 0x4462 <RemoveMinus+0x34>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    447c:	ac 0f       	add	r26, r28
    447e:	bd 1f       	adc	r27, r29
    4480:	1c 92       	st	X, r1
     if (IsMinus(strNumber)==True){
	     MinPos=GetMinusPos(strNumber);
		 Length=strlen(strNumber);
		 StrPosCopy(strNumber,strNumber,MinPos,(Length-MinPos));	      
	 }
}
    4482:	df 91       	pop	r29
    4484:	cf 91       	pop	r28
    4486:	08 95       	ret

00004488 <IsMoreThan>:
	    Result=c-'0';
	 }
	return Result;
}

char IsMoreThan(char *strA, char *strB){
    4488:	ac 01       	movw	r20, r24
    448a:	27 2f       	mov	r18, r23
     char i,LengthA,LengthB,Result=False;
	 char strSend[20];	 
     //Check Length
	 LengthA=strlen(strA);
    448c:	fc 01       	movw	r30, r24
    448e:	01 90       	ld	r0, Z+
    4490:	00 20       	and	r0, r0
    4492:	e9 f7       	brne	.-6      	; 0x448e <IsMoreThan+0x6>
    4494:	31 97       	sbiw	r30, 0x01	; 1
    4496:	7e 2f       	mov	r23, r30
    4498:	78 1b       	sub	r23, r24
	 LengthB=strlen(strB);
    449a:	a6 2f       	mov	r26, r22
    449c:	b2 2f       	mov	r27, r18
    449e:	fd 01       	movw	r30, r26
    44a0:	01 90       	ld	r0, Z+
    44a2:	00 20       	and	r0, r0
    44a4:	e9 f7       	brne	.-6      	; 0x44a0 <IsMoreThan+0x18>
    44a6:	31 97       	sbiw	r30, 0x01	; 1
    44a8:	e6 1b       	sub	r30, r22
	 Result=False;
	 if (LengthA>LengthB)Result=True;
    44aa:	e7 17       	cp	r30, r23
    44ac:	48 f1       	brcs	.+82     	; 0x4500 <IsMoreThan+0x78>
	 else 
	 if (LengthA==LengthB){          //456755 
    44ae:	7e 17       	cp	r23, r30
    44b0:	49 f5       	brne	.+82     	; 0x4504 <IsMoreThan+0x7c>
    44b2:	86 2f       	mov	r24, r22
    44b4:	92 2f       	mov	r25, r18
    44b6:	9c 01       	movw	r18, r24
    44b8:	d9 01       	movw	r26, r18
    44ba:	20 e0       	ldi	r18, 0x00	; 0
    44bc:	30 e0       	ldi	r19, 0x00	; 0
    44be:	1d c0       	rjmp	.+58     	; 0x44fa <IsMoreThan+0x72>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    44c0:	fa 01       	movw	r30, r20
    44c2:	e2 0f       	add	r30, r18
    44c4:	f3 1f       	adc	r31, r19
    44c6:	e0 81       	ld	r30, Z
    44c8:	e0 53       	subi	r30, 0x30	; 48
    44ca:	ea 30       	cpi	r30, 0x0A	; 10
    44cc:	10 f0       	brcs	.+4      	; 0x44d2 <IsMoreThan+0x4a>
    44ce:	60 e0       	ldi	r22, 0x00	; 0
    44d0:	01 c0       	rjmp	.+2      	; 0x44d4 <IsMoreThan+0x4c>
    44d2:	6e 2f       	mov	r22, r30
	 Result=False;
	 if (LengthA>LengthB)Result=True;
	 else 
	 if (LengthA==LengthB){          //456755 
	     for(i=0;i<LengthA;i++){    //456410   
		     if (Ord(strA[i])>Ord(strB[i])){
    44d4:	8c 91       	ld	r24, X
    44d6:	80 53       	subi	r24, 0x30	; 48
    44d8:	8a 30       	cpi	r24, 0x0A	; 10
    44da:	10 f0       	brcs	.+4      	; 0x44e0 <IsMoreThan+0x58>
    44dc:	90 e0       	ldi	r25, 0x00	; 0
    44de:	01 c0       	rjmp	.+2      	; 0x44e2 <IsMoreThan+0x5a>
    44e0:	98 2f       	mov	r25, r24
    44e2:	96 17       	cp	r25, r22
    44e4:	68 f0       	brcs	.+26     	; 0x4500 <IsMoreThan+0x78>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    44e6:	ea 30       	cpi	r30, 0x0A	; 10
    44e8:	08 f0       	brcs	.+2      	; 0x44ec <IsMoreThan+0x64>
    44ea:	e0 e0       	ldi	r30, 0x00	; 0
	 if (LengthA==LengthB){          //456755 
	     for(i=0;i<LengthA;i++){    //456410   
		     if (Ord(strA[i])>Ord(strB[i])){
			     Result=True;
				 break;
			 }else if (Ord(strA[i])<Ord(strB[i])){
    44ec:	8a 30       	cpi	r24, 0x0A	; 10
    44ee:	10 f4       	brcc	.+4      	; 0x44f4 <IsMoreThan+0x6c>
    44f0:	e8 17       	cp	r30, r24
    44f2:	40 f0       	brcs	.+16     	; 0x4504 <IsMoreThan+0x7c>
    44f4:	2f 5f       	subi	r18, 0xFF	; 255
    44f6:	3f 4f       	sbci	r19, 0xFF	; 255
    44f8:	11 96       	adiw	r26, 0x01	; 1
	 LengthB=strlen(strB);
	 Result=False;
	 if (LengthA>LengthB)Result=True;
	 else 
	 if (LengthA==LengthB){          //456755 
	     for(i=0;i<LengthA;i++){    //456410   
    44fa:	27 17       	cp	r18, r23
    44fc:	08 f3       	brcs	.-62     	; 0x44c0 <IsMoreThan+0x38>
    44fe:	02 c0       	rjmp	.+4      	; 0x4504 <IsMoreThan+0x7c>
    4500:	81 e0       	ldi	r24, 0x01	; 1
    4502:	08 95       	ret
    4504:	80 e0       	ldi	r24, 0x00	; 0
				 break;
			 }			 		 
		 }
	 }
  return Result;
}
    4506:	08 95       	ret

00004508 <IsZerroAll>:
   return Result;
}

char IsZerroAll(char *strZerro){
     char i,Length,nZerro=0,Result;
	 Length=strlen(strZerro);
    4508:	fc 01       	movw	r30, r24
    450a:	01 90       	ld	r0, Z+
    450c:	00 20       	and	r0, r0
    450e:	e9 f7       	brne	.-6      	; 0x450a <IsZerroAll+0x2>
    4510:	31 97       	sbiw	r30, 0x01	; 1
    4512:	e8 1b       	sub	r30, r24
    4514:	dc 01       	movw	r26, r24
    4516:	ae 0f       	add	r26, r30
    4518:	b1 1d       	adc	r27, r1
    451a:	90 e0       	ldi	r25, 0x00	; 0
    451c:	20 e0       	ldi	r18, 0x00	; 0
    451e:	06 c0       	rjmp	.+12     	; 0x452c <IsZerroAll+0x24>
	 nZerro=0;
	 Result=False;
	 for(i=0;i<Length;i++){
	     if (strZerro[Length-i]=='0')nZerro++;
    4520:	8c 91       	ld	r24, X
    4522:	80 33       	cpi	r24, 0x30	; 48
    4524:	09 f4       	brne	.+2      	; 0x4528 <IsZerroAll+0x20>
    4526:	2f 5f       	subi	r18, 0xFF	; 255
char IsZerroAll(char *strZerro){
     char i,Length,nZerro=0,Result;
	 Length=strlen(strZerro);
	 nZerro=0;
	 Result=False;
	 for(i=0;i<Length;i++){
    4528:	9f 5f       	subi	r25, 0xFF	; 255
    452a:	11 97       	sbiw	r26, 0x01	; 1
    452c:	9e 17       	cp	r25, r30
    452e:	c0 f3       	brcs	.-16     	; 0x4520 <IsZerroAll+0x18>
    4530:	80 e0       	ldi	r24, 0x00	; 0
    4532:	2e 17       	cp	r18, r30
    4534:	09 f4       	brne	.+2      	; 0x4538 <IsZerroAll+0x30>
    4536:	81 e0       	ldi	r24, 0x01	; 1
	     if (strZerro[Length-i]=='0')nZerro++;
	 }if (nZerro==Length) Result=True;
  return Result;
}
    4538:	08 95       	ret

0000453a <PstrCopy>:
     _uart(_COM_PRINTER, 1, 0x0D);     
     _uart(_COM_PRINTER, 1, 0x0A);

}

void PstrCopy(char *Dest,char *Source){
    453a:	cf 93       	push	r28
    453c:	df 93       	push	r29
    453e:	20 e0       	ldi	r18, 0x00	; 0
    4540:	08 c0       	rjmp	.+16     	; 0x4552 <PstrCopy+0x18>
     char i=0;
	 for(i=0;i<strlen(Source);i++){
	    Dest[i]=pgm_read_byte(&Source[i]);
    4542:	fb 01       	movw	r30, r22
    4544:	ec 0f       	add	r30, r28
    4546:	fd 1f       	adc	r31, r29
    4548:	e4 91       	lpm	r30, Z+
    454a:	c8 0f       	add	r28, r24
    454c:	d9 1f       	adc	r29, r25
    454e:	e8 83       	st	Y, r30

}

void PstrCopy(char *Dest,char *Source){
     char i=0;
	 for(i=0;i<strlen(Source);i++){
    4550:	2f 5f       	subi	r18, 0xFF	; 255
    4552:	c2 2f       	mov	r28, r18
    4554:	d0 e0       	ldi	r29, 0x00	; 0
    4556:	fb 01       	movw	r30, r22
    4558:	01 90       	ld	r0, Z+
    455a:	00 20       	and	r0, r0
    455c:	e9 f7       	brne	.-6      	; 0x4558 <PstrCopy+0x1e>
    455e:	31 97       	sbiw	r30, 0x01	; 1
    4560:	e6 1b       	sub	r30, r22
    4562:	f7 0b       	sbc	r31, r23
    4564:	ce 17       	cp	r28, r30
    4566:	df 07       	cpc	r29, r31
    4568:	60 f3       	brcs	.-40     	; 0x4542 <PstrCopy+0x8>
	    Dest[i]=pgm_read_byte(&Source[i]);
	 }
}
    456a:	df 91       	pop	r29
    456c:	cf 91       	pop	r28
    456e:	08 95       	ret

00004570 <SpaceOnly>:
	     if (strDecimal[i]==DecPointMark)
		     strDecimal[i]=0;
	 }
}

char SpaceOnly(char *string){
    4570:	ac 01       	movw	r20, r24
     char Result,nChar=0;
	 unsigned int i=0;
	 nChar=0;
	 Result=False;
	 for(i=0;i<strlen(string);i++){
    4572:	dc 01       	movw	r26, r24
    4574:	0d 90       	ld	r0, X+
    4576:	00 20       	and	r0, r0
    4578:	e9 f7       	brne	.-6      	; 0x4574 <SpaceOnly+0x4>
    457a:	11 97       	sbiw	r26, 0x01	; 1
    457c:	a8 1b       	sub	r26, r24
    457e:	b9 0b       	sbc	r27, r25
    4580:	90 e0       	ldi	r25, 0x00	; 0
    4582:	20 e0       	ldi	r18, 0x00	; 0
    4584:	30 e0       	ldi	r19, 0x00	; 0
    4586:	09 c0       	rjmp	.+18     	; 0x459a <SpaceOnly+0x2a>
	    if(string[i]!=' ') nChar++;
    4588:	fa 01       	movw	r30, r20
    458a:	e2 0f       	add	r30, r18
    458c:	f3 1f       	adc	r31, r19
    458e:	80 81       	ld	r24, Z
    4590:	80 32       	cpi	r24, 0x20	; 32
    4592:	09 f0       	breq	.+2      	; 0x4596 <SpaceOnly+0x26>
    4594:	9f 5f       	subi	r25, 0xFF	; 255
char SpaceOnly(char *string){
     char Result,nChar=0;
	 unsigned int i=0;
	 nChar=0;
	 Result=False;
	 for(i=0;i<strlen(string);i++){
    4596:	2f 5f       	subi	r18, 0xFF	; 255
    4598:	3f 4f       	sbci	r19, 0xFF	; 255
    459a:	2a 17       	cp	r18, r26
    459c:	3b 07       	cpc	r19, r27
    459e:	a0 f3       	brcs	.-24     	; 0x4588 <SpaceOnly+0x18>
    45a0:	80 e0       	ldi	r24, 0x00	; 0
    45a2:	99 23       	and	r25, r25
    45a4:	09 f4       	brne	.+2      	; 0x45a8 <SpaceOnly+0x38>
    45a6:	81 e0       	ldi	r24, 0x01	; 1
	 }
	 if (nChar>0) Result=False;
	 else Result=True;

	 return Result;
}
    45a8:	08 95       	ret

000045aa <RemDecimal>:
	 }
}



void RemDecimal(char *strDecimal){//4500.00-->4500
    45aa:	9c 01       	movw	r18, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    45ac:	e1 99       	sbic	0x1c, 1	; 28
    45ae:	fe cf       	rjmp	.-4      	; 0x45ac <RemDecimal+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    45b0:	8e e3       	ldi	r24, 0x3E	; 62
    45b2:	90 e0       	ldi	r25, 0x00	; 0
    45b4:	9f bb       	out	0x1f, r25	; 31
    45b6:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    45b8:	e0 9a       	sbi	0x1c, 0	; 28
    45ba:	5d b3       	in	r21, 0x1d	; 29
    45bc:	40 e0       	ldi	r20, 0x00	; 0
    45be:	08 c0       	rjmp	.+16     	; 0x45d0 <RemDecimal+0x26>
char i,DecPointMark;
     DecPointMark=eeprom_read_byte(&DefDecimalMark);	 

     for(i=0;i<strlen(strDecimal);i++){
	     if (strDecimal[i]==DecPointMark)
    45c0:	f9 01       	movw	r30, r18
    45c2:	e8 0f       	add	r30, r24
    45c4:	f9 1f       	adc	r31, r25
    45c6:	80 81       	ld	r24, Z
    45c8:	85 17       	cp	r24, r21
    45ca:	09 f4       	brne	.+2      	; 0x45ce <RemDecimal+0x24>
		     strDecimal[i]=0;
    45cc:	10 82       	st	Z, r1

void RemDecimal(char *strDecimal){//4500.00-->4500
char i,DecPointMark;
     DecPointMark=eeprom_read_byte(&DefDecimalMark);	 

     for(i=0;i<strlen(strDecimal);i++){
    45ce:	4f 5f       	subi	r20, 0xFF	; 255
    45d0:	84 2f       	mov	r24, r20
    45d2:	90 e0       	ldi	r25, 0x00	; 0
    45d4:	f9 01       	movw	r30, r18
    45d6:	01 90       	ld	r0, Z+
    45d8:	00 20       	and	r0, r0
    45da:	e9 f7       	brne	.-6      	; 0x45d6 <RemDecimal+0x2c>
    45dc:	31 97       	sbiw	r30, 0x01	; 1
    45de:	e2 1b       	sub	r30, r18
    45e0:	f3 0b       	sbc	r31, r19
    45e2:	8e 17       	cp	r24, r30
    45e4:	9f 07       	cpc	r25, r31
    45e6:	60 f3       	brcs	.-40     	; 0x45c0 <RemDecimal+0x16>
	     if (strDecimal[i]==DecPointMark)
		     strDecimal[i]=0;
	 }
}
    45e8:	08 95       	ret

000045ea <GetProductPrice>:
          stGenerateReport=grScanAction;
	      break;
	 }
}
//SaveTotalProduct(xGrade,strDeltaVolume,strDeltaMoney);
void GetProductPrice(char *sPrice,char xPumpID,char xNozzle){
    45ea:	cf 92       	push	r12
    45ec:	df 92       	push	r13
    45ee:	ef 92       	push	r14
    45f0:	ff 92       	push	r15
    45f2:	0f 93       	push	r16
    45f4:	1f 93       	push	r17
    45f6:	df 93       	push	r29
    45f8:	cf 93       	push	r28
    45fa:	cd b7       	in	r28, 0x3d	; 61
    45fc:	de b7       	in	r29, 0x3e	; 62
    45fe:	67 97       	sbiw	r28, 0x17	; 23
    4600:	0f b6       	in	r0, 0x3f	; 63
    4602:	f8 94       	cli
    4604:	de bf       	out	0x3e, r29	; 62
    4606:	0f be       	out	0x3f, r0	; 63
    4608:	cd bf       	out	0x3d, r28	; 61
    460a:	7c 01       	movw	r14, r24
    460c:	d6 2e       	mov	r13, r22
    460e:	c4 2e       	mov	r12, r20
char i,PPumpID[8],PProdID[6],strPrice[9],iPumpID,xProductID;
     sprintf_P(sPrice,PSTR(""));
    4610:	00 d0       	rcall	.+0      	; 0x4612 <GetProductPrice+0x28>
    4612:	00 d0       	rcall	.+0      	; 0x4614 <GetProductPrice+0x2a>
    4614:	ad b7       	in	r26, 0x3d	; 61
    4616:	be b7       	in	r27, 0x3e	; 62
    4618:	12 96       	adiw	r26, 0x02	; 2
    461a:	9c 93       	st	X, r25
    461c:	8e 93       	st	-X, r24
    461e:	11 97       	sbiw	r26, 0x01	; 1
    4620:	8c ef       	ldi	r24, 0xFC	; 252
    4622:	93 e0       	ldi	r25, 0x03	; 3
    4624:	14 96       	adiw	r26, 0x04	; 4
    4626:	9c 93       	st	X, r25
    4628:	8e 93       	st	-X, r24
    462a:	13 97       	sbiw	r26, 0x03	; 3
    462c:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    4630:	0f 90       	pop	r0
    4632:	0f 90       	pop	r0
    4634:	0f 90       	pop	r0
    4636:	0f 90       	pop	r0
    4638:	8e 01       	movw	r16, r28
    463a:	09 5f       	subi	r16, 0xF9	; 249
    463c:	1f 4f       	sbci	r17, 0xFF	; 255
    463e:	c8 01       	movw	r24, r16
    4640:	65 e4       	ldi	r22, 0x45	; 69
    4642:	70 e0       	ldi	r23, 0x00	; 0
    4644:	48 e0       	ldi	r20, 0x08	; 8
    4646:	50 e0       	ldi	r21, 0x00	; 0
    4648:	23 ef       	ldi	r18, 0xF3	; 243
    464a:	32 e1       	ldi	r19, 0x12	; 18
    464c:	0e 94 1f b4 	call	0x1683e	; 0x1683e <__eerd_block>
    4650:	f8 01       	movw	r30, r16
     //FindPumpID
	 eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap,8);
	 iPumpID=0;
	 for(i=0;i<8;i++){
    4652:	9e 01       	movw	r18, r28
    4654:	21 5f       	subi	r18, 0xF1	; 241
    4656:	3f 4f       	sbci	r19, 0xFF	; 255
    4658:	9e 2f       	mov	r25, r30
    465a:	90 1b       	sub	r25, r16
	     if (PPumpID[i]==xPumpID){
    465c:	80 81       	ld	r24, Z
    465e:	8d 15       	cp	r24, r13
    4660:	11 f4       	brne	.+4      	; 0x4666 <GetProductPrice+0x7c>
    4662:	89 2f       	mov	r24, r25
    4664:	05 c0       	rjmp	.+10     	; 0x4670 <GetProductPrice+0x86>
    4666:	31 96       	adiw	r30, 0x01	; 1
char i,PPumpID[8],PProdID[6],strPrice[9],iPumpID,xProductID;
     sprintf_P(sPrice,PSTR(""));
     //FindPumpID
	 eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap,8);
	 iPumpID=0;
	 for(i=0;i<8;i++){
    4668:	e2 17       	cp	r30, r18
    466a:	f3 07       	cpc	r31, r19
    466c:	a9 f7       	brne	.-22     	; 0x4658 <GetProductPrice+0x6e>
    466e:	80 e0       	ldi	r24, 0x00	; 0
	     if (PPumpID[i]==xPumpID){
		     iPumpID=i;
			 break;
		 }	 
	 }
	 if ((iPumpID>=0)&&(xNozzle<6)){
    4670:	b5 e0       	ldi	r27, 0x05	; 5
    4672:	bc 15       	cp	r27, r12
    4674:	08 f4       	brcc	.+2      	; 0x4678 <GetProductPrice+0x8e>
    4676:	41 c0       	rjmp	.+130    	; 0x46fa <GetProductPrice+0x110>
    4678:	66 e0       	ldi	r22, 0x06	; 6
    467a:	86 9f       	mul	r24, r22
    467c:	b0 01       	movw	r22, r0
    467e:	11 24       	eor	r1, r1
    4680:	6b 5a       	subi	r22, 0xAB	; 171
    4682:	7f 4f       	sbci	r23, 0xFF	; 255
    4684:	ce 01       	movw	r24, r28
    4686:	01 96       	adiw	r24, 0x01	; 1
    4688:	46 e0       	ldi	r20, 0x06	; 6
    468a:	50 e0       	ldi	r21, 0x00	; 0
    468c:	23 ef       	ldi	r18, 0xF3	; 243
    468e:	32 e1       	ldi	r19, 0x12	; 18
    4690:	0e 94 1f b4 	call	0x1683e	; 0x1683e <__eerd_block>
         eeprom_read_block((void*) &PProdID,(const void*) &DefNozzleMap[iPumpID],6);
         xProductID=PProdID[xNozzle-1];
		 //Price
		 eeprom_read_block((void*) &strPrice, (const void*) &DefProductPrice[xProductID-1], 9);
		 RemDecimal(strPrice);
    4694:	8e 01       	movw	r16, r28
    4696:	01 5f       	subi	r16, 0xF1	; 241
    4698:	1f 4f       	sbci	r17, 0xFF	; 255
    469a:	fe 01       	movw	r30, r28
    469c:	ec 0d       	add	r30, r12
    469e:	f1 1d       	adc	r31, r1
    46a0:	60 81       	ld	r22, Z
    46a2:	89 e0       	ldi	r24, 0x09	; 9
    46a4:	68 9f       	mul	r22, r24
    46a6:	b0 01       	movw	r22, r0
    46a8:	11 24       	eor	r1, r1
    46aa:	64 58       	subi	r22, 0x84	; 132
    46ac:	7f 4f       	sbci	r23, 0xFF	; 255
    46ae:	c8 01       	movw	r24, r16
    46b0:	49 e0       	ldi	r20, 0x09	; 9
    46b2:	50 e0       	ldi	r21, 0x00	; 0
    46b4:	23 ef       	ldi	r18, 0xF3	; 243
    46b6:	32 e1       	ldi	r19, 0x12	; 18
    46b8:	0e 94 1f b4 	call	0x1683e	; 0x1683e <__eerd_block>
    46bc:	c8 01       	movw	r24, r16
    46be:	0e 94 d5 22 	call	0x45aa	; 0x45aa <RemDecimal>
		 sprintf_P(sPrice,PSTR("%s"),strPrice);
    46c2:	00 d0       	rcall	.+0      	; 0x46c4 <GetProductPrice+0xda>
    46c4:	00 d0       	rcall	.+0      	; 0x46c6 <GetProductPrice+0xdc>
    46c6:	00 d0       	rcall	.+0      	; 0x46c8 <GetProductPrice+0xde>
    46c8:	ed b7       	in	r30, 0x3d	; 61
    46ca:	fe b7       	in	r31, 0x3e	; 62
    46cc:	31 96       	adiw	r30, 0x01	; 1
    46ce:	ad b7       	in	r26, 0x3d	; 61
    46d0:	be b7       	in	r27, 0x3e	; 62
    46d2:	12 96       	adiw	r26, 0x02	; 2
    46d4:	fc 92       	st	X, r15
    46d6:	ee 92       	st	-X, r14
    46d8:	11 97       	sbiw	r26, 0x01	; 1
    46da:	89 ef       	ldi	r24, 0xF9	; 249
    46dc:	93 e0       	ldi	r25, 0x03	; 3
    46de:	93 83       	std	Z+3, r25	; 0x03
    46e0:	82 83       	std	Z+2, r24	; 0x02
    46e2:	15 83       	std	Z+5, r17	; 0x05
    46e4:	04 83       	std	Z+4, r16	; 0x04
    46e6:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    46ea:	ed b7       	in	r30, 0x3d	; 61
    46ec:	fe b7       	in	r31, 0x3e	; 62
    46ee:	36 96       	adiw	r30, 0x06	; 6
    46f0:	0f b6       	in	r0, 0x3f	; 63
    46f2:	f8 94       	cli
    46f4:	fe bf       	out	0x3e, r31	; 62
    46f6:	0f be       	out	0x3f, r0	; 63
    46f8:	ed bf       	out	0x3d, r30	; 61
	 }    
	 //Clear Decimal

}
    46fa:	67 96       	adiw	r28, 0x17	; 23
    46fc:	0f b6       	in	r0, 0x3f	; 63
    46fe:	f8 94       	cli
    4700:	de bf       	out	0x3e, r29	; 62
    4702:	0f be       	out	0x3f, r0	; 63
    4704:	cd bf       	out	0x3d, r28	; 61
    4706:	cf 91       	pop	r28
    4708:	df 91       	pop	r29
    470a:	1f 91       	pop	r17
    470c:	0f 91       	pop	r16
    470e:	ff 90       	pop	r15
    4710:	ef 90       	pop	r14
    4712:	df 90       	pop	r13
    4714:	cf 90       	pop	r12
    4716:	08 95       	ret

00004718 <FormatDate>:
	 }     
   }
}

              //Fmt:DATE_LONG_YEAR,DATE_SHORT_YEAR //0123456789    0123456789 
void FormatDate(char FmtYear, char *Date){         //2010/06/16 -> 16/06/2010
    4718:	df 93       	push	r29
    471a:	cf 93       	push	r28
    471c:	cd b7       	in	r28, 0x3d	; 61
    471e:	de b7       	in	r29, 0x3e	; 62
    4720:	2b 97       	sbiw	r28, 0x0b	; 11
    4722:	0f b6       	in	r0, 0x3f	; 63
    4724:	f8 94       	cli
    4726:	de bf       	out	0x3e, r29	; 62
    4728:	0f be       	out	0x3f, r0	; 63
    472a:	cd bf       	out	0x3d, r28	; 61
    472c:	98 2f       	mov	r25, r24
    472e:	9b 01       	movw	r18, r22
     char i,sDate[11];

     sDate[0]=Date[8];
    4730:	fb 01       	movw	r30, r22
    4732:	80 85       	ldd	r24, Z+8	; 0x08
    4734:	89 83       	std	Y+1, r24	; 0x01
	 sDate[1]=Date[9];
    4736:	81 85       	ldd	r24, Z+9	; 0x09
    4738:	8a 83       	std	Y+2, r24	; 0x02
     sDate[2]=Date[7];
    473a:	87 81       	ldd	r24, Z+7	; 0x07
    473c:	8b 83       	std	Y+3, r24	; 0x03
	 sDate[3]=Date[5];
    473e:	85 81       	ldd	r24, Z+5	; 0x05
    4740:	8c 83       	std	Y+4, r24	; 0x04
     sDate[4]=Date[6];
    4742:	86 81       	ldd	r24, Z+6	; 0x06
    4744:	8d 83       	std	Y+5, r24	; 0x05
	 sDate[5]=Date[4];
    4746:	84 81       	ldd	r24, Z+4	; 0x04
    4748:	8e 83       	std	Y+6, r24	; 0x06
	 switch(FmtYear){
    474a:	99 23       	and	r25, r25
    474c:	19 f0       	breq	.+6      	; 0x4754 <FormatDate+0x3c>
    474e:	91 30       	cpi	r25, 0x01	; 1
    4750:	59 f4       	brne	.+22     	; 0x4768 <FormatDate+0x50>
    4752:	0f c0       	rjmp	.+30     	; 0x4772 <FormatDate+0x5a>
	 case DATE_LONG_YEAR:
	 	  for(i=0;i<4;i++)sDate[i+6]=Date[i];
    4754:	fb 01       	movw	r30, r22
    4756:	80 81       	ld	r24, Z
    4758:	8f 83       	std	Y+7, r24	; 0x07
    475a:	81 81       	ldd	r24, Z+1	; 0x01
    475c:	88 87       	std	Y+8, r24	; 0x08
    475e:	82 81       	ldd	r24, Z+2	; 0x02
    4760:	89 87       	std	Y+9, r24	; 0x09
    4762:	83 81       	ldd	r24, Z+3	; 0x03
    4764:	8a 87       	std	Y+10, r24	; 0x0a
          sDate[10]=0;
    4766:	1b 86       	std	Y+11, r1	; 0x0b
    4768:	90 e0       	ldi	r25, 0x00	; 0
	      for(i=0;i<2;i++)sDate[i+6]=Date[i+2];
          sDate[8]=0;
	      break;
	 }
	 //replace
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
    476a:	ae 01       	movw	r20, r28
    476c:	4f 5f       	subi	r20, 0xFF	; 255
    476e:	5f 4f       	sbci	r21, 0xFF	; 255
    4770:	0f c0       	rjmp	.+30     	; 0x4790 <FormatDate+0x78>
	 case DATE_LONG_YEAR:
	 	  for(i=0;i<4;i++)sDate[i+6]=Date[i];
          sDate[10]=0;
	      break;
	 case DATE_SHORT_YEAR:
	      for(i=0;i<2;i++)sDate[i+6]=Date[i+2];
    4772:	fb 01       	movw	r30, r22
    4774:	82 81       	ldd	r24, Z+2	; 0x02
    4776:	8f 83       	std	Y+7, r24	; 0x07
    4778:	83 81       	ldd	r24, Z+3	; 0x03
    477a:	88 87       	std	Y+8, r24	; 0x08
          sDate[8]=0;
    477c:	19 86       	std	Y+9, r1	; 0x09
    477e:	f4 cf       	rjmp	.-24     	; 0x4768 <FormatDate+0x50>
	      break;
	 }
	 //replace
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
    4780:	f9 01       	movw	r30, r18
    4782:	ea 0f       	add	r30, r26
    4784:	fb 1f       	adc	r31, r27
    4786:	a4 0f       	add	r26, r20
    4788:	b5 1f       	adc	r27, r21
    478a:	8c 91       	ld	r24, X
    478c:	80 83       	st	Z, r24
    478e:	9f 5f       	subi	r25, 0xFF	; 255
    4790:	a9 2f       	mov	r26, r25
    4792:	b0 e0       	ldi	r27, 0x00	; 0
    4794:	fa 01       	movw	r30, r20
    4796:	01 90       	ld	r0, Z+
    4798:	00 20       	and	r0, r0
    479a:	e9 f7       	brne	.-6      	; 0x4796 <FormatDate+0x7e>
    479c:	31 97       	sbiw	r30, 0x01	; 1
    479e:	e4 1b       	sub	r30, r20
    47a0:	f5 0b       	sbc	r31, r21
    47a2:	ae 17       	cp	r26, r30
    47a4:	bf 07       	cpc	r27, r31
    47a6:	60 f3       	brcs	.-40     	; 0x4780 <FormatDate+0x68>
}
    47a8:	2b 96       	adiw	r28, 0x0b	; 11
    47aa:	0f b6       	in	r0, 0x3f	; 63
    47ac:	f8 94       	cli
    47ae:	de bf       	out	0x3e, r29	; 62
    47b0:	0f be       	out	0x3f, r0	; 63
    47b2:	cd bf       	out	0x3d, r28	; 61
    47b4:	cf 91       	pop	r28
    47b6:	df 91       	pop	r29
    47b8:	08 95       	ret

000047ba <RemZeroLead>:

	while (1){};
  #endif
}

void RemZeroLead(char *Zeroed){//Remove Zero Character 00001004 000050000 0 
    47ba:	cf 93       	push	r28
    47bc:	df 93       	push	r29
    47be:	ec 01       	movw	r28, r24
unsigned char i=0,Length=0,ZeroPos=0,IsFound=False;;
     IsFound=False;
     ZeroPos=0;Length=strlen(Zeroed);
    47c0:	fc 01       	movw	r30, r24
    47c2:	01 90       	ld	r0, Z+
    47c4:	00 20       	and	r0, r0
    47c6:	e9 f7       	brne	.-6      	; 0x47c2 <RemZeroLead+0x8>
    47c8:	31 97       	sbiw	r30, 0x01	; 1
    47ca:	e8 1b       	sub	r30, r24
  if ((Length>1)&&(Zeroed[0]=='0')){
    47cc:	e2 30       	cpi	r30, 0x02	; 2
    47ce:	d0 f1       	brcs	.+116    	; 0x4844 <RemZeroLead+0x8a>
    47d0:	88 81       	ld	r24, Y
    47d2:	80 33       	cpi	r24, 0x30	; 48
    47d4:	b9 f5       	brne	.+110    	; 0x4844 <RemZeroLead+0x8a>
    47d6:	4c 2f       	mov	r20, r28
    47d8:	de 01       	movw	r26, r28
    47da:	90 e0       	ldi	r25, 0x00	; 0
	 if (Zeroed[0]=='0'){
         for(i=0;i<Length;i++){//00000000->0
	         if ((Zeroed[i]=='0')&&(Zeroed[i+1]=='0')&&(IsFound==False)) ZeroPos++;
    47dc:	8c 91       	ld	r24, X
    47de:	80 33       	cpi	r24, 0x30	; 48
    47e0:	69 f4       	brne	.+26     	; 0x47fc <RemZeroLead+0x42>
    47e2:	11 96       	adiw	r26, 0x01	; 1
    47e4:	8c 91       	ld	r24, X
    47e6:	11 97       	sbiw	r26, 0x01	; 1
    47e8:	80 33       	cpi	r24, 0x30	; 48
    47ea:	11 f4       	brne	.+4      	; 0x47f0 <RemZeroLead+0x36>
    47ec:	9f 5f       	subi	r25, 0xFF	; 255
    47ee:	06 c0       	rjmp	.+12     	; 0x47fc <RemZeroLead+0x42>
             if ((Zeroed[i]=='0')&&(Zeroed[i+1]!='0')){
			     if ((Zeroed[i+1]=='.')||(Zeroed[i+1]==','))ZeroPos--;
    47f0:	8e 32       	cpi	r24, 0x2E	; 46
    47f2:	11 f0       	breq	.+4      	; 0x47f8 <RemZeroLead+0x3e>
    47f4:	8c 32       	cpi	r24, 0x2C	; 44
    47f6:	41 f4       	brne	.+16     	; 0x4808 <RemZeroLead+0x4e>
    47f8:	91 50       	subi	r25, 0x01	; 1
    47fa:	06 c0       	rjmp	.+12     	; 0x4808 <RemZeroLead+0x4e>
    47fc:	11 96       	adiw	r26, 0x01	; 1
unsigned char i=0,Length=0,ZeroPos=0,IsFound=False;;
     IsFound=False;
     ZeroPos=0;Length=strlen(Zeroed);
  if ((Length>1)&&(Zeroed[0]=='0')){
	 if (Zeroed[0]=='0'){
         for(i=0;i<Length;i++){//00000000->0
    47fe:	8a 2f       	mov	r24, r26
    4800:	84 1b       	sub	r24, r20
    4802:	8e 17       	cp	r24, r30
    4804:	58 f3       	brcs	.-42     	; 0x47dc <RemZeroLead+0x22>
    4806:	01 c0       	rjmp	.+2      	; 0x480a <RemZeroLead+0x50>
		         IsFound=True;
			     break;			  
			     }
	      }

		  if (IsFound==True)ZeroPos++;
    4808:	9f 5f       	subi	r25, 0xFF	; 255
		  if (ZeroPos>=Length)ZeroPos=Length-1;
    480a:	9e 17       	cp	r25, r30
    480c:	10 f0       	brcs	.+4      	; 0x4812 <RemZeroLead+0x58>
    480e:	9e 2f       	mov	r25, r30
    4810:	91 50       	subi	r25, 0x01	; 1
    4812:	40 e0       	ldi	r20, 0x00	; 0
          for(i=0;i<(Length-ZeroPos);i++){
    4814:	89 2f       	mov	r24, r25
    4816:	90 e0       	ldi	r25, 0x00	; 0
    4818:	2e 2f       	mov	r18, r30
    481a:	30 e0       	ldi	r19, 0x00	; 0
    481c:	28 1b       	sub	r18, r24
    481e:	39 0b       	sbc	r19, r25
	          Zeroed[i]=Zeroed[i+ZeroPos];
    4820:	be 01       	movw	r22, r28
    4822:	68 0f       	add	r22, r24
    4824:	79 1f       	adc	r23, r25
    4826:	09 c0       	rjmp	.+18     	; 0x483a <RemZeroLead+0x80>
    4828:	fe 01       	movw	r30, r28
    482a:	ea 0f       	add	r30, r26
    482c:	fb 1f       	adc	r31, r27
    482e:	a6 0f       	add	r26, r22
    4830:	b7 1f       	adc	r27, r23
    4832:	8c 91       	ld	r24, X
    4834:	80 83       	st	Z, r24
		      Zeroed[i+1]=0;
    4836:	11 82       	std	Z+1, r1	; 0x01
			     }
	      }

		  if (IsFound==True)ZeroPos++;
		  if (ZeroPos>=Length)ZeroPos=Length-1;
          for(i=0;i<(Length-ZeroPos);i++){
    4838:	4f 5f       	subi	r20, 0xFF	; 255
    483a:	a4 2f       	mov	r26, r20
    483c:	b0 e0       	ldi	r27, 0x00	; 0
    483e:	a2 17       	cp	r26, r18
    4840:	b3 07       	cpc	r27, r19
    4842:	94 f3       	brlt	.-28     	; 0x4828 <RemZeroLead+0x6e>
	          Zeroed[i]=Zeroed[i+ZeroPos];
		      Zeroed[i+1]=0;
	   }//Zeroed[Length-ZeroPos]=0;
	 }     
   }
}
    4844:	df 91       	pop	r29
    4846:	cf 91       	pop	r28
    4848:	08 95       	ret

0000484a <RemSpaceLead>:
	 if (Spaced[PosSpaced]==' ')Spaced[PosSpaced]=0;
	 if (Spaced[0]==' ')Spaced[0]=0;
	 Spaced[strlen(Spaced)]=0;
}

void RemSpaceLead(char *Zeroed){//Remove Space Character SSSSSS1234 12340234
    484a:	cf 93       	push	r28
    484c:	df 93       	push	r29
    484e:	ec 01       	movw	r28, r24
unsigned char i=0,Length=0,ZeroPos=0,IsFound=False;;
     ZeroPos=0;Length=strlen(Zeroed);
    4850:	fc 01       	movw	r30, r24
    4852:	01 90       	ld	r0, Z+
    4854:	00 20       	and	r0, r0
    4856:	e9 f7       	brne	.-6      	; 0x4852 <RemSpaceLead+0x8>
    4858:	31 97       	sbiw	r30, 0x01	; 1
    485a:	6e 2f       	mov	r22, r30
    485c:	68 1b       	sub	r22, r24
	 if ((Length>1)&&(Zeroed[0]==' ')){
    485e:	62 30       	cpi	r22, 0x02	; 2
    4860:	e0 f1       	brcs	.+120    	; 0x48da <RemSpaceLead+0x90>
    4862:	88 81       	ld	r24, Y
    4864:	80 32       	cpi	r24, 0x20	; 32
    4866:	c9 f5       	brne	.+114    	; 0x48da <RemSpaceLead+0x90>
    4868:	4c 2f       	mov	r20, r28
    486a:	fe 01       	movw	r30, r28
    486c:	20 e0       	ldi	r18, 0x00	; 0
    486e:	90 e0       	ldi	r25, 0x00	; 0
	     for(i=0;i<Length;i++){
		     if ((Zeroed[i]==' ')&&(Zeroed[i+1]==' ')&&(IsFound==False)) ZeroPos++;
    4870:	80 81       	ld	r24, Z
    4872:	80 32       	cpi	r24, 0x20	; 32
    4874:	41 f4       	brne	.+16     	; 0x4886 <RemSpaceLead+0x3c>
    4876:	81 81       	ldd	r24, Z+1	; 0x01
    4878:	80 32       	cpi	r24, 0x20	; 32
    487a:	21 f4       	brne	.+8      	; 0x4884 <RemSpaceLead+0x3a>
    487c:	22 23       	and	r18, r18
    487e:	19 f4       	brne	.+6      	; 0x4886 <RemSpaceLead+0x3c>
    4880:	9f 5f       	subi	r25, 0xFF	; 255
    4882:	01 c0       	rjmp	.+2      	; 0x4886 <RemSpaceLead+0x3c>
    4884:	21 e0       	ldi	r18, 0x01	; 1
    4886:	31 96       	adiw	r30, 0x01	; 1

void RemSpaceLead(char *Zeroed){//Remove Space Character SSSSSS1234 12340234
unsigned char i=0,Length=0,ZeroPos=0,IsFound=False;;
     ZeroPos=0;Length=strlen(Zeroed);
	 if ((Length>1)&&(Zeroed[0]==' ')){
	     for(i=0;i<Length;i++){
    4888:	8e 2f       	mov	r24, r30
    488a:	84 1b       	sub	r24, r20
    488c:	86 17       	cp	r24, r22
    488e:	80 f3       	brcs	.-32     	; 0x4870 <RemSpaceLead+0x26>
		     if ((Zeroed[i]==' ')&&(Zeroed[i+1]==' ')&&(IsFound==False)) ZeroPos++;
	         if((Zeroed[i]==' ')&&(Zeroed[i+1]!=' '))IsFound=True;
		 }ZeroPos++;
    4890:	39 2f       	mov	r19, r25
    4892:	3f 5f       	subi	r19, 0xFF	; 255
    4894:	20 e0       	ldi	r18, 0x00	; 0
	     for(i=0;i<strlen(Zeroed);i++){
		     Zeroed[i]=Zeroed[i+ZeroPos];
    4896:	43 2f       	mov	r20, r19
    4898:	50 e0       	ldi	r21, 0x00	; 0
    489a:	09 c0       	rjmp	.+18     	; 0x48ae <RemSpaceLead+0x64>
    489c:	fe 01       	movw	r30, r28
    489e:	e8 0f       	add	r30, r24
    48a0:	f9 1f       	adc	r31, r25
    48a2:	df 01       	movw	r26, r30
    48a4:	a4 0f       	add	r26, r20
    48a6:	b5 1f       	adc	r27, r21
    48a8:	8c 91       	ld	r24, X
    48aa:	80 83       	st	Z, r24
	 if ((Length>1)&&(Zeroed[0]==' ')){
	     for(i=0;i<Length;i++){
		     if ((Zeroed[i]==' ')&&(Zeroed[i+1]==' ')&&(IsFound==False)) ZeroPos++;
	         if((Zeroed[i]==' ')&&(Zeroed[i+1]!=' '))IsFound=True;
		 }ZeroPos++;
	     for(i=0;i<strlen(Zeroed);i++){
    48ac:	2f 5f       	subi	r18, 0xFF	; 255
    48ae:	82 2f       	mov	r24, r18
    48b0:	90 e0       	ldi	r25, 0x00	; 0
    48b2:	fe 01       	movw	r30, r28
    48b4:	01 90       	ld	r0, Z+
    48b6:	00 20       	and	r0, r0
    48b8:	e9 f7       	brne	.-6      	; 0x48b4 <RemSpaceLead+0x6a>
    48ba:	31 97       	sbiw	r30, 0x01	; 1
    48bc:	ec 1b       	sub	r30, r28
    48be:	fd 0b       	sbc	r31, r29
    48c0:	8e 17       	cp	r24, r30
    48c2:	9f 07       	cpc	r25, r31
    48c4:	58 f3       	brcs	.-42     	; 0x489c <RemSpaceLead+0x52>
		     Zeroed[i]=Zeroed[i+ZeroPos];
		 }
		 //Clearence
		 for(i=(Length-ZeroPos);i<Length;i++){
    48c6:	86 2f       	mov	r24, r22
    48c8:	83 1b       	sub	r24, r19
    48ca:	05 c0       	rjmp	.+10     	; 0x48d6 <RemSpaceLead+0x8c>
		     Zeroed[i]=0;
    48cc:	fe 01       	movw	r30, r28
    48ce:	e8 0f       	add	r30, r24
    48d0:	f1 1d       	adc	r31, r1
    48d2:	10 82       	st	Z, r1
		 }ZeroPos++;
	     for(i=0;i<strlen(Zeroed);i++){
		     Zeroed[i]=Zeroed[i+ZeroPos];
		 }
		 //Clearence
		 for(i=(Length-ZeroPos);i<Length;i++){
    48d4:	8f 5f       	subi	r24, 0xFF	; 255
    48d6:	86 17       	cp	r24, r22
    48d8:	c8 f3       	brcs	.-14     	; 0x48cc <RemSpaceLead+0x82>
		     Zeroed[i]=0;
		 }
     }
}
    48da:	df 91       	pop	r29
    48dc:	cf 91       	pop	r28
    48de:	08 95       	ret

000048e0 <RemSpaceLag>:
	 if (Spaced[0]==' ')Spaced[0]=0;
	 Spaced[strlen(Spaced)]=0;
}
*/
                                                      //012345678
void RemSpaceLag(char *Spaced){//Remove Space Character 1234SSSSS L=9 i=0 i=7
    48e0:	0f 93       	push	r16
    48e2:	1f 93       	push	r17
    48e4:	cf 93       	push	r28
    48e6:	df 93       	push	r29
    48e8:	ec 01       	movw	r28, r24
unsigned char i=0,Length=0,PosSpaced=0;
     Length=strlen(Spaced);
    48ea:	dc 01       	movw	r26, r24
    48ec:	0d 90       	ld	r0, X+
    48ee:	00 20       	and	r0, r0
    48f0:	e9 f7       	brne	.-6      	; 0x48ec <RemSpaceLag+0xc>
    48f2:	11 97       	sbiw	r26, 0x01	; 1
    48f4:	a8 1b       	sub	r26, r24
    48f6:	b0 e0       	ldi	r27, 0x00	; 0
    48f8:	20 e0       	ldi	r18, 0x00	; 0
    48fa:	30 e0       	ldi	r19, 0x00	; 0
     for(i=0;i<(Length-1);i++){
    48fc:	6a 2f       	mov	r22, r26
    48fe:	70 e0       	ldi	r23, 0x00	; 0
    4900:	8b 01       	movw	r16, r22
    4902:	01 50       	subi	r16, 0x01	; 1
    4904:	10 40       	sbci	r17, 0x00	; 0
	     if ((Spaced[Length-i-2]==' ')&&(Spaced[Length-i-1]==' ')){
		      Spaced[Length-i-1]=0;
    4906:	a1 50       	subi	r26, 0x01	; 1
    4908:	16 c0       	rjmp	.+44     	; 0x4936 <RemSpaceLag+0x56>
                                                      //012345678
void RemSpaceLag(char *Spaced){//Remove Space Character 1234SSSSS L=9 i=0 i=7
unsigned char i=0,Length=0,PosSpaced=0;
     Length=strlen(Spaced);
     for(i=0;i<(Length-1);i++){
	     if ((Spaced[Length-i-2]==' ')&&(Spaced[Length-i-1]==' ')){
    490a:	ab 01       	movw	r20, r22
    490c:	48 1b       	sub	r20, r24
    490e:	59 0b       	sbc	r21, r25
    4910:	fe 01       	movw	r30, r28
    4912:	e4 0f       	add	r30, r20
    4914:	f5 1f       	adc	r31, r21
    4916:	32 97       	sbiw	r30, 0x02	; 2
    4918:	80 81       	ld	r24, Z
    491a:	80 32       	cpi	r24, 0x20	; 32
    491c:	89 f4       	brne	.+34     	; 0x4940 <RemSpaceLag+0x60>
    491e:	fa 01       	movw	r30, r20
    4920:	31 97       	sbiw	r30, 0x01	; 1
    4922:	ec 0f       	add	r30, r28
    4924:	fd 1f       	adc	r31, r29
    4926:	2f 5f       	subi	r18, 0xFF	; 255
    4928:	3f 4f       	sbci	r19, 0xFF	; 255
    492a:	80 81       	ld	r24, Z
    492c:	80 32       	cpi	r24, 0x20	; 32
    492e:	41 f4       	brne	.+16     	; 0x4940 <RemSpaceLag+0x60>
		      Spaced[Length-i-1]=0;
    4930:	10 82       	st	Z, r1
    4932:	ba 2f       	mov	r27, r26
    4934:	b2 1b       	sub	r27, r18
*/
                                                      //012345678
void RemSpaceLag(char *Spaced){//Remove Space Character 1234SSSSS L=9 i=0 i=7
unsigned char i=0,Length=0,PosSpaced=0;
     Length=strlen(Spaced);
     for(i=0;i<(Length-1);i++){
    4936:	82 2f       	mov	r24, r18
    4938:	90 e0       	ldi	r25, 0x00	; 0
    493a:	80 17       	cp	r24, r16
    493c:	91 07       	cpc	r25, r17
    493e:	2c f3       	brlt	.-54     	; 0x490a <RemSpaceLag+0x2a>
		      Spaced[Length-i-1]=0;
			  PosSpaced=Length-i-2;
			  }
         else break;
	 }
	 if (Spaced[PosSpaced]==' ')Spaced[PosSpaced]=0;
    4940:	fe 01       	movw	r30, r28
    4942:	eb 0f       	add	r30, r27
    4944:	f1 1d       	adc	r31, r1
    4946:	80 81       	ld	r24, Z
    4948:	80 32       	cpi	r24, 0x20	; 32
    494a:	09 f4       	brne	.+2      	; 0x494e <RemSpaceLag+0x6e>
    494c:	10 82       	st	Z, r1
	 if (Spaced[0]==' ')Spaced[0]=0;
    494e:	88 81       	ld	r24, Y
    4950:	80 32       	cpi	r24, 0x20	; 32
    4952:	09 f4       	brne	.+2      	; 0x4956 <RemSpaceLag+0x76>
    4954:	18 82       	st	Y, r1
	 Spaced[strlen(Spaced)]=0;
    4956:	fe 01       	movw	r30, r28
    4958:	01 90       	ld	r0, Z+
    495a:	00 20       	and	r0, r0
    495c:	e9 f7       	brne	.-6      	; 0x4958 <RemSpaceLag+0x78>
    495e:	31 97       	sbiw	r30, 0x01	; 1
    4960:	ec 1b       	sub	r30, r28
    4962:	fd 0b       	sbc	r31, r29
    4964:	ec 0f       	add	r30, r28
    4966:	fd 1f       	adc	r31, r29
    4968:	10 82       	st	Z, r1
}
    496a:	df 91       	pop	r29
    496c:	cf 91       	pop	r28
    496e:	1f 91       	pop	r17
    4970:	0f 91       	pop	r16
    4972:	08 95       	ret

00004974 <procMessage57>:
     StrPosCopy(rcv_trans,strAmount,135,7);
     StrPosCopy(rcv_trans,strGainPoints,142,4);
     return Result;
}

char procMessage57(){
    4974:	1f 93       	push	r17
	    Dest[IdxSource+i]=Source[i];
	 }Dest[IdxSource+Length]=0;
}
char CharPosCopy(char *Source, unsigned int IdxSource){
     char Result;
     Result=Source[IdxSource];
    4976:	10 91 2e 0b 	lds	r17, 0x0B2E
    497a:	20 e0       	ldi	r18, 0x00	; 0
    497c:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    497e:	f9 01       	movw	r30, r18
    4980:	eb 50       	subi	r30, 0x0B	; 11
    4982:	f5 4f       	sbci	r31, 0xF5	; 245
    4984:	d9 01       	movw	r26, r18
    4986:	af 59       	subi	r26, 0x9F	; 159
    4988:	b2 4f       	sbci	r27, 0xF2	; 242
    498a:	95 96       	adiw	r26, 0x25	; 37
    498c:	8c 91       	ld	r24, X
    498e:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    4990:	2f 5f       	subi	r18, 0xFF	; 255
    4992:	3f 4f       	sbci	r19, 0xFF	; 255
    4994:	24 31       	cpi	r18, 0x14	; 20
    4996:	31 05       	cpc	r19, r1
    4998:	91 f7       	brne	.-28     	; 0x497e <procMessage57+0xa>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    499a:	10 92 09 0b 	sts	0x0B09, r1
	 
	     //Card Status
		 Result=(CharPosCopy(rcv_trans,57)-'0')+1;
		 //CardID
		 StrPosCopy(strCardID,rcv_trans,37,20);
		 RemSpaceLead(strCardID);
    499e:	81 e6       	ldi	r24, 0x61	; 97
    49a0:	9d e0       	ldi	r25, 0x0D	; 13
    49a2:	0e 94 25 24 	call	0x484a	; 0x484a <RemSpaceLead>
    49a6:	20 e0       	ldi	r18, 0x00	; 0
    49a8:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    49aa:	f9 01       	movw	r30, r18
    49ac:	ec 5f       	subi	r30, 0xFC	; 252
    49ae:	fa 4f       	sbci	r31, 0xFA	; 250
    49b0:	d9 01       	movw	r26, r18
    49b2:	ab 50       	subi	r26, 0x0B	; 11
    49b4:	b5 4f       	sbci	r27, 0xF5	; 245
    49b6:	dc 96       	adiw	r26, 0x3c	; 60
    49b8:	8c 91       	ld	r24, X
    49ba:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    49bc:	2f 5f       	subi	r18, 0xFF	; 255
    49be:	3f 4f       	sbci	r19, 0xFF	; 255
    49c0:	28 32       	cpi	r18, 0x28	; 40
    49c2:	31 05       	cpc	r19, r1
    49c4:	91 f7       	brne	.-28     	; 0x49aa <procMessage57+0x36>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    49c6:	10 92 2c 05 	sts	0x052C, r1
		 //CardID
		 StrPosCopy(strCardID,rcv_trans,37,20);
		 RemSpaceLead(strCardID);
	     //Card Holder
		 StrPosCopy(rcv_trans,strCardHolder,60,40);
		 RemSpaceLag(strCardHolder);
    49ca:	84 e0       	ldi	r24, 0x04	; 4
    49cc:	95 e0       	ldi	r25, 0x05	; 5
    49ce:	0e 94 70 24 	call	0x48e0	; 0x48e0 <RemSpaceLag>
    49d2:	20 e0       	ldi	r18, 0x00	; 0
    49d4:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    49d6:	f9 01       	movw	r30, r18
    49d8:	e5 5c       	subi	r30, 0xC5	; 197
    49da:	fa 4f       	sbci	r31, 0xFA	; 250
    49dc:	d9 01       	movw	r26, r18
    49de:	a3 57       	subi	r26, 0x73	; 115
    49e0:	b4 4f       	sbci	r27, 0xF4	; 244
    49e2:	8c 91       	ld	r24, X
    49e4:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    49e6:	2f 5f       	subi	r18, 0xFF	; 255
    49e8:	3f 4f       	sbci	r19, 0xFF	; 255
    49ea:	29 31       	cpi	r18, 0x19	; 25
    49ec:	31 05       	cpc	r19, r1
    49ee:	99 f7       	brne	.-26     	; 0x49d6 <procMessage57+0x62>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    49f0:	10 92 54 05 	sts	0x0554, r1
	     //Card Holder
		 StrPosCopy(rcv_trans,strCardHolder,60,40);
		 RemSpaceLag(strCardHolder);
		 //BalanceTypePrint
		 StrPosCopy(rcv_trans,strBalanceTypePrint,154-2,25);
		 RemSpaceLag(strBalanceTypePrint);
    49f4:	8b e3       	ldi	r24, 0x3B	; 59
    49f6:	95 e0       	ldi	r25, 0x05	; 5
    49f8:	0e 94 70 24 	call	0x48e0	; 0x48e0 <RemSpaceLag>
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    49fc:	80 91 a6 0b 	lds	r24, 0x0BA6
    4a00:	80 93 c5 04 	sts	0x04C5, r24
	 }Dest[Length]=0;
    4a04:	10 92 c6 04 	sts	0x04C6, r1
    4a08:	20 e0       	ldi	r18, 0x00	; 0
    4a0a:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    4a0c:	f9 01       	movw	r30, r18
    4a0e:	ed 52       	subi	r30, 0x2D	; 45
    4a10:	f2 4f       	sbci	r31, 0xF2	; 242
    4a12:	d9 01       	movw	r26, r18
    4a14:	a9 55       	subi	r26, 0x59	; 89
    4a16:	b4 4f       	sbci	r27, 0xF4	; 244
    4a18:	8c 91       	ld	r24, X
    4a1a:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    4a1c:	2f 5f       	subi	r18, 0xFF	; 255
    4a1e:	3f 4f       	sbci	r19, 0xFF	; 255
    4a20:	2d 30       	cpi	r18, 0x0D	; 13
    4a22:	31 05       	cpc	r19, r1
    4a24:	99 f7       	brne	.-26     	; 0x4a0c <procMessage57+0x98>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    4a26:	10 92 e0 0d 	sts	0x0DE0, r1
		 RemSpaceLag(strBalanceTypePrint);
         //BalanceTypeCode
		 StrPosCopy(rcv_trans,strBalanceCode,177,1);
		 //Balance
		 StrPosCopy(rcv_trans,strBalance,178,13);
		 RemSpaceLead(strBalance);
    4a2a:	83 ed       	ldi	r24, 0xD3	; 211
    4a2c:	9d e0       	ldi	r25, 0x0D	; 13
    4a2e:	0e 94 25 24 	call	0x484a	; 0x484a <RemSpaceLead>
    4a32:	20 e0       	ldi	r18, 0x00	; 0
    4a34:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    4a36:	f9 01       	movw	r30, r18
    4a38:	ee 52       	subi	r30, 0x2E	; 46
    4a3a:	f5 4f       	sbci	r31, 0xF5	; 245
    4a3c:	d9 01       	movw	r26, r18
    4a3e:	ac 54       	subi	r26, 0x4C	; 76
    4a40:	b4 4f       	sbci	r27, 0xF4	; 244
    4a42:	8c 91       	ld	r24, X
    4a44:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    4a46:	2f 5f       	subi	r18, 0xFF	; 255
    4a48:	3f 4f       	sbci	r19, 0xFF	; 255
    4a4a:	2a 30       	cpi	r18, 0x0A	; 10
    4a4c:	31 05       	cpc	r19, r1
    4a4e:	99 f7       	brne	.-26     	; 0x4a36 <procMessage57+0xc2>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    4a50:	10 92 dc 0a 	sts	0x0ADC, r1
		 //Balance
		 StrPosCopy(rcv_trans,strBalance,178,13);
		 RemSpaceLead(strBalance);
		 //LicPlate
		 StrPosCopy(rcv_trans,strLicPlate,193-2,10);
		 RemSpaceLag(strLicPlate);
    4a54:	82 ed       	ldi	r24, 0xD2	; 210
    4a56:	9a e0       	ldi	r25, 0x0A	; 10
    4a58:	0e 94 70 24 	call	0x48e0	; 0x48e0 <RemSpaceLag>
    4a5c:	20 e0       	ldi	r18, 0x00	; 0
    4a5e:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    4a60:	f9 01       	movw	r30, r18
    4a62:	e4 5a       	subi	r30, 0xA4	; 164
    4a64:	f6 4f       	sbci	r31, 0xF6	; 246
    4a66:	d9 01       	movw	r26, r18
    4a68:	a2 54       	subi	r26, 0x42	; 66
    4a6a:	b4 4f       	sbci	r27, 0xF4	; 244
    4a6c:	8c 91       	ld	r24, X
    4a6e:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    4a70:	2f 5f       	subi	r18, 0xFF	; 255
    4a72:	3f 4f       	sbci	r19, 0xFF	; 255
    4a74:	24 31       	cpi	r18, 0x14	; 20
    4a76:	31 05       	cpc	r19, r1
    4a78:	99 f7       	brne	.-26     	; 0x4a60 <procMessage57+0xec>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    4a7a:	10 92 70 09 	sts	0x0970, r1
		 //LicPlate
		 StrPosCopy(rcv_trans,strLicPlate,193-2,10);
		 RemSpaceLag(strLicPlate);
		 //CompName
		 StrPosCopy(rcv_trans,strCompName,203-2,20);
		 RemSpaceLag(strCompName);
    4a7e:	8c e5       	ldi	r24, 0x5C	; 92
    4a80:	99 e0       	ldi	r25, 0x09	; 9
    4a82:	0e 94 70 24 	call	0x48e0	; 0x48e0 <RemSpaceLag>
		 _uart_print(0,1,strCompName);
		 
_uart_print(0,1,strCardID);
*/	
     return Result;
}
    4a86:	81 2f       	mov	r24, r17
    4a88:	8f 52       	subi	r24, 0x2F	; 47
    4a8a:	1f 91       	pop	r17
    4a8c:	08 95       	ret

00004a8e <clearString>:
	     break;
	}
  return Result;
}

void clearString(char *str){
    4a8e:	20 e0       	ldi	r18, 0x00	; 0
    4a90:	30 e0       	ldi	r19, 0x00	; 0
    4a92:	06 c0       	rjmp	.+12     	; 0x4aa0 <clearString+0x12>
     int i;
	 for(i=0;i<strlen(str);i++){
	    str[i]=0;
    4a94:	fc 01       	movw	r30, r24
    4a96:	e2 0f       	add	r30, r18
    4a98:	f3 1f       	adc	r31, r19
    4a9a:	10 82       	st	Z, r1
  return Result;
}

void clearString(char *str){
     int i;
	 for(i=0;i<strlen(str);i++){
    4a9c:	2f 5f       	subi	r18, 0xFF	; 255
    4a9e:	3f 4f       	sbci	r19, 0xFF	; 255
    4aa0:	fc 01       	movw	r30, r24
    4aa2:	01 90       	ld	r0, Z+
    4aa4:	00 20       	and	r0, r0
    4aa6:	e9 f7       	brne	.-6      	; 0x4aa2 <clearString+0x14>
    4aa8:	31 97       	sbiw	r30, 0x01	; 1
    4aaa:	e8 1b       	sub	r30, r24
    4aac:	f9 0b       	sbc	r31, r25
    4aae:	2e 17       	cp	r18, r30
    4ab0:	3f 07       	cpc	r19, r31
    4ab2:	80 f3       	brcs	.-32     	; 0x4a94 <clearString+0x6>
	    str[i]=0;
	 }
}
    4ab4:	08 95       	ret

00004ab6 <AddZeroLead>:
	 }String[Size]=0;
  }
}


void AddZeroLead(char *String,unsigned char Size){// 1234 ->0000001234
    4ab6:	bf 92       	push	r11
    4ab8:	cf 92       	push	r12
    4aba:	df 92       	push	r13
    4abc:	ef 92       	push	r14
    4abe:	ff 92       	push	r15
    4ac0:	0f 93       	push	r16
    4ac2:	1f 93       	push	r17
    4ac4:	df 93       	push	r29
    4ac6:	cf 93       	push	r28
    4ac8:	cd b7       	in	r28, 0x3d	; 61
    4aca:	de b7       	in	r29, 0x3e	; 62
    4acc:	6e 97       	sbiw	r28, 0x1e	; 30
    4ace:	0f b6       	in	r0, 0x3f	; 63
    4ad0:	f8 94       	cli
    4ad2:	de bf       	out	0x3e, r29	; 62
    4ad4:	0f be       	out	0x3f, r0	; 63
    4ad6:	cd bf       	out	0x3d, r28	; 61
    4ad8:	8c 01       	movw	r16, r24
     char i,Length,strAdded[30];
     Length=strlen(String);
    4ada:	fc 01       	movw	r30, r24
    4adc:	01 90       	ld	r0, Z+
    4ade:	00 20       	and	r0, r0
    4ae0:	e9 f7       	brne	.-6      	; 0x4adc <AddZeroLead+0x26>
    4ae2:	31 97       	sbiw	r30, 0x01	; 1
    4ae4:	2e 2f       	mov	r18, r30
    4ae6:	28 1b       	sub	r18, r24

	 if (Size>Length){
    4ae8:	26 17       	cp	r18, r22
    4aea:	e0 f5       	brcc	.+120    	; 0x4b64 <AddZeroLead+0xae>
    4aec:	7e 01       	movw	r14, r28
    4aee:	08 94       	sec
    4af0:	e1 1c       	adc	r14, r1
    4af2:	f1 1c       	adc	r15, r1
    4af4:	f7 01       	movw	r30, r14
	 }String[Size]=0;
  }
}


void AddZeroLead(char *String,unsigned char Size){// 1234 ->0000001234
    4af6:	be 2c       	mov	r11, r14
     char i,Length,strAdded[30];
     Length=strlen(String);

	 if (Size>Length){
         for(i=0;i<Size;i++){
	         strAdded[i]='0';
    4af8:	90 e3       	ldi	r25, 0x30	; 48
    4afa:	01 c0       	rjmp	.+2      	; 0x4afe <AddZeroLead+0x48>
    4afc:	91 93       	st	Z+, r25
void AddZeroLead(char *String,unsigned char Size){// 1234 ->0000001234
     char i,Length,strAdded[30];
     Length=strlen(String);

	 if (Size>Length){
         for(i=0;i<Size;i++){
    4afe:	8e 2f       	mov	r24, r30
    4b00:	8b 19       	sub	r24, r11
    4b02:	86 17       	cp	r24, r22
    4b04:	d8 f3       	brcs	.-10     	; 0x4afc <AddZeroLead+0x46>
	         strAdded[i]='0';
	     }strAdded[Size]=0;
    4b06:	46 2f       	mov	r20, r22
    4b08:	50 e0       	ldi	r21, 0x00	; 0
    4b0a:	ce 01       	movw	r24, r28
    4b0c:	01 96       	adiw	r24, 0x01	; 1
    4b0e:	fc 01       	movw	r30, r24
    4b10:	e4 0f       	add	r30, r20
    4b12:	f5 1f       	adc	r31, r21
    4b14:	10 82       	st	Z, r1
	     //Copy
         for(i=(Size-Length);i<Size;i++){
    4b16:	76 2f       	mov	r23, r22
    4b18:	72 1b       	sub	r23, r18
    4b1a:	6c 01       	movw	r12, r24
	         strAdded[i]=String[i-(Size-Length)];
    4b1c:	30 e0       	ldi	r19, 0x00	; 0
    4b1e:	24 1b       	sub	r18, r20
    4b20:	35 0b       	sbc	r19, r21
    4b22:	0c c0       	rjmp	.+24     	; 0x4b3c <AddZeroLead+0x86>
    4b24:	e7 2f       	mov	r30, r23
    4b26:	f0 e0       	ldi	r31, 0x00	; 0
    4b28:	d6 01       	movw	r26, r12
    4b2a:	ae 0f       	add	r26, r30
    4b2c:	bf 1f       	adc	r27, r31
    4b2e:	e0 0f       	add	r30, r16
    4b30:	f1 1f       	adc	r31, r17
    4b32:	e2 0f       	add	r30, r18
    4b34:	f3 1f       	adc	r31, r19
    4b36:	80 81       	ld	r24, Z
    4b38:	8c 93       	st	X, r24
	 if (Size>Length){
         for(i=0;i<Size;i++){
	         strAdded[i]='0';
	     }strAdded[Size]=0;
	     //Copy
         for(i=(Size-Length);i<Size;i++){
    4b3a:	7f 5f       	subi	r23, 0xFF	; 255
    4b3c:	76 17       	cp	r23, r22
    4b3e:	90 f3       	brcs	.-28     	; 0x4b24 <AddZeroLead+0x6e>
	         strAdded[i]=String[i-(Size-Length)];
	     }strAdded[Size]=0;
    4b40:	4c 0d       	add	r20, r12
    4b42:	5d 1d       	adc	r21, r13
    4b44:	da 01       	movw	r26, r20
    4b46:	1c 92       	st	X, r1
    4b48:	f8 01       	movw	r30, r16
    4b4a:	04 c0       	rjmp	.+8      	; 0x4b54 <AddZeroLead+0x9e>
	     //Zeroed
         for(i=0;i<Size;i++){
	         String[i]=strAdded[i];
    4b4c:	d7 01       	movw	r26, r14
    4b4e:	8d 91       	ld	r24, X+
    4b50:	7d 01       	movw	r14, r26
    4b52:	81 93       	st	Z+, r24
	     //Copy
         for(i=(Size-Length);i<Size;i++){
	         strAdded[i]=String[i-(Size-Length)];
	     }strAdded[Size]=0;
	     //Zeroed
         for(i=0;i<Size;i++){
    4b54:	8e 2d       	mov	r24, r14
    4b56:	8b 19       	sub	r24, r11
    4b58:	86 17       	cp	r24, r22
    4b5a:	c0 f3       	brcs	.-16     	; 0x4b4c <AddZeroLead+0x96>
	         String[i]=strAdded[i];
	     }String[Size]=0;
    4b5c:	06 0f       	add	r16, r22
    4b5e:	11 1d       	adc	r17, r1
    4b60:	f8 01       	movw	r30, r16
    4b62:	10 82       	st	Z, r1
	 }
}
    4b64:	6e 96       	adiw	r28, 0x1e	; 30
    4b66:	0f b6       	in	r0, 0x3f	; 63
    4b68:	f8 94       	cli
    4b6a:	de bf       	out	0x3e, r29	; 62
    4b6c:	0f be       	out	0x3f, r0	; 63
    4b6e:	cd bf       	out	0x3d, r28	; 61
    4b70:	cf 91       	pop	r28
    4b72:	df 91       	pop	r29
    4b74:	1f 91       	pop	r17
    4b76:	0f 91       	pop	r16
    4b78:	ff 90       	pop	r15
    4b7a:	ef 90       	pop	r14
    4b7c:	df 90       	pop	r13
    4b7e:	cf 90       	pop	r12
    4b80:	bf 90       	pop	r11
    4b82:	08 95       	ret

00004b84 <GetTotalizerMoney>:
	     FIPAddr=FIPAddr-1;	     
	     GetTotalizerData(TVOLUME,TOTALIZER_NOW,FIPAddr,iGrade,Result);
	 }
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalTotalVolume),2,Result);
}
void GetTotalizerMoney(char iPumpID,char iGrade, char *Result){
    4b84:	0f 93       	push	r16
    4b86:	1f 93       	push	r17
    4b88:	cf 93       	push	r28
    4b8a:	df 93       	push	r29
    4b8c:	18 2f       	mov	r17, r24
    4b8e:	06 2f       	mov	r16, r22
    4b90:	ea 01       	movw	r28, r20
     char FIPAddr;
     AddZeroLead(Result,13); 
    4b92:	ca 01       	movw	r24, r20
    4b94:	6d e0       	ldi	r22, 0x0D	; 13
    4b96:	0e 94 5b 25 	call	0x4ab6	; 0x4ab6 <AddZeroLead>
	 FIPAddr=GetFIPAddr(iPumpID);
    4b9a:	81 2f       	mov	r24, r17
    4b9c:	0e 94 39 1c 	call	0x3872	; 0x3872 <GetFIPAddr>
    4ba0:	48 2f       	mov	r20, r24
	 if (FIPAddr>0){
    4ba2:	88 23       	and	r24, r24
    4ba4:	39 f0       	breq	.+14     	; 0x4bb4 <GetTotalizerMoney+0x30>
	    FIPAddr=FIPAddr-1;
	    GetTotalizerData(TMONEY,TOTALIZER_NOW,FIPAddr,iGrade,Result);
    4ba6:	41 50       	subi	r20, 0x01	; 1
    4ba8:	81 e0       	ldi	r24, 0x01	; 1
    4baa:	61 e0       	ldi	r22, 0x01	; 1
    4bac:	20 2f       	mov	r18, r16
    4bae:	8e 01       	movw	r16, r28
    4bb0:	0e 94 f8 1c 	call	0x39f0	; 0x39f0 <GetTotalizerData>
	}
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalTotalMoney),2,Result);
}
    4bb4:	df 91       	pop	r29
    4bb6:	cf 91       	pop	r28
    4bb8:	1f 91       	pop	r17
    4bba:	0f 91       	pop	r16
    4bbc:	08 95       	ret

00004bbe <GetTotalizerVolume>:
     AddZeroLead(Result,10);
	 sprintf_P(Result,PSTR("%s"),RecPumpData[iPumpID&0x0F].Money);
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalMoney),3,Result);
}

void GetTotalizerVolume(char iPumpID,char iGrade,char *Result){
    4bbe:	0f 93       	push	r16
    4bc0:	1f 93       	push	r17
    4bc2:	cf 93       	push	r28
    4bc4:	df 93       	push	r29
    4bc6:	18 2f       	mov	r17, r24
    4bc8:	06 2f       	mov	r16, r22
    4bca:	ea 01       	movw	r28, r20
     char FIPAddr;
     AddZeroLead(Result,11);
    4bcc:	ca 01       	movw	r24, r20
    4bce:	6b e0       	ldi	r22, 0x0B	; 11
    4bd0:	0e 94 5b 25 	call	0x4ab6	; 0x4ab6 <AddZeroLead>
	 FIPAddr=GetFIPAddr(iPumpID);
    4bd4:	81 2f       	mov	r24, r17
    4bd6:	0e 94 39 1c 	call	0x3872	; 0x3872 <GetFIPAddr>
    4bda:	48 2f       	mov	r20, r24
	 if (FIPAddr>0){
    4bdc:	88 23       	and	r24, r24
    4bde:	39 f0       	breq	.+14     	; 0x4bee <GetTotalizerVolume+0x30>
	     FIPAddr=FIPAddr-1;	     
	     GetTotalizerData(TVOLUME,TOTALIZER_NOW,FIPAddr,iGrade,Result);
    4be0:	41 50       	subi	r20, 0x01	; 1
    4be2:	80 e0       	ldi	r24, 0x00	; 0
    4be4:	61 e0       	ldi	r22, 0x01	; 1
    4be6:	20 2f       	mov	r18, r16
    4be8:	8e 01       	movw	r16, r28
    4bea:	0e 94 f8 1c 	call	0x39f0	; 0x39f0 <GetTotalizerData>
	 }
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalTotalVolume),2,Result);
}
    4bee:	df 91       	pop	r29
    4bf0:	cf 91       	pop	r28
    4bf2:	1f 91       	pop	r17
    4bf4:	0f 91       	pop	r16
    4bf6:	08 95       	ret

00004bf8 <GetTransactionMoney>:
void GetTransactionVolume(char iPumpID,char *Result){
     AddZeroLead(Result,10);
     sprintf_P(Result,PSTR("%s"),RecPumpData[iPumpID&0x0F].Volume); 
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalVolume),3,Result);
}
void GetTransactionMoney(char iPumpID,char *Result){
    4bf8:	ef 92       	push	r14
    4bfa:	ff 92       	push	r15
    4bfc:	0f 93       	push	r16
    4bfe:	1f 93       	push	r17
    4c00:	08 2f       	mov	r16, r24
    4c02:	7b 01       	movw	r14, r22
     AddZeroLead(Result,10);
    4c04:	cb 01       	movw	r24, r22
    4c06:	6a e0       	ldi	r22, 0x0A	; 10
    4c08:	0e 94 5b 25 	call	0x4ab6	; 0x4ab6 <AddZeroLead>
	 sprintf_P(Result,PSTR("%s"),RecPumpData[iPumpID&0x0F].Money);
    4c0c:	00 d0       	rcall	.+0      	; 0x4c0e <GetTransactionMoney+0x16>
    4c0e:	00 d0       	rcall	.+0      	; 0x4c10 <GetTransactionMoney+0x18>
    4c10:	00 d0       	rcall	.+0      	; 0x4c12 <GetTransactionMoney+0x1a>
    4c12:	ed b7       	in	r30, 0x3d	; 61
    4c14:	fe b7       	in	r31, 0x3e	; 62
    4c16:	31 96       	adiw	r30, 0x01	; 1
    4c18:	ad b7       	in	r26, 0x3d	; 61
    4c1a:	be b7       	in	r27, 0x3e	; 62
    4c1c:	12 96       	adiw	r26, 0x02	; 2
    4c1e:	fc 92       	st	X, r15
    4c20:	ee 92       	st	-X, r14
    4c22:	11 97       	sbiw	r26, 0x01	; 1
    4c24:	83 e6       	ldi	r24, 0x63	; 99
    4c26:	93 e0       	ldi	r25, 0x03	; 3
    4c28:	93 83       	std	Z+3, r25	; 0x03
    4c2a:	82 83       	std	Z+2, r24	; 0x02
    4c2c:	10 e0       	ldi	r17, 0x00	; 0
    4c2e:	0f 70       	andi	r16, 0x0F	; 15
    4c30:	10 70       	andi	r17, 0x00	; 0
    4c32:	85 e3       	ldi	r24, 0x35	; 53
    4c34:	90 e0       	ldi	r25, 0x00	; 0
    4c36:	9c 01       	movw	r18, r24
    4c38:	02 9f       	mul	r16, r18
    4c3a:	c0 01       	movw	r24, r0
    4c3c:	03 9f       	mul	r16, r19
    4c3e:	90 0d       	add	r25, r0
    4c40:	12 9f       	mul	r17, r18
    4c42:	90 0d       	add	r25, r0
    4c44:	11 24       	eor	r1, r1
    4c46:	89 54       	subi	r24, 0x49	; 73
    4c48:	98 4f       	sbci	r25, 0xF8	; 248
    4c4a:	95 83       	std	Z+5, r25	; 0x05
    4c4c:	84 83       	std	Z+4, r24	; 0x04
    4c4e:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    4c52:	8d b7       	in	r24, 0x3d	; 61
    4c54:	9e b7       	in	r25, 0x3e	; 62
    4c56:	06 96       	adiw	r24, 0x06	; 6
    4c58:	0f b6       	in	r0, 0x3f	; 63
    4c5a:	f8 94       	cli
    4c5c:	9e bf       	out	0x3e, r25	; 62
    4c5e:	0f be       	out	0x3f, r0	; 63
    4c60:	8d bf       	out	0x3d, r24	; 61
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalMoney),3,Result);
}
    4c62:	1f 91       	pop	r17
    4c64:	0f 91       	pop	r16
    4c66:	ff 90       	pop	r15
    4c68:	ef 90       	pop	r14
    4c6a:	08 95       	ret

00004c6c <GetTransactionVolume>:
     }
*/
     FormatDecimal(Result,CurrentDecimal);
}

void GetTransactionVolume(char iPumpID,char *Result){
    4c6c:	ef 92       	push	r14
    4c6e:	ff 92       	push	r15
    4c70:	0f 93       	push	r16
    4c72:	1f 93       	push	r17
    4c74:	08 2f       	mov	r16, r24
    4c76:	7b 01       	movw	r14, r22
     AddZeroLead(Result,10);
    4c78:	cb 01       	movw	r24, r22
    4c7a:	6a e0       	ldi	r22, 0x0A	; 10
    4c7c:	0e 94 5b 25 	call	0x4ab6	; 0x4ab6 <AddZeroLead>
     sprintf_P(Result,PSTR("%s"),RecPumpData[iPumpID&0x0F].Volume); 
    4c80:	00 d0       	rcall	.+0      	; 0x4c82 <GetTransactionVolume+0x16>
    4c82:	00 d0       	rcall	.+0      	; 0x4c84 <GetTransactionVolume+0x18>
    4c84:	00 d0       	rcall	.+0      	; 0x4c86 <GetTransactionVolume+0x1a>
    4c86:	ed b7       	in	r30, 0x3d	; 61
    4c88:	fe b7       	in	r31, 0x3e	; 62
    4c8a:	31 96       	adiw	r30, 0x01	; 1
    4c8c:	ad b7       	in	r26, 0x3d	; 61
    4c8e:	be b7       	in	r27, 0x3e	; 62
    4c90:	12 96       	adiw	r26, 0x02	; 2
    4c92:	fc 92       	st	X, r15
    4c94:	ee 92       	st	-X, r14
    4c96:	11 97       	sbiw	r26, 0x01	; 1
    4c98:	86 e6       	ldi	r24, 0x66	; 102
    4c9a:	93 e0       	ldi	r25, 0x03	; 3
    4c9c:	93 83       	std	Z+3, r25	; 0x03
    4c9e:	82 83       	std	Z+2, r24	; 0x02
    4ca0:	10 e0       	ldi	r17, 0x00	; 0
    4ca2:	0f 70       	andi	r16, 0x0F	; 15
    4ca4:	10 70       	andi	r17, 0x00	; 0
    4ca6:	85 e3       	ldi	r24, 0x35	; 53
    4ca8:	90 e0       	ldi	r25, 0x00	; 0
    4caa:	9c 01       	movw	r18, r24
    4cac:	02 9f       	mul	r16, r18
    4cae:	c0 01       	movw	r24, r0
    4cb0:	03 9f       	mul	r16, r19
    4cb2:	90 0d       	add	r25, r0
    4cb4:	12 9f       	mul	r17, r18
    4cb6:	90 0d       	add	r25, r0
    4cb8:	11 24       	eor	r1, r1
    4cba:	82 55       	subi	r24, 0x52	; 82
    4cbc:	98 4f       	sbci	r25, 0xF8	; 248
    4cbe:	95 83       	std	Z+5, r25	; 0x05
    4cc0:	84 83       	std	Z+4, r24	; 0x04
    4cc2:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    4cc6:	8d b7       	in	r24, 0x3d	; 61
    4cc8:	9e b7       	in	r25, 0x3e	; 62
    4cca:	06 96       	adiw	r24, 0x06	; 6
    4ccc:	0f b6       	in	r0, 0x3f	; 63
    4cce:	f8 94       	cli
    4cd0:	9e bf       	out	0x3e, r25	; 62
    4cd2:	0f be       	out	0x3f, r0	; 63
    4cd4:	8d bf       	out	0x3d, r24	; 61
	 //NormalizeDecimal(eeprom_read_byte(&DefDecimalVolume),3,Result);
}
    4cd6:	1f 91       	pop	r17
    4cd8:	0f 91       	pop	r16
    4cda:	ff 90       	pop	r15
    4cdc:	ef 90       	pop	r14
    4cde:	08 95       	ret

00004ce0 <AddZeroLag>:
	         String[i]=strAdded[i];
	     }String[Size]=0;
	 }
}

void AddZeroLag(char *String,unsigned char Size){// [123]->12300
    4ce0:	cf 93       	push	r28
    4ce2:	df 93       	push	r29
    4ce4:	ec 01       	movw	r28, r24
char i,Length;
     Length=strlen(String);
    4ce6:	dc 01       	movw	r26, r24
    4ce8:	0d 90       	ld	r0, X+
    4cea:	00 20       	and	r0, r0
    4cec:	e9 f7       	brne	.-6      	; 0x4ce8 <AddZeroLag+0x8>
    4cee:	11 97       	sbiw	r26, 0x01	; 1
    4cf0:	a8 1b       	sub	r26, r24
    4cf2:	b9 0b       	sbc	r27, r25
  if (Length<Size){   
    4cf4:	a6 17       	cp	r26, r22
    4cf6:	60 f4       	brcc	.+24     	; 0x4d10 <AddZeroLag+0x30>
    4cf8:	8a 2f       	mov	r24, r26
     for(i=Length;i<Size;i++){
	    String[i]='0';
    4cfa:	90 e3       	ldi	r25, 0x30	; 48
    4cfc:	fe 01       	movw	r30, r28
    4cfe:	e8 0f       	add	r30, r24
    4d00:	f1 1d       	adc	r31, r1
    4d02:	90 83       	st	Z, r25

void AddZeroLag(char *String,unsigned char Size){// [123]->12300
char i,Length;
     Length=strlen(String);
  if (Length<Size){   
     for(i=Length;i<Size;i++){
    4d04:	8f 5f       	subi	r24, 0xFF	; 255
    4d06:	86 17       	cp	r24, r22
    4d08:	c8 f3       	brcs	.-14     	; 0x4cfc <AddZeroLag+0x1c>
	    String[i]='0';
	 }String[Size]=0;
    4d0a:	c6 0f       	add	r28, r22
    4d0c:	d1 1d       	adc	r29, r1
    4d0e:	18 82       	st	Y, r1
  }
}
    4d10:	df 91       	pop	r29
    4d12:	cf 91       	pop	r28
    4d14:	08 95       	ret

00004d16 <StrCalc>:
     
	 //if (NinePos<Length-4)
	 StrCalc(TPLUS,strMaxValue,strOverflowed,strOverflowed);
}
                                                                   //     1111111 
void StrCalc(char TOperation, char *strA , char *strB, char *strC){//  A: 00000000
    4d16:	3f 92       	push	r3
    4d18:	4f 92       	push	r4
    4d1a:	5f 92       	push	r5
    4d1c:	6f 92       	push	r6
    4d1e:	7f 92       	push	r7
    4d20:	8f 92       	push	r8
    4d22:	9f 92       	push	r9
    4d24:	af 92       	push	r10
    4d26:	bf 92       	push	r11
    4d28:	cf 92       	push	r12
    4d2a:	df 92       	push	r13
    4d2c:	ef 92       	push	r14
    4d2e:	ff 92       	push	r15
    4d30:	0f 93       	push	r16
    4d32:	1f 93       	push	r17
    4d34:	df 93       	push	r29
    4d36:	cf 93       	push	r28
    4d38:	cd b7       	in	r28, 0x3d	; 61
    4d3a:	de b7       	in	r29, 0x3e	; 62
    4d3c:	c8 55       	subi	r28, 0x58	; 88
    4d3e:	d0 40       	sbci	r29, 0x00	; 0
    4d40:	0f b6       	in	r0, 0x3f	; 63
    4d42:	f8 94       	cli
    4d44:	de bf       	out	0x3e, r29	; 62
    4d46:	0f be       	out	0x3f, r0	; 63
    4d48:	cd bf       	out	0x3d, r28	; 61
    4d4a:	68 2e       	mov	r6, r24
    4d4c:	67 96       	adiw	r28, 0x17	; 23
    4d4e:	7f af       	std	Y+63, r23	; 0x3f
    4d50:	6e af       	std	Y+62, r22	; 0x3e
    4d52:	67 97       	sbiw	r28, 0x17	; 23
    4d54:	69 96       	adiw	r28, 0x19	; 25
    4d56:	5f af       	std	Y+63, r21	; 0x3f
    4d58:	4e af       	std	Y+62, r20	; 0x3e
    4d5a:	69 97       	sbiw	r28, 0x19	; 25
    4d5c:	59 01       	movw	r10, r18
    4d5e:	fe 01       	movw	r30, r28
    4d60:	31 96       	adiw	r30, 0x01	; 1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    4d62:	ce 01       	movw	r24, r28
    4d64:	45 96       	adiw	r24, 0x15	; 21
	     strMemory[i]=data;
    4d66:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    4d68:	e8 17       	cp	r30, r24
    4d6a:	f9 07       	cpc	r31, r25
    4d6c:	e1 f7       	brne	.-8      	; 0x4d66 <StrCalc+0x50>
	     strMemory[i]=data;
    4d6e:	ce 01       	movw	r24, r28
    4d70:	89 96       	adiw	r24, 0x29	; 41
    4d72:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    4d74:	e8 17       	cp	r30, r24
    4d76:	f9 07       	cpc	r31, r25
    4d78:	e1 f7       	brne	.-8      	; 0x4d72 <StrCalc+0x5c>
    4d7a:	fe 01       	movw	r30, r28
    4d7c:	fd 96       	adiw	r30, 0x3d	; 61
	     strMemory[i]=data;
    4d7e:	cf 01       	movw	r24, r30
    4d80:	44 96       	adiw	r24, 0x14	; 20
    4d82:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    4d84:	e8 17       	cp	r30, r24
    4d86:	f9 07       	cpc	r31, r25
    4d88:	e1 f7       	brne	.-8      	; 0x4d82 <StrCalc+0x6c>
	 FillChar(tmpB,sizeof(tmpB),0);
	 FillChar(Result,sizeof(Result),0);
                                            // -5    -5     5    5
	                                        // -6 -   6 -  -6 -  6 -
                                            // -5+6   
	 sprintf_P(tmpA,PSTR("%s"),strA);       // 
    4d8a:	00 d0       	rcall	.+0      	; 0x4d8c <StrCalc+0x76>
    4d8c:	00 d0       	rcall	.+0      	; 0x4d8e <StrCalc+0x78>
    4d8e:	00 d0       	rcall	.+0      	; 0x4d90 <StrCalc+0x7a>
    4d90:	ed b7       	in	r30, 0x3d	; 61
    4d92:	fe b7       	in	r31, 0x3e	; 62
    4d94:	31 96       	adiw	r30, 0x01	; 1
    4d96:	8e 01       	movw	r16, r28
    4d98:	0f 5f       	subi	r16, 0xFF	; 255
    4d9a:	1f 4f       	sbci	r17, 0xFF	; 255
    4d9c:	ad b7       	in	r26, 0x3d	; 61
    4d9e:	be b7       	in	r27, 0x3e	; 62
    4da0:	12 96       	adiw	r26, 0x02	; 2
    4da2:	1c 93       	st	X, r17
    4da4:	0e 93       	st	-X, r16
    4da6:	11 97       	sbiw	r26, 0x01	; 1
    4da8:	81 eb       	ldi	r24, 0xB1	; 177
    4daa:	95 e0       	ldi	r25, 0x05	; 5
    4dac:	93 83       	std	Z+3, r25	; 0x03
    4dae:	82 83       	std	Z+2, r24	; 0x02
    4db0:	67 96       	adiw	r28, 0x17	; 23
    4db2:	2e ad       	ldd	r18, Y+62	; 0x3e
    4db4:	3f ad       	ldd	r19, Y+63	; 0x3f
    4db6:	67 97       	sbiw	r28, 0x17	; 23
    4db8:	35 83       	std	Z+5, r19	; 0x05
    4dba:	24 83       	std	Z+4, r18	; 0x04
    4dbc:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
	 sprintf_P(tmpB,PSTR("%s"),strB);  
    4dc0:	ed b7       	in	r30, 0x3d	; 61
    4dc2:	fe b7       	in	r31, 0x3e	; 62
    4dc4:	31 96       	adiw	r30, 0x01	; 1
    4dc6:	ce 01       	movw	r24, r28
    4dc8:	45 96       	adiw	r24, 0x15	; 21
    4dca:	ad b7       	in	r26, 0x3d	; 61
    4dcc:	be b7       	in	r27, 0x3e	; 62
    4dce:	12 96       	adiw	r26, 0x02	; 2
    4dd0:	9c 93       	st	X, r25
    4dd2:	8e 93       	st	-X, r24
    4dd4:	11 97       	sbiw	r26, 0x01	; 1
    4dd6:	8e ea       	ldi	r24, 0xAE	; 174
    4dd8:	95 e0       	ldi	r25, 0x05	; 5
    4dda:	93 83       	std	Z+3, r25	; 0x03
    4ddc:	82 83       	std	Z+2, r24	; 0x02
    4dde:	69 96       	adiw	r28, 0x19	; 25
    4de0:	2e ad       	ldd	r18, Y+62	; 0x3e
    4de2:	3f ad       	ldd	r19, Y+63	; 0x3f
    4de4:	69 97       	sbiw	r28, 0x19	; 25
    4de6:	35 83       	std	Z+5, r19	; 0x05
    4de8:	24 83       	std	Z+4, r18	; 0x04
    4dea:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>

     if (IsMinus(tmpA)==True){
    4dee:	8d b7       	in	r24, 0x3d	; 61
    4df0:	9e b7       	in	r25, 0x3e	; 62
    4df2:	06 96       	adiw	r24, 0x06	; 6
    4df4:	0f b6       	in	r0, 0x3f	; 63
    4df6:	f8 94       	cli
    4df8:	9e bf       	out	0x3e, r25	; 62
    4dfa:	0f be       	out	0x3f, r0	; 63
    4dfc:	8d bf       	out	0x3d, r24	; 61
    4dfe:	c8 01       	movw	r24, r16
    4e00:	0e 94 12 22 	call	0x4424	; 0x4424 <IsMinus>
    4e04:	81 30       	cpi	r24, 0x01	; 1
    4e06:	21 f0       	breq	.+8      	; 0x4e10 <StrCalc+0xfa>
    4e08:	65 96       	adiw	r28, 0x15	; 21
    4e0a:	1f ae       	std	Y+63, r1	; 0x3f
    4e0c:	65 97       	sbiw	r28, 0x15	; 21
    4e0e:	07 c0       	rjmp	.+14     	; 0x4e1e <StrCalc+0x108>
	     RemoveMinus(tmpA);
    4e10:	c8 01       	movw	r24, r16
    4e12:	0e 94 17 22 	call	0x442e	; 0x442e <RemoveMinus>
    4e16:	91 e0       	ldi	r25, 0x01	; 1
    4e18:	65 96       	adiw	r28, 0x15	; 21
    4e1a:	9f af       	std	Y+63, r25	; 0x3f
    4e1c:	65 97       	sbiw	r28, 0x15	; 21
		 IsMinA=True;
	 }
     if (IsMinus(tmpB)==True){
    4e1e:	8e 01       	movw	r16, r28
    4e20:	0b 5e       	subi	r16, 0xEB	; 235
    4e22:	1f 4f       	sbci	r17, 0xFF	; 255
    4e24:	c8 01       	movw	r24, r16
    4e26:	0e 94 12 22 	call	0x4424	; 0x4424 <IsMinus>
    4e2a:	81 30       	cpi	r24, 0x01	; 1
    4e2c:	21 f0       	breq	.+8      	; 0x4e36 <StrCalc+0x120>
    4e2e:	64 96       	adiw	r28, 0x14	; 20
    4e30:	1f ae       	std	Y+63, r1	; 0x3f
    4e32:	64 97       	sbiw	r28, 0x14	; 20
    4e34:	07 c0       	rjmp	.+14     	; 0x4e44 <StrCalc+0x12e>
	     RemoveMinus(tmpB);
    4e36:	c8 01       	movw	r24, r16
    4e38:	0e 94 17 22 	call	0x442e	; 0x442e <RemoveMinus>
    4e3c:	a1 e0       	ldi	r26, 0x01	; 1
    4e3e:	64 96       	adiw	r28, 0x14	; 20
    4e40:	af af       	std	Y+63, r26	; 0x3f
    4e42:	64 97       	sbiw	r28, 0x14	; 20
		 IsMinB=True;
	 }    	

     lenA=strlen(tmpA);
    4e44:	fe 01       	movw	r30, r28
    4e46:	31 96       	adiw	r30, 0x01	; 1
    4e48:	df 01       	movw	r26, r30
    4e4a:	0d 90       	ld	r0, X+
    4e4c:	00 20       	and	r0, r0
    4e4e:	e9 f7       	brne	.-6      	; 0x4e4a <StrCalc+0x134>
    4e50:	cd 01       	movw	r24, r26
    4e52:	01 97       	sbiw	r24, 0x01	; 1
    4e54:	8e 1b       	sub	r24, r30
    4e56:	9f 0b       	sbc	r25, r31
     lenB=strlen(tmpB);
    4e58:	de 01       	movw	r26, r28
    4e5a:	55 96       	adiw	r26, 0x15	; 21
    4e5c:	fd 01       	movw	r30, r26
    4e5e:	01 90       	ld	r0, Z+
    4e60:	00 20       	and	r0, r0
    4e62:	e9 f7       	brne	.-6      	; 0x4e5e <StrCalc+0x148>
    4e64:	31 97       	sbiw	r30, 0x01	; 1
     /*
	 sprintf_P(strSend,PSTR("A:%s"),strA);	 _uart_print(0,1,strSend);
	 sprintf_P(strSend,PSTR("B:%s"),strB);	 _uart_print(0,1,strSend);
     */

     AddZeroLead(tmpA,FixLen+1);
    4e66:	1e 2f       	mov	r17, r30
    4e68:	1a 1b       	sub	r17, r26
    4e6a:	18 17       	cp	r17, r24
    4e6c:	08 f4       	brcc	.+2      	; 0x4e70 <StrCalc+0x15a>
    4e6e:	18 2f       	mov	r17, r24
    4e70:	1f 5f       	subi	r17, 0xFF	; 255
    4e72:	7e 01       	movw	r14, r28
    4e74:	08 94       	sec
    4e76:	e1 1c       	adc	r14, r1
    4e78:	f1 1c       	adc	r15, r1
    4e7a:	c7 01       	movw	r24, r14
    4e7c:	61 2f       	mov	r22, r17
    4e7e:	0e 94 5b 25 	call	0x4ab6	; 0x4ab6 <AddZeroLead>
     AddZeroLead(tmpB,FixLen+1);
    4e82:	a5 e1       	ldi	r26, 0x15	; 21
    4e84:	ca 2e       	mov	r12, r26
    4e86:	d1 2c       	mov	r13, r1
    4e88:	cc 0e       	add	r12, r28
    4e8a:	dd 1e       	adc	r13, r29
    4e8c:	c6 01       	movw	r24, r12
    4e8e:	61 2f       	mov	r22, r17
    4e90:	0e 94 5b 25 	call	0x4ab6	; 0x4ab6 <AddZeroLead>
	 _uart_print(0,1,strSend);
	 sprintf_P(strSend,PSTR("B:%s"),strB);
	 _uart_print(0,1,strSend);
	 */

     lenA=strlen(tmpA);
    4e94:	f7 01       	movw	r30, r14
    4e96:	01 90       	ld	r0, Z+
    4e98:	00 20       	and	r0, r0
    4e9a:	e9 f7       	brne	.-6      	; 0x4e96 <StrCalc+0x180>
    4e9c:	31 97       	sbiw	r30, 0x01	; 1
    4e9e:	7e 2e       	mov	r7, r30
    4ea0:	7e 18       	sub	r7, r14
     lenB=strlen(tmpB);
    4ea2:	f6 01       	movw	r30, r12
    4ea4:	01 90       	ld	r0, Z+
    4ea6:	00 20       	and	r0, r0
    4ea8:	e9 f7       	brne	.-6      	; 0x4ea4 <StrCalc+0x18e>
    4eaa:	31 97       	sbiw	r30, 0x01	; 1
    4eac:	9e 2e       	mov	r9, r30
    4eae:	9c 18       	sub	r9, r12
     IsNegative=False;
	 
	 IsNegative=False;
	 IsSwap=False;

	 if (IsMoreThan(tmpB,tmpA)==True){
    4eb0:	c6 01       	movw	r24, r12
    4eb2:	b7 01       	movw	r22, r14
    4eb4:	0e 94 44 22 	call	0x4488	; 0x4488 <IsMoreThan>
    4eb8:	81 30       	cpi	r24, 0x01	; 1
    4eba:	11 f0       	breq	.+4      	; 0x4ec0 <StrCalc+0x1aa>
    4ebc:	80 e0       	ldi	r24, 0x00	; 0
    4ebe:	42 c0       	rjmp	.+132    	; 0x4f44 <StrCalc+0x22e>
	     IsSwap=True;
         sprintf_P(tmpC,PSTR("%s"),tmpA);
    4ec0:	00 d0       	rcall	.+0      	; 0x4ec2 <StrCalc+0x1ac>
    4ec2:	00 d0       	rcall	.+0      	; 0x4ec4 <StrCalc+0x1ae>
    4ec4:	00 d0       	rcall	.+0      	; 0x4ec6 <StrCalc+0x1b0>
    4ec6:	ed b7       	in	r30, 0x3d	; 61
    4ec8:	fe b7       	in	r31, 0x3e	; 62
    4eca:	31 96       	adiw	r30, 0x01	; 1
    4ecc:	8e 01       	movw	r16, r28
    4ece:	07 5d       	subi	r16, 0xD7	; 215
    4ed0:	1f 4f       	sbci	r17, 0xFF	; 255
    4ed2:	ad b7       	in	r26, 0x3d	; 61
    4ed4:	be b7       	in	r27, 0x3e	; 62
    4ed6:	12 96       	adiw	r26, 0x02	; 2
    4ed8:	1c 93       	st	X, r17
    4eda:	0e 93       	st	-X, r16
    4edc:	11 97       	sbiw	r26, 0x01	; 1
    4ede:	8b ea       	ldi	r24, 0xAB	; 171
    4ee0:	95 e0       	ldi	r25, 0x05	; 5
    4ee2:	93 83       	std	Z+3, r25	; 0x03
    4ee4:	82 83       	std	Z+2, r24	; 0x02
    4ee6:	f5 82       	std	Z+5, r15	; 0x05
    4ee8:	e4 82       	std	Z+4, r14	; 0x04
    4eea:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
		 sprintf_P(tmpA,PSTR("%s"),tmpB);
    4eee:	ed b7       	in	r30, 0x3d	; 61
    4ef0:	fe b7       	in	r31, 0x3e	; 62
    4ef2:	31 96       	adiw	r30, 0x01	; 1
    4ef4:	ad b7       	in	r26, 0x3d	; 61
    4ef6:	be b7       	in	r27, 0x3e	; 62
    4ef8:	12 96       	adiw	r26, 0x02	; 2
    4efa:	fc 92       	st	X, r15
    4efc:	ee 92       	st	-X, r14
    4efe:	11 97       	sbiw	r26, 0x01	; 1
    4f00:	88 ea       	ldi	r24, 0xA8	; 168
    4f02:	95 e0       	ldi	r25, 0x05	; 5
    4f04:	93 83       	std	Z+3, r25	; 0x03
    4f06:	82 83       	std	Z+2, r24	; 0x02
    4f08:	d5 82       	std	Z+5, r13	; 0x05
    4f0a:	c4 82       	std	Z+4, r12	; 0x04
    4f0c:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
		 sprintf_P(tmpB,PSTR("%s"),tmpC);
    4f10:	ed b7       	in	r30, 0x3d	; 61
    4f12:	fe b7       	in	r31, 0x3e	; 62
    4f14:	31 96       	adiw	r30, 0x01	; 1
    4f16:	ad b7       	in	r26, 0x3d	; 61
    4f18:	be b7       	in	r27, 0x3e	; 62
    4f1a:	12 96       	adiw	r26, 0x02	; 2
    4f1c:	dc 92       	st	X, r13
    4f1e:	ce 92       	st	-X, r12
    4f20:	11 97       	sbiw	r26, 0x01	; 1
    4f22:	85 ea       	ldi	r24, 0xA5	; 165
    4f24:	95 e0       	ldi	r25, 0x05	; 5
    4f26:	93 83       	std	Z+3, r25	; 0x03
    4f28:	82 83       	std	Z+2, r24	; 0x02
    4f2a:	15 83       	std	Z+5, r17	; 0x05
    4f2c:	04 83       	std	Z+4, r16	; 0x04
    4f2e:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    4f32:	81 e0       	ldi	r24, 0x01	; 1
    4f34:	ed b7       	in	r30, 0x3d	; 61
    4f36:	fe b7       	in	r31, 0x3e	; 62
    4f38:	36 96       	adiw	r30, 0x06	; 6
    4f3a:	0f b6       	in	r0, 0x3f	; 63
    4f3c:	f8 94       	cli
    4f3e:	fe bf       	out	0x3e, r31	; 62
    4f40:	0f be       	out	0x3f, r0	; 63
    4f42:	ed bf       	out	0x3d, r30	; 61
	 }
    
	if (TOperation==TMINUS){
    4f44:	66 20       	and	r6, r6
    4f46:	39 f5       	brne	.+78     	; 0x4f96 <StrCalc+0x280>
	    TCalc=TOperation;
		IsNegative=False;
		if (IsSwap==True){
    4f48:	81 30       	cpi	r24, 0x01	; 1
    4f4a:	99 f4       	brne	.+38     	; 0x4f72 <StrCalc+0x25c>
		    if ((IsMinA==True)&&(IsMinB==True)){IsNegative=False;TCalc=TMINUS;}
    4f4c:	65 96       	adiw	r28, 0x15	; 21
    4f4e:	ff ad       	ldd	r31, Y+63	; 0x3f
    4f50:	65 97       	sbiw	r28, 0x15	; 21
    4f52:	f1 30       	cpi	r31, 0x01	; 1
    4f54:	39 f4       	brne	.+14     	; 0x4f64 <StrCalc+0x24e>
    4f56:	64 96       	adiw	r28, 0x14	; 20
    4f58:	2f ad       	ldd	r18, Y+63	; 0x3f
    4f5a:	64 97       	sbiw	r28, 0x14	; 20
    4f5c:	21 30       	cpi	r18, 0x01	; 1
    4f5e:	09 f0       	breq	.+2      	; 0x4f62 <StrCalc+0x24c>
    4f60:	9e c1       	rjmp	.+828    	; 0x529e <StrCalc+0x588>
    4f62:	42 c0       	rjmp	.+132    	; 0x4fe8 <StrCalc+0x2d2>
            else if ((IsMinA==True)&&(IsMinB==False)){IsNegative=True;TCalc=TPLUS;}
            else if ((IsMinA==False)&&(IsMinB==True)){IsNegative=False;TCalc=TPLUS;}
    4f64:	64 96       	adiw	r28, 0x14	; 20
    4f66:	3f ad       	ldd	r19, Y+63	; 0x3f
    4f68:	64 97       	sbiw	r28, 0x14	; 20
    4f6a:	31 30       	cpi	r19, 0x01	; 1
    4f6c:	09 f0       	breq	.+2      	; 0x4f70 <StrCalc+0x25a>
    4f6e:	8e c1       	rjmp	.+796    	; 0x528c <StrCalc+0x576>
    4f70:	92 c1       	rjmp	.+804    	; 0x5296 <StrCalc+0x580>
            else if ((IsMinA==False)&&(IsMinB==False)){IsNegative=True;TCalc=TMINUS;}
		}else
		if (IsSwap==False){
		    if ((IsMinA==True)&&(IsMinB==True)){IsNegative=True;TCalc=TMINUS;}
    4f72:	65 96       	adiw	r28, 0x15	; 21
    4f74:	8f ad       	ldd	r24, Y+63	; 0x3f
    4f76:	65 97       	sbiw	r28, 0x15	; 21
    4f78:	81 30       	cpi	r24, 0x01	; 1
    4f7a:	39 f4       	brne	.+14     	; 0x4f8a <StrCalc+0x274>
    4f7c:	64 96       	adiw	r28, 0x14	; 20
    4f7e:	9f ad       	ldd	r25, Y+63	; 0x3f
    4f80:	64 97       	sbiw	r28, 0x14	; 20
    4f82:	91 30       	cpi	r25, 0x01	; 1
    4f84:	09 f0       	breq	.+2      	; 0x4f88 <StrCalc+0x272>
    4f86:	8b c1       	rjmp	.+790    	; 0x529e <StrCalc+0x588>
    4f88:	81 c1       	rjmp	.+770    	; 0x528c <StrCalc+0x576>
            else if ((IsMinA==True)&&(IsMinB==False)){IsNegative=True;TCalc=TPLUS;}
            else if ((IsMinA==False)&&(IsMinB==True)){IsNegative=False;TCalc=TPLUS;}
    4f8a:	64 96       	adiw	r28, 0x14	; 20
    4f8c:	af ad       	ldd	r26, Y+63	; 0x3f
    4f8e:	64 97       	sbiw	r28, 0x14	; 20
    4f90:	a1 30       	cpi	r26, 0x01	; 1
    4f92:	51 f5       	brne	.+84     	; 0x4fe8 <StrCalc+0x2d2>
    4f94:	80 c1       	rjmp	.+768    	; 0x5296 <StrCalc+0x580>
            else if ((IsMinA==False)&&(IsMinB==False)){IsNegative=False;TCalc=TMINUS;}
		}
	 }else
	if (TOperation==TPLUS){
    4f96:	b1 e0       	ldi	r27, 0x01	; 1
    4f98:	6b 16       	cp	r6, r27
    4f9a:	31 f5       	brne	.+76     	; 0x4fe8 <StrCalc+0x2d2>
	    TCalc=TOperation;
		IsNegative=False;
		if (IsSwap==True){
    4f9c:	81 30       	cpi	r24, 0x01	; 1
    4f9e:	91 f4       	brne	.+36     	; 0x4fc4 <StrCalc+0x2ae>
		    if ((IsMinA==True)&&(IsMinB==True)){IsNegative=True;TCalc=TPLUS;}
    4fa0:	65 96       	adiw	r28, 0x15	; 21
    4fa2:	ef ad       	ldd	r30, Y+63	; 0x3f
    4fa4:	65 97       	sbiw	r28, 0x15	; 21
    4fa6:	e1 30       	cpi	r30, 0x01	; 1
    4fa8:	31 f4       	brne	.+12     	; 0x4fb6 <StrCalc+0x2a0>
    4faa:	64 96       	adiw	r28, 0x14	; 20
    4fac:	ff ad       	ldd	r31, Y+63	; 0x3f
    4fae:	64 97       	sbiw	r28, 0x14	; 20
    4fb0:	f1 30       	cpi	r31, 0x01	; 1
    4fb2:	d1 f4       	brne	.+52     	; 0x4fe8 <StrCalc+0x2d2>
    4fb4:	74 c1       	rjmp	.+744    	; 0x529e <StrCalc+0x588>
            else if ((IsMinA==True)&&(IsMinB==False)){IsNegative=False;TCalc=TMINUS;}
            else if ((IsMinA==False)&&(IsMinB==True)){IsNegative=True;TCalc=TMINUS;}
    4fb6:	64 96       	adiw	r28, 0x14	; 20
    4fb8:	2f ad       	ldd	r18, Y+63	; 0x3f
    4fba:	64 97       	sbiw	r28, 0x14	; 20
    4fbc:	21 30       	cpi	r18, 0x01	; 1
    4fbe:	09 f0       	breq	.+2      	; 0x4fc2 <StrCalc+0x2ac>
    4fc0:	6a c1       	rjmp	.+724    	; 0x5296 <StrCalc+0x580>
    4fc2:	64 c1       	rjmp	.+712    	; 0x528c <StrCalc+0x576>
            else if ((IsMinA==False)&&(IsMinB==False)){IsNegative=False;TCalc=TPLUS;}
		}else
		if (IsSwap==False){
		    if ((IsMinA==True)&&(IsMinB==True)){IsNegative=True;TCalc=TPLUS;}
    4fc4:	65 96       	adiw	r28, 0x15	; 21
    4fc6:	3f ad       	ldd	r19, Y+63	; 0x3f
    4fc8:	65 97       	sbiw	r28, 0x15	; 21
    4fca:	31 30       	cpi	r19, 0x01	; 1
    4fcc:	39 f4       	brne	.+14     	; 0x4fdc <StrCalc+0x2c6>
    4fce:	64 96       	adiw	r28, 0x14	; 20
    4fd0:	8f ad       	ldd	r24, Y+63	; 0x3f
    4fd2:	64 97       	sbiw	r28, 0x14	; 20
    4fd4:	81 30       	cpi	r24, 0x01	; 1
    4fd6:	09 f0       	breq	.+2      	; 0x4fda <StrCalc+0x2c4>
    4fd8:	59 c1       	rjmp	.+690    	; 0x528c <StrCalc+0x576>
    4fda:	61 c1       	rjmp	.+706    	; 0x529e <StrCalc+0x588>
            else if ((IsMinA==True)&&(IsMinB==False)){IsNegative=True;TCalc=TMINUS;}
            else if ((IsMinA==False)&&(IsMinB==True)){IsNegative=False;TCalc=TMINUS;}
    4fdc:	64 96       	adiw	r28, 0x14	; 20
    4fde:	9f ad       	ldd	r25, Y+63	; 0x3f
    4fe0:	64 97       	sbiw	r28, 0x14	; 20
    4fe2:	91 30       	cpi	r25, 0x01	; 1
    4fe4:	09 f0       	breq	.+2      	; 0x4fe8 <StrCalc+0x2d2>
    4fe6:	57 c1       	rjmp	.+686    	; 0x5296 <StrCalc+0x580>
   // A: 100000
   // B: 000001 -
   // -----------
   // C: 099999

	 if (TCalc==TMINUS){
    4fe8:	62 96       	adiw	r28, 0x12	; 18
    4fea:	1f ae       	std	Y+63, r1	; 0x3f
    4fec:	62 97       	sbiw	r28, 0x12	; 18
     
	 //if (NinePos<Length-4)
	 StrCalc(TPLUS,strMaxValue,strOverflowed,strOverflowed);
}
                                                                   //     1111111 
void StrCalc(char TOperation, char *strA , char *strB, char *strC){//  A: 00000000
    4fee:	e7 2c       	mov	r14, r7
    4ff0:	ff 24       	eor	r15, r15
    4ff2:	67 01       	movw	r12, r14
    4ff4:	08 94       	sec
    4ff6:	c1 08       	sbc	r12, r1
    4ff8:	d1 08       	sbc	r13, r1
    4ffa:	ae 01       	movw	r20, r28
    4ffc:	43 5c       	subi	r20, 0xC3	; 195
    4ffe:	5f 4f       	sbci	r21, 0xFF	; 255
    5000:	4c 0d       	add	r20, r12
    5002:	5d 1d       	adc	r21, r13
    5004:	ce 01       	movw	r24, r28
    5006:	01 96       	adiw	r24, 0x01	; 1
    5008:	8c 01       	movw	r16, r24
    500a:	0c 0d       	add	r16, r12
    500c:	1d 1d       	adc	r17, r13
    500e:	be 01       	movw	r22, r28
    5010:	69 0d       	add	r22, r9
    5012:	71 1d       	adc	r23, r1
    5014:	6c 5e       	subi	r22, 0xEC	; 236
    5016:	7f 4f       	sbci	r23, 0xFF	; 255
    5018:	99 24       	eor	r9, r9
			     Result[lenA-i-1]=Chr(Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
			 }else
			 if (Ord(tmpA[lenA-i-1])<Ord(tmpB[lenB-i-1])){
			 //Pinjaman
			     for(j=i+1;j<lenA;j++){
				     if (tmpA[lenA-j-1]=='0')tmpA[lenA-j-1]='9';
    501a:	2c 01       	movw	r4, r24
    501c:	f9 e3       	ldi	r31, 0x39	; 57
    501e:	8f 2e       	mov	r8, r31
					 if (tmpA[lenA-j-1]!='0'){
					     tmpA[lenA-j-1]=Chr(Ord(tmpA[lenA-j-1])-1);
						 break;
					 }				 
				 }
				 Result[lenA-i-1]=Chr(10+Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
    5020:	9a e0       	ldi	r25, 0x0A	; 10
    5022:	52 c0       	rjmp	.+164    	; 0x50c8 <StrCalc+0x3b2>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    5024:	d8 01       	movw	r26, r16
    5026:	8c 91       	ld	r24, X
    5028:	80 53       	subi	r24, 0x30	; 48
    502a:	8a 30       	cpi	r24, 0x0A	; 10
    502c:	10 f0       	brcs	.+4      	; 0x5032 <StrCalc+0x31c>
    502e:	20 e0       	ldi	r18, 0x00	; 0
    5030:	01 c0       	rjmp	.+2      	; 0x5034 <StrCalc+0x31e>
    5032:	28 2f       	mov	r18, r24
   // -----------
   // C: 099999

	 if (TCalc==TMINUS){
	     for(i=0;i<lenA;i++){		 
		     if (Ord(tmpA[lenA-i-1])>=Ord(tmpB[lenB-i-1])){
    5034:	fb 01       	movw	r30, r22
    5036:	30 81       	ld	r19, Z
    5038:	30 53       	subi	r19, 0x30	; 48
    503a:	3a 30       	cpi	r19, 0x0A	; 10
    503c:	10 f4       	brcc	.+4      	; 0x5042 <StrCalc+0x32c>
    503e:	23 17       	cp	r18, r19
    5040:	40 f0       	brcs	.+16     	; 0x5052 <StrCalc+0x33c>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    5042:	8a 30       	cpi	r24, 0x0A	; 10
    5044:	08 f0       	brcs	.+2      	; 0x5048 <StrCalc+0x332>
    5046:	80 e0       	ldi	r24, 0x00	; 0

	 if (TCalc==TMINUS){
	     for(i=0;i<lenA;i++){		 
		     if (Ord(tmpA[lenA-i-1])>=Ord(tmpB[lenB-i-1])){
			 //Cukup
			     Result[lenA-i-1]=Chr(Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
    5048:	3a 30       	cpi	r19, 0x0A	; 10
    504a:	08 f0       	brcs	.+2      	; 0x504e <StrCalc+0x338>
    504c:	30 e0       	ldi	r19, 0x00	; 0
    504e:	83 1b       	sub	r24, r19
    5050:	2d c0       	rjmp	.+90     	; 0x50ac <StrCalc+0x396>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    5052:	8a 30       	cpi	r24, 0x0A	; 10
    5054:	10 f4       	brcc	.+4      	; 0x505a <StrCalc+0x344>
	     for(i=0;i<lenA;i++){		 
		     if (Ord(tmpA[lenA-i-1])>=Ord(tmpB[lenB-i-1])){
			 //Cukup
			     Result[lenA-i-1]=Chr(Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
			 }else
			 if (Ord(tmpA[lenA-i-1])<Ord(tmpB[lenB-i-1])){
    5056:	83 17       	cp	r24, r19
    5058:	80 f5       	brcc	.+96     	; 0x50ba <StrCalc+0x3a4>
    505a:	29 2d       	mov	r18, r9
    505c:	0a c0       	rjmp	.+20     	; 0x5072 <StrCalc+0x35c>
			 //Pinjaman
			     for(j=i+1;j<lenA;j++){
				     if (tmpA[lenA-j-1]=='0')tmpA[lenA-j-1]='9';
    505e:	f6 01       	movw	r30, r12
    5060:	e2 1b       	sub	r30, r18
    5062:	f1 09       	sbc	r31, r1
    5064:	d2 01       	movw	r26, r4
    5066:	ae 0f       	add	r26, r30
    5068:	bf 1f       	adc	r27, r31
    506a:	8c 91       	ld	r24, X
    506c:	80 33       	cpi	r24, 0x30	; 48
    506e:	29 f4       	brne	.+10     	; 0x507a <StrCalc+0x364>
    5070:	8c 92       	st	X, r8
			 //Cukup
			     Result[lenA-i-1]=Chr(Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
			 }else
			 if (Ord(tmpA[lenA-i-1])<Ord(tmpB[lenB-i-1])){
			 //Pinjaman
			     for(j=i+1;j<lenA;j++){
    5072:	2f 5f       	subi	r18, 0xFF	; 255
    5074:	27 15       	cp	r18, r7
    5076:	98 f3       	brcs	.-26     	; 0x505e <StrCalc+0x348>
    5078:	10 c0       	rjmp	.+32     	; 0x509a <StrCalc+0x384>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    507a:	28 2f       	mov	r18, r24
    507c:	20 53       	subi	r18, 0x30	; 48
    507e:	2a 30       	cpi	r18, 0x0A	; 10
    5080:	08 f0       	brcs	.+2      	; 0x5084 <StrCalc+0x36e>
    5082:	20 e0       	ldi	r18, 0x00	; 0
			 //Pinjaman
			     for(j=i+1;j<lenA;j++){
				     if (tmpA[lenA-j-1]=='0')tmpA[lenA-j-1]='9';
					 else
					 if (tmpA[lenA-j-1]!='0'){
					     tmpA[lenA-j-1]=Chr(Ord(tmpA[lenA-j-1])-1);
    5084:	82 2f       	mov	r24, r18
    5086:	81 50       	subi	r24, 0x01	; 1
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    5088:	8a 30       	cpi	r24, 0x0A	; 10
    508a:	10 f0       	brcs	.+4      	; 0x5090 <StrCalc+0x37a>
    508c:	80 e3       	ldi	r24, 0x30	; 48
    508e:	02 c0       	rjmp	.+4      	; 0x5094 <StrCalc+0x37e>
	    Result='0'+X;
    5090:	82 2f       	mov	r24, r18
    5092:	81 5d       	subi	r24, 0xD1	; 209
			 //Pinjaman
			     for(j=i+1;j<lenA;j++){
				     if (tmpA[lenA-j-1]=='0')tmpA[lenA-j-1]='9';
					 else
					 if (tmpA[lenA-j-1]!='0'){
					     tmpA[lenA-j-1]=Chr(Ord(tmpA[lenA-j-1])-1);
    5094:	e4 0d       	add	r30, r4
    5096:	f5 1d       	adc	r31, r5
    5098:	80 83       	st	Z, r24
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    509a:	f8 01       	movw	r30, r16
    509c:	20 81       	ld	r18, Z
    509e:	20 53       	subi	r18, 0x30	; 48
    50a0:	2a 30       	cpi	r18, 0x0A	; 10
    50a2:	08 f0       	brcs	.+2      	; 0x50a6 <StrCalc+0x390>
    50a4:	20 e0       	ldi	r18, 0x00	; 0
					 if (tmpA[lenA-j-1]!='0'){
					     tmpA[lenA-j-1]=Chr(Ord(tmpA[lenA-j-1])-1);
						 break;
					 }				 
				 }
				 Result[lenA-i-1]=Chr(10+Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
    50a6:	89 2f       	mov	r24, r25
    50a8:	83 1b       	sub	r24, r19
    50aa:	82 0f       	add	r24, r18
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    50ac:	8a 30       	cpi	r24, 0x0A	; 10
    50ae:	10 f0       	brcs	.+4      	; 0x50b4 <StrCalc+0x39e>
    50b0:	80 e3       	ldi	r24, 0x30	; 48
    50b2:	01 c0       	rjmp	.+2      	; 0x50b6 <StrCalc+0x3a0>
	    Result='0'+X;
    50b4:	80 5d       	subi	r24, 0xD0	; 208
					 if (tmpA[lenA-j-1]!='0'){
					     tmpA[lenA-j-1]=Chr(Ord(tmpA[lenA-j-1])-1);
						 break;
					 }				 
				 }
				 Result[lenA-i-1]=Chr(10+Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
    50b6:	da 01       	movw	r26, r20
    50b8:	8c 93       	st	X, r24
   // B: 000001 -
   // -----------
   // C: 099999

	 if (TCalc==TMINUS){
	     for(i=0;i<lenA;i++){		 
    50ba:	93 94       	inc	r9
    50bc:	41 50       	subi	r20, 0x01	; 1
    50be:	50 40       	sbci	r21, 0x00	; 0
    50c0:	01 50       	subi	r16, 0x01	; 1
    50c2:	10 40       	sbci	r17, 0x00	; 0
    50c4:	61 50       	subi	r22, 0x01	; 1
    50c6:	70 40       	sbci	r23, 0x00	; 0
    50c8:	97 14       	cp	r9, r7
    50ca:	08 f4       	brcc	.+2      	; 0x50ce <StrCalc+0x3b8>
    50cc:	ab cf       	rjmp	.-170    	; 0x5024 <StrCalc+0x30e>
						 break;
					 }				 
				 }
				 Result[lenA-i-1]=Chr(10+Ord(tmpA[lenA-i-1])-Ord(tmpB[lenB-i-1]));
			 }
		 }Result[lenA]=0;		    
    50ce:	8e 01       	movw	r16, r28
    50d0:	03 5c       	subi	r16, 0xC3	; 195
    50d2:	1f 4f       	sbci	r17, 0xFF	; 255
    50d4:	e0 0e       	add	r14, r16
    50d6:	f1 1e       	adc	r15, r17
    50d8:	f7 01       	movw	r30, r14
    50da:	10 82       	st	Z, r1
       RemZeroLead(Result);
    50dc:	c8 01       	movw	r24, r16
    50de:	0e 94 dd 23 	call	0x47ba	; 0x47ba <RemZeroLead>
//	 sprintf_P(strSend,PSTR("C':%s"),Result);
//	 _uart_print(0,1,strSend);
		 
		 FixLen=strlen(Result);
    50e2:	f8 01       	movw	r30, r16
    50e4:	01 90       	ld	r0, Z+
    50e6:	00 20       	and	r0, r0
    50e8:	e9 f7       	brne	.-6      	; 0x50e4 <StrCalc+0x3ce>
    50ea:	31 97       	sbiw	r30, 0x01	; 1
    50ec:	3e 2f       	mov	r19, r30
    50ee:	30 1b       	sub	r19, r16
    50f0:	d8 01       	movw	r26, r16
    50f2:	20 e0       	ldi	r18, 0x00	; 0
    50f4:	90 e0       	ldi	r25, 0x00	; 0
		 iPos=0;
		 for(i=0;i<FixLen;i++){
		     if ((i==0)&&(IsNegative==True)){
			     strC[iPos]='-';
    50f6:	4d e2       	ldi	r20, 0x2D	; 45
    50f8:	13 c0       	rjmp	.+38     	; 0x5120 <StrCalc+0x40a>
//	 _uart_print(0,1,strSend);
		 
		 FixLen=strlen(Result);
		 iPos=0;
		 for(i=0;i<FixLen;i++){
		     if ((i==0)&&(IsNegative==True)){
    50fa:	22 23       	and	r18, r18
    50fc:	51 f4       	brne	.+20     	; 0x5112 <StrCalc+0x3fc>
    50fe:	62 96       	adiw	r28, 0x12	; 18
    5100:	ff ad       	ldd	r31, Y+63	; 0x3f
    5102:	62 97       	sbiw	r28, 0x12	; 18
    5104:	f1 30       	cpi	r31, 0x01	; 1
    5106:	29 f4       	brne	.+10     	; 0x5112 <StrCalc+0x3fc>
			     strC[iPos]='-';
    5108:	f5 01       	movw	r30, r10
    510a:	e9 0f       	add	r30, r25
    510c:	f1 1d       	adc	r31, r1
    510e:	40 83       	st	Z, r20
				 iPos++;
    5110:	9f 5f       	subi	r25, 0xFF	; 255
			 }
		     strC[iPos]=Result[i];
    5112:	f5 01       	movw	r30, r10
    5114:	e9 0f       	add	r30, r25
    5116:	f1 1d       	adc	r31, r1
    5118:	8d 91       	ld	r24, X+
    511a:	80 83       	st	Z, r24
			 iPos++;
    511c:	9f 5f       	subi	r25, 0xFF	; 255
//	 sprintf_P(strSend,PSTR("C':%s"),Result);
//	 _uart_print(0,1,strSend);
		 
		 FixLen=strlen(Result);
		 iPos=0;
		 for(i=0;i<FixLen;i++){
    511e:	2f 5f       	subi	r18, 0xFF	; 255
    5120:	23 17       	cp	r18, r19
    5122:	58 f3       	brcs	.-42     	; 0x50fa <StrCalc+0x3e4>
			     strC[iPos]='-';
				 iPos++;
			 }
		     strC[iPos]=Result[i];
			 iPos++;
		 }strC[iPos]=0;
    5124:	f5 01       	movw	r30, r10
    5126:	e9 0f       	add	r30, r25
    5128:	f1 1d       	adc	r31, r1
    512a:	10 82       	st	Z, r1
    512c:	a0 c0       	rjmp	.+320    	; 0x526e <StrCalc+0x558>
	 }
	 else                     //         1
	 if (TCalc==TPLUS){  //A:099999999
    512e:	ed e3       	ldi	r30, 0x3D	; 61
    5130:	ee 2e       	mov	r14, r30
    5132:	f1 2c       	mov	r15, r1
    5134:	ec 0e       	add	r14, r28
    5136:	fd 1e       	adc	r15, r29
    5138:	ae 01       	movw	r20, r28
    513a:	49 0d       	add	r20, r9
    513c:	51 1d       	adc	r21, r1
    513e:	4c 5e       	subi	r20, 0xEC	; 236
    5140:	5f 4f       	sbci	r21, 0xFF	; 255
     
	 //if (NinePos<Length-4)
	 StrCalc(TPLUS,strMaxValue,strOverflowed,strOverflowed);
}
                                                                   //     1111111 
void StrCalc(char TOperation, char *strA , char *strB, char *strC){//  A: 00000000
    5142:	07 2d       	mov	r16, r7
    5144:	10 e0       	ldi	r17, 0x00	; 0
    5146:	48 01       	movw	r8, r16
    5148:	08 94       	sec
    514a:	81 08       	sbc	r8, r1
    514c:	91 08       	sbc	r9, r1
    514e:	ce 01       	movw	r24, r28
    5150:	01 96       	adiw	r24, 0x01	; 1
    5152:	6c 01       	movw	r12, r24
    5154:	c8 0c       	add	r12, r8
    5156:	d9 1c       	adc	r13, r9
    5158:	30 e0       	ldi	r19, 0x00	; 0
    515a:	20 e0       	ldi	r18, 0x00	; 0
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    515c:	2c 01       	movw	r4, r24
                 //Lebih
				 Result[i]=Chr(newC%10);
				 zMin=newC/10;
			     for(j=i+1;j<lenA;j++){
				     if ((Ord(tmpA[lenA-j-1])+zMin)>=10){
					     tmpA[lenA-j-1]=Chr((Ord(tmpA[lenA-j-1])+zMin)%10);
    515e:	70 e3       	ldi	r23, 0x30	; 48
    5160:	37 2e       	mov	r3, r23
    5162:	47 c0       	rjmp	.+142    	; 0x51f2 <StrCalc+0x4dc>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    5164:	d6 01       	movw	r26, r12
    5166:	9c 91       	ld	r25, X
    5168:	90 53       	subi	r25, 0x30	; 48
    516a:	9a 30       	cpi	r25, 0x0A	; 10
    516c:	08 f0       	brcs	.+2      	; 0x5170 <StrCalc+0x45a>
    516e:	90 e0       	ldi	r25, 0x00	; 0
	 }
	 else                     //         1
	 if (TCalc==TPLUS){  //A:099999999
	     zMin=0;              //B:000000001
	     for(i=0;i<lenA;i++){ //C:       00
		     newC=(Ord(tmpA[lenA-i-1])+Ord(tmpB[lenB-i-1]));			 
    5170:	fa 01       	movw	r30, r20
    5172:	80 81       	ld	r24, Z
    5174:	80 53       	subi	r24, 0x30	; 48
    5176:	8a 30       	cpi	r24, 0x0A	; 10
    5178:	08 f0       	brcs	.+2      	; 0x517c <StrCalc+0x466>
    517a:	80 e0       	ldi	r24, 0x00	; 0
    517c:	89 0f       	add	r24, r25
			 if (newC<10){
    517e:	8a 30       	cpi	r24, 0x0A	; 10
    5180:	18 f4       	brcc	.+6      	; 0x5188 <StrCalc+0x472>
			     Result[i]=Chr(newC);
    5182:	80 5d       	subi	r24, 0xD0	; 208
    5184:	d7 01       	movw	r26, r14
    5186:	28 c0       	rjmp	.+80     	; 0x51d8 <StrCalc+0x4c2>
				 zMin=newC/10;
			 }else if (newC>=10){
                 //Lebih
				 Result[i]=Chr(newC%10);
    5188:	6a e0       	ldi	r22, 0x0A	; 10
    518a:	0e 94 1f b7 	call	0x16e3e	; 0x16e3e <__udivmodqi4>
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    518e:	9a 30       	cpi	r25, 0x0A	; 10
    5190:	10 f0       	brcs	.+4      	; 0x5196 <StrCalc+0x480>
    5192:	90 e3       	ldi	r25, 0x30	; 48
    5194:	01 c0       	rjmp	.+2      	; 0x5198 <StrCalc+0x482>
	    Result='0'+X;
    5196:	90 5d       	subi	r25, 0xD0	; 208
			 if (newC<10){
			     Result[i]=Chr(newC);
				 zMin=newC/10;
			 }else if (newC>=10){
                 //Lebih
				 Result[i]=Chr(newC%10);
    5198:	f7 01       	movw	r30, r14
    519a:	90 83       	st	Z, r25
    519c:	83 2f       	mov	r24, r19
    519e:	0e c0       	rjmp	.+28     	; 0x51bc <StrCalc+0x4a6>
				 zMin=newC/10;
			     for(j=i+1;j<lenA;j++){
				     if ((Ord(tmpA[lenA-j-1])+zMin)>=10){
    51a0:	d4 01       	movw	r26, r8
    51a2:	a8 1b       	sub	r26, r24
    51a4:	b1 09       	sbc	r27, r1
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    51a6:	f2 01       	movw	r30, r4
    51a8:	ea 0f       	add	r30, r26
    51aa:	fb 1f       	adc	r31, r27
    51ac:	90 81       	ld	r25, Z
    51ae:	90 53       	subi	r25, 0x30	; 48
    51b0:	9a 30       	cpi	r25, 0x0A	; 10
    51b2:	08 f0       	brcs	.+2      	; 0x51b6 <StrCalc+0x4a0>
    51b4:	79 c0       	rjmp	.+242    	; 0x52a8 <StrCalc+0x592>
			 }else if (newC>=10){
                 //Lebih
				 Result[i]=Chr(newC%10);
				 zMin=newC/10;
			     for(j=i+1;j<lenA;j++){
				     if ((Ord(tmpA[lenA-j-1])+zMin)>=10){
    51b6:	99 30       	cpi	r25, 0x09	; 9
    51b8:	29 f4       	brne	.+10     	; 0x51c4 <StrCalc+0x4ae>
					     tmpA[lenA-j-1]=Chr((Ord(tmpA[lenA-j-1])+zMin)%10);
    51ba:	30 82       	st	Z, r3
				 zMin=newC/10;
			 }else if (newC>=10){
                 //Lebih
				 Result[i]=Chr(newC%10);
				 zMin=newC/10;
			     for(j=i+1;j<lenA;j++){
    51bc:	8f 5f       	subi	r24, 0xFF	; 255
    51be:	87 15       	cp	r24, r7
    51c0:	78 f3       	brcs	.-34     	; 0x51a0 <StrCalc+0x48a>
    51c2:	0d c0       	rjmp	.+26     	; 0x51de <StrCalc+0x4c8>
				     if ((Ord(tmpA[lenA-j-1])+zMin)>=10){
					     tmpA[lenA-j-1]=Chr((Ord(tmpA[lenA-j-1])+zMin)%10);
						 zMin=1;
					 }else{
					     tmpA[lenA-j-1]=Chr((Ord(tmpA[lenA-j-1])+zMin));
    51c4:	89 2f       	mov	r24, r25
    51c6:	8f 5f       	subi	r24, 0xFF	; 255
  return Result;
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
    51c8:	8a 30       	cpi	r24, 0x0A	; 10
    51ca:	10 f0       	brcs	.+4      	; 0x51d0 <StrCalc+0x4ba>
    51cc:	80 e3       	ldi	r24, 0x30	; 48
    51ce:	02 c0       	rjmp	.+4      	; 0x51d4 <StrCalc+0x4be>
	    Result='0'+X;
    51d0:	89 2f       	mov	r24, r25
    51d2:	8f 5c       	subi	r24, 0xCF	; 207
			     for(j=i+1;j<lenA;j++){
				     if ((Ord(tmpA[lenA-j-1])+zMin)>=10){
					     tmpA[lenA-j-1]=Chr((Ord(tmpA[lenA-j-1])+zMin)%10);
						 zMin=1;
					 }else{
					     tmpA[lenA-j-1]=Chr((Ord(tmpA[lenA-j-1])+zMin));
    51d4:	a4 0d       	add	r26, r4
    51d6:	b5 1d       	adc	r27, r5
    51d8:	8c 93       	st	X, r24
    51da:	20 e0       	ldi	r18, 0x00	; 0
    51dc:	01 c0       	rjmp	.+2      	; 0x51e0 <StrCalc+0x4ca>
				 zMin=newC/10;
			 }else if (newC>=10){
                 //Lebih
				 Result[i]=Chr(newC%10);
				 zMin=newC/10;
			     for(j=i+1;j<lenA;j++){
    51de:	21 e0       	ldi	r18, 0x01	; 1
		 }strC[iPos]=0;
	 }
	 else                     //         1
	 if (TCalc==TPLUS){  //A:099999999
	     zMin=0;              //B:000000001
	     for(i=0;i<lenA;i++){ //C:       00
    51e0:	3f 5f       	subi	r19, 0xFF	; 255
    51e2:	08 94       	sec
    51e4:	e1 1c       	adc	r14, r1
    51e6:	f1 1c       	adc	r15, r1
    51e8:	41 50       	subi	r20, 0x01	; 1
    51ea:	50 40       	sbci	r21, 0x00	; 0
    51ec:	08 94       	sec
    51ee:	c1 08       	sbc	r12, r1
    51f0:	d1 08       	sbc	r13, r1
    51f2:	37 15       	cp	r19, r7
    51f4:	08 f4       	brcc	.+2      	; 0x51f8 <StrCalc+0x4e2>
    51f6:	b6 cf       	rjmp	.-148    	; 0x5164 <StrCalc+0x44e>
}

char Chr(char X){//Return Char Value
     char Result='0';
	 if ((X>=0)&&(X<=9)){
	    Result='0'+X;
    51f8:	20 5d       	subi	r18, 0xD0	; 208
				 }//EndFor j                
			   }//End else
			 }//EndFor

		  //Result[lenA]==Chr(zMin); ???
		  Result[lenA]=Chr(zMin);
    51fa:	de 01       	movw	r26, r28
    51fc:	dd 96       	adiw	r26, 0x3d	; 61
    51fe:	fd 01       	movw	r30, r26
    5200:	e0 0f       	add	r30, r16
    5202:	f1 1f       	adc	r31, r17
    5204:	20 83       	st	Z, r18
		  Result[lenA+1]=0;
    5206:	0c 0f       	add	r16, r28
    5208:	1d 1f       	adc	r17, r29
    520a:	f8 01       	movw	r30, r16
    520c:	16 ae       	std	Z+62, r1	; 0x3e
		 FixLen=strlen(Result);
		 for(i=0;i<FixLen;i++){
		     strC[i]=Result[FixLen-i-1];
		 }strC[FixLen]=0;
*/
         FixLen=strlen(Result);
    520e:	fd 01       	movw	r30, r26
    5210:	01 90       	ld	r0, Z+
    5212:	00 20       	and	r0, r0
    5214:	e9 f7       	brne	.-6      	; 0x5210 <StrCalc+0x4fa>
    5216:	31 97       	sbiw	r30, 0x01	; 1
    5218:	5e 2f       	mov	r21, r30
    521a:	5a 1b       	sub	r21, r26
    521c:	25 2f       	mov	r18, r21
    521e:	30 e0       	ldi	r19, 0x00	; 0
    5220:	21 50       	subi	r18, 0x01	; 1
    5222:	30 40       	sbci	r19, 0x00	; 0
    5224:	2a 0f       	add	r18, r26
    5226:	3b 1f       	adc	r19, r27
    5228:	40 e0       	ldi	r20, 0x00	; 0
    522a:	90 e0       	ldi	r25, 0x00	; 0
		 iPos=0;
		 for(i=0;i<FixLen;i++){
		     if ((i==0)&&(IsNegative==True)){
			     strC[iPos]='-';
    522c:	6d e2       	ldi	r22, 0x2D	; 45
    522e:	16 c0       	rjmp	.+44     	; 0x525c <StrCalc+0x546>
		 }strC[FixLen]=0;
*/
         FixLen=strlen(Result);
		 iPos=0;
		 for(i=0;i<FixLen;i++){
		     if ((i==0)&&(IsNegative==True)){
    5230:	44 23       	and	r20, r20
    5232:	51 f4       	brne	.+20     	; 0x5248 <StrCalc+0x532>
    5234:	63 96       	adiw	r28, 0x13	; 19
    5236:	ff ad       	ldd	r31, Y+63	; 0x3f
    5238:	63 97       	sbiw	r28, 0x13	; 19
    523a:	f1 30       	cpi	r31, 0x01	; 1
    523c:	29 f4       	brne	.+10     	; 0x5248 <StrCalc+0x532>
			     strC[iPos]='-';
    523e:	f5 01       	movw	r30, r10
    5240:	e9 0f       	add	r30, r25
    5242:	f1 1d       	adc	r31, r1
    5244:	60 83       	st	Z, r22
				 iPos++;
    5246:	9f 5f       	subi	r25, 0xFF	; 255
			 }
		     strC[iPos]=Result[FixLen-i-1];
    5248:	f5 01       	movw	r30, r10
    524a:	e9 0f       	add	r30, r25
    524c:	f1 1d       	adc	r31, r1
    524e:	d9 01       	movw	r26, r18
    5250:	8c 91       	ld	r24, X
    5252:	80 83       	st	Z, r24
			 iPos++;
    5254:	9f 5f       	subi	r25, 0xFF	; 255
		     strC[i]=Result[FixLen-i-1];
		 }strC[FixLen]=0;
*/
         FixLen=strlen(Result);
		 iPos=0;
		 for(i=0;i<FixLen;i++){
    5256:	4f 5f       	subi	r20, 0xFF	; 255
    5258:	21 50       	subi	r18, 0x01	; 1
    525a:	30 40       	sbci	r19, 0x00	; 0
    525c:	45 17       	cp	r20, r21
    525e:	40 f3       	brcs	.-48     	; 0x5230 <StrCalc+0x51a>
			     strC[iPos]='-';
				 iPos++;
			 }
		     strC[iPos]=Result[FixLen-i-1];
			 iPos++;
		 }strC[iPos]=0;
    5260:	f5 01       	movw	r30, r10
    5262:	e9 0f       	add	r30, r25
    5264:	f1 1d       	adc	r31, r1
    5266:	10 82       	st	Z, r1

       RemZeroLead(strC);
    5268:	c5 01       	movw	r24, r10
    526a:	0e 94 dd 23 	call	0x47ba	; 0x47ba <RemZeroLead>
  //    sprintf_P(strSend,PSTR("C':%s"),strC);
//	 _uart_print(0,1,strSend);

	 }//EndIf 

	 if (TOperation==TMULTIPLY){
    526e:	b2 e0       	ldi	r27, 0x02	; 2
    5270:	6b 16       	cp	r6, r27
    5272:	e1 f4       	brne	.+56     	; 0x52ac <StrCalc+0x596>
		 valA=atol(strA);
		 valB=atol(strB);
		 valC=valA*valB;		 
         ltoa(valC,strC,10);
		 */
		 CalcMultiply(strA,strB,strC);
    5274:	67 96       	adiw	r28, 0x17	; 23
    5276:	8e ad       	ldd	r24, Y+62	; 0x3e
    5278:	9f ad       	ldd	r25, Y+63	; 0x3f
    527a:	67 97       	sbiw	r28, 0x17	; 23
    527c:	69 96       	adiw	r28, 0x19	; 25
    527e:	6e ad       	ldd	r22, Y+62	; 0x3e
    5280:	7f ad       	ldd	r23, Y+63	; 0x3f
    5282:	69 97       	sbiw	r28, 0x19	; 25
    5284:	a5 01       	movw	r20, r10
    5286:	0e 94 6f 29 	call	0x52de	; 0x52de <CalcMultiply>
    528a:	10 c0       	rjmp	.+32     	; 0x52ac <StrCalc+0x596>
	 }
}
    528c:	e1 e0       	ldi	r30, 0x01	; 1
    528e:	62 96       	adiw	r28, 0x12	; 18
    5290:	ef af       	std	Y+63, r30	; 0x3f
    5292:	62 97       	sbiw	r28, 0x12	; 18
    5294:	ac ce       	rjmp	.-680    	; 0x4fee <StrCalc+0x2d8>
    5296:	63 96       	adiw	r28, 0x13	; 19
    5298:	1f ae       	std	Y+63, r1	; 0x3f
    529a:	63 97       	sbiw	r28, 0x13	; 19
    529c:	48 cf       	rjmp	.-368    	; 0x512e <StrCalc+0x418>
    529e:	f1 e0       	ldi	r31, 0x01	; 1
    52a0:	63 96       	adiw	r28, 0x13	; 19
    52a2:	ff af       	std	Y+63, r31	; 0x3f
    52a4:	63 97       	sbiw	r28, 0x13	; 19
    52a6:	43 cf       	rjmp	.-378    	; 0x512e <StrCalc+0x418>
    52a8:	90 e0       	ldi	r25, 0x00	; 0
    52aa:	8c cf       	rjmp	.-232    	; 0x51c4 <StrCalc+0x4ae>
    52ac:	c8 5a       	subi	r28, 0xA8	; 168
    52ae:	df 4f       	sbci	r29, 0xFF	; 255
    52b0:	0f b6       	in	r0, 0x3f	; 63
    52b2:	f8 94       	cli
    52b4:	de bf       	out	0x3e, r29	; 62
    52b6:	0f be       	out	0x3f, r0	; 63
    52b8:	cd bf       	out	0x3d, r28	; 61
    52ba:	cf 91       	pop	r28
    52bc:	df 91       	pop	r29
    52be:	1f 91       	pop	r17
    52c0:	0f 91       	pop	r16
    52c2:	ff 90       	pop	r15
    52c4:	ef 90       	pop	r14
    52c6:	df 90       	pop	r13
    52c8:	cf 90       	pop	r12
    52ca:	bf 90       	pop	r11
    52cc:	af 90       	pop	r10
    52ce:	9f 90       	pop	r9
    52d0:	8f 90       	pop	r8
    52d2:	7f 90       	pop	r7
    52d4:	6f 90       	pop	r6
    52d6:	5f 90       	pop	r5
    52d8:	4f 90       	pop	r4
    52da:	3f 90       	pop	r3
    52dc:	08 95       	ret

000052de <CalcMultiply>:
	 }
	 strResult[lenR]=0;
}


void CalcMultiply(char *strA,char *strB,char *strC){
    52de:	4f 92       	push	r4
    52e0:	5f 92       	push	r5
    52e2:	6f 92       	push	r6
    52e4:	7f 92       	push	r7
    52e6:	8f 92       	push	r8
    52e8:	9f 92       	push	r9
    52ea:	af 92       	push	r10
    52ec:	bf 92       	push	r11
    52ee:	cf 92       	push	r12
    52f0:	df 92       	push	r13
    52f2:	ef 92       	push	r14
    52f4:	ff 92       	push	r15
    52f6:	0f 93       	push	r16
    52f8:	1f 93       	push	r17
    52fa:	df 93       	push	r29
    52fc:	cf 93       	push	r28
    52fe:	cd b7       	in	r28, 0x3d	; 61
    5300:	de b7       	in	r29, 0x3e	; 62
    5302:	a8 97       	sbiw	r28, 0x28	; 40
    5304:	0f b6       	in	r0, 0x3f	; 63
    5306:	f8 94       	cli
    5308:	de bf       	out	0x3e, r29	; 62
    530a:	0f be       	out	0x3f, r0	; 63
    530c:	cd bf       	out	0x3d, r28	; 61
    530e:	3c 01       	movw	r6, r24
    5310:	6b 01       	movw	r12, r22
    5312:	2a 01       	movw	r4, r20
	 
	 */
	 char i,lenB;
	 char prevSeg[20],currSeg[20];

     RemZeroLead(strA);
    5314:	0e 94 dd 23 	call	0x47ba	; 0x47ba <RemZeroLead>
     RemZeroLead(strB);
    5318:	c6 01       	movw	r24, r12
    531a:	0e 94 dd 23 	call	0x47ba	; 0x47ba <RemZeroLead>
	 lenB=strlen(strB);
    531e:	d6 01       	movw	r26, r12
    5320:	0d 90       	ld	r0, X+
    5322:	00 20       	and	r0, r0
    5324:	e9 f7       	brne	.-6      	; 0x5320 <CalcMultiply+0x42>
    5326:	11 97       	sbiw	r26, 0x01	; 1
    5328:	8a 2e       	mov	r8, r26
    532a:	8c 18       	sub	r8, r12
	 sprintf_P(prevSeg,PSTR("0"));
    532c:	00 d0       	rcall	.+0      	; 0x532e <CalcMultiply+0x50>
    532e:	00 d0       	rcall	.+0      	; 0x5330 <CalcMultiply+0x52>
    5330:	8e 01       	movw	r16, r28
    5332:	0f 5f       	subi	r16, 0xFF	; 255
    5334:	1f 4f       	sbci	r17, 0xFF	; 255
    5336:	ad b7       	in	r26, 0x3d	; 61
    5338:	be b7       	in	r27, 0x3e	; 62
    533a:	12 96       	adiw	r26, 0x02	; 2
    533c:	1c 93       	st	X, r17
    533e:	0e 93       	st	-X, r16
    5340:	11 97       	sbiw	r26, 0x01	; 1
    5342:	83 ea       	ldi	r24, 0xA3	; 163
    5344:	95 e0       	ldi	r25, 0x05	; 5
    5346:	14 96       	adiw	r26, 0x04	; 4
    5348:	9c 93       	st	X, r25
    534a:	8e 93       	st	-X, r24
    534c:	13 97       	sbiw	r26, 0x03	; 3
    534e:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
	 sprintf_P(currSeg,PSTR("0"));
    5352:	b5 e1       	ldi	r27, 0x15	; 21
    5354:	eb 2e       	mov	r14, r27
    5356:	f1 2c       	mov	r15, r1
    5358:	ec 0e       	add	r14, r28
    535a:	fd 1e       	adc	r15, r29
    535c:	ed b7       	in	r30, 0x3d	; 61
    535e:	fe b7       	in	r31, 0x3e	; 62
    5360:	f2 82       	std	Z+2, r15	; 0x02
    5362:	e1 82       	std	Z+1, r14	; 0x01
    5364:	81 ea       	ldi	r24, 0xA1	; 161
    5366:	95 e0       	ldi	r25, 0x05	; 5
    5368:	94 83       	std	Z+4, r25	; 0x04
    536a:	83 83       	std	Z+3, r24	; 0x03
    536c:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    5370:	bb 24       	eor	r11, r11
    5372:	0f 90       	pop	r0
    5374:	0f 90       	pop	r0
    5376:	0f 90       	pop	r0
    5378:	0f 90       	pop	r0
    537a:	a0 2e       	mov	r10, r16
    537c:	91 2e       	mov	r9, r17

	 for(i=0;i<strlen(strB);i++){
	     //
         CalcSegmen(strA,strB[lenB-1-i],currSeg);
    537e:	08 2d       	mov	r16, r8
    5380:	10 e0       	ldi	r17, 0x00	; 0
    5382:	01 50       	subi	r16, 0x01	; 1
    5384:	10 40       	sbci	r17, 0x00	; 0
    5386:	1f c0       	rjmp	.+62     	; 0x53c6 <CalcMultiply+0xe8>
    5388:	f8 01       	movw	r30, r16
    538a:	e8 1b       	sub	r30, r24
    538c:	f9 0b       	sbc	r31, r25
    538e:	ec 0d       	add	r30, r12
    5390:	fd 1d       	adc	r31, r13
    5392:	c3 01       	movw	r24, r6
    5394:	60 81       	ld	r22, Z
    5396:	a7 01       	movw	r20, r14
    5398:	0e 94 62 21 	call	0x42c4	; 0x42c4 <CalcSegmen>
         AddZeroLag(currSeg,strlen(currSeg)+i);
    539c:	f7 01       	movw	r30, r14
    539e:	01 90       	ld	r0, Z+
    53a0:	00 20       	and	r0, r0
    53a2:	e9 f7       	brne	.-6      	; 0x539e <CalcMultiply+0xc0>
    53a4:	31 97       	sbiw	r30, 0x01	; 1
    53a6:	ee 19       	sub	r30, r14
    53a8:	ff 09       	sbc	r31, r15
    53aa:	6b 2d       	mov	r22, r11
    53ac:	6e 0f       	add	r22, r30
    53ae:	c7 01       	movw	r24, r14
    53b0:	0e 94 70 26 	call	0x4ce0	; 0x4ce0 <AddZeroLag>
	     StrCalc(TPLUS,prevSeg,currSeg,prevSeg);
    53b4:	81 e0       	ldi	r24, 0x01	; 1
    53b6:	6a 2d       	mov	r22, r10
    53b8:	79 2d       	mov	r23, r9
    53ba:	a7 01       	movw	r20, r14
    53bc:	2a 2d       	mov	r18, r10
    53be:	39 2d       	mov	r19, r9
    53c0:	0e 94 8b 26 	call	0x4d16	; 0x4d16 <StrCalc>
     RemZeroLead(strB);
	 lenB=strlen(strB);
	 sprintf_P(prevSeg,PSTR("0"));
	 sprintf_P(currSeg,PSTR("0"));

	 for(i=0;i<strlen(strB);i++){
    53c4:	b3 94       	inc	r11
    53c6:	f6 01       	movw	r30, r12
    53c8:	01 90       	ld	r0, Z+
    53ca:	00 20       	and	r0, r0
    53cc:	e9 f7       	brne	.-6      	; 0x53c8 <CalcMultiply+0xea>
    53ce:	31 97       	sbiw	r30, 0x01	; 1
    53d0:	ec 19       	sub	r30, r12
    53d2:	fd 09       	sbc	r31, r13
    53d4:	8b 2d       	mov	r24, r11
    53d6:	90 e0       	ldi	r25, 0x00	; 0
    53d8:	8e 17       	cp	r24, r30
    53da:	9f 07       	cpc	r25, r31
    53dc:	a8 f2       	brcs	.-86     	; 0x5388 <CalcMultiply+0xaa>
	     //
         CalcSegmen(strA,strB[lenB-1-i],currSeg);
         AddZeroLag(currSeg,strlen(currSeg)+i);
	     StrCalc(TPLUS,prevSeg,currSeg,prevSeg);
	 }
	 sprintf_P(strC,PSTR("%s"),prevSeg);
    53de:	00 d0       	rcall	.+0      	; 0x53e0 <CalcMultiply+0x102>
    53e0:	00 d0       	rcall	.+0      	; 0x53e2 <CalcMultiply+0x104>
    53e2:	00 d0       	rcall	.+0      	; 0x53e4 <CalcMultiply+0x106>
    53e4:	ed b7       	in	r30, 0x3d	; 61
    53e6:	fe b7       	in	r31, 0x3e	; 62
    53e8:	31 96       	adiw	r30, 0x01	; 1
    53ea:	ad b7       	in	r26, 0x3d	; 61
    53ec:	be b7       	in	r27, 0x3e	; 62
    53ee:	12 96       	adiw	r26, 0x02	; 2
    53f0:	5c 92       	st	X, r5
    53f2:	4e 92       	st	-X, r4
    53f4:	11 97       	sbiw	r26, 0x01	; 1
    53f6:	8e e9       	ldi	r24, 0x9E	; 158
    53f8:	95 e0       	ldi	r25, 0x05	; 5
    53fa:	93 83       	std	Z+3, r25	; 0x03
    53fc:	82 83       	std	Z+2, r24	; 0x02
    53fe:	a4 82       	std	Z+4, r10	; 0x04
    5400:	95 82       	std	Z+5, r9	; 0x05
    5402:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    5406:	ed b7       	in	r30, 0x3d	; 61
    5408:	fe b7       	in	r31, 0x3e	; 62
    540a:	36 96       	adiw	r30, 0x06	; 6
    540c:	0f b6       	in	r0, 0x3f	; 63
    540e:	f8 94       	cli
    5410:	fe bf       	out	0x3e, r31	; 62
    5412:	0f be       	out	0x3f, r0	; 63
    5414:	ed bf       	out	0x3d, r30	; 61
}
    5416:	a8 96       	adiw	r28, 0x28	; 40
    5418:	0f b6       	in	r0, 0x3f	; 63
    541a:	f8 94       	cli
    541c:	de bf       	out	0x3e, r29	; 62
    541e:	0f be       	out	0x3f, r0	; 63
    5420:	cd bf       	out	0x3d, r28	; 61
    5422:	cf 91       	pop	r28
    5424:	df 91       	pop	r29
    5426:	1f 91       	pop	r17
    5428:	0f 91       	pop	r16
    542a:	ff 90       	pop	r15
    542c:	ef 90       	pop	r14
    542e:	df 90       	pop	r13
    5430:	cf 90       	pop	r12
    5432:	bf 90       	pop	r11
    5434:	af 90       	pop	r10
    5436:	9f 90       	pop	r9
    5438:	8f 90       	pop	r8
    543a:	7f 90       	pop	r7
    543c:	6f 90       	pop	r6
    543e:	5f 90       	pop	r5
    5440:	4f 90       	pop	r4
    5442:	08 95       	ret

00005444 <NormalizeOverflow>:
		 Length=strlen(strNumber);
		 StrPosCopy(strNumber,strNumber,MinPos,(Length-MinPos));	      
	 }
}

void NormalizeOverflow(char *strOverflowed){
    5444:	cf 92       	push	r12
    5446:	df 92       	push	r13
    5448:	ef 92       	push	r14
    544a:	ff 92       	push	r15
    544c:	0f 93       	push	r16
    544e:	1f 93       	push	r17
    5450:	df 93       	push	r29
    5452:	cf 93       	push	r28
    5454:	cd b7       	in	r28, 0x3d	; 61
    5456:	de b7       	in	r29, 0x3e	; 62
    5458:	64 97       	sbiw	r28, 0x14	; 20
    545a:	0f b6       	in	r0, 0x3f	; 63
    545c:	f8 94       	cli
    545e:	de bf       	out	0x3e, r29	; 62
    5460:	0f be       	out	0x3f, r0	; 63
    5462:	cd bf       	out	0x3d, r28	; 61
    5464:	d8 2e       	mov	r13, r24
    5466:	c9 2e       	mov	r12, r25
char i,Length,strMaxValue[20];//-99999999

     Length=strlen(strOverflowed);//-999453
    5468:	a8 2f       	mov	r26, r24
    546a:	b9 2f       	mov	r27, r25
    546c:	fd 01       	movw	r30, r26
    546e:	01 90       	ld	r0, Z+
    5470:	00 20       	and	r0, r0
    5472:	e9 f7       	brne	.-6      	; 0x546e <NormalizeOverflow+0x2a>
    5474:	31 97       	sbiw	r30, 0x01	; 1
    5476:	4e 2f       	mov	r20, r30
    5478:	48 1b       	sub	r20, r24
    547a:	20 e0       	ldi	r18, 0x00	; 0
    547c:	30 e0       	ldi	r19, 0x00	; 0
    547e:	7e 01       	movw	r14, r28
    5480:	08 94       	sec
    5482:	e1 1c       	adc	r14, r1
    5484:	f1 1c       	adc	r15, r1
    5486:	04 2f       	mov	r16, r20
    5488:	10 e0       	ldi	r17, 0x00	; 0
    548a:	0e c0       	rjmp	.+28     	; 0x54a8 <NormalizeOverflow+0x64>
     for(i=0;i<Length;i++){//123456
	     strMaxValue[i]='0'+((Length-i)/Length);
    548c:	f7 01       	movw	r30, r14
    548e:	e2 0f       	add	r30, r18
    5490:	f3 1f       	adc	r31, r19
    5492:	c8 01       	movw	r24, r16
    5494:	82 1b       	sub	r24, r18
    5496:	93 0b       	sbc	r25, r19
    5498:	64 2f       	mov	r22, r20
    549a:	70 e0       	ldi	r23, 0x00	; 0
    549c:	0e 94 4c b7 	call	0x16e98	; 0x16e98 <__divmodhi4>
    54a0:	60 5d       	subi	r22, 0xD0	; 208
    54a2:	60 83       	st	Z, r22
    54a4:	2f 5f       	subi	r18, 0xFF	; 255
    54a6:	3f 4f       	sbci	r19, 0xFF	; 255

void NormalizeOverflow(char *strOverflowed){
char i,Length,strMaxValue[20];//-99999999

     Length=strlen(strOverflowed);//-999453
     for(i=0;i<Length;i++){//123456
    54a8:	24 17       	cp	r18, r20
    54aa:	80 f3       	brcs	.-32     	; 0x548c <NormalizeOverflow+0x48>
	     strMaxValue[i]='0'+((Length-i)/Length);
	 }strMaxValue[Length]=0;
    54ac:	0e 0d       	add	r16, r14
    54ae:	1f 1d       	adc	r17, r15
    54b0:	f8 01       	movw	r30, r16
    54b2:	10 82       	st	Z, r1
     
	 //if (NinePos<Length-4)
	 StrCalc(TPLUS,strMaxValue,strOverflowed,strOverflowed);
    54b4:	81 e0       	ldi	r24, 0x01	; 1
    54b6:	b7 01       	movw	r22, r14
    54b8:	4d 2d       	mov	r20, r13
    54ba:	5c 2d       	mov	r21, r12
    54bc:	2d 2d       	mov	r18, r13
    54be:	3c 2d       	mov	r19, r12
    54c0:	0e 94 8b 26 	call	0x4d16	; 0x4d16 <StrCalc>
}
    54c4:	64 96       	adiw	r28, 0x14	; 20
    54c6:	0f b6       	in	r0, 0x3f	; 63
    54c8:	f8 94       	cli
    54ca:	de bf       	out	0x3e, r29	; 62
    54cc:	0f be       	out	0x3f, r0	; 63
    54ce:	cd bf       	out	0x3d, r28	; 61
    54d0:	cf 91       	pop	r28
    54d2:	df 91       	pop	r29
    54d4:	1f 91       	pop	r17
    54d6:	0f 91       	pop	r16
    54d8:	ff 90       	pop	r15
    54da:	ef 90       	pop	r14
    54dc:	df 90       	pop	r13
    54de:	cf 90       	pop	r12
    54e0:	08 95       	ret

000054e2 <AddSpaceLead>:
	    String[i]=' ';
	 }String[Size]=0;
  }
}

void AddSpaceLead(char *String,unsigned char Size){//
    54e2:	bf 92       	push	r11
    54e4:	cf 92       	push	r12
    54e6:	df 92       	push	r13
    54e8:	ef 92       	push	r14
    54ea:	ff 92       	push	r15
    54ec:	0f 93       	push	r16
    54ee:	1f 93       	push	r17
    54f0:	df 93       	push	r29
    54f2:	cf 93       	push	r28
    54f4:	cd b7       	in	r28, 0x3d	; 61
    54f6:	de b7       	in	r29, 0x3e	; 62
    54f8:	e2 97       	sbiw	r28, 0x32	; 50
    54fa:	0f b6       	in	r0, 0x3f	; 63
    54fc:	f8 94       	cli
    54fe:	de bf       	out	0x3e, r29	; 62
    5500:	0f be       	out	0x3f, r0	; 63
    5502:	cd bf       	out	0x3d, r28	; 61
    5504:	8c 01       	movw	r16, r24
     char i,Length,strAdded[50];
     Length=strlen(String);
    5506:	fc 01       	movw	r30, r24
    5508:	01 90       	ld	r0, Z+
    550a:	00 20       	and	r0, r0
    550c:	e9 f7       	brne	.-6      	; 0x5508 <AddSpaceLead+0x26>
    550e:	31 97       	sbiw	r30, 0x01	; 1
    5510:	2e 2f       	mov	r18, r30
    5512:	28 1b       	sub	r18, r24

	 if (Size>Length){
    5514:	26 17       	cp	r18, r22
    5516:	e0 f5       	brcc	.+120    	; 0x5590 <AddSpaceLead+0xae>
    5518:	7e 01       	movw	r14, r28
    551a:	08 94       	sec
    551c:	e1 1c       	adc	r14, r1
    551e:	f1 1c       	adc	r15, r1
    5520:	f7 01       	movw	r30, r14
	    String[i]=' ';
	 }String[Size]=0;
  }
}

void AddSpaceLead(char *String,unsigned char Size){//
    5522:	be 2c       	mov	r11, r14
     char i,Length,strAdded[50];
     Length=strlen(String);

	 if (Size>Length){
         for(i=0;i<Size;i++){
	         strAdded[i]=' ';
    5524:	90 e2       	ldi	r25, 0x20	; 32
    5526:	01 c0       	rjmp	.+2      	; 0x552a <AddSpaceLead+0x48>
    5528:	91 93       	st	Z+, r25
void AddSpaceLead(char *String,unsigned char Size){//
     char i,Length,strAdded[50];
     Length=strlen(String);

	 if (Size>Length){
         for(i=0;i<Size;i++){
    552a:	8e 2f       	mov	r24, r30
    552c:	8b 19       	sub	r24, r11
    552e:	86 17       	cp	r24, r22
    5530:	d8 f3       	brcs	.-10     	; 0x5528 <AddSpaceLead+0x46>
	         strAdded[i]=' ';
	     }strAdded[Size]=0;
    5532:	46 2f       	mov	r20, r22
    5534:	50 e0       	ldi	r21, 0x00	; 0
    5536:	ce 01       	movw	r24, r28
    5538:	01 96       	adiw	r24, 0x01	; 1
    553a:	fc 01       	movw	r30, r24
    553c:	e4 0f       	add	r30, r20
    553e:	f5 1f       	adc	r31, r21
    5540:	10 82       	st	Z, r1
	     //Copy
         for(i=(Size-Length);i<Size;i++){
    5542:	76 2f       	mov	r23, r22
    5544:	72 1b       	sub	r23, r18
    5546:	6c 01       	movw	r12, r24
	         strAdded[i]=String[i-(Size-Length)];
    5548:	30 e0       	ldi	r19, 0x00	; 0
    554a:	24 1b       	sub	r18, r20
    554c:	35 0b       	sbc	r19, r21
    554e:	0c c0       	rjmp	.+24     	; 0x5568 <AddSpaceLead+0x86>
    5550:	e7 2f       	mov	r30, r23
    5552:	f0 e0       	ldi	r31, 0x00	; 0
    5554:	d6 01       	movw	r26, r12
    5556:	ae 0f       	add	r26, r30
    5558:	bf 1f       	adc	r27, r31
    555a:	e0 0f       	add	r30, r16
    555c:	f1 1f       	adc	r31, r17
    555e:	e2 0f       	add	r30, r18
    5560:	f3 1f       	adc	r31, r19
    5562:	80 81       	ld	r24, Z
    5564:	8c 93       	st	X, r24
	 if (Size>Length){
         for(i=0;i<Size;i++){
	         strAdded[i]=' ';
	     }strAdded[Size]=0;
	     //Copy
         for(i=(Size-Length);i<Size;i++){
    5566:	7f 5f       	subi	r23, 0xFF	; 255
    5568:	76 17       	cp	r23, r22
    556a:	90 f3       	brcs	.-28     	; 0x5550 <AddSpaceLead+0x6e>
	         strAdded[i]=String[i-(Size-Length)];
	     }strAdded[Size]=0;
    556c:	4c 0d       	add	r20, r12
    556e:	5d 1d       	adc	r21, r13
    5570:	da 01       	movw	r26, r20
    5572:	1c 92       	st	X, r1
    5574:	f8 01       	movw	r30, r16
    5576:	04 c0       	rjmp	.+8      	; 0x5580 <AddSpaceLead+0x9e>
	     //Spaced
         for(i=0;i<Size;i++){
	         String[i]=strAdded[i];
    5578:	d7 01       	movw	r26, r14
    557a:	8d 91       	ld	r24, X+
    557c:	7d 01       	movw	r14, r26
    557e:	81 93       	st	Z+, r24
	     //Copy
         for(i=(Size-Length);i<Size;i++){
	         strAdded[i]=String[i-(Size-Length)];
	     }strAdded[Size]=0;
	     //Spaced
         for(i=0;i<Size;i++){
    5580:	8e 2d       	mov	r24, r14
    5582:	8b 19       	sub	r24, r11
    5584:	86 17       	cp	r24, r22
    5586:	c0 f3       	brcs	.-16     	; 0x5578 <AddSpaceLead+0x96>
	         String[i]=strAdded[i];
	     }String[Size]=0;
    5588:	06 0f       	add	r16, r22
    558a:	11 1d       	adc	r17, r1
    558c:	f8 01       	movw	r30, r16
    558e:	10 82       	st	Z, r1
	 }
}
    5590:	e2 96       	adiw	r28, 0x32	; 50
    5592:	0f b6       	in	r0, 0x3f	; 63
    5594:	f8 94       	cli
    5596:	de bf       	out	0x3e, r29	; 62
    5598:	0f be       	out	0x3f, r0	; 63
    559a:	cd bf       	out	0x3d, r28	; 61
    559c:	cf 91       	pop	r28
    559e:	df 91       	pop	r29
    55a0:	1f 91       	pop	r17
    55a2:	0f 91       	pop	r16
    55a4:	ff 90       	pop	r15
    55a6:	ef 90       	pop	r14
    55a8:	df 90       	pop	r13
    55aa:	cf 90       	pop	r12
    55ac:	bf 90       	pop	r11
    55ae:	08 95       	ret

000055b0 <AddSpaceLag>:
	 }
}



void AddSpaceLag(char *String,unsigned char Size){// [CREDITCARD             ]
    55b0:	cf 93       	push	r28
    55b2:	df 93       	push	r29
    55b4:	ec 01       	movw	r28, r24
char i,Length;
     Length=strlen(String);
    55b6:	dc 01       	movw	r26, r24
    55b8:	0d 90       	ld	r0, X+
    55ba:	00 20       	and	r0, r0
    55bc:	e9 f7       	brne	.-6      	; 0x55b8 <AddSpaceLag+0x8>
    55be:	11 97       	sbiw	r26, 0x01	; 1
    55c0:	a8 1b       	sub	r26, r24
    55c2:	b9 0b       	sbc	r27, r25
  if (Length<Size){   
    55c4:	a6 17       	cp	r26, r22
    55c6:	60 f4       	brcc	.+24     	; 0x55e0 <AddSpaceLag+0x30>
    55c8:	8a 2f       	mov	r24, r26
     for(i=Length;i<Size;i++){
	    String[i]=' ';
    55ca:	90 e2       	ldi	r25, 0x20	; 32
    55cc:	fe 01       	movw	r30, r28
    55ce:	e8 0f       	add	r30, r24
    55d0:	f1 1d       	adc	r31, r1
    55d2:	90 83       	st	Z, r25

void AddSpaceLag(char *String,unsigned char Size){// [CREDITCARD             ]
char i,Length;
     Length=strlen(String);
  if (Length<Size){   
     for(i=Length;i<Size;i++){
    55d4:	8f 5f       	subi	r24, 0xFF	; 255
    55d6:	86 17       	cp	r24, r22
    55d8:	c8 f3       	brcs	.-14     	; 0x55cc <AddSpaceLag+0x1c>
	    String[i]=' ';
	 }String[Size]=0;
    55da:	c6 0f       	add	r28, r22
    55dc:	d1 1d       	adc	r29, r1
    55de:	18 82       	st	Y, r1
  }
}
    55e0:	df 91       	pop	r29
    55e2:	cf 91       	pop	r28
    55e4:	08 95       	ret

000055e6 <GetProductName>:
	 }    
	 //Clear Decimal

}

void GetProductName(char GradeId,char *strProductName){
    55e6:	0f 93       	push	r16
    55e8:	1f 93       	push	r17
    55ea:	df 93       	push	r29
    55ec:	cf 93       	push	r28
    55ee:	cd b7       	in	r28, 0x3d	; 61
    55f0:	de b7       	in	r29, 0x3e	; 62
    55f2:	2c 97       	sbiw	r28, 0x0c	; 12
    55f4:	0f b6       	in	r0, 0x3f	; 63
    55f6:	f8 94       	cli
    55f8:	de bf       	out	0x3e, r29	; 62
    55fa:	0f be       	out	0x3f, r0	; 63
    55fc:	cd bf       	out	0x3d, r28	; 61
    55fe:	48 2f       	mov	r20, r24
    5600:	8b 01       	movw	r16, r22
    5602:	fe 01       	movw	r30, r28
    5604:	31 96       	adiw	r30, 0x01	; 1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    5606:	9e 01       	movw	r18, r28
    5608:	23 5f       	subi	r18, 0xF3	; 243
    560a:	3f 4f       	sbci	r19, 0xFF	; 255
	     strMemory[i]=data;
    560c:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    560e:	e2 17       	cp	r30, r18
    5610:	f3 07       	cpc	r31, r19
    5612:	e1 f7       	brne	.-8      	; 0x560c <GetProductName+0x26>
    5614:	ce 01       	movw	r24, r28
    5616:	01 96       	adiw	r24, 0x01	; 1

void GetProductName(char GradeId,char *strProductName){
char SProductName[12],i,Length;
     FillChar(SProductName,sizeof(SProductName),0); 
	 //eeprom_read_block((void*) &SProductName, (const void*) &DefProductName[GradeId-1],10);
	 if (GradeId>0) eeprom_read_block((void*) &SProductName, (const void*) &DefProductName[GradeId-1],10);
    5618:	44 23       	and	r20, r20
    561a:	69 f0       	breq	.+26     	; 0x5636 <GetProductName+0x50>
    561c:	6d e0       	ldi	r22, 0x0D	; 13
    561e:	46 9f       	mul	r20, r22
    5620:	b0 01       	movw	r22, r0
    5622:	11 24       	eor	r1, r1
    5624:	62 55       	subi	r22, 0x52	; 82
    5626:	7f 4f       	sbci	r23, 0xFF	; 255
    5628:	4a e0       	ldi	r20, 0x0A	; 10
    562a:	50 e0       	ldi	r21, 0x00	; 0
    562c:	23 ef       	ldi	r18, 0xF3	; 243
    562e:	32 e1       	ldi	r19, 0x12	; 18
    5630:	0e 94 1f b4 	call	0x1683e	; 0x1683e <__eerd_block>
    5634:	14 c0       	rjmp	.+40     	; 0x565e <GetProductName+0x78>
	 else sprintf_P(SProductName,PSTR("N/A"));
    5636:	00 d0       	rcall	.+0      	; 0x5638 <GetProductName+0x52>
    5638:	00 d0       	rcall	.+0      	; 0x563a <GetProductName+0x54>
    563a:	ad b7       	in	r26, 0x3d	; 61
    563c:	be b7       	in	r27, 0x3e	; 62
    563e:	12 96       	adiw	r26, 0x02	; 2
    5640:	9c 93       	st	X, r25
    5642:	8e 93       	st	-X, r24
    5644:	11 97       	sbiw	r26, 0x01	; 1
    5646:	85 ef       	ldi	r24, 0xF5	; 245
    5648:	93 e0       	ldi	r25, 0x03	; 3
    564a:	14 96       	adiw	r26, 0x04	; 4
    564c:	9c 93       	st	X, r25
    564e:	8e 93       	st	-X, r24
    5650:	13 97       	sbiw	r26, 0x03	; 3
    5652:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    5656:	0f 90       	pop	r0
    5658:	0f 90       	pop	r0
    565a:	0f 90       	pop	r0
    565c:	0f 90       	pop	r0

     Length=strlen(SProductName);
    565e:	de 01       	movw	r26, r28
    5660:	11 96       	adiw	r26, 0x01	; 1
    5662:	fd 01       	movw	r30, r26
    5664:	01 90       	ld	r0, Z+
    5666:	00 20       	and	r0, r0
    5668:	e9 f7       	brne	.-6      	; 0x5664 <GetProductName+0x7e>
    566a:	31 97       	sbiw	r30, 0x01	; 1
    566c:	ea 1b       	sub	r30, r26
    566e:	eb 30       	cpi	r30, 0x0B	; 11
    5670:	08 f0       	brcs	.+2      	; 0x5674 <GetProductName+0x8e>
    5672:	ea e0       	ldi	r30, 0x0A	; 10
    5674:	ae 01       	movw	r20, r28
    5676:	4f 5f       	subi	r20, 0xFF	; 255
    5678:	5f 4f       	sbci	r21, 0xFF	; 255
    567a:	98 01       	movw	r18, r16
    567c:	ba 01       	movw	r22, r20
    567e:	06 c0       	rjmp	.+12     	; 0x568c <GetProductName+0xa6>
	 if (Length>10)Length=10;

	 for(i=0;i<Length;i++){
	     strProductName[i]=SProductName[i];
    5680:	db 01       	movw	r26, r22
    5682:	8d 91       	ld	r24, X+
    5684:	bd 01       	movw	r22, r26
    5686:	d9 01       	movw	r26, r18
    5688:	8d 93       	st	X+, r24
    568a:	9d 01       	movw	r18, r26
	 else sprintf_P(SProductName,PSTR("N/A"));

     Length=strlen(SProductName);
	 if (Length>10)Length=10;

	 for(i=0;i<Length;i++){
    568c:	86 2f       	mov	r24, r22
    568e:	84 1b       	sub	r24, r20
    5690:	8e 17       	cp	r24, r30
    5692:	b0 f3       	brcs	.-20     	; 0x5680 <GetProductName+0x9a>
	     strProductName[i]=SProductName[i];
	 }strProductName[Length]=0;
    5694:	c8 01       	movw	r24, r16
    5696:	8e 0f       	add	r24, r30
    5698:	91 1d       	adc	r25, r1
    569a:	fc 01       	movw	r30, r24
    569c:	10 82       	st	Z, r1

	 AddSpaceLag(strProductName,10);
    569e:	c8 01       	movw	r24, r16
    56a0:	6a e0       	ldi	r22, 0x0A	; 10
    56a2:	0e 94 d8 2a 	call	0x55b0	; 0x55b0 <AddSpaceLag>
}
    56a6:	2c 96       	adiw	r28, 0x0c	; 12
    56a8:	0f b6       	in	r0, 0x3f	; 63
    56aa:	f8 94       	cli
    56ac:	de bf       	out	0x3e, r29	; 62
    56ae:	0f be       	out	0x3f, r0	; 63
    56b0:	cd bf       	out	0x3d, r28	; 61
    56b2:	cf 91       	pop	r28
    56b4:	df 91       	pop	r29
    56b6:	1f 91       	pop	r17
    56b8:	0f 91       	pop	r16
    56ba:	08 95       	ret

000056bc <GeniusSendLastTransaction>:
}
void GeniusSendPumpPreset(char iPumpID){
}


void GeniusSendLastTransaction(char iPumpID){
    56bc:	2f 92       	push	r2
    56be:	3f 92       	push	r3
    56c0:	4f 92       	push	r4
    56c2:	5f 92       	push	r5
    56c4:	6f 92       	push	r6
    56c6:	7f 92       	push	r7
    56c8:	8f 92       	push	r8
    56ca:	9f 92       	push	r9
    56cc:	af 92       	push	r10
    56ce:	bf 92       	push	r11
    56d0:	cf 92       	push	r12
    56d2:	df 92       	push	r13
    56d4:	ef 92       	push	r14
    56d6:	ff 92       	push	r15
    56d8:	0f 93       	push	r16
    56da:	1f 93       	push	r17
    56dc:	df 93       	push	r29
    56de:	cf 93       	push	r28
    56e0:	cd b7       	in	r28, 0x3d	; 61
    56e2:	de b7       	in	r29, 0x3e	; 62
    56e4:	c0 5b       	subi	r28, 0xB0	; 176
    56e6:	d0 40       	sbci	r29, 0x00	; 0
    56e8:	0f b6       	in	r0, 0x3f	; 63
    56ea:	f8 94       	cli
    56ec:	de bf       	out	0x3e, r29	; 62
    56ee:	0f be       	out	0x3f, r0	; 63
    56f0:	cd bf       	out	0x3d, r28	; 61
    56f2:	e8 2e       	mov	r14, r24
    56f4:	fe 01       	movw	r30, r28
    56f6:	37 96       	adiw	r30, 0x07	; 7

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    56f8:	ce 01       	movw	r24, r28
    56fa:	46 96       	adiw	r24, 0x16	; 22
	     strMemory[i]=data;
    56fc:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    56fe:	e8 17       	cp	r30, r24
    5700:	f9 07       	cpc	r31, r25
    5702:	e1 f7       	brne	.-8      	; 0x56fc <GeniusSendLastTransaction+0x40>
	     strMemory[i]=data;
    5704:	ce 01       	movw	r24, r28
    5706:	85 96       	adiw	r24, 0x25	; 37
    5708:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    570a:	e8 17       	cp	r30, r24
    570c:	f9 07       	cpc	r31, r25
    570e:	e1 f7       	brne	.-8      	; 0x5708 <GeniusSendLastTransaction+0x4c>
	     strMemory[i]=data;
    5710:	ce 01       	movw	r24, r28
    5712:	c4 96       	adiw	r24, 0x34	; 52
    5714:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    5716:	e8 17       	cp	r30, r24
    5718:	f9 07       	cpc	r31, r25
    571a:	e1 f7       	brne	.-8      	; 0x5714 <GeniusSendLastTransaction+0x58>
	     strMemory[i]=data;
    571c:	cf 01       	movw	r24, r30
    571e:	3f 01       	movw	r6, r30
    5720:	0f 96       	adiw	r24, 0x0f	; 15
    5722:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    5724:	e8 17       	cp	r30, r24
    5726:	f9 07       	cpc	r31, r25
    5728:	e1 f7       	brne	.-8      	; 0x5722 <GeniusSendLastTransaction+0x66>
	 FillChar(STotalVolume,sizeof(STotalVolume),0);
	 FillChar(STotalMoney,sizeof(STotalMoney),0);
	      

	 //Generate
	 FIPAddr=GetFIPAddr(iPumpID);
    572a:	8e 2d       	mov	r24, r14
    572c:	0e 94 39 1c 	call	0x3872	; 0x3872 <GetFIPAddr>
    5730:	96 e0       	ldi	r25, 0x06	; 6
    5732:	89 9f       	mul	r24, r25
    5734:	b0 01       	movw	r22, r0
    5736:	11 24       	eor	r1, r1
    5738:	61 5b       	subi	r22, 0xB1	; 177
    573a:	7f 4f       	sbci	r23, 0xFF	; 255
    573c:	8e 01       	movw	r16, r28
    573e:	0f 5f       	subi	r16, 0xFF	; 255
    5740:	1f 4f       	sbci	r17, 0xFF	; 255
    5742:	c8 01       	movw	r24, r16
    5744:	46 e0       	ldi	r20, 0x06	; 6
    5746:	50 e0       	ldi	r21, 0x00	; 0
    5748:	23 ef       	ldi	r18, 0xF3	; 243
    574a:	32 e1       	ldi	r19, 0x12	; 18
    574c:	0e 94 1f b4 	call	0x1683e	; 0x1683e <__eerd_block>
     eeprom_read_block((void*) &PProductID, (const void*) &DefNozzleMap[FIPAddr-1], 6);
	 iNozzle=RecPumpData[iPumpID&0x0F].Grade;
    5750:	2e 2c       	mov	r2, r14
    5752:	33 24       	eor	r3, r3
    5754:	91 01       	movw	r18, r2
    5756:	2f 70       	andi	r18, 0x0F	; 15
    5758:	30 70       	andi	r19, 0x00	; 0
    575a:	85 e3       	ldi	r24, 0x35	; 53
    575c:	90 e0       	ldi	r25, 0x00	; 0
    575e:	28 9f       	mul	r18, r24
    5760:	f0 01       	movw	r30, r0
    5762:	29 9f       	mul	r18, r25
    5764:	f0 0d       	add	r31, r0
    5766:	38 9f       	mul	r19, r24
    5768:	f0 0d       	add	r31, r0
    576a:	11 24       	eor	r1, r1
    576c:	e5 57       	subi	r30, 0x75	; 117
    576e:	f8 4f       	sbci	r31, 0xF8	; 248
    5770:	f0 80       	ld	r15, Z
	 iProdID=PProductID[iNozzle];
    5772:	4f 2c       	mov	r4, r15
    5774:	55 24       	eor	r5, r5

	 GetProductName(iProdID,strProduct);
    5776:	04 0d       	add	r16, r4
    5778:	15 1d       	adc	r17, r5
    577a:	d8 01       	movw	r26, r16
    577c:	8c 91       	ld	r24, X
    577e:	61 e4       	ldi	r22, 0x41	; 65
    5780:	79 e0       	ldi	r23, 0x09	; 9
    5782:	0e 94 f3 2a 	call	0x55e6	; 0x55e6 <GetProductName>
	 GetTransactionVolume(iPumpID,SVolume);
    5786:	97 e0       	ldi	r25, 0x07	; 7
    5788:	89 2e       	mov	r8, r25
    578a:	91 2c       	mov	r9, r1
    578c:	8c 0e       	add	r8, r28
    578e:	9d 1e       	adc	r9, r29
    5790:	8e 2d       	mov	r24, r14
    5792:	b4 01       	movw	r22, r8
    5794:	0e 94 36 26 	call	0x4c6c	; 0x4c6c <GetTransactionVolume>
	 GetTransactionMoney(iPumpID,SMoney);
    5798:	86 e1       	ldi	r24, 0x16	; 22
    579a:	a8 2e       	mov	r10, r24
    579c:	b1 2c       	mov	r11, r1
    579e:	ac 0e       	add	r10, r28
    57a0:	bd 1e       	adc	r11, r29
    57a2:	8e 2d       	mov	r24, r14
    57a4:	b5 01       	movw	r22, r10
    57a6:	0e 94 fc 25 	call	0x4bf8	; 0x4bf8 <GetTransactionMoney>
	 GetTotalizerVolume(iPumpID,iNozzle,STotalVolume);
    57aa:	05 e2       	ldi	r16, 0x25	; 37
    57ac:	c0 2e       	mov	r12, r16
    57ae:	d1 2c       	mov	r13, r1
    57b0:	cc 0e       	add	r12, r28
    57b2:	dd 1e       	adc	r13, r29
    57b4:	8e 2d       	mov	r24, r14
    57b6:	6f 2d       	mov	r22, r15
    57b8:	a6 01       	movw	r20, r12
    57ba:	0e 94 df 25 	call	0x4bbe	; 0x4bbe <GetTotalizerVolume>
	 GetTotalizerMoney(iPumpID,iNozzle,STotalMoney);
    57be:	8e 2d       	mov	r24, r14
    57c0:	6f 2d       	mov	r22, r15
    57c2:	a3 01       	movw	r20, r6
    57c4:	0e 94 c2 25 	call	0x4b84	; 0x4b84 <GetTotalizerMoney>
	 
     ComposeDatetime(SDatetime);
    57c8:	13 e4       	ldi	r17, 0x43	; 67
    57ca:	e1 2e       	mov	r14, r17
    57cc:	f1 2c       	mov	r15, r1
    57ce:	ec 0e       	add	r14, r28
    57d0:	fd 1e       	adc	r15, r29
    57d2:	c7 01       	movw	r24, r14
    57d4:	0e 94 51 1b 	call	0x36a2	; 0x36a2 <ComposeDatetime>

	 //Compose
	 sprintf_P(strSend,PSTR("T%.2d%.2d%s%s%s%s%s%s:"),iPumpID,iNozzle,strProduct,SDatetime,SVolume,SMoney,STotalVolume,STotalMoney);
    57d8:	ed b7       	in	r30, 0x3d	; 61
    57da:	fe b7       	in	r31, 0x3e	; 62
    57dc:	74 97       	sbiw	r30, 0x14	; 20
    57de:	0f b6       	in	r0, 0x3f	; 63
    57e0:	f8 94       	cli
    57e2:	fe bf       	out	0x3e, r31	; 62
    57e4:	0f be       	out	0x3f, r0	; 63
    57e6:	ed bf       	out	0x3d, r30	; 61
    57e8:	31 96       	adiw	r30, 0x01	; 1
    57ea:	8e 01       	movw	r16, r28
    57ec:	09 5a       	subi	r16, 0xA9	; 169
    57ee:	1f 4f       	sbci	r17, 0xFF	; 255
    57f0:	ad b7       	in	r26, 0x3d	; 61
    57f2:	be b7       	in	r27, 0x3e	; 62
    57f4:	12 96       	adiw	r26, 0x02	; 2
    57f6:	1c 93       	st	X, r17
    57f8:	0e 93       	st	-X, r16
    57fa:	11 97       	sbiw	r26, 0x01	; 1
    57fc:	88 e3       	ldi	r24, 0x38	; 56
    57fe:	93 e0       	ldi	r25, 0x03	; 3
    5800:	93 83       	std	Z+3, r25	; 0x03
    5802:	82 83       	std	Z+2, r24	; 0x02
    5804:	35 82       	std	Z+5, r3	; 0x05
    5806:	24 82       	std	Z+4, r2	; 0x04
    5808:	57 82       	std	Z+7, r5	; 0x07
    580a:	46 82       	std	Z+6, r4	; 0x06
    580c:	81 e4       	ldi	r24, 0x41	; 65
    580e:	99 e0       	ldi	r25, 0x09	; 9
    5810:	91 87       	std	Z+9, r25	; 0x09
    5812:	80 87       	std	Z+8, r24	; 0x08
    5814:	f3 86       	std	Z+11, r15	; 0x0b
    5816:	e2 86       	std	Z+10, r14	; 0x0a
    5818:	95 86       	std	Z+13, r9	; 0x0d
    581a:	84 86       	std	Z+12, r8	; 0x0c
    581c:	b7 86       	std	Z+15, r11	; 0x0f
    581e:	a6 86       	std	Z+14, r10	; 0x0e
    5820:	d1 8a       	std	Z+17, r13	; 0x11
    5822:	c0 8a       	std	Z+16, r12	; 0x10
    5824:	62 8a       	std	Z+18, r6	; 0x12
    5826:	73 8a       	std	Z+19, r7	; 0x13
    5828:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
	 cSum=SumChecksum(strSend);
    582c:	ad b7       	in	r26, 0x3d	; 61
    582e:	be b7       	in	r27, 0x3e	; 62
    5830:	54 96       	adiw	r26, 0x14	; 20
    5832:	0f b6       	in	r0, 0x3f	; 63
    5834:	f8 94       	cli
    5836:	be bf       	out	0x3e, r27	; 62
    5838:	0f be       	out	0x3f, r0	; 63
    583a:	ad bf       	out	0x3d, r26	; 61
    583c:	c8 01       	movw	r24, r16
    583e:	0e 94 11 20 	call	0x4022	; 0x4022 <SumChecksum>
    5842:	e8 2e       	mov	r14, r24
	 _uart_print(1,0,strSend);
    5844:	81 e0       	ldi	r24, 0x01	; 1
    5846:	60 e0       	ldi	r22, 0x00	; 0
    5848:	a8 01       	movw	r20, r16
    584a:	0e 94 97 b2 	call	0x1652e	; 0x1652e <_uart_print>
    584e:	f8 01       	movw	r30, r16

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    5850:	c8 01       	movw	r24, r16
    5852:	f9 2e       	mov	r15, r25
    5854:	ce 01       	movw	r24, r28
    5856:	8f 54       	subi	r24, 0x4F	; 79
    5858:	9f 4f       	sbci	r25, 0xFF	; 255
	     strMemory[i]=data;
    585a:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    585c:	e8 17       	cp	r30, r24
    585e:	f9 07       	cpc	r31, r25
    5860:	e1 f7       	brne	.-8      	; 0x585a <GeniusSendLastTransaction+0x19e>
	 //Compose
	 sprintf_P(strSend,PSTR("T%.2d%.2d%s%s%s%s%s%s:"),iPumpID,iNozzle,strProduct,SDatetime,SVolume,SMoney,STotalVolume,STotalMoney);
	 cSum=SumChecksum(strSend);
	 _uart_print(1,0,strSend);
	 FillChar(strSend,sizeof(strSend),0);      
	 sprintf_P(strSend,PSTR("%d"),cSum);
    5862:	00 d0       	rcall	.+0      	; 0x5864 <GeniusSendLastTransaction+0x1a8>
    5864:	00 d0       	rcall	.+0      	; 0x5866 <GeniusSendLastTransaction+0x1aa>
    5866:	00 d0       	rcall	.+0      	; 0x5868 <GeniusSendLastTransaction+0x1ac>
    5868:	ed b7       	in	r30, 0x3d	; 61
    586a:	fe b7       	in	r31, 0x3e	; 62
    586c:	31 96       	adiw	r30, 0x01	; 1
    586e:	ad b7       	in	r26, 0x3d	; 61
    5870:	be b7       	in	r27, 0x3e	; 62
    5872:	11 96       	adiw	r26, 0x01	; 1
    5874:	0c 93       	st	X, r16
    5876:	11 97       	sbiw	r26, 0x01	; 1
    5878:	12 96       	adiw	r26, 0x02	; 2
    587a:	fc 92       	st	X, r15
    587c:	85 e3       	ldi	r24, 0x35	; 53
    587e:	93 e0       	ldi	r25, 0x03	; 3
    5880:	93 83       	std	Z+3, r25	; 0x03
    5882:	82 83       	std	Z+2, r24	; 0x02
    5884:	e4 82       	std	Z+4, r14	; 0x04
    5886:	15 82       	std	Z+5, r1	; 0x05
    5888:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
	 _uart_print(1,1,strSend);	 
    588c:	ed b7       	in	r30, 0x3d	; 61
    588e:	fe b7       	in	r31, 0x3e	; 62
    5890:	36 96       	adiw	r30, 0x06	; 6
    5892:	0f b6       	in	r0, 0x3f	; 63
    5894:	f8 94       	cli
    5896:	fe bf       	out	0x3e, r31	; 62
    5898:	0f be       	out	0x3f, r0	; 63
    589a:	ed bf       	out	0x3d, r30	; 61
    589c:	81 e0       	ldi	r24, 0x01	; 1
    589e:	61 e0       	ldi	r22, 0x01	; 1
    58a0:	40 2f       	mov	r20, r16
    58a2:	5f 2d       	mov	r21, r15
    58a4:	0e 94 97 b2 	call	0x1652e	; 0x1652e <_uart_print>
}
    58a8:	c0 55       	subi	r28, 0x50	; 80
    58aa:	df 4f       	sbci	r29, 0xFF	; 255
    58ac:	0f b6       	in	r0, 0x3f	; 63
    58ae:	f8 94       	cli
    58b0:	de bf       	out	0x3e, r29	; 62
    58b2:	0f be       	out	0x3f, r0	; 63
    58b4:	cd bf       	out	0x3d, r28	; 61
    58b6:	cf 91       	pop	r28
    58b8:	df 91       	pop	r29
    58ba:	1f 91       	pop	r17
    58bc:	0f 91       	pop	r16
    58be:	ff 90       	pop	r15
    58c0:	ef 90       	pop	r14
    58c2:	df 90       	pop	r13
    58c4:	cf 90       	pop	r12
    58c6:	bf 90       	pop	r11
    58c8:	af 90       	pop	r10
    58ca:	9f 90       	pop	r9
    58cc:	8f 90       	pop	r8
    58ce:	7f 90       	pop	r7
    58d0:	6f 90       	pop	r6
    58d2:	5f 90       	pop	r5
    58d4:	4f 90       	pop	r4
    58d6:	3f 90       	pop	r3
    58d8:	2f 90       	pop	r2
    58da:	08 95       	ret

000058dc <systemGeniusProtocol>:

void systemGeniusProtocol(){
static char stGeniusProtocol=gpInitScan;
static char iPumpID;
	 
	 switch(stGeniusProtocol){
    58dc:	80 91 dc 01 	lds	r24, 0x01DC
    58e0:	83 30       	cpi	r24, 0x03	; 3
    58e2:	71 f1       	breq	.+92     	; 0x5940 <systemGeniusProtocol+0x64>
    58e4:	84 30       	cpi	r24, 0x04	; 4
    58e6:	28 f4       	brcc	.+10     	; 0x58f2 <systemGeniusProtocol+0x16>
    58e8:	81 30       	cpi	r24, 0x01	; 1
    58ea:	81 f0       	breq	.+32     	; 0x590c <systemGeniusProtocol+0x30>
    58ec:	82 30       	cpi	r24, 0x02	; 2
    58ee:	c0 f4       	brcc	.+48     	; 0x5920 <systemGeniusProtocol+0x44>
    58f0:	09 c0       	rjmp	.+18     	; 0x5904 <systemGeniusProtocol+0x28>
    58f2:	85 30       	cpi	r24, 0x05	; 5
    58f4:	09 f4       	brne	.+2      	; 0x58f8 <systemGeniusProtocol+0x1c>
    58f6:	49 c0       	rjmp	.+146    	; 0x598a <systemGeniusProtocol+0xae>
    58f8:	85 30       	cpi	r24, 0x05	; 5
    58fa:	c0 f1       	brcs	.+112    	; 0x596c <systemGeniusProtocol+0x90>
    58fc:	86 30       	cpi	r24, 0x06	; 6
    58fe:	09 f0       	breq	.+2      	; 0x5902 <systemGeniusProtocol+0x26>
    5900:	60 c0       	rjmp	.+192    	; 0x59c2 <systemGeniusProtocol+0xe6>
    5902:	4d c0       	rjmp	.+154    	; 0x599e <systemGeniusProtocol+0xc2>
	 case gpInitScan:
	      iPumpID=1;
    5904:	81 e0       	ldi	r24, 0x01	; 1
    5906:	80 93 db 01 	sts	0x01DB, r24
    590a:	46 c0       	rjmp	.+140    	; 0x5998 <systemGeniusProtocol+0xbc>
          stGeniusProtocol=gpScanNewTransaction;
	      break;
	 case gpScanNewTransaction:
	      if (GetIncomingTransStatus(PumpID)==TS_NEW){
    590c:	80 91 da 01 	lds	r24, 0x01DA
    5910:	0e 94 e0 1a 	call	0x35c0	; 0x35c0 <GetIncomingTransStatus>
    5914:	82 30       	cpi	r24, 0x02	; 2
    5916:	09 f0       	breq	.+2      	; 0x591a <systemGeniusProtocol+0x3e>
    5918:	54 c0       	rjmp	.+168    	; 0x59c2 <systemGeniusProtocol+0xe6>
		      IsTotalizerReceived=False;
    591a:	10 92 c5 01 	sts	0x01C5, r1
    591e:	3c c0       	rjmp	.+120    	; 0x5998 <systemGeniusProtocol+0xbc>
		      stGeniusProtocol=gpRequestTotalizer;
		  }
	      break;
     case gpRequestTotalizer:
	      SendPoolingCommand(SC_TOTALIZER,iPumpID);
    5920:	90 91 db 01 	lds	r25, 0x01DB
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    5924:	85 e0       	ldi	r24, 0x05	; 5
    5926:	80 93 8a 07 	sts	0x078A, r24
	 PoolMsg=plMsg;
    592a:	90 93 ae 0d 	sts	0x0DAE, r25
     IsControlPooling=True;
    592e:	81 e0       	ldi	r24, 0x01	; 1
    5930:	80 93 97 01 	sts	0x0197, r24
		      stGeniusProtocol=gpRequestTotalizer;
		  }
	      break;
     case gpRequestTotalizer:
	      SendPoolingCommand(SC_TOTALIZER,iPumpID);
		  TimSend=0;
    5934:	10 92 a9 01 	sts	0x01A9, r1
    5938:	10 92 a8 01 	sts	0x01A8, r1
		  stGeniusProtocol=gpWaitRequestedTotalizer;
    593c:	83 e0       	ldi	r24, 0x03	; 3
    593e:	2c c0       	rjmp	.+88     	; 0x5998 <systemGeniusProtocol+0xbc>
	      break;
     case gpWaitRequestedTotalizer:
	      if ((IsTotalizerReceived==True)&&(AcknoledgePump==iPumpID)){
    5940:	80 91 c5 01 	lds	r24, 0x01C5
    5944:	81 30       	cpi	r24, 0x01	; 1
    5946:	59 f4       	brne	.+22     	; 0x595e <systemGeniusProtocol+0x82>
    5948:	90 91 c7 0d 	lds	r25, 0x0DC7
    594c:	80 91 db 01 	lds	r24, 0x01DB
    5950:	98 17       	cp	r25, r24
    5952:	29 f4       	brne	.+10     	; 0x595e <systemGeniusProtocol+0x82>
		      IsTotalizerReceived=False;
    5954:	10 92 c5 01 	sts	0x01C5, r1
			  stGeniusProtocol=gpSendTransactionData;
    5958:	84 e0       	ldi	r24, 0x04	; 4
    595a:	80 93 dc 01 	sts	0x01DC, r24
		  }
	      if (TimSend>TIM_SEND*2)stGeniusProtocol=gpNextPumpScan;
    595e:	80 91 a8 01 	lds	r24, 0x01A8
    5962:	90 91 a9 01 	lds	r25, 0x01A9
    5966:	45 97       	sbiw	r24, 0x15	; 21
    5968:	60 f1       	brcs	.+88     	; 0x59c2 <systemGeniusProtocol+0xe6>
    596a:	15 c0       	rjmp	.+42     	; 0x5996 <systemGeniusProtocol+0xba>
	      break;
     case gpSendTransactionData:
          GeniusSendLastTransaction(iPumpID);
    596c:	80 91 db 01 	lds	r24, 0x01DB
    5970:	0e 94 5e 2b 	call	0x56bc	; 0x56bc <GeniusSendLastTransaction>
		  SetIncomingTransStatus(iPumpID,TS_OLD);
    5974:	80 91 db 01 	lds	r24, 0x01DB
    5978:	63 e0       	ldi	r22, 0x03	; 3
    597a:	0e 94 ae 1a 	call	0x355c	; 0x355c <SetIncomingTransStatus>
		  
		  TimSend=0;
    597e:	10 92 a9 01 	sts	0x01A9, r1
    5982:	10 92 a8 01 	sts	0x01A8, r1
          stGeniusProtocol=gpDelayNextPumpScan;
    5986:	85 e0       	ldi	r24, 0x05	; 5
    5988:	07 c0       	rjmp	.+14     	; 0x5998 <systemGeniusProtocol+0xbc>
	      break;
     case gpDelayNextPumpScan:
          if (TimSend>1)stGeniusProtocol=gpNextPumpScan;
    598a:	80 91 a8 01 	lds	r24, 0x01A8
    598e:	90 91 a9 01 	lds	r25, 0x01A9
    5992:	02 97       	sbiw	r24, 0x02	; 2
    5994:	b0 f0       	brcs	.+44     	; 0x59c2 <systemGeniusProtocol+0xe6>
    5996:	86 e0       	ldi	r24, 0x06	; 6
    5998:	80 93 dc 01 	sts	0x01DC, r24
    599c:	08 95       	ret
	      break;
     case gpNextPumpScan:
          if (iPumpID<=eeprom_read_byte(&DefPoolingPumpMax)){
    599e:	20 91 db 01 	lds	r18, 0x01DB
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    59a2:	e1 99       	sbic	0x1c, 1	; 28
    59a4:	fe cf       	rjmp	.-4      	; 0x59a2 <systemGeniusProtocol+0xc6>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    59a6:	84 e4       	ldi	r24, 0x44	; 68
    59a8:	91 e0       	ldi	r25, 0x01	; 1
    59aa:	9f bb       	out	0x1f, r25	; 31
    59ac:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    59ae:	e0 9a       	sbi	0x1c, 0	; 28
    59b0:	8d b3       	in	r24, 0x1d	; 29
    59b2:	82 17       	cp	r24, r18
    59b4:	30 f0       	brcs	.+12     	; 0x59c2 <systemGeniusProtocol+0xe6>
		      iPumpID++;
    59b6:	2f 5f       	subi	r18, 0xFF	; 255
    59b8:	20 93 db 01 	sts	0x01DB, r18
              stGeniusProtocol=gpScanNewTransaction;
    59bc:	81 e0       	ldi	r24, 0x01	; 1
    59be:	80 93 dc 01 	sts	0x01DC, r24
    59c2:	08 95       	ret

000059c4 <StrAlignCenter>:
	 }
	 //replace
	 for(i=0;i<strlen(sDate);i++)Date[i]=sDate[i];
}

void StrAlignCenter(char *Source, unsigned int Length){
    59c4:	ef 92       	push	r14
    59c6:	ff 92       	push	r15
    59c8:	0f 93       	push	r16
    59ca:	1f 93       	push	r17
    59cc:	18 2f       	mov	r17, r24
    59ce:	09 2f       	mov	r16, r25
    59d0:	7b 01       	movw	r14, r22
char nAddedSpace,srcLength;
     RemSpaceLag(Source);
    59d2:	0e 94 70 24 	call	0x48e0	; 0x48e0 <RemSpaceLag>
	 RemSpaceLead(Source);
    59d6:	81 2f       	mov	r24, r17
    59d8:	90 2f       	mov	r25, r16
    59da:	0e 94 25 24 	call	0x484a	; 0x484a <RemSpaceLead>
	 srcLength=strlen(Source);
    59de:	a1 2f       	mov	r26, r17
    59e0:	b0 2f       	mov	r27, r16
    59e2:	fd 01       	movw	r30, r26
    59e4:	01 90       	ld	r0, Z+
    59e6:	00 20       	and	r0, r0
    59e8:	e9 f7       	brne	.-6      	; 0x59e4 <StrAlignCenter+0x20>
    59ea:	31 97       	sbiw	r30, 0x01	; 1
    59ec:	e1 1b       	sub	r30, r17
     nAddedSpace=(Length-srcLength)/2;
     AddSpaceLead(Source,srcLength+nAddedSpace);
    59ee:	c7 01       	movw	r24, r14
    59f0:	8e 1b       	sub	r24, r30
    59f2:	91 09       	sbc	r25, r1
    59f4:	96 95       	lsr	r25
    59f6:	87 95       	ror	r24
    59f8:	e8 0f       	add	r30, r24
    59fa:	81 2f       	mov	r24, r17
    59fc:	90 2f       	mov	r25, r16
    59fe:	6e 2f       	mov	r22, r30
    5a00:	0e 94 71 2a 	call	0x54e2	; 0x54e2 <AddSpaceLead>
	 AddSpaceLag(Source,Length);
    5a04:	81 2f       	mov	r24, r17
    5a06:	90 2f       	mov	r25, r16
    5a08:	6e 2d       	mov	r22, r14
    5a0a:	0e 94 d8 2a 	call	0x55b0	; 0x55b0 <AddSpaceLag>
}
    5a0e:	1f 91       	pop	r17
    5a10:	0f 91       	pop	r16
    5a12:	ff 90       	pop	r15
    5a14:	ef 90       	pop	r14
    5a16:	08 95       	ret

00005a18 <AddCharLead>:
	 }String[Size]=0;
  }

}

void AddCharLead(char *String,char CharAdded,unsigned char Size){//
    5a18:	bf 92       	push	r11
    5a1a:	cf 92       	push	r12
    5a1c:	df 92       	push	r13
    5a1e:	ef 92       	push	r14
    5a20:	ff 92       	push	r15
    5a22:	0f 93       	push	r16
    5a24:	1f 93       	push	r17
    5a26:	df 93       	push	r29
    5a28:	cf 93       	push	r28
    5a2a:	cd b7       	in	r28, 0x3d	; 61
    5a2c:	de b7       	in	r29, 0x3e	; 62
    5a2e:	6e 97       	sbiw	r28, 0x1e	; 30
    5a30:	0f b6       	in	r0, 0x3f	; 63
    5a32:	f8 94       	cli
    5a34:	de bf       	out	0x3e, r29	; 62
    5a36:	0f be       	out	0x3f, r0	; 63
    5a38:	cd bf       	out	0x3d, r28	; 61
    5a3a:	8c 01       	movw	r16, r24
    5a3c:	e4 2e       	mov	r14, r20
     char i,Length,strAdded[30];
     Length=strlen(String);
    5a3e:	fc 01       	movw	r30, r24
    5a40:	01 90       	ld	r0, Z+
    5a42:	00 20       	and	r0, r0
    5a44:	e9 f7       	brne	.-6      	; 0x5a40 <AddCharLead+0x28>
    5a46:	31 97       	sbiw	r30, 0x01	; 1
    5a48:	2e 2f       	mov	r18, r30
    5a4a:	28 1b       	sub	r18, r24

	 if (Size>Length){
    5a4c:	24 17       	cp	r18, r20
    5a4e:	d0 f5       	brcc	.+116    	; 0x5ac4 <AddCharLead+0xac>
    5a50:	ae 01       	movw	r20, r28
    5a52:	4f 5f       	subi	r20, 0xFF	; 255
    5a54:	5f 4f       	sbci	r21, 0xFF	; 255
    5a56:	fa 01       	movw	r30, r20
	 }String[Size]=0;
  }

}

void AddCharLead(char *String,char CharAdded,unsigned char Size){//
    5a58:	b4 2e       	mov	r11, r20
    5a5a:	01 c0       	rjmp	.+2      	; 0x5a5e <AddCharLead+0x46>
     char i,Length,strAdded[30];
     Length=strlen(String);

	 if (Size>Length){
         for(i=0;i<Size;i++){
	         strAdded[i]=CharAdded;
    5a5c:	61 93       	st	Z+, r22
void AddCharLead(char *String,char CharAdded,unsigned char Size){//
     char i,Length,strAdded[30];
     Length=strlen(String);

	 if (Size>Length){
         for(i=0;i<Size;i++){
    5a5e:	8e 2f       	mov	r24, r30
    5a60:	8b 19       	sub	r24, r11
    5a62:	8e 15       	cp	r24, r14
    5a64:	d8 f3       	brcs	.-10     	; 0x5a5c <AddCharLead+0x44>
	         strAdded[i]=CharAdded;
	     }strAdded[Size]=0;
    5a66:	6e 2d       	mov	r22, r14
    5a68:	70 e0       	ldi	r23, 0x00	; 0
    5a6a:	ce 01       	movw	r24, r28
    5a6c:	01 96       	adiw	r24, 0x01	; 1
    5a6e:	fc 01       	movw	r30, r24
    5a70:	e6 0f       	add	r30, r22
    5a72:	f7 1f       	adc	r31, r23
    5a74:	10 82       	st	Z, r1
	     //Copy
         for(i=(Size-Length);i<Size;i++){
    5a76:	fe 2c       	mov	r15, r14
    5a78:	f2 1a       	sub	r15, r18
    5a7a:	6c 01       	movw	r12, r24
	         strAdded[i]=String[i-(Size-Length)];
    5a7c:	30 e0       	ldi	r19, 0x00	; 0
    5a7e:	26 1b       	sub	r18, r22
    5a80:	37 0b       	sbc	r19, r23
    5a82:	0c c0       	rjmp	.+24     	; 0x5a9c <AddCharLead+0x84>
    5a84:	ef 2d       	mov	r30, r15
    5a86:	f0 e0       	ldi	r31, 0x00	; 0
    5a88:	d6 01       	movw	r26, r12
    5a8a:	ae 0f       	add	r26, r30
    5a8c:	bf 1f       	adc	r27, r31
    5a8e:	e0 0f       	add	r30, r16
    5a90:	f1 1f       	adc	r31, r17
    5a92:	e2 0f       	add	r30, r18
    5a94:	f3 1f       	adc	r31, r19
    5a96:	80 81       	ld	r24, Z
    5a98:	8c 93       	st	X, r24
	 if (Size>Length){
         for(i=0;i<Size;i++){
	         strAdded[i]=CharAdded;
	     }strAdded[Size]=0;
	     //Copy
         for(i=(Size-Length);i<Size;i++){
    5a9a:	f3 94       	inc	r15
    5a9c:	fe 14       	cp	r15, r14
    5a9e:	90 f3       	brcs	.-28     	; 0x5a84 <AddCharLead+0x6c>
	         strAdded[i]=String[i-(Size-Length)];
	     }strAdded[Size]=0;
    5aa0:	6c 0d       	add	r22, r12
    5aa2:	7d 1d       	adc	r23, r13
    5aa4:	db 01       	movw	r26, r22
    5aa6:	1c 92       	st	X, r1
    5aa8:	f8 01       	movw	r30, r16
    5aaa:	04 c0       	rjmp	.+8      	; 0x5ab4 <AddCharLead+0x9c>
	     //Spaced
         for(i=0;i<Size;i++){
	         String[i]=strAdded[i];
    5aac:	da 01       	movw	r26, r20
    5aae:	8d 91       	ld	r24, X+
    5ab0:	ad 01       	movw	r20, r26
    5ab2:	81 93       	st	Z+, r24
	     //Copy
         for(i=(Size-Length);i<Size;i++){
	         strAdded[i]=String[i-(Size-Length)];
	     }strAdded[Size]=0;
	     //Spaced
         for(i=0;i<Size;i++){
    5ab4:	84 2f       	mov	r24, r20
    5ab6:	8b 19       	sub	r24, r11
    5ab8:	8e 15       	cp	r24, r14
    5aba:	c0 f3       	brcs	.-16     	; 0x5aac <AddCharLead+0x94>
	         String[i]=strAdded[i];
	     }String[Size]=0;
    5abc:	0e 0d       	add	r16, r14
    5abe:	11 1d       	adc	r17, r1
    5ac0:	f8 01       	movw	r30, r16
    5ac2:	10 82       	st	Z, r1
	 }
}
    5ac4:	6e 96       	adiw	r28, 0x1e	; 30
    5ac6:	0f b6       	in	r0, 0x3f	; 63
    5ac8:	f8 94       	cli
    5aca:	de bf       	out	0x3e, r29	; 62
    5acc:	0f be       	out	0x3f, r0	; 63
    5ace:	cd bf       	out	0x3d, r28	; 61
    5ad0:	cf 91       	pop	r28
    5ad2:	df 91       	pop	r29
    5ad4:	1f 91       	pop	r17
    5ad6:	0f 91       	pop	r16
    5ad8:	ff 90       	pop	r15
    5ada:	ef 90       	pop	r14
    5adc:	df 90       	pop	r13
    5ade:	cf 90       	pop	r12
    5ae0:	bf 90       	pop	r11
    5ae2:	08 95       	ret

00005ae4 <AddCharLag>:
    }
return Result;
}

//String Processing
void AddCharLag(char *String,char CharAdded,unsigned char Size){
    5ae4:	cf 93       	push	r28
    5ae6:	df 93       	push	r29
    5ae8:	ec 01       	movw	r28, r24
char i,Length;
     Length=strlen(String);
    5aea:	dc 01       	movw	r26, r24
    5aec:	0d 90       	ld	r0, X+
    5aee:	00 20       	and	r0, r0
    5af0:	e9 f7       	brne	.-6      	; 0x5aec <AddCharLag+0x8>
    5af2:	11 97       	sbiw	r26, 0x01	; 1
    5af4:	a8 1b       	sub	r26, r24
    5af6:	b9 0b       	sbc	r27, r25
  if (Length<Size){   
    5af8:	a4 17       	cp	r26, r20
    5afa:	58 f4       	brcc	.+22     	; 0x5b12 <AddCharLag+0x2e>
    5afc:	8a 2f       	mov	r24, r26
     for(i=Length;i<Size;i++){
	    String[i]=CharAdded;
    5afe:	fe 01       	movw	r30, r28
    5b00:	e8 0f       	add	r30, r24
    5b02:	f1 1d       	adc	r31, r1
    5b04:	60 83       	st	Z, r22
//String Processing
void AddCharLag(char *String,char CharAdded,unsigned char Size){
char i,Length;
     Length=strlen(String);
  if (Length<Size){   
     for(i=Length;i<Size;i++){
    5b06:	8f 5f       	subi	r24, 0xFF	; 255
    5b08:	84 17       	cp	r24, r20
    5b0a:	c8 f3       	brcs	.-14     	; 0x5afe <AddCharLag+0x1a>
	    String[i]=CharAdded;
	 }String[Size]=0;
    5b0c:	c4 0f       	add	r28, r20
    5b0e:	d1 1d       	adc	r29, r1
    5b10:	18 82       	st	Y, r1
  }

}
    5b12:	df 91       	pop	r29
    5b14:	cf 91       	pop	r28
    5b16:	08 95       	ret

00005b18 <CountTotalizerSatus>:
		      Result++;		  
		  }	 
	 }
  return Result;
}
char CountTotalizerSatus(char *strPumpStatusTotalizer){
    5b18:	cf 92       	push	r12
    5b1a:	df 92       	push	r13
    5b1c:	ef 92       	push	r14
    5b1e:	ff 92       	push	r15
    5b20:	0f 93       	push	r16
    5b22:	1f 93       	push	r17
    5b24:	cf 93       	push	r28
    5b26:	df 93       	push	r29
    5b28:	7c 01       	movw	r14, r24
char i,Result;
     Result=0;
	 for (i=0;i<strlen(strPumpStatusTotalizer);i++){
    5b2a:	dc 01       	movw	r26, r24
    5b2c:	0d 90       	ld	r0, X+
    5b2e:	00 20       	and	r0, r0
    5b30:	e9 f7       	brne	.-6      	; 0x5b2c <CountTotalizerSatus+0x14>
    5b32:	8d 01       	movw	r16, r26
    5b34:	01 50       	subi	r16, 0x01	; 1
    5b36:	10 40       	sbci	r17, 0x00	; 0
    5b38:	08 1b       	sub	r16, r24
    5b3a:	19 0b       	sbc	r17, r25
    5b3c:	cc 24       	eor	r12, r12
    5b3e:	dd 24       	eor	r13, r13
    5b40:	0a c0       	rjmp	.+20     	; 0x5b56 <CountTotalizerSatus+0x3e>
	      if (strPumpStatusTotalizer[i]==GetPumpStatusLabel(PS_TOTALIZER)){
    5b42:	84 e1       	ldi	r24, 0x14	; 20
    5b44:	0e 94 90 13 	call	0x2720	; 0x2720 <GetPumpStatusLabel>
    5b48:	ce 0d       	add	r28, r14
    5b4a:	df 1d       	adc	r29, r15
    5b4c:	98 81       	ld	r25, Y
    5b4e:	98 17       	cp	r25, r24
    5b50:	09 f4       	brne	.+2      	; 0x5b54 <CountTotalizerSatus+0x3c>
		      Result++;		  
    5b52:	d3 94       	inc	r13
  return Result;
}
char CountTotalizerSatus(char *strPumpStatusTotalizer){
char i,Result;
     Result=0;
	 for (i=0;i<strlen(strPumpStatusTotalizer);i++){
    5b54:	c3 94       	inc	r12
    5b56:	cc 2d       	mov	r28, r12
    5b58:	d0 e0       	ldi	r29, 0x00	; 0
    5b5a:	c0 17       	cp	r28, r16
    5b5c:	d1 07       	cpc	r29, r17
    5b5e:	88 f3       	brcs	.-30     	; 0x5b42 <CountTotalizerSatus+0x2a>
	      if (strPumpStatusTotalizer[i]==GetPumpStatusLabel(PS_TOTALIZER)){
		      Result++;		  
		  }	 
	 }
  return Result;
}
    5b60:	8d 2d       	mov	r24, r13
    5b62:	df 91       	pop	r29
    5b64:	cf 91       	pop	r28
    5b66:	1f 91       	pop	r17
    5b68:	0f 91       	pop	r16
    5b6a:	ff 90       	pop	r15
    5b6c:	ef 90       	pop	r14
    5b6e:	df 90       	pop	r13
    5b70:	cf 90       	pop	r12
    5b72:	08 95       	ret

00005b74 <RemoveChar>:
	   sprintf_P(strSend,PSTR("Wrap:%s"),strDestCode);
	   _uart_print(1,1,strSend);     
	 #endif
}

void RemoveChar(char *strSource, char cRem){
    5b74:	1f 93       	push	r17
    5b76:	df 93       	push	r29
    5b78:	cf 93       	push	r28
    5b7a:	cd b7       	in	r28, 0x3d	; 61
    5b7c:	de b7       	in	r29, 0x3e	; 62
    5b7e:	64 97       	sbiw	r28, 0x14	; 20
    5b80:	0f b6       	in	r0, 0x3f	; 63
    5b82:	f8 94       	cli
    5b84:	de bf       	out	0x3e, r29	; 62
    5b86:	0f be       	out	0x3f, r0	; 63
    5b88:	cd bf       	out	0x3d, r28	; 61
    5b8a:	16 2f       	mov	r17, r22
    5b8c:	50 e0       	ldi	r21, 0x00	; 0
    5b8e:	40 e0       	ldi	r20, 0x00	; 0
     char i,iAdd,sTemp[20];
     iAdd=0;
	 for(i=0;i<strlen(strSource);i++){
	     if (strSource[i]!=cRem){
		     sTemp[iAdd]=strSource[i];
    5b90:	be 01       	movw	r22, r28
    5b92:	6f 5f       	subi	r22, 0xFF	; 255
    5b94:	7f 4f       	sbci	r23, 0xFF	; 255
    5b96:	0c c0       	rjmp	.+24     	; 0x5bb0 <RemoveChar+0x3c>

void RemoveChar(char *strSource, char cRem){
     char i,iAdd,sTemp[20];
     iAdd=0;
	 for(i=0;i<strlen(strSource);i++){
	     if (strSource[i]!=cRem){
    5b98:	28 0f       	add	r18, r24
    5b9a:	39 1f       	adc	r19, r25
    5b9c:	d9 01       	movw	r26, r18
    5b9e:	2c 91       	ld	r18, X
    5ba0:	21 17       	cp	r18, r17
    5ba2:	29 f0       	breq	.+10     	; 0x5bae <RemoveChar+0x3a>
		     sTemp[iAdd]=strSource[i];
    5ba4:	fb 01       	movw	r30, r22
    5ba6:	e4 0f       	add	r30, r20
    5ba8:	f1 1d       	adc	r31, r1
    5baa:	20 83       	st	Z, r18
			 iAdd++;
    5bac:	4f 5f       	subi	r20, 0xFF	; 255
}

void RemoveChar(char *strSource, char cRem){
     char i,iAdd,sTemp[20];
     iAdd=0;
	 for(i=0;i<strlen(strSource);i++){
    5bae:	5f 5f       	subi	r21, 0xFF	; 255
    5bb0:	25 2f       	mov	r18, r21
    5bb2:	30 e0       	ldi	r19, 0x00	; 0
    5bb4:	fc 01       	movw	r30, r24
    5bb6:	01 90       	ld	r0, Z+
    5bb8:	00 20       	and	r0, r0
    5bba:	e9 f7       	brne	.-6      	; 0x5bb6 <RemoveChar+0x42>
    5bbc:	31 97       	sbiw	r30, 0x01	; 1
    5bbe:	e8 1b       	sub	r30, r24
    5bc0:	f9 0b       	sbc	r31, r25
    5bc2:	2e 17       	cp	r18, r30
    5bc4:	3f 07       	cpc	r19, r31
    5bc6:	40 f3       	brcs	.-48     	; 0x5b98 <RemoveChar+0x24>
	     if (strSource[i]!=cRem){
		     sTemp[iAdd]=strSource[i];
			 iAdd++;
          }
	 }sTemp[iAdd]=0;
    5bc8:	9e 01       	movw	r18, r28
    5bca:	2f 5f       	subi	r18, 0xFF	; 255
    5bcc:	3f 4f       	sbci	r19, 0xFF	; 255
    5bce:	f9 01       	movw	r30, r18
    5bd0:	e4 0f       	add	r30, r20
    5bd2:	f1 1d       	adc	r31, r1
    5bd4:	10 82       	st	Z, r1
	 sprintf_P(strSource,PSTR("%s"),sTemp);
    5bd6:	00 d0       	rcall	.+0      	; 0x5bd8 <RemoveChar+0x64>
    5bd8:	00 d0       	rcall	.+0      	; 0x5bda <RemoveChar+0x66>
    5bda:	00 d0       	rcall	.+0      	; 0x5bdc <RemoveChar+0x68>
    5bdc:	ed b7       	in	r30, 0x3d	; 61
    5bde:	fe b7       	in	r31, 0x3e	; 62
    5be0:	31 96       	adiw	r30, 0x01	; 1
    5be2:	ad b7       	in	r26, 0x3d	; 61
    5be4:	be b7       	in	r27, 0x3e	; 62
    5be6:	12 96       	adiw	r26, 0x02	; 2
    5be8:	9c 93       	st	X, r25
    5bea:	8e 93       	st	-X, r24
    5bec:	11 97       	sbiw	r26, 0x01	; 1
    5bee:	8f ea       	ldi	r24, 0xAF	; 175
    5bf0:	97 e1       	ldi	r25, 0x17	; 23
    5bf2:	93 83       	std	Z+3, r25	; 0x03
    5bf4:	82 83       	std	Z+2, r24	; 0x02
    5bf6:	35 83       	std	Z+5, r19	; 0x05
    5bf8:	24 83       	std	Z+4, r18	; 0x04
    5bfa:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    5bfe:	ed b7       	in	r30, 0x3d	; 61
    5c00:	fe b7       	in	r31, 0x3e	; 62
    5c02:	36 96       	adiw	r30, 0x06	; 6
    5c04:	0f b6       	in	r0, 0x3f	; 63
    5c06:	f8 94       	cli
    5c08:	fe bf       	out	0x3e, r31	; 62
    5c0a:	0f be       	out	0x3f, r0	; 63
    5c0c:	ed bf       	out	0x3d, r30	; 61
}
    5c0e:	64 96       	adiw	r28, 0x14	; 20
    5c10:	0f b6       	in	r0, 0x3f	; 63
    5c12:	f8 94       	cli
    5c14:	de bf       	out	0x3e, r29	; 62
    5c16:	0f be       	out	0x3f, r0	; 63
    5c18:	cd bf       	out	0x3d, r28	; 61
    5c1a:	cf 91       	pop	r28
    5c1c:	df 91       	pop	r29
    5c1e:	1f 91       	pop	r17
    5c20:	08 95       	ret

00005c22 <WrapCode>:
	      break;
	 }
   return Result;
}

void WrapCode(char *strRawCode){
    5c22:	8f 92       	push	r8
    5c24:	9f 92       	push	r9
    5c26:	bf 92       	push	r11
    5c28:	cf 92       	push	r12
    5c2a:	df 92       	push	r13
    5c2c:	ef 92       	push	r14
    5c2e:	ff 92       	push	r15
    5c30:	0f 93       	push	r16
    5c32:	1f 93       	push	r17
    5c34:	df 93       	push	r29
    5c36:	cf 93       	push	r28
    5c38:	cd b7       	in	r28, 0x3d	; 61
    5c3a:	de b7       	in	r29, 0x3e	; 62
    5c3c:	2f 97       	sbiw	r28, 0x0f	; 15
    5c3e:	0f b6       	in	r0, 0x3f	; 63
    5c40:	f8 94       	cli
    5c42:	de bf       	out	0x3e, r29	; 62
    5c44:	0f be       	out	0x3f, r0	; 63
    5c46:	cd bf       	out	0x3d, r28	; 61
    5c48:	6c 01       	movw	r12, r24
    5c4a:	bb 24       	eor	r11, r11
    5c4c:	40 e0       	ldi	r20, 0x00	; 0
    5c4e:	4e 01       	movw	r8, r28
    5c50:	08 94       	sec
    5c52:	81 1c       	adc	r8, r1
    5c54:	91 1c       	adc	r9, r1
    5c56:	12 c0       	rjmp	.+36     	; 0x5c7c <WrapCode+0x5a>
     char i,seedKey;
	 char strTemp[15];
	 //62678677 ->68846445
	 seedKey=0;
	 for (i=0;i<strlen(strRawCode);i++){
	      strTemp[i]='0'+GeniusCalc(G_PLUS,(strRawCode[i]-'0'),seedKey);
    5c58:	86 01       	movw	r16, r12
    5c5a:	0e 0d       	add	r16, r14
    5c5c:	1f 1d       	adc	r17, r15
    5c5e:	d8 01       	movw	r26, r16
    5c60:	6c 91       	ld	r22, X
    5c62:	60 53       	subi	r22, 0x30	; 48
    5c64:	80 e0       	ldi	r24, 0x00	; 0
    5c66:	0e 94 5a 16 	call	0x2cb4	; 0x2cb4 <GeniusCalc>
    5c6a:	e8 0c       	add	r14, r8
    5c6c:	f9 1c       	adc	r15, r9
    5c6e:	80 5d       	subi	r24, 0xD0	; 208
    5c70:	f7 01       	movw	r30, r14
    5c72:	80 83       	st	Z, r24
		  seedKey=strRawCode[i]-'0';
    5c74:	d8 01       	movw	r26, r16
    5c76:	4c 91       	ld	r20, X
    5c78:	40 53       	subi	r20, 0x30	; 48
void WrapCode(char *strRawCode){
     char i,seedKey;
	 char strTemp[15];
	 //62678677 ->68846445
	 seedKey=0;
	 for (i=0;i<strlen(strRawCode);i++){
    5c7a:	b3 94       	inc	r11
    5c7c:	eb 2c       	mov	r14, r11
    5c7e:	ff 24       	eor	r15, r15
    5c80:	d6 01       	movw	r26, r12
    5c82:	0d 90       	ld	r0, X+
    5c84:	00 20       	and	r0, r0
    5c86:	e9 f7       	brne	.-6      	; 0x5c82 <WrapCode+0x60>
    5c88:	11 97       	sbiw	r26, 0x01	; 1
    5c8a:	ac 19       	sub	r26, r12
    5c8c:	bd 09       	sbc	r27, r13
    5c8e:	ea 16       	cp	r14, r26
    5c90:	fb 06       	cpc	r15, r27
    5c92:	10 f3       	brcs	.-60     	; 0x5c58 <WrapCode+0x36>
	      strTemp[i]='0'+GeniusCalc(G_PLUS,(strRawCode[i]-'0'),seedKey);
		  seedKey=strRawCode[i]-'0';
	 }strTemp[strlen(strRawCode)]=0;
    5c94:	a8 0d       	add	r26, r8
    5c96:	b9 1d       	adc	r27, r9
    5c98:	1c 92       	st	X, r1
     sprintf_P(strRawCode,PSTR("%s"),strTemp);
    5c9a:	00 d0       	rcall	.+0      	; 0x5c9c <WrapCode+0x7a>
    5c9c:	00 d0       	rcall	.+0      	; 0x5c9e <WrapCode+0x7c>
    5c9e:	00 d0       	rcall	.+0      	; 0x5ca0 <WrapCode+0x7e>
    5ca0:	ed b7       	in	r30, 0x3d	; 61
    5ca2:	fe b7       	in	r31, 0x3e	; 62
    5ca4:	31 96       	adiw	r30, 0x01	; 1
    5ca6:	ad b7       	in	r26, 0x3d	; 61
    5ca8:	be b7       	in	r27, 0x3e	; 62
    5caa:	12 96       	adiw	r26, 0x02	; 2
    5cac:	dc 92       	st	X, r13
    5cae:	ce 92       	st	-X, r12
    5cb0:	11 97       	sbiw	r26, 0x01	; 1
    5cb2:	8a eb       	ldi	r24, 0xBA	; 186
    5cb4:	97 e1       	ldi	r25, 0x17	; 23
    5cb6:	93 83       	std	Z+3, r25	; 0x03
    5cb8:	82 83       	std	Z+2, r24	; 0x02
    5cba:	95 82       	std	Z+5, r9	; 0x05
    5cbc:	84 82       	std	Z+4, r8	; 0x04
    5cbe:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    5cc2:	ed b7       	in	r30, 0x3d	; 61
    5cc4:	fe b7       	in	r31, 0x3e	; 62
    5cc6:	36 96       	adiw	r30, 0x06	; 6
    5cc8:	0f b6       	in	r0, 0x3f	; 63
    5cca:	f8 94       	cli
    5ccc:	fe bf       	out	0x3e, r31	; 62
    5cce:	0f be       	out	0x3f, r0	; 63
    5cd0:	ed bf       	out	0x3d, r30	; 61
}
    5cd2:	2f 96       	adiw	r28, 0x0f	; 15
    5cd4:	0f b6       	in	r0, 0x3f	; 63
    5cd6:	f8 94       	cli
    5cd8:	de bf       	out	0x3e, r29	; 62
    5cda:	0f be       	out	0x3f, r0	; 63
    5cdc:	cd bf       	out	0x3d, r28	; 61
    5cde:	cf 91       	pop	r28
    5ce0:	df 91       	pop	r29
    5ce2:	1f 91       	pop	r17
    5ce4:	0f 91       	pop	r16
    5ce6:	ff 90       	pop	r15
    5ce8:	ef 90       	pop	r14
    5cea:	df 90       	pop	r13
    5cec:	cf 90       	pop	r12
    5cee:	bf 90       	pop	r11
    5cf0:	9f 90       	pop	r9
    5cf2:	8f 90       	pop	r8
    5cf4:	08 95       	ret

00005cf6 <GenerateKeyStamp>:


   return Result;
}

void GenerateKeyStamp(char *sTime, char *sGCode, char *strKeyStamp){//
    5cf6:	8f 92       	push	r8
    5cf8:	9f 92       	push	r9
    5cfa:	af 92       	push	r10
    5cfc:	bf 92       	push	r11
    5cfe:	df 92       	push	r13
    5d00:	ef 92       	push	r14
    5d02:	ff 92       	push	r15
    5d04:	0f 93       	push	r16
    5d06:	1f 93       	push	r17
    5d08:	df 93       	push	r29
    5d0a:	cf 93       	push	r28
    5d0c:	cd b7       	in	r28, 0x3d	; 61
    5d0e:	de b7       	in	r29, 0x3e	; 62
    5d10:	2d 97       	sbiw	r28, 0x0d	; 13
    5d12:	0f b6       	in	r0, 0x3f	; 63
    5d14:	f8 94       	cli
    5d16:	de bf       	out	0x3e, r29	; 62
    5d18:	0f be       	out	0x3f, r0	; 63
    5d1a:	cd bf       	out	0x3d, r28	; 61
    5d1c:	9c 01       	movw	r18, r24
    5d1e:	7b 01       	movw	r14, r22
    5d20:	5a 01       	movw	r10, r20
	             65585577
	 */
     char seedIdx,sSeed[10],sAdd[3],i;
     
	 seedIdx=(sTime[5]-'0')%8; 
	 sAdd[0]=sGCode[seedIdx];
    5d22:	dc 01       	movw	r26, r24
    5d24:	15 96       	adiw	r26, 0x05	; 5
    5d26:	8c 91       	ld	r24, X
    5d28:	90 e0       	ldi	r25, 0x00	; 0
    5d2a:	c0 97       	sbiw	r24, 0x30	; 48
    5d2c:	68 e0       	ldi	r22, 0x08	; 8
    5d2e:	70 e0       	ldi	r23, 0x00	; 0
    5d30:	0e 94 4c b7 	call	0x16e98	; 0x16e98 <__divmodhi4>
    5d34:	f7 01       	movw	r30, r14
    5d36:	e8 0f       	add	r30, r24
    5d38:	f1 1d       	adc	r31, r1
    5d3a:	80 81       	ld	r24, Z
    5d3c:	89 83       	std	Y+1, r24	; 0x01
     seedIdx=(sTime[6]-'0')%8;
	 sAdd[1]=sGCode[seedIdx];
    5d3e:	f9 01       	movw	r30, r18
    5d40:	86 81       	ldd	r24, Z+6	; 0x06
    5d42:	90 e0       	ldi	r25, 0x00	; 0
    5d44:	c0 97       	sbiw	r24, 0x30	; 48
    5d46:	68 e0       	ldi	r22, 0x08	; 8
    5d48:	70 e0       	ldi	r23, 0x00	; 0
    5d4a:	0e 94 4c b7 	call	0x16e98	; 0x16e98 <__divmodhi4>
    5d4e:	f7 01       	movw	r30, r14
    5d50:	e8 0f       	add	r30, r24
    5d52:	f1 1d       	adc	r31, r1
    5d54:	80 81       	ld	r24, Z
    5d56:	8a 83       	std	Y+2, r24	; 0x02
	 sAdd[2]=0;
    5d58:	1b 82       	std	Y+3, r1	; 0x03

	 sprintf_P(sSeed,PSTR("%s%s"),sTime,sAdd);
    5d5a:	8d b7       	in	r24, 0x3d	; 61
    5d5c:	9e b7       	in	r25, 0x3e	; 62
    5d5e:	08 97       	sbiw	r24, 0x08	; 8
    5d60:	0f b6       	in	r0, 0x3f	; 63
    5d62:	f8 94       	cli
    5d64:	9e bf       	out	0x3e, r25	; 62
    5d66:	0f be       	out	0x3f, r0	; 63
    5d68:	8d bf       	out	0x3d, r24	; 61
    5d6a:	ed b7       	in	r30, 0x3d	; 61
    5d6c:	fe b7       	in	r31, 0x3e	; 62
    5d6e:	31 96       	adiw	r30, 0x01	; 1
    5d70:	8e 01       	movw	r16, r28
    5d72:	0c 5f       	subi	r16, 0xFC	; 252
    5d74:	1f 4f       	sbci	r17, 0xFF	; 255
    5d76:	ad b7       	in	r26, 0x3d	; 61
    5d78:	be b7       	in	r27, 0x3e	; 62
    5d7a:	12 96       	adiw	r26, 0x02	; 2
    5d7c:	1c 93       	st	X, r17
    5d7e:	0e 93       	st	-X, r16
    5d80:	11 97       	sbiw	r26, 0x01	; 1
    5d82:	8a ea       	ldi	r24, 0xAA	; 170
    5d84:	97 e1       	ldi	r25, 0x17	; 23
    5d86:	93 83       	std	Z+3, r25	; 0x03
    5d88:	82 83       	std	Z+2, r24	; 0x02
    5d8a:	35 83       	std	Z+5, r19	; 0x05
    5d8c:	24 83       	std	Z+4, r18	; 0x04
    5d8e:	ce 01       	movw	r24, r28
    5d90:	01 96       	adiw	r24, 0x01	; 1
    5d92:	97 83       	std	Z+7, r25	; 0x07
    5d94:	86 83       	std	Z+6, r24	; 0x06
    5d96:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    5d9a:	dd 24       	eor	r13, r13
    5d9c:	ed b7       	in	r30, 0x3d	; 61
    5d9e:	fe b7       	in	r31, 0x3e	; 62
    5da0:	38 96       	adiw	r30, 0x08	; 8
    5da2:	0f b6       	in	r0, 0x3f	; 63
    5da4:	f8 94       	cli
    5da6:	fe bf       	out	0x3e, r31	; 62
    5da8:	0f be       	out	0x3f, r0	; 63
    5daa:	ed bf       	out	0x3d, r30	; 61
     for(i=0;i<strlen(sGCode);i++){
	     strKeyStamp[i]='0'+GeniusCalc(G_MULTY,(sSeed[i]-'0'),(sGCode[i]-'0'));		 
    5dac:	48 01       	movw	r8, r16
    5dae:	13 c0       	rjmp	.+38     	; 0x5dd6 <GenerateKeyStamp+0xe0>
    5db0:	f4 01       	movw	r30, r8
    5db2:	e0 0f       	add	r30, r16
    5db4:	f1 1f       	adc	r31, r17
    5db6:	60 81       	ld	r22, Z
    5db8:	60 53       	subi	r22, 0x30	; 48
    5dba:	f7 01       	movw	r30, r14
    5dbc:	e0 0f       	add	r30, r16
    5dbe:	f1 1f       	adc	r31, r17
    5dc0:	40 81       	ld	r20, Z
    5dc2:	40 53       	subi	r20, 0x30	; 48
    5dc4:	81 e0       	ldi	r24, 0x01	; 1
    5dc6:	0e 94 5a 16 	call	0x2cb4	; 0x2cb4 <GeniusCalc>
    5dca:	0a 0d       	add	r16, r10
    5dcc:	1b 1d       	adc	r17, r11
    5dce:	80 5d       	subi	r24, 0xD0	; 208
    5dd0:	d8 01       	movw	r26, r16
    5dd2:	8c 93       	st	X, r24
     seedIdx=(sTime[6]-'0')%8;
	 sAdd[1]=sGCode[seedIdx];
	 sAdd[2]=0;

	 sprintf_P(sSeed,PSTR("%s%s"),sTime,sAdd);
     for(i=0;i<strlen(sGCode);i++){
    5dd4:	d3 94       	inc	r13
    5dd6:	0d 2d       	mov	r16, r13
    5dd8:	10 e0       	ldi	r17, 0x00	; 0
    5dda:	d7 01       	movw	r26, r14
    5ddc:	0d 90       	ld	r0, X+
    5dde:	00 20       	and	r0, r0
    5de0:	e9 f7       	brne	.-6      	; 0x5ddc <GenerateKeyStamp+0xe6>
    5de2:	11 97       	sbiw	r26, 0x01	; 1
    5de4:	ae 19       	sub	r26, r14
    5de6:	bf 09       	sbc	r27, r15
    5de8:	0a 17       	cp	r16, r26
    5dea:	1b 07       	cpc	r17, r27
    5dec:	08 f3       	brcs	.-62     	; 0x5db0 <GenerateKeyStamp+0xba>
	     strKeyStamp[i]='0'+GeniusCalc(G_MULTY,(sSeed[i]-'0'),(sGCode[i]-'0'));		 
	 }strKeyStamp[strlen(sGCode)]=0;
    5dee:	aa 0d       	add	r26, r10
    5df0:	bb 1d       	adc	r27, r11
    5df2:	1c 92       	st	X, r1
     WrapCode(strKeyStamp);
    5df4:	c5 01       	movw	r24, r10
    5df6:	0e 94 11 2e 	call	0x5c22	; 0x5c22 <WrapCode>
}
    5dfa:	2d 96       	adiw	r28, 0x0d	; 13
    5dfc:	0f b6       	in	r0, 0x3f	; 63
    5dfe:	f8 94       	cli
    5e00:	de bf       	out	0x3e, r29	; 62
    5e02:	0f be       	out	0x3f, r0	; 63
    5e04:	cd bf       	out	0x3d, r28	; 61
    5e06:	cf 91       	pop	r28
    5e08:	df 91       	pop	r29
    5e0a:	1f 91       	pop	r17
    5e0c:	0f 91       	pop	r16
    5e0e:	ff 90       	pop	r15
    5e10:	ef 90       	pop	r14
    5e12:	df 90       	pop	r13
    5e14:	bf 90       	pop	r11
    5e16:	af 90       	pop	r10
    5e18:	9f 90       	pop	r9
    5e1a:	8f 90       	pop	r8
    5e1c:	08 95       	ret

00005e1e <GenerateGeniusCode>:
		  seedKey=strRawCode[i]-'0';
	 }strTemp[strlen(strRawCode)]=0;
     sprintf_P(strRawCode,PSTR("%s"),strTemp);
}

void GenerateGeniusCode(char *srcDate, char cSeed, char *strDestCode){
    5e1e:	af 92       	push	r10
    5e20:	bf 92       	push	r11
    5e22:	cf 92       	push	r12
    5e24:	df 92       	push	r13
    5e26:	ef 92       	push	r14
    5e28:	ff 92       	push	r15
    5e2a:	0f 93       	push	r16
    5e2c:	1f 93       	push	r17
    5e2e:	df 93       	push	r29
    5e30:	cf 93       	push	r28
    5e32:	cd b7       	in	r28, 0x3d	; 61
    5e34:	de b7       	in	r29, 0x3e	; 62
    5e36:	28 97       	sbiw	r28, 0x08	; 8
    5e38:	0f b6       	in	r0, 0x3f	; 63
    5e3a:	f8 94       	cli
    5e3c:	de bf       	out	0x3e, r29	; 62
    5e3e:	0f be       	out	0x3f, r0	; 63
    5e40:	cd bf       	out	0x3d, r28	; 61
    5e42:	7c 01       	movw	r14, r24
    5e44:	c6 2e       	mov	r12, r22
    5e46:	5a 01       	movw	r10, r20
	    sprintf_P(strSend,PSTR("Date[%s]"),srcDate);
		_uart_print(1,1,strSend);
     #endif
    

	 StrPosCopy(srcDate,AddYear,strlen(srcDate)-2,2);
    5e48:	fc 01       	movw	r30, r24
    5e4a:	01 90       	ld	r0, Z+
    5e4c:	00 20       	and	r0, r0
    5e4e:	e9 f7       	brne	.-6      	; 0x5e4a <GenerateGeniusCode+0x2c>
    5e50:	e8 1b       	sub	r30, r24
    5e52:	f9 0b       	sbc	r31, r25
    5e54:	33 97       	sbiw	r30, 0x03	; 3
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    5e56:	e8 0f       	add	r30, r24
    5e58:	f9 1f       	adc	r31, r25
    5e5a:	80 81       	ld	r24, Z
    5e5c:	89 83       	std	Y+1, r24	; 0x01
    5e5e:	81 81       	ldd	r24, Z+1	; 0x01
    5e60:	8a 83       	std	Y+2, r24	; 0x02
	 }Dest[Length]=0;
    5e62:	1b 82       	std	Y+3, r1	; 0x03
    #ifdef DEBUG_GENIUS_CODE
	    sprintf_P(strSend,PSTR("Year:[%s]"),AddYear);
		_uart_print(1,1,strSend);
     #endif

	 sprintf_P(SYear,PSTR("20%s"),AddYear);
    5e64:	00 d0       	rcall	.+0      	; 0x5e66 <GenerateGeniusCode+0x48>
    5e66:	00 d0       	rcall	.+0      	; 0x5e68 <GenerateGeniusCode+0x4a>
    5e68:	00 d0       	rcall	.+0      	; 0x5e6a <GenerateGeniusCode+0x4c>
    5e6a:	ed b7       	in	r30, 0x3d	; 61
    5e6c:	fe b7       	in	r31, 0x3e	; 62
    5e6e:	31 96       	adiw	r30, 0x01	; 1
    5e70:	8e 01       	movw	r16, r28
    5e72:	0c 5f       	subi	r16, 0xFC	; 252
    5e74:	1f 4f       	sbci	r17, 0xFF	; 255
    5e76:	ad b7       	in	r26, 0x3d	; 61
    5e78:	be b7       	in	r27, 0x3e	; 62
    5e7a:	12 96       	adiw	r26, 0x02	; 2
    5e7c:	1c 93       	st	X, r17
    5e7e:	0e 93       	st	-X, r16
    5e80:	11 97       	sbiw	r26, 0x01	; 1
    5e82:	85 eb       	ldi	r24, 0xB5	; 181
    5e84:	97 e1       	ldi	r25, 0x17	; 23
    5e86:	93 83       	std	Z+3, r25	; 0x03
    5e88:	82 83       	std	Z+2, r24	; 0x02
    5e8a:	ce 01       	movw	r24, r28
    5e8c:	01 96       	adiw	r24, 0x01	; 1
    5e8e:	95 83       	std	Z+5, r25	; 0x05
    5e90:	84 83       	std	Z+4, r24	; 0x04
    5e92:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
	 StrPosPaste(SYear,srcDate,strlen(srcDate)-2,strlen(SYear));
    5e96:	d7 01       	movw	r26, r14
    5e98:	0d 90       	ld	r0, X+
    5e9a:	00 20       	and	r0, r0
    5e9c:	e9 f7       	brne	.-6      	; 0x5e98 <GenerateGeniusCode+0x7a>
    5e9e:	9d 01       	movw	r18, r26
    5ea0:	21 50       	subi	r18, 0x01	; 1
    5ea2:	30 40       	sbci	r19, 0x00	; 0
    5ea4:	2e 19       	sub	r18, r14
    5ea6:	3f 09       	sbc	r19, r15
    5ea8:	d8 01       	movw	r26, r16
    5eaa:	0d 90       	ld	r0, X+
    5eac:	00 20       	and	r0, r0
    5eae:	e9 f7       	brne	.-6      	; 0x5eaa <GenerateGeniusCode+0x8c>
    5eb0:	11 97       	sbiw	r26, 0x01	; 1
    5eb2:	a0 1b       	sub	r26, r16
    5eb4:	b1 0b       	sbc	r27, r17
    5eb6:	22 50       	subi	r18, 0x02	; 2
    5eb8:	30 40       	sbci	r19, 0x00	; 0
    5eba:	b7 01       	movw	r22, r14
    5ebc:	62 0f       	add	r22, r18
    5ebe:	73 1f       	adc	r23, r19
    5ec0:	2e 5f       	subi	r18, 0xFE	; 254
    5ec2:	3f 4f       	sbci	r19, 0xFF	; 255
    5ec4:	40 e0       	ldi	r20, 0x00	; 0
    5ec6:	50 e0       	ldi	r21, 0x00	; 0
    5ec8:	ed b7       	in	r30, 0x3d	; 61
    5eca:	fe b7       	in	r31, 0x3e	; 62
    5ecc:	36 96       	adiw	r30, 0x06	; 6
    5ece:	0f b6       	in	r0, 0x3f	; 63
    5ed0:	f8 94       	cli
    5ed2:	fe bf       	out	0x3e, r31	; 62
    5ed4:	0f be       	out	0x3f, r0	; 63
    5ed6:	ed bf       	out	0x3d, r30	; 61
    5ed8:	09 c0       	rjmp	.+18     	; 0x5eec <GenerateGeniusCode+0xce>
	 }Dest[Length]=0;
}
void StrPosPaste(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[IdxSource+i]=Source[i];
    5eda:	f8 01       	movw	r30, r16
    5edc:	e4 0f       	add	r30, r20
    5ede:	f5 1f       	adc	r31, r21
    5ee0:	80 81       	ld	r24, Z
    5ee2:	fb 01       	movw	r30, r22
    5ee4:	81 93       	st	Z+, r24
    5ee6:	bf 01       	movw	r22, r30
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
}
void StrPosPaste(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    5ee8:	4f 5f       	subi	r20, 0xFF	; 255
    5eea:	5f 4f       	sbci	r21, 0xFF	; 255
    5eec:	4a 17       	cp	r20, r26
    5eee:	5b 07       	cpc	r21, r27
    5ef0:	a0 f3       	brcs	.-24     	; 0x5eda <GenerateGeniusCode+0xbc>
	    Dest[IdxSource+i]=Source[i];
	 }Dest[IdxSource+Length]=0;
    5ef2:	ae 0d       	add	r26, r14
    5ef4:	bf 1d       	adc	r27, r15
    5ef6:	a2 0f       	add	r26, r18
    5ef8:	b3 1f       	adc	r27, r19
    5efa:	12 97       	sbiw	r26, 0x02	; 2
    5efc:	1c 92       	st	X, r1
	 #ifdef DEBUG_GENIUS_CODE
	    sprintf_P(strSend,PSTR("NewDate[%s]"),srcDate);
		_uart_print(1,1,strSend);
     #endif

	 sprintf_P(strDestCode,PSTR("%c"),cSeed);     
    5efe:	00 d0       	rcall	.+0      	; 0x5f00 <GenerateGeniusCode+0xe2>
    5f00:	00 d0       	rcall	.+0      	; 0x5f02 <GenerateGeniusCode+0xe4>
    5f02:	00 d0       	rcall	.+0      	; 0x5f04 <GenerateGeniusCode+0xe6>
    5f04:	ed b7       	in	r30, 0x3d	; 61
    5f06:	fe b7       	in	r31, 0x3e	; 62
    5f08:	31 96       	adiw	r30, 0x01	; 1
    5f0a:	ad b7       	in	r26, 0x3d	; 61
    5f0c:	be b7       	in	r27, 0x3e	; 62
    5f0e:	12 96       	adiw	r26, 0x02	; 2
    5f10:	bc 92       	st	X, r11
    5f12:	ae 92       	st	-X, r10
    5f14:	11 97       	sbiw	r26, 0x01	; 1
    5f16:	82 eb       	ldi	r24, 0xB2	; 178
    5f18:	97 e1       	ldi	r25, 0x17	; 23
    5f1a:	93 83       	std	Z+3, r25	; 0x03
    5f1c:	82 83       	std	Z+2, r24	; 0x02
    5f1e:	c4 82       	std	Z+4, r12	; 0x04
    5f20:	15 82       	std	Z+5, r1	; 0x05
    5f22:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    5f26:	dd 24       	eor	r13, r13
    5f28:	d3 94       	inc	r13
    5f2a:	ed b7       	in	r30, 0x3d	; 61
    5f2c:	fe b7       	in	r31, 0x3e	; 62
    5f2e:	36 96       	adiw	r30, 0x06	; 6
    5f30:	0f b6       	in	r0, 0x3f	; 63
    5f32:	f8 94       	cli
    5f34:	fe bf       	out	0x3e, r31	; 62
    5f36:	0f be       	out	0x3f, r0	; 63
    5f38:	ed bf       	out	0x3d, r30	; 61
	 GCalcOpt=G_PLUS;
	 for (i=1;i<strlen(srcDate);i++){
	      strDestCode[i]='0'+GeniusCalc(GCalcOpt,(cSeed-'0'),(srcDate[i]-'0'));	 
    5f3a:	f0 ed       	ldi	r31, 0xD0	; 208
    5f3c:	cf 0e       	add	r12, r31
    5f3e:	0f c0       	rjmp	.+30     	; 0x5f5e <GenerateGeniusCode+0x140>
    5f40:	f7 01       	movw	r30, r14
    5f42:	e0 0f       	add	r30, r16
    5f44:	f1 1f       	adc	r31, r17
    5f46:	40 81       	ld	r20, Z
    5f48:	40 53       	subi	r20, 0x30	; 48
    5f4a:	80 e0       	ldi	r24, 0x00	; 0
    5f4c:	6c 2d       	mov	r22, r12
    5f4e:	0e 94 5a 16 	call	0x2cb4	; 0x2cb4 <GeniusCalc>
    5f52:	0a 0d       	add	r16, r10
    5f54:	1b 1d       	adc	r17, r11
    5f56:	80 5d       	subi	r24, 0xD0	; 208
    5f58:	d8 01       	movw	r26, r16
    5f5a:	8c 93       	st	X, r24
		_uart_print(1,1,strSend);
     #endif

	 sprintf_P(strDestCode,PSTR("%c"),cSeed);     
	 GCalcOpt=G_PLUS;
	 for (i=1;i<strlen(srcDate);i++){
    5f5c:	d3 94       	inc	r13
    5f5e:	0d 2d       	mov	r16, r13
    5f60:	10 e0       	ldi	r17, 0x00	; 0
    5f62:	d7 01       	movw	r26, r14
    5f64:	0d 90       	ld	r0, X+
    5f66:	00 20       	and	r0, r0
    5f68:	e9 f7       	brne	.-6      	; 0x5f64 <GenerateGeniusCode+0x146>
    5f6a:	11 97       	sbiw	r26, 0x01	; 1
    5f6c:	ae 19       	sub	r26, r14
    5f6e:	bf 09       	sbc	r27, r15
    5f70:	0a 17       	cp	r16, r26
    5f72:	1b 07       	cpc	r17, r27
    5f74:	28 f3       	brcs	.-54     	; 0x5f40 <GenerateGeniusCode+0x122>
	      strDestCode[i]='0'+GeniusCalc(GCalcOpt,(cSeed-'0'),(srcDate[i]-'0'));	 
	 }strDestCode[strlen(srcDate)]=0;
    5f76:	aa 0d       	add	r26, r10
    5f78:	bb 1d       	adc	r27, r11
    5f7a:	1c 92       	st	X, r1
	 #ifdef DEBUG_GENIUS_CODE
       sprintf_P(strSend,PSTR("1st:%s"),strDestCode);
	   _uart_print(1,1,strSend);     
	 #endif

	 WrapCode(strDestCode);
    5f7c:	c5 01       	movw	r24, r10
    5f7e:	0e 94 11 2e 	call	0x5c22	; 0x5c22 <WrapCode>
	 #ifdef DEBUG_GENIUS_CODE
	   sprintf_P(strSend,PSTR("Wrap:%s"),strDestCode);
	   _uart_print(1,1,strSend);     
	 #endif
}
    5f82:	28 96       	adiw	r28, 0x08	; 8
    5f84:	0f b6       	in	r0, 0x3f	; 63
    5f86:	f8 94       	cli
    5f88:	de bf       	out	0x3e, r29	; 62
    5f8a:	0f be       	out	0x3f, r0	; 63
    5f8c:	cd bf       	out	0x3d, r28	; 61
    5f8e:	cf 91       	pop	r28
    5f90:	df 91       	pop	r29
    5f92:	1f 91       	pop	r17
    5f94:	0f 91       	pop	r16
    5f96:	ff 90       	pop	r15
    5f98:	ef 90       	pop	r14
    5f9a:	df 90       	pop	r13
    5f9c:	cf 90       	pop	r12
    5f9e:	bf 90       	pop	r11
    5fa0:	af 90       	pop	r10
    5fa2:	08 95       	ret

00005fa4 <GeneratePrintInit>:
	IsBusyMsg11=True;
}



void GeneratePrintInit(){//Create Initialize Print 
    5fa4:	cf 92       	push	r12
    5fa6:	df 92       	push	r13
    5fa8:	ef 92       	push	r14
    5faa:	ff 92       	push	r15
    5fac:	0f 93       	push	r16
    5fae:	1f 93       	push	r17
    5fb0:	df 93       	push	r29
    5fb2:	cf 93       	push	r28
    5fb4:	cd b7       	in	r28, 0x3d	; 61
    5fb6:	de b7       	in	r29, 0x3e	; 62
    5fb8:	62 97       	sbiw	r28, 0x12	; 18
    5fba:	0f b6       	in	r0, 0x3f	; 63
    5fbc:	f8 94       	cli
    5fbe:	de bf       	out	0x3e, r29	; 62
    5fc0:	0f be       	out	0x3f, r0	; 63
    5fc2:	cd bf       	out	0x3d, r28	; 61
     char strVernum[6],strVerdate[12];
	 sprintf_P(strVernum,PSTR(VERSION_NUM));
    5fc4:	00 d0       	rcall	.+0      	; 0x5fc6 <GeneratePrintInit+0x22>
    5fc6:	00 d0       	rcall	.+0      	; 0x5fc8 <GeneratePrintInit+0x24>
    5fc8:	6e 01       	movw	r12, r28
    5fca:	08 94       	sec
    5fcc:	c1 1c       	adc	r12, r1
    5fce:	d1 1c       	adc	r13, r1
    5fd0:	ad b7       	in	r26, 0x3d	; 61
    5fd2:	be b7       	in	r27, 0x3e	; 62
    5fd4:	12 96       	adiw	r26, 0x02	; 2
    5fd6:	dc 92       	st	X, r13
    5fd8:	ce 92       	st	-X, r12
    5fda:	11 97       	sbiw	r26, 0x01	; 1
    5fdc:	84 e3       	ldi	r24, 0x34	; 52
    5fde:	9d e1       	ldi	r25, 0x1D	; 29
    5fe0:	14 96       	adiw	r26, 0x04	; 4
    5fe2:	9c 93       	st	X, r25
    5fe4:	8e 93       	st	-X, r24
    5fe6:	13 97       	sbiw	r26, 0x03	; 3
    5fe8:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
	 sprintf_P(strVerdate,PSTR(VERSION_DATE));
    5fec:	37 e0       	ldi	r19, 0x07	; 7
    5fee:	e3 2e       	mov	r14, r19
    5ff0:	f1 2c       	mov	r15, r1
    5ff2:	ec 0e       	add	r14, r28
    5ff4:	fd 1e       	adc	r15, r29
    5ff6:	ed b7       	in	r30, 0x3d	; 61
    5ff8:	fe b7       	in	r31, 0x3e	; 62
    5ffa:	f2 82       	std	Z+2, r15	; 0x02
    5ffc:	e1 82       	std	Z+1, r14	; 0x01
    5ffe:	89 e2       	ldi	r24, 0x29	; 41
    6000:	9d e1       	ldi	r25, 0x1D	; 29
    6002:	94 83       	std	Z+4, r25	; 0x04
    6004:	83 83       	std	Z+3, r24	; 0x03
    6006:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
     sprintf_P(PrintBuffer,PSTR("\nGeNiUs Ticket Printer \n Version:%s\n Last Update %s \n Hanindo Automation Solutions \n www.hanindogroup.com\n\n\n\n\n\n\n\n"),strVernum,strVerdate);
    600a:	00 d0       	rcall	.+0      	; 0x600c <GeneratePrintInit+0x68>
    600c:	00 d0       	rcall	.+0      	; 0x600e <GeneratePrintInit+0x6a>
    600e:	ed b7       	in	r30, 0x3d	; 61
    6010:	fe b7       	in	r31, 0x3e	; 62
    6012:	31 96       	adiw	r30, 0x01	; 1
    6014:	0f ec       	ldi	r16, 0xCF	; 207
    6016:	15 e0       	ldi	r17, 0x05	; 5
    6018:	ad b7       	in	r26, 0x3d	; 61
    601a:	be b7       	in	r27, 0x3e	; 62
    601c:	12 96       	adiw	r26, 0x02	; 2
    601e:	1c 93       	st	X, r17
    6020:	0e 93       	st	-X, r16
    6022:	11 97       	sbiw	r26, 0x01	; 1
    6024:	87 eb       	ldi	r24, 0xB7	; 183
    6026:	9c e1       	ldi	r25, 0x1C	; 28
    6028:	93 83       	std	Z+3, r25	; 0x03
    602a:	82 83       	std	Z+2, r24	; 0x02
    602c:	d5 82       	std	Z+5, r13	; 0x05
    602e:	c4 82       	std	Z+4, r12	; 0x04
    6030:	f7 82       	std	Z+7, r15	; 0x07
    6032:	e6 82       	std	Z+6, r14	; 0x06
    6034:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
	 _uart_print(0,1,PrintBuffer);
    6038:	ed b7       	in	r30, 0x3d	; 61
    603a:	fe b7       	in	r31, 0x3e	; 62
    603c:	38 96       	adiw	r30, 0x08	; 8
    603e:	0f b6       	in	r0, 0x3f	; 63
    6040:	f8 94       	cli
    6042:	fe bf       	out	0x3e, r31	; 62
    6044:	0f be       	out	0x3f, r0	; 63
    6046:	ed bf       	out	0x3d, r30	; 61
    6048:	80 e0       	ldi	r24, 0x00	; 0
    604a:	61 e0       	ldi	r22, 0x01	; 1
    604c:	a8 01       	movw	r20, r16
    604e:	0e 94 97 b2 	call	0x1652e	; 0x1652e <_uart_print>
	 LengthMessage81=strlen(PrintBuffer);
    6052:	f8 01       	movw	r30, r16
    6054:	01 90       	ld	r0, Z+
    6056:	00 20       	and	r0, r0
    6058:	e9 f7       	brne	.-6      	; 0x6054 <GeneratePrintInit+0xb0>
    605a:	31 97       	sbiw	r30, 0x01	; 1
    605c:	e0 1b       	sub	r30, r16
    605e:	f1 0b       	sbc	r31, r17
    6060:	f0 93 a1 01 	sts	0x01A1, r31
    6064:	e0 93 a0 01 	sts	0x01A0, r30
	 //Spooling HFCx 0000
	 cmdPrint=0b00010000|(1<<PRN_PAPER_CUT);
    6068:	80 e3       	ldi	r24, 0x30	; 48
    606a:	80 93 cb 01 	sts	0x01CB, r24
	 IsFreePrinting=True;
    606e:	81 e0       	ldi	r24, 0x01	; 1
    6070:	80 93 bf 01 	sts	0x01BF, r24
}
    6074:	62 96       	adiw	r28, 0x12	; 18
    6076:	0f b6       	in	r0, 0x3f	; 63
    6078:	f8 94       	cli
    607a:	de bf       	out	0x3e, r29	; 62
    607c:	0f be       	out	0x3f, r0	; 63
    607e:	cd bf       	out	0x3d, r28	; 61
    6080:	cf 91       	pop	r28
    6082:	df 91       	pop	r29
    6084:	1f 91       	pop	r17
    6086:	0f 91       	pop	r16
    6088:	ff 90       	pop	r15
    608a:	ef 90       	pop	r14
    608c:	df 90       	pop	r13
    608e:	cf 90       	pop	r12
    6090:	08 95       	ret

00006092 <FormatCurrency>:
     DecCfg=eeprom_read_byte(&DefDecimalTotalVolume);
	 FormatDecimal(strRawVolume,DecCfg);
}


void FormatCurrency(char *strCurrency){// 5000000.00 5,000,000.00
    6092:	9f 92       	push	r9
    6094:	af 92       	push	r10
    6096:	bf 92       	push	r11
    6098:	cf 92       	push	r12
    609a:	df 92       	push	r13
    609c:	ef 92       	push	r14
    609e:	ff 92       	push	r15
    60a0:	0f 93       	push	r16
    60a2:	1f 93       	push	r17
    60a4:	df 93       	push	r29
    60a6:	cf 93       	push	r28
    60a8:	cd b7       	in	r28, 0x3d	; 61
    60aa:	de b7       	in	r29, 0x3e	; 62
    60ac:	64 97       	sbiw	r28, 0x14	; 20
    60ae:	0f b6       	in	r0, 0x3f	; 63
    60b0:	f8 94       	cli
    60b2:	de bf       	out	0x3e, r29	; 62
    60b4:	0f be       	out	0x3f, r0	; 63
    60b6:	cd bf       	out	0x3d, r28	; 61
    60b8:	6c 01       	movw	r12, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    60ba:	e1 99       	sbic	0x1c, 1	; 28
    60bc:	fe cf       	rjmp	.-4      	; 0x60ba <FormatCurrency+0x28>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    60be:	8f e3       	ldi	r24, 0x3F	; 63
    60c0:	90 e0       	ldi	r25, 0x00	; 0
    60c2:	9f bb       	out	0x1f, r25	; 31
    60c4:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    60c6:	e0 9a       	sbi	0x1c, 0	; 28
    60c8:	9d b2       	in	r9, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    60ca:	e1 99       	sbic	0x1c, 1	; 28
    60cc:	fe cf       	rjmp	.-4      	; 0x60ca <FormatCurrency+0x38>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    60ce:	8e e3       	ldi	r24, 0x3E	; 62
    60d0:	90 e0       	ldi	r25, 0x00	; 0
    60d2:	9f bb       	out	0x1f, r25	; 31
    60d4:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    60d6:	e0 9a       	sbi	0x1c, 0	; 28
    60d8:	3d b3       	in	r19, 0x1d	; 29
	 char CurrencyMark,DecimalMark;

	 CurrencyMark=eeprom_read_byte(&DefCurrencyMark);
	 DecimalMark=eeprom_read_byte(&DefDecimalMark);

	 Length=strlen(strCurrency);//123,456
    60da:	f6 01       	movw	r30, r12
    60dc:	01 90       	ld	r0, Z+
    60de:	00 20       	and	r0, r0
    60e0:	e9 f7       	brne	.-6      	; 0x60dc <FormatCurrency+0x4a>
    60e2:	31 97       	sbiw	r30, 0x01	; 1
    60e4:	ee 2e       	mov	r14, r30
    60e6:	ec 18       	sub	r14, r12
    60e8:	fe 01       	movw	r30, r28
    60ea:	31 96       	adiw	r30, 0x01	; 1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    60ec:	ce 01       	movw	r24, r28
    60ee:	45 96       	adiw	r24, 0x15	; 21
	     strMemory[i]=data;
    60f0:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    60f2:	e8 17       	cp	r30, r24
    60f4:	f9 07       	cpc	r31, r25
    60f6:	e1 f7       	brne	.-8      	; 0x60f0 <FormatCurrency+0x5e>
    60f8:	f6 01       	movw	r30, r12
    60fa:	fe 2c       	mov	r15, r14
    60fc:	80 e0       	ldi	r24, 0x00	; 0
    60fe:	20 e0       	ldi	r18, 0x00	; 0
    6100:	09 c0       	rjmp	.+18     	; 0x6114 <FormatCurrency+0x82>
	 dotPos=Length;
	 nComa=0;
	 FillChar(fmtCurrency,sizeof(fmtCurrency),0);
	 //Detection
	 for(i=0;i<Length;i++){// 123,456 
	     if (strCurrency[i]==DecimalMark) dotPos=i;//3
    6102:	90 81       	ld	r25, Z
    6104:	93 17       	cp	r25, r19
    6106:	09 f4       	brne	.+2      	; 0x610a <FormatCurrency+0x78>
    6108:	f8 2e       	mov	r15, r24
		 if (strCurrency[i]==CurrencyMark) nComa++;//0
    610a:	99 15       	cp	r25, r9
    610c:	09 f4       	brne	.+2      	; 0x6110 <FormatCurrency+0x7e>
    610e:	2f 5f       	subi	r18, 0xFF	; 255
	 Length=strlen(strCurrency);//123,456
	 dotPos=Length;
	 nComa=0;
	 FillChar(fmtCurrency,sizeof(fmtCurrency),0);
	 //Detection
	 for(i=0;i<Length;i++){// 123,456 
    6110:	8f 5f       	subi	r24, 0xFF	; 255
    6112:	31 96       	adiw	r30, 0x01	; 1
    6114:	8e 15       	cp	r24, r14
    6116:	a8 f3       	brcs	.-22     	; 0x6102 <FormatCurrency+0x70>
	     if (strCurrency[i]==DecimalMark) dotPos=i;//3
		 if (strCurrency[i]==CurrencyMark) nComa++;//0
	 }

	 if((nComa==0)&&(dotPos>3)){		 
    6118:	22 23       	and	r18, r18
    611a:	09 f0       	breq	.+2      	; 0x611e <FormatCurrency+0x8c>
    611c:	5e c0       	rjmp	.+188    	; 0x61da <FormatCurrency+0x148>
    611e:	83 e0       	ldi	r24, 0x03	; 3
    6120:	8f 15       	cp	r24, r15
    6122:	08 f0       	brcs	.+2      	; 0x6126 <FormatCurrency+0x94>
    6124:	5a c0       	rjmp	.+180    	; 0x61da <FormatCurrency+0x148>
    6126:	40 e0       	ldi	r20, 0x00	; 0
    6128:	20 e0       	ldi	r18, 0x00	; 0
    612a:	30 e0       	ldi	r19, 0x00	; 0
         iPos=0;
	     for(i=0;i<dotPos;i++){
	         if ((((dotPos-i)%3)==0)&&(i<(dotPos))&&(i>0)){ 
    612c:	af 2c       	mov	r10, r15
    612e:	bb 24       	eor	r11, r11
		        fmtCurrency[iPos]=CurrencyMark;
    6130:	8e 01       	movw	r16, r28
    6132:	0f 5f       	subi	r16, 0xFF	; 255
    6134:	1f 4f       	sbci	r17, 0xFF	; 255
	 }

	 if((nComa==0)&&(dotPos>3)){		 
         iPos=0;
	     for(i=0;i<dotPos;i++){
	         if ((((dotPos-i)%3)==0)&&(i<(dotPos))&&(i>0)){ 
    6136:	c5 01       	movw	r24, r10
    6138:	82 1b       	sub	r24, r18
    613a:	93 0b       	sbc	r25, r19
    613c:	63 e0       	ldi	r22, 0x03	; 3
    613e:	70 e0       	ldi	r23, 0x00	; 0
    6140:	0e 94 4c b7 	call	0x16e98	; 0x16e98 <__divmodhi4>
    6144:	89 2b       	or	r24, r25
    6146:	49 f4       	brne	.+18     	; 0x615a <FormatCurrency+0xc8>
    6148:	2f 15       	cp	r18, r15
    614a:	38 f4       	brcc	.+14     	; 0x615a <FormatCurrency+0xc8>
    614c:	22 23       	and	r18, r18
    614e:	29 f0       	breq	.+10     	; 0x615a <FormatCurrency+0xc8>
		        fmtCurrency[iPos]=CurrencyMark;
    6150:	f8 01       	movw	r30, r16
    6152:	e4 0f       	add	r30, r20
    6154:	f1 1d       	adc	r31, r1
    6156:	90 82       	st	Z, r9
		        iPos++;
    6158:	4f 5f       	subi	r20, 0xFF	; 255
		        }
		        fmtCurrency[iPos]=strCurrency[i];
    615a:	d8 01       	movw	r26, r16
    615c:	a4 0f       	add	r26, r20
    615e:	b1 1d       	adc	r27, r1
    6160:	f6 01       	movw	r30, r12
    6162:	e2 0f       	add	r30, r18
    6164:	f3 1f       	adc	r31, r19
    6166:	80 81       	ld	r24, Z
    6168:	8c 93       	st	X, r24
			    iPos++;
    616a:	4f 5f       	subi	r20, 0xFF	; 255
			    fmtCurrency[iPos]=0;
    616c:	f8 01       	movw	r30, r16
    616e:	e4 0f       	add	r30, r20
    6170:	f1 1d       	adc	r31, r1
    6172:	10 82       	st	Z, r1
    6174:	2f 5f       	subi	r18, 0xFF	; 255
    6176:	3f 4f       	sbci	r19, 0xFF	; 255
		 if (strCurrency[i]==CurrencyMark) nComa++;//0
	 }

	 if((nComa==0)&&(dotPos>3)){		 
         iPos=0;
	     for(i=0;i<dotPos;i++){
    6178:	2f 15       	cp	r18, r15
    617a:	e8 f2       	brcs	.-70     	; 0x6136 <FormatCurrency+0xa4>
    617c:	9f 2d       	mov	r25, r15
			    iPos++;
			    fmtCurrency[iPos]=0;
	         }
         
	     for(i=dotPos;i<Length;i++){
		        fmtCurrency[iPos]=strCurrency[i];
    617e:	9e 01       	movw	r18, r28
    6180:	2f 5f       	subi	r18, 0xFF	; 255
    6182:	3f 4f       	sbci	r19, 0xFF	; 255
    6184:	0e c0       	rjmp	.+28     	; 0x61a2 <FormatCurrency+0x110>
    6186:	d9 01       	movw	r26, r18
    6188:	a4 0f       	add	r26, r20
    618a:	b1 1d       	adc	r27, r1
    618c:	f6 01       	movw	r30, r12
    618e:	e9 0f       	add	r30, r25
    6190:	f1 1d       	adc	r31, r1
    6192:	80 81       	ld	r24, Z
    6194:	8c 93       	st	X, r24
			    iPos++;
    6196:	4f 5f       	subi	r20, 0xFF	; 255
			    fmtCurrency[iPos]=0;
    6198:	f9 01       	movw	r30, r18
    619a:	e4 0f       	add	r30, r20
    619c:	f1 1d       	adc	r31, r1
    619e:	10 82       	st	Z, r1
		        fmtCurrency[iPos]=strCurrency[i];
			    iPos++;
			    fmtCurrency[iPos]=0;
	         }
         
	     for(i=dotPos;i<Length;i++){
    61a0:	9f 5f       	subi	r25, 0xFF	; 255
    61a2:	9e 15       	cp	r25, r14
    61a4:	80 f3       	brcs	.-32     	; 0x6186 <FormatCurrency+0xf4>
    61a6:	90 e0       	ldi	r25, 0x00	; 0
		        fmtCurrency[iPos]=strCurrency[i];
			    iPos++;
			    fmtCurrency[iPos]=0;
	         }
	      for(i=0;i<strlen(fmtCurrency);i++){
    61a8:	9e 01       	movw	r18, r28
    61aa:	2f 5f       	subi	r18, 0xFF	; 255
    61ac:	3f 4f       	sbci	r19, 0xFF	; 255
    61ae:	09 c0       	rjmp	.+18     	; 0x61c2 <FormatCurrency+0x130>
	          strCurrency[i]=fmtCurrency[i];
    61b0:	f6 01       	movw	r30, r12
    61b2:	ea 0f       	add	r30, r26
    61b4:	fb 1f       	adc	r31, r27
    61b6:	a2 0f       	add	r26, r18
    61b8:	b3 1f       	adc	r27, r19
    61ba:	8c 91       	ld	r24, X
    61bc:	80 83       	st	Z, r24
			  strCurrency[i+1]=0;
    61be:	11 82       	std	Z+1, r1	; 0x01
	     for(i=dotPos;i<Length;i++){
		        fmtCurrency[iPos]=strCurrency[i];
			    iPos++;
			    fmtCurrency[iPos]=0;
	         }
	      for(i=0;i<strlen(fmtCurrency);i++){
    61c0:	9f 5f       	subi	r25, 0xFF	; 255
    61c2:	a9 2f       	mov	r26, r25
    61c4:	b0 e0       	ldi	r27, 0x00	; 0
    61c6:	f9 01       	movw	r30, r18
    61c8:	01 90       	ld	r0, Z+
    61ca:	00 20       	and	r0, r0
    61cc:	e9 f7       	brne	.-6      	; 0x61c8 <FormatCurrency+0x136>
    61ce:	31 97       	sbiw	r30, 0x01	; 1
    61d0:	e2 1b       	sub	r30, r18
    61d2:	f3 0b       	sbc	r31, r19
    61d4:	ae 17       	cp	r26, r30
    61d6:	bf 07       	cpc	r27, r31
    61d8:	58 f3       	brcs	.-42     	; 0x61b0 <FormatCurrency+0x11e>
	          strCurrency[i]=fmtCurrency[i];
			  strCurrency[i+1]=0;
	      }
     }      
}
    61da:	64 96       	adiw	r28, 0x14	; 20
    61dc:	0f b6       	in	r0, 0x3f	; 63
    61de:	f8 94       	cli
    61e0:	de bf       	out	0x3e, r29	; 62
    61e2:	0f be       	out	0x3f, r0	; 63
    61e4:	cd bf       	out	0x3d, r28	; 61
    61e6:	cf 91       	pop	r28
    61e8:	df 91       	pop	r29
    61ea:	1f 91       	pop	r17
    61ec:	0f 91       	pop	r16
    61ee:	ff 90       	pop	r15
    61f0:	ef 90       	pop	r14
    61f2:	df 90       	pop	r13
    61f4:	cf 90       	pop	r12
    61f6:	bf 90       	pop	r11
    61f8:	af 90       	pop	r10
    61fa:	9f 90       	pop	r9
    61fc:	08 95       	ret

000061fe <FormatDecimal>:

void TestLocalAccount(){

}

void FormatDecimal(char *strRawData, char DecimalCfg){// 9-> 0,009 0,234 123 
    61fe:	ef 92       	push	r14
    6200:	ff 92       	push	r15
    6202:	0f 93       	push	r16
    6204:	1f 93       	push	r17
    6206:	df 93       	push	r29
    6208:	cf 93       	push	r28
    620a:	cd b7       	in	r28, 0x3d	; 61
    620c:	de b7       	in	r29, 0x3e	; 62
    620e:	64 97       	sbiw	r28, 0x14	; 20
    6210:	0f b6       	in	r0, 0x3f	; 63
    6212:	f8 94       	cli
    6214:	de bf       	out	0x3e, r29	; 62
    6216:	0f be       	out	0x3f, r0	; 63
    6218:	cd bf       	out	0x3d, r28	; 61
    621a:	8c 01       	movw	r16, r24
     char i,iPos,CommaPos,Length=0;                 //1->0,01 
	 char strDecimalFormated[20];
	 char DecPointMark;
     if (DecimalCfg>0){    
    621c:	66 23       	and	r22, r22
    621e:	09 f4       	brne	.+2      	; 0x6222 <FormatDecimal+0x24>
    6220:	56 c0       	rjmp	.+172    	; 0x62ce <FormatDecimal+0xd0>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    6222:	e1 99       	sbic	0x1c, 1	; 28
    6224:	fe cf       	rjmp	.-4      	; 0x6222 <FormatDecimal+0x24>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    6226:	8e e3       	ldi	r24, 0x3E	; 62
    6228:	90 e0       	ldi	r25, 0x00	; 0
    622a:	9f bb       	out	0x1f, r25	; 31
    622c:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    622e:	e0 9a       	sbi	0x1c, 0	; 28
    6230:	ed b2       	in	r14, 0x1d	; 29
		 DecPointMark=eeprom_read_byte(&DefDecimalMark);	 
		 Length=strlen(strRawData);
    6232:	f8 01       	movw	r30, r16
    6234:	01 90       	ld	r0, Z+
    6236:	00 20       	and	r0, r0
    6238:	e9 f7       	brne	.-6      	; 0x6234 <FormatDecimal+0x36>
    623a:	31 97       	sbiw	r30, 0x01	; 1
    623c:	3e 2f       	mov	r19, r30
    623e:	30 1b       	sub	r19, r16

		 if (Length>DecimalCfg)CommaPos=Length-DecimalCfg;
    6240:	63 17       	cp	r22, r19
    6242:	b8 f5       	brcc	.+110    	; 0x62b2 <FormatDecimal+0xb4>
    6244:	f3 2e       	mov	r15, r19
    6246:	f6 1a       	sub	r15, r22
    6248:	b8 01       	movw	r22, r16
    624a:	d8 01       	movw	r26, r16
    624c:	20 e0       	ldi	r18, 0x00	; 0
    624e:	90 e0       	ldi	r25, 0x00	; 0

		 
		 iPos=0;
		 for(i=0;i<Length;i++){
			 if (i==CommaPos){
				 strDecimalFormated[iPos]=DecPointMark;
    6250:	ae 01       	movw	r20, r28
    6252:	4f 5f       	subi	r20, 0xFF	; 255
    6254:	5f 4f       	sbci	r21, 0xFF	; 255
    6256:	0e c0       	rjmp	.+28     	; 0x6274 <FormatDecimal+0x76>
			 }

		 
		 iPos=0;
		 for(i=0;i<Length;i++){
			 if (i==CommaPos){
    6258:	2f 15       	cp	r18, r15
    625a:	29 f4       	brne	.+10     	; 0x6266 <FormatDecimal+0x68>
				 strDecimalFormated[iPos]=DecPointMark;
    625c:	fa 01       	movw	r30, r20
    625e:	e9 0f       	add	r30, r25
    6260:	f1 1d       	adc	r31, r1
    6262:	e0 82       	st	Z, r14
				 iPos++;
    6264:	9f 5f       	subi	r25, 0xFF	; 255
			}
			strDecimalFormated[iPos]=strRawData[i];
    6266:	fa 01       	movw	r30, r20
    6268:	e9 0f       	add	r30, r25
    626a:	f1 1d       	adc	r31, r1
    626c:	8d 91       	ld	r24, X+
    626e:	80 83       	st	Z, r24
			//strDecimalFormated[iPos+1]=0;
			iPos++;
    6270:	9f 5f       	subi	r25, 0xFF	; 255
			 CommaPos=1;
			 }

		 
		 iPos=0;
		 for(i=0;i<Length;i++){
    6272:	2f 5f       	subi	r18, 0xFF	; 255
    6274:	23 17       	cp	r18, r19
    6276:	80 f3       	brcs	.-32     	; 0x6258 <FormatDecimal+0x5a>
				 iPos++;
			}
			strDecimalFormated[iPos]=strRawData[i];
			//strDecimalFormated[iPos+1]=0;
			iPos++;
		 }strDecimalFormated[iPos]=0;
    6278:	9e 01       	movw	r18, r28
    627a:	2f 5f       	subi	r18, 0xFF	; 255
    627c:	3f 4f       	sbci	r19, 0xFF	; 255
    627e:	f9 01       	movw	r30, r18
    6280:	e9 0f       	add	r30, r25
    6282:	f1 1d       	adc	r31, r1
    6284:	10 82       	st	Z, r1
		 
         //_uart_print(1,1,strDecimalFormated); 

		 Length=strlen(strDecimalFormated);
    6286:	f9 01       	movw	r30, r18
    6288:	01 90       	ld	r0, Z+
    628a:	00 20       	and	r0, r0
    628c:	e9 f7       	brne	.-6      	; 0x6288 <FormatDecimal+0x8a>
    628e:	31 97       	sbiw	r30, 0x01	; 1
    6290:	9e 2f       	mov	r25, r30
    6292:	92 1b       	sub	r25, r18
    6294:	d9 01       	movw	r26, r18
    6296:	04 c0       	rjmp	.+8      	; 0x62a0 <FormatDecimal+0xa2>
		 for(i=0;i<Length;i++){
			 strRawData[i]=strDecimalFormated[i];
    6298:	8d 91       	ld	r24, X+
    629a:	fb 01       	movw	r30, r22
    629c:	81 93       	st	Z+, r24
    629e:	bf 01       	movw	r22, r30
		 }strDecimalFormated[iPos]=0;
		 
         //_uart_print(1,1,strDecimalFormated); 

		 Length=strlen(strDecimalFormated);
		 for(i=0;i<Length;i++){
    62a0:	8a 2f       	mov	r24, r26
    62a2:	82 1b       	sub	r24, r18
    62a4:	89 17       	cp	r24, r25
    62a6:	c0 f3       	brcs	.-16     	; 0x6298 <FormatDecimal+0x9a>
			 strRawData[i]=strDecimalFormated[i];
		 }strRawData[Length]=0;
    62a8:	09 0f       	add	r16, r25
    62aa:	11 1d       	adc	r17, r1
    62ac:	f8 01       	movw	r30, r16
    62ae:	10 82       	st	Z, r1
    62b0:	0e c0       	rjmp	.+28     	; 0x62ce <FormatDecimal+0xd0>
		 if (Length>DecimalCfg)CommaPos=Length-DecimalCfg;
		 else CommaPos=1;


		 if (Length<=DecimalCfg){// 123 -> 0123
			 AddZeroLead(strRawData,(DecimalCfg+1));
    62b2:	6f 5f       	subi	r22, 0xFF	; 255
    62b4:	c8 01       	movw	r24, r16
    62b6:	0e 94 5b 25 	call	0x4ab6	; 0x4ab6 <AddZeroLead>
			 //AddZeroLead(strRawData,(DecimalCfg+2));
			 Length=strlen(strRawData);
    62ba:	f8 01       	movw	r30, r16
    62bc:	01 90       	ld	r0, Z+
    62be:	00 20       	and	r0, r0
    62c0:	e9 f7       	brne	.-6      	; 0x62bc <FormatDecimal+0xbe>
    62c2:	31 97       	sbiw	r30, 0x01	; 1
    62c4:	3e 2f       	mov	r19, r30
    62c6:	30 1b       	sub	r19, r16
    62c8:	ff 24       	eor	r15, r15
    62ca:	f3 94       	inc	r15
    62cc:	bd cf       	rjmp	.-134    	; 0x6248 <FormatDecimal+0x4a>
		 for(i=0;i<Length;i++){
			 strRawData[i]=strDecimalFormated[i];
		 }strRawData[Length]=0;
	 }
          //_uart_print(1,1,strRawData); 
}
    62ce:	64 96       	adiw	r28, 0x14	; 20
    62d0:	0f b6       	in	r0, 0x3f	; 63
    62d2:	f8 94       	cli
    62d4:	de bf       	out	0x3e, r29	; 62
    62d6:	0f be       	out	0x3f, r0	; 63
    62d8:	cd bf       	out	0x3d, r28	; 61
    62da:	cf 91       	pop	r28
    62dc:	df 91       	pop	r29
    62de:	1f 91       	pop	r17
    62e0:	0f 91       	pop	r16
    62e2:	ff 90       	pop	r15
    62e4:	ef 90       	pop	r14
    62e6:	08 95       	ret

000062e8 <NormalizeDecimal>:
	 Result=(SigmaSum%255);
	 if (Result==0)Result=255;
   return Result;
}

void NormalizeDecimal(char CurrentDecimal, char NewDecimal, char *Result){// 01234567,89
    62e8:	68 2f       	mov	r22, r24
    62ea:	ca 01       	movw	r24, r20
		 StrPosCopy(Result,SResult,DeltaDec,Length-DeltaDec);
		 	           
	 
     }
*/
     FormatDecimal(Result,CurrentDecimal);
    62ec:	0e 94 ff 30 	call	0x61fe	; 0x61fe <FormatDecimal>
}
    62f0:	08 95       	ret

000062f2 <FormatTotalizerVolume>:
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalTotalMoney);
	 FormatDecimal(strRawMoney,DecCfg);
}

void FormatTotalizerVolume(char *strRawVolume){//96->0,96 
    62f2:	9c 01       	movw	r18, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    62f4:	e1 99       	sbic	0x1c, 1	; 28
    62f6:	fe cf       	rjmp	.-4      	; 0x62f4 <FormatTotalizerVolume+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    62f8:	8c e3       	ldi	r24, 0x3C	; 60
    62fa:	90 e0       	ldi	r25, 0x00	; 0
    62fc:	9f bb       	out	0x1f, r25	; 31
    62fe:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    6300:	e0 9a       	sbi	0x1c, 0	; 28
    6302:	6d b3       	in	r22, 0x1d	; 29
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalTotalVolume);
	 FormatDecimal(strRawVolume,DecCfg);
    6304:	c9 01       	movw	r24, r18
    6306:	0e 94 ff 30 	call	0x61fe	; 0x61fe <FormatDecimal>
}
    630a:	08 95       	ret

0000630c <FormatTotalizerMoney>:
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalVolume);
	 FormatDecimal(strRawVolume,DecCfg);
}

void FormatTotalizerMoney(char *strRawMoney){
    630c:	9c 01       	movw	r18, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    630e:	e1 99       	sbic	0x1c, 1	; 28
    6310:	fe cf       	rjmp	.-4      	; 0x630e <FormatTotalizerMoney+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    6312:	8d e3       	ldi	r24, 0x3D	; 61
    6314:	90 e0       	ldi	r25, 0x00	; 0
    6316:	9f bb       	out	0x1f, r25	; 31
    6318:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    631a:	e0 9a       	sbi	0x1c, 0	; 28
    631c:	6d b3       	in	r22, 0x1d	; 29
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalTotalMoney);
	 FormatDecimal(strRawMoney,DecCfg);
    631e:	c9 01       	movw	r24, r18
    6320:	0e 94 ff 30 	call	0x61fe	; 0x61fe <FormatDecimal>
}
    6324:	08 95       	ret

00006326 <FormatVolume>:
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalMoney);
	 FormatDecimal(strRawMoney,DecCfg);
}

void FormatVolume(char *strRawVolume){//96->0,96 
    6326:	9c 01       	movw	r18, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    6328:	e1 99       	sbic	0x1c, 1	; 28
    632a:	fe cf       	rjmp	.-4      	; 0x6328 <FormatVolume+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    632c:	8a e3       	ldi	r24, 0x3A	; 58
    632e:	90 e0       	ldi	r25, 0x00	; 0
    6330:	9f bb       	out	0x1f, r25	; 31
    6332:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    6334:	e0 9a       	sbi	0x1c, 0	; 28
    6336:	6d b3       	in	r22, 0x1d	; 29
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalVolume);
	 FormatDecimal(strRawVolume,DecCfg);
    6338:	c9 01       	movw	r24, r18
    633a:	0e 94 ff 30 	call	0x61fe	; 0x61fe <FormatDecimal>
}
    633e:	08 95       	ret

00006340 <FormatMoney>:
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalPrice);
	 FormatDecimal(strRawPrice,DecCfg);
}

void FormatMoney(char *strRawMoney){
    6340:	9c 01       	movw	r18, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    6342:	e1 99       	sbic	0x1c, 1	; 28
    6344:	fe cf       	rjmp	.-4      	; 0x6342 <FormatMoney+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    6346:	8b e3       	ldi	r24, 0x3B	; 59
    6348:	90 e0       	ldi	r25, 0x00	; 0
    634a:	9f bb       	out	0x1f, r25	; 31
    634c:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    634e:	e0 9a       	sbi	0x1c, 0	; 28
    6350:	6d b3       	in	r22, 0x1d	; 29
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalMoney);
	 FormatDecimal(strRawMoney,DecCfg);
    6352:	c9 01       	movw	r24, r18
    6354:	0e 94 ff 30 	call	0x61fe	; 0x61fe <FormatDecimal>
}
    6358:	08 95       	ret

0000635a <FormatPrice>:
		 }strRawData[Length]=0;
	 }
          //_uart_print(1,1,strRawData); 
}

void FormatPrice(char *strRawPrice){
    635a:	9c 01       	movw	r18, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    635c:	e1 99       	sbic	0x1c, 1	; 28
    635e:	fe cf       	rjmp	.-4      	; 0x635c <FormatPrice+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    6360:	89 e3       	ldi	r24, 0x39	; 57
    6362:	90 e0       	ldi	r25, 0x00	; 0
    6364:	9f bb       	out	0x1f, r25	; 31
    6366:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    6368:	e0 9a       	sbi	0x1c, 0	; 28
    636a:	6d b3       	in	r22, 0x1d	; 29
     char DecCfg;
     DecCfg=eeprom_read_byte(&DefDecimalPrice);
	 FormatDecimal(strRawPrice,DecCfg);
    636c:	c9 01       	movw	r24, r18
    636e:	0e 94 ff 30 	call	0x61fe	; 0x61fe <FormatDecimal>
}
    6372:	08 95       	ret

00006374 <systemGenerateReport>:
	 }
}

//Spooling HFCS 0000 : Header, Footer, Copy , Scrool [Copy:16x max]
//			cmdPrint=procMessage81();
void systemGenerateReport(){
    6374:	2f 92       	push	r2
    6376:	3f 92       	push	r3
    6378:	4f 92       	push	r4
    637a:	5f 92       	push	r5
    637c:	6f 92       	push	r6
    637e:	7f 92       	push	r7
    6380:	8f 92       	push	r8
    6382:	9f 92       	push	r9
    6384:	af 92       	push	r10
    6386:	bf 92       	push	r11
    6388:	cf 92       	push	r12
    638a:	df 92       	push	r13
    638c:	ef 92       	push	r14
    638e:	ff 92       	push	r15
    6390:	0f 93       	push	r16
    6392:	1f 93       	push	r17
    6394:	df 93       	push	r29
    6396:	cf 93       	push	r28
    6398:	cd b7       	in	r28, 0x3d	; 61
    639a:	de b7       	in	r29, 0x3e	; 62
    639c:	c8 5f       	subi	r28, 0xF8	; 248
    639e:	d0 40       	sbci	r29, 0x00	; 0
    63a0:	0f b6       	in	r0, 0x3f	; 63
    63a2:	f8 94       	cli
    63a4:	de bf       	out	0x3e, r29	; 62
    63a6:	0f be       	out	0x3f, r0	; 63
    63a8:	cd bf       	out	0x3d, r28	; 61
	   char strTabSpace[20],strTabSpace2[20];
	   char iTotal;//,PadLength;
	   char sPrice[10],strProductPrice[20];
	   char FIPAddr;

     switch(stGenerateReport){
    63aa:	10 91 14 02 	lds	r17, 0x0214
    63ae:	16 30       	cpi	r17, 0x06	; 6
    63b0:	09 f4       	brne	.+2      	; 0x63b4 <systemGenerateReport+0x40>
    63b2:	5d c2       	rjmp	.+1210   	; 0x686e <systemGenerateReport+0x4fa>
    63b4:	17 30       	cpi	r17, 0x07	; 7
    63b6:	98 f4       	brcc	.+38     	; 0x63de <systemGenerateReport+0x6a>
    63b8:	12 30       	cpi	r17, 0x02	; 2
    63ba:	09 f4       	brne	.+2      	; 0x63be <systemGenerateReport+0x4a>
    63bc:	a7 c0       	rjmp	.+334    	; 0x650c <systemGenerateReport+0x198>
    63be:	13 30       	cpi	r17, 0x03	; 3
    63c0:	38 f4       	brcc	.+14     	; 0x63d0 <systemGenerateReport+0x5c>
    63c2:	11 23       	and	r17, r17
    63c4:	31 f1       	breq	.+76     	; 0x6412 <systemGenerateReport+0x9e>
    63c6:	11 30       	cpi	r17, 0x01	; 1
    63c8:	11 f0       	breq	.+4      	; 0x63ce <systemGenerateReport+0x5a>
    63ca:	0c 94 d3 3c 	jmp	0x79a6	; 0x79a6 <systemGenerateReport+0x1632>
    63ce:	2d c0       	rjmp	.+90     	; 0x642a <systemGenerateReport+0xb6>
    63d0:	14 30       	cpi	r17, 0x04	; 4
    63d2:	09 f4       	brne	.+2      	; 0x63d6 <systemGenerateReport+0x62>
    63d4:	c8 c1       	rjmp	.+912    	; 0x6766 <systemGenerateReport+0x3f2>
    63d6:	15 30       	cpi	r17, 0x05	; 5
    63d8:	08 f0       	brcs	.+2      	; 0x63dc <systemGenerateReport+0x68>
    63da:	4c c7       	rjmp	.+3736   	; 0x7274 <systemGenerateReport+0xf00>
    63dc:	bb c1       	rjmp	.+886    	; 0x6754 <systemGenerateReport+0x3e0>
    63de:	19 30       	cpi	r17, 0x09	; 9
    63e0:	09 f4       	brne	.+2      	; 0x63e4 <systemGenerateReport+0x70>
    63e2:	48 c7       	rjmp	.+3728   	; 0x7274 <systemGenerateReport+0xf00>
    63e4:	1a 30       	cpi	r17, 0x0A	; 10
    63e6:	40 f4       	brcc	.+16     	; 0x63f8 <systemGenerateReport+0x84>
    63e8:	17 30       	cpi	r17, 0x07	; 7
    63ea:	09 f4       	brne	.+2      	; 0x63ee <systemGenerateReport+0x7a>
    63ec:	aa c2       	rjmp	.+1364   	; 0x6942 <systemGenerateReport+0x5ce>
    63ee:	18 30       	cpi	r17, 0x08	; 8
    63f0:	11 f0       	breq	.+4      	; 0x63f6 <systemGenerateReport+0x82>
    63f2:	0c 94 d3 3c 	jmp	0x79a6	; 0x79a6 <systemGenerateReport+0x1632>
    63f6:	b3 c2       	rjmp	.+1382   	; 0x695e <systemGenerateReport+0x5ea>
    63f8:	1b 30       	cpi	r17, 0x0B	; 11
    63fa:	11 f4       	brne	.+4      	; 0x6400 <systemGenerateReport+0x8c>
    63fc:	0c 94 c6 3c 	jmp	0x798c	; 0x798c <systemGenerateReport+0x1618>
    6400:	1b 30       	cpi	r17, 0x0B	; 11
    6402:	08 f4       	brcc	.+2      	; 0x6406 <systemGenerateReport+0x92>
    6404:	3e c7       	rjmp	.+3708   	; 0x7282 <systemGenerateReport+0xf0e>
    6406:	1c 30       	cpi	r17, 0x0C	; 12
    6408:	11 f0       	breq	.+4      	; 0x640e <systemGenerateReport+0x9a>
    640a:	0c 94 d3 3c 	jmp	0x79a6	; 0x79a6 <systemGenerateReport+0x1632>
    640e:	0c 94 ce 3c 	jmp	0x799c	; 0x799c <systemGenerateReport+0x1628>
	 case grScanAction://Wait for Complete incoming Totalizer data	      
		  if (IsGenerateReport==True){
    6412:	80 91 99 01 	lds	r24, 0x0199
    6416:	81 30       	cpi	r24, 0x01	; 1
    6418:	11 f0       	breq	.+4      	; 0x641e <systemGenerateReport+0xaa>
    641a:	0c 94 d3 3c 	jmp	0x79a6	; 0x79a6 <systemGenerateReport+0x1632>
		      IsGenerateReport=False;
    641e:	10 92 99 01 	sts	0x0199, r1
			  IsFinishPrintingTotalizer=False;
    6422:	10 92 9a 01 	sts	0x019A, r1
    6426:	0c 94 cb 3c 	jmp	0x7996	; 0x7996 <systemGenerateReport+0x1622>
			  stGenerateReport=grInitData;
		  }
	      break;
	 case grInitData:
	      xPump=1;
    642a:	10 93 13 02 	sts	0x0213, r17
		  xNozzle=1;
    642e:	10 93 12 02 	sts	0x0212, r17
		  RepPos=0;
    6432:	10 92 03 02 	sts	0x0203, r1
    6436:	10 92 02 02 	sts	0x0202, r1
    643a:	ef ec       	ldi	r30, 0xCF	; 207
    643c:	f5 e0       	ldi	r31, 0x05	; 5
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    643e:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    6440:	87 e0       	ldi	r24, 0x07	; 7
    6442:	e0 36       	cpi	r30, 0x60	; 96
    6444:	f8 07       	cpc	r31, r24
    6446:	d9 f7       	brne	.-10     	; 0x643e <systemGenerateReport+0xca>
    6448:	fe 01       	movw	r30, r28
    644a:	eb 55       	subi	r30, 0x5B	; 91
    644c:	ff 4f       	sbci	r31, 0xFF	; 255
	     strMemory[i]=data;
    644e:	ce 01       	movw	r24, r28
    6450:	8b 50       	subi	r24, 0x0B	; 11
    6452:	9f 4f       	sbci	r25, 0xFF	; 255
    6454:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    6456:	e8 17       	cp	r30, r24
    6458:	f9 07       	cpc	r31, r25
    645a:	e1 f7       	brne	.-8      	; 0x6454 <systemGenerateReport+0xe0>
    645c:	fe 01       	movw	r30, r28
    645e:	f7 96       	adiw	r30, 0x37	; 55
	     strMemory[i]=data;
    6460:	cf 01       	movw	r24, r30
    6462:	0f 96       	adiw	r24, 0x0f	; 15
    6464:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    6466:	e8 17       	cp	r30, r24
    6468:	f9 07       	cpc	r31, r25
    646a:	e1 f7       	brne	.-8      	; 0x6464 <systemGenerateReport+0xf0>
    646c:	fe 01       	movw	r30, r28
    646e:	ea 5b       	subi	r30, 0xBA	; 186
    6470:	ff 4f       	sbci	r31, 0xFF	; 255
	     strMemory[i]=data;
    6472:	cf 01       	movw	r24, r30
    6474:	0f 96       	adiw	r24, 0x0f	; 15
    6476:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    6478:	e8 17       	cp	r30, r24
    647a:	f9 07       	cpc	r31, r25
    647c:	e1 f7       	brne	.-8      	; 0x6476 <systemGenerateReport+0x102>
    647e:	ec ef       	ldi	r30, 0xFC	; 252
    6480:	f9 e0       	ldi	r31, 0x09	; 9
	     strMemory[i]=data;
    6482:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    6484:	9a e0       	ldi	r25, 0x0A	; 10
    6486:	e0 31       	cpi	r30, 0x10	; 16
    6488:	f9 07       	cpc	r31, r25
    648a:	d9 f7       	brne	.-10     	; 0x6482 <systemGenerateReport+0x10e>
    648c:	ed ea       	ldi	r30, 0xAD	; 173
    648e:	fa e0       	ldi	r31, 0x0A	; 10
	     strMemory[i]=data;
    6490:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    6492:	aa e0       	ldi	r26, 0x0A	; 10
    6494:	e1 3c       	cpi	r30, 0xC1	; 193
    6496:	fa 07       	cpc	r31, r26
    6498:	d9 f7       	brne	.-10     	; 0x6490 <systemGenerateReport+0x11c>
    649a:	e8 e0       	ldi	r30, 0x08	; 8
    649c:	fe e0       	ldi	r31, 0x0E	; 14
	     strMemory[i]=data;
    649e:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    64a0:	be e0       	ldi	r27, 0x0E	; 14
    64a2:	e7 31       	cpi	r30, 0x17	; 23
    64a4:	fb 07       	cpc	r31, r27
    64a6:	d9 f7       	brne	.-10     	; 0x649e <systemGenerateReport+0x12a>
    64a8:	ed ed       	ldi	r30, 0xDD	; 221
    64aa:	fa e0       	ldi	r31, 0x0A	; 10
	     strMemory[i]=data;
    64ac:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    64ae:	8a e0       	ldi	r24, 0x0A	; 10
    64b0:	ec 3e       	cpi	r30, 0xEC	; 236
    64b2:	f8 07       	cpc	r31, r24
    64b4:	d9 f7       	brne	.-10     	; 0x64ac <systemGenerateReport+0x138>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    64b6:	e1 99       	sbic	0x1c, 1	; 28
    64b8:	fe cf       	rjmp	.-4      	; 0x64b6 <systemGenerateReport+0x142>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    64ba:	8f e3       	ldi	r24, 0x3F	; 63
    64bc:	91 e0       	ldi	r25, 0x01	; 1
    64be:	9f bb       	out	0x1f, r25	; 31
    64c0:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    64c2:	e0 9a       	sbi	0x1c, 0	; 28
    64c4:	2d b3       	in	r18, 0x1d	; 29
		  FillChar(strTotalMoney,sizeof(strTotalMoney),0);


		  FillChar(strDeltaMoney,sizeof(strDeltaMoney),0);
		  FillChar(strDeltaVolume,sizeof(strDeltaVolume),0);
		  sprintf_P(strShift,PSTR("%d"),eeprom_read_byte(&DefShift));
    64c6:	00 d0       	rcall	.+0      	; 0x64c8 <systemGenerateReport+0x154>
    64c8:	00 d0       	rcall	.+0      	; 0x64ca <systemGenerateReport+0x156>
    64ca:	00 d0       	rcall	.+0      	; 0x64cc <systemGenerateReport+0x158>
    64cc:	ed b7       	in	r30, 0x3d	; 61
    64ce:	fe b7       	in	r31, 0x3e	; 62
    64d0:	31 96       	adiw	r30, 0x01	; 1
    64d2:	83 e4       	ldi	r24, 0x43	; 67
    64d4:	9e e0       	ldi	r25, 0x0E	; 14
    64d6:	ad b7       	in	r26, 0x3d	; 61
    64d8:	be b7       	in	r27, 0x3e	; 62
    64da:	12 96       	adiw	r26, 0x02	; 2
    64dc:	9c 93       	st	X, r25
    64de:	8e 93       	st	-X, r24
    64e0:	11 97       	sbiw	r26, 0x01	; 1
    64e2:	8b e9       	ldi	r24, 0x9B	; 155
    64e4:	95 e0       	ldi	r25, 0x05	; 5
    64e6:	93 83       	std	Z+3, r25	; 0x03
    64e8:	82 83       	std	Z+2, r24	; 0x02
    64ea:	24 83       	std	Z+4, r18	; 0x04
    64ec:	15 82       	std	Z+5, r1	; 0x05
    64ee:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>

          stGenerateReport=grCreateReportHeader;
    64f2:	82 e0       	ldi	r24, 0x02	; 2
    64f4:	80 93 14 02 	sts	0x0214, r24
    64f8:	ed b7       	in	r30, 0x3d	; 61
    64fa:	fe b7       	in	r31, 0x3e	; 62
    64fc:	36 96       	adiw	r30, 0x06	; 6
    64fe:	0f b6       	in	r0, 0x3f	; 63
    6500:	f8 94       	cli
    6502:	fe bf       	out	0x3e, r31	; 62
    6504:	0f be       	out	0x3f, r0	; 63
    6506:	ed bf       	out	0x3d, r30	; 61
    6508:	0c 94 d3 3c 	jmp	0x79a6	; 0x79a6 <systemGenerateReport+0x1632>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    650c:	ce 01       	movw	r24, r28
    650e:	8b 5a       	subi	r24, 0xAB	; 171
    6510:	9f 4f       	sbci	r25, 0xFF	; 255
    6512:	63 e4       	ldi	r22, 0x43	; 67
    6514:	78 e0       	ldi	r23, 0x08	; 8
    6516:	44 e1       	ldi	r20, 0x14	; 20
    6518:	50 e0       	ldi	r21, 0x00	; 0
    651a:	23 ef       	ldi	r18, 0xF3	; 243
    651c:	32 e1       	ldi	r19, 0x12	; 18
    651e:	0e 94 1f b4 	call	0x1683e	; 0x1683e <__eerd_block>
	      break;
	 case grCreateReportHeader://Border: btTopLeft,btTopCenter,btTopRight,btMiddleLeft,btMiddleCenter,btMiddleRight,btBottomLeft,btBottomCenter,btBottomRight,btVertical,btHorizontal
		  eeprom_read_block((void*) &LastShiftDateTime, (const void*) &DefLastShiftDateTime, sizeof(DefLastShiftDateTime));
          
		  InserBorder(btTopLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btTopRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);
    6522:	81 e0       	ldi	r24, 0x01	; 1
    6524:	6f ec       	ldi	r22, 0xCF	; 207
    6526:	75 e0       	ldi	r23, 0x05	; 5
    6528:	41 e0       	ldi	r20, 0x01	; 1
    652a:	22 e0       	ldi	r18, 0x02	; 2
    652c:	32 e0       	ldi	r19, 0x02	; 2
    652e:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <InserBorder>
    6532:	8b e0       	ldi	r24, 0x0B	; 11
    6534:	6f ec       	ldi	r22, 0xCF	; 207
    6536:	75 e0       	ldi	r23, 0x05	; 5
    6538:	4a e2       	ldi	r20, 0x2A	; 42
    653a:	22 e0       	ldi	r18, 0x02	; 2
    653c:	32 e0       	ldi	r19, 0x02	; 2
    653e:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <InserBorder>
    6542:	83 e0       	ldi	r24, 0x03	; 3
    6544:	6f ec       	ldi	r22, 0xCF	; 207
    6546:	75 e0       	ldi	r23, 0x05	; 5
    6548:	41 e0       	ldi	r20, 0x01	; 1
    654a:	22 e0       	ldi	r18, 0x02	; 2
    654c:	32 e0       	ldi	r19, 0x02	; 2
    654e:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <InserBorder>
    6552:	8c e0       	ldi	r24, 0x0C	; 12
    6554:	6f ec       	ldi	r22, 0xCF	; 207
    6556:	75 e0       	ldi	r23, 0x05	; 5
    6558:	41 e0       	ldi	r20, 0x01	; 1
    655a:	22 e0       	ldi	r18, 0x02	; 2
    655c:	32 e0       	ldi	r19, 0x02	; 2
    655e:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <InserBorder>
	      sprintf_P(strReport,PSTR("        Laporan Tutup Shift: %s      "),strShift);CreateReport(strReport,PrintBuffer,&RepPos);
    6562:	00 d0       	rcall	.+0      	; 0x6564 <systemGenerateReport+0x1f0>
    6564:	00 d0       	rcall	.+0      	; 0x6566 <systemGenerateReport+0x1f2>
    6566:	00 d0       	rcall	.+0      	; 0x6568 <systemGenerateReport+0x1f4>
    6568:	ed b7       	in	r30, 0x3d	; 61
    656a:	fe b7       	in	r31, 0x3e	; 62
    656c:	31 96       	adiw	r30, 0x01	; 1
    656e:	8e 01       	movw	r16, r28
    6570:	0b 55       	subi	r16, 0x5B	; 91
    6572:	1f 4f       	sbci	r17, 0xFF	; 255
    6574:	ad b7       	in	r26, 0x3d	; 61
    6576:	be b7       	in	r27, 0x3e	; 62
    6578:	12 96       	adiw	r26, 0x02	; 2
    657a:	1c 93       	st	X, r17
    657c:	0e 93       	st	-X, r16
    657e:	11 97       	sbiw	r26, 0x01	; 1
    6580:	85 e7       	ldi	r24, 0x75	; 117
    6582:	95 e0       	ldi	r25, 0x05	; 5
    6584:	93 83       	std	Z+3, r25	; 0x03
    6586:	82 83       	std	Z+2, r24	; 0x02
    6588:	83 e4       	ldi	r24, 0x43	; 67
    658a:	9e e0       	ldi	r25, 0x0E	; 14
    658c:	95 83       	std	Z+5, r25	; 0x05
    658e:	84 83       	std	Z+4, r24	; 0x04
    6590:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    6594:	ed b7       	in	r30, 0x3d	; 61
    6596:	fe b7       	in	r31, 0x3e	; 62
    6598:	36 96       	adiw	r30, 0x06	; 6
    659a:	0f b6       	in	r0, 0x3f	; 63
    659c:	f8 94       	cli
    659e:	fe bf       	out	0x3e, r31	; 62
    65a0:	0f be       	out	0x3f, r0	; 63
    65a2:	ed bf       	out	0x3d, r30	; 61
    65a4:	c8 01       	movw	r24, r16
    65a6:	6f ec       	ldi	r22, 0xCF	; 207
    65a8:	75 e0       	ldi	r23, 0x05	; 5
    65aa:	42 e0       	ldi	r20, 0x02	; 2
    65ac:	52 e0       	ldi	r21, 0x02	; 2
    65ae:	0e 94 ad 20 	call	0x415a	; 0x415a <CreateReport>
		  InserBorder(btMiddleLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btMiddleRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);     
    65b2:	84 e0       	ldi	r24, 0x04	; 4
    65b4:	6f ec       	ldi	r22, 0xCF	; 207
    65b6:	75 e0       	ldi	r23, 0x05	; 5
    65b8:	41 e0       	ldi	r20, 0x01	; 1
    65ba:	22 e0       	ldi	r18, 0x02	; 2
    65bc:	32 e0       	ldi	r19, 0x02	; 2
    65be:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <InserBorder>
    65c2:	8b e0       	ldi	r24, 0x0B	; 11
    65c4:	6f ec       	ldi	r22, 0xCF	; 207
    65c6:	75 e0       	ldi	r23, 0x05	; 5
    65c8:	4a e2       	ldi	r20, 0x2A	; 42
    65ca:	22 e0       	ldi	r18, 0x02	; 2
    65cc:	32 e0       	ldi	r19, 0x02	; 2
    65ce:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <InserBorder>
    65d2:	86 e0       	ldi	r24, 0x06	; 6
    65d4:	6f ec       	ldi	r22, 0xCF	; 207
    65d6:	75 e0       	ldi	r23, 0x05	; 5
    65d8:	41 e0       	ldi	r20, 0x01	; 1
    65da:	22 e0       	ldi	r18, 0x02	; 2
    65dc:	32 e0       	ldi	r19, 0x02	; 2
    65de:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <InserBorder>
    65e2:	8c e0       	ldi	r24, 0x0C	; 12
    65e4:	6f ec       	ldi	r22, 0xCF	; 207
    65e6:	75 e0       	ldi	r23, 0x05	; 5
    65e8:	41 e0       	ldi	r20, 0x01	; 1
    65ea:	22 e0       	ldi	r18, 0x02	; 2
    65ec:	32 e0       	ldi	r19, 0x02	; 2
    65ee:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <InserBorder>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    65f2:	e1 99       	sbic	0x1c, 1	; 28
    65f4:	fe cf       	rjmp	.-4      	; 0x65f2 <systemGenerateReport+0x27e>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    65f6:	80 e0       	ldi	r24, 0x00	; 0
    65f8:	90 e0       	ldi	r25, 0x00	; 0
    65fa:	9f bb       	out	0x1f, r25	; 31
    65fc:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    65fe:	e0 9a       	sbi	0x1c, 0	; 28
    6600:	2d b3       	in	r18, 0x1d	; 29
	      sprintf_P(strReport,PSTR("Terminal ID : %.2d                   "),eeprom_read_byte(&DefIFT_ID));CreateReport(strReport,PrintBuffer,&RepPos);
    6602:	00 d0       	rcall	.+0      	; 0x6604 <systemGenerateReport+0x290>
    6604:	00 d0       	rcall	.+0      	; 0x6606 <systemGenerateReport+0x292>
    6606:	00 d0       	rcall	.+0      	; 0x6608 <systemGenerateReport+0x294>
    6608:	ed b7       	in	r30, 0x3d	; 61
    660a:	fe b7       	in	r31, 0x3e	; 62
    660c:	31 96       	adiw	r30, 0x01	; 1
    660e:	8e 01       	movw	r16, r28
    6610:	0b 55       	subi	r16, 0x5B	; 91
    6612:	1f 4f       	sbci	r17, 0xFF	; 255
    6614:	ad b7       	in	r26, 0x3d	; 61
    6616:	be b7       	in	r27, 0x3e	; 62
    6618:	12 96       	adiw	r26, 0x02	; 2
    661a:	1c 93       	st	X, r17
    661c:	0e 93       	st	-X, r16
    661e:	11 97       	sbiw	r26, 0x01	; 1
    6620:	8f e4       	ldi	r24, 0x4F	; 79
    6622:	95 e0       	ldi	r25, 0x05	; 5
    6624:	93 83       	std	Z+3, r25	; 0x03
    6626:	82 83       	std	Z+2, r24	; 0x02
    6628:	24 83       	std	Z+4, r18	; 0x04
    662a:	15 82       	std	Z+5, r1	; 0x05
    662c:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    6630:	ed b7       	in	r30, 0x3d	; 61
    6632:	fe b7       	in	r31, 0x3e	; 62
    6634:	36 96       	adiw	r30, 0x06	; 6
    6636:	0f b6       	in	r0, 0x3f	; 63
    6638:	f8 94       	cli
    663a:	fe bf       	out	0x3e, r31	; 62
    663c:	0f be       	out	0x3f, r0	; 63
    663e:	ed bf       	out	0x3d, r30	; 61
    6640:	c8 01       	movw	r24, r16
    6642:	6f ec       	ldi	r22, 0xCF	; 207
    6644:	75 e0       	ldi	r23, 0x05	; 5
    6646:	42 e0       	ldi	r20, 0x02	; 2
    6648:	52 e0       	ldi	r21, 0x02	; 2
    664a:	0e 94 ad 20 	call	0x415a	; 0x415a <CreateReport>
	      sprintf_P(strReport,PSTR("Awal  Shift : %s "),LastShiftDateTime);             CreateReport(strReport,PrintBuffer,&RepPos);
    664e:	00 d0       	rcall	.+0      	; 0x6650 <systemGenerateReport+0x2dc>
    6650:	00 d0       	rcall	.+0      	; 0x6652 <systemGenerateReport+0x2de>
    6652:	00 d0       	rcall	.+0      	; 0x6654 <systemGenerateReport+0x2e0>
    6654:	ed b7       	in	r30, 0x3d	; 61
    6656:	fe b7       	in	r31, 0x3e	; 62
    6658:	31 96       	adiw	r30, 0x01	; 1
    665a:	ad b7       	in	r26, 0x3d	; 61
    665c:	be b7       	in	r27, 0x3e	; 62
    665e:	12 96       	adiw	r26, 0x02	; 2
    6660:	1c 93       	st	X, r17
    6662:	0e 93       	st	-X, r16
    6664:	11 97       	sbiw	r26, 0x01	; 1
    6666:	8d e3       	ldi	r24, 0x3D	; 61
    6668:	95 e0       	ldi	r25, 0x05	; 5
    666a:	93 83       	std	Z+3, r25	; 0x03
    666c:	82 83       	std	Z+2, r24	; 0x02
    666e:	ce 01       	movw	r24, r28
    6670:	8b 5a       	subi	r24, 0xAB	; 171
    6672:	9f 4f       	sbci	r25, 0xFF	; 255
    6674:	95 83       	std	Z+5, r25	; 0x05
    6676:	84 83       	std	Z+4, r24	; 0x04
    6678:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    667c:	ed b7       	in	r30, 0x3d	; 61
    667e:	fe b7       	in	r31, 0x3e	; 62
    6680:	36 96       	adiw	r30, 0x06	; 6
    6682:	0f b6       	in	r0, 0x3f	; 63
    6684:	f8 94       	cli
    6686:	fe bf       	out	0x3e, r31	; 62
    6688:	0f be       	out	0x3f, r0	; 63
    668a:	ed bf       	out	0x3d, r30	; 61
    668c:	c8 01       	movw	r24, r16
    668e:	6f ec       	ldi	r22, 0xCF	; 207
    6690:	75 e0       	ldi	r23, 0x05	; 5
    6692:	42 e0       	ldi	r20, 0x02	; 2
    6694:	52 e0       	ldi	r21, 0x02	; 2
    6696:	0e 94 ad 20 	call	0x415a	; 0x415a <CreateReport>
	      sprintf_P(strReport,PSTR("Akhir Shift : %s "),CurrentShiftDateTime);      CreateReport(strReport,PrintBuffer,&RepPos);
    669a:	00 d0       	rcall	.+0      	; 0x669c <systemGenerateReport+0x328>
    669c:	00 d0       	rcall	.+0      	; 0x669e <systemGenerateReport+0x32a>
    669e:	00 d0       	rcall	.+0      	; 0x66a0 <systemGenerateReport+0x32c>
    66a0:	ed b7       	in	r30, 0x3d	; 61
    66a2:	fe b7       	in	r31, 0x3e	; 62
    66a4:	31 96       	adiw	r30, 0x01	; 1
    66a6:	ad b7       	in	r26, 0x3d	; 61
    66a8:	be b7       	in	r27, 0x3e	; 62
    66aa:	12 96       	adiw	r26, 0x02	; 2
    66ac:	1c 93       	st	X, r17
    66ae:	0e 93       	st	-X, r16
    66b0:	11 97       	sbiw	r26, 0x01	; 1
    66b2:	8b e2       	ldi	r24, 0x2B	; 43
    66b4:	95 e0       	ldi	r25, 0x05	; 5
    66b6:	93 83       	std	Z+3, r25	; 0x03
    66b8:	82 83       	std	Z+2, r24	; 0x02
    66ba:	81 e7       	ldi	r24, 0x71	; 113
    66bc:	99 e0       	ldi	r25, 0x09	; 9
    66be:	95 83       	std	Z+5, r25	; 0x05
    66c0:	84 83       	std	Z+4, r24	; 0x04
    66c2:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    66c6:	ed b7       	in	r30, 0x3d	; 61
    66c8:	fe b7       	in	r31, 0x3e	; 62
    66ca:	36 96       	adiw	r30, 0x06	; 6
    66cc:	0f b6       	in	r0, 0x3f	; 63
    66ce:	f8 94       	cli
    66d0:	fe bf       	out	0x3e, r31	; 62
    66d2:	0f be       	out	0x3f, r0	; 63
    66d4:	ed bf       	out	0x3d, r30	; 61
    66d6:	c8 01       	movw	r24, r16
    66d8:	6f ec       	ldi	r22, 0xCF	; 207
    66da:	75 e0       	ldi	r23, 0x05	; 5
    66dc:	42 e0       	ldi	r20, 0x02	; 2
    66de:	52 e0       	ldi	r21, 0x02	; 2
    66e0:	0e 94 ad 20 	call	0x415a	; 0x415a <CreateReport>
	      //sprintf_P(strReport,PSTR("Transaksi   : %s "),DeltaTransaction);      CreateReport(strReport,PrintBuffer,&RepPos);
          InserBorder(btBottomLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btBottomRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);
    66e4:	87 e0       	ldi	r24, 0x07	; 7
    66e6:	6f ec       	ldi	r22, 0xCF	; 207
    66e8:	75 e0       	ldi	r23, 0x05	; 5
    66ea:	41 e0       	ldi	r20, 0x01	; 1
    66ec:	22 e0       	ldi	r18, 0x02	; 2
    66ee:	32 e0       	ldi	r19, 0x02	; 2
    66f0:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <InserBorder>
    66f4:	8b e0       	ldi	r24, 0x0B	; 11
    66f6:	6f ec       	ldi	r22, 0xCF	; 207
    66f8:	75 e0       	ldi	r23, 0x05	; 5
    66fa:	4a e2       	ldi	r20, 0x2A	; 42
    66fc:	22 e0       	ldi	r18, 0x02	; 2
    66fe:	32 e0       	ldi	r19, 0x02	; 2
    6700:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <InserBorder>
    6704:	89 e0       	ldi	r24, 0x09	; 9
    6706:	6f ec       	ldi	r22, 0xCF	; 207
    6708:	75 e0       	ldi	r23, 0x05	; 5
    670a:	41 e0       	ldi	r20, 0x01	; 1
    670c:	22 e0       	ldi	r18, 0x02	; 2
    670e:	32 e0       	ldi	r19, 0x02	; 2
    6710:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <InserBorder>
    6714:	8c e0       	ldi	r24, 0x0C	; 12
    6716:	6f ec       	ldi	r22, 0xCF	; 207
    6718:	75 e0       	ldi	r23, 0x05	; 5
    671a:	41 e0       	ldi	r20, 0x01	; 1
    671c:	22 e0       	ldi	r18, 0x02	; 2
    671e:	32 e0       	ldi	r19, 0x02	; 2
    6720:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <InserBorder>
		  /*
	      if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("PUMP-PRODUCT   VOLUME(L)    RUPIAH(RP)"));         
	      else sprintf_P(strReport,PSTR("PUMP-PRODUCT   VOLUME(L)              "));CreateReport(strReport,PrintBuffer,&RepPos);
          InserBorder(btBottomLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btBottomRight,PrintBuffer,1,&RepPos);//InserBorder(btNewLine,PrintBuffer,1,&RepPos);         		 
          */
		  ClearList(GradeList);
    6724:	84 e0       	ldi	r24, 0x04	; 4
    6726:	92 e0       	ldi	r25, 0x02	; 2
    6728:	0e 94 4e 21 	call	0x429c	; 0x429c <ClearList>
		  cmdPrint=0b10000000;//PrintHeader
    672c:	80 e8       	ldi	r24, 0x80	; 128
    672e:	80 93 cb 01 	sts	0x01CB, r24
		  LengthMessage81=RepPos+1;
    6732:	80 91 02 02 	lds	r24, 0x0202
    6736:	90 91 03 02 	lds	r25, 0x0203
    673a:	01 96       	adiw	r24, 0x01	; 1
    673c:	90 93 a1 01 	sts	0x01A1, r25
    6740:	80 93 a0 01 	sts	0x01A0, r24
		  IsFreePrinting=True;
    6744:	81 e0       	ldi	r24, 0x01	; 1
    6746:	80 93 bf 01 	sts	0x01BF, r24
          IsBusyFreePrinting=True;
    674a:	80 93 ca 01 	sts	0x01CA, r24
		  		  
          stGenerateReport=grWaitPrinted1;
    674e:	83 e0       	ldi	r24, 0x03	; 3
    6750:	0c 94 cb 3c 	jmp	0x7996	; 0x7996 <systemGenerateReport+0x1622>
	      break;
     case grWaitPrinted1:
          if (IsBusyFreePrinting==False)
    6754:	80 91 ca 01 	lds	r24, 0x01CA
    6758:	88 23       	and	r24, r24
    675a:	11 f0       	breq	.+4      	; 0x6760 <systemGenerateReport+0x3ec>
    675c:	0c 94 d3 3c 	jmp	0x79a6	; 0x79a6 <systemGenerateReport+0x1632>
		      stGenerateReport=grGenerateLabel;//grGenerateReportData;//grFinishGenerateReport;
    6760:	84 e0       	ldi	r24, 0x04	; 4
    6762:	0c 94 cb 3c 	jmp	0x7996	; 0x7996 <systemGenerateReport+0x1622>
	      break;
     case grGenerateLabel:
          RepPos=0;
    6766:	10 92 03 02 	sts	0x0203, r1
    676a:	10 92 02 02 	sts	0x0202, r1
          InserBorder(btTopLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btTopRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          
    676e:	81 e0       	ldi	r24, 0x01	; 1
    6770:	6f ec       	ldi	r22, 0xCF	; 207
    6772:	75 e0       	ldi	r23, 0x05	; 5
    6774:	41 e0       	ldi	r20, 0x01	; 1
    6776:	22 e0       	ldi	r18, 0x02	; 2
    6778:	32 e0       	ldi	r19, 0x02	; 2
    677a:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <InserBorder>
    677e:	8b e0       	ldi	r24, 0x0B	; 11
    6780:	6f ec       	ldi	r22, 0xCF	; 207
    6782:	75 e0       	ldi	r23, 0x05	; 5
    6784:	4a e2       	ldi	r20, 0x2A	; 42
    6786:	22 e0       	ldi	r18, 0x02	; 2
    6788:	32 e0       	ldi	r19, 0x02	; 2
    678a:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <InserBorder>
    678e:	83 e0       	ldi	r24, 0x03	; 3
    6790:	6f ec       	ldi	r22, 0xCF	; 207
    6792:	75 e0       	ldi	r23, 0x05	; 5
    6794:	41 e0       	ldi	r20, 0x01	; 1
    6796:	22 e0       	ldi	r18, 0x02	; 2
    6798:	32 e0       	ldi	r19, 0x02	; 2
    679a:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <InserBorder>
    679e:	8c e0       	ldi	r24, 0x0C	; 12
    67a0:	6f ec       	ldi	r22, 0xCF	; 207
    67a2:	75 e0       	ldi	r23, 0x05	; 5
    67a4:	41 e0       	ldi	r20, 0x01	; 1
    67a6:	22 e0       	ldi	r18, 0x02	; 2
    67a8:	32 e0       	ldi	r19, 0x02	; 2
    67aa:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <InserBorder>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    67ae:	e1 99       	sbic	0x1c, 1	; 28
    67b0:	fe cf       	rjmp	.-4      	; 0x67ae <systemGenerateReport+0x43a>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    67b2:	81 ec       	ldi	r24, 0xC1	; 193
    67b4:	93 e0       	ldi	r25, 0x03	; 3
    67b6:	9f bb       	out	0x1f, r25	; 31
    67b8:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    67ba:	e0 9a       	sbi	0x1c, 0	; 28
    67bc:	8d b3       	in	r24, 0x1d	; 29
    67be:	9e 01       	movw	r18, r28
    67c0:	2b 55       	subi	r18, 0x5B	; 91
    67c2:	3f 4f       	sbci	r19, 0xFF	; 255
	      if (eeprom_read_byte(&DefPrintMoney)==True)
    67c4:	81 30       	cpi	r24, 0x01	; 1
    67c6:	79 f4       	brne	.+30     	; 0x67e6 <systemGenerateReport+0x472>
		       sprintf_P(strReport,PSTR("PUMP-PRODUCT   VOLUME(L)    RUPIAH(RP)"));         
    67c8:	00 d0       	rcall	.+0      	; 0x67ca <systemGenerateReport+0x456>
    67ca:	00 d0       	rcall	.+0      	; 0x67cc <systemGenerateReport+0x458>
    67cc:	ad b7       	in	r26, 0x3d	; 61
    67ce:	be b7       	in	r27, 0x3e	; 62
    67d0:	12 96       	adiw	r26, 0x02	; 2
    67d2:	3c 93       	st	X, r19
    67d4:	2e 93       	st	-X, r18
    67d6:	11 97       	sbiw	r26, 0x01	; 1
    67d8:	84 e0       	ldi	r24, 0x04	; 4
    67da:	95 e0       	ldi	r25, 0x05	; 5
    67dc:	14 96       	adiw	r26, 0x04	; 4
    67de:	9c 93       	st	X, r25
    67e0:	8e 93       	st	-X, r24
    67e2:	13 97       	sbiw	r26, 0x03	; 3
    67e4:	0a c0       	rjmp	.+20     	; 0x67fa <systemGenerateReport+0x486>
	      else sprintf_P(strReport,PSTR("PUMP-PRODUCT   VOLUME(L)              "));CreateReport(strReport,PrintBuffer,&RepPos);
    67e6:	00 d0       	rcall	.+0      	; 0x67e8 <systemGenerateReport+0x474>
    67e8:	00 d0       	rcall	.+0      	; 0x67ea <systemGenerateReport+0x476>
    67ea:	ed b7       	in	r30, 0x3d	; 61
    67ec:	fe b7       	in	r31, 0x3e	; 62
    67ee:	32 83       	std	Z+2, r19	; 0x02
    67f0:	21 83       	std	Z+1, r18	; 0x01
    67f2:	8d ed       	ldi	r24, 0xDD	; 221
    67f4:	94 e0       	ldi	r25, 0x04	; 4
    67f6:	94 83       	std	Z+4, r25	; 0x04
    67f8:	83 83       	std	Z+3, r24	; 0x03
    67fa:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    67fe:	0f 90       	pop	r0
    6800:	0f 90       	pop	r0
    6802:	0f 90       	pop	r0
    6804:	0f 90       	pop	r0
    6806:	ce 01       	movw	r24, r28
    6808:	8b 55       	subi	r24, 0x5B	; 91
    680a:	9f 4f       	sbci	r25, 0xFF	; 255
    680c:	6f ec       	ldi	r22, 0xCF	; 207
    680e:	75 e0       	ldi	r23, 0x05	; 5
    6810:	42 e0       	ldi	r20, 0x02	; 2
    6812:	52 e0       	ldi	r21, 0x02	; 2
    6814:	0e 94 ad 20 	call	0x415a	; 0x415a <CreateReport>
          InserBorder(btBottomLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btBottomRight,PrintBuffer,1,&RepPos);//InserBorder(btNewLine,PrintBuffer,1,&RepPos);         		 
    6818:	87 e0       	ldi	r24, 0x07	; 7
    681a:	6f ec       	ldi	r22, 0xCF	; 207
    681c:	75 e0       	ldi	r23, 0x05	; 5
    681e:	41 e0       	ldi	r20, 0x01	; 1
    6820:	22 e0       	ldi	r18, 0x02	; 2
    6822:	32 e0       	ldi	r19, 0x02	; 2
    6824:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <InserBorder>
    6828:	8b e0       	ldi	r24, 0x0B	; 11
    682a:	6f ec       	ldi	r22, 0xCF	; 207
    682c:	75 e0       	ldi	r23, 0x05	; 5
    682e:	4a e2       	ldi	r20, 0x2A	; 42
    6830:	22 e0       	ldi	r18, 0x02	; 2
    6832:	32 e0       	ldi	r19, 0x02	; 2
    6834:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <InserBorder>
    6838:	89 e0       	ldi	r24, 0x09	; 9
    683a:	6f ec       	ldi	r22, 0xCF	; 207
    683c:	75 e0       	ldi	r23, 0x05	; 5
    683e:	41 e0       	ldi	r20, 0x01	; 1
    6840:	22 e0       	ldi	r18, 0x02	; 2
    6842:	32 e0       	ldi	r19, 0x02	; 2
    6844:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <InserBorder>
          
		  cmdPrint=0b00000000;
    6848:	10 92 cb 01 	sts	0x01CB, r1
		  LengthMessage81=RepPos+1;
    684c:	80 91 02 02 	lds	r24, 0x0202
    6850:	90 91 03 02 	lds	r25, 0x0203
    6854:	01 96       	adiw	r24, 0x01	; 1
    6856:	90 93 a1 01 	sts	0x01A1, r25
    685a:	80 93 a0 01 	sts	0x01A0, r24

		  IsFreePrinting=True;
    685e:	81 e0       	ldi	r24, 0x01	; 1
    6860:	80 93 bf 01 	sts	0x01BF, r24
	      IsBusyFreePrinting=True;
    6864:	80 93 ca 01 	sts	0x01CA, r24

		  stGenerateReport=grWaitLabelPrinted;
    6868:	85 e0       	ldi	r24, 0x05	; 5
    686a:	0c 94 cb 3c 	jmp	0x7996	; 0x7996 <systemGenerateReport+0x1622>
          if (IsBusyFreePrinting==False)
		      stGenerateReport=grGenerateReportData;//grFinishGenerateReport;
	      break;
     case grGenerateReportData:
	      //Generate: PumpNum, Nozzle, Product
	      if ((xPump>=1)&&(xPump<=8)){
    686e:	80 91 13 02 	lds	r24, 0x0213
    6872:	81 50       	subi	r24, 0x01	; 1
    6874:	88 30       	cpi	r24, 0x08	; 8
    6876:	10 f0       	brcs	.+4      	; 0x687c <systemGenerateReport+0x508>
    6878:	0c 94 d3 3c 	jmp	0x79a6	; 0x79a6 <systemGenerateReport+0x1632>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    687c:	ce 01       	movw	r24, r28
    687e:	07 96       	adiw	r24, 0x07	; 7
    6880:	65 e4       	ldi	r22, 0x45	; 69
    6882:	70 e0       	ldi	r23, 0x00	; 0
    6884:	48 e0       	ldi	r20, 0x08	; 8
    6886:	50 e0       	ldi	r21, 0x00	; 0
    6888:	23 ef       	ldi	r18, 0xF3	; 243
    688a:	32 e1       	ldi	r19, 0x12	; 18
    688c:	0e 94 1f b4 	call	0x1683e	; 0x1683e <__eerd_block>
		      eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap, 8);
			  PumpNum=PPumpID[xPump-1];
    6890:	90 91 13 02 	lds	r25, 0x0213
    6894:	fe 01       	movw	r30, r28
    6896:	e9 0f       	add	r30, r25
    6898:	f1 1d       	adc	r31, r1
    689a:	86 81       	ldd	r24, Z+6	; 0x06
    689c:	80 93 10 02 	sts	0x0210, r24
			  if (PumpNum>0){
    68a0:	88 23       	and	r24, r24
    68a2:	09 f4       	brne	.+2      	; 0x68a6 <systemGenerateReport+0x532>
    68a4:	4b c0       	rjmp	.+150    	; 0x693c <systemGenerateReport+0x5c8>
    68a6:	91 9f       	mul	r25, r17
    68a8:	b0 01       	movw	r22, r0
    68aa:	11 24       	eor	r1, r1
    68ac:	61 5b       	subi	r22, 0xB1	; 177
    68ae:	7f 4f       	sbci	r23, 0xFF	; 255
    68b0:	ce 01       	movw	r24, r28
    68b2:	01 96       	adiw	r24, 0x01	; 1
    68b4:	46 e0       	ldi	r20, 0x06	; 6
    68b6:	50 e0       	ldi	r21, 0x00	; 0
    68b8:	23 ef       	ldi	r18, 0xF3	; 243
    68ba:	32 e1       	ldi	r19, 0x12	; 18
    68bc:	0e 94 1f b4 	call	0x1683e	; 0x1683e <__eerd_block>
				  eeprom_read_block((void*) &PProductID, (const void*) &DefNozzleMap[xPump-1], 6);
				  xGrade=PProductID[xNozzle-1];
    68c0:	80 91 12 02 	lds	r24, 0x0212
    68c4:	fe 01       	movw	r30, r28
    68c6:	e8 0f       	add	r30, r24
    68c8:	f1 1d       	adc	r31, r1
    68ca:	80 81       	ld	r24, Z
    68cc:	80 93 11 02 	sts	0x0211, r24
    68d0:	61 e4       	ldi	r22, 0x41	; 65
    68d2:	c6 2e       	mov	r12, r22
    68d4:	69 e0       	ldi	r22, 0x09	; 9
    68d6:	d6 2e       	mov	r13, r22

				  if (xGrade>0){
    68d8:	88 23       	and	r24, r24
    68da:	99 f0       	breq	.+38     	; 0x6902 <systemGenerateReport+0x58e>
				      GetProductName(xGrade,strProduct);
    68dc:	b6 01       	movw	r22, r12
    68de:	0e 94 f3 2a 	call	0x55e6	; 0x55e6 <GetProductName>
                      GradeUsed=xGrade;
    68e2:	80 91 11 02 	lds	r24, 0x0211
    68e6:	80 93 0e 02 	sts	0x020E, r24
					  xGrade=xNozzle;//
    68ea:	80 91 12 02 	lds	r24, 0x0212
    68ee:	80 93 11 02 	sts	0x0211, r24
					  PumpNozzle=xNozzle;
    68f2:	80 93 0f 02 	sts	0x020F, r24
					  xNozzle++;
    68f6:	8f 5f       	subi	r24, 0xFF	; 255
    68f8:	80 93 12 02 	sts	0x0212, r24
					  stGenerateReport=grCreateReportTotalizer;
    68fc:	88 e0       	ldi	r24, 0x08	; 8
    68fe:	0c 94 cb 3c 	jmp	0x7996	; 0x7996 <systemGenerateReport+0x1622>
				  }
				  else{sprintf_P(strProduct,PSTR("N/A"));			  
    6902:	00 d0       	rcall	.+0      	; 0x6904 <systemGenerateReport+0x590>
    6904:	00 d0       	rcall	.+0      	; 0x6906 <systemGenerateReport+0x592>
    6906:	ad b7       	in	r26, 0x3d	; 61
    6908:	be b7       	in	r27, 0x3e	; 62
    690a:	12 96       	adiw	r26, 0x02	; 2
    690c:	dc 92       	st	X, r13
    690e:	ce 92       	st	-X, r12
    6910:	11 97       	sbiw	r26, 0x01	; 1
    6912:	89 ed       	ldi	r24, 0xD9	; 217
    6914:	94 e0       	ldi	r25, 0x04	; 4
    6916:	14 96       	adiw	r26, 0x04	; 4
    6918:	9c 93       	st	X, r25
    691a:	8e 93       	st	-X, r24
    691c:	13 97       	sbiw	r26, 0x03	; 3
    691e:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
					   xNozzle++;
    6922:	80 91 12 02 	lds	r24, 0x0212
    6926:	8f 5f       	subi	r24, 0xFF	; 255
    6928:	80 93 12 02 	sts	0x0212, r24
					   if (xNozzle>6)stGenerateReport=grNextPump;
    692c:	0f 90       	pop	r0
    692e:	0f 90       	pop	r0
    6930:	0f 90       	pop	r0
    6932:	0f 90       	pop	r0
    6934:	87 30       	cpi	r24, 0x07	; 7
    6936:	10 f4       	brcc	.+4      	; 0x693c <systemGenerateReport+0x5c8>
    6938:	0c 94 d3 3c 	jmp	0x79a6	; 0x79a6 <systemGenerateReport+0x1632>
					  }
				}else stGenerateReport=grNextPump;
    693c:	87 e0       	ldi	r24, 0x07	; 7
    693e:	0c 94 cb 3c 	jmp	0x7996	; 0x7996 <systemGenerateReport+0x1622>
			  }
	      break;
     case grNextPump:
	      xNozzle=1;
    6942:	81 e0       	ldi	r24, 0x01	; 1
    6944:	80 93 12 02 	sts	0x0212, r24
	      xPump++;
    6948:	80 91 13 02 	lds	r24, 0x0213
    694c:	8f 5f       	subi	r24, 0xFF	; 255
    694e:	80 93 13 02 	sts	0x0213, r24
	      if (xPump>8)stGenerateReport=grCreateReportFooter;
    6952:	89 30       	cpi	r24, 0x09	; 9
    6954:	08 f4       	brcc	.+2      	; 0x6958 <systemGenerateReport+0x5e4>
    6956:	93 c4       	rjmp	.+2342   	; 0x727e <systemGenerateReport+0xf0a>
    6958:	8a e0       	ldi	r24, 0x0A	; 10
    695a:	0c 94 cb 3c 	jmp	0x7996	; 0x7996 <systemGenerateReport+0x1622>
		  else stGenerateReport=grGenerateReportData;
	      break;
     case grCreateReportTotalizer:

          RepPos=0;
    695e:	10 92 03 02 	sts	0x0203, r1
    6962:	10 92 02 02 	sts	0x0202, r1
    6966:	ef ec       	ldi	r30, 0xCF	; 207
    6968:	f5 e0       	ldi	r31, 0x05	; 5
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    696a:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    696c:	b7 e0       	ldi	r27, 0x07	; 7
    696e:	e0 36       	cpi	r30, 0x60	; 96
    6970:	fb 07       	cpc	r31, r27
    6972:	d9 f7       	brne	.-10     	; 0x696a <systemGenerateReport+0x5f6>
    6974:	fe 01       	movw	r30, r28
    6976:	eb 55       	subi	r30, 0x5B	; 91
    6978:	ff 4f       	sbci	r31, 0xFF	; 255
	     strMemory[i]=data;
    697a:	ce 01       	movw	r24, r28
    697c:	8b 50       	subi	r24, 0x0B	; 11
    697e:	9f 4f       	sbci	r25, 0xFF	; 255
    6980:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    6982:	e8 17       	cp	r30, r24
    6984:	f9 07       	cpc	r31, r25
    6986:	e1 f7       	brne	.-8      	; 0x6980 <systemGenerateReport+0x60c>
    6988:	e8 e0       	ldi	r30, 0x08	; 8
    698a:	fe e0       	ldi	r31, 0x0E	; 14
	     strMemory[i]=data;
    698c:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    698e:	8e e0       	ldi	r24, 0x0E	; 14
    6990:	e7 31       	cpi	r30, 0x17	; 23
    6992:	f8 07       	cpc	r31, r24
    6994:	d9 f7       	brne	.-10     	; 0x698c <systemGenerateReport+0x618>
    6996:	ed ed       	ldi	r30, 0xDD	; 221
    6998:	fa e0       	ldi	r31, 0x0A	; 10
	     strMemory[i]=data;
    699a:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    699c:	9a e0       	ldi	r25, 0x0A	; 10
    699e:	ec 3e       	cpi	r30, 0xEC	; 236
    69a0:	f9 07       	cpc	r31, r25
    69a2:	d9 f7       	brne	.-10     	; 0x699a <systemGenerateReport+0x626>
    69a4:	fe 01       	movw	r30, r28
    69a6:	79 96       	adiw	r30, 0x19	; 25
	     strMemory[i]=data;
    69a8:	ce 01       	movw	r24, r28
    69aa:	88 96       	adiw	r24, 0x28	; 40
    69ac:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    69ae:	e8 17       	cp	r30, r24
    69b0:	f9 07       	cpc	r31, r25
    69b2:	e1 f7       	brne	.-8      	; 0x69ac <systemGenerateReport+0x638>
	     strMemory[i]=data;
    69b4:	ce 01       	movw	r24, r28
    69b6:	c7 96       	adiw	r24, 0x37	; 55
    69b8:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    69ba:	e8 17       	cp	r30, r24
    69bc:	f9 07       	cpc	r31, r25
    69be:	e1 f7       	brne	.-8      	; 0x69b8 <systemGenerateReport+0x644>
	     strMemory[i]=data;
    69c0:	cf 01       	movw	r24, r30
    69c2:	0f 96       	adiw	r24, 0x0f	; 15
    69c4:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    69c6:	e8 17       	cp	r30, r24
    69c8:	f9 07       	cpc	r31, r25
    69ca:	e1 f7       	brne	.-8      	; 0x69c4 <systemGenerateReport+0x650>
    69cc:	fe 01       	movw	r30, r28
    69ce:	ea 5b       	subi	r30, 0xBA	; 186
    69d0:	ff 4f       	sbci	r31, 0xFF	; 255
	     strMemory[i]=data;
    69d2:	cf 01       	movw	r24, r30
    69d4:	ee 2e       	mov	r14, r30
    69d6:	d9 2e       	mov	r13, r25
    69d8:	0f 96       	adiw	r24, 0x0f	; 15
    69da:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    69dc:	e8 17       	cp	r30, r24
    69de:	f9 07       	cpc	r31, r25
    69e0:	e1 f7       	brne	.-8      	; 0x69da <systemGenerateReport+0x666>
		  FillChar(strLastMoney,sizeof(strLastMoney),0);

		  FillChar(strCurrentVolume,sizeof(strCurrentVolume),0);
		  FillChar(strCurrentMoney,sizeof(strCurrentMoney),0);

          FIPAddr=GetFIPAddr(PumpNum); 
    69e2:	80 91 10 02 	lds	r24, 0x0210
    69e6:	0e 94 39 1c 	call	0x3872	; 0x3872 <GetFIPAddr>
		  if (FIPAddr>0){
    69ea:	88 23       	and	r24, r24
    69ec:	49 f1       	breq	.+82     	; 0x6a40 <systemGenerateReport+0x6cc>
		      FIPAddr=FIPAddr-1;		  
    69ee:	f8 2e       	mov	r15, r24
    69f0:	fa 94       	dec	r15
			  GetTotalizerData(TVOLUME,TOTALIZER_LAST,FIPAddr,PumpNozzle,strLastVolume);
    69f2:	80 e0       	ldi	r24, 0x00	; 0
    69f4:	60 e0       	ldi	r22, 0x00	; 0
    69f6:	4f 2d       	mov	r20, r15
    69f8:	20 91 0f 02 	lds	r18, 0x020F
    69fc:	8e 01       	movw	r16, r28
    69fe:	07 5e       	subi	r16, 0xE7	; 231
    6a00:	1f 4f       	sbci	r17, 0xFF	; 255
    6a02:	0e 94 f8 1c 	call	0x39f0	; 0x39f0 <GetTotalizerData>
			  GetTotalizerData(TMONEY,TOTALIZER_LAST,FIPAddr,PumpNozzle,strLastMoney);
    6a06:	81 e0       	ldi	r24, 0x01	; 1
    6a08:	60 e0       	ldi	r22, 0x00	; 0
    6a0a:	4f 2d       	mov	r20, r15
    6a0c:	20 91 0f 02 	lds	r18, 0x020F
    6a10:	8e 01       	movw	r16, r28
    6a12:	08 5d       	subi	r16, 0xD8	; 216
    6a14:	1f 4f       	sbci	r17, 0xFF	; 255
    6a16:	0e 94 f8 1c 	call	0x39f0	; 0x39f0 <GetTotalizerData>

			  GetTotalizerData(TVOLUME,TOTALIZER_NOW,FIPAddr,PumpNozzle,strCurrentVolume);
    6a1a:	80 e0       	ldi	r24, 0x00	; 0
    6a1c:	61 e0       	ldi	r22, 0x01	; 1
    6a1e:	4f 2d       	mov	r20, r15
    6a20:	20 91 0f 02 	lds	r18, 0x020F
    6a24:	8e 01       	movw	r16, r28
    6a26:	09 5c       	subi	r16, 0xC9	; 201
    6a28:	1f 4f       	sbci	r17, 0xFF	; 255
    6a2a:	0e 94 f8 1c 	call	0x39f0	; 0x39f0 <GetTotalizerData>
			  GetTotalizerData(TMONEY,TOTALIZER_NOW,FIPAddr,PumpNozzle,strCurrentMoney);
    6a2e:	81 e0       	ldi	r24, 0x01	; 1
    6a30:	61 e0       	ldi	r22, 0x01	; 1
    6a32:	4f 2d       	mov	r20, r15
    6a34:	20 91 0f 02 	lds	r18, 0x020F
    6a38:	0e 2d       	mov	r16, r14
    6a3a:	1d 2d       	mov	r17, r13
    6a3c:	0e 94 f8 1c 	call	0x39f0	; 0x39f0 <GetTotalizerData>
		  }

		  StrCalc(TMINUS,strCurrentVolume,strLastVolume,strDeltaVolume);
    6a40:	80 e0       	ldi	r24, 0x00	; 0
    6a42:	be 01       	movw	r22, r28
    6a44:	69 5c       	subi	r22, 0xC9	; 201
    6a46:	7f 4f       	sbci	r23, 0xFF	; 255
    6a48:	ae 01       	movw	r20, r28
    6a4a:	47 5e       	subi	r20, 0xE7	; 231
    6a4c:	5f 4f       	sbci	r21, 0xFF	; 255
    6a4e:	2d ed       	ldi	r18, 0xDD	; 221
    6a50:	3a e0       	ldi	r19, 0x0A	; 10
    6a52:	0e 94 8b 26 	call	0x4d16	; 0x4d16 <StrCalc>

		  if (IsMinus(strDeltaVolume)==True)
    6a56:	8d ed       	ldi	r24, 0xDD	; 221
    6a58:	9a e0       	ldi	r25, 0x0A	; 10
    6a5a:	0e 94 12 22 	call	0x4424	; 0x4424 <IsMinus>
    6a5e:	81 30       	cpi	r24, 0x01	; 1
    6a60:	21 f4       	brne	.+8      	; 0x6a6a <systemGenerateReport+0x6f6>
		      NormalizeOverflow(strDeltaVolume);
    6a62:	8d ed       	ldi	r24, 0xDD	; 221
    6a64:	9a e0       	ldi	r25, 0x0A	; 10
    6a66:	0e 94 22 2a 	call	0x5444	; 0x5444 <NormalizeOverflow>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    6a6a:	e1 99       	sbic	0x1c, 1	; 28
    6a6c:	fe cf       	rjmp	.-4      	; 0x6a6a <systemGenerateReport+0x6f6>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    6a6e:	57 e3       	ldi	r21, 0x37	; 55
    6a70:	85 2e       	mov	r8, r21
    6a72:	51 e0       	ldi	r21, 0x01	; 1
    6a74:	95 2e       	mov	r9, r21
    6a76:	9f ba       	out	0x1f, r9	; 31
    6a78:	8e ba       	out	0x1e, r8	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    6a7a:	e0 9a       	sbi	0x1c, 0	; 28
    6a7c:	8d b3       	in	r24, 0x1d	; 29

		  //Calculate Wayne Estimated Total Money
		  if (eeprom_read_byte(&DefDispenserBrand)==ST_WAYNE_DART){
    6a7e:	82 30       	cpi	r24, 0x02	; 2
    6a80:	79 f4       	brne	.+30     	; 0x6aa0 <systemGenerateReport+0x72c>
              GetProductPrice(sPrice,PumpNum,PumpNozzle);//Money = Price x Volume
    6a82:	8e 01       	movw	r16, r28
    6a84:	01 5f       	subi	r16, 0xF1	; 241
    6a86:	1f 4f       	sbci	r17, 0xFF	; 255
    6a88:	c8 01       	movw	r24, r16
    6a8a:	60 91 10 02 	lds	r22, 0x0210
    6a8e:	40 91 0f 02 	lds	r20, 0x020F
    6a92:	0e 94 f5 22 	call	0x45ea	; 0x45ea <GetProductPrice>
			  StrCalc(TMULTIPLY,sPrice,strDeltaVolume,strDeltaMoney);
    6a96:	82 e0       	ldi	r24, 0x02	; 2
    6a98:	b8 01       	movw	r22, r16
    6a9a:	4d ed       	ldi	r20, 0xDD	; 221
    6a9c:	5a e0       	ldi	r21, 0x0A	; 10
    6a9e:	07 c0       	rjmp	.+14     	; 0x6aae <systemGenerateReport+0x73a>
			  
		  }else StrCalc(TMINUS,strCurrentMoney,strLastMoney,strDeltaMoney);
    6aa0:	80 e0       	ldi	r24, 0x00	; 0
    6aa2:	be 01       	movw	r22, r28
    6aa4:	6a 5b       	subi	r22, 0xBA	; 186
    6aa6:	7f 4f       	sbci	r23, 0xFF	; 255
    6aa8:	ae 01       	movw	r20, r28
    6aaa:	48 5d       	subi	r20, 0xD8	; 216
    6aac:	5f 4f       	sbci	r21, 0xFF	; 255
    6aae:	28 e0       	ldi	r18, 0x08	; 8
    6ab0:	3e e0       	ldi	r19, 0x0E	; 14
    6ab2:	0e 94 8b 26 	call	0x4d16	; 0x4d16 <StrCalc>

		  if (IsMinus(strDeltaMoney)==True)
    6ab6:	88 e0       	ldi	r24, 0x08	; 8
    6ab8:	9e e0       	ldi	r25, 0x0E	; 14
    6aba:	0e 94 12 22 	call	0x4424	; 0x4424 <IsMinus>
    6abe:	81 30       	cpi	r24, 0x01	; 1
    6ac0:	21 f4       	brne	.+8      	; 0x6aca <systemGenerateReport+0x756>
		      NormalizeOverflow(strDeltaMoney);
    6ac2:	88 e0       	ldi	r24, 0x08	; 8
    6ac4:	9e e0       	ldi	r25, 0x0E	; 14
    6ac6:	0e 94 22 2a 	call	0x5444	; 0x5444 <NormalizeOverflow>

		  AddList(GradeUsed,GradeList);
    6aca:	80 91 0e 02 	lds	r24, 0x020E
    6ace:	64 e0       	ldi	r22, 0x04	; 4
    6ad0:	72 e0       	ldi	r23, 0x02	; 2
    6ad2:	0e 94 1b 21 	call	0x4236	; 0x4236 <AddList>
		  
		  StrCalc(TPLUS,strTotalVolume,strDeltaVolume,strTotalVolume);
    6ad6:	81 e0       	ldi	r24, 0x01	; 1
    6ad8:	6c ef       	ldi	r22, 0xFC	; 252
    6ada:	79 e0       	ldi	r23, 0x09	; 9
    6adc:	4d ed       	ldi	r20, 0xDD	; 221
    6ade:	5a e0       	ldi	r21, 0x0A	; 10
    6ae0:	9b 01       	movw	r18, r22
    6ae2:	0e 94 8b 26 	call	0x4d16	; 0x4d16 <StrCalc>
		  StrCalc(TPLUS,strTotalMoney,strDeltaMoney,strTotalMoney);
    6ae6:	81 e0       	ldi	r24, 0x01	; 1
    6ae8:	6d ea       	ldi	r22, 0xAD	; 173
    6aea:	7a e0       	ldi	r23, 0x0A	; 10
    6aec:	48 e0       	ldi	r20, 0x08	; 8
    6aee:	5e e0       	ldi	r21, 0x0E	; 14
    6af0:	9b 01       	movw	r18, r22
    6af2:	0e 94 8b 26 	call	0x4d16	; 0x4d16 <StrCalc>


		  RemZeroLead(strDeltaMoney);
    6af6:	88 e0       	ldi	r24, 0x08	; 8
    6af8:	9e e0       	ldi	r25, 0x0E	; 14
    6afa:	0e 94 dd 23 	call	0x47ba	; 0x47ba <RemZeroLead>
		  RemZeroLead(strCurrentMoney);
    6afe:	46 e4       	ldi	r20, 0x46	; 70
    6b00:	c4 2e       	mov	r12, r20
    6b02:	d1 2c       	mov	r13, r1
    6b04:	cc 0e       	add	r12, r28
    6b06:	dd 1e       	adc	r13, r29
    6b08:	c6 01       	movw	r24, r12
    6b0a:	0e 94 dd 23 	call	0x47ba	; 0x47ba <RemZeroLead>
		  RemZeroLead(strLastMoney);
    6b0e:	38 e2       	ldi	r19, 0x28	; 40
    6b10:	e3 2e       	mov	r14, r19
    6b12:	f1 2c       	mov	r15, r1
    6b14:	ec 0e       	add	r14, r28
    6b16:	fd 1e       	adc	r15, r29
    6b18:	c7 01       	movw	r24, r14
    6b1a:	0e 94 dd 23 	call	0x47ba	; 0x47ba <RemZeroLead>

          RemZeroLead(strDeltaVolume);
    6b1e:	8d ed       	ldi	r24, 0xDD	; 221
    6b20:	9a e0       	ldi	r25, 0x0A	; 10
    6b22:	0e 94 dd 23 	call	0x47ba	; 0x47ba <RemZeroLead>
          RemZeroLead(strCurrentVolume);
    6b26:	27 e3       	ldi	r18, 0x37	; 55
    6b28:	a2 2e       	mov	r10, r18
    6b2a:	b1 2c       	mov	r11, r1
    6b2c:	ac 0e       	add	r10, r28
    6b2e:	bd 1e       	adc	r11, r29
    6b30:	c5 01       	movw	r24, r10
    6b32:	0e 94 dd 23 	call	0x47ba	; 0x47ba <RemZeroLead>
          RemZeroLead(strLastVolume);
    6b36:	8e 01       	movw	r16, r28
    6b38:	07 5e       	subi	r16, 0xE7	; 231
    6b3a:	1f 4f       	sbci	r17, 0xFF	; 255
    6b3c:	c8 01       	movw	r24, r16
    6b3e:	0e 94 dd 23 	call	0x47ba	; 0x47ba <RemZeroLead>

		  FormatTotalizerMoney(strDeltaMoney);
    6b42:	88 e0       	ldi	r24, 0x08	; 8
    6b44:	9e e0       	ldi	r25, 0x0E	; 14
    6b46:	0e 94 86 31 	call	0x630c	; 0x630c <FormatTotalizerMoney>
		  FormatTotalizerMoney(strCurrentMoney);
    6b4a:	c6 01       	movw	r24, r12
    6b4c:	0e 94 86 31 	call	0x630c	; 0x630c <FormatTotalizerMoney>
		  FormatTotalizerMoney(strLastMoney);
    6b50:	c7 01       	movw	r24, r14
    6b52:	0e 94 86 31 	call	0x630c	; 0x630c <FormatTotalizerMoney>

		  FormatTotalizerVolume(strDeltaVolume);
    6b56:	8d ed       	ldi	r24, 0xDD	; 221
    6b58:	9a e0       	ldi	r25, 0x0A	; 10
    6b5a:	0e 94 79 31 	call	0x62f2	; 0x62f2 <FormatTotalizerVolume>
		  FormatTotalizerVolume(strLastVolume);
    6b5e:	c8 01       	movw	r24, r16
    6b60:	0e 94 79 31 	call	0x62f2	; 0x62f2 <FormatTotalizerVolume>
		  FormatTotalizerVolume(strCurrentVolume); 
    6b64:	c5 01       	movw	r24, r10
    6b66:	0e 94 79 31 	call	0x62f2	; 0x62f2 <FormatTotalizerVolume>

          FormatCurrency(strDeltaMoney);
    6b6a:	88 e0       	ldi	r24, 0x08	; 8
    6b6c:	9e e0       	ldi	r25, 0x0E	; 14
    6b6e:	0e 94 49 30 	call	0x6092	; 0x6092 <FormatCurrency>
		  FormatCurrency(strCurrentMoney);
    6b72:	c6 01       	movw	r24, r12
    6b74:	0e 94 49 30 	call	0x6092	; 0x6092 <FormatCurrency>
		  FormatCurrency(strLastMoney);
    6b78:	c7 01       	movw	r24, r14
    6b7a:	0e 94 49 30 	call	0x6092	; 0x6092 <FormatCurrency>

		  FormatCurrency(strDeltaVolume);		  
    6b7e:	8d ed       	ldi	r24, 0xDD	; 221
    6b80:	9a e0       	ldi	r25, 0x0A	; 10
    6b82:	0e 94 49 30 	call	0x6092	; 0x6092 <FormatCurrency>
		  FormatCurrency(strLastVolume);
    6b86:	c8 01       	movw	r24, r16
    6b88:	0e 94 49 30 	call	0x6092	; 0x6092 <FormatCurrency>
          FormatCurrency(strCurrentVolume);
    6b8c:	c5 01       	movw	r24, r10
    6b8e:	0e 94 49 30 	call	0x6092	; 0x6092 <FormatCurrency>


          InserBorder(btTopLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btTopRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          
    6b92:	81 e0       	ldi	r24, 0x01	; 1
    6b94:	6f ec       	ldi	r22, 0xCF	; 207
    6b96:	75 e0       	ldi	r23, 0x05	; 5
    6b98:	41 e0       	ldi	r20, 0x01	; 1
    6b9a:	22 e0       	ldi	r18, 0x02	; 2
    6b9c:	32 e0       	ldi	r19, 0x02	; 2
    6b9e:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <InserBorder>
    6ba2:	8b e0       	ldi	r24, 0x0B	; 11
    6ba4:	6f ec       	ldi	r22, 0xCF	; 207
    6ba6:	75 e0       	ldi	r23, 0x05	; 5
    6ba8:	4a e2       	ldi	r20, 0x2A	; 42
    6baa:	22 e0       	ldi	r18, 0x02	; 2
    6bac:	32 e0       	ldi	r19, 0x02	; 2
    6bae:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <InserBorder>
    6bb2:	83 e0       	ldi	r24, 0x03	; 3
    6bb4:	6f ec       	ldi	r22, 0xCF	; 207
    6bb6:	75 e0       	ldi	r23, 0x05	; 5
    6bb8:	41 e0       	ldi	r20, 0x01	; 1
    6bba:	22 e0       	ldi	r18, 0x02	; 2
    6bbc:	32 e0       	ldi	r19, 0x02	; 2
    6bbe:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <InserBorder>
    6bc2:	8c e0       	ldi	r24, 0x0C	; 12
    6bc4:	6f ec       	ldi	r22, 0xCF	; 207
    6bc6:	75 e0       	ldi	r23, 0x05	; 5
    6bc8:	41 e0       	ldi	r20, 0x01	; 1
    6bca:	22 e0       	ldi	r18, 0x02	; 2
    6bcc:	32 e0       	ldi	r19, 0x02	; 2
    6bce:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <InserBorder>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    6bd2:	e1 99       	sbic	0x1c, 1	; 28
    6bd4:	fe cf       	rjmp	.-4      	; 0x6bd2 <systemGenerateReport+0x85e>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    6bd6:	9f ba       	out	0x1f, r9	; 31
    6bd8:	8e ba       	out	0x1e, r8	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    6bda:	e0 9a       	sbi	0x1c, 0	; 28
    6bdc:	8d b3       	in	r24, 0x1d	; 29
    6bde:	91 e4       	ldi	r25, 0x41	; 65
    6be0:	c9 2e       	mov	r12, r25
    6be2:	99 e0       	ldi	r25, 0x09	; 9
    6be4:	d9 2e       	mov	r13, r25
          if (eeprom_read_byte(&DefDispenserBrand)==ST_WAYNE_DART){
    6be6:	82 30       	cpi	r24, 0x02	; 2
    6be8:	09 f0       	breq	.+2      	; 0x6bec <systemGenerateReport+0x878>
    6bea:	84 c0       	rjmp	.+264    	; 0x6cf4 <systemGenerateReport+0x980>
		      GetProductPrice(sPrice,PumpNum,PumpNozzle);
    6bec:	0f e0       	ldi	r16, 0x0F	; 15
    6bee:	e0 2e       	mov	r14, r16
    6bf0:	f1 2c       	mov	r15, r1
    6bf2:	ec 0e       	add	r14, r28
    6bf4:	fd 1e       	adc	r15, r29
    6bf6:	c7 01       	movw	r24, r14
    6bf8:	60 91 10 02 	lds	r22, 0x0210
    6bfc:	40 91 0f 02 	lds	r20, 0x020F
    6c00:	0e 94 f5 22 	call	0x45ea	; 0x45ea <GetProductPrice>
			  sprintf_P(strProductPrice,PSTR("Harga: Rp.%s"),sPrice);
    6c04:	00 d0       	rcall	.+0      	; 0x6c06 <systemGenerateReport+0x892>
    6c06:	00 d0       	rcall	.+0      	; 0x6c08 <systemGenerateReport+0x894>
    6c08:	00 d0       	rcall	.+0      	; 0x6c0a <systemGenerateReport+0x896>
    6c0a:	ed b7       	in	r30, 0x3d	; 61
    6c0c:	fe b7       	in	r31, 0x3e	; 62
    6c0e:	31 96       	adiw	r30, 0x01	; 1
    6c10:	8e 01       	movw	r16, r28
    6c12:	0f 56       	subi	r16, 0x6F	; 111
    6c14:	1f 4f       	sbci	r17, 0xFF	; 255
    6c16:	ad b7       	in	r26, 0x3d	; 61
    6c18:	be b7       	in	r27, 0x3e	; 62
    6c1a:	12 96       	adiw	r26, 0x02	; 2
    6c1c:	1c 93       	st	X, r17
    6c1e:	0e 93       	st	-X, r16
    6c20:	11 97       	sbiw	r26, 0x01	; 1
    6c22:	8c ec       	ldi	r24, 0xCC	; 204
    6c24:	94 e0       	ldi	r25, 0x04	; 4
    6c26:	93 83       	std	Z+3, r25	; 0x03
    6c28:	82 83       	std	Z+2, r24	; 0x02
    6c2a:	f5 82       	std	Z+5, r15	; 0x05
    6c2c:	e4 82       	std	Z+4, r14	; 0x04
    6c2e:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>

		      GetTabSpace(((17+10-strlen(strProduct))-strlen(strProductPrice)),strTabSpace2);
    6c32:	d6 01       	movw	r26, r12
    6c34:	0d 90       	ld	r0, X+
    6c36:	00 20       	and	r0, r0
    6c38:	e9 f7       	brne	.-6      	; 0x6c34 <systemGenerateReport+0x8c0>
    6c3a:	11 97       	sbiw	r26, 0x01	; 1
    6c3c:	ac 19       	sub	r26, r12
    6c3e:	bd 09       	sbc	r27, r13
    6c40:	f8 01       	movw	r30, r16
    6c42:	01 90       	ld	r0, Z+
    6c44:	00 20       	and	r0, r0
    6c46:	e9 f7       	brne	.-6      	; 0x6c42 <systemGenerateReport+0x8ce>
    6c48:	31 97       	sbiw	r30, 0x01	; 1
    6c4a:	0e 1b       	sub	r16, r30
    6c4c:	0a 1b       	sub	r16, r26
    6c4e:	05 5e       	subi	r16, 0xE5	; 229
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    6c50:	ed b7       	in	r30, 0x3d	; 61
    6c52:	fe b7       	in	r31, 0x3e	; 62
    6c54:	36 96       	adiw	r30, 0x06	; 6
    6c56:	0f b6       	in	r0, 0x3f	; 63
    6c58:	f8 94       	cli
    6c5a:	fe bf       	out	0x3e, r31	; 62
    6c5c:	0f be       	out	0x3f, r0	; 63
    6c5e:	ed bf       	out	0x3d, r30	; 61
    6c60:	fe 01       	movw	r30, r28
    6c62:	e3 58       	subi	r30, 0x83	; 131
    6c64:	ff 4f       	sbci	r31, 0xFF	; 255
    6c66:	10 16       	cp	r1, r16
    6c68:	74 f4       	brge	.+28     	; 0x6c86 <systemGenerateReport+0x912>
    6c6a:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    6c6c:	90 e2       	ldi	r25, 0x20	; 32
    6c6e:	02 c0       	rjmp	.+4      	; 0x6c74 <systemGenerateReport+0x900>
    6c70:	91 93       	st	Z+, r25

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    6c72:	8f 5f       	subi	r24, 0xFF	; 255
    6c74:	80 17       	cp	r24, r16
    6c76:	e0 f3       	brcs	.-8      	; 0x6c70 <systemGenerateReport+0x8fc>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    6c78:	fe 01       	movw	r30, r28
    6c7a:	e3 58       	subi	r30, 0x83	; 131
    6c7c:	ff 4f       	sbci	r31, 0xFF	; 255
    6c7e:	e0 0f       	add	r30, r16
    6c80:	f1 1d       	adc	r31, r1
    6c82:	10 82       	st	Z, r1
    6c84:	03 c0       	rjmp	.+6      	; 0x6c8c <systemGenerateReport+0x918>
     }else{
	 strTab[0]=' ';
    6c86:	80 e2       	ldi	r24, 0x20	; 32
    6c88:	80 83       	st	Z, r24
	 strTab[1]=0;
    6c8a:	11 82       	std	Z+1, r1	; 0x01
          if (eeprom_read_byte(&DefDispenserBrand)==ST_WAYNE_DART){
		      GetProductPrice(sPrice,PumpNum,PumpNozzle);
			  sprintf_P(strProductPrice,PSTR("Harga: Rp.%s"),sPrice);

		      GetTabSpace(((17+10-strlen(strProduct))-strlen(strProductPrice)),strTabSpace2);
		      sprintf_P(strReport,PSTR("P%d.%d - %s %s %s"),PumpNum,PumpNozzle,strProduct,strTabSpace2,strProductPrice);
    6c8c:	8d b7       	in	r24, 0x3d	; 61
    6c8e:	9e b7       	in	r25, 0x3e	; 62
    6c90:	0e 97       	sbiw	r24, 0x0e	; 14
    6c92:	0f b6       	in	r0, 0x3f	; 63
    6c94:	f8 94       	cli
    6c96:	9e bf       	out	0x3e, r25	; 62
    6c98:	0f be       	out	0x3f, r0	; 63
    6c9a:	8d bf       	out	0x3d, r24	; 61
    6c9c:	ed b7       	in	r30, 0x3d	; 61
    6c9e:	fe b7       	in	r31, 0x3e	; 62
    6ca0:	31 96       	adiw	r30, 0x01	; 1
    6ca2:	ce 01       	movw	r24, r28
    6ca4:	8b 55       	subi	r24, 0x5B	; 91
    6ca6:	9f 4f       	sbci	r25, 0xFF	; 255
    6ca8:	ad b7       	in	r26, 0x3d	; 61
    6caa:	be b7       	in	r27, 0x3e	; 62
    6cac:	12 96       	adiw	r26, 0x02	; 2
    6cae:	9c 93       	st	X, r25
    6cb0:	8e 93       	st	-X, r24
    6cb2:	11 97       	sbiw	r26, 0x01	; 1
    6cb4:	8a eb       	ldi	r24, 0xBA	; 186
    6cb6:	94 e0       	ldi	r25, 0x04	; 4
    6cb8:	93 83       	std	Z+3, r25	; 0x03
    6cba:	82 83       	std	Z+2, r24	; 0x02
    6cbc:	80 91 10 02 	lds	r24, 0x0210
    6cc0:	84 83       	std	Z+4, r24	; 0x04
    6cc2:	15 82       	std	Z+5, r1	; 0x05
    6cc4:	80 91 0f 02 	lds	r24, 0x020F
    6cc8:	86 83       	std	Z+6, r24	; 0x06
    6cca:	17 82       	std	Z+7, r1	; 0x07
    6ccc:	81 e4       	ldi	r24, 0x41	; 65
    6cce:	99 e0       	ldi	r25, 0x09	; 9
    6cd0:	91 87       	std	Z+9, r25	; 0x09
    6cd2:	80 87       	std	Z+8, r24	; 0x08
    6cd4:	ce 01       	movw	r24, r28
    6cd6:	83 58       	subi	r24, 0x83	; 131
    6cd8:	9f 4f       	sbci	r25, 0xFF	; 255
    6cda:	93 87       	std	Z+11, r25	; 0x0b
    6cdc:	82 87       	std	Z+10, r24	; 0x0a
    6cde:	ce 01       	movw	r24, r28
    6ce0:	8f 56       	subi	r24, 0x6F	; 111
    6ce2:	9f 4f       	sbci	r25, 0xFF	; 255
    6ce4:	95 87       	std	Z+13, r25	; 0x0d
    6ce6:	84 87       	std	Z+12, r24	; 0x0c
    6ce8:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    6cec:	ed b7       	in	r30, 0x3d	; 61
    6cee:	fe b7       	in	r31, 0x3e	; 62
    6cf0:	3e 96       	adiw	r30, 0x0e	; 14
    6cf2:	27 c0       	rjmp	.+78     	; 0x6d42 <systemGenerateReport+0x9ce>
		  }
		  else sprintf_P(strReport,PSTR("P%d.%d - %s "),PumpNum,PumpNozzle,strProduct);
    6cf4:	8d b7       	in	r24, 0x3d	; 61
    6cf6:	9e b7       	in	r25, 0x3e	; 62
    6cf8:	0a 97       	sbiw	r24, 0x0a	; 10
    6cfa:	0f b6       	in	r0, 0x3f	; 63
    6cfc:	f8 94       	cli
    6cfe:	9e bf       	out	0x3e, r25	; 62
    6d00:	0f be       	out	0x3f, r0	; 63
    6d02:	8d bf       	out	0x3d, r24	; 61
    6d04:	ed b7       	in	r30, 0x3d	; 61
    6d06:	fe b7       	in	r31, 0x3e	; 62
    6d08:	31 96       	adiw	r30, 0x01	; 1
    6d0a:	ce 01       	movw	r24, r28
    6d0c:	8b 55       	subi	r24, 0x5B	; 91
    6d0e:	9f 4f       	sbci	r25, 0xFF	; 255
    6d10:	ad b7       	in	r26, 0x3d	; 61
    6d12:	be b7       	in	r27, 0x3e	; 62
    6d14:	12 96       	adiw	r26, 0x02	; 2
    6d16:	9c 93       	st	X, r25
    6d18:	8e 93       	st	-X, r24
    6d1a:	11 97       	sbiw	r26, 0x01	; 1
    6d1c:	8d ea       	ldi	r24, 0xAD	; 173
    6d1e:	94 e0       	ldi	r25, 0x04	; 4
    6d20:	93 83       	std	Z+3, r25	; 0x03
    6d22:	82 83       	std	Z+2, r24	; 0x02
    6d24:	80 91 10 02 	lds	r24, 0x0210
    6d28:	84 83       	std	Z+4, r24	; 0x04
    6d2a:	15 82       	std	Z+5, r1	; 0x05
    6d2c:	80 91 0f 02 	lds	r24, 0x020F
    6d30:	86 83       	std	Z+6, r24	; 0x06
    6d32:	17 82       	std	Z+7, r1	; 0x07
    6d34:	d1 86       	std	Z+9, r13	; 0x09
    6d36:	c0 86       	std	Z+8, r12	; 0x08
    6d38:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    6d3c:	ed b7       	in	r30, 0x3d	; 61
    6d3e:	fe b7       	in	r31, 0x3e	; 62
    6d40:	3a 96       	adiw	r30, 0x0a	; 10
    6d42:	0f b6       	in	r0, 0x3f	; 63
    6d44:	f8 94       	cli
    6d46:	fe bf       	out	0x3e, r31	; 62
    6d48:	0f be       	out	0x3f, r0	; 63
    6d4a:	ed bf       	out	0x3d, r30	; 61
		  CreateReport(strReport,PrintBuffer,&RepPos);
    6d4c:	ce 01       	movw	r24, r28
    6d4e:	8b 55       	subi	r24, 0x5B	; 91
    6d50:	9f 4f       	sbci	r25, 0xFF	; 255
    6d52:	6f ec       	ldi	r22, 0xCF	; 207
    6d54:	75 e0       	ldi	r23, 0x05	; 5
    6d56:	42 e0       	ldi	r20, 0x02	; 2
    6d58:	52 e0       	ldi	r21, 0x02	; 2
    6d5a:	0e 94 ad 20 	call	0x415a	; 0x415a <CreateReport>
          InserBorder(btMiddleLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btMiddleRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          
    6d5e:	84 e0       	ldi	r24, 0x04	; 4
    6d60:	6f ec       	ldi	r22, 0xCF	; 207
    6d62:	75 e0       	ldi	r23, 0x05	; 5
    6d64:	41 e0       	ldi	r20, 0x01	; 1
    6d66:	22 e0       	ldi	r18, 0x02	; 2
    6d68:	32 e0       	ldi	r19, 0x02	; 2
    6d6a:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <InserBorder>
    6d6e:	8b e0       	ldi	r24, 0x0B	; 11
    6d70:	6f ec       	ldi	r22, 0xCF	; 207
    6d72:	75 e0       	ldi	r23, 0x05	; 5
    6d74:	4a e2       	ldi	r20, 0x2A	; 42
    6d76:	22 e0       	ldi	r18, 0x02	; 2
    6d78:	32 e0       	ldi	r19, 0x02	; 2
    6d7a:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <InserBorder>
    6d7e:	86 e0       	ldi	r24, 0x06	; 6
    6d80:	6f ec       	ldi	r22, 0xCF	; 207
    6d82:	75 e0       	ldi	r23, 0x05	; 5
    6d84:	41 e0       	ldi	r20, 0x01	; 1
    6d86:	22 e0       	ldi	r18, 0x02	; 2
    6d88:	32 e0       	ldi	r19, 0x02	; 2
    6d8a:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <InserBorder>
    6d8e:	8c e0       	ldi	r24, 0x0C	; 12
    6d90:	6f ec       	ldi	r22, 0xCF	; 207
    6d92:	75 e0       	ldi	r23, 0x05	; 5
    6d94:	41 e0       	ldi	r20, 0x01	; 1
    6d96:	22 e0       	ldi	r18, 0x02	; 2
    6d98:	32 e0       	ldi	r19, 0x02	; 2
    6d9a:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <InserBorder>

		  GetTabSpace((17-strlen(strCurrentVolume)),strTabSpace);
    6d9e:	de 01       	movw	r26, r28
    6da0:	d7 96       	adiw	r26, 0x37	; 55
    6da2:	fd 01       	movw	r30, r26
    6da4:	01 90       	ld	r0, Z+
    6da6:	00 20       	and	r0, r0
    6da8:	e9 f7       	brne	.-6      	; 0x6da4 <systemGenerateReport+0xa30>
    6daa:	9a 2f       	mov	r25, r26
    6dac:	9e 1b       	sub	r25, r30
    6dae:	9e 5e       	subi	r25, 0xEE	; 238
    6db0:	de 01       	movw	r26, r28
    6db2:	a7 59       	subi	r26, 0x97	; 151
    6db4:	bf 4f       	sbci	r27, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    6db6:	19 16       	cp	r1, r25
    6db8:	7c f4       	brge	.+30     	; 0x6dd8 <systemGenerateReport+0xa64>
    6dba:	fd 01       	movw	r30, r26
    6dbc:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    6dbe:	20 e2       	ldi	r18, 0x20	; 32
    6dc0:	02 c0       	rjmp	.+4      	; 0x6dc6 <systemGenerateReport+0xa52>
    6dc2:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    6dc4:	8f 5f       	subi	r24, 0xFF	; 255
    6dc6:	89 17       	cp	r24, r25
    6dc8:	e0 f3       	brcs	.-8      	; 0x6dc2 <systemGenerateReport+0xa4e>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    6dca:	fe 01       	movw	r30, r28
    6dcc:	e7 59       	subi	r30, 0x97	; 151
    6dce:	ff 4f       	sbci	r31, 0xFF	; 255
    6dd0:	e9 0f       	add	r30, r25
    6dd2:	f1 1d       	adc	r31, r1
    6dd4:	10 82       	st	Z, r1
    6dd6:	04 c0       	rjmp	.+8      	; 0x6de0 <systemGenerateReport+0xa6c>
     }else{
	 strTab[0]=' ';
    6dd8:	80 e2       	ldi	r24, 0x20	; 32
    6dda:	8c 93       	st	X, r24
	 strTab[1]=0;
    6ddc:	11 96       	adiw	r26, 0x01	; 1
    6dde:	1c 92       	st	X, r1
		  else sprintf_P(strReport,PSTR("P%d.%d - %s "),PumpNum,PumpNozzle,strProduct);
		  CreateReport(strReport,PrintBuffer,&RepPos);
          InserBorder(btMiddleLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btMiddleRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          

		  GetTabSpace((17-strlen(strCurrentVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strCurrentMoney)),strTabSpace2);
    6de0:	de 01       	movw	r26, r28
    6de2:	aa 5b       	subi	r26, 0xBA	; 186
    6de4:	bf 4f       	sbci	r27, 0xFF	; 255
    6de6:	fd 01       	movw	r30, r26
    6de8:	01 90       	ld	r0, Z+
    6dea:	00 20       	and	r0, r0
    6dec:	e9 f7       	brne	.-6      	; 0x6de8 <systemGenerateReport+0xa74>
    6dee:	ae 1b       	sub	r26, r30
    6df0:	a0 5f       	subi	r26, 0xF0	; 240
    6df2:	fe 01       	movw	r30, r28
    6df4:	e3 58       	subi	r30, 0x83	; 131
    6df6:	ff 4f       	sbci	r31, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    6df8:	1a 16       	cp	r1, r26
    6dfa:	74 f4       	brge	.+28     	; 0x6e18 <systemGenerateReport+0xaa4>
    6dfc:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    6dfe:	90 e2       	ldi	r25, 0x20	; 32
    6e00:	02 c0       	rjmp	.+4      	; 0x6e06 <systemGenerateReport+0xa92>
    6e02:	91 93       	st	Z+, r25

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    6e04:	8f 5f       	subi	r24, 0xFF	; 255
    6e06:	8a 17       	cp	r24, r26
    6e08:	e0 f3       	brcs	.-8      	; 0x6e02 <systemGenerateReport+0xa8e>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    6e0a:	fe 01       	movw	r30, r28
    6e0c:	e3 58       	subi	r30, 0x83	; 131
    6e0e:	ff 4f       	sbci	r31, 0xFF	; 255
    6e10:	ea 0f       	add	r30, r26
    6e12:	f1 1d       	adc	r31, r1
    6e14:	10 82       	st	Z, r1
    6e16:	03 c0       	rjmp	.+6      	; 0x6e1e <systemGenerateReport+0xaaa>
     }else{
	 strTab[0]=' ';
    6e18:	80 e2       	ldi	r24, 0x20	; 32
    6e1a:	80 83       	st	Z, r24
	 strTab[1]=0;
    6e1c:	11 82       	std	Z+1, r1	; 0x01
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    6e1e:	e1 99       	sbic	0x1c, 1	; 28
    6e20:	fe cf       	rjmp	.-4      	; 0x6e1e <systemGenerateReport+0xaaa>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    6e22:	11 ec       	ldi	r17, 0xC1	; 193
    6e24:	e1 2e       	mov	r14, r17
    6e26:	13 e0       	ldi	r17, 0x03	; 3
    6e28:	f1 2e       	mov	r15, r17
    6e2a:	ff ba       	out	0x1f, r15	; 31
    6e2c:	ee ba       	out	0x1e, r14	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    6e2e:	e0 9a       	sbi	0x1c, 0	; 28
    6e30:	8d b3       	in	r24, 0x1d	; 29
    6e32:	9e 01       	movw	r18, r28
    6e34:	2b 55       	subi	r18, 0x5B	; 91
    6e36:	3f 4f       	sbci	r19, 0xFF	; 255
    6e38:	ae 01       	movw	r20, r28
    6e3a:	49 5c       	subi	r20, 0xC9	; 201
    6e3c:	5f 4f       	sbci	r21, 0xFF	; 255
    6e3e:	de 01       	movw	r26, r28
    6e40:	a7 59       	subi	r26, 0x97	; 151
    6e42:	bf 4f       	sbci	r27, 0xFF	; 255
          InserBorder(btMiddleLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btMiddleRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          

		  GetTabSpace((17-strlen(strCurrentVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strCurrentMoney)),strTabSpace2);
		  //PrintMoney
		  if (eeprom_read_byte(&DefPrintMoney)==True) sprintf_P(strReport,PSTR("Akhir:%s%s%s%s"),strTabSpace,strCurrentVolume,strTabSpace2,strCurrentMoney);//CreateReport(strReport,PrintBuffer,&RepPos);
    6e44:	81 30       	cpi	r24, 0x01	; 1
    6e46:	49 f5       	brne	.+82     	; 0x6e9a <systemGenerateReport+0xb26>
    6e48:	8d b7       	in	r24, 0x3d	; 61
    6e4a:	9e b7       	in	r25, 0x3e	; 62
    6e4c:	0c 97       	sbiw	r24, 0x0c	; 12
    6e4e:	0f b6       	in	r0, 0x3f	; 63
    6e50:	f8 94       	cli
    6e52:	9e bf       	out	0x3e, r25	; 62
    6e54:	0f be       	out	0x3f, r0	; 63
    6e56:	8d bf       	out	0x3d, r24	; 61
    6e58:	6d b7       	in	r22, 0x3d	; 61
    6e5a:	7e b7       	in	r23, 0x3e	; 62
    6e5c:	6f 5f       	subi	r22, 0xFF	; 255
    6e5e:	7f 4f       	sbci	r23, 0xFF	; 255
    6e60:	ed b7       	in	r30, 0x3d	; 61
    6e62:	fe b7       	in	r31, 0x3e	; 62
    6e64:	32 83       	std	Z+2, r19	; 0x02
    6e66:	21 83       	std	Z+1, r18	; 0x01
    6e68:	8e e9       	ldi	r24, 0x9E	; 158
    6e6a:	94 e0       	ldi	r25, 0x04	; 4
    6e6c:	fb 01       	movw	r30, r22
    6e6e:	93 83       	std	Z+3, r25	; 0x03
    6e70:	82 83       	std	Z+2, r24	; 0x02
    6e72:	b5 83       	std	Z+5, r27	; 0x05
    6e74:	a4 83       	std	Z+4, r26	; 0x04
    6e76:	57 83       	std	Z+7, r21	; 0x07
    6e78:	46 83       	std	Z+6, r20	; 0x06
    6e7a:	ce 01       	movw	r24, r28
    6e7c:	83 58       	subi	r24, 0x83	; 131
    6e7e:	9f 4f       	sbci	r25, 0xFF	; 255
    6e80:	91 87       	std	Z+9, r25	; 0x09
    6e82:	80 87       	std	Z+8, r24	; 0x08
    6e84:	ce 01       	movw	r24, r28
    6e86:	8a 5b       	subi	r24, 0xBA	; 186
    6e88:	9f 4f       	sbci	r25, 0xFF	; 255
    6e8a:	93 87       	std	Z+11, r25	; 0x0b
    6e8c:	82 87       	std	Z+10, r24	; 0x0a
    6e8e:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    6e92:	8d b7       	in	r24, 0x3d	; 61
    6e94:	9e b7       	in	r25, 0x3e	; 62
    6e96:	0c 96       	adiw	r24, 0x0c	; 12
    6e98:	1c c0       	rjmp	.+56     	; 0x6ed2 <systemGenerateReport+0xb5e>
		  else sprintf_P(strReport,PSTR("Akhir:%s%s"),strTabSpace,strCurrentVolume);
    6e9a:	ed b7       	in	r30, 0x3d	; 61
    6e9c:	fe b7       	in	r31, 0x3e	; 62
    6e9e:	38 97       	sbiw	r30, 0x08	; 8
    6ea0:	0f b6       	in	r0, 0x3f	; 63
    6ea2:	f8 94       	cli
    6ea4:	fe bf       	out	0x3e, r31	; 62
    6ea6:	0f be       	out	0x3f, r0	; 63
    6ea8:	ed bf       	out	0x3d, r30	; 61
    6eaa:	6d b7       	in	r22, 0x3d	; 61
    6eac:	7e b7       	in	r23, 0x3e	; 62
    6eae:	6f 5f       	subi	r22, 0xFF	; 255
    6eb0:	7f 4f       	sbci	r23, 0xFF	; 255
    6eb2:	32 83       	std	Z+2, r19	; 0x02
    6eb4:	21 83       	std	Z+1, r18	; 0x01
    6eb6:	83 e9       	ldi	r24, 0x93	; 147
    6eb8:	94 e0       	ldi	r25, 0x04	; 4
    6eba:	fb 01       	movw	r30, r22
    6ebc:	93 83       	std	Z+3, r25	; 0x03
    6ebe:	82 83       	std	Z+2, r24	; 0x02
    6ec0:	b5 83       	std	Z+5, r27	; 0x05
    6ec2:	a4 83       	std	Z+4, r26	; 0x04
    6ec4:	57 83       	std	Z+7, r21	; 0x07
    6ec6:	46 83       	std	Z+6, r20	; 0x06
    6ec8:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    6ecc:	8d b7       	in	r24, 0x3d	; 61
    6ece:	9e b7       	in	r25, 0x3e	; 62
    6ed0:	08 96       	adiw	r24, 0x08	; 8
    6ed2:	0f b6       	in	r0, 0x3f	; 63
    6ed4:	f8 94       	cli
    6ed6:	9e bf       	out	0x3e, r25	; 62
    6ed8:	0f be       	out	0x3f, r0	; 63
    6eda:	8d bf       	out	0x3d, r24	; 61
		  CreateReport(strReport,PrintBuffer,&RepPos);
    6edc:	ce 01       	movw	r24, r28
    6ede:	8b 55       	subi	r24, 0x5B	; 91
    6ee0:	9f 4f       	sbci	r25, 0xFF	; 255
    6ee2:	6f ec       	ldi	r22, 0xCF	; 207
    6ee4:	75 e0       	ldi	r23, 0x05	; 5
    6ee6:	42 e0       	ldi	r20, 0x02	; 2
    6ee8:	52 e0       	ldi	r21, 0x02	; 2
    6eea:	0e 94 ad 20 	call	0x415a	; 0x415a <CreateReport>

		  GetTabSpace((17-strlen(strLastVolume)),strTabSpace);
    6eee:	de 01       	movw	r26, r28
    6ef0:	59 96       	adiw	r26, 0x19	; 25
    6ef2:	fd 01       	movw	r30, r26
    6ef4:	01 90       	ld	r0, Z+
    6ef6:	00 20       	and	r0, r0
    6ef8:	e9 f7       	brne	.-6      	; 0x6ef4 <systemGenerateReport+0xb80>
    6efa:	9a 2f       	mov	r25, r26
    6efc:	9e 1b       	sub	r25, r30
    6efe:	9e 5e       	subi	r25, 0xEE	; 238
    6f00:	de 01       	movw	r26, r28
    6f02:	a7 59       	subi	r26, 0x97	; 151
    6f04:	bf 4f       	sbci	r27, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    6f06:	19 16       	cp	r1, r25
    6f08:	7c f4       	brge	.+30     	; 0x6f28 <systemGenerateReport+0xbb4>
    6f0a:	fd 01       	movw	r30, r26
    6f0c:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    6f0e:	20 e2       	ldi	r18, 0x20	; 32
    6f10:	02 c0       	rjmp	.+4      	; 0x6f16 <systemGenerateReport+0xba2>
    6f12:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    6f14:	8f 5f       	subi	r24, 0xFF	; 255
    6f16:	89 17       	cp	r24, r25
    6f18:	e0 f3       	brcs	.-8      	; 0x6f12 <systemGenerateReport+0xb9e>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    6f1a:	fe 01       	movw	r30, r28
    6f1c:	e7 59       	subi	r30, 0x97	; 151
    6f1e:	ff 4f       	sbci	r31, 0xFF	; 255
    6f20:	e9 0f       	add	r30, r25
    6f22:	f1 1d       	adc	r31, r1
    6f24:	10 82       	st	Z, r1
    6f26:	04 c0       	rjmp	.+8      	; 0x6f30 <systemGenerateReport+0xbbc>
     }else{
	 strTab[0]=' ';
    6f28:	80 e2       	ldi	r24, 0x20	; 32
    6f2a:	8c 93       	st	X, r24
	 strTab[1]=0;
    6f2c:	11 96       	adiw	r26, 0x01	; 1
    6f2e:	1c 92       	st	X, r1
		  if (eeprom_read_byte(&DefPrintMoney)==True) sprintf_P(strReport,PSTR("Akhir:%s%s%s%s"),strTabSpace,strCurrentVolume,strTabSpace2,strCurrentMoney);//CreateReport(strReport,PrintBuffer,&RepPos);
		  else sprintf_P(strReport,PSTR("Akhir:%s%s"),strTabSpace,strCurrentVolume);
		  CreateReport(strReport,PrintBuffer,&RepPos);

		  GetTabSpace((17-strlen(strLastVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strLastMoney)),strTabSpace2);
    6f30:	de 01       	movw	r26, r28
    6f32:	98 96       	adiw	r26, 0x28	; 40
    6f34:	fd 01       	movw	r30, r26
    6f36:	01 90       	ld	r0, Z+
    6f38:	00 20       	and	r0, r0
    6f3a:	e9 f7       	brne	.-6      	; 0x6f36 <systemGenerateReport+0xbc2>
    6f3c:	ae 1b       	sub	r26, r30
    6f3e:	a0 5f       	subi	r26, 0xF0	; 240
    6f40:	fe 01       	movw	r30, r28
    6f42:	e3 58       	subi	r30, 0x83	; 131
    6f44:	ff 4f       	sbci	r31, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    6f46:	1a 16       	cp	r1, r26
    6f48:	74 f4       	brge	.+28     	; 0x6f66 <systemGenerateReport+0xbf2>
    6f4a:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    6f4c:	90 e2       	ldi	r25, 0x20	; 32
    6f4e:	02 c0       	rjmp	.+4      	; 0x6f54 <systemGenerateReport+0xbe0>
    6f50:	91 93       	st	Z+, r25

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    6f52:	8f 5f       	subi	r24, 0xFF	; 255
    6f54:	8a 17       	cp	r24, r26
    6f56:	e0 f3       	brcs	.-8      	; 0x6f50 <systemGenerateReport+0xbdc>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    6f58:	fe 01       	movw	r30, r28
    6f5a:	e3 58       	subi	r30, 0x83	; 131
    6f5c:	ff 4f       	sbci	r31, 0xFF	; 255
    6f5e:	ea 0f       	add	r30, r26
    6f60:	f1 1d       	adc	r31, r1
    6f62:	10 82       	st	Z, r1
    6f64:	03 c0       	rjmp	.+6      	; 0x6f6c <systemGenerateReport+0xbf8>
     }else{
	 strTab[0]=' ';
    6f66:	80 e2       	ldi	r24, 0x20	; 32
    6f68:	80 83       	st	Z, r24
	 strTab[1]=0;
    6f6a:	11 82       	std	Z+1, r1	; 0x01
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    6f6c:	e1 99       	sbic	0x1c, 1	; 28
    6f6e:	fe cf       	rjmp	.-4      	; 0x6f6c <systemGenerateReport+0xbf8>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    6f70:	ff ba       	out	0x1f, r15	; 31
    6f72:	ee ba       	out	0x1e, r14	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    6f74:	e0 9a       	sbi	0x1c, 0	; 28
    6f76:	8d b3       	in	r24, 0x1d	; 29
    6f78:	9e 01       	movw	r18, r28
    6f7a:	2b 55       	subi	r18, 0x5B	; 91
    6f7c:	3f 4f       	sbci	r19, 0xFF	; 255
    6f7e:	ae 01       	movw	r20, r28
    6f80:	47 5e       	subi	r20, 0xE7	; 231
    6f82:	5f 4f       	sbci	r21, 0xFF	; 255
    6f84:	de 01       	movw	r26, r28
    6f86:	a7 59       	subi	r26, 0x97	; 151
    6f88:	bf 4f       	sbci	r27, 0xFF	; 255
		  CreateReport(strReport,PrintBuffer,&RepPos);

		  GetTabSpace((17-strlen(strLastVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strLastMoney)),strTabSpace2);
		  //PrintMoney
		  if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("Awal :%s%s%s%s"),strTabSpace,strLastVolume,strTabSpace2,strLastMoney);//CreateReport(strReport,PrintBuffer,&RepPos);
    6f8a:	81 30       	cpi	r24, 0x01	; 1
    6f8c:	31 f5       	brne	.+76     	; 0x6fda <systemGenerateReport+0xc66>
    6f8e:	ed b7       	in	r30, 0x3d	; 61
    6f90:	fe b7       	in	r31, 0x3e	; 62
    6f92:	3c 97       	sbiw	r30, 0x0c	; 12
    6f94:	0f b6       	in	r0, 0x3f	; 63
    6f96:	f8 94       	cli
    6f98:	fe bf       	out	0x3e, r31	; 62
    6f9a:	0f be       	out	0x3f, r0	; 63
    6f9c:	ed bf       	out	0x3d, r30	; 61
    6f9e:	6d b7       	in	r22, 0x3d	; 61
    6fa0:	7e b7       	in	r23, 0x3e	; 62
    6fa2:	6f 5f       	subi	r22, 0xFF	; 255
    6fa4:	7f 4f       	sbci	r23, 0xFF	; 255
    6fa6:	32 83       	std	Z+2, r19	; 0x02
    6fa8:	21 83       	std	Z+1, r18	; 0x01
    6faa:	84 e8       	ldi	r24, 0x84	; 132
    6fac:	94 e0       	ldi	r25, 0x04	; 4
    6fae:	fb 01       	movw	r30, r22
    6fb0:	93 83       	std	Z+3, r25	; 0x03
    6fb2:	82 83       	std	Z+2, r24	; 0x02
    6fb4:	b5 83       	std	Z+5, r27	; 0x05
    6fb6:	a4 83       	std	Z+4, r26	; 0x04
    6fb8:	57 83       	std	Z+7, r21	; 0x07
    6fba:	46 83       	std	Z+6, r20	; 0x06
    6fbc:	ce 01       	movw	r24, r28
    6fbe:	83 58       	subi	r24, 0x83	; 131
    6fc0:	9f 4f       	sbci	r25, 0xFF	; 255
    6fc2:	91 87       	std	Z+9, r25	; 0x09
    6fc4:	80 87       	std	Z+8, r24	; 0x08
    6fc6:	ce 01       	movw	r24, r28
    6fc8:	88 96       	adiw	r24, 0x28	; 40
    6fca:	93 87       	std	Z+11, r25	; 0x0b
    6fcc:	82 87       	std	Z+10, r24	; 0x0a
    6fce:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    6fd2:	8d b7       	in	r24, 0x3d	; 61
    6fd4:	9e b7       	in	r25, 0x3e	; 62
    6fd6:	0c 96       	adiw	r24, 0x0c	; 12
    6fd8:	1c c0       	rjmp	.+56     	; 0x7012 <systemGenerateReport+0xc9e>
		  else sprintf_P(strReport,PSTR("Awal :%s%s"),strTabSpace,strLastVolume);
    6fda:	ed b7       	in	r30, 0x3d	; 61
    6fdc:	fe b7       	in	r31, 0x3e	; 62
    6fde:	38 97       	sbiw	r30, 0x08	; 8
    6fe0:	0f b6       	in	r0, 0x3f	; 63
    6fe2:	f8 94       	cli
    6fe4:	fe bf       	out	0x3e, r31	; 62
    6fe6:	0f be       	out	0x3f, r0	; 63
    6fe8:	ed bf       	out	0x3d, r30	; 61
    6fea:	6d b7       	in	r22, 0x3d	; 61
    6fec:	7e b7       	in	r23, 0x3e	; 62
    6fee:	6f 5f       	subi	r22, 0xFF	; 255
    6ff0:	7f 4f       	sbci	r23, 0xFF	; 255
    6ff2:	32 83       	std	Z+2, r19	; 0x02
    6ff4:	21 83       	std	Z+1, r18	; 0x01
    6ff6:	89 e7       	ldi	r24, 0x79	; 121
    6ff8:	94 e0       	ldi	r25, 0x04	; 4
    6ffa:	fb 01       	movw	r30, r22
    6ffc:	93 83       	std	Z+3, r25	; 0x03
    6ffe:	82 83       	std	Z+2, r24	; 0x02
    7000:	b5 83       	std	Z+5, r27	; 0x05
    7002:	a4 83       	std	Z+4, r26	; 0x04
    7004:	57 83       	std	Z+7, r21	; 0x07
    7006:	46 83       	std	Z+6, r20	; 0x06
    7008:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    700c:	8d b7       	in	r24, 0x3d	; 61
    700e:	9e b7       	in	r25, 0x3e	; 62
    7010:	08 96       	adiw	r24, 0x08	; 8
    7012:	0f b6       	in	r0, 0x3f	; 63
    7014:	f8 94       	cli
    7016:	9e bf       	out	0x3e, r25	; 62
    7018:	0f be       	out	0x3f, r0	; 63
    701a:	8d bf       	out	0x3d, r24	; 61
		  CreateReport(strReport,PrintBuffer,&RepPos);
    701c:	ce 01       	movw	r24, r28
    701e:	8b 55       	subi	r24, 0x5B	; 91
    7020:	9f 4f       	sbci	r25, 0xFF	; 255
    7022:	6f ec       	ldi	r22, 0xCF	; 207
    7024:	75 e0       	ldi	r23, 0x05	; 5
    7026:	42 e0       	ldi	r20, 0x02	; 2
    7028:	52 e0       	ldi	r21, 0x02	; 2
    702a:	0e 94 ad 20 	call	0x415a	; 0x415a <CreateReport>
    702e:	8e 01       	movw	r16, r28
    7030:	07 59       	subi	r16, 0x97	; 151
    7032:	1f 4f       	sbci	r17, 0xFF	; 255
    7034:	f8 01       	movw	r30, r16
void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    7036:	20 e2       	ldi	r18, 0x20	; 32

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    7038:	d8 01       	movw	r26, r16
    703a:	c8 01       	movw	r24, r16
    703c:	0c 96       	adiw	r24, 0x0c	; 12
		     strTab[i]=' ';
    703e:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    7040:	e8 17       	cp	r30, r24
    7042:	f9 07       	cpc	r31, r25
    7044:	e1 f7       	brne	.-8      	; 0x703e <systemGenerateReport+0xcca>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    7046:	1c 96       	adiw	r26, 0x0c	; 12
    7048:	1c 92       	st	X, r1
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    704a:	e1 99       	sbic	0x1c, 1	; 28
    704c:	fe cf       	rjmp	.-4      	; 0x704a <systemGenerateReport+0xcd6>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    704e:	ff ba       	out	0x1f, r15	; 31
    7050:	ee ba       	out	0x1e, r14	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    7052:	e0 9a       	sbi	0x1c, 0	; 28
    7054:	8d b3       	in	r24, 0x1d	; 29
    7056:	9e 01       	movw	r18, r28
    7058:	2b 55       	subi	r18, 0x5B	; 91
    705a:	3f 4f       	sbci	r19, 0xFF	; 255
    705c:	de 01       	movw	r26, r28
    705e:	a7 59       	subi	r26, 0x97	; 151
    7060:	bf 4f       	sbci	r27, 0xFF	; 255
		  else sprintf_P(strReport,PSTR("Awal :%s%s"),strTabSpace,strLastVolume);
		  CreateReport(strReport,PrintBuffer,&RepPos);

		  GetTabSpace(12,strTabSpace);
          //PrintMoney
          if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("%s-----------   -------------"),strTabSpace);//CreateReport(strReport,PrintBuffer,&RepPos);
    7062:	81 30       	cpi	r24, 0x01	; 1
    7064:	71 f4       	brne	.+28     	; 0x7082 <systemGenerateReport+0xd0e>
    7066:	00 d0       	rcall	.+0      	; 0x7068 <systemGenerateReport+0xcf4>
    7068:	00 d0       	rcall	.+0      	; 0x706a <systemGenerateReport+0xcf6>
    706a:	00 d0       	rcall	.+0      	; 0x706c <systemGenerateReport+0xcf8>
    706c:	4d b7       	in	r20, 0x3d	; 61
    706e:	5e b7       	in	r21, 0x3e	; 62
    7070:	4f 5f       	subi	r20, 0xFF	; 255
    7072:	5f 4f       	sbci	r21, 0xFF	; 255
    7074:	ed b7       	in	r30, 0x3d	; 61
    7076:	fe b7       	in	r31, 0x3e	; 62
    7078:	32 83       	std	Z+2, r19	; 0x02
    707a:	21 83       	std	Z+1, r18	; 0x01
    707c:	8b e5       	ldi	r24, 0x5B	; 91
    707e:	94 e0       	ldi	r25, 0x04	; 4
    7080:	0d c0       	rjmp	.+26     	; 0x709c <systemGenerateReport+0xd28>
		  else sprintf_P(strReport,PSTR("%s-----------                "),strTabSpace);CreateReport(strReport,PrintBuffer,&RepPos);
    7082:	00 d0       	rcall	.+0      	; 0x7084 <systemGenerateReport+0xd10>
    7084:	00 d0       	rcall	.+0      	; 0x7086 <systemGenerateReport+0xd12>
    7086:	00 d0       	rcall	.+0      	; 0x7088 <systemGenerateReport+0xd14>
    7088:	4d b7       	in	r20, 0x3d	; 61
    708a:	5e b7       	in	r21, 0x3e	; 62
    708c:	4f 5f       	subi	r20, 0xFF	; 255
    708e:	5f 4f       	sbci	r21, 0xFF	; 255
    7090:	ed b7       	in	r30, 0x3d	; 61
    7092:	fe b7       	in	r31, 0x3e	; 62
    7094:	32 83       	std	Z+2, r19	; 0x02
    7096:	21 83       	std	Z+1, r18	; 0x01
    7098:	8d e3       	ldi	r24, 0x3D	; 61
    709a:	94 e0       	ldi	r25, 0x04	; 4
    709c:	fa 01       	movw	r30, r20
    709e:	93 83       	std	Z+3, r25	; 0x03
    70a0:	82 83       	std	Z+2, r24	; 0x02
    70a2:	b5 83       	std	Z+5, r27	; 0x05
    70a4:	a4 83       	std	Z+4, r26	; 0x04
    70a6:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    70aa:	8d b7       	in	r24, 0x3d	; 61
    70ac:	9e b7       	in	r25, 0x3e	; 62
    70ae:	06 96       	adiw	r24, 0x06	; 6
    70b0:	0f b6       	in	r0, 0x3f	; 63
    70b2:	f8 94       	cli
    70b4:	9e bf       	out	0x3e, r25	; 62
    70b6:	0f be       	out	0x3f, r0	; 63
    70b8:	8d bf       	out	0x3d, r24	; 61
    70ba:	ce 01       	movw	r24, r28
    70bc:	8b 55       	subi	r24, 0x5B	; 91
    70be:	9f 4f       	sbci	r25, 0xFF	; 255
    70c0:	6f ec       	ldi	r22, 0xCF	; 207
    70c2:	75 e0       	ldi	r23, 0x05	; 5
    70c4:	42 e0       	ldi	r20, 0x02	; 2
    70c6:	52 e0       	ldi	r21, 0x02	; 2
    70c8:	0e 94 ad 20 	call	0x415a	; 0x415a <CreateReport>

		  GetTabSpace((23-strlen(strDeltaVolume)),strTabSpace);
    70cc:	ed ed       	ldi	r30, 0xDD	; 221
    70ce:	fa e0       	ldi	r31, 0x0A	; 10
    70d0:	01 90       	ld	r0, Z+
    70d2:	00 20       	and	r0, r0
    70d4:	e9 f7       	brne	.-6      	; 0x70d0 <systemGenerateReport+0xd5c>
    70d6:	31 97       	sbiw	r30, 0x01	; 1
    70d8:	ed 5d       	subi	r30, 0xDD	; 221
    70da:	fa 40       	sbci	r31, 0x0A	; 10
    70dc:	97 e1       	ldi	r25, 0x17	; 23
    70de:	9e 1b       	sub	r25, r30
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    70e0:	19 16       	cp	r1, r25
    70e2:	84 f4       	brge	.+32     	; 0x7104 <systemGenerateReport+0xd90>
    70e4:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    70e6:	20 e2       	ldi	r18, 0x20	; 32
    70e8:	04 c0       	rjmp	.+8      	; 0x70f2 <systemGenerateReport+0xd7e>
    70ea:	d8 01       	movw	r26, r16
    70ec:	2d 93       	st	X+, r18
    70ee:	8d 01       	movw	r16, r26

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    70f0:	8f 5f       	subi	r24, 0xFF	; 255
    70f2:	89 17       	cp	r24, r25
    70f4:	d0 f3       	brcs	.-12     	; 0x70ea <systemGenerateReport+0xd76>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    70f6:	fe 01       	movw	r30, r28
    70f8:	e7 59       	subi	r30, 0x97	; 151
    70fa:	ff 4f       	sbci	r31, 0xFF	; 255
    70fc:	e9 0f       	add	r30, r25
    70fe:	f1 1d       	adc	r31, r1
    7100:	10 82       	st	Z, r1
    7102:	06 c0       	rjmp	.+12     	; 0x7110 <systemGenerateReport+0xd9c>
     }else{
	 strTab[0]=' ';
    7104:	fe 01       	movw	r30, r28
    7106:	e7 59       	subi	r30, 0x97	; 151
    7108:	ff 4f       	sbci	r31, 0xFF	; 255
    710a:	80 e2       	ldi	r24, 0x20	; 32
    710c:	80 83       	st	Z, r24
	 strTab[1]=0;
    710e:	11 82       	std	Z+1, r1	; 0x01
          //PrintMoney
          if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("%s-----------   -------------"),strTabSpace);//CreateReport(strReport,PrintBuffer,&RepPos);
		  else sprintf_P(strReport,PSTR("%s-----------                "),strTabSpace);CreateReport(strReport,PrintBuffer,&RepPos);

		  GetTabSpace((23-strlen(strDeltaVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strDeltaMoney)),strTabSpace2);
    7110:	e8 e0       	ldi	r30, 0x08	; 8
    7112:	fe e0       	ldi	r31, 0x0E	; 14
    7114:	01 90       	ld	r0, Z+
    7116:	00 20       	and	r0, r0
    7118:	e9 f7       	brne	.-6      	; 0x7114 <systemGenerateReport+0xda0>
    711a:	31 97       	sbiw	r30, 0x01	; 1
    711c:	e8 50       	subi	r30, 0x08	; 8
    711e:	fe 40       	sbci	r31, 0x0E	; 14
    7120:	9f e0       	ldi	r25, 0x0F	; 15
    7122:	9e 1b       	sub	r25, r30
    7124:	fe 01       	movw	r30, r28
    7126:	e3 58       	subi	r30, 0x83	; 131
    7128:	ff 4f       	sbci	r31, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    712a:	19 16       	cp	r1, r25
    712c:	74 f4       	brge	.+28     	; 0x714a <systemGenerateReport+0xdd6>
    712e:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    7130:	20 e2       	ldi	r18, 0x20	; 32
    7132:	02 c0       	rjmp	.+4      	; 0x7138 <systemGenerateReport+0xdc4>
    7134:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    7136:	8f 5f       	subi	r24, 0xFF	; 255
    7138:	89 17       	cp	r24, r25
    713a:	e0 f3       	brcs	.-8      	; 0x7134 <systemGenerateReport+0xdc0>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    713c:	fe 01       	movw	r30, r28
    713e:	e3 58       	subi	r30, 0x83	; 131
    7140:	ff 4f       	sbci	r31, 0xFF	; 255
    7142:	e9 0f       	add	r30, r25
    7144:	f1 1d       	adc	r31, r1
    7146:	10 82       	st	Z, r1
    7148:	03 c0       	rjmp	.+6      	; 0x7150 <systemGenerateReport+0xddc>
     }else{
	 strTab[0]=' ';
    714a:	80 e2       	ldi	r24, 0x20	; 32
    714c:	80 83       	st	Z, r24
	 strTab[1]=0;
    714e:	11 82       	std	Z+1, r1	; 0x01
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    7150:	e1 99       	sbic	0x1c, 1	; 28
    7152:	fe cf       	rjmp	.-4      	; 0x7150 <systemGenerateReport+0xddc>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    7154:	ff ba       	out	0x1f, r15	; 31
    7156:	ee ba       	out	0x1e, r14	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    7158:	e0 9a       	sbi	0x1c, 0	; 28
    715a:	8d b3       	in	r24, 0x1d	; 29
    715c:	9e 01       	movw	r18, r28
    715e:	2b 55       	subi	r18, 0x5B	; 91
    7160:	3f 4f       	sbci	r19, 0xFF	; 255
    7162:	4d ed       	ldi	r20, 0xDD	; 221
    7164:	5a e0       	ldi	r21, 0x0A	; 10
    7166:	de 01       	movw	r26, r28
    7168:	a7 59       	subi	r26, 0x97	; 151
    716a:	bf 4f       	sbci	r27, 0xFF	; 255
		  else sprintf_P(strReport,PSTR("%s-----------                "),strTabSpace);CreateReport(strReport,PrintBuffer,&RepPos);

		  GetTabSpace((23-strlen(strDeltaVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strDeltaMoney)),strTabSpace2);
          //PrintMoney
		  if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("%s%s%s%s"),strTabSpace,strDeltaVolume,strTabSpace2,strDeltaMoney);//CreateReport(strReport,PrintBuffer,&RepPos);
    716c:	81 30       	cpi	r24, 0x01	; 1
    716e:	31 f5       	brne	.+76     	; 0x71bc <systemGenerateReport+0xe48>
    7170:	ed b7       	in	r30, 0x3d	; 61
    7172:	fe b7       	in	r31, 0x3e	; 62
    7174:	3c 97       	sbiw	r30, 0x0c	; 12
    7176:	0f b6       	in	r0, 0x3f	; 63
    7178:	f8 94       	cli
    717a:	fe bf       	out	0x3e, r31	; 62
    717c:	0f be       	out	0x3f, r0	; 63
    717e:	ed bf       	out	0x3d, r30	; 61
    7180:	6d b7       	in	r22, 0x3d	; 61
    7182:	7e b7       	in	r23, 0x3e	; 62
    7184:	6f 5f       	subi	r22, 0xFF	; 255
    7186:	7f 4f       	sbci	r23, 0xFF	; 255
    7188:	32 83       	std	Z+2, r19	; 0x02
    718a:	21 83       	std	Z+1, r18	; 0x01
    718c:	84 e3       	ldi	r24, 0x34	; 52
    718e:	94 e0       	ldi	r25, 0x04	; 4
    7190:	fb 01       	movw	r30, r22
    7192:	93 83       	std	Z+3, r25	; 0x03
    7194:	82 83       	std	Z+2, r24	; 0x02
    7196:	b5 83       	std	Z+5, r27	; 0x05
    7198:	a4 83       	std	Z+4, r26	; 0x04
    719a:	57 83       	std	Z+7, r21	; 0x07
    719c:	46 83       	std	Z+6, r20	; 0x06
    719e:	ce 01       	movw	r24, r28
    71a0:	83 58       	subi	r24, 0x83	; 131
    71a2:	9f 4f       	sbci	r25, 0xFF	; 255
    71a4:	91 87       	std	Z+9, r25	; 0x09
    71a6:	80 87       	std	Z+8, r24	; 0x08
    71a8:	88 e0       	ldi	r24, 0x08	; 8
    71aa:	9e e0       	ldi	r25, 0x0E	; 14
    71ac:	93 87       	std	Z+11, r25	; 0x0b
    71ae:	82 87       	std	Z+10, r24	; 0x0a
    71b0:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    71b4:	8d b7       	in	r24, 0x3d	; 61
    71b6:	9e b7       	in	r25, 0x3e	; 62
    71b8:	0c 96       	adiw	r24, 0x0c	; 12
    71ba:	1c c0       	rjmp	.+56     	; 0x71f4 <systemGenerateReport+0xe80>
          else sprintf_P(strReport,PSTR("%s%s"),strTabSpace,strDeltaVolume);CreateReport(strReport,PrintBuffer,&RepPos);
    71bc:	ed b7       	in	r30, 0x3d	; 61
    71be:	fe b7       	in	r31, 0x3e	; 62
    71c0:	38 97       	sbiw	r30, 0x08	; 8
    71c2:	0f b6       	in	r0, 0x3f	; 63
    71c4:	f8 94       	cli
    71c6:	fe bf       	out	0x3e, r31	; 62
    71c8:	0f be       	out	0x3f, r0	; 63
    71ca:	ed bf       	out	0x3d, r30	; 61
    71cc:	6d b7       	in	r22, 0x3d	; 61
    71ce:	7e b7       	in	r23, 0x3e	; 62
    71d0:	6f 5f       	subi	r22, 0xFF	; 255
    71d2:	7f 4f       	sbci	r23, 0xFF	; 255
    71d4:	32 83       	std	Z+2, r19	; 0x02
    71d6:	21 83       	std	Z+1, r18	; 0x01
    71d8:	8f e2       	ldi	r24, 0x2F	; 47
    71da:	94 e0       	ldi	r25, 0x04	; 4
    71dc:	fb 01       	movw	r30, r22
    71de:	93 83       	std	Z+3, r25	; 0x03
    71e0:	82 83       	std	Z+2, r24	; 0x02
    71e2:	b5 83       	std	Z+5, r27	; 0x05
    71e4:	a4 83       	std	Z+4, r26	; 0x04
    71e6:	57 83       	std	Z+7, r21	; 0x07
    71e8:	46 83       	std	Z+6, r20	; 0x06
    71ea:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    71ee:	8d b7       	in	r24, 0x3d	; 61
    71f0:	9e b7       	in	r25, 0x3e	; 62
    71f2:	08 96       	adiw	r24, 0x08	; 8
    71f4:	0f b6       	in	r0, 0x3f	; 63
    71f6:	f8 94       	cli
    71f8:	9e bf       	out	0x3e, r25	; 62
    71fa:	0f be       	out	0x3f, r0	; 63
    71fc:	8d bf       	out	0x3d, r24	; 61
    71fe:	ce 01       	movw	r24, r28
    7200:	8b 55       	subi	r24, 0x5B	; 91
    7202:	9f 4f       	sbci	r25, 0xFF	; 255
    7204:	6f ec       	ldi	r22, 0xCF	; 207
    7206:	75 e0       	ldi	r23, 0x05	; 5
    7208:	42 e0       	ldi	r20, 0x02	; 2
    720a:	52 e0       	ldi	r21, 0x02	; 2
    720c:	0e 94 ad 20 	call	0x415a	; 0x415a <CreateReport>

          InserBorder(btBottomLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btBottomRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);
    7210:	87 e0       	ldi	r24, 0x07	; 7
    7212:	6f ec       	ldi	r22, 0xCF	; 207
    7214:	75 e0       	ldi	r23, 0x05	; 5
    7216:	41 e0       	ldi	r20, 0x01	; 1
    7218:	22 e0       	ldi	r18, 0x02	; 2
    721a:	32 e0       	ldi	r19, 0x02	; 2
    721c:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <InserBorder>
    7220:	8b e0       	ldi	r24, 0x0B	; 11
    7222:	6f ec       	ldi	r22, 0xCF	; 207
    7224:	75 e0       	ldi	r23, 0x05	; 5
    7226:	4a e2       	ldi	r20, 0x2A	; 42
    7228:	22 e0       	ldi	r18, 0x02	; 2
    722a:	32 e0       	ldi	r19, 0x02	; 2
    722c:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <InserBorder>
    7230:	89 e0       	ldi	r24, 0x09	; 9
    7232:	6f ec       	ldi	r22, 0xCF	; 207
    7234:	75 e0       	ldi	r23, 0x05	; 5
    7236:	41 e0       	ldi	r20, 0x01	; 1
    7238:	22 e0       	ldi	r18, 0x02	; 2
    723a:	32 e0       	ldi	r19, 0x02	; 2
    723c:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <InserBorder>
    7240:	8c e0       	ldi	r24, 0x0C	; 12
    7242:	6f ec       	ldi	r22, 0xCF	; 207
    7244:	75 e0       	ldi	r23, 0x05	; 5
    7246:	41 e0       	ldi	r20, 0x01	; 1
    7248:	22 e0       	ldi	r18, 0x02	; 2
    724a:	32 e0       	ldi	r19, 0x02	; 2
    724c:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <InserBorder>


          cmdPrint=0b00000000;
    7250:	10 92 cb 01 	sts	0x01CB, r1
		  LengthMessage81=RepPos+1;
    7254:	80 91 02 02 	lds	r24, 0x0202
    7258:	90 91 03 02 	lds	r25, 0x0203
    725c:	01 96       	adiw	r24, 0x01	; 1
    725e:	90 93 a1 01 	sts	0x01A1, r25
    7262:	80 93 a0 01 	sts	0x01A0, r24

		  IsFreePrinting=True;
    7266:	81 e0       	ldi	r24, 0x01	; 1
    7268:	80 93 bf 01 	sts	0x01BF, r24
	      IsBusyFreePrinting=True;
    726c:	80 93 ca 01 	sts	0x01CA, r24

	      stGenerateReport=grWaitPrinted2;
    7270:	89 e0       	ldi	r24, 0x09	; 9
    7272:	91 c3       	rjmp	.+1826   	; 0x7996 <systemGenerateReport+0x1622>
	      break;
     case grWaitPrinted2:
	 
          if (IsBusyFreePrinting==False)stGenerateReport=grGenerateReportData;
    7274:	80 91 ca 01 	lds	r24, 0x01CA
    7278:	88 23       	and	r24, r24
    727a:	09 f0       	breq	.+2      	; 0x727e <systemGenerateReport+0xf0a>
    727c:	94 c3       	rjmp	.+1832   	; 0x79a6 <systemGenerateReport+0x1632>
    727e:	86 e0       	ldi	r24, 0x06	; 6
    7280:	8a c3       	rjmp	.+1812   	; 0x7996 <systemGenerateReport+0x1622>
	      break;
     case grCreateReportFooter:
          RepPos=0;
    7282:	10 92 03 02 	sts	0x0203, r1
    7286:	10 92 02 02 	sts	0x0202, r1
    728a:	ef ec       	ldi	r30, 0xCF	; 207
    728c:	f5 e0       	ldi	r31, 0x05	; 5
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    728e:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7290:	97 e0       	ldi	r25, 0x07	; 7
    7292:	e0 36       	cpi	r30, 0x60	; 96
    7294:	f9 07       	cpc	r31, r25
    7296:	d9 f7       	brne	.-10     	; 0x728e <systemGenerateReport+0xf1a>
    7298:	fe 01       	movw	r30, r28
    729a:	eb 55       	subi	r30, 0x5B	; 91
    729c:	ff 4f       	sbci	r31, 0xFF	; 255
	     strMemory[i]=data;
    729e:	ce 01       	movw	r24, r28
    72a0:	8b 50       	subi	r24, 0x0B	; 11
    72a2:	9f 4f       	sbci	r25, 0xFF	; 255
    72a4:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    72a6:	e8 17       	cp	r30, r24
    72a8:	f9 07       	cpc	r31, r25
    72aa:	e1 f7       	brne	.-8      	; 0x72a4 <systemGenerateReport+0xf30>
     case grCreateReportFooter:
          RepPos=0;
		  FillChar(PrintBuffer,sizeof(PrintBuffer),0);
		  FillChar(strReport,sizeof(strReport),0);

		  RemZeroLead(strTotalMoney);
    72ac:	8d ea       	ldi	r24, 0xAD	; 173
    72ae:	9a e0       	ldi	r25, 0x0A	; 10
    72b0:	0e 94 dd 23 	call	0x47ba	; 0x47ba <RemZeroLead>
		  RemZeroLead(strTotalVolume);
    72b4:	0c ef       	ldi	r16, 0xFC	; 252
    72b6:	19 e0       	ldi	r17, 0x09	; 9
    72b8:	c8 01       	movw	r24, r16
    72ba:	0e 94 dd 23 	call	0x47ba	; 0x47ba <RemZeroLead>

		  FormatTotalizerMoney(strTotalMoney);
    72be:	8d ea       	ldi	r24, 0xAD	; 173
    72c0:	9a e0       	ldi	r25, 0x0A	; 10
    72c2:	0e 94 86 31 	call	0x630c	; 0x630c <FormatTotalizerMoney>
		  FormatCurrency(strTotalMoney);
    72c6:	8d ea       	ldi	r24, 0xAD	; 173
    72c8:	9a e0       	ldi	r25, 0x0A	; 10
    72ca:	0e 94 49 30 	call	0x6092	; 0x6092 <FormatCurrency>
		  FormatTotalizerVolume(strTotalVolume);
    72ce:	c8 01       	movw	r24, r16
    72d0:	0e 94 79 31 	call	0x62f2	; 0x62f2 <FormatTotalizerVolume>
		  FormatCurrency(strTotalVolume);
    72d4:	c8 01       	movw	r24, r16
    72d6:	0e 94 49 30 	call	0x6092	; 0x6092 <FormatCurrency>

          //Test
		  //RemZeroLead(strTotalMoney);
		  //RemZeroLead(strTotalVolume);

		  InserBorder(btTopLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btTopRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          
    72da:	81 e0       	ldi	r24, 0x01	; 1
    72dc:	6f ec       	ldi	r22, 0xCF	; 207
    72de:	75 e0       	ldi	r23, 0x05	; 5
    72e0:	41 e0       	ldi	r20, 0x01	; 1
    72e2:	22 e0       	ldi	r18, 0x02	; 2
    72e4:	32 e0       	ldi	r19, 0x02	; 2
    72e6:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <InserBorder>
    72ea:	8b e0       	ldi	r24, 0x0B	; 11
    72ec:	6f ec       	ldi	r22, 0xCF	; 207
    72ee:	75 e0       	ldi	r23, 0x05	; 5
    72f0:	4a e2       	ldi	r20, 0x2A	; 42
    72f2:	22 e0       	ldi	r18, 0x02	; 2
    72f4:	32 e0       	ldi	r19, 0x02	; 2
    72f6:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <InserBorder>
    72fa:	83 e0       	ldi	r24, 0x03	; 3
    72fc:	6f ec       	ldi	r22, 0xCF	; 207
    72fe:	75 e0       	ldi	r23, 0x05	; 5
    7300:	41 e0       	ldi	r20, 0x01	; 1
    7302:	22 e0       	ldi	r18, 0x02	; 2
    7304:	32 e0       	ldi	r19, 0x02	; 2
    7306:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <InserBorder>
    730a:	8c e0       	ldi	r24, 0x0C	; 12
    730c:	6f ec       	ldi	r22, 0xCF	; 207
    730e:	75 e0       	ldi	r23, 0x05	; 5
    7310:	41 e0       	ldi	r20, 0x01	; 1
    7312:	22 e0       	ldi	r18, 0x02	; 2
    7314:	32 e0       	ldi	r19, 0x02	; 2
    7316:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <InserBorder>
		  GetTabSpace((17-strlen(strTotalVolume)),strTabSpace);
    731a:	d8 01       	movw	r26, r16
    731c:	0d 90       	ld	r0, X+
    731e:	00 20       	and	r0, r0
    7320:	e9 f7       	brne	.-6      	; 0x731c <systemGenerateReport+0xfa8>
    7322:	8d 01       	movw	r16, r26
    7324:	01 50       	subi	r16, 0x01	; 1
    7326:	10 40       	sbci	r17, 0x00	; 0
    7328:	0c 5f       	subi	r16, 0xFC	; 252
    732a:	19 40       	sbci	r17, 0x09	; 9
    732c:	91 e1       	ldi	r25, 0x11	; 17
    732e:	90 1b       	sub	r25, r16
    7330:	de 01       	movw	r26, r28
    7332:	a7 59       	subi	r26, 0x97	; 151
    7334:	bf 4f       	sbci	r27, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    7336:	19 16       	cp	r1, r25
    7338:	7c f4       	brge	.+30     	; 0x7358 <systemGenerateReport+0xfe4>
    733a:	fd 01       	movw	r30, r26
    733c:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    733e:	20 e2       	ldi	r18, 0x20	; 32
    7340:	02 c0       	rjmp	.+4      	; 0x7346 <systemGenerateReport+0xfd2>
    7342:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    7344:	8f 5f       	subi	r24, 0xFF	; 255
    7346:	89 17       	cp	r24, r25
    7348:	e0 f3       	brcs	.-8      	; 0x7342 <systemGenerateReport+0xfce>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    734a:	fe 01       	movw	r30, r28
    734c:	e7 59       	subi	r30, 0x97	; 151
    734e:	ff 4f       	sbci	r31, 0xFF	; 255
    7350:	e9 0f       	add	r30, r25
    7352:	f1 1d       	adc	r31, r1
    7354:	10 82       	st	Z, r1
    7356:	04 c0       	rjmp	.+8      	; 0x7360 <systemGenerateReport+0xfec>
     }else{
	 strTab[0]=' ';
    7358:	80 e2       	ldi	r24, 0x20	; 32
    735a:	8c 93       	st	X, r24
	 strTab[1]=0;
    735c:	11 96       	adiw	r26, 0x01	; 1
    735e:	1c 92       	st	X, r1
		  //RemZeroLead(strTotalMoney);
		  //RemZeroLead(strTotalVolume);

		  InserBorder(btTopLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btTopRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          
		  GetTabSpace((17-strlen(strTotalVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strTotalMoney)),strTabSpace2);
    7360:	ed ea       	ldi	r30, 0xAD	; 173
    7362:	fa e0       	ldi	r31, 0x0A	; 10
    7364:	01 90       	ld	r0, Z+
    7366:	00 20       	and	r0, r0
    7368:	e9 f7       	brne	.-6      	; 0x7364 <systemGenerateReport+0xff0>
    736a:	31 97       	sbiw	r30, 0x01	; 1
    736c:	ed 5a       	subi	r30, 0xAD	; 173
    736e:	fa 40       	sbci	r31, 0x0A	; 10
    7370:	9f e0       	ldi	r25, 0x0F	; 15
    7372:	9e 1b       	sub	r25, r30
    7374:	fe 01       	movw	r30, r28
    7376:	e3 58       	subi	r30, 0x83	; 131
    7378:	ff 4f       	sbci	r31, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    737a:	19 16       	cp	r1, r25
    737c:	74 f4       	brge	.+28     	; 0x739a <systemGenerateReport+0x1026>
    737e:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    7380:	20 e2       	ldi	r18, 0x20	; 32
    7382:	02 c0       	rjmp	.+4      	; 0x7388 <systemGenerateReport+0x1014>
    7384:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    7386:	8f 5f       	subi	r24, 0xFF	; 255
    7388:	89 17       	cp	r24, r25
    738a:	e0 f3       	brcs	.-8      	; 0x7384 <systemGenerateReport+0x1010>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    738c:	fe 01       	movw	r30, r28
    738e:	e3 58       	subi	r30, 0x83	; 131
    7390:	ff 4f       	sbci	r31, 0xFF	; 255
    7392:	e9 0f       	add	r30, r25
    7394:	f1 1d       	adc	r31, r1
    7396:	10 82       	st	Z, r1
    7398:	03 c0       	rjmp	.+6      	; 0x73a0 <systemGenerateReport+0x102c>
     }else{
	 strTab[0]=' ';
    739a:	80 e2       	ldi	r24, 0x20	; 32
    739c:	80 83       	st	Z, r24
	 strTab[1]=0;
    739e:	11 82       	std	Z+1, r1	; 0x01
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    73a0:	e1 99       	sbic	0x1c, 1	; 28
    73a2:	fe cf       	rjmp	.-4      	; 0x73a0 <systemGenerateReport+0x102c>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    73a4:	e1 ec       	ldi	r30, 0xC1	; 193
    73a6:	f3 e0       	ldi	r31, 0x03	; 3
    73a8:	ff bb       	out	0x1f, r31	; 31
    73aa:	ee bb       	out	0x1e, r30	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    73ac:	e0 9a       	sbi	0x1c, 0	; 28
    73ae:	8d b3       	in	r24, 0x1d	; 29
    73b0:	9e 01       	movw	r18, r28
    73b2:	2b 55       	subi	r18, 0x5B	; 91
    73b4:	3f 4f       	sbci	r19, 0xFF	; 255
    73b6:	4c ef       	ldi	r20, 0xFC	; 252
    73b8:	59 e0       	ldi	r21, 0x09	; 9
    73ba:	de 01       	movw	r26, r28
    73bc:	a7 59       	subi	r26, 0x97	; 151
    73be:	bf 4f       	sbci	r27, 0xFF	; 255

		  InserBorder(btTopLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btTopRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);          
		  GetTabSpace((17-strlen(strTotalVolume)),strTabSpace);
		  GetTabSpace((15-strlen(strTotalMoney)),strTabSpace2);
          //PrintMoney
		  if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("TOTAL %s%s%s%s"),strTabSpace,strTotalVolume,strTabSpace2,strTotalMoney);//CreateReport(strReport,PrintBuffer,&RepPos);
    73c0:	81 30       	cpi	r24, 0x01	; 1
    73c2:	41 f5       	brne	.+80     	; 0x7414 <systemGenerateReport+0x10a0>
    73c4:	8d b7       	in	r24, 0x3d	; 61
    73c6:	9e b7       	in	r25, 0x3e	; 62
    73c8:	0c 97       	sbiw	r24, 0x0c	; 12
    73ca:	0f b6       	in	r0, 0x3f	; 63
    73cc:	f8 94       	cli
    73ce:	9e bf       	out	0x3e, r25	; 62
    73d0:	0f be       	out	0x3f, r0	; 63
    73d2:	8d bf       	out	0x3d, r24	; 61
    73d4:	6d b7       	in	r22, 0x3d	; 61
    73d6:	7e b7       	in	r23, 0x3e	; 62
    73d8:	6f 5f       	subi	r22, 0xFF	; 255
    73da:	7f 4f       	sbci	r23, 0xFF	; 255
    73dc:	ed b7       	in	r30, 0x3d	; 61
    73de:	fe b7       	in	r31, 0x3e	; 62
    73e0:	32 83       	std	Z+2, r19	; 0x02
    73e2:	21 83       	std	Z+1, r18	; 0x01
    73e4:	80 e2       	ldi	r24, 0x20	; 32
    73e6:	94 e0       	ldi	r25, 0x04	; 4
    73e8:	fb 01       	movw	r30, r22
    73ea:	93 83       	std	Z+3, r25	; 0x03
    73ec:	82 83       	std	Z+2, r24	; 0x02
    73ee:	b5 83       	std	Z+5, r27	; 0x05
    73f0:	a4 83       	std	Z+4, r26	; 0x04
    73f2:	57 83       	std	Z+7, r21	; 0x07
    73f4:	46 83       	std	Z+6, r20	; 0x06
    73f6:	ce 01       	movw	r24, r28
    73f8:	83 58       	subi	r24, 0x83	; 131
    73fa:	9f 4f       	sbci	r25, 0xFF	; 255
    73fc:	91 87       	std	Z+9, r25	; 0x09
    73fe:	80 87       	std	Z+8, r24	; 0x08
    7400:	8d ea       	ldi	r24, 0xAD	; 173
    7402:	9a e0       	ldi	r25, 0x0A	; 10
    7404:	93 87       	std	Z+11, r25	; 0x0b
    7406:	82 87       	std	Z+10, r24	; 0x0a
    7408:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    740c:	8d b7       	in	r24, 0x3d	; 61
    740e:	9e b7       	in	r25, 0x3e	; 62
    7410:	0c 96       	adiw	r24, 0x0c	; 12
    7412:	1c c0       	rjmp	.+56     	; 0x744c <systemGenerateReport+0x10d8>
		  else sprintf_P(strReport,PSTR("TOTAL %s%s"),strTabSpace,strTotalVolume);CreateReport(strReport,PrintBuffer,&RepPos);
    7414:	ed b7       	in	r30, 0x3d	; 61
    7416:	fe b7       	in	r31, 0x3e	; 62
    7418:	38 97       	sbiw	r30, 0x08	; 8
    741a:	0f b6       	in	r0, 0x3f	; 63
    741c:	f8 94       	cli
    741e:	fe bf       	out	0x3e, r31	; 62
    7420:	0f be       	out	0x3f, r0	; 63
    7422:	ed bf       	out	0x3d, r30	; 61
    7424:	6d b7       	in	r22, 0x3d	; 61
    7426:	7e b7       	in	r23, 0x3e	; 62
    7428:	6f 5f       	subi	r22, 0xFF	; 255
    742a:	7f 4f       	sbci	r23, 0xFF	; 255
    742c:	32 83       	std	Z+2, r19	; 0x02
    742e:	21 83       	std	Z+1, r18	; 0x01
    7430:	85 e1       	ldi	r24, 0x15	; 21
    7432:	94 e0       	ldi	r25, 0x04	; 4
    7434:	fb 01       	movw	r30, r22
    7436:	93 83       	std	Z+3, r25	; 0x03
    7438:	82 83       	std	Z+2, r24	; 0x02
    743a:	b5 83       	std	Z+5, r27	; 0x05
    743c:	a4 83       	std	Z+4, r26	; 0x04
    743e:	57 83       	std	Z+7, r21	; 0x07
    7440:	46 83       	std	Z+6, r20	; 0x06
    7442:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    7446:	8d b7       	in	r24, 0x3d	; 61
    7448:	9e b7       	in	r25, 0x3e	; 62
    744a:	08 96       	adiw	r24, 0x08	; 8
    744c:	0f b6       	in	r0, 0x3f	; 63
    744e:	f8 94       	cli
    7450:	9e bf       	out	0x3e, r25	; 62
    7452:	0f be       	out	0x3f, r0	; 63
    7454:	8d bf       	out	0x3d, r24	; 61
    7456:	ce 01       	movw	r24, r28
    7458:	8b 55       	subi	r24, 0x5B	; 91
    745a:	9f 4f       	sbci	r25, 0xFF	; 255
    745c:	6f ec       	ldi	r22, 0xCF	; 207
    745e:	75 e0       	ldi	r23, 0x05	; 5
    7460:	42 e0       	ldi	r20, 0x02	; 2
    7462:	52 e0       	ldi	r21, 0x02	; 2
    7464:	0e 94 ad 20 	call	0x415a	; 0x415a <CreateReport>

		  InserBorder(btMiddleLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btMiddleRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);     	      
    7468:	84 e0       	ldi	r24, 0x04	; 4
    746a:	6f ec       	ldi	r22, 0xCF	; 207
    746c:	75 e0       	ldi	r23, 0x05	; 5
    746e:	41 e0       	ldi	r20, 0x01	; 1
    7470:	22 e0       	ldi	r18, 0x02	; 2
    7472:	32 e0       	ldi	r19, 0x02	; 2
    7474:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <InserBorder>
    7478:	8b e0       	ldi	r24, 0x0B	; 11
    747a:	6f ec       	ldi	r22, 0xCF	; 207
    747c:	75 e0       	ldi	r23, 0x05	; 5
    747e:	4a e2       	ldi	r20, 0x2A	; 42
    7480:	22 e0       	ldi	r18, 0x02	; 2
    7482:	32 e0       	ldi	r19, 0x02	; 2
    7484:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <InserBorder>
    7488:	86 e0       	ldi	r24, 0x06	; 6
    748a:	6f ec       	ldi	r22, 0xCF	; 207
    748c:	75 e0       	ldi	r23, 0x05	; 5
    748e:	41 e0       	ldi	r20, 0x01	; 1
    7490:	22 e0       	ldi	r18, 0x02	; 2
    7492:	32 e0       	ldi	r19, 0x02	; 2
    7494:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <InserBorder>
    7498:	8c e0       	ldi	r24, 0x0C	; 12
    749a:	6f ec       	ldi	r22, 0xCF	; 207
    749c:	75 e0       	ldi	r23, 0x05	; 5
    749e:	41 e0       	ldi	r20, 0x01	; 1
    74a0:	22 e0       	ldi	r18, 0x02	; 2
    74a2:	32 e0       	ldi	r19, 0x02	; 2
    74a4:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <InserBorder>
    74a8:	ee 24       	eor	r14, r14

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    74aa:	b8 e2       	ldi	r27, 0x28	; 40
    74ac:	2b 2e       	mov	r2, r27
    74ae:	31 2c       	mov	r3, r1
    74b0:	2c 0e       	add	r2, r28
    74b2:	3d 1e       	adc	r3, r29
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    74b4:	a7 e3       	ldi	r26, 0x37	; 55
    74b6:	6a 2e       	mov	r6, r26
    74b8:	71 2c       	mov	r7, r1
    74ba:	6c 0e       	add	r6, r28
    74bc:	7d 1e       	adc	r7, r29
    74be:	d3 01       	movw	r26, r6
    74c0:	1f 96       	adiw	r26, 0x0f	; 15
    74c2:	cb 50       	subi	r28, 0x0B	; 11
    74c4:	df 4f       	sbci	r29, 0xFF	; 255
    74c6:	b9 83       	std	Y+1, r27	; 0x01
    74c8:	a8 83       	st	Y, r26
    74ca:	c5 5f       	subi	r28, 0xF5	; 245
    74cc:	d0 40       	sbci	r29, 0x00	; 0
    74ce:	f6 e4       	ldi	r31, 0x46	; 70
    74d0:	4f 2e       	mov	r4, r31
    74d2:	51 2c       	mov	r5, r1
    74d4:	4c 0e       	add	r4, r28
    74d6:	5d 1e       	adc	r5, r29
    74d8:	f2 01       	movw	r30, r4
    74da:	3f 96       	adiw	r30, 0x0f	; 15
    74dc:	c9 50       	subi	r28, 0x09	; 9
    74de:	df 4f       	sbci	r29, 0xFF	; 255
    74e0:	f9 83       	std	Y+1, r31	; 0x01
    74e2:	e8 83       	st	Y, r30
    74e4:	c7 5f       	subi	r28, 0xF7	; 247
    74e6:	d0 40       	sbci	r29, 0x00	; 0
    74e8:	ed e7       	ldi	r30, 0x7D	; 125
    74ea:	8e 2e       	mov	r8, r30
    74ec:	91 2c       	mov	r9, r1
    74ee:	8c 0e       	add	r8, r28
    74f0:	9d 1e       	adc	r9, r29
    74f2:	e3 c1       	rjmp	.+966    	; 0x78ba <systemGenerateReport+0x1546>
    74f4:	f5 01       	movw	r30, r10
    74f6:	ec 5f       	subi	r30, 0xFC	; 252
    74f8:	fd 4f       	sbci	r31, 0xFD	; 253
    74fa:	80 81       	ld	r24, Z
    74fc:	80 53       	subi	r24, 0x30	; 48
    74fe:	8a 30       	cpi	r24, 0x0A	; 10
    7500:	08 f0       	brcs	.+2      	; 0x7504 <systemGenerateReport+0x1190>
    7502:	80 e0       	ldi	r24, 0x00	; 0
		  else sprintf_P(strReport,PSTR("TOTAL %s%s"),strTabSpace,strTotalVolume);CreateReport(strReport,PrintBuffer,&RepPos);

		  InserBorder(btMiddleLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btMiddleRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);     	      

		  for(iTotal=0;iTotal<strlen(GradeList);iTotal++){
		      xGrade=Ord(GradeList[iTotal]);
    7504:	80 93 11 02 	sts	0x0211, r24
			  if (xGrade>0){
    7508:	88 23       	and	r24, r24
    750a:	09 f4       	brne	.+2      	; 0x750e <systemGenerateReport+0x119a>
    750c:	d5 c1       	rjmp	.+938    	; 0x78b8 <systemGenerateReport+0x1544>
			      GetProductName(xGrade,strProduct);
    750e:	61 e4       	ldi	r22, 0x41	; 65
    7510:	79 e0       	ldi	r23, 0x09	; 9
    7512:	0e 94 f3 2a 	call	0x55e6	; 0x55e6 <GetProductName>
    7516:	ec ef       	ldi	r30, 0xFC	; 252
    7518:	f9 e0       	ldi	r31, 0x09	; 9
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    751a:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    751c:	8a e0       	ldi	r24, 0x0A	; 10
    751e:	e0 31       	cpi	r30, 0x10	; 16
    7520:	f8 07       	cpc	r31, r24
    7522:	d9 f7       	brne	.-10     	; 0x751a <systemGenerateReport+0x11a6>
    7524:	ed ea       	ldi	r30, 0xAD	; 173
    7526:	fa e0       	ldi	r31, 0x0A	; 10
	     strMemory[i]=data;
    7528:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    752a:	9a e0       	ldi	r25, 0x0A	; 10
    752c:	e1 3c       	cpi	r30, 0xC1	; 193
    752e:	f9 07       	cpc	r31, r25
    7530:	d9 f7       	brne	.-10     	; 0x7528 <systemGenerateReport+0x11b4>
			      GetProductName(xGrade,strProduct);
				  
				  FillChar(strTotalVolume,sizeof(strTotalVolume),0);
				  FillChar(strTotalMoney,sizeof(strTotalMoney),0);

				  for(xPump=1;xPump<=8;xPump++){
    7532:	81 e0       	ldi	r24, 0x01	; 1
    7534:	80 93 13 02 	sts	0x0213, r24

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    7538:	79 e1       	ldi	r23, 0x19	; 25
    753a:	c7 2e       	mov	r12, r23
    753c:	d1 2c       	mov	r13, r1
    753e:	cc 0e       	add	r12, r28
    7540:	dd 1e       	adc	r13, r29
    7542:	e6 c0       	rjmp	.+460    	; 0x7710 <systemGenerateReport+0x139c>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    7544:	ce 01       	movw	r24, r28
    7546:	07 96       	adiw	r24, 0x07	; 7
    7548:	65 e4       	ldi	r22, 0x45	; 69
    754a:	70 e0       	ldi	r23, 0x00	; 0
    754c:	48 e0       	ldi	r20, 0x08	; 8
    754e:	50 e0       	ldi	r21, 0x00	; 0
    7550:	23 ef       	ldi	r18, 0xF3	; 243
    7552:	32 e1       	ldi	r19, 0x12	; 18
    7554:	0e 94 1f b4 	call	0x1683e	; 0x1683e <__eerd_block>
				  FillChar(strTotalVolume,sizeof(strTotalVolume),0);
				  FillChar(strTotalMoney,sizeof(strTotalMoney),0);

				  for(xPump=1;xPump<=8;xPump++){
				      eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap, 8);
			          PumpNum=PPumpID[xPump-1];
    7558:	80 91 13 02 	lds	r24, 0x0213
    755c:	fe 01       	movw	r30, r28
    755e:	e8 0f       	add	r30, r24
    7560:	f1 1d       	adc	r31, r1
    7562:	86 81       	ldd	r24, Z+6	; 0x06
    7564:	80 93 10 02 	sts	0x0210, r24
					  if (PumpNum>0){
    7568:	88 23       	and	r24, r24
    756a:	09 f4       	brne	.+2      	; 0x756e <systemGenerateReport+0x11fa>
    756c:	cc c0       	rjmp	.+408    	; 0x7706 <systemGenerateReport+0x1392>
						  for (xNozzle=1;xNozzle<=6;xNozzle++){
    756e:	81 e0       	ldi	r24, 0x01	; 1
    7570:	c3 c0       	rjmp	.+390    	; 0x76f8 <systemGenerateReport+0x1384>
    7572:	60 91 13 02 	lds	r22, 0x0213
    7576:	a6 e0       	ldi	r26, 0x06	; 6
    7578:	6a 9f       	mul	r22, r26
    757a:	b0 01       	movw	r22, r0
    757c:	11 24       	eor	r1, r1
    757e:	61 5b       	subi	r22, 0xB1	; 177
    7580:	7f 4f       	sbci	r23, 0xFF	; 255
    7582:	ce 01       	movw	r24, r28
    7584:	01 96       	adiw	r24, 0x01	; 1
    7586:	46 e0       	ldi	r20, 0x06	; 6
    7588:	50 e0       	ldi	r21, 0x00	; 0
    758a:	23 ef       	ldi	r18, 0xF3	; 243
    758c:	32 e1       	ldi	r19, 0x12	; 18
    758e:	0e 94 1f b4 	call	0x1683e	; 0x1683e <__eerd_block>
							  eeprom_read_block((void*) &PProductID, (const void*) &DefNozzleMap[xPump-1], 6);
							  //Found Grade
						      if (PProductID[xNozzle-1]==xGrade){
    7592:	80 91 12 02 	lds	r24, 0x0212
    7596:	fe 01       	movw	r30, r28
    7598:	e8 0f       	add	r30, r24
    759a:	f1 1d       	adc	r31, r1
    759c:	90 81       	ld	r25, Z
    759e:	80 91 11 02 	lds	r24, 0x0211
    75a2:	98 17       	cp	r25, r24
    75a4:	09 f0       	breq	.+2      	; 0x75a8 <systemGenerateReport+0x1234>
    75a6:	a5 c0       	rjmp	.+330    	; 0x76f2 <systemGenerateReport+0x137e>
    75a8:	e8 e0       	ldi	r30, 0x08	; 8
    75aa:	fe e0       	ldi	r31, 0x0E	; 14
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    75ac:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    75ae:	be e0       	ldi	r27, 0x0E	; 14
    75b0:	e7 31       	cpi	r30, 0x17	; 23
    75b2:	fb 07       	cpc	r31, r27
    75b4:	d9 f7       	brne	.-10     	; 0x75ac <systemGenerateReport+0x1238>
    75b6:	ed ed       	ldi	r30, 0xDD	; 221
    75b8:	fa e0       	ldi	r31, 0x0A	; 10
	     strMemory[i]=data;
    75ba:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    75bc:	8a e0       	ldi	r24, 0x0A	; 10
    75be:	ec 3e       	cpi	r30, 0xEC	; 236
    75c0:	f8 07       	cpc	r31, r24
    75c2:	d9 f7       	brne	.-10     	; 0x75ba <systemGenerateReport+0x1246>
    75c4:	f6 01       	movw	r30, r12
	     strMemory[i]=data;
    75c6:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    75c8:	e2 15       	cp	r30, r2
    75ca:	f3 05       	cpc	r31, r3
    75cc:	e1 f7       	brne	.-8      	; 0x75c6 <systemGenerateReport+0x1252>
    75ce:	f1 01       	movw	r30, r2
	     strMemory[i]=data;
    75d0:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    75d2:	e6 15       	cp	r30, r6
    75d4:	f7 05       	cpc	r31, r7
    75d6:	e1 f7       	brne	.-8      	; 0x75d0 <systemGenerateReport+0x125c>
    75d8:	f3 01       	movw	r30, r6
	     strMemory[i]=data;
    75da:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    75dc:	cb 50       	subi	r28, 0x0B	; 11
    75de:	df 4f       	sbci	r29, 0xFF	; 255
    75e0:	a8 81       	ld	r26, Y
    75e2:	b9 81       	ldd	r27, Y+1	; 0x01
    75e4:	c5 5f       	subi	r28, 0xF5	; 245
    75e6:	d0 40       	sbci	r29, 0x00	; 0
    75e8:	ea 17       	cp	r30, r26
    75ea:	fb 07       	cpc	r31, r27
    75ec:	b1 f7       	brne	.-20     	; 0x75da <systemGenerateReport+0x1266>
    75ee:	f2 01       	movw	r30, r4
	     strMemory[i]=data;
    75f0:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    75f2:	c9 50       	subi	r28, 0x09	; 9
    75f4:	df 4f       	sbci	r29, 0xFF	; 255
    75f6:	88 81       	ld	r24, Y
    75f8:	99 81       	ldd	r25, Y+1	; 0x01
    75fa:	c7 5f       	subi	r28, 0xF7	; 247
    75fc:	d0 40       	sbci	r29, 0x00	; 0
    75fe:	e8 17       	cp	r30, r24
    7600:	f9 07       	cpc	r31, r25
    7602:	b1 f7       	brne	.-20     	; 0x75f0 <systemGenerateReport+0x127c>
								  FillChar(strLastVolume,sizeof(strLastVolume),0);
								  FillChar(strLastMoney,sizeof(strLastMoney),0);
								  FillChar(strCurrentVolume,sizeof(strCurrentVolume),0);
								  FillChar(strCurrentMoney,sizeof(strCurrentMoney),0);

								  PumpNozzle=xNozzle;
    7604:	80 91 12 02 	lds	r24, 0x0212
    7608:	80 93 0f 02 	sts	0x020F, r24
								  
								  FIPAddr=GetFIPAddr(PumpNum); 
    760c:	80 91 10 02 	lds	r24, 0x0210
    7610:	0e 94 39 1c 	call	0x3872	; 0x3872 <GetFIPAddr>
								  if (FIPAddr>0){
    7614:	88 23       	and	r24, r24
    7616:	11 f1       	breq	.+68     	; 0x765c <systemGenerateReport+0x12e8>
									  FIPAddr=FIPAddr-1;							  							  							      
    7618:	f8 2e       	mov	r15, r24
    761a:	fa 94       	dec	r15
									  GetTotalizerData(TVOLUME,TOTALIZER_LAST,FIPAddr,PumpNozzle,strLastVolume);
    761c:	80 e0       	ldi	r24, 0x00	; 0
    761e:	60 e0       	ldi	r22, 0x00	; 0
    7620:	4f 2d       	mov	r20, r15
    7622:	20 91 0f 02 	lds	r18, 0x020F
    7626:	86 01       	movw	r16, r12
    7628:	0e 94 f8 1c 	call	0x39f0	; 0x39f0 <GetTotalizerData>
									  GetTotalizerData(TMONEY,TOTALIZER_LAST,FIPAddr,PumpNozzle,strLastMoney);
    762c:	81 e0       	ldi	r24, 0x01	; 1
    762e:	60 e0       	ldi	r22, 0x00	; 0
    7630:	4f 2d       	mov	r20, r15
    7632:	20 91 0f 02 	lds	r18, 0x020F
    7636:	81 01       	movw	r16, r2
    7638:	0e 94 f8 1c 	call	0x39f0	; 0x39f0 <GetTotalizerData>

									  GetTotalizerData(TVOLUME,TOTALIZER_NOW,FIPAddr,PumpNozzle,strCurrentVolume);
    763c:	80 e0       	ldi	r24, 0x00	; 0
    763e:	61 e0       	ldi	r22, 0x01	; 1
    7640:	4f 2d       	mov	r20, r15
    7642:	20 91 0f 02 	lds	r18, 0x020F
    7646:	83 01       	movw	r16, r6
    7648:	0e 94 f8 1c 	call	0x39f0	; 0x39f0 <GetTotalizerData>
									  GetTotalizerData(TMONEY,TOTALIZER_NOW,FIPAddr,PumpNozzle,strCurrentMoney);
    764c:	81 e0       	ldi	r24, 0x01	; 1
    764e:	61 e0       	ldi	r22, 0x01	; 1
    7650:	4f 2d       	mov	r20, r15
    7652:	20 91 0f 02 	lds	r18, 0x020F
    7656:	82 01       	movw	r16, r4
    7658:	0e 94 f8 1c 	call	0x39f0	; 0x39f0 <GetTotalizerData>
								  }

								  StrCalc(TMINUS,strCurrentVolume,strLastVolume,strDeltaVolume);
    765c:	80 e0       	ldi	r24, 0x00	; 0
    765e:	b3 01       	movw	r22, r6
    7660:	a6 01       	movw	r20, r12
    7662:	2d ed       	ldi	r18, 0xDD	; 221
    7664:	3a e0       	ldi	r19, 0x0A	; 10
    7666:	0e 94 8b 26 	call	0x4d16	; 0x4d16 <StrCalc>
								  if (IsMinus(strDeltaVolume)==True)
    766a:	8d ed       	ldi	r24, 0xDD	; 221
    766c:	9a e0       	ldi	r25, 0x0A	; 10
    766e:	0e 94 12 22 	call	0x4424	; 0x4424 <IsMinus>
    7672:	81 30       	cpi	r24, 0x01	; 1
    7674:	21 f4       	brne	.+8      	; 0x767e <systemGenerateReport+0x130a>
								      NormalizeOverflow(strDeltaVolume);
    7676:	8d ed       	ldi	r24, 0xDD	; 221
    7678:	9a e0       	ldi	r25, 0x0A	; 10
    767a:	0e 94 22 2a 	call	0x5444	; 0x5444 <NormalizeOverflow>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    767e:	e1 99       	sbic	0x1c, 1	; 28
    7680:	fe cf       	rjmp	.-4      	; 0x767e <systemGenerateReport+0x130a>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    7682:	a7 e3       	ldi	r26, 0x37	; 55
    7684:	b1 e0       	ldi	r27, 0x01	; 1
    7686:	bf bb       	out	0x1f, r27	; 31
    7688:	ae bb       	out	0x1e, r26	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    768a:	e0 9a       	sbi	0x1c, 0	; 28
    768c:	8d b3       	in	r24, 0x1d	; 29


								  //Calculate Wayne Estimated Total Money
								  if (eeprom_read_byte(&DefDispenserBrand)==ST_WAYNE_DART){
    768e:	82 30       	cpi	r24, 0x02	; 2
    7690:	79 f4       	brne	.+30     	; 0x76b0 <systemGenerateReport+0x133c>
						              GetProductPrice(sPrice,PumpNum,PumpNozzle);//Money = Price x Volume
    7692:	ce 01       	movw	r24, r28
    7694:	0f 96       	adiw	r24, 0x0f	; 15
    7696:	60 91 10 02 	lds	r22, 0x0210
    769a:	40 91 0f 02 	lds	r20, 0x020F
    769e:	0e 94 f5 22 	call	0x45ea	; 0x45ea <GetProductPrice>
									  StrCalc(TMULTIPLY,sPrice,strDeltaVolume,strDeltaMoney);
    76a2:	82 e0       	ldi	r24, 0x02	; 2
    76a4:	be 01       	movw	r22, r28
    76a6:	61 5f       	subi	r22, 0xF1	; 241
    76a8:	7f 4f       	sbci	r23, 0xFF	; 255
    76aa:	4d ed       	ldi	r20, 0xDD	; 221
    76ac:	5a e0       	ldi	r21, 0x0A	; 10
    76ae:	03 c0       	rjmp	.+6      	; 0x76b6 <systemGenerateReport+0x1342>
								  }else StrCalc(TMINUS,strCurrentMoney,strLastMoney,strDeltaMoney);
    76b0:	80 e0       	ldi	r24, 0x00	; 0
    76b2:	b2 01       	movw	r22, r4
    76b4:	a1 01       	movw	r20, r2
    76b6:	28 e0       	ldi	r18, 0x08	; 8
    76b8:	3e e0       	ldi	r19, 0x0E	; 14
    76ba:	0e 94 8b 26 	call	0x4d16	; 0x4d16 <StrCalc>
								  //StrCalc(TMINUS,strCurrentMoney,strLastMoney,strDeltaMoney);
								  if (IsMinus(strDeltaMoney)==True)
    76be:	88 e0       	ldi	r24, 0x08	; 8
    76c0:	9e e0       	ldi	r25, 0x0E	; 14
    76c2:	0e 94 12 22 	call	0x4424	; 0x4424 <IsMinus>
    76c6:	81 30       	cpi	r24, 0x01	; 1
    76c8:	21 f4       	brne	.+8      	; 0x76d2 <systemGenerateReport+0x135e>
								      NormalizeOverflow(strDeltaMoney);
    76ca:	88 e0       	ldi	r24, 0x08	; 8
    76cc:	9e e0       	ldi	r25, 0x0E	; 14
    76ce:	0e 94 22 2a 	call	0x5444	; 0x5444 <NormalizeOverflow>
		  
								  StrCalc(TPLUS,strTotalVolume,strDeltaVolume,strTotalVolume);
    76d2:	81 e0       	ldi	r24, 0x01	; 1
    76d4:	6c ef       	ldi	r22, 0xFC	; 252
    76d6:	79 e0       	ldi	r23, 0x09	; 9
    76d8:	4d ed       	ldi	r20, 0xDD	; 221
    76da:	5a e0       	ldi	r21, 0x0A	; 10
    76dc:	9b 01       	movw	r18, r22
    76de:	0e 94 8b 26 	call	0x4d16	; 0x4d16 <StrCalc>
								  StrCalc(TPLUS,strTotalMoney,strDeltaMoney,strTotalMoney);
    76e2:	81 e0       	ldi	r24, 0x01	; 1
    76e4:	6d ea       	ldi	r22, 0xAD	; 173
    76e6:	7a e0       	ldi	r23, 0x0A	; 10
    76e8:	48 e0       	ldi	r20, 0x08	; 8
    76ea:	5e e0       	ldi	r21, 0x0E	; 14
    76ec:	9b 01       	movw	r18, r22
    76ee:	0e 94 8b 26 	call	0x4d16	; 0x4d16 <StrCalc>

				  for(xPump=1;xPump<=8;xPump++){
				      eeprom_read_block((void*) &PPumpID, (const void*) &DefPumpMap, 8);
			          PumpNum=PPumpID[xPump-1];
					  if (PumpNum>0){
						  for (xNozzle=1;xNozzle<=6;xNozzle++){
    76f2:	80 91 12 02 	lds	r24, 0x0212
    76f6:	8f 5f       	subi	r24, 0xFF	; 255
    76f8:	80 93 12 02 	sts	0x0212, r24
    76fc:	80 91 12 02 	lds	r24, 0x0212
    7700:	87 30       	cpi	r24, 0x07	; 7
    7702:	08 f4       	brcc	.+2      	; 0x7706 <systemGenerateReport+0x1392>
    7704:	36 cf       	rjmp	.-404    	; 0x7572 <systemGenerateReport+0x11fe>
			      GetProductName(xGrade,strProduct);
				  
				  FillChar(strTotalVolume,sizeof(strTotalVolume),0);
				  FillChar(strTotalMoney,sizeof(strTotalMoney),0);

				  for(xPump=1;xPump<=8;xPump++){
    7706:	80 91 13 02 	lds	r24, 0x0213
    770a:	8f 5f       	subi	r24, 0xFF	; 255
    770c:	80 93 13 02 	sts	0x0213, r24
    7710:	80 91 13 02 	lds	r24, 0x0213
    7714:	89 30       	cpi	r24, 0x09	; 9
    7716:	08 f4       	brcc	.+2      	; 0x771a <systemGenerateReport+0x13a6>
    7718:	15 cf       	rjmp	.-470    	; 0x7544 <systemGenerateReport+0x11d0>
							  }
						  }
					  }				  
				  }

				  RemZeroLead(strTotalMoney);
    771a:	8d ea       	ldi	r24, 0xAD	; 173
    771c:	9a e0       	ldi	r25, 0x0A	; 10
    771e:	0e 94 dd 23 	call	0x47ba	; 0x47ba <RemZeroLead>
				  RemZeroLead(strTotalVolume);
    7722:	0c ef       	ldi	r16, 0xFC	; 252
    7724:	19 e0       	ldi	r17, 0x09	; 9
    7726:	c8 01       	movw	r24, r16
    7728:	0e 94 dd 23 	call	0x47ba	; 0x47ba <RemZeroLead>

				  FormatTotalizerMoney(strTotalMoney);
    772c:	8d ea       	ldi	r24, 0xAD	; 173
    772e:	9a e0       	ldi	r25, 0x0A	; 10
    7730:	0e 94 86 31 	call	0x630c	; 0x630c <FormatTotalizerMoney>
				  FormatCurrency(strTotalMoney);
    7734:	8d ea       	ldi	r24, 0xAD	; 173
    7736:	9a e0       	ldi	r25, 0x0A	; 10
    7738:	0e 94 49 30 	call	0x6092	; 0x6092 <FormatCurrency>

				  FormatTotalizerVolume(strTotalVolume);
    773c:	c8 01       	movw	r24, r16
    773e:	0e 94 79 31 	call	0x62f2	; 0x62f2 <FormatTotalizerVolume>
				  FormatCurrency(strTotalVolume);
    7742:	c8 01       	movw	r24, r16
    7744:	0e 94 49 30 	call	0x6092	; 0x6092 <FormatCurrency>
		          //Test
				 // RemZeroLead(strTotalMoney);
				 // RemZeroLead(strTotalVolume);


			      GetTabSpace((21-strlen(strProduct)-strlen(strTotalVolume)),strTabSpace);
    7748:	e1 e4       	ldi	r30, 0x41	; 65
    774a:	f9 e0       	ldi	r31, 0x09	; 9
    774c:	01 90       	ld	r0, Z+
    774e:	00 20       	and	r0, r0
    7750:	e9 f7       	brne	.-6      	; 0x774c <systemGenerateReport+0x13d8>
    7752:	31 97       	sbiw	r30, 0x01	; 1
    7754:	e1 54       	subi	r30, 0x41	; 65
    7756:	f9 40       	sbci	r31, 0x09	; 9
    7758:	d8 01       	movw	r26, r16
    775a:	0d 90       	ld	r0, X+
    775c:	00 20       	and	r0, r0
    775e:	e9 f7       	brne	.-6      	; 0x775a <systemGenerateReport+0x13e6>
    7760:	8d 01       	movw	r16, r26
    7762:	01 50       	subi	r16, 0x01	; 1
    7764:	10 40       	sbci	r17, 0x00	; 0
    7766:	0c 5f       	subi	r16, 0xFC	; 252
    7768:	19 40       	sbci	r17, 0x09	; 9
    776a:	8e 2f       	mov	r24, r30
    776c:	81 95       	neg	r24
    776e:	80 1b       	sub	r24, r16
    7770:	8b 5e       	subi	r24, 0xEB	; 235
    7772:	de 01       	movw	r26, r28
    7774:	a7 59       	subi	r26, 0x97	; 151
    7776:	bf 4f       	sbci	r27, 0xFF	; 255
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    7778:	18 16       	cp	r1, r24
    777a:	7c f4       	brge	.+30     	; 0x779a <systemGenerateReport+0x1426>
    777c:	fd 01       	movw	r30, r26
    777e:	90 e0       	ldi	r25, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    7780:	20 e2       	ldi	r18, 0x20	; 32
    7782:	02 c0       	rjmp	.+4      	; 0x7788 <systemGenerateReport+0x1414>
    7784:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    7786:	9f 5f       	subi	r25, 0xFF	; 255
    7788:	98 17       	cp	r25, r24
    778a:	e0 f3       	brcs	.-8      	; 0x7784 <systemGenerateReport+0x1410>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    778c:	fe 01       	movw	r30, r28
    778e:	e7 59       	subi	r30, 0x97	; 151
    7790:	ff 4f       	sbci	r31, 0xFF	; 255
    7792:	e8 0f       	add	r30, r24
    7794:	f1 1d       	adc	r31, r1
    7796:	10 82       	st	Z, r1
    7798:	04 c0       	rjmp	.+8      	; 0x77a2 <systemGenerateReport+0x142e>
     }else{
	 strTab[0]=' ';
    779a:	80 e2       	ldi	r24, 0x20	; 32
    779c:	8c 93       	st	X, r24
	 strTab[1]=0;
    779e:	11 96       	adiw	r26, 0x01	; 1
    77a0:	1c 92       	st	X, r1
				 // RemZeroLead(strTotalMoney);
				 // RemZeroLead(strTotalVolume);


			      GetTabSpace((21-strlen(strProduct)-strlen(strTotalVolume)),strTabSpace);
			      GetTabSpace((15-strlen(strTotalMoney)),strTabSpace2);
    77a2:	ed ea       	ldi	r30, 0xAD	; 173
    77a4:	fa e0       	ldi	r31, 0x0A	; 10
    77a6:	01 90       	ld	r0, Z+
    77a8:	00 20       	and	r0, r0
    77aa:	e9 f7       	brne	.-6      	; 0x77a6 <systemGenerateReport+0x1432>
    77ac:	31 97       	sbiw	r30, 0x01	; 1
    77ae:	ed 5a       	subi	r30, 0xAD	; 173
    77b0:	fa 40       	sbci	r31, 0x0A	; 10
    77b2:	9f e0       	ldi	r25, 0x0F	; 15
    77b4:	9e 1b       	sub	r25, r30
	 sprintf_P(strC,PSTR("%s"),prevSeg);
}

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
    77b6:	19 16       	cp	r1, r25
    77b8:	6c f4       	brge	.+26     	; 0x77d4 <systemGenerateReport+0x1460>
    77ba:	f4 01       	movw	r30, r8
    77bc:	80 e0       	ldi	r24, 0x00	; 0
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
		     strTab[i]=' ';
    77be:	20 e2       	ldi	r18, 0x20	; 32
    77c0:	02 c0       	rjmp	.+4      	; 0x77c6 <systemGenerateReport+0x1452>
    77c2:	21 93       	st	Z+, r18

void GetTabSpace(signed char TabLength, char *strTab){
     char i,nTab;
	 if (TabLength>0){
		 nTab=TabLength;//%40;
		 for(i=0;i<nTab;i++){
    77c4:	8f 5f       	subi	r24, 0xFF	; 255
    77c6:	89 17       	cp	r24, r25
    77c8:	e0 f3       	brcs	.-8      	; 0x77c2 <systemGenerateReport+0x144e>
		     strTab[i]=' ';
		 }strTab[nTab]=0;
    77ca:	f4 01       	movw	r30, r8
    77cc:	e9 0f       	add	r30, r25
    77ce:	f1 1d       	adc	r31, r1
    77d0:	10 82       	st	Z, r1
    77d2:	04 c0       	rjmp	.+8      	; 0x77dc <systemGenerateReport+0x1468>
     }else{
	 strTab[0]=' ';
    77d4:	80 e2       	ldi	r24, 0x20	; 32
    77d6:	f4 01       	movw	r30, r8
    77d8:	80 83       	st	Z, r24
	 strTab[1]=0;
    77da:	11 82       	std	Z+1, r1	; 0x01
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    77dc:	e1 99       	sbic	0x1c, 1	; 28
    77de:	fe cf       	rjmp	.-4      	; 0x77dc <systemGenerateReport+0x1468>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    77e0:	81 ec       	ldi	r24, 0xC1	; 193
    77e2:	93 e0       	ldi	r25, 0x03	; 3
    77e4:	9f bb       	out	0x1f, r25	; 31
    77e6:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    77e8:	e0 9a       	sbi	0x1c, 0	; 28
    77ea:	8d b3       	in	r24, 0x1d	; 29
    77ec:	9e 01       	movw	r18, r28
    77ee:	2b 55       	subi	r18, 0x5B	; 91
    77f0:	3f 4f       	sbci	r19, 0xFF	; 255
    77f2:	4c ef       	ldi	r20, 0xFC	; 252
    77f4:	59 e0       	ldi	r21, 0x09	; 9
    77f6:	61 e4       	ldi	r22, 0x41	; 65
    77f8:	c6 2e       	mov	r12, r22
    77fa:	69 e0       	ldi	r22, 0x09	; 9
    77fc:	d6 2e       	mov	r13, r22
    77fe:	de 01       	movw	r26, r28
    7800:	a7 59       	subi	r26, 0x97	; 151
    7802:	bf 4f       	sbci	r27, 0xFF	; 255
    7804:	b5 01       	movw	r22, r10
    7806:	6f 5f       	subi	r22, 0xFF	; 255
    7808:	7f 4f       	sbci	r23, 0xFF	; 255

			      GetTabSpace((21-strlen(strProduct)-strlen(strTotalVolume)),strTabSpace);
			      GetTabSpace((15-strlen(strTotalMoney)),strTabSpace2);

				  //PrintMoney
		          if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("%d.%s%s%s%s%s"),iTotal+1,strProduct,strTabSpace,strTotalVolume,strTabSpace2,strTotalMoney);
    780a:	81 30       	cpi	r24, 0x01	; 1
    780c:	39 f5       	brne	.+78     	; 0x785c <systemGenerateReport+0x14e8>
    780e:	ed b7       	in	r30, 0x3d	; 61
    7810:	fe b7       	in	r31, 0x3e	; 62
    7812:	70 97       	sbiw	r30, 0x10	; 16
    7814:	0f b6       	in	r0, 0x3f	; 63
    7816:	f8 94       	cli
    7818:	fe bf       	out	0x3e, r31	; 62
    781a:	0f be       	out	0x3f, r0	; 63
    781c:	ed bf       	out	0x3d, r30	; 61
    781e:	0d b7       	in	r16, 0x3d	; 61
    7820:	1e b7       	in	r17, 0x3e	; 62
    7822:	0f 5f       	subi	r16, 0xFF	; 255
    7824:	1f 4f       	sbci	r17, 0xFF	; 255
    7826:	32 83       	std	Z+2, r19	; 0x02
    7828:	21 83       	std	Z+1, r18	; 0x01
    782a:	87 e0       	ldi	r24, 0x07	; 7
    782c:	94 e0       	ldi	r25, 0x04	; 4
    782e:	f8 01       	movw	r30, r16
    7830:	93 83       	std	Z+3, r25	; 0x03
    7832:	82 83       	std	Z+2, r24	; 0x02
    7834:	75 83       	std	Z+5, r23	; 0x05
    7836:	64 83       	std	Z+4, r22	; 0x04
    7838:	d7 82       	std	Z+7, r13	; 0x07
    783a:	c6 82       	std	Z+6, r12	; 0x06
    783c:	b1 87       	std	Z+9, r27	; 0x09
    783e:	a0 87       	std	Z+8, r26	; 0x08
    7840:	53 87       	std	Z+11, r21	; 0x0b
    7842:	42 87       	std	Z+10, r20	; 0x0a
    7844:	95 86       	std	Z+13, r9	; 0x0d
    7846:	84 86       	std	Z+12, r8	; 0x0c
    7848:	8d ea       	ldi	r24, 0xAD	; 173
    784a:	9a e0       	ldi	r25, 0x0A	; 10
    784c:	97 87       	std	Z+15, r25	; 0x0f
    784e:	86 87       	std	Z+14, r24	; 0x0e
    7850:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    7854:	8d b7       	in	r24, 0x3d	; 61
    7856:	9e b7       	in	r25, 0x3e	; 62
    7858:	40 96       	adiw	r24, 0x10	; 16
    785a:	20 c0       	rjmp	.+64     	; 0x789c <systemGenerateReport+0x1528>
				  else sprintf_P(strReport,PSTR("%d.%s%s%s"),iTotal+1,strProduct,strTabSpace,strTotalVolume);
    785c:	ed b7       	in	r30, 0x3d	; 61
    785e:	fe b7       	in	r31, 0x3e	; 62
    7860:	3c 97       	sbiw	r30, 0x0c	; 12
    7862:	0f b6       	in	r0, 0x3f	; 63
    7864:	f8 94       	cli
    7866:	fe bf       	out	0x3e, r31	; 62
    7868:	0f be       	out	0x3f, r0	; 63
    786a:	ed bf       	out	0x3d, r30	; 61
    786c:	0d b7       	in	r16, 0x3d	; 61
    786e:	1e b7       	in	r17, 0x3e	; 62
    7870:	0f 5f       	subi	r16, 0xFF	; 255
    7872:	1f 4f       	sbci	r17, 0xFF	; 255
    7874:	32 83       	std	Z+2, r19	; 0x02
    7876:	21 83       	std	Z+1, r18	; 0x01
    7878:	8d ef       	ldi	r24, 0xFD	; 253
    787a:	93 e0       	ldi	r25, 0x03	; 3
    787c:	f8 01       	movw	r30, r16
    787e:	93 83       	std	Z+3, r25	; 0x03
    7880:	82 83       	std	Z+2, r24	; 0x02
    7882:	75 83       	std	Z+5, r23	; 0x05
    7884:	64 83       	std	Z+4, r22	; 0x04
    7886:	d7 82       	std	Z+7, r13	; 0x07
    7888:	c6 82       	std	Z+6, r12	; 0x06
    788a:	b1 87       	std	Z+9, r27	; 0x09
    788c:	a0 87       	std	Z+8, r26	; 0x08
    788e:	53 87       	std	Z+11, r21	; 0x0b
    7890:	42 87       	std	Z+10, r20	; 0x0a
    7892:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    7896:	8d b7       	in	r24, 0x3d	; 61
    7898:	9e b7       	in	r25, 0x3e	; 62
    789a:	0c 96       	adiw	r24, 0x0c	; 12
    789c:	0f b6       	in	r0, 0x3f	; 63
    789e:	f8 94       	cli
    78a0:	9e bf       	out	0x3e, r25	; 62
    78a2:	0f be       	out	0x3f, r0	; 63
    78a4:	8d bf       	out	0x3d, r24	; 61

				  CreateReport(strReport,PrintBuffer,&RepPos);
    78a6:	ce 01       	movw	r24, r28
    78a8:	8b 55       	subi	r24, 0x5B	; 91
    78aa:	9f 4f       	sbci	r25, 0xFF	; 255
    78ac:	6f ec       	ldi	r22, 0xCF	; 207
    78ae:	75 e0       	ldi	r23, 0x05	; 5
    78b0:	42 e0       	ldi	r20, 0x02	; 2
    78b2:	52 e0       	ldi	r21, 0x02	; 2
    78b4:	0e 94 ad 20 	call	0x415a	; 0x415a <CreateReport>
		  if (eeprom_read_byte(&DefPrintMoney)==True)sprintf_P(strReport,PSTR("TOTAL %s%s%s%s"),strTabSpace,strTotalVolume,strTabSpace2,strTotalMoney);//CreateReport(strReport,PrintBuffer,&RepPos);
		  else sprintf_P(strReport,PSTR("TOTAL %s%s"),strTabSpace,strTotalVolume);CreateReport(strReport,PrintBuffer,&RepPos);

		  InserBorder(btMiddleLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btMiddleRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);     	      

		  for(iTotal=0;iTotal<strlen(GradeList);iTotal++){
    78b8:	e3 94       	inc	r14
    78ba:	e4 e0       	ldi	r30, 0x04	; 4
    78bc:	f2 e0       	ldi	r31, 0x02	; 2
    78be:	01 90       	ld	r0, Z+
    78c0:	00 20       	and	r0, r0
    78c2:	e9 f7       	brne	.-6      	; 0x78be <systemGenerateReport+0x154a>
    78c4:	31 97       	sbiw	r30, 0x01	; 1
    78c6:	e4 50       	subi	r30, 0x04	; 4
    78c8:	f2 40       	sbci	r31, 0x02	; 2
    78ca:	ae 2c       	mov	r10, r14
    78cc:	bb 24       	eor	r11, r11
    78ce:	ae 16       	cp	r10, r30
    78d0:	bf 06       	cpc	r11, r31
    78d2:	08 f4       	brcc	.+2      	; 0x78d6 <systemGenerateReport+0x1562>
    78d4:	0f ce       	rjmp	.-994    	; 0x74f4 <systemGenerateReport+0x1180>
				  else sprintf_P(strReport,PSTR("%d.%s%s%s"),iTotal+1,strProduct,strTabSpace,strTotalVolume);

				  CreateReport(strReport,PrintBuffer,&RepPos);
               }
		  }
          InserBorder(btBottomLeft,PrintBuffer,1,&RepPos);InserBorder(btHorizontal,PrintBuffer,BORDER_LENGTH,&RepPos);InserBorder(btBottomRight,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);
    78d6:	87 e0       	ldi	r24, 0x07	; 7
    78d8:	6f ec       	ldi	r22, 0xCF	; 207
    78da:	75 e0       	ldi	r23, 0x05	; 5
    78dc:	41 e0       	ldi	r20, 0x01	; 1
    78de:	22 e0       	ldi	r18, 0x02	; 2
    78e0:	32 e0       	ldi	r19, 0x02	; 2
    78e2:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <InserBorder>
    78e6:	8b e0       	ldi	r24, 0x0B	; 11
    78e8:	6f ec       	ldi	r22, 0xCF	; 207
    78ea:	75 e0       	ldi	r23, 0x05	; 5
    78ec:	4a e2       	ldi	r20, 0x2A	; 42
    78ee:	22 e0       	ldi	r18, 0x02	; 2
    78f0:	32 e0       	ldi	r19, 0x02	; 2
    78f2:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <InserBorder>
    78f6:	89 e0       	ldi	r24, 0x09	; 9
    78f8:	6f ec       	ldi	r22, 0xCF	; 207
    78fa:	75 e0       	ldi	r23, 0x05	; 5
    78fc:	41 e0       	ldi	r20, 0x01	; 1
    78fe:	22 e0       	ldi	r18, 0x02	; 2
    7900:	32 e0       	ldi	r19, 0x02	; 2
    7902:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <InserBorder>
    7906:	8c e0       	ldi	r24, 0x0C	; 12
    7908:	6f ec       	ldi	r22, 0xCF	; 207
    790a:	75 e0       	ldi	r23, 0x05	; 5
    790c:	41 e0       	ldi	r20, 0x01	; 1
    790e:	22 e0       	ldi	r18, 0x02	; 2
    7910:	32 e0       	ldi	r19, 0x02	; 2
    7912:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <InserBorder>
		  InserBorder(btNewLine,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);InserBorder(btNewLine,PrintBuffer,1,&RepPos);
    7916:	8c e0       	ldi	r24, 0x0C	; 12
    7918:	6f ec       	ldi	r22, 0xCF	; 207
    791a:	75 e0       	ldi	r23, 0x05	; 5
    791c:	41 e0       	ldi	r20, 0x01	; 1
    791e:	22 e0       	ldi	r18, 0x02	; 2
    7920:	32 e0       	ldi	r19, 0x02	; 2
    7922:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <InserBorder>
    7926:	8c e0       	ldi	r24, 0x0C	; 12
    7928:	6f ec       	ldi	r22, 0xCF	; 207
    792a:	75 e0       	ldi	r23, 0x05	; 5
    792c:	41 e0       	ldi	r20, 0x01	; 1
    792e:	22 e0       	ldi	r18, 0x02	; 2
    7930:	32 e0       	ldi	r19, 0x02	; 2
    7932:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <InserBorder>
    7936:	8c e0       	ldi	r24, 0x0C	; 12
    7938:	6f ec       	ldi	r22, 0xCF	; 207
    793a:	75 e0       	ldi	r23, 0x05	; 5
    793c:	41 e0       	ldi	r20, 0x01	; 1
    793e:	22 e0       	ldi	r18, 0x02	; 2
    7940:	32 e0       	ldi	r19, 0x02	; 2
    7942:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <InserBorder>
    7946:	8c e0       	ldi	r24, 0x0C	; 12
    7948:	6f ec       	ldi	r22, 0xCF	; 207
    794a:	75 e0       	ldi	r23, 0x05	; 5
    794c:	41 e0       	ldi	r20, 0x01	; 1
    794e:	22 e0       	ldi	r18, 0x02	; 2
    7950:	32 e0       	ldi	r19, 0x02	; 2
    7952:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <InserBorder>
    7956:	8c e0       	ldi	r24, 0x0C	; 12
    7958:	6f ec       	ldi	r22, 0xCF	; 207
    795a:	75 e0       	ldi	r23, 0x05	; 5
    795c:	41 e0       	ldi	r20, 0x01	; 1
    795e:	22 e0       	ldi	r18, 0x02	; 2
    7960:	32 e0       	ldi	r19, 0x02	; 2
    7962:	0e 94 7e 1a 	call	0x34fc	; 0x34fc <InserBorder>


          cmdPrint=0b00010000|(1<<PRN_PAPER_CUT);
    7966:	80 e3       	ldi	r24, 0x30	; 48
    7968:	80 93 cb 01 	sts	0x01CB, r24
		  LengthMessage81=RepPos+1;
    796c:	80 91 02 02 	lds	r24, 0x0202
    7970:	90 91 03 02 	lds	r25, 0x0203
    7974:	01 96       	adiw	r24, 0x01	; 1
    7976:	90 93 a1 01 	sts	0x01A1, r25
    797a:	80 93 a0 01 	sts	0x01A0, r24
		  IsFreePrinting=True;
    797e:	81 e0       	ldi	r24, 0x01	; 1
    7980:	80 93 bf 01 	sts	0x01BF, r24
	      IsBusyFreePrinting=True; 
    7984:	80 93 ca 01 	sts	0x01CA, r24
         	       
	      stGenerateReport=grWaitPrinted3;
    7988:	8b e0       	ldi	r24, 0x0B	; 11
    798a:	05 c0       	rjmp	.+10     	; 0x7996 <systemGenerateReport+0x1622>
	      break;
     case grWaitPrinted3:
          if (IsBusyFreePrinting==False)stGenerateReport=grFinishGenerateReport;
    798c:	80 91 ca 01 	lds	r24, 0x01CA
    7990:	88 23       	and	r24, r24
    7992:	49 f4       	brne	.+18     	; 0x79a6 <systemGenerateReport+0x1632>
    7994:	8c e0       	ldi	r24, 0x0C	; 12
    7996:	80 93 14 02 	sts	0x0214, r24
    799a:	05 c0       	rjmp	.+10     	; 0x79a6 <systemGenerateReport+0x1632>
	      break;
     case grFinishGenerateReport:
	      IsFinishPrintingTotalizer=True;
    799c:	81 e0       	ldi	r24, 0x01	; 1
    799e:	80 93 9a 01 	sts	0x019A, r24
          stGenerateReport=grScanAction;
    79a2:	10 92 14 02 	sts	0x0214, r1
	      break;
	 }
}
    79a6:	c8 50       	subi	r28, 0x08	; 8
    79a8:	df 4f       	sbci	r29, 0xFF	; 255
    79aa:	0f b6       	in	r0, 0x3f	; 63
    79ac:	f8 94       	cli
    79ae:	de bf       	out	0x3e, r29	; 62
    79b0:	0f be       	out	0x3f, r0	; 63
    79b2:	cd bf       	out	0x3d, r28	; 61
    79b4:	cf 91       	pop	r28
    79b6:	df 91       	pop	r29
    79b8:	1f 91       	pop	r17
    79ba:	0f 91       	pop	r16
    79bc:	ff 90       	pop	r15
    79be:	ef 90       	pop	r14
    79c0:	df 90       	pop	r13
    79c2:	cf 90       	pop	r12
    79c4:	bf 90       	pop	r11
    79c6:	af 90       	pop	r10
    79c8:	9f 90       	pop	r9
    79ca:	8f 90       	pop	r8
    79cc:	7f 90       	pop	r7
    79ce:	6f 90       	pop	r6
    79d0:	5f 90       	pop	r5
    79d2:	4f 90       	pop	r4
    79d4:	3f 90       	pop	r3
    79d6:	2f 90       	pop	r2
    79d8:	08 95       	ret

000079da <UpdateCardID>:
	 else SeqNum=0;
	 leadingZero(SeqNum,strSeqNum);
} 


void UpdateCardID(){
    79da:	cf 93       	push	r28
    79dc:	df 93       	push	r29
     char i,LengthID;
	 LengthID=strlen(strRFID);  //           +12345678  
    79de:	ec e2       	ldi	r30, 0x2C	; 44
    79e0:	fe e0       	ldi	r31, 0x0E	; 14
    79e2:	01 90       	ld	r0, Z+
    79e4:	00 20       	and	r0, r0
    79e6:	e9 f7       	brne	.-6      	; 0x79e2 <UpdateCardID+0x8>
    79e8:	31 97       	sbiw	r30, 0x01	; 1
    79ea:	ec 52       	subi	r30, 0x2C	; 44
    79ec:	fe 40       	sbci	r31, 0x0E	; 14
    79ee:	a1 e6       	ldi	r26, 0x61	; 97
    79f0:	bd e0       	ldi	r27, 0x0D	; 13
	 else SeqNum=0;
	 leadingZero(SeqNum,strSeqNum);
} 


void UpdateCardID(){
    79f2:	f0 e0       	ldi	r31, 0x00	; 0
    79f4:	ef 01       	movw	r28, r30
    79f6:	c8 5e       	subi	r28, 0xE8	; 232
    79f8:	d1 4f       	sbci	r29, 0xF1	; 241
    79fa:	20 e0       	ldi	r18, 0x00	; 0
    79fc:	30 e0       	ldi	r19, 0x00	; 0
     char i,LengthID;
	 LengthID=strlen(strRFID);  //           +12345678  
	 for(i=0;i<20;i++){         //SSSSSSSSSSSS12345678
	    if (i<(20-LengthID))strCardID[i]=' ';
    79fe:	44 e1       	ldi	r20, 0x14	; 20
    7a00:	50 e0       	ldi	r21, 0x00	; 0
    7a02:	4e 1b       	sub	r20, r30
    7a04:	5f 0b       	sbc	r21, r31
    7a06:	90 e2       	ldi	r25, 0x20	; 32
    7a08:	24 17       	cp	r18, r20
    7a0a:	35 07       	cpc	r19, r21
    7a0c:	14 f4       	brge	.+4      	; 0x7a12 <UpdateCardID+0x38>
    7a0e:	9c 93       	st	X, r25
    7a10:	02 c0       	rjmp	.+4      	; 0x7a16 <UpdateCardID+0x3c>
		else strCardID[i]=strRFID[i-(20-LengthID)];
    7a12:	88 81       	ld	r24, Y
    7a14:	8c 93       	st	X, r24
    7a16:	2f 5f       	subi	r18, 0xFF	; 255
    7a18:	3f 4f       	sbci	r19, 0xFF	; 255
    7a1a:	11 96       	adiw	r26, 0x01	; 1
    7a1c:	21 96       	adiw	r28, 0x01	; 1


void UpdateCardID(){
     char i,LengthID;
	 LengthID=strlen(strRFID);  //           +12345678  
	 for(i=0;i<20;i++){         //SSSSSSSSSSSS12345678
    7a1e:	24 31       	cpi	r18, 0x14	; 20
    7a20:	31 05       	cpc	r19, r1
    7a22:	91 f7       	brne	.-28     	; 0x7a08 <UpdateCardID+0x2e>
	    if (i<(20-LengthID))strCardID[i]=' ';
		else strCardID[i]=strRFID[i-(20-LengthID)];
	 }strCardID[20]=0;
    7a24:	10 92 75 0d 	sts	0x0D75, r1

}
    7a28:	df 91       	pop	r29
    7a2a:	cf 91       	pop	r28
    7a2c:	08 95       	ret

00007a2e <GetParameter>:
	}
  return  PosFound;
}


void GetParameter(char *GFlow,char FLength,char *GCmd,char *GPumpID, char *GeniCSum){
    7a2e:	8f 92       	push	r8
    7a30:	9f 92       	push	r9
    7a32:	af 92       	push	r10
    7a34:	bf 92       	push	r11
    7a36:	cf 92       	push	r12
    7a38:	df 92       	push	r13
    7a3a:	ef 92       	push	r14
    7a3c:	ff 92       	push	r15
    7a3e:	0f 93       	push	r16
    7a40:	1f 93       	push	r17
    7a42:	df 93       	push	r29
    7a44:	cf 93       	push	r28
    7a46:	cd b7       	in	r28, 0x3d	; 61
    7a48:	de b7       	in	r29, 0x3e	; 62
    7a4a:	a7 97       	sbiw	r28, 0x27	; 39
    7a4c:	0f b6       	in	r0, 0x3f	; 63
    7a4e:	f8 94       	cli
    7a50:	de bf       	out	0x3e, r29	; 62
    7a52:	0f be       	out	0x3f, r0	; 63
    7a54:	cd bf       	out	0x3d, r28	; 61
    7a56:	79 01       	movw	r14, r18
    7a58:	48 01       	movw	r8, r16
    7a5a:	e6 2f       	mov	r30, r22
    7a5c:	f0 e0       	ldi	r31, 0x00	; 0
    7a5e:	31 97       	sbiw	r30, 0x01	; 1
    7a60:	e8 0f       	add	r30, r24
    7a62:	f9 1f       	adc	r31, r25
    7a64:	9e 01       	movw	r18, r28
    7a66:	26 5f       	subi	r18, 0xF6	; 246
    7a68:	3f 4f       	sbci	r19, 0xFF	; 255
    7a6a:	d9 01       	movw	r26, r18
    7a6c:	03 c0       	rjmp	.+6      	; 0x7a74 <GetParameter+0x46>
char strSend[20],strSub[3];
int SumLength;

     //TransposeFlow
     for (i=0;i<FLength;i++){	 
	     SGeniusFlow[i]=GFlow[FLength-i-1];
    7a6e:	80 81       	ld	r24, Z
    7a70:	8d 93       	st	X+, r24
    7a72:	31 97       	sbiw	r30, 0x01	; 1
char SGeniusFlow[30];
char strSend[20],strSub[3];
int SumLength;

     //TransposeFlow
     for (i=0;i<FLength;i++){	 
    7a74:	8a 2f       	mov	r24, r26
    7a76:	82 1b       	sub	r24, r18
    7a78:	86 17       	cp	r24, r22
    7a7a:	c8 f3       	brcs	.-14     	; 0x7a6e <GetParameter+0x40>
	     SGeniusFlow[i]=GFlow[FLength-i-1];
	 }SGeniusFlow[FLength]=0;
    7a7c:	c6 2e       	mov	r12, r22
    7a7e:	dd 24       	eor	r13, r13
    7a80:	ea e0       	ldi	r30, 0x0A	; 10
    7a82:	ae 2e       	mov	r10, r30
    7a84:	b1 2c       	mov	r11, r1
    7a86:	ac 0e       	add	r10, r28
    7a88:	bd 1e       	adc	r11, r29
    7a8a:	f5 01       	movw	r30, r10
    7a8c:	ec 0d       	add	r30, r12
    7a8e:	fd 1d       	adc	r31, r13
    7a90:	10 82       	st	Z, r1

	 xCmd=CharPosCopy(SGeniusFlow,0);
	 *GCmd=xCmd;
    7a92:	8a 85       	ldd	r24, Y+10	; 0x0a
    7a94:	fa 01       	movw	r30, r20
    7a96:	80 83       	st	Z, r24
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7a98:	8b 85       	ldd	r24, Y+11	; 0x0b
    7a9a:	89 83       	std	Y+1, r24	; 0x01
    7a9c:	8c 85       	ldd	r24, Y+12	; 0x0c
    7a9e:	8a 83       	std	Y+2, r24	; 0x02
	 }Dest[Length]=0;
    7aa0:	1b 82       	std	Y+3, r1	; 0x03
	 }SGeniusFlow[FLength]=0;

	 xCmd=CharPosCopy(SGeniusFlow,0);
	 *GCmd=xCmd;
	 StrPosCopy(SGeniusFlow,sPumpID,1,2);
	 xPumpID=atoi(sPumpID);
    7aa2:	ce 01       	movw	r24, r28
    7aa4:	01 96       	adiw	r24, 0x01	; 1
    7aa6:	0e 94 ea b3 	call	0x167d4	; 0x167d4 <atoi>
	 *GPumpID=xPumpID;
    7aaa:	f7 01       	movw	r30, r14
    7aac:	80 83       	st	Z, r24
	 sprintf_P(strSub,PSTR(":"));
    7aae:	00 d0       	rcall	.+0      	; 0x7ab0 <GetParameter+0x82>
    7ab0:	00 d0       	rcall	.+0      	; 0x7ab2 <GetParameter+0x84>
    7ab2:	77 e0       	ldi	r23, 0x07	; 7
    7ab4:	e7 2e       	mov	r14, r23
    7ab6:	f1 2c       	mov	r15, r1
    7ab8:	ec 0e       	add	r14, r28
    7aba:	fd 1e       	adc	r15, r29
    7abc:	ed b7       	in	r30, 0x3d	; 61
    7abe:	fe b7       	in	r31, 0x3e	; 62
    7ac0:	f2 82       	std	Z+2, r15	; 0x02
    7ac2:	e1 82       	std	Z+1, r14	; 0x01
    7ac4:	87 e7       	ldi	r24, 0x77	; 119
    7ac6:	93 e0       	ldi	r25, 0x03	; 3
    7ac8:	94 83       	std	Z+4, r25	; 0x04
    7aca:	83 83       	std	Z+3, r24	; 0x03
    7acc:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
	 if (Pos(strSub,SGeniusFlow)<FLength){
    7ad0:	0f 90       	pop	r0
    7ad2:	0f 90       	pop	r0
    7ad4:	0f 90       	pop	r0
    7ad6:	0f 90       	pop	r0
    7ad8:	c7 01       	movw	r24, r14
    7ada:	b5 01       	movw	r22, r10
    7adc:	0e 94 76 20 	call	0x40ec	; 0x40ec <Pos>
    7ae0:	8c 15       	cp	r24, r12
    7ae2:	9d 05       	cpc	r25, r13
    7ae4:	4c f5       	brge	.+82     	; 0x7b38 <GetParameter+0x10a>
	     SumLength=FLength-Pos(strSub,SGeniusFlow);
    7ae6:	c7 01       	movw	r24, r14
    7ae8:	b5 01       	movw	r22, r10
    7aea:	0e 94 76 20 	call	0x40ec	; 0x40ec <Pos>
    7aee:	8c 01       	movw	r16, r24
	 	 StrPosCopy(SGeniusFlow,sCSum,Pos(strSub,SGeniusFlow)+1,SumLength);
    7af0:	c7 01       	movw	r24, r14
    7af2:	b5 01       	movw	r22, r10
    7af4:	0e 94 76 20 	call	0x40ec	; 0x40ec <Pos>
    7af8:	a6 01       	movw	r20, r12
    7afa:	40 1b       	sub	r20, r16
    7afc:	51 0b       	sbc	r21, r17
    7afe:	d5 01       	movw	r26, r10
    7b00:	a8 0f       	add	r26, r24
    7b02:	b9 1f       	adc	r27, r25
    7b04:	20 e0       	ldi	r18, 0x00	; 0
    7b06:	30 e0       	ldi	r19, 0x00	; 0
    7b08:	be 01       	movw	r22, r28
    7b0a:	6c 5f       	subi	r22, 0xFC	; 252
    7b0c:	7f 4f       	sbci	r23, 0xFF	; 255
    7b0e:	07 c0       	rjmp	.+14     	; 0x7b1e <GetParameter+0xf0>
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7b10:	fb 01       	movw	r30, r22
    7b12:	e2 0f       	add	r30, r18
    7b14:	f3 1f       	adc	r31, r19
    7b16:	8c 91       	ld	r24, X
    7b18:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7b1a:	2f 5f       	subi	r18, 0xFF	; 255
    7b1c:	3f 4f       	sbci	r19, 0xFF	; 255
    7b1e:	11 96       	adiw	r26, 0x01	; 1
    7b20:	24 17       	cp	r18, r20
    7b22:	35 07       	cpc	r19, r21
    7b24:	a8 f3       	brcs	.-22     	; 0x7b10 <GetParameter+0xe2>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7b26:	46 0f       	add	r20, r22
    7b28:	57 1f       	adc	r21, r23
    7b2a:	fa 01       	movw	r30, r20
    7b2c:	10 82       	st	Z, r1
	 *GPumpID=xPumpID;
	 sprintf_P(strSub,PSTR(":"));
	 if (Pos(strSub,SGeniusFlow)<FLength){
	     SumLength=FLength-Pos(strSub,SGeniusFlow);
	 	 StrPosCopy(SGeniusFlow,sCSum,Pos(strSub,SGeniusFlow)+1,SumLength);
		 xCsum=atoi(sCSum);
    7b2e:	cb 01       	movw	r24, r22
    7b30:	0e 94 ea b3 	call	0x167d4	; 0x167d4 <atoi>
	     *GeniCSum=xCsum;
    7b34:	f4 01       	movw	r30, r8
    7b36:	80 83       	st	Z, r24
	 sprintf_P(strSend,PSTR("%d"),xPumpID);
	 _uart_print(1,1,strSend);
	 sprintf_P(strSend,PSTR("%s"),sCSum);
	 _uart_print(1,1,strSend);
*/
}
    7b38:	a7 96       	adiw	r28, 0x27	; 39
    7b3a:	0f b6       	in	r0, 0x3f	; 63
    7b3c:	f8 94       	cli
    7b3e:	de bf       	out	0x3e, r29	; 62
    7b40:	0f be       	out	0x3f, r0	; 63
    7b42:	cd bf       	out	0x3d, r28	; 61
    7b44:	cf 91       	pop	r28
    7b46:	df 91       	pop	r29
    7b48:	1f 91       	pop	r17
    7b4a:	0f 91       	pop	r16
    7b4c:	ff 90       	pop	r15
    7b4e:	ef 90       	pop	r14
    7b50:	df 90       	pop	r13
    7b52:	cf 90       	pop	r12
    7b54:	bf 90       	pop	r11
    7b56:	af 90       	pop	r10
    7b58:	9f 90       	pop	r9
    7b5a:	8f 90       	pop	r8
    7b5c:	08 95       	ret

00007b5e <GeniusProtocol>:
   return Result;	 
}

//enum eGeniusProtocolCommand{GP_PUMP_STATUS,GP_PUMP_LAST_TRANSACTION,GP_PUMP_STOP,GP_PUMP_RESUME,GP_PUMP_PRESET};

void GeniusProtocol(char dataIn){
    7b5e:	ff 92       	push	r15
    7b60:	0f 93       	push	r16
    7b62:	1f 93       	push	r17
    7b64:	df 93       	push	r29
    7b66:	cf 93       	push	r28
    7b68:	cd b7       	in	r28, 0x3d	; 61
    7b6a:	de b7       	in	r29, 0x3e	; 62
    7b6c:	67 97       	sbiw	r28, 0x17	; 23
    7b6e:	0f b6       	in	r0, 0x3f	; 63
    7b70:	f8 94       	cli
    7b72:	de bf       	out	0x3e, r29	; 62
    7b74:	0f be       	out	0x3f, r0	; 63
    7b76:	cd bf       	out	0x3d, r28	; 61
    7b78:	f8 2e       	mov	r15, r24
	 char i,GeniCmd,GeniPumpID,GeniCSum;//,sCmd[7];
	 char strSend[20];

    //_uart(1,1,dataIn);

	if (dataIn==0x0D){	
    7b7a:	8d e0       	ldi	r24, 0x0D	; 13
    7b7c:	f8 16       	cp	r15, r24
    7b7e:	09 f0       	breq	.+2      	; 0x7b82 <GeniusProtocol+0x24>
    7b80:	45 c0       	rjmp	.+138    	; 0x7c0c <GeniusProtocol+0xae>
	    GetParameter(Geniflow,FlowLength,&GeniCmd,&GeniPumpID,&GeniCSum);
    7b82:	8f ed       	ldi	r24, 0xDF	; 223
    7b84:	91 e0       	ldi	r25, 0x01	; 1
    7b86:	60 91 de 01 	lds	r22, 0x01DE
    7b8a:	ae 01       	movw	r20, r28
    7b8c:	4f 5f       	subi	r20, 0xFF	; 255
    7b8e:	5f 4f       	sbci	r21, 0xFF	; 255
    7b90:	9e 01       	movw	r18, r28
    7b92:	2e 5f       	subi	r18, 0xFE	; 254
    7b94:	3f 4f       	sbci	r19, 0xFF	; 255
    7b96:	8e 01       	movw	r16, r28
    7b98:	0d 5f       	subi	r16, 0xFD	; 253
    7b9a:	1f 4f       	sbci	r17, 0xFF	; 255
    7b9c:	0e 94 17 3d 	call	0x7a2e	; 0x7a2e <GetParameter>
		FlowLength=0;
    7ba0:	10 92 de 01 	sts	0x01DE, r1
		IsGeniusFlow=False;
    7ba4:	10 92 dd 01 	sts	0x01DD, r1
		FillChar(strSend,0,sizeof(strSend));
		sprintf_P(strSend,PSTR("%c%.2d:"),GeniCmd,GeniPumpID);
    7ba8:	ad b7       	in	r26, 0x3d	; 61
    7baa:	be b7       	in	r27, 0x3e	; 62
    7bac:	18 97       	sbiw	r26, 0x08	; 8
    7bae:	0f b6       	in	r0, 0x3f	; 63
    7bb0:	f8 94       	cli
    7bb2:	be bf       	out	0x3e, r27	; 62
    7bb4:	0f be       	out	0x3f, r0	; 63
    7bb6:	ad bf       	out	0x3d, r26	; 61
    7bb8:	ed b7       	in	r30, 0x3d	; 61
    7bba:	fe b7       	in	r31, 0x3e	; 62
    7bbc:	31 96       	adiw	r30, 0x01	; 1
    7bbe:	8e 01       	movw	r16, r28
    7bc0:	0c 5f       	subi	r16, 0xFC	; 252
    7bc2:	1f 4f       	sbci	r17, 0xFF	; 255
    7bc4:	12 96       	adiw	r26, 0x02	; 2
    7bc6:	1c 93       	st	X, r17
    7bc8:	0e 93       	st	-X, r16
    7bca:	11 97       	sbiw	r26, 0x01	; 1
    7bcc:	89 e6       	ldi	r24, 0x69	; 105
    7bce:	93 e0       	ldi	r25, 0x03	; 3
    7bd0:	93 83       	std	Z+3, r25	; 0x03
    7bd2:	82 83       	std	Z+2, r24	; 0x02
    7bd4:	89 81       	ldd	r24, Y+1	; 0x01
    7bd6:	84 83       	std	Z+4, r24	; 0x04
    7bd8:	15 82       	std	Z+5, r1	; 0x05
    7bda:	8a 81       	ldd	r24, Y+2	; 0x02
    7bdc:	86 83       	std	Z+6, r24	; 0x06
    7bde:	17 82       	std	Z+7, r1	; 0x07
    7be0:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
		//_uart_print(1,1,strSend);


		if ((SumChecksum(strSend))==GeniCSum){
    7be4:	8d b7       	in	r24, 0x3d	; 61
    7be6:	9e b7       	in	r25, 0x3e	; 62
    7be8:	08 96       	adiw	r24, 0x08	; 8
    7bea:	0f b6       	in	r0, 0x3f	; 63
    7bec:	f8 94       	cli
    7bee:	9e bf       	out	0x3e, r25	; 62
    7bf0:	0f be       	out	0x3f, r0	; 63
    7bf2:	8d bf       	out	0x3d, r24	; 61
    7bf4:	c8 01       	movw	r24, r16
    7bf6:	0e 94 11 20 	call	0x4022	; 0x4022 <SumChecksum>
    7bfa:	9b 81       	ldd	r25, Y+3	; 0x03
    7bfc:	89 17       	cp	r24, r25
    7bfe:	31 f4       	brne	.+12     	; 0x7c0c <GeniusProtocol+0xae>
		     switch(GeniCmd){
    7c00:	89 81       	ldd	r24, Y+1	; 0x01
    7c02:	84 35       	cpi	r24, 0x54	; 84
    7c04:	19 f4       	brne	.+6      	; 0x7c0c <GeniusProtocol+0xae>
			 case 'C'://PumpStatus
			      GeniusSendPumpStatus(GeniPumpID);
			      break;
             case 'T'://Transaction Request: T01:239<0D>
			      GeniusSendLastTransaction(GeniPumpID);
    7c06:	8a 81       	ldd	r24, Y+2	; 0x02
    7c08:	0e 94 5e 2b 	call	0x56bc	; 0x56bc <GeniusSendLastTransaction>
    7c0c:	e1 ef       	ldi	r30, 0xF1	; 241
    7c0e:	f1 e0       	ldi	r31, 0x01	; 1
			 }
		}
	}
	//Shifting
	for(i=19;i>0;i--){
	    Geniflow[i]=Geniflow[i-1];	
    7c10:	80 81       	ld	r24, Z
    7c12:	81 83       	std	Z+1, r24	; 0x01
    7c14:	31 97       	sbiw	r30, 0x01	; 1
			      break;
			 }
		}
	}
	//Shifting
	for(i=19;i>0;i--){
    7c16:	91 e0       	ldi	r25, 0x01	; 1
    7c18:	ee 3d       	cpi	r30, 0xDE	; 222
    7c1a:	f9 07       	cpc	r31, r25
    7c1c:	c9 f7       	brne	.-14     	; 0x7c10 <GeniusProtocol+0xb2>
	    Geniflow[i]=Geniflow[i-1];	
	}Geniflow[0]=dataIn;
    7c1e:	f1 82       	std	Z+1, r15	; 0x01

	if (IsGeniusCommand(dataIn)==True)IsGeniusFlow=True;
    7c20:	8f 2d       	mov	r24, r15
    7c22:	0e 94 31 20 	call	0x4062	; 0x4062 <IsGeniusCommand>
    7c26:	81 30       	cpi	r24, 0x01	; 1
    7c28:	11 f4       	brne	.+4      	; 0x7c2e <GeniusProtocol+0xd0>
    7c2a:	80 93 dd 01 	sts	0x01DD, r24
	if (IsGeniusFlow==True)FlowLength++;
    7c2e:	80 91 dd 01 	lds	r24, 0x01DD
    7c32:	81 30       	cpi	r24, 0x01	; 1
    7c34:	29 f4       	brne	.+10     	; 0x7c40 <GeniusProtocol+0xe2>
    7c36:	80 91 de 01 	lds	r24, 0x01DE
    7c3a:	8f 5f       	subi	r24, 0xFF	; 255
    7c3c:	80 93 de 01 	sts	0x01DE, r24
	Geniflow[3]=Geniflow[2];
	Geniflow[2]=Geniflow[1];
	Geniflow[1]=Geniflow[0];
	Geniflow[0]=dataIn;
*/
}
    7c40:	67 96       	adiw	r28, 0x17	; 23
    7c42:	0f b6       	in	r0, 0x3f	; 63
    7c44:	f8 94       	cli
    7c46:	de bf       	out	0x3e, r29	; 62
    7c48:	0f be       	out	0x3f, r0	; 63
    7c4a:	cd bf       	out	0x3d, r28	; 61
    7c4c:	cf 91       	pop	r28
    7c4e:	df 91       	pop	r29
    7c50:	1f 91       	pop	r17
    7c52:	0f 91       	pop	r16
    7c54:	ff 90       	pop	r15
    7c56:	08 95       	ret

00007c58 <__vector_30>:
}

// NotSuccessful! 


ISR(USART1_RX_vect){
    7c58:	1f 92       	push	r1
    7c5a:	0f 92       	push	r0
    7c5c:	0f b6       	in	r0, 0x3f	; 63
    7c5e:	0f 92       	push	r0
    7c60:	0b b6       	in	r0, 0x3b	; 59
    7c62:	0f 92       	push	r0
    7c64:	11 24       	eor	r1, r1
    7c66:	1f 93       	push	r17
    7c68:	2f 93       	push	r18
    7c6a:	3f 93       	push	r19
    7c6c:	4f 93       	push	r20
    7c6e:	5f 93       	push	r21
    7c70:	6f 93       	push	r22
    7c72:	7f 93       	push	r23
    7c74:	8f 93       	push	r24
    7c76:	9f 93       	push	r25
    7c78:	af 93       	push	r26
    7c7a:	bf 93       	push	r27
    7c7c:	ef 93       	push	r30
    7c7e:	ff 93       	push	r31
	char dataTX1,serialSend[12];
	static char IsAdvanZProtocol=False;
	unsigned int i;
	dataTX1 = UDR1;
    7c80:	10 91 9c 00 	lds	r17, 0x009C

	//NewPacket
	if (IsNewPacket==True){
    7c84:	80 91 9b 01 	lds	r24, 0x019B
    7c88:	81 30       	cpi	r24, 0x01	; 1
    7c8a:	51 f4       	brne	.+20     	; 0x7ca0 <__vector_30+0x48>
	    if (dataTX1==0x01){
    7c8c:	11 30       	cpi	r17, 0x01	; 1
    7c8e:	41 f4       	brne	.+16     	; 0x7ca0 <__vector_30+0x48>
		    char_count=0;
    7c90:	10 92 9d 01 	sts	0x019D, r1
    7c94:	10 92 9c 01 	sts	0x019C, r1
            IsNewPacket=False;
    7c98:	10 92 9b 01 	sts	0x019B, r1
			IsAdvanZProtocol=True;
    7c9c:	10 93 a5 03 	sts	0x03A5, r17
			}
	}
    //Save data to buffer if AdvanZ MSG
	if (IsAdvanZProtocol==True){
    7ca0:	80 91 a5 03 	lds	r24, 0x03A5
    7ca4:	81 30       	cpi	r24, 0x01	; 1
    7ca6:	69 f4       	brne	.+26     	; 0x7cc2 <__vector_30+0x6a>
	    rcv_trans[char_count]=dataTX1;
    7ca8:	80 91 9c 01 	lds	r24, 0x019C
    7cac:	90 91 9d 01 	lds	r25, 0x019D
    7cb0:	fc 01       	movw	r30, r24
    7cb2:	eb 50       	subi	r30, 0x0B	; 11
    7cb4:	f5 4f       	sbci	r31, 0xF5	; 245
    7cb6:	10 83       	st	Z, r17
	    char_count++; 
    7cb8:	01 96       	adiw	r24, 0x01	; 1
    7cba:	90 93 9d 01 	sts	0x019D, r25
    7cbe:	80 93 9c 01 	sts	0x019C, r24
	}

	if (dataTX1==0x02){
    7cc2:	12 30       	cpi	r17, 0x02	; 2
    7cc4:	b1 f5       	brne	.+108    	; 0x7d32 <__vector_30+0xda>
		transLength=char_count;
    7cc6:	60 91 9c 01 	lds	r22, 0x019C
    7cca:	70 91 9d 01 	lds	r23, 0x019D
    7cce:	70 93 9f 01 	sts	0x019F, r23
    7cd2:	60 93 9e 01 	sts	0x019E, r22
		char_count=0;
    7cd6:	10 92 9d 01 	sts	0x019D, r1
    7cda:	10 92 9c 01 	sts	0x019C, r1
		IsAdvanZProtocol=False;
    7cde:	10 92 a5 03 	sts	0x03A5, r1

		//MessageIdentification
        if (MsgCode!=MSG_NONE)MsgCode=MSG_NONE;
	    MsgCode=((rcv_trans[35]-'0')*10)+(rcv_trans[36]-'0');
    7ce2:	20 91 19 0b 	lds	r18, 0x0B19
    7ce6:	20 51       	subi	r18, 0x10	; 16
    7ce8:	80 91 18 0b 	lds	r24, 0x0B18
    7cec:	3a e0       	ldi	r19, 0x0A	; 10
    7cee:	83 9f       	mul	r24, r19
    7cf0:	c0 01       	movw	r24, r0
    7cf2:	11 24       	eor	r1, r1
    7cf4:	28 0f       	add	r18, r24
    7cf6:	20 93 24 01 	sts	0x0124, r18
     
	    IdentifyMessage(rcv_trans[0],transLength);
    7cfa:	80 91 f5 0a 	lds	r24, 0x0AF5
    7cfe:	0e 94 f0 18 	call	0x31e0	; 0x31e0 <IdentifyMessage>
		IsNewPacket=True;
    7d02:	21 e0       	ldi	r18, 0x01	; 1
    7d04:	20 93 9b 01 	sts	0x019B, r18

		if ((rcv_trans[35]=='8')&&(rcv_trans[36]=='1')){
    7d08:	80 91 18 0b 	lds	r24, 0x0B18
    7d0c:	88 33       	cpi	r24, 0x38	; 56
    7d0e:	89 f4       	brne	.+34     	; 0x7d32 <__vector_30+0xda>
    7d10:	80 91 19 0b 	lds	r24, 0x0B19
    7d14:	81 33       	cpi	r24, 0x31	; 49
    7d16:	69 f4       	brne	.+26     	; 0x7d32 <__vector_30+0xda>
		   LengthMessage81=transLength-12-44;
    7d18:	80 91 9e 01 	lds	r24, 0x019E
    7d1c:	90 91 9f 01 	lds	r25, 0x019F
    7d20:	c8 97       	sbiw	r24, 0x38	; 56
    7d22:	90 93 a1 01 	sts	0x01A1, r25
    7d26:	80 93 a0 01 	sts	0x01A0, r24
		   IsMessage81=True;
    7d2a:	20 93 bd 01 	sts	0x01BD, r18
		   IsCompleteFilling=True;
    7d2e:	20 93 c0 01 	sts	0x01C0, r18
		

	}//Endif(dataTX1==0x02)

	//ConfigDetection: iConf?<0D><0A>
	if (IsNewPacket!=True)ConfigProtocol(dataTX1);
    7d32:	80 91 9b 01 	lds	r24, 0x019B
    7d36:	81 30       	cpi	r24, 0x01	; 1
    7d38:	19 f0       	breq	.+6      	; 0x7d40 <__vector_30+0xe8>
    7d3a:	81 2f       	mov	r24, r17
    7d3c:	0e 94 e3 14 	call	0x29c6	; 0x29c6 <ConfigProtocol>
	//GeniusDetection: [CMD][MSG][CSUM][0x0D]
	if ((IFType==IT_STANDALONE)&&(IsNewPacket!=True))GeniusProtocol(dataTX1);		
    7d40:	80 91 10 01 	lds	r24, 0x0110
    7d44:	82 30       	cpi	r24, 0x02	; 2
    7d46:	39 f4       	brne	.+14     	; 0x7d56 <__vector_30+0xfe>
    7d48:	80 91 9b 01 	lds	r24, 0x019B
    7d4c:	81 30       	cpi	r24, 0x01	; 1
    7d4e:	19 f0       	breq	.+6      	; 0x7d56 <__vector_30+0xfe>
    7d50:	81 2f       	mov	r24, r17
    7d52:	0e 94 af 3d 	call	0x7b5e	; 0x7b5e <GeniusProtocol>
    //_uart(0,1,dataTX1);
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}
    7d56:	ff 91       	pop	r31
    7d58:	ef 91       	pop	r30
    7d5a:	bf 91       	pop	r27
    7d5c:	af 91       	pop	r26
    7d5e:	9f 91       	pop	r25
    7d60:	8f 91       	pop	r24
    7d62:	7f 91       	pop	r23
    7d64:	6f 91       	pop	r22
    7d66:	5f 91       	pop	r21
    7d68:	4f 91       	pop	r20
    7d6a:	3f 91       	pop	r19
    7d6c:	2f 91       	pop	r18
    7d6e:	1f 91       	pop	r17
    7d70:	0f 90       	pop	r0
    7d72:	0b be       	out	0x3b, r0	; 59
    7d74:	0f 90       	pop	r0
    7d76:	0f be       	out	0x3f, r0	; 63
    7d78:	0f 90       	pop	r0
    7d7a:	1f 90       	pop	r1
    7d7c:	18 95       	reti

00007d7e <procMessage99>:
     StrPosCopy(rcv_trans,strAmount,74,8); 
	 StrPosCopy(rcv_trans,strStatus,82,1);
     StrPosCopy(rcv_trans,strSurcharge,83,9);    
}

char procMessage99(){//<STX>[IFT IDSeq N Srce IPDest IPMsg CodeTran NoShiftDateTimeIsland IDFIP IDProduct IDDescriptionPriceVolumeAmountMOP TypeMOP NameCard IDCard HolderBalance Type Balance MeterVolume MeterAmount Current TimePrint Count Checksum ETX
    7d7e:	0f 93       	push	r16
    7d80:	1f 93       	push	r17
     char Result;
	 Result=MSG99_NONE;
	 //Message99
	 if((rcv_trans[0]==0x01)&&(transLength>=378)){
    7d82:	80 91 f5 0a 	lds	r24, 0x0AF5
    7d86:	81 30       	cpi	r24, 0x01	; 1
    7d88:	09 f0       	breq	.+2      	; 0x7d8c <procMessage99+0xe>
    7d8a:	2e c2       	rjmp	.+1116   	; 0x81e8 <procMessage99+0x46a>
    7d8c:	80 91 9e 01 	lds	r24, 0x019E
    7d90:	90 91 9f 01 	lds	r25, 0x019F
    7d94:	8a 57       	subi	r24, 0x7A	; 122
    7d96:	91 40       	sbci	r25, 0x01	; 1
    7d98:	08 f4       	brcc	.+2      	; 0x7d9c <procMessage99+0x1e>
    7d9a:	26 c2       	rjmp	.+1100   	; 0x81e8 <procMessage99+0x46a>
    7d9c:	20 e0       	ldi	r18, 0x00	; 0
    7d9e:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7da0:	f9 01       	movw	r30, r18
    7da2:	ef 59       	subi	r30, 0x9F	; 159
    7da4:	f1 4f       	sbci	r31, 0xF1	; 241
    7da6:	d9 01       	movw	r26, r18
    7da8:	ab 50       	subi	r26, 0x0B	; 11
    7daa:	b5 4f       	sbci	r27, 0xF5	; 245
    7dac:	95 96       	adiw	r26, 0x25	; 37
    7dae:	8c 91       	ld	r24, X
    7db0:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7db2:	2f 5f       	subi	r18, 0xFF	; 255
    7db4:	3f 4f       	sbci	r19, 0xFF	; 255
    7db6:	26 30       	cpi	r18, 0x06	; 6
    7db8:	31 05       	cpc	r19, r1
    7dba:	91 f7       	brne	.-28     	; 0x7da0 <procMessage99+0x22>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7dbc:	10 92 67 0e 	sts	0x0E67, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7dc0:	80 91 20 0b 	lds	r24, 0x0B20
    7dc4:	80 93 43 0e 	sts	0x0E43, r24
	 }Dest[Length]=0;
    7dc8:	10 92 44 0e 	sts	0x0E44, r1
	 Result=MSG99_NONE;
	 //Message99
	 if((rcv_trans[0]==0x01)&&(transLength>=378)){
       StrPosCopy(rcv_trans,strTranNo,37,6);//Transaction Number
       StrPosCopy(rcv_trans,strShift,43,1);
       Shift=(CharPosCopy(rcv_trans,43)-'0');
    7dcc:	80 53       	subi	r24, 0x30	; 48
    7dce:	80 93 d0 01 	sts	0x01D0, r24
    7dd2:	20 e0       	ldi	r18, 0x00	; 0
    7dd4:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7dd6:	f9 01       	movw	r30, r18
    7dd8:	ef 5a       	subi	r30, 0xAF	; 175
    7dda:	f6 4f       	sbci	r31, 0xF6	; 246
    7ddc:	d9 01       	movw	r26, r18
    7dde:	ab 50       	subi	r26, 0x0B	; 11
    7de0:	b5 4f       	sbci	r27, 0xF5	; 245
    7de2:	9c 96       	adiw	r26, 0x2c	; 44
    7de4:	8c 91       	ld	r24, X
    7de6:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7de8:	2f 5f       	subi	r18, 0xFF	; 255
    7dea:	3f 4f       	sbci	r19, 0xFF	; 255
    7dec:	2a 30       	cpi	r18, 0x0A	; 10
    7dee:	31 05       	cpc	r19, r1
    7df0:	91 f7       	brne	.-28     	; 0x7dd6 <procMessage99+0x58>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7df2:	10 92 5b 09 	sts	0x095B, r1
    7df6:	20 e0       	ldi	r18, 0x00	; 0
    7df8:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7dfa:	f9 01       	movw	r30, r18
    7dfc:	e3 5d       	subi	r30, 0xD3	; 211
    7dfe:	fa 4f       	sbci	r31, 0xFA	; 250
    7e00:	d9 01       	movw	r26, r18
    7e02:	ab 50       	subi	r26, 0x0B	; 11
    7e04:	b5 4f       	sbci	r27, 0xF5	; 245
    7e06:	d6 96       	adiw	r26, 0x36	; 54
    7e08:	8c 91       	ld	r24, X
    7e0a:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7e0c:	2f 5f       	subi	r18, 0xFF	; 255
    7e0e:	3f 4f       	sbci	r19, 0xFF	; 255
    7e10:	28 30       	cpi	r18, 0x08	; 8
    7e12:	31 05       	cpc	r19, r1
    7e14:	91 f7       	brne	.-28     	; 0x7dfa <procMessage99+0x7c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7e16:	10 92 35 05 	sts	0x0535, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7e1a:	80 91 33 0b 	lds	r24, 0x0B33
    7e1e:	80 93 cf 0a 	sts	0x0ACF, r24
    7e22:	80 91 34 0b 	lds	r24, 0x0B34
    7e26:	80 93 d0 0a 	sts	0x0AD0, r24
	 }Dest[Length]=0;
    7e2a:	10 92 d1 0a 	sts	0x0AD1, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7e2e:	80 91 35 0b 	lds	r24, 0x0B35
    7e32:	80 93 9c 09 	sts	0x099C, r24
    7e36:	80 91 36 0b 	lds	r24, 0x0B36
    7e3a:	80 93 9d 09 	sts	0x099D, r24
	 }Dest[Length]=0;
    7e3e:	10 92 9e 09 	sts	0x099E, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7e42:	80 91 37 0b 	lds	r24, 0x0B37
    7e46:	80 93 76 0a 	sts	0x0A76, r24
    7e4a:	80 91 38 0b 	lds	r24, 0x0B38
    7e4e:	80 93 77 0a 	sts	0x0A77, r24
	 }Dest[Length]=0;
    7e52:	10 92 78 0a 	sts	0x0A78, r1
    7e56:	20 e0       	ldi	r18, 0x00	; 0
    7e58:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7e5a:	f9 01       	movw	r30, r18
    7e5c:	ef 5e       	subi	r30, 0xEF	; 239
    7e5e:	f5 4f       	sbci	r31, 0xF5	; 245
    7e60:	d9 01       	movw	r26, r18
    7e62:	a7 5c       	subi	r26, 0xC7	; 199
    7e64:	b4 4f       	sbci	r27, 0xF4	; 244
    7e66:	8c 91       	ld	r24, X
    7e68:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7e6a:	2f 5f       	subi	r18, 0xFF	; 255
    7e6c:	3f 4f       	sbci	r19, 0xFF	; 255
    7e6e:	2f 30       	cpi	r18, 0x0F	; 15
    7e70:	31 05       	cpc	r19, r1
    7e72:	99 f7       	brne	.-26     	; 0x7e5a <procMessage99+0xdc>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7e74:	10 92 20 0a 	sts	0x0A20, r1
    7e78:	20 e0       	ldi	r18, 0x00	; 0
    7e7a:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7e7c:	f9 01       	movw	r30, r18
    7e7e:	ef 57       	subi	r30, 0x7F	; 127
    7e80:	f8 4f       	sbci	r31, 0xF8	; 248
    7e82:	d9 01       	movw	r26, r18
    7e84:	a8 5b       	subi	r26, 0xB8	; 184
    7e86:	b4 4f       	sbci	r27, 0xF4	; 244
    7e88:	8c 91       	ld	r24, X
    7e8a:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7e8c:	2f 5f       	subi	r18, 0xFF	; 255
    7e8e:	3f 4f       	sbci	r19, 0xFF	; 255
    7e90:	28 30       	cpi	r18, 0x08	; 8
    7e92:	31 05       	cpc	r19, r1
    7e94:	99 f7       	brne	.-26     	; 0x7e7c <procMessage99+0xfe>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7e96:	10 92 89 07 	sts	0x0789, r1
    7e9a:	20 e0       	ldi	r18, 0x00	; 0
    7e9c:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7e9e:	f9 01       	movw	r30, r18
    7ea0:	eb 5a       	subi	r30, 0xAB	; 171
    7ea2:	fa 4f       	sbci	r31, 0xFA	; 250
    7ea4:	d9 01       	movw	r26, r18
    7ea6:	a0 5b       	subi	r26, 0xB0	; 176
    7ea8:	b4 4f       	sbci	r27, 0xF4	; 244
    7eaa:	8c 91       	ld	r24, X
    7eac:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7eae:	2f 5f       	subi	r18, 0xFF	; 255
    7eb0:	3f 4f       	sbci	r19, 0xFF	; 255
    7eb2:	28 30       	cpi	r18, 0x08	; 8
    7eb4:	31 05       	cpc	r19, r1
    7eb6:	99 f7       	brne	.-26     	; 0x7e9e <procMessage99+0x120>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7eb8:	10 92 5d 05 	sts	0x055D, r1
    7ebc:	20 e0       	ldi	r18, 0x00	; 0
    7ebe:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7ec0:	f9 01       	movw	r30, r18
    7ec2:	e5 57       	subi	r30, 0x75	; 117
    7ec4:	f2 4f       	sbci	r31, 0xF2	; 242
    7ec6:	d9 01       	movw	r26, r18
    7ec8:	a8 5a       	subi	r26, 0xA8	; 168
    7eca:	b4 4f       	sbci	r27, 0xF4	; 244
    7ecc:	8c 91       	ld	r24, X
    7ece:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7ed0:	2f 5f       	subi	r18, 0xFF	; 255
    7ed2:	3f 4f       	sbci	r19, 0xFF	; 255
    7ed4:	2a 30       	cpi	r18, 0x0A	; 10
    7ed6:	31 05       	cpc	r19, r1
    7ed8:	99 f7       	brne	.-26     	; 0x7ec0 <procMessage99+0x142>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7eda:	10 92 95 0d 	sts	0x0D95, r1

	   //FillChar(strAmount,sizeof(strAmount),0);
       StrPosCopy(rcv_trans,strAmount,99,10);

       //StrPosCopy(rcv_trans,strMOPType,109,1);
       MOPType=(CharPosCopy(rcv_trans,109)-'0');
    7ede:	80 91 62 0b 	lds	r24, 0x0B62
    7ee2:	80 53       	subi	r24, 0x30	; 48
    7ee4:	80 93 cf 01 	sts	0x01CF, r24
    7ee8:	20 e0       	ldi	r18, 0x00	; 0
    7eea:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7eec:	f9 01       	movw	r30, r18
    7eee:	e0 5a       	subi	r30, 0xA0	; 160
    7ef0:	f8 4f       	sbci	r31, 0xF8	; 248
    7ef2:	d9 01       	movw	r26, r18
    7ef4:	ad 59       	subi	r26, 0x9D	; 157
    7ef6:	b4 4f       	sbci	r27, 0xF4	; 244
    7ef8:	8c 91       	ld	r24, X
    7efa:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7efc:	2f 5f       	subi	r18, 0xFF	; 255
    7efe:	3f 4f       	sbci	r19, 0xFF	; 255
    7f00:	24 31       	cpi	r18, 0x14	; 20
    7f02:	31 05       	cpc	r19, r1
    7f04:	99 f7       	brne	.-26     	; 0x7eec <procMessage99+0x16e>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7f06:	10 92 74 07 	sts	0x0774, r1
    7f0a:	20 e0       	ldi	r18, 0x00	; 0
    7f0c:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7f0e:	f9 01       	movw	r30, r18
    7f10:	ef 59       	subi	r30, 0x9F	; 159
    7f12:	f2 4f       	sbci	r31, 0xF2	; 242
    7f14:	d9 01       	movw	r26, r18
    7f16:	a9 58       	subi	r26, 0x89	; 137
    7f18:	b4 4f       	sbci	r27, 0xF4	; 244
    7f1a:	8c 91       	ld	r24, X
    7f1c:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7f1e:	2f 5f       	subi	r18, 0xFF	; 255
    7f20:	3f 4f       	sbci	r19, 0xFF	; 255
    7f22:	24 31       	cpi	r18, 0x14	; 20
    7f24:	31 05       	cpc	r19, r1
    7f26:	99 f7       	brne	.-26     	; 0x7f0e <procMessage99+0x190>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7f28:	10 92 75 0d 	sts	0x0D75, r1
    7f2c:	20 e0       	ldi	r18, 0x00	; 0
    7f2e:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7f30:	f9 01       	movw	r30, r18
    7f32:	ec 5f       	subi	r30, 0xFC	; 252
    7f34:	fa 4f       	sbci	r31, 0xFA	; 250
    7f36:	d9 01       	movw	r26, r18
    7f38:	a5 57       	subi	r26, 0x75	; 117
    7f3a:	b4 4f       	sbci	r27, 0xF4	; 244
    7f3c:	8c 91       	ld	r24, X
    7f3e:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7f40:	2f 5f       	subi	r18, 0xFF	; 255
    7f42:	3f 4f       	sbci	r19, 0xFF	; 255
    7f44:	28 32       	cpi	r18, 0x28	; 40
    7f46:	31 05       	cpc	r19, r1
    7f48:	99 f7       	brne	.-26     	; 0x7f30 <procMessage99+0x1b2>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7f4a:	10 92 2c 05 	sts	0x052C, r1
    7f4e:	20 e0       	ldi	r18, 0x00	; 0
    7f50:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7f52:	f9 01       	movw	r30, r18
    7f54:	e5 5c       	subi	r30, 0xC5	; 197
    7f56:	fa 4f       	sbci	r31, 0xFA	; 250
    7f58:	d9 01       	movw	r26, r18
    7f5a:	ad 54       	subi	r26, 0x4D	; 77
    7f5c:	b4 4f       	sbci	r27, 0xF4	; 244
    7f5e:	8c 91       	ld	r24, X
    7f60:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7f62:	2f 5f       	subi	r18, 0xFF	; 255
    7f64:	3f 4f       	sbci	r19, 0xFF	; 255
    7f66:	29 31       	cpi	r18, 0x19	; 25
    7f68:	31 05       	cpc	r19, r1
    7f6a:	99 f7       	brne	.-26     	; 0x7f52 <procMessage99+0x1d4>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7f6c:	10 92 54 05 	sts	0x0554, r1
    7f70:	20 e0       	ldi	r18, 0x00	; 0
    7f72:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7f74:	f9 01       	movw	r30, r18
    7f76:	ed 52       	subi	r30, 0x2D	; 45
    7f78:	f2 4f       	sbci	r31, 0xF2	; 242
    7f7a:	d9 01       	movw	r26, r18
    7f7c:	a4 53       	subi	r26, 0x34	; 52
    7f7e:	b4 4f       	sbci	r27, 0xF4	; 244
    7f80:	8c 91       	ld	r24, X
    7f82:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7f84:	2f 5f       	subi	r18, 0xFF	; 255
    7f86:	3f 4f       	sbci	r19, 0xFF	; 255
    7f88:	2d 30       	cpi	r18, 0x0D	; 13
    7f8a:	31 05       	cpc	r19, r1
    7f8c:	99 f7       	brne	.-26     	; 0x7f74 <procMessage99+0x1f6>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7f8e:	10 92 e0 0d 	sts	0x0DE0, r1
    7f92:	20 e0       	ldi	r18, 0x00	; 0
    7f94:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7f96:	f9 01       	movw	r30, r18
    7f98:	e4 59       	subi	r30, 0x94	; 148
    7f9a:	fa 4f       	sbci	r31, 0xFA	; 250
    7f9c:	d9 01       	movw	r26, r18
    7f9e:	a7 52       	subi	r26, 0x27	; 39
    7fa0:	b4 4f       	sbci	r27, 0xF4	; 244
    7fa2:	8c 91       	ld	r24, X
    7fa4:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7fa6:	2f 5f       	subi	r18, 0xFF	; 255
    7fa8:	3f 4f       	sbci	r19, 0xFF	; 255
    7faa:	2d 30       	cpi	r18, 0x0D	; 13
    7fac:	31 05       	cpc	r19, r1
    7fae:	99 f7       	brne	.-26     	; 0x7f96 <procMessage99+0x218>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7fb0:	10 92 79 05 	sts	0x0579, r1
    7fb4:	20 e0       	ldi	r18, 0x00	; 0
    7fb6:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7fb8:	f9 01       	movw	r30, r18
    7fba:	ef 53       	subi	r30, 0x3F	; 63
    7fbc:	f5 4f       	sbci	r31, 0xF5	; 245
    7fbe:	d9 01       	movw	r26, r18
    7fc0:	aa 51       	subi	r26, 0x1A	; 26
    7fc2:	b4 4f       	sbci	r27, 0xF4	; 244
    7fc4:	8c 91       	ld	r24, X
    7fc6:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7fc8:	2f 5f       	subi	r18, 0xFF	; 255
    7fca:	3f 4f       	sbci	r19, 0xFF	; 255
    7fcc:	2d 30       	cpi	r18, 0x0D	; 13
    7fce:	31 05       	cpc	r19, r1
    7fd0:	99 f7       	brne	.-26     	; 0x7fb8 <procMessage99+0x23a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7fd2:	10 92 ce 0a 	sts	0x0ACE, r1
    7fd6:	20 e0       	ldi	r18, 0x00	; 0
    7fd8:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7fda:	f9 01       	movw	r30, r18
    7fdc:	e1 56       	subi	r30, 0x61	; 97
    7fde:	f6 4f       	sbci	r31, 0xF6	; 246
    7fe0:	d9 01       	movw	r26, r18
    7fe2:	ad 50       	subi	r26, 0x0D	; 13
    7fe4:	b4 4f       	sbci	r27, 0xF4	; 244
    7fe6:	8c 91       	ld	r24, X
    7fe8:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    7fea:	2f 5f       	subi	r18, 0xFF	; 255
    7fec:	3f 4f       	sbci	r19, 0xFF	; 255
    7fee:	23 31       	cpi	r18, 0x13	; 19
    7ff0:	31 05       	cpc	r19, r1
    7ff2:	99 f7       	brne	.-26     	; 0x7fda <procMessage99+0x25c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    7ff4:	10 92 b2 09 	sts	0x09B2, r1
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    7ff8:	80 91 06 0c 	lds	r24, 0x0C06
    7ffc:	80 93 5e 0e 	sts	0x0E5E, r24
    8000:	80 91 07 0c 	lds	r24, 0x0C07
    8004:	80 93 5f 0e 	sts	0x0E5F, r24
	 }Dest[Length]=0;
    8008:	10 92 60 0e 	sts	0x0E60, r1
    800c:	20 e0       	ldi	r18, 0x00	; 0
    800e:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8010:	f9 01       	movw	r30, r18
    8012:	e4 51       	subi	r30, 0x14	; 20
    8014:	f5 4f       	sbci	r31, 0xF5	; 245
    8016:	d9 01       	movw	r26, r18
    8018:	a8 5f       	subi	r26, 0xF8	; 248
    801a:	b3 4f       	sbci	r27, 0xF3	; 243
    801c:	8c 91       	ld	r24, X
    801e:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8020:	2f 5f       	subi	r18, 0xFF	; 255
    8022:	3f 4f       	sbci	r19, 0xFF	; 255
    8024:	28 30       	cpi	r18, 0x08	; 8
    8026:	31 05       	cpc	r19, r1
    8028:	99 f7       	brne	.-26     	; 0x8010 <procMessage99+0x292>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    802a:	10 92 f4 0a 	sts	0x0AF4, r1
    802e:	20 e0       	ldi	r18, 0x00	; 0
    8030:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8032:	f9 01       	movw	r30, r18
    8034:	e5 56       	subi	r30, 0x65	; 101
    8036:	fb 4f       	sbci	r31, 0xFB	; 251
    8038:	d9 01       	movw	r26, r18
    803a:	a0 5f       	subi	r26, 0xF0	; 240
    803c:	b3 4f       	sbci	r27, 0xF3	; 243
    803e:	8c 91       	ld	r24, X
    8040:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8042:	2f 5f       	subi	r18, 0xFF	; 255
    8044:	3f 4f       	sbci	r19, 0xFF	; 255
    8046:	28 30       	cpi	r18, 0x08	; 8
    8048:	31 05       	cpc	r19, r1
    804a:	99 f7       	brne	.-26     	; 0x8032 <procMessage99+0x2b4>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    804c:	10 92 a3 04 	sts	0x04A3, r1
    8050:	20 e0       	ldi	r18, 0x00	; 0
    8052:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8054:	f9 01       	movw	r30, r18
    8056:	e9 53       	subi	r30, 0x39	; 57
    8058:	fb 4f       	sbci	r31, 0xFB	; 251
    805a:	d9 01       	movw	r26, r18
    805c:	a8 5e       	subi	r26, 0xE8	; 232
    805e:	b3 4f       	sbci	r27, 0xF3	; 243
    8060:	8c 91       	ld	r24, X
    8062:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8064:	2f 5f       	subi	r18, 0xFF	; 255
    8066:	3f 4f       	sbci	r19, 0xFF	; 255
    8068:	24 31       	cpi	r18, 0x14	; 20
    806a:	31 05       	cpc	r19, r1
    806c:	99 f7       	brne	.-26     	; 0x8054 <procMessage99+0x2d6>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    806e:	10 92 db 04 	sts	0x04DB, r1
    8072:	20 e0       	ldi	r18, 0x00	; 0
    8074:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8076:	f9 01       	movw	r30, r18
    8078:	ec 55       	subi	r30, 0x5C	; 92
    807a:	fb 4f       	sbci	r31, 0xFB	; 251
    807c:	d9 01       	movw	r26, r18
    807e:	a4 5d       	subi	r26, 0xD4	; 212
    8080:	b3 4f       	sbci	r27, 0xF3	; 243
    8082:	8c 91       	ld	r24, X
    8084:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8086:	2f 5f       	subi	r18, 0xFF	; 255
    8088:	3f 4f       	sbci	r19, 0xFF	; 255
    808a:	2e 31       	cpi	r18, 0x1E	; 30
    808c:	31 05       	cpc	r19, r1
    808e:	99 f7       	brne	.-26     	; 0x8076 <procMessage99+0x2f8>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8090:	10 92 c2 04 	sts	0x04C2, r1
    8094:	20 e0       	ldi	r18, 0x00	; 0
    8096:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8098:	f9 01       	movw	r30, r18
    809a:	e6 5c       	subi	r30, 0xC6	; 198
    809c:	f5 4f       	sbci	r31, 0xF5	; 245
    809e:	d9 01       	movw	r26, r18
    80a0:	a6 5b       	subi	r26, 0xB6	; 182
    80a2:	b3 4f       	sbci	r27, 0xF3	; 243
    80a4:	8c 91       	ld	r24, X
    80a6:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    80a8:	2f 5f       	subi	r18, 0xFF	; 255
    80aa:	3f 4f       	sbci	r19, 0xFF	; 255
    80ac:	28 30       	cpi	r18, 0x08	; 8
    80ae:	31 05       	cpc	r19, r1
    80b0:	99 f7       	brne	.-26     	; 0x8098 <procMessage99+0x31a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    80b2:	10 92 42 0a 	sts	0x0A42, r1
    80b6:	20 e0       	ldi	r18, 0x00	; 0
    80b8:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    80ba:	f9 01       	movw	r30, r18
    80bc:	e2 5a       	subi	r30, 0xA2	; 162
    80be:	fa 4f       	sbci	r31, 0xFA	; 250
    80c0:	d9 01       	movw	r26, r18
    80c2:	ae 5a       	subi	r26, 0xAE	; 174
    80c4:	b3 4f       	sbci	r27, 0xF3	; 243
    80c6:	8c 91       	ld	r24, X
    80c8:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    80ca:	2f 5f       	subi	r18, 0xFF	; 255
    80cc:	3f 4f       	sbci	r19, 0xFF	; 255
    80ce:	2a 30       	cpi	r18, 0x0A	; 10
    80d0:	31 05       	cpc	r19, r1
    80d2:	99 f7       	brne	.-26     	; 0x80ba <procMessage99+0x33c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    80d4:	10 92 68 05 	sts	0x0568, r1
    80d8:	20 e0       	ldi	r18, 0x00	; 0
    80da:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    80dc:	f9 01       	movw	r30, r18
    80de:	e8 53       	subi	r30, 0x38	; 56
    80e0:	f2 4f       	sbci	r31, 0xF2	; 242
    80e2:	d9 01       	movw	r26, r18
    80e4:	a4 5a       	subi	r26, 0xA4	; 164
    80e6:	b3 4f       	sbci	r27, 0xF3	; 243
    80e8:	8c 91       	ld	r24, X
    80ea:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    80ec:	2f 5f       	subi	r18, 0xFF	; 255
    80ee:	3f 4f       	sbci	r19, 0xFF	; 255
    80f0:	2a 30       	cpi	r18, 0x0A	; 10
    80f2:	31 05       	cpc	r19, r1
    80f4:	99 f7       	brne	.-26     	; 0x80dc <procMessage99+0x35e>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    80f6:	10 92 d2 0d 	sts	0x0DD2, r1
    80fa:	20 e0       	ldi	r18, 0x00	; 0
    80fc:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    80fe:	f9 01       	movw	r30, r18
    8100:	e1 53       	subi	r30, 0x31	; 49
    8102:	f6 4f       	sbci	r31, 0xF6	; 246
    8104:	d9 01       	movw	r26, r18
    8106:	aa 59       	subi	r26, 0x9A	; 154
    8108:	b3 4f       	sbci	r27, 0xF3	; 243
    810a:	8c 91       	ld	r24, X
    810c:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    810e:	2f 5f       	subi	r18, 0xFF	; 255
    8110:	3f 4f       	sbci	r19, 0xFF	; 255
    8112:	24 31       	cpi	r18, 0x14	; 20
    8114:	31 05       	cpc	r19, r1
    8116:	99 f7       	brne	.-26     	; 0x80fe <procMessage99+0x380>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8118:	10 92 e3 09 	sts	0x09E3, r1
    811c:	20 e0       	ldi	r18, 0x00	; 0
    811e:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8120:	f9 01       	movw	r30, r18
    8122:	e9 5a       	subi	r30, 0xA9	; 169
    8124:	f5 4f       	sbci	r31, 0xF5	; 245
    8126:	d9 01       	movw	r26, r18
    8128:	a6 58       	subi	r26, 0x86	; 134
    812a:	b3 4f       	sbci	r27, 0xF3	; 243
    812c:	8c 91       	ld	r24, X
    812e:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8130:	2f 5f       	subi	r18, 0xFF	; 255
    8132:	3f 4f       	sbci	r19, 0xFF	; 255
    8134:	2a 30       	cpi	r18, 0x0A	; 10
    8136:	31 05       	cpc	r19, r1
    8138:	99 f7       	brne	.-26     	; 0x8120 <procMessage99+0x3a2>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    813a:	10 92 61 0a 	sts	0x0A61, r1
    813e:	20 e0       	ldi	r18, 0x00	; 0
    8140:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8142:	f9 01       	movw	r30, r18
    8144:	e6 58       	subi	r30, 0x86	; 134
    8146:	fa 4f       	sbci	r31, 0xFA	; 250
    8148:	d9 01       	movw	r26, r18
    814a:	ac 57       	subi	r26, 0x7C	; 124
    814c:	b3 4f       	sbci	r27, 0xF3	; 243
    814e:	8c 91       	ld	r24, X
    8150:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8152:	2f 5f       	subi	r18, 0xFF	; 255
    8154:	3f 4f       	sbci	r19, 0xFF	; 255
    8156:	28 30       	cpi	r18, 0x08	; 8
    8158:	31 05       	cpc	r19, r1
    815a:	99 f7       	brne	.-26     	; 0x8142 <procMessage99+0x3c4>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    815c:	10 92 82 05 	sts	0x0582, r1
    8160:	20 e0       	ldi	r18, 0x00	; 0
    8162:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8164:	f9 01       	movw	r30, r18
    8166:	ed 5a       	subi	r30, 0xAD	; 173
    8168:	f1 4f       	sbci	r31, 0xF1	; 241
    816a:	d9 01       	movw	r26, r18
    816c:	a4 57       	subi	r26, 0x74	; 116
    816e:	b3 4f       	sbci	r27, 0xF3	; 243
    8170:	8c 91       	ld	r24, X
    8172:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8174:	2f 5f       	subi	r18, 0xFF	; 255
    8176:	3f 4f       	sbci	r19, 0xFF	; 255
    8178:	2a 30       	cpi	r18, 0x0A	; 10
    817a:	31 05       	cpc	r19, r1
    817c:	99 f7       	brne	.-26     	; 0x8164 <procMessage99+0x3e6>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    817e:	10 92 5d 0e 	sts	0x0E5D, r1
    8182:	20 e0       	ldi	r18, 0x00	; 0
    8184:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8186:	f9 01       	movw	r30, r18
    8188:	eb 51       	subi	r30, 0x1B	; 27
    818a:	f2 4f       	sbci	r31, 0xF2	; 242
    818c:	d9 01       	movw	r26, r18
    818e:	aa 56       	subi	r26, 0x6A	; 106
    8190:	b3 4f       	sbci	r27, 0xF3	; 243
    8192:	8c 91       	ld	r24, X
    8194:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8196:	2f 5f       	subi	r18, 0xFF	; 255
    8198:	3f 4f       	sbci	r19, 0xFF	; 255
    819a:	24 31       	cpi	r18, 0x14	; 20
    819c:	31 05       	cpc	r19, r1
    819e:	99 f7       	brne	.-26     	; 0x8186 <procMessage99+0x408>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    81a0:	10 92 f9 0d 	sts	0x0DF9, r1
    81a4:	20 e0       	ldi	r18, 0x00	; 0
    81a6:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    81a8:	f9 01       	movw	r30, r18
    81aa:	e3 55       	subi	r30, 0x53	; 83
    81ac:	fa 4f       	sbci	r31, 0xFA	; 250
    81ae:	d9 01       	movw	r26, r18
    81b0:	a6 55       	subi	r26, 0x56	; 86
    81b2:	b3 4f       	sbci	r27, 0xF3	; 243
    81b4:	8c 91       	ld	r24, X
    81b6:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    81b8:	2f 5f       	subi	r18, 0xFF	; 255
    81ba:	3f 4f       	sbci	r19, 0xFF	; 255
    81bc:	2e 31       	cpi	r18, 0x1E	; 30
    81be:	31 05       	cpc	r19, r1
    81c0:	99 f7       	brne	.-26     	; 0x81a8 <procMessage99+0x42a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    81c2:	10 92 cb 05 	sts	0x05CB, r1
       StrPosCopy(rcv_trans,strCorporateName,437,30);
	   //


	   //FIP Detection LocalAccount Null Filling
	   if ((nLocalAccount>0)&&(LocalAccountFIP[0]==atoi(strFIP_ID))){
    81c6:	80 91 a4 01 	lds	r24, 0x01A4
    81ca:	88 23       	and	r24, r24
    81cc:	69 f0       	breq	.+26     	; 0x81e8 <procMessage99+0x46a>
    81ce:	00 91 36 05 	lds	r16, 0x0536
    81d2:	10 e0       	ldi	r17, 0x00	; 0
    81d4:	8c e9       	ldi	r24, 0x9C	; 156
    81d6:	99 e0       	ldi	r25, 0x09	; 9
    81d8:	0e 94 ea b3 	call	0x167d4	; 0x167d4 <atoi>
    81dc:	08 17       	cp	r16, r24
    81de:	19 07       	cpc	r17, r25
    81e0:	19 f4       	brne	.+6      	; 0x81e8 <procMessage99+0x46a>
	        IsCompleteFilling=True;
    81e2:	81 e0       	ldi	r24, 0x01	; 1
    81e4:	80 93 c0 01 	sts	0x01C0, r24
	   }

	  }
     return Result;     
}
    81e8:	80 e0       	ldi	r24, 0x00	; 0
    81ea:	1f 91       	pop	r17
    81ec:	0f 91       	pop	r16
    81ee:	08 95       	ret

000081f0 <GetMessageID>:
		  }
       IsStandaloneAcknoledge=True;
	  }
}

char GetMessageID(char *strMessageFlow){
    81f0:	0f 93       	push	r16
    81f2:	1f 93       	push	r17
    81f4:	df 93       	push	r29
    81f6:	cf 93       	push	r28
    81f8:	00 d0       	rcall	.+0      	; 0x81fa <GetMessageID+0xa>
    81fa:	0f 92       	push	r0
    81fc:	cd b7       	in	r28, 0x3d	; 61
    81fe:	de b7       	in	r29, 0x3e	; 62
    8200:	fc 01       	movw	r30, r24
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8202:	80 81       	ld	r24, Z
    8204:	89 83       	std	Y+1, r24	; 0x01
    8206:	81 81       	ldd	r24, Z+1	; 0x01
    8208:	8a 83       	std	Y+2, r24	; 0x02
	 }Dest[Length]=0;
    820a:	1b 82       	std	Y+3, r1	; 0x03
}

char GetMessageID(char *strMessageFlow){
     char Result,strMsgID[3];
	 StrPosCopy(strMessageFlow,strMsgID,0,2);
	 RemZeroLead(strMsgID);
    820c:	8e 01       	movw	r16, r28
    820e:	0f 5f       	subi	r16, 0xFF	; 255
    8210:	1f 4f       	sbci	r17, 0xFF	; 255
    8212:	c8 01       	movw	r24, r16
    8214:	0e 94 dd 23 	call	0x47ba	; 0x47ba <RemZeroLead>
	 Result=atoi(strMsgID);
    8218:	c8 01       	movw	r24, r16
    821a:	0e 94 ea b3 	call	0x167d4	; 0x167d4 <atoi>
  return Result;
}
    821e:	0f 90       	pop	r0
    8220:	0f 90       	pop	r0
    8222:	0f 90       	pop	r0
    8224:	cf 91       	pop	r28
    8226:	df 91       	pop	r29
    8228:	1f 91       	pop	r17
    822a:	0f 91       	pop	r16
    822c:	08 95       	ret

0000822e <FTestChar>:
         if (TimTicker>TICKER_DELAY)stDisplayTicker=tiRight;	     
	     break;
	}
}

char FTestChar(){
    822e:	0f 93       	push	r16
    8230:	1f 93       	push	r17
    8232:	df 93       	push	r29
    8234:	cf 93       	push	r28
    8236:	cd b7       	in	r28, 0x3d	; 61
    8238:	de b7       	in	r29, 0x3e	; 62
    823a:	64 97       	sbiw	r28, 0x14	; 20
    823c:	0f b6       	in	r0, 0x3f	; 63
    823e:	f8 94       	cli
    8240:	de bf       	out	0x3e, r29	; 62
    8242:	0f be       	out	0x3f, r0	; 63
    8244:	cd bf       	out	0x3d, r28	; 61
char lcdteks[20],Result;
static char i=0;
     Result=MENU_NONE;
     sprintf_P(lcdteks,PSTR("D:%d C:%c  "),i,i);
    8246:	20 91 70 03 	lds	r18, 0x0370
    824a:	8d b7       	in	r24, 0x3d	; 61
    824c:	9e b7       	in	r25, 0x3e	; 62
    824e:	08 97       	sbiw	r24, 0x08	; 8
    8250:	0f b6       	in	r0, 0x3f	; 63
    8252:	f8 94       	cli
    8254:	9e bf       	out	0x3e, r25	; 62
    8256:	0f be       	out	0x3f, r0	; 63
    8258:	8d bf       	out	0x3d, r24	; 61
    825a:	ed b7       	in	r30, 0x3d	; 61
    825c:	fe b7       	in	r31, 0x3e	; 62
    825e:	31 96       	adiw	r30, 0x01	; 1
    8260:	8e 01       	movw	r16, r28
    8262:	0f 5f       	subi	r16, 0xFF	; 255
    8264:	1f 4f       	sbci	r17, 0xFF	; 255
    8266:	ad b7       	in	r26, 0x3d	; 61
    8268:	be b7       	in	r27, 0x3e	; 62
    826a:	12 96       	adiw	r26, 0x02	; 2
    826c:	1c 93       	st	X, r17
    826e:	0e 93       	st	-X, r16
    8270:	11 97       	sbiw	r26, 0x01	; 1
    8272:	84 e0       	ldi	r24, 0x04	; 4
    8274:	9c e1       	ldi	r25, 0x1C	; 28
    8276:	93 83       	std	Z+3, r25	; 0x03
    8278:	82 83       	std	Z+2, r24	; 0x02
    827a:	24 83       	std	Z+4, r18	; 0x04
    827c:	15 82       	std	Z+5, r1	; 0x05
    827e:	26 83       	std	Z+6, r18	; 0x06
    8280:	17 82       	std	Z+7, r1	; 0x07
    8282:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
     lcd_print(1,1,lcdteks);
    8286:	8d b7       	in	r24, 0x3d	; 61
    8288:	9e b7       	in	r25, 0x3e	; 62
    828a:	08 96       	adiw	r24, 0x08	; 8
    828c:	0f b6       	in	r0, 0x3f	; 63
    828e:	f8 94       	cli
    8290:	9e bf       	out	0x3e, r25	; 62
    8292:	0f be       	out	0x3f, r0	; 63
    8294:	8d bf       	out	0x3d, r24	; 61
    8296:	81 e0       	ldi	r24, 0x01	; 1
    8298:	61 e0       	ldi	r22, 0x01	; 1
    829a:	a8 01       	movw	r20, r16
    829c:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
	 if (i==0xFF)Result=MENU_DONE;
    82a0:	20 91 70 03 	lds	r18, 0x0370
	 i++;
    82a4:	2f 5f       	subi	r18, 0xFF	; 255
    82a6:	20 93 70 03 	sts	0x0370, r18
    82aa:	21 50       	subi	r18, 0x01	; 1
    82ac:	88 ee       	ldi	r24, 0xE8	; 232
    82ae:	9d ef       	ldi	r25, 0xFD	; 253
    82b0:	49 e1       	ldi	r20, 0x19	; 25
    82b2:	50 e0       	ldi	r21, 0x00	; 0
    82b4:	fa 01       	movw	r30, r20
    82b6:	31 97       	sbiw	r30, 0x01	; 1
    82b8:	f1 f7       	brne	.-4      	; 0x82b6 <FTestChar+0x88>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    82ba:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    82bc:	d9 f7       	brne	.-10     	; 0x82b4 <FTestChar+0x86>
    82be:	80 e0       	ldi	r24, 0x00	; 0
    82c0:	2f 3f       	cpi	r18, 0xFF	; 255
    82c2:	09 f4       	brne	.+2      	; 0x82c6 <FTestChar+0x98>
    82c4:	81 e0       	ldi	r24, 0x01	; 1
     _delay_ms(6500);
  return Result;
}
    82c6:	64 96       	adiw	r28, 0x14	; 20
    82c8:	0f b6       	in	r0, 0x3f	; 63
    82ca:	f8 94       	cli
    82cc:	de bf       	out	0x3e, r29	; 62
    82ce:	0f be       	out	0x3f, r0	; 63
    82d0:	cd bf       	out	0x3d, r28	; 61
    82d2:	cf 91       	pop	r28
    82d4:	df 91       	pop	r29
    82d6:	1f 91       	pop	r17
    82d8:	0f 91       	pop	r16
    82da:	08 95       	ret

000082dc <DisplayPumpStatus>:
		  break;         	 
	 }
  return Result;	 
}

void DisplayPumpStatus(){
    82dc:	0f 93       	push	r16
    82de:	1f 93       	push	r17
    82e0:	df 93       	push	r29
    82e2:	cf 93       	push	r28
    82e4:	cd b7       	in	r28, 0x3d	; 61
    82e6:	de b7       	in	r29, 0x3e	; 62
    82e8:	a8 97       	sbiw	r28, 0x28	; 40
    82ea:	0f b6       	in	r0, 0x3f	; 63
    82ec:	f8 94       	cli
    82ee:	de bf       	out	0x3e, r29	; 62
    82f0:	0f be       	out	0x3f, r0	; 63
    82f2:	cd bf       	out	0x3d, r28	; 61
     char SPump[20],lcdteks[20];

	 if (IsNewPumpStatus==True){
    82f4:	80 91 11 01 	lds	r24, 0x0111
    82f8:	81 30       	cpi	r24, 0x01	; 1
    82fa:	09 f0       	breq	.+2      	; 0x82fe <DisplayPumpStatus+0x22>
    82fc:	4a c0       	rjmp	.+148    	; 0x8392 <DisplayPumpStatus+0xb6>
	     IsNewPumpStatus=False;
    82fe:	10 92 11 01 	sts	0x0111, r1
     }      
}

void BackLightTrig(){
     //TimBackLight=0;
__key_light = 1; __key_lgtcnt = 0; PORTG=PORTG&0b11111101;
    8302:	80 93 bf 03 	sts	0x03BF, r24
    8306:	10 92 c0 03 	sts	0x03C0, r1
    830a:	80 91 65 00 	lds	r24, 0x0065
    830e:	8d 7f       	andi	r24, 0xFD	; 253
    8310:	80 93 65 00 	sts	0x0065, r24
     char SPump[20],lcdteks[20];

	 if (IsNewPumpStatus==True){
	     IsNewPumpStatus=False;
		 BackLightTrig();
		 StrPosCopy(strPumpStatus,SPump,0,PumpCountMax);
    8314:	80 91 5f 01 	lds	r24, 0x015F
    8318:	48 2f       	mov	r20, r24
    831a:	50 e0       	ldi	r21, 0x00	; 0
    831c:	20 e0       	ldi	r18, 0x00	; 0
    831e:	30 e0       	ldi	r19, 0x00	; 0
    8320:	be 01       	movw	r22, r28
    8322:	6f 5f       	subi	r22, 0xFF	; 255
    8324:	7f 4f       	sbci	r23, 0xFF	; 255
    8326:	0a c0       	rjmp	.+20     	; 0x833c <DisplayPumpStatus+0x60>
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8328:	fb 01       	movw	r30, r22
    832a:	e2 0f       	add	r30, r18
    832c:	f3 1f       	adc	r31, r19
    832e:	d9 01       	movw	r26, r18
    8330:	ae 5e       	subi	r26, 0xEE	; 238
    8332:	be 4f       	sbci	r27, 0xFE	; 254
    8334:	8c 91       	ld	r24, X
    8336:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8338:	2f 5f       	subi	r18, 0xFF	; 255
    833a:	3f 4f       	sbci	r19, 0xFF	; 255
    833c:	24 17       	cp	r18, r20
    833e:	35 07       	cpc	r19, r21
    8340:	98 f3       	brcs	.-26     	; 0x8328 <DisplayPumpStatus+0x4c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8342:	46 0f       	add	r20, r22
    8344:	57 1f       	adc	r21, r23
    8346:	da 01       	movw	r26, r20
    8348:	1c 92       	st	X, r1

	 if (IsNewPumpStatus==True){
	     IsNewPumpStatus=False;
		 BackLightTrig();
		 StrPosCopy(strPumpStatus,SPump,0,PumpCountMax);
		 sprintf_P(lcdteks,PSTR("%s"),SPump);
    834a:	00 d0       	rcall	.+0      	; 0x834c <DisplayPumpStatus+0x70>
    834c:	00 d0       	rcall	.+0      	; 0x834e <DisplayPumpStatus+0x72>
    834e:	00 d0       	rcall	.+0      	; 0x8350 <DisplayPumpStatus+0x74>
    8350:	ed b7       	in	r30, 0x3d	; 61
    8352:	fe b7       	in	r31, 0x3e	; 62
    8354:	31 96       	adiw	r30, 0x01	; 1
    8356:	8e 01       	movw	r16, r28
    8358:	0b 5e       	subi	r16, 0xEB	; 235
    835a:	1f 4f       	sbci	r17, 0xFF	; 255
    835c:	ad b7       	in	r26, 0x3d	; 61
    835e:	be b7       	in	r27, 0x3e	; 62
    8360:	12 96       	adiw	r26, 0x02	; 2
    8362:	1c 93       	st	X, r17
    8364:	0e 93       	st	-X, r16
    8366:	11 97       	sbiw	r26, 0x01	; 1
    8368:	84 e9       	ldi	r24, 0x94	; 148
    836a:	92 e2       	ldi	r25, 0x22	; 34
    836c:	93 83       	std	Z+3, r25	; 0x03
    836e:	82 83       	std	Z+2, r24	; 0x02
    8370:	75 83       	std	Z+5, r23	; 0x05
    8372:	64 83       	std	Z+4, r22	; 0x04
    8374:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
         lcd_print(4,1,lcdteks);
    8378:	ed b7       	in	r30, 0x3d	; 61
    837a:	fe b7       	in	r31, 0x3e	; 62
    837c:	36 96       	adiw	r30, 0x06	; 6
    837e:	0f b6       	in	r0, 0x3f	; 63
    8380:	f8 94       	cli
    8382:	fe bf       	out	0x3e, r31	; 62
    8384:	0f be       	out	0x3f, r0	; 63
    8386:	ed bf       	out	0x3d, r30	; 61
    8388:	84 e0       	ldi	r24, 0x04	; 4
    838a:	61 e0       	ldi	r22, 0x01	; 1
    838c:	a8 01       	movw	r20, r16
    838e:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
     	 }
}
    8392:	a8 96       	adiw	r28, 0x28	; 40
    8394:	0f b6       	in	r0, 0x3f	; 63
    8396:	f8 94       	cli
    8398:	de bf       	out	0x3e, r29	; 62
    839a:	0f be       	out	0x3f, r0	; 63
    839c:	cd bf       	out	0x3d, r28	; 61
    839e:	cf 91       	pop	r28
    83a0:	df 91       	pop	r29
    83a2:	1f 91       	pop	r17
    83a4:	0f 91       	pop	r16
    83a6:	08 95       	ret

000083a8 <FViewFreeMessage>:
char FViewFreeMessage(){
static char stFreeMessage=fmInit;
       char Result=MENU_NONE;
     
	 Result=MENU_NONE;
	 switch(stFreeMessage){
    83a8:	80 91 59 03 	lds	r24, 0x0359
    83ac:	81 30       	cpi	r24, 0x01	; 1
    83ae:	49 f0       	breq	.+18     	; 0x83c2 <FViewFreeMessage+0x1a>
    83b0:	81 30       	cpi	r24, 0x01	; 1
    83b2:	28 f0       	brcs	.+10     	; 0x83be <FViewFreeMessage+0x16>
    83b4:	82 30       	cpi	r24, 0x02	; 2
    83b6:	19 f1       	breq	.+70     	; 0x83fe <FViewFreeMessage+0x56>
    83b8:	83 30       	cpi	r24, 0x03	; 3
    83ba:	71 f5       	brne	.+92     	; 0x8418 <FViewFreeMessage+0x70>
    83bc:	29 c0       	rjmp	.+82     	; 0x8410 <FViewFreeMessage+0x68>
	 case fmInit:
	      stFreeMessage=fmDisplayFreeMessage;
    83be:	81 e0       	ldi	r24, 0x01	; 1
    83c0:	23 c0       	rjmp	.+70     	; 0x8408 <FViewFreeMessage+0x60>
	      break;
     case fmDisplayFreeMessage:
		  lcd_clear();
    83c2:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
		  lcd_print(1,1,strFreeMessageLine1);
    83c6:	81 e0       	ldi	r24, 0x01	; 1
    83c8:	61 e0       	ldi	r22, 0x01	; 1
    83ca:	47 e9       	ldi	r20, 0x97	; 151
    83cc:	5a e0       	ldi	r21, 0x0A	; 10
    83ce:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
		  lcd_print(2,1,strFreeMessageLine2);
    83d2:	82 e0       	ldi	r24, 0x02	; 2
    83d4:	61 e0       	ldi	r22, 0x01	; 1
    83d6:	46 e8       	ldi	r20, 0x86	; 134
    83d8:	59 e0       	ldi	r21, 0x09	; 9
    83da:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
		  lcd_print(3,1,strFreeMessageLine3);
    83de:	83 e0       	ldi	r24, 0x03	; 3
    83e0:	61 e0       	ldi	r22, 0x01	; 1
    83e2:	41 e2       	ldi	r20, 0x21	; 33
    83e4:	5a e0       	ldi	r21, 0x0A	; 10
    83e6:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
		  lcd_print(4,1,strFreeMessageLine4);
    83ea:	84 e0       	ldi	r24, 0x04	; 4
    83ec:	61 e0       	ldi	r22, 0x01	; 1
    83ee:	41 eb       	ldi	r20, 0xB1	; 177
    83f0:	5d e0       	ldi	r21, 0x0D	; 13
    83f2:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
	      TimDisplay=0;
    83f6:	10 92 a7 01 	sts	0x01A7, r1
	      stFreeMessage=fmDelayViewMesage;
    83fa:	82 e0       	ldi	r24, 0x02	; 2
    83fc:	05 c0       	rjmp	.+10     	; 0x8408 <FViewFreeMessage+0x60>
	      break;
	 case fmDelayViewMesage:  
	      if (TimDisplay>TIM_FREE_MESSAGE)stFreeMessage=fmFinishFreeMessage;
    83fe:	80 91 a7 01 	lds	r24, 0x01A7
    8402:	8b 30       	cpi	r24, 0x0B	; 11
    8404:	48 f0       	brcs	.+18     	; 0x8418 <FViewFreeMessage+0x70>
    8406:	83 e0       	ldi	r24, 0x03	; 3
    8408:	80 93 59 03 	sts	0x0359, r24
    840c:	80 e0       	ldi	r24, 0x00	; 0
    840e:	08 95       	ret
	      break;
     case fmFinishFreeMessage:
          stFreeMessage=fmInit;
    8410:	10 92 59 03 	sts	0x0359, r1
    8414:	81 e0       	ldi	r24, 0x01	; 1
    8416:	08 95       	ret
    8418:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
  return Result;
}
    841a:	08 95       	ret

0000841c <_scr_idle>:
		if ((__num>='0')&&(__num<='9')||(IsStandAloneDetected==True)) 
		break;
	 }
}

void _scr_idle(void){
    841c:	cf 92       	push	r12
    841e:	df 92       	push	r13
    8420:	ef 92       	push	r14
    8422:	ff 92       	push	r15
    8424:	0f 93       	push	r16
    8426:	1f 93       	push	r17
    8428:	df 93       	push	r29
    842a:	cf 93       	push	r28
    842c:	cd b7       	in	r28, 0x3d	; 61
    842e:	de b7       	in	r29, 0x3e	; 62
    8430:	a8 97       	sbiw	r28, 0x28	; 40
    8432:	0f b6       	in	r0, 0x3f	; 63
    8434:	f8 94       	cli
    8436:	de bf       	out	0x3e, r29	; 62
    8438:	0f be       	out	0x3f, r0	; 63
    843a:	cd bf       	out	0x3d, r28	; 61
char strCodeName[10],strVersion[10],lcdteks[20];
    sprintf_P(strCodeName,PSTR(CODE_NAME)); 
    843c:	00 d0       	rcall	.+0      	; 0x843e <_scr_idle+0x22>
    843e:	00 d0       	rcall	.+0      	; 0x8440 <_scr_idle+0x24>
    8440:	6e 01       	movw	r12, r28
    8442:	08 94       	sec
    8444:	c1 1c       	adc	r12, r1
    8446:	d1 1c       	adc	r13, r1
    8448:	ad b7       	in	r26, 0x3d	; 61
    844a:	be b7       	in	r27, 0x3e	; 62
    844c:	12 96       	adiw	r26, 0x02	; 2
    844e:	dc 92       	st	X, r13
    8450:	ce 92       	st	-X, r12
    8452:	11 97       	sbiw	r26, 0x01	; 1
    8454:	8d e1       	ldi	r24, 0x1D	; 29
    8456:	92 e2       	ldi	r25, 0x22	; 34
    8458:	14 96       	adiw	r26, 0x04	; 4
    845a:	9c 93       	st	X, r25
    845c:	8e 93       	st	-X, r24
    845e:	13 97       	sbiw	r26, 0x03	; 3
    8460:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    sprintf_P(strVersion,PSTR(VERSION_NUM)); 
    8464:	fb e0       	ldi	r31, 0x0B	; 11
    8466:	ef 2e       	mov	r14, r31
    8468:	f1 2c       	mov	r15, r1
    846a:	ec 0e       	add	r14, r28
    846c:	fd 1e       	adc	r15, r29
    846e:	ed b7       	in	r30, 0x3d	; 61
    8470:	fe b7       	in	r31, 0x3e	; 62
    8472:	f2 82       	std	Z+2, r15	; 0x02
    8474:	e1 82       	std	Z+1, r14	; 0x01
    8476:	88 e1       	ldi	r24, 0x18	; 24
    8478:	92 e2       	ldi	r25, 0x22	; 34
    847a:	94 83       	std	Z+4, r25	; 0x04
    847c:	83 83       	std	Z+3, r24	; 0x03
    847e:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    sprintf_P(lcdteks,PSTR("%s %s"),strCodeName,strVersion); 
    8482:	00 d0       	rcall	.+0      	; 0x8484 <_scr_idle+0x68>
    8484:	00 d0       	rcall	.+0      	; 0x8486 <_scr_idle+0x6a>
    8486:	ed b7       	in	r30, 0x3d	; 61
    8488:	fe b7       	in	r31, 0x3e	; 62
    848a:	31 96       	adiw	r30, 0x01	; 1
    848c:	8e 01       	movw	r16, r28
    848e:	0b 5e       	subi	r16, 0xEB	; 235
    8490:	1f 4f       	sbci	r17, 0xFF	; 255
    8492:	ad b7       	in	r26, 0x3d	; 61
    8494:	be b7       	in	r27, 0x3e	; 62
    8496:	12 96       	adiw	r26, 0x02	; 2
    8498:	1c 93       	st	X, r17
    849a:	0e 93       	st	-X, r16
    849c:	11 97       	sbiw	r26, 0x01	; 1
    849e:	82 e1       	ldi	r24, 0x12	; 18
    84a0:	92 e2       	ldi	r25, 0x22	; 34
    84a2:	93 83       	std	Z+3, r25	; 0x03
    84a4:	82 83       	std	Z+2, r24	; 0x02
    84a6:	d5 82       	std	Z+5, r13	; 0x05
    84a8:	c4 82       	std	Z+4, r12	; 0x04
    84aa:	f7 82       	std	Z+7, r15	; 0x07
    84ac:	e6 82       	std	Z+6, r14	; 0x06
    84ae:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
	lcd_clear();
    84b2:	ed b7       	in	r30, 0x3d	; 61
    84b4:	fe b7       	in	r31, 0x3e	; 62
    84b6:	38 96       	adiw	r30, 0x08	; 8
    84b8:	0f b6       	in	r0, 0x3f	; 63
    84ba:	f8 94       	cli
    84bc:	fe bf       	out	0x3e, r31	; 62
    84be:	0f be       	out	0x3f, r0	; 63
    84c0:	ed bf       	out	0x3d, r30	; 61
    84c2:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
	lcd_print(1,1,lcdteks);
    84c6:	81 e0       	ldi	r24, 0x01	; 1
    84c8:	61 e0       	ldi	r22, 0x01	; 1
    84ca:	a8 01       	movw	r20, r16
    84cc:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
}
    84d0:	a8 96       	adiw	r28, 0x28	; 40
    84d2:	0f b6       	in	r0, 0x3f	; 63
    84d4:	f8 94       	cli
    84d6:	de bf       	out	0x3e, r29	; 62
    84d8:	0f be       	out	0x3f, r0	; 63
    84da:	cd bf       	out	0x3d, r28	; 61
    84dc:	cf 91       	pop	r28
    84de:	df 91       	pop	r29
    84e0:	1f 91       	pop	r17
    84e2:	0f 91       	pop	r16
    84e4:	ff 90       	pop	r15
    84e6:	ef 90       	pop	r14
    84e8:	df 90       	pop	r13
    84ea:	cf 90       	pop	r12
    84ec:	08 95       	ret

000084ee <_scr_pump>:
	 }
	 */
     sprintf_P(StrResult,PSTR("%.2d"),Val);

}
void _scr_pump(void){
    84ee:	8f 92       	push	r8
    84f0:	9f 92       	push	r9
    84f2:	af 92       	push	r10
    84f4:	bf 92       	push	r11
    84f6:	cf 92       	push	r12
    84f8:	df 92       	push	r13
    84fa:	ef 92       	push	r14
    84fc:	ff 92       	push	r15
    84fe:	0f 93       	push	r16
    8500:	1f 93       	push	r17
    8502:	df 93       	push	r29
    8504:	cf 93       	push	r28
    8506:	cd b7       	in	r28, 0x3d	; 61
    8508:	de b7       	in	r29, 0x3e	; 62
    850a:	6c 97       	sbiw	r28, 0x1c	; 28
    850c:	0f b6       	in	r0, 0x3f	; 63
    850e:	f8 94       	cli
    8510:	de bf       	out	0x3e, r29	; 62
    8512:	0f be       	out	0x3f, r0	; 63
    8514:	cd bf       	out	0x3d, r28	; 61
	 //char strPumpL[3],strPumpR[3];
	 char __pump_id[8];
	 char i;
     char lcdteks[20];
	 lcd_clear();_delay_ms(10);
    8516:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
    851a:	84 ec       	ldi	r24, 0xC4	; 196
    851c:	99 e0       	ldi	r25, 0x09	; 9
    851e:	01 97       	sbiw	r24, 0x01	; 1
    8520:	f1 f7       	brne	.-4      	; 0x851e <_scr_pump+0x30>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    8522:	8e 01       	movw	r16, r28
    8524:	0f 5f       	subi	r16, 0xFF	; 255
    8526:	1f 4f       	sbci	r17, 0xFF	; 255
    8528:	c8 01       	movw	r24, r16
    852a:	65 e4       	ldi	r22, 0x45	; 69
    852c:	70 e0       	ldi	r23, 0x00	; 0
    852e:	48 e0       	ldi	r20, 0x08	; 8
    8530:	50 e0       	ldi	r21, 0x00	; 0
    8532:	23 ef       	ldi	r18, 0xF3	; 243
    8534:	32 e1       	ldi	r19, 0x12	; 18
    8536:	0e 94 1f b4 	call	0x1683e	; 0x1683e <__eerd_block>
    853a:	78 01       	movw	r14, r16
    853c:	01 e0       	ldi	r16, 0x01	; 1
    853e:	10 e0       	ldi	r17, 0x00	; 0
		eeprom_read_block((void*) &__pump_id, (const void*) &DefPumpMap, 8);
        for (i=0;i<4;i++){
             //leadingZero(__pump_id[i],strPumpL);
			 //leadingZero(__pump_id[i+4],strPumpR);
             //sprintf_P(lcdteks,PSTR("%d.P%s | %.P%s  "),(i+1),strPumpL,(i+5),strPumpR);
			 sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d "),(i+1),__pump_id[i],(i+5),__pump_id[i+4]);
    8540:	89 e0       	ldi	r24, 0x09	; 9
    8542:	c8 2e       	mov	r12, r24
    8544:	d1 2c       	mov	r13, r1
    8546:	cc 0e       	add	r12, r28
    8548:	dd 1e       	adc	r13, r29
    854a:	b1 e4       	ldi	r27, 0x41	; 65
    854c:	8b 2e       	mov	r8, r27
    854e:	bd e0       	ldi	r27, 0x0D	; 13
    8550:	9b 2e       	mov	r9, r27
	 char i;
     char lcdteks[20];
	 lcd_clear();_delay_ms(10);
	 //Display
		eeprom_read_block((void*) &__pump_id, (const void*) &DefPumpMap, 8);
        for (i=0;i<4;i++){
    8552:	a5 e0       	ldi	r26, 0x05	; 5
    8554:	aa 2e       	mov	r10, r26
    8556:	b1 2c       	mov	r11, r1
    8558:	ac 0e       	add	r10, r28
    855a:	bd 1e       	adc	r11, r29
             //leadingZero(__pump_id[i],strPumpL);
			 //leadingZero(__pump_id[i+4],strPumpR);
             //sprintf_P(lcdteks,PSTR("%d.P%s | %.P%s  "),(i+1),strPumpL,(i+5),strPumpR);
			 sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d "),(i+1),__pump_id[i],(i+5),__pump_id[i+4]);
    855c:	8d b7       	in	r24, 0x3d	; 61
    855e:	9e b7       	in	r25, 0x3e	; 62
    8560:	0c 97       	sbiw	r24, 0x0c	; 12
    8562:	0f b6       	in	r0, 0x3f	; 63
    8564:	f8 94       	cli
    8566:	9e bf       	out	0x3e, r25	; 62
    8568:	0f be       	out	0x3f, r0	; 63
    856a:	8d bf       	out	0x3d, r24	; 61
    856c:	ed b7       	in	r30, 0x3d	; 61
    856e:	fe b7       	in	r31, 0x3e	; 62
    8570:	31 96       	adiw	r30, 0x01	; 1
    8572:	ad b7       	in	r26, 0x3d	; 61
    8574:	be b7       	in	r27, 0x3e	; 62
    8576:	12 96       	adiw	r26, 0x02	; 2
    8578:	dc 92       	st	X, r13
    857a:	ce 92       	st	-X, r12
    857c:	11 97       	sbiw	r26, 0x01	; 1
    857e:	93 82       	std	Z+3, r9	; 0x03
    8580:	82 82       	std	Z+2, r8	; 0x02
    8582:	15 83       	std	Z+5, r17	; 0x05
    8584:	04 83       	std	Z+4, r16	; 0x04
    8586:	d7 01       	movw	r26, r14
    8588:	8c 91       	ld	r24, X
    858a:	86 83       	std	Z+6, r24	; 0x06
    858c:	17 82       	std	Z+7, r1	; 0x07
    858e:	0c 5f       	subi	r16, 0xFC	; 252
    8590:	1f 4f       	sbci	r17, 0xFF	; 255
    8592:	11 87       	std	Z+9, r17	; 0x09
    8594:	00 87       	std	Z+8, r16	; 0x08
    8596:	04 50       	subi	r16, 0x04	; 4
    8598:	10 40       	sbci	r17, 0x00	; 0
    859a:	14 96       	adiw	r26, 0x04	; 4
    859c:	8c 91       	ld	r24, X
    859e:	82 87       	std	Z+10, r24	; 0x0a
    85a0:	13 86       	std	Z+11, r1	; 0x0b
    85a2:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
			 lcd_print((i+1),1,lcdteks);
    85a6:	8d b7       	in	r24, 0x3d	; 61
    85a8:	9e b7       	in	r25, 0x3e	; 62
    85aa:	0c 96       	adiw	r24, 0x0c	; 12
    85ac:	0f b6       	in	r0, 0x3f	; 63
    85ae:	f8 94       	cli
    85b0:	9e bf       	out	0x3e, r25	; 62
    85b2:	0f be       	out	0x3f, r0	; 63
    85b4:	8d bf       	out	0x3d, r24	; 61
    85b6:	80 2f       	mov	r24, r16
    85b8:	61 e0       	ldi	r22, 0x01	; 1
    85ba:	a6 01       	movw	r20, r12
    85bc:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
    85c0:	08 94       	sec
    85c2:	e1 1c       	adc	r14, r1
    85c4:	f1 1c       	adc	r15, r1
    85c6:	0f 5f       	subi	r16, 0xFF	; 255
    85c8:	1f 4f       	sbci	r17, 0xFF	; 255
	 char i;
     char lcdteks[20];
	 lcd_clear();_delay_ms(10);
	 //Display
		eeprom_read_block((void*) &__pump_id, (const void*) &DefPumpMap, 8);
        for (i=0;i<4;i++){
    85ca:	ea 14       	cp	r14, r10
    85cc:	fb 04       	cpc	r15, r11
    85ce:	31 f6       	brne	.-116    	; 0x855c <_scr_pump+0x6e>
			 //leadingZero(__pump_id[i+4],strPumpR);
             //sprintf_P(lcdteks,PSTR("%d.P%s | %.P%s  "),(i+1),strPumpL,(i+5),strPumpR);
			 sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d "),(i+1),__pump_id[i],(i+5),__pump_id[i+4]);
			 lcd_print((i+1),1,lcdteks);
		}
        lcd_printf(4,15,PSTR("*)Exit"));
    85d0:	84 e0       	ldi	r24, 0x04	; 4
    85d2:	6f e0       	ldi	r22, 0x0F	; 15
    85d4:	4a e3       	ldi	r20, 0x3A	; 58
    85d6:	5d e0       	ldi	r21, 0x0D	; 13
    85d8:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
}
    85dc:	6c 96       	adiw	r28, 0x1c	; 28
    85de:	0f b6       	in	r0, 0x3f	; 63
    85e0:	f8 94       	cli
    85e2:	de bf       	out	0x3e, r29	; 62
    85e4:	0f be       	out	0x3f, r0	; 63
    85e6:	cd bf       	out	0x3d, r28	; 61
    85e8:	cf 91       	pop	r28
    85ea:	df 91       	pop	r29
    85ec:	1f 91       	pop	r17
    85ee:	0f 91       	pop	r16
    85f0:	ff 90       	pop	r15
    85f2:	ef 90       	pop	r14
    85f4:	df 90       	pop	r13
    85f6:	cf 90       	pop	r12
    85f8:	bf 90       	pop	r11
    85fa:	af 90       	pop	r10
    85fc:	9f 90       	pop	r9
    85fe:	8f 90       	pop	r8
    8600:	08 95       	ret

00008602 <_menu_host>:
			lcd_print(__x, __y, __buff);
		}
	}
}

void _menu_host(void){
    8602:	2f 92       	push	r2
    8604:	3f 92       	push	r3
    8606:	4f 92       	push	r4
    8608:	5f 92       	push	r5
    860a:	6f 92       	push	r6
    860c:	7f 92       	push	r7
    860e:	8f 92       	push	r8
    8610:	9f 92       	push	r9
    8612:	af 92       	push	r10
    8614:	bf 92       	push	r11
    8616:	cf 92       	push	r12
    8618:	df 92       	push	r13
    861a:	ef 92       	push	r14
    861c:	ff 92       	push	r15
    861e:	0f 93       	push	r16
    8620:	1f 93       	push	r17
    8622:	df 93       	push	r29
    8624:	cf 93       	push	r28
    8626:	cd b7       	in	r28, 0x3d	; 61
    8628:	de b7       	in	r29, 0x3e	; 62
    862a:	6d 97       	sbiw	r28, 0x1d	; 29
    862c:	0f b6       	in	r0, 0x3f	; 63
    862e:	f8 94       	cli
    8630:	de bf       	out	0x3e, r29	; 62
    8632:	0f be       	out	0x3f, r0	; 63
    8634:	cd bf       	out	0x3d, r28	; 61
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    8636:	e1 99       	sbic	0x1c, 1	; 28
    8638:	fe cf       	rjmp	.-4      	; 0x8636 <_menu_host+0x34>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    863a:	21 ec       	ldi	r18, 0xC1	; 193
    863c:	33 e0       	ldi	r19, 0x03	; 3
    863e:	3f bb       	out	0x1f, r19	; 31
    8640:	2e bb       	out	0x1e, r18	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    8642:	e0 9a       	sbi	0x1c, 0	; 28
    8644:	8d b3       	in	r24, 0x1d	; 29
	char 			__value[4];
	unsigned char	__i, __x, __y, __key, __num, __buff[5];
	char lcdteks[20];
	static char TermID;

	__value[0] = eeprom_read_byte(&DefPrintMoney);
    8646:	89 83       	std	Y+1, r24	; 0x01
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    8648:	e1 99       	sbic	0x1c, 1	; 28
    864a:	fe cf       	rjmp	.-4      	; 0x8648 <_menu_host+0x46>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    864c:	f7 e3       	ldi	r31, 0x37	; 55
    864e:	2f 2e       	mov	r2, r31
    8650:	f0 e0       	ldi	r31, 0x00	; 0
    8652:	3f 2e       	mov	r3, r31
    8654:	3f ba       	out	0x1f, r3	; 31
    8656:	2e ba       	out	0x1e, r2	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    8658:	e0 9a       	sbi	0x1c, 0	; 28
    865a:	8d b3       	in	r24, 0x1d	; 29
	__value[1] = eeprom_read_byte(&DefShowDateTime);
    865c:	8a 83       	std	Y+2, r24	; 0x02
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    865e:	e1 99       	sbic	0x1c, 1	; 28
    8660:	fe cf       	rjmp	.-4      	; 0x865e <_menu_host+0x5c>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    8662:	e8 e3       	ldi	r30, 0x38	; 56
    8664:	4e 2e       	mov	r4, r30
    8666:	e0 e0       	ldi	r30, 0x00	; 0
    8668:	5e 2e       	mov	r5, r30
    866a:	5f ba       	out	0x1f, r5	; 31
    866c:	4e ba       	out	0x1e, r4	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    866e:	e0 9a       	sbi	0x1c, 0	; 28
    8670:	8d b3       	in	r24, 0x1d	; 29
	__value[2] = eeprom_read_byte(&DefNotifScreen);
    8672:	8b 83       	std	Y+3, r24	; 0x03
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    8674:	e1 99       	sbic	0x1c, 1	; 28
    8676:	fe cf       	rjmp	.-4      	; 0x8674 <_menu_host+0x72>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    8678:	70 e0       	ldi	r23, 0x00	; 0
    867a:	67 2e       	mov	r6, r23
    867c:	70 e0       	ldi	r23, 0x00	; 0
    867e:	77 2e       	mov	r7, r23
    8680:	7f ba       	out	0x1f, r7	; 31
    8682:	6e ba       	out	0x1e, r6	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    8684:	e0 9a       	sbi	0x1c, 0	; 28
    8686:	8d b3       	in	r24, 0x1d	; 29
	TermID= eeprom_read_byte(&DefIFT_ID);
    8688:	80 93 d1 02 	sts	0x02D1, r24


	lcd_clear();_delay_ms(10);
    868c:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
    8690:	84 ec       	ldi	r24, 0xC4	; 196
    8692:	99 e0       	ldi	r25, 0x09	; 9
    8694:	01 97       	sbiw	r24, 0x01	; 1
    8696:	f1 f7       	brne	.-4      	; 0x8694 <_menu_host+0x92>
	lcd_printf(1, 1, PSTR("1)Money :"));
    8698:	81 e0       	ldi	r24, 0x01	; 1
    869a:	61 e0       	ldi	r22, 0x01	; 1
    869c:	4f e3       	ldi	r20, 0x3F	; 63
    869e:	5b e0       	ldi	r21, 0x0B	; 11
    86a0:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
	lcd_printf(2, 1, PSTR("2)D/T   :"));
    86a4:	82 e0       	ldi	r24, 0x02	; 2
    86a6:	61 e0       	ldi	r22, 0x01	; 1
    86a8:	45 e3       	ldi	r20, 0x35	; 53
    86aa:	5b e0       	ldi	r21, 0x0B	; 11
    86ac:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
	lcd_printf(3, 1, PSTR("3)Notif :     *)Exit"));
    86b0:	83 e0       	ldi	r24, 0x03	; 3
    86b2:	61 e0       	ldi	r22, 0x01	; 1
    86b4:	40 e2       	ldi	r20, 0x20	; 32
    86b6:	5b e0       	ldi	r21, 0x0B	; 11
    86b8:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
   sprintf_P(lcdteks,PSTR("4)TermID:%d "),TermID);
    86bc:	00 d0       	rcall	.+0      	; 0x86be <_menu_host+0xbc>
    86be:	00 d0       	rcall	.+0      	; 0x86c0 <_menu_host+0xbe>
    86c0:	00 d0       	rcall	.+0      	; 0x86c2 <_menu_host+0xc0>
    86c2:	ed b7       	in	r30, 0x3d	; 61
    86c4:	fe b7       	in	r31, 0x3e	; 62
    86c6:	31 96       	adiw	r30, 0x01	; 1
    86c8:	8e 01       	movw	r16, r28
    86ca:	06 5f       	subi	r16, 0xF6	; 246
    86cc:	1f 4f       	sbci	r17, 0xFF	; 255
    86ce:	ad b7       	in	r26, 0x3d	; 61
    86d0:	be b7       	in	r27, 0x3e	; 62
    86d2:	12 96       	adiw	r26, 0x02	; 2
    86d4:	1c 93       	st	X, r17
    86d6:	0e 93       	st	-X, r16
    86d8:	11 97       	sbiw	r26, 0x01	; 1
    86da:	83 e1       	ldi	r24, 0x13	; 19
    86dc:	9b e0       	ldi	r25, 0x0B	; 11
    86de:	93 83       	std	Z+3, r25	; 0x03
    86e0:	82 83       	std	Z+2, r24	; 0x02
    86e2:	80 91 d1 02 	lds	r24, 0x02D1
    86e6:	84 83       	std	Z+4, r24	; 0x04
    86e8:	15 82       	std	Z+5, r1	; 0x05
    86ea:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
		 lcd_print(4, 1,lcdteks);
    86ee:	ed b7       	in	r30, 0x3d	; 61
    86f0:	fe b7       	in	r31, 0x3e	; 62
    86f2:	36 96       	adiw	r30, 0x06	; 6
    86f4:	0f b6       	in	r0, 0x3f	; 63
    86f6:	f8 94       	cli
    86f8:	fe bf       	out	0x3e, r31	; 62
    86fa:	0f be       	out	0x3f, r0	; 63
    86fc:	ed bf       	out	0x3d, r30	; 61
    86fe:	84 e0       	ldi	r24, 0x04	; 4
    8700:	61 e0       	ldi	r22, 0x01	; 1
    8702:	a8 01       	movw	r20, r16
    8704:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
	lcd_printf(4, 15, PSTR("#)Save"));
    8708:	84 e0       	ldi	r24, 0x04	; 4
    870a:	6f e0       	ldi	r22, 0x0F	; 15
    870c:	4c e0       	ldi	r20, 0x0C	; 12
    870e:	5b e0       	ldi	r21, 0x0B	; 11
    8710:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
    8714:	68 ef       	ldi	r22, 0xF8	; 248
    8716:	e6 2e       	mov	r14, r22
    8718:	62 e0       	ldi	r22, 0x02	; 2
    871a:	f6 2e       	mov	r15, r22
    871c:	6e 01       	movw	r12, r28
    871e:	08 94       	sec
    8720:	c1 1c       	adc	r12, r1
    8722:	d1 1c       	adc	r13, r1

	for(__i = 0; __i < 3; __i++){
		__x = pgm_read_byte(&__hostloc[__i][0]);
		__y = pgm_read_byte(&__hostloc[__i][1]);
		_f_inttostr(__buff, __value[__i]);
    8724:	55 e0       	ldi	r21, 0x05	; 5
    8726:	a5 2e       	mov	r10, r21
    8728:	b1 2c       	mov	r11, r1
    872a:	ac 0e       	add	r10, r28
    872c:	bd 1e       	adc	r11, r29
   sprintf_P(lcdteks,PSTR("4)TermID:%d "),TermID);
		 lcd_print(4, 1,lcdteks);
	lcd_printf(4, 15, PSTR("#)Save"));

	for(__i = 0; __i < 3; __i++){
		__x = pgm_read_byte(&__hostloc[__i][0]);
    872e:	f7 01       	movw	r30, r14
    8730:	04 91       	lpm	r16, Z+
		__y = pgm_read_byte(&__hostloc[__i][1]);
    8732:	08 94       	sec
    8734:	e1 1c       	adc	r14, r1
    8736:	f1 1c       	adc	r15, r1
    8738:	f7 01       	movw	r30, r14
    873a:	14 91       	lpm	r17, Z+
		_f_inttostr(__buff, __value[__i]);
    873c:	d6 01       	movw	r26, r12
    873e:	4d 91       	ld	r20, X+
    8740:	6d 01       	movw	r12, r26
    8742:	50 e0       	ldi	r21, 0x00	; 0
    8744:	60 e0       	ldi	r22, 0x00	; 0
    8746:	70 e0       	ldi	r23, 0x00	; 0
    8748:	c5 01       	movw	r24, r10
    874a:	0e 94 62 19 	call	0x32c4	; 0x32c4 <_f_inttostr>
		lcd_print(__x, __y, __buff);
    874e:	80 2f       	mov	r24, r16
    8750:	61 2f       	mov	r22, r17
    8752:	a5 01       	movw	r20, r10
    8754:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
    8758:	08 94       	sec
    875a:	e1 1c       	adc	r14, r1
    875c:	f1 1c       	adc	r15, r1
	lcd_printf(3, 1, PSTR("3)Notif :     *)Exit"));
   sprintf_P(lcdteks,PSTR("4)TermID:%d "),TermID);
		 lcd_print(4, 1,lcdteks);
	lcd_printf(4, 15, PSTR("#)Save"));

	for(__i = 0; __i < 3; __i++){
    875e:	be ef       	ldi	r27, 0xFE	; 254
    8760:	eb 16       	cp	r14, r27
    8762:	b2 e0       	ldi	r27, 0x02	; 2
    8764:	fb 06       	cpc	r15, r27
    8766:	19 f7       	brne	.-58     	; 0x872e <_menu_host+0x12c>
			lcd_print(__x, __y, __buff);
		}else
		if (__num=='4'){
		    if (TermID<=99)TermID++;
			else TermID=1;
	     sprintf_P(lcdteks,PSTR("4)TermID:%d "),TermID);
    8768:	4a e0       	ldi	r20, 0x0A	; 10
    876a:	a4 2e       	mov	r10, r20
    876c:	b1 2c       	mov	r11, r1
    876e:	ac 0e       	add	r10, r28
    8770:	bd 1e       	adc	r11, r29
    8772:	3f ef       	ldi	r19, 0xFF	; 255
    8774:	83 2e       	mov	r8, r19
    8776:	3a e0       	ldi	r19, 0x0A	; 10
    8778:	93 2e       	mov	r9, r19
			eeprom_write_byte(&DefNotifScreen, __value[2]);
			eeprom_write_byte(&DefIFT_ID,TermID);
			break;
		}
		if(__num >= 0x31 && __num <= 0x33){
			if(__value[__num - 0x31] == 1)
    877a:	6e 01       	movw	r12, r28
    877c:	08 94       	sec
    877e:	c1 1c       	adc	r12, r1
    8780:	d1 1c       	adc	r13, r1
				__value[__num - 0x31] = 0;
			else
				__value[__num - 0x31]++;
			__x = pgm_read_byte(&__hostloc[__num - 0x31][0]);
			__y = pgm_read_byte(&__hostloc[__num - 0x31][1]);
			_f_inttostr(__buff, __value[__num - 0x31]);
    8782:	25 e0       	ldi	r18, 0x05	; 5
    8784:	e2 2e       	mov	r14, r18
    8786:	f1 2c       	mov	r15, r1
    8788:	ec 0e       	add	r14, r28
    878a:	fd 1e       	adc	r15, r29
		_f_inttostr(__buff, __value[__i]);
		lcd_print(__x, __y, __buff);
	}

	while(1){
		__key = _key_scan(1);
    878c:	81 e0       	ldi	r24, 0x01	; 1
    878e:	0e 94 ab ae 	call	0x15d56	; 0x15d56 <_key_scan>
    8792:	18 2f       	mov	r17, r24
		__num = _key_btn(__key);
    8794:	0e 94 0c ae 	call	0x15c18	; 0x15c18 <_key_btn>
    8798:	98 2f       	mov	r25, r24

		if(__key == _KEY_CANCEL)
    879a:	17 3e       	cpi	r17, 0xE7	; 231
    879c:	09 f4       	brne	.+2      	; 0x87a0 <_menu_host+0x19e>
    879e:	95 c0       	rjmp	.+298    	; 0x88ca <_menu_host+0x2c8>
			return;
		if(__key==_KEY_ENTER){
    87a0:	17 3b       	cpi	r17, 0xB7	; 183
    87a2:	09 f0       	breq	.+2      	; 0x87a6 <_menu_host+0x1a4>
    87a4:	30 c0       	rjmp	.+96     	; 0x8806 <_menu_host+0x204>
			eeprom_write_byte(&DefPrintMoney, __value[0]);
    87a6:	89 81       	ldd	r24, Y+1	; 0x01
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    87a8:	e1 99       	sbic	0x1c, 1	; 28
    87aa:	fe cf       	rjmp	.-4      	; 0x87a8 <_menu_host+0x1a6>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    87ac:	e1 ec       	ldi	r30, 0xC1	; 193
    87ae:	f3 e0       	ldi	r31, 0x03	; 3
    87b0:	ff bb       	out	0x1f, r31	; 31
    87b2:	ee bb       	out	0x1e, r30	; 30
#endif
    EEDR = __value;
    87b4:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    87b6:	0f b6       	in	r0, 0x3f	; 63
    87b8:	f8 94       	cli
    87ba:	e2 9a       	sbi	0x1c, 2	; 28
    87bc:	e1 9a       	sbi	0x1c, 1	; 28
    87be:	0f be       	out	0x3f, r0	; 63
			eeprom_write_byte(&DefShowDateTime, __value[1]);
    87c0:	8a 81       	ldd	r24, Y+2	; 0x02
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    87c2:	e1 99       	sbic	0x1c, 1	; 28
    87c4:	fe cf       	rjmp	.-4      	; 0x87c2 <_menu_host+0x1c0>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    87c6:	3f ba       	out	0x1f, r3	; 31
    87c8:	2e ba       	out	0x1e, r2	; 30
#endif
    EEDR = __value;
    87ca:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    87cc:	0f b6       	in	r0, 0x3f	; 63
    87ce:	f8 94       	cli
    87d0:	e2 9a       	sbi	0x1c, 2	; 28
    87d2:	e1 9a       	sbi	0x1c, 1	; 28
    87d4:	0f be       	out	0x3f, r0	; 63
			eeprom_write_byte(&DefNotifScreen, __value[2]);
    87d6:	8b 81       	ldd	r24, Y+3	; 0x03
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    87d8:	e1 99       	sbic	0x1c, 1	; 28
    87da:	fe cf       	rjmp	.-4      	; 0x87d8 <_menu_host+0x1d6>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    87dc:	5f ba       	out	0x1f, r5	; 31
    87de:	4e ba       	out	0x1e, r4	; 30
#endif
    EEDR = __value;
    87e0:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    87e2:	0f b6       	in	r0, 0x3f	; 63
    87e4:	f8 94       	cli
    87e6:	e2 9a       	sbi	0x1c, 2	; 28
    87e8:	e1 9a       	sbi	0x1c, 1	; 28
    87ea:	0f be       	out	0x3f, r0	; 63
			eeprom_write_byte(&DefIFT_ID,TermID);
    87ec:	80 91 d1 02 	lds	r24, 0x02D1
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    87f0:	e1 99       	sbic	0x1c, 1	; 28
    87f2:	fe cf       	rjmp	.-4      	; 0x87f0 <_menu_host+0x1ee>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    87f4:	7f ba       	out	0x1f, r7	; 31
    87f6:	6e ba       	out	0x1e, r6	; 30
#endif
    EEDR = __value;
    87f8:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    87fa:	0f b6       	in	r0, 0x3f	; 63
    87fc:	f8 94       	cli
    87fe:	e2 9a       	sbi	0x1c, 2	; 28
    8800:	e1 9a       	sbi	0x1c, 1	; 28
    8802:	0f be       	out	0x3f, r0	; 63
    8804:	62 c0       	rjmp	.+196    	; 0x88ca <_menu_host+0x2c8>
			break;
		}
		if(__num >= 0x31 && __num <= 0x33){
    8806:	81 53       	subi	r24, 0x31	; 49
    8808:	83 30       	cpi	r24, 0x03	; 3
    880a:	58 f5       	brcc	.+86     	; 0x8862 <_menu_host+0x260>
			if(__value[__num - 0x31] == 1)
    880c:	a9 2f       	mov	r26, r25
    880e:	b0 e0       	ldi	r27, 0x00	; 0
    8810:	d1 97       	sbiw	r26, 0x31	; 49
    8812:	f6 01       	movw	r30, r12
    8814:	ea 0f       	add	r30, r26
    8816:	fb 1f       	adc	r31, r27
    8818:	80 81       	ld	r24, Z
    881a:	81 30       	cpi	r24, 0x01	; 1
    881c:	11 f4       	brne	.+4      	; 0x8822 <_menu_host+0x220>
				__value[__num - 0x31] = 0;
    881e:	10 82       	st	Z, r1
    8820:	02 c0       	rjmp	.+4      	; 0x8826 <_menu_host+0x224>
			else
				__value[__num - 0x31]++;
    8822:	8f 5f       	subi	r24, 0xFF	; 255
    8824:	80 83       	st	Z, r24
			__x = pgm_read_byte(&__hostloc[__num - 0x31][0]);
    8826:	29 2f       	mov	r18, r25
    8828:	30 e0       	ldi	r19, 0x00	; 0
    882a:	21 53       	subi	r18, 0x31	; 49
    882c:	30 40       	sbci	r19, 0x00	; 0
    882e:	22 0f       	add	r18, r18
    8830:	33 1f       	adc	r19, r19
    8832:	c9 01       	movw	r24, r18
    8834:	88 50       	subi	r24, 0x08	; 8
    8836:	9d 4f       	sbci	r25, 0xFD	; 253
    8838:	fc 01       	movw	r30, r24
    883a:	04 91       	lpm	r16, Z+
			__y = pgm_read_byte(&__hostloc[__num - 0x31][1]);
    883c:	27 50       	subi	r18, 0x07	; 7
    883e:	3d 4f       	sbci	r19, 0xFD	; 253
    8840:	f9 01       	movw	r30, r18
    8842:	14 91       	lpm	r17, Z+
			_f_inttostr(__buff, __value[__num - 0x31]);
    8844:	ac 0d       	add	r26, r12
    8846:	bd 1d       	adc	r27, r13
    8848:	4c 91       	ld	r20, X
    884a:	50 e0       	ldi	r21, 0x00	; 0
    884c:	60 e0       	ldi	r22, 0x00	; 0
    884e:	70 e0       	ldi	r23, 0x00	; 0
    8850:	c7 01       	movw	r24, r14
    8852:	0e 94 62 19 	call	0x32c4	; 0x32c4 <_f_inttostr>
			lcd_print(__x, __y, __buff);
    8856:	80 2f       	mov	r24, r16
    8858:	61 2f       	mov	r22, r17
    885a:	a7 01       	movw	r20, r14
    885c:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
    8860:	95 cf       	rjmp	.-214    	; 0x878c <_menu_host+0x18a>
		}else
		if (__num=='4'){
    8862:	94 33       	cpi	r25, 0x34	; 52
    8864:	09 f0       	breq	.+2      	; 0x8868 <_menu_host+0x266>
    8866:	92 cf       	rjmp	.-220    	; 0x878c <_menu_host+0x18a>
		    if (TermID<=99)TermID++;
    8868:	80 91 d1 02 	lds	r24, 0x02D1
    886c:	84 36       	cpi	r24, 0x64	; 100
    886e:	10 f4       	brcc	.+4      	; 0x8874 <_menu_host+0x272>
    8870:	8f 5f       	subi	r24, 0xFF	; 255
    8872:	01 c0       	rjmp	.+2      	; 0x8876 <_menu_host+0x274>
			else TermID=1;
    8874:	81 e0       	ldi	r24, 0x01	; 1
    8876:	80 93 d1 02 	sts	0x02D1, r24
	     sprintf_P(lcdteks,PSTR("4)TermID:%d "),TermID);
    887a:	00 d0       	rcall	.+0      	; 0x887c <_menu_host+0x27a>
    887c:	00 d0       	rcall	.+0      	; 0x887e <_menu_host+0x27c>
    887e:	00 d0       	rcall	.+0      	; 0x8880 <_menu_host+0x27e>
    8880:	ed b7       	in	r30, 0x3d	; 61
    8882:	fe b7       	in	r31, 0x3e	; 62
    8884:	31 96       	adiw	r30, 0x01	; 1
    8886:	ad b7       	in	r26, 0x3d	; 61
    8888:	be b7       	in	r27, 0x3e	; 62
    888a:	12 96       	adiw	r26, 0x02	; 2
    888c:	bc 92       	st	X, r11
    888e:	ae 92       	st	-X, r10
    8890:	11 97       	sbiw	r26, 0x01	; 1
    8892:	93 82       	std	Z+3, r9	; 0x03
    8894:	82 82       	std	Z+2, r8	; 0x02
    8896:	80 91 d1 02 	lds	r24, 0x02D1
    889a:	84 83       	std	Z+4, r24	; 0x04
    889c:	15 82       	std	Z+5, r1	; 0x05
    889e:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
		 lcd_print(4, 1,lcdteks);lcd_printf(4, 15, PSTR("#)Save"));
    88a2:	ed b7       	in	r30, 0x3d	; 61
    88a4:	fe b7       	in	r31, 0x3e	; 62
    88a6:	36 96       	adiw	r30, 0x06	; 6
    88a8:	0f b6       	in	r0, 0x3f	; 63
    88aa:	f8 94       	cli
    88ac:	fe bf       	out	0x3e, r31	; 62
    88ae:	0f be       	out	0x3f, r0	; 63
    88b0:	ed bf       	out	0x3d, r30	; 61
    88b2:	84 e0       	ldi	r24, 0x04	; 4
    88b4:	61 e0       	ldi	r22, 0x01	; 1
    88b6:	a5 01       	movw	r20, r10
    88b8:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
    88bc:	84 e0       	ldi	r24, 0x04	; 4
    88be:	6f e0       	ldi	r22, 0x0F	; 15
    88c0:	48 ef       	ldi	r20, 0xF8	; 248
    88c2:	5a e0       	ldi	r21, 0x0A	; 10
    88c4:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
    88c8:	61 cf       	rjmp	.-318    	; 0x878c <_menu_host+0x18a>
		 
		}

	}
}
    88ca:	6d 96       	adiw	r28, 0x1d	; 29
    88cc:	0f b6       	in	r0, 0x3f	; 63
    88ce:	f8 94       	cli
    88d0:	de bf       	out	0x3e, r29	; 62
    88d2:	0f be       	out	0x3f, r0	; 63
    88d4:	cd bf       	out	0x3d, r28	; 61
    88d6:	cf 91       	pop	r28
    88d8:	df 91       	pop	r29
    88da:	1f 91       	pop	r17
    88dc:	0f 91       	pop	r16
    88de:	ff 90       	pop	r15
    88e0:	ef 90       	pop	r14
    88e2:	df 90       	pop	r13
    88e4:	cf 90       	pop	r12
    88e6:	bf 90       	pop	r11
    88e8:	af 90       	pop	r10
    88ea:	9f 90       	pop	r9
    88ec:	8f 90       	pop	r8
    88ee:	7f 90       	pop	r7
    88f0:	6f 90       	pop	r6
    88f2:	5f 90       	pop	r5
    88f4:	4f 90       	pop	r4
    88f6:	3f 90       	pop	r3
    88f8:	2f 90       	pop	r2
    88fa:	08 95       	ret

000088fc <FSettingHost>:
char FSettingPrinter(){
     _menu_printer();
	 return MENU_DONE;
}
char FSettingHost(){
     _menu_host();
    88fc:	0e 94 01 43 	call	0x8602	; 0x8602 <_menu_host>
	 return MENU_DONE;
}
    8900:	81 e0       	ldi	r24, 0x01	; 1
    8902:	08 95       	ret

00008904 <system_stop>:
	return Result;
}

void system_stop(){
	 char __key,__num;
	 lcd_printf(4,1,PSTR("Press any key..     "));
    8904:	84 e0       	ldi	r24, 0x04	; 4
    8906:	61 e0       	ldi	r22, 0x01	; 1
    8908:	44 e2       	ldi	r20, 0x24	; 36
    890a:	52 e2       	ldi	r21, 0x22	; 34
    890c:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    8910:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    8912:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    8914:	85 e0       	ldi	r24, 0x05	; 5
    8916:	90 e0       	ldi	r25, 0x00	; 0
    8918:	90 93 d7 01 	sts	0x01D7, r25
    891c:	80 93 d6 01 	sts	0x01D6, r24
void system_stop(){
	 char __key,__num;
	 lcd_printf(4,1,PSTR("Press any key..     "));
	 system_beep(5);
	 while(1){
		__key = _key_scan(1);
    8920:	81 e0       	ldi	r24, 0x01	; 1
    8922:	0e 94 ab ae 	call	0x15d56	; 0x15d56 <_key_scan>
		__num = _key_btn(__key);
    8926:	0e 94 0c ae 	call	0x15c18	; 0x15c18 <_key_btn>
		if ((__num>='0')&&(__num<='9')||(IsStandAloneDetected==True)) 
    892a:	80 53       	subi	r24, 0x30	; 48
    892c:	8a 30       	cpi	r24, 0x0A	; 10
    892e:	20 f0       	brcs	.+8      	; 0x8938 <system_stop+0x34>
    8930:	80 91 b3 01 	lds	r24, 0x01B3
    8934:	81 30       	cpi	r24, 0x01	; 1
    8936:	a1 f7       	brne	.-24     	; 0x8920 <system_stop+0x1c>
    8938:	08 95       	ret

0000893a <systemForceType>:
	 }
}

char systemForceType(){
     char Result,KeyChar;
	 lcd_printf(4,1,PSTR("[1]Slave [2]Standalone"));
    893a:	84 e0       	ldi	r24, 0x04	; 4
    893c:	61 e0       	ldi	r22, 0x01	; 1
    893e:	49 e3       	ldi	r20, 0x39	; 57
    8940:	52 e2       	ldi	r21, 0x22	; 34
    8942:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    8946:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    8948:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    894a:	81 e0       	ldi	r24, 0x01	; 1
    894c:	90 e0       	ldi	r25, 0x00	; 0
    894e:	90 93 d7 01 	sts	0x01D7, r25
    8952:	80 93 d6 01 	sts	0x01D6, r24
    8956:	80 e5       	ldi	r24, 0x50	; 80
    8958:	93 ec       	ldi	r25, 0xC3	; 195
    895a:	01 97       	sbiw	r24, 0x01	; 1
    895c:	f1 f7       	brne	.-4      	; 0x895a <systemForceType+0x20>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    895e:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    8960:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    8962:	82 e0       	ldi	r24, 0x02	; 2
    8964:	90 e0       	ldi	r25, 0x00	; 0
    8966:	90 93 d7 01 	sts	0x01D7, r25
    896a:	80 93 d6 01 	sts	0x01D6, r24
	 lcd_printf(4,1,PSTR("[1]Slave [2]Standalone"));
	 system_beep(1);
	 _delay_ms(200);
	 system_beep(2);
	 while(1){
	    KeyChar=_key_btn(_key_scan(1));
    896e:	81 e0       	ldi	r24, 0x01	; 1
    8970:	0e 94 ab ae 	call	0x15d56	; 0x15d56 <_key_scan>
    8974:	0e 94 0c ae 	call	0x15c18	; 0x15c18 <_key_btn>
    8978:	98 2f       	mov	r25, r24
		if ((KeyChar=='1')||(KeyChar=='2')){
    897a:	81 53       	subi	r24, 0x31	; 49
    897c:	82 30       	cpi	r24, 0x02	; 2
    897e:	b8 f7       	brcc	.-18     	; 0x896e <systemForceType+0x34>
		    Result=KeyChar;
			break;
		}
	 }
	return Result;
}
    8980:	89 2f       	mov	r24, r25
    8982:	08 95       	ret

00008984 <SetTotalizerData>:
			  }
		  }
	 }
}

void SetTotalizerData(char TType, char TAddr, char xPumpAddr, char xGradeAddr, char *strValue){// 0 1 1 "00000000"
    8984:	af 92       	push	r10
    8986:	bf 92       	push	r11
    8988:	cf 92       	push	r12
    898a:	df 92       	push	r13
    898c:	ef 92       	push	r14
    898e:	ff 92       	push	r15
    8990:	0f 93       	push	r16
    8992:	1f 93       	push	r17
    8994:	df 93       	push	r29
    8996:	cf 93       	push	r28
    8998:	cd b7       	in	r28, 0x3d	; 61
    899a:	de b7       	in	r29, 0x3e	; 62
    899c:	65 97       	sbiw	r28, 0x15	; 21
    899e:	0f b6       	in	r0, 0x3f	; 63
    89a0:	f8 94       	cli
    89a2:	de bf       	out	0x3e, r29	; 62
    89a4:	0f be       	out	0x3f, r0	; 63
    89a6:	cd bf       	out	0x3d, r28	; 61
    89a8:	d8 2e       	mov	r13, r24
    89aa:	c6 2e       	mov	r12, r22
    89ac:	b4 2e       	mov	r11, r20
    89ae:	a2 2e       	mov	r10, r18
     char rawValue[6],iPumpAddr,iGrade;
	 char strPValue[15];
	 char Idx;
	 char strSend[30];
	 //Convert String to RawData
	 if (strlen(strValue)<=12){
    89b0:	d8 01       	movw	r26, r16
    89b2:	0d 90       	ld	r0, X+
    89b4:	00 20       	and	r0, r0
    89b6:	e9 f7       	brne	.-6      	; 0x89b2 <SetTotalizerData+0x2e>
    89b8:	11 97       	sbiw	r26, 0x01	; 1
    89ba:	a0 1b       	sub	r26, r16
    89bc:	b1 0b       	sbc	r27, r17
    89be:	87 e0       	ldi	r24, 0x07	; 7
    89c0:	e8 2e       	mov	r14, r24
    89c2:	f1 2c       	mov	r15, r1
    89c4:	ec 0e       	add	r14, r28
    89c6:	fd 1e       	adc	r15, r29
    89c8:	ad 30       	cpi	r26, 0x0D	; 13
    89ca:	b1 05       	cpc	r27, r1
    89cc:	58 f5       	brcc	.+86     	; 0x8a24 <SetTotalizerData+0xa0>
	     sprintf_P(strPValue,PSTR("%s"),strValue);
    89ce:	00 d0       	rcall	.+0      	; 0x89d0 <SetTotalizerData+0x4c>
    89d0:	00 d0       	rcall	.+0      	; 0x89d2 <SetTotalizerData+0x4e>
    89d2:	00 d0       	rcall	.+0      	; 0x89d4 <SetTotalizerData+0x50>
    89d4:	ed b7       	in	r30, 0x3d	; 61
    89d6:	fe b7       	in	r31, 0x3e	; 62
    89d8:	31 96       	adiw	r30, 0x01	; 1
    89da:	ad b7       	in	r26, 0x3d	; 61
    89dc:	be b7       	in	r27, 0x3e	; 62
    89de:	12 96       	adiw	r26, 0x02	; 2
    89e0:	fc 92       	st	X, r15
    89e2:	ee 92       	st	-X, r14
    89e4:	11 97       	sbiw	r26, 0x01	; 1
    89e6:	88 ee       	ldi	r24, 0xE8	; 232
    89e8:	95 e0       	ldi	r25, 0x05	; 5
    89ea:	93 83       	std	Z+3, r25	; 0x03
    89ec:	82 83       	std	Z+2, r24	; 0x02
    89ee:	15 83       	std	Z+5, r17	; 0x05
    89f0:	04 83       	std	Z+4, r16	; 0x04
    89f2:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
		 if (strlen(strPValue)<12)AddZeroLead(strPValue,12);
    89f6:	f7 01       	movw	r30, r14
    89f8:	01 90       	ld	r0, Z+
    89fa:	00 20       	and	r0, r0
    89fc:	e9 f7       	brne	.-6      	; 0x89f8 <SetTotalizerData+0x74>
    89fe:	31 97       	sbiw	r30, 0x01	; 1
    8a00:	ee 19       	sub	r30, r14
    8a02:	ff 09       	sbc	r31, r15
    8a04:	6d b7       	in	r22, 0x3d	; 61
    8a06:	7e b7       	in	r23, 0x3e	; 62
    8a08:	6a 5f       	subi	r22, 0xFA	; 250
    8a0a:	7f 4f       	sbci	r23, 0xFF	; 255
    8a0c:	0f b6       	in	r0, 0x3f	; 63
    8a0e:	f8 94       	cli
    8a10:	7e bf       	out	0x3e, r23	; 62
    8a12:	0f be       	out	0x3f, r0	; 63
    8a14:	6d bf       	out	0x3d, r22	; 61
    8a16:	3c 97       	sbiw	r30, 0x0c	; 12
    8a18:	a0 f4       	brcc	.+40     	; 0x8a42 <SetTotalizerData+0xbe>
    8a1a:	c7 01       	movw	r24, r14
    8a1c:	6c e0       	ldi	r22, 0x0C	; 12
    8a1e:	0e 94 5b 25 	call	0x4ab6	; 0x4ab6 <AddZeroLead>
    8a22:	0f c0       	rjmp	.+30     	; 0x8a42 <SetTotalizerData+0xbe>
    8a24:	8a 2f       	mov	r24, r26
    8a26:	8c 50       	subi	r24, 0x0C	; 12
    8a28:	f8 01       	movw	r30, r16
    8a2a:	e8 0f       	add	r30, r24
    8a2c:	f1 1d       	adc	r31, r1
    8a2e:	d7 01       	movw	r26, r14
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8a30:	9e 01       	movw	r18, r28
    8a32:	2d 5e       	subi	r18, 0xED	; 237
    8a34:	3f 4f       	sbci	r19, 0xFF	; 255
	    Dest[i]=Source[IdxSource+i];
    8a36:	81 91       	ld	r24, Z+
    8a38:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8a3a:	a2 17       	cp	r26, r18
    8a3c:	b3 07       	cpc	r27, r19
    8a3e:	d9 f7       	brne	.-10     	; 0x8a36 <SetTotalizerData+0xb2>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8a40:	1b 8a       	std	Y+19, r1	; 0x13
	 else {//Lebih dari 8: 0123456789
	     Idx=strlen(strValue)-12;
	     StrPosCopy(strValue,strPValue,Idx,12);
	 }

	 iPumpAddr=(xPumpAddr&0x0F);
    8a42:	0b 2d       	mov	r16, r11
    8a44:	0f 70       	andi	r16, 0x0F	; 15
	 if ((xGradeAddr>=1)&&(xGradeAddr<=6))
    8a46:	1a 2d       	mov	r17, r10
    8a48:	11 50       	subi	r17, 0x01	; 1
    8a4a:	16 30       	cpi	r17, 0x06	; 6
    8a4c:	08 f0       	brcs	.+2      	; 0x8a50 <SetTotalizerData+0xcc>
    8a4e:	10 e0       	ldi	r17, 0x00	; 0
	     iGrade=xGradeAddr-1;
	 StrToRaw(strPValue,rawValue);
    8a50:	ce 01       	movw	r24, r28
    8a52:	07 96       	adiw	r24, 0x07	; 7
    8a54:	7e 01       	movw	r14, r28
    8a56:	08 94       	sec
    8a58:	e1 1c       	adc	r14, r1
    8a5a:	f1 1c       	adc	r15, r1
    8a5c:	b7 01       	movw	r22, r14
    8a5e:	0e 94 d1 19 	call	0x33a2	; 0x33a2 <StrToRaw>

	 if (TType==TVOLUME)eeprom_write_block((const void*)&rawValue,(void*)&(TotalVolume[TAddr][iPumpAddr][iGrade]), sizeof(rawValue));
    8a62:	dd 20       	and	r13, r13
    8a64:	d9 f4       	brne	.+54     	; 0x8a9c <SetTotalizerData+0x118>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    8a66:	84 e2       	ldi	r24, 0x24	; 36
    8a68:	08 9f       	mul	r16, r24
    8a6a:	c0 01       	movw	r24, r0
    8a6c:	11 24       	eor	r1, r1
    8a6e:	4c 2d       	mov	r20, r12
    8a70:	50 e0       	ldi	r21, 0x00	; 0
    8a72:	20 e2       	ldi	r18, 0x20	; 32
    8a74:	31 e0       	ldi	r19, 0x01	; 1
    8a76:	d9 01       	movw	r26, r18
    8a78:	4a 9f       	mul	r20, r26
    8a7a:	90 01       	movw	r18, r0
    8a7c:	4b 9f       	mul	r20, r27
    8a7e:	30 0d       	add	r19, r0
    8a80:	5a 9f       	mul	r21, r26
    8a82:	30 0d       	add	r19, r0
    8a84:	11 24       	eor	r1, r1
    8a86:	82 0f       	add	r24, r18
    8a88:	93 1f       	adc	r25, r19
    8a8a:	26 e0       	ldi	r18, 0x06	; 6
    8a8c:	12 9f       	mul	r17, r18
    8a8e:	90 01       	movw	r18, r0
    8a90:	11 24       	eor	r1, r1
    8a92:	82 0f       	add	r24, r18
    8a94:	93 1f       	adc	r25, r19
    8a96:	8d 53       	subi	r24, 0x3D	; 61
    8a98:	9c 4f       	sbci	r25, 0xFC	; 252
    8a9a:	1d c0       	rjmp	.+58     	; 0x8ad6 <SetTotalizerData+0x152>
	 else 
	 if (TType==TMONEY)eeprom_write_block((const void*)&rawValue,(void*)&(TotalMoney[TAddr][iPumpAddr][iGrade]), sizeof(rawValue));
    8a9c:	b1 e0       	ldi	r27, 0x01	; 1
    8a9e:	db 16       	cp	r13, r27
    8aa0:	09 f5       	brne	.+66     	; 0x8ae4 <SetTotalizerData+0x160>
    8aa2:	84 e2       	ldi	r24, 0x24	; 36
    8aa4:	08 9f       	mul	r16, r24
    8aa6:	c0 01       	movw	r24, r0
    8aa8:	11 24       	eor	r1, r1
    8aaa:	4c 2d       	mov	r20, r12
    8aac:	50 e0       	ldi	r21, 0x00	; 0
    8aae:	20 e2       	ldi	r18, 0x20	; 32
    8ab0:	31 e0       	ldi	r19, 0x01	; 1
    8ab2:	b9 01       	movw	r22, r18
    8ab4:	46 9f       	mul	r20, r22
    8ab6:	90 01       	movw	r18, r0
    8ab8:	47 9f       	mul	r20, r23
    8aba:	30 0d       	add	r19, r0
    8abc:	56 9f       	mul	r21, r22
    8abe:	30 0d       	add	r19, r0
    8ac0:	11 24       	eor	r1, r1
    8ac2:	82 0f       	add	r24, r18
    8ac4:	93 1f       	adc	r25, r19
    8ac6:	26 e0       	ldi	r18, 0x06	; 6
    8ac8:	12 9f       	mul	r17, r18
    8aca:	90 01       	movw	r18, r0
    8acc:	11 24       	eor	r1, r1
    8ace:	82 0f       	add	r24, r18
    8ad0:	93 1f       	adc	r25, r19
    8ad2:	8d 5f       	subi	r24, 0xFD	; 253
    8ad4:	99 4f       	sbci	r25, 0xF9	; 249
    8ad6:	b7 01       	movw	r22, r14
    8ad8:	46 e0       	ldi	r20, 0x06	; 6
    8ada:	50 e0       	ldi	r21, 0x00	; 0
    8adc:	2b ef       	ldi	r18, 0xFB	; 251
    8ade:	32 e1       	ldi	r19, 0x12	; 18
    8ae0:	0e 94 3b b4 	call	0x16876	; 0x16876 <__eewr_block>
}
    8ae4:	65 96       	adiw	r28, 0x15	; 21
    8ae6:	0f b6       	in	r0, 0x3f	; 63
    8ae8:	f8 94       	cli
    8aea:	de bf       	out	0x3e, r29	; 62
    8aec:	0f be       	out	0x3f, r0	; 63
    8aee:	cd bf       	out	0x3d, r28	; 61
    8af0:	cf 91       	pop	r28
    8af2:	df 91       	pop	r29
    8af4:	1f 91       	pop	r17
    8af6:	0f 91       	pop	r16
    8af8:	ff 90       	pop	r15
    8afa:	ef 90       	pop	r14
    8afc:	df 90       	pop	r13
    8afe:	cf 90       	pop	r12
    8b00:	bf 90       	pop	r11
    8b02:	af 90       	pop	r10
    8b04:	08 95       	ret

00008b06 <SaveTotalizerCurrentToLast>:
	 }Dest[12]=0;
}

//SetTotalizerData(TVOLUME,TOTALIZER_NOW,1,1,strVolume)

void SaveTotalizerCurrentToLast(){
    8b06:	4f 92       	push	r4
    8b08:	5f 92       	push	r5
    8b0a:	7f 92       	push	r7
    8b0c:	8f 92       	push	r8
    8b0e:	9f 92       	push	r9
    8b10:	af 92       	push	r10
    8b12:	bf 92       	push	r11
    8b14:	cf 92       	push	r12
    8b16:	df 92       	push	r13
    8b18:	ef 92       	push	r14
    8b1a:	ff 92       	push	r15
    8b1c:	0f 93       	push	r16
    8b1e:	1f 93       	push	r17
    8b20:	df 93       	push	r29
    8b22:	cf 93       	push	r28
    8b24:	cd b7       	in	r28, 0x3d	; 61
    8b26:	de b7       	in	r29, 0x3e	; 62
    8b28:	2f 97       	sbiw	r28, 0x0f	; 15
    8b2a:	0f b6       	in	r0, 0x3f	; 63
    8b2c:	f8 94       	cli
    8b2e:	de bf       	out	0x3e, r29	; 62
    8b30:	0f be       	out	0x3f, r0	; 63
    8b32:	cd bf       	out	0x3d, r28	; 61
    8b34:	77 24       	eor	r7, r7
    8b36:	73 94       	inc	r7
	 
	 for (iPump=1;iPump<=16;iPump++){//Pump
	      FIPAddr=GetFIPAddr(iPump);
		  if (FIPAddr>0){
		      FIPAddr=FIPAddr-1;
			  for(iGrade=1;iGrade<=6;iGrade++){
    8b38:	4e 01       	movw	r8, r28
    8b3a:	08 94       	sec
    8b3c:	81 1c       	adc	r8, r1
    8b3e:	91 1c       	adc	r9, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    8b40:	90 e1       	ldi	r25, 0x10	; 16
    8b42:	49 2e       	mov	r4, r25
    8b44:	51 2c       	mov	r5, r1
    8b46:	4c 0e       	add	r4, r28
    8b48:	5d 1e       	adc	r5, r29
     char iPump,iGrade;
     char strValue[15];
     char FIPAddr;
	 
	 for (iPump=1;iPump<=16;iPump++){//Pump
	      FIPAddr=GetFIPAddr(iPump);
    8b4a:	87 2d       	mov	r24, r7
    8b4c:	0e 94 39 1c 	call	0x3872	; 0x3872 <GetFIPAddr>
		  if (FIPAddr>0){
    8b50:	88 23       	and	r24, r24
    8b52:	91 f1       	breq	.+100    	; 0x8bb8 <SaveTotalizerCurrentToLast+0xb2>
		      FIPAddr=FIPAddr-1;
    8b54:	a8 2e       	mov	r10, r24
    8b56:	aa 94       	dec	r10
    8b58:	bb 24       	eor	r11, r11
    8b5a:	b3 94       	inc	r11
    8b5c:	2a c0       	rjmp	.+84     	; 0x8bb2 <SaveTotalizerCurrentToLast+0xac>
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    8b5e:	f7 01       	movw	r30, r14
    8b60:	11 92       	st	Z+, r1
    8b62:	7f 01       	movw	r14, r30

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    8b64:	e4 15       	cp	r30, r4
    8b66:	f5 05       	cpc	r31, r5
    8b68:	d1 f7       	brne	.-12     	; 0x8b5e <SaveTotalizerCurrentToLast+0x58>
	      FIPAddr=GetFIPAddr(iPump);
		  if (FIPAddr>0){
		      FIPAddr=FIPAddr-1;
			  for(iGrade=1;iGrade<=6;iGrade++){
				  FillChar(strValue,sizeof(strValue),0);
				  GetTotalizerData(TVOLUME,TOTALIZER_NOW,FIPAddr,iGrade,strValue);
    8b6a:	80 e0       	ldi	r24, 0x00	; 0
    8b6c:	61 e0       	ldi	r22, 0x01	; 1
    8b6e:	4a 2d       	mov	r20, r10
    8b70:	2b 2d       	mov	r18, r11
    8b72:	84 01       	movw	r16, r8
    8b74:	0e 94 f8 1c 	call	0x39f0	; 0x39f0 <GetTotalizerData>
				  SetTotalizerData(TVOLUME,TOTALIZER_LAST,FIPAddr,iGrade,strValue);
    8b78:	80 e0       	ldi	r24, 0x00	; 0
    8b7a:	60 e0       	ldi	r22, 0x00	; 0
    8b7c:	4a 2d       	mov	r20, r10
    8b7e:	2b 2d       	mov	r18, r11
    8b80:	0e 94 c2 44 	call	0x8984	; 0x8984 <SetTotalizerData>
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    8b84:	f6 01       	movw	r30, r12
    8b86:	11 92       	st	Z+, r1
    8b88:	6f 01       	movw	r12, r30

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    8b8a:	ee 15       	cp	r30, r14
    8b8c:	ff 05       	cpc	r31, r15
    8b8e:	d1 f7       	brne	.-12     	; 0x8b84 <SaveTotalizerCurrentToLast+0x7e>
			  for(iGrade=1;iGrade<=6;iGrade++){
				  FillChar(strValue,sizeof(strValue),0);
				  GetTotalizerData(TVOLUME,TOTALIZER_NOW,FIPAddr,iGrade,strValue);
				  SetTotalizerData(TVOLUME,TOTALIZER_LAST,FIPAddr,iGrade,strValue);
				  FillChar(strValue,sizeof(strValue),0);
				  GetTotalizerData(TMONEY,TOTALIZER_NOW,FIPAddr,iGrade,strValue);
    8b90:	81 e0       	ldi	r24, 0x01	; 1
    8b92:	61 e0       	ldi	r22, 0x01	; 1
    8b94:	4a 2d       	mov	r20, r10
    8b96:	2b 2d       	mov	r18, r11
    8b98:	84 01       	movw	r16, r8
    8b9a:	0e 94 f8 1c 	call	0x39f0	; 0x39f0 <GetTotalizerData>
				  SetTotalizerData(TMONEY,TOTALIZER_LAST,FIPAddr,iGrade,strValue);
    8b9e:	81 e0       	ldi	r24, 0x01	; 1
    8ba0:	60 e0       	ldi	r22, 0x00	; 0
    8ba2:	4a 2d       	mov	r20, r10
    8ba4:	2b 2d       	mov	r18, r11
    8ba6:	0e 94 c2 44 	call	0x8984	; 0x8984 <SetTotalizerData>
	 
	 for (iPump=1;iPump<=16;iPump++){//Pump
	      FIPAddr=GetFIPAddr(iPump);
		  if (FIPAddr>0){
		      FIPAddr=FIPAddr-1;
			  for(iGrade=1;iGrade<=6;iGrade++){
    8baa:	b3 94       	inc	r11
    8bac:	f7 e0       	ldi	r31, 0x07	; 7
    8bae:	bf 16       	cp	r11, r31
    8bb0:	19 f0       	breq	.+6      	; 0x8bb8 <SaveTotalizerCurrentToLast+0xb2>
    8bb2:	64 01       	movw	r12, r8
    8bb4:	74 01       	movw	r14, r8
    8bb6:	d3 cf       	rjmp	.-90     	; 0x8b5e <SaveTotalizerCurrentToLast+0x58>
void SaveTotalizerCurrentToLast(){
     char iPump,iGrade;
     char strValue[15];
     char FIPAddr;
	 
	 for (iPump=1;iPump<=16;iPump++){//Pump
    8bb8:	73 94       	inc	r7
    8bba:	81 e1       	ldi	r24, 0x11	; 17
    8bbc:	78 16       	cp	r7, r24
    8bbe:	29 f6       	brne	.-118    	; 0x8b4a <SaveTotalizerCurrentToLast+0x44>
				  GetTotalizerData(TMONEY,TOTALIZER_NOW,FIPAddr,iGrade,strValue);
				  SetTotalizerData(TMONEY,TOTALIZER_LAST,FIPAddr,iGrade,strValue);
			  }
		  }
	 }
}
    8bc0:	2f 96       	adiw	r28, 0x0f	; 15
    8bc2:	0f b6       	in	r0, 0x3f	; 63
    8bc4:	f8 94       	cli
    8bc6:	de bf       	out	0x3e, r29	; 62
    8bc8:	0f be       	out	0x3f, r0	; 63
    8bca:	cd bf       	out	0x3d, r28	; 61
    8bcc:	cf 91       	pop	r28
    8bce:	df 91       	pop	r29
    8bd0:	1f 91       	pop	r17
    8bd2:	0f 91       	pop	r16
    8bd4:	ff 90       	pop	r15
    8bd6:	ef 90       	pop	r14
    8bd8:	df 90       	pop	r13
    8bda:	cf 90       	pop	r12
    8bdc:	bf 90       	pop	r11
    8bde:	af 90       	pop	r10
    8be0:	9f 90       	pop	r9
    8be2:	8f 90       	pop	r8
    8be4:	7f 90       	pop	r7
    8be6:	5f 90       	pop	r5
    8be8:	4f 90       	pop	r4
    8bea:	08 95       	ret

00008bec <ResetTotalizer>:


//-------------------Totalizer-----------------------------------------
//TAddr{TOTALIZER_LAST,TOTALIZER_NOW}
//TType:{TNONE,TVOLUME,TMONEY};
void ResetTotalizer(char TAddr){//Clear All TotalizerData;
    8bec:	af 92       	push	r10
    8bee:	bf 92       	push	r11
    8bf0:	cf 92       	push	r12
    8bf2:	df 92       	push	r13
    8bf4:	ef 92       	push	r14
    8bf6:	ff 92       	push	r15
    8bf8:	0f 93       	push	r16
    8bfa:	1f 93       	push	r17
    8bfc:	df 93       	push	r29
    8bfe:	cf 93       	push	r28
    8c00:	cd b7       	in	r28, 0x3d	; 61
    8c02:	de b7       	in	r29, 0x3e	; 62
    8c04:	29 97       	sbiw	r28, 0x09	; 9
    8c06:	0f b6       	in	r0, 0x3f	; 63
    8c08:	f8 94       	cli
    8c0a:	de bf       	out	0x3e, r29	; 62
    8c0c:	0f be       	out	0x3f, r0	; 63
    8c0e:	cd bf       	out	0x3d, r28	; 61
    8c10:	a8 2e       	mov	r10, r24
     char iPump,iGrade;
     char strValue[9];
	 char FIPAddr;
	 
	 sprintf_P(strValue,PSTR("00000000"));
    8c12:	00 d0       	rcall	.+0      	; 0x8c14 <ResetTotalizer+0x28>
    8c14:	00 d0       	rcall	.+0      	; 0x8c16 <ResetTotalizer+0x2a>
    8c16:	6e 01       	movw	r12, r28
    8c18:	08 94       	sec
    8c1a:	c1 1c       	adc	r12, r1
    8c1c:	d1 1c       	adc	r13, r1
    8c1e:	ed b7       	in	r30, 0x3d	; 61
    8c20:	fe b7       	in	r31, 0x3e	; 62
    8c22:	d2 82       	std	Z+2, r13	; 0x02
    8c24:	c1 82       	std	Z+1, r12	; 0x01
    8c26:	8b ee       	ldi	r24, 0xEB	; 235
    8c28:	95 e0       	ldi	r25, 0x05	; 5
    8c2a:	94 83       	std	Z+4, r25	; 0x04
    8c2c:	83 83       	std	Z+3, r24	; 0x03
    8c2e:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    8c32:	ee 24       	eor	r14, r14
    8c34:	e3 94       	inc	r14
    8c36:	0f 90       	pop	r0
    8c38:	0f 90       	pop	r0
    8c3a:	0f 90       	pop	r0
    8c3c:	0f 90       	pop	r0
	 for (iPump=1;iPump<=16;iPump++){//Pump
	      FIPAddr=GetFIPAddr(iPump);
    8c3e:	8e 2d       	mov	r24, r14
    8c40:	0e 94 39 1c 	call	0x3872	; 0x3872 <GetFIPAddr>
		  if (FIPAddr>0){
    8c44:	88 23       	and	r24, r24
    8c46:	a9 f0       	breq	.+42     	; 0x8c72 <ResetTotalizer+0x86>
		      FIPAddr=FIPAddr-1;
    8c48:	b8 2e       	mov	r11, r24
    8c4a:	ba 94       	dec	r11
    8c4c:	ff 24       	eor	r15, r15
    8c4e:	f3 94       	inc	r15
			  for(iGrade=1;iGrade<=6;iGrade++){
				  SetTotalizerData(TVOLUME,TAddr,FIPAddr,iGrade,strValue);
    8c50:	80 e0       	ldi	r24, 0x00	; 0
    8c52:	6a 2d       	mov	r22, r10
    8c54:	4b 2d       	mov	r20, r11
    8c56:	2f 2d       	mov	r18, r15
    8c58:	86 01       	movw	r16, r12
    8c5a:	0e 94 c2 44 	call	0x8984	; 0x8984 <SetTotalizerData>
				  SetTotalizerData(TMONEY,TAddr,FIPAddr,iGrade,strValue);
    8c5e:	81 e0       	ldi	r24, 0x01	; 1
    8c60:	6a 2d       	mov	r22, r10
    8c62:	4b 2d       	mov	r20, r11
    8c64:	2f 2d       	mov	r18, r15
    8c66:	0e 94 c2 44 	call	0x8984	; 0x8984 <SetTotalizerData>
	 sprintf_P(strValue,PSTR("00000000"));
	 for (iPump=1;iPump<=16;iPump++){//Pump
	      FIPAddr=GetFIPAddr(iPump);
		  if (FIPAddr>0){
		      FIPAddr=FIPAddr-1;
			  for(iGrade=1;iGrade<=6;iGrade++){
    8c6a:	f3 94       	inc	r15
    8c6c:	f7 e0       	ldi	r31, 0x07	; 7
    8c6e:	ff 16       	cp	r15, r31
    8c70:	79 f7       	brne	.-34     	; 0x8c50 <ResetTotalizer+0x64>
     char iPump,iGrade;
     char strValue[9];
	 char FIPAddr;
	 
	 sprintf_P(strValue,PSTR("00000000"));
	 for (iPump=1;iPump<=16;iPump++){//Pump
    8c72:	e3 94       	inc	r14
    8c74:	81 e1       	ldi	r24, 0x11	; 17
    8c76:	e8 16       	cp	r14, r24
    8c78:	11 f7       	brne	.-60     	; 0x8c3e <ResetTotalizer+0x52>
				  SetTotalizerData(TVOLUME,TAddr,FIPAddr,iGrade,strValue);
				  SetTotalizerData(TMONEY,TAddr,FIPAddr,iGrade,strValue);
			  }
		  }
	 }
}
    8c7a:	29 96       	adiw	r28, 0x09	; 9
    8c7c:	0f b6       	in	r0, 0x3f	; 63
    8c7e:	f8 94       	cli
    8c80:	de bf       	out	0x3e, r29	; 62
    8c82:	0f be       	out	0x3f, r0	; 63
    8c84:	cd bf       	out	0x3d, r28	; 61
    8c86:	cf 91       	pop	r28
    8c88:	df 91       	pop	r29
    8c8a:	1f 91       	pop	r17
    8c8c:	0f 91       	pop	r16
    8c8e:	ff 90       	pop	r15
    8c90:	ef 90       	pop	r14
    8c92:	df 90       	pop	r13
    8c94:	cf 90       	pop	r12
    8c96:	bf 90       	pop	r11
    8c98:	af 90       	pop	r10
    8c9a:	08 95       	ret

00008c9c <procMessage21>:
     eeprom_read_block((void*)&Dest,(const void*)&strCompare, Length);
     //if 
     eeprom_write_block((const void*)&Src,(void*)&Dest, Length);
}

char procMessage21(){
    8c9c:	af 92       	push	r10
    8c9e:	bf 92       	push	r11
    8ca0:	cf 92       	push	r12
    8ca2:	df 92       	push	r13
    8ca4:	ef 92       	push	r14
    8ca6:	ff 92       	push	r15
    8ca8:	0f 93       	push	r16
    8caa:	1f 93       	push	r17
    8cac:	df 93       	push	r29
    8cae:	cf 93       	push	r28
    8cb0:	cd b7       	in	r28, 0x3d	; 61
    8cb2:	de b7       	in	r29, 0x3e	; 62
    8cb4:	2b 97       	sbiw	r28, 0x0b	; 11
    8cb6:	0f b6       	in	r0, 0x3f	; 63
    8cb8:	f8 94       	cli
    8cba:	de bf       	out	0x3e, r29	; 62
    8cbc:	0f be       	out	0x3f, r0	; 63
    8cbe:	cd bf       	out	0x3d, r28	; 61
    8cc0:	09 e0       	ldi	r16, 0x09	; 9
    8cc2:	11 e0       	ldi	r17, 0x01	; 1
    8cc4:	3a e1       	ldi	r19, 0x1A	; 26
    8cc6:	e3 2e       	mov	r14, r19
    8cc8:	3b e0       	ldi	r19, 0x0B	; 11
    8cca:	f3 2e       	mov	r15, r19
    8ccc:	6e 01       	movw	r12, r28
    8cce:	08 94       	sec
    8cd0:	c1 1c       	adc	r12, r1
    8cd2:	d1 1c       	adc	r13, r1
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8cd4:	2b e0       	ldi	r18, 0x0B	; 11
    8cd6:	a2 2e       	mov	r10, r18
    8cd8:	b1 2c       	mov	r11, r1
    8cda:	ac 0e       	add	r10, r28
    8cdc:	bd 1e       	adc	r11, r29
     eeprom_read_block((void*)&Dest,(const void*)&strCompare, Length);
     //if 
     eeprom_write_block((const void*)&Src,(void*)&Dest, Length);
}

char procMessage21(){
    8cde:	f6 01       	movw	r30, r12
    8ce0:	d7 01       	movw	r26, r14
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    8ce2:	8d 91       	ld	r24, X+
    8ce4:	81 93       	st	Z+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    8ce6:	ea 15       	cp	r30, r10
    8ce8:	fb 05       	cpc	r31, r11
    8cea:	d9 f7       	brne	.-10     	; 0x8ce2 <procMessage21+0x46>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    8cec:	1b 86       	std	Y+11, r1	; 0x0b
    8cee:	c8 01       	movw	r24, r16
    8cf0:	b6 01       	movw	r22, r12
    8cf2:	4b e0       	ldi	r20, 0x0B	; 11
    8cf4:	50 e0       	ldi	r21, 0x00	; 0
    8cf6:	2b ef       	ldi	r18, 0xFB	; 251
    8cf8:	32 e1       	ldi	r19, 0x12	; 18
    8cfa:	0e 94 3b b4 	call	0x16876	; 0x16876 <__eewr_block>
    8cfe:	05 5f       	subi	r16, 0xF5	; 245
    8d00:	1f 4f       	sbci	r17, 0xFF	; 255
    8d02:	8a e0       	ldi	r24, 0x0A	; 10
    8d04:	90 e0       	ldi	r25, 0x00	; 0
    8d06:	e8 0e       	add	r14, r24
    8d08:	f9 1e       	adc	r15, r25
}

char procMessage21(){
     char i,Result,strBankName[11];
	 Result=0;
	 for(i=0;i<4;i++){
    8d0a:	91 e0       	ldi	r25, 0x01	; 1
    8d0c:	05 33       	cpi	r16, 0x35	; 53
    8d0e:	19 07       	cpc	r17, r25
    8d10:	31 f7       	brne	.-52     	; 0x8cde <procMessage21+0x42>
         StrPosCopy(rcv_trans,strBankName,(37+(i*10)),10);
		 //Result=((Result<<1)|SaveToEEPROM(strBankName,DefBankName[i],11)); 
		 eeprom_write_block((const void*)&strBankName, (void*)&DefBankName[i], 11);
	 }
	 return Result;
}
    8d12:	80 e0       	ldi	r24, 0x00	; 0
    8d14:	2b 96       	adiw	r28, 0x0b	; 11
    8d16:	0f b6       	in	r0, 0x3f	; 63
    8d18:	f8 94       	cli
    8d1a:	de bf       	out	0x3e, r29	; 62
    8d1c:	0f be       	out	0x3f, r0	; 63
    8d1e:	cd bf       	out	0x3d, r28	; 61
    8d20:	cf 91       	pop	r28
    8d22:	df 91       	pop	r29
    8d24:	1f 91       	pop	r17
    8d26:	0f 91       	pop	r16
    8d28:	ff 90       	pop	r15
    8d2a:	ef 90       	pop	r14
    8d2c:	df 90       	pop	r13
    8d2e:	cf 90       	pop	r12
    8d30:	bf 90       	pop	r11
    8d32:	af 90       	pop	r10
    8d34:	08 95       	ret

00008d36 <SaveToEEPROM>:
       StrPosCopy(rcv_trans,strFreeMessageLine3,79,20);
       StrPosCopy(rcv_trans,strFreeMessageLine4,99,20);
	 return Result;
}

char SaveToEEPROM(char *Src,char *Dest,unsigned int Length){
    8d36:	ef 92       	push	r14
    8d38:	ff 92       	push	r15
    8d3a:	0f 93       	push	r16
    8d3c:	1f 93       	push	r17
    8d3e:	df 93       	push	r29
    8d40:	cf 93       	push	r28
    8d42:	cd b7       	in	r28, 0x3d	; 61
    8d44:	de b7       	in	r29, 0x3e	; 62
    8d46:	ac 97       	sbiw	r28, 0x2c	; 44
    8d48:	0f b6       	in	r0, 0x3f	; 63
    8d4a:	f8 94       	cli
    8d4c:	de bf       	out	0x3e, r29	; 62
    8d4e:	0f be       	out	0x3f, r0	; 63
    8d50:	cd bf       	out	0x3d, r28	; 61
    8d52:	9a a7       	std	Y+42, r25	; 0x2a
    8d54:	89 a7       	std	Y+41, r24	; 0x29
    8d56:	7c a7       	std	Y+44, r23	; 0x2c
    8d58:	6b a7       	std	Y+43, r22	; 0x2b
    8d5a:	7a 01       	movw	r14, r20
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    8d5c:	8e 01       	movw	r16, r28
    8d5e:	05 5d       	subi	r16, 0xD5	; 213
    8d60:	1f 4f       	sbci	r17, 0xFF	; 255
    8d62:	c8 01       	movw	r24, r16
    8d64:	be 01       	movw	r22, r28
    8d66:	6f 5f       	subi	r22, 0xFF	; 255
    8d68:	7f 4f       	sbci	r23, 0xFF	; 255
    8d6a:	23 ef       	ldi	r18, 0xF3	; 243
    8d6c:	32 e1       	ldi	r19, 0x12	; 18
    8d6e:	0e 94 1f b4 	call	0x1683e	; 0x1683e <__eerd_block>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    8d72:	c8 01       	movw	r24, r16
    8d74:	be 01       	movw	r22, r28
    8d76:	67 5d       	subi	r22, 0xD7	; 215
    8d78:	7f 4f       	sbci	r23, 0xFF	; 255
    8d7a:	a7 01       	movw	r20, r14
    8d7c:	2b ef       	ldi	r18, 0xFB	; 251
    8d7e:	32 e1       	ldi	r19, 0x12	; 18
    8d80:	0e 94 3b b4 	call	0x16876	; 0x16876 <__eewr_block>
     char strCompare[40];
	 //Read Previous Data
     eeprom_read_block((void*)&Dest,(const void*)&strCompare, Length);
     //if 
     eeprom_write_block((const void*)&Src,(void*)&Dest, Length);
}
    8d84:	ac 96       	adiw	r28, 0x2c	; 44
    8d86:	0f b6       	in	r0, 0x3f	; 63
    8d88:	f8 94       	cli
    8d8a:	de bf       	out	0x3e, r29	; 62
    8d8c:	0f be       	out	0x3f, r0	; 63
    8d8e:	cd bf       	out	0x3d, r28	; 61
    8d90:	cf 91       	pop	r28
    8d92:	df 91       	pop	r29
    8d94:	1f 91       	pop	r17
    8d96:	0f 91       	pop	r16
    8d98:	ff 90       	pop	r15
    8d9a:	ef 90       	pop	r14
    8d9c:	08 95       	ret

00008d9e <_menu_pumpprodinput>:
//**********************************************************************
// subrutin merubah produk
// parameter di simpan di __pump_prod
//**********************************************************************

void _menu_pumpprodinput(unsigned char __select){
    8d9e:	8f 92       	push	r8
    8da0:	9f 92       	push	r9
    8da2:	af 92       	push	r10
    8da4:	bf 92       	push	r11
    8da6:	cf 92       	push	r12
    8da8:	df 92       	push	r13
    8daa:	ef 92       	push	r14
    8dac:	ff 92       	push	r15
    8dae:	0f 93       	push	r16
    8db0:	1f 93       	push	r17
    8db2:	df 93       	push	r29
    8db4:	cf 93       	push	r28
    8db6:	cd b7       	in	r28, 0x3d	; 61
    8db8:	de b7       	in	r29, 0x3e	; 62
    8dba:	a7 97       	sbiw	r28, 0x27	; 39
    8dbc:	0f b6       	in	r0, 0x3f	; 63
    8dbe:	f8 94       	cli
    8dc0:	de bf       	out	0x3e, r29	; 62
    8dc2:	0f be       	out	0x3f, r0	; 63
    8dc4:	cd bf       	out	0x3d, r28	; 61
    8dc6:	b8 2e       	mov	r11, r24
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    8dc8:	8e 01       	movw	r16, r28
    8dca:	04 5f       	subi	r16, 0xF4	; 244
    8dcc:	1f 4f       	sbci	r17, 0xFF	; 255
    8dce:	c8 01       	movw	r24, r16
    8dd0:	65 e4       	ldi	r22, 0x45	; 69
    8dd2:	70 e0       	ldi	r23, 0x00	; 0
    8dd4:	48 e0       	ldi	r20, 0x08	; 8
    8dd6:	50 e0       	ldi	r21, 0x00	; 0
    8dd8:	23 ef       	ldi	r18, 0xF3	; 243
    8dda:	32 e1       	ldi	r19, 0x12	; 18
    8ddc:	0e 94 1f b4 	call	0x1683e	; 0x1683e <__eerd_block>
	char 			__pump_prod[6],__pump_id[8];
	unsigned char	__i, __x, __y, __key, __num, __buff[5];
	char lcdteks[20];

	eeprom_read_block((void*) &__pump_id, (const void*) &DefPumpMap, 8);
	eeprom_read_block((void*) &__pump_prod, (const void*) &DefNozzleMap[__select], 6);
    8de0:	86 e0       	ldi	r24, 0x06	; 6
    8de2:	b8 9e       	mul	r11, r24
    8de4:	40 01       	movw	r8, r0
    8de6:	11 24       	eor	r1, r1
    8de8:	85 e5       	ldi	r24, 0x55	; 85
    8dea:	90 e0       	ldi	r25, 0x00	; 0
    8dec:	88 0e       	add	r8, r24
    8dee:	99 1e       	adc	r9, r25
    8df0:	e6 e0       	ldi	r30, 0x06	; 6
    8df2:	ce 2e       	mov	r12, r30
    8df4:	d1 2c       	mov	r13, r1
    8df6:	cc 0e       	add	r12, r28
    8df8:	dd 1e       	adc	r13, r29
    8dfa:	c6 01       	movw	r24, r12
    8dfc:	b4 01       	movw	r22, r8
    8dfe:	46 e0       	ldi	r20, 0x06	; 6
    8e00:	50 e0       	ldi	r21, 0x00	; 0
    8e02:	23 ef       	ldi	r18, 0xF3	; 243
    8e04:	32 e1       	ldi	r19, 0x12	; 18
    8e06:	0e 94 1f b4 	call	0x1683e	; 0x1683e <__eerd_block>

	lcd_clear();_delay_ms(10);
    8e0a:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
    8e0e:	84 ec       	ldi	r24, 0xC4	; 196
    8e10:	99 e0       	ldi	r25, 0x09	; 9
    8e12:	01 97       	sbiw	r24, 0x01	; 1
    8e14:	f1 f7       	brne	.-4      	; 0x8e12 <_menu_pumpprodinput+0x74>
    sprintf_P(lcdteks, PSTR("Product FIP%.2d"),__pump_id[__select]);
    8e16:	00 d0       	rcall	.+0      	; 0x8e18 <_menu_pumpprodinput+0x7a>
    8e18:	00 d0       	rcall	.+0      	; 0x8e1a <_menu_pumpprodinput+0x7c>
    8e1a:	00 d0       	rcall	.+0      	; 0x8e1c <_menu_pumpprodinput+0x7e>
    8e1c:	ed b7       	in	r30, 0x3d	; 61
    8e1e:	fe b7       	in	r31, 0x3e	; 62
    8e20:	31 96       	adiw	r30, 0x01	; 1
    8e22:	74 e1       	ldi	r23, 0x14	; 20
    8e24:	e7 2e       	mov	r14, r23
    8e26:	f1 2c       	mov	r15, r1
    8e28:	ec 0e       	add	r14, r28
    8e2a:	fd 1e       	adc	r15, r29
    8e2c:	ad b7       	in	r26, 0x3d	; 61
    8e2e:	be b7       	in	r27, 0x3e	; 62
    8e30:	12 96       	adiw	r26, 0x02	; 2
    8e32:	fc 92       	st	X, r15
    8e34:	ee 92       	st	-X, r14
    8e36:	11 97       	sbiw	r26, 0x01	; 1
    8e38:	81 ef       	ldi	r24, 0xF1	; 241
    8e3a:	9b e0       	ldi	r25, 0x0B	; 11
    8e3c:	93 83       	std	Z+3, r25	; 0x03
    8e3e:	82 83       	std	Z+2, r24	; 0x02
    8e40:	0b 0d       	add	r16, r11
    8e42:	11 1d       	adc	r17, r1
    8e44:	d8 01       	movw	r26, r16
    8e46:	8c 91       	ld	r24, X
    8e48:	84 83       	std	Z+4, r24	; 0x04
    8e4a:	15 82       	std	Z+5, r1	; 0x05
    8e4c:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    lcd_print(1, 1,lcdteks);
    8e50:	ed b7       	in	r30, 0x3d	; 61
    8e52:	fe b7       	in	r31, 0x3e	; 62
    8e54:	36 96       	adiw	r30, 0x06	; 6
    8e56:	0f b6       	in	r0, 0x3f	; 63
    8e58:	f8 94       	cli
    8e5a:	fe bf       	out	0x3e, r31	; 62
    8e5c:	0f be       	out	0x3f, r0	; 63
    8e5e:	ed bf       	out	0x3d, r30	; 61
    8e60:	81 e0       	ldi	r24, 0x01	; 1
    8e62:	61 e0       	ldi	r22, 0x01	; 1
    8e64:	a7 01       	movw	r20, r14
    8e66:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>

	lcd_printf(2, 1, PSTR("1)N1:  3)N3:  5)N5:"));
    8e6a:	82 e0       	ldi	r24, 0x02	; 2
    8e6c:	61 e0       	ldi	r22, 0x01	; 1
    8e6e:	4d ed       	ldi	r20, 0xDD	; 221
    8e70:	5b e0       	ldi	r21, 0x0B	; 11
    8e72:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
	lcd_printf(3, 1, PSTR("2)N2:  4)N4:  6)N6:"));
    8e76:	83 e0       	ldi	r24, 0x03	; 3
    8e78:	61 e0       	ldi	r22, 0x01	; 1
    8e7a:	49 ec       	ldi	r20, 0xC9	; 201
    8e7c:	5b e0       	ldi	r21, 0x0B	; 11
    8e7e:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
	lcd_printf(4, 1, PSTR("*)Exit        #)Save"));
    8e82:	84 e0       	ldi	r24, 0x04	; 4
    8e84:	61 e0       	ldi	r22, 0x01	; 1
    8e86:	44 eb       	ldi	r20, 0xB4	; 180
    8e88:	5b e0       	ldi	r21, 0x0B	; 11
    8e8a:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
    8e8e:	64 ed       	ldi	r22, 0xD4	; 212
    8e90:	e6 2e       	mov	r14, r22
    8e92:	62 e0       	ldi	r22, 0x02	; 2
    8e94:	f6 2e       	mov	r15, r22

	for(__i = 0; __i < 6; __i++){
		__x = pgm_read_byte(&__prodloc[__i][0]);
		__y = pgm_read_byte(&__prodloc[__i][1]);
		_f_inttostr(__buff, __pump_prod[__i]);
    8e96:	5e 01       	movw	r10, r28
    8e98:	08 94       	sec
    8e9a:	a1 1c       	adc	r10, r1
    8e9c:	b1 1c       	adc	r11, r1
	lcd_printf(2, 1, PSTR("1)N1:  3)N3:  5)N5:"));
	lcd_printf(3, 1, PSTR("2)N2:  4)N4:  6)N6:"));
	lcd_printf(4, 1, PSTR("*)Exit        #)Save"));

	for(__i = 0; __i < 6; __i++){
		__x = pgm_read_byte(&__prodloc[__i][0]);
    8e9e:	f7 01       	movw	r30, r14
    8ea0:	04 91       	lpm	r16, Z+
		__y = pgm_read_byte(&__prodloc[__i][1]);
    8ea2:	08 94       	sec
    8ea4:	e1 1c       	adc	r14, r1
    8ea6:	f1 1c       	adc	r15, r1
    8ea8:	f7 01       	movw	r30, r14
    8eaa:	14 91       	lpm	r17, Z+
		_f_inttostr(__buff, __pump_prod[__i]);
    8eac:	d6 01       	movw	r26, r12
    8eae:	4d 91       	ld	r20, X+
    8eb0:	6d 01       	movw	r12, r26
    8eb2:	50 e0       	ldi	r21, 0x00	; 0
    8eb4:	60 e0       	ldi	r22, 0x00	; 0
    8eb6:	70 e0       	ldi	r23, 0x00	; 0
    8eb8:	c5 01       	movw	r24, r10
    8eba:	0e 94 62 19 	call	0x32c4	; 0x32c4 <_f_inttostr>
		lcd_print(__x+1, __y, __buff);
    8ebe:	80 2f       	mov	r24, r16
    8ec0:	8f 5f       	subi	r24, 0xFF	; 255
    8ec2:	61 2f       	mov	r22, r17
    8ec4:	a5 01       	movw	r20, r10
    8ec6:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
    8eca:	08 94       	sec
    8ecc:	e1 1c       	adc	r14, r1
    8ece:	f1 1c       	adc	r15, r1

	lcd_printf(2, 1, PSTR("1)N1:  3)N3:  5)N5:"));
	lcd_printf(3, 1, PSTR("2)N2:  4)N4:  6)N6:"));
	lcd_printf(4, 1, PSTR("*)Exit        #)Save"));

	for(__i = 0; __i < 6; __i++){
    8ed0:	b0 ee       	ldi	r27, 0xE0	; 224
    8ed2:	eb 16       	cp	r14, r27
    8ed4:	b2 e0       	ldi	r27, 0x02	; 2
    8ed6:	fb 06       	cpc	r15, r27
    8ed8:	11 f7       	brne	.-60     	; 0x8e9e <_menu_pumpprodinput+0x100>
		if(__key == _KEY_ENTER){
			eeprom_write_block((const void*) &__pump_prod, (void*) &DefNozzleMap[__select], 6);
			return;
		}
		if(__num >= '1' && __num <= '6'){
			if(__pump_prod[__num - '1'] == 6)
    8eda:	56 e0       	ldi	r21, 0x06	; 6
    8edc:	c5 2e       	mov	r12, r21
    8ede:	d1 2c       	mov	r13, r1
    8ee0:	cc 0e       	add	r12, r28
    8ee2:	dd 1e       	adc	r13, r29
			else
				__pump_prod[__num - '1']++;

			__x = pgm_read_byte(&__prodloc[__num - 0x31][0]);
			__y = pgm_read_byte(&__prodloc[__num - 0x31][1]);
			_f_inttostr(__buff, __pump_prod[__num - 0x31]);
    8ee4:	7e 01       	movw	r14, r28
    8ee6:	08 94       	sec
    8ee8:	e1 1c       	adc	r14, r1
    8eea:	f1 1c       	adc	r15, r1
		lcd_print(__x+1, __y, __buff);
	}

	while(1){
		
		__key = _key_scan(1);
    8eec:	81 e0       	ldi	r24, 0x01	; 1
    8eee:	0e 94 ab ae 	call	0x15d56	; 0x15d56 <_key_scan>
    8ef2:	18 2f       	mov	r17, r24
		__num = _key_btn(__key);
    8ef4:	0e 94 0c ae 	call	0x15c18	; 0x15c18 <_key_btn>
    8ef8:	98 2f       	mov	r25, r24
		if(__key == _KEY_CANCEL)
    8efa:	17 3e       	cpi	r17, 0xE7	; 231
    8efc:	09 f4       	brne	.+2      	; 0x8f00 <_menu_pumpprodinput+0x162>
    8efe:	3c c0       	rjmp	.+120    	; 0x8f78 <_menu_pumpprodinput+0x1da>
			return;
		if(__key == _KEY_ENTER){
    8f00:	17 3b       	cpi	r17, 0xB7	; 183
    8f02:	59 f4       	brne	.+22     	; 0x8f1a <_menu_pumpprodinput+0x17c>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    8f04:	c4 01       	movw	r24, r8
    8f06:	be 01       	movw	r22, r28
    8f08:	6a 5f       	subi	r22, 0xFA	; 250
    8f0a:	7f 4f       	sbci	r23, 0xFF	; 255
    8f0c:	46 e0       	ldi	r20, 0x06	; 6
    8f0e:	50 e0       	ldi	r21, 0x00	; 0
    8f10:	2b ef       	ldi	r18, 0xFB	; 251
    8f12:	32 e1       	ldi	r19, 0x12	; 18
    8f14:	0e 94 3b b4 	call	0x16876	; 0x16876 <__eewr_block>
    8f18:	2f c0       	rjmp	.+94     	; 0x8f78 <_menu_pumpprodinput+0x1da>
			eeprom_write_block((const void*) &__pump_prod, (void*) &DefNozzleMap[__select], 6);
			return;
		}
		if(__num >= '1' && __num <= '6'){
    8f1a:	81 53       	subi	r24, 0x31	; 49
    8f1c:	86 30       	cpi	r24, 0x06	; 6
    8f1e:	30 f7       	brcc	.-52     	; 0x8eec <_menu_pumpprodinput+0x14e>
			if(__pump_prod[__num - '1'] == 6)
    8f20:	a9 2f       	mov	r26, r25
    8f22:	b0 e0       	ldi	r27, 0x00	; 0
    8f24:	d1 97       	sbiw	r26, 0x31	; 49
    8f26:	f6 01       	movw	r30, r12
    8f28:	ea 0f       	add	r30, r26
    8f2a:	fb 1f       	adc	r31, r27
    8f2c:	80 81       	ld	r24, Z
    8f2e:	86 30       	cpi	r24, 0x06	; 6
    8f30:	11 f4       	brne	.+4      	; 0x8f36 <_menu_pumpprodinput+0x198>
				__pump_prod[__num - '1'] = 0;
    8f32:	10 82       	st	Z, r1
    8f34:	02 c0       	rjmp	.+4      	; 0x8f3a <_menu_pumpprodinput+0x19c>
			else
				__pump_prod[__num - '1']++;
    8f36:	8f 5f       	subi	r24, 0xFF	; 255
    8f38:	80 83       	st	Z, r24

			__x = pgm_read_byte(&__prodloc[__num - 0x31][0]);
    8f3a:	29 2f       	mov	r18, r25
    8f3c:	30 e0       	ldi	r19, 0x00	; 0
    8f3e:	21 53       	subi	r18, 0x31	; 49
    8f40:	30 40       	sbci	r19, 0x00	; 0
    8f42:	22 0f       	add	r18, r18
    8f44:	33 1f       	adc	r19, r19
    8f46:	c9 01       	movw	r24, r18
    8f48:	8c 52       	subi	r24, 0x2C	; 44
    8f4a:	9d 4f       	sbci	r25, 0xFD	; 253
    8f4c:	fc 01       	movw	r30, r24
    8f4e:	04 91       	lpm	r16, Z+
			__y = pgm_read_byte(&__prodloc[__num - 0x31][1]);
    8f50:	2b 52       	subi	r18, 0x2B	; 43
    8f52:	3d 4f       	sbci	r19, 0xFD	; 253
    8f54:	f9 01       	movw	r30, r18
    8f56:	14 91       	lpm	r17, Z+
			_f_inttostr(__buff, __pump_prod[__num - 0x31]);
    8f58:	ac 0d       	add	r26, r12
    8f5a:	bd 1d       	adc	r27, r13
    8f5c:	4c 91       	ld	r20, X
    8f5e:	50 e0       	ldi	r21, 0x00	; 0
    8f60:	60 e0       	ldi	r22, 0x00	; 0
    8f62:	70 e0       	ldi	r23, 0x00	; 0
    8f64:	c7 01       	movw	r24, r14
    8f66:	0e 94 62 19 	call	0x32c4	; 0x32c4 <_f_inttostr>
			lcd_print(__x+1, __y, __buff);
    8f6a:	80 2f       	mov	r24, r16
    8f6c:	8f 5f       	subi	r24, 0xFF	; 255
    8f6e:	61 2f       	mov	r22, r17
    8f70:	a7 01       	movw	r20, r14
    8f72:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
    8f76:	ba cf       	rjmp	.-140    	; 0x8eec <_menu_pumpprodinput+0x14e>
		}
	}
}
    8f78:	a7 96       	adiw	r28, 0x27	; 39
    8f7a:	0f b6       	in	r0, 0x3f	; 63
    8f7c:	f8 94       	cli
    8f7e:	de bf       	out	0x3e, r29	; 62
    8f80:	0f be       	out	0x3f, r0	; 63
    8f82:	cd bf       	out	0x3d, r28	; 61
    8f84:	cf 91       	pop	r28
    8f86:	df 91       	pop	r29
    8f88:	1f 91       	pop	r17
    8f8a:	0f 91       	pop	r16
    8f8c:	ff 90       	pop	r15
    8f8e:	ef 90       	pop	r14
    8f90:	df 90       	pop	r13
    8f92:	cf 90       	pop	r12
    8f94:	bf 90       	pop	r11
    8f96:	af 90       	pop	r10
    8f98:	9f 90       	pop	r9
    8f9a:	8f 90       	pop	r8
    8f9c:	08 95       	ret

00008f9e <_menu_pumpprod>:
	       break;
	   }	   
	}
}

void _menu_pumpprod(void){
    8f9e:	cf 93       	push	r28
    8fa0:	df 93       	push	r29
    8fa2:	c4 ec       	ldi	r28, 0xC4	; 196
    8fa4:	d9 e0       	ldi	r29, 0x09	; 9
	char __key;
	//char __pump_id[8];
	while(1){
		lcd_clear();_delay_ms(10);
    8fa6:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
    8faa:	ce 01       	movw	r24, r28
    8fac:	01 97       	sbiw	r24, 0x01	; 1
    8fae:	f1 f7       	brne	.-4      	; 0x8fac <_menu_pumpprod+0xe>
		_scr_pump();
    8fb0:	0e 94 77 42 	call	0x84ee	; 0x84ee <_scr_pump>
		while(1){
			__key = _key_scan(1);
    8fb4:	81 e0       	ldi	r24, 0x01	; 1
    8fb6:	0e 94 ab ae 	call	0x15d56	; 0x15d56 <_key_scan>
			if( __key == _KEY_1 || __key == _KEY_2 || __key == _KEY_3 ||
    8fba:	8e 3e       	cpi	r24, 0xEE	; 238
    8fbc:	71 f0       	breq	.+28     	; 0x8fda <_menu_pumpprod+0x3c>
    8fbe:	8e 3d       	cpi	r24, 0xDE	; 222
    8fc0:	61 f0       	breq	.+24     	; 0x8fda <_menu_pumpprod+0x3c>
    8fc2:	8e 3b       	cpi	r24, 0xBE	; 190
    8fc4:	51 f0       	breq	.+20     	; 0x8fda <_menu_pumpprod+0x3c>
    8fc6:	8d 3e       	cpi	r24, 0xED	; 237
    8fc8:	41 f0       	breq	.+16     	; 0x8fda <_menu_pumpprod+0x3c>
    8fca:	8d 3d       	cpi	r24, 0xDD	; 221
    8fcc:	31 f0       	breq	.+12     	; 0x8fda <_menu_pumpprod+0x3c>
    8fce:	8d 3b       	cpi	r24, 0xBD	; 189
    8fd0:	21 f0       	breq	.+8      	; 0x8fda <_menu_pumpprod+0x3c>
    8fd2:	8b 3e       	cpi	r24, 0xEB	; 235
    8fd4:	11 f0       	breq	.+4      	; 0x8fda <_menu_pumpprod+0x3c>
    8fd6:	8b 3d       	cpi	r24, 0xDB	; 219
    8fd8:	31 f4       	brne	.+12     	; 0x8fe6 <_menu_pumpprod+0x48>
				__key == _KEY_4 || __key == _KEY_5 || __key == _KEY_6 ||
				__key == _KEY_7 || __key == _KEY_8){
				_menu_pumpprodinput(_key_btn(__key) - 0x31);
    8fda:	0e 94 0c ae 	call	0x15c18	; 0x15c18 <_key_btn>
    8fde:	81 53       	subi	r24, 0x31	; 49
    8fe0:	0e 94 cf 46 	call	0x8d9e	; 0x8d9e <_menu_pumpprodinput>
    8fe4:	e0 cf       	rjmp	.-64     	; 0x8fa6 <_menu_pumpprod+0x8>
				break;
			}
			if(__key == _KEY_CANCEL)
    8fe6:	87 3e       	cpi	r24, 0xE7	; 231
    8fe8:	29 f7       	brne	.-54     	; 0x8fb4 <_menu_pumpprod+0x16>
				return;
		}
	}
}
    8fea:	df 91       	pop	r29
    8fec:	cf 91       	pop	r28
    8fee:	08 95       	ret

00008ff0 <FMenuPumpLabel>:
		       break;		         
	      }
	 }     
}

void FMenuPumpLabel(){
    8ff0:	6f 92       	push	r6
    8ff2:	7f 92       	push	r7
    8ff4:	8f 92       	push	r8
    8ff6:	9f 92       	push	r9
    8ff8:	af 92       	push	r10
    8ffa:	bf 92       	push	r11
    8ffc:	cf 92       	push	r12
    8ffe:	df 92       	push	r13
    9000:	ef 92       	push	r14
    9002:	ff 92       	push	r15
    9004:	1f 93       	push	r17
    9006:	df 93       	push	r29
    9008:	cf 93       	push	r28
    900a:	cd b7       	in	r28, 0x3d	; 61
    900c:	de b7       	in	r29, 0x3e	; 62
    900e:	2d 97       	sbiw	r28, 0x0d	; 13
    9010:	0f b6       	in	r0, 0x3f	; 63
    9012:	f8 94       	cli
    9014:	de bf       	out	0x3e, r29	; 62
    9016:	0f be       	out	0x3f, r0	; 63
    9018:	cd bf       	out	0x3d, r28	; 61
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    901a:	86 e0       	ldi	r24, 0x06	; 6
    901c:	c8 2e       	mov	r12, r24
    901e:	d1 2c       	mov	r13, r1
    9020:	cc 0e       	add	r12, r28
    9022:	dd 1e       	adc	r13, r29
    9024:	c6 01       	movw	r24, r12
    9026:	6d e4       	ldi	r22, 0x4D	; 77
    9028:	70 e0       	ldi	r23, 0x00	; 0
    902a:	48 e0       	ldi	r20, 0x08	; 8
    902c:	50 e0       	ldi	r21, 0x00	; 0
    902e:	23 ef       	ldi	r18, 0xF3	; 243
    9030:	32 e1       	ldi	r19, 0x12	; 18
    9032:	0e 94 1f b4 	call	0x1683e	; 0x1683e <__eerd_block>
	char PPumpLabel[8];
	unsigned char i, xPos,yPos,KeyPressed,KeyChar,strLabel[5];
	static char MaxCountId=16;

	eeprom_read_block((void*) &PPumpLabel, (const void*) &DefPumpLabel, 8);
	MaxCountId=99;
    9036:	83 e6       	ldi	r24, 0x63	; 99
    9038:	80 93 56 01 	sts	0x0156, r24
	lcd_clear();_delay_ms(10);
    903c:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
    9040:	84 ec       	ldi	r24, 0xC4	; 196
    9042:	99 e0       	ldi	r25, 0x09	; 9
    9044:	01 97       	sbiw	r24, 0x01	; 1
    9046:	f1 f7       	brne	.-4      	; 0x9044 <FMenuPumpLabel+0x54>
	lcd_printf(1, 1, PSTR("1)1:   5)5:"));
    9048:	81 e0       	ldi	r24, 0x01	; 1
    904a:	61 e0       	ldi	r22, 0x01	; 1
    904c:	4c ee       	ldi	r20, 0xEC	; 236
    904e:	5c e0       	ldi	r21, 0x0C	; 12
    9050:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
	lcd_printf(2, 1, PSTR("2)2:   6)6:"));
    9054:	82 e0       	ldi	r24, 0x02	; 2
    9056:	61 e0       	ldi	r22, 0x01	; 1
    9058:	40 ee       	ldi	r20, 0xE0	; 224
    905a:	5c e0       	ldi	r21, 0x0C	; 12
    905c:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
	lcd_printf(3, 1, PSTR("3)3:   7)7:   #)Save"));
    9060:	83 e0       	ldi	r24, 0x03	; 3
    9062:	61 e0       	ldi	r22, 0x01	; 1
    9064:	4b ec       	ldi	r20, 0xCB	; 203
    9066:	5c e0       	ldi	r21, 0x0C	; 12
    9068:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
	lcd_printf(4, 1, PSTR("4)4:   8)8:   *)Exit"));
    906c:	84 e0       	ldi	r24, 0x04	; 4
    906e:	61 e0       	ldi	r22, 0x01	; 1
    9070:	46 eb       	ldi	r20, 0xB6	; 182
    9072:	5c e0       	ldi	r21, 0x0C	; 12
    9074:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
    9078:	76 01       	movw	r14, r12

	for(i=0;i< 8;i++){
	    sprintf_P(strLabel,PSTR("%.2d"),PPumpLabel[i]);
    907a:	5e 01       	movw	r10, r28
    907c:	08 94       	sec
    907e:	a1 1c       	adc	r10, r1
    9080:	b1 1c       	adc	r11, r1
    9082:	11 eb       	ldi	r17, 0xB1	; 177
    9084:	61 2e       	mov	r6, r17
    9086:	1c e0       	ldi	r17, 0x0C	; 12
    9088:	71 2e       	mov	r7, r17
	lcd_printf(1, 1, PSTR("1)1:   5)5:"));
	lcd_printf(2, 1, PSTR("2)2:   6)6:"));
	lcd_printf(3, 1, PSTR("3)3:   7)7:   #)Save"));
	lcd_printf(4, 1, PSTR("4)4:   8)8:   *)Exit"));

	for(i=0;i< 8;i++){
    908a:	be e0       	ldi	r27, 0x0E	; 14
    908c:	8b 2e       	mov	r8, r27
    908e:	91 2c       	mov	r9, r1
    9090:	8c 0e       	add	r8, r28
    9092:	9d 1e       	adc	r9, r29
	MaxCountId=99;
	lcd_clear();_delay_ms(10);
	lcd_printf(1, 1, PSTR("1)1:   5)5:"));
	lcd_printf(2, 1, PSTR("2)2:   6)6:"));
	lcd_printf(3, 1, PSTR("3)3:   7)7:   #)Save"));
	lcd_printf(4, 1, PSTR("4)4:   8)8:   *)Exit"));
    9094:	1e 2d       	mov	r17, r14
    9096:	1c 19       	sub	r17, r12

	for(i=0;i< 8;i++){
	    sprintf_P(strLabel,PSTR("%.2d"),PPumpLabel[i]);
    9098:	00 d0       	rcall	.+0      	; 0x909a <FMenuPumpLabel+0xaa>
    909a:	00 d0       	rcall	.+0      	; 0x909c <FMenuPumpLabel+0xac>
    909c:	00 d0       	rcall	.+0      	; 0x909e <FMenuPumpLabel+0xae>
    909e:	ed b7       	in	r30, 0x3d	; 61
    90a0:	fe b7       	in	r31, 0x3e	; 62
    90a2:	31 96       	adiw	r30, 0x01	; 1
    90a4:	ad b7       	in	r26, 0x3d	; 61
    90a6:	be b7       	in	r27, 0x3e	; 62
    90a8:	12 96       	adiw	r26, 0x02	; 2
    90aa:	bc 92       	st	X, r11
    90ac:	ae 92       	st	-X, r10
    90ae:	11 97       	sbiw	r26, 0x01	; 1
    90b0:	73 82       	std	Z+3, r7	; 0x03
    90b2:	62 82       	std	Z+2, r6	; 0x02
    90b4:	d7 01       	movw	r26, r14
    90b6:	8d 91       	ld	r24, X+
    90b8:	7d 01       	movw	r14, r26
    90ba:	84 83       	std	Z+4, r24	; 0x04
    90bc:	15 82       	std	Z+5, r1	; 0x05
    90be:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
		xPos=1+(i%4);
		yPos=5+(i/4)*8;
        lcd_print(xPos,yPos,strLabel);
    90c2:	ed b7       	in	r30, 0x3d	; 61
    90c4:	fe b7       	in	r31, 0x3e	; 62
    90c6:	36 96       	adiw	r30, 0x06	; 6
    90c8:	0f b6       	in	r0, 0x3f	; 63
    90ca:	f8 94       	cli
    90cc:	fe bf       	out	0x3e, r31	; 62
    90ce:	0f be       	out	0x3f, r0	; 63
    90d0:	ed bf       	out	0x3d, r30	; 61
    90d2:	61 2f       	mov	r22, r17
    90d4:	66 95       	lsr	r22
    90d6:	66 95       	lsr	r22
    90d8:	66 0f       	add	r22, r22
    90da:	66 0f       	add	r22, r22
    90dc:	66 0f       	add	r22, r22
    90de:	6b 5f       	subi	r22, 0xFB	; 251
    90e0:	13 70       	andi	r17, 0x03	; 3
    90e2:	81 2f       	mov	r24, r17
    90e4:	8f 5f       	subi	r24, 0xFF	; 255
    90e6:	a5 01       	movw	r20, r10
    90e8:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
	lcd_printf(1, 1, PSTR("1)1:   5)5:"));
	lcd_printf(2, 1, PSTR("2)2:   6)6:"));
	lcd_printf(3, 1, PSTR("3)3:   7)7:   #)Save"));
	lcd_printf(4, 1, PSTR("4)4:   8)8:   *)Exit"));

	for(i=0;i< 8;i++){
    90ec:	e8 14       	cp	r14, r8
    90ee:	f9 04       	cpc	r15, r9
    90f0:	89 f6       	brne	.-94     	; 0x9094 <FMenuPumpLabel+0xa4>
			eeprom_write_block((const void*) &PPumpLabel, (void*) &DefPumpLabel, 8);
			break;
		}
		if ((KeyChar>='1') && (KeyChar<= '8')){
		     i=(KeyChar-'1');
			if(PPumpLabel[i] == MaxCountId)
    90f2:	a6 e0       	ldi	r26, 0x06	; 6
    90f4:	ca 2e       	mov	r12, r26
    90f6:	d1 2c       	mov	r13, r1
    90f8:	cc 0e       	add	r12, r28
    90fa:	dd 1e       	adc	r13, r29
			   PPumpLabel[i] = 0;
			else
			   PPumpLabel[i]++;
            xPos=1+(i%4);
		    yPos=5+(i/4)*8;
			sprintf_P(strLabel,PSTR("%.2d"),PPumpLabel[i]);
    90fc:	7e 01       	movw	r14, r28
    90fe:	08 94       	sec
    9100:	e1 1c       	adc	r14, r1
    9102:	f1 1c       	adc	r15, r1
    9104:	fc ea       	ldi	r31, 0xAC	; 172
    9106:	af 2e       	mov	r10, r31
    9108:	fc e0       	ldi	r31, 0x0C	; 12
    910a:	bf 2e       	mov	r11, r31
		yPos=5+(i/4)*8;
        lcd_print(xPos,yPos,strLabel);
	}

	while(1){
		KeyPressed = _key_scan(1);
    910c:	81 e0       	ldi	r24, 0x01	; 1
    910e:	0e 94 ab ae 	call	0x15d56	; 0x15d56 <_key_scan>
    9112:	18 2f       	mov	r17, r24
		KeyChar    = _key_btn(KeyPressed);
    9114:	0e 94 0c ae 	call	0x15c18	; 0x15c18 <_key_btn>
		if(KeyPressed == _KEY_CANCEL)break;
    9118:	17 3e       	cpi	r17, 0xE7	; 231
    911a:	09 f4       	brne	.+2      	; 0x911e <FMenuPumpLabel+0x12e>
    911c:	4b c0       	rjmp	.+150    	; 0x91b4 <FMenuPumpLabel+0x1c4>
		else
		if(KeyPressed == _KEY_ENTER){
    911e:	17 3b       	cpi	r17, 0xB7	; 183
    9120:	61 f4       	brne	.+24     	; 0x913a <FMenuPumpLabel+0x14a>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    9122:	8d e4       	ldi	r24, 0x4D	; 77
    9124:	90 e0       	ldi	r25, 0x00	; 0
    9126:	be 01       	movw	r22, r28
    9128:	6a 5f       	subi	r22, 0xFA	; 250
    912a:	7f 4f       	sbci	r23, 0xFF	; 255
    912c:	48 e0       	ldi	r20, 0x08	; 8
    912e:	50 e0       	ldi	r21, 0x00	; 0
    9130:	2b ef       	ldi	r18, 0xFB	; 251
    9132:	32 e1       	ldi	r19, 0x12	; 18
    9134:	0e 94 3b b4 	call	0x16876	; 0x16876 <__eewr_block>
    9138:	3d c0       	rjmp	.+122    	; 0x91b4 <FMenuPumpLabel+0x1c4>
			eeprom_write_block((const void*) &PPumpLabel, (void*) &DefPumpLabel, 8);
			break;
		}
		if ((KeyChar>='1') && (KeyChar<= '8')){
    913a:	18 2f       	mov	r17, r24
    913c:	11 53       	subi	r17, 0x31	; 49
    913e:	18 30       	cpi	r17, 0x08	; 8
    9140:	28 f7       	brcc	.-54     	; 0x910c <FMenuPumpLabel+0x11c>
		     i=(KeyChar-'1');
			if(PPumpLabel[i] == MaxCountId)
    9142:	a1 2f       	mov	r26, r17
    9144:	b0 e0       	ldi	r27, 0x00	; 0
    9146:	f6 01       	movw	r30, r12
    9148:	ea 0f       	add	r30, r26
    914a:	fb 1f       	adc	r31, r27
    914c:	90 81       	ld	r25, Z
    914e:	80 91 56 01 	lds	r24, 0x0156
    9152:	98 17       	cp	r25, r24
    9154:	11 f4       	brne	.+4      	; 0x915a <FMenuPumpLabel+0x16a>
			   PPumpLabel[i] = 0;
    9156:	10 82       	st	Z, r1
    9158:	02 c0       	rjmp	.+4      	; 0x915e <FMenuPumpLabel+0x16e>
			else
			   PPumpLabel[i]++;
    915a:	9f 5f       	subi	r25, 0xFF	; 255
    915c:	90 83       	st	Z, r25
            xPos=1+(i%4);
		    yPos=5+(i/4)*8;
			sprintf_P(strLabel,PSTR("%.2d"),PPumpLabel[i]);
    915e:	00 d0       	rcall	.+0      	; 0x9160 <FMenuPumpLabel+0x170>
    9160:	00 d0       	rcall	.+0      	; 0x9162 <FMenuPumpLabel+0x172>
    9162:	00 d0       	rcall	.+0      	; 0x9164 <FMenuPumpLabel+0x174>
    9164:	2d b7       	in	r18, 0x3d	; 61
    9166:	3e b7       	in	r19, 0x3e	; 62
    9168:	2f 5f       	subi	r18, 0xFF	; 255
    916a:	3f 4f       	sbci	r19, 0xFF	; 255
    916c:	ed b7       	in	r30, 0x3d	; 61
    916e:	fe b7       	in	r31, 0x3e	; 62
    9170:	f2 82       	std	Z+2, r15	; 0x02
    9172:	e1 82       	std	Z+1, r14	; 0x01
    9174:	f9 01       	movw	r30, r18
    9176:	b3 82       	std	Z+3, r11	; 0x03
    9178:	a2 82       	std	Z+2, r10	; 0x02
    917a:	ac 0d       	add	r26, r12
    917c:	bd 1d       	adc	r27, r13
    917e:	8c 91       	ld	r24, X
    9180:	84 83       	std	Z+4, r24	; 0x04
    9182:	15 82       	std	Z+5, r1	; 0x05
    9184:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
            lcd_print(xPos,yPos,strLabel);
    9188:	8d b7       	in	r24, 0x3d	; 61
    918a:	9e b7       	in	r25, 0x3e	; 62
    918c:	06 96       	adiw	r24, 0x06	; 6
    918e:	0f b6       	in	r0, 0x3f	; 63
    9190:	f8 94       	cli
    9192:	9e bf       	out	0x3e, r25	; 62
    9194:	0f be       	out	0x3f, r0	; 63
    9196:	8d bf       	out	0x3d, r24	; 61
    9198:	61 2f       	mov	r22, r17
    919a:	66 95       	lsr	r22
    919c:	66 95       	lsr	r22
    919e:	66 0f       	add	r22, r22
    91a0:	66 0f       	add	r22, r22
    91a2:	66 0f       	add	r22, r22
    91a4:	6b 5f       	subi	r22, 0xFB	; 251
    91a6:	13 70       	andi	r17, 0x03	; 3
    91a8:	81 2f       	mov	r24, r17
    91aa:	8f 5f       	subi	r24, 0xFF	; 255
    91ac:	a7 01       	movw	r20, r14
    91ae:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
    91b2:	ac cf       	rjmp	.-168    	; 0x910c <FMenuPumpLabel+0x11c>
		}
	}
}
    91b4:	2d 96       	adiw	r28, 0x0d	; 13
    91b6:	0f b6       	in	r0, 0x3f	; 63
    91b8:	f8 94       	cli
    91ba:	de bf       	out	0x3e, r29	; 62
    91bc:	0f be       	out	0x3f, r0	; 63
    91be:	cd bf       	out	0x3d, r28	; 61
    91c0:	cf 91       	pop	r28
    91c2:	df 91       	pop	r29
    91c4:	1f 91       	pop	r17
    91c6:	ff 90       	pop	r15
    91c8:	ef 90       	pop	r14
    91ca:	df 90       	pop	r13
    91cc:	cf 90       	pop	r12
    91ce:	bf 90       	pop	r11
    91d0:	af 90       	pop	r10
    91d2:	9f 90       	pop	r9
    91d4:	8f 90       	pop	r8
    91d6:	7f 90       	pop	r7
    91d8:	6f 90       	pop	r6
    91da:	08 95       	ret

000091dc <GenerateTransactionNum>:
		 //else Result=PS_NO_DATA;    		    
	 }	
   return Result;
}

void GenerateTransactionNum(char *sTransNumber){//Create and Save TransactionNumber to EEPROM
    91dc:	cf 92       	push	r12
    91de:	df 92       	push	r13
    91e0:	ef 92       	push	r14
    91e2:	ff 92       	push	r15
    91e4:	0f 93       	push	r16
    91e6:	1f 93       	push	r17
    91e8:	df 93       	push	r29
    91ea:	cf 93       	push	r28
    91ec:	cd b7       	in	r28, 0x3d	; 61
    91ee:	de b7       	in	r29, 0x3e	; 62
    91f0:	27 97       	sbiw	r28, 0x07	; 7
    91f2:	0f b6       	in	r0, 0x3f	; 63
    91f4:	f8 94       	cli
    91f6:	de bf       	out	0x3e, r29	; 62
    91f8:	0f be       	out	0x3f, r0	; 63
    91fa:	cd bf       	out	0x3d, r28	; 61
    91fc:	6c 01       	movw	r12, r24
    91fe:	fe 01       	movw	r30, r28
    9200:	31 96       	adiw	r30, 0x01	; 1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    9202:	ce 01       	movw	r24, r28
    9204:	08 96       	adiw	r24, 0x08	; 8
	     strMemory[i]=data;
    9206:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    9208:	e8 17       	cp	r30, r24
    920a:	f9 07       	cpc	r31, r25
    920c:	e1 f7       	brne	.-8      	; 0x9206 <GenerateTransactionNum+0x2a>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    920e:	8e 01       	movw	r16, r28
    9210:	0f 5f       	subi	r16, 0xFF	; 255
    9212:	1f 4f       	sbci	r17, 0xFF	; 255
    9214:	c8 01       	movw	r24, r16
    9216:	68 e3       	ldi	r22, 0x38	; 56
    9218:	71 e0       	ldi	r23, 0x01	; 1
    921a:	47 e0       	ldi	r20, 0x07	; 7
    921c:	50 e0       	ldi	r21, 0x00	; 0
    921e:	23 ef       	ldi	r18, 0xF3	; 243
    9220:	32 e1       	ldi	r19, 0x12	; 18
    9222:	0e 94 1f b4 	call	0x1683e	; 0x1683e <__eerd_block>
     char i,PTransNum[7],cNum,xNum=0,xAdd=0,Length=0;
	 FillChar(PTransNum,sizeof(PTransNum),0);//"999999"->"000000"
     eeprom_read_block((void*) &PTransNum, (const void*) &DefTransactionNumber,sizeof(DefTransactionNumber));
     xAdd=1;
	 xNum=0;
	 Length=strlen(PTransNum);
    9226:	f8 01       	movw	r30, r16
    9228:	01 90       	ld	r0, Z+
    922a:	00 20       	and	r0, r0
    922c:	e9 f7       	brne	.-6      	; 0x9228 <GenerateTransactionNum+0x4c>
    922e:	31 97       	sbiw	r30, 0x01	; 1
    9230:	e0 1b       	sub	r30, r16
		 //else Result=PS_NO_DATA;    		    
	 }	
   return Result;
}

void GenerateTransactionNum(char *sTransNumber){//Create and Save TransactionNumber to EEPROM
    9232:	f0 e0       	ldi	r31, 0x00	; 0
    9234:	0e 0f       	add	r16, r30
    9236:	1f 1f       	adc	r17, r31
    9238:	31 97       	sbiw	r30, 0x01	; 1
    923a:	76 01       	movw	r14, r12
    923c:	ee 0e       	add	r14, r30
    923e:	ff 1e       	adc	r15, r31
    9240:	31 96       	adiw	r30, 0x01	; 1
    9242:	61 e0       	ldi	r22, 0x01	; 1
    9244:	19 c0       	rjmp	.+50     	; 0x9278 <GenerateTransactionNum+0x9c>
	 xNum=0;
	 Length=strlen(PTransNum);

	 for(i=0;i<Length;i++){//[000009] 999999 123456
	     xNum=PTransNum[Length-i-1]-'0';		 
		 cNum='0'+((xNum+xAdd)%10);
    9246:	d8 01       	movw	r26, r16
    9248:	2c 91       	ld	r18, X
    924a:	20 53       	subi	r18, 0x30	; 48
    924c:	30 e0       	ldi	r19, 0x00	; 0
    924e:	26 0f       	add	r18, r22
    9250:	31 1d       	adc	r19, r1
    9252:	c9 01       	movw	r24, r18
    9254:	6a e0       	ldi	r22, 0x0A	; 10
    9256:	70 e0       	ldi	r23, 0x00	; 0
    9258:	0e 94 4c b7 	call	0x16e98	; 0x16e98 <__divmodhi4>
    925c:	48 2f       	mov	r20, r24
    925e:	40 5d       	subi	r20, 0xD0	; 208
		 xAdd=((xNum+xAdd)/10);
    9260:	c9 01       	movw	r24, r18
    9262:	6a e0       	ldi	r22, 0x0A	; 10
    9264:	70 e0       	ldi	r23, 0x00	; 0
    9266:	0e 94 4c b7 	call	0x16e98	; 0x16e98 <__divmodhi4>
		 PTransNum[Length-i-1]=cNum;
    926a:	d8 01       	movw	r26, r16
    926c:	4c 93       	st	X, r20
		 sTransNumber[Length-i-1]=cNum;
    926e:	d7 01       	movw	r26, r14
    9270:	4c 93       	st	X, r20
    9272:	08 94       	sec
    9274:	e1 08       	sbc	r14, r1
    9276:	f1 08       	sbc	r15, r1
    9278:	01 50       	subi	r16, 0x01	; 1
    927a:	10 40       	sbci	r17, 0x00	; 0
     eeprom_read_block((void*) &PTransNum, (const void*) &DefTransactionNumber,sizeof(DefTransactionNumber));
     xAdd=1;
	 xNum=0;
	 Length=strlen(PTransNum);

	 for(i=0;i<Length;i++){//[000009] 999999 123456
    927c:	0c 17       	cp	r16, r28
    927e:	1d 07       	cpc	r17, r29
    9280:	11 f7       	brne	.-60     	; 0x9246 <GenerateTransactionNum+0x6a>
		 cNum='0'+((xNum+xAdd)%10);
		 xAdd=((xNum+xAdd)/10);
		 PTransNum[Length-i-1]=cNum;
		 sTransNumber[Length-i-1]=cNum;
	 }
	 sTransNumber[Length]=0;
    9282:	ce 0e       	add	r12, r30
    9284:	df 1e       	adc	r13, r31
    9286:	d6 01       	movw	r26, r12
    9288:	1c 92       	st	X, r1
	 PTransNum[Length]=0;
    928a:	be 01       	movw	r22, r28
    928c:	6f 5f       	subi	r22, 0xFF	; 255
    928e:	7f 4f       	sbci	r23, 0xFF	; 255
    9290:	e6 0f       	add	r30, r22
    9292:	f7 1f       	adc	r31, r23
    9294:	10 82       	st	Z, r1
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    9296:	88 e3       	ldi	r24, 0x38	; 56
    9298:	91 e0       	ldi	r25, 0x01	; 1
    929a:	47 e0       	ldi	r20, 0x07	; 7
    929c:	50 e0       	ldi	r21, 0x00	; 0
    929e:	2b ef       	ldi	r18, 0xFB	; 251
    92a0:	32 e1       	ldi	r19, 0x12	; 18
    92a2:	0e 94 3b b4 	call	0x16876	; 0x16876 <__eewr_block>

     eeprom_write_block((const void*)&PTransNum,(void*)&DefTransactionNumber,sizeof(DefTransactionNumber));
}
    92a6:	27 96       	adiw	r28, 0x07	; 7
    92a8:	0f b6       	in	r0, 0x3f	; 63
    92aa:	f8 94       	cli
    92ac:	de bf       	out	0x3e, r29	; 62
    92ae:	0f be       	out	0x3f, r0	; 63
    92b0:	cd bf       	out	0x3d, r28	; 61
    92b2:	cf 91       	pop	r28
    92b4:	df 91       	pop	r29
    92b6:	1f 91       	pop	r17
    92b8:	0f 91       	pop	r16
    92ba:	ff 90       	pop	r15
    92bc:	ef 90       	pop	r14
    92be:	df 90       	pop	r13
    92c0:	cf 90       	pop	r12
    92c2:	08 95       	ret

000092c4 <_f_punctuation>:
				__string[__i++] = 0x30;
		__devider = __devider / 10;
	}
	__string[__i] = '\0';
}
void _f_punctuation(char* __string, unsigned char __mode, unsigned char __length, unsigned char __decimal){
    92c4:	bf 92       	push	r11
    92c6:	cf 92       	push	r12
    92c8:	df 92       	push	r13
    92ca:	ef 92       	push	r14
    92cc:	ff 92       	push	r15
    92ce:	0f 93       	push	r16
    92d0:	1f 93       	push	r17
    92d2:	df 93       	push	r29
    92d4:	cf 93       	push	r28
    92d6:	cd b7       	in	r28, 0x3d	; 61
    92d8:	de b7       	in	r29, 0x3e	; 62
    92da:	2f 97       	sbiw	r28, 0x0f	; 15
    92dc:	0f b6       	in	r0, 0x3f	; 63
    92de:	f8 94       	cli
    92e0:	de bf       	out	0x3e, r29	; 62
    92e2:	0f be       	out	0x3f, r0	; 63
    92e4:	cd bf       	out	0x3d, r28	; 61
    92e6:	8c 01       	movw	r16, r24
    92e8:	c6 2e       	mov	r12, r22
    92ea:	d4 2e       	mov	r13, r20
    92ec:	62 2f       	mov	r22, r18
	char __buff[15] = {"000000000000000"};
    92ee:	de 01       	movw	r26, r28
    92f0:	11 96       	adiw	r26, 0x01	; 1
    92f2:	e0 e0       	ldi	r30, 0x00	; 0
    92f4:	f1 e0       	ldi	r31, 0x01	; 1
    92f6:	8f e0       	ldi	r24, 0x0F	; 15
    92f8:	01 90       	ld	r0, Z+
    92fa:	0d 92       	st	X+, r0
    92fc:	81 50       	subi	r24, 0x01	; 1
    92fe:	e1 f7       	brne	.-8      	; 0x92f8 <_f_punctuation+0x34>
	char  __point = 0,  __len;
	unsigned char __i, __ii,__counter = 0;

	__len = strlen(__string);
    9300:	f8 01       	movw	r30, r16
    9302:	01 90       	ld	r0, Z+
    9304:	00 20       	and	r0, r0
    9306:	e9 f7       	brne	.-6      	; 0x9302 <_f_punctuation+0x3e>
    9308:	31 97       	sbiw	r30, 0x01	; 1
    930a:	3e 2f       	mov	r19, r30
    930c:	30 1b       	sub	r19, r16
	if(__mode == 0){
    930e:	cc 20       	and	r12, r12
    9310:	11 f5       	brne	.+68     	; 0x9356 <_f_punctuation+0x92>
		__buff[__length] = '\0';
    9312:	8d 2d       	mov	r24, r13
    9314:	90 e0       	ldi	r25, 0x00	; 0
    9316:	fe 01       	movw	r30, r28
    9318:	e8 0f       	add	r30, r24
    931a:	f9 1f       	adc	r31, r25
    931c:	11 82       	std	Z+1, r1	; 0x01
		for(__i = __length, __ii = __len - 1; __i > (__length - __len); __i--, __ii--)
    931e:	23 2f       	mov	r18, r19
    9320:	21 50       	subi	r18, 0x01	; 1
    9322:	4d 2d       	mov	r20, r13
    9324:	bc 01       	movw	r22, r24
    9326:	63 1b       	sub	r22, r19
    9328:	71 09       	sbc	r23, r1
    932a:	09 c0       	rjmp	.+18     	; 0x933e <_f_punctuation+0x7a>
			__buff[__i - 1] = __string[__ii];
    932c:	ac 0f       	add	r26, r28
    932e:	bd 1f       	adc	r27, r29
    9330:	f8 01       	movw	r30, r16
    9332:	e2 0f       	add	r30, r18
    9334:	f1 1d       	adc	r31, r1
    9336:	80 81       	ld	r24, Z
    9338:	8c 93       	st	X, r24
	unsigned char __i, __ii,__counter = 0;

	__len = strlen(__string);
	if(__mode == 0){
		__buff[__length] = '\0';
		for(__i = __length, __ii = __len - 1; __i > (__length - __len); __i--, __ii--)
    933a:	41 50       	subi	r20, 0x01	; 1
    933c:	21 50       	subi	r18, 0x01	; 1
    933e:	a4 2f       	mov	r26, r20
    9340:	b0 e0       	ldi	r27, 0x00	; 0
    9342:	6a 17       	cp	r22, r26
    9344:	7b 07       	cpc	r23, r27
    9346:	94 f3       	brlt	.-28     	; 0x932c <_f_punctuation+0x68>
			__buff[__i - 1] = __string[__ii];
		strcpy(__string, __buff);
    9348:	c8 01       	movw	r24, r16
    934a:	be 01       	movw	r22, r28
    934c:	6f 5f       	subi	r22, 0xFF	; 255
    934e:	7f 4f       	sbci	r23, 0xFF	; 255
    9350:	0e 94 18 b4 	call	0x16830	; 0x16830 <strcpy>
    9354:	90 c0       	rjmp	.+288    	; 0x9476 <_f_punctuation+0x1b2>
	}
	else{
		if(__decimal > 0){
    9356:	66 23       	and	r22, r22
    9358:	61 f1       	breq	.+88     	; 0x93b2 <_f_punctuation+0xee>
    935a:	a3 2f       	mov	r26, r19
    935c:	b0 e0       	ldi	r27, 0x00	; 0
    935e:	11 97       	sbiw	r26, 0x01	; 1
    9360:	a0 0f       	add	r26, r16
    9362:	b1 1f       	adc	r27, r17
    9364:	90 e0       	ldi	r25, 0x00	; 0
    9366:	ae 01       	movw	r20, r28
    9368:	4f 5f       	subi	r20, 0xFF	; 255
    936a:	5f 4f       	sbci	r21, 0xFF	; 255
			for(__i = 0; __i < __decimal; __i++){
				if(__i < __len)
					__buff[__counter++] = __string[__len - 1 - __i];
				else
					__buff[__counter++] = '0';
    936c:	20 e3       	ldi	r18, 0x30	; 48
    936e:	0e c0       	rjmp	.+28     	; 0x938c <_f_punctuation+0xc8>
    9370:	e9 2f       	mov	r30, r25
    9372:	f0 e0       	ldi	r31, 0x00	; 0
		strcpy(__string, __buff);
	}
	else{
		if(__decimal > 0){
			for(__i = 0; __i < __decimal; __i++){
				if(__i < __len)
    9374:	93 17       	cp	r25, r19
    9376:	28 f4       	brcc	.+10     	; 0x9382 <_f_punctuation+0xbe>
					__buff[__counter++] = __string[__len - 1 - __i];
    9378:	e4 0f       	add	r30, r20
    937a:	f5 1f       	adc	r31, r21
    937c:	8c 91       	ld	r24, X
    937e:	80 83       	st	Z, r24
    9380:	03 c0       	rjmp	.+6      	; 0x9388 <_f_punctuation+0xc4>
				else
					__buff[__counter++] = '0';
    9382:	e4 0f       	add	r30, r20
    9384:	f5 1f       	adc	r31, r21
    9386:	20 83       	st	Z, r18
			__buff[__i - 1] = __string[__ii];
		strcpy(__string, __buff);
	}
	else{
		if(__decimal > 0){
			for(__i = 0; __i < __decimal; __i++){
    9388:	9f 5f       	subi	r25, 0xFF	; 255
    938a:	11 97       	sbiw	r26, 0x01	; 1
    938c:	96 17       	cp	r25, r22
    938e:	80 f3       	brcs	.-32     	; 0x9370 <_f_punctuation+0xac>
				if(__i < __len)
					__buff[__counter++] = __string[__len - 1 - __i];
				else
					__buff[__counter++] = '0';
			}
			__buff[__counter++] = ',';
    9390:	de 01       	movw	r26, r28
    9392:	11 96       	adiw	r26, 0x01	; 1
    9394:	fd 01       	movw	r30, r26
    9396:	e6 0f       	add	r30, r22
    9398:	f1 1d       	adc	r31, r1
    939a:	8c e2       	ldi	r24, 0x2C	; 44
    939c:	80 83       	st	Z, r24
    939e:	56 2f       	mov	r21, r22
    93a0:	5f 5f       	subi	r21, 0xFF	; 255
		}
		if(__decimal > 0 && __len <= 2)
    93a2:	33 30       	cpi	r19, 0x03	; 3
    93a4:	48 f4       	brcc	.+18     	; 0x93b8 <_f_punctuation+0xf4>
			__buff[__counter++] = '0';
    93a6:	a5 0f       	add	r26, r21
    93a8:	b1 1d       	adc	r27, r1
    93aa:	80 e3       	ldi	r24, 0x30	; 48
    93ac:	8c 93       	st	X, r24
    93ae:	5f 5f       	subi	r21, 0xFF	; 255
    93b0:	32 c0       	rjmp	.+100    	; 0x9416 <_f_punctuation+0x152>
		else{
			if(__len > 1){
    93b2:	32 30       	cpi	r19, 0x02	; 2
    93b4:	68 f1       	brcs	.+90     	; 0x9410 <_f_punctuation+0x14c>
    93b6:	50 e0       	ldi	r21, 0x00	; 0
				for(	__i = 0, __ii = __len - 1 - __decimal; __i < __len - __decimal;
    93b8:	31 50       	subi	r19, 0x01	; 1
    93ba:	b3 2e       	mov	r11, r19
    93bc:	b6 1a       	sub	r11, r22
    93be:	3f 5f       	subi	r19, 0xFF	; 255
    93c0:	70 e0       	ldi	r23, 0x00	; 0
    93c2:	40 e0       	ldi	r20, 0x00	; 0
    93c4:	23 2f       	mov	r18, r19
    93c6:	30 e0       	ldi	r19, 0x00	; 0
    93c8:	26 1b       	sub	r18, r22
    93ca:	31 09       	sbc	r19, r1
						__i++, __point++, __ii--){
					if(__point == 3){
						__point = 0;
						__buff[__counter++] = '.';
    93cc:	7e 01       	movw	r14, r28
    93ce:	08 94       	sec
    93d0:	e1 1c       	adc	r14, r1
    93d2:	f1 1c       	adc	r15, r1
    93d4:	6e e2       	ldi	r22, 0x2E	; 46
    93d6:	14 c0       	rjmp	.+40     	; 0x9400 <_f_punctuation+0x13c>
			__buff[__counter++] = '0';
		else{
			if(__len > 1){
				for(	__i = 0, __ii = __len - 1 - __decimal; __i < __len - __decimal;
						__i++, __point++, __ii--){
					if(__point == 3){
    93d8:	73 30       	cpi	r23, 0x03	; 3
    93da:	31 f4       	brne	.+12     	; 0x93e8 <_f_punctuation+0x124>
						__point = 0;
						__buff[__counter++] = '.';
    93dc:	f7 01       	movw	r30, r14
    93de:	e5 0f       	add	r30, r21
    93e0:	f1 1d       	adc	r31, r1
    93e2:	60 83       	st	Z, r22
    93e4:	5f 5f       	subi	r21, 0xFF	; 255
    93e6:	70 e0       	ldi	r23, 0x00	; 0
					}
					__buff[__counter++] = __string[__ii];
    93e8:	f7 01       	movw	r30, r14
    93ea:	e5 0f       	add	r30, r21
    93ec:	f1 1d       	adc	r31, r1
    93ee:	c8 01       	movw	r24, r16
    93f0:	8a 0f       	add	r24, r26
    93f2:	91 1d       	adc	r25, r1
    93f4:	dc 01       	movw	r26, r24
    93f6:	8c 91       	ld	r24, X
    93f8:	80 83       	st	Z, r24
    93fa:	5f 5f       	subi	r21, 0xFF	; 255
		if(__decimal > 0 && __len <= 2)
			__buff[__counter++] = '0';
		else{
			if(__len > 1){
				for(	__i = 0, __ii = __len - 1 - __decimal; __i < __len - __decimal;
						__i++, __point++, __ii--){
    93fc:	4f 5f       	subi	r20, 0xFF	; 255
    93fe:	7f 5f       	subi	r23, 0xFF	; 255
    9400:	ab 2d       	mov	r26, r11
    9402:	a4 1b       	sub	r26, r20
		}
		if(__decimal > 0 && __len <= 2)
			__buff[__counter++] = '0';
		else{
			if(__len > 1){
				for(	__i = 0, __ii = __len - 1 - __decimal; __i < __len - __decimal;
    9404:	84 2f       	mov	r24, r20
    9406:	90 e0       	ldi	r25, 0x00	; 0
    9408:	82 17       	cp	r24, r18
    940a:	93 07       	cpc	r25, r19
    940c:	2c f3       	brlt	.-54     	; 0x93d8 <_f_punctuation+0x114>
    940e:	03 c0       	rjmp	.+6      	; 0x9416 <_f_punctuation+0x152>
					}
					__buff[__counter++] = __string[__ii];
				}
			}
			else
				__buff[__counter++] = '0';
    9410:	80 e3       	ldi	r24, 0x30	; 48
    9412:	89 83       	std	Y+1, r24	; 0x01
    9414:	51 e0       	ldi	r21, 0x01	; 1
		}
		if(__mode == 1){
    9416:	91 e0       	ldi	r25, 0x01	; 1
    9418:	c9 16       	cp	r12, r25
    941a:	79 f4       	brne	.+30     	; 0x943a <_f_punctuation+0x176>
    941c:	fe 01       	movw	r30, r28
    941e:	31 96       	adiw	r30, 0x01	; 1
    9420:	e5 0f       	add	r30, r21
    9422:	f1 1d       	adc	r31, r1
    9424:	d8 01       	movw	r26, r16
    9426:	02 c0       	rjmp	.+4      	; 0x942c <_f_punctuation+0x168>
			for(__i = 0; __i < __counter; __i++)
				__string[__i] = __buff[__counter - 1 - __i];
    9428:	80 81       	ld	r24, Z
    942a:	8d 93       	st	X+, r24
    942c:	31 97       	sbiw	r30, 0x01	; 1
			}
			else
				__buff[__counter++] = '0';
		}
		if(__mode == 1){
			for(__i = 0; __i < __counter; __i++)
    942e:	ec 17       	cp	r30, r28
    9430:	fd 07       	cpc	r31, r29
    9432:	d1 f7       	brne	.-12     	; 0x9428 <_f_punctuation+0x164>
				__string[__i] = __buff[__counter - 1 - __i];
			__string[__counter] = '\0';
    9434:	05 0f       	add	r16, r21
    9436:	11 1d       	adc	r17, r1
    9438:	1c c0       	rjmp	.+56     	; 0x9472 <_f_punctuation+0x1ae>
		}
		if(__mode == 2){
    943a:	f2 e0       	ldi	r31, 0x02	; 2
    943c:	cf 16       	cp	r12, r31
    943e:	d9 f4       	brne	.+54     	; 0x9476 <_f_punctuation+0x1b2>
    9440:	f8 01       	movw	r30, r16
    9442:	80 e0       	ldi	r24, 0x00	; 0
			for(__i = 0; __i < __length; __i++)
				__string[__i] = 0x20;
    9444:	90 e2       	ldi	r25, 0x20	; 32
    9446:	02 c0       	rjmp	.+4      	; 0x944c <_f_punctuation+0x188>
    9448:	91 93       	st	Z+, r25
			for(__i = 0; __i < __counter; __i++)
				__string[__i] = __buff[__counter - 1 - __i];
			__string[__counter] = '\0';
		}
		if(__mode == 2){
			for(__i = 0; __i < __length; __i++)
    944a:	8f 5f       	subi	r24, 0xFF	; 255
    944c:	8d 15       	cp	r24, r13
    944e:	e0 f3       	brcs	.-8      	; 0x9448 <_f_punctuation+0x184>
				__string[__i] = 0x20;
			for(__i = 0, __ii = __length - 1; __i < __counter; __i++, __ii--)
    9450:	de 01       	movw	r26, r28
    9452:	11 96       	adiw	r26, 0x01	; 1
    9454:	9d 2d       	mov	r25, r13
    9456:	91 50       	subi	r25, 0x01	; 1
    9458:	29 2f       	mov	r18, r25
    945a:	25 1b       	sub	r18, r21
    945c:	06 c0       	rjmp	.+12     	; 0x946a <_f_punctuation+0x1a6>
				__string[__ii] = __buff[__i];
    945e:	f8 01       	movw	r30, r16
    9460:	e9 0f       	add	r30, r25
    9462:	f1 1d       	adc	r31, r1
    9464:	8d 91       	ld	r24, X+
    9466:	80 83       	st	Z, r24
			__string[__counter] = '\0';
		}
		if(__mode == 2){
			for(__i = 0; __i < __length; __i++)
				__string[__i] = 0x20;
			for(__i = 0, __ii = __length - 1; __i < __counter; __i++, __ii--)
    9468:	91 50       	subi	r25, 0x01	; 1
    946a:	92 17       	cp	r25, r18
    946c:	c1 f7       	brne	.-16     	; 0x945e <_f_punctuation+0x19a>
				__string[__ii] = __buff[__i];
			__string[__length] = '\0';
    946e:	0d 0d       	add	r16, r13
    9470:	11 1d       	adc	r17, r1
    9472:	f8 01       	movw	r30, r16
    9474:	10 82       	st	Z, r1
		}
	}
}
    9476:	2f 96       	adiw	r28, 0x0f	; 15
    9478:	0f b6       	in	r0, 0x3f	; 63
    947a:	f8 94       	cli
    947c:	de bf       	out	0x3e, r29	; 62
    947e:	0f be       	out	0x3f, r0	; 63
    9480:	cd bf       	out	0x3d, r28	; 61
    9482:	cf 91       	pop	r28
    9484:	df 91       	pop	r29
    9486:	1f 91       	pop	r17
    9488:	0f 91       	pop	r16
    948a:	ff 90       	pop	r15
    948c:	ef 90       	pop	r14
    948e:	df 90       	pop	r13
    9490:	cf 90       	pop	r12
    9492:	bf 90       	pop	r11
    9494:	08 95       	ret

00009496 <_menu_printer>:
}

//*************************************************************************
//  ngeset printer

void _menu_printer(void){
    9496:	2f 92       	push	r2
    9498:	3f 92       	push	r3
    949a:	4f 92       	push	r4
    949c:	5f 92       	push	r5
    949e:	6f 92       	push	r6
    94a0:	7f 92       	push	r7
    94a2:	8f 92       	push	r8
    94a4:	9f 92       	push	r9
    94a6:	af 92       	push	r10
    94a8:	bf 92       	push	r11
    94aa:	cf 92       	push	r12
    94ac:	df 92       	push	r13
    94ae:	ef 92       	push	r14
    94b0:	ff 92       	push	r15
    94b2:	0f 93       	push	r16
    94b4:	1f 93       	push	r17
    94b6:	df 93       	push	r29
    94b8:	cf 93       	push	r28
    94ba:	cd b7       	in	r28, 0x3d	; 61
    94bc:	de b7       	in	r29, 0x3e	; 62
    94be:	2c 97       	sbiw	r28, 0x0c	; 12
    94c0:	0f b6       	in	r0, 0x3f	; 63
    94c2:	f8 94       	cli
    94c4:	de bf       	out	0x3e, r29	; 62
    94c6:	0f be       	out	0x3f, r0	; 63
    94c8:	cd bf       	out	0x3d, r28	; 61
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    94ca:	e1 99       	sbic	0x1c, 1	; 28
    94cc:	fe cf       	rjmp	.-4      	; 0x94ca <_menu_printer+0x34>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    94ce:	80 e3       	ldi	r24, 0x30	; 48
    94d0:	90 e0       	ldi	r25, 0x00	; 0
    94d2:	9f bb       	out	0x1f, r25	; 31
    94d4:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    94d6:	e0 9a       	sbi	0x1c, 0	; 28
    94d8:	5d b3       	in	r21, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    94da:	e1 99       	sbic	0x1c, 1	; 28
    94dc:	fe cf       	rjmp	.-4      	; 0x94da <_menu_printer+0x44>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    94de:	e5 e3       	ldi	r30, 0x35	; 53
    94e0:	f0 e0       	ldi	r31, 0x00	; 0
    94e2:	ff bb       	out	0x1f, r31	; 31
    94e4:	ee bb       	out	0x1e, r30	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    94e6:	e0 9a       	sbi	0x1c, 0	; 28
    94e8:	4d b3       	in	r20, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    94ea:	e1 99       	sbic	0x1c, 1	; 28
    94ec:	fe cf       	rjmp	.-4      	; 0x94ea <_menu_printer+0x54>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    94ee:	84 e3       	ldi	r24, 0x34	; 52
    94f0:	90 e0       	ldi	r25, 0x00	; 0
    94f2:	9f bb       	out	0x1f, r25	; 31
    94f4:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    94f6:	e0 9a       	sbi	0x1c, 0	; 28
    94f8:	3d b3       	in	r19, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    94fa:	e1 99       	sbic	0x1c, 1	; 28
    94fc:	fe cf       	rjmp	.-4      	; 0x94fa <_menu_printer+0x64>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    94fe:	e3 e3       	ldi	r30, 0x33	; 51
    9500:	f0 e0       	ldi	r31, 0x00	; 0
    9502:	ff bb       	out	0x1f, r31	; 31
    9504:	ee bb       	out	0x1e, r30	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    9506:	e0 9a       	sbi	0x1c, 0	; 28
    9508:	2d b3       	in	r18, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    950a:	e1 99       	sbic	0x1c, 1	; 28
    950c:	fe cf       	rjmp	.-4      	; 0x950a <_menu_printer+0x74>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    950e:	71 e3       	ldi	r23, 0x31	; 49
    9510:	27 2e       	mov	r2, r23
    9512:	70 e0       	ldi	r23, 0x00	; 0
    9514:	37 2e       	mov	r3, r23
    9516:	3f ba       	out	0x1f, r3	; 31
    9518:	2e ba       	out	0x1e, r2	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    951a:	e0 9a       	sbi	0x1c, 0	; 28
    951c:	9d b3       	in	r25, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    951e:	e1 99       	sbic	0x1c, 1	; 28
    9520:	fe cf       	rjmp	.-4      	; 0x951e <_menu_printer+0x88>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    9522:	62 e3       	ldi	r22, 0x32	; 50
    9524:	46 2e       	mov	r4, r22
    9526:	60 e0       	ldi	r22, 0x00	; 0
    9528:	56 2e       	mov	r5, r22
    952a:	5f ba       	out	0x1f, r5	; 31
    952c:	4e ba       	out	0x1e, r4	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    952e:	e0 9a       	sbi	0x1c, 0	; 28
    9530:	8d b3       	in	r24, 0x1d	; 29
	char 			__value[6];
	char	__i, __x, __y, __lmt, __start, __key, __num, __buff[6];
//	char lcdteks[20];

	__value[0] = eeprom_read_byte(&DefPrinterType);
    9532:	59 83       	std	Y+1, r21	; 0x01
	__value[1] = eeprom_read_byte(&DefPrintSize);
    9534:	4a 83       	std	Y+2, r20	; 0x02
	__value[2] = eeprom_read_byte(&DefPrintLogo);
    9536:	3b 83       	std	Y+3, r19	; 0x03
	__value[3] = eeprom_read_byte(&DefPrintAutoCut);
    9538:	2c 83       	std	Y+4, r18	; 0x04
	__value[4] = eeprom_read_byte(&DefPrintScrollEnd);
    953a:	9d 83       	std	Y+5, r25	; 0x05
	__value[5] = eeprom_read_byte(&DefPrintScrollSpace);
    953c:	8e 83       	std	Y+6, r24	; 0x06

	lcd_clear();
    953e:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
	lcd_printf(1, 1, PSTR("1)Type:  5)Scroll:"));
    9542:	81 e0       	ldi	r24, 0x01	; 1
    9544:	61 e0       	ldi	r22, 0x01	; 1
    9546:	4c e7       	ldi	r20, 0x7C	; 124
    9548:	5b e0       	ldi	r21, 0x0B	; 11
    954a:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
	lcd_printf(2, 1, PSTR("2)Size:  6)Space :"));
    954e:	82 e0       	ldi	r24, 0x02	; 2
    9550:	61 e0       	ldi	r22, 0x01	; 1
    9552:	49 e6       	ldi	r20, 0x69	; 105
    9554:	5b e0       	ldi	r21, 0x0B	; 11
    9556:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
	lcd_printf(3, 1, PSTR("3)Logo:  #)Save"));
    955a:	83 e0       	ldi	r24, 0x03	; 3
    955c:	61 e0       	ldi	r22, 0x01	; 1
    955e:	49 e5       	ldi	r20, 0x59	; 89
    9560:	5b e0       	ldi	r21, 0x0B	; 11
    9562:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
	lcd_printf(4, 1, PSTR("4)Cut :  *)Exit"));
    9566:	84 e0       	ldi	r24, 0x04	; 4
    9568:	61 e0       	ldi	r22, 0x01	; 1
    956a:	49 e4       	ldi	r20, 0x49	; 73
    956c:	5b e0       	ldi	r21, 0x0B	; 11
    956e:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
    9572:	00 ee       	ldi	r16, 0xE0	; 224
    9574:	12 e0       	ldi	r17, 0x02	; 2
    9576:	4e 01       	movw	r8, r28
    9578:	08 94       	sec
    957a:	81 1c       	adc	r8, r1
    957c:	91 1c       	adc	r9, r1
    957e:	74 01       	movw	r14, r8

	for(__i = 0; __i < 6; __i++){
		__x = pgm_read_byte(&__prntloc[__i][0]);
		__y = pgm_read_byte(&__prntloc[__i][1]);
		_f_inttostr(__buff, __value[__i]);
    9580:	37 e0       	ldi	r19, 0x07	; 7
    9582:	c3 2e       	mov	r12, r19
    9584:	d1 2c       	mov	r13, r1
    9586:	cc 0e       	add	r12, r28
    9588:	dd 1e       	adc	r13, r29
	lcd_printf(2, 1, PSTR("2)Size:  6)Space :"));
	lcd_printf(3, 1, PSTR("3)Logo:  #)Save"));
	lcd_printf(4, 1, PSTR("4)Cut :  *)Exit"));

	for(__i = 0; __i < 6; __i++){
		__x = pgm_read_byte(&__prntloc[__i][0]);
    958a:	f8 01       	movw	r30, r16
    958c:	a4 90       	lpm	r10, Z+
		__y = pgm_read_byte(&__prntloc[__i][1]);
    958e:	0f 5f       	subi	r16, 0xFF	; 255
    9590:	1f 4f       	sbci	r17, 0xFF	; 255
    9592:	f8 01       	movw	r30, r16
    9594:	b4 90       	lpm	r11, Z+
    9596:	01 50       	subi	r16, 0x01	; 1
    9598:	10 40       	sbci	r17, 0x00	; 0
		_f_inttostr(__buff, __value[__i]);
    959a:	f7 01       	movw	r30, r14
    959c:	40 81       	ld	r20, Z
    959e:	50 e0       	ldi	r21, 0x00	; 0
    95a0:	60 e0       	ldi	r22, 0x00	; 0
    95a2:	70 e0       	ldi	r23, 0x00	; 0
    95a4:	c6 01       	movw	r24, r12
    95a6:	0e 94 62 19 	call	0x32c4	; 0x32c4 <_f_inttostr>
		if(__i == 4)_f_punctuation(__buff, 0, 2, 0);
    95aa:	8e 2d       	mov	r24, r14
    95ac:	88 19       	sub	r24, r8
    95ae:	84 30       	cpi	r24, 0x04	; 4
    95b0:	31 f4       	brne	.+12     	; 0x95be <_menu_printer+0x128>
    95b2:	c6 01       	movw	r24, r12
    95b4:	60 e0       	ldi	r22, 0x00	; 0
    95b6:	42 e0       	ldi	r20, 0x02	; 2
    95b8:	20 e0       	ldi	r18, 0x00	; 0
    95ba:	0e 94 62 49 	call	0x92c4	; 0x92c4 <_f_punctuation>
		lcd_print(__x, __y, __buff);
    95be:	8a 2d       	mov	r24, r10
    95c0:	6b 2d       	mov	r22, r11
    95c2:	a6 01       	movw	r20, r12
    95c4:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
    95c8:	0e 5f       	subi	r16, 0xFE	; 254
    95ca:	1f 4f       	sbci	r17, 0xFF	; 255
    95cc:	08 94       	sec
    95ce:	e1 1c       	adc	r14, r1
    95d0:	f1 1c       	adc	r15, r1
	lcd_printf(1, 1, PSTR("1)Type:  5)Scroll:"));
	lcd_printf(2, 1, PSTR("2)Size:  6)Space :"));
	lcd_printf(3, 1, PSTR("3)Logo:  #)Save"));
	lcd_printf(4, 1, PSTR("4)Cut :  *)Exit"));

	for(__i = 0; __i < 6; __i++){
    95d2:	f2 e0       	ldi	r31, 0x02	; 2
    95d4:	0c 3e       	cpi	r16, 0xEC	; 236
    95d6:	1f 07       	cpc	r17, r31
    95d8:	c1 f6       	brne	.-80     	; 0x958a <_menu_printer+0xf4>

		}
		if(__num >= 0x31 && __num <= 0x36){
			__lmt = pgm_read_byte(&__prntlmt[__num - 0x31]);
			__start = pgm_read_byte(&__prntstr[__num - 0x31]);
			if(__value[__num - 0x31] == __lmt)
    95da:	3e 01       	movw	r6, r28
    95dc:	08 94       	sec
    95de:	61 1c       	adc	r6, r1
    95e0:	71 1c       	adc	r7, r1
				__value[__num - 0x31] = __start;
			else
				__value[__num - 0x31]++;
			__x = pgm_read_byte(&__prntloc[__num - 0x31][0]);
			__y = pgm_read_byte(&__prntloc[__num - 0x31][1]);
			_f_inttostr(__buff, __value[__num - 0x31]);
    95e2:	27 e0       	ldi	r18, 0x07	; 7
    95e4:	c2 2e       	mov	r12, r18
    95e6:	d1 2c       	mov	r13, r1
    95e8:	cc 0e       	add	r12, r28
    95ea:	dd 1e       	adc	r13, r29
		__key = _key_scan(1);
		__num = _key_btn(__key);
		if(__key == _KEY_CANCEL)
			return;
		if(__key==_KEY_ENTER){
			eeprom_write_byte(&DefPrinterType, __value[0]);
    95ec:	89 80       	ldd	r8, Y+1	; 0x01
			eeprom_write_byte(&DefPrintSize, __value[1]);
    95ee:	9a 80       	ldd	r9, Y+2	; 0x02
			eeprom_write_byte(&DefPrintLogo, __value[2]);
    95f0:	ab 80       	ldd	r10, Y+3	; 0x03
			eeprom_write_byte(&DefPrintAutoCut, __value[3]);
    95f2:	bc 80       	ldd	r11, Y+4	; 0x04
			eeprom_write_byte(&DefPrintScrollEnd, __value[4]);
    95f4:	ed 80       	ldd	r14, Y+5	; 0x05
			eeprom_write_byte(&DefPrintScrollSpace, __value[5]);
    95f6:	fe 80       	ldd	r15, Y+6	; 0x06
	}
    //sprintf_P(lcdteks,PSTR("6)Space :%.2d"),__value[5]);
	//lcd_print(2,10,lcdteks);

	while(1){	
		__key = _key_scan(1);
    95f8:	81 e0       	ldi	r24, 0x01	; 1
    95fa:	0e 94 ab ae 	call	0x15d56	; 0x15d56 <_key_scan>
    95fe:	18 2f       	mov	r17, r24
		__num = _key_btn(__key);
    9600:	0e 94 0c ae 	call	0x15c18	; 0x15c18 <_key_btn>
    9604:	08 2f       	mov	r16, r24
		if(__key == _KEY_CANCEL)
    9606:	17 3e       	cpi	r17, 0xE7	; 231
    9608:	09 f4       	brne	.+2      	; 0x960c <_menu_printer+0x176>
    960a:	85 c0       	rjmp	.+266    	; 0x9716 <_menu_printer+0x280>
			return;
		if(__key==_KEY_ENTER){
    960c:	17 3b       	cpi	r17, 0xB7	; 183
    960e:	09 f0       	breq	.+2      	; 0x9612 <_menu_printer+0x17c>
    9610:	44 c0       	rjmp	.+136    	; 0x969a <_menu_printer+0x204>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    9612:	e1 99       	sbic	0x1c, 1	; 28
    9614:	fe cf       	rjmp	.-4      	; 0x9612 <_menu_printer+0x17c>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    9616:	80 e3       	ldi	r24, 0x30	; 48
    9618:	90 e0       	ldi	r25, 0x00	; 0
    961a:	9f bb       	out	0x1f, r25	; 31
    961c:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    961e:	8d ba       	out	0x1d, r8	; 29

    __asm__ __volatile__ (
    9620:	0f b6       	in	r0, 0x3f	; 63
    9622:	f8 94       	cli
    9624:	e2 9a       	sbi	0x1c, 2	; 28
    9626:	e1 9a       	sbi	0x1c, 1	; 28
    9628:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    962a:	e1 99       	sbic	0x1c, 1	; 28
    962c:	fe cf       	rjmp	.-4      	; 0x962a <_menu_printer+0x194>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    962e:	e5 e3       	ldi	r30, 0x35	; 53
    9630:	f0 e0       	ldi	r31, 0x00	; 0
    9632:	ff bb       	out	0x1f, r31	; 31
    9634:	ee bb       	out	0x1e, r30	; 30
#endif
    EEDR = __value;
    9636:	9d ba       	out	0x1d, r9	; 29

    __asm__ __volatile__ (
    9638:	0f b6       	in	r0, 0x3f	; 63
    963a:	f8 94       	cli
    963c:	e2 9a       	sbi	0x1c, 2	; 28
    963e:	e1 9a       	sbi	0x1c, 1	; 28
    9640:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    9642:	e1 99       	sbic	0x1c, 1	; 28
    9644:	fe cf       	rjmp	.-4      	; 0x9642 <_menu_printer+0x1ac>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    9646:	84 e3       	ldi	r24, 0x34	; 52
    9648:	90 e0       	ldi	r25, 0x00	; 0
    964a:	9f bb       	out	0x1f, r25	; 31
    964c:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    964e:	ad ba       	out	0x1d, r10	; 29

    __asm__ __volatile__ (
    9650:	0f b6       	in	r0, 0x3f	; 63
    9652:	f8 94       	cli
    9654:	e2 9a       	sbi	0x1c, 2	; 28
    9656:	e1 9a       	sbi	0x1c, 1	; 28
    9658:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    965a:	e1 99       	sbic	0x1c, 1	; 28
    965c:	fe cf       	rjmp	.-4      	; 0x965a <_menu_printer+0x1c4>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    965e:	e3 e3       	ldi	r30, 0x33	; 51
    9660:	f0 e0       	ldi	r31, 0x00	; 0
    9662:	ff bb       	out	0x1f, r31	; 31
    9664:	ee bb       	out	0x1e, r30	; 30
#endif
    EEDR = __value;
    9666:	bd ba       	out	0x1d, r11	; 29

    __asm__ __volatile__ (
    9668:	0f b6       	in	r0, 0x3f	; 63
    966a:	f8 94       	cli
    966c:	e2 9a       	sbi	0x1c, 2	; 28
    966e:	e1 9a       	sbi	0x1c, 1	; 28
    9670:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    9672:	e1 99       	sbic	0x1c, 1	; 28
    9674:	fe cf       	rjmp	.-4      	; 0x9672 <_menu_printer+0x1dc>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    9676:	3f ba       	out	0x1f, r3	; 31
    9678:	2e ba       	out	0x1e, r2	; 30
#endif
    EEDR = __value;
    967a:	ed ba       	out	0x1d, r14	; 29

    __asm__ __volatile__ (
    967c:	0f b6       	in	r0, 0x3f	; 63
    967e:	f8 94       	cli
    9680:	e2 9a       	sbi	0x1c, 2	; 28
    9682:	e1 9a       	sbi	0x1c, 1	; 28
    9684:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    9686:	e1 99       	sbic	0x1c, 1	; 28
    9688:	fe cf       	rjmp	.-4      	; 0x9686 <_menu_printer+0x1f0>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    968a:	5f ba       	out	0x1f, r5	; 31
    968c:	4e ba       	out	0x1e, r4	; 30
#endif
    EEDR = __value;
    968e:	fd ba       	out	0x1d, r15	; 29

    __asm__ __volatile__ (
    9690:	0f b6       	in	r0, 0x3f	; 63
    9692:	f8 94       	cli
    9694:	e2 9a       	sbi	0x1c, 2	; 28
    9696:	e1 9a       	sbi	0x1c, 1	; 28
    9698:	0f be       	out	0x3f, r0	; 63
			eeprom_write_byte(&DefPrintAutoCut, __value[3]);
			eeprom_write_byte(&DefPrintScrollEnd, __value[4]);
			eeprom_write_byte(&DefPrintScrollSpace, __value[5]);

		}
		if(__num >= 0x31 && __num <= 0x36){
    969a:	80 2f       	mov	r24, r16
    969c:	81 53       	subi	r24, 0x31	; 49
    969e:	86 30       	cpi	r24, 0x06	; 6
    96a0:	08 f0       	brcs	.+2      	; 0x96a4 <_menu_printer+0x20e>
    96a2:	aa cf       	rjmp	.-172    	; 0x95f8 <_menu_printer+0x162>
			__lmt = pgm_read_byte(&__prntlmt[__num - 0x31]);
    96a4:	a0 2f       	mov	r26, r16
    96a6:	b0 e0       	ldi	r27, 0x00	; 0
    96a8:	d1 97       	sbiw	r26, 0x31	; 49
    96aa:	fd 01       	movw	r30, r26
    96ac:	e4 51       	subi	r30, 0x14	; 20
    96ae:	fd 4f       	sbci	r31, 0xFD	; 253
    96b0:	24 91       	lpm	r18, Z+
			__start = pgm_read_byte(&__prntstr[__num - 0x31]);
    96b2:	fd 01       	movw	r30, r26
    96b4:	ee 50       	subi	r30, 0x0E	; 14
    96b6:	fd 4f       	sbci	r31, 0xFD	; 253
    96b8:	94 91       	lpm	r25, Z+
			if(__value[__num - 0x31] == __lmt)
    96ba:	f3 01       	movw	r30, r6
    96bc:	ea 0f       	add	r30, r26
    96be:	fb 1f       	adc	r31, r27
    96c0:	80 81       	ld	r24, Z
    96c2:	82 17       	cp	r24, r18
    96c4:	11 f4       	brne	.+4      	; 0x96ca <_menu_printer+0x234>
				__value[__num - 0x31] = __start;
    96c6:	90 83       	st	Z, r25
    96c8:	02 c0       	rjmp	.+4      	; 0x96ce <_menu_printer+0x238>
			else
				__value[__num - 0x31]++;
    96ca:	8f 5f       	subi	r24, 0xFF	; 255
    96cc:	80 83       	st	Z, r24
			__x = pgm_read_byte(&__prntloc[__num - 0x31][0]);
    96ce:	9d 01       	movw	r18, r26
    96d0:	22 0f       	add	r18, r18
    96d2:	33 1f       	adc	r19, r19
    96d4:	c9 01       	movw	r24, r18
    96d6:	80 52       	subi	r24, 0x20	; 32
    96d8:	9d 4f       	sbci	r25, 0xFD	; 253
    96da:	fc 01       	movw	r30, r24
    96dc:	f4 90       	lpm	r15, Z+
			__y = pgm_read_byte(&__prntloc[__num - 0x31][1]);
    96de:	2f 51       	subi	r18, 0x1F	; 31
    96e0:	3d 4f       	sbci	r19, 0xFD	; 253
    96e2:	f9 01       	movw	r30, r18
    96e4:	14 91       	lpm	r17, Z+
			_f_inttostr(__buff, __value[__num - 0x31]);
    96e6:	a6 0d       	add	r26, r6
    96e8:	b7 1d       	adc	r27, r7
    96ea:	4c 91       	ld	r20, X
    96ec:	50 e0       	ldi	r21, 0x00	; 0
    96ee:	60 e0       	ldi	r22, 0x00	; 0
    96f0:	70 e0       	ldi	r23, 0x00	; 0
    96f2:	c6 01       	movw	r24, r12
    96f4:	0e 94 62 19 	call	0x32c4	; 0x32c4 <_f_inttostr>
			if((__num == 0x35)||(__num == 0x36))
    96f8:	05 53       	subi	r16, 0x35	; 53
    96fa:	02 30       	cpi	r16, 0x02	; 2
    96fc:	30 f4       	brcc	.+12     	; 0x970a <_menu_printer+0x274>
				_f_punctuation(__buff, 0, 2, 0);
    96fe:	c6 01       	movw	r24, r12
    9700:	60 e0       	ldi	r22, 0x00	; 0
    9702:	42 e0       	ldi	r20, 0x02	; 2
    9704:	20 e0       	ldi	r18, 0x00	; 0
    9706:	0e 94 62 49 	call	0x92c4	; 0x92c4 <_f_punctuation>
			lcd_print(__x, __y, __buff);
    970a:	8f 2d       	mov	r24, r15
    970c:	61 2f       	mov	r22, r17
    970e:	a6 01       	movw	r20, r12
    9710:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
    9714:	6b cf       	rjmp	.-298    	; 0x95ec <_menu_printer+0x156>
		}
	}
}
    9716:	2c 96       	adiw	r28, 0x0c	; 12
    9718:	0f b6       	in	r0, 0x3f	; 63
    971a:	f8 94       	cli
    971c:	de bf       	out	0x3e, r29	; 62
    971e:	0f be       	out	0x3f, r0	; 63
    9720:	cd bf       	out	0x3d, r28	; 61
    9722:	cf 91       	pop	r28
    9724:	df 91       	pop	r29
    9726:	1f 91       	pop	r17
    9728:	0f 91       	pop	r16
    972a:	ff 90       	pop	r15
    972c:	ef 90       	pop	r14
    972e:	df 90       	pop	r13
    9730:	cf 90       	pop	r12
    9732:	bf 90       	pop	r11
    9734:	af 90       	pop	r10
    9736:	9f 90       	pop	r9
    9738:	8f 90       	pop	r8
    973a:	7f 90       	pop	r7
    973c:	6f 90       	pop	r6
    973e:	5f 90       	pop	r5
    9740:	4f 90       	pop	r4
    9742:	3f 90       	pop	r3
    9744:	2f 90       	pop	r2
    9746:	08 95       	ret

00009748 <FSettingPrinter>:
char FSettingDatetime(){
     _menu_datetime();
     return MENU_DONE;
}
char FSettingPrinter(){
     _menu_printer();
    9748:	0e 94 4b 4a 	call	0x9496	; 0x9496 <_menu_printer>
	 return MENU_DONE;
}
    974c:	81 e0       	ldi	r24, 0x01	; 1
    974e:	08 95       	ret

00009750 <SendPrint>:
	 for(i=0;i<strlen(Source);i++){
	    Dest[i]=pgm_read_byte(&Source[i]);
	 }
}

void SendPrint(char xSend,char xSendLead){
    9750:	1f 93       	push	r17
    9752:	18 2f       	mov	r17, r24
static char zSend;     
	 if (xSend==0x19){
    9754:	89 31       	cpi	r24, 0x19	; 25
    9756:	59 f4       	brne	.+22     	; 0x976e <SendPrint+0x1e>
	     if (zSend==xSendLead)_uart(_COM_PRINTER,1,xSendLead);
    9758:	40 91 89 02 	lds	r20, 0x0289
    975c:	46 17       	cp	r20, r22
    975e:	19 f4       	brne	.+6      	; 0x9766 <SendPrint+0x16>
    9760:	80 e0       	ldi	r24, 0x00	; 0
    9762:	61 e0       	ldi	r22, 0x01	; 1
    9764:	07 c0       	rjmp	.+14     	; 0x9774 <SendPrint+0x24>
		 else _uart(_COM_PRINTER,1,' ');	 
    9766:	80 e0       	ldi	r24, 0x00	; 0
    9768:	61 e0       	ldi	r22, 0x01	; 1
    976a:	40 e2       	ldi	r20, 0x20	; 32
    976c:	03 c0       	rjmp	.+6      	; 0x9774 <SendPrint+0x24>
	 } 
	 else _uart(_COM_PRINTER,1,xSend);
    976e:	80 e0       	ldi	r24, 0x00	; 0
    9770:	61 e0       	ldi	r22, 0x01	; 1
    9772:	41 2f       	mov	r20, r17
    9774:	0e 94 7a b2 	call	0x164f4	; 0x164f4 <_uart>
	 zSend=xSend;
    9778:	10 93 89 02 	sts	0x0289, r17
}
    977c:	1f 91       	pop	r17
    977e:	08 95       	ret

00009780 <CarriegeReturn>:
	      break;	 
	 }
}

void CarriegeReturn(){
     _uart(_COM_PRINTER, 1, 0x0D);     
    9780:	80 e0       	ldi	r24, 0x00	; 0
    9782:	61 e0       	ldi	r22, 0x01	; 1
    9784:	4d e0       	ldi	r20, 0x0D	; 13
    9786:	0e 94 7a b2 	call	0x164f4	; 0x164f4 <_uart>
     _uart(_COM_PRINTER, 1, 0x0A);
    978a:	80 e0       	ldi	r24, 0x00	; 0
    978c:	61 e0       	ldi	r22, 0x01	; 1
    978e:	4a e0       	ldi	r20, 0x0A	; 10
    9790:	0e 94 7a b2 	call	0x164f4	; 0x164f4 <_uart>

}
    9794:	08 95       	ret

00009796 <InitPrinter>:
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    9796:	e1 99       	sbic	0x1c, 1	; 28
    9798:	fe cf       	rjmp	.-4      	; 0x9796 <InitPrinter>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    979a:	80 e3       	ldi	r24, 0x30	; 48
    979c:	90 e0       	ldi	r25, 0x00	; 0
    979e:	9f bb       	out	0x1f, r25	; 31
    97a0:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    97a2:	e0 9a       	sbi	0x1c, 0	; 28
    97a4:	8d b3       	in	r24, 0x1d	; 29
void InitPrinter(){
char PrinterType;
     PrinterType=eeprom_read_byte(&DefPrinterType);
    //Custom Printer TG02
	//Density Lowest: 1D 7C 00
	if (PrinterType==PT_CUSTOM_TG02){
    97a6:	81 30       	cpi	r24, 0x01	; 1
    97a8:	71 f5       	brne	.+92     	; 0x9806 <InitPrinter+0x70>
		_uart(_COM_PRINTER, 1, 0x1D);_uart(_COM_PRINTER, 1, 0x7C);_uart(_COM_PRINTER, 1, 0x00);
    97aa:	80 e0       	ldi	r24, 0x00	; 0
    97ac:	61 e0       	ldi	r22, 0x01	; 1
    97ae:	4d e1       	ldi	r20, 0x1D	; 29
    97b0:	0e 94 7a b2 	call	0x164f4	; 0x164f4 <_uart>
    97b4:	80 e0       	ldi	r24, 0x00	; 0
    97b6:	61 e0       	ldi	r22, 0x01	; 1
    97b8:	4c e7       	ldi	r20, 0x7C	; 124
    97ba:	0e 94 7a b2 	call	0x164f4	; 0x164f4 <_uart>
    97be:	80 e0       	ldi	r24, 0x00	; 0
    97c0:	61 e0       	ldi	r22, 0x01	; 1
    97c2:	40 e0       	ldi	r20, 0x00	; 0
    97c4:	0e 94 7a b2 	call	0x164f4	; 0x164f4 <_uart>
		//Double Strike ON : 1B 47 01
		_uart(_COM_PRINTER, 1, 0x1B);_uart(_COM_PRINTER, 1, 0x47);_uart(_COM_PRINTER, 1, 0x01);
    97c8:	80 e0       	ldi	r24, 0x00	; 0
    97ca:	61 e0       	ldi	r22, 0x01	; 1
    97cc:	4b e1       	ldi	r20, 0x1B	; 27
    97ce:	0e 94 7a b2 	call	0x164f4	; 0x164f4 <_uart>
    97d2:	80 e0       	ldi	r24, 0x00	; 0
    97d4:	61 e0       	ldi	r22, 0x01	; 1
    97d6:	47 e4       	ldi	r20, 0x47	; 71
    97d8:	0e 94 7a b2 	call	0x164f4	; 0x164f4 <_uart>
    97dc:	80 e0       	ldi	r24, 0x00	; 0
    97de:	61 e0       	ldi	r22, 0x01	; 1
    97e0:	41 e0       	ldi	r20, 0x01	; 1
    97e2:	0e 94 7a b2 	call	0x164f4	; 0x164f4 <_uart>
		//Font Setting: 1D 21 01
		_uart(_COM_PRINTER, 1, 0x1D);_uart(_COM_PRINTER, 1, 0x21);_uart(_COM_PRINTER, 1, 0x01);   
    97e6:	80 e0       	ldi	r24, 0x00	; 0
    97e8:	61 e0       	ldi	r22, 0x01	; 1
    97ea:	4d e1       	ldi	r20, 0x1D	; 29
    97ec:	0e 94 7a b2 	call	0x164f4	; 0x164f4 <_uart>
    97f0:	80 e0       	ldi	r24, 0x00	; 0
    97f2:	61 e0       	ldi	r22, 0x01	; 1
    97f4:	41 e2       	ldi	r20, 0x21	; 33
    97f6:	0e 94 7a b2 	call	0x164f4	; 0x164f4 <_uart>
    97fa:	80 e0       	ldi	r24, 0x00	; 0
    97fc:	61 e0       	ldi	r22, 0x01	; 1
    97fe:	41 e0       	ldi	r20, 0x01	; 1
    9800:	0e 94 7a b2 	call	0x164f4	; 0x164f4 <_uart>
    9804:	08 95       	ret
		}
    else
	if (PrinterType==PT_CUSTOM_CUBE){
    9806:	82 30       	cpi	r24, 0x02	; 2
    9808:	69 f5       	brne	.+90     	; 0x9864 <InitPrinter+0xce>
        //Print Density 0%
		_uart(_COM_PRINTER, 1, 0x1D);_uart(_COM_PRINTER, 1, 0x7C);_uart(_COM_PRINTER, 1, 0x04);
    980a:	80 e0       	ldi	r24, 0x00	; 0
    980c:	61 e0       	ldi	r22, 0x01	; 1
    980e:	4d e1       	ldi	r20, 0x1D	; 29
    9810:	0e 94 7a b2 	call	0x164f4	; 0x164f4 <_uart>
    9814:	80 e0       	ldi	r24, 0x00	; 0
    9816:	61 e0       	ldi	r22, 0x01	; 1
    9818:	4c e7       	ldi	r20, 0x7C	; 124
    981a:	0e 94 7a b2 	call	0x164f4	; 0x164f4 <_uart>
    981e:	80 e0       	ldi	r24, 0x00	; 0
    9820:	61 e0       	ldi	r22, 0x01	; 1
    9822:	44 e0       	ldi	r20, 0x04	; 4
    9824:	0e 94 7a b2 	call	0x164f4	; 0x164f4 <_uart>
		//Double Strike OFF : 1B 47 00
		_uart(_COM_PRINTER, 1, 0x1B);_uart(_COM_PRINTER, 1, 0x47);_uart(_COM_PRINTER, 1, 0x00);
    9828:	80 e0       	ldi	r24, 0x00	; 0
    982a:	61 e0       	ldi	r22, 0x01	; 1
    982c:	4b e1       	ldi	r20, 0x1B	; 27
    982e:	0e 94 7a b2 	call	0x164f4	; 0x164f4 <_uart>
    9832:	80 e0       	ldi	r24, 0x00	; 0
    9834:	61 e0       	ldi	r22, 0x01	; 1
    9836:	47 e4       	ldi	r20, 0x47	; 71
    9838:	0e 94 7a b2 	call	0x164f4	; 0x164f4 <_uart>
    983c:	80 e0       	ldi	r24, 0x00	; 0
    983e:	61 e0       	ldi	r22, 0x01	; 1
    9840:	40 e0       	ldi	r20, 0x00	; 0
    9842:	0e 94 7a b2 	call	0x164f4	; 0x164f4 <_uart>
		//Font Setting: 1D 21 01
		_uart(_COM_PRINTER, 1, 0x1D);_uart(_COM_PRINTER, 1, 0x21);_uart(_COM_PRINTER, 1, 0x00);   
    9846:	80 e0       	ldi	r24, 0x00	; 0
    9848:	61 e0       	ldi	r22, 0x01	; 1
    984a:	4d e1       	ldi	r20, 0x1D	; 29
    984c:	0e 94 7a b2 	call	0x164f4	; 0x164f4 <_uart>
    9850:	80 e0       	ldi	r24, 0x00	; 0
    9852:	61 e0       	ldi	r22, 0x01	; 1
    9854:	41 e2       	ldi	r20, 0x21	; 33
    9856:	0e 94 7a b2 	call	0x164f4	; 0x164f4 <_uart>
    985a:	80 e0       	ldi	r24, 0x00	; 0
    985c:	61 e0       	ldi	r22, 0x01	; 1
    985e:	40 e0       	ldi	r20, 0x00	; 0
    9860:	0e 94 7a b2 	call	0x164f4	; 0x164f4 <_uart>
    9864:	08 95       	ret

00009866 <PrintNormalHeight>:
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    9866:	e1 99       	sbic	0x1c, 1	; 28
    9868:	fe cf       	rjmp	.-4      	; 0x9866 <PrintNormalHeight>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    986a:	80 e3       	ldi	r24, 0x30	; 48
    986c:	90 e0       	ldi	r25, 0x00	; 0
    986e:	9f bb       	out	0x1f, r25	; 31
    9870:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    9872:	e0 9a       	sbi	0x1c, 0	; 28
    9874:	8d b3       	in	r24, 0x1d	; 29
}

void PrintNormalHeight(){
char PrinterType;
     PrinterType=eeprom_read_byte(&DefPrinterType);
	 if (PrinterType==PT_CUSTOM_CUBE){
    9876:	82 30       	cpi	r24, 0x02	; 2
    9878:	79 f4       	brne	.+30     	; 0x9898 <PrintNormalHeight+0x32>
	     _uart(_COM_PRINTER, 1, 0x1D);_uart(_COM_PRINTER, 1, 0x21);_uart(_COM_PRINTER, 1, 0x00);
    987a:	80 e0       	ldi	r24, 0x00	; 0
    987c:	61 e0       	ldi	r22, 0x01	; 1
    987e:	4d e1       	ldi	r20, 0x1D	; 29
    9880:	0e 94 7a b2 	call	0x164f4	; 0x164f4 <_uart>
    9884:	80 e0       	ldi	r24, 0x00	; 0
    9886:	61 e0       	ldi	r22, 0x01	; 1
    9888:	41 e2       	ldi	r20, 0x21	; 33
    988a:	0e 94 7a b2 	call	0x164f4	; 0x164f4 <_uart>
    988e:	80 e0       	ldi	r24, 0x00	; 0
    9890:	61 e0       	ldi	r22, 0x01	; 1
    9892:	40 e0       	ldi	r20, 0x00	; 0
    9894:	0e 94 7a b2 	call	0x164f4	; 0x164f4 <_uart>
    9898:	08 95       	ret

0000989a <PrintDoubleHeight>:
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    989a:	e1 99       	sbic	0x1c, 1	; 28
    989c:	fe cf       	rjmp	.-4      	; 0x989a <PrintDoubleHeight>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    989e:	80 e3       	ldi	r24, 0x30	; 48
    98a0:	90 e0       	ldi	r25, 0x00	; 0
    98a2:	9f bb       	out	0x1f, r25	; 31
    98a4:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    98a6:	e0 9a       	sbi	0x1c, 0	; 28
    98a8:	8d b3       	in	r24, 0x1d	; 29
//void SetPrinterCharacterWidth

void PrintDoubleHeight(){
char PrinterType;
     PrinterType=eeprom_read_byte(&DefPrinterType);
	 if (PrinterType==PT_CUSTOM_CUBE){
    98aa:	82 30       	cpi	r24, 0x02	; 2
    98ac:	79 f4       	brne	.+30     	; 0x98cc <PrintDoubleHeight+0x32>
	     _uart(_COM_PRINTER, 1, 0x1D);_uart(_COM_PRINTER, 1, 0x21);_uart(_COM_PRINTER, 1, 0x01);
    98ae:	80 e0       	ldi	r24, 0x00	; 0
    98b0:	61 e0       	ldi	r22, 0x01	; 1
    98b2:	4d e1       	ldi	r20, 0x1D	; 29
    98b4:	0e 94 7a b2 	call	0x164f4	; 0x164f4 <_uart>
    98b8:	80 e0       	ldi	r24, 0x00	; 0
    98ba:	61 e0       	ldi	r22, 0x01	; 1
    98bc:	41 e2       	ldi	r20, 0x21	; 33
    98be:	0e 94 7a b2 	call	0x164f4	; 0x164f4 <_uart>
    98c2:	80 e0       	ldi	r24, 0x00	; 0
    98c4:	61 e0       	ldi	r22, 0x01	; 1
    98c6:	41 e0       	ldi	r20, 0x01	; 1
    98c8:	0e 94 7a b2 	call	0x164f4	; 0x164f4 <_uart>
    98cc:	08 95       	ret

000098ce <PaperCut>:

	 return Result;
}


void PaperCut(){
    98ce:	1f 93       	push	r17
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    98d0:	e1 99       	sbic	0x1c, 1	; 28
    98d2:	fe cf       	rjmp	.-4      	; 0x98d0 <PaperCut+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    98d4:	83 e3       	ldi	r24, 0x33	; 51
    98d6:	90 e0       	ldi	r25, 0x00	; 0
    98d8:	9f bb       	out	0x1f, r25	; 31
    98da:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    98dc:	e0 9a       	sbi	0x1c, 0	; 28
    98de:	1d b3       	in	r17, 0x1d	; 29
     char CutType;
     CutType= eeprom_read_byte(&DefPrintAutoCut);
     _uart(_COM_PRINTER, 1, 0x1B);
    98e0:	80 e0       	ldi	r24, 0x00	; 0
    98e2:	61 e0       	ldi	r22, 0x01	; 1
    98e4:	4b e1       	ldi	r20, 0x1B	; 27
    98e6:	0e 94 7a b2 	call	0x164f4	; 0x164f4 <_uart>
	 if(CutType== 1) { _uart(_COM_PRINTER, 1, 0x6D);}
    98ea:	11 30       	cpi	r17, 0x01	; 1
    98ec:	21 f4       	brne	.+8      	; 0x98f6 <PaperCut+0x28>
    98ee:	80 e0       	ldi	r24, 0x00	; 0
    98f0:	61 e0       	ldi	r22, 0x01	; 1
    98f2:	4d e6       	ldi	r20, 0x6D	; 109
    98f4:	05 c0       	rjmp	.+10     	; 0x9900 <PaperCut+0x32>
	 if(CutType== 2) {_uart(_COM_PRINTER, 1, 0x69);}
    98f6:	12 30       	cpi	r17, 0x02	; 2
    98f8:	29 f4       	brne	.+10     	; 0x9904 <PaperCut+0x36>
    98fa:	80 e0       	ldi	r24, 0x00	; 0
    98fc:	61 e0       	ldi	r22, 0x01	; 1
    98fe:	49 e6       	ldi	r20, 0x69	; 105
    9900:	0e 94 7a b2 	call	0x164f4	; 0x164f4 <_uart>

}
    9904:	1f 91       	pop	r17
    9906:	08 95       	ret

00009908 <sendMessage98>:
		        break;
	       }//EndSwitch
return Result;
}

void sendMessage98(char PumpID){
    9908:	ff 92       	push	r15
    990a:	0f 93       	push	r16
    990c:	1f 93       	push	r17
    990e:	df 93       	push	r29
    9910:	cf 93       	push	r28
    9912:	cd b7       	in	r28, 0x3d	; 61
    9914:	de b7       	in	r29, 0x3e	; 62
    9916:	ea 97       	sbiw	r28, 0x3a	; 58
    9918:	0f b6       	in	r0, 0x3f	; 63
    991a:	f8 94       	cli
    991c:	de bf       	out	0x3e, r29	; 62
    991e:	0f be       	out	0x3f, r0	; 63
    9920:	cd bf       	out	0x3d, r28	; 61
    9922:	f8 2e       	mov	r15, r24
	char __pump_id[8];
	char strSend[50];
	char xFIP_ID;
	
	_uart(1, 1,0x01);
    9924:	81 e0       	ldi	r24, 0x01	; 1
    9926:	61 e0       	ldi	r22, 0x01	; 1
    9928:	41 e0       	ldi	r20, 0x01	; 1
    992a:	0e 94 7a b2 	call	0x164f4	; 0x164f4 <_uart>
    UpdateIFT_ID(); //ReadIFT_ID
    992e:	0e 94 0f 1c 	call	0x381e	; 0x381e <UpdateIFT_ID>
	UpdateSeqNum(); //UpdateSeqNum SeqNum++
    9932:	0e 94 e4 1b 	call	0x37c8	; 0x37c8 <UpdateSeqNum>
	UpdateClientIP();//ReadSourceIP
    9936:	0e 94 ff 1d 	call	0x3bfe	; 0x3bfe <UpdateClientIP>
	UpdateServerIP();//ReadDestIP
    993a:	0e 94 97 1d 	call	0x3b2e	; 0x3b2e <UpdateServerIP>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    993e:	ce 01       	movw	r24, r28
    9940:	01 96       	adiw	r24, 0x01	; 1
    9942:	65 e4       	ldi	r22, 0x45	; 69
    9944:	70 e0       	ldi	r23, 0x00	; 0
    9946:	48 e0       	ldi	r20, 0x08	; 8
    9948:	50 e0       	ldi	r21, 0x00	; 0
    994a:	23 ef       	ldi	r18, 0xF3	; 243
    994c:	32 e1       	ldi	r19, 0x12	; 18
    994e:	0e 94 1f b4 	call	0x1683e	; 0x1683e <__eerd_block>
	eeprom_read_block((void*) &__pump_id, (const void*) &DefPumpMap, 8);
	xFIP_ID=__pump_id[PumpID-1];
	//if (xFIP_ID>16)xFIP_ID=16;
	sprintf_P(strSend,PSTR("%s%s%s%s98%.2dF968CFFB"),strIFT_ID,strSeqNum,strClientIP,strServerIP,xFIP_ID);
    9952:	8d b7       	in	r24, 0x3d	; 61
    9954:	9e b7       	in	r25, 0x3e	; 62
    9956:	0e 97       	sbiw	r24, 0x0e	; 14
    9958:	0f b6       	in	r0, 0x3f	; 63
    995a:	f8 94       	cli
    995c:	9e bf       	out	0x3e, r25	; 62
    995e:	0f be       	out	0x3f, r0	; 63
    9960:	8d bf       	out	0x3d, r24	; 61
    9962:	ad b7       	in	r26, 0x3d	; 61
    9964:	be b7       	in	r27, 0x3e	; 62
    9966:	11 96       	adiw	r26, 0x01	; 1
    9968:	8e 01       	movw	r16, r28
    996a:	07 5f       	subi	r16, 0xF7	; 247
    996c:	1f 4f       	sbci	r17, 0xFF	; 255
    996e:	ed b7       	in	r30, 0x3d	; 61
    9970:	fe b7       	in	r31, 0x3e	; 62
    9972:	12 83       	std	Z+2, r17	; 0x02
    9974:	01 83       	std	Z+1, r16	; 0x01
    9976:	89 e3       	ldi	r24, 0x39	; 57
    9978:	9d e1       	ldi	r25, 0x1D	; 29
    997a:	13 96       	adiw	r26, 0x03	; 3
    997c:	9c 93       	st	X, r25
    997e:	8e 93       	st	-X, r24
    9980:	12 97       	sbiw	r26, 0x02	; 2
    9982:	8c ec       	ldi	r24, 0xCC	; 204
    9984:	95 e0       	ldi	r25, 0x05	; 5
    9986:	15 96       	adiw	r26, 0x05	; 5
    9988:	9c 93       	st	X, r25
    998a:	8e 93       	st	-X, r24
    998c:	14 97       	sbiw	r26, 0x04	; 4
    998e:	8b ea       	ldi	r24, 0xAB	; 171
    9990:	9d e0       	ldi	r25, 0x0D	; 13
    9992:	17 96       	adiw	r26, 0x07	; 7
    9994:	9c 93       	st	X, r25
    9996:	8e 93       	st	-X, r24
    9998:	16 97       	sbiw	r26, 0x06	; 6
    999a:	8e eb       	ldi	r24, 0xBE	; 190
    999c:	99 e0       	ldi	r25, 0x09	; 9
    999e:	19 96       	adiw	r26, 0x09	; 9
    99a0:	9c 93       	st	X, r25
    99a2:	8e 93       	st	-X, r24
    99a4:	18 97       	sbiw	r26, 0x08	; 8
    99a6:	8b ee       	ldi	r24, 0xEB	; 235
    99a8:	99 e0       	ldi	r25, 0x09	; 9
    99aa:	1b 96       	adiw	r26, 0x0b	; 11
    99ac:	9c 93       	st	X, r25
    99ae:	8e 93       	st	-X, r24
    99b0:	1a 97       	sbiw	r26, 0x0a	; 10
    99b2:	fe 01       	movw	r30, r28
    99b4:	ef 0d       	add	r30, r15
    99b6:	f1 1d       	adc	r31, r1
    99b8:	80 81       	ld	r24, Z
    99ba:	1c 96       	adiw	r26, 0x0c	; 12
    99bc:	8c 93       	st	X, r24
    99be:	1c 97       	sbiw	r26, 0x0c	; 12
    99c0:	1d 96       	adiw	r26, 0x0d	; 13
    99c2:	1c 92       	st	X, r1
    99c4:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
	_uart_print(1, 0,strSend);
    99c8:	8d b7       	in	r24, 0x3d	; 61
    99ca:	9e b7       	in	r25, 0x3e	; 62
    99cc:	0e 96       	adiw	r24, 0x0e	; 14
    99ce:	0f b6       	in	r0, 0x3f	; 63
    99d0:	f8 94       	cli
    99d2:	9e bf       	out	0x3e, r25	; 62
    99d4:	0f be       	out	0x3f, r0	; 63
    99d6:	8d bf       	out	0x3d, r24	; 61
    99d8:	81 e0       	ldi	r24, 0x01	; 1
    99da:	60 e0       	ldi	r22, 0x00	; 0
    99dc:	a8 01       	movw	r20, r16
    99de:	0e 94 97 b2 	call	0x1652e	; 0x1652e <_uart_print>
	_uart(1, 1,0x02);
    99e2:	81 e0       	ldi	r24, 0x01	; 1
    99e4:	61 e0       	ldi	r22, 0x01	; 1
    99e6:	42 e0       	ldi	r20, 0x02	; 2
    99e8:	0e 94 7a b2 	call	0x164f4	; 0x164f4 <_uart>
	IsBusyMsg11=True;
    99ec:	81 e0       	ldi	r24, 0x01	; 1
    99ee:	80 93 c4 01 	sts	0x01C4, r24
}
    99f2:	ea 96       	adiw	r28, 0x3a	; 58
    99f4:	0f b6       	in	r0, 0x3f	; 63
    99f6:	f8 94       	cli
    99f8:	de bf       	out	0x3e, r29	; 62
    99fa:	0f be       	out	0x3f, r0	; 63
    99fc:	cd bf       	out	0x3d, r28	; 61
    99fe:	cf 91       	pop	r28
    9a00:	df 91       	pop	r29
    9a02:	1f 91       	pop	r17
    9a04:	0f 91       	pop	r16
    9a06:	ff 90       	pop	r15
    9a08:	08 95       	ret

00009a0a <sendMessage94>:
    //_uart_print(0, 0,strSend);
    _uart_print(1, 0,strSend);
	_uart(1, 1,0x02);
}

void sendMessage94(){//Void Transaction Message
    9a0a:	0f 93       	push	r16
    9a0c:	1f 93       	push	r17
    9a0e:	df 93       	push	r29
    9a10:	cf 93       	push	r28
    9a12:	cd b7       	in	r28, 0x3d	; 61
    9a14:	de b7       	in	r29, 0x3e	; 62
    9a16:	c0 55       	subi	r28, 0x50	; 80
    9a18:	d0 40       	sbci	r29, 0x00	; 0
    9a1a:	0f b6       	in	r0, 0x3f	; 63
    9a1c:	f8 94       	cli
    9a1e:	de bf       	out	0x3e, r29	; 62
    9a20:	0f be       	out	0x3f, r0	; 63
    9a22:	cd bf       	out	0x3d, r28	; 61
	char strSend[80];
	_uart(1, 1,0x01);
    9a24:	81 e0       	ldi	r24, 0x01	; 1
    9a26:	61 e0       	ldi	r22, 0x01	; 1
    9a28:	41 e0       	ldi	r20, 0x01	; 1
    9a2a:	0e 94 7a b2 	call	0x164f4	; 0x164f4 <_uart>
	UpdateIFT_ID(); //ReadIFT_ID
    9a2e:	0e 94 0f 1c 	call	0x381e	; 0x381e <UpdateIFT_ID>
	UpdateSeqNum(); //UpdateSeqNum SeqNum++
    9a32:	0e 94 e4 1b 	call	0x37c8	; 0x37c8 <UpdateSeqNum>
	UpdateClientIP();//ReadSourceIP
    9a36:	0e 94 ff 1d 	call	0x3bfe	; 0x3bfe <UpdateClientIP>
	UpdateServerIP();//ReadDestIP
    9a3a:	0e 94 97 1d 	call	0x3b2e	; 0x3b2e <UpdateServerIP>
	sprintf_P(strSend,PSTR("%s%s%s%s94"),strIFT_ID,strSeqNum,strClientIP,strServerIP);
    9a3e:	8d b7       	in	r24, 0x3d	; 61
    9a40:	9e b7       	in	r25, 0x3e	; 62
    9a42:	0c 97       	sbiw	r24, 0x0c	; 12
    9a44:	0f b6       	in	r0, 0x3f	; 63
    9a46:	f8 94       	cli
    9a48:	9e bf       	out	0x3e, r25	; 62
    9a4a:	0f be       	out	0x3f, r0	; 63
    9a4c:	8d bf       	out	0x3d, r24	; 61
    9a4e:	ed b7       	in	r30, 0x3d	; 61
    9a50:	fe b7       	in	r31, 0x3e	; 62
    9a52:	31 96       	adiw	r30, 0x01	; 1
    9a54:	8e 01       	movw	r16, r28
    9a56:	0f 5f       	subi	r16, 0xFF	; 255
    9a58:	1f 4f       	sbci	r17, 0xFF	; 255
    9a5a:	ad b7       	in	r26, 0x3d	; 61
    9a5c:	be b7       	in	r27, 0x3e	; 62
    9a5e:	12 96       	adiw	r26, 0x02	; 2
    9a60:	1c 93       	st	X, r17
    9a62:	0e 93       	st	-X, r16
    9a64:	11 97       	sbiw	r26, 0x01	; 1
    9a66:	81 ed       	ldi	r24, 0xD1	; 209
    9a68:	90 e2       	ldi	r25, 0x20	; 32
    9a6a:	93 83       	std	Z+3, r25	; 0x03
    9a6c:	82 83       	std	Z+2, r24	; 0x02
    9a6e:	8c ec       	ldi	r24, 0xCC	; 204
    9a70:	95 e0       	ldi	r25, 0x05	; 5
    9a72:	95 83       	std	Z+5, r25	; 0x05
    9a74:	84 83       	std	Z+4, r24	; 0x04
    9a76:	8b ea       	ldi	r24, 0xAB	; 171
    9a78:	9d e0       	ldi	r25, 0x0D	; 13
    9a7a:	97 83       	std	Z+7, r25	; 0x07
    9a7c:	86 83       	std	Z+6, r24	; 0x06
    9a7e:	8e eb       	ldi	r24, 0xBE	; 190
    9a80:	99 e0       	ldi	r25, 0x09	; 9
    9a82:	91 87       	std	Z+9, r25	; 0x09
    9a84:	80 87       	std	Z+8, r24	; 0x08
    9a86:	8b ee       	ldi	r24, 0xEB	; 235
    9a88:	99 e0       	ldi	r25, 0x09	; 9
    9a8a:	93 87       	std	Z+11, r25	; 0x0b
    9a8c:	82 87       	std	Z+10, r24	; 0x0a
    9a8e:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    _uart_print(1, 0,strSend);
    9a92:	ed b7       	in	r30, 0x3d	; 61
    9a94:	fe b7       	in	r31, 0x3e	; 62
    9a96:	3c 96       	adiw	r30, 0x0c	; 12
    9a98:	0f b6       	in	r0, 0x3f	; 63
    9a9a:	f8 94       	cli
    9a9c:	fe bf       	out	0x3e, r31	; 62
    9a9e:	0f be       	out	0x3f, r0	; 63
    9aa0:	ed bf       	out	0x3d, r30	; 61
    9aa2:	81 e0       	ldi	r24, 0x01	; 1
    9aa4:	60 e0       	ldi	r22, 0x00	; 0
    9aa6:	a8 01       	movw	r20, r16
    9aa8:	0e 94 97 b2 	call	0x1652e	; 0x1652e <_uart_print>
    //_uart_print(0, 0,strSend);
	sprintf_P(strSend,PSTR("%s%s"),strInvoiceNumber,strDateTime);
    9aac:	8d b7       	in	r24, 0x3d	; 61
    9aae:	9e b7       	in	r25, 0x3e	; 62
    9ab0:	08 97       	sbiw	r24, 0x08	; 8
    9ab2:	0f b6       	in	r0, 0x3f	; 63
    9ab4:	f8 94       	cli
    9ab6:	9e bf       	out	0x3e, r25	; 62
    9ab8:	0f be       	out	0x3f, r0	; 63
    9aba:	8d bf       	out	0x3d, r24	; 61
    9abc:	ed b7       	in	r30, 0x3d	; 61
    9abe:	fe b7       	in	r31, 0x3e	; 62
    9ac0:	31 96       	adiw	r30, 0x01	; 1
    9ac2:	ad b7       	in	r26, 0x3d	; 61
    9ac4:	be b7       	in	r27, 0x3e	; 62
    9ac6:	12 96       	adiw	r26, 0x02	; 2
    9ac8:	1c 93       	st	X, r17
    9aca:	0e 93       	st	-X, r16
    9acc:	11 97       	sbiw	r26, 0x01	; 1
    9ace:	8c ec       	ldi	r24, 0xCC	; 204
    9ad0:	90 e2       	ldi	r25, 0x20	; 32
    9ad2:	93 83       	std	Z+3, r25	; 0x03
    9ad4:	82 83       	std	Z+2, r24	; 0x02
    9ad6:	86 e3       	ldi	r24, 0x36	; 54
    9ad8:	99 e0       	ldi	r25, 0x09	; 9
    9ada:	95 83       	std	Z+5, r25	; 0x05
    9adc:	84 83       	std	Z+4, r24	; 0x04
    9ade:	87 e9       	ldi	r24, 0x97	; 151
    9ae0:	9d e0       	ldi	r25, 0x0D	; 13
    9ae2:	97 83       	std	Z+7, r25	; 0x07
    9ae4:	86 83       	std	Z+6, r24	; 0x06
    9ae6:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    _uart_print(1, 0,strSend);
    9aea:	ed b7       	in	r30, 0x3d	; 61
    9aec:	fe b7       	in	r31, 0x3e	; 62
    9aee:	38 96       	adiw	r30, 0x08	; 8
    9af0:	0f b6       	in	r0, 0x3f	; 63
    9af2:	f8 94       	cli
    9af4:	fe bf       	out	0x3e, r31	; 62
    9af6:	0f be       	out	0x3f, r0	; 63
    9af8:	ed bf       	out	0x3d, r30	; 61
    9afa:	81 e0       	ldi	r24, 0x01	; 1
    9afc:	60 e0       	ldi	r22, 0x00	; 0
    9afe:	a8 01       	movw	r20, r16
    9b00:	0e 94 97 b2 	call	0x1652e	; 0x1652e <_uart_print>
	sprintf_P(strSend,PSTR("E9445512"));
    9b04:	00 d0       	rcall	.+0      	; 0x9b06 <sendMessage94+0xfc>
    9b06:	00 d0       	rcall	.+0      	; 0x9b08 <sendMessage94+0xfe>
    9b08:	ad b7       	in	r26, 0x3d	; 61
    9b0a:	be b7       	in	r27, 0x3e	; 62
    9b0c:	12 96       	adiw	r26, 0x02	; 2
    9b0e:	1c 93       	st	X, r17
    9b10:	0e 93       	st	-X, r16
    9b12:	11 97       	sbiw	r26, 0x01	; 1
    9b14:	83 ec       	ldi	r24, 0xC3	; 195
    9b16:	90 e2       	ldi	r25, 0x20	; 32
    9b18:	14 96       	adiw	r26, 0x04	; 4
    9b1a:	9c 93       	st	X, r25
    9b1c:	8e 93       	st	-X, r24
    9b1e:	13 97       	sbiw	r26, 0x03	; 3
    9b20:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    //_uart_print(0, 0,strSend);
    _uart_print(1, 0,strSend);
    9b24:	0f 90       	pop	r0
    9b26:	0f 90       	pop	r0
    9b28:	0f 90       	pop	r0
    9b2a:	0f 90       	pop	r0
    9b2c:	81 e0       	ldi	r24, 0x01	; 1
    9b2e:	60 e0       	ldi	r22, 0x00	; 0
    9b30:	a8 01       	movw	r20, r16
    9b32:	0e 94 97 b2 	call	0x1652e	; 0x1652e <_uart_print>
	_uart(1, 1,0x02);
    9b36:	81 e0       	ldi	r24, 0x01	; 1
    9b38:	61 e0       	ldi	r22, 0x01	; 1
    9b3a:	42 e0       	ldi	r20, 0x02	; 2
    9b3c:	0e 94 7a b2 	call	0x164f4	; 0x164f4 <_uart>
}
    9b40:	c0 5b       	subi	r28, 0xB0	; 176
    9b42:	df 4f       	sbci	r29, 0xFF	; 255
    9b44:	0f b6       	in	r0, 0x3f	; 63
    9b46:	f8 94       	cli
    9b48:	de bf       	out	0x3e, r29	; 62
    9b4a:	0f be       	out	0x3f, r0	; 63
    9b4c:	cd bf       	out	0x3d, r28	; 61
    9b4e:	cf 91       	pop	r28
    9b50:	df 91       	pop	r29
    9b52:	1f 91       	pop	r17
    9b54:	0f 91       	pop	r16
    9b56:	08 95       	ret

00009b58 <sendMessage92>:
	sprintf_P(strSend,PSTR("E9445512"));
    _uart_print(1, 0,strSend);
	_uart(1, 1,0x02);
}

void sendMessage92(){
    9b58:	0f 93       	push	r16
    9b5a:	1f 93       	push	r17
    9b5c:	df 93       	push	r29
    9b5e:	cf 93       	push	r28
    9b60:	cd b7       	in	r28, 0x3d	; 61
    9b62:	de b7       	in	r29, 0x3e	; 62
    9b64:	c0 55       	subi	r28, 0x50	; 80
    9b66:	d0 40       	sbci	r29, 0x00	; 0
    9b68:	0f b6       	in	r0, 0x3f	; 63
    9b6a:	f8 94       	cli
    9b6c:	de bf       	out	0x3e, r29	; 62
    9b6e:	0f be       	out	0x3f, r0	; 63
    9b70:	cd bf       	out	0x3d, r28	; 61
	char strSend[80];
	_uart(1, 1,0x01);
    9b72:	81 e0       	ldi	r24, 0x01	; 1
    9b74:	61 e0       	ldi	r22, 0x01	; 1
    9b76:	41 e0       	ldi	r20, 0x01	; 1
    9b78:	0e 94 7a b2 	call	0x164f4	; 0x164f4 <_uart>
	UpdateIFT_ID(); //ReadIFT_ID
    9b7c:	0e 94 0f 1c 	call	0x381e	; 0x381e <UpdateIFT_ID>
	UpdateSeqNum(); //UpdateSeqNum SeqNum++
    9b80:	0e 94 e4 1b 	call	0x37c8	; 0x37c8 <UpdateSeqNum>
	UpdateClientIP();//ReadSourceIP
    9b84:	0e 94 ff 1d 	call	0x3bfe	; 0x3bfe <UpdateClientIP>
	UpdateServerIP();//ReadDestIP
    9b88:	0e 94 97 1d 	call	0x3b2e	; 0x3b2e <UpdateServerIP>
	sprintf_P(strSend,PSTR("%s%s%s%s92"),strIFT_ID,strSeqNum,strClientIP,strServerIP);
    9b8c:	8d b7       	in	r24, 0x3d	; 61
    9b8e:	9e b7       	in	r25, 0x3e	; 62
    9b90:	0c 97       	sbiw	r24, 0x0c	; 12
    9b92:	0f b6       	in	r0, 0x3f	; 63
    9b94:	f8 94       	cli
    9b96:	9e bf       	out	0x3e, r25	; 62
    9b98:	0f be       	out	0x3f, r0	; 63
    9b9a:	8d bf       	out	0x3d, r24	; 61
    9b9c:	ed b7       	in	r30, 0x3d	; 61
    9b9e:	fe b7       	in	r31, 0x3e	; 62
    9ba0:	31 96       	adiw	r30, 0x01	; 1
    9ba2:	8e 01       	movw	r16, r28
    9ba4:	0f 5f       	subi	r16, 0xFF	; 255
    9ba6:	1f 4f       	sbci	r17, 0xFF	; 255
    9ba8:	ad b7       	in	r26, 0x3d	; 61
    9baa:	be b7       	in	r27, 0x3e	; 62
    9bac:	12 96       	adiw	r26, 0x02	; 2
    9bae:	1c 93       	st	X, r17
    9bb0:	0e 93       	st	-X, r16
    9bb2:	11 97       	sbiw	r26, 0x01	; 1
    9bb4:	85 ef       	ldi	r24, 0xF5	; 245
    9bb6:	90 e2       	ldi	r25, 0x20	; 32
    9bb8:	93 83       	std	Z+3, r25	; 0x03
    9bba:	82 83       	std	Z+2, r24	; 0x02
    9bbc:	8c ec       	ldi	r24, 0xCC	; 204
    9bbe:	95 e0       	ldi	r25, 0x05	; 5
    9bc0:	95 83       	std	Z+5, r25	; 0x05
    9bc2:	84 83       	std	Z+4, r24	; 0x04
    9bc4:	8b ea       	ldi	r24, 0xAB	; 171
    9bc6:	9d e0       	ldi	r25, 0x0D	; 13
    9bc8:	97 83       	std	Z+7, r25	; 0x07
    9bca:	86 83       	std	Z+6, r24	; 0x06
    9bcc:	8e eb       	ldi	r24, 0xBE	; 190
    9bce:	99 e0       	ldi	r25, 0x09	; 9
    9bd0:	91 87       	std	Z+9, r25	; 0x09
    9bd2:	80 87       	std	Z+8, r24	; 0x08
    9bd4:	8b ee       	ldi	r24, 0xEB	; 235
    9bd6:	99 e0       	ldi	r25, 0x09	; 9
    9bd8:	93 87       	std	Z+11, r25	; 0x0b
    9bda:	82 87       	std	Z+10, r24	; 0x0a
    9bdc:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    _uart_print(1, 0,strSend);
    9be0:	ed b7       	in	r30, 0x3d	; 61
    9be2:	fe b7       	in	r31, 0x3e	; 62
    9be4:	3c 96       	adiw	r30, 0x0c	; 12
    9be6:	0f b6       	in	r0, 0x3f	; 63
    9be8:	f8 94       	cli
    9bea:	fe bf       	out	0x3e, r31	; 62
    9bec:	0f be       	out	0x3f, r0	; 63
    9bee:	ed bf       	out	0x3d, r30	; 61
    9bf0:	81 e0       	ldi	r24, 0x01	; 1
    9bf2:	60 e0       	ldi	r22, 0x00	; 0
    9bf4:	a8 01       	movw	r20, r16
    9bf6:	0e 94 97 b2 	call	0x1652e	; 0x1652e <_uart_print>
    //_uart_print(0, 0,strSend);
	sprintf_P(strSend,PSTR("%s%s%s%s"),strTranNo,strFIP_ID,strCardType,strCardID);
    9bfa:	8d b7       	in	r24, 0x3d	; 61
    9bfc:	9e b7       	in	r25, 0x3e	; 62
    9bfe:	0c 97       	sbiw	r24, 0x0c	; 12
    9c00:	0f b6       	in	r0, 0x3f	; 63
    9c02:	f8 94       	cli
    9c04:	9e bf       	out	0x3e, r25	; 62
    9c06:	0f be       	out	0x3f, r0	; 63
    9c08:	8d bf       	out	0x3d, r24	; 61
    9c0a:	ed b7       	in	r30, 0x3d	; 61
    9c0c:	fe b7       	in	r31, 0x3e	; 62
    9c0e:	31 96       	adiw	r30, 0x01	; 1
    9c10:	ad b7       	in	r26, 0x3d	; 61
    9c12:	be b7       	in	r27, 0x3e	; 62
    9c14:	12 96       	adiw	r26, 0x02	; 2
    9c16:	1c 93       	st	X, r17
    9c18:	0e 93       	st	-X, r16
    9c1a:	11 97       	sbiw	r26, 0x01	; 1
    9c1c:	8c ee       	ldi	r24, 0xEC	; 236
    9c1e:	90 e2       	ldi	r25, 0x20	; 32
    9c20:	93 83       	std	Z+3, r25	; 0x03
    9c22:	82 83       	std	Z+2, r24	; 0x02
    9c24:	81 e6       	ldi	r24, 0x61	; 97
    9c26:	9e e0       	ldi	r25, 0x0E	; 14
    9c28:	95 83       	std	Z+5, r25	; 0x05
    9c2a:	84 83       	std	Z+4, r24	; 0x04
    9c2c:	8c e9       	ldi	r24, 0x9C	; 156
    9c2e:	99 e0       	ldi	r25, 0x09	; 9
    9c30:	97 83       	std	Z+7, r25	; 0x07
    9c32:	86 83       	std	Z+6, r24	; 0x06
    9c34:	8d e7       	ldi	r24, 0x7D	; 125
    9c36:	9e e0       	ldi	r25, 0x0E	; 14
    9c38:	91 87       	std	Z+9, r25	; 0x09
    9c3a:	80 87       	std	Z+8, r24	; 0x08
    9c3c:	81 e6       	ldi	r24, 0x61	; 97
    9c3e:	9d e0       	ldi	r25, 0x0D	; 13
    9c40:	93 87       	std	Z+11, r25	; 0x0b
    9c42:	82 87       	std	Z+10, r24	; 0x0a
    9c44:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    _uart_print(1, 0,strSend);
    9c48:	ed b7       	in	r30, 0x3d	; 61
    9c4a:	fe b7       	in	r31, 0x3e	; 62
    9c4c:	3c 96       	adiw	r30, 0x0c	; 12
    9c4e:	0f b6       	in	r0, 0x3f	; 63
    9c50:	f8 94       	cli
    9c52:	fe bf       	out	0x3e, r31	; 62
    9c54:	0f be       	out	0x3f, r0	; 63
    9c56:	ed bf       	out	0x3d, r30	; 61
    9c58:	81 e0       	ldi	r24, 0x01	; 1
    9c5a:	60 e0       	ldi	r22, 0x00	; 0
    9c5c:	a8 01       	movw	r20, r16
    9c5e:	0e 94 97 b2 	call	0x1652e	; 0x1652e <_uart_print>
    //_uart_print(0, 0,strSend);
	sprintf_P(strSend,PSTR("%s%s%s"),strApprovalCode,strInvoiceNumber,strDateTime);
    9c62:	8d b7       	in	r24, 0x3d	; 61
    9c64:	9e b7       	in	r25, 0x3e	; 62
    9c66:	0a 97       	sbiw	r24, 0x0a	; 10
    9c68:	0f b6       	in	r0, 0x3f	; 63
    9c6a:	f8 94       	cli
    9c6c:	9e bf       	out	0x3e, r25	; 62
    9c6e:	0f be       	out	0x3f, r0	; 63
    9c70:	8d bf       	out	0x3d, r24	; 61
    9c72:	ed b7       	in	r30, 0x3d	; 61
    9c74:	fe b7       	in	r31, 0x3e	; 62
    9c76:	31 96       	adiw	r30, 0x01	; 1
    9c78:	ad b7       	in	r26, 0x3d	; 61
    9c7a:	be b7       	in	r27, 0x3e	; 62
    9c7c:	12 96       	adiw	r26, 0x02	; 2
    9c7e:	1c 93       	st	X, r17
    9c80:	0e 93       	st	-X, r16
    9c82:	11 97       	sbiw	r26, 0x01	; 1
    9c84:	85 ee       	ldi	r24, 0xE5	; 229
    9c86:	90 e2       	ldi	r25, 0x20	; 32
    9c88:	93 83       	std	Z+3, r25	; 0x03
    9c8a:	82 83       	std	Z+2, r24	; 0x02
    9c8c:	84 ee       	ldi	r24, 0xE4	; 228
    9c8e:	99 e0       	ldi	r25, 0x09	; 9
    9c90:	95 83       	std	Z+5, r25	; 0x05
    9c92:	84 83       	std	Z+4, r24	; 0x04
    9c94:	86 e3       	ldi	r24, 0x36	; 54
    9c96:	99 e0       	ldi	r25, 0x09	; 9
    9c98:	97 83       	std	Z+7, r25	; 0x07
    9c9a:	86 83       	std	Z+6, r24	; 0x06
    9c9c:	87 e9       	ldi	r24, 0x97	; 151
    9c9e:	9d e0       	ldi	r25, 0x0D	; 13
    9ca0:	91 87       	std	Z+9, r25	; 0x09
    9ca2:	80 87       	std	Z+8, r24	; 0x08
    9ca4:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    _uart_print(1, 0,strSend);
    9ca8:	ed b7       	in	r30, 0x3d	; 61
    9caa:	fe b7       	in	r31, 0x3e	; 62
    9cac:	3a 96       	adiw	r30, 0x0a	; 10
    9cae:	0f b6       	in	r0, 0x3f	; 63
    9cb0:	f8 94       	cli
    9cb2:	fe bf       	out	0x3e, r31	; 62
    9cb4:	0f be       	out	0x3f, r0	; 63
    9cb6:	ed bf       	out	0x3d, r30	; 61
    9cb8:	81 e0       	ldi	r24, 0x01	; 1
    9cba:	60 e0       	ldi	r22, 0x00	; 0
    9cbc:	a8 01       	movw	r20, r16
    9cbe:	0e 94 97 b2 	call	0x1652e	; 0x1652e <_uart_print>
    //_uart_print(0, 0,strSend);
	sprintf_P(strSend,PSTR("E9445512"));
    9cc2:	00 d0       	rcall	.+0      	; 0x9cc4 <sendMessage92+0x16c>
    9cc4:	00 d0       	rcall	.+0      	; 0x9cc6 <sendMessage92+0x16e>
    9cc6:	ad b7       	in	r26, 0x3d	; 61
    9cc8:	be b7       	in	r27, 0x3e	; 62
    9cca:	12 96       	adiw	r26, 0x02	; 2
    9ccc:	1c 93       	st	X, r17
    9cce:	0e 93       	st	-X, r16
    9cd0:	11 97       	sbiw	r26, 0x01	; 1
    9cd2:	8c ed       	ldi	r24, 0xDC	; 220
    9cd4:	90 e2       	ldi	r25, 0x20	; 32
    9cd6:	14 96       	adiw	r26, 0x04	; 4
    9cd8:	9c 93       	st	X, r25
    9cda:	8e 93       	st	-X, r24
    9cdc:	13 97       	sbiw	r26, 0x03	; 3
    9cde:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    //_uart_print(0, 0,strSend);
    _uart_print(1, 0,strSend);
    9ce2:	0f 90       	pop	r0
    9ce4:	0f 90       	pop	r0
    9ce6:	0f 90       	pop	r0
    9ce8:	0f 90       	pop	r0
    9cea:	81 e0       	ldi	r24, 0x01	; 1
    9cec:	60 e0       	ldi	r22, 0x00	; 0
    9cee:	a8 01       	movw	r20, r16
    9cf0:	0e 94 97 b2 	call	0x1652e	; 0x1652e <_uart_print>
	_uart(1, 1,0x02);
    9cf4:	81 e0       	ldi	r24, 0x01	; 1
    9cf6:	61 e0       	ldi	r22, 0x01	; 1
    9cf8:	42 e0       	ldi	r20, 0x02	; 2
    9cfa:	0e 94 7a b2 	call	0x164f4	; 0x164f4 <_uart>
}
    9cfe:	c0 5b       	subi	r28, 0xB0	; 176
    9d00:	df 4f       	sbci	r29, 0xFF	; 255
    9d02:	0f b6       	in	r0, 0x3f	; 63
    9d04:	f8 94       	cli
    9d06:	de bf       	out	0x3e, r29	; 62
    9d08:	0f be       	out	0x3f, r0	; 63
    9d0a:	cd bf       	out	0x3d, r28	; 61
    9d0c:	cf 91       	pop	r28
    9d0e:	df 91       	pop	r29
    9d10:	1f 91       	pop	r17
    9d12:	0f 91       	pop	r16
    9d14:	08 95       	ret

00009d16 <sendMessage90>:
	sprintf_P(strSend,PSTR("%dF0000000E123456FFFFF%sE9445512"),CardType,strOdometer);
    _uart_print(1, 0,strSend);
	_uart(1, 1,0x02);
}

void sendMessage90(){
    9d16:	0f 93       	push	r16
    9d18:	1f 93       	push	r17
    9d1a:	df 93       	push	r29
    9d1c:	cf 93       	push	r28
    9d1e:	cd b7       	in	r28, 0x3d	; 61
    9d20:	de b7       	in	r29, 0x3e	; 62
    9d22:	c0 55       	subi	r28, 0x50	; 80
    9d24:	d0 40       	sbci	r29, 0x00	; 0
    9d26:	0f b6       	in	r0, 0x3f	; 63
    9d28:	f8 94       	cli
    9d2a:	de bf       	out	0x3e, r29	; 62
    9d2c:	0f be       	out	0x3f, r0	; 63
    9d2e:	cd bf       	out	0x3d, r28	; 61
	char strSend[80];
	_uart(1, 1,0x01);
    9d30:	81 e0       	ldi	r24, 0x01	; 1
    9d32:	61 e0       	ldi	r22, 0x01	; 1
    9d34:	41 e0       	ldi	r20, 0x01	; 1
    9d36:	0e 94 7a b2 	call	0x164f4	; 0x164f4 <_uart>
	UpdateIFT_ID(); //ReadIFT_ID
    9d3a:	0e 94 0f 1c 	call	0x381e	; 0x381e <UpdateIFT_ID>
	UpdateSeqNum(); //UpdateSeqNum SeqNum++
    9d3e:	0e 94 e4 1b 	call	0x37c8	; 0x37c8 <UpdateSeqNum>
	UpdateClientIP();//ReadSourceIP
    9d42:	0e 94 ff 1d 	call	0x3bfe	; 0x3bfe <UpdateClientIP>
	UpdateServerIP();//ReadDestIP
    9d46:	0e 94 97 1d 	call	0x3b2e	; 0x3b2e <UpdateServerIP>
	sprintf_P(strSend,PSTR("%s%s%s%s90"),strIFT_ID,strSeqNum,strClientIP,strServerIP);
    9d4a:	8d b7       	in	r24, 0x3d	; 61
    9d4c:	9e b7       	in	r25, 0x3e	; 62
    9d4e:	0c 97       	sbiw	r24, 0x0c	; 12
    9d50:	0f b6       	in	r0, 0x3f	; 63
    9d52:	f8 94       	cli
    9d54:	9e bf       	out	0x3e, r25	; 62
    9d56:	0f be       	out	0x3f, r0	; 63
    9d58:	8d bf       	out	0x3d, r24	; 61
    9d5a:	ed b7       	in	r30, 0x3d	; 61
    9d5c:	fe b7       	in	r31, 0x3e	; 62
    9d5e:	31 96       	adiw	r30, 0x01	; 1
    9d60:	8e 01       	movw	r16, r28
    9d62:	0f 5f       	subi	r16, 0xFF	; 255
    9d64:	1f 4f       	sbci	r17, 0xFF	; 255
    9d66:	ad b7       	in	r26, 0x3d	; 61
    9d68:	be b7       	in	r27, 0x3e	; 62
    9d6a:	12 96       	adiw	r26, 0x02	; 2
    9d6c:	1c 93       	st	X, r17
    9d6e:	0e 93       	st	-X, r16
    9d70:	11 97       	sbiw	r26, 0x01	; 1
    9d72:	8e e0       	ldi	r24, 0x0E	; 14
    9d74:	91 e2       	ldi	r25, 0x21	; 33
    9d76:	93 83       	std	Z+3, r25	; 0x03
    9d78:	82 83       	std	Z+2, r24	; 0x02
    9d7a:	8c ec       	ldi	r24, 0xCC	; 204
    9d7c:	95 e0       	ldi	r25, 0x05	; 5
    9d7e:	95 83       	std	Z+5, r25	; 0x05
    9d80:	84 83       	std	Z+4, r24	; 0x04
    9d82:	8b ea       	ldi	r24, 0xAB	; 171
    9d84:	9d e0       	ldi	r25, 0x0D	; 13
    9d86:	97 83       	std	Z+7, r25	; 0x07
    9d88:	86 83       	std	Z+6, r24	; 0x06
    9d8a:	8e eb       	ldi	r24, 0xBE	; 190
    9d8c:	99 e0       	ldi	r25, 0x09	; 9
    9d8e:	91 87       	std	Z+9, r25	; 0x09
    9d90:	80 87       	std	Z+8, r24	; 0x08
    9d92:	8b ee       	ldi	r24, 0xEB	; 235
    9d94:	99 e0       	ldi	r25, 0x09	; 9
    9d96:	93 87       	std	Z+11, r25	; 0x0b
    9d98:	82 87       	std	Z+10, r24	; 0x0a
    9d9a:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    _uart_print(1, 0,strSend);
    9d9e:	ed b7       	in	r30, 0x3d	; 61
    9da0:	fe b7       	in	r31, 0x3e	; 62
    9da2:	3c 96       	adiw	r30, 0x0c	; 12
    9da4:	0f b6       	in	r0, 0x3f	; 63
    9da6:	f8 94       	cli
    9da8:	fe bf       	out	0x3e, r31	; 62
    9daa:	0f be       	out	0x3f, r0	; 63
    9dac:	ed bf       	out	0x3d, r30	; 61
    9dae:	81 e0       	ldi	r24, 0x01	; 1
    9db0:	60 e0       	ldi	r22, 0x00	; 0
    9db2:	a8 01       	movw	r20, r16
    9db4:	0e 94 97 b2 	call	0x1652e	; 0x1652e <_uart_print>
	sprintf_P(strSend,PSTR("%s%s"),strFIP_ID,strRef1);
    9db8:	8d b7       	in	r24, 0x3d	; 61
    9dba:	9e b7       	in	r25, 0x3e	; 62
    9dbc:	08 97       	sbiw	r24, 0x08	; 8
    9dbe:	0f b6       	in	r0, 0x3f	; 63
    9dc0:	f8 94       	cli
    9dc2:	9e bf       	out	0x3e, r25	; 62
    9dc4:	0f be       	out	0x3f, r0	; 63
    9dc6:	8d bf       	out	0x3d, r24	; 61
    9dc8:	ed b7       	in	r30, 0x3d	; 61
    9dca:	fe b7       	in	r31, 0x3e	; 62
    9dcc:	31 96       	adiw	r30, 0x01	; 1
    9dce:	ad b7       	in	r26, 0x3d	; 61
    9dd0:	be b7       	in	r27, 0x3e	; 62
    9dd2:	12 96       	adiw	r26, 0x02	; 2
    9dd4:	1c 93       	st	X, r17
    9dd6:	0e 93       	st	-X, r16
    9dd8:	11 97       	sbiw	r26, 0x01	; 1
    9dda:	89 e0       	ldi	r24, 0x09	; 9
    9ddc:	91 e2       	ldi	r25, 0x21	; 33
    9dde:	93 83       	std	Z+3, r25	; 0x03
    9de0:	82 83       	std	Z+2, r24	; 0x02
    9de2:	8c e9       	ldi	r24, 0x9C	; 156
    9de4:	99 e0       	ldi	r25, 0x09	; 9
    9de6:	95 83       	std	Z+5, r25	; 0x05
    9de8:	84 83       	std	Z+4, r24	; 0x04
    9dea:	88 e6       	ldi	r24, 0x68	; 104
    9dec:	9e e0       	ldi	r25, 0x0E	; 14
    9dee:	97 83       	std	Z+7, r25	; 0x07
    9df0:	86 83       	std	Z+6, r24	; 0x06
    9df2:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    _uart_print(1, 0,strSend);
    9df6:	ed b7       	in	r30, 0x3d	; 61
    9df8:	fe b7       	in	r31, 0x3e	; 62
    9dfa:	38 96       	adiw	r30, 0x08	; 8
    9dfc:	0f b6       	in	r0, 0x3f	; 63
    9dfe:	f8 94       	cli
    9e00:	fe bf       	out	0x3e, r31	; 62
    9e02:	0f be       	out	0x3f, r0	; 63
    9e04:	ed bf       	out	0x3d, r30	; 61
    9e06:	81 e0       	ldi	r24, 0x01	; 1
    9e08:	60 e0       	ldi	r22, 0x00	; 0
    9e0a:	a8 01       	movw	r20, r16
    9e0c:	0e 94 97 b2 	call	0x1652e	; 0x1652e <_uart_print>
	sprintf_P(strSend,PSTR("E9445512"));
    9e10:	00 d0       	rcall	.+0      	; 0x9e12 <sendMessage90+0xfc>
    9e12:	00 d0       	rcall	.+0      	; 0x9e14 <sendMessage90+0xfe>
    9e14:	ad b7       	in	r26, 0x3d	; 61
    9e16:	be b7       	in	r27, 0x3e	; 62
    9e18:	12 96       	adiw	r26, 0x02	; 2
    9e1a:	1c 93       	st	X, r17
    9e1c:	0e 93       	st	-X, r16
    9e1e:	11 97       	sbiw	r26, 0x01	; 1
    9e20:	80 e0       	ldi	r24, 0x00	; 0
    9e22:	91 e2       	ldi	r25, 0x21	; 33
    9e24:	14 96       	adiw	r26, 0x04	; 4
    9e26:	9c 93       	st	X, r25
    9e28:	8e 93       	st	-X, r24
    9e2a:	13 97       	sbiw	r26, 0x03	; 3
    9e2c:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    _uart_print(1, 0,strSend);
    9e30:	0f 90       	pop	r0
    9e32:	0f 90       	pop	r0
    9e34:	0f 90       	pop	r0
    9e36:	0f 90       	pop	r0
    9e38:	81 e0       	ldi	r24, 0x01	; 1
    9e3a:	60 e0       	ldi	r22, 0x00	; 0
    9e3c:	a8 01       	movw	r20, r16
    9e3e:	0e 94 97 b2 	call	0x1652e	; 0x1652e <_uart_print>
	_uart(1, 1,0x02);
    9e42:	81 e0       	ldi	r24, 0x01	; 1
    9e44:	61 e0       	ldi	r22, 0x01	; 1
    9e46:	42 e0       	ldi	r20, 0x02	; 2
    9e48:	0e 94 7a b2 	call	0x164f4	; 0x164f4 <_uart>
}
    9e4c:	c0 5b       	subi	r28, 0xB0	; 176
    9e4e:	df 4f       	sbci	r29, 0xFF	; 255
    9e50:	0f b6       	in	r0, 0x3f	; 63
    9e52:	f8 94       	cli
    9e54:	de bf       	out	0x3e, r29	; 62
    9e56:	0f be       	out	0x3f, r0	; 63
    9e58:	cd bf       	out	0x3d, r28	; 61
    9e5a:	cf 91       	pop	r28
    9e5c:	df 91       	pop	r29
    9e5e:	1f 91       	pop	r17
    9e60:	0f 91       	pop	r16
    9e62:	08 95       	ret

00009e64 <sendMessage58>:

	_uart_printf(1,0,PSTR("AF968CFFB"));
	_uart(1, 1,0x02);
}

void sendMessage58(){
    9e64:	cf 92       	push	r12
    9e66:	df 92       	push	r13
    9e68:	ef 92       	push	r14
    9e6a:	ff 92       	push	r15
    9e6c:	0f 93       	push	r16
    9e6e:	1f 93       	push	r17
    9e70:	df 93       	push	r29
    9e72:	cf 93       	push	r28
    9e74:	cd b7       	in	r28, 0x3d	; 61
    9e76:	de b7       	in	r29, 0x3e	; 62
    9e78:	c0 55       	subi	r28, 0x50	; 80
    9e7a:	d0 40       	sbci	r29, 0x00	; 0
    9e7c:	0f b6       	in	r0, 0x3f	; 63
    9e7e:	f8 94       	cli
    9e80:	de bf       	out	0x3e, r29	; 62
    9e82:	0f be       	out	0x3f, r0	; 63
    9e84:	cd bf       	out	0x3d, r28	; 61
	char strSend[80];
	_uart(1, 1,0x01);
    9e86:	81 e0       	ldi	r24, 0x01	; 1
    9e88:	61 e0       	ldi	r22, 0x01	; 1
    9e8a:	41 e0       	ldi	r20, 0x01	; 1
    9e8c:	0e 94 7a b2 	call	0x164f4	; 0x164f4 <_uart>
	UpdateIFT_ID(); //ReadIFT_ID
    9e90:	0e 94 0f 1c 	call	0x381e	; 0x381e <UpdateIFT_ID>
	UpdateSeqNum(); //UpdateSeqNum SeqNum++
    9e94:	0e 94 e4 1b 	call	0x37c8	; 0x37c8 <UpdateSeqNum>
	UpdateClientIP();//ReadSourceIP
    9e98:	0e 94 ff 1d 	call	0x3bfe	; 0x3bfe <UpdateClientIP>
	UpdateServerIP();//ReadDestIP
    9e9c:	0e 94 97 1d 	call	0x3b2e	; 0x3b2e <UpdateServerIP>
	UpdateCardID();  //ReadCardID
    9ea0:	0e 94 ed 3c 	call	0x79da	; 0x79da <UpdateCardID>
	sprintf_P(strSend,PSTR("%s%s%s%s58"),strIFT_ID,strSeqNum,strClientIP,strServerIP);
    9ea4:	8d b7       	in	r24, 0x3d	; 61
    9ea6:	9e b7       	in	r25, 0x3e	; 62
    9ea8:	0c 97       	sbiw	r24, 0x0c	; 12
    9eaa:	0f b6       	in	r0, 0x3f	; 63
    9eac:	f8 94       	cli
    9eae:	9e bf       	out	0x3e, r25	; 62
    9eb0:	0f be       	out	0x3f, r0	; 63
    9eb2:	8d bf       	out	0x3d, r24	; 61
    9eb4:	ed b7       	in	r30, 0x3d	; 61
    9eb6:	fe b7       	in	r31, 0x3e	; 62
    9eb8:	31 96       	adiw	r30, 0x01	; 1
    9eba:	8e 01       	movw	r16, r28
    9ebc:	0f 5f       	subi	r16, 0xFF	; 255
    9ebe:	1f 4f       	sbci	r17, 0xFF	; 255
    9ec0:	ad b7       	in	r26, 0x3d	; 61
    9ec2:	be b7       	in	r27, 0x3e	; 62
    9ec4:	12 96       	adiw	r26, 0x02	; 2
    9ec6:	1c 93       	st	X, r17
    9ec8:	0e 93       	st	-X, r16
    9eca:	11 97       	sbiw	r26, 0x01	; 1
    9ecc:	85 e4       	ldi	r24, 0x45	; 69
    9ece:	91 e2       	ldi	r25, 0x21	; 33
    9ed0:	93 83       	std	Z+3, r25	; 0x03
    9ed2:	82 83       	std	Z+2, r24	; 0x02
    9ed4:	8c ec       	ldi	r24, 0xCC	; 204
    9ed6:	95 e0       	ldi	r25, 0x05	; 5
    9ed8:	95 83       	std	Z+5, r25	; 0x05
    9eda:	84 83       	std	Z+4, r24	; 0x04
    9edc:	8b ea       	ldi	r24, 0xAB	; 171
    9ede:	9d e0       	ldi	r25, 0x0D	; 13
    9ee0:	97 83       	std	Z+7, r25	; 0x07
    9ee2:	86 83       	std	Z+6, r24	; 0x06
    9ee4:	8e eb       	ldi	r24, 0xBE	; 190
    9ee6:	99 e0       	ldi	r25, 0x09	; 9
    9ee8:	91 87       	std	Z+9, r25	; 0x09
    9eea:	80 87       	std	Z+8, r24	; 0x08
    9eec:	8b ee       	ldi	r24, 0xEB	; 235
    9eee:	99 e0       	ldi	r25, 0x09	; 9
    9ef0:	93 87       	std	Z+11, r25	; 0x0b
    9ef2:	82 87       	std	Z+10, r24	; 0x0a
    9ef4:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    _uart_print(1, 0,strSend);
    9ef8:	8d b7       	in	r24, 0x3d	; 61
    9efa:	9e b7       	in	r25, 0x3e	; 62
    9efc:	0c 96       	adiw	r24, 0x0c	; 12
    9efe:	0f b6       	in	r0, 0x3f	; 63
    9f00:	f8 94       	cli
    9f02:	9e bf       	out	0x3e, r25	; 62
    9f04:	0f be       	out	0x3f, r0	; 63
    9f06:	8d bf       	out	0x3d, r24	; 61
    9f08:	81 e0       	ldi	r24, 0x01	; 1
    9f0a:	60 e0       	ldi	r22, 0x00	; 0
    9f0c:	a8 01       	movw	r20, r16
    9f0e:	0e 94 97 b2 	call	0x1652e	; 0x1652e <_uart_print>
	AddSpaceLead(strBalanceValue,13);
    9f12:	fa ef       	ldi	r31, 0xFA	; 250
    9f14:	ef 2e       	mov	r14, r31
    9f16:	fd e0       	ldi	r31, 0x0D	; 13
    9f18:	ff 2e       	mov	r15, r31
    9f1a:	c7 01       	movw	r24, r14
    9f1c:	6d e0       	ldi	r22, 0x0D	; 13
    9f1e:	0e 94 71 2a 	call	0x54e2	; 0x54e2 <AddSpaceLead>
	AddSpaceLead(strOdometer,10);
    9f22:	e3 ea       	ldi	r30, 0xA3	; 163
    9f24:	ce 2e       	mov	r12, r30
    9f26:	e5 e0       	ldi	r30, 0x05	; 5
    9f28:	de 2e       	mov	r13, r30
    9f2a:	c6 01       	movw	r24, r12
    9f2c:	6a e0       	ldi	r22, 0x0A	; 10
    9f2e:	0e 94 71 2a 	call	0x54e2	; 0x54e2 <AddSpaceLead>
	sprintf_P(strSend,PSTR("%s%s%d%s%s"),strCardID,strFIP_ID,NozzleID,strBalanceType,strBalanceValue);
    9f32:	ad b7       	in	r26, 0x3d	; 61
    9f34:	be b7       	in	r27, 0x3e	; 62
    9f36:	1e 97       	sbiw	r26, 0x0e	; 14
    9f38:	0f b6       	in	r0, 0x3f	; 63
    9f3a:	f8 94       	cli
    9f3c:	be bf       	out	0x3e, r27	; 62
    9f3e:	0f be       	out	0x3f, r0	; 63
    9f40:	ad bf       	out	0x3d, r26	; 61
    9f42:	ed b7       	in	r30, 0x3d	; 61
    9f44:	fe b7       	in	r31, 0x3e	; 62
    9f46:	31 96       	adiw	r30, 0x01	; 1
    9f48:	12 96       	adiw	r26, 0x02	; 2
    9f4a:	1c 93       	st	X, r17
    9f4c:	0e 93       	st	-X, r16
    9f4e:	11 97       	sbiw	r26, 0x01	; 1
    9f50:	8a e3       	ldi	r24, 0x3A	; 58
    9f52:	91 e2       	ldi	r25, 0x21	; 33
    9f54:	93 83       	std	Z+3, r25	; 0x03
    9f56:	82 83       	std	Z+2, r24	; 0x02
    9f58:	81 e6       	ldi	r24, 0x61	; 97
    9f5a:	9d e0       	ldi	r25, 0x0D	; 13
    9f5c:	95 83       	std	Z+5, r25	; 0x05
    9f5e:	84 83       	std	Z+4, r24	; 0x04
    9f60:	8c e9       	ldi	r24, 0x9C	; 156
    9f62:	99 e0       	ldi	r25, 0x09	; 9
    9f64:	97 83       	std	Z+7, r25	; 0x07
    9f66:	86 83       	std	Z+6, r24	; 0x06
    9f68:	80 91 50 09 	lds	r24, 0x0950
    9f6c:	80 87       	std	Z+8, r24	; 0x08
    9f6e:	11 86       	std	Z+9, r1	; 0x09
    9f70:	83 e8       	ldi	r24, 0x83	; 131
    9f72:	95 e0       	ldi	r25, 0x05	; 5
    9f74:	93 87       	std	Z+11, r25	; 0x0b
    9f76:	82 87       	std	Z+10, r24	; 0x0a
    9f78:	f5 86       	std	Z+13, r15	; 0x0d
    9f7a:	e4 86       	std	Z+12, r14	; 0x0c
    9f7c:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    _uart_print(1, 0,strSend);
    9f80:	8d b7       	in	r24, 0x3d	; 61
    9f82:	9e b7       	in	r25, 0x3e	; 62
    9f84:	0e 96       	adiw	r24, 0x0e	; 14
    9f86:	0f b6       	in	r0, 0x3f	; 63
    9f88:	f8 94       	cli
    9f8a:	9e bf       	out	0x3e, r25	; 62
    9f8c:	0f be       	out	0x3f, r0	; 63
    9f8e:	8d bf       	out	0x3d, r24	; 61
    9f90:	81 e0       	ldi	r24, 0x01	; 1
    9f92:	60 e0       	ldi	r22, 0x00	; 0
    9f94:	a8 01       	movw	r20, r16
    9f96:	0e 94 97 b2 	call	0x1652e	; 0x1652e <_uart_print>

	CardType=0;
    9f9a:	10 92 69 05 	sts	0x0569, r1
	sprintf_P(strSend,PSTR("%dF0000000E123456FFFFF%sE9445512"),CardType,strOdometer);
    9f9e:	ad b7       	in	r26, 0x3d	; 61
    9fa0:	be b7       	in	r27, 0x3e	; 62
    9fa2:	18 97       	sbiw	r26, 0x08	; 8
    9fa4:	0f b6       	in	r0, 0x3f	; 63
    9fa6:	f8 94       	cli
    9fa8:	be bf       	out	0x3e, r27	; 62
    9faa:	0f be       	out	0x3f, r0	; 63
    9fac:	ad bf       	out	0x3d, r26	; 61
    9fae:	ed b7       	in	r30, 0x3d	; 61
    9fb0:	fe b7       	in	r31, 0x3e	; 62
    9fb2:	31 96       	adiw	r30, 0x01	; 1
    9fb4:	12 96       	adiw	r26, 0x02	; 2
    9fb6:	1c 93       	st	X, r17
    9fb8:	0e 93       	st	-X, r16
    9fba:	11 97       	sbiw	r26, 0x01	; 1
    9fbc:	89 e1       	ldi	r24, 0x19	; 25
    9fbe:	91 e2       	ldi	r25, 0x21	; 33
    9fc0:	93 83       	std	Z+3, r25	; 0x03
    9fc2:	82 83       	std	Z+2, r24	; 0x02
    9fc4:	15 82       	std	Z+5, r1	; 0x05
    9fc6:	14 82       	std	Z+4, r1	; 0x04
    9fc8:	d7 82       	std	Z+7, r13	; 0x07
    9fca:	c6 82       	std	Z+6, r12	; 0x06
    9fcc:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    _uart_print(1, 0,strSend);
    9fd0:	8d b7       	in	r24, 0x3d	; 61
    9fd2:	9e b7       	in	r25, 0x3e	; 62
    9fd4:	08 96       	adiw	r24, 0x08	; 8
    9fd6:	0f b6       	in	r0, 0x3f	; 63
    9fd8:	f8 94       	cli
    9fda:	9e bf       	out	0x3e, r25	; 62
    9fdc:	0f be       	out	0x3f, r0	; 63
    9fde:	8d bf       	out	0x3d, r24	; 61
    9fe0:	81 e0       	ldi	r24, 0x01	; 1
    9fe2:	60 e0       	ldi	r22, 0x00	; 0
    9fe4:	a8 01       	movw	r20, r16
    9fe6:	0e 94 97 b2 	call	0x1652e	; 0x1652e <_uart_print>
	_uart(1, 1,0x02);
    9fea:	81 e0       	ldi	r24, 0x01	; 1
    9fec:	61 e0       	ldi	r22, 0x01	; 1
    9fee:	42 e0       	ldi	r20, 0x02	; 2
    9ff0:	0e 94 7a b2 	call	0x164f4	; 0x164f4 <_uart>
}
    9ff4:	c0 5b       	subi	r28, 0xB0	; 176
    9ff6:	df 4f       	sbci	r29, 0xFF	; 255
    9ff8:	0f b6       	in	r0, 0x3f	; 63
    9ffa:	f8 94       	cli
    9ffc:	de bf       	out	0x3e, r29	; 62
    9ffe:	0f be       	out	0x3f, r0	; 63
    a000:	cd bf       	out	0x3d, r28	; 61
    a002:	cf 91       	pop	r28
    a004:	df 91       	pop	r29
    a006:	1f 91       	pop	r17
    a008:	0f 91       	pop	r16
    a00a:	ff 90       	pop	r15
    a00c:	ef 90       	pop	r14
    a00e:	df 90       	pop	r13
    a010:	cf 90       	pop	r12
    a012:	08 95       	ret

0000a014 <sendMessage32>:
	_uart(1, 1,0x02);
}



void sendMessage32(){//Msg32: <01>[ID][Seq][SrcIP][DestIP][MsgCode][FIP][PaymentType][Ref1][Ref2][Ref3][Ref4]<02>
    a014:	0f 93       	push	r16
    a016:	1f 93       	push	r17
    a018:	df 93       	push	r29
    a01a:	cf 93       	push	r28
    a01c:	cd b7       	in	r28, 0x3d	; 61
    a01e:	de b7       	in	r29, 0x3e	; 62
    a020:	c0 55       	subi	r28, 0x50	; 80
    a022:	d0 40       	sbci	r29, 0x00	; 0
    a024:	0f b6       	in	r0, 0x3f	; 63
    a026:	f8 94       	cli
    a028:	de bf       	out	0x3e, r29	; 62
    a02a:	0f be       	out	0x3f, r0	; 63
    a02c:	cd bf       	out	0x3d, r28	; 61
	char strSend[80];
	UpdateIFT_ID(); //ReadIFT_ID
    a02e:	0e 94 0f 1c 	call	0x381e	; 0x381e <UpdateIFT_ID>
	UpdateSeqNum(); //UpdateSeqNum SeqNum++
    a032:	0e 94 e4 1b 	call	0x37c8	; 0x37c8 <UpdateSeqNum>
	UpdateClientIP();//ReadSourceIP
    a036:	0e 94 ff 1d 	call	0x3bfe	; 0x3bfe <UpdateClientIP>
	UpdateServerIP();//ReadDestIP
    a03a:	0e 94 97 1d 	call	0x3b2e	; 0x3b2e <UpdateServerIP>
	_uart(1, 1,0x01);
    a03e:	81 e0       	ldi	r24, 0x01	; 1
    a040:	61 e0       	ldi	r22, 0x01	; 1
    a042:	41 e0       	ldi	r20, 0x01	; 1
    a044:	0e 94 7a b2 	call	0x164f4	; 0x164f4 <_uart>
	sprintf_P(strSend,PSTR("%s%s%s%s32"),strIFT_ID,strSeqNum,strClientIP,strServerIP);
    a048:	8d b7       	in	r24, 0x3d	; 61
    a04a:	9e b7       	in	r25, 0x3e	; 62
    a04c:	0c 97       	sbiw	r24, 0x0c	; 12
    a04e:	0f b6       	in	r0, 0x3f	; 63
    a050:	f8 94       	cli
    a052:	9e bf       	out	0x3e, r25	; 62
    a054:	0f be       	out	0x3f, r0	; 63
    a056:	8d bf       	out	0x3d, r24	; 61
    a058:	ed b7       	in	r30, 0x3d	; 61
    a05a:	fe b7       	in	r31, 0x3e	; 62
    a05c:	31 96       	adiw	r30, 0x01	; 1
    a05e:	8e 01       	movw	r16, r28
    a060:	0f 5f       	subi	r16, 0xFF	; 255
    a062:	1f 4f       	sbci	r17, 0xFF	; 255
    a064:	ad b7       	in	r26, 0x3d	; 61
    a066:	be b7       	in	r27, 0x3e	; 62
    a068:	12 96       	adiw	r26, 0x02	; 2
    a06a:	1c 93       	st	X, r17
    a06c:	0e 93       	st	-X, r16
    a06e:	11 97       	sbiw	r26, 0x01	; 1
    a070:	80 e8       	ldi	r24, 0x80	; 128
    a072:	91 e2       	ldi	r25, 0x21	; 33
    a074:	93 83       	std	Z+3, r25	; 0x03
    a076:	82 83       	std	Z+2, r24	; 0x02
    a078:	8c ec       	ldi	r24, 0xCC	; 204
    a07a:	95 e0       	ldi	r25, 0x05	; 5
    a07c:	95 83       	std	Z+5, r25	; 0x05
    a07e:	84 83       	std	Z+4, r24	; 0x04
    a080:	8b ea       	ldi	r24, 0xAB	; 171
    a082:	9d e0       	ldi	r25, 0x0D	; 13
    a084:	97 83       	std	Z+7, r25	; 0x07
    a086:	86 83       	std	Z+6, r24	; 0x06
    a088:	8e eb       	ldi	r24, 0xBE	; 190
    a08a:	99 e0       	ldi	r25, 0x09	; 9
    a08c:	91 87       	std	Z+9, r25	; 0x09
    a08e:	80 87       	std	Z+8, r24	; 0x08
    a090:	8b ee       	ldi	r24, 0xEB	; 235
    a092:	99 e0       	ldi	r25, 0x09	; 9
    a094:	93 87       	std	Z+11, r25	; 0x0b
    a096:	82 87       	std	Z+10, r24	; 0x0a
    a098:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    _uart_print(1, 0,strSend);
    a09c:	ed b7       	in	r30, 0x3d	; 61
    a09e:	fe b7       	in	r31, 0x3e	; 62
    a0a0:	3c 96       	adiw	r30, 0x0c	; 12
    a0a2:	0f b6       	in	r0, 0x3f	; 63
    a0a4:	f8 94       	cli
    a0a6:	fe bf       	out	0x3e, r31	; 62
    a0a8:	0f be       	out	0x3f, r0	; 63
    a0aa:	ed bf       	out	0x3d, r30	; 61
    a0ac:	81 e0       	ldi	r24, 0x01	; 1
    a0ae:	60 e0       	ldi	r22, 0x00	; 0
    a0b0:	a8 01       	movw	r20, r16
    a0b2:	0e 94 97 b2 	call	0x1652e	; 0x1652e <_uart_print>
	sprintf_P(strSend,PSTR("%s%s%s%s"),strFIP_ID,strPaymentType,strRef1,strRef2);
    a0b6:	8d b7       	in	r24, 0x3d	; 61
    a0b8:	9e b7       	in	r25, 0x3e	; 62
    a0ba:	0c 97       	sbiw	r24, 0x0c	; 12
    a0bc:	0f b6       	in	r0, 0x3f	; 63
    a0be:	f8 94       	cli
    a0c0:	9e bf       	out	0x3e, r25	; 62
    a0c2:	0f be       	out	0x3f, r0	; 63
    a0c4:	8d bf       	out	0x3d, r24	; 61
    a0c6:	ed b7       	in	r30, 0x3d	; 61
    a0c8:	fe b7       	in	r31, 0x3e	; 62
    a0ca:	31 96       	adiw	r30, 0x01	; 1
    a0cc:	ad b7       	in	r26, 0x3d	; 61
    a0ce:	be b7       	in	r27, 0x3e	; 62
    a0d0:	12 96       	adiw	r26, 0x02	; 2
    a0d2:	1c 93       	st	X, r17
    a0d4:	0e 93       	st	-X, r16
    a0d6:	11 97       	sbiw	r26, 0x01	; 1
    a0d8:	87 e7       	ldi	r24, 0x77	; 119
    a0da:	91 e2       	ldi	r25, 0x21	; 33
    a0dc:	93 83       	std	Z+3, r25	; 0x03
    a0de:	82 83       	std	Z+2, r24	; 0x02
    a0e0:	8c e9       	ldi	r24, 0x9C	; 156
    a0e2:	99 e0       	ldi	r25, 0x09	; 9
    a0e4:	95 83       	std	Z+5, r25	; 0x05
    a0e6:	84 83       	std	Z+4, r24	; 0x04
    a0e8:	83 e3       	ldi	r24, 0x33	; 51
    a0ea:	99 e0       	ldi	r25, 0x09	; 9
    a0ec:	97 83       	std	Z+7, r25	; 0x07
    a0ee:	86 83       	std	Z+6, r24	; 0x06
    a0f0:	88 e6       	ldi	r24, 0x68	; 104
    a0f2:	9e e0       	ldi	r25, 0x0E	; 14
    a0f4:	91 87       	std	Z+9, r25	; 0x09
    a0f6:	80 87       	std	Z+8, r24	; 0x08
    a0f8:	86 e7       	ldi	r24, 0x76	; 118
    a0fa:	9d e0       	ldi	r25, 0x0D	; 13
    a0fc:	93 87       	std	Z+11, r25	; 0x0b
    a0fe:	82 87       	std	Z+10, r24	; 0x0a
    a100:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    _uart_print(1, 0,strSend);
    a104:	ed b7       	in	r30, 0x3d	; 61
    a106:	fe b7       	in	r31, 0x3e	; 62
    a108:	3c 96       	adiw	r30, 0x0c	; 12
    a10a:	0f b6       	in	r0, 0x3f	; 63
    a10c:	f8 94       	cli
    a10e:	fe bf       	out	0x3e, r31	; 62
    a110:	0f be       	out	0x3f, r0	; 63
    a112:	ed bf       	out	0x3d, r30	; 61
    a114:	81 e0       	ldi	r24, 0x01	; 1
    a116:	60 e0       	ldi	r22, 0x00	; 0
    a118:	a8 01       	movw	r20, r16
    a11a:	0e 94 97 b2 	call	0x1652e	; 0x1652e <_uart_print>
	sprintf_P(strSend,PSTR("%s%s"),strRef3,strRef4);
    a11e:	8d b7       	in	r24, 0x3d	; 61
    a120:	9e b7       	in	r25, 0x3e	; 62
    a122:	08 97       	sbiw	r24, 0x08	; 8
    a124:	0f b6       	in	r0, 0x3f	; 63
    a126:	f8 94       	cli
    a128:	9e bf       	out	0x3e, r25	; 62
    a12a:	0f be       	out	0x3f, r0	; 63
    a12c:	8d bf       	out	0x3d, r24	; 61
    a12e:	ed b7       	in	r30, 0x3d	; 61
    a130:	fe b7       	in	r31, 0x3e	; 62
    a132:	31 96       	adiw	r30, 0x01	; 1
    a134:	ad b7       	in	r26, 0x3d	; 61
    a136:	be b7       	in	r27, 0x3e	; 62
    a138:	12 96       	adiw	r26, 0x02	; 2
    a13a:	1c 93       	st	X, r17
    a13c:	0e 93       	st	-X, r16
    a13e:	11 97       	sbiw	r26, 0x01	; 1
    a140:	82 e7       	ldi	r24, 0x72	; 114
    a142:	91 e2       	ldi	r25, 0x21	; 33
    a144:	93 83       	std	Z+3, r25	; 0x03
    a146:	82 83       	std	Z+2, r24	; 0x02
    a148:	82 e8       	ldi	r24, 0x82	; 130
    a14a:	9a e0       	ldi	r25, 0x0A	; 10
    a14c:	95 83       	std	Z+5, r25	; 0x05
    a14e:	84 83       	std	Z+4, r24	; 0x04
    a150:	85 e8       	ldi	r24, 0x85	; 133
    a152:	95 e0       	ldi	r25, 0x05	; 5
    a154:	97 83       	std	Z+7, r25	; 0x07
    a156:	86 83       	std	Z+6, r24	; 0x06
    a158:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    _uart_print(1, 0,strSend);
    a15c:	ed b7       	in	r30, 0x3d	; 61
    a15e:	fe b7       	in	r31, 0x3e	; 62
    a160:	38 96       	adiw	r30, 0x08	; 8
    a162:	0f b6       	in	r0, 0x3f	; 63
    a164:	f8 94       	cli
    a166:	fe bf       	out	0x3e, r31	; 62
    a168:	0f be       	out	0x3f, r0	; 63
    a16a:	ed bf       	out	0x3d, r30	; 61
    a16c:	81 e0       	ldi	r24, 0x01	; 1
    a16e:	60 e0       	ldi	r22, 0x00	; 0
    a170:	a8 01       	movw	r20, r16
    a172:	0e 94 97 b2 	call	0x1652e	; 0x1652e <_uart_print>
	sprintf_P(strSend,PSTR("F968CFFB"));
    a176:	00 d0       	rcall	.+0      	; 0xa178 <sendMessage32+0x164>
    a178:	00 d0       	rcall	.+0      	; 0xa17a <sendMessage32+0x166>
    a17a:	ad b7       	in	r26, 0x3d	; 61
    a17c:	be b7       	in	r27, 0x3e	; 62
    a17e:	12 96       	adiw	r26, 0x02	; 2
    a180:	1c 93       	st	X, r17
    a182:	0e 93       	st	-X, r16
    a184:	11 97       	sbiw	r26, 0x01	; 1
    a186:	89 e6       	ldi	r24, 0x69	; 105
    a188:	91 e2       	ldi	r25, 0x21	; 33
    a18a:	14 96       	adiw	r26, 0x04	; 4
    a18c:	9c 93       	st	X, r25
    a18e:	8e 93       	st	-X, r24
    a190:	13 97       	sbiw	r26, 0x03	; 3
    a192:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    _uart_print(1, 0,strSend);
    a196:	0f 90       	pop	r0
    a198:	0f 90       	pop	r0
    a19a:	0f 90       	pop	r0
    a19c:	0f 90       	pop	r0
    a19e:	81 e0       	ldi	r24, 0x01	; 1
    a1a0:	60 e0       	ldi	r22, 0x00	; 0
    a1a2:	a8 01       	movw	r20, r16
    a1a4:	0e 94 97 b2 	call	0x1652e	; 0x1652e <_uart_print>
	_uart(1, 1,0x02);
    a1a8:	81 e0       	ldi	r24, 0x01	; 1
    a1aa:	61 e0       	ldi	r22, 0x01	; 1
    a1ac:	42 e0       	ldi	r20, 0x02	; 2
    a1ae:	0e 94 7a b2 	call	0x164f4	; 0x164f4 <_uart>

}
    a1b2:	c0 5b       	subi	r28, 0xB0	; 176
    a1b4:	df 4f       	sbci	r29, 0xFF	; 255
    a1b6:	0f b6       	in	r0, 0x3f	; 63
    a1b8:	f8 94       	cli
    a1ba:	de bf       	out	0x3e, r29	; 62
    a1bc:	0f be       	out	0x3f, r0	; 63
    a1be:	cd bf       	out	0x3d, r28	; 61
    a1c0:	cf 91       	pop	r28
    a1c2:	df 91       	pop	r29
    a1c4:	1f 91       	pop	r17
    a1c6:	0f 91       	pop	r16
    a1c8:	08 95       	ret

0000a1ca <sendMessage28>:
	sprintf_P(strSend,PSTR("%s%sF968CFFB"),strCardID,strFIP_ID);
    _uart_print(1, 0,strSend);
	_uart(1, 1,0x02);
}

void sendMessage28(){//Msg28: <01>[0103192.168.016.070192.168.016.18024[FIP][CardID]F968CFFB]<02>
    a1ca:	0f 93       	push	r16
    a1cc:	1f 93       	push	r17
    a1ce:	df 93       	push	r29
    a1d0:	cf 93       	push	r28
    a1d2:	cd b7       	in	r28, 0x3d	; 61
    a1d4:	de b7       	in	r29, 0x3e	; 62
    a1d6:	ec 97       	sbiw	r28, 0x3c	; 60
    a1d8:	0f b6       	in	r0, 0x3f	; 63
    a1da:	f8 94       	cli
    a1dc:	de bf       	out	0x3e, r29	; 62
    a1de:	0f be       	out	0x3f, r0	; 63
    a1e0:	cd bf       	out	0x3d, r28	; 61
	char strSend[60];
	_uart(1, 1,0x01);
    a1e2:	81 e0       	ldi	r24, 0x01	; 1
    a1e4:	61 e0       	ldi	r22, 0x01	; 1
    a1e6:	41 e0       	ldi	r20, 0x01	; 1
    a1e8:	0e 94 7a b2 	call	0x164f4	; 0x164f4 <_uart>
	UpdateIFT_ID(); //ReadIFT_ID
    a1ec:	0e 94 0f 1c 	call	0x381e	; 0x381e <UpdateIFT_ID>
	UpdateSeqNum(); //UpdateSeqNum SeqNum++
    a1f0:	0e 94 e4 1b 	call	0x37c8	; 0x37c8 <UpdateSeqNum>
	UpdateClientIP();//ReadSourceIP
    a1f4:	0e 94 ff 1d 	call	0x3bfe	; 0x3bfe <UpdateClientIP>
	UpdateServerIP();//ReadDestIP
    a1f8:	0e 94 97 1d 	call	0x3b2e	; 0x3b2e <UpdateServerIP>
	sprintf_P(strSend,PSTR("%s%s%s%s28"),strIFT_ID,strSeqNum,strClientIP,strServerIP);
    a1fc:	8d b7       	in	r24, 0x3d	; 61
    a1fe:	9e b7       	in	r25, 0x3e	; 62
    a200:	0c 97       	sbiw	r24, 0x0c	; 12
    a202:	0f b6       	in	r0, 0x3f	; 63
    a204:	f8 94       	cli
    a206:	9e bf       	out	0x3e, r25	; 62
    a208:	0f be       	out	0x3f, r0	; 63
    a20a:	8d bf       	out	0x3d, r24	; 61
    a20c:	ed b7       	in	r30, 0x3d	; 61
    a20e:	fe b7       	in	r31, 0x3e	; 62
    a210:	31 96       	adiw	r30, 0x01	; 1
    a212:	8e 01       	movw	r16, r28
    a214:	0f 5f       	subi	r16, 0xFF	; 255
    a216:	1f 4f       	sbci	r17, 0xFF	; 255
    a218:	ad b7       	in	r26, 0x3d	; 61
    a21a:	be b7       	in	r27, 0x3e	; 62
    a21c:	12 96       	adiw	r26, 0x02	; 2
    a21e:	1c 93       	st	X, r17
    a220:	0e 93       	st	-X, r16
    a222:	11 97       	sbiw	r26, 0x01	; 1
    a224:	88 e9       	ldi	r24, 0x98	; 152
    a226:	91 e2       	ldi	r25, 0x21	; 33
    a228:	93 83       	std	Z+3, r25	; 0x03
    a22a:	82 83       	std	Z+2, r24	; 0x02
    a22c:	8c ec       	ldi	r24, 0xCC	; 204
    a22e:	95 e0       	ldi	r25, 0x05	; 5
    a230:	95 83       	std	Z+5, r25	; 0x05
    a232:	84 83       	std	Z+4, r24	; 0x04
    a234:	8b ea       	ldi	r24, 0xAB	; 171
    a236:	9d e0       	ldi	r25, 0x0D	; 13
    a238:	97 83       	std	Z+7, r25	; 0x07
    a23a:	86 83       	std	Z+6, r24	; 0x06
    a23c:	8e eb       	ldi	r24, 0xBE	; 190
    a23e:	99 e0       	ldi	r25, 0x09	; 9
    a240:	91 87       	std	Z+9, r25	; 0x09
    a242:	80 87       	std	Z+8, r24	; 0x08
    a244:	8b ee       	ldi	r24, 0xEB	; 235
    a246:	99 e0       	ldi	r25, 0x09	; 9
    a248:	93 87       	std	Z+11, r25	; 0x0b
    a24a:	82 87       	std	Z+10, r24	; 0x0a
    a24c:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    _uart_print(1, 0,strSend);
    a250:	8d b7       	in	r24, 0x3d	; 61
    a252:	9e b7       	in	r25, 0x3e	; 62
    a254:	0c 96       	adiw	r24, 0x0c	; 12
    a256:	0f b6       	in	r0, 0x3f	; 63
    a258:	f8 94       	cli
    a25a:	9e bf       	out	0x3e, r25	; 62
    a25c:	0f be       	out	0x3f, r0	; 63
    a25e:	8d bf       	out	0x3d, r24	; 61
    a260:	81 e0       	ldi	r24, 0x01	; 1
    a262:	60 e0       	ldi	r22, 0x00	; 0
    a264:	a8 01       	movw	r20, r16
    a266:	0e 94 97 b2 	call	0x1652e	; 0x1652e <_uart_print>
	UpdateCardID();
    a26a:	0e 94 ed 3c 	call	0x79da	; 0x79da <UpdateCardID>
	sprintf_P(strSend,PSTR("%s%sF968CFFB"),strFIP_ID,strCardID);
    a26e:	ad b7       	in	r26, 0x3d	; 61
    a270:	be b7       	in	r27, 0x3e	; 62
    a272:	18 97       	sbiw	r26, 0x08	; 8
    a274:	0f b6       	in	r0, 0x3f	; 63
    a276:	f8 94       	cli
    a278:	be bf       	out	0x3e, r27	; 62
    a27a:	0f be       	out	0x3f, r0	; 63
    a27c:	ad bf       	out	0x3d, r26	; 61
    a27e:	ed b7       	in	r30, 0x3d	; 61
    a280:	fe b7       	in	r31, 0x3e	; 62
    a282:	31 96       	adiw	r30, 0x01	; 1
    a284:	12 96       	adiw	r26, 0x02	; 2
    a286:	1c 93       	st	X, r17
    a288:	0e 93       	st	-X, r16
    a28a:	11 97       	sbiw	r26, 0x01	; 1
    a28c:	8b e8       	ldi	r24, 0x8B	; 139
    a28e:	91 e2       	ldi	r25, 0x21	; 33
    a290:	93 83       	std	Z+3, r25	; 0x03
    a292:	82 83       	std	Z+2, r24	; 0x02
    a294:	8c e9       	ldi	r24, 0x9C	; 156
    a296:	99 e0       	ldi	r25, 0x09	; 9
    a298:	95 83       	std	Z+5, r25	; 0x05
    a29a:	84 83       	std	Z+4, r24	; 0x04
    a29c:	81 e6       	ldi	r24, 0x61	; 97
    a29e:	9d e0       	ldi	r25, 0x0D	; 13
    a2a0:	97 83       	std	Z+7, r25	; 0x07
    a2a2:	86 83       	std	Z+6, r24	; 0x06
    a2a4:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    _uart_print(1, 0,strSend);
    a2a8:	8d b7       	in	r24, 0x3d	; 61
    a2aa:	9e b7       	in	r25, 0x3e	; 62
    a2ac:	08 96       	adiw	r24, 0x08	; 8
    a2ae:	0f b6       	in	r0, 0x3f	; 63
    a2b0:	f8 94       	cli
    a2b2:	9e bf       	out	0x3e, r25	; 62
    a2b4:	0f be       	out	0x3f, r0	; 63
    a2b6:	8d bf       	out	0x3d, r24	; 61
    a2b8:	81 e0       	ldi	r24, 0x01	; 1
    a2ba:	60 e0       	ldi	r22, 0x00	; 0
    a2bc:	a8 01       	movw	r20, r16
    a2be:	0e 94 97 b2 	call	0x1652e	; 0x1652e <_uart_print>
	_uart(1, 1,0x02);
    a2c2:	81 e0       	ldi	r24, 0x01	; 1
    a2c4:	61 e0       	ldi	r22, 0x01	; 1
    a2c6:	42 e0       	ldi	r20, 0x02	; 2
    a2c8:	0e 94 7a b2 	call	0x164f4	; 0x164f4 <_uart>
}
    a2cc:	ec 96       	adiw	r28, 0x3c	; 60
    a2ce:	0f b6       	in	r0, 0x3f	; 63
    a2d0:	f8 94       	cli
    a2d2:	de bf       	out	0x3e, r29	; 62
    a2d4:	0f be       	out	0x3f, r0	; 63
    a2d6:	cd bf       	out	0x3d, r28	; 61
    a2d8:	cf 91       	pop	r28
    a2da:	df 91       	pop	r29
    a2dc:	1f 91       	pop	r17
    a2de:	0f 91       	pop	r16
    a2e0:	08 95       	ret

0000a2e2 <sendMessage24>:
	sprintf_P(strSend,PSTR("%sF968CFFB"),strCardID);
    _uart_print(1, 0,strSend);
	_uart(1, 1,0x02);
}

void sendMessage24(){//Msg24: <01>[0103192.168.016.070192.168.016.18022[CardID]F968CFFB]<02>
    a2e2:	0f 93       	push	r16
    a2e4:	1f 93       	push	r17
    a2e6:	df 93       	push	r29
    a2e8:	cf 93       	push	r28
    a2ea:	cd b7       	in	r28, 0x3d	; 61
    a2ec:	de b7       	in	r29, 0x3e	; 62
    a2ee:	ec 97       	sbiw	r28, 0x3c	; 60
    a2f0:	0f b6       	in	r0, 0x3f	; 63
    a2f2:	f8 94       	cli
    a2f4:	de bf       	out	0x3e, r29	; 62
    a2f6:	0f be       	out	0x3f, r0	; 63
    a2f8:	cd bf       	out	0x3d, r28	; 61
	char strSend[60];
	_uart(1, 1,0x01);
    a2fa:	81 e0       	ldi	r24, 0x01	; 1
    a2fc:	61 e0       	ldi	r22, 0x01	; 1
    a2fe:	41 e0       	ldi	r20, 0x01	; 1
    a300:	0e 94 7a b2 	call	0x164f4	; 0x164f4 <_uart>
	UpdateIFT_ID(); //ReadIFT_ID
    a304:	0e 94 0f 1c 	call	0x381e	; 0x381e <UpdateIFT_ID>
	UpdateSeqNum(); //UpdateSeqNum SeqNum++
    a308:	0e 94 e4 1b 	call	0x37c8	; 0x37c8 <UpdateSeqNum>
	UpdateClientIP();//ReadSourceIP
    a30c:	0e 94 ff 1d 	call	0x3bfe	; 0x3bfe <UpdateClientIP>
	UpdateServerIP();//ReadDestIP
    a310:	0e 94 97 1d 	call	0x3b2e	; 0x3b2e <UpdateServerIP>
	sprintf_P(strSend,PSTR("%s%s%s%s24"),strIFT_ID,strSeqNum,strClientIP,strServerIP);
    a314:	8d b7       	in	r24, 0x3d	; 61
    a316:	9e b7       	in	r25, 0x3e	; 62
    a318:	0c 97       	sbiw	r24, 0x0c	; 12
    a31a:	0f b6       	in	r0, 0x3f	; 63
    a31c:	f8 94       	cli
    a31e:	9e bf       	out	0x3e, r25	; 62
    a320:	0f be       	out	0x3f, r0	; 63
    a322:	8d bf       	out	0x3d, r24	; 61
    a324:	ed b7       	in	r30, 0x3d	; 61
    a326:	fe b7       	in	r31, 0x3e	; 62
    a328:	31 96       	adiw	r30, 0x01	; 1
    a32a:	8e 01       	movw	r16, r28
    a32c:	0f 5f       	subi	r16, 0xFF	; 255
    a32e:	1f 4f       	sbci	r17, 0xFF	; 255
    a330:	ad b7       	in	r26, 0x3d	; 61
    a332:	be b7       	in	r27, 0x3e	; 62
    a334:	12 96       	adiw	r26, 0x02	; 2
    a336:	1c 93       	st	X, r17
    a338:	0e 93       	st	-X, r16
    a33a:	11 97       	sbiw	r26, 0x01	; 1
    a33c:	80 eb       	ldi	r24, 0xB0	; 176
    a33e:	91 e2       	ldi	r25, 0x21	; 33
    a340:	93 83       	std	Z+3, r25	; 0x03
    a342:	82 83       	std	Z+2, r24	; 0x02
    a344:	8c ec       	ldi	r24, 0xCC	; 204
    a346:	95 e0       	ldi	r25, 0x05	; 5
    a348:	95 83       	std	Z+5, r25	; 0x05
    a34a:	84 83       	std	Z+4, r24	; 0x04
    a34c:	8b ea       	ldi	r24, 0xAB	; 171
    a34e:	9d e0       	ldi	r25, 0x0D	; 13
    a350:	97 83       	std	Z+7, r25	; 0x07
    a352:	86 83       	std	Z+6, r24	; 0x06
    a354:	8e eb       	ldi	r24, 0xBE	; 190
    a356:	99 e0       	ldi	r25, 0x09	; 9
    a358:	91 87       	std	Z+9, r25	; 0x09
    a35a:	80 87       	std	Z+8, r24	; 0x08
    a35c:	8b ee       	ldi	r24, 0xEB	; 235
    a35e:	99 e0       	ldi	r25, 0x09	; 9
    a360:	93 87       	std	Z+11, r25	; 0x0b
    a362:	82 87       	std	Z+10, r24	; 0x0a
    a364:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    _uart_print(1, 0,strSend);
    a368:	8d b7       	in	r24, 0x3d	; 61
    a36a:	9e b7       	in	r25, 0x3e	; 62
    a36c:	0c 96       	adiw	r24, 0x0c	; 12
    a36e:	0f b6       	in	r0, 0x3f	; 63
    a370:	f8 94       	cli
    a372:	9e bf       	out	0x3e, r25	; 62
    a374:	0f be       	out	0x3f, r0	; 63
    a376:	8d bf       	out	0x3d, r24	; 61
    a378:	81 e0       	ldi	r24, 0x01	; 1
    a37a:	60 e0       	ldi	r22, 0x00	; 0
    a37c:	a8 01       	movw	r20, r16
    a37e:	0e 94 97 b2 	call	0x1652e	; 0x1652e <_uart_print>
	UpdateCardID();
    a382:	0e 94 ed 3c 	call	0x79da	; 0x79da <UpdateCardID>
	sprintf_P(strSend,PSTR("%s%sF968CFFB"),strCardID,strFIP_ID);
    a386:	ad b7       	in	r26, 0x3d	; 61
    a388:	be b7       	in	r27, 0x3e	; 62
    a38a:	18 97       	sbiw	r26, 0x08	; 8
    a38c:	0f b6       	in	r0, 0x3f	; 63
    a38e:	f8 94       	cli
    a390:	be bf       	out	0x3e, r27	; 62
    a392:	0f be       	out	0x3f, r0	; 63
    a394:	ad bf       	out	0x3d, r26	; 61
    a396:	ed b7       	in	r30, 0x3d	; 61
    a398:	fe b7       	in	r31, 0x3e	; 62
    a39a:	31 96       	adiw	r30, 0x01	; 1
    a39c:	12 96       	adiw	r26, 0x02	; 2
    a39e:	1c 93       	st	X, r17
    a3a0:	0e 93       	st	-X, r16
    a3a2:	11 97       	sbiw	r26, 0x01	; 1
    a3a4:	83 ea       	ldi	r24, 0xA3	; 163
    a3a6:	91 e2       	ldi	r25, 0x21	; 33
    a3a8:	93 83       	std	Z+3, r25	; 0x03
    a3aa:	82 83       	std	Z+2, r24	; 0x02
    a3ac:	81 e6       	ldi	r24, 0x61	; 97
    a3ae:	9d e0       	ldi	r25, 0x0D	; 13
    a3b0:	95 83       	std	Z+5, r25	; 0x05
    a3b2:	84 83       	std	Z+4, r24	; 0x04
    a3b4:	8c e9       	ldi	r24, 0x9C	; 156
    a3b6:	99 e0       	ldi	r25, 0x09	; 9
    a3b8:	97 83       	std	Z+7, r25	; 0x07
    a3ba:	86 83       	std	Z+6, r24	; 0x06
    a3bc:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    _uart_print(1, 0,strSend);
    a3c0:	8d b7       	in	r24, 0x3d	; 61
    a3c2:	9e b7       	in	r25, 0x3e	; 62
    a3c4:	08 96       	adiw	r24, 0x08	; 8
    a3c6:	0f b6       	in	r0, 0x3f	; 63
    a3c8:	f8 94       	cli
    a3ca:	9e bf       	out	0x3e, r25	; 62
    a3cc:	0f be       	out	0x3f, r0	; 63
    a3ce:	8d bf       	out	0x3d, r24	; 61
    a3d0:	81 e0       	ldi	r24, 0x01	; 1
    a3d2:	60 e0       	ldi	r22, 0x00	; 0
    a3d4:	a8 01       	movw	r20, r16
    a3d6:	0e 94 97 b2 	call	0x1652e	; 0x1652e <_uart_print>
	_uart(1, 1,0x02);
    a3da:	81 e0       	ldi	r24, 0x01	; 1
    a3dc:	61 e0       	ldi	r22, 0x01	; 1
    a3de:	42 e0       	ldi	r20, 0x02	; 2
    a3e0:	0e 94 7a b2 	call	0x164f4	; 0x164f4 <_uart>
}
    a3e4:	ec 96       	adiw	r28, 0x3c	; 60
    a3e6:	0f b6       	in	r0, 0x3f	; 63
    a3e8:	f8 94       	cli
    a3ea:	de bf       	out	0x3e, r29	; 62
    a3ec:	0f be       	out	0x3f, r0	; 63
    a3ee:	cd bf       	out	0x3d, r28	; 61
    a3f0:	cf 91       	pop	r28
    a3f2:	df 91       	pop	r29
    a3f4:	1f 91       	pop	r17
    a3f6:	0f 91       	pop	r16
    a3f8:	08 95       	ret

0000a3fa <sendMessage22>:
    _uart_print(1, 0,strSend);
	_uart(1, 1,0x02);
	IsNewPacket=True;
}

void sendMessage22(){//Msg22: <01>[0103192.168.016.070192.168.016.18022[CardID]F968CFFB]<02>
    a3fa:	0f 93       	push	r16
    a3fc:	1f 93       	push	r17
    a3fe:	df 93       	push	r29
    a400:	cf 93       	push	r28
    a402:	cd b7       	in	r28, 0x3d	; 61
    a404:	de b7       	in	r29, 0x3e	; 62
    a406:	ec 97       	sbiw	r28, 0x3c	; 60
    a408:	0f b6       	in	r0, 0x3f	; 63
    a40a:	f8 94       	cli
    a40c:	de bf       	out	0x3e, r29	; 62
    a40e:	0f be       	out	0x3f, r0	; 63
    a410:	cd bf       	out	0x3d, r28	; 61
	char strSend[60];
	_uart(1, 1,0x01);
    a412:	81 e0       	ldi	r24, 0x01	; 1
    a414:	61 e0       	ldi	r22, 0x01	; 1
    a416:	41 e0       	ldi	r20, 0x01	; 1
    a418:	0e 94 7a b2 	call	0x164f4	; 0x164f4 <_uart>
	UpdateIFT_ID(); //ReadIFT_ID
    a41c:	0e 94 0f 1c 	call	0x381e	; 0x381e <UpdateIFT_ID>
	UpdateSeqNum(); //UpdateSeqNum SeqNum++
    a420:	0e 94 e4 1b 	call	0x37c8	; 0x37c8 <UpdateSeqNum>
	UpdateClientIP();//ReadSourceIP
    a424:	0e 94 ff 1d 	call	0x3bfe	; 0x3bfe <UpdateClientIP>
	UpdateServerIP();//ReadDestIP
    a428:	0e 94 97 1d 	call	0x3b2e	; 0x3b2e <UpdateServerIP>
	sprintf_P(strSend,PSTR("%s%s%s%s22"),strIFT_ID,strSeqNum,strClientIP,strServerIP);
    a42c:	8d b7       	in	r24, 0x3d	; 61
    a42e:	9e b7       	in	r25, 0x3e	; 62
    a430:	0c 97       	sbiw	r24, 0x0c	; 12
    a432:	0f b6       	in	r0, 0x3f	; 63
    a434:	f8 94       	cli
    a436:	9e bf       	out	0x3e, r25	; 62
    a438:	0f be       	out	0x3f, r0	; 63
    a43a:	8d bf       	out	0x3d, r24	; 61
    a43c:	ed b7       	in	r30, 0x3d	; 61
    a43e:	fe b7       	in	r31, 0x3e	; 62
    a440:	31 96       	adiw	r30, 0x01	; 1
    a442:	8e 01       	movw	r16, r28
    a444:	0f 5f       	subi	r16, 0xFF	; 255
    a446:	1f 4f       	sbci	r17, 0xFF	; 255
    a448:	ad b7       	in	r26, 0x3d	; 61
    a44a:	be b7       	in	r27, 0x3e	; 62
    a44c:	12 96       	adiw	r26, 0x02	; 2
    a44e:	1c 93       	st	X, r17
    a450:	0e 93       	st	-X, r16
    a452:	11 97       	sbiw	r26, 0x01	; 1
    a454:	86 ec       	ldi	r24, 0xC6	; 198
    a456:	91 e2       	ldi	r25, 0x21	; 33
    a458:	93 83       	std	Z+3, r25	; 0x03
    a45a:	82 83       	std	Z+2, r24	; 0x02
    a45c:	8c ec       	ldi	r24, 0xCC	; 204
    a45e:	95 e0       	ldi	r25, 0x05	; 5
    a460:	95 83       	std	Z+5, r25	; 0x05
    a462:	84 83       	std	Z+4, r24	; 0x04
    a464:	8b ea       	ldi	r24, 0xAB	; 171
    a466:	9d e0       	ldi	r25, 0x0D	; 13
    a468:	97 83       	std	Z+7, r25	; 0x07
    a46a:	86 83       	std	Z+6, r24	; 0x06
    a46c:	8e eb       	ldi	r24, 0xBE	; 190
    a46e:	99 e0       	ldi	r25, 0x09	; 9
    a470:	91 87       	std	Z+9, r25	; 0x09
    a472:	80 87       	std	Z+8, r24	; 0x08
    a474:	8b ee       	ldi	r24, 0xEB	; 235
    a476:	99 e0       	ldi	r25, 0x09	; 9
    a478:	93 87       	std	Z+11, r25	; 0x0b
    a47a:	82 87       	std	Z+10, r24	; 0x0a
    a47c:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    _uart_print(1, 0,strSend);
    a480:	8d b7       	in	r24, 0x3d	; 61
    a482:	9e b7       	in	r25, 0x3e	; 62
    a484:	0c 96       	adiw	r24, 0x0c	; 12
    a486:	0f b6       	in	r0, 0x3f	; 63
    a488:	f8 94       	cli
    a48a:	9e bf       	out	0x3e, r25	; 62
    a48c:	0f be       	out	0x3f, r0	; 63
    a48e:	8d bf       	out	0x3d, r24	; 61
    a490:	81 e0       	ldi	r24, 0x01	; 1
    a492:	60 e0       	ldi	r22, 0x00	; 0
    a494:	a8 01       	movw	r20, r16
    a496:	0e 94 97 b2 	call	0x1652e	; 0x1652e <_uart_print>
	UpdateCardID();
    a49a:	0e 94 ed 3c 	call	0x79da	; 0x79da <UpdateCardID>
	sprintf_P(strSend,PSTR("%sF968CFFB"),strCardID);
    a49e:	00 d0       	rcall	.+0      	; 0xa4a0 <sendMessage22+0xa6>
    a4a0:	00 d0       	rcall	.+0      	; 0xa4a2 <sendMessage22+0xa8>
    a4a2:	00 d0       	rcall	.+0      	; 0xa4a4 <sendMessage22+0xaa>
    a4a4:	ed b7       	in	r30, 0x3d	; 61
    a4a6:	fe b7       	in	r31, 0x3e	; 62
    a4a8:	31 96       	adiw	r30, 0x01	; 1
    a4aa:	ad b7       	in	r26, 0x3d	; 61
    a4ac:	be b7       	in	r27, 0x3e	; 62
    a4ae:	12 96       	adiw	r26, 0x02	; 2
    a4b0:	1c 93       	st	X, r17
    a4b2:	0e 93       	st	-X, r16
    a4b4:	11 97       	sbiw	r26, 0x01	; 1
    a4b6:	8b eb       	ldi	r24, 0xBB	; 187
    a4b8:	91 e2       	ldi	r25, 0x21	; 33
    a4ba:	93 83       	std	Z+3, r25	; 0x03
    a4bc:	82 83       	std	Z+2, r24	; 0x02
    a4be:	81 e6       	ldi	r24, 0x61	; 97
    a4c0:	9d e0       	ldi	r25, 0x0D	; 13
    a4c2:	95 83       	std	Z+5, r25	; 0x05
    a4c4:	84 83       	std	Z+4, r24	; 0x04
    a4c6:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    _uart_print(1, 0,strSend);
    a4ca:	8d b7       	in	r24, 0x3d	; 61
    a4cc:	9e b7       	in	r25, 0x3e	; 62
    a4ce:	06 96       	adiw	r24, 0x06	; 6
    a4d0:	0f b6       	in	r0, 0x3f	; 63
    a4d2:	f8 94       	cli
    a4d4:	9e bf       	out	0x3e, r25	; 62
    a4d6:	0f be       	out	0x3f, r0	; 63
    a4d8:	8d bf       	out	0x3d, r24	; 61
    a4da:	81 e0       	ldi	r24, 0x01	; 1
    a4dc:	60 e0       	ldi	r22, 0x00	; 0
    a4de:	a8 01       	movw	r20, r16
    a4e0:	0e 94 97 b2 	call	0x1652e	; 0x1652e <_uart_print>
	_uart(1, 1,0x02);
    a4e4:	81 e0       	ldi	r24, 0x01	; 1
    a4e6:	61 e0       	ldi	r22, 0x01	; 1
    a4e8:	42 e0       	ldi	r20, 0x02	; 2
    a4ea:	0e 94 7a b2 	call	0x164f4	; 0x164f4 <_uart>
}
    a4ee:	ec 96       	adiw	r28, 0x3c	; 60
    a4f0:	0f b6       	in	r0, 0x3f	; 63
    a4f2:	f8 94       	cli
    a4f4:	de bf       	out	0x3e, r29	; 62
    a4f6:	0f be       	out	0x3f, r0	; 63
    a4f8:	cd bf       	out	0x3d, r28	; 61
    a4fa:	cf 91       	pop	r28
    a4fc:	df 91       	pop	r29
    a4fe:	1f 91       	pop	r17
    a500:	0f 91       	pop	r16
    a502:	08 95       	ret

0000a504 <sendMessage10>:
     _uart_print(1, 0,strSend);
	 _uart(1, 1,0x02);
}

/*Subrutine Msg10*/
void sendMessage10(){//Msg10: <01>[0103192.168.016.070192.168.016.18010F968CFFB]<02>
    a504:	0f 93       	push	r16
    a506:	1f 93       	push	r17
    a508:	df 93       	push	r29
    a50a:	cf 93       	push	r28
    a50c:	cd b7       	in	r28, 0x3d	; 61
    a50e:	de b7       	in	r29, 0x3e	; 62
    a510:	ec 97       	sbiw	r28, 0x3c	; 60
    a512:	0f b6       	in	r0, 0x3f	; 63
    a514:	f8 94       	cli
    a516:	de bf       	out	0x3e, r29	; 62
    a518:	0f be       	out	0x3f, r0	; 63
    a51a:	cd bf       	out	0x3d, r28	; 61
	char strSend[60];
	_uart(1, 1,0x01);
    a51c:	81 e0       	ldi	r24, 0x01	; 1
    a51e:	61 e0       	ldi	r22, 0x01	; 1
    a520:	41 e0       	ldi	r20, 0x01	; 1
    a522:	0e 94 7a b2 	call	0x164f4	; 0x164f4 <_uart>
	UpdateIFT_ID(); //ReadIFT_ID
    a526:	0e 94 0f 1c 	call	0x381e	; 0x381e <UpdateIFT_ID>
	UpdateSeqNum(); //UpdateSeqNum SeqNum++
    a52a:	0e 94 e4 1b 	call	0x37c8	; 0x37c8 <UpdateSeqNum>
	UpdateClientIP();//ReadSourceIP
    a52e:	0e 94 ff 1d 	call	0x3bfe	; 0x3bfe <UpdateClientIP>
	UpdateServerIP();//ReadDestIP
    a532:	0e 94 97 1d 	call	0x3b2e	; 0x3b2e <UpdateServerIP>
	sprintf_P(strSend,PSTR("%s%s%s%s10F968CFFB"),strIFT_ID,strSeqNum,strClientIP,strServerIP);
    a536:	8d b7       	in	r24, 0x3d	; 61
    a538:	9e b7       	in	r25, 0x3e	; 62
    a53a:	0c 97       	sbiw	r24, 0x0c	; 12
    a53c:	0f b6       	in	r0, 0x3f	; 63
    a53e:	f8 94       	cli
    a540:	9e bf       	out	0x3e, r25	; 62
    a542:	0f be       	out	0x3f, r0	; 63
    a544:	8d bf       	out	0x3d, r24	; 61
    a546:	ed b7       	in	r30, 0x3d	; 61
    a548:	fe b7       	in	r31, 0x3e	; 62
    a54a:	31 96       	adiw	r30, 0x01	; 1
    a54c:	8e 01       	movw	r16, r28
    a54e:	0f 5f       	subi	r16, 0xFF	; 255
    a550:	1f 4f       	sbci	r17, 0xFF	; 255
    a552:	ad b7       	in	r26, 0x3d	; 61
    a554:	be b7       	in	r27, 0x3e	; 62
    a556:	12 96       	adiw	r26, 0x02	; 2
    a558:	1c 93       	st	X, r17
    a55a:	0e 93       	st	-X, r16
    a55c:	11 97       	sbiw	r26, 0x01	; 1
    a55e:	81 ed       	ldi	r24, 0xD1	; 209
    a560:	91 e2       	ldi	r25, 0x21	; 33
    a562:	93 83       	std	Z+3, r25	; 0x03
    a564:	82 83       	std	Z+2, r24	; 0x02
    a566:	8c ec       	ldi	r24, 0xCC	; 204
    a568:	95 e0       	ldi	r25, 0x05	; 5
    a56a:	95 83       	std	Z+5, r25	; 0x05
    a56c:	84 83       	std	Z+4, r24	; 0x04
    a56e:	8b ea       	ldi	r24, 0xAB	; 171
    a570:	9d e0       	ldi	r25, 0x0D	; 13
    a572:	97 83       	std	Z+7, r25	; 0x07
    a574:	86 83       	std	Z+6, r24	; 0x06
    a576:	8e eb       	ldi	r24, 0xBE	; 190
    a578:	99 e0       	ldi	r25, 0x09	; 9
    a57a:	91 87       	std	Z+9, r25	; 0x09
    a57c:	80 87       	std	Z+8, r24	; 0x08
    a57e:	8b ee       	ldi	r24, 0xEB	; 235
    a580:	99 e0       	ldi	r25, 0x09	; 9
    a582:	93 87       	std	Z+11, r25	; 0x0b
    a584:	82 87       	std	Z+10, r24	; 0x0a
    a586:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    _uart_print(1, 0,strSend);
    a58a:	8d b7       	in	r24, 0x3d	; 61
    a58c:	9e b7       	in	r25, 0x3e	; 62
    a58e:	0c 96       	adiw	r24, 0x0c	; 12
    a590:	0f b6       	in	r0, 0x3f	; 63
    a592:	f8 94       	cli
    a594:	9e bf       	out	0x3e, r25	; 62
    a596:	0f be       	out	0x3f, r0	; 63
    a598:	8d bf       	out	0x3d, r24	; 61
    a59a:	81 e0       	ldi	r24, 0x01	; 1
    a59c:	60 e0       	ldi	r22, 0x00	; 0
    a59e:	a8 01       	movw	r20, r16
    a5a0:	0e 94 97 b2 	call	0x1652e	; 0x1652e <_uart_print>
	_uart(1, 1,0x02);
    a5a4:	81 e0       	ldi	r24, 0x01	; 1
    a5a6:	61 e0       	ldi	r22, 0x01	; 1
    a5a8:	42 e0       	ldi	r20, 0x02	; 2
    a5aa:	0e 94 7a b2 	call	0x164f4	; 0x164f4 <_uart>
	IsNewPacket=True;
    a5ae:	81 e0       	ldi	r24, 0x01	; 1
    a5b0:	80 93 9b 01 	sts	0x019B, r24
}
    a5b4:	ec 96       	adiw	r28, 0x3c	; 60
    a5b6:	0f b6       	in	r0, 0x3f	; 63
    a5b8:	f8 94       	cli
    a5ba:	de bf       	out	0x3e, r29	; 62
    a5bc:	0f be       	out	0x3f, r0	; 63
    a5be:	cd bf       	out	0x3d, r28	; 61
    a5c0:	cf 91       	pop	r28
    a5c2:	df 91       	pop	r29
    a5c4:	1f 91       	pop	r17
    a5c6:	0f 91       	pop	r16
    a5c8:	08 95       	ret

0000a5ca <sendMessage04>:
	 }
		 sprintf_P(strServerIP,PSTR("%s.%s.%s.%s"),strIP[0],strIP[1],strIP[2],strIP[3]);
}

/*Subrutine Msg04*/
void sendMessage04(){   //      <STX>[IFTID][Seq][No][SrceIP][DestIP][MsgCode][ReceiptNo][Value][Checksum][ETX]
    a5ca:	0f 93       	push	r16
    a5cc:	1f 93       	push	r17
    a5ce:	df 93       	push	r29
    a5d0:	cf 93       	push	r28
    a5d2:	cd b7       	in	r28, 0x3d	; 61
    a5d4:	de b7       	in	r29, 0x3e	; 62
    a5d6:	ec 97       	sbiw	r28, 0x3c	; 60
    a5d8:	0f b6       	in	r0, 0x3f	; 63
    a5da:	f8 94       	cli
    a5dc:	de bf       	out	0x3e, r29	; 62
    a5de:	0f be       	out	0x3f, r0	; 63
    a5e0:	cd bf       	out	0x3d, r28	; 61
                        //Msg04: <01>[01][03][192.168.000.101][192.168.000.001][04][000001]0F968CFFB]<02>
	 char strSend[60];
	 _uart(1, 1,0x01);
    a5e2:	81 e0       	ldi	r24, 0x01	; 1
    a5e4:	61 e0       	ldi	r22, 0x01	; 1
    a5e6:	41 e0       	ldi	r20, 0x01	; 1
    a5e8:	0e 94 7a b2 	call	0x164f4	; 0x164f4 <_uart>
	 UpdateIFT_ID(); //ReadIFT_ID
    a5ec:	0e 94 0f 1c 	call	0x381e	; 0x381e <UpdateIFT_ID>
	 UpdateSeqNum(); //UpdateSeqNum SeqNum++
    a5f0:	0e 94 e4 1b 	call	0x37c8	; 0x37c8 <UpdateSeqNum>
	 UpdateClientIP();//ReadSourceIP
    a5f4:	0e 94 ff 1d 	call	0x3bfe	; 0x3bfe <UpdateClientIP>
	 UpdateServerIP();//ReadDestIP
    a5f8:	0e 94 97 1d 	call	0x3b2e	; 0x3b2e <UpdateServerIP>
	 //strTranNo = strReceiptNum
	 sprintf_P(strSend,PSTR("%s%s%s%s04%s1F968CFFB"),strIFT_ID,strSeqNum,strClientIP,strServerIP,strTranNo);
    a5fc:	8d b7       	in	r24, 0x3d	; 61
    a5fe:	9e b7       	in	r25, 0x3e	; 62
    a600:	0e 97       	sbiw	r24, 0x0e	; 14
    a602:	0f b6       	in	r0, 0x3f	; 63
    a604:	f8 94       	cli
    a606:	9e bf       	out	0x3e, r25	; 62
    a608:	0f be       	out	0x3f, r0	; 63
    a60a:	8d bf       	out	0x3d, r24	; 61
    a60c:	ed b7       	in	r30, 0x3d	; 61
    a60e:	fe b7       	in	r31, 0x3e	; 62
    a610:	31 96       	adiw	r30, 0x01	; 1
    a612:	8e 01       	movw	r16, r28
    a614:	0f 5f       	subi	r16, 0xFF	; 255
    a616:	1f 4f       	sbci	r17, 0xFF	; 255
    a618:	ad b7       	in	r26, 0x3d	; 61
    a61a:	be b7       	in	r27, 0x3e	; 62
    a61c:	12 96       	adiw	r26, 0x02	; 2
    a61e:	1c 93       	st	X, r17
    a620:	0e 93       	st	-X, r16
    a622:	11 97       	sbiw	r26, 0x01	; 1
    a624:	84 ee       	ldi	r24, 0xE4	; 228
    a626:	91 e2       	ldi	r25, 0x21	; 33
    a628:	93 83       	std	Z+3, r25	; 0x03
    a62a:	82 83       	std	Z+2, r24	; 0x02
    a62c:	8c ec       	ldi	r24, 0xCC	; 204
    a62e:	95 e0       	ldi	r25, 0x05	; 5
    a630:	95 83       	std	Z+5, r25	; 0x05
    a632:	84 83       	std	Z+4, r24	; 0x04
    a634:	8b ea       	ldi	r24, 0xAB	; 171
    a636:	9d e0       	ldi	r25, 0x0D	; 13
    a638:	97 83       	std	Z+7, r25	; 0x07
    a63a:	86 83       	std	Z+6, r24	; 0x06
    a63c:	8e eb       	ldi	r24, 0xBE	; 190
    a63e:	99 e0       	ldi	r25, 0x09	; 9
    a640:	91 87       	std	Z+9, r25	; 0x09
    a642:	80 87       	std	Z+8, r24	; 0x08
    a644:	8b ee       	ldi	r24, 0xEB	; 235
    a646:	99 e0       	ldi	r25, 0x09	; 9
    a648:	93 87       	std	Z+11, r25	; 0x0b
    a64a:	82 87       	std	Z+10, r24	; 0x0a
    a64c:	81 e6       	ldi	r24, 0x61	; 97
    a64e:	9e e0       	ldi	r25, 0x0E	; 14
    a650:	95 87       	std	Z+13, r25	; 0x0d
    a652:	84 87       	std	Z+12, r24	; 0x0c
    a654:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
     _uart_print(1, 0,strSend);
    a658:	8d b7       	in	r24, 0x3d	; 61
    a65a:	9e b7       	in	r25, 0x3e	; 62
    a65c:	0e 96       	adiw	r24, 0x0e	; 14
    a65e:	0f b6       	in	r0, 0x3f	; 63
    a660:	f8 94       	cli
    a662:	9e bf       	out	0x3e, r25	; 62
    a664:	0f be       	out	0x3f, r0	; 63
    a666:	8d bf       	out	0x3d, r24	; 61
    a668:	81 e0       	ldi	r24, 0x01	; 1
    a66a:	60 e0       	ldi	r22, 0x00	; 0
    a66c:	a8 01       	movw	r20, r16
    a66e:	0e 94 97 b2 	call	0x1652e	; 0x1652e <_uart_print>
	 _uart(1, 1,0x02);
    a672:	81 e0       	ldi	r24, 0x01	; 1
    a674:	61 e0       	ldi	r22, 0x01	; 1
    a676:	42 e0       	ldi	r20, 0x02	; 2
    a678:	0e 94 7a b2 	call	0x164f4	; 0x164f4 <_uart>
}
    a67c:	ec 96       	adiw	r28, 0x3c	; 60
    a67e:	0f b6       	in	r0, 0x3f	; 63
    a680:	f8 94       	cli
    a682:	de bf       	out	0x3e, r29	; 62
    a684:	0f be       	out	0x3f, r0	; 63
    a686:	cd bf       	out	0x3d, r28	; 61
    a688:	cf 91       	pop	r28
    a68a:	df 91       	pop	r29
    a68c:	1f 91       	pop	r17
    a68e:	0f 91       	pop	r16
    a690:	08 95       	ret

0000a692 <FreePrinting>:
	 } 
	 else _uart(_COM_PRINTER,1,xSend);
	 zSend=xSend;
}

void FreePrinting(){
    a692:	0f 93       	push	r16
    a694:	1f 93       	push	r17
static char iPrinted=0,iHeader=0,iFooter=0,PrintCopy=0,iMargin=0,iScroll=0,nScroll=0;
static char strHeader[41];
static unsigned int iSend=0,LSend=0,iLoop=0;

     //Normalize FreePrintIdleState
     if ((IsFreePrinting==True)&&(stFreePrinting!=fpInit)){
    a696:	20 91 bf 01 	lds	r18, 0x01BF
    a69a:	21 30       	cpi	r18, 0x01	; 1
    a69c:	31 f4       	brne	.+12     	; 0xa6aa <FreePrinting+0x18>
    a69e:	80 91 25 01 	lds	r24, 0x0125
    a6a2:	81 30       	cpi	r24, 0x01	; 1
    a6a4:	11 f0       	breq	.+4      	; 0xa6aa <FreePrinting+0x18>
	     stFreePrinting=fpInit;
    a6a6:	20 93 25 01 	sts	0x0125, r18
	 }

	 switch (stFreePrinting){
    a6aa:	80 91 25 01 	lds	r24, 0x0125
    a6ae:	90 e0       	ldi	r25, 0x00	; 0
    a6b0:	fc 01       	movw	r30, r24
    a6b2:	31 97       	sbiw	r30, 0x01	; 1
    a6b4:	e5 31       	cpi	r30, 0x15	; 21
    a6b6:	f1 05       	cpc	r31, r1
    a6b8:	08 f0       	brcs	.+2      	; 0xa6bc <FreePrinting+0x2a>
    a6ba:	7e c2       	rjmp	.+1276   	; 0xabb8 <FreePrinting+0x526>
    a6bc:	ec 59       	subi	r30, 0x9C	; 156
    a6be:	ff 4f       	sbci	r31, 0xFF	; 255
    a6c0:	ee 0f       	add	r30, r30
    a6c2:	ff 1f       	adc	r31, r31
    a6c4:	05 90       	lpm	r0, Z+
    a6c6:	f4 91       	lpm	r31, Z+
    a6c8:	e0 2d       	mov	r30, r0
    a6ca:	09 94       	ijmp
     case fpInit:
	      //_uart_printf(0,1,PSTR("fpInit"));
	      if (IsFreePrinting==True){
    a6cc:	21 30       	cpi	r18, 0x01	; 1
    a6ce:	09 f0       	breq	.+2      	; 0xa6d2 <FreePrinting+0x40>
    a6d0:	73 c2       	rjmp	.+1254   	; 0xabb8 <FreePrinting+0x526>
		      IsFreePrinting=False;
    a6d2:	10 92 bf 01 	sts	0x01BF, r1
			  IsBusyFreePrinting=True;
    a6d6:	20 93 ca 01 	sts	0x01CA, r18
			  IsBusyPrint=False;
    a6da:	10 92 c9 01 	sts	0x01C9, r1
			  iPrinted=0,iFooter=0;
    a6de:	10 92 88 02 	sts	0x0288, r1
    a6e2:	10 92 86 02 	sts	0x0286, r1

			  PrintCopy=(cmdPrint&0x0F);
    a6e6:	80 91 cb 01 	lds	r24, 0x01CB
    a6ea:	8f 70       	andi	r24, 0x0F	; 15
    a6ec:	80 93 85 02 	sts	0x0285, r24

			  //cmdPrint=cmdPrint|0b00100000;
			  //PrintCopy=2;

			  stFreePrinting=fpInitHeader;
    a6f0:	82 e0       	ldi	r24, 0x02	; 2
    a6f2:	80 93 25 01 	sts	0x0125, r24
			  InitPrinter();
    a6f6:	0e 94 cb 4b 	call	0x9796	; 0x9796 <InitPrinter>
    a6fa:	5e c2       	rjmp	.+1212   	; 0xabb8 <FreePrinting+0x526>
			  }
	      break;
     case fpInitHeader:
	      //_uart_printf(0,1,PSTR("fpInitHeader"));
		  iHeader=0;
    a6fc:	10 92 87 02 	sts	0x0287, r1
	      if (((cmdPrint&0b10000000)>>7)==1){
    a700:	80 91 cb 01 	lds	r24, 0x01CB
    a704:	88 1f       	adc	r24, r24
    a706:	88 27       	eor	r24, r24
    a708:	88 1f       	adc	r24, r24
    a70a:	90 e0       	ldi	r25, 0x00	; 0
    a70c:	81 30       	cpi	r24, 0x01	; 1
    a70e:	91 05       	cpc	r25, r1
    a710:	21 f1       	breq	.+72     	; 0xa75a <FreePrinting+0xc8>
		      stFreePrinting=fpLoadHeader;
			  }
		  else
	      if (((cmdPrint&0b10000000)>>7)==0) stFreePrinting=fpInitMessage;	      
    a712:	89 2b       	or	r24, r25
    a714:	09 f0       	breq	.+2      	; 0xa718 <FreePrinting+0x86>
    a716:	50 c2       	rjmp	.+1184   	; 0xabb8 <FreePrinting+0x526>
    a718:	85 e0       	ldi	r24, 0x05	; 5
    a71a:	80 93 25 01 	sts	0x0125, r24
    a71e:	4c c2       	rjmp	.+1176   	; 0xabb8 <FreePrinting+0x526>
    a720:	60 91 87 02 	lds	r22, 0x0287
    a724:	89 e2       	ldi	r24, 0x29	; 41
    a726:	68 9f       	mul	r22, r24
    a728:	b0 01       	movw	r22, r0
    a72a:	11 24       	eor	r1, r1
    a72c:	69 5d       	subi	r22, 0xD9	; 217
    a72e:	7d 4f       	sbci	r23, 0xFD	; 253
    a730:	89 e5       	ldi	r24, 0x59	; 89
    a732:	92 e0       	ldi	r25, 0x02	; 2
    a734:	48 e2       	ldi	r20, 0x28	; 40
    a736:	50 e0       	ldi	r21, 0x00	; 0
    a738:	23 ef       	ldi	r18, 0xF3	; 243
    a73a:	32 e1       	ldi	r19, 0x12	; 18
    a73c:	0e 94 1f b4 	call	0x1683e	; 0x1683e <__eerd_block>
	      break;
     case fpLoadHeader:
	      //_uart_printf(0,1,PSTR("fpLoadHeader"));
          //Header 1
	      eeprom_read_block((void*) &strHeader, (const void*) &DefHeaderFooter[iHeader], 40);
		  iHeader++;
    a740:	00 91 87 02 	lds	r16, 0x0287
    a744:	0f 5f       	subi	r16, 0xFF	; 255
    a746:	00 93 87 02 	sts	0x0287, r16
		  if (iHeader<6){
    a74a:	06 30       	cpi	r16, 0x06	; 6
    a74c:	28 f7       	brcc	.-54     	; 0xa718 <FreePrinting+0x86>
		      if (SpaceOnly(strHeader)==True){
    a74e:	89 e5       	ldi	r24, 0x59	; 89
    a750:	92 e0       	ldi	r25, 0x02	; 2
    a752:	0e 94 b8 22 	call	0x4570	; 0x4570 <SpaceOnly>
    a756:	81 30       	cpi	r24, 0x01	; 1
    a758:	11 f4       	brne	.+4      	; 0xa75e <FreePrinting+0xcc>
			      stFreePrinting=fpLoadHeader;
    a75a:	83 e0       	ldi	r24, 0x03	; 3
    a75c:	de cf       	rjmp	.-68     	; 0xa71a <FreePrinting+0x88>
				  }	      
			  else{
			      stFreePrinting=fpPrintHeader;
    a75e:	84 e0       	ldi	r24, 0x04	; 4
    a760:	80 93 25 01 	sts	0x0125, r24
			      iSend=0;
    a764:	10 92 58 02 	sts	0x0258, r1
    a768:	10 92 57 02 	sts	0x0257, r1
				  iLoop=0;
    a76c:	10 92 54 02 	sts	0x0254, r1
    a770:	10 92 53 02 	sts	0x0253, r1
				  //PrintDoubleHeight on 1st Header
				  if (iHeader==1) PrintDoubleHeight();
    a774:	01 30       	cpi	r16, 0x01	; 1
    a776:	19 f4       	brne	.+6      	; 0xa77e <FreePrinting+0xec>
    a778:	0e 94 4d 4c 	call	0x989a	; 0x989a <PrintDoubleHeight>
    a77c:	1d c2       	rjmp	.+1082   	; 0xabb8 <FreePrinting+0x526>
				  else 
				  if (iHeader==2) PrintNormalHeight();
    a77e:	02 30       	cpi	r16, 0x02	; 2
    a780:	09 f0       	breq	.+2      	; 0xa784 <FreePrinting+0xf2>
    a782:	1a c2       	rjmp	.+1076   	; 0xabb8 <FreePrinting+0x526>
    a784:	0e 94 33 4c 	call	0x9866	; 0x9866 <PrintNormalHeight>
    a788:	17 c2       	rjmp	.+1070   	; 0xabb8 <FreePrinting+0x526>
		  {stFreePrinting=fpInitMessage;
		  }
	      break;
     case fpPrintHeader:
	      //_uart_printf(0,1,PSTR("fpPrintHeader"));
		  if (iSend<40){
    a78a:	80 91 57 02 	lds	r24, 0x0257
    a78e:	90 91 58 02 	lds	r25, 0x0258
    a792:	88 97       	sbiw	r24, 0x28	; 40
    a794:	78 f4       	brcc	.+30     	; 0xa7b4 <FreePrinting+0x122>
		      iLoop++;
    a796:	80 91 53 02 	lds	r24, 0x0253
    a79a:	90 91 54 02 	lds	r25, 0x0254
    a79e:	01 96       	adiw	r24, 0x01	; 1
    a7a0:	90 93 54 02 	sts	0x0254, r25
    a7a4:	80 93 53 02 	sts	0x0253, r24
			  if ((iLoop%PRINT_DELAY)==0){
			     //_uart(_COM_PRINTER,1,strHeader[iSend]);
		         //iSend++;
				 TimPrintBusy=0;
    a7a8:	10 92 cd 01 	sts	0x01CD, r1
    a7ac:	10 92 cc 01 	sts	0x01CC, r1
				 stFreePrinting=fpCheckPrintStatusHeader;
    a7b0:	82 e1       	ldi	r24, 0x12	; 18
    a7b2:	b3 cf       	rjmp	.-154    	; 0xa71a <FreePrinting+0x88>
				 }
			  }
          else{ 
		     stFreePrinting=fpLoadHeader;
    a7b4:	83 e0       	ldi	r24, 0x03	; 3
    a7b6:	57 c1       	rjmp	.+686    	; 0xaa66 <FreePrinting+0x3d4>
			 CarriegeReturn();
		  }
	      break;

     case fpCheckPrintStatusHeader:
	      if (IsBusyPrint==False){
    a7b8:	80 91 c9 01 	lds	r24, 0x01C9
    a7bc:	88 23       	and	r24, r24
    a7be:	09 f0       	breq	.+2      	; 0xa7c2 <FreePrinting+0x130>
    a7c0:	71 c1       	rjmp	.+738    	; 0xaaa4 <FreePrinting+0x412>
		      _uart(_COM_PRINTER,1,strHeader[iSend]);
    a7c2:	e0 91 57 02 	lds	r30, 0x0257
    a7c6:	f0 91 58 02 	lds	r31, 0x0258
    a7ca:	e7 5a       	subi	r30, 0xA7	; 167
    a7cc:	fd 4f       	sbci	r31, 0xFD	; 253
    a7ce:	61 e0       	ldi	r22, 0x01	; 1
    a7d0:	40 81       	ld	r20, Z
    a7d2:	0e 94 7a b2 	call	0x164f4	; 0x164f4 <_uart>
		      iSend++;
    a7d6:	80 91 57 02 	lds	r24, 0x0257
    a7da:	90 91 58 02 	lds	r25, 0x0258
    a7de:	01 96       	adiw	r24, 0x01	; 1
    a7e0:	90 93 58 02 	sts	0x0258, r25
    a7e4:	80 93 57 02 	sts	0x0257, r24
		      stFreePrinting=fpPrintHeader;
    a7e8:	84 e0       	ldi	r24, 0x04	; 4
    a7ea:	5a c1       	rjmp	.+692    	; 0xaaa0 <FreePrinting+0x40e>
			  }
	      break;

     case fpInitMessage:
	      //_uart_printf(0,1,PSTR("fpInitMessage"));
	      iSend=0;iLoop=0;
    a7ec:	10 92 58 02 	sts	0x0258, r1
    a7f0:	10 92 57 02 	sts	0x0257, r1
    a7f4:	10 92 54 02 	sts	0x0254, r1
    a7f8:	10 92 53 02 	sts	0x0253, r1
          stFreePrinting=fpPrintMessage; 
    a7fc:	08 e0       	ldi	r16, 0x08	; 8
    a7fe:	00 93 25 01 	sts	0x0125, r16
		  CarriegeReturn();
    a802:	0e 94 c0 4b 	call	0x9780	; 0x9780 <CarriegeReturn>
		  if (iPrinted>0) stFreePrinting=fpInitDuplicate;
    a806:	80 91 88 02 	lds	r24, 0x0288
    a80a:	88 23       	and	r24, r24
    a80c:	11 f0       	breq	.+4      	; 0xa812 <FreePrinting+0x180>
    a80e:	86 e0       	ldi	r24, 0x06	; 6
    a810:	84 cf       	rjmp	.-248    	; 0xa71a <FreePrinting+0x88>
		  else stFreePrinting=fpPrintMessage; 
    a812:	00 93 25 01 	sts	0x0125, r16
    a816:	d0 c1       	rjmp	.+928    	; 0xabb8 <FreePrinting+0x526>
	      break;
     case fpInitDuplicate:
	      //_uart_printf(0,1,PSTR("fpInitDuplicate"));
          if (iPrinted>0)sprintf_P(strHeader,PSTR("             DUPLICATE COPY        "));
    a818:	80 91 88 02 	lds	r24, 0x0288
    a81c:	29 e5       	ldi	r18, 0x59	; 89
    a81e:	32 e0       	ldi	r19, 0x02	; 2
    a820:	88 23       	and	r24, r24
    a822:	49 f0       	breq	.+18     	; 0xa836 <FreePrinting+0x1a4>
    a824:	00 d0       	rcall	.+0      	; 0xa826 <FreePrinting+0x194>
    a826:	00 d0       	rcall	.+0      	; 0xa828 <FreePrinting+0x196>
    a828:	ed b7       	in	r30, 0x3d	; 61
    a82a:	fe b7       	in	r31, 0x3e	; 62
    a82c:	32 83       	std	Z+2, r19	; 0x02
    a82e:	21 83       	std	Z+1, r18	; 0x01
    a830:	88 e1       	ldi	r24, 0x18	; 24
    a832:	96 e0       	ldi	r25, 0x06	; 6
    a834:	08 c0       	rjmp	.+16     	; 0xa846 <FreePrinting+0x1b4>
          else           sprintf_P(strHeader,PSTR("                                   "));
    a836:	00 d0       	rcall	.+0      	; 0xa838 <FreePrinting+0x1a6>
    a838:	00 d0       	rcall	.+0      	; 0xa83a <FreePrinting+0x1a8>
    a83a:	ed b7       	in	r30, 0x3d	; 61
    a83c:	fe b7       	in	r31, 0x3e	; 62
    a83e:	32 83       	std	Z+2, r19	; 0x02
    a840:	21 83       	std	Z+1, r18	; 0x01
    a842:	84 ef       	ldi	r24, 0xF4	; 244
    a844:	95 e0       	ldi	r25, 0x05	; 5
    a846:	94 83       	std	Z+4, r25	; 0x04
    a848:	83 83       	std	Z+3, r24	; 0x03
    a84a:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    a84e:	0f 90       	pop	r0
    a850:	0f 90       	pop	r0
    a852:	0f 90       	pop	r0
    a854:	0f 90       	pop	r0
		  iSend=0;
    a856:	10 92 58 02 	sts	0x0258, r1
    a85a:	10 92 57 02 	sts	0x0257, r1
		  iLoop=0;
    a85e:	10 92 54 02 	sts	0x0254, r1
    a862:	10 92 53 02 	sts	0x0253, r1
		  LSend=strlen(strHeader);
    a866:	e9 e5       	ldi	r30, 0x59	; 89
    a868:	f2 e0       	ldi	r31, 0x02	; 2
    a86a:	01 90       	ld	r0, Z+
    a86c:	00 20       	and	r0, r0
    a86e:	e9 f7       	brne	.-6      	; 0xa86a <FreePrinting+0x1d8>
    a870:	31 97       	sbiw	r30, 0x01	; 1
    a872:	e9 55       	subi	r30, 0x59	; 89
    a874:	f2 40       	sbci	r31, 0x02	; 2
    a876:	f0 93 56 02 	sts	0x0256, r31
    a87a:	e0 93 55 02 	sts	0x0255, r30
          stFreePrinting=fpPrintDuplicate; 
    a87e:	87 e0       	ldi	r24, 0x07	; 7
    a880:	4c cf       	rjmp	.-360    	; 0xa71a <FreePrinting+0x88>
	      break;
     case fpPrintDuplicate:
	      //_uart_printf(0,1,PSTR("fpPrintDuplicate"));
		  if (iSend<LSend){
    a882:	20 91 57 02 	lds	r18, 0x0257
    a886:	30 91 58 02 	lds	r19, 0x0258
    a88a:	80 91 55 02 	lds	r24, 0x0255
    a88e:	90 91 56 02 	lds	r25, 0x0256
    a892:	28 17       	cp	r18, r24
    a894:	39 07       	cpc	r19, r25
    a896:	78 f4       	brcc	.+30     	; 0xa8b6 <FreePrinting+0x224>
		      iLoop++;
    a898:	80 91 53 02 	lds	r24, 0x0253
    a89c:	90 91 54 02 	lds	r25, 0x0254
    a8a0:	01 96       	adiw	r24, 0x01	; 1
    a8a2:	90 93 54 02 	sts	0x0254, r25
    a8a6:	80 93 53 02 	sts	0x0253, r24
			  if((iLoop%PRINT_DELAY)==0){
			     //_uart(_COM_PRINTER,1,strHeader[iSend]);
				 //iSend++;
				 TimPrintBusy=0;
    a8aa:	10 92 cd 01 	sts	0x01CD, r1
    a8ae:	10 92 cc 01 	sts	0x01CC, r1
                 stFreePrinting=fpCheckPrintStatusDuplicate;
    a8b2:	85 e1       	ldi	r24, 0x15	; 21
    a8b4:	32 cf       	rjmp	.-412    	; 0xa71a <FreePrinting+0x88>
				 }
			  }
          else {
		     iSend=0;
    a8b6:	10 92 58 02 	sts	0x0258, r1
    a8ba:	10 92 57 02 	sts	0x0257, r1
		     stFreePrinting=fpPrintMessage;
    a8be:	88 e0       	ldi	r24, 0x08	; 8
    a8c0:	d2 c0       	rjmp	.+420    	; 0xaa66 <FreePrinting+0x3d4>
			 CarriegeReturn();	      
			 }
	      break;
     case fpCheckPrintStatusDuplicate:
	      if (IsBusyPrint==False){
    a8c2:	80 91 c9 01 	lds	r24, 0x01C9
    a8c6:	88 23       	and	r24, r24
    a8c8:	09 f0       	breq	.+2      	; 0xa8cc <FreePrinting+0x23a>
    a8ca:	ec c0       	rjmp	.+472    	; 0xaaa4 <FreePrinting+0x412>
		      _uart(_COM_PRINTER,1,strHeader[iSend]);
    a8cc:	e0 91 57 02 	lds	r30, 0x0257
    a8d0:	f0 91 58 02 	lds	r31, 0x0258
    a8d4:	e7 5a       	subi	r30, 0xA7	; 167
    a8d6:	fd 4f       	sbci	r31, 0xFD	; 253
    a8d8:	61 e0       	ldi	r22, 0x01	; 1
    a8da:	40 81       	ld	r20, Z
    a8dc:	0e 94 7a b2 	call	0x164f4	; 0x164f4 <_uart>
		      iSend++;
    a8e0:	80 91 57 02 	lds	r24, 0x0257
    a8e4:	90 91 58 02 	lds	r25, 0x0258
    a8e8:	01 96       	adiw	r24, 0x01	; 1
    a8ea:	90 93 58 02 	sts	0x0258, r25
    a8ee:	80 93 57 02 	sts	0x0257, r24
		      stFreePrinting=fpPrintDuplicate;
    a8f2:	87 e0       	ldi	r24, 0x07	; 7
    a8f4:	d5 c0       	rjmp	.+426    	; 0xaaa0 <FreePrinting+0x40e>
		      stFreePrinting=fpFinishFreePrinting;
			  }
	      break;

     case fpPrintMessage:
		  if (iSend<LengthMessage81){
    a8f6:	20 91 57 02 	lds	r18, 0x0257
    a8fa:	30 91 58 02 	lds	r19, 0x0258
    a8fe:	80 91 a0 01 	lds	r24, 0x01A0
    a902:	90 91 a1 01 	lds	r25, 0x01A1
    a906:	28 17       	cp	r18, r24
    a908:	39 07       	cpc	r19, r25
    a90a:	78 f4       	brcc	.+30     	; 0xa92a <FreePrinting+0x298>
		      iLoop++;
    a90c:	80 91 53 02 	lds	r24, 0x0253
    a910:	90 91 54 02 	lds	r25, 0x0254
    a914:	01 96       	adiw	r24, 0x01	; 1
    a916:	90 93 54 02 	sts	0x0254, r25
    a91a:	80 93 53 02 	sts	0x0253, r24
			  if((iLoop%PRINT_DELAY)==0){
			     TimPrintBusy=0;
    a91e:	10 92 cd 01 	sts	0x01CD, r1
    a922:	10 92 cc 01 	sts	0x01CC, r1
				 stFreePrinting=fpCheckPrintStatusMessage;
    a926:	83 e1       	ldi	r24, 0x13	; 19
    a928:	f8 ce       	rjmp	.-528    	; 0xa71a <FreePrinting+0x88>
				 }
			  }
          else stFreePrinting=fpInitFooter;
    a92a:	8b e0       	ldi	r24, 0x0B	; 11
    a92c:	f6 ce       	rjmp	.-532    	; 0xa71a <FreePrinting+0x88>
	      break;
     
     case fpCheckPrintStatusMessage:
	      if (IsBusyPrint==False){
    a92e:	80 91 c9 01 	lds	r24, 0x01C9
    a932:	88 23       	and	r24, r24
    a934:	09 f0       	breq	.+2      	; 0xa938 <FreePrinting+0x2a6>
    a936:	b6 c0       	rjmp	.+364    	; 0xaaa4 <FreePrinting+0x412>
              if ((PrintBuffer[iSend]!=0x0D)||(PrintBuffer[iSend]!=0x0A))
			      SendPrint(PrintBuffer[iSend],PrintBuffer[iSend+1]);
    a938:	e0 91 57 02 	lds	r30, 0x0257
    a93c:	f0 91 58 02 	lds	r31, 0x0258
    a940:	e1 53       	subi	r30, 0x31	; 49
    a942:	fa 4f       	sbci	r31, 0xFA	; 250
    a944:	80 81       	ld	r24, Z
    a946:	61 81       	ldd	r22, Z+1	; 0x01
    a948:	0e 94 a8 4b 	call	0x9750	; 0x9750 <SendPrint>
			     // _uart(_COM_PRINTER,1,PrintBuffer[iSend]);
              if ((PrintBuffer[iSend]==0x0D)||(PrintBuffer[iSend+1]==0x0A))
    a94c:	e0 91 57 02 	lds	r30, 0x0257
    a950:	f0 91 58 02 	lds	r31, 0x0258
    a954:	e1 53       	subi	r30, 0x31	; 49
    a956:	fa 4f       	sbci	r31, 0xFA	; 250
    a958:	80 81       	ld	r24, Z
    a95a:	8d 30       	cpi	r24, 0x0D	; 13
    a95c:	19 f0       	breq	.+6      	; 0xa964 <FreePrinting+0x2d2>
    a95e:	81 81       	ldd	r24, Z+1	; 0x01
    a960:	8a 30       	cpi	r24, 0x0A	; 10
    a962:	11 f4       	brne	.+4      	; 0xa968 <FreePrinting+0x2d6>
			     CarriegeReturn();
    a964:	0e 94 c0 4b 	call	0x9780	; 0x9780 <CarriegeReturn>
             iSend++;
    a968:	80 91 57 02 	lds	r24, 0x0257
    a96c:	90 91 58 02 	lds	r25, 0x0258
    a970:	01 96       	adiw	r24, 0x01	; 1
    a972:	90 93 58 02 	sts	0x0258, r25
    a976:	80 93 57 02 	sts	0x0257, r24
		     stFreePrinting=fpPrintMessage;
    a97a:	88 e0       	ldi	r24, 0x08	; 8
    a97c:	91 c0       	rjmp	.+290    	; 0xaaa0 <FreePrinting+0x40e>
		      stFreePrinting=fpFinishFreePrinting;
			  }
	      break;
     //SpaceAdded
	 case fpInitSpace:
	      iLoop=0;
    a97e:	10 92 54 02 	sts	0x0254, r1
    a982:	10 92 53 02 	sts	0x0253, r1
		  iMargin=0;
    a986:	10 92 84 02 	sts	0x0284, r1
		  stFreePrinting=fpPrintMargin;
    a98a:	8a e0       	ldi	r24, 0x0A	; 10
    a98c:	c6 ce       	rjmp	.-628    	; 0xa71a <FreePrinting+0x88>
	      break;
	 case fpPrintMargin:
		  if (iMargin<PRINT_MARGIN){
    a98e:	80 91 84 02 	lds	r24, 0x0284
    a992:	85 30       	cpi	r24, 0x05	; 5
    a994:	90 f4       	brcc	.+36     	; 0xa9ba <FreePrinting+0x328>
		      iMargin++;
    a996:	8f 5f       	subi	r24, 0xFF	; 255
    a998:	80 93 84 02 	sts	0x0284, r24
		      iLoop++;
    a99c:	80 91 53 02 	lds	r24, 0x0253
    a9a0:	90 91 54 02 	lds	r25, 0x0254
    a9a4:	01 96       	adiw	r24, 0x01	; 1
    a9a6:	90 93 54 02 	sts	0x0254, r25
    a9aa:	80 93 53 02 	sts	0x0253, r24
	          if ((iLoop%PRINT_DELAY)==0)_uart(_COM_PRINTER,1,' ');
    a9ae:	80 e0       	ldi	r24, 0x00	; 0
    a9b0:	61 e0       	ldi	r22, 0x01	; 1
    a9b2:	40 e2       	ldi	r20, 0x20	; 32
    a9b4:	0e 94 7a b2 	call	0x164f4	; 0x164f4 <_uart>
    a9b8:	ff c0       	rjmp	.+510    	; 0xabb8 <FreePrinting+0x526>
			 }
          else stFreePrinting=fpPrintMessage;
    a9ba:	88 e0       	ldi	r24, 0x08	; 8
    a9bc:	ae ce       	rjmp	.-676    	; 0xa71a <FreePrinting+0x88>
	      break;
     case fpInitFooter:
	      //_uart_printf(0,1,PSTR("fpInitFooter"));
          if (((cmdPrint&0b01000000)>>6)==1){
    a9be:	80 91 cb 01 	lds	r24, 0x01CB
    a9c2:	86 ff       	sbrs	r24, 6
    a9c4:	06 c0       	rjmp	.+12     	; 0xa9d2 <FreePrinting+0x340>
		      stFreePrinting=fpLoadFooter;
    a9c6:	8c e0       	ldi	r24, 0x0C	; 12
    a9c8:	80 93 25 01 	sts	0x0125, r24
			  iFooter=0;
    a9cc:	10 92 86 02 	sts	0x0286, r1
    a9d0:	f3 c0       	rjmp	.+486    	; 0xabb8 <FreePrinting+0x526>
			  }
		  else
	      if (((cmdPrint&0b01000000)>>6)==0) stFreePrinting=fpPaperCut;//fpInitScroll;	                
    a9d2:	80 e1       	ldi	r24, 0x10	; 16
    a9d4:	a2 ce       	rjmp	.-700    	; 0xa71a <FreePrinting+0x88>
    a9d6:	60 91 86 02 	lds	r22, 0x0286
    a9da:	89 e2       	ldi	r24, 0x29	; 41
    a9dc:	68 9f       	mul	r22, r24
    a9de:	b0 01       	movw	r22, r0
    a9e0:	11 24       	eor	r1, r1
    a9e2:	63 5e       	subi	r22, 0xE3	; 227
    a9e4:	7c 4f       	sbci	r23, 0xFC	; 252
    a9e6:	89 e5       	ldi	r24, 0x59	; 89
    a9e8:	92 e0       	ldi	r25, 0x02	; 2
    a9ea:	48 e2       	ldi	r20, 0x28	; 40
    a9ec:	50 e0       	ldi	r21, 0x00	; 0
    a9ee:	23 ef       	ldi	r18, 0xF3	; 243
    a9f0:	32 e1       	ldi	r19, 0x12	; 18
    a9f2:	0e 94 1f b4 	call	0x1683e	; 0x1683e <__eerd_block>
	      break;
     case fpLoadFooter:
	 	  //_uart_printf(0,1,PSTR("fpLoadFooter"));
          //Footer 1
	      eeprom_read_block((void*) &strHeader, (const void*) &DefHeaderFooter[6+iFooter], 40);
		  iFooter++;
    a9f6:	80 91 86 02 	lds	r24, 0x0286
    a9fa:	8f 5f       	subi	r24, 0xFF	; 255
    a9fc:	80 93 86 02 	sts	0x0286, r24
		  if (iFooter<4){
    aa00:	84 30       	cpi	r24, 0x04	; 4
    aa02:	90 f4       	brcc	.+36     	; 0xaa28 <FreePrinting+0x396>
		      if (SpaceOnly(strHeader)==True){
    aa04:	89 e5       	ldi	r24, 0x59	; 89
    aa06:	92 e0       	ldi	r25, 0x02	; 2
    aa08:	0e 94 b8 22 	call	0x4570	; 0x4570 <SpaceOnly>
    aa0c:	81 30       	cpi	r24, 0x01	; 1
    aa0e:	11 f4       	brne	.+4      	; 0xaa14 <FreePrinting+0x382>
			      stFreePrinting=fpLoadFooter;
    aa10:	8c e0       	ldi	r24, 0x0C	; 12
    aa12:	83 ce       	rjmp	.-762    	; 0xa71a <FreePrinting+0x88>
				  }
			  else{
			      iSend=0;
    aa14:	10 92 58 02 	sts	0x0258, r1
    aa18:	10 92 57 02 	sts	0x0257, r1
				  iLoop=0;
    aa1c:	10 92 54 02 	sts	0x0254, r1
    aa20:	10 92 53 02 	sts	0x0253, r1
				  stFreePrinting=fpPrintFooter;
    aa24:	8d e0       	ldi	r24, 0x0D	; 13
    aa26:	79 ce       	rjmp	.-782    	; 0xa71a <FreePrinting+0x88>
			      }
		  }else{
		    CarriegeReturn();
    aa28:	0e 94 c0 4b 	call	0x9780	; 0x9780 <CarriegeReturn>
			iPrinted++;
    aa2c:	80 91 88 02 	lds	r24, 0x0288
    aa30:	8f 5f       	subi	r24, 0xFF	; 255
    aa32:	80 93 88 02 	sts	0x0288, r24

			//if (eeprom_read_byte(&DefPrinterType)==PT_CUSTOM_CUBE){
			    stFreePrinting=fpInitScroll;
    aa36:	8e e0       	ldi	r24, 0x0E	; 14
    aa38:	70 ce       	rjmp	.-800    	; 0xa71a <FreePrinting+0x88>
			//}else stFreePrinting=fpPaperCut;

			}
	      break;
     case fpPrintFooter:
		  if (iSend<40){
    aa3a:	80 91 57 02 	lds	r24, 0x0257
    aa3e:	90 91 58 02 	lds	r25, 0x0258
    aa42:	88 97       	sbiw	r24, 0x28	; 40
    aa44:	78 f4       	brcc	.+30     	; 0xaa64 <FreePrinting+0x3d2>
		      iLoop++;
    aa46:	80 91 53 02 	lds	r24, 0x0253
    aa4a:	90 91 54 02 	lds	r25, 0x0254
    aa4e:	01 96       	adiw	r24, 0x01	; 1
    aa50:	90 93 54 02 	sts	0x0254, r25
    aa54:	80 93 53 02 	sts	0x0253, r24
			  if((iLoop%PRINT_DELAY)==0){
		        //_uart(_COM_PRINTER,1,strHeader[iSend]);
		        //iSend++;
				TimPrintBusy=0;
    aa58:	10 92 cd 01 	sts	0x01CD, r1
    aa5c:	10 92 cc 01 	sts	0x01CC, r1
				stFreePrinting=fpCheckPrintStatusFooter;
    aa60:	84 e1       	ldi	r24, 0x14	; 20
    aa62:	5b ce       	rjmp	.-842    	; 0xa71a <FreePrinting+0x88>
				}
			  }
          else {
		      stFreePrinting=fpLoadFooter;
    aa64:	8c e0       	ldi	r24, 0x0C	; 12
    aa66:	80 93 25 01 	sts	0x0125, r24
			  CarriegeReturn();
    aa6a:	0e 94 c0 4b 	call	0x9780	; 0x9780 <CarriegeReturn>
    aa6e:	a4 c0       	rjmp	.+328    	; 0xabb8 <FreePrinting+0x526>
			  }
	      break;
     
	 case fpCheckPrintStatusFooter:
	      if (IsBusyPrint==False){
    aa70:	80 91 c9 01 	lds	r24, 0x01C9
    aa74:	88 23       	and	r24, r24
    aa76:	b1 f4       	brne	.+44     	; 0xaaa4 <FreePrinting+0x412>
		      _uart(_COM_PRINTER,1,strHeader[iSend]);
    aa78:	e0 91 57 02 	lds	r30, 0x0257
    aa7c:	f0 91 58 02 	lds	r31, 0x0258
    aa80:	e7 5a       	subi	r30, 0xA7	; 167
    aa82:	fd 4f       	sbci	r31, 0xFD	; 253
    aa84:	61 e0       	ldi	r22, 0x01	; 1
    aa86:	40 81       	ld	r20, Z
    aa88:	0e 94 7a b2 	call	0x164f4	; 0x164f4 <_uart>
		      iSend++;
    aa8c:	80 91 57 02 	lds	r24, 0x0257
    aa90:	90 91 58 02 	lds	r25, 0x0258
    aa94:	01 96       	adiw	r24, 0x01	; 1
    aa96:	90 93 58 02 	sts	0x0258, r25
    aa9a:	80 93 57 02 	sts	0x0257, r24
		      stFreePrinting=fpPrintFooter;
    aa9e:	8d e0       	ldi	r24, 0x0D	; 13
    aaa0:	80 93 25 01 	sts	0x0125, r24
		  }
		  if (TimPrintBusy>TIM_BUSY_PRINT){
    aaa4:	80 91 cc 01 	lds	r24, 0x01CC
    aaa8:	90 91 cd 01 	lds	r25, 0x01CD
    aaac:	0b 97       	sbiw	r24, 0x0b	; 11
    aaae:	0c f4       	brge	.+2      	; 0xaab2 <FreePrinting+0x420>
    aab0:	83 c0       	rjmp	.+262    	; 0xabb8 <FreePrinting+0x526>
		      IsPrintERROR=True;
    aab2:	81 e0       	ldi	r24, 0x01	; 1
    aab4:	80 93 c7 01 	sts	0x01C7, r24
		      stFreePrinting=fpFinishFreePrinting;
    aab8:	81 e1       	ldi	r24, 0x11	; 17
    aaba:	2f ce       	rjmp	.-930    	; 0xa71a <FreePrinting+0x88>
			  }
	      break;

     case fpInitScroll:
	      iScroll=0;
    aabc:	10 92 83 02 	sts	0x0283, r1
		  iSend=0;
    aac0:	10 92 58 02 	sts	0x0258, r1
    aac4:	10 92 57 02 	sts	0x0257, r1
		  if (iPrinted<PrintCopy)
    aac8:	90 91 88 02 	lds	r25, 0x0288
    aacc:	80 91 85 02 	lds	r24, 0x0285
    aad0:	98 17       	cp	r25, r24
    aad2:	28 f4       	brcc	.+10     	; 0xaade <FreePrinting+0x44c>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    aad4:	e1 99       	sbic	0x1c, 1	; 28
    aad6:	fe cf       	rjmp	.-4      	; 0xaad4 <FreePrinting+0x442>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    aad8:	82 e3       	ldi	r24, 0x32	; 50
    aada:	90 e0       	ldi	r25, 0x00	; 0
    aadc:	04 c0       	rjmp	.+8      	; 0xaae6 <FreePrinting+0x454>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    aade:	e1 99       	sbic	0x1c, 1	; 28
    aae0:	fe cf       	rjmp	.-4      	; 0xaade <FreePrinting+0x44c>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    aae2:	81 e3       	ldi	r24, 0x31	; 49
    aae4:	90 e0       	ldi	r25, 0x00	; 0
    aae6:	9f bb       	out	0x1f, r25	; 31
    aae8:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    aaea:	e0 9a       	sbi	0x1c, 0	; 28
    aaec:	8d b3       	in	r24, 0x1d	; 29
		      nScroll=eeprom_read_byte(&DefPrintScrollSpace);
		  else if (iPrinted>=PrintCopy)
		  	  nScroll=eeprom_read_byte(&DefPrintScrollEnd);
    aaee:	80 93 82 02 	sts	0x0282, r24

          stFreePrinting=fpScrollPaper;
    aaf2:	8f e0       	ldi	r24, 0x0F	; 15
    aaf4:	12 ce       	rjmp	.-988    	; 0xa71a <FreePrinting+0x88>
	      break;
     case fpScrollPaper:
	      if (iScroll>nScroll)stFreePrinting=fpPaperCut;
    aaf6:	90 91 83 02 	lds	r25, 0x0283
    aafa:	80 91 82 02 	lds	r24, 0x0282
    aafe:	89 17       	cp	r24, r25
    ab00:	18 f4       	brcc	.+6      	; 0xab08 <FreePrinting+0x476>
    ab02:	80 e1       	ldi	r24, 0x10	; 16
    ab04:	80 93 25 01 	sts	0x0125, r24
		  iSend++;
    ab08:	80 91 57 02 	lds	r24, 0x0257
    ab0c:	90 91 58 02 	lds	r25, 0x0258
    ab10:	01 96       	adiw	r24, 0x01	; 1
    ab12:	90 93 58 02 	sts	0x0258, r25
    ab16:	80 93 57 02 	sts	0x0257, r24
		  if (iSend%PRINT_DELAY==0){
		      CarriegeReturn();
    ab1a:	0e 94 c0 4b 	call	0x9780	; 0x9780 <CarriegeReturn>
			  iScroll++;
    ab1e:	80 91 83 02 	lds	r24, 0x0283
    ab22:	8f 5f       	subi	r24, 0xFF	; 255
    ab24:	80 93 83 02 	sts	0x0283, r24
    ab28:	47 c0       	rjmp	.+142    	; 0xabb8 <FreePrinting+0x526>
			  }
	      break;
     case fpPaperCut:
		  //_uart_printf(0,1,PSTR("fpPaperCut"));
		  //iPrinted++;
          if (iPrinted<PrintCopy){
    ab2a:	90 91 88 02 	lds	r25, 0x0288
    ab2e:	80 91 85 02 	lds	r24, 0x0285
    ab32:	98 17       	cp	r25, r24
    ab34:	20 f4       	brcc	.+8      	; 0xab3e <FreePrinting+0x4ac>
		      CarriegeReturn();
    ab36:	0e 94 c0 4b 	call	0x9780	; 0x9780 <CarriegeReturn>
              stFreePrinting=fpInitHeader;
    ab3a:	82 e0       	ldi	r24, 0x02	; 2
    ab3c:	07 c0       	rjmp	.+14     	; 0xab4c <FreePrinting+0x4ba>
			  }
          else{
		      if (IFType==IT_SLAVE)sendMessage04();
    ab3e:	80 91 10 01 	lds	r24, 0x0110
    ab42:	81 30       	cpi	r24, 0x01	; 1
    ab44:	11 f4       	brne	.+4      	; 0xab4a <FreePrinting+0x4b8>
    ab46:	0e 94 e5 52 	call	0xa5ca	; 0xa5ca <sendMessage04>
		      stFreePrinting=fpFinishFreePrinting;
    ab4a:	81 e1       	ldi	r24, 0x11	; 17
    ab4c:	80 93 25 01 	sts	0x0125, r24
			  }

		  if (((cmdPrint&0b00100000)>>5)==1){
    ab50:	80 91 cb 01 	lds	r24, 0x01CB
    ab54:	85 ff       	sbrs	r24, 5
    ab56:	30 c0       	rjmp	.+96     	; 0xabb8 <FreePrinting+0x526>
		      if (iPrinted==0){
    ab58:	80 91 88 02 	lds	r24, 0x0288
    ab5c:	88 23       	and	r24, r24
    ab5e:	31 f4       	brne	.+12     	; 0xab6c <FreePrinting+0x4da>
			      CarriegeReturn();_delay_ms(50);
    ab60:	0e 94 c0 4b 	call	0x9780	; 0x9780 <CarriegeReturn>
    ab64:	84 ed       	ldi	r24, 0xD4	; 212
    ab66:	90 e3       	ldi	r25, 0x30	; 48
    ab68:	01 97       	sbiw	r24, 0x01	; 1
    ab6a:	f1 f7       	brne	.-4      	; 0xab68 <FreePrinting+0x4d6>
				 }
              //HFCS 0000 : Header, Footer, Copy , Scrool [Copy:16x max]
		      if ((iPrinted==PrintCopy)){
    ab6c:	90 91 88 02 	lds	r25, 0x0288
    ab70:	80 91 85 02 	lds	r24, 0x0285
    ab74:	98 17       	cp	r25, r24
    ab76:	b1 f4       	brne	.+44     	; 0xaba4 <FreePrinting+0x512>
			      // if (((cmdPrint&0b00010000)>>4)==1){
				       CarriegeReturn();_delay_ms(50);
    ab78:	0e 94 c0 4b 	call	0x9780	; 0x9780 <CarriegeReturn>
    ab7c:	04 ed       	ldi	r16, 0xD4	; 212
    ab7e:	10 e3       	ldi	r17, 0x30	; 48
    ab80:	c8 01       	movw	r24, r16
    ab82:	01 97       	sbiw	r24, 0x01	; 1
    ab84:	f1 f7       	brne	.-4      	; 0xab82 <FreePrinting+0x4f0>
					   CarriegeReturn();_delay_ms(50);
    ab86:	0e 94 c0 4b 	call	0x9780	; 0x9780 <CarriegeReturn>
    ab8a:	c8 01       	movw	r24, r16
    ab8c:	01 97       	sbiw	r24, 0x01	; 1
    ab8e:	f1 f7       	brne	.-4      	; 0xab8c <FreePrinting+0x4fa>
					   CarriegeReturn();_delay_ms(50);
    ab90:	0e 94 c0 4b 	call	0x9780	; 0x9780 <CarriegeReturn>
    ab94:	c8 01       	movw	r24, r16
    ab96:	01 97       	sbiw	r24, 0x01	; 1
    ab98:	f1 f7       	brne	.-4      	; 0xab96 <FreePrinting+0x504>
					   CarriegeReturn();_delay_ms(50);
    ab9a:	0e 94 c0 4b 	call	0x9780	; 0x9780 <CarriegeReturn>
    ab9e:	c8 01       	movw	r24, r16
    aba0:	01 97       	sbiw	r24, 0x01	; 1
    aba2:	f1 f7       	brne	.-4      	; 0xaba0 <FreePrinting+0x50e>
				   //}
				 }
		      PaperCut();
    aba4:	0e 94 67 4c 	call	0x98ce	; 0x98ce <PaperCut>
    aba8:	07 c0       	rjmp	.+14     	; 0xabb8 <FreePrinting+0x526>
		   }
	      break;
     case fpFinishFreePrinting:
	 	  //_uart_printf(0,1,PSTR("fpFinished"));
		  IsBusyFreePrinting=False;
    abaa:	10 92 ca 01 	sts	0x01CA, r1
	      stFreePrinting=fpInit;
    abae:	81 e0       	ldi	r24, 0x01	; 1
    abb0:	80 93 25 01 	sts	0x0125, r24
		  iPrinted=0;
    abb4:	10 92 88 02 	sts	0x0288, r1
	      break;
	 }//EndCase
}
    abb8:	1f 91       	pop	r17
    abba:	0f 91       	pop	r16
    abbc:	08 95       	ret

0000abbe <PrintIdle>:
		//Font Setting: 1D 21 01
		_uart(_COM_PRINTER, 1, 0x1D);_uart(_COM_PRINTER, 1, 0x21);_uart(_COM_PRINTER, 1, 0x00);   
		}
}

void PrintIdle(){
    abbe:	cf 93       	push	r28
    abc0:	df 93       	push	r29
		_uart_print(1,1,strSend);
	 }
	 #endif

     //Normalize PrintIdleState
     if ((IsPrinting==True)&&(stPrintIdle!=piIdle)){
    abc2:	80 91 c3 01 	lds	r24, 0x01C3
    abc6:	81 30       	cpi	r24, 0x01	; 1
    abc8:	31 f4       	brne	.+12     	; 0xabd6 <PrintIdle+0x18>
    abca:	80 91 c6 02 	lds	r24, 0x02C6
    abce:	88 23       	and	r24, r24
    abd0:	11 f0       	breq	.+4      	; 0xabd6 <PrintIdle+0x18>
	     stPrintIdle=piIdle;
    abd2:	10 92 c6 02 	sts	0x02C6, r1
	 }

     switch(stPrintIdle){
    abd6:	80 91 c6 02 	lds	r24, 0x02C6
    abda:	e8 2f       	mov	r30, r24
    abdc:	f0 e0       	ldi	r31, 0x00	; 0
    abde:	e5 31       	cpi	r30, 0x15	; 21
    abe0:	f1 05       	cpc	r31, r1
    abe2:	08 f0       	brcs	.+2      	; 0xabe6 <PrintIdle+0x28>
    abe4:	0f c7       	rjmp	.+3614   	; 0xba04 <PrintIdle+0xe46>
    abe6:	e7 58       	subi	r30, 0x87	; 135
    abe8:	ff 4f       	sbci	r31, 0xFF	; 255
    abea:	ee 0f       	add	r30, r30
    abec:	ff 1f       	adc	r31, r31
    abee:	05 90       	lpm	r0, Z+
    abf0:	f4 91       	lpm	r31, Z+
    abf2:	e0 2d       	mov	r30, r0
    abf4:	09 94       	ijmp
	 case piIdle:
	      if (IsPrinting==True){
    abf6:	80 91 c3 01 	lds	r24, 0x01C3
    abfa:	81 30       	cpi	r24, 0x01	; 1
    abfc:	09 f0       	breq	.+2      	; 0xac00 <PrintIdle+0x42>
    abfe:	02 c7       	rjmp	.+3588   	; 0xba04 <PrintIdle+0xe46>
		      IsPrinting=False;
    ac00:	10 92 c3 01 	sts	0x01C3, r1
			  IsBusyIdlePrinting=True;
    ac04:	80 93 c8 01 	sts	0x01C8, r24
			  IsBusyPrint=False;
    ac08:	10 92 c9 01 	sts	0x01C9, r1
			  iPrinted=0;
    ac0c:	10 92 8b 02 	sts	0x028B, r1
			  PrintCopy=0;
    ac10:	10 92 8a 02 	sts	0x028A, r1
		      stPrintIdle=piInit;
    ac14:	80 93 c6 02 	sts	0x02C6, r24
			  InitPrinter();
    ac18:	0e 94 cb 4b 	call	0x9796	; 0x9796 <InitPrinter>
			  IsSignedField=False;
    ac1c:	10 92 92 02 	sts	0x0292, r1
    ac20:	f1 c6       	rjmp	.+3554   	; 0xba04 <PrintIdle+0xe46>
			  }
	      break;
	 case piInit:
	      iHeader=0;
    ac22:	10 92 c5 02 	sts	0x02C5, r1
		  CarriegeReturn();
    ac26:	0e 94 c0 4b 	call	0x9780	; 0x9780 <CarriegeReturn>
    ac2a:	1d c0       	rjmp	.+58     	; 0xac66 <PrintIdle+0xa8>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    ac2c:	60 91 c5 02 	lds	r22, 0x02C5
    ac30:	89 e2       	ldi	r24, 0x29	; 41
    ac32:	68 9f       	mul	r22, r24
    ac34:	b0 01       	movw	r22, r0
    ac36:	11 24       	eor	r1, r1
    ac38:	69 5d       	subi	r22, 0xD9	; 217
    ac3a:	7d 4f       	sbci	r23, 0xFD	; 253
    ac3c:	85 e9       	ldi	r24, 0x95	; 149
    ac3e:	92 e0       	ldi	r25, 0x02	; 2
    ac40:	49 e2       	ldi	r20, 0x29	; 41
    ac42:	50 e0       	ldi	r21, 0x00	; 0
    ac44:	23 ef       	ldi	r18, 0xF3	; 243
    ac46:	32 e1       	ldi	r19, 0x12	; 18
    ac48:	0e 94 1f b4 	call	0x1683e	; 0x1683e <__eerd_block>
		  stPrintIdle=piLoadHeader;
	      break;
     case piLoadHeader:
	      eeprom_read_block((void*) &strPrint, (const void*) &DefHeaderFooter[iHeader], sizeof(DefHeaderFooter[iHeader]));
		  iHeader++;
    ac4c:	80 91 c5 02 	lds	r24, 0x02C5
    ac50:	8f 5f       	subi	r24, 0xFF	; 255
    ac52:	80 93 c5 02 	sts	0x02C5, r24
		  if (iHeader<6){
    ac56:	86 30       	cpi	r24, 0x06	; 6
    ac58:	00 f5       	brcc	.+64     	; 0xac9a <PrintIdle+0xdc>
		      if (SpaceOnly(strPrint)==True){
    ac5a:	85 e9       	ldi	r24, 0x95	; 149
    ac5c:	92 e0       	ldi	r25, 0x02	; 2
    ac5e:	0e 94 b8 22 	call	0x4570	; 0x4570 <SpaceOnly>
    ac62:	81 30       	cpi	r24, 0x01	; 1
    ac64:	11 f4       	brne	.+4      	; 0xac6a <PrintIdle+0xac>
			      stPrintIdle=piLoadHeader;
    ac66:	82 e0       	ldi	r24, 0x02	; 2
    ac68:	a2 c6       	rjmp	.+3396   	; 0xb9ae <PrintIdle+0xdf0>
				  }	      
			  else{
			      stPrintIdle=piPrintHeader;
    ac6a:	83 e0       	ldi	r24, 0x03	; 3
    ac6c:	80 93 c6 02 	sts	0x02C6, r24
			      iSend=0;
    ac70:	10 92 91 02 	sts	0x0291, r1
    ac74:	10 92 90 02 	sts	0x0290, r1
				  iLoop=0;
    ac78:	10 92 8d 02 	sts	0x028D, r1
    ac7c:	10 92 8c 02 	sts	0x028C, r1
				  //PrintDoubleHeight on 1st Header
				  if (iHeader==1) PrintDoubleHeight();
    ac80:	80 91 c5 02 	lds	r24, 0x02C5
    ac84:	81 30       	cpi	r24, 0x01	; 1
    ac86:	19 f4       	brne	.+6      	; 0xac8e <PrintIdle+0xd0>
    ac88:	0e 94 4d 4c 	call	0x989a	; 0x989a <PrintDoubleHeight>
    ac8c:	bb c6       	rjmp	.+3446   	; 0xba04 <PrintIdle+0xe46>
				  else 
				  if (iHeader==2) PrintNormalHeight();
    ac8e:	82 30       	cpi	r24, 0x02	; 2
    ac90:	09 f0       	breq	.+2      	; 0xac94 <PrintIdle+0xd6>
    ac92:	b8 c6       	rjmp	.+3440   	; 0xba04 <PrintIdle+0xe46>
    ac94:	0e 94 33 4c 	call	0x9866	; 0x9866 <PrintNormalHeight>
    ac98:	b5 c6       	rjmp	.+3434   	; 0xba04 <PrintIdle+0xe46>
			   }
		  }else{stPrintIdle=piInitDuplicate; //stPrintIdle=piInitMessage;//
    ac9a:	84 e0       	ldi	r24, 0x04	; 4
    ac9c:	88 c6       	rjmp	.+3344   	; 0xb9ae <PrintIdle+0xdf0>
		        //else stPrintIdle=piInitMessage;
		  }
	      break;
	 case piPrintHeader:
		  if (iSend<40){
    ac9e:	80 91 90 02 	lds	r24, 0x0290
    aca2:	90 91 91 02 	lds	r25, 0x0291
    aca6:	88 97       	sbiw	r24, 0x28	; 40
    aca8:	78 f4       	brcc	.+30     	; 0xacc8 <PrintIdle+0x10a>
		      iLoop++;
    acaa:	80 91 8c 02 	lds	r24, 0x028C
    acae:	90 91 8d 02 	lds	r25, 0x028D
    acb2:	01 96       	adiw	r24, 0x01	; 1
    acb4:	90 93 8d 02 	sts	0x028D, r25
    acb8:	80 93 8c 02 	sts	0x028C, r24
			  if ((iLoop%PRINT_DELAY)==0){
				 TimPrintBusy=0;
    acbc:	10 92 cd 01 	sts	0x01CD, r1
    acc0:	10 92 cc 01 	sts	0x01CC, r1
				 stPrintIdle=piCheckPrintStatusHeader;
    acc4:	8b e0       	ldi	r24, 0x0B	; 11
    acc6:	73 c6       	rjmp	.+3302   	; 0xb9ae <PrintIdle+0xdf0>
				 }
			  }
          else{ 
		     stPrintIdle=piLoadHeader;
    acc8:	82 e0       	ldi	r24, 0x02	; 2
    acca:	01 c6       	rjmp	.+3074   	; 0xb8ce <PrintIdle+0xd10>
			 CarriegeReturn();
		  }
	      break;
     case piCheckPrintStatusHeader:
	      if (IsBusyPrint==False){
    accc:	80 91 c9 01 	lds	r24, 0x01C9
    acd0:	88 23       	and	r24, r24
    acd2:	09 f0       	breq	.+2      	; 0xacd6 <PrintIdle+0x118>
    acd4:	62 c6       	rjmp	.+3268   	; 0xb99a <PrintIdle+0xddc>
		      _uart(_COM_PRINTER,1,strPrint[iSend]);
    acd6:	e0 91 90 02 	lds	r30, 0x0290
    acda:	f0 91 91 02 	lds	r31, 0x0291
    acde:	eb 56       	subi	r30, 0x6B	; 107
    ace0:	fd 4f       	sbci	r31, 0xFD	; 253
    ace2:	61 e0       	ldi	r22, 0x01	; 1
    ace4:	40 81       	ld	r20, Z
    ace6:	0e 94 7a b2 	call	0x164f4	; 0x164f4 <_uart>
		      iSend++;
    acea:	80 91 90 02 	lds	r24, 0x0290
    acee:	90 91 91 02 	lds	r25, 0x0291
    acf2:	01 96       	adiw	r24, 0x01	; 1
    acf4:	90 93 91 02 	sts	0x0291, r25
    acf8:	80 93 90 02 	sts	0x0290, r24
		      stPrintIdle=piPrintHeader;
    acfc:	83 e0       	ldi	r24, 0x03	; 3
    acfe:	4b c6       	rjmp	.+3222   	; 0xb996 <PrintIdle+0xdd8>
		      stPrintIdle=piFinishPrintIdle;
			  }
	      break;

     case piInitDuplicate:
          if ((iPrinted>0)||(IsReprintTicket==True)){
    ad00:	80 91 8b 02 	lds	r24, 0x028B
    ad04:	88 23       	and	r24, r24
    ad06:	21 f4       	brne	.+8      	; 0xad10 <PrintIdle+0x152>
    ad08:	80 91 92 01 	lds	r24, 0x0192
    ad0c:	81 30       	cpi	r24, 0x01	; 1
    ad0e:	a9 f4       	brne	.+42     	; 0xad3a <PrintIdle+0x17c>
		      IsReprintTicket=False;
    ad10:	10 92 92 01 	sts	0x0192, r1
		      CarriegeReturn(); 
    ad14:	0e 94 c0 4b 	call	0x9780	; 0x9780 <CarriegeReturn>
		      sprintf_P(strPrint,PSTR("             DUPLICATE COPY        "));
    ad18:	00 d0       	rcall	.+0      	; 0xad1a <PrintIdle+0x15c>
    ad1a:	00 d0       	rcall	.+0      	; 0xad1c <PrintIdle+0x15e>
    ad1c:	85 e9       	ldi	r24, 0x95	; 149
    ad1e:	92 e0       	ldi	r25, 0x02	; 2
    ad20:	ad b7       	in	r26, 0x3d	; 61
    ad22:	be b7       	in	r27, 0x3e	; 62
    ad24:	12 96       	adiw	r26, 0x02	; 2
    ad26:	9c 93       	st	X, r25
    ad28:	8e 93       	st	-X, r24
    ad2a:	11 97       	sbiw	r26, 0x01	; 1
    ad2c:	83 e0       	ldi	r24, 0x03	; 3
    ad2e:	9a e0       	ldi	r25, 0x0A	; 10
    ad30:	14 96       	adiw	r26, 0x04	; 4
    ad32:	9c 93       	st	X, r25
    ad34:	8e 93       	st	-X, r24
    ad36:	13 97       	sbiw	r26, 0x03	; 3
    ad38:	0c c0       	rjmp	.+24     	; 0xad52 <PrintIdle+0x194>
		      }
          else{           sprintf_P(strPrint,PSTR(" "));
    ad3a:	00 d0       	rcall	.+0      	; 0xad3c <PrintIdle+0x17e>
    ad3c:	00 d0       	rcall	.+0      	; 0xad3e <PrintIdle+0x180>
    ad3e:	85 e9       	ldi	r24, 0x95	; 149
    ad40:	92 e0       	ldi	r25, 0x02	; 2
    ad42:	ed b7       	in	r30, 0x3d	; 61
    ad44:	fe b7       	in	r31, 0x3e	; 62
    ad46:	92 83       	std	Z+2, r25	; 0x02
    ad48:	81 83       	std	Z+1, r24	; 0x01
    ad4a:	81 e0       	ldi	r24, 0x01	; 1
    ad4c:	9a e0       	ldi	r25, 0x0A	; 10
    ad4e:	94 83       	std	Z+4, r25	; 0x04
    ad50:	83 83       	std	Z+3, r24	; 0x03
    ad52:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    ad56:	0f 90       	pop	r0
    ad58:	0f 90       	pop	r0
    ad5a:	0f 90       	pop	r0
    ad5c:	0f 90       	pop	r0
		      }
		  iSend=0;
    ad5e:	10 92 91 02 	sts	0x0291, r1
    ad62:	10 92 90 02 	sts	0x0290, r1
		  iLoop=0;
    ad66:	10 92 8d 02 	sts	0x028D, r1
    ad6a:	10 92 8c 02 	sts	0x028C, r1
		  LSend=strlen(strPrint);
    ad6e:	e5 e9       	ldi	r30, 0x95	; 149
    ad70:	f2 e0       	ldi	r31, 0x02	; 2
    ad72:	01 90       	ld	r0, Z+
    ad74:	00 20       	and	r0, r0
    ad76:	e9 f7       	brne	.-6      	; 0xad72 <PrintIdle+0x1b4>
    ad78:	31 97       	sbiw	r30, 0x01	; 1
    ad7a:	e5 59       	subi	r30, 0x95	; 149
    ad7c:	f2 40       	sbci	r31, 0x02	; 2
    ad7e:	f0 93 8f 02 	sts	0x028F, r31
    ad82:	e0 93 8e 02 	sts	0x028E, r30
          stPrintIdle=piPrintDuplicate; 
    ad86:	85 e0       	ldi	r24, 0x05	; 5
    ad88:	12 c6       	rjmp	.+3108   	; 0xb9ae <PrintIdle+0xdf0>
	      break;
     case piPrintDuplicate:
		  if (iSend<LSend){
    ad8a:	20 91 90 02 	lds	r18, 0x0290
    ad8e:	30 91 91 02 	lds	r19, 0x0291
    ad92:	80 91 8e 02 	lds	r24, 0x028E
    ad96:	90 91 8f 02 	lds	r25, 0x028F
    ad9a:	28 17       	cp	r18, r24
    ad9c:	39 07       	cpc	r19, r25
    ad9e:	78 f4       	brcc	.+30     	; 0xadbe <PrintIdle+0x200>
		      iLoop++;
    ada0:	80 91 8c 02 	lds	r24, 0x028C
    ada4:	90 91 8d 02 	lds	r25, 0x028D
    ada8:	01 96       	adiw	r24, 0x01	; 1
    adaa:	90 93 8d 02 	sts	0x028D, r25
    adae:	80 93 8c 02 	sts	0x028C, r24
			  if((iLoop%PRINT_DELAY)==0){
				 TimPrintBusy=0;
    adb2:	10 92 cd 01 	sts	0x01CD, r1
    adb6:	10 92 cc 01 	sts	0x01CC, r1
                 stPrintIdle=piCheckPrintStatusDuplicate;
    adba:	86 e0       	ldi	r24, 0x06	; 6
    adbc:	f8 c5       	rjmp	.+3056   	; 0xb9ae <PrintIdle+0xdf0>
				 }
			  }
          else {
		     iSend=0;
    adbe:	10 92 91 02 	sts	0x0291, r1
    adc2:	10 92 90 02 	sts	0x0290, r1
		     stPrintIdle=piInitMessage;
    adc6:	87 e0       	ldi	r24, 0x07	; 7
    adc8:	f2 c5       	rjmp	.+3044   	; 0xb9ae <PrintIdle+0xdf0>
			 }
	      break;
     case piCheckPrintStatusDuplicate:
	      if (IsBusyPrint==False){
    adca:	80 91 c9 01 	lds	r24, 0x01C9
    adce:	88 23       	and	r24, r24
    add0:	09 f0       	breq	.+2      	; 0xadd4 <PrintIdle+0x216>
    add2:	e3 c5       	rjmp	.+3014   	; 0xb99a <PrintIdle+0xddc>
		      _uart(_COM_PRINTER,1,strPrint[iSend]);
    add4:	e0 91 90 02 	lds	r30, 0x0290
    add8:	f0 91 91 02 	lds	r31, 0x0291
    addc:	eb 56       	subi	r30, 0x6B	; 107
    adde:	fd 4f       	sbci	r31, 0xFD	; 253
    ade0:	61 e0       	ldi	r22, 0x01	; 1
    ade2:	40 81       	ld	r20, Z
    ade4:	0e 94 7a b2 	call	0x164f4	; 0x164f4 <_uart>
    ade8:	84 ec       	ldi	r24, 0xC4	; 196
    adea:	99 e0       	ldi	r25, 0x09	; 9
    adec:	01 97       	sbiw	r24, 0x01	; 1
    adee:	f1 f7       	brne	.-4      	; 0xadec <PrintIdle+0x22e>
			  _delay_ms(10);
		      iSend++;
    adf0:	80 91 90 02 	lds	r24, 0x0290
    adf4:	90 91 91 02 	lds	r25, 0x0291
    adf8:	01 96       	adiw	r24, 0x01	; 1
    adfa:	90 93 91 02 	sts	0x0291, r25
    adfe:	80 93 90 02 	sts	0x0290, r24
		      stPrintIdle=piPrintDuplicate;
    ae02:	85 e0       	ldi	r24, 0x05	; 5
    ae04:	c8 c5       	rjmp	.+2960   	; 0xb996 <PrintIdle+0xdd8>
		      stPrintIdle=piFinishPrintIdle;
			  }
	      break;

     case piInitMessage:
	      iSend=0;iLoop=0;
    ae06:	10 92 91 02 	sts	0x0291, r1
    ae0a:	10 92 90 02 	sts	0x0290, r1
    ae0e:	10 92 8d 02 	sts	0x028D, r1
    ae12:	10 92 8c 02 	sts	0x028C, r1
		  iMessage=0;
    ae16:	10 92 94 02 	sts	0x0294, r1
		  switch(MOPType){
    ae1a:	80 91 cf 01 	lds	r24, 0x01CF
    ae1e:	83 30       	cpi	r24, 0x03	; 3
    ae20:	81 f0       	breq	.+32     	; 0xae42 <PrintIdle+0x284>
    ae22:	84 30       	cpi	r24, 0x04	; 4
    ae24:	28 f4       	brcc	.+10     	; 0xae30 <PrintIdle+0x272>
    ae26:	81 30       	cpi	r24, 0x01	; 1
    ae28:	61 f0       	breq	.+24     	; 0xae42 <PrintIdle+0x284>
    ae2a:	82 30       	cpi	r24, 0x02	; 2
    ae2c:	40 f4       	brcc	.+16     	; 0xae3e <PrintIdle+0x280>
    ae2e:	10 c0       	rjmp	.+32     	; 0xae50 <PrintIdle+0x292>
    ae30:	88 30       	cpi	r24, 0x08	; 8
    ae32:	49 f0       	breq	.+18     	; 0xae46 <PrintIdle+0x288>
    ae34:	89 30       	cpi	r24, 0x09	; 9
    ae36:	61 f0       	breq	.+24     	; 0xae50 <PrintIdle+0x292>
    ae38:	87 30       	cpi	r24, 0x07	; 7
    ae3a:	51 f4       	brne	.+20     	; 0xae50 <PrintIdle+0x292>
    ae3c:	02 c0       	rjmp	.+4      	; 0xae42 <PrintIdle+0x284>
		  case MOP_CASH:
		       MessageLine=10;
			   PrintCopy=1;
		       break;
          case MOP_CREDIT_CARD:
		       MessageLine=10;
    ae3e:	8a e0       	ldi	r24, 0x0A	; 10
    ae40:	03 c0       	rjmp	.+6      	; 0xae48 <PrintIdle+0x28a>
          case MOP_LOCAL_ACCOUNT:
		       MessageLine=20;
			   PrintCopy=2;
		       break;
          case MOP_VOUCHER:
		       MessageLine=20;
    ae42:	84 e1       	ldi	r24, 0x14	; 20
    ae44:	01 c0       	rjmp	.+2      	; 0xae48 <PrintIdle+0x28a>
			   PrintCopy=2;
		       break;
          case MOP_PUMP_TEST:
		       MessageLine=12;
    ae46:	8c e0       	ldi	r24, 0x0C	; 12
    ae48:	80 93 93 02 	sts	0x0293, r24
			   PrintCopy=2;
    ae4c:	82 e0       	ldi	r24, 0x02	; 2
    ae4e:	04 c0       	rjmp	.+8      	; 0xae58 <PrintIdle+0x29a>
          case MOP_VOID_CARD:
		       MessageLine=10;
			   PrintCopy=1;
		       break;          
          default:
		       MessageLine=10;
    ae50:	8a e0       	ldi	r24, 0x0A	; 10
    ae52:	80 93 93 02 	sts	0x0293, r24
			   PrintCopy=1;
    ae56:	81 e0       	ldi	r24, 0x01	; 1
    ae58:	80 93 8a 02 	sts	0x028A, r24
		       break; 
		  }
		  //LoyaltyDetection
          if ((strlen(strLoyCardID)>0)&&(SpaceOnly(strLoyCardID)==False)){
    ae5c:	80 91 c7 04 	lds	r24, 0x04C7
    ae60:	88 23       	and	r24, r24
    ae62:	49 f0       	breq	.+18     	; 0xae76 <PrintIdle+0x2b8>
    ae64:	87 ec       	ldi	r24, 0xC7	; 199
    ae66:	94 e0       	ldi	r25, 0x04	; 4
    ae68:	0e 94 b8 22 	call	0x4570	; 0x4570 <SpaceOnly>
    ae6c:	88 23       	and	r24, r24
    ae6e:	19 f4       	brne	.+6      	; 0xae76 <PrintIdle+0x2b8>
		       MessageLine=33;
    ae70:	81 e2       	ldi	r24, 0x21	; 33
    ae72:	80 93 93 02 	sts	0x0293, r24
		  }
          //stPrintIdle=piLoadMessage;
		  stPrintIdle=piFormatingMessage;
    ae76:	88 e0       	ldi	r24, 0x08	; 8
    ae78:	9a c5       	rjmp	.+2868   	; 0xb9ae <PrintIdle+0xdf0>
	      break;
     case piFormatingMessage:
	      if (iPrinted==0){
    ae7a:	80 91 8b 02 	lds	r24, 0x028B
    ae7e:	88 23       	and	r24, r24
    ae80:	09 f0       	breq	.+2      	; 0xae84 <PrintIdle+0x2c6>
    ae82:	c8 c4       	rjmp	.+2448   	; 0xb814 <PrintIdle+0xc56>

		      FormatDate(DATE_LONG_YEAR,strDate);
    ae84:	61 e5       	ldi	r22, 0x51	; 81
    ae86:	79 e0       	ldi	r23, 0x09	; 9
    ae88:	0e 94 8c 23 	call	0x4718	; 0x4718 <FormatDate>
              RemZeroLead(strIslandID);
    ae8c:	8f ec       	ldi	r24, 0xCF	; 207
    ae8e:	9a e0       	ldi	r25, 0x0A	; 10
    ae90:	0e 94 dd 23 	call	0x47ba	; 0x47ba <RemZeroLead>
			  RemZeroLead(strFIP_ID);
    ae94:	8c e9       	ldi	r24, 0x9C	; 156
    ae96:	99 e0       	ldi	r25, 0x09	; 9
    ae98:	0e 94 dd 23 	call	0x47ba	; 0x47ba <RemZeroLead>
		      RemZeroLead(strPrice);              
    ae9c:	81 e8       	ldi	r24, 0x81	; 129
    ae9e:	97 e0       	ldi	r25, 0x07	; 7
    aea0:	0e 94 dd 23 	call	0x47ba	; 0x47ba <RemZeroLead>
              if (IFType==IT_SLAVE)
    aea4:	80 91 10 01 	lds	r24, 0x0110
    aea8:	81 30       	cpi	r24, 0x01	; 1
    aeaa:	21 f4       	brne	.+8      	; 0xaeb4 <PrintIdle+0x2f6>
			      RemZeroLead(strVolume);
    aeac:	85 e5       	ldi	r24, 0x55	; 85
    aeae:	95 e0       	ldi	r25, 0x05	; 5
    aeb0:	0e 94 dd 23 	call	0x47ba	; 0x47ba <RemZeroLead>
              RemZeroLead(strAmount);
    aeb4:	8b e8       	ldi	r24, 0x8B	; 139
    aeb6:	9d e0       	ldi	r25, 0x0D	; 13
    aeb8:	0e 94 dd 23 	call	0x47ba	; 0x47ba <RemZeroLead>

			  RemDecimal(strPrice);
    aebc:	81 e8       	ldi	r24, 0x81	; 129
    aebe:	97 e0       	ldi	r25, 0x07	; 7
    aec0:	0e 94 d5 22 	call	0x45aa	; 0x45aa <RemDecimal>
			  RemDecimal(strAmount);
    aec4:	8b e8       	ldi	r24, 0x8B	; 139
    aec6:	9d e0       	ldi	r25, 0x0D	; 13
    aec8:	0e 94 d5 22 	call	0x45aa	; 0x45aa <RemDecimal>
	  
			  FormatCurrency(strPrice);
    aecc:	81 e8       	ldi	r24, 0x81	; 129
    aece:	97 e0       	ldi	r25, 0x07	; 7
    aed0:	0e 94 49 30 	call	0x6092	; 0x6092 <FormatCurrency>
			  FormatCurrency(strAmount);
    aed4:	8b e8       	ldi	r24, 0x8B	; 139
    aed6:	9d e0       	ldi	r25, 0x0D	; 13
    aed8:	0e 94 49 30 	call	0x6092	; 0x6092 <FormatCurrency>
              if (IFType==IT_SLAVE){
    aedc:	80 91 10 01 	lds	r24, 0x0110
    aee0:	81 30       	cpi	r24, 0x01	; 1
    aee2:	09 f0       	breq	.+2      	; 0xaee6 <PrintIdle+0x328>
    aee4:	97 c4       	rjmp	.+2350   	; 0xb814 <PrintIdle+0xc56>
		          RemSpaceLag(strCardID);
    aee6:	81 e6       	ldi	r24, 0x61	; 97
    aee8:	9d e0       	ldi	r25, 0x0D	; 13
    aeea:	0e 94 70 24 	call	0x48e0	; 0x48e0 <RemSpaceLag>
		          RemSpaceLag(strCardHolder);
    aeee:	84 e0       	ldi	r24, 0x04	; 4
    aef0:	95 e0       	ldi	r25, 0x05	; 5
    aef2:	0e 94 70 24 	call	0x48e0	; 0x48e0 <RemSpaceLag>
		          RemSpaceLag(strMOPName);
    aef6:	80 e6       	ldi	r24, 0x60	; 96
    aef8:	97 e0       	ldi	r25, 0x07	; 7
    aefa:	0e 94 70 24 	call	0x48e0	; 0x48e0 <RemSpaceLag>
		          RemSpaceLag(strLoyCardHolder);
    aefe:	84 ea       	ldi	r24, 0xA4	; 164
    af00:	94 e0       	ldi	r25, 0x04	; 4
    af02:	0e 94 70 24 	call	0x48e0	; 0x48e0 <RemSpaceLag>
		          RemSpaceLag(strCorporateID);
    af06:	85 ee       	ldi	r24, 0xE5	; 229
    af08:	9d e0       	ldi	r25, 0x0D	; 13
    af0a:	0e 94 70 24 	call	0x48e0	; 0x48e0 <RemSpaceLag>
		          RemSpaceLag(strCorporateName);
    af0e:	8d ea       	ldi	r24, 0xAD	; 173
    af10:	95 e0       	ldi	r25, 0x05	; 5
    af12:	0e 94 70 24 	call	0x48e0	; 0x48e0 <RemSpaceLag>
		          RemSpaceLag(strLoyRedeemPoints);
    af16:	8a e7       	ldi	r24, 0x7A	; 122
    af18:	95 e0       	ldi	r25, 0x05	; 5
    af1a:	0e 94 70 24 	call	0x48e0	; 0x48e0 <RemSpaceLag>
		          RemSpaceLag(strLoyCurrMonConsumeV);
    af1e:	88 ec       	ldi	r24, 0xC8	; 200
    af20:	9d e0       	ldi	r25, 0x0D	; 13
    af22:	0e 94 70 24 	call	0x48e0	; 0x48e0 <RemSpaceLag>
				  RemSpaceLag(strLoyCurrMonConsumeA);
    af26:	8e e5       	ldi	r24, 0x5E	; 94
    af28:	95 e0       	ldi	r25, 0x05	; 5
    af2a:	0e 94 70 24 	call	0x48e0	; 0x48e0 <RemSpaceLag>
		          FormatCurrency(strLoyCurrMonConsumeV);              
    af2e:	88 ec       	ldi	r24, 0xC8	; 200
    af30:	9d e0       	ldi	r25, 0x0D	; 13
    af32:	0e 94 49 30 	call	0x6092	; 0x6092 <FormatCurrency>
		          FormatCurrency(strLoyCurrMonConsumeA);
    af36:	8e e5       	ldi	r24, 0x5E	; 94
    af38:	95 e0       	ldi	r25, 0x05	; 5
    af3a:	0e 94 49 30 	call	0x6092	; 0x6092 <FormatCurrency>
    af3e:	6a c4       	rjmp	.+2260   	; 0xb814 <PrintIdle+0xc56>
			   }
		  }
          stPrintIdle=piLoadMessage;
	      break;
     case piLoadMessage:
	      switch(iMessage){
    af40:	80 91 94 02 	lds	r24, 0x0294
    af44:	e8 2f       	mov	r30, r24
    af46:	f0 e0       	ldi	r31, 0x00	; 0
    af48:	e5 32       	cpi	r30, 0x25	; 37
    af4a:	f1 05       	cpc	r31, r1
    af4c:	08 f0       	brcs	.+2      	; 0xaf50 <PrintIdle+0x392>
    af4e:	26 c4       	rjmp	.+2124   	; 0xb79c <PrintIdle+0xbde>
    af50:	e2 57       	subi	r30, 0x72	; 114
    af52:	ff 4f       	sbci	r31, 0xFF	; 255
    af54:	ee 0f       	add	r30, r30
    af56:	ff 1f       	adc	r31, r31
    af58:	05 90       	lpm	r0, Z+
    af5a:	f4 91       	lpm	r31, Z+
    af5c:	e0 2d       	mov	r30, r0
    af5e:	09 94       	ijmp
		  case 0:
		       CarriegeReturn();
    af60:	0e 94 c0 4b 	call	0x9780	; 0x9780 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("      Shift: %s  No.Trans: %s "),strShift,strTranNo);
    af64:	8d b7       	in	r24, 0x3d	; 61
    af66:	9e b7       	in	r25, 0x3e	; 62
    af68:	08 97       	sbiw	r24, 0x08	; 8
    af6a:	0f b6       	in	r0, 0x3f	; 63
    af6c:	f8 94       	cli
    af6e:	9e bf       	out	0x3e, r25	; 62
    af70:	0f be       	out	0x3f, r0	; 63
    af72:	8d bf       	out	0x3d, r24	; 61
    af74:	ed b7       	in	r30, 0x3d	; 61
    af76:	fe b7       	in	r31, 0x3e	; 62
    af78:	31 96       	adiw	r30, 0x01	; 1
    af7a:	85 e9       	ldi	r24, 0x95	; 149
    af7c:	92 e0       	ldi	r25, 0x02	; 2
    af7e:	ad b7       	in	r26, 0x3d	; 61
    af80:	be b7       	in	r27, 0x3e	; 62
    af82:	12 96       	adiw	r26, 0x02	; 2
    af84:	9c 93       	st	X, r25
    af86:	8e 93       	st	-X, r24
    af88:	11 97       	sbiw	r26, 0x01	; 1
    af8a:	82 ee       	ldi	r24, 0xE2	; 226
    af8c:	99 e0       	ldi	r25, 0x09	; 9
    af8e:	93 83       	std	Z+3, r25	; 0x03
    af90:	82 83       	std	Z+2, r24	; 0x02
    af92:	83 e4       	ldi	r24, 0x43	; 67
    af94:	9e e0       	ldi	r25, 0x0E	; 14
    af96:	95 83       	std	Z+5, r25	; 0x05
    af98:	84 83       	std	Z+4, r24	; 0x04
    af9a:	81 e6       	ldi	r24, 0x61	; 97
    af9c:	9e e0       	ldi	r25, 0x0E	; 14
    af9e:	1f c0       	rjmp	.+62     	; 0xafde <PrintIdle+0x420>
		       break;
		  case 1:
		       //FormatDate(strDate);
			   CarriegeReturn();
    afa0:	0e 94 c0 4b 	call	0x9780	; 0x9780 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("      Waktu: %s %s "),strDate,strTime);
    afa4:	8d b7       	in	r24, 0x3d	; 61
    afa6:	9e b7       	in	r25, 0x3e	; 62
    afa8:	08 97       	sbiw	r24, 0x08	; 8
    afaa:	0f b6       	in	r0, 0x3f	; 63
    afac:	f8 94       	cli
    afae:	9e bf       	out	0x3e, r25	; 62
    afb0:	0f be       	out	0x3f, r0	; 63
    afb2:	8d bf       	out	0x3d, r24	; 61
    afb4:	ed b7       	in	r30, 0x3d	; 61
    afb6:	fe b7       	in	r31, 0x3e	; 62
    afb8:	31 96       	adiw	r30, 0x01	; 1
    afba:	85 e9       	ldi	r24, 0x95	; 149
    afbc:	92 e0       	ldi	r25, 0x02	; 2
    afbe:	ad b7       	in	r26, 0x3d	; 61
    afc0:	be b7       	in	r27, 0x3e	; 62
    afc2:	12 96       	adiw	r26, 0x02	; 2
    afc4:	9c 93       	st	X, r25
    afc6:	8e 93       	st	-X, r24
    afc8:	11 97       	sbiw	r26, 0x01	; 1
    afca:	8e ec       	ldi	r24, 0xCE	; 206
    afcc:	99 e0       	ldi	r25, 0x09	; 9
    afce:	93 83       	std	Z+3, r25	; 0x03
    afd0:	82 83       	std	Z+2, r24	; 0x02
    afd2:	81 e5       	ldi	r24, 0x51	; 81
    afd4:	99 e0       	ldi	r25, 0x09	; 9
    afd6:	95 83       	std	Z+5, r25	; 0x05
    afd8:	84 83       	std	Z+4, r24	; 0x04
    afda:	8d e2       	ldi	r24, 0x2D	; 45
    afdc:	95 e0       	ldi	r25, 0x05	; 5
    afde:	97 83       	std	Z+7, r25	; 0x07
    afe0:	86 83       	std	Z+6, r24	; 0x06
    afe2:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    afe6:	ed b7       	in	r30, 0x3d	; 61
    afe8:	fe b7       	in	r31, 0x3e	; 62
    afea:	38 96       	adiw	r30, 0x08	; 8
    afec:	b9 c3       	rjmp	.+1906   	; 0xb760 <PrintIdle+0xba2>
		       break;
		  case 2:
		       CarriegeReturn();
    afee:	0e 94 c0 4b 	call	0x9780	; 0x9780 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("    ------------------------------"));
    aff2:	00 d0       	rcall	.+0      	; 0xaff4 <PrintIdle+0x436>
    aff4:	00 d0       	rcall	.+0      	; 0xaff6 <PrintIdle+0x438>
    aff6:	85 e9       	ldi	r24, 0x95	; 149
    aff8:	92 e0       	ldi	r25, 0x02	; 2
    affa:	ad b7       	in	r26, 0x3d	; 61
    affc:	be b7       	in	r27, 0x3e	; 62
    affe:	12 96       	adiw	r26, 0x02	; 2
    b000:	9c 93       	st	X, r25
    b002:	8e 93       	st	-X, r24
    b004:	11 97       	sbiw	r26, 0x01	; 1
    b006:	8b ea       	ldi	r24, 0xAB	; 171
    b008:	99 e0       	ldi	r25, 0x09	; 9
    b00a:	be c3       	rjmp	.+1916   	; 0xb788 <PrintIdle+0xbca>
		       break;
		  case 3:
		       CarriegeReturn();
    b00c:	0e 94 c0 4b 	call	0x9780	; 0x9780 <CarriegeReturn>
			   //RemZeroLead(strIslandID);
			   //RemZeroLead(strFIP_ID);
		       sprintf_P(strPrint,PSTR("      Pulau/Pompa : [%s]-%s"),strIslandID,strFIP_ID);
    b010:	ed b7       	in	r30, 0x3d	; 61
    b012:	fe b7       	in	r31, 0x3e	; 62
    b014:	38 97       	sbiw	r30, 0x08	; 8
    b016:	0f b6       	in	r0, 0x3f	; 63
    b018:	f8 94       	cli
    b01a:	fe bf       	out	0x3e, r31	; 62
    b01c:	0f be       	out	0x3f, r0	; 63
    b01e:	ed bf       	out	0x3d, r30	; 61
    b020:	31 96       	adiw	r30, 0x01	; 1
    b022:	85 e9       	ldi	r24, 0x95	; 149
    b024:	92 e0       	ldi	r25, 0x02	; 2
    b026:	ad b7       	in	r26, 0x3d	; 61
    b028:	be b7       	in	r27, 0x3e	; 62
    b02a:	12 96       	adiw	r26, 0x02	; 2
    b02c:	9c 93       	st	X, r25
    b02e:	8e 93       	st	-X, r24
    b030:	11 97       	sbiw	r26, 0x01	; 1
    b032:	8f e8       	ldi	r24, 0x8F	; 143
    b034:	99 e0       	ldi	r25, 0x09	; 9
    b036:	93 83       	std	Z+3, r25	; 0x03
    b038:	82 83       	std	Z+2, r24	; 0x02
    b03a:	8f ec       	ldi	r24, 0xCF	; 207
    b03c:	9a e0       	ldi	r25, 0x0A	; 10
    b03e:	95 83       	std	Z+5, r25	; 0x05
    b040:	84 83       	std	Z+4, r24	; 0x04
    b042:	8c e9       	ldi	r24, 0x9C	; 156
    b044:	99 e0       	ldi	r25, 0x09	; 9
    b046:	cb cf       	rjmp	.-106    	; 0xafde <PrintIdle+0x420>
		       break;
		  case 4:
		       CarriegeReturn();
    b048:	0e 94 c0 4b 	call	0x9780	; 0x9780 <CarriegeReturn>
			   sprintf_P(strPrint,PSTR("      Produk      : %s"),strDescription);
    b04c:	00 d0       	rcall	.+0      	; 0xb04e <PrintIdle+0x490>
    b04e:	00 d0       	rcall	.+0      	; 0xb050 <PrintIdle+0x492>
    b050:	00 d0       	rcall	.+0      	; 0xb052 <PrintIdle+0x494>
    b052:	ed b7       	in	r30, 0x3d	; 61
    b054:	fe b7       	in	r31, 0x3e	; 62
    b056:	31 96       	adiw	r30, 0x01	; 1
    b058:	85 e9       	ldi	r24, 0x95	; 149
    b05a:	92 e0       	ldi	r25, 0x02	; 2
    b05c:	ad b7       	in	r26, 0x3d	; 61
    b05e:	be b7       	in	r27, 0x3e	; 62
    b060:	12 96       	adiw	r26, 0x02	; 2
    b062:	9c 93       	st	X, r25
    b064:	8e 93       	st	-X, r24
    b066:	11 97       	sbiw	r26, 0x01	; 1
    b068:	88 e7       	ldi	r24, 0x78	; 120
    b06a:	99 e0       	ldi	r25, 0x09	; 9
    b06c:	93 83       	std	Z+3, r25	; 0x03
    b06e:	82 83       	std	Z+2, r24	; 0x02
    b070:	81 e1       	ldi	r24, 0x11	; 17
    b072:	9a e0       	ldi	r25, 0x0A	; 10
    b074:	6e c3       	rjmp	.+1756   	; 0xb752 <PrintIdle+0xb94>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    b076:	e1 99       	sbic	0x1c, 1	; 28
    b078:	fe cf       	rjmp	.-4      	; 0xb076 <PrintIdle+0x4b8>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    b07a:	81 ec       	ldi	r24, 0xC1	; 193
    b07c:	93 e0       	ldi	r25, 0x03	; 3
    b07e:	9f bb       	out	0x1f, r25	; 31
    b080:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    b082:	e0 9a       	sbi	0x1c, 0	; 28
    b084:	8d b3       	in	r24, 0x1d	; 29
    b086:	c5 e9       	ldi	r28, 0x95	; 149
    b088:	d2 e0       	ldi	r29, 0x02	; 2
		       break;
		  case 5:
		       //RemZeroLead(strPrice);
               //FormatCurrency(strPrice);
               if (eeprom_read_byte(&DefPrintMoney)==True){
    b08a:	81 30       	cpi	r24, 0x01	; 1
    b08c:	a9 f4       	brne	.+42     	; 0xb0b8 <PrintIdle+0x4fa>
			   	   CarriegeReturn();
    b08e:	0e 94 c0 4b 	call	0x9780	; 0x9780 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("      Harga/L     : Rp.%s"),strPrice);
    b092:	00 d0       	rcall	.+0      	; 0xb094 <PrintIdle+0x4d6>
    b094:	00 d0       	rcall	.+0      	; 0xb096 <PrintIdle+0x4d8>
    b096:	00 d0       	rcall	.+0      	; 0xb098 <PrintIdle+0x4da>
    b098:	ed b7       	in	r30, 0x3d	; 61
    b09a:	fe b7       	in	r31, 0x3e	; 62
    b09c:	31 96       	adiw	r30, 0x01	; 1
    b09e:	ad b7       	in	r26, 0x3d	; 61
    b0a0:	be b7       	in	r27, 0x3e	; 62
    b0a2:	12 96       	adiw	r26, 0x02	; 2
    b0a4:	dc 93       	st	X, r29
    b0a6:	ce 93       	st	-X, r28
    b0a8:	11 97       	sbiw	r26, 0x01	; 1
    b0aa:	8e e5       	ldi	r24, 0x5E	; 94
    b0ac:	99 e0       	ldi	r25, 0x09	; 9
    b0ae:	93 83       	std	Z+3, r25	; 0x03
    b0b0:	82 83       	std	Z+2, r24	; 0x02
    b0b2:	81 e8       	ldi	r24, 0x81	; 129
    b0b4:	97 e0       	ldi	r25, 0x07	; 7
    b0b6:	4d c3       	rjmp	.+1690   	; 0xb752 <PrintIdle+0xb94>
			   }else sprintf_P(strPrint,PSTR(""));
    b0b8:	00 d0       	rcall	.+0      	; 0xb0ba <PrintIdle+0x4fc>
    b0ba:	00 d0       	rcall	.+0      	; 0xb0bc <PrintIdle+0x4fe>
    b0bc:	ad b7       	in	r26, 0x3d	; 61
    b0be:	be b7       	in	r27, 0x3e	; 62
    b0c0:	12 96       	adiw	r26, 0x02	; 2
    b0c2:	dc 93       	st	X, r29
    b0c4:	ce 93       	st	-X, r28
    b0c6:	11 97       	sbiw	r26, 0x01	; 1
    b0c8:	8d e5       	ldi	r24, 0x5D	; 93
    b0ca:	99 e0       	ldi	r25, 0x09	; 9
    b0cc:	5d c3       	rjmp	.+1722   	; 0xb788 <PrintIdle+0xbca>

		       break;
		  case 6:
		       //RemZeroLead(strVolume);
		       CarriegeReturn();
    b0ce:	0e 94 c0 4b 	call	0x9780	; 0x9780 <CarriegeReturn>
			   sprintf_P(strPrint,PSTR("      Jml Liter   : %s L"),strVolume);
    b0d2:	00 d0       	rcall	.+0      	; 0xb0d4 <PrintIdle+0x516>
    b0d4:	00 d0       	rcall	.+0      	; 0xb0d6 <PrintIdle+0x518>
    b0d6:	00 d0       	rcall	.+0      	; 0xb0d8 <PrintIdle+0x51a>
    b0d8:	ed b7       	in	r30, 0x3d	; 61
    b0da:	fe b7       	in	r31, 0x3e	; 62
    b0dc:	31 96       	adiw	r30, 0x01	; 1
    b0de:	85 e9       	ldi	r24, 0x95	; 149
    b0e0:	92 e0       	ldi	r25, 0x02	; 2
    b0e2:	ad b7       	in	r26, 0x3d	; 61
    b0e4:	be b7       	in	r27, 0x3e	; 62
    b0e6:	12 96       	adiw	r26, 0x02	; 2
    b0e8:	9c 93       	st	X, r25
    b0ea:	8e 93       	st	-X, r24
    b0ec:	11 97       	sbiw	r26, 0x01	; 1
    b0ee:	84 e4       	ldi	r24, 0x44	; 68
    b0f0:	99 e0       	ldi	r25, 0x09	; 9
    b0f2:	93 83       	std	Z+3, r25	; 0x03
    b0f4:	82 83       	std	Z+2, r24	; 0x02
    b0f6:	85 e5       	ldi	r24, 0x55	; 85
    b0f8:	95 e0       	ldi	r25, 0x05	; 5
    b0fa:	2b c3       	rjmp	.+1622   	; 0xb752 <PrintIdle+0xb94>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    b0fc:	e1 99       	sbic	0x1c, 1	; 28
    b0fe:	fe cf       	rjmp	.-4      	; 0xb0fc <PrintIdle+0x53e>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    b100:	81 ec       	ldi	r24, 0xC1	; 193
    b102:	93 e0       	ldi	r25, 0x03	; 3
    b104:	9f bb       	out	0x1f, r25	; 31
    b106:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    b108:	e0 9a       	sbi	0x1c, 0	; 28
    b10a:	8d b3       	in	r24, 0x1d	; 29
    b10c:	c5 e9       	ldi	r28, 0x95	; 149
    b10e:	d2 e0       	ldi	r29, 0x02	; 2
		       break;
		  case 7:
		       //RemZeroLead(strAmount);		       
			   //FormatCurrency(strAmount);
               if (eeprom_read_byte(&DefPrintMoney)==True){
    b110:	81 30       	cpi	r24, 0x01	; 1
    b112:	a9 f4       	brne	.+42     	; 0xb13e <PrintIdle+0x580>
			   	   CarriegeReturn();
    b114:	0e 94 c0 4b 	call	0x9780	; 0x9780 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("      Jml Rupiah  : Rp.%s"),strAmount);
    b118:	00 d0       	rcall	.+0      	; 0xb11a <PrintIdle+0x55c>
    b11a:	00 d0       	rcall	.+0      	; 0xb11c <PrintIdle+0x55e>
    b11c:	00 d0       	rcall	.+0      	; 0xb11e <PrintIdle+0x560>
    b11e:	ed b7       	in	r30, 0x3d	; 61
    b120:	fe b7       	in	r31, 0x3e	; 62
    b122:	31 96       	adiw	r30, 0x01	; 1
    b124:	ad b7       	in	r26, 0x3d	; 61
    b126:	be b7       	in	r27, 0x3e	; 62
    b128:	12 96       	adiw	r26, 0x02	; 2
    b12a:	dc 93       	st	X, r29
    b12c:	ce 93       	st	-X, r28
    b12e:	11 97       	sbiw	r26, 0x01	; 1
    b130:	8a e2       	ldi	r24, 0x2A	; 42
    b132:	99 e0       	ldi	r25, 0x09	; 9
    b134:	93 83       	std	Z+3, r25	; 0x03
    b136:	82 83       	std	Z+2, r24	; 0x02
    b138:	8b e8       	ldi	r24, 0x8B	; 139
    b13a:	9d e0       	ldi	r25, 0x0D	; 13
    b13c:	0a c3       	rjmp	.+1556   	; 0xb752 <PrintIdle+0xb94>
			   }else sprintf_P(strPrint,PSTR(""));
    b13e:	00 d0       	rcall	.+0      	; 0xb140 <PrintIdle+0x582>
    b140:	00 d0       	rcall	.+0      	; 0xb142 <PrintIdle+0x584>
    b142:	ad b7       	in	r26, 0x3d	; 61
    b144:	be b7       	in	r27, 0x3e	; 62
    b146:	12 96       	adiw	r26, 0x02	; 2
    b148:	dc 93       	st	X, r29
    b14a:	ce 93       	st	-X, r28
    b14c:	11 97       	sbiw	r26, 0x01	; 1
    b14e:	89 e2       	ldi	r24, 0x29	; 41
    b150:	99 e0       	ldi	r25, 0x09	; 9
    b152:	1a c3       	rjmp	.+1588   	; 0xb788 <PrintIdle+0xbca>

		       break;
		  case 8:
		       if ((strlen(strLicPlate)>0)&&(SpaceOnly(strLicPlate)==False)){
    b154:	c2 ed       	ldi	r28, 0xD2	; 210
    b156:	da e0       	ldi	r29, 0x0A	; 10
    b158:	80 91 d2 0a 	lds	r24, 0x0AD2
    b15c:	88 23       	and	r24, r24
    b15e:	09 f4       	brne	.+2      	; 0xb162 <PrintIdle+0x5a4>
    b160:	18 c2       	rjmp	.+1072   	; 0xb592 <PrintIdle+0x9d4>
    b162:	ce 01       	movw	r24, r28
    b164:	0e 94 b8 22 	call	0x4570	; 0x4570 <SpaceOnly>
    b168:	88 23       	and	r24, r24
    b16a:	09 f0       	breq	.+2      	; 0xb16e <PrintIdle+0x5b0>
    b16c:	12 c2       	rjmp	.+1060   	; 0xb592 <PrintIdle+0x9d4>
			       CarriegeReturn();
    b16e:	0e 94 c0 4b 	call	0x9780	; 0x9780 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("      No.Polisi   : %s"),strLicPlate);
    b172:	00 d0       	rcall	.+0      	; 0xb174 <PrintIdle+0x5b6>
    b174:	00 d0       	rcall	.+0      	; 0xb176 <PrintIdle+0x5b8>
    b176:	00 d0       	rcall	.+0      	; 0xb178 <PrintIdle+0x5ba>
    b178:	ed b7       	in	r30, 0x3d	; 61
    b17a:	fe b7       	in	r31, 0x3e	; 62
    b17c:	31 96       	adiw	r30, 0x01	; 1
    b17e:	85 e9       	ldi	r24, 0x95	; 149
    b180:	92 e0       	ldi	r25, 0x02	; 2
    b182:	ad b7       	in	r26, 0x3d	; 61
    b184:	be b7       	in	r27, 0x3e	; 62
    b186:	12 96       	adiw	r26, 0x02	; 2
    b188:	9c 93       	st	X, r25
    b18a:	8e 93       	st	-X, r24
    b18c:	11 97       	sbiw	r26, 0x01	; 1
    b18e:	82 e1       	ldi	r24, 0x12	; 18
    b190:	99 e0       	ldi	r25, 0x09	; 9
    b192:	1f c0       	rjmp	.+62     	; 0xb1d2 <PrintIdle+0x614>
                   ClearMem(strLicPlate);
				   }
               else ClearMem(strPrint);
		       break;
		  case 9:
		       if ((strlen(strOdometer)>0)&&(SpaceOnly(strOdometer)==False)){
    b194:	c3 ea       	ldi	r28, 0xA3	; 163
    b196:	d5 e0       	ldi	r29, 0x05	; 5
    b198:	80 91 a3 05 	lds	r24, 0x05A3
    b19c:	88 23       	and	r24, r24
    b19e:	09 f4       	brne	.+2      	; 0xb1a2 <PrintIdle+0x5e4>
    b1a0:	f8 c1       	rjmp	.+1008   	; 0xb592 <PrintIdle+0x9d4>
    b1a2:	ce 01       	movw	r24, r28
    b1a4:	0e 94 b8 22 	call	0x4570	; 0x4570 <SpaceOnly>
    b1a8:	88 23       	and	r24, r24
    b1aa:	09 f0       	breq	.+2      	; 0xb1ae <PrintIdle+0x5f0>
    b1ac:	f2 c1       	rjmp	.+996    	; 0xb592 <PrintIdle+0x9d4>
			       CarriegeReturn();
    b1ae:	0e 94 c0 4b 	call	0x9780	; 0x9780 <CarriegeReturn>
		           sprintf_P(strPrint,PSTR("      Odometer    : %s"),strOdometer);
    b1b2:	00 d0       	rcall	.+0      	; 0xb1b4 <PrintIdle+0x5f6>
    b1b4:	00 d0       	rcall	.+0      	; 0xb1b6 <PrintIdle+0x5f8>
    b1b6:	00 d0       	rcall	.+0      	; 0xb1b8 <PrintIdle+0x5fa>
    b1b8:	ed b7       	in	r30, 0x3d	; 61
    b1ba:	fe b7       	in	r31, 0x3e	; 62
    b1bc:	31 96       	adiw	r30, 0x01	; 1
    b1be:	85 e9       	ldi	r24, 0x95	; 149
    b1c0:	92 e0       	ldi	r25, 0x02	; 2
    b1c2:	ad b7       	in	r26, 0x3d	; 61
    b1c4:	be b7       	in	r27, 0x3e	; 62
    b1c6:	12 96       	adiw	r26, 0x02	; 2
    b1c8:	9c 93       	st	X, r25
    b1ca:	8e 93       	st	-X, r24
    b1cc:	11 97       	sbiw	r26, 0x01	; 1
    b1ce:	8b ef       	ldi	r24, 0xFB	; 251
    b1d0:	98 e0       	ldi	r25, 0x08	; 8
    b1d2:	93 83       	std	Z+3, r25	; 0x03
    b1d4:	82 83       	std	Z+2, r24	; 0x02
    b1d6:	d5 83       	std	Z+5, r29	; 0x05
    b1d8:	c4 83       	std	Z+4, r28	; 0x04
    b1da:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
				   ClearMem(strOdometer);
    b1de:	ed b7       	in	r30, 0x3d	; 61
    b1e0:	fe b7       	in	r31, 0x3e	; 62
    b1e2:	36 96       	adiw	r30, 0x06	; 6
    b1e4:	0f b6       	in	r0, 0x3f	; 63
    b1e6:	f8 94       	cli
    b1e8:	fe bf       	out	0x3e, r31	; 62
    b1ea:	0f be       	out	0x3f, r0	; 63
    b1ec:	ed bf       	out	0x3d, r30	; 61
    b1ee:	ce 01       	movw	r24, r28
    b1f0:	0e 94 a6 ad 	call	0x15b4c	; 0x15b4c <ClearMem>
    b1f4:	d3 c2       	rjmp	.+1446   	; 0xb79c <PrintIdle+0xbde>
			   }else ClearMem(strPrint);
		       break;
		  case 10:
		       CarriegeReturn();
    b1f6:	0e 94 c0 4b 	call	0x9780	; 0x9780 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("    ------------------------------"));
    b1fa:	00 d0       	rcall	.+0      	; 0xb1fc <PrintIdle+0x63e>
    b1fc:	00 d0       	rcall	.+0      	; 0xb1fe <PrintIdle+0x640>
    b1fe:	85 e9       	ldi	r24, 0x95	; 149
    b200:	92 e0       	ldi	r25, 0x02	; 2
    b202:	ad b7       	in	r26, 0x3d	; 61
    b204:	be b7       	in	r27, 0x3e	; 62
    b206:	12 96       	adiw	r26, 0x02	; 2
    b208:	9c 93       	st	X, r25
    b20a:	8e 93       	st	-X, r24
    b20c:	11 97       	sbiw	r26, 0x01	; 1
    b20e:	88 ed       	ldi	r24, 0xD8	; 216
    b210:	98 e0       	ldi	r25, 0x08	; 8
    b212:	ba c2       	rjmp	.+1396   	; 0xb788 <PrintIdle+0xbca>
		       break;
          //ChangeMOPPrint
		  case 11:
			   if ((MOPType==MOP_LOCAL_ACCOUNT)||(MOPType==MOP_DEBIT_CARD)||(MOPType==MOP_LOYALTY_LOCAL_ACCOUNT)){
    b214:	80 91 cf 01 	lds	r24, 0x01CF
    b218:	81 30       	cpi	r24, 0x01	; 1
    b21a:	21 f0       	breq	.+8      	; 0xb224 <PrintIdle+0x666>
    b21c:	83 30       	cpi	r24, 0x03	; 3
    b21e:	11 f0       	breq	.+4      	; 0xb224 <PrintIdle+0x666>
    b220:	86 30       	cpi	r24, 0x06	; 6
    b222:	b9 f4       	brne	.+46     	; 0xb252 <PrintIdle+0x694>
			       //RemSpaceLag(strCardID);
				   CarriegeReturn();
    b224:	0e 94 c0 4b 	call	0x9780	; 0x9780 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("    Kartu ID : %s"),strCardID);
    b228:	00 d0       	rcall	.+0      	; 0xb22a <PrintIdle+0x66c>
    b22a:	00 d0       	rcall	.+0      	; 0xb22c <PrintIdle+0x66e>
    b22c:	00 d0       	rcall	.+0      	; 0xb22e <PrintIdle+0x670>
    b22e:	ed b7       	in	r30, 0x3d	; 61
    b230:	fe b7       	in	r31, 0x3e	; 62
    b232:	31 96       	adiw	r30, 0x01	; 1
    b234:	85 e9       	ldi	r24, 0x95	; 149
    b236:	92 e0       	ldi	r25, 0x02	; 2
    b238:	ad b7       	in	r26, 0x3d	; 61
    b23a:	be b7       	in	r27, 0x3e	; 62
    b23c:	12 96       	adiw	r26, 0x02	; 2
    b23e:	9c 93       	st	X, r25
    b240:	8e 93       	st	-X, r24
    b242:	11 97       	sbiw	r26, 0x01	; 1
    b244:	86 ec       	ldi	r24, 0xC6	; 198
    b246:	98 e0       	ldi	r25, 0x08	; 8
    b248:	93 83       	std	Z+3, r25	; 0x03
    b24a:	82 83       	std	Z+2, r24	; 0x02
    b24c:	81 e6       	ldi	r24, 0x61	; 97
    b24e:	9d e0       	ldi	r25, 0x0D	; 13
    b250:	18 c0       	rjmp	.+48     	; 0xb282 <PrintIdle+0x6c4>
				   IsSignedField=True;
				   }
	           else
			   if (MOPType==MOP_VOUCHER){
    b252:	87 30       	cpi	r24, 0x07	; 7
    b254:	f1 f4       	brne	.+60     	; 0xb292 <PrintIdle+0x6d4>
			       //RemSpaceLag(strCardID);
				   CarriegeReturn();
    b256:	0e 94 c0 4b 	call	0x9780	; 0x9780 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("    Voucher No: %s"),strVoucherNum);
    b25a:	00 d0       	rcall	.+0      	; 0xb25c <PrintIdle+0x69e>
    b25c:	00 d0       	rcall	.+0      	; 0xb25e <PrintIdle+0x6a0>
    b25e:	00 d0       	rcall	.+0      	; 0xb260 <PrintIdle+0x6a2>
    b260:	ed b7       	in	r30, 0x3d	; 61
    b262:	fe b7       	in	r31, 0x3e	; 62
    b264:	31 96       	adiw	r30, 0x01	; 1
    b266:	85 e9       	ldi	r24, 0x95	; 149
    b268:	92 e0       	ldi	r25, 0x02	; 2
    b26a:	ad b7       	in	r26, 0x3d	; 61
    b26c:	be b7       	in	r27, 0x3e	; 62
    b26e:	12 96       	adiw	r26, 0x02	; 2
    b270:	9c 93       	st	X, r25
    b272:	8e 93       	st	-X, r24
    b274:	11 97       	sbiw	r26, 0x01	; 1
    b276:	83 eb       	ldi	r24, 0xB3	; 179
    b278:	98 e0       	ldi	r25, 0x08	; 8
    b27a:	93 83       	std	Z+3, r25	; 0x03
    b27c:	82 83       	std	Z+2, r24	; 0x02
    b27e:	87 e1       	ldi	r24, 0x17	; 23
    b280:	9e e0       	ldi	r25, 0x0E	; 14
    b282:	95 83       	std	Z+5, r25	; 0x05
    b284:	84 83       	std	Z+4, r24	; 0x04
    b286:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
				   IsSignedField=True;
    b28a:	81 e0       	ldi	r24, 0x01	; 1
    b28c:	80 93 92 02 	sts	0x0292, r24
    b290:	64 c2       	rjmp	.+1224   	; 0xb75a <PrintIdle+0xb9c>
    b292:	c5 e9       	ldi	r28, 0x95	; 149
    b294:	d2 e0       	ldi	r29, 0x02	; 2
				   }
			   else
			   if (MOPType==MOP_PUMP_TEST) {
    b296:	88 30       	cpi	r24, 0x08	; 8
    b298:	09 f0       	breq	.+2      	; 0xb29c <PrintIdle+0x6de>
    b29a:	a9 cf       	rjmp	.-174    	; 0xb1ee <PrintIdle+0x630>
			       CarriegeReturn();
    b29c:	0e 94 c0 4b 	call	0x9780	; 0x9780 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("          *** PUMP TEST ***       "));
    b2a0:	00 d0       	rcall	.+0      	; 0xb2a2 <PrintIdle+0x6e4>
    b2a2:	00 d0       	rcall	.+0      	; 0xb2a4 <PrintIdle+0x6e6>
    b2a4:	ad b7       	in	r26, 0x3d	; 61
    b2a6:	be b7       	in	r27, 0x3e	; 62
    b2a8:	12 96       	adiw	r26, 0x02	; 2
    b2aa:	dc 93       	st	X, r29
    b2ac:	ce 93       	st	-X, r28
    b2ae:	11 97       	sbiw	r26, 0x01	; 1
    b2b0:	80 e9       	ldi	r24, 0x90	; 144
    b2b2:	98 e0       	ldi	r25, 0x08	; 8
    b2b4:	14 96       	adiw	r26, 0x04	; 4
    b2b6:	9c 93       	st	X, r25
    b2b8:	8e 93       	st	-X, r24
    b2ba:	13 97       	sbiw	r26, 0x03	; 3
    b2bc:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
				   IsSignedField=False;
    b2c0:	10 92 92 02 	sts	0x0292, r1
    b2c4:	67 c2       	rjmp	.+1230   	; 0xb794 <PrintIdle+0xbd6>
				   }
               else ClearMem(strPrint);
		       break;
          case 12:
			   if (MOPType==MOP_LOCAL_ACCOUNT) {
    b2c6:	80 91 cf 01 	lds	r24, 0x01CF
    b2ca:	81 30       	cpi	r24, 0x01	; 1
    b2cc:	99 f4       	brne	.+38     	; 0xb2f4 <PrintIdle+0x736>
			       //RemSpaceLag(strCardHolder);
				   CarriegeReturn();
    b2ce:	0e 94 c0 4b 	call	0x9780	; 0x9780 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("    Nama     : %s"),strCardHolder);
    b2d2:	00 d0       	rcall	.+0      	; 0xb2d4 <PrintIdle+0x716>
    b2d4:	00 d0       	rcall	.+0      	; 0xb2d6 <PrintIdle+0x718>
    b2d6:	00 d0       	rcall	.+0      	; 0xb2d8 <PrintIdle+0x71a>
    b2d8:	ed b7       	in	r30, 0x3d	; 61
    b2da:	fe b7       	in	r31, 0x3e	; 62
    b2dc:	31 96       	adiw	r30, 0x01	; 1
    b2de:	85 e9       	ldi	r24, 0x95	; 149
    b2e0:	92 e0       	ldi	r25, 0x02	; 2
    b2e2:	ad b7       	in	r26, 0x3d	; 61
    b2e4:	be b7       	in	r27, 0x3e	; 62
    b2e6:	12 96       	adiw	r26, 0x02	; 2
    b2e8:	9c 93       	st	X, r25
    b2ea:	8e 93       	st	-X, r24
    b2ec:	11 97       	sbiw	r26, 0x01	; 1
    b2ee:	8e e7       	ldi	r24, 0x7E	; 126
    b2f0:	98 e0       	ldi	r25, 0x08	; 8
    b2f2:	3a c0       	rjmp	.+116    	; 0xb368 <PrintIdle+0x7aa>
				   }
               else 
               if (MOPType==MOP_DEBIT_CARD) {//EDCApprovalCode
    b2f4:	83 30       	cpi	r24, 0x03	; 3
    b2f6:	e9 f5       	brne	.+122    	; 0xb372 <PrintIdle+0x7b4>
			       if (IsPrintApprovalCode==True){
    b2f8:	80 91 b1 01 	lds	r24, 0x01B1
    b2fc:	81 30       	cpi	r24, 0x01	; 1
    b2fe:	11 f5       	brne	.+68     	; 0xb344 <PrintIdle+0x786>
				       IsPrintApprovalCode=False;
    b300:	10 92 b1 01 	sts	0x01B1, r1
					   FillChar(strCardHolder,0,sizeof(strCardHolder));
					   sprintf_P(strCardHolder,PSTR("%s  "),strApprovalCode);
    b304:	00 d0       	rcall	.+0      	; 0xb306 <PrintIdle+0x748>
    b306:	00 d0       	rcall	.+0      	; 0xb308 <PrintIdle+0x74a>
    b308:	00 d0       	rcall	.+0      	; 0xb30a <PrintIdle+0x74c>
    b30a:	ed b7       	in	r30, 0x3d	; 61
    b30c:	fe b7       	in	r31, 0x3e	; 62
    b30e:	31 96       	adiw	r30, 0x01	; 1
    b310:	84 e0       	ldi	r24, 0x04	; 4
    b312:	95 e0       	ldi	r25, 0x05	; 5
    b314:	ad b7       	in	r26, 0x3d	; 61
    b316:	be b7       	in	r27, 0x3e	; 62
    b318:	12 96       	adiw	r26, 0x02	; 2
    b31a:	9c 93       	st	X, r25
    b31c:	8e 93       	st	-X, r24
    b31e:	11 97       	sbiw	r26, 0x01	; 1
    b320:	89 e7       	ldi	r24, 0x79	; 121
    b322:	98 e0       	ldi	r25, 0x08	; 8
    b324:	93 83       	std	Z+3, r25	; 0x03
    b326:	82 83       	std	Z+2, r24	; 0x02
    b328:	84 ee       	ldi	r24, 0xE4	; 228
    b32a:	99 e0       	ldi	r25, 0x09	; 9
    b32c:	95 83       	std	Z+5, r25	; 0x05
    b32e:	84 83       	std	Z+4, r24	; 0x04
    b330:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    b334:	ed b7       	in	r30, 0x3d	; 61
    b336:	fe b7       	in	r31, 0x3e	; 62
    b338:	36 96       	adiw	r30, 0x06	; 6
    b33a:	0f b6       	in	r0, 0x3f	; 63
    b33c:	f8 94       	cli
    b33e:	fe bf       	out	0x3e, r31	; 62
    b340:	0f be       	out	0x3f, r0	; 63
    b342:	ed bf       	out	0x3d, r30	; 61
				   }
			       //RemSpaceLag(strCardHolder);
				   CarriegeReturn();
    b344:	0e 94 c0 4b 	call	0x9780	; 0x9780 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("    Appr Code: %s"),strCardHolder);
    b348:	00 d0       	rcall	.+0      	; 0xb34a <PrintIdle+0x78c>
    b34a:	00 d0       	rcall	.+0      	; 0xb34c <PrintIdle+0x78e>
    b34c:	00 d0       	rcall	.+0      	; 0xb34e <PrintIdle+0x790>
    b34e:	ed b7       	in	r30, 0x3d	; 61
    b350:	fe b7       	in	r31, 0x3e	; 62
    b352:	31 96       	adiw	r30, 0x01	; 1
    b354:	85 e9       	ldi	r24, 0x95	; 149
    b356:	92 e0       	ldi	r25, 0x02	; 2
    b358:	ad b7       	in	r26, 0x3d	; 61
    b35a:	be b7       	in	r27, 0x3e	; 62
    b35c:	12 96       	adiw	r26, 0x02	; 2
    b35e:	9c 93       	st	X, r25
    b360:	8e 93       	st	-X, r24
    b362:	11 97       	sbiw	r26, 0x01	; 1
    b364:	87 e6       	ldi	r24, 0x67	; 103
    b366:	98 e0       	ldi	r25, 0x08	; 8
    b368:	93 83       	std	Z+3, r25	; 0x03
    b36a:	82 83       	std	Z+2, r24	; 0x02
    b36c:	84 e0       	ldi	r24, 0x04	; 4
    b36e:	95 e0       	ldi	r25, 0x05	; 5
    b370:	f0 c1       	rjmp	.+992    	; 0xb752 <PrintIdle+0xb94>
				   }
               else
			   if (MOPType==MOP_VOUCHER){
    b372:	87 30       	cpi	r24, 0x07	; 7
    b374:	79 f4       	brne	.+30     	; 0xb394 <PrintIdle+0x7d6>
			       CarriegeReturn();
    b376:	0e 94 c0 4b 	call	0x9780	; 0x9780 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("  "));
    b37a:	00 d0       	rcall	.+0      	; 0xb37c <PrintIdle+0x7be>
    b37c:	00 d0       	rcall	.+0      	; 0xb37e <PrintIdle+0x7c0>
    b37e:	85 e9       	ldi	r24, 0x95	; 149
    b380:	92 e0       	ldi	r25, 0x02	; 2
    b382:	ad b7       	in	r26, 0x3d	; 61
    b384:	be b7       	in	r27, 0x3e	; 62
    b386:	12 96       	adiw	r26, 0x02	; 2
    b388:	9c 93       	st	X, r25
    b38a:	8e 93       	st	-X, r24
    b38c:	11 97       	sbiw	r26, 0x01	; 1
    b38e:	84 e6       	ldi	r24, 0x64	; 100
    b390:	98 e0       	ldi	r25, 0x08	; 8
    b392:	fa c1       	rjmp	.+1012   	; 0xb788 <PrintIdle+0xbca>
    b394:	c5 e9       	ldi	r28, 0x95	; 149
    b396:	d2 e0       	ldi	r29, 0x02	; 2
				   }
			   else
			   if (MOPType==MOP_PUMP_TEST) {
    b398:	88 30       	cpi	r24, 0x08	; 8
    b39a:	09 f0       	breq	.+2      	; 0xb39e <PrintIdle+0x7e0>
    b39c:	28 cf       	rjmp	.-432    	; 0xb1ee <PrintIdle+0x630>
			       CarriegeReturn();
    b39e:	0e 94 c0 4b 	call	0x9780	; 0x9780 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("                 "));
    b3a2:	00 d0       	rcall	.+0      	; 0xb3a4 <PrintIdle+0x7e6>
    b3a4:	00 d0       	rcall	.+0      	; 0xb3a6 <PrintIdle+0x7e8>
    b3a6:	ed b7       	in	r30, 0x3d	; 61
    b3a8:	fe b7       	in	r31, 0x3e	; 62
    b3aa:	d2 83       	std	Z+2, r29	; 0x02
    b3ac:	c1 83       	std	Z+1, r28	; 0x01
    b3ae:	82 e5       	ldi	r24, 0x52	; 82
    b3b0:	98 e0       	ldi	r25, 0x08	; 8
    b3b2:	25 c0       	rjmp	.+74     	; 0xb3fe <PrintIdle+0x840>
				   }
               else ClearMem(strPrint);
		       break;
          case 13:
		       if (IsSignedField==True){
    b3b4:	80 91 92 02 	lds	r24, 0x0292
    b3b8:	c5 e9       	ldi	r28, 0x95	; 149
    b3ba:	d2 e0       	ldi	r29, 0x02	; 2
    b3bc:	81 30       	cpi	r24, 0x01	; 1
    b3be:	09 f0       	breq	.+2      	; 0xb3c2 <PrintIdle+0x804>
    b3c0:	16 cf       	rjmp	.-468    	; 0xb1ee <PrintIdle+0x630>
			       CarriegeReturn();
    b3c2:	0e 94 c0 4b 	call	0x9780	; 0x9780 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("                      "));
    b3c6:	00 d0       	rcall	.+0      	; 0xb3c8 <PrintIdle+0x80a>
    b3c8:	00 d0       	rcall	.+0      	; 0xb3ca <PrintIdle+0x80c>
    b3ca:	ad b7       	in	r26, 0x3d	; 61
    b3cc:	be b7       	in	r27, 0x3e	; 62
    b3ce:	12 96       	adiw	r26, 0x02	; 2
    b3d0:	dc 93       	st	X, r29
    b3d2:	ce 93       	st	-X, r28
    b3d4:	11 97       	sbiw	r26, 0x01	; 1
    b3d6:	8b e3       	ldi	r24, 0x3B	; 59
    b3d8:	98 e0       	ldi	r25, 0x08	; 8
    b3da:	d6 c1       	rjmp	.+940    	; 0xb788 <PrintIdle+0xbca>
               }else ClearMem(strPrint);
		       break;
          case 14:
		       if (IsSignedField==True){
    b3dc:	80 91 92 02 	lds	r24, 0x0292
    b3e0:	c5 e9       	ldi	r28, 0x95	; 149
    b3e2:	d2 e0       	ldi	r29, 0x02	; 2
    b3e4:	81 30       	cpi	r24, 0x01	; 1
    b3e6:	09 f0       	breq	.+2      	; 0xb3ea <PrintIdle+0x82c>
    b3e8:	02 cf       	rjmp	.-508    	; 0xb1ee <PrintIdle+0x630>
			       CarriegeReturn();
    b3ea:	0e 94 c0 4b 	call	0x9780	; 0x9780 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("                      "));
    b3ee:	00 d0       	rcall	.+0      	; 0xb3f0 <PrintIdle+0x832>
    b3f0:	00 d0       	rcall	.+0      	; 0xb3f2 <PrintIdle+0x834>
    b3f2:	ed b7       	in	r30, 0x3d	; 61
    b3f4:	fe b7       	in	r31, 0x3e	; 62
    b3f6:	d2 83       	std	Z+2, r29	; 0x02
    b3f8:	c1 83       	std	Z+1, r28	; 0x01
    b3fa:	84 e2       	ldi	r24, 0x24	; 36
    b3fc:	98 e0       	ldi	r25, 0x08	; 8
    b3fe:	94 83       	std	Z+4, r25	; 0x04
    b400:	83 83       	std	Z+3, r24	; 0x03
    b402:	c6 c1       	rjmp	.+908    	; 0xb790 <PrintIdle+0xbd2>
			       //sprintf_P(strPrint,PSTR("                      "));
				   ClearMem(strPrint);
               }else ClearMem(strPrint);
		       break;
          case 17:
		       if (IsSignedField==True){
    b404:	80 91 92 02 	lds	r24, 0x0292
    b408:	c5 e9       	ldi	r28, 0x95	; 149
    b40a:	d2 e0       	ldi	r29, 0x02	; 2
    b40c:	81 30       	cpi	r24, 0x01	; 1
    b40e:	09 f0       	breq	.+2      	; 0xb412 <PrintIdle+0x854>
    b410:	ee ce       	rjmp	.-548    	; 0xb1ee <PrintIdle+0x630>
			       CarriegeReturn();
    b412:	0e 94 c0 4b 	call	0x9780	; 0x9780 <CarriegeReturn>
			       sprintf_P(strPrint,PSTR("    Tanda Tangan  (______________)"));
    b416:	00 d0       	rcall	.+0      	; 0xb418 <PrintIdle+0x85a>
    b418:	00 d0       	rcall	.+0      	; 0xb41a <PrintIdle+0x85c>
    b41a:	ad b7       	in	r26, 0x3d	; 61
    b41c:	be b7       	in	r27, 0x3e	; 62
    b41e:	12 96       	adiw	r26, 0x02	; 2
    b420:	dc 93       	st	X, r29
    b422:	ce 93       	st	-X, r28
    b424:	11 97       	sbiw	r26, 0x01	; 1
    b426:	81 e0       	ldi	r24, 0x01	; 1
    b428:	98 e0       	ldi	r25, 0x08	; 8
    b42a:	ae c1       	rjmp	.+860    	; 0xb788 <PrintIdle+0xbca>
               }else ClearMem(strPrint);
		       break;
          case 18:
		       if (IsSignedField==True){
    b42c:	80 91 92 02 	lds	r24, 0x0292
    b430:	81 30       	cpi	r24, 0x01	; 1
    b432:	09 f0       	breq	.+2      	; 0xb436 <PrintIdle+0x878>
    b434:	ae c0       	rjmp	.+348    	; 0xb592 <PrintIdle+0x9d4>
			       IsSignedField=False;
    b436:	10 92 92 02 	sts	0x0292, r1
    b43a:	ab c0       	rjmp	.+342    	; 0xb592 <PrintIdle+0x9d4>
			       //sprintf_P(strPrint,PSTR("                      "));
				   ClearMem(strPrint);
               }else ClearMem(strPrint);
		       break;
          case 19://PrintMOP Name
		       if (MOPType!=MOP_CASH){
    b43c:	80 91 cf 01 	lds	r24, 0x01CF
    b440:	c5 e9       	ldi	r28, 0x95	; 149
    b442:	d2 e0       	ldi	r29, 0x02	; 2
    b444:	88 23       	and	r24, r24
    b446:	09 f4       	brne	.+2      	; 0xb44a <PrintIdle+0x88c>
    b448:	d2 ce       	rjmp	.-604    	; 0xb1ee <PrintIdle+0x630>
			       CarriegeReturn();
    b44a:	0e 94 c0 4b 	call	0x9780	; 0x9780 <CarriegeReturn>
			       //RemSpaceLag(strMOPName);
			       sprintf_P(strPrint,PSTR("    .%s"),strMOPName);
    b44e:	00 d0       	rcall	.+0      	; 0xb450 <PrintIdle+0x892>
    b450:	00 d0       	rcall	.+0      	; 0xb452 <PrintIdle+0x894>
    b452:	00 d0       	rcall	.+0      	; 0xb454 <PrintIdle+0x896>
    b454:	ed b7       	in	r30, 0x3d	; 61
    b456:	fe b7       	in	r31, 0x3e	; 62
    b458:	31 96       	adiw	r30, 0x01	; 1
    b45a:	ad b7       	in	r26, 0x3d	; 61
    b45c:	be b7       	in	r27, 0x3e	; 62
    b45e:	12 96       	adiw	r26, 0x02	; 2
    b460:	dc 93       	st	X, r29
    b462:	ce 93       	st	-X, r28
    b464:	11 97       	sbiw	r26, 0x01	; 1
    b466:	89 ef       	ldi	r24, 0xF9	; 249
    b468:	97 e0       	ldi	r25, 0x07	; 7
    b46a:	93 83       	std	Z+3, r25	; 0x03
    b46c:	82 83       	std	Z+2, r24	; 0x02
    b46e:	80 e6       	ldi	r24, 0x60	; 96
    b470:	97 e0       	ldi	r25, 0x07	; 7
    b472:	6f c1       	rjmp	.+734    	; 0xb752 <PrintIdle+0xb94>
			   }else ClearMem(strPrint);
		       break;
		  case 20:
		       if (MOPType!=MOP_CASH){
    b474:	80 91 cf 01 	lds	r24, 0x01CF
    b478:	c5 e9       	ldi	r28, 0x95	; 149
    b47a:	d2 e0       	ldi	r29, 0x02	; 2
    b47c:	88 23       	and	r24, r24
    b47e:	09 f4       	brne	.+2      	; 0xb482 <PrintIdle+0x8c4>
    b480:	b6 ce       	rjmp	.-660    	; 0xb1ee <PrintIdle+0x630>
			       CarriegeReturn();
    b482:	0e 94 c0 4b 	call	0x9780	; 0x9780 <CarriegeReturn>
		           sprintf_P(strPrint,PSTR("    ------------------------------"));
    b486:	00 d0       	rcall	.+0      	; 0xb488 <PrintIdle+0x8ca>
    b488:	00 d0       	rcall	.+0      	; 0xb48a <PrintIdle+0x8cc>
    b48a:	ad b7       	in	r26, 0x3d	; 61
    b48c:	be b7       	in	r27, 0x3e	; 62
    b48e:	12 96       	adiw	r26, 0x02	; 2
    b490:	dc 93       	st	X, r29
    b492:	ce 93       	st	-X, r28
    b494:	11 97       	sbiw	r26, 0x01	; 1
    b496:	86 ed       	ldi	r24, 0xD6	; 214
    b498:	97 e0       	ldi	r25, 0x07	; 7
    b49a:	76 c1       	rjmp	.+748    	; 0xb788 <PrintIdle+0xbca>
			   }else ClearMem(strPrint);
		       break;          
          //Loyalty
		  case 21:
		       CarriegeReturn();
    b49c:	0e 94 c0 4b 	call	0x9780	; 0x9780 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("         LOYALTY INFORMATION      "));
    b4a0:	00 d0       	rcall	.+0      	; 0xb4a2 <PrintIdle+0x8e4>
    b4a2:	00 d0       	rcall	.+0      	; 0xb4a4 <PrintIdle+0x8e6>
    b4a4:	85 e9       	ldi	r24, 0x95	; 149
    b4a6:	92 e0       	ldi	r25, 0x02	; 2
    b4a8:	ed b7       	in	r30, 0x3d	; 61
    b4aa:	fe b7       	in	r31, 0x3e	; 62
    b4ac:	92 83       	std	Z+2, r25	; 0x02
    b4ae:	81 83       	std	Z+1, r24	; 0x01
    b4b0:	83 eb       	ldi	r24, 0xB3	; 179
    b4b2:	97 e0       	ldi	r25, 0x07	; 7
    b4b4:	a4 cf       	rjmp	.-184    	; 0xb3fe <PrintIdle+0x840>
		       break; 			            
		  case 22:
		       CarriegeReturn();
    b4b6:	0e 94 c0 4b 	call	0x9780	; 0x9780 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("     Card ID      : %s"),strLoyCardID);
    b4ba:	00 d0       	rcall	.+0      	; 0xb4bc <PrintIdle+0x8fe>
    b4bc:	00 d0       	rcall	.+0      	; 0xb4be <PrintIdle+0x900>
    b4be:	00 d0       	rcall	.+0      	; 0xb4c0 <PrintIdle+0x902>
    b4c0:	ed b7       	in	r30, 0x3d	; 61
    b4c2:	fe b7       	in	r31, 0x3e	; 62
    b4c4:	31 96       	adiw	r30, 0x01	; 1
    b4c6:	85 e9       	ldi	r24, 0x95	; 149
    b4c8:	92 e0       	ldi	r25, 0x02	; 2
    b4ca:	ad b7       	in	r26, 0x3d	; 61
    b4cc:	be b7       	in	r27, 0x3e	; 62
    b4ce:	12 96       	adiw	r26, 0x02	; 2
    b4d0:	9c 93       	st	X, r25
    b4d2:	8e 93       	st	-X, r24
    b4d4:	11 97       	sbiw	r26, 0x01	; 1
    b4d6:	8c e9       	ldi	r24, 0x9C	; 156
    b4d8:	97 e0       	ldi	r25, 0x07	; 7
    b4da:	93 83       	std	Z+3, r25	; 0x03
    b4dc:	82 83       	std	Z+2, r24	; 0x02
    b4de:	87 ec       	ldi	r24, 0xC7	; 199
    b4e0:	94 e0       	ldi	r25, 0x04	; 4
    b4e2:	37 c1       	rjmp	.+622    	; 0xb752 <PrintIdle+0xb94>
		       break;
		  case 23:
		       CarriegeReturn();
    b4e4:	0e 94 c0 4b 	call	0x9780	; 0x9780 <CarriegeReturn>
			   //RemSpaceLag(strLoyCardHolder);
		       sprintf_P(strPrint,PSTR("     Card Holder  : %s "),strLoyCardHolder);
    b4e8:	00 d0       	rcall	.+0      	; 0xb4ea <PrintIdle+0x92c>
    b4ea:	00 d0       	rcall	.+0      	; 0xb4ec <PrintIdle+0x92e>
    b4ec:	00 d0       	rcall	.+0      	; 0xb4ee <PrintIdle+0x930>
    b4ee:	ed b7       	in	r30, 0x3d	; 61
    b4f0:	fe b7       	in	r31, 0x3e	; 62
    b4f2:	31 96       	adiw	r30, 0x01	; 1
    b4f4:	85 e9       	ldi	r24, 0x95	; 149
    b4f6:	92 e0       	ldi	r25, 0x02	; 2
    b4f8:	ad b7       	in	r26, 0x3d	; 61
    b4fa:	be b7       	in	r27, 0x3e	; 62
    b4fc:	12 96       	adiw	r26, 0x02	; 2
    b4fe:	9c 93       	st	X, r25
    b500:	8e 93       	st	-X, r24
    b502:	11 97       	sbiw	r26, 0x01	; 1
    b504:	84 e8       	ldi	r24, 0x84	; 132
    b506:	97 e0       	ldi	r25, 0x07	; 7
    b508:	93 83       	std	Z+3, r25	; 0x03
    b50a:	82 83       	std	Z+2, r24	; 0x02
    b50c:	84 ea       	ldi	r24, 0xA4	; 164
    b50e:	94 e0       	ldi	r25, 0x04	; 4
    b510:	20 c1       	rjmp	.+576    	; 0xb752 <PrintIdle+0xb94>
		       break;
		  case 24:
		       if ((strlen(strCorporateID)>0)&&(SpaceOnly(strCorporateID)==False)){
    b512:	c5 ee       	ldi	r28, 0xE5	; 229
    b514:	dd e0       	ldi	r29, 0x0D	; 13
    b516:	80 91 e5 0d 	lds	r24, 0x0DE5
    b51a:	88 23       	and	r24, r24
    b51c:	d1 f1       	breq	.+116    	; 0xb592 <PrintIdle+0x9d4>
    b51e:	ce 01       	movw	r24, r28
    b520:	0e 94 b8 22 	call	0x4570	; 0x4570 <SpaceOnly>
    b524:	88 23       	and	r24, r24
    b526:	a9 f5       	brne	.+106    	; 0xb592 <PrintIdle+0x9d4>
		           CarriegeReturn();
    b528:	0e 94 c0 4b 	call	0x9780	; 0x9780 <CarriegeReturn>
				   //RemSpaceLag(strCorporateID);
		           sprintf_P(strPrint,PSTR("     Corp ID      : %s"),strCorporateID);
    b52c:	00 d0       	rcall	.+0      	; 0xb52e <PrintIdle+0x970>
    b52e:	00 d0       	rcall	.+0      	; 0xb530 <PrintIdle+0x972>
    b530:	00 d0       	rcall	.+0      	; 0xb532 <PrintIdle+0x974>
    b532:	ed b7       	in	r30, 0x3d	; 61
    b534:	fe b7       	in	r31, 0x3e	; 62
    b536:	31 96       	adiw	r30, 0x01	; 1
    b538:	85 e9       	ldi	r24, 0x95	; 149
    b53a:	92 e0       	ldi	r25, 0x02	; 2
    b53c:	ad b7       	in	r26, 0x3d	; 61
    b53e:	be b7       	in	r27, 0x3e	; 62
    b540:	12 96       	adiw	r26, 0x02	; 2
    b542:	9c 93       	st	X, r25
    b544:	8e 93       	st	-X, r24
    b546:	11 97       	sbiw	r26, 0x01	; 1
    b548:	8d e6       	ldi	r24, 0x6D	; 109
    b54a:	97 e0       	ldi	r25, 0x07	; 7
    b54c:	1d c0       	rjmp	.+58     	; 0xb588 <PrintIdle+0x9ca>
			   }else ClearMem(strPrint);
		       break;
		  case 25:
		       if ((strlen(strCorporateName)>0)&&(SpaceOnly(strCorporateName)==False)){
    b54e:	cd ea       	ldi	r28, 0xAD	; 173
    b550:	d5 e0       	ldi	r29, 0x05	; 5
    b552:	80 91 ad 05 	lds	r24, 0x05AD
    b556:	88 23       	and	r24, r24
    b558:	e1 f0       	breq	.+56     	; 0xb592 <PrintIdle+0x9d4>
    b55a:	ce 01       	movw	r24, r28
    b55c:	0e 94 b8 22 	call	0x4570	; 0x4570 <SpaceOnly>
    b560:	88 23       	and	r24, r24
    b562:	b9 f4       	brne	.+46     	; 0xb592 <PrintIdle+0x9d4>
		           CarriegeReturn();
    b564:	0e 94 c0 4b 	call	0x9780	; 0x9780 <CarriegeReturn>
				   //RemSpaceLag(strCorporateName);
		           sprintf_P(strPrint,PSTR("     Corp Name    : %s"),strCorporateName);
    b568:	00 d0       	rcall	.+0      	; 0xb56a <PrintIdle+0x9ac>
    b56a:	00 d0       	rcall	.+0      	; 0xb56c <PrintIdle+0x9ae>
    b56c:	00 d0       	rcall	.+0      	; 0xb56e <PrintIdle+0x9b0>
    b56e:	ed b7       	in	r30, 0x3d	; 61
    b570:	fe b7       	in	r31, 0x3e	; 62
    b572:	31 96       	adiw	r30, 0x01	; 1
    b574:	85 e9       	ldi	r24, 0x95	; 149
    b576:	92 e0       	ldi	r25, 0x02	; 2
    b578:	ad b7       	in	r26, 0x3d	; 61
    b57a:	be b7       	in	r27, 0x3e	; 62
    b57c:	12 96       	adiw	r26, 0x02	; 2
    b57e:	9c 93       	st	X, r25
    b580:	8e 93       	st	-X, r24
    b582:	11 97       	sbiw	r26, 0x01	; 1
    b584:	86 e5       	ldi	r24, 0x56	; 86
    b586:	97 e0       	ldi	r25, 0x07	; 7
    b588:	93 83       	std	Z+3, r25	; 0x03
    b58a:	82 83       	std	Z+2, r24	; 0x02
    b58c:	d5 83       	std	Z+5, r29	; 0x05
    b58e:	c4 83       	std	Z+4, r28	; 0x04
    b590:	e2 c0       	rjmp	.+452    	; 0xb756 <PrintIdle+0xb98>
			   }else ClearMem(strPrint);
    b592:	85 e9       	ldi	r24, 0x95	; 149
    b594:	92 e0       	ldi	r25, 0x02	; 2
    b596:	2c ce       	rjmp	.-936    	; 0xb1f0 <PrintIdle+0x632>
		       break;
		  case 26:
		       CarriegeReturn();
    b598:	0e 94 c0 4b 	call	0x9780	; 0x9780 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("     Gain Points  : %s"),strGainPoints);
    b59c:	00 d0       	rcall	.+0      	; 0xb59e <PrintIdle+0x9e0>
    b59e:	00 d0       	rcall	.+0      	; 0xb5a0 <PrintIdle+0x9e2>
    b5a0:	00 d0       	rcall	.+0      	; 0xb5a2 <PrintIdle+0x9e4>
    b5a2:	ed b7       	in	r30, 0x3d	; 61
    b5a4:	fe b7       	in	r31, 0x3e	; 62
    b5a6:	31 96       	adiw	r30, 0x01	; 1
    b5a8:	85 e9       	ldi	r24, 0x95	; 149
    b5aa:	92 e0       	ldi	r25, 0x02	; 2
    b5ac:	ad b7       	in	r26, 0x3d	; 61
    b5ae:	be b7       	in	r27, 0x3e	; 62
    b5b0:	12 96       	adiw	r26, 0x02	; 2
    b5b2:	9c 93       	st	X, r25
    b5b4:	8e 93       	st	-X, r24
    b5b6:	11 97       	sbiw	r26, 0x01	; 1
    b5b8:	8f e3       	ldi	r24, 0x3F	; 63
    b5ba:	97 e0       	ldi	r25, 0x07	; 7
    b5bc:	93 83       	std	Z+3, r25	; 0x03
    b5be:	82 83       	std	Z+2, r24	; 0x02
    b5c0:	8b e9       	ldi	r24, 0x9B	; 155
    b5c2:	94 e0       	ldi	r25, 0x04	; 4
    b5c4:	c6 c0       	rjmp	.+396    	; 0xb752 <PrintIdle+0xb94>
		       break;
		  case 27:
		       CarriegeReturn();
    b5c6:	0e 94 c0 4b 	call	0x9780	; 0x9780 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("     Prev Points  : %s"),strPrevPoints);
    b5ca:	00 d0       	rcall	.+0      	; 0xb5cc <PrintIdle+0xa0e>
    b5cc:	00 d0       	rcall	.+0      	; 0xb5ce <PrintIdle+0xa10>
    b5ce:	00 d0       	rcall	.+0      	; 0xb5d0 <PrintIdle+0xa12>
    b5d0:	ed b7       	in	r30, 0x3d	; 61
    b5d2:	fe b7       	in	r31, 0x3e	; 62
    b5d4:	31 96       	adiw	r30, 0x01	; 1
    b5d6:	85 e9       	ldi	r24, 0x95	; 149
    b5d8:	92 e0       	ldi	r25, 0x02	; 2
    b5da:	ad b7       	in	r26, 0x3d	; 61
    b5dc:	be b7       	in	r27, 0x3e	; 62
    b5de:	12 96       	adiw	r26, 0x02	; 2
    b5e0:	9c 93       	st	X, r25
    b5e2:	8e 93       	st	-X, r24
    b5e4:	11 97       	sbiw	r26, 0x01	; 1
    b5e6:	88 e2       	ldi	r24, 0x28	; 40
    b5e8:	97 e0       	ldi	r25, 0x07	; 7
    b5ea:	93 83       	std	Z+3, r25	; 0x03
    b5ec:	82 83       	std	Z+2, r24	; 0x02
    b5ee:	8c ee       	ldi	r24, 0xEC	; 236
    b5f0:	9a e0       	ldi	r25, 0x0A	; 10
    b5f2:	af c0       	rjmp	.+350    	; 0xb752 <PrintIdle+0xb94>
		       break;
		  case 28:
		       CarriegeReturn();
    b5f4:	0e 94 c0 4b 	call	0x9780	; 0x9780 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("     Curr Points  : %s"),strLoyCurrentPoints);
    b5f8:	00 d0       	rcall	.+0      	; 0xb5fa <PrintIdle+0xa3c>
    b5fa:	00 d0       	rcall	.+0      	; 0xb5fc <PrintIdle+0xa3e>
    b5fc:	00 d0       	rcall	.+0      	; 0xb5fe <PrintIdle+0xa40>
    b5fe:	ed b7       	in	r30, 0x3d	; 61
    b600:	fe b7       	in	r31, 0x3e	; 62
    b602:	31 96       	adiw	r30, 0x01	; 1
    b604:	85 e9       	ldi	r24, 0x95	; 149
    b606:	92 e0       	ldi	r25, 0x02	; 2
    b608:	ad b7       	in	r26, 0x3d	; 61
    b60a:	be b7       	in	r27, 0x3e	; 62
    b60c:	12 96       	adiw	r26, 0x02	; 2
    b60e:	9c 93       	st	X, r25
    b610:	8e 93       	st	-X, r24
    b612:	11 97       	sbiw	r26, 0x01	; 1
    b614:	81 e1       	ldi	r24, 0x11	; 17
    b616:	97 e0       	ldi	r25, 0x07	; 7
    b618:	93 83       	std	Z+3, r25	; 0x03
    b61a:	82 83       	std	Z+2, r24	; 0x02
    b61c:	8a e3       	ldi	r24, 0x3A	; 58
    b61e:	9a e0       	ldi	r25, 0x0A	; 10
    b620:	98 c0       	rjmp	.+304    	; 0xb752 <PrintIdle+0xb94>
		       break;
		  case 29:
		       CarriegeReturn();
    b622:	0e 94 c0 4b 	call	0x9780	; 0x9780 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("     Expiry       : %s"),strLoyExpiry);
    b626:	00 d0       	rcall	.+0      	; 0xb628 <PrintIdle+0xa6a>
    b628:	00 d0       	rcall	.+0      	; 0xb62a <PrintIdle+0xa6c>
    b62a:	00 d0       	rcall	.+0      	; 0xb62c <PrintIdle+0xa6e>
    b62c:	ed b7       	in	r30, 0x3d	; 61
    b62e:	fe b7       	in	r31, 0x3e	; 62
    b630:	31 96       	adiw	r30, 0x01	; 1
    b632:	85 e9       	ldi	r24, 0x95	; 149
    b634:	92 e0       	ldi	r25, 0x02	; 2
    b636:	ad b7       	in	r26, 0x3d	; 61
    b638:	be b7       	in	r27, 0x3e	; 62
    b63a:	12 96       	adiw	r26, 0x02	; 2
    b63c:	9c 93       	st	X, r25
    b63e:	8e 93       	st	-X, r24
    b640:	11 97       	sbiw	r26, 0x01	; 1
    b642:	8a ef       	ldi	r24, 0xFA	; 250
    b644:	96 e0       	ldi	r25, 0x06	; 6
    b646:	93 83       	std	Z+3, r25	; 0x03
    b648:	82 83       	std	Z+2, r24	; 0x02
    b64a:	83 e5       	ldi	r24, 0x53	; 83
    b64c:	9e e0       	ldi	r25, 0x0E	; 14
    b64e:	81 c0       	rjmp	.+258    	; 0xb752 <PrintIdle+0xb94>
		       break;
		  case 30:
		       CarriegeReturn();
    b650:	0e 94 c0 4b 	call	0x9780	; 0x9780 <CarriegeReturn>
			   //RemSpaceLag(strLoyRedeemPoints);
		       sprintf_P(strPrint,PSTR("     Total Redeem : %s"),strLoyRedeemPoints);
    b654:	00 d0       	rcall	.+0      	; 0xb656 <PrintIdle+0xa98>
    b656:	00 d0       	rcall	.+0      	; 0xb658 <PrintIdle+0xa9a>
    b658:	00 d0       	rcall	.+0      	; 0xb65a <PrintIdle+0xa9c>
    b65a:	ed b7       	in	r30, 0x3d	; 61
    b65c:	fe b7       	in	r31, 0x3e	; 62
    b65e:	31 96       	adiw	r30, 0x01	; 1
    b660:	85 e9       	ldi	r24, 0x95	; 149
    b662:	92 e0       	ldi	r25, 0x02	; 2
    b664:	ad b7       	in	r26, 0x3d	; 61
    b666:	be b7       	in	r27, 0x3e	; 62
    b668:	12 96       	adiw	r26, 0x02	; 2
    b66a:	9c 93       	st	X, r25
    b66c:	8e 93       	st	-X, r24
    b66e:	11 97       	sbiw	r26, 0x01	; 1
    b670:	83 ee       	ldi	r24, 0xE3	; 227
    b672:	96 e0       	ldi	r25, 0x06	; 6
    b674:	93 83       	std	Z+3, r25	; 0x03
    b676:	82 83       	std	Z+2, r24	; 0x02
    b678:	8a e7       	ldi	r24, 0x7A	; 122
    b67a:	95 e0       	ldi	r25, 0x05	; 5
    b67c:	6a c0       	rjmp	.+212    	; 0xb752 <PrintIdle+0xb94>
		       break;
		  case 31:
		       CarriegeReturn();
    b67e:	0e 94 c0 4b 	call	0x9780	; 0x9780 <CarriegeReturn>
			   //RemSpaceLag(strLoyCurrMonConsumeV);
			   //FormatCurrency(strLoyCurrMonConsumeV);
		       sprintf_P(strPrint,PSTR("     Month Cons V : %s L"),strLoyCurrMonConsumeV);
    b682:	00 d0       	rcall	.+0      	; 0xb684 <PrintIdle+0xac6>
    b684:	00 d0       	rcall	.+0      	; 0xb686 <PrintIdle+0xac8>
    b686:	00 d0       	rcall	.+0      	; 0xb688 <PrintIdle+0xaca>
    b688:	ed b7       	in	r30, 0x3d	; 61
    b68a:	fe b7       	in	r31, 0x3e	; 62
    b68c:	31 96       	adiw	r30, 0x01	; 1
    b68e:	85 e9       	ldi	r24, 0x95	; 149
    b690:	92 e0       	ldi	r25, 0x02	; 2
    b692:	ad b7       	in	r26, 0x3d	; 61
    b694:	be b7       	in	r27, 0x3e	; 62
    b696:	12 96       	adiw	r26, 0x02	; 2
    b698:	9c 93       	st	X, r25
    b69a:	8e 93       	st	-X, r24
    b69c:	11 97       	sbiw	r26, 0x01	; 1
    b69e:	8a ec       	ldi	r24, 0xCA	; 202
    b6a0:	96 e0       	ldi	r25, 0x06	; 6
    b6a2:	93 83       	std	Z+3, r25	; 0x03
    b6a4:	82 83       	std	Z+2, r24	; 0x02
    b6a6:	88 ec       	ldi	r24, 0xC8	; 200
    b6a8:	9d e0       	ldi	r25, 0x0D	; 13
    b6aa:	53 c0       	rjmp	.+166    	; 0xb752 <PrintIdle+0xb94>
		       break;
		  case 32:
		       CarriegeReturn();
    b6ac:	0e 94 c0 4b 	call	0x9780	; 0x9780 <CarriegeReturn>
			   //RemSpaceLag(strLoyCurrMonConsumeA);
			   //FormatCurrency(strLoyCurrMonConsumeA);
		       sprintf_P(strPrint,PSTR("     Month Cons A : Rp.%s"),strLoyCurrMonConsumeA);
    b6b0:	00 d0       	rcall	.+0      	; 0xb6b2 <PrintIdle+0xaf4>
    b6b2:	00 d0       	rcall	.+0      	; 0xb6b4 <PrintIdle+0xaf6>
    b6b4:	00 d0       	rcall	.+0      	; 0xb6b6 <PrintIdle+0xaf8>
    b6b6:	ed b7       	in	r30, 0x3d	; 61
    b6b8:	fe b7       	in	r31, 0x3e	; 62
    b6ba:	31 96       	adiw	r30, 0x01	; 1
    b6bc:	85 e9       	ldi	r24, 0x95	; 149
    b6be:	92 e0       	ldi	r25, 0x02	; 2
    b6c0:	ad b7       	in	r26, 0x3d	; 61
    b6c2:	be b7       	in	r27, 0x3e	; 62
    b6c4:	12 96       	adiw	r26, 0x02	; 2
    b6c6:	9c 93       	st	X, r25
    b6c8:	8e 93       	st	-X, r24
    b6ca:	11 97       	sbiw	r26, 0x01	; 1
    b6cc:	80 eb       	ldi	r24, 0xB0	; 176
    b6ce:	96 e0       	ldi	r25, 0x06	; 6
    b6d0:	93 83       	std	Z+3, r25	; 0x03
    b6d2:	82 83       	std	Z+2, r24	; 0x02
    b6d4:	8e e5       	ldi	r24, 0x5E	; 94
    b6d6:	95 e0       	ldi	r25, 0x05	; 5
    b6d8:	3c c0       	rjmp	.+120    	; 0xb752 <PrintIdle+0xb94>
		       break;
		  case 33://EndOfLoyalty
		       CarriegeReturn();
    b6da:	0e 94 c0 4b 	call	0x9780	; 0x9780 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("    ------------------------------"));
    b6de:	00 d0       	rcall	.+0      	; 0xb6e0 <PrintIdle+0xb22>
    b6e0:	00 d0       	rcall	.+0      	; 0xb6e2 <PrintIdle+0xb24>
    b6e2:	85 e9       	ldi	r24, 0x95	; 149
    b6e4:	92 e0       	ldi	r25, 0x02	; 2
    b6e6:	ad b7       	in	r26, 0x3d	; 61
    b6e8:	be b7       	in	r27, 0x3e	; 62
    b6ea:	12 96       	adiw	r26, 0x02	; 2
    b6ec:	9c 93       	st	X, r25
    b6ee:	8e 93       	st	-X, r24
    b6f0:	11 97       	sbiw	r26, 0x01	; 1
    b6f2:	8d e8       	ldi	r24, 0x8D	; 141
    b6f4:	96 e0       	ldi	r25, 0x06	; 6
    b6f6:	48 c0       	rjmp	.+144    	; 0xb788 <PrintIdle+0xbca>
		       break;
		  case 34:
		       CarriegeReturn();
    b6f8:	0e 94 c0 4b 	call	0x9780	; 0x9780 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("     Surcharge Dsc: %s"),strSurchargeDesc);
    b6fc:	00 d0       	rcall	.+0      	; 0xb6fe <PrintIdle+0xb40>
    b6fe:	00 d0       	rcall	.+0      	; 0xb700 <PrintIdle+0xb42>
    b700:	00 d0       	rcall	.+0      	; 0xb702 <PrintIdle+0xb44>
    b702:	ed b7       	in	r30, 0x3d	; 61
    b704:	fe b7       	in	r31, 0x3e	; 62
    b706:	31 96       	adiw	r30, 0x01	; 1
    b708:	85 e9       	ldi	r24, 0x95	; 149
    b70a:	92 e0       	ldi	r25, 0x02	; 2
    b70c:	ad b7       	in	r26, 0x3d	; 61
    b70e:	be b7       	in	r27, 0x3e	; 62
    b710:	12 96       	adiw	r26, 0x02	; 2
    b712:	9c 93       	st	X, r25
    b714:	8e 93       	st	-X, r24
    b716:	11 97       	sbiw	r26, 0x01	; 1
    b718:	86 e7       	ldi	r24, 0x76	; 118
    b71a:	96 e0       	ldi	r25, 0x06	; 6
    b71c:	93 83       	std	Z+3, r25	; 0x03
    b71e:	82 83       	std	Z+2, r24	; 0x02
    b720:	8f ec       	ldi	r24, 0xCF	; 207
    b722:	99 e0       	ldi	r25, 0x09	; 9
    b724:	16 c0       	rjmp	.+44     	; 0xb752 <PrintIdle+0xb94>
		       break;
		  case 35:
		       CarriegeReturn();
    b726:	0e 94 c0 4b 	call	0x9780	; 0x9780 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("     Surcharge Amt: %s"),strSurchargeAmount);
    b72a:	00 d0       	rcall	.+0      	; 0xb72c <PrintIdle+0xb6e>
    b72c:	00 d0       	rcall	.+0      	; 0xb72e <PrintIdle+0xb70>
    b72e:	00 d0       	rcall	.+0      	; 0xb730 <PrintIdle+0xb72>
    b730:	ed b7       	in	r30, 0x3d	; 61
    b732:	fe b7       	in	r31, 0x3e	; 62
    b734:	31 96       	adiw	r30, 0x01	; 1
    b736:	85 e9       	ldi	r24, 0x95	; 149
    b738:	92 e0       	ldi	r25, 0x02	; 2
    b73a:	ad b7       	in	r26, 0x3d	; 61
    b73c:	be b7       	in	r27, 0x3e	; 62
    b73e:	12 96       	adiw	r26, 0x02	; 2
    b740:	9c 93       	st	X, r25
    b742:	8e 93       	st	-X, r24
    b744:	11 97       	sbiw	r26, 0x01	; 1
    b746:	8f e5       	ldi	r24, 0x5F	; 95
    b748:	96 e0       	ldi	r25, 0x06	; 6
    b74a:	93 83       	std	Z+3, r25	; 0x03
    b74c:	82 83       	std	Z+2, r24	; 0x02
    b74e:	87 e5       	ldi	r24, 0x57	; 87
    b750:	9a e0       	ldi	r25, 0x0A	; 10
    b752:	95 83       	std	Z+5, r25	; 0x05
    b754:	84 83       	std	Z+4, r24	; 0x04
    b756:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    b75a:	ed b7       	in	r30, 0x3d	; 61
    b75c:	fe b7       	in	r31, 0x3e	; 62
    b75e:	36 96       	adiw	r30, 0x06	; 6
    b760:	0f b6       	in	r0, 0x3f	; 63
    b762:	f8 94       	cli
    b764:	fe bf       	out	0x3e, r31	; 62
    b766:	0f be       	out	0x3f, r0	; 63
    b768:	ed bf       	out	0x3d, r30	; 61
    b76a:	18 c0       	rjmp	.+48     	; 0xb79c <PrintIdle+0xbde>
		       break;
		  case 36:
		       CarriegeReturn();
    b76c:	0e 94 c0 4b 	call	0x9780	; 0x9780 <CarriegeReturn>
		       sprintf_P(strPrint,PSTR("    ------------------------------"));
    b770:	00 d0       	rcall	.+0      	; 0xb772 <PrintIdle+0xbb4>
    b772:	00 d0       	rcall	.+0      	; 0xb774 <PrintIdle+0xbb6>
    b774:	85 e9       	ldi	r24, 0x95	; 149
    b776:	92 e0       	ldi	r25, 0x02	; 2
    b778:	ad b7       	in	r26, 0x3d	; 61
    b77a:	be b7       	in	r27, 0x3e	; 62
    b77c:	12 96       	adiw	r26, 0x02	; 2
    b77e:	9c 93       	st	X, r25
    b780:	8e 93       	st	-X, r24
    b782:	11 97       	sbiw	r26, 0x01	; 1
    b784:	8c e3       	ldi	r24, 0x3C	; 60
    b786:	96 e0       	ldi	r25, 0x06	; 6
    b788:	14 96       	adiw	r26, 0x04	; 4
    b78a:	9c 93       	st	X, r25
    b78c:	8e 93       	st	-X, r24
    b78e:	13 97       	sbiw	r26, 0x03	; 3
    b790:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    b794:	0f 90       	pop	r0
    b796:	0f 90       	pop	r0
    b798:	0f 90       	pop	r0
    b79a:	0f 90       	pop	r0
		       break;
		  }
		  iLoop=0;iSend=0;LSend=strlen(strPrint);
    b79c:	10 92 8d 02 	sts	0x028D, r1
    b7a0:	10 92 8c 02 	sts	0x028C, r1
    b7a4:	10 92 91 02 	sts	0x0291, r1
    b7a8:	10 92 90 02 	sts	0x0290, r1
    b7ac:	e5 e9       	ldi	r30, 0x95	; 149
    b7ae:	f2 e0       	ldi	r31, 0x02	; 2
    b7b0:	01 90       	ld	r0, Z+
    b7b2:	00 20       	and	r0, r0
    b7b4:	e9 f7       	brne	.-6      	; 0xb7b0 <PrintIdle+0xbf2>
    b7b6:	31 97       	sbiw	r30, 0x01	; 1
    b7b8:	e5 59       	subi	r30, 0x95	; 149
    b7ba:	f2 40       	sbci	r31, 0x02	; 2
    b7bc:	f0 93 8f 02 	sts	0x028F, r31
    b7c0:	e0 93 8e 02 	sts	0x028E, r30
          stPrintIdle=piPrintMessage;
    b7c4:	8a e0       	ldi	r24, 0x0A	; 10
    b7c6:	f3 c0       	rjmp	.+486    	; 0xb9ae <PrintIdle+0xdf0>
	      break;
     case piPrintMessage:
	      if (iSend<LSend){
    b7c8:	20 91 90 02 	lds	r18, 0x0290
    b7cc:	30 91 91 02 	lds	r19, 0x0291
    b7d0:	80 91 8e 02 	lds	r24, 0x028E
    b7d4:	90 91 8f 02 	lds	r25, 0x028F
    b7d8:	28 17       	cp	r18, r24
    b7da:	39 07       	cpc	r19, r25
    b7dc:	78 f4       	brcc	.+30     	; 0xb7fc <PrintIdle+0xc3e>
		      iLoop++;
    b7de:	80 91 8c 02 	lds	r24, 0x028C
    b7e2:	90 91 8d 02 	lds	r25, 0x028D
    b7e6:	01 96       	adiw	r24, 0x01	; 1
    b7e8:	90 93 8d 02 	sts	0x028D, r25
    b7ec:	80 93 8c 02 	sts	0x028C, r24
			  if((iLoop%PRINT_DELAY)==0){
				 TimPrintBusy=0;
    b7f0:	10 92 cd 01 	sts	0x01CD, r1
    b7f4:	10 92 cc 01 	sts	0x01CC, r1
				 stPrintIdle=piCheckPrintStatusMessage;
    b7f8:	8c e0       	ldi	r24, 0x0C	; 12
    b7fa:	d9 c0       	rjmp	.+434    	; 0xb9ae <PrintIdle+0xdf0>
				 }
			  }
          else{iMessage++;
    b7fc:	80 91 94 02 	lds	r24, 0x0294
    b800:	8f 5f       	subi	r24, 0xFF	; 255
    b802:	80 93 94 02 	sts	0x0294, r24
		      if (iMessage>MessageLine){
    b806:	90 91 93 02 	lds	r25, 0x0293
    b80a:	98 17       	cp	r25, r24
    b80c:	18 f4       	brcc	.+6      	; 0xb814 <PrintIdle+0xc56>
			      iFooter=0;
    b80e:	10 92 c4 02 	sts	0x02C4, r1
    b812:	5c c0       	rjmp	.+184    	; 0xb8cc <PrintIdle+0xd0e>
				  stPrintIdle=piLoadFooter;
				  CarriegeReturn();
			  }
			  else stPrintIdle=piLoadMessage;
    b814:	89 e0       	ldi	r24, 0x09	; 9
    b816:	cb c0       	rjmp	.+406    	; 0xb9ae <PrintIdle+0xdf0>
			  }
	      break;
     case piCheckPrintStatusMessage:
	      if (IsBusyPrint==False){
    b818:	80 91 c9 01 	lds	r24, 0x01C9
    b81c:	88 23       	and	r24, r24
    b81e:	09 f0       	breq	.+2      	; 0xb822 <PrintIdle+0xc64>
    b820:	bc c0       	rjmp	.+376    	; 0xb99a <PrintIdle+0xddc>
		      _uart(_COM_PRINTER,1,strPrint[iSend]);
    b822:	e0 91 90 02 	lds	r30, 0x0290
    b826:	f0 91 91 02 	lds	r31, 0x0291
    b82a:	eb 56       	subi	r30, 0x6B	; 107
    b82c:	fd 4f       	sbci	r31, 0xFD	; 253
    b82e:	61 e0       	ldi	r22, 0x01	; 1
    b830:	40 81       	ld	r20, Z
    b832:	0e 94 7a b2 	call	0x164f4	; 0x164f4 <_uart>
		      iSend++;
    b836:	80 91 90 02 	lds	r24, 0x0290
    b83a:	90 91 91 02 	lds	r25, 0x0291
    b83e:	01 96       	adiw	r24, 0x01	; 1
    b840:	90 93 91 02 	sts	0x0291, r25
    b844:	80 93 90 02 	sts	0x0290, r24
		      stPrintIdle=piPrintMessage;
    b848:	8a e0       	ldi	r24, 0x0A	; 10
    b84a:	a5 c0       	rjmp	.+330    	; 0xb996 <PrintIdle+0xdd8>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    b84c:	60 91 c4 02 	lds	r22, 0x02C4
    b850:	89 e2       	ldi	r24, 0x29	; 41
    b852:	68 9f       	mul	r22, r24
    b854:	b0 01       	movw	r22, r0
    b856:	11 24       	eor	r1, r1
    b858:	63 5e       	subi	r22, 0xE3	; 227
    b85a:	7c 4f       	sbci	r23, 0xFC	; 252
    b85c:	85 e9       	ldi	r24, 0x95	; 149
    b85e:	92 e0       	ldi	r25, 0x02	; 2
    b860:	48 e2       	ldi	r20, 0x28	; 40
    b862:	50 e0       	ldi	r21, 0x00	; 0
    b864:	23 ef       	ldi	r18, 0xF3	; 243
    b866:	32 e1       	ldi	r19, 0x12	; 18
    b868:	0e 94 1f b4 	call	0x1683e	; 0x1683e <__eerd_block>
	      break;
		       
     case piLoadFooter:
	      FillChar(strPrint,0,sizeof(strPrint));
	      eeprom_read_block((void*) &strPrint, (const void*) &DefHeaderFooter[6+iFooter], 40);
		  iFooter++;
    b86c:	80 91 c4 02 	lds	r24, 0x02C4
    b870:	8f 5f       	subi	r24, 0xFF	; 255
    b872:	80 93 c4 02 	sts	0x02C4, r24
		  if (iFooter<=4){
    b876:	85 30       	cpi	r24, 0x05	; 5
    b878:	90 f4       	brcc	.+36     	; 0xb89e <PrintIdle+0xce0>
		      if (SpaceOnly(strPrint)==True){
    b87a:	85 e9       	ldi	r24, 0x95	; 149
    b87c:	92 e0       	ldi	r25, 0x02	; 2
    b87e:	0e 94 b8 22 	call	0x4570	; 0x4570 <SpaceOnly>
    b882:	81 30       	cpi	r24, 0x01	; 1
    b884:	11 f4       	brne	.+4      	; 0xb88a <PrintIdle+0xccc>
			      stPrintIdle=piLoadFooter;
    b886:	8e e0       	ldi	r24, 0x0E	; 14
    b888:	92 c0       	rjmp	.+292    	; 0xb9ae <PrintIdle+0xdf0>
				  }
			  else{
			      iSend=0;
    b88a:	10 92 91 02 	sts	0x0291, r1
    b88e:	10 92 90 02 	sts	0x0290, r1
				  iLoop=0;
    b892:	10 92 8d 02 	sts	0x028D, r1
    b896:	10 92 8c 02 	sts	0x028C, r1
				  stPrintIdle=piPrintFooter;
    b89a:	8f e0       	ldi	r24, 0x0F	; 15
    b89c:	88 c0       	rjmp	.+272    	; 0xb9ae <PrintIdle+0xdf0>
				  //RemSpaceLag(strPrint);
				  //CarriegeReturn();
			      }
		  }else{stPrintIdle=piInitScroll;
    b89e:	81 e1       	ldi	r24, 0x11	; 17
    b8a0:	86 c0       	rjmp	.+268    	; 0xb9ae <PrintIdle+0xdf0>
		        //iPrinted++;
			}
	      break;
     case piPrintFooter:
		  if (iSend<40){
    b8a2:	80 91 90 02 	lds	r24, 0x0290
    b8a6:	90 91 91 02 	lds	r25, 0x0291
    b8aa:	88 97       	sbiw	r24, 0x28	; 40
    b8ac:	78 f4       	brcc	.+30     	; 0xb8cc <PrintIdle+0xd0e>
		      iLoop++;
    b8ae:	80 91 8c 02 	lds	r24, 0x028C
    b8b2:	90 91 8d 02 	lds	r25, 0x028D
    b8b6:	01 96       	adiw	r24, 0x01	; 1
    b8b8:	90 93 8d 02 	sts	0x028D, r25
    b8bc:	80 93 8c 02 	sts	0x028C, r24
			  if((iLoop%PRINT_DELAY)==0){
				TimPrintBusy=0;
    b8c0:	10 92 cd 01 	sts	0x01CD, r1
    b8c4:	10 92 cc 01 	sts	0x01CC, r1
				stPrintIdle=piCheckPrintStatusFooter;
    b8c8:	8d e0       	ldi	r24, 0x0D	; 13
    b8ca:	71 c0       	rjmp	.+226    	; 0xb9ae <PrintIdle+0xdf0>
				}
			  }
          else {
		      stPrintIdle=piLoadFooter;
    b8cc:	8e e0       	ldi	r24, 0x0E	; 14
    b8ce:	80 93 c6 02 	sts	0x02C6, r24
			  CarriegeReturn();
    b8d2:	0e 94 c0 4b 	call	0x9780	; 0x9780 <CarriegeReturn>
    b8d6:	96 c0       	rjmp	.+300    	; 0xba04 <PrintIdle+0xe46>
			  }
	      break;
     case piCheckPrintStatusFooter:
	      if (IsBusyPrint==False){
    b8d8:	80 91 c9 01 	lds	r24, 0x01C9
    b8dc:	88 23       	and	r24, r24
    b8de:	09 f0       	breq	.+2      	; 0xb8e2 <PrintIdle+0xd24>
    b8e0:	5c c0       	rjmp	.+184    	; 0xb99a <PrintIdle+0xddc>
		      _uart(_COM_PRINTER,1,strPrint[iSend]);
    b8e2:	e0 91 90 02 	lds	r30, 0x0290
    b8e6:	f0 91 91 02 	lds	r31, 0x0291
    b8ea:	eb 56       	subi	r30, 0x6B	; 107
    b8ec:	fd 4f       	sbci	r31, 0xFD	; 253
    b8ee:	61 e0       	ldi	r22, 0x01	; 1
    b8f0:	40 81       	ld	r20, Z
    b8f2:	0e 94 7a b2 	call	0x164f4	; 0x164f4 <_uart>
		      iSend++;
    b8f6:	80 91 90 02 	lds	r24, 0x0290
    b8fa:	90 91 91 02 	lds	r25, 0x0291
    b8fe:	01 96       	adiw	r24, 0x01	; 1
    b900:	90 93 91 02 	sts	0x0291, r25
    b904:	80 93 90 02 	sts	0x0290, r24
		      stPrintIdle=piPrintFooter;
    b908:	8f e0       	ldi	r24, 0x0F	; 15
    b90a:	45 c0       	rjmp	.+138    	; 0xb996 <PrintIdle+0xdd8>
		      stPrintIdle=piFinishPrintIdle;
			  }
	      break;

     case piInitScroll:
	      iPrinted++;
    b90c:	90 91 8b 02 	lds	r25, 0x028B
    b910:	9f 5f       	subi	r25, 0xFF	; 255
    b912:	90 93 8b 02 	sts	0x028B, r25
		  iScroll=0;
    b916:	10 92 c3 02 	sts	0x02C3, r1
		  iLoop=0;
    b91a:	10 92 8d 02 	sts	0x028D, r1
    b91e:	10 92 8c 02 	sts	0x028C, r1
		  if (iPrinted<PrintCopy){
    b922:	80 91 8a 02 	lds	r24, 0x028A
    b926:	98 17       	cp	r25, r24
    b928:	28 f4       	brcc	.+10     	; 0xb934 <PrintIdle+0xd76>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    b92a:	e1 99       	sbic	0x1c, 1	; 28
    b92c:	fe cf       	rjmp	.-4      	; 0xb92a <PrintIdle+0xd6c>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    b92e:	82 e3       	ldi	r24, 0x32	; 50
    b930:	90 e0       	ldi	r25, 0x00	; 0
    b932:	04 c0       	rjmp	.+8      	; 0xb93c <PrintIdle+0xd7e>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    b934:	e1 99       	sbic	0x1c, 1	; 28
    b936:	fe cf       	rjmp	.-4      	; 0xb934 <PrintIdle+0xd76>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    b938:	81 e3       	ldi	r24, 0x31	; 49
    b93a:	90 e0       	ldi	r25, 0x00	; 0
    b93c:	9f bb       	out	0x1f, r25	; 31
    b93e:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    b940:	e0 9a       	sbi	0x1c, 0	; 28
    b942:	8d b3       	in	r24, 0x1d	; 29
		      nScroll=eeprom_read_byte(&DefPrintScrollSpace);
		  }else if (iPrinted>=PrintCopy){		  	  
		      nScroll=eeprom_read_byte(&DefPrintScrollEnd);
    b944:	80 93 c2 02 	sts	0x02C2, r24
		  if (eeprom_read_byte(&DefPrinterType)==PT_CUSTOM_TG02){
		      _uart_printf(0,1,PSTR("----Scrolled2-----"));

		      stPrintIdle=piPaperCut;
		  }*/
          stPrintIdle=piScrollPaper;              
    b948:	80 e1       	ldi	r24, 0x10	; 16
    b94a:	31 c0       	rjmp	.+98     	; 0xb9ae <PrintIdle+0xdf0>
	      break;
     case piScrollPaper:
	      iLoop++;
    b94c:	80 91 8c 02 	lds	r24, 0x028C
    b950:	90 91 8d 02 	lds	r25, 0x028D
    b954:	01 96       	adiw	r24, 0x01	; 1
    b956:	90 93 8d 02 	sts	0x028D, r25
    b95a:	80 93 8c 02 	sts	0x028C, r24
		  if (iLoop%PRINT_DELAY==0){
			  TimPrintBusy=0;
    b95e:	10 92 cd 01 	sts	0x01CD, r1
    b962:	10 92 cc 01 	sts	0x01CC, r1
			  stPrintIdle=piCheckPrintStatusScroll;
    b966:	82 e1       	ldi	r24, 0x12	; 18
    b968:	80 93 c6 02 	sts	0x02C6, r24
			  }
	      if (iScroll>nScroll)stPrintIdle=piPaperCut;
    b96c:	90 91 c3 02 	lds	r25, 0x02C3
    b970:	80 91 c2 02 	lds	r24, 0x02C2
    b974:	89 17       	cp	r24, r25
    b976:	08 f0       	brcs	.+2      	; 0xb97a <PrintIdle+0xdbc>
    b978:	45 c0       	rjmp	.+138    	; 0xba04 <PrintIdle+0xe46>
    b97a:	83 e1       	ldi	r24, 0x13	; 19
    b97c:	18 c0       	rjmp	.+48     	; 0xb9ae <PrintIdle+0xdf0>
	      break;
     case piCheckPrintStatusScroll:
	      if (IsBusyPrint==False){
    b97e:	80 91 c9 01 	lds	r24, 0x01C9
    b982:	88 23       	and	r24, r24
    b984:	51 f4       	brne	.+20     	; 0xb99a <PrintIdle+0xddc>
		      iScroll++;
    b986:	80 91 c3 02 	lds	r24, 0x02C3
    b98a:	8f 5f       	subi	r24, 0xFF	; 255
    b98c:	80 93 c3 02 	sts	0x02C3, r24
		      CarriegeReturn();
    b990:	0e 94 c0 4b 	call	0x9780	; 0x9780 <CarriegeReturn>
		      stPrintIdle=piScrollPaper;
    b994:	80 e1       	ldi	r24, 0x10	; 16
    b996:	80 93 c6 02 	sts	0x02C6, r24
		  }
		  if (TimPrintBusy>TIM_BUSY_PRINT){
    b99a:	80 91 cc 01 	lds	r24, 0x01CC
    b99e:	90 91 cd 01 	lds	r25, 0x01CD
    b9a2:	0b 97       	sbiw	r24, 0x0b	; 11
    b9a4:	7c f1       	brlt	.+94     	; 0xba04 <PrintIdle+0xe46>
		      IsPrintERROR=True;
    b9a6:	81 e0       	ldi	r24, 0x01	; 1
    b9a8:	80 93 c7 01 	sts	0x01C7, r24
		      stPrintIdle=piFinishPrintIdle;
    b9ac:	84 e1       	ldi	r24, 0x14	; 20
    b9ae:	80 93 c6 02 	sts	0x02C6, r24
    b9b2:	28 c0       	rjmp	.+80     	; 0xba04 <PrintIdle+0xe46>
	      break;
     case piPaperCut:
	      //sprintf_P(strSend,PSTR("i:%d Copy:%d"),iPrinted,PrintCopy);
		  //_uart_print(0,1,strSend);

          if (iPrinted>=PrintCopy){
    b9b4:	90 91 8b 02 	lds	r25, 0x028B
    b9b8:	80 91 8a 02 	lds	r24, 0x028A
    b9bc:	98 17       	cp	r25, r24
    b9be:	10 f0       	brcs	.+4      	; 0xb9c4 <PrintIdle+0xe06>
		      stPrintIdle=piFinishPrintIdle;
    b9c0:	84 e1       	ldi	r24, 0x14	; 20
    b9c2:	05 c0       	rjmp	.+10     	; 0xb9ce <PrintIdle+0xe10>
			  }
		  else {CarriegeReturn();
    b9c4:	0e 94 c0 4b 	call	0x9780	; 0x9780 <CarriegeReturn>
		        CarriegeReturn();
    b9c8:	0e 94 c0 4b 	call	0x9780	; 0x9780 <CarriegeReturn>
		        stPrintIdle=piInit;
    b9cc:	81 e0       	ldi	r24, 0x01	; 1
    b9ce:	80 93 c6 02 	sts	0x02C6, r24
		       }
		  PaperCut();
    b9d2:	0e 94 67 4c 	call	0x98ce	; 0x98ce <PaperCut>
    b9d6:	16 c0       	rjmp	.+44     	; 0xba04 <PrintIdle+0xe46>
	      break;
     case piFinishPrintIdle:	      
	      switch(IFType){
    b9d8:	80 91 10 01 	lds	r24, 0x0110
    b9dc:	81 30       	cpi	r24, 0x01	; 1
    b9de:	19 f0       	breq	.+6      	; 0xb9e6 <PrintIdle+0xe28>
    b9e0:	82 30       	cpi	r24, 0x02	; 2
    b9e2:	61 f4       	brne	.+24     	; 0xb9fc <PrintIdle+0xe3e>
    b9e4:	03 c0       	rjmp	.+6      	; 0xb9ec <PrintIdle+0xe2e>
		  case IT_SLAVE:
		       sendMessage04();
    b9e6:	0e 94 e5 52 	call	0xa5ca	; 0xa5ca <sendMessage04>
    b9ea:	08 c0       	rjmp	.+16     	; 0xb9fc <PrintIdle+0xe3e>
		       break;
		  case IT_STANDALONE:
		  
		       UpdateStandaloneStatus((atoi(strFIP_ID)&0x0F),PS_PRINTED);
    b9ec:	8c e9       	ldi	r24, 0x9C	; 156
    b9ee:	99 e0       	ldi	r25, 0x09	; 9
    b9f0:	0e 94 ea b3 	call	0x167d4	; 0x167d4 <atoi>
    b9f4:	8f 70       	andi	r24, 0x0F	; 15
    b9f6:	61 e1       	ldi	r22, 0x11	; 17
    b9f8:	0e 94 70 1c 	call	0x38e0	; 0x38e0 <UpdateStandaloneStatus>
			   //strPumpStatus[FIPAddr]=GetPumpStatusLabel(PUMP_OFF);			   
			   //IsNewPumpStatus=True;//UpdateDisplay

		       break;
		  }
		  IsBusyIdlePrinting=False;
    b9fc:	10 92 c8 01 	sts	0x01C8, r1
          stPrintIdle=piIdle;
    ba00:	10 92 c6 02 	sts	0x02C6, r1
	      break;	 
	 }
}
    ba04:	df 91       	pop	r29
    ba06:	cf 91       	pop	r28
    ba08:	08 95       	ret

0000ba0a <systemPrinting>:
     

}

void systemPrinting(){
	 FreePrinting();
    ba0a:	0e 94 49 53 	call	0xa692	; 0xa692 <FreePrinting>
	 PrintIdle();
    ba0e:	0e 94 df 55 	call	0xabbe	; 0xabbe <PrintIdle>
}
    ba12:	08 95       	ret

0000ba14 <procMessage11>:
}




void procMessage11(){
    ba14:	af 92       	push	r10
    ba16:	bf 92       	push	r11
    ba18:	cf 92       	push	r12
    ba1a:	df 92       	push	r13
    ba1c:	ef 92       	push	r14
    ba1e:	ff 92       	push	r15
    ba20:	0f 93       	push	r16
    ba22:	1f 93       	push	r17
    ba24:	df 93       	push	r29
    ba26:	cf 93       	push	r28
    ba28:	cd b7       	in	r28, 0x3d	; 61
    ba2a:	de b7       	in	r29, 0x3e	; 62
    ba2c:	c5 55       	subi	r28, 0x55	; 85
    ba2e:	d0 40       	sbci	r29, 0x00	; 0
    ba30:	0f b6       	in	r0, 0x3f	; 63
    ba32:	f8 94       	cli
    ba34:	de bf       	out	0x3e, r29	; 62
    ba36:	0f be       	out	0x3f, r0	; 63
    ba38:	cd bf       	out	0x3d, r28	; 61
    ba3a:	20 e0       	ldi	r18, 0x00	; 0
    ba3c:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    ba3e:	ae 01       	movw	r20, r28
    ba40:	46 5f       	subi	r20, 0xF6	; 246
    ba42:	5f 4f       	sbci	r21, 0xFF	; 255
    ba44:	fa 01       	movw	r30, r20
    ba46:	e2 0f       	add	r30, r18
    ba48:	f3 1f       	adc	r31, r19
    ba4a:	d9 01       	movw	r26, r18
    ba4c:	ab 50       	subi	r26, 0x0B	; 11
    ba4e:	b5 4f       	sbci	r27, 0xF5	; 245
    ba50:	9b 96       	adiw	r26, 0x2b	; 43
    ba52:	8c 91       	ld	r24, X
    ba54:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    ba56:	2f 5f       	subi	r18, 0xFF	; 255
    ba58:	3f 4f       	sbci	r19, 0xFF	; 255
    ba5a:	2a 30       	cpi	r18, 0x0A	; 10
    ba5c:	31 05       	cpc	r19, r1
    ba5e:	91 f7       	brne	.-28     	; 0xba44 <procMessage11+0x30>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    ba60:	fa 01       	movw	r30, r20
    ba62:	12 86       	std	Z+10, r1	; 0x0a
     char buffHeader[41];
	 char strProductName[13],strProductPrice[9],strTime[12],strDate[10];

     //Update Datetime
	 StrPosCopy(rcv_trans,strDate,43,10);//2004/09/14 19:05:36
	 FormatDate(DATE_SHORT_YEAR,strDate);
    ba64:	81 e0       	ldi	r24, 0x01	; 1
    ba66:	ba 01       	movw	r22, r20
    ba68:	0e 94 8c 23 	call	0x4718	; 0x4718 <FormatDate>
    ba6c:	20 e0       	ldi	r18, 0x00	; 0
    ba6e:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    ba70:	ae 01       	movw	r20, r28
    ba72:	4c 5e       	subi	r20, 0xEC	; 236
    ba74:	5f 4f       	sbci	r21, 0xFF	; 255
    ba76:	fa 01       	movw	r30, r20
    ba78:	e2 0f       	add	r30, r18
    ba7a:	f3 1f       	adc	r31, r19
    ba7c:	d9 01       	movw	r26, r18
    ba7e:	ab 50       	subi	r26, 0x0B	; 11
    ba80:	b5 4f       	sbci	r27, 0xF5	; 245
    ba82:	d6 96       	adiw	r26, 0x36	; 54
    ba84:	8c 91       	ld	r24, X
    ba86:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    ba88:	2f 5f       	subi	r18, 0xFF	; 255
    ba8a:	3f 4f       	sbci	r19, 0xFF	; 255
    ba8c:	28 30       	cpi	r18, 0x08	; 8
    ba8e:	31 05       	cpc	r19, r1
    ba90:	91 f7       	brne	.-28     	; 0xba76 <procMessage11+0x62>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    ba92:	1c 8e       	std	Y+28, r1	; 0x1c

     //Update Datetime
	 StrPosCopy(rcv_trans,strDate,43,10);//2004/09/14 19:05:36
	 FormatDate(DATE_SHORT_YEAR,strDate);
	 StrPosCopy(rcv_trans,strTime,54,8);
	 _datetime(_DATETIME_WRITE,strDate,strTime);
    ba94:	81 e0       	ldi	r24, 0x01	; 1
    ba96:	be 01       	movw	r22, r28
    ba98:	66 5f       	subi	r22, 0xF6	; 246
    ba9a:	7f 4f       	sbci	r23, 0xFF	; 255
    ba9c:	0e 94 76 b1 	call	0x162ec	; 0x162ec <_datetime>
	  
     clearString(buffHeader);
    baa0:	8e 01       	movw	r16, r28
    baa2:	03 5d       	subi	r16, 0xD3	; 211
    baa4:	1f 4f       	sbci	r17, 0xFF	; 255
    baa6:	c8 01       	movw	r24, r16
    baa8:	0e 94 47 25 	call	0x4a8e	; 0x4a8e <clearString>
    baac:	20 e0       	ldi	r18, 0x00	; 0
    baae:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    bab0:	f8 01       	movw	r30, r16
    bab2:	e2 0f       	add	r30, r18
    bab4:	f3 1f       	adc	r31, r19
    bab6:	d9 01       	movw	r26, r18
    bab8:	ab 50       	subi	r26, 0x0B	; 11
    baba:	b5 4f       	sbci	r27, 0xF5	; 245
    babc:	de 96       	adiw	r26, 0x3e	; 62
    babe:	8c 91       	ld	r24, X
    bac0:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bac2:	2f 5f       	subi	r18, 0xFF	; 255
    bac4:	3f 4f       	sbci	r19, 0xFF	; 255
    bac6:	28 32       	cpi	r18, 0x28	; 40
    bac8:	31 05       	cpc	r19, r1
    baca:	91 f7       	brne	.-28     	; 0xbab0 <procMessage11+0x9c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    bacc:	fe 01       	movw	r30, r28
    bace:	eb 5a       	subi	r30, 0xAB	; 171
    bad0:	ff 4f       	sbci	r31, 0xFF	; 255
    bad2:	10 82       	st	Z, r1
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    bad4:	87 e2       	ldi	r24, 0x27	; 39
    bad6:	92 e0       	ldi	r25, 0x02	; 2
    bad8:	b8 01       	movw	r22, r16
    bada:	48 e2       	ldi	r20, 0x28	; 40
    badc:	50 e0       	ldi	r21, 0x00	; 0
    bade:	2b ef       	ldi	r18, 0xFB	; 251
    bae0:	32 e1       	ldi	r19, 0x12	; 18
    bae2:	0e 94 3b b4 	call	0x16876	; 0x16876 <__eewr_block>
    bae6:	20 e0       	ldi	r18, 0x00	; 0
    bae8:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    baea:	be 01       	movw	r22, r28
    baec:	63 5d       	subi	r22, 0xD3	; 211
    baee:	7f 4f       	sbci	r23, 0xFF	; 255
    baf0:	fb 01       	movw	r30, r22
    baf2:	e2 0f       	add	r30, r18
    baf4:	f3 1f       	adc	r31, r19
    baf6:	d9 01       	movw	r26, r18
    baf8:	a5 5a       	subi	r26, 0xA5	; 165
    bafa:	b4 4f       	sbci	r27, 0xF4	; 244
    bafc:	8c 91       	ld	r24, X
    bafe:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bb00:	2f 5f       	subi	r18, 0xFF	; 255
    bb02:	3f 4f       	sbci	r19, 0xFF	; 255
    bb04:	28 32       	cpi	r18, 0x28	; 40
    bb06:	31 05       	cpc	r19, r1
    bb08:	99 f7       	brne	.-26     	; 0xbaf0 <procMessage11+0xdc>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    bb0a:	fe 01       	movw	r30, r28
    bb0c:	eb 5a       	subi	r30, 0xAB	; 171
    bb0e:	ff 4f       	sbci	r31, 0xFF	; 255
    bb10:	10 82       	st	Z, r1
    bb12:	80 e5       	ldi	r24, 0x50	; 80
    bb14:	92 e0       	ldi	r25, 0x02	; 2
    bb16:	48 e2       	ldi	r20, 0x28	; 40
    bb18:	50 e0       	ldi	r21, 0x00	; 0
    bb1a:	2b ef       	ldi	r18, 0xFB	; 251
    bb1c:	32 e1       	ldi	r19, 0x12	; 18
    bb1e:	0e 94 3b b4 	call	0x16876	; 0x16876 <__eewr_block>
    bb22:	20 e0       	ldi	r18, 0x00	; 0
    bb24:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    bb26:	be 01       	movw	r22, r28
    bb28:	63 5d       	subi	r22, 0xD3	; 211
    bb2a:	7f 4f       	sbci	r23, 0xFF	; 255
    bb2c:	fb 01       	movw	r30, r22
    bb2e:	e2 0f       	add	r30, r18
    bb30:	f3 1f       	adc	r31, r19
    bb32:	d9 01       	movw	r26, r18
    bb34:	ad 57       	subi	r26, 0x7D	; 125
    bb36:	b4 4f       	sbci	r27, 0xF4	; 244
    bb38:	8c 91       	ld	r24, X
    bb3a:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bb3c:	2f 5f       	subi	r18, 0xFF	; 255
    bb3e:	3f 4f       	sbci	r19, 0xFF	; 255
    bb40:	28 32       	cpi	r18, 0x28	; 40
    bb42:	31 05       	cpc	r19, r1
    bb44:	99 f7       	brne	.-26     	; 0xbb2c <procMessage11+0x118>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    bb46:	fe 01       	movw	r30, r28
    bb48:	eb 5a       	subi	r30, 0xAB	; 171
    bb4a:	ff 4f       	sbci	r31, 0xFF	; 255
    bb4c:	10 82       	st	Z, r1
    bb4e:	89 e7       	ldi	r24, 0x79	; 121
    bb50:	92 e0       	ldi	r25, 0x02	; 2
    bb52:	48 e2       	ldi	r20, 0x28	; 40
    bb54:	50 e0       	ldi	r21, 0x00	; 0
    bb56:	2b ef       	ldi	r18, 0xFB	; 251
    bb58:	32 e1       	ldi	r19, 0x12	; 18
    bb5a:	0e 94 3b b4 	call	0x16876	; 0x16876 <__eewr_block>
    bb5e:	20 e0       	ldi	r18, 0x00	; 0
    bb60:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    bb62:	be 01       	movw	r22, r28
    bb64:	63 5d       	subi	r22, 0xD3	; 211
    bb66:	7f 4f       	sbci	r23, 0xFF	; 255
    bb68:	fb 01       	movw	r30, r22
    bb6a:	e2 0f       	add	r30, r18
    bb6c:	f3 1f       	adc	r31, r19
    bb6e:	d9 01       	movw	r26, r18
    bb70:	a5 55       	subi	r26, 0x55	; 85
    bb72:	b4 4f       	sbci	r27, 0xF4	; 244
    bb74:	8c 91       	ld	r24, X
    bb76:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bb78:	2f 5f       	subi	r18, 0xFF	; 255
    bb7a:	3f 4f       	sbci	r19, 0xFF	; 255
    bb7c:	28 32       	cpi	r18, 0x28	; 40
    bb7e:	31 05       	cpc	r19, r1
    bb80:	99 f7       	brne	.-26     	; 0xbb68 <procMessage11+0x154>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    bb82:	fe 01       	movw	r30, r28
    bb84:	eb 5a       	subi	r30, 0xAB	; 171
    bb86:	ff 4f       	sbci	r31, 0xFF	; 255
    bb88:	10 82       	st	Z, r1
    bb8a:	82 ea       	ldi	r24, 0xA2	; 162
    bb8c:	92 e0       	ldi	r25, 0x02	; 2
    bb8e:	48 e2       	ldi	r20, 0x28	; 40
    bb90:	50 e0       	ldi	r21, 0x00	; 0
    bb92:	2b ef       	ldi	r18, 0xFB	; 251
    bb94:	32 e1       	ldi	r19, 0x12	; 18
    bb96:	0e 94 3b b4 	call	0x16876	; 0x16876 <__eewr_block>
    bb9a:	20 e0       	ldi	r18, 0x00	; 0
    bb9c:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    bb9e:	be 01       	movw	r22, r28
    bba0:	63 5d       	subi	r22, 0xD3	; 211
    bba2:	7f 4f       	sbci	r23, 0xFF	; 255
    bba4:	fb 01       	movw	r30, r22
    bba6:	e2 0f       	add	r30, r18
    bba8:	f3 1f       	adc	r31, r19
    bbaa:	d9 01       	movw	r26, r18
    bbac:	ad 52       	subi	r26, 0x2D	; 45
    bbae:	b4 4f       	sbci	r27, 0xF4	; 244
    bbb0:	8c 91       	ld	r24, X
    bbb2:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bbb4:	2f 5f       	subi	r18, 0xFF	; 255
    bbb6:	3f 4f       	sbci	r19, 0xFF	; 255
    bbb8:	28 32       	cpi	r18, 0x28	; 40
    bbba:	31 05       	cpc	r19, r1
    bbbc:	99 f7       	brne	.-26     	; 0xbba4 <procMessage11+0x190>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    bbbe:	fe 01       	movw	r30, r28
    bbc0:	eb 5a       	subi	r30, 0xAB	; 171
    bbc2:	ff 4f       	sbci	r31, 0xFF	; 255
    bbc4:	10 82       	st	Z, r1
    bbc6:	8b ec       	ldi	r24, 0xCB	; 203
    bbc8:	92 e0       	ldi	r25, 0x02	; 2
    bbca:	48 e2       	ldi	r20, 0x28	; 40
    bbcc:	50 e0       	ldi	r21, 0x00	; 0
    bbce:	2b ef       	ldi	r18, 0xFB	; 251
    bbd0:	32 e1       	ldi	r19, 0x12	; 18
    bbd2:	0e 94 3b b4 	call	0x16876	; 0x16876 <__eewr_block>
    bbd6:	20 e0       	ldi	r18, 0x00	; 0
    bbd8:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    bbda:	be 01       	movw	r22, r28
    bbdc:	63 5d       	subi	r22, 0xD3	; 211
    bbde:	7f 4f       	sbci	r23, 0xFF	; 255
    bbe0:	fb 01       	movw	r30, r22
    bbe2:	e2 0f       	add	r30, r18
    bbe4:	f3 1f       	adc	r31, r19
    bbe6:	d9 01       	movw	r26, r18
    bbe8:	a5 50       	subi	r26, 0x05	; 5
    bbea:	b4 4f       	sbci	r27, 0xF4	; 244
    bbec:	8c 91       	ld	r24, X
    bbee:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bbf0:	2f 5f       	subi	r18, 0xFF	; 255
    bbf2:	3f 4f       	sbci	r19, 0xFF	; 255
    bbf4:	28 32       	cpi	r18, 0x28	; 40
    bbf6:	31 05       	cpc	r19, r1
    bbf8:	99 f7       	brne	.-26     	; 0xbbe0 <procMessage11+0x1cc>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    bbfa:	fe 01       	movw	r30, r28
    bbfc:	eb 5a       	subi	r30, 0xAB	; 171
    bbfe:	ff 4f       	sbci	r31, 0xFF	; 255
    bc00:	10 82       	st	Z, r1
    bc02:	84 ef       	ldi	r24, 0xF4	; 244
    bc04:	92 e0       	ldi	r25, 0x02	; 2
    bc06:	48 e2       	ldi	r20, 0x28	; 40
    bc08:	50 e0       	ldi	r21, 0x00	; 0
    bc0a:	2b ef       	ldi	r18, 0xFB	; 251
    bc0c:	32 e1       	ldi	r19, 0x12	; 18
    bc0e:	0e 94 3b b4 	call	0x16876	; 0x16876 <__eewr_block>
    bc12:	20 e0       	ldi	r18, 0x00	; 0
    bc14:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    bc16:	be 01       	movw	r22, r28
    bc18:	63 5d       	subi	r22, 0xD3	; 211
    bc1a:	7f 4f       	sbci	r23, 0xFF	; 255
    bc1c:	fb 01       	movw	r30, r22
    bc1e:	e2 0f       	add	r30, r18
    bc20:	f3 1f       	adc	r31, r19
    bc22:	d9 01       	movw	r26, r18
    bc24:	ad 5d       	subi	r26, 0xDD	; 221
    bc26:	b3 4f       	sbci	r27, 0xF3	; 243
    bc28:	8c 91       	ld	r24, X
    bc2a:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bc2c:	2f 5f       	subi	r18, 0xFF	; 255
    bc2e:	3f 4f       	sbci	r19, 0xFF	; 255
    bc30:	28 32       	cpi	r18, 0x28	; 40
    bc32:	31 05       	cpc	r19, r1
    bc34:	99 f7       	brne	.-26     	; 0xbc1c <procMessage11+0x208>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    bc36:	fe 01       	movw	r30, r28
    bc38:	eb 5a       	subi	r30, 0xAB	; 171
    bc3a:	ff 4f       	sbci	r31, 0xFF	; 255
    bc3c:	10 82       	st	Z, r1
    bc3e:	8d e1       	ldi	r24, 0x1D	; 29
    bc40:	93 e0       	ldi	r25, 0x03	; 3
    bc42:	48 e2       	ldi	r20, 0x28	; 40
    bc44:	50 e0       	ldi	r21, 0x00	; 0
    bc46:	2b ef       	ldi	r18, 0xFB	; 251
    bc48:	32 e1       	ldi	r19, 0x12	; 18
    bc4a:	0e 94 3b b4 	call	0x16876	; 0x16876 <__eewr_block>
    bc4e:	20 e0       	ldi	r18, 0x00	; 0
    bc50:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    bc52:	be 01       	movw	r22, r28
    bc54:	63 5d       	subi	r22, 0xD3	; 211
    bc56:	7f 4f       	sbci	r23, 0xFF	; 255
    bc58:	fb 01       	movw	r30, r22
    bc5a:	e2 0f       	add	r30, r18
    bc5c:	f3 1f       	adc	r31, r19
    bc5e:	d9 01       	movw	r26, r18
    bc60:	a5 5b       	subi	r26, 0xB5	; 181
    bc62:	b3 4f       	sbci	r27, 0xF3	; 243
    bc64:	8c 91       	ld	r24, X
    bc66:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bc68:	2f 5f       	subi	r18, 0xFF	; 255
    bc6a:	3f 4f       	sbci	r19, 0xFF	; 255
    bc6c:	28 32       	cpi	r18, 0x28	; 40
    bc6e:	31 05       	cpc	r19, r1
    bc70:	99 f7       	brne	.-26     	; 0xbc58 <procMessage11+0x244>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    bc72:	fe 01       	movw	r30, r28
    bc74:	eb 5a       	subi	r30, 0xAB	; 171
    bc76:	ff 4f       	sbci	r31, 0xFF	; 255
    bc78:	10 82       	st	Z, r1
    bc7a:	86 e4       	ldi	r24, 0x46	; 70
    bc7c:	93 e0       	ldi	r25, 0x03	; 3
    bc7e:	48 e2       	ldi	r20, 0x28	; 40
    bc80:	50 e0       	ldi	r21, 0x00	; 0
    bc82:	2b ef       	ldi	r18, 0xFB	; 251
    bc84:	32 e1       	ldi	r19, 0x12	; 18
    bc86:	0e 94 3b b4 	call	0x16876	; 0x16876 <__eewr_block>
    bc8a:	20 e0       	ldi	r18, 0x00	; 0
    bc8c:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    bc8e:	be 01       	movw	r22, r28
    bc90:	63 5d       	subi	r22, 0xD3	; 211
    bc92:	7f 4f       	sbci	r23, 0xFF	; 255
    bc94:	fb 01       	movw	r30, r22
    bc96:	e2 0f       	add	r30, r18
    bc98:	f3 1f       	adc	r31, r19
    bc9a:	d9 01       	movw	r26, r18
    bc9c:	ad 58       	subi	r26, 0x8D	; 141
    bc9e:	b3 4f       	sbci	r27, 0xF3	; 243
    bca0:	8c 91       	ld	r24, X
    bca2:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bca4:	2f 5f       	subi	r18, 0xFF	; 255
    bca6:	3f 4f       	sbci	r19, 0xFF	; 255
    bca8:	28 32       	cpi	r18, 0x28	; 40
    bcaa:	31 05       	cpc	r19, r1
    bcac:	99 f7       	brne	.-26     	; 0xbc94 <procMessage11+0x280>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    bcae:	fe 01       	movw	r30, r28
    bcb0:	eb 5a       	subi	r30, 0xAB	; 171
    bcb2:	ff 4f       	sbci	r31, 0xFF	; 255
    bcb4:	10 82       	st	Z, r1
    bcb6:	8f e6       	ldi	r24, 0x6F	; 111
    bcb8:	93 e0       	ldi	r25, 0x03	; 3
    bcba:	48 e2       	ldi	r20, 0x28	; 40
    bcbc:	50 e0       	ldi	r21, 0x00	; 0
    bcbe:	2b ef       	ldi	r18, 0xFB	; 251
    bcc0:	32 e1       	ldi	r19, 0x12	; 18
    bcc2:	0e 94 3b b4 	call	0x16876	; 0x16876 <__eewr_block>
    bcc6:	20 e0       	ldi	r18, 0x00	; 0
    bcc8:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    bcca:	be 01       	movw	r22, r28
    bccc:	63 5d       	subi	r22, 0xD3	; 211
    bcce:	7f 4f       	sbci	r23, 0xFF	; 255
    bcd0:	fb 01       	movw	r30, r22
    bcd2:	e2 0f       	add	r30, r18
    bcd4:	f3 1f       	adc	r31, r19
    bcd6:	d9 01       	movw	r26, r18
    bcd8:	a5 56       	subi	r26, 0x65	; 101
    bcda:	b3 4f       	sbci	r27, 0xF3	; 243
    bcdc:	8c 91       	ld	r24, X
    bcde:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bce0:	2f 5f       	subi	r18, 0xFF	; 255
    bce2:	3f 4f       	sbci	r19, 0xFF	; 255
    bce4:	28 32       	cpi	r18, 0x28	; 40
    bce6:	31 05       	cpc	r19, r1
    bce8:	99 f7       	brne	.-26     	; 0xbcd0 <procMessage11+0x2bc>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    bcea:	fe 01       	movw	r30, r28
    bcec:	eb 5a       	subi	r30, 0xAB	; 171
    bcee:	ff 4f       	sbci	r31, 0xFF	; 255
    bcf0:	10 82       	st	Z, r1
    bcf2:	88 e9       	ldi	r24, 0x98	; 152
    bcf4:	93 e0       	ldi	r25, 0x03	; 3
    bcf6:	48 e2       	ldi	r20, 0x28	; 40
    bcf8:	50 e0       	ldi	r21, 0x00	; 0
    bcfa:	2b ef       	ldi	r18, 0xFB	; 251
    bcfc:	32 e1       	ldi	r19, 0x12	; 18
    bcfe:	0e 94 3b b4 	call	0x16876	; 0x16876 <__eewr_block>
    bd02:	0b eb       	ldi	r16, 0xBB	; 187
    bd04:	10 e0       	ldi	r17, 0x00	; 0
    bd06:	2b ed       	ldi	r18, 0xDB	; 219
    bd08:	e2 2e       	mov	r14, r18
    bd0a:	2c e0       	ldi	r18, 0x0C	; 12
    bd0c:	f2 2e       	mov	r15, r18
    bd0e:	90 e2       	ldi	r25, 0x20	; 32
    bd10:	c9 2e       	mov	r12, r25
    bd12:	d1 2c       	mov	r13, r1
    bd14:	cc 0e       	add	r12, r28
    bd16:	dd 1e       	adc	r13, r29
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bd18:	8c e2       	ldi	r24, 0x2C	; 44
    bd1a:	a8 2e       	mov	r10, r24
    bd1c:	b1 2c       	mov	r11, r1
    bd1e:	ac 0e       	add	r10, r28
    bd20:	bd 1e       	adc	r11, r29
    bd22:	f6 01       	movw	r30, r12
    bd24:	d7 01       	movw	r26, r14
	    Dest[i]=Source[IdxSource+i];
    bd26:	8d 91       	ld	r24, X+
    bd28:	81 93       	st	Z+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bd2a:	ea 15       	cp	r30, r10
    bd2c:	fb 05       	cpc	r31, r11
    bd2e:	d9 f7       	brne	.-10     	; 0xbd26 <procMessage11+0x312>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    bd30:	1c a6       	std	Y+44, r1	; 0x2c
     StrPosCopy(rcv_trans,buffHeader,422,40);
     eeprom_write_block((const void*) &buffHeader, (void*) &DefHeaderFooter[9], 40);
	 //ProductName
	 for(i=0;i<6;i++){
	    StrPosCopy(rcv_trans,strProductName,(486+(i*12)),12);
		RemSpaceLag(strProductName);
    bd32:	c6 01       	movw	r24, r12
    bd34:	0e 94 70 24 	call	0x48e0	; 0x48e0 <RemSpaceLag>
    bd38:	c8 01       	movw	r24, r16
    bd3a:	b6 01       	movw	r22, r12
    bd3c:	4c e0       	ldi	r20, 0x0C	; 12
    bd3e:	50 e0       	ldi	r21, 0x00	; 0
    bd40:	2b ef       	ldi	r18, 0xFB	; 251
    bd42:	32 e1       	ldi	r19, 0x12	; 18
    bd44:	0e 94 3b b4 	call	0x16876	; 0x16876 <__eewr_block>
    bd48:	03 5f       	subi	r16, 0xF3	; 243
    bd4a:	1f 4f       	sbci	r17, 0xFF	; 255
    bd4c:	8c e0       	ldi	r24, 0x0C	; 12
    bd4e:	90 e0       	ldi	r25, 0x00	; 0
    bd50:	e8 0e       	add	r14, r24
    bd52:	f9 1e       	adc	r15, r25
     StrPosCopy(rcv_trans,buffHeader,382,40);
     eeprom_write_block((const void*) &buffHeader, (void*) &DefHeaderFooter[8], 40);
     StrPosCopy(rcv_trans,buffHeader,422,40);
     eeprom_write_block((const void*) &buffHeader, (void*) &DefHeaderFooter[9], 40);
	 //ProductName
	 for(i=0;i<6;i++){
    bd54:	91 e0       	ldi	r25, 0x01	; 1
    bd56:	09 30       	cpi	r16, 0x09	; 9
    bd58:	19 07       	cpc	r17, r25
    bd5a:	19 f7       	brne	.-58     	; 0xbd22 <procMessage11+0x30e>
    bd5c:	05 e8       	ldi	r16, 0x85	; 133
    bd5e:	10 e0       	ldi	r17, 0x00	; 0
    bd60:	b3 e2       	ldi	r27, 0x23	; 35
    bd62:	eb 2e       	mov	r14, r27
    bd64:	bd e0       	ldi	r27, 0x0D	; 13
    bd66:	fb 2e       	mov	r15, r27
    bd68:	6e 01       	movw	r12, r28
    bd6a:	08 94       	sec
    bd6c:	c1 1c       	adc	r12, r1
    bd6e:	d1 1c       	adc	r13, r1
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bd70:	a9 e0       	ldi	r26, 0x09	; 9
    bd72:	aa 2e       	mov	r10, r26
    bd74:	b1 2c       	mov	r11, r1
    bd76:	ac 0e       	add	r10, r28
    bd78:	bd 1e       	adc	r11, r29
     StrPosCopy(rcv_trans,buffHeader,382,40);
     eeprom_write_block((const void*) &buffHeader, (void*) &DefHeaderFooter[8], 40);
     StrPosCopy(rcv_trans,buffHeader,422,40);
     eeprom_write_block((const void*) &buffHeader, (void*) &DefHeaderFooter[9], 40);
	 //ProductName
	 for(i=0;i<6;i++){
    bd7a:	f6 01       	movw	r30, r12
    bd7c:	d7 01       	movw	r26, r14
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    bd7e:	8d 91       	ld	r24, X+
    bd80:	81 93       	st	Z+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    bd82:	ea 15       	cp	r30, r10
    bd84:	fb 05       	cpc	r31, r11
    bd86:	d9 f7       	brne	.-10     	; 0xbd7e <procMessage11+0x36a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    bd88:	19 86       	std	Y+9, r1	; 0x09
        eeprom_write_block((const void*) &strProductName, (void*) &DefProductName[i], 12);
	 }
	 //ProductPrice
	 for(i=0;i<6;i++){
        StrPosCopy(rcv_trans,strProductPrice,(558+(i*8)),8);
		RemSpaceLag(strProductPrice);
    bd8a:	c6 01       	movw	r24, r12
    bd8c:	0e 94 70 24 	call	0x48e0	; 0x48e0 <RemSpaceLag>
		RemZeroLead(strProductPrice);
    bd90:	c6 01       	movw	r24, r12
    bd92:	0e 94 dd 23 	call	0x47ba	; 0x47ba <RemZeroLead>
		RemDecimal(strProductPrice);
    bd96:	c6 01       	movw	r24, r12
    bd98:	0e 94 d5 22 	call	0x45aa	; 0x45aa <RemDecimal>
    bd9c:	c8 01       	movw	r24, r16
    bd9e:	b6 01       	movw	r22, r12
    bda0:	48 e0       	ldi	r20, 0x08	; 8
    bda2:	50 e0       	ldi	r21, 0x00	; 0
    bda4:	2b ef       	ldi	r18, 0xFB	; 251
    bda6:	32 e1       	ldi	r19, 0x12	; 18
    bda8:	0e 94 3b b4 	call	0x16876	; 0x16876 <__eewr_block>
    bdac:	07 5f       	subi	r16, 0xF7	; 247
    bdae:	1f 4f       	sbci	r17, 0xFF	; 255
    bdb0:	e8 e0       	ldi	r30, 0x08	; 8
    bdb2:	f0 e0       	ldi	r31, 0x00	; 0
    bdb4:	ee 0e       	add	r14, r30
    bdb6:	ff 1e       	adc	r15, r31
	    StrPosCopy(rcv_trans,strProductName,(486+(i*12)),12);
		RemSpaceLag(strProductName);
        eeprom_write_block((const void*) &strProductName, (void*) &DefProductName[i], 12);
	 }
	 //ProductPrice
	 for(i=0;i<6;i++){
    bdb8:	f0 e0       	ldi	r31, 0x00	; 0
    bdba:	0b 3b       	cpi	r16, 0xBB	; 187
    bdbc:	1f 07       	cpc	r17, r31
    bdbe:	e9 f6       	brne	.-70     	; 0xbd7a <procMessage11+0x366>
		RemSpaceLag(strProductPrice);
		RemZeroLead(strProductPrice);
		RemDecimal(strProductPrice);
        eeprom_write_block((const void*) &strProductPrice, (void*) &DefProductPrice[i], 8);
	 }
}
    bdc0:	cb 5a       	subi	r28, 0xAB	; 171
    bdc2:	df 4f       	sbci	r29, 0xFF	; 255
    bdc4:	0f b6       	in	r0, 0x3f	; 63
    bdc6:	f8 94       	cli
    bdc8:	de bf       	out	0x3e, r29	; 62
    bdca:	0f be       	out	0x3f, r0	; 63
    bdcc:	cd bf       	out	0x3d, r28	; 61
    bdce:	cf 91       	pop	r28
    bdd0:	df 91       	pop	r29
    bdd2:	1f 91       	pop	r17
    bdd4:	0f 91       	pop	r16
    bdd6:	ff 90       	pop	r15
    bdd8:	ef 90       	pop	r14
    bdda:	df 90       	pop	r13
    bddc:	cf 90       	pop	r12
    bdde:	bf 90       	pop	r11
    bde0:	af 90       	pop	r10
    bde2:	08 95       	ret

0000bde4 <FCloseShift>:
	 }
  return Result;
}


char FCloseShift(char ShiftType){//SHIFT_NONE,NEW_SHIFT,CONTINUE_SHIFT
    bde4:	df 92       	push	r13
    bde6:	ef 92       	push	r14
    bde8:	ff 92       	push	r15
    bdea:	0f 93       	push	r16
    bdec:	1f 93       	push	r17
    bdee:	df 93       	push	r29
    bdf0:	cf 93       	push	r28
    bdf2:	cd b7       	in	r28, 0x3d	; 61
    bdf4:	de b7       	in	r29, 0x3e	; 62
    bdf6:	64 97       	sbiw	r28, 0x14	; 20
    bdf8:	0f b6       	in	r0, 0x3f	; 63
    bdfa:	f8 94       	cli
    bdfc:	de bf       	out	0x3e, r29	; 62
    bdfe:	0f be       	out	0x3f, r0	; 63
    be00:	cd bf       	out	0x3d, r28	; 61
    be02:	18 2f       	mov	r17, r24
	 char KeyPressed;
	 char FIPAddr;


	 Result=MENU_NONE;
	 switch(stCloseShift){
    be04:	80 91 20 03 	lds	r24, 0x0320
    be08:	87 30       	cpi	r24, 0x07	; 7
    be0a:	09 f4       	brne	.+2      	; 0xbe0e <FCloseShift+0x2a>
    be0c:	a6 c1       	rjmp	.+844    	; 0xc15a <FCloseShift+0x376>
    be0e:	88 30       	cpi	r24, 0x08	; 8
    be10:	78 f4       	brcc	.+30     	; 0xbe30 <FCloseShift+0x4c>
    be12:	84 30       	cpi	r24, 0x04	; 4
    be14:	09 f4       	brne	.+2      	; 0xbe18 <FCloseShift+0x34>
    be16:	68 c0       	rjmp	.+208    	; 0xbee8 <FCloseShift+0x104>
    be18:	85 30       	cpi	r24, 0x05	; 5
    be1a:	18 f4       	brcc	.+6      	; 0xbe22 <FCloseShift+0x3e>
    be1c:	88 23       	and	r24, r24
    be1e:	c1 f0       	breq	.+48     	; 0xbe50 <FCloseShift+0x6c>
    be20:	22 c2       	rjmp	.+1092   	; 0xc266 <FCloseShift+0x482>
    be22:	85 30       	cpi	r24, 0x05	; 5
    be24:	09 f4       	brne	.+2      	; 0xbe28 <FCloseShift+0x44>
    be26:	a6 c0       	rjmp	.+332    	; 0xbf74 <FCloseShift+0x190>
    be28:	86 30       	cpi	r24, 0x06	; 6
    be2a:	09 f0       	breq	.+2      	; 0xbe2e <FCloseShift+0x4a>
    be2c:	1c c2       	rjmp	.+1080   	; 0xc266 <FCloseShift+0x482>
    be2e:	a8 c0       	rjmp	.+336    	; 0xbf80 <FCloseShift+0x19c>
    be30:	8a 30       	cpi	r24, 0x0A	; 10
    be32:	09 f4       	brne	.+2      	; 0xbe36 <FCloseShift+0x52>
    be34:	d6 c1       	rjmp	.+940    	; 0xc1e2 <FCloseShift+0x3fe>
    be36:	8b 30       	cpi	r24, 0x0B	; 11
    be38:	20 f4       	brcc	.+8      	; 0xbe42 <FCloseShift+0x5e>
    be3a:	88 30       	cpi	r24, 0x08	; 8
    be3c:	09 f0       	breq	.+2      	; 0xbe40 <FCloseShift+0x5c>
    be3e:	13 c2       	rjmp	.+1062   	; 0xc266 <FCloseShift+0x482>
    be40:	92 c1       	rjmp	.+804    	; 0xc166 <FCloseShift+0x382>
    be42:	8b 30       	cpi	r24, 0x0B	; 11
    be44:	09 f4       	brne	.+2      	; 0xbe48 <FCloseShift+0x64>
    be46:	0b c2       	rjmp	.+1046   	; 0xc25e <FCloseShift+0x47a>
    be48:	8c 30       	cpi	r24, 0x0C	; 12
    be4a:	09 f0       	breq	.+2      	; 0xbe4e <FCloseShift+0x6a>
    be4c:	0c c2       	rjmp	.+1048   	; 0xc266 <FCloseShift+0x482>
    be4e:	d2 c1       	rjmp	.+932    	; 0xc1f4 <FCloseShift+0x410>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    be50:	e1 99       	sbic	0x1c, 1	; 28
    be52:	fe cf       	rjmp	.-4      	; 0xbe50 <FCloseShift+0x6c>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    be54:	89 e4       	ldi	r24, 0x49	; 73
    be56:	91 e0       	ldi	r25, 0x01	; 1
    be58:	9f bb       	out	0x1f, r25	; 31
    be5a:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    be5c:	e0 9a       	sbi	0x1c, 0	; 28
    be5e:	8d b3       	in	r24, 0x1d	; 29
	 case csInitCloseShift:
	      ActivePump=eeprom_read_byte(&DefActivePump);
    be60:	80 93 60 01 	sts	0x0160, r24
		  IsPumpBusy=False;
    be64:	10 92 1f 03 	sts	0x031F, r1
    be68:	ff 24       	eor	r15, r15
					
		       if (strPumpStatus[FIPAddr]==GetPumpStatusLabel(PS_TOTALIZER))
			        UpdateStandaloneStatus(GetPumpID(FIPAddr),PUMP_OFF);
					
               if (strPumpStatus[FIPAddr]==GetPumpStatusLabel(PUMP_BUSY))
			       IsPumpBusy=True;
    be6a:	dd 24       	eor	r13, r13
    be6c:	d3 94       	inc	r13
    be6e:	36 c0       	rjmp	.+108    	; 0xbedc <FCloseShift+0xf8>
	 case csInitCloseShift:
	      ActivePump=eeprom_read_byte(&DefActivePump);
		  IsPumpBusy=False;
		  //FindBusy Pump
		  for (FIPAddr=0;FIPAddr<ActivePump;FIPAddr++){		       
		       if ((strPumpStatus[FIPAddr]!=GetPumpStatusLabel(PUMP_NONE))&&(strPumpStatus[FIPAddr]!=GetPumpStatusLabel(PUMP_OFF))&&(strPumpStatus[FIPAddr]!=GetPumpStatusLabel(PUMP_BUSY)))
    be70:	0f 2d       	mov	r16, r15
    be72:	10 e0       	ldi	r17, 0x00	; 0
    be74:	f8 01       	movw	r30, r16
    be76:	ee 5e       	subi	r30, 0xEE	; 238
    be78:	fe 4f       	sbci	r31, 0xFE	; 254
    be7a:	e0 80       	ld	r14, Z
    be7c:	8e e0       	ldi	r24, 0x0E	; 14
    be7e:	0e 94 90 13 	call	0x2720	; 0x2720 <GetPumpStatusLabel>
    be82:	e8 16       	cp	r14, r24
    be84:	81 f0       	breq	.+32     	; 0xbea6 <FCloseShift+0xc2>
    be86:	86 e0       	ldi	r24, 0x06	; 6
    be88:	0e 94 90 13 	call	0x2720	; 0x2720 <GetPumpStatusLabel>
    be8c:	e8 16       	cp	r14, r24
    be8e:	59 f0       	breq	.+22     	; 0xbea6 <FCloseShift+0xc2>
    be90:	89 e0       	ldi	r24, 0x09	; 9
    be92:	0e 94 90 13 	call	0x2720	; 0x2720 <GetPumpStatusLabel>
    be96:	e8 16       	cp	r14, r24
    be98:	31 f0       	breq	.+12     	; 0xbea6 <FCloseShift+0xc2>
				    UpdateStandaloneStatus(GetPumpID(FIPAddr),PUMP_OFF);
    be9a:	8f 2d       	mov	r24, r15
    be9c:	0e 94 ce 1c 	call	0x399c	; 0x399c <GetPumpID>
    bea0:	66 e0       	ldi	r22, 0x06	; 6
    bea2:	0e 94 70 1c 	call	0x38e0	; 0x38e0 <UpdateStandaloneStatus>
					
		       if (strPumpStatus[FIPAddr]==GetPumpStatusLabel(PS_TOTALIZER))
    bea6:	84 e1       	ldi	r24, 0x14	; 20
    bea8:	0e 94 90 13 	call	0x2720	; 0x2720 <GetPumpStatusLabel>
    beac:	f8 01       	movw	r30, r16
    beae:	ee 5e       	subi	r30, 0xEE	; 238
    beb0:	fe 4f       	sbci	r31, 0xFE	; 254
    beb2:	90 81       	ld	r25, Z
    beb4:	98 17       	cp	r25, r24
    beb6:	31 f4       	brne	.+12     	; 0xbec4 <FCloseShift+0xe0>
			        UpdateStandaloneStatus(GetPumpID(FIPAddr),PUMP_OFF);
    beb8:	8f 2d       	mov	r24, r15
    beba:	0e 94 ce 1c 	call	0x399c	; 0x399c <GetPumpID>
    bebe:	66 e0       	ldi	r22, 0x06	; 6
    bec0:	0e 94 70 1c 	call	0x38e0	; 0x38e0 <UpdateStandaloneStatus>
					
               if (strPumpStatus[FIPAddr]==GetPumpStatusLabel(PUMP_BUSY))
    bec4:	89 e0       	ldi	r24, 0x09	; 9
    bec6:	0e 94 90 13 	call	0x2720	; 0x2720 <GetPumpStatusLabel>
    beca:	0e 5e       	subi	r16, 0xEE	; 238
    becc:	1e 4f       	sbci	r17, 0xFE	; 254
    bece:	d8 01       	movw	r26, r16
    bed0:	9c 91       	ld	r25, X
    bed2:	98 17       	cp	r25, r24
    bed4:	11 f4       	brne	.+4      	; 0xbeda <FCloseShift+0xf6>
			       IsPumpBusy=True;
    bed6:	d0 92 1f 03 	sts	0x031F, r13
	 switch(stCloseShift){
	 case csInitCloseShift:
	      ActivePump=eeprom_read_byte(&DefActivePump);
		  IsPumpBusy=False;
		  //FindBusy Pump
		  for (FIPAddr=0;FIPAddr<ActivePump;FIPAddr++){		       
    beda:	f3 94       	inc	r15
    bedc:	80 91 60 01 	lds	r24, 0x0160
    bee0:	f8 16       	cp	r15, r24
    bee2:	30 f2       	brcs	.-116    	; 0xbe70 <FCloseShift+0x8c>
					
               if (strPumpStatus[FIPAddr]==GetPumpStatusLabel(PUMP_BUSY))
			       IsPumpBusy=True;
			   }

          stCloseShift=csSendTotalizerALL;
    bee4:	84 e0       	ldi	r24, 0x04	; 4
    bee6:	b8 c1       	rjmp	.+880    	; 0xc258 <FCloseShift+0x474>
			  */
	      break;
     case csWaitPumpLocked:	     
	      break;
     case csSendTotalizerALL:
	      lcd_clear();
    bee8:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
		  lcd_printf(1,1,PSTR("Totalizer.."));
    beec:	81 e0       	ldi	r24, 0x01	; 1
    beee:	61 e0       	ldi	r22, 0x01	; 1
    bef0:	48 e9       	ldi	r20, 0x98	; 152
    bef2:	55 e1       	ldi	r21, 0x15	; 21
    bef4:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		  
		  sprintf_P(lcdteks,PSTR("Wait Pump:%d "),(ActivePump-CountTotalizerSatus(strPumpStatus)));
    bef8:	00 91 60 01 	lds	r16, 0x0160
    befc:	10 e0       	ldi	r17, 0x00	; 0
    befe:	82 e1       	ldi	r24, 0x12	; 18
    bf00:	91 e0       	ldi	r25, 0x01	; 1
    bf02:	0e 94 8c 2d 	call	0x5b18	; 0x5b18 <CountTotalizerSatus>
    bf06:	00 d0       	rcall	.+0      	; 0xbf08 <FCloseShift+0x124>
    bf08:	00 d0       	rcall	.+0      	; 0xbf0a <FCloseShift+0x126>
    bf0a:	00 d0       	rcall	.+0      	; 0xbf0c <FCloseShift+0x128>
    bf0c:	ed b7       	in	r30, 0x3d	; 61
    bf0e:	fe b7       	in	r31, 0x3e	; 62
    bf10:	31 96       	adiw	r30, 0x01	; 1
    bf12:	7e 01       	movw	r14, r28
    bf14:	08 94       	sec
    bf16:	e1 1c       	adc	r14, r1
    bf18:	f1 1c       	adc	r15, r1
    bf1a:	ad b7       	in	r26, 0x3d	; 61
    bf1c:	be b7       	in	r27, 0x3e	; 62
    bf1e:	12 96       	adiw	r26, 0x02	; 2
    bf20:	fc 92       	st	X, r15
    bf22:	ee 92       	st	-X, r14
    bf24:	11 97       	sbiw	r26, 0x01	; 1
    bf26:	2a e8       	ldi	r18, 0x8A	; 138
    bf28:	35 e1       	ldi	r19, 0x15	; 21
    bf2a:	33 83       	std	Z+3, r19	; 0x03
    bf2c:	22 83       	std	Z+2, r18	; 0x02
    bf2e:	08 1b       	sub	r16, r24
    bf30:	11 09       	sbc	r17, r1
    bf32:	15 83       	std	Z+5, r17	; 0x05
    bf34:	04 83       	std	Z+4, r16	; 0x04
    bf36:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
		  lcd_print(2,1,lcdteks);
    bf3a:	ed b7       	in	r30, 0x3d	; 61
    bf3c:	fe b7       	in	r31, 0x3e	; 62
    bf3e:	36 96       	adiw	r30, 0x06	; 6
    bf40:	0f b6       	in	r0, 0x3f	; 63
    bf42:	f8 94       	cli
    bf44:	fe bf       	out	0x3e, r31	; 62
    bf46:	0f be       	out	0x3f, r0	; 63
    bf48:	ed bf       	out	0x3d, r30	; 61
    bf4a:	82 e0       	ldi	r24, 0x02	; 2
    bf4c:	61 e0       	ldi	r22, 0x01	; 1
    bf4e:	a7 01       	movw	r20, r14
    bf50:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>


          IsNewPumpStatus=True;
    bf54:	11 e0       	ldi	r17, 0x01	; 1
    bf56:	10 93 11 01 	sts	0x0111, r17
		  DisplayPumpStatus(); 
    bf5a:	0e 94 6e 41 	call	0x82dc	; 0x82dc <DisplayPumpStatus>
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    bf5e:	95 e0       	ldi	r25, 0x05	; 5
    bf60:	90 93 8a 07 	sts	0x078A, r25
	 PoolMsg=plMsg;
    bf64:	82 e1       	ldi	r24, 0x12	; 18
    bf66:	80 93 ae 0d 	sts	0x0DAE, r24
     IsControlPooling=True;
    bf6a:	10 93 97 01 	sts	0x0197, r17
          IsNewPumpStatus=True;
		  DisplayPumpStatus(); 
		  //SendCommand
	      //SendSlaveCommand(SC_TOTALIZER,PUMP_ALL);          
		  SendPoolingCommand(SC_TOTALIZER,PUMP_ALL);
		  stCloseShift=csDisplayPumpStatus;
    bf6e:	90 93 20 03 	sts	0x0320, r25
    bf72:	79 c1       	rjmp	.+754    	; 0xc266 <FCloseShift+0x482>
	      break;
     case csDisplayPumpStatus:
		  DisplayPumpStatus(); 
    bf74:	0e 94 6e 41 	call	0x82dc	; 0x82dc <DisplayPumpStatus>
		  TimDisplay=0;         
    bf78:	10 92 a7 01 	sts	0x01A7, r1
          stCloseShift=csWaitTotalizerComplete;
    bf7c:	86 e0       	ldi	r24, 0x06	; 6
    bf7e:	6c c1       	rjmp	.+728    	; 0xc258 <FCloseShift+0x474>
	      break;
     case csWaitTotalizerComplete:
	      KeyPressed=_key_scan(1);
    bf80:	81 e0       	ldi	r24, 0x01	; 1
    bf82:	0e 94 ab ae 	call	0x15d56	; 0x15d56 <_key_scan>
    bf86:	d8 2e       	mov	r13, r24
		  if (IsNewPumpStatus==True){
    bf88:	80 91 11 01 	lds	r24, 0x0111
    bf8c:	81 30       	cpi	r24, 0x01	; 1
    bf8e:	89 f5       	brne	.+98     	; 0xbff2 <FCloseShift+0x20e>
			  sprintf_P(lcdteks,PSTR("Wait Pump:%d "),(ActivePump-CountTotalizerSatus(strPumpStatus)));
    bf90:	00 91 60 01 	lds	r16, 0x0160
    bf94:	10 e0       	ldi	r17, 0x00	; 0
    bf96:	82 e1       	ldi	r24, 0x12	; 18
    bf98:	91 e0       	ldi	r25, 0x01	; 1
    bf9a:	0e 94 8c 2d 	call	0x5b18	; 0x5b18 <CountTotalizerSatus>
    bf9e:	00 d0       	rcall	.+0      	; 0xbfa0 <FCloseShift+0x1bc>
    bfa0:	00 d0       	rcall	.+0      	; 0xbfa2 <FCloseShift+0x1be>
    bfa2:	00 d0       	rcall	.+0      	; 0xbfa4 <FCloseShift+0x1c0>
    bfa4:	ed b7       	in	r30, 0x3d	; 61
    bfa6:	fe b7       	in	r31, 0x3e	; 62
    bfa8:	31 96       	adiw	r30, 0x01	; 1
    bfaa:	7e 01       	movw	r14, r28
    bfac:	08 94       	sec
    bfae:	e1 1c       	adc	r14, r1
    bfb0:	f1 1c       	adc	r15, r1
    bfb2:	ad b7       	in	r26, 0x3d	; 61
    bfb4:	be b7       	in	r27, 0x3e	; 62
    bfb6:	12 96       	adiw	r26, 0x02	; 2
    bfb8:	fc 92       	st	X, r15
    bfba:	ee 92       	st	-X, r14
    bfbc:	11 97       	sbiw	r26, 0x01	; 1
    bfbe:	2c e7       	ldi	r18, 0x7C	; 124
    bfc0:	35 e1       	ldi	r19, 0x15	; 21
    bfc2:	33 83       	std	Z+3, r19	; 0x03
    bfc4:	22 83       	std	Z+2, r18	; 0x02
    bfc6:	08 1b       	sub	r16, r24
    bfc8:	11 09       	sbc	r17, r1
    bfca:	15 83       	std	Z+5, r17	; 0x05
    bfcc:	04 83       	std	Z+4, r16	; 0x04
    bfce:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
			  lcd_print(2,1,lcdteks);
    bfd2:	ed b7       	in	r30, 0x3d	; 61
    bfd4:	fe b7       	in	r31, 0x3e	; 62
    bfd6:	36 96       	adiw	r30, 0x06	; 6
    bfd8:	0f b6       	in	r0, 0x3f	; 63
    bfda:	f8 94       	cli
    bfdc:	fe bf       	out	0x3e, r31	; 62
    bfde:	0f be       	out	0x3f, r0	; 63
    bfe0:	ed bf       	out	0x3d, r30	; 61
    bfe2:	82 e0       	ldi	r24, 0x02	; 2
    bfe4:	61 e0       	ldi	r22, 0x01	; 1
    bfe6:	a7 01       	movw	r20, r14
    bfe8:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
		  	  stCloseShift=csDisplayPumpStatus;	 
    bfec:	85 e0       	ldi	r24, 0x05	; 5
    bfee:	80 93 20 03 	sts	0x0320, r24
		  }
		  if ((CountTotalizerSatus(strPumpStatus)>=ActivePump)&&(TimDisplay>5)){
    bff2:	82 e1       	ldi	r24, 0x12	; 18
    bff4:	91 e0       	ldi	r25, 0x01	; 1
    bff6:	0e 94 8c 2d 	call	0x5b18	; 0x5b18 <CountTotalizerSatus>
    bffa:	90 91 60 01 	lds	r25, 0x0160
    bffe:	89 17       	cp	r24, r25
    c000:	a0 f0       	brcs	.+40     	; 0xc02a <FCloseShift+0x246>
    c002:	80 91 a7 01 	lds	r24, 0x01A7
    c006:	86 30       	cpi	r24, 0x06	; 6
    c008:	80 f0       	brcs	.+32     	; 0xc02a <FCloseShift+0x246>
    c00a:	10 e0       	ldi	r17, 0x00	; 0
    c00c:	07 c0       	rjmp	.+14     	; 0xc01c <FCloseShift+0x238>
		      for (FIPAddr=0;FIPAddr<ActivePump;FIPAddr++)
			       UpdateStandaloneStatus(GetPumpID(FIPAddr),PUMP_OFF);
    c00e:	81 2f       	mov	r24, r17
    c010:	0e 94 ce 1c 	call	0x399c	; 0x399c <GetPumpID>
    c014:	66 e0       	ldi	r22, 0x06	; 6
    c016:	0e 94 70 1c 	call	0x38e0	; 0x38e0 <UpdateStandaloneStatus>
			  sprintf_P(lcdteks,PSTR("Wait Pump:%d "),(ActivePump-CountTotalizerSatus(strPumpStatus)));
			  lcd_print(2,1,lcdteks);
		  	  stCloseShift=csDisplayPumpStatus;	 
		  }
		  if ((CountTotalizerSatus(strPumpStatus)>=ActivePump)&&(TimDisplay>5)){
		      for (FIPAddr=0;FIPAddr<ActivePump;FIPAddr++)
    c01a:	1f 5f       	subi	r17, 0xFF	; 255
    c01c:	80 91 60 01 	lds	r24, 0x0160
    c020:	18 17       	cp	r17, r24
    c022:	a8 f3       	brcs	.-22     	; 0xc00e <FCloseShift+0x22a>
			       UpdateStandaloneStatus(GetPumpID(FIPAddr),PUMP_OFF);

		      stCloseShift=csGenerateReport;		      
    c024:	88 e0       	ldi	r24, 0x08	; 8
    c026:	80 93 20 03 	sts	0x0320, r24
			  }
          //sprintf_P(lcdteks,PSTR("TimSend:%d"),TimDisplay);
		  //lcd_print(3,1,lcdteks);

          if ((TimDisplay>15)&&(IsPumpBusy!=True)){
    c02a:	80 91 a7 01 	lds	r24, 0x01A7
    c02e:	80 31       	cpi	r24, 0x10	; 16
    c030:	08 f4       	brcc	.+2      	; 0xc034 <FCloseShift+0x250>
    c032:	67 c0       	rjmp	.+206    	; 0xc102 <FCloseShift+0x31e>
    c034:	80 91 1f 03 	lds	r24, 0x031F
    c038:	81 30       	cpi	r24, 0x01	; 1
    c03a:	09 f4       	brne	.+2      	; 0xc03e <FCloseShift+0x25a>
    c03c:	62 c0       	rjmp	.+196    	; 0xc102 <FCloseShift+0x31e>
		      if(CountNoPumpSatus(strPumpStatus)>=eeprom_read_byte(&DefActivePump)){
    c03e:	82 e1       	ldi	r24, 0x12	; 18
    c040:	91 e0       	ldi	r25, 0x01	; 1
    c042:	0e 94 8c 16 	call	0x2d18	; 0x2d18 <CountNoPumpSatus>
    c046:	28 2f       	mov	r18, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    c048:	e1 99       	sbic	0x1c, 1	; 28
    c04a:	fe cf       	rjmp	.-4      	; 0xc048 <FCloseShift+0x264>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    c04c:	89 e4       	ldi	r24, 0x49	; 73
    c04e:	91 e0       	ldi	r25, 0x01	; 1
    c050:	9f bb       	out	0x1f, r25	; 31
    c052:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    c054:	e0 9a       	sbi	0x1c, 0	; 28
    c056:	8d b3       	in	r24, 0x1d	; 29
    c058:	28 17       	cp	r18, r24
    c05a:	08 f4       	brcc	.+2      	; 0xc05e <FCloseShift+0x27a>
    c05c:	52 c0       	rjmp	.+164    	; 0xc102 <FCloseShift+0x31e>
			  //lcd_printf(2,1,PSTR("NoPumpFound  ")); 
			  //sprintf_P(lcdteks,PSTR("NoPumpFound:%d"),CountNoPumpSatus(strPumpStatus));
			  sprintf_P(lcdteks,PSTR("Error - No Pump:%d "),ActivePump-CountNoPumpSatus(strPumpStatus));
    c05e:	00 91 60 01 	lds	r16, 0x0160
    c062:	10 e0       	ldi	r17, 0x00	; 0
    c064:	82 e1       	ldi	r24, 0x12	; 18
    c066:	91 e0       	ldi	r25, 0x01	; 1
    c068:	0e 94 8c 16 	call	0x2d18	; 0x2d18 <CountNoPumpSatus>
    c06c:	00 d0       	rcall	.+0      	; 0xc06e <FCloseShift+0x28a>
    c06e:	00 d0       	rcall	.+0      	; 0xc070 <FCloseShift+0x28c>
    c070:	00 d0       	rcall	.+0      	; 0xc072 <FCloseShift+0x28e>
    c072:	ed b7       	in	r30, 0x3d	; 61
    c074:	fe b7       	in	r31, 0x3e	; 62
    c076:	31 96       	adiw	r30, 0x01	; 1
    c078:	7e 01       	movw	r14, r28
    c07a:	08 94       	sec
    c07c:	e1 1c       	adc	r14, r1
    c07e:	f1 1c       	adc	r15, r1
    c080:	ad b7       	in	r26, 0x3d	; 61
    c082:	be b7       	in	r27, 0x3e	; 62
    c084:	12 96       	adiw	r26, 0x02	; 2
    c086:	fc 92       	st	X, r15
    c088:	ee 92       	st	-X, r14
    c08a:	11 97       	sbiw	r26, 0x01	; 1
    c08c:	28 e6       	ldi	r18, 0x68	; 104
    c08e:	35 e1       	ldi	r19, 0x15	; 21
    c090:	33 83       	std	Z+3, r19	; 0x03
    c092:	22 83       	std	Z+2, r18	; 0x02
    c094:	08 1b       	sub	r16, r24
    c096:	11 09       	sbc	r17, r1
    c098:	15 83       	std	Z+5, r17	; 0x05
    c09a:	04 83       	std	Z+4, r16	; 0x04
    c09c:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
			  lcd_print(3,1,lcdteks);
    c0a0:	ed b7       	in	r30, 0x3d	; 61
    c0a2:	fe b7       	in	r31, 0x3e	; 62
    c0a4:	36 96       	adiw	r30, 0x06	; 6
    c0a6:	0f b6       	in	r0, 0x3f	; 63
    c0a8:	f8 94       	cli
    c0aa:	fe bf       	out	0x3e, r31	; 62
    c0ac:	0f be       	out	0x3f, r0	; 63
    c0ae:	ed bf       	out	0x3d, r30	; 61
    c0b0:	83 e0       	ldi	r24, 0x03	; 3
    c0b2:	61 e0       	ldi	r22, 0x01	; 1
    c0b4:	a7 01       	movw	r20, r14
    c0b6:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
    c0ba:	10 e0       	ldi	r17, 0x00	; 0
    c0bc:	11 c0       	rjmp	.+34     	; 0xc0e0 <FCloseShift+0x2fc>
			  
			  for (FIPAddr=0;FIPAddr<ActivePump;FIPAddr++){
		           if (strPumpStatus[FIPAddr]==GetPumpStatusLabel(PS_TOTALIZER))
    c0be:	84 e1       	ldi	r24, 0x14	; 20
    c0c0:	0e 94 90 13 	call	0x2720	; 0x2720 <GetPumpStatusLabel>
    c0c4:	e1 2f       	mov	r30, r17
    c0c6:	f0 e0       	ldi	r31, 0x00	; 0
    c0c8:	ee 5e       	subi	r30, 0xEE	; 238
    c0ca:	fe 4f       	sbci	r31, 0xFE	; 254
    c0cc:	90 81       	ld	r25, Z
    c0ce:	98 17       	cp	r25, r24
    c0d0:	31 f4       	brne	.+12     	; 0xc0de <FCloseShift+0x2fa>
			           UpdateStandaloneStatus(GetPumpID(FIPAddr),PUMP_OFF);
    c0d2:	81 2f       	mov	r24, r17
    c0d4:	0e 94 ce 1c 	call	0x399c	; 0x399c <GetPumpID>
    c0d8:	66 e0       	ldi	r22, 0x06	; 6
    c0da:	0e 94 70 1c 	call	0x38e0	; 0x38e0 <UpdateStandaloneStatus>
			  //lcd_printf(2,1,PSTR("NoPumpFound  ")); 
			  //sprintf_P(lcdteks,PSTR("NoPumpFound:%d"),CountNoPumpSatus(strPumpStatus));
			  sprintf_P(lcdteks,PSTR("Error - No Pump:%d "),ActivePump-CountNoPumpSatus(strPumpStatus));
			  lcd_print(3,1,lcdteks);
			  
			  for (FIPAddr=0;FIPAddr<ActivePump;FIPAddr++){
    c0de:	1f 5f       	subi	r17, 0xFF	; 255
    c0e0:	80 91 60 01 	lds	r24, 0x0160
    c0e4:	18 17       	cp	r17, r24
    c0e6:	58 f3       	brcs	.-42     	; 0xc0be <FCloseShift+0x2da>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    c0e8:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    c0ea:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    c0ec:	81 e0       	ldi	r24, 0x01	; 1
    c0ee:	90 e0       	ldi	r25, 0x00	; 0
    c0f0:	90 93 d7 01 	sts	0x01D7, r25
    c0f4:	80 93 d6 01 	sts	0x01D6, r24
		           if (strPumpStatus[FIPAddr]==GetPumpStatusLabel(PS_TOTALIZER))
			           UpdateStandaloneStatus(GetPumpID(FIPAddr),PUMP_OFF);
			  }

			  system_beep(1);
			  TimDisplay=0;
    c0f8:	10 92 a7 01 	sts	0x01A7, r1
			  stCloseShift=csNoPumpFound;		     
    c0fc:	87 e0       	ldi	r24, 0x07	; 7
    c0fe:	80 93 20 03 	sts	0x0320, r24
			  }			  
		  }
		  if (KeyPressed==_KEY_CANCEL){
    c102:	f7 ee       	ldi	r31, 0xE7	; 231
    c104:	df 16       	cp	r13, r31
    c106:	09 f0       	breq	.+2      	; 0xc10a <FCloseShift+0x326>
    c108:	ae c0       	rjmp	.+348    	; 0xc266 <FCloseShift+0x482>
			  sprintf_P(lcdteks,PSTR("Cancel"));
    c10a:	00 d0       	rcall	.+0      	; 0xc10c <FCloseShift+0x328>
    c10c:	00 d0       	rcall	.+0      	; 0xc10e <FCloseShift+0x32a>
    c10e:	8e 01       	movw	r16, r28
    c110:	0f 5f       	subi	r16, 0xFF	; 255
    c112:	1f 4f       	sbci	r17, 0xFF	; 255
    c114:	ad b7       	in	r26, 0x3d	; 61
    c116:	be b7       	in	r27, 0x3e	; 62
    c118:	12 96       	adiw	r26, 0x02	; 2
    c11a:	1c 93       	st	X, r17
    c11c:	0e 93       	st	-X, r16
    c11e:	11 97       	sbiw	r26, 0x01	; 1
    c120:	81 e6       	ldi	r24, 0x61	; 97
    c122:	95 e1       	ldi	r25, 0x15	; 21
    c124:	14 96       	adiw	r26, 0x04	; 4
    c126:	9c 93       	st	X, r25
    c128:	8e 93       	st	-X, r24
    c12a:	13 97       	sbiw	r26, 0x03	; 3
    c12c:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
			  lcd_print(3,1,lcdteks);
    c130:	0f 90       	pop	r0
    c132:	0f 90       	pop	r0
    c134:	0f 90       	pop	r0
    c136:	0f 90       	pop	r0
    c138:	83 e0       	ldi	r24, 0x03	; 3
    c13a:	61 e0       	ldi	r22, 0x01	; 1
    c13c:	a8 01       	movw	r20, r16
    c13e:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    c142:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    c144:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    c146:	81 e0       	ldi	r24, 0x01	; 1
    c148:	90 e0       	ldi	r25, 0x00	; 0
    c14a:	90 93 d7 01 	sts	0x01D7, r25
    c14e:	80 93 d6 01 	sts	0x01D6, r24
		  }
		  if (KeyPressed==_KEY_CANCEL){
			  sprintf_P(lcdteks,PSTR("Cancel"));
			  lcd_print(3,1,lcdteks);
			  system_beep(1);
			  TimDisplay=0;
    c152:	10 92 a7 01 	sts	0x01A7, r1
			  stCloseShift=csNoPumpFound;		     		  
    c156:	87 e0       	ldi	r24, 0x07	; 7
    c158:	7f c0       	rjmp	.+254    	; 0xc258 <FCloseShift+0x474>
		  }
	      break;
     case csNoPumpFound:
	      if (TimDisplay>TIM_DISPLAY){
    c15a:	80 91 a7 01 	lds	r24, 0x01A7
    c15e:	8b 30       	cpi	r24, 0x0B	; 11
    c160:	08 f4       	brcc	.+2      	; 0xc164 <FCloseShift+0x380>
    c162:	81 c0       	rjmp	.+258    	; 0xc266 <FCloseShift+0x482>
    c164:	78 c0       	rjmp	.+240    	; 0xc256 <FCloseShift+0x472>
		      stCloseShift=csFinishCloseShift;
		  }	      
	      break;
     case csGenerateReport:
		  lcd_printf(1,1,PSTR("Printing Totalizer"));
    c166:	81 e0       	ldi	r24, 0x01	; 1
    c168:	61 e0       	ldi	r22, 0x01	; 1
    c16a:	4e e4       	ldi	r20, 0x4E	; 78
    c16c:	55 e1       	ldi	r21, 0x15	; 21
    c16e:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
          _datetime(0, strSystemDate, strSystemTime);
    c172:	0a e9       	ldi	r16, 0x9A	; 154
    c174:	15 e0       	ldi	r17, 0x05	; 5
    c176:	39 e7       	ldi	r19, 0x79	; 121
    c178:	e3 2e       	mov	r14, r19
    c17a:	3a e0       	ldi	r19, 0x0A	; 10
    c17c:	f3 2e       	mov	r15, r19
    c17e:	80 e0       	ldi	r24, 0x00	; 0
    c180:	b8 01       	movw	r22, r16
    c182:	a7 01       	movw	r20, r14
    c184:	0e 94 76 b1 	call	0x162ec	; 0x162ec <_datetime>
		  sprintf_P(CurrentShiftDateTime,PSTR("%s %s"),strSystemDate,strSystemTime);
    c188:	ed b7       	in	r30, 0x3d	; 61
    c18a:	fe b7       	in	r31, 0x3e	; 62
    c18c:	38 97       	sbiw	r30, 0x08	; 8
    c18e:	0f b6       	in	r0, 0x3f	; 63
    c190:	f8 94       	cli
    c192:	fe bf       	out	0x3e, r31	; 62
    c194:	0f be       	out	0x3f, r0	; 63
    c196:	ed bf       	out	0x3d, r30	; 61
    c198:	31 96       	adiw	r30, 0x01	; 1
    c19a:	81 e7       	ldi	r24, 0x71	; 113
    c19c:	99 e0       	ldi	r25, 0x09	; 9
    c19e:	ad b7       	in	r26, 0x3d	; 61
    c1a0:	be b7       	in	r27, 0x3e	; 62
    c1a2:	12 96       	adiw	r26, 0x02	; 2
    c1a4:	9c 93       	st	X, r25
    c1a6:	8e 93       	st	-X, r24
    c1a8:	11 97       	sbiw	r26, 0x01	; 1
    c1aa:	88 e4       	ldi	r24, 0x48	; 72
    c1ac:	95 e1       	ldi	r25, 0x15	; 21
    c1ae:	93 83       	std	Z+3, r25	; 0x03
    c1b0:	82 83       	std	Z+2, r24	; 0x02
    c1b2:	15 83       	std	Z+5, r17	; 0x05
    c1b4:	04 83       	std	Z+4, r16	; 0x04
    c1b6:	f7 82       	std	Z+7, r15	; 0x07
    c1b8:	e6 82       	std	Z+6, r14	; 0x06
    c1ba:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
		  IsGenerateReport=True;
    c1be:	81 e0       	ldi	r24, 0x01	; 1
    c1c0:	80 93 99 01 	sts	0x0199, r24
		  IsFinishPrintingTotalizer=False;
    c1c4:	10 92 9a 01 	sts	0x019A, r1
		  stCloseShift=csWaitPrintTotalizerComplete;
    c1c8:	8a e0       	ldi	r24, 0x0A	; 10
    c1ca:	80 93 20 03 	sts	0x0320, r24
    c1ce:	80 e0       	ldi	r24, 0x00	; 0
    c1d0:	ed b7       	in	r30, 0x3d	; 61
    c1d2:	fe b7       	in	r31, 0x3e	; 62
    c1d4:	38 96       	adiw	r30, 0x08	; 8
    c1d6:	0f b6       	in	r0, 0x3f	; 63
    c1d8:	f8 94       	cli
    c1da:	fe bf       	out	0x3e, r31	; 62
    c1dc:	0f be       	out	0x3f, r0	; 63
    c1de:	ed bf       	out	0x3d, r30	; 61
    c1e0:	43 c0       	rjmp	.+134    	; 0xc268 <FCloseShift+0x484>
	      break;
     case csWaitTotalizerALL:
	      break;
     case csWaitPrintTotalizerComplete:
	      if (IsFinishPrintingTotalizer==True){
    c1e2:	80 91 9a 01 	lds	r24, 0x019A
    c1e6:	81 30       	cpi	r24, 0x01	; 1
    c1e8:	09 f0       	breq	.+2      	; 0xc1ec <FCloseShift+0x408>
    c1ea:	3d c0       	rjmp	.+122    	; 0xc266 <FCloseShift+0x482>
		      IsFinishPrintingTotalizer=False;
    c1ec:	10 92 9a 01 	sts	0x019A, r1
		      stCloseShift=csDumpShift;
    c1f0:	8c e0       	ldi	r24, 0x0C	; 12
    c1f2:	32 c0       	rjmp	.+100    	; 0xc258 <FCloseShift+0x474>
		  }
	      break;
     case csDumpShift://Increment CurrentShift save Current to Last
		  lcd_printf(1,1,PSTR("Saving ShiftData.. "));
    c1f4:	81 e0       	ldi	r24, 0x01	; 1
    c1f6:	61 e0       	ldi	r22, 0x01	; 1
    c1f8:	44 e3       	ldi	r20, 0x34	; 52
    c1fa:	55 e1       	ldi	r21, 0x15	; 21
    c1fc:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
	      if (ShiftType==CONTINUE_SHIFT)//Shift=Shift+1
    c200:	12 30       	cpi	r17, 0x02	; 2
    c202:	71 f4       	brne	.+28     	; 0xc220 <FCloseShift+0x43c>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    c204:	e1 99       	sbic	0x1c, 1	; 28
    c206:	fe cf       	rjmp	.-4      	; 0xc204 <FCloseShift+0x420>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    c208:	2f e3       	ldi	r18, 0x3F	; 63
    c20a:	31 e0       	ldi	r19, 0x01	; 1
    c20c:	3f bb       	out	0x1f, r19	; 31
    c20e:	2e bb       	out	0x1e, r18	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    c210:	e0 9a       	sbi	0x1c, 0	; 28
    c212:	8d b3       	in	r24, 0x1d	; 29
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    c214:	e1 99       	sbic	0x1c, 1	; 28
    c216:	fe cf       	rjmp	.-4      	; 0xc214 <FCloseShift+0x430>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    c218:	3f bb       	out	0x1f, r19	; 31
    c21a:	2e bb       	out	0x1e, r18	; 30
		      eeprom_write_byte(&DefShift,eeprom_read_byte(&DefShift)+1);	 
    c21c:	8f 5f       	subi	r24, 0xFF	; 255
    c21e:	09 c0       	rjmp	.+18     	; 0xc232 <FCloseShift+0x44e>
          else if (ShiftType==NEW_SHIFT)//Shift=1
    c220:	11 30       	cpi	r17, 0x01	; 1
    c222:	69 f4       	brne	.+26     	; 0xc23e <FCloseShift+0x45a>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    c224:	e1 99       	sbic	0x1c, 1	; 28
    c226:	fe cf       	rjmp	.-4      	; 0xc224 <FCloseShift+0x440>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    c228:	8f e3       	ldi	r24, 0x3F	; 63
    c22a:	91 e0       	ldi	r25, 0x01	; 1
    c22c:	9f bb       	out	0x1f, r25	; 31
    c22e:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    c230:	81 e0       	ldi	r24, 0x01	; 1
    c232:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    c234:	0f b6       	in	r0, 0x3f	; 63
    c236:	f8 94       	cli
    c238:	e2 9a       	sbi	0x1c, 2	; 28
    c23a:	e1 9a       	sbi	0x1c, 1	; 28
    c23c:	0f be       	out	0x3f, r0	; 63
		      eeprom_write_byte(&DefShift,1);	 

          SaveTotalizerCurrentToLast();
    c23e:	0e 94 83 45 	call	0x8b06	; 0x8b06 <SaveTotalizerCurrentToLast>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    c242:	83 e4       	ldi	r24, 0x43	; 67
    c244:	98 e0       	ldi	r25, 0x08	; 8
    c246:	61 e7       	ldi	r22, 0x71	; 113
    c248:	79 e0       	ldi	r23, 0x09	; 9
    c24a:	44 e1       	ldi	r20, 0x14	; 20
    c24c:	50 e0       	ldi	r21, 0x00	; 0
    c24e:	2b ef       	ldi	r18, 0xFB	; 251
    c250:	32 e1       	ldi	r19, 0x12	; 18
    c252:	0e 94 3b b4 	call	0x16876	; 0x16876 <__eewr_block>
          eeprom_write_block((const void*) &CurrentShiftDateTime, (void*) &DefLastShiftDateTime,sizeof(DefLastShiftDateTime));
		  stCloseShift=csFinishCloseShift;
    c256:	8b e0       	ldi	r24, 0x0B	; 11
    c258:	80 93 20 03 	sts	0x0320, r24
    c25c:	04 c0       	rjmp	.+8      	; 0xc266 <FCloseShift+0x482>
	      break;
     case csFinishCloseShift:
          stCloseShift=csInitCloseShift;
    c25e:	10 92 20 03 	sts	0x0320, r1
    c262:	81 e0       	ldi	r24, 0x01	; 1
    c264:	01 c0       	rjmp	.+2      	; 0xc268 <FCloseShift+0x484>
    c266:	80 e0       	ldi	r24, 0x00	; 0
		  Result=MENU_DONE;
	      break;
	 }
	 //_uart_printf(0,1,PSTR("Close Shift"));	
   return Result;
}
    c268:	64 96       	adiw	r28, 0x14	; 20
    c26a:	0f b6       	in	r0, 0x3f	; 63
    c26c:	f8 94       	cli
    c26e:	de bf       	out	0x3e, r29	; 62
    c270:	0f be       	out	0x3f, r0	; 63
    c272:	cd bf       	out	0x3d, r28	; 61
    c274:	cf 91       	pop	r28
    c276:	df 91       	pop	r29
    c278:	1f 91       	pop	r17
    c27a:	0f 91       	pop	r16
    c27c:	ff 90       	pop	r15
    c27e:	ef 90       	pop	r14
    c280:	df 90       	pop	r13
    c282:	08 95       	ret

0000c284 <FMenuShift>:
     char SubMenu,KeyChar,KeyPressed;

     char Result;

Result=MENU_NONE;
     switch(stMenuShift){
    c284:	80 91 21 03 	lds	r24, 0x0321
    c288:	82 30       	cpi	r24, 0x02	; 2
    c28a:	09 f4       	brne	.+2      	; 0xc28e <FMenuShift+0xa>
    c28c:	48 c0       	rjmp	.+144    	; 0xc31e <FMenuShift+0x9a>
    c28e:	83 30       	cpi	r24, 0x03	; 3
    c290:	30 f4       	brcc	.+12     	; 0xc29e <FMenuShift+0x1a>
    c292:	88 23       	and	r24, r24
    c294:	69 f0       	breq	.+26     	; 0xc2b0 <FMenuShift+0x2c>
    c296:	81 30       	cpi	r24, 0x01	; 1
    c298:	09 f0       	breq	.+2      	; 0xc29c <FMenuShift+0x18>
    c29a:	50 c0       	rjmp	.+160    	; 0xc33c <FMenuShift+0xb8>
    c29c:	25 c0       	rjmp	.+74     	; 0xc2e8 <FMenuShift+0x64>
    c29e:	84 30       	cpi	r24, 0x04	; 4
    c2a0:	09 f4       	brne	.+2      	; 0xc2a4 <FMenuShift+0x20>
    c2a2:	4c c0       	rjmp	.+152    	; 0xc33c <FMenuShift+0xb8>
    c2a4:	84 30       	cpi	r24, 0x04	; 4
    c2a6:	e8 f1       	brcs	.+122    	; 0xc322 <FMenuShift+0x9e>
    c2a8:	85 30       	cpi	r24, 0x05	; 5
    c2aa:	09 f0       	breq	.+2      	; 0xc2ae <FMenuShift+0x2a>
    c2ac:	47 c0       	rjmp	.+142    	; 0xc33c <FMenuShift+0xb8>
    c2ae:	42 c0       	rjmp	.+132    	; 0xc334 <FMenuShift+0xb0>
	 case msInitMenuShift:
	      lcd_clear();
    c2b0:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
		  lcd_printf(1,1,PSTR("1.Close Shift"));
    c2b4:	81 e0       	ldi	r24, 0x01	; 1
    c2b6:	61 e0       	ldi	r22, 0x01	; 1
    c2b8:	47 ec       	ldi	r20, 0xC7	; 199
    c2ba:	55 e1       	ldi	r21, 0x15	; 21
    c2bc:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		  lcd_printf(2,1,PSTR("2.Close Day  "));
    c2c0:	82 e0       	ldi	r24, 0x02	; 2
    c2c2:	61 e0       	ldi	r22, 0x01	; 1
    c2c4:	49 eb       	ldi	r20, 0xB9	; 185
    c2c6:	55 e1       	ldi	r21, 0x15	; 21
    c2c8:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		  lcd_printf(3,1,PSTR("3.Lock Pump  "));
    c2cc:	83 e0       	ldi	r24, 0x03	; 3
    c2ce:	61 e0       	ldi	r22, 0x01	; 1
    c2d0:	4b ea       	ldi	r20, 0xAB	; 171
    c2d2:	55 e1       	ldi	r21, 0x15	; 21
    c2d4:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		  lcd_printf(4,1,PSTR("*)Exit"));
    c2d8:	84 e0       	ldi	r24, 0x04	; 4
    c2da:	61 e0       	ldi	r22, 0x01	; 1
    c2dc:	44 ea       	ldi	r20, 0xA4	; 164
    c2de:	55 e1       	ldi	r21, 0x15	; 21
    c2e0:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		  stMenuShift=msSelectShift;
    c2e4:	81 e0       	ldi	r24, 0x01	; 1
    c2e6:	18 c0       	rjmp	.+48     	; 0xc318 <FMenuShift+0x94>
	      break;
     case msSelectShift:
          KeyPressed=_key_scan(1);
    c2e8:	81 e0       	ldi	r24, 0x01	; 1
    c2ea:	0e 94 ab ae 	call	0x15d56	; 0x15d56 <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
    c2ee:	0e 94 0c ae 	call	0x15c18	; 0x15c18 <_key_btn>
          switch(KeyChar){
    c2f2:	82 33       	cpi	r24, 0x32	; 50
    c2f4:	61 f0       	breq	.+24     	; 0xc30e <FMenuShift+0x8a>
    c2f6:	83 33       	cpi	r24, 0x33	; 51
    c2f8:	28 f4       	brcc	.+10     	; 0xc304 <FMenuShift+0x80>
    c2fa:	8a 32       	cpi	r24, 0x2A	; 42
    c2fc:	61 f0       	breq	.+24     	; 0xc316 <FMenuShift+0x92>
    c2fe:	81 33       	cpi	r24, 0x31	; 49
    c300:	e9 f4       	brne	.+58     	; 0xc33c <FMenuShift+0xb8>
    c302:	03 c0       	rjmp	.+6      	; 0xc30a <FMenuShift+0x86>
    c304:	83 33       	cpi	r24, 0x33	; 51
    c306:	d1 f4       	brne	.+52     	; 0xc33c <FMenuShift+0xb8>
    c308:	04 c0       	rjmp	.+8      	; 0xc312 <FMenuShift+0x8e>
		  case '1':
		       SubMenu=MENU_NONE;
		       stMenuShift=msCloseShift;
    c30a:	82 e0       	ldi	r24, 0x02	; 2
    c30c:	05 c0       	rjmp	.+10     	; 0xc318 <FMenuShift+0x94>
		       break; 
		  case '2':
		       SubMenu=MENU_NONE;
		       stMenuShift=msCloseDay;
    c30e:	83 e0       	ldi	r24, 0x03	; 3
    c310:	03 c0       	rjmp	.+6      	; 0xc318 <FMenuShift+0x94>
		       break; 
		  case '3':
		       SubMenu=MENU_NONE;
		       stMenuShift=msLockPump;
    c312:	84 e0       	ldi	r24, 0x04	; 4
    c314:	01 c0       	rjmp	.+2      	; 0xc318 <FMenuShift+0x94>
		       break; 
		  case '*':
		       stMenuShift=msExitShift;
    c316:	85 e0       	ldi	r24, 0x05	; 5
    c318:	80 93 21 03 	sts	0x0321, r24
    c31c:	09 c0       	rjmp	.+18     	; 0xc330 <FMenuShift+0xac>
		       break; 			   		  
		  }
		  break;
     case msCloseShift:
	      SubMenu=FCloseShift(CONTINUE_SHIFT);
    c31e:	82 e0       	ldi	r24, 0x02	; 2
    c320:	01 c0       	rjmp	.+2      	; 0xc324 <FMenuShift+0xa0>
		  if (SubMenu==MENU_DONE)stMenuShift=msInitMenuShift;
		  //IsGenerateReport=True;		  
	      break;
     case msCloseDay:
	      SubMenu=FCloseShift(NEW_SHIFT);
    c322:	81 e0       	ldi	r24, 0x01	; 1
    c324:	0e 94 f2 5e 	call	0xbde4	; 0xbde4 <FCloseShift>
		  if (SubMenu==MENU_DONE)stMenuShift=msInitMenuShift;
    c328:	81 30       	cpi	r24, 0x01	; 1
    c32a:	41 f4       	brne	.+16     	; 0xc33c <FMenuShift+0xb8>
    c32c:	10 92 21 03 	sts	0x0321, r1
    c330:	80 e0       	ldi	r24, 0x00	; 0
    c332:	08 95       	ret
     case msLockPump:
	      SubMenu=FLockPump();
		  if (SubMenu==MENU_DONE)stMenuShift=msInitMenuShift;
	      break;
     case msExitShift:
          stMenuShift=msInitMenuShift;
    c334:	10 92 21 03 	sts	0x0321, r1
    c338:	81 e0       	ldi	r24, 0x01	; 1
    c33a:	08 95       	ret
    c33c:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;	 
	 } 
   return Result;
}
    c33e:	08 95       	ret

0000c340 <DisplayDateTime>:

void DisplayQueueFIP(){// FIP:#1#2#3#4#5

}

void DisplayDateTime(){
    c340:	cf 92       	push	r12
    c342:	df 92       	push	r13
    c344:	ef 92       	push	r14
    c346:	ff 92       	push	r15
    c348:	0f 93       	push	r16
    c34a:	1f 93       	push	r17
    c34c:	df 93       	push	r29
    c34e:	cf 93       	push	r28
    c350:	cd b7       	in	r28, 0x3d	; 61
    c352:	de b7       	in	r29, 0x3e	; 62
    c354:	64 97       	sbiw	r28, 0x14	; 20
    c356:	0f b6       	in	r0, 0x3f	; 63
    c358:	f8 94       	cli
    c35a:	de bf       	out	0x3e, r29	; 62
    c35c:	0f be       	out	0x3f, r0	; 63
    c35e:	cd bf       	out	0x3d, r28	; 61
char lcdteks[20];
	 _datetime(0, strSystemDate, strSystemTime);
    c360:	5a e9       	ldi	r21, 0x9A	; 154
    c362:	e5 2e       	mov	r14, r21
    c364:	55 e0       	ldi	r21, 0x05	; 5
    c366:	f5 2e       	mov	r15, r21
    c368:	49 e7       	ldi	r20, 0x79	; 121
    c36a:	c4 2e       	mov	r12, r20
    c36c:	4a e0       	ldi	r20, 0x0A	; 10
    c36e:	d4 2e       	mov	r13, r20
    c370:	80 e0       	ldi	r24, 0x00	; 0
    c372:	b7 01       	movw	r22, r14
    c374:	a6 01       	movw	r20, r12
    c376:	0e 94 76 b1 	call	0x162ec	; 0x162ec <_datetime>
	 sprintf_P(lcdteks,PSTR("%s %s"),strSystemDate,strSystemTime);
    c37a:	8d b7       	in	r24, 0x3d	; 61
    c37c:	9e b7       	in	r25, 0x3e	; 62
    c37e:	08 97       	sbiw	r24, 0x08	; 8
    c380:	0f b6       	in	r0, 0x3f	; 63
    c382:	f8 94       	cli
    c384:	9e bf       	out	0x3e, r25	; 62
    c386:	0f be       	out	0x3f, r0	; 63
    c388:	8d bf       	out	0x3d, r24	; 61
    c38a:	ed b7       	in	r30, 0x3d	; 61
    c38c:	fe b7       	in	r31, 0x3e	; 62
    c38e:	31 96       	adiw	r30, 0x01	; 1
    c390:	8e 01       	movw	r16, r28
    c392:	0f 5f       	subi	r16, 0xFF	; 255
    c394:	1f 4f       	sbci	r17, 0xFF	; 255
    c396:	ad b7       	in	r26, 0x3d	; 61
    c398:	be b7       	in	r27, 0x3e	; 62
    c39a:	12 96       	adiw	r26, 0x02	; 2
    c39c:	1c 93       	st	X, r17
    c39e:	0e 93       	st	-X, r16
    c3a0:	11 97       	sbiw	r26, 0x01	; 1
    c3a2:	80 e1       	ldi	r24, 0x10	; 16
    c3a4:	9c e1       	ldi	r25, 0x1C	; 28
    c3a6:	93 83       	std	Z+3, r25	; 0x03
    c3a8:	82 83       	std	Z+2, r24	; 0x02
    c3aa:	f5 82       	std	Z+5, r15	; 0x05
    c3ac:	e4 82       	std	Z+4, r14	; 0x04
    c3ae:	d7 82       	std	Z+7, r13	; 0x07
    c3b0:	c6 82       	std	Z+6, r12	; 0x06
    c3b2:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
	 lcd_print(2, 1, lcdteks);
    c3b6:	8d b7       	in	r24, 0x3d	; 61
    c3b8:	9e b7       	in	r25, 0x3e	; 62
    c3ba:	08 96       	adiw	r24, 0x08	; 8
    c3bc:	0f b6       	in	r0, 0x3f	; 63
    c3be:	f8 94       	cli
    c3c0:	9e bf       	out	0x3e, r25	; 62
    c3c2:	0f be       	out	0x3f, r0	; 63
    c3c4:	8d bf       	out	0x3d, r24	; 61
    c3c6:	82 e0       	ldi	r24, 0x02	; 2
    c3c8:	61 e0       	ldi	r22, 0x01	; 1
    c3ca:	a8 01       	movw	r20, r16
    c3cc:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
}
    c3d0:	64 96       	adiw	r28, 0x14	; 20
    c3d2:	0f b6       	in	r0, 0x3f	; 63
    c3d4:	f8 94       	cli
    c3d6:	de bf       	out	0x3e, r29	; 62
    c3d8:	0f be       	out	0x3f, r0	; 63
    c3da:	cd bf       	out	0x3d, r28	; 61
    c3dc:	cf 91       	pop	r28
    c3de:	df 91       	pop	r29
    c3e0:	1f 91       	pop	r17
    c3e2:	0f 91       	pop	r16
    c3e4:	ff 90       	pop	r15
    c3e6:	ef 90       	pop	r14
    c3e8:	df 90       	pop	r13
    c3ea:	cf 90       	pop	r12
    c3ec:	08 95       	ret

0000c3ee <_menu_datetime>:
		}
	}
}


void _menu_datetime(void){
    c3ee:	8f 92       	push	r8
    c3f0:	9f 92       	push	r9
    c3f2:	af 92       	push	r10
    c3f4:	bf 92       	push	r11
    c3f6:	cf 92       	push	r12
    c3f8:	df 92       	push	r13
    c3fa:	ef 92       	push	r14
    c3fc:	ff 92       	push	r15
    c3fe:	0f 93       	push	r16
    c400:	1f 93       	push	r17
    c402:	df 93       	push	r29
    c404:	cf 93       	push	r28
    c406:	cd b7       	in	r28, 0x3d	; 61
    c408:	de b7       	in	r29, 0x3e	; 62
    c40a:	c2 54       	subi	r28, 0x42	; 66
    c40c:	d0 40       	sbci	r29, 0x00	; 0
    c40e:	0f b6       	in	r0, 0x3f	; 63
    c410:	f8 94       	cli
    c412:	de bf       	out	0x3e, r29	; 62
    c414:	0f be       	out	0x3f, r0	; 63
    c416:	cd bf       	out	0x3d, r28	; 61
	char	__key, __chr;
	char	__date[9];
	char	__time[9];
	char	__map[12][4] = {	{1,  8, 0, 3}, {1,  9, 0, 9}, {1, 11, 0, 1}, {1, 12, 0, 9},
								{1, 14, 0, 9}, {1, 15, 0, 9}, {2,  8, 0, 2}, {2,  9, 0, 9},
								{2, 11, 0, 5}, {2, 12, 0, 9}, {2, 14, 0, 5}, {2, 15, 0, 9}};
    c418:	de 01       	movw	r26, r28
    c41a:	53 96       	adiw	r26, 0x13	; 19
    c41c:	e6 e2       	ldi	r30, 0x26	; 38
    c41e:	f1 e0       	ldi	r31, 0x01	; 1
    c420:	80 e3       	ldi	r24, 0x30	; 48
    c422:	01 90       	ld	r0, Z+
    c424:	0d 92       	st	X+, r0
    c426:	81 50       	subi	r24, 0x01	; 1
    c428:	e1 f7       	brne	.-8      	; 0xc422 <_menu_datetime+0x34>

	_datetime(_DATETIME_READ, __date, __time);
    c42a:	8e 01       	movw	r16, r28
    c42c:	0f 5f       	subi	r16, 0xFF	; 255
    c42e:	1f 4f       	sbci	r17, 0xFF	; 255
    c430:	b8 01       	movw	r22, r16
    c432:	ae 01       	movw	r20, r28
    c434:	46 5f       	subi	r20, 0xF6	; 246
    c436:	5f 4f       	sbci	r21, 0xFF	; 255
    c438:	0e 94 76 b1 	call	0x162ec	; 0x162ec <_datetime>
    c43c:	e5 e1       	ldi	r30, 0x15	; 21
    c43e:	8e 2e       	mov	r8, r30
    c440:	91 2c       	mov	r9, r1
    c442:	8c 0e       	add	r8, r28
    c444:	9d 1e       	adc	r9, r29
    c446:	d4 01       	movw	r26, r8
    c448:	20 e0       	ldi	r18, 0x00	; 0
    c44a:	30 e0       	ldi	r19, 0x00	; 0
    c44c:	40 e0       	ldi	r20, 0x00	; 0
    c44e:	50 e0       	ldi	r21, 0x00	; 0
	for(__i = 0, __ii = 0; __i < 6; __i++, __ii++){
		if(__i == 2 || __i == 4)
    c450:	22 30       	cpi	r18, 0x02	; 2
    c452:	31 05       	cpc	r19, r1
    c454:	19 f0       	breq	.+6      	; 0xc45c <_menu_datetime+0x6e>
    c456:	24 30       	cpi	r18, 0x04	; 4
    c458:	31 05       	cpc	r19, r1
    c45a:	11 f4       	brne	.+4      	; 0xc460 <_menu_datetime+0x72>
			__ii++;
    c45c:	4f 5f       	subi	r20, 0xFF	; 255
    c45e:	5f 4f       	sbci	r21, 0xFF	; 255
		__map[__i][2] = __date[__ii];
    c460:	f8 01       	movw	r30, r16
    c462:	e4 0f       	add	r30, r20
    c464:	f5 1f       	adc	r31, r21
    c466:	80 81       	ld	r24, Z
    c468:	8c 93       	st	X, r24
	char	__map[12][4] = {	{1,  8, 0, 3}, {1,  9, 0, 9}, {1, 11, 0, 1}, {1, 12, 0, 9},
								{1, 14, 0, 9}, {1, 15, 0, 9}, {2,  8, 0, 2}, {2,  9, 0, 9},
								{2, 11, 0, 5}, {2, 12, 0, 9}, {2, 14, 0, 5}, {2, 15, 0, 9}};

	_datetime(_DATETIME_READ, __date, __time);
	for(__i = 0, __ii = 0; __i < 6; __i++, __ii++){
    c46a:	2f 5f       	subi	r18, 0xFF	; 255
    c46c:	3f 4f       	sbci	r19, 0xFF	; 255
    c46e:	14 96       	adiw	r26, 0x04	; 4
    c470:	26 30       	cpi	r18, 0x06	; 6
    c472:	31 05       	cpc	r19, r1
    c474:	19 f0       	breq	.+6      	; 0xc47c <_menu_datetime+0x8e>
    c476:	4f 5f       	subi	r20, 0xFF	; 255
    c478:	5f 4f       	sbci	r21, 0xFF	; 255
    c47a:	ea cf       	rjmp	.-44     	; 0xc450 <_menu_datetime+0x62>
    c47c:	7d e2       	ldi	r23, 0x2D	; 45
    c47e:	a7 2e       	mov	r10, r23
    c480:	b1 2c       	mov	r11, r1
    c482:	ac 0e       	add	r10, r28
    c484:	bd 1e       	adc	r11, r29
    c486:	d5 01       	movw	r26, r10
    c488:	40 e0       	ldi	r20, 0x00	; 0
    c48a:	50 e0       	ldi	r21, 0x00	; 0
		__map[__i][2] = __date[__ii];
	}
	for(__i = 6, __ii = 0; __i < 12; __i++, __ii++){
		if(__i == 8 || __i == 10)
			__ii++;
		__map[__i][2] = __time[__ii];
    c48c:	6a e0       	ldi	r22, 0x0A	; 10
    c48e:	e6 2e       	mov	r14, r22
    c490:	f1 2c       	mov	r15, r1
    c492:	ec 0e       	add	r14, r28
    c494:	fd 1e       	adc	r15, r29
		if(__i == 2 || __i == 4)
			__ii++;
		__map[__i][2] = __date[__ii];
	}
	for(__i = 6, __ii = 0; __i < 12; __i++, __ii++){
		if(__i == 8 || __i == 10)
    c496:	28 30       	cpi	r18, 0x08	; 8
    c498:	31 05       	cpc	r19, r1
    c49a:	19 f0       	breq	.+6      	; 0xc4a2 <_menu_datetime+0xb4>
    c49c:	2a 30       	cpi	r18, 0x0A	; 10
    c49e:	31 05       	cpc	r19, r1
    c4a0:	11 f4       	brne	.+4      	; 0xc4a6 <_menu_datetime+0xb8>
			__ii++;
    c4a2:	4f 5f       	subi	r20, 0xFF	; 255
    c4a4:	5f 4f       	sbci	r21, 0xFF	; 255
		__map[__i][2] = __time[__ii];
    c4a6:	f7 01       	movw	r30, r14
    c4a8:	e4 0f       	add	r30, r20
    c4aa:	f5 1f       	adc	r31, r21
    c4ac:	80 81       	ld	r24, Z
    c4ae:	8c 93       	st	X, r24
	for(__i = 0, __ii = 0; __i < 6; __i++, __ii++){
		if(__i == 2 || __i == 4)
			__ii++;
		__map[__i][2] = __date[__ii];
	}
	for(__i = 6, __ii = 0; __i < 12; __i++, __ii++){
    c4b0:	2f 5f       	subi	r18, 0xFF	; 255
    c4b2:	3f 4f       	sbci	r19, 0xFF	; 255
    c4b4:	14 96       	adiw	r26, 0x04	; 4
    c4b6:	2c 30       	cpi	r18, 0x0C	; 12
    c4b8:	31 05       	cpc	r19, r1
    c4ba:	19 f0       	breq	.+6      	; 0xc4c2 <_menu_datetime+0xd4>
    c4bc:	4f 5f       	subi	r20, 0xFF	; 255
    c4be:	5f 4f       	sbci	r21, 0xFF	; 255
    c4c0:	ea cf       	rjmp	.-44     	; 0xc496 <_menu_datetime+0xa8>
		if(__i == 8 || __i == 10)
			__ii++;
		__map[__i][2] = __time[__ii];
	}

	lcd_clear();_delay_ms(10);
    c4c2:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
    c4c6:	84 ec       	ldi	r24, 0xC4	; 196
    c4c8:	99 e0       	ldi	r25, 0x09	; 9
    c4ca:	01 97       	sbiw	r24, 0x01	; 1
    c4cc:	f1 f7       	brne	.-4      	; 0xc4ca <_menu_datetime+0xdc>
	lcd_printf(1, 1, PSTR("DATE : "));
    c4ce:	81 e0       	ldi	r24, 0x01	; 1
    c4d0:	61 e0       	ldi	r22, 0x01	; 1
    c4d2:	4c ea       	ldi	r20, 0xAC	; 172
    c4d4:	5b e0       	ldi	r21, 0x0B	; 11
    c4d6:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
	lcd_printf(2, 1, PSTR("TIME : "));
    c4da:	82 e0       	ldi	r24, 0x02	; 2
    c4dc:	61 e0       	ldi	r22, 0x01	; 1
    c4de:	44 ea       	ldi	r20, 0xA4	; 164
    c4e0:	5b e0       	ldi	r21, 0x0B	; 11
    c4e2:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
	lcd_print(1, 8, __date);
    c4e6:	81 e0       	ldi	r24, 0x01	; 1
    c4e8:	68 e0       	ldi	r22, 0x08	; 8
    c4ea:	8e 01       	movw	r16, r28
    c4ec:	0f 5f       	subi	r16, 0xFF	; 255
    c4ee:	1f 4f       	sbci	r17, 0xFF	; 255
    c4f0:	a8 01       	movw	r20, r16
    c4f2:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
	lcd_print(2, 8, __time);
    c4f6:	82 e0       	ldi	r24, 0x02	; 2
    c4f8:	68 e0       	ldi	r22, 0x08	; 8
    c4fa:	a7 01       	movw	r20, r14
    c4fc:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
	lcd_printf(4, 1, PSTR("*)Cancel      #)Save"));
    c500:	84 e0       	ldi	r24, 0x04	; 4
    c502:	61 e0       	ldi	r22, 0x01	; 1
    c504:	4f e8       	ldi	r20, 0x8F	; 143
    c506:	5b e0       	ldi	r21, 0x0B	; 11
    c508:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>

	__i = 0;
	lcd_xy(__map[__i][0], __map[__i][1]);
    c50c:	8b 89       	ldd	r24, Y+19	; 0x13
    c50e:	6c 89       	ldd	r22, Y+20	; 0x14
    c510:	0e 94 f1 ac 	call	0x159e2	; 0x159e2 <lcd_xy>
	CURSOR_SHOW;
    c514:	8f e0       	ldi	r24, 0x0F	; 15
    c516:	0e 94 5e ac 	call	0x158bc	; 0x158bc <lcd_command>
    c51a:	ee 24       	eor	r14, r14
    c51c:	ff 24       	eor	r15, r15
					else
						goto LEWAT;
				}
			}
CETAK:
			__map[__i][2] = __chr;
    c51e:	68 01       	movw	r12, r16
	lcd_xy(__map[__i][0], __map[__i][1]);
	CURSOR_SHOW;

	while(1){
		
		__key = _key_scan(1);
    c520:	81 e0       	ldi	r24, 0x01	; 1
    c522:	0e 94 ab ae 	call	0x15d56	; 0x15d56 <_key_scan>
    c526:	18 2f       	mov	r17, r24
		__chr = _key_btn(__key);
    c528:	0e 94 0c ae 	call	0x15c18	; 0x15c18 <_key_btn>
    c52c:	48 2f       	mov	r20, r24
		if(__chr >= 0x30 && __chr <= 0x39){
    c52e:	80 53       	subi	r24, 0x30	; 48
    c530:	8a 30       	cpi	r24, 0x0A	; 10
    c532:	08 f0       	brcs	.+2      	; 0xc536 <_menu_datetime+0x148>
    c534:	72 c0       	rjmp	.+228    	; 0xc61a <_menu_datetime+0x22c>
			if(__i == 0 || __i == 2 || __i == 6 || __i == 8 || __i == 10){
    c536:	e1 14       	cp	r14, r1
    c538:	f1 04       	cpc	r15, r1
    c53a:	81 f0       	breq	.+32     	; 0xc55c <_menu_datetime+0x16e>
    c53c:	82 e0       	ldi	r24, 0x02	; 2
    c53e:	e8 16       	cp	r14, r24
    c540:	f1 04       	cpc	r15, r1
    c542:	61 f0       	breq	.+24     	; 0xc55c <_menu_datetime+0x16e>
    c544:	96 e0       	ldi	r25, 0x06	; 6
    c546:	e9 16       	cp	r14, r25
    c548:	f1 04       	cpc	r15, r1
    c54a:	41 f0       	breq	.+16     	; 0xc55c <_menu_datetime+0x16e>
    c54c:	a8 e0       	ldi	r26, 0x08	; 8
    c54e:	ea 16       	cp	r14, r26
    c550:	f1 04       	cpc	r15, r1
    c552:	21 f0       	breq	.+8      	; 0xc55c <_menu_datetime+0x16e>
    c554:	ba e0       	ldi	r27, 0x0A	; 10
    c556:	eb 16       	cp	r14, r27
    c558:	f1 04       	cpc	r15, r1
    c55a:	81 f4       	brne	.+32     	; 0xc57c <_menu_datetime+0x18e>
				if((__chr - 0x30) <= __map[__i][3])
    c55c:	84 2f       	mov	r24, r20
    c55e:	90 e0       	ldi	r25, 0x00	; 0
    c560:	c0 97       	sbiw	r24, 0x30	; 48
    c562:	f7 01       	movw	r30, r14
    c564:	ee 0f       	add	r30, r30
    c566:	ff 1f       	adc	r31, r31
    c568:	ee 0f       	add	r30, r30
    c56a:	ff 1f       	adc	r31, r31
    c56c:	ec 0d       	add	r30, r12
    c56e:	fd 1d       	adc	r31, r13
    c570:	25 89       	ldd	r18, Z+21	; 0x15
    c572:	30 e0       	ldi	r19, 0x00	; 0
    c574:	28 17       	cp	r18, r24
    c576:	39 07       	cpc	r19, r25
    c578:	84 f5       	brge	.+96     	; 0xc5da <_menu_datetime+0x1ec>
    c57a:	4f c0       	rjmp	.+158    	; 0xc61a <_menu_datetime+0x22c>
					goto CETAK;
				else
					goto LEWAT;
			}
			if(__i == 1){
    c57c:	81 e0       	ldi	r24, 0x01	; 1
    c57e:	e8 16       	cp	r14, r24
    c580:	f1 04       	cpc	r15, r1
    c582:	61 f4       	brne	.+24     	; 0xc59c <_menu_datetime+0x1ae>
				if((__map[0][2] - 0x30) < __map[0][3])
    c584:	2d 89       	ldd	r18, Y+21	; 0x15
    c586:	30 e0       	ldi	r19, 0x00	; 0
    c588:	2f 52       	subi	r18, 0x2F	; 47
    c58a:	30 40       	sbci	r19, 0x00	; 0
    c58c:	8e 89       	ldd	r24, Y+22	; 0x16
    c58e:	90 e0       	ldi	r25, 0x00	; 0
    c590:	82 17       	cp	r24, r18
    c592:	93 07       	cpc	r25, r19
    c594:	14 f5       	brge	.+68     	; 0xc5da <_menu_datetime+0x1ec>
					goto CETAK;
				if((__map[0][2] - 0x30) >= __map[0][3]){
					if(__chr < 0x32)
    c596:	42 33       	cpi	r20, 0x32	; 50
    c598:	00 f1       	brcs	.+64     	; 0xc5da <_menu_datetime+0x1ec>
    c59a:	3f c0       	rjmp	.+126    	; 0xc61a <_menu_datetime+0x22c>
						goto CETAK;
					else
						goto LEWAT;
				}
			}
			if(__i == 3){
    c59c:	93 e0       	ldi	r25, 0x03	; 3
    c59e:	e9 16       	cp	r14, r25
    c5a0:	f1 04       	cpc	r15, r1
    c5a2:	61 f4       	brne	.+24     	; 0xc5bc <_menu_datetime+0x1ce>
				if((__map[2][2] - 0x30) < __map[2][3])
    c5a4:	2d 8d       	ldd	r18, Y+29	; 0x1d
    c5a6:	30 e0       	ldi	r19, 0x00	; 0
    c5a8:	2f 52       	subi	r18, 0x2F	; 47
    c5aa:	30 40       	sbci	r19, 0x00	; 0
    c5ac:	8e 8d       	ldd	r24, Y+30	; 0x1e
    c5ae:	90 e0       	ldi	r25, 0x00	; 0
    c5b0:	82 17       	cp	r24, r18
    c5b2:	93 07       	cpc	r25, r19
    c5b4:	94 f4       	brge	.+36     	; 0xc5da <_menu_datetime+0x1ec>
					goto CETAK;
				if((__map[2][2] - 0x30) >= __map[2][3]){
					if(__chr < 0x33)
    c5b6:	43 33       	cpi	r20, 0x33	; 51
    c5b8:	80 f0       	brcs	.+32     	; 0xc5da <_menu_datetime+0x1ec>
    c5ba:	2f c0       	rjmp	.+94     	; 0xc61a <_menu_datetime+0x22c>
						goto CETAK;
					else
						goto LEWAT;
				}
			}
			if(__i == 7){
    c5bc:	a7 e0       	ldi	r26, 0x07	; 7
    c5be:	ea 16       	cp	r14, r26
    c5c0:	f1 04       	cpc	r15, r1
    c5c2:	59 f4       	brne	.+22     	; 0xc5da <_menu_datetime+0x1ec>
				if((__map[6][2] - 0x30) < __map[6][3])
    c5c4:	2d a5       	ldd	r18, Y+45	; 0x2d
    c5c6:	30 e0       	ldi	r19, 0x00	; 0
    c5c8:	2f 52       	subi	r18, 0x2F	; 47
    c5ca:	30 40       	sbci	r19, 0x00	; 0
    c5cc:	8e a5       	ldd	r24, Y+46	; 0x2e
    c5ce:	90 e0       	ldi	r25, 0x00	; 0
    c5d0:	82 17       	cp	r24, r18
    c5d2:	93 07       	cpc	r25, r19
    c5d4:	14 f4       	brge	.+4      	; 0xc5da <_menu_datetime+0x1ec>
					goto CETAK;
				if((__map[6][2] - 0x30) >= __map[6][3]){
					if(__chr < 0x34)
    c5d6:	44 33       	cpi	r20, 0x34	; 52
    c5d8:	00 f5       	brcc	.+64     	; 0xc61a <_menu_datetime+0x22c>
					else
						goto LEWAT;
				}
			}
CETAK:
			__map[__i][2] = __chr;
    c5da:	f7 01       	movw	r30, r14
    c5dc:	ee 0f       	add	r30, r30
    c5de:	ff 1f       	adc	r31, r31
    c5e0:	ee 0f       	add	r30, r30
    c5e2:	ff 1f       	adc	r31, r31
    c5e4:	ec 0d       	add	r30, r12
    c5e6:	fd 1d       	adc	r31, r13
    c5e8:	44 8b       	std	Z+20, r20	; 0x14
			_lcd(__chr);
    c5ea:	84 2f       	mov	r24, r20
    c5ec:	0e 94 cb ac 	call	0x15996	; 0x15996 <_lcd>
			__i++;
    c5f0:	08 94       	sec
    c5f2:	e1 1c       	adc	r14, r1
    c5f4:	f1 1c       	adc	r15, r1
    c5f6:	bc e0       	ldi	r27, 0x0C	; 12
    c5f8:	eb 16       	cp	r14, r27
    c5fa:	f1 04       	cpc	r15, r1
    c5fc:	1c f0       	brlt	.+6      	; 0xc604 <_menu_datetime+0x216>
    c5fe:	bb e0       	ldi	r27, 0x0B	; 11
    c600:	eb 2e       	mov	r14, r27
    c602:	f1 2c       	mov	r15, r1
			if(__i > 11)
				__i = 11;
			lcd_xy(__map[__i][0], __map[__i][1]);
    c604:	f7 01       	movw	r30, r14
    c606:	ee 0f       	add	r30, r30
    c608:	ff 1f       	adc	r31, r31
    c60a:	ee 0f       	add	r30, r30
    c60c:	ff 1f       	adc	r31, r31
    c60e:	ec 0d       	add	r30, r12
    c610:	fd 1d       	adc	r31, r13
    c612:	82 89       	ldd	r24, Z+18	; 0x12
    c614:	63 89       	ldd	r22, Z+19	; 0x13
    c616:	0e 94 f1 ac 	call	0x159e2	; 0x159e2 <lcd_xy>
LEWAT:		;
		}
		if(__key == _KEY_SHIFT){
    c61a:	1b 37       	cpi	r17, 0x7B	; 123
    c61c:	59 f4       	brne	.+22     	; 0xc634 <_menu_datetime+0x246>
			__i++;
    c61e:	08 94       	sec
    c620:	e1 1c       	adc	r14, r1
    c622:	f1 1c       	adc	r15, r1
    c624:	8c e0       	ldi	r24, 0x0C	; 12
    c626:	e8 16       	cp	r14, r24
    c628:	f1 04       	cpc	r15, r1
    c62a:	6c f0       	brlt	.+26     	; 0xc646 <_menu_datetime+0x258>
    c62c:	7b e0       	ldi	r23, 0x0B	; 11
    c62e:	e7 2e       	mov	r14, r23
    c630:	f1 2c       	mov	r15, r1
    c632:	09 c0       	rjmp	.+18     	; 0xc646 <_menu_datetime+0x258>
			if(__i > 11)
				__i = 11;
			lcd_xy(__map[__i][0], __map[__i][1]);
		}
		if(__key == _KEY_CLEAR){
    c634:	17 37       	cpi	r17, 0x77	; 119
    c636:	99 f4       	brne	.+38     	; 0xc65e <_menu_datetime+0x270>
			__i--;
    c638:	08 94       	sec
    c63a:	e1 08       	sbc	r14, r1
    c63c:	f1 08       	sbc	r15, r1
    c63e:	f7 fe       	sbrs	r15, 7
    c640:	02 c0       	rjmp	.+4      	; 0xc646 <_menu_datetime+0x258>
    c642:	ee 24       	eor	r14, r14
    c644:	ff 24       	eor	r15, r15
			if(__i <= 0)
				__i = 0;
			lcd_xy(__map[__i][0], __map[__i][1]);
    c646:	f7 01       	movw	r30, r14
    c648:	ee 0f       	add	r30, r30
    c64a:	ff 1f       	adc	r31, r31
    c64c:	ee 0f       	add	r30, r30
    c64e:	ff 1f       	adc	r31, r31
    c650:	ec 0d       	add	r30, r12
    c652:	fd 1d       	adc	r31, r13
    c654:	82 89       	ldd	r24, Z+18	; 0x12
    c656:	63 89       	ldd	r22, Z+19	; 0x13
    c658:	0e 94 f1 ac 	call	0x159e2	; 0x159e2 <lcd_xy>
    c65c:	61 cf       	rjmp	.-318    	; 0xc520 <_menu_datetime+0x132>
		}
		if(__key == _KEY_CANCEL)
    c65e:	17 3e       	cpi	r17, 0xE7	; 231
    c660:	09 f4       	brne	.+2      	; 0xc664 <_menu_datetime+0x276>
    c662:	49 c0       	rjmp	.+146    	; 0xc6f6 <_menu_datetime+0x308>
			break;
		if(__key == _KEY_ENTER){
    c664:	17 3b       	cpi	r17, 0xB7	; 183
    c666:	09 f0       	breq	.+2      	; 0xc66a <_menu_datetime+0x27c>
    c668:	5b cf       	rjmp	.-330    	; 0xc520 <_menu_datetime+0x132>
    c66a:	20 e0       	ldi	r18, 0x00	; 0
    c66c:	30 e0       	ldi	r19, 0x00	; 0
    c66e:	40 e0       	ldi	r20, 0x00	; 0
    c670:	50 e0       	ldi	r21, 0x00	; 0
			for(__i = 0, __ii = 0; __i < 6; __i++, __ii++){
				if(__i == 2 || __i == 4)
					__ii++;
				__date[__ii] = __map[__i][2];
    c672:	be 01       	movw	r22, r28
    c674:	6f 5f       	subi	r22, 0xFF	; 255
    c676:	7f 4f       	sbci	r23, 0xFF	; 255
		}
		if(__key == _KEY_CANCEL)
			break;
		if(__key == _KEY_ENTER){
			for(__i = 0, __ii = 0; __i < 6; __i++, __ii++){
				if(__i == 2 || __i == 4)
    c678:	22 30       	cpi	r18, 0x02	; 2
    c67a:	31 05       	cpc	r19, r1
    c67c:	19 f0       	breq	.+6      	; 0xc684 <_menu_datetime+0x296>
    c67e:	24 30       	cpi	r18, 0x04	; 4
    c680:	31 05       	cpc	r19, r1
    c682:	11 f4       	brne	.+4      	; 0xc688 <_menu_datetime+0x29a>
					__ii++;
    c684:	4f 5f       	subi	r20, 0xFF	; 255
    c686:	5f 4f       	sbci	r21, 0xFF	; 255
				__date[__ii] = __map[__i][2];
    c688:	fb 01       	movw	r30, r22
    c68a:	e4 0f       	add	r30, r20
    c68c:	f5 1f       	adc	r31, r21
    c68e:	d4 01       	movw	r26, r8
    c690:	8c 91       	ld	r24, X
    c692:	80 83       	st	Z, r24
			lcd_xy(__map[__i][0], __map[__i][1]);
		}
		if(__key == _KEY_CANCEL)
			break;
		if(__key == _KEY_ENTER){
			for(__i = 0, __ii = 0; __i < 6; __i++, __ii++){
    c694:	2f 5f       	subi	r18, 0xFF	; 255
    c696:	3f 4f       	sbci	r19, 0xFF	; 255
    c698:	84 e0       	ldi	r24, 0x04	; 4
    c69a:	90 e0       	ldi	r25, 0x00	; 0
    c69c:	88 0e       	add	r8, r24
    c69e:	99 1e       	adc	r9, r25
    c6a0:	26 30       	cpi	r18, 0x06	; 6
    c6a2:	31 05       	cpc	r19, r1
    c6a4:	19 f0       	breq	.+6      	; 0xc6ac <_menu_datetime+0x2be>
    c6a6:	4f 5f       	subi	r20, 0xFF	; 255
    c6a8:	5f 4f       	sbci	r21, 0xFF	; 255
    c6aa:	e6 cf       	rjmp	.-52     	; 0xc678 <_menu_datetime+0x28a>
    c6ac:	60 e0       	ldi	r22, 0x00	; 0
    c6ae:	70 e0       	ldi	r23, 0x00	; 0
				__date[__ii] = __map[__i][2];
			}
			for(__i = 6, __ii = 0; __i < 12; __i++, __ii++){
				if(__i == 8 || __i == 10)
					__ii++;
				__time[__ii] = __map[__i][2];
    c6b0:	ae 01       	movw	r20, r28
    c6b2:	46 5f       	subi	r20, 0xF6	; 246
    c6b4:	5f 4f       	sbci	r21, 0xFF	; 255
				if(__i == 2 || __i == 4)
					__ii++;
				__date[__ii] = __map[__i][2];
			}
			for(__i = 6, __ii = 0; __i < 12; __i++, __ii++){
				if(__i == 8 || __i == 10)
    c6b6:	28 30       	cpi	r18, 0x08	; 8
    c6b8:	31 05       	cpc	r19, r1
    c6ba:	19 f0       	breq	.+6      	; 0xc6c2 <_menu_datetime+0x2d4>
    c6bc:	2a 30       	cpi	r18, 0x0A	; 10
    c6be:	31 05       	cpc	r19, r1
    c6c0:	11 f4       	brne	.+4      	; 0xc6c6 <_menu_datetime+0x2d8>
					__ii++;
    c6c2:	6f 5f       	subi	r22, 0xFF	; 255
    c6c4:	7f 4f       	sbci	r23, 0xFF	; 255
				__time[__ii] = __map[__i][2];
    c6c6:	fa 01       	movw	r30, r20
    c6c8:	e6 0f       	add	r30, r22
    c6ca:	f7 1f       	adc	r31, r23
    c6cc:	d5 01       	movw	r26, r10
    c6ce:	8c 91       	ld	r24, X
    c6d0:	80 83       	st	Z, r24
			for(__i = 0, __ii = 0; __i < 6; __i++, __ii++){
				if(__i == 2 || __i == 4)
					__ii++;
				__date[__ii] = __map[__i][2];
			}
			for(__i = 6, __ii = 0; __i < 12; __i++, __ii++){
    c6d2:	2f 5f       	subi	r18, 0xFF	; 255
    c6d4:	3f 4f       	sbci	r19, 0xFF	; 255
    c6d6:	84 e0       	ldi	r24, 0x04	; 4
    c6d8:	90 e0       	ldi	r25, 0x00	; 0
    c6da:	a8 0e       	add	r10, r24
    c6dc:	b9 1e       	adc	r11, r25
    c6de:	2c 30       	cpi	r18, 0x0C	; 12
    c6e0:	31 05       	cpc	r19, r1
    c6e2:	19 f0       	breq	.+6      	; 0xc6ea <_menu_datetime+0x2fc>
    c6e4:	6f 5f       	subi	r22, 0xFF	; 255
    c6e6:	7f 4f       	sbci	r23, 0xFF	; 255
    c6e8:	e6 cf       	rjmp	.-52     	; 0xc6b6 <_menu_datetime+0x2c8>
				if(__i == 8 || __i == 10)
					__ii++;
				__time[__ii] = __map[__i][2];
			}
			_datetime(_DATETIME_WRITE, __date, __time);
    c6ea:	81 e0       	ldi	r24, 0x01	; 1
    c6ec:	be 01       	movw	r22, r28
    c6ee:	6f 5f       	subi	r22, 0xFF	; 255
    c6f0:	7f 4f       	sbci	r23, 0xFF	; 255
    c6f2:	0e 94 76 b1 	call	0x162ec	; 0x162ec <_datetime>
			break;
		}
	}
	CURSOR_HIDE;
    c6f6:	8c e0       	ldi	r24, 0x0C	; 12
    c6f8:	0e 94 5e ac 	call	0x158bc	; 0x158bc <lcd_command>
}
    c6fc:	ce 5b       	subi	r28, 0xBE	; 190
    c6fe:	df 4f       	sbci	r29, 0xFF	; 255
    c700:	0f b6       	in	r0, 0x3f	; 63
    c702:	f8 94       	cli
    c704:	de bf       	out	0x3e, r29	; 62
    c706:	0f be       	out	0x3f, r0	; 63
    c708:	cd bf       	out	0x3d, r28	; 61
    c70a:	cf 91       	pop	r28
    c70c:	df 91       	pop	r29
    c70e:	1f 91       	pop	r17
    c710:	0f 91       	pop	r16
    c712:	ff 90       	pop	r15
    c714:	ef 90       	pop	r14
    c716:	df 90       	pop	r13
    c718:	cf 90       	pop	r12
    c71a:	bf 90       	pop	r11
    c71c:	af 90       	pop	r10
    c71e:	9f 90       	pop	r9
    c720:	8f 90       	pop	r8
    c722:	08 95       	ret

0000c724 <FSettingDatetime>:
	 }
     return Result;
}

char FSettingDatetime(){
     _menu_datetime();
    c724:	0e 94 f7 61 	call	0xc3ee	; 0xc3ee <_menu_datetime>
     return MENU_DONE;
}
    c728:	81 e0       	ldi	r24, 0x01	; 1
    c72a:	08 95       	ret

0000c72c <menu_FIP>:
	 }
  return Result;
}


char menu_FIP(char *xFIP,char *sFIPUsed){
    c72c:	4f 92       	push	r4
    c72e:	5f 92       	push	r5
    c730:	6f 92       	push	r6
    c732:	7f 92       	push	r7
    c734:	8f 92       	push	r8
    c736:	9f 92       	push	r9
    c738:	af 92       	push	r10
    c73a:	bf 92       	push	r11
    c73c:	cf 92       	push	r12
    c73e:	df 92       	push	r13
    c740:	ef 92       	push	r14
    c742:	ff 92       	push	r15
    c744:	0f 93       	push	r16
    c746:	1f 93       	push	r17
    c748:	df 93       	push	r29
    c74a:	cf 93       	push	r28
    c74c:	cd b7       	in	r28, 0x3d	; 61
    c74e:	de b7       	in	r29, 0x3e	; 62
    c750:	a2 97       	sbiw	r28, 0x22	; 34
    c752:	0f b6       	in	r0, 0x3f	; 63
    c754:	f8 94       	cli
    c756:	de bf       	out	0x3e, r29	; 62
    c758:	0f be       	out	0x3f, r0	; 63
    c75a:	cd bf       	out	0x3d, r28	; 61
    c75c:	7c 01       	movw	r14, r24
    c75e:	8b 01       	movw	r16, r22
       char Result=FIP_NONE;
       char FIP[8],strPumpL[3],strPumpR[3],lcdteks[20];
static char KeyPressed=0,KeyChar,KeyCharLast=' ',FIP_Used=0;
static unsigned int iLoop;

       switch(stEnterFIP){
    c760:	80 91 58 03 	lds	r24, 0x0358
    c764:	81 30       	cpi	r24, 0x01	; 1
    c766:	09 f4       	brne	.+2      	; 0xc76a <menu_FIP+0x3e>
    c768:	cf c0       	rjmp	.+414    	; 0xc908 <menu_FIP+0x1dc>
    c76a:	81 30       	cpi	r24, 0x01	; 1
    c76c:	20 f0       	brcs	.+8      	; 0xc776 <menu_FIP+0x4a>
    c76e:	82 30       	cpi	r24, 0x02	; 2
    c770:	09 f0       	breq	.+2      	; 0xc774 <menu_FIP+0x48>
    c772:	55 c1       	rjmp	.+682    	; 0xca1e <menu_FIP+0x2f2>
    c774:	52 c1       	rjmp	.+676    	; 0xca1a <menu_FIP+0x2ee>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    c776:	8e 01       	movw	r16, r28
    c778:	09 5f       	subi	r16, 0xF9	; 249
    c77a:	1f 4f       	sbci	r17, 0xFF	; 255
    c77c:	c8 01       	movw	r24, r16
    c77e:	65 e4       	ldi	r22, 0x45	; 69
    c780:	70 e0       	ldi	r23, 0x00	; 0
    c782:	48 e0       	ldi	r20, 0x08	; 8
    c784:	50 e0       	ldi	r21, 0x00	; 0
    c786:	23 ef       	ldi	r18, 0xF3	; 243
    c788:	32 e1       	ldi	r19, 0x12	; 18
    c78a:	0e 94 1f b4 	call	0x1683e	; 0x1683e <__eerd_block>
 	   case efInit:
	 	    eeprom_read_block((void*) &FIP, (const void*) &DefPumpMap, 8);
		    lcd_clear(); 
    c78e:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
    c792:	f8 01       	movw	r30, r16
    c794:	20 e0       	ldi	r18, 0x00	; 0
    c796:	30 e0       	ldi	r19, 0x00	; 0
    c798:	07 c0       	rjmp	.+14     	; 0xc7a8 <menu_FIP+0x7c>
		    for (iLoop=0;iLoop<8;iLoop++){
			     if (FIP[iLoop]>99) FIP[iLoop]=0;
    c79a:	80 81       	ld	r24, Z
    c79c:	84 36       	cpi	r24, 0x64	; 100
    c79e:	08 f0       	brcs	.+2      	; 0xc7a2 <menu_FIP+0x76>
    c7a0:	10 82       	st	Z, r1
    c7a2:	2f 5f       	subi	r18, 0xFF	; 255
    c7a4:	3f 4f       	sbci	r19, 0xFF	; 255
    c7a6:	31 96       	adiw	r30, 0x01	; 1

       switch(stEnterFIP){
 	   case efInit:
	 	    eeprom_read_block((void*) &FIP, (const void*) &DefPumpMap, 8);
		    lcd_clear(); 
		    for (iLoop=0;iLoop<8;iLoop++){
    c7a8:	28 30       	cpi	r18, 0x08	; 8
    c7aa:	31 05       	cpc	r19, r1
    c7ac:	b0 f3       	brcs	.-20     	; 0xc79a <menu_FIP+0x6e>
			     if (FIP[iLoop]>99) FIP[iLoop]=0;
		    }
		    for(iLoop=0;iLoop<4;iLoop++){
    c7ae:	10 92 54 03 	sts	0x0354, r1
    c7b2:	10 92 53 03 	sts	0x0353, r1
		}
     else {
	    sprintf_P(StrResult,PSTR("%d"),Val);
	 }
	 */
     sprintf_P(StrResult,PSTR("%.2d"),Val);
    c7b6:	5e 01       	movw	r10, r28
    c7b8:	08 94       	sec
    c7ba:	a1 1c       	adc	r10, r1
    c7bc:	b1 1c       	adc	r11, r1
    c7be:	06 e5       	ldi	r16, 0x56	; 86
    c7c0:	c0 2e       	mov	r12, r16
    c7c2:	0d e0       	ldi	r16, 0x0D	; 13
    c7c4:	d0 2e       	mov	r13, r16
    c7c6:	17 e0       	ldi	r17, 0x07	; 7
    c7c8:	41 2e       	mov	r4, r17
    c7ca:	51 2c       	mov	r5, r1
    c7cc:	4c 0e       	add	r4, r28
    c7ce:	5d 1e       	adc	r5, r29
		    for (iLoop=0;iLoop<8;iLoop++){
			     if (FIP[iLoop]>99) FIP[iLoop]=0;
		    }
		    for(iLoop=0;iLoop<4;iLoop++){
		        leadingZero(FIP[iLoop],strPumpL);leadingZero(FIP[iLoop+4],strPumpR);
                sprintf_P(lcdteks,PSTR("%d.P%s | %d.P%s"),(iLoop+1),strPumpL,(iLoop+5),strPumpR);
    c7d0:	b4 e0       	ldi	r27, 0x04	; 4
    c7d2:	eb 2e       	mov	r14, r27
    c7d4:	f1 2c       	mov	r15, r1
    c7d6:	ec 0e       	add	r14, r28
    c7d8:	fd 1e       	adc	r15, r29
    c7da:	ab e0       	ldi	r26, 0x0B	; 11
    c7dc:	6a 2e       	mov	r6, r26
    c7de:	71 2c       	mov	r7, r1
    c7e0:	6c 0e       	add	r6, r28
    c7e2:	7d 1e       	adc	r7, r29
    c7e4:	8e 01       	movw	r16, r28
    c7e6:	01 5f       	subi	r16, 0xF1	; 241
    c7e8:	1f 4f       	sbci	r17, 0xFF	; 255
    c7ea:	f8 e9       	ldi	r31, 0x98	; 152
    c7ec:	8f 2e       	mov	r8, r31
    c7ee:	fb e1       	ldi	r31, 0x1B	; 27
    c7f0:	9f 2e       	mov	r9, r31
    c7f2:	64 c0       	rjmp	.+200    	; 0xc8bc <menu_FIP+0x190>
		}
     else {
	    sprintf_P(StrResult,PSTR("%d"),Val);
	 }
	 */
     sprintf_P(StrResult,PSTR("%.2d"),Val);
    c7f4:	00 d0       	rcall	.+0      	; 0xc7f6 <menu_FIP+0xca>
    c7f6:	00 d0       	rcall	.+0      	; 0xc7f8 <menu_FIP+0xcc>
    c7f8:	00 d0       	rcall	.+0      	; 0xc7fa <menu_FIP+0xce>
    c7fa:	2d b7       	in	r18, 0x3d	; 61
    c7fc:	3e b7       	in	r19, 0x3e	; 62
    c7fe:	2f 5f       	subi	r18, 0xFF	; 255
    c800:	3f 4f       	sbci	r19, 0xFF	; 255
    c802:	ed b7       	in	r30, 0x3d	; 61
    c804:	fe b7       	in	r31, 0x3e	; 62
    c806:	b2 82       	std	Z+2, r11	; 0x02
    c808:	a1 82       	std	Z+1, r10	; 0x01
    c80a:	f9 01       	movw	r30, r18
    c80c:	d3 82       	std	Z+3, r13	; 0x03
    c80e:	c2 82       	std	Z+2, r12	; 0x02
    c810:	a4 0d       	add	r26, r4
    c812:	b5 1d       	adc	r27, r5
    c814:	8c 91       	ld	r24, X
    c816:	84 83       	std	Z+4, r24	; 0x04
    c818:	15 82       	std	Z+5, r1	; 0x05
    c81a:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    c81e:	ad b7       	in	r26, 0x3d	; 61
    c820:	be b7       	in	r27, 0x3e	; 62
    c822:	11 96       	adiw	r26, 0x01	; 1
    c824:	ed b7       	in	r30, 0x3d	; 61
    c826:	fe b7       	in	r31, 0x3e	; 62
    c828:	f2 82       	std	Z+2, r15	; 0x02
    c82a:	e1 82       	std	Z+1, r14	; 0x01
    c82c:	13 96       	adiw	r26, 0x03	; 3
    c82e:	dc 92       	st	X, r13
    c830:	ce 92       	st	-X, r12
    c832:	12 97       	sbiw	r26, 0x02	; 2
    c834:	e0 91 53 03 	lds	r30, 0x0353
    c838:	f0 91 54 03 	lds	r31, 0x0354
    c83c:	e6 0d       	add	r30, r6
    c83e:	f7 1d       	adc	r31, r7
    c840:	80 81       	ld	r24, Z
    c842:	14 96       	adiw	r26, 0x04	; 4
    c844:	8c 93       	st	X, r24
    c846:	14 97       	sbiw	r26, 0x04	; 4
    c848:	15 96       	adiw	r26, 0x05	; 5
    c84a:	1c 92       	st	X, r1
    c84c:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
		    for (iLoop=0;iLoop<8;iLoop++){
			     if (FIP[iLoop]>99) FIP[iLoop]=0;
		    }
		    for(iLoop=0;iLoop<4;iLoop++){
		        leadingZero(FIP[iLoop],strPumpL);leadingZero(FIP[iLoop+4],strPumpR);
                sprintf_P(lcdteks,PSTR("%d.P%s | %d.P%s"),(iLoop+1),strPumpL,(iLoop+5),strPumpR);
    c850:	80 91 53 03 	lds	r24, 0x0353
    c854:	90 91 54 03 	lds	r25, 0x0354
    c858:	00 d0       	rcall	.+0      	; 0xc85a <menu_FIP+0x12e>
    c85a:	00 d0       	rcall	.+0      	; 0xc85c <menu_FIP+0x130>
    c85c:	00 d0       	rcall	.+0      	; 0xc85e <menu_FIP+0x132>
    c85e:	ed b7       	in	r30, 0x3d	; 61
    c860:	fe b7       	in	r31, 0x3e	; 62
    c862:	31 96       	adiw	r30, 0x01	; 1
    c864:	ad b7       	in	r26, 0x3d	; 61
    c866:	be b7       	in	r27, 0x3e	; 62
    c868:	12 96       	adiw	r26, 0x02	; 2
    c86a:	1c 93       	st	X, r17
    c86c:	0e 93       	st	-X, r16
    c86e:	11 97       	sbiw	r26, 0x01	; 1
    c870:	93 82       	std	Z+3, r9	; 0x03
    c872:	82 82       	std	Z+2, r8	; 0x02
    c874:	01 96       	adiw	r24, 0x01	; 1
    c876:	95 83       	std	Z+5, r25	; 0x05
    c878:	84 83       	std	Z+4, r24	; 0x04
    c87a:	b7 82       	std	Z+7, r11	; 0x07
    c87c:	a6 82       	std	Z+6, r10	; 0x06
    c87e:	04 96       	adiw	r24, 0x04	; 4
    c880:	91 87       	std	Z+9, r25	; 0x09
    c882:	80 87       	std	Z+8, r24	; 0x08
    c884:	f3 86       	std	Z+11, r15	; 0x0b
    c886:	e2 86       	std	Z+10, r14	; 0x0a
    c888:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
                //sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d"),(iLoop+1),FIP[iLoop],(iLoop+5),FIP[iLoop+4]);
			    lcd_print((iLoop+1),1,lcdteks);
    c88c:	ed b7       	in	r30, 0x3d	; 61
    c88e:	fe b7       	in	r31, 0x3e	; 62
    c890:	3c 96       	adiw	r30, 0x0c	; 12
    c892:	0f b6       	in	r0, 0x3f	; 63
    c894:	f8 94       	cli
    c896:	fe bf       	out	0x3e, r31	; 62
    c898:	0f be       	out	0x3f, r0	; 63
    c89a:	ed bf       	out	0x3d, r30	; 61
    c89c:	80 91 53 03 	lds	r24, 0x0353
    c8a0:	8f 5f       	subi	r24, 0xFF	; 255
    c8a2:	61 e0       	ldi	r22, 0x01	; 1
    c8a4:	a8 01       	movw	r20, r16
    c8a6:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
	 	    eeprom_read_block((void*) &FIP, (const void*) &DefPumpMap, 8);
		    lcd_clear(); 
		    for (iLoop=0;iLoop<8;iLoop++){
			     if (FIP[iLoop]>99) FIP[iLoop]=0;
		    }
		    for(iLoop=0;iLoop<4;iLoop++){
    c8aa:	80 91 53 03 	lds	r24, 0x0353
    c8ae:	90 91 54 03 	lds	r25, 0x0354
    c8b2:	01 96       	adiw	r24, 0x01	; 1
    c8b4:	90 93 54 03 	sts	0x0354, r25
    c8b8:	80 93 53 03 	sts	0x0353, r24
    c8bc:	a0 91 53 03 	lds	r26, 0x0353
    c8c0:	b0 91 54 03 	lds	r27, 0x0354
    c8c4:	a4 30       	cpi	r26, 0x04	; 4
    c8c6:	b1 05       	cpc	r27, r1
    c8c8:	08 f4       	brcc	.+2      	; 0xc8cc <menu_FIP+0x1a0>
    c8ca:	94 cf       	rjmp	.-216    	; 0xc7f4 <menu_FIP+0xc8>
		        leadingZero(FIP[iLoop],strPumpL);leadingZero(FIP[iLoop+4],strPumpR);
                sprintf_P(lcdteks,PSTR("%d.P%s | %d.P%s"),(iLoop+1),strPumpL,(iLoop+5),strPumpR);
                //sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d"),(iLoop+1),FIP[iLoop],(iLoop+5),FIP[iLoop+4]);
			    lcd_print((iLoop+1),1,lcdteks);
			}
		    lcd_printf(1,15,PSTR("FIP:_"));    //"1.P01 | 5.P05 FIP:_ "                                                                      
    c8cc:	81 e0       	ldi	r24, 0x01	; 1
    c8ce:	6f e0       	ldi	r22, 0x0F	; 15
    c8d0:	42 e9       	ldi	r20, 0x92	; 146
    c8d2:	5b e1       	ldi	r21, 0x1B	; 27
    c8d4:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		    lcd_printf(2,15,PSTR("     "));    //"2.P02 | 6.P05       "
    c8d8:	82 e0       	ldi	r24, 0x02	; 2
    c8da:	6f e0       	ldi	r22, 0x0F	; 15
    c8dc:	4c e8       	ldi	r20, 0x8C	; 140
    c8de:	5b e1       	ldi	r21, 0x1B	; 27
    c8e0:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		    lcd_printf(3,15,PSTR("#)OK "));    //"3.P03 | 7.P07 #)OK  "
    c8e4:	83 e0       	ldi	r24, 0x03	; 3
    c8e6:	6f e0       	ldi	r22, 0x0F	; 15
    c8e8:	46 e8       	ldi	r20, 0x86	; 134
    c8ea:	5b e1       	ldi	r21, 0x1B	; 27
    c8ec:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
	        lcd_printf(4,15,PSTR("*)Exit"));   //"4.P04 | 8.P08 *)Exit"				
    c8f0:	84 e0       	ldi	r24, 0x04	; 4
    c8f2:	6f e0       	ldi	r22, 0x0F	; 15
    c8f4:	4f e7       	ldi	r20, 0x7F	; 127
    c8f6:	5b e1       	ldi	r21, 0x1B	; 27
    c8f8:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		    iLoop=0;
    c8fc:	10 92 54 03 	sts	0x0354, r1
    c900:	10 92 53 03 	sts	0x0353, r1
		    stEnterFIP=efFIPInput;
    c904:	81 e0       	ldi	r24, 0x01	; 1
    c906:	86 c0       	rjmp	.+268    	; 0xca14 <menu_FIP+0x2e8>
	        break;
	   case efFIPInput:
		    iLoop++;
    c908:	80 91 53 03 	lds	r24, 0x0353
    c90c:	90 91 54 03 	lds	r25, 0x0354
    c910:	01 96       	adiw	r24, 0x01	; 1
    c912:	90 93 54 03 	sts	0x0354, r25
    c916:	80 93 53 03 	sts	0x0353, r24
		    KeyPressed=_key_scan(1);
    c91a:	81 e0       	ldi	r24, 0x01	; 1
    c91c:	0e 94 ab ae 	call	0x15d56	; 0x15d56 <_key_scan>
    c920:	80 93 57 03 	sts	0x0357, r24
		    KeyChar=_key_btn(KeyPressed);
    c924:	0e 94 0c ae 	call	0x15c18	; 0x15c18 <_key_btn>
    c928:	98 2f       	mov	r25, r24
    c92a:	80 93 56 03 	sts	0x0356, r24
		    if ((KeyChar>='1')&&(KeyChar<='8')){
    c92e:	81 53       	subi	r24, 0x31	; 49
    c930:	88 30       	cpi	r24, 0x08	; 8
    c932:	60 f4       	brcc	.+24     	; 0xc94c <menu_FIP+0x220>
		 	     if (KeyCharLast!=KeyChar){
    c934:	80 91 5a 01 	lds	r24, 0x015A
    c938:	89 17       	cp	r24, r25
    c93a:	41 f0       	breq	.+16     	; 0xc94c <menu_FIP+0x220>
				     KeyCharLast=KeyChar;
    c93c:	90 93 5a 01 	sts	0x015A, r25
				     iLoop=1000;
    c940:	88 ee       	ldi	r24, 0xE8	; 232
    c942:	93 e0       	ldi	r25, 0x03	; 3
    c944:	90 93 54 03 	sts	0x0354, r25
    c948:	80 93 53 03 	sts	0x0353, r24
                 }
		    }
 		    if ((iLoop%2000)==0){
    c94c:	80 91 53 03 	lds	r24, 0x0353
    c950:	90 91 54 03 	lds	r25, 0x0354
    c954:	60 ed       	ldi	r22, 0xD0	; 208
    c956:	77 e0       	ldi	r23, 0x07	; 7
    c958:	0e 94 38 b7 	call	0x16e70	; 0x16e70 <__udivmodhi4>
    c95c:	89 2b       	or	r24, r25
    c95e:	39 f4       	brne	.+14     	; 0xc96e <menu_FIP+0x242>
		        lcd_xy(1,19);_lcd('_'); 
    c960:	81 e0       	ldi	r24, 0x01	; 1
    c962:	63 e1       	ldi	r22, 0x13	; 19
    c964:	0e 94 f1 ac 	call	0x159e2	; 0x159e2 <lcd_xy>
    c968:	8f e5       	ldi	r24, 0x5F	; 95
    c96a:	0e 94 cb ac 	call	0x15996	; 0x15996 <_lcd>
			   }
           if ((iLoop%2000)==1000){
    c96e:	80 91 53 03 	lds	r24, 0x0353
    c972:	90 91 54 03 	lds	r25, 0x0354
    c976:	60 ed       	ldi	r22, 0xD0	; 208
    c978:	77 e0       	ldi	r23, 0x07	; 7
    c97a:	0e 94 38 b7 	call	0x16e70	; 0x16e70 <__udivmodhi4>
    c97e:	88 5e       	subi	r24, 0xE8	; 232
    c980:	93 40       	sbci	r25, 0x03	; 3
    c982:	41 f4       	brne	.+16     	; 0xc994 <menu_FIP+0x268>
			    lcd_xy(1,19);_lcd(KeyCharLast); 
    c984:	81 e0       	ldi	r24, 0x01	; 1
    c986:	63 e1       	ldi	r22, 0x13	; 19
    c988:	0e 94 f1 ac 	call	0x159e2	; 0x159e2 <lcd_xy>
    c98c:	80 91 5a 01 	lds	r24, 0x015A
    c990:	0e 94 cb ac 	call	0x15996	; 0x15996 <_lcd>
			   }

		   if (((KeyChar>='1')&&(KeyChar<='8'))||(KeyPressed==_KEY_ENTER)&&(KeyCharLast!=' ')){ 
    c994:	80 91 56 03 	lds	r24, 0x0356
    c998:	81 53       	subi	r24, 0x31	; 49
    c99a:	88 30       	cpi	r24, 0x08	; 8
    c99c:	40 f0       	brcs	.+16     	; 0xc9ae <menu_FIP+0x282>
    c99e:	80 91 57 03 	lds	r24, 0x0357
    c9a2:	87 3b       	cpi	r24, 0xB7	; 183
    c9a4:	a1 f5       	brne	.+104    	; 0xca0e <menu_FIP+0x2e2>
    c9a6:	80 91 5a 01 	lds	r24, 0x015A
    c9aa:	80 32       	cpi	r24, 0x20	; 32
    c9ac:	c1 f1       	breq	.+112    	; 0xca1e <menu_FIP+0x2f2>
		         FIP_Used=FIP[KeyCharLast-'1'];
    c9ae:	80 91 5a 01 	lds	r24, 0x015A
    c9b2:	fe 01       	movw	r30, r28
    c9b4:	ba 97       	sbiw	r30, 0x2a	; 42
    c9b6:	e8 0f       	add	r30, r24
    c9b8:	f1 1d       	adc	r31, r1
    c9ba:	20 81       	ld	r18, Z
    c9bc:	20 93 55 03 	sts	0x0355, r18
				 if (FIP_Used<=99){
    c9c0:	24 36       	cpi	r18, 0x64	; 100
    c9c2:	00 f5       	brcc	.+64     	; 0xca04 <menu_FIP+0x2d8>
		}
     else {
	    sprintf_P(StrResult,PSTR("%d"),Val);
	 }
	 */
     sprintf_P(StrResult,PSTR("%.2d"),Val);
    c9c4:	00 d0       	rcall	.+0      	; 0xc9c6 <menu_FIP+0x29a>
    c9c6:	00 d0       	rcall	.+0      	; 0xc9c8 <menu_FIP+0x29c>
    c9c8:	00 d0       	rcall	.+0      	; 0xc9ca <menu_FIP+0x29e>
    c9ca:	ed b7       	in	r30, 0x3d	; 61
    c9cc:	fe b7       	in	r31, 0x3e	; 62
    c9ce:	31 96       	adiw	r30, 0x01	; 1
    c9d0:	ad b7       	in	r26, 0x3d	; 61
    c9d2:	be b7       	in	r27, 0x3e	; 62
    c9d4:	12 96       	adiw	r26, 0x02	; 2
    c9d6:	1c 93       	st	X, r17
    c9d8:	0e 93       	st	-X, r16
    c9da:	11 97       	sbiw	r26, 0x01	; 1
    c9dc:	86 e5       	ldi	r24, 0x56	; 86
    c9de:	9d e0       	ldi	r25, 0x0D	; 13
    c9e0:	93 83       	std	Z+3, r25	; 0x03
    c9e2:	82 83       	std	Z+2, r24	; 0x02
    c9e4:	24 83       	std	Z+4, r18	; 0x04
    c9e6:	15 82       	std	Z+5, r1	; 0x05
    c9e8:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
		   if (((KeyChar>='1')&&(KeyChar<='8'))||(KeyPressed==_KEY_ENTER)&&(KeyCharLast!=' ')){ 
		         FIP_Used=FIP[KeyCharLast-'1'];
				 if (FIP_Used<=99){
                    leadingZero(FIP_Used,sFIPUsed);
					 //sprintf_P(sFIPUsed,PSTR("%.2d"),FIP_Used);
					 xFIP[0]=FIP_Used;
    c9ec:	80 91 55 03 	lds	r24, 0x0355
    c9f0:	f7 01       	movw	r30, r14
    c9f2:	80 83       	st	Z, r24
    c9f4:	8d b7       	in	r24, 0x3d	; 61
    c9f6:	9e b7       	in	r25, 0x3e	; 62
    c9f8:	06 96       	adiw	r24, 0x06	; 6
    c9fa:	0f b6       	in	r0, 0x3f	; 63
    c9fc:	f8 94       	cli
    c9fe:	9e bf       	out	0x3e, r25	; 62
    ca00:	0f be       	out	0x3f, r0	; 63
    ca02:	8d bf       	out	0x3d, r24	; 61
					 }
				 Result=FIP_DONE;
                 stEnterFIP=efExitFIPInput;
    ca04:	82 e0       	ldi	r24, 0x02	; 2
    ca06:	80 93 58 03 	sts	0x0358, r24
    ca0a:	80 e0       	ldi	r24, 0x00	; 0
    ca0c:	09 c0       	rjmp	.+18     	; 0xca20 <menu_FIP+0x2f4>
		   }
		   else
		   if (KeyPressed==_KEY_CANCEL){
    ca0e:	87 3e       	cpi	r24, 0xE7	; 231
    ca10:	31 f4       	brne	.+12     	; 0xca1e <menu_FIP+0x2f2>
               Result=FIP_CANCEL;
			   stEnterFIP=efExitFIPInput;
    ca12:	82 e0       	ldi	r24, 0x02	; 2
    ca14:	80 93 58 03 	sts	0x0358, r24
    ca18:	03 c0       	rjmp	.+6      	; 0xca20 <menu_FIP+0x2f4>
		   }
	       break;
      case efExitFIPInput:
           stEnterFIP=efInit;
    ca1a:	10 92 58 03 	sts	0x0358, r1
    ca1e:	81 e0       	ldi	r24, 0x01	; 1
	       break;
	 }
return Result;
}
    ca20:	a2 96       	adiw	r28, 0x22	; 34
    ca22:	0f b6       	in	r0, 0x3f	; 63
    ca24:	f8 94       	cli
    ca26:	de bf       	out	0x3e, r29	; 62
    ca28:	0f be       	out	0x3f, r0	; 63
    ca2a:	cd bf       	out	0x3d, r28	; 61
    ca2c:	cf 91       	pop	r28
    ca2e:	df 91       	pop	r29
    ca30:	1f 91       	pop	r17
    ca32:	0f 91       	pop	r16
    ca34:	ff 90       	pop	r15
    ca36:	ef 90       	pop	r14
    ca38:	df 90       	pop	r13
    ca3a:	cf 90       	pop	r12
    ca3c:	bf 90       	pop	r11
    ca3e:	af 90       	pop	r10
    ca40:	9f 90       	pop	r9
    ca42:	8f 90       	pop	r8
    ca44:	7f 90       	pop	r7
    ca46:	6f 90       	pop	r6
    ca48:	5f 90       	pop	r5
    ca4a:	4f 90       	pop	r4
    ca4c:	08 95       	ret

0000ca4e <FMenuEDCTransaction>:
	      break;
	 }
	 return Result;
}

char FMenuEDCTransaction(){
    ca4e:	0f 93       	push	r16
    ca50:	1f 93       	push	r17
static char KeyPressed=0,FIP_Used=0,FIPResult;
       char lcdteks[20],Result=MENU_NONE;
//static unsigned int iLoop=0;

Result=MENU_NONE;
	 switch(stEtransaction){
    ca52:	80 91 4b 03 	lds	r24, 0x034B
    ca56:	85 30       	cpi	r24, 0x05	; 5
    ca58:	09 f4       	brne	.+2      	; 0xca5c <FMenuEDCTransaction+0xe>
    ca5a:	9f c0       	rjmp	.+318    	; 0xcb9a <FMenuEDCTransaction+0x14c>
    ca5c:	86 30       	cpi	r24, 0x06	; 6
    ca5e:	90 f4       	brcc	.+36     	; 0xca84 <FMenuEDCTransaction+0x36>
    ca60:	82 30       	cpi	r24, 0x02	; 2
    ca62:	09 f4       	brne	.+2      	; 0xca66 <FMenuEDCTransaction+0x18>
    ca64:	57 c0       	rjmp	.+174    	; 0xcb14 <FMenuEDCTransaction+0xc6>
    ca66:	83 30       	cpi	r24, 0x03	; 3
    ca68:	30 f4       	brcc	.+12     	; 0xca76 <FMenuEDCTransaction+0x28>
    ca6a:	88 23       	and	r24, r24
    ca6c:	f1 f0       	breq	.+60     	; 0xcaaa <FMenuEDCTransaction+0x5c>
    ca6e:	81 30       	cpi	r24, 0x01	; 1
    ca70:	09 f0       	breq	.+2      	; 0xca74 <FMenuEDCTransaction+0x26>
    ca72:	dd c0       	rjmp	.+442    	; 0xcc2e <FMenuEDCTransaction+0x1e0>
    ca74:	36 c0       	rjmp	.+108    	; 0xcae2 <FMenuEDCTransaction+0x94>
    ca76:	83 30       	cpi	r24, 0x03	; 3
    ca78:	09 f4       	brne	.+2      	; 0xca7c <FMenuEDCTransaction+0x2e>
    ca7a:	5e c0       	rjmp	.+188    	; 0xcb38 <FMenuEDCTransaction+0xea>
    ca7c:	84 30       	cpi	r24, 0x04	; 4
    ca7e:	09 f0       	breq	.+2      	; 0xca82 <FMenuEDCTransaction+0x34>
    ca80:	d6 c0       	rjmp	.+428    	; 0xcc2e <FMenuEDCTransaction+0x1e0>
    ca82:	83 c0       	rjmp	.+262    	; 0xcb8a <FMenuEDCTransaction+0x13c>
    ca84:	88 30       	cpi	r24, 0x08	; 8
    ca86:	09 f4       	brne	.+2      	; 0xca8a <FMenuEDCTransaction+0x3c>
    ca88:	c2 c0       	rjmp	.+388    	; 0xcc0e <FMenuEDCTransaction+0x1c0>
    ca8a:	89 30       	cpi	r24, 0x09	; 9
    ca8c:	38 f4       	brcc	.+14     	; 0xca9c <FMenuEDCTransaction+0x4e>
    ca8e:	86 30       	cpi	r24, 0x06	; 6
    ca90:	09 f4       	brne	.+2      	; 0xca94 <FMenuEDCTransaction+0x46>
    ca92:	98 c0       	rjmp	.+304    	; 0xcbc4 <FMenuEDCTransaction+0x176>
    ca94:	87 30       	cpi	r24, 0x07	; 7
    ca96:	09 f0       	breq	.+2      	; 0xca9a <FMenuEDCTransaction+0x4c>
    ca98:	ca c0       	rjmp	.+404    	; 0xcc2e <FMenuEDCTransaction+0x1e0>
    ca9a:	96 c0       	rjmp	.+300    	; 0xcbc8 <FMenuEDCTransaction+0x17a>
    ca9c:	89 30       	cpi	r24, 0x09	; 9
    ca9e:	09 f4       	brne	.+2      	; 0xcaa2 <FMenuEDCTransaction+0x54>
    caa0:	bc c0       	rjmp	.+376    	; 0xcc1a <FMenuEDCTransaction+0x1cc>
    caa2:	8a 30       	cpi	r24, 0x0A	; 10
    caa4:	09 f0       	breq	.+2      	; 0xcaa8 <FMenuEDCTransaction+0x5a>
    caa6:	c3 c0       	rjmp	.+390    	; 0xcc2e <FMenuEDCTransaction+0x1e0>
    caa8:	be c0       	rjmp	.+380    	; 0xcc26 <FMenuEDCTransaction+0x1d8>
	 case etInit:
	      lcd_clear();
    caaa:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
		  lcd_printf(1,1,PSTR("Select Card Type"));
    caae:	81 e0       	ldi	r24, 0x01	; 1
    cab0:	61 e0       	ldi	r22, 0x01	; 1
    cab2:	4a e0       	ldi	r20, 0x0A	; 10
    cab4:	5a e1       	ldi	r21, 0x1A	; 26
    cab6:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
          lcd_printf(1,1,PSTR("1.Debit/Flash Card  "));
    caba:	81 e0       	ldi	r24, 0x01	; 1
    cabc:	61 e0       	ldi	r22, 0x01	; 1
    cabe:	45 ef       	ldi	r20, 0xF5	; 245
    cac0:	59 e1       	ldi	r21, 0x19	; 25
    cac2:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		  lcd_printf(2,1,PSTR("2.Credit Card       "));
    cac6:	82 e0       	ldi	r24, 0x02	; 2
    cac8:	61 e0       	ldi	r22, 0x01	; 1
    caca:	40 ee       	ldi	r20, 0xE0	; 224
    cacc:	59 e1       	ldi	r21, 0x19	; 25
    cace:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
	      lcd_printf(4,1,PSTR("[*]Back             "));
    cad2:	84 e0       	ldi	r24, 0x04	; 4
    cad4:	61 e0       	ldi	r22, 0x01	; 1
    cad6:	4b ec       	ldi	r20, 0xCB	; 203
    cad8:	59 e1       	ldi	r21, 0x19	; 25
    cada:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		  stEtransaction=etInputEDC;
    cade:	81 e0       	ldi	r24, 0x01	; 1
    cae0:	6e c0       	rjmp	.+220    	; 0xcbbe <FMenuEDCTransaction+0x170>
	      break;
     case etInputEDC:
	 	  KeyPressed=_key_scan(1);
    cae2:	81 e0       	ldi	r24, 0x01	; 1
    cae4:	0e 94 ab ae 	call	0x15d56	; 0x15d56 <_key_scan>
    cae8:	80 93 49 03 	sts	0x0349, r24
		  KeyChar=_key_btn(KeyPressed);
    caec:	0e 94 0c ae 	call	0x15c18	; 0x15c18 <_key_btn>
    caf0:	98 2f       	mov	r25, r24
    caf2:	80 93 4a 03 	sts	0x034A, r24
		  if ((KeyChar>='1')&&(KeyChar<='2')){
    caf6:	81 53       	subi	r24, 0x31	; 49
    caf8:	82 30       	cpi	r24, 0x02	; 2
    cafa:	30 f4       	brcc	.+12     	; 0xcb08 <FMenuEDCTransaction+0xba>
		       EDCType=KeyChar-'0';
    cafc:	90 53       	subi	r25, 0x30	; 48
    cafe:	90 93 10 0a 	sts	0x0A10, r25
		       stEtransaction=etSelectFIP;
    cb02:	82 e0       	ldi	r24, 0x02	; 2
    cb04:	80 93 4b 03 	sts	0x034B, r24
		     }
		  if (KeyPressed==_KEY_CANCEL)stEtransaction=etExitEDCTransaction;
    cb08:	80 91 49 03 	lds	r24, 0x0349
    cb0c:	87 3e       	cpi	r24, 0xE7	; 231
    cb0e:	09 f0       	breq	.+2      	; 0xcb12 <FMenuEDCTransaction+0xc4>
    cb10:	8e c0       	rjmp	.+284    	; 0xcc2e <FMenuEDCTransaction+0x1e0>
    cb12:	87 c0       	rjmp	.+270    	; 0xcc22 <FMenuEDCTransaction+0x1d4>
	      break;
	 case etSelectFIP:
	      FIPResult=menu_FIP(FIP_Used,strFIP_ID);
    cb14:	80 e0       	ldi	r24, 0x00	; 0
    cb16:	90 e0       	ldi	r25, 0x00	; 0
    cb18:	6c e9       	ldi	r22, 0x9C	; 156
    cb1a:	79 e0       	ldi	r23, 0x09	; 9
    cb1c:	0e 94 96 63 	call	0xc72c	; 0xc72c <menu_FIP>
    cb20:	80 93 48 03 	sts	0x0348, r24
		  if (FIPResult==FIP_DONE)stEtransaction=etInitMessage90;
    cb24:	88 23       	and	r24, r24
    cb26:	11 f4       	brne	.+4      	; 0xcb2c <FMenuEDCTransaction+0xde>
    cb28:	83 e0       	ldi	r24, 0x03	; 3
    cb2a:	49 c0       	rjmp	.+146    	; 0xcbbe <FMenuEDCTransaction+0x170>
		  else
		  if (FIPResult==FIP_CANCEL)stEtransaction=etInit;
    cb2c:	82 30       	cpi	r24, 0x02	; 2
    cb2e:	09 f0       	breq	.+2      	; 0xcb32 <FMenuEDCTransaction+0xe4>
    cb30:	7e c0       	rjmp	.+252    	; 0xcc2e <FMenuEDCTransaction+0x1e0>
    cb32:	10 92 4b 03 	sts	0x034B, r1
    cb36:	7b c0       	rjmp	.+246    	; 0xcc2e <FMenuEDCTransaction+0x1e0>
    cb38:	e8 e6       	ldi	r30, 0x68	; 104
    cb3a:	fe e0       	ldi	r31, 0x0E	; 14
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
    cb3c:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    cb3e:	8e e0       	ldi	r24, 0x0E	; 14
    cb40:	ed 37       	cpi	r30, 0x7D	; 125
    cb42:	f8 07       	cpc	r31, r24
    cb44:	d9 f7       	brne	.-10     	; 0xcb3c <FMenuEDCTransaction+0xee>
		  else
		  if (FIPResult==FIP_CANCEL)stEtransaction=etInit;
	      break;
     case etInitMessage90:
	      FillChar(strRef1,sizeof(strRef1),0);
	      if (EDCType==1){
    cb46:	80 91 10 0a 	lds	r24, 0x0A10
    cb4a:	81 30       	cpi	r24, 0x01	; 1
    cb4c:	19 f4       	brne	.+6      	; 0xcb54 <FMenuEDCTransaction+0x106>
		      AddSpaceLag(strRef1,20);
    cb4e:	cf 01       	movw	r24, r30
    cb50:	45 97       	sbiw	r24, 0x15	; 21
    cb52:	16 c0       	rjmp	.+44     	; 0xcb80 <FMenuEDCTransaction+0x132>
          }
		  else
	      if (EDCType==2){
    cb54:	82 30       	cpi	r24, 0x02	; 2
    cb56:	b9 f4       	brne	.+46     	; 0xcb86 <FMenuEDCTransaction+0x138>
		      sprintf_P(strRef1,PSTR("CREDITCARD"));
    cb58:	00 d0       	rcall	.+0      	; 0xcb5a <FMenuEDCTransaction+0x10c>
    cb5a:	00 d0       	rcall	.+0      	; 0xcb5c <FMenuEDCTransaction+0x10e>
    cb5c:	8f 01       	movw	r16, r30
    cb5e:	05 51       	subi	r16, 0x15	; 21
    cb60:	10 40       	sbci	r17, 0x00	; 0
    cb62:	ed b7       	in	r30, 0x3d	; 61
    cb64:	fe b7       	in	r31, 0x3e	; 62
    cb66:	12 83       	std	Z+2, r17	; 0x02
    cb68:	01 83       	std	Z+1, r16	; 0x01
    cb6a:	80 ec       	ldi	r24, 0xC0	; 192
    cb6c:	99 e1       	ldi	r25, 0x19	; 25
    cb6e:	94 83       	std	Z+4, r25	; 0x04
    cb70:	83 83       	std	Z+3, r24	; 0x03
    cb72:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
			  AddSpaceLag(strRef1,20);
    cb76:	0f 90       	pop	r0
    cb78:	0f 90       	pop	r0
    cb7a:	0f 90       	pop	r0
    cb7c:	0f 90       	pop	r0
    cb7e:	c8 01       	movw	r24, r16
    cb80:	64 e1       	ldi	r22, 0x14	; 20
    cb82:	0e 94 d8 2a 	call	0x55b0	; 0x55b0 <AddSpaceLag>
		  }	 
	      stEtransaction=etSendingMessage90;
    cb86:	84 e0       	ldi	r24, 0x04	; 4
    cb88:	1a c0       	rjmp	.+52     	; 0xcbbe <FMenuEDCTransaction+0x170>
	      break;
     case etSendingMessage90:
          sendMessage90();
    cb8a:	0e 94 8b 4e 	call	0x9d16	; 0x9d16 <sendMessage90>
		  TimSend=0;
    cb8e:	10 92 a9 01 	sts	0x01A9, r1
    cb92:	10 92 a8 01 	sts	0x01A8, r1
          stEtransaction=etWaitReply;
    cb96:	85 e0       	ldi	r24, 0x05	; 5
    cb98:	12 c0       	rjmp	.+36     	; 0xcbbe <FMenuEDCTransaction+0x170>
	      break;
     case etWaitReply:
	      if (TimSend>TIM_SEND*2)stEtransaction=etNoConnection;
    cb9a:	80 91 a8 01 	lds	r24, 0x01A8
    cb9e:	90 91 a9 01 	lds	r25, 0x01A9
    cba2:	45 97       	sbiw	r24, 0x15	; 21
    cba4:	18 f0       	brcs	.+6      	; 0xcbac <FMenuEDCTransaction+0x15e>
    cba6:	88 e0       	ldi	r24, 0x08	; 8
    cba8:	80 93 4b 03 	sts	0x034B, r24
		  if ((IsMessage91==True)||(IsMessage09==True))
    cbac:	80 91 be 01 	lds	r24, 0x01BE
    cbb0:	81 30       	cpi	r24, 0x01	; 1
    cbb2:	21 f0       	breq	.+8      	; 0xcbbc <FMenuEDCTransaction+0x16e>
    cbb4:	80 91 ba 01 	lds	r24, 0x01BA
    cbb8:	81 30       	cpi	r24, 0x01	; 1
    cbba:	c9 f5       	brne	.+114    	; 0xcc2e <FMenuEDCTransaction+0x1e0>
		       stEtransaction=etSuccesEDC;
    cbbc:	86 e0       	ldi	r24, 0x06	; 6
    cbbe:	80 93 4b 03 	sts	0x034B, r24
    cbc2:	35 c0       	rjmp	.+106    	; 0xcc2e <FMenuEDCTransaction+0x1e0>
	      break;
     case etSuccesEDC:
	      stEtransaction=etDisplayFreeMessage;
    cbc4:	87 e0       	ldi	r24, 0x07	; 7
    cbc6:	fb cf       	rjmp	.-10     	; 0xcbbe <FMenuEDCTransaction+0x170>
	      break;
     case etDisplayFreeMessage:
	      if (IsMessage09==True){
    cbc8:	80 91 ba 01 	lds	r24, 0x01BA
    cbcc:	81 30       	cpi	r24, 0x01	; 1
    cbce:	19 f5       	brne	.+70     	; 0xcc16 <FMenuEDCTransaction+0x1c8>
		      IsMessage09=False;
    cbd0:	10 92 ba 01 	sts	0x01BA, r1
	          procMessage09();
    cbd4:	0e 94 56 17 	call	0x2eac	; 0x2eac <procMessage09>
		      lcd_clear();
    cbd8:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
		      lcd_print(1,1,strFreeMessageLine1);
    cbdc:	81 e0       	ldi	r24, 0x01	; 1
    cbde:	61 e0       	ldi	r22, 0x01	; 1
    cbe0:	47 e9       	ldi	r20, 0x97	; 151
    cbe2:	5a e0       	ldi	r21, 0x0A	; 10
    cbe4:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
		      lcd_print(2,1,strFreeMessageLine2);
    cbe8:	82 e0       	ldi	r24, 0x02	; 2
    cbea:	61 e0       	ldi	r22, 0x01	; 1
    cbec:	46 e8       	ldi	r20, 0x86	; 134
    cbee:	59 e0       	ldi	r21, 0x09	; 9
    cbf0:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
		      lcd_print(3,1,strFreeMessageLine3);
    cbf4:	83 e0       	ldi	r24, 0x03	; 3
    cbf6:	61 e0       	ldi	r22, 0x01	; 1
    cbf8:	41 e2       	ldi	r20, 0x21	; 33
    cbfa:	5a e0       	ldi	r21, 0x0A	; 10
    cbfc:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
			  lcd_print(4,1,strFreeMessageLine4);
    cc00:	84 e0       	ldi	r24, 0x04	; 4
    cc02:	61 e0       	ldi	r22, 0x01	; 1
    cc04:	41 eb       	ldi	r20, 0xB1	; 177
    cc06:	5d e0       	ldi	r21, 0x0D	; 13
    cc08:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
    cc0c:	02 c0       	rjmp	.+4      	; 0xcc12 <FMenuEDCTransaction+0x1c4>
			  TimDisplay=0;
			  }
		  stEtransaction=etDelayExit;
	      break;
     case etNoConnection:
	      lcd_clear();
    cc0e:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
		  TimDisplay=0;
    cc12:	10 92 a7 01 	sts	0x01A7, r1
		  stEtransaction=etDelayExit;
    cc16:	89 e0       	ldi	r24, 0x09	; 9
    cc18:	d2 cf       	rjmp	.-92     	; 0xcbbe <FMenuEDCTransaction+0x170>
	      break;
     case etDelayExit:
	      if (TimDisplay>8)stEtransaction=etExitEDCTransaction;
    cc1a:	80 91 a7 01 	lds	r24, 0x01A7
    cc1e:	89 30       	cpi	r24, 0x09	; 9
    cc20:	30 f0       	brcs	.+12     	; 0xcc2e <FMenuEDCTransaction+0x1e0>
    cc22:	8a e0       	ldi	r24, 0x0A	; 10
    cc24:	cc cf       	rjmp	.-104    	; 0xcbbe <FMenuEDCTransaction+0x170>
	      break;
     case etExitEDCTransaction:
	      stEtransaction=etInit;
    cc26:	10 92 4b 03 	sts	0x034B, r1
    cc2a:	81 e0       	ldi	r24, 0x01	; 1
    cc2c:	01 c0       	rjmp	.+2      	; 0xcc30 <FMenuEDCTransaction+0x1e2>
    cc2e:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
   return Result;
}
    cc30:	1f 91       	pop	r17
    cc32:	0f 91       	pop	r16
    cc34:	08 95       	ret

0000cc36 <FMenuLoyalty>:
	      break;
	 }
  return Result;
}

char FMenuLoyalty(){
    cc36:	cf 92       	push	r12
    cc38:	df 92       	push	r13
    cc3a:	ef 92       	push	r14
    cc3c:	ff 92       	push	r15
    cc3e:	0f 93       	push	r16
    cc40:	1f 93       	push	r17
    cc42:	df 93       	push	r29
    cc44:	cf 93       	push	r28
    cc46:	cd b7       	in	r28, 0x3d	; 61
    cc48:	de b7       	in	r29, 0x3e	; 62
    cc4a:	64 97       	sbiw	r28, 0x14	; 20
    cc4c:	0f b6       	in	r0, 0x3f	; 63
    cc4e:	f8 94       	cli
    cc50:	de bf       	out	0x3e, r29	; 62
    cc52:	0f be       	out	0x3f, r0	; 63
    cc54:	cd bf       	out	0x3d, r28	; 61
       char FIPResult,FIP_USED;
	   char Result=MENU_NONE;
	   char KeyChar;

     Result=MENU_NONE;
	 switch(stLoyalty){
    cc56:	00 91 4f 03 	lds	r16, 0x034F
    cc5a:	07 30       	cpi	r16, 0x07	; 7
    cc5c:	09 f4       	brne	.+2      	; 0xcc60 <FMenuLoyalty+0x2a>
    cc5e:	08 c1       	rjmp	.+528    	; 0xce70 <FMenuLoyalty+0x23a>
    cc60:	08 30       	cpi	r16, 0x08	; 8
    cc62:	98 f4       	brcc	.+38     	; 0xcc8a <FMenuLoyalty+0x54>
    cc64:	03 30       	cpi	r16, 0x03	; 3
    cc66:	09 f4       	brne	.+2      	; 0xcc6a <FMenuLoyalty+0x34>
    cc68:	5d c0       	rjmp	.+186    	; 0xcd24 <FMenuLoyalty+0xee>
    cc6a:	04 30       	cpi	r16, 0x04	; 4
    cc6c:	38 f4       	brcc	.+14     	; 0xcc7c <FMenuLoyalty+0x46>
    cc6e:	01 30       	cpi	r16, 0x01	; 1
    cc70:	09 f4       	brne	.+2      	; 0xcc74 <FMenuLoyalty+0x3e>
    cc72:	42 c0       	rjmp	.+132    	; 0xccf8 <FMenuLoyalty+0xc2>
    cc74:	02 30       	cpi	r16, 0x02	; 2
    cc76:	08 f0       	brcs	.+2      	; 0xcc7a <FMenuLoyalty+0x44>
    cc78:	63 c0       	rjmp	.+198    	; 0xcd40 <FMenuLoyalty+0x10a>
    cc7a:	20 c0       	rjmp	.+64     	; 0xccbc <FMenuLoyalty+0x86>
    cc7c:	05 30       	cpi	r16, 0x05	; 5
    cc7e:	09 f4       	brne	.+2      	; 0xcc82 <FMenuLoyalty+0x4c>
    cc80:	a4 c0       	rjmp	.+328    	; 0xcdca <FMenuLoyalty+0x194>
    cc82:	06 30       	cpi	r16, 0x06	; 6
    cc84:	08 f0       	brcs	.+2      	; 0xcc88 <FMenuLoyalty+0x52>
    cc86:	be c0       	rjmp	.+380    	; 0xce04 <FMenuLoyalty+0x1ce>
    cc88:	8e c0       	rjmp	.+284    	; 0xcda6 <FMenuLoyalty+0x170>
    cc8a:	0b 30       	cpi	r16, 0x0B	; 11
    cc8c:	09 f4       	brne	.+2      	; 0xcc90 <FMenuLoyalty+0x5a>
    cc8e:	3e c1       	rjmp	.+636    	; 0xcf0c <FMenuLoyalty+0x2d6>
    cc90:	0c 30       	cpi	r16, 0x0C	; 12
    cc92:	38 f4       	brcc	.+14     	; 0xcca2 <FMenuLoyalty+0x6c>
    cc94:	09 30       	cpi	r16, 0x09	; 9
    cc96:	09 f4       	brne	.+2      	; 0xcc9a <FMenuLoyalty+0x64>
    cc98:	f6 c0       	rjmp	.+492    	; 0xce86 <FMenuLoyalty+0x250>
    cc9a:	0a 30       	cpi	r16, 0x0A	; 10
    cc9c:	08 f0       	brcs	.+2      	; 0xcca0 <FMenuLoyalty+0x6a>
    cc9e:	18 c1       	rjmp	.+560    	; 0xced0 <FMenuLoyalty+0x29a>
    cca0:	ea c0       	rjmp	.+468    	; 0xce76 <FMenuLoyalty+0x240>
    cca2:	0d 30       	cpi	r16, 0x0D	; 13
    cca4:	09 f4       	brne	.+2      	; 0xcca8 <FMenuLoyalty+0x72>
    cca6:	f6 c1       	rjmp	.+1004   	; 0xd094 <FMenuLoyalty+0x45e>
    cca8:	0d 30       	cpi	r16, 0x0D	; 13
    ccaa:	08 f4       	brcc	.+2      	; 0xccae <FMenuLoyalty+0x78>
    ccac:	ff c1       	rjmp	.+1022   	; 0xd0ac <FMenuLoyalty+0x476>
    ccae:	0e 30       	cpi	r16, 0x0E	; 14
    ccb0:	09 f4       	brne	.+2      	; 0xccb4 <FMenuLoyalty+0x7e>
    ccb2:	0e c2       	rjmp	.+1052   	; 0xd0d0 <FMenuLoyalty+0x49a>
    ccb4:	0f 30       	cpi	r16, 0x0F	; 15
    ccb6:	09 f0       	breq	.+2      	; 0xccba <FMenuLoyalty+0x84>
    ccb8:	17 c2       	rjmp	.+1070   	; 0xd0e8 <FMenuLoyalty+0x4b2>
    ccba:	10 c2       	rjmp	.+1056   	; 0xd0dc <FMenuLoyalty+0x4a6>
	 case mlInit:
	      lcd_clear();
    ccbc:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
		  lcd_printf(1,1,PSTR("  Menu Loyalty   "));
    ccc0:	81 e0       	ldi	r24, 0x01	; 1
    ccc2:	61 e0       	ldi	r22, 0x01	; 1
    ccc4:	47 ef       	ldi	r20, 0xF7	; 247
    ccc6:	5a e1       	ldi	r21, 0x1A	; 26
    ccc8:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
          lcd_printf(1,1,PSTR("1.Enquiry        "));
    cccc:	81 e0       	ldi	r24, 0x01	; 1
    ccce:	61 e0       	ldi	r22, 0x01	; 1
    ccd0:	45 ee       	ldi	r20, 0xE5	; 229
    ccd2:	5a e1       	ldi	r21, 0x1A	; 26
    ccd4:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		  lcd_printf(2,1,PSTR("2.Loyalty Update "));
    ccd8:	82 e0       	ldi	r24, 0x02	; 2
    ccda:	61 e0       	ldi	r22, 0x01	; 1
    ccdc:	43 ed       	ldi	r20, 0xD3	; 211
    ccde:	5a e1       	ldi	r21, 0x1A	; 26
    cce0:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
	      lcd_printf(4,1,PSTR("[*]Back          "));
    cce4:	84 e0       	ldi	r24, 0x04	; 4
    cce6:	61 e0       	ldi	r22, 0x01	; 1
    cce8:	41 ec       	ldi	r20, 0xC1	; 193
    ccea:	5a e1       	ldi	r21, 0x1A	; 26
    ccec:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		  IsLoyaltyUpdate=False;
    ccf0:	10 92 4c 03 	sts	0x034C, r1
		  stLoyalty=mlLoyaltySelect;
    ccf4:	81 e0       	ldi	r24, 0x01	; 1
    ccf6:	0a c0       	rjmp	.+20     	; 0xcd0c <FMenuLoyalty+0xd6>
	      break;
	 case mlLoyaltySelect:
	 	  KeyPressed=_key_scan(1);
    ccf8:	81 e0       	ldi	r24, 0x01	; 1
    ccfa:	0e 94 ab ae 	call	0x15d56	; 0x15d56 <_key_scan>
    ccfe:	80 93 4e 03 	sts	0x034E, r24
		  if (KeyPressed==_KEY_1){
    cd02:	8e 3e       	cpi	r24, 0xEE	; 238
    cd04:	31 f4       	brne	.+12     	; 0xcd12 <FMenuLoyalty+0xdc>
		      IsLoyaltyUpdate=False;
    cd06:	10 92 4c 03 	sts	0x034C, r1
		      stLoyalty=mlShowEnquiry;
    cd0a:	84 e0       	ldi	r24, 0x04	; 4
    cd0c:	80 93 4f 03 	sts	0x034F, r24
    cd10:	eb c1       	rjmp	.+982    	; 0xd0e8 <FMenuLoyalty+0x4b2>
			  }
		  else
		  if (KeyPressed==_KEY_2){
    cd12:	8e 3d       	cpi	r24, 0xDE	; 222
    cd14:	19 f4       	brne	.+6      	; 0xcd1c <FMenuLoyalty+0xe6>
		      IsLoyaltyUpdate=True;
    cd16:	00 93 4c 03 	sts	0x034C, r16
    cd1a:	6b c0       	rjmp	.+214    	; 0xcdf2 <FMenuLoyalty+0x1bc>
			  stLoyalty=mlSelectFIP;
			  }
		  if (KeyPressed==_KEY_CANCEL)stLoyalty=mlExitLoyalty;
    cd1c:	87 3e       	cpi	r24, 0xE7	; 231
    cd1e:	09 f4       	brne	.+2      	; 0xcd22 <FMenuLoyalty+0xec>
    cd20:	db c1       	rjmp	.+950    	; 0xd0d8 <FMenuLoyalty+0x4a2>
    cd22:	e2 c1       	rjmp	.+964    	; 0xd0e8 <FMenuLoyalty+0x4b2>
	      break;
     case mlSelectFIP:
	      FIPResult=menu_FIP(&FIP_Used,strFIP_ID);
    cd24:	8d e4       	ldi	r24, 0x4D	; 77
    cd26:	93 e0       	ldi	r25, 0x03	; 3
    cd28:	6c e9       	ldi	r22, 0x9C	; 156
    cd2a:	79 e0       	ldi	r23, 0x09	; 9
    cd2c:	0e 94 96 63 	call	0xc72c	; 0xc72c <menu_FIP>
		  if (FIPResult==FIP_DONE)stLoyalty=mlUpdateLoyalty;
    cd30:	88 23       	and	r24, r24
    cd32:	11 f4       	brne	.+4      	; 0xcd38 <FMenuLoyalty+0x102>
    cd34:	82 e0       	ldi	r24, 0x02	; 2
    cd36:	ea cf       	rjmp	.-44     	; 0xcd0c <FMenuLoyalty+0xd6>
		  else
		  if (FIPResult==FIP_CANCEL)stLoyalty=mlInit;
    cd38:	82 30       	cpi	r24, 0x02	; 2
    cd3a:	09 f0       	breq	.+2      	; 0xcd3e <FMenuLoyalty+0x108>
    cd3c:	d5 c1       	rjmp	.+938    	; 0xd0e8 <FMenuLoyalty+0x4b2>
    cd3e:	5b c0       	rjmp	.+182    	; 0xcdf6 <FMenuLoyalty+0x1c0>
	      break;
     case mlUpdateLoyalty: 
	      lcd_clear();
    cd40:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
		  sprintf_P(lcdteks,PSTR("FIP:%s"),strFIP_ID);
    cd44:	00 d0       	rcall	.+0      	; 0xcd46 <FMenuLoyalty+0x110>
    cd46:	00 d0       	rcall	.+0      	; 0xcd48 <FMenuLoyalty+0x112>
    cd48:	00 d0       	rcall	.+0      	; 0xcd4a <FMenuLoyalty+0x114>
    cd4a:	ed b7       	in	r30, 0x3d	; 61
    cd4c:	fe b7       	in	r31, 0x3e	; 62
    cd4e:	31 96       	adiw	r30, 0x01	; 1
    cd50:	8e 01       	movw	r16, r28
    cd52:	0f 5f       	subi	r16, 0xFF	; 255
    cd54:	1f 4f       	sbci	r17, 0xFF	; 255
    cd56:	ad b7       	in	r26, 0x3d	; 61
    cd58:	be b7       	in	r27, 0x3e	; 62
    cd5a:	12 96       	adiw	r26, 0x02	; 2
    cd5c:	1c 93       	st	X, r17
    cd5e:	0e 93       	st	-X, r16
    cd60:	11 97       	sbiw	r26, 0x01	; 1
    cd62:	8a eb       	ldi	r24, 0xBA	; 186
    cd64:	9a e1       	ldi	r25, 0x1A	; 26
    cd66:	93 83       	std	Z+3, r25	; 0x03
    cd68:	82 83       	std	Z+2, r24	; 0x02
    cd6a:	8c e9       	ldi	r24, 0x9C	; 156
    cd6c:	99 e0       	ldi	r25, 0x09	; 9
    cd6e:	95 83       	std	Z+5, r25	; 0x05
    cd70:	84 83       	std	Z+4, r24	; 0x04
    cd72:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
		  lcd_printf(1,1,PSTR("Tap Kartu RFID"));
    cd76:	8d b7       	in	r24, 0x3d	; 61
    cd78:	9e b7       	in	r25, 0x3e	; 62
    cd7a:	06 96       	adiw	r24, 0x06	; 6
    cd7c:	0f b6       	in	r0, 0x3f	; 63
    cd7e:	f8 94       	cli
    cd80:	9e bf       	out	0x3e, r25	; 62
    cd82:	0f be       	out	0x3f, r0	; 63
    cd84:	8d bf       	out	0x3d, r24	; 61
    cd86:	81 e0       	ldi	r24, 0x01	; 1
    cd88:	61 e0       	ldi	r22, 0x01	; 1
    cd8a:	4b ea       	ldi	r20, 0xAB	; 171
    cd8c:	5a e1       	ldi	r21, 0x1A	; 26
    cd8e:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		  lcd_print(2,1,lcdteks);
    cd92:	82 e0       	ldi	r24, 0x02	; 2
    cd94:	61 e0       	ldi	r22, 0x01	; 1
    cd96:	a8 01       	movw	r20, r16
    cd98:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
          lcd_printf(4,1,PSTR("[*]Back    [#]Exit"));
    cd9c:	84 e0       	ldi	r24, 0x04	; 4
    cd9e:	61 e0       	ldi	r22, 0x01	; 1
    cda0:	48 e9       	ldi	r20, 0x98	; 152
    cda2:	5a e1       	ldi	r21, 0x1A	; 26
    cda4:	0c c0       	rjmp	.+24     	; 0xcdbe <FMenuLoyalty+0x188>
		  IsRFIDDetected=False;
	      stLoyalty=mlInputRFID;
	      break;
	 case mlShowEnquiry:
	      lcd_clear();
    cda6:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
		  lcd_printf(1,1,PSTR("Tap Kartu RFID"));
    cdaa:	81 e0       	ldi	r24, 0x01	; 1
    cdac:	61 e0       	ldi	r22, 0x01	; 1
    cdae:	49 e8       	ldi	r20, 0x89	; 137
    cdb0:	5a e1       	ldi	r21, 0x1A	; 26
    cdb2:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
          lcd_printf(4,1,PSTR("[*]Back    [#]Exit"));
    cdb6:	84 e0       	ldi	r24, 0x04	; 4
    cdb8:	61 e0       	ldi	r22, 0x01	; 1
    cdba:	46 e7       	ldi	r20, 0x76	; 118
    cdbc:	5a e1       	ldi	r21, 0x1A	; 26
    cdbe:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		  IsRFIDDetected=False;
    cdc2:	10 92 af 01 	sts	0x01AF, r1
		  stLoyalty=mlInputRFID;
    cdc6:	85 e0       	ldi	r24, 0x05	; 5
    cdc8:	a1 cf       	rjmp	.-190    	; 0xcd0c <FMenuLoyalty+0xd6>
	      break;
     case mlInputRFID:
	      if (IsRFIDDetected==True){
    cdca:	80 91 af 01 	lds	r24, 0x01AF
    cdce:	81 30       	cpi	r24, 0x01	; 1
    cdd0:	29 f4       	brne	.+10     	; 0xcddc <FMenuLoyalty+0x1a6>
		      IsRFIDDetected=False;
    cdd2:	10 92 af 01 	sts	0x01AF, r1
		      stLoyalty=mlShowProsesRFID;
    cdd6:	86 e0       	ldi	r24, 0x06	; 6
    cdd8:	80 93 4f 03 	sts	0x034F, r24
		  }
	 	  KeyPressed=_key_scan(1);
    cddc:	81 e0       	ldi	r24, 0x01	; 1
    cdde:	0e 94 ab ae 	call	0x15d56	; 0x15d56 <_key_scan>
    cde2:	80 93 4e 03 	sts	0x034E, r24
		  if (KeyPressed==_KEY_CANCEL){
    cde6:	87 3e       	cpi	r24, 0xE7	; 231
    cde8:	49 f4       	brne	.+18     	; 0xcdfc <FMenuLoyalty+0x1c6>
		      if (IsLoyaltyUpdate==True)
    cdea:	80 91 4c 03 	lds	r24, 0x034C
    cdee:	81 30       	cpi	r24, 0x01	; 1
    cdf0:	11 f4       	brne	.+4      	; 0xcdf6 <FMenuLoyalty+0x1c0>
			       stLoyalty=mlSelectFIP;
    cdf2:	83 e0       	ldi	r24, 0x03	; 3
    cdf4:	8b cf       	rjmp	.-234    	; 0xcd0c <FMenuLoyalty+0xd6>
			  else stLoyalty=mlInit;
    cdf6:	10 92 4f 03 	sts	0x034F, r1
    cdfa:	76 c1       	rjmp	.+748    	; 0xd0e8 <FMenuLoyalty+0x4b2>
			  }
		  else
		  if (KeyPressed==_KEY_ENTER)stLoyalty=mlExitLoyalty;
    cdfc:	87 3b       	cpi	r24, 0xB7	; 183
    cdfe:	09 f0       	breq	.+2      	; 0xce02 <FMenuLoyalty+0x1cc>
    ce00:	73 c1       	rjmp	.+742    	; 0xd0e8 <FMenuLoyalty+0x4b2>
    ce02:	6a c1       	rjmp	.+724    	; 0xd0d8 <FMenuLoyalty+0x4a2>
	      break;
     case mlShowProsesRFID:
	      lcd_clear();
    ce04:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
		  sprintf_P(lcdteks,PSTR("ID:%s"),strRFID);
    ce08:	00 d0       	rcall	.+0      	; 0xce0a <FMenuLoyalty+0x1d4>
    ce0a:	00 d0       	rcall	.+0      	; 0xce0c <FMenuLoyalty+0x1d6>
    ce0c:	00 d0       	rcall	.+0      	; 0xce0e <FMenuLoyalty+0x1d8>
    ce0e:	ed b7       	in	r30, 0x3d	; 61
    ce10:	fe b7       	in	r31, 0x3e	; 62
    ce12:	31 96       	adiw	r30, 0x01	; 1
    ce14:	8e 01       	movw	r16, r28
    ce16:	0f 5f       	subi	r16, 0xFF	; 255
    ce18:	1f 4f       	sbci	r17, 0xFF	; 255
    ce1a:	ad b7       	in	r26, 0x3d	; 61
    ce1c:	be b7       	in	r27, 0x3e	; 62
    ce1e:	12 96       	adiw	r26, 0x02	; 2
    ce20:	1c 93       	st	X, r17
    ce22:	0e 93       	st	-X, r16
    ce24:	11 97       	sbiw	r26, 0x01	; 1
    ce26:	80 e7       	ldi	r24, 0x70	; 112
    ce28:	9a e1       	ldi	r25, 0x1A	; 26
    ce2a:	93 83       	std	Z+3, r25	; 0x03
    ce2c:	82 83       	std	Z+2, r24	; 0x02
    ce2e:	8c e2       	ldi	r24, 0x2C	; 44
    ce30:	9e e0       	ldi	r25, 0x0E	; 14
    ce32:	95 83       	std	Z+5, r25	; 0x05
    ce34:	84 83       	std	Z+4, r24	; 0x04
    ce36:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
		  lcd_print (1,1,lcdteks);	      
    ce3a:	8d b7       	in	r24, 0x3d	; 61
    ce3c:	9e b7       	in	r25, 0x3e	; 62
    ce3e:	06 96       	adiw	r24, 0x06	; 6
    ce40:	0f b6       	in	r0, 0x3f	; 63
    ce42:	f8 94       	cli
    ce44:	9e bf       	out	0x3e, r25	; 62
    ce46:	0f be       	out	0x3f, r0	; 63
    ce48:	8d bf       	out	0x3d, r24	; 61
    ce4a:	81 e0       	ldi	r24, 0x01	; 1
    ce4c:	61 e0       	ldi	r22, 0x01	; 1
    ce4e:	a8 01       	movw	r20, r16
    ce50:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
		  lcd_printf(2,1,PSTR("Proses"));	      
    ce54:	82 e0       	ldi	r24, 0x02	; 2
    ce56:	61 e0       	ldi	r22, 0x01	; 1
    ce58:	49 e6       	ldi	r20, 0x69	; 105
    ce5a:	5a e1       	ldi	r21, 0x1A	; 26
    ce5c:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		  if (IsLoyaltyUpdate==True)stLoyalty=mlSendMessage24;
    ce60:	80 91 4c 03 	lds	r24, 0x034C
    ce64:	81 30       	cpi	r24, 0x01	; 1
    ce66:	11 f4       	brne	.+4      	; 0xce6c <FMenuLoyalty+0x236>
    ce68:	88 e0       	ldi	r24, 0x08	; 8
    ce6a:	50 cf       	rjmp	.-352    	; 0xcd0c <FMenuLoyalty+0xd6>
		  else stLoyalty=mlSendMessage22;
    ce6c:	87 e0       	ldi	r24, 0x07	; 7
    ce6e:	4e cf       	rjmp	.-356    	; 0xcd0c <FMenuLoyalty+0xd6>
	      break;
     case mlSendMessage22:
	      sendMessage22();
    ce70:	0e 94 fd 51 	call	0xa3fa	; 0xa3fa <sendMessage22>
    ce74:	02 c0       	rjmp	.+4      	; 0xce7a <FMenuLoyalty+0x244>
		  TimSend=0;		  
          stLoyalty=mlWaitReply;
	      break;
     case mlSendMessage24:
	      sendMessage24();
    ce76:	0e 94 71 51 	call	0xa2e2	; 0xa2e2 <sendMessage24>
		  TimSend=0;		  
    ce7a:	10 92 a9 01 	sts	0x01A9, r1
    ce7e:	10 92 a8 01 	sts	0x01A8, r1
          stLoyalty=mlWaitReply;
    ce82:	89 e0       	ldi	r24, 0x09	; 9
    ce84:	43 cf       	rjmp	.-378    	; 0xcd0c <FMenuLoyalty+0xd6>
	      break;
     case mlWaitReply:
	      if (TimSend>(TIM_SEND*3))
    ce86:	80 91 a8 01 	lds	r24, 0x01A8
    ce8a:	90 91 a9 01 	lds	r25, 0x01A9
    ce8e:	4f 97       	sbiw	r24, 0x1f	; 31
    ce90:	18 f0       	brcs	.+6      	; 0xce98 <FMenuLoyalty+0x262>
		      stLoyalty=mlNoConnection;
    ce92:	8c e0       	ldi	r24, 0x0C	; 12
    ce94:	80 93 4f 03 	sts	0x034F, r24
	      if (IsMessage23==True){
    ce98:	80 91 b9 01 	lds	r24, 0x01B9
    ce9c:	81 30       	cpi	r24, 0x01	; 1
    ce9e:	39 f4       	brne	.+14     	; 0xceae <FMenuLoyalty+0x278>
		      IsMessage23=False;
    cea0:	10 92 b9 01 	sts	0x01B9, r1
			  procMessage23();
    cea4:	0e 94 a1 17 	call	0x2f42	; 0x2f42 <procMessage23>
			  stLoyalty=mlDispEnquiry;
    cea8:	8b e0       	ldi	r24, 0x0B	; 11
    ceaa:	80 93 4f 03 	sts	0x034F, r24
		  }
	      if (IsMessage09==True){
    ceae:	80 91 ba 01 	lds	r24, 0x01BA
    ceb2:	81 30       	cpi	r24, 0x01	; 1
    ceb4:	39 f4       	brne	.+14     	; 0xcec4 <FMenuLoyalty+0x28e>
		      IsMessage09=False;
    ceb6:	10 92 ba 01 	sts	0x01BA, r1
	          procMessage09();
    ceba:	0e 94 56 17 	call	0x2eac	; 0x2eac <procMessage09>
              stLoyalty=mlDisplayFreeMessage;
    cebe:	8a e0       	ldi	r24, 0x0A	; 10
    cec0:	80 93 4f 03 	sts	0x034F, r24
		  }
	      if (IsMessage99==True){
    cec4:	80 91 b6 01 	lds	r24, 0x01B6
    cec8:	81 30       	cpi	r24, 0x01	; 1
    ceca:	09 f0       	breq	.+2      	; 0xcece <FMenuLoyalty+0x298>
    cecc:	0d c1       	rjmp	.+538    	; 0xd0e8 <FMenuLoyalty+0x4b2>
    cece:	1c c0       	rjmp	.+56     	; 0xcf08 <FMenuLoyalty+0x2d2>
              stLoyalty=mlDelayExitLoyalty;
		  }
	      break;
     case mlDisplayFreeMessage:
		  lcd_clear();
    ced0:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
		  lcd_print(1,1,strFreeMessageLine1);
    ced4:	81 e0       	ldi	r24, 0x01	; 1
    ced6:	61 e0       	ldi	r22, 0x01	; 1
    ced8:	47 e9       	ldi	r20, 0x97	; 151
    ceda:	5a e0       	ldi	r21, 0x0A	; 10
    cedc:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
		  lcd_print(2,1,strFreeMessageLine2);
    cee0:	82 e0       	ldi	r24, 0x02	; 2
    cee2:	61 e0       	ldi	r22, 0x01	; 1
    cee4:	46 e8       	ldi	r20, 0x86	; 134
    cee6:	59 e0       	ldi	r21, 0x09	; 9
    cee8:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
		  lcd_print(3,1,strFreeMessageLine3);
    ceec:	83 e0       	ldi	r24, 0x03	; 3
    ceee:	61 e0       	ldi	r22, 0x01	; 1
    cef0:	41 e2       	ldi	r20, 0x21	; 33
    cef2:	5a e0       	ldi	r21, 0x0A	; 10
    cef4:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
		  lcd_print(4,1,strFreeMessageLine4);
    cef8:	84 e0       	ldi	r24, 0x04	; 4
    cefa:	61 e0       	ldi	r22, 0x01	; 1
    cefc:	41 eb       	ldi	r20, 0xB1	; 177
    cefe:	5d e0       	ldi	r21, 0x0D	; 13
    cf00:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
		  TimDisplay=0;
    cf04:	10 92 a7 01 	sts	0x01A7, r1
		  stLoyalty=mlDelayExitLoyalty;
    cf08:	8e e0       	ldi	r24, 0x0E	; 14
    cf0a:	00 cf       	rjmp	.-512    	; 0xcd0c <FMenuLoyalty+0xd6>
	      break;
     case mlDispEnquiry:	      
	      lcd_clear();
    cf0c:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
		  RemSpaceLag(strCardID);RemSpaceLag(strCardHolder);
    cf10:	21 e6       	ldi	r18, 0x61	; 97
    cf12:	c2 2e       	mov	r12, r18
    cf14:	2d e0       	ldi	r18, 0x0D	; 13
    cf16:	d2 2e       	mov	r13, r18
    cf18:	c6 01       	movw	r24, r12
    cf1a:	0e 94 70 24 	call	0x48e0	; 0x48e0 <RemSpaceLag>
    cf1e:	94 e0       	ldi	r25, 0x04	; 4
    cf20:	e9 2e       	mov	r14, r25
    cf22:	95 e0       	ldi	r25, 0x05	; 5
    cf24:	f9 2e       	mov	r15, r25
    cf26:	c7 01       	movw	r24, r14
    cf28:	0e 94 70 24 	call	0x48e0	; 0x48e0 <RemSpaceLag>
		  sprintf_P(lcdteks,PSTR("%s:%s"),strCardID,strCardHolder);
    cf2c:	ad b7       	in	r26, 0x3d	; 61
    cf2e:	be b7       	in	r27, 0x3e	; 62
    cf30:	18 97       	sbiw	r26, 0x08	; 8
    cf32:	0f b6       	in	r0, 0x3f	; 63
    cf34:	f8 94       	cli
    cf36:	be bf       	out	0x3e, r27	; 62
    cf38:	0f be       	out	0x3f, r0	; 63
    cf3a:	ad bf       	out	0x3d, r26	; 61
    cf3c:	ed b7       	in	r30, 0x3d	; 61
    cf3e:	fe b7       	in	r31, 0x3e	; 62
    cf40:	31 96       	adiw	r30, 0x01	; 1
    cf42:	8e 01       	movw	r16, r28
    cf44:	0f 5f       	subi	r16, 0xFF	; 255
    cf46:	1f 4f       	sbci	r17, 0xFF	; 255
    cf48:	12 96       	adiw	r26, 0x02	; 2
    cf4a:	1c 93       	st	X, r17
    cf4c:	0e 93       	st	-X, r16
    cf4e:	11 97       	sbiw	r26, 0x01	; 1
    cf50:	83 e6       	ldi	r24, 0x63	; 99
    cf52:	9a e1       	ldi	r25, 0x1A	; 26
    cf54:	93 83       	std	Z+3, r25	; 0x03
    cf56:	82 83       	std	Z+2, r24	; 0x02
    cf58:	d5 82       	std	Z+5, r13	; 0x05
    cf5a:	c4 82       	std	Z+4, r12	; 0x04
    cf5c:	f7 82       	std	Z+7, r15	; 0x07
    cf5e:	e6 82       	std	Z+6, r14	; 0x06
    cf60:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
		  lcd_print(1,1,lcdteks);RemSpaceLag(strLoyCurrentPoints);
    cf64:	8d b7       	in	r24, 0x3d	; 61
    cf66:	9e b7       	in	r25, 0x3e	; 62
    cf68:	08 96       	adiw	r24, 0x08	; 8
    cf6a:	0f b6       	in	r0, 0x3f	; 63
    cf6c:	f8 94       	cli
    cf6e:	9e bf       	out	0x3e, r25	; 62
    cf70:	0f be       	out	0x3f, r0	; 63
    cf72:	8d bf       	out	0x3d, r24	; 61
    cf74:	81 e0       	ldi	r24, 0x01	; 1
    cf76:	61 e0       	ldi	r22, 0x01	; 1
    cf78:	a8 01       	movw	r20, r16
    cf7a:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
    cf7e:	8a e3       	ldi	r24, 0x3A	; 58
    cf80:	e8 2e       	mov	r14, r24
    cf82:	8a e0       	ldi	r24, 0x0A	; 10
    cf84:	f8 2e       	mov	r15, r24
    cf86:	c7 01       	movw	r24, r14
    cf88:	0e 94 70 24 	call	0x48e0	; 0x48e0 <RemSpaceLag>
		  sprintf_P(lcdteks,PSTR("Points:%s"),strLoyCurrentPoints);
    cf8c:	00 d0       	rcall	.+0      	; 0xcf8e <FMenuLoyalty+0x358>
    cf8e:	00 d0       	rcall	.+0      	; 0xcf90 <FMenuLoyalty+0x35a>
    cf90:	00 d0       	rcall	.+0      	; 0xcf92 <FMenuLoyalty+0x35c>
    cf92:	ed b7       	in	r30, 0x3d	; 61
    cf94:	fe b7       	in	r31, 0x3e	; 62
    cf96:	31 96       	adiw	r30, 0x01	; 1
    cf98:	ad b7       	in	r26, 0x3d	; 61
    cf9a:	be b7       	in	r27, 0x3e	; 62
    cf9c:	12 96       	adiw	r26, 0x02	; 2
    cf9e:	1c 93       	st	X, r17
    cfa0:	0e 93       	st	-X, r16
    cfa2:	11 97       	sbiw	r26, 0x01	; 1
    cfa4:	89 e5       	ldi	r24, 0x59	; 89
    cfa6:	9a e1       	ldi	r25, 0x1A	; 26
    cfa8:	93 83       	std	Z+3, r25	; 0x03
    cfaa:	82 83       	std	Z+2, r24	; 0x02
    cfac:	f5 82       	std	Z+5, r15	; 0x05
    cfae:	e4 82       	std	Z+4, r14	; 0x04
    cfb0:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
		  lcd_print(2,1,lcdteks);RemSpaceLag(strLoyCurrentPoints);
    cfb4:	8d b7       	in	r24, 0x3d	; 61
    cfb6:	9e b7       	in	r25, 0x3e	; 62
    cfb8:	06 96       	adiw	r24, 0x06	; 6
    cfba:	0f b6       	in	r0, 0x3f	; 63
    cfbc:	f8 94       	cli
    cfbe:	9e bf       	out	0x3e, r25	; 62
    cfc0:	0f be       	out	0x3f, r0	; 63
    cfc2:	8d bf       	out	0x3d, r24	; 61
    cfc4:	82 e0       	ldi	r24, 0x02	; 2
    cfc6:	61 e0       	ldi	r22, 0x01	; 1
    cfc8:	a8 01       	movw	r20, r16
    cfca:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
    cfce:	c7 01       	movw	r24, r14
    cfd0:	0e 94 70 24 	call	0x48e0	; 0x48e0 <RemSpaceLag>
		  sprintf_P(lcdteks,PSTR("CM Amt:%s"),strLoyCurrMonConsumeA);
    cfd4:	00 d0       	rcall	.+0      	; 0xcfd6 <FMenuLoyalty+0x3a0>
    cfd6:	00 d0       	rcall	.+0      	; 0xcfd8 <FMenuLoyalty+0x3a2>
    cfd8:	00 d0       	rcall	.+0      	; 0xcfda <FMenuLoyalty+0x3a4>
    cfda:	ed b7       	in	r30, 0x3d	; 61
    cfdc:	fe b7       	in	r31, 0x3e	; 62
    cfde:	31 96       	adiw	r30, 0x01	; 1
    cfe0:	ad b7       	in	r26, 0x3d	; 61
    cfe2:	be b7       	in	r27, 0x3e	; 62
    cfe4:	12 96       	adiw	r26, 0x02	; 2
    cfe6:	1c 93       	st	X, r17
    cfe8:	0e 93       	st	-X, r16
    cfea:	11 97       	sbiw	r26, 0x01	; 1
    cfec:	8f e4       	ldi	r24, 0x4F	; 79
    cfee:	9a e1       	ldi	r25, 0x1A	; 26
    cff0:	93 83       	std	Z+3, r25	; 0x03
    cff2:	82 83       	std	Z+2, r24	; 0x02
    cff4:	8e e5       	ldi	r24, 0x5E	; 94
    cff6:	95 e0       	ldi	r25, 0x05	; 5
    cff8:	95 83       	std	Z+5, r25	; 0x05
    cffa:	84 83       	std	Z+4, r24	; 0x04
    cffc:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
		  lcd_print(3,1,lcdteks);RemSpaceLag(strLoyCurrentPoints);
    d000:	8d b7       	in	r24, 0x3d	; 61
    d002:	9e b7       	in	r25, 0x3e	; 62
    d004:	06 96       	adiw	r24, 0x06	; 6
    d006:	0f b6       	in	r0, 0x3f	; 63
    d008:	f8 94       	cli
    d00a:	9e bf       	out	0x3e, r25	; 62
    d00c:	0f be       	out	0x3f, r0	; 63
    d00e:	8d bf       	out	0x3d, r24	; 61
    d010:	83 e0       	ldi	r24, 0x03	; 3
    d012:	61 e0       	ldi	r22, 0x01	; 1
    d014:	a8 01       	movw	r20, r16
    d016:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
    d01a:	c7 01       	movw	r24, r14
    d01c:	0e 94 70 24 	call	0x48e0	; 0x48e0 <RemSpaceLag>
		  sprintf_P(lcdteks,PSTR("Cm Vol:%s"),strLoyCurrMonConsumeV);
    d020:	00 d0       	rcall	.+0      	; 0xd022 <FMenuLoyalty+0x3ec>
    d022:	00 d0       	rcall	.+0      	; 0xd024 <FMenuLoyalty+0x3ee>
    d024:	00 d0       	rcall	.+0      	; 0xd026 <FMenuLoyalty+0x3f0>
    d026:	ed b7       	in	r30, 0x3d	; 61
    d028:	fe b7       	in	r31, 0x3e	; 62
    d02a:	31 96       	adiw	r30, 0x01	; 1
    d02c:	ad b7       	in	r26, 0x3d	; 61
    d02e:	be b7       	in	r27, 0x3e	; 62
    d030:	12 96       	adiw	r26, 0x02	; 2
    d032:	1c 93       	st	X, r17
    d034:	0e 93       	st	-X, r16
    d036:	11 97       	sbiw	r26, 0x01	; 1
    d038:	85 e4       	ldi	r24, 0x45	; 69
    d03a:	9a e1       	ldi	r25, 0x1A	; 26
    d03c:	93 83       	std	Z+3, r25	; 0x03
    d03e:	82 83       	std	Z+2, r24	; 0x02
    d040:	88 ec       	ldi	r24, 0xC8	; 200
    d042:	9d e0       	ldi	r25, 0x0D	; 13
    d044:	95 83       	std	Z+5, r25	; 0x05
    d046:	84 83       	std	Z+4, r24	; 0x04
    d048:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
		  lcd_print(4,1,lcdteks);
    d04c:	8d b7       	in	r24, 0x3d	; 61
    d04e:	9e b7       	in	r25, 0x3e	; 62
    d050:	06 96       	adiw	r24, 0x06	; 6
    d052:	0f b6       	in	r0, 0x3f	; 63
    d054:	f8 94       	cli
    d056:	9e bf       	out	0x3e, r25	; 62
    d058:	0f be       	out	0x3f, r0	; 63
    d05a:	8d bf       	out	0x3d, r24	; 61
    d05c:	84 e0       	ldi	r24, 0x04	; 4
    d05e:	61 e0       	ldi	r22, 0x01	; 1
    d060:	a8 01       	movw	r20, r16
    d062:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
		  TimDisplay=0;
    d066:	10 92 a7 01 	sts	0x01A7, r1
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    d06a:	e1 99       	sbic	0x1c, 1	; 28
    d06c:	fe cf       	rjmp	.-4      	; 0xd06a <FMenuLoyalty+0x434>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    d06e:	88 e3       	ldi	r24, 0x38	; 56
    d070:	90 e0       	ldi	r25, 0x00	; 0
    d072:	9f bb       	out	0x1f, r25	; 31
    d074:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    d076:	e0 9a       	sbi	0x1c, 0	; 28
    d078:	8d b3       	in	r24, 0x1d	; 29

		  if (eeprom_read_byte(&DefNotifScreen)==1) {
    d07a:	81 30       	cpi	r24, 0x01	; 1
    d07c:	09 f0       	breq	.+2      	; 0xd080 <FMenuLoyalty+0x44a>
    d07e:	44 cf       	rjmp	.-376    	; 0xcf08 <FMenuLoyalty+0x2d2>
		      stLoyalty=mlPressAnyKey;
    d080:	8d e0       	ldi	r24, 0x0D	; 13
    d082:	80 93 4f 03 	sts	0x034F, r24
			  lcd_printf(2,1,PSTR("Press Any Key"));
    d086:	82 e0       	ldi	r24, 0x02	; 2
    d088:	61 e0       	ldi	r22, 0x01	; 1
    d08a:	47 e3       	ldi	r20, 0x37	; 55
    d08c:	5a e1       	ldi	r21, 0x1A	; 26
    d08e:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
    d092:	2a c0       	rjmp	.+84     	; 0xd0e8 <FMenuLoyalty+0x4b2>
          } else stLoyalty=mlDelayExitLoyalty;
		  break;
     case mlPressAnyKey:
	      KeyPressed=_key_scan(1);
    d094:	81 e0       	ldi	r24, 0x01	; 1
    d096:	0e 94 ab ae 	call	0x15d56	; 0x15d56 <_key_scan>
    d09a:	80 93 4e 03 	sts	0x034E, r24
	      KeyChar=_key_btn(KeyPressed);
    d09e:	0e 94 0c ae 	call	0x15c18	; 0x15c18 <_key_btn>
	      switch(KeyChar){		  
    d0a2:	83 32       	cpi	r24, 0x23	; 35
    d0a4:	c9 f0       	breq	.+50     	; 0xd0d8 <FMenuLoyalty+0x4a2>
    d0a6:	8a 32       	cpi	r24, 0x2A	; 42
    d0a8:	f9 f4       	brne	.+62     	; 0xd0e8 <FMenuLoyalty+0x4b2>
    d0aa:	16 c0       	rjmp	.+44     	; 0xd0d8 <FMenuLoyalty+0x4a2>
               stLoyalty=mlExitLoyalty;
		       break;		  
		  }
	      break;
     case mlNoConnection:
	      lcd_clear();
    d0ac:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
		  lcd_printf(2,1,PSTR("TCP/IP ERROR "));
    d0b0:	82 e0       	ldi	r24, 0x02	; 2
    d0b2:	61 e0       	ldi	r22, 0x01	; 1
    d0b4:	49 e2       	ldi	r20, 0x29	; 41
    d0b6:	5a e1       	ldi	r21, 0x1A	; 26
    d0b8:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		  lcd_printf(3,1,PSTR("No Connection"));
    d0bc:	83 e0       	ldi	r24, 0x03	; 3
    d0be:	61 e0       	ldi	r22, 0x01	; 1
    d0c0:	4b e1       	ldi	r20, 0x1B	; 27
    d0c2:	5a e1       	ldi	r21, 0x1A	; 26
    d0c4:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		  TimDisplay=5;
    d0c8:	85 e0       	ldi	r24, 0x05	; 5
    d0ca:	80 93 a7 01 	sts	0x01A7, r24
    d0ce:	1c cf       	rjmp	.-456    	; 0xcf08 <FMenuLoyalty+0x2d2>
		  stLoyalty=mlDelayExitLoyalty;
	      break;
     case mlDelayExitLoyalty:
          if(TimDisplay>=10)stLoyalty=mlExitLoyalty;
    d0d0:	80 91 a7 01 	lds	r24, 0x01A7
    d0d4:	8a 30       	cpi	r24, 0x0A	; 10
    d0d6:	40 f0       	brcs	.+16     	; 0xd0e8 <FMenuLoyalty+0x4b2>
    d0d8:	8f e0       	ldi	r24, 0x0F	; 15
    d0da:	18 ce       	rjmp	.-976    	; 0xcd0c <FMenuLoyalty+0xd6>
	      break;
	 case mlExitLoyalty:
	      lcd_clear();
    d0dc:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
	      stLoyalty=mlInit;
    d0e0:	10 92 4f 03 	sts	0x034F, r1
    d0e4:	81 e0       	ldi	r24, 0x01	; 1
    d0e6:	01 c0       	rjmp	.+2      	; 0xd0ea <FMenuLoyalty+0x4b4>
    d0e8:	80 e0       	ldi	r24, 0x00	; 0
		  Result=MENU_DONE;
	      break;
	 }
	 return Result;
}
    d0ea:	64 96       	adiw	r28, 0x14	; 20
    d0ec:	0f b6       	in	r0, 0x3f	; 63
    d0ee:	f8 94       	cli
    d0f0:	de bf       	out	0x3e, r29	; 62
    d0f2:	0f be       	out	0x3f, r0	; 63
    d0f4:	cd bf       	out	0x3d, r28	; 61
    d0f6:	cf 91       	pop	r28
    d0f8:	df 91       	pop	r29
    d0fa:	1f 91       	pop	r17
    d0fc:	0f 91       	pop	r16
    d0fe:	ff 90       	pop	r15
    d100:	ef 90       	pop	r14
    d102:	df 90       	pop	r13
    d104:	cf 90       	pop	r12
    d106:	08 95       	ret

0000d108 <ValidateRestoreCode>:
	     strKeyStamp[i]='0'+GeniusCalc(G_MULTY,(sSeed[i]-'0'),(sGCode[i]-'0'));		 
	 }strKeyStamp[strlen(sGCode)]=0;
     WrapCode(strKeyStamp);
}

char ValidateRestoreCode(char *sKeyStamp, char *sRestoreCode){//==RC_VALID
    d108:	ef 92       	push	r14
    d10a:	ff 92       	push	r15
    d10c:	0f 93       	push	r16
    d10e:	1f 93       	push	r17
    d110:	cf 93       	push	r28
    d112:	df 93       	push	r29
    d114:	ec 01       	movw	r28, r24
    d116:	7b 01       	movw	r14, r22

	 //  KeyStamp: [6]5585577 WrapCode6x
	 //sprintf_P(strSend,PSTR("KeyStamp:%s"),sKeyStamp);
	 //_uart_print(1,1,strSend);

	 nSum=sKeyStamp[0]-'0';
    d118:	08 81       	ld	r16, Y
    d11a:	00 53       	subi	r16, 0x30	; 48
    d11c:	10 e0       	ldi	r17, 0x00	; 0
    d11e:	04 c0       	rjmp	.+8      	; 0xd128 <ValidateRestoreCode+0x20>
	 for (i=0;i<nSum;i++){
         WrapCode(sKeyStamp);
    d120:	ce 01       	movw	r24, r28
    d122:	0e 94 11 2e 	call	0x5c22	; 0x5c22 <WrapCode>
	 //  KeyStamp: [6]5585577 WrapCode6x
	 //sprintf_P(strSend,PSTR("KeyStamp:%s"),sKeyStamp);
	 //_uart_print(1,1,strSend);

	 nSum=sKeyStamp[0]-'0';
	 for (i=0;i<nSum;i++){
    d126:	1f 5f       	subi	r17, 0xFF	; 255
    d128:	10 17       	cp	r17, r16
    d12a:	d0 f3       	brcs	.-12     	; 0xd120 <ValidateRestoreCode+0x18>
	 //_uart_print(1,1,strSend);
     
	 //sprintf_P(strSend,PSTR("WrapStamp:%s"),sRestoreCode);
	 //_uart_print(1,1,strSend);

	 if (strcmp(sKeyStamp,sRestoreCode)==0)
    d12c:	ce 01       	movw	r24, r28
    d12e:	b7 01       	movw	r22, r14
    d130:	0e 94 0f b4 	call	0x1681e	; 0x1681e <strcmp>
    d134:	00 97       	sbiw	r24, 0x00	; 0
    d136:	11 f0       	breq	.+4      	; 0xd13c <ValidateRestoreCode+0x34>
    d138:	82 e0       	ldi	r24, 0x02	; 2
    d13a:	01 c0       	rjmp	.+2      	; 0xd13e <ValidateRestoreCode+0x36>
    d13c:	81 e0       	ldi	r24, 0x01	; 1
	     Result=RC_VALID;	 
     else Result=RC_INVALID;

   return Result;
}
    d13e:	df 91       	pop	r29
    d140:	cf 91       	pop	r28
    d142:	1f 91       	pop	r17
    d144:	0f 91       	pop	r16
    d146:	ff 90       	pop	r15
    d148:	ef 90       	pop	r14
    d14a:	08 95       	ret

0000d14c <ValidateGeniusCode>:
          }
	 }sTemp[iAdd]=0;
	 sprintf_P(strSource,PSTR("%s"),sTemp);
}

char ValidateGeniusCode(char *sDate, char *sGenCode){//==GC_VALID
    d14c:	ef 92       	push	r14
    d14e:	ff 92       	push	r15
    d150:	0f 93       	push	r16
    d152:	1f 93       	push	r17
    d154:	df 93       	push	r29
    d156:	cf 93       	push	r28
    d158:	cd b7       	in	r28, 0x3d	; 61
    d15a:	de b7       	in	r29, 0x3e	; 62
    d15c:	2a 97       	sbiw	r28, 0x0a	; 10
    d15e:	0f b6       	in	r0, 0x3f	; 63
    d160:	f8 94       	cli
    d162:	de bf       	out	0x3e, r29	; 62
    d164:	0f be       	out	0x3f, r0	; 63
    d166:	cd bf       	out	0x3d, r28	; 61
    d168:	7b 01       	movw	r14, r22

         #ifdef DEBUG_GENIUS_CODE
		 sprintf_P(strSend,PSTR("[%s]"),sGenCode); 
         _uart_print(1,1,strSend);
		 #endif
	 if (strlen(sGenCode)==8){//Length musti  8
    d16a:	fb 01       	movw	r30, r22
    d16c:	01 90       	ld	r0, Z+
    d16e:	00 20       	and	r0, r0
    d170:	e9 f7       	brne	.-6      	; 0xd16c <ValidateGeniusCode+0x20>
    d172:	39 97       	sbiw	r30, 0x09	; 9
    d174:	e6 17       	cp	r30, r22
    d176:	f7 07       	cpc	r31, r23
    d178:	11 f0       	breq	.+4      	; 0xd17e <ValidateGeniusCode+0x32>
    d17a:	80 e0       	ldi	r24, 0x00	; 0
    d17c:	11 c0       	rjmp	.+34     	; 0xd1a0 <ValidateGeniusCode+0x54>
	     //sDate: 05012001		 
		 GenerateGeniusCode(sDate,sGenCode[0],sAutoGen);
    d17e:	fb 01       	movw	r30, r22
    d180:	60 81       	ld	r22, Z
    d182:	8e 01       	movw	r16, r28
    d184:	0f 5f       	subi	r16, 0xFF	; 255
    d186:	1f 4f       	sbci	r17, 0xFF	; 255
    d188:	a8 01       	movw	r20, r16
    d18a:	0e 94 0f 2f 	call	0x5e1e	; 0x5e1e <GenerateGeniusCode>
         #ifdef DEBUG_GENIUS_CODE
		 sprintf_P(strSend,PSTR("%s|%s"),sAutoGen,sGenCode); 
         _uart_print(1,1,strSend);
		 #endif

         if (strcmp(sAutoGen,sGenCode)==0)
    d18e:	c8 01       	movw	r24, r16
    d190:	b7 01       	movw	r22, r14
    d192:	0e 94 0f b4 	call	0x1681e	; 0x1681e <strcmp>
    d196:	00 97       	sbiw	r24, 0x00	; 0
    d198:	11 f0       	breq	.+4      	; 0xd19e <ValidateGeniusCode+0x52>
    d19a:	82 e0       	ldi	r24, 0x02	; 2
    d19c:	01 c0       	rjmp	.+2      	; 0xd1a0 <ValidateGeniusCode+0x54>
    d19e:	81 e0       	ldi	r24, 0x01	; 1
         else Result=GC_INVALID;
	 }


   return Result;
}
    d1a0:	2a 96       	adiw	r28, 0x0a	; 10
    d1a2:	0f b6       	in	r0, 0x3f	; 63
    d1a4:	f8 94       	cli
    d1a6:	de bf       	out	0x3e, r29	; 62
    d1a8:	0f be       	out	0x3f, r0	; 63
    d1aa:	cd bf       	out	0x3d, r28	; 61
    d1ac:	cf 91       	pop	r28
    d1ae:	df 91       	pop	r29
    d1b0:	1f 91       	pop	r17
    d1b2:	0f 91       	pop	r16
    d1b4:	ff 90       	pop	r15
    d1b6:	ef 90       	pop	r14
    d1b8:	08 95       	ret

0000d1ba <FMenuSettingServerIP>:
		       break;     
		  }//EndSwitch	 
    return Result;
}

char FMenuSettingServerIP(){
    d1ba:	0f 93       	push	r16
    d1bc:	1f 93       	push	r17
    d1be:	df 93       	push	r29
    d1c0:	cf 93       	push	r28
    d1c2:	cd b7       	in	r28, 0x3d	; 61
    d1c4:	de b7       	in	r29, 0x3e	; 62
    d1c6:	64 97       	sbiw	r28, 0x14	; 20
    d1c8:	0f b6       	in	r0, 0x3f	; 63
    d1ca:	f8 94       	cli
    d1cc:	de bf       	out	0x3e, r29	; 62
    d1ce:	0f be       	out	0x3f, r0	; 63
    d1d0:	cd bf       	out	0x3d, r28	; 61
     //Server IP
     //Old: 192.168.123.000
	 //New:   _.   .   .
	 //--------------------
	 //*)cancel    #)next
	 Result=MENU_NONE;
    d1d2:	10 92 01 03 	sts	0x0301, r1
     switch(stClientIP){
    d1d6:	80 91 58 01 	lds	r24, 0x0158
    d1da:	82 30       	cpi	r24, 0x02	; 2
    d1dc:	09 f4       	brne	.+2      	; 0xd1e0 <FMenuSettingServerIP+0x26>
    d1de:	7b c0       	rjmp	.+246    	; 0xd2d6 <FMenuSettingServerIP+0x11c>
    d1e0:	83 30       	cpi	r24, 0x03	; 3
    d1e2:	20 f4       	brcc	.+8      	; 0xd1ec <FMenuSettingServerIP+0x32>
    d1e4:	81 30       	cpi	r24, 0x01	; 1
    d1e6:	09 f0       	breq	.+2      	; 0xd1ea <FMenuSettingServerIP+0x30>
    d1e8:	65 c2       	rjmp	.+1226   	; 0xd6b4 <FMenuSettingServerIP+0x4fa>
    d1ea:	07 c0       	rjmp	.+14     	; 0xd1fa <FMenuSettingServerIP+0x40>
    d1ec:	83 30       	cpi	r24, 0x03	; 3
    d1ee:	09 f4       	brne	.+2      	; 0xd1f2 <FMenuSettingServerIP+0x38>
    d1f0:	5c c2       	rjmp	.+1208   	; 0xd6aa <FMenuSettingServerIP+0x4f0>
    d1f2:	84 30       	cpi	r24, 0x04	; 4
    d1f4:	09 f0       	breq	.+2      	; 0xd1f8 <FMenuSettingServerIP+0x3e>
    d1f6:	5e c2       	rjmp	.+1212   	; 0xd6b4 <FMenuSettingServerIP+0x4fa>
    d1f8:	4a c2       	rjmp	.+1172   	; 0xd68e <FMenuSettingServerIP+0x4d4>
		  case cipInit:
			   lcd_clear();
    d1fa:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
	           lcd_printf(1,1,PSTR("Server IP"));
    d1fe:	81 e0       	ldi	r24, 0x01	; 1
    d200:	61 e0       	ldi	r22, 0x01	; 1
    d202:	43 e0       	ldi	r20, 0x03	; 3
    d204:	53 e1       	ldi	r21, 0x13	; 19
    d206:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    d20a:	88 ef       	ldi	r24, 0xF8	; 248
    d20c:	92 e0       	ldi	r25, 0x02	; 2
    d20e:	6c e2       	ldi	r22, 0x2C	; 44
    d210:	70 e0       	ldi	r23, 0x00	; 0
    d212:	44 e0       	ldi	r20, 0x04	; 4
    d214:	50 e0       	ldi	r21, 0x00	; 0
    d216:	23 ef       	ldi	r18, 0xF3	; 243
    d218:	32 e1       	ldi	r19, 0x12	; 18
    d21a:	0e 94 1f b4 	call	0x1683e	; 0x1683e <__eerd_block>
			   eeprom_read_block((void*)&IP_blok,(const void*)&DefServerIP,4);
	           sprintf_P(lcdteks,PSTR("Old: %d.%d.%d.%d"),IP_blok[0],IP_blok[1],IP_blok[2],IP_blok[3]);
    d21e:	8d b7       	in	r24, 0x3d	; 61
    d220:	9e b7       	in	r25, 0x3e	; 62
    d222:	0c 97       	sbiw	r24, 0x0c	; 12
    d224:	0f b6       	in	r0, 0x3f	; 63
    d226:	f8 94       	cli
    d228:	9e bf       	out	0x3e, r25	; 62
    d22a:	0f be       	out	0x3f, r0	; 63
    d22c:	8d bf       	out	0x3d, r24	; 61
    d22e:	ed b7       	in	r30, 0x3d	; 61
    d230:	fe b7       	in	r31, 0x3e	; 62
    d232:	31 96       	adiw	r30, 0x01	; 1
    d234:	8e 01       	movw	r16, r28
    d236:	0f 5f       	subi	r16, 0xFF	; 255
    d238:	1f 4f       	sbci	r17, 0xFF	; 255
    d23a:	ad b7       	in	r26, 0x3d	; 61
    d23c:	be b7       	in	r27, 0x3e	; 62
    d23e:	12 96       	adiw	r26, 0x02	; 2
    d240:	1c 93       	st	X, r17
    d242:	0e 93       	st	-X, r16
    d244:	11 97       	sbiw	r26, 0x01	; 1
    d246:	82 ef       	ldi	r24, 0xF2	; 242
    d248:	92 e1       	ldi	r25, 0x12	; 18
    d24a:	93 83       	std	Z+3, r25	; 0x03
    d24c:	82 83       	std	Z+2, r24	; 0x02
    d24e:	80 91 f8 02 	lds	r24, 0x02F8
    d252:	84 83       	std	Z+4, r24	; 0x04
    d254:	15 82       	std	Z+5, r1	; 0x05
    d256:	80 91 f9 02 	lds	r24, 0x02F9
    d25a:	86 83       	std	Z+6, r24	; 0x06
    d25c:	17 82       	std	Z+7, r1	; 0x07
    d25e:	80 91 fa 02 	lds	r24, 0x02FA
    d262:	80 87       	std	Z+8, r24	; 0x08
    d264:	11 86       	std	Z+9, r1	; 0x09
    d266:	80 91 fb 02 	lds	r24, 0x02FB
    d26a:	82 87       	std	Z+10, r24	; 0x0a
    d26c:	13 86       	std	Z+11, r1	; 0x0b
    d26e:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
	           lcd_print(2,1,lcdteks);
    d272:	ed b7       	in	r30, 0x3d	; 61
    d274:	fe b7       	in	r31, 0x3e	; 62
    d276:	3c 96       	adiw	r30, 0x0c	; 12
    d278:	0f b6       	in	r0, 0x3f	; 63
    d27a:	f8 94       	cli
    d27c:	fe bf       	out	0x3e, r31	; 62
    d27e:	0f be       	out	0x3f, r0	; 63
    d280:	ed bf       	out	0x3d, r30	; 61
    d282:	82 e0       	ldi	r24, 0x02	; 2
    d284:	61 e0       	ldi	r22, 0x01	; 1
    d286:	a8 01       	movw	r20, r16
    d288:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
			   lcd_printf(3,1,PSTR("New:   _.   .   .   "));
    d28c:	83 e0       	ldi	r24, 0x03	; 3
    d28e:	61 e0       	ldi	r22, 0x01	; 1
    d290:	4d ed       	ldi	r20, 0xDD	; 221
    d292:	52 e1       	ldi	r21, 0x12	; 18
    d294:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
			   lcd_printf(4,1,PSTR("[*]cancel  [#]next  "));
    d298:	84 e0       	ldi	r24, 0x04	; 4
    d29a:	61 e0       	ldi	r22, 0x01	; 1
    d29c:	48 ec       	ldi	r20, 0xC8	; 200
    d29e:	52 e1       	ldi	r21, 0x12	; 18
    d2a0:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
               iLoop=0;
    d2a4:	10 92 f7 02 	sts	0x02F7, r1
    d2a8:	10 92 f6 02 	sts	0x02F6, r1
			   y=3,x=8;
    d2ac:	83 e0       	ldi	r24, 0x03	; 3
    d2ae:	80 93 fe 02 	sts	0x02FE, r24
    d2b2:	88 e0       	ldi	r24, 0x08	; 8
    d2b4:	80 93 ff 02 	sts	0x02FF, r24
			   iInput=0; iBlok=0;
    d2b8:	10 92 fd 02 	sts	0x02FD, r1
    d2bc:	10 92 f5 02 	sts	0x02F5, r1
    d2c0:	10 92 f4 02 	sts	0x02F4, r1
			   IPchar[0]='0';IPchar[1]='0';IPchar[2]='0';
    d2c4:	80 e3       	ldi	r24, 0x30	; 48
    d2c6:	80 93 03 03 	sts	0x0303, r24
    d2ca:	80 93 04 03 	sts	0x0304, r24
    d2ce:	80 93 05 03 	sts	0x0305, r24
			   stClientIP=cipInputIP; 
    d2d2:	82 e0       	ldi	r24, 0x02	; 2
    d2d4:	e7 c1       	rjmp	.+974    	; 0xd6a4 <FMenuSettingServerIP+0x4ea>
		       break;
          case cipInputIP:
			   //Blinking 60% _ 
			   iLoop++;
    d2d6:	80 91 f6 02 	lds	r24, 0x02F6
    d2da:	90 91 f7 02 	lds	r25, 0x02F7
    d2de:	01 96       	adiw	r24, 0x01	; 1
    d2e0:	90 93 f7 02 	sts	0x02F7, r25
    d2e4:	80 93 f6 02 	sts	0x02F6, r24
			   if ((iLoop%2000)==0){
    d2e8:	60 ed       	ldi	r22, 0xD0	; 208
    d2ea:	77 e0       	ldi	r23, 0x07	; 7
    d2ec:	0e 94 38 b7 	call	0x16e70	; 0x16e70 <__udivmodhi4>
    d2f0:	89 2b       	or	r24, r25
    d2f2:	81 f4       	brne	.+32     	; 0xd314 <FMenuSettingServerIP+0x15a>
			      lcd_put(y,(x+(iBlok*4)),'_'); 
    d2f4:	80 91 f4 02 	lds	r24, 0x02F4
    d2f8:	90 91 f5 02 	lds	r25, 0x02F5
    d2fc:	88 0f       	add	r24, r24
    d2fe:	99 1f       	adc	r25, r25
    d300:	88 0f       	add	r24, r24
    d302:	99 1f       	adc	r25, r25
    d304:	60 91 ff 02 	lds	r22, 0x02FF
    d308:	68 0f       	add	r22, r24
    d30a:	80 91 fe 02 	lds	r24, 0x02FE
    d30e:	4f e5       	ldi	r20, 0x5F	; 95
    d310:	0e 94 7f ad 	call	0x15afe	; 0x15afe <lcd_put>
			   }
			   if ((iLoop%2000)==1000){
    d314:	80 91 f6 02 	lds	r24, 0x02F6
    d318:	90 91 f7 02 	lds	r25, 0x02F7
    d31c:	60 ed       	ldi	r22, 0xD0	; 208
    d31e:	77 e0       	ldi	r23, 0x07	; 7
    d320:	0e 94 38 b7 	call	0x16e70	; 0x16e70 <__udivmodhi4>
    d324:	88 5e       	subi	r24, 0xE8	; 232
    d326:	93 40       	sbci	r25, 0x03	; 3
    d328:	81 f4       	brne	.+32     	; 0xd34a <FMenuSettingServerIP+0x190>
			      lcd_put(y,(x+(iBlok*4)),' '); 
    d32a:	80 91 f4 02 	lds	r24, 0x02F4
    d32e:	90 91 f5 02 	lds	r25, 0x02F5
    d332:	88 0f       	add	r24, r24
    d334:	99 1f       	adc	r25, r25
    d336:	88 0f       	add	r24, r24
    d338:	99 1f       	adc	r25, r25
    d33a:	60 91 ff 02 	lds	r22, 0x02FF
    d33e:	68 0f       	add	r22, r24
    d340:	80 91 fe 02 	lds	r24, 0x02FE
    d344:	40 e2       	ldi	r20, 0x20	; 32
    d346:	0e 94 7f ad 	call	0x15afe	; 0x15afe <lcd_put>
			   }
			   //GetKeyPressed
			   keyPressed=_key_scan(1);
    d34a:	81 e0       	ldi	r24, 0x01	; 1
    d34c:	0e 94 ab ae 	call	0x15d56	; 0x15d56 <_key_scan>
    d350:	80 93 fc 02 	sts	0x02FC, r24
			   keyChar=_key_btn(keyPressed);
    d354:	0e 94 0c ae 	call	0x15c18	; 0x15c18 <_key_btn>
    d358:	28 2f       	mov	r18, r24
    d35a:	80 93 00 03 	sts	0x0300, r24
               if ((keyChar>='0')&&(keyChar<='9')){
    d35e:	80 53       	subi	r24, 0x30	; 48
    d360:	8a 30       	cpi	r24, 0x0A	; 10
    d362:	08 f0       	brcs	.+2      	; 0xd366 <FMenuSettingServerIP+0x1ac>
    d364:	d6 c0       	rjmp	.+428    	; 0xd512 <FMenuSettingServerIP+0x358>
    d366:	80 e5       	ldi	r24, 0x50	; 80
    d368:	93 ec       	ldi	r25, 0xC3	; 195
    d36a:	01 97       	sbiw	r24, 0x01	; 1
    d36c:	f1 f7       	brne	.-4      	; 0xd36a <FMenuSettingServerIP+0x1b0>
			       _delay_ms(200);
			       IPchar[iInput]=keyChar;
    d36e:	80 91 fd 02 	lds	r24, 0x02FD
    d372:	e8 2f       	mov	r30, r24
    d374:	f0 e0       	ldi	r31, 0x00	; 0
    d376:	ed 5f       	subi	r30, 0xFD	; 253
    d378:	fc 4f       	sbci	r31, 0xFC	; 252
    d37a:	20 83       	st	Z, r18
				   iInput++;                    
    d37c:	8f 5f       	subi	r24, 0xFF	; 255
    d37e:	80 93 fd 02 	sts	0x02FD, r24
				   for (i=1;i<(iInput+1);i++){
    d382:	81 e0       	ldi	r24, 0x01	; 1
    d384:	1c c0       	rjmp	.+56     	; 0xd3be <FMenuSettingServerIP+0x204>
				       lcd_xy(y,((x+(iBlok*4))-(3-i)));_lcd(IPchar[i-1]);
    d386:	80 91 ff 02 	lds	r24, 0x02FF
    d38a:	68 0f       	add	r22, r24
    d38c:	63 50       	subi	r22, 0x03	; 3
    d38e:	80 91 f4 02 	lds	r24, 0x02F4
    d392:	90 91 f5 02 	lds	r25, 0x02F5
    d396:	88 0f       	add	r24, r24
    d398:	99 1f       	adc	r25, r25
    d39a:	88 0f       	add	r24, r24
    d39c:	99 1f       	adc	r25, r25
    d39e:	68 0f       	add	r22, r24
    d3a0:	80 91 fe 02 	lds	r24, 0x02FE
    d3a4:	0e 94 f1 ac 	call	0x159e2	; 0x159e2 <lcd_xy>
    d3a8:	e0 91 02 03 	lds	r30, 0x0302
    d3ac:	f0 e0       	ldi	r31, 0x00	; 0
    d3ae:	ee 5f       	subi	r30, 0xFE	; 254
    d3b0:	fc 4f       	sbci	r31, 0xFC	; 252
    d3b2:	80 81       	ld	r24, Z
    d3b4:	0e 94 cb ac 	call	0x15996	; 0x15996 <_lcd>
			   keyChar=_key_btn(keyPressed);
               if ((keyChar>='0')&&(keyChar<='9')){
			       _delay_ms(200);
			       IPchar[iInput]=keyChar;
				   iInput++;                    
				   for (i=1;i<(iInput+1);i++){
    d3b8:	80 91 02 03 	lds	r24, 0x0302
    d3bc:	8f 5f       	subi	r24, 0xFF	; 255
    d3be:	80 93 02 03 	sts	0x0302, r24
    d3c2:	70 91 fd 02 	lds	r23, 0x02FD
    d3c6:	60 91 02 03 	lds	r22, 0x0302
    d3ca:	27 2f       	mov	r18, r23
    d3cc:	30 e0       	ldi	r19, 0x00	; 0
    d3ce:	86 2f       	mov	r24, r22
    d3d0:	90 e0       	ldi	r25, 0x00	; 0
    d3d2:	28 17       	cp	r18, r24
    d3d4:	39 07       	cpc	r19, r25
    d3d6:	bc f6       	brge	.-82     	; 0xd386 <FMenuSettingServerIP+0x1cc>
				       lcd_xy(y,((x+(iBlok*4))-(3-i)));_lcd(IPchar[i-1]);
				   }
                   //NextInput
				   if (iInput>=3){
    d3d8:	73 30       	cpi	r23, 0x03	; 3
    d3da:	08 f4       	brcc	.+2      	; 0xd3de <FMenuSettingServerIP+0x224>
    d3dc:	91 c0       	rjmp	.+290    	; 0xd500 <FMenuSettingServerIP+0x346>
				       IP_blok[iBlok]=((IPchar[0]-'0')*100)+((IPchar[1]-'0')*10)+((IPchar[2]-'0'));
    d3de:	40 91 f4 02 	lds	r20, 0x02F4
    d3e2:	50 91 f5 02 	lds	r21, 0x02F5
    d3e6:	fa 01       	movw	r30, r20
    d3e8:	e8 50       	subi	r30, 0x08	; 8
    d3ea:	fd 4f       	sbci	r31, 0xFD	; 253
    d3ec:	20 91 05 03 	lds	r18, 0x0305
    d3f0:	20 5d       	subi	r18, 0xD0	; 208
    d3f2:	80 91 03 03 	lds	r24, 0x0303
    d3f6:	34 e6       	ldi	r19, 0x64	; 100
    d3f8:	83 9f       	mul	r24, r19
    d3fa:	c0 01       	movw	r24, r0
    d3fc:	11 24       	eor	r1, r1
    d3fe:	28 0f       	add	r18, r24
    d400:	80 91 04 03 	lds	r24, 0x0304
    d404:	3a e0       	ldi	r19, 0x0A	; 10
    d406:	83 9f       	mul	r24, r19
    d408:	c0 01       	movw	r24, r0
    d40a:	11 24       	eor	r1, r1
    d40c:	28 0f       	add	r18, r24
    d40e:	20 83       	st	Z, r18
					   IPchar[0]='0';IPchar[1]='0';IPchar[2]='0';
    d410:	80 e3       	ldi	r24, 0x30	; 48
    d412:	80 93 03 03 	sts	0x0303, r24
    d416:	80 93 04 03 	sts	0x0304, r24
    d41a:	80 93 05 03 	sts	0x0305, r24
					   //Reposition Value
					   lcd_printf(y,((x+(iBlok*4))-iInput),PSTR("   "));
    d41e:	44 0f       	add	r20, r20
    d420:	55 1f       	adc	r21, r21
    d422:	44 0f       	add	r20, r20
    d424:	55 1f       	adc	r21, r21
    d426:	60 91 ff 02 	lds	r22, 0x02FF
    d42a:	64 0f       	add	r22, r20
    d42c:	67 1b       	sub	r22, r23
    d42e:	80 91 fe 02 	lds	r24, 0x02FE
    d432:	44 ec       	ldi	r20, 0xC4	; 196
    d434:	52 e1       	ldi	r21, 0x12	; 18
    d436:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
					   sprintf_P(lcdteks,PSTR("%d"),IP_blok[iBlok]);
    d43a:	00 d0       	rcall	.+0      	; 0xd43c <FMenuSettingServerIP+0x282>
    d43c:	00 d0       	rcall	.+0      	; 0xd43e <FMenuSettingServerIP+0x284>
    d43e:	00 d0       	rcall	.+0      	; 0xd440 <FMenuSettingServerIP+0x286>
    d440:	ad b7       	in	r26, 0x3d	; 61
    d442:	be b7       	in	r27, 0x3e	; 62
    d444:	11 96       	adiw	r26, 0x01	; 1
    d446:	8e 01       	movw	r16, r28
    d448:	0f 5f       	subi	r16, 0xFF	; 255
    d44a:	1f 4f       	sbci	r17, 0xFF	; 255
    d44c:	ed b7       	in	r30, 0x3d	; 61
    d44e:	fe b7       	in	r31, 0x3e	; 62
    d450:	12 83       	std	Z+2, r17	; 0x02
    d452:	01 83       	std	Z+1, r16	; 0x01
    d454:	81 ec       	ldi	r24, 0xC1	; 193
    d456:	92 e1       	ldi	r25, 0x12	; 18
    d458:	13 96       	adiw	r26, 0x03	; 3
    d45a:	9c 93       	st	X, r25
    d45c:	8e 93       	st	-X, r24
    d45e:	12 97       	sbiw	r26, 0x02	; 2
    d460:	e0 91 f4 02 	lds	r30, 0x02F4
    d464:	f0 91 f5 02 	lds	r31, 0x02F5
    d468:	e8 50       	subi	r30, 0x08	; 8
    d46a:	fd 4f       	sbci	r31, 0xFD	; 253
    d46c:	80 81       	ld	r24, Z
    d46e:	14 96       	adiw	r26, 0x04	; 4
    d470:	8c 93       	st	X, r24
    d472:	14 97       	sbiw	r26, 0x04	; 4
    d474:	15 96       	adiw	r26, 0x05	; 5
    d476:	1c 92       	st	X, r1
    d478:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
                       lcd_print(y,1+((x+(iBlok*4))-strlen(lcdteks)),lcdteks);
    d47c:	f8 01       	movw	r30, r16
    d47e:	01 90       	ld	r0, Z+
    d480:	00 20       	and	r0, r0
    d482:	e9 f7       	brne	.-6      	; 0xd47e <FMenuSettingServerIP+0x2c4>
    d484:	31 97       	sbiw	r30, 0x01	; 1
    d486:	e0 1b       	sub	r30, r16
    d488:	f1 0b       	sbc	r31, r17
    d48a:	8d b7       	in	r24, 0x3d	; 61
    d48c:	9e b7       	in	r25, 0x3e	; 62
    d48e:	06 96       	adiw	r24, 0x06	; 6
    d490:	0f b6       	in	r0, 0x3f	; 63
    d492:	f8 94       	cli
    d494:	9e bf       	out	0x3e, r25	; 62
    d496:	0f be       	out	0x3f, r0	; 63
    d498:	8d bf       	out	0x3d, r24	; 61
    d49a:	60 91 ff 02 	lds	r22, 0x02FF
    d49e:	6f 5f       	subi	r22, 0xFF	; 255
    d4a0:	80 91 f4 02 	lds	r24, 0x02F4
    d4a4:	90 91 f5 02 	lds	r25, 0x02F5
    d4a8:	88 0f       	add	r24, r24
    d4aa:	99 1f       	adc	r25, r25
    d4ac:	88 0f       	add	r24, r24
    d4ae:	99 1f       	adc	r25, r25
    d4b0:	68 0f       	add	r22, r24
    d4b2:	6e 1b       	sub	r22, r30
    d4b4:	80 91 fe 02 	lds	r24, 0x02FE
    d4b8:	a8 01       	movw	r20, r16
    d4ba:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
					   if (iBlok>0)lcd_printf(y,1+((x+((iBlok-1)*4))),PSTR("."));
    d4be:	80 91 f4 02 	lds	r24, 0x02F4
    d4c2:	90 91 f5 02 	lds	r25, 0x02F5
    d4c6:	00 97       	sbiw	r24, 0x00	; 0
    d4c8:	81 f0       	breq	.+32     	; 0xd4ea <FMenuSettingServerIP+0x330>
    d4ca:	60 91 ff 02 	lds	r22, 0x02FF
    d4ce:	6f 5f       	subi	r22, 0xFF	; 255
    d4d0:	81 50       	subi	r24, 0x01	; 1
    d4d2:	90 4c       	sbci	r25, 0xC0	; 192
    d4d4:	88 0f       	add	r24, r24
    d4d6:	99 1f       	adc	r25, r25
    d4d8:	88 0f       	add	r24, r24
    d4da:	99 1f       	adc	r25, r25
    d4dc:	68 0f       	add	r22, r24
    d4de:	80 91 fe 02 	lds	r24, 0x02FE
    d4e2:	4f eb       	ldi	r20, 0xBF	; 191
    d4e4:	52 e1       	ldi	r21, 0x12	; 18
    d4e6:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
					   iInput=0;
    d4ea:	10 92 fd 02 	sts	0x02FD, r1
					   iBlok++;
    d4ee:	80 91 f4 02 	lds	r24, 0x02F4
    d4f2:	90 91 f5 02 	lds	r25, 0x02F5
    d4f6:	01 96       	adiw	r24, 0x01	; 1
    d4f8:	90 93 f5 02 	sts	0x02F5, r25
    d4fc:	80 93 f4 02 	sts	0x02F4, r24

				   }
				   if (iBlok>=4)stClientIP=cipStoreIPblok;
    d500:	80 91 f4 02 	lds	r24, 0x02F4
    d504:	90 91 f5 02 	lds	r25, 0x02F5
    d508:	04 97       	sbiw	r24, 0x04	; 4
    d50a:	18 f0       	brcs	.+6      	; 0xd512 <FMenuSettingServerIP+0x358>
    d50c:	84 e0       	ldi	r24, 0x04	; 4
    d50e:	80 93 58 01 	sts	0x0158, r24
			   }

			   if (keyPressed==_KEY_CANCEL){
    d512:	80 91 fc 02 	lds	r24, 0x02FC
    d516:	87 3e       	cpi	r24, 0xE7	; 231
    d518:	09 f4       	brne	.+2      	; 0xd51c <FMenuSettingServerIP+0x362>
    d51a:	c3 c0       	rjmp	.+390    	; 0xd6a2 <FMenuSettingServerIP+0x4e8>
			       stClientIP=cipExit; 
			   }
			   else
			   if (keyPressed==_KEY_ENTER){
    d51c:	87 3b       	cpi	r24, 0xB7	; 183
    d51e:	09 f0       	breq	.+2      	; 0xd522 <FMenuSettingServerIP+0x368>
    d520:	c9 c0       	rjmp	.+402    	; 0xd6b4 <FMenuSettingServerIP+0x4fa>
			       //NextInput
			       if (iBlok<4){
    d522:	40 91 f4 02 	lds	r20, 0x02F4
    d526:	50 91 f5 02 	lds	r21, 0x02F5
    d52a:	44 30       	cpi	r20, 0x04	; 4
    d52c:	51 05       	cpc	r21, r1
    d52e:	08 f0       	brcs	.+2      	; 0xd532 <FMenuSettingServerIP+0x378>
    d530:	a6 c0       	rjmp	.+332    	; 0xd67e <FMenuSettingServerIP+0x4c4>
				       if (iInput==1)IP_blok[iBlok]=((IPchar[0]-'0'));
    d532:	80 91 fd 02 	lds	r24, 0x02FD
    d536:	81 30       	cpi	r24, 0x01	; 1
    d538:	41 f4       	brne	.+16     	; 0xd54a <FMenuSettingServerIP+0x390>
    d53a:	fa 01       	movw	r30, r20
    d53c:	e8 50       	subi	r30, 0x08	; 8
    d53e:	fd 4f       	sbci	r31, 0xFD	; 253
    d540:	80 91 03 03 	lds	r24, 0x0303
    d544:	80 53       	subi	r24, 0x30	; 48
    d546:	80 83       	st	Z, r24
    d548:	22 c0       	rjmp	.+68     	; 0xd58e <FMenuSettingServerIP+0x3d4>
					   if (iInput==2)IP_blok[iBlok]=((IPchar[0]-'0')*10)+(IPchar[1]-'0');
    d54a:	82 30       	cpi	r24, 0x02	; 2
    d54c:	49 f4       	brne	.+18     	; 0xd560 <FMenuSettingServerIP+0x3a6>
    d54e:	fa 01       	movw	r30, r20
    d550:	e8 50       	subi	r30, 0x08	; 8
    d552:	fd 4f       	sbci	r31, 0xFD	; 253
    d554:	20 91 04 03 	lds	r18, 0x0304
    d558:	20 51       	subi	r18, 0x10	; 16
    d55a:	80 91 03 03 	lds	r24, 0x0303
    d55e:	11 c0       	rjmp	.+34     	; 0xd582 <FMenuSettingServerIP+0x3c8>
					   if (iInput==3)IP_blok[iBlok]=((IPchar[0]-'0')*100)+((IPchar[1]-'0')*10)+((IPchar[2]-'0'));
    d560:	83 30       	cpi	r24, 0x03	; 3
    d562:	a9 f4       	brne	.+42     	; 0xd58e <FMenuSettingServerIP+0x3d4>
    d564:	fa 01       	movw	r30, r20
    d566:	e8 50       	subi	r30, 0x08	; 8
    d568:	fd 4f       	sbci	r31, 0xFD	; 253
    d56a:	20 91 05 03 	lds	r18, 0x0305
    d56e:	20 5d       	subi	r18, 0xD0	; 208
    d570:	80 91 03 03 	lds	r24, 0x0303
    d574:	34 e6       	ldi	r19, 0x64	; 100
    d576:	83 9f       	mul	r24, r19
    d578:	c0 01       	movw	r24, r0
    d57a:	11 24       	eor	r1, r1
    d57c:	28 0f       	add	r18, r24
    d57e:	80 91 04 03 	lds	r24, 0x0304
    d582:	3a e0       	ldi	r19, 0x0A	; 10
    d584:	83 9f       	mul	r24, r19
    d586:	c0 01       	movw	r24, r0
    d588:	11 24       	eor	r1, r1
    d58a:	28 0f       	add	r18, r24
    d58c:	20 83       	st	Z, r18
				       
					   IPchar[0]='0';IPchar[1]='0';IPchar[2]='0';
    d58e:	80 e3       	ldi	r24, 0x30	; 48
    d590:	80 93 03 03 	sts	0x0303, r24
    d594:	80 93 04 03 	sts	0x0304, r24
    d598:	80 93 05 03 	sts	0x0305, r24
					   //Reposition Value
					   lcd_printf(y,((x+(iBlok*4))-3),PSTR("   "));
    d59c:	60 91 ff 02 	lds	r22, 0x02FF
    d5a0:	63 50       	subi	r22, 0x03	; 3
    d5a2:	44 0f       	add	r20, r20
    d5a4:	55 1f       	adc	r21, r21
    d5a6:	44 0f       	add	r20, r20
    d5a8:	55 1f       	adc	r21, r21
    d5aa:	64 0f       	add	r22, r20
    d5ac:	80 91 fe 02 	lds	r24, 0x02FE
    d5b0:	4b eb       	ldi	r20, 0xBB	; 187
    d5b2:	52 e1       	ldi	r21, 0x12	; 18
    d5b4:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
					   sprintf_P(lcdteks,PSTR("%d"),IP_blok[iBlok]);
    d5b8:	00 d0       	rcall	.+0      	; 0xd5ba <FMenuSettingServerIP+0x400>
    d5ba:	00 d0       	rcall	.+0      	; 0xd5bc <FMenuSettingServerIP+0x402>
    d5bc:	00 d0       	rcall	.+0      	; 0xd5be <FMenuSettingServerIP+0x404>
    d5be:	ad b7       	in	r26, 0x3d	; 61
    d5c0:	be b7       	in	r27, 0x3e	; 62
    d5c2:	11 96       	adiw	r26, 0x01	; 1
    d5c4:	8e 01       	movw	r16, r28
    d5c6:	0f 5f       	subi	r16, 0xFF	; 255
    d5c8:	1f 4f       	sbci	r17, 0xFF	; 255
    d5ca:	ed b7       	in	r30, 0x3d	; 61
    d5cc:	fe b7       	in	r31, 0x3e	; 62
    d5ce:	12 83       	std	Z+2, r17	; 0x02
    d5d0:	01 83       	std	Z+1, r16	; 0x01
    d5d2:	88 eb       	ldi	r24, 0xB8	; 184
    d5d4:	92 e1       	ldi	r25, 0x12	; 18
    d5d6:	13 96       	adiw	r26, 0x03	; 3
    d5d8:	9c 93       	st	X, r25
    d5da:	8e 93       	st	-X, r24
    d5dc:	12 97       	sbiw	r26, 0x02	; 2
    d5de:	e0 91 f4 02 	lds	r30, 0x02F4
    d5e2:	f0 91 f5 02 	lds	r31, 0x02F5
    d5e6:	e8 50       	subi	r30, 0x08	; 8
    d5e8:	fd 4f       	sbci	r31, 0xFD	; 253
    d5ea:	80 81       	ld	r24, Z
    d5ec:	14 96       	adiw	r26, 0x04	; 4
    d5ee:	8c 93       	st	X, r24
    d5f0:	14 97       	sbiw	r26, 0x04	; 4
    d5f2:	15 96       	adiw	r26, 0x05	; 5
    d5f4:	1c 92       	st	X, r1
    d5f6:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
                       lcd_print(y,1+((x+(iBlok*4))-strlen(lcdteks)),lcdteks);
    d5fa:	f8 01       	movw	r30, r16
    d5fc:	01 90       	ld	r0, Z+
    d5fe:	00 20       	and	r0, r0
    d600:	e9 f7       	brne	.-6      	; 0xd5fc <FMenuSettingServerIP+0x442>
    d602:	31 97       	sbiw	r30, 0x01	; 1
    d604:	e0 1b       	sub	r30, r16
    d606:	f1 0b       	sbc	r31, r17
    d608:	8d b7       	in	r24, 0x3d	; 61
    d60a:	9e b7       	in	r25, 0x3e	; 62
    d60c:	06 96       	adiw	r24, 0x06	; 6
    d60e:	0f b6       	in	r0, 0x3f	; 63
    d610:	f8 94       	cli
    d612:	9e bf       	out	0x3e, r25	; 62
    d614:	0f be       	out	0x3f, r0	; 63
    d616:	8d bf       	out	0x3d, r24	; 61
    d618:	60 91 ff 02 	lds	r22, 0x02FF
    d61c:	6f 5f       	subi	r22, 0xFF	; 255
    d61e:	80 91 f4 02 	lds	r24, 0x02F4
    d622:	90 91 f5 02 	lds	r25, 0x02F5
    d626:	88 0f       	add	r24, r24
    d628:	99 1f       	adc	r25, r25
    d62a:	88 0f       	add	r24, r24
    d62c:	99 1f       	adc	r25, r25
    d62e:	68 0f       	add	r22, r24
    d630:	6e 1b       	sub	r22, r30
    d632:	80 91 fe 02 	lds	r24, 0x02FE
    d636:	a8 01       	movw	r20, r16
    d638:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>

					   if (iBlok>0)lcd_printf(y,1+((x+((iBlok-1)*4))),PSTR("."));
    d63c:	80 91 f4 02 	lds	r24, 0x02F4
    d640:	90 91 f5 02 	lds	r25, 0x02F5
    d644:	00 97       	sbiw	r24, 0x00	; 0
    d646:	81 f0       	breq	.+32     	; 0xd668 <FMenuSettingServerIP+0x4ae>
    d648:	60 91 ff 02 	lds	r22, 0x02FF
    d64c:	6f 5f       	subi	r22, 0xFF	; 255
    d64e:	81 50       	subi	r24, 0x01	; 1
    d650:	90 4c       	sbci	r25, 0xC0	; 192
    d652:	88 0f       	add	r24, r24
    d654:	99 1f       	adc	r25, r25
    d656:	88 0f       	add	r24, r24
    d658:	99 1f       	adc	r25, r25
    d65a:	68 0f       	add	r22, r24
    d65c:	80 91 fe 02 	lds	r24, 0x02FE
    d660:	46 eb       	ldi	r20, 0xB6	; 182
    d662:	52 e1       	ldi	r21, 0x12	; 18
    d664:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
				       iInput=0;
    d668:	10 92 fd 02 	sts	0x02FD, r1
					   iBlok++;	   
    d66c:	80 91 f4 02 	lds	r24, 0x02F4
    d670:	90 91 f5 02 	lds	r25, 0x02F5
    d674:	01 96       	adiw	r24, 0x01	; 1
    d676:	90 93 f5 02 	sts	0x02F5, r25
    d67a:	80 93 f4 02 	sts	0x02F4, r24
				   }
				   if (iBlok>=4)stClientIP=cipStoreIPblok;
    d67e:	80 91 f4 02 	lds	r24, 0x02F4
    d682:	90 91 f5 02 	lds	r25, 0x02F5
    d686:	04 97       	sbiw	r24, 0x04	; 4
    d688:	a8 f0       	brcs	.+42     	; 0xd6b4 <FMenuSettingServerIP+0x4fa>
    d68a:	84 e0       	ldi	r24, 0x04	; 4
    d68c:	0b c0       	rjmp	.+22     	; 0xd6a4 <FMenuSettingServerIP+0x4ea>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    d68e:	8c e2       	ldi	r24, 0x2C	; 44
    d690:	90 e0       	ldi	r25, 0x00	; 0
    d692:	68 ef       	ldi	r22, 0xF8	; 248
    d694:	72 e0       	ldi	r23, 0x02	; 2
    d696:	44 e0       	ldi	r20, 0x04	; 4
    d698:	50 e0       	ldi	r21, 0x00	; 0
    d69a:	2b ef       	ldi	r18, 0xFB	; 251
    d69c:	32 e1       	ldi	r19, 0x12	; 18
    d69e:	0e 94 3b b4 	call	0x16876	; 0x16876 <__eewr_block>
			   }
		       break;
          case cipStoreIPblok:
		       //UpdateIPblok
			   eeprom_write_block((const void*) &IP_blok,(const void*) &DefServerIP,4);
			   stClientIP=cipExit;
    d6a2:	83 e0       	ldi	r24, 0x03	; 3
    d6a4:	80 93 58 01 	sts	0x0158, r24
    d6a8:	05 c0       	rjmp	.+10     	; 0xd6b4 <FMenuSettingServerIP+0x4fa>
		       break; 
          case cipExit://Cancel IPConfig
			   stClientIP=cipInit;
    d6aa:	81 e0       	ldi	r24, 0x01	; 1
    d6ac:	80 93 58 01 	sts	0x0158, r24
			   Result=MENU_DONE;
    d6b0:	80 93 01 03 	sts	0x0301, r24
		       break;     
		  }//EndSwitch	 
	return Result;
}
    d6b4:	80 91 01 03 	lds	r24, 0x0301
    d6b8:	64 96       	adiw	r28, 0x14	; 20
    d6ba:	0f b6       	in	r0, 0x3f	; 63
    d6bc:	f8 94       	cli
    d6be:	de bf       	out	0x3e, r29	; 62
    d6c0:	0f be       	out	0x3f, r0	; 63
    d6c2:	cd bf       	out	0x3d, r28	; 61
    d6c4:	cf 91       	pop	r28
    d6c6:	df 91       	pop	r29
    d6c8:	1f 91       	pop	r17
    d6ca:	0f 91       	pop	r16
    d6cc:	08 95       	ret

0000d6ce <FMenuSettingClientIP>:





char FMenuSettingClientIP(){
    d6ce:	0f 93       	push	r16
    d6d0:	1f 93       	push	r17
    d6d2:	df 93       	push	r29
    d6d4:	cf 93       	push	r28
    d6d6:	cd b7       	in	r28, 0x3d	; 61
    d6d8:	de b7       	in	r29, 0x3e	; 62
    d6da:	64 97       	sbiw	r28, 0x14	; 20
    d6dc:	0f b6       	in	r0, 0x3f	; 63
    d6de:	f8 94       	cli
    d6e0:	de bf       	out	0x3e, r29	; 62
    d6e2:	0f be       	out	0x3f, r0	; 63
    d6e4:	cd bf       	out	0x3d, r28	; 61
     //Client IP
     //Old: 192.168.123.000
	 //New:   _.   .   .
	 //--------------------
	 //*)cancel    #)next
     Result=MENU_NONE;
    d6e6:	10 92 13 03 	sts	0x0313, r1
	 switch(stClientIP){
    d6ea:	80 91 59 01 	lds	r24, 0x0159
    d6ee:	82 30       	cpi	r24, 0x02	; 2
    d6f0:	09 f4       	brne	.+2      	; 0xd6f4 <FMenuSettingClientIP+0x26>
    d6f2:	7b c0       	rjmp	.+246    	; 0xd7ea <FMenuSettingClientIP+0x11c>
    d6f4:	83 30       	cpi	r24, 0x03	; 3
    d6f6:	20 f4       	brcc	.+8      	; 0xd700 <FMenuSettingClientIP+0x32>
    d6f8:	81 30       	cpi	r24, 0x01	; 1
    d6fa:	09 f0       	breq	.+2      	; 0xd6fe <FMenuSettingClientIP+0x30>
    d6fc:	65 c2       	rjmp	.+1226   	; 0xdbc8 <FMenuSettingClientIP+0x4fa>
    d6fe:	07 c0       	rjmp	.+14     	; 0xd70e <FMenuSettingClientIP+0x40>
    d700:	83 30       	cpi	r24, 0x03	; 3
    d702:	09 f4       	brne	.+2      	; 0xd706 <FMenuSettingClientIP+0x38>
    d704:	5c c2       	rjmp	.+1208   	; 0xdbbe <FMenuSettingClientIP+0x4f0>
    d706:	84 30       	cpi	r24, 0x04	; 4
    d708:	09 f0       	breq	.+2      	; 0xd70c <FMenuSettingClientIP+0x3e>
    d70a:	5e c2       	rjmp	.+1212   	; 0xdbc8 <FMenuSettingClientIP+0x4fa>
    d70c:	4a c2       	rjmp	.+1172   	; 0xdba2 <FMenuSettingClientIP+0x4d4>
		  case cipInit:
			   lcd_clear();
    d70e:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
	           lcd_printf(1,1,PSTR("Client IP"));
    d712:	81 e0       	ldi	r24, 0x01	; 1
    d714:	61 e0       	ldi	r22, 0x01	; 1
    d716:	4a e5       	ldi	r20, 0x5A	; 90
    d718:	53 e1       	ldi	r21, 0x13	; 19
    d71a:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    d71e:	8a e0       	ldi	r24, 0x0A	; 10
    d720:	93 e0       	ldi	r25, 0x03	; 3
    d722:	68 e2       	ldi	r22, 0x28	; 40
    d724:	70 e0       	ldi	r23, 0x00	; 0
    d726:	44 e0       	ldi	r20, 0x04	; 4
    d728:	50 e0       	ldi	r21, 0x00	; 0
    d72a:	23 ef       	ldi	r18, 0xF3	; 243
    d72c:	32 e1       	ldi	r19, 0x12	; 18
    d72e:	0e 94 1f b4 	call	0x1683e	; 0x1683e <__eerd_block>
			   eeprom_read_block((void*)&IP_blok,(const void*)&DefClientIP,4);
	           sprintf_P(lcdteks,PSTR("Old: %d.%d.%d.%d"),IP_blok[0],IP_blok[1],IP_blok[2],IP_blok[3]);
    d732:	8d b7       	in	r24, 0x3d	; 61
    d734:	9e b7       	in	r25, 0x3e	; 62
    d736:	0c 97       	sbiw	r24, 0x0c	; 12
    d738:	0f b6       	in	r0, 0x3f	; 63
    d73a:	f8 94       	cli
    d73c:	9e bf       	out	0x3e, r25	; 62
    d73e:	0f be       	out	0x3f, r0	; 63
    d740:	8d bf       	out	0x3d, r24	; 61
    d742:	ed b7       	in	r30, 0x3d	; 61
    d744:	fe b7       	in	r31, 0x3e	; 62
    d746:	31 96       	adiw	r30, 0x01	; 1
    d748:	8e 01       	movw	r16, r28
    d74a:	0f 5f       	subi	r16, 0xFF	; 255
    d74c:	1f 4f       	sbci	r17, 0xFF	; 255
    d74e:	ad b7       	in	r26, 0x3d	; 61
    d750:	be b7       	in	r27, 0x3e	; 62
    d752:	12 96       	adiw	r26, 0x02	; 2
    d754:	1c 93       	st	X, r17
    d756:	0e 93       	st	-X, r16
    d758:	11 97       	sbiw	r26, 0x01	; 1
    d75a:	89 e4       	ldi	r24, 0x49	; 73
    d75c:	93 e1       	ldi	r25, 0x13	; 19
    d75e:	93 83       	std	Z+3, r25	; 0x03
    d760:	82 83       	std	Z+2, r24	; 0x02
    d762:	80 91 0a 03 	lds	r24, 0x030A
    d766:	84 83       	std	Z+4, r24	; 0x04
    d768:	15 82       	std	Z+5, r1	; 0x05
    d76a:	80 91 0b 03 	lds	r24, 0x030B
    d76e:	86 83       	std	Z+6, r24	; 0x06
    d770:	17 82       	std	Z+7, r1	; 0x07
    d772:	80 91 0c 03 	lds	r24, 0x030C
    d776:	80 87       	std	Z+8, r24	; 0x08
    d778:	11 86       	std	Z+9, r1	; 0x09
    d77a:	80 91 0d 03 	lds	r24, 0x030D
    d77e:	82 87       	std	Z+10, r24	; 0x0a
    d780:	13 86       	std	Z+11, r1	; 0x0b
    d782:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
	           lcd_print(2,1,lcdteks);
    d786:	ed b7       	in	r30, 0x3d	; 61
    d788:	fe b7       	in	r31, 0x3e	; 62
    d78a:	3c 96       	adiw	r30, 0x0c	; 12
    d78c:	0f b6       	in	r0, 0x3f	; 63
    d78e:	f8 94       	cli
    d790:	fe bf       	out	0x3e, r31	; 62
    d792:	0f be       	out	0x3f, r0	; 63
    d794:	ed bf       	out	0x3d, r30	; 61
    d796:	82 e0       	ldi	r24, 0x02	; 2
    d798:	61 e0       	ldi	r22, 0x01	; 1
    d79a:	a8 01       	movw	r20, r16
    d79c:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
			   lcd_printf(3,1,PSTR("New:   _.   .   .   "));
    d7a0:	83 e0       	ldi	r24, 0x03	; 3
    d7a2:	61 e0       	ldi	r22, 0x01	; 1
    d7a4:	44 e3       	ldi	r20, 0x34	; 52
    d7a6:	53 e1       	ldi	r21, 0x13	; 19
    d7a8:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
			   lcd_printf(4,1,PSTR("[*]cancel  [#]next  "));
    d7ac:	84 e0       	ldi	r24, 0x04	; 4
    d7ae:	61 e0       	ldi	r22, 0x01	; 1
    d7b0:	4f e1       	ldi	r20, 0x1F	; 31
    d7b2:	53 e1       	ldi	r21, 0x13	; 19
    d7b4:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
               iLoop=0;
    d7b8:	10 92 09 03 	sts	0x0309, r1
    d7bc:	10 92 08 03 	sts	0x0308, r1
			   y=3,x=8;
    d7c0:	83 e0       	ldi	r24, 0x03	; 3
    d7c2:	80 93 10 03 	sts	0x0310, r24
    d7c6:	88 e0       	ldi	r24, 0x08	; 8
    d7c8:	80 93 11 03 	sts	0x0311, r24
			   iInput=0; iBlok=0;
    d7cc:	10 92 0f 03 	sts	0x030F, r1
    d7d0:	10 92 07 03 	sts	0x0307, r1
    d7d4:	10 92 06 03 	sts	0x0306, r1
			   IPchar[0]='0';IPchar[1]='0';IPchar[2]='0';
    d7d8:	80 e3       	ldi	r24, 0x30	; 48
    d7da:	80 93 15 03 	sts	0x0315, r24
    d7de:	80 93 16 03 	sts	0x0316, r24
    d7e2:	80 93 17 03 	sts	0x0317, r24
			   stClientIP=cipInputIP; 
    d7e6:	82 e0       	ldi	r24, 0x02	; 2
    d7e8:	e7 c1       	rjmp	.+974    	; 0xdbb8 <FMenuSettingClientIP+0x4ea>
		       break;
          case cipInputIP:
			   //Blinking 60% _ 
			   iLoop++;
    d7ea:	80 91 08 03 	lds	r24, 0x0308
    d7ee:	90 91 09 03 	lds	r25, 0x0309
    d7f2:	01 96       	adiw	r24, 0x01	; 1
    d7f4:	90 93 09 03 	sts	0x0309, r25
    d7f8:	80 93 08 03 	sts	0x0308, r24
			   if ((iLoop%2000)==0){
    d7fc:	60 ed       	ldi	r22, 0xD0	; 208
    d7fe:	77 e0       	ldi	r23, 0x07	; 7
    d800:	0e 94 38 b7 	call	0x16e70	; 0x16e70 <__udivmodhi4>
    d804:	89 2b       	or	r24, r25
    d806:	81 f4       	brne	.+32     	; 0xd828 <FMenuSettingClientIP+0x15a>
			      lcd_put(y,(x+(iBlok*4)),'_'); 
    d808:	80 91 06 03 	lds	r24, 0x0306
    d80c:	90 91 07 03 	lds	r25, 0x0307
    d810:	88 0f       	add	r24, r24
    d812:	99 1f       	adc	r25, r25
    d814:	88 0f       	add	r24, r24
    d816:	99 1f       	adc	r25, r25
    d818:	60 91 11 03 	lds	r22, 0x0311
    d81c:	68 0f       	add	r22, r24
    d81e:	80 91 10 03 	lds	r24, 0x0310
    d822:	4f e5       	ldi	r20, 0x5F	; 95
    d824:	0e 94 7f ad 	call	0x15afe	; 0x15afe <lcd_put>
			   }
			   if ((iLoop%2000)==1000){
    d828:	80 91 08 03 	lds	r24, 0x0308
    d82c:	90 91 09 03 	lds	r25, 0x0309
    d830:	60 ed       	ldi	r22, 0xD0	; 208
    d832:	77 e0       	ldi	r23, 0x07	; 7
    d834:	0e 94 38 b7 	call	0x16e70	; 0x16e70 <__udivmodhi4>
    d838:	88 5e       	subi	r24, 0xE8	; 232
    d83a:	93 40       	sbci	r25, 0x03	; 3
    d83c:	81 f4       	brne	.+32     	; 0xd85e <FMenuSettingClientIP+0x190>
			      lcd_put(y,(x+(iBlok*4)),' '); 
    d83e:	80 91 06 03 	lds	r24, 0x0306
    d842:	90 91 07 03 	lds	r25, 0x0307
    d846:	88 0f       	add	r24, r24
    d848:	99 1f       	adc	r25, r25
    d84a:	88 0f       	add	r24, r24
    d84c:	99 1f       	adc	r25, r25
    d84e:	60 91 11 03 	lds	r22, 0x0311
    d852:	68 0f       	add	r22, r24
    d854:	80 91 10 03 	lds	r24, 0x0310
    d858:	40 e2       	ldi	r20, 0x20	; 32
    d85a:	0e 94 7f ad 	call	0x15afe	; 0x15afe <lcd_put>
			   }
			   //GetKeyPressed
			   keyPressed=_key_scan(1);
    d85e:	81 e0       	ldi	r24, 0x01	; 1
    d860:	0e 94 ab ae 	call	0x15d56	; 0x15d56 <_key_scan>
    d864:	80 93 0e 03 	sts	0x030E, r24
			   keyChar=_key_btn(keyPressed);
    d868:	0e 94 0c ae 	call	0x15c18	; 0x15c18 <_key_btn>
    d86c:	28 2f       	mov	r18, r24
    d86e:	80 93 12 03 	sts	0x0312, r24
               if ((keyChar>='0')&&(keyChar<='9')){
    d872:	80 53       	subi	r24, 0x30	; 48
    d874:	8a 30       	cpi	r24, 0x0A	; 10
    d876:	08 f0       	brcs	.+2      	; 0xd87a <FMenuSettingClientIP+0x1ac>
    d878:	d6 c0       	rjmp	.+428    	; 0xda26 <FMenuSettingClientIP+0x358>
    d87a:	80 e5       	ldi	r24, 0x50	; 80
    d87c:	93 ec       	ldi	r25, 0xC3	; 195
    d87e:	01 97       	sbiw	r24, 0x01	; 1
    d880:	f1 f7       	brne	.-4      	; 0xd87e <FMenuSettingClientIP+0x1b0>
			       _delay_ms(200);
			       IPchar[iInput]=keyChar;
    d882:	80 91 0f 03 	lds	r24, 0x030F
    d886:	e8 2f       	mov	r30, r24
    d888:	f0 e0       	ldi	r31, 0x00	; 0
    d88a:	eb 5e       	subi	r30, 0xEB	; 235
    d88c:	fc 4f       	sbci	r31, 0xFC	; 252
    d88e:	20 83       	st	Z, r18
				   iInput++;                    
    d890:	8f 5f       	subi	r24, 0xFF	; 255
    d892:	80 93 0f 03 	sts	0x030F, r24
				   for (i=1;i<(iInput+1);i++){
    d896:	81 e0       	ldi	r24, 0x01	; 1
    d898:	1c c0       	rjmp	.+56     	; 0xd8d2 <FMenuSettingClientIP+0x204>
				       lcd_xy(y,((x+(iBlok*4))-(3-i)));_lcd(IPchar[i-1]);
    d89a:	80 91 11 03 	lds	r24, 0x0311
    d89e:	68 0f       	add	r22, r24
    d8a0:	63 50       	subi	r22, 0x03	; 3
    d8a2:	80 91 06 03 	lds	r24, 0x0306
    d8a6:	90 91 07 03 	lds	r25, 0x0307
    d8aa:	88 0f       	add	r24, r24
    d8ac:	99 1f       	adc	r25, r25
    d8ae:	88 0f       	add	r24, r24
    d8b0:	99 1f       	adc	r25, r25
    d8b2:	68 0f       	add	r22, r24
    d8b4:	80 91 10 03 	lds	r24, 0x0310
    d8b8:	0e 94 f1 ac 	call	0x159e2	; 0x159e2 <lcd_xy>
    d8bc:	e0 91 14 03 	lds	r30, 0x0314
    d8c0:	f0 e0       	ldi	r31, 0x00	; 0
    d8c2:	ec 5e       	subi	r30, 0xEC	; 236
    d8c4:	fc 4f       	sbci	r31, 0xFC	; 252
    d8c6:	80 81       	ld	r24, Z
    d8c8:	0e 94 cb ac 	call	0x15996	; 0x15996 <_lcd>
			   keyChar=_key_btn(keyPressed);
               if ((keyChar>='0')&&(keyChar<='9')){
			       _delay_ms(200);
			       IPchar[iInput]=keyChar;
				   iInput++;                    
				   for (i=1;i<(iInput+1);i++){
    d8cc:	80 91 14 03 	lds	r24, 0x0314
    d8d0:	8f 5f       	subi	r24, 0xFF	; 255
    d8d2:	80 93 14 03 	sts	0x0314, r24
    d8d6:	70 91 0f 03 	lds	r23, 0x030F
    d8da:	60 91 14 03 	lds	r22, 0x0314
    d8de:	27 2f       	mov	r18, r23
    d8e0:	30 e0       	ldi	r19, 0x00	; 0
    d8e2:	86 2f       	mov	r24, r22
    d8e4:	90 e0       	ldi	r25, 0x00	; 0
    d8e6:	28 17       	cp	r18, r24
    d8e8:	39 07       	cpc	r19, r25
    d8ea:	bc f6       	brge	.-82     	; 0xd89a <FMenuSettingClientIP+0x1cc>
				       lcd_xy(y,((x+(iBlok*4))-(3-i)));_lcd(IPchar[i-1]);
				   }
                   //NextInput
				   if (iInput>=3){
    d8ec:	73 30       	cpi	r23, 0x03	; 3
    d8ee:	08 f4       	brcc	.+2      	; 0xd8f2 <FMenuSettingClientIP+0x224>
    d8f0:	91 c0       	rjmp	.+290    	; 0xda14 <FMenuSettingClientIP+0x346>
				       IP_blok[iBlok]=((IPchar[0]-'0')*100)+((IPchar[1]-'0')*10)+((IPchar[2]-'0'));
    d8f2:	40 91 06 03 	lds	r20, 0x0306
    d8f6:	50 91 07 03 	lds	r21, 0x0307
    d8fa:	fa 01       	movw	r30, r20
    d8fc:	e6 5f       	subi	r30, 0xF6	; 246
    d8fe:	fc 4f       	sbci	r31, 0xFC	; 252
    d900:	20 91 17 03 	lds	r18, 0x0317
    d904:	20 5d       	subi	r18, 0xD0	; 208
    d906:	80 91 15 03 	lds	r24, 0x0315
    d90a:	34 e6       	ldi	r19, 0x64	; 100
    d90c:	83 9f       	mul	r24, r19
    d90e:	c0 01       	movw	r24, r0
    d910:	11 24       	eor	r1, r1
    d912:	28 0f       	add	r18, r24
    d914:	80 91 16 03 	lds	r24, 0x0316
    d918:	3a e0       	ldi	r19, 0x0A	; 10
    d91a:	83 9f       	mul	r24, r19
    d91c:	c0 01       	movw	r24, r0
    d91e:	11 24       	eor	r1, r1
    d920:	28 0f       	add	r18, r24
    d922:	20 83       	st	Z, r18
					   IPchar[0]='0';IPchar[1]='0';IPchar[2]='0';
    d924:	80 e3       	ldi	r24, 0x30	; 48
    d926:	80 93 15 03 	sts	0x0315, r24
    d92a:	80 93 16 03 	sts	0x0316, r24
    d92e:	80 93 17 03 	sts	0x0317, r24
					   //Reposition Value
					   lcd_printf(y,((x+(iBlok*4))-iInput),PSTR("   "));
    d932:	44 0f       	add	r20, r20
    d934:	55 1f       	adc	r21, r21
    d936:	44 0f       	add	r20, r20
    d938:	55 1f       	adc	r21, r21
    d93a:	60 91 11 03 	lds	r22, 0x0311
    d93e:	64 0f       	add	r22, r20
    d940:	67 1b       	sub	r22, r23
    d942:	80 91 10 03 	lds	r24, 0x0310
    d946:	4b e1       	ldi	r20, 0x1B	; 27
    d948:	53 e1       	ldi	r21, 0x13	; 19
    d94a:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
					   sprintf_P(lcdteks,PSTR("%d"),IP_blok[iBlok]);
    d94e:	00 d0       	rcall	.+0      	; 0xd950 <FMenuSettingClientIP+0x282>
    d950:	00 d0       	rcall	.+0      	; 0xd952 <FMenuSettingClientIP+0x284>
    d952:	00 d0       	rcall	.+0      	; 0xd954 <FMenuSettingClientIP+0x286>
    d954:	ad b7       	in	r26, 0x3d	; 61
    d956:	be b7       	in	r27, 0x3e	; 62
    d958:	11 96       	adiw	r26, 0x01	; 1
    d95a:	8e 01       	movw	r16, r28
    d95c:	0f 5f       	subi	r16, 0xFF	; 255
    d95e:	1f 4f       	sbci	r17, 0xFF	; 255
    d960:	ed b7       	in	r30, 0x3d	; 61
    d962:	fe b7       	in	r31, 0x3e	; 62
    d964:	12 83       	std	Z+2, r17	; 0x02
    d966:	01 83       	std	Z+1, r16	; 0x01
    d968:	88 e1       	ldi	r24, 0x18	; 24
    d96a:	93 e1       	ldi	r25, 0x13	; 19
    d96c:	13 96       	adiw	r26, 0x03	; 3
    d96e:	9c 93       	st	X, r25
    d970:	8e 93       	st	-X, r24
    d972:	12 97       	sbiw	r26, 0x02	; 2
    d974:	e0 91 06 03 	lds	r30, 0x0306
    d978:	f0 91 07 03 	lds	r31, 0x0307
    d97c:	e6 5f       	subi	r30, 0xF6	; 246
    d97e:	fc 4f       	sbci	r31, 0xFC	; 252
    d980:	80 81       	ld	r24, Z
    d982:	14 96       	adiw	r26, 0x04	; 4
    d984:	8c 93       	st	X, r24
    d986:	14 97       	sbiw	r26, 0x04	; 4
    d988:	15 96       	adiw	r26, 0x05	; 5
    d98a:	1c 92       	st	X, r1
    d98c:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
                       lcd_print(y,1+((x+(iBlok*4))-strlen(lcdteks)),lcdteks);
    d990:	f8 01       	movw	r30, r16
    d992:	01 90       	ld	r0, Z+
    d994:	00 20       	and	r0, r0
    d996:	e9 f7       	brne	.-6      	; 0xd992 <FMenuSettingClientIP+0x2c4>
    d998:	31 97       	sbiw	r30, 0x01	; 1
    d99a:	e0 1b       	sub	r30, r16
    d99c:	f1 0b       	sbc	r31, r17
    d99e:	8d b7       	in	r24, 0x3d	; 61
    d9a0:	9e b7       	in	r25, 0x3e	; 62
    d9a2:	06 96       	adiw	r24, 0x06	; 6
    d9a4:	0f b6       	in	r0, 0x3f	; 63
    d9a6:	f8 94       	cli
    d9a8:	9e bf       	out	0x3e, r25	; 62
    d9aa:	0f be       	out	0x3f, r0	; 63
    d9ac:	8d bf       	out	0x3d, r24	; 61
    d9ae:	60 91 11 03 	lds	r22, 0x0311
    d9b2:	6f 5f       	subi	r22, 0xFF	; 255
    d9b4:	80 91 06 03 	lds	r24, 0x0306
    d9b8:	90 91 07 03 	lds	r25, 0x0307
    d9bc:	88 0f       	add	r24, r24
    d9be:	99 1f       	adc	r25, r25
    d9c0:	88 0f       	add	r24, r24
    d9c2:	99 1f       	adc	r25, r25
    d9c4:	68 0f       	add	r22, r24
    d9c6:	6e 1b       	sub	r22, r30
    d9c8:	80 91 10 03 	lds	r24, 0x0310
    d9cc:	a8 01       	movw	r20, r16
    d9ce:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
					   if (iBlok>0)lcd_printf(y,1+((x+((iBlok-1)*4))),PSTR("."));
    d9d2:	80 91 06 03 	lds	r24, 0x0306
    d9d6:	90 91 07 03 	lds	r25, 0x0307
    d9da:	00 97       	sbiw	r24, 0x00	; 0
    d9dc:	81 f0       	breq	.+32     	; 0xd9fe <FMenuSettingClientIP+0x330>
    d9de:	60 91 11 03 	lds	r22, 0x0311
    d9e2:	6f 5f       	subi	r22, 0xFF	; 255
    d9e4:	81 50       	subi	r24, 0x01	; 1
    d9e6:	90 4c       	sbci	r25, 0xC0	; 192
    d9e8:	88 0f       	add	r24, r24
    d9ea:	99 1f       	adc	r25, r25
    d9ec:	88 0f       	add	r24, r24
    d9ee:	99 1f       	adc	r25, r25
    d9f0:	68 0f       	add	r22, r24
    d9f2:	80 91 10 03 	lds	r24, 0x0310
    d9f6:	46 e1       	ldi	r20, 0x16	; 22
    d9f8:	53 e1       	ldi	r21, 0x13	; 19
    d9fa:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
					   iInput=0;
    d9fe:	10 92 0f 03 	sts	0x030F, r1
					   iBlok++;
    da02:	80 91 06 03 	lds	r24, 0x0306
    da06:	90 91 07 03 	lds	r25, 0x0307
    da0a:	01 96       	adiw	r24, 0x01	; 1
    da0c:	90 93 07 03 	sts	0x0307, r25
    da10:	80 93 06 03 	sts	0x0306, r24

				   }
				   if (iBlok>=4)stClientIP=cipStoreIPblok;
    da14:	80 91 06 03 	lds	r24, 0x0306
    da18:	90 91 07 03 	lds	r25, 0x0307
    da1c:	04 97       	sbiw	r24, 0x04	; 4
    da1e:	18 f0       	brcs	.+6      	; 0xda26 <FMenuSettingClientIP+0x358>
    da20:	84 e0       	ldi	r24, 0x04	; 4
    da22:	80 93 59 01 	sts	0x0159, r24
			   }

			   if (keyPressed==_KEY_CANCEL){
    da26:	80 91 0e 03 	lds	r24, 0x030E
    da2a:	87 3e       	cpi	r24, 0xE7	; 231
    da2c:	09 f4       	brne	.+2      	; 0xda30 <FMenuSettingClientIP+0x362>
    da2e:	c3 c0       	rjmp	.+390    	; 0xdbb6 <FMenuSettingClientIP+0x4e8>
			       stClientIP=cipExit; 
			   }
			   else
			   if (keyPressed==_KEY_ENTER){
    da30:	87 3b       	cpi	r24, 0xB7	; 183
    da32:	09 f0       	breq	.+2      	; 0xda36 <FMenuSettingClientIP+0x368>
    da34:	c9 c0       	rjmp	.+402    	; 0xdbc8 <FMenuSettingClientIP+0x4fa>
			       //NextInput
			       if (iBlok<4){
    da36:	40 91 06 03 	lds	r20, 0x0306
    da3a:	50 91 07 03 	lds	r21, 0x0307
    da3e:	44 30       	cpi	r20, 0x04	; 4
    da40:	51 05       	cpc	r21, r1
    da42:	08 f0       	brcs	.+2      	; 0xda46 <FMenuSettingClientIP+0x378>
    da44:	a6 c0       	rjmp	.+332    	; 0xdb92 <FMenuSettingClientIP+0x4c4>
				       if (iInput==1)IP_blok[iBlok]=((IPchar[0]-'0'));
    da46:	80 91 0f 03 	lds	r24, 0x030F
    da4a:	81 30       	cpi	r24, 0x01	; 1
    da4c:	41 f4       	brne	.+16     	; 0xda5e <FMenuSettingClientIP+0x390>
    da4e:	fa 01       	movw	r30, r20
    da50:	e6 5f       	subi	r30, 0xF6	; 246
    da52:	fc 4f       	sbci	r31, 0xFC	; 252
    da54:	80 91 15 03 	lds	r24, 0x0315
    da58:	80 53       	subi	r24, 0x30	; 48
    da5a:	80 83       	st	Z, r24
    da5c:	22 c0       	rjmp	.+68     	; 0xdaa2 <FMenuSettingClientIP+0x3d4>
					   if (iInput==2)IP_blok[iBlok]=((IPchar[0]-'0')*10)+(IPchar[1]-'0');
    da5e:	82 30       	cpi	r24, 0x02	; 2
    da60:	49 f4       	brne	.+18     	; 0xda74 <FMenuSettingClientIP+0x3a6>
    da62:	fa 01       	movw	r30, r20
    da64:	e6 5f       	subi	r30, 0xF6	; 246
    da66:	fc 4f       	sbci	r31, 0xFC	; 252
    da68:	20 91 16 03 	lds	r18, 0x0316
    da6c:	20 51       	subi	r18, 0x10	; 16
    da6e:	80 91 15 03 	lds	r24, 0x0315
    da72:	11 c0       	rjmp	.+34     	; 0xda96 <FMenuSettingClientIP+0x3c8>
					   if (iInput==3)IP_blok[iBlok]=((IPchar[0]-'0')*100)+((IPchar[1]-'0')*10)+((IPchar[2]-'0'));
    da74:	83 30       	cpi	r24, 0x03	; 3
    da76:	a9 f4       	brne	.+42     	; 0xdaa2 <FMenuSettingClientIP+0x3d4>
    da78:	fa 01       	movw	r30, r20
    da7a:	e6 5f       	subi	r30, 0xF6	; 246
    da7c:	fc 4f       	sbci	r31, 0xFC	; 252
    da7e:	20 91 17 03 	lds	r18, 0x0317
    da82:	20 5d       	subi	r18, 0xD0	; 208
    da84:	80 91 15 03 	lds	r24, 0x0315
    da88:	34 e6       	ldi	r19, 0x64	; 100
    da8a:	83 9f       	mul	r24, r19
    da8c:	c0 01       	movw	r24, r0
    da8e:	11 24       	eor	r1, r1
    da90:	28 0f       	add	r18, r24
    da92:	80 91 16 03 	lds	r24, 0x0316
    da96:	3a e0       	ldi	r19, 0x0A	; 10
    da98:	83 9f       	mul	r24, r19
    da9a:	c0 01       	movw	r24, r0
    da9c:	11 24       	eor	r1, r1
    da9e:	28 0f       	add	r18, r24
    daa0:	20 83       	st	Z, r18
				       
					   IPchar[0]='0';IPchar[1]='0';IPchar[2]='0';
    daa2:	80 e3       	ldi	r24, 0x30	; 48
    daa4:	80 93 15 03 	sts	0x0315, r24
    daa8:	80 93 16 03 	sts	0x0316, r24
    daac:	80 93 17 03 	sts	0x0317, r24
					   //Reposition Value
					   lcd_printf(y,((x+(iBlok*4))-3),PSTR("   "));
    dab0:	60 91 11 03 	lds	r22, 0x0311
    dab4:	63 50       	subi	r22, 0x03	; 3
    dab6:	44 0f       	add	r20, r20
    dab8:	55 1f       	adc	r21, r21
    daba:	44 0f       	add	r20, r20
    dabc:	55 1f       	adc	r21, r21
    dabe:	64 0f       	add	r22, r20
    dac0:	80 91 10 03 	lds	r24, 0x0310
    dac4:	42 e1       	ldi	r20, 0x12	; 18
    dac6:	53 e1       	ldi	r21, 0x13	; 19
    dac8:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
					   sprintf_P(lcdteks,PSTR("%d"),IP_blok[iBlok]);
    dacc:	00 d0       	rcall	.+0      	; 0xdace <FMenuSettingClientIP+0x400>
    dace:	00 d0       	rcall	.+0      	; 0xdad0 <FMenuSettingClientIP+0x402>
    dad0:	00 d0       	rcall	.+0      	; 0xdad2 <FMenuSettingClientIP+0x404>
    dad2:	ad b7       	in	r26, 0x3d	; 61
    dad4:	be b7       	in	r27, 0x3e	; 62
    dad6:	11 96       	adiw	r26, 0x01	; 1
    dad8:	8e 01       	movw	r16, r28
    dada:	0f 5f       	subi	r16, 0xFF	; 255
    dadc:	1f 4f       	sbci	r17, 0xFF	; 255
    dade:	ed b7       	in	r30, 0x3d	; 61
    dae0:	fe b7       	in	r31, 0x3e	; 62
    dae2:	12 83       	std	Z+2, r17	; 0x02
    dae4:	01 83       	std	Z+1, r16	; 0x01
    dae6:	8f e0       	ldi	r24, 0x0F	; 15
    dae8:	93 e1       	ldi	r25, 0x13	; 19
    daea:	13 96       	adiw	r26, 0x03	; 3
    daec:	9c 93       	st	X, r25
    daee:	8e 93       	st	-X, r24
    daf0:	12 97       	sbiw	r26, 0x02	; 2
    daf2:	e0 91 06 03 	lds	r30, 0x0306
    daf6:	f0 91 07 03 	lds	r31, 0x0307
    dafa:	e6 5f       	subi	r30, 0xF6	; 246
    dafc:	fc 4f       	sbci	r31, 0xFC	; 252
    dafe:	80 81       	ld	r24, Z
    db00:	14 96       	adiw	r26, 0x04	; 4
    db02:	8c 93       	st	X, r24
    db04:	14 97       	sbiw	r26, 0x04	; 4
    db06:	15 96       	adiw	r26, 0x05	; 5
    db08:	1c 92       	st	X, r1
    db0a:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
                       lcd_print(y,1+((x+(iBlok*4))-strlen(lcdteks)),lcdteks);
    db0e:	f8 01       	movw	r30, r16
    db10:	01 90       	ld	r0, Z+
    db12:	00 20       	and	r0, r0
    db14:	e9 f7       	brne	.-6      	; 0xdb10 <FMenuSettingClientIP+0x442>
    db16:	31 97       	sbiw	r30, 0x01	; 1
    db18:	e0 1b       	sub	r30, r16
    db1a:	f1 0b       	sbc	r31, r17
    db1c:	8d b7       	in	r24, 0x3d	; 61
    db1e:	9e b7       	in	r25, 0x3e	; 62
    db20:	06 96       	adiw	r24, 0x06	; 6
    db22:	0f b6       	in	r0, 0x3f	; 63
    db24:	f8 94       	cli
    db26:	9e bf       	out	0x3e, r25	; 62
    db28:	0f be       	out	0x3f, r0	; 63
    db2a:	8d bf       	out	0x3d, r24	; 61
    db2c:	60 91 11 03 	lds	r22, 0x0311
    db30:	6f 5f       	subi	r22, 0xFF	; 255
    db32:	80 91 06 03 	lds	r24, 0x0306
    db36:	90 91 07 03 	lds	r25, 0x0307
    db3a:	88 0f       	add	r24, r24
    db3c:	99 1f       	adc	r25, r25
    db3e:	88 0f       	add	r24, r24
    db40:	99 1f       	adc	r25, r25
    db42:	68 0f       	add	r22, r24
    db44:	6e 1b       	sub	r22, r30
    db46:	80 91 10 03 	lds	r24, 0x0310
    db4a:	a8 01       	movw	r20, r16
    db4c:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>

					   if (iBlok>0)lcd_printf(y,1+((x+((iBlok-1)*4))),PSTR("."));
    db50:	80 91 06 03 	lds	r24, 0x0306
    db54:	90 91 07 03 	lds	r25, 0x0307
    db58:	00 97       	sbiw	r24, 0x00	; 0
    db5a:	81 f0       	breq	.+32     	; 0xdb7c <FMenuSettingClientIP+0x4ae>
    db5c:	60 91 11 03 	lds	r22, 0x0311
    db60:	6f 5f       	subi	r22, 0xFF	; 255
    db62:	81 50       	subi	r24, 0x01	; 1
    db64:	90 4c       	sbci	r25, 0xC0	; 192
    db66:	88 0f       	add	r24, r24
    db68:	99 1f       	adc	r25, r25
    db6a:	88 0f       	add	r24, r24
    db6c:	99 1f       	adc	r25, r25
    db6e:	68 0f       	add	r22, r24
    db70:	80 91 10 03 	lds	r24, 0x0310
    db74:	4d e0       	ldi	r20, 0x0D	; 13
    db76:	53 e1       	ldi	r21, 0x13	; 19
    db78:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
				       iInput=0;
    db7c:	10 92 0f 03 	sts	0x030F, r1
					   iBlok++;	   
    db80:	80 91 06 03 	lds	r24, 0x0306
    db84:	90 91 07 03 	lds	r25, 0x0307
    db88:	01 96       	adiw	r24, 0x01	; 1
    db8a:	90 93 07 03 	sts	0x0307, r25
    db8e:	80 93 06 03 	sts	0x0306, r24
				   }
				   if (iBlok>=4)stClientIP=cipStoreIPblok;
    db92:	80 91 06 03 	lds	r24, 0x0306
    db96:	90 91 07 03 	lds	r25, 0x0307
    db9a:	04 97       	sbiw	r24, 0x04	; 4
    db9c:	a8 f0       	brcs	.+42     	; 0xdbc8 <FMenuSettingClientIP+0x4fa>
    db9e:	84 e0       	ldi	r24, 0x04	; 4
    dba0:	0b c0       	rjmp	.+22     	; 0xdbb8 <FMenuSettingClientIP+0x4ea>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    dba2:	88 e2       	ldi	r24, 0x28	; 40
    dba4:	90 e0       	ldi	r25, 0x00	; 0
    dba6:	6a e0       	ldi	r22, 0x0A	; 10
    dba8:	73 e0       	ldi	r23, 0x03	; 3
    dbaa:	44 e0       	ldi	r20, 0x04	; 4
    dbac:	50 e0       	ldi	r21, 0x00	; 0
    dbae:	2b ef       	ldi	r18, 0xFB	; 251
    dbb0:	32 e1       	ldi	r19, 0x12	; 18
    dbb2:	0e 94 3b b4 	call	0x16876	; 0x16876 <__eewr_block>
			   }
		       break;
          case cipStoreIPblok://UpdateIPblok
			   eeprom_write_block((const void*) &IP_blok,(const void*) &DefClientIP,4);
			   stClientIP=cipExit;
    dbb6:	83 e0       	ldi	r24, 0x03	; 3
    dbb8:	80 93 59 01 	sts	0x0159, r24
    dbbc:	05 c0       	rjmp	.+10     	; 0xdbc8 <FMenuSettingClientIP+0x4fa>
		       break; 
          case cipExit://Cancel IPConfig
		       stClientIP=cipInit;
    dbbe:	81 e0       	ldi	r24, 0x01	; 1
    dbc0:	80 93 59 01 	sts	0x0159, r24
		       Result=MENU_DONE;
    dbc4:	80 93 13 03 	sts	0x0313, r24
		       break;     
		  }//EndSwitch	 
    return Result;
}
    dbc8:	80 91 13 03 	lds	r24, 0x0313
    dbcc:	64 96       	adiw	r28, 0x14	; 20
    dbce:	0f b6       	in	r0, 0x3f	; 63
    dbd0:	f8 94       	cli
    dbd2:	de bf       	out	0x3e, r29	; 62
    dbd4:	0f be       	out	0x3f, r0	; 63
    dbd6:	cd bf       	out	0x3d, r28	; 61
    dbd8:	cf 91       	pop	r28
    dbda:	df 91       	pop	r29
    dbdc:	1f 91       	pop	r17
    dbde:	0f 91       	pop	r16
    dbe0:	08 95       	ret

0000dbe2 <DisplayStandaloneSequence>:
	 i++;
     _delay_ms(6500);
  return Result;
}

void DisplayStandaloneSequence(char x,char y, char PoolingSequence){
    dbe2:	df 93       	push	r29
    dbe4:	cf 93       	push	r28
    dbe6:	cd b7       	in	r28, 0x3d	; 61
    dbe8:	de b7       	in	r29, 0x3e	; 62
    dbea:	28 97       	sbiw	r28, 0x08	; 8
    dbec:	0f b6       	in	r0, 0x3f	; 63
    dbee:	f8 94       	cli
    dbf0:	de bf       	out	0x3e, r29	; 62
    dbf2:	0f be       	out	0x3f, r0	; 63
    dbf4:	cd bf       	out	0x3d, r28	; 61
    dbf6:	58 2f       	mov	r21, r24
	 MapSequence[3]='/';
	 MapSequence[4]='-';
	 MapSequence[5]=164;//0x5C;
	 MapSequence[6]='|';
	 MapSequence[7]='/';
	 if (IsPoolingRestarted==False)lcd_put(x,y,MapSequence[(PoolingSequence%8)]);     
    dbf8:	80 91 96 01 	lds	r24, 0x0196
    dbfc:	88 23       	and	r24, r24
    dbfe:	a1 f4       	brne	.+40     	; 0xdc28 <DisplayStandaloneSequence+0x46>

void DisplayStandaloneSequence(char x,char y, char PoolingSequence){
     char MapSequence[8];

     //sprintf_P(MapSequence,PSTR("-\|/-|/"));
	 MapSequence[0]='-';
    dc00:	3d e2       	ldi	r19, 0x2D	; 45
    dc02:	39 83       	std	Y+1, r19	; 0x01
	 MapSequence[1]='`';//0x5C;
    dc04:	80 e6       	ldi	r24, 0x60	; 96
    dc06:	8a 83       	std	Y+2, r24	; 0x02
	 MapSequence[2]='|';
    dc08:	2c e7       	ldi	r18, 0x7C	; 124
    dc0a:	2b 83       	std	Y+3, r18	; 0x03
	 MapSequence[3]='/';
    dc0c:	9f e2       	ldi	r25, 0x2F	; 47
    dc0e:	9c 83       	std	Y+4, r25	; 0x04
	 MapSequence[4]='-';
    dc10:	3d 83       	std	Y+5, r19	; 0x05
	 MapSequence[5]=164;//0x5C;
    dc12:	84 ea       	ldi	r24, 0xA4	; 164
    dc14:	8e 83       	std	Y+6, r24	; 0x06
	 MapSequence[6]='|';
    dc16:	2f 83       	std	Y+7, r18	; 0x07
	 MapSequence[7]='/';
    dc18:	98 87       	std	Y+8, r25	; 0x08
	 if (IsPoolingRestarted==False)lcd_put(x,y,MapSequence[(PoolingSequence%8)]);     
    dc1a:	47 70       	andi	r20, 0x07	; 7
    dc1c:	fe 01       	movw	r30, r28
    dc1e:	e4 0f       	add	r30, r20
    dc20:	f1 1d       	adc	r31, r1
    dc22:	85 2f       	mov	r24, r21
    dc24:	41 81       	ldd	r20, Z+1	; 0x01
    dc26:	08 c0       	rjmp	.+16     	; 0xdc38 <DisplayStandaloneSequence+0x56>
	 else if (IsPoolingRestarted==True){
    dc28:	80 91 96 01 	lds	r24, 0x0196
    dc2c:	81 30       	cpi	r24, 0x01	; 1
    dc2e:	31 f4       	brne	.+12     	; 0xdc3c <DisplayStandaloneSequence+0x5a>
	          IsPoolingRestarted=False;
    dc30:	10 92 96 01 	sts	0x0196, r1
	          lcd_put(x,y,'X');     
    dc34:	85 2f       	mov	r24, r21
    dc36:	48 e5       	ldi	r20, 0x58	; 88
    dc38:	0e 94 7f ad 	call	0x15afe	; 0x15afe <lcd_put>
			  }

}
    dc3c:	28 96       	adiw	r28, 0x08	; 8
    dc3e:	0f b6       	in	r0, 0x3f	; 63
    dc40:	f8 94       	cli
    dc42:	de bf       	out	0x3e, r29	; 62
    dc44:	0f be       	out	0x3f, r0	; 63
    dc46:	cd bf       	out	0x3d, r28	; 61
    dc48:	cf 91       	pop	r28
    dc4a:	df 91       	pop	r29
    dc4c:	08 95       	ret

0000dc4e <FSettingPumpPooling>:
	      break;
	 }
     return Result;
}

char FSettingPumpPooling(){//Parameter: PumpCount,
    dc4e:	0f 93       	push	r16
    dc50:	1f 93       	push	r17
    dc52:	df 93       	push	r29
    dc54:	cf 93       	push	r28
    dc56:	cd b7       	in	r28, 0x3d	; 61
    dc58:	de b7       	in	r29, 0x3e	; 62
    dc5a:	6a 97       	sbiw	r28, 0x1a	; 26
    dc5c:	0f b6       	in	r0, 0x3f	; 63
    dc5e:	f8 94       	cli
    dc60:	de bf       	out	0x3e, r29	; 62
    dc62:	0f be       	out	0x3f, r0	; 63
    dc64:	cd bf       	out	0x3d, r28	; 61
static char stPumpPooling=ppInitMenu;
char i,lcdteks[20];
char KeyChar,Addr=0,PPoolingSetting[6];
     Result=MENU_NONE;

     switch(stPumpPooling){
    dc66:	80 91 df 02 	lds	r24, 0x02DF
    dc6a:	82 30       	cpi	r24, 0x02	; 2
    dc6c:	09 f4       	brne	.+2      	; 0xdc70 <FSettingPumpPooling+0x22>
    dc6e:	1b c1       	rjmp	.+566    	; 0xdea6 <FSettingPumpPooling+0x258>
    dc70:	83 30       	cpi	r24, 0x03	; 3
    dc72:	30 f4       	brcc	.+12     	; 0xdc80 <FSettingPumpPooling+0x32>
    dc74:	88 23       	and	r24, r24
    dc76:	59 f0       	breq	.+22     	; 0xdc8e <FSettingPumpPooling+0x40>
    dc78:	81 30       	cpi	r24, 0x01	; 1
    dc7a:	09 f0       	breq	.+2      	; 0xdc7e <FSettingPumpPooling+0x30>
    dc7c:	1b c2       	rjmp	.+1078   	; 0xe0b4 <FSettingPumpPooling+0x466>
    dc7e:	09 c1       	rjmp	.+530    	; 0xde92 <FSettingPumpPooling+0x244>
    dc80:	83 30       	cpi	r24, 0x03	; 3
    dc82:	09 f4       	brne	.+2      	; 0xdc86 <FSettingPumpPooling+0x38>
    dc84:	06 c2       	rjmp	.+1036   	; 0xe092 <FSettingPumpPooling+0x444>
    dc86:	84 30       	cpi	r24, 0x04	; 4
    dc88:	09 f0       	breq	.+2      	; 0xdc8c <FSettingPumpPooling+0x3e>
    dc8a:	14 c2       	rjmp	.+1064   	; 0xe0b4 <FSettingPumpPooling+0x466>
    dc8c:	0f c2       	rjmp	.+1054   	; 0xe0ac <FSettingPumpPooling+0x45e>
	 case ppInitMenu:
          lcd_clear();
    dc8e:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
    dc92:	20 e0       	ldi	r18, 0x00	; 0
    dc94:	30 e0       	ldi	r19, 0x00	; 0
		  for (i=0;i<6;i++){
		      PPoolingSetting[i]=eeprom_read_byte(&DefPoolingPumpMax+i);
    dc96:	ae 01       	movw	r20, r28
    dc98:	4f 5f       	subi	r20, 0xFF	; 255
    dc9a:	5f 4f       	sbci	r21, 0xFF	; 255
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    dc9c:	e1 99       	sbic	0x1c, 1	; 28
    dc9e:	fe cf       	rjmp	.-4      	; 0xdc9c <FSettingPumpPooling+0x4e>
    dca0:	c9 01       	movw	r24, r18
    dca2:	8c 5b       	subi	r24, 0xBC	; 188
    dca4:	9e 4f       	sbci	r25, 0xFE	; 254
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    dca6:	9f bb       	out	0x1f, r25	; 31
    dca8:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    dcaa:	e0 9a       	sbi	0x1c, 0	; 28
    dcac:	8d b3       	in	r24, 0x1d	; 29
    dcae:	fa 01       	movw	r30, r20
    dcb0:	e2 0f       	add	r30, r18
    dcb2:	f3 1f       	adc	r31, r19
    dcb4:	80 83       	st	Z, r24
    dcb6:	2f 5f       	subi	r18, 0xFF	; 255
    dcb8:	3f 4f       	sbci	r19, 0xFF	; 255
     Result=MENU_NONE;

     switch(stPumpPooling){
	 case ppInitMenu:
          lcd_clear();
		  for (i=0;i<6;i++){
    dcba:	26 30       	cpi	r18, 0x06	; 6
    dcbc:	31 05       	cpc	r19, r1
    dcbe:	71 f7       	brne	.-36     	; 0xdc9c <FSettingPumpPooling+0x4e>
		      PPoolingSetting[i]=eeprom_read_byte(&DefPoolingPumpMax+i);
		  }

		  sprintf_P(lcdteks,PSTR("1.MaxPump:%d"),PPoolingSetting[0]);lcd_print(1,1,lcdteks);
    dcc0:	00 d0       	rcall	.+0      	; 0xdcc2 <FSettingPumpPooling+0x74>
    dcc2:	00 d0       	rcall	.+0      	; 0xdcc4 <FSettingPumpPooling+0x76>
    dcc4:	00 d0       	rcall	.+0      	; 0xdcc6 <FSettingPumpPooling+0x78>
    dcc6:	ed b7       	in	r30, 0x3d	; 61
    dcc8:	fe b7       	in	r31, 0x3e	; 62
    dcca:	31 96       	adiw	r30, 0x01	; 1
    dccc:	8e 01       	movw	r16, r28
    dcce:	09 5f       	subi	r16, 0xF9	; 249
    dcd0:	1f 4f       	sbci	r17, 0xFF	; 255
    dcd2:	ad b7       	in	r26, 0x3d	; 61
    dcd4:	be b7       	in	r27, 0x3e	; 62
    dcd6:	12 96       	adiw	r26, 0x02	; 2
    dcd8:	1c 93       	st	X, r17
    dcda:	0e 93       	st	-X, r16
    dcdc:	11 97       	sbiw	r26, 0x01	; 1
    dcde:	8c e9       	ldi	r24, 0x9C	; 156
    dce0:	9d e0       	ldi	r25, 0x0D	; 13
    dce2:	93 83       	std	Z+3, r25	; 0x03
    dce4:	82 83       	std	Z+2, r24	; 0x02
    dce6:	89 81       	ldd	r24, Y+1	; 0x01
    dce8:	84 83       	std	Z+4, r24	; 0x04
    dcea:	15 82       	std	Z+5, r1	; 0x05
    dcec:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    dcf0:	ed b7       	in	r30, 0x3d	; 61
    dcf2:	fe b7       	in	r31, 0x3e	; 62
    dcf4:	36 96       	adiw	r30, 0x06	; 6
    dcf6:	0f b6       	in	r0, 0x3f	; 63
    dcf8:	f8 94       	cli
    dcfa:	fe bf       	out	0x3e, r31	; 62
    dcfc:	0f be       	out	0x3f, r0	; 63
    dcfe:	ed bf       	out	0x3d, r30	; 61
    dd00:	81 e0       	ldi	r24, 0x01	; 1
    dd02:	61 e0       	ldi	r22, 0x01	; 1
    dd04:	a8 01       	movw	r20, r16
    dd06:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
          sprintf_P(lcdteks,PSTR("2.nNoPump:%d"),PPoolingSetting[1]);lcd_print(2,1,lcdteks);
    dd0a:	00 d0       	rcall	.+0      	; 0xdd0c <FSettingPumpPooling+0xbe>
    dd0c:	00 d0       	rcall	.+0      	; 0xdd0e <FSettingPumpPooling+0xc0>
    dd0e:	00 d0       	rcall	.+0      	; 0xdd10 <FSettingPumpPooling+0xc2>
    dd10:	ed b7       	in	r30, 0x3d	; 61
    dd12:	fe b7       	in	r31, 0x3e	; 62
    dd14:	31 96       	adiw	r30, 0x01	; 1
    dd16:	ad b7       	in	r26, 0x3d	; 61
    dd18:	be b7       	in	r27, 0x3e	; 62
    dd1a:	12 96       	adiw	r26, 0x02	; 2
    dd1c:	1c 93       	st	X, r17
    dd1e:	0e 93       	st	-X, r16
    dd20:	11 97       	sbiw	r26, 0x01	; 1
    dd22:	8f e8       	ldi	r24, 0x8F	; 143
    dd24:	9d e0       	ldi	r25, 0x0D	; 13
    dd26:	93 83       	std	Z+3, r25	; 0x03
    dd28:	82 83       	std	Z+2, r24	; 0x02
    dd2a:	8a 81       	ldd	r24, Y+2	; 0x02
    dd2c:	84 83       	std	Z+4, r24	; 0x04
    dd2e:	15 82       	std	Z+5, r1	; 0x05
    dd30:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    dd34:	ed b7       	in	r30, 0x3d	; 61
    dd36:	fe b7       	in	r31, 0x3e	; 62
    dd38:	36 96       	adiw	r30, 0x06	; 6
    dd3a:	0f b6       	in	r0, 0x3f	; 63
    dd3c:	f8 94       	cli
    dd3e:	fe bf       	out	0x3e, r31	; 62
    dd40:	0f be       	out	0x3f, r0	; 63
    dd42:	ed bf       	out	0x3d, r30	; 61
    dd44:	82 e0       	ldi	r24, 0x02	; 2
    dd46:	61 e0       	ldi	r22, 0x01	; 1
    dd48:	a8 01       	movw	r20, r16
    dd4a:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
          sprintf_P(lcdteks,PSTR("3.TrySend:%d"),PPoolingSetting[2]);lcd_print(3,1,lcdteks);
    dd4e:	00 d0       	rcall	.+0      	; 0xdd50 <FSettingPumpPooling+0x102>
    dd50:	00 d0       	rcall	.+0      	; 0xdd52 <FSettingPumpPooling+0x104>
    dd52:	00 d0       	rcall	.+0      	; 0xdd54 <FSettingPumpPooling+0x106>
    dd54:	ed b7       	in	r30, 0x3d	; 61
    dd56:	fe b7       	in	r31, 0x3e	; 62
    dd58:	31 96       	adiw	r30, 0x01	; 1
    dd5a:	ad b7       	in	r26, 0x3d	; 61
    dd5c:	be b7       	in	r27, 0x3e	; 62
    dd5e:	12 96       	adiw	r26, 0x02	; 2
    dd60:	1c 93       	st	X, r17
    dd62:	0e 93       	st	-X, r16
    dd64:	11 97       	sbiw	r26, 0x01	; 1
    dd66:	82 e8       	ldi	r24, 0x82	; 130
    dd68:	9d e0       	ldi	r25, 0x0D	; 13
    dd6a:	93 83       	std	Z+3, r25	; 0x03
    dd6c:	82 83       	std	Z+2, r24	; 0x02
    dd6e:	8b 81       	ldd	r24, Y+3	; 0x03
    dd70:	84 83       	std	Z+4, r24	; 0x04
    dd72:	15 82       	std	Z+5, r1	; 0x05
    dd74:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    dd78:	ed b7       	in	r30, 0x3d	; 61
    dd7a:	fe b7       	in	r31, 0x3e	; 62
    dd7c:	36 96       	adiw	r30, 0x06	; 6
    dd7e:	0f b6       	in	r0, 0x3f	; 63
    dd80:	f8 94       	cli
    dd82:	fe bf       	out	0x3e, r31	; 62
    dd84:	0f be       	out	0x3f, r0	; 63
    dd86:	ed bf       	out	0x3d, r30	; 61
    dd88:	83 e0       	ldi	r24, 0x03	; 3
    dd8a:	61 e0       	ldi	r22, 0x01	; 1
    dd8c:	a8 01       	movw	r20, r16
    dd8e:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
          sprintf_P(lcdteks,PSTR("4.TimPool:%d"),PPoolingSetting[3]);lcd_print(4,1,lcdteks);
    dd92:	00 d0       	rcall	.+0      	; 0xdd94 <FSettingPumpPooling+0x146>
    dd94:	00 d0       	rcall	.+0      	; 0xdd96 <FSettingPumpPooling+0x148>
    dd96:	00 d0       	rcall	.+0      	; 0xdd98 <FSettingPumpPooling+0x14a>
    dd98:	ed b7       	in	r30, 0x3d	; 61
    dd9a:	fe b7       	in	r31, 0x3e	; 62
    dd9c:	31 96       	adiw	r30, 0x01	; 1
    dd9e:	ad b7       	in	r26, 0x3d	; 61
    dda0:	be b7       	in	r27, 0x3e	; 62
    dda2:	12 96       	adiw	r26, 0x02	; 2
    dda4:	1c 93       	st	X, r17
    dda6:	0e 93       	st	-X, r16
    dda8:	11 97       	sbiw	r26, 0x01	; 1
    ddaa:	85 e7       	ldi	r24, 0x75	; 117
    ddac:	9d e0       	ldi	r25, 0x0D	; 13
    ddae:	93 83       	std	Z+3, r25	; 0x03
    ddb0:	82 83       	std	Z+2, r24	; 0x02
    ddb2:	8c 81       	ldd	r24, Y+4	; 0x04
    ddb4:	84 83       	std	Z+4, r24	; 0x04
    ddb6:	15 82       	std	Z+5, r1	; 0x05
    ddb8:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    ddbc:	ed b7       	in	r30, 0x3d	; 61
    ddbe:	fe b7       	in	r31, 0x3e	; 62
    ddc0:	36 96       	adiw	r30, 0x06	; 6
    ddc2:	0f b6       	in	r0, 0x3f	; 63
    ddc4:	f8 94       	cli
    ddc6:	fe bf       	out	0x3e, r31	; 62
    ddc8:	0f be       	out	0x3f, r0	; 63
    ddca:	ed bf       	out	0x3d, r30	; 61
    ddcc:	84 e0       	ldi	r24, 0x04	; 4
    ddce:	61 e0       	ldi	r22, 0x01	; 1
    ddd0:	a8 01       	movw	r20, r16
    ddd2:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
          sprintf_P(lcdteks,PSTR("5.Dly:%d"),PPoolingSetting[4]);lcd_print(1,13,lcdteks);
    ddd6:	00 d0       	rcall	.+0      	; 0xddd8 <FSettingPumpPooling+0x18a>
    ddd8:	00 d0       	rcall	.+0      	; 0xddda <FSettingPumpPooling+0x18c>
    ddda:	00 d0       	rcall	.+0      	; 0xdddc <FSettingPumpPooling+0x18e>
    dddc:	ed b7       	in	r30, 0x3d	; 61
    ddde:	fe b7       	in	r31, 0x3e	; 62
    dde0:	31 96       	adiw	r30, 0x01	; 1
    dde2:	ad b7       	in	r26, 0x3d	; 61
    dde4:	be b7       	in	r27, 0x3e	; 62
    dde6:	12 96       	adiw	r26, 0x02	; 2
    dde8:	1c 93       	st	X, r17
    ddea:	0e 93       	st	-X, r16
    ddec:	11 97       	sbiw	r26, 0x01	; 1
    ddee:	8c e6       	ldi	r24, 0x6C	; 108
    ddf0:	9d e0       	ldi	r25, 0x0D	; 13
    ddf2:	93 83       	std	Z+3, r25	; 0x03
    ddf4:	82 83       	std	Z+2, r24	; 0x02
    ddf6:	8d 81       	ldd	r24, Y+5	; 0x05
    ddf8:	84 83       	std	Z+4, r24	; 0x04
    ddfa:	15 82       	std	Z+5, r1	; 0x05
    ddfc:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    de00:	ed b7       	in	r30, 0x3d	; 61
    de02:	fe b7       	in	r31, 0x3e	; 62
    de04:	36 96       	adiw	r30, 0x06	; 6
    de06:	0f b6       	in	r0, 0x3f	; 63
    de08:	f8 94       	cli
    de0a:	fe bf       	out	0x3e, r31	; 62
    de0c:	0f be       	out	0x3f, r0	; 63
    de0e:	ed bf       	out	0x3d, r30	; 61
    de10:	81 e0       	ldi	r24, 0x01	; 1
    de12:	6d e0       	ldi	r22, 0x0D	; 13
    de14:	a8 01       	movw	r20, r16
    de16:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
          sprintf_P(lcdteks,PSTR("6.Act:%d"),PPoolingSetting[5]);lcd_print(2,13,lcdteks);
    de1a:	00 d0       	rcall	.+0      	; 0xde1c <FSettingPumpPooling+0x1ce>
    de1c:	00 d0       	rcall	.+0      	; 0xde1e <FSettingPumpPooling+0x1d0>
    de1e:	00 d0       	rcall	.+0      	; 0xde20 <FSettingPumpPooling+0x1d2>
    de20:	ed b7       	in	r30, 0x3d	; 61
    de22:	fe b7       	in	r31, 0x3e	; 62
    de24:	31 96       	adiw	r30, 0x01	; 1
    de26:	ad b7       	in	r26, 0x3d	; 61
    de28:	be b7       	in	r27, 0x3e	; 62
    de2a:	12 96       	adiw	r26, 0x02	; 2
    de2c:	1c 93       	st	X, r17
    de2e:	0e 93       	st	-X, r16
    de30:	11 97       	sbiw	r26, 0x01	; 1
    de32:	83 e6       	ldi	r24, 0x63	; 99
    de34:	9d e0       	ldi	r25, 0x0D	; 13
    de36:	93 83       	std	Z+3, r25	; 0x03
    de38:	82 83       	std	Z+2, r24	; 0x02
    de3a:	8e 81       	ldd	r24, Y+6	; 0x06
    de3c:	84 83       	std	Z+4, r24	; 0x04
    de3e:	15 82       	std	Z+5, r1	; 0x05
    de40:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    de44:	ed b7       	in	r30, 0x3d	; 61
    de46:	fe b7       	in	r31, 0x3e	; 62
    de48:	36 96       	adiw	r30, 0x06	; 6
    de4a:	0f b6       	in	r0, 0x3f	; 63
    de4c:	f8 94       	cli
    de4e:	fe bf       	out	0x3e, r31	; 62
    de50:	0f be       	out	0x3f, r0	; 63
    de52:	ed bf       	out	0x3d, r30	; 61
    de54:	82 e0       	ldi	r24, 0x02	; 2
    de56:	6d e0       	ldi	r22, 0x0D	; 13
    de58:	a8 01       	movw	r20, r16
    de5a:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
          sprintf_P(lcdteks,PSTR("[*]Exit"));lcd_print(4,13,lcdteks);
    de5e:	00 d0       	rcall	.+0      	; 0xde60 <FSettingPumpPooling+0x212>
    de60:	00 d0       	rcall	.+0      	; 0xde62 <FSettingPumpPooling+0x214>
    de62:	ad b7       	in	r26, 0x3d	; 61
    de64:	be b7       	in	r27, 0x3e	; 62
    de66:	12 96       	adiw	r26, 0x02	; 2
    de68:	1c 93       	st	X, r17
    de6a:	0e 93       	st	-X, r16
    de6c:	11 97       	sbiw	r26, 0x01	; 1
    de6e:	8b e5       	ldi	r24, 0x5B	; 91
    de70:	9d e0       	ldi	r25, 0x0D	; 13
    de72:	14 96       	adiw	r26, 0x04	; 4
    de74:	9c 93       	st	X, r25
    de76:	8e 93       	st	-X, r24
    de78:	13 97       	sbiw	r26, 0x03	; 3
    de7a:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    de7e:	0f 90       	pop	r0
    de80:	0f 90       	pop	r0
    de82:	0f 90       	pop	r0
    de84:	0f 90       	pop	r0
    de86:	84 e0       	ldi	r24, 0x04	; 4
    de88:	6d e0       	ldi	r22, 0x0D	; 13
    de8a:	a8 01       	movw	r20, r16
    de8c:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
    de90:	08 c0       	rjmp	.+16     	; 0xdea2 <FSettingPumpPooling+0x254>

          stPumpPooling=ppPoolingSettingInput;
	      break;
     case ppDisplaySequence:
          IsNewPoolingSequence=False;
    de92:	10 92 94 01 	sts	0x0194, r1
		  DisplayStandaloneSequence(3,14,iSequencePooling);
    de96:	83 e0       	ldi	r24, 0x03	; 3
    de98:	6e e0       	ldi	r22, 0x0E	; 14
    de9a:	40 91 93 01 	lds	r20, 0x0193
    de9e:	0e 94 f1 6d 	call	0xdbe2	; 0xdbe2 <DisplayStandaloneSequence>
          stPumpPooling=ppPoolingSettingInput;
    dea2:	82 e0       	ldi	r24, 0x02	; 2
    dea4:	f3 c0       	rjmp	.+486    	; 0xe08c <FSettingPumpPooling+0x43e>
	      break;
     case ppPoolingSettingInput:
	      if(IsNewPoolingSequence==True)stPumpPooling=ppDisplaySequence;
    dea6:	80 91 94 01 	lds	r24, 0x0194
    deaa:	81 30       	cpi	r24, 0x01	; 1
    deac:	11 f4       	brne	.+4      	; 0xdeb2 <FSettingPumpPooling+0x264>
    deae:	80 93 df 02 	sts	0x02DF, r24

          KeyChar=_key_btn(_key_scan(1));
    deb2:	81 e0       	ldi	r24, 0x01	; 1
    deb4:	0e 94 ab ae 	call	0x15d56	; 0x15d56 <_key_scan>
    deb8:	0e 94 0c ae 	call	0x15c18	; 0x15c18 <_key_btn>
		  if ((KeyChar>='1')&&(KeyChar<='6')){
    debc:	48 2f       	mov	r20, r24
    debe:	41 53       	subi	r20, 0x31	; 49
    dec0:	46 30       	cpi	r20, 0x06	; 6
    dec2:	10 f0       	brcs	.+4      	; 0xdec8 <FSettingPumpPooling+0x27a>
    dec4:	40 e0       	ldi	r20, 0x00	; 0
    dec6:	06 c0       	rjmp	.+12     	; 0xded4 <FSettingPumpPooling+0x286>
		      Addr=KeyChar-'1';
			  TimSend=0;
    dec8:	10 92 a9 01 	sts	0x01A9, r1
    decc:	10 92 a8 01 	sts	0x01A8, r1
			  IsStandaloneAcknoledge=False;
    ded0:	10 92 95 01 	sts	0x0195, r1
          }
		  switch(KeyChar){
    ded4:	83 33       	cpi	r24, 0x33	; 51
    ded6:	09 f4       	brne	.+2      	; 0xdeda <FSettingPumpPooling+0x28c>
    ded8:	67 c0       	rjmp	.+206    	; 0xdfa8 <FSettingPumpPooling+0x35a>
    deda:	84 33       	cpi	r24, 0x34	; 52
    dedc:	48 f4       	brcc	.+18     	; 0xdef0 <FSettingPumpPooling+0x2a2>
    dede:	81 33       	cpi	r24, 0x31	; 49
    dee0:	89 f0       	breq	.+34     	; 0xdf04 <FSettingPumpPooling+0x2b6>
    dee2:	82 33       	cpi	r24, 0x32	; 50
    dee4:	08 f0       	brcs	.+2      	; 0xdee8 <FSettingPumpPooling+0x29a>
    dee6:	3d c0       	rjmp	.+122    	; 0xdf62 <FSettingPumpPooling+0x314>
    dee8:	8a 32       	cpi	r24, 0x2A	; 42
    deea:	09 f0       	breq	.+2      	; 0xdeee <FSettingPumpPooling+0x2a0>
    deec:	e3 c0       	rjmp	.+454    	; 0xe0b4 <FSettingPumpPooling+0x466>
    deee:	cd c0       	rjmp	.+410    	; 0xe08a <FSettingPumpPooling+0x43c>
    def0:	85 33       	cpi	r24, 0x35	; 53
    def2:	09 f4       	brne	.+2      	; 0xdef6 <FSettingPumpPooling+0x2a8>
    def4:	91 c0       	rjmp	.+290    	; 0xe018 <FSettingPumpPooling+0x3ca>
    def6:	85 33       	cpi	r24, 0x35	; 53
    def8:	08 f4       	brcc	.+2      	; 0xdefc <FSettingPumpPooling+0x2ae>
    defa:	78 c0       	rjmp	.+240    	; 0xdfec <FSettingPumpPooling+0x39e>
    defc:	86 33       	cpi	r24, 0x36	; 54
    defe:	09 f0       	breq	.+2      	; 0xdf02 <FSettingPumpPooling+0x2b4>
    df00:	d9 c0       	rjmp	.+434    	; 0xe0b4 <FSettingPumpPooling+0x466>
    df02:	a0 c0       	rjmp	.+320    	; 0xe044 <FSettingPumpPooling+0x3f6>
		  case '1'://MaxPump
		       PPoolingSetting[Addr]=((PPoolingSetting[Addr]+1)%17);
    df04:	24 2f       	mov	r18, r20
    df06:	30 e0       	ldi	r19, 0x00	; 0
    df08:	fe 01       	movw	r30, r28
    df0a:	31 96       	adiw	r30, 0x01	; 1
    df0c:	e2 0f       	add	r30, r18
    df0e:	f3 1f       	adc	r31, r19
    df10:	80 81       	ld	r24, Z
    df12:	90 e0       	ldi	r25, 0x00	; 0
    df14:	01 96       	adiw	r24, 0x01	; 1
    df16:	61 e1       	ldi	r22, 0x11	; 17
    df18:	70 e0       	ldi	r23, 0x00	; 0
    df1a:	0e 94 4c b7 	call	0x16e98	; 0x16e98 <__divmodhi4>
    df1e:	80 83       	st	Z, r24
			   if (PPoolingSetting[Addr]==0)PPoolingSetting[Addr]=1;
    df20:	88 23       	and	r24, r24
    df22:	11 f4       	brne	.+4      	; 0xdf28 <FSettingPumpPooling+0x2da>
    df24:	81 e0       	ldi	r24, 0x01	; 1
    df26:	80 83       	st	Z, r24
			   //SendSlaveCommand(SC_SET_POOLING_MAX_PUMP,PPoolingSetting[Addr]);
			   SendPoolingCommand(SC_SET_POOLING_MAX_PUMP,PPoolingSetting[Addr]);
    df28:	2c 0f       	add	r18, r28
    df2a:	3d 1f       	adc	r19, r29
    df2c:	f9 01       	movw	r30, r18
    df2e:	21 81       	ldd	r18, Z+1	; 0x01
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    df30:	85 e1       	ldi	r24, 0x15	; 21
    df32:	80 93 8a 07 	sts	0x078A, r24
	 PoolMsg=plMsg;
    df36:	20 93 ae 0d 	sts	0x0DAE, r18
     IsControlPooling=True;
    df3a:	81 e0       	ldi	r24, 0x01	; 1
    df3c:	80 93 97 01 	sts	0x0197, r24
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    df40:	e1 99       	sbic	0x1c, 1	; 28
    df42:	fe cf       	rjmp	.-4      	; 0xdf40 <FSettingPumpPooling+0x2f2>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    df44:	84 2f       	mov	r24, r20
    df46:	90 e0       	ldi	r25, 0x00	; 0
    df48:	8c 5b       	subi	r24, 0xBC	; 188
    df4a:	9e 4f       	sbci	r25, 0xFE	; 254
    df4c:	9f bb       	out	0x1f, r25	; 31
    df4e:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    df50:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
    df52:	0f b6       	in	r0, 0x3f	; 63
    df54:	f8 94       	cli
    df56:	e2 9a       	sbi	0x1c, 2	; 28
    df58:	e1 9a       	sbi	0x1c, 1	; 28
    df5a:	0f be       	out	0x3f, r0	; 63
			   if (PPoolingSetting[Addr]==0)PPoolingSetting[Addr]=1;
			   //SendSlaveCommand(SC_SET_POOLING_MAX_PUMP,PPoolingSetting[Addr]);
			   SendPoolingCommand(SC_SET_POOLING_MAX_PUMP,PPoolingSetting[Addr]);

			   eeprom_write_byte(&DefPoolingPumpMax+Addr,PPoolingSetting[Addr]);
			   PumpCountMax=PPoolingSetting[Addr];
    df5c:	20 93 5f 01 	sts	0x015F, r18
    df60:	21 c0       	rjmp	.+66     	; 0xdfa4 <FSettingPumpPooling+0x356>
			   //stPumpPooling=ppInitMenu;
			   stPumpPooling=ppWaitPoolingRespond;
		       break;
		  case '2'://NoPump
		       PPoolingSetting[Addr]=((PPoolingSetting[Addr]+1)%21);
    df62:	fe 01       	movw	r30, r28
    df64:	e4 0f       	add	r30, r20
    df66:	f1 1d       	adc	r31, r1
    df68:	81 81       	ldd	r24, Z+1	; 0x01
    df6a:	90 e0       	ldi	r25, 0x00	; 0
    df6c:	01 96       	adiw	r24, 0x01	; 1
    df6e:	65 e1       	ldi	r22, 0x15	; 21
    df70:	70 e0       	ldi	r23, 0x00	; 0
    df72:	0e 94 4c b7 	call	0x16e98	; 0x16e98 <__divmodhi4>
    df76:	28 2f       	mov	r18, r24
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    df78:	84 e1       	ldi	r24, 0x14	; 20
    df7a:	80 93 8a 07 	sts	0x078A, r24
	 PoolMsg=plMsg;
    df7e:	20 93 ae 0d 	sts	0x0DAE, r18
     IsControlPooling=True;
    df82:	81 e0       	ldi	r24, 0x01	; 1
    df84:	80 93 97 01 	sts	0x0197, r24
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    df88:	e1 99       	sbic	0x1c, 1	; 28
    df8a:	fe cf       	rjmp	.-4      	; 0xdf88 <FSettingPumpPooling+0x33a>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    df8c:	84 2f       	mov	r24, r20
    df8e:	90 e0       	ldi	r25, 0x00	; 0
    df90:	8c 5b       	subi	r24, 0xBC	; 188
    df92:	9e 4f       	sbci	r25, 0xFE	; 254
    df94:	9f bb       	out	0x1f, r25	; 31
    df96:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    df98:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
    df9a:	0f b6       	in	r0, 0x3f	; 63
    df9c:	f8 94       	cli
    df9e:	e2 9a       	sbi	0x1c, 2	; 28
    dfa0:	e1 9a       	sbi	0x1c, 1	; 28
    dfa2:	0f be       	out	0x3f, r0	; 63
			   //SendSlaveCommand(SC_SET_POOLING_NO_PUMP_COUNT,PPoolingSetting[Addr]);
			   SendPoolingCommand(SC_SET_POOLING_NO_PUMP_COUNT,PPoolingSetting[Addr]);

			   eeprom_write_byte(&DefPoolingPumpMax+Addr,PPoolingSetting[Addr]);
			   //stPumpPooling=ppInitMenu;
			   stPumpPooling=ppWaitPoolingRespond;
    dfa4:	83 e0       	ldi	r24, 0x03	; 3
    dfa6:	72 c0       	rjmp	.+228    	; 0xe08c <FSettingPumpPooling+0x43e>
		       break;
		  case '3'://TrySend
		       PPoolingSetting[Addr]=((PPoolingSetting[Addr]+1)%21);
    dfa8:	24 2f       	mov	r18, r20
    dfaa:	30 e0       	ldi	r19, 0x00	; 0
    dfac:	fe 01       	movw	r30, r28
    dfae:	31 96       	adiw	r30, 0x01	; 1
    dfb0:	e2 0f       	add	r30, r18
    dfb2:	f3 1f       	adc	r31, r19
    dfb4:	80 81       	ld	r24, Z
    dfb6:	90 e0       	ldi	r25, 0x00	; 0
    dfb8:	01 96       	adiw	r24, 0x01	; 1
    dfba:	65 e1       	ldi	r22, 0x15	; 21
    dfbc:	70 e0       	ldi	r23, 0x00	; 0
    dfbe:	0e 94 4c b7 	call	0x16e98	; 0x16e98 <__divmodhi4>
    dfc2:	80 83       	st	Z, r24
			   if (PPoolingSetting[Addr]==0)PPoolingSetting[Addr]=1;
    dfc4:	88 23       	and	r24, r24
    dfc6:	11 f4       	brne	.+4      	; 0xdfcc <FSettingPumpPooling+0x37e>
    dfc8:	81 e0       	ldi	r24, 0x01	; 1
    dfca:	80 83       	st	Z, r24
			   //SendSlaveCommand(SC_SET_POOLING_SEND,PPoolingSetting[Addr]);
			   SendPoolingCommand(SC_SET_POOLING_SEND,PPoolingSetting[Addr]);
    dfcc:	2c 0f       	add	r18, r28
    dfce:	3d 1f       	adc	r19, r29
    dfd0:	d9 01       	movw	r26, r18
    dfd2:	11 96       	adiw	r26, 0x01	; 1
    dfd4:	2c 91       	ld	r18, X
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    dfd6:	86 e1       	ldi	r24, 0x16	; 22
    dfd8:	80 93 8a 07 	sts	0x078A, r24
	 PoolMsg=plMsg;
    dfdc:	20 93 ae 0d 	sts	0x0DAE, r18
     IsControlPooling=True;
    dfe0:	81 e0       	ldi	r24, 0x01	; 1
    dfe2:	80 93 97 01 	sts	0x0197, r24
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    dfe6:	e1 99       	sbic	0x1c, 1	; 28
    dfe8:	fe cf       	rjmp	.-4      	; 0xdfe6 <FSettingPumpPooling+0x398>
    dfea:	d0 cf       	rjmp	.-96     	; 0xdf8c <FSettingPumpPooling+0x33e>
			   eeprom_write_byte(&DefPoolingPumpMax+Addr,PPoolingSetting[Addr]);
			   //stPumpPooling=ppInitMenu;
			   stPumpPooling=ppWaitPoolingRespond;
		       break;
		  case '4'://TimPool
		       PPoolingSetting[Addr]=((PPoolingSetting[Addr]+1)%21);
    dfec:	fe 01       	movw	r30, r28
    dfee:	e4 0f       	add	r30, r20
    dff0:	f1 1d       	adc	r31, r1
    dff2:	81 81       	ldd	r24, Z+1	; 0x01
    dff4:	90 e0       	ldi	r25, 0x00	; 0
    dff6:	01 96       	adiw	r24, 0x01	; 1
    dff8:	65 e1       	ldi	r22, 0x15	; 21
    dffa:	70 e0       	ldi	r23, 0x00	; 0
    dffc:	0e 94 4c b7 	call	0x16e98	; 0x16e98 <__divmodhi4>
    e000:	28 2f       	mov	r18, r24
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    e002:	87 e1       	ldi	r24, 0x17	; 23
    e004:	80 93 8a 07 	sts	0x078A, r24
	 PoolMsg=plMsg;
    e008:	20 93 ae 0d 	sts	0x0DAE, r18
     IsControlPooling=True;
    e00c:	81 e0       	ldi	r24, 0x01	; 1
    e00e:	80 93 97 01 	sts	0x0197, r24
    e012:	e1 99       	sbic	0x1c, 1	; 28
    e014:	fe cf       	rjmp	.-4      	; 0xe012 <FSettingPumpPooling+0x3c4>
    e016:	ba cf       	rjmp	.-140    	; 0xdf8c <FSettingPumpPooling+0x33e>
			   eeprom_write_byte(&DefPoolingPumpMax+Addr,PPoolingSetting[Addr]);
			   //stPumpPooling=ppInitMenu;
			   stPumpPooling=ppWaitPoolingRespond;
		       break;
		  case '5'://DelayNextPump
		       PPoolingSetting[Addr]=((PPoolingSetting[Addr]+1)%41); 
    e018:	fe 01       	movw	r30, r28
    e01a:	e4 0f       	add	r30, r20
    e01c:	f1 1d       	adc	r31, r1
    e01e:	81 81       	ldd	r24, Z+1	; 0x01
    e020:	90 e0       	ldi	r25, 0x00	; 0
    e022:	01 96       	adiw	r24, 0x01	; 1
    e024:	69 e2       	ldi	r22, 0x29	; 41
    e026:	70 e0       	ldi	r23, 0x00	; 0
    e028:	0e 94 4c b7 	call	0x16e98	; 0x16e98 <__divmodhi4>
    e02c:	28 2f       	mov	r18, r24
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    e02e:	88 e1       	ldi	r24, 0x18	; 24
    e030:	80 93 8a 07 	sts	0x078A, r24
	 PoolMsg=plMsg;
    e034:	20 93 ae 0d 	sts	0x0DAE, r18
     IsControlPooling=True;
    e038:	81 e0       	ldi	r24, 0x01	; 1
    e03a:	80 93 97 01 	sts	0x0197, r24
    e03e:	e1 99       	sbic	0x1c, 1	; 28
    e040:	fe cf       	rjmp	.-4      	; 0xe03e <FSettingPumpPooling+0x3f0>
    e042:	a4 cf       	rjmp	.-184    	; 0xdf8c <FSettingPumpPooling+0x33e>
			   eeprom_write_byte(&DefPoolingPumpMax+Addr,PPoolingSetting[Addr]);
			   //stPumpPooling=ppInitMenu;
               stPumpPooling=ppWaitPoolingRespond;
		       break;
		  case '6'://ActivePump
		       PPoolingSetting[Addr]=((PPoolingSetting[Addr]+1)%(1+eeprom_read_byte(&DefPoolingPumpMax))); 			       
    e044:	fe 01       	movw	r30, r28
    e046:	e4 0f       	add	r30, r20
    e048:	f1 1d       	adc	r31, r1
    e04a:	21 81       	ldd	r18, Z+1	; 0x01
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    e04c:	e1 99       	sbic	0x1c, 1	; 28
    e04e:	fe cf       	rjmp	.-4      	; 0xe04c <FSettingPumpPooling+0x3fe>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    e050:	84 e4       	ldi	r24, 0x44	; 68
    e052:	91 e0       	ldi	r25, 0x01	; 1
    e054:	9f bb       	out	0x1f, r25	; 31
    e056:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    e058:	e0 9a       	sbi	0x1c, 0	; 28
    e05a:	6d b3       	in	r22, 0x1d	; 29
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    e05c:	e1 99       	sbic	0x1c, 1	; 28
    e05e:	fe cf       	rjmp	.-4      	; 0xe05c <FSettingPumpPooling+0x40e>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    e060:	84 2f       	mov	r24, r20
    e062:	90 e0       	ldi	r25, 0x00	; 0
    e064:	8c 5b       	subi	r24, 0xBC	; 188
    e066:	9e 4f       	sbci	r25, 0xFE	; 254
    e068:	9f bb       	out	0x1f, r25	; 31
    e06a:	8e bb       	out	0x1e, r24	; 30
    e06c:	82 2f       	mov	r24, r18
    e06e:	90 e0       	ldi	r25, 0x00	; 0
    e070:	70 e0       	ldi	r23, 0x00	; 0
    e072:	6f 5f       	subi	r22, 0xFF	; 255
    e074:	7f 4f       	sbci	r23, 0xFF	; 255
    e076:	01 96       	adiw	r24, 0x01	; 1
    e078:	0e 94 4c b7 	call	0x16e98	; 0x16e98 <__divmodhi4>
#endif
    EEDR = __value;
    e07c:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    e07e:	0f b6       	in	r0, 0x3f	; 63
    e080:	f8 94       	cli
    e082:	e2 9a       	sbi	0x1c, 2	; 28
    e084:	e1 9a       	sbi	0x1c, 1	; 28
    e086:	0f be       	out	0x3f, r0	; 63
    e088:	0e c0       	rjmp	.+28     	; 0xe0a6 <FSettingPumpPooling+0x458>
			   eeprom_write_byte(&DefPoolingPumpMax+Addr,PPoolingSetting[Addr]);
			   stPumpPooling=ppInitMenu;
		       break;
		  case '*'://Exit
		       stPumpPooling=ppExitSettingPooling;		            
    e08a:	84 e0       	ldi	r24, 0x04	; 4
    e08c:	80 93 df 02 	sts	0x02DF, r24
    e090:	11 c0       	rjmp	.+34     	; 0xe0b4 <FSettingPumpPooling+0x466>
		       break;
		  }  
	      break;
     case ppWaitPoolingRespond:	    
	      if ((IsStandaloneAcknoledge==True)||(TimSend>5))stPumpPooling=ppInitMenu;
    e092:	80 91 95 01 	lds	r24, 0x0195
    e096:	81 30       	cpi	r24, 0x01	; 1
    e098:	31 f0       	breq	.+12     	; 0xe0a6 <FSettingPumpPooling+0x458>
    e09a:	80 91 a8 01 	lds	r24, 0x01A8
    e09e:	90 91 a9 01 	lds	r25, 0x01A9
    e0a2:	06 97       	sbiw	r24, 0x06	; 6
    e0a4:	38 f0       	brcs	.+14     	; 0xe0b4 <FSettingPumpPooling+0x466>
    e0a6:	10 92 df 02 	sts	0x02DF, r1
    e0aa:	04 c0       	rjmp	.+8      	; 0xe0b4 <FSettingPumpPooling+0x466>
	      break;
     case ppExitSettingPooling:
          stPumpPooling=ppInitMenu;
    e0ac:	10 92 df 02 	sts	0x02DF, r1
    e0b0:	81 e0       	ldi	r24, 0x01	; 1
    e0b2:	01 c0       	rjmp	.+2      	; 0xe0b6 <FSettingPumpPooling+0x468>
    e0b4:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
    }
return Result;
}
    e0b6:	6a 96       	adiw	r28, 0x1a	; 26
    e0b8:	0f b6       	in	r0, 0x3f	; 63
    e0ba:	f8 94       	cli
    e0bc:	de bf       	out	0x3e, r29	; 62
    e0be:	0f be       	out	0x3f, r0	; 63
    e0c0:	cd bf       	out	0x3d, r28	; 61
    e0c2:	cf 91       	pop	r28
    e0c4:	df 91       	pop	r29
    e0c6:	1f 91       	pop	r17
    e0c8:	0f 91       	pop	r16
    e0ca:	08 95       	ret

0000e0cc <DisplayTicker>:
	 lcd_print(2, 1, lcdteks);
}

void DisplayTicker(){
static char stDisplayTicker=tiRight;
	switch(stDisplayTicker){
    e0cc:	80 91 71 03 	lds	r24, 0x0371
    e0d0:	81 30       	cpi	r24, 0x01	; 1
    e0d2:	81 f0       	breq	.+32     	; 0xe0f4 <DisplayTicker+0x28>
    e0d4:	81 30       	cpi	r24, 0x01	; 1
    e0d6:	28 f0       	brcs	.+10     	; 0xe0e2 <DisplayTicker+0x16>
    e0d8:	82 30       	cpi	r24, 0x02	; 2
    e0da:	91 f0       	breq	.+36     	; 0xe100 <DisplayTicker+0x34>
    e0dc:	83 30       	cpi	r24, 0x03	; 3
    e0de:	09 f5       	brne	.+66     	; 0xe122 <DisplayTicker+0x56>
    e0e0:	1a c0       	rjmp	.+52     	; 0xe116 <DisplayTicker+0x4a>
	case tiRight:
	     lcd_put(4, 1, '>');
    e0e2:	84 e0       	ldi	r24, 0x04	; 4
    e0e4:	61 e0       	ldi	r22, 0x01	; 1
    e0e6:	4e e3       	ldi	r20, 0x3E	; 62
    e0e8:	0e 94 7f ad 	call	0x15afe	; 0x15afe <lcd_put>
		 TimTicker=0;
    e0ec:	10 92 a5 01 	sts	0x01A5, r1
         stDisplayTicker=tiDelayRight;
    e0f0:	81 e0       	ldi	r24, 0x01	; 1
    e0f2:	0e c0       	rjmp	.+28     	; 0xe110 <DisplayTicker+0x44>
	break;
	case tiDelayRight:
         if (TimTicker>TICKER_DELAY)stDisplayTicker=tiLeft;	     
    e0f4:	80 91 a5 01 	lds	r24, 0x01A5
    e0f8:	8b 30       	cpi	r24, 0x0B	; 11
    e0fa:	98 f0       	brcs	.+38     	; 0xe122 <DisplayTicker+0x56>
    e0fc:	82 e0       	ldi	r24, 0x02	; 2
    e0fe:	08 c0       	rjmp	.+16     	; 0xe110 <DisplayTicker+0x44>
	     break;
	case tiLeft:
	     lcd_put(4, 1, '<');
    e100:	84 e0       	ldi	r24, 0x04	; 4
    e102:	61 e0       	ldi	r22, 0x01	; 1
    e104:	4c e3       	ldi	r20, 0x3C	; 60
    e106:	0e 94 7f ad 	call	0x15afe	; 0x15afe <lcd_put>
         TimTicker=0;
    e10a:	10 92 a5 01 	sts	0x01A5, r1
         stDisplayTicker=tiDelayLeft;
    e10e:	83 e0       	ldi	r24, 0x03	; 3
    e110:	80 93 71 03 	sts	0x0371, r24
    e114:	08 95       	ret
	break;
	case tiDelayLeft:
         if (TimTicker>TICKER_DELAY)stDisplayTicker=tiRight;	     
    e116:	80 91 a5 01 	lds	r24, 0x01A5
    e11a:	8b 30       	cpi	r24, 0x0B	; 11
    e11c:	10 f0       	brcs	.+4      	; 0xe122 <DisplayTicker+0x56>
    e11e:	10 92 71 03 	sts	0x0371, r1
    e122:	08 95       	ret

0000e124 <DisplayIdle>:
	          lcd_put(x,y,'X');     
			  }

}

void DisplayIdle(){
    e124:	6f 92       	push	r6
    e126:	7f 92       	push	r7
    e128:	8f 92       	push	r8
    e12a:	9f 92       	push	r9
    e12c:	af 92       	push	r10
    e12e:	bf 92       	push	r11
    e130:	cf 92       	push	r12
    e132:	df 92       	push	r13
    e134:	ff 92       	push	r15
    e136:	0f 93       	push	r16
    e138:	1f 93       	push	r17
    e13a:	df 93       	push	r29
    e13c:	cf 93       	push	r28
    e13e:	cd b7       	in	r28, 0x3d	; 61
    e140:	de b7       	in	r29, 0x3e	; 62
    e142:	67 97       	sbiw	r28, 0x17	; 23
    e144:	0f b6       	in	r0, 0x3f	; 63
    e146:	f8 94       	cli
    e148:	de bf       	out	0x3e, r29	; 62
    e14a:	0f be       	out	0x3f, r0	; 63
    e14c:	cd bf       	out	0x3d, r28	; 61
static unsigned int iLoopDisplayIdle=0;
static char stDispIdle=diScan;
     char i,iDisp;
     char lcdteks[20],sFIP[3];

     iLoopDisplayIdle++;
    e14e:	80 91 6e 03 	lds	r24, 0x036E
    e152:	90 91 6f 03 	lds	r25, 0x036F
    e156:	01 96       	adiw	r24, 0x01	; 1
    e158:	90 93 6f 03 	sts	0x036F, r25
    e15c:	80 93 6e 03 	sts	0x036E, r24
     //Setting DateTime ON

	if ((iLoopDisplayIdle%50)==0){
    e160:	62 e3       	ldi	r22, 0x32	; 50
    e162:	70 e0       	ldi	r23, 0x00	; 0
    e164:	0e 94 38 b7 	call	0x16e70	; 0x16e70 <__udivmodhi4>
    e168:	89 2b       	or	r24, r25
    e16a:	29 f5       	brne	.+74     	; 0xe1b6 <DisplayIdle+0x92>
	   if (IFType==IT_STANDALONE)DisplayPumpStatus();
    e16c:	80 91 10 01 	lds	r24, 0x0110
    e170:	82 30       	cpi	r24, 0x02	; 2
    e172:	11 f4       	brne	.+4      	; 0xe178 <DisplayIdle+0x54>
    e174:	0e 94 6e 41 	call	0x82dc	; 0x82dc <DisplayPumpStatus>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    e178:	e1 99       	sbic	0x1c, 1	; 28
    e17a:	fe cf       	rjmp	.-4      	; 0xe178 <DisplayIdle+0x54>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    e17c:	87 e3       	ldi	r24, 0x37	; 55
    e17e:	90 e0       	ldi	r25, 0x00	; 0
    e180:	9f bb       	out	0x1f, r25	; 31
    e182:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    e184:	e0 9a       	sbi	0x1c, 0	; 28
    e186:	8d b3       	in	r24, 0x1d	; 29
	   if(eeprom_read_byte(&DefShowDateTime)) DisplayDateTime();
    e188:	88 23       	and	r24, r24
    e18a:	19 f0       	breq	.+6      	; 0xe192 <DisplayIdle+0x6e>
    e18c:	0e 94 a0 61 	call	0xc340	; 0xc340 <DisplayDateTime>
    e190:	02 c0       	rjmp	.+4      	; 0xe196 <DisplayIdle+0x72>
       else DisplayTicker();
    e192:	0e 94 66 70 	call	0xe0cc	; 0xe0cc <DisplayTicker>
	   //Display Standalone Sequnece
	   
	   if((IFType==IT_STANDALONE)&&(IsNewPoolingSequence==True)){
    e196:	80 91 10 01 	lds	r24, 0x0110
    e19a:	82 30       	cpi	r24, 0x02	; 2
    e19c:	61 f4       	brne	.+24     	; 0xe1b6 <DisplayIdle+0x92>
    e19e:	80 91 94 01 	lds	r24, 0x0194
    e1a2:	81 30       	cpi	r24, 0x01	; 1
    e1a4:	41 f4       	brne	.+16     	; 0xe1b6 <DisplayIdle+0x92>
	       IsNewPoolingSequence=False;
    e1a6:	10 92 94 01 	sts	0x0194, r1
		   DisplayStandaloneSequence(4,18,iSequencePooling);
    e1aa:	84 e0       	ldi	r24, 0x04	; 4
    e1ac:	62 e1       	ldi	r22, 0x12	; 18
    e1ae:	40 91 93 01 	lds	r20, 0x0193
    e1b2:	0e 94 f1 6d 	call	0xdbe2	; 0xdbe2 <DisplayStandaloneSequence>

	 }
     //DisplayPumpStatus Standalone Mode

	 //Display Printing FIP
	 switch (stDispIdle){
    e1b6:	f0 90 6d 03 	lds	r15, 0x036D
    e1ba:	ff 20       	and	r15, r15
    e1bc:	29 f0       	breq	.+10     	; 0xe1c8 <DisplayIdle+0xa4>
    e1be:	81 e0       	ldi	r24, 0x01	; 1
    e1c0:	f8 16       	cp	r15, r24
    e1c2:	09 f0       	breq	.+2      	; 0xe1c6 <DisplayIdle+0xa2>
    e1c4:	58 c0       	rjmp	.+176    	; 0xe276 <DisplayIdle+0x152>
    e1c6:	2f c0       	rjmp	.+94     	; 0xe226 <DisplayIdle+0x102>
	 case diScan:
	      if (IsBusyIdlePrinting==True){
    e1c8:	f0 90 c8 01 	lds	r15, 0x01C8
    e1cc:	91 e0       	ldi	r25, 0x01	; 1
    e1ce:	f9 16       	cp	r15, r25
    e1d0:	09 f0       	breq	.+2      	; 0xe1d4 <DisplayIdle+0xb0>
    e1d2:	51 c0       	rjmp	.+162    	; 0xe276 <DisplayIdle+0x152>
		       sprintf_P(lcdteks,PSTR("Printing FIP%s "),strFIP_ID);
    e1d4:	00 d0       	rcall	.+0      	; 0xe1d6 <DisplayIdle+0xb2>
    e1d6:	00 d0       	rcall	.+0      	; 0xe1d8 <DisplayIdle+0xb4>
    e1d8:	00 d0       	rcall	.+0      	; 0xe1da <DisplayIdle+0xb6>
    e1da:	ed b7       	in	r30, 0x3d	; 61
    e1dc:	fe b7       	in	r31, 0x3e	; 62
    e1de:	31 96       	adiw	r30, 0x01	; 1
    e1e0:	8e 01       	movw	r16, r28
    e1e2:	0c 5f       	subi	r16, 0xFC	; 252
    e1e4:	1f 4f       	sbci	r17, 0xFF	; 255
    e1e6:	ad b7       	in	r26, 0x3d	; 61
    e1e8:	be b7       	in	r27, 0x3e	; 62
    e1ea:	12 96       	adiw	r26, 0x02	; 2
    e1ec:	1c 93       	st	X, r17
    e1ee:	0e 93       	st	-X, r16
    e1f0:	11 97       	sbiw	r26, 0x01	; 1
    e1f2:	84 ef       	ldi	r24, 0xF4	; 244
    e1f4:	9b e1       	ldi	r25, 0x1B	; 27
    e1f6:	93 83       	std	Z+3, r25	; 0x03
    e1f8:	82 83       	std	Z+2, r24	; 0x02
    e1fa:	8c e9       	ldi	r24, 0x9C	; 156
    e1fc:	99 e0       	ldi	r25, 0x09	; 9
    e1fe:	95 83       	std	Z+5, r25	; 0x05
    e200:	84 83       	std	Z+4, r24	; 0x04
    e202:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
			   lcd_print(3,1,lcdteks);
    e206:	ed b7       	in	r30, 0x3d	; 61
    e208:	fe b7       	in	r31, 0x3e	; 62
    e20a:	36 96       	adiw	r30, 0x06	; 6
    e20c:	0f b6       	in	r0, 0x3f	; 63
    e20e:	f8 94       	cli
    e210:	fe bf       	out	0x3e, r31	; 62
    e212:	0f be       	out	0x3f, r0	; 63
    e214:	ed bf       	out	0x3d, r30	; 61
    e216:	83 e0       	ldi	r24, 0x03	; 3
    e218:	61 e0       	ldi	r22, 0x01	; 1
    e21a:	a8 01       	movw	r20, r16
    e21c:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
			   stDispIdle=diWaitNoBusy;
    e220:	f0 92 6d 03 	sts	0x036D, r15
    e224:	28 c0       	rjmp	.+80     	; 0xe276 <DisplayIdle+0x152>
		  }         
	      break;
     case diWaitNoBusy:
	      if (IsBusyIdlePrinting==False){
    e226:	80 91 c8 01 	lds	r24, 0x01C8
    e22a:	88 23       	and	r24, r24
    e22c:	21 f5       	brne	.+72     	; 0xe276 <DisplayIdle+0x152>
		       sprintf_P(lcdteks,PSTR("                    "));
    e22e:	00 d0       	rcall	.+0      	; 0xe230 <DisplayIdle+0x10c>
    e230:	00 d0       	rcall	.+0      	; 0xe232 <DisplayIdle+0x10e>
    e232:	8e 01       	movw	r16, r28
    e234:	0c 5f       	subi	r16, 0xFC	; 252
    e236:	1f 4f       	sbci	r17, 0xFF	; 255
    e238:	ad b7       	in	r26, 0x3d	; 61
    e23a:	be b7       	in	r27, 0x3e	; 62
    e23c:	12 96       	adiw	r26, 0x02	; 2
    e23e:	1c 93       	st	X, r17
    e240:	0e 93       	st	-X, r16
    e242:	11 97       	sbiw	r26, 0x01	; 1
    e244:	8f ed       	ldi	r24, 0xDF	; 223
    e246:	9b e1       	ldi	r25, 0x1B	; 27
    e248:	14 96       	adiw	r26, 0x04	; 4
    e24a:	9c 93       	st	X, r25
    e24c:	8e 93       	st	-X, r24
    e24e:	13 97       	sbiw	r26, 0x03	; 3
    e250:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
			   lcd_print(3,1,lcdteks);
    e254:	0f 90       	pop	r0
    e256:	0f 90       	pop	r0
    e258:	0f 90       	pop	r0
    e25a:	0f 90       	pop	r0
    e25c:	83 e0       	ldi	r24, 0x03	; 3
    e25e:	61 e0       	ldi	r22, 0x01	; 1
    e260:	a8 01       	movw	r20, r16
    e262:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
			   stDispIdle=diScan;
    e266:	10 92 6d 03 	sts	0x036D, r1
			   if (nLocalAccount>0)IsViewFillingFIP=True;
    e26a:	80 91 a4 01 	lds	r24, 0x01A4
    e26e:	88 23       	and	r24, r24
    e270:	11 f0       	breq	.+4      	; 0xe276 <DisplayIdle+0x152>
    e272:	f0 92 ad 01 	sts	0x01AD, r15
		  }
	      break;     
	 }
	 //Display Filling FIP
	 if (IsViewFillingFIP==True){
    e276:	80 91 ad 01 	lds	r24, 0x01AD
    e27a:	81 30       	cpi	r24, 0x01	; 1
    e27c:	09 f0       	breq	.+2      	; 0xe280 <DisplayIdle+0x15c>
    e27e:	69 c0       	rjmp	.+210    	; 0xe352 <DisplayIdle+0x22e>
	     IsViewFillingFIP=False;
    e280:	10 92 ad 01 	sts	0x01AD, r1
		 if (nLocalAccount>0){
    e284:	80 91 a4 01 	lds	r24, 0x01A4
    e288:	88 23       	and	r24, r24
    e28a:	09 f4       	brne	.+2      	; 0xe28e <DisplayIdle+0x16a>
    e28c:	5c c0       	rjmp	.+184    	; 0xe346 <DisplayIdle+0x222>
		     lcd_printf(3,1,PSTR("@FIP:"));
    e28e:	83 e0       	ldi	r24, 0x03	; 3
    e290:	61 e0       	ldi	r22, 0x01	; 1
    e292:	49 ed       	ldi	r20, 0xD9	; 217
    e294:	5b e1       	ldi	r21, 0x1B	; 27
    e296:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
    e29a:	ff 24       	eor	r15, r15
		     for (iDisp=0;iDisp<nLocalAccount;iDisp++){
			      //leadingZero(LocalAccountFIP[iDisp],sFIP);
				  sprintf_P(sFIP,PSTR("%.2d"),LocalAccountFIP[iDisp]);
    e29c:	5e 01       	movw	r10, r28
    e29e:	08 94       	sec
    e2a0:	a1 1c       	adc	r10, r1
    e2a2:	b1 1c       	adc	r11, r1
    e2a4:	34 ed       	ldi	r19, 0xD4	; 212
    e2a6:	63 2e       	mov	r6, r19
    e2a8:	3b e1       	ldi	r19, 0x1B	; 27
    e2aa:	73 2e       	mov	r7, r19
			      sprintf_P(lcdteks,PSTR("#%s"),sFIP);
    e2ac:	24 e0       	ldi	r18, 0x04	; 4
    e2ae:	c2 2e       	mov	r12, r18
    e2b0:	d1 2c       	mov	r13, r1
    e2b2:	cc 0e       	add	r12, r28
    e2b4:	dd 1e       	adc	r13, r29
    e2b6:	90 ed       	ldi	r25, 0xD0	; 208
    e2b8:	89 2e       	mov	r8, r25
    e2ba:	9b e1       	ldi	r25, 0x1B	; 27
    e2bc:	99 2e       	mov	r9, r25
    e2be:	3d c0       	rjmp	.+122    	; 0xe33a <DisplayIdle+0x216>
	     IsViewFillingFIP=False;
		 if (nLocalAccount>0){
		     lcd_printf(3,1,PSTR("@FIP:"));
		     for (iDisp=0;iDisp<nLocalAccount;iDisp++){
			      //leadingZero(LocalAccountFIP[iDisp],sFIP);
				  sprintf_P(sFIP,PSTR("%.2d"),LocalAccountFIP[iDisp]);
    e2c0:	0f 2d       	mov	r16, r15
    e2c2:	10 e0       	ldi	r17, 0x00	; 0
    e2c4:	00 d0       	rcall	.+0      	; 0xe2c6 <DisplayIdle+0x1a2>
    e2c6:	00 d0       	rcall	.+0      	; 0xe2c8 <DisplayIdle+0x1a4>
    e2c8:	00 d0       	rcall	.+0      	; 0xe2ca <DisplayIdle+0x1a6>
    e2ca:	ad b7       	in	r26, 0x3d	; 61
    e2cc:	be b7       	in	r27, 0x3e	; 62
    e2ce:	11 96       	adiw	r26, 0x01	; 1
    e2d0:	ed b7       	in	r30, 0x3d	; 61
    e2d2:	fe b7       	in	r31, 0x3e	; 62
    e2d4:	b2 82       	std	Z+2, r11	; 0x02
    e2d6:	a1 82       	std	Z+1, r10	; 0x01
    e2d8:	13 96       	adiw	r26, 0x03	; 3
    e2da:	7c 92       	st	X, r7
    e2dc:	6e 92       	st	-X, r6
    e2de:	12 97       	sbiw	r26, 0x02	; 2
    e2e0:	f8 01       	movw	r30, r16
    e2e2:	ea 5c       	subi	r30, 0xCA	; 202
    e2e4:	fa 4f       	sbci	r31, 0xFA	; 250
    e2e6:	80 81       	ld	r24, Z
    e2e8:	14 96       	adiw	r26, 0x04	; 4
    e2ea:	8c 93       	st	X, r24
    e2ec:	14 97       	sbiw	r26, 0x04	; 4
    e2ee:	15 96       	adiw	r26, 0x05	; 5
    e2f0:	1c 92       	st	X, r1
    e2f2:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
			      sprintf_P(lcdteks,PSTR("#%s"),sFIP);
    e2f6:	ed b7       	in	r30, 0x3d	; 61
    e2f8:	fe b7       	in	r31, 0x3e	; 62
    e2fa:	31 96       	adiw	r30, 0x01	; 1
    e2fc:	ad b7       	in	r26, 0x3d	; 61
    e2fe:	be b7       	in	r27, 0x3e	; 62
    e300:	12 96       	adiw	r26, 0x02	; 2
    e302:	dc 92       	st	X, r13
    e304:	ce 92       	st	-X, r12
    e306:	11 97       	sbiw	r26, 0x01	; 1
    e308:	93 82       	std	Z+3, r9	; 0x03
    e30a:	82 82       	std	Z+2, r8	; 0x02
    e30c:	b5 82       	std	Z+5, r11	; 0x05
    e30e:	a4 82       	std	Z+4, r10	; 0x04
    e310:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
			      lcd_print(3,6+(iDisp*3),lcdteks);
    e314:	ed b7       	in	r30, 0x3d	; 61
    e316:	fe b7       	in	r31, 0x3e	; 62
    e318:	36 96       	adiw	r30, 0x06	; 6
    e31a:	0f b6       	in	r0, 0x3f	; 63
    e31c:	f8 94       	cli
    e31e:	fe bf       	out	0x3e, r31	; 62
    e320:	0f be       	out	0x3f, r0	; 63
    e322:	ed bf       	out	0x3d, r30	; 61
    e324:	b8 01       	movw	r22, r16
    e326:	66 0f       	add	r22, r22
    e328:	77 1f       	adc	r23, r23
    e32a:	60 0f       	add	r22, r16
    e32c:	71 1f       	adc	r23, r17
    e32e:	6a 5f       	subi	r22, 0xFA	; 250
    e330:	83 e0       	ldi	r24, 0x03	; 3
    e332:	a6 01       	movw	r20, r12
    e334:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
	 //Display Filling FIP
	 if (IsViewFillingFIP==True){
	     IsViewFillingFIP=False;
		 if (nLocalAccount>0){
		     lcd_printf(3,1,PSTR("@FIP:"));
		     for (iDisp=0;iDisp<nLocalAccount;iDisp++){
    e338:	f3 94       	inc	r15
    e33a:	80 91 a4 01 	lds	r24, 0x01A4
    e33e:	f8 16       	cp	r15, r24
    e340:	08 f4       	brcc	.+2      	; 0xe344 <DisplayIdle+0x220>
    e342:	be cf       	rjmp	.-132    	; 0xe2c0 <DisplayIdle+0x19c>
    e344:	06 c0       	rjmp	.+12     	; 0xe352 <DisplayIdle+0x22e>
				  sprintf_P(sFIP,PSTR("%.2d"),LocalAccountFIP[iDisp]);
			      sprintf_P(lcdteks,PSTR("#%s"),sFIP);
			      lcd_print(3,6+(iDisp*3),lcdteks);
		     }
		 }else{
		 lcd_printf(3,1,PSTR("                    "));
    e346:	83 e0       	ldi	r24, 0x03	; 3
    e348:	61 e0       	ldi	r22, 0x01	; 1
    e34a:	4b eb       	ldi	r20, 0xBB	; 187
    e34c:	5b e1       	ldi	r21, 0x1B	; 27
    e34e:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		 }    
	 }
	 //Filling @FIP 
     if (IsCompleteFilling==True){
    e352:	80 91 c0 01 	lds	r24, 0x01C0
    e356:	81 30       	cpi	r24, 0x01	; 1
    e358:	c1 f4       	brne	.+48     	; 0xe38a <DisplayIdle+0x266>
	     IsCompleteFilling=False;
    e35a:	10 92 c0 01 	sts	0x01C0, r1
	     if (nLocalAccount>0){
    e35e:	90 91 a4 01 	lds	r25, 0x01A4
    e362:	99 23       	and	r25, r25
    e364:	91 f0       	breq	.+36     	; 0xe38a <DisplayIdle+0x266>
    e366:	e6 e3       	ldi	r30, 0x36	; 54
    e368:	f5 e0       	ldi	r31, 0x05	; 5
			 for(i=0;i<nLocalAccount;i++){//Shift data
    e36a:	29 2f       	mov	r18, r25
    e36c:	30 e0       	ldi	r19, 0x00	; 0
    e36e:	2e 0f       	add	r18, r30
    e370:	3f 1f       	adc	r19, r31
    e372:	02 c0       	rjmp	.+4      	; 0xe378 <DisplayIdle+0x254>
			     LocalAccountFIP[i]=LocalAccountFIP[i+1];
    e374:	81 81       	ldd	r24, Z+1	; 0x01
    e376:	81 93       	st	Z+, r24
	 }
	 //Filling @FIP 
     if (IsCompleteFilling==True){
	     IsCompleteFilling=False;
	     if (nLocalAccount>0){
			 for(i=0;i<nLocalAccount;i++){//Shift data
    e378:	e2 17       	cp	r30, r18
    e37a:	f3 07       	cpc	r31, r19
    e37c:	d9 f7       	brne	.-10     	; 0xe374 <DisplayIdle+0x250>
			     LocalAccountFIP[i]=LocalAccountFIP[i+1];
			 }
			 nLocalAccount--;
    e37e:	91 50       	subi	r25, 0x01	; 1
    e380:	90 93 a4 01 	sts	0x01A4, r25
             IsViewFillingFIP=True; 
    e384:	81 e0       	ldi	r24, 0x01	; 1
    e386:	80 93 ad 01 	sts	0x01AD, r24
		 }
	 }
}
    e38a:	67 96       	adiw	r28, 0x17	; 23
    e38c:	0f b6       	in	r0, 0x3f	; 63
    e38e:	f8 94       	cli
    e390:	de bf       	out	0x3e, r29	; 62
    e392:	0f be       	out	0x3f, r0	; 63
    e394:	cd bf       	out	0x3d, r28	; 61
    e396:	cf 91       	pop	r28
    e398:	df 91       	pop	r29
    e39a:	1f 91       	pop	r17
    e39c:	0f 91       	pop	r16
    e39e:	ff 90       	pop	r15
    e3a0:	df 90       	pop	r13
    e3a2:	cf 90       	pop	r12
    e3a4:	bf 90       	pop	r11
    e3a6:	af 90       	pop	r10
    e3a8:	9f 90       	pop	r9
    e3aa:	8f 90       	pop	r8
    e3ac:	7f 90       	pop	r7
    e3ae:	6f 90       	pop	r6
    e3b0:	08 95       	ret

0000e3b2 <systemMaster>:
	cbi(DDRB,2);sbi(PORTB,2);//MOSI Input
	cbi(DDRB,1);sbi(PORTB,1);//SCK  Input
}

void systemMaster(){
  	_spi_init(1, 0);         //Master
    e3b2:	81 e0       	ldi	r24, 0x01	; 1
    e3b4:	60 e0       	ldi	r22, 0x00	; 0
    e3b6:	0e 94 7f af 	call	0x15efe	; 0x15efe <_spi_init>
    _spi_enable(_SPI_SLAVE); //Enable SS 
    e3ba:	81 e0       	ldi	r24, 0x01	; 1
    e3bc:	0e 94 92 af 	call	0x15f24	; 0x15f24 <_spi_enable>
	cbi(DDRB,3);sbi(PORTB,3);//MISO Input
    e3c0:	bb 98       	cbi	0x17, 3	; 23
    e3c2:	c3 9a       	sbi	0x18, 3	; 24
	sbi(DDRB,2);             //MOSI Output
    e3c4:	ba 9a       	sbi	0x17, 2	; 23
}
    e3c6:	08 95       	ret

0000e3c8 <systemSlave>:




void systemSlave(){
    _spi_enable(_SPI_NONE);	
    e3c8:	80 e0       	ldi	r24, 0x00	; 0
    e3ca:	0e 94 92 af 	call	0x15f24	; 0x15f24 <_spi_enable>
  	_spi_init(0, 1);         //Slave
    e3ce:	80 e0       	ldi	r24, 0x00	; 0
    e3d0:	61 e0       	ldi	r22, 0x01	; 1
    e3d2:	0e 94 7f af 	call	0x15efe	; 0x15efe <_spi_init>
	sbi(DDRB,3);             //MISO Output
    e3d6:	bb 9a       	sbi	0x17, 3	; 23
	sbi(DDRB,3);sbi(PORTB,3);//MISO Output
    e3d8:	bb 9a       	sbi	0x17, 3	; 23
    e3da:	c3 9a       	sbi	0x18, 3	; 24
	cbi(DDRB,2);sbi(PORTB,2);//MOSI Input
    e3dc:	ba 98       	cbi	0x17, 2	; 23
    e3de:	c2 9a       	sbi	0x18, 2	; 24
	cbi(DDRB,1);sbi(PORTB,1);//SCK  Input
    e3e0:	b9 98       	cbi	0x17, 1	; 23
    e3e2:	c1 9a       	sbi	0x18, 1	; 24
}
    e3e4:	08 95       	ret

0000e3e6 <EDCSendByte>:
    _spi_enable(_SPI_SLAVE); //Enable SS 
	cbi(DDRB,3);sbi(PORTB,3);//MISO Input
	sbi(DDRB,2);             //MOSI Output
}

void EDCSendByte(char EDCData){
    e3e6:	1f 93       	push	r17
    e3e8:	18 2f       	mov	r17, r24
     systemMaster();	 
    e3ea:	0e 94 d9 71 	call	0xe3b2	; 0xe3b2 <systemMaster>
     _spi(EDCData);
    e3ee:	81 2f       	mov	r24, r17
    e3f0:	0e 94 a9 af 	call	0x15f52	; 0x15f52 <_spi>
     systemSlave();
    e3f4:	0e 94 e4 71 	call	0xe3c8	; 0xe3c8 <systemSlave>
}
    e3f8:	1f 91       	pop	r17
    e3fa:	08 95       	ret

0000e3fc <SendEDCMessage>:
     char Result;
	 Result=xLRC^DataIn;
     return(Result);
}

void SendEDCMessage(){
    e3fc:	cf 92       	push	r12
    e3fe:	df 92       	push	r13
    e400:	ef 92       	push	r14
    e402:	ff 92       	push	r15
    e404:	0f 93       	push	r16
    e406:	1f 93       	push	r17
    e408:	df 93       	push	r29
    e40a:	cf 93       	push	r28
    e40c:	cd b7       	in	r28, 0x3d	; 61
    e40e:	de b7       	in	r29, 0x3e	; 62
    e410:	ec 97       	sbiw	r28, 0x3c	; 60
    e412:	0f b6       	in	r0, 0x3f	; 63
    e414:	f8 94       	cli
    e416:	de bf       	out	0x3e, r29	; 62
    e418:	0f be       	out	0x3f, r0	; 63
    e41a:	cd bf       	out	0x3d, r28	; 61

     //GenerateData
	 //sprintf_P(strAmount,PSTR("%d"),100);//Testing Only
	 //AddZeroLead(strAmount,8);
	 //_uart_printf(0,0,PSTR("StrStatus:"));_uart_print(0,1,strStatus);
     sprintf_P(SerialEDC,PSTR("02%s%s%s%s%s%s%s"),strTranNo,strFIP_ID,strDescription,strPrice,strVolume,strAmount,strStatus);     
    e41c:	8d b7       	in	r24, 0x3d	; 61
    e41e:	9e b7       	in	r25, 0x3e	; 62
    e420:	42 97       	sbiw	r24, 0x12	; 18
    e422:	0f b6       	in	r0, 0x3f	; 63
    e424:	f8 94       	cli
    e426:	9e bf       	out	0x3e, r25	; 62
    e428:	0f be       	out	0x3f, r0	; 63
    e42a:	8d bf       	out	0x3d, r24	; 61
    e42c:	ed b7       	in	r30, 0x3d	; 61
    e42e:	fe b7       	in	r31, 0x3e	; 62
    e430:	31 96       	adiw	r30, 0x01	; 1
    e432:	8e 01       	movw	r16, r28
    e434:	0f 5f       	subi	r16, 0xFF	; 255
    e436:	1f 4f       	sbci	r17, 0xFF	; 255
    e438:	ad b7       	in	r26, 0x3d	; 61
    e43a:	be b7       	in	r27, 0x3e	; 62
    e43c:	12 96       	adiw	r26, 0x02	; 2
    e43e:	1c 93       	st	X, r17
    e440:	0e 93       	st	-X, r16
    e442:	11 97       	sbiw	r26, 0x01	; 1
    e444:	88 ea       	ldi	r24, 0xA8	; 168
    e446:	9b e1       	ldi	r25, 0x1B	; 27
    e448:	93 83       	std	Z+3, r25	; 0x03
    e44a:	82 83       	std	Z+2, r24	; 0x02
    e44c:	81 e6       	ldi	r24, 0x61	; 97
    e44e:	9e e0       	ldi	r25, 0x0E	; 14
    e450:	95 83       	std	Z+5, r25	; 0x05
    e452:	84 83       	std	Z+4, r24	; 0x04
    e454:	8c e9       	ldi	r24, 0x9C	; 156
    e456:	99 e0       	ldi	r25, 0x09	; 9
    e458:	97 83       	std	Z+7, r25	; 0x07
    e45a:	86 83       	std	Z+6, r24	; 0x06
    e45c:	81 e1       	ldi	r24, 0x11	; 17
    e45e:	9a e0       	ldi	r25, 0x0A	; 10
    e460:	91 87       	std	Z+9, r25	; 0x09
    e462:	80 87       	std	Z+8, r24	; 0x08
    e464:	81 e8       	ldi	r24, 0x81	; 129
    e466:	97 e0       	ldi	r25, 0x07	; 7
    e468:	93 87       	std	Z+11, r25	; 0x0b
    e46a:	82 87       	std	Z+10, r24	; 0x0a
    e46c:	85 e5       	ldi	r24, 0x55	; 85
    e46e:	95 e0       	ldi	r25, 0x05	; 5
    e470:	95 87       	std	Z+13, r25	; 0x0d
    e472:	84 87       	std	Z+12, r24	; 0x0c
    e474:	8b e8       	ldi	r24, 0x8B	; 139
    e476:	9d e0       	ldi	r25, 0x0D	; 13
    e478:	97 87       	std	Z+15, r25	; 0x0f
    e47a:	86 87       	std	Z+14, r24	; 0x0e
    e47c:	8a e6       	ldi	r24, 0x6A	; 106
    e47e:	95 e0       	ldi	r25, 0x05	; 5
    e480:	91 8b       	std	Z+17, r25	; 0x11
    e482:	80 8b       	std	Z+16, r24	; 0x10
    e484:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
	 //SendingData
	 xCRC=0;EDCSendByte(0x02);
    e488:	8d b7       	in	r24, 0x3d	; 61
    e48a:	9e b7       	in	r25, 0x3e	; 62
    e48c:	42 96       	adiw	r24, 0x12	; 18
    e48e:	0f b6       	in	r0, 0x3f	; 63
    e490:	f8 94       	cli
    e492:	9e bf       	out	0x3e, r25	; 62
    e494:	0f be       	out	0x3f, r0	; 63
    e496:	8d bf       	out	0x3d, r24	; 61
    e498:	82 e0       	ldi	r24, 0x02	; 2
    e49a:	0e 94 f3 71 	call	0xe3e6	; 0xe3e6 <EDCSendByte>
    e49e:	ff 24       	eor	r15, r15
    e4a0:	52 e0       	ldi	r21, 0x02	; 2
    e4a2:	e5 2e       	mov	r14, r21
    e4a4:	44 ec       	ldi	r20, 0xC4	; 196
    e4a6:	c4 2e       	mov	r12, r20
    e4a8:	49 e0       	ldi	r20, 0x09	; 9
    e4aa:	d4 2e       	mov	r13, r20
    e4ac:	0a c0       	rjmp	.+20     	; 0xe4c2 <SendEDCMessage+0xc6>
	 xCRC=CalcLRC(xCRC,0x02);	      
	 for (i=0;i<strlen(SerialEDC);i++){
          xCRC=CalcLRC(xCRC,SerialEDC[i]);
    e4ae:	a0 0f       	add	r26, r16
    e4b0:	b1 1f       	adc	r27, r17
    e4b2:	8c 91       	ld	r24, X
     systemSlave();
}

char CalcLRC(char xLRC,char DataIn){
     char Result;
	 Result=xLRC^DataIn;
    e4b4:	e8 26       	eor	r14, r24
	 //SendingData
	 xCRC=0;EDCSendByte(0x02);
	 xCRC=CalcLRC(xCRC,0x02);	      
	 for (i=0;i<strlen(SerialEDC);i++){
          xCRC=CalcLRC(xCRC,SerialEDC[i]);
          EDCSendByte(SerialEDC[i]);
    e4b6:	0e 94 f3 71 	call	0xe3e6	; 0xe3e6 <EDCSendByte>
    e4ba:	c6 01       	movw	r24, r12
    e4bc:	01 97       	sbiw	r24, 0x01	; 1
    e4be:	f1 f7       	brne	.-4      	; 0xe4bc <SendEDCMessage+0xc0>
	 //_uart_printf(0,0,PSTR("StrStatus:"));_uart_print(0,1,strStatus);
     sprintf_P(SerialEDC,PSTR("02%s%s%s%s%s%s%s"),strTranNo,strFIP_ID,strDescription,strPrice,strVolume,strAmount,strStatus);     
	 //SendingData
	 xCRC=0;EDCSendByte(0x02);
	 xCRC=CalcLRC(xCRC,0x02);	      
	 for (i=0;i<strlen(SerialEDC);i++){
    e4c0:	f3 94       	inc	r15
    e4c2:	f8 01       	movw	r30, r16
    e4c4:	01 90       	ld	r0, Z+
    e4c6:	00 20       	and	r0, r0
    e4c8:	e9 f7       	brne	.-6      	; 0xe4c4 <SendEDCMessage+0xc8>
    e4ca:	31 97       	sbiw	r30, 0x01	; 1
    e4cc:	e0 1b       	sub	r30, r16
    e4ce:	f1 0b       	sbc	r31, r17
    e4d0:	af 2d       	mov	r26, r15
    e4d2:	b0 e0       	ldi	r27, 0x00	; 0
    e4d4:	ae 17       	cp	r26, r30
    e4d6:	bf 07       	cpc	r27, r31
    e4d8:	50 f3       	brcs	.-44     	; 0xe4ae <SendEDCMessage+0xb2>
          xCRC=CalcLRC(xCRC,SerialEDC[i]);
          EDCSendByte(SerialEDC[i]);
		  //_uart(0,1,SerialEDC[i]);
		  _delay_ms(10);//min:8
	 }
     EDCSendByte(0x03);
    e4da:	83 e0       	ldi	r24, 0x03	; 3
    e4dc:	0e 94 f3 71 	call	0xe3e6	; 0xe3e6 <EDCSendByte>
	 xCRC=CalcLRC(xCRC,0x03);	      
	 EDCSendByte(xCRC);
    e4e0:	83 e0       	ldi	r24, 0x03	; 3
    e4e2:	8e 25       	eor	r24, r14
    e4e4:	0e 94 f3 71 	call	0xe3e6	; 0xe3e6 <EDCSendByte>
}
    e4e8:	ec 96       	adiw	r28, 0x3c	; 60
    e4ea:	0f b6       	in	r0, 0x3f	; 63
    e4ec:	f8 94       	cli
    e4ee:	de bf       	out	0x3e, r29	; 62
    e4f0:	0f be       	out	0x3f, r0	; 63
    e4f2:	cd bf       	out	0x3d, r28	; 61
    e4f4:	cf 91       	pop	r28
    e4f6:	df 91       	pop	r29
    e4f8:	1f 91       	pop	r17
    e4fa:	0f 91       	pop	r16
    e4fc:	ff 90       	pop	r15
    e4fe:	ef 90       	pop	r14
    e500:	df 90       	pop	r13
    e502:	cf 90       	pop	r12
    e504:	08 95       	ret

0000e506 <SendSlaveCommand>:
void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
	 PoolMsg=plMsg;
     IsControlPooling=True;
}
void SendSlaveCommand(char SlaveCommand,char SlaveMessage){     
    e506:	0f 93       	push	r16
    e508:	1f 93       	push	r17
    e50a:	18 2f       	mov	r17, r24
    e50c:	06 2f       	mov	r16, r22
	 systemMaster();
    e50e:	0e 94 d9 71 	call	0xe3b2	; 0xe3b2 <systemMaster>
	 _spi(0x05);
    e512:	85 e0       	ldi	r24, 0x05	; 5
    e514:	0e 94 a9 af 	call	0x15f52	; 0x15f52 <_spi>
	 _spi(SlaveCommand);
    e518:	81 2f       	mov	r24, r17
    e51a:	0e 94 a9 af 	call	0x15f52	; 0x15f52 <_spi>
	 _spi(SlaveMessage);
    e51e:	80 2f       	mov	r24, r16
    e520:	0e 94 a9 af 	call	0x15f52	; 0x15f52 <_spi>
	 _spi(0x06);
    e524:	86 e0       	ldi	r24, 0x06	; 6
    e526:	0e 94 a9 af 	call	0x15f52	; 0x15f52 <_spi>
	 systemSlave();
    e52a:	0e 94 e4 71 	call	0xe3c8	; 0xe3c8 <systemSlave>
}
    e52e:	1f 91       	pop	r17
    e530:	0f 91       	pop	r16
    e532:	08 95       	ret

0000e534 <FSettingPumpID>:
     if ((*Value)>MinValue){
	     (*Value)--;
	 }else *Value=MaxValue;
}

char FSettingPumpID(){
    e534:	9f 92       	push	r9
    e536:	af 92       	push	r10
    e538:	bf 92       	push	r11
    e53a:	cf 92       	push	r12
    e53c:	df 92       	push	r13
    e53e:	ef 92       	push	r14
    e540:	ff 92       	push	r15
    e542:	0f 93       	push	r16
    e544:	1f 93       	push	r17
    e546:	df 93       	push	r29
    e548:	cf 93       	push	r28
    e54a:	cd b7       	in	r28, 0x3d	; 61
    e54c:	de b7       	in	r29, 0x3e	; 62
    e54e:	64 97       	sbiw	r28, 0x14	; 20
    e550:	0f b6       	in	r0, 0x3f	; 63
    e552:	f8 94       	cli
    e554:	de bf       	out	0x3e, r29	; 62
    e556:	0f be       	out	0x3f, r0	; 63
    e558:	cd bf       	out	0x3d, r28	; 61
	 char iLoop,Result,KeyChar,KeyPressed,i,j,CheckPump;
	 char lcdteks[20];
	 static char Idx,PPumpId[8],MsgPumpId,PumpCount;
     
	 Result=MENU_NONE;
	 switch (stMenuPumpID){
    e55a:	80 91 de 02 	lds	r24, 0x02DE
    e55e:	85 30       	cpi	r24, 0x05	; 5
    e560:	09 f4       	brne	.+2      	; 0xe564 <FSettingPumpID+0x30>
    e562:	88 c1       	rjmp	.+784    	; 0xe874 <FSettingPumpID+0x340>
    e564:	86 30       	cpi	r24, 0x06	; 6
    e566:	90 f4       	brcc	.+36     	; 0xe58c <FSettingPumpID+0x58>
    e568:	82 30       	cpi	r24, 0x02	; 2
    e56a:	09 f4       	brne	.+2      	; 0xe56e <FSettingPumpID+0x3a>
    e56c:	8f c0       	rjmp	.+286    	; 0xe68c <FSettingPumpID+0x158>
    e56e:	83 30       	cpi	r24, 0x03	; 3
    e570:	30 f4       	brcc	.+12     	; 0xe57e <FSettingPumpID+0x4a>
    e572:	88 23       	and	r24, r24
    e574:	f1 f0       	breq	.+60     	; 0xe5b2 <FSettingPumpID+0x7e>
    e576:	81 30       	cpi	r24, 0x01	; 1
    e578:	09 f0       	breq	.+2      	; 0xe57c <FSettingPumpID+0x48>
    e57a:	73 c2       	rjmp	.+1254   	; 0xea62 <FSettingPumpID+0x52e>
    e57c:	2d c0       	rjmp	.+90     	; 0xe5d8 <FSettingPumpID+0xa4>
    e57e:	83 30       	cpi	r24, 0x03	; 3
    e580:	09 f4       	brne	.+2      	; 0xe584 <FSettingPumpID+0x50>
    e582:	51 c1       	rjmp	.+674    	; 0xe826 <FSettingPumpID+0x2f2>
    e584:	84 30       	cpi	r24, 0x04	; 4
    e586:	09 f0       	breq	.+2      	; 0xe58a <FSettingPumpID+0x56>
    e588:	6c c2       	rjmp	.+1240   	; 0xea62 <FSettingPumpID+0x52e>
    e58a:	6d c1       	rjmp	.+730    	; 0xe866 <FSettingPumpID+0x332>
    e58c:	88 30       	cpi	r24, 0x08	; 8
    e58e:	09 f4       	brne	.+2      	; 0xe592 <FSettingPumpID+0x5e>
    e590:	fc c1       	rjmp	.+1016   	; 0xe98a <FSettingPumpID+0x456>
    e592:	89 30       	cpi	r24, 0x09	; 9
    e594:	38 f4       	brcc	.+14     	; 0xe5a4 <FSettingPumpID+0x70>
    e596:	86 30       	cpi	r24, 0x06	; 6
    e598:	09 f4       	brne	.+2      	; 0xe59c <FSettingPumpID+0x68>
    e59a:	9b c1       	rjmp	.+822    	; 0xe8d2 <FSettingPumpID+0x39e>
    e59c:	87 30       	cpi	r24, 0x07	; 7
    e59e:	09 f0       	breq	.+2      	; 0xe5a2 <FSettingPumpID+0x6e>
    e5a0:	60 c2       	rjmp	.+1216   	; 0xea62 <FSettingPumpID+0x52e>
    e5a2:	45 c2       	rjmp	.+1162   	; 0xea2e <FSettingPumpID+0x4fa>
    e5a4:	89 30       	cpi	r24, 0x09	; 9
    e5a6:	09 f4       	brne	.+2      	; 0xe5aa <FSettingPumpID+0x76>
    e5a8:	4a c2       	rjmp	.+1172   	; 0xea3e <FSettingPumpID+0x50a>
    e5aa:	8a 30       	cpi	r24, 0x0A	; 10
    e5ac:	09 f0       	breq	.+2      	; 0xe5b0 <FSettingPumpID+0x7c>
    e5ae:	59 c2       	rjmp	.+1202   	; 0xea62 <FSettingPumpID+0x52e>
    e5b0:	4c c2       	rjmp	.+1176   	; 0xea4a <FSettingPumpID+0x516>
	 case mpInitPumpId:	      
	      //Disable PumpPooling
		  if (IFType==IT_STANDALONE)SendSlaveCommand(SC_STOP_POOL_SEQUENCE,0);
    e5b2:	80 91 10 01 	lds	r24, 0x0110
    e5b6:	82 30       	cpi	r24, 0x02	; 2
    e5b8:	21 f4       	brne	.+8      	; 0xe5c2 <FSettingPumpID+0x8e>
    e5ba:	8f e1       	ldi	r24, 0x1F	; 31
    e5bc:	60 e0       	ldi	r22, 0x00	; 0
    e5be:	0e 94 83 72 	call	0xe506	; 0xe506 <SendSlaveCommand>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    e5c2:	84 ed       	ldi	r24, 0xD4	; 212
    e5c4:	92 e0       	ldi	r25, 0x02	; 2
    e5c6:	65 e4       	ldi	r22, 0x45	; 69
    e5c8:	70 e0       	ldi	r23, 0x00	; 0
    e5ca:	48 e0       	ldi	r20, 0x08	; 8
    e5cc:	50 e0       	ldi	r21, 0x00	; 0
    e5ce:	23 ef       	ldi	r18, 0xF3	; 243
    e5d0:	32 e1       	ldi	r19, 0x12	; 18
    e5d2:	0e 94 1f b4 	call	0x1683e	; 0x1683e <__eerd_block>
    e5d6:	4c c1       	rjmp	.+664    	; 0xe870 <FSettingPumpID+0x33c>
		  eeprom_read_block((void*) &PPumpId, (const void*) &DefPumpMap,8);
          stMenuPumpID=mpDisplayPumpId;
	      break;
	 case mpDisplayPumpId:
	      lcd_clear();		  
    e5d8:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
    e5dc:	b4 ed       	ldi	r27, 0xD4	; 212
    e5de:	eb 2e       	mov	r14, r27
    e5e0:	b2 e0       	ldi	r27, 0x02	; 2
    e5e2:	fb 2e       	mov	r15, r27
    e5e4:	01 e0       	ldi	r16, 0x01	; 1
    e5e6:	10 e0       	ldi	r17, 0x00	; 0
		  for (iLoop=0;iLoop<4;iLoop++){
			  sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d"),(iLoop+1),PPumpId[iLoop],(iLoop+5),PPumpId[iLoop+4]);
    e5e8:	6e 01       	movw	r12, r28
    e5ea:	08 94       	sec
    e5ec:	c1 1c       	adc	r12, r1
    e5ee:	d1 1c       	adc	r13, r1
    e5f0:	a8 e9       	ldi	r26, 0x98	; 152
    e5f2:	aa 2e       	mov	r10, r26
    e5f4:	ac e0       	ldi	r26, 0x0C	; 12
    e5f6:	ba 2e       	mov	r11, r26
    e5f8:	8d b7       	in	r24, 0x3d	; 61
    e5fa:	9e b7       	in	r25, 0x3e	; 62
    e5fc:	0c 97       	sbiw	r24, 0x0c	; 12
    e5fe:	0f b6       	in	r0, 0x3f	; 63
    e600:	f8 94       	cli
    e602:	9e bf       	out	0x3e, r25	; 62
    e604:	0f be       	out	0x3f, r0	; 63
    e606:	8d bf       	out	0x3d, r24	; 61
    e608:	ed b7       	in	r30, 0x3d	; 61
    e60a:	fe b7       	in	r31, 0x3e	; 62
    e60c:	31 96       	adiw	r30, 0x01	; 1
    e60e:	ad b7       	in	r26, 0x3d	; 61
    e610:	be b7       	in	r27, 0x3e	; 62
    e612:	12 96       	adiw	r26, 0x02	; 2
    e614:	dc 92       	st	X, r13
    e616:	ce 92       	st	-X, r12
    e618:	11 97       	sbiw	r26, 0x01	; 1
    e61a:	b3 82       	std	Z+3, r11	; 0x03
    e61c:	a2 82       	std	Z+2, r10	; 0x02
    e61e:	15 83       	std	Z+5, r17	; 0x05
    e620:	04 83       	std	Z+4, r16	; 0x04
    e622:	d7 01       	movw	r26, r14
    e624:	8c 91       	ld	r24, X
    e626:	86 83       	std	Z+6, r24	; 0x06
    e628:	17 82       	std	Z+7, r1	; 0x07
    e62a:	0c 5f       	subi	r16, 0xFC	; 252
    e62c:	1f 4f       	sbci	r17, 0xFF	; 255
    e62e:	11 87       	std	Z+9, r17	; 0x09
    e630:	00 87       	std	Z+8, r16	; 0x08
    e632:	04 50       	subi	r16, 0x04	; 4
    e634:	10 40       	sbci	r17, 0x00	; 0
    e636:	14 96       	adiw	r26, 0x04	; 4
    e638:	8c 91       	ld	r24, X
    e63a:	82 87       	std	Z+10, r24	; 0x0a
    e63c:	13 86       	std	Z+11, r1	; 0x0b
    e63e:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
			  lcd_print((iLoop+1),1,lcdteks);
    e642:	ed b7       	in	r30, 0x3d	; 61
    e644:	fe b7       	in	r31, 0x3e	; 62
    e646:	3c 96       	adiw	r30, 0x0c	; 12
    e648:	0f b6       	in	r0, 0x3f	; 63
    e64a:	f8 94       	cli
    e64c:	fe bf       	out	0x3e, r31	; 62
    e64e:	0f be       	out	0x3f, r0	; 63
    e650:	ed bf       	out	0x3d, r30	; 61
    e652:	80 2f       	mov	r24, r16
    e654:	61 e0       	ldi	r22, 0x01	; 1
    e656:	a6 01       	movw	r20, r12
    e658:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
    e65c:	08 94       	sec
    e65e:	e1 1c       	adc	r14, r1
    e660:	f1 1c       	adc	r15, r1
    e662:	0f 5f       	subi	r16, 0xFF	; 255
    e664:	1f 4f       	sbci	r17, 0xFF	; 255
		  eeprom_read_block((void*) &PPumpId, (const void*) &DefPumpMap,8);
          stMenuPumpID=mpDisplayPumpId;
	      break;
	 case mpDisplayPumpId:
	      lcd_clear();		  
		  for (iLoop=0;iLoop<4;iLoop++){
    e666:	f8 ed       	ldi	r31, 0xD8	; 216
    e668:	ef 16       	cp	r14, r31
    e66a:	f2 e0       	ldi	r31, 0x02	; 2
    e66c:	ff 06       	cpc	r15, r31
    e66e:	21 f6       	brne	.-120    	; 0xe5f8 <FSettingPumpID+0xc4>
			  sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d"),(iLoop+1),PPumpId[iLoop],(iLoop+5),PPumpId[iLoop+4]);
			  lcd_print((iLoop+1),1,lcdteks);
          }
          lcd_printf(3,15,PSTR("*)Back"));
    e670:	83 e0       	ldi	r24, 0x03	; 3
    e672:	6f e0       	ldi	r22, 0x0F	; 15
    e674:	41 e9       	ldi	r20, 0x91	; 145
    e676:	5c e0       	ldi	r21, 0x0C	; 12
    e678:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
	      lcd_printf(4,15,PSTR("#)Save"));
    e67c:	84 e0       	ldi	r24, 0x04	; 4
    e67e:	6f e0       	ldi	r22, 0x0F	; 15
    e680:	4a e8       	ldi	r20, 0x8A	; 138
    e682:	5c e0       	ldi	r21, 0x0C	; 12
    e684:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
          stMenuPumpID=mpSelectInput;
    e688:	82 e0       	ldi	r24, 0x02	; 2
    e68a:	d6 c1       	rjmp	.+940    	; 0xea38 <FSettingPumpID+0x504>
	      break;
     case mpSelectInput:
	      KeyPressed=_key_scan(1);
    e68c:	81 e0       	ldi	r24, 0x01	; 1
    e68e:	0e 94 ab ae 	call	0x15d56	; 0x15d56 <_key_scan>
    e692:	98 2e       	mov	r9, r24
	      KeyChar=_key_btn(KeyPressed);
    e694:	0e 94 0c ae 	call	0x15c18	; 0x15c18 <_key_btn>
    e698:	98 2f       	mov	r25, r24
          if ((KeyChar>='1') && (KeyChar<='8')){
    e69a:	81 53       	subi	r24, 0x31	; 49
    e69c:	88 30       	cpi	r24, 0x08	; 8
    e69e:	08 f0       	brcs	.+2      	; 0xe6a2 <FSettingPumpID+0x16e>
    e6a0:	85 c0       	rjmp	.+266    	; 0xe7ac <FSettingPumpID+0x278>
		      //eeprom_read_block((void*) &PPumpId, (const void*) &DefPumpMap,8);
			  switch(IFType){
    e6a2:	80 91 10 01 	lds	r24, 0x0110
    e6a6:	81 30       	cpi	r24, 0x01	; 1
    e6a8:	19 f0       	breq	.+6      	; 0xe6b0 <FSettingPumpID+0x17c>
    e6aa:	82 30       	cpi	r24, 0x02	; 2
    e6ac:	a1 f5       	brne	.+104    	; 0xe716 <FSettingPumpID+0x1e2>
    e6ae:	17 c0       	rjmp	.+46     	; 0xe6de <FSettingPumpID+0x1aa>
			  case IT_SLAVE:
			       if (IsShift==False)IncValue(&PPumpId[KeyChar-'1'],0,99);//PPumpId[KeyChar-'1']=((PPumpId[KeyChar-'1']+1)%100);
    e6b0:	80 91 dd 02 	lds	r24, 0x02DD
    e6b4:	88 23       	and	r24, r24
    e6b6:	41 f4       	brne	.+16     	; 0xe6c8 <FSettingPumpID+0x194>
    e6b8:	e9 2f       	mov	r30, r25
    e6ba:	f0 e0       	ldi	r31, 0x00	; 0
    e6bc:	ed 55       	subi	r30, 0x5D	; 93
    e6be:	fd 4f       	sbci	r31, 0xFD	; 253
		}
	}
}

void IncValue(char *Value,char MinValue,char MaxValue){
     if ((*Value)<MaxValue){
    e6c0:	80 81       	ld	r24, Z
    e6c2:	83 36       	cpi	r24, 0x63	; 99
    e6c4:	c8 f4       	brcc	.+50     	; 0xe6f8 <FSettingPumpID+0x1c4>
    e6c6:	16 c0       	rjmp	.+44     	; 0xe6f4 <FSettingPumpID+0x1c0>
		      //eeprom_read_block((void*) &PPumpId, (const void*) &DefPumpMap,8);
			  switch(IFType){
			  case IT_SLAVE:
			       if (IsShift==False)IncValue(&PPumpId[KeyChar-'1'],0,99);//PPumpId[KeyChar-'1']=((PPumpId[KeyChar-'1']+1)%100);
				   else
				   if (IsShift==True)DecValue(&PPumpId[KeyChar-'1'],0,99);//PPumpId[KeyChar-'1']=100-(100-((PPumpId[KeyChar-'1']+1)%100));
    e6c8:	81 30       	cpi	r24, 0x01	; 1
    e6ca:	29 f5       	brne	.+74     	; 0xe716 <FSettingPumpID+0x1e2>
    e6cc:	e9 2f       	mov	r30, r25
    e6ce:	f0 e0       	ldi	r31, 0x00	; 0
    e6d0:	ed 55       	subi	r30, 0x5D	; 93
    e6d2:	fd 4f       	sbci	r31, 0xFD	; 253
	     (*Value)++;
	 }else *Value=MinValue;
}

void DecValue(char *Value,char MinValue,char MaxValue){
     if ((*Value)>MinValue){
    e6d4:	80 81       	ld	r24, Z
    e6d6:	88 23       	and	r24, r24
    e6d8:	d1 f4       	brne	.+52     	; 0xe70e <FSettingPumpID+0x1da>
	     (*Value)--;
	 }else *Value=MaxValue;
    e6da:	83 e6       	ldi	r24, 0x63	; 99
    e6dc:	1b c0       	rjmp	.+54     	; 0xe714 <FSettingPumpID+0x1e0>
			       if (IsShift==False)IncValue(&PPumpId[KeyChar-'1'],0,99);//PPumpId[KeyChar-'1']=((PPumpId[KeyChar-'1']+1)%100);
				   else
				   if (IsShift==True)DecValue(&PPumpId[KeyChar-'1'],0,99);//PPumpId[KeyChar-'1']=100-(100-((PPumpId[KeyChar-'1']+1)%100));
			       break;
              case IT_STANDALONE:
			       if (IsShift==False)IncValue(&PPumpId[KeyChar-'1'],0,16);//PPumpId[KeyChar-'1']=((PPumpId[KeyChar-'1']+1)%16);
    e6de:	80 91 dd 02 	lds	r24, 0x02DD
    e6e2:	88 23       	and	r24, r24
    e6e4:	59 f4       	brne	.+22     	; 0xe6fc <FSettingPumpID+0x1c8>
    e6e6:	e9 2f       	mov	r30, r25
    e6e8:	f0 e0       	ldi	r31, 0x00	; 0
    e6ea:	ed 55       	subi	r30, 0x5D	; 93
    e6ec:	fd 4f       	sbci	r31, 0xFD	; 253
		}
	}
}

void IncValue(char *Value,char MinValue,char MaxValue){
     if ((*Value)<MaxValue){
    e6ee:	80 81       	ld	r24, Z
    e6f0:	80 31       	cpi	r24, 0x10	; 16
    e6f2:	10 f4       	brcc	.+4      	; 0xe6f8 <FSettingPumpID+0x1c4>
	     (*Value)++;
    e6f4:	8f 5f       	subi	r24, 0xFF	; 255
    e6f6:	0e c0       	rjmp	.+28     	; 0xe714 <FSettingPumpID+0x1e0>
	 }else *Value=MinValue;
    e6f8:	10 82       	st	Z, r1
    e6fa:	0d c0       	rjmp	.+26     	; 0xe716 <FSettingPumpID+0x1e2>
				   if (IsShift==True)DecValue(&PPumpId[KeyChar-'1'],0,99);//PPumpId[KeyChar-'1']=100-(100-((PPumpId[KeyChar-'1']+1)%100));
			       break;
              case IT_STANDALONE:
			       if (IsShift==False)IncValue(&PPumpId[KeyChar-'1'],0,16);//PPumpId[KeyChar-'1']=((PPumpId[KeyChar-'1']+1)%16);
				   else
				   if (IsShift==True)DecValue(&PPumpId[KeyChar-'1'],0,16);//PPumpId[KeyChar-'1']=17-(17-((PPumpId[KeyChar-'1']+1)%17));
    e6fc:	81 30       	cpi	r24, 0x01	; 1
    e6fe:	59 f4       	brne	.+22     	; 0xe716 <FSettingPumpID+0x1e2>
    e700:	e9 2f       	mov	r30, r25
    e702:	f0 e0       	ldi	r31, 0x00	; 0
    e704:	ed 55       	subi	r30, 0x5D	; 93
    e706:	fd 4f       	sbci	r31, 0xFD	; 253
	     (*Value)++;
	 }else *Value=MinValue;
}

void DecValue(char *Value,char MinValue,char MaxValue){
     if ((*Value)>MinValue){
    e708:	80 81       	ld	r24, Z
    e70a:	88 23       	and	r24, r24
    e70c:	11 f0       	breq	.+4      	; 0xe712 <FSettingPumpID+0x1de>
	     (*Value)--;
    e70e:	81 50       	subi	r24, 0x01	; 1
    e710:	01 c0       	rjmp	.+2      	; 0xe714 <FSettingPumpID+0x1e0>
	 }else *Value=MaxValue;
    e712:	80 e1       	ldi	r24, 0x10	; 16
    e714:	80 83       	st	Z, r24
    e716:	f4 ed       	ldi	r31, 0xD4	; 212
    e718:	ef 2e       	mov	r14, r31
    e71a:	f2 e0       	ldi	r31, 0x02	; 2
    e71c:	ff 2e       	mov	r15, r31
    e71e:	01 e0       	ldi	r16, 0x01	; 1
    e720:	10 e0       	ldi	r17, 0x00	; 0
				   if (IsShift==True)DecValue(&PPumpId[KeyChar-'1'],0,16);//PPumpId[KeyChar-'1']=17-(17-((PPumpId[KeyChar-'1']+1)%17));
			       break;			  
			  }
			  //Redraw
			  for (iLoop=0;iLoop<4;iLoop++){
				  sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d"),(iLoop+1),PPumpId[iLoop],(iLoop+5),PPumpId[iLoop+4]);
    e722:	6e 01       	movw	r12, r28
    e724:	08 94       	sec
    e726:	c1 1c       	adc	r12, r1
    e728:	d1 1c       	adc	r13, r1
    e72a:	e6 e7       	ldi	r30, 0x76	; 118
    e72c:	ae 2e       	mov	r10, r30
    e72e:	ec e0       	ldi	r30, 0x0C	; 12
    e730:	be 2e       	mov	r11, r30
    e732:	8d b7       	in	r24, 0x3d	; 61
    e734:	9e b7       	in	r25, 0x3e	; 62
    e736:	0c 97       	sbiw	r24, 0x0c	; 12
    e738:	0f b6       	in	r0, 0x3f	; 63
    e73a:	f8 94       	cli
    e73c:	9e bf       	out	0x3e, r25	; 62
    e73e:	0f be       	out	0x3f, r0	; 63
    e740:	8d bf       	out	0x3d, r24	; 61
    e742:	ed b7       	in	r30, 0x3d	; 61
    e744:	fe b7       	in	r31, 0x3e	; 62
    e746:	31 96       	adiw	r30, 0x01	; 1
    e748:	ad b7       	in	r26, 0x3d	; 61
    e74a:	be b7       	in	r27, 0x3e	; 62
    e74c:	12 96       	adiw	r26, 0x02	; 2
    e74e:	dc 92       	st	X, r13
    e750:	ce 92       	st	-X, r12
    e752:	11 97       	sbiw	r26, 0x01	; 1
    e754:	b3 82       	std	Z+3, r11	; 0x03
    e756:	a2 82       	std	Z+2, r10	; 0x02
    e758:	15 83       	std	Z+5, r17	; 0x05
    e75a:	04 83       	std	Z+4, r16	; 0x04
    e75c:	d7 01       	movw	r26, r14
    e75e:	8c 91       	ld	r24, X
    e760:	86 83       	std	Z+6, r24	; 0x06
    e762:	17 82       	std	Z+7, r1	; 0x07
    e764:	0c 5f       	subi	r16, 0xFC	; 252
    e766:	1f 4f       	sbci	r17, 0xFF	; 255
    e768:	11 87       	std	Z+9, r17	; 0x09
    e76a:	00 87       	std	Z+8, r16	; 0x08
    e76c:	04 50       	subi	r16, 0x04	; 4
    e76e:	10 40       	sbci	r17, 0x00	; 0
    e770:	14 96       	adiw	r26, 0x04	; 4
    e772:	8c 91       	ld	r24, X
    e774:	82 87       	std	Z+10, r24	; 0x0a
    e776:	13 86       	std	Z+11, r1	; 0x0b
    e778:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
				  lcd_print((iLoop+1),1,lcdteks);
    e77c:	ed b7       	in	r30, 0x3d	; 61
    e77e:	fe b7       	in	r31, 0x3e	; 62
    e780:	3c 96       	adiw	r30, 0x0c	; 12
    e782:	0f b6       	in	r0, 0x3f	; 63
    e784:	f8 94       	cli
    e786:	fe bf       	out	0x3e, r31	; 62
    e788:	0f be       	out	0x3f, r0	; 63
    e78a:	ed bf       	out	0x3d, r30	; 61
    e78c:	80 2f       	mov	r24, r16
    e78e:	61 e0       	ldi	r22, 0x01	; 1
    e790:	a6 01       	movw	r20, r12
    e792:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
    e796:	08 94       	sec
    e798:	e1 1c       	adc	r14, r1
    e79a:	f1 1c       	adc	r15, r1
    e79c:	0f 5f       	subi	r16, 0xFF	; 255
    e79e:	1f 4f       	sbci	r17, 0xFF	; 255
				   else
				   if (IsShift==True)DecValue(&PPumpId[KeyChar-'1'],0,16);//PPumpId[KeyChar-'1']=17-(17-((PPumpId[KeyChar-'1']+1)%17));
			       break;			  
			  }
			  //Redraw
			  for (iLoop=0;iLoop<4;iLoop++){
    e7a0:	f8 ed       	ldi	r31, 0xD8	; 216
    e7a2:	ef 16       	cp	r14, r31
    e7a4:	f2 e0       	ldi	r31, 0x02	; 2
    e7a6:	ff 06       	cpc	r15, r31
    e7a8:	21 f6       	brne	.-120    	; 0xe732 <FSettingPumpID+0x1fe>
    e7aa:	2b c0       	rjmp	.+86     	; 0xe802 <FSettingPumpID+0x2ce>
				  sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d"),(iLoop+1),PPumpId[iLoop],(iLoop+5),PPumpId[iLoop+4]);
				  lcd_print((iLoop+1),1,lcdteks);
	          }
		  }else if (KeyChar=='#'){
    e7ac:	93 32       	cpi	r25, 0x23	; 35
    e7ae:	21 f5       	brne	.+72     	; 0xe7f8 <FSettingPumpID+0x2c4>
    e7b0:	40 e0       	ldi	r20, 0x00	; 0
    e7b2:	20 e0       	ldi	r18, 0x00	; 0
    e7b4:	30 e0       	ldi	r19, 0x00	; 0
    e7b6:	52 2f       	mov	r21, r18
		      //Evaluate same PumpID
			  PumpCount=0;
			  for (i=0;i<8;i++){
			       CheckPump=PPumpId[i];
    e7b8:	f9 01       	movw	r30, r18
    e7ba:	ec 52       	subi	r30, 0x2C	; 44
    e7bc:	fd 4f       	sbci	r31, 0xFD	; 253
    e7be:	e0 81       	ld	r30, Z
				   if (CheckPump>0){
    e7c0:	ee 23       	and	r30, r30
    e7c2:	69 f0       	breq	.+26     	; 0xe7de <FSettingPumpID+0x2aa>
    e7c4:	a4 ed       	ldi	r26, 0xD4	; 212
    e7c6:	b2 e0       	ldi	r27, 0x02	; 2
    e7c8:	90 e0       	ldi	r25, 0x00	; 0
				      for(j=0;j<8;j++){					      
					      if ((i!=j)&&(CheckPump==PPumpId[j]))
    e7ca:	59 17       	cp	r21, r25
    e7cc:	21 f0       	breq	.+8      	; 0xe7d6 <FSettingPumpID+0x2a2>
    e7ce:	8c 91       	ld	r24, X
    e7d0:	e8 17       	cp	r30, r24
    e7d2:	09 f4       	brne	.+2      	; 0xe7d6 <FSettingPumpID+0x2a2>
						       PumpCount++;
    e7d4:	4f 5f       	subi	r20, 0xFF	; 255
		      //Evaluate same PumpID
			  PumpCount=0;
			  for (i=0;i<8;i++){
			       CheckPump=PPumpId[i];
				   if (CheckPump>0){
				      for(j=0;j<8;j++){					      
    e7d6:	9f 5f       	subi	r25, 0xFF	; 255
    e7d8:	11 96       	adiw	r26, 0x01	; 1
    e7da:	98 30       	cpi	r25, 0x08	; 8
    e7dc:	b1 f7       	brne	.-20     	; 0xe7ca <FSettingPumpID+0x296>
    e7de:	2f 5f       	subi	r18, 0xFF	; 255
    e7e0:	3f 4f       	sbci	r19, 0xFF	; 255
				  lcd_print((iLoop+1),1,lcdteks);
	          }
		  }else if (KeyChar=='#'){
		      //Evaluate same PumpID
			  PumpCount=0;
			  for (i=0;i<8;i++){
    e7e2:	28 30       	cpi	r18, 0x08	; 8
    e7e4:	31 05       	cpc	r19, r1
    e7e6:	39 f7       	brne	.-50     	; 0xe7b6 <FSettingPumpID+0x282>
    e7e8:	40 93 d2 02 	sts	0x02D2, r20
					      if ((i!=j)&&(CheckPump==PPumpId[j]))
						       PumpCount++;
					  }
				    }				     
				  }			       			  			  
			  if (PumpCount>0) stMenuPumpID=mpSaveFailed;
    e7ec:	44 23       	and	r20, r20
    e7ee:	11 f0       	breq	.+4      	; 0xe7f4 <FSettingPumpID+0x2c0>
    e7f0:	83 e0       	ldi	r24, 0x03	; 3
    e7f2:	05 c0       	rjmp	.+10     	; 0xe7fe <FSettingPumpID+0x2ca>
			  else stMenuPumpID=mpSavingPumpId;
    e7f4:	85 e0       	ldi	r24, 0x05	; 5
    e7f6:	03 c0       	rjmp	.+6      	; 0xe7fe <FSettingPumpID+0x2ca>
		  }	
		  else if (KeyChar=='*'){
    e7f8:	9a 32       	cpi	r25, 0x2A	; 42
    e7fa:	19 f4       	brne	.+6      	; 0xe802 <FSettingPumpID+0x2ce>
		      stMenuPumpID=mpExitPumpId;
    e7fc:	8a e0       	ldi	r24, 0x0A	; 10
    e7fe:	80 93 de 02 	sts	0x02DE, r24
		  }
		  if (KeyPressed==_KEY_SHIFT){
    e802:	8b e7       	ldi	r24, 0x7B	; 123
    e804:	98 16       	cp	r9, r24
    e806:	09 f0       	breq	.+2      	; 0xe80a <FSettingPumpID+0x2d6>
    e808:	2c c1       	rjmp	.+600    	; 0xea62 <FSettingPumpID+0x52e>
		      if (IsShift==False)IsShift=True;
    e80a:	80 91 dd 02 	lds	r24, 0x02DD
    e80e:	88 23       	and	r24, r24
    e810:	21 f4       	brne	.+8      	; 0xe81a <FSettingPumpID+0x2e6>
    e812:	81 e0       	ldi	r24, 0x01	; 1
    e814:	80 93 dd 02 	sts	0x02DD, r24
    e818:	24 c1       	rjmp	.+584    	; 0xea62 <FSettingPumpID+0x52e>
			  else
			  if (IsShift==True)IsShift=False;
    e81a:	81 30       	cpi	r24, 0x01	; 1
    e81c:	09 f0       	breq	.+2      	; 0xe820 <FSettingPumpID+0x2ec>
    e81e:	21 c1       	rjmp	.+578    	; 0xea62 <FSettingPumpID+0x52e>
    e820:	10 92 dd 02 	sts	0x02DD, r1
    e824:	1e c1       	rjmp	.+572    	; 0xea62 <FSettingPumpID+0x52e>
		  }
	      break;
     case mpSaveFailed:
	      lcd_clear();
    e826:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
		  lcd_printf(1,1,PSTR("      Warning!      "));
    e82a:	81 e0       	ldi	r24, 0x01	; 1
    e82c:	61 e0       	ldi	r22, 0x01	; 1
    e82e:	41 e6       	ldi	r20, 0x61	; 97
    e830:	5c e0       	ldi	r21, 0x0C	; 12
    e832:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		  lcd_printf(2,1,PSTR("  Duplicate PumpID  "));
    e836:	82 e0       	ldi	r24, 0x02	; 2
    e838:	61 e0       	ldi	r22, 0x01	; 1
    e83a:	4c e4       	ldi	r20, 0x4C	; 76
    e83c:	5c e0       	ldi	r21, 0x0C	; 12
    e83e:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		  lcd_printf(3,1,PSTR("    Not Allowed     "));		  
    e842:	83 e0       	ldi	r24, 0x03	; 3
    e844:	61 e0       	ldi	r22, 0x01	; 1
    e846:	47 e3       	ldi	r20, 0x37	; 55
    e848:	5c e0       	ldi	r21, 0x0C	; 12
    e84a:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    e84e:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    e850:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    e852:	82 e0       	ldi	r24, 0x02	; 2
    e854:	90 e0       	ldi	r25, 0x00	; 0
    e856:	90 93 d7 01 	sts	0x01D7, r25
    e85a:	80 93 d6 01 	sts	0x01D6, r24
	      lcd_clear();
		  lcd_printf(1,1,PSTR("      Warning!      "));
		  lcd_printf(2,1,PSTR("  Duplicate PumpID  "));
		  lcd_printf(3,1,PSTR("    Not Allowed     "));		  
		  system_beep(2);
	      TimDisplay=0;
    e85e:	10 92 a7 01 	sts	0x01A7, r1
	      stMenuPumpID=mpDisplayFailed;
    e862:	84 e0       	ldi	r24, 0x04	; 4
    e864:	e9 c0       	rjmp	.+466    	; 0xea38 <FSettingPumpID+0x504>
          break;	 
     case mpDisplayFailed:
	      if (TimDisplay>6) stMenuPumpID=mpDisplayPumpId;
    e866:	80 91 a7 01 	lds	r24, 0x01A7
    e86a:	87 30       	cpi	r24, 0x07	; 7
    e86c:	08 f4       	brcc	.+2      	; 0xe870 <FSettingPumpID+0x33c>
    e86e:	f9 c0       	rjmp	.+498    	; 0xea62 <FSettingPumpID+0x52e>
    e870:	81 e0       	ldi	r24, 0x01	; 1
    e872:	e2 c0       	rjmp	.+452    	; 0xea38 <FSettingPumpID+0x504>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    e874:	85 e4       	ldi	r24, 0x45	; 69
    e876:	90 e0       	ldi	r25, 0x00	; 0
    e878:	64 ed       	ldi	r22, 0xD4	; 212
    e87a:	72 e0       	ldi	r23, 0x02	; 2
    e87c:	48 e0       	ldi	r20, 0x08	; 8
    e87e:	50 e0       	ldi	r21, 0x00	; 0
    e880:	2b ef       	ldi	r18, 0xFB	; 251
    e882:	32 e1       	ldi	r19, 0x12	; 18
    e884:	0e 94 3b b4 	call	0x16876	; 0x16876 <__eewr_block>
	      break;
     case mpSavingPumpId:
	      eeprom_write_block((const void*) &PPumpId, (void*) &DefPumpMap, 8);
		  if (IFType==IT_STANDALONE){
    e888:	80 91 10 01 	lds	r24, 0x0110
    e88c:	82 30       	cpi	r24, 0x02	; 2
    e88e:	e9 f4       	brne	.+58     	; 0xe8ca <FSettingPumpID+0x396>
		      //SendConfig to Slave
			  lcd_clear();
    e890:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
              lcd_printf(1,1,PSTR("-PumpID-"));
    e894:	81 e0       	ldi	r24, 0x01	; 1
    e896:	61 e0       	ldi	r22, 0x01	; 1
    e898:	4e e2       	ldi	r20, 0x2E	; 46
    e89a:	5c e0       	ldi	r21, 0x0C	; 12
    e89c:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
              lcd_printf(2,1,PSTR("Saving.."));
    e8a0:	82 e0       	ldi	r24, 0x02	; 2
    e8a2:	61 e0       	ldi	r22, 0x01	; 1
    e8a4:	45 e2       	ldi	r20, 0x25	; 37
    e8a6:	5c e0       	ldi	r21, 0x0C	; 12
    e8a8:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
			  Idx=0;
    e8ac:	10 92 dc 02 	sts	0x02DC, r1
			  PumpCount=0;
    e8b0:	10 92 d2 02 	sts	0x02D2, r1
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    e8b4:	84 ed       	ldi	r24, 0xD4	; 212
    e8b6:	92 e0       	ldi	r25, 0x02	; 2
    e8b8:	65 e4       	ldi	r22, 0x45	; 69
    e8ba:	70 e0       	ldi	r23, 0x00	; 0
    e8bc:	48 e0       	ldi	r20, 0x08	; 8
    e8be:	50 e0       	ldi	r21, 0x00	; 0
    e8c0:	23 ef       	ldi	r18, 0xF3	; 243
    e8c2:	32 e1       	ldi	r19, 0x12	; 18
    e8c4:	0e 94 1f b4 	call	0x1683e	; 0x1683e <__eerd_block>
    e8c8:	b6 c0       	rjmp	.+364    	; 0xea36 <FSettingPumpID+0x502>
              eeprom_read_block((void*) &PPumpId, (const void*) &DefPumpMap,8);
              stMenuPumpID=mpSendConfigToSlave;
		  }else if (IFType==IT_SLAVE){
    e8ca:	81 30       	cpi	r24, 0x01	; 1
    e8cc:	09 f0       	breq	.+2      	; 0xe8d0 <FSettingPumpID+0x39c>
    e8ce:	c9 c0       	rjmp	.+402    	; 0xea62 <FSettingPumpID+0x52e>
    e8d0:	ba c0       	rjmp	.+372    	; 0xea46 <FSettingPumpID+0x512>
		      //SendConfig to Slave              
              stMenuPumpID=mpExitPumpId;
		  }
	      break;
     case mpSendConfigToSlave:
	      IsStandaloneAcknoledge=False;
    e8d2:	10 92 95 01 	sts	0x0195, r1
	      if (PPumpId[Idx]!=0){
    e8d6:	90 91 dc 02 	lds	r25, 0x02DC
    e8da:	29 2f       	mov	r18, r25
    e8dc:	30 e0       	ldi	r19, 0x00	; 0
    e8de:	f9 01       	movw	r30, r18
    e8e0:	ec 52       	subi	r30, 0x2C	; 44
    e8e2:	fd 4f       	sbci	r31, 0xFD	; 253
    e8e4:	60 81       	ld	r22, Z
    e8e6:	66 23       	and	r22, r22
    e8e8:	81 f0       	breq	.+32     	; 0xe90a <FSettingPumpID+0x3d6>
		      PumpCount++;
    e8ea:	80 91 d2 02 	lds	r24, 0x02D2
    e8ee:	8f 5f       	subi	r24, 0xFF	; 255
    e8f0:	80 93 d2 02 	sts	0x02D2, r24
		      MsgPumpId=((Idx<<4)|(0x0F&PPumpId[Idx]));//[Idx][PumpId]
    e8f4:	6f 70       	andi	r22, 0x0F	; 15
    e8f6:	74 e0       	ldi	r23, 0x04	; 4
    e8f8:	22 0f       	add	r18, r18
    e8fa:	33 1f       	adc	r19, r19
    e8fc:	7a 95       	dec	r23
    e8fe:	e1 f7       	brne	.-8      	; 0xe8f8 <FSettingPumpID+0x3c4>
    e900:	62 2b       	or	r22, r18
    e902:	60 93 d3 02 	sts	0x02D3, r22
	         //SendPoolingCommand(SC_SET_PUMPID,MsgPumpId);
			  SendSlaveCommand(SC_SET_PUMPID,MsgPumpId);
    e906:	8d e1       	ldi	r24, 0x1D	; 29
    e908:	02 c0       	rjmp	.+4      	; 0xe90e <FSettingPumpID+0x3da>
		  }else SendSlaveCommand(SC_CLEAR_PUMPID,Idx);//SendPoolingCommand(SC_CLEAR_PUMPID,Idx);
    e90a:	8e e1       	ldi	r24, 0x1E	; 30
    e90c:	69 2f       	mov	r22, r25
    e90e:	0e 94 83 72 	call	0xe506	; 0xe506 <SendSlaveCommand>
		  sprintf_P(lcdteks,PSTR("Id[%d]=%.2d  "),Idx+1,PPumpId[Idx]);
    e912:	e0 91 dc 02 	lds	r30, 0x02DC
    e916:	f0 e0       	ldi	r31, 0x00	; 0
    e918:	ad b7       	in	r26, 0x3d	; 61
    e91a:	be b7       	in	r27, 0x3e	; 62
    e91c:	18 97       	sbiw	r26, 0x08	; 8
    e91e:	0f b6       	in	r0, 0x3f	; 63
    e920:	f8 94       	cli
    e922:	be bf       	out	0x3e, r27	; 62
    e924:	0f be       	out	0x3f, r0	; 63
    e926:	ad bf       	out	0x3d, r26	; 61
    e928:	2d b7       	in	r18, 0x3d	; 61
    e92a:	3e b7       	in	r19, 0x3e	; 62
    e92c:	2f 5f       	subi	r18, 0xFF	; 255
    e92e:	3f 4f       	sbci	r19, 0xFF	; 255
    e930:	8e 01       	movw	r16, r28
    e932:	0f 5f       	subi	r16, 0xFF	; 255
    e934:	1f 4f       	sbci	r17, 0xFF	; 255
    e936:	12 96       	adiw	r26, 0x02	; 2
    e938:	1c 93       	st	X, r17
    e93a:	0e 93       	st	-X, r16
    e93c:	11 97       	sbiw	r26, 0x01	; 1
    e93e:	87 e1       	ldi	r24, 0x17	; 23
    e940:	9c e0       	ldi	r25, 0x0C	; 12
    e942:	d9 01       	movw	r26, r18
    e944:	13 96       	adiw	r26, 0x03	; 3
    e946:	9c 93       	st	X, r25
    e948:	8e 93       	st	-X, r24
    e94a:	12 97       	sbiw	r26, 0x02	; 2
    e94c:	31 96       	adiw	r30, 0x01	; 1
    e94e:	15 96       	adiw	r26, 0x05	; 5
    e950:	fc 93       	st	X, r31
    e952:	ee 93       	st	-X, r30
    e954:	14 97       	sbiw	r26, 0x04	; 4
    e956:	31 97       	sbiw	r30, 0x01	; 1
    e958:	ec 52       	subi	r30, 0x2C	; 44
    e95a:	fd 4f       	sbci	r31, 0xFD	; 253
    e95c:	80 81       	ld	r24, Z
    e95e:	16 96       	adiw	r26, 0x06	; 6
    e960:	8c 93       	st	X, r24
    e962:	16 97       	sbiw	r26, 0x06	; 6
    e964:	17 96       	adiw	r26, 0x07	; 7
    e966:	1c 92       	st	X, r1
    e968:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
		  lcd_print(3,1,lcdteks);
    e96c:	ed b7       	in	r30, 0x3d	; 61
    e96e:	fe b7       	in	r31, 0x3e	; 62
    e970:	38 96       	adiw	r30, 0x08	; 8
    e972:	0f b6       	in	r0, 0x3f	; 63
    e974:	f8 94       	cli
    e976:	fe bf       	out	0x3e, r31	; 62
    e978:	0f be       	out	0x3f, r0	; 63
    e97a:	ed bf       	out	0x3d, r30	; 61
    e97c:	83 e0       	ldi	r24, 0x03	; 3
    e97e:	61 e0       	ldi	r22, 0x01	; 1
    e980:	a8 01       	movw	r20, r16
    e982:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
          stMenuPumpID=mpWaitSlaveReply;
    e986:	88 e0       	ldi	r24, 0x08	; 8
    e988:	57 c0       	rjmp	.+174    	; 0xea38 <FSettingPumpID+0x504>
	      break;
     case mpWaitSlaveReply:
	      KeyPressed=_key_scan(1);
    e98a:	81 e0       	ldi	r24, 0x01	; 1
    e98c:	0e 94 ab ae 	call	0x15d56	; 0x15d56 <_key_scan>
	      KeyChar=_key_btn(KeyPressed);
    e990:	0e 94 0c ae 	call	0x15c18	; 0x15c18 <_key_btn>
		  if (KeyChar=='*'){
    e994:	8a 32       	cpi	r24, 0x2A	; 42
    e996:	99 f4       	brne	.+38     	; 0xe9be <FSettingPumpID+0x48a>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    e998:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    e99a:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    e99c:	82 e0       	ldi	r24, 0x02	; 2
    e99e:	90 e0       	ldi	r25, 0x00	; 0
    e9a0:	90 93 d7 01 	sts	0x01D7, r25
    e9a4:	80 93 d6 01 	sts	0x01D6, r24
     case mpWaitSlaveReply:
	      KeyPressed=_key_scan(1);
	      KeyChar=_key_btn(KeyPressed);
		  if (KeyChar=='*'){
		      system_beep(2);
		      lcd_printf(2,1,PSTR("Cancel     "));
    e9a8:	82 e0       	ldi	r24, 0x02	; 2
    e9aa:	61 e0       	ldi	r22, 0x01	; 1
    e9ac:	4b e0       	ldi	r20, 0x0B	; 11
    e9ae:	5c e0       	ldi	r21, 0x0C	; 12
    e9b0:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
			  TimDisplay=0;
    e9b4:	10 92 a7 01 	sts	0x01A7, r1
		      stMenuPumpID=mpDelayExitPumpId;
    e9b8:	89 e0       	ldi	r24, 0x09	; 9
    e9ba:	80 93 de 02 	sts	0x02DE, r24
			  }
          if (IsStandaloneAcknoledge==True){
    e9be:	80 91 95 01 	lds	r24, 0x0195
    e9c2:	81 30       	cpi	r24, 0x01	; 1
    e9c4:	09 f0       	breq	.+2      	; 0xe9c8 <FSettingPumpID+0x494>
    e9c6:	4d c0       	rjmp	.+154    	; 0xea62 <FSettingPumpID+0x52e>
		      Idx++;
    e9c8:	80 91 dc 02 	lds	r24, 0x02DC
    e9cc:	8f 5f       	subi	r24, 0xFF	; 255
    e9ce:	80 93 dc 02 	sts	0x02DC, r24
		      if (Idx<8){//Finish, Send MaxPumpCount
    e9d2:	88 30       	cpi	r24, 0x08	; 8
    e9d4:	10 f5       	brcc	.+68     	; 0xea1a <FSettingPumpID+0x4e6>
			      eeprom_write_byte(&DefPoolingPumpMax,PumpCount);
    e9d6:	20 91 d2 02 	lds	r18, 0x02D2
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    e9da:	e1 99       	sbic	0x1c, 1	; 28
    e9dc:	fe cf       	rjmp	.-4      	; 0xe9da <FSettingPumpID+0x4a6>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    e9de:	84 e4       	ldi	r24, 0x44	; 68
    e9e0:	91 e0       	ldi	r25, 0x01	; 1
    e9e2:	9f bb       	out	0x1f, r25	; 31
    e9e4:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    e9e6:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
    e9e8:	0f b6       	in	r0, 0x3f	; 63
    e9ea:	f8 94       	cli
    e9ec:	e2 9a       	sbi	0x1c, 2	; 28
    e9ee:	e1 9a       	sbi	0x1c, 1	; 28
    e9f0:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    e9f2:	e1 99       	sbic	0x1c, 1	; 28
    e9f4:	fe cf       	rjmp	.-4      	; 0xe9f2 <FSettingPumpID+0x4be>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    e9f6:	9f bb       	out	0x1f, r25	; 31
    e9f8:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    e9fa:	e0 9a       	sbi	0x1c, 0	; 28
    e9fc:	9d b3       	in	r25, 0x1d	; 29
				  PumpCountMax=eeprom_read_byte(&DefPoolingPumpMax);
    e9fe:	90 93 5f 01 	sts	0x015F, r25
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
    ea02:	85 e1       	ldi	r24, 0x15	; 21
    ea04:	80 93 8a 07 	sts	0x078A, r24
	 PoolMsg=plMsg;
    ea08:	90 93 ae 0d 	sts	0x0DAE, r25
     IsControlPooling=True;
    ea0c:	81 e0       	ldi	r24, 0x01	; 1
    ea0e:	80 93 97 01 	sts	0x0197, r24
		      Idx++;
		      if (Idx<8){//Finish, Send MaxPumpCount
			      eeprom_write_byte(&DefPoolingPumpMax,PumpCount);
				  PumpCountMax=eeprom_read_byte(&DefPoolingPumpMax);
                  SendPoolingCommand(SC_SET_POOLING_MAX_PUMP,PumpCountMax);
			      TimDisplay=0;		 
    ea12:	10 92 a7 01 	sts	0x01A7, r1
				  stMenuPumpID=mpDelaySaveConfig;
    ea16:	87 e0       	ldi	r24, 0x07	; 7
    ea18:	0f c0       	rjmp	.+30     	; 0xea38 <FSettingPumpID+0x504>
			  }else{lcd_printf(2,1,PSTR("Completed"));
    ea1a:	82 e0       	ldi	r24, 0x02	; 2
    ea1c:	61 e0       	ldi	r22, 0x01	; 1
    ea1e:	41 e0       	ldi	r20, 0x01	; 1
    ea20:	5c e0       	ldi	r21, 0x0C	; 12
    ea22:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
					TimDisplay=0;
    ea26:	10 92 a7 01 	sts	0x01A7, r1
				    stMenuPumpID=mpDelayExitPumpId;
    ea2a:	89 e0       	ldi	r24, 0x09	; 9
    ea2c:	05 c0       	rjmp	.+10     	; 0xea38 <FSettingPumpID+0x504>
				   }
			  }		  
	      break;
     case mpDelaySaveConfig:
	      if (TimDisplay>2)stMenuPumpID=mpSendConfigToSlave;
    ea2e:	80 91 a7 01 	lds	r24, 0x01A7
    ea32:	83 30       	cpi	r24, 0x03	; 3
    ea34:	b0 f0       	brcs	.+44     	; 0xea62 <FSettingPumpID+0x52e>
    ea36:	86 e0       	ldi	r24, 0x06	; 6
    ea38:	80 93 de 02 	sts	0x02DE, r24
    ea3c:	12 c0       	rjmp	.+36     	; 0xea62 <FSettingPumpID+0x52e>
	      break;
     case mpDelayExitPumpId:
	      if (TimDisplay>8)stMenuPumpID=mpExitPumpId;
    ea3e:	80 91 a7 01 	lds	r24, 0x01A7
    ea42:	89 30       	cpi	r24, 0x09	; 9
    ea44:	70 f0       	brcs	.+28     	; 0xea62 <FSettingPumpID+0x52e>
    ea46:	8a e0       	ldi	r24, 0x0A	; 10
    ea48:	f7 cf       	rjmp	.-18     	; 0xea38 <FSettingPumpID+0x504>
	      break;
     case mpExitPumpId:
	      if (IFType==IT_STANDALONE)
    ea4a:	80 91 10 01 	lds	r24, 0x0110
    ea4e:	82 30       	cpi	r24, 0x02	; 2
    ea50:	21 f4       	brne	.+8      	; 0xea5a <FSettingPumpID+0x526>
		      SendSlaveCommand(SC_START_POOL_SEQUENCE,0);
    ea52:	80 e2       	ldi	r24, 0x20	; 32
    ea54:	60 e0       	ldi	r22, 0x00	; 0
    ea56:	0e 94 83 72 	call	0xe506	; 0xe506 <SendSlaveCommand>
	      Result=MENU_DONE;
          stMenuPumpID=mpInitPumpId;
    ea5a:	10 92 de 02 	sts	0x02DE, r1
    ea5e:	81 e0       	ldi	r24, 0x01	; 1
    ea60:	01 c0       	rjmp	.+2      	; 0xea64 <FSettingPumpID+0x530>
    ea62:	80 e0       	ldi	r24, 0x00	; 0
	      break;
	 }
   return Result;
}
    ea64:	64 96       	adiw	r28, 0x14	; 20
    ea66:	0f b6       	in	r0, 0x3f	; 63
    ea68:	f8 94       	cli
    ea6a:	de bf       	out	0x3e, r29	; 62
    ea6c:	0f be       	out	0x3f, r0	; 63
    ea6e:	cd bf       	out	0x3d, r28	; 61
    ea70:	cf 91       	pop	r28
    ea72:	df 91       	pop	r29
    ea74:	1f 91       	pop	r17
    ea76:	0f 91       	pop	r16
    ea78:	ff 90       	pop	r15
    ea7a:	ef 90       	pop	r14
    ea7c:	df 90       	pop	r13
    ea7e:	cf 90       	pop	r12
    ea80:	bf 90       	pop	r11
    ea82:	af 90       	pop	r10
    ea84:	9f 90       	pop	r9
    ea86:	08 95       	ret

0000ea88 <_menu_pumpid>:

void _menu_pumpid(void){
	while(1){
	   if (FSettingPumpID()==MENU_DONE){
    ea88:	0e 94 9a 72 	call	0xe534	; 0xe534 <FSettingPumpID>
    ea8c:	81 30       	cpi	r24, 0x01	; 1
    ea8e:	e1 f7       	brne	.-8      	; 0xea88 <_menu_pumpid>
	       break;
	   }	   
	}
}
    ea90:	08 95       	ret

0000ea92 <_menu_pump>:
        lcd_printf(4,15,PSTR("*)Exit"));
}



void _menu_pump(void){
    ea92:	cf 93       	push	r28
    ea94:	df 93       	push	r29
    ea96:	c4 ec       	ldi	r28, 0xC4	; 196
    ea98:	d9 e0       	ldi	r29, 0x09	; 9
	char __key;

	while(1){
		lcd_clear();_delay_ms(10);
    ea9a:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
    ea9e:	ce 01       	movw	r24, r28
    eaa0:	01 97       	sbiw	r24, 0x01	; 1
    eaa2:	f1 f7       	brne	.-4      	; 0xeaa0 <_menu_pump+0xe>
		lcd_printf(1, 1, PSTR("1)ID"));
    eaa4:	81 e0       	ldi	r24, 0x01	; 1
    eaa6:	61 e0       	ldi	r22, 0x01	; 1
    eaa8:	45 e3       	ldi	r20, 0x35	; 53
    eaaa:	5d e0       	ldi	r21, 0x0D	; 13
    eaac:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		lcd_printf(2, 1, PSTR("2)Product"));
    eab0:	82 e0       	ldi	r24, 0x02	; 2
    eab2:	61 e0       	ldi	r22, 0x01	; 1
    eab4:	4b e2       	ldi	r20, 0x2B	; 43
    eab6:	5d e0       	ldi	r21, 0x0D	; 13
    eab8:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		lcd_printf(4, 1, PSTR("*)Exit"));
    eabc:	84 e0       	ldi	r24, 0x04	; 4
    eabe:	61 e0       	ldi	r22, 0x01	; 1
    eac0:	44 e2       	ldi	r20, 0x24	; 36
    eac2:	5d e0       	ldi	r21, 0x0D	; 13
    eac4:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>

		while(1){
			__key = _key_scan(1);
    eac8:	81 e0       	ldi	r24, 0x01	; 1
    eaca:	0e 94 ab ae 	call	0x15d56	; 0x15d56 <_key_scan>
			if(__key == _KEY_CANCEL)
    eace:	87 3e       	cpi	r24, 0xE7	; 231
    ead0:	51 f0       	breq	.+20     	; 0xeae6 <_menu_pump+0x54>
				return;
			if(__key == _KEY_1){
    ead2:	8e 3e       	cpi	r24, 0xEE	; 238
    ead4:	19 f4       	brne	.+6      	; 0xeadc <_menu_pump+0x4a>
				_menu_pumpid();
    ead6:	0e 94 44 75 	call	0xea88	; 0xea88 <_menu_pumpid>
    eada:	df cf       	rjmp	.-66     	; 0xea9a <_menu_pump+0x8>
				break;
			}
			if(__key == _KEY_2){
    eadc:	8e 3d       	cpi	r24, 0xDE	; 222
    eade:	a1 f7       	brne	.-24     	; 0xeac8 <_menu_pump+0x36>
				_menu_pumpprod();
    eae0:	0e 94 cf 47 	call	0x8f9e	; 0x8f9e <_menu_pumpprod>
    eae4:	da cf       	rjmp	.-76     	; 0xea9a <_menu_pump+0x8>
				break;
			}
		}
	}
}
    eae6:	df 91       	pop	r29
    eae8:	cf 91       	pop	r28
    eaea:	08 95       	ret

0000eaec <FMenuPumpType>:





void FMenuPumpType(){
    eaec:	cf 92       	push	r12
    eaee:	df 92       	push	r13
    eaf0:	ef 92       	push	r14
    eaf2:	ff 92       	push	r15
    eaf4:	0f 93       	push	r16
    eaf6:	1f 93       	push	r17
    eaf8:	df 93       	push	r29
    eafa:	cf 93       	push	r28
    eafc:	cd b7       	in	r28, 0x3d	; 61
    eafe:	de b7       	in	r29, 0x3e	; 62
    eb00:	a8 97       	sbiw	r28, 0x28	; 40
    eb02:	0f b6       	in	r0, 0x3f	; 63
    eb04:	f8 94       	cli
    eb06:	de bf       	out	0x3e, r29	; 62
    eb08:	0f be       	out	0x3f, r0	; 63
    eb0a:	cd bf       	out	0x3d, r28	; 61
     stPumpType=ptInitMenu;
	 IsRunPumpType=True;
	 while(IsRunPumpType==True){
		  switch(stPumpType){
		  case ptInitMenu:
		       lcd_clear();
    eb0c:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
			   lcd_printf(1,1,PSTR("-Dispenser Brand-"));
    eb10:	81 e0       	ldi	r24, 0x01	; 1
    eb12:	61 e0       	ldi	r22, 0x01	; 1
    eb14:	42 e1       	ldi	r20, 0x12	; 18
    eb16:	5d e0       	ldi	r21, 0x0D	; 13
    eb18:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    eb1c:	e1 99       	sbic	0x1c, 1	; 28
    eb1e:	fe cf       	rjmp	.-4      	; 0xeb1c <FMenuPumpType+0x30>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    eb20:	87 e3       	ldi	r24, 0x37	; 55
    eb22:	91 e0       	ldi	r25, 0x01	; 1
    eb24:	9f bb       	out	0x1f, r25	; 31
    eb26:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    eb28:	e0 9a       	sbi	0x1c, 0	; 28
    eb2a:	0d b3       	in	r16, 0x1d	; 29
			   IdxType=eeprom_read_byte(&DefDispenserBrand);
			   //Brand Selection
			   if (IdxType>=3) IdxType=0;
    eb2c:	03 30       	cpi	r16, 0x03	; 3
    eb2e:	08 f0       	brcs	.+2      	; 0xeb32 <FMenuPumpType+0x46>
    eb30:	00 e0       	ldi	r16, 0x00	; 0
               strcpy_P(DispenserBrandName,(PGM_P)pgm_read_word(&(DefListDispenserName[IdxType])));
    eb32:	10 e0       	ldi	r17, 0x00	; 0
    eb34:	f8 01       	movw	r30, r16
    eb36:	ee 0f       	add	r30, r30
    eb38:	ff 1f       	adc	r31, r31
    eb3a:	e5 5d       	subi	r30, 0xD5	; 213
    eb3c:	fc 4f       	sbci	r31, 0xFC	; 252
    eb3e:	65 91       	lpm	r22, Z+
    eb40:	74 91       	lpm	r23, Z+
    eb42:	85 e1       	ldi	r24, 0x15	; 21
    eb44:	c8 2e       	mov	r12, r24
    eb46:	d1 2c       	mov	r13, r1
    eb48:	cc 0e       	add	r12, r28
    eb4a:	dd 1e       	adc	r13, r29
    eb4c:	c6 01       	movw	r24, r12
    eb4e:	0e 94 08 b4 	call	0x16810	; 0x16810 <strcpy_P>
			   sprintf_P(lcdteks,PSTR("%d.%s"),IdxType+1,DispenserBrandName);
    eb52:	8d b7       	in	r24, 0x3d	; 61
    eb54:	9e b7       	in	r25, 0x3e	; 62
    eb56:	08 97       	sbiw	r24, 0x08	; 8
    eb58:	0f b6       	in	r0, 0x3f	; 63
    eb5a:	f8 94       	cli
    eb5c:	9e bf       	out	0x3e, r25	; 62
    eb5e:	0f be       	out	0x3f, r0	; 63
    eb60:	8d bf       	out	0x3d, r24	; 61
    eb62:	ed b7       	in	r30, 0x3d	; 61
    eb64:	fe b7       	in	r31, 0x3e	; 62
    eb66:	31 96       	adiw	r30, 0x01	; 1
    eb68:	7e 01       	movw	r14, r28
    eb6a:	08 94       	sec
    eb6c:	e1 1c       	adc	r14, r1
    eb6e:	f1 1c       	adc	r15, r1
    eb70:	ad b7       	in	r26, 0x3d	; 61
    eb72:	be b7       	in	r27, 0x3e	; 62
    eb74:	12 96       	adiw	r26, 0x02	; 2
    eb76:	fc 92       	st	X, r15
    eb78:	ee 92       	st	-X, r14
    eb7a:	11 97       	sbiw	r26, 0x01	; 1
    eb7c:	8c e0       	ldi	r24, 0x0C	; 12
    eb7e:	9d e0       	ldi	r25, 0x0D	; 13
    eb80:	93 83       	std	Z+3, r25	; 0x03
    eb82:	82 83       	std	Z+2, r24	; 0x02
    eb84:	0f 5f       	subi	r16, 0xFF	; 255
    eb86:	1f 4f       	sbci	r17, 0xFF	; 255
    eb88:	15 83       	std	Z+5, r17	; 0x05
    eb8a:	04 83       	std	Z+4, r16	; 0x04
    eb8c:	d7 82       	std	Z+7, r13	; 0x07
    eb8e:	c6 82       	std	Z+6, r12	; 0x06
    eb90:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
			   lcd_print(2,1,lcdteks);
    eb94:	8d b7       	in	r24, 0x3d	; 61
    eb96:	9e b7       	in	r25, 0x3e	; 62
    eb98:	08 96       	adiw	r24, 0x08	; 8
    eb9a:	0f b6       	in	r0, 0x3f	; 63
    eb9c:	f8 94       	cli
    eb9e:	9e bf       	out	0x3e, r25	; 62
    eba0:	0f be       	out	0x3f, r0	; 63
    eba2:	8d bf       	out	0x3d, r24	; 61
    eba4:	82 e0       	ldi	r24, 0x02	; 2
    eba6:	61 e0       	ldi	r22, 0x01	; 1
    eba8:	a7 01       	movw	r20, r14
    ebaa:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
			   lcd_printf(4,1,PSTR("[*]Exit  [#]Change "));
    ebae:	84 e0       	ldi	r24, 0x04	; 4
    ebb0:	61 e0       	ldi	r22, 0x01	; 1
    ebb2:	48 ef       	ldi	r20, 0xF8	; 248
    ebb4:	5c e0       	ldi	r21, 0x0C	; 12
    ebb6:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
			   if (IFType==IT_STANDALONE)
    ebba:	80 91 10 01 	lds	r24, 0x0110
    ebbe:	82 30       	cpi	r24, 0x02	; 2
    ebc0:	21 f4       	brne	.+8      	; 0xebca <FMenuPumpType+0xde>
			       SendSlaveCommand(SC_STOP_POOL_SEQUENCE,0);
    ebc2:	8f e1       	ldi	r24, 0x1F	; 31
    ebc4:	60 e0       	ldi	r22, 0x00	; 0
    ebc6:	0e 94 83 72 	call	0xe506	; 0xe506 <SendSlaveCommand>
			   stPumpType=ptSelectBrand;
	 		   break;
          case ptSelectBrand:
		       KeyPressed = _key_scan(1);
    ebca:	81 e0       	ldi	r24, 0x01	; 1
    ebcc:	0e 94 ab ae 	call	0x15d56	; 0x15d56 <_key_scan>
		       KeyChar    = _key_btn(KeyPressed);
    ebd0:	0e 94 0c ae 	call	0x15c18	; 0x15c18 <_key_btn>

			   if (KeyChar=='#'){
    ebd4:	83 32       	cpi	r24, 0x23	; 35
    ebd6:	09 f0       	breq	.+2      	; 0xebda <FMenuPumpType+0xee>
    ebd8:	2d c0       	rjmp	.+90     	; 0xec34 <FMenuPumpType+0x148>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    ebda:	e1 99       	sbic	0x1c, 1	; 28
    ebdc:	fe cf       	rjmp	.-4      	; 0xebda <FMenuPumpType+0xee>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    ebde:	07 e3       	ldi	r16, 0x37	; 55
    ebe0:	11 e0       	ldi	r17, 0x01	; 1
    ebe2:	1f bb       	out	0x1f, r17	; 31
    ebe4:	0e bb       	out	0x1e, r16	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    ebe6:	e0 9a       	sbi	0x1c, 0	; 28
    ebe8:	8d b3       	in	r24, 0x1d	; 29
			       DispenserBrand=eeprom_read_byte(&DefDispenserBrand);
				   if (DispenserBrand<ST_WAYNE_DART)
    ebea:	82 30       	cpi	r24, 0x02	; 2
    ebec:	20 f4       	brcc	.+8      	; 0xebf6 <FMenuPumpType+0x10a>
				        DispenserBrand++;
    ebee:	8f 5f       	subi	r24, 0xFF	; 255
    ebf0:	80 93 61 01 	sts	0x0161, r24
    ebf4:	02 c0       	rjmp	.+4      	; 0xebfa <FMenuPumpType+0x10e>
				   else DispenserBrand=ST_NONE;
    ebf6:	10 92 61 01 	sts	0x0161, r1
                   //Apply DecimalSetting  
				   SetDispenser(DispenserBrand);
    ebfa:	80 91 61 01 	lds	r24, 0x0161
    ebfe:	0e 94 fc 1a 	call	0x35f8	; 0x35f8 <SetDispenser>

			       eeprom_write_byte(&DefDispenserBrand,DispenserBrand);
    ec02:	80 91 61 01 	lds	r24, 0x0161
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    ec06:	e1 99       	sbic	0x1c, 1	; 28
    ec08:	fe cf       	rjmp	.-4      	; 0xec06 <FMenuPumpType+0x11a>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    ec0a:	1f bb       	out	0x1f, r17	; 31
    ec0c:	0e bb       	out	0x1e, r16	; 30
#endif
    EEDR = __value;
    ec0e:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    ec10:	0f b6       	in	r0, 0x3f	; 63
    ec12:	f8 94       	cli
    ec14:	e2 9a       	sbi	0x1c, 2	; 28
    ec16:	e1 9a       	sbi	0x1c, 1	; 28
    ec18:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    ec1a:	e1 99       	sbic	0x1c, 1	; 28
    ec1c:	fe cf       	rjmp	.-4      	; 0xec1a <FMenuPumpType+0x12e>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    ec1e:	1f bb       	out	0x1f, r17	; 31
    ec20:	0e bb       	out	0x1e, r16	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    ec22:	e0 9a       	sbi	0x1c, 0	; 28
    ec24:	6d b3       	in	r22, 0x1d	; 29
				   //SendPoolingCommand(SC_SET_PUMP_TYPE,eeprom_read_byte(&DefDispenserBrand));
				   SendSlaveCommand(SC_SET_PUMP_TYPE,eeprom_read_byte(&DefDispenserBrand));
    ec26:	8c e1       	ldi	r24, 0x1C	; 28
    ec28:	0e 94 83 72 	call	0xe506	; 0xe506 <SendSlaveCommand>
				   IsSetPumpType=True;//False;
    ec2c:	81 e0       	ldi	r24, 0x01	; 1
    ec2e:	80 93 23 01 	sts	0x0123, r24
    ec32:	0c c0       	rjmp	.+24     	; 0xec4c <FMenuPumpType+0x160>
			       stPumpType=ptUpdated;			   
			   }else
			   if (KeyChar=='*'){
    ec34:	8a 32       	cpi	r24, 0x2A	; 42
    ec36:	09 f0       	breq	.+2      	; 0xec3a <FMenuPumpType+0x14e>
    ec38:	c8 cf       	rjmp	.-112    	; 0xebca <FMenuPumpType+0xde>
			       IsRunPumpType=False;
				   if (IFType==IT_STANDALONE)SendSlaveCommand(SC_START_POOL_SEQUENCE,0);
    ec3a:	80 91 10 01 	lds	r24, 0x0110
    ec3e:	82 30       	cpi	r24, 0x02	; 2
    ec40:	51 f4       	brne	.+20     	; 0xec56 <FMenuPumpType+0x16a>
    ec42:	80 e2       	ldi	r24, 0x20	; 32
    ec44:	60 e0       	ldi	r22, 0x00	; 0
    ec46:	0e 94 83 72 	call	0xe506	; 0xe506 <SendSlaveCommand>
    ec4a:	05 c0       	rjmp	.+10     	; 0xec56 <FMenuPumpType+0x16a>
			   }
		       break;
          case ptUpdated:
		       if (IsSetPumpType==True){
    ec4c:	80 91 23 01 	lds	r24, 0x0123
    ec50:	81 30       	cpi	r24, 0x01	; 1
    ec52:	e1 f7       	brne	.-8      	; 0xec4c <FMenuPumpType+0x160>
    ec54:	5b cf       	rjmp	.-330    	; 0xeb0c <FMenuPumpType+0x20>
			       stPumpType=ptInitMenu;
			   }
		       break;		         
	      }
	 }     
}
    ec56:	a8 96       	adiw	r28, 0x28	; 40
    ec58:	0f b6       	in	r0, 0x3f	; 63
    ec5a:	f8 94       	cli
    ec5c:	de bf       	out	0x3e, r29	; 62
    ec5e:	0f be       	out	0x3f, r0	; 63
    ec60:	cd bf       	out	0x3d, r28	; 61
    ec62:	cf 91       	pop	r28
    ec64:	df 91       	pop	r29
    ec66:	1f 91       	pop	r17
    ec68:	0f 91       	pop	r16
    ec6a:	ff 90       	pop	r15
    ec6c:	ef 90       	pop	r14
    ec6e:	df 90       	pop	r13
    ec70:	cf 90       	pop	r12
    ec72:	08 95       	ret

0000ec74 <FSettingPump>:
   return Result;
}

char FSettingPump(){
	 char __key,Result;
		lcd_clear();_delay_ms(10);
    ec74:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
    ec78:	84 ec       	ldi	r24, 0xC4	; 196
    ec7a:	99 e0       	ldi	r25, 0x09	; 9
    ec7c:	01 97       	sbiw	r24, 0x01	; 1
    ec7e:	f1 f7       	brne	.-4      	; 0xec7c <FSettingPump+0x8>
		lcd_printf(1,1, PSTR("1)ID     "));
    ec80:	81 e0       	ldi	r24, 0x01	; 1
    ec82:	61 e0       	ldi	r22, 0x01	; 1
    ec84:	46 e8       	ldi	r20, 0x86	; 134
    ec86:	51 e1       	ldi	r21, 0x11	; 17
    ec88:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		lcd_printf(2,1, PSTR("2)Product"));
    ec8c:	82 e0       	ldi	r24, 0x02	; 2
    ec8e:	61 e0       	ldi	r22, 0x01	; 1
    ec90:	4c e7       	ldi	r20, 0x7C	; 124
    ec92:	51 e1       	ldi	r21, 0x11	; 17
    ec94:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		if (IFType==IT_STANDALONE){
    ec98:	80 91 10 01 	lds	r24, 0x0110
    ec9c:	82 30       	cpi	r24, 0x02	; 2
    ec9e:	61 f4       	brne	.+24     	; 0xecb8 <FSettingPump+0x44>
		    lcd_printf(3,1, PSTR("3)Label  "));
    eca0:	83 e0       	ldi	r24, 0x03	; 3
    eca2:	61 e0       	ldi	r22, 0x01	; 1
    eca4:	42 e7       	ldi	r20, 0x72	; 114
    eca6:	51 e1       	ldi	r21, 0x11	; 17
    eca8:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		    lcd_printf(4,1, PSTR("4)Brand  *)Exit"));
    ecac:	84 e0       	ldi	r24, 0x04	; 4
    ecae:	61 e0       	ldi	r22, 0x01	; 1
    ecb0:	42 e6       	ldi	r20, 0x62	; 98
    ecb2:	51 e1       	ldi	r21, 0x11	; 17
    ecb4:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		}

		while(1){
			__key = _key_scan(1);
    ecb8:	81 e0       	ldi	r24, 0x01	; 1
    ecba:	0e 94 ab ae 	call	0x15d56	; 0x15d56 <_key_scan>
			if(__key == _KEY_CANCEL)
    ecbe:	87 3e       	cpi	r24, 0xE7	; 231
    ecc0:	d9 f0       	breq	.+54     	; 0xecf8 <FSettingPump+0x84>
				break;
			if(__key == _KEY_1){
    ecc2:	8e 3e       	cpi	r24, 0xEE	; 238
    ecc4:	19 f4       	brne	.+6      	; 0xeccc <FSettingPump+0x58>
				_menu_pumpid();
    ecc6:	0e 94 44 75 	call	0xea88	; 0xea88 <_menu_pumpid>
    ecca:	16 c0       	rjmp	.+44     	; 0xecf8 <FSettingPump+0x84>
				break;
			}
			if(__key == _KEY_2){
    eccc:	8e 3d       	cpi	r24, 0xDE	; 222
    ecce:	19 f4       	brne	.+6      	; 0xecd6 <FSettingPump+0x62>
				_menu_pumpprod();
    ecd0:	0e 94 cf 47 	call	0x8f9e	; 0x8f9e <_menu_pumpprod>
    ecd4:	11 c0       	rjmp	.+34     	; 0xecf8 <FSettingPump+0x84>
				break;
			}

			if((__key == _KEY_3)&&(IFType==IT_STANDALONE)){
    ecd6:	8e 3b       	cpi	r24, 0xBE	; 190
    ecd8:	39 f4       	brne	.+14     	; 0xece8 <FSettingPump+0x74>
    ecda:	80 91 10 01 	lds	r24, 0x0110
    ecde:	82 30       	cpi	r24, 0x02	; 2
    ece0:	59 f7       	brne	.-42     	; 0xecb8 <FSettingPump+0x44>
			    FMenuPumpLabel();
    ece2:	0e 94 f8 47 	call	0x8ff0	; 0x8ff0 <FMenuPumpLabel>
    ece6:	08 c0       	rjmp	.+16     	; 0xecf8 <FSettingPump+0x84>
				break;
			}
			if((__key == _KEY_4)&&(IFType==IT_STANDALONE)){
    ece8:	8d 3e       	cpi	r24, 0xED	; 237
    ecea:	31 f7       	brne	.-52     	; 0xecb8 <FSettingPump+0x44>
    ecec:	80 91 10 01 	lds	r24, 0x0110
    ecf0:	82 30       	cpi	r24, 0x02	; 2
    ecf2:	11 f7       	brne	.-60     	; 0xecb8 <FSettingPump+0x44>
			    FMenuPumpType();
    ecf4:	0e 94 76 75 	call	0xeaec	; 0xeaec <FMenuPumpType>

		}

	Result=MENU_DONE;
	return Result;
}
    ecf8:	81 e0       	ldi	r24, 0x01	; 1
    ecfa:	08 95       	ret

0000ecfc <InitializeConnection>:
void InitMemory(){
     PumpCountMax=eeprom_read_byte(&DefPoolingPumpMax);
	 ActivePump=eeprom_read_byte(&DefActivePump);
}

void InitializeConnection(){
    ecfc:	af 92       	push	r10
    ecfe:	bf 92       	push	r11
    ed00:	cf 92       	push	r12
    ed02:	df 92       	push	r13
    ed04:	ef 92       	push	r14
    ed06:	ff 92       	push	r15
    ed08:	0f 93       	push	r16
    ed0a:	1f 93       	push	r17
    ed0c:	df 93       	push	r29
    ed0e:	cf 93       	push	r28
    ed10:	cd b7       	in	r28, 0x3d	; 61
    ed12:	de b7       	in	r29, 0x3e	; 62
    ed14:	64 97       	sbiw	r28, 0x14	; 20
    ed16:	0f b6       	in	r0, 0x3f	; 63
    ed18:	f8 94       	cli
    ed1a:	de bf       	out	0x3e, r29	; 62
    ed1c:	0f be       	out	0x3f, r0	; 63
    ed1e:	cd bf       	out	0x3d, r28	; 61
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    ed20:	e1 99       	sbic	0x1c, 1	; 28
    ed22:	fe cf       	rjmp	.-4      	; 0xed20 <InitializeConnection+0x24>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    ed24:	46 e3       	ldi	r20, 0x36	; 54
    ed26:	a4 2e       	mov	r10, r20
    ed28:	41 e0       	ldi	r20, 0x01	; 1
    ed2a:	b4 2e       	mov	r11, r20
    ed2c:	bf ba       	out	0x1f, r11	; 31
    ed2e:	ae ba       	out	0x1e, r10	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    ed30:	e0 9a       	sbi	0x1c, 0	; 28
    ed32:	9d b3       	in	r25, 0x1d	; 29
	unsigned int tConnect=0;
	char ForceType=IT_NONE,iCon=0,iTry=0;
	char lcdteks[20];
	IFType=eeprom_read_byte(&DefInitIFT);
    ed34:	90 93 10 01 	sts	0x0110, r25
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    ed38:	e1 99       	sbic	0x1c, 1	; 28
    ed3a:	fe cf       	rjmp	.-4      	; 0xed38 <InitializeConnection+0x3c>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    ed3c:	37 e3       	ldi	r19, 0x37	; 55
    ed3e:	c3 2e       	mov	r12, r19
    ed40:	31 e0       	ldi	r19, 0x01	; 1
    ed42:	d3 2e       	mov	r13, r19
    ed44:	df ba       	out	0x1f, r13	; 31
    ed46:	ce ba       	out	0x1e, r12	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    ed48:	e0 9a       	sbi	0x1c, 0	; 28
    ed4a:	8d b3       	in	r24, 0x1d	; 29
	DispenserBrand=eeprom_read_byte(&DefDispenserBrand);
    ed4c:	80 93 61 01 	sts	0x0161, r24

	//SendSlaveCommand(SC_STOP_POOL_SEQUENCE,0);

    //Send Msg10
	if  (IFType==IT_SLAVE){
    ed50:	91 30       	cpi	r25, 0x01	; 1
    ed52:	09 f0       	breq	.+2      	; 0xed56 <InitializeConnection+0x5a>
    ed54:	59 c0       	rjmp	.+178    	; 0xee08 <InitializeConnection+0x10c>
	     SendSlaveCommand(SC_SLAVE,ST_NONE);
    ed56:	81 e0       	ldi	r24, 0x01	; 1
    ed58:	60 e0       	ldi	r22, 0x00	; 0
    ed5a:	0e 94 83 72 	call	0xe506	; 0xe506 <SendSlaveCommand>
		 char_count=0;
    ed5e:	10 92 9d 01 	sts	0x019D, r1
    ed62:	10 92 9c 01 	sts	0x019C, r1
		 if (IsPowerOn==True){
    ed66:	80 91 9a 04 	lds	r24, 0x049A
    ed6a:	81 30       	cpi	r24, 0x01	; 1
    ed6c:	59 f4       	brne	.+22     	; 0xed84 <InitializeConnection+0x88>
		     IsPowerOn=False;
    ed6e:	10 92 9a 04 	sts	0x049A, r1
    ed72:	80 e5       	ldi	r24, 0x50	; 80
    ed74:	93 ec       	ldi	r25, 0xC3	; 195
    ed76:	29 e1       	ldi	r18, 0x19	; 25
    ed78:	30 e0       	ldi	r19, 0x00	; 0
    ed7a:	f9 01       	movw	r30, r18
    ed7c:	31 97       	sbiw	r30, 0x01	; 1
    ed7e:	f1 f7       	brne	.-4      	; 0xed7c <InitializeConnection+0x80>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    ed80:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    ed82:	d9 f7       	brne	.-10     	; 0xed7a <InitializeConnection+0x7e>
		     _delay_ms(5000);
			 }
         sendMessage10();
    ed84:	0e 94 82 52 	call	0xa504	; 0xa504 <sendMessage10>
         lcd_printf(4,1,PSTR("Connect         "));
    ed88:	84 e0       	ldi	r24, 0x04	; 4
    ed8a:	61 e0       	ldi	r22, 0x01	; 1
    ed8c:	4f e7       	ldi	r20, 0x7F	; 127
    ed8e:	5c e1       	ldi	r21, 0x1C	; 28
    ed90:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		 lcd_printf(4,1,PSTR("Connect"));
    ed94:	84 e0       	ldi	r24, 0x04	; 4
    ed96:	61 e0       	ldi	r22, 0x01	; 1
    ed98:	47 e7       	ldi	r20, 0x77	; 119
    ed9a:	5c e1       	ldi	r21, 0x1C	; 28
    ed9c:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		 //EstablishConnection TCP/IP
		 IsMessage11=False;
    eda0:	10 92 b7 01 	sts	0x01B7, r1
    eda4:	ee 24       	eor	r14, r14
    eda6:	ff 24       	eor	r15, r15
    eda8:	10 e0       	ldi	r17, 0x00	; 0
    edaa:	00 e0       	ldi	r16, 0x00	; 0
    edac:	29 c0       	rjmp	.+82     	; 0xee00 <InitializeConnection+0x104>
		  //SlaveIdentification		  
		 while (IsMessage11==False){
		        lcd_put(4,(8+iCon),'.');
    edae:	61 2f       	mov	r22, r17
    edb0:	68 5f       	subi	r22, 0xF8	; 248
    edb2:	84 e0       	ldi	r24, 0x04	; 4
    edb4:	4e e2       	ldi	r20, 0x2E	; 46
    edb6:	0e 94 7f ad 	call	0x15afe	; 0x15afe <lcd_put>
                tConnect++;
    edba:	08 94       	sec
    edbc:	e1 1c       	adc	r14, r1
    edbe:	f1 1c       	adc	r15, r1
			    if ((tConnect%800)==0)iCon++;
    edc0:	c7 01       	movw	r24, r14
    edc2:	60 e2       	ldi	r22, 0x20	; 32
    edc4:	73 e0       	ldi	r23, 0x03	; 3
    edc6:	0e 94 38 b7 	call	0x16e70	; 0x16e70 <__udivmodhi4>
    edca:	89 2b       	or	r24, r25
    edcc:	09 f4       	brne	.+2      	; 0xedd0 <InitializeConnection+0xd4>
    edce:	1f 5f       	subi	r17, 0xFF	; 255
			    if (iCon>8){
    edd0:	19 30       	cpi	r17, 0x09	; 9
    edd2:	70 f0       	brcs	.+28     	; 0xedf0 <InitializeConnection+0xf4>
			        lcd_printf(4,1,PSTR("Connect         "));
    edd4:	84 e0       	ldi	r24, 0x04	; 4
    edd6:	61 e0       	ldi	r22, 0x01	; 1
    edd8:	46 e6       	ldi	r20, 0x66	; 102
    edda:	5c e1       	ldi	r21, 0x1C	; 28
    eddc:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
				    sendMessage10();
    ede0:	0e 94 82 52 	call	0xa504	; 0xa504 <sendMessage10>
				    SendSlaveCommand(SC_SLAVE,ST_NONE);
    ede4:	81 e0       	ldi	r24, 0x01	; 1
    ede6:	60 e0       	ldi	r22, 0x00	; 0
    ede8:	0e 94 83 72 	call	0xe506	; 0xe506 <SendSlaveCommand>
			        iCon=0;
				    iTry++;}
    edec:	0f 5f       	subi	r16, 0xFF	; 255
    edee:	10 e0       	ldi	r17, 0x00	; 0
			    if (iTry>3){
    edf0:	04 30       	cpi	r16, 0x04	; 4
    edf2:	30 f0       	brcs	.+12     	; 0xee00 <InitializeConnection+0x104>
			        //IsErrorTCPIP=True;
				    IsAdvanzStartupInfo=False;		
    edf4:	10 92 c1 01 	sts	0x01C1, r1
					IFType=IT_STANDALONE;
    edf8:	82 e0       	ldi	r24, 0x02	; 2
    edfa:	80 93 10 01 	sts	0x0110, r24
    edfe:	04 c0       	rjmp	.+8      	; 0xee08 <InitializeConnection+0x10c>
         lcd_printf(4,1,PSTR("Connect         "));
		 lcd_printf(4,1,PSTR("Connect"));
		 //EstablishConnection TCP/IP
		 IsMessage11=False;
		  //SlaveIdentification		  
		 while (IsMessage11==False){
    ee00:	80 91 b7 01 	lds	r24, 0x01B7
    ee04:	88 23       	and	r24, r24
    ee06:	99 f2       	breq	.-90     	; 0xedae <InitializeConnection+0xb2>
				    break;
			    }
            }//EndWhile
		}

	if (IFType==IT_STANDALONE){
    ee08:	80 91 10 01 	lds	r24, 0x0110
    ee0c:	82 30       	cpi	r24, 0x02	; 2
    ee0e:	09 f0       	breq	.+2      	; 0xee12 <InitializeConnection+0x116>
    ee10:	72 c0       	rjmp	.+228    	; 0xeef6 <InitializeConnection+0x1fa>
        IsStandAloneDetected=False;		
    ee12:	10 92 b3 01 	sts	0x01B3, r1
		SendSlaveCommand(SC_STANDALONE,DispenserBrand);
    ee16:	60 91 61 01 	lds	r22, 0x0161
    ee1a:	0e 94 83 72 	call	0xe506	; 0xe506 <SendSlaveCommand>
		tConnect=0,iCon=0,iTry=0;
	    lcd_clear();
    ee1e:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
	    lcd_printf(1,1,PSTR("Scan Pump"));
    ee22:	81 e0       	ldi	r24, 0x01	; 1
    ee24:	61 e0       	ldi	r22, 0x01	; 1
    ee26:	4c e5       	ldi	r20, 0x5C	; 92
    ee28:	5c e1       	ldi	r21, 0x1C	; 28
    ee2a:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    ee2e:	e1 99       	sbic	0x1c, 1	; 28
    ee30:	fe cf       	rjmp	.-4      	; 0xee2e <InitializeConnection+0x132>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    ee32:	df ba       	out	0x1f, r13	; 31
    ee34:	ce ba       	out	0x1e, r12	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    ee36:	e0 9a       	sbi	0x1c, 0	; 28
    ee38:	8d b3       	in	r24, 0x1d	; 29
		strcpy_P(lcdteks,(PGM_P)pgm_read_word(&(DefListDispenserName[eeprom_read_byte(&DefDispenserBrand)])));
    ee3a:	e8 2f       	mov	r30, r24
    ee3c:	f0 e0       	ldi	r31, 0x00	; 0
    ee3e:	ee 0f       	add	r30, r30
    ee40:	ff 1f       	adc	r31, r31
    ee42:	e5 5d       	subi	r30, 0xD5	; 213
    ee44:	fc 4f       	sbci	r31, 0xFC	; 252
    ee46:	65 91       	lpm	r22, Z+
    ee48:	74 91       	lpm	r23, Z+
    ee4a:	8e 01       	movw	r16, r28
    ee4c:	0f 5f       	subi	r16, 0xFF	; 255
    ee4e:	1f 4f       	sbci	r17, 0xFF	; 255
    ee50:	c8 01       	movw	r24, r16
    ee52:	0e 94 08 b4 	call	0x16810	; 0x16810 <strcpy_P>
		sprintf_P(lcdteks,PSTR("%s"),lcdteks);
    ee56:	00 d0       	rcall	.+0      	; 0xee58 <InitializeConnection+0x15c>
    ee58:	00 d0       	rcall	.+0      	; 0xee5a <InitializeConnection+0x15e>
    ee5a:	00 d0       	rcall	.+0      	; 0xee5c <InitializeConnection+0x160>
    ee5c:	ed b7       	in	r30, 0x3d	; 61
    ee5e:	fe b7       	in	r31, 0x3e	; 62
    ee60:	31 96       	adiw	r30, 0x01	; 1
    ee62:	ad b7       	in	r26, 0x3d	; 61
    ee64:	be b7       	in	r27, 0x3e	; 62
    ee66:	12 96       	adiw	r26, 0x02	; 2
    ee68:	1c 93       	st	X, r17
    ee6a:	0e 93       	st	-X, r16
    ee6c:	11 97       	sbiw	r26, 0x01	; 1
    ee6e:	89 e5       	ldi	r24, 0x59	; 89
    ee70:	9c e1       	ldi	r25, 0x1C	; 28
    ee72:	93 83       	std	Z+3, r25	; 0x03
    ee74:	82 83       	std	Z+2, r24	; 0x02
    ee76:	15 83       	std	Z+5, r17	; 0x05
    ee78:	04 83       	std	Z+4, r16	; 0x04
    ee7a:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
	    lcd_print(2,1,lcdteks);
    ee7e:	8d b7       	in	r24, 0x3d	; 61
    ee80:	9e b7       	in	r25, 0x3e	; 62
    ee82:	06 96       	adiw	r24, 0x06	; 6
    ee84:	0f b6       	in	r0, 0x3f	; 63
    ee86:	f8 94       	cli
    ee88:	9e bf       	out	0x3e, r25	; 62
    ee8a:	0f be       	out	0x3f, r0	; 63
    ee8c:	8d bf       	out	0x3d, r24	; 61
    ee8e:	82 e0       	ldi	r24, 0x02	; 2
    ee90:	61 e0       	ldi	r22, 0x01	; 1
    ee92:	a8 01       	movw	r20, r16
    ee94:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
    ee98:	00 e0       	ldi	r16, 0x00	; 0
    ee9a:	10 e0       	ldi	r17, 0x00	; 0
    ee9c:	ff 24       	eor	r15, r15
    ee9e:	dd 24       	eor	r13, r13
    eea0:	26 c0       	rjmp	.+76     	; 0xeeee <InitializeConnection+0x1f2>

	    while (IsStandAloneDetected==False){
		       lcd_put(4,(1+iCon),'.');
    eea2:	ef 2c       	mov	r14, r15
    eea4:	e3 94       	inc	r14
    eea6:	84 e0       	ldi	r24, 0x04	; 4
    eea8:	6e 2d       	mov	r22, r14
    eeaa:	4e e2       	ldi	r20, 0x2E	; 46
    eeac:	0e 94 7f ad 	call	0x15afe	; 0x15afe <lcd_put>
		       tConnect++;
    eeb0:	0f 5f       	subi	r16, 0xFF	; 255
    eeb2:	1f 4f       	sbci	r17, 0xFF	; 255
		       if ((tConnect%100)==0)iCon++;
    eeb4:	c8 01       	movw	r24, r16
    eeb6:	64 e6       	ldi	r22, 0x64	; 100
    eeb8:	70 e0       	ldi	r23, 0x00	; 0
    eeba:	0e 94 38 b7 	call	0x16e70	; 0x16e70 <__udivmodhi4>
    eebe:	89 2b       	or	r24, r25
    eec0:	09 f4       	brne	.+2      	; 0xeec4 <InitializeConnection+0x1c8>
    eec2:	fe 2c       	mov	r15, r14
		       if (iCon>16){
    eec4:	90 e1       	ldi	r25, 0x10	; 16
    eec6:	9f 15       	cp	r25, r15
    eec8:	78 f4       	brcc	.+30     	; 0xeee8 <InitializeConnection+0x1ec>
			       lcd_printf(4,1,PSTR("                   "));
    eeca:	84 e0       	ldi	r24, 0x04	; 4
    eecc:	61 e0       	ldi	r22, 0x01	; 1
    eece:	45 e4       	ldi	r20, 0x45	; 69
    eed0:	5c e1       	ldi	r21, 0x1C	; 28
    eed2:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
				   //IsStandaloneAcknoledge=False;
		           SendSlaveCommand(SC_STANDALONE,DispenserBrand);
    eed6:	82 e0       	ldi	r24, 0x02	; 2
    eed8:	60 91 61 01 	lds	r22, 0x0161
    eedc:	0e 94 83 72 	call	0xe506	; 0xe506 <SendSlaveCommand>
                   //InitStandalone();

			       DisplayPumpStatus();
    eee0:	0e 94 6e 41 	call	0x82dc	; 0x82dc <DisplayPumpStatus>
			       iCon=0;
			       iTry++;}
    eee4:	d3 94       	inc	r13
    eee6:	ff 24       	eor	r15, r15
		           if (iTry>3) break; 
    eee8:	a3 e0       	ldi	r26, 0x03	; 3
    eeea:	ad 15       	cp	r26, r13
    eeec:	20 f0       	brcs	.+8      	; 0xeef6 <InitializeConnection+0x1fa>
	    lcd_printf(1,1,PSTR("Scan Pump"));
		strcpy_P(lcdteks,(PGM_P)pgm_read_word(&(DefListDispenserName[eeprom_read_byte(&DefDispenserBrand)])));
		sprintf_P(lcdteks,PSTR("%s"),lcdteks);
	    lcd_print(2,1,lcdteks);

	    while (IsStandAloneDetected==False){
    eeee:	80 91 b3 01 	lds	r24, 0x01B3
    eef2:	88 23       	and	r24, r24
    eef4:	b1 f2       	breq	.-84     	; 0xeea2 <InitializeConnection+0x1a6>
			       iCon=0;
			       iTry++;}
		           if (iTry>3) break; 
	    }
	}//EndIf
	if(IsMessage11==True){
    eef6:	80 91 b7 01 	lds	r24, 0x01B7
    eefa:	81 30       	cpi	r24, 0x01	; 1
    eefc:	b9 f4       	brne	.+46     	; 0xef2c <InitializeConnection+0x230>
	   lcd_printf(4,1,PSTR("Connected"));
    eefe:	84 e0       	ldi	r24, 0x04	; 4
    ef00:	61 e0       	ldi	r22, 0x01	; 1
    ef02:	4b e3       	ldi	r20, 0x3B	; 59
    ef04:	5c e1       	ldi	r21, 0x1C	; 28
    ef06:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    ef0a:	e1 99       	sbic	0x1c, 1	; 28
    ef0c:	fe cf       	rjmp	.-4      	; 0xef0a <InitializeConnection+0x20e>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    ef0e:	bf ba       	out	0x1f, r11	; 31
    ef10:	ae ba       	out	0x1e, r10	; 30
#endif
    EEDR = __value;
    ef12:	11 e0       	ldi	r17, 0x01	; 1
    ef14:	1d bb       	out	0x1d, r17	; 29

    __asm__ __volatile__ (
    ef16:	0f b6       	in	r0, 0x3f	; 63
    ef18:	f8 94       	cli
    ef1a:	e2 9a       	sbi	0x1c, 2	; 28
    ef1c:	e1 9a       	sbi	0x1c, 1	; 28
    ef1e:	0f be       	out	0x3f, r0	; 63
	   eeprom_write_byte(&DefInitIFT,IT_SLAVE);
	   IFType=IT_SLAVE;
    ef20:	10 93 10 01 	sts	0x0110, r17
	   //IsErrorTCPIP=False;
	   procMessage11();
    ef24:	0e 94 0a 5d 	call	0xba14	; 0xba14 <procMessage11>
	   IsAdvanzStartupInfo=True;
    ef28:	10 93 c1 01 	sts	0x01C1, r17
	}
	if(IsStandAloneDetected==True){
    ef2c:	80 91 b3 01 	lds	r24, 0x01B3
    ef30:	81 30       	cpi	r24, 0x01	; 1
    ef32:	99 f4       	brne	.+38     	; 0xef5a <InitializeConnection+0x25e>
	   lcd_printf(4,1,PSTR("PumpFound"));
    ef34:	84 e0       	ldi	r24, 0x04	; 4
    ef36:	61 e0       	ldi	r22, 0x01	; 1
    ef38:	41 e3       	ldi	r20, 0x31	; 49
    ef3a:	5c e1       	ldi	r21, 0x1C	; 28
    ef3c:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    ef40:	e1 99       	sbic	0x1c, 1	; 28
    ef42:	fe cf       	rjmp	.-4      	; 0xef40 <InitializeConnection+0x244>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    ef44:	bf ba       	out	0x1f, r11	; 31
    ef46:	ae ba       	out	0x1e, r10	; 30
#endif
    EEDR = __value;
    ef48:	82 e0       	ldi	r24, 0x02	; 2
    ef4a:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    ef4c:	0f b6       	in	r0, 0x3f	; 63
    ef4e:	f8 94       	cli
    ef50:	e2 9a       	sbi	0x1c, 2	; 28
    ef52:	e1 9a       	sbi	0x1c, 1	; 28
    ef54:	0f be       	out	0x3f, r0	; 63
	   eeprom_write_byte(&DefInitIFT,IT_STANDALONE);
	   IFType=IT_STANDALONE;
    ef56:	80 93 10 01 	sts	0x0110, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    ef5a:	e1 99       	sbic	0x1c, 1	; 28
    ef5c:	fe cf       	rjmp	.-4      	; 0xef5a <InitializeConnection+0x25e>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    ef5e:	85 e3       	ldi	r24, 0x35	; 53
    ef60:	91 e0       	ldi	r25, 0x01	; 1
    ef62:	9f bb       	out	0x1f, r25	; 31
    ef64:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    ef66:	e0 9a       	sbi	0x1c, 0	; 28
    ef68:	8d b3       	in	r24, 0x1d	; 29
	}
	//PrintStatus
	if (eeprom_read_byte(&DefPrintInitialize)==True)GeneratePrintInit();
    ef6a:	81 30       	cpi	r24, 0x01	; 1
    ef6c:	11 f4       	brne	.+4      	; 0xef72 <InitializeConnection+0x276>
    ef6e:	0e 94 d2 2f 	call	0x5fa4	; 0x5fa4 <GeneratePrintInit>
	if ((IsStandAloneDetected==False)&&(IsMessage11==False)){		
    ef72:	80 91 b3 01 	lds	r24, 0x01B3
    ef76:	88 23       	and	r24, r24
    ef78:	09 f0       	breq	.+2      	; 0xef7c <InitializeConnection+0x280>
    ef7a:	38 c0       	rjmp	.+112    	; 0xefec <InitializeConnection+0x2f0>
    ef7c:	80 91 b7 01 	lds	r24, 0x01B7
    ef80:	88 23       	and	r24, r24
    ef82:	09 f0       	breq	.+2      	; 0xef86 <InitializeConnection+0x28a>
    ef84:	33 c0       	rjmp	.+102    	; 0xefec <InitializeConnection+0x2f0>
		 lcd_printf(2,1,PSTR("TCP/IP Error"));
    ef86:	82 e0       	ldi	r24, 0x02	; 2
    ef88:	61 e0       	ldi	r22, 0x01	; 1
    ef8a:	44 e2       	ldi	r20, 0x24	; 36
    ef8c:	5c e1       	ldi	r21, 0x1C	; 28
    ef8e:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		 lcd_printf(3,1,PSTR("No Pump Found"));
    ef92:	83 e0       	ldi	r24, 0x03	; 3
    ef94:	61 e0       	ldi	r22, 0x01	; 1
    ef96:	46 e1       	ldi	r20, 0x16	; 22
    ef98:	5c e1       	ldi	r21, 0x1C	; 28
    ef9a:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
    ef9e:	80 e2       	ldi	r24, 0x20	; 32
    efa0:	9e e4       	ldi	r25, 0x4E	; 78
    efa2:	29 e1       	ldi	r18, 0x19	; 25
    efa4:	30 e0       	ldi	r19, 0x00	; 0
    efa6:	f9 01       	movw	r30, r18
    efa8:	31 97       	sbiw	r30, 0x01	; 1
    efaa:	f1 f7       	brne	.-4      	; 0xefa8 <InitializeConnection+0x2ac>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    efac:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    efae:	d9 f7       	brne	.-10     	; 0xefa6 <InitializeConnection+0x2aa>
		 _delay_ms(2000);
		 ForceType=systemForceType();
    efb0:	0e 94 9d 44 	call	0x893a	; 0x893a <systemForceType>
		 if (ForceType=='1'){
    efb4:	81 33       	cpi	r24, 0x31	; 49
    efb6:	29 f4       	brne	.+10     	; 0xefc2 <InitializeConnection+0x2c6>
		     IFType=IT_SLAVE;
    efb8:	81 e0       	ldi	r24, 0x01	; 1
    efba:	80 93 10 01 	sts	0x0110, r24
			 SendSlaveCommand(SC_SLAVE,ST_NONE);
    efbe:	60 e0       	ldi	r22, 0x00	; 0
    efc0:	07 c0       	rjmp	.+14     	; 0xefd0 <InitializeConnection+0x2d4>
         }
		 else
		 if (ForceType=='2'){
    efc2:	82 33       	cpi	r24, 0x32	; 50
    efc4:	39 f4       	brne	.+14     	; 0xefd4 <InitializeConnection+0x2d8>
		     IFType=IT_STANDALONE;
    efc6:	82 e0       	ldi	r24, 0x02	; 2
    efc8:	80 93 10 01 	sts	0x0110, r24
			 SendSlaveCommand(SC_STANDALONE,DispenserBrand);
    efcc:	60 91 61 01 	lds	r22, 0x0161
    efd0:	0e 94 83 72 	call	0xe506	; 0xe506 <SendSlaveCommand>

			 //SendPoolingCommand(SC_SET_POOLING_MAX_PUMP,eeprom_read_byte(&DefPoolingPumpMax));

			 //InitStandalone();
         }
		 eeprom_write_byte(&DefInitIFT,IFType);
    efd4:	80 91 10 01 	lds	r24, 0x0110
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    efd8:	e1 99       	sbic	0x1c, 1	; 28
    efda:	fe cf       	rjmp	.-4      	; 0xefd8 <InitializeConnection+0x2dc>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    efdc:	bf ba       	out	0x1f, r11	; 31
    efde:	ae ba       	out	0x1e, r10	; 30
#endif
    EEDR = __value;
    efe0:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    efe2:	0f b6       	in	r0, 0x3f	; 63
    efe4:	f8 94       	cli
    efe6:	e2 9a       	sbi	0x1c, 2	; 28
    efe8:	e1 9a       	sbi	0x1c, 1	; 28
    efea:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    efec:	e1 99       	sbic	0x1c, 1	; 28
    efee:	fe cf       	rjmp	.-4      	; 0xefec <InitializeConnection+0x2f0>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    eff0:	84 e4       	ldi	r24, 0x44	; 68
    eff2:	91 e0       	ldi	r25, 0x01	; 1
    eff4:	9f bb       	out	0x1f, r25	; 31
    eff6:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    eff8:	e0 9a       	sbi	0x1c, 0	; 28
    effa:	8d b3       	in	r24, 0x1d	; 29

	 }
}

void InitMemory(){
     PumpCountMax=eeprom_read_byte(&DefPoolingPumpMax);
    effc:	80 93 5f 01 	sts	0x015F, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    f000:	e1 99       	sbic	0x1c, 1	; 28
    f002:	fe cf       	rjmp	.-4      	; 0xf000 <InitializeConnection+0x304>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    f004:	89 e4       	ldi	r24, 0x49	; 73
    f006:	91 e0       	ldi	r25, 0x01	; 1
    f008:	9f bb       	out	0x1f, r25	; 31
    f00a:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    f00c:	e0 9a       	sbi	0x1c, 0	; 28
    f00e:	8d b3       	in	r24, 0x1d	; 29
	 ActivePump=eeprom_read_byte(&DefActivePump);
    f010:	80 93 60 01 	sts	0x0160, r24
         }
		 eeprom_write_byte(&DefInitIFT,IFType);
	}
	InitMemory();
	//SendSlaveCommand(SC_START_POOL_SEQUENCE,0);
}
    f014:	64 96       	adiw	r28, 0x14	; 20
    f016:	0f b6       	in	r0, 0x3f	; 63
    f018:	f8 94       	cli
    f01a:	de bf       	out	0x3e, r29	; 62
    f01c:	0f be       	out	0x3f, r0	; 63
    f01e:	cd bf       	out	0x3d, r28	; 61
    f020:	cf 91       	pop	r28
    f022:	df 91       	pop	r29
    f024:	1f 91       	pop	r17
    f026:	0f 91       	pop	r16
    f028:	ff 90       	pop	r15
    f02a:	ef 90       	pop	r14
    f02c:	df 90       	pop	r13
    f02e:	cf 90       	pop	r12
    f030:	bf 90       	pop	r11
    f032:	af 90       	pop	r10
    f034:	08 95       	ret

0000f036 <StoreStandaloneTransData>:
     SendSlaveCommand(SC_TOTALIZER_ACK,iPumpID);
	 UpdateStandaloneStatus((iPumpID&0x0F),PS_TOTALIZER);	 
}
         
			                                         //      STX     MSGID  PumpID              6        8        8
void StoreStandaloneTransData(char *strRawTransData){//  [0x50,0x05]  01      01      1       004500   00000200  00000012 [0x06,0x60] = 24
    f036:	2f 92       	push	r2
    f038:	3f 92       	push	r3
    f03a:	4f 92       	push	r4
    f03c:	5f 92       	push	r5
    f03e:	6f 92       	push	r6
    f040:	7f 92       	push	r7
    f042:	8f 92       	push	r8
    f044:	9f 92       	push	r9
    f046:	af 92       	push	r10
    f048:	bf 92       	push	r11
    f04a:	cf 92       	push	r12
    f04c:	df 92       	push	r13
    f04e:	ef 92       	push	r14
    f050:	ff 92       	push	r15
    f052:	0f 93       	push	r16
    f054:	1f 93       	push	r17
    f056:	df 93       	push	r29
    f058:	cf 93       	push	r28
    f05a:	cd b7       	in	r28, 0x3d	; 61
    f05c:	de b7       	in	r29, 0x3e	; 62
    f05e:	e1 97       	sbiw	r28, 0x31	; 49
    f060:	0f b6       	in	r0, 0x3f	; 63
    f062:	f8 94       	cli
    f064:	de bf       	out	0x3e, r29	; 62
    f066:	0f be       	out	0x3f, r0	; 63
    f068:	cd bf       	out	0x3d, r28	; 61
    f06a:	7c 01       	movw	r14, r24
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    f06c:	dc 01       	movw	r26, r24
    f06e:	12 96       	adiw	r26, 0x02	; 2
    f070:	8c 91       	ld	r24, X
    f072:	12 97       	sbiw	r26, 0x02	; 2
    f074:	89 83       	std	Y+1, r24	; 0x01
    f076:	13 96       	adiw	r26, 0x03	; 3
    f078:	8c 91       	ld	r24, X
    f07a:	8a 83       	std	Y+2, r24	; 0x02
	 }Dest[Length]=0;
    f07c:	1b 82       	std	Y+3, r1	; 0x03
	 char strSend[30];
	 char TransDigit;
	 char FIPAddr;
      
	 StrPosCopy(strRawTransData,strPumpID,2,2);
	 RemZeroLead(strPumpID);
    f07e:	8e 01       	movw	r16, r28
    f080:	0f 5f       	subi	r16, 0xFF	; 255
    f082:	1f 4f       	sbci	r17, 0xFF	; 255
    f084:	c8 01       	movw	r24, r16
    f086:	0e 94 dd 23 	call	0x47ba	; 0x47ba <RemZeroLead>
	 iPumpID=atoi(strPumpID); 
    f08a:	c8 01       	movw	r24, r16
    f08c:	0e 94 ea b3 	call	0x167d4	; 0x167d4 <atoi>
    f090:	38 2e       	mov	r3, r24
	 
	 FIPAddr=GetFIPAddr(iPumpID);
    f092:	0e 94 39 1c 	call	0x3872	; 0x3872 <GetFIPAddr>
    f096:	d8 2e       	mov	r13, r24
	 if (FIPAddr>0){
    f098:	88 23       	and	r24, r24
    f09a:	09 f4       	brne	.+2      	; 0xf09e <StoreStandaloneTransData+0x68>
    f09c:	1a c2       	rjmp	.+1076   	; 0xf4d2 <StoreStandaloneTransData+0x49c>
	    Dest[IdxSource+i]=Source[i];
	 }Dest[IdxSource+Length]=0;
}
char CharPosCopy(char *Source, unsigned int IdxSource){
     char Result;
     Result=Source[IdxSource];
    f09e:	f7 01       	movw	r30, r14
    f0a0:	f4 81       	ldd	r31, Z+4	; 0x04
    f0a2:	f9 ab       	std	Y+49, r31	; 0x31

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    f0a4:	d7 01       	movw	r26, r14
    f0a6:	15 96       	adiw	r26, 0x05	; 5
    f0a8:	2c 90       	ld	r2, X
    f0aa:	e4 e0       	ldi	r30, 0x04	; 4
    f0ac:	8e 2e       	mov	r8, r30
    f0ae:	91 2c       	mov	r9, r1
    f0b0:	8c 0e       	add	r8, r28
    f0b2:	9d 1e       	adc	r9, r29
    f0b4:	f4 01       	movw	r30, r8
    f0b6:	ce 01       	movw	r24, r28
    f0b8:	0b 96       	adiw	r24, 0x0b	; 11
	     strMemory[i]=data;
    f0ba:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    f0bc:	e8 17       	cp	r30, r24
    f0be:	f9 07       	cpc	r31, r25
    f0c0:	e1 f7       	brne	.-8      	; 0xf0ba <StoreStandaloneTransData+0x84>
    f0c2:	7d e1       	ldi	r23, 0x1D	; 29
    f0c4:	67 2e       	mov	r6, r23
    f0c6:	71 2c       	mov	r7, r1
    f0c8:	6c 0e       	add	r6, r28
    f0ca:	7d 1e       	adc	r7, r29
    f0cc:	93 01       	movw	r18, r6
	     strMemory[i]=data;
    f0ce:	ce 01       	movw	r24, r28
    f0d0:	87 96       	adiw	r24, 0x27	; 39
    f0d2:	f9 01       	movw	r30, r18
    f0d4:	11 92       	st	Z+, r1
    f0d6:	9f 01       	movw	r18, r30

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    f0d8:	e8 17       	cp	r30, r24
    f0da:	f9 07       	cpc	r31, r25
    f0dc:	d1 f7       	brne	.-12     	; 0xf0d2 <StoreStandaloneTransData+0x9c>
    f0de:	2f 01       	movw	r4, r30
	     strMemory[i]=data;
    f0e0:	ce 01       	movw	r24, r28
    f0e2:	c1 96       	adiw	r24, 0x31	; 49
    f0e4:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
    f0e6:	e8 17       	cp	r30, r24
    f0e8:	f9 07       	cpc	r31, r25
    f0ea:	e1 f7       	brne	.-8      	; 0xf0e4 <StoreStandaloneTransData+0xae>
    f0ec:	a7 01       	movw	r20, r14
    f0ee:	d7 01       	movw	r26, r14
    f0f0:	f4 01       	movw	r30, r8
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f0f2:	be 01       	movw	r22, r28
    f0f4:	66 5f       	subi	r22, 0xF6	; 246
    f0f6:	7f 4f       	sbci	r23, 0xFF	; 255
	    Dest[i]=Source[IdxSource+i];
    f0f8:	16 96       	adiw	r26, 0x06	; 6
    f0fa:	8c 91       	ld	r24, X
    f0fc:	16 97       	sbiw	r26, 0x06	; 6
    f0fe:	81 93       	st	Z+, r24
    f100:	11 96       	adiw	r26, 0x01	; 1
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f102:	e6 17       	cp	r30, r22
    f104:	f7 07       	cpc	r31, r23
    f106:	c1 f7       	brne	.-16     	; 0xf0f8 <StoreStandaloneTransData+0xc2>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f108:	1a 86       	std	Y+10, r1	; 0x0a
    f10a:	d7 01       	movw	r26, r14
    f10c:	f3 01       	movw	r30, r6
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f10e:	be 01       	movw	r22, r28
    f110:	6b 5d       	subi	r22, 0xDB	; 219
    f112:	7f 4f       	sbci	r23, 0xFF	; 255
	    Dest[i]=Source[IdxSource+i];
    f114:	1c 96       	adiw	r26, 0x0c	; 12
    f116:	8c 91       	ld	r24, X
    f118:	1c 97       	sbiw	r26, 0x0c	; 12
    f11a:	81 93       	st	Z+, r24
    f11c:	11 96       	adiw	r26, 0x01	; 1
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f11e:	e6 17       	cp	r30, r22
    f120:	f7 07       	cpc	r31, r23
    f122:	c1 f7       	brne	.-16     	; 0xf114 <StoreStandaloneTransData+0xde>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f124:	1d a2       	std	Y+37, r1	; 0x25
    f126:	f9 01       	movw	r30, r18
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f128:	be 01       	movw	r22, r28
    f12a:	69 5d       	subi	r22, 0xD9	; 217
    f12c:	7f 4f       	sbci	r23, 0xFF	; 255
    f12e:	9e 01       	movw	r18, r28
    f130:	21 5d       	subi	r18, 0xD1	; 209
    f132:	3f 4f       	sbci	r19, 0xFF	; 255
	    Dest[i]=Source[IdxSource+i];
    f134:	da 01       	movw	r26, r20
    f136:	54 96       	adiw	r26, 0x14	; 20
    f138:	8c 91       	ld	r24, X
    f13a:	81 93       	st	Z+, r24
    f13c:	4f 5f       	subi	r20, 0xFF	; 255
    f13e:	5f 4f       	sbci	r21, 0xFF	; 255
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f140:	e2 17       	cp	r30, r18
    f142:	f3 07       	cpc	r31, r19
    f144:	b9 f7       	brne	.-18     	; 0xf134 <StoreStandaloneTransData+0xfe>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f146:	1f a6       	std	Y+47, r1	; 0x2f
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
    f148:	f7 01       	movw	r30, r14
    f14a:	84 8d       	ldd	r24, Z+28	; 0x1c
    f14c:	80 53       	subi	r24, 0x30	; 48
    f14e:	8a 30       	cpi	r24, 0x0A	; 10
    f150:	98 f4       	brcc	.+38     	; 0xf178 <StoreStandaloneTransData+0x142>

		 TransDigit=Ord(CharPosCopy(strRawTransData,28));
		 //Normalize7Digit
		 //sprintf_P(strSend,PSTR("Digit: %d"),TransDigit);
		 //_uart_print(1,1,strSend);
		 if  (TransDigit==8){
    f152:	88 30       	cpi	r24, 0x08	; 8
    f154:	89 f4       	brne	.+34     	; 0xf178 <StoreStandaloneTransData+0x142>
			  StrPosCopy(strPMoney,strPMoney,0,strlen(strPMoney)-1);	 
    f156:	fb 01       	movw	r30, r22
    f158:	01 90       	ld	r0, Z+
    f15a:	00 20       	and	r0, r0
    f15c:	e9 f7       	brne	.-6      	; 0xf158 <StoreStandaloneTransData+0x122>
    f15e:	e6 1b       	sub	r30, r22
    f160:	f7 0b       	sbc	r31, r23
    f162:	32 97       	sbiw	r30, 0x02	; 2
    f164:	80 e0       	ldi	r24, 0x00	; 0
    f166:	90 e0       	ldi	r25, 0x00	; 0
    f168:	01 c0       	rjmp	.+2      	; 0xf16c <StoreStandaloneTransData+0x136>
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f16a:	01 96       	adiw	r24, 0x01	; 1
    f16c:	8e 17       	cp	r24, r30
    f16e:	9f 07       	cpc	r25, r31
    f170:	e0 f3       	brcs	.-8      	; 0xf16a <StoreStandaloneTransData+0x134>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f172:	ec 0f       	add	r30, r28
    f174:	fd 1f       	adc	r31, r29
    f176:	17 a2       	std	Z+39, r1	; 0x27
		 //sprintf_P(strSend,PSTR("Digit: %d"),TransDigit);
		 //_uart_print(1,1,strSend);
		 if  (TransDigit==8){
			  StrPosCopy(strPMoney,strPMoney,0,strlen(strPMoney)-1);	 
		 }
		 RemZeroLead(strPPU);
    f178:	64 e0       	ldi	r22, 0x04	; 4
    f17a:	e6 2e       	mov	r14, r22
    f17c:	f1 2c       	mov	r15, r1
    f17e:	ec 0e       	add	r14, r28
    f180:	fd 1e       	adc	r15, r29
    f182:	c7 01       	movw	r24, r14
    f184:	0e 94 dd 23 	call	0x47ba	; 0x47ba <RemZeroLead>
		 RemZeroLead(strPVolume);
    f188:	5d e1       	ldi	r21, 0x1D	; 29
    f18a:	a5 2e       	mov	r10, r21
    f18c:	b1 2c       	mov	r11, r1
    f18e:	ac 0e       	add	r10, r28
    f190:	bd 1e       	adc	r11, r29
    f192:	c5 01       	movw	r24, r10
    f194:	0e 94 dd 23 	call	0x47ba	; 0x47ba <RemZeroLead>
		 RemZeroLead(strPMoney);
    f198:	8e 01       	movw	r16, r28
    f19a:	09 5d       	subi	r16, 0xD9	; 217
    f19c:	1f 4f       	sbci	r17, 0xFF	; 255
    f19e:	c8 01       	movw	r24, r16
    f1a0:	0e 94 dd 23 	call	0x47ba	; 0x47ba <RemZeroLead>
		 //sprintf_P(strSend,PSTR("Money: %s"),strPMoney);
		 //_uart_print(1,1,strSend);


		 //Void Detection
		 if (atoi(strPMoney)==0)TransactionStatus=TS_VOID;
    f1a4:	c8 01       	movw	r24, r16
    f1a6:	0e 94 ea b3 	call	0x167d4	; 0x167d4 <atoi>
    f1aa:	89 2b       	or	r24, r25
    f1ac:	09 f0       	breq	.+2      	; 0xf1b0 <StoreStandaloneTransData+0x17a>
    f1ae:	46 c1       	rjmp	.+652    	; 0xf43c <StoreStandaloneTransData+0x406>
		 else TransactionStatus=TS_NEW;
		 
		 if (TransactionStatus==TS_VOID){//RejectData
			 UpdateStandaloneStatus((iPumpID&0x0F),PS_VOID);
    f1b0:	83 2d       	mov	r24, r3
    f1b2:	8f 70       	andi	r24, 0x0F	; 15
    f1b4:	63 e1       	ldi	r22, 0x13	; 19
    f1b6:	0e 94 70 1c 	call	0x38e0	; 0x38e0 <UpdateStandaloneStatus>
    f1ba:	8b c1       	rjmp	.+790    	; 0xf4d2 <StoreStandaloneTransData+0x49c>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    f1bc:	e1 99       	sbic	0x1c, 1	; 28
    f1be:	fe cf       	rjmp	.-4      	; 0xf1bc <StoreStandaloneTransData+0x186>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    f1c0:	8f e3       	ldi	r24, 0x3F	; 63
    f1c2:	91 e0       	ldi	r25, 0x01	; 1
    f1c4:	9f bb       	out	0x1f, r25	; 31
    f1c6:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    f1c8:	e0 9a       	sbi	0x1c, 0	; 28
    f1ca:	2d b3       	in	r18, 0x1d	; 29
			 //_uart_print(1,1,strPVolume);
			 
			 GenerateTransactionNum(strTranNo);		 
			 sprintf_P(strTransDate,PSTR("%s"),strSystemDate);
			 sprintf_P(strTransTime,PSTR("%s"),strSystemTime);
			 sprintf_P(strShift,PSTR("%d"),eeprom_read_byte(&DefShift));
    f1cc:	00 d0       	rcall	.+0      	; 0xf1ce <StoreStandaloneTransData+0x198>
    f1ce:	00 d0       	rcall	.+0      	; 0xf1d0 <StoreStandaloneTransData+0x19a>
    f1d0:	00 d0       	rcall	.+0      	; 0xf1d2 <StoreStandaloneTransData+0x19c>
    f1d2:	ed b7       	in	r30, 0x3d	; 61
    f1d4:	fe b7       	in	r31, 0x3e	; 62
    f1d6:	31 96       	adiw	r30, 0x01	; 1
    f1d8:	83 e4       	ldi	r24, 0x43	; 67
    f1da:	9e e0       	ldi	r25, 0x0E	; 14
    f1dc:	ad b7       	in	r26, 0x3d	; 61
    f1de:	be b7       	in	r27, 0x3e	; 62
    f1e0:	12 96       	adiw	r26, 0x02	; 2
    f1e2:	9c 93       	st	X, r25
    f1e4:	8e 93       	st	-X, r24
    f1e6:	11 97       	sbiw	r26, 0x01	; 1
    f1e8:	8b eb       	ldi	r24, 0xBB	; 187
    f1ea:	92 e2       	ldi	r25, 0x22	; 34
    f1ec:	93 83       	std	Z+3, r25	; 0x03
    f1ee:	82 83       	std	Z+2, r24	; 0x02
    f1f0:	24 83       	std	Z+4, r18	; 0x04
    f1f2:	15 82       	std	Z+5, r1	; 0x05
    f1f4:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
					 
			 //TransNum,Date,Time
			 StrPosCopy(strTranNo,RecPumpData[FIPAddr].strTransNum,0,strlen(strTranNo));
    f1f8:	e1 e6       	ldi	r30, 0x61	; 97
    f1fa:	fe e0       	ldi	r31, 0x0E	; 14
    f1fc:	df 01       	movw	r26, r30
    f1fe:	0d 90       	ld	r0, X+
    f200:	00 20       	and	r0, r0
    f202:	e9 f7       	brne	.-6      	; 0xf1fe <StoreStandaloneTransData+0x1c8>
    f204:	9d 01       	movw	r18, r26
    f206:	21 50       	subi	r18, 0x01	; 1
    f208:	30 40       	sbci	r19, 0x00	; 0
    f20a:	2e 1b       	sub	r18, r30
    f20c:	3f 0b       	sbc	r19, r31
    f20e:	85 e3       	ldi	r24, 0x35	; 53
    f210:	90 e0       	ldi	r25, 0x00	; 0
    f212:	c8 9e       	mul	r12, r24
    f214:	d0 01       	movw	r26, r0
    f216:	c9 9e       	mul	r12, r25
    f218:	b0 0d       	add	r27, r0
    f21a:	d8 9e       	mul	r13, r24
    f21c:	b0 0d       	add	r27, r0
    f21e:	11 24       	eor	r1, r1
    f220:	a2 57       	subi	r26, 0x72	; 114
    f222:	b8 4f       	sbci	r27, 0xF8	; 248
    f224:	4d b7       	in	r20, 0x3d	; 61
    f226:	5e b7       	in	r21, 0x3e	; 62
    f228:	4a 5f       	subi	r20, 0xFA	; 250
    f22a:	5f 4f       	sbci	r21, 0xFF	; 255
    f22c:	0f b6       	in	r0, 0x3f	; 63
    f22e:	f8 94       	cli
    f230:	5e bf       	out	0x3e, r21	; 62
    f232:	0f be       	out	0x3f, r0	; 63
    f234:	4d bf       	out	0x3d, r20	; 61
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f236:	a9 01       	movw	r20, r18
    f238:	4e 0f       	add	r20, r30
    f23a:	5f 1f       	adc	r21, r31
    f23c:	02 c0       	rjmp	.+4      	; 0xf242 <StoreStandaloneTransData+0x20c>
	    Dest[i]=Source[IdxSource+i];
    f23e:	81 91       	ld	r24, Z+
    f240:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f242:	e4 17       	cp	r30, r20
    f244:	f5 07       	cpc	r31, r21
    f246:	d9 f7       	brne	.-10     	; 0xf23e <StoreStandaloneTransData+0x208>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f248:	85 e3       	ldi	r24, 0x35	; 53
    f24a:	90 e0       	ldi	r25, 0x00	; 0
    f24c:	dc 01       	movw	r26, r24
    f24e:	ca 9e       	mul	r12, r26
    f250:	c0 01       	movw	r24, r0
    f252:	cb 9e       	mul	r12, r27
    f254:	90 0d       	add	r25, r0
    f256:	da 9e       	mul	r13, r26
    f258:	90 0d       	add	r25, r0
    f25a:	11 24       	eor	r1, r1
    f25c:	fc 01       	movw	r30, r24
    f25e:	e5 57       	subi	r30, 0x75	; 117
    f260:	f8 4f       	sbci	r31, 0xF8	; 248
    f262:	e2 0f       	add	r30, r18
    f264:	f3 1f       	adc	r31, r19
    f266:	13 82       	std	Z+3, r1	; 0x03
			 sprintf_P(strTransTime,PSTR("%s"),strSystemTime);
			 sprintf_P(strShift,PSTR("%d"),eeprom_read_byte(&DefShift));
					 
			 //TransNum,Date,Time
			 StrPosCopy(strTranNo,RecPumpData[FIPAddr].strTransNum,0,strlen(strTranNo));
			 StrPosCopy(strTransDate,RecPumpData[FIPAddr].strTransDate,0,strlen(strTransDate));
    f268:	fe 01       	movw	r30, r28
    f26a:	3b 96       	adiw	r30, 0x0b	; 11
    f26c:	df 01       	movw	r26, r30
    f26e:	0d 90       	ld	r0, X+
    f270:	00 20       	and	r0, r0
    f272:	e9 f7       	brne	.-6      	; 0xf26e <StoreStandaloneTransData+0x238>
    f274:	11 97       	sbiw	r26, 0x01	; 1
    f276:	ae 1b       	sub	r26, r30
    f278:	bf 0b       	sbc	r27, r31
    f27a:	bf 01       	movw	r22, r30
    f27c:	9c 01       	movw	r18, r24
    f27e:	2b 56       	subi	r18, 0x6B	; 107
    f280:	38 4f       	sbci	r19, 0xF8	; 248
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f282:	af 01       	movw	r20, r30
    f284:	4a 0f       	add	r20, r26
    f286:	5b 1f       	adc	r21, r27
    f288:	06 c0       	rjmp	.+12     	; 0xf296 <StoreStandaloneTransData+0x260>
	    Dest[i]=Source[IdxSource+i];
    f28a:	fb 01       	movw	r30, r22
    f28c:	81 91       	ld	r24, Z+
    f28e:	bf 01       	movw	r22, r30
    f290:	f9 01       	movw	r30, r18
    f292:	81 93       	st	Z+, r24
    f294:	9f 01       	movw	r18, r30
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f296:	64 17       	cp	r22, r20
    f298:	75 07       	cpc	r23, r21
    f29a:	b9 f7       	brne	.-18     	; 0xf28a <StoreStandaloneTransData+0x254>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f29c:	85 e3       	ldi	r24, 0x35	; 53
    f29e:	90 e0       	ldi	r25, 0x00	; 0
    f2a0:	9c 01       	movw	r18, r24
    f2a2:	c2 9e       	mul	r12, r18
    f2a4:	c0 01       	movw	r24, r0
    f2a6:	c3 9e       	mul	r12, r19
    f2a8:	90 0d       	add	r25, r0
    f2aa:	d2 9e       	mul	r13, r18
    f2ac:	90 0d       	add	r25, r0
    f2ae:	11 24       	eor	r1, r1
    f2b0:	fc 01       	movw	r30, r24
    f2b2:	e5 57       	subi	r30, 0x75	; 117
    f2b4:	f8 4f       	sbci	r31, 0xF8	; 248
    f2b6:	ea 0f       	add	r30, r26
    f2b8:	fb 1f       	adc	r31, r27
    f2ba:	12 86       	std	Z+10, r1	; 0x0a
			 sprintf_P(strShift,PSTR("%d"),eeprom_read_byte(&DefShift));
					 
			 //TransNum,Date,Time
			 StrPosCopy(strTranNo,RecPumpData[FIPAddr].strTransNum,0,strlen(strTranNo));
			 StrPosCopy(strTransDate,RecPumpData[FIPAddr].strTransDate,0,strlen(strTransDate));
			 StrPosCopy(strTransTime,RecPumpData[FIPAddr].strTransTime,0,strlen(strTransTime));
    f2bc:	fe 01       	movw	r30, r28
    f2be:	74 96       	adiw	r30, 0x14	; 20
    f2c0:	df 01       	movw	r26, r30
    f2c2:	0d 90       	ld	r0, X+
    f2c4:	00 20       	and	r0, r0
    f2c6:	e9 f7       	brne	.-6      	; 0xf2c2 <StoreStandaloneTransData+0x28c>
    f2c8:	11 97       	sbiw	r26, 0x01	; 1
    f2ca:	ae 1b       	sub	r26, r30
    f2cc:	bf 0b       	sbc	r27, r31
    f2ce:	bf 01       	movw	r22, r30
    f2d0:	9c 01       	movw	r18, r24
    f2d2:	22 56       	subi	r18, 0x62	; 98
    f2d4:	38 4f       	sbci	r19, 0xF8	; 248
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f2d6:	af 01       	movw	r20, r30
    f2d8:	4a 0f       	add	r20, r26
    f2da:	5b 1f       	adc	r21, r27
    f2dc:	06 c0       	rjmp	.+12     	; 0xf2ea <StoreStandaloneTransData+0x2b4>
	    Dest[i]=Source[IdxSource+i];
    f2de:	fb 01       	movw	r30, r22
    f2e0:	81 91       	ld	r24, Z+
    f2e2:	bf 01       	movw	r22, r30
    f2e4:	f9 01       	movw	r30, r18
    f2e6:	81 93       	st	Z+, r24
    f2e8:	9f 01       	movw	r18, r30
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f2ea:	64 17       	cp	r22, r20
    f2ec:	75 07       	cpc	r23, r21
    f2ee:	b9 f7       	brne	.-18     	; 0xf2de <StoreStandaloneTransData+0x2a8>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f2f0:	85 e3       	ldi	r24, 0x35	; 53
    f2f2:	90 e0       	ldi	r25, 0x00	; 0
    f2f4:	c8 9e       	mul	r12, r24
    f2f6:	70 01       	movw	r14, r0
    f2f8:	c9 9e       	mul	r12, r25
    f2fa:	f0 0c       	add	r15, r0
    f2fc:	d8 9e       	mul	r13, r24
    f2fe:	f0 0c       	add	r15, r0
    f300:	11 24       	eor	r1, r1
    f302:	87 01       	movw	r16, r14
    f304:	05 57       	subi	r16, 0x75	; 117
    f306:	18 4f       	sbci	r17, 0xF8	; 248
    f308:	a0 0f       	add	r26, r16
    f30a:	b1 1f       	adc	r27, r17
    f30c:	53 96       	adiw	r26, 0x13	; 19
    f30e:	1c 92       	st	X, r1
			 //TransNum,Date,Time
			 StrPosCopy(strTranNo,RecPumpData[FIPAddr].strTransNum,0,strlen(strTranNo));
			 StrPosCopy(strTransDate,RecPumpData[FIPAddr].strTransDate,0,strlen(strTransDate));
			 StrPosCopy(strTransTime,RecPumpData[FIPAddr].strTransTime,0,strlen(strTransTime));
			 //Grade Nozzle Shift
			 RecPumpData[FIPAddr].Grade=PGrade;
    f310:	f0 ed       	ldi	r31, 0xD0	; 208
    f312:	2f 0e       	add	r2, r31
    f314:	d8 01       	movw	r26, r16
    f316:	2c 92       	st	X, r2
			 RecPumpData[FIPAddr].Nozzle=PNozzle;
    f318:	b9 a9       	ldd	r27, Y+49	; 0x31
    f31a:	b0 53       	subi	r27, 0x30	; 48
    f31c:	f8 01       	movw	r30, r16
    f31e:	b1 83       	std	Z+1, r27	; 0x01
			 RecPumpData[FIPAddr].Shift=atoi(strShift);
    f320:	83 e4       	ldi	r24, 0x43	; 67
    f322:	9e e0       	ldi	r25, 0x0E	; 14
    f324:	0e 94 ea b3 	call	0x167d4	; 0x167d4 <atoi>
    f328:	d8 01       	movw	r26, r16
    f32a:	12 96       	adiw	r26, 0x02	; 2
    f32c:	8c 93       	st	X, r24
			 //Price Volume Money
			 StrPosCopy(strPPU,RecPumpData[FIPAddr].Price,0,strlen(strPPU));
    f32e:	fe 01       	movw	r30, r28
    f330:	34 96       	adiw	r30, 0x04	; 4
    f332:	df 01       	movw	r26, r30
    f334:	0d 90       	ld	r0, X+
    f336:	00 20       	and	r0, r0
    f338:	e9 f7       	brne	.-6      	; 0xf334 <StoreStandaloneTransData+0x2fe>
    f33a:	11 97       	sbiw	r26, 0x01	; 1
    f33c:	ae 1b       	sub	r26, r30
    f33e:	bf 0b       	sbc	r27, r31
    f340:	97 01       	movw	r18, r14
    f342:	29 55       	subi	r18, 0x59	; 89
    f344:	38 4f       	sbci	r19, 0xF8	; 248
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f346:	af 01       	movw	r20, r30
    f348:	4a 0f       	add	r20, r26
    f34a:	5b 1f       	adc	r21, r27
    f34c:	06 c0       	rjmp	.+12     	; 0xf35a <StoreStandaloneTransData+0x324>
	    Dest[i]=Source[IdxSource+i];
    f34e:	f4 01       	movw	r30, r8
    f350:	81 91       	ld	r24, Z+
    f352:	4f 01       	movw	r8, r30
    f354:	f9 01       	movw	r30, r18
    f356:	81 93       	st	Z+, r24
    f358:	9f 01       	movw	r18, r30
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f35a:	84 16       	cp	r8, r20
    f35c:	95 06       	cpc	r9, r21
    f35e:	b9 f7       	brne	.-18     	; 0xf34e <StoreStandaloneTransData+0x318>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f360:	85 e3       	ldi	r24, 0x35	; 53
    f362:	90 e0       	ldi	r25, 0x00	; 0
    f364:	9c 01       	movw	r18, r24
    f366:	c2 9e       	mul	r12, r18
    f368:	c0 01       	movw	r24, r0
    f36a:	c3 9e       	mul	r12, r19
    f36c:	90 0d       	add	r25, r0
    f36e:	d2 9e       	mul	r13, r18
    f370:	90 0d       	add	r25, r0
    f372:	11 24       	eor	r1, r1
    f374:	fc 01       	movw	r30, r24
    f376:	e5 57       	subi	r30, 0x75	; 117
    f378:	f8 4f       	sbci	r31, 0xF8	; 248
    f37a:	ea 0f       	add	r30, r26
    f37c:	fb 1f       	adc	r31, r27
    f37e:	14 8e       	std	Z+28, r1	; 0x1c
			 RecPumpData[FIPAddr].Grade=PGrade;
			 RecPumpData[FIPAddr].Nozzle=PNozzle;
			 RecPumpData[FIPAddr].Shift=atoi(strShift);
			 //Price Volume Money
			 StrPosCopy(strPPU,RecPumpData[FIPAddr].Price,0,strlen(strPPU));
			 StrPosCopy(strPVolume,RecPumpData[FIPAddr].Volume,0,strlen(strPVolume));
    f380:	fe 01       	movw	r30, r28
    f382:	7d 96       	adiw	r30, 0x1d	; 29
    f384:	df 01       	movw	r26, r30
    f386:	0d 90       	ld	r0, X+
    f388:	00 20       	and	r0, r0
    f38a:	e9 f7       	brne	.-6      	; 0xf386 <StoreStandaloneTransData+0x350>
    f38c:	11 97       	sbiw	r26, 0x01	; 1
    f38e:	ae 1b       	sub	r26, r30
    f390:	bf 0b       	sbc	r27, r31
    f392:	9c 01       	movw	r18, r24
    f394:	22 55       	subi	r18, 0x52	; 82
    f396:	38 4f       	sbci	r19, 0xF8	; 248
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f398:	af 01       	movw	r20, r30
    f39a:	4a 0f       	add	r20, r26
    f39c:	5b 1f       	adc	r21, r27
    f39e:	06 c0       	rjmp	.+12     	; 0xf3ac <StoreStandaloneTransData+0x376>
	    Dest[i]=Source[IdxSource+i];
    f3a0:	f3 01       	movw	r30, r6
    f3a2:	81 91       	ld	r24, Z+
    f3a4:	3f 01       	movw	r6, r30
    f3a6:	f9 01       	movw	r30, r18
    f3a8:	81 93       	st	Z+, r24
    f3aa:	9f 01       	movw	r18, r30
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f3ac:	64 16       	cp	r6, r20
    f3ae:	75 06       	cpc	r7, r21
    f3b0:	b9 f7       	brne	.-18     	; 0xf3a0 <StoreStandaloneTransData+0x36a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f3b2:	85 e3       	ldi	r24, 0x35	; 53
    f3b4:	90 e0       	ldi	r25, 0x00	; 0
    f3b6:	9c 01       	movw	r18, r24
    f3b8:	c2 9e       	mul	r12, r18
    f3ba:	c0 01       	movw	r24, r0
    f3bc:	c3 9e       	mul	r12, r19
    f3be:	90 0d       	add	r25, r0
    f3c0:	d2 9e       	mul	r13, r18
    f3c2:	90 0d       	add	r25, r0
    f3c4:	11 24       	eor	r1, r1
    f3c6:	fc 01       	movw	r30, r24
    f3c8:	e5 57       	subi	r30, 0x75	; 117
    f3ca:	f8 4f       	sbci	r31, 0xF8	; 248
    f3cc:	ea 0f       	add	r30, r26
    f3ce:	fb 1f       	adc	r31, r27
    f3d0:	13 a2       	std	Z+35, r1	; 0x23
			 RecPumpData[FIPAddr].Nozzle=PNozzle;
			 RecPumpData[FIPAddr].Shift=atoi(strShift);
			 //Price Volume Money
			 StrPosCopy(strPPU,RecPumpData[FIPAddr].Price,0,strlen(strPPU));
			 StrPosCopy(strPVolume,RecPumpData[FIPAddr].Volume,0,strlen(strPVolume));
			 StrPosCopy(strPMoney,RecPumpData[FIPAddr].Money,0,strlen(strPMoney));
    f3d2:	fe 01       	movw	r30, r28
    f3d4:	b7 96       	adiw	r30, 0x27	; 39
    f3d6:	df 01       	movw	r26, r30
    f3d8:	0d 90       	ld	r0, X+
    f3da:	00 20       	and	r0, r0
    f3dc:	e9 f7       	brne	.-6      	; 0xf3d8 <StoreStandaloneTransData+0x3a2>
    f3de:	11 97       	sbiw	r26, 0x01	; 1
    f3e0:	ae 1b       	sub	r26, r30
    f3e2:	bf 0b       	sbc	r27, r31
    f3e4:	9c 01       	movw	r18, r24
    f3e6:	29 54       	subi	r18, 0x49	; 73
    f3e8:	38 4f       	sbci	r19, 0xF8	; 248
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f3ea:	af 01       	movw	r20, r30
    f3ec:	4a 0f       	add	r20, r26
    f3ee:	5b 1f       	adc	r21, r27
    f3f0:	06 c0       	rjmp	.+12     	; 0xf3fe <StoreStandaloneTransData+0x3c8>
	    Dest[i]=Source[IdxSource+i];
    f3f2:	f2 01       	movw	r30, r4
    f3f4:	81 91       	ld	r24, Z+
    f3f6:	2f 01       	movw	r4, r30
    f3f8:	f9 01       	movw	r30, r18
    f3fa:	81 93       	st	Z+, r24
    f3fc:	9f 01       	movw	r18, r30
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f3fe:	44 16       	cp	r4, r20
    f400:	55 06       	cpc	r5, r21
    f402:	b9 f7       	brne	.-18     	; 0xf3f2 <StoreStandaloneTransData+0x3bc>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f404:	85 e3       	ldi	r24, 0x35	; 53
    f406:	90 e0       	ldi	r25, 0x00	; 0
    f408:	c8 9e       	mul	r12, r24
    f40a:	f0 01       	movw	r30, r0
    f40c:	c9 9e       	mul	r12, r25
    f40e:	f0 0d       	add	r31, r0
    f410:	d8 9e       	mul	r13, r24
    f412:	f0 0d       	add	r31, r0
    f414:	11 24       	eor	r1, r1
    f416:	e5 57       	subi	r30, 0x75	; 117
    f418:	f8 4f       	sbci	r31, 0xF8	; 248
    f41a:	ea 0f       	add	r30, r26
    f41c:	fb 1f       	adc	r31, r27
    f41e:	14 a6       	std	Z+44, r1	; 0x2c
			 //Price Volume Money
			 StrPosCopy(strPPU,RecPumpData[FIPAddr].Price,0,strlen(strPPU));
			 StrPosCopy(strPVolume,RecPumpData[FIPAddr].Volume,0,strlen(strPVolume));
			 StrPosCopy(strPMoney,RecPumpData[FIPAddr].Money,0,strlen(strPMoney));

			 UpdateStandaloneStatus((iPumpID&0x0F),PS_PRINT_READY);
    f420:	83 2d       	mov	r24, r3
    f422:	8f 70       	andi	r24, 0x0F	; 15
    f424:	60 e1       	ldi	r22, 0x10	; 16
    f426:	0e 94 70 1c 	call	0x38e0	; 0x38e0 <UpdateStandaloneStatus>
			 
			 SetIncomingTransStatus(iPumpID,TS_NEW);		 
    f42a:	83 2d       	mov	r24, r3
    f42c:	62 e0       	ldi	r22, 0x02	; 2
    f42e:	0e 94 ae 1a 	call	0x355c	; 0x355c <SetIncomingTransStatus>

			 SendSlaveCommand(SC_TRANSACTION_ACK,iPumpID);
    f432:	8b e0       	ldi	r24, 0x0B	; 11
    f434:	63 2d       	mov	r22, r3
    f436:	0e 94 83 72 	call	0xe506	; 0xe506 <SendSlaveCommand>
    f43a:	4b c0       	rjmp	.+150    	; 0xf4d2 <StoreStandaloneTransData+0x49c>
			 UpdateStandaloneStatus((iPumpID&0x0F),PS_VOID);
		 }
		 else 
		 if (TransactionStatus=TS_NEW){ 
			 //Update ReprintReady
			 ReprintReady[FIPAddr]=True;//Ready for Printing
    f43c:	da 94       	dec	r13
    f43e:	cd 2c       	mov	r12, r13
    f440:	dd 24       	eor	r13, r13
    f442:	f6 01       	movw	r30, r12
    f444:	ee 57       	subi	r30, 0x7E	; 126
    f446:	fe 4f       	sbci	r31, 0xFE	; 254
    f448:	81 e0       	ldi	r24, 0x01	; 1
    f44a:	80 83       	st	Z, r24
			  
			 FormatPrice(strPPU);
    f44c:	c7 01       	movw	r24, r14
    f44e:	0e 94 ad 31 	call	0x635a	; 0x635a <FormatPrice>
			 FormatMoney(strPMoney);
    f452:	c8 01       	movw	r24, r16
    f454:	0e 94 a0 31 	call	0x6340	; 0x6340 <FormatMoney>
			 FormatVolume(strPVolume);
    f458:	c5 01       	movw	r24, r10
    f45a:	0e 94 93 31 	call	0x6326	; 0x6326 <FormatVolume>

			 //_uart_print(1,1,strPVolume);
			 
			 GenerateTransactionNum(strTranNo);		 
    f45e:	81 e6       	ldi	r24, 0x61	; 97
    f460:	9e e0       	ldi	r25, 0x0E	; 14
    f462:	0e 94 ee 48 	call	0x91dc	; 0x91dc <GenerateTransactionNum>
			 sprintf_P(strTransDate,PSTR("%s"),strSystemDate);
    f466:	00 d0       	rcall	.+0      	; 0xf468 <StoreStandaloneTransData+0x432>
    f468:	00 d0       	rcall	.+0      	; 0xf46a <StoreStandaloneTransData+0x434>
    f46a:	00 d0       	rcall	.+0      	; 0xf46c <StoreStandaloneTransData+0x436>
    f46c:	ed b7       	in	r30, 0x3d	; 61
    f46e:	fe b7       	in	r31, 0x3e	; 62
    f470:	31 96       	adiw	r30, 0x01	; 1
    f472:	ce 01       	movw	r24, r28
    f474:	0b 96       	adiw	r24, 0x0b	; 11
    f476:	ad b7       	in	r26, 0x3d	; 61
    f478:	be b7       	in	r27, 0x3e	; 62
    f47a:	12 96       	adiw	r26, 0x02	; 2
    f47c:	9c 93       	st	X, r25
    f47e:	8e 93       	st	-X, r24
    f480:	11 97       	sbiw	r26, 0x01	; 1
    f482:	81 ec       	ldi	r24, 0xC1	; 193
    f484:	92 e2       	ldi	r25, 0x22	; 34
    f486:	93 83       	std	Z+3, r25	; 0x03
    f488:	82 83       	std	Z+2, r24	; 0x02
    f48a:	8a e9       	ldi	r24, 0x9A	; 154
    f48c:	95 e0       	ldi	r25, 0x05	; 5
    f48e:	95 83       	std	Z+5, r25	; 0x05
    f490:	84 83       	std	Z+4, r24	; 0x04
    f492:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
			 sprintf_P(strTransTime,PSTR("%s"),strSystemTime);
    f496:	ed b7       	in	r30, 0x3d	; 61
    f498:	fe b7       	in	r31, 0x3e	; 62
    f49a:	31 96       	adiw	r30, 0x01	; 1
    f49c:	ce 01       	movw	r24, r28
    f49e:	44 96       	adiw	r24, 0x14	; 20
    f4a0:	ad b7       	in	r26, 0x3d	; 61
    f4a2:	be b7       	in	r27, 0x3e	; 62
    f4a4:	12 96       	adiw	r26, 0x02	; 2
    f4a6:	9c 93       	st	X, r25
    f4a8:	8e 93       	st	-X, r24
    f4aa:	11 97       	sbiw	r26, 0x01	; 1
    f4ac:	8e eb       	ldi	r24, 0xBE	; 190
    f4ae:	92 e2       	ldi	r25, 0x22	; 34
    f4b0:	93 83       	std	Z+3, r25	; 0x03
    f4b2:	82 83       	std	Z+2, r24	; 0x02
    f4b4:	89 e7       	ldi	r24, 0x79	; 121
    f4b6:	9a e0       	ldi	r25, 0x0A	; 10
    f4b8:	95 83       	std	Z+5, r25	; 0x05
    f4ba:	84 83       	std	Z+4, r24	; 0x04
    f4bc:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    f4c0:	ed b7       	in	r30, 0x3d	; 61
    f4c2:	fe b7       	in	r31, 0x3e	; 62
    f4c4:	36 96       	adiw	r30, 0x06	; 6
    f4c6:	0f b6       	in	r0, 0x3f	; 63
    f4c8:	f8 94       	cli
    f4ca:	fe bf       	out	0x3e, r31	; 62
    f4cc:	0f be       	out	0x3f, r0	; 63
    f4ce:	ed bf       	out	0x3d, r30	; 61
    f4d0:	75 ce       	rjmp	.-790    	; 0xf1bc <StoreStandaloneTransData+0x186>

			 SendSlaveCommand(SC_TRANSACTION_ACK,iPumpID);
		 }		 
	 }    
     //_uart_print(0,1,strRawTransData);
}
    f4d2:	e1 96       	adiw	r28, 0x31	; 49
    f4d4:	0f b6       	in	r0, 0x3f	; 63
    f4d6:	f8 94       	cli
    f4d8:	de bf       	out	0x3e, r29	; 62
    f4da:	0f be       	out	0x3f, r0	; 63
    f4dc:	cd bf       	out	0x3d, r28	; 61
    f4de:	cf 91       	pop	r28
    f4e0:	df 91       	pop	r29
    f4e2:	1f 91       	pop	r17
    f4e4:	0f 91       	pop	r16
    f4e6:	ff 90       	pop	r15
    f4e8:	ef 90       	pop	r14
    f4ea:	df 90       	pop	r13
    f4ec:	cf 90       	pop	r12
    f4ee:	bf 90       	pop	r11
    f4f0:	af 90       	pop	r10
    f4f2:	9f 90       	pop	r9
    f4f4:	8f 90       	pop	r8
    f4f6:	7f 90       	pop	r7
    f4f8:	6f 90       	pop	r6
    f4fa:	5f 90       	pop	r5
    f4fc:	4f 90       	pop	r4
    f4fe:	3f 90       	pop	r3
    f500:	2f 90       	pop	r2
    f502:	08 95       	ret

0000f504 <StoreStandaloneTotalizerData>:
	  systemEDC();
	  systemConfigProtocol();
	  //systemGeniusProtocol(); //AKR-->Protocol disabled
}

void StoreStandaloneTotalizerData(char *strRawTransData){//Sending FlowSPI_Protocol <STX>   [MsgID][PumpID][Volume1][Amount1][Volume2][Amount2][Volume3][Amount3][Volume4][Amount4][Volume5][Amount5][Volume6][Amount6]<ETX>
    f504:	2f 92       	push	r2
    f506:	3f 92       	push	r3
    f508:	4f 92       	push	r4
    f50a:	5f 92       	push	r5
    f50c:	7f 92       	push	r7
    f50e:	8f 92       	push	r8
    f510:	9f 92       	push	r9
    f512:	af 92       	push	r10
    f514:	bf 92       	push	r11
    f516:	cf 92       	push	r12
    f518:	df 92       	push	r13
    f51a:	ef 92       	push	r14
    f51c:	ff 92       	push	r15
    f51e:	0f 93       	push	r16
    f520:	1f 93       	push	r17
    f522:	df 93       	push	r29
    f524:	cf 93       	push	r28
    f526:	cd b7       	in	r28, 0x3d	; 61
    f528:	de b7       	in	r29, 0x3e	; 62
    f52a:	a1 97       	sbiw	r28, 0x21	; 33
    f52c:	0f b6       	in	r0, 0x3f	; 63
    f52e:	f8 94       	cli
    f530:	de bf       	out	0x3e, r29	; 62
    f532:	0f be       	out	0x3f, r0	; 63
    f534:	cd bf       	out	0x3d, r28	; 61
    f536:	8c 01       	movw	r16, r24
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    f538:	fc 01       	movw	r30, r24
    f53a:	82 81       	ldd	r24, Z+2	; 0x02
    f53c:	89 83       	std	Y+1, r24	; 0x01
    f53e:	83 81       	ldd	r24, Z+3	; 0x03
    f540:	8a 83       	std	Y+2, r24	; 0x02
	 }Dest[Length]=0;
    f542:	1b 82       	std	Y+3, r1	; 0x03
	 //    _uart(1,1,strRawTransData[i]); 
	 // }

     StrPosCopy(strRawTransData,strPumpID,2,2);
	 //IdIFT(strPumpID);
	 iPumpID=atoi(strPumpID);  
    f544:	ce 01       	movw	r24, r28
    f546:	01 96       	adiw	r24, 0x01	; 1
    f548:	0e 94 ea b3 	call	0x167d4	; 0x167d4 <atoi>
    f54c:	c8 2e       	mov	r12, r24
	 
	 FIPAddr=GetFIPAddr(iPumpID);
    f54e:	0e 94 39 1c 	call	0x3872	; 0x3872 <GetFIPAddr>
	 if (FIPAddr>0){
    f552:	88 23       	and	r24, r24
    f554:	09 f4       	brne	.+2      	; 0xf558 <StoreStandaloneTotalizerData+0x54>
    f556:	44 c0       	rjmp	.+136    	; 0xf5e0 <StoreStandaloneTotalizerData+0xdc>
	     FIPAddr=FIPAddr-1;
    f558:	78 2e       	mov	r7, r24
    f55a:	7a 94       	dec	r7
    f55c:	80 e1       	ldi	r24, 0x10	; 16
    f55e:	e8 2e       	mov	r14, r24
    f560:	f1 2c       	mov	r15, r1
    f562:	e0 0e       	add	r14, r16
    f564:	f1 1e       	adc	r15, r17
    f566:	dd 24       	eor	r13, r13
    f568:	d3 94       	inc	r13
    f56a:	14 e0       	ldi	r17, 0x04	; 4
    f56c:	81 2e       	mov	r8, r17
    f56e:	91 2c       	mov	r9, r1
    f570:	8c 0e       	add	r8, r28
    f572:	9d 1e       	adc	r9, r29
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f574:	b0 e1       	ldi	r27, 0x10	; 16
    f576:	2b 2e       	mov	r2, r27
    f578:	31 2c       	mov	r3, r1
    f57a:	2c 0e       	add	r2, r28
    f57c:	3d 1e       	adc	r3, r29
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f57e:	a3 e1       	ldi	r26, 0x13	; 19
    f580:	aa 2e       	mov	r10, r26
    f582:	b1 2c       	mov	r11, r1
    f584:	ac 0e       	add	r10, r28
    f586:	bd 1e       	adc	r11, r29
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f588:	ff e1       	ldi	r31, 0x1F	; 31
    f58a:	4f 2e       	mov	r4, r31
    f58c:	51 2c       	mov	r5, r1
    f58e:	4c 0e       	add	r4, r28
    f590:	5d 1e       	adc	r5, r29
	 //IdIFT(strPumpID);
	 iPumpID=atoi(strPumpID);  
	 
	 FIPAddr=GetFIPAddr(iPumpID);
	 if (FIPAddr>0){
	     FIPAddr=FIPAddr-1;
    f592:	d7 01       	movw	r26, r14
    f594:	1c 97       	sbiw	r26, 0x0c	; 12
    f596:	f4 01       	movw	r30, r8
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    f598:	8d 91       	ld	r24, X+
    f59a:	81 93       	st	Z+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f59c:	e2 15       	cp	r30, r2
    f59e:	f3 05       	cpc	r31, r3
    f5a0:	d9 f7       	brne	.-10     	; 0xf598 <StoreStandaloneTotalizerData+0x94>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f5a2:	18 8a       	std	Y+16, r1	; 0x10
    f5a4:	f5 01       	movw	r30, r10
    f5a6:	d7 01       	movw	r26, r14
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
    f5a8:	8d 91       	ld	r24, X+
    f5aa:	81 93       	st	Z+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
    f5ac:	e4 15       	cp	r30, r4
    f5ae:	f5 05       	cpc	r31, r5
    f5b0:	d9 f7       	brne	.-10     	; 0xf5a8 <StoreStandaloneTotalizerData+0xa4>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
    f5b2:	1f 8e       	std	Y+31, r1	; 0x1f

		 for (iGrade=1;iGrade<=6;iGrade++){          
			  StrPosCopy(strRawTransData,strGVolume,(4+((iGrade-1)*24)),12);
			  StrPosCopy(strRawTransData,strGMoney,(16+((iGrade-1)*24)),12);
			  
			  SetTotalizerData(TVOLUME,TOTALIZER_NOW,FIPAddr,iGrade,strGVolume);
    f5b4:	80 e0       	ldi	r24, 0x00	; 0
    f5b6:	61 e0       	ldi	r22, 0x01	; 1
    f5b8:	47 2d       	mov	r20, r7
    f5ba:	2d 2d       	mov	r18, r13
    f5bc:	84 01       	movw	r16, r8
    f5be:	0e 94 c2 44 	call	0x8984	; 0x8984 <SetTotalizerData>
			  SetTotalizerData(TMONEY,TOTALIZER_NOW,FIPAddr,iGrade,strGMoney);
    f5c2:	81 e0       	ldi	r24, 0x01	; 1
    f5c4:	61 e0       	ldi	r22, 0x01	; 1
    f5c6:	47 2d       	mov	r20, r7
    f5c8:	2d 2d       	mov	r18, r13
    f5ca:	85 01       	movw	r16, r10
    f5cc:	0e 94 c2 44 	call	0x8984	; 0x8984 <SetTotalizerData>
	 FIPAddr=GetFIPAddr(iPumpID);
	 if (FIPAddr>0){
	     FIPAddr=FIPAddr-1;
		 //_uart_printf(1,1,PSTR("Totalizer:"));

		 for (iGrade=1;iGrade<=6;iGrade++){          
    f5d0:	d3 94       	inc	r13
    f5d2:	88 e1       	ldi	r24, 0x18	; 24
    f5d4:	90 e0       	ldi	r25, 0x00	; 0
    f5d6:	e8 0e       	add	r14, r24
    f5d8:	f9 1e       	adc	r15, r25
    f5da:	97 e0       	ldi	r25, 0x07	; 7
    f5dc:	d9 16       	cp	r13, r25
    f5de:	c9 f6       	brne	.-78     	; 0xf592 <StoreStandaloneTotalizerData+0x8e>
			  SetTotalizerData(TMONEY,TOTALIZER_NOW,FIPAddr,iGrade,strGMoney);
			  //sprintf_P(strSend,PSTR("Nozzle:%d Volume:%s Money:%s"),iGrade,strGVolume,strGMoney);
			  //_uart_print(0,1,strSend);
		 }	
	}
     SendSlaveCommand(SC_TOTALIZER_ACK,iPumpID);
    f5e0:	8d e0       	ldi	r24, 0x0D	; 13
    f5e2:	6c 2d       	mov	r22, r12
    f5e4:	0e 94 83 72 	call	0xe506	; 0xe506 <SendSlaveCommand>
	 UpdateStandaloneStatus((iPumpID&0x0F),PS_TOTALIZER);	 
    f5e8:	8c 2d       	mov	r24, r12
    f5ea:	8f 70       	andi	r24, 0x0F	; 15
    f5ec:	64 e1       	ldi	r22, 0x14	; 20
    f5ee:	0e 94 70 1c 	call	0x38e0	; 0x38e0 <UpdateStandaloneStatus>
}
    f5f2:	a1 96       	adiw	r28, 0x21	; 33
    f5f4:	0f b6       	in	r0, 0x3f	; 63
    f5f6:	f8 94       	cli
    f5f8:	de bf       	out	0x3e, r29	; 62
    f5fa:	0f be       	out	0x3f, r0	; 63
    f5fc:	cd bf       	out	0x3d, r28	; 61
    f5fe:	cf 91       	pop	r28
    f600:	df 91       	pop	r29
    f602:	1f 91       	pop	r17
    f604:	0f 91       	pop	r16
    f606:	ff 90       	pop	r15
    f608:	ef 90       	pop	r14
    f60a:	df 90       	pop	r13
    f60c:	cf 90       	pop	r12
    f60e:	bf 90       	pop	r11
    f610:	af 90       	pop	r10
    f612:	9f 90       	pop	r9
    f614:	8f 90       	pop	r8
    f616:	7f 90       	pop	r7
    f618:	5f 90       	pop	r5
    f61a:	4f 90       	pop	r4
    f61c:	3f 90       	pop	r3
    f61e:	2f 90       	pop	r2
    f620:	08 95       	ret

0000f622 <ScanStandaloneFlow>:
	 _spi(SlaveMessage);
	 _spi(0x06);
	 systemSlave();
}

void ScanStandaloneFlow(char data){  //<STX>[PumpID][STA]<ETX> --> 0x07 0xF1 0xF2 0x08
    f622:	0f 93       	push	r16
    f624:	1f 93       	push	r17
    f626:	08 2f       	mov	r16, r24

      DataPumpID=0;
      DataPumpStatus=0;
	  MixData=0;
      //Shift data
      zDataFlow[4]=zDataFlow[3];
    f628:	80 91 b7 03 	lds	r24, 0x03B7
    f62c:	80 93 b8 03 	sts	0x03B8, r24
	  zDataFlow[3]=zDataFlow[2];
    f630:	80 91 b6 03 	lds	r24, 0x03B6
    f634:	80 93 b7 03 	sts	0x03B7, r24
	  zDataFlow[2]=zDataFlow[1];
    f638:	80 91 b5 03 	lds	r24, 0x03B5
    f63c:	80 93 b6 03 	sts	0x03B6, r24
      zDataFlow[1]=zDataFlow[0];
    f640:	90 91 b4 03 	lds	r25, 0x03B4
    f644:	90 93 b5 03 	sts	0x03B5, r25
      zDataFlow[0]=data;
    f648:	00 93 b4 03 	sts	0x03B4, r16

      //Scan UpdatedPumpStatus Flow
	  //<STX>[ID][STA]<ETX>: 0x07[ID STA]0x08
	  if((zDataFlow[2]==0x07)&&(zDataFlow[0]==0x08)){
    f64c:	87 30       	cpi	r24, 0x07	; 7
    f64e:	79 f4       	brne	.+30     	; 0xf66e <ScanStandaloneFlow+0x4c>
    f650:	08 30       	cpi	r16, 0x08	; 8
    f652:	69 f4       	brne	.+26     	; 0xf66e <ScanStandaloneFlow+0x4c>
          MixData=zDataFlow[1];
	      DataPumpID=((MixData&0xF0)>>4);
		  DataPumpStatus=(MixData&0x0F);
    f654:	19 2f       	mov	r17, r25
    f656:	1f 70       	andi	r17, 0x0F	; 15
		  UpdateStandaloneStatus(DataPumpID,DataPumpStatus);
    f658:	89 2f       	mov	r24, r25
    f65a:	82 95       	swap	r24
    f65c:	8f 70       	andi	r24, 0x0F	; 15
    f65e:	61 2f       	mov	r22, r17
    f660:	0e 94 70 1c 	call	0x38e0	; 0x38e0 <UpdateStandaloneStatus>
		  if (DataPumpStatus!=PUMP_NONE)IsStandAloneDetected=True;
    f664:	1e 30       	cpi	r17, 0x0E	; 14
    f666:	19 f0       	breq	.+6      	; 0xf66e <ScanStandaloneFlow+0x4c>
    f668:	81 e0       	ldi	r24, 0x01	; 1
    f66a:	80 93 b3 01 	sts	0x01B3, r24
		  //sprintf_P(strSend,PSTR("PS:%d Id:%d"),MixData,DataPumpID);
		  //_uart_print(0,1,strSend);
	  }

	  //Scan Transaction Completion FEOT
	  if (IsStandaloneTrans==True){
    f66e:	80 91 b4 01 	lds	r24, 0x01B4
    f672:	81 30       	cpi	r24, 0x01	; 1
    f674:	69 f4       	brne	.+26     	; 0xf690 <ScanStandaloneFlow+0x6e>
	      strStandReceived[iFlow]=data;
    f676:	80 91 b2 03 	lds	r24, 0x03B2
    f67a:	90 91 b3 03 	lds	r25, 0x03B3
    f67e:	fc 01       	movw	r30, r24
    f680:	ea 51       	subi	r30, 0x1A	; 26
    f682:	fb 4f       	sbci	r31, 0xFB	; 251
    f684:	00 83       	st	Z, r16
		  iFlow++;
    f686:	01 96       	adiw	r24, 0x01	; 1
    f688:	90 93 b3 03 	sts	0x03B3, r25
    f68c:	80 93 b2 03 	sts	0x03B2, r24
	  }
	  if((zDataFlow[1]==0x05)&&(zDataFlow[0]==0x50)){
    f690:	80 91 b5 03 	lds	r24, 0x03B5
    f694:	85 30       	cpi	r24, 0x05	; 5
    f696:	61 f4       	brne	.+24     	; 0xf6b0 <ScanStandaloneFlow+0x8e>
    f698:	80 91 b4 03 	lds	r24, 0x03B4
    f69c:	80 35       	cpi	r24, 0x50	; 80
    f69e:	41 f5       	brne	.+80     	; 0xf6f0 <ScanStandaloneFlow+0xce>
	      IsStandaloneTrans=True;
    f6a0:	81 e0       	ldi	r24, 0x01	; 1
    f6a2:	80 93 b4 01 	sts	0x01B4, r24
		  iFlow=0;
    f6a6:	10 92 b3 03 	sts	0x03B3, r1
    f6aa:	10 92 b2 03 	sts	0x03B2, r1
    f6ae:	20 c0       	rjmp	.+64     	; 0xf6f0 <ScanStandaloneFlow+0xce>
	  }
	  if((zDataFlow[1]==0x06)&&(zDataFlow[0]==0x60)){
    f6b0:	86 30       	cpi	r24, 0x06	; 6
    f6b2:	f1 f4       	brne	.+60     	; 0xf6f0 <ScanStandaloneFlow+0xce>
    f6b4:	80 91 b4 03 	lds	r24, 0x03B4
    f6b8:	80 36       	cpi	r24, 0x60	; 96
    f6ba:	d1 f4       	brne	.+52     	; 0xf6f0 <ScanStandaloneFlow+0xce>
	      IsStandaloneTrans=False;
    f6bc:	10 92 b4 01 	sts	0x01B4, r1
	      strStandReceived[iFlow]=0;
    f6c0:	e0 91 b2 03 	lds	r30, 0x03B2
    f6c4:	f0 91 b3 03 	lds	r31, 0x03B3
    f6c8:	ea 51       	subi	r30, 0x1A	; 26
    f6ca:	fb 4f       	sbci	r31, 0xFB	; 251
    f6cc:	10 82       	st	Z, r1

		  //_uart_print(1,1,strStandReceived);

		  MsgIDx=GetMessageID(strStandReceived);
    f6ce:	86 ee       	ldi	r24, 0xE6	; 230
    f6d0:	94 e0       	ldi	r25, 0x04	; 4
    f6d2:	0e 94 f8 40 	call	0x81f0	; 0x81f0 <GetMessageID>
          if (MsgIDx==0x01)StoreStandaloneTransData(strStandReceived);
    f6d6:	81 30       	cpi	r24, 0x01	; 1
    f6d8:	29 f4       	brne	.+10     	; 0xf6e4 <ScanStandaloneFlow+0xc2>
    f6da:	86 ee       	ldi	r24, 0xE6	; 230
    f6dc:	94 e0       	ldi	r25, 0x04	; 4
    f6de:	0e 94 1b 78 	call	0xf036	; 0xf036 <StoreStandaloneTransData>
    f6e2:	06 c0       	rjmp	.+12     	; 0xf6f0 <ScanStandaloneFlow+0xce>
		  else
          if (MsgIDx==0x02)StoreStandaloneTotalizerData(strStandReceived);
    f6e4:	82 30       	cpi	r24, 0x02	; 2
    f6e6:	21 f4       	brne	.+8      	; 0xf6f0 <ScanStandaloneFlow+0xce>
    f6e8:	86 ee       	ldi	r24, 0xE6	; 230
    f6ea:	94 e0       	ldi	r25, 0x04	; 4
    f6ec:	0e 94 82 7a 	call	0xf504	; 0xf504 <StoreStandaloneTotalizerData>
	  }
	  //AcknoledgeCommand
	  if ((zDataFlow[3]==0x09)&&(zDataFlow[0]==0x0A)){
    f6f0:	80 91 b7 03 	lds	r24, 0x03B7
    f6f4:	89 30       	cpi	r24, 0x09	; 9
    f6f6:	c1 f5       	brne	.+112    	; 0xf768 <ScanStandaloneFlow+0x146>
    f6f8:	80 91 b4 03 	lds	r24, 0x03B4
    f6fc:	8a 30       	cpi	r24, 0x0A	; 10
    f6fe:	a1 f5       	brne	.+104    	; 0xf768 <ScanStandaloneFlow+0x146>
	      
	      AcknoledgePump=zDataFlow[1];
    f700:	90 91 b5 03 	lds	r25, 0x03B5
    f704:	90 93 c7 0d 	sts	0x0DC7, r25
	      AcknoledgeCommand=zDataFlow[2];	  
    f708:	80 91 b6 03 	lds	r24, 0x03B6
    f70c:	80 93 80 07 	sts	0x0780, r24
		  switch(AcknoledgeCommand){
    f710:	89 31       	cpi	r24, 0x19	; 25
    f712:	51 f0       	breq	.+20     	; 0xf728 <ScanStandaloneFlow+0x106>
    f714:	8a 31       	cpi	r24, 0x1A	; 26
    f716:	18 f4       	brcc	.+6      	; 0xf71e <ScanStandaloneFlow+0xfc>
    f718:	85 30       	cpi	r24, 0x05	; 5
    f71a:	19 f5       	brne	.+70     	; 0xf762 <ScanStandaloneFlow+0x140>
    f71c:	17 c0       	rjmp	.+46     	; 0xf74c <ScanStandaloneFlow+0x12a>
    f71e:	8a 31       	cpi	r24, 0x1A	; 26
    f720:	c9 f0       	breq	.+50     	; 0xf754 <ScanStandaloneFlow+0x132>
    f722:	8c 31       	cpi	r24, 0x1C	; 28
    f724:	f1 f4       	brne	.+60     	; 0xf762 <ScanStandaloneFlow+0x140>
    f726:	1a c0       	rjmp	.+52     	; 0xf75c <ScanStandaloneFlow+0x13a>
		  case SC_LIVE_SEQUENCE:
		       iSequencePooling=AcknoledgePump;
    f728:	90 93 93 01 	sts	0x0193, r25
			   IsNewPoolingSequence=True;
    f72c:	81 e0       	ldi	r24, 0x01	; 1
    f72e:	80 93 94 01 	sts	0x0194, r24
			   //SendPoolingCommand()
			   if (IsControlPooling==True){
    f732:	80 91 97 01 	lds	r24, 0x0197
    f736:	81 30       	cpi	r24, 0x01	; 1
    f738:	a1 f4       	brne	.+40     	; 0xf762 <ScanStandaloneFlow+0x140>
			       IsControlPooling=False;
    f73a:	10 92 97 01 	sts	0x0197, r1
				   SendSlaveCommand(PoolCmd,PoolMsg);
    f73e:	80 91 8a 07 	lds	r24, 0x078A
    f742:	60 91 ae 0d 	lds	r22, 0x0DAE
    f746:	0e 94 83 72 	call	0xe506	; 0xe506 <SendSlaveCommand>
    f74a:	0b c0       	rjmp	.+22     	; 0xf762 <ScanStandaloneFlow+0x140>
                }
		       break;
          case SC_TOTALIZER:
		       IsTotalizerReceived=True;
    f74c:	81 e0       	ldi	r24, 0x01	; 1
    f74e:	80 93 c5 01 	sts	0x01C5, r24
    f752:	07 c0       	rjmp	.+14     	; 0xf762 <ScanStandaloneFlow+0x140>
		       break;
		  case SC_POOL_RESTARTED:
		       IsPoolingRestarted=True;
    f754:	81 e0       	ldi	r24, 0x01	; 1
    f756:	80 93 96 01 	sts	0x0196, r24
    f75a:	03 c0       	rjmp	.+6      	; 0xf762 <ScanStandaloneFlow+0x140>
		       break;
          case SC_SET_PUMP_TYPE:
		       IsSetPumpType=True;
    f75c:	81 e0       	ldi	r24, 0x01	; 1
    f75e:	80 93 23 01 	sts	0x0123, r24
		       break;
		  }
       IsStandaloneAcknoledge=True;
    f762:	81 e0       	ldi	r24, 0x01	; 1
    f764:	80 93 95 01 	sts	0x0195, r24
	  }
}
    f768:	1f 91       	pop	r17
    f76a:	0f 91       	pop	r16
    f76c:	08 95       	ret

0000f76e <__vector_17>:
//	  sprintf(SerialSend,"Length:%i",Length);	 
//	  _uart_print(1,0,SerialSend);
	 }
}

ISR(SPI_STC_vect){
    f76e:	1f 92       	push	r1
    f770:	0f 92       	push	r0
    f772:	0f b6       	in	r0, 0x3f	; 63
    f774:	0f 92       	push	r0
    f776:	0b b6       	in	r0, 0x3b	; 59
    f778:	0f 92       	push	r0
    f77a:	11 24       	eor	r1, r1
    f77c:	1f 93       	push	r17
    f77e:	2f 93       	push	r18
    f780:	3f 93       	push	r19
    f782:	4f 93       	push	r20
    f784:	5f 93       	push	r21
    f786:	6f 93       	push	r22
    f788:	7f 93       	push	r23
    f78a:	8f 93       	push	r24
    f78c:	9f 93       	push	r25
    f78e:	af 93       	push	r26
    f790:	bf 93       	push	r27
    f792:	ef 93       	push	r30
    f794:	ff 93       	push	r31
char dataSPI;
//char Reply=0;
    //_uart(0,1,SPDR);
	dataSPI=SPDR;
    f796:	1f b1       	in	r17, 0x0f	; 15
	ScanRFIDFlow(dataSPI);
    f798:	81 2f       	mov	r24, r17
    f79a:	0e 94 8f 14 	call	0x291e	; 0x291e <ScanRFIDFlow>
	if (IFType==IT_SLAVE)ScanEDCFlow(dataSPI);
    f79e:	80 91 10 01 	lds	r24, 0x0110
    f7a2:	81 30       	cpi	r24, 0x01	; 1
    f7a4:	21 f4       	brne	.+8      	; 0xf7ae <__vector_17+0x40>
    f7a6:	81 2f       	mov	r24, r17
    f7a8:	0e 94 cd 13 	call	0x279a	; 0x279a <ScanEDCFlow>
    f7ac:	05 c0       	rjmp	.+10     	; 0xf7b8 <__vector_17+0x4a>
	else
	if (IFType==IT_STANDALONE)ScanStandaloneFlow(dataSPI);
    f7ae:	82 30       	cpi	r24, 0x02	; 2
    f7b0:	19 f4       	brne	.+6      	; 0xf7b8 <__vector_17+0x4a>
    f7b2:	81 2f       	mov	r24, r17
    f7b4:	0e 94 11 7b 	call	0xf622	; 0xf622 <ScanStandaloneFlow>
}
    f7b8:	ff 91       	pop	r31
    f7ba:	ef 91       	pop	r30
    f7bc:	bf 91       	pop	r27
    f7be:	af 91       	pop	r26
    f7c0:	9f 91       	pop	r25
    f7c2:	8f 91       	pop	r24
    f7c4:	7f 91       	pop	r23
    f7c6:	6f 91       	pop	r22
    f7c8:	5f 91       	pop	r21
    f7ca:	4f 91       	pop	r20
    f7cc:	3f 91       	pop	r19
    f7ce:	2f 91       	pop	r18
    f7d0:	1f 91       	pop	r17
    f7d2:	0f 90       	pop	r0
    f7d4:	0b be       	out	0x3b, r0	; 59
    f7d6:	0f 90       	pop	r0
    f7d8:	0f be       	out	0x3f, r0	; 63
    f7da:	0f 90       	pop	r0
    f7dc:	1f 90       	pop	r1
    f7de:	18 95       	reti

0000f7e0 <UserInput>:
void ShowMessage(char *Message){//Display Message on Line3
     char i;
}


char UserInput(char TypeUI,char xPos, char yPos,char *strResult, unsigned int MaxValue, char MaxLength){
    f7e0:	8f 92       	push	r8
    f7e2:	9f 92       	push	r9
    f7e4:	af 92       	push	r10
    f7e6:	bf 92       	push	r11
    f7e8:	cf 92       	push	r12
    f7ea:	df 92       	push	r13
    f7ec:	ef 92       	push	r14
    f7ee:	ff 92       	push	r15
    f7f0:	0f 93       	push	r16
    f7f2:	1f 93       	push	r17
    f7f4:	cf 93       	push	r28
    f7f6:	df 93       	push	r29
    f7f8:	f8 2e       	mov	r15, r24
    f7fa:	96 2e       	mov	r9, r22
    f7fc:	d4 2e       	mov	r13, r20
    f7fe:	e9 01       	movw	r28, r18
    f800:	58 01       	movw	r10, r16
    f802:	8e 2c       	mov	r8, r14
	 static char iHit=0,IsShifted=False,IsSameKey=False,IsNextKey=False,IsNewKey=False,IsFirst=False;//,KeyByte=0;
	 static unsigned int iLoop=0,KeyTimeout;//,TimerPressed=0,NewKeyTimeout;
	        unsigned int NumbValue=0;
	 char KeyPressed=0,KeyChar=0,iDisp=0;
     Result=USER_NONE;
	 switch(stUserInput){// 100 ->199 500 90
    f804:	10 91 6b 03 	lds	r17, 0x036B
    f808:	12 30       	cpi	r17, 0x02	; 2
    f80a:	09 f4       	brne	.+2      	; 0xf80e <UserInput+0x2e>
    f80c:	2c c2       	rjmp	.+1112   	; 0xfc66 <UserInput+0x486>
    f80e:	13 30       	cpi	r17, 0x03	; 3
    f810:	30 f4       	brcc	.+12     	; 0xf81e <UserInput+0x3e>
    f812:	11 23       	and	r17, r17
    f814:	59 f0       	breq	.+22     	; 0xf82c <UserInput+0x4c>
    f816:	11 30       	cpi	r17, 0x01	; 1
    f818:	09 f0       	breq	.+2      	; 0xf81c <UserInput+0x3c>
    f81a:	f5 c2       	rjmp	.+1514   	; 0xfe06 <UserInput+0x626>
    f81c:	2c c0       	rjmp	.+88     	; 0xf876 <UserInput+0x96>
    f81e:	13 30       	cpi	r17, 0x03	; 3
    f820:	09 f4       	brne	.+2      	; 0xf824 <UserInput+0x44>
    f822:	76 c2       	rjmp	.+1260   	; 0xfd10 <UserInput+0x530>
    f824:	14 30       	cpi	r17, 0x04	; 4
    f826:	09 f0       	breq	.+2      	; 0xf82a <UserInput+0x4a>
    f828:	ee c2       	rjmp	.+1500   	; 0xfe06 <UserInput+0x626>
    f82a:	ef c2       	rjmp	.+1502   	; 0xfe0a <UserInput+0x62a>
	 case uiInit:
	      iLoop=0;
    f82c:	10 92 5d 03 	sts	0x035D, r1
    f830:	10 92 5c 03 	sts	0x035C, r1
		  stUserInput=uiInput;
		  xChar=xPos;yChar=yPos;
    f834:	60 93 6a 03 	sts	0x036A, r22
    f838:	40 93 69 03 	sts	0x0369, r20
          iValuePos=0;
    f83c:	10 92 68 03 	sts	0x0368, r1
		  KeyTimeout=0;
    f840:	10 92 5b 03 	sts	0x035B, r1
    f844:	10 92 5a 03 	sts	0x035A, r1
		  IsSameKey=False;
    f848:	10 92 61 03 	sts	0x0361, r1
		  IsNextKey=False;
    f84c:	10 92 60 03 	sts	0x0360, r1
		  IsNewKey=False;
    f850:	10 92 5f 03 	sts	0x035F, r1
		  IsShifted=True;
    f854:	91 e0       	ldi	r25, 0x01	; 1
    f856:	90 93 62 03 	sts	0x0362, r25
		  zKeyChar=' ';
    f85a:	80 e2       	ldi	r24, 0x20	; 32
    f85c:	80 93 67 03 	sts	0x0367, r24
		  iHit=0;
    f860:	10 92 63 03 	sts	0x0363, r1
		  IsFirst=False;
    f864:	10 92 5e 03 	sts	0x035E, r1
		  IsDelete=False;
    f868:	10 92 64 03 	sts	0x0364, r1
		  Result=USER_NO_DATA;
		  stUserInput=uiInput;
    f86c:	90 93 6b 03 	sts	0x036B, r25
    f870:	35 e0       	ldi	r19, 0x05	; 5
    f872:	e3 2e       	mov	r14, r19
    f874:	ce c2       	rjmp	.+1436   	; 0xfe12 <UserInput+0x632>
	      break;
	 case uiInput:
	      KeyPressed=_key_scan(1);                  //  _  ABC DEF GHI JKL MNO PQRS TUV WXYZ
    f876:	81 e0       	ldi	r24, 0x01	; 1
    f878:	0e 94 ab ae 	call	0x15d56	; 0x15d56 <_key_scan>
    f87c:	c8 2e       	mov	r12, r24
		  KeyChar= _key_btn(KeyPressed);            //  1   2   3   4   5   6   7    8   9
    f87e:	0e 94 0c ae 	call	0x15c18	; 0x15c18 <_key_btn>
    f882:	e8 2e       	mov	r14, r24
		  if (KeyPressed==_KEY_SHIFT){
    f884:	2b e7       	ldi	r18, 0x7B	; 123
    f886:	c2 16       	cp	r12, r18
    f888:	59 f4       	brne	.+22     	; 0xf8a0 <UserInput+0xc0>
		      if (IsShifted==False)IsShifted=True;
    f88a:	80 91 62 03 	lds	r24, 0x0362
    f88e:	88 23       	and	r24, r24
    f890:	19 f4       	brne	.+6      	; 0xf898 <UserInput+0xb8>
    f892:	10 93 62 03 	sts	0x0362, r17
    f896:	04 c0       	rjmp	.+8      	; 0xf8a0 <UserInput+0xc0>
			  else
		      if (IsShifted==True)IsShifted=False;
    f898:	81 30       	cpi	r24, 0x01	; 1
    f89a:	11 f4       	brne	.+4      	; 0xf8a0 <UserInput+0xc0>
    f89c:	10 92 62 03 	sts	0x0362, r1
			  }
          
		  if (IsSameKey==True){
    f8a0:	80 91 61 03 	lds	r24, 0x0361
    f8a4:	81 30       	cpi	r24, 0x01	; 1
    f8a6:	e9 f4       	brne	.+58     	; 0xf8e2 <UserInput+0x102>
		      KeyTimeout++;
    f8a8:	80 91 5a 03 	lds	r24, 0x035A
    f8ac:	90 91 5b 03 	lds	r25, 0x035B
    f8b0:	01 96       	adiw	r24, 0x01	; 1
    f8b2:	90 93 5b 03 	sts	0x035B, r25
    f8b6:	80 93 5a 03 	sts	0x035A, r24
              if (KeyTimeout>1000){
    f8ba:	89 5e       	subi	r24, 0xE9	; 233
    f8bc:	93 40       	sbci	r25, 0x03	; 3
    f8be:	88 f0       	brcs	.+34     	; 0xf8e2 <UserInput+0x102>
			      if (TypeUI==UI_ALPHANUM_PASSWORD)lcd_put(xChar,yChar,'*');
    f8c0:	f5 e0       	ldi	r31, 0x05	; 5
    f8c2:	ff 16       	cp	r15, r31
    f8c4:	39 f4       	brne	.+14     	; 0xf8d4 <UserInput+0xf4>
    f8c6:	80 91 6a 03 	lds	r24, 0x036A
    f8ca:	60 91 69 03 	lds	r22, 0x0369
    f8ce:	4a e2       	ldi	r20, 0x2A	; 42
    f8d0:	0e 94 7f ad 	call	0x15afe	; 0x15afe <lcd_put>

		          IsNextKey=True;
    f8d4:	81 e0       	ldi	r24, 0x01	; 1
    f8d6:	80 93 60 03 	sts	0x0360, r24
				  iLoop=0;
    f8da:	10 92 5d 03 	sts	0x035D, r1
    f8de:	10 92 5c 03 	sts	0x035C, r1
			     }
              }
 
 		  //if (((KeyChar>='0')&&(KeyChar<='9')&&(iValuePos<=MaxLength))||(IsNextKey==True)){
		  if (((KeyChar>='0')&&(KeyChar<='9')&&(iValuePos<MaxLength))||(IsNextKey==True)){
    f8e2:	8e 2d       	mov	r24, r14
    f8e4:	80 53       	subi	r24, 0x30	; 48
    f8e6:	8a 30       	cpi	r24, 0x0A	; 10
    f8e8:	20 f4       	brcc	.+8      	; 0xf8f2 <UserInput+0x112>
    f8ea:	80 91 68 03 	lds	r24, 0x0368
    f8ee:	88 15       	cp	r24, r8
    f8f0:	40 f0       	brcs	.+16     	; 0xf902 <UserInput+0x122>
    f8f2:	80 91 60 03 	lds	r24, 0x0360
    f8f6:	81 30       	cpi	r24, 0x01	; 1
    f8f8:	21 f0       	breq	.+8      	; 0xf902 <UserInput+0x122>
    f8fa:	ee 24       	eor	r14, r14
    f8fc:	00 e0       	ldi	r16, 0x00	; 0
    f8fe:	10 e0       	ldi	r17, 0x00	; 0
    f900:	be c0       	rjmp	.+380    	; 0xfa7e <UserInput+0x29e>
    f902:	84 e2       	ldi	r24, 0x24	; 36
    f904:	94 ef       	ldi	r25, 0xF4	; 244
    f906:	01 97       	sbiw	r24, 0x01	; 1
    f908:	f1 f7       	brne	.-4      	; 0xf906 <UserInput+0x126>
		       _delay_ms(250);
		       strResult[iValuePos]=KeyChar;
    f90a:	80 91 68 03 	lds	r24, 0x0368
    f90e:	fe 01       	movw	r30, r28
    f910:	e8 0f       	add	r30, r24
    f912:	f1 1d       	adc	r31, r1
    f914:	e0 82       	st	Z, r14
		       strResult[iValuePos+1]=0;
    f916:	11 82       	std	Z+1, r1	; 0x01

			   if ((TypeUI==UI_NUMBER_R)||(TypeUI==UI_NUMBER_L)||(TypeUI==UI_NUM_PASSWORD)) 
    f918:	8f 2d       	mov	r24, r15
    f91a:	81 50       	subi	r24, 0x01	; 1
    f91c:	82 30       	cpi	r24, 0x02	; 2
    f91e:	30 f0       	brcs	.+12     	; 0xf92c <UserInput+0x14c>
    f920:	24 e0       	ldi	r18, 0x04	; 4
    f922:	f2 16       	cp	r15, r18
    f924:	19 f0       	breq	.+6      	; 0xf92c <UserInput+0x14c>
    f926:	00 e0       	ldi	r16, 0x00	; 0
    f928:	10 e0       	ldi	r17, 0x00	; 0
    f92a:	04 c0       	rjmp	.+8      	; 0xf934 <UserInput+0x154>
			        NumbValue=atoi(strResult);
    f92c:	ce 01       	movw	r24, r28
    f92e:	0e 94 ea b3 	call	0x167d4	; 0x167d4 <atoi>
    f932:	8c 01       	movw	r16, r24
			   else NumbValue=0;
				
			   if ((TypeUI==UI_ALPHANUM_R)||(TypeUI==UI_ALPHANUM_PASSWORD)){
    f934:	83 e0       	ldi	r24, 0x03	; 3
    f936:	f8 16       	cp	r15, r24
    f938:	21 f0       	breq	.+8      	; 0xf942 <UserInput+0x162>
    f93a:	e5 e0       	ldi	r30, 0x05	; 5
    f93c:	fe 16       	cp	r15, r30
    f93e:	09 f0       	breq	.+2      	; 0xf942 <UserInput+0x162>
    f940:	63 c0       	rjmp	.+198    	; 0xfa08 <UserInput+0x228>
			       if (KeyChar!=zKeyChar){
    f942:	80 91 67 03 	lds	r24, 0x0367
    f946:	e8 16       	cp	r14, r24
    f948:	71 f0       	breq	.+28     	; 0xf966 <UserInput+0x186>
					   IsSameKey=False;
    f94a:	10 92 61 03 	sts	0x0361, r1
					   IsNewKey=True;
    f94e:	81 e0       	ldi	r24, 0x01	; 1
    f950:	80 93 5f 03 	sts	0x035F, r24
				       iHit=0;
    f954:	10 92 63 03 	sts	0x0363, r1
					   iLoop=1000;
    f958:	88 ee       	ldi	r24, 0xE8	; 232
    f95a:	93 e0       	ldi	r25, 0x03	; 3
    f95c:	90 93 5d 03 	sts	0x035D, r25
    f960:	80 93 5c 03 	sts	0x035C, r24
    f964:	51 c0       	rjmp	.+162    	; 0xfa08 <UserInput+0x228>
				   }
                   else{
				   if (IsNewKey==True){
    f966:	80 91 5f 03 	lds	r24, 0x035F
    f96a:	81 30       	cpi	r24, 0x01	; 1
    f96c:	71 f4       	brne	.+28     	; 0xf98a <UserInput+0x1aa>
					   IsNewKey=False;
    f96e:	10 92 5f 03 	sts	0x035F, r1
					   yChar--;
    f972:	80 91 69 03 	lds	r24, 0x0369
    f976:	81 50       	subi	r24, 0x01	; 1
    f978:	80 93 69 03 	sts	0x0369, r24
					   if (iValuePos>0) iValuePos--;
    f97c:	80 91 68 03 	lds	r24, 0x0368
    f980:	88 23       	and	r24, r24
    f982:	19 f0       	breq	.+6      	; 0xf98a <UserInput+0x1aa>
    f984:	81 50       	subi	r24, 0x01	; 1
    f986:	80 93 68 03 	sts	0x0368, r24
					   }
				   KeyTimeout=0;
    f98a:	10 92 5b 03 	sts	0x035B, r1
    f98e:	10 92 5a 03 	sts	0x035A, r1
				   IsSameKey=True;
    f992:	81 e0       	ldi	r24, 0x01	; 1
    f994:	80 93 61 03 	sts	0x0361, r24
				   if (iHit<pgm_read_byte(&MaxKeyHit[(zKeyChar-'0')])) iHit++;
    f998:	80 91 63 03 	lds	r24, 0x0363
    f99c:	e0 91 67 03 	lds	r30, 0x0367
    f9a0:	f0 e0       	ldi	r31, 0x00	; 0
    f9a2:	e2 53       	subi	r30, 0x32	; 50
    f9a4:	fd 4f       	sbci	r31, 0xFD	; 253
    f9a6:	e4 91       	lpm	r30, Z+
    f9a8:	8e 17       	cp	r24, r30
    f9aa:	20 f4       	brcc	.+8      	; 0xf9b4 <UserInput+0x1d4>
    f9ac:	8f 5f       	subi	r24, 0xFF	; 255
    f9ae:	80 93 63 03 	sts	0x0363, r24
    f9b2:	02 c0       	rjmp	.+4      	; 0xf9b8 <UserInput+0x1d8>
                   else iHit=0;
    f9b4:	10 92 63 03 	sts	0x0363, r1
				   iLoop=1000;
    f9b8:	88 ee       	ldi	r24, 0xE8	; 232
    f9ba:	93 e0       	ldi	r25, 0x03	; 3
    f9bc:	90 93 5d 03 	sts	0x035D, r25
    f9c0:	80 93 5c 03 	sts	0x035C, r24

                   zAlphaChar=AlphaChar;
    f9c4:	80 91 65 03 	lds	r24, 0x0365
    f9c8:	80 93 66 03 	sts	0x0366, r24
			       AlphaChar=_table_alphanum(IsShifted,KeyPressed,iHit);			   
    f9cc:	80 91 62 03 	lds	r24, 0x0362
    f9d0:	6c 2d       	mov	r22, r12
    f9d2:	40 91 63 03 	lds	r20, 0x0363
    f9d6:	0e 94 5e ae 	call	0x15cbc	; 0x15cbc <_table_alphanum>
    f9da:	80 93 65 03 	sts	0x0365, r24
                   
				   if (IsNextKey==True){
    f9de:	80 91 60 03 	lds	r24, 0x0360
    f9e2:	81 30       	cpi	r24, 0x01	; 1
    f9e4:	41 f4       	brne	.+16     	; 0xf9f6 <UserInput+0x216>
                       AlphaChar=zAlphaChar;       
    f9e6:	80 91 66 03 	lds	r24, 0x0366
    f9ea:	80 93 65 03 	sts	0x0365, r24
					   IsNextKey=False;
    f9ee:	10 92 60 03 	sts	0x0360, r1
					   IsSameKey=False;
    f9f2:	10 92 61 03 	sts	0x0361, r1
				   }   
				   strResult[iValuePos]=AlphaChar;
    f9f6:	80 91 68 03 	lds	r24, 0x0368
    f9fa:	fe 01       	movw	r30, r28
    f9fc:	e8 0f       	add	r30, r24
    f9fe:	f1 1d       	adc	r31, r1
    fa00:	80 91 65 03 	lds	r24, 0x0365
    fa04:	80 83       	st	Z, r24
		           strResult[iValuePos+1]=0;
    fa06:	11 82       	std	Z+1, r1	; 0x01
				 }//endElse 
				 
			   }//EndAlphaNum

			 if (TypeUI==UI_NUMBER_L){
    fa08:	f2 e0       	ldi	r31, 0x02	; 2
    fa0a:	ff 16       	cp	r15, r31
    fa0c:	71 f4       	brne	.+28     	; 0xfa2a <UserInput+0x24a>
			    if ((NumbValue<=MaxValue)||(MaxValue==0)){
    fa0e:	a0 16       	cp	r10, r16
    fa10:	b1 06       	cpc	r11, r17
    fa12:	18 f4       	brcc	.+6      	; 0xfa1a <UserInput+0x23a>
    fa14:	a1 14       	cp	r10, r1
    fa16:	b1 04       	cpc	r11, r1
    fa18:	71 f5       	brne	.+92     	; 0xfa76 <UserInput+0x296>
				     iValuePos++;
    fa1a:	80 91 68 03 	lds	r24, 0x0368
    fa1e:	8f 5f       	subi	r24, 0xFF	; 255
    fa20:	80 93 68 03 	sts	0x0368, r24
					 stUserInput=uiInputDisp;
    fa24:	83 e0       	ldi	r24, 0x03	; 3
    fa26:	80 93 6b 03 	sts	0x036B, r24
				} 
			 }
  
			   if ((NumbValue<=MaxValue)||(MaxValue==0)){
    fa2a:	a0 16       	cp	r10, r16
    fa2c:	b1 06       	cpc	r11, r17
    fa2e:	18 f4       	brcc	.+6      	; 0xfa36 <UserInput+0x256>
    fa30:	a1 14       	cp	r10, r1
    fa32:	b1 04       	cpc	r11, r1
    fa34:	01 f5       	brne	.+64     	; 0xfa76 <UserInput+0x296>
			       if ((TypeUI==UI_NUMBER_R)||(TypeUI==UI_ALPHANUM_R)||
    fa36:	21 e0       	ldi	r18, 0x01	; 1
    fa38:	f2 16       	cp	r15, r18
    fa3a:	49 f0       	breq	.+18     	; 0xfa4e <UserInput+0x26e>
    fa3c:	83 e0       	ldi	r24, 0x03	; 3
    fa3e:	f8 16       	cp	r15, r24
    fa40:	31 f0       	breq	.+12     	; 0xfa4e <UserInput+0x26e>
    fa42:	e4 e0       	ldi	r30, 0x04	; 4
    fa44:	fe 16       	cp	r15, r30
    fa46:	19 f0       	breq	.+6      	; 0xfa4e <UserInput+0x26e>
    fa48:	f5 e0       	ldi	r31, 0x05	; 5
    fa4a:	ff 16       	cp	r15, r31
    fa4c:	a1 f4       	brne	.+40     	; 0xfa76 <UserInput+0x296>
				       (TypeUI==UI_NUM_PASSWORD)||(TypeUI==UI_ALPHANUM_PASSWORD)){
				      if (IsSameKey==False){
    fa4e:	80 91 61 03 	lds	r24, 0x0361
    fa52:	88 23       	and	r24, r24
    fa54:	69 f4       	brne	.+26     	; 0xfa70 <UserInput+0x290>
					      IsFirst=True;
    fa56:	81 e0       	ldi	r24, 0x01	; 1
    fa58:	80 93 5e 03 	sts	0x035E, r24
					      iValuePos++;
    fa5c:	80 91 68 03 	lds	r24, 0x0368
    fa60:	8f 5f       	subi	r24, 0xFF	; 255
    fa62:	80 93 68 03 	sts	0x0368, r24
						  //FullEntry
						  if (iValuePos==MaxLength)Result=USER_FULL_ENTRY;
					      yChar++;
    fa66:	80 91 69 03 	lds	r24, 0x0369
    fa6a:	8f 5f       	subi	r24, 0xFF	; 255
    fa6c:	80 93 69 03 	sts	0x0369, r24
						  //yChar=(yChar+1;//Max Display

						  }
                  stUserInput=uiInputDisp;
    fa70:	83 e0       	ldi	r24, 0x03	; 3
    fa72:	80 93 6b 03 	sts	0x036B, r24
				  }
			   }
              zKeyChar=KeyChar;
    fa76:	e0 92 67 03 	sts	0x0367, r14
    fa7a:	24 e0       	ldi	r18, 0x04	; 4
    fa7c:	e2 2e       	mov	r14, r18
             Result=USER_ENTRY;
             }//EndKeyChar
			 
                 
              if ((TypeUI==UI_NUMBER_R)||(TypeUI==UI_NUMBER_L)||(TypeUI==UI_NUM_PASSWORD)){
    fa7e:	2f 2d       	mov	r18, r15
    fa80:	21 50       	subi	r18, 0x01	; 1
    fa82:	22 30       	cpi	r18, 0x02	; 2
    fa84:	18 f0       	brcs	.+6      	; 0xfa8c <UserInput+0x2ac>
    fa86:	84 e0       	ldi	r24, 0x04	; 4
    fa88:	f8 16       	cp	r15, r24
    fa8a:	89 f4       	brne	.+34     	; 0xfaae <UserInput+0x2ce>
                   if((NumbValue>MaxValue)||(iValuePos==MaxLength)){
    fa8c:	a0 16       	cp	r10, r16
    fa8e:	b1 06       	cpc	r11, r17
    fa90:	20 f0       	brcs	.+8      	; 0xfa9a <UserInput+0x2ba>
    fa92:	80 91 68 03 	lds	r24, 0x0368
    fa96:	88 15       	cp	r24, r8
    fa98:	51 f4       	brne	.+20     	; 0xfaae <UserInput+0x2ce>
			           if (MaxValue>0)system_beep(1);
    fa9a:	ab 28       	or	r10, r11
    fa9c:	41 f0       	breq	.+16     	; 0xfaae <UserInput+0x2ce>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
    fa9e:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
    faa0:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
    faa2:	81 e0       	ldi	r24, 0x01	; 1
    faa4:	90 e0       	ldi	r25, 0x00	; 0
    faa6:	90 93 d7 01 	sts	0x01D7, r25
    faaa:	80 93 d6 01 	sts	0x01D6, r24
			           if (MaxValue>0)system_beep(1);
				   }
                 }
		  
		  //CANCEL OK
		  if (KeyPressed==_KEY_CANCEL){
    faae:	e7 ee       	ldi	r30, 0xE7	; 231
    fab0:	ce 16       	cp	r12, r30
    fab2:	71 f4       	brne	.+28     	; 0xfad0 <UserInput+0x2f0>
		      if (iValuePos>0){
    fab4:	80 91 68 03 	lds	r24, 0x0368
    fab8:	88 23       	and	r24, r24
    faba:	41 f0       	breq	.+16     	; 0xfacc <UserInput+0x2ec>
			      iLoop=1999;
    fabc:	8f ec       	ldi	r24, 0xCF	; 207
    fabe:	97 e0       	ldi	r25, 0x07	; 7
    fac0:	90 93 5d 03 	sts	0x035D, r25
    fac4:	80 93 5c 03 	sts	0x035C, r24
				  stUserInput=uiClearDisplay;
    fac8:	82 e0       	ldi	r24, 0x02	; 2
    faca:	26 c0       	rjmp	.+76     	; 0xfb18 <UserInput+0x338>
				  }
			  else{
			      UserInputResult=USER_CANCEL;
    facc:	81 e0       	ldi	r24, 0x01	; 1
    face:	21 c0       	rjmp	.+66     	; 0xfb12 <UserInput+0x332>
			      stUserInput=uiFinished;
				  }
		  }
		  else {
		  if (KeyPressed==_KEY_ENTER){
    fad0:	f7 eb       	ldi	r31, 0xB7	; 183
    fad2:	cf 16       	cp	r12, r31
    fad4:	19 f5       	brne	.+70     	; 0xfb1c <UserInput+0x33c>
		      strResult[iValuePos]=0;
    fad6:	80 91 68 03 	lds	r24, 0x0368
    fada:	fe 01       	movw	r30, r28
    fadc:	e8 0f       	add	r30, r24
    fade:	f1 1d       	adc	r31, r1
    fae0:	10 82       	st	Z, r1
			  if ((TypeUI==UI_NUMBER_R)||(TypeUI==UI_NUMBER_L)){
    fae2:	22 30       	cpi	r18, 0x02	; 2
    fae4:	a8 f4       	brcc	.+42     	; 0xfb10 <UserInput+0x330>
			       if (iValuePos==0)sprintf_P(strResult,PSTR("0"));
    fae6:	88 23       	and	r24, r24
    fae8:	81 f4       	brne	.+32     	; 0xfb0a <UserInput+0x32a>
    faea:	00 d0       	rcall	.+0      	; 0xfaec <UserInput+0x30c>
    faec:	00 d0       	rcall	.+0      	; 0xfaee <UserInput+0x30e>
    faee:	ed b7       	in	r30, 0x3d	; 61
    faf0:	fe b7       	in	r31, 0x3e	; 62
    faf2:	d2 83       	std	Z+2, r29	; 0x02
    faf4:	c1 83       	std	Z+1, r28	; 0x01
    faf6:	89 eb       	ldi	r24, 0xB9	; 185
    faf8:	9b e1       	ldi	r25, 0x1B	; 27
    fafa:	94 83       	std	Z+4, r25	; 0x04
    fafc:	83 83       	std	Z+3, r24	; 0x03
    fafe:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    fb02:	0f 90       	pop	r0
    fb04:	0f 90       	pop	r0
    fb06:	0f 90       	pop	r0
    fb08:	0f 90       	pop	r0
			       RemZeroLead(strResult);
    fb0a:	ce 01       	movw	r24, r28
    fb0c:	0e 94 dd 23 	call	0x47ba	; 0x47ba <RemZeroLead>
				  }
		      UserInputResult=USER_OK;
    fb10:	83 e0       	ldi	r24, 0x03	; 3
    fb12:	80 93 6c 03 	sts	0x036C, r24
		      stUserInput=uiFinished;
    fb16:	84 e0       	ldi	r24, 0x04	; 4
    fb18:	80 93 6b 03 	sts	0x036B, r24
			  }
		  }//EndElse

		  if ((iLoop%2000)==0){
    fb1c:	80 91 5c 03 	lds	r24, 0x035C
    fb20:	90 91 5d 03 	lds	r25, 0x035D
    fb24:	60 ed       	ldi	r22, 0xD0	; 208
    fb26:	77 e0       	ldi	r23, 0x07	; 7
    fb28:	0e 94 38 b7 	call	0x16e70	; 0x16e70 <__udivmodhi4>
    fb2c:	89 2b       	or	r24, r25
    fb2e:	09 f0       	breq	.+2      	; 0xfb32 <UserInput+0x352>
    fb30:	4b c0       	rjmp	.+150    	; 0xfbc8 <UserInput+0x3e8>
		      if (IsSameKey==True)
    fb32:	80 91 61 03 	lds	r24, 0x0361
    fb36:	81 30       	cpi	r24, 0x01	; 1
    fb38:	c9 f4       	brne	.+50     	; 0xfb6c <UserInput+0x38c>
			      //lcd_put(xChar,yChar,AlphaChar); 
				  lcd_put(xPos+((yPos+iValuePos-1)/20),yPos+(iValuePos%20),AlphaChar); 
    fb3a:	20 91 68 03 	lds	r18, 0x0368
    fb3e:	82 2f       	mov	r24, r18
    fb40:	90 e0       	ldi	r25, 0x00	; 0
    fb42:	01 97       	sbiw	r24, 0x01	; 1
    fb44:	8d 0d       	add	r24, r13
    fb46:	91 1d       	adc	r25, r1
    fb48:	64 e1       	ldi	r22, 0x14	; 20
    fb4a:	70 e0       	ldi	r23, 0x00	; 0
    fb4c:	0e 94 4c b7 	call	0x16e98	; 0x16e98 <__divmodhi4>
    fb50:	36 2f       	mov	r19, r22
    fb52:	82 2f       	mov	r24, r18
    fb54:	64 e1       	ldi	r22, 0x14	; 20
    fb56:	0e 94 1f b7 	call	0x16e3e	; 0x16e3e <__udivmodqi4>
    fb5a:	6d 2d       	mov	r22, r13
    fb5c:	69 0f       	add	r22, r25
    fb5e:	89 2d       	mov	r24, r9
    fb60:	83 0f       	add	r24, r19
    fb62:	40 91 65 03 	lds	r20, 0x0365
    fb66:	0e 94 7f ad 	call	0x15afe	; 0x15afe <lcd_put>
    fb6a:	2e c0       	rjmp	.+92     	; 0xfbc8 <UserInput+0x3e8>
			  else {
			      if((TypeUI==UI_ALPHANUM_PASSWORD)&&(iValuePos>0))lcd_put(xChar,yChar-1,'*'); 
    fb6c:	f5 e0       	ldi	r31, 0x05	; 5
    fb6e:	ff 16       	cp	r15, r31
    fb70:	61 f4       	brne	.+24     	; 0xfb8a <UserInput+0x3aa>
    fb72:	80 91 68 03 	lds	r24, 0x0368
    fb76:	88 23       	and	r24, r24
    fb78:	41 f0       	breq	.+16     	; 0xfb8a <UserInput+0x3aa>
    fb7a:	60 91 69 03 	lds	r22, 0x0369
    fb7e:	61 50       	subi	r22, 0x01	; 1
    fb80:	80 91 6a 03 	lds	r24, 0x036A
    fb84:	4a e2       	ldi	r20, 0x2A	; 42
    fb86:	0e 94 7f ad 	call	0x15afe	; 0x15afe <lcd_put>
			      //lcd_put(xChar,yChar,'_'); 
				  lcd_put(xPos+((yPos+iValuePos-1)/20),yPos+(iValuePos%20),'_'); 
    fb8a:	20 91 68 03 	lds	r18, 0x0368
    fb8e:	82 2f       	mov	r24, r18
    fb90:	90 e0       	ldi	r25, 0x00	; 0
    fb92:	01 97       	sbiw	r24, 0x01	; 1
    fb94:	8d 0d       	add	r24, r13
    fb96:	91 1d       	adc	r25, r1
    fb98:	64 e1       	ldi	r22, 0x14	; 20
    fb9a:	70 e0       	ldi	r23, 0x00	; 0
    fb9c:	0e 94 4c b7 	call	0x16e98	; 0x16e98 <__divmodhi4>
    fba0:	36 2f       	mov	r19, r22
    fba2:	82 2f       	mov	r24, r18
    fba4:	64 e1       	ldi	r22, 0x14	; 20
    fba6:	0e 94 1f b7 	call	0x16e3e	; 0x16e3e <__udivmodqi4>
    fbaa:	6d 2d       	mov	r22, r13
    fbac:	69 0f       	add	r22, r25
    fbae:	89 2d       	mov	r24, r9
    fbb0:	83 0f       	add	r24, r19
    fbb2:	4f e5       	ldi	r20, 0x5F	; 95
    fbb4:	0e 94 7f ad 	call	0x15afe	; 0x15afe <lcd_put>

				  if (IsFirst==True){
    fbb8:	80 91 5e 03 	lds	r24, 0x035E
    fbbc:	81 30       	cpi	r24, 0x01	; 1
    fbbe:	21 f4       	brne	.+8      	; 0xfbc8 <UserInput+0x3e8>
				      IsFirst=False;
    fbc0:	10 92 5e 03 	sts	0x035E, r1
				      zKeyChar=0;
    fbc4:	10 92 67 03 	sts	0x0367, r1
					  }
				  }
			  }
          if ((iLoop%2000)==1000){
    fbc8:	80 91 5c 03 	lds	r24, 0x035C
    fbcc:	90 91 5d 03 	lds	r25, 0x035D
    fbd0:	60 ed       	ldi	r22, 0xD0	; 208
    fbd2:	77 e0       	ldi	r23, 0x07	; 7
    fbd4:	0e 94 38 b7 	call	0x16e70	; 0x16e70 <__udivmodhi4>
    fbd8:	88 5e       	subi	r24, 0xE8	; 232
    fbda:	93 40       	sbci	r25, 0x03	; 3
    fbdc:	d1 f5       	brne	.+116    	; 0xfc52 <UserInput+0x472>
		      if (IsSameKey==True){
    fbde:	80 91 61 03 	lds	r24, 0x0361
    fbe2:	81 30       	cpi	r24, 0x01	; 1
    fbe4:	f9 f4       	brne	.+62     	; 0xfc24 <UserInput+0x444>
			      if (TypeUI!=UI_NUM_PASSWORD)
    fbe6:	84 e0       	ldi	r24, 0x04	; 4
    fbe8:	f8 16       	cp	r15, r24
    fbea:	b1 f0       	breq	.+44     	; 0xfc18 <UserInput+0x438>
				       //lcd_put(xChar,yChar,AlphaChar); 
					   lcd_put(xPos+((yPos+iValuePos-1)/20),yChar%21,AlphaChar); 
    fbec:	80 91 68 03 	lds	r24, 0x0368
    fbf0:	90 e0       	ldi	r25, 0x00	; 0
    fbf2:	01 97       	sbiw	r24, 0x01	; 1
    fbf4:	8d 0d       	add	r24, r13
    fbf6:	91 1d       	adc	r25, r1
    fbf8:	64 e1       	ldi	r22, 0x14	; 20
    fbfa:	70 e0       	ldi	r23, 0x00	; 0
    fbfc:	0e 94 4c b7 	call	0x16e98	; 0x16e98 <__divmodhi4>
    fc00:	26 2f       	mov	r18, r22
    fc02:	80 91 69 03 	lds	r24, 0x0369
    fc06:	65 e1       	ldi	r22, 0x15	; 21
    fc08:	0e 94 1f b7 	call	0x16e3e	; 0x16e3e <__udivmodqi4>
    fc0c:	89 2d       	mov	r24, r9
    fc0e:	82 0f       	add	r24, r18
    fc10:	69 2f       	mov	r22, r25
    fc12:	40 91 65 03 	lds	r20, 0x0365
    fc16:	1b c0       	rjmp	.+54     	; 0xfc4e <UserInput+0x46e>
					   
				  else lcd_put(xChar,yChar,'*'); 
    fc18:	80 91 6a 03 	lds	r24, 0x036A
    fc1c:	60 91 69 03 	lds	r22, 0x0369
    fc20:	4a e2       	ldi	r20, 0x2A	; 42
    fc22:	15 c0       	rjmp	.+42     	; 0xfc4e <UserInput+0x46e>
			  }
			  //else lcd_put(xChar,yChar,' '); 
			  else lcd_put(xPos+((yPos+iValuePos-1)/20),yPos+(iValuePos%20),' '); 			  
    fc24:	20 91 68 03 	lds	r18, 0x0368
    fc28:	82 2f       	mov	r24, r18
    fc2a:	90 e0       	ldi	r25, 0x00	; 0
    fc2c:	01 97       	sbiw	r24, 0x01	; 1
    fc2e:	8d 0d       	add	r24, r13
    fc30:	91 1d       	adc	r25, r1
    fc32:	64 e1       	ldi	r22, 0x14	; 20
    fc34:	70 e0       	ldi	r23, 0x00	; 0
    fc36:	0e 94 4c b7 	call	0x16e98	; 0x16e98 <__divmodhi4>
    fc3a:	36 2f       	mov	r19, r22
    fc3c:	82 2f       	mov	r24, r18
    fc3e:	64 e1       	ldi	r22, 0x14	; 20
    fc40:	0e 94 1f b7 	call	0x16e3e	; 0x16e3e <__udivmodqi4>
    fc44:	d9 0e       	add	r13, r25
    fc46:	89 2d       	mov	r24, r9
    fc48:	83 0f       	add	r24, r19
    fc4a:	6d 2d       	mov	r22, r13
    fc4c:	40 e2       	ldi	r20, 0x20	; 32
    fc4e:	0e 94 7f ad 	call	0x15afe	; 0x15afe <lcd_put>
			  }
          iLoop++;
    fc52:	80 91 5c 03 	lds	r24, 0x035C
    fc56:	90 91 5d 03 	lds	r25, 0x035D
    fc5a:	01 96       	adiw	r24, 0x01	; 1
    fc5c:	90 93 5d 03 	sts	0x035D, r25
    fc60:	80 93 5c 03 	sts	0x035C, r24
    fc64:	d6 c0       	rjmp	.+428    	; 0xfe12 <UserInput+0x632>
          break;
     case uiClearDisplay:
          if (TypeUI==UI_NUMBER_L){
    fc66:	e2 e0       	ldi	r30, 0x02	; 2
    fc68:	8e 17       	cp	r24, r30
    fc6a:	99 f4       	brne	.+38     	; 0xfc92 <UserInput+0x4b2>
		      lcd_put(xChar,(yChar-iValuePos),' '); // 123_ 1_
    fc6c:	60 91 69 03 	lds	r22, 0x0369
    fc70:	80 91 68 03 	lds	r24, 0x0368
    fc74:	68 1b       	sub	r22, r24
    fc76:	80 91 6a 03 	lds	r24, 0x036A
    fc7a:	40 e2       	ldi	r20, 0x20	; 32
    fc7c:	0e 94 7f ad 	call	0x15afe	; 0x15afe <lcd_put>
		      strResult[iValuePos]=0;
    fc80:	80 91 68 03 	lds	r24, 0x0368
    fc84:	c8 0f       	add	r28, r24
    fc86:	d1 1d       	adc	r29, r1
    fc88:	18 82       	st	Y, r1
		      iValuePos--;
    fc8a:	81 50       	subi	r24, 0x01	; 1
    fc8c:	80 93 68 03 	sts	0x0368, r24
    fc90:	33 c0       	rjmp	.+102    	; 0xfcf8 <UserInput+0x518>
			  }
          else
		  if ((TypeUI==UI_NUMBER_R)||(TypeUI==UI_ALPHANUM_R)||
    fc92:	f1 e0       	ldi	r31, 0x01	; 1
    fc94:	8f 17       	cp	r24, r31
    fc96:	49 f0       	breq	.+18     	; 0xfcaa <UserInput+0x4ca>
    fc98:	23 e0       	ldi	r18, 0x03	; 3
    fc9a:	82 17       	cp	r24, r18
    fc9c:	31 f0       	breq	.+12     	; 0xfcaa <UserInput+0x4ca>
    fc9e:	84 e0       	ldi	r24, 0x04	; 4
    fca0:	f8 16       	cp	r15, r24
    fca2:	19 f0       	breq	.+6      	; 0xfcaa <UserInput+0x4ca>
    fca4:	e5 e0       	ldi	r30, 0x05	; 5
    fca6:	fe 16       	cp	r15, r30
    fca8:	39 f5       	brne	.+78     	; 0xfcf8 <UserInput+0x518>
		      (TypeUI==UI_NUM_PASSWORD)||(TypeUI==UI_ALPHANUM_PASSWORD)){
		      //lcd_put(xChar,yChar,' '); // 123_ 1_
			  lcd_put(xPos+((yPos+iValuePos-1)/20),yPos+(iValuePos%20),' '); // 123_ 1_
    fcaa:	20 91 68 03 	lds	r18, 0x0368
    fcae:	82 2f       	mov	r24, r18
    fcb0:	90 e0       	ldi	r25, 0x00	; 0
    fcb2:	01 97       	sbiw	r24, 0x01	; 1
    fcb4:	8d 0d       	add	r24, r13
    fcb6:	91 1d       	adc	r25, r1
    fcb8:	64 e1       	ldi	r22, 0x14	; 20
    fcba:	70 e0       	ldi	r23, 0x00	; 0
    fcbc:	0e 94 4c b7 	call	0x16e98	; 0x16e98 <__divmodhi4>
    fcc0:	36 2f       	mov	r19, r22
    fcc2:	82 2f       	mov	r24, r18
    fcc4:	64 e1       	ldi	r22, 0x14	; 20
    fcc6:	0e 94 1f b7 	call	0x16e3e	; 0x16e3e <__udivmodqi4>
    fcca:	d9 0e       	add	r13, r25
    fccc:	89 2d       	mov	r24, r9
    fcce:	83 0f       	add	r24, r19
    fcd0:	6d 2d       	mov	r22, r13
    fcd2:	40 e2       	ldi	r20, 0x20	; 32
    fcd4:	0e 94 7f ad 	call	0x15afe	; 0x15afe <lcd_put>
			  
		      strResult[iValuePos]=0;
    fcd8:	80 91 68 03 	lds	r24, 0x0368
    fcdc:	c8 0f       	add	r28, r24
    fcde:	d1 1d       	adc	r29, r1
    fce0:	18 82       	st	Y, r1
		      iValuePos--;
    fce2:	81 50       	subi	r24, 0x01	; 1
    fce4:	80 93 68 03 	sts	0x0368, r24
			  yChar--;
    fce8:	80 91 69 03 	lds	r24, 0x0369
    fcec:	81 50       	subi	r24, 0x01	; 1
    fcee:	80 93 69 03 	sts	0x0369, r24
			  IsDelete=True;
    fcf2:	81 e0       	ldi	r24, 0x01	; 1
    fcf4:	80 93 64 03 	sts	0x0364, r24
		  }
		  if (iValuePos==0)Result=USER_NO_DATA;		  
    fcf8:	80 91 68 03 	lds	r24, 0x0368
    fcfc:	88 23       	and	r24, r24
    fcfe:	19 f4       	brne	.+6      	; 0xfd06 <UserInput+0x526>
    fd00:	95 e0       	ldi	r25, 0x05	; 5
    fd02:	e9 2e       	mov	r14, r25
    fd04:	01 c0       	rjmp	.+2      	; 0xfd08 <UserInput+0x528>
    fd06:	ee 24       	eor	r14, r14
		  stUserInput=uiInputDisp;//Redraw
    fd08:	83 e0       	ldi	r24, 0x03	; 3
    fd0a:	80 93 6b 03 	sts	0x036B, r24
    fd0e:	81 c0       	rjmp	.+258    	; 0xfe12 <UserInput+0x632>
	      break;      
     case uiInputDisp:
	      if(TypeUI==UI_ALPHANUM_PASSWORD){
    fd10:	f5 e0       	ldi	r31, 0x05	; 5
    fd12:	8f 17       	cp	r24, r31
    fd14:	19 f5       	brne	.+70     	; 0xfd5c <UserInput+0x57c>
			  if (iValuePos>0){
    fd16:	80 91 68 03 	lds	r24, 0x0368
    fd1a:	88 23       	and	r24, r24
    fd1c:	a9 f0       	breq	.+42     	; 0xfd48 <UserInput+0x568>
                  lcd_put(xChar,(yChar-2),'*');
    fd1e:	60 91 69 03 	lds	r22, 0x0369
    fd22:	62 50       	subi	r22, 0x02	; 2
    fd24:	80 91 6a 03 	lds	r24, 0x036A
    fd28:	4a e2       	ldi	r20, 0x2A	; 42
    fd2a:	0e 94 7f ad 	call	0x15afe	; 0x15afe <lcd_put>
			      if (IsDelete==True){
    fd2e:	80 91 64 03 	lds	r24, 0x0364
    fd32:	60 91 69 03 	lds	r22, 0x0369
    fd36:	81 30       	cpi	r24, 0x01	; 1
    fd38:	71 f0       	breq	.+28     	; 0xfd56 <UserInput+0x576>
				      IsDelete=False;
			          lcd_put(xChar,(yChar-1),'*');
			          }
				  else lcd_put(xChar,(yChar-1),strResult[iValuePos-1]);
    fd3a:	61 50       	subi	r22, 0x01	; 1
    fd3c:	80 91 68 03 	lds	r24, 0x0368
    fd40:	c8 0f       	add	r28, r24
    fd42:	d1 1d       	adc	r29, r1
    fd44:	21 97       	sbiw	r28, 0x01	; 1
    fd46:	4d c0       	rjmp	.+154    	; 0xfde2 <UserInput+0x602>
			      }
			  else{ if(IsDelete==True){
    fd48:	80 91 64 03 	lds	r24, 0x0364
    fd4c:	60 91 69 03 	lds	r22, 0x0369
    fd50:	81 30       	cpi	r24, 0x01	; 1
    fd52:	09 f0       	breq	.+2      	; 0xfd56 <UserInput+0x576>
    fd54:	45 c0       	rjmp	.+138    	; 0xfde0 <UserInput+0x600>
			           IsDelete=False;
    fd56:	10 92 64 03 	sts	0x0364, r1
    fd5a:	4c c0       	rjmp	.+152    	; 0xfdf4 <UserInput+0x614>
					   lcd_put(xChar,(yChar-1),'*');
			           }
			        else lcd_put(xChar,(yChar-1),strResult[iValuePos]);
			  }
		  }else
	      if (TypeUI==UI_NUMBER_L){
    fd5c:	22 e0       	ldi	r18, 0x02	; 2
    fd5e:	82 17       	cp	r24, r18
    fd60:	a1 f4       	brne	.+40     	; 0xfd8a <UserInput+0x5aa>
    fd62:	10 e0       	ldi	r17, 0x00	; 0
    fd64:	0d c0       	rjmp	.+26     	; 0xfd80 <UserInput+0x5a0>
	          for(iDisp=0;iDisp<iValuePos;iDisp++){
				  lcd_put(xChar,(yChar-(iValuePos-iDisp)),strResult[iDisp]);
    fd66:	60 91 69 03 	lds	r22, 0x0369
    fd6a:	68 1b       	sub	r22, r24
    fd6c:	61 0f       	add	r22, r17
    fd6e:	fe 01       	movw	r30, r28
    fd70:	e1 0f       	add	r30, r17
    fd72:	f1 1d       	adc	r31, r1
    fd74:	80 91 6a 03 	lds	r24, 0x036A
    fd78:	40 81       	ld	r20, Z
    fd7a:	0e 94 7f ad 	call	0x15afe	; 0x15afe <lcd_put>
			           }
			        else lcd_put(xChar,(yChar-1),strResult[iValuePos]);
			  }
		  }else
	      if (TypeUI==UI_NUMBER_L){
	          for(iDisp=0;iDisp<iValuePos;iDisp++){
    fd7e:	1f 5f       	subi	r17, 0xFF	; 255
    fd80:	80 91 68 03 	lds	r24, 0x0368
    fd84:	18 17       	cp	r17, r24
    fd86:	78 f3       	brcs	.-34     	; 0xfd66 <UserInput+0x586>
    fd88:	3b c0       	rjmp	.+118    	; 0xfe00 <UserInput+0x620>
				  lcd_put(xChar,(yChar-(iValuePos-iDisp)),strResult[iDisp]);
		      }
		  }else
	      if ((TypeUI==UI_NUMBER_R)||(TypeUI==UI_ALPHANUM_R)){
    fd8a:	81 e0       	ldi	r24, 0x01	; 1
    fd8c:	f8 16       	cp	r15, r24
    fd8e:	19 f0       	breq	.+6      	; 0xfd96 <UserInput+0x5b6>
    fd90:	e3 e0       	ldi	r30, 0x03	; 3
    fd92:	fe 16       	cp	r15, r30
    fd94:	51 f5       	brne	.+84     	; 0xfdea <UserInput+0x60a>
		      
			  //if (iValuePos>0) lcd_put(xChar,(yChar-1),strResult[iValuePos-1]);
			  if (iValuePos>0) lcd_put(xPos+((yPos+iValuePos-1)/21),yPos+((iValuePos-1)%20),strResult[iValuePos-1]);			  
    fd96:	20 91 68 03 	lds	r18, 0x0368
    fd9a:	4d 2d       	mov	r20, r13
    fd9c:	50 e0       	ldi	r21, 0x00	; 0
    fd9e:	22 23       	and	r18, r18
    fda0:	c1 f0       	breq	.+48     	; 0xfdd2 <UserInput+0x5f2>
    fda2:	30 e0       	ldi	r19, 0x00	; 0
    fda4:	f9 01       	movw	r30, r18
    fda6:	31 97       	sbiw	r30, 0x01	; 1
    fda8:	cf 01       	movw	r24, r30
    fdaa:	84 0f       	add	r24, r20
    fdac:	95 1f       	adc	r25, r21
    fdae:	65 e1       	ldi	r22, 0x15	; 21
    fdb0:	70 e0       	ldi	r23, 0x00	; 0
    fdb2:	0e 94 4c b7 	call	0x16e98	; 0x16e98 <__divmodhi4>
    fdb6:	46 2f       	mov	r20, r22
    fdb8:	cf 01       	movw	r24, r30
    fdba:	64 e1       	ldi	r22, 0x14	; 20
    fdbc:	70 e0       	ldi	r23, 0x00	; 0
    fdbe:	0e 94 4c b7 	call	0x16e98	; 0x16e98 <__divmodhi4>
    fdc2:	d8 0e       	add	r13, r24
    fdc4:	c2 0f       	add	r28, r18
    fdc6:	d3 1f       	adc	r29, r19
    fdc8:	21 97       	sbiw	r28, 0x01	; 1
    fdca:	89 2d       	mov	r24, r9
    fdcc:	84 0f       	add	r24, r20
    fdce:	6d 2d       	mov	r22, r13
    fdd0:	0a c0       	rjmp	.+20     	; 0xfde6 <UserInput+0x606>
			  else{ if ((yChar-1)>=yPos)lcd_put(xChar,(yChar-1),strResult[iValuePos]);
    fdd2:	60 91 69 03 	lds	r22, 0x0369
    fdd6:	86 2f       	mov	r24, r22
    fdd8:	90 e0       	ldi	r25, 0x00	; 0
    fdda:	48 17       	cp	r20, r24
    fddc:	59 07       	cpc	r21, r25
    fdde:	84 f4       	brge	.+32     	; 0xfe00 <UserInput+0x620>
    fde0:	61 50       	subi	r22, 0x01	; 1
    fde2:	80 91 6a 03 	lds	r24, 0x036A
    fde6:	48 81       	ld	r20, Y
    fde8:	09 c0       	rjmp	.+18     	; 0xfdfc <UserInput+0x61c>
			  }
		  }else
		  //DisplayAsterik *
		  if (TypeUI==UI_NUM_PASSWORD){
    fdea:	f4 e0       	ldi	r31, 0x04	; 4
    fdec:	ff 16       	cp	r15, r31
    fdee:	41 f4       	brne	.+16     	; 0xfe00 <UserInput+0x620>
		      lcd_put(xChar,(yChar-1),'*');
    fdf0:	60 91 69 03 	lds	r22, 0x0369
    fdf4:	61 50       	subi	r22, 0x01	; 1
    fdf6:	80 91 6a 03 	lds	r24, 0x036A
    fdfa:	4a e2       	ldi	r20, 0x2A	; 42
    fdfc:	0e 94 7f ad 	call	0x15afe	; 0x15afe <lcd_put>
		  }

          stUserInput=uiInput;
    fe00:	81 e0       	ldi	r24, 0x01	; 1
    fe02:	80 93 6b 03 	sts	0x036B, r24
    fe06:	ee 24       	eor	r14, r14
    fe08:	04 c0       	rjmp	.+8      	; 0xfe12 <UserInput+0x632>
	      break;	 
     case uiFinished:
	      Result=UserInputResult;
    fe0a:	e0 90 6c 03 	lds	r14, 0x036C
	      stUserInput=uiInit;
    fe0e:	10 92 6b 03 	sts	0x036B, r1
	      break;
	 }
	 return Result;
}
    fe12:	8e 2d       	mov	r24, r14
    fe14:	df 91       	pop	r29
    fe16:	cf 91       	pop	r28
    fe18:	1f 91       	pop	r17
    fe1a:	0f 91       	pop	r16
    fe1c:	ff 90       	pop	r15
    fe1e:	ef 90       	pop	r14
    fe20:	df 90       	pop	r13
    fe22:	cf 90       	pop	r12
    fe24:	bf 90       	pop	r11
    fe26:	af 90       	pop	r10
    fe28:	9f 90       	pop	r9
    fe2a:	8f 90       	pop	r8
    fe2c:	08 95       	ret

0000fe2e <TestUserInput>:
    //sprintf_P(strSend,PSTR("Pos:%d"),*Pos);
	//_uart_print(0,1,strSend);
}


char TestUserInput(){
    fe2e:	6f 92       	push	r6
    fe30:	7f 92       	push	r7
    fe32:	8f 92       	push	r8
    fe34:	9f 92       	push	r9
    fe36:	af 92       	push	r10
    fe38:	bf 92       	push	r11
    fe3a:	cf 92       	push	r12
    fe3c:	df 92       	push	r13
    fe3e:	ef 92       	push	r14
    fe40:	ff 92       	push	r15
    fe42:	0f 93       	push	r16
    fe44:	1f 93       	push	r17
    fe46:	df 93       	push	r29
    fe48:	cf 93       	push	r28
    fe4a:	cd b7       	in	r28, 0x3d	; 61
    fe4c:	de b7       	in	r29, 0x3e	; 62
    fe4e:	ce 56       	subi	r28, 0x6E	; 110
    fe50:	d0 40       	sbci	r29, 0x00	; 0
    fe52:	0f b6       	in	r0, 0x3f	; 63
    fe54:	f8 94       	cli
    fe56:	de bf       	out	0x3e, r29	; 62
    fe58:	0f be       	out	0x3f, r0	; 63
    fe5a:	cd bf       	out	0x3d, r28	; 61
char lcdteks[20],strSend[30];
char SVolume[15],SMoney[15],STotalVolume[15],STotalMoney[15];
char Result;

char uiResult;
	uiResult=UserInput(UI_ALPHANUM_R,2,1,strNumber,0,10);
    fe5c:	e3 ef       	ldi	r30, 0xF3	; 243
    fe5e:	6e 2e       	mov	r6, r30
    fe60:	e1 e0       	ldi	r30, 0x01	; 1
    fe62:	7e 2e       	mov	r7, r30
    fe64:	83 e0       	ldi	r24, 0x03	; 3
    fe66:	62 e0       	ldi	r22, 0x02	; 2
    fe68:	41 e0       	ldi	r20, 0x01	; 1
    fe6a:	93 01       	movw	r18, r6
    fe6c:	00 e0       	ldi	r16, 0x00	; 0
    fe6e:	10 e0       	ldi	r17, 0x00	; 0
    fe70:	7a e0       	ldi	r23, 0x0A	; 10
    fe72:	e7 2e       	mov	r14, r23
    fe74:	0e 94 f0 7b 	call	0xf7e0	; 0xf7e0 <UserInput>
	Result=MENU_NONE;
    if (uiResult==USER_OK){
    fe78:	83 30       	cpi	r24, 0x03	; 3
    fe7a:	09 f0       	breq	.+2      	; 0xfe7e <TestUserInput+0x50>
    fe7c:	ed c1       	rjmp	.+986    	; 0x10258 <TestUserInput+0x42a>
	    sprintf_P(lcdteks,PSTR("Data:%s"),strNumber);
    fe7e:	00 d0       	rcall	.+0      	; 0xfe80 <TestUserInput+0x52>
    fe80:	00 d0       	rcall	.+0      	; 0xfe82 <TestUserInput+0x54>
    fe82:	00 d0       	rcall	.+0      	; 0xfe84 <TestUserInput+0x56>
    fe84:	ed b7       	in	r30, 0x3d	; 61
    fe86:	fe b7       	in	r31, 0x3e	; 62
    fe88:	31 96       	adiw	r30, 0x01	; 1
    fe8a:	8e 01       	movw	r16, r28
    fe8c:	03 5c       	subi	r16, 0xC3	; 195
    fe8e:	1f 4f       	sbci	r17, 0xFF	; 255
    fe90:	ad b7       	in	r26, 0x3d	; 61
    fe92:	be b7       	in	r27, 0x3e	; 62
    fe94:	12 96       	adiw	r26, 0x02	; 2
    fe96:	1c 93       	st	X, r17
    fe98:	0e 93       	st	-X, r16
    fe9a:	11 97       	sbiw	r26, 0x01	; 1
    fe9c:	8d ee       	ldi	r24, 0xED	; 237
    fe9e:	93 e0       	ldi	r25, 0x03	; 3
    fea0:	93 83       	std	Z+3, r25	; 0x03
    fea2:	82 83       	std	Z+2, r24	; 0x02
    fea4:	75 82       	std	Z+5, r7	; 0x05
    fea6:	64 82       	std	Z+4, r6	; 0x04
    fea8:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
	   lcd_print(3,1,lcdteks);
    feac:	8d b7       	in	r24, 0x3d	; 61
    feae:	9e b7       	in	r25, 0x3e	; 62
    feb0:	06 96       	adiw	r24, 0x06	; 6
    feb2:	0f b6       	in	r0, 0x3f	; 63
    feb4:	f8 94       	cli
    feb6:	9e bf       	out	0x3e, r25	; 62
    feb8:	0f be       	out	0x3f, r0	; 63
    feba:	8d bf       	out	0x3d, r24	; 61
    febc:	83 e0       	ldi	r24, 0x03	; 3
    febe:	61 e0       	ldi	r22, 0x01	; 1
    fec0:	a8 01       	movw	r20, r16
    fec2:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
	   //FormatCurrency(strNumber);
	   //FormatMoney(strNumber);
	   //RemZeroLead(strNumber);
	   sprintf_P(SVolume,PSTR("%s"),strNumber);
    fec6:	00 d0       	rcall	.+0      	; 0xfec8 <TestUserInput+0x9a>
    fec8:	00 d0       	rcall	.+0      	; 0xfeca <TestUserInput+0x9c>
    feca:	00 d0       	rcall	.+0      	; 0xfecc <TestUserInput+0x9e>
    fecc:	ed b7       	in	r30, 0x3d	; 61
    fece:	fe b7       	in	r31, 0x3e	; 62
    fed0:	31 96       	adiw	r30, 0x01	; 1
    fed2:	7e 01       	movw	r14, r28
    fed4:	08 94       	sec
    fed6:	e1 1c       	adc	r14, r1
    fed8:	f1 1c       	adc	r15, r1
    feda:	ad b7       	in	r26, 0x3d	; 61
    fedc:	be b7       	in	r27, 0x3e	; 62
    fede:	12 96       	adiw	r26, 0x02	; 2
    fee0:	fc 92       	st	X, r15
    fee2:	ee 92       	st	-X, r14
    fee4:	11 97       	sbiw	r26, 0x01	; 1
    fee6:	8a ee       	ldi	r24, 0xEA	; 234
    fee8:	93 e0       	ldi	r25, 0x03	; 3
    feea:	93 83       	std	Z+3, r25	; 0x03
    feec:	82 83       	std	Z+2, r24	; 0x02
    feee:	75 82       	std	Z+5, r7	; 0x05
    fef0:	64 82       	std	Z+4, r6	; 0x04
    fef2:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
	   sprintf_P(SMoney,PSTR("%s"),strNumber);
    fef6:	ed b7       	in	r30, 0x3d	; 61
    fef8:	fe b7       	in	r31, 0x3e	; 62
    fefa:	31 96       	adiw	r30, 0x01	; 1
    fefc:	60 e1       	ldi	r22, 0x10	; 16
    fefe:	a6 2e       	mov	r10, r22
    ff00:	b1 2c       	mov	r11, r1
    ff02:	ac 0e       	add	r10, r28
    ff04:	bd 1e       	adc	r11, r29
    ff06:	ad b7       	in	r26, 0x3d	; 61
    ff08:	be b7       	in	r27, 0x3e	; 62
    ff0a:	12 96       	adiw	r26, 0x02	; 2
    ff0c:	bc 92       	st	X, r11
    ff0e:	ae 92       	st	-X, r10
    ff10:	11 97       	sbiw	r26, 0x01	; 1
    ff12:	87 ee       	ldi	r24, 0xE7	; 231
    ff14:	93 e0       	ldi	r25, 0x03	; 3
    ff16:	93 83       	std	Z+3, r25	; 0x03
    ff18:	82 83       	std	Z+2, r24	; 0x02
    ff1a:	75 82       	std	Z+5, r7	; 0x05
    ff1c:	64 82       	std	Z+4, r6	; 0x04
    ff1e:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
	   sprintf_P(STotalVolume,PSTR("%s"),strNumber);
    ff22:	ed b7       	in	r30, 0x3d	; 61
    ff24:	fe b7       	in	r31, 0x3e	; 62
    ff26:	31 96       	adiw	r30, 0x01	; 1
    ff28:	5f e1       	ldi	r21, 0x1F	; 31
    ff2a:	85 2e       	mov	r8, r21
    ff2c:	91 2c       	mov	r9, r1
    ff2e:	8c 0e       	add	r8, r28
    ff30:	9d 1e       	adc	r9, r29
    ff32:	ad b7       	in	r26, 0x3d	; 61
    ff34:	be b7       	in	r27, 0x3e	; 62
    ff36:	12 96       	adiw	r26, 0x02	; 2
    ff38:	9c 92       	st	X, r9
    ff3a:	8e 92       	st	-X, r8
    ff3c:	11 97       	sbiw	r26, 0x01	; 1
    ff3e:	84 ee       	ldi	r24, 0xE4	; 228
    ff40:	93 e0       	ldi	r25, 0x03	; 3
    ff42:	93 83       	std	Z+3, r25	; 0x03
    ff44:	82 83       	std	Z+2, r24	; 0x02
    ff46:	75 82       	std	Z+5, r7	; 0x05
    ff48:	64 82       	std	Z+4, r6	; 0x04
    ff4a:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
	   sprintf_P(STotalMoney,PSTR("%s"),strNumber);
    ff4e:	ed b7       	in	r30, 0x3d	; 61
    ff50:	fe b7       	in	r31, 0x3e	; 62
    ff52:	31 96       	adiw	r30, 0x01	; 1
    ff54:	4e e2       	ldi	r20, 0x2E	; 46
    ff56:	c4 2e       	mov	r12, r20
    ff58:	d1 2c       	mov	r13, r1
    ff5a:	cc 0e       	add	r12, r28
    ff5c:	dd 1e       	adc	r13, r29
    ff5e:	ad b7       	in	r26, 0x3d	; 61
    ff60:	be b7       	in	r27, 0x3e	; 62
    ff62:	12 96       	adiw	r26, 0x02	; 2
    ff64:	dc 92       	st	X, r13
    ff66:	ce 92       	st	-X, r12
    ff68:	11 97       	sbiw	r26, 0x01	; 1
    ff6a:	81 ee       	ldi	r24, 0xE1	; 225
    ff6c:	93 e0       	ldi	r25, 0x03	; 3
    ff6e:	93 83       	std	Z+3, r25	; 0x03
    ff70:	82 83       	std	Z+2, r24	; 0x02
    ff72:	75 82       	std	Z+5, r7	; 0x05
    ff74:	64 82       	std	Z+4, r6	; 0x04
    ff76:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>

	   sprintf_P(lcdteks,PSTR("Formated:%s"),strNumber);
    ff7a:	ed b7       	in	r30, 0x3d	; 61
    ff7c:	fe b7       	in	r31, 0x3e	; 62
    ff7e:	31 96       	adiw	r30, 0x01	; 1
    ff80:	ad b7       	in	r26, 0x3d	; 61
    ff82:	be b7       	in	r27, 0x3e	; 62
    ff84:	12 96       	adiw	r26, 0x02	; 2
    ff86:	1c 93       	st	X, r17
    ff88:	0e 93       	st	-X, r16
    ff8a:	11 97       	sbiw	r26, 0x01	; 1
    ff8c:	85 ed       	ldi	r24, 0xD5	; 213
    ff8e:	93 e0       	ldi	r25, 0x03	; 3
    ff90:	93 83       	std	Z+3, r25	; 0x03
    ff92:	82 83       	std	Z+2, r24	; 0x02
    ff94:	75 82       	std	Z+5, r7	; 0x05
    ff96:	64 82       	std	Z+4, r6	; 0x04
    ff98:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
       lcd_print(4,1,lcdteks);
    ff9c:	8d b7       	in	r24, 0x3d	; 61
    ff9e:	9e b7       	in	r25, 0x3e	; 62
    ffa0:	06 96       	adiw	r24, 0x06	; 6
    ffa2:	0f b6       	in	r0, 0x3f	; 63
    ffa4:	f8 94       	cli
    ffa6:	9e bf       	out	0x3e, r25	; 62
    ffa8:	0f be       	out	0x3f, r0	; 63
    ffaa:	8d bf       	out	0x3d, r24	; 61
    ffac:	84 e0       	ldi	r24, 0x04	; 4
    ffae:	61 e0       	ldi	r22, 0x01	; 1
    ffb0:	a8 01       	movw	r20, r16
    ffb2:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
	   sprintf_P(strSend,PSTR("Raw:%s"),strNumber);
    ffb6:	00 d0       	rcall	.+0      	; 0xffb8 <TestUserInput+0x18a>
    ffb8:	00 d0       	rcall	.+0      	; 0xffba <TestUserInput+0x18c>
    ffba:	00 d0       	rcall	.+0      	; 0xffbc <TestUserInput+0x18e>
    ffbc:	ed b7       	in	r30, 0x3d	; 61
    ffbe:	fe b7       	in	r31, 0x3e	; 62
    ffc0:	31 96       	adiw	r30, 0x01	; 1
    ffc2:	8e 01       	movw	r16, r28
    ffc4:	0f 5a       	subi	r16, 0xAF	; 175
    ffc6:	1f 4f       	sbci	r17, 0xFF	; 255
    ffc8:	ad b7       	in	r26, 0x3d	; 61
    ffca:	be b7       	in	r27, 0x3e	; 62
    ffcc:	12 96       	adiw	r26, 0x02	; 2
    ffce:	1c 93       	st	X, r17
    ffd0:	0e 93       	st	-X, r16
    ffd2:	11 97       	sbiw	r26, 0x01	; 1
    ffd4:	8e ec       	ldi	r24, 0xCE	; 206
    ffd6:	93 e0       	ldi	r25, 0x03	; 3
    ffd8:	93 83       	std	Z+3, r25	; 0x03
    ffda:	82 83       	std	Z+2, r24	; 0x02
    ffdc:	75 82       	std	Z+5, r7	; 0x05
    ffde:	64 82       	std	Z+4, r6	; 0x04
    ffe0:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
	   _uart_print(0,1,strSend);
    ffe4:	8d b7       	in	r24, 0x3d	; 61
    ffe6:	9e b7       	in	r25, 0x3e	; 62
    ffe8:	06 96       	adiw	r24, 0x06	; 6
    ffea:	0f b6       	in	r0, 0x3f	; 63
    ffec:	f8 94       	cli
    ffee:	9e bf       	out	0x3e, r25	; 62
    fff0:	0f be       	out	0x3f, r0	; 63
    fff2:	8d bf       	out	0x3d, r24	; 61
    fff4:	80 e0       	ldi	r24, 0x00	; 0
    fff6:	61 e0       	ldi	r22, 0x01	; 1
    fff8:	a8 01       	movw	r20, r16
    fffa:	0e 94 97 b2 	call	0x1652e	; 0x1652e <_uart_print>

	   RemoveMinus(strNumber);
    fffe:	c3 01       	movw	r24, r6
   10000:	0e 94 17 22 	call	0x442e	; 0x442e <RemoveMinus>

	   sprintf_P(strSend,PSTR("Minus:%s"),strNumber);
   10004:	00 d0       	rcall	.+0      	; 0x10006 <TestUserInput+0x1d8>
   10006:	00 d0       	rcall	.+0      	; 0x10008 <TestUserInput+0x1da>
   10008:	00 d0       	rcall	.+0      	; 0x1000a <TestUserInput+0x1dc>
   1000a:	ed b7       	in	r30, 0x3d	; 61
   1000c:	fe b7       	in	r31, 0x3e	; 62
   1000e:	31 96       	adiw	r30, 0x01	; 1
   10010:	ad b7       	in	r26, 0x3d	; 61
   10012:	be b7       	in	r27, 0x3e	; 62
   10014:	12 96       	adiw	r26, 0x02	; 2
   10016:	1c 93       	st	X, r17
   10018:	0e 93       	st	-X, r16
   1001a:	11 97       	sbiw	r26, 0x01	; 1
   1001c:	85 ec       	ldi	r24, 0xC5	; 197
   1001e:	93 e0       	ldi	r25, 0x03	; 3
   10020:	93 83       	std	Z+3, r25	; 0x03
   10022:	82 83       	std	Z+2, r24	; 0x02
   10024:	75 82       	std	Z+5, r7	; 0x05
   10026:	64 82       	std	Z+4, r6	; 0x04
   10028:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
	   _uart_print(0,1,strSend);
   1002c:	8d b7       	in	r24, 0x3d	; 61
   1002e:	9e b7       	in	r25, 0x3e	; 62
   10030:	06 96       	adiw	r24, 0x06	; 6
   10032:	0f b6       	in	r0, 0x3f	; 63
   10034:	f8 94       	cli
   10036:	9e bf       	out	0x3e, r25	; 62
   10038:	0f be       	out	0x3f, r0	; 63
   1003a:	8d bf       	out	0x3d, r24	; 61
   1003c:	80 e0       	ldi	r24, 0x00	; 0
   1003e:	61 e0       	ldi	r22, 0x01	; 1
   10040:	a8 01       	movw	r20, r16
   10042:	0e 94 97 b2 	call	0x1652e	; 0x1652e <_uart_print>

       
	   RemZeroLead(strNumber);
   10046:	c3 01       	movw	r24, r6
   10048:	0e 94 dd 23 	call	0x47ba	; 0x47ba <RemZeroLead>
	   sprintf_P(strSend,PSTR("Removed:%s"),strNumber);
   1004c:	00 d0       	rcall	.+0      	; 0x1004e <TestUserInput+0x220>
   1004e:	00 d0       	rcall	.+0      	; 0x10050 <TestUserInput+0x222>
   10050:	00 d0       	rcall	.+0      	; 0x10052 <TestUserInput+0x224>
   10052:	ed b7       	in	r30, 0x3d	; 61
   10054:	fe b7       	in	r31, 0x3e	; 62
   10056:	31 96       	adiw	r30, 0x01	; 1
   10058:	ad b7       	in	r26, 0x3d	; 61
   1005a:	be b7       	in	r27, 0x3e	; 62
   1005c:	12 96       	adiw	r26, 0x02	; 2
   1005e:	1c 93       	st	X, r17
   10060:	0e 93       	st	-X, r16
   10062:	11 97       	sbiw	r26, 0x01	; 1
   10064:	8a eb       	ldi	r24, 0xBA	; 186
   10066:	93 e0       	ldi	r25, 0x03	; 3
   10068:	93 83       	std	Z+3, r25	; 0x03
   1006a:	82 83       	std	Z+2, r24	; 0x02
   1006c:	75 82       	std	Z+5, r7	; 0x05
   1006e:	64 82       	std	Z+4, r6	; 0x04
   10070:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
	   _uart_print(0,1,strSend);
   10074:	8d b7       	in	r24, 0x3d	; 61
   10076:	9e b7       	in	r25, 0x3e	; 62
   10078:	06 96       	adiw	r24, 0x06	; 6
   1007a:	0f b6       	in	r0, 0x3f	; 63
   1007c:	f8 94       	cli
   1007e:	9e bf       	out	0x3e, r25	; 62
   10080:	0f be       	out	0x3f, r0	; 63
   10082:	8d bf       	out	0x3d, r24	; 61
   10084:	80 e0       	ldi	r24, 0x00	; 0
   10086:	61 e0       	ldi	r22, 0x01	; 1
   10088:	a8 01       	movw	r20, r16
   1008a:	0e 94 97 b2 	call	0x1652e	; 0x1652e <_uart_print>

RemZeroLead(SVolume);
   1008e:	c7 01       	movw	r24, r14
   10090:	0e 94 dd 23 	call	0x47ba	; 0x47ba <RemZeroLead>
RemZeroLead(SMoney);
   10094:	c5 01       	movw	r24, r10
   10096:	0e 94 dd 23 	call	0x47ba	; 0x47ba <RemZeroLead>
RemZeroLead(STotalVolume);
   1009a:	c4 01       	movw	r24, r8
   1009c:	0e 94 dd 23 	call	0x47ba	; 0x47ba <RemZeroLead>
RemZeroLead(STotalMoney);
   100a0:	c6 01       	movw	r24, r12
   100a2:	0e 94 dd 23 	call	0x47ba	; 0x47ba <RemZeroLead>
       
	   
	   FormatVolume(SVolume); 
   100a6:	c7 01       	movw	r24, r14
   100a8:	0e 94 93 31 	call	0x6326	; 0x6326 <FormatVolume>
	   FormatMoney(SMoney);
   100ac:	c5 01       	movw	r24, r10
   100ae:	0e 94 a0 31 	call	0x6340	; 0x6340 <FormatMoney>
	   FormatTotalizerMoney(STotalVolume);
   100b2:	c4 01       	movw	r24, r8
   100b4:	0e 94 86 31 	call	0x630c	; 0x630c <FormatTotalizerMoney>
	   FormatTotalizerVolume(STotalMoney);
   100b8:	c6 01       	movw	r24, r12
   100ba:	0e 94 79 31 	call	0x62f2	; 0x62f2 <FormatTotalizerVolume>

	   sprintf_P(strSend,PSTR("Volume:%s"),SVolume);
   100be:	00 d0       	rcall	.+0      	; 0x100c0 <TestUserInput+0x292>
   100c0:	00 d0       	rcall	.+0      	; 0x100c2 <TestUserInput+0x294>
   100c2:	00 d0       	rcall	.+0      	; 0x100c4 <TestUserInput+0x296>
   100c4:	ed b7       	in	r30, 0x3d	; 61
   100c6:	fe b7       	in	r31, 0x3e	; 62
   100c8:	31 96       	adiw	r30, 0x01	; 1
   100ca:	ad b7       	in	r26, 0x3d	; 61
   100cc:	be b7       	in	r27, 0x3e	; 62
   100ce:	12 96       	adiw	r26, 0x02	; 2
   100d0:	1c 93       	st	X, r17
   100d2:	0e 93       	st	-X, r16
   100d4:	11 97       	sbiw	r26, 0x01	; 1
   100d6:	80 eb       	ldi	r24, 0xB0	; 176
   100d8:	93 e0       	ldi	r25, 0x03	; 3
   100da:	93 83       	std	Z+3, r25	; 0x03
   100dc:	82 83       	std	Z+2, r24	; 0x02
   100de:	f5 82       	std	Z+5, r15	; 0x05
   100e0:	e4 82       	std	Z+4, r14	; 0x04
   100e2:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
	   _uart_print(0,1,strSend);
   100e6:	8d b7       	in	r24, 0x3d	; 61
   100e8:	9e b7       	in	r25, 0x3e	; 62
   100ea:	06 96       	adiw	r24, 0x06	; 6
   100ec:	0f b6       	in	r0, 0x3f	; 63
   100ee:	f8 94       	cli
   100f0:	9e bf       	out	0x3e, r25	; 62
   100f2:	0f be       	out	0x3f, r0	; 63
   100f4:	8d bf       	out	0x3d, r24	; 61
   100f6:	80 e0       	ldi	r24, 0x00	; 0
   100f8:	61 e0       	ldi	r22, 0x01	; 1
   100fa:	a8 01       	movw	r20, r16
   100fc:	0e 94 97 b2 	call	0x1652e	; 0x1652e <_uart_print>
	   sprintf_P(strSend,PSTR("Money:%s"),SMoney);
   10100:	00 d0       	rcall	.+0      	; 0x10102 <TestUserInput+0x2d4>
   10102:	00 d0       	rcall	.+0      	; 0x10104 <TestUserInput+0x2d6>
   10104:	00 d0       	rcall	.+0      	; 0x10106 <TestUserInput+0x2d8>
   10106:	ed b7       	in	r30, 0x3d	; 61
   10108:	fe b7       	in	r31, 0x3e	; 62
   1010a:	31 96       	adiw	r30, 0x01	; 1
   1010c:	ad b7       	in	r26, 0x3d	; 61
   1010e:	be b7       	in	r27, 0x3e	; 62
   10110:	12 96       	adiw	r26, 0x02	; 2
   10112:	1c 93       	st	X, r17
   10114:	0e 93       	st	-X, r16
   10116:	11 97       	sbiw	r26, 0x01	; 1
   10118:	87 ea       	ldi	r24, 0xA7	; 167
   1011a:	93 e0       	ldi	r25, 0x03	; 3
   1011c:	93 83       	std	Z+3, r25	; 0x03
   1011e:	82 83       	std	Z+2, r24	; 0x02
   10120:	b5 82       	std	Z+5, r11	; 0x05
   10122:	a4 82       	std	Z+4, r10	; 0x04
   10124:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
	   _uart_print(0,1,strSend);
   10128:	8d b7       	in	r24, 0x3d	; 61
   1012a:	9e b7       	in	r25, 0x3e	; 62
   1012c:	06 96       	adiw	r24, 0x06	; 6
   1012e:	0f b6       	in	r0, 0x3f	; 63
   10130:	f8 94       	cli
   10132:	9e bf       	out	0x3e, r25	; 62
   10134:	0f be       	out	0x3f, r0	; 63
   10136:	8d bf       	out	0x3d, r24	; 61
   10138:	80 e0       	ldi	r24, 0x00	; 0
   1013a:	61 e0       	ldi	r22, 0x01	; 1
   1013c:	a8 01       	movw	r20, r16
   1013e:	0e 94 97 b2 	call	0x1652e	; 0x1652e <_uart_print>
	   sprintf_P(strSend,PSTR("TVolume:%s"),STotalVolume);
   10142:	00 d0       	rcall	.+0      	; 0x10144 <TestUserInput+0x316>
   10144:	00 d0       	rcall	.+0      	; 0x10146 <TestUserInput+0x318>
   10146:	00 d0       	rcall	.+0      	; 0x10148 <TestUserInput+0x31a>
   10148:	ed b7       	in	r30, 0x3d	; 61
   1014a:	fe b7       	in	r31, 0x3e	; 62
   1014c:	31 96       	adiw	r30, 0x01	; 1
   1014e:	ad b7       	in	r26, 0x3d	; 61
   10150:	be b7       	in	r27, 0x3e	; 62
   10152:	12 96       	adiw	r26, 0x02	; 2
   10154:	1c 93       	st	X, r17
   10156:	0e 93       	st	-X, r16
   10158:	11 97       	sbiw	r26, 0x01	; 1
   1015a:	8c e9       	ldi	r24, 0x9C	; 156
   1015c:	93 e0       	ldi	r25, 0x03	; 3
   1015e:	93 83       	std	Z+3, r25	; 0x03
   10160:	82 83       	std	Z+2, r24	; 0x02
   10162:	95 82       	std	Z+5, r9	; 0x05
   10164:	84 82       	std	Z+4, r8	; 0x04
   10166:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
	   _uart_print(0,1,strSend);
   1016a:	8d b7       	in	r24, 0x3d	; 61
   1016c:	9e b7       	in	r25, 0x3e	; 62
   1016e:	06 96       	adiw	r24, 0x06	; 6
   10170:	0f b6       	in	r0, 0x3f	; 63
   10172:	f8 94       	cli
   10174:	9e bf       	out	0x3e, r25	; 62
   10176:	0f be       	out	0x3f, r0	; 63
   10178:	8d bf       	out	0x3d, r24	; 61
   1017a:	80 e0       	ldi	r24, 0x00	; 0
   1017c:	61 e0       	ldi	r22, 0x01	; 1
   1017e:	a8 01       	movw	r20, r16
   10180:	0e 94 97 b2 	call	0x1652e	; 0x1652e <_uart_print>
	   sprintf_P(strSend,PSTR("TMoney:%s"),STotalMoney);
   10184:	00 d0       	rcall	.+0      	; 0x10186 <TestUserInput+0x358>
   10186:	00 d0       	rcall	.+0      	; 0x10188 <TestUserInput+0x35a>
   10188:	00 d0       	rcall	.+0      	; 0x1018a <TestUserInput+0x35c>
   1018a:	ed b7       	in	r30, 0x3d	; 61
   1018c:	fe b7       	in	r31, 0x3e	; 62
   1018e:	31 96       	adiw	r30, 0x01	; 1
   10190:	ad b7       	in	r26, 0x3d	; 61
   10192:	be b7       	in	r27, 0x3e	; 62
   10194:	12 96       	adiw	r26, 0x02	; 2
   10196:	1c 93       	st	X, r17
   10198:	0e 93       	st	-X, r16
   1019a:	11 97       	sbiw	r26, 0x01	; 1
   1019c:	82 e9       	ldi	r24, 0x92	; 146
   1019e:	93 e0       	ldi	r25, 0x03	; 3
   101a0:	93 83       	std	Z+3, r25	; 0x03
   101a2:	82 83       	std	Z+2, r24	; 0x02
   101a4:	d5 82       	std	Z+5, r13	; 0x05
   101a6:	c4 82       	std	Z+4, r12	; 0x04
   101a8:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
	   _uart_print(0,1,strSend);
   101ac:	8d b7       	in	r24, 0x3d	; 61
   101ae:	9e b7       	in	r25, 0x3e	; 62
   101b0:	06 96       	adiw	r24, 0x06	; 6
   101b2:	0f b6       	in	r0, 0x3f	; 63
   101b4:	f8 94       	cli
   101b6:	9e bf       	out	0x3e, r25	; 62
   101b8:	0f be       	out	0x3f, r0	; 63
   101ba:	8d bf       	out	0x3d, r24	; 61
   101bc:	80 e0       	ldi	r24, 0x00	; 0
   101be:	61 e0       	ldi	r22, 0x01	; 1
   101c0:	a8 01       	movw	r20, r16
   101c2:	0e 94 97 b2 	call	0x1652e	; 0x1652e <_uart_print>

	   FormatCurrency(SMoney);
   101c6:	c5 01       	movw	r24, r10
   101c8:	0e 94 49 30 	call	0x6092	; 0x6092 <FormatCurrency>
	   FormatCurrency(STotalMoney);
   101cc:	c6 01       	movw	r24, r12
   101ce:	0e 94 49 30 	call	0x6092	; 0x6092 <FormatCurrency>
    
	   sprintf_P(strSend,PSTR("FmtMoney:%s"),SMoney);
   101d2:	00 d0       	rcall	.+0      	; 0x101d4 <TestUserInput+0x3a6>
   101d4:	00 d0       	rcall	.+0      	; 0x101d6 <TestUserInput+0x3a8>
   101d6:	00 d0       	rcall	.+0      	; 0x101d8 <TestUserInput+0x3aa>
   101d8:	ed b7       	in	r30, 0x3d	; 61
   101da:	fe b7       	in	r31, 0x3e	; 62
   101dc:	31 96       	adiw	r30, 0x01	; 1
   101de:	ad b7       	in	r26, 0x3d	; 61
   101e0:	be b7       	in	r27, 0x3e	; 62
   101e2:	12 96       	adiw	r26, 0x02	; 2
   101e4:	1c 93       	st	X, r17
   101e6:	0e 93       	st	-X, r16
   101e8:	11 97       	sbiw	r26, 0x01	; 1
   101ea:	86 e8       	ldi	r24, 0x86	; 134
   101ec:	93 e0       	ldi	r25, 0x03	; 3
   101ee:	93 83       	std	Z+3, r25	; 0x03
   101f0:	82 83       	std	Z+2, r24	; 0x02
   101f2:	b5 82       	std	Z+5, r11	; 0x05
   101f4:	a4 82       	std	Z+4, r10	; 0x04
   101f6:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
	   _uart_print(0,1,strSend);
   101fa:	8d b7       	in	r24, 0x3d	; 61
   101fc:	9e b7       	in	r25, 0x3e	; 62
   101fe:	06 96       	adiw	r24, 0x06	; 6
   10200:	0f b6       	in	r0, 0x3f	; 63
   10202:	f8 94       	cli
   10204:	9e bf       	out	0x3e, r25	; 62
   10206:	0f be       	out	0x3f, r0	; 63
   10208:	8d bf       	out	0x3d, r24	; 61
   1020a:	80 e0       	ldi	r24, 0x00	; 0
   1020c:	61 e0       	ldi	r22, 0x01	; 1
   1020e:	a8 01       	movw	r20, r16
   10210:	0e 94 97 b2 	call	0x1652e	; 0x1652e <_uart_print>
	   sprintf_P(strSend,PSTR("FmtTMoney:%s"),STotalMoney);
   10214:	00 d0       	rcall	.+0      	; 0x10216 <TestUserInput+0x3e8>
   10216:	00 d0       	rcall	.+0      	; 0x10218 <TestUserInput+0x3ea>
   10218:	00 d0       	rcall	.+0      	; 0x1021a <TestUserInput+0x3ec>
   1021a:	ed b7       	in	r30, 0x3d	; 61
   1021c:	fe b7       	in	r31, 0x3e	; 62
   1021e:	31 96       	adiw	r30, 0x01	; 1
   10220:	ad b7       	in	r26, 0x3d	; 61
   10222:	be b7       	in	r27, 0x3e	; 62
   10224:	12 96       	adiw	r26, 0x02	; 2
   10226:	1c 93       	st	X, r17
   10228:	0e 93       	st	-X, r16
   1022a:	11 97       	sbiw	r26, 0x01	; 1
   1022c:	89 e7       	ldi	r24, 0x79	; 121
   1022e:	93 e0       	ldi	r25, 0x03	; 3
   10230:	93 83       	std	Z+3, r25	; 0x03
   10232:	82 83       	std	Z+2, r24	; 0x02
   10234:	d5 82       	std	Z+5, r13	; 0x05
   10236:	c4 82       	std	Z+4, r12	; 0x04
   10238:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
	   _uart_print(0,1,strSend);
   1023c:	8d b7       	in	r24, 0x3d	; 61
   1023e:	9e b7       	in	r25, 0x3e	; 62
   10240:	06 96       	adiw	r24, 0x06	; 6
   10242:	0f b6       	in	r0, 0x3f	; 63
   10244:	f8 94       	cli
   10246:	9e bf       	out	0x3e, r25	; 62
   10248:	0f be       	out	0x3f, r0	; 63
   1024a:	8d bf       	out	0x3d, r24	; 61
   1024c:	80 e0       	ldi	r24, 0x00	; 0
   1024e:	61 e0       	ldi	r22, 0x01	; 1
   10250:	a8 01       	movw	r20, r16
   10252:	0e 94 97 b2 	call	0x1652e	; 0x1652e <_uart_print>
   10256:	02 c0       	rjmp	.+4      	; 0x1025c <TestUserInput+0x42e>


   	
	}else    
	if (uiResult==USER_CANCEL){
   10258:	81 30       	cpi	r24, 0x01	; 1
   1025a:	11 f0       	breq	.+4      	; 0x10260 <TestUserInput+0x432>
   1025c:	80 e0       	ldi	r24, 0x00	; 0
   1025e:	0b c0       	rjmp	.+22     	; 0x10276 <TestUserInput+0x448>
	   lcd_clear();
   10260:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
   10264:	fe 01       	movw	r30, r28
   10266:	fd 96       	adiw	r30, 0x3d	; 61

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   10268:	cf 01       	movw	r24, r30
   1026a:	0f 96       	adiw	r24, 0x0f	; 15
	     strMemory[i]=data;
   1026c:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   1026e:	e8 17       	cp	r30, r24
   10270:	f9 07       	cpc	r31, r25
   10272:	e1 f7       	brne	.-8      	; 0x1026c <TestUserInput+0x43e>
   10274:	81 e0       	ldi	r24, 0x01	; 1
       Result=MENU_DONE;   
	   //lcd_printf(1,1,PSTR("InputNumber:"));
       //lcd_printf(2,1,PSTR("_         "));
	}
  return Result;
}
   10276:	c2 59       	subi	r28, 0x92	; 146
   10278:	df 4f       	sbci	r29, 0xFF	; 255
   1027a:	0f b6       	in	r0, 0x3f	; 63
   1027c:	f8 94       	cli
   1027e:	de bf       	out	0x3e, r29	; 62
   10280:	0f be       	out	0x3f, r0	; 63
   10282:	cd bf       	out	0x3d, r28	; 61
   10284:	cf 91       	pop	r28
   10286:	df 91       	pop	r29
   10288:	1f 91       	pop	r17
   1028a:	0f 91       	pop	r16
   1028c:	ff 90       	pop	r15
   1028e:	ef 90       	pop	r14
   10290:	df 90       	pop	r13
   10292:	cf 90       	pop	r12
   10294:	bf 90       	pop	r11
   10296:	af 90       	pop	r10
   10298:	9f 90       	pop	r9
   1029a:	8f 90       	pop	r8
   1029c:	7f 90       	pop	r7
   1029e:	6f 90       	pop	r6
   102a0:	08 95       	ret

000102a2 <FSettingDec>:

	Result=MENU_DONE;
	return Result;
}

char FSettingDec(){
   102a2:	df 92       	push	r13
   102a4:	ef 92       	push	r14
   102a6:	ff 92       	push	r15
   102a8:	0f 93       	push	r16
   102aa:	1f 93       	push	r17
   102ac:	df 93       	push	r29
   102ae:	cf 93       	push	r28
   102b0:	cd b7       	in	r28, 0x3d	; 61
   102b2:	de b7       	in	r29, 0x3e	; 62
   102b4:	64 97       	sbiw	r28, 0x14	; 20
   102b6:	0f b6       	in	r0, 0x3f	; 63
   102b8:	f8 94       	cli
   102ba:	de bf       	out	0x3e, r29	; 62
   102bc:	0f be       	out	0x3f, r0	; 63
   102be:	cd bf       	out	0x3d, r28	; 61
static char stSettingDecimal=sdInitDisplay;
     char PDecimalConfig[4],Addr,KeyChar,Result;
	 char lcdteks[20];

     Result=MENU_NONE;
	 switch(stSettingDecimal){
   102c0:	80 91 e3 02 	lds	r24, 0x02E3
   102c4:	82 30       	cpi	r24, 0x02	; 2
   102c6:	09 f4       	brne	.+2      	; 0x102ca <FSettingDec+0x28>
   102c8:	c7 c0       	rjmp	.+398    	; 0x10458 <FSettingDec+0x1b6>
   102ca:	83 30       	cpi	r24, 0x03	; 3
   102cc:	30 f4       	brcc	.+12     	; 0x102da <FSettingDec+0x38>
   102ce:	88 23       	and	r24, r24
   102d0:	71 f0       	breq	.+28     	; 0x102ee <FSettingDec+0x4c>
   102d2:	81 30       	cpi	r24, 0x01	; 1
   102d4:	09 f0       	breq	.+2      	; 0x102d8 <FSettingDec+0x36>
   102d6:	c3 c1       	rjmp	.+902    	; 0x1065e <FSettingDec+0x3bc>
   102d8:	92 c0       	rjmp	.+292    	; 0x103fe <FSettingDec+0x15c>
   102da:	84 30       	cpi	r24, 0x04	; 4
   102dc:	09 f4       	brne	.+2      	; 0x102e0 <FSettingDec+0x3e>
   102de:	b3 c1       	rjmp	.+870    	; 0x10646 <FSettingDec+0x3a4>
   102e0:	84 30       	cpi	r24, 0x04	; 4
   102e2:	08 f4       	brcc	.+2      	; 0x102e6 <FSettingDec+0x44>
   102e4:	68 c1       	rjmp	.+720    	; 0x105b6 <FSettingDec+0x314>
   102e6:	85 30       	cpi	r24, 0x05	; 5
   102e8:	09 f0       	breq	.+2      	; 0x102ec <FSettingDec+0x4a>
   102ea:	b9 c1       	rjmp	.+882    	; 0x1065e <FSettingDec+0x3bc>
   102ec:	b4 c1       	rjmp	.+872    	; 0x10656 <FSettingDec+0x3b4>
	 case sdInitDisplay:
	      lcd_clear();         //"12345678901234567890
   102ee:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   102f2:	e1 99       	sbic	0x1c, 1	; 28
   102f4:	fe cf       	rjmp	.-4      	; 0x102f2 <FSettingDec+0x50>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   102f6:	89 e3       	ldi	r24, 0x39	; 57
   102f8:	90 e0       	ldi	r25, 0x00	; 0
   102fa:	9f bb       	out	0x1f, r25	; 31
   102fc:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   102fe:	e0 9a       	sbi	0x1c, 0	; 28
   10300:	2d b3       	in	r18, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   10302:	e1 99       	sbic	0x1c, 1	; 28
   10304:	fe cf       	rjmp	.-4      	; 0x10302 <FSettingDec+0x60>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   10306:	8a e3       	ldi	r24, 0x3A	; 58
   10308:	90 e0       	ldi	r25, 0x00	; 0
   1030a:	9f bb       	out	0x1f, r25	; 31
   1030c:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   1030e:	e0 9a       	sbi	0x1c, 0	; 28
   10310:	ed b2       	in	r14, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   10312:	e1 99       	sbic	0x1c, 1	; 28
   10314:	fe cf       	rjmp	.-4      	; 0x10312 <FSettingDec+0x70>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   10316:	8b e3       	ldi	r24, 0x3B	; 59
   10318:	90 e0       	ldi	r25, 0x00	; 0
   1031a:	9f bb       	out	0x1f, r25	; 31
   1031c:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   1031e:	e0 9a       	sbi	0x1c, 0	; 28
   10320:	fd b2       	in	r15, 0x1d	; 29
		  PDecimalConfig[0]=eeprom_read_byte(&DefDecimalPrice);
		  PDecimalConfig[1]=eeprom_read_byte(&DefDecimalVolume);
		  PDecimalConfig[2]=eeprom_read_byte(&DefDecimalMoney);

		  sprintf_P(lcdteks,PSTR("1.Price :%d"),PDecimalConfig[0]);
   10322:	00 d0       	rcall	.+0      	; 0x10324 <FSettingDec+0x82>
   10324:	00 d0       	rcall	.+0      	; 0x10326 <FSettingDec+0x84>
   10326:	00 d0       	rcall	.+0      	; 0x10328 <FSettingDec+0x86>
   10328:	ed b7       	in	r30, 0x3d	; 61
   1032a:	fe b7       	in	r31, 0x3e	; 62
   1032c:	31 96       	adiw	r30, 0x01	; 1
   1032e:	8e 01       	movw	r16, r28
   10330:	0f 5f       	subi	r16, 0xFF	; 255
   10332:	1f 4f       	sbci	r17, 0xFF	; 255
   10334:	ad b7       	in	r26, 0x3d	; 61
   10336:	be b7       	in	r27, 0x3e	; 62
   10338:	12 96       	adiw	r26, 0x02	; 2
   1033a:	1c 93       	st	X, r17
   1033c:	0e 93       	st	-X, r16
   1033e:	11 97       	sbiw	r26, 0x01	; 1
   10340:	86 e5       	ldi	r24, 0x56	; 86
   10342:	91 e1       	ldi	r25, 0x11	; 17
   10344:	93 83       	std	Z+3, r25	; 0x03
   10346:	82 83       	std	Z+2, r24	; 0x02
   10348:	24 83       	std	Z+4, r18	; 0x04
   1034a:	15 82       	std	Z+5, r1	; 0x05
   1034c:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
		  lcd_print(1,1,lcdteks);
   10350:	8d b7       	in	r24, 0x3d	; 61
   10352:	9e b7       	in	r25, 0x3e	; 62
   10354:	06 96       	adiw	r24, 0x06	; 6
   10356:	0f b6       	in	r0, 0x3f	; 63
   10358:	f8 94       	cli
   1035a:	9e bf       	out	0x3e, r25	; 62
   1035c:	0f be       	out	0x3f, r0	; 63
   1035e:	8d bf       	out	0x3d, r24	; 61
   10360:	81 e0       	ldi	r24, 0x01	; 1
   10362:	61 e0       	ldi	r22, 0x01	; 1
   10364:	a8 01       	movw	r20, r16
   10366:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
		  sprintf_P(lcdteks,PSTR("2.Volume:%d"),PDecimalConfig[1]);
   1036a:	00 d0       	rcall	.+0      	; 0x1036c <FSettingDec+0xca>
   1036c:	00 d0       	rcall	.+0      	; 0x1036e <FSettingDec+0xcc>
   1036e:	00 d0       	rcall	.+0      	; 0x10370 <FSettingDec+0xce>
   10370:	ed b7       	in	r30, 0x3d	; 61
   10372:	fe b7       	in	r31, 0x3e	; 62
   10374:	31 96       	adiw	r30, 0x01	; 1
   10376:	ad b7       	in	r26, 0x3d	; 61
   10378:	be b7       	in	r27, 0x3e	; 62
   1037a:	12 96       	adiw	r26, 0x02	; 2
   1037c:	1c 93       	st	X, r17
   1037e:	0e 93       	st	-X, r16
   10380:	11 97       	sbiw	r26, 0x01	; 1
   10382:	8a e4       	ldi	r24, 0x4A	; 74
   10384:	91 e1       	ldi	r25, 0x11	; 17
   10386:	93 83       	std	Z+3, r25	; 0x03
   10388:	82 83       	std	Z+2, r24	; 0x02
   1038a:	e4 82       	std	Z+4, r14	; 0x04
   1038c:	15 82       	std	Z+5, r1	; 0x05
   1038e:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
		  lcd_print(2,1,lcdteks);
   10392:	8d b7       	in	r24, 0x3d	; 61
   10394:	9e b7       	in	r25, 0x3e	; 62
   10396:	06 96       	adiw	r24, 0x06	; 6
   10398:	0f b6       	in	r0, 0x3f	; 63
   1039a:	f8 94       	cli
   1039c:	9e bf       	out	0x3e, r25	; 62
   1039e:	0f be       	out	0x3f, r0	; 63
   103a0:	8d bf       	out	0x3d, r24	; 61
   103a2:	82 e0       	ldi	r24, 0x02	; 2
   103a4:	61 e0       	ldi	r22, 0x01	; 1
   103a6:	a8 01       	movw	r20, r16
   103a8:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
		  sprintf_P(lcdteks,PSTR("3.Money :%d"),PDecimalConfig[2]);
   103ac:	00 d0       	rcall	.+0      	; 0x103ae <FSettingDec+0x10c>
   103ae:	00 d0       	rcall	.+0      	; 0x103b0 <FSettingDec+0x10e>
   103b0:	00 d0       	rcall	.+0      	; 0x103b2 <FSettingDec+0x110>
   103b2:	ed b7       	in	r30, 0x3d	; 61
   103b4:	fe b7       	in	r31, 0x3e	; 62
   103b6:	31 96       	adiw	r30, 0x01	; 1
   103b8:	ad b7       	in	r26, 0x3d	; 61
   103ba:	be b7       	in	r27, 0x3e	; 62
   103bc:	12 96       	adiw	r26, 0x02	; 2
   103be:	1c 93       	st	X, r17
   103c0:	0e 93       	st	-X, r16
   103c2:	11 97       	sbiw	r26, 0x01	; 1
   103c4:	8e e3       	ldi	r24, 0x3E	; 62
   103c6:	91 e1       	ldi	r25, 0x11	; 17
   103c8:	93 83       	std	Z+3, r25	; 0x03
   103ca:	82 83       	std	Z+2, r24	; 0x02
   103cc:	f4 82       	std	Z+4, r15	; 0x04
   103ce:	15 82       	std	Z+5, r1	; 0x05
   103d0:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
		  lcd_print(3,1,lcdteks);
   103d4:	8d b7       	in	r24, 0x3d	; 61
   103d6:	9e b7       	in	r25, 0x3e	; 62
   103d8:	06 96       	adiw	r24, 0x06	; 6
   103da:	0f b6       	in	r0, 0x3f	; 63
   103dc:	f8 94       	cli
   103de:	9e bf       	out	0x3e, r25	; 62
   103e0:	0f be       	out	0x3f, r0	; 63
   103e2:	8d bf       	out	0x3d, r24	; 61
   103e4:	83 e0       	ldi	r24, 0x03	; 3
   103e6:	61 e0       	ldi	r22, 0x01	; 1
   103e8:	a8 01       	movw	r20, r16
   103ea:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
		  lcd_printf(4,1,PSTR("[*]Back  [#]Next"));
   103ee:	84 e0       	ldi	r24, 0x04	; 4
   103f0:	61 e0       	ldi	r22, 0x01	; 1
   103f2:	4d e2       	ldi	r20, 0x2D	; 45
   103f4:	51 e1       	ldi	r21, 0x11	; 17
   103f6:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		  stSettingDecimal=sdSelectKey1;
   103fa:	81 e0       	ldi	r24, 0x01	; 1
   103fc:	29 c1       	rjmp	.+594    	; 0x10650 <FSettingDec+0x3ae>
		  break;
     case sdSelectKey1:
          KeyChar=_key_btn(_key_scan(1));
   103fe:	81 e0       	ldi	r24, 0x01	; 1
   10400:	0e 94 ab ae 	call	0x15d56	; 0x15d56 <_key_scan>
   10404:	0e 94 0c ae 	call	0x15c18	; 0x15c18 <_key_btn>
		  if ((KeyChar>='1')&&(KeyChar<='3')){
   10408:	98 2f       	mov	r25, r24
   1040a:	91 53       	subi	r25, 0x31	; 49
   1040c:	93 30       	cpi	r25, 0x03	; 3
   1040e:	e0 f4       	brcc	.+56     	; 0x10448 <FSettingDec+0x1a6>
		      Addr=KeyChar-'1';
		  	  PDecimalConfig[Addr]=eeprom_read_byte(&DefDecimalPrice+Addr);
   10410:	29 2f       	mov	r18, r25
   10412:	30 e0       	ldi	r19, 0x00	; 0
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   10414:	e1 99       	sbic	0x1c, 1	; 28
   10416:	fe cf       	rjmp	.-4      	; 0x10414 <FSettingDec+0x172>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   10418:	c9 01       	movw	r24, r18
   1041a:	87 5c       	subi	r24, 0xC7	; 199
   1041c:	9f 4f       	sbci	r25, 0xFF	; 255
   1041e:	9f bb       	out	0x1f, r25	; 31
   10420:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   10422:	e0 9a       	sbi	0x1c, 0	; 28
   10424:	8d b3       	in	r24, 0x1d	; 29
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   10426:	e1 99       	sbic	0x1c, 1	; 28
   10428:	fe cf       	rjmp	.-4      	; 0x10426 <FSettingDec+0x184>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   1042a:	27 5c       	subi	r18, 0xC7	; 199
   1042c:	3f 4f       	sbci	r19, 0xFF	; 255
   1042e:	3f bb       	out	0x1f, r19	; 31
   10430:	2e bb       	out	0x1e, r18	; 30
			  PDecimalConfig[Addr]=(PDecimalConfig[Addr]+1)%4;
   10432:	90 e0       	ldi	r25, 0x00	; 0
   10434:	01 96       	adiw	r24, 0x01	; 1
   10436:	83 70       	andi	r24, 0x03	; 3
   10438:	90 70       	andi	r25, 0x00	; 0
#endif
    EEDR = __value;
   1043a:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
   1043c:	0f b6       	in	r0, 0x3f	; 63
   1043e:	f8 94       	cli
   10440:	e2 9a       	sbi	0x1c, 2	; 28
   10442:	e1 9a       	sbi	0x1c, 1	; 28
   10444:	0f be       	out	0x3f, r0	; 63
   10446:	f6 c0       	rjmp	.+492    	; 0x10634 <FSettingDec+0x392>

			  eeprom_write_byte(&DefDecimalPrice+Addr,PDecimalConfig[Addr]);
              stSettingDecimal=sdInitDisplay;
		  }else if (KeyChar=='*') stSettingDecimal=sdExitSettingDecimal;
   10448:	8a 32       	cpi	r24, 0x2A	; 42
   1044a:	11 f4       	brne	.+4      	; 0x10450 <FSettingDec+0x1ae>
   1044c:	85 e0       	ldi	r24, 0x05	; 5
   1044e:	00 c1       	rjmp	.+512    	; 0x10650 <FSettingDec+0x3ae>
		  else if (KeyChar=='#') stSettingDecimal=sdInitDisplay2;
   10450:	83 32       	cpi	r24, 0x23	; 35
   10452:	09 f0       	breq	.+2      	; 0x10456 <FSettingDec+0x1b4>
   10454:	04 c1       	rjmp	.+520    	; 0x1065e <FSettingDec+0x3bc>
   10456:	fb c0       	rjmp	.+502    	; 0x1064e <FSettingDec+0x3ac>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   10458:	e1 99       	sbic	0x1c, 1	; 28
   1045a:	fe cf       	rjmp	.-4      	; 0x10458 <FSettingDec+0x1b6>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   1045c:	8c e3       	ldi	r24, 0x3C	; 60
   1045e:	90 e0       	ldi	r25, 0x00	; 0
   10460:	9f bb       	out	0x1f, r25	; 31
   10462:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   10464:	e0 9a       	sbi	0x1c, 0	; 28
   10466:	2d b3       	in	r18, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   10468:	e1 99       	sbic	0x1c, 1	; 28
   1046a:	fe cf       	rjmp	.-4      	; 0x10468 <FSettingDec+0x1c6>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   1046c:	8d e3       	ldi	r24, 0x3D	; 61
   1046e:	90 e0       	ldi	r25, 0x00	; 0
   10470:	9f bb       	out	0x1f, r25	; 31
   10472:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   10474:	e0 9a       	sbi	0x1c, 0	; 28
   10476:	ed b2       	in	r14, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   10478:	e1 99       	sbic	0x1c, 1	; 28
   1047a:	fe cf       	rjmp	.-4      	; 0x10478 <FSettingDec+0x1d6>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   1047c:	8e e3       	ldi	r24, 0x3E	; 62
   1047e:	90 e0       	ldi	r25, 0x00	; 0
   10480:	9f bb       	out	0x1f, r25	; 31
   10482:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   10484:	e0 9a       	sbi	0x1c, 0	; 28
   10486:	dd b2       	in	r13, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   10488:	e1 99       	sbic	0x1c, 1	; 28
   1048a:	fe cf       	rjmp	.-4      	; 0x10488 <FSettingDec+0x1e6>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   1048c:	8f e3       	ldi	r24, 0x3F	; 63
   1048e:	90 e0       	ldi	r25, 0x00	; 0
   10490:	9f bb       	out	0x1f, r25	; 31
   10492:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   10494:	e0 9a       	sbi	0x1c, 0	; 28
   10496:	fd b2       	in	r15, 0x1d	; 29
     case sdInitDisplay2:
		  PDecimalConfig[0]=eeprom_read_byte(&DefDecimalTotalVolume);
		  PDecimalConfig[1]=eeprom_read_byte(&DefDecimalTotalMoney);
		  PDecimalConfig[2]=eeprom_read_byte(&DefDecimalMark);
		  PDecimalConfig[3]=eeprom_read_byte(&DefCurrencyMark);
		  sprintf_P(lcdteks,PSTR("1.T.Volume:%d  5.Test"),PDecimalConfig[0]);
   10498:	00 d0       	rcall	.+0      	; 0x1049a <FSettingDec+0x1f8>
   1049a:	00 d0       	rcall	.+0      	; 0x1049c <FSettingDec+0x1fa>
   1049c:	00 d0       	rcall	.+0      	; 0x1049e <FSettingDec+0x1fc>
   1049e:	ed b7       	in	r30, 0x3d	; 61
   104a0:	fe b7       	in	r31, 0x3e	; 62
   104a2:	31 96       	adiw	r30, 0x01	; 1
   104a4:	8e 01       	movw	r16, r28
   104a6:	0f 5f       	subi	r16, 0xFF	; 255
   104a8:	1f 4f       	sbci	r17, 0xFF	; 255
   104aa:	ad b7       	in	r26, 0x3d	; 61
   104ac:	be b7       	in	r27, 0x3e	; 62
   104ae:	12 96       	adiw	r26, 0x02	; 2
   104b0:	1c 93       	st	X, r17
   104b2:	0e 93       	st	-X, r16
   104b4:	11 97       	sbiw	r26, 0x01	; 1
   104b6:	87 e1       	ldi	r24, 0x17	; 23
   104b8:	91 e1       	ldi	r25, 0x11	; 17
   104ba:	93 83       	std	Z+3, r25	; 0x03
   104bc:	82 83       	std	Z+2, r24	; 0x02
   104be:	24 83       	std	Z+4, r18	; 0x04
   104c0:	15 82       	std	Z+5, r1	; 0x05
   104c2:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
		  lcd_print(1,1,lcdteks);
   104c6:	8d b7       	in	r24, 0x3d	; 61
   104c8:	9e b7       	in	r25, 0x3e	; 62
   104ca:	06 96       	adiw	r24, 0x06	; 6
   104cc:	0f b6       	in	r0, 0x3f	; 63
   104ce:	f8 94       	cli
   104d0:	9e bf       	out	0x3e, r25	; 62
   104d2:	0f be       	out	0x3f, r0	; 63
   104d4:	8d bf       	out	0x3d, r24	; 61
   104d6:	81 e0       	ldi	r24, 0x01	; 1
   104d8:	61 e0       	ldi	r22, 0x01	; 1
   104da:	a8 01       	movw	r20, r16
   104dc:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
		  sprintf_P(lcdteks,PSTR("2.T.Money :%d "),PDecimalConfig[1]);
   104e0:	00 d0       	rcall	.+0      	; 0x104e2 <FSettingDec+0x240>
   104e2:	00 d0       	rcall	.+0      	; 0x104e4 <FSettingDec+0x242>
   104e4:	00 d0       	rcall	.+0      	; 0x104e6 <FSettingDec+0x244>
   104e6:	ed b7       	in	r30, 0x3d	; 61
   104e8:	fe b7       	in	r31, 0x3e	; 62
   104ea:	31 96       	adiw	r30, 0x01	; 1
   104ec:	ad b7       	in	r26, 0x3d	; 61
   104ee:	be b7       	in	r27, 0x3e	; 62
   104f0:	12 96       	adiw	r26, 0x02	; 2
   104f2:	1c 93       	st	X, r17
   104f4:	0e 93       	st	-X, r16
   104f6:	11 97       	sbiw	r26, 0x01	; 1
   104f8:	88 e0       	ldi	r24, 0x08	; 8
   104fa:	91 e1       	ldi	r25, 0x11	; 17
   104fc:	93 83       	std	Z+3, r25	; 0x03
   104fe:	82 83       	std	Z+2, r24	; 0x02
   10500:	e4 82       	std	Z+4, r14	; 0x04
   10502:	15 82       	std	Z+5, r1	; 0x05
   10504:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
		  lcd_print(2,1,lcdteks);
   10508:	8d b7       	in	r24, 0x3d	; 61
   1050a:	9e b7       	in	r25, 0x3e	; 62
   1050c:	06 96       	adiw	r24, 0x06	; 6
   1050e:	0f b6       	in	r0, 0x3f	; 63
   10510:	f8 94       	cli
   10512:	9e bf       	out	0x3e, r25	; 62
   10514:	0f be       	out	0x3f, r0	; 63
   10516:	8d bf       	out	0x3d, r24	; 61
   10518:	82 e0       	ldi	r24, 0x02	; 2
   1051a:	61 e0       	ldi	r22, 0x01	; 1
   1051c:	a8 01       	movw	r20, r16
   1051e:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
		  sprintf_P(lcdteks,PSTR("3.Decimal :%c "),PDecimalConfig[2]);
   10522:	00 d0       	rcall	.+0      	; 0x10524 <FSettingDec+0x282>
   10524:	00 d0       	rcall	.+0      	; 0x10526 <FSettingDec+0x284>
   10526:	00 d0       	rcall	.+0      	; 0x10528 <FSettingDec+0x286>
   10528:	ed b7       	in	r30, 0x3d	; 61
   1052a:	fe b7       	in	r31, 0x3e	; 62
   1052c:	31 96       	adiw	r30, 0x01	; 1
   1052e:	ad b7       	in	r26, 0x3d	; 61
   10530:	be b7       	in	r27, 0x3e	; 62
   10532:	12 96       	adiw	r26, 0x02	; 2
   10534:	1c 93       	st	X, r17
   10536:	0e 93       	st	-X, r16
   10538:	11 97       	sbiw	r26, 0x01	; 1
   1053a:	89 ef       	ldi	r24, 0xF9	; 249
   1053c:	90 e1       	ldi	r25, 0x10	; 16
   1053e:	93 83       	std	Z+3, r25	; 0x03
   10540:	82 83       	std	Z+2, r24	; 0x02
   10542:	d4 82       	std	Z+4, r13	; 0x04
   10544:	15 82       	std	Z+5, r1	; 0x05
   10546:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
		  lcd_print(3,1,lcdteks);
   1054a:	8d b7       	in	r24, 0x3d	; 61
   1054c:	9e b7       	in	r25, 0x3e	; 62
   1054e:	06 96       	adiw	r24, 0x06	; 6
   10550:	0f b6       	in	r0, 0x3f	; 63
   10552:	f8 94       	cli
   10554:	9e bf       	out	0x3e, r25	; 62
   10556:	0f be       	out	0x3f, r0	; 63
   10558:	8d bf       	out	0x3d, r24	; 61
   1055a:	83 e0       	ldi	r24, 0x03	; 3
   1055c:	61 e0       	ldi	r22, 0x01	; 1
   1055e:	a8 01       	movw	r20, r16
   10560:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
		  sprintf_P(lcdteks,PSTR("4.Sparator:%c "),PDecimalConfig[3]);
   10564:	00 d0       	rcall	.+0      	; 0x10566 <FSettingDec+0x2c4>
   10566:	00 d0       	rcall	.+0      	; 0x10568 <FSettingDec+0x2c6>
   10568:	00 d0       	rcall	.+0      	; 0x1056a <FSettingDec+0x2c8>
   1056a:	ed b7       	in	r30, 0x3d	; 61
   1056c:	fe b7       	in	r31, 0x3e	; 62
   1056e:	31 96       	adiw	r30, 0x01	; 1
   10570:	ad b7       	in	r26, 0x3d	; 61
   10572:	be b7       	in	r27, 0x3e	; 62
   10574:	12 96       	adiw	r26, 0x02	; 2
   10576:	1c 93       	st	X, r17
   10578:	0e 93       	st	-X, r16
   1057a:	11 97       	sbiw	r26, 0x01	; 1
   1057c:	8a ee       	ldi	r24, 0xEA	; 234
   1057e:	90 e1       	ldi	r25, 0x10	; 16
   10580:	93 83       	std	Z+3, r25	; 0x03
   10582:	82 83       	std	Z+2, r24	; 0x02
   10584:	f4 82       	std	Z+4, r15	; 0x04
   10586:	15 82       	std	Z+5, r1	; 0x05
   10588:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
		  lcd_print(4,1,lcdteks);
   1058c:	8d b7       	in	r24, 0x3d	; 61
   1058e:	9e b7       	in	r25, 0x3e	; 62
   10590:	06 96       	adiw	r24, 0x06	; 6
   10592:	0f b6       	in	r0, 0x3f	; 63
   10594:	f8 94       	cli
   10596:	9e bf       	out	0x3e, r25	; 62
   10598:	0f be       	out	0x3f, r0	; 63
   1059a:	8d bf       	out	0x3d, r24	; 61
   1059c:	84 e0       	ldi	r24, 0x04	; 4
   1059e:	61 e0       	ldi	r22, 0x01	; 1
   105a0:	a8 01       	movw	r20, r16
   105a2:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
		  lcd_printf(4,14,PSTR("*)Back"));
   105a6:	84 e0       	ldi	r24, 0x04	; 4
   105a8:	6e e0       	ldi	r22, 0x0E	; 14
   105aa:	43 ee       	ldi	r20, 0xE3	; 227
   105ac:	50 e1       	ldi	r21, 0x10	; 16
   105ae:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
	      stSettingDecimal=sdSelectKey2;
   105b2:	83 e0       	ldi	r24, 0x03	; 3
   105b4:	4d c0       	rjmp	.+154    	; 0x10650 <FSettingDec+0x3ae>
	      break;
     case sdSelectKey2:
          KeyChar=_key_btn(_key_scan(1));
   105b6:	81 e0       	ldi	r24, 0x01	; 1
   105b8:	0e 94 ab ae 	call	0x15d56	; 0x15d56 <_key_scan>
   105bc:	0e 94 0c ae 	call	0x15c18	; 0x15c18 <_key_btn>
   105c0:	28 2f       	mov	r18, r24
		  if ((KeyChar>='1')&&(KeyChar<='2')){
   105c2:	98 2f       	mov	r25, r24
   105c4:	91 53       	subi	r25, 0x31	; 49
   105c6:	92 30       	cpi	r25, 0x02	; 2
   105c8:	b0 f4       	brcc	.+44     	; 0x105f6 <FSettingDec+0x354>
		      Addr=KeyChar-'1';
		  	  PDecimalConfig[Addr]=eeprom_read_byte(&DefDecimalTotalVolume+Addr);
   105ca:	29 2f       	mov	r18, r25
   105cc:	30 e0       	ldi	r19, 0x00	; 0
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   105ce:	e1 99       	sbic	0x1c, 1	; 28
   105d0:	fe cf       	rjmp	.-4      	; 0x105ce <FSettingDec+0x32c>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   105d2:	c9 01       	movw	r24, r18
   105d4:	84 5c       	subi	r24, 0xC4	; 196
   105d6:	9f 4f       	sbci	r25, 0xFF	; 255
   105d8:	9f bb       	out	0x1f, r25	; 31
   105da:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   105dc:	e0 9a       	sbi	0x1c, 0	; 28
   105de:	8d b3       	in	r24, 0x1d	; 29
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   105e0:	e1 99       	sbic	0x1c, 1	; 28
   105e2:	fe cf       	rjmp	.-4      	; 0x105e0 <FSettingDec+0x33e>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   105e4:	24 5c       	subi	r18, 0xC4	; 196
   105e6:	3f 4f       	sbci	r19, 0xFF	; 255
   105e8:	3f bb       	out	0x1f, r19	; 31
   105ea:	2e bb       	out	0x1e, r18	; 30
		      PDecimalConfig[Addr]=(PDecimalConfig[Addr]+1)%4;
   105ec:	90 e0       	ldi	r25, 0x00	; 0
   105ee:	01 96       	adiw	r24, 0x01	; 1
   105f0:	83 70       	andi	r24, 0x03	; 3
   105f2:	90 70       	andi	r25, 0x00	; 0
   105f4:	16 c0       	rjmp	.+44     	; 0x10622 <FSettingDec+0x380>

			  eeprom_write_byte(&DefDecimalTotalVolume+Addr,PDecimalConfig[Addr]);
              stSettingDecimal=sdInitDisplay2;
		  }else if ((KeyChar>='3')&&(KeyChar<='4')){
   105f6:	83 53       	subi	r24, 0x33	; 51
   105f8:	82 30       	cpi	r24, 0x02	; 2
   105fa:	d0 f4       	brcc	.+52     	; 0x10630 <FSettingDec+0x38e>
		      Addr=KeyChar-'1';
		  	  PDecimalConfig[Addr]=eeprom_read_byte(&DefDecimalTotalVolume+Addr);
   105fc:	09 2f       	mov	r16, r25
   105fe:	10 e0       	ldi	r17, 0x00	; 0
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   10600:	e1 99       	sbic	0x1c, 1	; 28
   10602:	fe cf       	rjmp	.-4      	; 0x10600 <FSettingDec+0x35e>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   10604:	c8 01       	movw	r24, r16
   10606:	84 5c       	subi	r24, 0xC4	; 196
   10608:	9f 4f       	sbci	r25, 0xFF	; 255
   1060a:	9f bb       	out	0x1f, r25	; 31
   1060c:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   1060e:	e0 9a       	sbi	0x1c, 0	; 28
   10610:	8d b3       	in	r24, 0x1d	; 29
			  PDecimalConfig[Addr]=SelectMark(PDecimalConfig[Addr]);
   10612:	0e 94 58 1d 	call	0x3ab0	; 0x3ab0 <SelectMark>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   10616:	e1 99       	sbic	0x1c, 1	; 28
   10618:	fe cf       	rjmp	.-4      	; 0x10616 <FSettingDec+0x374>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   1061a:	04 5c       	subi	r16, 0xC4	; 196
   1061c:	1f 4f       	sbci	r17, 0xFF	; 255
   1061e:	1f bb       	out	0x1f, r17	; 31
   10620:	0e bb       	out	0x1e, r16	; 30
#endif
    EEDR = __value;
   10622:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
   10624:	0f b6       	in	r0, 0x3f	; 63
   10626:	f8 94       	cli
   10628:	e2 9a       	sbi	0x1c, 2	; 28
   1062a:	e1 9a       	sbi	0x1c, 1	; 28
   1062c:	0f be       	out	0x3f, r0	; 63
   1062e:	0f c0       	rjmp	.+30     	; 0x1064e <FSettingDec+0x3ac>
			  eeprom_write_byte(&DefDecimalTotalVolume+Addr,PDecimalConfig[Addr]);
              stSettingDecimal=sdInitDisplay2;
		  }else if (KeyChar=='*') stSettingDecimal=sdInitDisplay;
   10630:	2a 32       	cpi	r18, 0x2A	; 42
   10632:	19 f4       	brne	.+6      	; 0x1063a <FSettingDec+0x398>
   10634:	10 92 e3 02 	sts	0x02E3, r1
   10638:	12 c0       	rjmp	.+36     	; 0x1065e <FSettingDec+0x3bc>
		  else if (KeyChar=='5'){
   1063a:	25 33       	cpi	r18, 0x35	; 53
   1063c:	81 f4       	brne	.+32     	; 0x1065e <FSettingDec+0x3bc>
		          lcd_clear();
   1063e:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
		          stSettingDecimal=sdTestInput;
   10642:	84 e0       	ldi	r24, 0x04	; 4
   10644:	05 c0       	rjmp	.+10     	; 0x10650 <FSettingDec+0x3ae>
				  }
          break;
     case sdTestInput:
	      if (TestUserInput()==MENU_DONE)stSettingDecimal=sdInitDisplay2;
   10646:	0e 94 17 7f 	call	0xfe2e	; 0xfe2e <TestUserInput>
   1064a:	81 30       	cpi	r24, 0x01	; 1
   1064c:	41 f4       	brne	.+16     	; 0x1065e <FSettingDec+0x3bc>
   1064e:	82 e0       	ldi	r24, 0x02	; 2
   10650:	80 93 e3 02 	sts	0x02E3, r24
   10654:	04 c0       	rjmp	.+8      	; 0x1065e <FSettingDec+0x3bc>
	      break;
	 case sdExitSettingDecimal:
          stSettingDecimal=sdInitDisplay;
   10656:	10 92 e3 02 	sts	0x02E3, r1
   1065a:	81 e0       	ldi	r24, 0x01	; 1
   1065c:	01 c0       	rjmp	.+2      	; 0x10660 <FSettingDec+0x3be>
   1065e:	80 e0       	ldi	r24, 0x00	; 0
		  Result=MENU_DONE;
	      break;
	 }
    return Result;
}
   10660:	64 96       	adiw	r28, 0x14	; 20
   10662:	0f b6       	in	r0, 0x3f	; 63
   10664:	f8 94       	cli
   10666:	de bf       	out	0x3e, r29	; 62
   10668:	0f be       	out	0x3f, r0	; 63
   1066a:	cd bf       	out	0x3d, r28	; 61
   1066c:	cf 91       	pop	r28
   1066e:	df 91       	pop	r29
   10670:	1f 91       	pop	r17
   10672:	0f 91       	pop	r16
   10674:	ff 90       	pop	r15
   10676:	ef 90       	pop	r14
   10678:	df 90       	pop	r13
   1067a:	08 95       	ret

0001067c <FTestCalculation>:
	 }
  return Result;
}


void FTestCalculation(){
   1067c:	cf 92       	push	r12
   1067e:	df 92       	push	r13
   10680:	ef 92       	push	r14
   10682:	ff 92       	push	r15
   10684:	0f 93       	push	r16
   10686:	1f 93       	push	r17
   10688:	df 93       	push	r29
   1068a:	cf 93       	push	r28
   1068c:	cd b7       	in	r28, 0x3d	; 61
   1068e:	de b7       	in	r29, 0x3e	; 62
   10690:	64 97       	sbiw	r28, 0x14	; 20
   10692:	0f b6       	in	r0, 0x3f	; 63
   10694:	f8 94       	cli
   10696:	de bf       	out	0x3e, r29	; 62
   10698:	0f be       	out	0x3f, r0	; 63
   1069a:	cd bf       	out	0x3d, r28	; 61
static char stTestCalc=tcInitData,uiResult=USER_NONE;
static char InputA[20],InputB[20],OutputC[20];
     char lcdteks[20],KeyChar;
     
	 switch(stTestCalc){
   1069c:	80 91 52 02 	lds	r24, 0x0252
   106a0:	82 30       	cpi	r24, 0x02	; 2
   106a2:	09 f4       	brne	.+2      	; 0x106a6 <FTestCalculation+0x2a>
   106a4:	4b c0       	rjmp	.+150    	; 0x1073c <FTestCalculation+0xc0>
   106a6:	83 30       	cpi	r24, 0x03	; 3
   106a8:	30 f4       	brcc	.+12     	; 0x106b6 <FTestCalculation+0x3a>
   106aa:	88 23       	and	r24, r24
   106ac:	71 f0       	breq	.+28     	; 0x106ca <FTestCalculation+0x4e>
   106ae:	81 30       	cpi	r24, 0x01	; 1
   106b0:	09 f0       	breq	.+2      	; 0x106b4 <FTestCalculation+0x38>
   106b2:	e7 c0       	rjmp	.+462    	; 0x10882 <FTestCalculation+0x206>
   106b4:	2f c0       	rjmp	.+94     	; 0x10714 <FTestCalculation+0x98>
   106b6:	84 30       	cpi	r24, 0x04	; 4
   106b8:	09 f4       	brne	.+2      	; 0x106bc <FTestCalculation+0x40>
   106ba:	82 c0       	rjmp	.+260    	; 0x107c0 <FTestCalculation+0x144>
   106bc:	84 30       	cpi	r24, 0x04	; 4
   106be:	08 f4       	brcc	.+2      	; 0x106c2 <FTestCalculation+0x46>
   106c0:	6d c0       	rjmp	.+218    	; 0x1079c <FTestCalculation+0x120>
   106c2:	85 30       	cpi	r24, 0x05	; 5
   106c4:	09 f0       	breq	.+2      	; 0x106c8 <FTestCalculation+0x4c>
   106c6:	dd c0       	rjmp	.+442    	; 0x10882 <FTestCalculation+0x206>
   106c8:	d1 c0       	rjmp	.+418    	; 0x1086c <FTestCalculation+0x1f0>
	 case tcInitData:
	      lcd_clear();
   106ca:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
		  lcd_printf(1,1,PSTR("Operation Multiply"));
   106ce:	81 e0       	ldi	r24, 0x01	; 1
   106d0:	61 e0       	ldi	r22, 0x01	; 1
   106d2:	45 ed       	ldi	r20, 0xD5	; 213
   106d4:	55 e0       	ldi	r21, 0x05	; 5
   106d6:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		  lcd_printf(2,1,PSTR("InA:_"));
   106da:	82 e0       	ldi	r24, 0x02	; 2
   106dc:	61 e0       	ldi	r22, 0x01	; 1
   106de:	4f ec       	ldi	r20, 0xCF	; 207
   106e0:	55 e0       	ldi	r21, 0x05	; 5
   106e2:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
   106e6:	ad e3       	ldi	r26, 0x3D	; 61
   106e8:	b2 e0       	ldi	r27, 0x02	; 2
   106ea:	fd 01       	movw	r30, r26
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
   106ec:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   106ee:	82 e0       	ldi	r24, 0x02	; 2
   106f0:	e1 35       	cpi	r30, 0x51	; 81
   106f2:	f8 07       	cpc	r31, r24
   106f4:	d9 f7       	brne	.-10     	; 0x106ec <FTestCalculation+0x70>
   106f6:	74 97       	sbiw	r30, 0x14	; 20
	     strMemory[i]=data;
   106f8:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   106fa:	92 e0       	ldi	r25, 0x02	; 2
   106fc:	e1 35       	cpi	r30, 0x51	; 81
   106fe:	f9 07       	cpc	r31, r25
   10700:	d9 f7       	brne	.-10     	; 0x106f8 <FTestCalculation+0x7c>
	     strMemory[i]=data;
   10702:	1d 92       	st	X+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   10704:	82 e0       	ldi	r24, 0x02	; 2
   10706:	a1 35       	cpi	r26, 0x51	; 81
   10708:	b8 07       	cpc	r27, r24
   1070a:	d9 f7       	brne	.-10     	; 0x10702 <FTestCalculation+0x86>
		  lcd_printf(2,1,PSTR("InA:_"));
		  FillChar(InputA,sizeof(InputA),0);
		  FillChar(InputA,sizeof(InputB),0);
		  FillChar(InputA,sizeof(OutputC),0);

		  uiResult=USER_NONE;
   1070c:	10 92 51 02 	sts	0x0251, r1
          stTestCalc=tcInputA;
   10710:	81 e0       	ldi	r24, 0x01	; 1
   10712:	11 c0       	rjmp	.+34     	; 0x10736 <FTestCalculation+0xba>
	      break;
     case tcInputA:
	      uiResult=UserInput(UI_ALPHANUM_R,2,5,InputA,0,15);
   10714:	83 e0       	ldi	r24, 0x03	; 3
   10716:	62 e0       	ldi	r22, 0x02	; 2
   10718:	45 e0       	ldi	r20, 0x05	; 5
   1071a:	2d e3       	ldi	r18, 0x3D	; 61
   1071c:	32 e0       	ldi	r19, 0x02	; 2
   1071e:	00 e0       	ldi	r16, 0x00	; 0
   10720:	10 e0       	ldi	r17, 0x00	; 0
   10722:	9f e0       	ldi	r25, 0x0F	; 15
   10724:	e9 2e       	mov	r14, r25
   10726:	0e 94 f0 7b 	call	0xf7e0	; 0xf7e0 <UserInput>
   1072a:	80 93 51 02 	sts	0x0251, r24
	      if (uiResult==USER_OK)stTestCalc=tcDispInputA;
   1072e:	83 30       	cpi	r24, 0x03	; 3
   10730:	09 f0       	breq	.+2      	; 0x10734 <FTestCalculation+0xb8>
   10732:	a7 c0       	rjmp	.+334    	; 0x10882 <FTestCalculation+0x206>
   10734:	82 e0       	ldi	r24, 0x02	; 2
   10736:	80 93 52 02 	sts	0x0252, r24
   1073a:	a3 c0       	rjmp	.+326    	; 0x10882 <FTestCalculation+0x206>
	      break;
     case tcDispInputA:
	      sprintf_P(lcdteks,PSTR("InA:%s"),InputA);
   1073c:	00 d0       	rcall	.+0      	; 0x1073e <FTestCalculation+0xc2>
   1073e:	00 d0       	rcall	.+0      	; 0x10740 <FTestCalculation+0xc4>
   10740:	00 d0       	rcall	.+0      	; 0x10742 <FTestCalculation+0xc6>
   10742:	ed b7       	in	r30, 0x3d	; 61
   10744:	fe b7       	in	r31, 0x3e	; 62
   10746:	31 96       	adiw	r30, 0x01	; 1
   10748:	8e 01       	movw	r16, r28
   1074a:	0f 5f       	subi	r16, 0xFF	; 255
   1074c:	1f 4f       	sbci	r17, 0xFF	; 255
   1074e:	ad b7       	in	r26, 0x3d	; 61
   10750:	be b7       	in	r27, 0x3e	; 62
   10752:	12 96       	adiw	r26, 0x02	; 2
   10754:	1c 93       	st	X, r17
   10756:	0e 93       	st	-X, r16
   10758:	11 97       	sbiw	r26, 0x01	; 1
   1075a:	88 ec       	ldi	r24, 0xC8	; 200
   1075c:	95 e0       	ldi	r25, 0x05	; 5
   1075e:	93 83       	std	Z+3, r25	; 0x03
   10760:	82 83       	std	Z+2, r24	; 0x02
   10762:	8d e3       	ldi	r24, 0x3D	; 61
   10764:	92 e0       	ldi	r25, 0x02	; 2
   10766:	95 83       	std	Z+5, r25	; 0x05
   10768:	84 83       	std	Z+4, r24	; 0x04
   1076a:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
		  lcd_print(2,1,lcdteks);
   1076e:	8d b7       	in	r24, 0x3d	; 61
   10770:	9e b7       	in	r25, 0x3e	; 62
   10772:	06 96       	adiw	r24, 0x06	; 6
   10774:	0f b6       	in	r0, 0x3f	; 63
   10776:	f8 94       	cli
   10778:	9e bf       	out	0x3e, r25	; 62
   1077a:	0f be       	out	0x3f, r0	; 63
   1077c:	8d bf       	out	0x3d, r24	; 61
   1077e:	82 e0       	ldi	r24, 0x02	; 2
   10780:	61 e0       	ldi	r22, 0x01	; 1
   10782:	a8 01       	movw	r20, r16
   10784:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
		  lcd_printf(3,1,PSTR("InB:_"));
   10788:	83 e0       	ldi	r24, 0x03	; 3
   1078a:	61 e0       	ldi	r22, 0x01	; 1
   1078c:	42 ec       	ldi	r20, 0xC2	; 194
   1078e:	55 e0       	ldi	r21, 0x05	; 5
   10790:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		  uiResult=USER_NONE;
   10794:	10 92 51 02 	sts	0x0251, r1
          stTestCalc=tcInputB;
   10798:	83 e0       	ldi	r24, 0x03	; 3
   1079a:	cd cf       	rjmp	.-102    	; 0x10736 <FTestCalculation+0xba>
	      break;
     case tcInputB:
	 	  uiResult=UserInput(UI_ALPHANUM_R,3,5,InputB,0,15);
   1079c:	83 e0       	ldi	r24, 0x03	; 3
   1079e:	63 e0       	ldi	r22, 0x03	; 3
   107a0:	45 e0       	ldi	r20, 0x05	; 5
   107a2:	29 e2       	ldi	r18, 0x29	; 41
   107a4:	32 e0       	ldi	r19, 0x02	; 2
   107a6:	00 e0       	ldi	r16, 0x00	; 0
   107a8:	10 e0       	ldi	r17, 0x00	; 0
   107aa:	bf e0       	ldi	r27, 0x0F	; 15
   107ac:	eb 2e       	mov	r14, r27
   107ae:	0e 94 f0 7b 	call	0xf7e0	; 0xf7e0 <UserInput>
   107b2:	80 93 51 02 	sts	0x0251, r24
	      if (uiResult==USER_OK)stTestCalc=tcCalcualte;
   107b6:	83 30       	cpi	r24, 0x03	; 3
   107b8:	09 f0       	breq	.+2      	; 0x107bc <FTestCalculation+0x140>
   107ba:	63 c0       	rjmp	.+198    	; 0x10882 <FTestCalculation+0x206>
   107bc:	84 e0       	ldi	r24, 0x04	; 4
   107be:	bb cf       	rjmp	.-138    	; 0x10736 <FTestCalculation+0xba>
	      break;
     case tcCalcualte:
	      sprintf_P(lcdteks,PSTR("InB:%s"),InputB);
   107c0:	00 d0       	rcall	.+0      	; 0x107c2 <FTestCalculation+0x146>
   107c2:	00 d0       	rcall	.+0      	; 0x107c4 <FTestCalculation+0x148>
   107c4:	00 d0       	rcall	.+0      	; 0x107c6 <FTestCalculation+0x14a>
   107c6:	ed b7       	in	r30, 0x3d	; 61
   107c8:	fe b7       	in	r31, 0x3e	; 62
   107ca:	31 96       	adiw	r30, 0x01	; 1
   107cc:	8e 01       	movw	r16, r28
   107ce:	0f 5f       	subi	r16, 0xFF	; 255
   107d0:	1f 4f       	sbci	r17, 0xFF	; 255
   107d2:	ad b7       	in	r26, 0x3d	; 61
   107d4:	be b7       	in	r27, 0x3e	; 62
   107d6:	12 96       	adiw	r26, 0x02	; 2
   107d8:	1c 93       	st	X, r17
   107da:	0e 93       	st	-X, r16
   107dc:	11 97       	sbiw	r26, 0x01	; 1
   107de:	8b eb       	ldi	r24, 0xBB	; 187
   107e0:	95 e0       	ldi	r25, 0x05	; 5
   107e2:	93 83       	std	Z+3, r25	; 0x03
   107e4:	82 83       	std	Z+2, r24	; 0x02
   107e6:	a9 e2       	ldi	r26, 0x29	; 41
   107e8:	ea 2e       	mov	r14, r26
   107ea:	a2 e0       	ldi	r26, 0x02	; 2
   107ec:	fa 2e       	mov	r15, r26
   107ee:	f5 82       	std	Z+5, r15	; 0x05
   107f0:	e4 82       	std	Z+4, r14	; 0x04
   107f2:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
		  lcd_print(3,1,lcdteks);
   107f6:	8d b7       	in	r24, 0x3d	; 61
   107f8:	9e b7       	in	r25, 0x3e	; 62
   107fa:	06 96       	adiw	r24, 0x06	; 6
   107fc:	0f b6       	in	r0, 0x3f	; 63
   107fe:	f8 94       	cli
   10800:	9e bf       	out	0x3e, r25	; 62
   10802:	0f be       	out	0x3f, r0	; 63
   10804:	8d bf       	out	0x3d, r24	; 61
   10806:	83 e0       	ldi	r24, 0x03	; 3
   10808:	61 e0       	ldi	r22, 0x01	; 1
   1080a:	a8 01       	movw	r20, r16
   1080c:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
		  //StrCalc(TMINUS,InputA,InputB,OutputC);
		  //StrCalc(TPLUS,InputA,InputB,OutputC);
		  StrCalc(TMULTIPLY,InputA,InputB,OutputC);
   10810:	f5 e1       	ldi	r31, 0x15	; 21
   10812:	cf 2e       	mov	r12, r31
   10814:	f2 e0       	ldi	r31, 0x02	; 2
   10816:	df 2e       	mov	r13, r31
   10818:	82 e0       	ldi	r24, 0x02	; 2
   1081a:	6d e3       	ldi	r22, 0x3D	; 61
   1081c:	72 e0       	ldi	r23, 0x02	; 2
   1081e:	a7 01       	movw	r20, r14
   10820:	96 01       	movw	r18, r12
   10822:	0e 94 8b 26 	call	0x4d16	; 0x4d16 <StrCalc>
	      sprintf_P(lcdteks,PSTR("A+B:%s"),OutputC);
   10826:	00 d0       	rcall	.+0      	; 0x10828 <FTestCalculation+0x1ac>
   10828:	00 d0       	rcall	.+0      	; 0x1082a <FTestCalculation+0x1ae>
   1082a:	00 d0       	rcall	.+0      	; 0x1082c <FTestCalculation+0x1b0>
   1082c:	ed b7       	in	r30, 0x3d	; 61
   1082e:	fe b7       	in	r31, 0x3e	; 62
   10830:	31 96       	adiw	r30, 0x01	; 1
   10832:	ad b7       	in	r26, 0x3d	; 61
   10834:	be b7       	in	r27, 0x3e	; 62
   10836:	12 96       	adiw	r26, 0x02	; 2
   10838:	1c 93       	st	X, r17
   1083a:	0e 93       	st	-X, r16
   1083c:	11 97       	sbiw	r26, 0x01	; 1
   1083e:	84 eb       	ldi	r24, 0xB4	; 180
   10840:	95 e0       	ldi	r25, 0x05	; 5
   10842:	93 83       	std	Z+3, r25	; 0x03
   10844:	82 83       	std	Z+2, r24	; 0x02
   10846:	d5 82       	std	Z+5, r13	; 0x05
   10848:	c4 82       	std	Z+4, r12	; 0x04
   1084a:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
		  lcd_print(4,1,lcdteks);
   1084e:	8d b7       	in	r24, 0x3d	; 61
   10850:	9e b7       	in	r25, 0x3e	; 62
   10852:	06 96       	adiw	r24, 0x06	; 6
   10854:	0f b6       	in	r0, 0x3f	; 63
   10856:	f8 94       	cli
   10858:	9e bf       	out	0x3e, r25	; 62
   1085a:	0f be       	out	0x3f, r0	; 63
   1085c:	8d bf       	out	0x3d, r24	; 61
   1085e:	84 e0       	ldi	r24, 0x04	; 4
   10860:	61 e0       	ldi	r22, 0x01	; 1
   10862:	a8 01       	movw	r20, r16
   10864:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
          stTestCalc=tcWaitEnter;
   10868:	85 e0       	ldi	r24, 0x05	; 5
   1086a:	65 cf       	rjmp	.-310    	; 0x10736 <FTestCalculation+0xba>
	      break;
     case tcWaitEnter:
	      KeyChar= _key_btn(_key_scan(1));       
   1086c:	81 e0       	ldi	r24, 0x01	; 1
   1086e:	0e 94 ab ae 	call	0x15d56	; 0x15d56 <_key_scan>
   10872:	0e 94 0c ae 	call	0x15c18	; 0x15c18 <_key_btn>
		  if (KeyChar=='#')stTestCalc=tcInitData;
   10876:	83 32       	cpi	r24, 0x23	; 35
   10878:	11 f0       	breq	.+4      	; 0x1087e <FTestCalculation+0x202>
		  else
		  if (KeyChar=='*')stTestCalc=tcInitData;
   1087a:	8a 32       	cpi	r24, 0x2A	; 42
   1087c:	11 f4       	brne	.+4      	; 0x10882 <FTestCalculation+0x206>
   1087e:	10 92 52 02 	sts	0x0252, r1
	      break;	 
	 }
}
   10882:	64 96       	adiw	r28, 0x14	; 20
   10884:	0f b6       	in	r0, 0x3f	; 63
   10886:	f8 94       	cli
   10888:	de bf       	out	0x3e, r29	; 62
   1088a:	0f be       	out	0x3f, r0	; 63
   1088c:	cd bf       	out	0x3d, r28	; 61
   1088e:	cf 91       	pop	r28
   10890:	df 91       	pop	r29
   10892:	1f 91       	pop	r17
   10894:	0f 91       	pop	r16
   10896:	ff 90       	pop	r15
   10898:	ef 90       	pop	r14
   1089a:	df 90       	pop	r13
   1089c:	cf 90       	pop	r12
   1089e:	08 95       	ret

000108a0 <FMenuTicket>:
	    StrResult[2]='0'+Val;
	    StrResult[3]=0;
		}   
}

char FMenuTicket(){
   108a0:	ef 92       	push	r14
   108a2:	0f 93       	push	r16
   108a4:	1f 93       	push	r17
   108a6:	df 93       	push	r29
   108a8:	cf 93       	push	r28
   108aa:	cd b7       	in	r28, 0x3d	; 61
   108ac:	de b7       	in	r29, 0x3e	; 62
   108ae:	64 97       	sbiw	r28, 0x14	; 20
   108b0:	0f b6       	in	r0, 0x3f	; 63
   108b2:	f8 94       	cli
   108b4:	de bf       	out	0x3e, r29	; 62
   108b6:	0f be       	out	0x3f, r0	; 63
   108b8:	cd bf       	out	0x3d, r28	; 61
static char uiResult=USER_NONE,iPos,iSend,KeyPressed,KeyChar,FIP_Used,zFIP_Used;
static unsigned int iLoop=0;
     char Result=MENU_NONE,lcdteks[20];

    Result=MENU_NONE;   
    switch(stMenuTicket){
   108ba:	80 91 d0 02 	lds	r24, 0x02D0
   108be:	86 30       	cpi	r24, 0x06	; 6
   108c0:	09 f4       	brne	.+2      	; 0x108c4 <FMenuTicket+0x24>
   108c2:	c8 c0       	rjmp	.+400    	; 0x10a54 <FMenuTicket+0x1b4>
   108c4:	87 30       	cpi	r24, 0x07	; 7
   108c6:	90 f4       	brcc	.+36     	; 0x108ec <FMenuTicket+0x4c>
   108c8:	82 30       	cpi	r24, 0x02	; 2
   108ca:	09 f4       	brne	.+2      	; 0x108ce <FMenuTicket+0x2e>
   108cc:	3f c0       	rjmp	.+126    	; 0x1094c <FMenuTicket+0xac>
   108ce:	83 30       	cpi	r24, 0x03	; 3
   108d0:	30 f4       	brcc	.+12     	; 0x108de <FMenuTicket+0x3e>
   108d2:	88 23       	and	r24, r24
   108d4:	09 f1       	breq	.+66     	; 0x10918 <FMenuTicket+0x78>
   108d6:	81 30       	cpi	r24, 0x01	; 1
   108d8:	09 f0       	breq	.+2      	; 0x108dc <FMenuTicket+0x3c>
   108da:	33 c1       	rjmp	.+614    	; 0x10b42 <FMenuTicket+0x2a2>
   108dc:	1f c0       	rjmp	.+62     	; 0x1091c <FMenuTicket+0x7c>
   108de:	84 30       	cpi	r24, 0x04	; 4
   108e0:	09 f4       	brne	.+2      	; 0x108e4 <FMenuTicket+0x44>
   108e2:	8d c0       	rjmp	.+282    	; 0x109fe <FMenuTicket+0x15e>
   108e4:	85 30       	cpi	r24, 0x05	; 5
   108e6:	08 f0       	brcs	.+2      	; 0x108ea <FMenuTicket+0x4a>
   108e8:	af c0       	rjmp	.+350    	; 0x10a48 <FMenuTicket+0x1a8>
   108ea:	51 c0       	rjmp	.+162    	; 0x1098e <FMenuTicket+0xee>
   108ec:	89 30       	cpi	r24, 0x09	; 9
   108ee:	09 f4       	brne	.+2      	; 0x108f2 <FMenuTicket+0x52>
   108f0:	03 c1       	rjmp	.+518    	; 0x10af8 <FMenuTicket+0x258>
   108f2:	8a 30       	cpi	r24, 0x0A	; 10
   108f4:	38 f4       	brcc	.+14     	; 0x10904 <FMenuTicket+0x64>
   108f6:	87 30       	cpi	r24, 0x07	; 7
   108f8:	09 f4       	brne	.+2      	; 0x108fc <FMenuTicket+0x5c>
   108fa:	df c0       	rjmp	.+446    	; 0x10aba <FMenuTicket+0x21a>
   108fc:	88 30       	cpi	r24, 0x08	; 8
   108fe:	09 f0       	breq	.+2      	; 0x10902 <FMenuTicket+0x62>
   10900:	20 c1       	rjmp	.+576    	; 0x10b42 <FMenuTicket+0x2a2>
   10902:	cb c0       	rjmp	.+406    	; 0x10a9a <FMenuTicket+0x1fa>
   10904:	8b 30       	cpi	r24, 0x0B	; 11
   10906:	09 f4       	brne	.+2      	; 0x1090a <FMenuTicket+0x6a>
   10908:	fd c0       	rjmp	.+506    	; 0x10b04 <FMenuTicket+0x264>
   1090a:	8b 30       	cpi	r24, 0x0B	; 11
   1090c:	08 f4       	brcc	.+2      	; 0x10910 <FMenuTicket+0x70>
   1090e:	13 c1       	rjmp	.+550    	; 0x10b36 <FMenuTicket+0x296>
   10910:	8c 30       	cpi	r24, 0x0C	; 12
   10912:	09 f0       	breq	.+2      	; 0x10916 <FMenuTicket+0x76>
   10914:	16 c1       	rjmp	.+556    	; 0x10b42 <FMenuTicket+0x2a2>
   10916:	11 c1       	rjmp	.+546    	; 0x10b3a <FMenuTicket+0x29a>
	case mtInit:
		 stMenuTicket=mtPlatNo;
   10918:	81 e0       	ldi	r24, 0x01	; 1
   1091a:	81 c0       	rjmp	.+258    	; 0x10a1e <FMenuTicket+0x17e>
	     break;
    case mtPlatNo:
	     lcd_clear();
   1091c:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
	     lcd_printf(1,1,PSTR("Input Plat No: "));
   10920:	81 e0       	ldi	r24, 0x01	; 1
   10922:	61 e0       	ldi	r22, 0x01	; 1
   10924:	48 ee       	ldi	r20, 0xE8	; 232
   10926:	5a e0       	ldi	r21, 0x0A	; 10
   10928:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
	     lcd_printf(2,1,PSTR("_"));
   1092c:	82 e0       	ldi	r24, 0x02	; 2
   1092e:	61 e0       	ldi	r22, 0x01	; 1
   10930:	46 ee       	ldi	r20, 0xE6	; 230
   10932:	5a e0       	ldi	r21, 0x0A	; 10
   10934:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
	     lcd_printf(4,1,PSTR("[*]Cancel  [#]Enter "));
   10938:	84 e0       	ldi	r24, 0x04	; 4
   1093a:	61 e0       	ldi	r22, 0x01	; 1
   1093c:	41 ed       	ldi	r20, 0xD1	; 209
   1093e:	5a e0       	ldi	r21, 0x0A	; 10
   10940:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		 uiResult=USER_NONE;
   10944:	10 92 cf 02 	sts	0x02CF, r1
		 stMenuTicket=mtInputPlatNo;
   10948:	82 e0       	ldi	r24, 0x02	; 2
   1094a:	69 c0       	rjmp	.+210    	; 0x10a1e <FMenuTicket+0x17e>
	     break;
    case mtInputPlatNo:
	     uiResult=UserInput(UI_ALPHANUM_R,2,1,strLicPlate,0,10);
   1094c:	83 e0       	ldi	r24, 0x03	; 3
   1094e:	62 e0       	ldi	r22, 0x02	; 2
   10950:	41 e0       	ldi	r20, 0x01	; 1
   10952:	22 ed       	ldi	r18, 0xD2	; 210
   10954:	3a e0       	ldi	r19, 0x0A	; 10
   10956:	00 e0       	ldi	r16, 0x00	; 0
   10958:	10 e0       	ldi	r17, 0x00	; 0
   1095a:	7a e0       	ldi	r23, 0x0A	; 10
   1095c:	e7 2e       	mov	r14, r23
   1095e:	0e 94 f0 7b 	call	0xf7e0	; 0xf7e0 <UserInput>
   10962:	80 93 cf 02 	sts	0x02CF, r24
		 if (uiResult==USER_OK)stMenuTicket=mtOdometer;
   10966:	83 30       	cpi	r24, 0x03	; 3
   10968:	09 f4       	brne	.+2      	; 0x1096c <FMenuTicket+0xcc>
   1096a:	59 c0       	rjmp	.+178    	; 0x10a1e <FMenuTicket+0x17e>
		 else
		 if (uiResult==USER_CANCEL)stMenuTicket=mtExitMenuTicket;
   1096c:	81 30       	cpi	r24, 0x01	; 1
   1096e:	09 f4       	brne	.+2      	; 0x10972 <FMenuTicket+0xd2>
   10970:	e2 c0       	rjmp	.+452    	; 0x10b36 <FMenuTicket+0x296>
         else
		 if (uiResult==USER_ENTRY)lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   10972:	84 30       	cpi	r24, 0x04	; 4
   10974:	21 f4       	brne	.+8      	; 0x1097e <FMenuTicket+0xde>
   10976:	61 e0       	ldi	r22, 0x01	; 1
   10978:	4c eb       	ldi	r20, 0xBC	; 188
   1097a:	5a e0       	ldi	r21, 0x0A	; 10
   1097c:	62 c0       	rjmp	.+196    	; 0x10a42 <FMenuTicket+0x1a2>
		 else
		 if (uiResult==USER_NO_DATA)lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   1097e:	85 30       	cpi	r24, 0x05	; 5
   10980:	09 f0       	breq	.+2      	; 0x10984 <FMenuTicket+0xe4>
   10982:	df c0       	rjmp	.+446    	; 0x10b42 <FMenuTicket+0x2a2>
   10984:	84 e0       	ldi	r24, 0x04	; 4
   10986:	61 e0       	ldi	r22, 0x01	; 1
   10988:	47 ea       	ldi	r20, 0xA7	; 167
   1098a:	5a e0       	ldi	r21, 0x0A	; 10
   1098c:	5a c0       	rjmp	.+180    	; 0x10a42 <FMenuTicket+0x1a2>
	     break;
    case mtOdometer:
	     lcd_clear();
   1098e:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
		 sprintf_P(lcdteks,PSTR("Plat No: %s "),strLicPlate);
   10992:	00 d0       	rcall	.+0      	; 0x10994 <FMenuTicket+0xf4>
   10994:	00 d0       	rcall	.+0      	; 0x10996 <FMenuTicket+0xf6>
   10996:	00 d0       	rcall	.+0      	; 0x10998 <FMenuTicket+0xf8>
   10998:	ed b7       	in	r30, 0x3d	; 61
   1099a:	fe b7       	in	r31, 0x3e	; 62
   1099c:	31 96       	adiw	r30, 0x01	; 1
   1099e:	8e 01       	movw	r16, r28
   109a0:	0f 5f       	subi	r16, 0xFF	; 255
   109a2:	1f 4f       	sbci	r17, 0xFF	; 255
   109a4:	ad b7       	in	r26, 0x3d	; 61
   109a6:	be b7       	in	r27, 0x3e	; 62
   109a8:	12 96       	adiw	r26, 0x02	; 2
   109aa:	1c 93       	st	X, r17
   109ac:	0e 93       	st	-X, r16
   109ae:	11 97       	sbiw	r26, 0x01	; 1
   109b0:	8a e9       	ldi	r24, 0x9A	; 154
   109b2:	9a e0       	ldi	r25, 0x0A	; 10
   109b4:	93 83       	std	Z+3, r25	; 0x03
   109b6:	82 83       	std	Z+2, r24	; 0x02
   109b8:	82 ed       	ldi	r24, 0xD2	; 210
   109ba:	9a e0       	ldi	r25, 0x0A	; 10
   109bc:	95 83       	std	Z+5, r25	; 0x05
   109be:	84 83       	std	Z+4, r24	; 0x04
   109c0:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
	     lcd_print(1,1,lcdteks);
   109c4:	8d b7       	in	r24, 0x3d	; 61
   109c6:	9e b7       	in	r25, 0x3e	; 62
   109c8:	06 96       	adiw	r24, 0x06	; 6
   109ca:	0f b6       	in	r0, 0x3f	; 63
   109cc:	f8 94       	cli
   109ce:	9e bf       	out	0x3e, r25	; 62
   109d0:	0f be       	out	0x3f, r0	; 63
   109d2:	8d bf       	out	0x3d, r24	; 61
   109d4:	81 e0       	ldi	r24, 0x01	; 1
   109d6:	61 e0       	ldi	r22, 0x01	; 1
   109d8:	a8 01       	movw	r20, r16
   109da:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
	     lcd_printf(2,1,PSTR("Odometer:_ "));
   109de:	82 e0       	ldi	r24, 0x02	; 2
   109e0:	61 e0       	ldi	r22, 0x01	; 1
   109e2:	4e e8       	ldi	r20, 0x8E	; 142
   109e4:	5a e0       	ldi	r21, 0x0A	; 10
   109e6:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
	     lcd_printf(4,1,PSTR("[*]Cancel  [#]Enter "));
   109ea:	84 e0       	ldi	r24, 0x04	; 4
   109ec:	61 e0       	ldi	r22, 0x01	; 1
   109ee:	49 e7       	ldi	r20, 0x79	; 121
   109f0:	5a e0       	ldi	r21, 0x0A	; 10
   109f2:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		 uiResult=USER_NONE;
   109f6:	10 92 cf 02 	sts	0x02CF, r1
		 stMenuTicket=mtInputOdometer;
   109fa:	84 e0       	ldi	r24, 0x04	; 4
   109fc:	10 c0       	rjmp	.+32     	; 0x10a1e <FMenuTicket+0x17e>
	     break;
    case mtInputOdometer:
	     uiResult=UserInput(UI_NUMBER_R,2,10,strOdometer,0,10);
   109fe:	81 e0       	ldi	r24, 0x01	; 1
   10a00:	62 e0       	ldi	r22, 0x02	; 2
   10a02:	4a e0       	ldi	r20, 0x0A	; 10
   10a04:	23 ea       	ldi	r18, 0xA3	; 163
   10a06:	35 e0       	ldi	r19, 0x05	; 5
   10a08:	00 e0       	ldi	r16, 0x00	; 0
   10a0a:	10 e0       	ldi	r17, 0x00	; 0
   10a0c:	5a e0       	ldi	r21, 0x0A	; 10
   10a0e:	e5 2e       	mov	r14, r21
   10a10:	0e 94 f0 7b 	call	0xf7e0	; 0xf7e0 <UserInput>
   10a14:	80 93 cf 02 	sts	0x02CF, r24
		 if (uiResult==USER_OK)stMenuTicket=mtFIP;
   10a18:	83 30       	cpi	r24, 0x03	; 3
   10a1a:	21 f4       	brne	.+8      	; 0x10a24 <FMenuTicket+0x184>
   10a1c:	85 e0       	ldi	r24, 0x05	; 5
   10a1e:	80 93 d0 02 	sts	0x02D0, r24
   10a22:	8f c0       	rjmp	.+286    	; 0x10b42 <FMenuTicket+0x2a2>
		 else
		 if (uiResult==USER_CANCEL)stMenuTicket=mtPlatNo;
   10a24:	81 30       	cpi	r24, 0x01	; 1
   10a26:	d9 f3       	breq	.-10     	; 0x10a1e <FMenuTicket+0x17e>
		 else
		 if (uiResult==USER_ENTRY)lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   10a28:	84 30       	cpi	r24, 0x04	; 4
   10a2a:	21 f4       	brne	.+8      	; 0x10a34 <FMenuTicket+0x194>
   10a2c:	61 e0       	ldi	r22, 0x01	; 1
   10a2e:	44 e6       	ldi	r20, 0x64	; 100
   10a30:	5a e0       	ldi	r21, 0x0A	; 10
   10a32:	07 c0       	rjmp	.+14     	; 0x10a42 <FMenuTicket+0x1a2>
		 else
		 if (uiResult==USER_NO_DATA)lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   10a34:	85 30       	cpi	r24, 0x05	; 5
   10a36:	09 f0       	breq	.+2      	; 0x10a3a <FMenuTicket+0x19a>
   10a38:	84 c0       	rjmp	.+264    	; 0x10b42 <FMenuTicket+0x2a2>
   10a3a:	84 e0       	ldi	r24, 0x04	; 4
   10a3c:	61 e0       	ldi	r22, 0x01	; 1
   10a3e:	4f e4       	ldi	r20, 0x4F	; 79
   10a40:	5a e0       	ldi	r21, 0x0A	; 10
   10a42:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
   10a46:	7d c0       	rjmp	.+250    	; 0x10b42 <FMenuTicket+0x2a2>
	     break;
    case mtFIP:
	     lcd_clear();
   10a48:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
		 _scr_pump();
   10a4c:	0e 94 77 42 	call	0x84ee	; 0x84ee <_scr_pump>
		 stMenuTicket=mtInputFIP;
   10a50:	86 e0       	ldi	r24, 0x06	; 6
   10a52:	e5 cf       	rjmp	.-54     	; 0x10a1e <FMenuTicket+0x17e>
	     break;
    case mtInputFIP:
	     KeyPressed=_key_scan(1);
   10a54:	81 e0       	ldi	r24, 0x01	; 1
   10a56:	0e 94 ab ae 	call	0x15d56	; 0x15d56 <_key_scan>
   10a5a:	80 93 cc 02 	sts	0x02CC, r24
		 KeyChar=_key_btn(KeyPressed);
   10a5e:	0e 94 0c ae 	call	0x15c18	; 0x15c18 <_key_btn>
   10a62:	80 93 cb 02 	sts	0x02CB, r24
		 if ((KeyChar>='1')&&(KeyChar<='8')){
   10a66:	81 53       	subi	r24, 0x31	; 49
   10a68:	88 30       	cpi	r24, 0x08	; 8
   10a6a:	40 f4       	brcc	.+16     	; 0x10a7c <FMenuTicket+0x1dc>
		     FIP_Used=KeyChar-'0';
   10a6c:	8f 5f       	subi	r24, 0xFF	; 255
   10a6e:	80 93 ca 02 	sts	0x02CA, r24
			 zFIP_Used=FIP_Used;
   10a72:	80 93 c9 02 	sts	0x02C9, r24
		     stMenuTicket=mtSendMsg98;
   10a76:	87 e0       	ldi	r24, 0x07	; 7
   10a78:	80 93 d0 02 	sts	0x02D0, r24
		 }
		 if (KeyPressed==_KEY_CANCEL){
   10a7c:	80 91 cc 02 	lds	r24, 0x02CC
   10a80:	87 3e       	cpi	r24, 0xE7	; 231
   10a82:	11 f4       	brne	.+4      	; 0x10a88 <FMenuTicket+0x1e8>
             stMenuTicket=mtOdometer;
   10a84:	83 e0       	ldi	r24, 0x03	; 3
   10a86:	cb cf       	rjmp	.-106    	; 0x10a1e <FMenuTicket+0x17e>
		 }else
		 if (KeyPressed==_KEY_ENTER){
   10a88:	87 3b       	cpi	r24, 0xB7	; 183
   10a8a:	09 f0       	breq	.+2      	; 0x10a8e <FMenuTicket+0x1ee>
   10a8c:	5a c0       	rjmp	.+180    	; 0x10b42 <FMenuTicket+0x2a2>
		     FIP_Used=zFIP_Used;
   10a8e:	80 91 c9 02 	lds	r24, 0x02C9
   10a92:	80 93 ca 02 	sts	0x02CA, r24
             stMenuTicket=mtInitWaitMessage99;
   10a96:	88 e0       	ldi	r24, 0x08	; 8
   10a98:	c2 cf       	rjmp	.-124    	; 0x10a1e <FMenuTicket+0x17e>
		 }
	     break;	
    case mtInitWaitMessage99:
	     lcd_clear();
   10a9a:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
		 lcd_printf(2,1,PSTR("Send Request"));
   10a9e:	82 e0       	ldi	r24, 0x02	; 2
   10aa0:	61 e0       	ldi	r22, 0x01	; 1
   10aa2:	42 e4       	ldi	r20, 0x42	; 66
   10aa4:	5a e0       	ldi	r21, 0x0A	; 10
   10aa6:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		 lcd_printf(3,1,PSTR("Proses"));
   10aaa:	83 e0       	ldi	r24, 0x03	; 3
   10aac:	61 e0       	ldi	r22, 0x01	; 1
   10aae:	4b e3       	ldi	r20, 0x3B	; 59
   10ab0:	5a e0       	ldi	r21, 0x0A	; 10
   10ab2:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
         stMenuTicket=mtSendMsg98;
   10ab6:	87 e0       	ldi	r24, 0x07	; 7
   10ab8:	b2 cf       	rjmp	.-156    	; 0x10a1e <FMenuTicket+0x17e>
	     break;
    case mtSendMsg98:
	     iPos=0;
   10aba:	10 92 ce 02 	sts	0x02CE, r1
		 iSend=0;
   10abe:	10 92 cd 02 	sts	0x02CD, r1
		 IsMessage99=False;
   10ac2:	10 92 b6 01 	sts	0x01B6, r1
		 TimSend=0;
   10ac6:	10 92 a9 01 	sts	0x01A9, r1
   10aca:	10 92 a8 01 	sts	0x01A8, r1
		 iLoop=0;
   10ace:	10 92 c8 02 	sts	0x02C8, r1
   10ad2:	10 92 c7 02 	sts	0x02C7, r1
		 if (IFType==IT_SLAVE)sendMessage98(FIP_Used);
   10ad6:	80 91 10 01 	lds	r24, 0x0110
   10ada:	81 30       	cpi	r24, 0x01	; 1
   10adc:	29 f4       	brne	.+10     	; 0x10ae8 <FMenuTicket+0x248>
   10ade:	80 91 ca 02 	lds	r24, 0x02CA
   10ae2:	0e 94 84 4c 	call	0x9908	; 0x9908 <sendMessage98>
   10ae6:	27 c0       	rjmp	.+78     	; 0x10b36 <FMenuTicket+0x296>
		 else 
		 if (IFType==IT_STANDALONE)PrintStandalone(FIP_Used,False);
   10ae8:	82 30       	cpi	r24, 0x02	; 2
   10aea:	29 f5       	brne	.+74     	; 0x10b36 <FMenuTicket+0x296>
   10aec:	80 91 ca 02 	lds	r24, 0x02CA
   10af0:	60 e0       	ldi	r22, 0x00	; 0
   10af2:	0e 94 bb 1f 	call	0x3f76	; 0x3f76 <PrintStandalone>
   10af6:	1f c0       	rjmp	.+62     	; 0x10b36 <FMenuTicket+0x296>
	                     stMenuTicket=mtSendMsg98;
				  }
			 }
		 }
		 */
		 if (IsMessage99==True){ 
   10af8:	80 91 b6 01 	lds	r24, 0x01B6
   10afc:	81 30       	cpi	r24, 0x01	; 1
   10afe:	09 f5       	brne	.+66     	; 0x10b42 <FMenuTicket+0x2a2>
		    stMenuTicket=mtMessage99Received;
   10b00:	8a e0       	ldi	r24, 0x0A	; 10
   10b02:	8d cf       	rjmp	.-230    	; 0x10a1e <FMenuTicket+0x17e>
	     break;
    case mtMessage99Received:
	     stMenuTicket=mtExitMenuTicket;
		 break;
    case mtNoConnection:
	     lcd_clear();
   10b04:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
		 lcd_printf(2,1,PSTR("Error No Connection"));
   10b08:	82 e0       	ldi	r24, 0x02	; 2
   10b0a:	61 e0       	ldi	r22, 0x01	; 1
   10b0c:	47 e2       	ldi	r20, 0x27	; 39
   10b0e:	5a e0       	ldi	r21, 0x0A	; 10
   10b10:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   10b14:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   10b16:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   10b18:	82 e0       	ldi	r24, 0x02	; 2
   10b1a:	90 e0       	ldi	r25, 0x00	; 0
   10b1c:	90 93 d7 01 	sts	0x01D7, r25
   10b20:	80 93 d6 01 	sts	0x01D6, r24
   10b24:	80 e2       	ldi	r24, 0x20	; 32
   10b26:	9e e4       	ldi	r25, 0x4E	; 78
   10b28:	29 e1       	ldi	r18, 0x19	; 25
   10b2a:	30 e0       	ldi	r19, 0x00	; 0
   10b2c:	f9 01       	movw	r30, r18
   10b2e:	31 97       	sbiw	r30, 0x01	; 1
   10b30:	f1 f7       	brne	.-4      	; 0x10b2e <FMenuTicket+0x28e>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
   10b32:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
   10b34:	d9 f7       	brne	.-10     	; 0x10b2c <FMenuTicket+0x28c>
    case mtNoConnection:
	     lcd_clear();
		 lcd_printf(2,1,PSTR("Error No Connection"));
		 system_beep(2);
		 _delay_ms(2000);
         stMenuTicket=mtExitMenuTicket;
   10b36:	8c e0       	ldi	r24, 0x0C	; 12
   10b38:	72 cf       	rjmp	.-284    	; 0x10a1e <FMenuTicket+0x17e>
	     break;
    case mtExitMenuTicket:
	     Result=MENU_DONE;
	     stMenuTicket=mtInit;
   10b3a:	10 92 d0 02 	sts	0x02D0, r1
   10b3e:	81 e0       	ldi	r24, 0x01	; 1
   10b40:	01 c0       	rjmp	.+2      	; 0x10b44 <FMenuTicket+0x2a4>
   10b42:	80 e0       	ldi	r24, 0x00	; 0
	     break;
	}
  return Result;
}
   10b44:	64 96       	adiw	r28, 0x14	; 20
   10b46:	0f b6       	in	r0, 0x3f	; 63
   10b48:	f8 94       	cli
   10b4a:	de bf       	out	0x3e, r29	; 62
   10b4c:	0f be       	out	0x3f, r0	; 63
   10b4e:	cd bf       	out	0x3d, r28	; 61
   10b50:	cf 91       	pop	r28
   10b52:	df 91       	pop	r29
   10b54:	1f 91       	pop	r17
   10b56:	0f 91       	pop	r16
   10b58:	ef 90       	pop	r14
   10b5a:	08 95       	ret

00010b5c <FSettingOperator>:
char FSettingHost(){
     _menu_host();
	 return MENU_DONE;
}

char FSettingOperator(){//Change Active Operator, Change Password
   10b5c:	ef 92       	push	r14
   10b5e:	0f 93       	push	r16
   10b60:	1f 93       	push	r17
   10b62:	df 93       	push	r29
   10b64:	cf 93       	push	r28
   10b66:	cd b7       	in	r28, 0x3d	; 61
   10b68:	de b7       	in	r29, 0x3e	; 62
   10b6a:	e5 97       	sbiw	r28, 0x35	; 53
   10b6c:	0f b6       	in	r0, 0x3f	; 63
   10b6e:	f8 94       	cli
   10b70:	de bf       	out	0x3e, r29	; 62
   10b72:	0f be       	out	0x3f, r0	; 63
   10b74:	cd bf       	out	0x3d, r28	; 61
	        char KeyPressed,KeyChar,lcdteks[20],strPassword[15];
			char strOperatorName[18];
			char uiResult=USER_NONE,Result=MENU_NONE;
     //_menu_user();
	 Result=MENU_NONE;
	 switch(stSettingOperator){
   10b76:	80 91 e2 02 	lds	r24, 0x02E2
   10b7a:	87 30       	cpi	r24, 0x07	; 7
   10b7c:	09 f4       	brne	.+2      	; 0x10b80 <FSettingOperator+0x24>
   10b7e:	75 c1       	rjmp	.+746    	; 0x10e6a <FSettingOperator+0x30e>
   10b80:	88 30       	cpi	r24, 0x08	; 8
   10b82:	90 f4       	brcc	.+36     	; 0x10ba8 <FSettingOperator+0x4c>
   10b84:	83 30       	cpi	r24, 0x03	; 3
   10b86:	09 f4       	brne	.+2      	; 0x10b8a <FSettingOperator+0x2e>
   10b88:	9a c0       	rjmp	.+308    	; 0x10cbe <FSettingOperator+0x162>
   10b8a:	84 30       	cpi	r24, 0x04	; 4
   10b8c:	30 f4       	brcc	.+12     	; 0x10b9a <FSettingOperator+0x3e>
   10b8e:	81 30       	cpi	r24, 0x01	; 1
   10b90:	a1 f1       	breq	.+104    	; 0x10bfa <FSettingOperator+0x9e>
   10b92:	82 30       	cpi	r24, 0x02	; 2
   10b94:	08 f0       	brcs	.+2      	; 0x10b98 <FSettingOperator+0x3c>
   10b96:	44 c0       	rjmp	.+136    	; 0x10c20 <FSettingOperator+0xc4>
   10b98:	20 c0       	rjmp	.+64     	; 0x10bda <FSettingOperator+0x7e>
   10b9a:	85 30       	cpi	r24, 0x05	; 5
   10b9c:	09 f4       	brne	.+2      	; 0x10ba0 <FSettingOperator+0x44>
   10b9e:	36 c1       	rjmp	.+620    	; 0x10e0c <FSettingOperator+0x2b0>
   10ba0:	86 30       	cpi	r24, 0x06	; 6
   10ba2:	08 f0       	brcs	.+2      	; 0x10ba6 <FSettingOperator+0x4a>
   10ba4:	4f c1       	rjmp	.+670    	; 0x10e44 <FSettingOperator+0x2e8>
   10ba6:	f9 c0       	rjmp	.+498    	; 0x10d9a <FSettingOperator+0x23e>
   10ba8:	8b 30       	cpi	r24, 0x0B	; 11
   10baa:	09 f4       	brne	.+2      	; 0x10bae <FSettingOperator+0x52>
   10bac:	20 c2       	rjmp	.+1088   	; 0x10fee <FSettingOperator+0x492>
   10bae:	8c 30       	cpi	r24, 0x0C	; 12
   10bb0:	38 f4       	brcc	.+14     	; 0x10bc0 <FSettingOperator+0x64>
   10bb2:	89 30       	cpi	r24, 0x09	; 9
   10bb4:	09 f4       	brne	.+2      	; 0x10bb8 <FSettingOperator+0x5c>
   10bb6:	a7 c1       	rjmp	.+846    	; 0x10f06 <FSettingOperator+0x3aa>
   10bb8:	8a 30       	cpi	r24, 0x0A	; 10
   10bba:	08 f0       	brcs	.+2      	; 0x10bbe <FSettingOperator+0x62>
   10bbc:	d7 c1       	rjmp	.+942    	; 0x10f6c <FSettingOperator+0x410>
   10bbe:	75 c1       	rjmp	.+746    	; 0x10eaa <FSettingOperator+0x34e>
   10bc0:	8d 30       	cpi	r24, 0x0D	; 13
   10bc2:	09 f4       	brne	.+2      	; 0x10bc6 <FSettingOperator+0x6a>
   10bc4:	a1 c2       	rjmp	.+1346   	; 0x11108 <FSettingOperator+0x5ac>
   10bc6:	8d 30       	cpi	r24, 0x0D	; 13
   10bc8:	08 f4       	brcc	.+2      	; 0x10bcc <FSettingOperator+0x70>
   10bca:	18 c2       	rjmp	.+1072   	; 0x10ffc <FSettingOperator+0x4a0>
   10bcc:	8e 30       	cpi	r24, 0x0E	; 14
   10bce:	09 f4       	brne	.+2      	; 0x10bd2 <FSettingOperator+0x76>
   10bd0:	a0 c2       	rjmp	.+1344   	; 0x11112 <FSettingOperator+0x5b6>
   10bd2:	8f 30       	cpi	r24, 0x0F	; 15
   10bd4:	09 f0       	breq	.+2      	; 0x10bd8 <FSettingOperator+0x7c>
   10bd6:	a8 c2       	rjmp	.+1360   	; 0x11128 <FSettingOperator+0x5cc>
   10bd8:	a3 c2       	rjmp	.+1350   	; 0x11120 <FSettingOperator+0x5c4>
	 case soMenuOption:
	      lcd_clear();
   10bda:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
		  lcd_printf(1,1,PSTR("1.Change Operator"));
   10bde:	81 e0       	ldi	r24, 0x01	; 1
   10be0:	61 e0       	ldi	r22, 0x01	; 1
   10be2:	41 ed       	ldi	r20, 0xD1	; 209
   10be4:	50 e1       	ldi	r21, 0x10	; 16
   10be6:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		  lcd_printf(2,1,PSTR("2.Change Password"));
   10bea:	82 e0       	ldi	r24, 0x02	; 2
   10bec:	61 e0       	ldi	r22, 0x01	; 1
   10bee:	4f eb       	ldi	r20, 0xBF	; 191
   10bf0:	50 e1       	ldi	r21, 0x10	; 16
   10bf2:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
          stSettingOperator=soMenuOptionInput;
   10bf6:	81 e0       	ldi	r24, 0x01	; 1
   10bf8:	6d c2       	rjmp	.+1242   	; 0x110d4 <FSettingOperator+0x578>
	      break;
     case soMenuOptionInput:
	      KeyPressed=_key_scan(1);
   10bfa:	81 e0       	ldi	r24, 0x01	; 1
   10bfc:	0e 94 ab ae 	call	0x15d56	; 0x15d56 <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
   10c00:	0e 94 0c ae 	call	0x15c18	; 0x15c18 <_key_btn>
		  switch(KeyChar){
   10c04:	81 33       	cpi	r24, 0x31	; 49
   10c06:	31 f0       	breq	.+12     	; 0x10c14 <FSettingOperator+0xb8>
   10c08:	82 33       	cpi	r24, 0x32	; 50
   10c0a:	31 f0       	breq	.+12     	; 0x10c18 <FSettingOperator+0xbc>
   10c0c:	8a 32       	cpi	r24, 0x2A	; 42
   10c0e:	09 f0       	breq	.+2      	; 0x10c12 <FSettingOperator+0xb6>
   10c10:	8b c2       	rjmp	.+1302   	; 0x11128 <FSettingOperator+0x5cc>
   10c12:	04 c0       	rjmp	.+8      	; 0x10c1c <FSettingOperator+0xc0>
		  case '1':
		       stSettingOperator=soChangeOperatorInit;
   10c14:	82 e0       	ldi	r24, 0x02	; 2
   10c16:	5e c2       	rjmp	.+1212   	; 0x110d4 <FSettingOperator+0x578>
		       break;
          case '2':
		       stSettingOperator=soChangePasswordInit;
   10c18:	85 e0       	ldi	r24, 0x05	; 5
   10c1a:	5c c2       	rjmp	.+1208   	; 0x110d4 <FSettingOperator+0x578>
		       break;
          case '*':
		       stSettingOperator=soExitSettingOperator;
   10c1c:	8f e0       	ldi	r24, 0x0F	; 15
   10c1e:	5a c2       	rjmp	.+1204   	; 0x110d4 <FSettingOperator+0x578>
		       break;
		  }
	      break;
     case soChangeOperatorInit:
	      lcd_clear();		  
   10c20:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
   10c24:	8e 01       	movw	r16, r28
   10c26:	00 5f       	subi	r16, 0xF0	; 240
   10c28:	1f 4f       	sbci	r17, 0xFF	; 255
   10c2a:	c8 01       	movw	r24, r16
   10c2c:	65 e1       	ldi	r22, 0x15	; 21
   10c2e:	70 e0       	ldi	r23, 0x00	; 0
   10c30:	42 e1       	ldi	r20, 0x12	; 18
   10c32:	50 e0       	ldi	r21, 0x00	; 0
   10c34:	23 ef       	ldi	r18, 0xF3	; 243
   10c36:	32 e1       	ldi	r19, 0x12	; 18
   10c38:	0e 94 1f b4 	call	0x1683e	; 0x1683e <__eerd_block>
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   10c3c:	98 01       	movw	r18, r16
   10c3e:	ce 01       	movw	r24, r28
   10c40:	4f 96       	adiw	r24, 0x1f	; 31
	    Dest[i]=Source[IdxSource+i];
   10c42:	0f 5f       	subi	r16, 0xFF	; 255
   10c44:	1f 4f       	sbci	r17, 0xFF	; 255
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   10c46:	08 17       	cp	r16, r24
   10c48:	19 07       	cpc	r17, r25
   10c4a:	d9 f7       	brne	.-10     	; 0x10c42 <FSettingOperator+0xe6>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   10c4c:	1f 8e       	std	Y+31, r1	; 0x1f
     case soChangeOperatorInit:
	      lcd_clear();		  
		  eeprom_read_block((void*) &strOperatorName, (const void*) &DefOperatorName,18);
		  StrPosCopy(strOperatorName,strOperatorName,0,15);

		  sprintf_P(lcdteks,PSTR("%s"),strOperatorName);
   10c4e:	00 d0       	rcall	.+0      	; 0x10c50 <FSettingOperator+0xf4>
   10c50:	00 d0       	rcall	.+0      	; 0x10c52 <FSettingOperator+0xf6>
   10c52:	00 d0       	rcall	.+0      	; 0x10c54 <FSettingOperator+0xf8>
   10c54:	ed b7       	in	r30, 0x3d	; 61
   10c56:	fe b7       	in	r31, 0x3e	; 62
   10c58:	31 96       	adiw	r30, 0x01	; 1
   10c5a:	8e 01       	movw	r16, r28
   10c5c:	0e 5d       	subi	r16, 0xDE	; 222
   10c5e:	1f 4f       	sbci	r17, 0xFF	; 255
   10c60:	ad b7       	in	r26, 0x3d	; 61
   10c62:	be b7       	in	r27, 0x3e	; 62
   10c64:	12 96       	adiw	r26, 0x02	; 2
   10c66:	1c 93       	st	X, r17
   10c68:	0e 93       	st	-X, r16
   10c6a:	11 97       	sbiw	r26, 0x01	; 1
   10c6c:	8c eb       	ldi	r24, 0xBC	; 188
   10c6e:	90 e1       	ldi	r25, 0x10	; 16
   10c70:	93 83       	std	Z+3, r25	; 0x03
   10c72:	82 83       	std	Z+2, r24	; 0x02
   10c74:	24 83       	std	Z+4, r18	; 0x04
   10c76:	35 83       	std	Z+5, r19	; 0x05
   10c78:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
		  lcd_printf(1,1,PSTR("Name:"));
   10c7c:	8d b7       	in	r24, 0x3d	; 61
   10c7e:	9e b7       	in	r25, 0x3e	; 62
   10c80:	06 96       	adiw	r24, 0x06	; 6
   10c82:	0f b6       	in	r0, 0x3f	; 63
   10c84:	f8 94       	cli
   10c86:	9e bf       	out	0x3e, r25	; 62
   10c88:	0f be       	out	0x3f, r0	; 63
   10c8a:	8d bf       	out	0x3d, r24	; 61
   10c8c:	81 e0       	ldi	r24, 0x01	; 1
   10c8e:	61 e0       	ldi	r22, 0x01	; 1
   10c90:	46 eb       	ldi	r20, 0xB6	; 182
   10c92:	50 e1       	ldi	r21, 0x10	; 16
   10c94:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		  lcd_print (1,6,lcdteks);
   10c98:	81 e0       	ldi	r24, 0x01	; 1
   10c9a:	66 e0       	ldi	r22, 0x06	; 6
   10c9c:	a8 01       	movw	r20, r16
   10c9e:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
		  lcd_printf(2,1,PSTR("New :_              "));
   10ca2:	82 e0       	ldi	r24, 0x02	; 2
   10ca4:	61 e0       	ldi	r22, 0x01	; 1
   10ca6:	41 ea       	ldi	r20, 0xA1	; 161
   10ca8:	50 e1       	ldi	r21, 0x10	; 16
   10caa:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		  lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   10cae:	84 e0       	ldi	r24, 0x04	; 4
   10cb0:	61 e0       	ldi	r22, 0x01	; 1
   10cb2:	4c e8       	ldi	r20, 0x8C	; 140
   10cb4:	50 e1       	ldi	r21, 0x10	; 16
   10cb6:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
          stSettingOperator=soOperatorNameInput;
   10cba:	83 e0       	ldi	r24, 0x03	; 3
   10cbc:	0b c2       	rjmp	.+1046   	; 0x110d4 <FSettingOperator+0x578>
	      break;
     case soOperatorNameInput:
          uiResult=USER_NONE;
	      uiResult=UserInput(UI_ALPHANUM_R,2,6,strFreeMessageLine1,0,16);
   10cbe:	83 e0       	ldi	r24, 0x03	; 3
   10cc0:	62 e0       	ldi	r22, 0x02	; 2
   10cc2:	46 e0       	ldi	r20, 0x06	; 6
   10cc4:	27 e9       	ldi	r18, 0x97	; 151
   10cc6:	3a e0       	ldi	r19, 0x0A	; 10
   10cc8:	00 e0       	ldi	r16, 0x00	; 0
   10cca:	10 e0       	ldi	r17, 0x00	; 0
   10ccc:	b0 e1       	ldi	r27, 0x10	; 16
   10cce:	eb 2e       	mov	r14, r27
   10cd0:	0e 94 f0 7b 	call	0xf7e0	; 0xf7e0 <UserInput>
		  switch(uiResult){
   10cd4:	83 30       	cpi	r24, 0x03	; 3
   10cd6:	51 f0       	breq	.+20     	; 0x10cec <FSettingOperator+0x190>
   10cd8:	84 30       	cpi	r24, 0x04	; 4
   10cda:	08 f4       	brcc	.+2      	; 0x10cde <FSettingOperator+0x182>
   10cdc:	f5 c0       	rjmp	.+490    	; 0x10ec8 <FSettingOperator+0x36c>
   10cde:	84 30       	cpi	r24, 0x04	; 4
   10ce0:	09 f4       	brne	.+2      	; 0x10ce4 <FSettingOperator+0x188>
   10ce2:	51 c0       	rjmp	.+162    	; 0x10d86 <FSettingOperator+0x22a>
   10ce4:	85 30       	cpi	r24, 0x05	; 5
   10ce6:	09 f0       	breq	.+2      	; 0x10cea <FSettingOperator+0x18e>
   10ce8:	1f c2       	rjmp	.+1086   	; 0x11128 <FSettingOperator+0x5cc>
   10cea:	52 c0       	rjmp	.+164    	; 0x10d90 <FSettingOperator+0x234>
		  case USER_OK:
		       lcd_clear();
   10cec:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
   10cf0:	20 e0       	ldi	r18, 0x00	; 0
   10cf2:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   10cf4:	ae 01       	movw	r20, r28
   10cf6:	40 5f       	subi	r20, 0xF0	; 240
   10cf8:	5f 4f       	sbci	r21, 0xFF	; 255
   10cfa:	fa 01       	movw	r30, r20
   10cfc:	e2 0f       	add	r30, r18
   10cfe:	f3 1f       	adc	r31, r19
   10d00:	d9 01       	movw	r26, r18
   10d02:	a9 56       	subi	r26, 0x69	; 105
   10d04:	b5 4f       	sbci	r27, 0xF5	; 245
   10d06:	8c 91       	ld	r24, X
   10d08:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   10d0a:	2f 5f       	subi	r18, 0xFF	; 255
   10d0c:	3f 4f       	sbci	r19, 0xFF	; 255
   10d0e:	2f 30       	cpi	r18, 0x0F	; 15
   10d10:	31 05       	cpc	r19, r1
   10d12:	99 f7       	brne	.-26     	; 0x10cfa <FSettingOperator+0x19e>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   10d14:	1f 8e       	std	Y+31, r1	; 0x1f
	      uiResult=UserInput(UI_ALPHANUM_R,2,6,strFreeMessageLine1,0,16);
		  switch(uiResult){
		  case USER_OK:
		       lcd_clear();
			   StrPosCopy(strFreeMessageLine1,strOperatorName,0,15);
		       sprintf_P(lcdteks,PSTR("%s"),strOperatorName);
   10d16:	00 d0       	rcall	.+0      	; 0x10d18 <FSettingOperator+0x1bc>
   10d18:	00 d0       	rcall	.+0      	; 0x10d1a <FSettingOperator+0x1be>
   10d1a:	00 d0       	rcall	.+0      	; 0x10d1c <FSettingOperator+0x1c0>
   10d1c:	ed b7       	in	r30, 0x3d	; 61
   10d1e:	fe b7       	in	r31, 0x3e	; 62
   10d20:	31 96       	adiw	r30, 0x01	; 1
   10d22:	8e 01       	movw	r16, r28
   10d24:	0e 5d       	subi	r16, 0xDE	; 222
   10d26:	1f 4f       	sbci	r17, 0xFF	; 255
   10d28:	ad b7       	in	r26, 0x3d	; 61
   10d2a:	be b7       	in	r27, 0x3e	; 62
   10d2c:	12 96       	adiw	r26, 0x02	; 2
   10d2e:	1c 93       	st	X, r17
   10d30:	0e 93       	st	-X, r16
   10d32:	11 97       	sbiw	r26, 0x01	; 1
   10d34:	89 e8       	ldi	r24, 0x89	; 137
   10d36:	90 e1       	ldi	r25, 0x10	; 16
   10d38:	93 83       	std	Z+3, r25	; 0x03
   10d3a:	82 83       	std	Z+2, r24	; 0x02
   10d3c:	55 83       	std	Z+5, r21	; 0x05
   10d3e:	44 83       	std	Z+4, r20	; 0x04
   10d40:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
			   lcd_printf(1,1,PSTR("New Operator:"));
   10d44:	8d b7       	in	r24, 0x3d	; 61
   10d46:	9e b7       	in	r25, 0x3e	; 62
   10d48:	06 96       	adiw	r24, 0x06	; 6
   10d4a:	0f b6       	in	r0, 0x3f	; 63
   10d4c:	f8 94       	cli
   10d4e:	9e bf       	out	0x3e, r25	; 62
   10d50:	0f be       	out	0x3f, r0	; 63
   10d52:	8d bf       	out	0x3d, r24	; 61
   10d54:	81 e0       	ldi	r24, 0x01	; 1
   10d56:	61 e0       	ldi	r22, 0x01	; 1
   10d58:	4b e7       	ldi	r20, 0x7B	; 123
   10d5a:	50 e1       	ldi	r21, 0x10	; 16
   10d5c:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
			   lcd_print (2,1,lcdteks);
   10d60:	82 e0       	ldi	r24, 0x02	; 2
   10d62:	61 e0       	ldi	r22, 0x01	; 1
   10d64:	a8 01       	movw	r20, r16
   10d66:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
			   lcd_printf(3,1,PSTR("Save?"));
   10d6a:	83 e0       	ldi	r24, 0x03	; 3
   10d6c:	61 e0       	ldi	r22, 0x01	; 1
   10d6e:	45 e7       	ldi	r20, 0x75	; 117
   10d70:	50 e1       	ldi	r21, 0x10	; 16
   10d72:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
			   lcd_printf(4,1,PSTR("[*]No    [#]Yes"));
   10d76:	84 e0       	ldi	r24, 0x04	; 4
   10d78:	61 e0       	ldi	r22, 0x01	; 1
   10d7a:	45 e6       	ldi	r20, 0x65	; 101
   10d7c:	50 e1       	ldi	r21, 0x10	; 16
   10d7e:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
               stSettingOperator=soIsSaveOperatorName;
   10d82:	84 e0       	ldi	r24, 0x04	; 4
   10d84:	a7 c1       	rjmp	.+846    	; 0x110d4 <FSettingOperator+0x578>
		       break;
		  case USER_CANCEL:
               stSettingOperator=soMenuOption; 
		       break;
          case USER_ENTRY:
		       lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   10d86:	84 e0       	ldi	r24, 0x04	; 4
   10d88:	61 e0       	ldi	r22, 0x01	; 1
   10d8a:	40 e5       	ldi	r20, 0x50	; 80
   10d8c:	50 e1       	ldi	r21, 0x10	; 16
   10d8e:	2c c1       	rjmp	.+600    	; 0x10fe8 <FSettingOperator+0x48c>
		       break;
          case USER_NO_DATA:
		       lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   10d90:	84 e0       	ldi	r24, 0x04	; 4
   10d92:	61 e0       	ldi	r22, 0x01	; 1
   10d94:	4b e3       	ldi	r20, 0x3B	; 59
   10d96:	50 e1       	ldi	r21, 0x10	; 16
   10d98:	27 c1       	rjmp	.+590    	; 0x10fe8 <FSettingOperator+0x48c>
		       break;
		  }
	      break;
     case soIsSaveOperatorName:
          KeyPressed=_key_scan(1);
   10d9a:	81 e0       	ldi	r24, 0x01	; 1
   10d9c:	0e 94 ab ae 	call	0x15d56	; 0x15d56 <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
   10da0:	0e 94 0c ae 	call	0x15c18	; 0x15c18 <_key_btn>
		  switch(KeyChar){
   10da4:	83 32       	cpi	r24, 0x23	; 35
   10da6:	09 f0       	breq	.+2      	; 0x10daa <FSettingOperator+0x24e>
   10da8:	56 c0       	rjmp	.+172    	; 0x10e56 <FSettingOperator+0x2fa>
          case '*':
		       stSettingOperator=soMenuOption;
		       break;
   10daa:	20 e0       	ldi	r18, 0x00	; 0
   10dac:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   10dae:	8e 01       	movw	r16, r28
   10db0:	00 5f       	subi	r16, 0xF0	; 240
   10db2:	1f 4f       	sbci	r17, 0xFF	; 255
   10db4:	f8 01       	movw	r30, r16
   10db6:	e2 0f       	add	r30, r18
   10db8:	f3 1f       	adc	r31, r19
   10dba:	d9 01       	movw	r26, r18
   10dbc:	a9 56       	subi	r26, 0x69	; 105
   10dbe:	b5 4f       	sbci	r27, 0xF5	; 245
   10dc0:	8c 91       	ld	r24, X
   10dc2:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   10dc4:	2f 5f       	subi	r18, 0xFF	; 255
   10dc6:	3f 4f       	sbci	r19, 0xFF	; 255
   10dc8:	2f 30       	cpi	r18, 0x0F	; 15
   10dca:	31 05       	cpc	r19, r1
   10dcc:	99 f7       	brne	.-26     	; 0x10db4 <FSettingOperator+0x258>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   10dce:	1f 8e       	std	Y+31, r1	; 0x1f
          case '*':
		       stSettingOperator=soMenuOption;
		       break;
          case '#':
		       StrPosCopy(strFreeMessageLine1,strOperatorName,0,15);
               AddSpaceLag(strOperatorName,18); 
   10dd0:	c8 01       	movw	r24, r16
   10dd2:	62 e1       	ldi	r22, 0x12	; 18
   10dd4:	0e 94 d8 2a 	call	0x55b0	; 0x55b0 <AddSpaceLag>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
   10dd8:	85 e1       	ldi	r24, 0x15	; 21
   10dda:	90 e0       	ldi	r25, 0x00	; 0
   10ddc:	b8 01       	movw	r22, r16
   10dde:	42 e1       	ldi	r20, 0x12	; 18
   10de0:	50 e0       	ldi	r21, 0x00	; 0
   10de2:	2b ef       	ldi	r18, 0xFB	; 251
   10de4:	32 e1       	ldi	r19, 0x12	; 18
   10de6:	0e 94 3b b4 	call	0x16876	; 0x16876 <__eewr_block>
		       eeprom_write_block((const void*) &strOperatorName, (void*) &DefOperatorName,18);
		       lcd_printf(3,1,PSTR("Saved "));
   10dea:	83 e0       	ldi	r24, 0x03	; 3
   10dec:	61 e0       	ldi	r22, 0x01	; 1
   10dee:	44 e3       	ldi	r20, 0x34	; 52
   10df0:	50 e1       	ldi	r21, 0x10	; 16
   10df2:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
			   TimDisplay=0;
   10df6:	10 92 a7 01 	sts	0x01A7, r1
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   10dfa:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   10dfc:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   10dfe:	81 e0       	ldi	r24, 0x01	; 1
   10e00:	90 e0       	ldi	r25, 0x00	; 0
   10e02:	90 93 d7 01 	sts	0x01D7, r25
   10e06:	80 93 d6 01 	sts	0x01D6, r24
   10e0a:	49 c1       	rjmp	.+658    	; 0x1109e <FSettingOperator+0x542>
		       stSettingOperator=soDelayDisplaySaved;
		       break;
		  }	      
		  break;
     case soChangePasswordInit:
	      lcd_clear();
   10e0c:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
		  lcd_printf(1,1,PSTR("-Change Password-"));
   10e10:	81 e0       	ldi	r24, 0x01	; 1
   10e12:	61 e0       	ldi	r22, 0x01	; 1
   10e14:	42 e2       	ldi	r20, 0x22	; 34
   10e16:	50 e1       	ldi	r21, 0x10	; 16
   10e18:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		  lcd_printf(2,1,PSTR("1.Supervisor"));
   10e1c:	82 e0       	ldi	r24, 0x02	; 2
   10e1e:	61 e0       	ldi	r22, 0x01	; 1
   10e20:	45 e1       	ldi	r20, 0x15	; 21
   10e22:	50 e1       	ldi	r21, 0x10	; 16
   10e24:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		  lcd_printf(3,1,PSTR("2.Administrator"));
   10e28:	83 e0       	ldi	r24, 0x03	; 3
   10e2a:	61 e0       	ldi	r22, 0x01	; 1
   10e2c:	45 e0       	ldi	r20, 0x05	; 5
   10e2e:	50 e1       	ldi	r21, 0x10	; 16
   10e30:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		  lcd_printf(4,1,PSTR("[*]Back     "));
   10e34:	84 e0       	ldi	r24, 0x04	; 4
   10e36:	61 e0       	ldi	r22, 0x01	; 1
   10e38:	48 ef       	ldi	r20, 0xF8	; 248
   10e3a:	5f e0       	ldi	r21, 0x0F	; 15
   10e3c:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
          stSettingOperator=soChangePasswordInput; 
   10e40:	86 e0       	ldi	r24, 0x06	; 6
   10e42:	48 c1       	rjmp	.+656    	; 0x110d4 <FSettingOperator+0x578>
	      break;
     case soChangePasswordInput:
          KeyPressed=_key_scan(1);
   10e44:	81 e0       	ldi	r24, 0x01	; 1
   10e46:	0e 94 ab ae 	call	0x15d56	; 0x15d56 <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
   10e4a:	0e 94 0c ae 	call	0x15c18	; 0x15c18 <_key_btn>
		  switch(KeyChar){
   10e4e:	81 33       	cpi	r24, 0x31	; 49
   10e50:	31 f0       	breq	.+12     	; 0x10e5e <FSettingOperator+0x302>
   10e52:	82 33       	cpi	r24, 0x32	; 50
   10e54:	31 f0       	breq	.+12     	; 0x10e62 <FSettingOperator+0x306>
   10e56:	8a 32       	cpi	r24, 0x2A	; 42
   10e58:	09 f0       	breq	.+2      	; 0x10e5c <FSettingOperator+0x300>
   10e5a:	66 c1       	rjmp	.+716    	; 0x11128 <FSettingOperator+0x5cc>
   10e5c:	5e c1       	rjmp	.+700    	; 0x1111a <FSettingOperator+0x5be>
		  case '1':		 
		       PassType=PT_SUPERVISOR;
   10e5e:	81 e0       	ldi	r24, 0x01	; 1
   10e60:	01 c0       	rjmp	.+2      	; 0x10e64 <FSettingOperator+0x308>
		       stSettingOperator=soOldPasswordDisplay;
		       break;
          case '2':		       
		       PassType=PT_ADMINISTRATOR;
   10e62:	82 e0       	ldi	r24, 0x02	; 2
   10e64:	80 93 e1 02 	sts	0x02E1, r24
   10e68:	75 c0       	rjmp	.+234    	; 0x10f54 <FSettingOperator+0x3f8>
		       stSettingOperator=soMenuOption;
		       break;
		  }	      
	      break;
     case soOldPasswordDisplay:
	 	  lcd_clear();
   10e6a:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
	      if (PassType==PT_SUPERVISOR){
   10e6e:	80 91 e1 02 	lds	r24, 0x02E1
   10e72:	81 30       	cpi	r24, 0x01	; 1
   10e74:	21 f4       	brne	.+8      	; 0x10e7e <FSettingOperator+0x322>
		      lcd_printf(1,1,PSTR("-Supervisor-"));              
   10e76:	61 e0       	ldi	r22, 0x01	; 1
   10e78:	4b ee       	ldi	r20, 0xEB	; 235
   10e7a:	5f e0       	ldi	r21, 0x0F	; 15
   10e7c:	06 c0       	rjmp	.+12     	; 0x10e8a <FSettingOperator+0x32e>
		  }else if (PassType==PT_ADMINISTRATOR){		       
   10e7e:	82 30       	cpi	r24, 0x02	; 2
   10e80:	31 f4       	brne	.+12     	; 0x10e8e <FSettingOperator+0x332>
		       lcd_printf(1,1,PSTR("-Administrator-"));			   
   10e82:	81 e0       	ldi	r24, 0x01	; 1
   10e84:	61 e0       	ldi	r22, 0x01	; 1
   10e86:	4b ed       	ldi	r20, 0xDB	; 219
   10e88:	5f e0       	ldi	r21, 0x0F	; 15
   10e8a:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		  }
		      lcd_printf(2,1,PSTR("Old:_"));
   10e8e:	82 e0       	ldi	r24, 0x02	; 2
   10e90:	61 e0       	ldi	r22, 0x01	; 1
   10e92:	45 ed       	ldi	r20, 0xD5	; 213
   10e94:	5f e0       	ldi	r21, 0x0F	; 15
   10e96:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
			  lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   10e9a:	84 e0       	ldi	r24, 0x04	; 4
   10e9c:	61 e0       	ldi	r22, 0x01	; 1
   10e9e:	40 ec       	ldi	r20, 0xC0	; 192
   10ea0:	5f e0       	ldi	r21, 0x0F	; 15
   10ea2:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>

          stSettingOperator=soOldPasswordEntry;
   10ea6:	88 e0       	ldi	r24, 0x08	; 8
   10ea8:	15 c1       	rjmp	.+554    	; 0x110d4 <FSettingOperator+0x578>
	      break;
     case soOldPasswordEntry:
          uiResult=USER_NONE;
          uiResult=UserInput(UI_NUM_PASSWORD,2,5,strFreeMessageLine1,0,8);           
   10eaa:	84 e0       	ldi	r24, 0x04	; 4
   10eac:	62 e0       	ldi	r22, 0x02	; 2
   10eae:	45 e0       	ldi	r20, 0x05	; 5
   10eb0:	27 e9       	ldi	r18, 0x97	; 151
   10eb2:	3a e0       	ldi	r19, 0x0A	; 10
   10eb4:	00 e0       	ldi	r16, 0x00	; 0
   10eb6:	10 e0       	ldi	r17, 0x00	; 0
   10eb8:	a8 e0       	ldi	r26, 0x08	; 8
   10eba:	ea 2e       	mov	r14, r26
   10ebc:	0e 94 f0 7b 	call	0xf7e0	; 0xf7e0 <UserInput>
		  switch(uiResult){
   10ec0:	83 30       	cpi	r24, 0x03	; 3
   10ec2:	61 f0       	breq	.+24     	; 0x10edc <FSettingOperator+0x380>
   10ec4:	84 30       	cpi	r24, 0x04	; 4
   10ec6:	20 f4       	brcc	.+8      	; 0x10ed0 <FSettingOperator+0x374>
   10ec8:	81 30       	cpi	r24, 0x01	; 1
   10eca:	09 f0       	breq	.+2      	; 0x10ece <FSettingOperator+0x372>
   10ecc:	2d c1       	rjmp	.+602    	; 0x11128 <FSettingOperator+0x5cc>
   10ece:	25 c1       	rjmp	.+586    	; 0x1111a <FSettingOperator+0x5be>
   10ed0:	84 30       	cpi	r24, 0x04	; 4
   10ed2:	79 f0       	breq	.+30     	; 0x10ef2 <FSettingOperator+0x396>
   10ed4:	85 30       	cpi	r24, 0x05	; 5
   10ed6:	09 f0       	breq	.+2      	; 0x10eda <FSettingOperator+0x37e>
   10ed8:	27 c1       	rjmp	.+590    	; 0x11128 <FSettingOperator+0x5cc>
   10eda:	10 c0       	rjmp	.+32     	; 0x10efc <FSettingOperator+0x3a0>
		  case USER_OK:
		       lcd_printf(2,1,PSTR("New:_               "));
   10edc:	82 e0       	ldi	r24, 0x02	; 2
   10ede:	61 e0       	ldi	r22, 0x01	; 1
   10ee0:	4b ea       	ldi	r20, 0xAB	; 171
   10ee2:	5f e0       	ldi	r21, 0x0F	; 15
   10ee4:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
			   lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   10ee8:	84 e0       	ldi	r24, 0x04	; 4
   10eea:	61 e0       	ldi	r22, 0x01	; 1
   10eec:	46 e9       	ldi	r20, 0x96	; 150
   10eee:	5f e0       	ldi	r21, 0x0F	; 15
   10ef0:	6e c0       	rjmp	.+220    	; 0x10fce <FSettingOperator+0x472>
		       break;
		  case USER_CANCEL:
               stSettingOperator=soMenuOption; 
		       break;
          case USER_ENTRY:
		       lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   10ef2:	84 e0       	ldi	r24, 0x04	; 4
   10ef4:	61 e0       	ldi	r22, 0x01	; 1
   10ef6:	41 e8       	ldi	r20, 0x81	; 129
   10ef8:	5f e0       	ldi	r21, 0x0F	; 15
   10efa:	76 c0       	rjmp	.+236    	; 0x10fe8 <FSettingOperator+0x48c>
		       break;
          case USER_NO_DATA:
		       lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   10efc:	84 e0       	ldi	r24, 0x04	; 4
   10efe:	61 e0       	ldi	r22, 0x01	; 1
   10f00:	4c e6       	ldi	r20, 0x6C	; 108
   10f02:	5f e0       	ldi	r21, 0x0F	; 15
   10f04:	71 c0       	rjmp	.+226    	; 0x10fe8 <FSettingOperator+0x48c>
		       break;
		  }
	      break;
     case soNewPasswordEntry1:
          uiResult=USER_NONE;
          uiResult=UserInput(UI_NUM_PASSWORD,2,5,strFreeMessageLine2,0,8);           
   10f06:	84 e0       	ldi	r24, 0x04	; 4
   10f08:	62 e0       	ldi	r22, 0x02	; 2
   10f0a:	45 e0       	ldi	r20, 0x05	; 5
   10f0c:	26 e8       	ldi	r18, 0x86	; 134
   10f0e:	39 e0       	ldi	r19, 0x09	; 9
   10f10:	00 e0       	ldi	r16, 0x00	; 0
   10f12:	10 e0       	ldi	r17, 0x00	; 0
   10f14:	f8 e0       	ldi	r31, 0x08	; 8
   10f16:	ef 2e       	mov	r14, r31
   10f18:	0e 94 f0 7b 	call	0xf7e0	; 0xf7e0 <UserInput>
		  switch(uiResult){
   10f1c:	83 30       	cpi	r24, 0x03	; 3
   10f1e:	61 f0       	breq	.+24     	; 0x10f38 <FSettingOperator+0x3dc>
   10f20:	84 30       	cpi	r24, 0x04	; 4
   10f22:	20 f4       	brcc	.+8      	; 0x10f2c <FSettingOperator+0x3d0>
   10f24:	81 30       	cpi	r24, 0x01	; 1
   10f26:	09 f0       	breq	.+2      	; 0x10f2a <FSettingOperator+0x3ce>
   10f28:	ff c0       	rjmp	.+510    	; 0x11128 <FSettingOperator+0x5cc>
   10f2a:	14 c0       	rjmp	.+40     	; 0x10f54 <FSettingOperator+0x3f8>
   10f2c:	84 30       	cpi	r24, 0x04	; 4
   10f2e:	a1 f0       	breq	.+40     	; 0x10f58 <FSettingOperator+0x3fc>
   10f30:	85 30       	cpi	r24, 0x05	; 5
   10f32:	09 f0       	breq	.+2      	; 0x10f36 <FSettingOperator+0x3da>
   10f34:	f9 c0       	rjmp	.+498    	; 0x11128 <FSettingOperator+0x5cc>
   10f36:	15 c0       	rjmp	.+42     	; 0x10f62 <FSettingOperator+0x406>
		  case USER_OK:
		       lcd_printf(3,1,PSTR("New:_               "));
   10f38:	83 e0       	ldi	r24, 0x03	; 3
   10f3a:	61 e0       	ldi	r22, 0x01	; 1
   10f3c:	47 e5       	ldi	r20, 0x57	; 87
   10f3e:	5f e0       	ldi	r21, 0x0F	; 15
   10f40:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
			   lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   10f44:	84 e0       	ldi	r24, 0x04	; 4
   10f46:	61 e0       	ldi	r22, 0x01	; 1
   10f48:	42 e4       	ldi	r20, 0x42	; 66
   10f4a:	5f e0       	ldi	r21, 0x0F	; 15
   10f4c:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		       stSettingOperator=soNewPasswordEntry2;
   10f50:	8a e0       	ldi	r24, 0x0A	; 10
   10f52:	c0 c0       	rjmp	.+384    	; 0x110d4 <FSettingOperator+0x578>
		       break;
		  case USER_CANCEL:		       
			   stSettingOperator=soOldPasswordDisplay;
   10f54:	87 e0       	ldi	r24, 0x07	; 7
   10f56:	be c0       	rjmp	.+380    	; 0x110d4 <FSettingOperator+0x578>
		       break;
          case USER_ENTRY:
		       lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   10f58:	84 e0       	ldi	r24, 0x04	; 4
   10f5a:	61 e0       	ldi	r22, 0x01	; 1
   10f5c:	4d e2       	ldi	r20, 0x2D	; 45
   10f5e:	5f e0       	ldi	r21, 0x0F	; 15
   10f60:	43 c0       	rjmp	.+134    	; 0x10fe8 <FSettingOperator+0x48c>
		       break;
          case USER_NO_DATA:
		       lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   10f62:	84 e0       	ldi	r24, 0x04	; 4
   10f64:	61 e0       	ldi	r22, 0x01	; 1
   10f66:	48 e1       	ldi	r20, 0x18	; 24
   10f68:	5f e0       	ldi	r21, 0x0F	; 15
   10f6a:	3e c0       	rjmp	.+124    	; 0x10fe8 <FSettingOperator+0x48c>
		       break;
		  }	      
	      break;
     case soNewPasswordEntry2:
          uiResult=USER_NONE;
          uiResult=UserInput(UI_NUM_PASSWORD,3,5,strFreeMessageLine3,0,8);           
   10f6c:	84 e0       	ldi	r24, 0x04	; 4
   10f6e:	63 e0       	ldi	r22, 0x03	; 3
   10f70:	45 e0       	ldi	r20, 0x05	; 5
   10f72:	21 e2       	ldi	r18, 0x21	; 33
   10f74:	3a e0       	ldi	r19, 0x0A	; 10
   10f76:	00 e0       	ldi	r16, 0x00	; 0
   10f78:	10 e0       	ldi	r17, 0x00	; 0
   10f7a:	e8 e0       	ldi	r30, 0x08	; 8
   10f7c:	ee 2e       	mov	r14, r30
   10f7e:	0e 94 f0 7b 	call	0xf7e0	; 0xf7e0 <UserInput>
		  switch(uiResult){
   10f82:	83 30       	cpi	r24, 0x03	; 3
   10f84:	61 f0       	breq	.+24     	; 0x10f9e <FSettingOperator+0x442>
   10f86:	84 30       	cpi	r24, 0x04	; 4
   10f88:	20 f4       	brcc	.+8      	; 0x10f92 <FSettingOperator+0x436>
   10f8a:	81 30       	cpi	r24, 0x01	; 1
   10f8c:	09 f0       	breq	.+2      	; 0x10f90 <FSettingOperator+0x434>
   10f8e:	cc c0       	rjmp	.+408    	; 0x11128 <FSettingOperator+0x5cc>
   10f90:	12 c0       	rjmp	.+36     	; 0x10fb6 <FSettingOperator+0x45a>
   10f92:	84 30       	cpi	r24, 0x04	; 4
   10f94:	01 f1       	breq	.+64     	; 0x10fd6 <FSettingOperator+0x47a>
   10f96:	85 30       	cpi	r24, 0x05	; 5
   10f98:	09 f0       	breq	.+2      	; 0x10f9c <FSettingOperator+0x440>
   10f9a:	c6 c0       	rjmp	.+396    	; 0x11128 <FSettingOperator+0x5cc>
   10f9c:	21 c0       	rjmp	.+66     	; 0x10fe0 <FSettingOperator+0x484>
		  case USER_OK:
		       lcd_clear();
   10f9e:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
               lcd_printf(1,1,PSTR("Validating.."));
   10fa2:	81 e0       	ldi	r24, 0x01	; 1
   10fa4:	61 e0       	ldi	r22, 0x01	; 1
   10fa6:	4b e0       	ldi	r20, 0x0B	; 11
   10fa8:	5f e0       	ldi	r21, 0x0F	; 15
   10faa:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
			   TimDisplay=0;
   10fae:	10 92 a7 01 	sts	0x01A7, r1
		       stSettingOperator=soDispValidatePassword;
   10fb2:	8b e0       	ldi	r24, 0x0B	; 11
   10fb4:	8f c0       	rjmp	.+286    	; 0x110d4 <FSettingOperator+0x578>
		       break;
		  case USER_CANCEL:
               lcd_clear();
   10fb6:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
               lcd_printf(2,1,PSTR("New:_               "));
   10fba:	82 e0       	ldi	r24, 0x02	; 2
   10fbc:	61 e0       	ldi	r22, 0x01	; 1
   10fbe:	46 ef       	ldi	r20, 0xF6	; 246
   10fc0:	5e e0       	ldi	r21, 0x0E	; 14
   10fc2:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
			   lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   10fc6:	84 e0       	ldi	r24, 0x04	; 4
   10fc8:	61 e0       	ldi	r22, 0x01	; 1
   10fca:	41 ee       	ldi	r20, 0xE1	; 225
   10fcc:	5e e0       	ldi	r21, 0x0E	; 14
   10fce:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		       stSettingOperator=soNewPasswordEntry1;
   10fd2:	89 e0       	ldi	r24, 0x09	; 9
   10fd4:	7f c0       	rjmp	.+254    	; 0x110d4 <FSettingOperator+0x578>
		       break;
          case USER_ENTRY:
		       lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   10fd6:	84 e0       	ldi	r24, 0x04	; 4
   10fd8:	61 e0       	ldi	r22, 0x01	; 1
   10fda:	4c ec       	ldi	r20, 0xCC	; 204
   10fdc:	5e e0       	ldi	r21, 0x0E	; 14
   10fde:	04 c0       	rjmp	.+8      	; 0x10fe8 <FSettingOperator+0x48c>
		       break;
          case USER_NO_DATA:
		       lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   10fe0:	84 e0       	ldi	r24, 0x04	; 4
   10fe2:	61 e0       	ldi	r22, 0x01	; 1
   10fe4:	47 eb       	ldi	r20, 0xB7	; 183
   10fe6:	5e e0       	ldi	r21, 0x0E	; 14
   10fe8:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
   10fec:	9d c0       	rjmp	.+314    	; 0x11128 <FSettingOperator+0x5cc>
		       break;
		  }	      
	      break;
     case soDispValidatePassword:
	      if (TimDisplay>3)stSettingOperator=soValidatePassword;
   10fee:	80 91 a7 01 	lds	r24, 0x01A7
   10ff2:	84 30       	cpi	r24, 0x04	; 4
   10ff4:	08 f4       	brcc	.+2      	; 0x10ff8 <FSettingOperator+0x49c>
   10ff6:	98 c0       	rjmp	.+304    	; 0x11128 <FSettingOperator+0x5cc>
   10ff8:	8c e0       	ldi	r24, 0x0C	; 12
   10ffa:	6c c0       	rjmp	.+216    	; 0x110d4 <FSettingOperator+0x578>
	      break;
     case soValidatePassword:
          if (PassType==PT_SUPERVISOR) eeprom_read_block((void*) &strPassword, (const void*) &DefSysPassword, 10);		      			   
   10ffc:	80 91 e1 02 	lds	r24, 0x02E1
   11000:	81 30       	cpi	r24, 0x01	; 1
   11002:	29 f4       	brne	.+10     	; 0x1100e <FSettingOperator+0x4b2>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
   11004:	ce 01       	movw	r24, r28
   11006:	01 96       	adiw	r24, 0x01	; 1
   11008:	6b e0       	ldi	r22, 0x0B	; 11
   1100a:	70 e0       	ldi	r23, 0x00	; 0
   1100c:	06 c0       	rjmp	.+12     	; 0x1101a <FSettingOperator+0x4be>
		  else 
		  if (PassType==PT_ADMINISTRATOR) eeprom_read_block((void*) &strPassword, (const void*) &DefSpvPassword, 10);    
   1100e:	82 30       	cpi	r24, 0x02	; 2
   11010:	51 f4       	brne	.+20     	; 0x11026 <FSettingOperator+0x4ca>
   11012:	ce 01       	movw	r24, r28
   11014:	01 96       	adiw	r24, 0x01	; 1
   11016:	61 e0       	ldi	r22, 0x01	; 1
   11018:	70 e0       	ldi	r23, 0x00	; 0
   1101a:	4a e0       	ldi	r20, 0x0A	; 10
   1101c:	50 e0       	ldi	r21, 0x00	; 0
   1101e:	23 ef       	ldi	r18, 0xF3	; 243
   11020:	32 e1       	ldi	r19, 0x12	; 18
   11022:	0e 94 1f b4 	call	0x1683e	; 0x1683e <__eerd_block>
		  
		  //Check Old Validity
		  if (strcmp(strPassword,strFreeMessageLine1)==0){//OldMessage Valid
   11026:	ce 01       	movw	r24, r28
   11028:	01 96       	adiw	r24, 0x01	; 1
   1102a:	67 e9       	ldi	r22, 0x97	; 151
   1102c:	7a e0       	ldi	r23, 0x0A	; 10
   1102e:	0e 94 0f b4 	call	0x1681e	; 0x1681e <strcmp>
   11032:	00 97       	sbiw	r24, 0x00	; 0
   11034:	09 f0       	breq	.+2      	; 0x11038 <FSettingOperator+0x4dc>
   11036:	51 c0       	rjmp	.+162    	; 0x110da <FSettingOperator+0x57e>
              if (strcmp(strFreeMessageLine2,strFreeMessageLine3)==0){
   11038:	86 e8       	ldi	r24, 0x86	; 134
   1103a:	99 e0       	ldi	r25, 0x09	; 9
   1103c:	61 e2       	ldi	r22, 0x21	; 33
   1103e:	7a e0       	ldi	r23, 0x0A	; 10
   11040:	0e 94 0f b4 	call	0x1681e	; 0x1681e <strcmp>
   11044:	00 97       	sbiw	r24, 0x00	; 0
   11046:	69 f5       	brne	.+90     	; 0x110a2 <FSettingOperator+0x546>
                  
			      if (PassType==PT_SUPERVISOR) eeprom_write_block((const void*) &strFreeMessageLine2, (void*) &DefSysPassword, 10);		      			   
   11048:	80 91 e1 02 	lds	r24, 0x02E1
   1104c:	81 30       	cpi	r24, 0x01	; 1
   1104e:	19 f4       	brne	.+6      	; 0x11056 <FSettingOperator+0x4fa>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
   11050:	8b e0       	ldi	r24, 0x0B	; 11
   11052:	90 e0       	ldi	r25, 0x00	; 0
   11054:	04 c0       	rjmp	.+8      	; 0x1105e <FSettingOperator+0x502>
		          else 
		          if (PassType==PT_ADMINISTRATOR) eeprom_write_block((const void*) &strFreeMessageLine2, (void*) &DefSpvPassword, 10);    
   11056:	82 30       	cpi	r24, 0x02	; 2
   11058:	51 f4       	brne	.+20     	; 0x1106e <FSettingOperator+0x512>
   1105a:	81 e0       	ldi	r24, 0x01	; 1
   1105c:	90 e0       	ldi	r25, 0x00	; 0
   1105e:	66 e8       	ldi	r22, 0x86	; 134
   11060:	79 e0       	ldi	r23, 0x09	; 9
   11062:	4a e0       	ldi	r20, 0x0A	; 10
   11064:	50 e0       	ldi	r21, 0x00	; 0
   11066:	2b ef       	ldi	r18, 0xFB	; 251
   11068:	32 e1       	ldi	r19, 0x12	; 18
   1106a:	0e 94 3b b4 	call	0x16876	; 0x16876 <__eewr_block>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   1106e:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   11070:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   11072:	81 e0       	ldi	r24, 0x01	; 1
   11074:	90 e0       	ldi	r25, 0x00	; 0
   11076:	90 93 d7 01 	sts	0x01D7, r25
   1107a:	80 93 d6 01 	sts	0x01D6, r24
			      if (PassType==PT_SUPERVISOR) eeprom_write_block((const void*) &strFreeMessageLine2, (void*) &DefSysPassword, 10);		      			   
		          else 
		          if (PassType==PT_ADMINISTRATOR) eeprom_write_block((const void*) &strFreeMessageLine2, (void*) &DefSpvPassword, 10);    

			      system_beep(1);
				  lcd_clear();
   1107e:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
			      lcd_printf(2,1,PSTR("     Completed      "));
   11082:	82 e0       	ldi	r24, 0x02	; 2
   11084:	61 e0       	ldi	r22, 0x01	; 1
   11086:	42 ea       	ldi	r20, 0xA2	; 162
   11088:	5e e0       	ldi	r21, 0x0E	; 14
   1108a:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
			      lcd_printf(3,1,PSTR("   Password Saved   "));    
   1108e:	83 e0       	ldi	r24, 0x03	; 3
   11090:	61 e0       	ldi	r22, 0x01	; 1
   11092:	4d e8       	ldi	r20, 0x8D	; 141
   11094:	5e e0       	ldi	r21, 0x0E	; 14
   11096:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
				  TimDisplay=0;
   1109a:	10 92 a7 01 	sts	0x01A7, r1
				  stSettingOperator=soDelayDisplaySaved;
   1109e:	8e e0       	ldi	r24, 0x0E	; 14
   110a0:	19 c0       	rjmp	.+50     	; 0x110d4 <FSettingOperator+0x578>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   110a2:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   110a4:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   110a6:	82 e0       	ldi	r24, 0x02	; 2
   110a8:	90 e0       	ldi	r25, 0x00	; 0
   110aa:	90 93 d7 01 	sts	0x01D7, r25
   110ae:	80 93 d6 01 	sts	0x01D6, r24
			      lcd_printf(3,1,PSTR("   Password Saved   "));    
				  TimDisplay=0;
				  stSettingOperator=soDelayDisplaySaved;
			  }else {
			  system_beep(2);
		      TimDisplay=0;
   110b2:	10 92 a7 01 	sts	0x01A7, r1
		      lcd_clear();
   110b6:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
		      lcd_printf(2,1,PSTR("      ERROR         "));
   110ba:	82 e0       	ldi	r24, 0x02	; 2
   110bc:	61 e0       	ldi	r22, 0x01	; 1
   110be:	48 e7       	ldi	r20, 0x78	; 120
   110c0:	5e e0       	ldi	r21, 0x0E	; 14
   110c2:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		      lcd_printf(3,1,PSTR("Invalid New Password"));
   110c6:	83 e0       	ldi	r24, 0x03	; 3
   110c8:	61 e0       	ldi	r22, 0x01	; 1
   110ca:	43 e6       	ldi	r20, 0x63	; 99
   110cc:	5e e0       	ldi	r21, 0x0E	; 14
   110ce:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		      stSettingOperator=soDisplayInvalidPassword;
   110d2:	8d e0       	ldi	r24, 0x0D	; 13
   110d4:	80 93 e2 02 	sts	0x02E2, r24
   110d8:	27 c0       	rjmp	.+78     	; 0x11128 <FSettingOperator+0x5cc>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   110da:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   110dc:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   110de:	82 e0       	ldi	r24, 0x02	; 2
   110e0:	90 e0       	ldi	r25, 0x00	; 0
   110e2:	90 93 d7 01 	sts	0x01D7, r25
   110e6:	80 93 d6 01 	sts	0x01D6, r24
		      stSettingOperator=soDisplayInvalidPassword;
			  }
		  }else {
		   //InvalidOld Password
		   system_beep(2);
		   TimDisplay=0;
   110ea:	10 92 a7 01 	sts	0x01A7, r1
		   lcd_clear();
   110ee:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
		   lcd_printf(2,1,PSTR("      ERROR         "));
   110f2:	82 e0       	ldi	r24, 0x02	; 2
   110f4:	61 e0       	ldi	r22, 0x01	; 1
   110f6:	4e e4       	ldi	r20, 0x4E	; 78
   110f8:	5e e0       	ldi	r21, 0x0E	; 14
   110fa:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		   lcd_printf(3,1,PSTR("Invalid Old Password"));
   110fe:	83 e0       	ldi	r24, 0x03	; 3
   11100:	61 e0       	ldi	r22, 0x01	; 1
   11102:	49 e3       	ldi	r20, 0x39	; 57
   11104:	5e e0       	ldi	r21, 0x0E	; 14
   11106:	e3 cf       	rjmp	.-58     	; 0x110ce <FSettingOperator+0x572>
		   stSettingOperator=soDisplayInvalidPassword;
		   }
	      break;
     case soDisplayInvalidPassword:
	      if (TimDisplay>6)stSettingOperator=soMenuOption;
   11108:	80 91 a7 01 	lds	r24, 0x01A7
   1110c:	87 30       	cpi	r24, 0x07	; 7
   1110e:	60 f0       	brcs	.+24     	; 0x11128 <FSettingOperator+0x5cc>
   11110:	04 c0       	rjmp	.+8      	; 0x1111a <FSettingOperator+0x5be>
	      break;
     case soDelayDisplaySaved:
	      if (TimDisplay>4)stSettingOperator=soMenuOption;
   11112:	80 91 a7 01 	lds	r24, 0x01A7
   11116:	85 30       	cpi	r24, 0x05	; 5
   11118:	38 f0       	brcs	.+14     	; 0x11128 <FSettingOperator+0x5cc>
   1111a:	10 92 e2 02 	sts	0x02E2, r1
   1111e:	04 c0       	rjmp	.+8      	; 0x11128 <FSettingOperator+0x5cc>
	      break;
	 case soExitSettingOperator:
	      stSettingOperator=soMenuOption;
   11120:	10 92 e2 02 	sts	0x02E2, r1
   11124:	81 e0       	ldi	r24, 0x01	; 1
   11126:	01 c0       	rjmp	.+2      	; 0x1112a <FSettingOperator+0x5ce>
   11128:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
     return Result;
}
   1112a:	e5 96       	adiw	r28, 0x35	; 53
   1112c:	0f b6       	in	r0, 0x3f	; 63
   1112e:	f8 94       	cli
   11130:	de bf       	out	0x3e, r29	; 62
   11132:	0f be       	out	0x3f, r0	; 63
   11134:	cd bf       	out	0x3d, r28	; 61
   11136:	cf 91       	pop	r28
   11138:	df 91       	pop	r29
   1113a:	1f 91       	pop	r17
   1113c:	0f 91       	pop	r16
   1113e:	ef 90       	pop	r14
   11140:	08 95       	ret

00011142 <FSettingProduct>:

void menu_product(){

}

char FSettingProduct(){//Using strDescription
   11142:	6f 92       	push	r6
   11144:	7f 92       	push	r7
   11146:	8f 92       	push	r8
   11148:	9f 92       	push	r9
   1114a:	af 92       	push	r10
   1114c:	bf 92       	push	r11
   1114e:	cf 92       	push	r12
   11150:	df 92       	push	r13
   11152:	ef 92       	push	r14
   11154:	ff 92       	push	r15
   11156:	0f 93       	push	r16
   11158:	1f 93       	push	r17
   1115a:	df 93       	push	r29
   1115c:	cf 93       	push	r28
   1115e:	cd b7       	in	r28, 0x3d	; 61
   11160:	de b7       	in	r29, 0x3e	; 62
   11162:	a1 97       	sbiw	r28, 0x21	; 33
   11164:	0f b6       	in	r0, 0x3f	; 63
   11166:	f8 94       	cli
   11168:	de bf       	out	0x3e, r29	; 62
   1116a:	0f be       	out	0x3f, r0	; 63
   1116c:	cd bf       	out	0x3d, r28	; 61
     char i;//,x,y;
	 char strProductName[13],lcdteks[20];
	 char Result=MENU_NONE;
	 
     Result=MENU_NONE;
     switch(stMenuProduct){
   1116e:	80 91 ef 02 	lds	r24, 0x02EF
   11172:	83 30       	cpi	r24, 0x03	; 3
   11174:	09 f4       	brne	.+2      	; 0x11178 <FSettingProduct+0x36>
   11176:	ff c0       	rjmp	.+510    	; 0x11376 <FSettingProduct+0x234>
   11178:	84 30       	cpi	r24, 0x04	; 4
   1117a:	38 f4       	brcc	.+14     	; 0x1118a <FSettingProduct+0x48>
   1117c:	81 30       	cpi	r24, 0x01	; 1
   1117e:	09 f4       	brne	.+2      	; 0x11182 <FSettingProduct+0x40>
   11180:	72 c0       	rjmp	.+228    	; 0x11266 <FSettingProduct+0x124>
   11182:	82 30       	cpi	r24, 0x02	; 2
   11184:	08 f0       	brcs	.+2      	; 0x11188 <FSettingProduct+0x46>
   11186:	82 c0       	rjmp	.+260    	; 0x1128c <FSettingProduct+0x14a>
   11188:	0a c0       	rjmp	.+20     	; 0x1119e <FSettingProduct+0x5c>
   1118a:	85 30       	cpi	r24, 0x05	; 5
   1118c:	09 f4       	brne	.+2      	; 0x11190 <FSettingProduct+0x4e>
   1118e:	83 c1       	rjmp	.+774    	; 0x11496 <FSettingProduct+0x354>
   11190:	85 30       	cpi	r24, 0x05	; 5
   11192:	08 f4       	brcc	.+2      	; 0x11196 <FSettingProduct+0x54>
   11194:	a2 c1       	rjmp	.+836    	; 0x114da <FSettingProduct+0x398>
   11196:	86 30       	cpi	r24, 0x06	; 6
   11198:	09 f0       	breq	.+2      	; 0x1119c <FSettingProduct+0x5a>
   1119a:	c9 c1       	rjmp	.+914    	; 0x1152e <FSettingProduct+0x3ec>
   1119c:	c4 c1       	rjmp	.+904    	; 0x11526 <FSettingProduct+0x3e4>
	 case mpInitProduct:
	      //DisplayProductName
		  lcd_clear();
   1119e:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
   111a2:	bb eb       	ldi	r27, 0xBB	; 187
   111a4:	cb 2e       	mov	r12, r27
   111a6:	b0 e0       	ldi	r27, 0x00	; 0
   111a8:	db 2e       	mov	r13, r27
   111aa:	a1 e0       	ldi	r26, 0x01	; 1
   111ac:	ea 2e       	mov	r14, r26
   111ae:	f1 2c       	mov	r15, r1
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
   111b0:	4e 01       	movw	r8, r28
   111b2:	08 94       	sec
   111b4:	81 1c       	adc	r8, r1
   111b6:	91 1c       	adc	r9, r1
		  //lcd_printf(1,1,PSTR("Product:"));
	      for(i=0;i<6;i++){//234 
	          eeprom_read_block((void*) &strProductName, (const void*) &DefProductName[i], 13);
	          sprintf_P(lcdteks,PSTR("%d)%s"),(i+1),strProductName);
   111b8:	fe e0       	ldi	r31, 0x0E	; 14
   111ba:	af 2e       	mov	r10, r31
   111bc:	b1 2c       	mov	r11, r1
   111be:	ac 0e       	add	r10, r28
   111c0:	bd 1e       	adc	r11, r29
   111c2:	e8 e0       	ldi	r30, 0x08	; 8
   111c4:	6e 2e       	mov	r6, r30
   111c6:	e2 e1       	ldi	r30, 0x12	; 18
   111c8:	7e 2e       	mov	r7, r30
			  lcd_print((((i)%4)+1),(((i)/4)*10)+1,lcdteks);
   111ca:	0a e0       	ldi	r16, 0x0A	; 10
	 
     Result=MENU_NONE;
     switch(stMenuProduct){
	 case mpInitProduct:
	      //DisplayProductName
		  lcd_clear();
   111cc:	1e 2d       	mov	r17, r14
   111ce:	11 50       	subi	r17, 0x01	; 1
   111d0:	c4 01       	movw	r24, r8
   111d2:	b6 01       	movw	r22, r12
   111d4:	4d e0       	ldi	r20, 0x0D	; 13
   111d6:	50 e0       	ldi	r21, 0x00	; 0
   111d8:	23 ef       	ldi	r18, 0xF3	; 243
   111da:	32 e1       	ldi	r19, 0x12	; 18
   111dc:	0e 94 1f b4 	call	0x1683e	; 0x1683e <__eerd_block>
		  //lcd_printf(1,1,PSTR("Product:"));
	      for(i=0;i<6;i++){//234 
	          eeprom_read_block((void*) &strProductName, (const void*) &DefProductName[i], 13);
	          sprintf_P(lcdteks,PSTR("%d)%s"),(i+1),strProductName);
   111e0:	8d b7       	in	r24, 0x3d	; 61
   111e2:	9e b7       	in	r25, 0x3e	; 62
   111e4:	08 97       	sbiw	r24, 0x08	; 8
   111e6:	0f b6       	in	r0, 0x3f	; 63
   111e8:	f8 94       	cli
   111ea:	9e bf       	out	0x3e, r25	; 62
   111ec:	0f be       	out	0x3f, r0	; 63
   111ee:	8d bf       	out	0x3d, r24	; 61
   111f0:	ed b7       	in	r30, 0x3d	; 61
   111f2:	fe b7       	in	r31, 0x3e	; 62
   111f4:	31 96       	adiw	r30, 0x01	; 1
   111f6:	ad b7       	in	r26, 0x3d	; 61
   111f8:	be b7       	in	r27, 0x3e	; 62
   111fa:	12 96       	adiw	r26, 0x02	; 2
   111fc:	bc 92       	st	X, r11
   111fe:	ae 92       	st	-X, r10
   11200:	11 97       	sbiw	r26, 0x01	; 1
   11202:	73 82       	std	Z+3, r7	; 0x03
   11204:	62 82       	std	Z+2, r6	; 0x02
   11206:	f5 82       	std	Z+5, r15	; 0x05
   11208:	e4 82       	std	Z+4, r14	; 0x04
   1120a:	97 82       	std	Z+7, r9	; 0x07
   1120c:	86 82       	std	Z+6, r8	; 0x06
   1120e:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
			  lcd_print((((i)%4)+1),(((i)/4)*10)+1,lcdteks);
   11212:	8d b7       	in	r24, 0x3d	; 61
   11214:	9e b7       	in	r25, 0x3e	; 62
   11216:	08 96       	adiw	r24, 0x08	; 8
   11218:	0f b6       	in	r0, 0x3f	; 63
   1121a:	f8 94       	cli
   1121c:	9e bf       	out	0x3e, r25	; 62
   1121e:	0f be       	out	0x3f, r0	; 63
   11220:	8d bf       	out	0x3d, r24	; 61
   11222:	61 2f       	mov	r22, r17
   11224:	66 95       	lsr	r22
   11226:	66 95       	lsr	r22
   11228:	60 9f       	mul	r22, r16
   1122a:	b0 01       	movw	r22, r0
   1122c:	11 24       	eor	r1, r1
   1122e:	6f 5f       	subi	r22, 0xFF	; 255
   11230:	13 70       	andi	r17, 0x03	; 3
   11232:	81 2f       	mov	r24, r17
   11234:	8f 5f       	subi	r24, 0xFF	; 255
   11236:	a5 01       	movw	r20, r10
   11238:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
   1123c:	ad e0       	ldi	r26, 0x0D	; 13
   1123e:	b0 e0       	ldi	r27, 0x00	; 0
   11240:	ca 0e       	add	r12, r26
   11242:	db 1e       	adc	r13, r27
   11244:	08 94       	sec
   11246:	e1 1c       	adc	r14, r1
   11248:	f1 1c       	adc	r15, r1
     switch(stMenuProduct){
	 case mpInitProduct:
	      //DisplayProductName
		  lcd_clear();
		  //lcd_printf(1,1,PSTR("Product:"));
	      for(i=0;i<6;i++){//234 
   1124a:	b9 e0       	ldi	r27, 0x09	; 9
   1124c:	cb 16       	cp	r12, r27
   1124e:	b1 e0       	ldi	r27, 0x01	; 1
   11250:	db 06       	cpc	r13, r27
   11252:	09 f0       	breq	.+2      	; 0x11256 <FSettingProduct+0x114>
   11254:	bb cf       	rjmp	.-138    	; 0x111cc <FSettingProduct+0x8a>
	          eeprom_read_block((void*) &strProductName, (const void*) &DefProductName[i], 13);
	          sprintf_P(lcdteks,PSTR("%d)%s"),(i+1),strProductName);
			  lcd_print((((i)%4)+1),(((i)/4)*10)+1,lcdteks);
		  }
		  lcd_printf(4,11,PSTR("*)Back"));
   11256:	84 e0       	ldi	r24, 0x04	; 4
   11258:	6b e0       	ldi	r22, 0x0B	; 11
   1125a:	41 e0       	ldi	r20, 0x01	; 1
   1125c:	52 e1       	ldi	r21, 0x12	; 18
   1125e:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
          stMenuProduct=mpChangeProduct;
   11262:	81 e0       	ldi	r24, 0x01	; 1
   11264:	5a c1       	rjmp	.+692    	; 0x1151a <FSettingProduct+0x3d8>
	      break;
     case mpChangeProduct:
		  KeyPressed=_key_scan(1);
   11266:	81 e0       	ldi	r24, 0x01	; 1
   11268:	0e 94 ab ae 	call	0x15d56	; 0x15d56 <_key_scan>
   1126c:	18 2f       	mov	r17, r24
		  KeyChar=_key_btn(KeyPressed);
   1126e:	0e 94 0c ae 	call	0x15c18	; 0x15c18 <_key_btn>
		  if ((KeyChar>='1')&&(KeyChar<='6')){
   11272:	81 53       	subi	r24, 0x31	; 49
   11274:	86 30       	cpi	r24, 0x06	; 6
   11276:	28 f4       	brcc	.+10     	; 0x11282 <FSettingProduct+0x140>
		      ProdID=KeyChar-'1';
   11278:	80 93 ee 02 	sts	0x02EE, r24
			  stMenuProduct=mpDispPrice;
   1127c:	82 e0       	ldi	r24, 0x02	; 2
   1127e:	80 93 ef 02 	sts	0x02EF, r24
		  }
		  if (KeyPressed==_KEY_CANCEL){
   11282:	17 3e       	cpi	r17, 0xE7	; 231
   11284:	09 f0       	breq	.+2      	; 0x11288 <FSettingProduct+0x146>
   11286:	53 c1       	rjmp	.+678    	; 0x1152e <FSettingProduct+0x3ec>
		      stMenuProduct=mpExitMenuProduct;
   11288:	86 e0       	ldi	r24, 0x06	; 6
   1128a:	47 c1       	rjmp	.+654    	; 0x1151a <FSettingProduct+0x3d8>
   1128c:	60 91 ee 02 	lds	r22, 0x02EE
   11290:	8d e0       	ldi	r24, 0x0D	; 13
   11292:	68 9f       	mul	r22, r24
   11294:	b0 01       	movw	r22, r0
   11296:	11 24       	eor	r1, r1
   11298:	65 54       	subi	r22, 0x45	; 69
   1129a:	7f 4f       	sbci	r23, 0xFF	; 255
   1129c:	7e 01       	movw	r14, r28
   1129e:	08 94       	sec
   112a0:	e1 1c       	adc	r14, r1
   112a2:	f1 1c       	adc	r15, r1
   112a4:	c7 01       	movw	r24, r14
   112a6:	4d e0       	ldi	r20, 0x0D	; 13
   112a8:	50 e0       	ldi	r21, 0x00	; 0
   112aa:	23 ef       	ldi	r18, 0xF3	; 243
   112ac:	32 e1       	ldi	r19, 0x12	; 18
   112ae:	0e 94 1f b4 	call	0x1683e	; 0x1683e <__eerd_block>
		  }
	      break;
     case mpDispPrice:
	 	  eeprom_read_block((void*) &strProductName, (const void*) &DefProductName[ProdID], 13);
		  eeprom_read_block((void*) &strPrice, (const void*) &DefProductPrice[ProdID], 9);
		  sprintf_P(lcdteks,PSTR("1)%s"),strProductName);
   112b2:	74 ee       	ldi	r23, 0xE4	; 228
   112b4:	c7 2e       	mov	r12, r23
   112b6:	72 e0       	ldi	r23, 0x02	; 2
   112b8:	d7 2e       	mov	r13, r23
   112ba:	60 91 ee 02 	lds	r22, 0x02EE
   112be:	89 e0       	ldi	r24, 0x09	; 9
   112c0:	68 9f       	mul	r22, r24
   112c2:	b0 01       	movw	r22, r0
   112c4:	11 24       	eor	r1, r1
   112c6:	6b 57       	subi	r22, 0x7B	; 123
   112c8:	7f 4f       	sbci	r23, 0xFF	; 255
   112ca:	c6 01       	movw	r24, r12
   112cc:	49 e0       	ldi	r20, 0x09	; 9
   112ce:	50 e0       	ldi	r21, 0x00	; 0
   112d0:	23 ef       	ldi	r18, 0xF3	; 243
   112d2:	32 e1       	ldi	r19, 0x12	; 18
   112d4:	0e 94 1f b4 	call	0x1683e	; 0x1683e <__eerd_block>
   112d8:	00 d0       	rcall	.+0      	; 0x112da <FSettingProduct+0x198>
   112da:	00 d0       	rcall	.+0      	; 0x112dc <FSettingProduct+0x19a>
   112dc:	00 d0       	rcall	.+0      	; 0x112de <FSettingProduct+0x19c>
   112de:	ed b7       	in	r30, 0x3d	; 61
   112e0:	fe b7       	in	r31, 0x3e	; 62
   112e2:	31 96       	adiw	r30, 0x01	; 1
   112e4:	8e 01       	movw	r16, r28
   112e6:	02 5f       	subi	r16, 0xF2	; 242
   112e8:	1f 4f       	sbci	r17, 0xFF	; 255
   112ea:	ad b7       	in	r26, 0x3d	; 61
   112ec:	be b7       	in	r27, 0x3e	; 62
   112ee:	12 96       	adiw	r26, 0x02	; 2
   112f0:	1c 93       	st	X, r17
   112f2:	0e 93       	st	-X, r16
   112f4:	11 97       	sbiw	r26, 0x01	; 1
   112f6:	8c ef       	ldi	r24, 0xFC	; 252
   112f8:	91 e1       	ldi	r25, 0x11	; 17
   112fa:	93 83       	std	Z+3, r25	; 0x03
   112fc:	82 83       	std	Z+2, r24	; 0x02
   112fe:	f5 82       	std	Z+5, r15	; 0x05
   11300:	e4 82       	std	Z+4, r14	; 0x04
   11302:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
		  lcd_clear();lcd_print(1,1,lcdteks);
   11306:	8d b7       	in	r24, 0x3d	; 61
   11308:	9e b7       	in	r25, 0x3e	; 62
   1130a:	06 96       	adiw	r24, 0x06	; 6
   1130c:	0f b6       	in	r0, 0x3f	; 63
   1130e:	f8 94       	cli
   11310:	9e bf       	out	0x3e, r25	; 62
   11312:	0f be       	out	0x3f, r0	; 63
   11314:	8d bf       	out	0x3d, r24	; 61
   11316:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
   1131a:	81 e0       	ldi	r24, 0x01	; 1
   1131c:	61 e0       	ldi	r22, 0x01	; 1
   1131e:	a8 01       	movw	r20, r16
   11320:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
		  sprintf_P(lcdteks,PSTR("2)%s"),strPrice);
   11324:	00 d0       	rcall	.+0      	; 0x11326 <FSettingProduct+0x1e4>
   11326:	00 d0       	rcall	.+0      	; 0x11328 <FSettingProduct+0x1e6>
   11328:	00 d0       	rcall	.+0      	; 0x1132a <FSettingProduct+0x1e8>
   1132a:	ed b7       	in	r30, 0x3d	; 61
   1132c:	fe b7       	in	r31, 0x3e	; 62
   1132e:	31 96       	adiw	r30, 0x01	; 1
   11330:	ad b7       	in	r26, 0x3d	; 61
   11332:	be b7       	in	r27, 0x3e	; 62
   11334:	12 96       	adiw	r26, 0x02	; 2
   11336:	1c 93       	st	X, r17
   11338:	0e 93       	st	-X, r16
   1133a:	11 97       	sbiw	r26, 0x01	; 1
   1133c:	87 ef       	ldi	r24, 0xF7	; 247
   1133e:	91 e1       	ldi	r25, 0x11	; 17
   11340:	93 83       	std	Z+3, r25	; 0x03
   11342:	82 83       	std	Z+2, r24	; 0x02
   11344:	d5 82       	std	Z+5, r13	; 0x05
   11346:	c4 82       	std	Z+4, r12	; 0x04
   11348:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
		  lcd_print(2,1,lcdteks);
   1134c:	8d b7       	in	r24, 0x3d	; 61
   1134e:	9e b7       	in	r25, 0x3e	; 62
   11350:	06 96       	adiw	r24, 0x06	; 6
   11352:	0f b6       	in	r0, 0x3f	; 63
   11354:	f8 94       	cli
   11356:	9e bf       	out	0x3e, r25	; 62
   11358:	0f be       	out	0x3f, r0	; 63
   1135a:	8d bf       	out	0x3d, r24	; 61
   1135c:	82 e0       	ldi	r24, 0x02	; 2
   1135e:	61 e0       	ldi	r22, 0x01	; 1
   11360:	a8 01       	movw	r20, r16
   11362:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
		  lcd_printf(4,1,PSTR("*)Back       "));
   11366:	84 e0       	ldi	r24, 0x04	; 4
   11368:	61 e0       	ldi	r22, 0x01	; 1
   1136a:	49 ee       	ldi	r20, 0xE9	; 233
   1136c:	51 e1       	ldi	r21, 0x11	; 17
   1136e:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		  stMenuProduct=mpIsEdit;
   11372:	83 e0       	ldi	r24, 0x03	; 3
   11374:	d2 c0       	rjmp	.+420    	; 0x1151a <FSettingProduct+0x3d8>
	      break;
     case mpIsEdit:
		  KeyPressed=_key_scan(1);
   11376:	81 e0       	ldi	r24, 0x01	; 1
   11378:	0e 94 ab ae 	call	0x15d56	; 0x15d56 <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
   1137c:	0e 94 0c ae 	call	0x15c18	; 0x15c18 <_key_btn>
		  if (KeyChar=='*'){
   11380:	8a 32       	cpi	r24, 0x2A	; 42
   11382:	09 f4       	brne	.+2      	; 0x11386 <FSettingProduct+0x244>
   11384:	a7 c0       	rjmp	.+334    	; 0x114d4 <FSettingProduct+0x392>
		      stMenuProduct=mpInitProduct;
		  }else
		  if (KeyChar=='1'){
   11386:	81 33       	cpi	r24, 0x31	; 49
   11388:	09 f0       	breq	.+2      	; 0x1138c <FSettingProduct+0x24a>
   1138a:	4c c0       	rjmp	.+152    	; 0x11424 <FSettingProduct+0x2e2>
   1138c:	60 91 ee 02 	lds	r22, 0x02EE
   11390:	8d e0       	ldi	r24, 0x0D	; 13
   11392:	68 9f       	mul	r22, r24
   11394:	b0 01       	movw	r22, r0
   11396:	11 24       	eor	r1, r1
   11398:	65 54       	subi	r22, 0x45	; 69
   1139a:	7f 4f       	sbci	r23, 0xFF	; 255
   1139c:	8e 01       	movw	r16, r28
   1139e:	0f 5f       	subi	r16, 0xFF	; 255
   113a0:	1f 4f       	sbci	r17, 0xFF	; 255
   113a2:	c8 01       	movw	r24, r16
   113a4:	4d e0       	ldi	r20, 0x0D	; 13
   113a6:	50 e0       	ldi	r21, 0x00	; 0
   113a8:	23 ef       	ldi	r18, 0xF3	; 243
   113aa:	32 e1       	ldi	r19, 0x12	; 18
   113ac:	0e 94 1f b4 	call	0x1683e	; 0x1683e <__eerd_block>
		      eeprom_read_block((void*) &strProductName, (const void*) &DefProductName[ProdID], 13);
		      sprintf_P(lcdteks,PSTR("Old:%s"),strProductName);
   113b0:	00 d0       	rcall	.+0      	; 0x113b2 <FSettingProduct+0x270>
   113b2:	00 d0       	rcall	.+0      	; 0x113b4 <FSettingProduct+0x272>
   113b4:	00 d0       	rcall	.+0      	; 0x113b6 <FSettingProduct+0x274>
   113b6:	ed b7       	in	r30, 0x3d	; 61
   113b8:	fe b7       	in	r31, 0x3e	; 62
   113ba:	31 96       	adiw	r30, 0x01	; 1
   113bc:	6e e0       	ldi	r22, 0x0E	; 14
   113be:	e6 2e       	mov	r14, r22
   113c0:	f1 2c       	mov	r15, r1
   113c2:	ec 0e       	add	r14, r28
   113c4:	fd 1e       	adc	r15, r29
   113c6:	ad b7       	in	r26, 0x3d	; 61
   113c8:	be b7       	in	r27, 0x3e	; 62
   113ca:	12 96       	adiw	r26, 0x02	; 2
   113cc:	fc 92       	st	X, r15
   113ce:	ee 92       	st	-X, r14
   113d0:	11 97       	sbiw	r26, 0x01	; 1
   113d2:	82 ee       	ldi	r24, 0xE2	; 226
   113d4:	91 e1       	ldi	r25, 0x11	; 17
   113d6:	93 83       	std	Z+3, r25	; 0x03
   113d8:	82 83       	std	Z+2, r24	; 0x02
   113da:	15 83       	std	Z+5, r17	; 0x05
   113dc:	04 83       	std	Z+4, r16	; 0x04
   113de:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
			  lcd_printf(1,1,PSTR("Edit Product Name   "));
   113e2:	8d b7       	in	r24, 0x3d	; 61
   113e4:	9e b7       	in	r25, 0x3e	; 62
   113e6:	06 96       	adiw	r24, 0x06	; 6
   113e8:	0f b6       	in	r0, 0x3f	; 63
   113ea:	f8 94       	cli
   113ec:	9e bf       	out	0x3e, r25	; 62
   113ee:	0f be       	out	0x3f, r0	; 63
   113f0:	8d bf       	out	0x3d, r24	; 61
   113f2:	81 e0       	ldi	r24, 0x01	; 1
   113f4:	61 e0       	ldi	r22, 0x01	; 1
   113f6:	4d ec       	ldi	r20, 0xCD	; 205
   113f8:	51 e1       	ldi	r21, 0x11	; 17
   113fa:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		       lcd_print(2,1,lcdteks);
   113fe:	82 e0       	ldi	r24, 0x02	; 2
   11400:	61 e0       	ldi	r22, 0x01	; 1
   11402:	a7 01       	movw	r20, r14
   11404:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
			  lcd_printf(3,1,PSTR("New:_"));
   11408:	83 e0       	ldi	r24, 0x03	; 3
   1140a:	61 e0       	ldi	r22, 0x01	; 1
   1140c:	47 ec       	ldi	r20, 0xC7	; 199
   1140e:	51 e1       	ldi	r21, 0x11	; 17
   11410:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		      lcd_printf(4,1,PSTR("*)Back    #)OK      "));
   11414:	84 e0       	ldi	r24, 0x04	; 4
   11416:	61 e0       	ldi	r22, 0x01	; 1
   11418:	42 eb       	ldi	r20, 0xB2	; 178
   1141a:	51 e1       	ldi	r21, 0x11	; 17
   1141c:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		      stMenuProduct=mpEditProductName;
   11420:	85 e0       	ldi	r24, 0x05	; 5
   11422:	7b c0       	rjmp	.+246    	; 0x1151a <FSettingProduct+0x3d8>
		  }else
		  if (KeyChar=='2'){
   11424:	82 33       	cpi	r24, 0x32	; 50
   11426:	09 f0       	breq	.+2      	; 0x1142a <FSettingProduct+0x2e8>
   11428:	82 c0       	rjmp	.+260    	; 0x1152e <FSettingProduct+0x3ec>
		      uiResult=USER_NONE;
   1142a:	10 92 ed 02 	sts	0x02ED, r1
		      sprintf_P(lcdteks,PSTR("Old:%s"),strPrice);
   1142e:	00 d0       	rcall	.+0      	; 0x11430 <FSettingProduct+0x2ee>
   11430:	00 d0       	rcall	.+0      	; 0x11432 <FSettingProduct+0x2f0>
   11432:	00 d0       	rcall	.+0      	; 0x11434 <FSettingProduct+0x2f2>
   11434:	ed b7       	in	r30, 0x3d	; 61
   11436:	fe b7       	in	r31, 0x3e	; 62
   11438:	31 96       	adiw	r30, 0x01	; 1
   1143a:	8e 01       	movw	r16, r28
   1143c:	02 5f       	subi	r16, 0xF2	; 242
   1143e:	1f 4f       	sbci	r17, 0xFF	; 255
   11440:	ad b7       	in	r26, 0x3d	; 61
   11442:	be b7       	in	r27, 0x3e	; 62
   11444:	12 96       	adiw	r26, 0x02	; 2
   11446:	1c 93       	st	X, r17
   11448:	0e 93       	st	-X, r16
   1144a:	11 97       	sbiw	r26, 0x01	; 1
   1144c:	8b ea       	ldi	r24, 0xAB	; 171
   1144e:	91 e1       	ldi	r25, 0x11	; 17
   11450:	93 83       	std	Z+3, r25	; 0x03
   11452:	82 83       	std	Z+2, r24	; 0x02
   11454:	84 ee       	ldi	r24, 0xE4	; 228
   11456:	92 e0       	ldi	r25, 0x02	; 2
   11458:	95 83       	std	Z+5, r25	; 0x05
   1145a:	84 83       	std	Z+4, r24	; 0x04
   1145c:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
		       lcd_print(2,1,lcdteks);
   11460:	8d b7       	in	r24, 0x3d	; 61
   11462:	9e b7       	in	r25, 0x3e	; 62
   11464:	06 96       	adiw	r24, 0x06	; 6
   11466:	0f b6       	in	r0, 0x3f	; 63
   11468:	f8 94       	cli
   1146a:	9e bf       	out	0x3e, r25	; 62
   1146c:	0f be       	out	0x3f, r0	; 63
   1146e:	8d bf       	out	0x3d, r24	; 61
   11470:	82 e0       	ldi	r24, 0x02	; 2
   11472:	61 e0       	ldi	r22, 0x01	; 1
   11474:	a8 01       	movw	r20, r16
   11476:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
			  lcd_printf(3,1,PSTR("New:_"));
   1147a:	83 e0       	ldi	r24, 0x03	; 3
   1147c:	61 e0       	ldi	r22, 0x01	; 1
   1147e:	45 ea       	ldi	r20, 0xA5	; 165
   11480:	51 e1       	ldi	r21, 0x11	; 17
   11482:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		      lcd_printf(4,1,PSTR("*)Back    #)OK      "));
   11486:	84 e0       	ldi	r24, 0x04	; 4
   11488:	61 e0       	ldi	r22, 0x01	; 1
   1148a:	40 e9       	ldi	r20, 0x90	; 144
   1148c:	51 e1       	ldi	r21, 0x11	; 17
   1148e:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		      stMenuProduct=mpEditPrice;
   11492:	84 e0       	ldi	r24, 0x04	; 4
   11494:	42 c0       	rjmp	.+132    	; 0x1151a <FSettingProduct+0x3d8>
		  }
	      break;
     case mpEditProductName:
	      uiResult=UserInput(UI_ALPHANUM_R,3,5,strDescription,0,10);
   11496:	83 e0       	ldi	r24, 0x03	; 3
   11498:	63 e0       	ldi	r22, 0x03	; 3
   1149a:	45 e0       	ldi	r20, 0x05	; 5
   1149c:	21 e1       	ldi	r18, 0x11	; 17
   1149e:	3a e0       	ldi	r19, 0x0A	; 10
   114a0:	00 e0       	ldi	r16, 0x00	; 0
   114a2:	10 e0       	ldi	r17, 0x00	; 0
   114a4:	5a e0       	ldi	r21, 0x0A	; 10
   114a6:	e5 2e       	mov	r14, r21
   114a8:	0e 94 f0 7b 	call	0xf7e0	; 0xf7e0 <UserInput>
   114ac:	80 93 ed 02 	sts	0x02ED, r24
		  if (uiResult==USER_OK){
   114b0:	83 30       	cpi	r24, 0x03	; 3
   114b2:	b1 f5       	brne	.+108    	; 0x11520 <FSettingProduct+0x3de>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
   114b4:	80 91 ee 02 	lds	r24, 0x02EE
   114b8:	2d e0       	ldi	r18, 0x0D	; 13
   114ba:	82 9f       	mul	r24, r18
   114bc:	c0 01       	movw	r24, r0
   114be:	11 24       	eor	r1, r1
   114c0:	85 54       	subi	r24, 0x45	; 69
   114c2:	9f 4f       	sbci	r25, 0xFF	; 255
   114c4:	61 e1       	ldi	r22, 0x11	; 17
   114c6:	7a e0       	ldi	r23, 0x0A	; 10
   114c8:	4d e0       	ldi	r20, 0x0D	; 13
   114ca:	50 e0       	ldi	r21, 0x00	; 0
   114cc:	2b ef       	ldi	r18, 0xFB	; 251
   114ce:	32 e1       	ldi	r19, 0x12	; 18
   114d0:	0e 94 3b b4 	call	0x16876	; 0x16876 <__eewr_block>
		      eeprom_write_block((const void*)&strDescription,(void*)&DefProductName[ProdID], 13);
		      stMenuProduct=mpInitProduct;
   114d4:	10 92 ef 02 	sts	0x02EF, r1
   114d8:	2a c0       	rjmp	.+84     	; 0x1152e <FSettingProduct+0x3ec>
			  }
		  else
		  if (uiResult==USER_CANCEL)stMenuProduct=mpDispPrice;
	      break;
     case mpEditPrice:
	      uiResult=UserInput(UI_NUMBER_R,3,5,strPrice,0,7);
   114da:	81 e0       	ldi	r24, 0x01	; 1
   114dc:	63 e0       	ldi	r22, 0x03	; 3
   114de:	45 e0       	ldi	r20, 0x05	; 5
   114e0:	24 ee       	ldi	r18, 0xE4	; 228
   114e2:	32 e0       	ldi	r19, 0x02	; 2
   114e4:	00 e0       	ldi	r16, 0x00	; 0
   114e6:	10 e0       	ldi	r17, 0x00	; 0
   114e8:	97 e0       	ldi	r25, 0x07	; 7
   114ea:	e9 2e       	mov	r14, r25
   114ec:	0e 94 f0 7b 	call	0xf7e0	; 0xf7e0 <UserInput>
   114f0:	80 93 ed 02 	sts	0x02ED, r24
		  if (uiResult==USER_OK){
   114f4:	83 30       	cpi	r24, 0x03	; 3
   114f6:	a1 f4       	brne	.+40     	; 0x11520 <FSettingProduct+0x3de>
   114f8:	80 91 ee 02 	lds	r24, 0x02EE
   114fc:	29 e0       	ldi	r18, 0x09	; 9
   114fe:	82 9f       	mul	r24, r18
   11500:	c0 01       	movw	r24, r0
   11502:	11 24       	eor	r1, r1
   11504:	8b 57       	subi	r24, 0x7B	; 123
   11506:	9f 4f       	sbci	r25, 0xFF	; 255
   11508:	64 ee       	ldi	r22, 0xE4	; 228
   1150a:	72 e0       	ldi	r23, 0x02	; 2
   1150c:	49 e0       	ldi	r20, 0x09	; 9
   1150e:	50 e0       	ldi	r21, 0x00	; 0
   11510:	2b ef       	ldi	r18, 0xFB	; 251
   11512:	32 e1       	ldi	r19, 0x12	; 18
   11514:	0e 94 3b b4 	call	0x16876	; 0x16876 <__eewr_block>
		      eeprom_write_block((const void*)&strPrice,(void*)&DefProductPrice[ProdID], 9);
		      stMenuProduct=mpDispPrice;//stMenuProduct=mpInit;
   11518:	82 e0       	ldi	r24, 0x02	; 2
   1151a:	80 93 ef 02 	sts	0x02EF, r24
   1151e:	07 c0       	rjmp	.+14     	; 0x1152e <FSettingProduct+0x3ec>
			  }
		  else
		  if (uiResult==USER_CANCEL)stMenuProduct=mpDispPrice;
   11520:	81 30       	cpi	r24, 0x01	; 1
   11522:	29 f4       	brne	.+10     	; 0x1152e <FSettingProduct+0x3ec>
   11524:	f9 cf       	rjmp	.-14     	; 0x11518 <FSettingProduct+0x3d6>
	      break;
     case mpExitMenuProduct:
	      stMenuProduct=mpInitProduct;
   11526:	10 92 ef 02 	sts	0x02EF, r1
   1152a:	81 e0       	ldi	r24, 0x01	; 1
   1152c:	01 c0       	rjmp	.+2      	; 0x11530 <FSettingProduct+0x3ee>
   1152e:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
   return Result;
}
   11530:	a1 96       	adiw	r28, 0x21	; 33
   11532:	0f b6       	in	r0, 0x3f	; 63
   11534:	f8 94       	cli
   11536:	de bf       	out	0x3e, r29	; 62
   11538:	0f be       	out	0x3f, r0	; 63
   1153a:	cd bf       	out	0x3d, r28	; 61
   1153c:	cf 91       	pop	r28
   1153e:	df 91       	pop	r29
   11540:	1f 91       	pop	r17
   11542:	0f 91       	pop	r16
   11544:	ff 90       	pop	r15
   11546:	ef 90       	pop	r14
   11548:	df 90       	pop	r13
   1154a:	cf 90       	pop	r12
   1154c:	bf 90       	pop	r11
   1154e:	af 90       	pop	r10
   11550:	9f 90       	pop	r9
   11552:	8f 90       	pop	r8
   11554:	7f 90       	pop	r7
   11556:	6f 90       	pop	r6
   11558:	08 95       	ret

0001155a <FMenuSettingFooter>:
	 }
   //_menu_header();   
   return Result;
}

char FMenuSettingFooter(){
   1155a:	ef 92       	push	r14
   1155c:	0f 93       	push	r16
   1155e:	1f 93       	push	r17
   11560:	df 93       	push	r29
   11562:	cf 93       	push	r28
   11564:	cd b7       	in	r28, 0x3d	; 61
   11566:	de b7       	in	r29, 0x3e	; 62
   11568:	c6 54       	subi	r28, 0x46	; 70
   1156a:	d0 40       	sbci	r29, 0x00	; 0
   1156c:	0f b6       	in	r0, 0x3f	; 63
   1156e:	f8 94       	cli
   11570:	de bf       	out	0x3e, r29	; 62
   11572:	0f be       	out	0x3f, r0	; 63
   11574:	cd bf       	out	0x3d, r28	; 61
	 char lcdteks[20];
	 char strHeaderFooter[50];
	 
	 Result=MENU_NONE;
     
	 switch (stSettingHeader){
   11576:	80 91 1a 03 	lds	r24, 0x031A
   1157a:	84 30       	cpi	r24, 0x04	; 4
   1157c:	09 f4       	brne	.+2      	; 0x11580 <FMenuSettingFooter+0x26>
   1157e:	3f c1       	rjmp	.+638    	; 0x117fe <FMenuSettingFooter+0x2a4>
   11580:	85 30       	cpi	r24, 0x05	; 5
   11582:	40 f4       	brcc	.+16     	; 0x11594 <FMenuSettingFooter+0x3a>
   11584:	81 30       	cpi	r24, 0x01	; 1
   11586:	79 f1       	breq	.+94     	; 0x115e6 <FMenuSettingFooter+0x8c>
   11588:	81 30       	cpi	r24, 0x01	; 1
   1158a:	88 f0       	brcs	.+34     	; 0x115ae <FMenuSettingFooter+0x54>
   1158c:	82 30       	cpi	r24, 0x02	; 2
   1158e:	09 f0       	breq	.+2      	; 0x11592 <FMenuSettingFooter+0x38>
   11590:	85 c1       	rjmp	.+778    	; 0x1189c <FMenuSettingFooter+0x342>
   11592:	76 c0       	rjmp	.+236    	; 0x11680 <FMenuSettingFooter+0x126>
   11594:	86 30       	cpi	r24, 0x06	; 6
   11596:	09 f4       	brne	.+2      	; 0x1159a <FMenuSettingFooter+0x40>
   11598:	d7 c0       	rjmp	.+430    	; 0x11748 <FMenuSettingFooter+0x1ee>
   1159a:	86 30       	cpi	r24, 0x06	; 6
   1159c:	08 f4       	brcc	.+2      	; 0x115a0 <FMenuSettingFooter+0x46>
   1159e:	bf c0       	rjmp	.+382    	; 0x1171e <FMenuSettingFooter+0x1c4>
   115a0:	87 30       	cpi	r24, 0x07	; 7
   115a2:	09 f4       	brne	.+2      	; 0x115a6 <FMenuSettingFooter+0x4c>
   115a4:	3d c1       	rjmp	.+634    	; 0x11820 <FMenuSettingFooter+0x2c6>
   115a6:	88 30       	cpi	r24, 0x08	; 8
   115a8:	09 f0       	breq	.+2      	; 0x115ac <FMenuSettingFooter+0x52>
   115aa:	78 c1       	rjmp	.+752    	; 0x1189c <FMenuSettingFooter+0x342>
   115ac:	73 c1       	rjmp	.+742    	; 0x11894 <FMenuSettingFooter+0x33a>
	 case shInitHeader:
	      lcd_clear();
   115ae:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
		  lcd_printf(1,1,PSTR("1)Footer1  3)Footer3"));
   115b2:	81 e0       	ldi	r24, 0x01	; 1
   115b4:	61 e0       	ldi	r22, 0x01	; 1
   115b6:	4f ef       	ldi	r20, 0xFF	; 255
   115b8:	53 e1       	ldi	r21, 0x13	; 19
   115ba:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		  lcd_printf(2,1,PSTR("2)Footer2  4)Footer4"));
   115be:	82 e0       	ldi	r24, 0x02	; 2
   115c0:	61 e0       	ldi	r22, 0x01	; 1
   115c2:	4a ee       	ldi	r20, 0xEA	; 234
   115c4:	53 e1       	ldi	r21, 0x13	; 19
   115c6:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		  lcd_printf(3,1,PSTR("                    "));
   115ca:	83 e0       	ldi	r24, 0x03	; 3
   115cc:	61 e0       	ldi	r22, 0x01	; 1
   115ce:	45 ed       	ldi	r20, 0xD5	; 213
   115d0:	53 e1       	ldi	r21, 0x13	; 19
   115d2:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		  lcd_printf(4,1,PSTR("*)Exit              "));
   115d6:	84 e0       	ldi	r24, 0x04	; 4
   115d8:	61 e0       	ldi	r22, 0x01	; 1
   115da:	40 ec       	ldi	r20, 0xC0	; 192
   115dc:	53 e1       	ldi	r21, 0x13	; 19
   115de:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		  stSettingHeader=shHeaderSelect;
   115e2:	81 e0       	ldi	r24, 0x01	; 1
   115e4:	16 c1       	rjmp	.+556    	; 0x11812 <FMenuSettingFooter+0x2b8>
	      break;
      case shHeaderSelect:
	      KeyChar=_key_btn(_key_scan(1));
   115e6:	81 e0       	ldi	r24, 0x01	; 1
   115e8:	0e 94 ab ae 	call	0x15d56	; 0x15d56 <_key_scan>
   115ec:	0e 94 0c ae 	call	0x15c18	; 0x15c18 <_key_btn>
   115f0:	80 93 18 03 	sts	0x0318, r24
		  if ((KeyChar>='1')&&(KeyChar<='6')){
   115f4:	81 53       	subi	r24, 0x31	; 49
   115f6:	86 30       	cpi	r24, 0x06	; 6
   115f8:	e0 f5       	brcc	.+120    	; 0x11672 <FMenuSettingFooter+0x118>
		       HeaderIdx=KeyChar-'1';//
   115fa:	80 93 19 03 	sts	0x0319, r24
			   lcd_clear();
   115fe:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
			   sprintf_P(lcdteks,PSTR("Edit Footer%d "),HeaderIdx+1);
   11602:	00 d0       	rcall	.+0      	; 0x11604 <FMenuSettingFooter+0xaa>
   11604:	00 d0       	rcall	.+0      	; 0x11606 <FMenuSettingFooter+0xac>
   11606:	00 d0       	rcall	.+0      	; 0x11608 <FMenuSettingFooter+0xae>
   11608:	ed b7       	in	r30, 0x3d	; 61
   1160a:	fe b7       	in	r31, 0x3e	; 62
   1160c:	31 96       	adiw	r30, 0x01	; 1
   1160e:	8e 01       	movw	r16, r28
   11610:	0f 5f       	subi	r16, 0xFF	; 255
   11612:	1f 4f       	sbci	r17, 0xFF	; 255
   11614:	ad b7       	in	r26, 0x3d	; 61
   11616:	be b7       	in	r27, 0x3e	; 62
   11618:	12 96       	adiw	r26, 0x02	; 2
   1161a:	1c 93       	st	X, r17
   1161c:	0e 93       	st	-X, r16
   1161e:	11 97       	sbiw	r26, 0x01	; 1
   11620:	81 eb       	ldi	r24, 0xB1	; 177
   11622:	93 e1       	ldi	r25, 0x13	; 19
   11624:	93 83       	std	Z+3, r25	; 0x03
   11626:	82 83       	std	Z+2, r24	; 0x02
   11628:	80 91 19 03 	lds	r24, 0x0319
   1162c:	90 e0       	ldi	r25, 0x00	; 0
   1162e:	01 96       	adiw	r24, 0x01	; 1
   11630:	95 83       	std	Z+5, r25	; 0x05
   11632:	84 83       	std	Z+4, r24	; 0x04
   11634:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
			   lcd_print(1,1,lcdteks);
   11638:	8d b7       	in	r24, 0x3d	; 61
   1163a:	9e b7       	in	r25, 0x3e	; 62
   1163c:	06 96       	adiw	r24, 0x06	; 6
   1163e:	0f b6       	in	r0, 0x3f	; 63
   11640:	f8 94       	cli
   11642:	9e bf       	out	0x3e, r25	; 62
   11644:	0f be       	out	0x3f, r0	; 63
   11646:	8d bf       	out	0x3d, r24	; 61
   11648:	81 e0       	ldi	r24, 0x01	; 1
   1164a:	61 e0       	ldi	r22, 0x01	; 1
   1164c:	a8 01       	movw	r20, r16
   1164e:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
			   lcd_printf(4,1,PSTR("[*]Back  [#]OK"));
   11652:	84 e0       	ldi	r24, 0x04	; 4
   11654:	61 e0       	ldi	r22, 0x01	; 1
   11656:	42 ea       	ldi	r20, 0xA2	; 162
   11658:	53 e1       	ldi	r21, 0x13	; 19
   1165a:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
   1165e:	ef ec       	ldi	r30, 0xCF	; 207
   11660:	f5 e0       	ldi	r31, 0x05	; 5
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
   11662:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   11664:	97 e0       	ldi	r25, 0x07	; 7
   11666:	e0 36       	cpi	r30, 0x60	; 96
   11668:	f9 07       	cpc	r31, r25
   1166a:	d9 f7       	brne	.-10     	; 0x11662 <FMenuSettingFooter+0x108>
			   lcd_clear();
			   sprintf_P(lcdteks,PSTR("Edit Footer%d "),HeaderIdx+1);
			   lcd_print(1,1,lcdteks);
			   lcd_printf(4,1,PSTR("[*]Back  [#]OK"));
			   FillChar(PrintBuffer,sizeof(PrintBuffer),0);
			   stSettingHeader=shEditHeader1;
   1166c:	82 e0       	ldi	r24, 0x02	; 2
   1166e:	80 93 1a 03 	sts	0x031A, r24
		  }
		  if(KeyChar=='*')stSettingHeader=shExitSettingHeader;
   11672:	80 91 18 03 	lds	r24, 0x0318
   11676:	8a 32       	cpi	r24, 0x2A	; 42
   11678:	09 f0       	breq	.+2      	; 0x1167c <FMenuSettingFooter+0x122>
   1167a:	10 c1       	rjmp	.+544    	; 0x1189c <FMenuSettingFooter+0x342>
   1167c:	88 e0       	ldi	r24, 0x08	; 8
   1167e:	c9 c0       	rjmp	.+402    	; 0x11812 <FMenuSettingFooter+0x2b8>
	      break;
     case shEditHeader1:
          //uiResult=UserInput(UI_ALPHANUM_R,2,1,strFreeMessageLine1,0,20);
		  uiResult=UserInput(UI_ALPHANUM_R,2,1,PrintBuffer,0,40);
   11680:	83 e0       	ldi	r24, 0x03	; 3
   11682:	62 e0       	ldi	r22, 0x02	; 2
   11684:	41 e0       	ldi	r20, 0x01	; 1
   11686:	2f ec       	ldi	r18, 0xCF	; 207
   11688:	35 e0       	ldi	r19, 0x05	; 5
   1168a:	00 e0       	ldi	r16, 0x00	; 0
   1168c:	10 e0       	ldi	r17, 0x00	; 0
   1168e:	98 e2       	ldi	r25, 0x28	; 40
   11690:	e9 2e       	mov	r14, r25
   11692:	0e 94 f0 7b 	call	0xf7e0	; 0xf7e0 <UserInput>
		  if (uiResult==USER_OK){
   11696:	83 30       	cpi	r24, 0x03	; 3
   11698:	f1 f5       	brne	.+124    	; 0x11716 <FMenuSettingFooter+0x1bc>
			  lcd_clear();
   1169a:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
			  AddSpaceLag(PrintBuffer,40);
   1169e:	8f ec       	ldi	r24, 0xCF	; 207
   116a0:	95 e0       	ldi	r25, 0x05	; 5
   116a2:	68 e2       	ldi	r22, 0x28	; 40
   116a4:	0e 94 d8 2a 	call	0x55b0	; 0x55b0 <AddSpaceLag>
   116a8:	20 e0       	ldi	r18, 0x00	; 0
   116aa:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   116ac:	f9 01       	movw	r30, r18
   116ae:	e9 56       	subi	r30, 0x69	; 105
   116b0:	f5 4f       	sbci	r31, 0xF5	; 245
   116b2:	d9 01       	movw	r26, r18
   116b4:	a1 53       	subi	r26, 0x31	; 49
   116b6:	ba 4f       	sbci	r27, 0xFA	; 250
   116b8:	8c 91       	ld	r24, X
   116ba:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   116bc:	2f 5f       	subi	r18, 0xFF	; 255
   116be:	3f 4f       	sbci	r19, 0xFF	; 255
   116c0:	24 31       	cpi	r18, 0x14	; 20
   116c2:	31 05       	cpc	r19, r1
   116c4:	99 f7       	brne	.-26     	; 0x116ac <FMenuSettingFooter+0x152>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   116c6:	10 92 ab 0a 	sts	0x0AAB, r1
   116ca:	e3 ee       	ldi	r30, 0xE3	; 227
   116cc:	f5 e0       	ldi	r31, 0x05	; 5
   116ce:	a6 e8       	ldi	r26, 0x86	; 134
   116d0:	b9 e0       	ldi	r27, 0x09	; 9
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   116d2:	81 91       	ld	r24, Z+
   116d4:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   116d6:	85 e0       	ldi	r24, 0x05	; 5
   116d8:	e7 3f       	cpi	r30, 0xF7	; 247
   116da:	f8 07       	cpc	r31, r24
   116dc:	d1 f7       	brne	.-12     	; 0x116d2 <FMenuSettingFooter+0x178>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   116de:	10 92 9a 09 	sts	0x099A, r1
			  lcd_clear();
			  AddSpaceLag(PrintBuffer,40);
			  StrPosCopy(PrintBuffer,strFreeMessageLine1,0,20);
			  StrPosCopy(PrintBuffer,strFreeMessageLine2,20,20);

			  lcd_print(1,1,strFreeMessageLine1);			  
   116e2:	81 e0       	ldi	r24, 0x01	; 1
   116e4:	61 e0       	ldi	r22, 0x01	; 1
   116e6:	47 e9       	ldi	r20, 0x97	; 151
   116e8:	5a e0       	ldi	r21, 0x0A	; 10
   116ea:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
			  lcd_print(2,1,strFreeMessageLine2);			  
   116ee:	82 e0       	ldi	r24, 0x02	; 2
   116f0:	61 e0       	ldi	r22, 0x01	; 1
   116f2:	46 e8       	ldi	r20, 0x86	; 134
   116f4:	59 e0       	ldi	r21, 0x09	; 9
   116f6:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
			  
			  lcd_printf(3,1,PSTR("Align Center?"));
   116fa:	83 e0       	ldi	r24, 0x03	; 3
   116fc:	61 e0       	ldi	r22, 0x01	; 1
   116fe:	44 e9       	ldi	r20, 0x94	; 148
   11700:	53 e1       	ldi	r21, 0x13	; 19
   11702:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
			  lcd_printf(4,1,PSTR("[*]No  [#]Yes"));
   11706:	84 e0       	ldi	r24, 0x04	; 4
   11708:	61 e0       	ldi	r22, 0x01	; 1
   1170a:	46 e8       	ldi	r20, 0x86	; 134
   1170c:	53 e1       	ldi	r21, 0x13	; 19
   1170e:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		      stSettingHeader=shIsAlignCenter;
   11712:	85 e0       	ldi	r24, 0x05	; 5
   11714:	7e c0       	rjmp	.+252    	; 0x11812 <FMenuSettingFooter+0x2b8>
		  }
		  else
		  if (uiResult==USER_CANCEL)stSettingHeader=shInitHeader;
   11716:	81 30       	cpi	r24, 0x01	; 1
   11718:	09 f0       	breq	.+2      	; 0x1171c <FMenuSettingFooter+0x1c2>
   1171a:	c0 c0       	rjmp	.+384    	; 0x1189c <FMenuSettingFooter+0x342>
   1171c:	b8 c0       	rjmp	.+368    	; 0x1188e <FMenuSettingFooter+0x334>
	      break;
     case shIsAlignCenter:
	      KeyChar=_key_btn(_key_scan(1));
   1171e:	81 e0       	ldi	r24, 0x01	; 1
   11720:	0e 94 ab ae 	call	0x15d56	; 0x15d56 <_key_scan>
   11724:	0e 94 0c ae 	call	0x15c18	; 0x15c18 <_key_btn>
   11728:	80 93 18 03 	sts	0x0318, r24
          if(KeyChar=='#'){
   1172c:	83 32       	cpi	r24, 0x23	; 35
   1172e:	39 f4       	brne	.+14     	; 0x1173e <FMenuSettingFooter+0x1e4>
		      //AlignCenter			  
			  StrAlignCenter(PrintBuffer,40);
   11730:	8f ec       	ldi	r24, 0xCF	; 207
   11732:	95 e0       	ldi	r25, 0x05	; 5
   11734:	68 e2       	ldi	r22, 0x28	; 40
   11736:	70 e0       	ldi	r23, 0x00	; 0
   11738:	0e 94 e2 2c 	call	0x59c4	; 0x59c4 <StrAlignCenter>
   1173c:	03 c0       	rjmp	.+6      	; 0x11744 <FMenuSettingFooter+0x1ea>
			  stSettingHeader=shIsSaveHeader;
		  } else if(KeyChar=='*')stSettingHeader=shIsSaveHeader;		 
   1173e:	8a 32       	cpi	r24, 0x2A	; 42
   11740:	09 f0       	breq	.+2      	; 0x11744 <FMenuSettingFooter+0x1ea>
   11742:	ac c0       	rjmp	.+344    	; 0x1189c <FMenuSettingFooter+0x342>
   11744:	86 e0       	ldi	r24, 0x06	; 6
   11746:	65 c0       	rjmp	.+202    	; 0x11812 <FMenuSettingFooter+0x2b8>
	      break;
     case shIsSaveHeader:
	      lcd_clear(); 
   11748:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
   1174c:	20 e0       	ldi	r18, 0x00	; 0
   1174e:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   11750:	f9 01       	movw	r30, r18
   11752:	e9 56       	subi	r30, 0x69	; 105
   11754:	f5 4f       	sbci	r31, 0xF5	; 245
   11756:	d9 01       	movw	r26, r18
   11758:	a1 53       	subi	r26, 0x31	; 49
   1175a:	ba 4f       	sbci	r27, 0xFA	; 250
   1175c:	8c 91       	ld	r24, X
   1175e:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   11760:	2f 5f       	subi	r18, 0xFF	; 255
   11762:	3f 4f       	sbci	r19, 0xFF	; 255
   11764:	24 31       	cpi	r18, 0x14	; 20
   11766:	31 05       	cpc	r19, r1
   11768:	99 f7       	brne	.-26     	; 0x11750 <FMenuSettingFooter+0x1f6>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   1176a:	10 92 ab 0a 	sts	0x0AAB, r1
   1176e:	e3 ee       	ldi	r30, 0xE3	; 227
   11770:	f5 e0       	ldi	r31, 0x05	; 5
   11772:	a6 e8       	ldi	r26, 0x86	; 134
   11774:	b9 e0       	ldi	r27, 0x09	; 9
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   11776:	81 91       	ld	r24, Z+
   11778:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   1177a:	95 e0       	ldi	r25, 0x05	; 5
   1177c:	e7 3f       	cpi	r30, 0xF7	; 247
   1177e:	f9 07       	cpc	r31, r25
   11780:	d1 f7       	brne	.-12     	; 0x11776 <FMenuSettingFooter+0x21c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   11782:	10 92 9a 09 	sts	0x099A, r1
	      break;
     case shIsSaveHeader:
	      lcd_clear(); 
		  StrPosCopy(PrintBuffer,strFreeMessageLine1,0,20);
		  StrPosCopy(PrintBuffer,strFreeMessageLine2,20,20);
          lcd_print(1,1,strFreeMessageLine1);
   11786:	81 e0       	ldi	r24, 0x01	; 1
   11788:	61 e0       	ldi	r22, 0x01	; 1
   1178a:	47 e9       	ldi	r20, 0x97	; 151
   1178c:	5a e0       	ldi	r21, 0x0A	; 10
   1178e:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
		  lcd_print(2,1,strFreeMessageLine2);
   11792:	82 e0       	ldi	r24, 0x02	; 2
   11794:	61 e0       	ldi	r22, 0x01	; 1
   11796:	46 e8       	ldi	r20, 0x86	; 134
   11798:	59 e0       	ldi	r21, 0x09	; 9
   1179a:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
		  sprintf_P(lcdteks,PSTR("Save Footer%d ?"),HeaderIdx+1);
   1179e:	00 d0       	rcall	.+0      	; 0x117a0 <FMenuSettingFooter+0x246>
   117a0:	00 d0       	rcall	.+0      	; 0x117a2 <FMenuSettingFooter+0x248>
   117a2:	00 d0       	rcall	.+0      	; 0x117a4 <FMenuSettingFooter+0x24a>
   117a4:	ed b7       	in	r30, 0x3d	; 61
   117a6:	fe b7       	in	r31, 0x3e	; 62
   117a8:	31 96       	adiw	r30, 0x01	; 1
   117aa:	8e 01       	movw	r16, r28
   117ac:	0f 5f       	subi	r16, 0xFF	; 255
   117ae:	1f 4f       	sbci	r17, 0xFF	; 255
   117b0:	ad b7       	in	r26, 0x3d	; 61
   117b2:	be b7       	in	r27, 0x3e	; 62
   117b4:	12 96       	adiw	r26, 0x02	; 2
   117b6:	1c 93       	st	X, r17
   117b8:	0e 93       	st	-X, r16
   117ba:	11 97       	sbiw	r26, 0x01	; 1
   117bc:	86 e7       	ldi	r24, 0x76	; 118
   117be:	93 e1       	ldi	r25, 0x13	; 19
   117c0:	93 83       	std	Z+3, r25	; 0x03
   117c2:	82 83       	std	Z+2, r24	; 0x02
   117c4:	80 91 19 03 	lds	r24, 0x0319
   117c8:	90 e0       	ldi	r25, 0x00	; 0
   117ca:	01 96       	adiw	r24, 0x01	; 1
   117cc:	95 83       	std	Z+5, r25	; 0x05
   117ce:	84 83       	std	Z+4, r24	; 0x04
   117d0:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
		  lcd_print(3,1,lcdteks);
   117d4:	8d b7       	in	r24, 0x3d	; 61
   117d6:	9e b7       	in	r25, 0x3e	; 62
   117d8:	06 96       	adiw	r24, 0x06	; 6
   117da:	0f b6       	in	r0, 0x3f	; 63
   117dc:	f8 94       	cli
   117de:	9e bf       	out	0x3e, r25	; 62
   117e0:	0f be       	out	0x3f, r0	; 63
   117e2:	8d bf       	out	0x3d, r24	; 61
   117e4:	83 e0       	ldi	r24, 0x03	; 3
   117e6:	61 e0       	ldi	r22, 0x01	; 1
   117e8:	a8 01       	movw	r20, r16
   117ea:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
		  lcd_printf(4,1,PSTR("[*]No [#]Yes"));		      
   117ee:	84 e0       	ldi	r24, 0x04	; 4
   117f0:	61 e0       	ldi	r22, 0x01	; 1
   117f2:	49 e6       	ldi	r20, 0x69	; 105
   117f4:	53 e1       	ldi	r21, 0x13	; 19
   117f6:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
	      stSettingHeader=shSaveHeaderQuestions;      
   117fa:	84 e0       	ldi	r24, 0x04	; 4
   117fc:	0a c0       	rjmp	.+20     	; 0x11812 <FMenuSettingFooter+0x2b8>
	      break;       
     case shSaveHeaderQuestions:
          KeyChar=_key_btn(_key_scan(1));
   117fe:	81 e0       	ldi	r24, 0x01	; 1
   11800:	0e 94 ab ae 	call	0x15d56	; 0x15d56 <_key_scan>
   11804:	0e 94 0c ae 	call	0x15c18	; 0x15c18 <_key_btn>
   11808:	80 93 18 03 	sts	0x0318, r24
	      if(KeyChar=='#')stSettingHeader=shSaveHeader;
   1180c:	83 32       	cpi	r24, 0x23	; 35
   1180e:	21 f4       	brne	.+8      	; 0x11818 <FMenuSettingFooter+0x2be>
   11810:	87 e0       	ldi	r24, 0x07	; 7
   11812:	80 93 1a 03 	sts	0x031A, r24
   11816:	42 c0       	rjmp	.+132    	; 0x1189c <FMenuSettingFooter+0x342>
		  else
          if(KeyChar=='*')stSettingHeader=shInitHeader;
   11818:	8a 32       	cpi	r24, 0x2A	; 42
   1181a:	09 f0       	breq	.+2      	; 0x1181e <FMenuSettingFooter+0x2c4>
   1181c:	3f c0       	rjmp	.+126    	; 0x1189c <FMenuSettingFooter+0x342>
   1181e:	37 c0       	rjmp	.+110    	; 0x1188e <FMenuSettingFooter+0x334>
	      break;
     case shSaveHeader:
	      sprintf_P(strHeaderFooter,PSTR("%s%s"),strFreeMessageLine1,strFreeMessageLine2);
   11820:	ad b7       	in	r26, 0x3d	; 61
   11822:	be b7       	in	r27, 0x3e	; 62
   11824:	18 97       	sbiw	r26, 0x08	; 8
   11826:	0f b6       	in	r0, 0x3f	; 63
   11828:	f8 94       	cli
   1182a:	be bf       	out	0x3e, r27	; 62
   1182c:	0f be       	out	0x3f, r0	; 63
   1182e:	ad bf       	out	0x3d, r26	; 61
   11830:	ed b7       	in	r30, 0x3d	; 61
   11832:	fe b7       	in	r31, 0x3e	; 62
   11834:	31 96       	adiw	r30, 0x01	; 1
   11836:	8e 01       	movw	r16, r28
   11838:	0b 5e       	subi	r16, 0xEB	; 235
   1183a:	1f 4f       	sbci	r17, 0xFF	; 255
   1183c:	12 96       	adiw	r26, 0x02	; 2
   1183e:	1c 93       	st	X, r17
   11840:	0e 93       	st	-X, r16
   11842:	11 97       	sbiw	r26, 0x01	; 1
   11844:	84 e6       	ldi	r24, 0x64	; 100
   11846:	93 e1       	ldi	r25, 0x13	; 19
   11848:	93 83       	std	Z+3, r25	; 0x03
   1184a:	82 83       	std	Z+2, r24	; 0x02
   1184c:	87 e9       	ldi	r24, 0x97	; 151
   1184e:	9a e0       	ldi	r25, 0x0A	; 10
   11850:	95 83       	std	Z+5, r25	; 0x05
   11852:	84 83       	std	Z+4, r24	; 0x04
   11854:	86 e8       	ldi	r24, 0x86	; 134
   11856:	99 e0       	ldi	r25, 0x09	; 9
   11858:	97 83       	std	Z+7, r25	; 0x07
   1185a:	86 83       	std	Z+6, r24	; 0x06
   1185c:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
   11860:	8d b7       	in	r24, 0x3d	; 61
   11862:	9e b7       	in	r25, 0x3e	; 62
   11864:	08 96       	adiw	r24, 0x08	; 8
   11866:	0f b6       	in	r0, 0x3f	; 63
   11868:	f8 94       	cli
   1186a:	9e bf       	out	0x3e, r25	; 62
   1186c:	0f be       	out	0x3f, r0	; 63
   1186e:	8d bf       	out	0x3d, r24	; 61
   11870:	80 91 19 03 	lds	r24, 0x0319
   11874:	29 e2       	ldi	r18, 0x29	; 41
   11876:	82 9f       	mul	r24, r18
   11878:	c0 01       	movw	r24, r0
   1187a:	11 24       	eor	r1, r1
   1187c:	83 5e       	subi	r24, 0xE3	; 227
   1187e:	9c 4f       	sbci	r25, 0xFC	; 252
   11880:	b8 01       	movw	r22, r16
   11882:	48 e2       	ldi	r20, 0x28	; 40
   11884:	50 e0       	ldi	r21, 0x00	; 0
   11886:	2b ef       	ldi	r18, 0xFB	; 251
   11888:	32 e1       	ldi	r19, 0x12	; 18
   1188a:	0e 94 3b b4 	call	0x16876	; 0x16876 <__eewr_block>
	      eeprom_write_block((const void*) &strHeaderFooter, (void*) &DefHeaderFooter[HeaderIdx+6],40);
		  //eeprom_write_block((const void*) &PrintBuffer, (void*) &DefHeaderFooter[HeaderIdx+6],40);

          stSettingHeader=shInitHeader;
   1188e:	10 92 1a 03 	sts	0x031A, r1
   11892:	04 c0       	rjmp	.+8      	; 0x1189c <FMenuSettingFooter+0x342>
	      break;
     case shExitSettingHeader:
          stSettingHeader=shInitHeader;
   11894:	10 92 1a 03 	sts	0x031A, r1
   11898:	81 e0       	ldi	r24, 0x01	; 1
   1189a:	01 c0       	rjmp	.+2      	; 0x1189e <FMenuSettingFooter+0x344>
   1189c:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;	 
	 }
   return Result;
}
   1189e:	ca 5b       	subi	r28, 0xBA	; 186
   118a0:	df 4f       	sbci	r29, 0xFF	; 255
   118a2:	0f b6       	in	r0, 0x3f	; 63
   118a4:	f8 94       	cli
   118a6:	de bf       	out	0x3e, r29	; 62
   118a8:	0f be       	out	0x3f, r0	; 63
   118aa:	cd bf       	out	0x3d, r28	; 61
   118ac:	cf 91       	pop	r28
   118ae:	df 91       	pop	r29
   118b0:	1f 91       	pop	r17
   118b2:	0f 91       	pop	r16
   118b4:	ef 90       	pop	r14
   118b6:	08 95       	ret

000118b8 <FMenuSettingHeader>:
	      break;
	 }
   return Result;
}

char FMenuSettingHeader(){
   118b8:	ef 92       	push	r14
   118ba:	0f 93       	push	r16
   118bc:	1f 93       	push	r17
   118be:	df 93       	push	r29
   118c0:	cf 93       	push	r28
   118c2:	cd b7       	in	r28, 0x3d	; 61
   118c4:	de b7       	in	r29, 0x3e	; 62
   118c6:	c6 54       	subi	r28, 0x46	; 70
   118c8:	d0 40       	sbci	r29, 0x00	; 0
   118ca:	0f b6       	in	r0, 0x3f	; 63
   118cc:	f8 94       	cli
   118ce:	de bf       	out	0x3e, r29	; 62
   118d0:	0f be       	out	0x3f, r0	; 63
   118d2:	cd bf       	out	0x3d, r28	; 61
	 char lcdteks[20];
	 char strHeaderFooter[50];
	 
	 Result=MENU_NONE;
     
	 switch (stSettingHeader){
   118d4:	80 91 1d 03 	lds	r24, 0x031D
   118d8:	84 30       	cpi	r24, 0x04	; 4
   118da:	09 f4       	brne	.+2      	; 0x118de <FMenuSettingHeader+0x26>
   118dc:	3f c1       	rjmp	.+638    	; 0x11b5c <FMenuSettingHeader+0x2a4>
   118de:	85 30       	cpi	r24, 0x05	; 5
   118e0:	40 f4       	brcc	.+16     	; 0x118f2 <FMenuSettingHeader+0x3a>
   118e2:	81 30       	cpi	r24, 0x01	; 1
   118e4:	79 f1       	breq	.+94     	; 0x11944 <FMenuSettingHeader+0x8c>
   118e6:	81 30       	cpi	r24, 0x01	; 1
   118e8:	88 f0       	brcs	.+34     	; 0x1190c <FMenuSettingHeader+0x54>
   118ea:	82 30       	cpi	r24, 0x02	; 2
   118ec:	09 f0       	breq	.+2      	; 0x118f0 <FMenuSettingHeader+0x38>
   118ee:	85 c1       	rjmp	.+778    	; 0x11bfa <FMenuSettingHeader+0x342>
   118f0:	76 c0       	rjmp	.+236    	; 0x119de <FMenuSettingHeader+0x126>
   118f2:	86 30       	cpi	r24, 0x06	; 6
   118f4:	09 f4       	brne	.+2      	; 0x118f8 <FMenuSettingHeader+0x40>
   118f6:	d7 c0       	rjmp	.+430    	; 0x11aa6 <FMenuSettingHeader+0x1ee>
   118f8:	86 30       	cpi	r24, 0x06	; 6
   118fa:	08 f4       	brcc	.+2      	; 0x118fe <FMenuSettingHeader+0x46>
   118fc:	bf c0       	rjmp	.+382    	; 0x11a7c <FMenuSettingHeader+0x1c4>
   118fe:	87 30       	cpi	r24, 0x07	; 7
   11900:	09 f4       	brne	.+2      	; 0x11904 <FMenuSettingHeader+0x4c>
   11902:	3d c1       	rjmp	.+634    	; 0x11b7e <FMenuSettingHeader+0x2c6>
   11904:	88 30       	cpi	r24, 0x08	; 8
   11906:	09 f0       	breq	.+2      	; 0x1190a <FMenuSettingHeader+0x52>
   11908:	78 c1       	rjmp	.+752    	; 0x11bfa <FMenuSettingHeader+0x342>
   1190a:	73 c1       	rjmp	.+742    	; 0x11bf2 <FMenuSettingHeader+0x33a>
	 case shInitHeader:
	      lcd_clear();
   1190c:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
		  lcd_printf(1,1,PSTR("1)Header1  4)Header4"));
   11910:	81 e0       	ldi	r24, 0x01	; 1
   11912:	61 e0       	ldi	r22, 0x01	; 1
   11914:	4f ea       	ldi	r20, 0xAF	; 175
   11916:	54 e1       	ldi	r21, 0x14	; 20
   11918:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		  lcd_printf(2,1,PSTR("2)Header2  5)Header5"));
   1191c:	82 e0       	ldi	r24, 0x02	; 2
   1191e:	61 e0       	ldi	r22, 0x01	; 1
   11920:	4a e9       	ldi	r20, 0x9A	; 154
   11922:	54 e1       	ldi	r21, 0x14	; 20
   11924:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		  lcd_printf(3,1,PSTR("3)Header3  6)Header6"));
   11928:	83 e0       	ldi	r24, 0x03	; 3
   1192a:	61 e0       	ldi	r22, 0x01	; 1
   1192c:	45 e8       	ldi	r20, 0x85	; 133
   1192e:	54 e1       	ldi	r21, 0x14	; 20
   11930:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		  lcd_printf(4,1,PSTR("*)Exit              "));
   11934:	84 e0       	ldi	r24, 0x04	; 4
   11936:	61 e0       	ldi	r22, 0x01	; 1
   11938:	40 e7       	ldi	r20, 0x70	; 112
   1193a:	54 e1       	ldi	r21, 0x14	; 20
   1193c:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		  stSettingHeader=shHeaderSelect;
   11940:	81 e0       	ldi	r24, 0x01	; 1
   11942:	16 c1       	rjmp	.+556    	; 0x11b70 <FMenuSettingHeader+0x2b8>
	      break;
     case shHeaderSelect:
	      KeyChar=_key_btn(_key_scan(1));
   11944:	81 e0       	ldi	r24, 0x01	; 1
   11946:	0e 94 ab ae 	call	0x15d56	; 0x15d56 <_key_scan>
   1194a:	0e 94 0c ae 	call	0x15c18	; 0x15c18 <_key_btn>
   1194e:	80 93 1b 03 	sts	0x031B, r24
		  if ((KeyChar>='1')&&(KeyChar<='6')){
   11952:	81 53       	subi	r24, 0x31	; 49
   11954:	86 30       	cpi	r24, 0x06	; 6
   11956:	e0 f5       	brcc	.+120    	; 0x119d0 <FMenuSettingHeader+0x118>
		       HeaderIdx=KeyChar-'1';//
   11958:	80 93 1c 03 	sts	0x031C, r24
			   lcd_clear();
   1195c:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
			   sprintf_P(lcdteks,PSTR("Edit Header%d "),HeaderIdx+1);
   11960:	00 d0       	rcall	.+0      	; 0x11962 <FMenuSettingHeader+0xaa>
   11962:	00 d0       	rcall	.+0      	; 0x11964 <FMenuSettingHeader+0xac>
   11964:	00 d0       	rcall	.+0      	; 0x11966 <FMenuSettingHeader+0xae>
   11966:	ed b7       	in	r30, 0x3d	; 61
   11968:	fe b7       	in	r31, 0x3e	; 62
   1196a:	31 96       	adiw	r30, 0x01	; 1
   1196c:	8e 01       	movw	r16, r28
   1196e:	0f 5f       	subi	r16, 0xFF	; 255
   11970:	1f 4f       	sbci	r17, 0xFF	; 255
   11972:	ad b7       	in	r26, 0x3d	; 61
   11974:	be b7       	in	r27, 0x3e	; 62
   11976:	12 96       	adiw	r26, 0x02	; 2
   11978:	1c 93       	st	X, r17
   1197a:	0e 93       	st	-X, r16
   1197c:	11 97       	sbiw	r26, 0x01	; 1
   1197e:	81 e6       	ldi	r24, 0x61	; 97
   11980:	94 e1       	ldi	r25, 0x14	; 20
   11982:	93 83       	std	Z+3, r25	; 0x03
   11984:	82 83       	std	Z+2, r24	; 0x02
   11986:	80 91 1c 03 	lds	r24, 0x031C
   1198a:	90 e0       	ldi	r25, 0x00	; 0
   1198c:	01 96       	adiw	r24, 0x01	; 1
   1198e:	95 83       	std	Z+5, r25	; 0x05
   11990:	84 83       	std	Z+4, r24	; 0x04
   11992:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
			   lcd_print(1,1,lcdteks);
   11996:	8d b7       	in	r24, 0x3d	; 61
   11998:	9e b7       	in	r25, 0x3e	; 62
   1199a:	06 96       	adiw	r24, 0x06	; 6
   1199c:	0f b6       	in	r0, 0x3f	; 63
   1199e:	f8 94       	cli
   119a0:	9e bf       	out	0x3e, r25	; 62
   119a2:	0f be       	out	0x3f, r0	; 63
   119a4:	8d bf       	out	0x3d, r24	; 61
   119a6:	81 e0       	ldi	r24, 0x01	; 1
   119a8:	61 e0       	ldi	r22, 0x01	; 1
   119aa:	a8 01       	movw	r20, r16
   119ac:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
			   lcd_printf(4,1,PSTR("[*]Back  [#]OK"));
   119b0:	84 e0       	ldi	r24, 0x04	; 4
   119b2:	61 e0       	ldi	r22, 0x01	; 1
   119b4:	42 e5       	ldi	r20, 0x52	; 82
   119b6:	54 e1       	ldi	r21, 0x14	; 20
   119b8:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
   119bc:	ef ec       	ldi	r30, 0xCF	; 207
   119be:	f5 e0       	ldi	r31, 0x05	; 5
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
   119c0:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   119c2:	97 e0       	ldi	r25, 0x07	; 7
   119c4:	e0 36       	cpi	r30, 0x60	; 96
   119c6:	f9 07       	cpc	r31, r25
   119c8:	d9 f7       	brne	.-10     	; 0x119c0 <FMenuSettingHeader+0x108>
			   lcd_clear();
			   sprintf_P(lcdteks,PSTR("Edit Header%d "),HeaderIdx+1);
			   lcd_print(1,1,lcdteks);
			   lcd_printf(4,1,PSTR("[*]Back  [#]OK"));
			   FillChar(PrintBuffer,sizeof(PrintBuffer),0);
			   stSettingHeader=shEditHeader1;
   119ca:	82 e0       	ldi	r24, 0x02	; 2
   119cc:	80 93 1d 03 	sts	0x031D, r24
		  }
		  if(KeyChar=='*')stSettingHeader=shExitSettingHeader;
   119d0:	80 91 1b 03 	lds	r24, 0x031B
   119d4:	8a 32       	cpi	r24, 0x2A	; 42
   119d6:	09 f0       	breq	.+2      	; 0x119da <FMenuSettingHeader+0x122>
   119d8:	10 c1       	rjmp	.+544    	; 0x11bfa <FMenuSettingHeader+0x342>
   119da:	88 e0       	ldi	r24, 0x08	; 8
   119dc:	c9 c0       	rjmp	.+402    	; 0x11b70 <FMenuSettingHeader+0x2b8>
	      break;
     case shEditHeader1:
          //uiResult=UserInput(UI_ALPHANUM_R,2,1,strFreeMessageLine1,0,20);
		  uiResult=UserInput(UI_ALPHANUM_R,2,1,PrintBuffer,0,40);
   119de:	83 e0       	ldi	r24, 0x03	; 3
   119e0:	62 e0       	ldi	r22, 0x02	; 2
   119e2:	41 e0       	ldi	r20, 0x01	; 1
   119e4:	2f ec       	ldi	r18, 0xCF	; 207
   119e6:	35 e0       	ldi	r19, 0x05	; 5
   119e8:	00 e0       	ldi	r16, 0x00	; 0
   119ea:	10 e0       	ldi	r17, 0x00	; 0
   119ec:	58 e2       	ldi	r21, 0x28	; 40
   119ee:	e5 2e       	mov	r14, r21
   119f0:	0e 94 f0 7b 	call	0xf7e0	; 0xf7e0 <UserInput>
		  if (uiResult==USER_OK){
   119f4:	83 30       	cpi	r24, 0x03	; 3
   119f6:	f1 f5       	brne	.+124    	; 0x11a74 <FMenuSettingHeader+0x1bc>
			  lcd_clear();
   119f8:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
			  AddSpaceLag(PrintBuffer,40);
   119fc:	8f ec       	ldi	r24, 0xCF	; 207
   119fe:	95 e0       	ldi	r25, 0x05	; 5
   11a00:	68 e2       	ldi	r22, 0x28	; 40
   11a02:	0e 94 d8 2a 	call	0x55b0	; 0x55b0 <AddSpaceLag>
   11a06:	20 e0       	ldi	r18, 0x00	; 0
   11a08:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   11a0a:	f9 01       	movw	r30, r18
   11a0c:	e9 56       	subi	r30, 0x69	; 105
   11a0e:	f5 4f       	sbci	r31, 0xF5	; 245
   11a10:	d9 01       	movw	r26, r18
   11a12:	a1 53       	subi	r26, 0x31	; 49
   11a14:	ba 4f       	sbci	r27, 0xFA	; 250
   11a16:	8c 91       	ld	r24, X
   11a18:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   11a1a:	2f 5f       	subi	r18, 0xFF	; 255
   11a1c:	3f 4f       	sbci	r19, 0xFF	; 255
   11a1e:	24 31       	cpi	r18, 0x14	; 20
   11a20:	31 05       	cpc	r19, r1
   11a22:	99 f7       	brne	.-26     	; 0x11a0a <FMenuSettingHeader+0x152>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   11a24:	10 92 ab 0a 	sts	0x0AAB, r1
   11a28:	e3 ee       	ldi	r30, 0xE3	; 227
   11a2a:	f5 e0       	ldi	r31, 0x05	; 5
   11a2c:	a6 e8       	ldi	r26, 0x86	; 134
   11a2e:	b9 e0       	ldi	r27, 0x09	; 9
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   11a30:	81 91       	ld	r24, Z+
   11a32:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   11a34:	85 e0       	ldi	r24, 0x05	; 5
   11a36:	e7 3f       	cpi	r30, 0xF7	; 247
   11a38:	f8 07       	cpc	r31, r24
   11a3a:	d1 f7       	brne	.-12     	; 0x11a30 <FMenuSettingHeader+0x178>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   11a3c:	10 92 9a 09 	sts	0x099A, r1
			  lcd_clear();
			  AddSpaceLag(PrintBuffer,40);
			  StrPosCopy(PrintBuffer,strFreeMessageLine1,0,20);
			  StrPosCopy(PrintBuffer,strFreeMessageLine2,20,20);

			  lcd_print(1,1,strFreeMessageLine1);			  
   11a40:	81 e0       	ldi	r24, 0x01	; 1
   11a42:	61 e0       	ldi	r22, 0x01	; 1
   11a44:	47 e9       	ldi	r20, 0x97	; 151
   11a46:	5a e0       	ldi	r21, 0x0A	; 10
   11a48:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
			  lcd_print(2,1,strFreeMessageLine2);			  
   11a4c:	82 e0       	ldi	r24, 0x02	; 2
   11a4e:	61 e0       	ldi	r22, 0x01	; 1
   11a50:	46 e8       	ldi	r20, 0x86	; 134
   11a52:	59 e0       	ldi	r21, 0x09	; 9
   11a54:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
			  
			  lcd_printf(3,1,PSTR("Align Center?"));
   11a58:	83 e0       	ldi	r24, 0x03	; 3
   11a5a:	61 e0       	ldi	r22, 0x01	; 1
   11a5c:	44 e4       	ldi	r20, 0x44	; 68
   11a5e:	54 e1       	ldi	r21, 0x14	; 20
   11a60:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
			  lcd_printf(4,1,PSTR("[*]No  [#]Yes"));
   11a64:	84 e0       	ldi	r24, 0x04	; 4
   11a66:	61 e0       	ldi	r22, 0x01	; 1
   11a68:	46 e3       	ldi	r20, 0x36	; 54
   11a6a:	54 e1       	ldi	r21, 0x14	; 20
   11a6c:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		      stSettingHeader=shIsAlignCenter;
   11a70:	85 e0       	ldi	r24, 0x05	; 5
   11a72:	7e c0       	rjmp	.+252    	; 0x11b70 <FMenuSettingHeader+0x2b8>
		  }
		  else
		  if (uiResult==USER_CANCEL)stSettingHeader=shInitHeader;
   11a74:	81 30       	cpi	r24, 0x01	; 1
   11a76:	09 f0       	breq	.+2      	; 0x11a7a <FMenuSettingHeader+0x1c2>
   11a78:	c0 c0       	rjmp	.+384    	; 0x11bfa <FMenuSettingHeader+0x342>
   11a7a:	b8 c0       	rjmp	.+368    	; 0x11bec <FMenuSettingHeader+0x334>
	      break;
     case shIsAlignCenter:
	      KeyChar=_key_btn(_key_scan(1));
   11a7c:	81 e0       	ldi	r24, 0x01	; 1
   11a7e:	0e 94 ab ae 	call	0x15d56	; 0x15d56 <_key_scan>
   11a82:	0e 94 0c ae 	call	0x15c18	; 0x15c18 <_key_btn>
   11a86:	80 93 1b 03 	sts	0x031B, r24
          if(KeyChar=='#'){
   11a8a:	83 32       	cpi	r24, 0x23	; 35
   11a8c:	39 f4       	brne	.+14     	; 0x11a9c <FMenuSettingHeader+0x1e4>
		      //AlignCenter			  
			  StrAlignCenter(PrintBuffer,40);
   11a8e:	8f ec       	ldi	r24, 0xCF	; 207
   11a90:	95 e0       	ldi	r25, 0x05	; 5
   11a92:	68 e2       	ldi	r22, 0x28	; 40
   11a94:	70 e0       	ldi	r23, 0x00	; 0
   11a96:	0e 94 e2 2c 	call	0x59c4	; 0x59c4 <StrAlignCenter>
   11a9a:	03 c0       	rjmp	.+6      	; 0x11aa2 <FMenuSettingHeader+0x1ea>
			  stSettingHeader=shIsSaveHeader;
		  } else if(KeyChar=='*')stSettingHeader=shIsSaveHeader;		 
   11a9c:	8a 32       	cpi	r24, 0x2A	; 42
   11a9e:	09 f0       	breq	.+2      	; 0x11aa2 <FMenuSettingHeader+0x1ea>
   11aa0:	ac c0       	rjmp	.+344    	; 0x11bfa <FMenuSettingHeader+0x342>
   11aa2:	86 e0       	ldi	r24, 0x06	; 6
   11aa4:	65 c0       	rjmp	.+202    	; 0x11b70 <FMenuSettingHeader+0x2b8>
	      break;
     case shIsSaveHeader:
	      lcd_clear(); 
   11aa6:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
   11aaa:	20 e0       	ldi	r18, 0x00	; 0
   11aac:	30 e0       	ldi	r19, 0x00	; 0
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   11aae:	f9 01       	movw	r30, r18
   11ab0:	e9 56       	subi	r30, 0x69	; 105
   11ab2:	f5 4f       	sbci	r31, 0xF5	; 245
   11ab4:	d9 01       	movw	r26, r18
   11ab6:	a1 53       	subi	r26, 0x31	; 49
   11ab8:	ba 4f       	sbci	r27, 0xFA	; 250
   11aba:	8c 91       	ld	r24, X
   11abc:	80 83       	st	Z, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   11abe:	2f 5f       	subi	r18, 0xFF	; 255
   11ac0:	3f 4f       	sbci	r19, 0xFF	; 255
   11ac2:	24 31       	cpi	r18, 0x14	; 20
   11ac4:	31 05       	cpc	r19, r1
   11ac6:	99 f7       	brne	.-26     	; 0x11aae <FMenuSettingHeader+0x1f6>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   11ac8:	10 92 ab 0a 	sts	0x0AAB, r1
   11acc:	e3 ee       	ldi	r30, 0xE3	; 227
   11ace:	f5 e0       	ldi	r31, 0x05	; 5
   11ad0:	a6 e8       	ldi	r26, 0x86	; 134
   11ad2:	b9 e0       	ldi	r27, 0x09	; 9
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   11ad4:	81 91       	ld	r24, Z+
   11ad6:	8d 93       	st	X+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   11ad8:	95 e0       	ldi	r25, 0x05	; 5
   11ada:	e7 3f       	cpi	r30, 0xF7	; 247
   11adc:	f9 07       	cpc	r31, r25
   11ade:	d1 f7       	brne	.-12     	; 0x11ad4 <FMenuSettingHeader+0x21c>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   11ae0:	10 92 9a 09 	sts	0x099A, r1
	      break;
     case shIsSaveHeader:
	      lcd_clear(); 
		  StrPosCopy(PrintBuffer,strFreeMessageLine1,0,20);
		  StrPosCopy(PrintBuffer,strFreeMessageLine2,20,20);
          lcd_print(1,1,strFreeMessageLine1);
   11ae4:	81 e0       	ldi	r24, 0x01	; 1
   11ae6:	61 e0       	ldi	r22, 0x01	; 1
   11ae8:	47 e9       	ldi	r20, 0x97	; 151
   11aea:	5a e0       	ldi	r21, 0x0A	; 10
   11aec:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
		  lcd_print(2,1,strFreeMessageLine2);
   11af0:	82 e0       	ldi	r24, 0x02	; 2
   11af2:	61 e0       	ldi	r22, 0x01	; 1
   11af4:	46 e8       	ldi	r20, 0x86	; 134
   11af6:	59 e0       	ldi	r21, 0x09	; 9
   11af8:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
		  sprintf_P(lcdteks,PSTR("Save Header%d ?"),HeaderIdx+1);
   11afc:	00 d0       	rcall	.+0      	; 0x11afe <FMenuSettingHeader+0x246>
   11afe:	00 d0       	rcall	.+0      	; 0x11b00 <FMenuSettingHeader+0x248>
   11b00:	00 d0       	rcall	.+0      	; 0x11b02 <FMenuSettingHeader+0x24a>
   11b02:	ed b7       	in	r30, 0x3d	; 61
   11b04:	fe b7       	in	r31, 0x3e	; 62
   11b06:	31 96       	adiw	r30, 0x01	; 1
   11b08:	8e 01       	movw	r16, r28
   11b0a:	0f 5f       	subi	r16, 0xFF	; 255
   11b0c:	1f 4f       	sbci	r17, 0xFF	; 255
   11b0e:	ad b7       	in	r26, 0x3d	; 61
   11b10:	be b7       	in	r27, 0x3e	; 62
   11b12:	12 96       	adiw	r26, 0x02	; 2
   11b14:	1c 93       	st	X, r17
   11b16:	0e 93       	st	-X, r16
   11b18:	11 97       	sbiw	r26, 0x01	; 1
   11b1a:	86 e2       	ldi	r24, 0x26	; 38
   11b1c:	94 e1       	ldi	r25, 0x14	; 20
   11b1e:	93 83       	std	Z+3, r25	; 0x03
   11b20:	82 83       	std	Z+2, r24	; 0x02
   11b22:	80 91 1c 03 	lds	r24, 0x031C
   11b26:	90 e0       	ldi	r25, 0x00	; 0
   11b28:	01 96       	adiw	r24, 0x01	; 1
   11b2a:	95 83       	std	Z+5, r25	; 0x05
   11b2c:	84 83       	std	Z+4, r24	; 0x04
   11b2e:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
		  lcd_print(3,1,lcdteks);
   11b32:	8d b7       	in	r24, 0x3d	; 61
   11b34:	9e b7       	in	r25, 0x3e	; 62
   11b36:	06 96       	adiw	r24, 0x06	; 6
   11b38:	0f b6       	in	r0, 0x3f	; 63
   11b3a:	f8 94       	cli
   11b3c:	9e bf       	out	0x3e, r25	; 62
   11b3e:	0f be       	out	0x3f, r0	; 63
   11b40:	8d bf       	out	0x3d, r24	; 61
   11b42:	83 e0       	ldi	r24, 0x03	; 3
   11b44:	61 e0       	ldi	r22, 0x01	; 1
   11b46:	a8 01       	movw	r20, r16
   11b48:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
		  lcd_printf(4,1,PSTR("[*]No [#]Yes"));		      
   11b4c:	84 e0       	ldi	r24, 0x04	; 4
   11b4e:	61 e0       	ldi	r22, 0x01	; 1
   11b50:	49 e1       	ldi	r20, 0x19	; 25
   11b52:	54 e1       	ldi	r21, 0x14	; 20
   11b54:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
	      stSettingHeader=shSaveHeaderQuestions;      
   11b58:	84 e0       	ldi	r24, 0x04	; 4
   11b5a:	0a c0       	rjmp	.+20     	; 0x11b70 <FMenuSettingHeader+0x2b8>
	      break;    
     case shSaveHeaderQuestions:
	      KeyChar=_key_btn(_key_scan(1));
   11b5c:	81 e0       	ldi	r24, 0x01	; 1
   11b5e:	0e 94 ab ae 	call	0x15d56	; 0x15d56 <_key_scan>
   11b62:	0e 94 0c ae 	call	0x15c18	; 0x15c18 <_key_btn>
   11b66:	80 93 1b 03 	sts	0x031B, r24
	      if(KeyChar=='#')stSettingHeader=shSaveHeader;
   11b6a:	83 32       	cpi	r24, 0x23	; 35
   11b6c:	21 f4       	brne	.+8      	; 0x11b76 <FMenuSettingHeader+0x2be>
   11b6e:	87 e0       	ldi	r24, 0x07	; 7
   11b70:	80 93 1d 03 	sts	0x031D, r24
   11b74:	42 c0       	rjmp	.+132    	; 0x11bfa <FMenuSettingHeader+0x342>
		  else
          if(KeyChar=='*')stSettingHeader=shInitHeader;
   11b76:	8a 32       	cpi	r24, 0x2A	; 42
   11b78:	09 f0       	breq	.+2      	; 0x11b7c <FMenuSettingHeader+0x2c4>
   11b7a:	3f c0       	rjmp	.+126    	; 0x11bfa <FMenuSettingHeader+0x342>
   11b7c:	37 c0       	rjmp	.+110    	; 0x11bec <FMenuSettingHeader+0x334>
	      break;
     case shSaveHeader:
	      sprintf_P(strHeaderFooter,PSTR("%s%s"),strFreeMessageLine1,strFreeMessageLine2);
   11b7e:	ad b7       	in	r26, 0x3d	; 61
   11b80:	be b7       	in	r27, 0x3e	; 62
   11b82:	18 97       	sbiw	r26, 0x08	; 8
   11b84:	0f b6       	in	r0, 0x3f	; 63
   11b86:	f8 94       	cli
   11b88:	be bf       	out	0x3e, r27	; 62
   11b8a:	0f be       	out	0x3f, r0	; 63
   11b8c:	ad bf       	out	0x3d, r26	; 61
   11b8e:	ed b7       	in	r30, 0x3d	; 61
   11b90:	fe b7       	in	r31, 0x3e	; 62
   11b92:	31 96       	adiw	r30, 0x01	; 1
   11b94:	8e 01       	movw	r16, r28
   11b96:	0b 5e       	subi	r16, 0xEB	; 235
   11b98:	1f 4f       	sbci	r17, 0xFF	; 255
   11b9a:	12 96       	adiw	r26, 0x02	; 2
   11b9c:	1c 93       	st	X, r17
   11b9e:	0e 93       	st	-X, r16
   11ba0:	11 97       	sbiw	r26, 0x01	; 1
   11ba2:	84 e1       	ldi	r24, 0x14	; 20
   11ba4:	94 e1       	ldi	r25, 0x14	; 20
   11ba6:	93 83       	std	Z+3, r25	; 0x03
   11ba8:	82 83       	std	Z+2, r24	; 0x02
   11baa:	87 e9       	ldi	r24, 0x97	; 151
   11bac:	9a e0       	ldi	r25, 0x0A	; 10
   11bae:	95 83       	std	Z+5, r25	; 0x05
   11bb0:	84 83       	std	Z+4, r24	; 0x04
   11bb2:	86 e8       	ldi	r24, 0x86	; 134
   11bb4:	99 e0       	ldi	r25, 0x09	; 9
   11bb6:	97 83       	std	Z+7, r25	; 0x07
   11bb8:	86 83       	std	Z+6, r24	; 0x06
   11bba:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
   11bbe:	8d b7       	in	r24, 0x3d	; 61
   11bc0:	9e b7       	in	r25, 0x3e	; 62
   11bc2:	08 96       	adiw	r24, 0x08	; 8
   11bc4:	0f b6       	in	r0, 0x3f	; 63
   11bc6:	f8 94       	cli
   11bc8:	9e bf       	out	0x3e, r25	; 62
   11bca:	0f be       	out	0x3f, r0	; 63
   11bcc:	8d bf       	out	0x3d, r24	; 61
   11bce:	80 91 1c 03 	lds	r24, 0x031C
   11bd2:	29 e2       	ldi	r18, 0x29	; 41
   11bd4:	82 9f       	mul	r24, r18
   11bd6:	c0 01       	movw	r24, r0
   11bd8:	11 24       	eor	r1, r1
   11bda:	89 5d       	subi	r24, 0xD9	; 217
   11bdc:	9d 4f       	sbci	r25, 0xFD	; 253
   11bde:	b8 01       	movw	r22, r16
   11be0:	48 e2       	ldi	r20, 0x28	; 40
   11be2:	50 e0       	ldi	r21, 0x00	; 0
   11be4:	2b ef       	ldi	r18, 0xFB	; 251
   11be6:	32 e1       	ldi	r19, 0x12	; 18
   11be8:	0e 94 3b b4 	call	0x16876	; 0x16876 <__eewr_block>
	      eeprom_write_block((const void*) &strHeaderFooter, (void*) &DefHeaderFooter[HeaderIdx],40);
		  //eeprom_write_block((const void*) &PrintBuffer, (void*) &DefHeaderFooter[HeaderIdx],40);
          stSettingHeader=shInitHeader;
   11bec:	10 92 1d 03 	sts	0x031D, r1
   11bf0:	04 c0       	rjmp	.+8      	; 0x11bfa <FMenuSettingHeader+0x342>
	      break;
     case shExitSettingHeader:
          stSettingHeader=shInitHeader;
   11bf2:	10 92 1d 03 	sts	0x031D, r1
   11bf6:	81 e0       	ldi	r24, 0x01	; 1
   11bf8:	01 c0       	rjmp	.+2      	; 0x11bfc <FMenuSettingHeader+0x344>
   11bfa:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;	 
	 }
   //_menu_header();   
   return Result;
}
   11bfc:	ca 5b       	subi	r28, 0xBA	; 186
   11bfe:	df 4f       	sbci	r29, 0xFF	; 255
   11c00:	0f b6       	in	r0, 0x3f	; 63
   11c02:	f8 94       	cli
   11c04:	de bf       	out	0x3e, r29	; 62
   11c06:	0f be       	out	0x3f, r0	; 63
   11c08:	cd bf       	out	0x3d, r28	; 61
   11c0a:	cf 91       	pop	r28
   11c0c:	df 91       	pop	r29
   11c0e:	1f 91       	pop	r17
   11c10:	0f 91       	pop	r16
   11c12:	ef 90       	pop	r14
   11c14:	08 95       	ret

00011c16 <FMenuAdminSettings>:

char FMenuAdminSettings(){
     static char stAdminSettings=asInitMenu;
	 char SubMenu,Result,KeyChar;
	 Result=MENU_NONE;
	 switch(stAdminSettings){
   11c16:	80 91 1e 03 	lds	r24, 0x031E
   11c1a:	83 30       	cpi	r24, 0x03	; 3
   11c1c:	09 f4       	brne	.+2      	; 0x11c20 <FMenuAdminSettings+0xa>
   11c1e:	6e c0       	rjmp	.+220    	; 0x11cfc <FMenuAdminSettings+0xe6>
   11c20:	84 30       	cpi	r24, 0x04	; 4
   11c22:	30 f4       	brcc	.+12     	; 0x11c30 <FMenuAdminSettings+0x1a>
   11c24:	81 30       	cpi	r24, 0x01	; 1
   11c26:	e9 f1       	breq	.+122    	; 0x11ca2 <FMenuAdminSettings+0x8c>
   11c28:	82 30       	cpi	r24, 0x02	; 2
   11c2a:	08 f0       	brcs	.+2      	; 0x11c2e <FMenuAdminSettings+0x18>
   11c2c:	64 c0       	rjmp	.+200    	; 0x11cf6 <FMenuAdminSettings+0xe0>
   11c2e:	0d c0       	rjmp	.+26     	; 0x11c4a <FMenuAdminSettings+0x34>
   11c30:	85 30       	cpi	r24, 0x05	; 5
   11c32:	09 f4       	brne	.+2      	; 0x11c36 <FMenuAdminSettings+0x20>
   11c34:	66 c0       	rjmp	.+204    	; 0x11d02 <FMenuAdminSettings+0xec>
   11c36:	85 30       	cpi	r24, 0x05	; 5
   11c38:	08 f4       	brcc	.+2      	; 0x11c3c <FMenuAdminSettings+0x26>
   11c3a:	6a c0       	rjmp	.+212    	; 0x11d10 <FMenuAdminSettings+0xfa>
   11c3c:	86 30       	cpi	r24, 0x06	; 6
   11c3e:	09 f4       	brne	.+2      	; 0x11c42 <FMenuAdminSettings+0x2c>
   11c40:	63 c0       	rjmp	.+198    	; 0x11d08 <FMenuAdminSettings+0xf2>
   11c42:	87 30       	cpi	r24, 0x07	; 7
   11c44:	09 f0       	breq	.+2      	; 0x11c48 <FMenuAdminSettings+0x32>
   11c46:	6c c0       	rjmp	.+216    	; 0x11d20 <FMenuAdminSettings+0x10a>
   11c48:	67 c0       	rjmp	.+206    	; 0x11d18 <FMenuAdminSettings+0x102>
	 case asInitMenu:
          lcd_clear();
   11c4a:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
		  if (IFType==IT_SLAVE){
   11c4e:	80 91 10 01 	lds	r24, 0x0110
   11c52:	81 30       	cpi	r24, 0x01	; 1
   11c54:	51 f4       	brne	.+20     	; 0x11c6a <FMenuAdminSettings+0x54>
		      lcd_printf(1,1, PSTR("1)Header    4)Client"));
   11c56:	61 e0       	ldi	r22, 0x01	; 1
   11c58:	4f e1       	ldi	r20, 0x1F	; 31
   11c5a:	55 e1       	ldi	r21, 0x15	; 21
   11c5c:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		      lcd_printf(2,1, PSTR("2)Footer    5)Server"));
   11c60:	82 e0       	ldi	r24, 0x02	; 2
   11c62:	61 e0       	ldi	r22, 0x01	; 1
   11c64:	4a e0       	ldi	r20, 0x0A	; 10
   11c66:	55 e1       	ldi	r21, 0x15	; 21
   11c68:	0c c0       	rjmp	.+24     	; 0x11c82 <FMenuAdminSettings+0x6c>
		  }else
		  if (IFType==IT_STANDALONE){
   11c6a:	82 30       	cpi	r24, 0x02	; 2
   11c6c:	61 f4       	brne	.+24     	; 0x11c86 <FMenuAdminSettings+0x70>
		      lcd_printf(1,1, PSTR("1)Header            "));
   11c6e:	81 e0       	ldi	r24, 0x01	; 1
   11c70:	61 e0       	ldi	r22, 0x01	; 1
   11c72:	45 ef       	ldi	r20, 0xF5	; 245
   11c74:	54 e1       	ldi	r21, 0x14	; 20
   11c76:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		      lcd_printf(2,1, PSTR("2)Footer            "));
   11c7a:	82 e0       	ldi	r24, 0x02	; 2
   11c7c:	61 e0       	ldi	r22, 0x01	; 1
   11c7e:	40 ee       	ldi	r20, 0xE0	; 224
   11c80:	54 e1       	ldi	r21, 0x14	; 20
   11c82:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		  }
		  lcd_printf(3,1, PSTR("3)Password          "));
   11c86:	83 e0       	ldi	r24, 0x03	; 3
   11c88:	61 e0       	ldi	r22, 0x01	; 1
   11c8a:	4b ec       	ldi	r20, 0xCB	; 203
   11c8c:	54 e1       	ldi	r21, 0x14	; 20
   11c8e:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		  lcd_printf(4,1, PSTR("*)Exit"));
   11c92:	84 e0       	ldi	r24, 0x04	; 4
   11c94:	61 e0       	ldi	r22, 0x01	; 1
   11c96:	44 ec       	ldi	r20, 0xC4	; 196
   11c98:	54 e1       	ldi	r21, 0x14	; 20
   11c9a:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		  stAdminSettings=asAdminSettingsOption;
   11c9e:	81 e0       	ldi	r24, 0x01	; 1
   11ca0:	27 c0       	rjmp	.+78     	; 0x11cf0 <FMenuAdminSettings+0xda>
		  break;
     case asAdminSettingsOption:
	      KeyChar=_key_btn(_key_scan(1));
   11ca2:	81 e0       	ldi	r24, 0x01	; 1
   11ca4:	0e 94 ab ae 	call	0x15d56	; 0x15d56 <_key_scan>
   11ca8:	0e 94 0c ae 	call	0x15c18	; 0x15c18 <_key_btn>
   11cac:	98 2f       	mov	r25, r24
		  switch(KeyChar){
   11cae:	82 33       	cpi	r24, 0x32	; 50
   11cb0:	61 f0       	breq	.+24     	; 0x11cca <FMenuAdminSettings+0xb4>
   11cb2:	83 33       	cpi	r24, 0x33	; 51
   11cb4:	28 f4       	brcc	.+10     	; 0x11cc0 <FMenuAdminSettings+0xaa>
   11cb6:	8a 32       	cpi	r24, 0x2A	; 42
   11cb8:	61 f0       	breq	.+24     	; 0x11cd2 <FMenuAdminSettings+0xbc>
   11cba:	81 33       	cpi	r24, 0x31	; 49
   11cbc:	69 f4       	brne	.+26     	; 0x11cd8 <FMenuAdminSettings+0xc2>
   11cbe:	03 c0       	rjmp	.+6      	; 0x11cc6 <FMenuAdminSettings+0xb0>
   11cc0:	83 33       	cpi	r24, 0x33	; 51
   11cc2:	51 f4       	brne	.+20     	; 0x11cd8 <FMenuAdminSettings+0xc2>
   11cc4:	04 c0       	rjmp	.+8      	; 0x11cce <FMenuAdminSettings+0xb8>
		  case '1':stAdminSettings=asAdminSettingHeader;
   11cc6:	82 e0       	ldi	r24, 0x02	; 2
   11cc8:	05 c0       	rjmp	.+10     	; 0x11cd4 <FMenuAdminSettings+0xbe>
		       break;
		  case '2':stAdminSettings=asAdminSettingFooter;
   11cca:	83 e0       	ldi	r24, 0x03	; 3
   11ccc:	03 c0       	rjmp	.+6      	; 0x11cd4 <FMenuAdminSettings+0xbe>
		       break;
		  case '3':stAdminSettings=asAdminSettingPassword;
   11cce:	84 e0       	ldi	r24, 0x04	; 4
   11cd0:	01 c0       	rjmp	.+2      	; 0x11cd4 <FMenuAdminSettings+0xbe>
		       break;
		  case '*':stAdminSettings=asExitAdminSetting;
   11cd2:	87 e0       	ldi	r24, 0x07	; 7
   11cd4:	80 93 1e 03 	sts	0x031E, r24
		       break;			   
		  }
		  if (IFType==IT_SLAVE){
   11cd8:	80 91 10 01 	lds	r24, 0x0110
   11cdc:	81 30       	cpi	r24, 0x01	; 1
   11cde:	01 f5       	brne	.+64     	; 0x11d20 <FMenuAdminSettings+0x10a>
			  switch(KeyChar){
   11ce0:	94 33       	cpi	r25, 0x34	; 52
   11ce2:	19 f0       	breq	.+6      	; 0x11cea <FMenuAdminSettings+0xd4>
   11ce4:	95 33       	cpi	r25, 0x35	; 53
   11ce6:	e1 f4       	brne	.+56     	; 0x11d20 <FMenuAdminSettings+0x10a>
   11ce8:	02 c0       	rjmp	.+4      	; 0x11cee <FMenuAdminSettings+0xd8>
			  case '4':stAdminSettings=asAdminSettingClientIP;
   11cea:	85 e0       	ldi	r24, 0x05	; 5
   11cec:	01 c0       	rjmp	.+2      	; 0x11cf0 <FMenuAdminSettings+0xda>
				   break;
			  case '5':stAdminSettings=asAdminSettingServerIP;
   11cee:	86 e0       	ldi	r24, 0x06	; 6
   11cf0:	80 93 1e 03 	sts	0x031E, r24
   11cf4:	0f c0       	rjmp	.+30     	; 0x11d14 <FMenuAdminSettings+0xfe>
				   break;
			  }
		  }
	      break;
	 case asAdminSettingHeader:
	      SubMenu=FMenuSettingHeader();
   11cf6:	0e 94 5c 8c 	call	0x118b8	; 0x118b8 <FMenuSettingHeader>
   11cfa:	08 c0       	rjmp	.+16     	; 0x11d0c <FMenuAdminSettings+0xf6>
	      if (SubMenu==MENU_DONE)stAdminSettings=asInitMenu;
	      break;
	 case asAdminSettingFooter:
	      SubMenu=FMenuSettingFooter();
   11cfc:	0e 94 ad 8a 	call	0x1155a	; 0x1155a <FMenuSettingFooter>
   11d00:	05 c0       	rjmp	.+10     	; 0x11d0c <FMenuAdminSettings+0xf6>
	 case asAdminSettingPassword:
	      SubMenu=FMenuSettingPassword();
	      if (SubMenu==MENU_DONE)stAdminSettings=asInitMenu;	 
	      break;
     case asAdminSettingClientIP:
	      SubMenu=FMenuSettingClientIP();
   11d02:	0e 94 67 6b 	call	0xd6ce	; 0xd6ce <FMenuSettingClientIP>
   11d06:	02 c0       	rjmp	.+4      	; 0x11d0c <FMenuAdminSettings+0xf6>
	      if (SubMenu==MENU_DONE)stAdminSettings=asInitMenu;	 
	      break;
	 case asAdminSettingServerIP:
	      SubMenu=FMenuSettingServerIP();
   11d08:	0e 94 dd 68 	call	0xd1ba	; 0xd1ba <FMenuSettingServerIP>
	      if (SubMenu==MENU_DONE)stAdminSettings=asInitMenu;	 
   11d0c:	81 30       	cpi	r24, 0x01	; 1
   11d0e:	41 f4       	brne	.+16     	; 0x11d20 <FMenuAdminSettings+0x10a>
   11d10:	10 92 1e 03 	sts	0x031E, r1
   11d14:	80 e0       	ldi	r24, 0x00	; 0
   11d16:	08 95       	ret
	      break;
     case asExitAdminSetting:
	      stAdminSettings=asInitMenu;
   11d18:	10 92 1e 03 	sts	0x031E, r1
   11d1c:	81 e0       	ldi	r24, 0x01	; 1
   11d1e:	08 95       	ret
   11d20:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
   return Result;
}
   11d22:	08 95       	ret

00011d24 <FMenuMaster>:
     else Result=RC_INVALID;

   return Result;
}

char FMenuMaster(){ 
   11d24:	ef 92       	push	r14
   11d26:	ff 92       	push	r15
   11d28:	0f 93       	push	r16
   11d2a:	1f 93       	push	r17
   11d2c:	df 93       	push	r29
   11d2e:	cf 93       	push	r28
   11d30:	cd b7       	in	r28, 0x3d	; 61
   11d32:	de b7       	in	r29, 0x3e	; 62
   11d34:	e2 97       	sbiw	r28, 0x32	; 50
   11d36:	0f b6       	in	r0, 0x3f	; 63
   11d38:	f8 94       	cli
   11d3a:	de bf       	out	0x3e, r29	; 62
   11d3c:	0f be       	out	0x3f, r0	; 63
   11d3e:	cd bf       	out	0x3d, r28	; 61
static char stMenuMaster=mmInitMaster;
     char KeyPressed,KeyChar,Result=MENU_NONE;
	 char uiResult,lcdteks[20],PTime[10],PDate[10],strNewPassword[10];
	 char strSend[20];

	 switch(stMenuMaster){
   11d40:	80 91 23 03 	lds	r24, 0x0323
   11d44:	e8 2f       	mov	r30, r24
   11d46:	f0 e0       	ldi	r31, 0x00	; 0
   11d48:	e1 31       	cpi	r30, 0x11	; 17
   11d4a:	f1 05       	cpc	r31, r1
   11d4c:	08 f0       	brcs	.+2      	; 0x11d50 <FMenuMaster+0x2c>
   11d4e:	f3 c1       	rjmp	.+998    	; 0x12136 <FMenuMaster+0x412>
   11d50:	ed 54       	subi	r30, 0x4D	; 77
   11d52:	ff 4f       	sbci	r31, 0xFF	; 255
   11d54:	ee 0f       	add	r30, r30
   11d56:	ff 1f       	adc	r31, r31
   11d58:	05 90       	lpm	r0, Z+
   11d5a:	f4 91       	lpm	r31, Z+
   11d5c:	e0 2d       	mov	r30, r0
   11d5e:	09 94       	ijmp
	 case mmInitMaster:
	      lcd_clear();
   11d60:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
		  lcd_printf(1,1,PSTR("-System Admin Level-"));
   11d64:	81 e0       	ldi	r24, 0x01	; 1
   11d66:	61 e0       	ldi	r22, 0x01	; 1
   11d68:	45 e9       	ldi	r20, 0x95	; 149
   11d6a:	57 e1       	ldi	r21, 0x17	; 23
   11d6c:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		  lcd_printf(2,1,PSTR("1.Restore Password  "));
   11d70:	82 e0       	ldi	r24, 0x02	; 2
   11d72:	61 e0       	ldi	r22, 0x01	; 1
   11d74:	40 e8       	ldi	r20, 0x80	; 128
   11d76:	57 e1       	ldi	r21, 0x17	; 23
   11d78:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		  lcd_printf(3,1,PSTR("2.Change Password   "));
   11d7c:	83 e0       	ldi	r24, 0x03	; 3
   11d7e:	61 e0       	ldi	r22, 0x01	; 1
   11d80:	4b e6       	ldi	r20, 0x6B	; 107
   11d82:	57 e1       	ldi	r21, 0x17	; 23
   11d84:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		  lcd_printf(4,1,PSTR("[*]Exit             "));
   11d88:	84 e0       	ldi	r24, 0x04	; 4
   11d8a:	61 e0       	ldi	r22, 0x01	; 1
   11d8c:	46 e5       	ldi	r20, 0x56	; 86
   11d8e:	57 e1       	ldi	r21, 0x17	; 23
   11d90:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>

		  //_uart_printf(1,1,PSTR("-System Admin Level-"));

		  stMenuMaster=mmMasterSelect;
   11d94:	81 e0       	ldi	r24, 0x01	; 1
   11d96:	f6 c0       	rjmp	.+492    	; 0x11f84 <FMenuMaster+0x260>
	      break;
     case mmMasterSelect:
	 	  KeyPressed=_key_scan(1);
   11d98:	81 e0       	ldi	r24, 0x01	; 1
   11d9a:	0e 94 ab ae 	call	0x15d56	; 0x15d56 <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
   11d9e:	0e 94 0c ae 	call	0x15c18	; 0x15c18 <_key_btn>
          switch(KeyChar){
   11da2:	81 33       	cpi	r24, 0x31	; 49
   11da4:	09 f4       	brne	.+2      	; 0x11da8 <FMenuMaster+0x84>
   11da6:	ed c0       	rjmp	.+474    	; 0x11f82 <FMenuMaster+0x25e>
   11da8:	82 33       	cpi	r24, 0x32	; 50
   11daa:	21 f0       	breq	.+8      	; 0x11db4 <FMenuMaster+0x90>
   11dac:	8a 32       	cpi	r24, 0x2A	; 42
   11dae:	09 f0       	breq	.+2      	; 0x11db2 <FMenuMaster+0x8e>
   11db0:	c2 c1       	rjmp	.+900    	; 0x12136 <FMenuMaster+0x412>
   11db2:	bb c1       	rjmp	.+886    	; 0x1212a <FMenuMaster+0x406>
		  case '1':
               stMenuMaster=mmRestorePasswordMenu;
		       break;
		  case '2':
		       stMenuMaster=mmChangePassword;
   11db4:	8e e0       	ldi	r24, 0x0E	; 14
   11db6:	e6 c0       	rjmp	.+460    	; 0x11f84 <FMenuMaster+0x260>
		       stMenuMaster=mmExitMaster;
		       break;
		  }
	      break;
     case mmChangePassword:
	      stMenuMaster=mmInitMaster;
   11db8:	10 92 23 03 	sts	0x0323, r1
   11dbc:	bc c1       	rjmp	.+888    	; 0x12136 <FMenuMaster+0x412>
	      break;
     case mmRestorePasswordMenu:	      
	      lcd_clear();
   11dbe:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
		  lcd_printf(1,1,PSTR("Enter GeNiUs Code   "));
   11dc2:	81 e0       	ldi	r24, 0x01	; 1
   11dc4:	61 e0       	ldi	r22, 0x01	; 1
   11dc6:	41 e4       	ldi	r20, 0x41	; 65
   11dc8:	57 e1       	ldi	r21, 0x17	; 23
   11dca:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		  lcd_printf(2,1,PSTR("_                   "));
   11dce:	82 e0       	ldi	r24, 0x02	; 2
   11dd0:	61 e0       	ldi	r22, 0x01	; 1
   11dd2:	4c e2       	ldi	r20, 0x2C	; 44
   11dd4:	57 e1       	ldi	r21, 0x17	; 23
   11dd6:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		  lcd_printf(4,4,PSTR("[*]Cancel   [#]Enter"));
   11dda:	84 e0       	ldi	r24, 0x04	; 4
   11ddc:	64 e0       	ldi	r22, 0x04	; 4
   11dde:	47 e1       	ldi	r20, 0x17	; 23
   11de0:	57 e1       	ldi	r21, 0x17	; 23
   11de2:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		  sprintf_P(strGeniusCode,PSTR(""));
   11de6:	00 d0       	rcall	.+0      	; 0x11de8 <FMenuMaster+0xc4>
   11de8:	00 d0       	rcall	.+0      	; 0x11dea <FMenuMaster+0xc6>
   11dea:	85 e7       	ldi	r24, 0x75	; 117
   11dec:	97 e0       	ldi	r25, 0x07	; 7
   11dee:	ad b7       	in	r26, 0x3d	; 61
   11df0:	be b7       	in	r27, 0x3e	; 62
   11df2:	12 96       	adiw	r26, 0x02	; 2
   11df4:	9c 93       	st	X, r25
   11df6:	8e 93       	st	-X, r24
   11df8:	11 97       	sbiw	r26, 0x01	; 1
   11dfa:	86 e1       	ldi	r24, 0x16	; 22
   11dfc:	97 e1       	ldi	r25, 0x17	; 23
   11dfe:	14 96       	adiw	r26, 0x04	; 4
   11e00:	9c 93       	st	X, r25
   11e02:	8e 93       	st	-X, r24
   11e04:	13 97       	sbiw	r26, 0x03	; 3
   11e06:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
          stMenuMaster=mmGeniusCodeEntry;
   11e0a:	83 e0       	ldi	r24, 0x03	; 3
   11e0c:	80 93 23 03 	sts	0x0323, r24
   11e10:	80 e0       	ldi	r24, 0x00	; 0
   11e12:	0f 90       	pop	r0
   11e14:	0f 90       	pop	r0
   11e16:	0f 90       	pop	r0
   11e18:	0f 90       	pop	r0
   11e1a:	8e c1       	rjmp	.+796    	; 0x12138 <FMenuMaster+0x414>
	      break;
     case mmGeniusCodeEntry:
	 	  uiResult=UserInput(UI_NUMBER_R,2,1,strGeniusCode,0,10);
   11e1c:	81 e0       	ldi	r24, 0x01	; 1
   11e1e:	62 e0       	ldi	r22, 0x02	; 2
   11e20:	41 e0       	ldi	r20, 0x01	; 1
   11e22:	25 e7       	ldi	r18, 0x75	; 117
   11e24:	37 e0       	ldi	r19, 0x07	; 7
   11e26:	00 e0       	ldi	r16, 0x00	; 0
   11e28:	10 e0       	ldi	r17, 0x00	; 0
   11e2a:	fa e0       	ldi	r31, 0x0A	; 10
   11e2c:	ef 2e       	mov	r14, r31
   11e2e:	0e 94 f0 7b 	call	0xf7e0	; 0xf7e0 <UserInput>
		  switch(uiResult){
   11e32:	83 30       	cpi	r24, 0x03	; 3
   11e34:	49 f0       	breq	.+18     	; 0x11e48 <FMenuMaster+0x124>
   11e36:	84 30       	cpi	r24, 0x04	; 4
   11e38:	08 f4       	brcc	.+2      	; 0x11e3c <FMenuMaster+0x118>
   11e3a:	f2 c0       	rjmp	.+484    	; 0x12020 <FMenuMaster+0x2fc>
   11e3c:	84 30       	cpi	r24, 0x04	; 4
   11e3e:	69 f0       	breq	.+26     	; 0x11e5a <FMenuMaster+0x136>
   11e40:	85 30       	cpi	r24, 0x05	; 5
   11e42:	09 f0       	breq	.+2      	; 0x11e46 <FMenuMaster+0x122>
   11e44:	78 c1       	rjmp	.+752    	; 0x12136 <FMenuMaster+0x412>
   11e46:	0e c0       	rjmp	.+28     	; 0x11e64 <FMenuMaster+0x140>
		  case USER_OK:
               
			   //_uart_printf(1,0,PSTR("GeniusCode: "));
			   //_uart_print(1,1,strGeniusCode);

		       _datetime(0, strSystemDate, strSystemTime);
   11e48:	80 e0       	ldi	r24, 0x00	; 0
   11e4a:	6a e9       	ldi	r22, 0x9A	; 154
   11e4c:	75 e0       	ldi	r23, 0x05	; 5
   11e4e:	49 e7       	ldi	r20, 0x79	; 121
   11e50:	5a e0       	ldi	r21, 0x0A	; 10
   11e52:	0e 94 76 b1 	call	0x162ec	; 0x162ec <_datetime>
               stMenuMaster=mmIsValidGeniusCode;
   11e56:	84 e0       	ldi	r24, 0x04	; 4
   11e58:	95 c0       	rjmp	.+298    	; 0x11f84 <FMenuMaster+0x260>
		       break;
          case USER_CANCEL:
		       stMenuMaster=mmExitMaster;
		       break;
		  case USER_ENTRY:
		       lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   11e5a:	84 e0       	ldi	r24, 0x04	; 4
   11e5c:	61 e0       	ldi	r22, 0x01	; 1
   11e5e:	41 e0       	ldi	r20, 0x01	; 1
   11e60:	57 e1       	ldi	r21, 0x17	; 23
   11e62:	f3 c0       	rjmp	.+486    	; 0x1204a <FMenuMaster+0x326>
		       break;
          case USER_NO_DATA:
		       lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   11e64:	84 e0       	ldi	r24, 0x04	; 4
   11e66:	61 e0       	ldi	r22, 0x01	; 1
   11e68:	4c ee       	ldi	r20, 0xEC	; 236
   11e6a:	56 e1       	ldi	r21, 0x16	; 22
   11e6c:	ee c0       	rjmp	.+476    	; 0x1204a <FMenuMaster+0x326>
		       break;
		  }
	      break;
     case mmIsValidGeniusCode:
	      //GetDate
		      sprintf_P(PDate,PSTR("%s"),strSystemDate);
   11e6e:	00 d0       	rcall	.+0      	; 0x11e70 <FMenuMaster+0x14c>
   11e70:	00 d0       	rcall	.+0      	; 0x11e72 <FMenuMaster+0x14e>
   11e72:	00 d0       	rcall	.+0      	; 0x11e74 <FMenuMaster+0x150>
   11e74:	ed b7       	in	r30, 0x3d	; 61
   11e76:	fe b7       	in	r31, 0x3e	; 62
   11e78:	31 96       	adiw	r30, 0x01	; 1
   11e7a:	8e 01       	movw	r16, r28
   11e7c:	05 5f       	subi	r16, 0xF5	; 245
   11e7e:	1f 4f       	sbci	r17, 0xFF	; 255
   11e80:	ad b7       	in	r26, 0x3d	; 61
   11e82:	be b7       	in	r27, 0x3e	; 62
   11e84:	12 96       	adiw	r26, 0x02	; 2
   11e86:	1c 93       	st	X, r17
   11e88:	0e 93       	st	-X, r16
   11e8a:	11 97       	sbiw	r26, 0x01	; 1
   11e8c:	89 ee       	ldi	r24, 0xE9	; 233
   11e8e:	96 e1       	ldi	r25, 0x16	; 22
   11e90:	93 83       	std	Z+3, r25	; 0x03
   11e92:	82 83       	std	Z+2, r24	; 0x02
   11e94:	8a e9       	ldi	r24, 0x9A	; 154
   11e96:	95 e0       	ldi	r25, 0x05	; 5
   11e98:	95 83       	std	Z+5, r25	; 0x05
   11e9a:	84 83       	std	Z+4, r24	; 0x04
   11e9c:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
			  RemoveChar(PDate,'/');
   11ea0:	ed b7       	in	r30, 0x3d	; 61
   11ea2:	fe b7       	in	r31, 0x3e	; 62
   11ea4:	36 96       	adiw	r30, 0x06	; 6
   11ea6:	0f b6       	in	r0, 0x3f	; 63
   11ea8:	f8 94       	cli
   11eaa:	fe bf       	out	0x3e, r31	; 62
   11eac:	0f be       	out	0x3f, r0	; 63
   11eae:	ed bf       	out	0x3d, r30	; 61
   11eb0:	c8 01       	movw	r24, r16
   11eb2:	6f e2       	ldi	r22, 0x2F	; 47
   11eb4:	0e 94 ba 2d 	call	0x5b74	; 0x5b74 <RemoveChar>
		  if (ValidateGeniusCode(PDate,strGeniusCode)==GC_VALID){
   11eb8:	c8 01       	movw	r24, r16
   11eba:	65 e7       	ldi	r22, 0x75	; 117
   11ebc:	77 e0       	ldi	r23, 0x07	; 7
   11ebe:	0e 94 a6 68 	call	0xd14c	; 0xd14c <ValidateGeniusCode>
   11ec2:	81 30       	cpi	r24, 0x01	; 1
   11ec4:	09 f0       	breq	.+2      	; 0x11ec8 <FMenuMaster+0x1a4>
   11ec6:	44 c0       	rjmp	.+136    	; 0x11f50 <FMenuMaster+0x22c>

		  	  sprintf_P(PTime,PSTR("%s"),strSystemTime);
   11ec8:	00 d0       	rcall	.+0      	; 0x11eca <FMenuMaster+0x1a6>
   11eca:	00 d0       	rcall	.+0      	; 0x11ecc <FMenuMaster+0x1a8>
   11ecc:	00 d0       	rcall	.+0      	; 0x11ece <FMenuMaster+0x1aa>
   11ece:	ed b7       	in	r30, 0x3d	; 61
   11ed0:	fe b7       	in	r31, 0x3e	; 62
   11ed2:	31 96       	adiw	r30, 0x01	; 1
   11ed4:	8e 01       	movw	r16, r28
   11ed6:	0f 5f       	subi	r16, 0xFF	; 255
   11ed8:	1f 4f       	sbci	r17, 0xFF	; 255
   11eda:	ad b7       	in	r26, 0x3d	; 61
   11edc:	be b7       	in	r27, 0x3e	; 62
   11ede:	12 96       	adiw	r26, 0x02	; 2
   11ee0:	1c 93       	st	X, r17
   11ee2:	0e 93       	st	-X, r16
   11ee4:	11 97       	sbiw	r26, 0x01	; 1
   11ee6:	86 ee       	ldi	r24, 0xE6	; 230
   11ee8:	96 e1       	ldi	r25, 0x16	; 22
   11eea:	93 83       	std	Z+3, r25	; 0x03
   11eec:	82 83       	std	Z+2, r24	; 0x02
   11eee:	89 e7       	ldi	r24, 0x79	; 121
   11ef0:	9a e0       	ldi	r25, 0x0A	; 10
   11ef2:	95 83       	std	Z+5, r25	; 0x05
   11ef4:	84 83       	std	Z+4, r24	; 0x04
   11ef6:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
			  RemoveChar(PTime,':');sprintf_P(strKeyStamp,PSTR(""));
   11efa:	ed b7       	in	r30, 0x3d	; 61
   11efc:	fe b7       	in	r31, 0x3e	; 62
   11efe:	36 96       	adiw	r30, 0x06	; 6
   11f00:	0f b6       	in	r0, 0x3f	; 63
   11f02:	f8 94       	cli
   11f04:	fe bf       	out	0x3e, r31	; 62
   11f06:	0f be       	out	0x3f, r0	; 63
   11f08:	ed bf       	out	0x3d, r30	; 61
   11f0a:	c8 01       	movw	r24, r16
   11f0c:	6a e3       	ldi	r22, 0x3A	; 58
   11f0e:	0e 94 ba 2d 	call	0x5b74	; 0x5b74 <RemoveChar>
   11f12:	00 d0       	rcall	.+0      	; 0x11f14 <FMenuMaster+0x1f0>
   11f14:	00 d0       	rcall	.+0      	; 0x11f16 <FMenuMaster+0x1f2>
   11f16:	e3 eb       	ldi	r30, 0xB3	; 179
   11f18:	ee 2e       	mov	r14, r30
   11f1a:	e9 e0       	ldi	r30, 0x09	; 9
   11f1c:	fe 2e       	mov	r15, r30
   11f1e:	ad b7       	in	r26, 0x3d	; 61
   11f20:	be b7       	in	r27, 0x3e	; 62
   11f22:	12 96       	adiw	r26, 0x02	; 2
   11f24:	fc 92       	st	X, r15
   11f26:	ee 92       	st	-X, r14
   11f28:	11 97       	sbiw	r26, 0x01	; 1
   11f2a:	85 ee       	ldi	r24, 0xE5	; 229
   11f2c:	96 e1       	ldi	r25, 0x16	; 22
   11f2e:	14 96       	adiw	r26, 0x04	; 4
   11f30:	9c 93       	st	X, r25
   11f32:	8e 93       	st	-X, r24
   11f34:	13 97       	sbiw	r26, 0x03	; 3
   11f36:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>

              //sprintf_P(strSend,PSTR("Time:%s"),PTime);
			  // _uart_print(1,1,strSend);

		      GenerateKeyStamp(PTime,strGeniusCode,strKeyStamp);			  
   11f3a:	0f 90       	pop	r0
   11f3c:	0f 90       	pop	r0
   11f3e:	0f 90       	pop	r0
   11f40:	0f 90       	pop	r0
   11f42:	c8 01       	movw	r24, r16
   11f44:	65 e7       	ldi	r22, 0x75	; 117
   11f46:	77 e0       	ldi	r23, 0x07	; 7
   11f48:	a7 01       	movw	r20, r14
   11f4a:	0e 94 7b 2e 	call	0x5cf6	; 0x5cf6 <GenerateKeyStamp>
   11f4e:	d5 c0       	rjmp	.+426    	; 0x120fa <FMenuMaster+0x3d6>
			  stMenuMaster=mmDisplayKeyStamp;
		  }else stMenuMaster=mmDisplayInvalidCode;
   11f50:	85 e0       	ldi	r24, 0x05	; 5
   11f52:	18 c0       	rjmp	.+48     	; 0x11f84 <FMenuMaster+0x260>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   11f54:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   11f56:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   11f58:	81 e0       	ldi	r24, 0x01	; 1
   11f5a:	90 e0       	ldi	r25, 0x00	; 0
   11f5c:	90 93 d7 01 	sts	0x01D7, r25
   11f60:	80 93 d6 01 	sts	0x01D6, r24
			  stMenuMaster=mmDisplayKeyStamp;
		  }else stMenuMaster=mmDisplayInvalidCode;
	      break;
     case mmDisplayInvalidCode:
	      system_beep(1);
          lcd_printf(3,1,PSTR("Invalid Code        "));
   11f64:	83 e0       	ldi	r24, 0x03	; 3
   11f66:	61 e0       	ldi	r22, 0x01	; 1
   11f68:	40 ed       	ldi	r20, 0xD0	; 208
   11f6a:	56 e1       	ldi	r21, 0x16	; 22
   11f6c:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
          TimDisplay=0; 
   11f70:	10 92 a7 01 	sts	0x01A7, r1
		  stMenuMaster=mmDelayDisplayInvalidCode;
   11f74:	86 e0       	ldi	r24, 0x06	; 6
   11f76:	06 c0       	rjmp	.+12     	; 0x11f84 <FMenuMaster+0x260>
	      break;
     case mmDelayDisplayInvalidCode:
	      if (TimDisplay>5)stMenuMaster=mmRestorePasswordMenu;
   11f78:	80 91 a7 01 	lds	r24, 0x01A7
   11f7c:	86 30       	cpi	r24, 0x06	; 6
   11f7e:	08 f4       	brcc	.+2      	; 0x11f82 <FMenuMaster+0x25e>
   11f80:	da c0       	rjmp	.+436    	; 0x12136 <FMenuMaster+0x412>
   11f82:	82 e0       	ldi	r24, 0x02	; 2
   11f84:	80 93 23 03 	sts	0x0323, r24
   11f88:	d6 c0       	rjmp	.+428    	; 0x12136 <FMenuMaster+0x412>
	      break;
     case mmDisplayKeyStamp:
	      lcd_clear();
   11f8a:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
		  sprintf_P(lcdteks,PSTR("Key Stamp:%s "),strKeyStamp);
   11f8e:	00 d0       	rcall	.+0      	; 0x11f90 <FMenuMaster+0x26c>
   11f90:	00 d0       	rcall	.+0      	; 0x11f92 <FMenuMaster+0x26e>
   11f92:	00 d0       	rcall	.+0      	; 0x11f94 <FMenuMaster+0x270>
   11f94:	ed b7       	in	r30, 0x3d	; 61
   11f96:	fe b7       	in	r31, 0x3e	; 62
   11f98:	31 96       	adiw	r30, 0x01	; 1
   11f9a:	8e 01       	movw	r16, r28
   11f9c:	01 5e       	subi	r16, 0xE1	; 225
   11f9e:	1f 4f       	sbci	r17, 0xFF	; 255
   11fa0:	ad b7       	in	r26, 0x3d	; 61
   11fa2:	be b7       	in	r27, 0x3e	; 62
   11fa4:	12 96       	adiw	r26, 0x02	; 2
   11fa6:	1c 93       	st	X, r17
   11fa8:	0e 93       	st	-X, r16
   11faa:	11 97       	sbiw	r26, 0x01	; 1
   11fac:	82 ec       	ldi	r24, 0xC2	; 194
   11fae:	96 e1       	ldi	r25, 0x16	; 22
   11fb0:	93 83       	std	Z+3, r25	; 0x03
   11fb2:	82 83       	std	Z+2, r24	; 0x02
   11fb4:	83 eb       	ldi	r24, 0xB3	; 179
   11fb6:	99 e0       	ldi	r25, 0x09	; 9
   11fb8:	95 83       	std	Z+5, r25	; 0x05
   11fba:	84 83       	std	Z+4, r24	; 0x04
   11fbc:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
		  lcd_print(1,1,lcdteks);
   11fc0:	ed b7       	in	r30, 0x3d	; 61
   11fc2:	fe b7       	in	r31, 0x3e	; 62
   11fc4:	36 96       	adiw	r30, 0x06	; 6
   11fc6:	0f b6       	in	r0, 0x3f	; 63
   11fc8:	f8 94       	cli
   11fca:	fe bf       	out	0x3e, r31	; 62
   11fcc:	0f be       	out	0x3f, r0	; 63
   11fce:	ed bf       	out	0x3d, r30	; 61
   11fd0:	81 e0       	ldi	r24, 0x01	; 1
   11fd2:	61 e0       	ldi	r22, 0x01	; 1
   11fd4:	a8 01       	movw	r20, r16
   11fd6:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
		  lcd_printf(2,1,PSTR("Enter Restore Code  "));
   11fda:	82 e0       	ldi	r24, 0x02	; 2
   11fdc:	61 e0       	ldi	r22, 0x01	; 1
   11fde:	4d ea       	ldi	r20, 0xAD	; 173
   11fe0:	56 e1       	ldi	r21, 0x16	; 22
   11fe2:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		  lcd_printf(3,1,PSTR("_                   "));
   11fe6:	83 e0       	ldi	r24, 0x03	; 3
   11fe8:	61 e0       	ldi	r22, 0x01	; 1
   11fea:	48 e9       	ldi	r20, 0x98	; 152
   11fec:	56 e1       	ldi	r21, 0x16	; 22
   11fee:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		  lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   11ff2:	84 e0       	ldi	r24, 0x04	; 4
   11ff4:	61 e0       	ldi	r22, 0x01	; 1
   11ff6:	43 e8       	ldi	r20, 0x83	; 131
   11ff8:	56 e1       	ldi	r21, 0x16	; 22
   11ffa:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
          stMenuMaster=mmRestoreCodeEntry;
   11ffe:	88 e0       	ldi	r24, 0x08	; 8
   12000:	c1 cf       	rjmp	.-126    	; 0x11f84 <FMenuMaster+0x260>
	      break;
     case mmRestoreCodeEntry:
	 	  uiResult=UserInput(UI_NUMBER_R,3,1,strRestoreCode,0,10);
   12002:	81 e0       	ldi	r24, 0x01	; 1
   12004:	63 e0       	ldi	r22, 0x03	; 3
   12006:	41 e0       	ldi	r20, 0x01	; 1
   12008:	26 e3       	ldi	r18, 0x36	; 54
   1200a:	3e e0       	ldi	r19, 0x0E	; 14
   1200c:	00 e0       	ldi	r16, 0x00	; 0
   1200e:	10 e0       	ldi	r17, 0x00	; 0
   12010:	7a e0       	ldi	r23, 0x0A	; 10
   12012:	e7 2e       	mov	r14, r23
   12014:	0e 94 f0 7b 	call	0xf7e0	; 0xf7e0 <UserInput>
		  switch(uiResult){
   12018:	83 30       	cpi	r24, 0x03	; 3
   1201a:	61 f0       	breq	.+24     	; 0x12034 <FMenuMaster+0x310>
   1201c:	84 30       	cpi	r24, 0x04	; 4
   1201e:	20 f4       	brcc	.+8      	; 0x12028 <FMenuMaster+0x304>
   12020:	81 30       	cpi	r24, 0x01	; 1
   12022:	09 f0       	breq	.+2      	; 0x12026 <FMenuMaster+0x302>
   12024:	88 c0       	rjmp	.+272    	; 0x12136 <FMenuMaster+0x412>
   12026:	81 c0       	rjmp	.+258    	; 0x1212a <FMenuMaster+0x406>
   12028:	84 30       	cpi	r24, 0x04	; 4
   1202a:	31 f0       	breq	.+12     	; 0x12038 <FMenuMaster+0x314>
   1202c:	85 30       	cpi	r24, 0x05	; 5
   1202e:	09 f0       	breq	.+2      	; 0x12032 <FMenuMaster+0x30e>
   12030:	82 c0       	rjmp	.+260    	; 0x12136 <FMenuMaster+0x412>
   12032:	07 c0       	rjmp	.+14     	; 0x12042 <FMenuMaster+0x31e>
		  case USER_OK:
               stMenuMaster=mmIsValidRestoreCode;
   12034:	89 e0       	ldi	r24, 0x09	; 9
   12036:	a6 cf       	rjmp	.-180    	; 0x11f84 <FMenuMaster+0x260>
		       break;
          case USER_CANCEL:
		       stMenuMaster=mmExitMaster;
		       break;
		  case USER_ENTRY:
		       lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   12038:	84 e0       	ldi	r24, 0x04	; 4
   1203a:	61 e0       	ldi	r22, 0x01	; 1
   1203c:	4e e6       	ldi	r20, 0x6E	; 110
   1203e:	56 e1       	ldi	r21, 0x16	; 22
   12040:	04 c0       	rjmp	.+8      	; 0x1204a <FMenuMaster+0x326>
		       break;
          case USER_NO_DATA:
		       lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   12042:	84 e0       	ldi	r24, 0x04	; 4
   12044:	61 e0       	ldi	r22, 0x01	; 1
   12046:	49 e5       	ldi	r20, 0x59	; 89
   12048:	56 e1       	ldi	r21, 0x16	; 22
   1204a:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
   1204e:	73 c0       	rjmp	.+230    	; 0x12136 <FMenuMaster+0x412>
		       break;
		  }
	      break;
     case mmIsValidRestoreCode:
	      if (ValidateRestoreCode(strKeyStamp,strRestoreCode)==RC_VALID){
   12050:	83 eb       	ldi	r24, 0xB3	; 179
   12052:	99 e0       	ldi	r25, 0x09	; 9
   12054:	66 e3       	ldi	r22, 0x36	; 54
   12056:	7e e0       	ldi	r23, 0x0E	; 14
   12058:	0e 94 84 68 	call	0xd108	; 0xd108 <ValidateRestoreCode>
   1205c:	81 30       	cpi	r24, 0x01	; 1
   1205e:	11 f4       	brne	.+4      	; 0x12064 <FMenuMaster+0x340>
		      stMenuMaster=mmRestorePassword;
   12060:	8c e0       	ldi	r24, 0x0C	; 12
   12062:	90 cf       	rjmp	.-224    	; 0x11f84 <FMenuMaster+0x260>
		  }else stMenuMaster=mmDisplayInvalidRestoreCode;
   12064:	8a e0       	ldi	r24, 0x0A	; 10
   12066:	8e cf       	rjmp	.-228    	; 0x11f84 <FMenuMaster+0x260>
	      break;
     case mmRestorePassword:
	      sprintf_P(strNewPassword,PSTR(SPV_DEFAULT_PASS));
   12068:	00 d0       	rcall	.+0      	; 0x1206a <FMenuMaster+0x346>
   1206a:	00 d0       	rcall	.+0      	; 0x1206c <FMenuMaster+0x348>
   1206c:	8e 01       	movw	r16, r28
   1206e:	0b 5e       	subi	r16, 0xEB	; 235
   12070:	1f 4f       	sbci	r17, 0xFF	; 255
   12072:	ad b7       	in	r26, 0x3d	; 61
   12074:	be b7       	in	r27, 0x3e	; 62
   12076:	12 96       	adiw	r26, 0x02	; 2
   12078:	1c 93       	st	X, r17
   1207a:	0e 93       	st	-X, r16
   1207c:	11 97       	sbiw	r26, 0x01	; 1
   1207e:	83 e5       	ldi	r24, 0x53	; 83
   12080:	96 e1       	ldi	r25, 0x16	; 22
   12082:	14 96       	adiw	r26, 0x04	; 4
   12084:	9c 93       	st	X, r25
   12086:	8e 93       	st	-X, r24
   12088:	13 97       	sbiw	r26, 0x03	; 3
   1208a:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
   1208e:	0f 90       	pop	r0
   12090:	0f 90       	pop	r0
   12092:	0f 90       	pop	r0
   12094:	0f 90       	pop	r0
   12096:	81 e0       	ldi	r24, 0x01	; 1
   12098:	90 e0       	ldi	r25, 0x00	; 0
   1209a:	b8 01       	movw	r22, r16
   1209c:	4a e0       	ldi	r20, 0x0A	; 10
   1209e:	50 e0       	ldi	r21, 0x00	; 0
   120a0:	2b ef       	ldi	r18, 0xFB	; 251
   120a2:	32 e1       	ldi	r19, 0x12	; 18
   120a4:	0e 94 3b b4 	call	0x16876	; 0x16876 <__eewr_block>
		  eeprom_write_block((const void*) &strNewPassword,(void*) &DefSpvPassword,sizeof(DefSpvPassword));
		  sprintf_P(strNewPassword,PSTR(SYS_DEFAULT_PASS));
   120a8:	00 d0       	rcall	.+0      	; 0x120aa <FMenuMaster+0x386>
   120aa:	00 d0       	rcall	.+0      	; 0x120ac <FMenuMaster+0x388>
   120ac:	ed b7       	in	r30, 0x3d	; 61
   120ae:	fe b7       	in	r31, 0x3e	; 62
   120b0:	12 83       	std	Z+2, r17	; 0x02
   120b2:	01 83       	std	Z+1, r16	; 0x01
   120b4:	8d e4       	ldi	r24, 0x4D	; 77
   120b6:	96 e1       	ldi	r25, 0x16	; 22
   120b8:	94 83       	std	Z+4, r25	; 0x04
   120ba:	83 83       	std	Z+3, r24	; 0x03
   120bc:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
   120c0:	0f 90       	pop	r0
   120c2:	0f 90       	pop	r0
   120c4:	0f 90       	pop	r0
   120c6:	0f 90       	pop	r0
   120c8:	8b e0       	ldi	r24, 0x0B	; 11
   120ca:	90 e0       	ldi	r25, 0x00	; 0
   120cc:	b8 01       	movw	r22, r16
   120ce:	4a e0       	ldi	r20, 0x0A	; 10
   120d0:	50 e0       	ldi	r21, 0x00	; 0
   120d2:	2b ef       	ldi	r18, 0xFB	; 251
   120d4:	32 e1       	ldi	r19, 0x12	; 18
   120d6:	0e 94 3b b4 	call	0x16876	; 0x16876 <__eewr_block>
		  eeprom_write_block((const void*) &strNewPassword,(void*) &DefSysPassword,sizeof(DefSysPassword));	      		  
	      stMenuMaster=mmDisplaySuccess;
   120da:	8d e0       	ldi	r24, 0x0D	; 13
   120dc:	53 cf       	rjmp	.-346    	; 0x11f84 <FMenuMaster+0x260>
	      break;
     case mmDisplayInvalidRestoreCode:
	      lcd_printf(3,1,PSTR("Invalid Restore  "));
   120de:	83 e0       	ldi	r24, 0x03	; 3
   120e0:	61 e0       	ldi	r22, 0x01	; 1
   120e2:	4b e3       	ldi	r20, 0x3B	; 59
   120e4:	56 e1       	ldi	r21, 0x16	; 22
   120e6:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		  TimDisplay=0;
   120ea:	10 92 a7 01 	sts	0x01A7, r1
          stMenuMaster=mmDelayInvalidRestoreCode;
   120ee:	8b e0       	ldi	r24, 0x0B	; 11
   120f0:	49 cf       	rjmp	.-366    	; 0x11f84 <FMenuMaster+0x260>
	      break;
     case mmDelayInvalidRestoreCode:
	      if (TimDisplay>5)stMenuMaster=mmDisplayKeyStamp;
   120f2:	80 91 a7 01 	lds	r24, 0x01A7
   120f6:	86 30       	cpi	r24, 0x06	; 6
   120f8:	f0 f0       	brcs	.+60     	; 0x12136 <FMenuMaster+0x412>
   120fa:	87 e0       	ldi	r24, 0x07	; 7
   120fc:	43 cf       	rjmp	.-378    	; 0x11f84 <FMenuMaster+0x260>
	      break;
     case mmDisplaySuccess:
	      //lcd_clear();
		  lcd_printf(3,1,PSTR("Password Restored"));
   120fe:	83 e0       	ldi	r24, 0x03	; 3
   12100:	61 e0       	ldi	r22, 0x01	; 1
   12102:	49 e2       	ldi	r20, 0x29	; 41
   12104:	56 e1       	ldi	r21, 0x16	; 22
   12106:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   1210a:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   1210c:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   1210e:	81 e0       	ldi	r24, 0x01	; 1
   12110:	90 e0       	ldi	r25, 0x00	; 0
   12112:	90 93 d7 01 	sts	0x01D7, r25
   12116:	80 93 d6 01 	sts	0x01D6, r24
	      break;
     case mmDisplaySuccess:
	      //lcd_clear();
		  lcd_printf(3,1,PSTR("Password Restored"));
		  system_beep(1);
		  TimDisplay=0;
   1211a:	10 92 a7 01 	sts	0x01A7, r1
          stMenuMaster=mmDelayExit;
   1211e:	8f e0       	ldi	r24, 0x0F	; 15
   12120:	31 cf       	rjmp	.-414    	; 0x11f84 <FMenuMaster+0x260>
	      break;
     case mmDelayExit:
	      if (TimDisplay>=5)stMenuMaster=mmExitMaster;
   12122:	80 91 a7 01 	lds	r24, 0x01A7
   12126:	85 30       	cpi	r24, 0x05	; 5
   12128:	30 f0       	brcs	.+12     	; 0x12136 <FMenuMaster+0x412>
   1212a:	80 e1       	ldi	r24, 0x10	; 16
   1212c:	2b cf       	rjmp	.-426    	; 0x11f84 <FMenuMaster+0x260>
	      break;
     case mmExitMaster:
	      stMenuMaster=mmInitMaster;
   1212e:	10 92 23 03 	sts	0x0323, r1
   12132:	81 e0       	ldi	r24, 0x01	; 1
   12134:	01 c0       	rjmp	.+2      	; 0x12138 <FMenuMaster+0x414>
   12136:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
  return Result;

}
   12138:	e2 96       	adiw	r28, 0x32	; 50
   1213a:	0f b6       	in	r0, 0x3f	; 63
   1213c:	f8 94       	cli
   1213e:	de bf       	out	0x3e, r29	; 62
   12140:	0f be       	out	0x3f, r0	; 63
   12142:	cd bf       	out	0x3d, r28	; 61
   12144:	cf 91       	pop	r28
   12146:	df 91       	pop	r29
   12148:	1f 91       	pop	r17
   1214a:	0f 91       	pop	r16
   1214c:	ff 90       	pop	r15
   1214e:	ef 90       	pop	r14
   12150:	08 95       	ret

00012152 <FMenuPassword>:
   return Result;	 
}



char FMenuPassword(){
   12152:	af 92       	push	r10
   12154:	bf 92       	push	r11
   12156:	cf 92       	push	r12
   12158:	df 92       	push	r13
   1215a:	ef 92       	push	r14
   1215c:	0f 93       	push	r16
   1215e:	1f 93       	push	r17
   12160:	df 93       	push	r29
   12162:	cf 93       	push	r28
   12164:	cd b7       	in	r28, 0x3d	; 61
   12166:	de b7       	in	r29, 0x3e	; 62
   12168:	6e 97       	sbiw	r28, 0x1e	; 30
   1216a:	0f b6       	in	r0, 0x3f	; 63
   1216c:	f8 94       	cli
   1216e:	de bf       	out	0x3e, r29	; 62
   12170:	0f be       	out	0x3f, r0	; 63
   12172:	cd bf       	out	0x3d, r28	; 61
static char stMenuPasword=mpInitPassword,uiResult,strPassword[10],PassStatus=MP_NONE;;
char Result=MP_NONE,strMasterPass[10],strSystemPass[10],strAdminPass[10];

     Result=MP_NONE;
     switch(stMenuPasword){
   12174:	e0 90 30 03 	lds	r14, 0x0330
   12178:	81 e0       	ldi	r24, 0x01	; 1
   1217a:	e8 16       	cp	r14, r24
   1217c:	09 f1       	breq	.+66     	; 0x121c0 <FMenuPassword+0x6e>
   1217e:	e8 16       	cp	r14, r24
   12180:	48 f0       	brcs	.+18     	; 0x12194 <FMenuPassword+0x42>
   12182:	e2 e0       	ldi	r30, 0x02	; 2
   12184:	ee 16       	cp	r14, r30
   12186:	09 f4       	brne	.+2      	; 0x1218a <FMenuPassword+0x38>
   12188:	3f c0       	rjmp	.+126    	; 0x12208 <FMenuPassword+0xb6>
   1218a:	f3 e0       	ldi	r31, 0x03	; 3
   1218c:	ef 16       	cp	r14, r31
   1218e:	09 f0       	breq	.+2      	; 0x12192 <FMenuPassword+0x40>
   12190:	92 c0       	rjmp	.+292    	; 0x122b6 <FMenuPassword+0x164>
   12192:	8c c0       	rjmp	.+280    	; 0x122ac <FMenuPassword+0x15a>
	 case mpInitPassword:
	      lcd_clear();
   12194:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
		  lcd_printf(1,1,PSTR("PASSWORD:"));
   12198:	81 e0       	ldi	r24, 0x01	; 1
   1219a:	61 e0       	ldi	r22, 0x01	; 1
   1219c:	46 e0       	ldi	r20, 0x06	; 6
   1219e:	58 e1       	ldi	r21, 0x18	; 24
   121a0:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		  lcd_printf(2,1,PSTR("_"));
   121a4:	82 e0       	ldi	r24, 0x02	; 2
   121a6:	61 e0       	ldi	r22, 0x01	; 1
   121a8:	44 e0       	ldi	r20, 0x04	; 4
   121aa:	58 e1       	ldi	r21, 0x18	; 24
   121ac:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		  lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   121b0:	84 e0       	ldi	r24, 0x04	; 4
   121b2:	61 e0       	ldi	r22, 0x01	; 1
   121b4:	4f ee       	ldi	r20, 0xEF	; 239
   121b6:	57 e1       	ldi	r21, 0x17	; 23
   121b8:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		  FillChar(strPassword,0,sizeof(strPassword));
		  stMenuPasword=mpInputPasword;
   121bc:	81 e0       	ldi	r24, 0x01	; 1
   121be:	73 c0       	rjmp	.+230    	; 0x122a6 <FMenuPassword+0x154>
	      break;
     case mpInputPasword:
	 	      uiResult=UserInput(UI_NUM_PASSWORD,2,1,strPassword,0,8);
   121c0:	84 e0       	ldi	r24, 0x04	; 4
   121c2:	62 e0       	ldi	r22, 0x02	; 2
   121c4:	41 e0       	ldi	r20, 0x01	; 1
   121c6:	25 e2       	ldi	r18, 0x25	; 37
   121c8:	33 e0       	ldi	r19, 0x03	; 3
   121ca:	00 e0       	ldi	r16, 0x00	; 0
   121cc:	10 e0       	ldi	r17, 0x00	; 0
   121ce:	98 e0       	ldi	r25, 0x08	; 8
   121d0:	e9 2e       	mov	r14, r25
   121d2:	0e 94 f0 7b 	call	0xf7e0	; 0xf7e0 <UserInput>
   121d6:	80 93 2f 03 	sts	0x032F, r24
		  if (uiResult==USER_OK){
   121da:	83 30       	cpi	r24, 0x03	; 3
   121dc:	11 f4       	brne	.+4      	; 0x121e2 <FMenuPassword+0x90>
		      stMenuPasword=mpProcessPassword;
   121de:	82 e0       	ldi	r24, 0x02	; 2
   121e0:	62 c0       	rjmp	.+196    	; 0x122a6 <FMenuPassword+0x154>
			  }
		  else
		  if (uiResult==USER_CANCEL){
   121e2:	81 30       	cpi	r24, 0x01	; 1
   121e4:	09 f4       	brne	.+2      	; 0x121e8 <FMenuPassword+0x96>
   121e6:	50 c0       	rjmp	.+160    	; 0x12288 <FMenuPassword+0x136>
		      PassStatus=MP_CANCEL;
		      stMenuPasword=mpExit;
			  }
		  else
		  if (uiResult==USER_ENTRY)lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   121e8:	84 30       	cpi	r24, 0x04	; 4
   121ea:	21 f4       	brne	.+8      	; 0x121f4 <FMenuPassword+0xa2>
   121ec:	61 e0       	ldi	r22, 0x01	; 1
   121ee:	4a ed       	ldi	r20, 0xDA	; 218
   121f0:	57 e1       	ldi	r21, 0x17	; 23
   121f2:	07 c0       	rjmp	.+14     	; 0x12202 <FMenuPassword+0xb0>
		  else
		  if (uiResult==USER_NO_DATA)lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   121f4:	85 30       	cpi	r24, 0x05	; 5
   121f6:	09 f0       	breq	.+2      	; 0x121fa <FMenuPassword+0xa8>
   121f8:	5e c0       	rjmp	.+188    	; 0x122b6 <FMenuPassword+0x164>
   121fa:	84 e0       	ldi	r24, 0x04	; 4
   121fc:	61 e0       	ldi	r22, 0x01	; 1
   121fe:	45 ec       	ldi	r20, 0xC5	; 197
   12200:	57 e1       	ldi	r21, 0x17	; 23
   12202:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
   12206:	57 c0       	rjmp	.+174    	; 0x122b6 <FMenuPassword+0x164>
          break;	 
	 case mpProcessPassword:
		      
	      sprintf_P(strMasterPass,PSTR(MASTER_PASSWORD)); 
   12208:	00 d0       	rcall	.+0      	; 0x1220a <FMenuPassword+0xb8>
   1220a:	00 d0       	rcall	.+0      	; 0x1220c <FMenuPassword+0xba>
   1220c:	8e 01       	movw	r16, r28
   1220e:	0f 5f       	subi	r16, 0xFF	; 255
   12210:	1f 4f       	sbci	r17, 0xFF	; 255
   12212:	ed b7       	in	r30, 0x3d	; 61
   12214:	fe b7       	in	r31, 0x3e	; 62
   12216:	12 83       	std	Z+2, r17	; 0x02
   12218:	01 83       	std	Z+1, r16	; 0x01
   1221a:	8d eb       	ldi	r24, 0xBD	; 189
   1221c:	97 e1       	ldi	r25, 0x17	; 23
   1221e:	94 83       	std	Z+4, r25	; 0x04
   12220:	83 83       	std	Z+3, r24	; 0x03
   12222:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
   12226:	0f 90       	pop	r0
   12228:	0f 90       	pop	r0
   1222a:	0f 90       	pop	r0
   1222c:	0f 90       	pop	r0
   1222e:	b5 e1       	ldi	r27, 0x15	; 21
   12230:	cb 2e       	mov	r12, r27
   12232:	d1 2c       	mov	r13, r1
   12234:	cc 0e       	add	r12, r28
   12236:	dd 1e       	adc	r13, r29
   12238:	c6 01       	movw	r24, r12
   1223a:	61 e0       	ldi	r22, 0x01	; 1
   1223c:	70 e0       	ldi	r23, 0x00	; 0
   1223e:	4a e0       	ldi	r20, 0x0A	; 10
   12240:	50 e0       	ldi	r21, 0x00	; 0
   12242:	23 ef       	ldi	r18, 0xF3	; 243
   12244:	32 e1       	ldi	r19, 0x12	; 18
   12246:	0e 94 1f b4 	call	0x1683e	; 0x1683e <__eerd_block>
	      eeprom_read_block((void*) &strAdminPass, (const void*) &DefSpvPassword, 10);
	      eeprom_read_block((void*) &strSystemPass, (const void*) &DefSysPassword, 10);
		  
		  if (strcmp(strMasterPass,strPassword)==0)
   1224a:	ab e0       	ldi	r26, 0x0B	; 11
   1224c:	aa 2e       	mov	r10, r26
   1224e:	b1 2c       	mov	r11, r1
   12250:	ac 0e       	add	r10, r28
   12252:	bd 1e       	adc	r11, r29
   12254:	c5 01       	movw	r24, r10
   12256:	6b e0       	ldi	r22, 0x0B	; 11
   12258:	70 e0       	ldi	r23, 0x00	; 0
   1225a:	4a e0       	ldi	r20, 0x0A	; 10
   1225c:	50 e0       	ldi	r21, 0x00	; 0
   1225e:	23 ef       	ldi	r18, 0xF3	; 243
   12260:	32 e1       	ldi	r19, 0x12	; 18
   12262:	0e 94 1f b4 	call	0x1683e	; 0x1683e <__eerd_block>
   12266:	c8 01       	movw	r24, r16
   12268:	65 e2       	ldi	r22, 0x25	; 37
   1226a:	73 e0       	ldi	r23, 0x03	; 3
   1226c:	0e 94 0f b4 	call	0x1681e	; 0x1681e <strcmp>
   12270:	00 97       	sbiw	r24, 0x00	; 0
   12272:	11 f4       	brne	.+4      	; 0x12278 <FMenuPassword+0x126>
		       PassStatus=MP_VALID_MASTER;
   12274:	83 e0       	ldi	r24, 0x03	; 3
   12276:	08 c0       	rjmp	.+16     	; 0x12288 <FMenuPassword+0x136>
		  else
	      if (strcmp(strAdminPass,strPassword)==0){
   12278:	c6 01       	movw	r24, r12
   1227a:	65 e2       	ldi	r22, 0x25	; 37
   1227c:	73 e0       	ldi	r23, 0x03	; 3
   1227e:	0e 94 0f b4 	call	0x1681e	; 0x1681e <strcmp>
   12282:	00 97       	sbiw	r24, 0x00	; 0
   12284:	21 f4       	brne	.+8      	; 0x1228e <FMenuPassword+0x13c>
		       PassStatus=MP_VALID_ADMIN;
   12286:	84 e0       	ldi	r24, 0x04	; 4
   12288:	80 93 24 03 	sts	0x0324, r24
   1228c:	0b c0       	rjmp	.+22     	; 0x122a4 <FMenuPassword+0x152>
               //lcd_printf(3,1,PSTR("Admin"));
               //_delay_ms(5000);
			   }
		  else if (strcmp(strSystemPass,strPassword)==0){
   1228e:	c5 01       	movw	r24, r10
   12290:	65 e2       	ldi	r22, 0x25	; 37
   12292:	73 e0       	ldi	r23, 0x03	; 3
   12294:	0e 94 0f b4 	call	0x1681e	; 0x1681e <strcmp>
   12298:	00 97       	sbiw	r24, 0x00	; 0
   1229a:	11 f4       	brne	.+4      	; 0x122a0 <FMenuPassword+0x14e>
		       PassStatus=MP_VALID_SYSTEM;
   1229c:	85 e0       	ldi	r24, 0x05	; 5
   1229e:	f4 cf       	rjmp	.-24     	; 0x12288 <FMenuPassword+0x136>
			   //lcd_printf(3,1,PSTR("System"));
               //_delay_ms(5000);
			   }
		  else PassStatus=MP_INVALID;
   122a0:	e0 92 24 03 	sts	0x0324, r14
		  stMenuPasword=mpExit;
   122a4:	83 e0       	ldi	r24, 0x03	; 3
   122a6:	80 93 30 03 	sts	0x0330, r24
   122aa:	05 c0       	rjmp	.+10     	; 0x122b6 <FMenuPassword+0x164>
	      break;
	 case mpExit:
	      //lcd_print(3,1,strPassword);
		  //_delay_ms(5000);
	      stMenuPasword=mpInitPassword;
   122ac:	10 92 30 03 	sts	0x0330, r1
	      Result=PassStatus;
   122b0:	80 91 24 03 	lds	r24, 0x0324
   122b4:	01 c0       	rjmp	.+2      	; 0x122b8 <FMenuPassword+0x166>
   122b6:	80 e0       	ldi	r24, 0x00	; 0
	      break;
	 }
   return Result;
}
   122b8:	6e 96       	adiw	r28, 0x1e	; 30
   122ba:	0f b6       	in	r0, 0x3f	; 63
   122bc:	f8 94       	cli
   122be:	de bf       	out	0x3e, r29	; 62
   122c0:	0f be       	out	0x3f, r0	; 63
   122c2:	cd bf       	out	0x3d, r28	; 61
   122c4:	cf 91       	pop	r28
   122c6:	df 91       	pop	r29
   122c8:	1f 91       	pop	r17
   122ca:	0f 91       	pop	r16
   122cc:	ef 90       	pop	r14
   122ce:	df 90       	pop	r13
   122d0:	cf 90       	pop	r12
   122d2:	bf 90       	pop	r11
   122d4:	af 90       	pop	r10
   122d6:	08 95       	ret

000122d8 <FMenuReprint>:
	       break;
	 }
return Result;
}

char FMenuReprint(){
   122d8:	0f 93       	push	r16
   122da:	1f 93       	push	r17
   122dc:	df 93       	push	r29
   122de:	cf 93       	push	r28
   122e0:	cd b7       	in	r28, 0x3d	; 61
   122e2:	de b7       	in	r29, 0x3e	; 62
   122e4:	64 97       	sbiw	r28, 0x14	; 20
   122e6:	0f b6       	in	r0, 0x3f	; 63
   122e8:	f8 94       	cli
   122ea:	de bf       	out	0x3e, r29	; 62
   122ec:	0f be       	out	0x3f, r0	; 63
   122ee:	cd bf       	out	0x3d, r28	; 61
static char KeyPressed=0,FIP_Used=0;
       char lcdteks[20],FIPResult,KeyChar;//,FIP_USED;
	   char PassResult,Result=MENU_NONE,ReprintResult;

     Result=MENU_NONE;
	 switch(stReprint){
   122f0:	80 91 52 03 	lds	r24, 0x0352
   122f4:	87 30       	cpi	r24, 0x07	; 7
   122f6:	09 f4       	brne	.+2      	; 0x122fa <FMenuReprint+0x22>
   122f8:	8e c0       	rjmp	.+284    	; 0x12416 <FMenuReprint+0x13e>
   122fa:	88 30       	cpi	r24, 0x08	; 8
   122fc:	90 f4       	brcc	.+36     	; 0x12322 <FMenuReprint+0x4a>
   122fe:	83 30       	cpi	r24, 0x03	; 3
   12300:	09 f4       	brne	.+2      	; 0x12304 <FMenuReprint+0x2c>
   12302:	43 c0       	rjmp	.+134    	; 0x1238a <FMenuReprint+0xb2>
   12304:	84 30       	cpi	r24, 0x04	; 4
   12306:	30 f4       	brcc	.+12     	; 0x12314 <FMenuReprint+0x3c>
   12308:	81 30       	cpi	r24, 0x01	; 1
   1230a:	09 f4       	brne	.+2      	; 0x1230e <FMenuReprint+0x36>
   1230c:	55 c0       	rjmp	.+170    	; 0x123b8 <FMenuReprint+0xe0>
   1230e:	82 30       	cpi	r24, 0x02	; 2
   12310:	48 f5       	brcc	.+82     	; 0x12364 <FMenuReprint+0x8c>
   12312:	1d c0       	rjmp	.+58     	; 0x1234e <FMenuReprint+0x76>
   12314:	85 30       	cpi	r24, 0x05	; 5
   12316:	09 f4       	brne	.+2      	; 0x1231a <FMenuReprint+0x42>
   12318:	6c c0       	rjmp	.+216    	; 0x123f2 <FMenuReprint+0x11a>
   1231a:	86 30       	cpi	r24, 0x06	; 6
   1231c:	08 f0       	brcs	.+2      	; 0x12320 <FMenuReprint+0x48>
   1231e:	50 c0       	rjmp	.+160    	; 0x123c0 <FMenuReprint+0xe8>
   12320:	45 c0       	rjmp	.+138    	; 0x123ac <FMenuReprint+0xd4>
   12322:	8b 30       	cpi	r24, 0x0B	; 11
   12324:	09 f4       	brne	.+2      	; 0x12328 <FMenuReprint+0x50>
   12326:	da c0       	rjmp	.+436    	; 0x124dc <FMenuReprint+0x204>
   12328:	8c 30       	cpi	r24, 0x0C	; 12
   1232a:	38 f4       	brcc	.+14     	; 0x1233a <FMenuReprint+0x62>
   1232c:	89 30       	cpi	r24, 0x09	; 9
   1232e:	09 f4       	brne	.+2      	; 0x12332 <FMenuReprint+0x5a>
   12330:	b8 c0       	rjmp	.+368    	; 0x124a2 <FMenuReprint+0x1ca>
   12332:	8a 30       	cpi	r24, 0x0A	; 10
   12334:	08 f0       	brcs	.+2      	; 0x12338 <FMenuReprint+0x60>
   12336:	ca c0       	rjmp	.+404    	; 0x124cc <FMenuReprint+0x1f4>
   12338:	7c c0       	rjmp	.+248    	; 0x12432 <FMenuReprint+0x15a>
   1233a:	8d 30       	cpi	r24, 0x0D	; 13
   1233c:	09 f4       	brne	.+2      	; 0x12340 <FMenuReprint+0x68>
   1233e:	ed c0       	rjmp	.+474    	; 0x1251a <FMenuReprint+0x242>
   12340:	8d 30       	cpi	r24, 0x0D	; 13
   12342:	08 f4       	brcc	.+2      	; 0x12346 <FMenuReprint+0x6e>
   12344:	d7 c0       	rjmp	.+430    	; 0x124f4 <FMenuReprint+0x21c>
   12346:	8e 30       	cpi	r24, 0x0E	; 14
   12348:	09 f0       	breq	.+2      	; 0x1234c <FMenuReprint+0x74>
   1234a:	f0 c0       	rjmp	.+480    	; 0x1252c <FMenuReprint+0x254>
   1234c:	eb c0       	rjmp	.+470    	; 0x12524 <FMenuReprint+0x24c>
	 case rtInit:
	      lcd_clear();
   1234e:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
          if (IFType==IT_SLAVE)stReprint=rtFIP;
   12352:	80 91 10 01 	lds	r24, 0x0110
   12356:	81 30       	cpi	r24, 0x01	; 1
   12358:	09 f4       	brne	.+2      	; 0x1235c <FMenuReprint+0x84>
   1235a:	b3 c0       	rjmp	.+358    	; 0x124c2 <FMenuReprint+0x1ea>
		  else
		  if (IFType==IT_STANDALONE)stReprint=rtStandaloneFIP;//rtValidPassword;//rtStandaloneFIP;
   1235c:	82 30       	cpi	r24, 0x02	; 2
   1235e:	09 f0       	breq	.+2      	; 0x12362 <FMenuReprint+0x8a>
   12360:	e5 c0       	rjmp	.+458    	; 0x1252c <FMenuReprint+0x254>
   12362:	04 c0       	rjmp	.+8      	; 0x1236c <FMenuReprint+0x94>
	      break;
     case rtValidPassword:
	      PassResult=FMenuPassword();
   12364:	0e 94 a9 90 	call	0x12152	; 0x12152 <FMenuPassword>
	      if (PassResult==MP_VALID_ADMIN)stReprint=rtStandaloneFIP;
   12368:	84 30       	cpi	r24, 0x04	; 4
   1236a:	11 f4       	brne	.+4      	; 0x12370 <FMenuReprint+0x98>
   1236c:	81 e0       	ldi	r24, 0x01	; 1
   1236e:	0a c0       	rjmp	.+20     	; 0x12384 <FMenuReprint+0xac>
		  else
	      if (PassResult==MP_VALID_SYSTEM)stReprint=rtInvalidPassword;
   12370:	85 30       	cpi	r24, 0x05	; 5
   12372:	11 f0       	breq	.+4      	; 0x12378 <FMenuReprint+0xa0>
          else
	      if (PassResult==MP_INVALID)stReprint=rtInvalidPassword;
   12374:	82 30       	cpi	r24, 0x02	; 2
   12376:	11 f4       	brne	.+4      	; 0x1237c <FMenuReprint+0xa4>
   12378:	83 e0       	ldi	r24, 0x03	; 3
   1237a:	04 c0       	rjmp	.+8      	; 0x12384 <FMenuReprint+0xac>
		  else
	      if (PassResult==MP_CANCEL)stReprint=rtExitReprint;
   1237c:	81 30       	cpi	r24, 0x01	; 1
   1237e:	09 f0       	breq	.+2      	; 0x12382 <FMenuReprint+0xaa>
   12380:	d5 c0       	rjmp	.+426    	; 0x1252c <FMenuReprint+0x254>
   12382:	8e e0       	ldi	r24, 0x0E	; 14
   12384:	80 93 52 03 	sts	0x0352, r24
   12388:	d1 c0       	rjmp	.+418    	; 0x1252c <FMenuReprint+0x254>
	      break;
     case rtInvalidPassword:
          TimDisplay=0;
   1238a:	10 92 a7 01 	sts	0x01A7, r1
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   1238e:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   12390:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   12392:	81 e0       	ldi	r24, 0x01	; 1
   12394:	90 e0       	ldi	r25, 0x00	; 0
   12396:	90 93 d7 01 	sts	0x01D7, r25
   1239a:	80 93 d6 01 	sts	0x01D6, r24
	      if (PassResult==MP_CANCEL)stReprint=rtExitReprint;
	      break;
     case rtInvalidPassword:
          TimDisplay=0;
		  system_beep(1);
		  lcd_printf(3,1,PSTR("Access Denied"));
   1239e:	83 e0       	ldi	r24, 0x03	; 3
   123a0:	61 e0       	ldi	r22, 0x01	; 1
   123a2:	41 e7       	ldi	r20, 0x71	; 113
   123a4:	5b e1       	ldi	r21, 0x1B	; 27
   123a6:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
   123aa:	33 c0       	rjmp	.+102    	; 0x12412 <FMenuReprint+0x13a>
          stReprint=rtTimDisplayInvalid;
	      break;
     case rtTimDisplayInvalid:
	      if (TimDisplay>2)stReprint=rtExitReprint;
   123ac:	80 91 a7 01 	lds	r24, 0x01A7
   123b0:	83 30       	cpi	r24, 0x03	; 3
   123b2:	08 f4       	brcc	.+2      	; 0x123b6 <FMenuReprint+0xde>
   123b4:	bb c0       	rjmp	.+374    	; 0x1252c <FMenuReprint+0x254>
   123b6:	e5 cf       	rjmp	.-54     	; 0x12382 <FMenuReprint+0xaa>
	      break;
     case rtStandaloneFIP:
	      _scr_pump();
   123b8:	0e 94 77 42 	call	0x84ee	; 0x84ee <_scr_pump>
		  stReprint=rtStandaloneInputFIP;
   123bc:	86 e0       	ldi	r24, 0x06	; 6
   123be:	e2 cf       	rjmp	.-60     	; 0x12384 <FMenuReprint+0xac>
	      break;
     case rtStandaloneInputFIP:
		  KeyChar=_key_btn(_key_scan(1));
   123c0:	81 e0       	ldi	r24, 0x01	; 1
   123c2:	0e 94 ab ae 	call	0x15d56	; 0x15d56 <_key_scan>
   123c6:	0e 94 0c ae 	call	0x15c18	; 0x15c18 <_key_btn>
   123ca:	98 2f       	mov	r25, r24
		  if ((KeyChar>='1')&&(KeyChar<='8')){
   123cc:	81 53       	subi	r24, 0x31	; 49
   123ce:	88 30       	cpi	r24, 0x08	; 8
   123d0:	60 f4       	brcc	.+24     	; 0x123ea <FMenuReprint+0x112>
		       ReprintResult=PrintStandalone(KeyChar-'0',True);
   123d2:	8f 5f       	subi	r24, 0xFF	; 255
   123d4:	61 e0       	ldi	r22, 0x01	; 1
   123d6:	0e 94 bb 1f 	call	0x3f76	; 0x3f76 <PrintStandalone>
			   if (ReprintResult==PS_NO_DATA)stReprint=rtDisplayNoTransaction;
   123da:	82 31       	cpi	r24, 0x12	; 18
   123dc:	11 f4       	brne	.+4      	; 0x123e2 <FMenuReprint+0x10a>
   123de:	85 e0       	ldi	r24, 0x05	; 5
   123e0:	d1 cf       	rjmp	.-94     	; 0x12384 <FMenuReprint+0xac>
			   else if (ReprintResult==PS_PRINTED)stReprint=rtExitReprint;
   123e2:	81 31       	cpi	r24, 0x11	; 17
   123e4:	09 f0       	breq	.+2      	; 0x123e8 <FMenuReprint+0x110>
   123e6:	a2 c0       	rjmp	.+324    	; 0x1252c <FMenuReprint+0x254>
   123e8:	cc cf       	rjmp	.-104    	; 0x12382 <FMenuReprint+0xaa>

		  }else if (KeyChar=='*')stReprint=rtExitReprint;
   123ea:	9a 32       	cpi	r25, 0x2A	; 42
   123ec:	09 f0       	breq	.+2      	; 0x123f0 <FMenuReprint+0x118>
   123ee:	9e c0       	rjmp	.+316    	; 0x1252c <FMenuReprint+0x254>
   123f0:	c8 cf       	rjmp	.-112    	; 0x12382 <FMenuReprint+0xaa>

	      break;
     case rtDisplayNoTransaction:
	      lcd_printf(3, 1,PSTR("Tidak Ada Transaksi "));
   123f2:	83 e0       	ldi	r24, 0x03	; 3
   123f4:	61 e0       	ldi	r22, 0x01	; 1
   123f6:	4c e5       	ldi	r20, 0x5C	; 92
   123f8:	5b e1       	ldi	r21, 0x1B	; 27
   123fa:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   123fe:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   12400:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   12402:	81 e0       	ldi	r24, 0x01	; 1
   12404:	90 e0       	ldi	r25, 0x00	; 0
   12406:	90 93 d7 01 	sts	0x01D7, r25
   1240a:	80 93 d6 01 	sts	0x01D6, r24

	      break;
     case rtDisplayNoTransaction:
	      lcd_printf(3, 1,PSTR("Tidak Ada Transaksi "));
		  system_beep(1);
          TimDisplay=0;
   1240e:	10 92 a7 01 	sts	0x01A7, r1
		  stReprint=rtTimDisplayInvalid;
   12412:	84 e0       	ldi	r24, 0x04	; 4
   12414:	b7 cf       	rjmp	.-146    	; 0x12384 <FMenuReprint+0xac>
	      break;
	 case rtFIP:
	      FIPResult=menu_FIP(&FIP_Used,strFIP_ID);
   12416:	80 e5       	ldi	r24, 0x50	; 80
   12418:	93 e0       	ldi	r25, 0x03	; 3
   1241a:	6c e9       	ldi	r22, 0x9C	; 156
   1241c:	79 e0       	ldi	r23, 0x09	; 9
   1241e:	0e 94 96 63 	call	0xc72c	; 0xc72c <menu_FIP>
		  if (FIPResult==FIP_DONE){
   12422:	88 23       	and	r24, r24
   12424:	11 f4       	brne	.+4      	; 0x1242a <FMenuReprint+0x152>
		      stReprint=rtRFID;
   12426:	88 e0       	ldi	r24, 0x08	; 8
   12428:	ad cf       	rjmp	.-166    	; 0x12384 <FMenuReprint+0xac>
			  }
		  else
		  if (FIPResult==FIP_CANCEL)stReprint=rtExitReprint;
   1242a:	82 30       	cpi	r24, 0x02	; 2
   1242c:	09 f0       	breq	.+2      	; 0x12430 <FMenuReprint+0x158>
   1242e:	7e c0       	rjmp	.+252    	; 0x1252c <FMenuReprint+0x254>
   12430:	a8 cf       	rjmp	.-176    	; 0x12382 <FMenuReprint+0xaa>
	      break;
	 case rtRFID:
	      lcd_clear();
   12432:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
		  sprintf_P(lcdteks,PSTR("RePrint FIP:%s "),strFIP_ID);lcd_print(1,1,lcdteks);
   12436:	00 d0       	rcall	.+0      	; 0x12438 <FMenuReprint+0x160>
   12438:	00 d0       	rcall	.+0      	; 0x1243a <FMenuReprint+0x162>
   1243a:	00 d0       	rcall	.+0      	; 0x1243c <FMenuReprint+0x164>
   1243c:	ed b7       	in	r30, 0x3d	; 61
   1243e:	fe b7       	in	r31, 0x3e	; 62
   12440:	31 96       	adiw	r30, 0x01	; 1
   12442:	8e 01       	movw	r16, r28
   12444:	0f 5f       	subi	r16, 0xFF	; 255
   12446:	1f 4f       	sbci	r17, 0xFF	; 255
   12448:	ad b7       	in	r26, 0x3d	; 61
   1244a:	be b7       	in	r27, 0x3e	; 62
   1244c:	12 96       	adiw	r26, 0x02	; 2
   1244e:	1c 93       	st	X, r17
   12450:	0e 93       	st	-X, r16
   12452:	11 97       	sbiw	r26, 0x01	; 1
   12454:	8c e4       	ldi	r24, 0x4C	; 76
   12456:	9b e1       	ldi	r25, 0x1B	; 27
   12458:	93 83       	std	Z+3, r25	; 0x03
   1245a:	82 83       	std	Z+2, r24	; 0x02
   1245c:	8c e9       	ldi	r24, 0x9C	; 156
   1245e:	99 e0       	ldi	r25, 0x09	; 9
   12460:	95 83       	std	Z+5, r25	; 0x05
   12462:	84 83       	std	Z+4, r24	; 0x04
   12464:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
   12468:	8d b7       	in	r24, 0x3d	; 61
   1246a:	9e b7       	in	r25, 0x3e	; 62
   1246c:	06 96       	adiw	r24, 0x06	; 6
   1246e:	0f b6       	in	r0, 0x3f	; 63
   12470:	f8 94       	cli
   12472:	9e bf       	out	0x3e, r25	; 62
   12474:	0f be       	out	0x3f, r0	; 63
   12476:	8d bf       	out	0x3d, r24	; 61
   12478:	81 e0       	ldi	r24, 0x01	; 1
   1247a:	61 e0       	ldi	r22, 0x01	; 1
   1247c:	a8 01       	movw	r20, r16
   1247e:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
		  lcd_printf(2,1,PSTR(  "Tap Supervisor Card"));
   12482:	82 e0       	ldi	r24, 0x02	; 2
   12484:	61 e0       	ldi	r22, 0x01	; 1
   12486:	48 e3       	ldi	r20, 0x38	; 56
   12488:	5b e1       	ldi	r21, 0x1B	; 27
   1248a:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
          lcd_printf(4,1,PSTR(  "[*]Back    [#]Exit"));
   1248e:	84 e0       	ldi	r24, 0x04	; 4
   12490:	61 e0       	ldi	r22, 0x01	; 1
   12492:	45 e2       	ldi	r20, 0x25	; 37
   12494:	5b e1       	ldi	r21, 0x1B	; 27
   12496:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		  IsRFIDDetected=False;
   1249a:	10 92 af 01 	sts	0x01AF, r1
		  stReprint=rtInputRFID;
   1249e:	89 e0       	ldi	r24, 0x09	; 9
   124a0:	71 cf       	rjmp	.-286    	; 0x12384 <FMenuReprint+0xac>
	      break;
	 case rtInputRFID:
	      if (IsRFIDDetected==True){
   124a2:	80 91 af 01 	lds	r24, 0x01AF
   124a6:	81 30       	cpi	r24, 0x01	; 1
   124a8:	29 f4       	brne	.+10     	; 0x124b4 <FMenuReprint+0x1dc>
		      IsRFIDDetected=False;
   124aa:	10 92 af 01 	sts	0x01AF, r1
		      stReprint=rtSendMessage28;
   124ae:	8a e0       	ldi	r24, 0x0A	; 10
   124b0:	80 93 52 03 	sts	0x0352, r24
		  }
	 	  KeyPressed=_key_scan(1);
   124b4:	81 e0       	ldi	r24, 0x01	; 1
   124b6:	0e 94 ab ae 	call	0x15d56	; 0x15d56 <_key_scan>
   124ba:	80 93 51 03 	sts	0x0351, r24
		  if (KeyPressed==_KEY_CANCEL){
   124be:	87 3e       	cpi	r24, 0xE7	; 231
   124c0:	11 f4       	brne	.+4      	; 0x124c6 <FMenuReprint+0x1ee>
		      stReprint=rtFIP;
   124c2:	87 e0       	ldi	r24, 0x07	; 7
   124c4:	5f cf       	rjmp	.-322    	; 0x12384 <FMenuReprint+0xac>
			  }
		  else
		  if (KeyPressed==_KEY_ENTER)stReprint=rtExitReprint;
   124c6:	87 3b       	cpi	r24, 0xB7	; 183
   124c8:	89 f5       	brne	.+98     	; 0x1252c <FMenuReprint+0x254>
   124ca:	5b cf       	rjmp	.-330    	; 0x12382 <FMenuReprint+0xaa>
	      break;
     case rtSendMessage28:
		  sendMessage28();
   124cc:	0e 94 e5 50 	call	0xa1ca	; 0xa1ca <sendMessage28>
		  TimSend=0;
   124d0:	10 92 a9 01 	sts	0x01A9, r1
   124d4:	10 92 a8 01 	sts	0x01A8, r1
		  stReprint=rtWaitReply;
   124d8:	8b e0       	ldi	r24, 0x0B	; 11
   124da:	54 cf       	rjmp	.-344    	; 0x12384 <FMenuReprint+0xac>
		  break;
     case rtWaitReply:
	      if (TimSend>TIM_SEND*3)stReprint=rtNoConnection;
   124dc:	80 91 a8 01 	lds	r24, 0x01A8
   124e0:	90 91 a9 01 	lds	r25, 0x01A9
   124e4:	4f 97       	sbiw	r24, 0x1f	; 31
   124e6:	18 f0       	brcs	.+6      	; 0x124ee <FMenuReprint+0x216>
   124e8:	8c e0       	ldi	r24, 0x0C	; 12
   124ea:	80 93 52 03 	sts	0x0352, r24
	      if (IsMessage99==True){
   124ee:	80 91 b6 01 	lds	r24, 0x01B6
   124f2:	44 cf       	rjmp	.-376    	; 0x1237c <FMenuReprint+0xa4>
		      stReprint=rtExitReprint;
		  }
	      break;
     case rtNoConnection:
	      lcd_clear();
   124f4:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
		  lcd_printf(2,1,PSTR("TCP/IP ERROR "));
   124f8:	82 e0       	ldi	r24, 0x02	; 2
   124fa:	61 e0       	ldi	r22, 0x01	; 1
   124fc:	47 e1       	ldi	r20, 0x17	; 23
   124fe:	5b e1       	ldi	r21, 0x1B	; 27
   12500:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		  lcd_printf(3,1,PSTR("No Connection"));
   12504:	83 e0       	ldi	r24, 0x03	; 3
   12506:	61 e0       	ldi	r22, 0x01	; 1
   12508:	49 e0       	ldi	r20, 0x09	; 9
   1250a:	5b e1       	ldi	r21, 0x1B	; 27
   1250c:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		  TimDisplay=5;
   12510:	85 e0       	ldi	r24, 0x05	; 5
   12512:	80 93 a7 01 	sts	0x01A7, r24
		  stReprint=rtDelayExitReprint;
   12516:	8d e0       	ldi	r24, 0x0D	; 13
   12518:	35 cf       	rjmp	.-406    	; 0x12384 <FMenuReprint+0xac>
	      break;
     case rtDelayExitReprint:
	      if(TimDisplay>=10)stReprint=rtExitReprint;
   1251a:	80 91 a7 01 	lds	r24, 0x01A7
   1251e:	8a 30       	cpi	r24, 0x0A	; 10
   12520:	28 f0       	brcs	.+10     	; 0x1252c <FMenuReprint+0x254>
   12522:	2f cf       	rjmp	.-418    	; 0x12382 <FMenuReprint+0xaa>
	      break;
	 case rtExitReprint:
	      stReprint=rtInit;
   12524:	10 92 52 03 	sts	0x0352, r1
   12528:	81 e0       	ldi	r24, 0x01	; 1
   1252a:	01 c0       	rjmp	.+2      	; 0x1252e <FMenuReprint+0x256>
   1252c:	80 e0       	ldi	r24, 0x00	; 0
		  Result=MENU_DONE;
	      break;
	 }
  return Result;
}
   1252e:	64 96       	adiw	r28, 0x14	; 20
   12530:	0f b6       	in	r0, 0x3f	; 63
   12532:	f8 94       	cli
   12534:	de bf       	out	0x3e, r29	; 62
   12536:	0f be       	out	0x3f, r0	; 63
   12538:	cd bf       	out	0x3d, r28	; 61
   1253a:	cf 91       	pop	r28
   1253c:	df 91       	pop	r29
   1253e:	1f 91       	pop	r17
   12540:	0f 91       	pop	r16
   12542:	08 95       	ret

00012544 <FMenuAdmin>:

char FMenuAdmin(){
static char stMenuAdmin=maInitAdmin;
	 char SubMenu,KeyPressed,KeyChar,Result=MENU_NONE;
     
	 switch(stMenuAdmin){
   12544:	80 91 22 03 	lds	r24, 0x0322
   12548:	83 30       	cpi	r24, 0x03	; 3
   1254a:	09 f4       	brne	.+2      	; 0x1254e <FMenuAdmin+0xa>
   1254c:	66 c0       	rjmp	.+204    	; 0x1261a <FMenuAdmin+0xd6>
   1254e:	84 30       	cpi	r24, 0x04	; 4
   12550:	30 f4       	brcc	.+12     	; 0x1255e <FMenuAdmin+0x1a>
   12552:	81 30       	cpi	r24, 0x01	; 1
   12554:	69 f1       	breq	.+90     	; 0x125b0 <FMenuAdmin+0x6c>
   12556:	82 30       	cpi	r24, 0x02	; 2
   12558:	08 f0       	brcs	.+2      	; 0x1255c <FMenuAdmin+0x18>
   1255a:	4d c0       	rjmp	.+154    	; 0x125f6 <FMenuAdmin+0xb2>
   1255c:	0d c0       	rjmp	.+26     	; 0x12578 <FMenuAdmin+0x34>
   1255e:	85 30       	cpi	r24, 0x05	; 5
   12560:	09 f4       	brne	.+2      	; 0x12564 <FMenuAdmin+0x20>
   12562:	4e c0       	rjmp	.+156    	; 0x12600 <FMenuAdmin+0xbc>
   12564:	85 30       	cpi	r24, 0x05	; 5
   12566:	08 f4       	brcc	.+2      	; 0x1256a <FMenuAdmin+0x26>
   12568:	49 c0       	rjmp	.+146    	; 0x125fc <FMenuAdmin+0xb8>
   1256a:	86 30       	cpi	r24, 0x06	; 6
   1256c:	09 f4       	brne	.+2      	; 0x12570 <FMenuAdmin+0x2c>
   1256e:	51 c0       	rjmp	.+162    	; 0x12612 <FMenuAdmin+0xce>
   12570:	87 30       	cpi	r24, 0x07	; 7
   12572:	09 f0       	breq	.+2      	; 0x12576 <FMenuAdmin+0x32>
   12574:	5a c0       	rjmp	.+180    	; 0x1262a <FMenuAdmin+0xe6>
   12576:	55 c0       	rjmp	.+170    	; 0x12622 <FMenuAdmin+0xde>
	 case maInitAdmin:
		  lcd_clear();
   12578:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
		  lcd_printf(1,1,PSTR("1)RePrint           "));
   1257c:	81 e0       	ldi	r24, 0x01	; 1
   1257e:	61 e0       	ldi	r22, 0x01	; 1
   12580:	44 e1       	ldi	r20, 0x14	; 20
   12582:	56 e1       	ldi	r21, 0x16	; 22
   12584:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		  lcd_printf(2,1,PSTR("2)CloseShift        "));
   12588:	82 e0       	ldi	r24, 0x02	; 2
   1258a:	61 e0       	ldi	r22, 0x01	; 1
   1258c:	4f ef       	ldi	r20, 0xFF	; 255
   1258e:	55 e1       	ldi	r21, 0x15	; 21
   12590:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		  lcd_printf(3,1,PSTR("3)CloseDay          "));		  
   12594:	83 e0       	ldi	r24, 0x03	; 3
   12596:	61 e0       	ldi	r22, 0x01	; 1
   12598:	4a ee       	ldi	r20, 0xEA	; 234
   1259a:	55 e1       	ldi	r21, 0x15	; 21
   1259c:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		  lcd_printf(4,1,PSTR("4)Settings   *)Exit "));
   125a0:	84 e0       	ldi	r24, 0x04	; 4
   125a2:	61 e0       	ldi	r22, 0x01	; 1
   125a4:	45 ed       	ldi	r20, 0xD5	; 213
   125a6:	55 e1       	ldi	r21, 0x15	; 21
   125a8:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
	      stMenuAdmin=maSelectOptions;
   125ac:	81 e0       	ldi	r24, 0x01	; 1
   125ae:	2e c0       	rjmp	.+92     	; 0x1260c <FMenuAdmin+0xc8>
	      break;
	 case maSelectOptions:
          KeyPressed=_key_scan(1);
   125b0:	81 e0       	ldi	r24, 0x01	; 1
   125b2:	0e 94 ab ae 	call	0x15d56	; 0x15d56 <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
   125b6:	0e 94 0c ae 	call	0x15c18	; 0x15c18 <_key_btn>
		  switch (KeyChar){
   125ba:	82 33       	cpi	r24, 0x32	; 50
   125bc:	71 f0       	breq	.+28     	; 0x125da <FMenuAdmin+0x96>
   125be:	83 33       	cpi	r24, 0x33	; 51
   125c0:	28 f4       	brcc	.+10     	; 0x125cc <FMenuAdmin+0x88>
   125c2:	8a 32       	cpi	r24, 0x2A	; 42
   125c4:	11 f1       	breq	.+68     	; 0x1260a <FMenuAdmin+0xc6>
   125c6:	81 33       	cpi	r24, 0x31	; 49
   125c8:	81 f5       	brne	.+96     	; 0x1262a <FMenuAdmin+0xe6>
   125ca:	05 c0       	rjmp	.+10     	; 0x125d6 <FMenuAdmin+0x92>
   125cc:	83 33       	cpi	r24, 0x33	; 51
   125ce:	59 f0       	breq	.+22     	; 0x125e6 <FMenuAdmin+0xa2>
   125d0:	84 33       	cpi	r24, 0x34	; 52
   125d2:	59 f5       	brne	.+86     	; 0x1262a <FMenuAdmin+0xe6>
   125d4:	0e c0       	rjmp	.+28     	; 0x125f2 <FMenuAdmin+0xae>
		  case '1':
		       stMenuAdmin=maMenuReprint;//maMenuAdminConfig;
   125d6:	82 e0       	ldi	r24, 0x02	; 2
   125d8:	19 c0       	rjmp	.+50     	; 0x1260c <FMenuAdmin+0xc8>
		       break;  
		  case '2':
		       if (IFType==IT_STANDALONE)
   125da:	80 91 10 01 	lds	r24, 0x0110
   125de:	82 30       	cpi	r24, 0x02	; 2
   125e0:	e1 f4       	brne	.+56     	; 0x1261a <FMenuAdmin+0xd6>
			       stMenuAdmin=maMenuCloseShift;
   125e2:	84 e0       	ldi	r24, 0x04	; 4
   125e4:	13 c0       	rjmp	.+38     	; 0x1260c <FMenuAdmin+0xc8>
               else stMenuAdmin=maInitAdmin;
		       break;  
		  case '3':
		       if (IFType==IT_STANDALONE)stMenuAdmin=maMenuCloseDay;
   125e6:	80 91 10 01 	lds	r24, 0x0110
   125ea:	82 30       	cpi	r24, 0x02	; 2
   125ec:	b1 f4       	brne	.+44     	; 0x1261a <FMenuAdmin+0xd6>
   125ee:	85 e0       	ldi	r24, 0x05	; 5
   125f0:	0d c0       	rjmp	.+26     	; 0x1260c <FMenuAdmin+0xc8>
               else stMenuAdmin=maInitAdmin;
		       break;  
		  case '4':
		  	   stMenuAdmin=maMenuAdminSettings;
   125f2:	86 e0       	ldi	r24, 0x06	; 6
   125f4:	0b c0       	rjmp	.+22     	; 0x1260c <FMenuAdmin+0xc8>
    		   stMenuAdmin=maExitMenuAdmin;
		       break;  		  
		  }		  
	      break;
     case maMenuReprint:
	      SubMenu=FMenuReprint();
   125f6:	0e 94 6c 91 	call	0x122d8	; 0x122d8 <FMenuReprint>
   125fa:	05 c0       	rjmp	.+10     	; 0x12606 <FMenuAdmin+0xc2>
	 case maMenuAdminConfig://ChangePassword[],RePrint,PumpTest
	      SubMenu=FSubMenuAdmin();
		  if (SubMenu==MENU_DONE)stMenuAdmin=maInitAdmin;
          break;	 
	 case maMenuCloseShift:
	 	  SubMenu=FCloseShift(CONTINUE_SHIFT);
   125fc:	82 e0       	ldi	r24, 0x02	; 2
   125fe:	01 c0       	rjmp	.+2      	; 0x12602 <FMenuAdmin+0xbe>
		  if (SubMenu==MENU_DONE)stMenuAdmin=maExitMenuAdmin;
	      break;
     case maMenuCloseDay://maMenuCloseShift,maMenuCloseDay
	 	  SubMenu=FCloseShift(NEW_SHIFT);
   12600:	81 e0       	ldi	r24, 0x01	; 1
   12602:	0e 94 f2 5e 	call	0xbde4	; 0xbde4 <FCloseShift>
		  if (SubMenu==MENU_DONE)stMenuAdmin=maExitMenuAdmin;
   12606:	81 30       	cpi	r24, 0x01	; 1
   12608:	81 f4       	brne	.+32     	; 0x1262a <FMenuAdmin+0xe6>
   1260a:	87 e0       	ldi	r24, 0x07	; 7
   1260c:	80 93 22 03 	sts	0x0322, r24
   12610:	06 c0       	rjmp	.+12     	; 0x1261e <FMenuAdmin+0xda>
	      break;
     case maMenuAdminSettings:
	      SubMenu=FMenuAdminSettings();
   12612:	0e 94 0b 8e 	call	0x11c16	; 0x11c16 <FMenuAdminSettings>
		  if (SubMenu==MENU_DONE)stMenuAdmin=maInitAdmin;	      
   12616:	81 30       	cpi	r24, 0x01	; 1
   12618:	41 f4       	brne	.+16     	; 0x1262a <FMenuAdmin+0xe6>
   1261a:	10 92 22 03 	sts	0x0322, r1
   1261e:	80 e0       	ldi	r24, 0x00	; 0
   12620:	08 95       	ret
	      break;
     case maExitMenuAdmin:
	      stMenuAdmin=maInitAdmin;	      
   12622:	10 92 22 03 	sts	0x0322, r1
   12626:	81 e0       	ldi	r24, 0x01	; 1
   12628:	08 95       	ret
   1262a:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
          break;	 
	 }
   return Result;
}
   1262c:	08 95       	ret

0001262e <FMenuChangeMOP>:
	      break;
	 }
   return Result;
}

char FMenuChangeMOP(){
   1262e:	af 92       	push	r10
   12630:	bf 92       	push	r11
   12632:	cf 92       	push	r12
   12634:	df 92       	push	r13
   12636:	ef 92       	push	r14
   12638:	ff 92       	push	r15
   1263a:	0f 93       	push	r16
   1263c:	1f 93       	push	r17
   1263e:	df 93       	push	r29
   12640:	cf 93       	push	r28
   12642:	cd b7       	in	r28, 0x3d	; 61
   12644:	de b7       	in	r29, 0x3e	; 62
   12646:	a3 97       	sbiw	r28, 0x23	; 35
   12648:	0f b6       	in	r0, 0x3f	; 63
   1264a:	f8 94       	cli
   1264c:	de bf       	out	0x3e, r29	; 62
   1264e:	0f be       	out	0x3f, r0	; 63
   12650:	cd bf       	out	0x3d, r28	; 61
	   char strBankName[11],strSurcharge[4],Result;
static char BankIdx=0,uiResult;//,Surcharge=0;
     
Result=MENU_NONE; 

	 switch(stChangeMOP){
   12652:	80 91 47 03 	lds	r24, 0x0347
   12656:	e8 2f       	mov	r30, r24
   12658:	f0 e0       	ldi	r31, 0x00	; 0
   1265a:	ee 31       	cpi	r30, 0x1E	; 30
   1265c:	f1 05       	cpc	r31, r1
   1265e:	08 f0       	brcs	.+2      	; 0x12662 <FMenuChangeMOP+0x34>
   12660:	24 c4       	rjmp	.+2120   	; 0x12eaa <FMenuChangeMOP+0x87c>
   12662:	ec 53       	subi	r30, 0x3C	; 60
   12664:	ff 4f       	sbci	r31, 0xFF	; 255
   12666:	ee 0f       	add	r30, r30
   12668:	ff 1f       	adc	r31, r31
   1266a:	05 90       	lpm	r0, Z+
   1266c:	f4 91       	lpm	r31, Z+
   1266e:	e0 2d       	mov	r30, r0
   12670:	09 94       	ijmp
	 case cmInit:
	      MOPType=PAY_NONE;
   12672:	85 e0       	ldi	r24, 0x05	; 5
   12674:	80 93 cf 01 	sts	0x01CF, r24
   12678:	4e c1       	rjmp	.+668    	; 0x12916 <FMenuChangeMOP+0x2e8>
		  stChangeMOP=cmDisplayMOPOption;
	      break;
	 case cmDisplayMOPOption: //12345678901234567890
	      lcd_clear();
   1267a:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
	      lcd_printf(1,1,PSTR("   Select Payment   "));
   1267e:	81 e0       	ldi	r24, 0x01	; 1
   12680:	61 e0       	ldi	r22, 0x01	; 1
   12682:	4b ea       	ldi	r20, 0xAB	; 171
   12684:	59 e1       	ldi	r21, 0x19	; 25
   12686:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
	      lcd_printf(2,1,PSTR("1.Account 3.Voucher "));
   1268a:	82 e0       	ldi	r24, 0x02	; 2
   1268c:	61 e0       	ldi	r22, 0x01	; 1
   1268e:	46 e9       	ldi	r20, 0x96	; 150
   12690:	59 e1       	ldi	r21, 0x19	; 25
   12692:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
	      lcd_printf(3,1,PSTR("2.Bank    4.PumpTest"));
   12696:	83 e0       	ldi	r24, 0x03	; 3
   12698:	61 e0       	ldi	r22, 0x01	; 1
   1269a:	41 e8       	ldi	r20, 0x81	; 129
   1269c:	59 e1       	ldi	r21, 0x19	; 25
   1269e:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
	      lcd_printf(4,1,PSTR("[*]Back             "));
   126a2:	84 e0       	ldi	r24, 0x04	; 4
   126a4:	61 e0       	ldi	r22, 0x01	; 1
   126a6:	4c e6       	ldi	r20, 0x6C	; 108
   126a8:	59 e1       	ldi	r21, 0x19	; 25
   126aa:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
          stChangeMOP=cmInputMOP;		 
   126ae:	82 e0       	ldi	r24, 0x02	; 2
   126b0:	b5 c1       	rjmp	.+874    	; 0x12a1c <FMenuChangeMOP+0x3ee>
		  break;
	 case cmInputMOP:
	      KeyPressed=_key_scan(1);
   126b2:	81 e0       	ldi	r24, 0x01	; 1
   126b4:	0e 94 ab ae 	call	0x15d56	; 0x15d56 <_key_scan>
   126b8:	80 93 42 03 	sts	0x0342, r24
		  KeyChar=_key_btn(KeyPressed);
   126bc:	0e 94 0c ae 	call	0x15c18	; 0x15c18 <_key_btn>
   126c0:	98 2f       	mov	r25, r24
   126c2:	80 93 43 03 	sts	0x0343, r24
		  if ((KeyChar>='1')&&(KeyChar<='4')){
   126c6:	81 53       	subi	r24, 0x31	; 49
   126c8:	84 30       	cpi	r24, 0x04	; 4
   126ca:	f0 f4       	brcc	.+60     	; 0x12708 <FMenuChangeMOP+0xda>
              switch(KeyChar){
   126cc:	92 33       	cpi	r25, 0x32	; 50
   126ce:	61 f0       	breq	.+24     	; 0x126e8 <FMenuChangeMOP+0xba>
   126d0:	93 33       	cpi	r25, 0x33	; 51
   126d2:	18 f4       	brcc	.+6      	; 0x126da <FMenuChangeMOP+0xac>
   126d4:	91 33       	cpi	r25, 0x31	; 49
   126d6:	c1 f4       	brne	.+48     	; 0x12708 <FMenuChangeMOP+0xda>
   126d8:	05 c0       	rjmp	.+10     	; 0x126e4 <FMenuChangeMOP+0xb6>
   126da:	93 33       	cpi	r25, 0x33	; 51
   126dc:	51 f0       	breq	.+20     	; 0x126f2 <FMenuChangeMOP+0xc4>
   126de:	94 33       	cpi	r25, 0x34	; 52
   126e0:	99 f4       	brne	.+38     	; 0x12708 <FMenuChangeMOP+0xda>
   126e2:	0c c0       	rjmp	.+24     	; 0x126fc <FMenuChangeMOP+0xce>
		        case '1':MOPType=PAY_ACCOUNT; stChangeMOP=cmSelectFIP;         break;
   126e4:	81 e0       	ldi	r24, 0x01	; 1
   126e6:	0b c0       	rjmp	.+22     	; 0x126fe <FMenuChangeMOP+0xd0>
		        case '2':MOPType=PAY_BANK;    stChangeMOP=cmSelectBankName;    break;
   126e8:	82 e0       	ldi	r24, 0x02	; 2
   126ea:	80 93 cf 01 	sts	0x01CF, r24
   126ee:	8b e0       	ldi	r24, 0x0B	; 11
   126f0:	09 c0       	rjmp	.+18     	; 0x12704 <FMenuChangeMOP+0xd6>
		        case '3':MOPType=PAY_VOUCHER; stChangeMOP=cmDispInputVoucher;  break;
   126f2:	83 e0       	ldi	r24, 0x03	; 3
   126f4:	80 93 cf 01 	sts	0x01CF, r24
   126f8:	8f e0       	ldi	r24, 0x0F	; 15
   126fa:	04 c0       	rjmp	.+8      	; 0x12704 <FMenuChangeMOP+0xd6>
		        case '4':MOPType=PAY_PUMPTEST;stChangeMOP=cmSelectFIP;         break;
   126fc:	84 e0       	ldi	r24, 0x04	; 4
   126fe:	80 93 cf 01 	sts	0x01CF, r24
   12702:	89 e0       	ldi	r24, 0x09	; 9
   12704:	80 93 47 03 	sts	0x0347, r24
		     }
		  }
		  if (KeyPressed==_KEY_CANCEL) stChangeMOP=cmExitChangeMOP;
   12708:	80 91 42 03 	lds	r24, 0x0342
   1270c:	87 3e       	cpi	r24, 0xE7	; 231
   1270e:	09 f0       	breq	.+2      	; 0x12712 <FMenuChangeMOP+0xe4>
   12710:	cc c3       	rjmp	.+1944   	; 0x12eaa <FMenuChangeMOP+0x87c>
   12712:	c3 c3       	rjmp	.+1926   	; 0x12e9a <FMenuChangeMOP+0x86c>
	      break;
	 case cmDispInputVoucher://Enter Voucher number
          lcd_clear();
   12714:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
		  lcd_printf(1,1,PSTR("Kode Voucher"));
   12718:	81 e0       	ldi	r24, 0x01	; 1
   1271a:	61 e0       	ldi	r22, 0x01	; 1
   1271c:	4f e5       	ldi	r20, 0x5F	; 95
   1271e:	59 e1       	ldi	r21, 0x19	; 25
   12720:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		  lcd_printf(2,1,PSTR("_"));
   12724:	82 e0       	ldi	r24, 0x02	; 2
   12726:	61 e0       	ldi	r22, 0x01	; 1
   12728:	4d e5       	ldi	r20, 0x5D	; 93
   1272a:	59 e1       	ldi	r21, 0x19	; 25
   1272c:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		  lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   12730:	84 e0       	ldi	r24, 0x04	; 4
   12732:	61 e0       	ldi	r22, 0x01	; 1
   12734:	48 e4       	ldi	r20, 0x48	; 72
   12736:	59 e1       	ldi	r21, 0x19	; 25
   12738:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
   1273c:	e7 e1       	ldi	r30, 0x17	; 23
   1273e:	fe e0       	ldi	r31, 0x0E	; 14
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
   12740:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   12742:	8e e0       	ldi	r24, 0x0E	; 14
   12744:	ec 32       	cpi	r30, 0x2C	; 44
   12746:	f8 07       	cpc	r31, r24
   12748:	d9 f7       	brne	.-10     	; 0x12740 <FMenuChangeMOP+0x112>
          lcd_clear();
		  lcd_printf(1,1,PSTR("Kode Voucher"));
		  lcd_printf(2,1,PSTR("_"));
		  lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
		  FillChar(strVoucherNum,sizeof(strVoucherNum),0);
          stChangeMOP=cmInputVoucher;
   1274a:	87 e0       	ldi	r24, 0x07	; 7
   1274c:	80 93 47 03 	sts	0x0347, r24
		  uiResult=USER_NONE;
   12750:	10 92 33 03 	sts	0x0333, r1
   12754:	aa c3       	rjmp	.+1876   	; 0x12eaa <FMenuChangeMOP+0x87c>
	      break;
     case cmInputVoucher:
          uiResult=UserInput(UI_NUMBER_R,2,1,strVoucherNum,0,13);
   12756:	81 e0       	ldi	r24, 0x01	; 1
   12758:	62 e0       	ldi	r22, 0x02	; 2
   1275a:	41 e0       	ldi	r20, 0x01	; 1
   1275c:	27 e1       	ldi	r18, 0x17	; 23
   1275e:	3e e0       	ldi	r19, 0x0E	; 14
   12760:	00 e0       	ldi	r16, 0x00	; 0
   12762:	10 e0       	ldi	r17, 0x00	; 0
   12764:	5d e0       	ldi	r21, 0x0D	; 13
   12766:	e5 2e       	mov	r14, r21
   12768:	0e 94 f0 7b 	call	0xf7e0	; 0xf7e0 <UserInput>
   1276c:	80 93 33 03 	sts	0x0333, r24
	      if (uiResult==USER_OK){
   12770:	83 30       	cpi	r24, 0x03	; 3
   12772:	11 f4       	brne	.+4      	; 0x12778 <FMenuChangeMOP+0x14a>
		     stChangeMOP=cmSelectFIP;
   12774:	89 e0       	ldi	r24, 0x09	; 9
   12776:	52 c1       	rjmp	.+676    	; 0x12a1c <FMenuChangeMOP+0x3ee>
			 }
		  else
	      if (uiResult==USER_CANCEL)stChangeMOP=cmDisplayMOPOption;
   12778:	81 30       	cpi	r24, 0x01	; 1
   1277a:	09 f4       	brne	.+2      	; 0x1277e <FMenuChangeMOP+0x150>
   1277c:	4f c1       	rjmp	.+670    	; 0x12a1c <FMenuChangeMOP+0x3ee>
		  else
		  if (uiResult==USER_ENTRY)lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   1277e:	84 30       	cpi	r24, 0x04	; 4
   12780:	21 f4       	brne	.+8      	; 0x1278a <FMenuChangeMOP+0x15c>
   12782:	61 e0       	ldi	r22, 0x01	; 1
   12784:	43 e3       	ldi	r20, 0x33	; 51
   12786:	59 e1       	ldi	r21, 0x19	; 25
   12788:	31 c1       	rjmp	.+610    	; 0x129ec <FMenuChangeMOP+0x3be>
		  else
		  if (uiResult==USER_NO_DATA)lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   1278a:	85 30       	cpi	r24, 0x05	; 5
   1278c:	09 f0       	breq	.+2      	; 0x12790 <FMenuChangeMOP+0x162>
   1278e:	8d c3       	rjmp	.+1818   	; 0x12eaa <FMenuChangeMOP+0x87c>
   12790:	84 e0       	ldi	r24, 0x04	; 4
   12792:	61 e0       	ldi	r22, 0x01	; 1
   12794:	4e e1       	ldi	r20, 0x1E	; 30
   12796:	59 e1       	ldi	r21, 0x19	; 25
   12798:	29 c1       	rjmp	.+594    	; 0x129ec <FMenuChangeMOP+0x3be>
	      break;
	 case cmSelectFIP:
	      FIPResult=menu_FIP(&FIP_Used,strFIP_ID);
   1279a:	81 e4       	ldi	r24, 0x41	; 65
   1279c:	93 e0       	ldi	r25, 0x03	; 3
   1279e:	6c e9       	ldi	r22, 0x9C	; 156
   127a0:	79 e0       	ldi	r23, 0x09	; 9
   127a2:	0e 94 96 63 	call	0xc72c	; 0xc72c <menu_FIP>
   127a6:	80 93 46 03 	sts	0x0346, r24
		  if (FIPResult==FIP_DONE){
   127aa:	88 23       	and	r24, r24
   127ac:	11 f4       	brne	.+4      	; 0x127b2 <FMenuChangeMOP+0x184>
		      //sprintf_P(strFIP_ID,PSTR("%.2d"),FIP_Used);
		      stChangeMOP=cmFlowFIP;
   127ae:	8e e0       	ldi	r24, 0x0E	; 14
   127b0:	35 c1       	rjmp	.+618    	; 0x12a1c <FMenuChangeMOP+0x3ee>
		  }
		  else
		  if (FIPResult==FIP_CANCEL){
   127b2:	82 30       	cpi	r24, 0x02	; 2
   127b4:	09 f0       	breq	.+2      	; 0x127b8 <FMenuChangeMOP+0x18a>
   127b6:	79 c3       	rjmp	.+1778   	; 0x12eaa <FMenuChangeMOP+0x87c>
		      if (MOPType==PAY_ACCOUNT)stChangeMOP=cmDisplayMOPOption;
   127b8:	80 91 cf 01 	lds	r24, 0x01CF
   127bc:	81 30       	cpi	r24, 0x01	; 1
   127be:	09 f4       	brne	.+2      	; 0x127c2 <FMenuChangeMOP+0x194>
   127c0:	2d c1       	rjmp	.+602    	; 0x12a1c <FMenuChangeMOP+0x3ee>
		      if (MOPType==PAY_BANK)stChangeMOP=cmSelectBankName;
   127c2:	82 30       	cpi	r24, 0x02	; 2
   127c4:	09 f4       	brne	.+2      	; 0x127c8 <FMenuChangeMOP+0x19a>
   127c6:	03 c1       	rjmp	.+518    	; 0x129ce <FMenuChangeMOP+0x3a0>
		      if (MOPType==PAY_VOUCHER)stChangeMOP=cmDispInputVoucher;
   127c8:	83 30       	cpi	r24, 0x03	; 3
   127ca:	11 f4       	brne	.+4      	; 0x127d0 <FMenuChangeMOP+0x1a2>
   127cc:	8f e0       	ldi	r24, 0x0F	; 15
   127ce:	26 c1       	rjmp	.+588    	; 0x12a1c <FMenuChangeMOP+0x3ee>
		      if (MOPType==PAY_PUMPTEST)stChangeMOP=cmDisplayMOPOption;		  
   127d0:	84 30       	cpi	r24, 0x04	; 4
   127d2:	09 f4       	brne	.+2      	; 0x127d6 <FMenuChangeMOP+0x1a8>
   127d4:	a0 c0       	rjmp	.+320    	; 0x12916 <FMenuChangeMOP+0x2e8>
   127d6:	69 c3       	rjmp	.+1746   	; 0x12eaa <FMenuChangeMOP+0x87c>
     case cmSelectFIPInput:
		
	      break;
		  //Load Bank Information
	 case cmSelectBankName:
	      lcd_clear();
   127d8:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
		  lcd_printf(1,1,PSTR("Select Bank"));
   127dc:	81 e0       	ldi	r24, 0x01	; 1
   127de:	61 e0       	ldi	r22, 0x01	; 1
   127e0:	42 e1       	ldi	r20, 0x12	; 18
   127e2:	59 e1       	ldi	r21, 0x19	; 25
   127e4:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		  iLoop=0;
	      for(iLoop=0;iLoop<4;iLoop++){
   127e8:	10 92 36 03 	sts	0x0336, r1
   127ec:	10 92 35 03 	sts	0x0335, r1
   127f0:	8e 01       	movw	r16, r28
   127f2:	0b 5f       	subi	r16, 0xFB	; 251
   127f4:	1f 4f       	sbci	r17, 0xFF	; 255
   127f6:	9b e0       	ldi	r25, 0x0B	; 11
   127f8:	a9 2e       	mov	r10, r25
   127fa:	b1 2c       	mov	r11, r1
			  eeprom_read_block((void*) &strBankName, (const void*) &DefBankName[iLoop], 11);
			  if (strlen(strBankName<=10)){
			     sprintf_P(lcdteks,PSTR("%d.%s"),(iLoop+1),strBankName);
   127fc:	80 e1       	ldi	r24, 0x10	; 16
   127fe:	e8 2e       	mov	r14, r24
   12800:	f1 2c       	mov	r15, r1
   12802:	ec 0e       	add	r14, r28
   12804:	fd 1e       	adc	r15, r29
   12806:	bc e0       	ldi	r27, 0x0C	; 12
   12808:	cb 2e       	mov	r12, r27
   1280a:	b9 e1       	ldi	r27, 0x19	; 25
   1280c:	db 2e       	mov	r13, r27
   1280e:	5d c0       	rjmp	.+186    	; 0x128ca <FMenuChangeMOP+0x29c>
   12810:	8a 9d       	mul	r24, r10
   12812:	b0 01       	movw	r22, r0
   12814:	8b 9d       	mul	r24, r11
   12816:	70 0d       	add	r23, r0
   12818:	9a 9d       	mul	r25, r10
   1281a:	70 0d       	add	r23, r0
   1281c:	11 24       	eor	r1, r1
   1281e:	67 5f       	subi	r22, 0xF7	; 247
   12820:	7e 4f       	sbci	r23, 0xFE	; 254
   12822:	c8 01       	movw	r24, r16
   12824:	4b e0       	ldi	r20, 0x0B	; 11
   12826:	50 e0       	ldi	r21, 0x00	; 0
   12828:	23 ef       	ldi	r18, 0xF3	; 243
   1282a:	32 e1       	ldi	r19, 0x12	; 18
   1282c:	0e 94 1f b4 	call	0x1683e	; 0x1683e <__eerd_block>
	      lcd_clear();
		  lcd_printf(1,1,PSTR("Select Bank"));
		  iLoop=0;
	      for(iLoop=0;iLoop<4;iLoop++){
			  eeprom_read_block((void*) &strBankName, (const void*) &DefBankName[iLoop], 11);
			  if (strlen(strBankName<=10)){
   12830:	e0 e0       	ldi	r30, 0x00	; 0
   12832:	f0 e0       	ldi	r31, 0x00	; 0
   12834:	0b 30       	cpi	r16, 0x0B	; 11
   12836:	11 05       	cpc	r17, r1
   12838:	10 f4       	brcc	.+4      	; 0x1283e <FMenuChangeMOP+0x210>
   1283a:	e1 e0       	ldi	r30, 0x01	; 1
   1283c:	f0 e0       	ldi	r31, 0x00	; 0
   1283e:	80 81       	ld	r24, Z
   12840:	88 23       	and	r24, r24
   12842:	d1 f1       	breq	.+116    	; 0x128b8 <FMenuChangeMOP+0x28a>
			     sprintf_P(lcdteks,PSTR("%d.%s"),(iLoop+1),strBankName);
   12844:	ad b7       	in	r26, 0x3d	; 61
   12846:	be b7       	in	r27, 0x3e	; 62
   12848:	18 97       	sbiw	r26, 0x08	; 8
   1284a:	0f b6       	in	r0, 0x3f	; 63
   1284c:	f8 94       	cli
   1284e:	be bf       	out	0x3e, r27	; 62
   12850:	0f be       	out	0x3f, r0	; 63
   12852:	ad bf       	out	0x3d, r26	; 61
   12854:	ed b7       	in	r30, 0x3d	; 61
   12856:	fe b7       	in	r31, 0x3e	; 62
   12858:	31 96       	adiw	r30, 0x01	; 1
   1285a:	12 96       	adiw	r26, 0x02	; 2
   1285c:	fc 92       	st	X, r15
   1285e:	ee 92       	st	-X, r14
   12860:	11 97       	sbiw	r26, 0x01	; 1
   12862:	d3 82       	std	Z+3, r13	; 0x03
   12864:	c2 82       	std	Z+2, r12	; 0x02
   12866:	80 91 35 03 	lds	r24, 0x0335
   1286a:	90 91 36 03 	lds	r25, 0x0336
   1286e:	01 96       	adiw	r24, 0x01	; 1
   12870:	95 83       	std	Z+5, r25	; 0x05
   12872:	84 83       	std	Z+4, r24	; 0x04
   12874:	17 83       	std	Z+7, r17	; 0x07
   12876:	06 83       	std	Z+6, r16	; 0x06
   12878:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
			     lcd_print((2+(iLoop%2)),(1+((iLoop/2)*12)),lcdteks);
   1287c:	20 91 35 03 	lds	r18, 0x0335
   12880:	30 91 36 03 	lds	r19, 0x0336
   12884:	ed b7       	in	r30, 0x3d	; 61
   12886:	fe b7       	in	r31, 0x3e	; 62
   12888:	38 96       	adiw	r30, 0x08	; 8
   1288a:	0f b6       	in	r0, 0x3f	; 63
   1288c:	f8 94       	cli
   1288e:	fe bf       	out	0x3e, r31	; 62
   12890:	0f be       	out	0x3f, r0	; 63
   12892:	ed bf       	out	0x3d, r30	; 61
   12894:	82 2f       	mov	r24, r18
   12896:	81 70       	andi	r24, 0x01	; 1
   12898:	36 95       	lsr	r19
   1289a:	27 95       	ror	r18
   1289c:	b9 01       	movw	r22, r18
   1289e:	66 0f       	add	r22, r22
   128a0:	77 1f       	adc	r23, r23
   128a2:	62 0f       	add	r22, r18
   128a4:	73 1f       	adc	r23, r19
   128a6:	66 0f       	add	r22, r22
   128a8:	77 1f       	adc	r23, r23
   128aa:	66 0f       	add	r22, r22
   128ac:	77 1f       	adc	r23, r23
   128ae:	6f 5f       	subi	r22, 0xFF	; 255
   128b0:	8e 5f       	subi	r24, 0xFE	; 254
   128b2:	a7 01       	movw	r20, r14
   128b4:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
		  //Load Bank Information
	 case cmSelectBankName:
	      lcd_clear();
		  lcd_printf(1,1,PSTR("Select Bank"));
		  iLoop=0;
	      for(iLoop=0;iLoop<4;iLoop++){
   128b8:	80 91 35 03 	lds	r24, 0x0335
   128bc:	90 91 36 03 	lds	r25, 0x0336
   128c0:	01 96       	adiw	r24, 0x01	; 1
   128c2:	90 93 36 03 	sts	0x0336, r25
   128c6:	80 93 35 03 	sts	0x0335, r24
   128ca:	80 91 35 03 	lds	r24, 0x0335
   128ce:	90 91 36 03 	lds	r25, 0x0336
   128d2:	84 30       	cpi	r24, 0x04	; 4
   128d4:	91 05       	cpc	r25, r1
   128d6:	08 f4       	brcc	.+2      	; 0x128da <FMenuChangeMOP+0x2ac>
   128d8:	9b cf       	rjmp	.-202    	; 0x12810 <FMenuChangeMOP+0x1e2>
			  if (strlen(strBankName<=10)){
			     sprintf_P(lcdteks,PSTR("%d.%s"),(iLoop+1),strBankName);
			     lcd_print((2+(iLoop%2)),(1+((iLoop/2)*12)),lcdteks);
				 }
		  }
	      lcd_printf(4,1,PSTR("[*]Back"));
   128da:	84 e0       	ldi	r24, 0x04	; 4
   128dc:	61 e0       	ldi	r22, 0x01	; 1
   128de:	44 e0       	ldi	r20, 0x04	; 4
   128e0:	59 e1       	ldi	r21, 0x19	; 25
   128e2:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		  stChangeMOP=cmSelectBankNameInput;
   128e6:	8c e0       	ldi	r24, 0x0C	; 12
   128e8:	99 c0       	rjmp	.+306    	; 0x12a1c <FMenuChangeMOP+0x3ee>
	      break;
     case cmSelectBankNameInput:
		  KeyPressed=_key_scan(1);
   128ea:	81 e0       	ldi	r24, 0x01	; 1
   128ec:	0e 94 ab ae 	call	0x15d56	; 0x15d56 <_key_scan>
   128f0:	80 93 42 03 	sts	0x0342, r24
		  KeyChar=_key_btn(KeyPressed);
   128f4:	0e 94 0c ae 	call	0x15c18	; 0x15c18 <_key_btn>
   128f8:	80 93 43 03 	sts	0x0343, r24
          if ((KeyChar>='1')&&(KeyChar<='4')){
   128fc:	81 53       	subi	r24, 0x31	; 49
   128fe:	84 30       	cpi	r24, 0x04	; 4
   12900:	28 f4       	brcc	.+10     	; 0x1290c <FMenuChangeMOP+0x2de>
		      BankIdx=KeyChar-'1';
   12902:	80 93 34 03 	sts	0x0334, r24
			  stChangeMOP=cmSelectFIP;
   12906:	89 e0       	ldi	r24, 0x09	; 9
   12908:	80 93 47 03 	sts	0x0347, r24
		  }
		  if (KeyPressed==_KEY_CANCEL) stChangeMOP=cmDisplayMOPOption;
   1290c:	80 91 42 03 	lds	r24, 0x0342
   12910:	87 3e       	cpi	r24, 0xE7	; 231
   12912:	09 f0       	breq	.+2      	; 0x12916 <FMenuChangeMOP+0x2e8>
   12914:	ca c2       	rjmp	.+1428   	; 0x12eaa <FMenuChangeMOP+0x87c>
   12916:	81 e0       	ldi	r24, 0x01	; 1
   12918:	81 c0       	rjmp	.+258    	; 0x12a1c <FMenuChangeMOP+0x3ee>

	      break;
     case cmDispBankSurcharge:
	      lcd_clear();
   1291a:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
   1291e:	65 e0       	ldi	r22, 0x05	; 5
   12920:	e6 2e       	mov	r14, r22
   12922:	f1 2c       	mov	r15, r1
   12924:	ec 0e       	add	r14, r28
   12926:	fd 1e       	adc	r15, r29
   12928:	60 91 34 03 	lds	r22, 0x0334
   1292c:	8b e0       	ldi	r24, 0x0B	; 11
   1292e:	68 9f       	mul	r22, r24
   12930:	b0 01       	movw	r22, r0
   12932:	11 24       	eor	r1, r1
   12934:	67 5f       	subi	r22, 0xF7	; 247
   12936:	7e 4f       	sbci	r23, 0xFE	; 254
   12938:	c7 01       	movw	r24, r14
   1293a:	4b e0       	ldi	r20, 0x0B	; 11
   1293c:	50 e0       	ldi	r21, 0x00	; 0
   1293e:	23 ef       	ldi	r18, 0xF3	; 243
   12940:	32 e1       	ldi	r19, 0x12	; 18
   12942:	0e 94 1f b4 	call	0x1683e	; 0x1683e <__eerd_block>
		  eeprom_read_block((void*) &strBankName, (const void*) &DefBankName[BankIdx], 11);
		  sprintf_P(lcdteks,PSTR("%s"),strBankName);
   12946:	00 d0       	rcall	.+0      	; 0x12948 <FMenuChangeMOP+0x31a>
   12948:	00 d0       	rcall	.+0      	; 0x1294a <FMenuChangeMOP+0x31c>
   1294a:	00 d0       	rcall	.+0      	; 0x1294c <FMenuChangeMOP+0x31e>
   1294c:	ed b7       	in	r30, 0x3d	; 61
   1294e:	fe b7       	in	r31, 0x3e	; 62
   12950:	31 96       	adiw	r30, 0x01	; 1
   12952:	8e 01       	movw	r16, r28
   12954:	00 5f       	subi	r16, 0xF0	; 240
   12956:	1f 4f       	sbci	r17, 0xFF	; 255
   12958:	ad b7       	in	r26, 0x3d	; 61
   1295a:	be b7       	in	r27, 0x3e	; 62
   1295c:	12 96       	adiw	r26, 0x02	; 2
   1295e:	1c 93       	st	X, r17
   12960:	0e 93       	st	-X, r16
   12962:	11 97       	sbiw	r26, 0x01	; 1
   12964:	81 e0       	ldi	r24, 0x01	; 1
   12966:	99 e1       	ldi	r25, 0x19	; 25
   12968:	93 83       	std	Z+3, r25	; 0x03
   1296a:	82 83       	std	Z+2, r24	; 0x02
   1296c:	f5 82       	std	Z+5, r15	; 0x05
   1296e:	e4 82       	std	Z+4, r14	; 0x04
   12970:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
		  lcd_print(1,1,lcdteks);
   12974:	ed b7       	in	r30, 0x3d	; 61
   12976:	fe b7       	in	r31, 0x3e	; 62
   12978:	36 96       	adiw	r30, 0x06	; 6
   1297a:	0f b6       	in	r0, 0x3f	; 63
   1297c:	f8 94       	cli
   1297e:	fe bf       	out	0x3e, r31	; 62
   12980:	0f be       	out	0x3f, r0	; 63
   12982:	ed bf       	out	0x3d, r30	; 61
   12984:	81 e0       	ldi	r24, 0x01	; 1
   12986:	61 e0       	ldi	r22, 0x01	; 1
   12988:	a8 01       	movw	r20, r16
   1298a:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
		  lcd_printf(2,1,PSTR("Surcharge:   _%"));
   1298e:	82 e0       	ldi	r24, 0x02	; 2
   12990:	61 e0       	ldi	r22, 0x01	; 1
   12992:	41 ef       	ldi	r20, 0xF1	; 241
   12994:	58 e1       	ldi	r21, 0x18	; 24
   12996:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
	      lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   1299a:	84 e0       	ldi	r24, 0x04	; 4
   1299c:	61 e0       	ldi	r22, 0x01	; 1
   1299e:	4c ed       	ldi	r20, 0xDC	; 220
   129a0:	58 e1       	ldi	r21, 0x18	; 24
   129a2:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
          stChangeMOP=cmInputBankSurcharge;
   129a6:	8d e0       	ldi	r24, 0x0D	; 13
   129a8:	39 c0       	rjmp	.+114    	; 0x12a1c <FMenuChangeMOP+0x3ee>
	      break;
	 case cmInputBankSurcharge:
	      uiResult=UserInput(UI_NUMBER_L,2,14,ValueChar,100,3);
   129aa:	82 e0       	ldi	r24, 0x02	; 2
   129ac:	62 e0       	ldi	r22, 0x02	; 2
   129ae:	4e e0       	ldi	r20, 0x0E	; 14
   129b0:	27 e3       	ldi	r18, 0x37	; 55
   129b2:	33 e0       	ldi	r19, 0x03	; 3
   129b4:	04 e6       	ldi	r16, 0x64	; 100
   129b6:	10 e0       	ldi	r17, 0x00	; 0
   129b8:	53 e0       	ldi	r21, 0x03	; 3
   129ba:	e5 2e       	mov	r14, r21
   129bc:	0e 94 f0 7b 	call	0xf7e0	; 0xf7e0 <UserInput>
   129c0:	80 93 33 03 	sts	0x0333, r24
	      if (uiResult==USER_OK)stChangeMOP=cmGenerateData;
   129c4:	83 30       	cpi	r24, 0x03	; 3
   129c6:	09 f4       	brne	.+2      	; 0x129ca <FMenuChangeMOP+0x39c>
   129c8:	cb c0       	rjmp	.+406    	; 0x12b60 <FMenuChangeMOP+0x532>
		  else
	      if (uiResult==USER_CANCEL)stChangeMOP=cmSelectBankName;
   129ca:	81 30       	cpi	r24, 0x01	; 1
   129cc:	11 f4       	brne	.+4      	; 0x129d2 <FMenuChangeMOP+0x3a4>
   129ce:	8b e0       	ldi	r24, 0x0B	; 11
   129d0:	25 c0       	rjmp	.+74     	; 0x12a1c <FMenuChangeMOP+0x3ee>
		  else
		  if (uiResult==USER_ENTRY)lcd_printf(4,1,PSTR("[*]Back     [#]Enter"));
   129d2:	84 30       	cpi	r24, 0x04	; 4
   129d4:	21 f4       	brne	.+8      	; 0x129de <FMenuChangeMOP+0x3b0>
   129d6:	61 e0       	ldi	r22, 0x01	; 1
   129d8:	47 ec       	ldi	r20, 0xC7	; 199
   129da:	58 e1       	ldi	r21, 0x18	; 24
   129dc:	07 c0       	rjmp	.+14     	; 0x129ec <FMenuChangeMOP+0x3be>
		  else
		  if (uiResult==USER_NO_DATA)lcd_printf(4,1,PSTR("[*]Cancel   [#]Enter"));
   129de:	85 30       	cpi	r24, 0x05	; 5
   129e0:	09 f0       	breq	.+2      	; 0x129e4 <FMenuChangeMOP+0x3b6>
   129e2:	63 c2       	rjmp	.+1222   	; 0x12eaa <FMenuChangeMOP+0x87c>
   129e4:	84 e0       	ldi	r24, 0x04	; 4
   129e6:	61 e0       	ldi	r22, 0x01	; 1
   129e8:	42 eb       	ldi	r20, 0xB2	; 178
   129ea:	58 e1       	ldi	r21, 0x18	; 24
   129ec:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
   129f0:	5c c2       	rjmp	.+1208   	; 0x12eaa <FMenuChangeMOP+0x87c>
	      break;
     case cmFlowFIP:
          switch(MOPType){
   129f2:	80 91 cf 01 	lds	r24, 0x01CF
   129f6:	82 30       	cpi	r24, 0x02	; 2
   129f8:	61 f0       	breq	.+24     	; 0x12a12 <FMenuChangeMOP+0x3e4>
   129fa:	83 30       	cpi	r24, 0x03	; 3
   129fc:	20 f4       	brcc	.+8      	; 0x12a06 <FMenuChangeMOP+0x3d8>
   129fe:	81 30       	cpi	r24, 0x01	; 1
   12a00:	09 f0       	breq	.+2      	; 0x12a04 <FMenuChangeMOP+0x3d6>
   12a02:	53 c2       	rjmp	.+1190   	; 0x12eaa <FMenuChangeMOP+0x87c>
   12a04:	0a c0       	rjmp	.+20     	; 0x12a1a <FMenuChangeMOP+0x3ec>
   12a06:	83 30       	cpi	r24, 0x03	; 3
   12a08:	31 f0       	breq	.+12     	; 0x12a16 <FMenuChangeMOP+0x3e8>
   12a0a:	84 30       	cpi	r24, 0x04	; 4
   12a0c:	09 f0       	breq	.+2      	; 0x12a10 <FMenuChangeMOP+0x3e2>
   12a0e:	4d c2       	rjmp	.+1178   	; 0x12eaa <FMenuChangeMOP+0x87c>
   12a10:	04 c0       	rjmp	.+8      	; 0x12a1a <FMenuChangeMOP+0x3ec>
		  case PAY_ACCOUNT: stChangeMOP=cmDispCardTap;       break;
		  case PAY_BANK:    stChangeMOP=cmDispBankSurcharge; break;
   12a12:	81 e1       	ldi	r24, 0x11	; 17
   12a14:	03 c0       	rjmp	.+6      	; 0x12a1c <FMenuChangeMOP+0x3ee>
		  case PAY_VOUCHER: stChangeMOP=cmProsesVoucher;      break;
   12a16:	85 e1       	ldi	r24, 0x15	; 21
   12a18:	01 c0       	rjmp	.+2      	; 0x12a1c <FMenuChangeMOP+0x3ee>
		  case PAY_PUMPTEST:stChangeMOP=cmDispCardTap;       break;
   12a1a:	82 e1       	ldi	r24, 0x12	; 18
   12a1c:	80 93 47 03 	sts	0x0347, r24
   12a20:	44 c2       	rjmp	.+1160   	; 0x12eaa <FMenuChangeMOP+0x87c>
		  }
	      break;
     case cmDispCardTap:
	      lcd_clear();
   12a22:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
	      lcd_printf(1,1,PSTR("Tap Kartu RFID"));
   12a26:	81 e0       	ldi	r24, 0x01	; 1
   12a28:	61 e0       	ldi	r22, 0x01	; 1
   12a2a:	43 ea       	ldi	r20, 0xA3	; 163
   12a2c:	58 e1       	ldi	r21, 0x18	; 24
   12a2e:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		  sprintf_P(lcdteks,PSTR("FIP%s"),strFIP_ID);
   12a32:	00 d0       	rcall	.+0      	; 0x12a34 <FMenuChangeMOP+0x406>
   12a34:	00 d0       	rcall	.+0      	; 0x12a36 <FMenuChangeMOP+0x408>
   12a36:	00 d0       	rcall	.+0      	; 0x12a38 <FMenuChangeMOP+0x40a>
   12a38:	ed b7       	in	r30, 0x3d	; 61
   12a3a:	fe b7       	in	r31, 0x3e	; 62
   12a3c:	31 96       	adiw	r30, 0x01	; 1
   12a3e:	8e 01       	movw	r16, r28
   12a40:	00 5f       	subi	r16, 0xF0	; 240
   12a42:	1f 4f       	sbci	r17, 0xFF	; 255
   12a44:	ad b7       	in	r26, 0x3d	; 61
   12a46:	be b7       	in	r27, 0x3e	; 62
   12a48:	12 96       	adiw	r26, 0x02	; 2
   12a4a:	1c 93       	st	X, r17
   12a4c:	0e 93       	st	-X, r16
   12a4e:	11 97       	sbiw	r26, 0x01	; 1
   12a50:	8d e9       	ldi	r24, 0x9D	; 157
   12a52:	98 e1       	ldi	r25, 0x18	; 24
   12a54:	93 83       	std	Z+3, r25	; 0x03
   12a56:	82 83       	std	Z+2, r24	; 0x02
   12a58:	8c e9       	ldi	r24, 0x9C	; 156
   12a5a:	99 e0       	ldi	r25, 0x09	; 9
   12a5c:	95 83       	std	Z+5, r25	; 0x05
   12a5e:	84 83       	std	Z+4, r24	; 0x04
   12a60:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
		  lcd_print(2,1,lcdteks);
   12a64:	ed b7       	in	r30, 0x3d	; 61
   12a66:	fe b7       	in	r31, 0x3e	; 62
   12a68:	36 96       	adiw	r30, 0x06	; 6
   12a6a:	0f b6       	in	r0, 0x3f	; 63
   12a6c:	f8 94       	cli
   12a6e:	fe bf       	out	0x3e, r31	; 62
   12a70:	0f be       	out	0x3f, r0	; 63
   12a72:	ed bf       	out	0x3d, r30	; 61
   12a74:	82 e0       	ldi	r24, 0x02	; 2
   12a76:	61 e0       	ldi	r22, 0x01	; 1
   12a78:	a8 01       	movw	r20, r16
   12a7a:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
          lcd_printf(4,1,PSTR("[*]Back    [#]Exit"));
   12a7e:	84 e0       	ldi	r24, 0x04	; 4
   12a80:	61 e0       	ldi	r22, 0x01	; 1
   12a82:	4a e8       	ldi	r20, 0x8A	; 138
   12a84:	58 e1       	ldi	r21, 0x18	; 24
   12a86:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		  IsRFIDDetected=False;
   12a8a:	10 92 af 01 	sts	0x01AF, r1
          stChangeMOP=cmRFIDCardInput;
   12a8e:	83 e1       	ldi	r24, 0x13	; 19
   12a90:	c5 cf       	rjmp	.-118    	; 0x12a1c <FMenuChangeMOP+0x3ee>
	      break;
	 case cmRFIDCardInput:
		  KeyPressed=_key_scan(1);
   12a92:	81 e0       	ldi	r24, 0x01	; 1
   12a94:	0e 94 ab ae 	call	0x15d56	; 0x15d56 <_key_scan>
   12a98:	80 93 42 03 	sts	0x0342, r24
		  KeyChar=_key_btn(KeyPressed);
   12a9c:	0e 94 0c ae 	call	0x15c18	; 0x15c18 <_key_btn>
   12aa0:	80 93 43 03 	sts	0x0343, r24
		  if (KeyPressed==_KEY_ENTER){
   12aa4:	80 91 42 03 	lds	r24, 0x0342
   12aa8:	87 3b       	cpi	r24, 0xB7	; 183
   12aaa:	11 f4       	brne	.+4      	; 0x12ab0 <FMenuChangeMOP+0x482>
		      stChangeMOP=cmExitChangeMOP;
   12aac:	8c e1       	ldi	r24, 0x1C	; 28
   12aae:	03 c0       	rjmp	.+6      	; 0x12ab6 <FMenuChangeMOP+0x488>
		  }
		  else
		  if (KeyPressed==_KEY_CANCEL){
   12ab0:	87 3e       	cpi	r24, 0xE7	; 231
   12ab2:	19 f4       	brne	.+6      	; 0x12aba <FMenuChangeMOP+0x48c>
   		      stChangeMOP=cmSelectFIP;
   12ab4:	89 e0       	ldi	r24, 0x09	; 9
   12ab6:	80 93 47 03 	sts	0x0347, r24
			 }
          if (IsRFIDDetected==True){
   12aba:	80 91 af 01 	lds	r24, 0x01AF
   12abe:	81 30       	cpi	r24, 0x01	; 1
   12ac0:	09 f0       	breq	.+2      	; 0x12ac4 <FMenuChangeMOP+0x496>
   12ac2:	f3 c1       	rjmp	.+998    	; 0x12eaa <FMenuChangeMOP+0x87c>
		      IsRFIDDetected=False;
   12ac4:	10 92 af 01 	sts	0x01AF, r1
			   stChangeMOP=cmProsesRFID;
   12ac8:	84 e1       	ldi	r24, 0x14	; 20
   12aca:	a8 cf       	rjmp	.-176    	; 0x12a1c <FMenuChangeMOP+0x3ee>
   12acc:	20 e0       	ldi	r18, 0x00	; 0
   12ace:	30 e0       	ldi	r19, 0x00	; 0
}

void ViewCardID(){//+12345678 -->12345678
     char i;
	 for(i=0;i<8;i++){         //00000000000012345678
		strCardID[i]=strRFID[i];
   12ad0:	f9 01       	movw	r30, r18
   12ad2:	ef 59       	subi	r30, 0x9F	; 159
   12ad4:	f2 4f       	sbci	r31, 0xF2	; 242
   12ad6:	d9 01       	movw	r26, r18
   12ad8:	a4 5d       	subi	r26, 0xD4	; 212
   12ada:	b1 4f       	sbci	r27, 0xF1	; 241
   12adc:	8c 91       	ld	r24, X
   12ade:	80 83       	st	Z, r24
   12ae0:	2f 5f       	subi	r18, 0xFF	; 255
   12ae2:	3f 4f       	sbci	r19, 0xFF	; 255

}

void ViewCardID(){//+12345678 -->12345678
     char i;
	 for(i=0;i<8;i++){         //00000000000012345678
   12ae4:	28 30       	cpi	r18, 0x08	; 8
   12ae6:	31 05       	cpc	r19, r1
   12ae8:	99 f7       	brne	.-26     	; 0x12ad0 <FMenuChangeMOP+0x4a2>
		strCardID[i]=strRFID[i];
	 }strCardID[8]=0;     
   12aea:	10 92 69 0d 	sts	0x0D69, r1
			   stChangeMOP=cmProsesRFID;
			 }
	      break;
     case cmProsesRFID:
	      ViewCardID();
          sprintf_P(lcdteks,PSTR("ID:%s"),strCardID);lcd_print(2,1,lcdteks);
   12aee:	00 d0       	rcall	.+0      	; 0x12af0 <FMenuChangeMOP+0x4c2>
   12af0:	00 d0       	rcall	.+0      	; 0x12af2 <FMenuChangeMOP+0x4c4>
   12af2:	00 d0       	rcall	.+0      	; 0x12af4 <FMenuChangeMOP+0x4c6>
   12af4:	ed b7       	in	r30, 0x3d	; 61
   12af6:	fe b7       	in	r31, 0x3e	; 62
   12af8:	31 96       	adiw	r30, 0x01	; 1
   12afa:	8e 01       	movw	r16, r28
   12afc:	00 5f       	subi	r16, 0xF0	; 240
   12afe:	1f 4f       	sbci	r17, 0xFF	; 255
   12b00:	ad b7       	in	r26, 0x3d	; 61
   12b02:	be b7       	in	r27, 0x3e	; 62
   12b04:	12 96       	adiw	r26, 0x02	; 2
   12b06:	1c 93       	st	X, r17
   12b08:	0e 93       	st	-X, r16
   12b0a:	11 97       	sbiw	r26, 0x01	; 1
   12b0c:	84 e8       	ldi	r24, 0x84	; 132
   12b0e:	98 e1       	ldi	r25, 0x18	; 24
   12b10:	93 83       	std	Z+3, r25	; 0x03
   12b12:	82 83       	std	Z+2, r24	; 0x02
   12b14:	81 e6       	ldi	r24, 0x61	; 97
   12b16:	9d e0       	ldi	r25, 0x0D	; 13
   12b18:	95 83       	std	Z+5, r25	; 0x05
   12b1a:	84 83       	std	Z+4, r24	; 0x04
   12b1c:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
   12b20:	ed b7       	in	r30, 0x3d	; 61
   12b22:	fe b7       	in	r31, 0x3e	; 62
   12b24:	36 96       	adiw	r30, 0x06	; 6
   12b26:	0f b6       	in	r0, 0x3f	; 63
   12b28:	f8 94       	cli
   12b2a:	fe bf       	out	0x3e, r31	; 62
   12b2c:	0f be       	out	0x3f, r0	; 63
   12b2e:	ed bf       	out	0x3d, r30	; 61
   12b30:	82 e0       	ldi	r24, 0x02	; 2
   12b32:	61 e0       	ldi	r22, 0x01	; 1
   12b34:	a8 01       	movw	r20, r16
   12b36:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
          lcd_printf(3,1,PSTR("Proses"));
   12b3a:	83 e0       	ldi	r24, 0x03	; 3
   12b3c:	61 e0       	ldi	r22, 0x01	; 1
   12b3e:	4d e7       	ldi	r20, 0x7D	; 125
   12b40:	58 e1       	ldi	r21, 0x18	; 24
   12b42:	0c c0       	rjmp	.+24     	; 0x12b5c <FMenuChangeMOP+0x52e>
		  stChangeMOP=cmGenerateData;
	      break;
     case cmProsesVoucher:
          lcd_clear();
   12b44:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
          lcd_printf(1,1,PSTR("-MOP Voucher-")); 
   12b48:	81 e0       	ldi	r24, 0x01	; 1
   12b4a:	61 e0       	ldi	r22, 0x01	; 1
   12b4c:	4f e6       	ldi	r20, 0x6F	; 111
   12b4e:	58 e1       	ldi	r21, 0x18	; 24
   12b50:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
          lcd_printf(3,1,PSTR("Proses"));
   12b54:	83 e0       	ldi	r24, 0x03	; 3
   12b56:	61 e0       	ldi	r22, 0x01	; 1
   12b58:	48 e6       	ldi	r20, 0x68	; 104
   12b5a:	58 e1       	ldi	r21, 0x18	; 24
   12b5c:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		  stChangeMOP=cmGenerateData;
   12b60:	86 e1       	ldi	r24, 0x16	; 22
   12b62:	5c cf       	rjmp	.-328    	; 0x12a1c <FMenuChangeMOP+0x3ee>
	      break;
   12b64:	e8 e6       	ldi	r30, 0x68	; 104
   12b66:	fe e0       	ldi	r31, 0x0E	; 14
}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
	     strMemory[i]=data;
   12b68:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   12b6a:	8e e0       	ldi	r24, 0x0E	; 14
   12b6c:	ed 37       	cpi	r30, 0x7D	; 125
   12b6e:	f8 07       	cpc	r31, r24
   12b70:	d9 f7       	brne	.-10     	; 0x12b68 <FMenuChangeMOP+0x53a>
   12b72:	e6 e7       	ldi	r30, 0x76	; 118
   12b74:	fd e0       	ldi	r31, 0x0D	; 13
	     strMemory[i]=data;
   12b76:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   12b78:	9d e0       	ldi	r25, 0x0D	; 13
   12b7a:	eb 38       	cpi	r30, 0x8B	; 139
   12b7c:	f9 07       	cpc	r31, r25
   12b7e:	d9 f7       	brne	.-10     	; 0x12b76 <FMenuChangeMOP+0x548>
   12b80:	e2 e8       	ldi	r30, 0x82	; 130
   12b82:	fa e0       	ldi	r31, 0x0A	; 10
	     strMemory[i]=data;
   12b84:	11 92       	st	Z+, r1

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   12b86:	aa e0       	ldi	r26, 0x0A	; 10
   12b88:	e7 39       	cpi	r30, 0x97	; 151
   12b8a:	fa 07       	cpc	r31, r26
   12b8c:	d9 f7       	brne	.-10     	; 0x12b84 <FMenuChangeMOP+0x556>
   12b8e:	25 e8       	ldi	r18, 0x85	; 133
   12b90:	e2 2e       	mov	r14, r18
   12b92:	25 e0       	ldi	r18, 0x05	; 5
   12b94:	f2 2e       	mov	r15, r18
	     strMemory[i]=data;
   12b96:	f7 01       	movw	r30, r14
   12b98:	11 92       	st	Z+, r1
   12b9a:	7f 01       	movw	r14, r30

}

void FillChar(char *strMemory, unsigned int Length,char data){
     unsigned int i;
	 for (i=0;i<Length;i++){
   12b9c:	fa e9       	ldi	r31, 0x9A	; 154
   12b9e:	ef 16       	cp	r14, r31
   12ba0:	f5 e0       	ldi	r31, 0x05	; 5
   12ba2:	ff 06       	cpc	r15, r31
   12ba4:	c1 f7       	brne	.-16     	; 0x12b96 <FMenuChangeMOP+0x568>
     case cmGenerateData:
	      FillChar(strRef1,sizeof(strRef1),0);
	      FillChar(strRef2,sizeof(strRef2),0);
	      FillChar(strRef3,sizeof(strRef3),0);
	      FillChar(strRef4,sizeof(strRef4),0);
          switch(MOPType){
   12ba6:	80 91 cf 01 	lds	r24, 0x01CF
   12baa:	82 30       	cpi	r24, 0x02	; 2
   12bac:	f1 f0       	breq	.+60     	; 0x12bea <FMenuChangeMOP+0x5bc>
   12bae:	83 30       	cpi	r24, 0x03	; 3
   12bb0:	20 f4       	brcc	.+8      	; 0x12bba <FMenuChangeMOP+0x58c>
   12bb2:	81 30       	cpi	r24, 0x01	; 1
   12bb4:	09 f0       	breq	.+2      	; 0x12bb8 <FMenuChangeMOP+0x58a>
   12bb6:	ad c0       	rjmp	.+346    	; 0x12d12 <FMenuChangeMOP+0x6e4>
   12bb8:	07 c0       	rjmp	.+14     	; 0x12bc8 <FMenuChangeMOP+0x59a>
   12bba:	83 30       	cpi	r24, 0x03	; 3
   12bbc:	09 f4       	brne	.+2      	; 0x12bc0 <FMenuChangeMOP+0x592>
   12bbe:	64 c0       	rjmp	.+200    	; 0x12c88 <FMenuChangeMOP+0x65a>
   12bc0:	84 30       	cpi	r24, 0x04	; 4
   12bc2:	09 f0       	breq	.+2      	; 0x12bc6 <FMenuChangeMOP+0x598>
   12bc4:	a6 c0       	rjmp	.+332    	; 0x12d12 <FMenuChangeMOP+0x6e4>
   12bc6:	75 c0       	rjmp	.+234    	; 0x12cb2 <FMenuChangeMOP+0x684>
		  case PAY_ACCOUNT:
		       sprintf_P(strRef1,PSTR("%s"),strCardID); 
   12bc8:	00 d0       	rcall	.+0      	; 0x12bca <FMenuChangeMOP+0x59c>
   12bca:	00 d0       	rcall	.+0      	; 0x12bcc <FMenuChangeMOP+0x59e>
   12bcc:	00 d0       	rcall	.+0      	; 0x12bce <FMenuChangeMOP+0x5a0>
   12bce:	ed b7       	in	r30, 0x3d	; 61
   12bd0:	fe b7       	in	r31, 0x3e	; 62
   12bd2:	31 96       	adiw	r30, 0x01	; 1
   12bd4:	88 e6       	ldi	r24, 0x68	; 104
   12bd6:	9e e0       	ldi	r25, 0x0E	; 14
   12bd8:	ad b7       	in	r26, 0x3d	; 61
   12bda:	be b7       	in	r27, 0x3e	; 62
   12bdc:	12 96       	adiw	r26, 0x02	; 2
   12bde:	9c 93       	st	X, r25
   12be0:	8e 93       	st	-X, r24
   12be2:	11 97       	sbiw	r26, 0x01	; 1
   12be4:	85 e6       	ldi	r24, 0x65	; 101
   12be6:	98 e1       	ldi	r25, 0x18	; 24
   12be8:	84 c0       	rjmp	.+264    	; 0x12cf2 <FMenuChangeMOP+0x6c4>
   12bea:	8e 01       	movw	r16, r28
   12bec:	0b 5f       	subi	r16, 0xFB	; 251
   12bee:	1f 4f       	sbci	r17, 0xFF	; 255
   12bf0:	60 91 34 03 	lds	r22, 0x0334
   12bf4:	8b e0       	ldi	r24, 0x0B	; 11
   12bf6:	68 9f       	mul	r22, r24
   12bf8:	b0 01       	movw	r22, r0
   12bfa:	11 24       	eor	r1, r1
   12bfc:	67 5f       	subi	r22, 0xF7	; 247
   12bfe:	7e 4f       	sbci	r23, 0xFE	; 254
   12c00:	c8 01       	movw	r24, r16
   12c02:	4b e0       	ldi	r20, 0x0B	; 11
   12c04:	50 e0       	ldi	r21, 0x00	; 0
   12c06:	23 ef       	ldi	r18, 0xF3	; 243
   12c08:	32 e1       	ldi	r19, 0x12	; 18
   12c0a:	0e 94 1f b4 	call	0x1683e	; 0x1683e <__eerd_block>
		       break;
		  case PAY_BANK:
		  	   eeprom_read_block((void*) &strBankName, (const void*) &DefBankName[BankIdx], 11);
		       sprintf_P(lcdteks,PSTR("%s"),strBankName);
   12c0e:	00 d0       	rcall	.+0      	; 0x12c10 <FMenuChangeMOP+0x5e2>
   12c10:	00 d0       	rcall	.+0      	; 0x12c12 <FMenuChangeMOP+0x5e4>
   12c12:	00 d0       	rcall	.+0      	; 0x12c14 <FMenuChangeMOP+0x5e6>
   12c14:	ed b7       	in	r30, 0x3d	; 61
   12c16:	fe b7       	in	r31, 0x3e	; 62
   12c18:	31 96       	adiw	r30, 0x01	; 1
   12c1a:	ce 01       	movw	r24, r28
   12c1c:	40 96       	adiw	r24, 0x10	; 16
   12c1e:	ad b7       	in	r26, 0x3d	; 61
   12c20:	be b7       	in	r27, 0x3e	; 62
   12c22:	12 96       	adiw	r26, 0x02	; 2
   12c24:	9c 93       	st	X, r25
   12c26:	8e 93       	st	-X, r24
   12c28:	11 97       	sbiw	r26, 0x01	; 1
   12c2a:	82 e6       	ldi	r24, 0x62	; 98
   12c2c:	98 e1       	ldi	r25, 0x18	; 24
   12c2e:	93 83       	std	Z+3, r25	; 0x03
   12c30:	82 83       	std	Z+2, r24	; 0x02
   12c32:	15 83       	std	Z+5, r17	; 0x05
   12c34:	04 83       	std	Z+4, r16	; 0x04
   12c36:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
		       sprintf_P(strRef1,PSTR("%s"),strBankName); 
   12c3a:	ed b7       	in	r30, 0x3d	; 61
   12c3c:	fe b7       	in	r31, 0x3e	; 62
   12c3e:	31 96       	adiw	r30, 0x01	; 1
   12c40:	88 e6       	ldi	r24, 0x68	; 104
   12c42:	9e e0       	ldi	r25, 0x0E	; 14
   12c44:	ad b7       	in	r26, 0x3d	; 61
   12c46:	be b7       	in	r27, 0x3e	; 62
   12c48:	12 96       	adiw	r26, 0x02	; 2
   12c4a:	9c 93       	st	X, r25
   12c4c:	8e 93       	st	-X, r24
   12c4e:	11 97       	sbiw	r26, 0x01	; 1
   12c50:	8f e5       	ldi	r24, 0x5F	; 95
   12c52:	98 e1       	ldi	r25, 0x18	; 24
   12c54:	93 83       	std	Z+3, r25	; 0x03
   12c56:	82 83       	std	Z+2, r24	; 0x02
   12c58:	15 83       	std	Z+5, r17	; 0x05
   12c5a:	04 83       	std	Z+4, r16	; 0x04
   12c5c:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
		       sprintf_P(strRef4,PSTR("%s"),strSurcharge); 
   12c60:	ed b7       	in	r30, 0x3d	; 61
   12c62:	fe b7       	in	r31, 0x3e	; 62
   12c64:	31 96       	adiw	r30, 0x01	; 1
   12c66:	8b ee       	ldi	r24, 0xEB	; 235
   12c68:	9f ef       	ldi	r25, 0xFF	; 255
   12c6a:	e8 0e       	add	r14, r24
   12c6c:	f9 1e       	adc	r15, r25
   12c6e:	ad b7       	in	r26, 0x3d	; 61
   12c70:	be b7       	in	r27, 0x3e	; 62
   12c72:	12 96       	adiw	r26, 0x02	; 2
   12c74:	fc 92       	st	X, r15
   12c76:	ee 92       	st	-X, r14
   12c78:	11 97       	sbiw	r26, 0x01	; 1
   12c7a:	8c e5       	ldi	r24, 0x5C	; 92
   12c7c:	98 e1       	ldi	r25, 0x18	; 24
   12c7e:	93 83       	std	Z+3, r25	; 0x03
   12c80:	82 83       	std	Z+2, r24	; 0x02
   12c82:	ce 01       	movw	r24, r28
   12c84:	01 96       	adiw	r24, 0x01	; 1
   12c86:	39 c0       	rjmp	.+114    	; 0x12cfa <FMenuChangeMOP+0x6cc>
		       break;
		  case PAY_VOUCHER://Load data Ref1=Voucher on cmVoucherInput
		  	   sprintf_P(strRef1,PSTR("%s"),strVoucherNum); 
   12c88:	00 d0       	rcall	.+0      	; 0x12c8a <FMenuChangeMOP+0x65c>
   12c8a:	00 d0       	rcall	.+0      	; 0x12c8c <FMenuChangeMOP+0x65e>
   12c8c:	00 d0       	rcall	.+0      	; 0x12c8e <FMenuChangeMOP+0x660>
   12c8e:	ed b7       	in	r30, 0x3d	; 61
   12c90:	fe b7       	in	r31, 0x3e	; 62
   12c92:	31 96       	adiw	r30, 0x01	; 1
   12c94:	88 e6       	ldi	r24, 0x68	; 104
   12c96:	9e e0       	ldi	r25, 0x0E	; 14
   12c98:	ad b7       	in	r26, 0x3d	; 61
   12c9a:	be b7       	in	r27, 0x3e	; 62
   12c9c:	12 96       	adiw	r26, 0x02	; 2
   12c9e:	9c 93       	st	X, r25
   12ca0:	8e 93       	st	-X, r24
   12ca2:	11 97       	sbiw	r26, 0x01	; 1
   12ca4:	89 e5       	ldi	r24, 0x59	; 89
   12ca6:	98 e1       	ldi	r25, 0x18	; 24
   12ca8:	93 83       	std	Z+3, r25	; 0x03
   12caa:	82 83       	std	Z+2, r24	; 0x02
   12cac:	87 e1       	ldi	r24, 0x17	; 23
   12cae:	9e e0       	ldi	r25, 0x0E	; 14
   12cb0:	24 c0       	rjmp	.+72     	; 0x12cfa <FMenuChangeMOP+0x6cc>
		       break;
		  case PAY_PUMPTEST:
		  	   sprintf_P(strRef1,PSTR("PUMP TEST")); 
   12cb2:	00 d0       	rcall	.+0      	; 0x12cb4 <FMenuChangeMOP+0x686>
   12cb4:	00 d0       	rcall	.+0      	; 0x12cb6 <FMenuChangeMOP+0x688>
   12cb6:	88 e6       	ldi	r24, 0x68	; 104
   12cb8:	9e e0       	ldi	r25, 0x0E	; 14
   12cba:	ad b7       	in	r26, 0x3d	; 61
   12cbc:	be b7       	in	r27, 0x3e	; 62
   12cbe:	12 96       	adiw	r26, 0x02	; 2
   12cc0:	9c 93       	st	X, r25
   12cc2:	8e 93       	st	-X, r24
   12cc4:	11 97       	sbiw	r26, 0x01	; 1
   12cc6:	8f e4       	ldi	r24, 0x4F	; 79
   12cc8:	98 e1       	ldi	r25, 0x18	; 24
   12cca:	14 96       	adiw	r26, 0x04	; 4
   12ccc:	9c 93       	st	X, r25
   12cce:	8e 93       	st	-X, r24
   12cd0:	13 97       	sbiw	r26, 0x03	; 3
   12cd2:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
		  	   sprintf_P(strRef2,PSTR("%s"),strCardID); 	       
   12cd6:	00 d0       	rcall	.+0      	; 0x12cd8 <FMenuChangeMOP+0x6aa>
   12cd8:	ed b7       	in	r30, 0x3d	; 61
   12cda:	fe b7       	in	r31, 0x3e	; 62
   12cdc:	31 96       	adiw	r30, 0x01	; 1
   12cde:	86 e7       	ldi	r24, 0x76	; 118
   12ce0:	9d e0       	ldi	r25, 0x0D	; 13
   12ce2:	ad b7       	in	r26, 0x3d	; 61
   12ce4:	be b7       	in	r27, 0x3e	; 62
   12ce6:	12 96       	adiw	r26, 0x02	; 2
   12ce8:	9c 93       	st	X, r25
   12cea:	8e 93       	st	-X, r24
   12cec:	11 97       	sbiw	r26, 0x01	; 1
   12cee:	8c e4       	ldi	r24, 0x4C	; 76
   12cf0:	98 e1       	ldi	r25, 0x18	; 24
   12cf2:	93 83       	std	Z+3, r25	; 0x03
   12cf4:	82 83       	std	Z+2, r24	; 0x02
   12cf6:	81 e6       	ldi	r24, 0x61	; 97
   12cf8:	9d e0       	ldi	r25, 0x0D	; 13
   12cfa:	95 83       	std	Z+5, r25	; 0x05
   12cfc:	84 83       	std	Z+4, r24	; 0x04
   12cfe:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
   12d02:	ed b7       	in	r30, 0x3d	; 61
   12d04:	fe b7       	in	r31, 0x3e	; 62
   12d06:	36 96       	adiw	r30, 0x06	; 6
   12d08:	0f b6       	in	r0, 0x3f	; 63
   12d0a:	f8 94       	cli
   12d0c:	fe bf       	out	0x3e, r31	; 62
   12d0e:	0f be       	out	0x3f, r0	; 63
   12d10:	ed bf       	out	0x3d, r30	; 61
		}
     else {
	    sprintf_P(StrResult,PSTR("%d"),Val);
	 }
	 */
     sprintf_P(StrResult,PSTR("%.2d"),Val);
   12d12:	00 d0       	rcall	.+0      	; 0x12d14 <FMenuChangeMOP+0x6e6>
   12d14:	00 d0       	rcall	.+0      	; 0x12d16 <FMenuChangeMOP+0x6e8>
   12d16:	00 d0       	rcall	.+0      	; 0x12d18 <FMenuChangeMOP+0x6ea>
   12d18:	ed b7       	in	r30, 0x3d	; 61
   12d1a:	fe b7       	in	r31, 0x3e	; 62
   12d1c:	31 96       	adiw	r30, 0x01	; 1
   12d1e:	83 e3       	ldi	r24, 0x33	; 51
   12d20:	99 e0       	ldi	r25, 0x09	; 9
   12d22:	ad b7       	in	r26, 0x3d	; 61
   12d24:	be b7       	in	r27, 0x3e	; 62
   12d26:	12 96       	adiw	r26, 0x02	; 2
   12d28:	9c 93       	st	X, r25
   12d2a:	8e 93       	st	-X, r24
   12d2c:	11 97       	sbiw	r26, 0x01	; 1
   12d2e:	86 e5       	ldi	r24, 0x56	; 86
   12d30:	9d e0       	ldi	r25, 0x0D	; 13
   12d32:	93 83       	std	Z+3, r25	; 0x03
   12d34:	82 83       	std	Z+2, r24	; 0x02
   12d36:	80 91 cf 01 	lds	r24, 0x01CF
   12d3a:	84 83       	std	Z+4, r24	; 0x04
   12d3c:	15 82       	std	Z+5, r1	; 0x05
   12d3e:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
		  	   sprintf_P(strRef1,PSTR("PUMP TEST")); 
		  	   sprintf_P(strRef2,PSTR("%s"),strCardID); 	       
		       break;
		  }
		  leadingZero(MOPType,strPaymentType);
		  AddSpaceLead(strRef1,20);
   12d42:	ed b7       	in	r30, 0x3d	; 61
   12d44:	fe b7       	in	r31, 0x3e	; 62
   12d46:	36 96       	adiw	r30, 0x06	; 6
   12d48:	0f b6       	in	r0, 0x3f	; 63
   12d4a:	f8 94       	cli
   12d4c:	fe bf       	out	0x3e, r31	; 62
   12d4e:	0f be       	out	0x3f, r0	; 63
   12d50:	ed bf       	out	0x3d, r30	; 61
   12d52:	88 e6       	ldi	r24, 0x68	; 104
   12d54:	9e e0       	ldi	r25, 0x0E	; 14
   12d56:	64 e1       	ldi	r22, 0x14	; 20
   12d58:	0e 94 71 2a 	call	0x54e2	; 0x54e2 <AddSpaceLead>
		  AddSpaceLead(strRef2,20);
   12d5c:	86 e7       	ldi	r24, 0x76	; 118
   12d5e:	9d e0       	ldi	r25, 0x0D	; 13
   12d60:	64 e1       	ldi	r22, 0x14	; 20
   12d62:	0e 94 71 2a 	call	0x54e2	; 0x54e2 <AddSpaceLead>
		  AddSpaceLead(strRef3,20);
   12d66:	82 e8       	ldi	r24, 0x82	; 130
   12d68:	9a e0       	ldi	r25, 0x0A	; 10
   12d6a:	64 e1       	ldi	r22, 0x14	; 20
   12d6c:	0e 94 71 2a 	call	0x54e2	; 0x54e2 <AddSpaceLead>
		  AddSpaceLead(strRef4,20);
   12d70:	85 e8       	ldi	r24, 0x85	; 133
   12d72:	95 e0       	ldi	r25, 0x05	; 5
   12d74:	64 e1       	ldi	r22, 0x14	; 20
   12d76:	0e 94 71 2a 	call	0x54e2	; 0x54e2 <AddSpaceLead>
		  iWait=0;
   12d7a:	10 92 44 03 	sts	0x0344, r1
		  IsMessage09=False;
   12d7e:	10 92 ba 01 	sts	0x01BA, r1
		  stChangeMOP=cmSendMessage32;	      
   12d82:	87 e1       	ldi	r24, 0x17	; 23
   12d84:	4b ce       	rjmp	.-874    	; 0x12a1c <FMenuChangeMOP+0x3ee>
	      break;
     case cmSendMessage32://SendMessage32
	      sendMessage32();
   12d86:	0e 94 0a 50 	call	0xa014	; 0xa014 <sendMessage32>
		  iLoop=0;
   12d8a:	10 92 36 03 	sts	0x0336, r1
   12d8e:	10 92 35 03 	sts	0x0335, r1
		  iPos=0;
   12d92:	10 92 45 03 	sts	0x0345, r1
		  lcd_printf(3,1,PSTR("Please Wait"));
   12d96:	83 e0       	ldi	r24, 0x03	; 3
   12d98:	61 e0       	ldi	r22, 0x01	; 1
   12d9a:	40 e4       	ldi	r20, 0x40	; 64
   12d9c:	58 e1       	ldi	r21, 0x18	; 24
   12d9e:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		  stChangeMOP=cmWaitReplyMessage;	      
   12da2:	88 e1       	ldi	r24, 0x18	; 24
   12da4:	3b ce       	rjmp	.-906    	; 0x12a1c <FMenuChangeMOP+0x3ee>
	      break;
     case cmWaitReplyMessage:
          iLoop++;
   12da6:	80 91 35 03 	lds	r24, 0x0335
   12daa:	90 91 36 03 	lds	r25, 0x0336
   12dae:	01 96       	adiw	r24, 0x01	; 1
   12db0:	90 93 36 03 	sts	0x0336, r25
   12db4:	80 93 35 03 	sts	0x0335, r24
		  if ((iLoop%MSG_WAIT_TIMOUT)==0){
   12db8:	68 e9       	ldi	r22, 0x98	; 152
   12dba:	7a e3       	ldi	r23, 0x3A	; 58
   12dbc:	0e 94 38 b7 	call	0x16e70	; 0x16e70 <__udivmodhi4>
   12dc0:	89 2b       	or	r24, r25
   12dc2:	19 f5       	brne	.+70     	; 0x12e0a <FMenuChangeMOP+0x7dc>
			 if (iPos<5){
   12dc4:	60 91 45 03 	lds	r22, 0x0345
   12dc8:	65 30       	cpi	r22, 0x05	; 5
   12dca:	68 f4       	brcc	.+26     	; 0x12de6 <FMenuChangeMOP+0x7b8>
				 lcd_xy(3,(13+iPos));_lcd('.');
   12dcc:	63 5f       	subi	r22, 0xF3	; 243
   12dce:	83 e0       	ldi	r24, 0x03	; 3
   12dd0:	0e 94 f1 ac 	call	0x159e2	; 0x159e2 <lcd_xy>
   12dd4:	8e e2       	ldi	r24, 0x2E	; 46
   12dd6:	0e 94 cb ac 	call	0x15996	; 0x15996 <_lcd>
				 iPos++;
   12dda:	80 91 45 03 	lds	r24, 0x0345
   12dde:	8f 5f       	subi	r24, 0xFF	; 255
   12de0:	80 93 45 03 	sts	0x0345, r24
   12de4:	12 c0       	rjmp	.+36     	; 0x12e0a <FMenuChangeMOP+0x7dc>
				}
			 else{
				 iPos=0;
   12de6:	10 92 45 03 	sts	0x0345, r1
				 lcd_printf(3,(13+iPos),PSTR("       "));
   12dea:	83 e0       	ldi	r24, 0x03	; 3
   12dec:	6d e0       	ldi	r22, 0x0D	; 13
   12dee:	48 e3       	ldi	r20, 0x38	; 56
   12df0:	58 e1       	ldi	r21, 0x18	; 24
   12df2:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
				 //Resend Message32
				 if (iWait<5)stChangeMOP=cmSendMessage32;
   12df6:	90 91 44 03 	lds	r25, 0x0344
   12dfa:	95 30       	cpi	r25, 0x05	; 5
   12dfc:	18 f4       	brcc	.+6      	; 0x12e04 <FMenuChangeMOP+0x7d6>
   12dfe:	87 e1       	ldi	r24, 0x17	; 23
   12e00:	80 93 47 03 	sts	0x0347, r24
				iWait++;
   12e04:	9f 5f       	subi	r25, 0xFF	; 255
   12e06:	90 93 44 03 	sts	0x0344, r25
				}
		  }
		  if (iWait>5)stChangeMOP=cmNoReply;
   12e0a:	80 91 44 03 	lds	r24, 0x0344
   12e0e:	86 30       	cpi	r24, 0x06	; 6
   12e10:	18 f0       	brcs	.+6      	; 0x12e18 <FMenuChangeMOP+0x7ea>
   12e12:	8a e1       	ldi	r24, 0x1A	; 26
   12e14:	80 93 47 03 	sts	0x0347, r24
		  if (IsMessage09==True)stChangeMOP=cmDisplayFreeMessage;
   12e18:	80 91 ba 01 	lds	r24, 0x01BA
   12e1c:	81 30       	cpi	r24, 0x01	; 1
   12e1e:	19 f4       	brne	.+6      	; 0x12e26 <FMenuChangeMOP+0x7f8>
   12e20:	89 e1       	ldi	r24, 0x19	; 25
   12e22:	80 93 47 03 	sts	0x0347, r24
		  if (IsMessage99==True)stChangeMOP=cmFinishChangeMOP;
   12e26:	80 91 b6 01 	lds	r24, 0x01B6
   12e2a:	81 30       	cpi	r24, 0x01	; 1
   12e2c:	f1 f5       	brne	.+124    	; 0x12eaa <FMenuChangeMOP+0x87c>
   12e2e:	37 c0       	rjmp	.+110    	; 0x12e9e <FMenuChangeMOP+0x870>
		  break;
     case cmDisplayFreeMessage:
	      IsMessage09=False;
   12e30:	10 92 ba 01 	sts	0x01BA, r1
	      msgResult=procMessage09();
   12e34:	0e 94 56 17 	call	0x2eac	; 0x2eac <procMessage09>
		  lcd_clear();
   12e38:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
		  lcd_print(1,1,strFreeMessageLine1);
   12e3c:	81 e0       	ldi	r24, 0x01	; 1
   12e3e:	61 e0       	ldi	r22, 0x01	; 1
   12e40:	47 e9       	ldi	r20, 0x97	; 151
   12e42:	5a e0       	ldi	r21, 0x0A	; 10
   12e44:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
		  lcd_print(2,1,strFreeMessageLine2);
   12e48:	82 e0       	ldi	r24, 0x02	; 2
   12e4a:	61 e0       	ldi	r22, 0x01	; 1
   12e4c:	46 e8       	ldi	r20, 0x86	; 134
   12e4e:	59 e0       	ldi	r21, 0x09	; 9
   12e50:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
		  lcd_print(3,1,strFreeMessageLine3);
   12e54:	83 e0       	ldi	r24, 0x03	; 3
   12e56:	61 e0       	ldi	r22, 0x01	; 1
   12e58:	41 e2       	ldi	r20, 0x21	; 33
   12e5a:	5a e0       	ldi	r21, 0x0A	; 10
   12e5c:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
		  lcd_print(4,1,strFreeMessageLine4);
   12e60:	84 e0       	ldi	r24, 0x04	; 4
   12e62:	61 e0       	ldi	r22, 0x01	; 1
   12e64:	41 eb       	ldi	r20, 0xB1	; 177
   12e66:	5d e0       	ldi	r21, 0x0D	; 13
   12e68:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
   12e6c:	0e c0       	rjmp	.+28     	; 0x12e8a <FMenuChangeMOP+0x85c>
		  TimDisplay=0;
          stChangeMOP=cmDelayMOP;
	      break;
     case cmNoReply:
	      lcd_clear();
   12e6e:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
		  lcd_printf(2,1,PSTR("No Reply    "));
   12e72:	82 e0       	ldi	r24, 0x02	; 2
   12e74:	61 e0       	ldi	r22, 0x01	; 1
   12e76:	4b e2       	ldi	r20, 0x2B	; 43
   12e78:	58 e1       	ldi	r21, 0x18	; 24
   12e7a:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
	      lcd_printf(3,1,PSTR("TCP/IP Error"));
   12e7e:	83 e0       	ldi	r24, 0x03	; 3
   12e80:	61 e0       	ldi	r22, 0x01	; 1
   12e82:	4e e1       	ldi	r20, 0x1E	; 30
   12e84:	58 e1       	ldi	r21, 0x18	; 24
   12e86:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		  TimDisplay=0;
   12e8a:	10 92 a7 01 	sts	0x01A7, r1
          stChangeMOP=cmDelayMOP;
   12e8e:	8b e1       	ldi	r24, 0x1B	; 27
   12e90:	c5 cd       	rjmp	.-1142   	; 0x12a1c <FMenuChangeMOP+0x3ee>
	      break;
     case cmDelayMOP:
	      if (TimDisplay>9)stChangeMOP=cmExitChangeMOP;
   12e92:	80 91 a7 01 	lds	r24, 0x01A7
   12e96:	8a 30       	cpi	r24, 0x0A	; 10
   12e98:	40 f0       	brcs	.+16     	; 0x12eaa <FMenuChangeMOP+0x87c>
   12e9a:	8c e1       	ldi	r24, 0x1C	; 28
   12e9c:	bf cd       	rjmp	.-1154   	; 0x12a1c <FMenuChangeMOP+0x3ee>
	      break;
     case cmExitChangeMOP:
	      stChangeMOP=cmFinishChangeMOP;
   12e9e:	8d e1       	ldi	r24, 0x1D	; 29
   12ea0:	bd cd       	rjmp	.-1158   	; 0x12a1c <FMenuChangeMOP+0x3ee>
	      break;
     case cmFinishChangeMOP:
	      stChangeMOP=cmInit;
   12ea2:	10 92 47 03 	sts	0x0347, r1
   12ea6:	81 e0       	ldi	r24, 0x01	; 1
   12ea8:	01 c0       	rjmp	.+2      	; 0x12eac <FMenuChangeMOP+0x87e>
   12eaa:	80 e0       	ldi	r24, 0x00	; 0
		  Result=MENU_DONE;
	      break;
	 }
  return Result;
}
   12eac:	a3 96       	adiw	r28, 0x23	; 35
   12eae:	0f b6       	in	r0, 0x3f	; 63
   12eb0:	f8 94       	cli
   12eb2:	de bf       	out	0x3e, r29	; 62
   12eb4:	0f be       	out	0x3f, r0	; 63
   12eb6:	cd bf       	out	0x3d, r28	; 61
   12eb8:	cf 91       	pop	r28
   12eba:	df 91       	pop	r29
   12ebc:	1f 91       	pop	r17
   12ebe:	0f 91       	pop	r16
   12ec0:	ff 90       	pop	r15
   12ec2:	ef 90       	pop	r14
   12ec4:	df 90       	pop	r13
   12ec6:	cf 90       	pop	r12
   12ec8:	bf 90       	pop	r11
   12eca:	af 90       	pop	r10
   12ecc:	08 95       	ret

00012ece <SetBaudRate>:
	 //Spooling HFCx 0000
	 cmdPrint=0b00010000|(1<<PRN_PAPER_CUT);
	 IsFreePrinting=True;
}

void SetBaudRate(char ComAddr,char brMap){//Com1..Com4
   12ece:	28 2f       	mov	r18, r24
   12ed0:	96 2f       	mov	r25, r22
unsigned int brValue=9600;
char brMessage=0;

     if ((ComAddr>=1)&&(ComAddr<=2)){
   12ed2:	81 50       	subi	r24, 0x01	; 1
   12ed4:	82 30       	cpi	r24, 0x02	; 2
   12ed6:	b8 f4       	brcc	.+46     	; 0x12f06 <SetBaudRate+0x38>
	 }
}

int GetBaudrate(char brSetting){
int Result=0;
     switch(brSetting){
   12ed8:	62 30       	cpi	r22, 0x02	; 2
   12eda:	59 f0       	breq	.+22     	; 0x12ef2 <SetBaudRate+0x24>
   12edc:	62 30       	cpi	r22, 0x02	; 2
   12ede:	18 f0       	brcs	.+6      	; 0x12ee6 <SetBaudRate+0x18>
   12ee0:	63 30       	cpi	r22, 0x03	; 3
   12ee2:	21 f4       	brne	.+8      	; 0x12eec <SetBaudRate+0x1e>
   12ee4:	09 c0       	rjmp	.+18     	; 0x12ef8 <SetBaudRate+0x2a>
   12ee6:	40 e8       	ldi	r20, 0x80	; 128
   12ee8:	55 e2       	ldi	r21, 0x25	; 37
   12eea:	08 c0       	rjmp	.+16     	; 0x12efc <SetBaudRate+0x2e>
   12eec:	40 e0       	ldi	r20, 0x00	; 0
   12eee:	50 e0       	ldi	r21, 0x00	; 0
   12ef0:	05 c0       	rjmp	.+10     	; 0x12efc <SetBaudRate+0x2e>
   12ef2:	40 e0       	ldi	r20, 0x00	; 0
   12ef4:	5b e4       	ldi	r21, 0x4B	; 75
   12ef6:	02 c0       	rjmp	.+4      	; 0x12efc <SetBaudRate+0x2e>
   12ef8:	4b e9       	ldi	r20, 0x9B	; 155
   12efa:	56 e1       	ldi	r21, 0x16	; 22
unsigned int brValue=9600;
char brMessage=0;

     if ((ComAddr>=1)&&(ComAddr<=2)){
	     brValue=GetBaudrate(brMap);
	      _uart_init((ComAddr-1),brValue);
   12efc:	60 e0       	ldi	r22, 0x00	; 0
   12efe:	70 e0       	ldi	r23, 0x00	; 0
   12f00:	0e 94 67 b2 	call	0x164ce	; 0x164ce <_uart_init>
   12f04:	08 95       	ret
	 }else
     if ((ComAddr>=3)&&(ComAddr<=4)){
   12f06:	82 2f       	mov	r24, r18
   12f08:	83 50       	subi	r24, 0x03	; 3
   12f0a:	82 30       	cpi	r24, 0x02	; 2
   12f0c:	a8 f4       	brcc	.+42     	; 0x12f38 <SetBaudRate+0x6a>
	     //[COM][Baud]
		 brMessage=((ComAddr<<4)|(0x0F&brMap));
   12f0e:	9f 70       	andi	r25, 0x0F	; 15
   12f10:	62 2f       	mov	r22, r18
   12f12:	62 95       	swap	r22
   12f14:	60 7f       	andi	r22, 0xF0	; 240
   12f16:	69 2b       	or	r22, r25
		 if (iSequencePooling>0)SendPoolingCommand(SC_BAUDRATE,brMessage);
   12f18:	80 91 93 01 	lds	r24, 0x0193
   12f1c:	88 23       	and	r24, r24
   12f1e:	49 f0       	breq	.+18     	; 0x12f32 <SetBaudRate+0x64>
		 }		 
	 }
}

void SendPoolingCommand(char plCmd,char plMsg){
	 PoolCmd=plCmd;
   12f20:	86 e0       	ldi	r24, 0x06	; 6
   12f22:	80 93 8a 07 	sts	0x078A, r24
	 PoolMsg=plMsg;
   12f26:	60 93 ae 0d 	sts	0x0DAE, r22
     IsControlPooling=True;
   12f2a:	81 e0       	ldi	r24, 0x01	; 1
   12f2c:	80 93 97 01 	sts	0x0197, r24
   12f30:	08 95       	ret
	 }else
     if ((ComAddr>=3)&&(ComAddr<=4)){
	     //[COM][Baud]
		 brMessage=((ComAddr<<4)|(0x0F&brMap));
		 if (iSequencePooling>0)SendPoolingCommand(SC_BAUDRATE,brMessage);
		 else SendSlaveCommand(SC_BAUDRATE,brMessage);
   12f32:	86 e0       	ldi	r24, 0x06	; 6
   12f34:	0e 94 83 72 	call	0xe506	; 0xe506 <SendSlaveCommand>
   12f38:	08 95       	ret

00012f3a <FSettingSystem>:
	      break;
	 }
     return Result;
}

char FSettingSystem(){
   12f3a:	af 92       	push	r10
   12f3c:	bf 92       	push	r11
   12f3e:	cf 92       	push	r12
   12f40:	df 92       	push	r13
   12f42:	ef 92       	push	r14
   12f44:	ff 92       	push	r15
   12f46:	0f 93       	push	r16
   12f48:	1f 93       	push	r17
   12f4a:	df 93       	push	r29
   12f4c:	cf 93       	push	r28
   12f4e:	cd b7       	in	r28, 0x3d	; 61
   12f50:	de b7       	in	r29, 0x3e	; 62
   12f52:	64 97       	sbiw	r28, 0x14	; 20
   12f54:	0f b6       	in	r0, 0x3f	; 63
   12f56:	f8 94       	cli
   12f58:	de bf       	out	0x3e, r29	; 62
   12f5a:	0f be       	out	0x3f, r0	; 63
   12f5c:	cd bf       	out	0x3d, r28	; 61
       char SubMenu,Result=MENU_NONE;
	   char HGMode;
       char lcdteks[20];
	   int bValue;

     switch(stSettingSytem){
   12f5e:	80 91 e0 02 	lds	r24, 0x02E0
   12f62:	82 30       	cpi	r24, 0x02	; 2
   12f64:	09 f4       	brne	.+2      	; 0x12f68 <FSettingSystem+0x2e>
   12f66:	cf c0       	rjmp	.+414    	; 0x13106 <FSettingSystem+0x1cc>
   12f68:	83 30       	cpi	r24, 0x03	; 3
   12f6a:	30 f4       	brcc	.+12     	; 0x12f78 <FSettingSystem+0x3e>
   12f6c:	88 23       	and	r24, r24
   12f6e:	71 f0       	breq	.+28     	; 0x12f8c <FSettingSystem+0x52>
   12f70:	81 30       	cpi	r24, 0x01	; 1
   12f72:	09 f0       	breq	.+2      	; 0x12f76 <FSettingSystem+0x3c>
   12f74:	6f c1       	rjmp	.+734    	; 0x13254 <FSettingSystem+0x31a>
   12f76:	7f c0       	rjmp	.+254    	; 0x13076 <FSettingSystem+0x13c>
   12f78:	84 30       	cpi	r24, 0x04	; 4
   12f7a:	09 f4       	brne	.+2      	; 0x12f7e <FSettingSystem+0x44>
   12f7c:	60 c1       	rjmp	.+704    	; 0x1323e <FSettingSystem+0x304>
   12f7e:	84 30       	cpi	r24, 0x04	; 4
   12f80:	08 f4       	brcc	.+2      	; 0x12f84 <FSettingSystem+0x4a>
   12f82:	2b c1       	rjmp	.+598    	; 0x131da <FSettingSystem+0x2a0>
   12f84:	85 30       	cpi	r24, 0x05	; 5
   12f86:	09 f0       	breq	.+2      	; 0x12f8a <FSettingSystem+0x50>
   12f88:	65 c1       	rjmp	.+714    	; 0x13254 <FSettingSystem+0x31a>
   12f8a:	60 c1       	rjmp	.+704    	; 0x1324c <FSettingSystem+0x312>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   12f8c:	e1 99       	sbic	0x1c, 1	; 28
   12f8e:	fe cf       	rjmp	.-4      	; 0x12f8c <FSettingSystem+0x52>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   12f90:	86 e3       	ldi	r24, 0x36	; 54
   12f92:	91 e0       	ldi	r25, 0x01	; 1
   12f94:	9f bb       	out	0x1f, r25	; 31
   12f96:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   12f98:	e0 9a       	sbi	0x1c, 0	; 28
   12f9a:	2d b3       	in	r18, 0x1d	; 29
	 case ssInitSettingSystem:
	      IFType=eeprom_read_byte(&DefInitIFT);
   12f9c:	20 93 10 01 	sts	0x0110, r18
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   12fa0:	e1 99       	sbic	0x1c, 1	; 28
   12fa2:	fe cf       	rjmp	.-4      	; 0x12fa0 <FSettingSystem+0x66>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   12fa4:	82 ec       	ldi	r24, 0xC2	; 194
   12fa6:	93 e0       	ldi	r25, 0x03	; 3
   12fa8:	9f bb       	out	0x1f, r25	; 31
   12faa:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   12fac:	e0 9a       	sbi	0x1c, 0	; 28
   12fae:	1d b3       	in	r17, 0x1d	; 29
		  HGMode=eeprom_read_byte(&DefHGMode);

	      if (IFType==IT_NONE)sprintf_P(lcdteks,PSTR("1.Mode:None"));
   12fb0:	22 23       	and	r18, r18
   12fb2:	69 f4       	brne	.+26     	; 0x12fce <FSettingSystem+0x94>
   12fb4:	00 d0       	rcall	.+0      	; 0x12fb6 <FSettingSystem+0x7c>
   12fb6:	00 d0       	rcall	.+0      	; 0x12fb8 <FSettingSystem+0x7e>
   12fb8:	ce 01       	movw	r24, r28
   12fba:	01 96       	adiw	r24, 0x01	; 1
   12fbc:	ad b7       	in	r26, 0x3d	; 61
   12fbe:	be b7       	in	r27, 0x3e	; 62
   12fc0:	12 96       	adiw	r26, 0x02	; 2
   12fc2:	9c 93       	st	X, r25
   12fc4:	8e 93       	st	-X, r24
   12fc6:	11 97       	sbiw	r26, 0x01	; 1
   12fc8:	8d e2       	ldi	r24, 0x2D	; 45
   12fca:	9e e0       	ldi	r25, 0x0E	; 14
   12fcc:	1d c0       	rjmp	.+58     	; 0x13008 <FSettingSystem+0xce>
		  else
	      if (IFType==IT_SLAVE)sprintf_P(lcdteks,PSTR("1.Mode:Slave"));
   12fce:	21 30       	cpi	r18, 0x01	; 1
   12fd0:	69 f4       	brne	.+26     	; 0x12fec <FSettingSystem+0xb2>
   12fd2:	00 d0       	rcall	.+0      	; 0x12fd4 <FSettingSystem+0x9a>
   12fd4:	00 d0       	rcall	.+0      	; 0x12fd6 <FSettingSystem+0x9c>
   12fd6:	ce 01       	movw	r24, r28
   12fd8:	01 96       	adiw	r24, 0x01	; 1
   12fda:	ed b7       	in	r30, 0x3d	; 61
   12fdc:	fe b7       	in	r31, 0x3e	; 62
   12fde:	92 83       	std	Z+2, r25	; 0x02
   12fe0:	81 83       	std	Z+1, r24	; 0x01
   12fe2:	80 e2       	ldi	r24, 0x20	; 32
   12fe4:	9e e0       	ldi	r25, 0x0E	; 14
   12fe6:	94 83       	std	Z+4, r25	; 0x04
   12fe8:	83 83       	std	Z+3, r24	; 0x03
   12fea:	12 c0       	rjmp	.+36     	; 0x13010 <FSettingSystem+0xd6>
		  else
	      if (IFType==IT_STANDALONE)sprintf_P(lcdteks,PSTR("1.Mode:Standalone"));
   12fec:	22 30       	cpi	r18, 0x02	; 2
   12fee:	b1 f4       	brne	.+44     	; 0x1301c <FSettingSystem+0xe2>
   12ff0:	00 d0       	rcall	.+0      	; 0x12ff2 <FSettingSystem+0xb8>
   12ff2:	00 d0       	rcall	.+0      	; 0x12ff4 <FSettingSystem+0xba>
   12ff4:	ce 01       	movw	r24, r28
   12ff6:	01 96       	adiw	r24, 0x01	; 1
   12ff8:	ad b7       	in	r26, 0x3d	; 61
   12ffa:	be b7       	in	r27, 0x3e	; 62
   12ffc:	12 96       	adiw	r26, 0x02	; 2
   12ffe:	9c 93       	st	X, r25
   13000:	8e 93       	st	-X, r24
   13002:	11 97       	sbiw	r26, 0x01	; 1
   13004:	8e e0       	ldi	r24, 0x0E	; 14
   13006:	9e e0       	ldi	r25, 0x0E	; 14
   13008:	14 96       	adiw	r26, 0x04	; 4
   1300a:	9c 93       	st	X, r25
   1300c:	8e 93       	st	-X, r24
   1300e:	13 97       	sbiw	r26, 0x03	; 3
   13010:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
   13014:	0f 90       	pop	r0
   13016:	0f 90       	pop	r0
   13018:	0f 90       	pop	r0
   1301a:	0f 90       	pop	r0

	      lcd_clear();
   1301c:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
		  lcd_print(1,1,lcdteks);
   13020:	81 e0       	ldi	r24, 0x01	; 1
   13022:	61 e0       	ldi	r22, 0x01	; 1
   13024:	ae 01       	movw	r20, r28
   13026:	4f 5f       	subi	r20, 0xFF	; 255
   13028:	5f 4f       	sbci	r21, 0xFF	; 255
   1302a:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
		  lcd_printf(2,1,PSTR("2.Baudrate"));
   1302e:	82 e0       	ldi	r24, 0x02	; 2
   13030:	61 e0       	ldi	r22, 0x01	; 1
   13032:	43 e0       	ldi	r20, 0x03	; 3
   13034:	5e e0       	ldi	r21, 0x0E	; 14
   13036:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>

		  if (HGMode==HM_TTL)lcd_printf(3,1,PSTR("3.COM3:TTL"));
   1303a:	11 23       	and	r17, r17
   1303c:	29 f4       	brne	.+10     	; 0x13048 <FSettingSystem+0x10e>
   1303e:	83 e0       	ldi	r24, 0x03	; 3
   13040:	61 e0       	ldi	r22, 0x01	; 1
   13042:	48 ef       	ldi	r20, 0xF8	; 248
   13044:	5d e0       	ldi	r21, 0x0D	; 13
   13046:	0d c0       	rjmp	.+26     	; 0x13062 <FSettingSystem+0x128>
		  else
		  if (HGMode==HM_232)lcd_printf(3,1,PSTR("3.COM3:232"));
   13048:	11 30       	cpi	r17, 0x01	; 1
   1304a:	29 f4       	brne	.+10     	; 0x13056 <FSettingSystem+0x11c>
   1304c:	83 e0       	ldi	r24, 0x03	; 3
   1304e:	61 e0       	ldi	r22, 0x01	; 1
   13050:	4d ee       	ldi	r20, 0xED	; 237
   13052:	5d e0       	ldi	r21, 0x0D	; 13
   13054:	06 c0       	rjmp	.+12     	; 0x13062 <FSettingSystem+0x128>
		  else
		  if (HGMode==HM_485)lcd_printf(3,1,PSTR("3.COM3:485"));		  
   13056:	12 30       	cpi	r17, 0x02	; 2
   13058:	31 f4       	brne	.+12     	; 0x13066 <FSettingSystem+0x12c>
   1305a:	83 e0       	ldi	r24, 0x03	; 3
   1305c:	61 e0       	ldi	r22, 0x01	; 1
   1305e:	42 ee       	ldi	r20, 0xE2	; 226
   13060:	5d e0       	ldi	r21, 0x0D	; 13
   13062:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		  lcd_printf(4,1,PSTR("[*]Back      "));
   13066:	84 e0       	ldi	r24, 0x04	; 4
   13068:	61 e0       	ldi	r22, 0x01	; 1
   1306a:	44 ed       	ldi	r20, 0xD4	; 212
   1306c:	5d e0       	ldi	r21, 0x0D	; 13
   1306e:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		  stSettingSytem=ssMenuSelect;
   13072:	81 e0       	ldi	r24, 0x01	; 1
   13074:	e1 c0       	rjmp	.+450    	; 0x13238 <FSettingSystem+0x2fe>
	      break;
     case ssMenuSelect:
          KeyPressed=_key_scan(1);
   13076:	81 e0       	ldi	r24, 0x01	; 1
   13078:	0e 94 ab ae 	call	0x15d56	; 0x15d56 <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
   1307c:	0e 94 0c ae 	call	0x15c18	; 0x15c18 <_key_btn>
		  if (KeyChar=='1'){
   13080:	81 33       	cpi	r24, 0x31	; 49
   13082:	c1 f4       	brne	.+48     	; 0x130b4 <FSettingSystem+0x17a>
		      IFType=((IFType+1)%3);
   13084:	80 91 10 01 	lds	r24, 0x0110
   13088:	90 e0       	ldi	r25, 0x00	; 0
   1308a:	01 96       	adiw	r24, 0x01	; 1
   1308c:	63 e0       	ldi	r22, 0x03	; 3
   1308e:	70 e0       	ldi	r23, 0x00	; 0
   13090:	0e 94 4c b7 	call	0x16e98	; 0x16e98 <__divmodhi4>
   13094:	80 93 10 01 	sts	0x0110, r24
			  SendSlaveCommand(IFType,DispenserBrand);
   13098:	60 91 61 01 	lds	r22, 0x0161
   1309c:	0e 94 83 72 	call	0xe506	; 0xe506 <SendSlaveCommand>
			  eeprom_write_byte(&DefInitIFT,IFType);
   130a0:	20 91 10 01 	lds	r18, 0x0110
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   130a4:	e1 99       	sbic	0x1c, 1	; 28
   130a6:	fe cf       	rjmp	.-4      	; 0x130a4 <FSettingSystem+0x16a>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   130a8:	86 e3       	ldi	r24, 0x36	; 54
   130aa:	91 e0       	ldi	r25, 0x01	; 1
   130ac:	9f bb       	out	0x1f, r25	; 31
   130ae:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
   130b0:	2d bb       	out	0x1d, r18	; 29
   130b2:	1f c0       	rjmp	.+62     	; 0x130f2 <FSettingSystem+0x1b8>
			  stSettingSytem=ssInitSettingSystem;
		  }
		  else
		  if (KeyChar=='2'){
   130b4:	82 33       	cpi	r24, 0x32	; 50
   130b6:	09 f4       	brne	.+2      	; 0x130ba <FSettingSystem+0x180>
   130b8:	ba c0       	rjmp	.+372    	; 0x1322e <FSettingSystem+0x2f4>
		      stSettingSytem=ssComSettings;
		  }
		  else
		  if (KeyChar=='3'){
   130ba:	83 33       	cpi	r24, 0x33	; 51
   130bc:	01 f5       	brne	.+64     	; 0x130fe <FSettingSystem+0x1c4>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   130be:	e1 99       	sbic	0x1c, 1	; 28
   130c0:	fe cf       	rjmp	.-4      	; 0x130be <FSettingSystem+0x184>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   130c2:	e2 ec       	ldi	r30, 0xC2	; 194
   130c4:	ee 2e       	mov	r14, r30
   130c6:	e3 e0       	ldi	r30, 0x03	; 3
   130c8:	fe 2e       	mov	r15, r30
   130ca:	ff ba       	out	0x1f, r15	; 31
   130cc:	ee ba       	out	0x1e, r14	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   130ce:	e0 9a       	sbi	0x1c, 0	; 28
   130d0:	8d b3       	in	r24, 0x1d	; 29
		      HGMode=eeprom_read_byte(&DefHGMode);
		      HGMode=((HGMode+1)%3);
   130d2:	90 e0       	ldi	r25, 0x00	; 0
   130d4:	01 96       	adiw	r24, 0x01	; 1
   130d6:	63 e0       	ldi	r22, 0x03	; 3
   130d8:	70 e0       	ldi	r23, 0x00	; 0
   130da:	0e 94 4c b7 	call	0x16e98	; 0x16e98 <__divmodhi4>
   130de:	18 2f       	mov	r17, r24
			  SendSlaveCommand(SC_HGM_MODE,HGMode);
   130e0:	81 e2       	ldi	r24, 0x21	; 33
   130e2:	61 2f       	mov	r22, r17
   130e4:	0e 94 83 72 	call	0xe506	; 0xe506 <SendSlaveCommand>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   130e8:	e1 99       	sbic	0x1c, 1	; 28
   130ea:	fe cf       	rjmp	.-4      	; 0x130e8 <FSettingSystem+0x1ae>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   130ec:	ff ba       	out	0x1f, r15	; 31
   130ee:	ee ba       	out	0x1e, r14	; 30
#endif
    EEDR = __value;
   130f0:	1d bb       	out	0x1d, r17	; 29

    __asm__ __volatile__ (
   130f2:	0f b6       	in	r0, 0x3f	; 63
   130f4:	f8 94       	cli
   130f6:	e2 9a       	sbi	0x1c, 2	; 28
   130f8:	e1 9a       	sbi	0x1c, 1	; 28
   130fa:	0f be       	out	0x3f, r0	; 63
   130fc:	a4 c0       	rjmp	.+328    	; 0x13246 <FSettingSystem+0x30c>
			  eeprom_write_byte(&DefHGMode,HGMode);
			  stSettingSytem=ssInitSettingSystem;
		  }
		  //else
		  if (KeyChar=='*'){
   130fe:	8a 32       	cpi	r24, 0x2A	; 42
   13100:	09 f4       	brne	.+2      	; 0x13104 <FSettingSystem+0x1ca>
   13102:	99 c0       	rjmp	.+306    	; 0x13236 <FSettingSystem+0x2fc>
   13104:	a7 c0       	rjmp	.+334    	; 0x13254 <FSettingSystem+0x31a>
		      stSettingSytem=ssExitSystemSettings;
		  }		  
		  break;
	 case ssComSettings:
	      lcd_clear();
   13106:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
		  lcd_printf(1,1,PSTR("     -Baudrate-     "));
   1310a:	81 e0       	ldi	r24, 0x01	; 1
   1310c:	61 e0       	ldi	r22, 0x01	; 1
   1310e:	4f eb       	ldi	r20, 0xBF	; 191
   13110:	5d e0       	ldi	r21, 0x0D	; 13
   13112:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
   13116:	01 e0       	ldi	r16, 0x01	; 1
   13118:	10 e0       	ldi	r17, 0x00	; 0

		  for (i=0;i<4;i++){
		       bValue=GetBaudrate(eeprom_read_byte(&DefBaudrate[i]));
			   if (bValue==5787)bValue=12213;
		       sprintf_P(lcdteks,PSTR("COM%d:%d"),i+1,bValue);
   1311a:	6e 01       	movw	r12, r28
   1311c:	08 94       	sec
   1311e:	c1 1c       	adc	r12, r1
   13120:	d1 1c       	adc	r13, r1
   13122:	76 eb       	ldi	r23, 0xB6	; 182
   13124:	a7 2e       	mov	r10, r23
   13126:	7d e0       	ldi	r23, 0x0D	; 13
   13128:	b7 2e       	mov	r11, r23
			   lcd_print((2+(i%2)),1+(i/2*11),lcdteks);
   1312a:	6b e0       	ldi	r22, 0x0B	; 11
   1312c:	e6 2e       	mov	r14, r22
		      stSettingSytem=ssExitSystemSettings;
		  }		  
		  break;
	 case ssComSettings:
	      lcd_clear();
		  lcd_printf(1,1,PSTR("     -Baudrate-     "));
   1312e:	f0 2e       	mov	r15, r16
   13130:	fa 94       	dec	r15
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   13132:	e1 99       	sbic	0x1c, 1	; 28
   13134:	fe cf       	rjmp	.-4      	; 0x13132 <FSettingSystem+0x1f8>
   13136:	c8 01       	movw	r24, r16
   13138:	81 5c       	subi	r24, 0xC1	; 193
   1313a:	9e 4f       	sbci	r25, 0xFE	; 254
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   1313c:	9f bb       	out	0x1f, r25	; 31
   1313e:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   13140:	e0 9a       	sbi	0x1c, 0	; 28
   13142:	8d b3       	in	r24, 0x1d	; 29
	 }
}

int GetBaudrate(char brSetting){
int Result=0;
     switch(brSetting){
   13144:	82 30       	cpi	r24, 0x02	; 2
   13146:	69 f0       	breq	.+26     	; 0x13162 <FSettingSystem+0x228>
   13148:	82 30       	cpi	r24, 0x02	; 2
   1314a:	28 f0       	brcs	.+10     	; 0x13156 <FSettingSystem+0x21c>
   1314c:	83 30       	cpi	r24, 0x03	; 3
   1314e:	31 f4       	brne	.+12     	; 0x1315c <FSettingSystem+0x222>
   13150:	85 eb       	ldi	r24, 0xB5	; 181
   13152:	9f e2       	ldi	r25, 0x2F	; 47
   13154:	08 c0       	rjmp	.+16     	; 0x13166 <FSettingSystem+0x22c>
   13156:	80 e8       	ldi	r24, 0x80	; 128
   13158:	95 e2       	ldi	r25, 0x25	; 37
   1315a:	05 c0       	rjmp	.+10     	; 0x13166 <FSettingSystem+0x22c>
   1315c:	80 e0       	ldi	r24, 0x00	; 0
   1315e:	90 e0       	ldi	r25, 0x00	; 0
   13160:	02 c0       	rjmp	.+4      	; 0x13166 <FSettingSystem+0x22c>
   13162:	80 e0       	ldi	r24, 0x00	; 0
   13164:	9b e4       	ldi	r25, 0x4B	; 75
		  lcd_printf(1,1,PSTR("     -Baudrate-     "));

		  for (i=0;i<4;i++){
		       bValue=GetBaudrate(eeprom_read_byte(&DefBaudrate[i]));
			   if (bValue==5787)bValue=12213;
		       sprintf_P(lcdteks,PSTR("COM%d:%d"),i+1,bValue);
   13166:	ed b7       	in	r30, 0x3d	; 61
   13168:	fe b7       	in	r31, 0x3e	; 62
   1316a:	38 97       	sbiw	r30, 0x08	; 8
   1316c:	0f b6       	in	r0, 0x3f	; 63
   1316e:	f8 94       	cli
   13170:	fe bf       	out	0x3e, r31	; 62
   13172:	0f be       	out	0x3f, r0	; 63
   13174:	ed bf       	out	0x3d, r30	; 61
   13176:	31 96       	adiw	r30, 0x01	; 1
   13178:	ad b7       	in	r26, 0x3d	; 61
   1317a:	be b7       	in	r27, 0x3e	; 62
   1317c:	12 96       	adiw	r26, 0x02	; 2
   1317e:	dc 92       	st	X, r13
   13180:	ce 92       	st	-X, r12
   13182:	11 97       	sbiw	r26, 0x01	; 1
   13184:	b3 82       	std	Z+3, r11	; 0x03
   13186:	a2 82       	std	Z+2, r10	; 0x02
   13188:	15 83       	std	Z+5, r17	; 0x05
   1318a:	04 83       	std	Z+4, r16	; 0x04
   1318c:	97 83       	std	Z+7, r25	; 0x07
   1318e:	86 83       	std	Z+6, r24	; 0x06
   13190:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
			   lcd_print((2+(i%2)),1+(i/2*11),lcdteks);
   13194:	ed b7       	in	r30, 0x3d	; 61
   13196:	fe b7       	in	r31, 0x3e	; 62
   13198:	38 96       	adiw	r30, 0x08	; 8
   1319a:	0f b6       	in	r0, 0x3f	; 63
   1319c:	f8 94       	cli
   1319e:	fe bf       	out	0x3e, r31	; 62
   131a0:	0f be       	out	0x3f, r0	; 63
   131a2:	ed bf       	out	0x3d, r30	; 61
   131a4:	6f 2d       	mov	r22, r15
   131a6:	66 95       	lsr	r22
   131a8:	6e 9d       	mul	r22, r14
   131aa:	b0 01       	movw	r22, r0
   131ac:	11 24       	eor	r1, r1
   131ae:	6f 5f       	subi	r22, 0xFF	; 255
   131b0:	f1 e0       	ldi	r31, 0x01	; 1
   131b2:	ff 22       	and	r15, r31
   131b4:	8f 2d       	mov	r24, r15
   131b6:	8e 5f       	subi	r24, 0xFE	; 254
   131b8:	a6 01       	movw	r20, r12
   131ba:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
   131be:	0f 5f       	subi	r16, 0xFF	; 255
   131c0:	1f 4f       	sbci	r17, 0xFF	; 255
		  break;
	 case ssComSettings:
	      lcd_clear();
		  lcd_printf(1,1,PSTR("     -Baudrate-     "));

		  for (i=0;i<4;i++){
   131c2:	05 30       	cpi	r16, 0x05	; 5
   131c4:	11 05       	cpc	r17, r1
   131c6:	09 f0       	breq	.+2      	; 0x131ca <FSettingSystem+0x290>
   131c8:	b2 cf       	rjmp	.-156    	; 0x1312e <FSettingSystem+0x1f4>
		       bValue=GetBaudrate(eeprom_read_byte(&DefBaudrate[i]));
			   if (bValue==5787)bValue=12213;
		       sprintf_P(lcdteks,PSTR("COM%d:%d"),i+1,bValue);
			   lcd_print((2+(i%2)),1+(i/2*11),lcdteks);
		  }
		  lcd_printf(4,1,PSTR("[*]Back     "));
   131ca:	84 e0       	ldi	r24, 0x04	; 4
   131cc:	61 e0       	ldi	r22, 0x01	; 1
   131ce:	49 ea       	ldi	r20, 0xA9	; 169
   131d0:	5d e0       	ldi	r21, 0x0D	; 13
   131d2:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		  stSettingSytem=ssBaudrateInput;
   131d6:	83 e0       	ldi	r24, 0x03	; 3
   131d8:	2f c0       	rjmp	.+94     	; 0x13238 <FSettingSystem+0x2fe>
	      break;
     case ssBaudrateInput:
	      KeyPressed=_key_scan(1);
   131da:	81 e0       	ldi	r24, 0x01	; 1
   131dc:	0e 94 ab ae 	call	0x15d56	; 0x15d56 <_key_scan>
		  KeyChar=_key_btn(KeyPressed);
   131e0:	0e 94 0c ae 	call	0x15c18	; 0x15c18 <_key_btn>
   131e4:	28 2f       	mov	r18, r24
		  if ((KeyChar>='1')&&(KeyChar<='4')){
   131e6:	81 53       	subi	r24, 0x31	; 49
   131e8:	84 30       	cpi	r24, 0x04	; 4
   131ea:	18 f5       	brcc	.+70     	; 0x13232 <FSettingSystem+0x2f8>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   131ec:	e1 99       	sbic	0x1c, 1	; 28
   131ee:	fe cf       	rjmp	.-4      	; 0x131ec <FSettingSystem+0x2b2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   131f0:	02 2f       	mov	r16, r18
   131f2:	10 e0       	ldi	r17, 0x00	; 0
   131f4:	01 5f       	subi	r16, 0xF1	; 241
   131f6:	1e 4f       	sbci	r17, 0xFE	; 254
   131f8:	1f bb       	out	0x1f, r17	; 31
   131fa:	0e bb       	out	0x1e, r16	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   131fc:	e0 9a       	sbi	0x1c, 0	; 28
   131fe:	8d b3       	in	r24, 0x1d	; 29
		       brVal=eeprom_read_byte(&DefBaudrate[KeyChar-'1']);
			   brVal=((brVal+1)%3)+1;
   13200:	90 e0       	ldi	r25, 0x00	; 0
   13202:	01 96       	adiw	r24, 0x01	; 1
   13204:	63 e0       	ldi	r22, 0x03	; 3
   13206:	70 e0       	ldi	r23, 0x00	; 0
   13208:	0e 94 4c b7 	call	0x16e98	; 0x16e98 <__divmodhi4>
   1320c:	f8 2e       	mov	r15, r24
   1320e:	f3 94       	inc	r15
			   SetBaudRate(KeyChar-'0',brVal);
   13210:	82 2f       	mov	r24, r18
   13212:	80 53       	subi	r24, 0x30	; 48
   13214:	6f 2d       	mov	r22, r15
   13216:	0e 94 67 97 	call	0x12ece	; 0x12ece <SetBaudRate>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   1321a:	e1 99       	sbic	0x1c, 1	; 28
   1321c:	fe cf       	rjmp	.-4      	; 0x1321a <FSettingSystem+0x2e0>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   1321e:	1f bb       	out	0x1f, r17	; 31
   13220:	0e bb       	out	0x1e, r16	; 30
#endif
    EEDR = __value;
   13222:	fd ba       	out	0x1d, r15	; 29

    __asm__ __volatile__ (
   13224:	0f b6       	in	r0, 0x3f	; 63
   13226:	f8 94       	cli
   13228:	e2 9a       	sbi	0x1c, 2	; 28
   1322a:	e1 9a       	sbi	0x1c, 1	; 28
   1322c:	0f be       	out	0x3f, r0	; 63
			   eeprom_write_byte(&DefBaudrate[KeyChar-'1'],brVal);
               stSettingSytem=ssComSettings;
   1322e:	82 e0       	ldi	r24, 0x02	; 2
   13230:	03 c0       	rjmp	.+6      	; 0x13238 <FSettingSystem+0x2fe>
		  }else if (KeyChar=='*')
   13232:	2a 32       	cpi	r18, 0x2A	; 42
   13234:	79 f4       	brne	.+30     	; 0x13254 <FSettingSystem+0x31a>
		      stSettingSytem=ssExitSystemSettings;		  	
   13236:	85 e0       	ldi	r24, 0x05	; 5
   13238:	80 93 e0 02 	sts	0x02E0, r24
   1323c:	0b c0       	rjmp	.+22     	; 0x13254 <FSettingSystem+0x31a>
	      break;
	 case ssPumpPoolingSettings:
          SubMenu=FSettingPumpPooling();
   1323e:	0e 94 27 6e 	call	0xdc4e	; 0xdc4e <FSettingPumpPooling>
		  if (SubMenu==MENU_DONE)stSettingSytem=ssInitSettingSystem;
   13242:	81 30       	cpi	r24, 0x01	; 1
   13244:	39 f4       	brne	.+14     	; 0x13254 <FSettingSystem+0x31a>
   13246:	10 92 e0 02 	sts	0x02E0, r1
   1324a:	04 c0       	rjmp	.+8      	; 0x13254 <FSettingSystem+0x31a>
	      break;
     case ssExitSystemSettings:
	      stSettingSytem=ssInitSettingSystem;
   1324c:	10 92 e0 02 	sts	0x02E0, r1
   13250:	81 e0       	ldi	r24, 0x01	; 1
   13252:	01 c0       	rjmp	.+2      	; 0x13256 <FSettingSystem+0x31c>
   13254:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
     return Result;
}
   13256:	64 96       	adiw	r28, 0x14	; 20
   13258:	0f b6       	in	r0, 0x3f	; 63
   1325a:	f8 94       	cli
   1325c:	de bf       	out	0x3e, r29	; 62
   1325e:	0f be       	out	0x3f, r0	; 63
   13260:	cd bf       	out	0x3d, r28	; 61
   13262:	cf 91       	pop	r28
   13264:	df 91       	pop	r29
   13266:	1f 91       	pop	r17
   13268:	0f 91       	pop	r16
   1326a:	ff 90       	pop	r15
   1326c:	ef 90       	pop	r14
   1326e:	df 90       	pop	r13
   13270:	cf 90       	pop	r12
   13272:	bf 90       	pop	r11
   13274:	af 90       	pop	r10
   13276:	08 95       	ret

00013278 <FMenuSettings>:


char FMenuSettings(){
char Result=MENU_NONE;
static char stMenuSettings=msInit,PageSetting=1,KeyPressed,KeyChar,SubMenu;
     switch(stMenuSettings){
   13278:	80 91 f3 02 	lds	r24, 0x02F3
   1327c:	e8 2f       	mov	r30, r24
   1327e:	f0 e0       	ldi	r31, 0x00	; 0
   13280:	e3 31       	cpi	r30, 0x13	; 19
   13282:	f1 05       	cpc	r31, r1
   13284:	08 f0       	brcs	.+2      	; 0x13288 <FMenuSettings+0x10>
   13286:	cd c0       	rjmp	.+410    	; 0x13422 <FMenuSettings+0x1aa>
   13288:	ee 51       	subi	r30, 0x1E	; 30
   1328a:	ff 4f       	sbci	r31, 0xFF	; 255
   1328c:	ee 0f       	add	r30, r30
   1328e:	ff 1f       	adc	r31, r31
   13290:	05 90       	lpm	r0, Z+
   13292:	f4 91       	lpm	r31, Z+
   13294:	e0 2d       	mov	r30, r0
   13296:	09 94       	ijmp
	 case msInit:
		  lcd_clear();
   13298:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
		  PageSetting=1;
   1329c:	81 e0       	ldi	r24, 0x01	; 1
   1329e:	80 93 57 01 	sts	0x0157, r24
   132a2:	b7 c0       	rjmp	.+366    	; 0x13412 <FMenuSettings+0x19a>
		  stMenuSettings=msDisplayPage;
		  break;
	 case msDisplayPage:
	      stMenuSettings=msDisplayPage+PageSetting;
   132a4:	80 91 57 01 	lds	r24, 0x0157
   132a8:	8f 5f       	subi	r24, 0xFF	; 255
   132aa:	b3 c0       	rjmp	.+358    	; 0x13412 <FMenuSettings+0x19a>
          break; 	 
	 case msDisplayPage1:
		  lcd_printf(1, 1, PSTR("1)Product  5)Printer"));
   132ac:	81 e0       	ldi	r24, 0x01	; 1
   132ae:	61 e0       	ldi	r22, 0x01	; 1
   132b0:	41 ea       	ldi	r20, 0xA1	; 161
   132b2:	52 e1       	ldi	r21, 0x12	; 18
   132b4:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		  lcd_printf(2, 1, PSTR("2)Pump     6)Host   "));
   132b8:	82 e0       	ldi	r24, 0x02	; 2
   132ba:	61 e0       	ldi	r22, 0x01	; 1
   132bc:	4c e8       	ldi	r20, 0x8C	; 140
   132be:	52 e1       	ldi	r21, 0x12	; 18
   132c0:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		  lcd_printf(3, 1, PSTR("3)Decimal  7)Next   "));
   132c4:	83 e0       	ldi	r24, 0x03	; 3
   132c6:	61 e0       	ldi	r22, 0x01	; 1
   132c8:	47 e7       	ldi	r20, 0x77	; 119
   132ca:	52 e1       	ldi	r21, 0x12	; 18
   132cc:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		  lcd_printf(4, 1, PSTR("4)Datetime *)Exit   "));
   132d0:	84 e0       	ldi	r24, 0x04	; 4
   132d2:	61 e0       	ldi	r22, 0x01	; 1
   132d4:	42 e6       	ldi	r20, 0x62	; 98
   132d6:	52 e1       	ldi	r21, 0x12	; 18
   132d8:	16 c0       	rjmp	.+44     	; 0x13306 <FMenuSettings+0x8e>
		  stMenuSettings=msSelection;
	      break;
	 case msDisplayPage2:
		  lcd_printf(1, 1, PSTR("1)Operator          "));
   132da:	81 e0       	ldi	r24, 0x01	; 1
   132dc:	61 e0       	ldi	r22, 0x01	; 1
   132de:	4d e4       	ldi	r20, 0x4D	; 77
   132e0:	52 e1       	ldi	r21, 0x12	; 18
   132e2:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		  lcd_printf(2, 1, PSTR("2)System            "));
   132e6:	82 e0       	ldi	r24, 0x02	; 2
   132e8:	61 e0       	ldi	r22, 0x01	; 1
   132ea:	48 e3       	ldi	r20, 0x38	; 56
   132ec:	52 e1       	ldi	r21, 0x12	; 18
   132ee:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		  lcd_printf(3, 1, PSTR("3)PumpPooling       "));
   132f2:	83 e0       	ldi	r24, 0x03	; 3
   132f4:	61 e0       	ldi	r22, 0x01	; 1
   132f6:	43 e2       	ldi	r20, 0x23	; 35
   132f8:	52 e1       	ldi	r21, 0x12	; 18
   132fa:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		  lcd_printf(4, 1, PSTR("*)Back              "));
   132fe:	84 e0       	ldi	r24, 0x04	; 4
   13300:	61 e0       	ldi	r22, 0x01	; 1
   13302:	4e e0       	ldi	r20, 0x0E	; 14
   13304:	52 e1       	ldi	r21, 0x12	; 18
   13306:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		  stMenuSettings=msSelection;
   1330a:	84 e0       	ldi	r24, 0x04	; 4
   1330c:	82 c0       	rjmp	.+260    	; 0x13412 <FMenuSettings+0x19a>
	      break;
	 case msSelection:
	      stMenuSettings=msSelection+PageSetting;
   1330e:	80 91 57 01 	lds	r24, 0x0157
   13312:	8c 5f       	subi	r24, 0xFC	; 252
   13314:	7e c0       	rjmp	.+252    	; 0x13412 <FMenuSettings+0x19a>
          break;	 
	 case msSelectionPage1:
		  KeyPressed=_key_scan(1);
   13316:	81 e0       	ldi	r24, 0x01	; 1
   13318:	0e 94 ab ae 	call	0x15d56	; 0x15d56 <_key_scan>
   1331c:	80 93 f2 02 	sts	0x02F2, r24
		  KeyChar=_key_btn(KeyPressed);
   13320:	0e 94 0c ae 	call	0x15c18	; 0x15c18 <_key_btn>
   13324:	80 93 f1 02 	sts	0x02F1, r24
		  switch(KeyChar){
   13328:	84 33       	cpi	r24, 0x34	; 52
   1332a:	d1 f0       	breq	.+52     	; 0x13360 <FMenuSettings+0xe8>
   1332c:	85 33       	cpi	r24, 0x35	; 53
   1332e:	50 f4       	brcc	.+20     	; 0x13344 <FMenuSettings+0xcc>
   13330:	82 33       	cpi	r24, 0x32	; 50
   13332:	91 f0       	breq	.+36     	; 0x13358 <FMenuSettings+0xe0>
   13334:	83 33       	cpi	r24, 0x33	; 51
   13336:	90 f4       	brcc	.+36     	; 0x1335c <FMenuSettings+0xe4>
   13338:	8a 32       	cpi	r24, 0x2A	; 42
   1333a:	d1 f0       	breq	.+52     	; 0x13370 <FMenuSettings+0xf8>
   1333c:	81 33       	cpi	r24, 0x31	; 49
   1333e:	09 f0       	breq	.+2      	; 0x13342 <FMenuSettings+0xca>
   13340:	70 c0       	rjmp	.+224    	; 0x13422 <FMenuSettings+0x1aa>
   13342:	08 c0       	rjmp	.+16     	; 0x13354 <FMenuSettings+0xdc>
   13344:	86 33       	cpi	r24, 0x36	; 54
   13346:	81 f0       	breq	.+32     	; 0x13368 <FMenuSettings+0xf0>
   13348:	86 33       	cpi	r24, 0x36	; 54
   1334a:	60 f0       	brcs	.+24     	; 0x13364 <FMenuSettings+0xec>
   1334c:	87 33       	cpi	r24, 0x37	; 55
   1334e:	09 f0       	breq	.+2      	; 0x13352 <FMenuSettings+0xda>
   13350:	68 c0       	rjmp	.+208    	; 0x13422 <FMenuSettings+0x1aa>
   13352:	0c c0       	rjmp	.+24     	; 0x1336c <FMenuSettings+0xf4>
		  case '1':
		       stMenuSettings=msMenuSettingProduct;
   13354:	89 e0       	ldi	r24, 0x09	; 9
   13356:	5d c0       	rjmp	.+186    	; 0x13412 <FMenuSettings+0x19a>
		       break;
		  case '2': 
		       stMenuSettings=msMenuSettingPump;
   13358:	8a e0       	ldi	r24, 0x0A	; 10
   1335a:	5b c0       	rjmp	.+182    	; 0x13412 <FMenuSettings+0x19a>
		       break;
		  case '3':
		       stMenuSettings=msMenuSettingDec;
   1335c:	8b e0       	ldi	r24, 0x0B	; 11
   1335e:	59 c0       	rjmp	.+178    	; 0x13412 <FMenuSettings+0x19a>
		       break;
		  case '4':
		       stMenuSettings=msMenuSettingDatetime;
   13360:	8c e0       	ldi	r24, 0x0C	; 12
   13362:	57 c0       	rjmp	.+174    	; 0x13412 <FMenuSettings+0x19a>
		       break;
		  case '5':
		       stMenuSettings=msMenuSettingPrinter;
   13364:	8d e0       	ldi	r24, 0x0D	; 13
   13366:	55 c0       	rjmp	.+170    	; 0x13412 <FMenuSettings+0x19a>
		       break;
		  case '6':
		       stMenuSettings=msMenuSettingHost;
   13368:	8e e0       	ldi	r24, 0x0E	; 14
   1336a:	53 c0       	rjmp	.+166    	; 0x13412 <FMenuSettings+0x19a>
		       break;
		  case '7':
		       stMenuSettings=msMenuSettingNextPage;
   1336c:	87 e0       	ldi	r24, 0x07	; 7
   1336e:	51 c0       	rjmp	.+162    	; 0x13412 <FMenuSettings+0x19a>
		       break;
		  case '*':
		       stMenuSettings=msMenuSettingExit;
   13370:	82 e1       	ldi	r24, 0x12	; 18
   13372:	4f c0       	rjmp	.+158    	; 0x13412 <FMenuSettings+0x19a>
		       break;			   
		  }
	      break;
	 case msSelectionPage2:
	 	  KeyPressed=_key_scan(1);
   13374:	81 e0       	ldi	r24, 0x01	; 1
   13376:	0e 94 ab ae 	call	0x15d56	; 0x15d56 <_key_scan>
   1337a:	80 93 f2 02 	sts	0x02F2, r24
		  KeyChar=_key_btn(KeyPressed);
   1337e:	0e 94 0c ae 	call	0x15c18	; 0x15c18 <_key_btn>
   13382:	80 93 f1 02 	sts	0x02F1, r24
		  switch(KeyChar){
   13386:	82 33       	cpi	r24, 0x32	; 50
   13388:	71 f0       	breq	.+28     	; 0x133a6 <FMenuSettings+0x12e>
   1338a:	83 33       	cpi	r24, 0x33	; 51
   1338c:	30 f4       	brcc	.+12     	; 0x1339a <FMenuSettings+0x122>
   1338e:	8a 32       	cpi	r24, 0x2A	; 42
   13390:	71 f0       	breq	.+28     	; 0x133ae <FMenuSettings+0x136>
   13392:	81 33       	cpi	r24, 0x31	; 49
   13394:	09 f0       	breq	.+2      	; 0x13398 <FMenuSettings+0x120>
   13396:	45 c0       	rjmp	.+138    	; 0x13422 <FMenuSettings+0x1aa>
   13398:	04 c0       	rjmp	.+8      	; 0x133a2 <FMenuSettings+0x12a>
   1339a:	83 33       	cpi	r24, 0x33	; 51
   1339c:	09 f0       	breq	.+2      	; 0x133a0 <FMenuSettings+0x128>
   1339e:	41 c0       	rjmp	.+130    	; 0x13422 <FMenuSettings+0x1aa>
   133a0:	04 c0       	rjmp	.+8      	; 0x133aa <FMenuSettings+0x132>
		  case '1':
		       stMenuSettings=msMenuSettingOperator;
   133a2:	8f e0       	ldi	r24, 0x0F	; 15
   133a4:	36 c0       	rjmp	.+108    	; 0x13412 <FMenuSettings+0x19a>
		       break;
		  case '2':
		       stMenuSettings=msMenuSettingSystem;
   133a6:	80 e1       	ldi	r24, 0x10	; 16
   133a8:	34 c0       	rjmp	.+104    	; 0x13412 <FMenuSettings+0x19a>
		       break;
		  case '3':
		       stMenuSettings=msMenuSettingPumpPooling;
   133aa:	81 e1       	ldi	r24, 0x11	; 17
   133ac:	32 c0       	rjmp	.+100    	; 0x13412 <FMenuSettings+0x19a>
		       break;
		  case '*':
		       stMenuSettings=msMenuSettingBackPage;
   133ae:	88 e0       	ldi	r24, 0x08	; 8
   133b0:	30 c0       	rjmp	.+96     	; 0x13412 <FMenuSettings+0x19a>
		       break;		  
		  }
	      break;
		  
	 case msMenuSettingNextPage:
	      if (PageSetting<2)PageSetting++;
   133b2:	80 91 57 01 	lds	r24, 0x0157
   133b6:	82 30       	cpi	r24, 0x02	; 2
   133b8:	48 f4       	brcc	.+18     	; 0x133cc <FMenuSettings+0x154>
   133ba:	8f 5f       	subi	r24, 0xFF	; 255
   133bc:	05 c0       	rjmp	.+10     	; 0x133c8 <FMenuSettings+0x150>
		  stMenuSettings=msDisplayPage;
	      break;
	 case msMenuSettingBackPage:
	      if (PageSetting>1)PageSetting--;
   133be:	80 91 57 01 	lds	r24, 0x0157
   133c2:	82 30       	cpi	r24, 0x02	; 2
   133c4:	18 f0       	brcs	.+6      	; 0x133cc <FMenuSettings+0x154>
   133c6:	81 50       	subi	r24, 0x01	; 1
   133c8:	80 93 57 01 	sts	0x0157, r24
		  stMenuSettings=msDisplayPage;
   133cc:	81 e0       	ldi	r24, 0x01	; 1
   133ce:	21 c0       	rjmp	.+66     	; 0x13412 <FMenuSettings+0x19a>
	      break;
//---Sub Menu Operations--------------------------------------------		  
     case msMenuSettingProduct:
	      SubMenu=FSettingProduct();
   133d0:	0e 94 a1 88 	call	0x11142	; 0x11142 <FSettingProduct>
   133d4:	1a c0       	rjmp	.+52     	; 0x1340a <FMenuSettings+0x192>
		  if (SubMenu==MENU_DONE)stMenuSettings=msDisplayPage;
	      break;
	 case msMenuSettingPump:
	      SubMenu=FSettingPump();
   133d6:	0e 94 3a 76 	call	0xec74	; 0xec74 <FSettingPump>
   133da:	17 c0       	rjmp	.+46     	; 0x1340a <FMenuSettings+0x192>
		  if (SubMenu==MENU_DONE)stMenuSettings=msDisplayPage;
	      break;
	 case msMenuSettingDec:
	      SubMenu=FSettingDec();
   133dc:	0e 94 51 81 	call	0x102a2	; 0x102a2 <FSettingDec>
   133e0:	14 c0       	rjmp	.+40     	; 0x1340a <FMenuSettings+0x192>
	 }
     return Result;
}

char FSettingDatetime(){
     _menu_datetime();
   133e2:	0e 94 f7 61 	call	0xc3ee	; 0xc3ee <_menu_datetime>
   133e6:	05 c0       	rjmp	.+10     	; 0x133f2 <FMenuSettings+0x17a>
     return MENU_DONE;
}
char FSettingPrinter(){
     _menu_printer();
   133e8:	0e 94 4b 4a 	call	0x9496	; 0x9496 <_menu_printer>
   133ec:	02 c0       	rjmp	.+4      	; 0x133f2 <FMenuSettings+0x17a>
	 return MENU_DONE;
}
char FSettingHost(){
     _menu_host();
   133ee:	0e 94 01 43 	call	0x8602	; 0x8602 <_menu_host>
	 case msMenuSettingPrinter: 
	      SubMenu=FSettingPrinter();
		  if (SubMenu==MENU_DONE)stMenuSettings=msDisplayPage;
	      break;
	 case msMenuSettingHost:
	      SubMenu=FSettingHost();
   133f2:	81 e0       	ldi	r24, 0x01	; 1
   133f4:	80 93 f0 02 	sts	0x02F0, r24
   133f8:	0c c0       	rjmp	.+24     	; 0x13412 <FMenuSettings+0x19a>
		  if (SubMenu==MENU_DONE)stMenuSettings=msDisplayPage;
	      break;
     case msMenuSettingOperator:
          SubMenu=FSettingOperator();
   133fa:	0e 94 ae 85 	call	0x10b5c	; 0x10b5c <FSettingOperator>
   133fe:	05 c0       	rjmp	.+10     	; 0x1340a <FMenuSettings+0x192>
		  if (SubMenu==MENU_DONE)stMenuSettings=msDisplayPage;
	      break;
	 case msMenuSettingSystem:
	      SubMenu=FSettingSystem();
   13400:	0e 94 9d 97 	call	0x12f3a	; 0x12f3a <FSettingSystem>
   13404:	02 c0       	rjmp	.+4      	; 0x1340a <FMenuSettings+0x192>
		  if (SubMenu==MENU_DONE)stMenuSettings=msDisplayPage;
	      break;	 
     case msMenuSettingPumpPooling:
	      SubMenu=FSettingPumpPooling();
   13406:	0e 94 27 6e 	call	0xdc4e	; 0xdc4e <FSettingPumpPooling>
   1340a:	80 93 f0 02 	sts	0x02F0, r24
		  if (SubMenu==MENU_DONE)stMenuSettings=msDisplayPage;
   1340e:	81 30       	cpi	r24, 0x01	; 1
   13410:	41 f4       	brne	.+16     	; 0x13422 <FMenuSettings+0x1aa>
   13412:	80 93 f3 02 	sts	0x02F3, r24
   13416:	80 e0       	ldi	r24, 0x00	; 0
   13418:	08 95       	ret
	      break;
//------------------------------------------------------------------
     case msMenuSettingExit:
	      stMenuSettings=msInit;
   1341a:	10 92 f3 02 	sts	0x02F3, r1
   1341e:	81 e0       	ldi	r24, 0x01	; 1
   13420:	08 95       	ret
   13422:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
   return Result;
}
   13424:	08 95       	ret

00013426 <FMenuAuthorization>:


char FMenuAuthorization(){
char Result=MENU_NONE,PassResult=MP_NONE,SubMenu=MENU_NONE;
static char stMenuAuthorization=maInit,PassTry=0;
     switch(stMenuAuthorization){
   13426:	80 91 32 03 	lds	r24, 0x0332
   1342a:	83 30       	cpi	r24, 0x03	; 3
   1342c:	69 f1       	breq	.+90     	; 0x13488 <FMenuAuthorization+0x62>
   1342e:	84 30       	cpi	r24, 0x04	; 4
   13430:	28 f4       	brcc	.+10     	; 0x1343c <FMenuAuthorization+0x16>
   13432:	81 30       	cpi	r24, 0x01	; 1
   13434:	89 f0       	breq	.+34     	; 0x13458 <FMenuAuthorization+0x32>
   13436:	82 30       	cpi	r24, 0x02	; 2
   13438:	50 f5       	brcc	.+84     	; 0x1348e <FMenuAuthorization+0x68>
   1343a:	0b c0       	rjmp	.+22     	; 0x13452 <FMenuAuthorization+0x2c>
   1343c:	85 30       	cpi	r24, 0x05	; 5
   1343e:	79 f1       	breq	.+94     	; 0x1349e <FMenuAuthorization+0x78>
   13440:	85 30       	cpi	r24, 0x05	; 5
   13442:	40 f1       	brcs	.+80     	; 0x13494 <FMenuAuthorization+0x6e>
   13444:	86 30       	cpi	r24, 0x06	; 6
   13446:	09 f4       	brne	.+2      	; 0x1344a <FMenuAuthorization+0x24>
   13448:	41 c0       	rjmp	.+130    	; 0x134cc <FMenuAuthorization+0xa6>
   1344a:	87 30       	cpi	r24, 0x07	; 7
   1344c:	09 f0       	breq	.+2      	; 0x13450 <FMenuAuthorization+0x2a>
   1344e:	51 c0       	rjmp	.+162    	; 0x134f2 <FMenuAuthorization+0xcc>
   13450:	4c c0       	rjmp	.+152    	; 0x134ea <FMenuAuthorization+0xc4>
	 case maInit:
	      PassTry=0;
   13452:	10 92 31 03 	sts	0x0331, r1
   13456:	42 c0       	rjmp	.+132    	; 0x134dc <FMenuAuthorization+0xb6>
		  stMenuAuthorization=maInputPassword;
	      break;
	 case maInputPassword:
	      PassResult=FMenuPassword();
   13458:	0e 94 a9 90 	call	0x12152	; 0x12152 <FMenuPassword>
		  switch(PassResult){
   1345c:	83 30       	cpi	r24, 0x03	; 3
   1345e:	09 f4       	brne	.+2      	; 0x13462 <FMenuAuthorization+0x3c>
   13460:	40 c0       	rjmp	.+128    	; 0x134e2 <FMenuAuthorization+0xbc>
   13462:	84 30       	cpi	r24, 0x04	; 4
   13464:	30 f4       	brcc	.+12     	; 0x13472 <FMenuAuthorization+0x4c>
   13466:	81 30       	cpi	r24, 0x01	; 1
   13468:	d9 f1       	breq	.+118    	; 0x134e0 <FMenuAuthorization+0xba>
   1346a:	82 30       	cpi	r24, 0x02	; 2
   1346c:	09 f0       	breq	.+2      	; 0x13470 <FMenuAuthorization+0x4a>
   1346e:	41 c0       	rjmp	.+130    	; 0x134f2 <FMenuAuthorization+0xcc>
   13470:	09 c0       	rjmp	.+18     	; 0x13484 <FMenuAuthorization+0x5e>
   13472:	84 30       	cpi	r24, 0x04	; 4
   13474:	19 f0       	breq	.+6      	; 0x1347c <FMenuAuthorization+0x56>
   13476:	85 30       	cpi	r24, 0x05	; 5
   13478:	e1 f5       	brne	.+120    	; 0x134f2 <FMenuAuthorization+0xcc>
   1347a:	02 c0       	rjmp	.+4      	; 0x13480 <FMenuAuthorization+0x5a>
		  case MP_VALID_ADMIN:
		       stMenuAuthorization=maMenuAdmin;
   1347c:	82 e0       	ldi	r24, 0x02	; 2
   1347e:	31 c0       	rjmp	.+98     	; 0x134e2 <FMenuAuthorization+0xbc>
		       break;
		  case MP_VALID_SYSTEM:
		       stMenuAuthorization=maMenuSettings;
   13480:	84 e0       	ldi	r24, 0x04	; 4
   13482:	2f c0       	rjmp	.+94     	; 0x134e2 <FMenuAuthorization+0xbc>
		       break;
		  case MP_INVALID:
		       stMenuAuthorization=maInvalidAuthorization;
   13484:	85 e0       	ldi	r24, 0x05	; 5
   13486:	2d c0       	rjmp	.+90     	; 0x134e2 <FMenuAuthorization+0xbc>
		  else
	      if (PassResult==MP_CANCEL)stMenuAuthorization=maExitAuthorization;
		  */
	      break;
	 case maMenuMaster:
	      SubMenu=FMenuMaster();
   13488:	0e 94 92 8e 	call	0x11d24	; 0x11d24 <FMenuMaster>
   1348c:	05 c0       	rjmp	.+10     	; 0x13498 <FMenuAuthorization+0x72>
		  if (SubMenu==MENU_DONE)stMenuAuthorization=maExitAuthorization;
	      break;
	 case maMenuAdmin:
          SubMenu=FMenuAdmin();
   1348e:	0e 94 a2 92 	call	0x12544	; 0x12544 <FMenuAdmin>
   13492:	02 c0       	rjmp	.+4      	; 0x13498 <FMenuAuthorization+0x72>
		  if (SubMenu==MENU_DONE)stMenuAuthorization=maExitAuthorization;          
		  break;
	 case maMenuSettings:
	      SubMenu=FMenuSettings();
   13494:	0e 94 3c 99 	call	0x13278	; 0x13278 <FMenuSettings>
		  if (SubMenu==MENU_DONE)stMenuAuthorization=maExitAuthorization;
   13498:	81 30       	cpi	r24, 0x01	; 1
   1349a:	59 f5       	brne	.+86     	; 0x134f2 <FMenuAuthorization+0xcc>
   1349c:	21 c0       	rjmp	.+66     	; 0x134e0 <FMenuAuthorization+0xba>
          break;	 
	 case maInvalidAuthorization:
	      PassTry++;
   1349e:	80 91 31 03 	lds	r24, 0x0331
   134a2:	8f 5f       	subi	r24, 0xFF	; 255
   134a4:	80 93 31 03 	sts	0x0331, r24
	      TimDisplay=0;
   134a8:	10 92 a7 01 	sts	0x01A7, r1
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   134ac:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   134ae:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   134b0:	81 e0       	ldi	r24, 0x01	; 1
   134b2:	90 e0       	ldi	r25, 0x00	; 0
   134b4:	90 93 d7 01 	sts	0x01D7, r25
   134b8:	80 93 d6 01 	sts	0x01D6, r24
          break;	 
	 case maInvalidAuthorization:
	      PassTry++;
	      TimDisplay=0;
		  system_beep(1);
		  lcd_printf(3,1,PSTR("Access Denied"));
   134bc:	83 e0       	ldi	r24, 0x03	; 3
   134be:	61 e0       	ldi	r22, 0x01	; 1
   134c0:	40 e1       	ldi	r20, 0x10	; 16
   134c2:	58 e1       	ldi	r21, 0x18	; 24
   134c4:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		  stMenuAuthorization=maDelayExitAuthorization;
   134c8:	86 e0       	ldi	r24, 0x06	; 6
   134ca:	0b c0       	rjmp	.+22     	; 0x134e2 <FMenuAuthorization+0xbc>
          break;	 
	 case maDelayExitAuthorization:
	      if (TimDisplay>2){
   134cc:	80 91 a7 01 	lds	r24, 0x01A7
   134d0:	83 30       	cpi	r24, 0x03	; 3
   134d2:	78 f0       	brcs	.+30     	; 0x134f2 <FMenuAuthorization+0xcc>
		      if (PassTry<3)stMenuAuthorization=maInputPassword;
   134d4:	80 91 31 03 	lds	r24, 0x0331
   134d8:	83 30       	cpi	r24, 0x03	; 3
   134da:	10 f4       	brcc	.+4      	; 0x134e0 <FMenuAuthorization+0xba>
   134dc:	81 e0       	ldi	r24, 0x01	; 1
   134de:	01 c0       	rjmp	.+2      	; 0x134e2 <FMenuAuthorization+0xbc>
			  else stMenuAuthorization=maExitAuthorization;
   134e0:	87 e0       	ldi	r24, 0x07	; 7
   134e2:	80 93 32 03 	sts	0x0332, r24
   134e6:	80 e0       	ldi	r24, 0x00	; 0
   134e8:	08 95       	ret
		  }
	      break;
	 case maExitAuthorization:
	      stMenuAuthorization=maInit;
   134ea:	10 92 32 03 	sts	0x0332, r1
   134ee:	81 e0       	ldi	r24, 0x01	; 1
   134f0:	08 95       	ret
   134f2:	80 e0       	ldi	r24, 0x00	; 0
	      Result=MENU_DONE;
	      break;
	 }
   return Result;	 
}
   134f4:	08 95       	ret

000134f6 <InitComport>:
     	  break;	 
	 }
   return Result;
}

void InitComport(){
   134f6:	af 92       	push	r10
   134f8:	bf 92       	push	r11
   134fa:	cf 92       	push	r12
   134fc:	df 92       	push	r13
   134fe:	ff 92       	push	r15
   13500:	0f 93       	push	r16
   13502:	1f 93       	push	r17
   13504:	df 93       	push	r29
   13506:	cf 93       	push	r28
   13508:	cd b7       	in	r28, 0x3d	; 61
   1350a:	de b7       	in	r29, 0x3e	; 62
   1350c:	64 97       	sbiw	r28, 0x14	; 20
   1350e:	0f b6       	in	r0, 0x3f	; 63
   13510:	f8 94       	cli
   13512:	de bf       	out	0x3e, r29	; 62
   13514:	0f be       	out	0x3f, r0	; 63
   13516:	cd bf       	out	0x3d, r28	; 61
     char brMap,i=0,lcdteks[20];	 
	 int bValue;
	 lcd_printf(3, 1, PSTR("Initialize COM ..."));
   13518:	83 e0       	ldi	r24, 0x03	; 3
   1351a:	61 e0       	ldi	r22, 0x01	; 1
   1351c:	44 ea       	ldi	r20, 0xA4	; 164
   1351e:	5c e1       	ldi	r21, 0x1C	; 28
   13520:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
   13524:	01 e0       	ldi	r16, 0x01	; 1
   13526:	10 e0       	ldi	r17, 0x00	; 0
     for(i=0;i<4;i++){
	     brMap=eeprom_read_byte(&DefBaudrate[i]);
		 bValue=GetBaudrate(brMap);
		 if (bValue==5787)bValue=12213;
		 sprintf_P(lcdteks,PSTR("COM%d:%i           "),i+1,bValue);
   13528:	6e 01       	movw	r12, r28
   1352a:	08 94       	sec
   1352c:	c1 1c       	adc	r12, r1
   1352e:	d1 1c       	adc	r13, r1
   13530:	f0 e9       	ldi	r31, 0x90	; 144
   13532:	af 2e       	mov	r10, r31
   13534:	fc e1       	ldi	r31, 0x1C	; 28
   13536:	bf 2e       	mov	r11, r31
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   13538:	e1 99       	sbic	0x1c, 1	; 28
   1353a:	fe cf       	rjmp	.-4      	; 0x13538 <InitComport+0x42>
   1353c:	c8 01       	movw	r24, r16
   1353e:	81 5c       	subi	r24, 0xC1	; 193
   13540:	9e 4f       	sbci	r25, 0xFE	; 254
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   13542:	9f bb       	out	0x1f, r25	; 31
   13544:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   13546:	e0 9a       	sbi	0x1c, 0	; 28
   13548:	fd b2       	in	r15, 0x1d	; 29
	 }
}

int GetBaudrate(char brSetting){
int Result=0;
     switch(brSetting){
   1354a:	22 e0       	ldi	r18, 0x02	; 2
   1354c:	f2 16       	cp	r15, r18
   1354e:	71 f0       	breq	.+28     	; 0x1356c <InitComport+0x76>
   13550:	f2 16       	cp	r15, r18
   13552:	30 f0       	brcs	.+12     	; 0x13560 <InitComport+0x6a>
   13554:	33 e0       	ldi	r19, 0x03	; 3
   13556:	f3 16       	cp	r15, r19
   13558:	31 f4       	brne	.+12     	; 0x13566 <InitComport+0x70>
   1355a:	85 eb       	ldi	r24, 0xB5	; 181
   1355c:	9f e2       	ldi	r25, 0x2F	; 47
   1355e:	08 c0       	rjmp	.+16     	; 0x13570 <InitComport+0x7a>
   13560:	80 e8       	ldi	r24, 0x80	; 128
   13562:	95 e2       	ldi	r25, 0x25	; 37
   13564:	05 c0       	rjmp	.+10     	; 0x13570 <InitComport+0x7a>
   13566:	80 e0       	ldi	r24, 0x00	; 0
   13568:	90 e0       	ldi	r25, 0x00	; 0
   1356a:	02 c0       	rjmp	.+4      	; 0x13570 <InitComport+0x7a>
   1356c:	80 e0       	ldi	r24, 0x00	; 0
   1356e:	9b e4       	ldi	r25, 0x4B	; 75
	 lcd_printf(3, 1, PSTR("Initialize COM ..."));
     for(i=0;i<4;i++){
	     brMap=eeprom_read_byte(&DefBaudrate[i]);
		 bValue=GetBaudrate(brMap);
		 if (bValue==5787)bValue=12213;
		 sprintf_P(lcdteks,PSTR("COM%d:%i           "),i+1,bValue);
   13570:	ad b7       	in	r26, 0x3d	; 61
   13572:	be b7       	in	r27, 0x3e	; 62
   13574:	18 97       	sbiw	r26, 0x08	; 8
   13576:	0f b6       	in	r0, 0x3f	; 63
   13578:	f8 94       	cli
   1357a:	be bf       	out	0x3e, r27	; 62
   1357c:	0f be       	out	0x3f, r0	; 63
   1357e:	ad bf       	out	0x3d, r26	; 61
   13580:	ed b7       	in	r30, 0x3d	; 61
   13582:	fe b7       	in	r31, 0x3e	; 62
   13584:	31 96       	adiw	r30, 0x01	; 1
   13586:	12 96       	adiw	r26, 0x02	; 2
   13588:	dc 92       	st	X, r13
   1358a:	ce 92       	st	-X, r12
   1358c:	11 97       	sbiw	r26, 0x01	; 1
   1358e:	b3 82       	std	Z+3, r11	; 0x03
   13590:	a2 82       	std	Z+2, r10	; 0x02
   13592:	15 83       	std	Z+5, r17	; 0x05
   13594:	04 83       	std	Z+4, r16	; 0x04
   13596:	97 83       	std	Z+7, r25	; 0x07
   13598:	86 83       	std	Z+6, r24	; 0x06
   1359a:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
		 lcd_print(4,1,lcdteks);
   1359e:	2d b7       	in	r18, 0x3d	; 61
   135a0:	3e b7       	in	r19, 0x3e	; 62
   135a2:	28 5f       	subi	r18, 0xF8	; 248
   135a4:	3f 4f       	sbci	r19, 0xFF	; 255
   135a6:	0f b6       	in	r0, 0x3f	; 63
   135a8:	f8 94       	cli
   135aa:	3e bf       	out	0x3e, r19	; 62
   135ac:	0f be       	out	0x3f, r0	; 63
   135ae:	2d bf       	out	0x3d, r18	; 61
   135b0:	84 e0       	ldi	r24, 0x04	; 4
   135b2:	61 e0       	ldi	r22, 0x01	; 1
   135b4:	a6 01       	movw	r20, r12
   135b6:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
		 SetBaudRate(i+1,brMap);
   135ba:	80 2f       	mov	r24, r16
   135bc:	6f 2d       	mov	r22, r15
   135be:	0e 94 67 97 	call	0x12ece	; 0x12ece <SetBaudRate>
 	     TimDisplay=0;
   135c2:	10 92 a7 01 	sts	0x01A7, r1
   135c6:	04 c0       	rjmp	.+8      	; 0x135d0 <InitComport+0xda>
	     while(TimDisplay<2){
		     if (TimDisplay>2)break;
   135c8:	80 91 a7 01 	lds	r24, 0x01A7
   135cc:	83 30       	cpi	r24, 0x03	; 3
   135ce:	20 f4       	brcc	.+8      	; 0x135d8 <InitComport+0xe2>
		 if (bValue==5787)bValue=12213;
		 sprintf_P(lcdteks,PSTR("COM%d:%i           "),i+1,bValue);
		 lcd_print(4,1,lcdteks);
		 SetBaudRate(i+1,brMap);
 	     TimDisplay=0;
	     while(TimDisplay<2){
   135d0:	80 91 a7 01 	lds	r24, 0x01A7
   135d4:	82 30       	cpi	r24, 0x02	; 2
   135d6:	c0 f3       	brcs	.-16     	; 0x135c8 <InitComport+0xd2>
   135d8:	0f 5f       	subi	r16, 0xFF	; 255
   135da:	1f 4f       	sbci	r17, 0xFF	; 255

void InitComport(){
     char brMap,i=0,lcdteks[20];	 
	 int bValue;
	 lcd_printf(3, 1, PSTR("Initialize COM ..."));
     for(i=0;i<4;i++){
   135dc:	05 30       	cpi	r16, 0x05	; 5
   135de:	11 05       	cpc	r17, r1
   135e0:	09 f0       	breq	.+2      	; 0x135e4 <InitComport+0xee>
   135e2:	aa cf       	rjmp	.-172    	; 0x13538 <InitComport+0x42>
	     while(TimDisplay<2){
		     if (TimDisplay>2)break;
		 };

	 }
}
   135e4:	64 96       	adiw	r28, 0x14	; 20
   135e6:	0f b6       	in	r0, 0x3f	; 63
   135e8:	f8 94       	cli
   135ea:	de bf       	out	0x3e, r29	; 62
   135ec:	0f be       	out	0x3f, r0	; 63
   135ee:	cd bf       	out	0x3d, r28	; 61
   135f0:	cf 91       	pop	r28
   135f2:	df 91       	pop	r29
   135f4:	1f 91       	pop	r17
   135f6:	0f 91       	pop	r16
   135f8:	ff 90       	pop	r15
   135fa:	df 90       	pop	r13
   135fc:	cf 90       	pop	r12
   135fe:	bf 90       	pop	r11
   13600:	af 90       	pop	r10
   13602:	08 95       	ret

00013604 <sendMessage56>:
    _uart_print(1, 0,strSend);
	_uart(1, 1,0x02);

}

void sendMessage56(){
   13604:	0f 93       	push	r16
   13606:	1f 93       	push	r17
   13608:	df 93       	push	r29
   1360a:	cf 93       	push	r28
   1360c:	cd b7       	in	r28, 0x3d	; 61
   1360e:	de b7       	in	r29, 0x3e	; 62
   13610:	ec 97       	sbiw	r28, 0x3c	; 60
   13612:	0f b6       	in	r0, 0x3f	; 63
   13614:	f8 94       	cli
   13616:	de bf       	out	0x3e, r29	; 62
   13618:	0f be       	out	0x3f, r0	; 63
   1361a:	cd bf       	out	0x3d, r28	; 61
	char strSend[60];
	_uart(1, 1,0x01);
   1361c:	81 e0       	ldi	r24, 0x01	; 1
   1361e:	61 e0       	ldi	r22, 0x01	; 1
   13620:	41 e0       	ldi	r20, 0x01	; 1
   13622:	0e 94 7a b2 	call	0x164f4	; 0x164f4 <_uart>
	UpdateIFT_ID(); //ReadIFT_ID
   13626:	0e 94 0f 1c 	call	0x381e	; 0x381e <UpdateIFT_ID>
	UpdateSeqNum(); //UpdateSeqNum SeqNum++
   1362a:	0e 94 e4 1b 	call	0x37c8	; 0x37c8 <UpdateSeqNum>
	UpdateClientIP();//ReadSourceIP
   1362e:	0e 94 ff 1d 	call	0x3bfe	; 0x3bfe <UpdateClientIP>
	UpdateServerIP();//ReadDestIP
   13632:	0e 94 97 1d 	call	0x3b2e	; 0x3b2e <UpdateServerIP>
	UpdateCardID();  //ReadCardID
   13636:	0e 94 ed 3c 	call	0x79da	; 0x79da <UpdateCardID>

	sprintf_P(strSend,PSTR("%s%s%s"),strIFT_ID,strSeqNum,strClientIP);
   1363a:	8d b7       	in	r24, 0x3d	; 61
   1363c:	9e b7       	in	r25, 0x3e	; 62
   1363e:	0a 97       	sbiw	r24, 0x0a	; 10
   13640:	0f b6       	in	r0, 0x3f	; 63
   13642:	f8 94       	cli
   13644:	9e bf       	out	0x3e, r25	; 62
   13646:	0f be       	out	0x3f, r0	; 63
   13648:	8d bf       	out	0x3d, r24	; 61
   1364a:	ed b7       	in	r30, 0x3d	; 61
   1364c:	fe b7       	in	r31, 0x3e	; 62
   1364e:	31 96       	adiw	r30, 0x01	; 1
   13650:	8e 01       	movw	r16, r28
   13652:	0f 5f       	subi	r16, 0xFF	; 255
   13654:	1f 4f       	sbci	r17, 0xFF	; 255
   13656:	ad b7       	in	r26, 0x3d	; 61
   13658:	be b7       	in	r27, 0x3e	; 62
   1365a:	12 96       	adiw	r26, 0x02	; 2
   1365c:	1c 93       	st	X, r17
   1365e:	0e 93       	st	-X, r16
   13660:	11 97       	sbiw	r26, 0x01	; 1
   13662:	82 e6       	ldi	r24, 0x62	; 98
   13664:	91 e2       	ldi	r25, 0x21	; 33
   13666:	93 83       	std	Z+3, r25	; 0x03
   13668:	82 83       	std	Z+2, r24	; 0x02
   1366a:	8c ec       	ldi	r24, 0xCC	; 204
   1366c:	95 e0       	ldi	r25, 0x05	; 5
   1366e:	95 83       	std	Z+5, r25	; 0x05
   13670:	84 83       	std	Z+4, r24	; 0x04
   13672:	8b ea       	ldi	r24, 0xAB	; 171
   13674:	9d e0       	ldi	r25, 0x0D	; 13
   13676:	97 83       	std	Z+7, r25	; 0x07
   13678:	86 83       	std	Z+6, r24	; 0x06
   1367a:	8e eb       	ldi	r24, 0xBE	; 190
   1367c:	99 e0       	ldi	r25, 0x09	; 9
   1367e:	91 87       	std	Z+9, r25	; 0x09
   13680:	80 87       	std	Z+8, r24	; 0x08
   13682:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    _uart_print(1, 0,strSend);
   13686:	8d b7       	in	r24, 0x3d	; 61
   13688:	9e b7       	in	r25, 0x3e	; 62
   1368a:	0a 96       	adiw	r24, 0x0a	; 10
   1368c:	0f b6       	in	r0, 0x3f	; 63
   1368e:	f8 94       	cli
   13690:	9e bf       	out	0x3e, r25	; 62
   13692:	0f be       	out	0x3f, r0	; 63
   13694:	8d bf       	out	0x3d, r24	; 61
   13696:	81 e0       	ldi	r24, 0x01	; 1
   13698:	60 e0       	ldi	r22, 0x00	; 0
   1369a:	a8 01       	movw	r20, r16
   1369c:	0e 94 97 b2 	call	0x1652e	; 0x1652e <_uart_print>
	sprintf_P(strSend,PSTR("%s56"),strServerIP);
   136a0:	00 d0       	rcall	.+0      	; 0x136a2 <sendMessage56+0x9e>
   136a2:	00 d0       	rcall	.+0      	; 0x136a4 <sendMessage56+0xa0>
   136a4:	00 d0       	rcall	.+0      	; 0x136a6 <sendMessage56+0xa2>
   136a6:	ed b7       	in	r30, 0x3d	; 61
   136a8:	fe b7       	in	r31, 0x3e	; 62
   136aa:	31 96       	adiw	r30, 0x01	; 1
   136ac:	ad b7       	in	r26, 0x3d	; 61
   136ae:	be b7       	in	r27, 0x3e	; 62
   136b0:	12 96       	adiw	r26, 0x02	; 2
   136b2:	1c 93       	st	X, r17
   136b4:	0e 93       	st	-X, r16
   136b6:	11 97       	sbiw	r26, 0x01	; 1
   136b8:	8d e5       	ldi	r24, 0x5D	; 93
   136ba:	91 e2       	ldi	r25, 0x21	; 33
   136bc:	93 83       	std	Z+3, r25	; 0x03
   136be:	82 83       	std	Z+2, r24	; 0x02
   136c0:	8b ee       	ldi	r24, 0xEB	; 235
   136c2:	99 e0       	ldi	r25, 0x09	; 9
   136c4:	95 83       	std	Z+5, r25	; 0x05
   136c6:	84 83       	std	Z+4, r24	; 0x04
   136c8:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    _uart_print(1, 0,strSend);
   136cc:	8d b7       	in	r24, 0x3d	; 61
   136ce:	9e b7       	in	r25, 0x3e	; 62
   136d0:	06 96       	adiw	r24, 0x06	; 6
   136d2:	0f b6       	in	r0, 0x3f	; 63
   136d4:	f8 94       	cli
   136d6:	9e bf       	out	0x3e, r25	; 62
   136d8:	0f be       	out	0x3f, r0	; 63
   136da:	8d bf       	out	0x3d, r24	; 61
   136dc:	81 e0       	ldi	r24, 0x01	; 1
   136de:	60 e0       	ldi	r22, 0x00	; 0
   136e0:	a8 01       	movw	r20, r16
   136e2:	0e 94 97 b2 	call	0x1652e	; 0x1652e <_uart_print>
    sprintf_P(strSend,PSTR("%s"),strCardID);
   136e6:	00 d0       	rcall	.+0      	; 0x136e8 <sendMessage56+0xe4>
   136e8:	00 d0       	rcall	.+0      	; 0x136ea <sendMessage56+0xe6>
   136ea:	00 d0       	rcall	.+0      	; 0x136ec <sendMessage56+0xe8>
   136ec:	ed b7       	in	r30, 0x3d	; 61
   136ee:	fe b7       	in	r31, 0x3e	; 62
   136f0:	31 96       	adiw	r30, 0x01	; 1
   136f2:	ad b7       	in	r26, 0x3d	; 61
   136f4:	be b7       	in	r27, 0x3e	; 62
   136f6:	12 96       	adiw	r26, 0x02	; 2
   136f8:	1c 93       	st	X, r17
   136fa:	0e 93       	st	-X, r16
   136fc:	11 97       	sbiw	r26, 0x01	; 1
   136fe:	8a e5       	ldi	r24, 0x5A	; 90
   13700:	91 e2       	ldi	r25, 0x21	; 33
   13702:	93 83       	std	Z+3, r25	; 0x03
   13704:	82 83       	std	Z+2, r24	; 0x02
   13706:	81 e6       	ldi	r24, 0x61	; 97
   13708:	9d e0       	ldi	r25, 0x0D	; 13
   1370a:	95 83       	std	Z+5, r25	; 0x05
   1370c:	84 83       	std	Z+4, r24	; 0x04
   1370e:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
    _uart_print(1, 0,strSend);	
   13712:	8d b7       	in	r24, 0x3d	; 61
   13714:	9e b7       	in	r25, 0x3e	; 62
   13716:	06 96       	adiw	r24, 0x06	; 6
   13718:	0f b6       	in	r0, 0x3f	; 63
   1371a:	f8 94       	cli
   1371c:	9e bf       	out	0x3e, r25	; 62
   1371e:	0f be       	out	0x3f, r0	; 63
   13720:	8d bf       	out	0x3d, r24	; 61
   13722:	81 e0       	ldi	r24, 0x01	; 1
   13724:	60 e0       	ldi	r22, 0x00	; 0
   13726:	a8 01       	movw	r20, r16
   13728:	0e 94 97 b2 	call	0x1652e	; 0x1652e <_uart_print>

	_uart_printf(1,0,PSTR("AF968CFFB"));
   1372c:	81 e0       	ldi	r24, 0x01	; 1
   1372e:	60 e0       	ldi	r22, 0x00	; 0
   13730:	40 e5       	ldi	r20, 0x50	; 80
   13732:	51 e2       	ldi	r21, 0x21	; 33
   13734:	0e 94 bf b2 	call	0x1657e	; 0x1657e <_uart_printf>
	_uart(1, 1,0x02);
   13738:	81 e0       	ldi	r24, 0x01	; 1
   1373a:	61 e0       	ldi	r22, 0x01	; 1
   1373c:	42 e0       	ldi	r20, 0x02	; 2
   1373e:	0e 94 7a b2 	call	0x164f4	; 0x164f4 <_uart>
}
   13742:	ec 96       	adiw	r28, 0x3c	; 60
   13744:	0f b6       	in	r0, 0x3f	; 63
   13746:	f8 94       	cli
   13748:	de bf       	out	0x3e, r29	; 62
   1374a:	0f be       	out	0x3f, r0	; 63
   1374c:	cd bf       	out	0x3d, r28	; 61
   1374e:	cf 91       	pop	r28
   13750:	df 91       	pop	r29
   13752:	1f 91       	pop	r17
   13754:	0f 91       	pop	r16
   13756:	08 95       	ret

00013758 <FMenuLocalAccount>:
		 }
	 else PORTG=PORTG|0x02;
}


char FMenuLocalAccount(){
   13758:	af 92       	push	r10
   1375a:	bf 92       	push	r11
   1375c:	cf 92       	push	r12
   1375e:	df 92       	push	r13
   13760:	ef 92       	push	r14
   13762:	ff 92       	push	r15
   13764:	0f 93       	push	r16
   13766:	1f 93       	push	r17
   13768:	df 93       	push	r29
   1376a:	cf 93       	push	r28
   1376c:	cd b7       	in	r28, 0x3d	; 61
   1376e:	de b7       	in	r29, 0x3e	; 62
   13770:	a9 97       	sbiw	r28, 0x29	; 41
   13772:	0f b6       	in	r0, 0x3f	; 63
   13774:	f8 94       	cli
   13776:	de bf       	out	0x3e, r29	; 62
   13778:	0f be       	out	0x3f, r0	; 63
   1377a:	cd bf       	out	0x3d, r28	; 61
       char strName[21];//,strPumpL[3],strPumpR[3];
       char Result;

	   Result=MENU_NONE;
	                                 //|   Local Account   |          
	       switch(stLocalAccount){   //|ID: ACD12345       |
   1377c:	80 91 5c 01 	lds	r24, 0x015C
   13780:	90 e0       	ldi	r25, 0x00	; 0
   13782:	fc 01       	movw	r30, r24
   13784:	31 97       	sbiw	r30, 0x01	; 1
   13786:	ef 31       	cpi	r30, 0x1F	; 31
   13788:	f1 05       	cpc	r31, r1
   1378a:	10 f0       	brcs	.+4      	; 0x13790 <FMenuLocalAccount+0x38>
   1378c:	0c 94 d8 a5 	jmp	0x14bb0	; 0x14bb0 <FMenuLocalAccount+0x1458>
   13790:	eb 50       	subi	r30, 0x0B	; 11
   13792:	ff 4f       	sbci	r31, 0xFF	; 255
   13794:	ee 0f       	add	r30, r30
   13796:	ff 1f       	adc	r31, r31
   13798:	05 90       	lpm	r0, Z+
   1379a:	f4 91       	lpm	r31, Z+
   1379c:	e0 2d       	mov	r30, r0
   1379e:	09 94       	ijmp
     }      
}

void BackLightTrig(){
     //TimBackLight=0;
__key_light = 1; __key_lgtcnt = 0; PORTG=PORTG&0b11111101;
   137a0:	81 e0       	ldi	r24, 0x01	; 1
   137a2:	80 93 bf 03 	sts	0x03BF, r24
   137a6:	10 92 c0 03 	sts	0x03C0, r1
   137aa:	80 91 65 00 	lds	r24, 0x0065
   137ae:	8d 7f       	andi	r24, 0xFD	; 253
   137b0:	80 93 65 00 	sts	0x0065, r24
   137b4:	20 e0       	ldi	r18, 0x00	; 0
   137b6:	30 e0       	ldi	r19, 0x00	; 0
}

void ViewCardID(){//+12345678 -->12345678
     char i;
	 for(i=0;i<8;i++){         //00000000000012345678
		strCardID[i]=strRFID[i];
   137b8:	f9 01       	movw	r30, r18
   137ba:	ef 59       	subi	r30, 0x9F	; 159
   137bc:	f2 4f       	sbci	r31, 0xF2	; 242
   137be:	d9 01       	movw	r26, r18
   137c0:	a4 5d       	subi	r26, 0xD4	; 212
   137c2:	b1 4f       	sbci	r27, 0xF1	; 241
   137c4:	8c 91       	ld	r24, X
   137c6:	80 83       	st	Z, r24
   137c8:	2f 5f       	subi	r18, 0xFF	; 255
   137ca:	3f 4f       	sbci	r19, 0xFF	; 255

}

void ViewCardID(){//+12345678 -->12345678
     char i;
	 for(i=0;i<8;i++){         //00000000000012345678
   137cc:	28 30       	cpi	r18, 0x08	; 8
   137ce:	31 05       	cpc	r19, r1
   137d0:	99 f7       	brne	.-26     	; 0x137b8 <FMenuLocalAccount+0x60>
		strCardID[i]=strRFID[i];
	 }strCardID[8]=0;     
   137d2:	10 92 69 0d 	sts	0x0D69, r1
	       switch(stLocalAccount){   //|ID: ACD12345       |
	       case laInit:              //|Process ...        |
		        //Process RFID Data  //|                   |
				//UpdateCardID();
                BackLightTrig();ViewCardID();
	            lcd_clear();
   137d6:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
	            lcd_printf(1,1,PSTR("   Local Account   "));
   137da:	81 e0       	ldi	r24, 0x01	; 1
   137dc:	61 e0       	ldi	r22, 0x01	; 1
   137de:	4a ea       	ldi	r20, 0xAA	; 170
   137e0:	50 e2       	ldi	r21, 0x20	; 32
   137e2:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
	            sprintf_P(lcdteks,PSTR("ID:%s"),strCardID);lcd_print(2,1,lcdteks);
   137e6:	00 d0       	rcall	.+0      	; 0x137e8 <FMenuLocalAccount+0x90>
   137e8:	00 d0       	rcall	.+0      	; 0x137ea <FMenuLocalAccount+0x92>
   137ea:	00 d0       	rcall	.+0      	; 0x137ec <FMenuLocalAccount+0x94>
   137ec:	ed b7       	in	r30, 0x3d	; 61
   137ee:	fe b7       	in	r31, 0x3e	; 62
   137f0:	31 96       	adiw	r30, 0x01	; 1
   137f2:	8e 01       	movw	r16, r28
   137f4:	0f 5f       	subi	r16, 0xFF	; 255
   137f6:	1f 4f       	sbci	r17, 0xFF	; 255
   137f8:	ad b7       	in	r26, 0x3d	; 61
   137fa:	be b7       	in	r27, 0x3e	; 62
   137fc:	12 96       	adiw	r26, 0x02	; 2
   137fe:	1c 93       	st	X, r17
   13800:	0e 93       	st	-X, r16
   13802:	11 97       	sbiw	r26, 0x01	; 1
   13804:	84 ea       	ldi	r24, 0xA4	; 164
   13806:	90 e2       	ldi	r25, 0x20	; 32
   13808:	93 83       	std	Z+3, r25	; 0x03
   1380a:	82 83       	std	Z+2, r24	; 0x02
   1380c:	81 e6       	ldi	r24, 0x61	; 97
   1380e:	9d e0       	ldi	r25, 0x0D	; 13
   13810:	95 83       	std	Z+5, r25	; 0x05
   13812:	84 83       	std	Z+4, r24	; 0x04
   13814:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
   13818:	ed b7       	in	r30, 0x3d	; 61
   1381a:	fe b7       	in	r31, 0x3e	; 62
   1381c:	36 96       	adiw	r30, 0x06	; 6
   1381e:	0f b6       	in	r0, 0x3f	; 63
   13820:	f8 94       	cli
   13822:	fe bf       	out	0x3e, r31	; 62
   13824:	0f be       	out	0x3f, r0	; 63
   13826:	ed bf       	out	0x3d, r30	; 61
   13828:	82 e0       	ldi	r24, 0x02	; 2
   1382a:	61 e0       	ldi	r22, 0x01	; 1
   1382c:	a8 01       	movw	r20, r16
   1382e:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
                lcd_printf(3,1,PSTR("Proses"));
   13832:	83 e0       	ldi	r24, 0x03	; 3
   13834:	61 e0       	ldi	r22, 0x01	; 1
   13836:	4d e9       	ldi	r20, 0x9D	; 157
   13838:	50 e2       	ldi	r21, 0x20	; 32
   1383a:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
				iPos=0;iLoop=0;
   1383e:	10 92 a3 03 	sts	0x03A3, r1
   13842:	10 92 73 03 	sts	0x0373, r1
   13846:	10 92 72 03 	sts	0x0372, r1
				IsFullAuthorized=False;
   1384a:	10 92 74 03 	sts	0x0374, r1
		        stLocalAccount=laSendID;
   1384e:	82 e0       	ldi	r24, 0x02	; 2
   13850:	dc c6       	rjmp	.+3512   	; 0x1460a <FMenuLocalAccount+0xeb2>
				break;         
           case laSendID://sendMessage56 
				IsMessage57=False;
   13852:	10 92 bc 01 	sts	0x01BC, r1
                sendMessage56();
   13856:	0e 94 02 9b 	call	0x13604	; 0x13604 <sendMessage56>
				iWait=0;iLoop=0;iPos=0;
   1385a:	10 92 a2 03 	sts	0x03A2, r1
   1385e:	10 92 73 03 	sts	0x0373, r1
   13862:	10 92 72 03 	sts	0x0372, r1
   13866:	10 92 a3 03 	sts	0x03A3, r1
				stLocalAccount=laWaitMessage57;
   1386a:	83 e0       	ldi	r24, 0x03	; 3
   1386c:	ce c6       	rjmp	.+3484   	; 0x1460a <FMenuLocalAccount+0xeb2>
		        break;
           case laWaitMessage57:
		        iLoop++;
   1386e:	80 91 72 03 	lds	r24, 0x0372
   13872:	90 91 73 03 	lds	r25, 0x0373
   13876:	01 96       	adiw	r24, 0x01	; 1
   13878:	90 93 73 03 	sts	0x0373, r25
   1387c:	80 93 72 03 	sts	0x0372, r24
				if ((iLoop%MSG_WAIT_TIMOUT)==0){
   13880:	68 e9       	ldi	r22, 0x98	; 152
   13882:	7a e3       	ldi	r23, 0x3A	; 58
   13884:	0e 94 38 b7 	call	0x16e70	; 0x16e70 <__udivmodhi4>
   13888:	89 2b       	or	r24, r25
   1388a:	e1 f4       	brne	.+56     	; 0x138c4 <FMenuLocalAccount+0x16c>
				   if (iPos<5){
   1388c:	60 91 a3 03 	lds	r22, 0x03A3
   13890:	65 30       	cpi	r22, 0x05	; 5
   13892:	58 f4       	brcc	.+22     	; 0x138aa <FMenuLocalAccount+0x152>
					   lcd_put(3,(8+iPos),'.');
   13894:	68 5f       	subi	r22, 0xF8	; 248
   13896:	83 e0       	ldi	r24, 0x03	; 3
   13898:	4e e2       	ldi	r20, 0x2E	; 46
   1389a:	0e 94 7f ad 	call	0x15afe	; 0x15afe <lcd_put>
				       iPos++;
   1389e:	80 91 a3 03 	lds	r24, 0x03A3
   138a2:	8f 5f       	subi	r24, 0xFF	; 255
   138a4:	80 93 a3 03 	sts	0x03A3, r24
   138a8:	0d c0       	rjmp	.+26     	; 0x138c4 <FMenuLocalAccount+0x16c>
					   }
				   else{
				       iPos=0;
   138aa:	10 92 a3 03 	sts	0x03A3, r1
					   lcd_printf(3,(9+iPos),PSTR("       "));
   138ae:	83 e0       	ldi	r24, 0x03	; 3
   138b0:	69 e0       	ldi	r22, 0x09	; 9
   138b2:	45 e9       	ldi	r20, 0x95	; 149
   138b4:	50 e2       	ldi	r21, 0x20	; 32
   138b6:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
					   iWait++;
   138ba:	80 91 a2 03 	lds	r24, 0x03A2
   138be:	8f 5f       	subi	r24, 0xFF	; 255
   138c0:	80 93 a2 03 	sts	0x03A2, r24
					   }
				}
				if (iWait>3){
   138c4:	80 91 a2 03 	lds	r24, 0x03A2
   138c8:	84 30       	cpi	r24, 0x04	; 4
   138ca:	78 f0       	brcs	.+30     	; 0x138ea <FMenuLocalAccount+0x192>
				    stLocalAccount=laConTimout;
   138cc:	84 e0       	ldi	r24, 0x04	; 4
   138ce:	80 93 5c 01 	sts	0x015C, r24
					TimLocAcc=0;
   138d2:	10 92 d3 01 	sts	0x01D3, r1
   138d6:	10 92 d2 01 	sts	0x01D2, r1
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   138da:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   138dc:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   138de:	82 e0       	ldi	r24, 0x02	; 2
   138e0:	90 e0       	ldi	r25, 0x00	; 0
   138e2:	90 93 d7 01 	sts	0x01D7, r25
   138e6:	80 93 d6 01 	sts	0x01D6, r24
				if (iWait>3){
				    stLocalAccount=laConTimout;
					TimLocAcc=0;
					system_beep(2);
				    }
				if (IsMessage57==True){
   138ea:	80 91 bc 01 	lds	r24, 0x01BC
   138ee:	81 30       	cpi	r24, 0x01	; 1
   138f0:	11 f0       	breq	.+4      	; 0x138f6 <FMenuLocalAccount+0x19e>
   138f2:	0c 94 d8 a5 	jmp	0x14bb0	; 0x14bb0 <FMenuLocalAccount+0x1458>
				    IsMessage57=False;
   138f6:	10 92 bc 01 	sts	0x01BC, r1
				    stLocalAccount=laProcMessage57;
   138fa:	85 e0       	ldi	r24, 0x05	; 5
   138fc:	86 c6       	rjmp	.+3340   	; 0x1460a <FMenuLocalAccount+0xeb2>
					}
		        break;
           case laConTimout:
		        //IsErrorTCPIP=True;
				lcd_printf(3,1,PSTR("Sending Failed      "));
   138fe:	83 e0       	ldi	r24, 0x03	; 3
   13900:	61 e0       	ldi	r22, 0x01	; 1
   13902:	40 e8       	ldi	r20, 0x80	; 128
   13904:	50 e2       	ldi	r21, 0x20	; 32
   13906:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
				lcd_printf(4,1,PSTR("TCP/IP Error        "));
   1390a:	84 e0       	ldi	r24, 0x04	; 4
   1390c:	61 e0       	ldi	r22, 0x01	; 1
   1390e:	4b e6       	ldi	r20, 0x6B	; 107
   13910:	50 e2       	ldi	r21, 0x20	; 32
   13912:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
                if (TimLocAcc>2)  stLocalAccount=laExitLocAcc;
   13916:	80 91 d2 01 	lds	r24, 0x01D2
   1391a:	90 91 d3 01 	lds	r25, 0x01D3
   1391e:	03 97       	sbiw	r24, 0x03	; 3
   13920:	10 f4       	brcc	.+4      	; 0x13926 <FMenuLocalAccount+0x1ce>
   13922:	0c 94 d8 a5 	jmp	0x14bb0	; 0x14bb0 <FMenuLocalAccount+0x1458>
   13926:	0c 94 cf a5 	jmp	0x14b9e	; 0x14b9e <FMenuLocalAccount+0x1446>
		        break;
           case laProcMessage57://Process Message
				lcd_printf(3,1,PSTR("Data Received       "));
   1392a:	83 e0       	ldi	r24, 0x03	; 3
   1392c:	61 e0       	ldi	r22, 0x01	; 1
   1392e:	46 e5       	ldi	r20, 0x56	; 86
   13930:	50 e2       	ldi	r21, 0x20	; 32
   13932:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
				LocAccStatus=GetLocAccStatus(procMessage57());
   13936:	0e 94 ba 24 	call	0x4974	; 0x4974 <procMessage57>


char GetLocAccStatus(char paramMessage57){
     char Result;
	 Result=LA_NONE;
     if (paramMessage57==MSG57_INVALID)Result=LA_INVALID;
   1393a:	81 30       	cpi	r24, 0x01	; 1
   1393c:	29 f0       	breq	.+10     	; 0x13948 <FMenuLocalAccount+0x1f0>
	 else
     if (paramMessage57==MSG57_VALID)Result=LA_VALID;
   1393e:	82 30       	cpi	r24, 0x02	; 2
   13940:	19 f0       	breq	.+6      	; 0x13948 <FMenuLocalAccount+0x1f0>
	 else
     if (paramMessage57==MSG57_LIMITED)Result=LA_LIMITED;
   13942:	83 30       	cpi	r24, 0x03	; 3
   13944:	09 f0       	breq	.+2      	; 0x13948 <FMenuLocalAccount+0x1f0>
   13946:	80 e0       	ldi	r24, 0x00	; 0
				lcd_printf(4,1,PSTR("TCP/IP Error        "));
                if (TimLocAcc>2)  stLocalAccount=laExitLocAcc;
		        break;
           case laProcMessage57://Process Message
				lcd_printf(3,1,PSTR("Data Received       "));
				LocAccStatus=GetLocAccStatus(procMessage57());
   13948:	80 93 a4 03 	sts	0x03A4, r24
				TimLocAcc=0;
   1394c:	10 92 d3 01 	sts	0x01D3, r1
   13950:	10 92 d2 01 	sts	0x01D2, r1
				stLocalAccount=laDispStatus;
   13954:	86 e0       	ldi	r24, 0x06	; 6
   13956:	59 c6       	rjmp	.+3250   	; 0x1460a <FMenuLocalAccount+0xeb2>
		        break;
           case laDispStatus://Display Status
		        if (LocAccStatus==LA_INVALID){
   13958:	80 91 a4 03 	lds	r24, 0x03A4
   1395c:	81 30       	cpi	r24, 0x01	; 1
   1395e:	29 f4       	brne	.+10     	; 0x1396a <FMenuLocalAccount+0x212>
					lcd_printf(3,1,PSTR("Tidak Terdaftar     "));    
   13960:	83 e0       	ldi	r24, 0x03	; 3
   13962:	61 e0       	ldi	r22, 0x01	; 1
   13964:	41 e4       	ldi	r20, 0x41	; 65
   13966:	50 e2       	ldi	r21, 0x20	; 32
   13968:	0d c0       	rjmp	.+26     	; 0x13984 <FMenuLocalAccount+0x22c>
					TimLocAcc=0;
				    stLocalAccount=laDelayExit;
				}
				else
                if (LocAccStatus==LA_VALID) {
   1396a:	82 30       	cpi	r24, 0x02	; 2
   1396c:	31 f4       	brne	.+12     	; 0x1397a <FMenuLocalAccount+0x222>
				    stLocalAccount=laDispValid; 
   1396e:	87 e0       	ldi	r24, 0x07	; 7
   13970:	80 93 5c 01 	sts	0x015C, r24
					lcd_clear();
   13974:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
   13978:	0e c0       	rjmp	.+28     	; 0x13996 <FMenuLocalAccount+0x23e>
					}
				else
                if (LocAccStatus==LA_LIMITED){
   1397a:	83 30       	cpi	r24, 0x03	; 3
   1397c:	61 f4       	brne	.+24     	; 0x13996 <FMenuLocalAccount+0x23e>
					lcd_printf(3,1,PSTR("Kartu Terbatas      "));    
   1397e:	61 e0       	ldi	r22, 0x01	; 1
   13980:	4c e2       	ldi	r20, 0x2C	; 44
   13982:	50 e2       	ldi	r21, 0x20	; 32
   13984:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
					TimLocAcc=0;
   13988:	10 92 d3 01 	sts	0x01D3, r1
   1398c:	10 92 d2 01 	sts	0x01D2, r1
				    stLocalAccount=laDelayExit;
   13990:	8e e1       	ldi	r24, 0x1E	; 30
   13992:	80 93 5c 01 	sts	0x015C, r24
				}
                if (TimLocAcc>5)stLocalAccount=laExitLocAcc;
   13996:	80 91 d2 01 	lds	r24, 0x01D2
   1399a:	90 91 d3 01 	lds	r25, 0x01D3
   1399e:	06 97       	sbiw	r24, 0x06	; 6
   139a0:	10 f4       	brcc	.+4      	; 0x139a6 <FMenuLocalAccount+0x24e>
   139a2:	0c 94 d8 a5 	jmp	0x14bb0	; 0x14bb0 <FMenuLocalAccount+0x1458>
   139a6:	0c 94 cf a5 	jmp	0x14b9e	; 0x14b9e <FMenuLocalAccount+0x1446>
		        break;
           case laDispValid://Display VALID ID
		        lcd_clear();
   139aa:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
				sprintf_P(strBalanceValue,PSTR("%s"),strBalance);
   139ae:	00 d0       	rcall	.+0      	; 0x139b0 <FMenuLocalAccount+0x258>
   139b0:	00 d0       	rcall	.+0      	; 0x139b2 <FMenuLocalAccount+0x25a>
   139b2:	00 d0       	rcall	.+0      	; 0x139b4 <FMenuLocalAccount+0x25c>
   139b4:	ed b7       	in	r30, 0x3d	; 61
   139b6:	fe b7       	in	r31, 0x3e	; 62
   139b8:	31 96       	adiw	r30, 0x01	; 1
   139ba:	8a ef       	ldi	r24, 0xFA	; 250
   139bc:	9d e0       	ldi	r25, 0x0D	; 13
   139be:	ad b7       	in	r26, 0x3d	; 61
   139c0:	be b7       	in	r27, 0x3e	; 62
   139c2:	12 96       	adiw	r26, 0x02	; 2
   139c4:	9c 93       	st	X, r25
   139c6:	8e 93       	st	-X, r24
   139c8:	11 97       	sbiw	r26, 0x01	; 1
   139ca:	89 e2       	ldi	r24, 0x29	; 41
   139cc:	90 e2       	ldi	r25, 0x20	; 32
   139ce:	93 83       	std	Z+3, r25	; 0x03
   139d0:	82 83       	std	Z+2, r24	; 0x02
   139d2:	03 ed       	ldi	r16, 0xD3	; 211
   139d4:	1d e0       	ldi	r17, 0x0D	; 13
   139d6:	15 83       	std	Z+5, r17	; 0x05
   139d8:	04 83       	std	Z+4, r16	; 0x04
   139da:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
				FormatCurrency(strBalance);
   139de:	ed b7       	in	r30, 0x3d	; 61
   139e0:	fe b7       	in	r31, 0x3e	; 62
   139e2:	36 96       	adiw	r30, 0x06	; 6
   139e4:	0f b6       	in	r0, 0x3f	; 63
   139e6:	f8 94       	cli
   139e8:	fe bf       	out	0x3e, r31	; 62
   139ea:	0f be       	out	0x3f, r0	; 63
   139ec:	ed bf       	out	0x3d, r30	; 61
   139ee:	c8 01       	movw	r24, r16
   139f0:	0e 94 49 30 	call	0x6092	; 0x6092 <FormatCurrency>
   139f4:	20 e0       	ldi	r18, 0x00	; 0
   139f6:	30 e0       	ldi	r19, 0x00	; 0


void StringCopy(char *Source,char *Dest,char Length){
     char i;
	 for (i=0;i<Length;i++){
	     Dest[i]=Source[i];
   139f8:	65 e1       	ldi	r22, 0x15	; 21
   139fa:	e6 2e       	mov	r14, r22
   139fc:	f1 2c       	mov	r15, r1
   139fe:	ec 0e       	add	r14, r28
   13a00:	fd 1e       	adc	r15, r29
   13a02:	f7 01       	movw	r30, r14
   13a04:	e2 0f       	add	r30, r18
   13a06:	f3 1f       	adc	r31, r19
   13a08:	d9 01       	movw	r26, r18
   13a0a:	ac 5f       	subi	r26, 0xFC	; 252
   13a0c:	ba 4f       	sbci	r27, 0xFA	; 250
   13a0e:	8c 91       	ld	r24, X
   13a10:	80 83       	st	Z, r24
   13a12:	2f 5f       	subi	r18, 0xFF	; 255
   13a14:	3f 4f       	sbci	r19, 0xFF	; 255
//Message 56


void StringCopy(char *Source,char *Dest,char Length){
     char i;
	 for (i=0;i<Length;i++){
   13a16:	24 31       	cpi	r18, 0x14	; 20
   13a18:	31 05       	cpc	r19, r1
   13a1a:	99 f7       	brne	.-26     	; 0x13a02 <FMenuLocalAccount+0x2aa>
	     Dest[i]=Source[i];
	 }Dest[Length]=0;
   13a1c:	19 a6       	std	Y+41, r1	; 0x29
		        lcd_clear();
				sprintf_P(strBalanceValue,PSTR("%s"),strBalance);
				FormatCurrency(strBalance);

		        StringCopy(strCardHolder,strName,20);  				                                                        
		        sprintf_P(lcdteks,PSTR("%s"),strCompName);               lcd_print(1,1,lcdteks);   //[CompName]
   13a1e:	00 d0       	rcall	.+0      	; 0x13a20 <FMenuLocalAccount+0x2c8>
   13a20:	00 d0       	rcall	.+0      	; 0x13a22 <FMenuLocalAccount+0x2ca>
   13a22:	00 d0       	rcall	.+0      	; 0x13a24 <FMenuLocalAccount+0x2cc>
   13a24:	ed b7       	in	r30, 0x3d	; 61
   13a26:	fe b7       	in	r31, 0x3e	; 62
   13a28:	31 96       	adiw	r30, 0x01	; 1
   13a2a:	8e 01       	movw	r16, r28
   13a2c:	0f 5f       	subi	r16, 0xFF	; 255
   13a2e:	1f 4f       	sbci	r17, 0xFF	; 255
   13a30:	ad b7       	in	r26, 0x3d	; 61
   13a32:	be b7       	in	r27, 0x3e	; 62
   13a34:	12 96       	adiw	r26, 0x02	; 2
   13a36:	1c 93       	st	X, r17
   13a38:	0e 93       	st	-X, r16
   13a3a:	11 97       	sbiw	r26, 0x01	; 1
   13a3c:	86 e2       	ldi	r24, 0x26	; 38
   13a3e:	90 e2       	ldi	r25, 0x20	; 32
   13a40:	93 83       	std	Z+3, r25	; 0x03
   13a42:	82 83       	std	Z+2, r24	; 0x02
   13a44:	8c e5       	ldi	r24, 0x5C	; 92
   13a46:	99 e0       	ldi	r25, 0x09	; 9
   13a48:	95 83       	std	Z+5, r25	; 0x05
   13a4a:	84 83       	std	Z+4, r24	; 0x04
   13a4c:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
   13a50:	ed b7       	in	r30, 0x3d	; 61
   13a52:	fe b7       	in	r31, 0x3e	; 62
   13a54:	36 96       	adiw	r30, 0x06	; 6
   13a56:	0f b6       	in	r0, 0x3f	; 63
   13a58:	f8 94       	cli
   13a5a:	fe bf       	out	0x3e, r31	; 62
   13a5c:	0f be       	out	0x3f, r0	; 63
   13a5e:	ed bf       	out	0x3d, r30	; 61
   13a60:	81 e0       	ldi	r24, 0x01	; 1
   13a62:	61 e0       	ldi	r22, 0x01	; 1
   13a64:	a8 01       	movw	r20, r16
   13a66:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
                //sprintf(lcdteks,"%s %s",strCardID,strName);    lcd_print(2,1,lcdteks);   //[Card ID][Card Holder]
				sprintf_P(lcdteks,PSTR("%s"),strName);                   lcd_print(2,1,lcdteks);   //[Card ID][Card Holder]
   13a6a:	00 d0       	rcall	.+0      	; 0x13a6c <FMenuLocalAccount+0x314>
   13a6c:	00 d0       	rcall	.+0      	; 0x13a6e <FMenuLocalAccount+0x316>
   13a6e:	00 d0       	rcall	.+0      	; 0x13a70 <FMenuLocalAccount+0x318>
   13a70:	ed b7       	in	r30, 0x3d	; 61
   13a72:	fe b7       	in	r31, 0x3e	; 62
   13a74:	31 96       	adiw	r30, 0x01	; 1
   13a76:	ad b7       	in	r26, 0x3d	; 61
   13a78:	be b7       	in	r27, 0x3e	; 62
   13a7a:	12 96       	adiw	r26, 0x02	; 2
   13a7c:	1c 93       	st	X, r17
   13a7e:	0e 93       	st	-X, r16
   13a80:	11 97       	sbiw	r26, 0x01	; 1
   13a82:	83 e2       	ldi	r24, 0x23	; 35
   13a84:	90 e2       	ldi	r25, 0x20	; 32
   13a86:	93 83       	std	Z+3, r25	; 0x03
   13a88:	82 83       	std	Z+2, r24	; 0x02
   13a8a:	f5 82       	std	Z+5, r15	; 0x05
   13a8c:	e4 82       	std	Z+4, r14	; 0x04
   13a8e:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
   13a92:	ed b7       	in	r30, 0x3d	; 61
   13a94:	fe b7       	in	r31, 0x3e	; 62
   13a96:	36 96       	adiw	r30, 0x06	; 6
   13a98:	0f b6       	in	r0, 0x3f	; 63
   13a9a:	f8 94       	cli
   13a9c:	fe bf       	out	0x3e, r31	; 62
   13a9e:	0f be       	out	0x3f, r0	; 63
   13aa0:	ed bf       	out	0x3d, r30	; 61
   13aa2:	82 e0       	ldi	r24, 0x02	; 2
   13aa4:	61 e0       	ldi	r22, 0x01	; 1
   13aa6:	a8 01       	movw	r20, r16
   13aa8:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
				sprintf_P(lcdteks,PSTR("%s %s"),strLicPlate,strBalance); lcd_print(3,1,lcdteks);   //[LicPlate][Balance] 
   13aac:	2d b7       	in	r18, 0x3d	; 61
   13aae:	3e b7       	in	r19, 0x3e	; 62
   13ab0:	28 50       	subi	r18, 0x08	; 8
   13ab2:	30 40       	sbci	r19, 0x00	; 0
   13ab4:	0f b6       	in	r0, 0x3f	; 63
   13ab6:	f8 94       	cli
   13ab8:	3e bf       	out	0x3e, r19	; 62
   13aba:	0f be       	out	0x3f, r0	; 63
   13abc:	2d bf       	out	0x3d, r18	; 61
   13abe:	ed b7       	in	r30, 0x3d	; 61
   13ac0:	fe b7       	in	r31, 0x3e	; 62
   13ac2:	31 96       	adiw	r30, 0x01	; 1
   13ac4:	ad b7       	in	r26, 0x3d	; 61
   13ac6:	be b7       	in	r27, 0x3e	; 62
   13ac8:	12 96       	adiw	r26, 0x02	; 2
   13aca:	1c 93       	st	X, r17
   13acc:	0e 93       	st	-X, r16
   13ace:	11 97       	sbiw	r26, 0x01	; 1
   13ad0:	8d e1       	ldi	r24, 0x1D	; 29
   13ad2:	90 e2       	ldi	r25, 0x20	; 32
   13ad4:	93 83       	std	Z+3, r25	; 0x03
   13ad6:	82 83       	std	Z+2, r24	; 0x02
   13ad8:	82 ed       	ldi	r24, 0xD2	; 210
   13ada:	9a e0       	ldi	r25, 0x0A	; 10
   13adc:	95 83       	std	Z+5, r25	; 0x05
   13ade:	84 83       	std	Z+4, r24	; 0x04
   13ae0:	83 ed       	ldi	r24, 0xD3	; 211
   13ae2:	9d e0       	ldi	r25, 0x0D	; 13
   13ae4:	97 83       	std	Z+7, r25	; 0x07
   13ae6:	86 83       	std	Z+6, r24	; 0x06
   13ae8:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
   13aec:	ed b7       	in	r30, 0x3d	; 61
   13aee:	fe b7       	in	r31, 0x3e	; 62
   13af0:	38 96       	adiw	r30, 0x08	; 8
   13af2:	0f b6       	in	r0, 0x3f	; 63
   13af4:	f8 94       	cli
   13af6:	fe bf       	out	0x3e, r31	; 62
   13af8:	0f be       	out	0x3f, r0	; 63
   13afa:	ed bf       	out	0x3d, r30	; 61
   13afc:	83 e0       	ldi	r24, 0x03	; 3
   13afe:	61 e0       	ldi	r22, 0x01	; 1
   13b00:	a8 01       	movw	r20, r16
   13b02:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
	            lcd_printf(4,1,PSTR("[*]Batal       [#]OK"));   //[*]Batal       [#]OK
   13b06:	84 e0       	ldi	r24, 0x04	; 4
   13b08:	61 e0       	ldi	r22, 0x01	; 1
   13b0a:	48 e0       	ldi	r20, 0x08	; 8
   13b0c:	50 e2       	ldi	r21, 0x20	; 32
   13b0e:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
				stLocalAccount=laDispValidInput;
   13b12:	88 e0       	ldi	r24, 0x08	; 8
   13b14:	7a c5       	rjmp	.+2804   	; 0x1460a <FMenuLocalAccount+0xeb2>
		        break;
           case laDispValidInput:
                KeyPressed=_key_scan(1);
   13b16:	81 e0       	ldi	r24, 0x01	; 1
   13b18:	0e 94 ab ae 	call	0x15d56	; 0x15d56 <_key_scan>
   13b1c:	80 93 9c 03 	sts	0x039C, r24
				if (KeyPressed==_KEY_ENTER) stLocalAccount=laSelectFIP;
   13b20:	87 3b       	cpi	r24, 0xB7	; 183
   13b22:	09 f4       	brne	.+2      	; 0x13b26 <FMenuLocalAccount+0x3ce>
   13b24:	84 c2       	rjmp	.+1288   	; 0x1402e <FMenuLocalAccount+0x8d6>
				else
				if (KeyPressed==_KEY_CANCEL)stLocalAccount=laExitLocAcc;
   13b26:	87 3e       	cpi	r24, 0xE7	; 231
   13b28:	11 f0       	breq	.+4      	; 0x13b2e <FMenuLocalAccount+0x3d6>
   13b2a:	0c 94 d8 a5 	jmp	0x14bb0	; 0x14bb0 <FMenuLocalAccount+0x1458>
   13b2e:	0c 94 cf a5 	jmp	0x14b9e	; 0x14b9e <FMenuLocalAccount+0x1446>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
   13b32:	82 e8       	ldi	r24, 0x82	; 130
   13b34:	93 e0       	ldi	r25, 0x03	; 3
   13b36:	65 e4       	ldi	r22, 0x45	; 69
   13b38:	70 e0       	ldi	r23, 0x00	; 0
   13b3a:	48 e0       	ldi	r20, 0x08	; 8
   13b3c:	50 e0       	ldi	r21, 0x00	; 0
   13b3e:	23 ef       	ldi	r18, 0xF3	; 243
   13b40:	32 e1       	ldi	r19, 0x12	; 18
   13b42:	0e 94 1f b4 	call	0x1683e	; 0x1683e <__eerd_block>
		        break;
           case laSelectFIP:       
		  		eeprom_read_block((void*) &FIP, (const void*) &DefPumpMap, 8);
				lcd_clear(); 
   13b46:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
				//for (iLoop=0;iLoop<8;iLoop++){
				//     if (FIP[iLoop]>16) FIP[iLoop]=0;
				//	 }
				for (iLoop=0;iLoop<4;iLoop++){
   13b4a:	10 92 73 03 	sts	0x0373, r1
   13b4e:	10 92 72 03 	sts	0x0372, r1
                     //leadingZero(FIP[iLoop],strPumpL);leadingZero(FIP[iLoop+4],strPumpR);
                     //sprintf_P(lcdteks,PSTR("%d.P%s | %d.P%s"),(iLoop+1),strPumpL,(iLoop+5),strPumpR);
					 sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d"),(iLoop+1),FIP[iLoop],(iLoop+5),FIP[iLoop+4]);
   13b52:	8e 01       	movw	r16, r28
   13b54:	0f 5f       	subi	r16, 0xFF	; 255
   13b56:	1f 4f       	sbci	r17, 0xFF	; 255
   13b58:	54 ef       	ldi	r21, 0xF4	; 244
   13b5a:	e5 2e       	mov	r14, r21
   13b5c:	5f e1       	ldi	r21, 0x1F	; 31
   13b5e:	f5 2e       	mov	r15, r21
   13b60:	41 c0       	rjmp	.+130    	; 0x13be4 <FMenuLocalAccount+0x48c>
   13b62:	8d b7       	in	r24, 0x3d	; 61
   13b64:	9e b7       	in	r25, 0x3e	; 62
   13b66:	0c 97       	sbiw	r24, 0x0c	; 12
   13b68:	0f b6       	in	r0, 0x3f	; 63
   13b6a:	f8 94       	cli
   13b6c:	9e bf       	out	0x3e, r25	; 62
   13b6e:	0f be       	out	0x3f, r0	; 63
   13b70:	8d bf       	out	0x3d, r24	; 61
   13b72:	ed b7       	in	r30, 0x3d	; 61
   13b74:	fe b7       	in	r31, 0x3e	; 62
   13b76:	31 96       	adiw	r30, 0x01	; 1
   13b78:	ad b7       	in	r26, 0x3d	; 61
   13b7a:	be b7       	in	r27, 0x3e	; 62
   13b7c:	12 96       	adiw	r26, 0x02	; 2
   13b7e:	1c 93       	st	X, r17
   13b80:	0e 93       	st	-X, r16
   13b82:	11 97       	sbiw	r26, 0x01	; 1
   13b84:	f3 82       	std	Z+3, r15	; 0x03
   13b86:	e2 82       	std	Z+2, r14	; 0x02
   13b88:	2f 5f       	subi	r18, 0xFF	; 255
   13b8a:	3f 4f       	sbci	r19, 0xFF	; 255
   13b8c:	35 83       	std	Z+5, r19	; 0x05
   13b8e:	24 83       	std	Z+4, r18	; 0x04
   13b90:	21 50       	subi	r18, 0x01	; 1
   13b92:	30 40       	sbci	r19, 0x00	; 0
   13b94:	d9 01       	movw	r26, r18
   13b96:	ae 57       	subi	r26, 0x7E	; 126
   13b98:	bc 4f       	sbci	r27, 0xFC	; 252
   13b9a:	8c 91       	ld	r24, X
   13b9c:	86 83       	std	Z+6, r24	; 0x06
   13b9e:	17 82       	std	Z+7, r1	; 0x07
   13ba0:	2b 5f       	subi	r18, 0xFB	; 251
   13ba2:	3f 4f       	sbci	r19, 0xFF	; 255
   13ba4:	31 87       	std	Z+9, r19	; 0x09
   13ba6:	20 87       	std	Z+8, r18	; 0x08
   13ba8:	14 96       	adiw	r26, 0x04	; 4
   13baa:	8c 91       	ld	r24, X
   13bac:	82 87       	std	Z+10, r24	; 0x0a
   13bae:	13 86       	std	Z+11, r1	; 0x0b
   13bb0:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
					 lcd_print((iLoop+1),1,lcdteks);
   13bb4:	ed b7       	in	r30, 0x3d	; 61
   13bb6:	fe b7       	in	r31, 0x3e	; 62
   13bb8:	3c 96       	adiw	r30, 0x0c	; 12
   13bba:	0f b6       	in	r0, 0x3f	; 63
   13bbc:	f8 94       	cli
   13bbe:	fe bf       	out	0x3e, r31	; 62
   13bc0:	0f be       	out	0x3f, r0	; 63
   13bc2:	ed bf       	out	0x3d, r30	; 61
   13bc4:	80 91 72 03 	lds	r24, 0x0372
   13bc8:	8f 5f       	subi	r24, 0xFF	; 255
   13bca:	61 e0       	ldi	r22, 0x01	; 1
   13bcc:	a8 01       	movw	r20, r16
   13bce:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
		  		eeprom_read_block((void*) &FIP, (const void*) &DefPumpMap, 8);
				lcd_clear(); 
				//for (iLoop=0;iLoop<8;iLoop++){
				//     if (FIP[iLoop]>16) FIP[iLoop]=0;
				//	 }
				for (iLoop=0;iLoop<4;iLoop++){
   13bd2:	80 91 72 03 	lds	r24, 0x0372
   13bd6:	90 91 73 03 	lds	r25, 0x0373
   13bda:	01 96       	adiw	r24, 0x01	; 1
   13bdc:	90 93 73 03 	sts	0x0373, r25
   13be0:	80 93 72 03 	sts	0x0372, r24
   13be4:	20 91 72 03 	lds	r18, 0x0372
   13be8:	30 91 73 03 	lds	r19, 0x0373
   13bec:	24 30       	cpi	r18, 0x04	; 4
   13bee:	31 05       	cpc	r19, r1
   13bf0:	08 f4       	brcc	.+2      	; 0x13bf4 <FMenuLocalAccount+0x49c>
   13bf2:	b7 cf       	rjmp	.-146    	; 0x13b62 <FMenuLocalAccount+0x40a>
                     //leadingZero(FIP[iLoop],strPumpL);leadingZero(FIP[iLoop+4],strPumpR);
                     //sprintf_P(lcdteks,PSTR("%d.P%s | %d.P%s"),(iLoop+1),strPumpL,(iLoop+5),strPumpR);
					 sprintf_P(lcdteks,PSTR("%d.P%.2d | %d.P%.2d"),(iLoop+1),FIP[iLoop],(iLoop+5),FIP[iLoop+4]);
					 lcd_print((iLoop+1),1,lcdteks);
					 }
		        lcd_printf(1,15,PSTR("FIP:_"));    //"1.P01 | 5.P05 FIP:_ "                                                                      
   13bf4:	81 e0       	ldi	r24, 0x01	; 1
   13bf6:	6f e0       	ldi	r22, 0x0F	; 15
   13bf8:	4e ee       	ldi	r20, 0xEE	; 238
   13bfa:	5f e1       	ldi	r21, 0x1F	; 31
   13bfc:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
				lcd_printf(2,15,PSTR("     "));    //"2.P02 | 6.P05       "
   13c00:	82 e0       	ldi	r24, 0x02	; 2
   13c02:	6f e0       	ldi	r22, 0x0F	; 15
   13c04:	48 ee       	ldi	r20, 0xE8	; 232
   13c06:	5f e1       	ldi	r21, 0x1F	; 31
   13c08:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
				lcd_printf(3,15,PSTR("#)OK "));    //"3.P03 | 7.P07 #)OK  "
   13c0c:	83 e0       	ldi	r24, 0x03	; 3
   13c0e:	6f e0       	ldi	r22, 0x0F	; 15
   13c10:	42 ee       	ldi	r20, 0xE2	; 226
   13c12:	5f e1       	ldi	r21, 0x1F	; 31
   13c14:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
	            lcd_printf(4,15,PSTR("*)Exit"));   //"4.P04 | 8.P08 *)Exit"				
   13c18:	84 e0       	ldi	r24, 0x04	; 4
   13c1a:	6f e0       	ldi	r22, 0x0F	; 15
   13c1c:	4b ed       	ldi	r20, 0xDB	; 219
   13c1e:	5f e1       	ldi	r21, 0x1F	; 31
   13c20:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
				//eeprom_read_block((void*) &FIP, (const void*) &DefPumpMap, 8);
				iLoop=0;
   13c24:	10 92 73 03 	sts	0x0373, r1
   13c28:	10 92 72 03 	sts	0x0372, r1
				stLocalAccount=laSelectFIPInput;
   13c2c:	8a e0       	ldi	r24, 0x0A	; 10
   13c2e:	ed c4       	rjmp	.+2522   	; 0x1460a <FMenuLocalAccount+0xeb2>
		        break; 
           case laSelectFIPInput:
			    //Blinking 50% _ 
			    iLoop++;
   13c30:	80 91 72 03 	lds	r24, 0x0372
   13c34:	90 91 73 03 	lds	r25, 0x0373
   13c38:	01 96       	adiw	r24, 0x01	; 1
   13c3a:	90 93 73 03 	sts	0x0373, r25
   13c3e:	80 93 72 03 	sts	0x0372, r24
			    //GetKeyPressed
			    KeyPressed=_key_scan(1);
   13c42:	81 e0       	ldi	r24, 0x01	; 1
   13c44:	0e 94 ab ae 	call	0x15d56	; 0x15d56 <_key_scan>
   13c48:	80 93 9c 03 	sts	0x039C, r24
			    KeyChar=_key_btn(KeyPressed);
   13c4c:	0e 94 0c ae 	call	0x15c18	; 0x15c18 <_key_btn>
   13c50:	98 2f       	mov	r25, r24
   13c52:	80 93 a1 03 	sts	0x03A1, r24
				if ((KeyChar>='1')&&(KeyChar<='8')){
   13c56:	81 53       	subi	r24, 0x31	; 49
   13c58:	88 30       	cpi	r24, 0x08	; 8
   13c5a:	60 f4       	brcc	.+24     	; 0x13c74 <FMenuLocalAccount+0x51c>
				    if (KeyCharLast!=KeyChar){
   13c5c:	80 91 5b 01 	lds	r24, 0x015B
   13c60:	89 17       	cp	r24, r25
   13c62:	41 f0       	breq	.+16     	; 0x13c74 <FMenuLocalAccount+0x51c>
					    KeyCharLast=KeyChar;
   13c64:	90 93 5b 01 	sts	0x015B, r25
						iLoop=1000;
   13c68:	88 ee       	ldi	r24, 0xE8	; 232
   13c6a:	93 e0       	ldi	r25, 0x03	; 3
   13c6c:	90 93 73 03 	sts	0x0373, r25
   13c70:	80 93 72 03 	sts	0x0372, r24
                    }
				}

			    if ((iLoop%2000)==0){
   13c74:	80 91 72 03 	lds	r24, 0x0372
   13c78:	90 91 73 03 	lds	r25, 0x0373
   13c7c:	60 ed       	ldi	r22, 0xD0	; 208
   13c7e:	77 e0       	ldi	r23, 0x07	; 7
   13c80:	0e 94 38 b7 	call	0x16e70	; 0x16e70 <__udivmodhi4>
   13c84:	89 2b       	or	r24, r25
   13c86:	39 f4       	brne	.+14     	; 0x13c96 <FMenuLocalAccount+0x53e>
			       lcd_xy(1,19);_lcd('_'); 
   13c88:	81 e0       	ldi	r24, 0x01	; 1
   13c8a:	63 e1       	ldi	r22, 0x13	; 19
   13c8c:	0e 94 f1 ac 	call	0x159e2	; 0x159e2 <lcd_xy>
   13c90:	8f e5       	ldi	r24, 0x5F	; 95
   13c92:	0e 94 cb ac 	call	0x15996	; 0x15996 <_lcd>
			    }
			    if ((iLoop%2000)==1000){
   13c96:	80 91 72 03 	lds	r24, 0x0372
   13c9a:	90 91 73 03 	lds	r25, 0x0373
   13c9e:	60 ed       	ldi	r22, 0xD0	; 208
   13ca0:	77 e0       	ldi	r23, 0x07	; 7
   13ca2:	0e 94 38 b7 	call	0x16e70	; 0x16e70 <__udivmodhi4>
   13ca6:	88 5e       	subi	r24, 0xE8	; 232
   13ca8:	93 40       	sbci	r25, 0x03	; 3
   13caa:	41 f4       	brne	.+16     	; 0x13cbc <FMenuLocalAccount+0x564>
			       lcd_xy(1,19);_lcd(KeyCharLast); 
   13cac:	81 e0       	ldi	r24, 0x01	; 1
   13cae:	63 e1       	ldi	r22, 0x13	; 19
   13cb0:	0e 94 f1 ac 	call	0x159e2	; 0x159e2 <lcd_xy>
   13cb4:	80 91 5b 01 	lds	r24, 0x015B
   13cb8:	0e 94 cb ac 	call	0x15996	; 0x15996 <_lcd>
			    }
				if (((KeyChar>='1')&&(KeyChar<='8'))||
   13cbc:	80 91 a1 03 	lds	r24, 0x03A1
   13cc0:	81 53       	subi	r24, 0x31	; 49
   13cc2:	88 30       	cpi	r24, 0x08	; 8
   13cc4:	50 f0       	brcs	.+20     	; 0x13cda <FMenuLocalAccount+0x582>
   13cc6:	80 91 9c 03 	lds	r24, 0x039C
   13cca:	87 3b       	cpi	r24, 0xB7	; 183
   13ccc:	09 f0       	breq	.+2      	; 0x13cd0 <FMenuLocalAccount+0x578>
   13cce:	57 c0       	rjmp	.+174    	; 0x13d7e <FMenuLocalAccount+0x626>
   13cd0:	80 91 5b 01 	lds	r24, 0x015B
   13cd4:	80 32       	cpi	r24, 0x20	; 32
   13cd6:	09 f4       	brne	.+2      	; 0x13cda <FMenuLocalAccount+0x582>
   13cd8:	6b c7       	rjmp	.+3798   	; 0x14bb0 <FMenuLocalAccount+0x1458>
				    (KeyPressed==_KEY_ENTER)&&(KeyCharLast!=' ')
					){
				    stLocalAccount=laSelectProduct;
   13cda:	8b e0       	ldi	r24, 0x0B	; 11
   13cdc:	80 93 5c 01 	sts	0x015C, r24
					FIP_Used=FIP[KeyCharLast-'1'];
   13ce0:	e0 91 5b 01 	lds	r30, 0x015B
   13ce4:	f0 e0       	ldi	r31, 0x00	; 0
   13ce6:	ef 5a       	subi	r30, 0xAF	; 175
   13ce8:	fc 4f       	sbci	r31, 0xFC	; 252
   13cea:	20 81       	ld	r18, Z
   13cec:	20 93 76 03 	sts	0x0376, r18
					if (FIP_Used<=99){
   13cf0:	24 36       	cpi	r18, 0x64	; 100
   13cf2:	08 f0       	brcs	.+2      	; 0x13cf6 <FMenuLocalAccount+0x59e>
   13cf4:	5d c7       	rjmp	.+3770   	; 0x14bb0 <FMenuLocalAccount+0x1458>
					    //leadingZero(FIP_Used,strFIP);
						//leadingZero(FIP_Used,strFIP_ID);
						sprintf_P(strFIP,PSTR("%.2d"),FIP_Used);
   13cf6:	00 d0       	rcall	.+0      	; 0x13cf8 <FMenuLocalAccount+0x5a0>
   13cf8:	00 d0       	rcall	.+0      	; 0x13cfa <FMenuLocalAccount+0x5a2>
   13cfa:	00 d0       	rcall	.+0      	; 0x13cfc <FMenuLocalAccount+0x5a4>
   13cfc:	ed b7       	in	r30, 0x3d	; 61
   13cfe:	fe b7       	in	r31, 0x3e	; 62
   13d00:	31 96       	adiw	r30, 0x01	; 1
   13d02:	8d e9       	ldi	r24, 0x9D	; 157
   13d04:	93 e0       	ldi	r25, 0x03	; 3
   13d06:	ad b7       	in	r26, 0x3d	; 61
   13d08:	be b7       	in	r27, 0x3e	; 62
   13d0a:	12 96       	adiw	r26, 0x02	; 2
   13d0c:	9c 93       	st	X, r25
   13d0e:	8e 93       	st	-X, r24
   13d10:	11 97       	sbiw	r26, 0x01	; 1
   13d12:	86 ed       	ldi	r24, 0xD6	; 214
   13d14:	9f e1       	ldi	r25, 0x1F	; 31
   13d16:	93 83       	std	Z+3, r25	; 0x03
   13d18:	82 83       	std	Z+2, r24	; 0x02
   13d1a:	24 83       	std	Z+4, r18	; 0x04
   13d1c:	15 82       	std	Z+5, r1	; 0x05
   13d1e:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
						sprintf_P(strFIP_ID,PSTR("%.2d"),FIP_Used);
   13d22:	ed b7       	in	r30, 0x3d	; 61
   13d24:	fe b7       	in	r31, 0x3e	; 62
   13d26:	31 96       	adiw	r30, 0x01	; 1
   13d28:	8c e9       	ldi	r24, 0x9C	; 156
   13d2a:	99 e0       	ldi	r25, 0x09	; 9
   13d2c:	ad b7       	in	r26, 0x3d	; 61
   13d2e:	be b7       	in	r27, 0x3e	; 62
   13d30:	12 96       	adiw	r26, 0x02	; 2
   13d32:	9c 93       	st	X, r25
   13d34:	8e 93       	st	-X, r24
   13d36:	11 97       	sbiw	r26, 0x01	; 1
   13d38:	81 ed       	ldi	r24, 0xD1	; 209
   13d3a:	9f e1       	ldi	r25, 0x1F	; 31
   13d3c:	93 83       	std	Z+3, r25	; 0x03
   13d3e:	82 83       	std	Z+2, r24	; 0x02
   13d40:	80 91 76 03 	lds	r24, 0x0376
   13d44:	84 83       	std	Z+4, r24	; 0x04
   13d46:	15 82       	std	Z+5, r1	; 0x05
   13d48:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
   13d4c:	ed b7       	in	r30, 0x3d	; 61
   13d4e:	fe b7       	in	r31, 0x3e	; 62
   13d50:	36 96       	adiw	r30, 0x06	; 6
   13d52:	0f b6       	in	r0, 0x3f	; 63
   13d54:	f8 94       	cli
   13d56:	fe bf       	out	0x3e, r31	; 62
   13d58:	0f be       	out	0x3f, r0	; 63
   13d5a:	ed bf       	out	0x3d, r30	; 61
   13d5c:	60 91 5b 01 	lds	r22, 0x015B
   13d60:	86 e0       	ldi	r24, 0x06	; 6
   13d62:	68 9f       	mul	r22, r24
   13d64:	b0 01       	movw	r22, r0
   13d66:	11 24       	eor	r1, r1
   13d68:	61 5d       	subi	r22, 0xD1	; 209
   13d6a:	70 40       	sbci	r23, 0x00	; 0
   13d6c:	8a e8       	ldi	r24, 0x8A	; 138
   13d6e:	93 e0       	ldi	r25, 0x03	; 3
   13d70:	46 e0       	ldi	r20, 0x06	; 6
   13d72:	50 e0       	ldi	r21, 0x00	; 0
   13d74:	23 ef       	ldi	r18, 0xF3	; 243
   13d76:	32 e1       	ldi	r19, 0x12	; 18
   13d78:	0e 94 1f b4 	call	0x1683e	; 0x1683e <__eerd_block>
   13d7c:	19 c7       	rjmp	.+3634   	; 0x14bb0 <FMenuLocalAccount+0x1458>

						eeprom_read_block((void*) &ProductID, (const void*) &DefNozzleMap[(KeyCharLast-'1')], 6);
						}
					}
				else
				if (KeyPressed==_KEY_CANCEL){
   13d7e:	87 3e       	cpi	r24, 0xE7	; 231
   13d80:	09 f0       	breq	.+2      	; 0x13d84 <FMenuLocalAccount+0x62c>
   13d82:	16 c7       	rjmp	.+3628   	; 0x14bb0 <FMenuLocalAccount+0x1458>
				    stLocalAccount=laDispValid;
   13d84:	87 e0       	ldi	r24, 0x07	; 7
   13d86:	41 c4       	rjmp	.+2178   	; 0x1460a <FMenuLocalAccount+0xeb2>
					}
		        break;
           case laSelectProduct://NozzleID
				lcd_clear();
   13d88:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
		        sprintf_P(lcdteks,PSTR("Pompa-%s"),strFIP);lcd_print(1,1,lcdteks);
   13d8c:	00 d0       	rcall	.+0      	; 0x13d8e <FMenuLocalAccount+0x636>
   13d8e:	00 d0       	rcall	.+0      	; 0x13d90 <FMenuLocalAccount+0x638>
   13d90:	00 d0       	rcall	.+0      	; 0x13d92 <FMenuLocalAccount+0x63a>
   13d92:	ed b7       	in	r30, 0x3d	; 61
   13d94:	fe b7       	in	r31, 0x3e	; 62
   13d96:	31 96       	adiw	r30, 0x01	; 1
   13d98:	8e 01       	movw	r16, r28
   13d9a:	0f 5f       	subi	r16, 0xFF	; 255
   13d9c:	1f 4f       	sbci	r17, 0xFF	; 255
   13d9e:	ad b7       	in	r26, 0x3d	; 61
   13da0:	be b7       	in	r27, 0x3e	; 62
   13da2:	12 96       	adiw	r26, 0x02	; 2
   13da4:	1c 93       	st	X, r17
   13da6:	0e 93       	st	-X, r16
   13da8:	11 97       	sbiw	r26, 0x01	; 1
   13daa:	88 ec       	ldi	r24, 0xC8	; 200
   13dac:	9f e1       	ldi	r25, 0x1F	; 31
   13dae:	93 83       	std	Z+3, r25	; 0x03
   13db0:	82 83       	std	Z+2, r24	; 0x02
   13db2:	8d e9       	ldi	r24, 0x9D	; 157
   13db4:	93 e0       	ldi	r25, 0x03	; 3
   13db6:	95 83       	std	Z+5, r25	; 0x05
   13db8:	84 83       	std	Z+4, r24	; 0x04
   13dba:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
   13dbe:	ed b7       	in	r30, 0x3d	; 61
   13dc0:	fe b7       	in	r31, 0x3e	; 62
   13dc2:	36 96       	adiw	r30, 0x06	; 6
   13dc4:	0f b6       	in	r0, 0x3f	; 63
   13dc6:	f8 94       	cli
   13dc8:	fe bf       	out	0x3e, r31	; 62
   13dca:	0f be       	out	0x3f, r0	; 63
   13dcc:	ed bf       	out	0x3d, r30	; 61
   13dce:	81 e0       	ldi	r24, 0x01	; 1
   13dd0:	61 e0       	ldi	r22, 0x01	; 1
   13dd2:	a8 01       	movw	r20, r16
   13dd4:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
				//Not MPD->Single Product
				if ((ProductID[0]>=1)&&(ProductID[0]<=6)&&
   13dd8:	90 91 8a 03 	lds	r25, 0x038A
   13ddc:	89 2f       	mov	r24, r25
   13dde:	81 50       	subi	r24, 0x01	; 1
   13de0:	86 30       	cpi	r24, 0x06	; 6
   13de2:	08 f0       	brcs	.+2      	; 0x13de6 <FMenuLocalAccount+0x68e>
   13de4:	4b c0       	rjmp	.+150    	; 0x13e7c <FMenuLocalAccount+0x724>
   13de6:	80 91 8b 03 	lds	r24, 0x038B
   13dea:	88 23       	and	r24, r24
   13dec:	09 f0       	breq	.+2      	; 0x13df0 <FMenuLocalAccount+0x698>
   13dee:	46 c0       	rjmp	.+140    	; 0x13e7c <FMenuLocalAccount+0x724>
   13df0:	80 91 8c 03 	lds	r24, 0x038C
   13df4:	88 23       	and	r24, r24
   13df6:	09 f0       	breq	.+2      	; 0x13dfa <FMenuLocalAccount+0x6a2>
   13df8:	41 c0       	rjmp	.+130    	; 0x13e7c <FMenuLocalAccount+0x724>
   13dfa:	80 91 8d 03 	lds	r24, 0x038D
   13dfe:	88 23       	and	r24, r24
   13e00:	e9 f5       	brne	.+122    	; 0x13e7c <FMenuLocalAccount+0x724>
				    (ProductID[1]==0)&&(ProductID[2]==0)&&(ProductID[3]==0)){
                     //Load 1st Product      					 
					 ProdId=ProductID[0];
   13e02:	90 93 75 03 	sts	0x0375, r25
   13e06:	6d e0       	ldi	r22, 0x0D	; 13
   13e08:	96 9f       	mul	r25, r22
   13e0a:	b0 01       	movw	r22, r0
   13e0c:	11 24       	eor	r1, r1
   13e0e:	62 55       	subi	r22, 0x52	; 82
   13e10:	7f 4f       	sbci	r23, 0xFF	; 255
   13e12:	87 e7       	ldi	r24, 0x77	; 119
   13e14:	93 e0       	ldi	r25, 0x03	; 3
   13e16:	4a e0       	ldi	r20, 0x0A	; 10
   13e18:	50 e0       	ldi	r21, 0x00	; 0
   13e1a:	23 ef       	ldi	r18, 0xF3	; 243
   13e1c:	32 e1       	ldi	r19, 0x12	; 18
   13e1e:	0e 94 1f b4 	call	0x1683e	; 0x1683e <__eerd_block>
   13e22:	a7 e7       	ldi	r26, 0x77	; 119
   13e24:	b3 e0       	ldi	r27, 0x03	; 3
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   13e26:	11 96       	adiw	r26, 0x01	; 1
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   13e28:	f3 e0       	ldi	r31, 0x03	; 3
   13e2a:	af 37       	cpi	r26, 0x7F	; 127
   13e2c:	bf 07       	cpc	r27, r31
   13e2e:	d9 f7       	brne	.-10     	; 0x13e26 <FMenuLocalAccount+0x6ce>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   13e30:	1c 92       	st	X, r1
				    (ProductID[1]==0)&&(ProductID[2]==0)&&(ProductID[3]==0)){
                     //Load 1st Product      					 
					 ProdId=ProductID[0];
					 eeprom_read_block((void*) &ProductName, (const void*) &DefProductName[ProdId-1],10);
					 StrPosCopy(ProductName,ProductName,0,8);
					 sprintf_P(strProduct,PSTR("%s"),ProductName);
   13e32:	00 d0       	rcall	.+0      	; 0x13e34 <FMenuLocalAccount+0x6dc>
   13e34:	00 d0       	rcall	.+0      	; 0x13e36 <FMenuLocalAccount+0x6de>
   13e36:	00 d0       	rcall	.+0      	; 0x13e38 <FMenuLocalAccount+0x6e0>
   13e38:	2d b7       	in	r18, 0x3d	; 61
   13e3a:	3e b7       	in	r19, 0x3e	; 62
   13e3c:	2f 5f       	subi	r18, 0xFF	; 255
   13e3e:	3f 4f       	sbci	r19, 0xFF	; 255
   13e40:	81 e4       	ldi	r24, 0x41	; 65
   13e42:	99 e0       	ldi	r25, 0x09	; 9
   13e44:	ed b7       	in	r30, 0x3d	; 61
   13e46:	fe b7       	in	r31, 0x3e	; 62
   13e48:	92 83       	std	Z+2, r25	; 0x02
   13e4a:	81 83       	std	Z+1, r24	; 0x01
   13e4c:	85 ec       	ldi	r24, 0xC5	; 197
   13e4e:	9f e1       	ldi	r25, 0x1F	; 31
   13e50:	f9 01       	movw	r30, r18
   13e52:	93 83       	std	Z+3, r25	; 0x03
   13e54:	82 83       	std	Z+2, r24	; 0x02
   13e56:	18 97       	sbiw	r26, 0x08	; 8
   13e58:	b5 83       	std	Z+5, r27	; 0x05
   13e5a:	a4 83       	std	Z+4, r26	; 0x04
   13e5c:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
                     stLocalAccount=laSelectBalanceType;
   13e60:	8d e0       	ldi	r24, 0x0D	; 13
   13e62:	80 93 5c 01 	sts	0x015C, r24
   13e66:	80 e0       	ldi	r24, 0x00	; 0
   13e68:	2d b7       	in	r18, 0x3d	; 61
   13e6a:	3e b7       	in	r19, 0x3e	; 62
   13e6c:	2a 5f       	subi	r18, 0xFA	; 250
   13e6e:	3f 4f       	sbci	r19, 0xFF	; 255
   13e70:	0f b6       	in	r0, 0x3f	; 63
   13e72:	f8 94       	cli
   13e74:	3e bf       	out	0x3e, r19	; 62
   13e76:	0f be       	out	0x3f, r0	; 63
   13e78:	2d bf       	out	0x3d, r18	; 61
   13e7a:	9b c6       	rjmp	.+3382   	; 0x14bb2 <FMenuLocalAccount+0x145a>
					}else
                {
				//MultiProductDisplay Select:
				//Load Nozzle Configuration
				for(iNozzle=0;iNozzle<4;iNozzle++){
   13e7c:	10 92 9a 03 	sts	0x039A, r1
				        eeprom_read_block((void*) &ProductName, (const void*) &DefProductName[ProdId-1],10);
						StrPosCopy(ProductName,ProductName,0,8);
					    sprintf_P(lcdteks,PSTR("%d.%s"),(iNozzle+1),ProductName);
                    }
					else{
					       sprintf_P(lcdteks,PSTR("     "));					
   13e80:	8e 01       	movw	r16, r28
   13e82:	0f 5f       	subi	r16, 0xFF	; 255
   13e84:	1f 4f       	sbci	r17, 0xFF	; 255
   13e86:	49 eb       	ldi	r20, 0xB9	; 185
   13e88:	c4 2e       	mov	r12, r20
   13e8a:	4f e1       	ldi	r20, 0x1F	; 31
   13e8c:	d4 2e       	mov	r13, r20
   13e8e:	3d e0       	ldi	r19, 0x0D	; 13
   13e90:	a3 2e       	mov	r10, r19
                    //Masalah 0-->void
				    ProdId=ProductID[iNozzle];
					if ((ProdId>=1)&&(ProdId<=6)){
				        eeprom_read_block((void*) &ProductName, (const void*) &DefProductName[ProdId-1],10);
						StrPosCopy(ProductName,ProductName,0,8);
					    sprintf_P(lcdteks,PSTR("%d.%s"),(iNozzle+1),ProductName);
   13e92:	2f eb       	ldi	r18, 0xBF	; 191
   13e94:	e2 2e       	mov	r14, r18
   13e96:	2f e1       	ldi	r18, 0x1F	; 31
   13e98:	f2 2e       	mov	r15, r18
                    }
					else{
					       sprintf_P(lcdteks,PSTR("     "));					
					}
				    lcd_print(2+(iNozzle%2),1+(iNozzle/2)*11,lcdteks);
   13e9a:	9b e0       	ldi	r25, 0x0B	; 11
   13e9c:	b9 2e       	mov	r11, r25
   13e9e:	6b c0       	rjmp	.+214    	; 0x13f76 <FMenuLocalAccount+0x81e>
                {
				//MultiProductDisplay Select:
				//Load Nozzle Configuration
				for(iNozzle=0;iNozzle<4;iNozzle++){
                    //Masalah 0-->void
				    ProdId=ProductID[iNozzle];
   13ea0:	f0 e0       	ldi	r31, 0x00	; 0
   13ea2:	e6 57       	subi	r30, 0x76	; 118
   13ea4:	fc 4f       	sbci	r31, 0xFC	; 252
   13ea6:	e0 81       	ld	r30, Z
   13ea8:	e0 93 75 03 	sts	0x0375, r30
					if ((ProdId>=1)&&(ProdId<=6)){
   13eac:	8e 2f       	mov	r24, r30
   13eae:	81 50       	subi	r24, 0x01	; 1
   13eb0:	86 30       	cpi	r24, 0x06	; 6
   13eb2:	e8 f5       	brcc	.+122    	; 0x13f2e <FMenuLocalAccount+0x7d6>
   13eb4:	ea 9d       	mul	r30, r10
   13eb6:	b0 01       	movw	r22, r0
   13eb8:	11 24       	eor	r1, r1
   13eba:	62 55       	subi	r22, 0x52	; 82
   13ebc:	7f 4f       	sbci	r23, 0xFF	; 255
   13ebe:	87 e7       	ldi	r24, 0x77	; 119
   13ec0:	93 e0       	ldi	r25, 0x03	; 3
   13ec2:	4a e0       	ldi	r20, 0x0A	; 10
   13ec4:	50 e0       	ldi	r21, 0x00	; 0
   13ec6:	23 ef       	ldi	r18, 0xF3	; 243
   13ec8:	32 e1       	ldi	r19, 0x12	; 18
   13eca:	0e 94 1f b4 	call	0x1683e	; 0x1683e <__eerd_block>
   13ece:	a7 e7       	ldi	r26, 0x77	; 119
   13ed0:	b3 e0       	ldi	r27, 0x03	; 3
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   13ed2:	11 96       	adiw	r26, 0x01	; 1
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   13ed4:	33 e0       	ldi	r19, 0x03	; 3
   13ed6:	af 37       	cpi	r26, 0x7F	; 127
   13ed8:	b3 07       	cpc	r27, r19
   13eda:	d9 f7       	brne	.-10     	; 0x13ed2 <FMenuLocalAccount+0x77a>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   13edc:	1c 92       	st	X, r1
                    //Masalah 0-->void
				    ProdId=ProductID[iNozzle];
					if ((ProdId>=1)&&(ProdId<=6)){
				        eeprom_read_block((void*) &ProductName, (const void*) &DefProductName[ProdId-1],10);
						StrPosCopy(ProductName,ProductName,0,8);
					    sprintf_P(lcdteks,PSTR("%d.%s"),(iNozzle+1),ProductName);
   13ede:	8d b7       	in	r24, 0x3d	; 61
   13ee0:	9e b7       	in	r25, 0x3e	; 62
   13ee2:	08 97       	sbiw	r24, 0x08	; 8
   13ee4:	0f b6       	in	r0, 0x3f	; 63
   13ee6:	f8 94       	cli
   13ee8:	9e bf       	out	0x3e, r25	; 62
   13eea:	0f be       	out	0x3f, r0	; 63
   13eec:	8d bf       	out	0x3d, r24	; 61
   13eee:	2d b7       	in	r18, 0x3d	; 61
   13ef0:	3e b7       	in	r19, 0x3e	; 62
   13ef2:	2f 5f       	subi	r18, 0xFF	; 255
   13ef4:	3f 4f       	sbci	r19, 0xFF	; 255
   13ef6:	ed b7       	in	r30, 0x3d	; 61
   13ef8:	fe b7       	in	r31, 0x3e	; 62
   13efa:	12 83       	std	Z+2, r17	; 0x02
   13efc:	01 83       	std	Z+1, r16	; 0x01
   13efe:	f9 01       	movw	r30, r18
   13f00:	f3 82       	std	Z+3, r15	; 0x03
   13f02:	e2 82       	std	Z+2, r14	; 0x02
   13f04:	80 91 9a 03 	lds	r24, 0x039A
   13f08:	90 e0       	ldi	r25, 0x00	; 0
   13f0a:	01 96       	adiw	r24, 0x01	; 1
   13f0c:	95 83       	std	Z+5, r25	; 0x05
   13f0e:	84 83       	std	Z+4, r24	; 0x04
   13f10:	18 97       	sbiw	r26, 0x08	; 8
   13f12:	b7 83       	std	Z+7, r27	; 0x07
   13f14:	a6 83       	std	Z+6, r26	; 0x06
   13f16:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
   13f1a:	2d b7       	in	r18, 0x3d	; 61
   13f1c:	3e b7       	in	r19, 0x3e	; 62
   13f1e:	28 5f       	subi	r18, 0xF8	; 248
   13f20:	3f 4f       	sbci	r19, 0xFF	; 255
   13f22:	0f b6       	in	r0, 0x3f	; 63
   13f24:	f8 94       	cli
   13f26:	3e bf       	out	0x3e, r19	; 62
   13f28:	0f be       	out	0x3f, r0	; 63
   13f2a:	2d bf       	out	0x3d, r18	; 61
   13f2c:	12 c0       	rjmp	.+36     	; 0x13f52 <FMenuLocalAccount+0x7fa>
                    }
					else{
					       sprintf_P(lcdteks,PSTR("     "));					
   13f2e:	00 d0       	rcall	.+0      	; 0x13f30 <FMenuLocalAccount+0x7d8>
   13f30:	00 d0       	rcall	.+0      	; 0x13f32 <FMenuLocalAccount+0x7da>
   13f32:	ad b7       	in	r26, 0x3d	; 61
   13f34:	be b7       	in	r27, 0x3e	; 62
   13f36:	12 96       	adiw	r26, 0x02	; 2
   13f38:	1c 93       	st	X, r17
   13f3a:	0e 93       	st	-X, r16
   13f3c:	11 97       	sbiw	r26, 0x01	; 1
   13f3e:	14 96       	adiw	r26, 0x04	; 4
   13f40:	dc 92       	st	X, r13
   13f42:	ce 92       	st	-X, r12
   13f44:	13 97       	sbiw	r26, 0x03	; 3
   13f46:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
   13f4a:	0f 90       	pop	r0
   13f4c:	0f 90       	pop	r0
   13f4e:	0f 90       	pop	r0
   13f50:	0f 90       	pop	r0
					}
				    lcd_print(2+(iNozzle%2),1+(iNozzle/2)*11,lcdteks);
   13f52:	80 91 9a 03 	lds	r24, 0x039A
   13f56:	68 2f       	mov	r22, r24
   13f58:	66 95       	lsr	r22
   13f5a:	6b 9d       	mul	r22, r11
   13f5c:	b0 01       	movw	r22, r0
   13f5e:	11 24       	eor	r1, r1
   13f60:	6f 5f       	subi	r22, 0xFF	; 255
   13f62:	81 70       	andi	r24, 0x01	; 1
   13f64:	8e 5f       	subi	r24, 0xFE	; 254
   13f66:	a8 01       	movw	r20, r16
   13f68:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
                     stLocalAccount=laSelectBalanceType;
					}else
                {
				//MultiProductDisplay Select:
				//Load Nozzle Configuration
				for(iNozzle=0;iNozzle<4;iNozzle++){
   13f6c:	80 91 9a 03 	lds	r24, 0x039A
   13f70:	8f 5f       	subi	r24, 0xFF	; 255
   13f72:	80 93 9a 03 	sts	0x039A, r24
   13f76:	e0 91 9a 03 	lds	r30, 0x039A
   13f7a:	e4 30       	cpi	r30, 0x04	; 4
   13f7c:	08 f4       	brcc	.+2      	; 0x13f80 <FMenuLocalAccount+0x828>
   13f7e:	90 cf       	rjmp	.-224    	; 0x13ea0 <FMenuLocalAccount+0x748>
					else{
					       sprintf_P(lcdteks,PSTR("     "));					
					}
				    lcd_print(2+(iNozzle%2),1+(iNozzle/2)*11,lcdteks);
				}
	            lcd_printf(4,1,PSTR("[*]Back             "));   //"[*]Back             "				
   13f80:	84 e0       	ldi	r24, 0x04	; 4
   13f82:	61 e0       	ldi	r22, 0x01	; 1
   13f84:	44 ea       	ldi	r20, 0xA4	; 164
   13f86:	5f e1       	ldi	r21, 0x1F	; 31
   13f88:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
				stLocalAccount=laSelectProductInput;
   13f8c:	8c e0       	ldi	r24, 0x0C	; 12
   13f8e:	3d c3       	rjmp	.+1658   	; 0x1460a <FMenuLocalAccount+0xeb2>
				}
		        break; 
           case laSelectProductInput:
				KeyPressed=_key_scan(1);
   13f90:	81 e0       	ldi	r24, 0x01	; 1
   13f92:	0e 94 ab ae 	call	0x15d56	; 0x15d56 <_key_scan>
   13f96:	80 93 9c 03 	sts	0x039C, r24
			    KeyChar=_key_btn(KeyPressed);
   13f9a:	0e 94 0c ae 	call	0x15c18	; 0x15c18 <_key_btn>
   13f9e:	80 93 a1 03 	sts	0x03A1, r24
				if ((KeyChar>='1')&&(KeyChar<='4')){
   13fa2:	81 53       	subi	r24, 0x31	; 49
   13fa4:	84 30       	cpi	r24, 0x04	; 4
   13fa6:	f0 f5       	brcc	.+124    	; 0x14024 <FMenuLocalAccount+0x8cc>
				    iNozzle=KeyChar-'1';
   13fa8:	80 93 9a 03 	sts	0x039A, r24
   13fac:	07 e7       	ldi	r16, 0x77	; 119
   13fae:	13 e0       	ldi	r17, 0x03	; 3
   13fb0:	e8 2f       	mov	r30, r24
   13fb2:	f0 e0       	ldi	r31, 0x00	; 0
   13fb4:	e6 57       	subi	r30, 0x76	; 118
   13fb6:	fc 4f       	sbci	r31, 0xFC	; 252
   13fb8:	60 81       	ld	r22, Z
   13fba:	8d e0       	ldi	r24, 0x0D	; 13
   13fbc:	f8 2e       	mov	r15, r24
   13fbe:	6f 9d       	mul	r22, r15
   13fc0:	b0 01       	movw	r22, r0
   13fc2:	11 24       	eor	r1, r1
   13fc4:	62 55       	subi	r22, 0x52	; 82
   13fc6:	7f 4f       	sbci	r23, 0xFF	; 255
   13fc8:	c8 01       	movw	r24, r16
   13fca:	4a e0       	ldi	r20, 0x0A	; 10
   13fcc:	50 e0       	ldi	r21, 0x00	; 0
   13fce:	23 ef       	ldi	r18, 0xF3	; 243
   13fd0:	32 e1       	ldi	r19, 0x12	; 18
   13fd2:	0e 94 1f b4 	call	0x1683e	; 0x1683e <__eerd_block>
				    eeprom_read_block((void*) &ProductName, (const void*) &DefProductName[ProductID[iNozzle]-1],10);
					sprintf_P(strProduct,PSTR("%s"),ProductName);
   13fd6:	00 d0       	rcall	.+0      	; 0x13fd8 <FMenuLocalAccount+0x880>
   13fd8:	00 d0       	rcall	.+0      	; 0x13fda <FMenuLocalAccount+0x882>
   13fda:	00 d0       	rcall	.+0      	; 0x13fdc <FMenuLocalAccount+0x884>
   13fdc:	ed b7       	in	r30, 0x3d	; 61
   13fde:	fe b7       	in	r31, 0x3e	; 62
   13fe0:	31 96       	adiw	r30, 0x01	; 1
   13fe2:	81 e4       	ldi	r24, 0x41	; 65
   13fe4:	99 e0       	ldi	r25, 0x09	; 9
   13fe6:	ad b7       	in	r26, 0x3d	; 61
   13fe8:	be b7       	in	r27, 0x3e	; 62
   13fea:	12 96       	adiw	r26, 0x02	; 2
   13fec:	9c 93       	st	X, r25
   13fee:	8e 93       	st	-X, r24
   13ff0:	11 97       	sbiw	r26, 0x01	; 1
   13ff2:	81 ea       	ldi	r24, 0xA1	; 161
   13ff4:	9f e1       	ldi	r25, 0x1F	; 31
   13ff6:	93 83       	std	Z+3, r25	; 0x03
   13ff8:	82 83       	std	Z+2, r24	; 0x02
   13ffa:	15 83       	std	Z+5, r17	; 0x05
   13ffc:	04 83       	std	Z+4, r16	; 0x04
   13ffe:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
					NozzleID=iNozzle+1;
   14002:	80 91 9a 03 	lds	r24, 0x039A
   14006:	8f 5f       	subi	r24, 0xFF	; 255
   14008:	80 93 50 09 	sts	0x0950, r24
                    stLocalAccount=laSelectBalanceType;
   1400c:	f0 92 5c 01 	sts	0x015C, r15
					lcd_clear();
   14010:	ed b7       	in	r30, 0x3d	; 61
   14012:	fe b7       	in	r31, 0x3e	; 62
   14014:	36 96       	adiw	r30, 0x06	; 6
   14016:	0f b6       	in	r0, 0x3f	; 63
   14018:	f8 94       	cli
   1401a:	fe bf       	out	0x3e, r31	; 62
   1401c:	0f be       	out	0x3f, r0	; 63
   1401e:	ed bf       	out	0x3d, r30	; 61
   14020:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
					}                
				if (KeyPressed==_KEY_CANCEL)stLocalAccount=laSelectFIP;//Back To Pump Selection
   14024:	80 91 9c 03 	lds	r24, 0x039C
   14028:	87 3e       	cpi	r24, 0xE7	; 231
   1402a:	09 f0       	breq	.+2      	; 0x1402e <FMenuLocalAccount+0x8d6>
   1402c:	c1 c5       	rjmp	.+2946   	; 0x14bb0 <FMenuLocalAccount+0x1458>
   1402e:	89 e0       	ldi	r24, 0x09	; 9
   14030:	ec c2       	rjmp	.+1496   	; 0x1460a <FMenuLocalAccount+0xeb2>
		        break;
           case laSelectBalanceType:
		        lcd_clear();
   14032:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
		        sprintf_P(lcdteks,PSTR("P%s-%s "),strFIP,strProduct);      
   14036:	2d b7       	in	r18, 0x3d	; 61
   14038:	3e b7       	in	r19, 0x3e	; 62
   1403a:	28 50       	subi	r18, 0x08	; 8
   1403c:	30 40       	sbci	r19, 0x00	; 0
   1403e:	0f b6       	in	r0, 0x3f	; 63
   14040:	f8 94       	cli
   14042:	3e bf       	out	0x3e, r19	; 62
   14044:	0f be       	out	0x3f, r0	; 63
   14046:	2d bf       	out	0x3d, r18	; 61
   14048:	ed b7       	in	r30, 0x3d	; 61
   1404a:	fe b7       	in	r31, 0x3e	; 62
   1404c:	31 96       	adiw	r30, 0x01	; 1
   1404e:	8e 01       	movw	r16, r28
   14050:	0f 5f       	subi	r16, 0xFF	; 255
   14052:	1f 4f       	sbci	r17, 0xFF	; 255
   14054:	ad b7       	in	r26, 0x3d	; 61
   14056:	be b7       	in	r27, 0x3e	; 62
   14058:	12 96       	adiw	r26, 0x02	; 2
   1405a:	1c 93       	st	X, r17
   1405c:	0e 93       	st	-X, r16
   1405e:	11 97       	sbiw	r26, 0x01	; 1
   14060:	89 e9       	ldi	r24, 0x99	; 153
   14062:	9f e1       	ldi	r25, 0x1F	; 31
   14064:	93 83       	std	Z+3, r25	; 0x03
   14066:	82 83       	std	Z+2, r24	; 0x02
   14068:	8d e9       	ldi	r24, 0x9D	; 157
   1406a:	93 e0       	ldi	r25, 0x03	; 3
   1406c:	95 83       	std	Z+5, r25	; 0x05
   1406e:	84 83       	std	Z+4, r24	; 0x04
   14070:	81 e4       	ldi	r24, 0x41	; 65
   14072:	99 e0       	ldi	r25, 0x09	; 9
   14074:	97 83       	std	Z+7, r25	; 0x07
   14076:	86 83       	std	Z+6, r24	; 0x06
   14078:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
				 lcd_print(1,1,lcdteks);                        //"P01-Pertamax        "                                                                      
   1407c:	ed b7       	in	r30, 0x3d	; 61
   1407e:	fe b7       	in	r31, 0x3e	; 62
   14080:	38 96       	adiw	r30, 0x08	; 8
   14082:	0f b6       	in	r0, 0x3f	; 63
   14084:	f8 94       	cli
   14086:	fe bf       	out	0x3e, r31	; 62
   14088:	0f be       	out	0x3f, r0	; 63
   1408a:	ed bf       	out	0x3d, r30	; 61
   1408c:	81 e0       	ldi	r24, 0x01	; 1
   1408e:	61 e0       	ldi	r22, 0x01	; 1
   14090:	a8 01       	movw	r20, r16
   14092:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
		        lcd_printf(2,1,PSTR("[1]Volume           "));   //"[1]Premium          "                                                                      
   14096:	82 e0       	ldi	r24, 0x02	; 2
   14098:	61 e0       	ldi	r22, 0x01	; 1
   1409a:	44 e8       	ldi	r20, 0x84	; 132
   1409c:	5f e1       	ldi	r21, 0x1F	; 31
   1409e:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
				lcd_printf(3,1,PSTR("[2]Amount           "));   //"[2]Pertamax         "
   140a2:	83 e0       	ldi	r24, 0x03	; 3
   140a4:	61 e0       	ldi	r22, 0x01	; 1
   140a6:	4f e6       	ldi	r20, 0x6F	; 111
   140a8:	5f e1       	ldi	r21, 0x1F	; 31
   140aa:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
				lcd_printf(4,1,PSTR("[*]Back    [#]Next  "));   //"[*]Back             "						        
   140ae:	84 e0       	ldi	r24, 0x04	; 4
   140b0:	61 e0       	ldi	r22, 0x01	; 1
   140b2:	4a e5       	ldi	r20, 0x5A	; 90
   140b4:	5f e1       	ldi	r21, 0x1F	; 31
   140b6:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
	            //lcd_printf(4,1,PSTR("[*]Back    [#]Next  "));   //"[*]Back             "						        
                stLocalAccount=laSelectBalanceTypeInput;   
   140ba:	8e e0       	ldi	r24, 0x0E	; 14
   140bc:	a6 c2       	rjmp	.+1356   	; 0x1460a <FMenuLocalAccount+0xeb2>
		        break;
           case laSelectBalanceTypeInput:
				KeyPressed=_key_scan(1);
   140be:	81 e0       	ldi	r24, 0x01	; 1
   140c0:	0e 94 ab ae 	call	0x15d56	; 0x15d56 <_key_scan>
   140c4:	80 93 9c 03 	sts	0x039C, r24
			    KeyChar=_key_btn(KeyPressed);
   140c8:	0e 94 0c ae 	call	0x15c18	; 0x15c18 <_key_btn>
   140cc:	98 2f       	mov	r25, r24
   140ce:	80 93 a1 03 	sts	0x03A1, r24
				if ((KeyChar>='1')&&(KeyChar<='2')){
   140d2:	81 53       	subi	r24, 0x31	; 49
   140d4:	82 30       	cpi	r24, 0x02	; 2
   140d6:	80 f5       	brcc	.+96     	; 0x14138 <FMenuLocalAccount+0x9e0>
                    if(KeyChar=='1'){
   140d8:	91 33       	cpi	r25, 0x31	; 49
   140da:	a1 f4       	brne	.+40     	; 0x14104 <FMenuLocalAccount+0x9ac>
					   BalanceType=1;
   140dc:	81 e0       	ldi	r24, 0x01	; 1
   140de:	80 93 a0 03 	sts	0x03A0, r24
					   sprintf_P(strBalanceType,PSTR("V"));
   140e2:	00 d0       	rcall	.+0      	; 0x140e4 <FMenuLocalAccount+0x98c>
   140e4:	00 d0       	rcall	.+0      	; 0x140e6 <FMenuLocalAccount+0x98e>
   140e6:	83 e8       	ldi	r24, 0x83	; 131
   140e8:	95 e0       	ldi	r25, 0x05	; 5
   140ea:	ad b7       	in	r26, 0x3d	; 61
   140ec:	be b7       	in	r27, 0x3e	; 62
   140ee:	12 96       	adiw	r26, 0x02	; 2
   140f0:	9c 93       	st	X, r25
   140f2:	8e 93       	st	-X, r24
   140f4:	11 97       	sbiw	r26, 0x01	; 1
   140f6:	88 e5       	ldi	r24, 0x58	; 88
   140f8:	9f e1       	ldi	r25, 0x1F	; 31
   140fa:	14 96       	adiw	r26, 0x04	; 4
   140fc:	9c 93       	st	X, r25
   140fe:	8e 93       	st	-X, r24
   14100:	13 97       	sbiw	r26, 0x03	; 3
   14102:	11 c0       	rjmp	.+34     	; 0x14126 <FMenuLocalAccount+0x9ce>
					   }
					else
                    if(KeyChar=='2'){
   14104:	92 33       	cpi	r25, 0x32	; 50
   14106:	a9 f4       	brne	.+42     	; 0x14132 <FMenuLocalAccount+0x9da>
					   BalanceType=2;
   14108:	82 e0       	ldi	r24, 0x02	; 2
   1410a:	80 93 a0 03 	sts	0x03A0, r24
                       sprintf_P(strBalanceType,PSTR("A"));
   1410e:	00 d0       	rcall	.+0      	; 0x14110 <FMenuLocalAccount+0x9b8>
   14110:	00 d0       	rcall	.+0      	; 0x14112 <FMenuLocalAccount+0x9ba>
   14112:	83 e8       	ldi	r24, 0x83	; 131
   14114:	95 e0       	ldi	r25, 0x05	; 5
   14116:	ed b7       	in	r30, 0x3d	; 61
   14118:	fe b7       	in	r31, 0x3e	; 62
   1411a:	92 83       	std	Z+2, r25	; 0x02
   1411c:	81 83       	std	Z+1, r24	; 0x01
   1411e:	86 e5       	ldi	r24, 0x56	; 86
   14120:	9f e1       	ldi	r25, 0x1F	; 31
   14122:	94 83       	std	Z+4, r25	; 0x04
   14124:	83 83       	std	Z+3, r24	; 0x03
   14126:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
   1412a:	0f 90       	pop	r0
   1412c:	0f 90       	pop	r0
   1412e:	0f 90       	pop	r0
   14130:	0f 90       	pop	r0
					   }
				    stLocalAccount=laBalanceValue;  
   14132:	8f e0       	ldi	r24, 0x0F	; 15
   14134:	80 93 5c 01 	sts	0x015C, r24
					}              
				if (KeyPressed==_KEY_CANCEL){
   14138:	80 91 9c 03 	lds	r24, 0x039C
   1413c:	87 3e       	cpi	r24, 0xE7	; 231
   1413e:	c9 f4       	brne	.+50     	; 0x14172 <FMenuLocalAccount+0xa1a>
				    if ((ProductID[0]>=1)&&(ProductID[0]<=6)&&(ProductID[1]==0)&&(ProductID[2]==0)&&(ProductID[3]==0))
   14140:	80 91 8a 03 	lds	r24, 0x038A
   14144:	81 50       	subi	r24, 0x01	; 1
   14146:	86 30       	cpi	r24, 0x06	; 6
   14148:	70 f4       	brcc	.+28     	; 0x14166 <FMenuLocalAccount+0xa0e>
   1414a:	80 91 8b 03 	lds	r24, 0x038B
   1414e:	88 23       	and	r24, r24
   14150:	51 f4       	brne	.+20     	; 0x14166 <FMenuLocalAccount+0xa0e>
   14152:	80 91 8c 03 	lds	r24, 0x038C
   14156:	88 23       	and	r24, r24
   14158:	31 f4       	brne	.+12     	; 0x14166 <FMenuLocalAccount+0xa0e>
   1415a:	80 91 8d 03 	lds	r24, 0x038D
   1415e:	88 23       	and	r24, r24
   14160:	11 f4       	brne	.+4      	; 0x14166 <FMenuLocalAccount+0xa0e>
					     stLocalAccount=laSelectFIP;//Back To FIP Select Non MPD
   14162:	89 e0       	ldi	r24, 0x09	; 9
   14164:	01 c0       	rjmp	.+2      	; 0x14168 <FMenuLocalAccount+0xa10>
                    else stLocalAccount=laSelectProduct;//Back To Product Selection MPD
   14166:	8b e0       	ldi	r24, 0x0B	; 11
   14168:	80 93 5c 01 	sts	0x015C, r24
					lcd_clear();
   1416c:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
   14170:	1f c5       	rjmp	.+2622   	; 0x14bb0 <FMenuLocalAccount+0x1458>
					}
                else
				if (KeyPressed==_KEY_ENTER){
   14172:	87 3b       	cpi	r24, 0xB7	; 183
   14174:	09 f0       	breq	.+2      	; 0x14178 <FMenuLocalAccount+0xa20>
   14176:	1c c5       	rjmp	.+2616   	; 0x14bb0 <FMenuLocalAccount+0x1458>
				    BalanceType=1;
   14178:	11 e0       	ldi	r17, 0x01	; 1
   1417a:	10 93 a0 03 	sts	0x03A0, r17
					sprintf_P(strBalanceType,PSTR("A"));
   1417e:	00 d0       	rcall	.+0      	; 0x14180 <FMenuLocalAccount+0xa28>
   14180:	00 d0       	rcall	.+0      	; 0x14182 <FMenuLocalAccount+0xa2a>
   14182:	83 e8       	ldi	r24, 0x83	; 131
   14184:	95 e0       	ldi	r25, 0x05	; 5
   14186:	ad b7       	in	r26, 0x3d	; 61
   14188:	be b7       	in	r27, 0x3e	; 62
   1418a:	12 96       	adiw	r26, 0x02	; 2
   1418c:	9c 93       	st	X, r25
   1418e:	8e 93       	st	-X, r24
   14190:	11 97       	sbiw	r26, 0x01	; 1
   14192:	84 e5       	ldi	r24, 0x54	; 84
   14194:	9f e1       	ldi	r25, 0x1F	; 31
   14196:	14 96       	adiw	r26, 0x04	; 4
   14198:	9c 93       	st	X, r25
   1419a:	8e 93       	st	-X, r24
   1419c:	13 97       	sbiw	r26, 0x03	; 3
   1419e:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
					//sprintf_P(strBalanceValue,PSTR("999"));
					IsFullAuthorized=True;
   141a2:	10 93 74 03 	sts	0x0374, r17
                    stLocalAccount=laOdometer;//FullAuthorized
   141a6:	81 e1       	ldi	r24, 0x11	; 17
   141a8:	80 93 5c 01 	sts	0x015C, r24
   141ac:	80 e0       	ldi	r24, 0x00	; 0
   141ae:	0f 90       	pop	r0
   141b0:	0f 90       	pop	r0
   141b2:	0f 90       	pop	r0
   141b4:	0f 90       	pop	r0
   141b6:	fd c4       	rjmp	.+2554   	; 0x14bb2 <FMenuLocalAccount+0x145a>
					}

		        break;
           case laBalanceValue:
		        lcd_clear();
   141b8:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
		        if(BalanceType==1){
   141bc:	80 91 a0 03 	lds	r24, 0x03A0
   141c0:	81 30       	cpi	r24, 0x01	; 1
   141c2:	f1 f5       	brne	.+124    	; 0x14240 <FMenuLocalAccount+0xae8>
		           sprintf_P(lcdteks,PSTR("P%s-%s "),strFIP,strProduct);      
   141c4:	ed b7       	in	r30, 0x3d	; 61
   141c6:	fe b7       	in	r31, 0x3e	; 62
   141c8:	38 97       	sbiw	r30, 0x08	; 8
   141ca:	0f b6       	in	r0, 0x3f	; 63
   141cc:	f8 94       	cli
   141ce:	fe bf       	out	0x3e, r31	; 62
   141d0:	0f be       	out	0x3f, r0	; 63
   141d2:	ed bf       	out	0x3d, r30	; 61
   141d4:	31 96       	adiw	r30, 0x01	; 1
   141d6:	8e 01       	movw	r16, r28
   141d8:	0f 5f       	subi	r16, 0xFF	; 255
   141da:	1f 4f       	sbci	r17, 0xFF	; 255
   141dc:	ad b7       	in	r26, 0x3d	; 61
   141de:	be b7       	in	r27, 0x3e	; 62
   141e0:	12 96       	adiw	r26, 0x02	; 2
   141e2:	1c 93       	st	X, r17
   141e4:	0e 93       	st	-X, r16
   141e6:	11 97       	sbiw	r26, 0x01	; 1
   141e8:	8c e4       	ldi	r24, 0x4C	; 76
   141ea:	9f e1       	ldi	r25, 0x1F	; 31
   141ec:	93 83       	std	Z+3, r25	; 0x03
   141ee:	82 83       	std	Z+2, r24	; 0x02
   141f0:	8d e9       	ldi	r24, 0x9D	; 157
   141f2:	93 e0       	ldi	r25, 0x03	; 3
   141f4:	95 83       	std	Z+5, r25	; 0x05
   141f6:	84 83       	std	Z+4, r24	; 0x04
   141f8:	81 e4       	ldi	r24, 0x41	; 65
   141fa:	99 e0       	ldi	r25, 0x09	; 9
   141fc:	97 83       	std	Z+7, r25	; 0x07
   141fe:	86 83       	std	Z+6, r24	; 0x06
   14200:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
				    lcd_print(1,1,lcdteks);                        //"P01-Pertamax        "                                                                      
   14204:	ed b7       	in	r30, 0x3d	; 61
   14206:	fe b7       	in	r31, 0x3e	; 62
   14208:	38 96       	adiw	r30, 0x08	; 8
   1420a:	0f b6       	in	r0, 0x3f	; 63
   1420c:	f8 94       	cli
   1420e:	fe bf       	out	0x3e, r31	; 62
   14210:	0f be       	out	0x3f, r0	; 63
   14212:	ed bf       	out	0x3d, r30	; 61
   14214:	81 e0       	ldi	r24, 0x01	; 1
   14216:	61 e0       	ldi	r22, 0x01	; 1
   14218:	a8 01       	movw	r20, r16
   1421a:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
		           lcd_printf(2,1,PSTR("[1]Volume:_         "));   //"[1]Volume:_         "                                                                      
   1421e:	82 e0       	ldi	r24, 0x02	; 2
   14220:	61 e0       	ldi	r22, 0x01	; 1
   14222:	47 e3       	ldi	r20, 0x37	; 55
   14224:	5f e1       	ldi	r21, 0x1F	; 31
   14226:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
				   lcd_printf(3,1,PSTR("                    "));   //"                    "
   1422a:	83 e0       	ldi	r24, 0x03	; 3
   1422c:	61 e0       	ldi	r22, 0x01	; 1
   1422e:	42 e2       	ldi	r20, 0x22	; 34
   14230:	5f e1       	ldi	r21, 0x1F	; 31
   14232:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
	               lcd_printf(4,1,PSTR("[*]Back  [#]OK      "));   //"[*]Back  [#]OK     "						        
   14236:	84 e0       	ldi	r24, 0x04	; 4
   14238:	61 e0       	ldi	r22, 0x01	; 1
   1423a:	4d e0       	ldi	r20, 0x0D	; 13
   1423c:	5f e1       	ldi	r21, 0x1F	; 31
   1423e:	43 c0       	rjmp	.+134    	; 0x142c6 <FMenuLocalAccount+0xb6e>
				   }
                else
		        if(BalanceType==2){
   14240:	82 30       	cpi	r24, 0x02	; 2
   14242:	09 f0       	breq	.+2      	; 0x14246 <FMenuLocalAccount+0xaee>
   14244:	42 c0       	rjmp	.+132    	; 0x142ca <FMenuLocalAccount+0xb72>
		           sprintf_P(lcdteks,PSTR("P%s-%s "),strFIP,strProduct);      
   14246:	2d b7       	in	r18, 0x3d	; 61
   14248:	3e b7       	in	r19, 0x3e	; 62
   1424a:	28 50       	subi	r18, 0x08	; 8
   1424c:	30 40       	sbci	r19, 0x00	; 0
   1424e:	0f b6       	in	r0, 0x3f	; 63
   14250:	f8 94       	cli
   14252:	3e bf       	out	0x3e, r19	; 62
   14254:	0f be       	out	0x3f, r0	; 63
   14256:	2d bf       	out	0x3d, r18	; 61
   14258:	ed b7       	in	r30, 0x3d	; 61
   1425a:	fe b7       	in	r31, 0x3e	; 62
   1425c:	31 96       	adiw	r30, 0x01	; 1
   1425e:	8e 01       	movw	r16, r28
   14260:	0f 5f       	subi	r16, 0xFF	; 255
   14262:	1f 4f       	sbci	r17, 0xFF	; 255
   14264:	ad b7       	in	r26, 0x3d	; 61
   14266:	be b7       	in	r27, 0x3e	; 62
   14268:	12 96       	adiw	r26, 0x02	; 2
   1426a:	1c 93       	st	X, r17
   1426c:	0e 93       	st	-X, r16
   1426e:	11 97       	sbiw	r26, 0x01	; 1
   14270:	85 e0       	ldi	r24, 0x05	; 5
   14272:	9f e1       	ldi	r25, 0x1F	; 31
   14274:	93 83       	std	Z+3, r25	; 0x03
   14276:	82 83       	std	Z+2, r24	; 0x02
   14278:	8d e9       	ldi	r24, 0x9D	; 157
   1427a:	93 e0       	ldi	r25, 0x03	; 3
   1427c:	95 83       	std	Z+5, r25	; 0x05
   1427e:	84 83       	std	Z+4, r24	; 0x04
   14280:	81 e4       	ldi	r24, 0x41	; 65
   14282:	99 e0       	ldi	r25, 0x09	; 9
   14284:	97 83       	std	Z+7, r25	; 0x07
   14286:	86 83       	std	Z+6, r24	; 0x06
   14288:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
				   lcd_print(1,1,lcdteks);                         //"P01-Pertamax        "                                                                      
   1428c:	ed b7       	in	r30, 0x3d	; 61
   1428e:	fe b7       	in	r31, 0x3e	; 62
   14290:	38 96       	adiw	r30, 0x08	; 8
   14292:	0f b6       	in	r0, 0x3f	; 63
   14294:	f8 94       	cli
   14296:	fe bf       	out	0x3e, r31	; 62
   14298:	0f be       	out	0x3f, r0	; 63
   1429a:	ed bf       	out	0x3d, r30	; 61
   1429c:	81 e0       	ldi	r24, 0x01	; 1
   1429e:	61 e0       	ldi	r22, 0x01	; 1
   142a0:	a8 01       	movw	r20, r16
   142a2:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
		           lcd_printf(2,1,PSTR("                    "));   //"                    "                                                                      
   142a6:	82 e0       	ldi	r24, 0x02	; 2
   142a8:	61 e0       	ldi	r22, 0x01	; 1
   142aa:	40 ef       	ldi	r20, 0xF0	; 240
   142ac:	5e e1       	ldi	r21, 0x1E	; 30
   142ae:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
				   lcd_printf(3,1,PSTR("[2]Amount:_         "));   //"[2]Amount:_         "
   142b2:	83 e0       	ldi	r24, 0x03	; 3
   142b4:	61 e0       	ldi	r22, 0x01	; 1
   142b6:	4b ed       	ldi	r20, 0xDB	; 219
   142b8:	5e e1       	ldi	r21, 0x1E	; 30
   142ba:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
	               lcd_printf(4,1,PSTR("[*]Back  [#]OK      "));   //"[*]Back  [#]OK      "			        
   142be:	84 e0       	ldi	r24, 0x04	; 4
   142c0:	61 e0       	ldi	r22, 0x01	; 1
   142c2:	46 ec       	ldi	r20, 0xC6	; 198
   142c4:	5e e1       	ldi	r21, 0x1E	; 30
   142c6:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
				   }
                iLoop=0;
   142ca:	10 92 73 03 	sts	0x0373, r1
   142ce:	10 92 72 03 	sts	0x0372, r1
				iValuePos=0;
   142d2:	10 92 9b 03 	sts	0x039B, r1
				ValueChar[iValuePos]=' ';
   142d6:	80 e2       	ldi	r24, 0x20	; 32
   142d8:	80 93 90 03 	sts	0x0390, r24
		        stLocalAccount=laBalanceValueInput;  
   142dc:	80 e1       	ldi	r24, 0x10	; 16
   142de:	95 c1       	rjmp	.+810    	; 0x1460a <FMenuLocalAccount+0xeb2>
		        break; 
           case laBalanceValueInput:
			    //Blinking 50% _      BalanceValue Volume=999  Amount=65536
			    iLoop++;
   142e0:	80 91 72 03 	lds	r24, 0x0372
   142e4:	90 91 73 03 	lds	r25, 0x0373
   142e8:	01 96       	adiw	r24, 0x01	; 1
   142ea:	90 93 73 03 	sts	0x0373, r25
   142ee:	80 93 72 03 	sts	0x0372, r24
			    //GetKeyPressed
			    KeyPressed=_key_scan(1);
   142f2:	81 e0       	ldi	r24, 0x01	; 1
   142f4:	0e 94 ab ae 	call	0x15d56	; 0x15d56 <_key_scan>
   142f8:	80 93 9c 03 	sts	0x039C, r24
			    KeyChar=_key_btn(KeyPressed);
   142fc:	0e 94 0c ae 	call	0x15c18	; 0x15c18 <_key_btn>
   14300:	98 2f       	mov	r25, r24
   14302:	80 93 a1 03 	sts	0x03A1, r24
				if (((KeyChar>='0')&&(KeyChar<='9')&&(iValuePos<6)&&(BalanceType==2))||//Max Rp.999999
   14306:	80 53       	subi	r24, 0x30	; 48
   14308:	8a 30       	cpi	r24, 0x0A	; 10
   1430a:	38 f5       	brcc	.+78     	; 0x1435a <FMenuLocalAccount+0xc02>
   1430c:	e0 91 9b 03 	lds	r30, 0x039B
   14310:	e6 30       	cpi	r30, 0x06	; 6
   14312:	18 f5       	brcc	.+70     	; 0x1435a <FMenuLocalAccount+0xc02>
   14314:	80 91 a0 03 	lds	r24, 0x03A0
   14318:	82 30       	cpi	r24, 0x02	; 2
   1431a:	21 f0       	breq	.+8      	; 0x14324 <FMenuLocalAccount+0xbcc>
   1431c:	e3 30       	cpi	r30, 0x03	; 3
   1431e:	e8 f4       	brcc	.+58     	; 0x1435a <FMenuLocalAccount+0xc02>
   14320:	81 30       	cpi	r24, 0x01	; 1
   14322:	d9 f4       	brne	.+54     	; 0x1435a <FMenuLocalAccount+0xc02>
				   ((KeyChar>='0')&&(KeyChar<='9')&&(iValuePos<3)&&(BalanceType==1))){ //Max       999L
				    ValueChar[iValuePos]=KeyChar;
   14324:	f0 e0       	ldi	r31, 0x00	; 0
   14326:	e0 57       	subi	r30, 0x70	; 112
   14328:	fc 4f       	sbci	r31, 0xFC	; 252
   1432a:	90 83       	st	Z, r25
					iValuePos++;
   1432c:	60 91 9b 03 	lds	r22, 0x039B
   14330:	6f 5f       	subi	r22, 0xFF	; 255
   14332:	60 93 9b 03 	sts	0x039B, r22
					lcd_xy(1+BalanceType,(10+iValuePos));_lcd(ValueChar[iValuePos-1]); 
   14336:	80 91 a0 03 	lds	r24, 0x03A0
   1433a:	66 5f       	subi	r22, 0xF6	; 246
   1433c:	8f 5f       	subi	r24, 0xFF	; 255
   1433e:	0e 94 f1 ac 	call	0x159e2	; 0x159e2 <lcd_xy>
   14342:	e0 91 9b 03 	lds	r30, 0x039B
   14346:	f0 e0       	ldi	r31, 0x00	; 0
   14348:	e1 57       	subi	r30, 0x71	; 113
   1434a:	fc 4f       	sbci	r31, 0xFC	; 252
   1434c:	80 81       	ld	r24, Z
   1434e:	0e 94 cb ac 	call	0x15996	; 0x15996 <_lcd>
   14352:	80 e5       	ldi	r24, 0x50	; 80
   14354:	93 ec       	ldi	r25, 0xC3	; 195
   14356:	01 97       	sbiw	r24, 0x01	; 1
   14358:	f1 f7       	brne	.-4      	; 0x14356 <FMenuLocalAccount+0xbfe>
					_delay_ms(200);
					}
			    if ((iLoop%2000)==0){
   1435a:	80 91 72 03 	lds	r24, 0x0372
   1435e:	90 91 73 03 	lds	r25, 0x0373
   14362:	60 ed       	ldi	r22, 0xD0	; 208
   14364:	77 e0       	ldi	r23, 0x07	; 7
   14366:	0e 94 38 b7 	call	0x16e70	; 0x16e70 <__udivmodhi4>
   1436a:	89 2b       	or	r24, r25
   1436c:	59 f4       	brne	.+22     	; 0x14384 <FMenuLocalAccount+0xc2c>
				     lcd_xy((1+BalanceType),(11+iValuePos));_lcd('_'); 
   1436e:	80 91 a0 03 	lds	r24, 0x03A0
   14372:	60 91 9b 03 	lds	r22, 0x039B
   14376:	65 5f       	subi	r22, 0xF5	; 245
   14378:	8f 5f       	subi	r24, 0xFF	; 255
   1437a:	0e 94 f1 ac 	call	0x159e2	; 0x159e2 <lcd_xy>
   1437e:	8f e5       	ldi	r24, 0x5F	; 95
   14380:	0e 94 cb ac 	call	0x15996	; 0x15996 <_lcd>
			    }
			    if ((iLoop%2000)==1000){
   14384:	80 91 72 03 	lds	r24, 0x0372
   14388:	90 91 73 03 	lds	r25, 0x0373
   1438c:	60 ed       	ldi	r22, 0xD0	; 208
   1438e:	77 e0       	ldi	r23, 0x07	; 7
   14390:	0e 94 38 b7 	call	0x16e70	; 0x16e70 <__udivmodhi4>
   14394:	88 5e       	subi	r24, 0xE8	; 232
   14396:	93 40       	sbci	r25, 0x03	; 3
   14398:	59 f4       	brne	.+22     	; 0x143b0 <FMenuLocalAccount+0xc58>
				     lcd_xy((1+BalanceType),(11+iValuePos));_lcd(' '); 
   1439a:	80 91 a0 03 	lds	r24, 0x03A0
   1439e:	60 91 9b 03 	lds	r22, 0x039B
   143a2:	65 5f       	subi	r22, 0xF5	; 245
   143a4:	8f 5f       	subi	r24, 0xFF	; 255
   143a6:	0e 94 f1 ac 	call	0x159e2	; 0x159e2 <lcd_xy>
   143aa:	80 e2       	ldi	r24, 0x20	; 32
   143ac:	0e 94 cb ac 	call	0x15996	; 0x15996 <_lcd>
			    }
				if (KeyPressed==_KEY_CANCEL){
   143b0:	80 91 9c 03 	lds	r24, 0x039C
   143b4:	87 3e       	cpi	r24, 0xE7	; 231
   143b6:	39 f4       	brne	.+14     	; 0x143c6 <FMenuLocalAccount+0xc6e>
				    lcd_clear();
   143b8:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
   143bc:	88 ea       	ldi	r24, 0xA8	; 168
   143be:	91 e6       	ldi	r25, 0x61	; 97
   143c0:	01 97       	sbiw	r24, 0x01	; 1
   143c2:	f1 f7       	brne	.-4      	; 0x143c0 <FMenuLocalAccount+0xc68>
   143c4:	1f c1       	rjmp	.+574    	; 0x14604 <FMenuLocalAccount+0xeac>
					_delay_ms(100);		        
				    stLocalAccount=laSelectBalanceType;		        
					}
				else
				if (KeyPressed==_KEY_ENTER){				    
   143c6:	87 3b       	cpi	r24, 0xB7	; 183
   143c8:	09 f0       	breq	.+2      	; 0x143cc <FMenuLocalAccount+0xc74>
   143ca:	f2 c3       	rjmp	.+2020   	; 0x14bb0 <FMenuLocalAccount+0x1458>
                    ValueChar[iValuePos]=0;
   143cc:	e0 91 9b 03 	lds	r30, 0x039B
   143d0:	f0 e0       	ldi	r31, 0x00	; 0
   143d2:	e0 57       	subi	r30, 0x70	; 112
   143d4:	fc 4f       	sbci	r31, 0xFC	; 252
   143d6:	10 82       	st	Z, r1
					sprintf_P(strBalanceValue,PSTR("%s"),ValueChar);
   143d8:	00 d0       	rcall	.+0      	; 0x143da <FMenuLocalAccount+0xc82>
   143da:	00 d0       	rcall	.+0      	; 0x143dc <FMenuLocalAccount+0xc84>
   143dc:	00 d0       	rcall	.+0      	; 0x143de <FMenuLocalAccount+0xc86>
   143de:	ed b7       	in	r30, 0x3d	; 61
   143e0:	fe b7       	in	r31, 0x3e	; 62
   143e2:	31 96       	adiw	r30, 0x01	; 1
   143e4:	8a ef       	ldi	r24, 0xFA	; 250
   143e6:	9d e0       	ldi	r25, 0x0D	; 13
   143e8:	ad b7       	in	r26, 0x3d	; 61
   143ea:	be b7       	in	r27, 0x3e	; 62
   143ec:	12 96       	adiw	r26, 0x02	; 2
   143ee:	9c 93       	st	X, r25
   143f0:	8e 93       	st	-X, r24
   143f2:	11 97       	sbiw	r26, 0x01	; 1
   143f4:	83 ec       	ldi	r24, 0xC3	; 195
   143f6:	9e e1       	ldi	r25, 0x1E	; 30
   143f8:	93 83       	std	Z+3, r25	; 0x03
   143fa:	82 83       	std	Z+2, r24	; 0x02
   143fc:	80 e9       	ldi	r24, 0x90	; 144
   143fe:	93 e0       	ldi	r25, 0x03	; 3
   14400:	95 83       	std	Z+5, r25	; 0x05
   14402:	84 83       	std	Z+4, r24	; 0x04
   14404:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
				    stLocalAccount=laOdometer;
   14408:	81 e1       	ldi	r24, 0x11	; 17
   1440a:	80 93 5c 01 	sts	0x015C, r24
					lcd_clear();
   1440e:	ed b7       	in	r30, 0x3d	; 61
   14410:	fe b7       	in	r31, 0x3e	; 62
   14412:	36 96       	adiw	r30, 0x06	; 6
   14414:	0f b6       	in	r0, 0x3f	; 63
   14416:	f8 94       	cli
   14418:	fe bf       	out	0x3e, r31	; 62
   1441a:	0f be       	out	0x3f, r0	; 63
   1441c:	ed bf       	out	0x3d, r30	; 61
   1441e:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
   14422:	88 ea       	ldi	r24, 0xA8	; 168
   14424:	91 e6       	ldi	r25, 0x61	; 97
   14426:	01 97       	sbiw	r24, 0x01	; 1
   14428:	f1 f7       	brne	.-4      	; 0x14426 <FMenuLocalAccount+0xcce>
   1442a:	c2 c3       	rjmp	.+1924   	; 0x14bb0 <FMenuLocalAccount+0x1458>
					_delay_ms(100);		        
					}
		        break;
           case laOdometer://GetOdometer			
		        lcd_clear();
   1442c:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
				if (IsFullAuthorized==True){
   14430:	80 91 74 03 	lds	r24, 0x0374
   14434:	81 30       	cpi	r24, 0x01	; 1
   14436:	09 f0       	breq	.+2      	; 0x1443a <FMenuLocalAccount+0xce2>
   14438:	4a c0       	rjmp	.+148    	; 0x144ce <FMenuLocalAccount+0xd76>
				    lcd_printf(1,1,PSTR("Pump Product   Full"));
   1443a:	61 e0       	ldi	r22, 0x01	; 1
   1443c:	4f ea       	ldi	r20, 0xAF	; 175
   1443e:	5e e1       	ldi	r21, 0x1E	; 30
   14440:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
					sprintf_P(lcdteks,PSTR("  %s %s "),strFIP,strProduct);    lcd_print(2,1,lcdteks);    //"P01  Pertamax       "
   14444:	2d b7       	in	r18, 0x3d	; 61
   14446:	3e b7       	in	r19, 0x3e	; 62
   14448:	28 50       	subi	r18, 0x08	; 8
   1444a:	30 40       	sbci	r19, 0x00	; 0
   1444c:	0f b6       	in	r0, 0x3f	; 63
   1444e:	f8 94       	cli
   14450:	3e bf       	out	0x3e, r19	; 62
   14452:	0f be       	out	0x3f, r0	; 63
   14454:	2d bf       	out	0x3d, r18	; 61
   14456:	ed b7       	in	r30, 0x3d	; 61
   14458:	fe b7       	in	r31, 0x3e	; 62
   1445a:	31 96       	adiw	r30, 0x01	; 1
   1445c:	8e 01       	movw	r16, r28
   1445e:	0f 5f       	subi	r16, 0xFF	; 255
   14460:	1f 4f       	sbci	r17, 0xFF	; 255
   14462:	ad b7       	in	r26, 0x3d	; 61
   14464:	be b7       	in	r27, 0x3e	; 62
   14466:	12 96       	adiw	r26, 0x02	; 2
   14468:	1c 93       	st	X, r17
   1446a:	0e 93       	st	-X, r16
   1446c:	11 97       	sbiw	r26, 0x01	; 1
   1446e:	86 ea       	ldi	r24, 0xA6	; 166
   14470:	9e e1       	ldi	r25, 0x1E	; 30
   14472:	93 83       	std	Z+3, r25	; 0x03
   14474:	82 83       	std	Z+2, r24	; 0x02
   14476:	8d e9       	ldi	r24, 0x9D	; 157
   14478:	93 e0       	ldi	r25, 0x03	; 3
   1447a:	95 83       	std	Z+5, r25	; 0x05
   1447c:	84 83       	std	Z+4, r24	; 0x04
   1447e:	81 e4       	ldi	r24, 0x41	; 65
   14480:	99 e0       	ldi	r25, 0x09	; 9
   14482:	97 83       	std	Z+7, r25	; 0x07
   14484:	86 83       	std	Z+6, r24	; 0x06
   14486:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
   1448a:	ed b7       	in	r30, 0x3d	; 61
   1448c:	fe b7       	in	r31, 0x3e	; 62
   1448e:	38 96       	adiw	r30, 0x08	; 8
   14490:	0f b6       	in	r0, 0x3f	; 63
   14492:	f8 94       	cli
   14494:	fe bf       	out	0x3e, r31	; 62
   14496:	0f be       	out	0x3f, r0	; 63
   14498:	ed bf       	out	0x3d, r30	; 61
   1449a:	82 e0       	ldi	r24, 0x02	; 2
   1449c:	61 e0       	ldi	r22, 0x01	; 1
   1449e:	a8 01       	movw	r20, r16
   144a0:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
		            sprintf_P(lcdteks,PSTR("  Tank"));            lcd_print(2,14,lcdteks);   //"P01  Pertamax 500000"
   144a4:	00 d0       	rcall	.+0      	; 0x144a6 <FMenuLocalAccount+0xd4e>
   144a6:	00 d0       	rcall	.+0      	; 0x144a8 <FMenuLocalAccount+0xd50>
   144a8:	ad b7       	in	r26, 0x3d	; 61
   144aa:	be b7       	in	r27, 0x3e	; 62
   144ac:	12 96       	adiw	r26, 0x02	; 2
   144ae:	1c 93       	st	X, r17
   144b0:	0e 93       	st	-X, r16
   144b2:	11 97       	sbiw	r26, 0x01	; 1
   144b4:	8f e9       	ldi	r24, 0x9F	; 159
   144b6:	9e e1       	ldi	r25, 0x1E	; 30
   144b8:	14 96       	adiw	r26, 0x04	; 4
   144ba:	9c 93       	st	X, r25
   144bc:	8e 93       	st	-X, r24
   144be:	13 97       	sbiw	r26, 0x03	; 3
   144c0:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
   144c4:	0f 90       	pop	r0
   144c6:	0f 90       	pop	r0
   144c8:	0f 90       	pop	r0
   144ca:	0f 90       	pop	r0
   144cc:	5e c0       	rjmp	.+188    	; 0x1458a <FMenuLocalAccount+0xe32>
				}
                else{
		            if (BalanceType==1) lcd_printf(1,1,PSTR("Pump Product Volume"));
   144ce:	80 91 a0 03 	lds	r24, 0x03A0
   144d2:	81 30       	cpi	r24, 0x01	; 1
   144d4:	29 f4       	brne	.+10     	; 0x144e0 <FMenuLocalAccount+0xd88>
   144d6:	61 e0       	ldi	r22, 0x01	; 1
   144d8:	4b e8       	ldi	r20, 0x8B	; 139
   144da:	5e e1       	ldi	r21, 0x1E	; 30
   144dc:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
                    if (BalanceType==2) lcd_printf(1,1,PSTR("Pump Product Amount"));//"Pump Product  Amount" 
   144e0:	80 91 a0 03 	lds	r24, 0x03A0
   144e4:	82 30       	cpi	r24, 0x02	; 2
   144e6:	31 f4       	brne	.+12     	; 0x144f4 <FMenuLocalAccount+0xd9c>
   144e8:	81 e0       	ldi	r24, 0x01	; 1
   144ea:	61 e0       	ldi	r22, 0x01	; 1
   144ec:	47 e7       	ldi	r20, 0x77	; 119
   144ee:	5e e1       	ldi	r21, 0x1E	; 30
   144f0:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
					sprintf_P(lcdteks,PSTR("  %s %s "),strFIP,strProduct);    lcd_print(2,1,lcdteks);    //"P01  Pertamax       "
   144f4:	ed b7       	in	r30, 0x3d	; 61
   144f6:	fe b7       	in	r31, 0x3e	; 62
   144f8:	38 97       	sbiw	r30, 0x08	; 8
   144fa:	0f b6       	in	r0, 0x3f	; 63
   144fc:	f8 94       	cli
   144fe:	fe bf       	out	0x3e, r31	; 62
   14500:	0f be       	out	0x3f, r0	; 63
   14502:	ed bf       	out	0x3d, r30	; 61
   14504:	31 96       	adiw	r30, 0x01	; 1
   14506:	8e 01       	movw	r16, r28
   14508:	0f 5f       	subi	r16, 0xFF	; 255
   1450a:	1f 4f       	sbci	r17, 0xFF	; 255
   1450c:	ad b7       	in	r26, 0x3d	; 61
   1450e:	be b7       	in	r27, 0x3e	; 62
   14510:	12 96       	adiw	r26, 0x02	; 2
   14512:	1c 93       	st	X, r17
   14514:	0e 93       	st	-X, r16
   14516:	11 97       	sbiw	r26, 0x01	; 1
   14518:	8e e6       	ldi	r24, 0x6E	; 110
   1451a:	9e e1       	ldi	r25, 0x1E	; 30
   1451c:	93 83       	std	Z+3, r25	; 0x03
   1451e:	82 83       	std	Z+2, r24	; 0x02
   14520:	8d e9       	ldi	r24, 0x9D	; 157
   14522:	93 e0       	ldi	r25, 0x03	; 3
   14524:	95 83       	std	Z+5, r25	; 0x05
   14526:	84 83       	std	Z+4, r24	; 0x04
   14528:	81 e4       	ldi	r24, 0x41	; 65
   1452a:	99 e0       	ldi	r25, 0x09	; 9
   1452c:	97 83       	std	Z+7, r25	; 0x07
   1452e:	86 83       	std	Z+6, r24	; 0x06
   14530:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
   14534:	ed b7       	in	r30, 0x3d	; 61
   14536:	fe b7       	in	r31, 0x3e	; 62
   14538:	38 96       	adiw	r30, 0x08	; 8
   1453a:	0f b6       	in	r0, 0x3f	; 63
   1453c:	f8 94       	cli
   1453e:	fe bf       	out	0x3e, r31	; 62
   14540:	0f be       	out	0x3f, r0	; 63
   14542:	ed bf       	out	0x3d, r30	; 61
   14544:	82 e0       	ldi	r24, 0x02	; 2
   14546:	61 e0       	ldi	r22, 0x01	; 1
   14548:	a8 01       	movw	r20, r16
   1454a:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
		            sprintf_P(lcdteks,PSTR("%s "),strBalanceValue);            lcd_print(2,14,lcdteks);   //"P01  Pertamax 500000"
   1454e:	00 d0       	rcall	.+0      	; 0x14550 <FMenuLocalAccount+0xdf8>
   14550:	00 d0       	rcall	.+0      	; 0x14552 <FMenuLocalAccount+0xdfa>
   14552:	00 d0       	rcall	.+0      	; 0x14554 <FMenuLocalAccount+0xdfc>
   14554:	ed b7       	in	r30, 0x3d	; 61
   14556:	fe b7       	in	r31, 0x3e	; 62
   14558:	31 96       	adiw	r30, 0x01	; 1
   1455a:	ad b7       	in	r26, 0x3d	; 61
   1455c:	be b7       	in	r27, 0x3e	; 62
   1455e:	12 96       	adiw	r26, 0x02	; 2
   14560:	1c 93       	st	X, r17
   14562:	0e 93       	st	-X, r16
   14564:	11 97       	sbiw	r26, 0x01	; 1
   14566:	8a e6       	ldi	r24, 0x6A	; 106
   14568:	9e e1       	ldi	r25, 0x1E	; 30
   1456a:	93 83       	std	Z+3, r25	; 0x03
   1456c:	82 83       	std	Z+2, r24	; 0x02
   1456e:	8a ef       	ldi	r24, 0xFA	; 250
   14570:	9d e0       	ldi	r25, 0x0D	; 13
   14572:	95 83       	std	Z+5, r25	; 0x05
   14574:	84 83       	std	Z+4, r24	; 0x04
   14576:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
   1457a:	ed b7       	in	r30, 0x3d	; 61
   1457c:	fe b7       	in	r31, 0x3e	; 62
   1457e:	36 96       	adiw	r30, 0x06	; 6
   14580:	0f b6       	in	r0, 0x3f	; 63
   14582:	f8 94       	cli
   14584:	fe bf       	out	0x3e, r31	; 62
   14586:	0f be       	out	0x3f, r0	; 63
   14588:	ed bf       	out	0x3d, r30	; 61
   1458a:	82 e0       	ldi	r24, 0x02	; 2
   1458c:	6e e0       	ldi	r22, 0x0E	; 14
   1458e:	a8 01       	movw	r20, r16
   14590:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>

				}
				lcd_printf(3,1,PSTR("Odometer:_       "));                                //"Odometer:_          "
   14594:	83 e0       	ldi	r24, 0x03	; 3
   14596:	61 e0       	ldi	r22, 0x01	; 1
   14598:	48 e5       	ldi	r20, 0x58	; 88
   1459a:	5e e1       	ldi	r21, 0x1E	; 30
   1459c:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
	            lcd_printf(4,1,PSTR("[*]Back  [#]OK   "));                                //"[*]Back  [#]OK      "						        
   145a0:	84 e0       	ldi	r24, 0x04	; 4
   145a2:	61 e0       	ldi	r22, 0x01	; 1
   145a4:	46 e4       	ldi	r20, 0x46	; 70
   145a6:	5e e1       	ldi	r21, 0x1E	; 30
   145a8:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
                //iLoop=0;
				//iValuePos=0;
				//ValueChar[iValuePos]=' ';        
				ClearMem(strOdometer);
   145ac:	83 ea       	ldi	r24, 0xA3	; 163
   145ae:	95 e0       	ldi	r25, 0x05	; 5
   145b0:	0e 94 a6 ad 	call	0x15b4c	; 0x15b4c <ClearMem>
		        stLocalAccount=laOdometerInput;
   145b4:	82 e1       	ldi	r24, 0x12	; 18
   145b6:	29 c0       	rjmp	.+82     	; 0x1460a <FMenuLocalAccount+0xeb2>
		        break;
           case laOdometerInput:
		        //Blinking 50% _      BalanceValue Volume=999  Amount=65536
			    //iLoop++;
				uiResult=UserInput(UI_NUMBER_R,3,10,strOdometer,0,10);
   145b8:	13 ea       	ldi	r17, 0xA3	; 163
   145ba:	c1 2e       	mov	r12, r17
   145bc:	15 e0       	ldi	r17, 0x05	; 5
   145be:	d1 2e       	mov	r13, r17
   145c0:	81 e0       	ldi	r24, 0x01	; 1
   145c2:	63 e0       	ldi	r22, 0x03	; 3
   145c4:	4a e0       	ldi	r20, 0x0A	; 10
   145c6:	96 01       	movw	r18, r12
   145c8:	00 e0       	ldi	r16, 0x00	; 0
   145ca:	10 e0       	ldi	r17, 0x00	; 0
   145cc:	ba e0       	ldi	r27, 0x0A	; 10
   145ce:	eb 2e       	mov	r14, r27
   145d0:	0e 94 f0 7b 	call	0xf7e0	; 0xf7e0 <UserInput>
				if (uiResult==USER_OK){
   145d4:	83 30       	cpi	r24, 0x03	; 3
   145d6:	79 f4       	brne	.+30     	; 0x145f6 <FMenuLocalAccount+0xe9e>
				    if ((strlen(strOdometer)==1)&&(strOdometer[0]=='0'))
   145d8:	f6 01       	movw	r30, r12
   145da:	01 90       	ld	r0, Z+
   145dc:	00 20       	and	r0, r0
   145de:	e9 f7       	brne	.-6      	; 0x145da <FMenuLocalAccount+0xe82>
   145e0:	e5 5a       	subi	r30, 0xA5	; 165
   145e2:	f5 40       	sbci	r31, 0x05	; 5
   145e4:	31 f4       	brne	.+12     	; 0x145f2 <FMenuLocalAccount+0xe9a>
   145e6:	80 91 a3 05 	lds	r24, 0x05A3
   145ea:	80 33       	cpi	r24, 0x30	; 48
   145ec:	11 f4       	brne	.+4      	; 0x145f2 <FMenuLocalAccount+0xe9a>
					    strOdometer[0]=0;
   145ee:	10 92 a3 05 	sts	0x05A3, r1

				    stLocalAccount=laDataConfirm;
   145f2:	83 e1       	ldi	r24, 0x13	; 19
   145f4:	0a c0       	rjmp	.+20     	; 0x1460a <FMenuLocalAccount+0xeb2>
					}
			    else
			    if (uiResult==USER_CANCEL){
   145f6:	81 30       	cpi	r24, 0x01	; 1
   145f8:	09 f0       	breq	.+2      	; 0x145fc <FMenuLocalAccount+0xea4>
   145fa:	da c2       	rjmp	.+1460   	; 0x14bb0 <FMenuLocalAccount+0x1458>
				    if (IsFullAuthorized==True)
   145fc:	80 91 74 03 	lds	r24, 0x0374
   14600:	81 30       	cpi	r24, 0x01	; 1
   14602:	11 f4       	brne	.+4      	; 0x14608 <FMenuLocalAccount+0xeb0>
					     stLocalAccount=laSelectBalanceType;
   14604:	8d e0       	ldi	r24, 0x0D	; 13
   14606:	01 c0       	rjmp	.+2      	; 0x1460a <FMenuLocalAccount+0xeb2>
					else stLocalAccount=laBalanceValue;		        
   14608:	8f e0       	ldi	r24, 0x0F	; 15
   1460a:	80 93 5c 01 	sts	0x015C, r24
   1460e:	d0 c2       	rjmp	.+1440   	; 0x14bb0 <FMenuLocalAccount+0x1458>
					}
                */

		        break;
           case laDataConfirm: 
		        lcd_clear();
   14610:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
   14614:	ed e0       	ldi	r30, 0x0D	; 13
   14616:	f5 e0       	ldi	r31, 0x05	; 5
   14618:	de 01       	movw	r26, r28
   1461a:	55 96       	adiw	r26, 0x15	; 21
	 }Dest[Length]=0;
}
void StringCopyPos(char *Source,char *Dest,char SrcPos,char Length){
     char i;
	 for (i=0;i<Length;i++){
	     Dest[i]=Source[SrcPos+i];
   1461c:	81 91       	ld	r24, Z+
   1461e:	8d 93       	st	X+, r24
	     Dest[i]=Source[i];
	 }Dest[Length]=0;
}
void StringCopyPos(char *Source,char *Dest,char SrcPos,char Length){
     char i;
	 for (i=0;i<Length;i++){
   14620:	35 e0       	ldi	r19, 0x05	; 5
   14622:	e7 31       	cpi	r30, 0x17	; 23
   14624:	f3 07       	cpc	r31, r19
   14626:	d1 f7       	brne	.-12     	; 0x1461c <FMenuLocalAccount+0xec4>
	     Dest[i]=Source[SrcPos+i];
	 }Dest[Length]=0;
   14628:	1f 8e       	std	Y+31, r1	; 0x1f

		        break;
           case laDataConfirm: 
		        lcd_clear();
		        StringCopyPos(strCardHolder,strName,9,10);                                          //Data Confirmation   
                sprintf_P(lcdteks,PSTR("%s "),strName);                  lcd_print(1,1,lcdteks);    //"Iyan The Man        "
   1462a:	00 d0       	rcall	.+0      	; 0x1462c <FMenuLocalAccount+0xed4>
   1462c:	00 d0       	rcall	.+0      	; 0x1462e <FMenuLocalAccount+0xed6>
   1462e:	00 d0       	rcall	.+0      	; 0x14630 <FMenuLocalAccount+0xed8>
   14630:	ed b7       	in	r30, 0x3d	; 61
   14632:	fe b7       	in	r31, 0x3e	; 62
   14634:	31 96       	adiw	r30, 0x01	; 1
   14636:	8e 01       	movw	r16, r28
   14638:	0f 5f       	subi	r16, 0xFF	; 255
   1463a:	1f 4f       	sbci	r17, 0xFF	; 255
   1463c:	ad b7       	in	r26, 0x3d	; 61
   1463e:	be b7       	in	r27, 0x3e	; 62
   14640:	12 96       	adiw	r26, 0x02	; 2
   14642:	1c 93       	st	X, r17
   14644:	0e 93       	st	-X, r16
   14646:	11 97       	sbiw	r26, 0x01	; 1
   14648:	82 e4       	ldi	r24, 0x42	; 66
   1464a:	9e e1       	ldi	r25, 0x1E	; 30
   1464c:	93 83       	std	Z+3, r25	; 0x03
   1464e:	82 83       	std	Z+2, r24	; 0x02
   14650:	ce 01       	movw	r24, r28
   14652:	45 96       	adiw	r24, 0x15	; 21
   14654:	95 83       	std	Z+5, r25	; 0x05
   14656:	84 83       	std	Z+4, r24	; 0x04
   14658:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
   1465c:	ed b7       	in	r30, 0x3d	; 61
   1465e:	fe b7       	in	r31, 0x3e	; 62
   14660:	36 96       	adiw	r30, 0x06	; 6
   14662:	0f b6       	in	r0, 0x3f	; 63
   14664:	f8 94       	cli
   14666:	fe bf       	out	0x3e, r31	; 62
   14668:	0f be       	out	0x3f, r0	; 63
   1466a:	ed bf       	out	0x3d, r30	; 61
   1466c:	81 e0       	ldi	r24, 0x01	; 1
   1466e:	61 e0       	ldi	r22, 0x01	; 1
   14670:	a8 01       	movw	r20, r16
   14672:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
		        sprintf_P(lcdteks,PSTR("ID: %s"),strCardID);             lcd_print(2,1,lcdteks);    //"ID1CCDA565 OD:123456"
   14676:	00 d0       	rcall	.+0      	; 0x14678 <FMenuLocalAccount+0xf20>
   14678:	00 d0       	rcall	.+0      	; 0x1467a <FMenuLocalAccount+0xf22>
   1467a:	00 d0       	rcall	.+0      	; 0x1467c <FMenuLocalAccount+0xf24>
   1467c:	ed b7       	in	r30, 0x3d	; 61
   1467e:	fe b7       	in	r31, 0x3e	; 62
   14680:	31 96       	adiw	r30, 0x01	; 1
   14682:	ad b7       	in	r26, 0x3d	; 61
   14684:	be b7       	in	r27, 0x3e	; 62
   14686:	12 96       	adiw	r26, 0x02	; 2
   14688:	1c 93       	st	X, r17
   1468a:	0e 93       	st	-X, r16
   1468c:	11 97       	sbiw	r26, 0x01	; 1
   1468e:	8b e3       	ldi	r24, 0x3B	; 59
   14690:	9e e1       	ldi	r25, 0x1E	; 30
   14692:	93 83       	std	Z+3, r25	; 0x03
   14694:	82 83       	std	Z+2, r24	; 0x02
   14696:	81 e6       	ldi	r24, 0x61	; 97
   14698:	9d e0       	ldi	r25, 0x0D	; 13
   1469a:	95 83       	std	Z+5, r25	; 0x05
   1469c:	84 83       	std	Z+4, r24	; 0x04
   1469e:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
   146a2:	ed b7       	in	r30, 0x3d	; 61
   146a4:	fe b7       	in	r31, 0x3e	; 62
   146a6:	36 96       	adiw	r30, 0x06	; 6
   146a8:	0f b6       	in	r0, 0x3f	; 63
   146aa:	f8 94       	cli
   146ac:	fe bf       	out	0x3e, r31	; 62
   146ae:	0f be       	out	0x3f, r0	; 63
   146b0:	ed bf       	out	0x3d, r30	; 61
   146b2:	82 e0       	ldi	r24, 0x02	; 2
   146b4:	61 e0       	ldi	r22, 0x01	; 1
   146b6:	a8 01       	movw	r20, r16
   146b8:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
				sprintf_P(lcdteks,PSTR("%s  %s "),strFIP,strProduct);    lcd_print(3,1,lcdteks);    //"P01  Pertamax 500000"
   146bc:	2d b7       	in	r18, 0x3d	; 61
   146be:	3e b7       	in	r19, 0x3e	; 62
   146c0:	28 50       	subi	r18, 0x08	; 8
   146c2:	30 40       	sbci	r19, 0x00	; 0
   146c4:	0f b6       	in	r0, 0x3f	; 63
   146c6:	f8 94       	cli
   146c8:	3e bf       	out	0x3e, r19	; 62
   146ca:	0f be       	out	0x3f, r0	; 63
   146cc:	2d bf       	out	0x3d, r18	; 61
   146ce:	ed b7       	in	r30, 0x3d	; 61
   146d0:	fe b7       	in	r31, 0x3e	; 62
   146d2:	31 96       	adiw	r30, 0x01	; 1
   146d4:	ad b7       	in	r26, 0x3d	; 61
   146d6:	be b7       	in	r27, 0x3e	; 62
   146d8:	12 96       	adiw	r26, 0x02	; 2
   146da:	1c 93       	st	X, r17
   146dc:	0e 93       	st	-X, r16
   146de:	11 97       	sbiw	r26, 0x01	; 1
   146e0:	83 e3       	ldi	r24, 0x33	; 51
   146e2:	9e e1       	ldi	r25, 0x1E	; 30
   146e4:	93 83       	std	Z+3, r25	; 0x03
   146e6:	82 83       	std	Z+2, r24	; 0x02
   146e8:	8d e9       	ldi	r24, 0x9D	; 157
   146ea:	93 e0       	ldi	r25, 0x03	; 3
   146ec:	95 83       	std	Z+5, r25	; 0x05
   146ee:	84 83       	std	Z+4, r24	; 0x04
   146f0:	81 e4       	ldi	r24, 0x41	; 65
   146f2:	99 e0       	ldi	r25, 0x09	; 9
   146f4:	97 83       	std	Z+7, r25	; 0x07
   146f6:	86 83       	std	Z+6, r24	; 0x06
   146f8:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
   146fc:	ed b7       	in	r30, 0x3d	; 61
   146fe:	fe b7       	in	r31, 0x3e	; 62
   14700:	38 96       	adiw	r30, 0x08	; 8
   14702:	0f b6       	in	r0, 0x3f	; 63
   14704:	f8 94       	cli
   14706:	fe bf       	out	0x3e, r31	; 62
   14708:	0f be       	out	0x3f, r0	; 63
   1470a:	ed bf       	out	0x3d, r30	; 61
   1470c:	83 e0       	ldi	r24, 0x03	; 3
   1470e:	61 e0       	ldi	r22, 0x01	; 1
   14710:	a8 01       	movw	r20, r16
   14712:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
		        if (IsFullAuthorized==True){
   14716:	80 91 74 03 	lds	r24, 0x0374
   1471a:	81 30       	cpi	r24, 0x01	; 1
   1471c:	39 f4       	brne	.+14     	; 0x1472c <FMenuLocalAccount+0xfd4>
                    lcd_printf(3,15,PSTR(" Full"));
   1471e:	83 e0       	ldi	r24, 0x03	; 3
   14720:	6f e0       	ldi	r22, 0x0F	; 15
   14722:	4d e2       	ldi	r20, 0x2D	; 45
   14724:	5e e1       	ldi	r21, 0x1E	; 30
   14726:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
   1472a:	23 c0       	rjmp	.+70     	; 0x14772 <FMenuLocalAccount+0x101a>
				}
				else {
				    sprintf_P(lcdteks,PSTR("%s "),strBalanceValue);          lcd_print(3,15,lcdteks);   //"[*]Back [0]ESC [#]OK " 
   1472c:	00 d0       	rcall	.+0      	; 0x1472e <FMenuLocalAccount+0xfd6>
   1472e:	00 d0       	rcall	.+0      	; 0x14730 <FMenuLocalAccount+0xfd8>
   14730:	00 d0       	rcall	.+0      	; 0x14732 <FMenuLocalAccount+0xfda>
   14732:	ed b7       	in	r30, 0x3d	; 61
   14734:	fe b7       	in	r31, 0x3e	; 62
   14736:	31 96       	adiw	r30, 0x01	; 1
   14738:	ad b7       	in	r26, 0x3d	; 61
   1473a:	be b7       	in	r27, 0x3e	; 62
   1473c:	12 96       	adiw	r26, 0x02	; 2
   1473e:	1c 93       	st	X, r17
   14740:	0e 93       	st	-X, r16
   14742:	11 97       	sbiw	r26, 0x01	; 1
   14744:	89 e2       	ldi	r24, 0x29	; 41
   14746:	9e e1       	ldi	r25, 0x1E	; 30
   14748:	93 83       	std	Z+3, r25	; 0x03
   1474a:	82 83       	std	Z+2, r24	; 0x02
   1474c:	8a ef       	ldi	r24, 0xFA	; 250
   1474e:	9d e0       	ldi	r25, 0x0D	; 13
   14750:	95 83       	std	Z+5, r25	; 0x05
   14752:	84 83       	std	Z+4, r24	; 0x04
   14754:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
   14758:	ed b7       	in	r30, 0x3d	; 61
   1475a:	fe b7       	in	r31, 0x3e	; 62
   1475c:	36 96       	adiw	r30, 0x06	; 6
   1475e:	0f b6       	in	r0, 0x3f	; 63
   14760:	f8 94       	cli
   14762:	fe bf       	out	0x3e, r31	; 62
   14764:	0f be       	out	0x3f, r0	; 63
   14766:	ed bf       	out	0x3d, r30	; 61
   14768:	83 e0       	ldi	r24, 0x03	; 3
   1476a:	6f e0       	ldi	r22, 0x0F	; 15
   1476c:	a8 01       	movw	r20, r16
   1476e:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
					}
	            lcd_printf(4,1,PSTR("[*]Back [0]ESC [#]OK"));    
   14772:	84 e0       	ldi	r24, 0x04	; 4
   14774:	61 e0       	ldi	r22, 0x01	; 1
   14776:	44 e1       	ldi	r20, 0x14	; 20
   14778:	5e e1       	ldi	r21, 0x1E	; 30
   1477a:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
                stLocalAccount=laDataConfirmInput;
   1477e:	84 e1       	ldi	r24, 0x14	; 20
   14780:	44 cf       	rjmp	.-376    	; 0x1460a <FMenuLocalAccount+0xeb2>
                //while(1){};   
		        break;
           case laDataConfirmInput:
                KeyPressed=_key_scan(1);
   14782:	81 e0       	ldi	r24, 0x01	; 1
   14784:	0e 94 ab ae 	call	0x15d56	; 0x15d56 <_key_scan>
   14788:	80 93 9c 03 	sts	0x039C, r24
                if (KeyPressed==_KEY_CANCEL)stLocalAccount=laOdometer;		        
   1478c:	87 3e       	cpi	r24, 0xE7	; 231
   1478e:	11 f4       	brne	.+4      	; 0x14794 <FMenuLocalAccount+0x103c>
   14790:	81 e1       	ldi	r24, 0x11	; 17
   14792:	3b cf       	rjmp	.-394    	; 0x1460a <FMenuLocalAccount+0xeb2>
				else
				if (KeyPressed==_KEY_ENTER)stLocalAccount=laProceedTransaction;
   14794:	87 3b       	cpi	r24, 0xB7	; 183
   14796:	11 f4       	brne	.+4      	; 0x1479c <FMenuLocalAccount+0x1044>
   14798:	85 e1       	ldi	r24, 0x15	; 21
   1479a:	37 cf       	rjmp	.-402    	; 0x1460a <FMenuLocalAccount+0xeb2>
				else
				if (KeyPressed==_KEY_0){
   1479c:	87 3d       	cpi	r24, 0xD7	; 215
   1479e:	09 f0       	breq	.+2      	; 0x147a2 <FMenuLocalAccount+0x104a>
   147a0:	07 c2       	rjmp	.+1038   	; 0x14bb0 <FMenuLocalAccount+0x1458>
				   //ShowCancel
				   TimLocAcc=0;
   147a2:	10 92 d3 01 	sts	0x01D3, r1
   147a6:	10 92 d2 01 	sts	0x01D2, r1
                   lcd_clear();
   147aa:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
				   lcd_printf(1,1,PSTR("Cancel Transaction  "));    //"Cancel Transaction"
   147ae:	81 e0       	ldi	r24, 0x01	; 1
   147b0:	61 e0       	ldi	r22, 0x01	; 1
   147b2:	4f ef       	ldi	r20, 0xFF	; 255
   147b4:	5d e1       	ldi	r21, 0x1D	; 29
   147b6:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
   147ba:	e9 c1       	rjmp	.+978    	; 0x14b8e <FMenuLocalAccount+0x1436>
				   stLocalAccount=laDelayExit;
				   }
		        break;
           case laProceedTransaction:
		        sendMessage58();
   147bc:	0e 94 32 4f 	call	0x9e64	; 0x9e64 <sendMessage58>
                RemZeroLead(strCardID);
   147c0:	81 e6       	ldi	r24, 0x61	; 97
   147c2:	9d e0       	ldi	r25, 0x0D	; 13
   147c4:	0e 94 dd 23 	call	0x47ba	; 0x47ba <RemZeroLead>
                RemZeroLead(strBalanceValue);
   147c8:	aa ef       	ldi	r26, 0xFA	; 250
   147ca:	ea 2e       	mov	r14, r26
   147cc:	ad e0       	ldi	r26, 0x0D	; 13
   147ce:	fa 2e       	mov	r15, r26
   147d0:	c7 01       	movw	r24, r14
   147d2:	0e 94 dd 23 	call	0x47ba	; 0x47ba <RemZeroLead>
				sprintf_P(lcdteks,PSTR("P%s %s "),strFIP,strProduct);       lcd_print(1,1,lcdteks);    //"P01  Pertamax 500000"
   147d6:	2d b7       	in	r18, 0x3d	; 61
   147d8:	3e b7       	in	r19, 0x3e	; 62
   147da:	28 50       	subi	r18, 0x08	; 8
   147dc:	30 40       	sbci	r19, 0x00	; 0
   147de:	0f b6       	in	r0, 0x3f	; 63
   147e0:	f8 94       	cli
   147e2:	3e bf       	out	0x3e, r19	; 62
   147e4:	0f be       	out	0x3f, r0	; 63
   147e6:	2d bf       	out	0x3d, r18	; 61
   147e8:	ed b7       	in	r30, 0x3d	; 61
   147ea:	fe b7       	in	r31, 0x3e	; 62
   147ec:	31 96       	adiw	r30, 0x01	; 1
   147ee:	8e 01       	movw	r16, r28
   147f0:	0f 5f       	subi	r16, 0xFF	; 255
   147f2:	1f 4f       	sbci	r17, 0xFF	; 255
   147f4:	ad b7       	in	r26, 0x3d	; 61
   147f6:	be b7       	in	r27, 0x3e	; 62
   147f8:	12 96       	adiw	r26, 0x02	; 2
   147fa:	1c 93       	st	X, r17
   147fc:	0e 93       	st	-X, r16
   147fe:	11 97       	sbiw	r26, 0x01	; 1
   14800:	87 ef       	ldi	r24, 0xF7	; 247
   14802:	9d e1       	ldi	r25, 0x1D	; 29
   14804:	93 83       	std	Z+3, r25	; 0x03
   14806:	82 83       	std	Z+2, r24	; 0x02
   14808:	8d e9       	ldi	r24, 0x9D	; 157
   1480a:	93 e0       	ldi	r25, 0x03	; 3
   1480c:	95 83       	std	Z+5, r25	; 0x05
   1480e:	84 83       	std	Z+4, r24	; 0x04
   14810:	81 e4       	ldi	r24, 0x41	; 65
   14812:	99 e0       	ldi	r25, 0x09	; 9
   14814:	97 83       	std	Z+7, r25	; 0x07
   14816:	86 83       	std	Z+6, r24	; 0x06
   14818:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
   1481c:	ed b7       	in	r30, 0x3d	; 61
   1481e:	fe b7       	in	r31, 0x3e	; 62
   14820:	38 96       	adiw	r30, 0x08	; 8
   14822:	0f b6       	in	r0, 0x3f	; 63
   14824:	f8 94       	cli
   14826:	fe bf       	out	0x3e, r31	; 62
   14828:	0f be       	out	0x3f, r0	; 63
   1482a:	ed bf       	out	0x3d, r30	; 61
   1482c:	81 e0       	ldi	r24, 0x01	; 1
   1482e:	61 e0       	ldi	r22, 0x01	; 1
   14830:	a8 01       	movw	r20, r16
   14832:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
		        sprintf_P(lcdteks,PSTR("%s"),strBalanceValue);              lcd_print(1,15,lcdteks);   //"ID1CCDA565          " 
   14836:	00 d0       	rcall	.+0      	; 0x14838 <FMenuLocalAccount+0x10e0>
   14838:	00 d0       	rcall	.+0      	; 0x1483a <FMenuLocalAccount+0x10e2>
   1483a:	00 d0       	rcall	.+0      	; 0x1483c <FMenuLocalAccount+0x10e4>
   1483c:	ed b7       	in	r30, 0x3d	; 61
   1483e:	fe b7       	in	r31, 0x3e	; 62
   14840:	31 96       	adiw	r30, 0x01	; 1
   14842:	ad b7       	in	r26, 0x3d	; 61
   14844:	be b7       	in	r27, 0x3e	; 62
   14846:	12 96       	adiw	r26, 0x02	; 2
   14848:	1c 93       	st	X, r17
   1484a:	0e 93       	st	-X, r16
   1484c:	11 97       	sbiw	r26, 0x01	; 1
   1484e:	84 ef       	ldi	r24, 0xF4	; 244
   14850:	9d e1       	ldi	r25, 0x1D	; 29
   14852:	93 83       	std	Z+3, r25	; 0x03
   14854:	82 83       	std	Z+2, r24	; 0x02
   14856:	f5 82       	std	Z+5, r15	; 0x05
   14858:	e4 82       	std	Z+4, r14	; 0x04
   1485a:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
   1485e:	ed b7       	in	r30, 0x3d	; 61
   14860:	fe b7       	in	r31, 0x3e	; 62
   14862:	36 96       	adiw	r30, 0x06	; 6
   14864:	0f b6       	in	r0, 0x3f	; 63
   14866:	f8 94       	cli
   14868:	fe bf       	out	0x3e, r31	; 62
   1486a:	0f be       	out	0x3f, r0	; 63
   1486c:	ed bf       	out	0x3d, r30	; 61
   1486e:	81 e0       	ldi	r24, 0x01	; 1
   14870:	6f e0       	ldi	r22, 0x0F	; 15
   14872:	a8 01       	movw	r20, r16
   14874:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
                lcd_printf(3,1,PSTR("Mohon Tunggu        "));                                         //"Mohon Tunggu ...    "
   14878:	83 e0       	ldi	r24, 0x03	; 3
   1487a:	61 e0       	ldi	r22, 0x01	; 1
   1487c:	4f ed       	ldi	r20, 0xDF	; 223
   1487e:	5d e1       	ldi	r21, 0x1D	; 29
   14880:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		        lcd_printf(4,1,PSTR("                    "));                                  //"                    "
   14884:	84 e0       	ldi	r24, 0x04	; 4
   14886:	61 e0       	ldi	r22, 0x01	; 1
   14888:	4a ec       	ldi	r20, 0xCA	; 202
   1488a:	5d e1       	ldi	r21, 0x1D	; 29
   1488c:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
				IsMessage00=False;
   14890:	10 92 b5 01 	sts	0x01B5, r1
				TimLocAcc=0;
   14894:	10 92 d3 01 	sts	0x01D3, r1
   14898:	10 92 d2 01 	sts	0x01D2, r1
				iLoop=0;iPos=0;iWait=0;
   1489c:	10 92 73 03 	sts	0x0373, r1
   148a0:	10 92 72 03 	sts	0x0372, r1
   148a4:	10 92 a3 03 	sts	0x03A3, r1
   148a8:	10 92 a2 03 	sts	0x03A2, r1
				stLocalAccount=laWaitMessage00;
   148ac:	87 e1       	ldi	r24, 0x17	; 23
   148ae:	ad ce       	rjmp	.-678    	; 0x1460a <FMenuLocalAccount+0xeb2>
		        break;
           case laWaitMessage00:
                iLoop++;
   148b0:	80 91 72 03 	lds	r24, 0x0372
   148b4:	90 91 73 03 	lds	r25, 0x0373
   148b8:	01 96       	adiw	r24, 0x01	; 1
   148ba:	90 93 73 03 	sts	0x0373, r25
   148be:	80 93 72 03 	sts	0x0372, r24
				if ((iLoop%MSG_WAIT_TIMOUT)==0){
   148c2:	68 e9       	ldi	r22, 0x98	; 152
   148c4:	7a e3       	ldi	r23, 0x3A	; 58
   148c6:	0e 94 38 b7 	call	0x16e70	; 0x16e70 <__udivmodhi4>
   148ca:	89 2b       	or	r24, r25
   148cc:	e1 f4       	brne	.+56     	; 0x14906 <FMenuLocalAccount+0x11ae>
				   if (iPos<5){
   148ce:	60 91 a3 03 	lds	r22, 0x03A3
   148d2:	65 30       	cpi	r22, 0x05	; 5
   148d4:	58 f4       	brcc	.+22     	; 0x148ec <FMenuLocalAccount+0x1194>
				       iPos++;
   148d6:	6f 5f       	subi	r22, 0xFF	; 255
   148d8:	60 93 a3 03 	sts	0x03A3, r22
					   lcd_xy(3,(14+iPos));_lcd('.');
   148dc:	62 5f       	subi	r22, 0xF2	; 242
   148de:	83 e0       	ldi	r24, 0x03	; 3
   148e0:	0e 94 f1 ac 	call	0x159e2	; 0x159e2 <lcd_xy>
   148e4:	8e e2       	ldi	r24, 0x2E	; 46
   148e6:	0e 94 cb ac 	call	0x15996	; 0x15996 <_lcd>
   148ea:	0d c0       	rjmp	.+26     	; 0x14906 <FMenuLocalAccount+0x11ae>
					   }
				   else{
				       iPos=0;
   148ec:	10 92 a3 03 	sts	0x03A3, r1
					   lcd_printf(3,(14+iPos),PSTR("       "));
   148f0:	83 e0       	ldi	r24, 0x03	; 3
   148f2:	6e e0       	ldi	r22, 0x0E	; 14
   148f4:	42 ec       	ldi	r20, 0xC2	; 194
   148f6:	5d e1       	ldi	r21, 0x1D	; 29
   148f8:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
					   iWait++;
   148fc:	80 91 a2 03 	lds	r24, 0x03A2
   14900:	8f 5f       	subi	r24, 0xFF	; 255
   14902:	80 93 a2 03 	sts	0x03A2, r24
					   }
				}
				if (iWait>5){
   14906:	80 91 a2 03 	lds	r24, 0x03A2
   1490a:	86 30       	cpi	r24, 0x06	; 6
   1490c:	78 f0       	brcs	.+30     	; 0x1492c <FMenuLocalAccount+0x11d4>
				    stLocalAccount=laConTimout;
   1490e:	84 e0       	ldi	r24, 0x04	; 4
   14910:	80 93 5c 01 	sts	0x015C, r24
					TimLocAcc=0;
   14914:	10 92 d3 01 	sts	0x01D3, r1
   14918:	10 92 d2 01 	sts	0x01D2, r1
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   1491c:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   1491e:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   14920:	82 e0       	ldi	r24, 0x02	; 2
   14922:	90 e0       	ldi	r25, 0x00	; 0
   14924:	90 93 d7 01 	sts	0x01D7, r25
   14928:	80 93 d6 01 	sts	0x01D6, r24
				if (iWait>5){
				    stLocalAccount=laConTimout;
					TimLocAcc=0;
					system_beep(2);
				    }
				if (IsMessage00==True){
   1492c:	80 91 b5 01 	lds	r24, 0x01B5
   14930:	81 30       	cpi	r24, 0x01	; 1
   14932:	09 f0       	breq	.+2      	; 0x14936 <FMenuLocalAccount+0x11de>
   14934:	3d c1       	rjmp	.+634    	; 0x14bb0 <FMenuLocalAccount+0x1458>
                    IsMessage00=False;
   14936:	10 92 b5 01 	sts	0x01B5, r1
				    stLocalAccount=laProcMessage00;
   1493a:	88 e1       	ldi	r24, 0x18	; 24
   1493c:	66 ce       	rjmp	.-820    	; 0x1460a <FMenuLocalAccount+0xeb2>
*/
char procMessage00(){
     char Result,strSend[10];
	 Result=MSG00_NACK;
	 //Message57
	 if((rcv_trans[0]==0x01)&&(transLength==MSG00_LENGTH)){
   1493e:	80 91 f5 0a 	lds	r24, 0x0AF5
   14942:	81 30       	cpi	r24, 0x01	; 1
   14944:	51 f4       	brne	.+20     	; 0x1495a <FMenuLocalAccount+0x1202>
   14946:	80 91 9e 01 	lds	r24, 0x019E
   1494a:	90 91 9f 01 	lds	r25, 0x019F
   1494e:	8f 97       	sbiw	r24, 0x2f	; 47
   14950:	21 f4       	brne	.+8      	; 0x1495a <FMenuLocalAccount+0x1202>
	     //Reply
		 Result=(CharPosCopy(rcv_trans,37)-'0');
   14952:	80 91 1a 0b 	lds	r24, 0x0B1A
   14956:	80 53       	subi	r24, 0x30	; 48
   14958:	01 c0       	rjmp	.+2      	; 0x1495c <FMenuLocalAccount+0x1204>
   1495a:	80 e0       	ldi	r24, 0x00	; 0
                    IsMessage00=False;
				    stLocalAccount=laProcMessage00;
					}
		        break;
           case laProcMessage00:
		        LocAccStatus=procMessage00();
   1495c:	80 93 a4 03 	sts	0x03A4, r24
                lcd_clear();
   14960:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
		        switch(LocAccStatus){
   14964:	10 91 a4 03 	lds	r17, 0x03A4
   14968:	11 30       	cpi	r17, 0x01	; 1
   1496a:	51 f0       	breq	.+20     	; 0x14980 <FMenuLocalAccount+0x1228>
   1496c:	11 30       	cpi	r17, 0x01	; 1
   1496e:	18 f0       	brcs	.+6      	; 0x14976 <FMenuLocalAccount+0x121e>
   14970:	13 30       	cpi	r17, 0x03	; 3
   14972:	69 f5       	brne	.+90     	; 0x149ce <FMenuLocalAccount+0x1276>
   14974:	1b c0       	rjmp	.+54     	; 0x149ac <FMenuLocalAccount+0x1254>
				case MSG00_NACK:
                     lcd_printf(2,1,PSTR("Authorisasi Gagal   "));
   14976:	82 e0       	ldi	r24, 0x02	; 2
   14978:	61 e0       	ldi	r22, 0x01	; 1
   1497a:	4d ea       	ldi	r20, 0xAD	; 173
   1497c:	5d e1       	ldi	r21, 0x1D	; 29
   1497e:	1a c0       	rjmp	.+52     	; 0x149b4 <FMenuLocalAccount+0x125c>
					 system_beep(2); 
					 stLocalAccount=laDelayExit;
				     break;
                case MSG00_ACK:
				     lcd_printf(2,1,PSTR("Authorisasi Berhasil"));
   14980:	82 e0       	ldi	r24, 0x02	; 2
   14982:	61 e0       	ldi	r22, 0x01	; 1
   14984:	48 e9       	ldi	r20, 0x98	; 152
   14986:	5d e1       	ldi	r21, 0x1D	; 29
   14988:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
				     LocalAccountFIP[nLocalAccount]=FIP_Used;
   1498c:	90 91 a4 01 	lds	r25, 0x01A4
   14990:	e9 2f       	mov	r30, r25
   14992:	f0 e0       	ldi	r31, 0x00	; 0
   14994:	ea 5c       	subi	r30, 0xCA	; 202
   14996:	fa 4f       	sbci	r31, 0xFA	; 250
   14998:	80 91 76 03 	lds	r24, 0x0376
   1499c:	80 83       	st	Z, r24
					 nLocalAccount++;
   1499e:	9f 5f       	subi	r25, 0xFF	; 255
   149a0:	90 93 a4 01 	sts	0x01A4, r25
					 IsViewFillingFIP=True;
   149a4:	10 93 ad 01 	sts	0x01AD, r17
					 stLocalAccount=laViewStatus;
   149a8:	86 e1       	ldi	r24, 0x16	; 22
   149aa:	0f c0       	rjmp	.+30     	; 0x149ca <FMenuLocalAccount+0x1272>
				     break;
                case MSG00_NO_FIP:
                     lcd_printf(2,1,PSTR("FIP Tidak Siap    "));
   149ac:	82 e0       	ldi	r24, 0x02	; 2
   149ae:	61 e0       	ldi	r22, 0x01	; 1
   149b0:	45 e8       	ldi	r20, 0x85	; 133
   149b2:	5d e1       	ldi	r21, 0x1D	; 29
   149b4:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   149b8:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   149ba:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   149bc:	82 e0       	ldi	r24, 0x02	; 2
   149be:	90 e0       	ldi	r25, 0x00	; 0
   149c0:	90 93 d7 01 	sts	0x01D7, r25
   149c4:	80 93 d6 01 	sts	0x01D6, r24
					 stLocalAccount=laViewStatus;
				     break;
                case MSG00_NO_FIP:
                     lcd_printf(2,1,PSTR("FIP Tidak Siap    "));
					 system_beep(2);
					 stLocalAccount=laDelayExit;
   149c8:	8e e1       	ldi	r24, 0x1E	; 30
   149ca:	80 93 5c 01 	sts	0x015C, r24
				     break;
				}
				TimLocAcc=0;
   149ce:	10 92 d3 01 	sts	0x01D3, r1
   149d2:	10 92 d2 01 	sts	0x01D2, r1
				ClearMem(strOdometer);
   149d6:	83 ea       	ldi	r24, 0xA3	; 163
   149d8:	95 e0       	ldi	r25, 0x05	; 5
   149da:	0e 94 a6 ad 	call	0x15b4c	; 0x15b4c <ClearMem>
	            ClearMem(strLicPlate);
   149de:	82 ed       	ldi	r24, 0xD2	; 210
   149e0:	9a e0       	ldi	r25, 0x0A	; 10
   149e2:	0e 94 a6 ad 	call	0x15b4c	; 0x15b4c <ClearMem>
   149e6:	e4 c0       	rjmp	.+456    	; 0x14bb0 <FMenuLocalAccount+0x1458>
		        break;
           case laViewStatus:
                if (TimLocAcc>20)stLocalAccount=laExitLocAcc;//laDisplayTransaction;
   149e8:	80 91 d2 01 	lds	r24, 0x01D2
   149ec:	90 91 d3 01 	lds	r25, 0x01D3
   149f0:	45 97       	sbiw	r24, 0x15	; 21
   149f2:	08 f4       	brcc	.+2      	; 0x149f6 <FMenuLocalAccount+0x129e>
   149f4:	dd c0       	rjmp	.+442    	; 0x14bb0 <FMenuLocalAccount+0x1458>
   149f6:	d3 c0       	rjmp	.+422    	; 0x14b9e <FMenuLocalAccount+0x1446>
		        break; 
           case laDisplayTransaction:
		        lcd_clear();
   149f8:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
                sprintf_P(lcdteks,PSTR("P%s %s "),strFIP,strProduct); lcd_print(1,1,lcdteks);    //"P01  Pertamax 500000"
   149fc:	2d b7       	in	r18, 0x3d	; 61
   149fe:	3e b7       	in	r19, 0x3e	; 62
   14a00:	28 50       	subi	r18, 0x08	; 8
   14a02:	30 40       	sbci	r19, 0x00	; 0
   14a04:	0f b6       	in	r0, 0x3f	; 63
   14a06:	f8 94       	cli
   14a08:	3e bf       	out	0x3e, r19	; 62
   14a0a:	0f be       	out	0x3f, r0	; 63
   14a0c:	2d bf       	out	0x3d, r18	; 61
   14a0e:	ed b7       	in	r30, 0x3d	; 61
   14a10:	fe b7       	in	r31, 0x3e	; 62
   14a12:	31 96       	adiw	r30, 0x01	; 1
   14a14:	7e 01       	movw	r14, r28
   14a16:	08 94       	sec
   14a18:	e1 1c       	adc	r14, r1
   14a1a:	f1 1c       	adc	r15, r1
   14a1c:	ad b7       	in	r26, 0x3d	; 61
   14a1e:	be b7       	in	r27, 0x3e	; 62
   14a20:	12 96       	adiw	r26, 0x02	; 2
   14a22:	fc 92       	st	X, r15
   14a24:	ee 92       	st	-X, r14
   14a26:	11 97       	sbiw	r26, 0x01	; 1
   14a28:	8d e7       	ldi	r24, 0x7D	; 125
   14a2a:	9d e1       	ldi	r25, 0x1D	; 29
   14a2c:	93 83       	std	Z+3, r25	; 0x03
   14a2e:	82 83       	std	Z+2, r24	; 0x02
   14a30:	8d e9       	ldi	r24, 0x9D	; 157
   14a32:	93 e0       	ldi	r25, 0x03	; 3
   14a34:	95 83       	std	Z+5, r25	; 0x05
   14a36:	84 83       	std	Z+4, r24	; 0x04
   14a38:	81 e4       	ldi	r24, 0x41	; 65
   14a3a:	99 e0       	ldi	r25, 0x09	; 9
   14a3c:	97 83       	std	Z+7, r25	; 0x07
   14a3e:	86 83       	std	Z+6, r24	; 0x06
   14a40:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
   14a44:	ed b7       	in	r30, 0x3d	; 61
   14a46:	fe b7       	in	r31, 0x3e	; 62
   14a48:	38 96       	adiw	r30, 0x08	; 8
   14a4a:	0f b6       	in	r0, 0x3f	; 63
   14a4c:	f8 94       	cli
   14a4e:	fe bf       	out	0x3e, r31	; 62
   14a50:	0f be       	out	0x3f, r0	; 63
   14a52:	ed bf       	out	0x3d, r30	; 61
   14a54:	81 e0       	ldi	r24, 0x01	; 1
   14a56:	61 e0       	ldi	r22, 0x01	; 1
   14a58:	a7 01       	movw	r20, r14
   14a5a:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
		        sprintf_P(lcdteks,PSTR("%s"),strBalanceValue);        lcd_print(1,15,lcdteks);   //"ID1CCDA565          " 
   14a5e:	00 d0       	rcall	.+0      	; 0x14a60 <FMenuLocalAccount+0x1308>
   14a60:	00 d0       	rcall	.+0      	; 0x14a62 <FMenuLocalAccount+0x130a>
   14a62:	00 d0       	rcall	.+0      	; 0x14a64 <FMenuLocalAccount+0x130c>
   14a64:	ed b7       	in	r30, 0x3d	; 61
   14a66:	fe b7       	in	r31, 0x3e	; 62
   14a68:	31 96       	adiw	r30, 0x01	; 1
   14a6a:	ad b7       	in	r26, 0x3d	; 61
   14a6c:	be b7       	in	r27, 0x3e	; 62
   14a6e:	12 96       	adiw	r26, 0x02	; 2
   14a70:	fc 92       	st	X, r15
   14a72:	ee 92       	st	-X, r14
   14a74:	11 97       	sbiw	r26, 0x01	; 1
   14a76:	8a e7       	ldi	r24, 0x7A	; 122
   14a78:	9d e1       	ldi	r25, 0x1D	; 29
   14a7a:	93 83       	std	Z+3, r25	; 0x03
   14a7c:	82 83       	std	Z+2, r24	; 0x02
   14a7e:	8a ef       	ldi	r24, 0xFA	; 250
   14a80:	9d e0       	ldi	r25, 0x0D	; 13
   14a82:	95 83       	std	Z+5, r25	; 0x05
   14a84:	84 83       	std	Z+4, r24	; 0x04
   14a86:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
   14a8a:	ed b7       	in	r30, 0x3d	; 61
   14a8c:	fe b7       	in	r31, 0x3e	; 62
   14a8e:	36 96       	adiw	r30, 0x06	; 6
   14a90:	0f b6       	in	r0, 0x3f	; 63
   14a92:	f8 94       	cli
   14a94:	fe bf       	out	0x3e, r31	; 62
   14a96:	0f be       	out	0x3f, r0	; 63
   14a98:	ed bf       	out	0x3d, r30	; 61
   14a9a:	81 e0       	ldi	r24, 0x01	; 1
   14a9c:	6f e0       	ldi	r22, 0x0F	; 15
   14a9e:	a7 01       	movw	r20, r14
   14aa0:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
                RemSpaceLead(strCardID);
   14aa4:	01 e6       	ldi	r16, 0x61	; 97
   14aa6:	1d e0       	ldi	r17, 0x0D	; 13
   14aa8:	c8 01       	movw	r24, r16
   14aaa:	0e 94 25 24 	call	0x484a	; 0x484a <RemSpaceLead>
				sprintf_P(lcdteks,PSTR("ID: %s"),strCardID);          lcd_print(2,1,lcdteks);
   14aae:	00 d0       	rcall	.+0      	; 0x14ab0 <FMenuLocalAccount+0x1358>
   14ab0:	00 d0       	rcall	.+0      	; 0x14ab2 <FMenuLocalAccount+0x135a>
   14ab2:	00 d0       	rcall	.+0      	; 0x14ab4 <FMenuLocalAccount+0x135c>
   14ab4:	ed b7       	in	r30, 0x3d	; 61
   14ab6:	fe b7       	in	r31, 0x3e	; 62
   14ab8:	31 96       	adiw	r30, 0x01	; 1
   14aba:	ad b7       	in	r26, 0x3d	; 61
   14abc:	be b7       	in	r27, 0x3e	; 62
   14abe:	12 96       	adiw	r26, 0x02	; 2
   14ac0:	fc 92       	st	X, r15
   14ac2:	ee 92       	st	-X, r14
   14ac4:	11 97       	sbiw	r26, 0x01	; 1
   14ac6:	83 e7       	ldi	r24, 0x73	; 115
   14ac8:	9d e1       	ldi	r25, 0x1D	; 29
   14aca:	93 83       	std	Z+3, r25	; 0x03
   14acc:	82 83       	std	Z+2, r24	; 0x02
   14ace:	15 83       	std	Z+5, r17	; 0x05
   14ad0:	04 83       	std	Z+4, r16	; 0x04
   14ad2:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
   14ad6:	ed b7       	in	r30, 0x3d	; 61
   14ad8:	fe b7       	in	r31, 0x3e	; 62
   14ada:	36 96       	adiw	r30, 0x06	; 6
   14adc:	0f b6       	in	r0, 0x3f	; 63
   14ade:	f8 94       	cli
   14ae0:	fe bf       	out	0x3e, r31	; 62
   14ae2:	0f be       	out	0x3f, r0	; 63
   14ae4:	ed bf       	out	0x3d, r30	; 61
   14ae6:	82 e0       	ldi	r24, 0x02	; 2
   14ae8:	61 e0       	ldi	r22, 0x01	; 1
   14aea:	a7 01       	movw	r20, r14
   14aec:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>
				TimLocAcc=0;
   14af0:	10 92 d3 01 	sts	0x01D3, r1
   14af4:	10 92 d2 01 	sts	0x01D2, r1
		        IsCompleteFilling=False;
   14af8:	10 92 c0 01 	sts	0x01C0, r1
				stLocalAccount=laWaitFilling;
   14afc:	8d e1       	ldi	r24, 0x1D	; 29
   14afe:	85 cd       	rjmp	.-1270   	; 0x1460a <FMenuLocalAccount+0xeb2>
		        break; 
           case laWaitFilling:
				if ((IsCompleteFilling==True)||(TimLocAcc>FILLING_TIMOUT)){
   14b00:	80 91 c0 01 	lds	r24, 0x01C0
   14b04:	81 30       	cpi	r24, 0x01	; 1
   14b06:	39 f0       	breq	.+14     	; 0x14b16 <FMenuLocalAccount+0x13be>
   14b08:	80 91 d2 01 	lds	r24, 0x01D2
   14b0c:	90 91 d3 01 	lds	r25, 0x01D3
   14b10:	0b 97       	sbiw	r24, 0x0b	; 11
   14b12:	08 f4       	brcc	.+2      	; 0x14b16 <FMenuLocalAccount+0x13be>
   14b14:	4d c0       	rjmp	.+154    	; 0x14bb0 <FMenuLocalAccount+0x1458>
				    IsCompleteFilling=False;
   14b16:	10 92 c0 01 	sts	0x01C0, r1
				    stLocalAccount=laSuccessTransaction;
   14b1a:	89 e1       	ldi	r24, 0x19	; 25
   14b1c:	80 93 5c 01 	sts	0x015C, r24
					TimLocAcc=0;
   14b20:	10 92 d3 01 	sts	0x01D3, r1
   14b24:	10 92 d2 01 	sts	0x01D2, r1
   14b28:	43 c0       	rjmp	.+134    	; 0x14bb0 <FMenuLocalAccount+0x1458>
					}
		        break;
           case laSuccessTransaction:
				lcd_clear();lcd_printf(2,1,PSTR("Transaksi Selesai"));
   14b2a:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
   14b2e:	82 e0       	ldi	r24, 0x02	; 2
   14b30:	61 e0       	ldi	r22, 0x01	; 1
   14b32:	41 e6       	ldi	r20, 0x61	; 97
   14b34:	5d e1       	ldi	r21, 0x1D	; 29
   14b36:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
				//Show Status FIP
				sprintf_P(lcdteks,PSTR("Fueling @FIP:#%d"),FIP_Used);
   14b3a:	00 d0       	rcall	.+0      	; 0x14b3c <FMenuLocalAccount+0x13e4>
   14b3c:	00 d0       	rcall	.+0      	; 0x14b3e <FMenuLocalAccount+0x13e6>
   14b3e:	00 d0       	rcall	.+0      	; 0x14b40 <FMenuLocalAccount+0x13e8>
   14b40:	ed b7       	in	r30, 0x3d	; 61
   14b42:	fe b7       	in	r31, 0x3e	; 62
   14b44:	31 96       	adiw	r30, 0x01	; 1
   14b46:	8e 01       	movw	r16, r28
   14b48:	0f 5f       	subi	r16, 0xFF	; 255
   14b4a:	1f 4f       	sbci	r17, 0xFF	; 255
   14b4c:	ad b7       	in	r26, 0x3d	; 61
   14b4e:	be b7       	in	r27, 0x3e	; 62
   14b50:	12 96       	adiw	r26, 0x02	; 2
   14b52:	1c 93       	st	X, r17
   14b54:	0e 93       	st	-X, r16
   14b56:	11 97       	sbiw	r26, 0x01	; 1
   14b58:	80 e5       	ldi	r24, 0x50	; 80
   14b5a:	9d e1       	ldi	r25, 0x1D	; 29
   14b5c:	93 83       	std	Z+3, r25	; 0x03
   14b5e:	82 83       	std	Z+2, r24	; 0x02
   14b60:	80 91 76 03 	lds	r24, 0x0376
   14b64:	84 83       	std	Z+4, r24	; 0x04
   14b66:	15 82       	std	Z+5, r1	; 0x05
   14b68:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
				lcd_print(3,1,lcdteks);
   14b6c:	ed b7       	in	r30, 0x3d	; 61
   14b6e:	fe b7       	in	r31, 0x3e	; 62
   14b70:	36 96       	adiw	r30, 0x06	; 6
   14b72:	0f b6       	in	r0, 0x3f	; 63
   14b74:	f8 94       	cli
   14b76:	fe bf       	out	0x3e, r31	; 62
   14b78:	0f be       	out	0x3f, r0	; 63
   14b7a:	ed bf       	out	0x3d, r30	; 61
   14b7c:	83 e0       	ldi	r24, 0x03	; 3
   14b7e:	61 e0       	ldi	r22, 0x01	; 1
   14b80:	a8 01       	movw	r20, r16
   14b82:	0e 94 0d ad 	call	0x15a1a	; 0x15a1a <lcd_print>

				TimLocAcc=0;
				stLocalAccount=laDelayExit;
		        break;
           case laFailedTransaction:
		        TimLocAcc=0;
   14b86:	10 92 d3 01 	sts	0x01D3, r1
   14b8a:	10 92 d2 01 	sts	0x01D2, r1
		        //Show Failed Report
				stLocalAccount=laDelayExit;
   14b8e:	8e e1       	ldi	r24, 0x1E	; 30
   14b90:	3c cd       	rjmp	.-1416   	; 0x1460a <FMenuLocalAccount+0xeb2>
		        break;
           case laDelayExit:
		        if (TimLocAcc>15)stLocalAccount=laExitLocAcc;
   14b92:	80 91 d2 01 	lds	r24, 0x01D2
   14b96:	90 91 d3 01 	lds	r25, 0x01D3
   14b9a:	40 97       	sbiw	r24, 0x10	; 16
   14b9c:	48 f0       	brcs	.+18     	; 0x14bb0 <FMenuLocalAccount+0x1458>
   14b9e:	8f e1       	ldi	r24, 0x1F	; 31
   14ba0:	34 cd       	rjmp	.-1432   	; 0x1460a <FMenuLocalAccount+0xeb2>
		        break;
           case laExitLocAcc:
		        Result=MENU_DONE;
				stLocalAccount=laInit;
   14ba2:	81 e0       	ldi	r24, 0x01	; 1
   14ba4:	80 93 5c 01 	sts	0x015C, r24
				lcd_clear();
   14ba8:	0e 94 66 ad 	call	0x15acc	; 0x15acc <lcd_clear>
   14bac:	81 e0       	ldi	r24, 0x01	; 1
   14bae:	01 c0       	rjmp	.+2      	; 0x14bb2 <FMenuLocalAccount+0x145a>
   14bb0:	80 e0       	ldi	r24, 0x00	; 0
		        break;
	       }//EndSwitch
return Result;
}
   14bb2:	a9 96       	adiw	r28, 0x29	; 41
   14bb4:	0f b6       	in	r0, 0x3f	; 63
   14bb6:	f8 94       	cli
   14bb8:	de bf       	out	0x3e, r29	; 62
   14bba:	0f be       	out	0x3f, r0	; 63
   14bbc:	cd bf       	out	0x3d, r28	; 61
   14bbe:	cf 91       	pop	r28
   14bc0:	df 91       	pop	r29
   14bc2:	1f 91       	pop	r17
   14bc4:	0f 91       	pop	r16
   14bc6:	ff 90       	pop	r15
   14bc8:	ef 90       	pop	r14
   14bca:	df 90       	pop	r13
   14bcc:	cf 90       	pop	r12
   14bce:	bf 90       	pop	r11
   14bd0:	af 90       	pop	r10
   14bd2:	08 95       	ret

00014bd4 <SendConfigParamater>:
          stConfigProtocol=cpWaitSend;
	      break;
	 }
}

void SendConfigParamater(){
   14bd4:	8f 92       	push	r8
   14bd6:	9f 92       	push	r9
   14bd8:	af 92       	push	r10
   14bda:	bf 92       	push	r11
   14bdc:	cf 92       	push	r12
   14bde:	df 92       	push	r13
   14be0:	ef 92       	push	r14
   14be2:	ff 92       	push	r15
   14be4:	0f 93       	push	r16
   14be6:	1f 93       	push	r17
   14be8:	df 93       	push	r29
   14bea:	cf 93       	push	r28
   14bec:	cd b7       	in	r28, 0x3d	; 61
   14bee:	de b7       	in	r29, 0x3e	; 62
   14bf0:	c5 56       	subi	r28, 0x65	; 101
   14bf2:	d0 40       	sbci	r29, 0x00	; 0
   14bf4:	0f b6       	in	r0, 0x3f	; 63
   14bf6:	f8 94       	cli
   14bf8:	de bf       	out	0x3e, r29	; 62
   14bfa:	0f be       	out	0x3f, r0	; 63
   14bfc:	cd bf       	out	0x3d, r28	; 61
char i,j,strSend[60];
char strEEPROM[41],xEEPROM;

     //Start
	 _uart_printf(1,0,PSTR("<"));
   14bfe:	81 e0       	ldi	r24, 0x01	; 1
   14c00:	60 e0       	ldi	r22, 0x00	; 0
   14c02:	41 e7       	ldi	r20, 0x71	; 113
   14c04:	52 e2       	ldi	r21, 0x22	; 34
   14c06:	0e 94 bf b2 	call	0x1657e	; 0x1657e <_uart_printf>
   14c0a:	07 e2       	ldi	r16, 0x27	; 39
   14c0c:	12 e0       	ldi	r17, 0x02	; 2
   14c0e:	6e 01       	movw	r12, r28
   14c10:	08 94       	sec
   14c12:	c1 1c       	adc	r12, r1
   14c14:	d1 1c       	adc	r13, r1
     //Header Footer 400
	 for (i=0;i<10;i++){
	      eeprom_read_block((void*) &strEEPROM, (const void*) &DefHeaderFooter[i],sizeof(DefHeaderFooter[i]));
		  FillChar(strSend,0,sizeof(strSend));
	      sprintf_P(strSend,PSTR("%s"),strEEPROM);
   14c16:	7a e2       	ldi	r23, 0x2A	; 42
   14c18:	e7 2e       	mov	r14, r23
   14c1a:	f1 2c       	mov	r15, r1
   14c1c:	ec 0e       	add	r14, r28
   14c1e:	fd 1e       	adc	r15, r29
   14c20:	6e e6       	ldi	r22, 0x6E	; 110
   14c22:	a6 2e       	mov	r10, r22
   14c24:	62 e2       	ldi	r22, 0x22	; 34
   14c26:	b6 2e       	mov	r11, r22
   14c28:	c6 01       	movw	r24, r12
   14c2a:	b8 01       	movw	r22, r16
   14c2c:	49 e2       	ldi	r20, 0x29	; 41
   14c2e:	50 e0       	ldi	r21, 0x00	; 0
   14c30:	23 ef       	ldi	r18, 0xF3	; 243
   14c32:	32 e1       	ldi	r19, 0x12	; 18
   14c34:	0e 94 1f b4 	call	0x1683e	; 0x1683e <__eerd_block>
   14c38:	00 d0       	rcall	.+0      	; 0x14c3a <SendConfigParamater+0x66>
   14c3a:	00 d0       	rcall	.+0      	; 0x14c3c <SendConfigParamater+0x68>
   14c3c:	00 d0       	rcall	.+0      	; 0x14c3e <SendConfigParamater+0x6a>
   14c3e:	ed b7       	in	r30, 0x3d	; 61
   14c40:	fe b7       	in	r31, 0x3e	; 62
   14c42:	31 96       	adiw	r30, 0x01	; 1
   14c44:	ad b7       	in	r26, 0x3d	; 61
   14c46:	be b7       	in	r27, 0x3e	; 62
   14c48:	12 96       	adiw	r26, 0x02	; 2
   14c4a:	fc 92       	st	X, r15
   14c4c:	ee 92       	st	-X, r14
   14c4e:	11 97       	sbiw	r26, 0x01	; 1
   14c50:	b3 82       	std	Z+3, r11	; 0x03
   14c52:	a2 82       	std	Z+2, r10	; 0x02
   14c54:	d5 82       	std	Z+5, r13	; 0x05
   14c56:	c4 82       	std	Z+4, r12	; 0x04
   14c58:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
		  AddSpaceLag(strSend,40);
   14c5c:	ed b7       	in	r30, 0x3d	; 61
   14c5e:	fe b7       	in	r31, 0x3e	; 62
   14c60:	36 96       	adiw	r30, 0x06	; 6
   14c62:	0f b6       	in	r0, 0x3f	; 63
   14c64:	f8 94       	cli
   14c66:	fe bf       	out	0x3e, r31	; 62
   14c68:	0f be       	out	0x3f, r0	; 63
   14c6a:	ed bf       	out	0x3d, r30	; 61
   14c6c:	c7 01       	movw	r24, r14
   14c6e:	68 e2       	ldi	r22, 0x28	; 40
   14c70:	0e 94 d8 2a 	call	0x55b0	; 0x55b0 <AddSpaceLag>
		  _uart_print(1,0,strSend);
   14c74:	81 e0       	ldi	r24, 0x01	; 1
   14c76:	60 e0       	ldi	r22, 0x00	; 0
   14c78:	a7 01       	movw	r20, r14
   14c7a:	0e 94 97 b2 	call	0x1652e	; 0x1652e <_uart_print>
   14c7e:	07 5d       	subi	r16, 0xD7	; 215
   14c80:	1f 4f       	sbci	r17, 0xFF	; 255
char strEEPROM[41],xEEPROM;

     //Start
	 _uart_printf(1,0,PSTR("<"));
     //Header Footer 400
	 for (i=0;i<10;i++){
   14c82:	f3 e0       	ldi	r31, 0x03	; 3
   14c84:	01 3c       	cpi	r16, 0xC1	; 193
   14c86:	1f 07       	cpc	r17, r31
   14c88:	79 f6       	brne	.-98     	; 0x14c28 <SendConfigParamater+0x54>
   14c8a:	0b eb       	ldi	r16, 0xBB	; 187
   14c8c:	10 e0       	ldi	r17, 0x00	; 0
   14c8e:	6e 01       	movw	r12, r28
   14c90:	08 94       	sec
   14c92:	c1 1c       	adc	r12, r1
   14c94:	d1 1c       	adc	r13, r1
	 }
	 //ProductName 72 
	 for (i=0;i<6;i++){
		 eeprom_read_block((void*) &strEEPROM, (const void*) &DefProductName[i],sizeof(DefProductName[i]));
		 FillChar(strSend,0,sizeof(strSend));
	     sprintf_P(strSend,PSTR("%s"),strEEPROM);
   14c96:	5a e2       	ldi	r21, 0x2A	; 42
   14c98:	e5 2e       	mov	r14, r21
   14c9a:	f1 2c       	mov	r15, r1
   14c9c:	ec 0e       	add	r14, r28
   14c9e:	fd 1e       	adc	r15, r29
   14ca0:	4b e6       	ldi	r20, 0x6B	; 107
   14ca2:	a4 2e       	mov	r10, r20
   14ca4:	42 e2       	ldi	r20, 0x22	; 34
   14ca6:	b4 2e       	mov	r11, r20
   14ca8:	c6 01       	movw	r24, r12
   14caa:	b8 01       	movw	r22, r16
   14cac:	4d e0       	ldi	r20, 0x0D	; 13
   14cae:	50 e0       	ldi	r21, 0x00	; 0
   14cb0:	23 ef       	ldi	r18, 0xF3	; 243
   14cb2:	32 e1       	ldi	r19, 0x12	; 18
   14cb4:	0e 94 1f b4 	call	0x1683e	; 0x1683e <__eerd_block>
   14cb8:	00 d0       	rcall	.+0      	; 0x14cba <SendConfigParamater+0xe6>
   14cba:	00 d0       	rcall	.+0      	; 0x14cbc <SendConfigParamater+0xe8>
   14cbc:	00 d0       	rcall	.+0      	; 0x14cbe <SendConfigParamater+0xea>
   14cbe:	ed b7       	in	r30, 0x3d	; 61
   14cc0:	fe b7       	in	r31, 0x3e	; 62
   14cc2:	31 96       	adiw	r30, 0x01	; 1
   14cc4:	ad b7       	in	r26, 0x3d	; 61
   14cc6:	be b7       	in	r27, 0x3e	; 62
   14cc8:	12 96       	adiw	r26, 0x02	; 2
   14cca:	fc 92       	st	X, r15
   14ccc:	ee 92       	st	-X, r14
   14cce:	11 97       	sbiw	r26, 0x01	; 1
   14cd0:	b3 82       	std	Z+3, r11	; 0x03
   14cd2:	a2 82       	std	Z+2, r10	; 0x02
   14cd4:	d5 82       	std	Z+5, r13	; 0x05
   14cd6:	c4 82       	std	Z+4, r12	; 0x04
   14cd8:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
		 AddSpaceLag(strSend,12);
   14cdc:	ed b7       	in	r30, 0x3d	; 61
   14cde:	fe b7       	in	r31, 0x3e	; 62
   14ce0:	36 96       	adiw	r30, 0x06	; 6
   14ce2:	0f b6       	in	r0, 0x3f	; 63
   14ce4:	f8 94       	cli
   14ce6:	fe bf       	out	0x3e, r31	; 62
   14ce8:	0f be       	out	0x3f, r0	; 63
   14cea:	ed bf       	out	0x3d, r30	; 61
   14cec:	c7 01       	movw	r24, r14
   14cee:	6c e0       	ldi	r22, 0x0C	; 12
   14cf0:	0e 94 d8 2a 	call	0x55b0	; 0x55b0 <AddSpaceLag>
		 _uart_print(1,0,strSend);
   14cf4:	81 e0       	ldi	r24, 0x01	; 1
   14cf6:	60 e0       	ldi	r22, 0x00	; 0
   14cf8:	a7 01       	movw	r20, r14
   14cfa:	0e 94 97 b2 	call	0x1652e	; 0x1652e <_uart_print>
   14cfe:	03 5f       	subi	r16, 0xF3	; 243
   14d00:	1f 4f       	sbci	r17, 0xFF	; 255
	      sprintf_P(strSend,PSTR("%s"),strEEPROM);
		  AddSpaceLag(strSend,40);
		  _uart_print(1,0,strSend);
	 }
	 //ProductName 72 
	 for (i=0;i<6;i++){
   14d02:	f1 e0       	ldi	r31, 0x01	; 1
   14d04:	09 30       	cpi	r16, 0x09	; 9
   14d06:	1f 07       	cpc	r17, r31
   14d08:	79 f6       	brne	.-98     	; 0x14ca8 <SendConfigParamater+0xd4>
   14d0a:	05 e8       	ldi	r16, 0x85	; 133
   14d0c:	10 e0       	ldi	r17, 0x00	; 0
   14d0e:	6e 01       	movw	r12, r28
   14d10:	08 94       	sec
   14d12:	c1 1c       	adc	r12, r1
   14d14:	d1 1c       	adc	r13, r1
	 }
	 //ProductPrice 30
	 for (i=0;i<6;i++){
		 eeprom_read_block((void*) &strEEPROM, (const void*) &DefProductPrice[i],sizeof(DefProductPrice[i]));
		 FillChar(strSend,0,sizeof(strSend));
	     sprintf_P(strSend,PSTR("%s"),strEEPROM);
   14d16:	3a e2       	ldi	r19, 0x2A	; 42
   14d18:	e3 2e       	mov	r14, r19
   14d1a:	f1 2c       	mov	r15, r1
   14d1c:	ec 0e       	add	r14, r28
   14d1e:	fd 1e       	adc	r15, r29
   14d20:	28 e6       	ldi	r18, 0x68	; 104
   14d22:	a2 2e       	mov	r10, r18
   14d24:	22 e2       	ldi	r18, 0x22	; 34
   14d26:	b2 2e       	mov	r11, r18
   14d28:	c6 01       	movw	r24, r12
   14d2a:	b8 01       	movw	r22, r16
   14d2c:	49 e0       	ldi	r20, 0x09	; 9
   14d2e:	50 e0       	ldi	r21, 0x00	; 0
   14d30:	23 ef       	ldi	r18, 0xF3	; 243
   14d32:	32 e1       	ldi	r19, 0x12	; 18
   14d34:	0e 94 1f b4 	call	0x1683e	; 0x1683e <__eerd_block>
   14d38:	00 d0       	rcall	.+0      	; 0x14d3a <SendConfigParamater+0x166>
   14d3a:	00 d0       	rcall	.+0      	; 0x14d3c <SendConfigParamater+0x168>
   14d3c:	00 d0       	rcall	.+0      	; 0x14d3e <SendConfigParamater+0x16a>
   14d3e:	ed b7       	in	r30, 0x3d	; 61
   14d40:	fe b7       	in	r31, 0x3e	; 62
   14d42:	31 96       	adiw	r30, 0x01	; 1
   14d44:	ad b7       	in	r26, 0x3d	; 61
   14d46:	be b7       	in	r27, 0x3e	; 62
   14d48:	12 96       	adiw	r26, 0x02	; 2
   14d4a:	fc 92       	st	X, r15
   14d4c:	ee 92       	st	-X, r14
   14d4e:	11 97       	sbiw	r26, 0x01	; 1
   14d50:	b3 82       	std	Z+3, r11	; 0x03
   14d52:	a2 82       	std	Z+2, r10	; 0x02
   14d54:	d5 82       	std	Z+5, r13	; 0x05
   14d56:	c4 82       	std	Z+4, r12	; 0x04
   14d58:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
		 AddSpaceLag(strSend,5);
   14d5c:	ed b7       	in	r30, 0x3d	; 61
   14d5e:	fe b7       	in	r31, 0x3e	; 62
   14d60:	36 96       	adiw	r30, 0x06	; 6
   14d62:	0f b6       	in	r0, 0x3f	; 63
   14d64:	f8 94       	cli
   14d66:	fe bf       	out	0x3e, r31	; 62
   14d68:	0f be       	out	0x3f, r0	; 63
   14d6a:	ed bf       	out	0x3d, r30	; 61
   14d6c:	c7 01       	movw	r24, r14
   14d6e:	65 e0       	ldi	r22, 0x05	; 5
   14d70:	0e 94 d8 2a 	call	0x55b0	; 0x55b0 <AddSpaceLag>
		 _uart_print(1,0,strSend);
   14d74:	81 e0       	ldi	r24, 0x01	; 1
   14d76:	60 e0       	ldi	r22, 0x00	; 0
   14d78:	a7 01       	movw	r20, r14
   14d7a:	0e 94 97 b2 	call	0x1652e	; 0x1652e <_uart_print>
   14d7e:	07 5f       	subi	r16, 0xF7	; 247
   14d80:	1f 4f       	sbci	r17, 0xFF	; 255
	     sprintf_P(strSend,PSTR("%s"),strEEPROM);
		 AddSpaceLag(strSend,12);
		 _uart_print(1,0,strSend);
	 }
	 //ProductPrice 30
	 for (i=0;i<6;i++){
   14d82:	f0 e0       	ldi	r31, 0x00	; 0
   14d84:	0b 3b       	cpi	r16, 0xBB	; 187
   14d86:	1f 07       	cpc	r17, r31
   14d88:	79 f6       	brne	.-98     	; 0x14d28 <SendConfigParamater+0x154>
   14d8a:	05 e4       	ldi	r16, 0x45	; 69
   14d8c:	10 e0       	ldi	r17, 0x00	; 0
	 //PumpID Config 8
	 for (i=0;i<8;i++){
	      xEEPROM=eeprom_read_byte(&DefPumpMap[i]);
		  if (xEEPROM>=100)xEEPROM=0;
		  FillChar(strSend,0,sizeof(strSend));
	      sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
   14d8e:	9a e2       	ldi	r25, 0x2A	; 42
   14d90:	e9 2e       	mov	r14, r25
   14d92:	f1 2c       	mov	r15, r1
   14d94:	ec 0e       	add	r14, r28
   14d96:	fd 1e       	adc	r15, r29
   14d98:	83 e6       	ldi	r24, 0x63	; 99
   14d9a:	c8 2e       	mov	r12, r24
   14d9c:	82 e2       	ldi	r24, 0x22	; 34
   14d9e:	d8 2e       	mov	r13, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   14da0:	e1 99       	sbic	0x1c, 1	; 28
   14da2:	fe cf       	rjmp	.-4      	; 0x14da0 <SendConfigParamater+0x1cc>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   14da4:	1f bb       	out	0x1f, r17	; 31
   14da6:	0e bb       	out	0x1e, r16	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   14da8:	e0 9a       	sbi	0x1c, 0	; 28
   14daa:	8d b3       	in	r24, 0x1d	; 29
		 _uart_print(1,0,strSend);
	 }
	 //PumpID Config 8
	 for (i=0;i<8;i++){
	      xEEPROM=eeprom_read_byte(&DefPumpMap[i]);
		  if (xEEPROM>=100)xEEPROM=0;
   14dac:	84 36       	cpi	r24, 0x64	; 100
   14dae:	08 f0       	brcs	.+2      	; 0x14db2 <SendConfigParamater+0x1de>
   14db0:	80 e0       	ldi	r24, 0x00	; 0
		  FillChar(strSend,0,sizeof(strSend));
	      sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
   14db2:	00 d0       	rcall	.+0      	; 0x14db4 <SendConfigParamater+0x1e0>
   14db4:	00 d0       	rcall	.+0      	; 0x14db6 <SendConfigParamater+0x1e2>
   14db6:	00 d0       	rcall	.+0      	; 0x14db8 <SendConfigParamater+0x1e4>
   14db8:	ed b7       	in	r30, 0x3d	; 61
   14dba:	fe b7       	in	r31, 0x3e	; 62
   14dbc:	31 96       	adiw	r30, 0x01	; 1
   14dbe:	ad b7       	in	r26, 0x3d	; 61
   14dc0:	be b7       	in	r27, 0x3e	; 62
   14dc2:	12 96       	adiw	r26, 0x02	; 2
   14dc4:	fc 92       	st	X, r15
   14dc6:	ee 92       	st	-X, r14
   14dc8:	11 97       	sbiw	r26, 0x01	; 1
   14dca:	d3 82       	std	Z+3, r13	; 0x03
   14dcc:	c2 82       	std	Z+2, r12	; 0x02
   14dce:	84 83       	std	Z+4, r24	; 0x04
   14dd0:	15 82       	std	Z+5, r1	; 0x05
   14dd2:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
		  AddSpaceLag(strSend,2);
   14dd6:	ed b7       	in	r30, 0x3d	; 61
   14dd8:	fe b7       	in	r31, 0x3e	; 62
   14dda:	36 96       	adiw	r30, 0x06	; 6
   14ddc:	0f b6       	in	r0, 0x3f	; 63
   14dde:	f8 94       	cli
   14de0:	fe bf       	out	0x3e, r31	; 62
   14de2:	0f be       	out	0x3f, r0	; 63
   14de4:	ed bf       	out	0x3d, r30	; 61
   14de6:	c7 01       	movw	r24, r14
   14de8:	62 e0       	ldi	r22, 0x02	; 2
   14dea:	0e 94 d8 2a 	call	0x55b0	; 0x55b0 <AddSpaceLag>
		 _uart_print(1,0,strSend);
   14dee:	81 e0       	ldi	r24, 0x01	; 1
   14df0:	60 e0       	ldi	r22, 0x00	; 0
   14df2:	a7 01       	movw	r20, r14
   14df4:	0e 94 97 b2 	call	0x1652e	; 0x1652e <_uart_print>
   14df8:	0f 5f       	subi	r16, 0xFF	; 255
   14dfa:	1f 4f       	sbci	r17, 0xFF	; 255
	     sprintf_P(strSend,PSTR("%s"),strEEPROM);
		 AddSpaceLag(strSend,5);
		 _uart_print(1,0,strSend);
	 }
	 //PumpID Config 8
	 for (i=0;i<8;i++){
   14dfc:	f0 e0       	ldi	r31, 0x00	; 0
   14dfe:	0d 34       	cpi	r16, 0x4D	; 77
   14e00:	1f 07       	cpc	r17, r31
   14e02:	71 f6       	brne	.-100    	; 0x14da0 <SendConfigParamater+0x1cc>
   14e04:	b5 e5       	ldi	r27, 0x55	; 85
   14e06:	eb 2e       	mov	r14, r27
   14e08:	b0 e0       	ldi	r27, 0x00	; 0
   14e0a:	fb 2e       	mov	r15, r27
	 //PumpID NozzleConfig 48
	 for (i=0;i<8;i++){
	      for (j=0;j<6;j++){
		       xEEPROM=eeprom_read_byte(&DefNozzleMap[i][j]);     
			   if (xEEPROM>=10)xEEPROM=0;
			   sprintf_P(strSend,PSTR("%d"),xEEPROM);
   14e0c:	aa e2       	ldi	r26, 0x2A	; 42
   14e0e:	aa 2e       	mov	r10, r26
   14e10:	b1 2c       	mov	r11, r1
   14e12:	ac 0e       	add	r10, r28
   14e14:	bd 1e       	adc	r11, r29
   14e16:	f0 e6       	ldi	r31, 0x60	; 96
   14e18:	8f 2e       	mov	r8, r31
   14e1a:	f2 e2       	ldi	r31, 0x22	; 34
   14e1c:	9f 2e       	mov	r9, r31
   14e1e:	37 c0       	rjmp	.+110    	; 0x14e8e <SendConfigParamater+0x2ba>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   14e20:	e1 99       	sbic	0x1c, 1	; 28
   14e22:	fe cf       	rjmp	.-4      	; 0x14e20 <SendConfigParamater+0x24c>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   14e24:	1f bb       	out	0x1f, r17	; 31
   14e26:	0e bb       	out	0x1e, r16	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   14e28:	e0 9a       	sbi	0x1c, 0	; 28
   14e2a:	8d b3       	in	r24, 0x1d	; 29
	 }
	 //PumpID NozzleConfig 48
	 for (i=0;i<8;i++){
	      for (j=0;j<6;j++){
		       xEEPROM=eeprom_read_byte(&DefNozzleMap[i][j]);     
			   if (xEEPROM>=10)xEEPROM=0;
   14e2c:	8a 30       	cpi	r24, 0x0A	; 10
   14e2e:	08 f0       	brcs	.+2      	; 0x14e32 <SendConfigParamater+0x25e>
   14e30:	80 e0       	ldi	r24, 0x00	; 0
			   sprintf_P(strSend,PSTR("%d"),xEEPROM);
   14e32:	00 d0       	rcall	.+0      	; 0x14e34 <SendConfigParamater+0x260>
   14e34:	00 d0       	rcall	.+0      	; 0x14e36 <SendConfigParamater+0x262>
   14e36:	00 d0       	rcall	.+0      	; 0x14e38 <SendConfigParamater+0x264>
   14e38:	ed b7       	in	r30, 0x3d	; 61
   14e3a:	fe b7       	in	r31, 0x3e	; 62
   14e3c:	31 96       	adiw	r30, 0x01	; 1
   14e3e:	ad b7       	in	r26, 0x3d	; 61
   14e40:	be b7       	in	r27, 0x3e	; 62
   14e42:	12 96       	adiw	r26, 0x02	; 2
   14e44:	bc 92       	st	X, r11
   14e46:	ae 92       	st	-X, r10
   14e48:	11 97       	sbiw	r26, 0x01	; 1
   14e4a:	93 82       	std	Z+3, r9	; 0x03
   14e4c:	82 82       	std	Z+2, r8	; 0x02
   14e4e:	84 83       	std	Z+4, r24	; 0x04
   14e50:	15 82       	std	Z+5, r1	; 0x05
   14e52:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
			   _uart_print(1,0,strSend);
   14e56:	ed b7       	in	r30, 0x3d	; 61
   14e58:	fe b7       	in	r31, 0x3e	; 62
   14e5a:	36 96       	adiw	r30, 0x06	; 6
   14e5c:	0f b6       	in	r0, 0x3f	; 63
   14e5e:	f8 94       	cli
   14e60:	fe bf       	out	0x3e, r31	; 62
   14e62:	0f be       	out	0x3f, r0	; 63
   14e64:	ed bf       	out	0x3d, r30	; 61
   14e66:	81 e0       	ldi	r24, 0x01	; 1
   14e68:	60 e0       	ldi	r22, 0x00	; 0
   14e6a:	a5 01       	movw	r20, r10
   14e6c:	0e 94 97 b2 	call	0x1652e	; 0x1652e <_uart_print>
		  AddSpaceLag(strSend,2);
		 _uart_print(1,0,strSend);
	 }
	 //PumpID NozzleConfig 48
	 for (i=0;i<8;i++){
	      for (j=0;j<6;j++){
   14e70:	d3 94       	inc	r13
   14e72:	0f 5f       	subi	r16, 0xFF	; 255
   14e74:	1f 4f       	sbci	r17, 0xFF	; 255
   14e76:	f6 e0       	ldi	r31, 0x06	; 6
   14e78:	df 16       	cp	r13, r31
   14e7a:	91 f6       	brne	.-92     	; 0x14e20 <SendConfigParamater+0x24c>
   14e7c:	86 e0       	ldi	r24, 0x06	; 6
   14e7e:	90 e0       	ldi	r25, 0x00	; 0
   14e80:	e8 0e       	add	r14, r24
   14e82:	f9 1e       	adc	r15, r25
	      sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
		  AddSpaceLag(strSend,2);
		 _uart_print(1,0,strSend);
	 }
	 //PumpID NozzleConfig 48
	 for (i=0;i<8;i++){
   14e84:	95 e8       	ldi	r25, 0x85	; 133
   14e86:	e9 16       	cp	r14, r25
   14e88:	90 e0       	ldi	r25, 0x00	; 0
   14e8a:	f9 06       	cpc	r15, r25
   14e8c:	19 f0       	breq	.+6      	; 0x14e94 <SendConfigParamater+0x2c0>
   14e8e:	87 01       	movw	r16, r14
   14e90:	dd 24       	eor	r13, r13
   14e92:	c6 cf       	rjmp	.-116    	; 0x14e20 <SendConfigParamater+0x24c>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   14e94:	e1 99       	sbic	0x1c, 1	; 28
   14e96:	fe cf       	rjmp	.-4      	; 0x14e94 <SendConfigParamater+0x2c0>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   14e98:	81 ec       	ldi	r24, 0xC1	; 193
   14e9a:	93 e0       	ldi	r25, 0x03	; 3
   14e9c:	9f bb       	out	0x1f, r25	; 31
   14e9e:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   14ea0:	e0 9a       	sbi	0x1c, 0	; 28
   14ea2:	8d b3       	in	r24, 0x1d	; 29
   14ea4:	9e 01       	movw	r18, r28
   14ea6:	26 5d       	subi	r18, 0xD6	; 214
   14ea8:	3f 4f       	sbci	r19, 0xFF	; 255
			   _uart_print(1,0,strSend);
		  }
	 }
	 //PrintNoMoney
	 xEEPROM=eeprom_read_byte(&DefPrintMoney);
	 if (xEEPROM==True){
   14eaa:	81 30       	cpi	r24, 0x01	; 1
   14eac:	79 f4       	brne	.+30     	; 0x14ecc <SendConfigParamater+0x2f8>
		 sprintf_P(strSend,PSTR("1"));
   14eae:	00 d0       	rcall	.+0      	; 0x14eb0 <SendConfigParamater+0x2dc>
   14eb0:	00 d0       	rcall	.+0      	; 0x14eb2 <SendConfigParamater+0x2de>
   14eb2:	ad b7       	in	r26, 0x3d	; 61
   14eb4:	be b7       	in	r27, 0x3e	; 62
   14eb6:	12 96       	adiw	r26, 0x02	; 2
   14eb8:	3c 93       	st	X, r19
   14eba:	2e 93       	st	-X, r18
   14ebc:	11 97       	sbiw	r26, 0x01	; 1
   14ebe:	8e e5       	ldi	r24, 0x5E	; 94
   14ec0:	92 e2       	ldi	r25, 0x22	; 34
   14ec2:	14 96       	adiw	r26, 0x04	; 4
   14ec4:	9c 93       	st	X, r25
   14ec6:	8e 93       	st	-X, r24
   14ec8:	13 97       	sbiw	r26, 0x03	; 3
   14eca:	0a c0       	rjmp	.+20     	; 0x14ee0 <SendConfigParamater+0x30c>
	 }else{
	     sprintf_P(strSend,PSTR("0"));
   14ecc:	00 d0       	rcall	.+0      	; 0x14ece <SendConfigParamater+0x2fa>
   14ece:	00 d0       	rcall	.+0      	; 0x14ed0 <SendConfigParamater+0x2fc>
   14ed0:	ed b7       	in	r30, 0x3d	; 61
   14ed2:	fe b7       	in	r31, 0x3e	; 62
   14ed4:	32 83       	std	Z+2, r19	; 0x02
   14ed6:	21 83       	std	Z+1, r18	; 0x01
   14ed8:	8c e5       	ldi	r24, 0x5C	; 92
   14eda:	92 e2       	ldi	r25, 0x22	; 34
   14edc:	94 83       	std	Z+4, r25	; 0x04
   14ede:	83 83       	std	Z+3, r24	; 0x03
   14ee0:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
   14ee4:	0f 90       	pop	r0
   14ee6:	0f 90       	pop	r0
   14ee8:	0f 90       	pop	r0
   14eea:	0f 90       	pop	r0
	 }_uart_print(1,0,strSend);
   14eec:	81 e0       	ldi	r24, 0x01	; 1
   14eee:	60 e0       	ldi	r22, 0x00	; 0
   14ef0:	ae 01       	movw	r20, r28
   14ef2:	46 5d       	subi	r20, 0xD6	; 214
   14ef4:	5f 4f       	sbci	r21, 0xFF	; 255
   14ef6:	0e 94 97 b2 	call	0x1652e	; 0x1652e <_uart_print>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   14efa:	e1 99       	sbic	0x1c, 1	; 28
   14efc:	fe cf       	rjmp	.-4      	; 0x14efa <SendConfigParamater+0x326>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   14efe:	80 e0       	ldi	r24, 0x00	; 0
   14f00:	90 e0       	ldi	r25, 0x00	; 0
   14f02:	9f bb       	out	0x1f, r25	; 31
   14f04:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   14f06:	e0 9a       	sbi	0x1c, 0	; 28
   14f08:	2d b3       	in	r18, 0x1d	; 29
	 //TermId
     xEEPROM=eeprom_read_byte(&DefIFT_ID);     
     sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
   14f0a:	00 d0       	rcall	.+0      	; 0x14f0c <SendConfigParamater+0x338>
   14f0c:	00 d0       	rcall	.+0      	; 0x14f0e <SendConfigParamater+0x33a>
   14f0e:	00 d0       	rcall	.+0      	; 0x14f10 <SendConfigParamater+0x33c>
   14f10:	ed b7       	in	r30, 0x3d	; 61
   14f12:	fe b7       	in	r31, 0x3e	; 62
   14f14:	31 96       	adiw	r30, 0x01	; 1
   14f16:	8e 01       	movw	r16, r28
   14f18:	06 5d       	subi	r16, 0xD6	; 214
   14f1a:	1f 4f       	sbci	r17, 0xFF	; 255
   14f1c:	ad b7       	in	r26, 0x3d	; 61
   14f1e:	be b7       	in	r27, 0x3e	; 62
   14f20:	12 96       	adiw	r26, 0x02	; 2
   14f22:	1c 93       	st	X, r17
   14f24:	0e 93       	st	-X, r16
   14f26:	11 97       	sbiw	r26, 0x01	; 1
   14f28:	87 e5       	ldi	r24, 0x57	; 87
   14f2a:	92 e2       	ldi	r25, 0x22	; 34
   14f2c:	93 83       	std	Z+3, r25	; 0x03
   14f2e:	82 83       	std	Z+2, r24	; 0x02
   14f30:	24 83       	std	Z+4, r18	; 0x04
   14f32:	15 82       	std	Z+5, r1	; 0x05
   14f34:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
     _uart_print(1,0,strSend);
   14f38:	ed b7       	in	r30, 0x3d	; 61
   14f3a:	fe b7       	in	r31, 0x3e	; 62
   14f3c:	36 96       	adiw	r30, 0x06	; 6
   14f3e:	0f b6       	in	r0, 0x3f	; 63
   14f40:	f8 94       	cli
   14f42:	fe bf       	out	0x3e, r31	; 62
   14f44:	0f be       	out	0x3f, r0	; 63
   14f46:	ed bf       	out	0x3d, r30	; 61
   14f48:	81 e0       	ldi	r24, 0x01	; 1
   14f4a:	60 e0       	ldi	r22, 0x00	; 0
   14f4c:	a8 01       	movw	r20, r16
   14f4e:	0e 94 97 b2 	call	0x1652e	; 0x1652e <_uart_print>
   14f52:	ed e4       	ldi	r30, 0x4D	; 77
   14f54:	ee 2e       	mov	r14, r30
   14f56:	e0 e0       	ldi	r30, 0x00	; 0
   14f58:	fe 2e       	mov	r15, r30
	 //PumpLabel
     for (i=0;i<8;i++){
	      xEEPROM=eeprom_read_byte(&DefPumpLabel[i]);
		  if (xEEPROM>=100)xEEPROM=0;
		  FillChar(strSend,0,sizeof(strSend));
	      sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
   14f5a:	d0 2e       	mov	r13, r16
   14f5c:	01 2f       	mov	r16, r17
   14f5e:	72 e5       	ldi	r23, 0x52	; 82
   14f60:	a7 2e       	mov	r10, r23
   14f62:	72 e2       	ldi	r23, 0x22	; 34
   14f64:	b7 2e       	mov	r11, r23
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
   14f66:	e1 99       	sbic	0x1c, 1	; 28
   14f68:	fe cf       	rjmp	.-4      	; 0x14f66 <SendConfigParamater+0x392>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   14f6a:	ff ba       	out	0x1f, r15	; 31
   14f6c:	ee ba       	out	0x1e, r14	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   14f6e:	e0 9a       	sbi	0x1c, 0	; 28
   14f70:	8d b3       	in	r24, 0x1d	; 29
     sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
     _uart_print(1,0,strSend);
	 //PumpLabel
     for (i=0;i<8;i++){
	      xEEPROM=eeprom_read_byte(&DefPumpLabel[i]);
		  if (xEEPROM>=100)xEEPROM=0;
   14f72:	84 36       	cpi	r24, 0x64	; 100
   14f74:	08 f0       	brcs	.+2      	; 0x14f78 <SendConfigParamater+0x3a4>
   14f76:	80 e0       	ldi	r24, 0x00	; 0
		  FillChar(strSend,0,sizeof(strSend));
	      sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
   14f78:	00 d0       	rcall	.+0      	; 0x14f7a <SendConfigParamater+0x3a6>
   14f7a:	00 d0       	rcall	.+0      	; 0x14f7c <SendConfigParamater+0x3a8>
   14f7c:	00 d0       	rcall	.+0      	; 0x14f7e <SendConfigParamater+0x3aa>
   14f7e:	ed b7       	in	r30, 0x3d	; 61
   14f80:	fe b7       	in	r31, 0x3e	; 62
   14f82:	31 96       	adiw	r30, 0x01	; 1
   14f84:	ad b7       	in	r26, 0x3d	; 61
   14f86:	be b7       	in	r27, 0x3e	; 62
   14f88:	11 96       	adiw	r26, 0x01	; 1
   14f8a:	dc 92       	st	X, r13
   14f8c:	11 97       	sbiw	r26, 0x01	; 1
   14f8e:	12 96       	adiw	r26, 0x02	; 2
   14f90:	0c 93       	st	X, r16
   14f92:	b3 82       	std	Z+3, r11	; 0x03
   14f94:	a2 82       	std	Z+2, r10	; 0x02
   14f96:	84 83       	std	Z+4, r24	; 0x04
   14f98:	15 82       	std	Z+5, r1	; 0x05
   14f9a:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
		  AddSpaceLag(strSend,2);
   14f9e:	ed b7       	in	r30, 0x3d	; 61
   14fa0:	fe b7       	in	r31, 0x3e	; 62
   14fa2:	36 96       	adiw	r30, 0x06	; 6
   14fa4:	0f b6       	in	r0, 0x3f	; 63
   14fa6:	f8 94       	cli
   14fa8:	fe bf       	out	0x3e, r31	; 62
   14faa:	0f be       	out	0x3f, r0	; 63
   14fac:	ed bf       	out	0x3d, r30	; 61
   14fae:	8d 2d       	mov	r24, r13
   14fb0:	90 2f       	mov	r25, r16
   14fb2:	62 e0       	ldi	r22, 0x02	; 2
   14fb4:	0e 94 d8 2a 	call	0x55b0	; 0x55b0 <AddSpaceLag>
		 _uart_print(1,0,strSend);
   14fb8:	81 e0       	ldi	r24, 0x01	; 1
   14fba:	60 e0       	ldi	r22, 0x00	; 0
   14fbc:	4d 2d       	mov	r20, r13
   14fbe:	50 2f       	mov	r21, r16
   14fc0:	0e 94 97 b2 	call	0x1652e	; 0x1652e <_uart_print>
   14fc4:	08 94       	sec
   14fc6:	e1 1c       	adc	r14, r1
   14fc8:	f1 1c       	adc	r15, r1
	 //TermId
     xEEPROM=eeprom_read_byte(&DefIFT_ID);     
     sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
     _uart_print(1,0,strSend);
	 //PumpLabel
     for (i=0;i<8;i++){
   14fca:	f5 e5       	ldi	r31, 0x55	; 85
   14fcc:	ef 16       	cp	r14, r31
   14fce:	f0 e0       	ldi	r31, 0x00	; 0
   14fd0:	ff 06       	cpc	r15, r31
   14fd2:	49 f6       	brne	.-110    	; 0x14f66 <SendConfigParamater+0x392>
		  FillChar(strSend,0,sizeof(strSend));
	      sprintf_P(strSend,PSTR("%.2d"),xEEPROM);
		  AddSpaceLag(strSend,2);
		 _uart_print(1,0,strSend);
	 }
	 _uart_printf(1,1,PSTR(">"));
   14fd4:	81 e0       	ldi	r24, 0x01	; 1
   14fd6:	61 e0       	ldi	r22, 0x01	; 1
   14fd8:	40 e5       	ldi	r20, 0x50	; 80
   14fda:	52 e2       	ldi	r21, 0x22	; 34
   14fdc:	0e 94 bf b2 	call	0x1657e	; 0x1657e <_uart_printf>
	 //End
}
   14fe0:	cb 59       	subi	r28, 0x9B	; 155
   14fe2:	df 4f       	sbci	r29, 0xFF	; 255
   14fe4:	0f b6       	in	r0, 0x3f	; 63
   14fe6:	f8 94       	cli
   14fe8:	de bf       	out	0x3e, r29	; 62
   14fea:	0f be       	out	0x3f, r0	; 63
   14fec:	cd bf       	out	0x3d, r28	; 61
   14fee:	cf 91       	pop	r28
   14ff0:	df 91       	pop	r29
   14ff2:	1f 91       	pop	r17
   14ff4:	0f 91       	pop	r16
   14ff6:	ff 90       	pop	r15
   14ff8:	ef 90       	pop	r14
   14ffa:	df 90       	pop	r13
   14ffc:	cf 90       	pop	r12
   14ffe:	bf 90       	pop	r11
   15000:	af 90       	pop	r10
   15002:	9f 90       	pop	r9
   15004:	8f 90       	pop	r8
   15006:	08 95       	ret

00015008 <SaveConfigParameter>:
     char Result;
	 Result=False;
   return Result;
}

void SaveConfigParameter(){
   15008:	8f 92       	push	r8
   1500a:	9f 92       	push	r9
   1500c:	af 92       	push	r10
   1500e:	bf 92       	push	r11
   15010:	cf 92       	push	r12
   15012:	df 92       	push	r13
   15014:	ef 92       	push	r14
   15016:	ff 92       	push	r15
   15018:	0f 93       	push	r16
   1501a:	1f 93       	push	r17
   1501c:	df 93       	push	r29
   1501e:	cf 93       	push	r28
   15020:	cd b7       	in	r28, 0x3d	; 61
   15022:	de b7       	in	r29, 0x3e	; 62
   15024:	c6 54       	subi	r28, 0x46	; 70
   15026:	d0 40       	sbci	r29, 0x00	; 0
   15028:	0f b6       	in	r0, 0x3f	; 63
   1502a:	f8 94       	cli
   1502c:	de bf       	out	0x3e, r29	; 62
   1502e:	0f be       	out	0x3f, r0	; 63
   15030:	cd bf       	out	0x3d, r28	; 61
char i,j;
char strEEPROM[50],xEEPROM;
unsigned int StrPos;
char strSend[20];
     
	 sprintf_P(strSend,PSTR("Length:%d"),transLength);
   15032:	00 d0       	rcall	.+0      	; 0x15034 <SaveConfigParameter+0x2c>
   15034:	00 d0       	rcall	.+0      	; 0x15036 <SaveConfigParameter+0x2e>
   15036:	00 d0       	rcall	.+0      	; 0x15038 <SaveConfigParameter+0x30>
   15038:	ed b7       	in	r30, 0x3d	; 61
   1503a:	fe b7       	in	r31, 0x3e	; 62
   1503c:	31 96       	adiw	r30, 0x01	; 1
   1503e:	8e 01       	movw	r16, r28
   15040:	0f 5f       	subi	r16, 0xFF	; 255
   15042:	1f 4f       	sbci	r17, 0xFF	; 255
   15044:	ad b7       	in	r26, 0x3d	; 61
   15046:	be b7       	in	r27, 0x3e	; 62
   15048:	12 96       	adiw	r26, 0x02	; 2
   1504a:	1c 93       	st	X, r17
   1504c:	0e 93       	st	-X, r16
   1504e:	11 97       	sbiw	r26, 0x01	; 1
   15050:	8a e8       	ldi	r24, 0x8A	; 138
   15052:	92 e2       	ldi	r25, 0x22	; 34
   15054:	93 83       	std	Z+3, r25	; 0x03
   15056:	82 83       	std	Z+2, r24	; 0x02
   15058:	80 91 9e 01 	lds	r24, 0x019E
   1505c:	90 91 9f 01 	lds	r25, 0x019F
   15060:	95 83       	std	Z+5, r25	; 0x05
   15062:	84 83       	std	Z+4, r24	; 0x04
   15064:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
	 _uart_print(1,1,strSend);
   15068:	ed b7       	in	r30, 0x3d	; 61
   1506a:	fe b7       	in	r31, 0x3e	; 62
   1506c:	36 96       	adiw	r30, 0x06	; 6
   1506e:	0f b6       	in	r0, 0x3f	; 63
   15070:	f8 94       	cli
   15072:	fe bf       	out	0x3e, r31	; 62
   15074:	0f be       	out	0x3f, r0	; 63
   15076:	ed bf       	out	0x3d, r30	; 61
   15078:	81 e0       	ldi	r24, 0x01	; 1
   1507a:	61 e0       	ldi	r22, 0x01	; 1
   1507c:	a8 01       	movw	r20, r16
   1507e:	0e 94 97 b2 	call	0x1652e	; 0x1652e <_uart_print>

     StrPos=0;
	 _uart_printf(1,1,PSTR("<Saving>")); 
   15082:	81 e0       	ldi	r24, 0x01	; 1
   15084:	61 e0       	ldi	r22, 0x01	; 1
   15086:	41 e8       	ldi	r20, 0x81	; 129
   15088:	52 e2       	ldi	r21, 0x22	; 34
   1508a:	0e 94 bf b2 	call	0x1657e	; 0x1657e <_uart_printf>
   1508e:	07 e2       	ldi	r16, 0x27	; 39
   15090:	12 e0       	ldi	r17, 0x02	; 2
   15092:	a5 ef       	ldi	r26, 0xF5	; 245
   15094:	ea 2e       	mov	r14, r26
   15096:	aa e0       	ldi	r26, 0x0A	; 10
   15098:	fa 2e       	mov	r15, r26
   1509a:	f5 e1       	ldi	r31, 0x15	; 21
   1509c:	af 2e       	mov	r10, r31
   1509e:	b1 2c       	mov	r11, r1
   150a0:	ac 0e       	add	r10, r28
   150a2:	bd 1e       	adc	r11, r29
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   150a4:	ed e3       	ldi	r30, 0x3D	; 61
   150a6:	ce 2e       	mov	r12, r30
   150a8:	d1 2c       	mov	r13, r1
   150aa:	cc 0e       	add	r12, r28
   150ac:	dd 1e       	adc	r13, r29
     
	 sprintf_P(strSend,PSTR("Length:%d"),transLength);
	 _uart_print(1,1,strSend);

     StrPos=0;
	 _uart_printf(1,1,PSTR("<Saving>")); 
   150ae:	d7 01       	movw	r26, r14
   150b0:	f5 01       	movw	r30, r10
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   150b2:	8d 91       	ld	r24, X+
   150b4:	81 93       	st	Z+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   150b6:	ec 15       	cp	r30, r12
   150b8:	fd 05       	cpc	r31, r13
   150ba:	d9 f7       	brne	.-10     	; 0x150b2 <SaveConfigParameter+0xaa>
	 _uart_printf(1,1,PSTR("<Saving>")); 
     //HeaderFooter
	 for(i=0;i<10;i++){
         FillChar(strEEPROM,0,sizeof(strEEPROM));   
		 StrPosCopy(rcv_trans,strEEPROM,(StrPos+(40*i)),40);
		 strEEPROM[40]=0;
   150bc:	1d ae       	std	Y+61, r1	; 0x3d
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
   150be:	c8 01       	movw	r24, r16
   150c0:	b5 01       	movw	r22, r10
   150c2:	49 e2       	ldi	r20, 0x29	; 41
   150c4:	50 e0       	ldi	r21, 0x00	; 0
   150c6:	2b ef       	ldi	r18, 0xFB	; 251
   150c8:	32 e1       	ldi	r19, 0x12	; 18
   150ca:	0e 94 3b b4 	call	0x16876	; 0x16876 <__eewr_block>
   150ce:	07 5d       	subi	r16, 0xD7	; 215
   150d0:	1f 4f       	sbci	r17, 0xFF	; 255
   150d2:	88 e2       	ldi	r24, 0x28	; 40
   150d4:	90 e0       	ldi	r25, 0x00	; 0
   150d6:	e8 0e       	add	r14, r24
   150d8:	f9 1e       	adc	r15, r25
	 _uart_print(1,1,strSend);

     StrPos=0;
	 _uart_printf(1,1,PSTR("<Saving>")); 
     //HeaderFooter
	 for(i=0;i<10;i++){
   150da:	93 e0       	ldi	r25, 0x03	; 3
   150dc:	01 3c       	cpi	r16, 0xC1	; 193
   150de:	19 07       	cpc	r17, r25
   150e0:	31 f7       	brne	.-52     	; 0x150ae <SaveConfigParameter+0xa6>
   150e2:	0b eb       	ldi	r16, 0xBB	; 187
   150e4:	10 e0       	ldi	r17, 0x00	; 0
   150e6:	75 e8       	ldi	r23, 0x85	; 133
   150e8:	e7 2e       	mov	r14, r23
   150ea:	7c e0       	ldi	r23, 0x0C	; 12
   150ec:	f7 2e       	mov	r15, r23
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   150ee:	65 e1       	ldi	r22, 0x15	; 21
   150f0:	c6 2e       	mov	r12, r22
   150f2:	d1 2c       	mov	r13, r1
   150f4:	cc 0e       	add	r12, r28
   150f6:	dd 1e       	adc	r13, r29
   150f8:	51 e2       	ldi	r21, 0x21	; 33
   150fa:	85 2e       	mov	r8, r21
   150fc:	91 2c       	mov	r9, r1
   150fe:	8c 0e       	add	r8, r28
   15100:	9d 1e       	adc	r9, r29
	 _uart_print(1,1,strSend);

     StrPos=0;
	 _uart_printf(1,1,PSTR("<Saving>")); 
     //HeaderFooter
	 for(i=0;i<10;i++){
   15102:	d7 01       	movw	r26, r14
   15104:	f5 01       	movw	r30, r10
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   15106:	8d 91       	ld	r24, X+
   15108:	81 93       	st	Z+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   1510a:	e8 15       	cp	r30, r8
   1510c:	f9 05       	cpc	r31, r9
   1510e:	d9 f7       	brne	.-10     	; 0x15106 <SaveConfigParameter+0xfe>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   15110:	19 a2       	std	Y+33, r1	; 0x21
	 //ProductName
	 StrPos=(40*10);
	 for(i=0;i<6;i++){
         FillChar(strEEPROM,0,sizeof(strEEPROM));   
		 StrPosCopy(rcv_trans,strEEPROM,(StrPos+(12*i)),12);
		 RemSpaceLag(strEEPROM);
   15112:	c6 01       	movw	r24, r12
   15114:	0e 94 70 24 	call	0x48e0	; 0x48e0 <RemSpaceLag>
		 strEEPROM[strlen(strEEPROM)]=0;
   15118:	f6 01       	movw	r30, r12
   1511a:	01 90       	ld	r0, Z+
   1511c:	00 20       	and	r0, r0
   1511e:	e9 f7       	brne	.-6      	; 0x1511a <SaveConfigParameter+0x112>
   15120:	31 97       	sbiw	r30, 0x01	; 1
   15122:	10 82       	st	Z, r1
   15124:	c8 01       	movw	r24, r16
   15126:	b6 01       	movw	r22, r12
   15128:	4d e0       	ldi	r20, 0x0D	; 13
   1512a:	50 e0       	ldi	r21, 0x00	; 0
   1512c:	2b ef       	ldi	r18, 0xFB	; 251
   1512e:	32 e1       	ldi	r19, 0x12	; 18
   15130:	0e 94 3b b4 	call	0x16876	; 0x16876 <__eewr_block>
   15134:	03 5f       	subi	r16, 0xF3	; 243
   15136:	1f 4f       	sbci	r17, 0xFF	; 255
   15138:	ac e0       	ldi	r26, 0x0C	; 12
   1513a:	b0 e0       	ldi	r27, 0x00	; 0
   1513c:	ea 0e       	add	r14, r26
   1513e:	fb 1e       	adc	r15, r27
		 eeprom_write_block((const void*) &strEEPROM, (void*) &DefHeaderFooter[i],41);
		 //_uart_print(1,1,strEEPROM);
	 }
	 //ProductName
	 StrPos=(40*10);
	 for(i=0;i<6;i++){
   15140:	b1 e0       	ldi	r27, 0x01	; 1
   15142:	09 30       	cpi	r16, 0x09	; 9
   15144:	1b 07       	cpc	r17, r27
   15146:	e9 f6       	brne	.-70     	; 0x15102 <SaveConfigParameter+0xfa>
   15148:	05 e8       	ldi	r16, 0x85	; 133
   1514a:	10 e0       	ldi	r17, 0x00	; 0
   1514c:	4d ec       	ldi	r20, 0xCD	; 205
   1514e:	e4 2e       	mov	r14, r20
   15150:	4c e0       	ldi	r20, 0x0C	; 12
   15152:	f4 2e       	mov	r15, r20
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   15154:	35 e1       	ldi	r19, 0x15	; 21
   15156:	c3 2e       	mov	r12, r19
   15158:	d1 2c       	mov	r13, r1
   1515a:	cc 0e       	add	r12, r28
   1515c:	dd 1e       	adc	r13, r29
   1515e:	2a e1       	ldi	r18, 0x1A	; 26
   15160:	82 2e       	mov	r8, r18
   15162:	91 2c       	mov	r9, r1
   15164:	8c 0e       	add	r8, r28
   15166:	9d 1e       	adc	r9, r29
		 eeprom_write_block((const void*) &strEEPROM, (void*) &DefHeaderFooter[i],41);
		 //_uart_print(1,1,strEEPROM);
	 }
	 //ProductName
	 StrPos=(40*10);
	 for(i=0;i<6;i++){
   15168:	d7 01       	movw	r26, r14
   1516a:	f5 01       	movw	r30, r10
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   1516c:	8d 91       	ld	r24, X+
   1516e:	81 93       	st	Z+, r24
	 AddSpaceLag(Source,Length);
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
   15170:	e8 15       	cp	r30, r8
   15172:	f9 05       	cpc	r31, r9
   15174:	d9 f7       	brne	.-10     	; 0x1516c <SaveConfigParameter+0x164>
	    Dest[i]=Source[IdxSource+i];
	 }Dest[Length]=0;
   15176:	1a 8e       	std	Y+26, r1	; 0x1a
	 //ProductPrice
	 StrPos=(40*10)+(12*6);
	 for(i=0;i<6;i++){
         FillChar(strEEPROM,0,sizeof(strEEPROM));   
		 StrPosCopy(rcv_trans,strEEPROM,(StrPos+(5*i)),5);
		 RemSpaceLag(strEEPROM);
   15178:	c6 01       	movw	r24, r12
   1517a:	0e 94 70 24 	call	0x48e0	; 0x48e0 <RemSpaceLag>
   1517e:	c8 01       	movw	r24, r16
   15180:	b6 01       	movw	r22, r12
   15182:	49 e0       	ldi	r20, 0x09	; 9
   15184:	50 e0       	ldi	r21, 0x00	; 0
   15186:	2b ef       	ldi	r18, 0xFB	; 251
   15188:	32 e1       	ldi	r19, 0x12	; 18
   1518a:	0e 94 3b b4 	call	0x16876	; 0x16876 <__eewr_block>
   1518e:	07 5f       	subi	r16, 0xF7	; 247
   15190:	1f 4f       	sbci	r17, 0xFF	; 255
   15192:	e5 e0       	ldi	r30, 0x05	; 5
   15194:	f0 e0       	ldi	r31, 0x00	; 0
   15196:	ee 0e       	add	r14, r30
   15198:	ff 1e       	adc	r15, r31
		// _uart_print(1,1,strEEPROM);

	 }    
	 //ProductPrice
	 StrPos=(40*10)+(12*6);
	 for(i=0;i<6;i++){
   1519a:	f0 e0       	ldi	r31, 0x00	; 0
   1519c:	0b 3b       	cpi	r16, 0xBB	; 187
   1519e:	1f 07       	cpc	r17, r31
   151a0:	19 f7       	brne	.-58     	; 0x15168 <SaveConfigParameter+0x160>
   151a2:	0b ee       	ldi	r16, 0xEB	; 235
   151a4:	1c e0       	ldi	r17, 0x0C	; 12
   151a6:	95 e4       	ldi	r25, 0x45	; 69
   151a8:	e9 2e       	mov	r14, r25
   151aa:	90 e0       	ldi	r25, 0x00	; 0
   151ac:	f9 2e       	mov	r15, r25
	 //PumpID Config
	 StrPos=(40*10)+(12*6)+(5*6);
	 for(i=0;i<8;i++){
         FillChar(strEEPROM,0,sizeof(strEEPROM));   
		 StrPosCopy(rcv_trans,strEEPROM,(StrPos+(2*i)),2);
		 RemZeroLead(strEEPROM);
   151ae:	85 e1       	ldi	r24, 0x15	; 21
   151b0:	c8 2e       	mov	r12, r24
   151b2:	d1 2c       	mov	r13, r1
   151b4:	cc 0e       	add	r12, r28
   151b6:	dd 1e       	adc	r13, r29
		 xEEPROM=atoi(strEEPROM);
         eeprom_write_byte(&DefPumpMap[i],xEEPROM);
		 sprintf_P(strSend,PSTR("%d"),xEEPROM);
   151b8:	4e 01       	movw	r8, r28
   151ba:	08 94       	sec
   151bc:	81 1c       	adc	r8, r1
   151be:	91 1c       	adc	r9, r1
   151c0:	be e7       	ldi	r27, 0x7E	; 126
   151c2:	ab 2e       	mov	r10, r27
   151c4:	b2 e2       	ldi	r27, 0x22	; 34
   151c6:	bb 2e       	mov	r11, r27
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   151c8:	d8 01       	movw	r26, r16
   151ca:	8c 91       	ld	r24, X
   151cc:	8d 8b       	std	Y+21, r24	; 0x15
   151ce:	11 96       	adiw	r26, 0x01	; 1
   151d0:	8c 91       	ld	r24, X
   151d2:	8e 8b       	std	Y+22, r24	; 0x16
	 }Dest[Length]=0;
   151d4:	1f 8a       	std	Y+23, r1	; 0x17
	 //PumpID Config
	 StrPos=(40*10)+(12*6)+(5*6);
	 for(i=0;i<8;i++){
         FillChar(strEEPROM,0,sizeof(strEEPROM));   
		 StrPosCopy(rcv_trans,strEEPROM,(StrPos+(2*i)),2);
		 RemZeroLead(strEEPROM);
   151d6:	c6 01       	movw	r24, r12
   151d8:	0e 94 dd 23 	call	0x47ba	; 0x47ba <RemZeroLead>
		 xEEPROM=atoi(strEEPROM);
   151dc:	c6 01       	movw	r24, r12
   151de:	0e 94 ea b3 	call	0x167d4	; 0x167d4 <atoi>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   151e2:	e1 99       	sbic	0x1c, 1	; 28
   151e4:	fe cf       	rjmp	.-4      	; 0x151e2 <SaveConfigParameter+0x1da>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   151e6:	ff ba       	out	0x1f, r15	; 31
   151e8:	ee ba       	out	0x1e, r14	; 30
#endif
    EEDR = __value;
   151ea:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
   151ec:	0f b6       	in	r0, 0x3f	; 63
   151ee:	f8 94       	cli
   151f0:	e2 9a       	sbi	0x1c, 2	; 28
   151f2:	e1 9a       	sbi	0x1c, 1	; 28
   151f4:	0f be       	out	0x3f, r0	; 63
         eeprom_write_byte(&DefPumpMap[i],xEEPROM);
		 sprintf_P(strSend,PSTR("%d"),xEEPROM);
   151f6:	00 d0       	rcall	.+0      	; 0x151f8 <SaveConfigParameter+0x1f0>
   151f8:	00 d0       	rcall	.+0      	; 0x151fa <SaveConfigParameter+0x1f2>
   151fa:	00 d0       	rcall	.+0      	; 0x151fc <SaveConfigParameter+0x1f4>
   151fc:	ed b7       	in	r30, 0x3d	; 61
   151fe:	fe b7       	in	r31, 0x3e	; 62
   15200:	31 96       	adiw	r30, 0x01	; 1
   15202:	ad b7       	in	r26, 0x3d	; 61
   15204:	be b7       	in	r27, 0x3e	; 62
   15206:	12 96       	adiw	r26, 0x02	; 2
   15208:	9c 92       	st	X, r9
   1520a:	8e 92       	st	-X, r8
   1520c:	11 97       	sbiw	r26, 0x01	; 1
   1520e:	b3 82       	std	Z+3, r11	; 0x03
   15210:	a2 82       	std	Z+2, r10	; 0x02
   15212:	84 83       	std	Z+4, r24	; 0x04
   15214:	15 82       	std	Z+5, r1	; 0x05
   15216:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
   1521a:	0e 5f       	subi	r16, 0xFE	; 254
   1521c:	1f 4f       	sbci	r17, 0xFF	; 255
   1521e:	08 94       	sec
   15220:	e1 1c       	adc	r14, r1
   15222:	f1 1c       	adc	r15, r1
		// _uart_print(1,1,strEEPROM);

	 }    
	 //PumpID Config
	 StrPos=(40*10)+(12*6)+(5*6);
	 for(i=0;i<8;i++){
   15224:	ed b7       	in	r30, 0x3d	; 61
   15226:	fe b7       	in	r31, 0x3e	; 62
   15228:	36 96       	adiw	r30, 0x06	; 6
   1522a:	0f b6       	in	r0, 0x3f	; 63
   1522c:	f8 94       	cli
   1522e:	fe bf       	out	0x3e, r31	; 62
   15230:	0f be       	out	0x3f, r0	; 63
   15232:	ed bf       	out	0x3d, r30	; 61
   15234:	fc e0       	ldi	r31, 0x0C	; 12
   15236:	0b 3f       	cpi	r16, 0xFB	; 251
   15238:	1f 07       	cpc	r17, r31
   1523a:	09 f0       	breq	.+2      	; 0x1523e <SaveConfigParameter+0x236>
   1523c:	c5 cf       	rjmp	.-118    	; 0x151c8 <SaveConfigParameter+0x1c0>
   1523e:	45 e5       	ldi	r20, 0x55	; 85
   15240:	50 e0       	ldi	r21, 0x00	; 0
   15242:	b8 01       	movw	r22, r16
   15244:	1d c0       	rjmp	.+58     	; 0x15280 <SaveConfigParameter+0x278>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
   15246:	90 81       	ld	r25, Z
   15248:	90 53       	subi	r25, 0x30	; 48
   1524a:	9a 30       	cpi	r25, 0x0A	; 10
   1524c:	08 f0       	brcs	.+2      	; 0x15250 <SaveConfigParameter+0x248>
   1524e:	90 e0       	ldi	r25, 0x00	; 0
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   15250:	e1 99       	sbic	0x1c, 1	; 28
   15252:	fe cf       	rjmp	.-4      	; 0x15250 <SaveConfigParameter+0x248>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   15254:	3f bb       	out	0x1f, r19	; 31
   15256:	2e bb       	out	0x1e, r18	; 30
#endif
    EEDR = __value;
   15258:	9d bb       	out	0x1d, r25	; 29

    __asm__ __volatile__ (
   1525a:	0f b6       	in	r0, 0x3f	; 63
   1525c:	f8 94       	cli
   1525e:	e2 9a       	sbi	0x1c, 2	; 28
   15260:	e1 9a       	sbi	0x1c, 1	; 28
   15262:	0f be       	out	0x3f, r0	; 63

	 }    
	 //PumpNozzle
	 StrPos=(40*10)+(12*6)+(5*6)+(2*8);
	 for (i=0;i<8;i++){
	     for (j=0;j<6;j++){
   15264:	8f 5f       	subi	r24, 0xFF	; 255
   15266:	31 96       	adiw	r30, 0x01	; 1
   15268:	2f 5f       	subi	r18, 0xFF	; 255
   1526a:	3f 4f       	sbci	r19, 0xFF	; 255
   1526c:	86 30       	cpi	r24, 0x06	; 6
   1526e:	59 f7       	brne	.-42     	; 0x15246 <SaveConfigParameter+0x23e>
   15270:	4a 5f       	subi	r20, 0xFA	; 250
   15272:	5f 4f       	sbci	r21, 0xFF	; 255
   15274:	6a 5f       	subi	r22, 0xFA	; 250
   15276:	7f 4f       	sbci	r23, 0xFF	; 255
		// _uart_print(1,1,strSend); 

	 }    
	 //PumpNozzle
	 StrPos=(40*10)+(12*6)+(5*6)+(2*8);
	 for (i=0;i<8;i++){
   15278:	80 e0       	ldi	r24, 0x00	; 0
   1527a:	45 38       	cpi	r20, 0x85	; 133
   1527c:	58 07       	cpc	r21, r24
   1527e:	21 f0       	breq	.+8      	; 0x15288 <SaveConfigParameter+0x280>
   15280:	fb 01       	movw	r30, r22
   15282:	9a 01       	movw	r18, r20
   15284:	80 e0       	ldi	r24, 0x00	; 0
   15286:	df cf       	rjmp	.-66     	; 0x15246 <SaveConfigParameter+0x23e>
	 }
	return Result;
}
char Ord(char c){//Return Ordinal Numbers
     char Result=0;
	 if ((c>='0')&&(c<='9')){
   15288:	80 91 2b 0d 	lds	r24, 0x0D2B
   1528c:	80 53       	subi	r24, 0x30	; 48
   1528e:	8a 30       	cpi	r24, 0x0A	; 10
   15290:	10 f0       	brcs	.+4      	; 0x15296 <SaveConfigParameter+0x28e>
   15292:	20 e0       	ldi	r18, 0x00	; 0
   15294:	03 c0       	rjmp	.+6      	; 0x1529c <SaveConfigParameter+0x294>
   15296:	81 11       	cpse	r24, r1
   15298:	81 e0       	ldi	r24, 0x01	; 1
   1529a:	28 2f       	mov	r18, r24
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   1529c:	e1 99       	sbic	0x1c, 1	; 28
   1529e:	fe cf       	rjmp	.-4      	; 0x1529c <SaveConfigParameter+0x294>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   152a0:	81 ec       	ldi	r24, 0xC1	; 193
   152a2:	93 e0       	ldi	r25, 0x03	; 3
   152a4:	9f bb       	out	0x1f, r25	; 31
   152a6:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
   152a8:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
   152aa:	0f b6       	in	r0, 0x3f	; 63
   152ac:	f8 94       	cli
   152ae:	e2 9a       	sbi	0x1c, 2	; 28
   152b0:	e1 9a       	sbi	0x1c, 1	; 28
   152b2:	0f be       	out	0x3f, r0	; 63
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   152b4:	80 91 2c 0d 	lds	r24, 0x0D2C
   152b8:	8d 8b       	std	Y+21, r24	; 0x15
   152ba:	80 91 2d 0d 	lds	r24, 0x0D2D
   152be:	8e 8b       	std	Y+22, r24	; 0x16
	 }Dest[Length]=0;
   152c0:	1f 8a       	std	Y+23, r1	; 0x17

	 //TermID
	 StrPos=(40*10)+(12*6)+(5*6)+(2*8)+(6*8)+1;
     FillChar(strEEPROM,0,sizeof(strEEPROM));   
	 StrPosCopy(rcv_trans,strEEPROM,StrPos,2);
	 RemZeroLead(strEEPROM);
   152c2:	8e 01       	movw	r16, r28
   152c4:	0b 5e       	subi	r16, 0xEB	; 235
   152c6:	1f 4f       	sbci	r17, 0xFF	; 255
   152c8:	c8 01       	movw	r24, r16
   152ca:	0e 94 dd 23 	call	0x47ba	; 0x47ba <RemZeroLead>
	 xEEPROM=atoi(strEEPROM);
   152ce:	c8 01       	movw	r24, r16
   152d0:	0e 94 ea b3 	call	0x167d4	; 0x167d4 <atoi>
   152d4:	28 2f       	mov	r18, r24
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   152d6:	e1 99       	sbic	0x1c, 1	; 28
   152d8:	fe cf       	rjmp	.-4      	; 0x152d6 <SaveConfigParameter+0x2ce>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   152da:	80 e0       	ldi	r24, 0x00	; 0
   152dc:	90 e0       	ldi	r25, 0x00	; 0
   152de:	9f bb       	out	0x1f, r25	; 31
   152e0:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
   152e2:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
   152e4:	0f b6       	in	r0, 0x3f	; 63
   152e6:	f8 94       	cli
   152e8:	e2 9a       	sbi	0x1c, 2	; 28
   152ea:	e1 9a       	sbi	0x1c, 1	; 28
   152ec:	0f be       	out	0x3f, r0	; 63
	 eeprom_write_byte(&DefIFT_ID,xEEPROM);
	 sprintf_P(strSend,PSTR("%d"),xEEPROM);
   152ee:	00 d0       	rcall	.+0      	; 0x152f0 <SaveConfigParameter+0x2e8>
   152f0:	00 d0       	rcall	.+0      	; 0x152f2 <SaveConfigParameter+0x2ea>
   152f2:	00 d0       	rcall	.+0      	; 0x152f4 <SaveConfigParameter+0x2ec>
   152f4:	ed b7       	in	r30, 0x3d	; 61
   152f6:	fe b7       	in	r31, 0x3e	; 62
   152f8:	31 96       	adiw	r30, 0x01	; 1
   152fa:	8e 01       	movw	r16, r28
   152fc:	0f 5f       	subi	r16, 0xFF	; 255
   152fe:	1f 4f       	sbci	r17, 0xFF	; 255
   15300:	ad b7       	in	r26, 0x3d	; 61
   15302:	be b7       	in	r27, 0x3e	; 62
   15304:	12 96       	adiw	r26, 0x02	; 2
   15306:	1c 93       	st	X, r17
   15308:	0e 93       	st	-X, r16
   1530a:	11 97       	sbiw	r26, 0x01	; 1
   1530c:	8b e7       	ldi	r24, 0x7B	; 123
   1530e:	92 e2       	ldi	r25, 0x22	; 34
   15310:	93 83       	std	Z+3, r25	; 0x03
   15312:	82 83       	std	Z+2, r24	; 0x02
   15314:	24 83       	std	Z+4, r18	; 0x04
   15316:	15 82       	std	Z+5, r1	; 0x05
   15318:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
   1531c:	ae e2       	ldi	r26, 0x2E	; 46
   1531e:	ea 2e       	mov	r14, r26
   15320:	ad e0       	ldi	r26, 0x0D	; 13
   15322:	fa 2e       	mov	r15, r26
   15324:	fd e4       	ldi	r31, 0x4D	; 77
   15326:	cf 2e       	mov	r12, r31
   15328:	f0 e0       	ldi	r31, 0x00	; 0
   1532a:	df 2e       	mov	r13, r31
   1532c:	ed b7       	in	r30, 0x3d	; 61
   1532e:	fe b7       	in	r31, 0x3e	; 62
   15330:	36 96       	adiw	r30, 0x06	; 6
   15332:	0f b6       	in	r0, 0x3f	; 63
   15334:	f8 94       	cli
   15336:	fe bf       	out	0x3e, r31	; 62
   15338:	0f be       	out	0x3f, r0	; 63
   1533a:	ed bf       	out	0x3d, r30	; 61
	 //PumpLabel
	 StrPos=(40*10)+(12*6)+(5*6)+(2*8)+(6*8)+1+2;
	 for(i=0;i<8;i++){
         FillChar(strEEPROM,0,sizeof(strEEPROM));   
		 StrPosCopy(rcv_trans,strEEPROM,(StrPos+(2*i)),2);
		 RemZeroLead(strEEPROM);
   1533c:	e5 e1       	ldi	r30, 0x15	; 21
   1533e:	ae 2e       	mov	r10, r30
   15340:	b1 2c       	mov	r11, r1
   15342:	ac 0e       	add	r10, r28
   15344:	bd 1e       	adc	r11, r29
		 xEEPROM=atoi(strEEPROM);
         eeprom_write_byte(&DefPumpLabel[i],xEEPROM);
		 sprintf_P(strSend,PSTR("%d"),xEEPROM);
   15346:	48 01       	movw	r8, r16
   15348:	08 e7       	ldi	r16, 0x78	; 120
   1534a:	12 e2       	ldi	r17, 0x22	; 34
}

void StrPosCopy(char *Source, char *Dest,unsigned int IdxSource, unsigned int Length){
unsigned int i;
     for(i=0;i<Length;i++){
	    Dest[i]=Source[IdxSource+i];
   1534c:	d7 01       	movw	r26, r14
   1534e:	8c 91       	ld	r24, X
   15350:	8d 8b       	std	Y+21, r24	; 0x15
   15352:	11 96       	adiw	r26, 0x01	; 1
   15354:	8c 91       	ld	r24, X
   15356:	8e 8b       	std	Y+22, r24	; 0x16
	 }Dest[Length]=0;
   15358:	1f 8a       	std	Y+23, r1	; 0x17
	 //PumpLabel
	 StrPos=(40*10)+(12*6)+(5*6)+(2*8)+(6*8)+1+2;
	 for(i=0;i<8;i++){
         FillChar(strEEPROM,0,sizeof(strEEPROM));   
		 StrPosCopy(rcv_trans,strEEPROM,(StrPos+(2*i)),2);
		 RemZeroLead(strEEPROM);
   1535a:	c5 01       	movw	r24, r10
   1535c:	0e 94 dd 23 	call	0x47ba	; 0x47ba <RemZeroLead>
		 xEEPROM=atoi(strEEPROM);
   15360:	c5 01       	movw	r24, r10
   15362:	0e 94 ea b3 	call	0x167d4	; 0x167d4 <atoi>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
   15366:	e1 99       	sbic	0x1c, 1	; 28
   15368:	fe cf       	rjmp	.-4      	; 0x15366 <SaveConfigParameter+0x35e>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   1536a:	df ba       	out	0x1f, r13	; 31
   1536c:	ce ba       	out	0x1e, r12	; 30
#endif
    EEDR = __value;
   1536e:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
   15370:	0f b6       	in	r0, 0x3f	; 63
   15372:	f8 94       	cli
   15374:	e2 9a       	sbi	0x1c, 2	; 28
   15376:	e1 9a       	sbi	0x1c, 1	; 28
   15378:	0f be       	out	0x3f, r0	; 63
         eeprom_write_byte(&DefPumpLabel[i],xEEPROM);
		 sprintf_P(strSend,PSTR("%d"),xEEPROM);
   1537a:	00 d0       	rcall	.+0      	; 0x1537c <SaveConfigParameter+0x374>
   1537c:	00 d0       	rcall	.+0      	; 0x1537e <SaveConfigParameter+0x376>
   1537e:	00 d0       	rcall	.+0      	; 0x15380 <SaveConfigParameter+0x378>
   15380:	ed b7       	in	r30, 0x3d	; 61
   15382:	fe b7       	in	r31, 0x3e	; 62
   15384:	31 96       	adiw	r30, 0x01	; 1
   15386:	ad b7       	in	r26, 0x3d	; 61
   15388:	be b7       	in	r27, 0x3e	; 62
   1538a:	11 96       	adiw	r26, 0x01	; 1
   1538c:	8c 92       	st	X, r8
   1538e:	11 97       	sbiw	r26, 0x01	; 1
   15390:	12 96       	adiw	r26, 0x02	; 2
   15392:	9c 92       	st	X, r9
   15394:	13 83       	std	Z+3, r17	; 0x03
   15396:	02 83       	std	Z+2, r16	; 0x02
   15398:	84 83       	std	Z+4, r24	; 0x04
   1539a:	15 82       	std	Z+5, r1	; 0x05
   1539c:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
   153a0:	e2 e0       	ldi	r30, 0x02	; 2
   153a2:	f0 e0       	ldi	r31, 0x00	; 0
   153a4:	ee 0e       	add	r14, r30
   153a6:	ff 1e       	adc	r15, r31
   153a8:	08 94       	sec
   153aa:	c1 1c       	adc	r12, r1
   153ac:	d1 1c       	adc	r13, r1
	 sprintf_P(strSend,PSTR("%d"),xEEPROM);
//	 _uart_print(1,1,strSend); 

	 //PumpLabel
	 StrPos=(40*10)+(12*6)+(5*6)+(2*8)+(6*8)+1+2;
	 for(i=0;i<8;i++){
   153ae:	8d b7       	in	r24, 0x3d	; 61
   153b0:	9e b7       	in	r25, 0x3e	; 62
   153b2:	06 96       	adiw	r24, 0x06	; 6
   153b4:	0f b6       	in	r0, 0x3f	; 63
   153b6:	f8 94       	cli
   153b8:	9e bf       	out	0x3e, r25	; 62
   153ba:	0f be       	out	0x3f, r0	; 63
   153bc:	8d bf       	out	0x3d, r24	; 61
   153be:	9e e3       	ldi	r25, 0x3E	; 62
   153c0:	e9 16       	cp	r14, r25
   153c2:	9d e0       	ldi	r25, 0x0D	; 13
   153c4:	f9 06       	cpc	r15, r25
   153c6:	09 f0       	breq	.+2      	; 0x153ca <SaveConfigParameter+0x3c2>
   153c8:	c1 cf       	rjmp	.-126    	; 0x1534c <SaveConfigParameter+0x344>
		 xEEPROM=atoi(strEEPROM);
         eeprom_write_byte(&DefPumpLabel[i],xEEPROM);
		 sprintf_P(strSend,PSTR("%d"),xEEPROM);
//		 _uart_print(1,1,strSend); 
	 }    
	 _uart_printf(1,1,PSTR("<OK>")); 
   153ca:	81 e0       	ldi	r24, 0x01	; 1
   153cc:	61 e0       	ldi	r22, 0x01	; 1
   153ce:	43 e7       	ldi	r20, 0x73	; 115
   153d0:	52 e2       	ldi	r21, 0x22	; 34
   153d2:	0e 94 bf b2 	call	0x1657e	; 0x1657e <_uart_printf>
}
   153d6:	ca 5b       	subi	r28, 0xBA	; 186
   153d8:	df 4f       	sbci	r29, 0xFF	; 255
   153da:	0f b6       	in	r0, 0x3f	; 63
   153dc:	f8 94       	cli
   153de:	de bf       	out	0x3e, r29	; 62
   153e0:	0f be       	out	0x3f, r0	; 63
   153e2:	cd bf       	out	0x3d, r28	; 61
   153e4:	cf 91       	pop	r28
   153e6:	df 91       	pop	r29
   153e8:	1f 91       	pop	r17
   153ea:	0f 91       	pop	r16
   153ec:	ff 90       	pop	r15
   153ee:	ef 90       	pop	r14
   153f0:	df 90       	pop	r13
   153f2:	cf 90       	pop	r12
   153f4:	bf 90       	pop	r11
   153f6:	af 90       	pop	r10
   153f8:	9f 90       	pop	r9
   153fa:	8f 90       	pop	r8
   153fc:	08 95       	ret

000153fe <systemConfigProtocol>:



void systemConfigProtocol(){
     static char stConfigProtocol=cpWaitSend;
	 switch(stConfigProtocol){
   153fe:	80 91 ad 03 	lds	r24, 0x03AD
   15402:	81 30       	cpi	r24, 0x01	; 1
   15404:	c1 f0       	breq	.+48     	; 0x15436 <systemConfigProtocol+0x38>
   15406:	81 30       	cpi	r24, 0x01	; 1
   15408:	18 f0       	brcs	.+6      	; 0x15410 <systemConfigProtocol+0x12>
   1540a:	82 30       	cpi	r24, 0x02	; 2
   1540c:	e9 f4       	brne	.+58     	; 0x15448 <systemConfigProtocol+0x4a>
   1540e:	18 c0       	rjmp	.+48     	; 0x15440 <systemConfigProtocol+0x42>
	 case cpWaitSend:
	      switch(ConfigCommand){
   15410:	80 91 c6 01 	lds	r24, 0x01C6
   15414:	81 30       	cpi	r24, 0x01	; 1
   15416:	31 f0       	breq	.+12     	; 0x15424 <systemConfigProtocol+0x26>
   15418:	82 30       	cpi	r24, 0x02	; 2
   1541a:	51 f4       	brne	.+20     	; 0x15430 <systemConfigProtocol+0x32>
		  case CC_SEND_CONFIG:
		       ConfigCommand=CC_NONE;
   1541c:	10 92 c6 01 	sts	0x01C6, r1
			   stConfigProtocol=cpSendingParameter;
   15420:	81 e0       	ldi	r24, 0x01	; 1
   15422:	03 c0       	rjmp	.+6      	; 0x1542a <systemConfigProtocol+0x2c>
		       break;
		  case CC_SAVE_CONFIG:
		       ConfigCommand=CC_NONE;
   15424:	10 92 c6 01 	sts	0x01C6, r1
			   stConfigProtocol=cpSavingParameter;
   15428:	82 e0       	ldi	r24, 0x02	; 2
   1542a:	80 93 ad 03 	sts	0x03AD, r24
   1542e:	08 95       	ret
		       break;
          default:
		       ConfigCommand=CC_NONE;
   15430:	10 92 c6 01 	sts	0x01C6, r1
   15434:	08 95       	ret
		       break;
		  }
	      break;
     case cpSendingParameter:
	      SendConfigParamater();
   15436:	0e 94 ea a5 	call	0x14bd4	; 0x14bd4 <SendConfigParamater>
          stConfigProtocol=cpWaitSend;
   1543a:	10 92 ad 03 	sts	0x03AD, r1
   1543e:	08 95       	ret
	      break;
     case cpSavingParameter:
          SaveConfigParameter();
   15440:	0e 94 04 a8 	call	0x15008	; 0x15008 <SaveConfigParameter>
          stConfigProtocol=cpWaitSend;
   15444:	10 92 ad 03 	sts	0x03AD, r1
   15448:	08 95       	ret

0001544a <FMenuIdle>:
	     ProcTimeOut++;
	}
	TimSend++;
}

void FMenuIdle(){
   1544a:	1f 93       	push	r17
	static char stMenuIdle=miInit,KeyPressed=0,KeyChar=0,ButtonID=0,PrintStandaloneResult=PS_NONE;
    //static unsigned int iLoopIdle=0;
	char lcdteks[20];
   

	switch(stMenuIdle){
   1544c:	80 91 bc 03 	lds	r24, 0x03BC
   15450:	e8 2f       	mov	r30, r24
   15452:	f0 e0       	ldi	r31, 0x00	; 0
   15454:	e9 31       	cpi	r30, 0x19	; 25
   15456:	f1 05       	cpc	r31, r1
   15458:	08 f0       	brcs	.+2      	; 0x1545c <FMenuIdle+0x12>
   1545a:	a6 c1       	rjmp	.+844    	; 0x157a8 <FMenuIdle+0x35e>
   1545c:	ec 5e       	subi	r30, 0xEC	; 236
   1545e:	fe 4f       	sbci	r31, 0xFE	; 254
   15460:	ee 0f       	add	r30, r30
   15462:	ff 1f       	adc	r31, r31
   15464:	05 90       	lpm	r0, Z+
   15466:	f4 91       	lpm	r31, Z+
   15468:	e0 2d       	mov	r30, r0
   1546a:	09 94       	ijmp
	case miInit:
         _scr_idle();
   1546c:	0e 94 0e 42 	call	0x841c	; 0x841c <_scr_idle>
   15470:	62 c1       	rjmp	.+708    	; 0x15736 <FMenuIdle+0x2ec>
		 stMenuIdle=miScan;		
	     break;
	case miScan:
         //Scan Key Pressed 
		 KeyPressed=_key_scan(1);
   15472:	81 e0       	ldi	r24, 0x01	; 1
   15474:	0e 94 ab ae 	call	0x15d56	; 0x15d56 <_key_scan>
   15478:	80 93 bb 03 	sts	0x03BB, r24
		 KeyChar= _key_btn(KeyPressed);       
   1547c:	0e 94 0c ae 	call	0x15c18	; 0x15c18 <_key_btn>
   15480:	80 93 ba 03 	sts	0x03BA, r24

		 switch(KeyPressed){
   15484:	80 91 bb 03 	lds	r24, 0x03BB
   15488:	8b 3b       	cpi	r24, 0xBB	; 187
   1548a:	09 f4       	brne	.+2      	; 0x1548e <FMenuIdle+0x44>
   1548c:	94 c0       	rjmp	.+296    	; 0x155b6 <FMenuIdle+0x16c>
   1548e:	8c 3b       	cpi	r24, 0xBC	; 188
   15490:	70 f4       	brcc	.+28     	; 0x154ae <FMenuIdle+0x64>
   15492:	8b 37       	cpi	r24, 0x7B	; 123
   15494:	a1 f1       	breq	.+104    	; 0x154fe <FMenuIdle+0xb4>
   15496:	8c 37       	cpi	r24, 0x7C	; 124
   15498:	20 f4       	brcc	.+8      	; 0x154a2 <FMenuIdle+0x58>
   1549a:	87 37       	cpi	r24, 0x77	; 119
   1549c:	09 f0       	breq	.+2      	; 0x154a0 <FMenuIdle+0x56>
   1549e:	84 c1       	rjmp	.+776    	; 0x157a8 <FMenuIdle+0x35e>
   154a0:	38 c0       	rjmp	.+112    	; 0x15512 <FMenuIdle+0xc8>
   154a2:	8d 37       	cpi	r24, 0x7D	; 125
   154a4:	01 f1       	breq	.+64     	; 0x154e6 <FMenuIdle+0x9c>
   154a6:	8e 37       	cpi	r24, 0x7E	; 126
   154a8:	09 f0       	breq	.+2      	; 0x154ac <FMenuIdle+0x62>
   154aa:	7e c1       	rjmp	.+764    	; 0x157a8 <FMenuIdle+0x35e>
   154ac:	12 c0       	rjmp	.+36     	; 0x154d2 <FMenuIdle+0x88>
   154ae:	8d 3d       	cpi	r24, 0xDD	; 221
   154b0:	09 f4       	brne	.+2      	; 0x154b4 <FMenuIdle+0x6a>
   154b2:	63 c0       	rjmp	.+198    	; 0x1557a <FMenuIdle+0x130>
   154b4:	8e 3d       	cpi	r24, 0xDE	; 222
   154b6:	38 f4       	brcc	.+14     	; 0x154c6 <FMenuIdle+0x7c>
   154b8:	8d 3b       	cpi	r24, 0xBD	; 189
   154ba:	09 f4       	brne	.+2      	; 0x154be <FMenuIdle+0x74>
   154bc:	6d c0       	rjmp	.+218    	; 0x15598 <FMenuIdle+0x14e>
   154be:	87 3d       	cpi	r24, 0xD7	; 215
   154c0:	09 f0       	breq	.+2      	; 0x154c4 <FMenuIdle+0x7a>
   154c2:	72 c1       	rjmp	.+740    	; 0x157a8 <FMenuIdle+0x35e>
   154c4:	32 c0       	rjmp	.+100    	; 0x1552a <FMenuIdle+0xe0>
   154c6:	8e 3d       	cpi	r24, 0xDE	; 222
   154c8:	d1 f1       	breq	.+116    	; 0x1553e <FMenuIdle+0xf4>
   154ca:	8d 3e       	cpi	r24, 0xED	; 237
   154cc:	09 f0       	breq	.+2      	; 0x154d0 <FMenuIdle+0x86>
   154ce:	6c c1       	rjmp	.+728    	; 0x157a8 <FMenuIdle+0x35e>
   154d0:	45 c0       	rjmp	.+138    	; 0x1555c <FMenuIdle+0x112>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   154d2:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   154d4:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   154d6:	82 e0       	ldi	r24, 0x02	; 2
   154d8:	90 e0       	ldi	r25, 0x00	; 0
   154da:	90 93 d7 01 	sts	0x01D7, r25
   154de:	80 93 d6 01 	sts	0x01D6, r24
         //Scan Key Pressed 
		 KeyPressed=_key_scan(1);
		 KeyChar= _key_btn(KeyPressed);       

		 switch(KeyPressed){
		 case _KEY_TIKET:system_beep(2);ButtonID=1;stMenuIdle=miDisplayProses;break;
   154e2:	81 e0       	ldi	r24, 0x01	; 1
   154e4:	1f c0       	rjmp	.+62     	; 0x15524 <FMenuIdle+0xda>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   154e6:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   154e8:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   154ea:	82 e0       	ldi	r24, 0x02	; 2
   154ec:	90 e0       	ldi	r25, 0x00	; 0
   154ee:	90 93 d7 01 	sts	0x01D7, r25
   154f2:	80 93 d6 01 	sts	0x01D6, r24
		 KeyPressed=_key_scan(1);
		 KeyChar= _key_btn(KeyPressed);       

		 switch(KeyPressed){
		 case _KEY_TIKET:system_beep(2);ButtonID=1;stMenuIdle=miDisplayProses;break;
		 case _KEY_MENU: system_beep(2);ButtonID=2;stMenuIdle=miDisplayProses;break;
   154f6:	82 e0       	ldi	r24, 0x02	; 2
   154f8:	80 93 b9 03 	sts	0x03B9, r24
   154fc:	53 c1       	rjmp	.+678    	; 0x157a4 <FMenuIdle+0x35a>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   154fe:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   15500:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   15502:	82 e0       	ldi	r24, 0x02	; 2
   15504:	90 e0       	ldi	r25, 0x00	; 0
   15506:	90 93 d7 01 	sts	0x01D7, r25
   1550a:	80 93 d6 01 	sts	0x01D6, r24
		 KeyChar= _key_btn(KeyPressed);       

		 switch(KeyPressed){
		 case _KEY_TIKET:system_beep(2);ButtonID=1;stMenuIdle=miDisplayProses;break;
		 case _KEY_MENU: system_beep(2);ButtonID=2;stMenuIdle=miDisplayProses;break;
		 case _KEY_SHIFT:system_beep(2);ButtonID=3;stMenuIdle=miDisplayProses;break;
   1550e:	83 e0       	ldi	r24, 0x03	; 3
   15510:	09 c0       	rjmp	.+18     	; 0x15524 <FMenuIdle+0xda>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   15512:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   15514:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   15516:	82 e0       	ldi	r24, 0x02	; 2
   15518:	90 e0       	ldi	r25, 0x00	; 0
   1551a:	90 93 d7 01 	sts	0x01D7, r25
   1551e:	80 93 d6 01 	sts	0x01D6, r24

		 switch(KeyPressed){
		 case _KEY_TIKET:system_beep(2);ButtonID=1;stMenuIdle=miDisplayProses;break;
		 case _KEY_MENU: system_beep(2);ButtonID=2;stMenuIdle=miDisplayProses;break;
		 case _KEY_SHIFT:system_beep(2);ButtonID=3;stMenuIdle=miDisplayProses;break;
		 case _KEY_CLEAR:system_beep(2);ButtonID=4;stMenuIdle=miDisplayProses;break;//stMenuIdle=miTestMsg56;break;//miDisplayProses;break;
   15522:	84 e0       	ldi	r24, 0x04	; 4
   15524:	80 93 b9 03 	sts	0x03B9, r24
   15528:	64 c0       	rjmp	.+200    	; 0x155f2 <FMenuIdle+0x1a8>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   1552a:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   1552c:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   1552e:	82 e0       	ldi	r24, 0x02	; 2
   15530:	90 e0       	ldi	r25, 0x00	; 0
   15532:	90 93 d7 01 	sts	0x01D7, r25
   15536:	80 93 d6 01 	sts	0x01D6, r24
		 switch(KeyPressed){
		 case _KEY_TIKET:system_beep(2);ButtonID=1;stMenuIdle=miDisplayProses;break;
		 case _KEY_MENU: system_beep(2);ButtonID=2;stMenuIdle=miDisplayProses;break;
		 case _KEY_SHIFT:system_beep(2);ButtonID=3;stMenuIdle=miDisplayProses;break;
		 case _KEY_CLEAR:system_beep(2);ButtonID=4;stMenuIdle=miDisplayProses;break;//stMenuIdle=miTestMsg56;break;//miDisplayProses;break;
		 case _KEY_0:    system_beep(2);           stMenuIdle=miRunTicket;    break;
   1553a:	8c e0       	ldi	r24, 0x0C	; 12
   1553c:	33 c1       	rjmp	.+614    	; 0x157a4 <FMenuIdle+0x35a>
	   //case _KEY_1:    system_beep(2);           stMenuIdle=miRunTotalizer; break;
		 case _KEY_2: if(IFType==IT_SLAVE) {system_beep(2); stMenuIdle=miRunEDC;}       break;
   1553e:	80 91 10 01 	lds	r24, 0x0110
   15542:	81 30       	cpi	r24, 0x01	; 1
   15544:	09 f0       	breq	.+2      	; 0x15548 <FMenuIdle+0xfe>
   15546:	30 c1       	rjmp	.+608    	; 0x157a8 <FMenuIdle+0x35e>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   15548:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   1554a:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   1554c:	82 e0       	ldi	r24, 0x02	; 2
   1554e:	90 e0       	ldi	r25, 0x00	; 0
   15550:	90 93 d7 01 	sts	0x01D7, r25
   15554:	80 93 d6 01 	sts	0x01D6, r24
		 case _KEY_MENU: system_beep(2);ButtonID=2;stMenuIdle=miDisplayProses;break;
		 case _KEY_SHIFT:system_beep(2);ButtonID=3;stMenuIdle=miDisplayProses;break;
		 case _KEY_CLEAR:system_beep(2);ButtonID=4;stMenuIdle=miDisplayProses;break;//stMenuIdle=miTestMsg56;break;//miDisplayProses;break;
		 case _KEY_0:    system_beep(2);           stMenuIdle=miRunTicket;    break;
	   //case _KEY_1:    system_beep(2);           stMenuIdle=miRunTotalizer; break;
		 case _KEY_2: if(IFType==IT_SLAVE) {system_beep(2); stMenuIdle=miRunEDC;}       break;
   15558:	80 e1       	ldi	r24, 0x10	; 16
   1555a:	24 c1       	rjmp	.+584    	; 0x157a4 <FMenuIdle+0x35a>
	   //case _KEY_3:    system_beep(2);           stMenuIdle=miClearTotalizer;break;
		 case _KEY_4: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunReprint;}   break;
   1555c:	80 91 10 01 	lds	r24, 0x0110
   15560:	81 30       	cpi	r24, 0x01	; 1
   15562:	09 f0       	breq	.+2      	; 0x15566 <FMenuIdle+0x11c>
   15564:	21 c1       	rjmp	.+578    	; 0x157a8 <FMenuIdle+0x35e>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   15566:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   15568:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   1556a:	82 e0       	ldi	r24, 0x02	; 2
   1556c:	90 e0       	ldi	r25, 0x00	; 0
   1556e:	90 93 d7 01 	sts	0x01D7, r25
   15572:	80 93 d6 01 	sts	0x01D6, r24
		 case _KEY_CLEAR:system_beep(2);ButtonID=4;stMenuIdle=miDisplayProses;break;//stMenuIdle=miTestMsg56;break;//miDisplayProses;break;
		 case _KEY_0:    system_beep(2);           stMenuIdle=miRunTicket;    break;
	   //case _KEY_1:    system_beep(2);           stMenuIdle=miRunTotalizer; break;
		 case _KEY_2: if(IFType==IT_SLAVE) {system_beep(2); stMenuIdle=miRunEDC;}       break;
	   //case _KEY_3:    system_beep(2);           stMenuIdle=miClearTotalizer;break;
		 case _KEY_4: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunReprint;}   break;
   15576:	82 e1       	ldi	r24, 0x12	; 18
   15578:	15 c1       	rjmp	.+554    	; 0x157a4 <FMenuIdle+0x35a>
		 case _KEY_5: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunLoyalty;}   break;
   1557a:	80 91 10 01 	lds	r24, 0x0110
   1557e:	81 30       	cpi	r24, 0x01	; 1
   15580:	09 f0       	breq	.+2      	; 0x15584 <FMenuIdle+0x13a>
   15582:	12 c1       	rjmp	.+548    	; 0x157a8 <FMenuIdle+0x35e>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   15584:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   15586:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   15588:	82 e0       	ldi	r24, 0x02	; 2
   1558a:	90 e0       	ldi	r25, 0x00	; 0
   1558c:	90 93 d7 01 	sts	0x01D7, r25
   15590:	80 93 d6 01 	sts	0x01D6, r24
		 case _KEY_0:    system_beep(2);           stMenuIdle=miRunTicket;    break;
	   //case _KEY_1:    system_beep(2);           stMenuIdle=miRunTotalizer; break;
		 case _KEY_2: if(IFType==IT_SLAVE) {system_beep(2); stMenuIdle=miRunEDC;}       break;
	   //case _KEY_3:    system_beep(2);           stMenuIdle=miClearTotalizer;break;
		 case _KEY_4: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunReprint;}   break;
		 case _KEY_5: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunLoyalty;}   break;
   15594:	81 e1       	ldi	r24, 0x11	; 17
   15596:	06 c1       	rjmp	.+524    	; 0x157a4 <FMenuIdle+0x35a>
		 case _KEY_6: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunChangeMOP;} break;
   15598:	80 91 10 01 	lds	r24, 0x0110
   1559c:	81 30       	cpi	r24, 0x01	; 1
   1559e:	09 f0       	breq	.+2      	; 0x155a2 <FMenuIdle+0x158>
   155a0:	03 c1       	rjmp	.+518    	; 0x157a8 <FMenuIdle+0x35e>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   155a2:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   155a4:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   155a6:	82 e0       	ldi	r24, 0x02	; 2
   155a8:	90 e0       	ldi	r25, 0x00	; 0
   155aa:	90 93 d7 01 	sts	0x01D7, r25
   155ae:	80 93 d6 01 	sts	0x01D6, r24
	   //case _KEY_1:    system_beep(2);           stMenuIdle=miRunTotalizer; break;
		 case _KEY_2: if(IFType==IT_SLAVE) {system_beep(2); stMenuIdle=miRunEDC;}       break;
	   //case _KEY_3:    system_beep(2);           stMenuIdle=miClearTotalizer;break;
		 case _KEY_4: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunReprint;}   break;
		 case _KEY_5: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunLoyalty;}   break;
		 case _KEY_6: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunChangeMOP;} break;
   155b2:	8f e0       	ldi	r24, 0x0F	; 15
   155b4:	f7 c0       	rjmp	.+494    	; 0x157a4 <FMenuIdle+0x35a>
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   155b6:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   155b8:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   155ba:	82 e0       	ldi	r24, 0x02	; 2
   155bc:	90 e0       	ldi	r25, 0x00	; 0
   155be:	90 93 d7 01 	sts	0x01D7, r25
   155c2:	80 93 d6 01 	sts	0x01D6, r24
	   //case _KEY_3:    system_beep(2);           stMenuIdle=miClearTotalizer;break;
		 case _KEY_4: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunReprint;}   break;
		 case _KEY_5: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunLoyalty;}   break;
		 case _KEY_6: if(IFType==IT_SLAVE) {system_beep(2);stMenuIdle=miRunChangeMOP;} break;
		 //case _KEY_8:    system_beep(2);           stMenuIdle=miRunTestChar;   break;
		 case _KEY_9:    system_beep(2);stMenuIdle=miRunAuth;      break;
   155c6:	8d e0       	ldi	r24, 0x0D	; 13
   155c8:	ed c0       	rjmp	.+474    	; 0x157a4 <FMenuIdle+0x35a>
		 }
	     break;
    case miTestMsg56:
	     sprintf_P(strCardID,PSTR("4356A31A"));
   155ca:	00 d0       	rcall	.+0      	; 0x155cc <FMenuIdle+0x182>
   155cc:	00 d0       	rcall	.+0      	; 0x155ce <FMenuIdle+0x184>
   155ce:	81 e6       	ldi	r24, 0x61	; 97
   155d0:	9d e0       	ldi	r25, 0x0D	; 13
   155d2:	ed b7       	in	r30, 0x3d	; 61
   155d4:	fe b7       	in	r31, 0x3e	; 62
   155d6:	92 83       	std	Z+2, r25	; 0x02
   155d8:	81 83       	std	Z+1, r24	; 0x01
   155da:	8c e9       	ldi	r24, 0x9C	; 156
   155dc:	93 e2       	ldi	r25, 0x23	; 35
   155de:	94 83       	std	Z+4, r25	; 0x04
   155e0:	83 83       	std	Z+3, r24	; 0x03
   155e2:	0e 94 5f b4 	call	0x168be	; 0x168be <sprintf_P>
	     sendMessage56();
   155e6:	0f 90       	pop	r0
   155e8:	0f 90       	pop	r0
   155ea:	0f 90       	pop	r0
   155ec:	0f 90       	pop	r0
   155ee:	0e 94 02 9b 	call	0x13604	; 0x13604 <sendMessage56>
         stMenuIdle=miDisplayProses;
   155f2:	82 e0       	ldi	r24, 0x02	; 2
   155f4:	d7 c0       	rjmp	.+430    	; 0x157a4 <FMenuIdle+0x35a>
	     break;
	case miDisplayProses:
	     if (IsBusyIdlePrinting==False){
   155f6:	80 91 c8 01 	lds	r24, 0x01C8
   155fa:	88 23       	and	r24, r24
   155fc:	09 f0       	breq	.+2      	; 0x15600 <FMenuIdle+0x1b6>
   155fe:	9b c0       	rjmp	.+310    	; 0x15736 <FMenuIdle+0x2ec>
		     lcd_printf(3,1,PSTR("SedangProses"));
   15600:	83 e0       	ldi	r24, 0x03	; 3
   15602:	61 e0       	ldi	r22, 0x01	; 1
   15604:	4f e8       	ldi	r20, 0x8F	; 143
   15606:	53 e2       	ldi	r21, 0x23	; 35
   15608:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
	         TimDisplay=0;
   1560c:	10 92 a7 01 	sts	0x01A7, r1
			 stMenuIdle=miWaitProses;
   15610:	83 e0       	ldi	r24, 0x03	; 3
   15612:	c8 c0       	rjmp	.+400    	; 0x157a4 <FMenuIdle+0x35a>
         }else stMenuIdle=miScan;
	     break;
    case miWaitProses:
	     if (TimDisplay>1){
   15614:	80 91 a7 01 	lds	r24, 0x01A7
   15618:	82 30       	cpi	r24, 0x02	; 2
   1561a:	08 f4       	brcc	.+2      	; 0x1561e <FMenuIdle+0x1d4>
   1561c:	c5 c0       	rjmp	.+394    	; 0x157a8 <FMenuIdle+0x35e>
		     if (IFType==IT_SLAVE)stMenuIdle=miSendMessage98;
   1561e:	80 91 10 01 	lds	r24, 0x0110
   15622:	81 30       	cpi	r24, 0x01	; 1
   15624:	11 f4       	brne	.+4      	; 0x1562a <FMenuIdle+0x1e0>
   15626:	84 e0       	ldi	r24, 0x04	; 4
   15628:	bd c0       	rjmp	.+378    	; 0x157a4 <FMenuIdle+0x35a>
			 else
		     if (IFType==IT_STANDALONE)stMenuIdle=miPrintStandalone;
   1562a:	82 30       	cpi	r24, 0x02	; 2
   1562c:	09 f0       	breq	.+2      	; 0x15630 <FMenuIdle+0x1e6>
   1562e:	bc c0       	rjmp	.+376    	; 0x157a8 <FMenuIdle+0x35e>
   15630:	87 e0       	ldi	r24, 0x07	; 7
   15632:	b8 c0       	rjmp	.+368    	; 0x157a4 <FMenuIdle+0x35a>
		 }
	     break;
    case miPrintStandalone:
	     PrintStandaloneResult=PrintStandalone(ButtonID,False);
   15634:	80 91 b9 03 	lds	r24, 0x03B9
   15638:	60 e0       	ldi	r22, 0x00	; 0
   1563a:	0e 94 bb 1f 	call	0x3f76	; 0x3f76 <PrintStandalone>
   1563e:	80 93 5d 01 	sts	0x015D, r24
	     if (PrintStandaloneResult==PS_PRINTED)stMenuIdle=miReady;
   15642:	81 31       	cpi	r24, 0x11	; 17
   15644:	09 f4       	brne	.+2      	; 0x15648 <FMenuIdle+0x1fe>
   15646:	ad c0       	rjmp	.+346    	; 0x157a2 <FMenuIdle+0x358>
		 else
		 if (PrintStandaloneResult==PS_NO_DATA)stMenuIdle=miDisplayNoTransaction;
   15648:	82 31       	cpi	r24, 0x12	; 18
   1564a:	09 f0       	breq	.+2      	; 0x1564e <FMenuIdle+0x204>
   1564c:	ad c0       	rjmp	.+346    	; 0x157a8 <FMenuIdle+0x35e>
   1564e:	88 e0       	ldi	r24, 0x08	; 8
   15650:	a9 c0       	rjmp	.+338    	; 0x157a4 <FMenuIdle+0x35a>
	     break;
    case miDisplayNoTransaction:
	     lcd_printf(3, 1,PSTR("Tidak Ada Transaksi "));
   15652:	83 e0       	ldi	r24, 0x03	; 3
   15654:	61 e0       	ldi	r22, 0x01	; 1
   15656:	4a e7       	ldi	r20, 0x7A	; 122
   15658:	53 e2       	ldi	r21, 0x23	; 35
   1565a:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
         TimDisplay=0;
   1565e:	10 92 a7 01 	sts	0x01A7, r1
		 stMenuIdle=miWaitDisplayNoTransaction;
   15662:	89 e0       	ldi	r24, 0x09	; 9
   15664:	9f c0       	rjmp	.+318    	; 0x157a4 <FMenuIdle+0x35a>
	     break;
    case miWaitDisplayNoTransaction:
	     if (TimDisplay>1){
   15666:	80 91 a7 01 	lds	r24, 0x01A7
   1566a:	82 30       	cpi	r24, 0x02	; 2
   1566c:	08 f4       	brcc	.+2      	; 0x15670 <FMenuIdle+0x226>
   1566e:	9c c0       	rjmp	.+312    	; 0x157a8 <FMenuIdle+0x35e>
	         lcd_printf(3,1,PSTR("Ready...            "));
   15670:	83 e0       	ldi	r24, 0x03	; 3
   15672:	61 e0       	ldi	r22, 0x01	; 1
   15674:	45 e6       	ldi	r20, 0x65	; 101
   15676:	53 e2       	ldi	r21, 0x23	; 35
   15678:	36 c0       	rjmp	.+108    	; 0x156e6 <FMenuIdle+0x29c>
		     stMenuIdle=miWaitReady;
			 TimDisplay=0;
		 }
	     break;
    case miSendMessage98:
	     lcd_printf(3,1,PSTR("Please Wait..       "));
   1567a:	83 e0       	ldi	r24, 0x03	; 3
   1567c:	61 e0       	ldi	r22, 0x01	; 1
   1567e:	40 e5       	ldi	r20, 0x50	; 80
   15680:	53 e2       	ldi	r21, 0x23	; 35
   15682:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
	     sendMessage98(ButtonID);
   15686:	80 91 b9 03 	lds	r24, 0x03B9
   1568a:	0e 94 84 4c 	call	0x9908	; 0x9908 <sendMessage98>
		 ProcTimeOut=0;
   1568e:	10 92 d9 01 	sts	0x01D9, r1
   15692:	10 92 d8 01 	sts	0x01D8, r1
		 stMenuIdle=miWaitPlease;
   15696:	85 e0       	ldi	r24, 0x05	; 5
   15698:	85 c0       	rjmp	.+266    	; 0x157a4 <FMenuIdle+0x35a>
	     break;
    case miWaitPlease:
         if (ProcTimeOut>TIM_NO_RESPONSE){
   1569a:	80 91 d8 01 	lds	r24, 0x01D8
   1569e:	90 91 d9 01 	lds	r25, 0x01D9
   156a2:	0f 97       	sbiw	r24, 0x0f	; 15
   156a4:	58 f0       	brcs	.+22     	; 0x156bc <FMenuIdle+0x272>
	         lcd_printf(3,1,PSTR("No Response..       "));
   156a6:	83 e0       	ldi	r24, 0x03	; 3
   156a8:	61 e0       	ldi	r22, 0x01	; 1
   156aa:	4b e3       	ldi	r20, 0x3B	; 59
   156ac:	53 e2       	ldi	r21, 0x23	; 35
   156ae:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		     stMenuIdle=miNoResponse;
   156b2:	86 e0       	ldi	r24, 0x06	; 6
   156b4:	80 93 bc 03 	sts	0x03BC, r24
			 TimDisplay=0;		 
   156b8:	10 92 a7 01 	sts	0x01A7, r1
		 }
		 if ((IsMessage99==True)||(IsMessage00==True)){
   156bc:	80 91 b6 01 	lds	r24, 0x01B6
   156c0:	81 30       	cpi	r24, 0x01	; 1
   156c2:	29 f0       	breq	.+10     	; 0x156ce <FMenuIdle+0x284>
   156c4:	80 91 b5 01 	lds	r24, 0x01B5
   156c8:	81 30       	cpi	r24, 0x01	; 1
   156ca:	09 f0       	breq	.+2      	; 0x156ce <FMenuIdle+0x284>
   156cc:	6d c0       	rjmp	.+218    	; 0x157a8 <FMenuIdle+0x35e>
		     ClearMem(strOdometer);
   156ce:	83 ea       	ldi	r24, 0xA3	; 163
   156d0:	95 e0       	ldi	r25, 0x05	; 5
   156d2:	0e 94 a6 ad 	call	0x15b4c	; 0x15b4c <ClearMem>
		     ClearMem(strLicPlate);
   156d6:	82 ed       	ldi	r24, 0xD2	; 210
   156d8:	9a e0       	ldi	r25, 0x0A	; 10
   156da:	0e 94 a6 ad 	call	0x15b4c	; 0x15b4c <ClearMem>
	         lcd_printf(3,1,PSTR("Ready...            "));
   156de:	83 e0       	ldi	r24, 0x03	; 3
   156e0:	61 e0       	ldi	r22, 0x01	; 1
   156e2:	46 e2       	ldi	r20, 0x26	; 38
   156e4:	53 e2       	ldi	r21, 0x23	; 35
   156e6:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		     stMenuIdle=miWaitReady;
   156ea:	8a e0       	ldi	r24, 0x0A	; 10
   156ec:	80 93 bc 03 	sts	0x03BC, r24
			 TimDisplay=0;
   156f0:	10 92 a7 01 	sts	0x01A7, r1
   156f4:	59 c0       	rjmp	.+178    	; 0x157a8 <FMenuIdle+0x35e>
			 }
	     break;
    case miNoResponse:
         if (TimDisplay>1){
   156f6:	80 91 a7 01 	lds	r24, 0x01A7
   156fa:	82 30       	cpi	r24, 0x02	; 2
   156fc:	08 f4       	brcc	.+2      	; 0x15700 <FMenuIdle+0x2b6>
   156fe:	54 c0       	rjmp	.+168    	; 0x157a8 <FMenuIdle+0x35e>
	         lcd_printf(3,1,PSTR("Ready...            "));
   15700:	83 e0       	ldi	r24, 0x03	; 3
   15702:	61 e0       	ldi	r22, 0x01	; 1
   15704:	41 e1       	ldi	r20, 0x11	; 17
   15706:	53 e2       	ldi	r21, 0x23	; 35
   15708:	ee cf       	rjmp	.-36     	; 0x156e6 <FMenuIdle+0x29c>
		     stMenuIdle=miWaitReady;
			 TimDisplay=0;
			 }	     
	     break;
    case miWaitReady:
         if (TimDisplay>1){
   1570a:	80 91 a7 01 	lds	r24, 0x01A7
   1570e:	82 30       	cpi	r24, 0x02	; 2
   15710:	08 f4       	brcc	.+2      	; 0x15714 <FMenuIdle+0x2ca>
   15712:	4a c0       	rjmp	.+148    	; 0x157a8 <FMenuIdle+0x35e>
	         lcd_printf(3,1,PSTR("                "));
   15714:	83 e0       	ldi	r24, 0x03	; 3
   15716:	61 e0       	ldi	r22, 0x01	; 1
   15718:	40 e0       	ldi	r20, 0x00	; 0
   1571a:	53 e2       	ldi	r21, 0x23	; 35
   1571c:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		     stMenuIdle=miReady;
   15720:	8b e0       	ldi	r24, 0x0B	; 11
   15722:	e4 cf       	rjmp	.-56     	; 0x156ec <FMenuIdle+0x2a2>
			 TimDisplay=0;
			 }	     
	     break;
    case miReady:
	     _scr_idle();
   15724:	0e 94 0e 42 	call	0x841c	; 0x841c <_scr_idle>
		 if (IFType==IT_STANDALONE)IsNewPumpStatus=True;
   15728:	80 91 10 01 	lds	r24, 0x0110
   1572c:	82 30       	cpi	r24, 0x02	; 2
   1572e:	19 f4       	brne	.+6      	; 0x15736 <FMenuIdle+0x2ec>
   15730:	81 e0       	ldi	r24, 0x01	; 1
   15732:	80 93 11 01 	sts	0x0111, r24
		 stMenuIdle=miScan;
   15736:	81 e0       	ldi	r24, 0x01	; 1
   15738:	35 c0       	rjmp	.+106    	; 0x157a4 <FMenuIdle+0x35a>
	     break;
	case miRunTicket://Slave,Standalone
		 if (FMenuTicket()==MENU_DONE)
   1573a:	0e 94 50 84 	call	0x108a0	; 0x108a0 <FMenuTicket>
   1573e:	2f c0       	rjmp	.+94     	; 0x1579e <FMenuIdle+0x354>
		     stMenuIdle=miReady;
	     break;
	case miRunAuth://Slave,Standalone
		 if (FMenuAuthorization()==MENU_DONE)
   15740:	0e 94 13 9a 	call	0x13426	; 0x13426 <FMenuAuthorization>
   15744:	2c c0       	rjmp	.+88     	; 0x1579e <FMenuIdle+0x354>
		     stMenuIdle=miReady;
	     break;
		 
    case miRunLocalAccount://Slave
		 if (FMenuLocalAccount()==MENU_DONE)
   15746:	0e 94 ac 9b 	call	0x13758	; 0x13758 <FMenuLocalAccount>
   1574a:	29 c0       	rjmp	.+82     	; 0x1579e <FMenuIdle+0x354>
		     stMenuIdle=miReady;
	     break;  
    case miRunChangeMOP://Slave
	     if (FMenuChangeMOP()==MENU_DONE)
   1574c:	0e 94 17 93 	call	0x1262e	; 0x1262e <FMenuChangeMOP>
   15750:	26 c0       	rjmp	.+76     	; 0x1579e <FMenuIdle+0x354>
		     stMenuIdle=miReady;
	     break;
    case miRunEDC://Slave
	     if (FMenuEDCTransaction()==MENU_DONE)
   15752:	0e 94 27 65 	call	0xca4e	; 0xca4e <FMenuEDCTransaction>
   15756:	23 c0       	rjmp	.+70     	; 0x1579e <FMenuIdle+0x354>
		     stMenuIdle=miReady;
         break;
    case miRunLoyalty://Slave
	     if (FMenuLoyalty()==MENU_DONE)
   15758:	0e 94 1b 66 	call	0xcc36	; 0xcc36 <FMenuLoyalty>
   1575c:	20 c0       	rjmp	.+64     	; 0x1579e <FMenuIdle+0x354>
		     stMenuIdle=miReady;
	     break;
    case miRunReprint://Slave,Standalone
	     if (FMenuReprint()==MENU_DONE)
   1575e:	0e 94 6c 91 	call	0x122d8	; 0x122d8 <FMenuReprint>
   15762:	1d c0       	rjmp	.+58     	; 0x1579e <FMenuIdle+0x354>
		     stMenuIdle=miReady;
	     break;
    case miRunViewFreeMessage://Slave
	     if (FViewFreeMessage()==MENU_DONE)
   15764:	0e 94 d4 41 	call	0x83a8	; 0x83a8 <FViewFreeMessage>
   15768:	1a c0       	rjmp	.+52     	; 0x1579e <FMenuIdle+0x354>
		     stMenuIdle=miReady;
	     break;
    case miClearTotalizer://Standalone
	     lcd_printf(3,1,PSTR("Clear Data Totalizer"));
   1576a:	83 e0       	ldi	r24, 0x03	; 3
   1576c:	61 e0       	ldi	r22, 0x01	; 1
   1576e:	4b ee       	ldi	r20, 0xEB	; 235
   15770:	52 e2       	ldi	r21, 0x22	; 34
   15772:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
	     ResetTotalizer(TOTALIZER_LAST);
   15776:	80 e0       	ldi	r24, 0x00	; 0
   15778:	0e 94 f6 45 	call	0x8bec	; 0x8bec <ResetTotalizer>
         ResetTotalizer(TOTALIZER_NOW);
   1577c:	81 e0       	ldi	r24, 0x01	; 1
   1577e:	0e 94 f6 45 	call	0x8bec	; 0x8bec <ResetTotalizer>
   15782:	0f c0       	rjmp	.+30     	; 0x157a2 <FMenuIdle+0x358>
         stMenuIdle=miReady;	      
	     break;
    case miRunTotalizer://Standalone
	     lcd_printf(3,1,PSTR("TotalizerAll     "));
   15784:	83 e0       	ldi	r24, 0x03	; 3
   15786:	61 e0       	ldi	r22, 0x01	; 1
   15788:	49 ed       	ldi	r20, 0xD9	; 217
   1578a:	52 e2       	ldi	r21, 0x22	; 34
   1578c:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
	     SendSlaveCommand(SC_TOTALIZER,PUMP_ALL);
   15790:	85 e0       	ldi	r24, 0x05	; 5
   15792:	62 e1       	ldi	r22, 0x12	; 18
   15794:	0e 94 83 72 	call	0xe506	; 0xe506 <SendSlaveCommand>
   15798:	04 c0       	rjmp	.+8      	; 0x157a2 <FMenuIdle+0x358>
		 stMenuIdle=miReady;	      
	     break;
    case miRunTestChar:	     
 	     if (FTestChar()==MENU_DONE)
   1579a:	0e 94 17 41 	call	0x822e	; 0x822e <FTestChar>
   1579e:	81 30       	cpi	r24, 0x01	; 1
   157a0:	19 f4       	brne	.+6      	; 0x157a8 <FMenuIdle+0x35e>
         stMenuIdle=miReady;
   157a2:	8b e0       	ldi	r24, 0x0B	; 11
   157a4:	80 93 bc 03 	sts	0x03BC, r24
	     break;
	}
//----------SYSTEM_PROC--------------------------------

        //Bank InfoUpdated
        if (IsMessage21==True){
   157a8:	80 91 b8 01 	lds	r24, 0x01B8
   157ac:	81 30       	cpi	r24, 0x01	; 1
   157ae:	21 f4       	brne	.+8      	; 0x157b8 <FMenuIdle+0x36e>
		    IsMessage21=False;
   157b0:	10 92 b8 01 	sts	0x01B8, r1
			procMessage21();
   157b4:	0e 94 4e 46 	call	0x8c9c	; 0x8c9c <procMessage21>

        }
        //Transaction Status
        if (IsMessage00==True){
   157b8:	80 91 b5 01 	lds	r24, 0x01B5
   157bc:	81 30       	cpi	r24, 0x01	; 1
   157be:	91 f4       	brne	.+36     	; 0x157e4 <FMenuIdle+0x39a>
		    IsMessage00=False;
   157c0:	10 92 b5 01 	sts	0x01B5, r1
*/
char procMessage00(){
     char Result,strSend[10];
	 Result=MSG00_NACK;
	 //Message57
	 if((rcv_trans[0]==0x01)&&(transLength==MSG00_LENGTH)){
   157c4:	20 91 f5 0a 	lds	r18, 0x0AF5
   157c8:	21 30       	cpi	r18, 0x01	; 1
   157ca:	61 f4       	brne	.+24     	; 0x157e4 <FMenuIdle+0x39a>
   157cc:	80 91 9e 01 	lds	r24, 0x019E
   157d0:	90 91 9f 01 	lds	r25, 0x019F
   157d4:	8f 97       	sbiw	r24, 0x2f	; 47
   157d6:	31 f4       	brne	.+12     	; 0x157e4 <FMenuIdle+0x39a>

        }
        //Transaction Status
        if (IsMessage00==True){
		    IsMessage00=False;
			if (procMessage00()==MSG00_NO_PRINT){
   157d8:	80 91 1a 0b 	lds	r24, 0x0B1A
   157dc:	84 33       	cpi	r24, 0x34	; 52
   157de:	11 f4       	brne	.+4      	; 0x157e4 <FMenuIdle+0x39a>
			    IsNoTransaction=True;
   157e0:	20 93 c2 01 	sts	0x01C2, r18
				}
		}
  
		//Send EDC Message Information;
		if (IsSendMessageEDC==True){
   157e4:	80 91 ae 01 	lds	r24, 0x01AE
   157e8:	81 30       	cpi	r24, 0x01	; 1
   157ea:	21 f4       	brne	.+8      	; 0x157f4 <FMenuIdle+0x3aa>
		    IsSendMessageEDC=False;
   157ec:	10 92 ae 01 	sts	0x01AE, r1
			SendEDCMessage();
   157f0:	0e 94 fe 71 	call	0xe3fc	; 0xe3fc <SendEDCMessage>
		}
		if (IsEDCApproved==True){
   157f4:	80 91 b0 01 	lds	r24, 0x01B0
   157f8:	81 30       	cpi	r24, 0x01	; 1
   157fa:	21 f4       	brne	.+8      	; 0x15804 <FMenuIdle+0x3ba>
		    IsEDCApproved=False;
   157fc:	10 92 b0 01 	sts	0x01B0, r1
            sendMessage92();
   15800:	0e 94 ac 4d 	call	0x9b58	; 0x9b58 <sendMessage92>
		}
		if (IsVoidTransaction==True){
   15804:	80 91 b2 01 	lds	r24, 0x01B2
   15808:	81 30       	cpi	r24, 0x01	; 1
   1580a:	21 f4       	brne	.+8      	; 0x15814 <FMenuIdle+0x3ca>
		    IsVoidTransaction=False;
   1580c:	10 92 b2 01 	sts	0x01B2, r1
            sendMessage94();
   15810:	0e 94 05 4d 	call	0x9a0a	; 0x9a0a <sendMessage94>
		}


        //Message99 Detection 
        if (IsMessage99==True){
   15814:	10 91 b6 01 	lds	r17, 0x01B6
   15818:	11 30       	cpi	r17, 0x01	; 1
   1581a:	31 f4       	brne	.+12     	; 0x15828 <FMenuIdle+0x3de>
	        IsMessage99=False;
   1581c:	10 92 b6 01 	sts	0x01B6, r1
		    procMessage99();
   15820:	0e 94 bf 3e 	call	0x7d7e	; 0x7d7e <procMessage99>
		    IsPrinting=True;
   15824:	10 93 c3 01 	sts	0x01C3, r17
		}
		//No Transaction
		if (IsNoTransaction==True){
   15828:	80 91 c2 01 	lds	r24, 0x01C2
   1582c:	81 30       	cpi	r24, 0x01	; 1
   1582e:	41 f4       	brne	.+16     	; 0x15840 <FMenuIdle+0x3f6>
			IsNoTransaction=False;
   15830:	10 92 c2 01 	sts	0x01C2, r1
			lcd_printf(3, 1,PSTR("Tidak Ada Transaksi "));
   15834:	83 e0       	ldi	r24, 0x03	; 3
   15836:	61 e0       	ldi	r22, 0x01	; 1
   15838:	44 ec       	ldi	r20, 0xC4	; 196
   1583a:	52 e2       	ldi	r21, 0x22	; 34
   1583c:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
		}
        
		//Display Idle
		if (stMenuIdle==miScan){//||(stMenuIdle=miWaitPlease)){ 
   15840:	80 91 bc 03 	lds	r24, 0x03BC
   15844:	81 30       	cpi	r24, 0x01	; 1
   15846:	11 f4       	brne	.+4      	; 0x1584c <FMenuIdle+0x402>
		    DisplayIdle();			
   15848:	0e 94 92 70 	call	0xe124	; 0xe124 <DisplayIdle>
			}        

        //Display FreeMessage
		if (stMenuIdle==miScan){ 
   1584c:	80 91 bc 03 	lds	r24, 0x03BC
   15850:	81 30       	cpi	r24, 0x01	; 1
   15852:	59 f4       	brne	.+22     	; 0x1586a <FMenuIdle+0x420>
		    if (IsMessage09==True){
   15854:	80 91 ba 01 	lds	r24, 0x01BA
   15858:	81 30       	cpi	r24, 0x01	; 1
   1585a:	39 f4       	brne	.+14     	; 0x1586a <FMenuIdle+0x420>
			    IsMessage09=False;
   1585c:	10 92 ba 01 	sts	0x01BA, r1
				procMessage09();
   15860:	0e 94 56 17 	call	0x2eac	; 0x2eac <procMessage09>
				stMenuIdle=miRunViewFreeMessage;
   15864:	83 e1       	ldi	r24, 0x13	; 19
   15866:	80 93 bc 03 	sts	0x03BC, r24
			   }
			}

        //LocalAccount Scanning
		if ((stMenuIdle==miScan)&&(IsRFIDDetected==True)){
   1586a:	80 91 bc 03 	lds	r24, 0x03BC
   1586e:	81 30       	cpi	r24, 0x01	; 1
   15870:	89 f4       	brne	.+34     	; 0x15894 <FMenuIdle+0x44a>
   15872:	80 91 af 01 	lds	r24, 0x01AF
   15876:	81 30       	cpi	r24, 0x01	; 1
   15878:	69 f4       	brne	.+26     	; 0x15894 <FMenuIdle+0x44a>
		    IsRFIDDetected=False;
   1587a:	10 92 af 01 	sts	0x01AF, r1
	//_uart(1,1,_spi(dataTX1)); //Testing SPI
}


void system_beep(unsigned int tBeep){
      DDRB= (DDRB|0b00100000);
   1587e:	bd 9a       	sbi	0x17, 5	; 23
	 PORTB=(PORTB&0b11011111);
   15880:	c5 98       	cbi	0x18, 5	; 24
	 TimBeep=tBeep;
   15882:	82 e0       	ldi	r24, 0x02	; 2
   15884:	90 e0       	ldi	r25, 0x00	; 0
   15886:	90 93 d7 01 	sts	0x01D7, r25
   1588a:	80 93 d6 01 	sts	0x01D6, r24

        //LocalAccount Scanning
		if ((stMenuIdle==miScan)&&(IsRFIDDetected==True)){
		    IsRFIDDetected=False;
		    system_beep(2);           
			stMenuIdle=miRunLocalAccount;
   1588e:	8e e0       	ldi	r24, 0x0E	; 14
   15890:	80 93 bc 03 	sts	0x03BC, r24
		}
        //Print Spooling
		if (IsMessage81==True){
   15894:	10 91 bd 01 	lds	r17, 0x01BD
   15898:	11 30       	cpi	r17, 0x01	; 1
   1589a:	41 f4       	brne	.+16     	; 0x158ac <FMenuIdle+0x462>
		    IsMessage81=False;
   1589c:	10 92 bd 01 	sts	0x01BD, r1
			//Spooling HFCS 0000 : Header, Footer, Copy , Scrool [Copy:16x max]
			cmdPrint=procMessage81();
   158a0:	0e 94 33 18 	call	0x3066	; 0x3066 <procMessage81>
   158a4:	80 93 cb 01 	sts	0x01CB, r24
			IsFreePrinting=True;
   158a8:	10 93 bf 01 	sts	0x01BF, r17
         }

    //SystemService
      systemGenerateReport();
   158ac:	0e 94 ba 31 	call	0x6374	; 0x6374 <systemGenerateReport>
      systemPrinting();
   158b0:	0e 94 05 5d 	call	0xba0a	; 0xba0a <systemPrinting>
	  systemEDC();
	  systemConfigProtocol();
   158b4:	0e 94 ff a9 	call	0x153fe	; 0x153fe <systemConfigProtocol>
	  //systemGeniusProtocol(); //AKR-->Protocol disabled
}
   158b8:	1f 91       	pop	r17
   158ba:	08 95       	ret

000158bc <lcd_command>:
	lcd_command(0x0c);
	lcd_command(0x06);
}

void lcd_command(unsigned char __chr){
	_LCD_PORT = __chr & 0xF0;
   158bc:	98 2f       	mov	r25, r24
   158be:	90 7f       	andi	r25, 0xF0	; 240
   158c0:	95 bb       	out	0x15, r25	; 21
	cbi(_LCD_PORT, _LCD_RS);
   158c2:	ab 98       	cbi	0x15, 3	; 21
	sbi(_LCD_PORT, _LCD_E);
   158c4:	a9 9a       	sbi	0x15, 1	; 21
   158c6:	48 ee       	ldi	r20, 0xE8	; 232
   158c8:	53 e0       	ldi	r21, 0x03	; 3
   158ca:	fa 01       	movw	r30, r20
   158cc:	31 97       	sbiw	r30, 0x01	; 1
   158ce:	f1 f7       	brne	.-4      	; 0x158cc <lcd_command+0x10>
	_LCD_BUSY;
	cbi(_LCD_PORT, _LCD_E);
   158d0:	a9 98       	cbi	0x15, 1	; 21
   158d2:	fa 01       	movw	r30, r20
   158d4:	31 97       	sbiw	r30, 0x01	; 1
   158d6:	f1 f7       	brne	.-4      	; 0x158d4 <lcd_command+0x18>
	_LCD_BUSY;

	_LCD_PORT = (__chr & 0x0F) << 4;
   158d8:	28 2f       	mov	r18, r24
   158da:	30 e0       	ldi	r19, 0x00	; 0
   158dc:	94 e0       	ldi	r25, 0x04	; 4
   158de:	22 0f       	add	r18, r18
   158e0:	33 1f       	adc	r19, r19
   158e2:	9a 95       	dec	r25
   158e4:	e1 f7       	brne	.-8      	; 0x158de <lcd_command+0x22>
   158e6:	25 bb       	out	0x15, r18	; 21
	cbi(_LCD_PORT, _LCD_RS);
   158e8:	ab 98       	cbi	0x15, 3	; 21
	sbi(_LCD_PORT, _LCD_E);
   158ea:	a9 9a       	sbi	0x15, 1	; 21
   158ec:	fa 01       	movw	r30, r20
   158ee:	31 97       	sbiw	r30, 0x01	; 1
   158f0:	f1 f7       	brne	.-4      	; 0x158ee <lcd_command+0x32>
	_LCD_BUSY;
	cbi(_LCD_PORT, _LCD_E);
   158f2:	a9 98       	cbi	0x15, 1	; 21
   158f4:	fa 01       	movw	r30, r20
   158f6:	31 97       	sbiw	r30, 0x01	; 1
   158f8:	f1 f7       	brne	.-4      	; 0x158f6 <lcd_command+0x3a>
	_LCD_BUSY;
	_LCD_BUSY;
	if (__chr==0x01) _delay_ms(50);
   158fa:	fa 01       	movw	r30, r20
   158fc:	31 97       	sbiw	r30, 0x01	; 1
   158fe:	f1 f7       	brne	.-4      	; 0x158fc <lcd_command+0x40>
   15900:	81 30       	cpi	r24, 0x01	; 1
   15902:	21 f4       	brne	.+8      	; 0x1590c <lcd_command+0x50>
   15904:	84 ed       	ldi	r24, 0xD4	; 212
   15906:	90 e3       	ldi	r25, 0x30	; 48
   15908:	01 97       	sbiw	r24, 0x01	; 1
   1590a:	f1 f7       	brne	.-4      	; 0x15908 <lcd_command+0x4c>
   1590c:	08 95       	ret

0001590e <lcd_init>:
   1590e:	86 ea       	ldi	r24, 0xA6	; 166
   15910:	9e e0       	ldi	r25, 0x0E	; 14
   15912:	01 97       	sbiw	r24, 0x01	; 1
   15914:	f1 f7       	brne	.-4      	; 0x15912 <lcd_init+0x4>

#define _LCD_BUSY	_delay_ms(4);

void lcd_init(void){
	_delay_ms(15);
	_LCD_PORT = 0x00;
   15916:	15 ba       	out	0x15, r1	; 21
	_LCD_DDR |= (1 << _LCD_D7) | (1 << _LCD_D6) | (1 << _LCD_D5) | (1 << _LCD_D4);
   15918:	84 b3       	in	r24, 0x14	; 20
   1591a:	80 6f       	ori	r24, 0xF0	; 240
   1591c:	84 bb       	out	0x14, r24	; 20
	_LCD_DDR |= (1 << _LCD_E) | (1 << _LCD_RW) | (1 << _LCD_RS);
   1591e:	84 b3       	in	r24, 0x14	; 20
   15920:	8e 60       	ori	r24, 0x0E	; 14
   15922:	84 bb       	out	0x14, r24	; 20

	_LCD_PORT = 0x30;
   15924:	20 e3       	ldi	r18, 0x30	; 48
   15926:	25 bb       	out	0x15, r18	; 21
	sbi(_LCD_PORT, _LCD_E);
   15928:	a9 9a       	sbi	0x15, 1	; 21
   1592a:	88 ee       	ldi	r24, 0xE8	; 232
   1592c:	93 e0       	ldi	r25, 0x03	; 3
   1592e:	fc 01       	movw	r30, r24
   15930:	31 97       	sbiw	r30, 0x01	; 1
   15932:	f1 f7       	brne	.-4      	; 0x15930 <lcd_init+0x22>
	_LCD_BUSY;
	cbi(_LCD_PORT, _LCD_E);
   15934:	a9 98       	cbi	0x15, 1	; 21
   15936:	fc 01       	movw	r30, r24
   15938:	31 97       	sbiw	r30, 0x01	; 1
   1593a:	f1 f7       	brne	.-4      	; 0x15938 <lcd_init+0x2a>
	_LCD_BUSY;

	_LCD_PORT = 0x30;
   1593c:	25 bb       	out	0x15, r18	; 21
	sbi(_LCD_PORT, _LCD_E);
   1593e:	a9 9a       	sbi	0x15, 1	; 21
   15940:	fc 01       	movw	r30, r24
   15942:	31 97       	sbiw	r30, 0x01	; 1
   15944:	f1 f7       	brne	.-4      	; 0x15942 <lcd_init+0x34>
	_LCD_BUSY;
	cbi(_LCD_PORT, _LCD_E);
   15946:	a9 98       	cbi	0x15, 1	; 21
   15948:	fc 01       	movw	r30, r24
   1594a:	31 97       	sbiw	r30, 0x01	; 1
   1594c:	f1 f7       	brne	.-4      	; 0x1594a <lcd_init+0x3c>
	_LCD_BUSY;

	_LCD_PORT = 0x30;
   1594e:	25 bb       	out	0x15, r18	; 21
	sbi(_LCD_PORT, _LCD_E);
   15950:	a9 9a       	sbi	0x15, 1	; 21
   15952:	fc 01       	movw	r30, r24
   15954:	31 97       	sbiw	r30, 0x01	; 1
   15956:	f1 f7       	brne	.-4      	; 0x15954 <lcd_init+0x46>
	_LCD_BUSY;
	cbi(_LCD_PORT, _LCD_E);
   15958:	a9 98       	cbi	0x15, 1	; 21
   1595a:	fc 01       	movw	r30, r24
   1595c:	31 97       	sbiw	r30, 0x01	; 1
   1595e:	f1 f7       	brne	.-4      	; 0x1595c <lcd_init+0x4e>
	_LCD_BUSY;

	_LCD_PORT = 0x20;
   15960:	20 e2       	ldi	r18, 0x20	; 32
   15962:	25 bb       	out	0x15, r18	; 21
	sbi(_LCD_PORT, _LCD_E);
   15964:	a9 9a       	sbi	0x15, 1	; 21
   15966:	fc 01       	movw	r30, r24
   15968:	31 97       	sbiw	r30, 0x01	; 1
   1596a:	f1 f7       	brne	.-4      	; 0x15968 <lcd_init+0x5a>
	_LCD_BUSY;
	cbi(_LCD_PORT, _LCD_E);
   1596c:	a9 98       	cbi	0x15, 1	; 21
   1596e:	01 97       	sbiw	r24, 0x01	; 1
   15970:	f1 f7       	brne	.-4      	; 0x1596e <lcd_init+0x60>
	_LCD_BUSY;

	_LIGHT_PORT = 0x01;
   15972:	81 e0       	ldi	r24, 0x01	; 1
   15974:	80 93 65 00 	sts	0x0065, r24
	_LIGHT_DDR |= (1 << _LIGHT_PIN);
   15978:	e4 e6       	ldi	r30, 0x64	; 100
   1597a:	f0 e0       	ldi	r31, 0x00	; 0
   1597c:	80 81       	ld	r24, Z
   1597e:	82 60       	ori	r24, 0x02	; 2
   15980:	80 83       	st	Z, r24

	lcd_command(0x28);
   15982:	88 e2       	ldi	r24, 0x28	; 40
   15984:	0e 94 5e ac 	call	0x158bc	; 0x158bc <lcd_command>
	lcd_command(0x0c);
   15988:	8c e0       	ldi	r24, 0x0C	; 12
   1598a:	0e 94 5e ac 	call	0x158bc	; 0x158bc <lcd_command>
	lcd_command(0x06);
   1598e:	86 e0       	ldi	r24, 0x06	; 6
   15990:	0e 94 5e ac 	call	0x158bc	; 0x158bc <lcd_command>
}
   15994:	08 95       	ret

00015996 <_lcd>:
	if (__chr==0x01) _delay_ms(50);

}

void _lcd(unsigned char __chr){
	_LCD_PORT =((__chr & 0xF0));
   15996:	28 2f       	mov	r18, r24
   15998:	20 7f       	andi	r18, 0xF0	; 240
   1599a:	25 bb       	out	0x15, r18	; 21
	sbi(_LCD_PORT, _LCD_RS);
   1599c:	ab 9a       	sbi	0x15, 3	; 21
	sbi(_LCD_PORT, _LCD_E);
   1599e:	a9 9a       	sbi	0x15, 1	; 21
	cbi(_LCD_PORT, _LCD_E);
   159a0:	a9 98       	cbi	0x15, 1	; 21

	_LCD_PORT = (((__chr & 0x0F) << 4));
   159a2:	90 e0       	ldi	r25, 0x00	; 0
   159a4:	24 e0       	ldi	r18, 0x04	; 4
   159a6:	88 0f       	add	r24, r24
   159a8:	99 1f       	adc	r25, r25
   159aa:	2a 95       	dec	r18
   159ac:	e1 f7       	brne	.-8      	; 0x159a6 <_lcd+0x10>
   159ae:	85 bb       	out	0x15, r24	; 21
	sbi(_LCD_PORT, _LCD_RS);
   159b0:	ab 9a       	sbi	0x15, 3	; 21
	sbi(_LCD_PORT, _LCD_E);
   159b2:	a9 9a       	sbi	0x15, 1	; 21
	cbi(_LCD_PORT, _LCD_E);
   159b4:	a9 98       	cbi	0x15, 1	; 21
   159b6:	88 ee       	ldi	r24, 0xE8	; 232
   159b8:	93 e0       	ldi	r25, 0x03	; 3
   159ba:	01 97       	sbiw	r24, 0x01	; 1
   159bc:	f1 f7       	brne	.-4      	; 0x159ba <_lcd+0x24>
	_LCD_BUSY;
	_delay_ms(1);
}
   159be:	8a ef       	ldi	r24, 0xFA	; 250
   159c0:	90 e0       	ldi	r25, 0x00	; 0
   159c2:	01 97       	sbiw	r24, 0x01	; 1
   159c4:	f1 f7       	brne	.-4      	; 0x159c2 <_lcd+0x2c>
   159c6:	08 95       	ret

000159c8 <lcd_string>:
     lcd_printf(2,1,PSTR("                    "));
     lcd_printf(3,1,PSTR("                    "));
     lcd_printf(4,1,PSTR("                    "));
}

void lcd_string(char *__string){
   159c8:	cf 93       	push	r28
   159ca:	df 93       	push	r29
   159cc:	ec 01       	movw	r28, r24
   159ce:	03 c0       	rjmp	.+6      	; 0x159d6 <lcd_string+0xe>
	while(*__string)
		_lcd(*__string++);
   159d0:	21 96       	adiw	r28, 0x01	; 1
   159d2:	0e 94 cb ac 	call	0x15996	; 0x15996 <_lcd>
     lcd_printf(3,1,PSTR("                    "));
     lcd_printf(4,1,PSTR("                    "));
}

void lcd_string(char *__string){
	while(*__string)
   159d6:	88 81       	ld	r24, Y
   159d8:	88 23       	and	r24, r24
   159da:	d1 f7       	brne	.-12     	; 0x159d0 <lcd_string+0x8>
		_lcd(*__string++);
}
   159dc:	df 91       	pop	r29
   159de:	cf 91       	pop	r28
   159e0:	08 95       	ret

000159e2 <lcd_xy>:

void lcd_xy(unsigned char __x, unsigned char __y){
	switch(__x){
   159e2:	82 30       	cpi	r24, 0x02	; 2
   159e4:	69 f0       	breq	.+26     	; 0x15a00 <lcd_xy+0x1e>
   159e6:	83 30       	cpi	r24, 0x03	; 3
   159e8:	18 f4       	brcc	.+6      	; 0x159f0 <lcd_xy+0xe>
   159ea:	81 30       	cpi	r24, 0x01	; 1
   159ec:	a9 f4       	brne	.+42     	; 0x15a18 <lcd_xy+0x36>
   159ee:	05 c0       	rjmp	.+10     	; 0x159fa <lcd_xy+0x18>
   159f0:	83 30       	cpi	r24, 0x03	; 3
   159f2:	49 f0       	breq	.+18     	; 0x15a06 <lcd_xy+0x24>
   159f4:	84 30       	cpi	r24, 0x04	; 4
   159f6:	81 f4       	brne	.+32     	; 0x15a18 <lcd_xy+0x36>
   159f8:	0b c0       	rjmp	.+22     	; 0x15a10 <lcd_xy+0x2e>
		case 1:
			lcd_command(0x80 + __y - 1);
   159fa:	86 2f       	mov	r24, r22
   159fc:	81 58       	subi	r24, 0x81	; 129
   159fe:	05 c0       	rjmp	.+10     	; 0x15a0a <lcd_xy+0x28>
			break;
		case 2:
			lcd_command(0xC0 + __y - 1);
   15a00:	86 2f       	mov	r24, r22
   15a02:	81 54       	subi	r24, 0x41	; 65
   15a04:	02 c0       	rjmp	.+4      	; 0x15a0a <lcd_xy+0x28>
			break;
		case 3:
			lcd_command(0x94 + __y - 1);
   15a06:	86 2f       	mov	r24, r22
   15a08:	8d 56       	subi	r24, 0x6D	; 109
   15a0a:	0e 94 5e ac 	call	0x158bc	; 0x158bc <lcd_command>
   15a0e:	08 95       	ret
			break;
		case 4:
			lcd_command(0xD4 + __y - 1);
   15a10:	86 2f       	mov	r24, r22
   15a12:	8d 52       	subi	r24, 0x2D	; 45
   15a14:	0e 94 5e ac 	call	0x158bc	; 0x158bc <lcd_command>
   15a18:	08 95       	ret

00015a1a <lcd_print>:
	 for (i=0;i<strlen(string);i++){
          string[i]=0;
	 }     
}

void lcd_print(unsigned char __x, unsigned char __y, char *__string){
   15a1a:	df 92       	push	r13
   15a1c:	ef 92       	push	r14
   15a1e:	ff 92       	push	r15
   15a20:	0f 93       	push	r16
   15a22:	1f 93       	push	r17
   15a24:	cf 93       	push	r28
   15a26:	df 93       	push	r29
   15a28:	06 2f       	mov	r16, r22
   15a2a:	d4 2e       	mov	r13, r20
   15a2c:	15 2f       	mov	r17, r21
    char yPos,iPos=0;//Modified by Iyan string [20] maks
	lcd_xy(__x, __y);
   15a2e:	0e 94 f1 ac 	call	0x159e2	; 0x159e2 <lcd_xy>
   15a32:	2d 2d       	mov	r18, r13
   15a34:	31 2f       	mov	r19, r17
   15a36:	c9 01       	movw	r24, r18
   15a38:	ec 01       	movw	r28, r24
	iPos=0;
	while((*__string)&&(iPos<=(20-__y))){
   15a3a:	34 e1       	ldi	r19, 0x14	; 20
   15a3c:	e3 2e       	mov	r14, r19
   15a3e:	f1 2c       	mov	r15, r1
   15a40:	e0 1a       	sub	r14, r16
   15a42:	f1 08       	sbc	r15, r1
   15a44:	04 c0       	rjmp	.+8      	; 0x15a4e <lcd_print+0x34>
		_lcd(*__string);__string++;
   15a46:	82 2f       	mov	r24, r18
   15a48:	0e 94 cb ac 	call	0x15996	; 0x15996 <_lcd>
   15a4c:	21 96       	adiw	r28, 0x01	; 1
   15a4e:	9e 01       	movw	r18, r28
   15a50:	2d 19       	sub	r18, r13
   15a52:	82 2f       	mov	r24, r18

void lcd_print(unsigned char __x, unsigned char __y, char *__string){
    char yPos,iPos=0;//Modified by Iyan string [20] maks
	lcd_xy(__x, __y);
	iPos=0;
	while((*__string)&&(iPos<=(20-__y))){
   15a54:	28 81       	ld	r18, Y
   15a56:	22 23       	and	r18, r18
   15a58:	21 f0       	breq	.+8      	; 0x15a62 <lcd_print+0x48>
   15a5a:	90 e0       	ldi	r25, 0x00	; 0
   15a5c:	e8 16       	cp	r14, r24
   15a5e:	f9 06       	cpc	r15, r25
   15a60:	94 f7       	brge	.-28     	; 0x15a46 <lcd_print+0x2c>
		_lcd(*__string);__string++;
		iPos++;
		}    
}
   15a62:	df 91       	pop	r29
   15a64:	cf 91       	pop	r28
   15a66:	1f 91       	pop	r17
   15a68:	0f 91       	pop	r16
   15a6a:	ff 90       	pop	r15
   15a6c:	ef 90       	pop	r14
   15a6e:	df 90       	pop	r13
   15a70:	08 95       	ret

00015a72 <lcd_printf>:

void lcd_printf(unsigned char __x, unsigned char __y, char *__string){
   15a72:	df 92       	push	r13
   15a74:	ef 92       	push	r14
   15a76:	ff 92       	push	r15
   15a78:	0f 93       	push	r16
   15a7a:	1f 93       	push	r17
   15a7c:	cf 93       	push	r28
   15a7e:	df 93       	push	r29
   15a80:	06 2f       	mov	r16, r22
   15a82:	d4 2e       	mov	r13, r20
   15a84:	15 2f       	mov	r17, r21
    char iPos=0;
	lcd_xy(__x, __y);
   15a86:	0e 94 f1 ac 	call	0x159e2	; 0x159e2 <lcd_xy>
   15a8a:	8d 2d       	mov	r24, r13
   15a8c:	91 2f       	mov	r25, r17
   15a8e:	fc 01       	movw	r30, r24
   15a90:	ef 01       	movw	r28, r30
	iPos=0;
	while((pgm_read_byte(&(*__string)))&&(iPos<=(20-__y))){
   15a92:	44 e1       	ldi	r20, 0x14	; 20
   15a94:	e4 2e       	mov	r14, r20
   15a96:	f1 2c       	mov	r15, r1
   15a98:	e0 1a       	sub	r14, r16
   15a9a:	f1 08       	sbc	r15, r1
   15a9c:	04 c0       	rjmp	.+8      	; 0x15aa6 <lcd_printf+0x34>
		_lcd(pgm_read_byte(&(*__string)));
   15a9e:	82 2f       	mov	r24, r18
   15aa0:	0e 94 cb ac 	call	0x15996	; 0x15996 <_lcd>
		__string++;
   15aa4:	21 96       	adiw	r28, 0x01	; 1
   15aa6:	9e 01       	movw	r18, r28
   15aa8:	2d 19       	sub	r18, r13
   15aaa:	82 2f       	mov	r24, r18

void lcd_printf(unsigned char __x, unsigned char __y, char *__string){
    char iPos=0;
	lcd_xy(__x, __y);
	iPos=0;
	while((pgm_read_byte(&(*__string)))&&(iPos<=(20-__y))){
   15aac:	fe 01       	movw	r30, r28
   15aae:	24 91       	lpm	r18, Z+
   15ab0:	22 23       	and	r18, r18
   15ab2:	21 f0       	breq	.+8      	; 0x15abc <lcd_printf+0x4a>
   15ab4:	90 e0       	ldi	r25, 0x00	; 0
   15ab6:	e8 16       	cp	r14, r24
   15ab8:	f9 06       	cpc	r15, r25
   15aba:	8c f7       	brge	.-30     	; 0x15a9e <lcd_printf+0x2c>
		_lcd(pgm_read_byte(&(*__string)));
		__string++;
		iPos++;
		}
}
   15abc:	df 91       	pop	r29
   15abe:	cf 91       	pop	r28
   15ac0:	1f 91       	pop	r17
   15ac2:	0f 91       	pop	r16
   15ac4:	ff 90       	pop	r15
   15ac6:	ef 90       	pop	r14
   15ac8:	df 90       	pop	r13
   15aca:	08 95       	ret

00015acc <lcd_clear>:
	_LCD_BUSY;
	_delay_ms(1);
}

void lcd_clear(){
     lcd_printf(1,1,PSTR("                    "));
   15acc:	81 e0       	ldi	r24, 0x01	; 1
   15ace:	61 e0       	ldi	r22, 0x01	; 1
   15ad0:	44 ee       	ldi	r20, 0xE4	; 228
   15ad2:	53 e2       	ldi	r21, 0x23	; 35
   15ad4:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
     lcd_printf(2,1,PSTR("                    "));
   15ad8:	82 e0       	ldi	r24, 0x02	; 2
   15ada:	61 e0       	ldi	r22, 0x01	; 1
   15adc:	4f ec       	ldi	r20, 0xCF	; 207
   15ade:	53 e2       	ldi	r21, 0x23	; 35
   15ae0:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
     lcd_printf(3,1,PSTR("                    "));
   15ae4:	83 e0       	ldi	r24, 0x03	; 3
   15ae6:	61 e0       	ldi	r22, 0x01	; 1
   15ae8:	4a eb       	ldi	r20, 0xBA	; 186
   15aea:	53 e2       	ldi	r21, 0x23	; 35
   15aec:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
     lcd_printf(4,1,PSTR("                    "));
   15af0:	84 e0       	ldi	r24, 0x04	; 4
   15af2:	61 e0       	ldi	r22, 0x01	; 1
   15af4:	45 ea       	ldi	r20, 0xA5	; 165
   15af6:	53 e2       	ldi	r21, 0x23	; 35
   15af8:	0e 94 39 ad 	call	0x15a72	; 0x15a72 <lcd_printf>
}
   15afc:	08 95       	ret

00015afe <lcd_put>:
		__string++;
		iPos++;
		}
}

void lcd_put(unsigned char __x, unsigned char __y, unsigned char __chr){
   15afe:	1f 93       	push	r17
   15b00:	14 2f       	mov	r17, r20
	lcd_xy(__x, __y);
   15b02:	0e 94 f1 ac 	call	0x159e2	; 0x159e2 <lcd_xy>
	_lcd(__chr);
   15b06:	81 2f       	mov	r24, r17
   15b08:	0e 94 cb ac 	call	0x15996	; 0x15996 <_lcd>
}
   15b0c:	1f 91       	pop	r17
   15b0e:	08 95       	ret

00015b10 <lcd_cgram>:

void lcd_cgram(unsigned char location, char *ptr){
   15b10:	0f 93       	push	r16
   15b12:	1f 93       	push	r17
   15b14:	cf 93       	push	r28
   15b16:	df 93       	push	r29
   15b18:	8b 01       	movw	r16, r22
	unsigned char i;
    if(location < 8){
   15b1a:	88 30       	cpi	r24, 0x08	; 8
   15b1c:	90 f4       	brcc	.+36     	; 0x15b42 <lcd_cgram+0x32>
		lcd_command(0x40 + (location * 8));
   15b1e:	88 0f       	add	r24, r24
   15b20:	88 0f       	add	r24, r24
   15b22:	88 0f       	add	r24, r24
   15b24:	80 5c       	subi	r24, 0xC0	; 192
   15b26:	0e 94 5e ac 	call	0x158bc	; 0x158bc <lcd_command>
   15b2a:	c0 e0       	ldi	r28, 0x00	; 0
   15b2c:	d0 e0       	ldi	r29, 0x00	; 0
		for(i = 0; i < 8; i++)
			_lcd(ptr[i]);
   15b2e:	f8 01       	movw	r30, r16
   15b30:	ec 0f       	add	r30, r28
   15b32:	fd 1f       	adc	r31, r29
   15b34:	80 81       	ld	r24, Z
   15b36:	0e 94 cb ac 	call	0x15996	; 0x15996 <_lcd>
   15b3a:	21 96       	adiw	r28, 0x01	; 1

void lcd_cgram(unsigned char location, char *ptr){
	unsigned char i;
    if(location < 8){
		lcd_command(0x40 + (location * 8));
		for(i = 0; i < 8; i++)
   15b3c:	c8 30       	cpi	r28, 0x08	; 8
   15b3e:	d1 05       	cpc	r29, r1
   15b40:	b1 f7       	brne	.-20     	; 0x15b2e <lcd_cgram+0x1e>
			_lcd(ptr[i]);
	}
}
   15b42:	df 91       	pop	r29
   15b44:	cf 91       	pop	r28
   15b46:	1f 91       	pop	r17
   15b48:	0f 91       	pop	r16
   15b4a:	08 95       	ret

00015b4c <ClearMem>:
			lcd_command(0xD4 + __y - 1);
			break;
	}
}

void ClearMem(char *string){
   15b4c:	cf 93       	push	r28
   15b4e:	df 93       	push	r29
   15b50:	20 e0       	ldi	r18, 0x00	; 0
   15b52:	04 c0       	rjmp	.+8      	; 0x15b5c <ClearMem+0x10>
     char i;
	 for (i=0;i<strlen(string);i++){
          string[i]=0;
   15b54:	c8 0f       	add	r28, r24
   15b56:	d9 1f       	adc	r29, r25
   15b58:	18 82       	st	Y, r1
	}
}

void ClearMem(char *string){
     char i;
	 for (i=0;i<strlen(string);i++){
   15b5a:	2f 5f       	subi	r18, 0xFF	; 255
   15b5c:	c2 2f       	mov	r28, r18
   15b5e:	d0 e0       	ldi	r29, 0x00	; 0
   15b60:	fc 01       	movw	r30, r24
   15b62:	01 90       	ld	r0, Z+
   15b64:	00 20       	and	r0, r0
   15b66:	e9 f7       	brne	.-6      	; 0x15b62 <ClearMem+0x16>
   15b68:	31 97       	sbiw	r30, 0x01	; 1
   15b6a:	e8 1b       	sub	r30, r24
   15b6c:	f9 0b       	sbc	r31, r25
   15b6e:	ce 17       	cp	r28, r30
   15b70:	df 07       	cpc	r29, r31
   15b72:	80 f3       	brcs	.-32     	; 0x15b54 <ClearMem+0x8>
          string[i]=0;
	 }     
}
   15b74:	df 91       	pop	r29
   15b76:	cf 91       	pop	r28
   15b78:	08 95       	ret

00015b7a <_key_hit>:
													 {'7', 'P', 'Q', 'R', 'S', '\0'},
											         {'8', 'T', 'U', 'V', '\0'}, 
													 {'9', 'W', 'X', 'Y', 'Z', '\0'}}};
const unsigned char __maxchar[10] PROGMEM = {2, 4, 3, 3, 3, 3, 3, 4, 3, 4};

char _key_hit(void){
   15b7a:	df 93       	push	r29
   15b7c:	cf 93       	push	r28
   15b7e:	00 d0       	rcall	.+0      	; 0x15b80 <_key_hit+0x6>
   15b80:	00 d0       	rcall	.+0      	; 0x15b82 <_key_hit+0x8>
   15b82:	cd b7       	in	r28, 0x3d	; 61
   15b84:	de b7       	in	r29, 0x3e	; 62
	unsigned char	i, keyhit=0x00;
	unsigned char	outmap[4] = {0xef, 0xdf, 0xbf, 0x7f};
   15b86:	8f ee       	ldi	r24, 0xEF	; 239
   15b88:	89 83       	std	Y+1, r24	; 0x01
   15b8a:	8f ed       	ldi	r24, 0xDF	; 223
   15b8c:	8a 83       	std	Y+2, r24	; 0x02
   15b8e:	8f eb       	ldi	r24, 0xBF	; 191
   15b90:	8b 83       	std	Y+3, r24	; 0x03
   15b92:	8f e7       	ldi	r24, 0x7F	; 127
   15b94:	8c 83       	std	Y+4, r24	; 0x04
   15b96:	de 01       	movw	r26, r28
   15b98:	11 96       	adiw	r26, 0x01	; 1
   15b9a:	2a ef       	ldi	r18, 0xFA	; 250
   15b9c:	30 e0       	ldi	r19, 0x00	; 0

	for(i=0; i<4; i++){
   15b9e:	ae 01       	movw	r20, r28
   15ba0:	4b 5f       	subi	r20, 0xFB	; 251
   15ba2:	5f 4f       	sbci	r21, 0xFF	; 255
   15ba4:	c9 01       	movw	r24, r18
   15ba6:	01 97       	sbiw	r24, 0x01	; 1
   15ba8:	f1 f7       	brne	.-4      	; 0x15ba6 <_key_hit+0x2c>
		_delay_ms(1);
		_KEY_PORT = outmap[i];
   15baa:	8c 91       	ld	r24, X
   15bac:	80 93 62 00 	sts	0x0062, r24
   15bb0:	f9 01       	movw	r30, r18
   15bb2:	31 97       	sbiw	r30, 0x01	; 1
   15bb4:	f1 f7       	brne	.-4      	; 0x15bb2 <_key_hit+0x38>
		_delay_ms(1);
		keyhit = _KEY_MATRIX;
   15bb6:	90 b1       	in	r25, 0x00	; 0
		if (keyhit!=outmap[i]) 
   15bb8:	98 17       	cp	r25, r24
   15bba:	21 f4       	brne	.+8      	; 0x15bc4 <_key_hit+0x4a>
		    break;
   15bbc:	11 96       	adiw	r26, 0x01	; 1

char _key_hit(void){
	unsigned char	i, keyhit=0x00;
	unsigned char	outmap[4] = {0xef, 0xdf, 0xbf, 0x7f};

	for(i=0; i<4; i++){
   15bbe:	a4 17       	cp	r26, r20
   15bc0:	b5 07       	cpc	r27, r21
   15bc2:	81 f7       	brne	.-32     	; 0x15ba4 <_key_hit+0x2a>
		keyhit = _KEY_MATRIX;
		if (keyhit!=outmap[i]) 
		    break;
	}
	return keyhit;
}
   15bc4:	89 2f       	mov	r24, r25
   15bc6:	0f 90       	pop	r0
   15bc8:	0f 90       	pop	r0
   15bca:	0f 90       	pop	r0
   15bcc:	0f 90       	pop	r0
   15bce:	cf 91       	pop	r28
   15bd0:	df 91       	pop	r29
   15bd2:	08 95       	ret

00015bd4 <_key_crr>:

char _key_crr(char __key){
	if(	__key != _KEY_1 && __key != _KEY_2 &&
   15bd4:	8e 3e       	cpi	r24, 0xEE	; 238
   15bd6:	f9 f0       	breq	.+62     	; 0x15c16 <_key_crr+0x42>
   15bd8:	8e 3d       	cpi	r24, 0xDE	; 222
   15bda:	e9 f0       	breq	.+58     	; 0x15c16 <_key_crr+0x42>
   15bdc:	8e 3b       	cpi	r24, 0xBE	; 190
   15bde:	d9 f0       	breq	.+54     	; 0x15c16 <_key_crr+0x42>
   15be0:	8d 3e       	cpi	r24, 0xED	; 237
   15be2:	c9 f0       	breq	.+50     	; 0x15c16 <_key_crr+0x42>
   15be4:	8d 3d       	cpi	r24, 0xDD	; 221
   15be6:	b9 f0       	breq	.+46     	; 0x15c16 <_key_crr+0x42>
   15be8:	8d 3b       	cpi	r24, 0xBD	; 189
   15bea:	a9 f0       	breq	.+42     	; 0x15c16 <_key_crr+0x42>
   15bec:	8b 3e       	cpi	r24, 0xEB	; 235
   15bee:	99 f0       	breq	.+38     	; 0x15c16 <_key_crr+0x42>
   15bf0:	8b 3d       	cpi	r24, 0xDB	; 219
   15bf2:	89 f0       	breq	.+34     	; 0x15c16 <_key_crr+0x42>
   15bf4:	8b 3b       	cpi	r24, 0xBB	; 187
   15bf6:	79 f0       	breq	.+30     	; 0x15c16 <_key_crr+0x42>
   15bf8:	87 3d       	cpi	r24, 0xD7	; 215
   15bfa:	69 f0       	breq	.+26     	; 0x15c16 <_key_crr+0x42>
   15bfc:	87 3e       	cpi	r24, 0xE7	; 231
   15bfe:	59 f0       	breq	.+22     	; 0x15c16 <_key_crr+0x42>
   15c00:	87 3b       	cpi	r24, 0xB7	; 183
   15c02:	49 f0       	breq	.+18     	; 0x15c16 <_key_crr+0x42>
   15c04:	8e 37       	cpi	r24, 0x7E	; 126
   15c06:	39 f0       	breq	.+14     	; 0x15c16 <_key_crr+0x42>
   15c08:	8d 37       	cpi	r24, 0x7D	; 125
   15c0a:	29 f0       	breq	.+10     	; 0x15c16 <_key_crr+0x42>
   15c0c:	8b 37       	cpi	r24, 0x7B	; 123
   15c0e:	19 f0       	breq	.+6      	; 0x15c16 <_key_crr+0x42>
   15c10:	87 37       	cpi	r24, 0x77	; 119
   15c12:	09 f0       	breq	.+2      	; 0x15c16 <_key_crr+0x42>
   15c14:	80 e0       	ldi	r24, 0x00	; 0
		__key != _KEY_CANCEL && __key != _KEY_ENTER &&
		__key != _KEY_TIKET && __key != _KEY_MENU &&
		__key != _KEY_SHIFT && __key != _KEY_CLEAR)
		return _KEY_NULL;
	return __key;
}
   15c16:	08 95       	ret

00015c18 <_key_btn>:

char _key_btn(char __key){
	char __keychar = 0;
	
	switch (__key){
   15c18:	8e 3b       	cpi	r24, 0xBE	; 190
   15c1a:	91 f1       	breq	.+100    	; 0x15c80 <_key_btn+0x68>
   15c1c:	8f 3b       	cpi	r24, 0xBF	; 191
   15c1e:	a8 f4       	brcc	.+42     	; 0x15c4a <_key_btn+0x32>
   15c20:	8e 37       	cpi	r24, 0x7E	; 126
   15c22:	09 f4       	brne	.+2      	; 0x15c26 <_key_btn+0xe>
   15c24:	41 c0       	rjmp	.+130    	; 0x15ca8 <_key_btn+0x90>
   15c26:	8f 37       	cpi	r24, 0x7F	; 127
   15c28:	48 f4       	brcc	.+18     	; 0x15c3c <_key_btn+0x24>
   15c2a:	8b 37       	cpi	r24, 0x7B	; 123
   15c2c:	09 f4       	brne	.+2      	; 0x15c30 <_key_btn+0x18>
   15c2e:	40 c0       	rjmp	.+128    	; 0x15cb0 <_key_btn+0x98>
   15c30:	8d 37       	cpi	r24, 0x7D	; 125
   15c32:	e1 f1       	breq	.+120    	; 0x15cac <_key_btn+0x94>
   15c34:	87 37       	cpi	r24, 0x77	; 119
   15c36:	09 f0       	breq	.+2      	; 0x15c3a <_key_btn+0x22>
   15c38:	3f c0       	rjmp	.+126    	; 0x15cb8 <_key_btn+0xa0>
   15c3a:	3c c0       	rjmp	.+120    	; 0x15cb4 <_key_btn+0x9c>
   15c3c:	8b 3b       	cpi	r24, 0xBB	; 187
   15c3e:	61 f1       	breq	.+88     	; 0x15c98 <_key_btn+0x80>
   15c40:	8d 3b       	cpi	r24, 0xBD	; 189
   15c42:	21 f1       	breq	.+72     	; 0x15c8c <_key_btn+0x74>
   15c44:	87 3b       	cpi	r24, 0xB7	; 183
   15c46:	c1 f5       	brne	.+112    	; 0x15cb8 <_key_btn+0xa0>
   15c48:	2d c0       	rjmp	.+90     	; 0x15ca4 <_key_btn+0x8c>
   15c4a:	8e 3d       	cpi	r24, 0xDE	; 222
   15c4c:	a9 f0       	breq	.+42     	; 0x15c78 <_key_btn+0x60>
   15c4e:	8f 3d       	cpi	r24, 0xDF	; 223
   15c50:	38 f4       	brcc	.+14     	; 0x15c60 <_key_btn+0x48>
   15c52:	8b 3d       	cpi	r24, 0xDB	; 219
   15c54:	f9 f0       	breq	.+62     	; 0x15c94 <_key_btn+0x7c>
   15c56:	8d 3d       	cpi	r24, 0xDD	; 221
   15c58:	b9 f0       	breq	.+46     	; 0x15c88 <_key_btn+0x70>
   15c5a:	87 3d       	cpi	r24, 0xD7	; 215
   15c5c:	69 f5       	brne	.+90     	; 0x15cb8 <_key_btn+0xa0>
   15c5e:	1e c0       	rjmp	.+60     	; 0x15c9c <_key_btn+0x84>
   15c60:	8b 3e       	cpi	r24, 0xEB	; 235
   15c62:	b1 f0       	breq	.+44     	; 0x15c90 <_key_btn+0x78>
   15c64:	8c 3e       	cpi	r24, 0xEC	; 236
   15c66:	18 f4       	brcc	.+6      	; 0x15c6e <_key_btn+0x56>
   15c68:	87 3e       	cpi	r24, 0xE7	; 231
   15c6a:	31 f5       	brne	.+76     	; 0x15cb8 <_key_btn+0xa0>
   15c6c:	19 c0       	rjmp	.+50     	; 0x15ca0 <_key_btn+0x88>
   15c6e:	8d 3e       	cpi	r24, 0xED	; 237
   15c70:	49 f0       	breq	.+18     	; 0x15c84 <_key_btn+0x6c>
   15c72:	8e 3e       	cpi	r24, 0xEE	; 238
   15c74:	09 f5       	brne	.+66     	; 0x15cb8 <_key_btn+0xa0>
   15c76:	02 c0       	rjmp	.+4      	; 0x15c7c <_key_btn+0x64>
   15c78:	82 e3       	ldi	r24, 0x32	; 50
   15c7a:	08 95       	ret
   15c7c:	81 e3       	ldi	r24, 0x31	; 49
   15c7e:	08 95       	ret
   15c80:	83 e3       	ldi	r24, 0x33	; 51
   15c82:	08 95       	ret
		case 0xDE:
			__keychar = 0x32; //2
			break;
		case 0xBE:
			__keychar = 0x33; //3
			break;
   15c84:	84 e3       	ldi	r24, 0x34	; 52
   15c86:	08 95       	ret
		case 0xED:
			__keychar = 0x34; //4
			break;
   15c88:	85 e3       	ldi	r24, 0x35	; 53
   15c8a:	08 95       	ret
		case 0xDD:
			__keychar = 0x35; //5
			break;
   15c8c:	86 e3       	ldi	r24, 0x36	; 54
   15c8e:	08 95       	ret
		case 0xBD:
			__keychar = 0x36; //6
			break;
   15c90:	87 e3       	ldi	r24, 0x37	; 55
   15c92:	08 95       	ret
		case 0xEB:
			__keychar = 0x37; //7
			break;
   15c94:	88 e3       	ldi	r24, 0x38	; 56
   15c96:	08 95       	ret
		case 0xDB:
			__keychar = 0x38; //8
			break;
   15c98:	89 e3       	ldi	r24, 0x39	; 57
   15c9a:	08 95       	ret
		case 0xBB:
			__keychar = 0x39; //9
			break;
   15c9c:	80 e3       	ldi	r24, 0x30	; 48
   15c9e:	08 95       	ret
		case 0xD7:
			__keychar = 0x30; //0
			break;
   15ca0:	8a e2       	ldi	r24, 0x2A	; 42
   15ca2:	08 95       	ret
		case 0xE7:
			__keychar = 0x2a; //*
			break;
   15ca4:	83 e2       	ldi	r24, 0x23	; 35
   15ca6:	08 95       	ret
		case 0xB7:
			__keychar = 0x23; //#
			break;
   15ca8:	81 ef       	ldi	r24, 0xF1	; 241
   15caa:	08 95       	ret
		case 0x7E:
			__keychar = 0xF1; //Menu 1
			break;
   15cac:	82 ef       	ldi	r24, 0xF2	; 242
   15cae:	08 95       	ret
		case 0x7D:
			__keychar = 0xF2; //Menu 2
			break;
   15cb0:	83 ef       	ldi	r24, 0xF3	; 243
   15cb2:	08 95       	ret
		case 0x7B:
			__keychar = 0xF3; //Menu 3
			break;
   15cb4:	84 ef       	ldi	r24, 0xF4	; 244
   15cb6:	08 95       	ret
		case 0x77:
			__keychar = 0xF4; //Menu 4
			break;
   15cb8:	80 e0       	ldi	r24, 0x00	; 0
			__keychar = 0x00;
			break;

	}
	return __keychar;
}
   15cba:	08 95       	ret

00015cbc <_table_alphanum>:
	}
	_PAD_1st;
	return __key;
}

char _table_alphanum(char __caps, char __key, char __hit){
   15cbc:	98 2f       	mov	r25, r24
unsigned char __retchar = 0;

	switch(__key){
   15cbe:	6d 3d       	cpi	r22, 0xDD	; 221
   15cc0:	11 f1       	breq	.+68     	; 0x15d06 <_table_alphanum+0x4a>
   15cc2:	6e 3d       	cpi	r22, 0xDE	; 222
   15cc4:	60 f4       	brcc	.+24     	; 0x15cde <_table_alphanum+0x22>
   15cc6:	6d 3b       	cpi	r22, 0xBD	; 189
   15cc8:	01 f1       	breq	.+64     	; 0x15d0a <_table_alphanum+0x4e>
   15cca:	6e 3b       	cpi	r22, 0xBE	; 190
   15ccc:	18 f4       	brcc	.+6      	; 0x15cd4 <_table_alphanum+0x18>
   15cce:	6b 3b       	cpi	r22, 0xBB	; 187
   15cd0:	21 f5       	brne	.+72     	; 0x15d1a <_table_alphanum+0x5e>
   15cd2:	21 c0       	rjmp	.+66     	; 0x15d16 <_table_alphanum+0x5a>
   15cd4:	6e 3b       	cpi	r22, 0xBE	; 190
   15cd6:	99 f0       	breq	.+38     	; 0x15cfe <_table_alphanum+0x42>
   15cd8:	6b 3d       	cpi	r22, 0xDB	; 219
   15cda:	f9 f4       	brne	.+62     	; 0x15d1a <_table_alphanum+0x5e>
   15cdc:	1a c0       	rjmp	.+52     	; 0x15d12 <_table_alphanum+0x56>
   15cde:	6b 3e       	cpi	r22, 0xEB	; 235
   15ce0:	b1 f0       	breq	.+44     	; 0x15d0e <_table_alphanum+0x52>
   15ce2:	6c 3e       	cpi	r22, 0xEC	; 236
   15ce4:	18 f4       	brcc	.+6      	; 0x15cec <_table_alphanum+0x30>
   15ce6:	6e 3d       	cpi	r22, 0xDE	; 222
   15ce8:	c1 f4       	brne	.+48     	; 0x15d1a <_table_alphanum+0x5e>
   15cea:	05 c0       	rjmp	.+10     	; 0x15cf6 <_table_alphanum+0x3a>
   15cec:	6d 3e       	cpi	r22, 0xED	; 237
   15cee:	49 f0       	breq	.+18     	; 0x15d02 <_table_alphanum+0x46>
   15cf0:	6e 3e       	cpi	r22, 0xEE	; 238
   15cf2:	99 f4       	brne	.+38     	; 0x15d1a <_table_alphanum+0x5e>
   15cf4:	02 c0       	rjmp	.+4      	; 0x15cfa <_table_alphanum+0x3e>
   15cf6:	82 e0       	ldi	r24, 0x02	; 2
   15cf8:	11 c0       	rjmp	.+34     	; 0x15d1c <_table_alphanum+0x60>
   15cfa:	81 e0       	ldi	r24, 0x01	; 1
   15cfc:	0f c0       	rjmp	.+30     	; 0x15d1c <_table_alphanum+0x60>
   15cfe:	83 e0       	ldi	r24, 0x03	; 3
   15d00:	0d c0       	rjmp	.+26     	; 0x15d1c <_table_alphanum+0x60>
		case 0xDE:
			__key = 2; //2
			break;
		case 0xBE:
			__key = 3; //3
			break;
   15d02:	84 e0       	ldi	r24, 0x04	; 4
   15d04:	0b c0       	rjmp	.+22     	; 0x15d1c <_table_alphanum+0x60>
		case 0xED:
			__key = 4; //4
			break;
   15d06:	85 e0       	ldi	r24, 0x05	; 5
   15d08:	09 c0       	rjmp	.+18     	; 0x15d1c <_table_alphanum+0x60>
		case 0xDD:
			__key = 5; //5
			break;
   15d0a:	86 e0       	ldi	r24, 0x06	; 6
   15d0c:	07 c0       	rjmp	.+14     	; 0x15d1c <_table_alphanum+0x60>
		case 0xBD:
			__key = 6; //6
			break;
   15d0e:	87 e0       	ldi	r24, 0x07	; 7
   15d10:	05 c0       	rjmp	.+10     	; 0x15d1c <_table_alphanum+0x60>
		case 0xEB:
			__key = 7; //7
			break;
   15d12:	88 e0       	ldi	r24, 0x08	; 8
   15d14:	03 c0       	rjmp	.+6      	; 0x15d1c <_table_alphanum+0x60>
		case 0xDB:
			__key = 8; //8
			break;
   15d16:	89 e0       	ldi	r24, 0x09	; 9
   15d18:	01 c0       	rjmp	.+2      	; 0x15d1c <_table_alphanum+0x60>
		case 0xBB:
			__key = 9; //9
			break;
   15d1a:	80 e0       	ldi	r24, 0x00	; 0
		default:
			__key = 0;
			break;	
	}

	if(__hit <= pgm_read_byte(&__maxchar[__key]))
   15d1c:	28 2f       	mov	r18, r24
   15d1e:	30 e0       	ldi	r19, 0x00	; 0
   15d20:	f9 01       	movw	r30, r18
   15d22:	ef 58       	subi	r30, 0x8F	; 143
   15d24:	fb 4d       	sbci	r31, 0xDB	; 219
   15d26:	e4 91       	lpm	r30, Z+
   15d28:	e4 17       	cp	r30, r20
   15d2a:	10 f4       	brcc	.+4      	; 0x15d30 <_table_alphanum+0x74>
   15d2c:	80 e0       	ldi	r24, 0x00	; 0
   15d2e:	08 95       	ret
		__retchar = pgm_read_byte(&__alphanum[__caps][__key][__hit]);
   15d30:	ec e3       	ldi	r30, 0x3C	; 60
   15d32:	9e 9f       	mul	r25, r30
   15d34:	f0 01       	movw	r30, r0
   15d36:	11 24       	eor	r1, r1
   15d38:	e4 0f       	add	r30, r20
   15d3a:	f1 1d       	adc	r31, r1
   15d3c:	c9 01       	movw	r24, r18
   15d3e:	88 0f       	add	r24, r24
   15d40:	99 1f       	adc	r25, r25
   15d42:	82 0f       	add	r24, r18
   15d44:	93 1f       	adc	r25, r19
   15d46:	88 0f       	add	r24, r24
   15d48:	99 1f       	adc	r25, r25
   15d4a:	e8 0f       	add	r30, r24
   15d4c:	f9 1f       	adc	r31, r25
   15d4e:	e7 50       	subi	r30, 0x07	; 7
   15d50:	fc 4d       	sbci	r31, 0xDC	; 220
   15d52:	84 91       	lpm	r24, Z+
	else __retchar = '\0';

	return __retchar;
}
   15d54:	08 95       	ret

00015d56 <_key_scan>:





char _key_scan(char __select){
   15d56:	8f 92       	push	r8
   15d58:	9f 92       	push	r9
   15d5a:	af 92       	push	r10
   15d5c:	bf 92       	push	r11
   15d5e:	cf 92       	push	r12
   15d60:	df 92       	push	r13
   15d62:	ef 92       	push	r14
   15d64:	ff 92       	push	r15
   15d66:	0f 93       	push	r16
   15d68:	1f 93       	push	r17
   15d6a:	df 93       	push	r29
   15d6c:	cf 93       	push	r28
   15d6e:	00 d0       	rcall	.+0      	; 0x15d70 <_key_scan+0x1a>
   15d70:	00 d0       	rcall	.+0      	; 0x15d72 <_key_scan+0x1c>
   15d72:	cd b7       	in	r28, 0x3d	; 61
   15d74:	de b7       	in	r29, 0x3e	; 62
   15d76:	18 2f       	mov	r17, r24
	char	__key = 0;

	if(__select==_PAD_SINGLE || __select==_PAD_MULTI){
   15d78:	81 50       	subi	r24, 0x01	; 1
   15d7a:	82 30       	cpi	r24, 0x02	; 2
   15d7c:	08 f0       	brcs	.+2      	; 0x15d80 <_key_scan+0x2a>
   15d7e:	aa c0       	rjmp	.+340    	; 0x15ed4 <_key_scan+0x17e>
													 {'9', 'W', 'X', 'Y', 'Z', '\0'}}};
const unsigned char __maxchar[10] PROGMEM = {2, 4, 3, 3, 3, 3, 3, 4, 3, 4};

char _key_hit(void){
	unsigned char	i, keyhit=0x00;
	unsigned char	outmap[4] = {0xef, 0xdf, 0xbf, 0x7f};
   15d80:	8f ee       	ldi	r24, 0xEF	; 239
   15d82:	89 83       	std	Y+1, r24	; 0x01
   15d84:	8f ed       	ldi	r24, 0xDF	; 223
   15d86:	8a 83       	std	Y+2, r24	; 0x02
   15d88:	8f eb       	ldi	r24, 0xBF	; 191
   15d8a:	8b 83       	std	Y+3, r24	; 0x03
   15d8c:	8f e7       	ldi	r24, 0x7F	; 127
   15d8e:	8c 83       	std	Y+4, r24	; 0x04
   15d90:	de 01       	movw	r26, r28
   15d92:	11 96       	adiw	r26, 0x01	; 1
   15d94:	2a ef       	ldi	r18, 0xFA	; 250
   15d96:	30 e0       	ldi	r19, 0x00	; 0

	for(i=0; i<4; i++){
   15d98:	ae 01       	movw	r20, r28
   15d9a:	4b 5f       	subi	r20, 0xFB	; 251
   15d9c:	5f 4f       	sbci	r21, 0xFF	; 255
   15d9e:	c9 01       	movw	r24, r18
   15da0:	01 97       	sbiw	r24, 0x01	; 1
   15da2:	f1 f7       	brne	.-4      	; 0x15da0 <_key_scan+0x4a>
		_delay_ms(1);
		_KEY_PORT = outmap[i];
   15da4:	8c 91       	ld	r24, X
   15da6:	80 93 62 00 	sts	0x0062, r24
   15daa:	f9 01       	movw	r30, r18
   15dac:	31 97       	sbiw	r30, 0x01	; 1
   15dae:	f1 f7       	brne	.-4      	; 0x15dac <_key_scan+0x56>
		_delay_ms(1);
		keyhit = _KEY_MATRIX;
   15db0:	90 b1       	in	r25, 0x00	; 0
		if (keyhit!=outmap[i]) 
   15db2:	98 17       	cp	r25, r24
   15db4:	21 f4       	brne	.+8      	; 0x15dbe <_key_scan+0x68>
   15db6:	11 96       	adiw	r26, 0x01	; 1

char _key_hit(void){
	unsigned char	i, keyhit=0x00;
	unsigned char	outmap[4] = {0xef, 0xdf, 0xbf, 0x7f};

	for(i=0; i<4; i++){
   15db8:	a4 17       	cp	r26, r20
   15dba:	b5 07       	cpc	r27, r21
   15dbc:	81 f7       	brne	.-32     	; 0x15d9e <_key_scan+0x48>
char _key_scan(char __select){
	char	__key = 0;

	if(__select==_PAD_SINGLE || __select==_PAD_MULTI){
		__key = _key_hit();
		__key = _key_crr(__key);
   15dbe:	89 2f       	mov	r24, r25
   15dc0:	0e 94 ea ad 	call	0x15bd4	; 0x15bd4 <_key_crr>
   15dc4:	28 2f       	mov	r18, r24

		if(__key!=_KEY_NULL){
   15dc6:	88 23       	and	r24, r24
   15dc8:	09 f4       	brne	.+2      	; 0x15dcc <_key_scan+0x76>
   15dca:	85 c0       	rjmp	.+266    	; 0x15ed6 <_key_scan+0x180>
			_LIGHT_SET;
   15dcc:	91 e0       	ldi	r25, 0x01	; 1
   15dce:	90 93 bf 03 	sts	0x03BF, r25
   15dd2:	10 92 c0 03 	sts	0x03C0, r1
   15dd6:	80 91 65 00 	lds	r24, 0x0065
   15dda:	8d 7f       	andi	r24, 0xFD	; 253
   15ddc:	80 93 65 00 	sts	0x0065, r24
			if(__sec_par)
   15de0:	80 91 99 04 	lds	r24, 0x0499
   15de4:	88 23       	and	r24, r24
   15de6:	31 f0       	breq	.+12     	; 0x15df4 <_key_scan+0x9e>
				_SEC_ON;
   15de8:	90 93 c7 03 	sts	0x03C7, r25
   15dec:	10 92 ff 03 	sts	0x03FF, r1
   15df0:	10 92 c8 03 	sts	0x03C8, r1

			if(_IS1st){
   15df4:	80 91 c1 03 	lds	r24, 0x03C1
   15df8:	88 23       	and	r24, r24
   15dfa:	71 f4       	brne	.+28     	; 0x15e18 <_key_scan+0xc2>
				if(	__key == _KEY_CANCEL || __key == _KEY_ENTER)
   15dfc:	27 3e       	cpi	r18, 0xE7	; 231
   15dfe:	11 f0       	breq	.+4      	; 0x15e04 <_key_scan+0xae>
   15e00:	27 3b       	cpi	r18, 0xB7	; 183
   15e02:	31 f4       	brne	.+12     	; 0x15e10 <_key_scan+0xba>
					if(__lock_num)
   15e04:	80 91 be 03 	lds	r24, 0x03BE
   15e08:	88 23       	and	r24, r24
   15e0a:	11 f0       	breq	.+4      	; 0x15e10 <_key_scan+0xba>
						__lock_num = 0;
   15e0c:	10 92 be 03 	sts	0x03BE, r1
				_PAD_2nd;
   15e10:	81 e0       	ldi	r24, 0x01	; 1
   15e12:	80 93 c1 03 	sts	0x03C1, r24
   15e16:	59 c0       	rjmp	.+178    	; 0x15eca <_key_scan+0x174>
				//_spi_tx(0x24, _SPI_SLAVE, "~");
				_delay_ms(5);
				return __key;
			}
			if(_IS2nd){
   15e18:	81 30       	cpi	r24, 0x01	; 1
   15e1a:	09 f0       	breq	.+2      	; 0x15e1e <_key_scan+0xc8>
   15e1c:	5c c0       	rjmp	.+184    	; 0x15ed6 <_key_scan+0x180>
				if(__select==_PAD_MULTI){
   15e1e:	12 30       	cpi	r17, 0x02	; 2
   15e20:	21 f5       	brne	.+72     	; 0x15e6a <_key_scan+0x114>
					if(	__key==_KEY_0 || __key==_KEY_1 || __key==_KEY_2 || __key==_KEY_3||
   15e22:	27 3d       	cpi	r18, 0xD7	; 215
   15e24:	91 f0       	breq	.+36     	; 0x15e4a <_key_scan+0xf4>
   15e26:	2e 3e       	cpi	r18, 0xEE	; 238
   15e28:	81 f0       	breq	.+32     	; 0x15e4a <_key_scan+0xf4>
   15e2a:	2e 3d       	cpi	r18, 0xDE	; 222
   15e2c:	71 f0       	breq	.+28     	; 0x15e4a <_key_scan+0xf4>
   15e2e:	2e 3b       	cpi	r18, 0xBE	; 190
   15e30:	61 f0       	breq	.+24     	; 0x15e4a <_key_scan+0xf4>
   15e32:	2d 3e       	cpi	r18, 0xED	; 237
   15e34:	51 f0       	breq	.+20     	; 0x15e4a <_key_scan+0xf4>
   15e36:	2d 3d       	cpi	r18, 0xDD	; 221
   15e38:	41 f0       	breq	.+16     	; 0x15e4a <_key_scan+0xf4>
   15e3a:	2d 3b       	cpi	r18, 0xBD	; 189
   15e3c:	31 f0       	breq	.+12     	; 0x15e4a <_key_scan+0xf4>
   15e3e:	2b 3e       	cpi	r18, 0xEB	; 235
   15e40:	21 f0       	breq	.+8      	; 0x15e4a <_key_scan+0xf4>
   15e42:	2b 3d       	cpi	r18, 0xDB	; 219
   15e44:	11 f0       	breq	.+4      	; 0x15e4a <_key_scan+0xf4>
   15e46:	2b 3b       	cpi	r18, 0xBB	; 187
   15e48:	81 f4       	brne	.+32     	; 0x15e6a <_key_scan+0x114>
						__key==_KEY_4 || __key==_KEY_5 || __key==_KEY_6 ||
						__key==_KEY_7 || __key==_KEY_8 || __key==_KEY_9){
						if(__lock_num){
   15e4a:	80 91 be 03 	lds	r24, 0x03BE
   15e4e:	88 23       	and	r24, r24
   15e50:	49 f0       	breq	.+18     	; 0x15e64 <_key_scan+0x10e>
							_SHIFT_SET;
   15e52:	81 e0       	ldi	r24, 0x01	; 1
   15e54:	80 93 c2 03 	sts	0x03C2, r24
   15e58:	10 92 c3 03 	sts	0x03C3, r1
							CURSOR_HIDE;
   15e5c:	8c e0       	ldi	r24, 0x0C	; 12
   15e5e:	0e 94 5e ac 	call	0x158bc	; 0x158bc <lcd_command>
   15e62:	03 c0       	rjmp	.+6      	; 0x15e6a <_key_scan+0x114>
						}
						else
							__lock_num = 1;
   15e64:	81 e0       	ldi	r24, 0x01	; 1
   15e66:	80 93 be 03 	sts	0x03BE, r24
													 {'9', 'W', 'X', 'Y', 'Z', '\0'}}};
const unsigned char __maxchar[10] PROGMEM = {2, 4, 3, 3, 3, 3, 3, 4, 3, 4};

char _key_hit(void){
	unsigned char	i, keyhit=0x00;
	unsigned char	outmap[4] = {0xef, 0xdf, 0xbf, 0x7f};
   15e6a:	ff ee       	ldi	r31, 0xEF	; 239
   15e6c:	8f 2e       	mov	r8, r31
   15e6e:	ef ed       	ldi	r30, 0xDF	; 223
   15e70:	9e 2e       	mov	r9, r30
   15e72:	7f eb       	ldi	r23, 0xBF	; 191
   15e74:	a7 2e       	mov	r10, r23
   15e76:	6f e7       	ldi	r22, 0x7F	; 127
   15e78:	b6 2e       	mov	r11, r22
   15e7a:	6e 01       	movw	r12, r28
   15e7c:	08 94       	sec
   15e7e:	c1 1c       	adc	r12, r1
   15e80:	d1 1c       	adc	r13, r1
   15e82:	0a ef       	ldi	r16, 0xFA	; 250
   15e84:	10 e0       	ldi	r17, 0x00	; 0

	for(i=0; i<4; i++){
   15e86:	55 e0       	ldi	r21, 0x05	; 5
   15e88:	e5 2e       	mov	r14, r21
   15e8a:	f1 2c       	mov	r15, r1
   15e8c:	ec 0e       	add	r14, r28
   15e8e:	fd 1e       	adc	r15, r29
													 {'9', 'W', 'X', 'Y', 'Z', '\0'}}};
const unsigned char __maxchar[10] PROGMEM = {2, 4, 3, 3, 3, 3, 3, 4, 3, 4};

char _key_hit(void){
	unsigned char	i, keyhit=0x00;
	unsigned char	outmap[4] = {0xef, 0xdf, 0xbf, 0x7f};
   15e90:	89 82       	std	Y+1, r8	; 0x01
   15e92:	9a 82       	std	Y+2, r9	; 0x02
   15e94:	ab 82       	std	Y+3, r10	; 0x03
   15e96:	bc 82       	std	Y+4, r11	; 0x04
   15e98:	d6 01       	movw	r26, r12
   15e9a:	c8 01       	movw	r24, r16
   15e9c:	01 97       	sbiw	r24, 0x01	; 1
   15e9e:	f1 f7       	brne	.-4      	; 0x15e9c <_key_scan+0x146>

	for(i=0; i<4; i++){
		_delay_ms(1);
		_KEY_PORT = outmap[i];
   15ea0:	8c 91       	ld	r24, X
   15ea2:	80 93 62 00 	sts	0x0062, r24
   15ea6:	f8 01       	movw	r30, r16
   15ea8:	31 97       	sbiw	r30, 0x01	; 1
   15eaa:	f1 f7       	brne	.-4      	; 0x15ea8 <_key_scan+0x152>
		_delay_ms(1);
		keyhit = _KEY_MATRIX;
   15eac:	90 b1       	in	r25, 0x00	; 0
		if (keyhit!=outmap[i]) 
   15eae:	98 17       	cp	r25, r24
   15eb0:	21 f4       	brne	.+8      	; 0x15eba <_key_scan+0x164>
   15eb2:	11 96       	adiw	r26, 0x01	; 1

char _key_hit(void){
	unsigned char	i, keyhit=0x00;
	unsigned char	outmap[4] = {0xef, 0xdf, 0xbf, 0x7f};

	for(i=0; i<4; i++){
   15eb4:	ae 15       	cp	r26, r14
   15eb6:	bf 05       	cpc	r27, r15
   15eb8:	81 f7       	brne	.-32     	; 0x15e9a <_key_scan+0x144>
							__lock_num = 1;
					}
				}
				do{
					__key = _key_hit();
					__key = _key_crr(__key);
   15eba:	89 2f       	mov	r24, r25
   15ebc:	0e 94 ea ad 	call	0x15bd4	; 0x15bd4 <_key_crr>
   15ec0:	28 2f       	mov	r18, r24
				}while(__key!=_KEY_NULL);
   15ec2:	88 23       	and	r24, r24
   15ec4:	29 f7       	brne	.-54     	; 0x15e90 <_key_scan+0x13a>
				_PAD_1st;
   15ec6:	10 92 c1 03 	sts	0x03C1, r1
   15eca:	82 ee       	ldi	r24, 0xE2	; 226
   15ecc:	94 e0       	ldi	r25, 0x04	; 4
   15ece:	01 97       	sbiw	r24, 0x01	; 1
   15ed0:	f1 f7       	brne	.-4      	; 0x15ece <_key_scan+0x178>
   15ed2:	03 c0       	rjmp	.+6      	; 0x15eda <_key_scan+0x184>
				_delay_ms(5);
				return _KEY_NULL;
   15ed4:	20 e0       	ldi	r18, 0x00	; 0
			}
		}
	}
	_PAD_1st;
   15ed6:	10 92 c1 03 	sts	0x03C1, r1
	return __key;
}
   15eda:	82 2f       	mov	r24, r18
   15edc:	0f 90       	pop	r0
   15ede:	0f 90       	pop	r0
   15ee0:	0f 90       	pop	r0
   15ee2:	0f 90       	pop	r0
   15ee4:	cf 91       	pop	r28
   15ee6:	df 91       	pop	r29
   15ee8:	1f 91       	pop	r17
   15eea:	0f 91       	pop	r16
   15eec:	ff 90       	pop	r15
   15eee:	ef 90       	pop	r14
   15ef0:	df 90       	pop	r13
   15ef2:	cf 90       	pop	r12
   15ef4:	bf 90       	pop	r11
   15ef6:	af 90       	pop	r10
   15ef8:	9f 90       	pop	r9
   15efa:	8f 90       	pop	r8
   15efc:	08 95       	ret

00015efe <_spi_init>:
unsigned char	__spi_i;
unsigned char	__spi_isstart = 0;
unsigned char	__spi_ismessage = 0;

void _spi_init(unsigned char __mode, unsigned char __interrupt){
	if(__mode){
   15efe:	88 23       	and	r24, r24
   15f00:	41 f0       	breq	.+16     	; 0x15f12 <_spi_init+0x14>
		_SPI_DDR = (1 << _SPI_MOSI) | (1 << _SPI_SCK);
   15f02:	86 e0       	ldi	r24, 0x06	; 6
   15f04:	87 bb       	out	0x17, r24	; 23
		if(__interrupt)
   15f06:	66 23       	and	r22, r22
   15f08:	11 f0       	breq	.+4      	; 0x15f0e <_spi_init+0x10>
			SPCR = (1 << SPIE) | (1 << SPE) | (1 << MSTR) | (1 << SPR1);
   15f0a:	82 ed       	ldi	r24, 0xD2	; 210
   15f0c:	09 c0       	rjmp	.+18     	; 0x15f20 <_spi_init+0x22>
		else
			SPCR = (1 << SPE) | (1 << MSTR) | (1 << SPR1);
   15f0e:	82 e5       	ldi	r24, 0x52	; 82
   15f10:	07 c0       	rjmp	.+14     	; 0x15f20 <_spi_init+0x22>
	}
	else{
		_SPI_DDR = (1 << _SPI_MISO);
   15f12:	88 e0       	ldi	r24, 0x08	; 8
   15f14:	87 bb       	out	0x17, r24	; 23
		if(__interrupt)
   15f16:	66 23       	and	r22, r22
   15f18:	11 f0       	breq	.+4      	; 0x15f1e <_spi_init+0x20>
			SPCR = (1 << SPIE) | (1 << SPE);
   15f1a:	80 ec       	ldi	r24, 0xC0	; 192
   15f1c:	01 c0       	rjmp	.+2      	; 0x15f20 <_spi_init+0x22>
		else
			SPCR = (1 << SPE);
   15f1e:	80 e4       	ldi	r24, 0x40	; 64
   15f20:	8d b9       	out	0x0d, r24	; 13
   15f22:	08 95       	ret

00015f24 <_spi_enable>:
	}
}

void _spi_enable(unsigned char __select){
	if(__select == 0){
   15f24:	88 23       	and	r24, r24
   15f26:	19 f4       	brne	.+6      	; 0x15f2e <_spi_enable+0xa>
		sbi(_SLAVE_PORT, _SLAVE_PIN);
   15f28:	db 9a       	sbi	0x1b, 3	; 27
		sbi(_MMC_PORT, _MMC_PIN);
   15f2a:	1b 9a       	sbi	0x03, 3	; 3
   15f2c:	08 95       	ret
	}
	if(__select == 1){
   15f2e:	81 30       	cpi	r24, 0x01	; 1
   15f30:	39 f4       	brne	.+14     	; 0x15f40 <_spi_enable+0x1c>
		sbi(_MMC_PORT, _MMC_PIN);
   15f32:	1b 9a       	sbi	0x03, 3	; 3
   15f34:	82 ee       	ldi	r24, 0xE2	; 226
   15f36:	94 e0       	ldi	r25, 0x04	; 4
   15f38:	01 97       	sbiw	r24, 0x01	; 1
   15f3a:	f1 f7       	brne	.-4      	; 0x15f38 <_spi_enable+0x14>
		_delay_ms(5);
		cbi(_SLAVE_PORT, _SLAVE_PIN);
   15f3c:	db 98       	cbi	0x1b, 3	; 27
   15f3e:	08 95       	ret
	}
	if(__select == 2){
   15f40:	82 30       	cpi	r24, 0x02	; 2
   15f42:	31 f4       	brne	.+12     	; 0x15f50 <_spi_enable+0x2c>
		sbi(_SLAVE_PORT, _SLAVE_PIN);
   15f44:	db 9a       	sbi	0x1b, 3	; 27
   15f46:	82 ee       	ldi	r24, 0xE2	; 226
   15f48:	94 e0       	ldi	r25, 0x04	; 4
   15f4a:	01 97       	sbiw	r24, 0x01	; 1
   15f4c:	f1 f7       	brne	.-4      	; 0x15f4a <_spi_enable+0x26>
		_delay_ms(5);
		cbi(_MMC_PORT, _MMC_PIN);
   15f4e:	1b 98       	cbi	0x03, 3	; 3
   15f50:	08 95       	ret

00015f52 <_spi>:
	}
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
   15f52:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1 << SPIF)));
   15f54:	77 9b       	sbis	0x0e, 7	; 14
   15f56:	fe cf       	rjmp	.-4      	; 0x15f54 <_spi+0x2>
	return SPDR;
   15f58:	8f b1       	in	r24, 0x0f	; 15
}
   15f5a:	08 95       	ret

00015f5c <_spi_rx>:


unsigned char _spi_rx(unsigned char __select){
	unsigned char __i = 0;

	_spi_enable(__select);
   15f5c:	0e 94 92 af 	call	0x15f24	; 0x15f24 <_spi_enable>
		cbi(_MMC_PORT, _MMC_PIN);
	}
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
   15f60:	81 e4       	ldi	r24, 0x41	; 65
   15f62:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1 << SPIF)));
   15f64:	77 9b       	sbis	0x0e, 7	; 14
   15f66:	fe cf       	rjmp	.-4      	; 0x15f64 <_spi_rx+0x8>
	return SPDR;
   15f68:	8f b1       	in	r24, 0x0f	; 15
unsigned char _spi_rx(unsigned char __select){
	unsigned char __i = 0;

	_spi_enable(__select);

		__spi_char = _spi(0x41);
   15f6a:	80 93 8e 0e 	sts	0x0E8E, r24
		if(__spi_char==0xff) return 0;
   15f6e:	8f 3f       	cpi	r24, 0xFF	; 255
   15f70:	11 f4       	brne	.+4      	; 0x15f76 <_spi_rx+0x1a>
   15f72:	80 e0       	ldi	r24, 0x00	; 0
   15f74:	08 95       	ret
		if(__spi_char==0x55) return 1;
   15f76:	85 35       	cpi	r24, 0x55	; 85
   15f78:	11 f4       	brne	.+4      	; 0x15f7e <_spi_rx+0x22>
   15f7a:	81 e0       	ldi	r24, 0x01	; 1
   15f7c:	08 95       	ret
		if(__spi_char==0x02) return 2;
   15f7e:	82 30       	cpi	r24, 0x02	; 2
   15f80:	21 f0       	breq	.+8      	; 0x15f8a <_spi_rx+0x2e>
	_spi_enable(_SPI_NONE);
   15f82:	80 e0       	ldi	r24, 0x00	; 0
   15f84:	0e 94 92 af 	call	0x15f24	; 0x15f24 <_spi_enable>
   15f88:	85 e1       	ldi	r24, 0x15	; 21
	return 21;
}
   15f8a:	08 95       	ret

00015f8c <_spi_tx>:

unsigned char _spi_tx(unsigned char __command, unsigned char __select, char* __message){
   15f8c:	1f 93       	push	r17
   15f8e:	cf 93       	push	r28
   15f90:	df 93       	push	r29
   15f92:	18 2f       	mov	r17, r24
   15f94:	86 2f       	mov	r24, r22
   15f96:	ea 01       	movw	r28, r20
	_spi_enable(__select);
   15f98:	0e 94 92 af 	call	0x15f24	; 0x15f24 <_spi_enable>
		cbi(_MMC_PORT, _MMC_PIN);
	}
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
   15f9c:	8b e7       	ldi	r24, 0x7B	; 123
   15f9e:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1 << SPIF)));
   15fa0:	77 9b       	sbis	0x0e, 7	; 14
   15fa2:	fe cf       	rjmp	.-4      	; 0x15fa0 <_spi_tx+0x14>
	return SPDR;
   15fa4:	8f b1       	in	r24, 0x0f	; 15
		cbi(_MMC_PORT, _MMC_PIN);
	}
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
   15fa6:	1f b9       	out	0x0f, r17	; 15
	while(!(SPSR & (1 << SPIF)));
   15fa8:	77 9b       	sbis	0x0e, 7	; 14
   15faa:	fe cf       	rjmp	.-4      	; 0x15fa8 <_spi_tx+0x1c>
	return SPDR;
   15fac:	8f b1       	in	r24, 0x0f	; 15
unsigned char _spi_tx(unsigned char __command, unsigned char __select, char* __message){
	_spi_enable(__select);
	_spi(0x7B);
	_spi(__command);

	if(strlen(__message) > 0){
   15fae:	88 81       	ld	r24, Y
   15fb0:	88 23       	and	r24, r24
   15fb2:	91 f0       	breq	.+36     	; 0x15fd8 <_spi_tx+0x4c>
		cbi(_MMC_PORT, _MMC_PIN);
	}
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
   15fb4:	88 e2       	ldi	r24, 0x28	; 40
   15fb6:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1 << SPIF)));
   15fb8:	77 9b       	sbis	0x0e, 7	; 14
   15fba:	fe cf       	rjmp	.-4      	; 0x15fb8 <_spi_tx+0x2c>
   15fbc:	04 c0       	rjmp	.+8      	; 0x15fc6 <_spi_tx+0x3a>
		cbi(_MMC_PORT, _MMC_PIN);
	}
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
   15fbe:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1 << SPIF)));
   15fc0:	77 9b       	sbis	0x0e, 7	; 14
   15fc2:	fe cf       	rjmp	.-4      	; 0x15fc0 <_spi_tx+0x34>
	_spi(__command);

	if(strlen(__message) > 0){
		_spi(0x28);
		while(*__message)
			_spi(*__message++);
   15fc4:	21 96       	adiw	r28, 0x01	; 1
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
	while(!(SPSR & (1 << SPIF)));
	return SPDR;
   15fc6:	8f b1       	in	r24, 0x0f	; 15
	_spi(0x7B);
	_spi(__command);

	if(strlen(__message) > 0){
		_spi(0x28);
		while(*__message)
   15fc8:	88 81       	ld	r24, Y
   15fca:	88 23       	and	r24, r24
   15fcc:	c1 f7       	brne	.-16     	; 0x15fbe <_spi_tx+0x32>
		cbi(_MMC_PORT, _MMC_PIN);
	}
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
   15fce:	89 e2       	ldi	r24, 0x29	; 41
   15fd0:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1 << SPIF)));
   15fd2:	77 9b       	sbis	0x0e, 7	; 14
   15fd4:	fe cf       	rjmp	.-4      	; 0x15fd2 <_spi_tx+0x46>
	return SPDR;
   15fd6:	8f b1       	in	r24, 0x0f	; 15
		cbi(_MMC_PORT, _MMC_PIN);
	}
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
   15fd8:	8d e7       	ldi	r24, 0x7D	; 125
   15fda:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1 << SPIF)));
   15fdc:	77 9b       	sbis	0x0e, 7	; 14
   15fde:	fe cf       	rjmp	.-4      	; 0x15fdc <_spi_tx+0x50>
	return SPDR;
   15fe0:	8f b1       	in	r24, 0x0f	; 15
			_spi(*__message++);
		_spi(0x29);
	}

	_spi(0x7D);
	_spi_enable(_SPI_NONE);
   15fe2:	80 e0       	ldi	r24, 0x00	; 0
   15fe4:	0e 94 92 af 	call	0x15f24	; 0x15f24 <_spi_enable>
	return 0;
}
   15fe8:	80 e0       	ldi	r24, 0x00	; 0
   15fea:	df 91       	pop	r29
   15fec:	cf 91       	pop	r28
   15fee:	1f 91       	pop	r17
   15ff0:	08 95       	ret

00015ff2 <_spi_txnum>:

unsigned char _spi_txnum(unsigned char __command, unsigned char __select, char* __message, unsigned char __num){
   15ff2:	ff 92       	push	r15
   15ff4:	0f 93       	push	r16
   15ff6:	1f 93       	push	r17
   15ff8:	86 2f       	mov	r24, r22
   15ffa:	14 2f       	mov	r17, r20
   15ffc:	05 2f       	mov	r16, r21
   15ffe:	f2 2e       	mov	r15, r18
	unsigned char	__i;

	_spi_enable(__select);
   16000:	0e 94 92 af 	call	0x15f24	; 0x15f24 <_spi_enable>
		cbi(_MMC_PORT, _MMC_PIN);
	}
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
   16004:	82 e0       	ldi	r24, 0x02	; 2
   16006:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1 << SPIF)));
   16008:	77 9b       	sbis	0x0e, 7	; 14
   1600a:	fe cf       	rjmp	.-4      	; 0x16008 <_spi_txnum+0x16>
	return SPDR;
   1600c:	8f b1       	in	r24, 0x0f	; 15
	unsigned char	__i;

	_spi_enable(__select);
	_spi(0x02);

	if(__num > 0){
   1600e:	ff 20       	and	r15, r15
   16010:	79 f0       	breq	.+30     	; 0x16030 <_spi_txnum+0x3e>
   16012:	81 2f       	mov	r24, r17
   16014:	90 2f       	mov	r25, r16
   16016:	9c 01       	movw	r18, r24
   16018:	f9 01       	movw	r30, r18
   1601a:	90 e0       	ldi	r25, 0x00	; 0
   1601c:	07 c0       	rjmp	.+14     	; 0x1602c <_spi_txnum+0x3a>
		for(__i = 0; __i < __num; __i++) _spi(__message[__i]);
   1601e:	80 81       	ld	r24, Z
		cbi(_MMC_PORT, _MMC_PIN);
	}
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
   16020:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1 << SPIF)));
   16022:	77 9b       	sbis	0x0e, 7	; 14
   16024:	fe cf       	rjmp	.-4      	; 0x16022 <_spi_txnum+0x30>
	return SPDR;
   16026:	8f b1       	in	r24, 0x0f	; 15

	_spi_enable(__select);
	_spi(0x02);

	if(__num > 0){
		for(__i = 0; __i < __num; __i++) _spi(__message[__i]);
   16028:	9f 5f       	subi	r25, 0xFF	; 255
   1602a:	31 96       	adiw	r30, 0x01	; 1
   1602c:	9f 15       	cp	r25, r15
   1602e:	b8 f3       	brcs	.-18     	; 0x1601e <_spi_txnum+0x2c>
		cbi(_MMC_PORT, _MMC_PIN);
	}
}

unsigned char _spi(unsigned char __data){
	SPDR = __data;
   16030:	83 e0       	ldi	r24, 0x03	; 3
   16032:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1 << SPIF)));
   16034:	77 9b       	sbis	0x0e, 7	; 14
   16036:	fe cf       	rjmp	.-4      	; 0x16034 <_spi_txnum+0x42>
	return SPDR;
   16038:	8f b1       	in	r24, 0x0f	; 15
	if(__num > 0){
		for(__i = 0; __i < __num; __i++) _spi(__message[__i]);
				}// for

	_spi(0x03);
	_spi_enable(_SPI_NONE);
   1603a:	80 e0       	ldi	r24, 0x00	; 0
   1603c:	0e 94 92 af 	call	0x15f24	; 0x15f24 <_spi_enable>
	return 0;
}
   16040:	80 e0       	ldi	r24, 0x00	; 0
   16042:	1f 91       	pop	r17
   16044:	0f 91       	pop	r16
   16046:	ff 90       	pop	r15
   16048:	08 95       	ret

0001604a <_spi_interrupt>:

unsigned char _spi_interrupt(void){
	__spi_char = SPDR;
   1604a:	9f b1       	in	r25, 0x0f	; 15
   1604c:	90 93 8e 0e 	sts	0x0E8E, r25

	if(__spi_char == 0xFF){
   16050:	9f 3f       	cpi	r25, 0xFF	; 255
   16052:	e9 f4       	brne	.+58     	; 0x1608e <_spi_interrupt+0x44>
		if(__spi_istransmit){
   16054:	80 91 fb 03 	lds	r24, 0x03FB
   16058:	88 23       	and	r24, r24
   1605a:	b9 f0       	breq	.+46     	; 0x1608a <_spi_interrupt+0x40>
			SPDR = __command[__spi_i];
   1605c:	90 91 8d 0e 	lds	r25, 0x0E8D
   16060:	e9 2f       	mov	r30, r25
   16062:	f0 e0       	ldi	r31, 0x00	; 0
   16064:	e7 53       	subi	r30, 0x37	; 55
   16066:	fc 4f       	sbci	r31, 0xFC	; 252
   16068:	80 81       	ld	r24, Z
   1606a:	8f b9       	out	0x0f, r24	; 15
			if(__command[__spi_i] == 0x7D){
   1606c:	8d 37       	cpi	r24, 0x7D	; 125
   1606e:	19 f4       	brne	.+6      	; 0x16076 <_spi_interrupt+0x2c>
				__spi_i = 0;
   16070:	10 92 8d 0e 	sts	0x0E8D, r1
   16074:	07 c0       	rjmp	.+14     	; 0x16084 <_spi_interrupt+0x3a>
				__spi_istransmit = 0;
			}
			else{
				__spi_i++;
   16076:	89 2f       	mov	r24, r25
   16078:	8f 5f       	subi	r24, 0xFF	; 255
   1607a:	80 93 8d 0e 	sts	0x0E8D, r24
				if(__spi_i == _MAX_COMMAND)
   1607e:	82 33       	cpi	r24, 0x32	; 50
   16080:	09 f0       	breq	.+2      	; 0x16084 <_spi_interrupt+0x3a>
   16082:	3f c0       	rjmp	.+126    	; 0x16102 <_spi_interrupt+0xb8>
					__spi_istransmit = 0;
   16084:	10 92 fb 03 	sts	0x03FB, r1
   16088:	3c c0       	rjmp	.+120    	; 0x16102 <_spi_interrupt+0xb8>
			}
		}
		else
			SPDR = 0xFF;
   1608a:	9f b9       	out	0x0f, r25	; 15
   1608c:	3a c0       	rjmp	.+116    	; 0x16102 <_spi_interrupt+0xb8>
	}
	else{
		if(__spi_char == 0x7D && __spi_isstart){
   1608e:	9d 37       	cpi	r25, 0x7D	; 125
   16090:	69 f4       	brne	.+26     	; 0x160ac <_spi_interrupt+0x62>
   16092:	80 91 c4 03 	lds	r24, 0x03C4
   16096:	88 23       	and	r24, r24
   16098:	49 f0       	breq	.+18     	; 0x160ac <_spi_interrupt+0x62>
			__spi_isstart = 0;
   1609a:	10 92 c4 03 	sts	0x03C4, r1
			__spi_ismessage = 0;
   1609e:	10 92 c5 03 	sts	0x03C5, r1
			__spi_i = 0;
   160a2:	10 92 8d 0e 	sts	0x0E8D, r1
			__command_flag = 1;
   160a6:	81 e0       	ldi	r24, 0x01	; 1
   160a8:	80 93 fe 03 	sts	0x03FE, r24
		}
		if(__spi_isstart && __spi_ismessage){
   160ac:	20 91 c4 03 	lds	r18, 0x03C4
   160b0:	22 23       	and	r18, r18
   160b2:	f1 f0       	breq	.+60     	; 0x160f0 <_spi_interrupt+0xa6>
   160b4:	80 91 c5 03 	lds	r24, 0x03C5
   160b8:	88 23       	and	r24, r24
   160ba:	29 f1       	breq	.+74     	; 0x16106 <_spi_interrupt+0xbc>
			if(__spi_char != 0x29){
   160bc:	99 32       	cpi	r25, 0x29	; 41
   160be:	c1 f0       	breq	.+48     	; 0x160f0 <_spi_interrupt+0xa6>
				__package[__spi_i] = __spi_char;
   160c0:	80 91 8d 0e 	lds	r24, 0x0E8D
   160c4:	e8 2f       	mov	r30, r24
   160c6:	f0 e0       	ldi	r31, 0x00	; 0
   160c8:	ed 5f       	subi	r30, 0xFD	; 253
   160ca:	fb 4f       	sbci	r31, 0xFB	; 251
   160cc:	90 83       	st	Z, r25
				__package[__spi_i + 1] = '\0';
   160ce:	11 82       	std	Z+1, r1	; 0x01
				__spi_i++;
   160d0:	8f 5f       	subi	r24, 0xFF	; 255
   160d2:	80 93 8d 0e 	sts	0x0E8D, r24
				if(__spi_i == _MAX_PACKAGE)
   160d6:	82 38       	cpi	r24, 0x82	; 130
   160d8:	59 f4       	brne	.+22     	; 0x160f0 <_spi_interrupt+0xa6>
					__spi_i = 0;
   160da:	10 92 8d 0e 	sts	0x0E8D, r1
   160de:	08 c0       	rjmp	.+16     	; 0x160f0 <_spi_interrupt+0xa6>
			}
		}
		if(__spi_isstart && !__spi_ismessage){
			if(__spi_char == 0x28){
				__spi_ismessage = 1;
   160e0:	81 e0       	ldi	r24, 0x01	; 1
   160e2:	80 93 c5 03 	sts	0x03C5, r24
				__spi_i = 0;
   160e6:	10 92 8d 0e 	sts	0x0E8D, r1
   160ea:	0b c0       	rjmp	.+22     	; 0x16102 <_spi_interrupt+0xb8>
			}
			else
				__command_set = __spi_char;
   160ec:	90 93 00 04 	sts	0x0400, r25
		}
		if(__spi_char == 0x7B && !__spi_isstart){
   160f0:	9b 37       	cpi	r25, 0x7B	; 123
   160f2:	39 f4       	brne	.+14     	; 0x16102 <_spi_interrupt+0xb8>
   160f4:	22 23       	and	r18, r18
   160f6:	29 f4       	brne	.+10     	; 0x16102 <_spi_interrupt+0xb8>
			__spi_isstart = 1;
   160f8:	81 e0       	ldi	r24, 0x01	; 1
   160fa:	80 93 c4 03 	sts	0x03C4, r24
			__spi_ismessage = 0;
   160fe:	10 92 c5 03 	sts	0x03C5, r1
		}
	}

	return 0;
}
   16102:	80 e0       	ldi	r24, 0x00	; 0
   16104:	08 95       	ret
				if(__spi_i == _MAX_PACKAGE)
					__spi_i = 0;
			}
		}
		if(__spi_isstart && !__spi_ismessage){
			if(__spi_char == 0x28){
   16106:	98 32       	cpi	r25, 0x28	; 40
   16108:	89 f7       	brne	.-30     	; 0x160ec <_spi_interrupt+0xa2>
   1610a:	ea cf       	rjmp	.-44     	; 0x160e0 <_spi_interrupt+0x96>

0001610c <_spi_command>:
	}

	return 0;
}

void _spi_command(unsigned char __cmd, char* __cell){
   1610c:	fb 01       	movw	r30, r22
	unsigned char __i = 0;

	__command[__i++] = 0x7B;
   1610e:	9b e7       	ldi	r25, 0x7B	; 123
   16110:	90 93 c9 03 	sts	0x03C9, r25
	__command[__i++] = __cmd;
   16114:	80 93 ca 03 	sts	0x03CA, r24

	if(strlen(__cell) > 0){
   16118:	80 81       	ld	r24, Z
   1611a:	88 23       	and	r24, r24
   1611c:	11 f4       	brne	.+4      	; 0x16122 <_spi_command+0x16>
   1611e:	92 e0       	ldi	r25, 0x02	; 2
   16120:	16 c0       	rjmp	.+44     	; 0x1614e <_spi_command+0x42>
		__command[__i++] = 0x28;
   16122:	88 e2       	ldi	r24, 0x28	; 40
   16124:	80 93 cb 03 	sts	0x03CB, r24
   16128:	83 e0       	ldi	r24, 0x03	; 3
   1612a:	05 c0       	rjmp	.+10     	; 0x16136 <_spi_command+0x2a>

		while(*__cell)
			__command[__i++] = *__cell++;
   1612c:	a7 53       	subi	r26, 0x37	; 55
   1612e:	bc 4f       	sbci	r27, 0xFC	; 252
   16130:	9c 93       	st	X, r25
   16132:	82 2f       	mov	r24, r18
   16134:	31 96       	adiw	r30, 0x01	; 1
	__command[__i++] = __cmd;

	if(strlen(__cell) > 0){
		__command[__i++] = 0x28;

		while(*__cell)
   16136:	90 81       	ld	r25, Z
   16138:	a8 2f       	mov	r26, r24
   1613a:	b0 e0       	ldi	r27, 0x00	; 0
   1613c:	28 2f       	mov	r18, r24
   1613e:	2f 5f       	subi	r18, 0xFF	; 255
   16140:	99 23       	and	r25, r25
   16142:	a1 f7       	brne	.-24     	; 0x1612c <_spi_command+0x20>
			__command[__i++] = *__cell++;

		__command[__i++] = 0x29;
   16144:	a7 53       	subi	r26, 0x37	; 55
   16146:	bc 4f       	sbci	r27, 0xFC	; 252
   16148:	89 e2       	ldi	r24, 0x29	; 41
   1614a:	8c 93       	st	X, r24
   1614c:	92 2f       	mov	r25, r18
	}

	__command[__i++] = 0x7D;
   1614e:	e9 2f       	mov	r30, r25
   16150:	f0 e0       	ldi	r31, 0x00	; 0
   16152:	e7 53       	subi	r30, 0x37	; 55
   16154:	fc 4f       	sbci	r31, 0xFC	; 252
   16156:	8d e7       	ldi	r24, 0x7D	; 125
   16158:	80 83       	st	Z, r24
	__command[__i++] = '\0';
   1615a:	9f 5f       	subi	r25, 0xFF	; 255
   1615c:	e9 2f       	mov	r30, r25
   1615e:	f0 e0       	ldi	r31, 0x00	; 0
   16160:	e7 53       	subi	r30, 0x37	; 55
   16162:	fc 4f       	sbci	r31, 0xFC	; 252
   16164:	10 82       	st	Z, r1
}
   16166:	08 95       	ret

00016168 <_rtc>:

#include <compat/twi.h>

#include "RTC.h"

unsigned char _rtc(int __addr, int __len, char* __datetime, unsigned char __dir){
   16168:	98 2f       	mov	r25, r24
	int				__twcr;
	unsigned char	__i = 0;
	
	if(__dir){
   1616a:	22 23       	and	r18, r18
   1616c:	09 f4       	brne	.+2      	; 0x16170 <_rtc+0x8>
   1616e:	49 c0       	rjmp	.+146    	; 0x16202 <_rtc+0x9a>
		TWCR = _BV(TWINT) | _BV(TWSTA) | _BV(TWEN);
   16170:	84 ea       	ldi	r24, 0xA4	; 164
   16172:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   16176:	80 91 74 00 	lds	r24, 0x0074
   1617a:	87 ff       	sbrs	r24, 7
   1617c:	fc cf       	rjmp	.-8      	; 0x16176 <_rtc+0xe>
		if(TW_STATUS != TW_START)
   1617e:	80 91 71 00 	lds	r24, 0x0071
   16182:	88 7f       	andi	r24, 0xF8	; 248
   16184:	88 30       	cpi	r24, 0x08	; 8
   16186:	09 f0       	breq	.+2      	; 0x1618a <_rtc+0x22>
   16188:	af c0       	rjmp	.+350    	; 0x162e8 <_rtc+0x180>
			return 1;

		TWDR = _DS1307W;
   1618a:	80 ed       	ldi	r24, 0xD0	; 208
   1618c:	80 93 73 00 	sts	0x0073, r24
		TWCR = _BV(TWINT) | _BV(TWEN);
   16190:	84 e8       	ldi	r24, 0x84	; 132
   16192:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   16196:	80 91 74 00 	lds	r24, 0x0074
   1619a:	87 ff       	sbrs	r24, 7
   1619c:	fc cf       	rjmp	.-8      	; 0x16196 <_rtc+0x2e>
		if(TW_STATUS != TW_MT_SLA_ACK)
   1619e:	80 91 71 00 	lds	r24, 0x0071
   161a2:	88 7f       	andi	r24, 0xF8	; 248
   161a4:	88 31       	cpi	r24, 0x18	; 24
   161a6:	09 f0       	breq	.+2      	; 0x161aa <_rtc+0x42>
   161a8:	9f c0       	rjmp	.+318    	; 0x162e8 <_rtc+0x180>
			return 1;

		TWDR = __addr;
   161aa:	90 93 73 00 	sts	0x0073, r25
		TWCR = _BV(TWINT) | _BV(TWEN);
   161ae:	84 e8       	ldi	r24, 0x84	; 132
   161b0:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   161b4:	80 91 74 00 	lds	r24, 0x0074
   161b8:	87 ff       	sbrs	r24, 7
   161ba:	fc cf       	rjmp	.-8      	; 0x161b4 <_rtc+0x4c>
		if(TW_STATUS != TW_MT_DATA_ACK)
   161bc:	80 91 71 00 	lds	r24, 0x0071
   161c0:	88 7f       	andi	r24, 0xF8	; 248
   161c2:	88 32       	cpi	r24, 0x28	; 40
   161c4:	09 f0       	breq	.+2      	; 0x161c8 <_rtc+0x60>
   161c6:	90 c0       	rjmp	.+288    	; 0x162e8 <_rtc+0x180>
   161c8:	9b 01       	movw	r18, r22
			return 1;

		for(; __len > 0; __len--){
			TWDR = __datetime[__i++];
			TWCR = _BV(TWINT) | _BV(TWEN);
   161ca:	94 e8       	ldi	r25, 0x84	; 132
   161cc:	14 c0       	rjmp	.+40     	; 0x161f6 <_rtc+0x8e>
		_rtc_response;
		if(TW_STATUS != TW_MT_DATA_ACK)
			return 1;

		for(; __len > 0; __len--){
			TWDR = __datetime[__i++];
   161ce:	fa 01       	movw	r30, r20
   161d0:	e8 0f       	add	r30, r24
   161d2:	f1 1d       	adc	r31, r1
   161d4:	80 81       	ld	r24, Z
   161d6:	80 93 73 00 	sts	0x0073, r24
			TWCR = _BV(TWINT) | _BV(TWEN);
   161da:	90 93 74 00 	sts	0x0074, r25
			_rtc_response;
   161de:	80 91 74 00 	lds	r24, 0x0074
   161e2:	87 ff       	sbrs	r24, 7
   161e4:	fc cf       	rjmp	.-8      	; 0x161de <_rtc+0x76>
			if(TW_STATUS == TW_MT_DATA_NACK)
   161e6:	80 91 71 00 	lds	r24, 0x0071
   161ea:	88 7f       	andi	r24, 0xF8	; 248
   161ec:	80 33       	cpi	r24, 0x30	; 48
   161ee:	09 f4       	brne	.+2      	; 0x161f2 <_rtc+0x8a>
   161f0:	7b c0       	rjmp	.+246    	; 0x162e8 <_rtc+0x180>
		TWCR = _BV(TWINT) | _BV(TWEN);
		_rtc_response;
		if(TW_STATUS != TW_MT_DATA_ACK)
			return 1;

		for(; __len > 0; __len--){
   161f2:	21 50       	subi	r18, 0x01	; 1
   161f4:	30 40       	sbci	r19, 0x00	; 0
   161f6:	86 2f       	mov	r24, r22
   161f8:	82 1b       	sub	r24, r18
   161fa:	12 16       	cp	r1, r18
   161fc:	13 06       	cpc	r1, r19
   161fe:	3c f3       	brlt	.-50     	; 0x161ce <_rtc+0x66>
   16200:	6e c0       	rjmp	.+220    	; 0x162de <_rtc+0x176>
		}

		TWCR = _BV(TWINT) | _BV(TWSTO) | _BV(TWEN);
	}
	else{
		TWCR =_BV(TWINT) | _BV(TWSTA) | _BV(TWEN);
   16202:	84 ea       	ldi	r24, 0xA4	; 164
   16204:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   16208:	80 91 74 00 	lds	r24, 0x0074
   1620c:	87 ff       	sbrs	r24, 7
   1620e:	fc cf       	rjmp	.-8      	; 0x16208 <_rtc+0xa0>
		if(TW_STATUS != TW_START)
   16210:	80 91 71 00 	lds	r24, 0x0071
   16214:	88 7f       	andi	r24, 0xF8	; 248
   16216:	88 30       	cpi	r24, 0x08	; 8
   16218:	09 f0       	breq	.+2      	; 0x1621c <_rtc+0xb4>
   1621a:	66 c0       	rjmp	.+204    	; 0x162e8 <_rtc+0x180>
			return 1;

		TWDR = _DS1307W;
   1621c:	80 ed       	ldi	r24, 0xD0	; 208
   1621e:	80 93 73 00 	sts	0x0073, r24
		TWCR = _BV(TWINT) | _BV(TWEN);
   16222:	84 e8       	ldi	r24, 0x84	; 132
   16224:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   16228:	80 91 74 00 	lds	r24, 0x0074
   1622c:	87 ff       	sbrs	r24, 7
   1622e:	fc cf       	rjmp	.-8      	; 0x16228 <_rtc+0xc0>
		if(TW_STATUS != TW_MT_SLA_ACK)
   16230:	80 91 71 00 	lds	r24, 0x0071
   16234:	88 7f       	andi	r24, 0xF8	; 248
   16236:	88 31       	cpi	r24, 0x18	; 24
   16238:	09 f0       	breq	.+2      	; 0x1623c <_rtc+0xd4>
   1623a:	56 c0       	rjmp	.+172    	; 0x162e8 <_rtc+0x180>
			return 1;

		TWDR = __addr;
   1623c:	90 93 73 00 	sts	0x0073, r25
		TWCR = _BV(TWINT) | _BV(TWEN);
   16240:	84 e8       	ldi	r24, 0x84	; 132
   16242:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   16246:	80 91 74 00 	lds	r24, 0x0074
   1624a:	87 ff       	sbrs	r24, 7
   1624c:	fc cf       	rjmp	.-8      	; 0x16246 <_rtc+0xde>
		if(TW_STATUS != TW_MT_DATA_ACK)
   1624e:	80 91 71 00 	lds	r24, 0x0071
   16252:	88 7f       	andi	r24, 0xF8	; 248
   16254:	88 32       	cpi	r24, 0x28	; 40
   16256:	09 f0       	breq	.+2      	; 0x1625a <_rtc+0xf2>
   16258:	47 c0       	rjmp	.+142    	; 0x162e8 <_rtc+0x180>
			return 1;

		TWCR =_BV(TWINT) | _BV(TWSTA) | _BV(TWEN);
   1625a:	84 ea       	ldi	r24, 0xA4	; 164
   1625c:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   16260:	80 91 74 00 	lds	r24, 0x0074
   16264:	87 ff       	sbrs	r24, 7
   16266:	fc cf       	rjmp	.-8      	; 0x16260 <_rtc+0xf8>
		if(TW_STATUS != TW_REP_START)
   16268:	80 91 71 00 	lds	r24, 0x0071
   1626c:	88 7f       	andi	r24, 0xF8	; 248
   1626e:	80 31       	cpi	r24, 0x10	; 16
   16270:	d9 f5       	brne	.+118    	; 0x162e8 <_rtc+0x180>
			return 1;

		TWDR = _DS1307R;
   16272:	81 ed       	ldi	r24, 0xD1	; 209
   16274:	80 93 73 00 	sts	0x0073, r24
		TWCR =_BV(TWINT) | _BV(TWEN);
   16278:	84 e8       	ldi	r24, 0x84	; 132
   1627a:	80 93 74 00 	sts	0x0074, r24
		_rtc_response;
   1627e:	80 91 74 00 	lds	r24, 0x0074
   16282:	87 ff       	sbrs	r24, 7
   16284:	fc cf       	rjmp	.-8      	; 0x1627e <_rtc+0x116>
		if(TW_STATUS != TW_MR_SLA_ACK)
   16286:	80 91 71 00 	lds	r24, 0x0071
   1628a:	88 7f       	andi	r24, 0xF8	; 248
   1628c:	80 34       	cpi	r24, 0x40	; 64
   1628e:	61 f5       	brne	.+88     	; 0x162e8 <_rtc+0x180>
   16290:	24 ec       	ldi	r18, 0xC4	; 196
   16292:	30 e0       	ldi	r19, 0x00	; 0
   16294:	90 e0       	ldi	r25, 0x00	; 0
   16296:	20 c0       	rjmp	.+64     	; 0x162d8 <_rtc+0x170>
			return 1;

		for(__twcr = _BV(TWINT) | _BV(TWEN) | _BV(TWEA); __len > 0; __len--){
			if(__len == 1)
   16298:	61 30       	cpi	r22, 0x01	; 1
   1629a:	71 05       	cpc	r23, r1
   1629c:	11 f4       	brne	.+4      	; 0x162a2 <_rtc+0x13a>
   1629e:	24 e8       	ldi	r18, 0x84	; 132
   162a0:	30 e0       	ldi	r19, 0x00	; 0
				__twcr = _BV(TWINT) | _BV(TWEN);
			TWCR = __twcr;
   162a2:	20 93 74 00 	sts	0x0074, r18
			_rtc_response;
   162a6:	80 91 74 00 	lds	r24, 0x0074
   162aa:	87 ff       	sbrs	r24, 7
   162ac:	fc cf       	rjmp	.-8      	; 0x162a6 <_rtc+0x13e>
			if(TW_STATUS == TW_MR_DATA_NACK)
   162ae:	80 91 71 00 	lds	r24, 0x0071
   162b2:	88 7f       	andi	r24, 0xF8	; 248
   162b4:	88 35       	cpi	r24, 0x58	; 88
   162b6:	11 f4       	brne	.+4      	; 0x162bc <_rtc+0x154>
   162b8:	60 e0       	ldi	r22, 0x00	; 0
   162ba:	70 e0       	ldi	r23, 0x00	; 0
				__len = 0;
			if(TW_STATUS == TW_MR_DATA_ACK)
   162bc:	80 91 71 00 	lds	r24, 0x0071
   162c0:	88 7f       	andi	r24, 0xF8	; 248
   162c2:	80 35       	cpi	r24, 0x50	; 80
   162c4:	39 f4       	brne	.+14     	; 0x162d4 <_rtc+0x16c>
				__datetime[__i++] = TWDR;
   162c6:	80 91 73 00 	lds	r24, 0x0073
   162ca:	fa 01       	movw	r30, r20
   162cc:	e9 0f       	add	r30, r25
   162ce:	f1 1d       	adc	r31, r1
   162d0:	80 83       	st	Z, r24
   162d2:	9f 5f       	subi	r25, 0xFF	; 255
		TWCR =_BV(TWINT) | _BV(TWEN);
		_rtc_response;
		if(TW_STATUS != TW_MR_SLA_ACK)
			return 1;

		for(__twcr = _BV(TWINT) | _BV(TWEN) | _BV(TWEA); __len > 0; __len--){
   162d4:	61 50       	subi	r22, 0x01	; 1
   162d6:	70 40       	sbci	r23, 0x00	; 0
   162d8:	16 16       	cp	r1, r22
   162da:	17 06       	cpc	r1, r23
   162dc:	ec f2       	brlt	.-70     	; 0x16298 <_rtc+0x130>
			if(TW_STATUS == TW_MR_DATA_NACK)
				__len = 0;
			if(TW_STATUS == TW_MR_DATA_ACK)
				__datetime[__i++] = TWDR;
		}
		TWCR = _BV(TWINT) | _BV(TWSTO) | _BV(TWEN);
   162de:	84 e9       	ldi	r24, 0x94	; 148
   162e0:	80 93 74 00 	sts	0x0074, r24
   162e4:	80 e0       	ldi	r24, 0x00	; 0
   162e6:	08 95       	ret
   162e8:	81 e0       	ldi	r24, 0x01	; 1
	}

    return 0;
}
   162ea:	08 95       	ret

000162ec <_datetime>:

void _datetime(unsigned char __mode, char* __date, char* __time){
   162ec:	ef 92       	push	r14
   162ee:	ff 92       	push	r15
   162f0:	0f 93       	push	r16
   162f2:	1f 93       	push	r17
   162f4:	df 93       	push	r29
   162f6:	cf 93       	push	r28
   162f8:	cd b7       	in	r28, 0x3d	; 61
   162fa:	de b7       	in	r29, 0x3e	; 62
   162fc:	64 97       	sbiw	r28, 0x14	; 20
   162fe:	0f b6       	in	r0, 0x3f	; 63
   16300:	f8 94       	cli
   16302:	de bf       	out	0x3e, r29	; 62
   16304:	0f be       	out	0x3f, r0	; 63
   16306:	cd bf       	out	0x3d, r28	; 61
   16308:	28 2f       	mov	r18, r24
   1630a:	8b 01       	movw	r16, r22
   1630c:	7a 01       	movw	r14, r20
   1630e:	ae 01       	movw	r20, r28
   16310:	4f 5f       	subi	r20, 0xFF	; 255
   16312:	5f 4f       	sbci	r21, 0xFF	; 255
	char	__datetime[20];

	if(__mode){
   16314:	88 23       	and	r24, r24
   16316:	99 f1       	breq	.+102    	; 0x1637e <_datetime+0x92>
		__datetime[4] = (((__date[0] - 0x30) & 0x0F) << 4) + ((__date[1] - 0x30) & 0x0F);
   16318:	fb 01       	movw	r30, r22
   1631a:	90 81       	ld	r25, Z
   1631c:	92 95       	swap	r25
   1631e:	90 7f       	andi	r25, 0xF0	; 240
   16320:	81 81       	ldd	r24, Z+1	; 0x01
   16322:	8f 70       	andi	r24, 0x0F	; 15
   16324:	98 0f       	add	r25, r24
   16326:	9d 83       	std	Y+5, r25	; 0x05
		__datetime[5] = (((__date[3] - 0x30) & 0x0F) << 4) + ((__date[4] - 0x30) & 0x0F);
   16328:	93 81       	ldd	r25, Z+3	; 0x03
   1632a:	92 95       	swap	r25
   1632c:	90 7f       	andi	r25, 0xF0	; 240
   1632e:	84 81       	ldd	r24, Z+4	; 0x04
   16330:	8f 70       	andi	r24, 0x0F	; 15
   16332:	98 0f       	add	r25, r24
   16334:	9e 83       	std	Y+6, r25	; 0x06
		__datetime[6] = (((__date[6] - 0x30) & 0x0F) << 4) + ((__date[7] - 0x30) & 0x0F);
   16336:	96 81       	ldd	r25, Z+6	; 0x06
   16338:	92 95       	swap	r25
   1633a:	90 7f       	andi	r25, 0xF0	; 240
   1633c:	87 81       	ldd	r24, Z+7	; 0x07
   1633e:	8f 70       	andi	r24, 0x0F	; 15
   16340:	98 0f       	add	r25, r24
   16342:	9f 83       	std	Y+7, r25	; 0x07

		__datetime[2] = (((__time[0] - 0x30) & 0x0F) << 4) + ((__time[1] - 0x30) & 0x0F);
   16344:	f7 01       	movw	r30, r14
   16346:	90 81       	ld	r25, Z
   16348:	92 95       	swap	r25
   1634a:	90 7f       	andi	r25, 0xF0	; 240
   1634c:	81 81       	ldd	r24, Z+1	; 0x01
   1634e:	8f 70       	andi	r24, 0x0F	; 15
   16350:	98 0f       	add	r25, r24
   16352:	9b 83       	std	Y+3, r25	; 0x03
		__datetime[1] = (((__time[3] - 0x30) & 0x0F) << 4) + ((__time[4] - 0x30) & 0x0F);
   16354:	93 81       	ldd	r25, Z+3	; 0x03
   16356:	92 95       	swap	r25
   16358:	90 7f       	andi	r25, 0xF0	; 240
   1635a:	84 81       	ldd	r24, Z+4	; 0x04
   1635c:	8f 70       	andi	r24, 0x0F	; 15
   1635e:	98 0f       	add	r25, r24
   16360:	9a 83       	std	Y+2, r25	; 0x02
		__datetime[0] = (((__time[6] - 0x30) & 0x0F) << 4) + ((__time[7] - 0x30) & 0x0F);
   16362:	96 81       	ldd	r25, Z+6	; 0x06
   16364:	92 95       	swap	r25
   16366:	90 7f       	andi	r25, 0xF0	; 240
   16368:	87 81       	ldd	r24, Z+7	; 0x07
   1636a:	8f 70       	andi	r24, 0x0F	; 15
   1636c:	98 0f       	add	r25, r24
   1636e:	99 83       	std	Y+1, r25	; 0x01
		_rtc(0, 8, __datetime, __mode);
   16370:	80 e0       	ldi	r24, 0x00	; 0
   16372:	90 e0       	ldi	r25, 0x00	; 0
   16374:	68 e0       	ldi	r22, 0x08	; 8
   16376:	70 e0       	ldi	r23, 0x00	; 0
   16378:	0e 94 b4 b0 	call	0x16168	; 0x16168 <_rtc>
   1637c:	4a c0       	rjmp	.+148    	; 0x16412 <_datetime+0x126>
	}
	else
		if(_rtc(0, 8, __datetime, __mode) != 1){
   1637e:	80 e0       	ldi	r24, 0x00	; 0
   16380:	90 e0       	ldi	r25, 0x00	; 0
   16382:	68 e0       	ldi	r22, 0x08	; 8
   16384:	70 e0       	ldi	r23, 0x00	; 0
   16386:	20 e0       	ldi	r18, 0x00	; 0
   16388:	0e 94 b4 b0 	call	0x16168	; 0x16168 <_rtc>
   1638c:	81 30       	cpi	r24, 0x01	; 1
   1638e:	09 f4       	brne	.+2      	; 0x16392 <_datetime+0xa6>
   16390:	40 c0       	rjmp	.+128    	; 0x16412 <_datetime+0x126>
			__date[0] = (__datetime[4] >> 4) + 0x30;
   16392:	9d 81       	ldd	r25, Y+5	; 0x05
   16394:	89 2f       	mov	r24, r25
   16396:	82 95       	swap	r24
   16398:	8f 70       	andi	r24, 0x0F	; 15
   1639a:	80 5d       	subi	r24, 0xD0	; 208
   1639c:	f8 01       	movw	r30, r16
   1639e:	80 83       	st	Z, r24
			__date[1] = (__datetime[4] & 0x0F) + 0x30;
   163a0:	9f 70       	andi	r25, 0x0F	; 15
   163a2:	90 5d       	subi	r25, 0xD0	; 208
   163a4:	91 83       	std	Z+1, r25	; 0x01
			__date[2] = '/';
   163a6:	2f e2       	ldi	r18, 0x2F	; 47
   163a8:	22 83       	std	Z+2, r18	; 0x02
			__date[3] = (__datetime[5] >> 4) + 0x30;
   163aa:	9e 81       	ldd	r25, Y+6	; 0x06
   163ac:	89 2f       	mov	r24, r25
   163ae:	82 95       	swap	r24
   163b0:	8f 70       	andi	r24, 0x0F	; 15
   163b2:	80 5d       	subi	r24, 0xD0	; 208
   163b4:	83 83       	std	Z+3, r24	; 0x03
			__date[4] = (__datetime[5] & 0x0F) + 0x30;
   163b6:	9f 70       	andi	r25, 0x0F	; 15
   163b8:	90 5d       	subi	r25, 0xD0	; 208
   163ba:	94 83       	std	Z+4, r25	; 0x04
			__date[5] = '/';
   163bc:	25 83       	std	Z+5, r18	; 0x05
			__date[6] = (__datetime[6] >> 4) + 0x30;
   163be:	9f 81       	ldd	r25, Y+7	; 0x07
   163c0:	89 2f       	mov	r24, r25
   163c2:	82 95       	swap	r24
   163c4:	8f 70       	andi	r24, 0x0F	; 15
   163c6:	80 5d       	subi	r24, 0xD0	; 208
   163c8:	86 83       	std	Z+6, r24	; 0x06
			__date[7] = (__datetime[6] & 0x0F) + 0x30;
   163ca:	9f 70       	andi	r25, 0x0F	; 15
   163cc:	90 5d       	subi	r25, 0xD0	; 208
   163ce:	97 83       	std	Z+7, r25	; 0x07
			__date[8] = '\0';
   163d0:	10 86       	std	Z+8, r1	; 0x08

			__time[0] = (__datetime[2] >> 4) + 0x30;
   163d2:	9b 81       	ldd	r25, Y+3	; 0x03
   163d4:	89 2f       	mov	r24, r25
   163d6:	82 95       	swap	r24
   163d8:	8f 70       	andi	r24, 0x0F	; 15
   163da:	80 5d       	subi	r24, 0xD0	; 208
   163dc:	f7 01       	movw	r30, r14
   163de:	80 83       	st	Z, r24
			__time[1] = (__datetime[2] & 0x0F) + 0x30;
   163e0:	9f 70       	andi	r25, 0x0F	; 15
   163e2:	90 5d       	subi	r25, 0xD0	; 208
   163e4:	91 83       	std	Z+1, r25	; 0x01
			__time[2] = ':';
   163e6:	2a e3       	ldi	r18, 0x3A	; 58
   163e8:	22 83       	std	Z+2, r18	; 0x02
			__time[3] = (__datetime[1] >> 4) + 0x30;
   163ea:	9a 81       	ldd	r25, Y+2	; 0x02
   163ec:	89 2f       	mov	r24, r25
   163ee:	82 95       	swap	r24
   163f0:	8f 70       	andi	r24, 0x0F	; 15
   163f2:	80 5d       	subi	r24, 0xD0	; 208
   163f4:	83 83       	std	Z+3, r24	; 0x03
			__time[4] = (__datetime[1] & 0x0F) + 0x30;
   163f6:	9f 70       	andi	r25, 0x0F	; 15
   163f8:	90 5d       	subi	r25, 0xD0	; 208
   163fa:	94 83       	std	Z+4, r25	; 0x04
			__time[5] = ':';
   163fc:	25 83       	std	Z+5, r18	; 0x05
			__time[6] = (__datetime[0] >> 4) + 0x30;
   163fe:	99 81       	ldd	r25, Y+1	; 0x01
   16400:	89 2f       	mov	r24, r25
   16402:	82 95       	swap	r24
   16404:	8f 70       	andi	r24, 0x0F	; 15
   16406:	80 5d       	subi	r24, 0xD0	; 208
   16408:	86 83       	std	Z+6, r24	; 0x06
			__time[7] = (__datetime[0] & 0x0F) + 0x30;
   1640a:	9f 70       	andi	r25, 0x0F	; 15
   1640c:	90 5d       	subi	r25, 0xD0	; 208
   1640e:	97 83       	std	Z+7, r25	; 0x07
			__time[8] = '\0';
   16410:	10 86       	std	Z+8, r1	; 0x08
		}
}
   16412:	64 96       	adiw	r28, 0x14	; 20
   16414:	0f b6       	in	r0, 0x3f	; 63
   16416:	f8 94       	cli
   16418:	de bf       	out	0x3e, r29	; 62
   1641a:	0f be       	out	0x3f, r0	; 63
   1641c:	cd bf       	out	0x3d, r28	; 61
   1641e:	cf 91       	pop	r28
   16420:	df 91       	pop	r29
   16422:	1f 91       	pop	r17
   16424:	0f 91       	pop	r16
   16426:	ff 90       	pop	r15
   16428:	ef 90       	pop	r14
   1642a:	08 95       	ret

0001642c <_day>:

unsigned char _day(void){
   1642c:	df 93       	push	r29
   1642e:	cf 93       	push	r28
   16430:	cd b7       	in	r28, 0x3d	; 61
   16432:	de b7       	in	r29, 0x3e	; 62
   16434:	64 97       	sbiw	r28, 0x14	; 20
   16436:	0f b6       	in	r0, 0x3f	; 63
   16438:	f8 94       	cli
   1643a:	de bf       	out	0x3e, r29	; 62
   1643c:	0f be       	out	0x3f, r0	; 63
   1643e:	cd bf       	out	0x3d, r28	; 61
	char	__datetime[20];

	if(_rtc(0, 8, __datetime, 0) != 1)
   16440:	80 e0       	ldi	r24, 0x00	; 0
   16442:	90 e0       	ldi	r25, 0x00	; 0
   16444:	68 e0       	ldi	r22, 0x08	; 8
   16446:	70 e0       	ldi	r23, 0x00	; 0
   16448:	ae 01       	movw	r20, r28
   1644a:	4f 5f       	subi	r20, 0xFF	; 255
   1644c:	5f 4f       	sbci	r21, 0xFF	; 255
   1644e:	20 e0       	ldi	r18, 0x00	; 0
   16450:	0e 94 b4 b0 	call	0x16168	; 0x16168 <_rtc>
   16454:	81 30       	cpi	r24, 0x01	; 1
   16456:	11 f4       	brne	.+4      	; 0x1645c <_day+0x30>
   16458:	80 e0       	ldi	r24, 0x00	; 0
   1645a:	02 c0       	rjmp	.+4      	; 0x16460 <_day+0x34>
		return __datetime[3] & 0x0F;
   1645c:	8c 81       	ldd	r24, Y+4	; 0x04
   1645e:	8f 70       	andi	r24, 0x0F	; 15
	return 0;
   16460:	64 96       	adiw	r28, 0x14	; 20
   16462:	0f b6       	in	r0, 0x3f	; 63
   16464:	f8 94       	cli
   16466:	de bf       	out	0x3e, r29	; 62
   16468:	0f be       	out	0x3f, r0	; 63
   1646a:	cd bf       	out	0x3d, r28	; 61
   1646c:	cf 91       	pop	r28
   1646e:	df 91       	pop	r29
   16470:	08 95       	ret

00016472 <_uart_baudrate>:
	}

	_uart_baudrate(__com, __baudrate);
}

void _uart_baudrate(unsigned char __com, unsigned long __baudrate){
   16472:	1f 93       	push	r17
   16474:	18 2f       	mov	r17, r24
   16476:	9a 01       	movw	r18, r20
   16478:	ab 01       	movw	r20, r22
	unsigned long __br;

	__br = (unsigned long)((_CPU_DEFAULT + (__baudrate * 8)) / (__baudrate * 16) - 1);
   1647a:	ca 01       	movw	r24, r20
   1647c:	b9 01       	movw	r22, r18
   1647e:	60 50       	subi	r22, 0x00	; 0
   16480:	70 4e       	sbci	r23, 0xE0	; 224
   16482:	83 4e       	sbci	r24, 0xE3	; 227
   16484:	9f 4f       	sbci	r25, 0xFF	; 255
   16486:	f3 e0       	ldi	r31, 0x03	; 3
   16488:	66 0f       	add	r22, r22
   1648a:	77 1f       	adc	r23, r23
   1648c:	88 1f       	adc	r24, r24
   1648e:	99 1f       	adc	r25, r25
   16490:	fa 95       	dec	r31
   16492:	d1 f7       	brne	.-12     	; 0x16488 <_uart_baudrate+0x16>
   16494:	e4 e0       	ldi	r30, 0x04	; 4
   16496:	22 0f       	add	r18, r18
   16498:	33 1f       	adc	r19, r19
   1649a:	44 1f       	adc	r20, r20
   1649c:	55 1f       	adc	r21, r21
   1649e:	ea 95       	dec	r30
   164a0:	d1 f7       	brne	.-12     	; 0x16496 <_uart_baudrate+0x24>
   164a2:	0e 94 5f b7 	call	0x16ebe	; 0x16ebe <__udivmodsi4>
   164a6:	21 50       	subi	r18, 0x01	; 1
   164a8:	30 40       	sbci	r19, 0x00	; 0
   164aa:	40 40       	sbci	r20, 0x00	; 0
   164ac:	50 40       	sbci	r21, 0x00	; 0
   164ae:	bb 27       	eor	r27, r27
   164b0:	a5 2f       	mov	r26, r21
   164b2:	94 2f       	mov	r25, r20
   164b4:	83 2f       	mov	r24, r19

	if(__com){
   164b6:	11 23       	and	r17, r17
   164b8:	29 f0       	breq	.+10     	; 0x164c4 <_uart_baudrate+0x52>
		UBRR1L = __br;
   164ba:	20 93 99 00 	sts	0x0099, r18
		UBRR1H = __br >> 8;
   164be:	80 93 98 00 	sts	0x0098, r24
   164c2:	03 c0       	rjmp	.+6      	; 0x164ca <_uart_baudrate+0x58>
	}
	else{
		UBRR0L = __br;
   164c4:	29 b9       	out	0x09, r18	; 9
		UBRR0H = __br >> 8;
   164c6:	80 93 90 00 	sts	0x0090, r24
	}
}
   164ca:	1f 91       	pop	r17
   164cc:	08 95       	ret

000164ce <_uart_init>:
#include <util/delay.h>
#include <string.h>

#include "UART.h"

void _uart_init(unsigned char __com, unsigned long __baudrate){
   164ce:	98 2f       	mov	r25, r24
	if(__com){
   164d0:	88 23       	and	r24, r24
   164d2:	39 f0       	breq	.+14     	; 0x164e2 <_uart_init+0x14>
		UCSR1B = _BV(RXCIE1) | _BV(RXEN1) | _BV(TXEN1);
   164d4:	88 e9       	ldi	r24, 0x98	; 152
   164d6:	80 93 9a 00 	sts	0x009A, r24
		UCSR1C = _BV(UCSZ11) | _BV(UCSZ10);
   164da:	86 e0       	ldi	r24, 0x06	; 6
   164dc:	80 93 9d 00 	sts	0x009D, r24
   164e0:	05 c0       	rjmp	.+10     	; 0x164ec <_uart_init+0x1e>
	}
	else{
		UCSR0B = _BV(RXCIE0) | _BV(RXEN0) | _BV(TXEN0);
   164e2:	88 e9       	ldi	r24, 0x98	; 152
   164e4:	8a b9       	out	0x0a, r24	; 10
		UCSR0C = _BV(UCSZ01) | _BV(UCSZ00);
   164e6:	86 e0       	ldi	r24, 0x06	; 6
   164e8:	80 93 95 00 	sts	0x0095, r24
	}

	_uart_baudrate(__com, __baudrate);
   164ec:	89 2f       	mov	r24, r25
   164ee:	0e 94 39 b2 	call	0x16472	; 0x16472 <_uart_baudrate>
}
   164f2:	08 95       	ret

000164f4 <_uart>:
		UBRR0H = __br >> 8;
	}
}

unsigned char _uart(unsigned char __com, unsigned char __dir, unsigned char __chr){
	if(__com){
   164f4:	88 23       	and	r24, r24
   164f6:	81 f0       	breq	.+32     	; 0x16518 <_uart+0x24>
		if(__dir){
   164f8:	66 23       	and	r22, r22
   164fa:	39 f0       	breq	.+14     	; 0x1650a <_uart+0x16>
			loop_until_bit_is_set(UCSR1A, UDRE1);
   164fc:	80 91 9b 00 	lds	r24, 0x009B
   16500:	85 ff       	sbrs	r24, 5
   16502:	fc cf       	rjmp	.-8      	; 0x164fc <_uart+0x8>
			UDR1 = __chr;
   16504:	40 93 9c 00 	sts	0x009C, r20
   16508:	0c c0       	rjmp	.+24     	; 0x16522 <_uart+0x2e>
		}
		else{
			loop_until_bit_is_set(UCSR1A, RXC);
   1650a:	80 91 9b 00 	lds	r24, 0x009B
   1650e:	87 ff       	sbrs	r24, 7
   16510:	fc cf       	rjmp	.-8      	; 0x1650a <_uart+0x16>
			return UDR1;
   16512:	80 91 9c 00 	lds	r24, 0x009C
   16516:	08 95       	ret
		}
	}
	else{
		if(__dir){
   16518:	66 23       	and	r22, r22
   1651a:	29 f0       	breq	.+10     	; 0x16526 <_uart+0x32>
			loop_until_bit_is_set(UCSR0A, UDRE0);
   1651c:	5d 9b       	sbis	0x0b, 5	; 11
   1651e:	fe cf       	rjmp	.-4      	; 0x1651c <_uart+0x28>
			UDR0 = __chr;
   16520:	4c b9       	out	0x0c, r20	; 12
   16522:	81 e0       	ldi	r24, 0x01	; 1
   16524:	08 95       	ret
		}
		else{
			loop_until_bit_is_set(UCSR0A,  RXC);
   16526:	5f 9b       	sbis	0x0b, 7	; 11
   16528:	fe cf       	rjmp	.-4      	; 0x16526 <_uart+0x32>
			return UDR0;
   1652a:	8c b1       	in	r24, 0x0c	; 12
		}

	}

	return 1;
}
   1652c:	08 95       	ret

0001652e <_uart_print>:

void _uart_print(unsigned char __com, unsigned char __ret, char *__str){
   1652e:	0f 93       	push	r16
   16530:	1f 93       	push	r17
   16532:	cf 93       	push	r28
   16534:	df 93       	push	r29
   16536:	18 2f       	mov	r17, r24
   16538:	06 2f       	mov	r16, r22
   1653a:	ea 01       	movw	r28, r20
	if(strlen(__str)>0)
   1653c:	88 81       	ld	r24, Y
   1653e:	88 23       	and	r24, r24
   16540:	31 f4       	brne	.+12     	; 0x1654e <_uart_print+0x20>
   16542:	08 c0       	rjmp	.+16     	; 0x16554 <_uart_print+0x26>
		while(*__str)
		     _uart(__com, 1, *__str++);
   16544:	21 96       	adiw	r28, 0x01	; 1
   16546:	81 2f       	mov	r24, r17
   16548:	61 e0       	ldi	r22, 0x01	; 1
   1654a:	0e 94 7a b2 	call	0x164f4	; 0x164f4 <_uart>
	return 1;
}

void _uart_print(unsigned char __com, unsigned char __ret, char *__str){
	if(strlen(__str)>0)
		while(*__str)
   1654e:	48 81       	ld	r20, Y
   16550:	44 23       	and	r20, r20
   16552:	c1 f7       	brne	.-16     	; 0x16544 <_uart_print+0x16>
		     _uart(__com, 1, *__str++);

	if(__ret){
   16554:	00 23       	and	r16, r16
   16556:	51 f0       	breq	.+20     	; 0x1656c <_uart_print+0x3e>
		_uart(__com, 1, 0x0D);
   16558:	81 2f       	mov	r24, r17
   1655a:	61 e0       	ldi	r22, 0x01	; 1
   1655c:	4d e0       	ldi	r20, 0x0D	; 13
   1655e:	0e 94 7a b2 	call	0x164f4	; 0x164f4 <_uart>
		_uart(__com, 1, 0x0A);
   16562:	81 2f       	mov	r24, r17
   16564:	61 e0       	ldi	r22, 0x01	; 1
   16566:	4a e0       	ldi	r20, 0x0A	; 10
   16568:	0e 94 7a b2 	call	0x164f4	; 0x164f4 <_uart>
   1656c:	82 ee       	ldi	r24, 0xE2	; 226
   1656e:	94 e0       	ldi	r25, 0x04	; 4
   16570:	01 97       	sbiw	r24, 0x01	; 1
   16572:	f1 f7       	brne	.-4      	; 0x16570 <_uart_print+0x42>
	}
	_delay_ms(5);
}
   16574:	df 91       	pop	r29
   16576:	cf 91       	pop	r28
   16578:	1f 91       	pop	r17
   1657a:	0f 91       	pop	r16
   1657c:	08 95       	ret

0001657e <_uart_printf>:

void _uart_printf(unsigned char __com, unsigned char __ret, char *__str){
   1657e:	0f 93       	push	r16
   16580:	1f 93       	push	r17
   16582:	cf 93       	push	r28
   16584:	df 93       	push	r29
   16586:	18 2f       	mov	r17, r24
   16588:	06 2f       	mov	r16, r22
   1658a:	ea 01       	movw	r28, r20
   1658c:	07 c0       	rjmp	.+14     	; 0x1659c <_uart_printf+0x1e>
	while(pgm_read_byte(&(*__str)))
		_uart(__com, 1, pgm_read_byte(&(*__str++)));
   1658e:	21 96       	adiw	r28, 0x01	; 1
   16590:	f9 01       	movw	r30, r18
   16592:	44 91       	lpm	r20, Z+
   16594:	81 2f       	mov	r24, r17
   16596:	61 e0       	ldi	r22, 0x01	; 1
   16598:	0e 94 7a b2 	call	0x164f4	; 0x164f4 <_uart>
   1659c:	9e 01       	movw	r18, r28
	}
	_delay_ms(5);
}

void _uart_printf(unsigned char __com, unsigned char __ret, char *__str){
	while(pgm_read_byte(&(*__str)))
   1659e:	fe 01       	movw	r30, r28
   165a0:	84 91       	lpm	r24, Z+
   165a2:	88 23       	and	r24, r24
   165a4:	a1 f7       	brne	.-24     	; 0x1658e <_uart_printf+0x10>
		_uart(__com, 1, pgm_read_byte(&(*__str++)));

	if(__ret){
   165a6:	00 23       	and	r16, r16
   165a8:	51 f0       	breq	.+20     	; 0x165be <_uart_printf+0x40>
		_uart(__com, 1, 0x0D);
   165aa:	81 2f       	mov	r24, r17
   165ac:	61 e0       	ldi	r22, 0x01	; 1
   165ae:	4d e0       	ldi	r20, 0x0D	; 13
   165b0:	0e 94 7a b2 	call	0x164f4	; 0x164f4 <_uart>
		_uart(__com, 1, 0x0A);
   165b4:	81 2f       	mov	r24, r17
   165b6:	61 e0       	ldi	r22, 0x01	; 1
   165b8:	4a e0       	ldi	r20, 0x0A	; 10
   165ba:	0e 94 7a b2 	call	0x164f4	; 0x164f4 <_uart>
   165be:	86 ea       	ldi	r24, 0xA6	; 166
   165c0:	9e e0       	ldi	r25, 0x0E	; 14
   165c2:	01 97       	sbiw	r24, 0x01	; 1
   165c4:	f1 f7       	brne	.-4      	; 0x165c2 <_uart_printf+0x44>
	}
	_delay_ms(15);
}
   165c6:	df 91       	pop	r29
   165c8:	cf 91       	pop	r28
   165ca:	1f 91       	pop	r17
   165cc:	0f 91       	pop	r16
   165ce:	08 95       	ret

000165d0 <Int2Str>:

void Int2Str(char* __string, unsigned long __value){
   165d0:	6f 92       	push	r6
   165d2:	7f 92       	push	r7
   165d4:	8f 92       	push	r8
   165d6:	9f 92       	push	r9
   165d8:	af 92       	push	r10
   165da:	bf 92       	push	r11
   165dc:	cf 92       	push	r12
   165de:	df 92       	push	r13
   165e0:	ef 92       	push	r14
   165e2:	ff 92       	push	r15
   165e4:	0f 93       	push	r16
   165e6:	1f 93       	push	r17
   165e8:	cf 93       	push	r28
   165ea:	df 93       	push	r29
   165ec:	ec 01       	movw	r28, r24
	char			__flag = 0, __i = 0, __count;
	unsigned long	__num, __devider = 1000000000;
	int				__tmp;

	if(__value == 0){
   165ee:	41 15       	cp	r20, r1
   165f0:	51 05       	cpc	r21, r1
   165f2:	61 05       	cpc	r22, r1
   165f4:	71 05       	cpc	r23, r1
   165f6:	21 f4       	brne	.+8      	; 0x16600 <Int2Str+0x30>
		__string[0] = '0';
   165f8:	80 e3       	ldi	r24, 0x30	; 48
   165fa:	88 83       	st	Y, r24
		__string[1] = '\0';
   165fc:	19 82       	std	Y+1, r1	; 0x01
   165fe:	48 c0       	rjmp	.+144    	; 0x16690 <Int2Str+0xc0>
		return;
   16600:	4a 01       	movw	r8, r20
   16602:	5b 01       	movw	r10, r22
   16604:	10 e0       	ldi	r17, 0x00	; 0
   16606:	00 e0       	ldi	r16, 0x00	; 0
   16608:	77 24       	eor	r7, r7
   1660a:	c1 2c       	mov	r12, r1
   1660c:	ba ec       	ldi	r27, 0xCA	; 202
   1660e:	db 2e       	mov	r13, r27
   16610:	ba e9       	ldi	r27, 0x9A	; 154
   16612:	eb 2e       	mov	r14, r27
   16614:	bb e3       	ldi	r27, 0x3B	; 59
   16616:	fb 2e       	mov	r15, r27
			if(!__flag)
				__flag = 1;
		}
		else
			if(__flag)
				__string[__i++] = 0x30;
   16618:	a0 e3       	ldi	r26, 0x30	; 48
   1661a:	6a 2e       	mov	r6, r26
		return;
	}

	__num = __value;
	for(__count = 0; __count < 10; __count++){
		if(__num >= __devider){
   1661c:	8c 14       	cp	r8, r12
   1661e:	9d 04       	cpc	r9, r13
   16620:	ae 04       	cpc	r10, r14
   16622:	bf 04       	cpc	r11, r15
   16624:	d0 f0       	brcs	.+52     	; 0x1665a <Int2Str+0x8a>
			__tmp = (int)(__num / __devider);
   16626:	c5 01       	movw	r24, r10
   16628:	b4 01       	movw	r22, r8
   1662a:	a7 01       	movw	r20, r14
   1662c:	96 01       	movw	r18, r12
   1662e:	0e 94 5f b7 	call	0x16ebe	; 0x16ebe <__udivmodsi4>
   16632:	12 2f       	mov	r17, r18
			__num = __num % __devider;
   16634:	c5 01       	movw	r24, r10
   16636:	b4 01       	movw	r22, r8
   16638:	a7 01       	movw	r20, r14
   1663a:	96 01       	movw	r18, r12
   1663c:	0e 94 5f b7 	call	0x16ebe	; 0x16ebe <__udivmodsi4>
   16640:	ac 01       	movw	r20, r24
   16642:	cb 01       	movw	r24, r22
   16644:	da 01       	movw	r26, r20
   16646:	4c 01       	movw	r8, r24
   16648:	5d 01       	movw	r10, r26
			__string[__i++] = __tmp + 0x30;
   1664a:	fe 01       	movw	r30, r28
   1664c:	e0 0f       	add	r30, r16
   1664e:	f1 1d       	adc	r31, r1
   16650:	10 5d       	subi	r17, 0xD0	; 208
   16652:	10 83       	st	Z, r17
   16654:	0f 5f       	subi	r16, 0xFF	; 255
   16656:	11 e0       	ldi	r17, 0x01	; 1
   16658:	07 c0       	rjmp	.+14     	; 0x16668 <Int2Str+0x98>
			if(!__flag)
				__flag = 1;
		}
		else
			if(__flag)
   1665a:	11 23       	and	r17, r17
   1665c:	29 f0       	breq	.+10     	; 0x16668 <Int2Str+0x98>
				__string[__i++] = 0x30;
   1665e:	fe 01       	movw	r30, r28
   16660:	e0 0f       	add	r30, r16
   16662:	f1 1d       	adc	r31, r1
   16664:	60 82       	st	Z, r6
   16666:	0f 5f       	subi	r16, 0xFF	; 255
		__string[1] = '\0';
		return;
	}

	__num = __value;
	for(__count = 0; __count < 10; __count++){
   16668:	73 94       	inc	r7
   1666a:	8a e0       	ldi	r24, 0x0A	; 10
   1666c:	78 16       	cp	r7, r24
   1666e:	69 f0       	breq	.+26     	; 0x1668a <Int2Str+0xba>
				__flag = 1;
		}
		else
			if(__flag)
				__string[__i++] = 0x30;
		__devider = __devider / 10;
   16670:	c7 01       	movw	r24, r14
   16672:	b6 01       	movw	r22, r12
   16674:	2a e0       	ldi	r18, 0x0A	; 10
   16676:	30 e0       	ldi	r19, 0x00	; 0
   16678:	40 e0       	ldi	r20, 0x00	; 0
   1667a:	50 e0       	ldi	r21, 0x00	; 0
   1667c:	0e 94 5f b7 	call	0x16ebe	; 0x16ebe <__udivmodsi4>
   16680:	c9 01       	movw	r24, r18
   16682:	da 01       	movw	r26, r20
   16684:	6c 01       	movw	r12, r24
   16686:	7d 01       	movw	r14, r26
   16688:	c9 cf       	rjmp	.-110    	; 0x1661c <Int2Str+0x4c>
	}
	__string[__i] = '\0';
   1668a:	c0 0f       	add	r28, r16
   1668c:	d1 1d       	adc	r29, r1
   1668e:	18 82       	st	Y, r1
}
   16690:	df 91       	pop	r29
   16692:	cf 91       	pop	r28
   16694:	1f 91       	pop	r17
   16696:	0f 91       	pop	r16
   16698:	ff 90       	pop	r15
   1669a:	ef 90       	pop	r14
   1669c:	df 90       	pop	r13
   1669e:	cf 90       	pop	r12
   166a0:	bf 90       	pop	r11
   166a2:	af 90       	pop	r10
   166a4:	9f 90       	pop	r9
   166a6:	8f 90       	pop	r8
   166a8:	7f 90       	pop	r7
   166aa:	6f 90       	pop	r6
   166ac:	08 95       	ret

000166ae <Str2Int>:

unsigned long Str2Int(char* __string){
   166ae:	6f 92       	push	r6
   166b0:	7f 92       	push	r7
   166b2:	8f 92       	push	r8
   166b4:	9f 92       	push	r9
   166b6:	af 92       	push	r10
   166b8:	bf 92       	push	r11
   166ba:	cf 92       	push	r12
   166bc:	df 92       	push	r13
   166be:	ef 92       	push	r14
   166c0:	ff 92       	push	r15
   166c2:	0f 93       	push	r16
   166c4:	1f 93       	push	r17
   166c6:	cf 93       	push	r28
   166c8:	df 93       	push	r29
   166ca:	ec 01       	movw	r28, r24
	unsigned char	__i, __len;
	unsigned long	__multiplier = 1, __retval = 0;

	__len = strlen(__string);
   166cc:	dc 01       	movw	r26, r24
   166ce:	0d 90       	ld	r0, X+
   166d0:	00 20       	and	r0, r0
   166d2:	e9 f7       	brne	.-6      	; 0x166ce <Str2Int+0x20>
   166d4:	11 97       	sbiw	r26, 0x01	; 1
   166d6:	7a 2e       	mov	r7, r26
   166d8:	78 1a       	sub	r7, r24

	if(__len > 0 && __len < 11){
   166da:	87 2d       	mov	r24, r7
   166dc:	81 50       	subi	r24, 0x01	; 1
   166de:	8a 30       	cpi	r24, 0x0A	; 10
   166e0:	08 f0       	brcs	.+2      	; 0x166e4 <Str2Int+0x36>
   166e2:	64 c0       	rjmp	.+200    	; 0x167ac <Str2Int+0xfe>
   166e4:	4e 01       	movw	r8, r28
   166e6:	fe 01       	movw	r30, r28
		__devider = __devider / 10;
	}
	__string[__i] = '\0';
}

unsigned long Str2Int(char* __string){
   166e8:	6c 2e       	mov	r6, r28
   166ea:	05 c0       	rjmp	.+10     	; 0x166f6 <Str2Int+0x48>

	__len = strlen(__string);

	if(__len > 0 && __len < 11){
		for(__i = 0; __i < __len; __i++)
			if(__string[__i] < 0x30 || __string[__i] > 0x39)
   166ec:	81 91       	ld	r24, Z+
   166ee:	80 53       	subi	r24, 0x30	; 48
   166f0:	8a 30       	cpi	r24, 0x0A	; 10
   166f2:	08 f0       	brcs	.+2      	; 0x166f6 <Str2Int+0x48>
   166f4:	5b c0       	rjmp	.+182    	; 0x167ac <Str2Int+0xfe>
	unsigned long	__multiplier = 1, __retval = 0;

	__len = strlen(__string);

	if(__len > 0 && __len < 11){
		for(__i = 0; __i < __len; __i++)
   166f6:	8e 2f       	mov	r24, r30
   166f8:	86 19       	sub	r24, r6
   166fa:	87 15       	cp	r24, r7
   166fc:	b8 f3       	brcs	.-18     	; 0x166ec <Str2Int+0x3e>
			if(__string[__i] < 0x30 || __string[__i] > 0x39)
				return 0;
		if(__len == 10){
   166fe:	8a e0       	ldi	r24, 0x0A	; 10
   16700:	78 16       	cp	r7, r24
   16702:	f9 f4       	brne	.+62     	; 0x16742 <Str2Int+0x94>
			if(__string[0] < 0x30 || __string[0] > 0x32)
   16704:	98 81       	ld	r25, Y
   16706:	89 2f       	mov	r24, r25
   16708:	80 53       	subi	r24, 0x30	; 48
   1670a:	83 30       	cpi	r24, 0x03	; 3
   1670c:	08 f0       	brcs	.+2      	; 0x16710 <Str2Int+0x62>
   1670e:	4e c0       	rjmp	.+156    	; 0x167ac <Str2Int+0xfe>
				return 0;
			if(__string[0] == 0x32){
   16710:	92 33       	cpi	r25, 0x32	; 50
   16712:	b9 f4       	brne	.+46     	; 0x16742 <Str2Int+0x94>
   16714:	fe 01       	movw	r30, r28
   16716:	91 e0       	ldi	r25, 0x01	; 1
				for(__i = 1; __i < __len; __i++)
					if(__string[__i] < 0x30 || __string[__i] > 0x30)
   16718:	81 81       	ldd	r24, Z+1	; 0x01
   1671a:	80 33       	cpi	r24, 0x30	; 48
   1671c:	09 f0       	breq	.+2      	; 0x16720 <Str2Int+0x72>
   1671e:	46 c0       	rjmp	.+140    	; 0x167ac <Str2Int+0xfe>
				return 0;
		if(__len == 10){
			if(__string[0] < 0x30 || __string[0] > 0x32)
				return 0;
			if(__string[0] == 0x32){
				for(__i = 1; __i < __len; __i++)
   16720:	9f 5f       	subi	r25, 0xFF	; 255
   16722:	31 96       	adiw	r30, 0x01	; 1
   16724:	9a 30       	cpi	r25, 0x0A	; 10
   16726:	c1 f7       	brne	.-16     	; 0x16718 <Str2Int+0x6a>
   16728:	0c c0       	rjmp	.+24     	; 0x16742 <Str2Int+0x94>
					if(__string[__i] < 0x30 || __string[__i] > 0x30)
						return 0;
			}
		}
		for(__i = 0; __i < __len - 1; __i++)
			__multiplier *= 10;
   1672a:	c6 01       	movw	r24, r12
   1672c:	b5 01       	movw	r22, r10
   1672e:	2a e0       	ldi	r18, 0x0A	; 10
   16730:	30 e0       	ldi	r19, 0x00	; 0
   16732:	40 e0       	ldi	r20, 0x00	; 0
   16734:	50 e0       	ldi	r21, 0x00	; 0
   16736:	0e 94 00 b7 	call	0x16e00	; 0x16e00 <__mulsi3>
   1673a:	5b 01       	movw	r10, r22
   1673c:	6c 01       	movw	r12, r24
				for(__i = 1; __i < __len; __i++)
					if(__string[__i] < 0x30 || __string[__i] > 0x30)
						return 0;
			}
		}
		for(__i = 0; __i < __len - 1; __i++)
   1673e:	1f 5f       	subi	r17, 0xFF	; 255
   16740:	09 c0       	rjmp	.+18     	; 0x16754 <Str2Int+0xa6>
   16742:	10 e0       	ldi	r17, 0x00	; 0
   16744:	01 e0       	ldi	r16, 0x01	; 1
   16746:	a0 2e       	mov	r10, r16
   16748:	b1 2c       	mov	r11, r1
   1674a:	c1 2c       	mov	r12, r1
   1674c:	d1 2c       	mov	r13, r1
   1674e:	c7 2d       	mov	r28, r7
   16750:	d0 e0       	ldi	r29, 0x00	; 0
   16752:	21 97       	sbiw	r28, 0x01	; 1
   16754:	81 2f       	mov	r24, r17
   16756:	90 e0       	ldi	r25, 0x00	; 0
   16758:	8c 17       	cp	r24, r28
   1675a:	9d 07       	cpc	r25, r29
   1675c:	34 f3       	brlt	.-52     	; 0x1672a <Str2Int+0x7c>
   1675e:	ee 24       	eor	r14, r14
   16760:	ff 24       	eor	r15, r15
   16762:	87 01       	movw	r16, r14
   16764:	1e c0       	rjmp	.+60     	; 0x167a2 <Str2Int+0xf4>
			__multiplier *= 10;
		for(__i = 0; __i < __len; __i++, __multiplier /= 10)
			__retval += ((unsigned long)(__string[__i] - 0x30) * __multiplier);
   16766:	f4 01       	movw	r30, r8
   16768:	21 91       	ld	r18, Z+
   1676a:	4f 01       	movw	r8, r30
   1676c:	30 e0       	ldi	r19, 0x00	; 0
   1676e:	20 53       	subi	r18, 0x30	; 48
   16770:	30 40       	sbci	r19, 0x00	; 0
   16772:	44 27       	eor	r20, r20
   16774:	37 fd       	sbrc	r19, 7
   16776:	40 95       	com	r20
   16778:	54 2f       	mov	r21, r20
   1677a:	c6 01       	movw	r24, r12
   1677c:	b5 01       	movw	r22, r10
   1677e:	0e 94 00 b7 	call	0x16e00	; 0x16e00 <__mulsi3>
   16782:	e6 0e       	add	r14, r22
   16784:	f7 1e       	adc	r15, r23
   16786:	08 1f       	adc	r16, r24
   16788:	19 1f       	adc	r17, r25
						return 0;
			}
		}
		for(__i = 0; __i < __len - 1; __i++)
			__multiplier *= 10;
		for(__i = 0; __i < __len; __i++, __multiplier /= 10)
   1678a:	c6 01       	movw	r24, r12
   1678c:	b5 01       	movw	r22, r10
   1678e:	2a e0       	ldi	r18, 0x0A	; 10
   16790:	30 e0       	ldi	r19, 0x00	; 0
   16792:	40 e0       	ldi	r20, 0x00	; 0
   16794:	50 e0       	ldi	r21, 0x00	; 0
   16796:	0e 94 5f b7 	call	0x16ebe	; 0x16ebe <__udivmodsi4>
   1679a:	c9 01       	movw	r24, r18
   1679c:	da 01       	movw	r26, r20
   1679e:	5c 01       	movw	r10, r24
   167a0:	6d 01       	movw	r12, r26
   167a2:	88 2d       	mov	r24, r8
   167a4:	86 19       	sub	r24, r6
   167a6:	87 15       	cp	r24, r7
   167a8:	f0 f2       	brcs	.-68     	; 0x16766 <Str2Int+0xb8>
   167aa:	03 c0       	rjmp	.+6      	; 0x167b2 <Str2Int+0x104>
   167ac:	ee 24       	eor	r14, r14
   167ae:	ff 24       	eor	r15, r15
   167b0:	87 01       	movw	r16, r14
			__retval += ((unsigned long)(__string[__i] - 0x30) * __multiplier);
	}
	return __retval;
}
   167b2:	b7 01       	movw	r22, r14
   167b4:	c8 01       	movw	r24, r16
   167b6:	df 91       	pop	r29
   167b8:	cf 91       	pop	r28
   167ba:	1f 91       	pop	r17
   167bc:	0f 91       	pop	r16
   167be:	ff 90       	pop	r15
   167c0:	ef 90       	pop	r14
   167c2:	df 90       	pop	r13
   167c4:	cf 90       	pop	r12
   167c6:	bf 90       	pop	r11
   167c8:	af 90       	pop	r10
   167ca:	9f 90       	pop	r9
   167cc:	8f 90       	pop	r8
   167ce:	7f 90       	pop	r7
   167d0:	6f 90       	pop	r6
   167d2:	08 95       	ret

000167d4 <atoi>:
   167d4:	fc 01       	movw	r30, r24
   167d6:	88 27       	eor	r24, r24
   167d8:	99 27       	eor	r25, r25
   167da:	e8 94       	clt
   167dc:	21 91       	ld	r18, Z+
   167de:	20 32       	cpi	r18, 0x20	; 32
   167e0:	e9 f3       	breq	.-6      	; 0x167dc <atoi+0x8>
   167e2:	29 30       	cpi	r18, 0x09	; 9
   167e4:	10 f0       	brcs	.+4      	; 0x167ea <atoi+0x16>
   167e6:	2e 30       	cpi	r18, 0x0E	; 14
   167e8:	c8 f3       	brcs	.-14     	; 0x167dc <atoi+0x8>
   167ea:	2b 32       	cpi	r18, 0x2B	; 43
   167ec:	41 f0       	breq	.+16     	; 0x167fe <atoi+0x2a>
   167ee:	2d 32       	cpi	r18, 0x2D	; 45
   167f0:	39 f4       	brne	.+14     	; 0x16800 <atoi+0x2c>
   167f2:	68 94       	set
   167f4:	04 c0       	rjmp	.+8      	; 0x167fe <atoi+0x2a>
   167f6:	0e 94 57 b4 	call	0x168ae	; 0x168ae <__mulhi_const_10>
   167fa:	82 0f       	add	r24, r18
   167fc:	91 1d       	adc	r25, r1
   167fe:	21 91       	ld	r18, Z+
   16800:	20 53       	subi	r18, 0x30	; 48
   16802:	2a 30       	cpi	r18, 0x0A	; 10
   16804:	c0 f3       	brcs	.-16     	; 0x167f6 <atoi+0x22>
   16806:	1e f4       	brtc	.+6      	; 0x1680e <atoi+0x3a>
   16808:	90 95       	com	r25
   1680a:	81 95       	neg	r24
   1680c:	9f 4f       	sbci	r25, 0xFF	; 255
   1680e:	08 95       	ret

00016810 <strcpy_P>:
   16810:	fb 01       	movw	r30, r22
   16812:	dc 01       	movw	r26, r24
   16814:	05 90       	lpm	r0, Z+
   16816:	0d 92       	st	X+, r0
   16818:	00 20       	and	r0, r0
   1681a:	e1 f7       	brne	.-8      	; 0x16814 <strcpy_P+0x4>
   1681c:	08 95       	ret

0001681e <strcmp>:
   1681e:	fb 01       	movw	r30, r22
   16820:	dc 01       	movw	r26, r24
   16822:	8d 91       	ld	r24, X+
   16824:	01 90       	ld	r0, Z+
   16826:	80 19       	sub	r24, r0
   16828:	01 10       	cpse	r0, r1
   1682a:	d9 f3       	breq	.-10     	; 0x16822 <strcmp+0x4>
   1682c:	99 0b       	sbc	r25, r25
   1682e:	08 95       	ret

00016830 <strcpy>:
   16830:	fb 01       	movw	r30, r22
   16832:	dc 01       	movw	r26, r24
   16834:	01 90       	ld	r0, Z+
   16836:	0d 92       	st	X+, r0
   16838:	00 20       	and	r0, r0
   1683a:	e1 f7       	brne	.-8      	; 0x16834 <strcpy+0x4>
   1683c:	08 95       	ret

0001683e <__eerd_block>:
   1683e:	a0 e0       	ldi	r26, 0x00	; 0
   16840:	b0 e0       	ldi	r27, 0x00	; 0
   16842:	e5 e2       	ldi	r30, 0x25	; 37
   16844:	f4 eb       	ldi	r31, 0xB4	; 180
   16846:	0c 94 8b b7 	jmp	0x16f16	; 0x16f16 <__prologue_saves__+0x14>
   1684a:	7c 01       	movw	r14, r24
   1684c:	eb 01       	movw	r28, r22
   1684e:	8a 01       	movw	r16, r20
   16850:	69 01       	movw	r12, r18
   16852:	09 c0       	rjmp	.+18     	; 0x16866 <__eerd_block+0x28>
   16854:	ce 01       	movw	r24, r28
   16856:	21 96       	adiw	r28, 0x01	; 1
   16858:	f6 01       	movw	r30, r12
   1685a:	09 95       	icall
   1685c:	f7 01       	movw	r30, r14
   1685e:	81 93       	st	Z+, r24
   16860:	7f 01       	movw	r14, r30
   16862:	01 50       	subi	r16, 0x01	; 1
   16864:	10 40       	sbci	r17, 0x00	; 0
   16866:	01 15       	cp	r16, r1
   16868:	11 05       	cpc	r17, r1
   1686a:	a1 f7       	brne	.-24     	; 0x16854 <__eerd_block+0x16>
   1686c:	cd b7       	in	r28, 0x3d	; 61
   1686e:	de b7       	in	r29, 0x3e	; 62
   16870:	e8 e0       	ldi	r30, 0x08	; 8
   16872:	0c 94 a7 b7 	jmp	0x16f4e	; 0x16f4e <__epilogue_restores__+0x14>

00016876 <__eewr_block>:
   16876:	a0 e0       	ldi	r26, 0x00	; 0
   16878:	b0 e0       	ldi	r27, 0x00	; 0
   1687a:	e1 e4       	ldi	r30, 0x41	; 65
   1687c:	f4 eb       	ldi	r31, 0xB4	; 180
   1687e:	0c 94 8b b7 	jmp	0x16f16	; 0x16f16 <__prologue_saves__+0x14>
   16882:	ec 01       	movw	r28, r24
   16884:	7b 01       	movw	r14, r22
   16886:	8a 01       	movw	r16, r20
   16888:	69 01       	movw	r12, r18
   1688a:	09 c0       	rjmp	.+18     	; 0x1689e <__eewr_block+0x28>
   1688c:	ce 01       	movw	r24, r28
   1688e:	21 96       	adiw	r28, 0x01	; 1
   16890:	f7 01       	movw	r30, r14
   16892:	61 91       	ld	r22, Z+
   16894:	7f 01       	movw	r14, r30
   16896:	f6 01       	movw	r30, r12
   16898:	09 95       	icall
   1689a:	01 50       	subi	r16, 0x01	; 1
   1689c:	10 40       	sbci	r17, 0x00	; 0
   1689e:	01 15       	cp	r16, r1
   168a0:	11 05       	cpc	r17, r1
   168a2:	a1 f7       	brne	.-24     	; 0x1688c <__eewr_block+0x16>
   168a4:	cd b7       	in	r28, 0x3d	; 61
   168a6:	de b7       	in	r29, 0x3e	; 62
   168a8:	e8 e0       	ldi	r30, 0x08	; 8
   168aa:	0c 94 a7 b7 	jmp	0x16f4e	; 0x16f4e <__epilogue_restores__+0x14>

000168ae <__mulhi_const_10>:
   168ae:	7a e0       	ldi	r23, 0x0A	; 10
   168b0:	97 9f       	mul	r25, r23
   168b2:	90 2d       	mov	r25, r0
   168b4:	87 9f       	mul	r24, r23
   168b6:	80 2d       	mov	r24, r0
   168b8:	91 0d       	add	r25, r1
   168ba:	11 24       	eor	r1, r1
   168bc:	08 95       	ret

000168be <sprintf_P>:
   168be:	ae e0       	ldi	r26, 0x0E	; 14
   168c0:	b0 e0       	ldi	r27, 0x00	; 0
   168c2:	e5 e6       	ldi	r30, 0x65	; 101
   168c4:	f4 eb       	ldi	r31, 0xB4	; 180
   168c6:	0c 94 8f b7 	jmp	0x16f1e	; 0x16f1e <__prologue_saves__+0x1c>
   168ca:	0d 89       	ldd	r16, Y+21	; 0x15
   168cc:	1e 89       	ldd	r17, Y+22	; 0x16
   168ce:	8e e0       	ldi	r24, 0x0E	; 14
   168d0:	8c 83       	std	Y+4, r24	; 0x04
   168d2:	1a 83       	std	Y+2, r17	; 0x02
   168d4:	09 83       	std	Y+1, r16	; 0x01
   168d6:	8f ef       	ldi	r24, 0xFF	; 255
   168d8:	9f e7       	ldi	r25, 0x7F	; 127
   168da:	9e 83       	std	Y+6, r25	; 0x06
   168dc:	8d 83       	std	Y+5, r24	; 0x05
   168de:	9e 01       	movw	r18, r28
   168e0:	27 5e       	subi	r18, 0xE7	; 231
   168e2:	3f 4f       	sbci	r19, 0xFF	; 255
   168e4:	ce 01       	movw	r24, r28
   168e6:	01 96       	adiw	r24, 0x01	; 1
   168e8:	6f 89       	ldd	r22, Y+23	; 0x17
   168ea:	78 8d       	ldd	r23, Y+24	; 0x18
   168ec:	a9 01       	movw	r20, r18
   168ee:	0e 94 83 b4 	call	0x16906	; 0x16906 <vfprintf>
   168f2:	2f 81       	ldd	r18, Y+7	; 0x07
   168f4:	38 85       	ldd	r19, Y+8	; 0x08
   168f6:	02 0f       	add	r16, r18
   168f8:	13 1f       	adc	r17, r19
   168fa:	f8 01       	movw	r30, r16
   168fc:	10 82       	st	Z, r1
   168fe:	2e 96       	adiw	r28, 0x0e	; 14
   16900:	e4 e0       	ldi	r30, 0x04	; 4
   16902:	0c 94 ab b7 	jmp	0x16f56	; 0x16f56 <__epilogue_restores__+0x1c>

00016906 <vfprintf>:
   16906:	ab e0       	ldi	r26, 0x0B	; 11
   16908:	b0 e0       	ldi	r27, 0x00	; 0
   1690a:	e9 e8       	ldi	r30, 0x89	; 137
   1690c:	f4 eb       	ldi	r31, 0xB4	; 180
   1690e:	0c 94 81 b7 	jmp	0x16f02	; 0x16f02 <__prologue_saves__>
   16912:	3c 01       	movw	r6, r24
   16914:	2b 01       	movw	r4, r22
   16916:	5a 01       	movw	r10, r20
   16918:	fc 01       	movw	r30, r24
   1691a:	17 82       	std	Z+7, r1	; 0x07
   1691c:	16 82       	std	Z+6, r1	; 0x06
   1691e:	83 81       	ldd	r24, Z+3	; 0x03
   16920:	81 fd       	sbrc	r24, 1
   16922:	03 c0       	rjmp	.+6      	; 0x1692a <vfprintf+0x24>
   16924:	6f ef       	ldi	r22, 0xFF	; 255
   16926:	7f ef       	ldi	r23, 0xFF	; 255
   16928:	c6 c1       	rjmp	.+908    	; 0x16cb6 <vfprintf+0x3b0>
   1692a:	9a e0       	ldi	r25, 0x0A	; 10
   1692c:	89 2e       	mov	r8, r25
   1692e:	1e 01       	movw	r2, r28
   16930:	08 94       	sec
   16932:	21 1c       	adc	r2, r1
   16934:	31 1c       	adc	r3, r1
   16936:	f3 01       	movw	r30, r6
   16938:	23 81       	ldd	r18, Z+3	; 0x03
   1693a:	f2 01       	movw	r30, r4
   1693c:	23 fd       	sbrc	r18, 3
   1693e:	85 91       	lpm	r24, Z+
   16940:	23 ff       	sbrs	r18, 3
   16942:	81 91       	ld	r24, Z+
   16944:	2f 01       	movw	r4, r30
   16946:	88 23       	and	r24, r24
   16948:	09 f4       	brne	.+2      	; 0x1694c <vfprintf+0x46>
   1694a:	b2 c1       	rjmp	.+868    	; 0x16cb0 <vfprintf+0x3aa>
   1694c:	85 32       	cpi	r24, 0x25	; 37
   1694e:	39 f4       	brne	.+14     	; 0x1695e <vfprintf+0x58>
   16950:	23 fd       	sbrc	r18, 3
   16952:	85 91       	lpm	r24, Z+
   16954:	23 ff       	sbrs	r18, 3
   16956:	81 91       	ld	r24, Z+
   16958:	2f 01       	movw	r4, r30
   1695a:	85 32       	cpi	r24, 0x25	; 37
   1695c:	29 f4       	brne	.+10     	; 0x16968 <vfprintf+0x62>
   1695e:	90 e0       	ldi	r25, 0x00	; 0
   16960:	b3 01       	movw	r22, r6
   16962:	0e 94 76 b6 	call	0x16cec	; 0x16cec <fputc>
   16966:	e7 cf       	rjmp	.-50     	; 0x16936 <vfprintf+0x30>
   16968:	98 2f       	mov	r25, r24
   1696a:	ff 24       	eor	r15, r15
   1696c:	ee 24       	eor	r14, r14
   1696e:	99 24       	eor	r9, r9
   16970:	ff e1       	ldi	r31, 0x1F	; 31
   16972:	ff 15       	cp	r31, r15
   16974:	d0 f0       	brcs	.+52     	; 0x169aa <vfprintf+0xa4>
   16976:	9b 32       	cpi	r25, 0x2B	; 43
   16978:	69 f0       	breq	.+26     	; 0x16994 <vfprintf+0x8e>
   1697a:	9c 32       	cpi	r25, 0x2C	; 44
   1697c:	28 f4       	brcc	.+10     	; 0x16988 <vfprintf+0x82>
   1697e:	90 32       	cpi	r25, 0x20	; 32
   16980:	59 f0       	breq	.+22     	; 0x16998 <vfprintf+0x92>
   16982:	93 32       	cpi	r25, 0x23	; 35
   16984:	91 f4       	brne	.+36     	; 0x169aa <vfprintf+0xa4>
   16986:	0e c0       	rjmp	.+28     	; 0x169a4 <vfprintf+0x9e>
   16988:	9d 32       	cpi	r25, 0x2D	; 45
   1698a:	49 f0       	breq	.+18     	; 0x1699e <vfprintf+0x98>
   1698c:	90 33       	cpi	r25, 0x30	; 48
   1698e:	69 f4       	brne	.+26     	; 0x169aa <vfprintf+0xa4>
   16990:	41 e0       	ldi	r20, 0x01	; 1
   16992:	24 c0       	rjmp	.+72     	; 0x169dc <vfprintf+0xd6>
   16994:	52 e0       	ldi	r21, 0x02	; 2
   16996:	f5 2a       	or	r15, r21
   16998:	84 e0       	ldi	r24, 0x04	; 4
   1699a:	f8 2a       	or	r15, r24
   1699c:	28 c0       	rjmp	.+80     	; 0x169ee <vfprintf+0xe8>
   1699e:	98 e0       	ldi	r25, 0x08	; 8
   169a0:	f9 2a       	or	r15, r25
   169a2:	25 c0       	rjmp	.+74     	; 0x169ee <vfprintf+0xe8>
   169a4:	e0 e1       	ldi	r30, 0x10	; 16
   169a6:	fe 2a       	or	r15, r30
   169a8:	22 c0       	rjmp	.+68     	; 0x169ee <vfprintf+0xe8>
   169aa:	f7 fc       	sbrc	r15, 7
   169ac:	29 c0       	rjmp	.+82     	; 0x16a00 <vfprintf+0xfa>
   169ae:	89 2f       	mov	r24, r25
   169b0:	80 53       	subi	r24, 0x30	; 48
   169b2:	8a 30       	cpi	r24, 0x0A	; 10
   169b4:	70 f4       	brcc	.+28     	; 0x169d2 <vfprintf+0xcc>
   169b6:	f6 fe       	sbrs	r15, 6
   169b8:	05 c0       	rjmp	.+10     	; 0x169c4 <vfprintf+0xbe>
   169ba:	98 9c       	mul	r9, r8
   169bc:	90 2c       	mov	r9, r0
   169be:	11 24       	eor	r1, r1
   169c0:	98 0e       	add	r9, r24
   169c2:	15 c0       	rjmp	.+42     	; 0x169ee <vfprintf+0xe8>
   169c4:	e8 9c       	mul	r14, r8
   169c6:	e0 2c       	mov	r14, r0
   169c8:	11 24       	eor	r1, r1
   169ca:	e8 0e       	add	r14, r24
   169cc:	f0 e2       	ldi	r31, 0x20	; 32
   169ce:	ff 2a       	or	r15, r31
   169d0:	0e c0       	rjmp	.+28     	; 0x169ee <vfprintf+0xe8>
   169d2:	9e 32       	cpi	r25, 0x2E	; 46
   169d4:	29 f4       	brne	.+10     	; 0x169e0 <vfprintf+0xda>
   169d6:	f6 fc       	sbrc	r15, 6
   169d8:	6b c1       	rjmp	.+726    	; 0x16cb0 <vfprintf+0x3aa>
   169da:	40 e4       	ldi	r20, 0x40	; 64
   169dc:	f4 2a       	or	r15, r20
   169de:	07 c0       	rjmp	.+14     	; 0x169ee <vfprintf+0xe8>
   169e0:	9c 36       	cpi	r25, 0x6C	; 108
   169e2:	19 f4       	brne	.+6      	; 0x169ea <vfprintf+0xe4>
   169e4:	50 e8       	ldi	r21, 0x80	; 128
   169e6:	f5 2a       	or	r15, r21
   169e8:	02 c0       	rjmp	.+4      	; 0x169ee <vfprintf+0xe8>
   169ea:	98 36       	cpi	r25, 0x68	; 104
   169ec:	49 f4       	brne	.+18     	; 0x16a00 <vfprintf+0xfa>
   169ee:	f2 01       	movw	r30, r4
   169f0:	23 fd       	sbrc	r18, 3
   169f2:	95 91       	lpm	r25, Z+
   169f4:	23 ff       	sbrs	r18, 3
   169f6:	91 91       	ld	r25, Z+
   169f8:	2f 01       	movw	r4, r30
   169fa:	99 23       	and	r25, r25
   169fc:	09 f0       	breq	.+2      	; 0x16a00 <vfprintf+0xfa>
   169fe:	b8 cf       	rjmp	.-144    	; 0x16970 <vfprintf+0x6a>
   16a00:	89 2f       	mov	r24, r25
   16a02:	85 54       	subi	r24, 0x45	; 69
   16a04:	83 30       	cpi	r24, 0x03	; 3
   16a06:	18 f0       	brcs	.+6      	; 0x16a0e <vfprintf+0x108>
   16a08:	80 52       	subi	r24, 0x20	; 32
   16a0a:	83 30       	cpi	r24, 0x03	; 3
   16a0c:	38 f4       	brcc	.+14     	; 0x16a1c <vfprintf+0x116>
   16a0e:	44 e0       	ldi	r20, 0x04	; 4
   16a10:	50 e0       	ldi	r21, 0x00	; 0
   16a12:	a4 0e       	add	r10, r20
   16a14:	b5 1e       	adc	r11, r21
   16a16:	5f e3       	ldi	r21, 0x3F	; 63
   16a18:	59 83       	std	Y+1, r21	; 0x01
   16a1a:	0f c0       	rjmp	.+30     	; 0x16a3a <vfprintf+0x134>
   16a1c:	93 36       	cpi	r25, 0x63	; 99
   16a1e:	31 f0       	breq	.+12     	; 0x16a2c <vfprintf+0x126>
   16a20:	93 37       	cpi	r25, 0x73	; 115
   16a22:	79 f0       	breq	.+30     	; 0x16a42 <vfprintf+0x13c>
   16a24:	93 35       	cpi	r25, 0x53	; 83
   16a26:	09 f0       	breq	.+2      	; 0x16a2a <vfprintf+0x124>
   16a28:	56 c0       	rjmp	.+172    	; 0x16ad6 <vfprintf+0x1d0>
   16a2a:	20 c0       	rjmp	.+64     	; 0x16a6c <vfprintf+0x166>
   16a2c:	f5 01       	movw	r30, r10
   16a2e:	80 81       	ld	r24, Z
   16a30:	89 83       	std	Y+1, r24	; 0x01
   16a32:	42 e0       	ldi	r20, 0x02	; 2
   16a34:	50 e0       	ldi	r21, 0x00	; 0
   16a36:	a4 0e       	add	r10, r20
   16a38:	b5 1e       	adc	r11, r21
   16a3a:	61 01       	movw	r12, r2
   16a3c:	01 e0       	ldi	r16, 0x01	; 1
   16a3e:	10 e0       	ldi	r17, 0x00	; 0
   16a40:	12 c0       	rjmp	.+36     	; 0x16a66 <vfprintf+0x160>
   16a42:	f5 01       	movw	r30, r10
   16a44:	c0 80       	ld	r12, Z
   16a46:	d1 80       	ldd	r13, Z+1	; 0x01
   16a48:	f6 fc       	sbrc	r15, 6
   16a4a:	03 c0       	rjmp	.+6      	; 0x16a52 <vfprintf+0x14c>
   16a4c:	6f ef       	ldi	r22, 0xFF	; 255
   16a4e:	7f ef       	ldi	r23, 0xFF	; 255
   16a50:	02 c0       	rjmp	.+4      	; 0x16a56 <vfprintf+0x150>
   16a52:	69 2d       	mov	r22, r9
   16a54:	70 e0       	ldi	r23, 0x00	; 0
   16a56:	42 e0       	ldi	r20, 0x02	; 2
   16a58:	50 e0       	ldi	r21, 0x00	; 0
   16a5a:	a4 0e       	add	r10, r20
   16a5c:	b5 1e       	adc	r11, r21
   16a5e:	c6 01       	movw	r24, r12
   16a60:	0e 94 6b b6 	call	0x16cd6	; 0x16cd6 <strnlen>
   16a64:	8c 01       	movw	r16, r24
   16a66:	5f e7       	ldi	r21, 0x7F	; 127
   16a68:	f5 22       	and	r15, r21
   16a6a:	14 c0       	rjmp	.+40     	; 0x16a94 <vfprintf+0x18e>
   16a6c:	f5 01       	movw	r30, r10
   16a6e:	c0 80       	ld	r12, Z
   16a70:	d1 80       	ldd	r13, Z+1	; 0x01
   16a72:	f6 fc       	sbrc	r15, 6
   16a74:	03 c0       	rjmp	.+6      	; 0x16a7c <vfprintf+0x176>
   16a76:	6f ef       	ldi	r22, 0xFF	; 255
   16a78:	7f ef       	ldi	r23, 0xFF	; 255
   16a7a:	02 c0       	rjmp	.+4      	; 0x16a80 <vfprintf+0x17a>
   16a7c:	69 2d       	mov	r22, r9
   16a7e:	70 e0       	ldi	r23, 0x00	; 0
   16a80:	42 e0       	ldi	r20, 0x02	; 2
   16a82:	50 e0       	ldi	r21, 0x00	; 0
   16a84:	a4 0e       	add	r10, r20
   16a86:	b5 1e       	adc	r11, r21
   16a88:	c6 01       	movw	r24, r12
   16a8a:	0e 94 60 b6 	call	0x16cc0	; 0x16cc0 <strnlen_P>
   16a8e:	8c 01       	movw	r16, r24
   16a90:	50 e8       	ldi	r21, 0x80	; 128
   16a92:	f5 2a       	or	r15, r21
   16a94:	f3 fe       	sbrs	r15, 3
   16a96:	07 c0       	rjmp	.+14     	; 0x16aa6 <vfprintf+0x1a0>
   16a98:	1a c0       	rjmp	.+52     	; 0x16ace <vfprintf+0x1c8>
   16a9a:	80 e2       	ldi	r24, 0x20	; 32
   16a9c:	90 e0       	ldi	r25, 0x00	; 0
   16a9e:	b3 01       	movw	r22, r6
   16aa0:	0e 94 76 b6 	call	0x16cec	; 0x16cec <fputc>
   16aa4:	ea 94       	dec	r14
   16aa6:	8e 2d       	mov	r24, r14
   16aa8:	90 e0       	ldi	r25, 0x00	; 0
   16aaa:	08 17       	cp	r16, r24
   16aac:	19 07       	cpc	r17, r25
   16aae:	a8 f3       	brcs	.-22     	; 0x16a9a <vfprintf+0x194>
   16ab0:	0e c0       	rjmp	.+28     	; 0x16ace <vfprintf+0x1c8>
   16ab2:	f6 01       	movw	r30, r12
   16ab4:	f7 fc       	sbrc	r15, 7
   16ab6:	85 91       	lpm	r24, Z+
   16ab8:	f7 fe       	sbrs	r15, 7
   16aba:	81 91       	ld	r24, Z+
   16abc:	6f 01       	movw	r12, r30
   16abe:	90 e0       	ldi	r25, 0x00	; 0
   16ac0:	b3 01       	movw	r22, r6
   16ac2:	0e 94 76 b6 	call	0x16cec	; 0x16cec <fputc>
   16ac6:	e1 10       	cpse	r14, r1
   16ac8:	ea 94       	dec	r14
   16aca:	01 50       	subi	r16, 0x01	; 1
   16acc:	10 40       	sbci	r17, 0x00	; 0
   16ace:	01 15       	cp	r16, r1
   16ad0:	11 05       	cpc	r17, r1
   16ad2:	79 f7       	brne	.-34     	; 0x16ab2 <vfprintf+0x1ac>
   16ad4:	ea c0       	rjmp	.+468    	; 0x16caa <vfprintf+0x3a4>
   16ad6:	94 36       	cpi	r25, 0x64	; 100
   16ad8:	11 f0       	breq	.+4      	; 0x16ade <vfprintf+0x1d8>
   16ada:	99 36       	cpi	r25, 0x69	; 105
   16adc:	69 f5       	brne	.+90     	; 0x16b38 <vfprintf+0x232>
   16ade:	f7 fe       	sbrs	r15, 7
   16ae0:	08 c0       	rjmp	.+16     	; 0x16af2 <vfprintf+0x1ec>
   16ae2:	f5 01       	movw	r30, r10
   16ae4:	20 81       	ld	r18, Z
   16ae6:	31 81       	ldd	r19, Z+1	; 0x01
   16ae8:	42 81       	ldd	r20, Z+2	; 0x02
   16aea:	53 81       	ldd	r21, Z+3	; 0x03
   16aec:	84 e0       	ldi	r24, 0x04	; 4
   16aee:	90 e0       	ldi	r25, 0x00	; 0
   16af0:	0a c0       	rjmp	.+20     	; 0x16b06 <vfprintf+0x200>
   16af2:	f5 01       	movw	r30, r10
   16af4:	80 81       	ld	r24, Z
   16af6:	91 81       	ldd	r25, Z+1	; 0x01
   16af8:	9c 01       	movw	r18, r24
   16afa:	44 27       	eor	r20, r20
   16afc:	37 fd       	sbrc	r19, 7
   16afe:	40 95       	com	r20
   16b00:	54 2f       	mov	r21, r20
   16b02:	82 e0       	ldi	r24, 0x02	; 2
   16b04:	90 e0       	ldi	r25, 0x00	; 0
   16b06:	a8 0e       	add	r10, r24
   16b08:	b9 1e       	adc	r11, r25
   16b0a:	9f e6       	ldi	r25, 0x6F	; 111
   16b0c:	f9 22       	and	r15, r25
   16b0e:	57 ff       	sbrs	r21, 7
   16b10:	09 c0       	rjmp	.+18     	; 0x16b24 <vfprintf+0x21e>
   16b12:	50 95       	com	r21
   16b14:	40 95       	com	r20
   16b16:	30 95       	com	r19
   16b18:	21 95       	neg	r18
   16b1a:	3f 4f       	sbci	r19, 0xFF	; 255
   16b1c:	4f 4f       	sbci	r20, 0xFF	; 255
   16b1e:	5f 4f       	sbci	r21, 0xFF	; 255
   16b20:	e0 e8       	ldi	r30, 0x80	; 128
   16b22:	fe 2a       	or	r15, r30
   16b24:	ca 01       	movw	r24, r20
   16b26:	b9 01       	movw	r22, r18
   16b28:	a1 01       	movw	r20, r2
   16b2a:	2a e0       	ldi	r18, 0x0A	; 10
   16b2c:	30 e0       	ldi	r19, 0x00	; 0
   16b2e:	0e 94 a2 b6 	call	0x16d44	; 0x16d44 <__ultoa_invert>
   16b32:	d8 2e       	mov	r13, r24
   16b34:	d2 18       	sub	r13, r2
   16b36:	40 c0       	rjmp	.+128    	; 0x16bb8 <vfprintf+0x2b2>
   16b38:	95 37       	cpi	r25, 0x75	; 117
   16b3a:	29 f4       	brne	.+10     	; 0x16b46 <vfprintf+0x240>
   16b3c:	1f 2d       	mov	r17, r15
   16b3e:	1f 7e       	andi	r17, 0xEF	; 239
   16b40:	2a e0       	ldi	r18, 0x0A	; 10
   16b42:	30 e0       	ldi	r19, 0x00	; 0
   16b44:	1d c0       	rjmp	.+58     	; 0x16b80 <vfprintf+0x27a>
   16b46:	1f 2d       	mov	r17, r15
   16b48:	19 7f       	andi	r17, 0xF9	; 249
   16b4a:	9f 36       	cpi	r25, 0x6F	; 111
   16b4c:	61 f0       	breq	.+24     	; 0x16b66 <vfprintf+0x260>
   16b4e:	90 37       	cpi	r25, 0x70	; 112
   16b50:	20 f4       	brcc	.+8      	; 0x16b5a <vfprintf+0x254>
   16b52:	98 35       	cpi	r25, 0x58	; 88
   16b54:	09 f0       	breq	.+2      	; 0x16b58 <vfprintf+0x252>
   16b56:	ac c0       	rjmp	.+344    	; 0x16cb0 <vfprintf+0x3aa>
   16b58:	0f c0       	rjmp	.+30     	; 0x16b78 <vfprintf+0x272>
   16b5a:	90 37       	cpi	r25, 0x70	; 112
   16b5c:	39 f0       	breq	.+14     	; 0x16b6c <vfprintf+0x266>
   16b5e:	98 37       	cpi	r25, 0x78	; 120
   16b60:	09 f0       	breq	.+2      	; 0x16b64 <vfprintf+0x25e>
   16b62:	a6 c0       	rjmp	.+332    	; 0x16cb0 <vfprintf+0x3aa>
   16b64:	04 c0       	rjmp	.+8      	; 0x16b6e <vfprintf+0x268>
   16b66:	28 e0       	ldi	r18, 0x08	; 8
   16b68:	30 e0       	ldi	r19, 0x00	; 0
   16b6a:	0a c0       	rjmp	.+20     	; 0x16b80 <vfprintf+0x27a>
   16b6c:	10 61       	ori	r17, 0x10	; 16
   16b6e:	14 fd       	sbrc	r17, 4
   16b70:	14 60       	ori	r17, 0x04	; 4
   16b72:	20 e1       	ldi	r18, 0x10	; 16
   16b74:	30 e0       	ldi	r19, 0x00	; 0
   16b76:	04 c0       	rjmp	.+8      	; 0x16b80 <vfprintf+0x27a>
   16b78:	14 fd       	sbrc	r17, 4
   16b7a:	16 60       	ori	r17, 0x06	; 6
   16b7c:	20 e1       	ldi	r18, 0x10	; 16
   16b7e:	32 e0       	ldi	r19, 0x02	; 2
   16b80:	17 ff       	sbrs	r17, 7
   16b82:	08 c0       	rjmp	.+16     	; 0x16b94 <vfprintf+0x28e>
   16b84:	f5 01       	movw	r30, r10
   16b86:	60 81       	ld	r22, Z
   16b88:	71 81       	ldd	r23, Z+1	; 0x01
   16b8a:	82 81       	ldd	r24, Z+2	; 0x02
   16b8c:	93 81       	ldd	r25, Z+3	; 0x03
   16b8e:	44 e0       	ldi	r20, 0x04	; 4
   16b90:	50 e0       	ldi	r21, 0x00	; 0
   16b92:	08 c0       	rjmp	.+16     	; 0x16ba4 <vfprintf+0x29e>
   16b94:	f5 01       	movw	r30, r10
   16b96:	80 81       	ld	r24, Z
   16b98:	91 81       	ldd	r25, Z+1	; 0x01
   16b9a:	bc 01       	movw	r22, r24
   16b9c:	80 e0       	ldi	r24, 0x00	; 0
   16b9e:	90 e0       	ldi	r25, 0x00	; 0
   16ba0:	42 e0       	ldi	r20, 0x02	; 2
   16ba2:	50 e0       	ldi	r21, 0x00	; 0
   16ba4:	a4 0e       	add	r10, r20
   16ba6:	b5 1e       	adc	r11, r21
   16ba8:	a1 01       	movw	r20, r2
   16baa:	0e 94 a2 b6 	call	0x16d44	; 0x16d44 <__ultoa_invert>
   16bae:	d8 2e       	mov	r13, r24
   16bb0:	d2 18       	sub	r13, r2
   16bb2:	8f e7       	ldi	r24, 0x7F	; 127
   16bb4:	f8 2e       	mov	r15, r24
   16bb6:	f1 22       	and	r15, r17
   16bb8:	f6 fe       	sbrs	r15, 6
   16bba:	0b c0       	rjmp	.+22     	; 0x16bd2 <vfprintf+0x2cc>
   16bbc:	5e ef       	ldi	r21, 0xFE	; 254
   16bbe:	f5 22       	and	r15, r21
   16bc0:	d9 14       	cp	r13, r9
   16bc2:	38 f4       	brcc	.+14     	; 0x16bd2 <vfprintf+0x2cc>
   16bc4:	f4 fe       	sbrs	r15, 4
   16bc6:	07 c0       	rjmp	.+14     	; 0x16bd6 <vfprintf+0x2d0>
   16bc8:	f2 fc       	sbrc	r15, 2
   16bca:	05 c0       	rjmp	.+10     	; 0x16bd6 <vfprintf+0x2d0>
   16bcc:	8f ee       	ldi	r24, 0xEF	; 239
   16bce:	f8 22       	and	r15, r24
   16bd0:	02 c0       	rjmp	.+4      	; 0x16bd6 <vfprintf+0x2d0>
   16bd2:	1d 2d       	mov	r17, r13
   16bd4:	01 c0       	rjmp	.+2      	; 0x16bd8 <vfprintf+0x2d2>
   16bd6:	19 2d       	mov	r17, r9
   16bd8:	f4 fe       	sbrs	r15, 4
   16bda:	0d c0       	rjmp	.+26     	; 0x16bf6 <vfprintf+0x2f0>
   16bdc:	fe 01       	movw	r30, r28
   16bde:	ed 0d       	add	r30, r13
   16be0:	f1 1d       	adc	r31, r1
   16be2:	80 81       	ld	r24, Z
   16be4:	80 33       	cpi	r24, 0x30	; 48
   16be6:	19 f4       	brne	.+6      	; 0x16bee <vfprintf+0x2e8>
   16be8:	99 ee       	ldi	r25, 0xE9	; 233
   16bea:	f9 22       	and	r15, r25
   16bec:	08 c0       	rjmp	.+16     	; 0x16bfe <vfprintf+0x2f8>
   16bee:	1f 5f       	subi	r17, 0xFF	; 255
   16bf0:	f2 fe       	sbrs	r15, 2
   16bf2:	05 c0       	rjmp	.+10     	; 0x16bfe <vfprintf+0x2f8>
   16bf4:	03 c0       	rjmp	.+6      	; 0x16bfc <vfprintf+0x2f6>
   16bf6:	8f 2d       	mov	r24, r15
   16bf8:	86 78       	andi	r24, 0x86	; 134
   16bfa:	09 f0       	breq	.+2      	; 0x16bfe <vfprintf+0x2f8>
   16bfc:	1f 5f       	subi	r17, 0xFF	; 255
   16bfe:	0f 2d       	mov	r16, r15
   16c00:	f3 fc       	sbrc	r15, 3
   16c02:	14 c0       	rjmp	.+40     	; 0x16c2c <vfprintf+0x326>
   16c04:	f0 fe       	sbrs	r15, 0
   16c06:	0f c0       	rjmp	.+30     	; 0x16c26 <vfprintf+0x320>
   16c08:	1e 15       	cp	r17, r14
   16c0a:	10 f0       	brcs	.+4      	; 0x16c10 <vfprintf+0x30a>
   16c0c:	9d 2c       	mov	r9, r13
   16c0e:	0b c0       	rjmp	.+22     	; 0x16c26 <vfprintf+0x320>
   16c10:	9d 2c       	mov	r9, r13
   16c12:	9e 0c       	add	r9, r14
   16c14:	91 1a       	sub	r9, r17
   16c16:	1e 2d       	mov	r17, r14
   16c18:	06 c0       	rjmp	.+12     	; 0x16c26 <vfprintf+0x320>
   16c1a:	80 e2       	ldi	r24, 0x20	; 32
   16c1c:	90 e0       	ldi	r25, 0x00	; 0
   16c1e:	b3 01       	movw	r22, r6
   16c20:	0e 94 76 b6 	call	0x16cec	; 0x16cec <fputc>
   16c24:	1f 5f       	subi	r17, 0xFF	; 255
   16c26:	1e 15       	cp	r17, r14
   16c28:	c0 f3       	brcs	.-16     	; 0x16c1a <vfprintf+0x314>
   16c2a:	04 c0       	rjmp	.+8      	; 0x16c34 <vfprintf+0x32e>
   16c2c:	1e 15       	cp	r17, r14
   16c2e:	10 f4       	brcc	.+4      	; 0x16c34 <vfprintf+0x32e>
   16c30:	e1 1a       	sub	r14, r17
   16c32:	01 c0       	rjmp	.+2      	; 0x16c36 <vfprintf+0x330>
   16c34:	ee 24       	eor	r14, r14
   16c36:	04 ff       	sbrs	r16, 4
   16c38:	0f c0       	rjmp	.+30     	; 0x16c58 <vfprintf+0x352>
   16c3a:	80 e3       	ldi	r24, 0x30	; 48
   16c3c:	90 e0       	ldi	r25, 0x00	; 0
   16c3e:	b3 01       	movw	r22, r6
   16c40:	0e 94 76 b6 	call	0x16cec	; 0x16cec <fputc>
   16c44:	02 ff       	sbrs	r16, 2
   16c46:	1d c0       	rjmp	.+58     	; 0x16c82 <vfprintf+0x37c>
   16c48:	01 fd       	sbrc	r16, 1
   16c4a:	03 c0       	rjmp	.+6      	; 0x16c52 <vfprintf+0x34c>
   16c4c:	88 e7       	ldi	r24, 0x78	; 120
   16c4e:	90 e0       	ldi	r25, 0x00	; 0
   16c50:	0e c0       	rjmp	.+28     	; 0x16c6e <vfprintf+0x368>
   16c52:	88 e5       	ldi	r24, 0x58	; 88
   16c54:	90 e0       	ldi	r25, 0x00	; 0
   16c56:	0b c0       	rjmp	.+22     	; 0x16c6e <vfprintf+0x368>
   16c58:	80 2f       	mov	r24, r16
   16c5a:	86 78       	andi	r24, 0x86	; 134
   16c5c:	91 f0       	breq	.+36     	; 0x16c82 <vfprintf+0x37c>
   16c5e:	01 ff       	sbrs	r16, 1
   16c60:	02 c0       	rjmp	.+4      	; 0x16c66 <vfprintf+0x360>
   16c62:	8b e2       	ldi	r24, 0x2B	; 43
   16c64:	01 c0       	rjmp	.+2      	; 0x16c68 <vfprintf+0x362>
   16c66:	80 e2       	ldi	r24, 0x20	; 32
   16c68:	f7 fc       	sbrc	r15, 7
   16c6a:	8d e2       	ldi	r24, 0x2D	; 45
   16c6c:	90 e0       	ldi	r25, 0x00	; 0
   16c6e:	b3 01       	movw	r22, r6
   16c70:	0e 94 76 b6 	call	0x16cec	; 0x16cec <fputc>
   16c74:	06 c0       	rjmp	.+12     	; 0x16c82 <vfprintf+0x37c>
   16c76:	80 e3       	ldi	r24, 0x30	; 48
   16c78:	90 e0       	ldi	r25, 0x00	; 0
   16c7a:	b3 01       	movw	r22, r6
   16c7c:	0e 94 76 b6 	call	0x16cec	; 0x16cec <fputc>
   16c80:	9a 94       	dec	r9
   16c82:	d9 14       	cp	r13, r9
   16c84:	c0 f3       	brcs	.-16     	; 0x16c76 <vfprintf+0x370>
   16c86:	da 94       	dec	r13
   16c88:	f1 01       	movw	r30, r2
   16c8a:	ed 0d       	add	r30, r13
   16c8c:	f1 1d       	adc	r31, r1
   16c8e:	80 81       	ld	r24, Z
   16c90:	90 e0       	ldi	r25, 0x00	; 0
   16c92:	b3 01       	movw	r22, r6
   16c94:	0e 94 76 b6 	call	0x16cec	; 0x16cec <fputc>
   16c98:	dd 20       	and	r13, r13
   16c9a:	a9 f7       	brne	.-22     	; 0x16c86 <vfprintf+0x380>
   16c9c:	06 c0       	rjmp	.+12     	; 0x16caa <vfprintf+0x3a4>
   16c9e:	80 e2       	ldi	r24, 0x20	; 32
   16ca0:	90 e0       	ldi	r25, 0x00	; 0
   16ca2:	b3 01       	movw	r22, r6
   16ca4:	0e 94 76 b6 	call	0x16cec	; 0x16cec <fputc>
   16ca8:	ea 94       	dec	r14
   16caa:	ee 20       	and	r14, r14
   16cac:	c1 f7       	brne	.-16     	; 0x16c9e <vfprintf+0x398>
   16cae:	43 ce       	rjmp	.-890    	; 0x16936 <vfprintf+0x30>
   16cb0:	f3 01       	movw	r30, r6
   16cb2:	66 81       	ldd	r22, Z+6	; 0x06
   16cb4:	77 81       	ldd	r23, Z+7	; 0x07
   16cb6:	cb 01       	movw	r24, r22
   16cb8:	2b 96       	adiw	r28, 0x0b	; 11
   16cba:	e2 e1       	ldi	r30, 0x12	; 18
   16cbc:	0c 94 9d b7 	jmp	0x16f3a	; 0x16f3a <__epilogue_restores__>

00016cc0 <strnlen_P>:
   16cc0:	fc 01       	movw	r30, r24
   16cc2:	05 90       	lpm	r0, Z+
   16cc4:	61 50       	subi	r22, 0x01	; 1
   16cc6:	70 40       	sbci	r23, 0x00	; 0
   16cc8:	01 10       	cpse	r0, r1
   16cca:	d8 f7       	brcc	.-10     	; 0x16cc2 <strnlen_P+0x2>
   16ccc:	80 95       	com	r24
   16cce:	90 95       	com	r25
   16cd0:	8e 0f       	add	r24, r30
   16cd2:	9f 1f       	adc	r25, r31
   16cd4:	08 95       	ret

00016cd6 <strnlen>:
   16cd6:	fc 01       	movw	r30, r24
   16cd8:	61 50       	subi	r22, 0x01	; 1
   16cda:	70 40       	sbci	r23, 0x00	; 0
   16cdc:	01 90       	ld	r0, Z+
   16cde:	01 10       	cpse	r0, r1
   16ce0:	d8 f7       	brcc	.-10     	; 0x16cd8 <strnlen+0x2>
   16ce2:	80 95       	com	r24
   16ce4:	90 95       	com	r25
   16ce6:	8e 0f       	add	r24, r30
   16ce8:	9f 1f       	adc	r25, r31
   16cea:	08 95       	ret

00016cec <fputc>:
   16cec:	0f 93       	push	r16
   16cee:	1f 93       	push	r17
   16cf0:	cf 93       	push	r28
   16cf2:	df 93       	push	r29
   16cf4:	8c 01       	movw	r16, r24
   16cf6:	eb 01       	movw	r28, r22
   16cf8:	8b 81       	ldd	r24, Y+3	; 0x03
   16cfa:	81 ff       	sbrs	r24, 1
   16cfc:	1b c0       	rjmp	.+54     	; 0x16d34 <fputc+0x48>
   16cfe:	82 ff       	sbrs	r24, 2
   16d00:	0d c0       	rjmp	.+26     	; 0x16d1c <fputc+0x30>
   16d02:	2e 81       	ldd	r18, Y+6	; 0x06
   16d04:	3f 81       	ldd	r19, Y+7	; 0x07
   16d06:	8c 81       	ldd	r24, Y+4	; 0x04
   16d08:	9d 81       	ldd	r25, Y+5	; 0x05
   16d0a:	28 17       	cp	r18, r24
   16d0c:	39 07       	cpc	r19, r25
   16d0e:	64 f4       	brge	.+24     	; 0x16d28 <fputc+0x3c>
   16d10:	e8 81       	ld	r30, Y
   16d12:	f9 81       	ldd	r31, Y+1	; 0x01
   16d14:	01 93       	st	Z+, r16
   16d16:	f9 83       	std	Y+1, r31	; 0x01
   16d18:	e8 83       	st	Y, r30
   16d1a:	06 c0       	rjmp	.+12     	; 0x16d28 <fputc+0x3c>
   16d1c:	e8 85       	ldd	r30, Y+8	; 0x08
   16d1e:	f9 85       	ldd	r31, Y+9	; 0x09
   16d20:	80 2f       	mov	r24, r16
   16d22:	09 95       	icall
   16d24:	89 2b       	or	r24, r25
   16d26:	31 f4       	brne	.+12     	; 0x16d34 <fputc+0x48>
   16d28:	8e 81       	ldd	r24, Y+6	; 0x06
   16d2a:	9f 81       	ldd	r25, Y+7	; 0x07
   16d2c:	01 96       	adiw	r24, 0x01	; 1
   16d2e:	9f 83       	std	Y+7, r25	; 0x07
   16d30:	8e 83       	std	Y+6, r24	; 0x06
   16d32:	02 c0       	rjmp	.+4      	; 0x16d38 <fputc+0x4c>
   16d34:	0f ef       	ldi	r16, 0xFF	; 255
   16d36:	1f ef       	ldi	r17, 0xFF	; 255
   16d38:	c8 01       	movw	r24, r16
   16d3a:	df 91       	pop	r29
   16d3c:	cf 91       	pop	r28
   16d3e:	1f 91       	pop	r17
   16d40:	0f 91       	pop	r16
   16d42:	08 95       	ret

00016d44 <__ultoa_invert>:
   16d44:	fa 01       	movw	r30, r20
   16d46:	aa 27       	eor	r26, r26
   16d48:	28 30       	cpi	r18, 0x08	; 8
   16d4a:	51 f1       	breq	.+84     	; 0x16da0 <__ultoa_invert+0x5c>
   16d4c:	20 31       	cpi	r18, 0x10	; 16
   16d4e:	81 f1       	breq	.+96     	; 0x16db0 <__ultoa_invert+0x6c>
   16d50:	e8 94       	clt
   16d52:	6f 93       	push	r22
   16d54:	6e 7f       	andi	r22, 0xFE	; 254
   16d56:	6e 5f       	subi	r22, 0xFE	; 254
   16d58:	7f 4f       	sbci	r23, 0xFF	; 255
   16d5a:	8f 4f       	sbci	r24, 0xFF	; 255
   16d5c:	9f 4f       	sbci	r25, 0xFF	; 255
   16d5e:	af 4f       	sbci	r26, 0xFF	; 255
   16d60:	b1 e0       	ldi	r27, 0x01	; 1
   16d62:	3e d0       	rcall	.+124    	; 0x16de0 <__ultoa_invert+0x9c>
   16d64:	b4 e0       	ldi	r27, 0x04	; 4
   16d66:	3c d0       	rcall	.+120    	; 0x16de0 <__ultoa_invert+0x9c>
   16d68:	67 0f       	add	r22, r23
   16d6a:	78 1f       	adc	r23, r24
   16d6c:	89 1f       	adc	r24, r25
   16d6e:	9a 1f       	adc	r25, r26
   16d70:	a1 1d       	adc	r26, r1
   16d72:	68 0f       	add	r22, r24
   16d74:	79 1f       	adc	r23, r25
   16d76:	8a 1f       	adc	r24, r26
   16d78:	91 1d       	adc	r25, r1
   16d7a:	a1 1d       	adc	r26, r1
   16d7c:	6a 0f       	add	r22, r26
   16d7e:	71 1d       	adc	r23, r1
   16d80:	81 1d       	adc	r24, r1
   16d82:	91 1d       	adc	r25, r1
   16d84:	a1 1d       	adc	r26, r1
   16d86:	20 d0       	rcall	.+64     	; 0x16dc8 <__ultoa_invert+0x84>
   16d88:	09 f4       	brne	.+2      	; 0x16d8c <__ultoa_invert+0x48>
   16d8a:	68 94       	set
   16d8c:	3f 91       	pop	r19
   16d8e:	2a e0       	ldi	r18, 0x0A	; 10
   16d90:	26 9f       	mul	r18, r22
   16d92:	11 24       	eor	r1, r1
   16d94:	30 19       	sub	r19, r0
   16d96:	30 5d       	subi	r19, 0xD0	; 208
   16d98:	31 93       	st	Z+, r19
   16d9a:	de f6       	brtc	.-74     	; 0x16d52 <__ultoa_invert+0xe>
   16d9c:	cf 01       	movw	r24, r30
   16d9e:	08 95       	ret
   16da0:	46 2f       	mov	r20, r22
   16da2:	47 70       	andi	r20, 0x07	; 7
   16da4:	40 5d       	subi	r20, 0xD0	; 208
   16da6:	41 93       	st	Z+, r20
   16da8:	b3 e0       	ldi	r27, 0x03	; 3
   16daa:	0f d0       	rcall	.+30     	; 0x16dca <__ultoa_invert+0x86>
   16dac:	c9 f7       	brne	.-14     	; 0x16da0 <__ultoa_invert+0x5c>
   16dae:	f6 cf       	rjmp	.-20     	; 0x16d9c <__ultoa_invert+0x58>
   16db0:	46 2f       	mov	r20, r22
   16db2:	4f 70       	andi	r20, 0x0F	; 15
   16db4:	40 5d       	subi	r20, 0xD0	; 208
   16db6:	4a 33       	cpi	r20, 0x3A	; 58
   16db8:	18 f0       	brcs	.+6      	; 0x16dc0 <__ultoa_invert+0x7c>
   16dba:	49 5d       	subi	r20, 0xD9	; 217
   16dbc:	31 fd       	sbrc	r19, 1
   16dbe:	40 52       	subi	r20, 0x20	; 32
   16dc0:	41 93       	st	Z+, r20
   16dc2:	02 d0       	rcall	.+4      	; 0x16dc8 <__ultoa_invert+0x84>
   16dc4:	a9 f7       	brne	.-22     	; 0x16db0 <__ultoa_invert+0x6c>
   16dc6:	ea cf       	rjmp	.-44     	; 0x16d9c <__ultoa_invert+0x58>
   16dc8:	b4 e0       	ldi	r27, 0x04	; 4
   16dca:	a6 95       	lsr	r26
   16dcc:	97 95       	ror	r25
   16dce:	87 95       	ror	r24
   16dd0:	77 95       	ror	r23
   16dd2:	67 95       	ror	r22
   16dd4:	ba 95       	dec	r27
   16dd6:	c9 f7       	brne	.-14     	; 0x16dca <__ultoa_invert+0x86>
   16dd8:	00 97       	sbiw	r24, 0x00	; 0
   16dda:	61 05       	cpc	r22, r1
   16ddc:	71 05       	cpc	r23, r1
   16dde:	08 95       	ret
   16de0:	9b 01       	movw	r18, r22
   16de2:	ac 01       	movw	r20, r24
   16de4:	0a 2e       	mov	r0, r26
   16de6:	06 94       	lsr	r0
   16de8:	57 95       	ror	r21
   16dea:	47 95       	ror	r20
   16dec:	37 95       	ror	r19
   16dee:	27 95       	ror	r18
   16df0:	ba 95       	dec	r27
   16df2:	c9 f7       	brne	.-14     	; 0x16de6 <__ultoa_invert+0xa2>
   16df4:	62 0f       	add	r22, r18
   16df6:	73 1f       	adc	r23, r19
   16df8:	84 1f       	adc	r24, r20
   16dfa:	95 1f       	adc	r25, r21
   16dfc:	a0 1d       	adc	r26, r0
   16dfe:	08 95       	ret

00016e00 <__mulsi3>:
   16e00:	62 9f       	mul	r22, r18
   16e02:	d0 01       	movw	r26, r0
   16e04:	73 9f       	mul	r23, r19
   16e06:	f0 01       	movw	r30, r0
   16e08:	82 9f       	mul	r24, r18
   16e0a:	e0 0d       	add	r30, r0
   16e0c:	f1 1d       	adc	r31, r1
   16e0e:	64 9f       	mul	r22, r20
   16e10:	e0 0d       	add	r30, r0
   16e12:	f1 1d       	adc	r31, r1
   16e14:	92 9f       	mul	r25, r18
   16e16:	f0 0d       	add	r31, r0
   16e18:	83 9f       	mul	r24, r19
   16e1a:	f0 0d       	add	r31, r0
   16e1c:	74 9f       	mul	r23, r20
   16e1e:	f0 0d       	add	r31, r0
   16e20:	65 9f       	mul	r22, r21
   16e22:	f0 0d       	add	r31, r0
   16e24:	99 27       	eor	r25, r25
   16e26:	72 9f       	mul	r23, r18
   16e28:	b0 0d       	add	r27, r0
   16e2a:	e1 1d       	adc	r30, r1
   16e2c:	f9 1f       	adc	r31, r25
   16e2e:	63 9f       	mul	r22, r19
   16e30:	b0 0d       	add	r27, r0
   16e32:	e1 1d       	adc	r30, r1
   16e34:	f9 1f       	adc	r31, r25
   16e36:	bd 01       	movw	r22, r26
   16e38:	cf 01       	movw	r24, r30
   16e3a:	11 24       	eor	r1, r1
   16e3c:	08 95       	ret

00016e3e <__udivmodqi4>:
   16e3e:	99 1b       	sub	r25, r25
   16e40:	79 e0       	ldi	r23, 0x09	; 9
   16e42:	04 c0       	rjmp	.+8      	; 0x16e4c <__udivmodqi4_ep>

00016e44 <__udivmodqi4_loop>:
   16e44:	99 1f       	adc	r25, r25
   16e46:	96 17       	cp	r25, r22
   16e48:	08 f0       	brcs	.+2      	; 0x16e4c <__udivmodqi4_ep>
   16e4a:	96 1b       	sub	r25, r22

00016e4c <__udivmodqi4_ep>:
   16e4c:	88 1f       	adc	r24, r24
   16e4e:	7a 95       	dec	r23
   16e50:	c9 f7       	brne	.-14     	; 0x16e44 <__udivmodqi4_loop>
   16e52:	80 95       	com	r24
   16e54:	08 95       	ret

00016e56 <__divmodqi4>:
   16e56:	87 fb       	bst	r24, 7
   16e58:	08 2e       	mov	r0, r24
   16e5a:	06 26       	eor	r0, r22
   16e5c:	87 fd       	sbrc	r24, 7
   16e5e:	81 95       	neg	r24
   16e60:	67 fd       	sbrc	r22, 7
   16e62:	61 95       	neg	r22
   16e64:	ec df       	rcall	.-40     	; 0x16e3e <__udivmodqi4>
   16e66:	0e f4       	brtc	.+2      	; 0x16e6a <__divmodqi4_1>
   16e68:	91 95       	neg	r25

00016e6a <__divmodqi4_1>:
   16e6a:	07 fc       	sbrc	r0, 7
   16e6c:	81 95       	neg	r24

00016e6e <__divmodqi4_exit>:
   16e6e:	08 95       	ret

00016e70 <__udivmodhi4>:
   16e70:	aa 1b       	sub	r26, r26
   16e72:	bb 1b       	sub	r27, r27
   16e74:	51 e1       	ldi	r21, 0x11	; 17
   16e76:	07 c0       	rjmp	.+14     	; 0x16e86 <__udivmodhi4_ep>

00016e78 <__udivmodhi4_loop>:
   16e78:	aa 1f       	adc	r26, r26
   16e7a:	bb 1f       	adc	r27, r27
   16e7c:	a6 17       	cp	r26, r22
   16e7e:	b7 07       	cpc	r27, r23
   16e80:	10 f0       	brcs	.+4      	; 0x16e86 <__udivmodhi4_ep>
   16e82:	a6 1b       	sub	r26, r22
   16e84:	b7 0b       	sbc	r27, r23

00016e86 <__udivmodhi4_ep>:
   16e86:	88 1f       	adc	r24, r24
   16e88:	99 1f       	adc	r25, r25
   16e8a:	5a 95       	dec	r21
   16e8c:	a9 f7       	brne	.-22     	; 0x16e78 <__udivmodhi4_loop>
   16e8e:	80 95       	com	r24
   16e90:	90 95       	com	r25
   16e92:	bc 01       	movw	r22, r24
   16e94:	cd 01       	movw	r24, r26
   16e96:	08 95       	ret

00016e98 <__divmodhi4>:
   16e98:	97 fb       	bst	r25, 7
   16e9a:	09 2e       	mov	r0, r25
   16e9c:	07 26       	eor	r0, r23
   16e9e:	0a d0       	rcall	.+20     	; 0x16eb4 <__divmodhi4_neg1>
   16ea0:	77 fd       	sbrc	r23, 7
   16ea2:	04 d0       	rcall	.+8      	; 0x16eac <__divmodhi4_neg2>
   16ea4:	e5 df       	rcall	.-54     	; 0x16e70 <__udivmodhi4>
   16ea6:	06 d0       	rcall	.+12     	; 0x16eb4 <__divmodhi4_neg1>
   16ea8:	00 20       	and	r0, r0
   16eaa:	1a f4       	brpl	.+6      	; 0x16eb2 <__divmodhi4_exit>

00016eac <__divmodhi4_neg2>:
   16eac:	70 95       	com	r23
   16eae:	61 95       	neg	r22
   16eb0:	7f 4f       	sbci	r23, 0xFF	; 255

00016eb2 <__divmodhi4_exit>:
   16eb2:	08 95       	ret

00016eb4 <__divmodhi4_neg1>:
   16eb4:	f6 f7       	brtc	.-4      	; 0x16eb2 <__divmodhi4_exit>
   16eb6:	90 95       	com	r25
   16eb8:	81 95       	neg	r24
   16eba:	9f 4f       	sbci	r25, 0xFF	; 255
   16ebc:	08 95       	ret

00016ebe <__udivmodsi4>:
   16ebe:	a1 e2       	ldi	r26, 0x21	; 33
   16ec0:	1a 2e       	mov	r1, r26
   16ec2:	aa 1b       	sub	r26, r26
   16ec4:	bb 1b       	sub	r27, r27
   16ec6:	fd 01       	movw	r30, r26
   16ec8:	0d c0       	rjmp	.+26     	; 0x16ee4 <__udivmodsi4_ep>

00016eca <__udivmodsi4_loop>:
   16eca:	aa 1f       	adc	r26, r26
   16ecc:	bb 1f       	adc	r27, r27
   16ece:	ee 1f       	adc	r30, r30
   16ed0:	ff 1f       	adc	r31, r31
   16ed2:	a2 17       	cp	r26, r18
   16ed4:	b3 07       	cpc	r27, r19
   16ed6:	e4 07       	cpc	r30, r20
   16ed8:	f5 07       	cpc	r31, r21
   16eda:	20 f0       	brcs	.+8      	; 0x16ee4 <__udivmodsi4_ep>
   16edc:	a2 1b       	sub	r26, r18
   16ede:	b3 0b       	sbc	r27, r19
   16ee0:	e4 0b       	sbc	r30, r20
   16ee2:	f5 0b       	sbc	r31, r21

00016ee4 <__udivmodsi4_ep>:
   16ee4:	66 1f       	adc	r22, r22
   16ee6:	77 1f       	adc	r23, r23
   16ee8:	88 1f       	adc	r24, r24
   16eea:	99 1f       	adc	r25, r25
   16eec:	1a 94       	dec	r1
   16eee:	69 f7       	brne	.-38     	; 0x16eca <__udivmodsi4_loop>
   16ef0:	60 95       	com	r22
   16ef2:	70 95       	com	r23
   16ef4:	80 95       	com	r24
   16ef6:	90 95       	com	r25
   16ef8:	9b 01       	movw	r18, r22
   16efa:	ac 01       	movw	r20, r24
   16efc:	bd 01       	movw	r22, r26
   16efe:	cf 01       	movw	r24, r30
   16f00:	08 95       	ret

00016f02 <__prologue_saves__>:
   16f02:	2f 92       	push	r2
   16f04:	3f 92       	push	r3
   16f06:	4f 92       	push	r4
   16f08:	5f 92       	push	r5
   16f0a:	6f 92       	push	r6
   16f0c:	7f 92       	push	r7
   16f0e:	8f 92       	push	r8
   16f10:	9f 92       	push	r9
   16f12:	af 92       	push	r10
   16f14:	bf 92       	push	r11
   16f16:	cf 92       	push	r12
   16f18:	df 92       	push	r13
   16f1a:	ef 92       	push	r14
   16f1c:	ff 92       	push	r15
   16f1e:	0f 93       	push	r16
   16f20:	1f 93       	push	r17
   16f22:	cf 93       	push	r28
   16f24:	df 93       	push	r29
   16f26:	cd b7       	in	r28, 0x3d	; 61
   16f28:	de b7       	in	r29, 0x3e	; 62
   16f2a:	ca 1b       	sub	r28, r26
   16f2c:	db 0b       	sbc	r29, r27
   16f2e:	0f b6       	in	r0, 0x3f	; 63
   16f30:	f8 94       	cli
   16f32:	de bf       	out	0x3e, r29	; 62
   16f34:	0f be       	out	0x3f, r0	; 63
   16f36:	cd bf       	out	0x3d, r28	; 61
   16f38:	09 94       	ijmp

00016f3a <__epilogue_restores__>:
   16f3a:	2a 88       	ldd	r2, Y+18	; 0x12
   16f3c:	39 88       	ldd	r3, Y+17	; 0x11
   16f3e:	48 88       	ldd	r4, Y+16	; 0x10
   16f40:	5f 84       	ldd	r5, Y+15	; 0x0f
   16f42:	6e 84       	ldd	r6, Y+14	; 0x0e
   16f44:	7d 84       	ldd	r7, Y+13	; 0x0d
   16f46:	8c 84       	ldd	r8, Y+12	; 0x0c
   16f48:	9b 84       	ldd	r9, Y+11	; 0x0b
   16f4a:	aa 84       	ldd	r10, Y+10	; 0x0a
   16f4c:	b9 84       	ldd	r11, Y+9	; 0x09
   16f4e:	c8 84       	ldd	r12, Y+8	; 0x08
   16f50:	df 80       	ldd	r13, Y+7	; 0x07
   16f52:	ee 80       	ldd	r14, Y+6	; 0x06
   16f54:	fd 80       	ldd	r15, Y+5	; 0x05
   16f56:	0c 81       	ldd	r16, Y+4	; 0x04
   16f58:	1b 81       	ldd	r17, Y+3	; 0x03
   16f5a:	aa 81       	ldd	r26, Y+2	; 0x02
   16f5c:	b9 81       	ldd	r27, Y+1	; 0x01
   16f5e:	ce 0f       	add	r28, r30
   16f60:	d1 1d       	adc	r29, r1
   16f62:	0f b6       	in	r0, 0x3f	; 63
   16f64:	f8 94       	cli
   16f66:	de bf       	out	0x3e, r29	; 62
   16f68:	0f be       	out	0x3f, r0	; 63
   16f6a:	cd bf       	out	0x3d, r28	; 61
   16f6c:	ed 01       	movw	r28, r26
   16f6e:	08 95       	ret

00016f70 <_exit>:
   16f70:	f8 94       	cli

00016f72 <__stop_program>:
   16f72:	ff cf       	rjmp	.-2      	; 0x16f72 <__stop_program>
